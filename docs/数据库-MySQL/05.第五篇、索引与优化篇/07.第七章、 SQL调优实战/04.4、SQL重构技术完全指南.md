---
title: 4、SQL重构技术完全指南
---
## 📚 目录

1. [SQL重构技术概述](#1-SQL重构技术概述)
2. [查询分解策略](#2-查询分解策略)
3. [条件简化技巧](#3-条件简化技巧)
4. [子查询转换技术](#4-子查询转换技术)
5. [联合查询重构](#5-联合查询重构)
6. [临时表消除技术](#6-临时表消除技术)
7. [排序消除技术](#7-排序消除技术)
8. [函数优化改写](#8-函数优化改写)
9. [CASE WHEN优化](#9-CASE-WHEN优化)
10. [EXISTS IN转换](#10-EXISTS-IN转换)
11. [查询合并技术](#11-查询合并技术)
12. [批量操作优化](#12-批量操作优化)
13. [复杂查询拆分策略](#13-复杂查询拆分策略)
14. [查询逻辑简化技术](#14-查询逻辑简化技术)
15. [核心要点总结](#15-核心要点总结)

---

## 1. 🎯 SQL重构技术概述


### 1.1 什么是SQL重构


**🔸 核心定义**
```
SQL重构：在保持查询结果不变的前提下，重新组织和优化SQL语句的技术
目标：提升查询性能、增强代码可读性、减少资源消耗
本质：通过改变SQL的写法来改变执行计划，让数据库更高效地处理数据
```

### 1.2 为什么需要SQL重构


**💡 性能问题的根源**
```
常见问题：
❌ 复杂嵌套查询执行缓慢
❌ 全表扫描导致响应超时  
❌ 临时表占用大量内存
❌ 重复计算浪费CPU资源
❌ 不合理的连接方式

重构后的效果：
✅ 查询时间从分钟级降到秒级
✅ CPU使用率大幅下降
✅ 内存占用显著减少
✅ 并发能力明显提升
```

### 1.3 SQL重构的基本原则


**⚡ 核心指导思想**
```
性能第一：优先考虑执行效率
等价性：确保重构前后结果完全一致
可读性：保持代码的清晰易懂
可维护性：便于后期修改和扩展
渐进式：先易后难，逐步优化
```

**🎯 重构优先级**
```
1. 🔥 高优先级：全表扫描、笛卡尔积、大量排序
2. 🚨 中优先级：复杂子查询、冗余计算、不必要的函数调用
3. 📈 低优先级：代码美化、逻辑简化、可读性提升
```

### 1.4 重构前的准备工作


**🔍 性能分析步骤**
```
第一步：执行计划分析
EXPLAIN PLAN FOR
SELECT ...

第二步：成本评估
- 查看Cost值
- 分析Rows数量
- 检查操作类型

第三步：资源监控
- CPU使用率
- 内存消耗
- I/O等待时间
- 锁竞争情况
```

---

## 2. 🔧 查询分解策略


### 2.1 什么是查询分解


**🔸 基本概念**
```
查询分解：将一个复杂的大查询拆分成多个简单的小查询
适用场景：复杂的多表连接、嵌套层次深的查询、计算逻辑复杂的SQL
核心思想：化繁为简，各个击破，分步骤获取结果
```

### 2.2 复杂查询的典型问题


**❌ 问题示例：一个"巨无霸"查询**
```sql
-- 糟糕的复杂查询：一次性获取所有数据
SELECT 
    u.user_name,
    u.department,
    p.project_name,
    t.task_name,
    t.status,
    (SELECT COUNT(*) FROM comments c WHERE c.task_id = t.task_id) as comment_count,
    (SELECT AVG(rating) FROM reviews r WHERE r.project_id = p.project_id) as avg_rating,
    CASE 
        WHEN t.deadline < SYSDATE THEN '已逾期'
        WHEN t.deadline < SYSDATE + 7 THEN '即将到期'
        ELSE '正常'
    END as deadline_status
FROM users u
JOIN user_projects up ON u.user_id = up.user_id
JOIN projects p ON up.project_id = p.project_id
JOIN tasks t ON p.project_id = t.project_id
WHERE u.department = '开发部'
    AND p.status = 'ACTIVE'
    AND t.create_time >= TRUNC(SYSDATE) - 30
ORDER BY u.user_name, p.project_name, t.deadline;
```

**⚠️ 这个查询的问题**
```
性能问题：
- 多层嵌套子查询重复执行
- 复杂的多表连接产生大量中间结果
- 排序操作在大数据集上执行

维护问题：
- 逻辑复杂，难以理解和修改
- 任何一个表结构变化都影响整个查询
- 调试困难，无法定位性能瓶颈
```

### 2.3 查询分解的实战技巧


**✅ 分解策略一：按业务逻辑分解**

```sql
-- 第一步：获取用户和项目的基础信息
SELECT 
    u.user_id,
    u.user_name,
    u.department,
    p.project_id,
    p.project_name,
    p.status
FROM users u
JOIN user_projects up ON u.user_id = up.user_id
JOIN projects p ON up.project_id = p.project_id
WHERE u.department = '开发部'
    AND p.status = 'ACTIVE';

-- 第二步：基于第一步结果获取任务信息
SELECT 
    t.task_id,
    t.project_id,
    t.task_name,
    t.status,
    t.deadline,
    t.create_time
FROM tasks t
WHERE t.project_id IN (第一步的project_id列表)
    AND t.create_time >= TRUNC(SYSDATE) - 30;

-- 第三步：批量计算统计信息
SELECT 
    task_id,
    COUNT(*) as comment_count
FROM comments
WHERE task_id IN (第二步的task_id列表)
GROUP BY task_id;

-- 第四步：在应用层组装最终结果
```

**✅ 分解策略二：先过滤后连接**

```sql
-- 原始查询：先连接后过滤（效率低）
SELECT u.user_name, o.order_amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.register_date >= '2024-01-01'
    AND o.order_date >= '2024-06-01';

-- 重构后：先过滤后连接（效率高）
-- 第一步：过滤用户
SELECT user_id, user_name
FROM users
WHERE register_date >= '2024-01-01';

-- 第二步：过滤订单
SELECT user_id, order_amount
FROM orders
WHERE order_date >= '2024-06-01';

-- 第三步：连接已过滤的小数据集
SELECT u.user_name, o.order_amount
FROM (第一步结果) u
JOIN (第二步结果) o ON u.user_id = o.user_id;
```

### 2.4 分解策略的选择标准


**🎯 何时使用查询分解**

| 场景 | **使用分解** | **不使用分解** |
|------|-------------|----------------|
| **数据量** | `超过百万行的多表连接` | `小数据集（几千行以内）` |
| **表数量** | `5张表以上的复杂连接` | `2-3张表的简单连接` |
| **子查询** | `多层嵌套的相关子查询` | `简单的单层子查询` |
| **网络开销** | `本地处理或高速网络` | `远程数据库或慢网络` |
| **业务需求** | `可以接受多次调用` | `必须原子性获取结果` |

**💡 分解的判断准则**
```
适合分解的信号：
🔸 执行计划Cost值超过1000
🔸 查询执行时间超过5秒
🔸 临时表空间使用超过100MB
🔸 CPU使用率持续超过80%

不适合分解的信号：
🔸 数据量小于1万行
🔸 强事务一致性要求
🔸 网络延迟敏感的场景
🔸 实时性要求极高的查询
```

---

## 3. 🎭 条件简化技巧


### 3.1 条件冗余消除


**🔸 识别和消除重复条件**

```sql
-- ❌ 冗余条件的典型案例
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01'
    AND o.order_date <= '2024-12-31'
    AND c.city = '北京'
    AND c.city IN ('北京', '上海', '广州')  -- 冗余！
    AND o.status = 'COMPLETED'
    AND (o.status = 'COMPLETED' OR o.status = 'SHIPPED');  -- 冗余！

-- ✅ 简化后的条件
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01'
    AND o.order_date <= '2024-12-31'
    AND c.city = '北京'
    AND o.status = 'COMPLETED';
```

**💡 冗余条件的识别技巧**
```
常见冗余模式：
1. 精确条件 + 范围条件：city = '北京' AND city IN ('北京', '上海')
2. 重复的逻辑表达式：status = 'A' AND (status = 'A' OR status = 'B')
3. 互相包含的日期范围：date >= '2024-01-01' AND date > '2023-12-31'
4. 多余的NOT NULL检查：已经有其他条件保证非空
```

### 3.2 条件下推优化


**🔸 将过滤条件尽早应用**

```sql
-- ❌ 条件没有下推：在连接后才过滤
SELECT u.user_name, p.product_name, s.sale_amount
FROM users u
JOIN purchases p ON u.user_id = p.user_id
JOIN sales s ON p.product_id = s.product_id
WHERE u.register_date >= '2024-01-01'
    AND s.sale_date >= '2024-06-01';

-- ✅ 条件下推：在连接前先过滤
SELECT u.user_name, p.product_name, s.sale_amount
FROM (
    SELECT user_id, user_name
    FROM users
    WHERE register_date >= '2024-01-01'  -- 条件下推到users表
) u
JOIN purchases p ON u.user_id = p.user_id
JOIN (
    SELECT product_id, sale_amount
    FROM sales
    WHERE sale_date >= '2024-06-01'  -- 条件下推到sales表
) s ON p.product_id = s.product_id;
```

### 3.3 逻辑运算符优化


**🔸 AND/OR条件的重组**

```sql
-- ❌ 低效的OR条件
SELECT *
FROM products
WHERE category = '电子产品' OR category = '数码配件' OR category = '智能设备';

-- ✅ 使用IN操作符
SELECT *
FROM products
WHERE category IN ('电子产品', '数码配件', '智能设备');

-- ❌ 复杂的AND/OR组合
SELECT *
FROM orders
WHERE (status = 'PENDING' AND priority = 'HIGH')
    OR (status = 'PROCESSING' AND priority = 'HIGH')
    OR (status = 'PENDING' AND priority = 'URGENT')
    OR (status = 'PROCESSING' AND priority = 'URGENT');

-- ✅ 提取公共条件
SELECT *
FROM orders
WHERE status IN ('PENDING', 'PROCESSING')
    AND priority IN ('HIGH', 'URGENT');
```

### 3.4 NULL值处理优化


**🔸 高效的NULL值判断**

```sql
-- ❌ 低效的NULL处理
SELECT *
FROM customers
WHERE ISNULL(phone, '') != ''
    AND ISNULL(email, '') != '';

-- ✅ 直接的NULL检查
SELECT *
FROM customers
WHERE phone IS NOT NULL
    AND email IS NOT NULL;

-- ❌ 复杂的CASE处理NULL
SELECT customer_id,
    CASE 
        WHEN phone IS NULL THEN '无电话'
        WHEN phone = '' THEN '空电话'
        ELSE phone
    END as phone_display
FROM customers;

-- ✅ 使用COALESCE简化
SELECT customer_id,
    COALESCE(NULLIF(phone, ''), '无电话') as phone_display
FROM customers;
```

---

## 4. 🔄 子查询转换技术


### 4.1 相关子查询转换为连接


**🔸 问题：相关子查询的性能陷阱**

```
相关子查询的执行过程：
外查询每返回一行 → 内查询执行一次
如果外查询返回10万行 → 内查询执行10万次！
这就是相关子查询性能差的根本原因
```

**❌ 典型的相关子查询**
```sql
-- 查找每个部门工资最高的员工
SELECT e.employee_id, e.name, e.salary, e.department_id
FROM employees e
WHERE e.salary = (
    SELECT MAX(salary)
    FROM employees e2
    WHERE e2.department_id = e.department_id  -- 相关条件
);
```

**✅ 转换为连接查询**
```sql
-- 方法一：使用窗口函数
SELECT employee_id, name, salary, department_id
FROM (
    SELECT employee_id, name, salary, department_id,
        ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn
    FROM employees
) ranked
WHERE rn = 1;

-- 方法二：使用子查询+连接
SELECT e.employee_id, e.name, e.salary, e.department_id
FROM employees e
JOIN (
    SELECT department_id, MAX(salary) as max_salary
    FROM employees
    GROUP BY department_id
) dept_max ON e.department_id = dept_max.department_id 
    AND e.salary = dept_max.max_salary;
```

### 4.2 EXISTS转换技巧


**🔸 EXISTS与IN的选择**

```sql
-- ❌ 相关EXISTS查询
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
        AND o.order_date >= '2024-01-01'
);

-- ✅ 转换为IN查询（当子查询结果集较小时）
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id IN (
    SELECT DISTINCT customer_id
    FROM orders
    WHERE order_date >= '2024-01-01'
);

-- ✅ 转换为连接查询（性能最佳）
SELECT DISTINCT c.customer_id, c.customer_name
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= '2024-01-01';
```

### 4.3 NOT EXISTS的优化


**🔸 查找不存在记录的高效方法**

```sql
-- ❌ NOT EXISTS相关子查询
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE NOT EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
);

-- ✅ 使用LEFT JOIN + IS NULL
SELECT c.customer_id, c.customer_name
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE o.customer_id IS NULL;

-- ✅ 使用NOT IN（注意NULL值问题）
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id NOT IN (
    SELECT customer_id
    FROM orders
    WHERE customer_id IS NOT NULL  -- 关键：排除NULL值
);
```

### 4.4 标量子查询优化


**🔸 返回单个值的子查询优化**

```sql
-- ❌ 重复的标量子查询
SELECT 
    product_id,
    product_name,
    price,
    (SELECT AVG(price) FROM products) as avg_price,
    price - (SELECT AVG(price) FROM products) as price_diff
FROM products;

-- ✅ 使用WITH子句消除重复计算
WITH avg_price AS (
    SELECT AVG(price) as avg_value
    FROM products
)
SELECT 
    product_id,
    product_name,
    price,
    avg_price.avg_value,
    price - avg_price.avg_value as price_diff
FROM products
CROSS JOIN avg_price;
```

---

## 5. 🔗 联合查询重构


### 5.1 UNION优化技术


**🔸 UNION vs UNION ALL的选择**

```sql
-- ❌ 不必要的UNION（自动去重）
SELECT customer_id, customer_name FROM customers WHERE city = '北京'
UNION
SELECT customer_id, customer_name FROM customers WHERE city = '上海';

-- ✅ 使用IN操作符替代
SELECT customer_id, customer_name 
FROM customers 
WHERE city IN ('北京', '上海');

-- ✅ 当确实需要合并不同表且不需要去重时，使用UNION ALL
SELECT 'customer' as type, customer_id as id, customer_name as name FROM customers
UNION ALL
SELECT 'supplier' as type, supplier_id as id, supplier_name as name FROM suppliers;
```

**💡 UNION优化准则**
```
使用UNION ALL的场景：
🔸 确定两个结果集没有重复记录
🔸 业务逻辑允许重复数据
🔸 性能要求高，去重成本大

使用UNION的场景：
🔸 必须消除重复记录
🔸 数据量较小，去重成本可接受
🔸 业务逻辑要求数据唯一性
```

### 5.2 复杂UNION的分解


**🔸 多个UNION的性能问题**

```sql
-- ❌ 复杂的多路UNION
SELECT order_id, 'pending' as status, order_date FROM orders WHERE status = 'PENDING'
UNION
SELECT order_id, 'processing' as status, order_date FROM orders WHERE status = 'PROCESSING'
UNION
SELECT order_id, 'completed' as status, order_date FROM orders WHERE status = 'COMPLETED'
UNION
SELECT order_id, 'cancelled' as status, order_date FROM orders WHERE status = 'CANCELLED';

-- ✅ 简化为单个查询
SELECT order_id, status, order_date 
FROM orders 
WHERE status IN ('PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED');
```

### 5.3 UNION与连接的转换


**🔸 某些UNION可以转换为更高效的连接**

```sql
-- ❌ 使用UNION合并相关数据
SELECT c.customer_id, c.customer_name, 'VIP' as level
FROM customers c
WHERE c.total_amount > 10000
UNION
SELECT c.customer_id, c.customer_name, 'GOLD' as level
FROM customers c
WHERE c.total_amount BETWEEN 5000 AND 10000;

-- ✅ 使用CASE WHEN替代
SELECT customer_id, customer_name,
    CASE 
        WHEN total_amount > 10000 THEN 'VIP'
        WHEN total_amount >= 5000 THEN 'GOLD'
        ELSE 'REGULAR'
    END as level
FROM customers
WHERE total_amount >= 5000;
```

---

## 6. 🗃️ 临时表消除技术


### 6.1 识别隐式临时表


**🔸 什么情况下会产生临时表**

```
产生临时表的常见场景：
📊 ORDER BY子句与索引不匹配
📊 GROUP BY的列没有合适索引
📊 DISTINCT操作在大数据集上
📊 复杂的子查询中间结果
📊 UNION操作的结果合并
📊 窗口函数的分区排序
```

**🔍 临时表的识别方法**
```sql
-- 查看执行计划中的临时表使用
EXPLAIN PLAN FOR
SELECT department, COUNT(*), AVG(salary)
FROM employees
WHERE hire_date >= '2024-01-01'
GROUP BY department
ORDER BY AVG(salary) DESC;

-- 执行计划中寻找这些关键词：
-- "TEMP TABLE", "SORT", "HASH GROUP BY"
```

### 6.2 避免ORDER BY产生的临时表


**✅ 利用索引消除排序**

```sql
-- ❌ 产生临时表的排序
SELECT customer_id, customer_name, register_date
FROM customers
WHERE city = '北京'
ORDER BY register_date DESC;

-- 需要创建复合索引
CREATE INDEX idx_customers_city_date ON customers(city, register_date DESC);

-- ✅ 现在查询不会产生临时表
SELECT customer_id, customer_name, register_date
FROM customers
WHERE city = '北京'
ORDER BY register_date DESC;
```

### 6.3 GROUP BY优化技术


**✅ 减少GROUP BY的开销**

```sql
-- ❌ 低效的GROUP BY
SELECT 
    EXTRACT(YEAR FROM order_date) as year,
    EXTRACT(MONTH FROM order_date) as month,
    COUNT(*) as order_count,
    SUM(order_amount) as total_amount
FROM orders
GROUP BY EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date)
ORDER BY year, month;

-- ✅ 使用计算列索引优化
-- 首先添加计算列
ALTER TABLE orders ADD year_month AS (TO_CHAR(order_date, 'YYYY-MM'));
CREATE INDEX idx_orders_year_month ON orders(year_month);

-- 优化后的查询
SELECT 
    year_month,
    COUNT(*) as order_count,
    SUM(order_amount) as total_amount
FROM orders
GROUP BY year_month
ORDER BY year_month;
```

### 6.4 窗口函数的临时表优化


**✅ 减少窗口函数的内存使用**

```sql
-- ❌ 多个窗口函数重复分区
SELECT 
    employee_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
    AVG(salary) OVER (PARTITION BY department_id) as dept_avg_salary,
    COUNT(*) OVER (PARTITION BY department_id) as dept_count
FROM employees;

-- ✅ 合并窗口规范，减少排序次数
SELECT 
    employee_id,
    salary,
    ROW_NUMBER() OVER w as salary_rank,
    AVG(salary) OVER w as dept_avg_salary,
    COUNT(*) OVER w as dept_count
FROM employees
WINDOW w AS (PARTITION BY department_id ORDER BY salary DESC);
```

---

## 7. 📊 排序消除技术


### 7.1 理解排序的成本


**🔸 排序操作的性能影响**

```
排序的成本分析：
🕐 时间复杂度：O(n log n)
💾 空间复杂度：可能需要临时磁盘空间
📈 资源消耗：CPU密集型操作
🔄 阻塞性：必须等待所有数据后才能开始输出
```

**⚠️ 高成本排序的识别标志**
```
危险信号：
- 执行计划中显示"filesort"
- temp_table_size不足时使用磁盘排序
- ORDER BY字段没有合适索引
- 排序字段包含函数或表达式
```

### 7.2 利用索引消除排序


**✅ 索引顺序与查询顺序匹配**

```sql
-- ❌ 需要排序的查询
SELECT order_id, customer_id, order_date, order_amount
FROM orders
WHERE order_date >= '2024-01-01'
ORDER BY order_date DESC, order_id DESC;

-- 创建匹配的复合索引
CREATE INDEX idx_orders_date_id ON orders(order_date DESC, order_id DESC);

-- ✅ 现在查询直接使用索引顺序，无需排序
```

### 7.3 LIMIT与排序的优化


**✅ 提前结束排序**

```sql
-- ❌ 全量排序后取TOP N
SELECT customer_id, customer_name, total_amount
FROM customers
ORDER BY total_amount DESC
LIMIT 10;

-- ✅ 确保有合适索引支持
CREATE INDEX idx_customers_amount ON customers(total_amount DESC);

-- ✅ 使用子查询限制排序范围
SELECT customer_id, customer_name, total_amount
FROM (
    SELECT customer_id, customer_name, total_amount
    FROM customers
    WHERE total_amount > 1000  -- 先过滤再排序
    ORDER BY total_amount DESC
    LIMIT 10
) top_customers;
```

### 7.4 排序字段的优化


**✅ 避免在排序字段上使用函数**

```sql
-- ❌ 在排序字段上使用函数
SELECT product_id, product_name, price
FROM products
ORDER BY UPPER(product_name);

-- ✅ 使用函数索引
CREATE INDEX idx_products_name_upper ON products(UPPER(product_name));

-- 或者添加冗余列避免函数计算
ALTER TABLE products ADD product_name_upper AS (UPPER(product_name));
CREATE INDEX idx_products_name_upper ON products(product_name_upper);

SELECT product_id, product_name, price
FROM products
ORDER BY product_name_upper;
```

---

## 8. ⚙️ 函数优化改写


### 8.1 标量函数的性能问题


**🔸 为什么函数调用影响性能**

```
函数性能问题的根源：
🔸 每行数据都要执行一次函数
🔸 无法利用索引（除非是函数索引）
🔸 可能阻止查询优化器的优化
🔸 CPU密集型计算增加响应时间
```

### 8.2 日期函数的优化


**❌ 低效的日期函数使用**
```sql
-- 在WHERE条件中使用函数
SELECT *
FROM orders
WHERE YEAR(order_date) = 2024
    AND MONTH(order_date) = 6;

-- 在ORDER BY中使用函数
SELECT *
FROM orders
ORDER BY YEAR(order_date), MONTH(order_date);
```

**✅ 优化后的日期处理**
```sql
-- 使用日期范围代替函数
SELECT *
FROM orders
WHERE order_date >= '2024-06-01'
    AND order_date < '2024-07-01';

-- 添加计算列用于排序
ALTER TABLE orders ADD order_year_month AS (DATE_FORMAT(order_date, '%Y-%m'));
CREATE INDEX idx_orders_year_month ON orders(order_year_month);

SELECT *
FROM orders
ORDER BY order_year_month;
```

### 8.3 字符串函数优化


**✅ 字符串处理的高效方法**

```sql
-- ❌ 使用LIKE进行前缀匹配
SELECT *
FROM products
WHERE UPPER(product_name) LIKE 'IPHONE%';

-- ✅ 创建大写列或函数索引
ALTER TABLE products ADD product_name_upper AS (UPPER(product_name));
CREATE INDEX idx_products_name_upper ON products(product_name_upper);

SELECT *
FROM products
WHERE product_name_upper LIKE 'IPHONE%';

-- ❌ 复杂的字符串处理
SELECT customer_id,
    CONCAT(UPPER(SUBSTRING(first_name, 1, 1)), 
           LOWER(SUBSTRING(first_name, 2)), 
           ' ', 
           UPPER(SUBSTRING(last_name, 1, 1)), 
           LOWER(SUBSTRING(last_name, 2))) as display_name
FROM customers;

-- ✅ 预计算并存储结果
ALTER TABLE customers ADD display_name VARCHAR(100);
UPDATE customers 
SET display_name = CONCAT(UPPER(SUBSTRING(first_name, 1, 1)), 
                         LOWER(SUBSTRING(first_name, 2)), 
                         ' ', 
                         UPPER(SUBSTRING(last_name, 1, 1)), 
                         LOWER(SUBSTRING(last_name, 2)));

-- 创建触发器保持数据同步
CREATE TRIGGER tr_customers_display_name
    BEFORE UPDATE ON customers
    FOR EACH ROW
    SET NEW.display_name = CONCAT(UPPER(SUBSTRING(NEW.first_name, 1, 1)), 
                                 LOWER(SUBSTRING(NEW.first_name, 2)), 
                                 ' ', 
                                 UPPER(SUBSTRING(NEW.last_name, 1, 1)), 
                                 LOWER(SUBSTRING(NEW.last_name, 2)));
```

### 8.4 数学函数优化


**✅ 避免重复的数学计算**

```sql
-- ❌ 重复计算
SELECT 
    product_id,
    price,
    price * 0.1 as tax,
    price + (price * 0.1) as total_price,
    CASE 
        WHEN price + (price * 0.1) > 100 THEN 'expensive'
        ELSE 'affordable'
    END as price_category
FROM products;

-- ✅ 使用子查询避免重复计算
SELECT 
    product_id,
    price,
    tax,
    total_price,
    CASE 
        WHEN total_price > 100 THEN 'expensive'
        ELSE 'affordable'
    END as price_category
FROM (
    SELECT 
        product_id,
        price,
        price * 0.1 as tax,
        price * 1.1 as total_price
    FROM products
) calculated;
```

---

## 9. 🎯 CASE WHEN优化


### 9.1 CASE WHEN的性能特点


**🔸 CASE表达式的执行机制**

```
CASE WHEN的执行顺序：
1. 按顺序评估每个WHEN条件
2. 找到第一个为TRUE的条件后立即返回
3. 如果都不满足，返回ELSE值
4. 没有ELSE且都不满足时返回NULL

性能优化要点：
🔸 将最可能满足的条件放在前面
🔸 避免在CASE中使用复杂表达式
🔸 考虑用连接或子查询替代复杂CASE
```

### 9.2 条件顺序优化


**✅ 按概率排序CASE条件**

```sql
-- ❌ 按逻辑顺序排列（低效）
SELECT 
    customer_id,
    order_amount,
    CASE 
        WHEN order_amount >= 10000 THEN 'VIP'      -- 1%的数据
        WHEN order_amount >= 5000 THEN 'Gold'     -- 5%的数据
        WHEN order_amount >= 1000 THEN 'Silver'   -- 20%的数据
        ELSE 'Regular'                             -- 74%的数据
    END as customer_level
FROM orders;

-- ✅ 按频率排序（高效）
SELECT 
    customer_id,
    order_amount,
    CASE 
        WHEN order_amount < 1000 THEN 'Regular'   -- 74%的数据（最先匹配）
        WHEN order_amount < 5000 THEN 'Silver'    -- 20%的数据
        WHEN order_amount < 10000 THEN 'Gold'     -- 5%的数据
        ELSE 'VIP'                                 -- 1%的数据
    END as customer_level
FROM orders;
```

### 9.3 复杂CASE表达式的简化


**✅ 使用连接替代复杂CASE**

```sql
-- ❌ 复杂的CASE表达式
SELECT 
    product_id,
    category_id,
    CASE category_id
        WHEN 1 THEN '电子产品'
        WHEN 2 THEN '服装配饰'
        WHEN 3 THEN '家居用品'
        WHEN 4 THEN '运动户外'
        WHEN 5 THEN '图书音像'
        WHEN 6 THEN '食品饮料'
        WHEN 7 THEN '美妆个护'
        WHEN 8 THEN '母婴用品'
        WHEN 9 THEN '汽车用品'
        WHEN 10 THEN '数码配件'
        ELSE '其他'
    END as category_name
FROM products;

-- ✅ 使用字典表连接
CREATE TABLE categories (
    category_id INT PRIMARY KEY,
    category_name VARCHAR(50)
);

INSERT INTO categories VALUES
(1, '电子产品'), (2, '服装配饰'), (3, '家居用品'),
(4, '运动户外'), (5, '图书音像'), (6, '食品饮料'),
(7, '美妆个护'), (8, '母婴用品'), (9, '汽车用品'),
(10, '数码配件');

SELECT 
    p.product_id,
    p.category_id,
    COALESCE(c.category_name, '其他') as category_name
FROM products p
LEFT JOIN categories c ON p.category_id = c.category_id;
```

### 9.4 CASE聚合优化


**✅ 条件聚合的高效写法**

```sql
-- ❌ 多个查询分别统计
SELECT COUNT(*) as total_orders FROM orders WHERE order_date >= '2024-01-01';
SELECT COUNT(*) as completed_orders FROM orders WHERE order_date >= '2024-01-01' AND status = 'COMPLETED';
SELECT COUNT(*) as pending_orders FROM orders WHERE order_date >= '2024-01-01' AND status = 'PENDING';

-- ✅ 使用CASE进行条件聚合
SELECT 
    COUNT(*) as total_orders,
    COUNT(CASE WHEN status = 'COMPLETED' THEN 1 END) as completed_orders,
    COUNT(CASE WHEN status = 'PENDING' THEN 1 END) as pending_orders,
    AVG(CASE WHEN status = 'COMPLETED' THEN order_amount END) as avg_completed_amount
FROM orders
WHERE order_date >= '2024-01-01';
```

---

## 10. 🔍 EXISTS IN转换


### 10.1 EXISTS vs IN的性能对比


**🔸 执行机制的差异**

```
EXISTS的执行特点：
✅ 短路求值：找到第一个匹配就停止
✅ 处理NULL值安全
✅ 适合大表关联小表的场景
❌ 每行都要执行子查询

IN的执行特点：
✅ 子查询只执行一次
✅ 适合子查询结果集较小的场景
❌ 遇到NULL值可能出现意外结果
❌ 子查询结果集大时性能差
```

### 10.2 EXISTS转IN的条件


**✅ 安全转换的场景**

```sql
-- ✅ 可以安全转换：子查询无NULL值风险
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
        AND o.order_date >= '2024-01-01'
);

-- 转换为IN（当orders.customer_id不包含NULL时）
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id IN (
    SELECT DISTINCT customer_id
    FROM orders
    WHERE order_date >= '2024-01-01'
        AND customer_id IS NOT NULL  -- 关键：确保无NULL
);
```

### 10.3 IN转EXISTS的优化


**✅ 大结果集场景的优化**

```sql
-- ❌ IN子查询结果集很大时性能差
SELECT p.product_id, p.product_name
FROM products p
WHERE p.product_id IN (
    SELECT product_id
    FROM order_items
    WHERE order_date >= '2024-01-01'  -- 可能返回数百万记录
);

-- ✅ 转换为EXISTS
SELECT p.product_id, p.product_name
FROM products p
WHERE EXISTS (
    SELECT 1
    FROM order_items oi
    WHERE oi.product_id = p.product_id
        AND oi.order_date >= '2024-01-01'
);
```

### 10.4 NOT EXISTS vs NOT IN


**⚠️ NOT IN的NULL值陷阱**

```sql
-- ❌ NOT IN遇到NULL值的问题
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id NOT IN (
    SELECT customer_id
    FROM orders
    WHERE order_date >= '2024-01-01'
);
-- 如果orders.customer_id中有NULL值，这个查询将返回空结果！

-- ✅ 使用NOT EXISTS避免NULL问题
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE NOT EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
        AND o.order_date >= '2024-01-01'
);

-- ✅ 或者在NOT IN中明确排除NULL
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id NOT IN (
    SELECT customer_id
    FROM orders
    WHERE order_date >= '2024-01-01'
        AND customer_id IS NOT NULL  -- 关键：排除NULL值
);
```

---

## 11. 🔄 查询合并技术


### 11.1 相似查询的识别与合并


**🔸 识别可合并的查询模式**

```sql
-- ❌ 多个相似的独立查询
-- 查询1：获取今日订单统计
SELECT COUNT(*) as today_orders
FROM orders
WHERE DATE(order_date) = CURDATE();

-- 查询2：获取今日销售额
SELECT SUM(order_amount) as today_sales
FROM orders
WHERE DATE(order_date) = CURDATE();

-- 查询3：获取今日平均订单金额
SELECT AVG(order_amount) as today_avg
FROM orders
WHERE DATE(order_date) = CURDATE();

-- ✅ 合并为单个查询
SELECT 
    COUNT(*) as today_orders,
    SUM(order_amount) as today_sales,
    AVG(order_amount) as today_avg
FROM orders
WHERE DATE(order_date) = CURDATE();
```

### 11.2 多维度统计的合并


**✅ 复杂统计查询的优化**

```sql
-- ❌ 分别统计不同状态的订单
SELECT 'PENDING' as status, COUNT(*) as count FROM orders WHERE status = 'PENDING';
SELECT 'PROCESSING' as status, COUNT(*) as count FROM orders WHERE status = 'PROCESSING';
SELECT 'COMPLETED' as status, COUNT(*) as count FROM orders WHERE status = 'COMPLETED';
SELECT 'CANCELLED' as status, COUNT(*) as count FROM orders WHERE status = 'CANCELLED';

-- ✅ 使用条件聚合合并
SELECT 
    COUNT(CASE WHEN status = 'PENDING' THEN 1 END) as pending_count,
    COUNT(CASE WHEN status = 'PROCESSING' THEN 1 END) as processing_count,
    COUNT(CASE WHEN status = 'COMPLETED' THEN 1 END) as completed_count,
    COUNT(CASE WHEN status = 'CANCELLED' THEN 1 END) as cancelled_count
FROM orders;

-- ✅ 或者使用GROUP BY获得标准格式
SELECT status, COUNT(*) as count
FROM orders
WHERE status IN ('PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED')
GROUP BY status;
```

### 11.3 关联查询的合并


**✅ 减少表的重复访问**

```sql
-- ❌ 多次访问相同的表
-- 获取客户基本信息
SELECT customer_id, customer_name FROM customers WHERE customer_id = 12345;

-- 获取客户订单数量
SELECT COUNT(*) FROM orders WHERE customer_id = 12345;

-- 获取客户总消费
SELECT SUM(order_amount) FROM orders WHERE customer_id = 12345;

-- 获取客户最后订单日期
SELECT MAX(order_date) FROM orders WHERE customer_id = 12345;

-- ✅ 合并为单个查询
SELECT 
    c.customer_id,
    c.customer_name,
    COUNT(o.order_id) as order_count,
    COALESCE(SUM(o.order_amount), 0) as total_amount,
    MAX(o.order_date) as last_order_date
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE c.customer_id = 12345
GROUP BY c.customer_id, c.customer_name;
```

### 11.4 分页查询的合并优化


**✅ 总数与分页数据的合并**

```sql
-- ❌ 分别查询总数和分页数据
SELECT COUNT(*) as total_count
FROM products
WHERE category = '电子产品';

SELECT product_id, product_name, price
FROM products
WHERE category = '电子产品'
ORDER BY price DESC
LIMIT 20 OFFSET 0;

-- ✅ 使用窗口函数合并
SELECT 
    product_id,
    product_name,
    price,
    COUNT(*) OVER() as total_count
FROM products
WHERE category = '电子产品'
ORDER BY price DESC
LIMIT 20 OFFSET 0;
```

---

## 12. ⚡ 批量操作优化


### 12.1 批量INSERT优化


**✅ 高效的批量插入策略**

```sql
-- ❌ 逐行插入（极其低效）
INSERT INTO products (name, price, category) VALUES ('产品1', 100, 1);
INSERT INTO products (name, price, category) VALUES ('产品2', 200, 1);
INSERT INTO products (name, price, category) VALUES ('产品3', 150, 2);
-- ... 重复数千次

-- ✅ 批量插入（推荐方式）
INSERT INTO products (name, price, category) VALUES
('产品1', 100, 1),
('产品2', 200, 1),
('产品3', 150, 2),
('产品4', 300, 2),
-- ... 一次插入1000-5000行
('产品1000', 250, 3);

-- ✅ 使用SELECT插入（从其他表批量复制）
INSERT INTO products_backup (name, price, category, created_date)
SELECT name, price, category, NOW()
FROM products
WHERE category IN (1, 2, 3);
```

### 12.2 批量UPDATE优化


**✅ 高效的批量更新技术**

```sql
-- ❌ 逐行更新
UPDATE products SET price = price * 1.1 WHERE product_id = 1;
UPDATE products SET price = price * 1.1 WHERE product_id = 2;
-- ... 重复数千次

-- ✅ 批量更新
UPDATE products 
SET price = price * 1.1 
WHERE category = '电子产品'
    AND price > 100;

-- ✅ 基于连接的批量更新
UPDATE products p
JOIN (
    SELECT product_id, 
        CASE 
            WHEN category = '电子产品' THEN 1.1
            WHEN category = '服装' THEN 1.05
            ELSE 1.0
        END as price_factor
    FROM product_categories
) pc ON p.product_id = pc.product_id
SET p.price = p.price * pc.price_factor;
```

### 12.3 批量DELETE优化


**✅ 安全高效的批量删除**

```sql
-- ❌ 无限制的大批量删除（可能锁表）
DELETE FROM order_logs 
WHERE log_date < '2023-01-01';  -- 可能删除数百万行

-- ✅ 分批删除，避免长时间锁表
DELIMITER $$
CREATE PROCEDURE BatchDelete()
BEGIN
    DECLARE row_count INT DEFAULT 1;
    
    WHILE row_count > 0 DO
        DELETE FROM order_logs 
        WHERE log_date < '2023-01-01'
        LIMIT 1000;  -- 每次删除1000行
        
        SET row_count = ROW_COUNT();
        
        -- 给其他操作让路
        DO SLEEP(0.1);
    END WHILE;
END$$
DELIMITER ;

CALL BatchDelete();
```

### 12.4 UPSERT操作优化


**✅ 插入或更新的高效处理**

```sql
-- ✅ MySQL的ON DUPLICATE KEY UPDATE
INSERT INTO user_stats (user_id, login_count, last_login)
VALUES 
(1, 1, NOW()),
(2, 1, NOW()),
(3, 1, NOW())
ON DUPLICATE KEY UPDATE 
    login_count = login_count + 1,
    last_login = NOW();

-- ✅ 使用REPLACE（适合完全替换的场景）
REPLACE INTO user_sessions (user_id, session_id, login_time)
VALUES 
(1, 'sess123', NOW()),
(2, 'sess456', NOW()),
(3, 'sess789', NOW());

-- ✅ 使用MERGE（其他数据库）
MERGE INTO user_stats us
USING (
    SELECT 1 as user_id, 1 as login_count, SYSDATE as last_login FROM dual
    UNION ALL
    SELECT 2, 1, SYSDATE FROM dual
) src ON (us.user_id = src.user_id)
WHEN MATCHED THEN
    UPDATE SET login_count = us.login_count + 1, last_login = SYSDATE
WHEN NOT MATCHED THEN
    INSERT (user_id, login_count, last_login)
    VALUES (src.user_id, src.login_count, src.last_login);
```

---

## 13. 🧩 复杂查询拆分策略


### 13.1 识别复杂查询的特征


**🔸 需要拆分的复杂查询标志**

```
复杂查询的典型特征：
📊 连接5张以上的表
📊 嵌套3层以上的子查询
📊 包含多个聚合函数和窗口函数
📊 执行时间超过10秒
📊 执行计划Cost值超过10000
📊 临时表使用超过100MB
```

### 13.2 垂直拆分策略


**✅ 按功能模块拆分查询**

```sql
-- ❌ 一个巨大的复杂查询
SELECT 
    u.user_id,
    u.user_name,
    u.email,
    -- 订单相关统计
    COUNT(DISTINCT o.order_id) as order_count,
    SUM(o.order_amount) as total_amount,
    AVG(o.order_amount) as avg_amount,
    MAX(o.order_date) as last_order_date,
    -- 产品相关统计
    COUNT(DISTINCT oi.product_id) as unique_products,
    -- 评价相关统计
    COUNT(DISTINCT r.review_id) as review_count,
    AVG(r.rating) as avg_rating,
    -- 优惠券使用统计
    COUNT(DISTINCT c.coupon_id) as coupon_used,
    SUM(c.discount_amount) as total_discount
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
LEFT JOIN reviews r ON o.order_id = r.order_id
LEFT JOIN coupon_usage c ON o.order_id = c.order_id
WHERE u.register_date >= '2024-01-01'
GROUP BY u.user_id, u.user_name, u.email;

-- ✅ 拆分为多个独立查询
-- 查询1：用户基本信息
SELECT user_id, user_name, email
FROM users
WHERE register_date >= '2024-01-01';

-- 查询2：订单统计（基于用户ID列表）
SELECT 
    user_id,
    COUNT(*) as order_count,
    SUM(order_amount) as total_amount,
    AVG(order_amount) as avg_amount,
    MAX(order_date) as last_order_date
FROM orders
WHERE user_id IN (用户ID列表)
GROUP BY user_id;

-- 查询3：产品统计
SELECT 
    o.user_id,
    COUNT(DISTINCT oi.product_id) as unique_products
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.user_id IN (用户ID列表)
GROUP BY o.user_id;

-- 查询4：评价统计
SELECT 
    o.user_id,
    COUNT(r.review_id) as review_count,
    AVG(r.rating) as avg_rating
FROM orders o
JOIN reviews r ON o.order_id = r.order_id
WHERE o.user_id IN (用户ID列表)
GROUP BY o.user_id;
```

### 13.3 水平拆分策略


**✅ 按时间或范围分段处理**

```sql
-- ❌ 处理全年数据的大查询
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(order_amount) as total_sales,
    AVG(order_amount) as avg_order_value
FROM orders
WHERE order_date >= '2024-01-01' 
    AND order_date < '2025-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m')
ORDER BY month;

-- ✅ 按季度拆分处理
-- Q1数据
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(order_amount) as total_sales,
    AVG(order_amount) as avg_order_value
FROM orders
WHERE order_date >= '2024-01-01' 
    AND order_date < '2024-04-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m');

-- Q2数据
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(order_amount) as total_sales,
    AVG(order_amount) as avg_order_value
FROM orders
WHERE order_date >= '2024-04-01' 
    AND order_date < '2024-07-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m');

-- 在应用层合并结果
```

### 13.4 分层查询策略


**✅ 构建中间结果集，逐层细化**

```sql
-- ✅ 第一层：构建基础数据集
CREATE TEMPORARY TABLE temp_user_orders AS
SELECT 
    u.user_id,
    u.user_name,
    o.order_id,
    o.order_date,
    o.order_amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.register_date >= '2024-01-01'
    AND o.order_date >= '2024-01-01';

-- 第二层：添加订单明细
CREATE TEMPORARY TABLE temp_order_details AS
SELECT 
    tuo.*,
    oi.product_id,
    oi.quantity,
    oi.unit_price
FROM temp_user_orders tuo
JOIN order_items oi ON tuo.order_id = oi.order_id;

-- 第三层：最终聚合统计
SELECT 
    user_id,
    user_name,
    COUNT(DISTINCT order_id) as order_count,
    COUNT(DISTINCT product_id) as unique_products,
    SUM(quantity) as total_quantity,
    SUM(order_amount) as total_amount
FROM temp_order_details
GROUP BY user_id, user_name;

-- 清理临时表
DROP TEMPORARY TABLE temp_user_orders;
DROP TEMPORARY TABLE temp_order_details;
```

---

## 14. 🎪 查询逻辑简化技术


### 14.1 冗余逻辑的识别


**🔸 常见的逻辑冗余模式**

```sql
-- ❌ 冗余的条件检查
SELECT *
FROM products p
WHERE p.status = 'ACTIVE'
    AND p.status IN ('ACTIVE', 'PENDING')  -- 冗余
    AND p.price > 0
    AND p.price IS NOT NULL  -- 冗余，>0已经排除了NULL
    AND (p.category = 'electronics' OR p.category IN ('electronics', 'books'));  -- 冗余

-- ✅ 简化后的逻辑
SELECT *
FROM products p
WHERE p.status = 'ACTIVE'
    AND p.price > 0
    AND p.category = 'electronics';
```

### 14.2 逻辑表达式的化简


**✅ 使用德摩根定律和布尔代数**

```sql
-- ❌ 复杂的逻辑表达式
SELECT *
FROM orders o
WHERE NOT (o.status = 'CANCELLED' OR o.status = 'REFUNDED')
    AND NOT (o.amount < 100 AND o.discount_rate > 0.5);

-- ✅ 使用德摩根定律简化
SELECT *
FROM orders o
WHERE o.status NOT IN ('CANCELLED', 'REFUNDED')
    AND (o.amount >= 100 OR o.discount_rate <= 0.5);

-- ❌ 复杂的嵌套条件
SELECT *
FROM customers c
WHERE (c.level = 'VIP' AND c.total_amount > 10000)
    OR (c.level = 'GOLD' AND c.total_amount > 5000)
    OR (c.level = 'SILVER' AND c.total_amount > 1000);

-- ✅ 使用CASE简化逻辑
SELECT *
FROM customers c
WHERE c.total_amount > 
    CASE c.level
        WHEN 'VIP' THEN 10000
        WHEN 'GOLD' THEN 5000
        WHEN 'SILVER' THEN 1000
        ELSE 999999  -- 其他等级设置不可能达到的值
    END;
```

### 14.3 条件合并与拆分


**✅ 合理组织WHERE条件**

```sql
-- ❌ 条件过于分散
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01'
    AND c.city = '北京'
    AND o.status = 'COMPLETED'
    AND c.level IN ('VIP', 'GOLD')
    AND o.order_date <= '2024-12-31'
    AND o.amount > 1000
    AND c.register_date >= '2023-01-01';

-- ✅ 按表分组条件，提高可读性
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE 
    -- 订单相关条件
    o.order_date BETWEEN '2024-01-01' AND '2024-12-31'
    AND o.status = 'COMPLETED'
    AND o.amount > 1000
    -- 客户相关条件
    AND c.city = '北京'
    AND c.level IN ('VIP', 'GOLD')
    AND c.register_date >= '2023-01-01';
```

### 14.4 子查询逻辑简化


**✅ 消除不必要的子查询嵌套**

```sql
-- ❌ 过度嵌套的子查询
SELECT *
FROM products p
WHERE p.product_id IN (
    SELECT oi.product_id
    FROM order_items oi
    WHERE oi.order_id IN (
        SELECT o.order_id
        FROM orders o
        WHERE o.customer_id IN (
            SELECT c.customer_id
            FROM customers c
            WHERE c.city = '北京'
        )
    )
);

-- ✅ 使用连接简化逻辑
SELECT DISTINCT p.*
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
JOIN customers c ON o.customer_id = c.customer_id
WHERE c.city = '北京';

-- ❌ 复杂的EXISTS逻辑
SELECT *
FROM customers c1
WHERE EXISTS (
    SELECT 1
    FROM customers c2
    WHERE c2.city = c1.city
        AND c2.customer_id != c1.customer_id
        AND EXISTS (
            SELECT 1
            FROM orders o
            WHERE o.customer_id = c2.customer_id
                AND o.order_date >= '2024-01-01'
        )
);

-- ✅ 使用窗口函数简化
SELECT DISTINCT c.*
FROM customers c
JOIN (
    SELECT customer_id, city,
        COUNT(*) OVER (PARTITION BY city) as city_customer_count
    FROM customers
) city_stats ON c.customer_id = city_stats.customer_id
JOIN orders o ON c.customer_id = o.customer_id
WHERE city_stats.city_customer_count > 1
    AND o.order_date >= '2024-01-01';
```

---

## 15. 📋 核心要点总结


### 15.1 SQL重构的核心原则


**🎯 重构优先级**
```
性能影响等级：
🔥 紧急级：全表扫描、笛卡尔积、大量临时表
⚠️ 重要级：复杂子查询、函数在WHERE条件中、无索引排序
📈 优化级：代码可读性、逻辑简化、维护性提升
```

**⚡ 效果评估标准**
```
量化指标：
📊 查询响应时间：目标<3秒
📊 CPU使用率：降低50%以上
📊 内存消耗：减少临时表使用
📊 并发能力：支持更多用户同时访问
📊 可维护性：代码复杂度降低
```

### 15.2 重构技术选择指南


**🔧 技术选择矩阵**

| 场景 | **首选技术** | **备选方案** | **适用条件** |
|------|-------------|-------------|-------------|
| **复杂多表连接** | `查询分解` | `临时表分层` | `数据量>100万行` |
| **嵌套子查询** | `连接转换` | `EXISTS转换` | `子查询执行频繁` |
| **条件复杂** | `逻辑简化` | `索引优化` | `WHERE条件>5个` |
| **重复计算** | `WITH子句` | `临时表` | `相同计算>3次` |
| **排序开销大** | `索引消除` | `LIMIT优化` | `排序字段可建索引` |
| **函数调用多** | `预计算列` | `函数索引` | `函数结果相对固定` |

### 15.3 重构实施步骤


**📋 标准重构流程**
```
第一步：性能基线测试
🔸 记录当前执行时间
🔸 分析执行计划
🔸 监控资源使用情况

第二步：识别瓶颈
🔸 找出成本最高的操作
🔸 定位全表扫描
🔸 发现临时表使用

第三步：制定重构方案
🔸 选择合适的重构技术
🔸 评估改造风险
🔸 准备回滚方案

第四步：分步实施
🔸 先易后难，逐步优化
🔸 每次改动后测试验证
🔸 保持结果一致性

第五步：效果评估
🔸 对比性能提升
🔸 验证功能正确性
🔸 监控稳定性
```

### 15.4 常见重构模式速查


**🚀 高频重构场景**

```
模式1：相关子查询→连接
适用：EXISTS、标量子查询
效果：性能提升50-90%

模式2：复杂CASE→字典表连接
适用：超过5个分支的CASE
效果：提升可维护性，略微提升性能

模式3：多查询→单查询合并
适用：相同表的重复访问
效果：减少I/O，提升50%以上性能

模式4：函数调用→预计算
适用：WHERE/ORDER BY中的函数
效果：利用索引，性能提升数十倍

模式5：复杂查询→分层处理
适用：5表以上复杂连接
效果：提升可维护性，便于调试
```

### 15.5 重构注意事项


**⚠️ 重构风险控制**
```
数据一致性风险：
🔸 重构前后结果必须完全一致
🔸 注意NULL值处理的差异
🔸 小心浮点数精度问题
🔸 验证边界条件处理

性能回归风险：
🔸 小数据集可能出现负优化
🔸 统计信息过期影响执行计划
🔸 并发场景下的锁竞争
🔸 内存不足时的性能下降

维护成本风险：
🔸 过度优化导致代码难懂
🔸 增加了额外的依赖关系
🔸 调试和排错更加困难
🔸 后续需求变更的适应性
```

**✅ 最佳实践建议**
```
代码质量：
🔸 保持代码可读性和注释完整
🔸 使用有意义的别名和变量名
🔸 遵循团队的编码规范
🔸 考虑后续维护和扩展需求

测试验证：
🔸 准备充分的测试数据
🔸 覆盖各种边界情况
🔸 进行压力测试验证
🔸 建立性能监控机制

文档记录：
🔸 记录重构的原因和过程
🔸 保留原始查询作为备份
🔸 说明重构后的维护要点
🔸 更新相关技术文档
```

### 15.6 学习路径建议


**📚 技能进阶路线**
```
入门阶段：
🌱 掌握基本的连接和子查询转换
🌱 理解索引对查询性能的影响
🌱 学会使用执行计划分析问题

进阶阶段：
🌿 熟练运用窗口函数和CTE
🌿 掌握复杂查询的分解技巧
🌿 理解数据库优化器的工作原理

高级阶段：
🌳 能够设计高效的数据访问模式
🌳 具备全局的数据库架构优化能力
🌳 可以指导团队进行SQL性能调优
```

**核心记忆要点：**
- SQL重构以性能为先，等价性为基础
- 复杂查询要分解，相关子查询要转换
- 函数避免WHERE中用，条件简化逻辑清
- 批量操作替单行，合并查询减访问
- 测试验证保一致，文档记录助维护