---
title: 26、索引失效案例
---
## 📚 目录

1. [索引失效概述](#1-索引失效概述)
2. [函数运算索引失效](#2-函数运算索引失效)
3. [类型转换索引失效](#3-类型转换索引失效)
4. [模糊查询索引失效](#4-模糊查询索引失效)
5. [负向条件索引失效](#5-负向条件索引失效)
6. [复合索引部分使用](#6-复合索引部分使用)
7. [索引统计信息过期](#7-索引统计信息过期)
8. [强制索引HINT使用](#8-强制索引hint使用)
9. [索引监控与优化](#9-索引监控与优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引失效概述


### 1.1 什么是索引失效


**通俗理解**：就像图书馆的目录册，如果你查书的方式不对，目录册就派不上用场了

```
正常情况：
查询 → 使用索引 → 快速定位 → 返回结果
时间：毫秒级

索引失效：
查询 → 全表扫描 → 逐行检查 → 返回结果  
时间：可能秒级甚至分钟级
```

### 1.2 索引失效的危害


**性能影响对比**：
```
场景：100万条数据的用户表

有效索引查询：
SELECT * FROM users WHERE id = 12345;
执行时间：0.001秒，扫描1行

索引失效查询：
SELECT * FROM users WHERE id + 0 = 12345;
执行时间：0.5秒，扫描100万行
```

### 1.3 索引失效判断方法


**使用EXPLAIN分析**：
```sql
EXPLAIN SELECT * FROM users WHERE name = 'zhangsan';
```

**关键指标解读**：
- **type**: 连接类型，`ALL`表示全表扫描（索引失效）
- **key**: 实际使用的索引，`NULL`表示没用索引  
- **rows**: 预计扫描行数，数字越大越慢
- **Extra**: 额外信息，`Using filesort`等表示性能问题

---

## 2. ⚡ 函数运算索引失效


### 2.1 问题本质


**核心原理**：索引是按原始字段值排序的，一旦对字段做函数处理，排序规律就被破坏了

```
索引存储结构（简化）：
name字段索引：
'Alice'   → 行1
'Bob'     → 行2  
'Charlie' → 行3

当查询 UPPER(name) = 'BOB' 时：
索引里存的是 'Bob'，不是 'BOB'
MySQL无法直接使用索引匹配
```

### 2.2 常见函数运算案例


#### 🔍 案例1：日期函数


```sql
-- ❌ 索引失效（对字段使用函数）
SELECT * FROM orders 
WHERE YEAR(create_time) = 2024;

-- ✅ 索引生效（函数用在常量上）
SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';
```

**原因分析**：
- `YEAR(create_time)`需要对每一行数据执行函数计算
- 索引无法预先知道函数计算的结果
- 只能全表扫描后逐行计算

#### 🔍 案例2：字符串函数


```sql
-- ❌ 索引失效
SELECT * FROM users 
WHERE UPPER(name) = 'ZHANGSAN';

-- ✅ 索引生效
SELECT * FROM users 
WHERE name = 'zhangsan';
-- 或者使用大小写不敏感的排序规则
```

#### 🔍 案例3：数学运算


```sql
-- ❌ 索引失效
SELECT * FROM products 
WHERE price * 0.8 > 100;

-- ✅ 索引生效
SELECT * FROM products 
WHERE price > 100 / 0.8;  -- price > 125
```

### 2.3 函数索引解决方案


**MySQL 8.0 支持函数索引**：
```sql
-- 创建函数索引
CREATE INDEX idx_year_create_time 
ON orders ((YEAR(create_time)));

-- 现在这个查询可以使用索引了
SELECT * FROM orders 
WHERE YEAR(create_time) = 2024;
```

---

## 3. 🔄 类型转换索引失效


### 3.1 隐式类型转换


**问题根源**：MySQL在比较不同类型时会自动转换，但转换规则可能导致索引失效

```
MySQL类型转换规则（简化）：
字符串 vs 数字：字符串转数字
日期 vs 字符串：字符串转日期
```

### 3.2 常见类型转换案例


#### 🔍 案例1：字符串字段查询数字


```sql
-- 表结构
CREATE TABLE users (
    phone VARCHAR(11) PRIMARY KEY
);

-- ❌ 索引失效（字符串字段用数字查询）
SELECT * FROM users 
WHERE phone = 13812345678;

-- 实际执行过程：
-- MySQL将所有phone字段转为数字再比较
-- 等价于：WHERE CAST(phone AS UNSIGNED) = 13812345678

-- ✅ 索引生效（类型匹配）
SELECT * FROM users 
WHERE phone = '13812345678';
```

#### 🔍 案例2：数字字段查询字符串


```sql
-- 表结构  
CREATE TABLE orders (
    user_id INT,
    INDEX idx_user_id (user_id)
);

-- ✅ 索引生效（数字字段用字符串，会转换常量）
SELECT * FROM orders 
WHERE user_id = '123';
-- MySQL转换为：WHERE user_id = 123

-- ⚠️ 注意：如果字符串无法转换成数字会有问题
SELECT * FROM orders 
WHERE user_id = '123abc';  -- 转换为123，可能不是预期结果
```

### 3.3 检测隐式转换


**查看转换警告**：
```sql
SELECT * FROM users WHERE phone = 13812345678;
SHOW WARNINGS;

-- 输出示例：
-- Warning | 1292 | Truncated incorrect DOUBLE value: '13812345678'
```

**使用严格模式检测**：
```sql
SET sql_mode = 'STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO';
```

---

## 4. 🔍 模糊查询索引失效


### 4.1 通配符位置的影响


**索引结构特点**：索引是按字典序排列的，只能从左边开始匹配

```
姓名索引示例：
'张三'
'张三丰'  
'张无忌'
'李四'
'李小龙'

前缀匹配 '张%'：可以快速定位到 '张' 开头的区域
后缀匹配 '%龙'：无法利用排序，必须全表扫描
```

### 4.2 模糊查询案例对比


#### 🔍 案例1：LIKE查询


```sql
-- ✅ 索引生效（前导匹配）
SELECT * FROM users 
WHERE name LIKE '张%';

-- ❌ 索引失效（前导模糊）
SELECT * FROM users 
WHERE name LIKE '%张%';

-- ❌ 索引失效（后缀匹配）
SELECT * FROM users 
WHERE name LIKE '%张';
```

#### 🔍 案例2：具体场景


```sql
-- 搜索手机号（前导匹配可用索引）
-- ✅ 查找138开头的手机号
SELECT * FROM users 
WHERE phone LIKE '138%';

-- ❌ 查找包含888的手机号（必须全表扫描）
SELECT * FROM users 
WHERE phone LIKE '%888%';
```

### 4.3 前导模糊查询解决方案


**方案1：全文索引**
```sql
-- 创建全文索引
ALTER TABLE articles 
ADD FULLTEXT(title, content);

-- 使用全文搜索
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 索引');
```

**方案2：搜索引擎**
```
对于复杂的模糊搜索需求：
- 使用 Elasticsearch
- 使用 Solr  
- 配合MySQL使用，各司其职
```

---

## 5. 🚫 负向条件索引失效


### 5.1 负向条件类型


**常见负向条件**：
- `!=` 或 `<>`：不等于
- `NOT IN`：不包含
- `NOT EXISTS`：不存在
- `NOT LIKE`：不匹配

### 5.2 负向条件案例


#### 🔍 案例1：不等于条件


```sql
-- ❌ 索引效率低（需要扫描大量数据）
SELECT * FROM users 
WHERE status != 'deleted';

-- ✅ 正向条件，索引效率高
SELECT * FROM users 
WHERE status IN ('active', 'pending', 'suspended');
```

**原因分析**：
```
假设用户状态分布：
active: 8000条
pending: 1500条  
suspended: 400条
deleted: 100条

status != 'deleted' 需要返回9900条记录
status = 'active' 只需要返回8000条记录

MySQL认为返回大部分数据时，全表扫描可能更快
```

#### 🔍 案例2：NOT IN条件


```sql
-- ❌ 索引失效
SELECT * FROM orders 
WHERE status NOT IN ('cancelled', 'refunded');

-- ✅ 改为正向条件
SELECT * FROM orders 
WHERE status IN ('pending', 'paid', 'shipped', 'completed');
```

### 5.3 负向条件优化策略


**策略1：改写为正向条件**
```sql
-- 原查询：查找不是VIP的用户
SELECT * FROM users WHERE user_type != 'vip';

-- 优化：列出所有非VIP类型
SELECT * FROM users WHERE user_type IN ('normal', 'trial', 'premium');
```

**策略2：使用复合查询**
```sql
-- 复杂场景可以分步骤查询
-- 1. 先查出要排除的ID
-- 2. 再查主要数据

SELECT * FROM orders o
WHERE EXISTS (
    SELECT 1 FROM order_items oi 
    WHERE oi.order_id = o.id 
    AND oi.product_type = 'digital'
);
```

---

## 6. 🔗 复合索引部分使用


### 6.1 复合索引的最左前缀原理


**通俗理解**：复合索引就像电话黄页，按姓氏→名字→年龄排序

```
复合索引：(lastname, firstname, age)

索引结构示例：
'李', '明',    25
'李', '明',    30  
'李', '小红',  22
'王', '刚',    28
'王', '小明',  24

查询规律：
✅ WHERE lastname = '李'                    -- 用到索引
✅ WHERE lastname = '李' AND firstname = '明' -- 用到索引  
❌ WHERE firstname = '明'                   -- 无法用索引
❌ WHERE age = 25                          -- 无法用索引
```

### 6.2 复合索引使用案例


#### 🔍 案例1：部分条件使用


```sql
-- 假设有复合索引：KEY idx_compound (user_id, create_time, status)

-- ✅ 完全使用索引（推荐）
SELECT * FROM orders 
WHERE user_id = 123 
  AND create_time > '2024-01-01' 
  AND status = 'paid';

-- ⚠️ 部分使用索引（user_id + create_time）
SELECT * FROM orders 
WHERE user_id = 123 
  AND create_time > '2024-01-01';

-- ❌ 索引失效（跳过了第一个字段）
SELECT * FROM orders 
WHERE create_time > '2024-01-01' 
  AND status = 'paid';
```

#### 🔍 案例2：范围查询影响


```sql
-- 复合索引：(category_id, price, stock)

-- ✅ 使用索引：category_id + price
SELECT * FROM products 
WHERE category_id = 1 
  AND price > 100;

-- ⚠️ 只用到category_id（price范围查询后的字段无法使用）
SELECT * FROM products 
WHERE category_id = 1 
  AND price > 100 
  AND stock > 0;

-- ✅ 优化：调整索引顺序为 (category_id, stock, price)
-- 这样所有字段都能用到
```

### 6.3 复合索引设计原则


**设计顺序建议**：
```
1. 等值查询字段放前面
2. 范围查询字段放后面  
3. 选择性高的字段放前面
4. 经常一起查询的字段组合

示例：
订单表常见查询：
- 按用户ID查订单：user_id
- 按时间范围查询：create_time  
- 按状态过滤：status

推荐索引：(user_id, status, create_time)
原因：user_id和status通常是等值查询，create_time是范围查询
```

---

## 7. 📊 索引统计信息过期


### 7.1 统计信息的作用


**通俗解释**：MySQL需要知道每个索引的"含金量"来选择最优的查询路径

```
索引统计信息包含：
- 索引的基数（不重复值的数量）
- 数据分布情况
- 索引的选择性

例如：
用户表100万条记录
- id字段：100万个不重复值（选择性极高）
- gender字段：只有2个值（选择性很低）
- city字段：有300个不重复值（选择性中等）

MySQL会优先选择选择性高的索引
```

### 7.2 统计信息过期案例


#### 🔍 案例1：数据大量变化后


```sql
-- 场景：用户表原本只有1万条记录，现在增长到100万条
-- 但是统计信息还是按照1万条的规模来判断

-- 查看当前统计信息
SELECT 
    table_name,
    table_rows,
    update_time
FROM information_schema.tables 
WHERE table_name = 'users';

-- 手动更新统计信息
ANALYZE TABLE users;
```

#### 🔍 案例2：索引选择错误


```sql
-- MySQL可能选择了错误的索引
SELECT * FROM orders 
WHERE user_id = 123 
  AND create_time > '2024-01-01';

-- 查看执行计划
EXPLAIN SELECT * FROM orders 
WHERE user_id = 123 
  AND create_time > '2024-01-01';

-- 如果选择了错误索引，更新统计信息
ANALYZE TABLE orders;
```

### 7.3 统计信息管理


**定期更新策略**：
```sql
-- 方法1：手动更新
ANALYZE TABLE table_name;

-- 方法2：自动更新（配置参数）
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_persistent = ON;

-- 方法3：定时任务更新
-- 在业务低峰期执行
```

**监控统计信息**：
```sql
-- 查看表的统计信息更新时间
SELECT 
    table_schema,
    table_name,
    update_time,
    table_rows
FROM information_schema.tables 
WHERE table_schema = 'your_database'
ORDER BY update_time;
```

---

## 8. 💡 强制索引HINT使用


### 8.1 什么时候需要HINT


**使用场景**：
- MySQL选择了错误的索引
- 统计信息不准确导致选择偏差
- 特定查询需要强制使用某个索引

### 8.2 HINT语法和案例


#### 🔍 强制使用索引


```sql
-- 强制使用指定索引
SELECT * FROM orders 
FORCE INDEX (idx_user_time)
WHERE user_id = 123 
  AND create_time > '2024-01-01';

-- 建议使用索引（MySQL可能忽略）
SELECT * FROM orders 
USE INDEX (idx_user_time)
WHERE user_id = 123;

-- 忽略某个索引
SELECT * FROM orders 
IGNORE INDEX (idx_create_time)
WHERE user_id = 123;
```

#### 🔍 实际应用案例


```sql
-- 场景：MySQL总是选择错误的索引

-- 1. 先查看MySQL的选择
EXPLAIN SELECT * FROM user_orders 
WHERE user_id = 123 
  AND status = 'pending' 
  AND create_time > '2024-01-01';

-- 2. 如果选择了错误索引，强制使用正确的
SELECT * FROM user_orders 
FORCE INDEX (idx_user_status_time)
WHERE user_id = 123 
  AND status = 'pending' 
  AND create_time > '2024-01-01';
```

### 8.3 HINT使用注意事项


**⚠️ 使用警告**：
```
HINT应该是临时方案，不是长期解决方案

问题根源通常是：
1. 索引设计不合理
2. 统计信息过期
3. 查询语句可以优化

更好的解决方案：
1. 重新设计索引
2. 更新统计信息  
3. 优化查询语句
4. 调整MySQL参数
```

---

## 9. 📈 索引监控与优化


### 9.1 隐式类型转换检测


#### 🔍 检测方法


```sql
-- 开启慢查询日志记录类型转换
SET GLOBAL log_queries_not_using_indexes = ON;
SET GLOBAL long_query_time = 0.1;

-- 查看警告信息
SELECT * FROM users WHERE phone = 13812345678;
SHOW WARNINGS;
```

#### 🔍 监控SQL语句


```sql
-- 创建监控表记录问题SQL
CREATE TABLE slow_query_monitor (
    id INT AUTO_INCREMENT PRIMARY KEY,
    query_text TEXT,
    warning_msg TEXT,
    exec_time DECIMAL(10,6),
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 定期检查慢查询日志
-- 识别类型转换问题
```

### 9.2 索引失效监控告警


#### 🔍 监控指标


```sql
-- 查询索引使用情况
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality,
    non_unique
FROM information_schema.statistics 
WHERE table_schema = 'your_database'
ORDER BY cardinality DESC;

-- 查询未使用的索引
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE index_name IS NOT NULL 
  AND count_star = 0;
```

### 9.3 索引使用率统计


#### 🔍 统计查询


```sql
-- 统计索引使用频率
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_FETCH DESC;
```

### 9.4 查询计划稳定性监控


```sql
-- 监控执行计划变化
CREATE TABLE query_plan_history (
    query_id VARCHAR(64),
    query_text TEXT,
    plan_info JSON,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_query_time (query_id, create_time)
);

-- 对比执行计划变化
-- 及时发现索引选择异常
```

---

## 10. 📋 核心要点总结


### 10.1 索引失效根本原因


```
🔸 索引结构被破坏：函数运算、类型转换
🔸 查询条件不匹配：前导模糊、负向条件  
🔸 索引选择错误：统计信息过期、选择性判断失误
🔸 使用方式不当：复合索引顺序错误
```

### 10.2 避免索引失效的最佳实践


**🔹 查询编写原则**：
```
1. 避免在WHERE字段上使用函数
2. 保持查询字段类型与表结构一致
3. 使用正向条件替代负向条件
4. 遵循复合索引的最左前缀原则
```

**🔹 索引设计原则**：
```
1. 高频查询字段优先建索引
2. 选择性高的字段优先
3. 复合索引考虑查询模式
4. 定期评估索引使用效果
```

**🔹 监控维护要点**：
```
1. 定期更新表统计信息
2. 监控慢查询和执行计划
3. 检测隐式类型转换
4. 评估索引使用率和效果
```

### 10.3 问题诊断流程


```
发现查询慢 ↓
├─ 使用EXPLAIN分析执行计划
├─ 检查是否使用了索引（key字段）  
├─ 查看扫描行数（rows字段）
├─ 检查SHOW WARNINGS输出
└─ 根据具体问题采取对应解决方案

解决方案选择：
├─ 函数运算 → 改写查询或创建函数索引
├─ 类型转换 → 统一查询和字段类型
├─ 模糊查询 → 使用前导匹配或全文索引
├─ 负向条件 → 改写为正向条件
├─ 复合索引 → 调整查询顺序或重建索引
└─ 统计过期 → 执行ANALYZE TABLE更新
```

### 10.4 性能优化记忆口诀


**核心记忆**：
```
索引失效看五点：函数类型模糊查，负向复合统计差
函数运算要避免，类型匹配是关键
模糊查询看位置，负向改成正向选
复合索引左前缀，统计及时要更新
监控告警不能少，HINT使用需谨慎
```

**实战检查清单**：
- [ ] 🔍 EXPLAIN查看执行计划
- [ ] 📊 检查type是否为ALL（全表扫描）
- [ ] 🔑 确认key字段有使用索引
- [ ] 📈 查看rows预计扫描行数
- [ ] ⚠️ 检查SHOW WARNINGS输出
- [ ] 🔄 定期ANALYZE TABLE更新统计信息
- [ ] 📝 记录和监控慢查询日志