---
title: 18、性能问题故障案例
---
## 📚 目录

1. [慢查询突发问题分析](#1-慢查询突发问题分析)
2. [CPU使用率飙升故障排查](#2-CPU使用率飙升故障排查)
3. [内存泄漏问题诊断](#3-内存泄漏问题诊断)
4. [IO瓶颈问题解决](#4-IO瓶颈问题解决)
5. [连接数异常处理](#5-连接数异常处理)
6. [缓存命中率下降分析](#6-缓存命中率下降分析)
7. [索引扫描异常案例](#7-索引扫描异常案例)
8. [查询计划变更检测](#8-查询计划变更检测)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🐌 慢查询突发问题分析


### 1.1 什么是慢查询突发


**简单理解**：就像平时走路很快的人，突然走得很慢一样，数据库查询突然变得很慢。

```
正常情况：查询0.1秒完成 ✅
突发情况：查询10秒才完成 ❌

这种突然变慢的现象就叫"慢查询突发"
```

**📊 慢查询判断标准**
```sql
-- 查看当前慢查询阈值
SHOW VARIABLES LIKE 'long_query_time';

-- 典型输出：2.0秒
-- 意思：超过2秒的查询会被记录为慢查询
```

### 1.2 慢查询突发的常见原因


**🔍 主要原因分析**

| 原因类型 | **具体表现** | **排查方法** | **解决思路** |
|---------|-------------|-------------|-------------|
| **锁等待** | `查询被阻塞等待` | `SHOW PROCESSLIST` | `找到锁源，优化事务` |
| **数据量激增** | `表数据突然增大` | `检查表大小变化` | `分区或清理数据` |
| **索引失效** | `执行计划改变` | `EXPLAIN查看计划` | `重建或优化索引` |
| **服务器负载** | `CPU/IO资源不足` | `系统监控工具` | `优化配置或扩容` |

### 1.3 慢查询排查实战步骤


**🔧 排查流程**
```
第一步：确认慢查询 → 第二步：找出慢SQL → 第三步：分析执行计划 → 第四步：针对性优化
```

**💻 实用排查命令**
```sql
-- 1. 查看慢查询日志是否开启
SHOW VARIABLES LIKE '%slow_query_log%';

-- 2. 查看当前正在运行的查询
SHOW FULL PROCESSLIST;

-- 3. 查看最近的慢查询
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 5;
```

### 1.4 典型案例：电商订单查询变慢


**📱 场景描述**：双十一期间，用户查询订单页面从0.2秒变成8秒

**🔍 排查过程**
```sql
-- 发现问题SQL
SELECT * FROM orders 
WHERE user_id = 12345 
ORDER BY create_time DESC 
LIMIT 10;

-- 分析执行计划
EXPLAIN SELECT * FROM orders 
WHERE user_id = 12345 
ORDER BY create_time DESC 
LIMIT 10;

-- 发现：没有user_id索引，全表扫描1000万条记录
```

**✅ 解决方案**
```sql
-- 添加复合索引
CREATE INDEX idx_user_time ON orders(user_id, create_time);

-- 结果：查询时间从8秒降到0.1秒
```

---

## 2. 🔥 CPU使用率飙升故障排查


### 2.1 CPU飙升的含义


**通俗解释**：就像人的大脑突然要处理很多复杂问题，CPU使用率飙升就是数据库服务器的"大脑"突然很忙。

```
正常情况：CPU使用率 20-50%
异常情况：CPU使用率 90-100%

持续高CPU会导致：
• 查询响应变慢
• 服务器整体性能下降  
• 可能引起服务不可用
```

### 2.2 CPU飙升的常见原因


**🎯 主要原因**

```
高频查询：大量简单查询同时执行
复杂计算：JOIN、排序、分组操作过多
缺少索引：大量全表扫描
锁竞争：多个查询争抢同一资源
配置不当：缓冲区设置过小
```

### 2.3 CPU问题排查方法


**📊 系统层面排查**
```bash
# 查看CPU整体使用情况
top

# 查看MySQL进程CPU占用
top -p $(pidof mysqld)

# 查看CPU使用率最高的查询
mysqladmin processlist | head -10
```

**🔍 MySQL层面排查**
```sql
-- 查看当前活跃连接
SHOW PROCESSLIST;

-- 查看正在执行的查询统计
SELECT * FROM performance_schema.events_statements_current
WHERE SQL_TEXT IS NOT NULL;

-- 查看最消耗CPU的查询
SELECT SCHEMA_NAME, DIGEST_TEXT, COUNT_STAR, AVG_TIMER_WAIT
FROM performance_schema.events_statements_summary_by_digest
ORDER BY AVG_TIMER_WAIT DESC LIMIT 5;
```

### 2.4 CPU飙升典型案例


**📈 案例：报表生成导致CPU爆满**

**背景**：每天凌晨2点生成销售报表，CPU使用率达到100%

**问题SQL**：
```sql
-- 原始SQL（CPU杀手）
SELECT 
    DATE(order_time) as date,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE order_time >= '2023-01-01'
GROUP BY DATE(order_time)
ORDER BY date;
```

**🔧 优化方案**
```sql
-- 优化后的SQL
-- 1. 添加必要索引
CREATE INDEX idx_order_time ON orders(order_time);
CREATE INDEX idx_order_items_oid ON order_items(order_id);

-- 2. 避免函数计算，使用范围查询
SELECT 
    DATE(order_time) as date,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE order_time >= '2023-01-01' 
    AND order_time < '2024-01-01'
GROUP BY DATE(order_time)
ORDER BY date;
```

**📊 优化效果**
```
优化前：CPU 100%，执行时间 45分钟
优化后：CPU 30%，执行时间 3分钟
```

---

## 3. 💾 内存泄漏问题诊断


### 3.1 什么是内存泄漏


**生活化理解**：就像水龙头没关紧，内存一直在"滴水"，越积越多，最终把"水桶"装满。

```
正常情况：用完内存后自动释放
泄漏情况：用完内存不释放，一直占用

结果：
• 服务器内存不足
• MySQL性能下降
• 甚至服务崩溃
```

### 3.2 内存泄漏的表现


**⚠️ 典型症状**

```
内存使用率持续上升：70% → 80% → 90% → 95%
查询响应时间越来越慢
连接建立困难
系统出现OOM（内存不足）错误
MySQL服务异常重启
```

### 3.3 内存使用监控


**📊 系统层面监控**
```bash
# 查看内存总体使用情况
free -h

# 查看MySQL进程内存占用
ps aux | grep mysqld

# 实时监控内存变化
watch -n 2 'free -h'
```

**🔍 MySQL层面监控**
```sql
-- 查看关键内存配置
SHOW VARIABLES LIKE '%buffer%';
SHOW VARIABLES LIKE '%cache%';

-- 查看内存使用状态
SHOW STATUS LIKE '%buffer%';
SHOW STATUS LIKE '%cache%';

-- 查看连接内存使用
SHOW STATUS LIKE 'Threads_connected';
SHOW VARIABLES LIKE 'thread_cache_size';
```

### 3.4 内存泄漏排查案例


**💡 案例：应用连接池配置不当**

**现象**：MySQL内存使用率在3天内从30%涨到95%

**排查过程**：
```sql
-- 1. 检查连接数变化
SHOW STATUS LIKE 'Threads_connected';  -- 发现：800个连接

-- 2. 检查最大连接数配置
SHOW VARIABLES LIKE 'max_connections';  -- 配置：1000个

-- 3. 检查每个连接内存使用
SHOW VARIABLES LIKE 'read_buffer_size';      -- 2MB
SHOW VARIABLES LIKE 'sort_buffer_size';      -- 4MB
SHOW VARIABLES LIKE 'join_buffer_size';      -- 2MB
-- 每个连接最多占用：2+4+2 = 8MB
-- 800个连接 × 8MB = 6.4GB内存占用
```

**🔧 解决方案**
```sql
-- 1. 优化连接池配置（应用层面）
-- 最大连接数：200（原来500）
-- 连接空闲时间：30秒（原来300秒）

-- 2. 优化MySQL内存参数
SET GLOBAL read_buffer_size = 1048576;      -- 1MB（原来2MB）
SET GLOBAL sort_buffer_size = 2097152;      -- 2MB（原来4MB）
SET GLOBAL join_buffer_size = 1048576;      -- 1MB（原来2MB）

-- 3. 设置连接超时
SET GLOBAL wait_timeout = 600;              -- 10分钟
SET GLOBAL interactive_timeout = 600;
```

---

## 4. 💽 IO瓶颈问题解决


### 4.1 什么是IO瓶颈


**简单理解**：IO就像图书管理员，负责从书架上取书（读数据）和放书（写数据）。IO瓶颈就是管理员太忙，处理不过来。

```
正常情况：读写数据很快
瓶颈情况：读写数据很慢，要排队等待

影响：
• 查询等待时间长
• 数据写入延迟
• 整体性能下降
```

### 4.2 IO瓶颈的识别方法


**📊 系统层面检查**
```bash
# 查看磁盘IO统计
iostat -x 1

# 查看IO等待时间
top  # 关注wa%（IO等待百分比）

# 查看磁盘使用率
df -h
```

**🔍 MySQL层面检查**
```sql
-- 查看InnoDB IO相关状态
SHOW ENGINE INNODB STATUS\G

-- 查看表空间IO统计
SELECT * FROM information_schema.INNODB_TABLESPACES_SCRUBBING;

-- 查看慢查询是否与IO相关
SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';
```

### 4.3 IO瓶颈优化策略


**🔧 常见优化方法**

| 优化方向 | **具体措施** | **适用场景** | **预期效果** |
|---------|-------------|-------------|-------------|
| **硬件升级** | `SSD替换机械硬盘` | `IO密集型应用` | `10倍性能提升` |
| **参数调优** | `调整缓冲池大小` | `内存充足情况` | `减少磁盘读写` |
| **查询优化** | `避免大量排序` | `所有场景` | `减少临时文件` |
| **架构优化** | `读写分离` | `读多写少` | `分散IO压力` |

### 4.4 IO瓶颈解决案例


**📈 案例：数据导入导致IO爆满**

**场景**：每晚需要导入100万条数据，IO利用率达到100%

**原始方案**：
```sql
-- 逐条插入（IO杀手）
INSERT INTO user_logs (user_id, action, create_time) 
VALUES (1, 'login', NOW());
-- 重复100万次...
```

**🚀 优化方案**：
```sql
-- 1. 批量插入
INSERT INTO user_logs (user_id, action, create_time) 
VALUES 
(1, 'login', '2023-10-01 10:00:00'),
(2, 'logout', '2023-10-01 10:01:00'),
-- ... 1000条一批
;

-- 2. 关闭自动提交，手动控制事务
SET autocommit = 0;
-- 插入数据...
COMMIT;

-- 3. 调整InnoDB参数
SET GLOBAL innodb_flush_log_at_trx_commit = 2;  -- 降低IO频率
SET GLOBAL innodb_buffer_pool_size = 2147483648; -- 增大缓冲池
```

**📊 优化效果**
```
优化前：100万条数据导入耗时 4小时，IO利用率100%
优化后：100万条数据导入耗时 30分钟，IO利用率60%
```

---

## 5. 🔌 连接数异常处理


### 5.1 连接数异常的含义


**通俗解释**：就像餐厅的座位，连接数异常就是要么没人来吃饭（连接太少），要么人太多坐不下（连接太多）。

```
连接过多：Too many connections 错误
连接过少：资源浪费，性能没充分利用
连接异常波动：忽高忽低，不稳定
```

### 5.2 连接数问题的类型


**📊 常见连接问题**

```
连接数暴增：
• 应用连接池配置错误
• 连接没有正确释放
• 突发流量冲击

连接数不足：
• 配置过于保守
• 连接池设置太小

连接泄漏：
• 应用代码没有关闭连接
• 长时间运行的查询占用连接
```

### 5.3 连接数监控和诊断


**🔍 监控连接状态**
```sql
-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看最大连接数配置
SHOW VARIABLES LIKE 'max_connections';

-- 查看连接使用历史峰值
SHOW STATUS LIKE 'Max_used_connections';

-- 查看详细连接信息
SHOW FULL PROCESSLIST;
```

**📈 连接数分析**
```sql
-- 按用户统计连接数
SELECT USER, COUNT(*) as connection_count
FROM information_schema.PROCESSLIST 
GROUP BY USER 
ORDER BY connection_count DESC;

-- 按状态统计连接
SELECT COMMAND, COUNT(*) as count
FROM information_schema.PROCESSLIST 
GROUP BY COMMAND 
ORDER BY count DESC;
```

### 5.4 连接数异常案例


**⚠️ 案例：电商大促期间连接数爆满**

**现象**：
```
错误日志：Too many connections
用户反馈：网站无法访问
监控显示：连接数从200跳到1000
```

**排查过程**：
```sql
-- 1. 检查当前连接情况
SHOW FULL PROCESSLIST;
-- 发现：大量Sleep状态连接

-- 2. 检查连接超时设置
SHOW VARIABLES LIKE '%timeout%';
-- 发现：wait_timeout = 28800（8小时）

-- 3. 分析连接来源
SELECT USER, HOST, COUNT(*) 
FROM information_schema.PROCESSLIST 
GROUP BY USER, HOST;
-- 发现：某个应用服务器创建了600个连接
```

**🔧 解决方案**：
```sql
-- 1. 紧急措施：杀掉空闲连接
SELECT CONCAT('KILL ', ID, ';') as kill_cmd
FROM information_schema.PROCESSLIST 
WHERE COMMAND = 'Sleep' 
AND TIME > 300;  -- 空闲超过5分钟

-- 2. 调整超时参数
SET GLOBAL wait_timeout = 600;          -- 10分钟
SET GLOBAL interactive_timeout = 600;

-- 3. 增加最大连接数（临时）
SET GLOBAL max_connections = 2000;
```

**📱 应用层面优化**：
```java
// 连接池配置优化
HikariConfig config = new HikariConfig();
config.setMaximumPoolSize(50);      // 最大连接数
config.setMinimumIdle(10);          // 最小空闲连接
config.setIdleTimeout(300000);      // 空闲超时5分钟
config.setConnectionTimeout(30000); // 连接超时30秒
```

---

## 6. 📊 缓存命中率下降分析


### 6.1 什么是缓存命中率


**生活化理解**：就像你的书桌，常用的书放在手边（缓存），不常用的放书架（磁盘）。命中率就是你能从书桌直接拿到书的概率。

```
高命中率（90%+）：大部分数据从内存读取 ✅
低命中率（<80%）：频繁访问磁盘，性能差 ❌

缓存命中率 = 从内存读取次数 / 总读取次数
```

### 6.2 缓存命中率的重要指标


**📈 关键指标监控**
```sql
-- 查看InnoDB缓冲池命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';
SHOW STATUS LIKE 'Innodb_buffer_pool_reads';

-- 计算命中率公式：
-- 命中率 = (read_requests - reads) / read_requests * 100%

-- 查看查询缓存命中率
SHOW STATUS LIKE 'Qcache_hits';
SHOW STATUS LIKE 'Com_select';
```

### 6.3 缓存命中率下降的原因


**🔍 常见原因分析**

```
数据量激增：缓冲池容纳不下所有热点数据
查询模式变化：访问大量冷数据
内存配置不当：缓冲池设置过小
索引缺失：大量随机读取
表结构变化：数据分布发生改变
```

### 6.4 缓存优化实战案例


**📉 案例：电商推荐系统命中率下降**

**背景**：推荐系统缓存命中率从95%下降到60%

**排查过程**：
```sql
-- 1. 检查缓冲池使用情况
SHOW STATUS LIKE 'Innodb_buffer_pool%';

-- 关键指标分析：
-- Innodb_buffer_pool_pages_total: 8192   (总页数)
-- Innodb_buffer_pool_pages_data: 7800    (数据页)
-- Innodb_buffer_pool_pages_free: 392     (空闲页)
-- 发现：缓冲池几乎满了

-- 2. 检查最近访问的表大小
SELECT 
    table_name,
    ROUND(data_length/1024/1024, 2) as data_mb,
    ROUND(index_length/1024/1024, 2) as index_mb
FROM information_schema.tables 
WHERE table_schema = 'ecommerce'
ORDER BY data_length DESC;

-- 发现：用户行为日志表从1GB增长到5GB
```

**🚀 优化方案**：
```sql
-- 1. 增大InnoDB缓冲池
SET GLOBAL innodb_buffer_pool_size = 4294967296;  -- 4GB

-- 2. 优化热点数据访问
CREATE INDEX idx_user_recent ON user_behavior(user_id, create_time);

-- 3. 数据归档策略
-- 只保留最近30天的行为数据
DELETE FROM user_behavior 
WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 4. 分区表设计
ALTER TABLE user_behavior 
PARTITION BY RANGE (TO_DAYS(create_time)) (
    PARTITION p_current VALUES LESS THAN (TO_DAYS('2024-01-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**📊 优化效果**：
```
优化前：命中率 60%，查询平均响应 500ms
优化后：命中率 92%，查询平均响应 50ms
```

---

## 7. 🔍 索引扫描异常案例


### 7.1 什么是索引扫描异常


**简单理解**：索引就像字典的目录，正常情况下我们通过目录快速找到内容。索引扫描异常就是目录"坏了"，只能一页页翻找。

```
正常索引扫描：通过B+树快速定位 ⚡
异常索引扫描：
• 全表扫描（没用上索引）
• 索引范围扫描过大
• 索引选择错误
```

### 7.2 索引扫描异常的表现


**⚠️ 典型症状**
```
查询执行时间突然变长
EXPLAIN显示type=ALL（全表扫描）
rows扫描行数异常多
key显示NULL（没使用索引）
```

### 7.3 索引问题诊断方法


**🔍 诊断步骤**
```sql
-- 1. 分析执行计划
EXPLAIN SELECT * FROM orders WHERE status = 'pending';

-- 2. 查看索引使用统计
SHOW INDEX FROM orders;

-- 3. 查看索引选择性
SELECT 
    COUNT(*) as total_rows,
    COUNT(DISTINCT status) as distinct_values,
    COUNT(DISTINCT status)/COUNT(*) as selectivity
FROM orders;
```

### 7.4 索引扫描异常案例


**📈 案例：订单查询突然变慢**

**现象**：用户订单查询从100ms变成5秒

**问题SQL**：
```sql
SELECT * FROM orders 
WHERE status IN ('pending', 'processing', 'shipped')
ORDER BY create_time DESC 
LIMIT 20;
```

**🔍 问题分析**：
```sql
-- 执行计划分析
EXPLAIN SELECT * FROM orders 
WHERE status IN ('pending', 'processing', 'shipped')
ORDER BY create_time DESC 
LIMIT 20;

-- 结果显示：
-- type: ALL (全表扫描)
-- rows: 1000000 (扫描100万行)
-- Extra: Using where; Using filesort
```

**发现问题**：
```sql
-- 检查现有索引
SHOW INDEX FROM orders;

-- 发现：只有单列索引
-- KEY idx_status (status)
-- KEY idx_create_time (create_time)
-- 但查询需要同时用到status和create_time排序
```

**🔧 解决方案**：
```sql
-- 创建复合索引
CREATE INDEX idx_status_time ON orders(status, create_time DESC);

-- 再次执行计划
EXPLAIN SELECT * FROM orders 
WHERE status IN ('pending', 'processing', 'shipped')
ORDER BY create_time DESC 
LIMIT 20;

-- 优化后结果：
-- type: range (索引范围扫描)
-- rows: 1500 (只扫描1500行)
-- Extra: Using index condition (使用索引条件下推)
```

**📊 性能对比**：
```
优化前：全表扫描100万行，耗时5秒
优化后：索引扫描1500行，耗时100ms
性能提升：50倍
```

---

## 8. 📋 查询计划变更检测


### 8.1 什么是查询计划变更


**通俗解释**：查询计划就像导航路线，MySQL会选择最快的路线执行查询。查询计划变更就是导航突然改变了路线，可能走了更慢的路。

```
稳定的查询计划：始终选择最优执行路径 ✅
不稳定的查询计划：执行路径经常变化 ❌

影响：
• 查询性能不可预期
• 有时快有时慢
• 难以优化
```

### 8.2 查询计划变更的原因


**🔍 常见变更原因**
```
统计信息过时：MySQL对数据分布判断错误
数据分布变化：热点数据迁移
索引统计更新：ANALYZE TABLE后执行计划改变
MySQL版本升级：优化器算法变化
参数调整：optimizer_switch等参数变化
```

### 8.3 查询计划监控方法


**📊 监控执行计划**
```sql
-- 1. 开启慢查询日志记录执行计划
SET GLOBAL log_slow_admin_statements = ON;
SET GLOBAL log_slow_slave_statements = ON;

-- 2. 使用Performance Schema监控
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT,
    SQL_TEXT
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%orders%'
ORDER BY COUNT_STAR DESC;

-- 3. 保存执行计划基线
CREATE TABLE query_plans (
    query_hash VARCHAR(64),
    query_text TEXT,
    explain_result JSON,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 8.4 查询计划变更案例


**⚠️ 案例：报表查询计划异常变更**

**背景**：每日销售报表查询，平时500ms，某天突然变成30秒

**问题查询**：
```sql
SELECT 
    DATE(o.create_time) as order_date,
    COUNT(*) as order_count,
    SUM(oi.quantity * oi.price) as total_amount
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.create_time >= '2023-10-01'
GROUP BY DATE(o.create_time);
```

**🔍 问题排查**：
```sql
-- 1. 对比执行计划
EXPLAIN FORMAT=JSON SELECT ...;

-- 发现执行计划变更：
-- 原计划：orders表走idx_create_time索引
-- 新计划：orders表走主键全扫描

-- 2. 检查表统计信息
SHOW TABLE STATUS LIKE 'orders';
-- 发现：Rows估计值异常

-- 3. 检查索引统计
SHOW INDEX FROM orders;
-- 发现：Cardinality值为0
```

**🔧 解决方案**：
```sql
-- 1. 更新表统计信息
ANALYZE TABLE orders;
ANALYZE TABLE order_items;

-- 2. 强制使用正确的索引（临时方案）
SELECT /*+ USE_INDEX(o, idx_create_time) */
    DATE(o.create_time) as order_date,
    COUNT(*) as order_count,
    SUM(oi.quantity * oi.price) as total_amount
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.create_time >= '2023-10-01'
GROUP BY DATE(o.create_time);

-- 3. 建立执行计划监控
CREATE EVENT monitor_query_plans
ON SCHEDULE EVERY 1 HOUR
DO
  INSERT INTO query_plans (query_hash, query_text, explain_result)
  SELECT 
    MD5(SQL_TEXT),
    SQL_TEXT,
    JSON_OBJECT('explain', 'data')
  FROM performance_schema.events_statements_summary_by_digest
  WHERE DIGEST_TEXT LIKE '%sales_report%';
```

**📈 预防措施**：
```sql
-- 1. 定期更新统计信息
CREATE EVENT update_table_stats
ON SCHEDULE EVERY 1 DAY
STARTS '2023-10-01 02:00:00'
DO
  CALL update_all_table_statistics();

-- 2. 锁定稳定的执行计划
-- MySQL 8.0+ 支持SQL Plan Management
-- 可以固定执行计划避免随意变更
```

---

## 9. 📋 核心要点总结


### 9.1 性能问题诊断思路


```
🎯 诊断流程：
现象观察 → 数据收集 → 原因分析 → 解决验证 → 预防措施

💡 关键原则：
• 先看监控指标，再看具体查询
• 先解决最影响性能的问题
• 优化后要验证效果
• 建立长期监控机制
```

### 9.2 常用性能诊断工具


| 问题类型 | **诊断工具** | **关键指标** | **优化方向** |
|---------|-------------|-------------|-------------|
| **慢查询** | `EXPLAIN, 慢查询日志` | `执行时间, 扫描行数` | `索引优化, SQL重写` |
| **CPU高** | `PROCESSLIST, Performance Schema` | `CPU使用率, 活跃连接` | `查询优化, 并发控制` |
| **内存泄漏** | `系统监控, 内存状态` | `内存使用率, 连接数` | `参数调整, 连接管理` |
| **IO瓶颈** | `iostat, InnoDB状态` | `IO利用率, 缓冲池` | `硬件升级, 缓存优化` |

### 9.3 性能优化最佳实践


**🔧 优化策略**
```
索引优化：
• 为WHERE条件创建合适索引
• 避免冗余和无用索引
• 定期维护索引统计信息

查询优化：
• 避免SELECT *
• 合理使用LIMIT
• 优化JOIN顺序

配置优化：
• 根据硬件调整缓冲池大小
• 合理设置连接参数
• 启用必要的性能监控

架构优化：
• 读写分离减轻主库压力
• 分库分表处理大数据量
• 使用缓存减少数据库访问
```

### 9.4 故障预防建议


**⚠️ 预防措施**
```
监控体系：
• 建立完整的性能监控
• 设置合理的告警阈值
• 定期分析性能趋势

运维规范：
• 定期备份和恢复测试
• 建立变更管理流程
• 制定应急响应预案

性能测试：
• 上线前进行压力测试
• 定期进行性能评估
• 建立性能基线标准
```

**💡 记忆要点**：
- 性能问题要"先监控，后分析，再优化"
- 索引是性能优化的关键，但不是万能的
- 系统性能是多个因素综合影响的结果
- 预防胜于治疗，监控和规范最重要