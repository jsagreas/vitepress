---
title: 23、内存溢出案例
---
## 📚 目录

1. [Buffer Pool溢出案例](#1-buffer-pool溢出案例)
2. [临时表内存超限案例](#2-临时表内存超限案例)
3. [查询内存泄漏案例](#3-查询内存泄漏案例)
4. [sort_buffer_size设置问题](#4-sort_buffer_size设置问题)
5. [内存监控与诊断](#5-内存监控与诊断)
6. [OOM异常处理](#6-oom异常处理)
7. [内存参数调优策略](#7-内存参数调优策略)
8. [内存碎片问题](#8-内存碎片问题)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 💾 Buffer Pool溢出案例


### 1.1 什么是Buffer Pool


**简单理解**：Buffer Pool就像MySQL的"内存仓库"，专门存放经常用到的数据页面。

```
生活中的类比：
图书馆的阅读桌 = Buffer Pool
经常看的书 = 热点数据页
桌子太小放不下 = Buffer Pool溢出

当桌子满了，新书来了就得把旧书放回书架
MySQL也是这样，内存满了就要淘汰旧数据
```

**Buffer Pool的作用**：
- 🔸 **减少磁盘IO**：把常用数据放在内存里，读取速度快1000倍
- 🔸 **提升查询速度**：内存中找数据比从硬盘找快得多
- 🔸 **缓存修改操作**：先在内存中改，定时写回磁盘

### 1.2 典型溢出案例


**案例背景**：
某电商网站在促销活动期间，MySQL服务器频繁出现内存不足，查询响应缓慢。

**问题现象**：
```sql
-- 查看Buffer Pool使用情况
SHOW ENGINE INNODB STATUS;
-- 发现：Buffer pool size: 1024 pages
-- Free buffers: 0  <-- 没有空闲缓冲区了！
```

**根本原因**：
```
Buffer Pool配置过小：
- 服务器总内存：32GB
- Buffer Pool大小：只设置了128MB (太小了！)
- 活跃数据量：约8GB
- 结果：内存根本装不下热点数据
```

### 1.3 解决方案


**内存配置调整**：
```sql
# my.cnf配置文件
[mysqld]
# 原来的错误配置
# innodb_buffer_pool_size = 128M

# 优化后的配置（建议总内存的70-80%）
innodb_buffer_pool_size = 24G
innodb_buffer_pool_instances = 8  # 分成8个实例，减少锁竞争
```

**效果验证**：
```sql
-- 检查配置是否生效
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
-- 结果：25,769,803,776 (约24GB)

-- 监控Buffer Pool命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';
-- 期望命中率 > 99%
```

---

## 2. 📊 临时表内存超限案例


### 2.1 临时表是什么


**通俗解释**：临时表就像草稿纸，MySQL在处理复杂查询时创建的"临时工作区"。

```
生活类比：
做数学题时的草稿纸 = 临时表
复杂运算过程 = SQL查询处理
草稿纸用完了 = 临时表内存超限
```

**临时表的使用场景**：
- 🔸 **ORDER BY排序**：数据量大时需要临时存储
- 🔸 **GROUP BY分组**：统计计算时的中间结果
- 🔸 **子查询**：复杂查询的中间数据
- 🔸 **UNION操作**：合并多个查询结果

### 2.2 内存超限案例


**问题SQL**：
```sql
-- 这个查询会产生大量临时数据
SELECT customer_id, COUNT(*), AVG(order_amount)
FROM orders 
WHERE order_date >= '2024-01-01'
GROUP BY customer_id
ORDER BY COUNT(*) DESC;
-- 订单表有500万行记录，客户有10万个
```

**问题分析**：
```
临时表大小计算：
- 客户数量：100,000个
- 每行数据：customer_id(8字节) + COUNT(8字节) + AVG(8字节) = 24字节
- 临时表大小：100,000 × 24 = 2.4MB (看似不大)
- 但是！排序过程需要额外空间，实际需要10MB+

默认配置问题：
tmp_table_size = 16M  # 临时表内存限制
max_heap_table_size = 16M  # 内存表大小限制
```

**错误现象**：
```sql
-- 查看临时表使用情况
SHOW STATUS LIKE 'Created_tmp%';
-- Created_tmp_disk_tables: 1250  <-- 创建了磁盘临时表
-- Created_tmp_tables: 1500       <-- 总临时表数
-- 磁盘临时表比例 = 1250/1500 = 83% (太高了！)
```

### 2.3 优化解决方案


**参数调优**：
```sql
# my.cnf配置调整
[mysqld]
tmp_table_size = 256M      # 增加临时表内存
max_heap_table_size = 256M # 增加内存表大小
```

**SQL优化**：
```sql
-- 原查询问题：全表扫描+大量临时数据
SELECT customer_id, COUNT(*), AVG(order_amount)
FROM orders 
WHERE order_date >= '2024-01-01'
GROUP BY customer_id
ORDER BY COUNT(*) DESC;

-- 优化后：添加索引，分页查询
-- 1. 创建复合索引
CREATE INDEX idx_orders_date_customer ON orders(order_date, customer_id);

-- 2. 分页获取结果
SELECT customer_id, COUNT(*) as order_count, AVG(order_amount) as avg_amount
FROM orders 
WHERE order_date >= '2024-01-01'
GROUP BY customer_id
ORDER BY order_count DESC
LIMIT 0, 100;  # 分页获取，减少内存压力
```

---

## 3. 🔍 查询内存泄漏案例


### 3.1 什么是查询内存泄漏


**通俗理解**：就像水龙头没关严，内存一点点流失，最终耗尽。

```
现实类比：
水龙头滴水 = 内存泄漏
水费越来越高 = 内存占用增长
最终停水 = 系统OOM崩溃
```

### 3.2 典型泄漏案例


**问题背景**：某应用系统MySQL内存使用率持续上升，最终导致OOM。

**泄漏SQL示例**：
```sql
-- 问题查询：没有WHERE条件的大表关联
SELECT a.*, b.*, c.*
FROM user_behavior a
LEFT JOIN user_profile b ON a.user_id = b.user_id  
LEFT JOIN user_preference c ON a.user_id = c.user_id;
-- user_behavior表：1000万行
-- 结果集：可能产生数亿行数据
```

**内存泄漏监控**：
```sql
-- 查看当前连接的内存使用
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE TIME > 300;  -- 查找运行超过5分钟的查询

-- 查看全局内存使用情况
SHOW STATUS LIKE 'Connection%';
SHOW STATUS LIKE '%memory%';
```

### 3.3 泄漏定位方法


**系统级监控**：
```bash
# 监控MySQL进程内存使用
top -p $(pgrep mysql)

# 详细内存分析
cat /proc/$(pgrep mysql)/status | grep VmRSS
# VmRSS: 物理内存使用量

# 查看MySQL错误日志
tail -f /var/log/mysql/error.log | grep -i memory
```

**MySQL内部诊断**：
```sql
-- 查看性能schema中的内存使用
SELECT 
    event_name,
    current_alloc,
    high_alloc
FROM performance_schema.memory_summary_global_by_event_name 
WHERE current_alloc > 0 
ORDER BY current_alloc DESC 
LIMIT 10;
```

### 3.4 解决方案


**查询优化**：
```sql
-- 原问题查询（内存杀手）
SELECT a.*, b.*, c.*
FROM user_behavior a
LEFT JOIN user_profile b ON a.user_id = b.user_id  
LEFT JOIN user_preference c ON a.user_id = c.user_id;

-- 优化方案1：添加WHERE条件
SELECT a.*, b.*, c.*
FROM user_behavior a
LEFT JOIN user_profile b ON a.user_id = b.user_id  
LEFT JOIN user_preference c ON a.user_id = c.user_id
WHERE a.create_time >= CURDATE() - INTERVAL 7 DAY;  -- 只查最近7天

-- 优化方案2：只选需要的字段
SELECT 
    a.user_id, 
    a.action_type, 
    b.user_name,
    c.preference_tag
FROM user_behavior a
LEFT JOIN user_profile b ON a.user_id = b.user_id  
LEFT JOIN user_preference c ON a.user_id = c.user_id
WHERE a.create_time >= CURDATE() - INTERVAL 7 DAY;
```

---

## 4. 🔧 sort_buffer_size设置问题


### 4.1 sort_buffer_size是什么


**简单理解**：sort_buffer_size就像排序时使用的"工作台"，台子越大，能同时处理的数据越多。

```
生活类比：
整理扑克牌的桌面 = sort_buffer_size
桌面小：要分多次整理 = 多次排序，效率低
桌面大：一次性整理完 = 一次排序，效率高
```

### 4.2 配置不当案例


**案例1：设置过小**
```sql
# 错误配置
sort_buffer_size = 32K  # 太小了！

-- 问题查询
SELECT * FROM products ORDER BY price DESC LIMIT 1000;
-- products表有100万行，排序数据量大

-- 结果：频繁使用磁盘临时文件
SHOW STATUS LIKE 'Sort_merge_passes';
-- Sort_merge_passes: 1500  (数值很高，表示多次磁盘排序)
```

**案例2：设置过大**
```sql
# 错误配置
sort_buffer_size = 1G  # 太大了！

# 问题：
# 1. 每个连接都分配1GB内存
# 2. 100个并发连接 = 100GB内存需求
# 3. 服务器内存不足，导致swap
```

### 4.3 合理配置方案


**配置原则**：
```sql
# 推荐配置（根据实际情况调整）
sort_buffer_size = 2M    # 一般查询够用
max_sort_length = 1024   # 排序字段长度限制

# 配置计算公式：
# sort_buffer_size × max_connections ≤ 总内存 × 50%
# 例如：2M × 200连接 = 400M ≤ 8GB × 50% = 4GB ✓
```

**动态调整**：
```sql
-- 对于特殊的大排序查询，可以临时调整
SET SESSION sort_buffer_size = 16M;
SELECT * FROM big_table ORDER BY complex_field;
SET SESSION sort_buffer_size = 2M;  -- 用完后恢复
```

---

## 5. 📈 内存监控与诊断


### 5.1 关键监控指标


**Buffer Pool指标**：
```sql
-- Buffer Pool命中率（最重要的指标）
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';

-- 计算命中率
SELECT 
  (1 - Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests) * 100 
  AS hit_ratio;
-- 期望值：> 99%
```

**临时表指标**：
```sql
-- 临时表使用情况
SHOW STATUS LIKE 'Created_tmp%';

-- 磁盘临时表比例
SELECT 
  (Created_tmp_disk_tables/Created_tmp_tables) * 100 
  AS disk_tmp_ratio;
-- 期望值：< 25%
```

### 5.2 内存使用峰值分析


**系统级监控**：
```bash
# 实时监控MySQL内存使用
while true; do
  echo "$(date): $(ps -o pid,vsz,rss,pmem,comm -p $(pgrep mysql))"
  sleep 60
done > mysql_memory.log

# 分析内存使用模式
awk '{print $1, $4}' mysql_memory.log | 
grep -v VSZ | 
sort -k2 -nr | 
head -10
```

**MySQL性能监控**：
```sql
-- 使用performance_schema监控内存
SELECT 
    SUBSTRING_INDEX(event_name, '/', -1) as memory_type,
    ROUND(SUM(current_alloc)/1024/1024, 2) as current_mb,
    ROUND(SUM(high_alloc)/1024/1024, 2) as peak_mb
FROM performance_schema.memory_summary_global_by_event_name 
WHERE current_alloc > 0
GROUP BY memory_type
ORDER BY current_mb DESC;
```

### 5.3 自动化监控脚本


```bash
#!/bin/bash
# MySQL内存监控脚本
MYSQL_USER="monitor_user"
MYSQL_PASS="monitor_pass"

# 检查Buffer Pool命中率
hit_ratio=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -e "
SELECT ROUND((1-Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests)*100,2) 
AS hit_ratio;" 2>/dev/null | tail -1)

if (( $(echo "$hit_ratio < 95" | bc -l) )); then
    echo "警告：Buffer Pool命中率过低 ($hit_ratio%)"
    # 发送告警邮件或短信
fi

# 检查临时表使用情况
disk_tmp_ratio=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -e "
SELECT ROUND((Created_tmp_disk_tables/Created_tmp_tables)*100,2) 
AS disk_tmp_ratio;" 2>/dev/null | tail -1)

if (( $(echo "$disk_tmp_ratio > 30" | bc -l) )); then
    echo "警告：磁盘临时表使用率过高 ($disk_tmp_ratio%)"
fi
```

---

## 6. 🆘 OOM异常处理


### 6.1 什么是OOM


**OOM (Out Of Memory)**：就是内存用完了，系统"弹尽粮绝"的状态。

```
生活类比：
手机内存不足 = OOM
无法安装新APP = 无法处理新请求  
手机卡死重启 = 服务器kill进程
```

### 6.2 OOM典型场景


**场景1：大查询导致OOM**
```sql
-- 危险查询：返回大量数据
SELECT * FROM log_table WHERE date >= '2024-01-01';
-- log_table有5000万行记录，结果集可能几GB大小
```

**场景2：连接数过多**
```sql
-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';
-- Threads_connected: 800

-- 如果每连接占用10MB，800连接 = 8GB内存
-- 超过服务器总内存就会OOM
```

### 6.3 OOM紧急处理方案


**立即措施**：
```bash
# 1. 查看系统内存状态
free -h
cat /proc/meminfo | grep -i available

# 2. 找出占用内存最大的MySQL进程
ps aux | grep mysql | sort -k4 -nr

# 3. 查看MySQL错误日志
tail -100 /var/log/mysql/error.log | grep -i "out of memory"

# 4. 紧急重启MySQL（谨慎操作）
systemctl restart mysql
```

**MySQL内部处理**：
```sql
-- 查看当前运行的查询
SHOW PROCESSLIST;

-- 杀掉占用内存大的查询
KILL 12345;  -- 12345是进程ID

-- 临时降低内存参数
SET GLOBAL sort_buffer_size = 1M;
SET GLOBAL tmp_table_size = 32M;
```

### 6.4 OOM预防策略


**系统层面配置**：
```bash
# /etc/sysctl.conf 配置swap使用
vm.swappiness = 10  # 降低swap使用倾向
vm.overcommit_memory = 2  # 严格内存分配检查

# 设置MySQL进程的内存限制（systemd）
# /etc/systemd/system/mysql.service.d/override.conf
[Service]
MemoryLimit=20G  # 限制MySQL最大使用20GB内存
```

**MySQL层面配置**：
```sql
# my.cnf 内存相关配置
[mysqld]
# 核心内存参数
innodb_buffer_pool_size = 16G
sort_buffer_size = 2M
tmp_table_size = 128M
max_heap_table_size = 128M

# 连接相关
max_connections = 200
thread_cache_size = 50

# 查询限制
max_join_size = 1000000  # 限制JOIN操作的行数
```

---

## 7. ⚙️ 内存参数调优策略


### 7.1 内存参数全景图


```
MySQL内存使用结构：
┌─────────────────────────────────┐
│          MySQL总内存             │
├─────────────────────────────────┤
│  InnoDB Buffer Pool (60-80%)   │ ← 最大内存消耗者
├─────────────────────────────────┤
│  连接内存 (sort_buffer等)        │ ← 与连接数相关
├─────────────────────────────────┤
│  临时表内存 (tmp_table_size)    │ ← 查询临时使用
├─────────────────────────────────┤
│  其他内存 (binlog cache等)      │ ← 各种缓存
└─────────────────────────────────┘
```

### 7.2 参数调优步骤


**第一步：评估硬件资源**
```bash
# 查看总内存
free -h
# 示例输出：
#              total        used        free      shared
# Mem:           32G         8.2G        23G        245M

# 计算MySQL可用内存 = 总内存 × 80% = 32G × 80% = 25.6G
```

**第二步：配置Buffer Pool**
```sql
# Buffer Pool是重中之重，分配60-70%的可用内存
innodb_buffer_pool_size = 18G  # 25.6G × 70% ≈ 18G
innodb_buffer_pool_instances = 8  # CPU核心数，减少锁竞争
```

**第三步：配置连接相关内存**
```sql
# 计算连接内存需求
# 每连接内存 = sort_buffer + read_buffer + join_buffer + ...
# 预估每连接 5-10MB

max_connections = 200        # 最大连接数
sort_buffer_size = 2M        # 排序缓冲区
read_buffer_size = 1M        # 顺序读缓冲区  
join_buffer_size = 2M        # JOIN缓冲区
thread_cache_size = 50       # 线程缓存

# 连接总内存预估 = 200 × 8M = 1.6G
```

**第四步：配置临时表内存**
```sql
tmp_table_size = 256M        # 临时表内存限制
max_heap_table_size = 256M   # 内存表大小限制
```

### 7.3 调优验证方法


**内存使用验证**：
```sql
-- 查看实际内存使用情况
SELECT 
    ($$innodb_buffer_pool_size) / 1024 / 1024 / 1024 AS buffer_pool_gb,
    ($$max_connections * ($$sort_buffer_size + $$read_buffer_size + $$join_buffer_size)) 
    / 1024 / 1024 / 1024 AS connection_memory_gb;
```

**性能指标验证**：
```sql
-- Buffer Pool命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';

-- 临时表使用情况  
SHOW STATUS LIKE 'Created_tmp%';

-- 排序操作情况
SHOW STATUS LIKE 'Sort%';
```

---

## 8. 🧩 内存碎片问题


### 8.1 什么是内存碎片


**通俗理解**：内存碎片就像停车场的碎片化停车位，总空间够，但找不到连续的大空间。

```
停车场类比：
┌─────┬─────┬─────┬─────┬─────┐
│ 空  │ 占用 │ 空  │ 占用 │ 空  │  ← 内存碎片化
└─────┴─────┴─────┴─────┴─────┘
虽然有3个空位，但放不下一辆大卡车

理想状态：
┌─────┬─────┬─────┬─────┬─────┐
│ 空  │ 空  │ 空  │ 占用 │ 占用 │  ← 内存整理后
└─────┴─────┴─────┴─────┴─────┘
3个连续空位，可以停大卡车
```

### 8.2 碎片产生原因


**InnoDB层面碎片**：
```sql
-- 查看表的碎片情况
SELECT 
    table_schema,
    table_name,
    ROUND(data_length/1024/1024, 2) as data_mb,
    ROUND(index_length/1024/1024, 2) as index_mb,
    ROUND(data_free/1024/1024, 2) as free_mb,
    ROUND(data_free/(data_length+index_length+data_free)*100, 2) as fragment_pct
FROM information_schema.tables 
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema')
AND data_free > 0
ORDER BY fragment_pct DESC;
```

**系统层面碎片**：
```bash
# 查看系统内存碎片
cat /proc/buddyinfo
# 显示各种大小的连续内存块数量

# 查看内存碎片化程度
grep -i fragment /proc/meminfo
```

### 8.3 碎片清理方法


**表级碎片整理**：
```sql
-- 整理单个表（会锁表，谨慎使用）
OPTIMIZE TABLE user_orders;

-- 批量整理碎片较多的表
SELECT CONCAT('OPTIMIZE TABLE ', table_schema, '.', table_name, ';') as optimize_sql
FROM information_schema.tables 
WHERE table_schema = 'your_database'
AND data_free > data_length * 0.1  -- 碎片超过10%
AND engine = 'InnoDB';
```

**系统级内存整理**：
```bash
# 清理系统缓存（谨慎操作）
sync
echo 1 > /proc/sys/vm/drop_caches  # 清理页缓存
echo 2 > /proc/sys/vm/drop_caches  # 清理目录项和inode缓存  
echo 3 > /proc/sys/vm/drop_caches  # 清理所有缓存
```

### 8.4 预防碎片策略


**表结构设计**：
```sql
-- 使用合理的主键设计
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- 自增主键，减少页分裂
    order_no VARCHAR(32),
    customer_id INT,
    -- ...
    INDEX idx_customer (customer_id)
);

-- 避免频繁的UPDATE操作改变行大小
-- 将经常变化的字段分离到单独表
```

**定期维护策略**：
```bash
#!/bin/bash
# 定期碎片整理脚本（建议在业务低峰期执行）

# 检查碎片化程度
mysql -e "
SELECT table_name, 
       ROUND(data_free/(data_length+index_length+data_free)*100, 2) as fragment_pct
FROM information_schema.tables 
WHERE table_schema = 'your_db' 
AND data_free/(data_length+index_length+data_free) > 0.2
ORDER BY fragment_pct DESC;
" > fragment_report.txt

# 如果碎片化严重，发送告警
if [ -s fragment_report.txt ]; then
    echo "发现严重碎片化表，需要维护" | mail -s "MySQL碎片告警" admin@company.com
fi
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Buffer Pool：MySQL最重要的内存缓存，影响90%的查询性能
🔸 临时表内存：处理排序、分组、子查询的工作区域  
🔸 连接内存：每个数据库连接分配的专用内存空间
🔸 内存泄漏：程序bug导致内存无法释放，最终耗尽系统资源
🔸 OOM异常：系统内存不足，无法分配新内存的严重故障
🔸 内存碎片：内存空间不连续，影响大内存块的分配效率
```

### 9.2 关键内存参数配置


| 参数名称 | **推荐配置** | **作用说明** | **配置依据** |
|---------|-------------|-------------|-------------|
| `innodb_buffer_pool_size` | `总内存×70%` | InnoDB数据页缓存 | 最重要参数，影响查询性能 |
| `sort_buffer_size` | `2-8M` | 排序操作缓冲区 | 太大浪费内存，太小多次排序 |
| `tmp_table_size` | `128-512M` | 临时表内存限制 | 根据查询复杂度调整 |
| `max_connections` | `100-500` | 最大连接数限制 | 平衡并发与内存使用 |
| `thread_cache_size` | `50-200` | 连接线程缓存 | 减少线程创建开销 |

### 9.3 故障排查思路


**内存问题诊断流程**：
```
步骤1：确认问题现象
├─ 查询缓慢 → 检查Buffer Pool命中率
├─ 临时文件多 → 检查tmp_table_size配置  
├─ 系统卡顿 → 检查内存使用和swap
└─ 服务崩溃 → 检查error.log中的OOM信息

步骤2：定位根本原因
├─ SQL分析 → 找出内存消耗大的查询
├─ 参数检查 → 验证内存相关参数配置
├─ 监控数据 → 分析内存使用趋势
└─ 系统资源 → 评估硬件资源是否充足

步骤3：制定解决方案
├─ 紧急处理 → kill占用内存大的查询，重启服务
├─ 参数优化 → 调整内存相关配置参数
├─ SQL优化 → 改写有问题的SQL语句
└─ 容量规划 → 评估是否需要硬件升级
```

### 9.4 最佳实践原则


**🔹 内存分配原则**
```
70-80%原则：MySQL占用系统总内存的70-80%
60-70%原则：Buffer Pool占用MySQL内存的60-70%
预留原则：为操作系统和其他进程预留20-30%内存
弹性原则：为突发情况预留10-20%的内存空间
```

**🔹 监控告警策略**  
```
内存使用率 > 85% → 一般告警
Buffer Pool命中率 < 95% → 重要告警
磁盘临时表比例 > 30% → 性能告警
系统开始使用swap → 紧急告警
```

**🔹 日常维护要点**
```
每日检查：内存使用情况和关键性能指标
每周分析：慢查询日志中的内存相关问题  
每月整理：清理内存碎片和过期数据
每季度评估：容量规划和参数优化
```

### 9.5 紧急处理清单


**内存紧急释放方案**：
```bash
# 1. 立即执行（按优先级）
killall -9 mysql_slow_query     # 杀掉慢查询
systemctl restart mysql         # 重启MySQL服务
echo 3 > /proc/sys/vm/drop_caches # 清理系统缓存

# 2. 临时缓解措施  
SET GLOBAL sort_buffer_size = 1M;
SET GLOBAL tmp_table_size = 32M;
SET GLOBAL max_connections = 50;

# 3. 查找问题根源
SHOW PROCESSLIST;               # 找出占用内存的查询
SHOW ENGINE INNODB STATUS;     # 检查InnoDB状态
tail -f /var/log/mysql/error.log # 监控错误日志
```

**核心记忆口诀**：
- Buffer Pool是核心，配置需谨慎
- 临时表内存限，查询要优化  
- 连接数控制好，避免内存爆
- 监控要及时，告警莫忽视
- 碎片定期理，性能保稳定