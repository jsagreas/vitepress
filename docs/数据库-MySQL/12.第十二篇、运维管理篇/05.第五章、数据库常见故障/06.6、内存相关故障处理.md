---
title: 6、内存相关故障处理
---
## 📚 目录

1. [内存故障概述](#1-内存故障概述)
2. [Out of Memory错误处理](#2-out-of-memory错误处理)
3. [InnoDB Buffer Pool优化](#3-innodb-buffer-pool优化)
4. [临时表内存问题](#4-临时表内存问题)
5. [查询内存优化](#5-查询内存优化)
6. [系统级内存监控](#6-系统级内存监控)
7. [内存参数调优策略](#7-内存参数调优策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 内存故障概述


### 1.1 什么是MySQL内存故障


**💡 通俗理解**：MySQL内存故障就像你的电脑内存不够用了，程序运行缓慢甚至崩溃

```
现实类比：
厨房做饭 = MySQL处理数据
厨房台面 = 内存空间
食材太多台面放不下 = 内存不足故障

结果：
- 做饭效率低下 = 查询变慢
- 无法继续做饭 = 服务崩溃
```

### 1.2 常见内存故障类型


**🔸 主要故障分类**
```
📊 按故障来源分类：

应用层故障：
• 大查询消耗过多内存
• 复杂JOIN操作内存溢出
• 临时表过大导致内存不足

系统层故障：
• 物理内存不足
• OOM Killer杀死MySQL进程
• 内存碎片导致分配失败

配置层故障：
• 缓冲池配置过大
• 排序缓冲区设置不当
• 连接数过多耗尽内存
```

### 1.3 内存故障的影响


**⚠️ 故障带来的问题**
```
性能影响：
• 查询响应时间急剧增加
• 并发处理能力下降
• 系统整体吞吐量降低

服务影响：
• 连接被拒绝
• 事务回滚
• 服务完全不可用

数据影响：
• 正在处理的事务丢失
• 缓存数据丢失需重建
• 可能的数据不一致
```

---

## 2. ❌ Out of Memory错误处理


### 2.1 Out of Memory错误详解


**🔸 错误现象识别**
```
错误日志表现：
[ERROR] Out of memory (Needed 8388608 bytes)
[ERROR] MySQL server has gone away
[ERROR] Lost connection to MySQL server during query

系统表现：
• 查询执行中断
• 连接突然断开
• MySQL进程被系统终止
```

**💭 为什么会出现OOM**
```
根本原因：
内存需求 > 可用内存

具体触发条件：
1. 单个查询需要的内存超过限制
2. 多个并发查询同时消耗大量内存
3. 系统总内存不足，MySQL被OOM Killer终止
4. 内存泄漏导致可用内存逐渐减少
```

### 2.2 OOM错误排查步骤


**🔍 系统级排查**
```bash
# 1. 查看系统内存使用情况
free -h
htop

# 2. 检查OOM Killer日志
dmesg | grep -i "killed process"
journalctl | grep -i "out of memory"

# 3. 查看MySQL进程内存使用
ps aux | grep mysql
cat /proc/$(pidof mysqld)/status | grep VmRSS
```

**📋 MySQL级别排查**
```sql
-- 查看当前内存使用情况
SHOW STATUS LIKE 'Innodb_buffer_pool_pages_total';
SHOW STATUS LIKE 'Innodb_buffer_pool_pages_free';

-- 查看活跃连接和查询
SHOW PROCESSLIST;
SELECT * FROM performance_schema.events_statements_current 
WHERE SQL_TEXT IS NOT NULL;

-- 检查内存相关配置
SHOW VARIABLES LIKE '%buffer%';
SHOW VARIABLES LIKE '%sort_buffer%';
```

### 2.3 OOM错误解决方案


**🛠️ 紧急处理措施**
```bash
# 1. 立即重启MySQL服务
systemctl restart mysql

# 2. 临时调整内存参数
mysql -e "SET GLOBAL innodb_buffer_pool_size = 512M;"
mysql -e "SET GLOBAL sort_buffer_size = 256K;"

# 3. 限制并发连接数
mysql -e "SET GLOBAL max_connections = 50;"
```

**🔧 根本解决方案**
```
硬件层面：
• 增加物理内存
• 使用SSD提高IO性能减少内存依赖

配置层面：
• 合理配置缓冲池大小
• 调整查询相关内存参数
• 优化连接参数设置

应用层面：
• 优化SQL查询语句
• 避免大表全表扫描
• 合理使用分页查询
```

---

## 3. 🗄️ InnoDB Buffer Pool优化


### 3.1 InnoDB Buffer Pool基础知识


**📖 什么是Buffer Pool**
```
通俗解释：
Buffer Pool就像图书馆的阅览室
• 把常用的书(数据页)放在阅览室(内存)
• 读者(查询)直接在阅览室找书，速度快
• 不用每次都去书库(磁盘)取书

技术定义：
InnoDB存储引擎的内存缓存区域
• 缓存数据页和索引页
• 减少磁盘IO操作
• 提高数据访问速度
```

### 3.2 Buffer Pool大小配置


**📏 合理配置原则**
```
配置建议：
专用MySQL服务器：物理内存的70-80%
混合服务器：物理内存的50-60%
开发测试环境：物理内存的30-40%

计算示例：
服务器内存16GB，专用MySQL服务器
推荐配置：16GB × 75% = 12GB
```

**⚙️ 配置方法**
```ini
# my.cnf配置文件
[mysqld]
# 设置Buffer Pool大小为12GB
innodb_buffer_pool_size = 12G

# 设置Buffer Pool实例数(CPU核心数)
innodb_buffer_pool_instances = 8

# 预热Buffer Pool
innodb_buffer_pool_dump_at_shutdown = 1
innodb_buffer_pool_load_at_startup = 1
```

### 3.3 Buffer Pool监控指标


**📊 关键监控指标**
```sql
-- Buffer Pool使用率
SELECT 
  ROUND(
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') * 100.0 /
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
  ) AS buffer_pool_utilization_pct;

-- Buffer Pool命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';
SHOW STATUS LIKE 'Innodb_buffer_pool_reads';
```

**🎯 性能指标解读**
```
命中率计算：
命中率 = (read_requests - reads) / read_requests × 100%

性能标准：
• 优秀：命中率 > 99%
• 良好：命中率 95-99%
• 需优化：命中率 < 95%

使用率标准：
• 合理：使用率 80-90%
• 偏低：使用率 < 60%（配置过大）
• 偏高：使用率 > 95%（配置过小）
```

### 3.4 Buffer Pool故障处理


**🚨 常见Buffer Pool问题**
```
问题1：Buffer Pool配置过大
现象：系统启动失败，OOM错误
解决：减小innodb_buffer_pool_size

问题2：Buffer Pool效率低
现象：命中率低，IO压力大
解决：增大Buffer Pool或优化查询

问题3：Buffer Pool碎片
现象：使用率不高但性能差
解决：重启MySQL重建Buffer Pool
```

---

## 4. 🗂️ 临时表内存问题


### 4.1 临时表内存机制


**📝 什么是临时表**
```
生活类比：
临时表就像做菜时的临时盘子
• 准备食材时暂时放菜的盘子
• 用完就扔掉，不占用正式餐具
• 如果食材太多，临时盘子不够用

技术含义：
MySQL处理复杂查询时创建的临时存储
• GROUP BY、ORDER BY、DISTINCT操作
• 子查询和复杂JOIN
• UNION操作
```

### 4.2 临时表内存配置


**⚙️ 关键参数设置**
```ini
# my.cnf配置
[mysqld]
# 临时表最大内存大小
tmp_table_size = 64M
max_heap_table_size = 64M

# 临时文件目录(SSD优先)
tmpdir = /tmp

# 内部临时表存储引擎
internal_tmp_disk_storage_engine = InnoDB
```

**📋 参数含义解释**
```
tmp_table_size：
• 内存中临时表的最大大小
• 超过这个值就写入磁盘
• 默认16MB，建议32-128MB

max_heap_table_size：
• MEMORY引擎表的最大大小
• 与tmp_table_size配合使用
• 通常设置为相同值

建议配置：
• 小型应用：32MB
• 中型应用：64-128MB  
• 大型应用：256MB-1GB
```

### 4.3 临时表问题排查


**🔍 监控临时表使用**
```sql
-- 查看临时表创建统计
SHOW STATUS LIKE 'Created_tmp_tables';
SHOW STATUS LIKE 'Created_tmp_disk_tables';

-- 计算磁盘临时表比例
SELECT 
  ROUND(
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') * 100.0 /
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Created_tmp_tables'), 2
  ) AS disk_tmp_table_pct;
```

**📊 性能指标标准**
```
磁盘临时表比例：
• 优秀：< 5%
• 良好：5-15%
• 需要优化：> 25%

优化建议：
比例过高时：
1. 增大tmp_table_size
2. 优化查询语句
3. 添加合适索引
4. 避免大结果集的ORDER BY
```

### 4.4 临时表优化策略


**🎯 查询优化**
```sql
-- 问题查询示例
SELECT column1, COUNT(*) 
FROM large_table 
GROUP BY column1 
ORDER BY COUNT(*) DESC;

-- 优化后查询
-- 1. 添加索引
CREATE INDEX idx_column1 ON large_table(column1);

-- 2. 使用LIMIT限制结果
SELECT column1, COUNT(*) 
FROM large_table 
GROUP BY column1 
ORDER BY COUNT(*) DESC 
LIMIT 100;
```

**💡 避免临时表的技巧**
```
索引优化：
• 为GROUP BY字段创建索引
• 为ORDER BY字段创建索引
• 创建复合索引覆盖查询字段

查询改写：
• 使用子查询替代复杂JOIN
• 分步骤处理大数据集
• 避免SELECT *
• 合理使用LIMIT
```

---

## 5. 🔍 查询内存优化


### 5.1 查询内存分配机制


**🧠 MySQL查询内存结构**
```
查询内存组成：
┌─────────────────────┐
│   连接内存缓冲区     │ ← 每个连接独占
├─────────────────────┤
│   查询缓存区        │ ← 结果集缓存
├─────────────────────┤
│   排序缓冲区        │ ← ORDER BY使用
├─────────────────────┤
│   连接缓冲区        │ ← JOIN操作使用
├─────────────────────┤
│   读取缓冲区        │ ← 表扫描使用
└─────────────────────┘
```

### 5.2 关键内存参数配置


**⚙️ 核心参数设置**
```ini
# my.cnf查询内存配置
[mysqld]
# 排序缓冲区大小
sort_buffer_size = 2M

# JOIN缓冲区大小  
join_buffer_size = 2M

# 读取缓冲区大小
read_buffer_size = 128K

# 随机读取缓冲区
read_rnd_buffer_size = 256K

# 批量插入缓冲区
bulk_insert_buffer_size = 8M
```

**📖 参数详细说明**
```
sort_buffer_size：
• 用途：ORDER BY和GROUP BY操作
• 过小：频繁使用磁盘临时文件
• 过大：浪费内存，可能OOM
• 建议：256K-4M

join_buffer_size：
• 用途：表连接操作
• 影响：嵌套循环连接性能
• 建议：128K-2M

read_buffer_size：
• 用途：全表扫描
• 影响：MyISAM表扫描速度
• 建议：128K-1M
```

### 5.3 大查询内存问题


**🚨 大查询识别**
```sql
-- 查找长时间运行的查询
SELECT 
  ID, USER, HOST, DB, COMMAND, TIME, STATE, INFO
FROM information_schema.PROCESSLIST 
WHERE TIME > 30 AND COMMAND != 'Sleep'
ORDER BY TIME DESC;

-- 查看查询内存使用
SELECT 
  thread_id,
  event_name,
  current_allocated,
  current_count_used
FROM performance_schema.memory_summary_by_thread_by_event_name
WHERE current_allocated > 1024*1024  -- 大于1MB
ORDER BY current_allocated DESC;
```

**🛠️ 大查询优化策略**
```
分页处理：
-- 问题：大结果集查询
SELECT * FROM large_table ORDER BY id;

-- 解决：使用LIMIT分页
SELECT * FROM large_table ORDER BY id LIMIT 1000 OFFSET 0;

批量处理：
-- 问题：大量数据更新
UPDATE large_table SET status = 1 WHERE condition;

-- 解决：分批更新
UPDATE large_table SET status = 1 WHERE condition LIMIT 1000;
```

### 5.4 内存泄漏检测


**🔍 内存泄漏排查**
```sql
-- 监控内存使用趋势
SELECT 
  NOW() as check_time,
  ROUND(SUM(current_allocated)/1024/1024, 2) as memory_mb
FROM performance_schema.memory_summary_global_by_event_name;

-- 查看连接内存使用
SELECT 
  PROCESSLIST_ID,
  PROCESSLIST_USER,
  PROCESSLIST_HOST,
  ROUND(SUM(current_allocated)/1024/1024, 2) as memory_mb
FROM performance_schema.memory_summary_by_thread_by_event_name t
JOIN performance_schema.threads th ON t.thread_id = th.thread_id
WHERE th.processlist_id IS NOT NULL
GROUP BY PROCESSLIST_ID
ORDER BY memory_mb DESC;
```

**💡 预防内存泄漏**
```
应用层面：
• 及时关闭数据库连接
• 避免长时间持有连接
• 合理设置连接超时时间

配置层面：
• 设置合理的wait_timeout
• 限制max_connections
• 监控连接池使用情况

监控层面：
• 定期检查内存使用趋势
• 设置内存使用报警
• 监控异常查询模式
```

---

## 6. 🖥️ 系统级内存监控


### 6.1 系统OOM Killer机制


**⚠️ 什么是OOM Killer**
```
通俗解释：
OOM Killer像小区保安
• 当内存资源紧张时(小区车位不够)
• 选择"最不重要"的进程杀掉(让违停车走人)
• 释放内存给其他进程(腾出车位)

技术含义：
Linux内核的内存保护机制
• 当系统内存严重不足时启动
• 选择占用内存最多的进程终止
• MySQL常常成为被杀掉的目标
```

### 6.2 OOM Killer日志分析


**📋 日志查看方法**
```bash
# 查看OOM Killer日志
dmesg | grep -i "killed process"
journalctl -k | grep "Out of memory"

# 查看详细OOM信息
grep -i "out of memory" /var/log/messages
grep -i "oom" /var/log/syslog
```

**🔍 日志内容解读**
```
典型OOM日志：
Out of memory: Kill process 1234 (mysqld) score 800 or sacrifice child
Killed process 1234 (mysqld) total-vm:8388608kB, anon-rss:6291456kB

关键信息：
• process 1234：被杀进程ID
• mysqld：被杀进程名
• score 800：OOM评分(越高越容易被杀)
• total-vm：虚拟内存大小
• anon-rss：实际物理内存使用
```

### 6.3 预防OOM Killer


**🛡️ 系统层面防护**
```bash
# 1. 调整MySQL进程的OOM评分
echo -1000 > /proc/$(pidof mysqld)/oom_score_adj

# 2. 设置内存保护脚本
#!/bin/bash
# 监控内存使用，提前预警
MEMORY_USAGE=$(free | grep Mem | awk '{print ($3/$2) * 100.0}')
if (( $(echo "$MEMORY_USAGE > 85" | bc -l) )); then
    echo "WARNING: Memory usage is ${MEMORY_USAGE}%"
    # 发送告警通知
fi
```

**⚙️ MySQL配置防护**
```ini
# my.cnf优化配置
[mysqld]
# 限制总内存使用
innodb_buffer_pool_size = 6G  # 不超过物理内存70%
max_connections = 100         # 限制连接数
thread_cache_size = 16        # 减少线程创建开销

# 限制单个查询内存
sort_buffer_size = 1M
join_buffer_size = 1M
tmp_table_size = 32M
```

### 6.4 内存监控脚本


**📊 自动监控工具**
```bash
#!/bin/bash
# MySQL内存监控脚本

# MySQL进程内存使用
MYSQL_PID=$(pidof mysqld)
if [ -n "$MYSQL_PID" ]; then
    MYSQL_MEM=$(cat /proc/$MYSQL_PID/status | grep VmRSS | awk '{print $2}')
    echo "MySQL Memory Usage: ${MYSQL_MEM}KB"
fi

# 系统内存使用
TOTAL_MEM=$(free -k | grep Mem | awk '{print $2}')
USED_MEM=$(free -k | grep Mem | awk '{print $3}')
MEM_PERCENT=$((USED_MEM * 100 / TOTAL_MEM))

echo "System Memory Usage: ${MEM_PERCENT}%"

# 触发告警条件
if [ $MEM_PERCENT -gt 90 ]; then
    echo "ALERT: High memory usage detected!"
    # 这里可以添加告警通知代码
fi
```

**📈 监控指标设置**
```
内存使用率阈值：
🟢 正常：< 70%
🟡 注意：70-85%
🔴 危险：> 85%
🚨 紧急：> 95%

MySQL内存阈值：
• Buffer Pool使用率：80-90%
• 连接内存总量：< 物理内存20%
• 临时表使用：磁盘临时表 < 15%
```

---

## 7. 🔧 内存参数调优策略


### 7.1 参数调优基本原则


**🎯 调优指导思想**
```
内存分配优先级：
1. InnoDB Buffer Pool (最重要)
2. 系统预留内存 (保证稳定)
3. 连接相关内存 (并发性能)
4. 查询缓冲区 (查询效率)
5. 其他缓冲区 (辅助功能)

调优原则：
• 80/20原则：80%内存给Buffer Pool
• 渐进调整：小步快跑，逐步优化
• 监控验证：每次调整后观察效果
• 备份配置：调优前备份原配置
```

### 7.2 不同规模的配置方案


**📊 配置方案模板**

**🔸 小型应用配置 (4GB内存)**
```ini
[mysqld]
# 核心内存配置
innodb_buffer_pool_size = 2G      # 50%内存
innodb_buffer_pool_instances = 2

# 连接配置
max_connections = 50
thread_cache_size = 8

# 查询缓冲区
sort_buffer_size = 256K
join_buffer_size = 256K
tmp_table_size = 16M
max_heap_table_size = 16M
```

**🔸 中型应用配置 (16GB内存)**
```ini
[mysqld]
# 核心内存配置
innodb_buffer_pool_size = 10G     # 62.5%内存
innodb_buffer_pool_instances = 8

# 连接配置
max_connections = 200
thread_cache_size = 16

# 查询缓冲区
sort_buffer_size = 1M
join_buffer_size = 1M
tmp_table_size = 64M
max_heap_table_size = 64M
```

**🔸 大型应用配置 (64GB内存)**
```ini
[mysqld]
# 核心内存配置
innodb_buffer_pool_size = 48G     # 75%内存
innodb_buffer_pool_instances = 16

# 连接配置
max_connections = 500
thread_cache_size = 32

# 查询缓冲区
sort_buffer_size = 2M
join_buffer_size = 2M
tmp_table_size = 128M
max_heap_table_size = 128M
```

### 7.3 内存碎片问题处理


**🧩 什么是内存碎片**
```
生活类比：
内存碎片像整理不好的仓库
• 有很多小空隙但放不下大物品
• 总空间够用但无法有效利用
• 需要重新整理才能恢复效率

技术含义：
内存分配和释放导致的空间浪费
• 频繁的内存分配释放
• 产生无法使用的小内存块
• 影响内存分配效率
```

**🔍 碎片检测方法**
```sql
-- 查看InnoDB缓冲池碎片
SHOW STATUS LIKE 'Innodb_buffer_pool_pages_free';
SHOW STATUS LIKE 'Innodb_buffer_pool_pages_total';

-- 系统内存碎片检查
SELECT 
  EVENT_NAME,
  CURRENT_COUNT_USED,
  CURRENT_NUMBER_OF_BYTES_USED,
  LOW_COUNT_USED,
  HIGH_COUNT_USED
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME LIKE '%buffer%'
ORDER BY CURRENT_NUMBER_OF_BYTES_USED DESC;
```

**🛠️ 碎片处理方案**
```
预防措施：
• 合理设置Buffer Pool实例数
• 避免频繁的大内存分配
• 定期重启MySQL服务

处理方法：
• 重启MySQL重建内存布局
• 调整内存参数配置
• 升级到更新版本的MySQL
```

### 7.4 动态参数调整


**⚡ 在线调整参数**
```sql
-- 可动态调整的内存参数
SET GLOBAL sort_buffer_size = 1048576;        -- 1MB
SET GLOBAL join_buffer_size = 1048576;        -- 1MB
SET GLOBAL tmp_table_size = 67108864;         -- 64MB
SET GLOBAL max_heap_table_size = 67108864;    -- 64MB

-- 查看当前设置
SHOW VARIABLES LIKE 'sort_buffer_size';
SHOW VARIABLES LIKE 'join_buffer_size';
```

**💾 永久保存配置**
```ini
# 将临时调整写入my.cnf
[mysqld]
sort_buffer_size = 1M
join_buffer_size = 1M
tmp_table_size = 64M
max_heap_table_size = 64M

# 重启后生效
systemctl restart mysql
```

**📋 调优检查清单**
```
调优前检查：
- [ ] 备份当前配置文件
- [ ] 记录当前性能基线
- [ ] 确认业务低峰期时间

调优后验证：
- [ ] 检查MySQL启动是否正常
- [ ] 监控内存使用变化
- [ ] 观察查询性能改善
- [ ] 确认没有新的错误日志
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 内存故障本质理解**
```
核心认知：
• MySQL内存故障 = 需求超过供给
• 表现形式：OOM错误、性能下降、服务崩溃
• 影响范围：单个查询到整个服务不可用
• 解决思路：开源节流，监控预防
```

**🔸 关键内存组件**
```
Buffer Pool：
• 作用：数据页缓存，减少磁盘IO
• 配置：物理内存的70-80%
• 监控：命中率>99%，使用率80-90%

临时表内存：
• 作用：复杂查询的临时存储
• 配置：32-128MB适中
• 监控：磁盘临时表比例<15%

查询缓冲区：
• 作用：排序、连接等操作的工作空间
• 配置：根据并发量和查询复杂度调整
• 监控：避免过大导致OOM
```

### 8.2 故障排查思路


**🔍 系统化排查流程**
```
第一步：确认故障现象
• 查看错误日志
• 确认影响范围
• 记录故障时间

第二步：定位故障原因
• 检查系统内存使用
• 分析MySQL内存配置
• 查找异常查询

第三步：应急处理
• 重启MySQL服务
• 临时调整内存参数
• 限制并发连接

第四步：根本解决
• 优化内存配置
• 改进应用查询
• 增加硬件资源
```

### 8.3 预防性维护策略


**🛡️ 日常监控要点**
```
系统监控：
• 内存使用率趋势
• OOM Killer日志
• MySQL进程状态

MySQL监控：
• Buffer Pool命中率
• 临时表使用情况
• 异常查询识别

应用监控：
• 连接数变化
• 查询执行时间
• 错误率统计
```

**📈 性能优化建议**
```
硬件层面：
• 内存容量：根据数据量和并发量规划
• 内存类型：使用DDR4或更新的内存
• 存储：使用SSD减少对内存的依赖

配置层面：
• 遵循80/20原则分配内存
• 根据业务特点调整参数
• 定期检查和优化配置

应用层面：
• 优化SQL查询语句
• 合理使用索引
• 避免不必要的大表操作
```

### 8.4 实际应用价值


**💼 业务价值**
- **服务稳定性**：减少因内存问题导致的服务中断
- **性能提升**：优化内存使用提高查询响应速度
- **成本控制**：合理配置避免硬件资源浪费
- **风险降低**：预防性监控减少故障发生概率

**🔧 技术价值**
- **故障处理**：快速定位和解决内存相关问题
- **性能调优**：掌握MySQL内存优化的方法
- **监控运维**：建立完善的内存监控体系
- **容量规划**：为业务增长做好资源规划

**🧠 核心记忆口诀**
```
内存故障找根源，OOM错误要重视
Buffer Pool是核心，配置监控两手抓
临时表内存注意，磁盘使用控比例
查询优化很重要，大内存要避免
系统监控不能少，预防胜过治疗好
```

**⚡ 关键数字记忆**
- Buffer Pool配置：物理内存的**70-80%**
- Buffer Pool命中率：保持**>99%**
- 磁盘临时表比例：控制**<15%**
- 系统内存使用：告警阈值**85%**
- 内存监控频率：每**5分钟**检查一次