---
title: 8、慢查询性能故障
---
## 📚 目录

1. [慢查询基础概念](#1-慢查询基础概念)
2. [慢查询日志分析](#2-慢查询日志分析)
3. [执行计划异常诊断](#3-执行计划异常诊断)
4. [索引失效问题排查](#4-索引失效问题排查)
5. [查询优化器问题](#5-查询优化器问题)
6. [统计信息过期处理](#6-统计信息过期处理)
7. [表扫描性能问题](#7-表扫描性能问题)
8. [查询缓存问题](#8-查询缓存问题)
9. [并发查询冲突](#9-并发查询冲突)
10. [查询性能回归分析](#10-查询性能回归分析)
11. [执行计划变更监控](#11-执行计划变更监控)
12. [查询超时处理](#12-查询超时处理)
13. [性能基线对比](#13-性能基线对比)
14. [核心要点总结](#14-核心要点总结)

---

## 1. 🐌 慢查询基础概念


### 1.1 什么是慢查询


**简单理解**：慢查询就是执行时间超过预期的SQL语句，就像排队买饭时某个窗口特别慢一样。

```
日常生活类比：
快餐店点餐：正常3分钟 → 慢查询：等了15分钟
数据库查询：正常0.1秒 → 慢查询：等了3秒

影响：
• 用户体验差：页面加载慢
• 资源占用：数据库压力大
• 连锁反应：影响其他查询
```

**慢查询的判定标准**：
- **时间阈值**：通常设定为1-2秒
- **业务影响**：影响用户正常使用
- **资源消耗**：占用过多CPU、内存、IO

### 1.2 慢查询的常见表现


**用户感知的现象**：
```
🔸 网页加载缓慢
• 点击按钮后页面转圈很久
• 列表页面刷新时间过长
• 搜索结果迟迟不出来

🔸 系统响应异常
• 某些功能偶尔卡顿
• 高峰期系统变慢
• 数据库连接数增加
```

**技术层面的指标**：
- 查询执行时间超过阈值
- CPU使用率突然升高
- 磁盘IO读写频繁
- 数据库连接池耗尽

### 1.3 慢查询产生的根本原因


**核心原因分类**：
```
📊 数据问题：
• 数据量过大：单表几百万行记录
• 数据分布不均：某些值特别集中

🔍 查询问题：
• 没有合适索引：全表扫描
• 查询逻辑复杂：多表关联、子查询

⚙️ 系统问题：
• 硬件性能不足：内存、磁盘慢
• 配置不当：缓冲区太小
```

---

## 2. 📋 慢查询日志分析


### 2.1 开启慢查询日志


**什么是慢查询日志**：
MySQL内置的记录工具，就像给数据库装了个"行车记录仪"，专门记录那些跑得慢的查询。

**开启步骤**：
```sql
-- 查看当前慢查询日志状态
SHOW VARIABLES LIKE 'slow_query_log%';

-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';

-- 设置慢查询时间阈值（秒）
SET GLOBAL long_query_time = 2;

-- 设置日志文件位置
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
```

### 2.2 慢查询日志内容解读


**日志示例**：
```
# Time: 2025-09-08T14:30:15.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 3.234567  Lock_time: 0.000123  Rows_sent: 1000  Rows_examined: 500000
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.order_date >= '2025-01-01';
```

**各字段含义解释**：
```
🔸 Query_time: 3.234567
• 含义：查询总耗时3.23秒
• 判断：明显超过2秒阈值

🔸 Rows_examined: 500000  
• 含义：扫描了50万行数据
• 问题：扫描行数过多，效率低

🔸 Rows_sent: 1000
• 含义：最终只返回1000行
• 分析：扫描50万行只为找1000行，效率极低

🔸 Lock_time: 0.000123
• 含义：等待锁的时间很短
• 说明：不是锁问题导致的慢查询
```

### 2.3 使用mysqldumpslow分析


**mysqldumpslow工具**：
MySQL官方提供的日志分析工具，就像给慢查询日志做"体检报告"。

```bash
# 显示执行次数最多的10条SQL
mysqldumpslow -s c -t 10 /var/log/mysql/slow.log

# 显示执行时间最长的10条SQL  
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 显示返回记录数最多的10条SQL
mysqldumpslow -s r -t 10 /var/log/mysql/slow.log
```

**分析结果示例**：
```
Count: 245    Time=4.23s (1036s)  Lock=0.00s (0s)  Rows=1500.0 (367500), app_user[app_user]@[192.168.1.100]
SELECT * FROM orders WHERE customer_id = N AND order_date >= 'S'

解读：
• Count: 245 → 这个查询模式出现了245次
• Time=4.23s → 平均每次耗时4.23秒  
• (1036s) → 总共耗时1036秒
• 问题严重程度：非常高（频繁且耗时）
```

---

## 3. 🔍 执行计划异常诊断


### 3.1 什么是执行计划


**通俗解释**：
执行计划就是MySQL为查询制定的"作战方案"，告诉我们数据库准备怎么找数据。

```
生活类比：
找书的计划：
方案A：按书架顺序一本本找 → 全表扫描
方案B：先查目录找到位置再取 → 使用索引

MySQL也是类似的选择过程
```

### 3.2 使用EXPLAIN分析查询


**基本语法**：
```sql
EXPLAIN SELECT * FROM orders 
WHERE customer_id = 12345 AND order_date >= '2025-01-01';
```

**执行计划输出解读**：
```
+----+-------+-------+-------+-------+------+-------+
| id | type  | table | key   | rows  | Extra                    |
+----+-------+-------+-------+-------+------+-------+
|  1 | ALL   | orders| NULL  | 50000 | Using where              |
+----+-------+-------+-------+-------+------+-------+

关键字段含义：
🔸 type: ALL
• 含义：全表扫描
• 问题：没有使用索引，性能最差

🔸 key: NULL  
• 含义：没有使用任何索引
• 原因：可能是没有合适的索引

🔸 rows: 50000
• 含义：预估需要扫描5万行
• 影响：数据量大时性能会很差
```

### 3.3 常见执行计划问题


**type字段的性能排序**：
```
性能从好到差：
const > eq_ref > ref > range > index > ALL

🔸 const：最优
• 通过主键或唯一索引查找单行
• 示例：WHERE id = 123

🔸 ref：良好  
• 通过普通索引查找
• 示例：WHERE customer_id = 123

🔸 range：可接受
• 索引范围扫描
• 示例：WHERE id BETWEEN 100 AND 200

🔸 ALL：最差
• 全表扫描，应该避免
• 大表时性能极差
```

**Extra字段的关键信息**：
```
🔸 Using filesort
• 含义：需要额外排序
• 问题：无法使用索引排序，性能差
• 解决：为ORDER BY字段建索引

🔸 Using temporary  
• 含义：需要临时表
• 问题：GROUP BY无法使用索引
• 解决：优化分组字段索引

🔸 Using where
• 含义：使用WHERE条件过滤
• 情况：可能是好事也可能是坏事
```

---

## 4. 📈 索引失效问题排查


### 4.1 索引失效的常见场景


**什么叫索引失效**：
就像图书馆的目录突然不能用了，只能一本本翻书找内容。

**典型失效场景**：

#### 🔸 函数操作导致失效

```sql
-- ❌ 错误写法：索引失效
SELECT * FROM orders WHERE YEAR(order_date) = 2025;

-- ✅ 正确写法：索引有效  
SELECT * FROM orders WHERE order_date >= '2025-01-01' 
  AND order_date < '2026-01-01';

原因解释：
• YEAR(order_date)对索引字段做了函数操作
• MySQL无法使用order_date上的索引
• 必须全表扫描计算每行的YEAR值
```

#### 🔸 类型转换导致失效

```sql
-- ❌ 错误写法：隐式类型转换
SELECT * FROM orders WHERE customer_id = '12345';
-- customer_id是INT类型，传入字符串

-- ✅ 正确写法：类型匹配
SELECT * FROM orders WHERE customer_id = 12345;

影响：
• 数据库需要转换每行的customer_id为字符串比较
• 索引无法直接使用
```

#### 🔸 LIKE模糊查询失效

```sql
-- ❌ 前缀通配符：索引失效
SELECT * FROM products WHERE name LIKE '%iPhone%';

-- ✅ 后缀通配符：索引有效
SELECT * FROM products WHERE name LIKE 'iPhone%';

-- ✅ 精确匹配：索引有效
SELECT * FROM products WHERE name = 'iPhone 15';
```

### 4.2 复合索引失效问题


**最左前缀原则**：
复合索引必须从最左边的字段开始使用，就像门牌号必须先写省市区。

```sql
-- 假设有复合索引：INDEX(customer_id, order_date, status)

-- ✅ 能使用索引：符合最左前缀
SELECT * FROM orders WHERE customer_id = 123;
SELECT * FROM orders WHERE customer_id = 123 AND order_date >= '2025-01-01';

-- ❌ 不能使用索引：跳过了customer_id
SELECT * FROM orders WHERE order_date >= '2025-01-01';
SELECT * FROM orders WHERE status = 'completed';

-- ❌ 部分使用索引：只能用到customer_id部分
SELECT * FROM orders WHERE customer_id = 123 AND status = 'completed';
```

### 4.3 索引失效检查方法


**使用EXPLAIN检查索引使用情况**：
```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- 检查key字段是否为NULL
-- 检查type字段是否为ALL
-- 检查rows字段是否过大
```

**强制使用索引测试**：
```sql
-- 强制使用指定索引
SELECT * FROM orders USE INDEX(idx_customer_id) 
WHERE customer_id = 123;

-- 对比性能差异
-- 如果强制使用索引后性能明显提升，说明索引可用但未被选择
```

---

## 5. 🧠 查询优化器问题


### 5.1 什么是查询优化器


**简单理解**：
查询优化器是MySQL的"大脑"，负责为每个查询选择最优的执行方案。

```
类比导航软件：
• 输入起点终点 → 写SQL查询
• 规划路线 → 查询优化器制定执行计划  
• 选择最快路线 → 选择最优执行方案
• 避开拥堵 → 避开性能瓶颈
```

### 5.2 优化器选择错误的执行计划


**常见问题场景**：
```sql
-- 表结构
CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  order_date DATE,
  status VARCHAR(20),
  INDEX idx_customer(customer_id),
  INDEX idx_date(order_date)
);
```

**优化器可能做错误选择**：
```sql
SELECT * FROM orders 
WHERE customer_id = 123 AND order_date >= '2025-01-01';

-- 情况A：优化器选择customer_id索引（可能正确）
-- 情况B：优化器选择order_date索引（可能错误）
-- 情况C：优化器选择全表扫描（明显错误）
```

### 5.3 优化器统计信息不准确


**统计信息的作用**：
优化器依赖统计信息估算成本，就像导航依赖实时路况信息。

**统计信息过期的影响**：
```sql
-- 数据库认为表很小（统计信息过期）
-- 实际表已经很大（数据增长很快）
-- 优化器基于错误信息做决策
-- 选择了不合适的执行计划

检查统计信息：
SHOW TABLE STATUS LIKE 'orders';
-- 查看Rows字段是否准确
```

**更新统计信息**：
```sql
-- 更新表的统计信息
ANALYZE TABLE orders;

-- 检查优化器是否选择了更好的执行计划
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;
```

### 5.4 强制使用特定执行计划


**使用HINT强制选择**：
```sql
-- 强制使用特定索引
SELECT * FROM orders USE INDEX(idx_customer) 
WHERE customer_id = 123 AND order_date >= '2025-01-01';

-- 忽略特定索引
SELECT * FROM orders IGNORE INDEX(idx_date)
WHERE customer_id = 123 AND order_date >= '2025-01-01';

-- 强制使用索引（如果没有合适索引就报错）
SELECT * FROM orders FORCE INDEX(idx_customer)
WHERE customer_id = 123;
```

---

## 6. 📊 统计信息过期处理


### 6.1 什么是统计信息


**通俗解释**：
统计信息就像数据库的"人口普查"，记录每个表的大致情况，帮助优化器做决策。

```
统计信息包含：
🔸 表的行数：大概有多少条记录
🔸 索引的选择性：某个值出现的频率
🔸 数据分布：数据是否均匀分布
🔸 最大最小值：数据的范围
```

### 6.2 统计信息过期的表现


**典型症状**：
```
症状1：执行计划突然变差
• 之前跑得好好的查询突然变慢
• EXPLAIN显示选择了错误的索引

症状2：优化器估算错误  
• 预估扫描1000行，实际扫描10万行
• 选择了成本更高的执行计划

症状3：数据量变化大的表
• 新上线的功能，数据增长很快
• 定期清理数据的表
```

### 6.3 检查统计信息准确性


**查看表统计信息**：
```sql
-- 查看表的基本统计信息
SHOW TABLE STATUS LIKE 'orders'\G

-- 重要字段：
-- Rows: 表的预估行数
-- Data_length: 数据文件大小
-- Update_time: 最后更新时间
```

**查看索引统计信息**：
```sql
-- 查看索引的统计信息
SHOW INDEX FROM orders;

-- 重要字段：
-- Cardinality: 索引的选择性（不同值的个数）
-- 如果Cardinality不准确，优化器会做错误判断
```

**实际行数 vs 统计行数对比**：
```sql
-- 实际行数
SELECT COUNT(*) FROM orders;

-- 统计信息中的行数（快速但可能不准确）
SELECT table_rows FROM information_schema.tables 
WHERE table_schema = 'database_name' AND table_name = 'orders';

-- 如果差异很大，说明统计信息过期
```

### 6.4 更新统计信息


**手动更新**：
```sql
-- 更新单个表的统计信息
ANALYZE TABLE orders;

-- 更新多个表
ANALYZE TABLE orders, customers, products;

-- 检查更新结果
SHOW TABLE STATUS LIKE 'orders';
```

**自动更新配置**：
```sql
-- 查看自动更新配置
SHOW VARIABLES LIKE '%innodb_stats%';

-- 启用自动统计信息更新
SET GLOBAL innodb_stats_auto_recalc = 1;

-- 设置触发自动更新的阈值（10%的数据变化）
SET GLOBAL innodb_stats_on_metadata = 0;
```

---

## 7. 🔄 表扫描性能问题


### 7.1 什么是表扫描


**通俗解释**：
表扫描就像在没有目录的图书馆里找书，只能一本一本地翻看。

```
表扫描类型：
🔸 全表扫描（Full Table Scan）
• 从第一行读到最后一行
• 检查每一行是否符合条件
• 数据量大时性能极差

🔸 索引扫描（Index Scan）  
• 按索引顺序读取数据
• 比全表扫描快，但仍需读取大量数据
```

### 7.2 表扫描产生的原因


**没有合适的索引**：
```sql
-- 没有为查询条件建立索引
SELECT * FROM orders WHERE remark LIKE '%urgent%';
-- remark字段没有索引，只能全表扫描
```

**索引选择性太低**：
```sql
-- 性别字段只有'男'/'女'两个值
SELECT * FROM users WHERE gender = '男';
-- 即使有索引，选择性太低，扫描行数仍然很多
```

**查询条件覆盖大部分数据**：
```sql
-- 查询90%的数据
SELECT * FROM orders WHERE order_date >= '2024-01-01';
-- MySQL可能认为全表扫描比索引扫描更快
```

### 7.3 表扫描性能问题诊断


**使用EXPLAIN分析**：
```sql
EXPLAIN SELECT * FROM orders WHERE remark LIKE '%urgent%';

-- 查看type字段：
-- ALL = 全表扫描（最差）
-- index = 索引扫描（较差）
-- range = 索引范围扫描（可接受）
```

**检查扫描行数**：
```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- 查看rows字段：
-- 如果rows接近表的总行数，说明扫描效率低
-- 理想情况是rows数量远小于表总行数
```

### 7.4 优化表扫描问题


**建立合适的索引**：
```sql
-- 为经常查询的字段建立索引
CREATE INDEX idx_customer_id ON orders(customer_id);
CREATE INDEX idx_order_date ON orders(order_date);

-- 为组合查询建立复合索引
CREATE INDEX idx_customer_date ON orders(customer_id, order_date);
```

**优化查询条件**：
```sql
-- ❌ 避免使用函数
SELECT * FROM orders WHERE YEAR(order_date) = 2025;

-- ✅ 使用范围查询
SELECT * FROM orders WHERE order_date >= '2025-01-01' 
  AND order_date < '2026-01-01';
```

**限制查询结果**：
```sql
-- 添加LIMIT限制返回行数
SELECT * FROM orders WHERE status = 'pending' LIMIT 100;

-- 分页查询避免一次性返回大量数据
SELECT * FROM orders WHERE status = 'pending' 
ORDER BY id LIMIT 20 OFFSET 0;
```

---

## 8. 💾 查询缓存问题


### 8.1 什么是查询缓存


**简单理解**：
查询缓存就像餐厅的"今日推荐"菜单，把常用的查询结果提前准备好。

```
工作原理：
1. 第一次执行查询 → 计算结果 → 保存到缓存
2. 再次执行相同查询 → 直接返回缓存结果
3. 表数据变化 → 清空相关缓存

优势：相同查询速度极快
劣势：数据变化频繁时效果差
```

### 8.2 查询缓存的问题


**缓存命中率低**：
```sql
-- 查看查询缓存状态
SHOW STATUS LIKE 'Qcache_%';

-- 关键指标：
-- Qcache_hits: 缓存命中次数
-- Qcache_inserts: 缓存插入次数  
-- Qcache_not_cached: 未缓存的查询数

-- 命中率计算：
-- 命中率 = Qcache_hits / (Qcache_hits + Qcache_inserts)
-- 如果命中率低于20%，说明缓存效果差
```

**缓存失效频繁**：
```sql
-- 数据表频繁更新导致缓存失效
INSERT INTO orders VALUES (...);  -- 缓存失效
UPDATE orders SET status = 'completed' WHERE id = 123;  -- 缓存失效
DELETE FROM orders WHERE id = 456;  -- 缓存失效

-- 每次数据变化都会清空该表的所有查询缓存
```

### 8.3 查询缓存配置优化


**查看缓存配置**：
```sql
-- 查看查询缓存相关配置
SHOW VARIABLES LIKE 'query_cache%';

-- 重要参数：
-- query_cache_type: 缓存类型（OFF/ON/DEMAND）
-- query_cache_size: 缓存大小
-- query_cache_limit: 单个查询结果最大缓存大小
```

**优化缓存设置**：
```sql
-- 设置合适的缓存大小（通常32MB-128MB）
SET GLOBAL query_cache_size = 67108864;  -- 64MB

-- 设置单个查询缓存限制
SET GLOBAL query_cache_limit = 1048576;  -- 1MB

-- 根据业务情况选择缓存类型
SET GLOBAL query_cache_type = 1;  -- ON
```

### 8.4 查询缓存的替代方案


**应用层缓存**：
```
Redis/Memcached缓存：
• 更灵活的缓存策略
• 可以缓存计算结果而不只是查询结果
• 不会因为数据变化全部失效

优势：
• 可以设置不同的过期时间
• 可以缓存复杂的业务数据
• 跨数据库、跨表的缓存
```

**MySQL 8.0的改进**：
```
MySQL 8.0已经移除查询缓存：
• 官方认为查询缓存收益不大
• 推荐使用应用层缓存
• 专注于提升查询本身的性能
```

---

## 9. 🔄 并发查询冲突


### 9.1 什么是并发查询冲突


**通俗解释**：
就像多个人同时要用同一本书，可能会发生"排队等待"或"互相干扰"的情况。

```
典型场景：
🔸 多个查询同时访问同一张表
🔸 查询和更新操作同时进行
🔸 大查询阻塞小查询
🔸 锁等待和死锁
```

### 9.2 常见的并发冲突问题


**表锁冲突**：
```sql
-- 大查询获得表锁
SELECT COUNT(*) FROM orders;  -- 可能获得表级共享锁

-- 同时进行的更新被阻塞
UPDATE orders SET status = 'completed' WHERE id = 123;  -- 等待锁释放
```

**行锁等待**：
```sql
-- 事务A：更新某行但未提交
BEGIN;
UPDATE orders SET status = 'processing' WHERE id = 123;
-- 未提交事务

-- 事务B：尝试更新同一行
UPDATE orders SET amount = 100 WHERE id = 123;  -- 等待事务A释放锁
```

**元数据锁等待**：
```sql
-- 长时间运行的查询
SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id;  -- 运行中

-- 同时尝试修改表结构
ALTER TABLE orders ADD COLUMN new_field VARCHAR(50);  -- 等待查询完成
```

### 9.3 诊断并发冲突


**查看当前锁等待**：
```sql
-- 查看正在等待的锁
SELECT * FROM information_schema.INNODB_LOCKS;

-- 查看锁等待关系
SELECT * FROM information_schema.INNODB_LOCK_WAITS;

-- 查看当前运行的事务
SELECT * FROM information_schema.INNODB_TRX;
```

**使用SHOW PROCESSLIST**：
```sql
SHOW PROCESSLIST;

-- 关注State列：
-- 'Waiting for table metadata lock' - 元数据锁等待
-- 'Waiting for table level lock' - 表锁等待  
-- 'update' - 可能在等待行锁
```

### 9.4 解决并发冲突


**优化查询减少锁时间**：
```sql
-- ❌ 避免大事务
BEGIN;
UPDATE orders SET status = 'completed';  -- 更新所有行，锁定时间长
-- 其他操作...
COMMIT;

-- ✅ 使用小事务
UPDATE orders SET status = 'completed' WHERE id IN (1,2,3,4,5);
-- 分批处理，减少锁定时间
```

**合理设置事务隔离级别**：
```sql
-- 查看当前隔离级别
SELECT $$transaction_isolation;

-- 对于读多写少的业务，可以考虑降低隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

**使用适当的锁提示**：
```sql
-- 读取时不加锁（可能读到脏数据）
SELECT * FROM orders WHERE id = 123 FOR SHARE;

-- 读取时加共享锁
SELECT * FROM orders WHERE id = 123 LOCK IN SHARE MODE;
```

---

## 10. 📉 查询性能回归分析


### 10.1 什么是查询性能回归


**简单理解**：
性能回归就是原本跑得很快的查询突然变慢了，就像原来顺畅的道路突然开始堵车。

```
典型表现：
🔸 相同的SQL查询时间突然增加
🔸 系统整体响应变慢
🔸 用户反馈页面加载缓慢
🔸 数据库CPU、IO使用率上升
```

### 10.2 性能回归的常见原因


**数据量增长**：
```sql
-- 三个月前：orders表10万行，查询0.1秒
SELECT * FROM orders WHERE customer_id = 123;

-- 现在：orders表500万行，查询3秒
-- 相同查询，数据量增长50倍，性能显著下降
```

**索引问题**：
```sql
-- 可能的原因：
-- 1. 索引被意外删除
SHOW INDEX FROM orders;  -- 检查索引是否存在

-- 2. 索引碎片严重
ANALYZE TABLE orders;  -- 重建统计信息

-- 3. 索引选择性下降
-- 数据分布变化导致索引效果变差
```

**数据库配置变化**：
```sql
-- 内存配置可能被修改
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- 查询缓存可能被关闭
SHOW VARIABLES LIKE 'query_cache_type';
```

### 10.3 性能回归诊断步骤


**第一步：确定回归范围**：
```sql
-- 对比当前执行计划与历史执行计划
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- 检查是否使用了相同的索引
-- 检查扫描行数是否增加
-- 检查执行类型是否变化
```

**第二步：检查环境变化**：
```sql
-- 检查表结构是否变化
SHOW CREATE TABLE orders;

-- 检查索引是否完整
SHOW INDEX FROM orders;

-- 检查统计信息是否过期
SHOW TABLE STATUS LIKE 'orders';
```

**第三步：对比历史性能**：
```bash
# 查看慢查询日志中的历史记录
grep "customer_id = 123" /var/log/mysql/slow.log

# 对比执行时间的变化趋势
```

### 10.4 性能回归修复方案


**数据量增长导致的回归**：
```sql
-- 优化索引
CREATE INDEX idx_customer_date ON orders(customer_id, order_date);

-- 分区表
ALTER TABLE orders PARTITION BY RANGE(YEAR(order_date));

-- 归档历史数据
DELETE FROM orders WHERE order_date < '2024-01-01';
```

**索引问题修复**：
```sql
-- 重建索引
DROP INDEX idx_customer_id ON orders;
CREATE INDEX idx_customer_id ON orders(customer_id);

-- 更新统计信息
ANALYZE TABLE orders;
```

---

## 11. 🔄 执行计划变更监控


### 11.1 为什么要监控执行计划变更


**重要性说明**：
执行计划就像查询的"行车路线"，路线变化可能导致性能巨大差异。

```
路线变化的影响：
原路线：使用索引，0.1秒
新路线：全表扫描，10秒
性能差异：100倍

类似场景：
• 导航软件选择了拥堵路线
• 结果：原本10分钟的路程变成2小时
```

### 11.2 执行计划变更的触发因素


**统计信息更新**：
```sql
-- 统计信息更新后，优化器可能选择不同的执行计划
ANALYZE TABLE orders;

-- 执行计划可能从使用索引A变为使用索引B
-- 或者从使用索引变为全表扫描
```

**数据分布变化**：
```sql
-- 数据分布发生变化
-- 例如：某个customer_id的订单数量激增
-- 导致优化器认为按customer_id查询成本过高
-- 改为使用其他索引或全表扫描
```

**数据库版本升级**：
```
优化器算法改进：
• 新版本的优化器可能有不同的成本估算
• 相同的查询可能选择不同的执行计划
• 大部分情况下是改进，但偶尔可能变差
```

### 11.3 监控执行计划变更


**建立执行计划基线**：
```sql
-- 为重要查询建立执行计划基线
EXPLAIN FORMAT=JSON SELECT * FROM orders 
WHERE customer_id = 123 AND order_date >= '2025-01-01';

-- 保存执行计划的关键信息：
-- 1. 使用的索引
-- 2. 访问类型（type）
-- 3. 预估扫描行数
-- 4. 额外信息（Extra）
```

**定期检查执行计划**：
```bash
#!/bin/bash
# 执行计划监控脚本

# 执行查询并获取执行计划
mysql -e "EXPLAIN SELECT * FROM orders WHERE customer_id = 123" > current_plan.txt

# 与基线对比
diff baseline_plan.txt current_plan.txt

# 如果有差异，发送告警
if [ $? -ne 0 ]; then
    echo "执行计划发生变更!" | mail -s "MySQL执行计划告警" admin@company.com
fi
```

### 11.4 执行计划变更应对策略


**使用SQL Hint固定执行计划**：
```sql
-- 强制使用特定索引
SELECT /*+ USE_INDEX(orders, idx_customer_id) */ 
* FROM orders WHERE customer_id = 123;

-- 强制使用特定连接算法
SELECT /*+ USE_NL(o, c) */ 
* FROM orders o JOIN customers c ON o.customer_id = c.id;
```

**创建更好的索引**：
```sql
-- 如果执行计划变更是因为索引不够优化
-- 创建更符合查询模式的索引
CREATE INDEX idx_customer_date_status 
ON orders(customer_id, order_date, status);
```

**使用存储过程稳定执行计划**：
```sql
-- 存储过程的执行计划相对稳定
DELIMITER //
CREATE PROCEDURE GetCustomerOrders(IN p_customer_id INT)
BEGIN
    SELECT * FROM orders 
    WHERE customer_id = p_customer_id 
    AND order_date >= '2025-01-01';
END //
DELIMITER ;
```

---

## 12. ⏰ 查询超时处理


### 12.1 什么是查询超时


**通俗解释**：
查询超时就像等公交车等太久，最后放弃等待。数据库设定一个等待时间，超过就强制结束查询。

```
超时的好处：
🔸 防止慢查询占用资源过久
🔸 避免数据库连接耗尽
🔸 保护数据库整体性能
🔸 提升用户体验（快速失败）
```

### 12.2 MySQL中的超时参数


**连接超时配置**：
```sql
-- 查看超时相关配置
SHOW VARIABLES LIKE '%timeout%';

-- 重要超时参数：
-- wait_timeout: 非交互连接超时时间（默认8小时）
-- interactive_timeout: 交互连接超时时间（默认8小时）
-- connect_timeout: 连接建立超时时间（默认10秒）
```

**查询执行超时**：
```sql
-- 设置单个查询的超时时间
SET SESSION max_execution_time = 30000;  -- 30秒（毫秒）

-- 查看当前设置
SELECT $$max_execution_time;
```

### 12.3 超时问题的表现


**客户端收到的错误**：
```
常见超时错误信息：
• "MySQL server has gone away"
• "Lost connection to MySQL server during query"
• "Query execution was interrupted"
• "Statement execution timeout"
```

**超时对系统的影响**：
```
正面影响：
• 防止慢查询影响其他用户
• 释放数据库连接资源
• 避免数据库负载过高

负面影响：
• 用户操作失败，体验差
• 可能导致数据不一致
• 需要应用程序处理重试逻辑
```

### 12.4 查询超时优化策略


**合理设置超时时间**：
```sql
-- 根据业务需求设置合适的超时时间
-- 在线事务处理：1-5秒
SET SESSION max_execution_time = 5000;

-- 数据分析查询：30-300秒
SET SESSION max_execution_time = 300000;

-- 数据导入导出：可以设置更长时间或不限制
SET SESSION max_execution_time = 0;  -- 0表示不限制
```

**查询优化减少超时**：
```sql
-- ❌ 容易超时的查询
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.order_date >= '2020-01-01';

-- ✅ 优化后的查询
-- 1. 添加限制条件
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.order_date >= '2025-01-01'  -- 缩小时间范围
AND o.status = 'active'  -- 添加状态条件
LIMIT 1000;  -- 限制返回行数

-- 2. 创建合适的索引
CREATE INDEX idx_order_date_status ON orders(order_date, status);
```

**分页处理大结果集**：
```sql
-- 避免一次性返回大量数据
SELECT * FROM orders 
WHERE customer_id = 123 
ORDER BY order_date DESC 
LIMIT 20 OFFSET 0;  -- 分页查询

-- 使用游标遍历大结果集
SELECT * FROM orders 
WHERE id > last_processed_id 
ORDER BY id 
LIMIT 1000;
```

---

## 13. 📊 性能基线对比


### 13.1 什么是性能基线


**简单理解**：
性能基线就像体检报告中的"正常值"，记录系统正常情况下的性能指标。

```
性能基线包含：
🔸 查询执行时间
🔸 数据库资源使用率
🔸 查询吞吐量
🔸 错误率和超时率
🔸 关键查询的执行计划
```

### 13.2 建立性能基线


**收集关键性能指标**：
```sql
-- 1. 查询执行时间基线
SELECT 
    schema_name,
    digest_text,
    avg_timer_wait/1000000000 as avg_exec_time_sec,
    count_star as exec_count
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY avg_timer_wait DESC 
LIMIT 10;
```

**记录系统资源基线**：
```sql
-- 2. 数据库连接数基线
SHOW STATUS LIKE 'Threads_connected';

-- 3. 缓冲池命中率基线
SHOW STATUS LIKE 'Innodb_buffer_pool_reads';
SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';

-- 计算命中率：
-- 命中率 = (read_requests - reads) / read_requests * 100%
```

**定期快照性能数据**：
```bash
#!/bin/bash
# 性能基线收集脚本

DATE=$(date +"%Y-%m-%d_%H-%M-%S")
BASELINE_DIR="/var/log/mysql/baseline"

# 创建基线目录
mkdir -p $BASELINE_DIR

# 收集查询性能数据
mysql -e "
SELECT NOW() as snapshot_time,
       schema_name,
       digest_text,
       avg_timer_wait/1000000000 as avg_exec_time_sec,
       count_star as exec_count
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY avg_timer_wait DESC 
LIMIT 20;
" > $BASELINE_DIR/query_baseline_$DATE.txt

# 收集系统状态
mysql -e "SHOW STATUS;" > $BASELINE_DIR/status_baseline_$DATE.txt
```

### 13.3 性能对比分析


**查询性能对比**：
```sql
-- 对比当前性能与基线
-- 当前查询时间：3.2秒
-- 基线查询时间：0.8秒
-- 性能回归：4倍性能下降

-- 找出性能回归的查询
SELECT 
    digest_text,
    avg_timer_wait/1000000000 as current_avg_time,
    -- 这里需要与历史基线数据对比
    'baseline_avg_time' as baseline_avg_time,
    'performance_ratio' as performance_ratio
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait/1000000000 > 2.0  -- 超过2秒的查询
ORDER BY avg_timer_wait DESC;
```

**资源使用对比**：
```sql
-- CPU使用率对比
-- 基线：CPU使用率30%
-- 当前：CPU使用率80%
-- 分析：可能有慢查询或并发过高

-- 内存使用对比
SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';
-- 对比缓冲池命中率变化
```

### 13.4 基于基线的告警机制


**设置性能告警阈值**：
```bash
#!/bin/bash
# 性能告警脚本

# 获取当前平均查询时间
CURRENT_AVG_TIME=$(mysql -sN -e "
SELECT AVG(avg_timer_wait/1000000000) 
FROM performance_schema.events_statements_summary_by_digest 
WHERE count_star > 10;")

# 基线平均查询时间（从历史数据获取）
BASELINE_AVG_TIME=0.5

# 计算性能比率
PERFORMANCE_RATIO=$(echo "$CURRENT_AVG_TIME / $BASELINE_AVG_TIME" | bc -l)

# 如果性能下降超过50%，发送告警
if (( $(echo "$PERFORMANCE_RATIO > 1.5" | bc -l) )); then
    echo "查询性能告警：当前平均查询时间${CURRENT_AVG_TIME}秒，比基线高${PERFORMANCE_RATIO}倍" | \
    mail -s "MySQL性能告警" admin@company.com
fi
```

**自动性能优化建议**：
```sql
-- 基于性能对比生成优化建议
-- 如果发现某个查询性能回归严重：
-- 1. 检查执行计划是否变化
-- 2. 检查索引是否存在
-- 3. 检查统计信息是否过期
-- 4. 建议执行ANALYZE TABLE
```

---

## 14. 📋 核心要点总结


### 14.1 慢查询排查思路


```
🔍 问题识别：
1. 开启慢查询日志，设置合理阈值
2. 使用mysqldumpslow分析日志
3. 关注执行次数多、耗时长的查询

🔧 问题诊断：
1. 使用EXPLAIN分析执行计划
2. 检查type字段（避免ALL全表扫描）
3. 检查key字段（确保使用了索引）
4. 检查rows字段（扫描行数是否合理）

⚡ 问题解决：
1. 为查询条件创建合适索引
2. 优化SQL语句避免索引失效
3. 更新统计信息保证优化器准确决策
4. 设置合理的超时和缓存策略
```

### 14.2 索引优化要点


```
📈 索引设计原则：
• 为WHERE、ORDER BY、JOIN字段建索引
• 复合索引遵循最左前缀原则
• 避免过多索引影响写入性能

🚫 避免索引失效：
• 不在索引字段上使用函数
• 避免隐式类型转换
• LIKE查询避免前缀通配符
• 使用合适的数据类型
```

### 14.3 性能监控要点


```
📊 关键监控指标：
• 慢查询数量和平均执行时间
• 数据库连接数和活跃连接
• 缓冲池命中率和IO使用率
• 锁等待时间和死锁次数

🎯 监控策略：
• 建立性能基线对比
• 设置告警阈值自动通知
• 定期检查执行计划变更
• 监控统计信息准确性
```

### 14.4 常见问题快速解决


```
⚡ 快速排查清单：
□ 检查是否有合适的索引
□ 确认统计信息是否最新
□ 查看是否有锁等待
□ 检查查询是否使用了函数
□ 确认数据量是否在合理范围
□ 查看执行计划type是否为ALL
□ 检查缓冲池大小是否足够
□ 确认超时设置是否合理
```

### 14.5 性能优化最佳实践


```
🎯 SQL编写规范：
• 只查询需要的字段，避免SELECT *
• 使用LIMIT限制返回行数
• 避免在WHERE中使用函数
• 合理使用JOIN，避免笛卡尔积

🔧 数据库配置：
• 合理设置innodb_buffer_pool_size
• 定期执行ANALYZE TABLE更新统计信息
• 设置合适的超时参数
• 监控并发连接数

📈 持续优化：
• 定期审查慢查询日志
• 建立性能监控和告警机制
• 制定索引维护计划
• 进行性能压测验证
```

**核心记忆要点**：
- 慢查询排查：日志→执行计划→索引→优化
- 索引失效：函数、类型转换、通配符要避免
- 性能监控：基线对比，主动发现问题
- 持续优化：监控、分析、改进的循环过程