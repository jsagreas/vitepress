---
title: 2、表维护核心命令实战
---
## 📚 目录

1. [表维护概述](#1-表维护概述)
2. [CHECK TABLE完整性检查](#2-CHECK-TABLE完整性检查)
3. [REPAIR TABLE表修复操作](#3-REPAIR-TABLE表修复操作)
4. [OPTIMIZE TABLE表优化重组](#4-OPTIMIZE-TABLE表优化重组)
5. [ANALYZE TABLE统计信息更新](#5-ANALYZE-TABLE统计信息更新)
6. [ALTER TABLE在线变更](#6-ALTER-TABLE在线变更)
7. [TRUNCATE TABLE快速清空](#7-TRUNCATE-TABLE快速清空)
8. [维护操作性能影响与锁定机制](#8-维护操作性能影响与锁定机制)
9. [维护命令执行时机与策略](#9-维护命令执行时机与策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔧 表维护概述


### 1.1 什么是表维护

**简单理解**：表维护就像给汽车做保养一样，定期检查、修复、优化数据库表，确保数据库健康运行。

```
数据库表维护的必要性：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   数据完整性     │    │   查询性能       │    │   存储效率       │
│  ============  │    │  ============  │    │  ============  │
│ • 检查数据错误  │    │ • 更新索引统计  │    │ • 回收空闲空间  │
│ • 修复损坏数据  │    │ • 优化查询计划  │    │ • 整理数据碎片  │
│ • 验证约束条件  │    │ • 重建索引结构  │    │ • 压缩表空间    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 核心维护命令分类


| 命令类型 | **主要作用** | **使用频率** | **影响程度** |
|----------|-------------|-------------|-------------|
| `CHECK TABLE` | `检查表完整性` | `定期检查` | `读锁，影响小` |
| `REPAIR TABLE` | `修复损坏表` | `故障时使用` | `写锁，影响大` |
| `OPTIMIZE TABLE` | `优化表结构` | `定期维护` | `重建表，影响大` |
| `ANALYZE TABLE` | `更新统计信息` | `高频使用` | `读锁，影响小` |
| `ALTER TABLE` | `结构变更` | `按需使用` | `锁定时间不定` |
| `TRUNCATE TABLE` | `快速清空` | `清理数据时` | `表锁，瞬间完成` |

### 1.3 维护命令选择原则


**🎯 选择标准**：
```
数据量大小：
• 小表(< 1GB)：可随时维护
• 中表(1-10GB)：选择业务低峰期  
• 大表(> 10GB)：需要专门维护窗口

业务影响程度：
• 核心业务表：优先选择影响小的命令
• 辅助业务表：可选择影响大但效果好的命令
• 日志类表：可直接清理重建

性能问题类型：
• 查询慢：优先 ANALYZE → OPTIMIZE
• 空间大：优先 OPTIMIZE → TRUNCATE  
• 数据错：优先 CHECK → REPAIR
```

---

## 2. 🔍 CHECK TABLE完整性检查


### 2.1 CHECK TABLE基本概念

**通俗解释**：`CHECK TABLE`就像给表做"体检"，检查数据是否完整、索引是否正常、表结构是否有问题。

**🔸 核心作用**：
- 检查表和索引的完整性
- 发现数据损坏问题
- 验证表结构一致性
- 不修改任何数据，只是检查

### 2.2 CHECK TABLE语法详解


**基础语法**：
```sql
CHECK TABLE table_name [, table_name] ... [option] ...

-- 检查选项
option: {
    FOR UPGRADE    -- 检查版本兼容性
  | QUICK          -- 快速检查，不扫描行数据
  | FAST           -- 仅检查未正常关闭的表
  | MEDIUM         -- 默认选项，检查行链接有效性
  | EXTENDED       -- 完全检查，最全面但最慢
  | CHANGED        -- 仅检查自上次检查后有变化的表
}
```

### 2.3 实际操作示例


**🛠️ 常用检查场景**：

```sql
-- 1. 基本完整性检查（最常用）
CHECK TABLE user_table;

-- 2. 快速检查多个表
CHECK TABLE user_table, order_table QUICK;

-- 3. 完全深度检查
CHECK TABLE important_table EXTENDED;

-- 4. 检查自上次变更后的表
CHECK TABLE log_table CHANGED;
```

### 2.4 CHECK结果解读


**📊 检查结果说明**：
```sql
-- 执行检查命令
CHECK TABLE user_table;

-- 典型返回结果
+-------------------+-------+----------+----------+
| Table             | Op    | Msg_type | Msg_text |
+-------------------+-------+----------+----------+
| mydb.user_table   | check | status   | OK       |
+-------------------+-------+----------+----------+
```

**结果状态含义**：
- **`OK`** - 表正常，无问题
- **`Table is already up to date`** - 表已是最新状态
- **`Corrupt`** - 表损坏，需要修复
- **`Error`** - 检查过程出错
- **`warning`** - 有警告信息，但不影响使用

### 2.5 CHECK TABLE性能影响


**⚡ 性能特点**：
```
锁定类型：读锁（READ LOCK）
影响程度：用户可以读取，但不能写入
执行时间：取决于表大小和检查选项

性能对比：
QUICK    < FAST < MEDIUM < EXTENDED
快速      一般    默认     最慢最全
```

**💡 使用建议**：
- **日常检查**：使用 `MEDIUM`（默认）
- **快速诊断**：使用 `QUICK`
- **深度体检**：使用 `EXTENDED`
- **大表检查**：在业务低峰期执行

---

## 3. 🔧 REPAIR TABLE表修复操作


### 3.1 REPAIR TABLE基本概念

**通俗解释**：`REPAIR TABLE`就像修理工具，当表数据损坏时，尝试自动修复损坏的数据和索引。

> **⚠️ 重要提示**：REPAIR TABLE主要适用于MyISAM存储引擎，InnoDB引擎有自己的崩溃恢复机制。

### 3.2 REPAIR TABLE语法详解


**基础语法**：
```sql
REPAIR TABLE table_name [, table_name] ... [QUICK] [EXTENDED] [USE_FRM]

-- 修复选项说明
QUICK      -- 快速修复，只修复索引树
EXTENDED   -- 扩展修复，逐行重建索引
USE_FRM    -- 使用.frm文件重建索引（.MYI文件损坏时使用）
```

### 3.3 实际修复场景


**🛠️ 修复操作示例**：

```sql
-- 1. 标准修复（最常用）
REPAIR TABLE damaged_table;

-- 2. 快速修复索引
REPAIR TABLE log_table QUICK;

-- 3. 完全重建修复
REPAIR TABLE critical_table EXTENDED;

-- 4. 索引文件损坏修复
REPAIR TABLE broken_table USE_FRM;
```

### 3.4 修复过程详解


**🔄 修复操作流程**：
```
修复过程示意：
损坏的表 → 检查损坏程度 → 选择修复策略 → 执行修复 → 验证结果

具体步骤：
1. 锁定表（防止并发访问）
2. 扫描数据文件找出损坏区域
3. 重建损坏的索引结构
4. 验证修复后的数据完整性
5. 释放表锁
```

### 3.5 修复结果处理


**📊 修复结果解读**：
```sql
-- 修复命令
REPAIR TABLE user_table;

-- 可能的返回结果
+-------------------+--------+----------+----------+
| Table             | Op     | Msg_type | Msg_text |
+-------------------+--------+----------+----------+
| mydb.user_table   | repair | status   | OK       |
+-------------------+--------+----------+----------+

-- 或者修复失败
+-------------------+--------+----------+----------------------------+
| Table             | Op     | Msg_type | Msg_text                   |
+-------------------+--------+----------+----------------------------+
| mydb.user_table   | repair | error    | 2 clients are using table |
+-------------------+--------+----------+----------------------------+
```

**❌ 修复失败常见原因**：
- 表正在被其他连接使用
- 磁盘空间不足
- 权限不够
- 数据损坏过于严重

### 3.6 修复最佳实践


**🎯 修复策略**：
```
修复前准备：
1. 备份原始数据（重要！）
2. 停止相关业务操作
3. 检查磁盘空间是否充足
4. 记录当前表状态

修复顺序：
CHECK TABLE → REPAIR TABLE QUICK → REPAIR TABLE EXTENDED
```

---

## 4. ⚡ OPTIMIZE TABLE表优化重组


### 4.1 OPTIMIZE TABLE基本概念

**通俗解释**：`OPTIMIZE TABLE`就像整理房间一样，把表中的数据重新整理排列，回收空闲空间，提高访问效率。

**🔸 主要作用**：
- 回收删除数据后的空闲空间
- 整理数据文件碎片
- 重建索引统计信息
- 提高查询性能

### 4.2 什么时候需要优化


**📊 需要优化的典型场景**：
```
数据变化情况 → 优化必要性

大量DELETE操作后：
删除前：[数据][数据][数据][数据][数据]
删除后：[数据][空洞][数据][空洞][数据]  ← 产生碎片
优化后：[数据][数据][数据]              ← 空间紧凑

频繁UPDATE操作：
• 变长字段频繁更新产生碎片
• 索引统计信息过期
• 查询性能下降

大批量INSERT后：
• 索引结构可能不够优化
• 统计信息需要更新
```

### 4.3 OPTIMIZE语法与示例


**基础语法**：
```sql
OPTIMIZE TABLE table_name [, table_name] ...
```

**🛠️ 实际操作示例**：
```sql
-- 1. 优化单个表
OPTIMIZE TABLE user_table;

-- 2. 同时优化多个表
OPTIMIZE TABLE user_table, order_table, product_table;

-- 3. 查看优化效果
SELECT 
    table_name,
    data_length,
    data_free,
    (data_free/data_length)*100 as fragmentation_pct
FROM information_schema.tables 
WHERE table_name = 'user_table';
```

### 4.4 优化过程详解


**🔄 优化操作内部流程**：
```
OPTIMIZE TABLE实际执行的操作：
1. 创建临时表结构
2. 将原表数据按顺序复制到临时表
3. 重建所有索引
4. 更新表统计信息
5. 用临时表替换原表
6. 删除原表文件

相当于执行：
ALTER TABLE table_name ENGINE=InnoDB;
```

### 4.5 优化效果评估


**📈 优化前后对比**：
```sql
-- 优化前检查表状态
SHOW TABLE STATUS LIKE 'user_table'\G

-- 关键指标：
-- Data_length: 数据文件大小
-- Data_free: 可回收的空闲空间
-- Avg_row_length: 平均行长度

-- 优化执行
OPTIMIZE TABLE user_table;

-- 优化后再次检查
SHOW TABLE STATUS LIKE 'user_table'\G

-- 对比变化：
-- Data_free 应该变成 0 或很小
-- Data_length 可能减小
-- 查询性能应该有提升
```

### 4.6 优化注意事项


**⚠️ 重要提醒**：
```
性能影响：
• 优化期间表被锁定，无法写入
• 需要额外的磁盘空间（约为表大小的2倍）
• 大表优化可能需要很长时间

适用存储引擎：
• InnoDB：支持，但实际执行ALTER TABLE重建
• MyISAM：完全支持
• Memory：不支持（会返回OK但不执行）

执行建议：
• 在业务低峰期执行
• 确保有足够的磁盘空间
• 大表考虑分批优化
```

---

## 5. 📊 ANALYZE TABLE统计信息更新


### 5.1 ANALYZE TABLE基本概念

**通俗解释**：`ANALYZE TABLE`就像给数据库做"普查"，收集表和索引的统计信息，帮助MySQL优化器制定更好的查询计划。

**🔸 核心作用**：
- 更新索引统计信息
- 帮助优化器选择最佳执行计划
- 提高查询性能
- 不修改表数据，只更新元数据

### 5.2 为什么需要统计信息


**📊 统计信息的重要性**：
```
查询优化器的决策依据：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   表行数统计     │    │   索引选择性     │    │   数据分布情况   │
│  ============  │    │  ============  │    │  ============  │
│ • 总行数        │    │ • 唯一值数量    │    │ • 值分布频率    │
│ • 平均行长      │    │ • 索引深度      │    │ • 热点数据      │
│ • 空值比例      │    │ • 叶子页数      │    │ • 数据倾斜      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                            ↓
                    影响查询执行计划选择
```

**实际例子**：
```sql
-- 假设查询：
SELECT * FROM user_table WHERE age > 25;

-- 优化器需要知道：
-- 1. user_table总共有多少行？
-- 2. age字段上有多少个不同的值？
-- 3. age > 25的数据大概占多少比例？
-- 4. 是走全表扫描快，还是走索引快？

-- 这些信息就来自ANALYZE TABLE收集的统计数据
```

### 5.3 ANALYZE语法与操作


**基础语法**：
```sql
ANALYZE TABLE table_name [, table_name] ...
```

**🛠️ 实际操作示例**：
```sql
-- 1. 分析单个表
ANALYZE TABLE user_table;

-- 2. 分析多个表
ANALYZE TABLE user_table, order_table, product_table;

-- 3. 查看分析结果
SELECT 
    table_name,
    cardinality,
    sub_part,
    nullable
FROM information_schema.statistics 
WHERE table_name = 'user_table';
```

### 5.4 统计信息查看方法


**📋 查看统计信息的方式**：
```sql
-- 1. 查看表级统计信息
SHOW TABLE STATUS LIKE 'user_table'\G

-- 2. 查看索引统计信息
SHOW INDEX FROM user_table;

-- 3. 查看详细统计信息
SELECT 
    table_name,
    table_rows,        -- 表行数估计
    avg_row_length,    -- 平均行长度
    data_length,       -- 数据文件大小
    index_length       -- 索引文件大小
FROM information_schema.tables 
WHERE table_name = 'user_table';
```

### 5.5 执行时机与频率


**⏰ 什么时候执行ANALYZE**：
```
必须执行的场景：
• 大批量数据导入后
• 大量DELETE/UPDATE操作后
• 新建索引后
• 查询性能突然下降时

建议执行频率：
• 高变化表：每天一次
• 中等变化表：每周一次
• 稳定表：每月一次
• 静态表：按需执行

自动执行设置：
-- 开启自动统计信息更新
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_persistent = ON;
```

### 5.6 性能影响与注意事项


**⚡ 性能特点**：
```
锁定影响：
• InnoDB：使用共享锁，可以并发读取
• MyISAM：使用读锁，阻塞写操作

执行时间：
• 通常很快完成（秒级）
• 大表可能需要几分钟
• 比OPTIMIZE TABLE快很多

资源消耗：
• CPU消耗较低
• IO消耗适中
• 内存消耗很少
```

---

## 6. 🔄 ALTER TABLE在线变更


### 6.1 ALTER TABLE基本概念

**通俗解释**：`ALTER TABLE`是修改表结构的万能工具，可以添加字段、修改数据类型、增删索引等，就像装修房子一样改造表结构。

**🔸 主要功能**：
- 添加、删除、修改列
- 创建、删除索引
- 修改表属性
- 重命名表或列
- 分区操作

### 6.2 在线DDL机制


**💡 在线DDL的含义**：
```
传统DDL问题：
修改表结构 → 锁定整个表 → 业务停止 → 修改完成 → 释放锁定

在线DDL优势：
修改表结构 → 最小锁定 → 业务继续 → 后台执行 → 快速完成

在线DDL支持情况：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   完全在线       │    │   部分在线       │    │   需要锁表       │
│  ============  │    │  ============  │    │  ============  │
│ • 添加索引      │    │ • 添加列        │    │ • 修改数据类型  │
│ • 删除索引      │    │ • 删除列        │    │ • 修改主键      │
│ • 重命名列      │    │ • 修改列属性    │    │ • 修改存储引擎  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 6.3 常用ALTER操作


**🛠️ 实际操作示例**：

```sql
-- 1. 添加新列（在线操作）
ALTER TABLE user_table 
ADD COLUMN phone VARCHAR(20) DEFAULT '' COMMENT '手机号';

-- 2. 修改列属性
ALTER TABLE user_table 
MODIFY COLUMN email VARCHAR(100) NOT NULL;

-- 3. 添加索引（完全在线）
ALTER TABLE user_table 
ADD INDEX idx_phone (phone);

-- 4. 删除索引（完全在线）
ALTER TABLE user_table 
DROP INDEX idx_old_column;

-- 5. 重命名列（需要锁定）
ALTER TABLE user_table 
CHANGE old_name new_name VARCHAR(50);
```

### 6.4 ALTER TABLE执行策略


**📋 执行算法选择**：
```sql
-- 指定执行算法
ALTER TABLE user_table 
ADD COLUMN age INT,
ALGORITHM = INPLACE,    -- 就地修改，不复制表
LOCK = NONE;           -- 不锁定表

-- 算法类型：
-- COPY：复制表方式（最慢，但兼容性最好）
-- INPLACE：就地修改（较快，部分操作支持）
-- INSTANT：即时修改（最快，MySQL 8.0+）

-- 锁定级别：
-- NONE：不锁定，完全在线
-- SHARED：共享锁，允许读取
-- EXCLUSIVE：排他锁，完全锁定
```

### 6.5 大表ALTER策略


**🎯 大表变更最佳实践**：
```sql
-- 1. 分步执行策略
-- 先添加列
ALTER TABLE large_table ADD COLUMN new_col INT;

-- 再更新数据（分批进行）
UPDATE large_table SET new_col = some_value 
WHERE id BETWEEN 1 AND 10000;

-- 最后添加约束
ALTER TABLE large_table MODIFY new_col INT NOT NULL;

-- 2. 使用pt-online-schema-change（第三方工具）
pt-online-schema-change \
  --alter "ADD COLUMN phone VARCHAR(20)" \
  --execute h=localhost,D=mydb,t=user_table
```

### 6.6 ALTER性能影响


**⚡ 性能影响评估**：
```
影响因素：
• 表大小：越大影响越大
• 操作类型：添加索引 < 添加列 < 修改数据类型
• 系统负载：高负载时影响更明显
• 存储引擎：InnoDB支持在线DDL，MyISAM不支持

预估时间：
• 添加索引：数据量 × 0.1秒/万行
• 添加列：数据量 × 0.5秒/万行  
• 修改数据类型：需要重建表，时间很长

监控方法：
SHOW PROCESSLIST;  -- 查看DDL进度
```

---

## 7. 🗑️ TRUNCATE TABLE快速清空


### 7.1 TRUNCATE TABLE基本概念

**通俗解释**：`TRUNCATE TABLE`就像把整个抽屉倒空重新开始，快速删除表中所有数据，但保留表结构。

**🔸 核心特点**：
- 删除所有行数据
- 保留表结构
- 重置自增计数器
- 速度极快
- 不可回滚（大部分情况）

### 7.2 TRUNCATE vs DELETE对比


**📊 性能与特性对比**：

| 特性 | **TRUNCATE TABLE** | **DELETE FROM table** |
|------|-------------------|----------------------|
| `速度` | `极快（毫秒级）` | `较慢（秒到分钟级）` |
| `锁定` | `表锁，瞬间释放` | `行锁，逐行处理` |
| `日志` | `最少日志记录` | `完整日志记录` |
| `回滚` | `不可回滚` | `可以回滚` |
| `触发器` | `不触发` | `触发DELETE触发器` |
| `自增ID` | `重置为1` | `保持不变` |
| `WHERE条件` | `不支持` | `支持条件删除` |

### 7.3 TRUNCATE语法与示例


**基础语法**：
```sql
TRUNCATE [TABLE] table_name
```

**🛠️ 实际操作示例**：
```sql
-- 1. 清空日志表
TRUNCATE TABLE access_log;

-- 2. 清空临时表
TRUNCATE TABLE temp_data;

-- 3. 重置测试数据
TRUNCATE TABLE test_user;

-- 检查效果
SELECT COUNT(*) FROM access_log;  -- 结果为0
SHOW TABLE STATUS LIKE 'access_log';  -- Auto_increment重置为1
```

### 7.4 使用场景与限制


**🎯 适用场景**：
```
理想使用场景：
• 清空日志表
• 清理临时数据
• 重置测试环境
• 清空缓存表
• 数据迁移准备

限制条件：
• 不能有外键约束引用
• 不能有活动的锁定
• 不能在事务中使用（部分存储引擎）
• 分区表需要特殊处理
```

**❌ 不能使用TRUNCATE的情况**：
```sql
-- 1. 有外键约束时
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 这时不能直接TRUNCATE users表
-- 必须先删除外键约束或清空orders表

-- 2. 有触发器且需要触发时
-- TRUNCATE不会触发DELETE触发器
-- 如果需要触发器执行，必须使用DELETE

-- 3. 需要条件删除时
-- TRUNCATE不支持WHERE条件
-- 必须使用DELETE WHERE
```

### 7.5 TRUNCATE执行过程


**🔄 内部执行机制**：
```
TRUNCATE TABLE的实际操作：
1. 获取表的排他锁
2. 删除所有数据页
3. 重置自增计数器
4. 更新表统计信息
5. 释放锁定

相比DELETE的优势：
DELETE：逐行删除 → 记录每行日志 → 检查约束 → 触发器
TRUNCATE：直接删除数据文件 → 最少日志 → 快速完成

时间对比示例：
100万行数据：
• DELETE FROM table：可能需要几分钟
• TRUNCATE TABLE：通常不到1秒
```

### 7.6 安全注意事项


**⚠️ 重要提醒**：
```
数据安全：
• TRUNCATE操作不可恢复
• 执行前务必确认数据可以删除
• 重要数据先备份

事务处理：
• 在InnoDB中，TRUNCATE会隐式提交当前事务
• 不能在显式事务中回滚TRUNCATE操作

权限要求：
• 需要DROP权限（不是DELETE权限）
• 权限级别比DELETE更高

最佳实践：
1. 执行前双重确认
2. 在测试环境先验证
3. 重要表先备份
4. 使用脚本时加入确认机制
```

---

## 8. 🔒 维护操作性能影响与锁定机制


### 8.1 锁定机制详解


**🔒 不同维护命令的锁定影响**：

```
锁定级别对比：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     读锁级别     │    │     写锁级别     │    │     表锁级别     │
│  ============  │    │  ============  │    │  ============  │
│ • CHECK TABLE   │    │ • REPAIR TABLE  │    │ • TRUNCATE     │
│ • ANALYZE TABLE │    │ • ALTER TABLE   │    │ • OPTIMIZE     │
│   (允许读取)    │    │   (阻塞读写)    │    │   (完全锁定)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

**实际影响示例**：
```sql
-- 1. CHECK TABLE执行期间
-- 会话A：
CHECK TABLE user_table;  -- 执行中...

-- 会话B（同时进行）：
SELECT * FROM user_table;     -- ✅ 可以执行
INSERT INTO user_table ...;   -- ❌ 等待锁释放

-- 2. OPTIMIZE TABLE执行期间  
-- 会话A：
OPTIMIZE TABLE user_table;    -- 执行中...

-- 会话B（同时进行）：
SELECT * FROM user_table;     -- ❌ 等待锁释放
INSERT INTO user_table ...;   -- ❌ 等待锁释放
```

### 8.2 性能影响评估


**📊 维护操作性能对比**：

| 命令 | **锁定时间** | **CPU使用** | **IO使用** | **内存使用** | **业务影响** |
|------|-------------|------------|------------|-------------|-------------|
| `CHECK` | `短暂` | `中等` | `高` | `低` | `读取不受影响` |
| `ANALYZE` | `很短` | `低` | `中等` | `低` | `几乎无影响` |
| `REPAIR` | `较长` | `高` | `很高` | `中等` | `完全阻塞写入` |
| `OPTIMIZE` | `很长` | `很高` | `很高` | `高` | `完全阻塞访问` |
| `TRUNCATE` | `瞬间` | `很低` | `很低` | `很低` | `瞬间完成` |

### 8.3 并发控制策略


**🎯 降低影响的策略**：
```sql
-- 1. 使用低优先级执行
SET SESSION low_priority_updates = 1;
OPTIMIZE TABLE user_table;

-- 2. 设置锁等待超时
SET SESSION lock_wait_timeout = 10;  -- 10秒超时

-- 3. 检查当前锁状态
SHOW ENGINE INNODB STATUS\G  -- 查看InnoDB锁信息
SHOW PROCESSLIST;            -- 查看等待的进程

-- 4. 分片表的分批处理
-- 对大表进行分时段维护
OPTIMIZE TABLE user_table_2024_01;
-- 等待业务低峰期
OPTIMIZE TABLE user_table_2024_02;
```

### 8.4 监控维护进度


**📈 进度监控方法**：
```sql
-- 1. 查看当前执行的维护操作
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM information_schema.PROCESSLIST 
WHERE COMMAND IN ('Repair', 'Optimize', 'Check');

-- 2. 监控表状态变化
-- 维护前
SELECT table_name, data_length, data_free, table_rows
FROM information_schema.tables 
WHERE table_name = 'user_table';

-- 维护后对比
-- （执行维护命令）

-- 再次查询对比效果
```

### 8.5 维护操作调度


**⏰ 最佳执行时机**：
```
业务时间分析：
00:00-06:00  业务低谷期     ← 最佳维护窗口
06:00-09:00  业务增长期     ← 可执行轻量维护
09:00-12:00  业务高峰期     ← 避免维护操作
12:00-14:00  午间相对空闲   ← 可执行中等维护
14:00-18:00  业务高峰期     ← 避免维护操作  
18:00-20:00  晚间高峰期     ← 避免维护操作
20:00-24:00  业务回落期     ← 可执行轻量维护

维护计划建议：
• 重度维护（OPTIMIZE）：凌晨执行
• 中度维护（REPAIR）：业务低谷期
• 轻度维护（ANALYZE）：任何时间
• 检查操作（CHECK）：定期自动执行
```

---

## 9. ⏰ 维护命令执行时机与策略


### 9.1 维护计划制定


**📋 维护策略矩阵**：
```
表重要性 × 数据变化频率 = 维护策略

             │  高变化  │  中变化  │  低变化  │
─────────────┼─────────┼─────────┼─────────┤
核心业务表   │  每日    │  每周    │  每月    │
重要业务表   │  每周    │  每月    │  季度    │  
辅助业务表   │  每月    │  季度    │  半年    │
日志类表     │  按需    │  按需    │  按需    │

维护内容：
• 每日：ANALYZE TABLE
• 每周：CHECK TABLE + ANALYZE TABLE  
• 每月：CHECK + ANALYZE + 必要时OPTIMIZE
• 季度：全面维护包括OPTIMIZE
```

### 9.2 自动化维护脚本


**🤖 维护脚本示例**：
```bash
#!/bin/bash
# database_maintenance.sh

# 配置参数
DB_NAME="mydb"
DB_USER="admin"
DB_PASS="password"

# 日志文件
LOG_FILE="/var/log/mysql_maintenance_$(date +%Y%m%d).log"

# 函数：执行SQL并记录日志
execute_sql() {
    local sql="$1"
    local description="$2"
    
    echo "$(date): $description" >> $LOG_FILE
    mysql -u$DB_USER -p$DB_PASS $DB_NAME -e "$sql" >> $LOG_FILE 2>&1
    
    if [ $? -eq 0 ]; then
        echo "$(date): $description - 成功" >> $LOG_FILE
    else
        echo "$(date): $description - 失败" >> $LOG_FILE
    fi
}

# 每日维护：更新统计信息
daily_maintenance() {
    echo "$(date): 开始每日维护" >> $LOG_FILE
    
    # 获取需要维护的表列表
    tables=$(mysql -u$DB_USER -p$DB_PASS $DB_NAME -e "
        SELECT table_name FROM information_schema.tables 
        WHERE table_schema='$DB_NAME' AND table_type='BASE TABLE'
    " --skip-column-names)
    
    # 逐个分析表
    for table in $tables; do
        execute_sql "ANALYZE TABLE $table;" "分析表 $table"
    done
    
    echo "$(date): 每日维护完成" >> $LOG_FILE
}

# 每周维护：检查表完整性
weekly_maintenance() {
    echo "$(date): 开始每周维护" >> $LOG_FILE
    
    # 检查所有表
    execute_sql "
        CHECK TABLE $(mysql -u$DB_USER -p$DB_PASS $DB_NAME -e "
            SELECT GROUP_CONCAT(table_name) FROM information_schema.tables 
            WHERE table_schema='$DB_NAME' AND table_type='BASE TABLE'
        " --skip-column-names);
    " "检查所有表"
    
    # 分析所有表
    daily_maintenance
    
    echo "$(date): 每周维护完成" >> $LOG_FILE
}

# 根据参数执行不同维护
case "$1" in
    "daily")
        daily_maintenance
        ;;
    "weekly")
        weekly_maintenance
        ;;
    *)
        echo "用法: $0 {daily|weekly}"
        exit 1
        ;;
esac
```

### 9.3 定时任务配置


**⏰ Crontab配置示例**：
```bash
# 编辑定时任务
crontab -e

# 添加维护任务
# 每天凌晨2点执行日常维护
0 2 * * * /path/to/database_maintenance.sh daily

# 每周日凌晨1点执行周维护
0 1 * * 0 /path/to/database_maintenance.sh weekly

# 每月1号凌晨3点执行深度维护
0 3 1 * * /path/to/monthly_maintenance.sh

# 每小时检查关键表（仅分析）
0 * * * * mysql -uadmin -ppassword mydb -e "ANALYZE TABLE user_table, order_table;"
```

### 9.4 维护结果监控


**📊 监控与报告**：
```sql
-- 创建维护日志表
CREATE TABLE maintenance_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    operation VARCHAR(20),
    start_time DATETIME,
    end_time DATETIME,
    result VARCHAR(10),
    message TEXT,
    data_length_before BIGINT,
    data_length_after BIGINT,
    INDEX idx_table_time (table_name, start_time)
);

-- 维护脚本中记录日志
INSERT INTO maintenance_log 
(table_name, operation, start_time, result, message) 
VALUES ('user_table', 'OPTIMIZE', NOW(), 'SUCCESS', 'Table optimized successfully');

-- 生成维护报告
SELECT 
    DATE(start_time) as maintenance_date,
    COUNT(*) as operations_count,
    SUM(CASE WHEN result = 'SUCCESS' THEN 1 ELSE 0 END) as success_count,
    SUM(CASE WHEN result = 'FAILED' THEN 1 ELSE 0 END) as failed_count,
    AVG(TIMESTAMPDIFF(SECOND, start_time, end_time)) as avg_duration_seconds
FROM maintenance_log 
WHERE start_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(start_time)
ORDER BY maintenance_date DESC;
```

### 9.5 紧急维护处理


**🚨 紧急情况处理流程**：
```
紧急维护触发条件：
• 查询性能急剧下降
• 表损坏报错
• 磁盘空间即将耗尽
• 统计信息严重过时

紧急处理步骤：
1. 评估影响范围和紧急程度
2. 通知相关团队准备
3. 选择影响最小的维护方案
4. 执行维护并密切监控
5. 验证修复效果
6. 记录问题和解决方案

快速诊断命令：
-- 检查表状态
SHOW TABLE STATUS WHERE Data_free > Data_length * 0.1;

-- 检查慢查询
SHOW PROCESSLIST;

-- 检查错误日志
SHOW ENGINE INNODB STATUS\G
```

---

## 10. 📋 核心要点总结


### 10.1 命令使用原则


**🎯 选择合适的维护命令**：
```
日常巡检：CHECK TABLE
• 定期检查表完整性
• 发现问题及时处理
• 影响小，可经常执行

性能优化：ANALYZE TABLE  
• 更新统计信息
• 提高查询性能
• 执行频率最高

问题修复：REPAIR TABLE
• 仅在发现损坏时使用
• 主要用于MyISAM表
• 执行前务必备份

深度优化：OPTIMIZE TABLE
• 回收空间，提升性能
• 影响大，选择合适时机
• 大表慎用

结构变更：ALTER TABLE
• 修改表结构
• 优先选择在线DDL
• 大表分批处理

快速清理：TRUNCATE TABLE
• 快速清空表数据
• 不可回滚，谨慎使用
• 适合日志、临时表
```

### 10.2 性能影响总结


**⚡ 维护操作影响对比**：
```
影响程度：TRUNCATE < ANALYZE < CHECK < ALTER < REPAIR < OPTIMIZE

执行建议：
轻量级（随时）：ANALYZE TABLE, TRUNCATE TABLE
中等级（低峰期）：CHECK TABLE, 简单ALTER TABLE  
重量级（维护窗口）：OPTIMIZE TABLE, REPAIR TABLE, 复杂ALTER

资源需求：
CPU密集型：OPTIMIZE, REPAIR
IO密集型：CHECK, OPTIMIZE  
内存密集型：大表ALTER
时间敏感型：REPAIR, OPTIMIZE
```

### 10.3 最佳实践要点


**🏆 维护作业最佳实践**：
- **定期执行**：建立定期维护计划，预防问题发生
- **监控先行**：先监控再维护，了解表状态后再决策
- **备份保障**：重要操作前必须备份，确保数据安全
- **分批处理**：大表分批维护，降低对业务的影响
- **时机选择**：在业务低峰期执行重度维护操作
- **结果验证**：维护后验证效果，确保达到预期目标

**🔧 实施建议**：
- 制定维护计划并严格执行
- 建立监控和报警机制
- 培训运维人员掌握各命令用法
- 准备紧急情况处理预案
- 定期评估和优化维护策略

**核心记忆**：
> 表维护像体检，定期检查保健康  
> 选对命令看时机，备份先行再维护  
> 轻重缓急要分清，业务影响需考量