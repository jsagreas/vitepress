---
title: 10、表数据质量检查
---
## 📚 目录

1. [数据质量检查概述](#1-数据质量检查概述)
2. [数据完整性检查](#2-数据完整性检查)
3. [约束违反检测](#3-约束违反检测)
4. [重复数据识别](#4-重复数据识别)
5. [空值数据分析](#5-空值数据分析)
6. [数据类型一致性](#6-数据类型一致性)
7. [外键约束验证](#7-外键约束验证)
8. [数据范围检查](#8-数据范围检查)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 数据质量检查概述


### 1.1 什么是数据质量检查


**简单理解**：数据质量检查就像是给数据库做"体检"，检查数据是否健康、完整、准确。

```
就像医生检查身体一样：
体检项目         数据质量检查
血压测量    →    数据范围检查
血液化验    →    数据类型检查  
X光检查     →    重复数据检查
心电图      →    完整性检查
```

### 1.2 为什么要做数据质量检查


**核心价值**：
- 🔍 **发现问题**：及时发现数据异常和错误
- 🛡️ **保证准确性**：确保业务决策基于正确数据
- ⚡ **提升性能**：清理无效数据，提高查询效率
- 📊 **支持分析**：为数据分析提供可靠基础

```
数据质量问题的影响：
┌─────────────────┐    ┌─────────────────┐
│   脏数据进入     │───▶│   错误的分析结果   │
└─────────────────┘    └─────────────────┘
         │                       │
         ▼                       ▼
┌─────────────────┐    ┌─────────────────┐
│   系统性能下降   │    │   业务决策失误   │
└─────────────────┘    └─────────────────┘
```

### 1.3 数据质量的主要维度


| 质量维度 | **含义** | **检查重点** |
|---------|---------|-------------|
| 🎯 **完整性** | `数据是否缺失` | `空值、必填字段` |
| ✅ **准确性** | `数据是否正确` | `格式、范围、逻辑` |
| 🔄 **一致性** | `数据是否统一` | `格式统一、关联一致` |
| ⚡ **及时性** | `数据是否最新` | `更新时间、过期数据` |
| 🎨 **唯一性** | `数据是否重复` | `主键、唯一约束` |

---

## 2. ✅ 数据完整性检查


### 2.1 什么是数据完整性


**通俗解释**：数据完整性就是检查数据是否"完整无缺"，就像检查表格是否填写完整一样。

### 2.2 主键完整性检查


**检查目的**：确保每条记录都有唯一标识

```sql
-- 检查主键是否有空值
SELECT COUNT(*) as null_primary_keys
FROM users 
WHERE user_id IS NULL;

-- 检查主键是否有重复
SELECT user_id, COUNT(*) as duplicate_count
FROM users 
GROUP BY user_id 
HAVING COUNT(*) > 1;
```

### 2.3 必填字段完整性检查


**实际场景**：用户注册表中，姓名、邮箱等关键信息不能为空

```sql
-- 检查用户表关键字段的空值情况
SELECT 
    'username' as field_name,
    COUNT(*) as total_records,
    SUM(CASE WHEN username IS NULL OR username = '' THEN 1 ELSE 0 END) as null_count,
    ROUND(SUM(CASE WHEN username IS NULL OR username = '' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as null_percentage
FROM users
UNION ALL
SELECT 
    'email' as field_name,
    COUNT(*) as total_records,
    SUM(CASE WHEN email IS NULL OR email = '' THEN 1 ELSE 0 END) as null_count,
    ROUND(SUM(CASE WHEN email IS NULL OR email = '' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as null_percentage
FROM users;
```

**结果解读**：
```
field_name | total_records | null_count | null_percentage
-----------|---------------|------------|----------------
username   | 10000         | 23         | 0.23%
email      | 10000         | 156        | 1.56%
```

### 2.4 参照完整性检查


**含义**：检查表与表之间的关联是否完整

```sql
-- 检查订单表中是否有无效的用户ID
SELECT COUNT(*) as orphan_orders
FROM orders o
LEFT JOIN users u ON o.user_id = u.user_id
WHERE u.user_id IS NULL;
```

---

## 3. 🚨 约束违反检测


### 3.1 约束违反的含义


**简单理解**：约束就像是数据库的"规则"，约束违反就是有数据"违反了规则"。

```
类比生活中的规则：
交通规则     →    数据库约束
闯红灯      →    违反非空约束
逆行       →    违反外键约束
超速       →    违反检查约束
```

### 3.2 非空约束检查


**检查目的**：确保重要字段不为空

```sql
-- 检查违反非空约束的记录
SELECT 
    table_name,
    column_name,
    constraint_name,
    COUNT(*) as violation_count
FROM (
    SELECT 'users' as table_name, 'email' as column_name, 'email_not_null' as constraint_name
    FROM users WHERE email IS NULL
    UNION ALL
    SELECT 'orders' as table_name, 'order_date' as column_name, 'order_date_not_null' as constraint_name  
    FROM orders WHERE order_date IS NULL
) violations
GROUP BY table_name, column_name, constraint_name;
```

### 3.3 唯一约束检查


**实际应用**：检查邮箱、手机号等应该唯一的字段

```sql
-- 检查邮箱重复情况
SELECT 
    email,
    COUNT(*) as duplicate_count,
    GROUP_CONCAT(user_id) as duplicate_user_ids
FROM users 
WHERE email IS NOT NULL
GROUP BY email 
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC;
```

### 3.4 检查约束验证


**场景举例**：年龄必须在合理范围内，价格必须为正数

```sql
-- 检查年龄范围约束
SELECT COUNT(*) as invalid_age_count
FROM users 
WHERE age < 0 OR age > 150;

-- 检查价格约束
SELECT COUNT(*) as invalid_price_count
FROM products 
WHERE price <= 0;
```

---

## 4. 🔍 重复数据识别


### 4.1 重复数据的危害


**实际影响**：
- 📊 **统计错误**：重复数据导致计算结果不准确
- 💾 **存储浪费**：占用不必要的存储空间
- ⚡ **性能下降**：查询和处理时间增加
- 🔄 **业务混乱**：同一个客户有多个记录

### 4.2 完全重复检测


**含义**：所有字段都相同的记录

```sql
-- 检查完全重复的用户记录
SELECT 
    username, email, phone, age,
    COUNT(*) as duplicate_count
FROM users 
GROUP BY username, email, phone, age
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC;
```

### 4.3 关键字段重复检测


**实际场景**：同一个人可能用不同信息注册多个账号

```sql
-- 基于邮箱检测可能的重复用户
WITH email_duplicates AS (
    SELECT email, COUNT(*) as count
    FROM users 
    WHERE email IS NOT NULL
    GROUP BY email 
    HAVING COUNT(*) > 1
)
SELECT 
    u.user_id,
    u.username, 
    u.email,
    u.registration_date,
    ed.count as total_accounts_with_same_email
FROM users u
JOIN email_duplicates ed ON u.email = ed.email
ORDER BY u.email, u.registration_date;
```

### 4.4 模糊重复检测


**应用场景**：名字相似、地址相近的记录可能是同一个实体

```sql
-- 检测相似的公司名称（简化示例）
SELECT 
    c1.company_id as id1,
    c1.company_name as name1,
    c2.company_id as id2, 
    c2.company_name as name2
FROM companies c1
JOIN companies c2 ON c1.company_id < c2.company_id
WHERE LEVENSHTEIN(c1.company_name, c2.company_name) <= 3
   OR SOUNDEX(c1.company_name) = SOUNDEX(c2.company_name);
```

---

## 5. 🕳️ 空值数据分析


### 5.1 空值分析的重要性


**为什么要分析空值**：
- 🎯 **了解数据质量**：空值比例反映数据收集质量
- 📊 **指导业务改进**：哪些字段经常空值需要优化流程
- 🔧 **优化存储**：过多空值的字段可能需要重新设计

### 5.2 全表空值统计


```sql
-- 统计每个字段的空值情况
SELECT 
    'user_id' as column_name,
    COUNT(*) as total_rows,
    SUM(CASE WHEN user_id IS NULL THEN 1 ELSE 0 END) as null_count,
    ROUND(AVG(CASE WHEN user_id IS NULL THEN 1.0 ELSE 0.0 END) * 100, 2) as null_percentage
FROM users
UNION ALL
SELECT 
    'username',
    COUNT(*),
    SUM(CASE WHEN username IS NULL THEN 1 ELSE 0 END),
    ROUND(AVG(CASE WHEN username IS NULL THEN 1.0 ELSE 0.0 END) * 100, 2)
FROM users
UNION ALL
SELECT 
    'email',
    COUNT(*),
    SUM(CASE WHEN email IS NULL THEN 1 ELSE 0 END),
    ROUND(AVG(CASE WHEN email IS NULL THEN 1.0 ELSE 0.0 END) * 100, 2)
FROM users;
```

### 5.3 空值模式分析


**发现规律**：哪些记录倾向于有更多空值

```sql
-- 分析用户档案完整度
SELECT 
    CASE 
        WHEN (username IS NULL) + (email IS NULL) + (phone IS NULL) + (address IS NULL) = 0 
        THEN '完整档案'
        WHEN (username IS NULL) + (email IS NULL) + (phone IS NULL) + (address IS NULL) <= 2 
        THEN '基本完整'
        ELSE '档案不全'
    END as profile_completeness,
    COUNT(*) as user_count,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users), 2) as percentage
FROM users
GROUP BY 
    CASE 
        WHEN (username IS NULL) + (email IS NULL) + (phone IS NULL) + (address IS NULL) = 0 
        THEN '完整档案'
        WHEN (username IS NULL) + (email IS NULL) + (phone IS NULL) + (address IS NULL) <= 2 
        THEN '基本完整'
        ELSE '档案不全'
    END;
```

### 5.4 业务影响分析


**关联业务指标**：空值对业务的实际影响

```sql
-- 分析档案完整度与用户活跃度的关系
SELECT 
    CASE 
        WHEN email IS NULL AND phone IS NULL THEN '无联系方式'
        WHEN email IS NULL OR phone IS NULL THEN '联系方式不全'
        ELSE '联系方式完整'
    END as contact_completeness,
    COUNT(*) as user_count,
    AVG(login_count) as avg_login_count,
    AVG(order_count) as avg_order_count
FROM users u
LEFT JOIN (
    SELECT user_id, COUNT(*) as login_count 
    FROM user_logins 
    GROUP BY user_id
) l ON u.user_id = l.user_id
LEFT JOIN (
    SELECT user_id, COUNT(*) as order_count 
    FROM orders 
    GROUP BY user_id  
) o ON u.user_id = o.user_id
GROUP BY contact_completeness;
```

---

## 6. 🔢 数据类型一致性


### 6.1 数据类型一致性的含义


**简单理解**：确保同一个字段中的数据格式保持统一，就像所有的电话号码都应该是数字格式。

### 6.2 数值型数据检查


**常见问题**：数值字段中混入了文本

```sql
-- 检查应该是数值的字段中的异常数据
SELECT 
    product_id,
    price,
    CASE 
        WHEN price REGEXP '^[0-9]+\.?[0-9]*$' THEN '正常数值'
        ELSE '异常格式'
    END as price_format_check
FROM products 
WHERE price IS NOT NULL
AND NOT price REGEXP '^[0-9]+\.?[0-9]*$';
```

### 6.3 日期格式一致性


**实际问题**：日期字段中可能存在不同格式

```sql
-- 检查日期格式的一致性
SELECT 
    order_date,
    CASE 
        WHEN order_date REGEXP '^[0-9]{4}-[0-9]{2}-[0-9]{2}$' THEN 'YYYY-MM-DD'
        WHEN order_date REGEXP '^[0-9]{2}/[0-9]{2}/[0-9]{4}$' THEN 'MM/DD/YYYY'
        WHEN order_date REGEXP '^[0-9]{2}-[0-9]{2}-[0-9]{4}$' THEN 'MM-DD-YYYY'
        ELSE '其他格式'
    END as date_format,
    COUNT(*) as count
FROM orders 
WHERE order_date IS NOT NULL
GROUP BY date_format;
```

### 6.4 字符串格式检查


**应用场景**：邮箱、手机号、身份证号等有固定格式要求

```sql
-- 检查邮箱格式
SELECT 
    COUNT(*) as total_emails,
    SUM(CASE 
        WHEN email REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' 
        THEN 1 ELSE 0 
    END) as valid_format_count,
    SUM(CASE 
        WHEN email NOT REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' 
        THEN 1 ELSE 0 
    END) as invalid_format_count
FROM users 
WHERE email IS NOT NULL;

-- 检查手机号格式
SELECT 
    phone,
    CASE 
        WHEN phone REGEXP '^1[3-9][0-9]{9}$' THEN '标准手机号'
        WHEN phone REGEXP '^[0-9]{11}$' THEN '11位数字'
        WHEN LENGTH(phone) != 11 THEN '长度异常'
        ELSE '格式异常'
    END as phone_check
FROM users 
WHERE phone IS NOT NULL 
AND phone NOT REGEXP '^1[3-9][0-9]{9}$';
```

---

## 7. 🔗 外键约束验证


### 7.1 外键约束的作用


**生活化理解**：外键就像是"身份证"，确保引用的记录确实存在。

```
现实场景对比：
学生选课    →    学生ID必须在学生表中存在
员工部门    →    部门ID必须在部门表中存在  
订单用户    →    用户ID必须在用户表中存在
```

### 7.2 孤儿记录检测


**什么是孤儿记录**：引用了不存在的外键值的记录

```sql
-- 检查订单表中的孤儿记录（用户ID不存在）
SELECT 
    o.order_id,
    o.user_id as invalid_user_id,
    o.order_date,
    o.total_amount
FROM orders o
LEFT JOIN users u ON o.user_id = u.user_id
WHERE u.user_id IS NULL;

-- 检查订单详情中的孤儿记录（产品ID不存在）
SELECT 
    od.order_detail_id,
    od.product_id as invalid_product_id,
    od.quantity,
    od.price
FROM order_details od
LEFT JOIN products p ON od.product_id = p.product_id  
WHERE p.product_id IS NULL;
```

### 7.3 循环引用检测


**场景说明**：检查是否存在不合理的循环依赖

```sql
-- 检查部门层级中的循环引用
WITH RECURSIVE dept_hierarchy AS (
    -- 起始点：所有部门
    SELECT department_id, parent_department_id, department_name, 
           department_id as root_id, 1 as level
    FROM departments
    
    UNION ALL
    
    -- 递归：向上查找父部门
    SELECT d.department_id, d.parent_department_id, d.department_name,
           dh.root_id, dh.level + 1
    FROM departments d
    JOIN dept_hierarchy dh ON d.department_id = dh.parent_department_id
    WHERE dh.level < 10  -- 防止无限递归
)
SELECT root_id, department_id, level
FROM dept_hierarchy 
WHERE root_id = department_id AND level > 1;  -- 发现循环
```

### 7.4 外键完整性统计


**整体评估**：了解外键约束的整体状况

```sql
-- 外键约束完整性统计报告
SELECT 
    'orders -> users' as relationship,
    COUNT(o.order_id) as total_orders,
    COUNT(u.user_id) as valid_references,
    COUNT(o.order_id) - COUNT(u.user_id) as orphan_count,
    ROUND((COUNT(u.user_id) * 100.0 / COUNT(o.order_id)), 2) as integrity_percentage
FROM orders o
LEFT JOIN users u ON o.user_id = u.user_id

UNION ALL

SELECT 
    'order_details -> products' as relationship,
    COUNT(od.order_detail_id) as total_details,
    COUNT(p.product_id) as valid_references,
    COUNT(od.order_detail_id) - COUNT(p.product_id) as orphan_count,
    ROUND((COUNT(p.product_id) * 100.0 / COUNT(od.order_detail_id)), 2) as integrity_percentage
FROM order_details od
LEFT JOIN products p ON od.product_id = p.product_id;
```

---

## 8. 📊 数据范围检查


### 8.1 数据范围检查的意义


**实际价值**：确保数据在合理的业务范围内，就像检查体温不能是-10度或200度。

### 8.2 数值范围检查


**常见场景**：年龄、价格、数量等应该在合理范围内

```sql
-- 检查用户年龄的合理性
SELECT 
    '年龄范围检查' as check_type,
    COUNT(*) as total_records,
    SUM(CASE WHEN age < 0 THEN 1 ELSE 0 END) as negative_age,
    SUM(CASE WHEN age > 150 THEN 1 ELSE 0 END) as excessive_age,
    SUM(CASE WHEN age BETWEEN 0 AND 150 THEN 1 ELSE 0 END) as normal_age,
    AVG(age) as average_age,
    MIN(age) as min_age,
    MAX(age) as max_age
FROM users 
WHERE age IS NOT NULL;

-- 检查产品价格的合理性
SELECT 
    '价格范围检查' as check_type,
    COUNT(*) as total_products,
    SUM(CASE WHEN price <= 0 THEN 1 ELSE 0 END) as zero_negative_price,
    SUM(CASE WHEN price > 1000000 THEN 1 ELSE 0 END) as excessive_price,
    AVG(price) as average_price,
    MIN(price) as min_price,
    MAX(price) as max_price
FROM products 
WHERE price IS NOT NULL;
```

### 8.3 日期范围检查


**业务逻辑**：订单日期不能是未来，生日不能是未来等

```sql
-- 检查订单日期的合理性
SELECT 
    COUNT(*) as total_orders,
    SUM(CASE WHEN order_date > CURRENT_DATE THEN 1 ELSE 0 END) as future_orders,
    SUM(CASE WHEN order_date < '2000-01-01' THEN 1 ELSE 0 END) as very_old_orders,
    SUM(CASE WHEN order_date BETWEEN '2000-01-01' AND CURRENT_DATE THEN 1 ELSE 0 END) as normal_orders
FROM orders 
WHERE order_date IS NOT NULL;

-- 检查用户生日的合理性  
SELECT 
    COUNT(*) as total_users,
    SUM(CASE WHEN birth_date > CURRENT_DATE THEN 1 ELSE 0 END) as future_birth,
    SUM(CASE WHEN birth_date < '1900-01-01' THEN 1 ELSE 0 END) as very_old_birth,
    SUM(CASE WHEN YEAR(CURRENT_DATE) - YEAR(birth_date) > 150 THEN 1 ELSE 0 END) as unrealistic_age
FROM users 
WHERE birth_date IS NOT NULL;
```

### 8.4 业务逻辑范围检查


**关联性检查**：多个字段之间的逻辑关系

```sql
-- 检查订单金额与明细金额的一致性
SELECT 
    o.order_id,
    o.total_amount as order_total,
    SUM(od.quantity * od.unit_price) as calculated_total,
    ABS(o.total_amount - SUM(od.quantity * od.unit_price)) as difference
FROM orders o
JOIN order_details od ON o.order_id = od.order_id
GROUP BY o.order_id, o.total_amount
HAVING ABS(o.total_amount - SUM(od.quantity * od.unit_price)) > 0.01;

-- 检查发货日期与订单日期的逻辑性
SELECT 
    order_id,
    order_date,
    ship_date,
    DATEDIFF(ship_date, order_date) as days_to_ship
FROM orders 
WHERE ship_date < order_date  -- 发货日期早于订单日期
   OR DATEDIFF(ship_date, order_date) > 365;  -- 超过一年才发货
```

### 8.5 统计分布检查


**发现异常值**：通过统计分析找出明显偏离正常范围的数据

```sql
-- 使用四分位数检测异常订单金额
WITH order_stats AS (
    SELECT 
        total_amount,
        NTILE(4) OVER (ORDER BY total_amount) as quartile
    FROM orders 
    WHERE total_amount IS NOT NULL
),
quartile_bounds AS (
    SELECT 
        MAX(CASE WHEN quartile = 1 THEN total_amount END) as q1,
        MAX(CASE WHEN quartile = 3 THEN total_amount END) as q3
    FROM order_stats
),
outlier_bounds AS (
    SELECT 
        q1 - 1.5 * (q3 - q1) as lower_bound,
        q3 + 1.5 * (q3 - q1) as upper_bound
    FROM quartile_bounds
)
SELECT 
    o.order_id,
    o.total_amount,
    CASE 
        WHEN o.total_amount < ob.lower_bound THEN '异常偏低'
        WHEN o.total_amount > ob.upper_bound THEN '异常偏高'
        ELSE '正常范围'
    END as outlier_status
FROM orders o
CROSS JOIN outlier_bounds ob
WHERE o.total_amount < ob.lower_bound 
   OR o.total_amount > ob.upper_bound;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 数据质量检查：确保数据准确、完整、一致的系统性检验
🔸 完整性检查：验证数据是否缺失，关键字段是否完整填写
🔸 约束违反：数据不符合预设规则的情况，需要及时发现和处理
🔸 重复数据：相同或相似的记录，影响数据准确性和系统性能
🔸 外键完整性：确保表间关联的有效性和一致性
🔸 数据范围：验证数据是否在合理的业务范围内
```

### 9.2 关键理解要点


**🔹 数据质量检查的系统性方法**
```
检查维度：
完整性 → 数据是否缺失
准确性 → 数据是否正确  
一致性 → 格式是否统一
唯一性 → 是否存在重复
有效性 → 是否符合业务规则
```

**🔹 实施策略的优先级**
```
高优先级：
✅ 主键和外键完整性
✅ 业务关键字段的非空检查
✅ 明显的数据格式错误

中优先级：
🔸 重复数据清理
🔸 数据范围合理性检查
🔸 格式一致性规范

低优先级：
📊 统计分析和报告
📈 历史趋势分析
🔍 深度数据挖掘
```

**🔹 自动化vs手工检查**
```
适合自动化：
• 格式验证（邮箱、手机号）
• 范围检查（年龄、价格）
• 约束验证（主键、外键）
• 重复数据检测

需要人工判断：
• 业务逻辑的合理性
• 数据的语义正确性
• 异常情况的处理策略
• 历史数据的处理方式
```

### 9.3 实际应用价值


**🎯 业务价值**
- **提升决策质量**：基于准确数据的业务分析和决策
- **降低运营风险**：及时发现和处理数据异常
- **提高工作效率**：减少因数据问题导致的重复工作
- **增强用户体验**：确保系统功能的正常运行

**🔧 技术价值**  
- **系统稳定性**：避免因脏数据导致的系统错误
- **性能优化**：清理无效数据，提升查询效率
- **数据迁移**：为系统升级和数据迁移提供保障
- **合规要求**：满足数据治理和合规性要求

### 9.4 最佳实践建议


**📅 定期检查机制**
```
日常监控：
• 每日检查关键业务数据
• 实时监控数据质量指标
• 异常情况自动告警

周期性审核：
• 每周全面数据质量报告
• 每月数据趋势分析
• 每季度数据治理评估
```

**🛠️ 工具和方法**
- **SQL脚本**：编写标准化的检查脚本
- **监控工具**：使用专业的数据质量监控工具
- **可视化报表**：建立数据质量仪表板
- **流程规范**：制定数据质量管理流程

**核心记忆要点**：
- 数据质量检查是数据库运维的基础工作
- 系统性的检查方法比零散的检查更有效
- 预防胜于治疗，建立持续的监控机制
- 工具自动化与人工智慧相结合是最佳实践