---
title: 4、表统计信息管理
---
## 📚 目录

1. [统计信息基础概念](#1-统计信息基础概念)
2. [统计信息采集机制](#2-统计信息采集机制)
3. [直方图统计数据详解](#3-直方图统计数据详解)
4. [索引统计信息管理](#4-索引统计信息管理)
5. [统计信息准确性检查](#5-统计信息准确性检查)
6. [统计信息更新策略](#6-统计信息更新策略)
7. [查询计划影响分析](#7-查询计划影响分析)
8. [统计信息运维最佳实践](#8-统计信息运维最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 统计信息基础概念


### 1.1 什么是统计信息


**🔸 核心定义**
```
统计信息：数据库系统收集的关于表和索引数据分布的元数据
作用：帮助查询优化器选择最优的执行计划
位置：存储在数据字典中，不占用表空间
```

**💡 通俗理解**
想象统计信息就像是一本"数据地图册"：
- **人口普查表**：告诉你每个城市有多少人（表有多少行）
- **年龄分布图**：显示各年龄段人数分布（列值分布）
- **道路指南**：哪些路径最快到达目的地（索引效率）

### 1.2 统计信息的核心作用


**🎯 查询优化器决策依据**
```
没有统计信息的查询：
用户查询 → 优化器盲猜 → 可能选择错误执行计划 → 性能差

有统计信息的查询：
用户查询 → 优化器分析统计 → 选择最优执行计划 → 性能好
```

**📈 主要统计类型**
```
📋 基础统计
┌─ 表行数：总记录数量
├─ 列基数：不重复值的数量
├─ 空值率：NULL值所占比例
└─ 平均长度：列数据平均字节数

📊 分布统计
┌─ 直方图：数据分布情况
├─ 最值信息：最大值和最小值
└─ 密度信息：数据密集程度
```

### 1.3 统计信息的重要性


**⚡ 性能影响示例**
```sql
-- 场景：查询年龄在25-30岁的用户
SELECT * FROM users WHERE age BETWEEN 25 AND 30;

无统计信息：
估算结果行数：表总行数 / 6 (盲猜)
实际匹配行数：可能差异巨大
执行计划：可能选择全表扫描

有统计信息：
估算结果行数：基于直方图精确计算
实际匹配行数：误差通常<10%
执行计划：选择最优索引
```

---

## 2. 🔄 统计信息采集机制


### 2.1 自动采集机制


**🤖 数据库自动采集**
```
自动采集触发条件：
├─ 表数据变更达到阈值（通常20%以上）
├─ 新建表或索引后
├─ 大量DML操作后
└─ 系统维护窗口期间

采集频率控制：
├─ 高频更新表：每日采集
├─ 中频更新表：每周采集  
├─ 低频更新表：每月采集
└─ 静态表：按需采集
```

**⚙️ MySQL自动采集配置**
```sql
-- 查看自动统计配置
SHOW VARIABLES LIKE 'innodb_stats%';

-- 关键参数说明
innodb_stats_auto_recalc = ON        -- 启用自动重新计算
innodb_stats_persistent = ON         -- 统计信息持久化
innodb_stats_sample_pages = 20       -- 采样页面数量
```

### 2.2 手动采集控制


**🔧 手动触发统计信息收集**
```sql
-- MySQL手动收集
ANALYZE TABLE table_name;

-- Oracle手动收集
EXEC DBMS_STATS.GATHER_TABLE_STATS(
    ownname => 'SCHEMA_NAME',
    tabname => 'TABLE_NAME',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE
);

-- SQL Server手动收集
UPDATE STATISTICS table_name;
```

**📊 采样策略配置**
```sql
-- 不同采样率的影响
采样率100%：准确性最高，但耗时长
采样率50%：平衡准确性和性能
采样率10%：快速收集，适合大表
采样率自动：让系统决定最优采样率
```

### 2.3 采集性能优化


**⚡ 大表采集优化策略**
```
并行采集：
├─ 多线程同时采集不同分区
├─ 减少单表采集时间
└─ 提高整体效率

分批采集：
├─ 按时间段分批处理
├─ 避免系统资源争抢
└─ 控制对业务的影响

增量采集：
├─ 只采集变更分区的统计
├─ 大幅减少采集时间
└─ 适合分区表管理
```

---

## 3. 📈 直方图统计数据详解


### 3.1 直方图基础概念


**🔸 什么是直方图**
```
直方图：将列值划分为若干个桶(bucket)，记录每个桶的数据分布情况

简单比喻：
就像统计班级成绩分布
┌─────────┬─────────┬─────────┐
│ 0-60分  │ 60-80分 │ 80-100分│
│  5人    │  15人   │   10人  │
└─────────┴─────────┴─────────┘
```

**📊 直方图类型对比**

| 类型 | **适用场景** | **优点** | **缺点** |
|------|------------|---------|----------|
| 🟢 **等高直方图** | `数据分布均匀` | `每个桶数据量相同，便于估算` | `值域范围不固定` |
| 🟡 **等宽直方图** | `数据分布不均` | `值域范围固定，易理解` | `桶内数据量差异大` |
| 🔵 **混合直方图** | `复杂分布数据` | `结合两种优势，更精确` | `实现复杂，占用空间大` |

### 3.2 直方图数据结构


**📋 MySQL直方图示例**
```sql
-- 创建直方图
ANALYZE TABLE users UPDATE HISTOGRAM ON age WITH 10 BUCKETS;

-- 查看直方图信息
SELECT 
    SCHEMA_NAME,
    TABLE_NAME, 
    COLUMN_NAME,
    JSON_EXTRACT(HISTOGRAM, '$.buckets') as buckets
FROM information_schema.COLUMN_STATISTICS 
WHERE TABLE_NAME = 'users';
```

**🗂️ 直方图存储结构**
```json
{
  "buckets": [
    [18, 25, 0.2, 1500],    // [下界, 上界, 累积频率, 样本数]
    [25, 35, 0.6, 2000],
    [35, 50, 0.8, 1000],
    [50, 65, 1.0, 500]
  ],
  "data-type": "int",
  "null-values": 0.05
}
```

### 3.3 直方图在查询优化中的应用


**🎯 选择性估算**
```sql
-- 查询示例
SELECT * FROM users WHERE age BETWEEN 25 AND 35;

-- 基于直方图的估算过程
步骤1️⃣：找到涉及的桶
        桶2: [25, 35] 覆盖范围100%
        
步骤2️⃣：计算选择性
        选择性 = (0.6 - 0.2) = 0.4 = 40%
        
步骤3️⃣：估算结果行数
        预估行数 = 总行数 × 选择性 = 1000万 × 0.4 = 400万行
        
步骤4️⃣：选择执行计划
        400万行 > 全表20% → 选择全表扫描
        400万行 < 全表20% → 选择索引扫描
```

---

## 4. 🔍 索引统计信息管理


### 4.1 索引统计信息类型


**📊 索引统计核心指标**
```
📋 基础指标
┌─ 索引页数：物理存储页面数量
├─ 索引深度：B+树的层级深度
├─ 叶子页数：存储实际数据的页数
└─ 记录密度：每页平均记录数

🎯 效率指标  
┌─ 选择性：唯一值占比
├─ 聚簇因子：数据物理有序程度
├─ 采样行数：统计采样的记录数
└─ 最后分析时间：统计信息更新时间
```

### 4.2 索引选择性分析


**⚡ 选择性计算公式**
```sql
-- 选择性 = 唯一值数量 / 总记录数

-- 查看索引选择性
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    TABLE_ROWS,
    ROUND(CARDINALITY / TABLE_ROWS, 4) as SELECTIVITY
FROM information_schema.STATISTICS s
JOIN information_schema.TABLES t USING(TABLE_SCHEMA, TABLE_NAME)
WHERE TABLE_SCHEMA = 'your_database';
```

**🎯 选择性评估标准**
```
选择性评估：
├─ 选择性 > 0.8  →  🟢 高选择性，索引效果好
├─ 选择性 0.3-0.8 →  🟡 中等选择性，适中效果  
├─ 选择性 < 0.3  →  🔴 低选择性，索引效果差
└─ 选择性 < 0.1  →  ❌ 考虑删除索引

实际示例：
用户ID索引：选择性 ≈ 1.0     (几乎每行唯一)
性别索引：选择性 ≈ 0.5       (男/女两个值)  
状态索引：选择性 ≈ 0.2       (5个状态值)
```

### 4.3 复合索引统计分析


**🔗 复合索引统计特点**
```sql
-- 复合索引：(user_id, status, create_time)
CREATE INDEX idx_user_status_time ON orders(user_id, status, create_time);

-- 各列选择性分析
第1列 user_id：    高选择性，过滤效果好
第2列 status：     低选择性，依赖前列过滤结果  
第3列 create_time：高选择性，用于排序优化

-- 前缀选择性计算
SELECT 
    COUNT(DISTINCT user_id) / COUNT(*) as col1_selectivity,
    COUNT(DISTINCT user_id, status) / COUNT(*) as col1_2_selectivity,
    COUNT(DISTINCT user_id, status, create_time) / COUNT(*) as col1_2_3_selectivity
FROM orders;
```

---

## 5. ✅ 统计信息准确性检查


### 5.1 统计信息过期检测


**⏰ 过期判断标准**
```sql
-- MySQL统计信息检查
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_ROWS,
    UPDATE_TIME,
    DATEDIFF(NOW(), UPDATE_TIME) as DAYS_OLD,
    CASE 
        WHEN DATEDIFF(NOW(), UPDATE_TIME) > 7 THEN '🔴 需要更新'
        WHEN DATEDIFF(NOW(), UPDATE_TIME) > 3 THEN '🟡 建议更新'  
        ELSE '🟢 较新'
    END as STATUS
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA NOT IN ('information_schema', 'mysql', 'performance_schema')
ORDER BY DAYS_OLD DESC;
```

**📊 数据变更率检测**
```sql
-- 检测表数据变更情况
WITH table_changes AS (
    SELECT 
        table_name,
        table_rows as current_rows,
        LAG(table_rows) OVER (PARTITION BY table_name ORDER BY check_time) as previous_rows,
        check_time
    FROM table_stats_history 
)
SELECT 
    table_name,
    current_rows,
    previous_rows,
    ROUND((current_rows - previous_rows) / previous_rows * 100, 2) as change_percent,
    CASE 
        WHEN ABS((current_rows - previous_rows) / previous_rows) > 0.2 THEN '🔴 需要更新统计'
        WHEN ABS((current_rows - previous_rows) / previous_rows) > 0.1 THEN '🟡 建议更新统计'
        ELSE '🟢 统计较准确'
    END as recommendation
FROM table_changes 
WHERE previous_rows IS NOT NULL;
```

### 5.2 统计信息质量评估


**🎯 准确性评估方法**
```sql
-- 实际值 vs 统计值对比
SELECT 
    '实际行数' as metric,
    COUNT(*) as actual_value,
    (SELECT table_rows FROM information_schema.tables 
     WHERE table_name = 'users') as stats_value,
    ROUND(ABS(COUNT(*) - (SELECT table_rows FROM information_schema.tables 
                         WHERE table_name = 'users')) / COUNT(*) * 100, 2) as error_percent
FROM users

UNION ALL

SELECT 
    '唯一值数量' as metric,
    COUNT(DISTINCT user_id) as actual_value,
    (SELECT cardinality FROM information_schema.statistics 
     WHERE table_name = 'users' AND column_name = 'user_id') as stats_value,
    ROUND(ABS(COUNT(DISTINCT user_id) - (SELECT cardinality FROM information_schema.statistics 
                                        WHERE table_name = 'users' AND column_name = 'user_id')) 
              / COUNT(DISTINCT user_id) * 100, 2) as error_percent
FROM users;
```

### 5.3 异常统计信息识别


**⚠️ 常见异常模式**
```
🔴 异常统计信息特征：
├─ 表行数为0但实际有数据
├─ 索引基数远大于表行数  
├─ 空值率为负数或大于100%
├─ 直方图桶数据明显不合理
└─ 统计更新时间过于陈旧

🔧 异常处理策略：
├─ 立即重新收集统计信息
├─ 检查系统配置参数
├─ 验证数据完整性
└─ 记录异常日志便于分析
```

---

## 6. 🔄 统计信息更新策略


### 6.1 更新策略制定


**📅 基于表特征的更新策略**
```
📊 高频更新表（如订单表）：
├─ 更新频率：每天凌晨2点
├─ 触发条件：数据变更>10%
├─ 采样率：20%（平衡准确性和速度）
└─ 监控指标：查询性能和统计准确性

📈 中频更新表（如用户表）：
├─ 更新频率：每周末
├─ 触发条件：数据变更>20%  
├─ 采样率：50%
└─ 监控指标：主要查询的执行计划

📋 低频更新表（如配置表）：
├─ 更新频率：每月
├─ 触发条件：数据变更>30%
├─ 采样率：100%（数据量小）
└─ 监控指标：基础统计准确性
```

### 6.2 自动更新机制配置


**🤖 MySQL自动更新配置**
```sql
-- 配置自动统计更新
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_persistent = ON;
SET GLOBAL innodb_stats_sample_pages = 20;

-- 表级别控制
ALTER TABLE users STATS_AUTO_RECALC = 1;
ALTER TABLE users STATS_SAMPLE_PAGES = 50;
```

**⚙️ 定时任务脚本示例**
```bash
#!/bin/bash
# 统计信息定时更新脚本

# 检查需要更新的表
mysql -u$USER -p$PASS -e "
SELECT CONCAT('ANALYZE TABLE ', table_schema, '.', table_name, ';') as sql_cmd
FROM information_schema.tables t
WHERE table_schema = 'your_database'
  AND (
    table_rows = 0 OR 
    update_time < DATE_SUB(NOW(), INTERVAL 7 DAY) OR
    -- 添加其他更新条件
  )
" | grep -v sql_cmd > /tmp/analyze_tables.sql

# 执行统计信息更新
if [ -s /tmp/analyze_tables.sql ]; then
    echo "更新统计信息开始: $(date)"
    mysql -u$USER -p$PASS < /tmp/analyze_tables.sql
    echo "更新统计信息完成: $(date)"
fi
```

### 6.3 更新性能优化


**⚡ 批量更新优化技巧**
```sql
-- 并行更新多个表（注意资源控制）
-- 终端1
ANALYZE TABLE table1, table2, table3;

-- 终端2  
ANALYZE TABLE table4, table5, table6;

-- 分时段更新大表
-- 00:00-02:00 更新核心业务表
-- 02:00-04:00 更新辅助表
-- 04:00-06:00 更新历史数据表
```

---

## 7. 📊 查询计划影响分析


### 7.1 执行计划分析基础


**🔍 执行计划关键信息**
```sql
-- 查看执行计划
EXPLAIN FORMAT=JSON 
SELECT * FROM users u
JOIN orders o ON u.user_id = o.user_id  
WHERE u.age BETWEEN 25 AND 35
  AND o.status = 'completed';
```

**📈 统计信息对执行计划的影响**
```
影响因素分析：
┌─ 行数估算：决定是否使用索引
├─ 选择性评估：影响多表JOIN顺序
├─ 数据分布：影响分区裁剪策略
└─ 成本计算：决定最优访问路径

执行计划变化示例：
统计信息过期前：使用索引，耗时100ms
统计信息过期后：全表扫描，耗时5000ms
重新收集后：恢复索引，耗时80ms
```

### 7.2 查询成本估算


**💰 成本模型组成**
```
查询成本 = IO成本 + CPU成本 + 网络成本

🔸 IO成本计算：
  = 页面读取数 × 页面IO代价
  = (表页数 × 选择性) × IO_COST_FACTOR

🔸 CPU成本计算：  
  = 处理行数 × CPU代价
  = (表行数 × 选择性) × CPU_COST_FACTOR

🔸 网络成本：
  = 结果集大小 × 网络传输代价
```

**📊 成本估算示例**
```sql
-- 查看查询成本估算
EXPLAIN FORMAT=JSON
SELECT * FROM users WHERE age = 25;

/*
估算过程：
1. 基于统计信息估算：age=25的行数约1000行
2. IO成本：需要读取的页面数 × IO代价
3. CPU成本：需要处理的行数 × CPU代价  
4. 总成本：IO成本 + CPU成本
5. 与其他执行路径对比，选择成本最低的
*/
```

### 7.3 多表JOIN优化


**🔗 JOIN顺序优化**
```sql
-- 三表JOIN示例
SELECT u.name, o.order_no, p.product_name
FROM users u
JOIN orders o ON u.user_id = o.user_id
JOIN order_products p ON o.order_id = p.order_id
WHERE u.city = 'Beijing' 
  AND o.status = 'completed';

-- JOIN顺序选择依据统计信息：
-- 1. 先过滤选择性高的表
-- 2. 小表驱动大表
-- 3. 考虑索引可用性
```

**📊 JOIN顺序成本对比**
```
方案A: users → orders → order_products
├─ 第1步：过滤users，预估1万行
├─ 第2步：JOIN orders，预估5万行  
├─ 第3步：JOIN products，预估10万行
└─ 总成本：较高

方案B: orders → users → order_products  
├─ 第1步：过滤orders，预估2万行
├─ 第2步：JOIN users，预估2万行
├─ 第3步：JOIN products，预估4万行
└─ 总成本：较低 ✅
```

---

## 8. 🛠️ 统计信息运维最佳实践


### 8.1 监控与告警体系


**📊 关键监控指标**
```sql
-- 统计信息健康度监控视图
CREATE VIEW v_stats_health AS
SELECT 
    table_schema,
    table_name,
    table_rows,
    update_time,
    DATEDIFF(NOW(), update_time) as days_old,
    -- 健康度评分
    CASE 
        WHEN DATEDIFF(NOW(), update_time) <= 1 THEN 100
        WHEN DATEDIFF(NOW(), update_time) <= 3 THEN 80  
        WHEN DATEDIFF(NOW(), update_time) <= 7 THEN 60
        WHEN DATEDIFF(NOW(), update_time) <= 30 THEN 40
        ELSE 20
    END as health_score
FROM information_schema.tables
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema');
```

**🚨 告警规则设置**
```
🔴 紧急告警（立即处理）：
├─ 核心表统计信息超过7天未更新
├─ 统计信息与实际差异超过50%
├─ 关键查询执行计划突然变差
└─ 统计信息收集失败

🟡 警告告警（24小时内处理）：
├─ 普通表统计信息超过14天未更新  
├─ 统计信息与实际差异超过20%
├─ 索引选择性明显下降
└─ 统计信息收集耗时异常增长
```

### 8.2 备份与恢复策略


**💾 统计信息备份**
```sql
-- MySQL统计信息备份
-- 1. 备份表统计信息
SELECT * FROM information_schema.tables 
WHERE table_schema = 'your_database'
INTO OUTFILE '/backup/table_stats.csv';

-- 2. 备份索引统计信息
SELECT * FROM information_schema.statistics 
WHERE table_schema = 'your_database'
INTO OUTFILE '/backup/index_stats.csv';

-- 3. 备份直方图信息
SELECT * FROM information_schema.column_statistics 
WHERE schema_name = 'your_database'
INTO OUTFILE '/backup/histogram_stats.csv';
```

**🔄 统计信息恢复**
```sql
-- 恢复流程
-- 1. 禁用自动统计更新
SET GLOBAL innodb_stats_auto_recalc = OFF;

-- 2. 删除现有统计信息
DELETE FROM mysql.innodb_table_stats WHERE database_name = 'your_database';
DELETE FROM mysql.innodb_index_stats WHERE database_name = 'your_database';

-- 3. 导入备份的统计信息
LOAD DATA INFILE '/backup/table_stats.csv' 
INTO TABLE mysql.innodb_table_stats;

-- 4. 重启服务或刷新统计
FLUSH TABLES;
```

### 8.3 性能优化建议


**🚀 统计信息性能优化清单**

```
📋 日常维护检查项：
✅ 检查统计信息更新时间
✅ 验证关键表的统计准确性  
✅ 监控查询执行计划变化
✅ 评估索引选择性变化
✅ 检查直方图数据质量

🔧 优化配置调整：
✅ 根据表特征调整采样率
✅ 优化统计信息更新频率
✅ 配置合适的直方图桶数
✅ 设置表级别统计参数
✅ 监控统计收集性能
```

**⚡ 大表统计优化策略**
```sql
-- 分区表统计优化
-- 1. 只更新变化的分区
ALTER TABLE large_table_2023 ANALYZE PARTITION p202312;

-- 2. 并行收集统计信息
-- 通过多个会话同时收集不同分区

-- 3. 增量统计收集
-- 只收集新增或修改分区的统计
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 统计信息本质：数据库的"地图册"，指导查询优化器选择最优路径
🔸 采集机制：自动+手动双重保障，平衡准确性和性能开销
🔸 直方图作用：精确描述数据分布，提高选择性估算准确度
🔸 更新策略：基于表特征制定差异化更新频率和采样率
🔸 质量管控：持续监控统计准确性，及时发现和修复异常
```

### 9.2 关键理解要点


**🔹 统计信息的生命周期**
```
收集阶段：根据表特征选择合适的采集策略
使用阶段：查询优化器基于统计信息生成执行计划  
维护阶段：监控准确性，定期更新保持时效性
优化阶段：分析性能瓶颈，调整统计信息配置
```

**🔹 准确性与性能的平衡**
```
高采样率：统计更准确，但收集时间长
低采样率：收集速度快，但可能不够准确
自动采样：让系统自动选择最优平衡点

最佳实践：根据表重要性和更新频率差异化配置
```

**🔹 统计信息对查询性能的影响**
```
准确统计 → 正确的执行计划 → 查询性能好
过期统计 → 错误的执行计划 → 查询性能差
无统计信息 → 盲目估算 → 性能不可预测
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **电商系统**：订单表统计信息影响促销活动查询性能
- **金融系统**：交易表统计准确性关系到风控查询效率  
- **内容平台**：用户行为表统计影响推荐算法查询速度
- **IoT平台**：设备数据表统计影响实时监控查询性能

**🔧 运维实践指导**
- **监控体系**：建立统计信息健康度监控和告警机制
- **更新策略**：制定基于业务特征的差异化更新策略
- **性能调优**：通过统计信息优化解决查询性能问题
- **容量规划**：基于统计信息趋势预测存储和性能需求

**核心记忆口诀**：
- 统计信息是优化器的眼睛，准确及时是关键
- 采集策略要因表制宜，平衡准确性和性能
- 监控告警不可少，异常发现要趁早
- 备份恢复要规范，关键时刻能救急