---
title: 6、性能分析工具
---
## 📚 目录

1. [性能分析工具概述](#1-性能分析工具概述)
2. [Performance Schema运维实战](#2-performance-schema运维实战)
3. [sys Schema运维应用](#3-sys-schema运维应用)
4. [INFORMATION_SCHEMA运维查询](#4-information-schema运维查询)
5. [MySQL Explain运维解读](#5-mysql-explain运维解读)
6. [MySQL Profile运维分析](#6-mysql-profile运维分析)
7. [性能分析实战流程](#7-性能分析实战流程)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 性能分析工具概述


### 1.1 什么是MySQL性能分析工具


**通俗理解**：MySQL性能分析工具就像医院的体检设备，帮助我们"诊断"数据库的健康状况

```
就像体检一样：
体检设备 → 发现身体问题 → 制定治疗方案
性能工具 → 发现性能问题 → 制定优化方案
```

**核心作用**：
- 🔍 **发现问题**：找出性能瓶颈在哪里
- 📊 **量化分析**：用数据说话，不凭感觉
- 🎯 **定位原因**：找到慢的具体原因
- 📈 **监控趋势**：观察性能变化趋势

### 1.2 MySQL内置性能分析工具体系


```
MySQL性能分析工具家族：
┌─────────────────────────────────────┐
│            MySQL Server             │
├─────────────────────────────────────┤
│  Performance Schema  ← 🔥最强大工具  │
├─────────────────────────────────────┤
│  sys Schema         ← 🔥简化查询    │ 
├─────────────────────────────────────┤
│  INFORMATION_SCHEMA ← 🔥基础信息    │
├─────────────────────────────────────┤
│  EXPLAIN           ← 🔥执行计划     │
├─────────────────────────────────────┤
│  Profile           ← 🔥详细分析     │
└─────────────────────────────────────┘
```

### 1.3 性能分析的基本思路


**分析流程**：
```
1️⃣ 发现慢查询 → 找到有问题的SQL
2️⃣ 分析执行计划 → 看SQL怎么执行的  
3️⃣ 检查资源使用 → 看哪里成了瓶颈
4️⃣ 定位根本原因 → 找到真正的问题
5️⃣ 制定优化方案 → 决定如何解决
6️⃣ 验证优化效果 → 确认问题解决
```

---

## 2. 🔥 Performance Schema运维实战


### 2.1 Performance Schema是什么


**简单理解**：Performance Schema就像MySQL的"黑匣子"，记录了数据库运行时的所有细节

```
类比：飞机黑匣子
┌─────────────────┐     ┌──────────────────────┐
│    飞机黑匣子    │ ≈   │  Performance Schema  │
├─────────────────┤     ├──────────────────────┤
│ 记录飞行数据     │     │ 记录SQL执行数据      │ 
│ 记录操作细节     │     │ 记录锁等待情况       │
│ 帮助事故分析     │     │ 帮助性能问题分析     │
└─────────────────┘     └──────────────────────┘
```

**核心特点**：
- 📊 **实时监控**：运行时实时收集性能数据
- 🎯 **细粒度**：可以精确到每个SQL语句
- 📈 **全面覆盖**：涵盖CPU、内存、IO、锁等
- ⚡ **低开销**：对数据库性能影响很小

### 2.2 Performance Schema基础配置


**开启Performance Schema**：
```sql
-- 查看是否开启
SHOW VARIABLES LIKE 'performance_schema';

-- 配置文件开启（需要重启）
[mysqld]
performance_schema = ON
```

**重要配置项**：
```sql
-- 查看关键配置
SELECT * FROM performance_schema.setup_actors;      -- 监控用户
SELECT * FROM performance_schema.setup_objects;     -- 监控对象  
SELECT * FROM performance_schema.setup_instruments; -- 监控工具
SELECT * FROM performance_schema.setup_consumers;   -- 数据消费者
```

### 2.3 核心监控表详解


**🔸 语句执行监控表**

```sql
-- events_statements_summary_by_digest：SQL语句执行统计
SELECT 
    SCHEMA_NAME AS 数据库,
    DIGEST_TEXT AS SQL语句,
    COUNT_STAR AS 执行次数,
    AVG_TIMER_WAIT/1000000000 AS 平均执行时间秒,
    SUM_TIMER_WAIT/1000000000 AS 总执行时间秒,
    SUM_LOCK_TIME/1000000000 AS 总锁等待时间秒,
    SUM_ROWS_EXAMINED AS 总扫描行数,
    SUM_ROWS_SENT AS 总返回行数
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC LIMIT 10;
```

**🔸 等待事件监控表**

```sql
-- events_waits_summary_global_by_event_name：等待事件统计
SELECT 
    EVENT_NAME AS 等待事件,
    COUNT_STAR AS 等待次数,
    SUM_TIMER_WAIT/1000000000 AS 总等待时间秒,
    AVG_TIMER_WAIT/1000000000 AS 平均等待时间秒
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE COUNT_STAR > 0 
ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
```

### 2.4 实际运维场景应用


**场景1：找出最慢的SQL**
```sql
-- 查找平均执行时间最长的SQL
SELECT 
    LEFT(DIGEST_TEXT, 50) AS SQL片段,
    COUNT_STAR AS 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000, 3) AS 平均耗时秒,
    ROUND(SUM_TIMER_WAIT/1000000000, 3) AS 总耗时秒
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME = 'your_database'
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 5;
```

**场景2：分析表访问热度**
```sql
-- 查看哪些表被访问最频繁
SELECT 
    OBJECT_SCHEMA AS 数据库名,
    OBJECT_NAME AS 表名,
    COUNT_STAR AS 访问次数,
    SUM_TIMER_WAIT/1000000000 AS 总耗时秒
FROM performance_schema.table_io_waits_summary_by_table 
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_STAR DESC 
LIMIT 10;
```

---

## 3. 🔥 sys Schema运维应用


### 3.1 sys Schema的作用


**通俗理解**：如果Performance Schema是原始数据，那么sys Schema就是"翻译器"，把复杂的数据变成人能看懂的报告

```
Performance Schema     →     sys Schema
    (原始数据)              (人性化视图)
        
复杂的监控表            →    简单易懂的报告
需要复杂SQL查询         →    开箱即用的视图  
技术人员才能看懂        →    运维人员都能用
```

**核心优势**：
- 🎯 **开箱即用**：预定义好的查询视图
- 📊 **人性化**：结果直观易懂
- ⚡ **高效**：经过优化的查询逻辑
- 🔧 **实用**：针对常见运维场景

### 3.2 sys Schema核心视图


**🔸 语句分析视图**

```sql
-- statement_analysis：SQL语句分析
SELECT 
    query AS SQL语句,
    exec_count AS 执行次数,
    avg_latency AS 平均延迟,
    max_latency AS 最大延迟,
    total_latency AS 总延迟,
    rows_examined_avg AS 平均扫描行数
FROM sys.statement_analysis 
ORDER BY total_latency DESC 
LIMIT 10;
```

**🔸 用户统计视图**

```sql
-- user_summary：用户活动统计
SELECT 
    user AS 用户名,
    statements AS 语句数,
    statement_avg_latency AS 平均延迟,
    table_scans AS 全表扫描次数,
    file_ios AS 文件IO次数,
    current_connections AS 当前连接数
FROM sys.user_summary 
ORDER BY statement_avg_latency DESC;
```

### 3.3 实用运维查询


**🔧 找出最耗资源的SQL**
```sql
-- 查看TOP耗时SQL
SELECT 
    LEFT(query, 60) AS SQL片段,
    exec_count AS 执行次数,
    avg_latency AS 平均耗时,
    total_latency AS 总耗时
FROM sys.statement_analysis 
WHERE query NOT LIKE '%performance_schema%'
    AND query NOT LIKE '%sys.%'
ORDER BY total_latency DESC 
LIMIT 5;
```

**🔧 分析表使用情况**
```sql
-- 查看表IO统计
SELECT 
    table_schema AS 数据库,
    table_name AS 表名,
    rows_fetched AS 读取行数,
    rows_inserted AS 插入行数,
    rows_updated AS 更新行数,
    rows_deleted AS 删除行数,
    io_read AS 读IO,
    io_write AS 写IO
FROM sys.schema_table_statistics 
WHERE table_schema = 'your_database'
ORDER BY io_read + io_write DESC 
LIMIT 10;
```

---

## 4. 🔥 INFORMATION_SCHEMA运维查询


### 4.1 INFORMATION_SCHEMA作用


**简单理解**：INFORMATION_SCHEMA是MySQL的"户口本"，记录了数据库的基本信息

```
现实生活                MySQL数据库
┌─────────────┐        ┌─────────────────┐
│    户口本    │   ≈    │ INFORMATION_    │
├─────────────┤        │    SCHEMA       │
│ 人员基本信息 │        │ 表结构基本信息   │
│ 家庭关系     │        │ 字段关系        │  
│ 住址信息     │        │ 索引信息        │
└─────────────┘        └─────────────────┘
```

**主要用途**：
- 📋 **查看表结构**：字段、类型、索引等
- 🔍 **检查约束**：主键、外键、唯一约束
- 📊 **统计信息**：表大小、行数等
- 🔧 **元数据查询**：数据库基础信息

### 4.2 常用运维查询


**🔸 表大小统计**
```sql
-- 查看数据库中各表的大小
SELECT 
    TABLE_SCHEMA AS 数据库名,
    TABLE_NAME AS 表名,
    ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS 表大小MB,
    TABLE_ROWS AS 估计行数,
    ROUND((DATA_LENGTH / 1024 / 1024), 2) AS 数据大小MB,
    ROUND((INDEX_LENGTH / 1024 / 1024), 2) AS 索引大小MB
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
    AND TABLE_TYPE = 'BASE TABLE'
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;
```

**🔸 索引使用情况**
```sql
-- 查看表的索引信息
SELECT 
    TABLE_NAME AS 表名,
    INDEX_NAME AS 索引名,
    COLUMN_NAME AS 列名,
    SEQ_IN_INDEX AS 列位置,
    CARDINALITY AS 唯一值数量,
    INDEX_TYPE AS 索引类型
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;
```

**🔸 字段类型检查**
```sql
-- 检查字段类型和属性
SELECT 
    TABLE_NAME AS 表名,
    COLUMN_NAME AS 字段名,
    DATA_TYPE AS 数据类型,
    IS_NULLABLE AS 是否允许NULL,
    COLUMN_DEFAULT AS 默认值,
    EXTRA AS 额外属性
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'your_database'
    AND TABLE_NAME = 'your_table'
ORDER BY ORDINAL_POSITION;
```

---

## 5. 🔥 MySQL Explain运维解读


### 5.1 Explain是什么


**通俗理解**：EXPLAIN就像GPS导航，告诉你SQL语句会"走什么路线"到达目标

```
开车导航                SQL执行计划
┌─────────────┐        ┌─────────────────┐
│ 从A到B的路线 │   ≈    │ 从查询到结果     │
├─────────────┤        ├─────────────────┤
│ 走哪些路     │        │ 使用哪些表      │
│ 用时多长     │        │ 使用哪些索引    │
│ 堵车情况     │        │ 扫描多少行      │
│ 最优路径     │        │ 连接方式        │
└─────────────┘        └─────────────────┘
```

### 5.2 Explain输出字段详解


**基本用法**：
```sql
EXPLAIN SELECT * FROM users WHERE age > 25;
```

**🔸 关键字段含义**

| 字段 | 含义 | 重要程度 | 关注点 |
|------|------|----------|--------|
| **id** | 执行顺序 | ⭐⭐⭐ | 数字越大越先执行 |
| **select_type** | 查询类型 | ⭐⭐ | SIMPLE最好 |
| **table** | 访问的表 | ⭐⭐⭐ | 具体操作哪张表 |
| **type** | 连接类型 | 🔥🔥🔥 | 性能关键指标 |
| **key** | 使用的索引 | 🔥🔥🔥 | NULL说明没用索引 |
| **rows** | 扫描行数 | 🔥🔥🔥 | 越少越好 |
| **Extra** | 额外信息 | ⭐⭐⭐ | 优化提示 |

### 5.3 type字段性能分析


**type性能排序**（从好到坏）：
```
性能优秀 → 性能较差
const → eq_ref → ref → range → index → ALL

🟢 const：主键或唯一索引查询，最快
🟢 eq_ref：主键或唯一索引连接，很快  
🟡 ref：非唯一索引查询，较快
🟡 range：范围查询，一般
🔴 index：索引全扫描，慢
🔴 ALL：全表扫描，最慢
```

**实际案例分析**：
```sql
-- 示例1：性能很好的查询
EXPLAIN SELECT * FROM users WHERE id = 123;
-- type: const (通过主键直接定位)

-- 示例2：性能一般的查询  
EXPLAIN SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- type: range (范围查询)

-- 示例3：性能很差的查询
EXPLAIN SELECT * FROM users WHERE name LIKE '%john%';
-- type: ALL (全表扫描)
```

### 5.4 实际优化案例


**案例1：发现缺失索引**
```sql
-- 慢查询
EXPLAIN SELECT * FROM orders WHERE customer_id = 100;

-- 结果分析
+----+-------+--------+------+--------+------+-------+
| id | table | type   | key  | rows   | Extra          |
+----+-------+--------+------+--------+------+-------+
| 1  | orders| ALL    | NULL | 50000  | Using where    |
+----+-------+--------+------+--------+------+-------+

-- 问题：type=ALL，key=NULL，说明没有使用索引
-- 解决：添加索引
CREATE INDEX idx_customer_id ON orders(customer_id);
```

**案例2：优化连接查询**
```sql
-- 慢查询
EXPLAIN SELECT u.name, o.total 
FROM users u JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active';

-- 优化建议：
-- 1. 确保连接字段有索引
-- 2. 过滤条件字段添加索引
-- 3. 调整连接顺序
```

---

## 6. 🔥 MySQL Profile运维分析


### 6.1 Profile是什么


**通俗理解**：Profile就像体检的详细检查报告，告诉你SQL执行时每个环节花了多少时间

```
体检报告                Profile分析
┌─────────────┐        ┌─────────────────┐
│ 血常规: 5分钟│   ≈    │ 解析SQL: 0.01秒  │
│ 心电图: 3分钟│        │ 执行查询: 2.5秒  │
│ B超: 10分钟  │        │ 发送结果: 0.1秒  │
│ 总计: 18分钟 │        │ 总计: 2.61秒     │
└─────────────┘        └─────────────────┘
```

### 6.2 Profile基本使用


**开启Profile**：
```sql
-- 开启profiling
SET profiling = 1;

-- 执行要分析的SQL
SELECT * FROM users WHERE age > 25;

-- 查看profile列表
SHOW PROFILES;

-- 查看具体分析结果
SHOW PROFILE FOR QUERY 1;
```

**Profile输出示例**：
```sql
SHOW PROFILE FOR QUERY 1;

+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000087 |
| checking permissions | 0.000009 |
| Opening tables       | 0.000027 |
| init                 | 0.000034 |
| System lock          | 0.000012 |
| optimizing           | 0.000008 |
| statistics           | 0.000019 |
| preparing            | 0.000011 |
| executing            | 0.000004 |
| Sending data         | 0.002156 |  ← 🔥主要耗时
| end                  | 0.000006 |
| query end            | 0.000007 |
| closing tables       | 0.000008 |
| freeing items        | 0.000015 |
| cleaning up          | 0.000001 |
+----------------------+----------+
```

### 6.3 Profile详细分析


**🔸 各阶段含义解释**

| 阶段 | 含义 | 优化关注点 |
|------|------|-----------|
| **starting** | 启动阶段 | 一般很快，无需关注 |
| **checking permissions** | 权限检查 | 权限表过大时会慢 |
| **Opening tables** | 打开表 | 表太多时会慢 |
| **optimizing** | 查询优化 | 复杂查询会慢 |
| **statistics** | 统计信息 | 统计信息过期会慢 |
| **preparing** | 准备执行 | 一般很快 |
| **executing** | 开始执行 | 主要执行时间 |
| **Sending data** | 发送数据 | 🔥通常是主要瓶颈 |

**🔸 重点关注的阶段**

1. **Sending data阶段过长**：
   ```sql
   -- 可能原因：
   -- 1. 返回数据量太大
   -- 2. 没有使用合适索引  
   -- 3. 网络传输慢
   
   -- 解决方案：
   -- 1. 限制返回结果集大小
   -- 2. 添加合适索引
   -- 3. 检查网络连接
   ```

2. **statistics阶段过长**：
   ```sql
   -- 可能原因：统计信息过期
   -- 解决方案：更新统计信息
   ANALYZE TABLE your_table;
   ```

### 6.4 Profile实际运维案例


**案例：分析慢查询**
```sql
-- 1. 开启profile
SET profiling = 1;

-- 2. 执行慢查询
SELECT u.name, COUNT(o.id) as order_count
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.create_time > '2024-01-01'
GROUP BY u.id;

-- 3. 查看执行时间分布
SHOW PROFILE FOR QUERY 1;

-- 4. 详细分析CPU使用
SHOW PROFILE CPU FOR QUERY 1;

-- 5. 分析IO情况  
SHOW PROFILE BLOCK IO FOR QUERY 1;
```

---

## 7. 📊 性能分析实战流程


### 7.1 完整分析流程


```
性能问题分析流程：
1️⃣ 问题发现 → 监控告警或用户反馈慢
2️⃣ 初步定位 → 使用sys schema快速定位
3️⃣ 详细分析 → 使用explain分析执行计划  
4️⃣ 深入诊断 → 使用profile分析详细耗时
5️⃣ 制定方案 → 基于分析结果制定优化方案
6️⃣ 实施优化 → 执行优化措施
7️⃣ 效果验证 → 对比优化前后性能
```

### 7.2 实战案例：完整分析过程


**步骤1：问题发现**
```sql
-- 通过sys schema发现慢查询
SELECT 
    LEFT(query, 80) AS SQL语句,
    exec_count AS 执行次数,
    avg_latency AS 平均耗时
FROM sys.statement_analysis 
WHERE avg_latency > '00:00:01.000'  -- 超过1秒的查询
ORDER BY avg_latency DESC 
LIMIT 5;
```

**步骤2：执行计划分析**
```sql
-- 分析具体SQL的执行计划
EXPLAIN SELECT u.name, u.email, p.title 
FROM users u 
JOIN posts p ON u.id = p.author_id 
WHERE u.status = 'active' 
  AND p.created_at > '2024-01-01';
```

**步骤3：详细性能分析**
```sql
-- 使用profile详细分析
SET profiling = 1;
-- 执行目标SQL
SHOW PROFILE FOR QUERY 1;
```

**步骤4：制定优化方案**
```sql
-- 根据分析结果，可能的优化：
-- 1. 添加复合索引
CREATE INDEX idx_user_status ON users(status);
CREATE INDEX idx_post_author_date ON posts(author_id, created_at);

-- 2. 重写SQL（如果需要）
-- 3. 调整配置参数
```

### 7.3 性能基线建立


**建立性能基线的重要性**：
- 📊 **对比标准**：有了基线才能判断性能好坏
- 📈 **趋势分析**：观察性能变化趋势
- 🎯 **目标设定**：制定合理的性能目标
- ⚠️ **预警机制**：及时发现性能下降

**基线数据收集**：
```sql
-- 收集关键性能指标
SELECT 
    ROUND(AVG(avg_latency_ms), 2) AS 平均响应时间ms,
    ROUND(MAX(avg_latency_ms), 2) AS 最大响应时间ms,
    SUM(exec_count) AS 总执行次数,
    COUNT(*) AS SQL语句数量
FROM (
    SELECT 
        exec_count,
        avg_latency/1000000 AS avg_latency_ms
    FROM sys.statement_analysis
    WHERE query NOT LIKE '%performance_schema%'
) t;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心工具


```
🔥 Performance Schema：最强大的性能监控工具
  - 实时收集详细性能数据
  - 可以精确定位性能瓶颈
  - 覆盖SQL、锁、IO等各个方面

🔥 sys Schema：人性化的性能分析视图  
  - 预定义的实用查询视图
  - 开箱即用，结果直观
  - 适合日常运维监控

🔥 INFORMATION_SCHEMA：数据库元数据查询
  - 查看表结构和基本信息
  - 分析表大小和索引情况
  - 检查约束和关系

🔥 EXPLAIN：SQL执行计划分析
  - 查看SQL执行路径
  - 发现索引使用问题
  - 优化查询性能

🔥 Profile：SQL详细执行分析
  - 分析SQL各阶段耗时
  - 定位具体性能瓶颈
  - 深度性能诊断
```

### 8.2 关键理解要点


**🔹 工具选择原则**
```
日常监控 → sys Schema（简单快速）
深度分析 → Performance Schema（详细全面）
执行计划 → EXPLAIN（SQL优化）
详细诊断 → Profile（精确定位）
基础信息 → INFORMATION_SCHEMA（元数据）
```

**🔹 性能分析思路**
```
从宏观到微观：
系统整体性能 → 具体慢查询 → SQL执行计划 → 详细执行阶段
```

**🔹 常见性能瓶颈**
```
1. 缺少合适索引 → 使用EXPLAIN发现
2. 返回数据过多 → 通过Profile的Sending data阶段发现  
3. 锁等待时间长 → 通过Performance Schema监控
4. 统计信息过期 → 通过Profile的statistics阶段发现
```

### 8.3 实际运维建议


**🔧 日常监控关注点**
- ✅ 定期检查sys.statement_analysis找出慢SQL
- ✅ 监控表大小增长趋势  
- ✅ 关注索引使用情况
- ✅ 建立性能基线对比

**⚠️ 性能优化注意事项**
- ✅ 优化前先建立基线
- ✅ 一次只改一个地方
- ✅ 充分测试后再上线
- ✅ 保留回滚方案

**🎯 工具使用最佳实践**
- Performance Schema：适合自动化监控脚本
- sys Schema：适合人工快速分析
- EXPLAIN：每个慢SQL都要分析
- Profile：深度问题分析时使用

**核心记忆**：
- 性能分析有章法，工具配合效果佳
- 宏观监控看全局，微观分析找根因
- 基线对比知好坏，持续优化是关键