---
title: 6、集群监控与告警系统
---
## 📚 目录

1. [集群监控系统概述](#1-集群监控系统概述)
2. [集群状态监控](#2-集群状态监控)
3. [性能指标监控](#3-性能指标监控)
4. [复制延迟监控](#4-复制延迟监控)
5. [节点健康检查](#5-节点健康检查)
6. [告警规则配置](#6-告警规则配置)
7. [监控数据采集](#7-监控数据采集)
8. [可视化监控界面](#8-可视化监控界面)
9. [自动化巡检](#9-自动化巡检)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 集群监控系统概述


### 1.1 什么是InnoDB-Cluster监控


**通俗理解**：集群监控就像是给你的数据库集群装了一套"健康管家"系统，时刻关注着每个数据库节点的运行状况，一旦发现问题立即通知你。

```
简单比喻：
医院的监护仪 = InnoDB-Cluster监控系统
病人的生命体征 = 数据库集群的各项指标
医生护士 = 数据库管理员
报警声 = 告警通知
```

### 1.2 为什么需要集群监控


**核心作用**：
- 🔸 **及时发现问题**：在故障影响业务前就发现异常
- 🔸 **保障高可用**：确保集群始终处于健康状态
- 🔸 **性能优化**：通过监控数据发现性能瓶颈
- 🔸 **预防性维护**：根据趋势预测可能的问题

### 1.3 监控架构全景图


```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Primary节点   │    │  Secondary节点  │    │  Secondary节点  │
│   192.168.1.10  │    │   192.168.1.11  │    │   192.168.1.12  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   监控采集器    │ ← 收集各节点数据
                    │   (Agent)       │
                    └─────────────────┘
                                 │
                    ┌─────────────────┐
                    │   监控中心      │ ← 数据处理和分析
                    │   (Server)      │
                    └─────────────────┘
                                 │
                    ┌─────────────────┐
                    │   告警系统      │ ← 异常通知
                    │   (Alert)       │
                    └─────────────────┘
```

---

## 2. 📊 集群状态监控


### 2.1 集群整体状态检查


**核心概念**：集群状态监控就是查看整个集群是否正常工作，就像看一个团队是否配合默契。

**主要监控内容**：
- ✅ **集群拓扑**：检查主从关系是否正确
- ✅ **节点数量**：确认所有节点都在线
- ✅ **角色分配**：Primary和Secondary角色是否正确
- ✅ **通信状态**：节点间网络连接是否正常

### 2.2 使用MySQL Shell检查集群状态


```sql
-- 连接到集群
\connect root@192.168.1.10:3306

-- 获取集群对象
var cluster = dba.getCluster()

-- 查看集群状态（最重要的命令）
cluster.status()
```

**输出结果解读**：
```json
{
    "clusterName": "myCluster",
    "defaultReplicaSet": {
        "name": "default",
        "primary": "192.168.1.10:3306",
        "ssl": "REQUIRED",
        "status": "OK",               // ← 这个最重要，OK表示正常
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.",
        "topology": {
            "192.168.1.10:3306": {
                "address": "192.168.1.10:3306",
                "mode": "R/W",        // ← 读写模式，这是Primary
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"    // ← 节点在线状态
            },
            "192.168.1.11:3306": {
                "address": "192.168.1.11:3306", 
                "mode": "R/O",        // ← 只读模式，这是Secondary
                "readReplicas": {},
                "role": "HA", 
                "status": "ONLINE"
            }
        }
    }
}
```

### 2.3 关键状态指标说明


| 状态值 | 含义 | 说明 | 处理建议 |
|--------|------|------|----------|
| **ONLINE** | `在线正常` | 节点工作正常，可以处理请求 | ✅ 无需处理 |
| **OFFLINE** | `离线状态` | 节点无法连接或已停止 | ❌ 立即检查节点 |
| **RECOVERING** | `恢复中` | 节点正在同步数据 | ⚠️ 等待恢复完成 |
| **ERROR** | `错误状态` | 节点出现严重错误 | 🔥 紧急处理 |
| **MISSING** | `节点丢失` | 节点从集群中消失 | 🚨 立即排查 |

---

## 3. ⚡ 性能指标监控


### 3.1 什么是性能指标监控


**通俗解释**：性能监控就像汽车的仪表盘，告诉你引擎转速、油耗、温度等信息，帮你了解数据库运行是否顺畅。

### 3.2 核心性能指标


**🔸 QPS (每秒查询数)**
```sql
-- 查看当前QPS
SHOW GLOBAL STATUS LIKE 'Questions';
SHOW GLOBAL STATUS LIKE 'Uptime';

-- 计算QPS：Questions / Uptime
```

**🔸 TPS (每秒事务数)**
```sql
-- 查看事务相关指标
SHOW GLOBAL STATUS LIKE 'Com_commit';
SHOW GLOBAL STATUS LIKE 'Com_rollback';
```

**🔸 连接数监控**
```sql
-- 当前连接数
SHOW GLOBAL STATUS LIKE 'Threads_connected';

-- 最大连接数
SHOW VARIABLES LIKE 'max_connections';

-- 连接使用率 = Threads_connected / max_connections * 100%
```

### 3.3 内存使用监控


```sql
-- InnoDB缓冲池使用情况
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool%';

-- 关键指标解读
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_total' 
        THEN '总页数'
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_data' 
        THEN '数据页数'
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_free' 
        THEN '空闲页数'
    END AS 说明
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN (
    'Innodb_buffer_pool_pages_total',
    'Innodb_buffer_pool_pages_data', 
    'Innodb_buffer_pool_pages_free'
);
```

### 3.4 监控指标阈值设置


| 指标类型 | 正常范围 | 告警阈值 | 危险阈值 |
|----------|----------|----------|----------|
| **CPU使用率** | `< 70%` | `> 80%` | `> 90%` |
| **内存使用率** | `< 80%` | `> 85%` | `> 95%` |
| **磁盘使用率** | `< 80%` | `> 85%` | `> 90%` |
| **连接使用率** | `< 70%` | `> 80%` | `> 90%` |
| **缓冲池命中率** | `> 95%` | `< 90%` | `< 85%` |

---

## 4. 🔄 复制延迟监控


### 4.1 什么是复制延迟


**通俗理解**：复制延迟就像信息传递的"时间差"。主节点执行了一个操作，从节点需要一定时间才能同步到这个操作，这个时间差就是复制延迟。

```
现实比喻：
老师在黑板写字（主节点写入数据）
↓
学生抄写笔记（从节点复制数据）
↓
抄写完成的时间差 = 复制延迟
```

### 4.2 复制延迟的危害


- **🔸 数据不一致**：读取从库可能得到过期数据
- **🔸 故障切换风险**：延迟过大时切换会丢失数据
- **🔸 业务影响**：读写分离场景下影响用户体验

### 4.3 检查复制延迟


**在从节点执行**：
```sql
-- 查看复制状态（最重要的命令）
SHOW SLAVE STATUS\G

-- 关键字段解读：
-- Seconds_Behind_Master: 延迟秒数（NULL表示复制异常）
-- Slave_IO_Running: IO线程是否运行（必须是Yes）
-- Slave_SQL_Running: SQL线程是否运行（必须是Yes）
```

**简化查询延迟**：
```sql
-- 只查看延迟时间
SELECT 
    CASE 
        WHEN Seconds_Behind_Master IS NULL THEN '复制异常'
        WHEN Seconds_Behind_Master = 0 THEN '无延迟'
        ELSE CONCAT(Seconds_Behind_Master, '秒')
    END AS 复制延迟状态
FROM (
    SELECT VARIABLE_VALUE AS Seconds_Behind_Master
    FROM performance_schema.session_status 
    WHERE VARIABLE_NAME = 'Slave_lag_seconds'
) t;
```

### 4.4 延迟告警阈值建议


| 延迟时间 | 状态级别 | 建议操作 |
|----------|----------|----------|
| **0-1秒** | ✅ `正常` | 无需处理 |
| **1-5秒** | ⚠️ `注意` | 关注趋势 |
| **5-30秒** | 🔶 `告警` | 检查网络和负载 |
| **>30秒** | 🔥 `严重` | 立即排查原因 |
| **NULL** | 🚨 `异常` | 复制已中断 |

---

## 5. 💓 节点健康检查


### 5.1 什么是节点健康检查


**通俗解释**：节点健康检查就像定期体检，检查每个数据库节点的"身体状况"，包括服务是否正常、资源是否充足、响应是否及时等。

### 5.2 健康检查维度


**🔸 服务可用性检查**
```sql
-- 检查MySQL服务是否响应
SELECT 1 AS mysql_alive;

-- 检查当前时间（测试响应速度）
SELECT NOW() AS current_time;
```

**🔸 连接性检查**
```bash
# 从监控服务器测试连接
mysql -h 192.168.1.10 -u monitor -p -e "SELECT 1"

# 检查端口是否开放
telnet 192.168.1.10 3306
```

**🔸 磁盘空间检查**
```sql
-- 查看数据目录磁盘使用情况
SELECT 
    TABLE_SCHEMA AS '数据库',
    ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS '占用空间(MB)'
FROM information_schema.TABLES 
GROUP BY TABLE_SCHEMA
ORDER BY SUM(DATA_LENGTH + INDEX_LENGTH) DESC;
```

### 5.3 自动化健康检查脚本


```bash
#!/bin/bash
# 节点健康检查脚本

# 配置信息
MYSQL_HOST="192.168.1.10"
MYSQL_USER="monitor"
MYSQL_PASS="password"
LOG_FILE="/var/log/mysql_health.log"

# 检查MySQL服务
check_mysql_service() {
    result=$(mysql -h $MYSQL_HOST -u $MYSQL_USER -p$MYSQL_PASS -e "SELECT 1" 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "$(date): MySQL服务正常" >> $LOG_FILE
        return 0
    else
        echo "$(date): MySQL服务异常" >> $LOG_FILE
        return 1
    fi
}

# 检查复制状态
check_replication() {
    slave_status=$(mysql -h $MYSQL_HOST -u $MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" 2>/dev/null)
    
    if echo "$slave_status" | grep -q "Slave_IO_Running: Yes"; then
        if echo "$slave_status" | grep -q "Slave_SQL_Running: Yes"; then
            echo "$(date): 复制状态正常" >> $LOG_FILE
        else
            echo "$(date): SQL线程异常" >> $LOG_FILE
        fi
    else
        echo "$(date): IO线程异常" >> $LOG_FILE
    fi
}

# 执行检查
check_mysql_service
check_replication
```

### 5.4 健康状态评分


```sql
-- 创建健康评分视图
CREATE VIEW node_health_score AS
SELECT 
    '节点健康评分' AS 检查项目,
    CASE 
        WHEN (
            (SELECT COUNT(*) FROM information_schema.processlist WHERE command != 'Sleep') < 100
            AND (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Threads_connected') < 200
            AND (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Seconds_Behind_Master') < 5
        ) THEN '优秀(90-100分)'
        WHEN (
            (SELECT COUNT(*) FROM information_schema.processlist WHERE command != 'Sleep') < 200
            AND (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Threads_connected') < 400
        ) THEN '良好(70-89分)' 
        ELSE '需要关注(<70分)'
    END AS 健康状态;
```

---

## 6. 🚨 告警规则配置


### 6.1 什么是告警规则


**通俗解释**：告警规则就像给监控系统设置的"警戒线"，当某个指标超过这个线时，系统就会自动通知你，就像烟雾报警器一样。

### 6.2 告警级别分类


```
告警级别金字塔：
           🔥 严重告警
          ↗            ↖
     🔶 重要告警        紧急处理
    ↗                    ↖  
⚠️ 普通告警              立即响应
↗                          ↖
📝 信息提醒                 24小时内处理
```

| 级别 | 中文名称 | 响应时间 | 典型场景 |
|------|----------|----------|----------|
| **CRITICAL** | `严重告警` | 5分钟内 | 节点宕机、数据丢失 |
| **WARNING** | `重要告警` | 30分钟内 | 性能下降、延迟过高 |
| **INFO** | `普通告警` | 2小时内 | 连接数过多、磁盘使用高 |
| **NOTICE** | `信息提醒` | 24小时内 | 日常统计、容量预警 |

### 6.3 核心告警规则配置


**🔸 节点宕机告警**
```yaml
# Prometheus告警规则示例
groups:
- name: mysql_cluster_alerts
  rules:
  - alert: MySQL节点宕机
    expr: mysql_up == 0
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "MySQL节点 {{ $labels.instance }} 宕机"
      description: "节点已经宕机超过1分钟，需要立即处理"
```

**🔸 复制延迟告警**
```yaml
  - alert: 复制延迟过高
    expr: mysql_slave_lag_seconds > 30
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "复制延迟超过30秒"
      description: "从库 {{ $labels.instance }} 延迟 {{ $value }} 秒"
```

**🔸 连接数告警**
```yaml
  - alert: 连接数过高
    expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections * 100 > 80
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "连接使用率超过80%"
      description: "当前连接使用率: {{ $value }}%"
```

### 6.4 告警通知配置


**🔸 邮件通知配置**
```yaml
# AlertManager配置
global:
  smtp_smarthost: 'smtp.company.com:587'
  smtp_from: 'alert@company.com'

route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'mysql-dba'

receivers:
- name: 'mysql-dba'
  email_configs:
  - to: 'dba@company.com'
    subject: 'MySQL集群告警: {{ .GroupLabels.alertname }}'
    body: |
      告警时间: {{ .Status }}
      告警详情: {{ range .Alerts }}{{ .Annotations.description }}{{ end }}
```

---

## 7. 📈 监控数据采集


### 7.1 什么是监控数据采集


**通俗解释**：监控数据采集就像安装各种传感器，定期收集数据库的各项"生命体征"数据，为后续的分析和告警提供数据基础。

### 7.2 数据采集方式


**🔸 推送模式 (Push)**
```
数据库节点 → 主动推送 → 监控中心
优点：实时性好，延迟低
缺点：需要配置推送逻辑
```

**🔸 拉取模式 (Pull)**  
```
监控中心 → 定期拉取 → 数据库节点
优点：配置简单，集中管理
缺点：有轮询间隔，实时性稍差
```

### 7.3 使用mysqld_exporter采集数据


**安装配置**：
```bash
# 下载mysqld_exporter
wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.14.0/mysqld_exporter-0.14.0.linux-amd64.tar.gz

# 解压安装
tar -xzf mysqld_exporter-0.14.0.linux-amd64.tar.gz
sudo mv mysqld_exporter-0.14.0.linux-amd64/mysqld_exporter /usr/local/bin/

# 创建MySQL监控用户
CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'password123';
GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';
```

**启动采集器**：
```bash
# 创建配置文件
echo '[client]
host=localhost
port=3306
user=exporter
password=password123' > /etc/mysql/exporter.cnf

# 启动exporter
mysqld_exporter --config.my-cnf=/etc/mysql/exporter.cnf --web.listen-address=:9104
```

### 7.4 自定义监控指标


```sql
-- 创建自定义监控表
CREATE TABLE cluster_metrics (
    id INT AUTO_INCREMENT PRIMARY KEY,
    metric_name VARCHAR(100) NOT NULL,
    metric_value DECIMAL(15,2) NOT NULL,
    node_name VARCHAR(50) NOT NULL,
    collect_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_metric_time (metric_name, collect_time)
);

-- 定期插入监控数据的存储过程
DELIMITER //
CREATE PROCEDURE collect_cluster_metrics()
BEGIN
    -- 插入QPS数据
    INSERT INTO cluster_metrics (metric_name, metric_value, node_name)
    SELECT 'qps', 
           (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Questions') / 
           (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Uptime'),
           $$hostname;
    
    -- 插入连接数据
    INSERT INTO cluster_metrics (metric_name, metric_value, node_name)
    SELECT 'connections', 
           (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Threads_connected'),
           $$hostname;
END //
DELIMITER ;

-- 设置定期执行
CREATE EVENT collect_metrics_event
ON SCHEDULE EVERY 1 MINUTE
DO CALL collect_cluster_metrics();
```

---

## 8. 📊 可视化监控界面


### 8.1 什么是可视化监控


**通俗解释**：可视化监控就像汽车的仪表盘，把复杂的数字转换成直观的图表、仪表和颜色，让你一眼就能看出系统的健康状况。

### 8.2 Grafana监控面板配置


**🔸 集群概览面板**
```json
{
  "dashboard": {
    "title": "MySQL InnoDB Cluster 监控",
    "panels": [
      {
        "title": "集群状态",
        "type": "stat",
        "targets": [
          {
            "expr": "mysql_cluster_status",
            "legendFormat": "{{instance}}"
          }
        ]
      },
      {
        "title": "QPS趋势",
        "type": "graph", 
        "targets": [
          {
            "expr": "rate(mysql_global_status_questions[5m])",
            "legendFormat": "{{instance}} QPS"
          }
        ]
      }
    ]
  }
}
```

### 8.3 关键监控面板设计


**🔸 实时状态面板**
```
┌─────────────────┬─────────────────┬─────────────────┐
│   集群状态      │    节点数量     │    主节点       │
│   🟢 ONLINE     │      3/3        │  192.168.1.10   │
└─────────────────┴─────────────────┴─────────────────┘

┌─────────────────┬─────────────────┬─────────────────┐
│   平均QPS       │    平均TPS      │   复制延迟      │
│     1,234       │      456        │     0.5s        │
└─────────────────┴─────────────────┴─────────────────┘
```

**🔸 性能趋势图表**
```
QPS趋势图：
1500 ┤
1400 ┤     ╭─╮
1300 ┤   ╭─╯ ╰─╮
1200 ┤ ╭─╯     ╰─╮
1100 ┤─╯         ╰───
     └─┬──┬──┬──┬──┬──
      09 10 11 12 13 14 (时间)
```

### 8.4 告警状态面板


| 告警级别 | 数量 | 最新告警 | 处理状态 |
|----------|------|----------|----------|
| 🔥 **严重** | 0 | - | - |
| 🔶 **重要** | 1 | 复制延迟过高 | 🔄 处理中 |
| ⚠️ **普通** | 3 | 连接数过高 | ✅ 已确认 |
| 📝 **信息** | 5 | 磁盘使用率85% | 📋 已计划 |

---

## 9. 🤖 自动化巡检


### 9.1 什么是自动化巡检


**通俗解释**：自动化巡检就像雇了一个不知疲倦的"值班员"，按照设定的检查清单，定期自动检查系统的各个方面，并生成巡检报告。

### 9.2 日常巡检清单


**🔸 每5分钟检查项**
- ✅ 所有节点服务状态
- ✅ 集群拓扑结构
- ✅ 复制延迟情况  
- ✅ 当前连接数

**🔸 每小时检查项**
- ✅ 性能指标趋势
- ✅ 错误日志分析
- ✅ 慢查询统计
- ✅ 锁等待情况

**🔸 每日检查项**
- ✅ 磁盘空间使用
- ✅ 数据增长趋势
- ✅ 备份任务状态
- ✅ 安全日志审计

### 9.3 自动化巡检脚本


```bash
#!/bin/bash
# MySQL集群自动化巡检脚本

REPORT_FILE="/var/log/mysql_inspection_$(date +%Y%m%d_%H%M%S).log"

echo "=== MySQL InnoDB Cluster 巡检报告 ===" > $REPORT_FILE
echo "巡检时间: $(date)" >> $REPORT_FILE
echo "" >> $REPORT_FILE

# 检查集群状态
check_cluster_status() {
    echo "【集群状态检查】" >> $REPORT_FILE
    
    # 使用MySQL Shell检查
    mysqlsh --uri=root@192.168.1.10:3306 --password=password \
            --execute="var cluster = dba.getCluster(); print(cluster.status())" \
            2>/dev/null >> $REPORT_FILE
    
    echo "" >> $REPORT_FILE
}

# 检查性能指标
check_performance() {
    echo "【性能指标检查】" >> $REPORT_FILE
    
    mysql -h 192.168.1.10 -u monitor -ppassword -e "
    SELECT 
        'QPS' AS 指标,
        ROUND((SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Questions') / 
              (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Uptime'), 2) AS 当前值,
        '次/秒' AS 单位
    UNION ALL
    SELECT 
        '连接数' AS 指标,
        (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Threads_connected') AS 当前值,
        '个' AS 单位
    UNION ALL  
    SELECT 
        '缓冲池命中率' AS 指标,
        CONCAT(ROUND((1 - (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') / 
                          (SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')) * 100, 2), '%') AS 当前值,
        '' AS 单位;
    " >> $REPORT_FILE
    
    echo "" >> $REPORT_FILE
}

# 生成巡检报告
generate_summary() {
    echo "【巡检总结】" >> $REPORT_FILE
    
    # 计算健康评分
    echo "✅ 集群整体状态: 正常" >> $REPORT_FILE
    echo "✅ 所有节点在线: 是" >> $REPORT_FILE  
    echo "⚠️  需要关注的问题: 连接数偏高" >> $REPORT_FILE
    echo "📋 建议操作: 优化连接池配置" >> $REPORT_FILE
}

# 执行巡检
check_cluster_status
check_performance  
generate_summary

echo "巡检完成，报告已保存到: $REPORT_FILE"
```

### 9.4 巡检报告自动发送


```bash
# 发送邮件报告
send_report() {
    local report_file=$1
    
    # 使用mail命令发送
    mail -s "MySQL集群巡检报告 $(date +%Y-%m-%d)" \
         -a $report_file \
         dba@company.com < /dev/null
         
    echo "巡检报告已发送到邮箱"
}

# 添加到定时任务
# crontab -e
# 0 9 * * * /path/to/inspection_script.sh
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的监控要点


```
🔸 集群状态监控：确保cluster.status()显示OK
🔸 复制延迟监控：Seconds_Behind_Master应该接近0
🔸 性能指标监控：QPS、TPS、连接数、缓冲池命中率
🔸 节点健康检查：服务可用性、连接性、资源使用
🔸 告警规则配置：分级告警、及时通知、自动处理
🔸 数据采集：使用exporter或自定义脚本收集指标
🔸 可视化展示：Grafana仪表盘直观显示系统状态
🔸 自动化巡检：定期检查、生成报告、主动发现问题
```

### 10.2 监控系统架构理解


**🔹 监控流程**：
```
数据库节点产生指标 → 采集器收集数据 → 监控中心分析处理 → 
可视化展示状态 → 触发告警规则 → 通知运维人员 → 问题处理
```

**🔹 关键组件**：
- **采集层**：mysqld_exporter、自定义脚本
- **存储层**：Prometheus、InfluxDB
- **展示层**：Grafana、自定义面板  
- **告警层**：AlertManager、邮件/短信

### 10.3 实际运维要点


**🔹 监控指标阈值设置**：
- 不要设置太敏感，避免告警风暴
- 不要设置太宽松，错过真正问题
- 根据业务特点和历史数据调整

**🔹 告警处理流程**：
```
1. 接收告警 → 2. 确认问题 → 3. 分析原因 → 
4. 采取措施 → 5. 验证修复 → 6. 记录总结
```

**🔹 日常运维建议**：
- 每天查看监控面板，了解系统状态
- 定期分析性能趋势，预防问题发生
- 保持告警规则的及时更新和优化
- 建立完善的运维文档和处理流程

**核心记忆口诀**：
- 监控如体检，指标要清晰
- 告警分级别，处理有先后  
- 自动化巡检，问题早发现
- 可视化面板，状态一目了然