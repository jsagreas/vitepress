---
title: 1、半同步复制原理
---
## 📚 目录

1. [半同步复制基础概念](#1-半同步复制基础概念)
2. [半同步复制工作机制](#2-半同步复制工作机制)
3. [ACK确认机制详解](#3-ACK确认机制详解)
4. [半同步复制架构分析](#4-半同步复制架构分析)
5. [性能与延迟分析](#5-性能与延迟分析)
6. [半同步复制在分布式系统中的应用](#6-半同步复制在分布式系统中的应用)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💾 半同步复制基础概念


### 1.1 什么是半同步复制


半同步复制是MySQL为了在**数据安全性**和**性能**之间找到平衡点而设计的复制机制。它既不像异步复制那样可能丢失数据，也不像同步复制那样严重影响性能。

**🔸 半同步复制的本质**

简单理解：主库执行事务后，必须等待**至少一个从库**确认收到日志，才认为事务真正完成。就像寄重要文件时要求"签收回执"一样。

```
数据复制安全性对比：

异步复制：    主库 ────────→ 从库
              ↓立即返回     ↓可能延迟
            客户端确认    数据同步

半同步复制：  主库 ────────→ 从库  
              ↓等待ACK     ↓立即回复ACK
            客户端确认 ←──  确认收到

同步复制：    主库 ────────→ 从库
              ↓等待完成     ↓完全同步
            客户端确认 ←──  数据已持久化
```

### 1.2 传统异步复制的问题


**❌ 异步复制存在的风险**

在传统异步复制中，主库执行完事务就立即返回给客户端，不等待从库的任何响应：

```sql
-- 异步复制流程示例
BEGIN;
INSERT INTO orders (user_id, amount) VALUES (1001, 299.99);
COMMIT;  -- 主库立即返回"成功"，不管从库是否收到
```

**潜在问题：**
- **数据丢失风险**：主库宕机时，可能有部分事务未传输到从库
- **主从不一致**：网络问题导致从库延迟，读写分离时可能读到过期数据
- **故障切换风险**：切换到从库时可能丢失最新的事务

### 1.3 半同步复制的优势


**✅ 半同步复制解决方案**

| **特性对比** | **异步复制** | **半同步复制** | **同步复制** |
|-------------|-------------|---------------|-------------|
| **数据安全性** | 🟡 `中等` | 🟢 `高` | 🟢 `最高` |
| **性能影响** | 🟢 `最小` | 🟡 `适中` | 🔴 `较大` |
| **网络要求** | 🟢 `宽松` | 🟡 `中等` | 🔴 `严格` |
| **故障容忍** | 🔴 `可能丢数据` | 🟢 `数据安全` | 🟡 `可能阻塞` |
| **实用性** | 🟢 `广泛使用` | 🟢 `推荐使用` | 🟡 `特殊场景` |

---

## 2. ⚙️ 半同步复制工作机制


### 2.1 主从确认流程详解


半同步复制的核心在于**确认机制**，主库必须收到从库的ACK(确认)后才能提交事务。

**🔄 完整工作流程**

```
半同步复制事务处理流程：

客户端                主库                从库
  │                   │                   │
  │──① SQL事务────────→│                   │
  │                   │──② binlog────────→│
  │                   │                   │──③ 接收日志
  │                   │                   │──④ 写入relay log
  │                   │←─⑤ ACK确认────────│
  │                   │──⑥ 提交事务        │
  │←──⑦ 返回成功──────│                   │
  │                   │                   │──⑧ 应用日志
```

**详细步骤说明：**

1. **客户端发起事务**：应用程序发送SQL到主库
2. **主库写入binlog**：事务写入二进制日志，但未提交
3. **传输到从库**：binlog事件发送给所有半同步从库
4. **从库确认接收**：从库写入relay log后立即发送ACK
5. **主库收到确认**：等待至少一个从库的ACK响应
6. **主库提交事务**：收到确认后正式提交事务
7. **返回客户端**：告知客户端事务执行成功
8. **从库应用日志**：从库在后台异步应用日志

### 2.2 rpl_semi_sync插件机制


**🔧 插件启用与配置**

半同步复制通过专门的插件实现，需要在主库和从库分别加载：

```sql
-- 主库配置
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
SET GLOBAL rpl_semi_sync_master_enabled = 1;

-- 从库配置  
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
```

**关键参数设置：**

| **参数名** | **作用** | **默认值** | **推荐设置** |
|-----------|---------|-----------|-------------|
| `rpl_semi_sync_master_timeout` | `等待ACK超时时间` | `10000ms` | `1000-3000ms` |
| `rpl_semi_sync_master_wait_no_slave` | `无从库时是否等待` | `ON` | `OFF(生产环境)` |
| `rpl_semi_sync_master_wait_point` | `等待确认的时机` | `AFTER_COMMIT` | `AFTER_SYNC` |

### 2.3 事务提交等待机制


**⏱️ 超时处理策略**

半同步复制设有超时机制，避免因从库问题导致主库无限等待：

```sql
-- 查看半同步状态
SHOW STATUS LIKE 'Rpl_semi_sync%';

-- 关键指标解读
Rpl_semi_sync_master_status: ON          -- 半同步是否启用
Rpl_semi_sync_master_clients: 2          -- 半同步从库数量  
Rpl_semi_sync_master_yes_tx: 1247        -- 半同步成功事务数
Rpl_semi_sync_master_no_tx: 23           -- 降级为异步的事务数
```

**超时降级机制：**

```
等待从库ACK确认
        ↓
   达到超时时间？ ──Yes──→ 降级为异步复制
        ↓ No              ↓
    收到ACK确认     记录日志警告
        ↓              ↓
    正常半同步提交    继续等待下次恢复
```

---

## 3. 🔄 ACK确认机制详解


### 3.1 ACK确认的技术细节


**💡 ACK确认的本质**

ACK(Acknowledgment)确认是从库向主库发送的"已收到日志"信号，确保关键数据不会因为主库故障而丢失。

```sql
-- ACK确认包含的信息
{
  "slave_server_id": 102,           -- 从库服务器ID
  "master_log_file": "mysql-bin.000023",  -- 主库日志文件
  "master_log_pos": 856432,         -- 日志位置点
  "timestamp": "2025-08-01 16:30:15" -- 确认时间戳
}
```

### 3.2 确认流程时序分析


**📊 时序图展示**

```
时间轴                主库              从库1             从库2
  │                   │                  │                 │
  │ T1  事务开始       │ BEGIN            │                 │
  │ T2  写入binlog     │ Write binlog     │                 │  
  │ T3  发送到从库     │ ──────binlog────→│ ──────binlog───→│
  │ T4  从库处理       │                  │ Receive & Write │ Receive & Write
  │ T5  发送ACK        │ ←─────ACK────────│                 │ 
  │ T6  收到第一个ACK  │ Got ACK from S1  │                 │
  │ T7  提交事务       │ COMMIT           │                 │
  │ T8  返回客户端     │ Return SUCCESS   │                 │
  │ T9  从库2的ACK     │ ←─────ACK───────────────────────────│
```

**关键时间点：**
- **T3-T5**：网络传输时间，影响半同步延迟
- **T5-T6**：等待第一个ACK的时间
- **T6-T7**：主库处理ACK并提交的时间

### 3.3 多从库确认策略


**🎯 最少确认数量设置**

```sql
-- MySQL 5.7+ 增强半同步复制
SET GLOBAL rpl_semi_sync_master_wait_for_slave_count = 2;
-- 等待至少2个从库确认才提交
```

**确认策略对比：**

| **策略** | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|-------------|
| **等待1个从库** | `延迟最小` | `可用性稍低` | `一般业务场景` |
| **等待2个从库** | `可用性更高` | `延迟增加` | `关键业务数据` |
| **等待多数从库** | `最高可用性` | `延迟较大` | `金融级应用` |

---

## 4. 🏗️ 半同步复制架构分析


### 4.1 半同步复制与2PC对比


**🔍 两阶段提交(2PC)的相似性**

半同步复制与分布式系统中的2PC(Two-Phase Commit)有相似之处，但又有本质区别：

```
2PC两阶段提交：
Phase 1: 协调者询问所有参与者是否可以提交
Phase 2: 根据回复决定提交或回滚

半同步复制：
Phase 1: 主库写入binlog并发送给从库
Phase 2: 等待从库ACK确认后再提交
```

**核心区别：**

| **特性** | **2PC** | **半同步复制** |
|---------|---------|---------------|
| **目标** | `分布式事务一致性` | `数据复制可靠性` |
| **失败处理** | `全部回滚` | `降级为异步复制` |
| **性能影响** | `较大` | `相对较小` |
| **一致性保证** | `强一致性` | `最终一致性` |

### 4.2 在CAP定理中的位置


**⚖️ CAP定理权衡**

半同步复制在CAP定理(Consistency、Availability、Partition tolerance)中的选择：

```
CAP定理在MySQL复制中的体现：

异步复制：   A + P (牺牲一致性，优先可用性)
半同步复制： C + A (平衡一致性和可用性，网络分区时可能降级)  
同步复制：   C + P (优先一致性，可能影响可用性)
```

**实际权衡：**
- **Consistency**：通过ACK确认保证数据不丢失
- **Availability**：超时机制避免长时间阻塞
- **Partition tolerance**：网络分区时可降级为异步

### 4.3 基本架构模式


**🌐 典型部署架构**

```
单主多从半同步架构：

         ┌─────────────────┐
         │    主库(Master)  │
         │  rpl_semi_sync   │
         │    _master       │
         └─────────┬───────┘
                   │
       ┌───────────┼───────────┐
       │           │           │
┌──────▼──────┐ ┌──▼───────┐ ┌──▼───────┐
│ 从库1(Slave) │ │从库2(Slave)│ │从库3(Slave)│
│半同步模式    │ │半同步模式   │ │异步模式   │
│rpl_semi_sync │ │rpl_semi_sync│ │普通slave  │
│  _slave      │ │  _slave     │ │          │
└─────────────┘ └────────────┘ └──────────┘
       │                │
   ┌───▼──┐         ┌───▼──┐
   │读业务 │         │读业务 │
   └──────┘         └──────┘
```

---

## 5. ⏱️ 性能与延迟分析


### 5.1 事务提交延迟量化模型


**📊 延迟构成分析**

半同步复制的总延迟可以用以下公式量化：

```
总延迟 = 网络传输延迟 + 从库处理延迟 + ACK返回延迟

具体计算：
T_total = T_network_to_slave + T_slave_process + T_network_ack + T_master_process

其中：
- T_network_to_slave: 主库到从库的网络延迟 (通常1-5ms)
- T_slave_process: 从库写入relay log时间 (通常0.1-1ms)  
- T_network_ack: ACK回包网络延迟 (通常1-5ms)
- T_master_process: 主库处理ACK时间 (通常0.1ms)
```

**实际性能测试数据：**

| **网络环境** | **平均延迟** | **P99延迟** | **性能影响** |
|-------------|-------------|-------------|-------------|
| **同机房** | `2-5ms` | `10ms` | `TPS下降15%` |
| **同城区** | `5-15ms` | `30ms` | `TPS下降30%` |
| **跨地域** | `50-100ms` | `200ms` | `TPS下降70%` |

### 5.2 异地部署网络延迟处理


**🌍 跨地域部署优化策略**

```sql
-- 针对高延迟网络的参数调优
SET GLOBAL rpl_semi_sync_master_timeout = 5000;  -- 增加超时时间
SET GLOBAL slave_net_timeout = 60;               -- 调整网络超时
SET GLOBAL sync_binlog = 1;                      -- 确保主库安全
```

**网络优化技术：**

- **专线连接**：使用专用网络连接，减少公网不稳定性
- **数据压缩**：启用binlog压缩减少传输数据量
- **批量传输**：适当增加max_binlog_size，减少文件切换
- **网络监控**：实时监控网络质量，自动调整参数

### 5.3 与InnoDB事务日志同步机制


**🔄 存储引擎层面的协调**

半同步复制需要与InnoDB的事务提交机制紧密配合：

```
InnoDB事务提交 + 半同步复制流程：

InnoDB Prepare Phase
        ↓
Write Binary Log  
        ↓
Wait for Semi-Sync ACK  ←── 半同步等待点
        ↓
InnoDB Commit Phase
        ↓
Return to Client
```

**关键配置参数：**

```sql
-- 确保事务安全性的配置组合
SET GLOBAL sync_binlog = 1;                    -- 每次提交都同步binlog
SET GLOBAL innodb_flush_log_at_trx_commit = 1; -- 每次提交都刷新redo log
SET GLOBAL rpl_semi_sync_master_wait_point = 'AFTER_SYNC'; -- 推荐等待点
```

---

## 6. 🌐 半同步复制在分布式系统中的应用


### 6.1 读写分离架构应用


**📖 读写分离中的数据一致性**

半同步复制在读写分离架构中可以显著提升数据一致性：

```sql
-- 应用层读写分离逻辑示例
public class DatabaseRouter {
    
    // 写操作：直接访问主库
    public void writeData(String sql) {
        masterDatabase.execute(sql);
        // 主库半同步复制确保从库已收到数据
    }
    
    // 读操作：访问从库，数据更新及时
    public ResultSet readData(String sql) {
        return slaveDatabase.query(sql);
        // 半同步保证读到的数据延迟极小
    }
}
```

**读写分离优势：**

- **写入安全性**：半同步确保写入数据不会丢失
- **读取一致性**：从库数据延迟降到毫秒级
- **故障切换**：主库故障时从库数据完整

### 6.2 负载均衡策略


**⚖️ 多从库负载均衡**

```
负载均衡策略设计：

                  ┌─────────────┐
                  │  主库(写)    │
                  └──────┬──────┘
                         │ 半同步复制
              ┌──────────┼──────────┐
              │          │          │
        ┌─────▼─────┐ ┌──▼────┐ ┌──▼────┐
        │半同步从库1 │ │半同步  │ │异步   │
        │(读-高一致)│ │从库2   │ │从库3  │
        └───────────┘ └───────┘ └───────┘
              │          │        │
        ┌─────▼─────┐ ┌──▼────┐ ┌──▼────┐
        │核心业务读 │ │一般读  │ │报表   │
        │需求       │ │业务    │ │分析   │
        └───────────┘ └───────┘ └───────┘
```

**负载分配策略：**

| **业务类型** | **路由目标** | **一致性要求** | **性能特点** |
|-------------|-------------|---------------|-------------|
| **实时查询** | `半同步从库` | `强一致性` | `延迟最低` |
| **一般查询** | `普通从库` | `弱一致性` | `吞吐量高` |
| **分析报表** | `专用从库` | `最终一致性` | `不影响在线业务` |

### 6.3 连接池协作优化


**🔗 连接池与半同步复制配合**

```java
// 连接池配置示例
public class SemiSyncConnectionPool {
    
    private HikariDataSource masterPool;    // 主库连接池
    private HikariDataSource semiSyncSlavePool;  // 半同步从库池
    private HikariDataSource asyncSlavePool;     // 异步从库池
    
    public void configurepools() {
        // 主库配置：较少连接，写入专用
        masterPool.setMaximumPoolSize(20);
        masterPool.setConnectionTimeout(3000);
        
        // 半同步从库：中等连接数，核心读业务
        semiSyncSlavePool.setMaximumPoolSize(50);
        semiSyncSlavePool.setConnectionTimeout(2000);
        
        // 异步从库：大量连接，非核心读业务
        asyncSlavePool.setMaximumPoolSize(100);
        asyncSlavePool.setConnectionTimeout(5000);
    }
}
```

### 6.4 分布式事务应用


**🔄 在分布式事务中的角色**

半同步复制可以作为分布式事务的一个组成部分：

```sql
-- 分布式事务示例：订单+库存+支付
BEGIN;

-- 1. 创建订单 (半同步复制确保订单数据安全)
INSERT INTO orders (user_id, product_id, amount) 
VALUES (1001, 2001, 299.99);

-- 2. 扣减库存 (通过半同步从库验证库存)
UPDATE inventory SET quantity = quantity - 1 
WHERE product_id = 2001 AND quantity > 0;

-- 3. 调用支付服务 (外部系统)
CALL payment_service.charge(1001, 299.99);

COMMIT; -- 半同步确保关键数据已复制到从库
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 半同步本质：主库等待至少一个从库ACK确认后才提交事务
🔸 安全性保证：通过确认机制避免数据丢失，提供数据安全性
🔸 性能权衡：在数据安全和性能之间找到最佳平衡点
🔸 超时机制：避免因从库问题导致主库长时间阻塞
🔸 插件实现：通过rpl_semi_sync插件在主库和从库启用
🔸 等待策略：支持多种等待点和确认数量设置
```

### 7.2 关键理解要点


**🔹 半同步与其他复制模式的选择**
```
数据安全性要求高 + 可接受轻微性能损失 → 半同步复制
数据安全性要求一般 + 性能要求极高 → 异步复制  
数据安全性要求极高 + 可接受较大性能损失 → 同步复制
```

**🔹 延迟优化的核心思路**
```
网络层面：使用专线连接，减少网络延迟
配置层面：合理设置超时参数和等待策略
架构层面：就近部署，减少跨地域复制
业务层面：区分核心和非核心数据处理
```

**🔹 故障处理的自动化机制**
```
从库故障 → 自动降级为异步复制 → 从库恢复后自动升级
网络故障 → 超时后降级 → 网络恢复后重新半同步
主库故障 → 提升从库为主库 → 数据完整性有保障
```

### 7.3 实际应用指导


**💼 生产环境最佳实践**

- **参数调优**：根据网络环境调整超时时间和等待策略
- **监控报警**：监控半同步状态和降级事件
- **架构设计**：合理配置半同步和异步从库的比例
- **业务适配**：核心业务使用半同步从库读取

**🔍 故障排查要点**

1. **性能问题**：检查网络延迟和从库处理能力
2. **降级问题**：分析从库故障原因和网络状况  
3. **数据一致性**：验证半同步确认机制是否正常工作
4. **参数调优**：根据业务特点优化相关参数设置

**⚠️ 注意事项**

- **网络依赖**：半同步复制对网络质量要求较高
- **性能影响**：会增加事务提交延迟，需要权衡
- **配置复杂**：涉及多个参数配置，需要仔细调试
- **版本兼容**：不同MySQL版本的半同步特性有差异

**核心记忆要点**：
- 半同步复制是"安全的异步"，通过ACK确认保证数据不丢失
- 超时降级机制确保可用性，网络恢复后自动升级
- 适合对数据安全性有要求但又不能接受同步复制性能损失的场景
- 是现代MySQL高可用架构的重要组成部分