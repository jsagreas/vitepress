---
title: 11、半同步复制与分布式事务
---
## 📚 目录

1. [半同步复制基础回顾](#1-半同步复制基础回顾)
2. [XA事务与半同步协作](#2-XA事务与半同步协作)
3. [分布式事务一致性保障](#3-分布式事务一致性保障)
4. [两阶段提交与半同步](#4-两阶段提交与半同步)
5. [事务协调器角色](#5-事务协调器角色)
6. [分布式回滚机制](#6-分布式回滚机制)
7. [跨库事务处理](#7-跨库事务处理)
8. [分布式死锁检测](#8-分布式死锁检测)
9. [事务补偿机制](#9-事务补偿机制)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔄 半同步复制基础回顾


### 1.1 半同步复制是什么

**半同步复制**是MySQL的一种数据同步方式，介于同步和异步复制之间。它要求主库在提交事务前，至少等待一个从库确认收到了binlog日志。

```
普通异步复制：
主库 ---> 提交事务 ---> 返回客户端 ---> 发送binlog给从库
问题：从库可能丢失数据

半同步复制：
主库 ---> 发送binlog ---> 等待从库确认 ---> 提交事务 ---> 返回客户端
优势：保证至少一个从库有数据备份
```

### 1.2 半同步复制的核心机制

- **确认机制**：从库收到binlog后发送ACK确认
- **超时机制**：等待确认超时后降级为异步复制
- **最少确认数**：可配置至少几个从库确认

```sql
-- 启用半同步复制
-- 主库配置
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
SET GLOBAL rpl_semi_sync_master_enabled = 1;

-- 从库配置  
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
```

---

## 2. 🔗 XA事务与半同步协作


### 2.1 XA事务是什么

**XA事务**是分布式事务的标准协议，让多个数据库能参与同一个事务，保证要么全部成功，要么全部失败。

```
XA事务基本流程：
1. 开始XA事务 (XA START)
2. 执行业务SQL
3. 准备阶段 (XA PREPARE) 
4. 提交阶段 (XA COMMIT) 或回滚 (XA ROLLBACK)
```

### 2.2 XA与半同步的配合

当XA事务遇到半同步复制时，需要保证分布式事务的一致性和数据的高可用性。

```sql
-- XA事务示例
XA START 'order_tx_001';
UPDATE orders SET status = 'paid' WHERE id = 123;
UPDATE inventory SET stock = stock - 1 WHERE product_id = 456;
XA END 'order_tx_001';

-- 准备阶段：半同步会等待从库确认
XA PREPARE 'order_tx_001';

-- 提交阶段：所有参与库都确认后才真正提交
XA COMMIT 'order_tx_001';
```

**关键点**：
- 🔸 **准备阶段**：半同步确保binlog已同步到从库
- 🔸 **提交阶段**：所有库都确认准备完成才最终提交
- 🔸 **回滚保障**：任何库失败都会触发全局回滚

---

## 3. ⚡ 分布式事务一致性保障


### 3.1 一致性问题的本质

分布式环境下最大的挑战是**保证多个数据库的数据一致性**。半同步复制在这里扮演重要角色。

```
分布式事务一致性层次：

强一致性：所有节点同时看到相同数据
└── 半同步 + XA事务实现

最终一致性：节点最终会达到一致状态  
└── 异步复制 + 补偿机制实现

弱一致性：不保证一致性
└── 纯异步复制
```

### 3.2 半同步如何保障一致性

半同步复制通过**确认机制**确保关键数据已经安全复制，为分布式事务提供数据保障。

**保障机制**：
- 🔸 **写入确认**：主库写入后等待从库确认
- 🔸 **故障切换**：主库故障时从库有完整数据
- 🔸 **数据不丢失**：避免网络分区导致的数据丢失

```sql
-- 配置半同步参数保障一致性
SET GLOBAL rpl_semi_sync_master_wait_for_slave_count = 2;  -- 至少2个从库确认
SET GLOBAL rpl_semi_sync_master_timeout = 1000;           -- 1秒超时
```

---

## 4. 🔄 两阶段提交与半同步


### 4.1 两阶段提交协议简介

**两阶段提交(2PC)**是分布式事务的经典协议，分为准备阶段和提交阶段。

```
阶段1：准备阶段(Prepare)
协调器 ---> "准备提交" ---> 所有参与者
所有参与者 ---> "准备完成" ---> 协调器

阶段2：提交阶段(Commit)  
协调器 ---> "正式提交" ---> 所有参与者
所有参与者 ---> "提交完成" ---> 协调器
```

### 4.2 半同步在2PC中的作用

半同步复制在2PC的**准备阶段**发挥关键作用，确保数据已经安全复制到备份节点。

```sql
-- 2PC + 半同步的完整流程
-- 阶段1：准备阶段
XA START 'global_tx_001';
UPDATE account SET balance = balance - 100 WHERE id = 1;  -- 扣款
XA END 'global_tx_001';
XA PREPARE 'global_tx_001';  -- 此时半同步等待从库确认

-- 阶段2：提交阶段（所有库都准备完成后）
XA COMMIT 'global_tx_001';   -- 最终提交
```

**优势分析**：
- ✅ **数据安全**：准备阶段就确保数据已复制
- ✅ **快速恢复**：主库故障时从库可立即接管
- ✅ **一致性强**：避免部分库提交部分库失败

---

## 5. 🎯 事务协调器角色


### 5.1 协调器的职责

**事务协调器**是分布式事务的"指挥官"，负责协调所有参与库的事务状态。

```
协调器核心职责：
┌─────────────────────┐
│   事务协调器         │
├─────────────────────┤
│ • 管理事务状态       │
│ • 协调各参与库       │  
│ • 处理故障恢复       │
│ • 维护事务日志       │
└─────────────────────┘
         │
    ┌────┴────┐
    │         │
   DB1       DB2
```

### 5.2 协调器与半同步的协作

协调器需要考虑半同步复制的特点，在事务决策时等待半同步确认完成。

```sql
-- 协调器管理的事务状态
CREATE TABLE xa_transactions (
    xa_id VARCHAR(64) PRIMARY KEY,
    status ENUM('ACTIVE', 'PREPARED', 'COMMITTED', 'ROLLED_BACK'),
    participant_count INT,
    prepared_count INT,
    created_time TIMESTAMP,
    updated_time TIMESTAMP
);

-- 协调器等待半同步确认的逻辑伪代码
function coordinateTransaction(xa_id) {
    // 1. 发送PREPARE到所有参与库
    for each participant {
        result = participant.prepare(xa_id);
        // 半同步会在这里等待从库确认
        if (!result.success) {
            rollbackAll(xa_id);
            return;
        }
    }
    
    // 2. 所有库都准备完成，发送COMMIT
    commitAll(xa_id);
}
```

---

## 6. 🔙 分布式回滚机制


### 6.1 分布式回滚的挑战

分布式环境下的回滚比单机复杂得多，需要**协调多个数据库同时回滚**，半同步复制增加了额外的复杂性。

```
回滚场景：
场景1：准备阶段失败 ---> 全局回滚
场景2：网络分区     ---> 部分回滚，需要恢复一致性  
场景3：协调器故障   ---> 悬挂事务处理
场景4：从库同步超时 ---> 降级处理
```

### 6.2 半同步环境下的回滚策略

```sql
-- 回滚处理示例
DELIMITER $$
CREATE PROCEDURE HandleDistributedRollback(IN xa_id VARCHAR(64))
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE participant_cursor CURSOR FOR 
        SELECT database_name FROM xa_participants WHERE xa_id = xa_id;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 记录回滚开始
    INSERT INTO xa_rollback_log (xa_id, start_time) VALUES (xa_id, NOW());
    
    OPEN participant_cursor;
    rollback_loop: LOOP
        FETCH participant_cursor INTO @db_name;
        IF done THEN LEAVE rollback_loop; END IF;
        
        -- 对每个参与库执行回滚
        SET @sql = CONCAT('XA ROLLBACK "', xa_id, '"');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    
    CLOSE participant_cursor;
    
    -- 更新回滚状态（半同步会确保此状态同步到从库）
    UPDATE xa_transactions SET status = 'ROLLED_BACK' WHERE xa_id = xa_id;
END$$
DELIMITER ;
```

**回滚要点**：
- 🔸 **顺序回滚**：按照提交相反的顺序回滚
- 🔸 **状态同步**：回滚状态通过半同步同步到备库
- 🔸 **补偿机制**：回滚失败时的补偿操作

---

## 7. 🌐 跨库事务处理


### 7.1 跨库事务的常见场景

跨库事务在业务系统中很常见，比如订单系统需要同时操作订单库和库存库。

```
典型跨库事务场景：
订单系统：
├── 订单库：创建订单记录
├── 库存库：减少商品库存  
├── 账户库：扣除账户余额
└── 日志库：记录操作日志

要求：要么全部成功，要么全部失败
```

### 7.2 跨库事务与半同步实现

```sql
-- 跨库事务处理示例
-- 场景：用户下单，需要操作多个库

-- 1. 启动全局事务
XA START 'order_20250908_001';

-- 2. 操作订单库
USE order_db;
INSERT INTO orders (user_id, product_id, quantity, amount) 
VALUES (1001, 2001, 2, 199.98);

-- 3. 操作库存库  
USE inventory_db;
UPDATE products SET stock = stock - 2 WHERE id = 2001 AND stock >= 2;

-- 4. 操作账户库
USE account_db;
UPDATE accounts SET balance = balance - 199.98 WHERE user_id = 1001 AND balance >= 199.98;

-- 5. 结束事务
XA END 'order_20250908_001';

-- 6. 准备阶段（半同步在这里发挥作用）
XA PREPARE 'order_20250908_001';

-- 7. 提交阶段
XA COMMIT 'order_20250908_001';
```

**半同步优势**：
- ✅ **数据安全**：每个库的操作都会同步到从库
- ✅ **快速恢复**：任何库故障都有备份可用
- ✅ **一致性保证**：避免跨库数据不一致

---

## 8. 🔍 分布式死锁检测


### 8.1 分布式死锁的产生

分布式环境下，死锁比单机更复杂，因为涉及多个数据库之间的等待关系。

```
分布式死锁示例：
事务T1：持有DB1锁 ---> 等待DB2锁
事务T2：持有DB2锁 ---> 等待DB1锁

结果：形成跨库死锁环
```

### 8.2 死锁检测机制

```sql
-- 死锁检测表设计
CREATE TABLE distributed_locks (
    lock_id VARCHAR(128) PRIMARY KEY,
    xa_id VARCHAR(64),
    database_name VARCHAR(64),
    table_name VARCHAR(64),
    row_id VARCHAR(128),
    lock_type ENUM('S', 'X'),  -- 共享锁/排他锁
    acquired_time TIMESTAMP,
    expires_time TIMESTAMP,
    INDEX idx_xa_id (xa_id)
);

-- 等待关系表
CREATE TABLE lock_waits (
    waiting_xa_id VARCHAR(64),
    waiting_for_xa_id VARCHAR(64),
    resource_id VARCHAR(128),
    wait_start_time TIMESTAMP,
    INDEX idx_waiting (waiting_xa_id),
    INDEX idx_waiting_for (waiting_for_xa_id)
);
```

### 8.3 死锁解决策略

```sql
-- 死锁检测和解决存储过程
DELIMITER $$
CREATE PROCEDURE DetectDistributedDeadlock()
BEGIN
    DECLARE deadlock_found INT DEFAULT 0;
    DECLARE victim_xa_id VARCHAR(64);
    
    -- 检测死锁环（简化版本）
    SELECT COUNT(*) INTO deadlock_found
    FROM lock_waits w1 
    JOIN lock_waits w2 ON w1.waiting_for_xa_id = w2.waiting_xa_id 
                       AND w2.waiting_for_xa_id = w1.waiting_xa_id;
    
    IF deadlock_found > 0 THEN
        -- 选择受害者事务（选择代价最小的）
        SELECT waiting_xa_id INTO victim_xa_id
        FROM lock_waits 
        ORDER BY wait_start_time DESC 
        LIMIT 1;
        
        -- 回滚受害者事务
        SET @sql = CONCAT('XA ROLLBACK "', victim_xa_id, '"');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 清理相关等待记录
        DELETE FROM lock_waits WHERE waiting_xa_id = victim_xa_id;
    END IF;
END$$
DELIMITER ;
```

---

## 9. 🔧 事务补偿机制


### 9.1 为什么需要补偿机制

在分布式事务中，有时候传统的回滚机制无法完美解决所有问题，需要**补偿机制**来修复数据不一致。

```
补偿机制适用场景：
1. 长时间运行的事务
2. 跨系统的复杂操作  
3. 部分操作不可逆（如发送邮件）
4. 网络分区导致的不一致
```

### 9.2 Saga模式与半同步

**Saga模式**是一种分布式事务补偿机制，将长事务分解为多个短事务，每个事务都有对应的补偿操作。

```sql
-- Saga事务日志表
CREATE TABLE saga_transactions (
    saga_id VARCHAR(64) PRIMARY KEY,
    business_type VARCHAR(32),
    status ENUM('RUNNING', 'COMPLETED', 'COMPENSATING', 'FAILED'),
    created_time TIMESTAMP,
    updated_time TIMESTAMP
);

-- Saga步骤表
CREATE TABLE saga_steps (
    step_id VARCHAR(64) PRIMARY KEY,
    saga_id VARCHAR(64),
    step_order INT,
    step_name VARCHAR(64),
    forward_sql TEXT,      -- 正向操作SQL
    compensate_sql TEXT,   -- 补偿操作SQL
    status ENUM('PENDING', 'COMPLETED', 'COMPENSATED', 'FAILED'),
    executed_time TIMESTAMP,
    FOREIGN KEY (saga_id) REFERENCES saga_transactions(saga_id)
);
```

### 9.3 补偿操作实现

```sql
-- 补偿操作示例：订单取消的补偿
DELIMITER $$
CREATE PROCEDURE CompensateOrder(IN saga_id VARCHAR(64))
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE step_cursor CURSOR FOR 
        SELECT step_order, compensate_sql 
        FROM saga_steps 
        WHERE saga_id = saga_id 
          AND status = 'COMPLETED'
        ORDER BY step_order DESC;  -- 逆序补偿
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 开始补偿流程
    UPDATE saga_transactions SET status = 'COMPENSATING' WHERE saga_id = saga_id;
    
    OPEN step_cursor;
    compensate_loop: LOOP
        FETCH step_cursor INTO @step_order, @compensate_sql;
        IF done THEN LEAVE compensate_loop; END IF;
        
        -- 执行补偿操作
        PREPARE stmt FROM @compensate_sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 更新步骤状态（通过半同步同步到从库）
        UPDATE saga_steps 
        SET status = 'COMPENSATED' 
        WHERE saga_id = saga_id AND step_order = @step_order;
    END LOOP;
    
    CLOSE step_cursor;
    
    -- 标记补偿完成
    UPDATE saga_transactions SET status = 'FAILED' WHERE saga_id = saga_id;
END$$
DELIMITER ;
```

**补偿要点**：
- 🔸 **逆序补偿**：按照执行相反的顺序进行补偿
- 🔸 **幂等性**：补偿操作必须是幂等的
- 🔸 **状态同步**：补偿状态通过半同步保证一致性

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 半同步复制：主库等待从库确认，保证数据安全复制
🔸 XA事务：分布式事务标准，支持跨库事务一致性
🔸 两阶段提交：分布式事务的经典协议，准备+提交两阶段
🔸 事务协调器：分布式事务的指挥官，协调各参与库
🔸 分布式回滚：跨多库的事务回滚，需要协调机制
🔸 跨库事务：涉及多个数据库的业务事务
🔸 死锁检测：分布式环境下的死锁识别和解决
🔸 补偿机制：传统回滚无法解决时的数据修复方案
```

### 10.2 关键理解要点


**🔹 半同步在分布式事务中的价值**
```
数据安全性：
- 确保关键数据已同步到备库
- 主库故障时快速切换
- 避免数据丢失风险

一致性保障：
- 与XA事务协作保证强一致性
- 为分布式事务提供可靠基础
- 支持复杂业务场景的数据一致性需求
```

**🔹 分布式事务的复杂性**
```
挑战：
- 网络分区和延迟问题
- 多库协调的复杂性
- 故障恢复的困难性

解决思路：
- 两阶段提交保证一致性
- 半同步提供数据安全保障
- 补偿机制处理异常情况
- 死锁检测保证系统稳定性
```

### 10.3 实际应用指导


**🎯 技术选型建议**
- **强一致性要求**：半同步 + XA事务
- **最终一致性可接受**：异步复制 + Saga模式  
- **性能要求高**：读写分离 + 最终一致性
- **数据安全性要求高**：半同步 + 多副本

**🔧 最佳实践**
- 合理设置半同步超时时间
- 监控分布式事务执行状态
- 定期检测和清理悬挂事务
- 建立完善的补偿机制
- 实施分布式死锁检测

**核心记忆**：
- 半同步保数据安全，XA事务保一致性
- 两阶段提交是基础，协调器是大脑
- 分布式回滚要协调，死锁检测不可少
- 补偿机制是后盾，业务连续性重要