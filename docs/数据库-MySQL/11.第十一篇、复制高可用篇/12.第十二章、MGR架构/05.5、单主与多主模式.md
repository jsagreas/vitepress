---
title: 5、单主与多主模式
---
## 📚 目录

1. [MGR模式概述](#1-MGR模式概述)
2. [Single-Primary单主模式](#2-Single-Primary单主模式)
3. [Multi-Primary多主模式](#3-Multi-Primary多主模式)
4. [模式切换操作](#4-模式切换操作)
5. [主节点选举机制](#5-主节点选举机制)
6. [多主冲突检测与解决](#6-多主冲突检测与解决)
7. [模式选择策略与性能对比](#7-模式选择策略与性能对比)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 MGR模式概述


### 1.1 什么是MGR模式

**MGR（MySQL Group Replication）** 就像一个数据库集群的"工作模式"，决定了集群中哪些服务器可以接受写操作。

┌─ MGR工作模式类比 ─────────────┐
│ 想象一个办公室的工作模式：    │
│ • 单主模式：只有一个经理能做决定 │
│ • 多主模式：多个经理都能做决定   │
│ 但需要协调避免冲突           │
└─────────────────────────────┘

**核心概念**：
- **Primary（主节点）**：能接受写操作的服务器
- **Secondary（从节点）**：只能读取数据的服务器
- **模式切换**：在运行中改变集群的工作方式

### 1.2 两种模式的本质区别


```
单主模式（Single-Primary）：
┌─────────┐    ┌─────────┐    ┌─────────┐
│ Primary │    │Secondary│    │Secondary│
│ (读+写) │    │ (只读)  │    │ (只读)  │
└─────────┘    └─────────┘    └─────────┘
     ↑              ↑              ↑
   写操作          读操作          读操作

多主模式（Multi-Primary）：
┌─────────┐    ┌─────────┐    ┌─────────┐
│ Primary │    │ Primary │    │ Primary │
│ (读+写) │    │ (读+写) │    │ (读+写) │
└─────────┘    └─────────┘    └─────────┘
     ↑              ↑              ↑
   写操作          写操作          写操作
```

🔸 **通俗理解**：
- **单主**：就像传统的老板制，只有一个人说了算
- **多主**：就像合伙人制，大家都能做决定，但要协调好

---

## 2. 🏢 Single-Primary单主模式


### 2.1 单主模式工作原理


**基本原理**：集群中只有一台服务器负责写操作，其他服务器自动同步数据。

```
工作流程：
客户端写请求 → Primary节点 → 数据同步 → Secondary节点
    ↓
1. 客户端发送写操作到Primary
2. Primary执行并记录事务
3. 事务通过MGR同步到所有Secondary
4. Secondary应用事务保持数据一致
```

### 2.2 单主模式的特点


| 特点 | **说明** | **实际影响** |
|------|----------|-------------|
| 🎯 **写操作集中** | `只有Primary能写` | `避免写冲突，管理简单` |
| 📖 **读负载分担** | `所有节点都能读` | `提升读性能，负载均衡` |
| 🔄 **自动故障转移** | `Primary故障时自动选新主` | `高可用性保障` |
| ⚡ **性能稳定** | `无写冲突检测开销` | `写性能更好` |

### 2.3 单主模式配置示例


```sql
-- 查看当前模式
SELECT * FROM performance_schema.replication_group_members;

-- 单主模式关键配置
SET GLOBAL group_replication_single_primary_mode = ON;
SET GLOBAL group_replication_enforce_update_everywhere_checks = OFF;

-- 启动MGR（在第一个节点）
START GROUP_REPLICATION;
```

💡 **配置说明**：
- `single_primary_mode = ON`：启用单主模式
- `enforce_update_everywhere_checks = OFF`：关闭多主检查

### 2.4 单主模式适用场景


```
✅ 适用场景：
• 传统的主从架构升级
• 写操作相对集中的应用
• 对数据一致性要求很高
• 希望管理简单的环境

❌ 不适用场景：
• 写操作非常分散
• 需要多地写入的场景
• Primary成为明显瓶颈时
```

---

## 3. 🌐 Multi-Primary多主模式


### 3.1 多主模式工作原理


**基本原理**：集群中所有节点都可以接受写操作，通过冲突检测机制保证数据一致性。

```
多主工作流程：
           冲突检测层
                ↓
节点A写操作 ←→ 协调机制 ←→ 节点B写操作
    ↓                       ↓
  应用事务                 应用事务
    ↓                       ↓
  同步到B                  同步到A
```

### 3.2 多主模式的特点


| 特点 | **优势** | **挑战** |
|------|----------|----------|
| 🚀 **写性能分散** | `多点并发写入` | `冲突检测开销` |
| 🌍 **地理分布友好** | `就近写入减少延迟` | `网络分区风险` |
| 📈 **扩展性好** | `写能力随节点增加` | `复杂度增加` |
| 🔄 **无单点故障** | `任何节点故障不影响写` | `冲突处理复杂` |

### 3.3 多主模式配置示例


```sql
-- 多主模式配置
SET GLOBAL group_replication_single_primary_mode = OFF;
SET GLOBAL group_replication_enforce_update_everywhere_checks = ON;

-- 检查冲突检测状态
SHOW VARIABLES LIKE 'group_replication_enforce_update_everywhere_checks';

-- 启动多主模式MGR
START GROUP_REPLICATION;
```

💡 **配置说明**：
- `single_primary_mode = OFF`：关闭单主模式
- `enforce_update_everywhere_checks = ON`：启用冲突检测

### 3.4 多主模式限制


```
⚠️ 多主模式限制：
• 不支持外键级联更新/删除
• 不支持SERIALIZABLE隔离级别
• 表必须有主键
• 不支持多表更新和GAP锁
• 不支持SELECT ... FOR UPDATE
```

🔸 **为什么有这些限制？**
因为这些操作在多主环境下很难保证一致性，容易产生冲突。

---

## 4. 🔄 模式切换操作


### 4.1 单主切换到多主


**切换步骤**：

```sql
-- 步骤1：停止MGR（在所有节点）
STOP GROUP_REPLICATION;

-- 步骤2：修改配置（在所有节点）
SET GLOBAL group_replication_single_primary_mode = OFF;
SET GLOBAL group_replication_enforce_update_everywhere_checks = ON;

-- 步骤3：重新启动MGR（从Primary节点开始）
START GROUP_REPLICATION;
```

### 4.2 多主切换到单主


```sql
-- 步骤1：选择要保留的Primary节点
SELECT MEMBER_HOST, MEMBER_PORT, MEMBER_STATE, MEMBER_ROLE 
FROM performance_schema.replication_group_members;

-- 步骤2：在目标Primary节点执行
SELECT group_replication_switch_to_single_primary_mode('server_uuid');

-- 步骤3：验证切换结果
SELECT * FROM performance_schema.replication_group_members;
```

### 4.3 模式切换注意事项


┌─ 切换前检查清单 ─────────────┐
│ ✅ 确认所有节点健康运行      │
│ ✅ 备份重要数据             │
│ ✅ 选择合适的维护窗口       │
│ ✅ 通知应用程序准备只读     │
│ ✅ 准备回滚方案             │
└─────────────────────────────┘

🚨 **业务影响最小化策略**：
1. **分批切换**：先测试环境，再生产环境
2. **监控切换**：实时监控性能指标
3. **快速回滚**：准备紧急回滚方案
4. **通知机制**：及时通知相关团队

---

## 5. 🗳️ 主节点选举机制


### 5.1 选举触发条件


**什么时候会选举新主？**
```
选举触发场景：
• Primary节点故障或离线
• 手动切换Primary
• 网络分区恢复后
• 新节点加入时的角色分配
```

### 5.2 选举权重算法


**选举算法原理**：
```
选举优先级（权重从高到低）：
1️⃣ MySQL版本（新版本优先）
2️⃣ 服务器权重值（server_weight）
3️⃣ 服务器UUID（字典序）

权重计算公式：
总权重 = MySQL版本权重 × 1000 + 服务器权重 + UUID权重
```

### 5.3 权重配置示例


```sql
-- 设置服务器权重（范围0-100，默认50）
SET GLOBAL group_replication_member_weight = 90;

-- 查看当前权重配置
SELECT MEMBER_HOST, MEMBER_WEIGHT, MEMBER_ROLE 
FROM performance_schema.replication_group_members;

-- 手动指定Primary节点
SELECT group_replication_set_as_primary('target_server_uuid');
```

🎯 **权重设置策略**：
- **高性能服务器**：设置更高权重（80-100）
- **普通服务器**：使用默认权重（50）
- **备用服务器**：设置较低权重（10-30）

### 5.4 智能化选举优化


```
🧠 智能选举策略：
• 考虑服务器负载情况
• 优先选择数据最新的节点
• 考虑网络延迟和带宽
• 避免频繁切换主节点

💡 最佳实践：
• 定期评估权重设置
• 监控选举频率和效果
• 根据业务特点调整策略
```

---

## 6. ⚔️ 多主冲突检测与解决


### 6.1 冲突类型分析


**数据冲突的常见情况**：

```
冲突场景示例：
节点A：UPDATE users SET age = 25 WHERE id = 1;
节点B：UPDATE users SET age = 30 WHERE id = 1;
                   ↓
            同时修改同一行数据
```

| 冲突类型 | **场景描述** | **检测方式** |
|---------|-------------|-------------|
| 🔄 **主键冲突** | `同时插入相同主键` | `主键唯一性检查` |
| 📝 **行级冲突** | `同时修改同一行` | `行版本号检查` |
| 🏷️ **唯一索引冲突** | `违反唯一约束` | `索引唯一性检查` |
| 🔐 **写集冲突** | `事务写集重叠` | `写集哈希比较` |

### 6.2 冲突检测机制


**检测流程**：
```
事务提交流程：
1. 本地执行事务
2. 生成写集（Write Set）
3. 广播到集群进行冲突检测
4. 无冲突：应用到所有节点
5. 有冲突：回滚后提交的事务
```

### 6.3 冲突解决策略


```sql
-- 查看冲突统计
SELECT * FROM performance_schema.replication_group_member_stats;

-- 监控冲突情况
SELECT 
    COUNT_TRANSACTIONS_CHECKED,
    COUNT_CONFLICTS_DETECTED,
    COUNT_TRANSACTIONS_ROWS_VALIDATING
FROM performance_schema.replication_group_member_stats;
```

### 6.4 智能冲突预防机制


┌─ 冲突预防策略 ───────────────┐
│ 🎯 **应用层设计**：          │
│ • 按业务模块分片写入         │
│ • 使用分布式锁机制           │
│ • 避免热点数据并发修改       │
│                              │
│ ⚙️ **数据库层优化**：        │
│ • 合理设计主键策略           │
│ • 减少事务持有时间           │
│ • 使用乐观锁代替悲观锁       │
└──────────────────────────────┘

**冲突预防最佳实践**：
```
✅ 推荐做法：
• 业务逻辑层面避免并发写同一数据
• 使用UUID或分布式ID避免主键冲突
• 小事务，快速提交
• 读写分离，写操作路由到特定节点

❌ 避免做法：
• 大事务长时间持有锁
• 频繁更新热点行
• 复杂的多表关联更新
• 在事务中进行耗时操作
```

---

## 7. 📊 模式选择策略与性能对比


### 7.1 选择决策矩阵


| 业务特征 | **单主模式** | **多主模式** | **推荐选择** |
|---------|-------------|-------------|-------------|
| 🔢 **写操作频率** | `中低频` | `高频分散` | `根据写入模式` |
| 🌍 **地理分布** | `单地域` | `多地域` | `多主适合全球化` |
| 📊 **数据一致性要求** | `强一致` | `最终一致` | `单主更严格` |
| 🛠️ **运维复杂度** | `简单` | `复杂` | `团队能力评估` |
| 💰 **成本考虑** | `较低` | `较高` | `预算和ROI分析` |

### 7.2 性能对比分析


```
📈 写性能对比：
单主模式：████████░░ 80% (无冲突检测开销)
多主模式：██████░░░░ 60% (有冲突检测开销)

📖 读性能对比：  
单主模式：██████████ 100% (所有节点可读)
多主模式：██████████ 100% (所有节点可读)

🔧 运维复杂度：
单主模式：███░░░░░░░ 30% (配置简单)
多主模式：████████░░ 80% (需要冲突管理)
```

### 7.3 实际应用场景推荐


**单主模式最佳场景**：
```
🏢 企业内部系统：
• ERP、CRM等传统业务系统
• 财务核算等强一致性要求场景
• 小到中型团队维护的系统

📱 特定类型应用：
• 博客、CMS等内容管理系统
• 电商后台管理系统
• 数据仓库和分析系统
```

**多主模式最佳场景**：
```
🌐 全球化应用：
• 跨国电商平台
• 社交媒体应用
• 在线协作工具

⚡ 高并发写入：
• 物联网数据收集
• 日志收集系统
• 实时分析平台
```

### 7.4 模式切换时机建议


```
🔄 从单主切换到多主：
• 写入负载超过单节点处理能力
• 业务扩展到多个地理区域
• 需要更高的写入可用性

🔄 从多主切换到单主：
• 冲突频率过高影响性能
• 运维复杂度超出团队能力
• 业务模式趋向集中化
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 MGR模式：决定集群中哪些节点能写入的工作方式
🔸 单主模式：只有一个Primary节点能写，其他只读
🔸 多主模式：所有节点都能写，需要冲突检测
🔸 模式切换：可以在线切换，但需要规划
🔸 选举机制：自动选择最合适的Primary节点
🔸 冲突检测：多主模式的核心安全机制
```

### 8.2 关键理解要点


**🔹 单主vs多主本质区别**
```
单主模式核心：
• 简单易管理，无写冲突
• 适合传统应用架构
• Primary故障时自动切换

多主模式核心：
• 分布式写入能力强
• 需要处理写冲突问题
• 适合地理分布应用
```

**🔹 选择原则**
```
技术角度：根据写入模式和一致性要求
业务角度：考虑地理分布和可用性需求
运维角度：评估团队能力和维护成本
```

### 8.3 实际应用指导


**🎯 最佳实践**：
- **起步建议**：从单主模式开始，需要时再切换
- **性能监控**：重点关注冲突率和同步延迟
- **应用设计**：从应用层面减少写冲突可能
- **运维规划**：制定清晰的故障处理流程

**⚠️ 常见误区**：
- 认为多主一定比单主好
- 忽视网络延迟对多主性能的影响
- 没有充分测试冲突场景
- 低估运维复杂度

**核心记忆**：
- MGR两种模式各有适用场景，不是谁好谁坏
- 单主简单稳定，多主灵活复杂
- 模式选择要结合业务特点和团队能力
- 冲突检测是多主模式的核心安全保障