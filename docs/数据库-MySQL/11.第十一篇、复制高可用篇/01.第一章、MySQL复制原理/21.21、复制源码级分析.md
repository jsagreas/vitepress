---
title: 21ã€å¤åˆ¶æºç çº§åˆ†æ
---
## ğŸ“š ç›®å½•

1. [MySQLå¤åˆ¶æºç æ¶æ„æ¦‚è§ˆ](#1-mysqlå¤åˆ¶æºç æ¶æ„æ¦‚è§ˆ)
2. [Dumpçº¿ç¨‹æºç å®ç°](#2-dumpçº¿ç¨‹æºç å®ç°)
3. [IOçº¿ç¨‹æºç åˆ†æ](#3-ioçº¿ç¨‹æºç åˆ†æ)
4. [SQLçº¿ç¨‹æºç æœºåˆ¶](#4-sqlçº¿ç¨‹æºç æœºåˆ¶)
5. [å¤åˆ¶äº‹ä»¶å¤„ç†æºç ](#5-å¤åˆ¶äº‹ä»¶å¤„ç†æºç )
6. [å†…å­˜ç®¡ç†æºç ](#6-å†…å­˜ç®¡ç†æºç )
7. [é”™è¯¯å¤„ç†æºç ](#7-é”™è¯¯å¤„ç†æºç )
8. [æ€§èƒ½çƒ­ç‚¹æºç åˆ†æ](#8-æ€§èƒ½çƒ­ç‚¹æºç åˆ†æ)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ—ï¸ MySQLå¤åˆ¶æºç æ¶æ„æ¦‚è§ˆ


### 1.1 ä»€ä¹ˆæ˜¯MySQLå¤åˆ¶æºç åˆ†æ


**ç®€å•ç†è§£**ï¼šå°±åƒæ‹†å¼€æ±½è½¦å¼•æ“çœ‹é‡Œé¢çš„é›¶ä»¶ï¼Œæˆ‘ä»¬è¦æ·±å…¥MySQLå¤åˆ¶çš„ä»£ç ï¼Œçœ‹çœ‹å®ƒåˆ°åº•æ˜¯æ€ä¹ˆå·¥ä½œçš„ã€‚

```
ç”Ÿæ´»ç±»æ¯”ï¼š
å¤åˆ¶ = è€å¸ˆè®²è¯¾ï¼Œå­¦ç”Ÿè®°ç¬”è®°
æºç åˆ†æ = ç ”ç©¶è€å¸ˆæ˜¯æ€ä¹ˆè®²çš„ï¼Œå­¦ç”Ÿæ˜¯æ€ä¹ˆè®°çš„

MySQLå¤åˆ¶è¿‡ç¨‹ï¼š
ä¸»åº“(è€å¸ˆ) â†’ Binlog(è®²è¯¾å†…å®¹) â†’ ä»åº“(å­¦ç”Ÿ)
     â†“              â†“              â†“
  äº§ç”Ÿäº‹ä»¶      ä¼ è¾“äº‹ä»¶        æ‰§è¡Œäº‹ä»¶
```

### 1.2 å¤åˆ¶æºç æ ¸å¿ƒç»„ä»¶æ¶æ„


**ğŸ”§ æ ¸å¿ƒæºç æ¨¡å—ç»“æ„**ï¼š
```
MySQLå¤åˆ¶æºç æ¶æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ä¸»åº“ç«¯       â”‚    â”‚    ä»åº“ç«¯       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Binlog Dump     â”‚â”€â”€â”€â–¶â”‚ IO Thread       â”‚
â”‚ çº¿ç¨‹            â”‚    â”‚ (æ¥æ”¶çº¿ç¨‹)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Eventç”Ÿæˆ       â”‚    â”‚ Relay Log       â”‚
â”‚ æ¨¡å—            â”‚    â”‚ ä¸­ç»§æ—¥å¿—        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç½‘ç»œä¼ è¾“        â”‚    â”‚ SQL Thread      â”‚
â”‚ æ¨¡å—            â”‚    â”‚ (æ‰§è¡Œçº¿ç¨‹)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’¡ æ ¸å¿ƒç†è§£**ï¼š
- **Dumpçº¿ç¨‹**ï¼šä¸»åº“çš„"æ’­éŸ³å‘˜"ï¼Œè´Ÿè´£è¯»å–å’Œå‘é€binlog
- **IOçº¿ç¨‹**ï¼šä»åº“çš„"è®°å½•å‘˜"ï¼Œè´Ÿè´£æ¥æ”¶å¹¶å†™å…¥relay log  
- **SQLçº¿ç¨‹**ï¼šä»åº“çš„"æ‰§è¡Œå‘˜"ï¼Œè´Ÿè´£è¯»å–å’Œæ‰§è¡Œrelay log

### 1.3 æºç æ–‡ä»¶ç»„ç»‡ç»“æ„


**ğŸ“ å…³é”®æºç æ–‡ä»¶ä½ç½®**ï¼š
```cpp
MySQLæºç ç›®å½•ç»“æ„ï¼š
sql/
â”œâ”€â”€ rpl_master.cc        // ä¸»åº“å¤åˆ¶é€»è¾‘
â”œâ”€â”€ rpl_slave.cc         // ä»åº“å¤åˆ¶é€»è¾‘  
â”œâ”€â”€ log_event.cc         // äº‹ä»¶å¤„ç†é€»è¾‘
â”œâ”€â”€ slave.cc             // ä»åº“æ ¸å¿ƒå®ç°
â”œâ”€â”€ rpl_rli.cc           // ä¸­ç»§æ—¥å¿—å¤„ç†
â”œâ”€â”€ rpl_mi.cc            // ä¸»åº“ä¿¡æ¯ç®¡ç†
â””â”€â”€ binlog.cc            // äºŒè¿›åˆ¶æ—¥å¿—å¤„ç†
```

---

## 2. ğŸ“¡ Dumpçº¿ç¨‹æºç å®ç°


### 2.1 Dumpçº¿ç¨‹æ˜¯ä»€ä¹ˆ


**é€šä¿—è§£é‡Š**ï¼šDumpçº¿ç¨‹å°±åƒä¸€ä¸ªä¸“é—¨çš„"é‚®é€’å‘˜"ï¼Œå®ƒçš„å·¥ä½œæ˜¯æŠŠä¸»åº“çš„binlogæ–‡ä»¶å†…å®¹ä¸€æ¡æ¡è¯»å‡ºæ¥ï¼Œç„¶åå‘é€ç»™ä»åº“ã€‚

```
å½¢è±¡æ¯”å–»ï¼š
Dumpçº¿ç¨‹ = å›¾ä¹¦é¦†ç®¡ç†å‘˜
ä»»åŠ¡ï¼šæ‰¾åˆ°æŒ‡å®šçš„ä¹¦(binlogæ–‡ä»¶)
     ç¿»åˆ°æŒ‡å®šé¡µç (positionä½ç½®)  
     ä¸€é¡µé¡µè¯»ç»™ç”¨æˆ·å¬(å‘é€event)
```

### 2.2 Dumpçº¿ç¨‹æ ¸å¿ƒæºç åˆ†æ


**ğŸ” å…³é”®å‡½æ•°ï¼š`mysql_binlog_send()`**

```cpp
// ä½ç½®ï¼šsql/rpl_master.cc
int mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos, 
                      ushort flags)
{
    // 1. æ‰“å¼€binlogæ–‡ä»¶
    IO_CACHE log;
    File file = open_binlog_file(&log, log_ident, &errmsg);
    
    // 2. å®šä½åˆ°æŒ‡å®šposition
    my_b_seek(&log, pos);
    
    // 3. å¾ªç¯è¯»å–å¹¶å‘é€äº‹ä»¶
    while (!thd->killed) {
        // è¯»å–äº‹ä»¶å¤´éƒ¨
        if (my_b_read(&log, (uchar*) packet->ptr(), 
                      LOG_EVENT_HEADER_LEN)) 
            break;
            
        // è¯»å–äº‹ä»¶æ•°æ®
        ulong data_len = uint4korr(packet->ptr() + EVENT_LEN_OFFSET);
        if (my_b_read(&log, (uchar*) packet->ptr() + LOG_EVENT_HEADER_LEN,
                      data_len - LOG_EVENT_HEADER_LEN))
            break;
            
        // å‘é€ç»™ä»åº“
        if (my_net_write(&thd->net, (uchar*) packet->ptr(), data_len))
            break;
            
        // åˆ·æ–°ç½‘ç»œç¼“å†²åŒº
        if (net_flush(&thd->net))
            break;
    }
    
    end_io_cache(&log);
    mysql_file_close(file, MYF(MY_WME));
}
```

**ğŸ’¡ ä»£ç ç†è§£è¦ç‚¹**ï¼š
- `IO_CACHE`ï¼šè¿™æ˜¯MySQLçš„æ–‡ä»¶è¯»å–ç¼“å­˜ï¼Œæé«˜è¯»å–æ•ˆç‡
- `my_b_seek()`ï¼šå®šä½åˆ°binlogæ–‡ä»¶çš„æŒ‡å®šä½ç½®
- `LOG_EVENT_HEADER_LEN`ï¼šæ¯ä¸ªäº‹ä»¶éƒ½æœ‰å›ºå®šé•¿åº¦çš„å¤´éƒ¨ä¿¡æ¯
- `my_net_write()`ï¼šé€šè¿‡ç½‘ç»œå‘é€æ•°æ®ç»™ä»åº“

### 2.3 Dumpçº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†


**ğŸ”„ çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯æµç¨‹**ï¼š

```cpp
// çº¿ç¨‹åˆ›å»ºå…¥å£ - sql/rpl_master.cc
void start_slave_thread(pthread_handler h_func, 
                       pthread_mutex_t *start_lock,
                       pthread_cond_t *start_cond, 
                       pthread_cond_t *stop_cond,
                       volatile uint *slave_running,
                       volatile ulong *slave_run_id,
                       Master_info* mi)
{
    pthread_t th;
    
    // åˆ›å»ºçº¿ç¨‹
    if (pthread_create(&th, &connection_attrib, h_func, (void*)mi))
    {
        // é”™è¯¯å¤„ç†
        sql_print_error("Can't create thread to handle slave");
        return;
    }
    
    // ç­‰å¾…çº¿ç¨‹å¯åŠ¨
    while (!*slave_running && !abort_loop)
        pthread_cond_wait(start_cond, start_lock);
}
```

**âš¡ æ€§èƒ½ä¼˜åŒ–è¦ç‚¹**ï¼š
- **ç¼“å­˜æœºåˆ¶**ï¼šä½¿ç”¨IO_CACHEå‡å°‘ç³»ç»Ÿè°ƒç”¨
- **ç½‘ç»œä¼˜åŒ–**ï¼šæ‰¹é‡å‘é€å‡å°‘ç½‘ç»œå¼€é”€
- **å†…å­˜ç®¡ç†**ï¼šé¢„åˆ†é…ç¼“å†²åŒºé¿å…é¢‘ç¹åˆ†é…

---

## 3. ğŸ“¥ IOçº¿ç¨‹æºç åˆ†æ


### 3.1 IOçº¿ç¨‹çš„ä½œç”¨


**ç®€å•ç†è§£**ï¼šIOçº¿ç¨‹å°±åƒä¸€ä¸ª"æ¥æ”¶å‘˜"ï¼Œä¸“é—¨è´Ÿè´£ä»ä¸»åº“æ¥æ”¶binlogäº‹ä»¶ï¼Œç„¶åå†™åˆ°æœ¬åœ°çš„relay logæ–‡ä»¶ä¸­ã€‚

```
ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼š
IOçº¿ç¨‹ = å¿«é€’å‘˜æ¥æ”¶åŒ…è£¹
å·¥ä½œæµç¨‹ï¼š
1. è¿æ¥åˆ°ä¸»åº“(è”ç³»å‘è´§æ–¹)
2. è¯·æ±‚binlogäº‹ä»¶(è¦æ±‚å‘è´§)  
3. æ¥æ”¶äº‹ä»¶æ•°æ®(æ”¶å–åŒ…è£¹)
4. å†™å…¥relay log(æ”¾åˆ°ä»“åº“)
```

### 3.2 IOçº¿ç¨‹æ ¸å¿ƒæºç å®ç°


**ğŸ” ä¸»è¦å‡½æ•°ï¼š`handle_slave_io()`**

```cpp
// ä½ç½®ï¼šsql/slave.cc  
pthread_handler_t handle_slave_io(void *arg)
{
    Master_info *mi = (Master_info*)arg;
    MYSQL *mysql;
    
    // 1. è¿æ¥åˆ°ä¸»åº“
    if (!(mysql = mysql_real_connect(mysql, mi->host, mi->user, 
                                    mi->password, 0, mi->port, 0, 0)))
    {
        sql_print_error("Slave I/O thread: error connecting to master");
        goto err;
    }
    
    // 2. å‘é€BINLOG DUMPå‘½ä»¤
    if (request_dump(mysql, mi))
    {
        sql_print_error("Failed on request_dump()");
        goto err;
    }
    
    // 3. å¾ªç¯æ¥æ”¶äº‹ä»¶
    while (!io_slave_killed(thd, mi))
    {
        // ä»ç½‘ç»œè¯»å–äº‹ä»¶
        len = cli_safe_read(mysql);
        if (len == packet_error || len < 8)
        {
            sql_print_error("Error reading packet from server");
            break;
        }
        
        // å†™å…¥relay log
        if (queue_event(mi, mysql->net.read_pos + 1, len - 1))
        {
            sql_print_error("Failed to queue_event");
            break;
        }
        
        // æ›´æ–°master info
        flush_master_info(mi, TRUE);
    }
    
err:
    mysql_close(mysql);
    return 0;
}
```

**ğŸ’¡ å…³é”®ç†è§£**ï¼š
- `Master_info`ï¼šå­˜å‚¨ä¸»åº“è¿æ¥ä¿¡æ¯çš„ç»“æ„ä½“
- `request_dump()`ï¼šå‘ä¸»åº“å‘é€å¼€å§‹å¤åˆ¶çš„å‘½ä»¤
- `cli_safe_read()`ï¼šå®‰å…¨çš„ç½‘ç»œæ•°æ®è¯»å–
- `queue_event()`ï¼šå°†äº‹ä»¶å†™å…¥relay logé˜Ÿåˆ—

### 3.3 ç½‘ç»œé€šä¿¡åè®®å®ç°


**ğŸ“¡ è¯·æ±‚Dumpçš„åè®®æ ¼å¼**ï¼š

```cpp
// å‘é€BINLOG DUMPå‘½ä»¤çš„æºç 
int request_dump(MYSQL* mysql, Master_info* mi)
{
    uchar buf[10];
    int4store(buf, mi->rli.group_relay_log_pos);    // position
    int2store(buf + 4, 0);                          // flags  
    int4store(buf + 6, mi->server_id);              // server_id
    
    // å‘é€COM_BINLOG_DUMPå‘½ä»¤
    if (simple_command(mysql, COM_BINLOG_DUMP, buf, 10, 1) ||
        my_net_write(&mysql->net, (uchar*)mi->master_log_name,
                     strlen(mi->master_log_name)))
    {
        return 1;
    }
    
    return 0;
}
```

**ğŸ”§ åè®®å­—æ®µè¯´æ˜**ï¼š
- **Position**ï¼šä»å“ªä¸ªä½ç½®å¼€å§‹è¯»å–binlog
- **Flags**ï¼šæ§åˆ¶æ ‡å¿—ä½ï¼ˆé€šå¸¸ä¸º0ï¼‰
- **Server ID**ï¼šä»åº“çš„æœåŠ¡å™¨ID
- **Log name**ï¼šä¸»åº“binlogæ–‡ä»¶å

---

## 4. âš™ï¸ SQLçº¿ç¨‹æºç æœºåˆ¶


### 4.1 SQLçº¿ç¨‹çš„èŒè´£


**é€šä¿—è§£é‡Š**ï¼šSQLçº¿ç¨‹å°±åƒä¸€ä¸ª"æ‰§è¡Œè€…"ï¼Œå®ƒè¯»å–IOçº¿ç¨‹å†™å…¥çš„relay logï¼Œç„¶åæŠŠé‡Œé¢çš„SQLè¯­å¥åœ¨æœ¬åœ°æ•°æ®åº“æ‰§è¡Œä¸€éã€‚

```
å·¥ä½œç±»æ¯”ï¼š
SQLçº¿ç¨‹ = å·¥å‚æµæ°´çº¿å·¥äºº
ä»»åŠ¡ï¼šä»ä¼ é€å¸¦(relay log)å–é›¶ä»¶(äº‹ä»¶)
     æŒ‰ç…§å›¾çº¸(äº‹ä»¶å†…å®¹)ç»„è£…äº§å“(æ‰§è¡ŒSQL)
     å®Œæˆåæ›´æ–°è¿›åº¦(æ›´æ–°ä½ç½®ä¿¡æ¯)
```

### 4.2 SQLçº¿ç¨‹æ‰§è¡Œæµç¨‹æºç 


**ğŸ” æ ¸å¿ƒå‡½æ•°ï¼š`handle_slave_sql()`**

```cpp
// ä½ç½®ï¼šsql/slave.cc
pthread_handler_t handle_slave_sql(void *arg)
{
    Relay_log_info *rli = (Relay_log_info*)arg;
    
    // åˆå§‹åŒ–SQLçº¿ç¨‹
    if (init_slave_thread(thd, SLAVE_THD_SQL))
        goto err;
        
    // ä¸»æ‰§è¡Œå¾ªç¯
    while (!sql_slave_killed(thd, rli))
    {
        // 1. ä»relay logè¯»å–ä¸‹ä¸€ä¸ªäº‹ä»¶
        Log_event *ev = next_event(rli);
        if (!ev)
        {
            // æ²¡æœ‰äº‹ä»¶ï¼Œç­‰å¾…æˆ–æ£€æŸ¥é”™è¯¯
            if (rli->relay_log.wait_for_update_relay_log(thd))
                break;
            continue;
        }
        
        // 2. æ‰§è¡Œäº‹ä»¶
        int exec_res = ev->exec_event(rli);
        if (exec_res)
        {
            // æ‰§è¡Œå‡ºé”™ï¼Œè®°å½•é”™è¯¯ä¿¡æ¯
            slave_print_msg(ERROR_LEVEL, rli, 
                           "Error executing event: %s", 
                           rli->last_error().message);
            delete ev;
            break;
        }
        
        // 3. æ›´æ–°æ‰§è¡Œä½ç½®
        if (ev->update_pos(rli))
        {
            sql_print_error("Failed to update relay log position");
            delete ev;
            break;
        }
        
        delete ev;
        
        // 4. å®šæœŸåˆ·æ–°ä½ç½®ä¿¡æ¯åˆ°ç£ç›˜
        if (flush_relay_log_info(rli))
            break;
    }
    
err:
    return 0;
}
```

**ğŸ’¡ æ‰§è¡Œè¦ç‚¹ç†è§£**ï¼š
- `next_event()`ï¼šä»relay logè¯»å–ä¸‹ä¸€ä¸ªå¾…æ‰§è¡Œäº‹ä»¶
- `exec_event()`ï¼šæ‰§è¡Œå…·ä½“çš„äº‹ä»¶ï¼ˆINSERTã€UPDATEç­‰ï¼‰
- `update_pos()`ï¼šæ›´æ–°æ‰§è¡Œä½ç½®ï¼Œç”¨äºæ–­ç‚¹ç»­ä¼ 
- `flush_relay_log_info()`ï¼šå°†ä½ç½®ä¿¡æ¯æŒä¹…åŒ–åˆ°ç£ç›˜

### 4.3 äº‹ä»¶æ‰§è¡Œçš„å¤šæ€å®ç°


**ğŸ­ ä¸åŒäº‹ä»¶ç±»å‹çš„æ‰§è¡Œ**ï¼š

```cpp
// äº‹ä»¶æ‰§è¡Œçš„å¤šæ€è°ƒç”¨ - log_event.cc
int Log_event::exec_event(Relay_log_info* rli)
{
    // åŸºç±»é»˜è®¤å®ç° - å¤§éƒ¨åˆ†äº‹ä»¶ç›´æ¥è¿”å›æˆåŠŸ
    return 0;
}

// Queryäº‹ä»¶æ‰§è¡Œï¼ˆDDL/DMLè¯­å¥ï¼‰
int Query_log_event::exec_event(Relay_log_info* rli)
{
    // 1. åˆ‡æ¢åˆ°æ­£ç¡®çš„æ•°æ®åº“
    if (db && mysql_change_db(thd, db, strlen(db), FALSE))
        return 1;
        
    // 2. æ‰§è¡ŒSQLè¯­å¥
    mysql_parse(thd, thd->query, thd->query_length);
    
    // 3. æ£€æŸ¥æ‰§è¡Œç»“æœ
    if (thd->query_error || thd->is_error())
        return 1;
        
    return 0;
}

// Write_rowsäº‹ä»¶æ‰§è¡Œï¼ˆINSERTè¯­å¥ï¼‰
int Write_rows_log_event::exec_event(Relay_log_info* rli)
{
    // æ‰“å¼€è¡¨
    if (open_and_lock_tables(thd, tables, FALSE))
        return 1;
        
    // æ’å…¥è¡Œæ•°æ®
    error = write_row(rli, TRUE /* overwrite */);
    
    return error;
}
```

---

## 5. ğŸ¯ å¤åˆ¶äº‹ä»¶å¤„ç†æºç 


### 5.1 äº‹ä»¶çš„ç”Ÿå‘½å‘¨æœŸ


**ç®€å•ç†è§£**ï¼šMySQLå¤åˆ¶ä¸­çš„äº‹ä»¶å°±åƒ"å¿«é€’åŒ…è£¹"ï¼Œæœ‰è‡ªå·±çš„æ ¼å¼ã€å†…å®¹å’Œå¤„ç†æµç¨‹ã€‚

```
äº‹ä»¶ç”Ÿå‘½å‘¨æœŸï¼š
åˆ›å»º â†’ åºåˆ—åŒ– â†’ ä¼ è¾“ â†’ ååºåˆ—åŒ– â†’ æ‰§è¡Œ â†’ é”€æ¯
 â†“        â†“       â†“        â†“        â†“      â†“
ä¸»åº“    å†™binlog  ç½‘ç»œ    è¯»relay   ä»åº“   å†…å­˜
äº§ç”Ÿ    æŒä¹…åŒ–    ä¼ è¾“    log      æ‰§è¡Œ   æ¸…ç†
```

### 5.2 äº‹ä»¶æ ¼å¼å’Œè§£ææºç 


**ğŸ“¦ äº‹ä»¶é€šç”¨å¤´éƒ¨ç»“æ„**ï¼š

```cpp
// äº‹ä»¶å¤´éƒ¨å®šä¹‰ - include/log_event.h
struct Log_event_header
{
    ulong timestamp;        // æ—¶é—´æˆ³(4å­—èŠ‚)
    uchar type_code;       // äº‹ä»¶ç±»å‹(1å­—èŠ‚) 
    ulong server_id;       // æœåŠ¡å™¨ID(4å­—èŠ‚)
    ulong data_written;    // äº‹ä»¶æ€»é•¿åº¦(4å­—èŠ‚)
    ulong log_pos;         // ä¸‹ä¸ªäº‹ä»¶ä½ç½®(4å­—èŠ‚)
    ushort flags;          // æ ‡å¿—ä½(2å­—èŠ‚)
};

// äº‹ä»¶è¯»å–å’Œåˆ›å»ºå‡½æ•°
Log_event* Log_event::read_log_event(const char* buf, 
                                     uint event_len,
                                     const char** error,
                                     const Format_description_log_event* fdle)
{
    // 1. æ£€æŸ¥äº‹ä»¶é•¿åº¦
    if (event_len < LOG_EVENT_MINIMAL_HEADER_LEN)
    {
        *error = "Event too small";
        return NULL;
    }
    
    // 2. è¯»å–äº‹ä»¶ç±»å‹
    Log_event_type event_type = (Log_event_type)buf[EVENT_TYPE_OFFSET];
    
    // 3. æ ¹æ®ç±»å‹åˆ›å»ºå…·ä½“äº‹ä»¶å¯¹è±¡
    switch (event_type)
    {
        case QUERY_EVENT:
            return new Query_log_event(buf, event_len, fdle);
        case WRITE_ROWS_EVENT:
            return new Write_rows_log_event(buf, event_len, fdle);
        case UPDATE_ROWS_EVENT:
            return new Update_rows_log_event(buf, event_len, fdle);
        case DELETE_ROWS_EVENT:
            return new Delete_rows_log_event(buf, event_len, fdle);
        default:
            *error = "Unknown event type";
            return NULL;
    }
}
```

**ğŸ” å…³é”®äº‹ä»¶ç±»å‹**ï¼š

| äº‹ä»¶ç±»å‹ | **ç”¨é€”è¯´æ˜** | **åŒ…å«å†…å®¹** |
|---------|------------|-------------|
| `QUERY_EVENT` | **DDLå’Œéƒ¨åˆ†DML** | `SQLè¯­å¥æ–‡æœ¬ã€æ•°æ®åº“å` |
| `WRITE_ROWS_EVENT` | **INSERTæ“ä½œ** | `è¡¨IDã€æ’å…¥çš„è¡Œæ•°æ®` |
| `UPDATE_ROWS_EVENT` | **UPDATEæ“ä½œ** | `è¡¨IDã€æ›´æ–°å‰åæ•°æ®` |
| `DELETE_ROWS_EVENT` | **DELETEæ“ä½œ** | `è¡¨IDã€åˆ é™¤çš„è¡Œæ•°æ®` |
| `FORMAT_DESCRIPTION_EVENT` | **æ ¼å¼æè¿°** | `binlogç‰ˆæœ¬ä¿¡æ¯` |

### 5.3 äº‹ä»¶åºåˆ—åŒ–å’Œååºåˆ—åŒ–


**ğŸ’¾ Queryäº‹ä»¶çš„åºåˆ—åŒ–å®ç°**ï¼š

```cpp
// Queryäº‹ä»¶å†™å…¥binlog - log_event.cc
bool Query_log_event::write(IO_CACHE* file)
{
    uchar buf[QUERY_HEADER_LEN];
    
    // å†™å…¥å¤´éƒ¨ä¿¡æ¯
    int4store(buf + Q_THREAD_ID_OFFSET, slave_proxy_id);
    int4store(buf + Q_EXEC_TIME_OFFSET, exec_time);
    int4store(buf + Q_DB_LEN_OFFSET, db_len);
    int2store(buf + Q_ERROR_CODE_OFFSET, error_code);
    int2store(buf + Q_STATUS_VARS_LEN_OFFSET, status_vars_len);
    
    // å†™å…¥å˜é•¿æ•°æ®
    if (my_b_safe_write(file, buf, QUERY_HEADER_LEN) ||
        my_b_safe_write(file, (uchar*)status_vars, status_vars_len) ||
        my_b_safe_write(file, (uchar*)db, db_len + 1) ||
        my_b_safe_write(file, (uchar*)query, q_len))
        return TRUE;
        
    return FALSE;
}

// Queryäº‹ä»¶ä»binlogè¯»å–
Query_log_event::Query_log_event(const char* buf, 
                                uint event_len,
                                const Format_description_log_event* fdle)
{
    // è¯»å–å›ºå®šå¤´éƒ¨
    slave_proxy_id = uint4korr(buf + Q_THREAD_ID_OFFSET);
    exec_time = uint4korr(buf + Q_EXEC_TIME_OFFSET);  
    db_len = uint4korr(buf + Q_DB_LEN_OFFSET);
    error_code = uint2korr(buf + Q_ERROR_CODE_OFFSET);
    
    // è¯»å–å˜é•¿æ•°æ®
    const char* start = buf + fdle->common_header_len + QUERY_HEADER_LEN;
    
    // è·³è¿‡çŠ¶æ€å˜é‡
    start += status_vars_len;
    
    // è¯»å–æ•°æ®åº“å
    db = start;
    start += db_len + 1;
    
    // è¯»å–SQLè¯­å¥
    query = start;
    q_len = event_len - (start - buf);
}
```

---

## 6. ğŸ§  å†…å­˜ç®¡ç†æºç 


### 6.1 å¤åˆ¶è¿‡ç¨‹çš„å†…å­˜ä½¿ç”¨


**ç®€å•ç†è§£**ï¼šMySQLå¤åˆ¶è¿‡ç¨‹ä¸­è¦å¤„ç†å¤§é‡çš„äº‹ä»¶æ•°æ®ï¼Œåˆç†çš„å†…å­˜ç®¡ç†èƒ½é¿å…å†…å­˜æ³„æ¼å’Œæé«˜æ€§èƒ½ã€‚

```
å†…å­˜ä½¿ç”¨åœºæ™¯ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ äº‹ä»¶è¯»å–    â”‚   â”‚ ç½‘ç»œç¼“å†²    â”‚   â”‚ äº‹ä»¶æ‰§è¡Œ    â”‚
â”‚ ç¼“å†²åŒº      â”‚   â”‚ é˜Ÿåˆ—        â”‚   â”‚ ä¸´æ—¶å¯¹è±¡    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“                 â†“                 â†“
   IO_CACHE         NETç»“æ„         THDå†…å­˜æ± 
```

### 6.2 å…³é”®å†…å­˜ç®¡ç†å®ç°


**ğŸ§  IO_CACHEç¼“å­˜ç®¡ç†**ï¼š

```cpp
// binlogæ–‡ä»¶è¯»å–ç¼“å­˜ - mysys/mf_iocache.c
int init_io_cache(IO_CACHE *info, File file, size_t cachesize,
                  enum cache_type type, my_off_t seek_offset,
                  pbool use_async_io, myf cache_myflags)
{
    // åˆ†é…è¯»å–ç¼“å†²åŒº
    if (!(info->buffer = (uchar*)my_malloc(cachesize, MYF(MY_WME))))
        return 1;
        
    info->file = file;
    info->type = type;
    info->buffer_length = cachesize;
    info->myflags = cache_myflags & ~MY_NABP;
    info->request_pos = info->read_pos = info->read_end = info->buffer;
    
    // è®¾ç½®è¯»å–å‡½æ•°æŒ‡é’ˆ
    if (type == READ_CACHE)
    {
        info->read_function = _my_b_read;
        info->seek_not_done = test(seek_offset != my_tell(file));
    }
    
    return 0;
}

// ç¼“å­˜è¯»å–å®ç°
int _my_b_read(IO_CACHE *info, uchar *Buffer, size_t Count)
{
    size_t length, diff_length, left_length;
    
    // ä»ç¼“å­˜ä¸­è¯»å–
    if ((left_length = (size_t)(info->read_end - info->read_pos)))
    {
        // ç¼“å­˜ä¸­æœ‰æ•°æ®ï¼Œç›´æ¥å¤åˆ¶
        diff_length = min(Count, left_length);
        memcpy(Buffer, info->read_pos, diff_length);
        info->read_pos += diff_length;
        Count -= diff_length;
        Buffer += diff_length;
        
        if (!Count)
            return 0;  // è¯»å–å®Œæˆ
    }
    
    // ç¼“å­˜ä¸è¶³ï¼Œä»æ–‡ä»¶è¯»å–
    if ((length = mysql_file_read(info->file, info->buffer, 
                                 info->buffer_length, info->myflags)) 
        == MY_FILE_ERROR)
        return 1;
        
    // æ›´æ–°ç¼“å­˜æŒ‡é’ˆ
    info->read_pos = info->buffer;
    info->read_end = info->buffer + length;
    info->pos_in_file += length;
    
    // ç»§ç»­è¯»å–å‰©ä½™æ•°æ®
    if (Count <= length)
    {
        memcpy(Buffer, info->buffer, Count);
        info->read_pos += Count;
        return 0;
    }
    
    return 1;  // è¯»å–å¤±è´¥
}
```

### 6.3 äº‹ä»¶å¯¹è±¡å†…å­˜æ± 


**ğŸŠâ€â™‚ï¸ THDå†…å­˜æ± ç®¡ç†**ï¼š

```cpp
// THDå†…å­˜åˆ†é…å™¨ - sql/sql_class.h
class THD
{
private:
    MEM_ROOT main_mem_root;      // ä¸»å†…å­˜æ ¹
    MEM_ROOT transaction_mem_root; // äº‹åŠ¡å†…å­˜æ ¹
    
public:
    // åˆ†é…å†…å­˜
    void* alloc(size_t size)
    {
        return alloc_root(&main_mem_root, size);
    }
    
    // é‡Šæ”¾äº‹åŠ¡å†…å­˜
    void cleanup_after_query()
    {
        free_root(&transaction_mem_root, MYF(MY_KEEP_PREALLOC));
    }
};

// å†…å­˜æ ¹åˆ†é…å®ç° - mysys/my_alloc.c  
void* alloc_root(MEM_ROOT *mem_root, size_t Size)
{
    USED_MEM *next;
    size_t get_size, block_size;
    uchar* point;
    
    Size = ALIGN_SIZE(Size);
    
    // æ£€æŸ¥å½“å‰å—æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
    if ((*(uchar**)mem_root->free + ALIGN_SIZE(Size)) <= 
        mem_root->used)
    {
        // å½“å‰å—ç©ºé—´è¶³å¤Ÿ
        point = *(uchar**)mem_root->free;
        *(uchar**)mem_root->free += ALIGN_SIZE(Size);
        return point;
    }
    
    // éœ€è¦åˆ†é…æ–°å—
    get_size = Size + ALIGN_SIZE(sizeof(USED_MEM));
    block_size = max(get_size, mem_root->block_size);
    
    if (!(next = (USED_MEM*)my_malloc(block_size, MYF(MY_WME))))
        return NULL;
        
    // é“¾æ¥åˆ°å†…å­˜æ ¹
    next->next = mem_root->used;
    mem_root->used = next;
    mem_root->free = (uchar**)(((char*)next) + ALIGN_SIZE(sizeof(USED_MEM)));
    
    point = (uchar*)mem_root->free;
    *(uchar**)mem_root->free += ALIGN_SIZE(Size);
    
    return point;
}
```

**ğŸ’¡ å†…å­˜ç®¡ç†ä¼˜åŠ¿**ï¼š
- **æ‰¹é‡åˆ†é…**ï¼šå‡å°‘malloc/freeè°ƒç”¨æ¬¡æ•°
- **å†…å­˜å¯¹é½**ï¼šæé«˜CPUè®¿é—®æ•ˆç‡  
- **è‡ªåŠ¨æ¸…ç†**ï¼šäº‹åŠ¡ç»“æŸè‡ªåŠ¨é‡Šæ”¾å†…å­˜
- **å‡å°‘ç¢ç‰‡**ï¼šè¿ç»­åˆ†é…å‡å°‘å†…å­˜ç¢ç‰‡

---

## 7. ğŸš¨ é”™è¯¯å¤„ç†æºç 


### 7.1 å¤åˆ¶é”™è¯¯åˆ†ç±»


**ç®€å•ç†è§£**ï¼šå¤åˆ¶è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°å„ç§é”™è¯¯ï¼Œå°±åƒå¿«é€’é…é€å¯èƒ½é‡åˆ°åœ°å€é”™è¯¯ã€æ”¶ä»¶äººä¸åœ¨ç­‰é—®é¢˜ï¼Œéœ€è¦æœ‰å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ã€‚

```
å¤åˆ¶é”™è¯¯åˆ†ç±»ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç½‘ç»œé”™è¯¯    â”‚   â”‚ æ•°æ®é”™è¯¯    â”‚   â”‚ é€»è¾‘é”™è¯¯    â”‚
â”‚ è¿æ¥ä¸­æ–­    â”‚   â”‚ æ•°æ®æŸå    â”‚   â”‚ ä¸»é”®å†²çª    â”‚
â”‚ è¶…æ—¶        â”‚   â”‚ æ ¼å¼é”™è¯¯    â”‚   â”‚ æƒé™ä¸è¶³    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“                 â†“                 â†“
   å¯é‡è¯•é”™è¯¯        ä¸¥é‡é”™è¯¯          ä¸šåŠ¡é”™è¯¯
```

### 7.2 é”™è¯¯æ£€æµ‹å’ŒæŠ¥å‘Šæœºåˆ¶


**ğŸ” é”™è¯¯æ£€æµ‹å®ç°**ï¼š

```cpp
// ä»åº“é”™è¯¯ä¿¡æ¯ç»“æ„ - sql/rpl_rli.h
class Relay_log_info
{
public:
    char last_error[MAX_SLAVE_ERRMSG];    // é”™è¯¯æ¶ˆæ¯
    int last_errno;                       // é”™è¯¯ç 
    time_t last_error_timestamp;          // é”™è¯¯æ—¶é—´
    
    // è®¾ç½®é”™è¯¯ä¿¡æ¯
    void report_error(int error_code, const char* format, ...)
    {
        va_list args;
        va_start(args, format);
        
        // è®°å½•é”™è¯¯ç å’Œæ—¶é—´
        last_errno = error_code;
        last_error_timestamp = time(NULL);
        
        // æ ¼å¼åŒ–é”™è¯¯æ¶ˆæ¯
        vsnprintf(last_error, sizeof(last_error), format, args);
        
        // è¾“å‡ºåˆ°é”™è¯¯æ—¥å¿—
        sql_print_error("Slave SQL thread error: %s", last_error);
        
        va_end(args);
        
        // åœæ­¢SQLçº¿ç¨‹
        abort_slave = 1;
    }
    
    // æ¸…é™¤é”™è¯¯ä¿¡æ¯
    void clear_error()
    {
        last_errno = 0;
        last_error[0] = '\0';
        last_error_timestamp = 0;
    }
};
```

### 7.3 é”™è¯¯æ¢å¤ç­–ç•¥å®ç°


**ğŸ”„ è‡ªåŠ¨é‡è¯•æœºåˆ¶**ï¼š

```cpp
// IOçº¿ç¨‹é‡è¿é€»è¾‘ - sql/slave.cc
static int try_to_reconnect(THD *thd, MYSQL *mysql, Master_info *mi)
{
    int retry_count = 0;
    const int max_retry = mi->retry_count;
    
    while (retry_count < max_retry && !io_slave_killed(thd, mi))
    {
        sql_print_information("Attempting to reconnect to master, "
                             "retry %d of %d", retry_count + 1, max_retry);
        
        // å…³é—­æ—§è¿æ¥
        mysql_close(mysql);
        
        // ç­‰å¾…é‡è¯•é—´éš”
        slave_sleep(thd, mi->connect_retry, io_slave_killed, mi);
        
        // å°è¯•é‡æ–°è¿æ¥
        if (!(mysql_real_connect(mysql, mi->host, mi->user, mi->password,
                                0, mi->port, 0, CLIENT_REMEMBER_OPTIONS)))
        {
            sql_print_error("Failed to reconnect to master: %s",
                           mysql_error(mysql));
            retry_count++;
            continue;
        }
        
        // é‡æ–°è¯·æ±‚dump
        if (request_dump(mysql, mi))
        {
            sql_print_error("Failed to request dump after reconnect");
            retry_count++;
            continue;
        }
        
        sql_print_information("Successfully reconnected to master");
        return 0;  // é‡è¿æˆåŠŸ
    }
    
    sql_print_error("Max retry count reached, giving up reconnection");
    return 1;  // é‡è¿å¤±è´¥
}

// SQLçº¿ç¨‹é”™è¯¯å¤„ç†
int handle_sql_thread_error(THD *thd, Relay_log_info *rli, 
                           Log_event *ev, int error_code)
{
    switch (error_code)
    {
        case ER_DUP_ENTRY:
            // ä¸»é”®å†²çª - æ£€æŸ¥æ˜¯å¦å…è®¸è·³è¿‡
            if (bitmap_is_set(&rli->ignore_error_numbers, ER_DUP_ENTRY))
            {
                sql_print_warning("Ignoring duplicate key error on slave");
                rli->clear_error();
                return 0;  // è·³è¿‡é”™è¯¯ç»§ç»­æ‰§è¡Œ
            }
            break;
            
        case ER_NO_SUCH_TABLE:
            // è¡¨ä¸å­˜åœ¨ - å¯èƒ½æ˜¯DDLåŒæ­¥é—®é¢˜
            if (ev->get_type_code() == DELETE_ROWS_EVENT)
            {
                sql_print_warning("Table doesn't exist for DELETE, skipping");
                return 0;
            }
            break;
            
        case ER_ACCESS_DENIED_ERROR:
            // æƒé™é”™è¯¯ - ä¸¥é‡é”™è¯¯ï¼Œéœ€è¦åœæ­¢
            rli->report_error(error_code, 
                             "Access denied error: %s", 
                             thd->stmt_da->message());
            return 1;
            
        default:
            // å…¶ä»–é”™è¯¯ - æ ¹æ®é…ç½®å†³å®š
            if (rli->slave_skip_counter > 0)
            {
                // è·³è¿‡æŒ‡å®šæ•°é‡çš„é”™è¯¯
                rli->slave_skip_counter--;
                sql_print_warning("Skipping error due to skip counter");
                return 0;
            }
    }
    
    // è®°å½•é”™è¯¯å¹¶åœæ­¢
    rli->report_error(error_code, "Error executing event: %s", 
                     thd->stmt_da->message());
    return 1;
}
```

---

## 8. âš¡ æ€§èƒ½çƒ­ç‚¹æºç åˆ†æ


### 8.1 æ€§èƒ½ç“¶é¢ˆè¯†åˆ«


**ç®€å•ç†è§£**ï¼šå°±åƒæ‰¾äº¤é€šå µç‚¹ä¸€æ ·ï¼Œæˆ‘ä»¬è¦æ‰¾å‡ºå¤åˆ¶è¿‡ç¨‹ä¸­æœ€æ…¢çš„ç¯èŠ‚ï¼Œç„¶åé’ˆå¯¹æ€§ä¼˜åŒ–ã€‚

```
å¤åˆ¶æ€§èƒ½çƒ­ç‚¹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç£ç›˜IO      â”‚   â”‚ ç½‘ç»œä¼ è¾“    â”‚   â”‚ SQLæ‰§è¡Œ     â”‚
â”‚ binlogè¯»å–  â”‚   â”‚ äº‹ä»¶ä¼ è¾“    â”‚   â”‚ è¡Œæ“ä½œ      â”‚
â”‚ relayå†™å…¥   â”‚   â”‚ ç½‘ç»œå»¶è¿Ÿ    â”‚   â”‚ ç´¢å¼•ç»´æŠ¤    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“                 â†“                 â†“
  ç¼“å­˜ä¼˜åŒ–          æ‰¹é‡ä¼ è¾“          å¹¶è¡Œæ‰§è¡Œ
```

### 8.2 å…³é”®æ€§èƒ½ä¼˜åŒ–å®ç°


**ğŸš€ æ‰¹é‡äº‹ä»¶å¤„ç†ä¼˜åŒ–**ï¼š

```cpp
// æ‰¹é‡å¤„ç†Row events - sql/log_event.cc
int Rows_log_event::do_apply_event(Relay_log_info const *rli)
{
    TABLE *table = m_table;
    int error = 0;
    
    // 1. å¼€å¯æ‰¹é‡æ¨¡å¼
    if (table->file->ha_start_bulk_insert(0))
        return 1;
        
    // 2. æ‰¹é‡å¤„ç†è¡Œæ•°æ®
    uchar *row_start = m_rows_buf;
    uchar *row_end = m_rows_buf + m_rows_cur;
    
    while (row_start < row_end)
    {
        // è§£æè¡Œæ•°æ®
        int ret = unpack_current_row(rli);
        if (ret)
        {
            error = ret;
            break;
        }
        
        // æ‰§è¡Œè¡Œæ“ä½œï¼ˆINSERT/UPDATE/DELETEï¼‰
        if ((error = do_exec_row(rli)))
            break;
            
        row_start = m_curr_row_end;
    }
    
    // 3. ç»“æŸæ‰¹é‡æ¨¡å¼ï¼Œæäº¤æ›´æ”¹
    int tmp_error = table->file->ha_end_bulk_insert();
    error = error ? error : tmp_error;
    
    return error;
}

// ç½‘ç»œä¼˜åŒ– - é¢„å–äº‹ä»¶
class Master_info 
{
private:
    size_t event_cache_size;    // äº‹ä»¶ç¼“å­˜å¤§å°
    Queue event_queue;          // äº‹ä»¶é˜Ÿåˆ—
    
public:
    // é¢„å–å¤šä¸ªäº‹ä»¶
    int prefetch_events(MYSQL *mysql)
    {
        while (event_queue.size() < MAX_PREFETCH_EVENTS &&
               !io_slave_killed(current_thd, this))
        {
            // è¯»å–ç½‘ç»œæ•°æ®
            ulong len = cli_safe_read(mysql);
            if (len == packet_error)
                return 1;
                
            // åˆ›å»ºäº‹ä»¶å¯¹è±¡
            Log_event *ev = Log_event::read_log_event(
                (const char*)mysql->net.read_pos + 1, len - 1,
                &error, format_description_event);
            
            if (!ev)
                return 1;
                
            // åŠ å…¥ç¼“å­˜é˜Ÿåˆ—
            event_queue.push(ev);
        }
        
        return 0;
    }
    
    // è·å–ç¼“å­˜çš„äº‹ä»¶
    Log_event* get_cached_event()
    {
        if (event_queue.empty())
            return NULL;
            
        Log_event *ev = event_queue.front();
        event_queue.pop();
        return ev;
    }
};
```

### 8.3 å†…å­˜è®¿é—®ä¼˜åŒ–


**ğŸ’¾ ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„**ï¼š

```cpp
// ä¼˜åŒ–çš„äº‹ä»¶è¯»å–ç¼“å†²åŒºç®¡ç†
class Event_buffer_manager
{
private:
    // ä½¿ç”¨ç¯å½¢ç¼“å†²åŒºå‡å°‘å†…å­˜åˆ†é…
    struct Ring_buffer
    {
        uchar *buffer;
        size_t size;
        size_t read_pos;
        size_t write_pos;
        
        bool is_full() const 
        { 
            return ((write_pos + 1) % size) == read_pos; 
        }
        
        bool is_empty() const 
        { 
            return read_pos == write_pos; 
        }
        
        size_t available_write() const
        {
            if (write_pos >= read_pos)
                return size - write_pos + read_pos - 1;
            else
                return read_pos - write_pos - 1;
        }
    };
    
    Ring_buffer ring_buf;
    
public:
    // é«˜æ•ˆçš„äº‹ä»¶è¯»å–
    int read_event(IO_CACHE *cache, Log_event **event)
    {
        // 1. ç¡®ä¿ç¼“å†²åŒºæœ‰è¶³å¤Ÿæ•°æ®
        if (ensure_buffer_data(cache, LOG_EVENT_HEADER_LEN) != 0)
            return -1;
            
        // 2. è¯»å–äº‹ä»¶å¤´éƒ¨ï¼ˆå†…å­˜è®¿é—®ï¼Œæ— ç³»ç»Ÿè°ƒç”¨ï¼‰
        uchar *header = ring_buf.buffer + ring_buf.read_pos;
        ulong event_len = uint4korr(header + EVENT_LEN_OFFSET);
        
        // 3. ç¡®ä¿å®Œæ•´äº‹ä»¶æ•°æ®å¯ç”¨
        if (ensure_buffer_data(cache, event_len) != 0)
            return -1;
            
        // 4. åˆ›å»ºäº‹ä»¶å¯¹è±¡ï¼ˆé›¶æ‹·è´ï¼‰
        *event = Log_event::read_log_event(
            (const char*)(ring_buf.buffer + ring_buf.read_pos),
            event_len, &error, format_description_event);
            
        // 5. æ›´æ–°è¯»å–ä½ç½®
        ring_buf.read_pos = (ring_buf.read_pos + event_len) % ring_buf.size;
        
        return 0;
    }
    
private:
    int ensure_buffer_data(IO_CACHE *cache, size_t needed)
    {
        size_t available = ring_buf.available_write();
        
        if (available < needed)
        {
            // éœ€è¦ä»æ–‡ä»¶è¯»å–æ›´å¤šæ•°æ®
            size_t to_read = min(available, cache->buffer_length);
            
            if (my_b_read(cache, 
                         ring_buf.buffer + ring_buf.write_pos, 
                         to_read) != 0)
                return -1;
                
            ring_buf.write_pos = (ring_buf.write_pos + to_read) % ring_buf.size;
        }
        
        return 0;
    }
};
```

**âš¡ æ€§èƒ½ç›‘æ§æŒ‡æ ‡**ï¼š

```cpp
// æ€§èƒ½ç»Ÿè®¡æ”¶é›†
struct Replication_stats
{
    // å»¶è¿Ÿç»Ÿè®¡
    ulonglong last_event_timestamp;
    ulonglong current_timestamp;
    
    // ååé‡ç»Ÿè®¡  
    ulonglong events_processed;
    ulonglong bytes_processed;
    ulonglong start_time;
    
    // è®¡ç®—å¤åˆ¶å»¶è¿Ÿ
    long get_lag_seconds() const
    {
        return (current_timestamp - last_event_timestamp);
    }
    
    // è®¡ç®—å¤„ç†é€Ÿåº¦
    double get_events_per_second() const
    {
        ulonglong elapsed = current_timestamp - start_time;
        return elapsed > 0 ? (double)events_processed / elapsed : 0.0;
    }
    
    // è®¡ç®—å¸¦å®½ä½¿ç”¨
    double get_mbps() const
    {
        ulonglong elapsed = current_timestamp - start_time;
        return elapsed > 0 ? 
            (double)bytes_processed / (1024 * 1024) / elapsed : 0.0;
    }
};
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ å¤åˆ¶æºç æ¶æ„ï¼šä¸»åº“Dumpçº¿ç¨‹ + ä»åº“IO/SQLçº¿ç¨‹çš„åä½œæœºåˆ¶
ğŸ”¸ çº¿ç¨‹èŒè´£åˆ†å·¥ï¼šDumpè´Ÿè´£å‘é€ï¼ŒIOè´Ÿè´£æ¥æ”¶ï¼ŒSQLè´Ÿè´£æ‰§è¡Œ
ğŸ”¸ äº‹ä»¶é©±åŠ¨æ¨¡å‹ï¼šæ‰€æœ‰æ“ä½œéƒ½åŸºäºbinlogäº‹ä»¶è¿›è¡Œ
ğŸ”¸ å†…å­˜ç®¡ç†ç­–ç•¥ï¼šç¼“å­˜æœºåˆ¶ã€å†…å­˜æ± ã€æ‰¹é‡å¤„ç†æå‡æ€§èƒ½
ğŸ”¸ é”™è¯¯å¤„ç†æœºåˆ¶ï¼šæ£€æµ‹ã€æŠ¥å‘Šã€é‡è¯•ã€æ¢å¤çš„å®Œæ•´æµç¨‹
ğŸ”¸ æ€§èƒ½ä¼˜åŒ–è¦ç‚¹ï¼šæ‰¹é‡å¤„ç†ã€ç¼“å­˜ä¼˜åŒ–ã€å¹¶è¡Œæ‰§è¡Œ
```

### 9.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆè¦äº†è§£æºç **ï¼š
```
å®é™…ä»·å€¼ï¼š
- é—®é¢˜æ’æŸ¥ï¼šé€šè¿‡æºç ç†è§£å¤åˆ¶åŸç†ï¼Œå¿«é€Ÿå®šä½é—®é¢˜
- æ€§èƒ½ä¼˜åŒ–ï¼šäº†è§£ç“¶é¢ˆç‚¹ï¼Œæœ‰é’ˆå¯¹æ€§åœ°è°ƒä¼˜å‚æ•°
- è¿ç»´æ”¯æ’‘ï¼šç†è§£å†…éƒ¨æœºåˆ¶ï¼Œåˆ¶å®šåˆç†çš„è¿ç»´ç­–ç•¥
- æŠ€æœ¯æå‡ï¼šæ·±å…¥ç†è§£MySQLå†…æ ¸ï¼Œæå‡æŠ€æœ¯æ°´å¹³
```

**ğŸ”¹ æºç é˜…è¯»é‡ç‚¹**ï¼š
```
å…³æ³¨è¦ç‚¹ï¼š
- æ•°æ®æµè½¬ï¼šäº‹ä»¶å¦‚ä½•ä»ä¸»åº“ä¼ è¾“åˆ°ä»åº“å¹¶æ‰§è¡Œ
- é”™è¯¯å¤„ç†ï¼šå„ç§å¼‚å¸¸æƒ…å†µçš„æ£€æµ‹å’Œæ¢å¤æœºåˆ¶
- æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡å¤„ç†ã€ç¼“å­˜ã€å†…å­˜ç®¡ç†ç­‰ä¼˜åŒ–æ‰‹æ®µ
- çŠ¶æ€ç®¡ç†ï¼šå¤åˆ¶çŠ¶æ€çš„ç»´æŠ¤å’ŒæŒä¹…åŒ–æœºåˆ¶
```

**ğŸ”¹ å®é™…åº”ç”¨æŒ‡å¯¼**ï¼š
```
è¿ç»´å®è·µï¼š
- ç›‘æ§å…³é”®æŒ‡æ ‡ï¼šå»¶è¿Ÿã€ååé‡ã€é”™è¯¯ç‡
- ä¼˜åŒ–é…ç½®å‚æ•°ï¼šç¼“å­˜å¤§å°ã€é‡è¯•æ¬¡æ•°ã€è¶…æ—¶è®¾ç½®
- æ•…éšœæ’æŸ¥æ€è·¯ï¼šä»æºç è§’åº¦åˆ†æå¤åˆ¶é—®é¢˜
- æ€§èƒ½è°ƒä¼˜æ–¹å‘ï¼šåŸºäºæºç çƒ­ç‚¹è¿›è¡Œé’ˆå¯¹æ€§ä¼˜åŒ–
```

### 9.3 å­¦ä¹ è·¯å¾„å»ºè®®


**ğŸ“š æ¸è¿›å¼å­¦ä¹ **ï¼š
```
ğŸŸ¢ åŸºç¡€é˜¶æ®µï¼š
- ç†è§£å¤åˆ¶åŸºæœ¬æµç¨‹
- æŒæ¡å…³é”®æ•°æ®ç»“æ„
- äº†è§£ä¸»è¦å‡½æ•°åŠŸèƒ½

ğŸŸ¡ è¿›é˜¶é˜¶æ®µï¼š  
- æ·±å…¥äº‹ä»¶å¤„ç†æœºåˆ¶
- åˆ†ææ€§èƒ½ä¼˜åŒ–åŸç†
- ç ”ç©¶é”™è¯¯å¤„ç†ç­–ç•¥

ğŸ”´ é«˜çº§é˜¶æ®µï¼š
- æºç è°ƒè¯•æŠ€å·§
- æ€§èƒ½ç“¶é¢ˆåˆ†æ
- è‡ªå®šä¹‰ä¼˜åŒ–æ–¹æ¡ˆ
```

**ğŸ› ï¸ å®è·µå»ºè®®**ï¼š
```
åŠ¨æ‰‹ç»ƒä¹ ï¼š
1. ç¼–è¯‘MySQLæºç ï¼Œè®¾ç½®è°ƒè¯•ç¯å¢ƒ
2. å•æ­¥è°ƒè¯•å¤åˆ¶ç›¸å…³å‡½æ•°
3. ä¿®æ”¹æºç éªŒè¯ç†è§£
4. åˆ†æç”Ÿäº§ç¯å¢ƒå¤åˆ¶é—®é¢˜
5. åŸºäºæºç åˆ¶å®šä¼˜åŒ–æ–¹æ¡ˆ
```

**æ ¸å¿ƒè®°å¿†**ï¼š
- MySQLå¤åˆ¶æœ¬è´¨æ˜¯äº‹ä»¶é©±åŠ¨çš„å¼‚æ­¥å¤„ç†ç³»ç»Ÿ
- ä¸‰ä¸ªçº¿ç¨‹åä½œå®Œæˆæ•°æ®åŒæ­¥ï¼šäº§ç”Ÿã€ä¼ è¾“ã€æ‰§è¡Œ
- æºç åˆ†æå¸®åŠ©æ·±å…¥ç†è§£åŸç†ï¼ŒæŒ‡å¯¼å®é™…è¿ç»´
- æ€§èƒ½ä¼˜åŒ–è¦ä»æºç å±‚é¢æ‰¾åˆ°çœŸæ­£çš„ç“¶é¢ˆç‚¹