---
title: 1、事务控制语句详解
---
## 📚 目录

1. [事务控制语句概述](#1-事务控制语句概述)
2. [START TRANSACTION事务启动](#2-start-transaction事务启动)
3. [COMMIT事务提交](#3-commit事务提交)
4. [ROLLBACK事务回滚](#4-rollback事务回滚)
5. [自动提交autocommit](#5-自动提交autocommit)
6. [事务嵌套与保存点](#6-事务嵌套与保存点)
7. [事务隔离级别设置](#7-事务隔离级别设置)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 事务控制语句概述


### 1.1 什么是事务控制语句


**🔸 基本概念**
事务控制语句是用来**管理数据库事务**的SQL命令，控制事务的开始、提交和回滚：

```
事务生命周期：
开始事务 → 执行SQL操作 → 提交/回滚 → 事务结束

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ START       │ → │ 执行SQL     │ → │ COMMIT/     │
│ TRANSACTION │    │ 语句        │    │ ROLLBACK    │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 1.2 事务控制语句全览


| 语句类型 | **主要语句** | **作用** | **使用场景** |
|---------|-------------|----------|-------------|
| **🚀 启动** | `START TRANSACTION` | 开始新事务 | 需要手动控制事务边界 |
| **✅ 提交** | `COMMIT` | 永久保存更改 | 确认所有操作正确 |
| **❌ 回滚** | `ROLLBACK` | 撤销所有更改 | 发现错误需要撤销 |
| **⚙️ 设置** | `SET autocommit` | 控制自动提交 | 配置事务行为 |
| **📍 保存点** | `SAVEPOINT name` | 设置回滚点 | 复杂事务分阶段控制 |
| **↩️ 部分回滚** | `ROLLBACK TO name` | 回滚到保存点 | 只撤销部分操作 |

### 1.3 SQL标准 vs MySQL特有语法


**🔸 标准SQL语法**
```sql
-- SQL标准语法
BEGIN;                  -- 开始事务
COMMIT;                 -- 提交事务
ROLLBACK;              -- 回滚事务
```

**🔸 MySQL扩展语法**
```sql
-- MySQL扩展语法
START TRANSACTION;              -- 推荐的启动方式
START TRANSACTION READ ONLY;    -- 只读事务
START TRANSACTION WITH CONSISTENT SNAPSHOT;  -- 一致性快照
```

---

## 2. ⭐ START TRANSACTION事务启动


### 2.1 基本启动语法


**🔸 标准启动方式**
```sql
-- 方式1：推荐使用
START TRANSACTION;

-- 方式2：兼容SQL标准
BEGIN;

-- 方式3：完整写法
BEGIN WORK;
```

**💡 三种方式的区别**
- `START TRANSACTION`：MySQL推荐，功能最完整
- `BEGIN`：简洁，兼容性好
- `BEGIN WORK`：完整SQL标准写法

### 2.2 事务启动参数选项


**🔸 WITH CONSISTENT SNAPSHOT**
```sql
-- 创建一致性快照，用于可重复读
START TRANSACTION WITH CONSISTENT SNAPSHOT;

-- 实际应用：备份数据时保证一致性
START TRANSACTION WITH CONSISTENT SNAPSHOT;
SELECT * FROM orders WHERE date = '2025-01-01';
SELECT * FROM order_items WHERE order_date = '2025-01-01';
COMMIT;
```

**🔸 READ WRITE/READ ONLY设置**
```sql
-- 只读事务：不能执行INSERT/UPDATE/DELETE
START TRANSACTION READ ONLY;
SELECT * FROM products;  -- ✅ 允许
-- UPDATE products SET price = 100;  -- ❌ 报错

-- 读写事务（默认）
START TRANSACTION READ WRITE;
UPDATE products SET price = 100;  -- ✅ 允许
```

### 2.3 事务边界控制


**🔸 明确的事务边界**
```sql
-- 银行转账示例
START TRANSACTION;

-- 检查账户余额
SELECT balance FROM accounts WHERE id = 1001;

-- 执行转账操作
UPDATE accounts SET balance = balance - 500 WHERE id = 1001;
UPDATE accounts SET balance = balance + 500 WHERE id = 1002;

-- 验证结果
SELECT balance FROM accounts WHERE id IN (1001, 1002);

COMMIT;  -- 确认提交
```

---

## 3. ⭐ COMMIT事务提交


### 3.1 基本提交语法


**🔸 标准提交方式**
```sql
-- 基本提交
COMMIT;

-- 完整写法
COMMIT WORK;

-- 提交并释放连接（某些数据库）
COMMIT AND RELEASE;
```

### 3.2 提交时机选择


**🔸 业务完整性提交**
```sql
-- 订单处理：所有相关操作一起提交
START TRANSACTION;

-- 创建订单
INSERT INTO orders (customer_id, total_amount) VALUES (1001, 150.00);
SET @order_id = LAST_INSERT_ID();

-- 添加订单项
INSERT INTO order_items (order_id, product_id, quantity) 
VALUES (@order_id, 101, 2), (@order_id, 102, 1);

-- 更新库存
UPDATE products SET stock = stock - 2 WHERE id = 101;
UPDATE products SET stock = stock - 1 WHERE id = 102;

COMMIT;  -- 所有操作成功才提交
```

### 3.3 批量提交策略


**🔸 大批量数据处理**
```sql
-- 处理大量数据时分批提交
SET @batch_size = 1000;
SET @processed = 0;

START TRANSACTION;
WHILE @processed < @total_records DO
    -- 处理一批数据
    UPDATE large_table SET status = 'processed' 
    WHERE status = 'pending' LIMIT @batch_size;
    
    SET @processed = @processed + @batch_size;
    
    -- 每批提交一次，避免长事务
    COMMIT;
    START TRANSACTION;
END WHILE;
COMMIT;
```

### 3.4 提交性能优化


**🔸 减少提交频率**
```sql
-- ❌ 低效：每条记录提交一次
-- START TRANSACTION;
-- INSERT INTO logs (message) VALUES ('log1');
-- COMMIT;
-- START TRANSACTION;
-- INSERT INTO logs (message) VALUES ('log2');
-- COMMIT;

-- ✅ 高效：批量提交
START TRANSACTION;
INSERT INTO logs (message) VALUES 
('log1'), ('log2'), ('log3'), ('log4'), ('log5');
COMMIT;
```

---

## 4. ⭐ ROLLBACK事务回滚


### 4.1 基本回滚语法


**🔸 完全回滚**
```sql
-- 基本回滚
ROLLBACK;

-- 完整写法
ROLLBACK WORK;
```

### 4.2 回滚使用场景


**🔸 错误检测回滚**
```sql
START TRANSACTION;

-- 转账操作
UPDATE accounts SET balance = balance - 1000 WHERE id = 1001;

-- 检查余额是否足够
SET @balance = (SELECT balance FROM accounts WHERE id = 1001);

IF @balance < 0 THEN
    ROLLBACK;  -- 余额不足，回滚事务
    SELECT 'Transfer failed: Insufficient balance' AS message;
ELSE
    UPDATE accounts SET balance = balance + 1000 WHERE id = 1002;
    COMMIT;  -- 成功，提交事务
    SELECT 'Transfer completed successfully' AS message;
END IF;
```

### 4.3 异常处理中的回滚


**🔸 存储过程中的异常处理**
```sql
DELIMITER //
CREATE PROCEDURE transfer_money(
    IN from_account INT,
    IN to_account INT, 
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;  -- 发生异常时自动回滚
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    UPDATE accounts SET balance = balance - amount WHERE id = from_account;
    UPDATE accounts SET balance = balance + amount WHERE id = to_account;
    
    COMMIT;
END//
DELIMITER ;
```

---

## 5. ⭐ 自动提交autocommit


### 5.1 自动提交概念


**🔸 什么是autocommit？**
```
autocommit是MySQL的一个系统变量：
• autocommit = 1：每条SQL语句自动提交（默认）
• autocommit = 0：需要手动COMMIT才能提交

工作模式对比：
自动提交模式：INSERT → 自动COMMIT
手动提交模式：INSERT → 等待 → 手动COMMIT
```

### 5.2 autocommit设置


**🔸 会话级别设置**
```sql
-- 查看当前autocommit状态
SELECT $$autocommit;

-- 关闭自动提交
SET autocommit = 0;

-- 开启自动提交（默认）
SET autocommit = 1;
```

**🔸 全局级别设置**
```sql
-- 设置全局autocommit（需要SUPER权限）
SET GLOBAL autocommit = 0;

-- 查看全局设置
SELECT $$global.autocommit;
```

### 5.3 autocommit的影响


**🔸 autocommit=1的行为**
```sql
-- 自动提交模式下
SET autocommit = 1;

INSERT INTO users (name) VALUES ('张三');  -- 立即提交
UPDATE users SET age = 25 WHERE name = '张三';  -- 立即提交
DELETE FROM users WHERE name = '张三';  -- 立即提交
```

**🔸 autocommit=0的行为**
```sql
-- 手动提交模式下
SET autocommit = 0;

INSERT INTO users (name) VALUES ('李四');  -- 未提交
UPDATE users SET age = 30 WHERE name = '李四';  -- 未提交
COMMIT;  -- 此时才真正提交

-- 或者回滚
INSERT INTO users (name) VALUES ('王五');
ROLLBACK;  -- 撤销插入操作
```

### 5.4 启动参数影响


**🔸 START TRANSACTION对autocommit的影响**
```sql
-- 即使autocommit=1，START TRANSACTION也会暂时禁用自动提交
SET autocommit = 1;

INSERT INTO test (data) VALUES ('test1');  -- 立即提交

START TRANSACTION;
INSERT INTO test (data) VALUES ('test2');  -- 不会立即提交
INSERT INTO test (data) VALUES ('test3');  -- 不会立即提交
COMMIT;  -- 统一提交test2和test3

-- 事务结束后，autocommit重新生效
INSERT INTO test (data) VALUES ('test4');  -- 立即提交
```

---

## 6. 🔄 事务嵌套与保存点


### 6.1 保存点概念


**🔸 什么是保存点？**
保存点（Savepoint）是事务内部的**检查点**，可以回滚到指定位置而不是回滚整个事务：

```
事务结构示例：
START TRANSACTION
    ├── 操作1
    ├── SAVEPOINT sp1
    ├── 操作2
    ├── 操作3
    ├── SAVEPOINT sp2
    ├── 操作4（出错）
    └── ROLLBACK TO sp2  -- 只回滚操作4，保留1-3
```

### 6.2 保存点语法


**🔸 保存点操作**
```sql
-- 创建保存点
SAVEPOINT savepoint_name;

-- 回滚到保存点
ROLLBACK TO savepoint_name;

-- 释放保存点
RELEASE SAVEPOINT savepoint_name;
```

### 6.3 保存点实际应用


**🔸 复杂业务处理**
```sql
START TRANSACTION;

-- 第一阶段：创建订单
INSERT INTO orders (customer_id) VALUES (1001);
SET @order_id = LAST_INSERT_ID();
SAVEPOINT order_created;

-- 第二阶段：添加订单项
INSERT INTO order_items (order_id, product_id, quantity) 
VALUES (@order_id, 101, 2);
SAVEPOINT items_added;

-- 第三阶段：更新库存（可能失败）
UPDATE products SET stock = stock - 2 WHERE id = 101;

-- 检查库存是否充足
IF (SELECT stock FROM products WHERE id = 101) < 0 THEN
    ROLLBACK TO items_added;  -- 只回滚库存更新
    SELECT 'Stock insufficient, order items removed' AS message;
ELSE
    COMMIT;  -- 全部成功
    SELECT 'Order completed successfully' AS message;
END IF;
```

### 6.4 事务嵌套处理


**🔸 MySQL的嵌套限制**
```sql
-- MySQL不支持真正的嵌套事务
START TRANSACTION;
    -- START TRANSACTION;  -- 这会隐式提交外层事务
    
-- 正确的嵌套方式：使用保存点
START TRANSACTION;
    INSERT INTO table1 VALUES (1);
    SAVEPOINT nested_point;
        INSERT INTO table2 VALUES (2);
        -- 如果需要回滚内层操作
        ROLLBACK TO nested_point;
    INSERT INTO table3 VALUES (3);
COMMIT;
```

---

## 7. 🔧 事务隔离级别设置


### 7.1 隔离级别概述


**🔸 四种隔离级别**
| 隔离级别 | **读取** | **脏读** | **不可重复读** | **幻读** |
|---------|---------|---------|-------------|----------|
| **READ UNCOMMITTED** | 未提交数据 | ✗ | ✗ | ✗ |
| **READ COMMITTED** | 已提交数据 | ✓ | ✗ | ✗ |
| **REPEATABLE READ** | 一致性读取 | ✓ | ✓ | ✗ |
| **SERIALIZABLE** | 串行化 | ✓ | ✓ | ✓ |

### 7.2 隔离级别设置语法


**🔸 设置语法**
```sql
-- 设置会话级别隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 为下一个事务设置隔离级别
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### 7.3 隔离级别实际应用


**🔸 报表查询场景**
```sql
-- 生成财务报表，需要数据一致性
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

SELECT SUM(amount) FROM orders WHERE date = '2025-01-01';
SELECT COUNT(*) FROM orders WHERE date = '2025-01-01';
-- 即使其他事务修改数据，这些查询结果保持一致

COMMIT;
```

### 7.4 只读事务设置


**🔸 只读事务语法**
```sql
-- 设置只读事务
SET TRANSACTION READ ONLY;
START TRANSACTION;

-- 或者直接在启动时设置
START TRANSACTION READ ONLY;

-- 只读事务特点
SELECT * FROM products;     -- ✅ 允许
-- INSERT INTO products;    -- ❌ 报错
-- UPDATE products;         -- ❌ 报错
-- DELETE FROM products;    -- ❌ 报错

COMMIT;
```

---

## 8. 📋 核心要点总结


### 8.1 事务控制语句速查


```
🚀 事务启动：
START TRANSACTION [READ ONLY | READ WRITE] [WITH CONSISTENT SNAPSHOT];
BEGIN [WORK];

✅ 事务提交：
COMMIT [WORK] [AND [NO] RELEASE];

❌ 事务回滚：
ROLLBACK [WORK] [TO SAVEPOINT savepoint_name];

🔄 保存点操作：
SAVEPOINT savepoint_name;
ROLLBACK TO savepoint_name;
RELEASE SAVEPOINT savepoint_name;
```

### 8.2 关键概念理解


```
🔸 事务边界控制：
• 明确的开始：START TRANSACTION
• 明确的结束：COMMIT或ROLLBACK
• 避免长事务：及时提交或回滚

🔸 自动提交机制：
• autocommit=1：每条SQL自动提交（默认）
• autocommit=0：需要手动提交
• START TRANSACTION暂时禁用自动提交

🔸 保存点机制：
• 事务内部的检查点
• 支持部分回滚
• 替代嵌套事务的解决方案
```

### 8.3 最佳实践规范


```
✅ 推荐做法：
• 使用START TRANSACTION而不是BEGIN
• 事务尽可能短小
• 在业务逻辑完整处提交
• 使用保存点处理复杂业务
• 异常处理中及时回滚

❌ 避免做法：
• 长时间不提交事务
• 在循环中频繁开启事务
• 忘记处理异常回滚
• 混合使用autocommit设置
```

### 8.4 性能优化要点


```
🚀 提交策略优化：
• 批量操作一次性提交
• 避免每条记录单独提交
• 大数据量时分批提交
• 合理设置事务边界

⚙️ 隔离级别选择：
• 读多写少：READ COMMITTED
• 数据一致性要求高：REPEATABLE READ
• 报表查询：可考虑READ UNCOMMITTED
• 并发控制严格：SERIALIZABLE
```

### 8.5 故障处理指南


```
🔧 常见问题处理：
• 事务阻塞：检查锁等待，考虑降低隔离级别
• 死锁问题：优化事务逻辑，统一加锁顺序
• 提交失败：检查约束条件，实施重试机制
• 回滚异常：确保异常处理逻辑完整

📊 监控要点：
• 事务持续时间
• 锁等待情况
• 死锁频率
• 回滚比率
```

**核心记忆口诀**：
- 事务三步曲：开始提交回滚清
- 保存点机制：部分回滚好帮手  
- 自动提交记：默认开启要注意
- 隔离级别选：根据业务定策略