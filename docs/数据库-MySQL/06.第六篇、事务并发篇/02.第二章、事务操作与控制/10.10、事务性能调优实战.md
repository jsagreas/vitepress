---
title: 10ã€äº‹åŠ¡æ€§èƒ½è°ƒä¼˜å®æˆ˜
---
## ğŸ“š ç›®å½•

1. [äº‹åŠ¡æ€§èƒ½åˆ†æåŸºç¡€](#1-äº‹åŠ¡æ€§èƒ½åˆ†æåŸºç¡€)
2. [é”ç«äº‰ä¼˜åŒ–ç­–ç•¥](#2-é”ç«äº‰ä¼˜åŒ–ç­–ç•¥)
3. [äº‹åŠ¡æ—¥å¿—è°ƒä¼˜](#3-äº‹åŠ¡æ—¥å¿—è°ƒä¼˜)
4. [æ‰¹é‡æ“ä½œä¼˜åŒ–](#4-æ‰¹é‡æ“ä½œä¼˜åŒ–)
5. [ç´¢å¼•ä¸äº‹åŠ¡å…³ç³»](#5-ç´¢å¼•ä¸äº‹åŠ¡å…³ç³»)
6. [äº‹åŠ¡ç›‘æ§æŒ‡æ ‡ä½“ç³»](#6-äº‹åŠ¡ç›‘æ§æŒ‡æ ‡ä½“ç³»)
7. [æ€§èƒ½ç“¶é¢ˆè¯†åˆ«ä¸å®šä½](#7-æ€§èƒ½ç“¶é¢ˆè¯†åˆ«ä¸å®šä½)
8. [æ€§èƒ½è°ƒä¼˜æ–¹æ³•è®º](#8-æ€§èƒ½è°ƒä¼˜æ–¹æ³•è®º)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ” äº‹åŠ¡æ€§èƒ½åˆ†æåŸºç¡€


### 1.1 ä»€ä¹ˆæ˜¯äº‹åŠ¡æ€§èƒ½åˆ†æ


> **ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ**
> 
> äº‹åŠ¡æ€§èƒ½åˆ†ææ˜¯æŒ‡ç³»ç»Ÿæ€§åœ°è¯„ä¼°æ•°æ®åº“äº‹åŠ¡æ“ä½œçš„æ‰§è¡Œæ•ˆç‡ï¼Œè¯†åˆ«æ€§èƒ½ç“¶é¢ˆï¼Œå¹¶åˆ¶å®šä¼˜åŒ–ç­–ç•¥çš„è¿‡ç¨‹ã€‚å®ƒä¸ä»…å…³æ³¨å•ä¸ªäº‹åŠ¡çš„æ‰§è¡Œæ—¶é—´ï¼Œæ›´è¦åˆ†æäº‹åŠ¡é—´çš„ç›¸äº’å½±å“ã€‚

**ä¸ºä»€ä¹ˆäº‹åŠ¡æ€§èƒ½å¦‚æ­¤é‡è¦ï¼Ÿ**

åœ¨é«˜å¹¶å‘çš„ä¸šåŠ¡åœºæ™¯ä¸­ï¼Œäº‹åŠ¡æ€§èƒ½ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒï¼š
- **å“åº”æ—¶é—´**ï¼šç”¨æˆ·ç­‰å¾…æ“ä½œå®Œæˆçš„æ—¶é—´
- **ç³»ç»Ÿååé‡**ï¼šå•ä½æ—¶é—´å†…èƒ½å¤„ç†çš„äº‹åŠ¡æ•°é‡
- **èµ„æºåˆ©ç”¨ç‡**ï¼šCPUã€å†…å­˜ã€ç£ç›˜I/Oçš„ä½¿ç”¨æ•ˆç‡
- **å¹¶å‘èƒ½åŠ›**ï¼šç³»ç»Ÿèƒ½åŒæ—¶å¤„ç†çš„ç”¨æˆ·æ•°é‡

```
å…¸å‹åœºæ™¯å¯¹æ¯”ï¼š
ç”µå•†ç§’æ€æ´»åŠ¨ï¼š
- é«˜å³°æœŸï¼š10000ä¸ªå¹¶å‘ä¸‹å•äº‹åŠ¡
- æœªä¼˜åŒ–ï¼šå¹³å‡å“åº”æ—¶é—´5ç§’ï¼ŒæˆåŠŸç‡60%
- ä¼˜åŒ–åï¼šå¹³å‡å“åº”æ—¶é—´0.5ç§’ï¼ŒæˆåŠŸç‡95%
æ•ˆæœï¼šç”¨æˆ·ä½“éªŒå¤§å¹…æå‡ï¼Œä¸šåŠ¡æ”¶å…¥æ˜¾è‘—å¢åŠ 
```

### 1.2 äº‹åŠ¡æ€§èƒ½çš„å½±å“å› ç´ 


**ğŸ¯ ä¸»è¦å½±å“å› ç´ **

| å› ç´ ç±»åˆ« | **å…·ä½“å½±å“** | **ä¸¥é‡ç¨‹åº¦** | **ä¼˜åŒ–éš¾åº¦** |
|---------|-------------|-------------|-------------|
| **é”ç«äº‰** | `äº‹åŠ¡ç­‰å¾…é”é‡Šæ”¾ï¼Œé˜»å¡å…¶ä»–äº‹åŠ¡` | `ğŸ”´ ä¸¥é‡` | `ğŸŸ¡ ä¸­ç­‰` |
| **äº‹åŠ¡æ—¥å¿—** | `æ—¥å¿—å†™å…¥æ€§èƒ½å½±å“äº‹åŠ¡æäº¤é€Ÿåº¦` | `ğŸŸ¡ ä¸­ç­‰` | `ğŸŸ¢ å®¹æ˜“` |
| **ç´¢å¼•è®¾è®¡** | `ä¸å½“ç´¢å¼•å¯¼è‡´é”èŒƒå›´æ‰©å¤§` | `ğŸ”´ ä¸¥é‡` | `ğŸŸ¡ ä¸­ç­‰` |
| **äº‹åŠ¡ç²’åº¦** | `äº‹åŠ¡è¿‡å¤§å ç”¨èµ„æºæ—¶é—´é•¿` | `ğŸŸ¡ ä¸­ç­‰` | `ğŸŸ¢ å®¹æ˜“` |
| **éš”ç¦»çº§åˆ«** | `è¿‡é«˜éš”ç¦»çº§åˆ«å¢åŠ é”å¼€é”€` | `ğŸŸ¡ ä¸­ç­‰` | `ğŸŸ¢ å®¹æ˜“` |

### 1.3 æ€§èƒ½åˆ†æçš„åŸºæœ¬æ–¹æ³•


**ğŸ”¬ åˆ†ææ€è·¯æ¡†æ¶**
```
ç¬¬ä¸€æ­¥ï¼šå»ºç«‹æ€§èƒ½åŸºçº¿
    â†“
ç¬¬äºŒæ­¥ï¼šè¯†åˆ«æ€§èƒ½é—®é¢˜
    â†“  
ç¬¬ä¸‰æ­¥ï¼šå®šä½é—®é¢˜æ ¹æº
    â†“
ç¬¬å››æ­¥ï¼šåˆ¶å®šä¼˜åŒ–æ–¹æ¡ˆ
    â†“
ç¬¬äº”æ­¥ï¼šéªŒè¯ä¼˜åŒ–æ•ˆæœ
```

**ğŸ“Š åŸºç¡€æ€§èƒ½æŒ‡æ ‡æŸ¥è¯¢**
```sql
-- æŸ¥çœ‹å½“å‰äº‹åŠ¡çŠ¶æ€
SELECT 
    pid,
    usename,
    application_name,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity 
WHERE state IN ('active', 'idle in transaction', 'idle in transaction (aborted)')
ORDER BY query_start;

-- äº‹åŠ¡è¿è¡Œæ—¶é—´ç»Ÿè®¡
SELECT 
    pid,
    usename,
    EXTRACT(EPOCH FROM (now() - xact_start)) as transaction_duration_seconds,
    EXTRACT(EPOCH FROM (now() - query_start)) as query_duration_seconds,
    state,
    LEFT(query, 100) as query_preview
FROM pg_stat_activity 
WHERE xact_start IS NOT NULL
ORDER BY transaction_duration_seconds DESC;
```

---

## 2. ğŸ”’ é”ç«äº‰ä¼˜åŒ–ç­–ç•¥


### 2.1 ç†è§£é”ç«äº‰çš„æœ¬è´¨


**ä»€ä¹ˆæ˜¯é”ç«äº‰ï¼Ÿ**

é”ç«äº‰å‘ç”Ÿåœ¨å¤šä¸ªäº‹åŠ¡åŒæ—¶éœ€è¦è®¿é—®ç›¸åŒçš„æ•°æ®èµ„æºæ—¶ã€‚å°±åƒå¤šä¸ªäººåŒæ—¶è¦ä½¿ç”¨åŒä¸€é—´ä¼šè®®å®¤ï¼Œå¿…é¡»æ’é˜Ÿç­‰å¾…ã€‚

> **ğŸ” ç”Ÿæ´»åŒ–ç†è§£**
>
> æƒ³è±¡ä¸€ä¸ªé“¶è¡ŒæŸœå°ï¼Œå¤šä¸ªå®¢æˆ·ï¼ˆäº‹åŠ¡ï¼‰åŒæ—¶è¦åŠç†ä¸šåŠ¡ï¼ˆè®¿é—®æ•°æ®ï¼‰ã€‚å¦‚æœä¸šåŠ¡éœ€è¦ç‹¬å æŸœå°ï¼ˆæ’ä»–é”ï¼‰ï¼Œå…¶ä»–å®¢æˆ·å°±å¿…é¡»ç­‰å¾…ã€‚é”ç«äº‰ä¼˜åŒ–å°±æ˜¯è¦å‡å°‘ç­‰å¾…æ—¶é—´ï¼Œæé«˜åŠäº‹æ•ˆç‡ã€‚

### 2.2 é”ç«äº‰çš„ç›‘æ§ä¸è¯Šæ–­


**ğŸ” é”ç­‰å¾…ç›‘æ§æŸ¥è¯¢**
```sql
-- æŸ¥çœ‹å½“å‰é”ç­‰å¾…æƒ…å†µ
CREATE OR REPLACE VIEW lock_monitoring AS
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_locks.mode AS blocked_mode,
    blocking_locks.mode AS blocking_mode,
    blocked_locks.locktype,
    blocked_locks.relation::regclass AS relation_name,
    EXTRACT(EPOCH FROM (now() - blocked_activity.query_start)) AS wait_time_seconds
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- ä½¿ç”¨ç›‘æ§è§†å›¾
SELECT * FROM lock_monitoring 
WHERE wait_time_seconds > 1  -- ç­‰å¾…è¶…è¿‡1ç§’çš„é”
ORDER BY wait_time_seconds DESC;
```

**ğŸ“ˆ é”ç«äº‰çƒ­ç‚¹åˆ†æ**
```sql
-- åˆ†æé”ç«äº‰çƒ­ç‚¹è¡¨
WITH lock_stats AS (
    SELECT 
        schemaname,
        relname,
        n_tup_ins + n_tup_upd + n_tup_del as total_modifications,
        n_tup_hot_upd,
        n_dead_tup,
        last_vacuum,
        last_autovacuum,
        last_analyze,
        last_autoanalyze
    FROM pg_stat_user_tables
)
SELECT 
    schemaname || '.' || relname as table_name,
    total_modifications as "æ€»ä¿®æ”¹æ¬¡æ•°",
    n_hot_upd as "HOTæ›´æ–°æ¬¡æ•°",
    n_dead_tup as "æ­»å…ƒç»„æ•°é‡",
    CASE 
        WHEN last_vacuum > last_autovacuum THEN last_vacuum
        ELSE last_autovacuum 
    END as "æœ€åæ¸…ç†æ—¶é—´",
    -- é”ç«äº‰é£é™©è¯„ä¼°
    CASE 
        WHEN total_modifications > 100000 AND n_dead_tup > 10000 THEN 'ğŸ”´ é«˜é£é™©'
        WHEN total_modifications > 50000 OR n_dead_tup > 5000 THEN 'ğŸŸ¡ ä¸­é£é™©'
        ELSE 'ğŸŸ¢ ä½é£é™©'
    END as "é”ç«äº‰é£é™©"
FROM lock_stats
ORDER BY total_modifications DESC
LIMIT 20;
```

### 2.3 å‡å°‘é”ç«äº‰çš„ç­–ç•¥


**ğŸ› ï¸ ç­–ç•¥1ï¼šä¼˜åŒ–äº‹åŠ¡è®¾è®¡**

```sql
-- âŒ é”™è¯¯åšæ³•ï¼šäº‹åŠ¡æ—¶é—´è¿‡é•¿
BEGIN;
    SELECT * FROM products WHERE id = 1 FOR UPDATE;  -- è·å–é”
    -- æ‰§è¡Œå¤æ‚ä¸šåŠ¡é€»è¾‘...
    PERFORM pg_sleep(5);  -- æ¨¡æ‹Ÿé•¿æ—¶é—´å¤„ç†
    UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;

-- âœ… æ­£ç¡®åšæ³•ï¼šç¼©çŸ­äº‹åŠ¡æ—¶é—´
-- ç¬¬ä¸€æ­¥ï¼šåœ¨äº‹åŠ¡å¤–åšå‡†å¤‡å·¥ä½œ
SELECT * FROM products WHERE id = 1;
-- æ‰§è¡Œå¤æ‚è®¡ç®—...

-- ç¬¬äºŒæ­¥ï¼šäº‹åŠ¡å†…å¿«é€Ÿå®Œæˆå…³é”®æ“ä½œ
BEGIN;
    UPDATE products SET stock = stock - 1 
    WHERE id = 1 AND stock > 0;
    
    -- æ£€æŸ¥æ›´æ–°æ˜¯å¦æˆåŠŸ
    IF NOT FOUND THEN
        ROLLBACK;
        -- å¤„ç†åº“å­˜ä¸è¶³æƒ…å†µ
    END IF;
COMMIT;
```

**ğŸ› ï¸ ç­–ç•¥2ï¼šä¼˜åŒ–é”ç²’åº¦**

```sql
-- âŒ é”™è¯¯åšæ³•ï¼šé”å®šæ•´å¼ è¡¨
BEGIN;
    LOCK TABLE orders IN ACCESS EXCLUSIVE MODE;  -- é”å®šæ•´è¡¨
    INSERT INTO orders (user_id, product_id, amount) 
    VALUES (1, 100, 299.99);
COMMIT;

-- âœ… æ­£ç¡®åšæ³•ï¼šåªé”å®šå¿…è¦çš„è¡Œ
BEGIN;
    -- åªé”å®šç›¸å…³çš„è¡Œ
    SELECT * FROM products 
    WHERE id = 100 AND stock > 0 
    FOR UPDATE SKIP LOCKED;  -- è·³è¿‡å·²é”å®šçš„è¡Œ
    
    INSERT INTO orders (user_id, product_id, amount) 
    VALUES (1, 100, 299.99);
    
    UPDATE products SET stock = stock - 1 
    WHERE id = 100;
COMMIT;
```

**ğŸ› ï¸ ç­–ç•¥3ï¼šä½¿ç”¨ä¹è§‚é”**

```sql
-- ä¹è§‚é”å®ç°ï¼šä½¿ç”¨ç‰ˆæœ¬å·æ§åˆ¶
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    stock INTEGER,
    version INTEGER DEFAULT 1,  -- ç‰ˆæœ¬å·å­—æ®µ
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ä¹è§‚é”æ›´æ–°æ“ä½œ
UPDATE products 
SET 
    stock = stock - 1,
    version = version + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1 
  AND version = 5  -- æ£€æŸ¥ç‰ˆæœ¬å·
  AND stock > 0;

-- æ£€æŸ¥æ›´æ–°ç»“æœ
IF NOT FOUND THEN
    -- ç‰ˆæœ¬å†²çªæˆ–åº“å­˜ä¸è¶³ï¼Œéœ€è¦é‡è¯•æˆ–å¤„ç†
    RAISE EXCEPTION 'æ›´æ–°å¤±è´¥ï¼šæ•°æ®å·²è¢«ä¿®æ”¹æˆ–åº“å­˜ä¸è¶³';
END IF;
```

### 2.4 æ­»é”æ£€æµ‹ä¸é¢„é˜²


**ğŸ” æ­»é”ç›‘æ§**
```sql
-- æŸ¥çœ‹æ­»é”ç»Ÿè®¡
SELECT 
    datname as "æ•°æ®åº“å",
    deadlocks as "æ­»é”æ¬¡æ•°",
    deadlocks::float / (deadlocks + xact_commit + xact_rollback) * 100 as "æ­»é”ç‡(%)"
FROM pg_stat_database 
WHERE datname NOT IN ('template0', 'template1', 'postgres')
ORDER BY deadlocks DESC;

-- æ­»é”è¯¦ç»†ä¿¡æ¯ï¼ˆéœ€è¦å¼€å¯æ—¥å¿—è®°å½•ï¼‰
-- åœ¨postgresql.confä¸­è®¾ç½®ï¼š
-- log_lock_waits = on
-- deadlock_timeout = 1s
-- log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
```

**ğŸ›¡ï¸ æ­»é”é¢„é˜²ç­–ç•¥**
```sql
-- ç­–ç•¥1ï¼šç»Ÿä¸€çš„é”é¡ºåº
-- âŒ å¯èƒ½å¯¼è‡´æ­»é”çš„æ“ä½œé¡ºåº
-- äº‹åŠ¡Aï¼šå…ˆé”è¡¨Aï¼Œå†é”è¡¨B
-- äº‹åŠ¡Bï¼šå…ˆé”è¡¨Bï¼Œå†é”è¡¨A

-- âœ… é¢„é˜²æ­»é”ï¼šç»Ÿä¸€é”å®šé¡ºåº
-- æ‰€æœ‰äº‹åŠ¡éƒ½æŒ‰ç›¸åŒé¡ºåºé”å®šèµ„æº
BEGIN;
    -- æ€»æ˜¯æŒ‰IDå‡åºé”å®š
    SELECT * FROM users WHERE id = LEAST(1, 2) FOR UPDATE;
    SELECT * FROM users WHERE id = GREATEST(1, 2) FOR UPDATE;
    -- æ‰§è¡Œä¸šåŠ¡é€»è¾‘...
COMMIT;

-- ç­–ç•¥2ï¼šä½¿ç”¨è¶…æ—¶æœºåˆ¶
SET lock_timeout = '5s';  -- è®¾ç½®é”ç­‰å¾…è¶…æ—¶
BEGIN;
    -- å¦‚æœç­‰å¾…é”è¶…è¿‡5ç§’ï¼Œè‡ªåŠ¨å›æ»š
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

---

## 3. ğŸ“ äº‹åŠ¡æ—¥å¿—è°ƒä¼˜


### 3.1 ç†è§£äº‹åŠ¡æ—¥å¿—çš„ä½œç”¨


**ä»€ä¹ˆæ˜¯äº‹åŠ¡æ—¥å¿—ï¼Ÿ**

äº‹åŠ¡æ—¥å¿—ï¼ˆWAL - Write-Ahead Loggingï¼‰æ˜¯æ•°æ®åº“ä¿è¯ACIDç‰¹æ€§çš„å…³é”®æœºåˆ¶ã€‚å®ƒè®°å½•äº†æ‰€æœ‰å¯¹æ•°æ®çš„ä¿®æ”¹æ“ä½œï¼Œç¡®ä¿å³ä½¿ç³»ç»Ÿå´©æºƒä¹Ÿèƒ½æ¢å¤æ•°æ®çš„ä¸€è‡´æ€§ã€‚

> **ğŸ” ç±»æ¯”ç†è§£**
>
> äº‹åŠ¡æ—¥å¿—å°±åƒä¸€ä¸ªè¯¦ç»†çš„æ“ä½œè®°å½•æœ¬ã€‚æ¯”å¦‚é“¶è¡Œè½¬è´¦ï¼Œåœ¨å®é™…è½¬ç§»èµ„é‡‘ä¹‹å‰ï¼Œä¼šå…ˆåœ¨è®°å½•æœ¬ä¸Šå†™ä¸‹"ä»è´¦æˆ·Aæ‰£é™¤100å…ƒï¼Œå‘è´¦æˆ·Bå¢åŠ 100å…ƒ"ã€‚å¦‚æœä¸­é€”å‡ºç°é—®é¢˜ï¼Œå¯ä»¥æ ¹æ®è®°å½•æœ¬æ¥æ¢å¤æˆ–æ’¤é”€æ“ä½œã€‚

### 3.2 WALé…ç½®ä¼˜åŒ–


**ğŸ“Š WALæ€§èƒ½ç›¸å…³å‚æ•°**

| å‚æ•°åç§° | **é»˜è®¤å€¼** | **æ¨èå€¼** | **ä½œç”¨è¯´æ˜** |
|---------|-----------|-----------|-------------|
| `wal_buffers` | `16MB` | `å†…å­˜çš„1-3%` | `WALç¼“å†²åŒºå¤§å°ï¼Œå½±å“å†™å…¥æ€§èƒ½` |
| `checkpoint_completion_target` | `0.5` | `0.7-0.9` | `æ£€æŸ¥ç‚¹å®Œæˆæ—¶é—´åˆ†å¸ƒï¼Œå‡å°‘IOå³°å€¼` |
| `max_wal_size` | `1GB` | `2-4GB` | `WALæ–‡ä»¶æœ€å¤§å¤§å°ï¼Œå½±å“æ£€æŸ¥ç‚¹é¢‘ç‡` |
| `min_wal_size` | `80MB` | `512MB-1GB` | `WALæ–‡ä»¶æœ€å°ä¿ç•™å¤§å°` |
| `wal_compression` | `off` | `on` | `WALå‹ç¼©ï¼Œå‡å°‘ç£ç›˜ç©ºé—´å’ŒIO` |

**ğŸ”§ WALä¼˜åŒ–é…ç½®ç¤ºä¾‹**
```sql
-- æŸ¥çœ‹å½“å‰WALé…ç½®
SELECT name, setting, unit, short_desc 
FROM pg_settings 
WHERE name IN (
    'wal_buffers', 
    'checkpoint_completion_target',
    'max_wal_size',
    'min_wal_size',
    'wal_compression'
)
ORDER BY name;

-- ä¼˜åŒ–åçš„é…ç½®å»ºè®®
-- åœ¨postgresql.confä¸­è®¾ç½®ï¼š

-- WALç¼“å†²åŒºå¤§å°ï¼ˆå†…å­˜çš„1-3%ï¼‰
wal_buffers = 256MB

-- æ£€æŸ¥ç‚¹å®Œæˆæ—¶é—´ï¼ˆ0.7-0.9ä¹‹é—´ï¼Œé¿å…IOå³°å€¼ï¼‰
checkpoint_completion_target = 0.8

-- WALæ–‡ä»¶å¤§å°é™åˆ¶
max_wal_size = 4GB
min_wal_size = 1GB

-- å¯ç”¨WALå‹ç¼©
wal_compression = on

-- åŒæ­¥æ–¹å¼ï¼ˆæ ¹æ®æ•°æ®é‡è¦æ€§è°ƒæ•´ï¼‰
synchronous_commit = on  -- é«˜å®‰å…¨æ€§
-- synchronous_commit = off  -- é«˜æ€§èƒ½ï¼ˆæœ‰æ•°æ®ä¸¢å¤±é£é™©ï¼‰
```

### 3.3 WALæ€§èƒ½ç›‘æ§


**ğŸ“ˆ WALå†™å…¥æ€§èƒ½ç›‘æ§**
```sql
-- WALç»Ÿè®¡ä¿¡æ¯
SELECT 
    wal_records as "WALè®°å½•æ•°",
    wal_fpi as "å…¨é¡µå†™å…¥æ•°",
    wal_bytes as "WALå­—èŠ‚æ•°",
    wal_buffers_full as "WALç¼“å†²åŒºæ»¡æ¬¡æ•°",
    wal_write as "WALå†™å…¥æ¬¡æ•°",
    wal_sync as "WALåŒæ­¥æ¬¡æ•°",
    wal_write_time as "WALå†™å…¥æ—¶é—´(ms)",
    wal_sync_time as "WALåŒæ­¥æ—¶é—´(ms)",
    stats_reset as "ç»Ÿè®¡é‡ç½®æ—¶é—´"
FROM pg_stat_wal;

-- è®¡ç®—WALå†™å…¥æ•ˆç‡
WITH wal_metrics AS (
    SELECT 
        wal_bytes,
        wal_write_time,
        wal_sync_time,
        wal_write + wal_sync as total_operations
    FROM pg_stat_wal
)
SELECT 
    ROUND(wal_bytes / 1024.0 / 1024.0, 2) as "WALæ€»å¤§å°(MB)",
    ROUND(wal_write_time::numeric / 1000.0, 2) as "å†™å…¥æ—¶é—´(ç§’)",
    ROUND(wal_sync_time::numeric / 1000.0, 2) as "åŒæ­¥æ—¶é—´(ç§’)",
    CASE 
        WHEN total_operations > 0 THEN 
            ROUND((wal_write_time + wal_sync_time)::numeric / total_operations, 2)
        ELSE 0 
    END as "å¹³å‡æ“ä½œæ—¶é—´(ms)",
    CASE 
        WHEN wal_write_time + wal_sync_time > 0 THEN 
            ROUND(wal_bytes / 1024.0 / 1024.0 / ((wal_write_time + wal_sync_time) / 1000.0), 2)
        ELSE 0 
    END as "WALå†™å…¥é€Ÿåº¦(MB/s)"
FROM wal_metrics;
```

**ğŸ” æ£€æŸ¥ç‚¹æ€§èƒ½åˆ†æ**
```sql
-- æ£€æŸ¥ç‚¹ç»Ÿè®¡
SELECT 
    checkpoints_timed as "å®šæ—¶æ£€æŸ¥ç‚¹",
    checkpoints_req as "è¯·æ±‚æ£€æŸ¥ç‚¹", 
    checkpoint_write_time as "æ£€æŸ¥ç‚¹å†™å…¥æ—¶é—´(ms)",
    checkpoint_sync_time as "æ£€æŸ¥ç‚¹åŒæ­¥æ—¶é—´(ms)",
    buffers_checkpoint as "æ£€æŸ¥ç‚¹ç¼“å†²åŒº",
    buffers_clean as "æ¸…ç†ç¼“å†²åŒº",
    buffers_backend as "åç«¯ç¼“å†²åŒº",
    buffers_backend_fsync as "åç«¯fsyncç¼“å†²åŒº",
    stats_reset as "ç»Ÿè®¡é‡ç½®æ—¶é—´"
FROM pg_stat_bgwriter;

-- æ£€æŸ¥ç‚¹é¢‘ç‡åˆ†æ
WITH checkpoint_analysis AS (
    SELECT 
        checkpoints_timed + checkpoints_req as total_checkpoints,
        checkpoints_timed,
        checkpoints_req,
        EXTRACT(EPOCH FROM (now() - stats_reset)) / 3600 as hours_since_reset
    FROM pg_stat_bgwriter
)
SELECT 
    ROUND(total_checkpoints / hours_since_reset, 2) as "æ£€æŸ¥ç‚¹é¢‘ç‡(æ¬¡/å°æ—¶)",
    ROUND(checkpoints_timed::numeric / total_checkpoints * 100, 2) as "å®šæ—¶æ£€æŸ¥ç‚¹æ¯”ä¾‹(%)",
    ROUND(checkpoints_req::numeric / total_checkpoints * 100, 2) as "å¼ºåˆ¶æ£€æŸ¥ç‚¹æ¯”ä¾‹(%)",
    CASE 
        WHEN checkpoints_req::numeric / total_checkpoints > 0.1 THEN 
            'ğŸ”´ å»ºè®®å¢åŠ max_wal_size'
        ELSE 'ğŸŸ¢ æ£€æŸ¥ç‚¹é¢‘ç‡æ­£å¸¸'
    END as "ä¼˜åŒ–å»ºè®®"
FROM checkpoint_analysis;
```

### 3.4 æ—¥å¿—å†™å…¥æ¨¡å¼ä¼˜åŒ–


**âš¡ åŒæ­¥æ¨¡å¼è°ƒä¼˜**
```sql
-- ä¸åŒåŒæ­¥æ¨¡å¼çš„æ€§èƒ½å¯¹æ¯”æµ‹è¯•
CREATE OR REPLACE FUNCTION test_sync_performance(
    test_name TEXT,
    sync_mode TEXT,
    test_iterations INTEGER DEFAULT 1000
) RETURNS TABLE (
    test_scenario TEXT,
    avg_time_ms NUMERIC,
    total_time_ms NUMERIC,
    tps NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    i INTEGER;
BEGIN
    -- è®¾ç½®åŒæ­¥æ¨¡å¼
    EXECUTE format('SET LOCAL synchronous_commit = %L', sync_mode);
    
    -- å¼€å§‹æ€§èƒ½æµ‹è¯•
    start_time := clock_timestamp();
    
    FOR i IN 1..test_iterations LOOP
        BEGIN
            INSERT INTO test_performance_log (test_name, iteration, log_time) 
            VALUES (test_name, i, CURRENT_TIMESTAMP);
        EXCEPTION WHEN OTHERS THEN
            -- å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­æµ‹è¯•
        END;
    END LOOP;
    
    end_time := clock_timestamp();
    
    -- è®¡ç®—æ€§èƒ½æŒ‡æ ‡
    test_scenario := format('%s (sync=%s)', test_name, sync_mode);
    total_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    avg_time_ms := total_time_ms / test_iterations;
    tps := test_iterations / EXTRACT(EPOCH FROM (end_time - start_time));
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºæµ‹è¯•è¡¨
CREATE TABLE IF NOT EXISTS test_performance_log (
    id SERIAL PRIMARY KEY,
    test_name VARCHAR(50),
    iteration INTEGER,
    log_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- è¿è¡Œä¸åŒåŒæ­¥æ¨¡å¼çš„æ€§èƒ½æµ‹è¯•
SELECT * FROM test_sync_performance('å°äº‹åŠ¡æµ‹è¯•', 'on', 1000)
UNION ALL
SELECT * FROM test_sync_performance('å°äº‹åŠ¡æµ‹è¯•', 'off', 1000)
UNION ALL  
SELECT * FROM test_sync_performance('å°äº‹åŠ¡æµ‹è¯•', 'local', 1000);
```

---

## 4. ğŸ“¦ æ‰¹é‡æ“ä½œä¼˜åŒ–


### 4.1 æ‰¹é‡æ“ä½œçš„é‡è¦æ€§


**ä¸ºä»€ä¹ˆéœ€è¦æ‰¹é‡æ“ä½œä¼˜åŒ–ï¼Ÿ**

åœ¨å¤„ç†å¤§é‡æ•°æ®æ—¶ï¼Œå•æ¡è®°å½•çš„æ“ä½œæ–¹å¼ä¼šå¸¦æ¥å·¨å¤§çš„æ€§èƒ½å¼€é”€ã€‚æ‰¹é‡æ“ä½œé€šè¿‡å‡å°‘ç½‘ç»œå¾€è¿”ã€äº‹åŠ¡å¼€é”€å’Œé”ç«äº‰ï¼Œæ˜¾è‘—æå‡å¤„ç†æ•ˆç‡ã€‚

> **ğŸ“Š æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹**
>
> æ’å…¥10ä¸‡æ¡è®°å½•çš„æ€§èƒ½å¯¹æ¯”ï¼š
> - å•æ¡æ’å…¥ï¼šæ¯æ¬¡ä¸€ä¸ªINSERTï¼Œè€—æ—¶120åˆ†é’Ÿ
> - æ‰¹é‡æ’å…¥ï¼šæ¯æ¬¡1000æ¡è®°å½•ï¼Œè€—æ—¶3åˆ†é’Ÿ  
> - ä½¿ç”¨COPYï¼šç›´æ¥æ•°æ®å¯¼å…¥ï¼Œè€—æ—¶30ç§’
> 
> æ€§èƒ½æå‡å¯è¾¾240å€ï¼

### 4.2 æ‰¹é‡æ’å…¥ä¼˜åŒ–


**ğŸš€ é«˜æ•ˆæ‰¹é‡æ’å…¥ç­–ç•¥**

```sql
-- âŒ ä½æ•ˆçš„å•æ¡æ’å…¥
BEGIN;
FOR i IN 1..10000 LOOP
    INSERT INTO orders (user_id, product_id, amount, order_date)
    VALUES (1, 100, 99.99, CURRENT_DATE);
END LOOP;
COMMIT;

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ1ï¼šæ‰¹é‡VALUESæ’å…¥
INSERT INTO orders (user_id, product_id, amount, order_date)
VALUES 
    (1, 100, 99.99, CURRENT_DATE),
    (2, 101, 149.99, CURRENT_DATE),
    (3, 102, 199.99, CURRENT_DATE),
    -- ... ä¸€æ¬¡æ’å…¥å¤šæ¡è®°å½•
    (1000, 200, 299.99, CURRENT_DATE);

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ2ï¼šä½¿ç”¨unnestè¿›è¡Œæ‰¹é‡æ’å…¥
INSERT INTO orders (user_id, product_id, amount, order_date)
SELECT 
    unnest(ARRAY[1,2,3,4,5]) as user_id,
    unnest(ARRAY[100,101,102,103,104]) as product_id,
    unnest(ARRAY[99.99,149.99,199.99,249.99,299.99]) as amount,
    CURRENT_DATE as order_date;

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ3ï¼šCOPYå‘½ä»¤ï¼ˆæœ€é«˜æ•ˆï¼‰
COPY orders (user_id, product_id, amount, order_date) FROM STDIN WITH CSV;
1,100,99.99,2023-01-01
2,101,149.99,2023-01-01
3,102,199.99,2023-01-01
\.
```

**ğŸ“Š æ‰¹é‡æ’å…¥æ€§èƒ½æµ‹è¯•**
```sql
-- åˆ›å»ºæ‰¹é‡æ’å…¥æ€§èƒ½æµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION test_bulk_insert_performance()
RETURNS TABLE (
    method_name TEXT,
    records_count INTEGER,
    execution_time_ms NUMERIC,
    records_per_second NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    test_records INTEGER := 10000;
BEGIN
    -- æ¸…ç†æµ‹è¯•è¡¨
    TRUNCATE TABLE test_orders;
    
    -- æµ‹è¯•æ–¹æ³•1ï¼šå•æ¡æ’å…¥
    method_name := 'å•æ¡æ’å…¥';
    records_count := test_records;
    start_time := clock_timestamp();
    
    FOR i IN 1..test_records LOOP
        INSERT INTO test_orders (user_id, amount) VALUES (i % 100 + 1, random() * 1000);
    END LOOP;
    
    end_time := clock_timestamp();
    execution_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    records_per_second := test_records / EXTRACT(EPOCH FROM (end_time - start_time));
    RETURN NEXT;
    
    -- æ¸…ç†å¹¶æµ‹è¯•æ–¹æ³•2ï¼šæ‰¹é‡æ’å…¥
    TRUNCATE TABLE test_orders;
    method_name := 'æ‰¹é‡æ’å…¥(1000æ¡/æ‰¹)';
    start_time := clock_timestamp();
    
    FOR batch IN 0..(test_records/1000-1) LOOP
        INSERT INTO test_orders (user_id, amount)
        SELECT 
            (batch * 1000 + generate_series(1, 1000)) % 100 + 1,
            random() * 1000;
    END LOOP;
    
    end_time := clock_timestamp();
    execution_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    records_per_second := test_records / EXTRACT(EPOCH FROM (end_time - start_time));
    RETURN NEXT;
    
END;
$$ LANGUAGE plpgsql;

-- è¿è¡Œæ€§èƒ½æµ‹è¯•
SELECT * FROM test_bulk_insert_performance();
```

### 4.3 æ‰¹é‡æ›´æ–°ä¼˜åŒ–


**ğŸ”„ é«˜æ•ˆæ‰¹é‡æ›´æ–°ç­–ç•¥**

```sql
-- âŒ ä½æ•ˆçš„é€è¡Œæ›´æ–°
UPDATE products SET price = price * 1.1 WHERE category_id = 1;
UPDATE products SET price = price * 1.2 WHERE category_id = 2;
UPDATE products SET price = price * 1.15 WHERE category_id = 3;

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ1ï¼šå•ä¸ªSQLå¤„ç†å¤šç§æƒ…å†µ
UPDATE products 
SET price = price * CASE 
    WHEN category_id = 1 THEN 1.1
    WHEN category_id = 2 THEN 1.2
    WHEN category_id = 3 THEN 1.15
    ELSE 1.0
END
WHERE category_id IN (1, 2, 3);

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ2ï¼šä½¿ç”¨ä¸´æ—¶è¡¨è¿›è¡Œæ‰¹é‡æ›´æ–°
CREATE TEMP TABLE price_adjustments (
    category_id INTEGER,
    adjustment_factor NUMERIC(5,2)
);

INSERT INTO price_adjustments VALUES 
    (1, 1.1), (2, 1.2), (3, 1.15);

UPDATE products 
SET price = products.price * pa.adjustment_factor
FROM price_adjustments pa
WHERE products.category_id = pa.category_id;

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ3ï¼šä½¿ç”¨VALUESå­å¥è¿›è¡Œæ‰¹é‡æ›´æ–°
UPDATE products 
SET price = products.price * adjustments.factor
FROM (VALUES 
    (1, 1.1),
    (2, 1.2), 
    (3, 1.15)
) AS adjustments(category_id, factor)
WHERE products.category_id = adjustments.category_id;
```

### 4.4 æ‰¹é‡åˆ é™¤ä¼˜åŒ–


**ğŸ—‘ï¸ å®‰å…¨é«˜æ•ˆçš„æ‰¹é‡åˆ é™¤**

```sql
-- âŒ å±é™©çš„å¤§æ‰¹é‡åˆ é™¤ï¼ˆå¯èƒ½å¯¼è‡´é”ç­‰å¾…ï¼‰
DELETE FROM log_table WHERE log_date < '2023-01-01';  -- å¯èƒ½åˆ é™¤æ•°ç™¾ä¸‡æ¡è®°å½•

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ1ï¼šåˆ†æ‰¹åˆ é™¤
DO $$
DECLARE
    batch_size INTEGER := 10000;
    deleted_count INTEGER;
BEGIN
    LOOP
        DELETE FROM log_table 
        WHERE ctid IN (
            SELECT ctid FROM log_table 
            WHERE log_date < '2023-01-01'
            LIMIT batch_size
        );
        
        GET DIAGNOSTICS deleted_count = ROW_COUNT;
        
        -- å¦‚æœæ²¡æœ‰æ›´å¤šæ•°æ®å¯åˆ é™¤ï¼Œé€€å‡ºå¾ªç¯
        IF deleted_count = 0 THEN
            EXIT;
        END IF;
        
        -- åœ¨æ‰¹æ¬¡ä¹‹é—´æäº¤ï¼Œé‡Šæ”¾é”
        COMMIT;
        
        -- å¯é€‰ï¼šåœ¨æ‰¹æ¬¡é—´æš‚åœï¼Œå‡å°‘ç³»ç»Ÿè´Ÿè½½
        PERFORM pg_sleep(0.1);
    END LOOP;
END $$;

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ2ï¼šä½¿ç”¨åˆ†åŒºè¡¨çš„åˆ†åŒºåˆ é™¤
-- å¦‚æœæ•°æ®æŒ‰æ—¶é—´åˆ†åŒºï¼Œå¯ä»¥ç›´æ¥åˆ é™¤æ•´ä¸ªåˆ†åŒº
DROP TABLE log_table_2022_q4;  -- åˆ é™¤2022å¹´Q4åˆ†åŒº

-- âœ… ä¼˜åŒ–æ–¹æ¡ˆ3ï¼šå…ˆç§»åŠ¨æ•°æ®å†åˆ é™¤
-- ä¿ç•™éœ€è¦çš„æ•°æ®ï¼Œåˆ é™¤å…¶ä½™çš„
CREATE TABLE log_table_new AS 
SELECT * FROM log_table WHERE log_date >= '2023-01-01';

-- é‡å‘½åè¡¨
BEGIN;
    DROP TABLE log_table;
    ALTER TABLE log_table_new RENAME TO log_table;
    -- é‡å»ºç´¢å¼•å’Œçº¦æŸ...
COMMIT;
```

---

## 5. ğŸ”— ç´¢å¼•ä¸äº‹åŠ¡å…³ç³»


### 5.1 ç´¢å¼•å¯¹äº‹åŠ¡æ€§èƒ½çš„å½±å“


**ç´¢å¼•å¦‚ä½•å½±å“äº‹åŠ¡ï¼Ÿ**

ç´¢å¼•ä¸ä»…å½±å“æŸ¥è¯¢æ€§èƒ½ï¼Œæ›´é‡è¦çš„æ˜¯å½±å“äº‹åŠ¡çš„é”å®šèŒƒå›´å’Œå¹¶å‘èƒ½åŠ›ã€‚åˆé€‚çš„ç´¢å¼•å¯ä»¥å‡å°‘é”å†²çªï¼Œè€Œä¸å½“çš„ç´¢å¼•å¯èƒ½å¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚

> **ğŸ” ç†è§£ç´¢å¼•ä¸é”çš„å…³ç³»**
>
> ç´¢å¼•å°±åƒä¸€æœ¬ä¹¦çš„ç›®å½•ï¼Œå¸®åŠ©å¿«é€Ÿå®šä½å†…å®¹ã€‚åœ¨äº‹åŠ¡ä¸­ï¼Œç´¢å¼•å†³å®šäº†é”å®šçš„ç²¾ç¡®åº¦ï¼š
> - æœ‰ç²¾ç¡®ç´¢å¼•ï¼šåªé”å®šéœ€è¦çš„è¡Œï¼ˆè¡Œçº§é”ï¼‰
> - æ²¡æœ‰åˆé€‚ç´¢å¼•ï¼šå¯èƒ½é”å®šæ›´å¤šè¡Œæˆ–æ•´å¼ è¡¨ï¼ˆè¡¨çº§é”ï¼‰

### 5.2 ç´¢å¼•è®¾è®¡å¯¹å¹¶å‘çš„å½±å“


**ğŸ“Š ä¸åŒç´¢å¼•ç­–ç•¥çš„å¹¶å‘è¡¨ç°**

| ç´¢å¼•ç­–ç•¥ | **é”å®šèŒƒå›´** | **å¹¶å‘æ€§èƒ½** | **é€‚ç”¨åœºæ™¯** |
|---------|-------------|-------------|-------------|
| **ä¸»é”®ç´¢å¼•** | `ç²¾ç¡®è¡Œé”` | `ğŸŸ¢ æœ€ä½³` | `ç‚¹æŸ¥è¯¢æ›´æ–°` |
| **å”¯ä¸€ç´¢å¼•** | `ç²¾ç¡®è¡Œé”` | `ğŸŸ¢ å¾ˆå¥½` | `å”¯ä¸€çº¦æŸæ›´æ–°` |
| **éå”¯ä¸€ç´¢å¼•** | `è¡Œé”+é—´éš™é”` | `ğŸŸ¡ ä¸€èˆ¬` | `èŒƒå›´æŸ¥è¯¢æ›´æ–°` |
| **æ— ç´¢å¼•** | `è¡¨é”æˆ–æ‰«æé”` | `ğŸ”´ æœ€å·®` | `åº”é¿å…` |

**ğŸ”§ å¹¶å‘å‹å¥½çš„ç´¢å¼•è®¾è®¡**
```sql
-- ç¤ºä¾‹è¡¨ï¼šç”¨æˆ·è®¢å•
CREATE TABLE user_orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    order_date DATE NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    amount DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- âœ… å¹¶å‘å‹å¥½çš„ç´¢å¼•è®¾è®¡
-- 1. æ”¯æŒé«˜å¹¶å‘æŸ¥è¯¢çš„å¤åˆç´¢å¼•
CREATE INDEX idx_user_orders_user_status ON user_orders (user_id, status);
CREATE INDEX idx_user_orders_date_status ON user_orders (order_date, status);

-- 2. æ”¯æŒé«˜å¹¶å‘æ›´æ–°çš„éƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_user_orders_pending ON user_orders (user_id) 
WHERE status = 'pending';  -- åªå¯¹å¾…å¤„ç†è®¢å•å»ºç´¢å¼•

-- 3. æ”¯æŒèŒƒå›´æŸ¥è¯¢çš„ç´¢å¼•
CREATE INDEX idx_user_orders_amount_date ON user_orders (amount, order_date);

-- âŒ é¿å…çš„ç´¢å¼•è®¾è®¡
-- è¿‡å®½çš„å¤åˆç´¢å¼•ï¼ˆå¾ˆå°‘å…¨éƒ¨ç”¨åˆ°ï¼‰
-- CREATE INDEX idx_too_wide ON user_orders (user_id, product_id, order_date, status, amount);

-- å‡½æ•°ç´¢å¼•ï¼ˆå¢åŠ æ›´æ–°å¼€é”€ï¼‰
-- CREATE INDEX idx_expensive_func ON user_orders (EXTRACT(YEAR FROM order_date));
```

### 5.3 ç´¢å¼•ç»´æŠ¤å¯¹äº‹åŠ¡çš„å½±å“


**ğŸ”§ ç´¢å¼•ç»´æŠ¤ç­–ç•¥**
```sql
-- ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_tup_read as "ç´¢å¼•è¯»å–æ¬¡æ•°",
    idx_tup_fetch as "ç´¢å¼•è·å–æ¬¡æ•°", 
    idx_scan as "ç´¢å¼•æ‰«ææ¬¡æ•°",
    CASE 
        WHEN idx_scan = 0 THEN 'ğŸ”´ æœªä½¿ç”¨'
        WHEN idx_scan < 100 THEN 'ğŸŸ¡ ä½¿ç”¨è¾ƒå°‘'
        ELSE 'ğŸŸ¢ æ­£å¸¸ä½¿ç”¨'
    END as "ä½¿ç”¨çŠ¶æ€"
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- æ£€æŸ¥é‡å¤å’Œå†—ä½™ç´¢å¼•
WITH index_columns AS (
    SELECT 
        schemaname,
        tablename,
        indexname,
        STRING_AGG(attname, ',' ORDER BY attnum) as columns
    FROM pg_stats
    WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
    GROUP BY schemaname, tablename, indexname
)
SELECT 
    i1.schemaname,
    i1.tablename,
    i1.indexname as "ç´¢å¼•1",
    i2.indexname as "ç´¢å¼•2", 
    i1.columns as "ç›¸åŒåˆ—",
    'ğŸŸ¡ å¯èƒ½å†—ä½™' as "å»ºè®®"
FROM index_columns i1
JOIN index_columns i2 ON 
    i1.schemaname = i2.schemaname 
    AND i1.tablename = i2.tablename
    AND i1.columns = i2.columns
    AND i1.indexname < i2.indexname;  -- é¿å…é‡å¤æ¯”è¾ƒ
```

**âš¡ åœ¨çº¿ç´¢å¼•é‡å»º**
```sql
-- å®‰å…¨çš„åœ¨çº¿ç´¢å¼•é‡å»ºæ–¹å¼
-- 1. åˆ›å»ºæ–°ç´¢å¼•ï¼ˆCONCURRENTLYæ–¹å¼ï¼Œä¸é˜»å¡è¯»å†™ï¼‰
CREATE INDEX CONCURRENTLY idx_user_orders_new 
ON user_orders (user_id, order_date, status);

-- 2. æ£€æŸ¥æ–°ç´¢å¼•æ˜¯å¦åˆ›å»ºæˆåŠŸ
SELECT 
    indexname,
    indexdef,
    CASE WHEN indisvalid THEN 'âœ… æœ‰æ•ˆ' ELSE 'âŒ æ— æ•ˆ' END as status
FROM pg_indexes 
JOIN pg_index ON indexrelid = (schemaname||'.'||indexname)::regclass
WHERE tablename = 'user_orders' AND indexname = 'idx_user_orders_new';

-- 3. å¦‚æœæˆåŠŸï¼Œåˆ é™¤æ—§ç´¢å¼•å¹¶é‡å‘½å
BEGIN;
    DROP INDEX idx_user_orders_old;
    ALTER INDEX idx_user_orders_new RENAME TO idx_user_orders_optimized;
COMMIT;
```

### 5.4 ç´¢å¼•é€‰æ‹©æ€§ä¸äº‹åŠ¡æ•ˆç‡


**ğŸ“ˆ ç´¢å¼•é€‰æ‹©æ€§åˆ†æ**
```sql
-- åˆ†æç´¢å¼•é€‰æ‹©æ€§
CREATE OR REPLACE FUNCTION analyze_index_selectivity(
    table_name TEXT,
    column_name TEXT
) RETURNS TABLE (
    distinct_values BIGINT,
    total_values BIGINT,
    selectivity NUMERIC,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY EXECUTE format('
        SELECT 
            COUNT(DISTINCT %I) as distinct_values,
            COUNT(*) as total_values,
            ROUND(COUNT(DISTINCT %I)::numeric / COUNT(*), 4) as selectivity,
            CASE 
                WHEN COUNT(DISTINCT %I)::numeric / COUNT(*) > 0.1 THEN ''ğŸŸ¢ é«˜é€‰æ‹©æ€§ï¼Œé€‚åˆå»ºç´¢å¼•''
                WHEN COUNT(DISTINCT %I)::numeric / COUNT(*) > 0.01 THEN ''ğŸŸ¡ ä¸­ç­‰é€‰æ‹©æ€§ï¼Œè§†æƒ…å†µå»ºç´¢å¼•''
                ELSE ''ğŸ”´ ä½é€‰æ‹©æ€§ï¼Œä¸å»ºè®®å»ºç´¢å¼•''
            END as recommendation
        FROM %I
    ', column_name, column_name, column_name, column_name, table_name);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM analyze_index_selectivity('user_orders', 'user_id');
SELECT * FROM analyze_index_selectivity('user_orders', 'status');
SELECT * FROM analyze_index_selectivity('user_orders', 'order_date');
```

---

## 6. ğŸ“Š äº‹åŠ¡ç›‘æ§æŒ‡æ ‡ä½“ç³»


### 6.1 å…³é”®æ€§èƒ½æŒ‡æ ‡KPI


**ğŸ¯ æ ¸å¿ƒKPIæŒ‡æ ‡å®šä¹‰**

| æŒ‡æ ‡ç±»åˆ« | **æŒ‡æ ‡åç§°** | **æ­£å¸¸èŒƒå›´** | **å‘Šè­¦é˜ˆå€¼** | **ä¼˜åŒ–ç›®æ ‡** |
|---------|-------------|-------------|-------------|-------------|
| **ååé‡** | `TPSï¼ˆæ¯ç§’äº‹åŠ¡æ•°ï¼‰` | `>1000` | `<500` | `æœ€å¤§åŒ–` |
| **å“åº”æ—¶é—´** | `å¹³å‡äº‹åŠ¡æ—¶é—´` | `<100ms` | `>500ms` | `æœ€å°åŒ–` |
| **å¹¶å‘æ€§** | `æ´»è·ƒäº‹åŠ¡æ•°` | `<100` | `>500` | `æ§åˆ¶åœ¨åˆç†èŒƒå›´` |
| **é”ç­‰å¾…** | `é”ç­‰å¾…æ—¶é—´` | `<10ms` | `>1000ms` | `æœ€å°åŒ–` |
| **æ­»é”ç‡** | `æ­»é”æ¬¡æ•°/æ€»äº‹åŠ¡` | `<0.01%` | `>0.1%` | `æ¥è¿‘é›¶` |

### 6.2 äº‹åŠ¡ååé‡ç›‘æ§


**ğŸ“ˆ å®æ—¶TPSç›‘æ§**
```sql
-- åˆ›å»ºTPSç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW transaction_throughput_monitor AS
WITH current_stats AS (
    SELECT 
        datname,
        xact_commit,
        xact_rollback,
        xact_commit + xact_rollback as total_transactions,
        stats_reset,
        EXTRACT(EPOCH FROM (now() - stats_reset)) as uptime_seconds
    FROM pg_stat_database
    WHERE datname NOT IN ('template0', 'template1')
),
tps_calc AS (
    SELECT 
        datname as "æ•°æ®åº“",
        total_transactions as "æ€»äº‹åŠ¡æ•°",
        ROUND(xact_commit::numeric / (xact_commit + xact_rollback) * 100, 2) as "æäº¤ç‡(%)",
        ROUND(total_transactions / uptime_seconds, 2) as "å¹³å‡TPS",
        CASE 
            WHEN total_transactions / uptime_seconds > 1000 THEN 'ğŸŸ¢ ä¼˜ç§€'
            WHEN total_transactions / uptime_seconds > 500 THEN 'ğŸŸ¡ ä¸€èˆ¬'
            ELSE 'ğŸ”´ éœ€è¦ä¼˜åŒ–'
        END as "TPSçŠ¶æ€"
    FROM current_stats
)
SELECT * FROM tps_calc ORDER BY "å¹³å‡TPS" DESC;

-- æŸ¥çœ‹å®æ—¶TPS
SELECT * FROM transaction_throughput_monitor;

-- å®æ—¶TPSè®¡ç®—ï¼ˆåŸºäºæœ€è¿‘ä¸€åˆ†é’Ÿï¼‰
WITH tps_snapshot AS (
    SELECT 
        datname,
        xact_commit + xact_rollback as transactions_now,
        pg_sleep(60), -- ç­‰å¾…1åˆ†é’Ÿ
        NULL -- å ä½ç¬¦
    FROM pg_stat_database 
    WHERE datname = current_database()
),
tps_after AS (
    SELECT 
        datname,
        xact_commit + xact_rollback as transactions_after
    FROM pg_stat_database 
    WHERE datname = current_database()
)
SELECT 
    (transactions_after - transactions_now) / 60.0 as "å®æ—¶TPS"
FROM tps_snapshot, tps_after;
```

### 6.3 å“åº”æ—¶é—´ç»Ÿè®¡


**â±ï¸ äº‹åŠ¡å“åº”æ—¶é—´åˆ†æ**
```sql
-- æŸ¥çœ‹é•¿æ—¶é—´è¿è¡Œçš„äº‹åŠ¡
SELECT 
    pid,
    usename as "ç”¨æˆ·",
    application_name as "åº”ç”¨",
    state as "çŠ¶æ€",
    EXTRACT(EPOCH FROM (now() - xact_start)) as "äº‹åŠ¡è¿è¡Œæ—¶é—´(ç§’)",
    EXTRACT(EPOCH FROM (now() - query_start)) as "æŸ¥è¯¢è¿è¡Œæ—¶é—´(ç§’)",
    wait_event_type as "ç­‰å¾…äº‹ä»¶ç±»å‹",
    wait_event as "ç­‰å¾…äº‹ä»¶",
    LEFT(query, 100) as "æŸ¥è¯¢é¢„è§ˆ"
FROM pg_stat_activity 
WHERE state != 'idle' 
  AND xact_start IS NOT NULL
ORDER BY "äº‹åŠ¡è¿è¡Œæ—¶é—´(ç§’)" DESC;

-- å“åº”æ—¶é—´åˆ†å¸ƒç»Ÿè®¡ï¼ˆéœ€è¦å¼€å¯track_functionsï¼‰
-- åœ¨postgresql.confä¸­è®¾ç½®ï¼štrack_functions = 'all'
SELECT 
    funcname as "å‡½æ•°å",
    calls as "è°ƒç”¨æ¬¡æ•°",
    ROUND(total_time::numeric / calls, 2) as "å¹³å‡æ‰§è¡Œæ—¶é—´(ms)",
    ROUND(mean_time::numeric, 2) as "å¹³å‡æ—¶é—´(ms)",
    ROUND(stddev_time::numeric, 2) as "æ—¶é—´æ ‡å‡†å·®(ms)",
    CASE 
        WHEN mean_time > 1000 THEN 'ğŸ”´ æ…¢å‡½æ•°'
        WHEN mean_time > 100 THEN 'ğŸŸ¡ éœ€å…³æ³¨'
        ELSE 'ğŸŸ¢ æ­£å¸¸'
    END as "æ€§èƒ½çŠ¶æ€"
FROM pg_stat_user_functions 
WHERE calls > 0
ORDER BY mean_time DESC
LIMIT 20;
```

### 6.4 é”ç­‰å¾…ç›‘æ§


**ğŸ”’ é”ç­‰å¾…ç»Ÿè®¡**
```sql
-- åˆ›å»ºé”ç­‰å¾…ç›‘æ§å‡½æ•°
CREATE OR REPLACE FUNCTION monitor_lock_waits()
RETURNS TABLE (
    monitoring_time TIMESTAMP,
    total_locks INTEGER,
    waiting_locks INTEGER,
    avg_wait_time_seconds NUMERIC,
    max_wait_time_seconds NUMERIC,
    deadlock_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    WITH lock_summary AS (
        SELECT 
            COUNT(*) as total_locks,
            COUNT(CASE WHEN NOT granted THEN 1 END) as waiting_locks,
            COALESCE(AVG(EXTRACT(EPOCH FROM (now() - query_start))), 0) as avg_wait_time,
            COALESCE(MAX(EXTRACT(EPOCH FROM (now() - query_start))), 0) as max_wait_time
        FROM pg_locks l
        LEFT JOIN pg_stat_activity a ON l.pid = a.pid
        WHERE NOT granted
    ),
    deadlock_summary AS (
        SELECT COALESCE(SUM(deadlocks), 0) as total_deadlocks
        FROM pg_stat_database
    )
    SELECT 
        CURRENT_TIMESTAMP,
        ls.total_locks::INTEGER,
        ls.waiting_locks::INTEGER,
        ROUND(ls.avg_wait_time::numeric, 2),
        ROUND(ls.max_wait_time::numeric, 2),
        ds.total_deadlocks
    FROM lock_summary ls, deadlock_summary ds;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç›‘æ§å‡½æ•°
SELECT * FROM monitor_lock_waits();

-- é”ç­‰å¾…çƒ­ç‚¹åˆ†æ
SELECT 
    database_name,
    relation_name,
    lock_type,
    lock_mode,
    COUNT(*) as lock_count,
    COUNT(CASE WHEN NOT granted THEN 1 END) as waiting_count,
    ROUND(AVG(CASE WHEN NOT granted THEN 
        EXTRACT(EPOCH FROM (now() - query_start)) 
    END), 2) as avg_wait_time_seconds
FROM (
    SELECT 
        d.datname as database_name,
        COALESCE(c.relname, 'N/A') as relation_name,
        l.locktype as lock_type,
        l.mode as lock_mode,
        l.granted,
        a.query_start
    FROM pg_locks l
    LEFT JOIN pg_class c ON l.relation = c.oid
    LEFT JOIN pg_database d ON l.database = d.oid
    LEFT JOIN pg_stat_activity a ON l.pid = a.pid
) lock_details
GROUP BY database_name, relation_name, lock_type, lock_mode
HAVING COUNT(CASE WHEN NOT granted THEN 1 END) > 0
ORDER BY waiting_count DESC, avg_wait_time_seconds DESC;
```

### 6.5 æ­»é”ç»Ÿè®¡


**ğŸ’€ æ­»é”åˆ†æä¸æŠ¥å‘Š**
```sql
-- æ­»é”ç»Ÿè®¡æŠ¥å‘Š
CREATE OR REPLACE FUNCTION deadlock_analysis_report()
RETURNS TABLE (
    database_name TEXT,
    deadlock_count BIGINT,
    deadlock_rate_percent NUMERIC,
    avg_deadlocks_per_hour NUMERIC,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH db_stats AS (
        SELECT 
            datname,
            deadlocks,
            xact_commit + xact_rollback as total_transactions,
            EXTRACT(EPOCH FROM (now() - stats_reset)) / 3600 as hours_since_reset
        FROM pg_stat_database
        WHERE datname NOT IN ('template0', 'template1', 'postgres')
    )
    SELECT 
        datname,
        deadlocks,
        CASE 
            WHEN total_transactions > 0 THEN 
                ROUND(deadlocks::numeric / total_transactions * 100, 4)
            ELSE 0 
        END as deadlock_rate,
        CASE 
            WHEN hours_since_reset > 0 THEN 
                ROUND(deadlocks::numeric / hours_since_reset, 2)
            ELSE 0 
        END as deadlocks_per_hour,
        CASE 
            WHEN deadlocks = 0 THEN 'ğŸŸ¢ æ— æ­»é”'
            WHEN deadlocks::numeric / total_transactions < 0.0001 THEN 'ğŸŸ¡ æ­»é”ç‡è¾ƒä½'
            WHEN deadlocks::numeric / total_transactions < 0.001 THEN 'ğŸŸ  éœ€è¦å…³æ³¨'
            ELSE 'ğŸ”´ æ­»é”ç‡è¿‡é«˜ï¼Œéœ€è¦ä¼˜åŒ–'
        END as recommendation
    FROM db_stats
    ORDER BY deadlock_rate DESC;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥çœ‹æ­»é”åˆ†ææŠ¥å‘Š
SELECT * FROM deadlock_analysis_report();
```

### 6.6 å›æ»šç‡åˆ†æ


**ğŸ”„ äº‹åŠ¡å›æ»šç»Ÿè®¡**
```sql
-- äº‹åŠ¡å›æ»šç‡åˆ†æ
WITH transaction_stats AS (
    SELECT 
        datname as "æ•°æ®åº“",
        xact_commit as "æäº¤äº‹åŠ¡æ•°",
        xact_rollback as "å›æ»šäº‹åŠ¡æ•°",
        xact_commit + xact_rollback as "æ€»äº‹åŠ¡æ•°"
    FROM pg_stat_database
    WHERE datname NOT IN ('template0', 'template1')
)
SELECT 
    "æ•°æ®åº“",
    "æäº¤äº‹åŠ¡æ•°",
    "å›æ»šäº‹åŠ¡æ•°",
    "æ€»äº‹åŠ¡æ•°",
    CASE 
        WHEN "æ€»äº‹åŠ¡æ•°" > 0 THEN 
            ROUND("å›æ»šäº‹åŠ¡æ•°"::numeric / "æ€»äº‹åŠ¡æ•°" * 100, 2)
        ELSE 0 
    END as "å›æ»šç‡(%)",
    CASE 
        WHEN "æ€»äº‹åŠ¡æ•°" = 0 THEN 'âšª æ— æ•°æ®'
        WHEN "å›æ»šäº‹åŠ¡æ•°"::numeric / "æ€»äº‹åŠ¡æ•°" < 0.01 THEN 'ğŸŸ¢ å›æ»šç‡æ­£å¸¸'
        WHEN "å›æ»šäº‹åŠ¡æ•°"::numeric / "æ€»äº‹åŠ¡æ•°" < 0.05 THEN 'ğŸŸ¡ éœ€è¦å…³æ³¨'
        ELSE 'ğŸ”´ å›æ»šç‡è¿‡é«˜'
    END as "çŠ¶æ€è¯„ä¼°"
FROM transaction_stats
ORDER BY "å›æ»šç‡(%)" DESC;

-- åº”ç”¨çº§åˆ«çš„å›æ»šç‡åˆ†æ
SELECT 
    application_name as "åº”ç”¨åç§°",
    COUNT(*) as "è¿æ¥æ•°",
    SUM(CASE WHEN state = 'idle in transaction (aborted)' THEN 1 ELSE 0 END) as "å¤±è´¥äº‹åŠ¡æ•°",
    ROUND(
        SUM(CASE WHEN state = 'idle in transaction (aborted)' THEN 1 ELSE 0 END)::numeric 
        / COUNT(*) * 100, 2
    ) as "å¤±è´¥ç‡(%)"
FROM pg_stat_activity
WHERE application_name IS NOT NULL AND application_name != ''
GROUP BY application_name
ORDER BY "å¤±è´¥ç‡(%)" DESC;
```

### 6.7 ç›‘æ§æ•°æ®å¯è§†åŒ–


**ğŸ“Š ç›‘æ§æ•°æ®æ”¶é›†ä¸å­˜å‚¨**
```sql
-- åˆ›å»ºç›‘æ§æ•°æ®å†å²è¡¨
CREATE TABLE IF NOT EXISTS transaction_monitoring_history (
    id SERIAL PRIMARY KEY,
    monitoring_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    database_name VARCHAR(100),
    tps NUMERIC(10,2),
    avg_response_time_ms NUMERIC(10,2),
    active_transactions INTEGER,
    waiting_locks INTEGER,
    deadlock_count INTEGER,
    rollback_rate_percent NUMERIC(5,2)
);

-- ç›‘æ§æ•°æ®æ”¶é›†å‡½æ•°
CREATE OR REPLACE FUNCTION collect_monitoring_data()
RETURNS VOID AS $$
DECLARE
    db_record RECORD;
BEGIN
    -- éå†æ‰€æœ‰ç”¨æˆ·æ•°æ®åº“
    FOR db_record IN 
        SELECT datname FROM pg_database 
        WHERE datname NOT IN ('template0', 'template1', 'postgres')
    LOOP
        -- æ”¶é›†å½“å‰æ•°æ®åº“çš„ç›‘æ§æŒ‡æ ‡
        INSERT INTO transaction_monitoring_history (
            database_name, 
            tps, 
            avg_response_time_ms,
            active_transactions,
            waiting_locks,
            deadlock_count,
            rollback_rate_percent
        )
        SELECT 
            db_record.datname,
            -- TPSè®¡ç®—ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
            CASE 
                WHEN EXTRACT(EPOCH FROM (now() - stats_reset)) > 0 THEN
                    (xact_commit + xact_rollback) / EXTRACT(EPOCH FROM (now() - stats_reset))
                ELSE 0 
            END,
            -- å¹³å‡å“åº”æ—¶é—´ï¼ˆä½¿ç”¨æ´»è·ƒæŸ¥è¯¢çš„å¹³å‡æ—¶é—´ä¼°ç®—ï¼‰
            COALESCE(AVG(EXTRACT(EPOCH FROM (now() - query_start)) * 1000), 0),
            -- æ´»è·ƒäº‹åŠ¡æ•°
            COUNT(CASE WHEN state = 'active' THEN 1 END),
            -- ç­‰å¾…é”æ•°é‡ï¼ˆè¿™é‡Œç®€åŒ–ä¸º0ï¼Œå®é™…éœ€è¦å¤æ‚æŸ¥è¯¢ï¼‰
            0,
            -- æ­»é”æ•°é‡
            deadlocks,
            -- å›æ»šç‡
            CASE 
                WHEN xact_commit + xact_rollback > 0 THEN
                    xact_rollback::numeric / (xact_commit + xact_rollback) * 100
                ELSE 0 
            END
        FROM pg_stat_database 
        CROSS JOIN pg_stat_activity
        WHERE datname = db_record.datname
        GROUP BY datname, xact_commit, xact_rollback, deadlocks, stats_reset;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- è®¾ç½®å®šæ—¶æ”¶é›†ï¼ˆéœ€è¦é…åˆcronæˆ–å…¶ä»–è°ƒåº¦å·¥å…·ï¼‰
-- SELECT collect_monitoring_data();
```

**ğŸ“ˆ è¶‹åŠ¿åˆ†ææŸ¥è¯¢**
```sql
-- æœ€è¿‘24å°æ—¶çš„æ€§èƒ½è¶‹åŠ¿
SELECT 
    DATE_TRUNC('hour', monitoring_time) as "å°æ—¶",
    database_name as "æ•°æ®åº“",
    ROUND(AVG(tps), 2) as "å¹³å‡TPS",
    ROUND(AVG(avg_response_time_ms), 2) as "å¹³å‡å“åº”æ—¶é—´(ms)",
    ROUND(AVG(active_transactions), 0) as "å¹³å‡æ´»è·ƒäº‹åŠ¡",
    MAX(waiting_locks) as "æœ€å¤§ç­‰å¾…é”æ•°",
    SUM(deadlock_count) as "æ­»é”æ€»æ•°"
FROM transaction_monitoring_history
WHERE monitoring_time >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
GROUP BY DATE_TRUNC('hour', monitoring_time), database_name
ORDER BY "å°æ—¶" DESC, database_name;

-- æ€§èƒ½å¼‚å¸¸æ£€æµ‹
WITH performance_baseline AS (
    SELECT 
        database_name,
        AVG(tps) as baseline_tps,
        AVG(avg_response_time_ms) as baseline_response_time,
        STDDEV(tps) as tps_stddev,
        STDDEV(avg_response_time_ms) as response_time_stddev
    FROM transaction_monitoring_history
    WHERE monitoring_time >= CURRENT_TIMESTAMP - INTERVAL '7 days'
    GROUP BY database_name
)
SELECT 
    h.monitoring_time,
    h.database_name,
    h.tps,
    b.baseline_tps,
    h.avg_response_time_ms,
    b.baseline_response_time,
    CASE 
        WHEN h.tps < (b.baseline_tps - 2 * b.tps_stddev) THEN 'ğŸ”´ TPSå¼‚å¸¸ä½'
        WHEN h.avg_response_time_ms > (b.baseline_response_time + 2 * b.response_time_stddev) THEN 'ğŸ”´ å“åº”æ—¶é—´å¼‚å¸¸é«˜'
        ELSE 'ğŸŸ¢ æ­£å¸¸'
    END as "å¼‚å¸¸çŠ¶æ€"
FROM transaction_monitoring_history h
JOIN performance_baseline b ON h.database_name = b.database_name
WHERE h.monitoring_time >= CURRENT_TIMESTAMP - INTERVAL '2 hours'
  AND (h.tps < (b.baseline_tps - 2 * b.tps_stddev) 
       OR h.avg_response_time_ms > (b.baseline_response_time + 2 * b.response_time_stddev))
ORDER BY h.monitoring_time DESC;
```

---

## 7. ğŸ” æ€§èƒ½ç“¶é¢ˆè¯†åˆ«ä¸å®šä½


### 7.1 ç“¶é¢ˆå®šä½æŠ€æœ¯


**ğŸ¯ ç³»ç»Ÿæ€§ç“¶é¢ˆè¯†åˆ«æ–¹æ³•**

æ€§èƒ½ç“¶é¢ˆå¾€å¾€éšè—åœ¨ç³»ç»Ÿçš„å„ä¸ªå±‚é¢ï¼Œéœ€è¦ç³»ç»Ÿæ€§çš„åˆ†ææ–¹æ³•æ¥å®šä½æ ¹æœ¬åŸå› ã€‚

```
ç“¶é¢ˆè¯†åˆ«çš„å±‚æ¬¡ç»“æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨å±‚ç“¶é¢ˆ         â”‚ â† ä¸šåŠ¡é€»è¾‘ã€äº‹åŠ¡è®¾è®¡
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ•°æ®åº“å±‚ç“¶é¢ˆ       â”‚ â† SQLæŸ¥è¯¢ã€ç´¢å¼•ã€é”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚   å­˜å‚¨å±‚ç“¶é¢ˆ         â”‚ â† ç£ç›˜I/Oã€WALå†™å…¥
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ç½‘ç»œå±‚ç“¶é¢ˆ         â”‚ â† ç½‘ç»œå»¶è¿Ÿã€å¸¦å®½
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”¬ å¤šç»´åº¦æ€§èƒ½åˆ†æ**
```sql
-- ç»¼åˆæ€§èƒ½ç“¶é¢ˆåˆ†ææŠ¥å‘Š
CREATE OR REPLACE FUNCTION comprehensive_bottleneck_analysis()
RETURNS TABLE (
    analysis_category TEXT,
    metric_name TEXT,
    current_value TEXT,
    threshold_value TEXT,
    status TEXT,
    recommendation TEXT
) AS $$
BEGIN
    -- CPUä½¿ç”¨ç‡åˆ†æ
    analysis_category := 'CPUæ€§èƒ½';
    metric_name := 'æ´»è·ƒè¿æ¥æ•°';
    SELECT COUNT(*) INTO current_value 
    FROM pg_stat_activity WHERE state = 'active';
    threshold_value := '100';
    
    IF current_value::INTEGER > 100 THEN
        status := 'ğŸ”´ è¶…è¿‡é˜ˆå€¼';
        recommendation := 'æ£€æŸ¥æ…¢æŸ¥è¯¢ï¼Œè€ƒè™‘è¿æ¥æ± ä¼˜åŒ–';
    ELSE
        status := 'ğŸŸ¢ æ­£å¸¸';
        recommendation := 'è¿æ¥æ•°åœ¨åˆç†èŒƒå›´å†…';
    END IF;
    RETURN NEXT;
    
    -- å†…å­˜ä½¿ç”¨åˆ†æ
    analysis_category := 'å†…å­˜æ€§èƒ½';
    metric_name := 'ç¼“å†²åŒºå‘½ä¸­ç‡';
    WITH buffer_stats AS (
        SELECT 
            SUM(heap_blks_hit) as hits,
            SUM(heap_blks_read) as reads
        FROM pg_statio_user_tables
    )
    SELECT ROUND(hits::numeric / NULLIF(hits + reads, 0) * 100, 2)::TEXT
    INTO current_value FROM buffer_stats;
    threshold_value := '95';
    
    IF current_value::NUMERIC < 95 THEN
        status := 'ğŸŸ¡ éœ€è¦å…³æ³¨';
        recommendation := 'è€ƒè™‘å¢åŠ shared_buffersé…ç½®';
    ELSE
        status := 'ğŸŸ¢ æ­£å¸¸';
        recommendation := 'ç¼“å†²åŒºå‘½ä¸­ç‡è‰¯å¥½';
    END IF;
    RETURN NEXT;
    
    -- I/Oæ€§èƒ½åˆ†æ
    analysis_category := 'I/Oæ€§èƒ½';
    metric_name := 'WALå†™å…¥æ—¶é—´';
    SELECT wal_write_time::TEXT INTO current_value FROM pg_stat_wal;
    threshold_value := '1000';  -- 1ç§’
    
    IF current_value::NUMERIC > 1000 THEN
        status := 'ğŸ”´ I/Oç“¶é¢ˆ';
        recommendation := 'æ£€æŸ¥ç£ç›˜æ€§èƒ½ï¼Œè€ƒè™‘SSDå‡çº§';
    ELSE
        status := 'ğŸŸ¢ æ­£å¸¸';
        recommendation := 'I/Oæ€§èƒ½è‰¯å¥½';
    END IF;
    RETURN NEXT;
    
    -- é”ç«äº‰åˆ†æ
    analysis_category := 'é”ç«äº‰';
    metric_name := 'ç­‰å¾…é”æ•°é‡';
    SELECT COUNT(*)::TEXT INTO current_value 
    FROM pg_locks WHERE NOT granted;
    threshold_value := '10';
    
    IF current_value::INTEGER > 10 THEN
        status := 'ğŸ”´ é”ç«äº‰ä¸¥é‡';
        recommendation := 'åˆ†æé”ç­‰å¾…åŸå› ï¼Œä¼˜åŒ–äº‹åŠ¡è®¾è®¡';
    ELSE
        status := 'ğŸŸ¢ æ­£å¸¸';
        recommendation := 'é”ç«äº‰ç¨‹åº¦å¯æ¥å—';
    END IF;
    RETURN NEXT;
    
END;
$$ LANGUAGE plpgsql;

-- è¿è¡Œç»¼åˆåˆ†æ
SELECT * FROM comprehensive_bottleneck_analysis();
```

### 7.2 æ…¢æŸ¥è¯¢ä¸æ…¢äº‹åŠ¡åˆ†æ


**ğŸŒ æ…¢æŸ¥è¯¢è¯†åˆ«**
```sql
-- å¼€å¯æ…¢æŸ¥è¯¢è®°å½•ï¼ˆåœ¨postgresql.confä¸­é…ç½®ï¼‰
-- log_min_duration_statement = 1000  # è®°å½•è¶…è¿‡1ç§’çš„æŸ¥è¯¢
-- log_statement = 'all'              # è®°å½•æ‰€æœ‰è¯­å¥ï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰

-- å½“å‰è¿è¡Œä¸­çš„æ…¢æŸ¥è¯¢
SELECT 
    pid,
    usename as "ç”¨æˆ·",
    application_name as "åº”ç”¨",
    client_addr as "å®¢æˆ·ç«¯IP",
    EXTRACT(EPOCH FROM (now() - query_start)) as "æŸ¥è¯¢è¿è¡Œæ—¶é—´(ç§’)",
    EXTRACT(EPOCH FROM (now() - xact_start)) as "äº‹åŠ¡è¿è¡Œæ—¶é—´(ç§’)",
    state as "çŠ¶æ€",
    wait_event_type as "ç­‰å¾…äº‹ä»¶ç±»å‹",
    wait_event as "ç­‰å¾…äº‹ä»¶",
    LEFT(query, 200) as "æŸ¥è¯¢è¯­å¥",
    CASE 
        WHEN EXTRACT(EPOCH FROM (now() - query_start)) > 60 THEN 'ğŸ”´ ä¸¥é‡è¶…æ—¶'
        WHEN EXTRACT(EPOCH FROM (now() - query_start)) > 10 THEN 'ğŸŸ¡ è¿è¡Œè¾ƒæ…¢'
        ELSE 'ğŸŸ¢ æ­£å¸¸'
    END as "çŠ¶æ€è¯„ä¼°"
FROM pg_stat_activity 
WHERE state = 'active' 
  AND query_start IS NOT NULL
  AND EXTRACT(EPOCH FROM (now() - query_start)) > 1  -- è¿è¡Œè¶…è¿‡1ç§’
ORDER BY "æŸ¥è¯¢è¿è¡Œæ—¶é—´(ç§’)" DESC;

-- æ…¢äº‹åŠ¡åˆ†æ
WITH slow_transactions AS (
    SELECT 
        pid,
        usename,
        application_name,
        EXTRACT(EPOCH FROM (now() - xact_start)) as transaction_duration,
        EXTRACT(EPOCH FROM (now() - query_start)) as query_duration,
        state,
        query
    FROM pg_stat_activity 
    WHERE xact_start IS NOT NULL
      AND EXTRACT(EPOCH FROM (now() - xact_start)) > 10  -- äº‹åŠ¡è¿è¡Œè¶…è¿‡10ç§’
)
SELECT 
    pid as "è¿›ç¨‹ID",
    usename as "ç”¨æˆ·",
    application_name as "åº”ç”¨",
    ROUND(transaction_duration::numeric, 2) as "äº‹åŠ¡æŒç»­æ—¶é—´(ç§’)",
    ROUND(query_duration::numeric, 2) as "å½“å‰æŸ¥è¯¢æ—¶é—´(ç§’)",
    state as "çŠ¶æ€",
    LEFT(query, 150) as "æŸ¥è¯¢å†…å®¹",
    CASE 
        WHEN transaction_duration > 300 THEN 'ğŸ”´ äº‹åŠ¡è¿‡é•¿ï¼Œå½±å“ç³»ç»Ÿæ€§èƒ½'
        WHEN transaction_duration > 60 THEN 'ğŸŸ¡ äº‹åŠ¡è¾ƒé•¿ï¼Œéœ€è¦å…³æ³¨'
        ELSE 'ğŸŸ¢ äº‹åŠ¡æ—¶é—´å¯æ¥å—'
    END as "é£é™©è¯„ä¼°"
FROM slow_transactions
ORDER BY transaction_duration DESC;
```

### 7.3 èµ„æºä½¿ç”¨åˆ†æ


**ğŸ’¾ å†…å­˜ä½¿ç”¨åˆ†æ**
```sql
-- æ•°æ®åº“å†…å­˜ä½¿ç”¨ç»Ÿè®¡
SELECT 
    name as "é…ç½®é¡¹",
    setting as "å½“å‰å€¼",
    unit as "å•ä½",
    source as "é…ç½®æ¥æº",
    CASE name 
        WHEN 'shared_buffers' THEN 'å…±äº«ç¼“å†²åŒºï¼šæœ€é‡è¦çš„å†…å­˜é…ç½®'
        WHEN 'work_mem' THEN 'å·¥ä½œå†…å­˜ï¼šæ’åºå’Œå“ˆå¸Œæ“ä½œä½¿ç”¨'
        WHEN 'maintenance_work_mem' THEN 'ç»´æŠ¤å†…å­˜ï¼šVACUUMå’ŒCREATE INDEXä½¿ç”¨'
        WHEN 'wal_buffers' THEN 'WALç¼“å†²åŒºï¼šäº‹åŠ¡æ—¥å¿—ç¼“å†²'
        WHEN 'effective_cache_size' THEN 'ç³»ç»Ÿç¼“å­˜ï¼šæŸ¥è¯¢ä¼˜åŒ–å™¨ä½¿ç”¨çš„ä¼°ç®—å€¼'
        ELSE 'å…¶ä»–å†…å­˜é…ç½®'
    END as "è¯´æ˜"
FROM pg_settings 
WHERE name IN (
    'shared_buffers', 
    'work_mem', 
    'maintenance_work_mem',
    'wal_buffers',
    'effective_cache_size'
)
ORDER BY name;

-- ç¼“å†²åŒºä½¿ç”¨æƒ…å†µ
WITH buffer_usage AS (
    SELECT 
        SUM(heap_blks_read) as total_read,
        SUM(heap_blks_hit) as total_hit,
        SUM(idx_blks_read) as index_read,
        SUM(idx_blks_hit) as index_hit
    FROM pg_statio_user_tables
)
SELECT 
    total_read + total_hit as "æ€»ç¼“å†²åŒºè®¿é—®",
    total_hit as "ç¼“å†²åŒºå‘½ä¸­",
    total_read as "ç£ç›˜è¯»å–",
    ROUND(total_hit::numeric / NULLIF(total_read + total_hit, 0) * 100, 2) as "ç¼“å†²åŒºå‘½ä¸­ç‡(%)",
    index_hit as "ç´¢å¼•ç¼“å†²åŒºå‘½ä¸­",
    index_read as "ç´¢å¼•ç£ç›˜è¯»å–",
    ROUND(index_hit::numeric / NULLIF(index_read + index_hit, 0) * 100, 2) as "ç´¢å¼•å‘½ä¸­ç‡(%)",
    CASE 
        WHEN total_hit::numeric / NULLIF(total_read + total_hit, 0) > 0.95 THEN 'ğŸŸ¢ ç¼“å†²åŒºæ€§èƒ½ä¼˜ç§€'
        WHEN total_hit::numeric / NULLIF(total_read + total_hit, 0) > 0.90 THEN 'ğŸŸ¡ ç¼“å†²åŒºæ€§èƒ½ä¸€èˆ¬'
        ELSE 'ğŸ”´ ç¼“å†²åŒºæ€§èƒ½ä¸ä½³ï¼Œè€ƒè™‘å¢åŠ shared_buffers'
    END as "æ€§èƒ½è¯„ä¼°"
FROM buffer_usage;
```

**ğŸ’¿ ç£ç›˜I/Oåˆ†æ**
```sql
-- è¡¨çº§åˆ«çš„I/Oç»Ÿè®¡
SELECT 
    schemaname || '.' || relname as "è¡¨å",
    heap_blks_read as "è¡¨ç£ç›˜è¯»å–",
    heap_blks_hit as "è¡¨ç¼“å†²å‘½ä¸­",
    idx_blks_read as "ç´¢å¼•ç£ç›˜è¯»å–", 
    idx_blks_hit as "ç´¢å¼•ç¼“å†²å‘½ä¸­",
    ROUND(
        (heap_blks_read + idx_blks_read)::numeric / 
        NULLIF(heap_blks_read + heap_blks_hit + idx_blks_read + idx_blks_hit, 0) * 100, 2
    ) as "ç£ç›˜I/Oæ¯”ä¾‹(%)",
    CASE 
        WHEN (heap_blks_read + idx_blks_read) = 0 THEN 'ğŸŸ¢ å…¨ç¼“å­˜å‘½ä¸­'
        WHEN (heap_blks_read + idx_blks_read)::numeric / 
             NULLIF(heap_blks_read + heap_blks_hit + idx_blks_read + idx_blks_hit, 0) < 0.05 
        THEN 'ğŸŸ¢ I/Oè¾ƒå°‘'
        WHEN (heap_blks_read + idx_blks_read)::numeric / 
             NULLIF(heap_blks_read + heap_blks_hit + idx_blks_read + idx_blks_hit, 0) < 0.20 
        THEN 'ğŸŸ¡ I/Oé€‚ä¸­'
        ELSE 'ğŸ”´ I/Oå¯†é›†ï¼Œæ€§èƒ½ç“¶é¢ˆ'
    END as "I/OçŠ¶æ€"
FROM pg_statio_user_tables
WHERE heap_blks_read + heap_blks_hit + idx_blks_read + idx_blks_hit > 0
ORDER BY (heap_blks_read + idx_blks_read) DESC
LIMIT 20;

-- WAL I/Oæ€§èƒ½ç»Ÿè®¡
WITH wal_performance AS (
    SELECT 
        wal_records,
        wal_fpi,
        wal_bytes / 1024 / 1024 as wal_mb,
        wal_buffers_full,
        wal_write,
        wal_sync,
        wal_write_time,
        wal_sync_time,
        EXTRACT(EPOCH FROM (now() - stats_reset)) as uptime_seconds
    FROM pg_stat_wal
)
SELECT 
    wal_records as "WALè®°å½•æ•°",
    wal_fpi as "å…¨é¡µå†™å…¥æ•°",
    ROUND(wal_mb::numeric, 2) as "WALæ€»å¤§å°(MB)",
    wal_buffers_full as "WALç¼“å†²åŒºæ»¡æ¬¡æ•°",
    ROUND(wal_write_time::numeric / NULLIF(wal_write, 0), 2) as "å¹³å‡å†™å…¥æ—¶é—´(ms)",
    ROUND(wal_sync_time::numeric / NULLIF(wal_sync, 0), 2) as "å¹³å‡åŒæ­¥æ—¶é—´(ms)",
    ROUND(wal_mb / NULLIF(uptime_seconds / 3600, 0), 2) as "WALå†™å…¥é€Ÿåº¦(MB/å°æ—¶)",
    CASE 
        WHEN wal_buffers_full > wal_write * 0.1 THEN 'ğŸ”´ WALç¼“å†²åŒºä¸è¶³'
        WHEN wal_write_time / NULLIF(wal_write, 0) > 10 THEN 'ğŸ”´ WALå†™å…¥æ€§èƒ½å·®'
        ELSE 'ğŸŸ¢ WALæ€§èƒ½æ­£å¸¸'
    END as "WALæ€§èƒ½çŠ¶æ€"
FROM wal_performance;
```

### 7.4 ç½‘ç»œä¸è¿æ¥åˆ†æ


**ğŸŒ è¿æ¥æ± ä¸ç½‘ç»œæ€§èƒ½**
```sql
-- è¿æ¥çŠ¶æ€åˆ†æ
WITH connection_stats AS (
    SELECT 
        state,
        application_name,
        COUNT(*) as connection_count,
        AVG(EXTRACT(EPOCH FROM (now() - backend_start))) as avg_connection_age_seconds
    FROM pg_stat_activity
    GROUP BY state, application_name
)
SELECT 
    COALESCE(application_name, 'æœªçŸ¥åº”ç”¨') as "åº”ç”¨åç§°",
    state as "è¿æ¥çŠ¶æ€",
    connection_count as "è¿æ¥æ•°",
    ROUND(avg_connection_age_seconds::numeric / 3600, 2) as "å¹³å‡è¿æ¥æ—¶é•¿(å°æ—¶)",
    CASE 
        WHEN state = 'idle' AND connection_count > 50 THEN 'ğŸŸ¡ ç©ºé—²è¿æ¥è¿‡å¤š'
        WHEN state = 'active' AND connection_count > 100 THEN 'ğŸ”´ æ´»è·ƒè¿æ¥è¿‡å¤š'
        WHEN state = 'idle in transaction' AND connection_count > 10 THEN 'ğŸ”´ äº‹åŠ¡è¿æ¥æ³„éœ²'
        ELSE 'ğŸŸ¢ è¿æ¥çŠ¶æ€æ­£å¸¸'
    END as "çŠ¶æ€è¯„ä¼°"
FROM connection_stats
ORDER BY connection_count DESC;

-- è¿æ¥æ¥æºåˆ†æ
SELECT 
    client_addr as "å®¢æˆ·ç«¯IP",
    COUNT(*) as "è¿æ¥æ•°",
    COUNT(DISTINCT usename) as "ç”¨æˆ·æ•°",
    COUNT(DISTINCT application_name) as "åº”ç”¨æ•°",
    STRING_AGG(DISTINCT application_name, ', ') as "åº”ç”¨åˆ—è¡¨",
    MAX(EXTRACT(EPOCH FROM (now() - backend_start))) / 3600 as "æœ€é•¿è¿æ¥æ—¶é—´(å°æ—¶)",
    CASE 
        WHEN COUNT(*) > 100 THEN 'ğŸ”´ å•IPè¿æ¥è¿‡å¤š'
        WHEN COUNT(*) > 50 THEN 'ğŸŸ¡ éœ€è¦å…³æ³¨'
        ELSE 'ğŸŸ¢ æ­£å¸¸'
    END as "é£é™©è¯„ä¼°"
FROM pg_stat_activity
WHERE client_addr IS NOT NULL
GROUP BY client_addr
ORDER BY "è¿æ¥æ•°" DESC
LIMIT 20;
```

---

## 8. ğŸ”§ æ€§èƒ½è°ƒä¼˜æ–¹æ³•è®º


### 8.1 è°ƒä¼˜æ•ˆæœè¯„ä¼°


**ğŸ“Š è°ƒä¼˜å‰åå¯¹æ¯”æ¡†æ¶**

æ€§èƒ½è°ƒä¼˜å¿…é¡»åŸºäºæ•°æ®é©±åŠ¨çš„æ–¹æ³•ï¼Œå»ºç«‹åŸºçº¿ã€å®æ–½ä¼˜åŒ–ã€éªŒè¯æ•ˆæœã€‚

> **ğŸ’¡ è°ƒä¼˜æ–¹æ³•è®º**
>
> 1. **å»ºç«‹åŸºçº¿**ï¼šè®°å½•ä¼˜åŒ–å‰çš„æ€§èƒ½æŒ‡æ ‡
> 2. **é—®é¢˜å®šä½**ï¼šè¯†åˆ«æ€§èƒ½ç“¶é¢ˆçš„æ ¹æœ¬åŸå›   
> 3. **åˆ¶å®šæ–¹æ¡ˆ**ï¼šè®¾è®¡å…·ä½“çš„ä¼˜åŒ–æªæ–½
> 4. **å®æ–½ä¼˜åŒ–**ï¼šåœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯åå®æ–½
> 5. **æ•ˆæœè¯„ä¼°**ï¼šå¯¹æ¯”ä¼˜åŒ–å‰åçš„æ€§èƒ½æ•°æ®
> 6. **æŒç»­ç›‘æ§**ï¼šç¡®ä¿ä¼˜åŒ–æ•ˆæœçš„æŒç»­æ€§

```sql
-- åˆ›å»ºæ€§èƒ½åŸºçº¿è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS performance_baseline (
    id SERIAL PRIMARY KEY,
    baseline_name VARCHAR(100) NOT NULL,
    measurement_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    tps NUMERIC(10,2),
    avg_response_time_ms NUMERIC(10,2),
    p95_response_time_ms NUMERIC(10,2),
    cpu_usage_percent NUMERIC(5,2),
    memory_hit_ratio NUMERIC(5,4),
    active_connections INTEGER,
    waiting_locks INTEGER,
    deadlock_count INTEGER,
    notes TEXT
);

-- è®°å½•åŸºçº¿æ€§èƒ½
CREATE OR REPLACE FUNCTION record_performance_baseline(baseline_name TEXT, notes TEXT DEFAULT '')
RETURNS VOID AS $
DECLARE
    current_tps NUMERIC;
    current_response_time NUMERIC;
    current_hit_ratio NUMERIC;
    current_connections INTEGER;
    current_waiting_locks INTEGER;
BEGIN
    -- è®¡ç®—å½“å‰TPS
    SELECT 
        (xact_commit + xact_rollback) / EXTRACT(EPOCH FROM (now() - stats_reset))
    INTO current_tps
    FROM pg_stat_database 
    WHERE datname = current_database();
    
    -- è®¡ç®—ç¼“å†²åŒºå‘½ä¸­ç‡
    WITH buffer_stats AS (
        SELECT 
            SUM(heap_blks_hit) as hits,
            SUM(heap_blks_read) as reads
        FROM pg_statio_user_tables
    )
    SELECT hits::numeric / NULLIF(hits + reads, 0)
    INTO current_hit_ratio FROM buffer_stats;
    
    -- è·å–æ´»è·ƒè¿æ¥æ•°
    SELECT COUNT(*) INTO current_connections
    FROM pg_stat_activity WHERE state = 'active';
    
    -- è·å–ç­‰å¾…é”æ•°é‡
    SELECT COUNT(*) INTO current_waiting_locks
    FROM pg_locks WHERE NOT granted;
    
    -- æ’å…¥åŸºçº¿è®°å½•
    INSERT INTO performance_baseline (
        baseline_name, 
        tps, 
        memory_hit_ratio,
        active_connections,
        waiting_locks,
        notes
    ) VALUES (
        baseline_name,
        current_tps,
        current_hit_ratio,
        current_connections,
        current_waiting_locks,
        notes
    );
    
    RAISE NOTICE 'åŸºçº¿ "%" å·²è®°å½•', baseline_name;
END;
$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT record_performance_baseline('ä¼˜åŒ–å‰åŸºçº¿', 'ç³»ç»Ÿå½“å‰çŠ¶æ€ï¼Œå‡†å¤‡å¼€å§‹è°ƒä¼˜');
```

**ğŸ“ˆ æ€§èƒ½å¯¹æ¯”åˆ†æ**
```sql
-- æ€§èƒ½æ”¹è¿›å¯¹æ¯”æŠ¥å‘Š
CREATE OR REPLACE FUNCTION performance_improvement_report(
    baseline_before TEXT,
    baseline_after TEXT
) RETURNS TABLE (
    metric_name TEXT,
    before_value TEXT,
    after_value TEXT,
    improvement_percent NUMERIC,
    improvement_status TEXT
) AS $
DECLARE
    before_record RECORD;
    after_record RECORD;
BEGIN
    -- è·å–ä¼˜åŒ–å‰æ•°æ®
    SELECT * INTO before_record 
    FROM performance_baseline 
    WHERE baseline_name = baseline_before
    ORDER BY measurement_time DESC LIMIT 1;
    
    -- è·å–ä¼˜åŒ–åæ•°æ®
    SELECT * INTO after_record 
    FROM performance_baseline 
    WHERE baseline_name = baseline_after
    ORDER BY measurement_time DESC LIMIT 1;
    
    -- TPSå¯¹æ¯”
    metric_name := 'TPS (æ¯ç§’äº‹åŠ¡æ•°)';
    before_value := COALESCE(before_record.tps::TEXT, 'N/A');
    after_value := COALESCE(after_record.tps::TEXT, 'N/A');
    IF before_record.tps > 0 AND after_record.tps > 0 THEN
        improvement_percent := (after_record.tps - before_record.tps) / before_record.tps * 100;
        improvement_status := CASE 
            WHEN improvement_percent > 20 THEN 'ğŸŸ¢ æ˜¾è‘—æå‡'
            WHEN improvement_percent > 5 THEN 'ğŸŸ¡ é€‚åº¦æå‡'
            WHEN improvement_percent > -5 THEN 'âšª åŸºæœ¬ä¸å˜'
            ELSE 'ğŸ”´ æ€§èƒ½ä¸‹é™'
        END;
    ELSE
        improvement_percent := NULL;
        improvement_status := 'âšª æ— æ³•æ¯”è¾ƒ';
    END IF;
    RETURN NEXT;
    
    -- å†…å­˜å‘½ä¸­ç‡å¯¹æ¯”
    metric_name := 'ç¼“å†²åŒºå‘½ä¸­ç‡';
    before_value := COALESCE(ROUND(before_record.memory_hit_ratio * 100, 2)::TEXT || '%', 'N/A');
    after_value := COALESCE(ROUND(after_record.memory_hit_ratio * 100, 2)::TEXT || '%', 'N/A');
    IF before_record.memory_hit_ratio > 0 AND after_record.memory_hit_ratio > 0 THEN
        improvement_percent := (after_record.memory_hit_ratio - before_record.memory_hit_ratio) * 100;
        improvement_status := CASE 
            WHEN improvement_percent > 1 THEN 'ğŸŸ¢ å‘½ä¸­ç‡æå‡'
            WHEN improvement_percent > -1 THEN 'âšª åŸºæœ¬ç¨³å®š'
            ELSE 'ğŸ”´ å‘½ä¸­ç‡ä¸‹é™'
        END;
    ELSE
        improvement_percent := NULL;
        improvement_status := 'âšª æ— æ³•æ¯”è¾ƒ';
    END IF;
    RETURN NEXT;
    
    -- æ´»è·ƒè¿æ¥æ•°å¯¹æ¯”
    metric_name := 'æ´»è·ƒè¿æ¥æ•°';
    before_value := COALESCE(before_record.active_connections::TEXT, 'N/A');
    after_value := COALESCE(after_record.active_connections::TEXT, 'N/A');
    IF before_record.active_connections > 0 AND after_record.active_connections > 0 THEN
        improvement_percent := (after_record.active_connections - before_record.active_connections)::numeric / before_record.active_connections * 100;
        improvement_status := CASE 
            WHEN improvement_percent < -20 THEN 'ğŸŸ¢ è¿æ¥æ•°æ˜¾è‘—å‡å°‘'
            WHEN improvement_percent < -5 THEN 'ğŸŸ¡ è¿æ¥æ•°é€‚åº¦å‡å°‘'
            WHEN improvement_percent < 5 THEN 'âšª è¿æ¥æ•°åŸºæœ¬ç¨³å®š'
            ELSE 'ğŸ”´ è¿æ¥æ•°å¢åŠ '
        END;
    ELSE
        improvement_percent := NULL;
        improvement_status := 'âšª æ— æ³•æ¯”è¾ƒ';
    END IF;
    RETURN NEXT;
    
END;
$ LANGUAGE plpgsql;

-- ä½¿ç”¨å¯¹æ¯”æŠ¥å‘Š
SELECT * FROM performance_improvement_report('ä¼˜åŒ–å‰åŸºçº¿', 'ä¼˜åŒ–ååŸºçº¿');
```

### 8.2 è°ƒä¼˜æœ€ä½³å®è·µ


**ğŸ¯ åˆ†é˜¶æ®µè°ƒä¼˜ç­–ç•¥**

```
è°ƒä¼˜ä¼˜å…ˆçº§æ’åºï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬ä¸€é˜¶æ®µï¼šä½æˆæœ¬é«˜æ”¶ç›Š â”‚
â”‚  â€¢ å‚æ•°ä¼˜åŒ–          â”‚
â”‚  â€¢ ç´¢å¼•ä¼˜åŒ–          â”‚  
â”‚  â€¢ æŸ¥è¯¢ä¼˜åŒ–          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¬¬äºŒé˜¶æ®µï¼šä¸­ç­‰æˆæœ¬æ”¶ç›Š â”‚
â”‚  â€¢ äº‹åŠ¡è®¾è®¡ä¼˜åŒ–       â”‚
â”‚  â€¢ è¿æ¥æ± è°ƒä¼˜        â”‚
â”‚  â€¢ æ‰¹é‡æ“ä½œä¼˜åŒ–       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¬¬ä¸‰é˜¶æ®µï¼šé«˜æˆæœ¬æ”¶ç›Š   â”‚
â”‚  â€¢ ç¡¬ä»¶å‡çº§          â”‚
â”‚  â€¢ æ¶æ„é‡è®¾è®¡        â”‚
â”‚  â€¢ åˆ†åº“åˆ†è¡¨          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”§ å¸¸è§è°ƒä¼˜æ£€æŸ¥æ¸…å•**
```sql
-- åˆ›å»ºè°ƒä¼˜æ£€æŸ¥æ¸…å•å‡½æ•°
CREATE OR REPLACE FUNCTION tuning_checklist()
RETURNS TABLE (
    category TEXT,
    check_item TEXT,
    current_status TEXT,
    recommendation TEXT,
    priority TEXT
) AS $
BEGIN
    -- ç´¢å¼•æ£€æŸ¥
    category := 'ç´¢å¼•ä¼˜åŒ–';
    check_item := 'ç¼ºå¤±ç´¢å¼•æ£€æŸ¥';
    
    -- æ£€æŸ¥æ˜¯å¦æœ‰ç»å¸¸è¿›è¡Œå…¨è¡¨æ‰«æçš„æŸ¥è¯¢
    WITH seq_scans AS (
        SELECT COUNT(*) as tables_with_seq_scans
        FROM pg_stat_user_tables 
        WHERE seq_scan > 1000 AND seq_tup_read / NULLIF(seq_scan, 0) > 10000
    )
    SELECT 
        CASE WHEN tables_with_seq_scans > 0 
             THEN tables_with_seq_scans::TEXT || 'ä¸ªè¡¨å­˜åœ¨å¤§é‡é¡ºåºæ‰«æ'
             ELSE 'æš‚æ— å‘ç°é—®é¢˜'
        END,
        CASE WHEN tables_with_seq_scans > 0 
             THEN 'ä¸ºé«˜é¢‘æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•'
             ELSE 'ç»§ç»­ç›‘æ§'
        END,
        CASE WHEN tables_with_seq_scans > 0 
             THEN 'ğŸ”´ é«˜ä¼˜å…ˆçº§'
             ELSE 'ğŸŸ¢ æ­£å¸¸'
        END
    INTO current_status, recommendation, priority
    FROM seq_scans;
    RETURN NEXT;
    
    -- WALé…ç½®æ£€æŸ¥
    category := 'WALé…ç½®';
    check_item := 'checkpointé¢‘ç‡';
    
    WITH checkpoint_stats AS (
        SELECT 
            checkpoints_req::numeric / NULLIF(checkpoints_timed + checkpoints_req, 0) as forced_checkpoint_ratio
        FROM pg_stat_bgwriter
    )
    SELECT 
        CASE WHEN forced_checkpoint_ratio > 0.1 
             THEN 'å¼ºåˆ¶checkpointæ¯”ä¾‹: ' || ROUND(forced_checkpoint_ratio * 100, 1)::TEXT || '%'
             ELSE 'å¼ºåˆ¶checkpointæ¯”ä¾‹æ­£å¸¸'
        END,
        CASE WHEN forced_checkpoint_ratio > 0.1 
             THEN 'å¢åŠ max_wal_sizeå‚æ•°'
             ELSE 'å½“å‰é…ç½®åˆç†'
        END,
        CASE WHEN forced_checkpoint_ratio > 0.1 
             THEN 'ğŸŸ¡ ä¸­ä¼˜å…ˆçº§'
             ELSE 'ğŸŸ¢ æ­£å¸¸'
        END
    INTO current_status, recommendation, priority
    FROM checkpoint_stats;
    RETURN NEXT;
    
    -- è¿æ¥æ•°æ£€æŸ¥
    category := 'è¿æ¥ç®¡ç†';
    check_item := 'è¿æ¥æ± çŠ¶æ€';
    
    WITH connection_stats AS (
        SELECT 
            COUNT(*) as total_connections,
            COUNT(CASE WHEN state = 'idle' THEN 1 END) as idle_connections
        FROM pg_stat_activity
    )
    SELECT 
        'æ€»è¿æ¥: ' || total_connections::TEXT || ', ç©ºé—²: ' || idle_connections::TEXT,
        CASE 
            WHEN idle_connections::numeric / total_connections > 0.5 
            THEN 'é…ç½®è¿æ¥æ± ï¼Œå‡å°‘ç©ºé—²è¿æ¥'
            ELSE 'è¿æ¥ä½¿ç”¨ç‡è‰¯å¥½'
        END,
        CASE 
            WHEN idle_connections::numeric / total_connections > 0.5 
            THEN 'ğŸŸ¡ ä¸­ä¼˜å…ˆçº§'
            ELSE 'ğŸŸ¢ æ­£å¸¸'
        END
    INTO current_status, recommendation, priority
    FROM connection_stats;
    RETURN NEXT;
    
    -- å†…å­˜é…ç½®æ£€æŸ¥
    category := 'å†…å­˜é…ç½®';
    check_item := 'shared_bufferså¤§å°';
    
    WITH memory_config AS (
        SELECT 
            setting::bigint * 8192 / 1024 / 1024 as shared_buffers_mb  -- è½¬æ¢ä¸ºMB
        FROM pg_settings 
        WHERE name = 'shared_buffers'
    )
    SELECT 
        shared_buffers_mb::TEXT || 'MB',
        CASE 
            WHEN shared_buffers_mb < 256 THEN 'å»ºè®®å¢åŠ åˆ°ç³»ç»Ÿå†…å­˜çš„25%'
            WHEN shared_buffers_mb > 8192 THEN 'è¿‡å¤§å¯èƒ½å½±å“æ€§èƒ½ï¼Œå»ºè®®é€‚å½“å‡å°‘'
            ELSE 'é…ç½®åˆç†'
        END,
        CASE 
            WHEN shared_buffers_mb < 256 OR shared_buffers_mb > 8192 
            THEN 'ğŸŸ¡ ä¸­ä¼˜å…ˆçº§'
            ELSE 'ğŸŸ¢ æ­£å¸¸'
        END
    INTO current_status, recommendation, priority
    FROM memory_config;
    RETURN NEXT;
    
END;
$ LANGUAGE plpgsql;

-- è¿è¡Œè°ƒä¼˜æ£€æŸ¥æ¸…å•
SELECT * FROM tuning_checklist();
```

### 8.3 è°ƒä¼˜æ•ˆæœéªŒè¯


**âœ… æ€§èƒ½å›å½’æµ‹è¯•**
```sql
-- åˆ›å»ºæ€§èƒ½å›å½’æµ‹è¯•å¥—ä»¶
CREATE OR REPLACE FUNCTION performance_regression_test()
RETURNS TABLE (
    test_name TEXT,
    baseline_time_ms NUMERIC,
    current_time_ms NUMERIC,
    performance_change_percent NUMERIC,
    status TEXT
) AS $
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    test_duration NUMERIC;
BEGIN
    -- æµ‹è¯•1ï¼šç®€å•æŸ¥è¯¢æ€§èƒ½
    test_name := 'ç®€å•ä¸»é”®æŸ¥è¯¢';
    start_time := clock_timestamp();
    PERFORM * FROM pg_class WHERE oid = 'pg_class'::regclass;
    end_time := clock_timestamp();
    current_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    baseline_time_ms := 1.0;  -- åŸºçº¿æ—¶é—´ï¼Œå®é™…åº”ä»å†å²è®°å½•è·å–
    performance_change_percent := (current_time_ms - baseline_time_ms) / baseline_time_ms * 100;
    status := CASE 
        WHEN performance_change_percent > 50 THEN 'ğŸ”´ æ€§èƒ½é€€åŒ–'
        WHEN performance_change_percent > 10 THEN 'ğŸŸ¡ è½»å¾®å˜æ…¢'
        WHEN performance_change_percent < -10 THEN 'ğŸŸ¢ æ€§èƒ½æå‡'
        ELSE 'âšª æ€§èƒ½ç¨³å®š'
    END;
    RETURN NEXT;
    
    -- æµ‹è¯•2ï¼šå¤æ‚æŸ¥è¯¢æ€§èƒ½
    test_name := 'å¤æ‚ç»Ÿè®¡æŸ¥è¯¢';
    start_time := clock_timestamp();
    PERFORM COUNT(*), AVG(relpages), SUM(reltuples) 
    FROM pg_class 
    WHERE relkind = 'r' 
    GROUP BY relnamespace;
    end_time := clock_timestamp();
    current_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    baseline_time_ms := 10.0;  -- åŸºçº¿æ—¶é—´
    performance_change_percent := (current_time_ms - baseline_time_ms) / baseline_time_ms * 100;
    status := CASE 
        WHEN performance_change_percent > 50 THEN 'ğŸ”´ æ€§èƒ½é€€åŒ–'
        WHEN performance_change_percent > 10 THEN 'ğŸŸ¡ è½»å¾®å˜æ…¢'
        WHEN performance_change_percent < -10 THEN 'ğŸŸ¢ æ€§èƒ½æå‡'
        ELSE 'âšª æ€§èƒ½ç¨³å®š'
    END;
    RETURN NEXT;
    
    -- æµ‹è¯•3ï¼šäº‹åŠ¡æ€§èƒ½
    test_name := 'äº‹åŠ¡æäº¤æ€§èƒ½';
    start_time := clock_timestamp();
    FOR i IN 1..100 LOOP
        BEGIN
            -- æ¨¡æ‹Ÿç®€å•äº‹åŠ¡
            INSERT INTO pg_temp.test_table_temp SELECT i;
        EXCEPTION WHEN OTHERS THEN
            -- å¿½ç•¥é”™è¯¯
        END;
    END LOOP;
    end_time := clock_timestamp();
    current_time_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    baseline_time_ms := 50.0;  -- åŸºçº¿æ—¶é—´
    performance_change_percent := (current_time_ms - baseline_time_ms) / baseline_time_ms * 100;
    status := CASE 
        WHEN performance_change_percent > 50 THEN 'ğŸ”´ æ€§èƒ½é€€åŒ–'
        WHEN performance_change_percent > 10 THEN 'ğŸŸ¡ è½»å¾®å˜æ…¢'
        WHEN performance_change_percent < -10 THEN 'ğŸŸ¢ æ€§èƒ½æå‡'
        ELSE 'âšª æ€§èƒ½ç¨³å®š'
    END;
    RETURN NEXT;
    
END;
$ LANGUAGE plpgsql;

-- è¿è¡Œå›å½’æµ‹è¯•
SELECT * FROM performance_regression_test();
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„è°ƒä¼˜æŠ€èƒ½


```
ğŸ”¸ æ€§èƒ½ç›‘æ§ï¼šå»ºç«‹å®Œæ•´çš„äº‹åŠ¡æ€§èƒ½ç›‘æ§ä½“ç³»
ğŸ”¸ ç“¶é¢ˆè¯†åˆ«ï¼šå¿«é€Ÿå®šä½æ€§èƒ½ç“¶é¢ˆçš„æ ¹æœ¬åŸå› 
ğŸ”¸ é”ä¼˜åŒ–ï¼šç†è§£é”æœºåˆ¶ï¼Œå‡å°‘é”ç«äº‰å’Œæ­»é”
ğŸ”¸ æ—¥å¿—è°ƒä¼˜ï¼šä¼˜åŒ–WALé…ç½®ï¼Œæå‡äº‹åŠ¡æäº¤æ€§èƒ½
ğŸ”¸ æ‰¹é‡ä¼˜åŒ–ï¼šæŒæ¡é«˜æ•ˆçš„æ‰¹é‡æ•°æ®å¤„ç†æŠ€æœ¯
ğŸ”¸ ç´¢å¼•ç­–ç•¥ï¼šè®¾è®¡å¹¶å‘å‹å¥½çš„ç´¢å¼•æ–¹æ¡ˆ
```

### 9.2 å…³é”®æ€§èƒ½æŒ‡æ ‡è®°å¿†


**ğŸ¯ æ ¸å¿ƒKPIæŒ‡æ ‡**
```
ååé‡æŒ‡æ ‡ï¼š
- TPS > 1000 (ä¼˜ç§€)
- TPS 500-1000 (ä¸€èˆ¬)  
- TPS < 500 (éœ€ä¼˜åŒ–)

å“åº”æ—¶é—´æŒ‡æ ‡ï¼š
- å¹³å‡å“åº”æ—¶é—´ < 100ms (ä¼˜ç§€)
- å¹³å‡å“åº”æ—¶é—´ 100-500ms (ä¸€èˆ¬)
- å¹³å‡å“åº”æ—¶é—´ > 500ms (éœ€ä¼˜åŒ–)

èµ„æºä½¿ç”¨æŒ‡æ ‡ï¼š
- ç¼“å†²åŒºå‘½ä¸­ç‡ > 95% (ä¼˜ç§€)
- é”ç­‰å¾…æ—¶é—´ < 10ms (æ­£å¸¸)
- æ­»é”ç‡ < 0.01% (å¯æ¥å—)
```

### 9.3 è°ƒä¼˜ä¼˜å…ˆçº§ç­–ç•¥


**ğŸ† è°ƒä¼˜ROIæ’åº**
```
ç¬¬ä¸€ä¼˜å…ˆçº§ï¼ˆä½æˆæœ¬é«˜æ”¶ç›Šï¼‰ï¼š
âœ… å‚æ•°è°ƒä¼˜ï¼šshared_buffersã€work_memã€max_wal_size
âœ… ç´¢å¼•ä¼˜åŒ–ï¼šæ·»åŠ ç¼ºå¤±ç´¢å¼•ï¼Œåˆ é™¤å†—ä½™ç´¢å¼•
âœ… æŸ¥è¯¢ä¼˜åŒ–ï¼šæ¶ˆé™¤å…¨è¡¨æ‰«æï¼Œä¼˜åŒ–æ…¢æŸ¥è¯¢
âœ… äº‹åŠ¡ä¼˜åŒ–ï¼šå‡å°‘äº‹åŠ¡æ—¶é—´ï¼Œé¿å…é•¿äº‹åŠ¡

ç¬¬äºŒä¼˜å…ˆçº§ï¼ˆä¸­ç­‰æˆæœ¬æ”¶ç›Šï¼‰ï¼š
ğŸ”§ è¿æ¥æ± é…ç½®ï¼šPgBouncerã€è¿æ¥æ•°æ§åˆ¶
ğŸ”§ æ‰¹é‡æ“ä½œï¼šCOPYå‘½ä»¤ã€æ‰¹é‡æ’å…¥ä¼˜åŒ–
ğŸ”§ é”ç­–ç•¥ï¼šä¹è§‚é”ã€é”é¡ºåºç»Ÿä¸€
ğŸ”§ ç›‘æ§ä½“ç³»ï¼šå®æ—¶ç›‘æ§ã€å‘Šè­¦æœºåˆ¶

ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼ˆé«˜æˆæœ¬æ”¶ç›Šï¼‰ï¼š
ğŸ’° ç¡¬ä»¶å‡çº§ï¼šSSDã€æ›´å¤šå†…å­˜ã€æ›´å¿«CPU
ğŸ’° æ¶æ„è°ƒæ•´ï¼šè¯»å†™åˆ†ç¦»ã€åˆ†åº“åˆ†è¡¨
ğŸ’° ç¼“å­˜å±‚ï¼šRedisã€Memcached
ğŸ’° è´Ÿè½½å‡è¡¡ï¼šæ•°æ®åº“é›†ç¾¤ã€è¿æ¥åˆ†å‘
```

### 9.4 å¸¸è§é”™è¯¯ä¸è§£å†³æ–¹æ¡ˆ


**âŒ å…¸å‹è°ƒä¼˜è¯¯åŒº**
```
è¯¯åŒº1ï¼šç›²ç›®å¢åŠ è¿æ¥æ•°
é—®é¢˜ï¼šè¿æ¥æ•°è¿‡å¤šå¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€
è§£å†³ï¼šä½¿ç”¨è¿æ¥æ± ï¼Œæ§åˆ¶æ´»è·ƒè¿æ¥æ•°

è¯¯åŒº2ï¼šè¿‡åº¦ä½¿ç”¨ç´¢å¼•
é—®é¢˜ï¼šç´¢å¼•ç»´æŠ¤å¼€é”€ï¼Œå½±å“å†™å…¥æ€§èƒ½  
è§£å†³ï¼šåªä¸ºé«˜é¢‘æŸ¥è¯¢åˆ›å»ºå¿…è¦ç´¢å¼•

è¯¯åŒº3ï¼šå¿½è§†é”ç«äº‰
é—®é¢˜ï¼šé”ç­‰å¾…å¯¼è‡´æ€§èƒ½ä¸‹é™
è§£å†³ï¼šä¼˜åŒ–äº‹åŠ¡è®¾è®¡ï¼Œå‡å°‘é”æŒæœ‰æ—¶é—´

è¯¯åŒº4ï¼šé…ç½®å‚æ•°è¿‡æ¿€
é—®é¢˜ï¼šå‚æ•°è®¾ç½®è¿‡å¤§æˆ–è¿‡å°éƒ½ä¼šå½±å“æ€§èƒ½
è§£å†³ï¼šåŸºäºå·¥ä½œè´Ÿè½½é€æ­¥è°ƒæ•´ï¼ŒæŒç»­ç›‘æ§
```

### 9.5 å®æˆ˜ç»éªŒæ€»ç»“


**ğŸ’¡ è°ƒä¼˜å®æˆ˜å¿ƒå¾—**
- **æ•°æ®é©±åŠ¨**ï¼šæ‰€æœ‰ä¼˜åŒ–éƒ½è¦åŸºäºç›‘æ§æ•°æ®ï¼Œä¸èƒ½å‡­æ„Ÿè§‰
- **å°æ­¥å¿«è·‘**ï¼šä¸€æ¬¡åªè°ƒæ•´ä¸€ä¸ªå‚æ•°ï¼Œè§‚å¯Ÿæ•ˆæœå†ç»§ç»­
- **åŸºçº¿å¯¹æ¯”**ï¼šå»ºç«‹æ€§èƒ½åŸºçº¿ï¼Œé‡åŒ–ä¼˜åŒ–æ•ˆæœ
- **æŒç»­ç›‘æ§**ï¼šä¼˜åŒ–ä¸æ˜¯ä¸€æ¬¡æ€§å·¥ä½œï¼Œéœ€è¦æŒç»­å…³æ³¨
- **æ–‡æ¡£è®°å½•**ï¼šè®°å½•æ¯æ¬¡è°ƒä¼˜çš„åŸå› ã€æ–¹æ³•å’Œæ•ˆæœ

**ğŸ”§ è°ƒä¼˜å·¥å…·æ¨è**
- **ç›‘æ§å·¥å…·**ï¼špg_stat_statementsã€pgbadgerã€ç›‘æ§dashboard
- **åˆ†æå·¥å…·**ï¼šEXPLAIN ANALYZEã€auto_explainã€æ€§èƒ½åˆ†æè„šæœ¬
- **å‹æµ‹å·¥å…·**ï¼špgbenchã€sysbenchã€è‡ªå®šä¹‰å‹æµ‹è„šæœ¬
- **è¿æ¥æ± **ï¼šPgBouncerã€Pgpool-II

**æ ¸å¿ƒè®°å¿†**ï¼š
- äº‹åŠ¡æ€§èƒ½è°ƒä¼˜æ˜¯ç³»ç»Ÿå·¥ç¨‹ï¼Œéœ€è¦å¤šç»´åº¦åˆ†æ
- ç›‘æ§æŒ‡æ ‡æ˜¯è°ƒä¼˜çš„åŸºç¡€ï¼Œæ²¡æœ‰ç›‘æ§å°±æ²¡æœ‰ä¼˜åŒ–
- é”ç«äº‰æ˜¯äº‹åŠ¡æ€§èƒ½çš„ä¸»è¦ç“¶é¢ˆï¼Œè¦é‡ç‚¹å…³æ³¨
- æ‰¹é‡æ“ä½œå’Œç´¢å¼•è®¾è®¡å¯¹æ€§èƒ½å½±å“å·¨å¤§
- è°ƒä¼˜è¦éµå¾ªæ•°æ®é©±åŠ¨ã€å°æ­¥å¿«è·‘çš„åŸåˆ™
- æ€§èƒ½ä¼˜åŒ–æ˜¯æŒç»­è¿‡ç¨‹ï¼Œéœ€è¦å»ºç«‹é•¿æ•ˆæœºåˆ¶