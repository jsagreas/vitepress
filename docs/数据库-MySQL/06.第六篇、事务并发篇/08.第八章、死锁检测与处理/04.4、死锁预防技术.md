---
title: 4、死锁预防技术
---
## 📚 目录

1. [死锁预防原理](#1-死锁预防原理)
2. [资源排序访问](#2-资源排序访问)
3. [超时机制](#3-超时机制)
4. [事务重试](#4-事务重试)
5. [锁顺序规范](#5-锁顺序规范)
6. [业务逻辑设计](#6-业务逻辑设计)
7. [预防策略选择](#7-预防策略选择)
8. [预防效果评估](#8-预防效果评估)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔒 死锁预防原理


### 1.1 什么是死锁预防


死锁预防就是在设计系统时采用各种策略，从根本上避免死锁的发生。它通过破坏死锁产生的必要条件来实现。

### 1.2 死锁产生的四个必要条件


**四个条件缺一不可**：
- **互斥条件**：资源不能被多个事务同时使用
- **持有并等待**：事务持有资源的同时等待其他资源
- **不可抢占**：已分配的资源不能被强制收回
- **循环等待**：多个事务形成环形等待链

### 1.3 预防技术完整体系


```
死锁预防策略体系：
┌─ 破坏循环等待 ── 资源排序访问
├─ 破坏持有等待 ── 超时机制
├─ 破坏不可抢占 ── 事务重试
└─ 优化设计 ────── 业务逻辑改进
```

**预防 vs 检测 vs 避免**：
- **预防**：从设计上杜绝死锁发生
- **检测**：死锁发生后检测并处理
- **避免**：运行时动态判断是否可能死锁

---

## 2. 📊 资源排序访问


### 2.1 核心思想


资源排序访问通过规定所有事务必须按照相同的顺序访问资源，从而破坏循环等待条件。

### 2.2 基本实现方法


**按主键排序访问**：
```sql
-- ❌ 错误做法：可能造成死锁
-- 事务A
UPDATE accounts SET balance = balance - 100 WHERE id = 5;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;

-- 事务B
UPDATE accounts SET balance = balance - 50 WHERE id = 1;
UPDATE accounts SET balance = balance + 50 WHERE id = 5;

-- ✅ 正确做法：按ID排序访问
-- 事务A
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 5;

-- 事务B  
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
UPDATE accounts SET balance = balance - 50 WHERE id = 5;
```

### 2.3 应用层排序实现


**Java代码示例**：
```java
public void transferMoney(int fromId, int toId, BigDecimal amount) {
    // 按ID排序，确保访问顺序一致
    int firstId = Math.min(fromId, toId);
    int secondId = Math.max(fromId, toId);
    
    // 按顺序锁定账户
    Account first = lockAccount(firstId);
    Account second = lockAccount(secondId);
    
    // 执行转账逻辑
    if (fromId == firstId) {
        first.withdraw(amount);
        second.deposit(amount);
    } else {
        second.withdraw(amount);
        first.deposit(amount);
    }
}
```

### 2.4 多表操作排序


**表级排序策略**：
```sql
-- 按表名字母顺序操作
-- 1. accounts表
-- 2. orders表  
-- 3. products表

-- ✅ 正确的操作顺序
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE orders SET status = 'paid' WHERE id = 123;
UPDATE products SET stock = stock - 1 WHERE id = 456;
```

---

## 3. ⏰ 超时机制


### 3.1 基本概念


超时机制通过设置锁等待的最大时间，当等待超时后自动回滚事务，破坏持有并等待条件。

### 3.2 MySQL锁等待超时设置


```sql
-- 查看当前超时设置
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';

-- 设置锁等待超时时间（单位：秒）
SET innodb_lock_wait_timeout = 30;

-- 会话级别设置
SET SESSION innodb_lock_wait_timeout = 10;
```

### 3.3 应用层超时处理


**JDBC超时设置**：
```java
public void executeWithTimeout() {
    Connection conn = null;
    try {
        conn = dataSource.getConnection();
        // 设置查询超时
        Statement stmt = conn.createStatement();
        stmt.setQueryTimeout(30);
        
        // 执行SQL
        stmt.executeUpdate("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
        
    } catch (SQLException e) {
        if (e.getErrorCode() == 1205) { // 锁等待超时
            // 记录日志并重试
            logger.warn("Lock wait timeout, retrying...");
        }
    }
}
```

### 3.4 超时策略配置


| 场景类型 | **建议超时时间** | **说明** |
|---------|----------------|----------|
| **在线交易** | 5-10秒 | 快速响应，避免用户等待 |
| **批量处理** | 60-300秒 | 允许较长等待时间 |
| **报表查询** | 300-600秒 | 复杂查询需要更多时间 |
| **数据导入** | 600-1800秒 | 大数据量操作 |

---

## 4. 🔄 事务重试


### 4.1 重试机制原理


当事务因为死锁或锁等待超时失败时，系统自动重新执行该事务，直到成功或达到最大重试次数。

### 4.2 重试策略实现


**基本重试模式**：
```java
@Transactional
public void transferWithRetry(int fromId, int toId, BigDecimal amount) {
    int maxRetries = 3;
    int attempt = 0;
    
    while (attempt < maxRetries) {
        try {
            // 执行转账逻辑
            doTransfer(fromId, toId, amount);
            return; // 成功则退出
            
        } catch (DeadlockException e) {
            attempt++;
            if (attempt >= maxRetries) {
                throw new RuntimeException("转账失败，已重试" + maxRetries + "次");
            }
            
            // 指数退避策略
            long delay = (long) Math.pow(2, attempt) * 100; // 100ms, 200ms, 400ms
            Thread.sleep(delay);
        }
    }
}
```

### 4.3 重试策略优化


**指数退避算法**：
```java
public class RetryPolicy {
    private int maxRetries = 3;
    private long baseDelay = 100; // 基础延迟100ms
    
    public void executeWithRetry(Runnable task) {
        for (int i = 0; i < maxRetries; i++) {
            try {
                task.run();
                return;
            } catch (Exception e) {
                if (i == maxRetries - 1) throw e;
                
                // 计算延迟时间：100ms * 2^i + 随机抖动
                long delay = baseDelay * (1L << i) + 
                           (long)(Math.random() * 50);
                Thread.sleep(delay);
            }
        }
    }
}
```

### 4.4 重试注意事项


**幂等性要求**：
```sql
-- ❌ 非幂等操作（重试会重复扣款）
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- ✅ 幂等操作（使用唯一约束防重复）
INSERT INTO transactions (id, from_account, amount, status) 
VALUES ('TXN_001', 1, 100, 'pending');
```

---

## 5. 📋 锁顺序规范


### 5.1 制定锁顺序规范


锁顺序规范是团队约定的资源访问顺序，确保所有开发人员遵循相同的锁定顺序。

### 5.2 常见锁顺序规范


**按表的重要性排序**：
```sql
-- 优先级：用户表 > 账户表 > 订单表 > 日志表
1. users
2. accounts  
3. orders
4. audit_logs
```

**按业务流程排序**：
```sql
-- 电商下单流程的锁顺序
1. 检查用户状态：SELECT FROM users WHERE id = ?
2. 检查商品库存：SELECT FROM products WHERE id = ?  
3. 创建订单：INSERT INTO orders
4. 扣减库存：UPDATE products SET stock = stock - 1
5. 扣减余额：UPDATE accounts SET balance = balance - amount
```

### 5.3 代码规范示例


**锁顺序注释规范**：
```java
/**
 * 转账操作 - 锁定顺序：accounts(小ID) -> accounts(大ID)
 */
public void transfer(int fromId, int toId, BigDecimal amount) {
    // 确保按ID升序锁定
    if (fromId > toId) {
        int temp = fromId;
        fromId = toId;
        toId = temp;
        amount = amount.negate();
    }
    
    // 按顺序锁定账户
    lockAccount(fromId);
    lockAccount(toId);
}
```

### 5.4 规范检查工具


**代码审查清单**：
- ✅ 是否按照约定的顺序访问表？
- ✅ 多表操作是否有明确的锁定顺序？
- ✅ 是否存在可能的循环等待？
- ✅ 事务是否尽可能短？

---

## 6. 💼 业务逻辑设计


### 6.1 避免热点数据争用


热点数据是多个事务频繁访问的数据，容易成为死锁的焦点。

**拆分热点行**：
```sql
-- ❌ 单行热点数据
CREATE TABLE counters (
    name VARCHAR(50) PRIMARY KEY,
    value INT
);

-- ✅ 分片减少争用
CREATE TABLE counters_sharded (
    name VARCHAR(50),
    shard_id INT,
    value INT,
    PRIMARY KEY (name, shard_id)
);

-- 读取时汇总
SELECT name, SUM(value) as total_value 
FROM counters_sharded 
WHERE name = 'page_views' 
GROUP BY name;
```

### 6.2 减少事务交互


**合并相关操作**：
```sql
-- ❌ 多次交互，增加死锁风险
BEGIN;
UPDATE orders SET status = 'processing' WHERE id = 1;
COMMIT;

BEGIN;
UPDATE products SET stock = stock - 1 WHERE id = 100;
COMMIT;

-- ✅ 合并为单个事务
BEGIN;
UPDATE orders SET status = 'processing' WHERE id = 1;
UPDATE products SET stock = stock - 1 WHERE id = 100;
COMMIT;
```

### 6.3 异步处理设计


**事件驱动架构**：
```java
// 主事务只处理核心逻辑
@Transactional
public void createOrder(Order order) {
    // 1. 创建订单（核心逻辑）
    orderRepository.save(order);
    
    // 2. 发布事件（异步处理）
    eventPublisher.publishEvent(new OrderCreatedEvent(order.getId()));
}

// 异步处理其他逻辑
@EventListener
@Async
public void handleOrderCreated(OrderCreatedEvent event) {
    // 异步处理：发送邮件、更新统计等
    emailService.sendOrderConfirmation(event.getOrderId());
    statisticsService.updateOrderCount();
}
```

---

## 7. ⚖ 预防策略选择


### 7.1 策略选择矩阵


| 应用场景 | **推荐策略** | **优点** | **注意事项** |
|---------|-------------|----------|-------------|
| **高并发OLTP** | 资源排序 + 超时 | 死锁少，性能好 | 需要严格规范 |
| **批量处理** | 超时 + 重试 | 处理能力强 | 设置合理超时 |
| **分布式系统** | 事务重试 + 异步 | 容错性好 | 需要幂等设计 |
| **实时交易** | 锁顺序 + 快速失败 | 响应及时 | 业务逻辑简化 |

### 7.2 策略组合使用


**推荐组合方案**：
```
方案一：互联网应用
- 资源排序访问（主要）
- 短超时时间（5-10秒）
- 简单重试（1-2次）

方案二：企业应用  
- 锁顺序规范（主要）
- 中等超时时间（30-60秒）
- 指数退避重试

方案三：批处理系统
- 超时机制（主要）  
- 异步处理
- 失败队列重试
```

### 7.3 预防策略选择决策树


```
开始
  |
  ├─ 是否高并发？
  │   ├─ 是 → 资源排序 + 短超时
  │   └─ 否 ↓
  |
  ├─ 是否批处理？  
  │   ├─ 是 → 长超时 + 重试
  │   └─ 否 ↓
  |
  ├─ 是否分布式？
  │   ├─ 是 → 异步 + 重试
  │   └─ 否 ↓
  |
  └─ 锁顺序规范 + 适中超时
```

---

## 8. 📈 预防效果评估


### 8.1 评估指标


**定量指标**：
```sql
-- 死锁频率
SELECT 
    DATE(created_time) as date,
    COUNT(*) as deadlock_count
FROM mysql.slow_log 
WHERE sql_text LIKE '%Deadlock found%'
GROUP BY DATE(created_time);

-- 平均锁等待时间  
SELECT AVG(wait_age) as avg_wait_time 
FROM sys.innodb_lock_waits;

-- 事务回滚率
SHOW GLOBAL STATUS LIKE 'Com_rollback';
SHOW GLOBAL STATUS LIKE 'Com_commit';
```

### 8.2 性能对比分析


**预防前后对比**：
| 指标 | **预防前** | **预防后** | **改善程度** |
|------|-----------|-----------|-------------|
| **死锁次数/小时** | 25次 | 2次 | ⬇️ 92% |
| **平均响应时间** | 800ms | 200ms | ⬇️ 75% |
| **事务成功率** | 94% | 99.5% | ⬆️ 5.5% |
| **并发处理能力** | 500 TPS | 1200 TPS | ⬆️ 140% |

### 8.3 持续监控机制


**监控脚本**：
```bash
#!/bin/bash
# deadlock_monitor.sh

LOG_FILE="/var/log/mysql/deadlock_monitor.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

# 检查死锁数量
DEADLOCKS=$(mysql -e "SHOW ENGINE INNODB STATUS\G" | grep -c "LATEST DETECTED DEADLOCK")

# 记录监控结果
echo "[$DATE] Deadlocks detected: $DEADLOCKS" >> $LOG_FILE

# 超过阈值时告警
if [ $DEADLOCKS -gt 5 ]; then
    echo "警告：检测到死锁数量异常 ($DEADLOCKS)" | mail -s "死锁告警" admin@company.com
fi
```

### 8.4 效果评估报告


**月度评估模板**：
```
死锁预防效果评估报告

1. 死锁发生情况
   - 本月死锁次数：X次
   - 环比变化：-Y%
   
2. 性能指标改善
   - 平均响应时间：从Ams降至Bms
   - 事务成功率：从X%提升至Y%
   
3. 预防措施执行情况
   - 代码规范遵循率：X%
   - 超时配置优化：完成
   
4. 下月改进计划
   - 进一步优化锁顺序
   - 增加重试机制覆盖率
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 死锁预防原理：通过破坏死锁产生的必要条件来避免死锁
🔸 资源排序访问：统一的资源访问顺序破坏循环等待条件
🔸 超时机制：设置合理的锁等待超时时间避免无限等待
🔸 事务重试：失败后自动重试提高事务成功率
🔸 业务逻辑设计：从源头设计避免死锁风险
```

### 9.2 关键理解要点


**预防策略的本质**
```
核心思想：预防胜于治疗，从设计阶段就避免死锁
实现方法：破坏死锁形成的必要条件
关键要素：规范、超时、重试、优化设计
```

**策略选择的原则**
```
考虑因素：业务场景、性能要求、开发成本、维护复杂度
平衡关系：安全性 vs 性能，复杂度 vs 效果
组合使用：多种策略组合使用效果更好
```

**效果评估的重要性**
```
持续改进：定期评估预防效果，调整策略
量化指标：用数据说话，客观评估改善程度
闭环管理：发现问题→分析原因→改进措施→效果评估
```

### 9.3 实际应用指导


**开发阶段**：
- ✅ **制定规范**：明确锁顺序和事务设计规范
- ✅ **代码审查**：检查是否遵循预防策略
- ✅ **测试验证**：并发测试验证预防效果
- ✅ **文档完善**：记录设计决策和规范说明

**运维阶段**：
- ✅ **参数配置**：合理设置超时和重试参数
- ✅ **监控告警**：建立死锁监控和告警机制
- ✅ **性能分析**：定期分析死锁和性能指标
- ✅ **持续优化**：根据运行情况调整预防策略

### 9.4 记忆要点


```
🧠 记忆口诀
预防死锁有方法，四个条件破一个
资源排序是关键，统一顺序避循环
超时重试来兜底，失败自动再执行
业务设计要合理，减少争用降风险
策略组合效果好，持续监控保稳定
```

**预防策略优先级**：
1. **资源排序访问**：最根本的预防方法
2. **合理超时设置**：避免长时间等待
3. **事务重试机制**：提高系统容错能力
4. **业务逻辑优化**：从源头减少死锁风险