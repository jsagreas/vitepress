---
title: 10、批量操作死锁检测与处理
---
## 📚 目录

1. [批量操作死锁概述](#1-批量操作死锁概述)
2. [批量INSERT死锁](#2-批量INSERT死锁)
3. [批量UPDATE冲突](#3-批量UPDATE冲突)
4. [批量DELETE锁等待](#4-批量DELETE锁等待)
5. [分批处理策略](#5-分批处理策略)
6. [并发批量控制](#6-并发批量控制)
7. [锁升级问题](#7-锁升级问题)
8. [批量操作优化](#8-批量操作优化)
9. [死锁预防措施](#9-死锁预防措施)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 批量操作死锁概述


### 1.1 什么是批量操作死锁

批量操作死锁是指在处理大量数据时，多个事务相互等待对方释放锁资源而导致的循环等待现象。

**典型场景**：
```
事务A：批量插入用户数据（ID 1-1000）
事务B：批量更新用户状态（ID 500-1500）
结果：相互等待，形成死锁
```

### 1.2 批量死锁的特点

- **涉及范围大**：操作数据量多，锁定资源广
- **持续时间长**：批量操作耗时较久，锁持有时间长
- **并发冲突高**：多个批量操作容易产生交集冲突
- **影响严重**：一旦死锁，影响面大

### 1.3 常见死锁场景


```
场景对比表：
┌─────────────────┬──────────────┬──────────────────┐
│   操作类型      │   锁定范围   │    死锁风险      │
├─────────────────┼──────────────┼──────────────────┤
│ 批量INSERT      │   表级/间隙  │       高         │
│ 批量UPDATE      │   行级/范围  │      极高        │
│ 批量DELETE      │   行级/范围  │      极高        │
│ 混合批量操作    │   多层次锁   │      最高        │
└─────────────────┴──────────────┴──────────────────┘
```

---

## 2. 📝 批量INSERT死锁


### 2.1 死锁产生原理

批量INSERT死锁主要由**间隙锁**和**插入意向锁**冲突导致。

**锁冲突机制**：
```
表结构：users (id PRIMARY KEY, name VARCHAR(50))
现有数据：id = 10, 20, 30

事务A插入：INSERT INTO users VALUES (15, 'Alice'), (25, 'Bob')
事务B插入：INSERT INTO users VALUES (12, 'Charlie'), (22, 'David')

冲突分析：
间隙 (10,20)：事务A插入15，事务B插入12
间隙 (20,30)：事务A插入25，事务B插入22
相互等待间隙锁 → 死锁
```

### 2.2 实际案例分析


```sql
-- 事务A
BEGIN;
INSERT INTO users VALUES 
(101, 'User1'), (103, 'User3'), (105, 'User5');

-- 事务B（同时执行）
BEGIN;
INSERT INTO users VALUES 
(102, 'User2'), (104, 'User4'), (106, 'User6');
```

**死锁检测结果**：
```
LATEST DETECTED DEADLOCK
------------------------
TRANSACTION A:
INSERT INTO users VALUES (103, 'User3')
等待插入意向锁在间隙 (102,104)

TRANSACTION B:  
INSERT INTO users VALUES (104, 'User4')
等待插入意向锁在间隙 (103,105)
```

### 2.3 预防策略

- **🔄 预排序**：按主键顺序批量插入
- **📦 分批处理**：减少单次插入数量
- **⏰ 错峰执行**：避免同时进行批量插入

```sql
-- ✅ 推荐做法：按ID顺序插入
INSERT INTO users VALUES 
(101, 'User1'), (102, 'User2'), (103, 'User3');

-- ❌ 避免：乱序插入
INSERT INTO users VALUES 
(103, 'User3'), (101, 'User1'), (102, 'User2');
```

---

## 3. 🔄 批量UPDATE冲突


### 3.1 UPDATE死锁机制

批量UPDATE死锁通常因为**锁定顺序不一致**导致循环等待。

**经典死锁场景**：
```
事务A：UPDATE users SET status=1 WHERE id BETWEEN 100 AND 200
事务B：UPDATE users SET level=5 WHERE id BETWEEN 150 AND 250

锁定分析：
事务A获取：id=100-149的行锁，等待id=150-200
事务B获取：id=201-250的行锁，等待id=150-200
交集区域 id=150-200 产生死锁
```

### 3.2 范围更新冲突


```sql
-- 场景：电商系统批量更新商品价格
-- 事务A：打折活动
UPDATE products 
SET price = price * 0.8 
WHERE category_id = 1 AND id BETWEEN 1000 AND 2000;

-- 事务B：库存调整
UPDATE products 
SET stock = stock - 10 
WHERE status = 'active' AND id BETWEEN 1500 AND 2500;
```

**冲突分析图**：
```
产品ID范围冲突示意：
事务A: |────────────────────────|
       1000                    2000
事务B:         |────────────────────────|
               1500                    2500
重叠区域:      |──────────|
               1500      2000  ← 死锁区域
```

### 3.3 解决方案


**🎯 统一锁定顺序**：
```sql
-- 方案1：按主键顺序更新
UPDATE products SET price = price * 0.8 
WHERE id IN (SELECT id FROM products 
             WHERE category_id = 1 AND id BETWEEN 1000 AND 2000 
             ORDER BY id);
```

**📦 分段处理**：
```sql
-- 方案2：分批次更新
DELIMITER $$
CREATE PROCEDURE BatchUpdate()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 100;
    DECLARE start_id INT DEFAULT 1000;
    
    WHILE start_id <= 2000 DO
        UPDATE products 
        SET price = price * 0.8 
        WHERE category_id = 1 
        AND id BETWEEN start_id AND start_id + batch_size - 1;
        
        SET start_id = start_id + batch_size;
        COMMIT; -- 分批提交
    END WHILE;
END$$
```

---

## 4. 🗑️ 批量DELETE锁等待


### 4.1 DELETE死锁特点

批量DELETE操作涉及**行锁**、**间隙锁**和**Next-Key锁**，容易形成复杂的锁等待链。

**锁定层次**：
```
DELETE操作锁定层次：
┌─────────────────┐
│   Next-Key锁    │ ← 行锁 + 间隙锁组合
├─────────────────┤
│    间隙锁       │ ← 防止幻读
├─────────────────┤
│    行锁         │ ← 锁定具体行
└─────────────────┘
```

### 4.2 典型死锁案例


```sql
-- 订单清理场景
-- 事务A：删除过期订单
DELETE FROM orders 
WHERE create_time < '2024-01-01' 
AND status IN ('cancelled', 'expired')
LIMIT 1000;

-- 事务B：删除测试数据
DELETE FROM orders 
WHERE user_id IN (SELECT id FROM test_users)
AND create_time < '2024-06-01'
LIMIT 500;
```

**死锁分析**：
```
锁冲突时序：
T1: 事务A锁定 orders(id=100-200, status='cancelled')
T2: 事务B锁定 orders(id=150-300, user_id IN test_users)  
T3: 事务A等待 orders(id=150-200) 
T4: 事务B等待 orders(id=150-200)
结果: 循环等待 → 死锁
```

### 4.3 优化策略


**🔍 精确条件删除**：
```sql
-- ✅ 推荐：明确的删除条件
DELETE FROM orders 
WHERE id IN (
    SELECT id FROM (
        SELECT id FROM orders 
        WHERE create_time < '2024-01-01' 
        AND status = 'cancelled'
        ORDER BY id LIMIT 100
    ) t
);
```

**⏱️ 分时间段删除**：
```sql
-- 分批删除，避免长时间锁定
SET @batch_date = '2024-01-01';
WHILE @batch_date < '2024-12-31' DO
    DELETE FROM orders 
    WHERE create_time >= @batch_date 
    AND create_time < DATE_ADD(@batch_date, INTERVAL 1 DAY)
    AND status = 'cancelled'
    LIMIT 100;
    
    SET @batch_date = DATE_ADD(@batch_date, INTERVAL 1 DAY);
END WHILE;
```

---

## 5. 📦 分批处理策略


### 5.1 分批处理原理

分批处理是将大批量操作拆分为多个小批次，降低锁冲突和死锁风险的核心策略。

**分批处理优势**：
- **🔒 减少锁范围**：单次操作涉及数据量少
- **⏰ 缩短锁时间**：每批次快速完成
- **🔄 增加并发**：其他事务有更多机会执行
- **📊 便于监控**：可以观察每批次执行情况

### 5.2 分批大小确定


```sql
-- 分批大小测试
SET @batch_sizes = '50,100,200,500,1000';
SET @test_table = 'large_table';

-- 性能测试结果示例：
┌─────────────┬──────────────┬──────────────┬──────────────┐
│  批次大小   │   执行时间   │   锁等待次数 │   死锁次数   │
├─────────────┼──────────────┼──────────────┼──────────────┤
│     50      │    0.1s      │      0       │      0       │
│    100      │    0.2s      │      1       │      0       │
│    200      │    0.5s      │      3       │      0       │
│    500      │    1.2s      │      8       │      1       │
│   1000      │    2.8s      │     15       │      3       │
└─────────────┴──────────────┴──────────────┴──────────────┘
```

### 5.3 动态分批算法


```sql
DELIMITER $$
CREATE PROCEDURE DynamicBatchProcess()
BEGIN
    DECLARE batch_size INT DEFAULT 100;
    DECLARE deadlock_count INT DEFAULT 0;
    DECLARE max_retries INT DEFAULT 3;
    
    batch_loop: LOOP
        BEGIN
            DECLARE EXIT HANDLER FOR 1213 -- 死锁错误
            BEGIN
                SET deadlock_count = deadlock_count + 1;
                IF deadlock_count >= max_retries THEN
                    SET batch_size = batch_size / 2; -- 减少批次大小
                    SET deadlock_count = 0;
                END IF;
                ROLLBACK;
            END;
            
            -- 执行批量操作
            UPDATE products SET price = price * 1.1 
            WHERE id BETWEEN @start_id AND @start_id + batch_size - 1;
            
            COMMIT;
            SET @start_id = @start_id + batch_size;
            
        END;
        
        -- 检查是否完成
        IF @start_id > @max_id THEN
            LEAVE batch_loop;
        END IF;
    END LOOP;
END$$
```

---

## 6. 🚦 并发批量控制


### 6.1 并发控制机制

在多个批量操作并发执行时，需要协调机制避免资源冲突。

**控制策略层次**：
```
并发控制架构：
┌─────────────────────────────┐
│     应用层并发控制           │ ← 业务逻辑控制
├─────────────────────────────┤  
│     数据库连接池控制         │ ← 连接数限制
├─────────────────────────────┤
│     事务隔离级别控制         │ ← 锁粒度控制
├─────────────────────────────┤
│     MySQL锁机制             │ ← 底层锁实现
└─────────────────────────────┘
```

### 6.2 资源分区策略


```sql
-- 按业务分区避免冲突
-- 用户数据分区处理
CREATE TABLE batch_locks (
    resource_type VARCHAR(50),
    partition_id INT,
    lock_time TIMESTAMP,
    process_id VARCHAR(100),
    PRIMARY KEY (resource_type, partition_id)
);

-- 获取分区锁
INSERT INTO batch_locks VALUES 
('user_update', 1, NOW(), CONNECTION_ID())
ON DUPLICATE KEY UPDATE 
    lock_time = IF(lock_time < NOW() - INTERVAL 5 MINUTE, NOW(), lock_time),
    process_id = IF(lock_time < NOW() - INTERVAL 5 MINUTE, CONNECTION_ID(), process_id);
```

### 6.3 队列化处理


```sql
-- 批量操作队列表
CREATE TABLE batch_queue (
    id INT AUTO_INCREMENT PRIMARY KEY,
    operation_type ENUM('INSERT', 'UPDATE', 'DELETE'),
    table_name VARCHAR(100),
    condition_sql TEXT,
    batch_size INT DEFAULT 100,
    priority INT DEFAULT 5,
    status ENUM('pending', 'processing', 'completed', 'failed'),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_status_priority (status, priority)
);

-- 队列处理器
DELIMITER $$
CREATE PROCEDURE ProcessBatchQueue()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE queue_id INT;
    DECLARE op_type VARCHAR(20);
    DECLARE sql_text TEXT;
    
    DECLARE queue_cursor CURSOR FOR
        SELECT id, operation_type, condition_sql 
        FROM batch_queue 
        WHERE status = 'pending' 
        ORDER BY priority DESC, created_time ASC
        LIMIT 1;
        
    OPEN queue_cursor;
    FETCH queue_cursor INTO queue_id, op_type, sql_text;
    
    IF NOT done THEN
        UPDATE batch_queue SET status = 'processing' WHERE id = queue_id;
        -- 执行具体操作
        SET @sql = sql_text;
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        UPDATE batch_queue SET status = 'completed' WHERE id = queue_id;
    END IF;
    
    CLOSE queue_cursor;
END$$
```

---

## 7. 📈 锁升级问题


### 7.1 锁升级概念

锁升级是指MySQL在特定条件下将多个细粒度锁合并为粗粒度锁的过程。

**升级触发条件**：
- 🔢 **锁数量过多**：单个事务持有锁超过阈值
- 💾 **内存压力**：锁表占用内存过大
- 📊 **锁冲突频繁**：细粒度锁效率低下

### 7.2 升级影响分析


```sql
-- 锁升级示例场景
-- 批量更新操作可能触发锁升级
UPDATE products SET price = price * 1.1 
WHERE category_id = 1; -- 假设影响10万行数据

-- 锁升级过程：
-- 阶段1：行锁 (10万个行锁)
-- 阶段2：页锁 (1000个页锁) 
-- 阶段3：表锁 (1个表锁) ← 升级结果
```

**升级影响对比**：
```
┌─────────────┬──────────────┬──────────────┬──────────────┐
│   锁类型    │   并发度     │   内存占用   │   冲突风险   │
├─────────────┼──────────────┼──────────────┼──────────────┤
│    行锁     │     高       │     高       │     低       │
│    页锁     │     中       │     中       │     中       │
│    表锁     │     低       │     低       │     高       │
└─────────────┴──────────────┴──────────────┴──────────────┘
```

### 7.3 预防锁升级


```sql
-- 方法1：控制单次操作数据量
SET SESSION innodb_lock_wait_timeout = 50;

DELIMITER $$
CREATE PROCEDURE PreventLockEscalation()
BEGIN
    DECLARE batch_count INT DEFAULT 0;
    DECLARE total_updated INT DEFAULT 0;
    
    batch_loop: LOOP
        UPDATE products 
        SET price = price * 1.1 
        WHERE category_id = 1 
        AND id BETWEEN batch_count * 100 + 1 AND (batch_count + 1) * 100;
        
        SET total_updated = total_updated + ROW_COUNT();
        SET batch_count = batch_count + 1;
        
        -- 每100行提交一次
        COMMIT;
        
        IF ROW_COUNT() = 0 THEN
            LEAVE batch_loop;
        END IF;
    END LOOP;
END$$

-- 方法2：使用索引优化
CREATE INDEX idx_category_price ON products(category_id, price);
```

---

## 8. ⚡ 批量操作优化


### 8.1 性能优化原则

批量操作优化需要在**性能**、**并发性**和**数据一致性**之间找到平衡点。

**优化方向**：
```
性能优化金字塔：
        ┌─────────────┐
        │  应用层优化  │ ← 算法、逻辑优化
        ├─────────────┤
        │  SQL层优化   │ ← 语句、索引优化  
        ├─────────────┤
        │  存储层优化  │ ← 配置、硬件优化
        └─────────────┘
```

### 8.2 SQL层面优化


```sql
-- 优化前：普通批量插入
INSERT INTO user_logs (user_id, action, log_time) VALUES
(1, 'login', NOW()),
(2, 'logout', NOW()),
(3, 'purchase', NOW());

-- 优化后：批量插入优化
-- 1. 关闭自动提交
SET autocommit = 0;

-- 2. 使用扩展插入语法
INSERT INTO user_logs (user_id, action, log_time) VALUES
(1, 'login', '2024-01-22 10:00:00'),
(2, 'logout', '2024-01-22 10:01:00'),
(3, 'purchase', '2024-01-22 10:02:00'),
(4, 'login', '2024-01-22 10:03:00'),
(5, 'view', '2024-01-22 10:04:00');

COMMIT;

-- 3. 使用LOAD DATA优化大批量插入
LOAD DATA INFILE '/tmp/user_logs.csv'
INTO TABLE user_logs
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
(user_id, action, log_time);
```

### 8.3 配置层面优化


```sql
-- 批量操作相关参数调优
SET SESSION innodb_buffer_pool_size = 2147483648;        -- 2GB缓冲池
SET SESSION bulk_insert_buffer_size = 67108864;          -- 64MB批量插入缓冲
SET SESSION innodb_log_file_size = 268435456;            -- 256MB日志文件
SET SESSION innodb_log_buffer_size = 33554432;           -- 32MB日志缓冲
SET SESSION innodb_flush_log_at_trx_commit = 2;          -- 异步刷新日志

-- 临时关闭约束检查（仅在数据迁移时使用）
SET foreign_key_checks = 0;
SET unique_checks = 0;

-- 批量操作后恢复
SET foreign_key_checks = 1;
SET unique_checks = 1;
```

### 8.4 监控与调优


```sql
-- 批量操作监控查询
-- 查看锁等待情况
SELECT 
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;

-- 查看批量操作进度
SHOW PROCESSLIST;

-- 检查表锁状态
SHOW OPEN TABLES WHERE In_use > 0;
```

---

## 9. 🛡️ 死锁预防措施


### 9.1 预防策略体系

死锁预防需要从**设计阶段**、**开发阶段**和**运行阶段**全方位考虑。

**预防措施层次**：
```
死锁预防体系：
┌─────────────────────────────────┐
│         设计层预防               │
│  • 表结构设计                   │  
│  • 索引策略                     │
│  • 业务流程设计                 │
├─────────────────────────────────┤
│         开发层预防               │
│  • SQL编写规范                  │
│  • 事务设计                     │  
│  • 错误处理                     │
├─────────────────────────────────┤
│         运行层预防               │
│  • 监控告警                     │
│  • 参数调优                     │
│  • 应急处理                     │
└─────────────────────────────────┘
```

### 9.2 编码规范


```sql
-- ✅ 推荐的批量操作编写规范

-- 1. 统一锁定顺序
DELIMITER $$
CREATE PROCEDURE StandardBatchUpdate()
BEGIN
    DECLARE EXIT HANDLER FOR 1213 -- 死锁处理
    BEGIN
        ROLLBACK;
        SELECT 'Deadlock detected, operation rolled back' AS result;
    END;
    
    -- 按主键顺序处理
    UPDATE products 
    SET price = price * 1.1 
    WHERE id IN (
        SELECT id FROM (
            SELECT id FROM products 
            WHERE category_id = 1 
            ORDER BY id  -- 关键：排序
        ) tmp
    );
    
    COMMIT;
END$$

-- 2. 设置合理超时
SET SESSION innodb_lock_wait_timeout = 10; -- 10秒超时

-- 3. 分批提交模式
BEGIN;
UPDATE products SET price = price * 1.1 WHERE id BETWEEN 1 AND 100;
COMMIT;

BEGIN;  
UPDATE products SET price = price * 1.1 WHERE id BETWEEN 101 AND 200;
COMMIT;
```

### 9.3 实时监控方案


```sql
-- 死锁监控存储过程
DELIMITER $$
CREATE PROCEDURE MonitorDeadlocks()
BEGIN
    DECLARE deadlock_count INT DEFAULT 0;
    
    -- 检查最近1小时的死锁数量
    SELECT COUNT(*) INTO deadlock_count
    FROM information_schema.innodb_metrics 
    WHERE name = 'lock_deadlocks' 
    AND time_enabled > NOW() - INTERVAL 1 HOUR;
    
    -- 超过阈值则告警
    IF deadlock_count > 10 THEN
        INSERT INTO alert_log (alert_type, message, created_time)
        VALUES ('DEADLOCK_HIGH', 
                CONCAT('Deadlock count in last hour: ', deadlock_count),
                NOW());
    END IF;
    
    -- 获取当前锁等待信息
    SELECT 
        waiting_pid,
        waiting_query,
        blocking_pid,
        blocking_query,
        wait_age_secs
    FROM sys.innodb_lock_waits
    WHERE wait_age_secs > 30; -- 等待超过30秒的事务
END$$

-- 定期执行监控（配合定时任务）
EVENT scheduler = ON;
CREATE EVENT DeadlockMonitorEvent
ON SCHEDULE EVERY 1 MINUTE
DO CALL MonitorDeadlocks();
```

### 9.4 应急处理预案


```sql
-- 死锁应急处理工具包

-- 1. 查看当前所有锁等待
CREATE VIEW current_lock_waits AS
SELECT 
    r.trx_id AS waiting_trx,
    r.trx_mysql_thread_id AS waiting_thread,
    SUBSTRING(r.trx_query, 1, 100) AS waiting_query,
    r.trx_operation_state AS waiting_state,
    b.trx_id AS blocking_trx,
    b.trx_mysql_thread_id AS blocking_thread,
    SUBSTRING(b.trx_query, 1, 100) AS blocking_query,
    b.trx_operation_state AS blocking_state
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id;

-- 2. 强制终止长时间运行的事务
DELIMITER $$
CREATE PROCEDURE KillLongRunningTrx(IN max_runtime_seconds INT)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE thread_id INT;
    DECLARE trx_cursor CURSOR FOR
        SELECT trx_mysql_thread_id 
        FROM information_schema.innodb_trx
        WHERE trx_started < NOW() - INTERVAL max_runtime_seconds SECOND;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN trx_cursor;
    kill_loop: LOOP
        FETCH trx_cursor INTO thread_id;
        IF done THEN
            LEAVE kill_loop;
        END IF;
        
        SET @sql = CONCAT('KILL ', thread_id);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    
    CLOSE trx_cursor;
END$$

-- 使用示例：终止运行超过300秒的事务
CALL KillLongRunningTrx(300);
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 批量死锁本质：多事务操作大量数据时的锁资源竞争
🔸 主要类型：INSERT间隙锁冲突、UPDATE范围冲突、DELETE复合锁冲突  
🔸 预防策略：统一锁顺序、分批处理、并发控制、锁升级预防
🔸 优化方向：SQL优化、配置调优、监控预警、应急处理
🔸 核心原则：小批量、短事务、有序锁、快提交
```

### 10.2 关键理解要点


**🔹 为什么批量操作容易死锁**：
```
根本原因：
- 锁范围大：涉及数据量多，锁定资源广
- 持续时间长：操作耗时久，锁持有时间长  
- 交集冲突：多个批量操作容易产生数据交集
- 顺序不一：不同事务锁定顺序不同易形成环路等待
```

**🔹 分批处理的核心价值**：
```
优势分析：
- 缩小锁范围：单次锁定数据量少
- 缩短锁时间：快速完成单批次操作
- 增加并发机会：其他事务有机会穿插执行
- 便于错误恢复：失败时只影响当前批次
```

**🔹 监控的重要性**：
```
监控价值：
- 提前发现：在死锁频发前识别风险
- 快速定位：准确找到死锁原因和涉及事务
- 优化指导：为调优提供数据支撑
- 应急处理：快速响应和解决问题
```

### 10.3 实战应用指导


**🎯 批量操作最佳实践**：
- **📦 合理分批**：单批次100-1000行，根据业务调整
- **🔄 统一顺序**：按主键或索引顺序处理数据
- **⏰ 控制时间**：单个事务不超过10秒
- **🔍 监控告警**：实时监控锁等待和死锁情况
- **🛡️ 异常处理**：完善的死锁重试和回滚机制

**🚨 问题排查思路**：
```
排查步骤：
1. 查看死锁日志：SHOW ENGINE INNODB STATUS
2. 分析锁等待：查询 information_schema.innodb_lock_waits
3. 检查事务状态：查询 information_schema.innodb_trx  
4. 定位冲突SQL：分析具体的冲突语句
5. 优化改进：调整SQL、分批策略或时序安排
```

### 10.4 性能优化要点


**⚡ 性能调优策略**：
```
调优层次：
应用层：合理分批、统一顺序、错峰执行
SQL层：索引优化、语句重构、批量语法
配置层：缓冲池、日志参数、超时设置  
硬件层：SSD磁盘、充足内存、多核CPU
```

**核心记忆口诀**：
- 批量操作要分批，统一顺序防死锁
- 监控告警很重要，快速定位解问题  
- 小批量短事务，性能并发两不误
- 预防胜于治疗法，设计开发要规范