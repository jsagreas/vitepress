---
title: 12、事务与缓冲池交互
---
## 📚 目录

1. [事务与缓冲池交互基础](#1-事务与缓冲池交互基础)
2. [缓冲池页面锁定机制](#2-缓冲池页面锁定机制)
3. [脏页管理策略](#3-脏页管理策略)
4. [页面版本控制](#4-页面版本控制)
5. [缓冲池LRU与事务](#5-缓冲池lru与事务)
6. [页面换出控制](#6-页面换出控制)
7. [缓冲池监控优化](#7-缓冲池监控优化)
8. [缓冲池交互完整机制](#8-缓冲池交互完整机制)
9. [交互性能优化](#9-交互性能优化)
10. [交互监控管理](#10-交互监控管理)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 📖 事务与缓冲池交互基础


### 1.1 什么是事务与缓冲池交互


**通俗理解**：事务与缓冲池的交互就像是"工人在工作台上处理材料"的过程。缓冲池是工作台（内存空间），存放着数据页（材料），事务是工人（操作者），需要在工作台上读取、修改这些材料。

```
生活类比：
图书馆阅读室 = 缓冲池
书籍 = 数据页
读者 = 事务
管理员 = 缓冲池管理器

读者要看书时：
1. 先在阅读室找书（缓冲池查找页面）
2. 如果没有，管理员从书库拿来（从磁盘加载页面）
3. 读者占用座位看书（事务锁定页面）
4. 看完后归还座位（释放页面锁定）
```

**🔸 核心概念**
- **缓冲池（Buffer Pool）**：InnoDB的内存缓存区域，存储数据页
- **页面锁定（Page Latch）**：事务访问页面时的短期锁定
- **脏页（Dirty Page）**：在内存中被修改但还未写入磁盘的页面
- **页面版本**：用于实现MVCC的页面多版本控制

### 1.2 交互的基本流程


**📊 事务访问数据的完整流程**
```
事务读取数据：
步骤1：检查缓冲池是否有目标页面
步骤2：如果没有，从磁盘加载页面到缓冲池
步骤3：获取页面的共享锁（S锁）
步骤4：读取页面数据
步骤5：释放页面锁

事务修改数据：
步骤1：检查缓冲池是否有目标页面
步骤2：如果没有，从磁盘加载页面到缓冲池  
步骤3：获取页面的排他锁（X锁）
步骤4：修改页面数据，标记为脏页
步骤5：记录redo日志
步骤6：释放页面锁
```

**💡 关键特点**
```
并发控制：
• 多个事务可以同时读取同一页面（共享锁）
• 只有一个事务能修改页面（排他锁）
• 页面锁的持有时间很短，提高并发性

一致性保证：
• 通过MVCC避免读写冲突
• 脏页及时刷新保证持久性
• undo日志支持事务回滚
```

---

## 2. 🔒 缓冲池页面锁定机制


### 2.1 页面锁定的基本概念


**🔸 页面锁定vs行锁定**
```
页面锁定（Page Latch）：
• 作用：保护缓冲池中页面的物理完整性
• 持有时间：毫秒级，非常短暂
• 目的：防止页面在读写过程中被破坏

行锁定（Row Lock）：
• 作用：保证事务的逻辑一致性
• 持有时间：事务级，可能很长
• 目的：实现事务的隔离性
```

**📊 锁定类型**

| 锁类型 | 用途 | 持有时间 | 并发特性 |
|--------|------|----------|----------|
| **页面S锁** | 读取页面数据 | 读取期间 | 多个事务可同时持有 |
| **页面X锁** | 修改页面数据 | 修改期间 | 排他性，只能一个事务持有 |
| **页面SX锁** | 读取并准备修改 | 读取到修改完成 | 特殊的升级锁 |

### 2.2 页面锁定的获取过程


**🎯 锁定获取流程**
```sql
-- 查看页面锁定等待情况
SELECT 
    event_name,
    count_star as 等待次数,
    sum_timer_wait/1000000000 as 总等待时间秒
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE event_name LIKE '%latch%'
ORDER BY sum_timer_wait DESC;
```

**⚡ 锁定冲突处理**
```
锁定冲突场景：
1. 事务A持有页面X锁，事务B请求S锁 → 等待
2. 事务A持有页面S锁，事务B请求X锁 → 等待  
3. 多个事务持有S锁，新事务请求S锁 → 立即获得

冲突解决：
• 等待队列：按FIFO顺序排队等待
• 超时机制：避免无限等待
• 死锁检测：检测并解决页面锁死锁
```

### 2.3 页面锁定优化技巧


**🔥 减少页面锁定冲突**
```sql
-- 监控页面锁定争用
SHOW ENGINE INNODB STATUS\G

-- 关注以下指标：
-- Mutex spin waits: 互斥锁自旋等待
-- Mutex spin rounds: 自旋轮数  
-- Mutex OS waits: 操作系统等待
```

**💡 优化策略**
```
应用层优化：
• 减少事务持有时间
• 避免长时间的大事务
• 按相同顺序访问页面避免死锁

系统参数调优：
• innodb_spin_wait_delay：自旋等待延迟
• innodb_sync_spin_loops：自旋循环次数
• innodb_thread_concurrency：并发线程数限制
```

---

## 3. 💧 脏页管理策略


### 3.1 脏页的产生和特征


**🔸 什么是脏页**
```
脏页产生过程：
1. 事务修改缓冲池中的页面数据
2. 修改后的页面与磁盘上的不一致
3. 这个被修改的页面就叫做脏页
4. 脏页需要在适当时机刷新到磁盘
```

**📊 脏页状态跟踪**
```sql
-- 查看脏页相关信息
SELECT 
    pool_id,
    pool_size,
    free_buffers,
    database_pages,
    dirty_pages,
    ROUND(dirty_pages*100.0/database_pages, 2) as 脏页比例
FROM information_schema.innodb_buffer_pool_stats;
```

### 3.2 脏页刷新策略


**🔥 刷新触发条件**
```
主动刷新：
• innodb_max_dirty_pages_pct达到阈值
• innodb_max_dirty_pages_pct_lwm达到低水位
• redo日志空间不足需要清理
• 缓冲池空间不足需要淘汰页面

被动刷新：
• 检查点（Checkpoint）时强制刷新
• 实例关闭时刷新所有脏页  
• 页面被淘汰前必须刷新
```

**⚡ 刷新算法**
```sql
-- 查看刷新相关参数
SHOW VARIABLES LIKE '%dirty_pages%';
SHOW VARIABLES LIKE '%flush%';

-- 关键参数：
-- innodb_max_dirty_pages_pct = 90 (脏页比例上限)
-- innodb_max_dirty_pages_pct_lwm = 10 (低水位)
-- innodb_io_capacity = 200 (IO能力)
-- innodb_flush_neighbors = 1 (相邻页面刷新)
```

### 3.3 脏页刷新优化


**🎯 自适应刷新算法**
```
自适应策略：
• 根据redo日志生成速度调整刷新速度
• 根据脏页比例动态调整刷新频率
• 考虑磁盘IO能力避免性能影响

优化配置：
• innodb_adaptive_flushing = ON
• innodb_flush_method = O_DIRECT  
• innodb_io_capacity_max = 2000
```

**💡 监控脏页刷新**
```sql
-- 监控脏页刷新效果
SELECT 
    variable_name,
    variable_value
FROM performance_schema.global_status 
WHERE variable_name LIKE '%flush%' 
   OR variable_name LIKE '%dirty%'
ORDER BY variable_name;
```

---

## 4. 📄 页面版本控制


### 4.1 MVCC与页面版本


**🔸 页面版本的概念**
```
页面版本控制原理：
• 每个数据行都有隐藏的版本字段（trx_id, roll_ptr）
• 不同事务看到的是不同版本的数据
• 通过undo日志链实现多版本访问
• 避免读写冲突，提高并发性能
```

**📊 版本控制机制**
```
版本号规则：
创建版本号：记录创建时的事务ID
删除版本号：记录删除时的事务ID  

读取规则：
• 只能读取创建版本号 ≤ 当前事务ID的记录
• 不能读取删除版本号 ≤ 当前事务ID的记录
• 保证读取到事务开始时的一致性快照
```

### 4.2 ReadView机制


**🎯 ReadView的作用**
```sql
-- 查看当前活跃事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_isolation_level
FROM information_schema.innodb_trx;
```

**🔍 版本可见性判断**
```
ReadView包含信息：
• m_low_limit_id：最大事务ID + 1
• m_up_limit_id：最小活跃事务ID
• m_ids：活跃事务ID列表
• m_creator_trx_id：创建ReadView的事务ID

可见性判断逻辑：
1. trx_id < m_up_limit_id → 可见
2. trx_id >= m_low_limit_id → 不可见
3. trx_id在m_ids中 → 不可见
4. 其他情况 → 可见
```

### 4.3 版本控制性能影响


**⚡ 性能考虑因素**
```
性能影响：
• undo日志链过长影响查询性能
• 长事务阻止undo日志清理
• ReadView创建有一定开销

优化策略：
• 避免长时间运行的事务
• 及时提交事务释放undo
• 合理设置innodb_undo_tablespaces
• 监控undo日志使用情况
```

**📊 版本控制监控**
```sql
-- 监控undo使用情况
SELECT 
    tablespace_name,
    file_name,
    file_size/1024/1024 as size_mb
FROM information_schema.files 
WHERE tablespace_name LIKE '%undo%';
```

---

## 5. 🔄 缓冲池LRU与事务


### 5.1 LRU算法基础


**🔸 传统LRU vs InnoDB LRU**
```
传统LRU问题：
• 全表扫描会污染缓冲池
• 热点数据可能被意外淘汰
• 无法区分访问模式的重要性

InnoDB改进LRU：
• 分为New Sublist和Old Sublist
• 新页面先插入Old区域
• 需要等待时间才能进入New区域
• 避免批量扫描污染热点数据
```

**📊 LRU链表结构**
```
缓冲池LRU链表：
┌─────────────────┐
│   New Sublist   │ ← 热点数据区域（默认5/8）
│     (热点)      │
├─────────────────┤
│   Old Sublist   │ ← 新加载数据区域（默认3/8）  
│    (新加载)     │
└─────────────────┘

移动规则：
• 新页面 → Old区域头部
• Old区域访问 → 等待时间后移动到New区域
• New区域访问 → 移动到New区域头部
```

### 5.2 事务对LRU的影响


**🎯 事务访问模式影响**
```sql
-- 查看缓冲池LRU状态
SELECT 
    pool_id,
    pool_size,
    old_database_pages,
    young_database_pages,
    ROUND(old_database_pages*100.0/pool_size, 2) as old_ratio
FROM information_schema.innodb_buffer_pool_stats;
```

**⚡ 不同事务模式的LRU影响**
```
OLTP事务特点：
• 随机访问模式
• 访问数据集相对固定
• 有明显的热点数据
• 适合LRU算法

OLAP查询特点：
• 顺序扫描大量数据
• 一次性访问，很少重复
• 容易污染缓冲池
• 需要特殊处理
```

### 5.3 LRU优化配置


**🔥 关键参数调优**
```sql
-- LRU相关参数
SHOW VARIABLES LIKE '%old%';

-- 重要参数：
-- innodb_old_blocks_pct = 37 (Old区域比例)
-- innodb_old_blocks_time = 1000 (Old区域等待时间ms)
-- innodb_buffer_pool_size (缓冲池总大小)
```

**💡 优化策略**
```
针对不同工作负载：
OLTP优化：
• 增大缓冲池大小
• 减少Old区域比例
• 缩短Old区域等待时间

OLAP优化：  
• 增加Old区域比例
• 延长Old区域等待时间
• 考虑使用查询提示
```

---

## 6. 🔄 页面换出控制


### 6.1 页面换出触发条件


**🔸 何时需要页面换出**
```
换出触发情况：
1. 缓冲池空间不足，需要加载新页面
2. 脏页比例超过限制，需要强制刷新
3. 系统内存压力大，需要释放内存
4. 实例关闭时的清理过程
```

**📊 换出选择策略**
```
页面换出优先级：
最优先：Clean页面且在LRU尾部
次优先：Old区域的页面
较低优先：New区域的非热点页面
最低优先：频繁访问的热点页面

换出限制：
• 正在被事务使用的页面不能换出
• 持有页面锁的页面不能换出
• 脏页必须先刷新再换出
```

### 6.2 换出过程控制


**⚡ 换出流程控制**
```sql
-- 监控页面换出情况
SELECT 
    variable_name,
    variable_value
FROM performance_schema.global_status 
WHERE variable_name LIKE '%evict%'
   OR variable_name LIKE '%lru%'
ORDER BY variable_name;
```

**🎯 换出性能优化**
```
优化策略：
• 预读取减少换出频率
• 批量换出提高效率
• 异步刷新脏页避免阻塞
• 合理配置缓冲池大小

相关参数：
• innodb_lru_scan_depth：LRU扫描深度
• innodb_buffer_pool_instances：缓冲池实例数
• innodb_page_cleaners：页面清理线程数
```

### 6.3 防止重要页面换出


**🔥 页面重要性评估**
```
重要页面特征：
• 索引根页面和高层节点
• 频繁访问的数据页面
• 系统表和元数据页面
• 正在进行事务的页面

保护机制：
• 固定重要页面在缓冲池中
• 延长重要页面的生存时间
• 优先换出临时和扫描页面
```

---

## 7. 📊 缓冲池监控优化


### 7.1 关键监控指标


**📈 核心性能指标**
```sql
-- 缓冲池命中率
SELECT 
    ROUND(
        (1 - (innodb_buffer_pool_reads / innodb_buffer_pool_read_requests)) * 100, 2
    ) as 缓冲池命中率
FROM (
    SELECT 
        variable_value as innodb_buffer_pool_reads
    FROM performance_schema.global_status 
    WHERE variable_name = 'Innodb_buffer_pool_reads'
) reads
CROSS JOIN (
    SELECT 
        variable_value as innodb_buffer_pool_read_requests  
    FROM performance_schema.global_status
    WHERE variable_name = 'Innodb_buffer_pool_read_requests'
) requests;
```

**🎯 详细状态监控**
```sql
-- 综合缓冲池状态
SELECT 
    pool_id as 池ID,
    pool_size as 总页面数,
    free_buffers as 空闲页面,
    database_pages as 数据页面,
    dirty_pages as 脏页数量,
    ROUND(dirty_pages*100.0/database_pages, 2) as 脏页比例,
    old_database_pages as Old区页面,
    ROUND(old_database_pages*100.0/database_pages, 2) as Old区比例
FROM information_schema.innodb_buffer_pool_stats;
```

### 7.2 性能瓶颈识别


**⚡ 常见瓶颈识别**
```sql
-- 查看等待事件
SELECT 
    event_name,
    count_star as 发生次数,
    ROUND(sum_timer_wait/1000000000, 2) as 总等待时间秒,
    ROUND(avg_timer_wait/1000000, 2) as 平均等待时间毫秒
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE event_name LIKE '%buffer%'
   OR event_name LIKE '%io%'
ORDER BY sum_timer_wait DESC;
```

**🔍 问题诊断方法**
```
常见问题及解决：

缓冲池命中率低：
• 增大innodb_buffer_pool_size
• 检查是否有全表扫描
• 优化查询减少随机IO

脏页比例过高：
• 调整innodb_max_dirty_pages_pct
• 增加innodb_io_capacity
• 检查磁盘IO性能

页面换出频繁：
• 增大缓冲池大小
• 优化查询减少数据访问量
• 调整LRU参数
```

### 7.3 监控自动化


**🤖 自动监控脚本**
```sql
-- 创建监控视图
CREATE VIEW buffer_pool_monitor AS
SELECT 
    NOW() as 监控时间,
    (SELECT variable_value FROM performance_schema.global_status 
     WHERE variable_name = 'Innodb_buffer_pool_read_requests') as 读请求总数,
    (SELECT variable_value FROM performance_schema.global_status 
     WHERE variable_name = 'Innodb_buffer_pool_reads') as 物理读次数,
    dirty_pages as 脏页数量,
    ROUND(dirty_pages*100.0/database_pages, 2) as 脏页比例百分比
FROM information_schema.innodb_buffer_pool_stats;
```

**📊 报警规则设置**
```
报警阈值建议：
• 缓冲池命中率 < 95%：需要关注
• 脏页比例 > 75%：需要优化
• 页面换出频率过高：需要调整
• 等待时间异常：需要排查

监控频率：
• 实时监控：关键指标每分钟检查
• 趋势分析：每小时记录统计数据
• 报表生成：每日汇总分析报告
```

---

## 8. 🔧 缓冲池交互完整机制


### 8.1 完整交互流程


**📊 端到端交互机制**
```
事务执行完整流程：

1. 事务开始
   ↓
2. 查找目标页面
   ├─ 缓冲池命中 → 直接访问
   └─ 缓冲池未命中 → 从磁盘加载
   ↓
3. 获取页面锁定
   ├─ 读操作 → 共享锁
   └─ 写操作 → 排他锁
   ↓
4. 执行数据操作
   ├─ 读取数据
   └─ 修改数据（标记脏页）
   ↓
5. 记录日志
   ├─ redo日志（重做）
   └─ undo日志（回滚）
   ↓
6. 释放页面锁定
   ↓
7. 事务提交/回滚
```

### 8.2 并发控制机制


**🔐 多事务并发处理**
```
并发场景处理：

场景1：多事务读取同一页面
• 所有事务获得共享锁
• 并发读取不冲突
• 通过MVCC看到一致性数据

场景2：读写事务并发
• 写事务获得排他锁修改数据
• 读事务通过MVCC读取旧版本
• 避免读写冲突

场景3：多事务写入同一页面
• 只有一个事务能获得排他锁
• 其他事务等待或者超时
• 通过行锁进一步细化控制
```

### 8.3 异常情况处理


**⚠️ 异常情况应对**
```
常见异常及处理：

内存不足：
• 触发页面换出机制
• 优先换出不重要页面
• 必要时强制刷新脏页

磁盘故障：
• 激活重做日志恢复
• 从备份恢复数据
• 切换到备用存储

死锁检测：
• 自动检测死锁循环
• 选择代价最小事务回滚
• 释放资源解除死锁

崩溃恢复：
• 重做未完成的操作
• 回滚未提交的事务
• 恢复数据一致性
```

---

## 9. ⚡ 交互性能优化


### 9.1 硬件层面优化


**🔧 硬件配置建议**
```
内存配置：
• 缓冲池大小 = 物理内存的70-80%
• 多实例配置提高并发性
• 使用大页内存提高效率

存储配置：
• SSD存储提高随机IO性能
• RAID配置提供冗余和性能
• 分离redo日志和数据文件

CPU配置：
• 多核CPU支持并发处理
• 合理设置线程并发数
• CPU绑定避免上下文切换
```

### 9.2 软件参数优化


**🎯 关键参数调优**
```sql
-- 核心性能参数
SET GLOBAL innodb_buffer_pool_size = 8G;
SET GLOBAL innodb_buffer_pool_instances = 8;
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_io_capacity_max = 4000;
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
SET GLOBAL innodb_thread_concurrency = 0;
```

**📊 参数配置策略**
```
工作负载特定优化：

OLTP工作负载：
• 较大的缓冲池
• 较高的IO容量设置
• 启用自适应哈希索引
• 合理的并发线程数

OLAP工作负载：
• 调整读取预取参数
• 增加排序缓冲区大小
• 优化临时表配置
• 调整LRU算法参数
```

### 9.3 应用层面优化


**💡 最佳实践建议**
```
事务设计优化：
• 保持事务简短快速
• 避免长时间持有锁
• 合理批量处理数据
• 按顺序访问避免死锁

查询优化：
• 使用适当的索引
• 避免全表扫描
• 优化JOIN操作
• 使用分区表

连接管理：
• 使用连接池
• 合理设置连接超时
• 监控连接使用情况
• 避免连接泄漏
```

---

## 10. 📊 交互监控管理


### 10.1 监控体系建设


**📈 分层监控策略**
```
监控层次：

系统层监控：
• CPU使用率
• 内存使用情况  
• 磁盘IO性能
• 网络带宽利用率

MySQL层监控：
• 缓冲池命中率
• 事务处理量
• 锁等待情况
• 慢查询分析

应用层监控：
• 响应时间
• 错误率
• 吞吐量
• 用户体验指标
```

### 10.2 性能基线建立


**🎯 基线指标收集**
```sql
-- 创建性能基线表
CREATE TABLE performance_baseline (
    收集时间 TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    缓冲池命中率 DECIMAL(5,2),
    脏页比例 DECIMAL(5,2),
    平均响应时间 DECIMAL(10,3),
    每秒事务数 INT,
    每秒查询数 INT
);

-- 定期收集基线数据
INSERT INTO performance_baseline (缓冲池命中率, 脏页比例, 平均响应时间)
SELECT 
    缓冲池命中率,
    脏页比例百分比,
    平均查询时间
FROM buffer_pool_monitor;
```

### 10.3 故障预警机制


**🚨 智能预警系统**
```
预警规则设计：

阈值预警：
• 单一指标超过预设阈值
• 多个指标综合评估
• 趋势分析预测问题

异常检测：
• 统计学异常识别
• 机器学习模型预测
• 历史模式对比分析

自动响应：
• 自动调整参数
• 触发备用方案
• 通知运维人员
• 记录处理日志
```

**💡 监控工具集成**
```
推荐监控工具：

开源工具：
• Prometheus + Grafana
• Zabbix
• Nagios
• Cacti

商业工具：
• MySQL Enterprise Monitor
• Percona Monitoring and Management
• SolarWinds Database Performance Analyzer

自定义脚本：
• Shell脚本定期检查
• Python自动化监控
• 集成企业监控平台
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 缓冲池交互本质：事务通过缓冲池访问和修改数据页面
🔸 页面锁定机制：短期物理锁保护页面完整性
🔸 脏页管理：修改页面的及时刷新保证数据持久性
🔸 LRU算法：智能页面淘汰策略保持热点数据
🔸 MVCC版本控制：多版本并发控制避免读写冲突
🔸 性能监控：全方位监控确保系统稳定运行
```

### 11.2 关键理解要点


**🔹 页面锁定vs行锁定**
```
区别理解：
页面锁定：
• 保护物理完整性，持有时间短
• 防止页面在操作中被破坏
• 类似"操作工作台时的安全锁"

行锁定：
• 保证逻辑一致性，持有时间长
• 实现事务隔离性
• 类似"预定座位的长期占用"

两者配合：先获得页面锁定，再申请行锁定
```

**🔹 脏页刷新策略**
```
刷新时机选择：
主动刷新：
• 根据脏页比例触发
• 根据redo日志空间触发
• 性能可控，推荐方式

被动刷新：
• 检查点强制刷新
• 页面淘汰前强制刷新
• 可能影响性能，需要避免

优化原则：多主动，少被动
```

**🔹 LRU算法改进**
```
传统LRU问题：
• 全表扫描污染缓冲池
• 热点数据被意外淘汰

InnoDB改进：
• 分区LRU（New/Old区域）
• 时间延迟机制
• 访问模式识别

效果：保护热点数据，提高命中率
```

### 11.3 实际应用价值


**🎯 性能优化指导**
```
硬件优化：
• 内存：足够大的缓冲池
• 存储：SSD提高IO性能
• CPU：多核支持并发

软件调优：
• 缓冲池大小配置
• LRU参数调整
• 脏页刷新策略
• 并发控制参数

应用优化：
• 事务设计原则
• 查询优化策略
• 索引使用最佳实践
```

**📊 监控运维指导**
```
关键监控指标：
• 缓冲池命中率 > 95%
• 脏页比例 < 75%
• 页面锁等待时间 < 1ms
• LRU扫描深度适中

故障排查思路：
1. 检查缓冲池状态
2. 分析页面锁等待
3. 查看脏页刷新情况
4. 评估LRU效果
5. 诊断IO性能

容量规划：
• 根据数据增长规划缓冲池
• 评估并发事务数量
• 预估IO性能需求
• 制定扩容策略
```

**🔧 故障处理指导**
```
常见问题及解决：

缓冲池命中率低：
原因：缓冲池太小或查询模式问题
解决：增大缓冲池，优化查询

脏页比例过高：
原因：刷新速度跟不上修改速度
解决：调整IO容量，优化刷新策略

页面锁争用严重：
原因：热点页面访问冲突
解决：优化数据分布，减少热点

内存使用异常：
原因：缓冲池配置不当
解决：调整缓冲池大小和实例数
```

**核心记忆口诀**：
- 缓冲池是内存工作台，事务操作数据靠它
- 页面锁定保完整，脏页刷新保持久  
- LRU算法很智能，热点数据不轻易换
- 监控指标要盯紧，性能问题早发现