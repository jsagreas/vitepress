---
title: 1、并发控制技术
---
## 📚 目录

1. [并发控制技术背景](#1-并发控制技术背景)
2. [乐观锁基本概念](#2-乐观锁基本概念)
3. [版本号机制实现](#3-版本号机制实现)
4. [CAS操作实现](#4-CAS操作实现)
5. [时间戳方式实现](#5-时间戳方式实现)
6. [校验和方法](#6-校验和方法)
7. [冲突检测与重试策略](#7-冲突检测与重试策略)
8. [性能优势与适用场景](#8-性能优势与适用场景)
9. [乐观锁优化实践](#9-乐观锁优化实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🚀 并发控制技术背景


### 1.1 并发控制历史发展


传统数据库主要使用悲观锁控制并发，但随着互联网应用的发展，需要更高效的并发控制方案。

```
并发控制技术演进：
┌─────────────────────────────────────────┐
│ 1970s: 悲观锁 → 预先加锁，安全但低效    │
│ 1980s: 两阶段锁 → 规范化锁协议          │
│ 1990s: 多版本 → MVCC技术出现            │
│ 2000s: 乐观锁 → 无锁并发，性能优异      │
│ 2010s: 分布式锁 → 跨节点并发控制        │
└─────────────────────────────────────────┘
```

### 1.2 理论基础演进


并发控制的核心是保证事务的串行化，确保并发执行的结果与串行执行一致。

```
串行化理论基础：
┌─────────────────┐  ┌─────────────────┐
│   冲突可串行化   │  │   视图可串行化   │
│                │  │                │
│ 基于操作冲突    │  │ 基于读写结果    │
│ 实现相对简单    │  │ 理论更完备      │
│ 性能开销较大    │  │ 实现复杂度高    │
└─────────────────┘  └─────────────────┘
```

### 1.3 性能需求推动


现代应用对数据库并发性能提出更高要求，传统悲观锁难以满足需求。

| 应用场景 | **并发需求** | **传统方案** | **性能瓶颈** |
|---------|-------------|-------------|-------------|
| 🛒 **电商系统** | `万级QPS` | `行锁+等待` | `锁竞争严重` |
| 📱 **社交应用** | `实时更新` | `表锁阻塞` | `用户体验差` |
| 💰 **金融交易** | `毫秒响应` | `串行处理` | `延迟过高` |
| 🎮 **游戏服务** | `状态同步` | `悲观锁定` | `并发度低` |

---

## 2. 🔓 乐观锁基本概念


### 2.1 乐观锁定义


乐观锁假设并发冲突很少发生，只在数据提交时检查是否存在冲突。

```
乐观锁 vs 悲观锁：
┌─────────────────┐    ┌─────────────────┐
│    悲观锁        │    │    乐观锁        │
│                │    │                │
│ 先加锁后操作    │    │ 先操作后检查    │
│ 假设必有冲突    │    │ 假设无冲突      │
│ 串行化执行      │    │ 并发执行        │
│ 性能较低        │    │ 性能较高        │
└─────────────────┘    └─────────────────┘
```

### 2.2 基本工作原理


乐观锁通过版本控制机制检测数据是否被其他事务修改过。

```sql
-- 乐观锁基本流程示例
-- 步骤1：读取数据及版本号
SELECT id, name, price, version FROM products WHERE id = 1;
-- 结果：id=1, name='手机', price=1000, version=5

-- 步骤2：修改数据（业务逻辑处理）
-- 在应用层进行价格调整等操作

-- 步骤3：更新时检查版本号
UPDATE products 
SET name='新手机', price=1200, version=version+1 
WHERE id=1 AND version=5;

-- 如果version已被其他事务修改，更新失败
```

### 2.3 核心设计思想


乐观锁的核心是"乐观假设 + 冲突检测 + 失败重试"的模式。

```
乐观锁设计思想：
┌─────────────────────────────────────────┐
│ 🎯 乐观假设：认为冲突概率很低           │
│ 🔍 延迟检测：操作结束时才检查冲突       │
│ ⚡ 无锁执行：读写操作无需等待锁         │
│ 🔄 冲突重试：检测到冲突时重新执行       │
└─────────────────────────────────────────┘
```

---

## 3. 🔢 版本号机制实现


### 3.1 版本号字段设计


为每个需要乐观锁控制的表增加版本号字段。

```sql
-- 添加版本号字段
ALTER TABLE users ADD COLUMN version INT DEFAULT 1;
ALTER TABLE products ADD COLUMN version BIGINT DEFAULT 1;
ALTER TABLE orders ADD COLUMN version INT DEFAULT 1;

-- 创建包含版本号的新表
CREATE TABLE inventory (
    id INT PRIMARY KEY,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    version INT NOT NULL DEFAULT 1,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 3.2 版本号更新机制


每次数据修改时，版本号自动递增。

```java
// Java实现版本号乐观锁
public class VersionOptimisticLock {
    
    public boolean updateProduct(int productId, String newName, int currentVersion) {
        String sql = "UPDATE products SET name=?, version=version+1 " +
                    "WHERE id=? AND version=?";
        
        int rowsAffected = jdbcTemplate.update(sql, newName, productId, currentVersion);
        
        return rowsAffected > 0; // 返回是否更新成功
    }
    
    public Product getProductWithVersion(int productId) {
        String sql = "SELECT id, name, price, version FROM products WHERE id=?";
        return jdbcTemplate.queryForObject(sql, Product.class, productId);
    }
}
```

### 3.3 版本号冲突处理


当版本号不匹配时，说明数据已被其他事务修改。

```java
// 版本号冲突处理策略
public class ConflictHandler {
    
    public void handleVersionConflict(int productId) throws OptimisticLockException {
        int maxRetries = 3;
        int attempt = 0;
        
        while (attempt < maxRetries) {
            try {
                // 重新读取最新数据
                Product product = getProductWithVersion(productId);
                
                // 重新执行业务逻辑
                String newName = processBusinessLogic(product);
                
                // 尝试更新
                if (updateProduct(productId, newName, product.getVersion())) {
                    return; // 更新成功
                }
                
                attempt++;
                Thread.sleep(10 * attempt); // 指数退避
                
            } catch (Exception e) {
                throw new OptimisticLockException("版本冲突处理失败", e);
            }
        }
        
        throw new OptimisticLockException("超过最大重试次数");
    }
}
```

---

## 4. ⚛️ CAS操作实现


### 4.1 CAS基本概念


CAS（Compare And Swap）是一种原子操作，比较当前值与期望值，相等时才更新。

```
CAS操作原理：
┌─────────────────────────────────────────┐
│ 输入参数：                              │
│ • 内存位置 V                           │
│ • 期望值 A                             │
│ • 新值 B                               │
├─────────────────────────────────────────┤
│ 操作逻辑：                              │
│ if (V == A) {                          │
│     V = B;                             │
│     return true;                       │
│ } else {                               │
│     return false;                      │
│ }                                      │
└─────────────────────────────────────────┘
```

### 4.2 MySQL中的CAS实现


利用WHERE条件实现原子性比较和更新。

```sql
-- CAS方式更新库存
UPDATE inventory 
SET quantity = quantity - 1 
WHERE product_id = 1 AND quantity >= 1;

-- 检查影响行数判断是否成功
-- 影响行数为1：CAS成功
-- 影响行数为0：CAS失败（库存不足或被其他事务修改）

-- CAS方式更新账户余额
UPDATE accounts 
SET balance = balance - 100 
WHERE user_id = 123 AND balance >= 100;
```

### 4.3 CAS重试机制


CAS失败时需要重新读取数据并重试。

```java
public class CASOptimisticLock {
    
    public boolean decreaseInventory(int productId, int decreaseAmount) {
        int maxRetries = 5;
        
        for (int i = 0; i < maxRetries; i++) {
            // 读取当前库存
            int currentQuantity = getCurrentQuantity(productId);
            
            if (currentQuantity < decreaseAmount) {
                return false; // 库存不足
            }
            
            // CAS更新
            String sql = "UPDATE inventory SET quantity = ? " +
                        "WHERE product_id = ? AND quantity = ?";
            
            int newQuantity = currentQuantity - decreaseAmount;
            int rowsAffected = jdbcTemplate.update(sql, 
                newQuantity, productId, currentQuantity);
            
            if (rowsAffected > 0) {
                return true; // 更新成功
            }
            
            // CAS失败，短暂等待后重试
            try {
                Thread.sleep(1 << i); // 指数退避：1,2,4,8,16ms
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        return false; // 超过重试次数
    }
}
```

---

## 5. ⏰ 时间戳方式实现


### 5.1 时间戳机制原理


使用最后修改时间戳检测数据是否被其他事务修改过。

```sql
-- 为表添加时间戳字段
ALTER TABLE users ADD COLUMN last_modified TIMESTAMP 
DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;

-- 读取数据时包含时间戳
SELECT id, name, email, last_modified FROM users WHERE id = 1;
-- 结果：id=1, name='张三', email='zhang@qq.com', last_modified='2024-01-20 10:30:45'
```

### 5.2 时间戳冲突检测


更新时检查时间戳是否发生变化。

```java
public class TimestampOptimisticLock {
    
    public boolean updateUser(int userId, String newEmail, Timestamp lastModified) {
        String sql = "UPDATE users SET email = ?, last_modified = CURRENT_TIMESTAMP " +
                    "WHERE id = ? AND last_modified = ?";
        
        int rowsAffected = jdbcTemplate.update(sql, newEmail, userId, lastModified);
        
        return rowsAffected > 0;
    }
    
    public User getUserWithTimestamp(int userId) {
        String sql = "SELECT id, name, email, last_modified FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, User.class, userId);
    }
}
```

### 5.3 时间戳精度考虑


时间戳精度影响冲突检测的准确性。

```
时间戳精度对比：
┌─────────────────┬─────────────┬─────────────┐
│ 精度级别        │ MySQL类型   │ 适用场景    │
├─────────────────┼─────────────┼─────────────┤
│ 秒级            │ TIMESTAMP   │ 低频操作    │
│ 毫秒级          │ TIMESTAMP(3)│ 中频操作    │
│ 微秒级          │ TIMESTAMP(6)│ 高频操作    │
└─────────────────┴─────────────┴─────────────┘

高并发场景建议使用微秒级精度：
CREATE TABLE high_frequency_table (
    id INT PRIMARY KEY,
    data VARCHAR(255),
    last_modified TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) 
                  ON UPDATE CURRENT_TIMESTAMP(6)
);
```

---

## 6. 🔐 校验和方法


### 6.1 校验和机制设计


通过计算数据校验和检测是否被修改过。

```java
public class ChecksumOptimisticLock {
    
    // 计算记录校验和
    public String calculateChecksum(User user) {
        String data = user.getId() + user.getName() + 
                     user.getEmail() + user.getAge();
        return DigestUtils.md5Hex(data);
    }
    
    // 带校验和的更新操作
    public boolean updateWithChecksum(User user, String originalChecksum) {
        // 重新读取数据计算校验和
        User currentUser = getUserById(user.getId());
        String currentChecksum = calculateChecksum(currentUser);
        
        // 校验和不匹配说明数据已被修改
        if (!originalChecksum.equals(currentChecksum)) {
            return false;
        }
        
        // 执行更新操作
        String sql = "UPDATE users SET name=?, email=?, age=? WHERE id=?";
        int rowsAffected = jdbcTemplate.update(sql, 
            user.getName(), user.getEmail(), user.getAge(), user.getId());
        
        return rowsAffected > 0;
    }
}
```

### 6.2 部分字段校验和


针对重要字段计算校验和，提高性能。

```java
public class PartialChecksumLock {
    
    // 只对关键字段计算校验和
    public String calculateCriticalChecksum(Product product) {
        // 只校验价格和库存等关键字段
        String criticalData = product.getPrice() + "|" + product.getQuantity();
        return DigestUtils.md5Hex(criticalData);
    }
    
    public boolean updatePrice(int productId, BigDecimal newPrice, String checksum) {
        Product current = getProductById(productId);
        String currentChecksum = calculateCriticalChecksum(current);
        
        if (!checksum.equals(currentChecksum)) {
            throw new OptimisticLockException("商品关键信息已被修改");
        }
        
        String sql = "UPDATE products SET price = ? WHERE id = ?";
        return jdbcTemplate.update(sql, newPrice, productId) > 0;
    }
}
```

---

## 7. 🔍 冲突检测与重试策略


### 7.1 冲突检测策略


根据不同场景选择合适的冲突检测方法。

```
冲突检测方法对比：
┌─────────────────┬─────────────┬─────────────┬─────────────┐
│ 检测方法        │ 实现难度    │ 性能开销    │ 准确性      │
├─────────────────┼─────────────┼─────────────┼─────────────┤
│ 版本号          │ ⭐⭐         │ ⭐⭐⭐⭐⭐    │ ⭐⭐⭐⭐⭐    │
│ 时间戳          │ ⭐⭐⭐       │ ⭐⭐⭐⭐     │ ⭐⭐⭐⭐     │
│ CAS比较         │ ⭐⭐⭐⭐     │ ⭐⭐⭐       │ ⭐⭐⭐⭐⭐    │
│ 校验和          │ ⭐⭐⭐⭐⭐   │ ⭐⭐         │ ⭐⭐⭐⭐⭐    │
└─────────────────┴─────────────┴─────────────┴─────────────┘
```

### 7.2 重试机制设计


设计合理的重试策略避免无限重试和系统过载。

```java
public class RetryStrategy {
    
    public <T> T executeWithRetry(Supplier<T> operation, int maxRetries) {
        Exception lastException = null;
        
        for (int attempt = 0; attempt < maxRetries; attempt++) {
            try {
                return operation.get();
            } catch (OptimisticLockException e) {
                lastException = e;
                
                if (attempt < maxRetries - 1) {
                    // 指数退避策略
                    long waitTime = (long) Math.pow(2, attempt) * 10; // 10,20,40,80ms
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("重试被中断", ie);
                    }
                }
            }
        }
        
        throw new RuntimeException("超过最大重试次数: " + maxRetries, lastException);
    }
}
```

### 7.3 智能重试策略


根据冲突频率动态调整重试策略。

```java
public class AdaptiveRetryStrategy {
    private volatile double conflictRate = 0.0;
    private final AtomicLong totalAttempts = new AtomicLong(0);
    private final AtomicLong conflicts = new AtomicLong(0);
    
    public boolean executeWithAdaptiveRetry(Runnable operation) {
        totalAttempts.incrementAndGet();
        
        // 根据冲突率调整最大重试次数
        int maxRetries = calculateMaxRetries();
        
        for (int attempt = 0; attempt < maxRetries; attempt++) {
            try {
                operation.run();
                return true;
            } catch (OptimisticLockException e) {
                conflicts.incrementAndGet();
                updateConflictRate();
                
                if (attempt < maxRetries - 1) {
                    try {
                        Thread.sleep(calculateWaitTime(attempt));
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        return false;
                    }
                }
            }
        }
        return false;
    }
    
    private int calculateMaxRetries() {
        if (conflictRate < 0.1) return 3;      // 低冲突
        else if (conflictRate < 0.3) return 5; // 中等冲突
        else return 7;                          // 高冲突
    }
    
    private void updateConflictRate() {
        conflictRate = (double) conflicts.get() / totalAttempts.get();
    }
}
```

---

## 8. 📈 性能优势与适用场景


### 8.1 性能优势分析


乐观锁在读多写少的场景下具有显著的性能优势。

```
性能优势量化分析：
┌─────────────────────────────────────────┐
│ 测试场景：1000并发用户，90%读10%写      │
├─────────────────────────────────────────┤
│ 悲观锁表现：                            │
│ • 读操作QPS: 5,000                     │
│ • 写操作QPS: 500                       │
│ • 平均响应时间: 200ms                   │
├─────────────────────────────────────────┤
│ 乐观锁表现：                            │
│ • 读操作QPS: 25,000                    │
│ • 写操作QPS: 2,000                     │
│ • 平均响应时间: 40ms                    │
└─────────────────────────────────────────┘

性能提升：
• 读操作性能提升：400%
• 写操作性能提升：300%
• 响应时间减少：80%
```

### 8.2 适用场景选择


不同场景下乐观锁和悲观锁的选择策略。

```
场景适用性分析：
┌─────────────────────────────────────────┐
│ ✅ 乐观锁适用场景：                      │
├─────────────────────────────────────────┤
│ 📊 数据分析系统 - 读多写少              │
│ 🛒 商品浏览页面 - 查询为主              │
│ 📝 内容管理系统 - 更新频率低            │
│ 📈 报表生成系统 - 大量读取操作          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ ❌ 乐观锁不适用场景：                    │
├─────────────────────────────────────────┤
│ 💰 账户余额更新 - 冲突率极高            │
│ 🎫 秒杀抢购系统 - 高并发写入            │
│ 📊 实时计数器 - 频繁更新                │
│ 🔄 状态机流转 - 严格顺序要求            │
└─────────────────────────────────────────┘
```

### 8.3 混合策略应用


在同一系统中根据不同业务模块选择不同的锁策略。

```java
public class HybridLockStrategy {
    
    // 商品信息更新 - 使用乐观锁
    public void updateProductInfo(Product product) {
        // 商品基本信息更新频率低，适合乐观锁
        optimisticLockService.updateProduct(product);
    }
    
    // 库存扣减 - 使用悲观锁
    public void decreaseInventory(int productId, int amount) {
        // 库存扣减冲突率高，使用悲观锁保证准确性
        pessimisticLockService.decreaseStock(productId, amount);
    }
    
    // 用户资料更新 - 使用乐观锁
    public void updateUserProfile(User user) {
        // 用户资料更新频率低，适合乐观锁
        optimisticLockService.updateUser(user);
    }
    
    // 订单状态更新 - 使用悲观锁
    public void updateOrderStatus(int orderId, String newStatus) {
        // 订单状态变更需要严格控制，使用悲观锁
        pessimisticLockService.updateOrder(orderId, newStatus);
    }
}
```

---

## 9. 🚀 乐观锁优化实践


### 9.1 减少冲突优化


通过合理的系统设计减少乐观锁冲突。

```java
public class ConflictReductionOptimization {
    
    // 1. 数据分片减少冲突
    public void updateUserScoreByPartition(int userId, int scoreIncrement) {
        // 根据用户ID分片，减少热点数据冲突
        int partition = userId % 10;
        String sql = "UPDATE user_scores_" + partition + 
                    " SET score = score + ?, version = version + 1 " +
                    "WHERE user_id = ? AND version = ?";
    }
    
    // 2. 批量操作优化
    public void batchUpdateWithOptimisticLock(List<Product> products) {
        // 将小批量更新合并，减少冲突概率
        products.stream()
               .collect(Collectors.groupingBy(Product::getCategoryId))
               .forEach(this::updateProductsByCategory);
    }
    
    // 3. 异步处理优化
    public void asyncUpdateWithOptimisticLock(UpdateRequest request) {
        // 将非关键更新异步化，避免阻塞主业务流程
        CompletableFuture.runAsync(() -> {
            try {
                executeWithRetry(() -> updateData(request));
            } catch (Exception e) {
                log.error("异步更新失败", e);
                // 可以选择重新入队或记录失败日志
            }
        });
    }
}
```

### 9.2 性能监控优化


建立乐观锁性能监控体系。

```java
public class OptimisticLockMonitor {
    private final MeterRegistry meterRegistry;
    private final Counter conflictCounter;
    private final Timer retryTimer;
    
    public OptimisticLockMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.conflictCounter = Counter.builder("optimistic_lock_conflicts")
                                    .register(meterRegistry);
        this.retryTimer = Timer.builder("optimistic_lock_retry_time")
                               .register(meterRegistry);
    }
    
    public <T> T executeWithMonitoring(Supplier<T> operation) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            return operation.get();
        } catch (OptimisticLockException e) {
            conflictCounter.increment();
            throw e;
        } finally {
            sample.stop(retryTimer);
        }
    }
    
    // 监控指标分析
    public void analyzeMetrics() {
        double conflictRate = conflictCounter.count() / retryTimer.count();
        if (conflictRate > 0.1) {
            log.warn("乐观锁冲突率过高: {}", conflictRate);
            // 可以触发告警或自动调整策略
        }
    }
}
```

### 9.3 缓存配合优化


结合缓存减少数据库访问，提高乐观锁性能。

```java
public class CacheOptimizedOptimisticLock {
    
    @Cacheable(value = "products", key = "#productId")
    public Product getProductWithVersion(int productId) {
        return productRepository.findByIdWithVersion(productId);
    }
    
    @CacheEvict(value = "products", key = "#product.id")
    public boolean updateProductWithOptimisticLock(Product product) {
        String sql = "UPDATE products SET name=?, price=?, version=version+1 " +
                    "WHERE id=? AND version=?";
        
        int rowsAffected = jdbcTemplate.update(sql, 
            product.getName(), product.getPrice(), 
            product.getId(), product.getVersion());
            
        if (rowsAffected > 0) {
            // 更新成功，清除缓存
            return true;
        }
        
        return false;
    }
    
    // 缓存预热策略
    @Scheduled(fixedRate = 300000) // 5分钟
    public void warmupCache() {
        List<Integer> hotProductIds = getHotProductIds();
        hotProductIds.forEach(this::getProductWithVersion);
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 乐观锁本质：假设冲突少，延迟检测，失败重试
🔸 版本号机制：最常用的实现方式，简单高效
🔸 CAS操作：原子性比较交换，无需额外字段
🔸 时间戳方式：利用修改时间检测冲突
🔸 校验和方法：通过数据摘要检测变化
🔸 冲突检测：在数据提交时检查是否被修改
🔸 重试策略：指数退避、自适应调整
🔸 适用场景：读多写少、冲突率低的场景
```

### 10.2 关键理解要点


**🔹 乐观锁 vs 悲观锁的本质差异**
```
思维模式：乐观假设 vs 悲观假设
执行时机：后检测 vs 先加锁  
性能特点：高并发 vs 高安全
适用场景：读密集 vs 写密集
```

**🔹 实现方式的选择策略**
```
版本号：通用性最好，推荐首选
CAS：无需额外字段，适合简单场景
时间戳：实现简单，精度是关键
校验和：检测能力强，计算开销大
```

**🔹 性能优化的关键点**
```
减少冲突：数据分片、批量操作、异步处理
合理重试：指数退避、最大次数限制
监控调优：冲突率监控、性能分析
缓存配合：减少数据库访问、提高响应速度
```

### 10.3 实际应用指导


- **系统设计** - 根据读写比例选择合适的并发控制策略
- **性能优化** - 通过监控冲突率持续优化乐观锁配置
- **问题排查** - 建立完善的监控体系及时发现性能瓶颈
- **架构演进** - 从单机乐观锁到分布式乐观锁的演进路径

### 10.4 学习进度检查


- [ ] **基本概念** - 理解乐观锁的工作原理和设计思想
- [ ] **实现方式** - 掌握版本号、CAS、时间戳等实现方法
- [ ] **冲突处理** - 熟练掌握冲突检测和重试策略
- [ ] **性能优化** - 能够分析和优化乐观锁性能
- [ ] **场景应用** - 知道什么时候使用乐观锁
- [ ] **监控调优** - 建立监控体系并进行性能调优

**🧠 记忆口诀：**
```
乐观假设冲突少，无锁并发性能高
版本时戳CAS和，四种实现各有招
冲突检测在提交，失败重试有技巧
读多写少最适合，监控优化不可少
```

**🎯 核心理解：**
乐观锁是一种"乐观假设+延迟检测+失败重试"的并发控制技术，在读多写少的场景下能够显著提升系统性能。掌握不同实现方式的特点，设计合理的冲突检测和重试策略，结合性能监控和优化手段，能够在实际项目中有效应用乐观锁技术。