---
title: 16、并发控制理论基础
---
## 📚 目录


1. [并发控制理论基础](#1-并发控制理论基础)
2. [可串行化理论](#2-可串行化理论)
3. [冲突可串行化](#3-冲突可串行化)
4. [视图可串行化](#4-视图可串行化)
5. [串行化图算法](#5-串行化图算法)
6. [并发控制正确性证明](#6-并发控制正确性证明)
7. [可串行化检测算法](#7-可串行化检测算法)
8. [理论与实践结合](#8-理论与实践结合)
9. [核心要点总结](#9-核心要点总结)

---

# 1. 🔬 并发控制理论基础



## 1.1 什么是并发控制



并发控制是**保证多个事务同时执行时数据库一致性的技术**。想象一下银行系统，如果两个人同时对同一个账户进行转账操作，没有合适的控制机制就可能出现数据不一致的问题。

**核心概念理解**：
```
单用户环境：一次只有一个操作
用户A: 查余额(1000) → 取款(500) → 余额变成500 ✓

多用户环境：多个操作同时进行
用户A: 查余额(1000) → 取款(500) → 余额应该是500
用户B: 查余额(1000) → 存款(200) → 余额应该是1200
如果不加控制，最终余额可能是700、500、1200中的任意一个！
```

## 1.2 并发问题的本质



**为什么会出现并发问题？**

数据库操作不是原子的，一个简单的转账包含多个步骤：
```
转账操作的内部步骤：
1. 读取账户A余额
2. 检查余额是否充足  
3. 减少账户A余额
4. 读取账户B余额
5. 增加账户B余额
6. 提交更改
```

当多个这样的操作交叉执行时，就可能产生**数据不一致**。

## 1.3 并发异常现象



**🔸 脏读（Dirty Read）**
```
事务T1: 修改数据X = 100 → 200
事务T2: 读取数据X = 200  ← 读到了未提交的数据
事务T1: 回滚，X 恢复为 100
结果：T2读到了"脏"数据200，但实际值是100
```

**🔸 不可重复读（Non-repeatable Read）**
```
事务T1: 读取X = 100
事务T2: 修改X = 200 并提交
事务T1: 再次读取X = 200  ← 同一事务中两次读取结果不同
结果：T1在同一事务内读到了不同的值
```

**🔸 幻读（Phantom Read）**
```
事务T1: SELECT COUNT(*) = 10 条记录
事务T2: INSERT 新记录并提交
事务T1: SELECT COUNT(*) = 11 条记录  ← 出现了"幻影"记录
结果：T1发现了之前不存在的记录
```

---

# 2. 📐 可串行化理论



## 2.1 什么是可串行化



**可串行化**是判断并发执行正确性的**黄金标准**。简单说，就是并发执行的结果要和某种串行执行的结果完全一样。

**通俗理解**：
```
串行执行：事务一个接一个执行，不会有冲突
T1: A→B转账500
T2: C→D转账300
串行执行1：先执行T1再执行T2
串行执行2：先执行T2再执行T1

可串行化：并发执行的结果等价于某种串行执行
如果T1和T2并发执行的结果 = 串行执行1的结果，则是可串行化的
```

## 2.2 可串行化的数学定义



**调度（Schedule）**：多个事务操作的一个执行序列

```
事务示例：
T1: R(X) W(X) Commit
T2: R(Y) W(Y) Commit

可能的调度：
S1: R1(X) W1(X) R2(Y) W2(Y) C1 C2  ← 串行调度
S2: R1(X) R2(Y) W1(X) W2(Y) C1 C2  ← 并发调度
S3: R2(Y) R1(X) W2(Y) W1(X) C2 C1  ← 另一种并发调度
```

## 2.3 可串行化的判断条件



一个调度是可串行化的，当且仅当它与某个串行调度**等价**。

**等价的含义**：
- 包含相同的事务和操作
- 对于任何数据库状态，执行结果相同
- 每个事务内部操作顺序保持不变

---

# 3. ⚔️ 冲突可串行化



## 3.1 什么是冲突操作



**冲突操作**是指两个来自不同事务的操作，如果交换它们的顺序会改变执行结果。

**冲突的三个条件**：
1. 来自不同事务
2. 访问同一数据项
3. 至少有一个是写操作

```
冲突类型：
✅ R1(X) - W2(X)  读-写冲突
✅ W1(X) - R2(X)  写-读冲突  
✅ W1(X) - W2(X)  写-写冲突
❌ R1(X) - R2(X)  读-读不冲突
❌ R1(X) - W2(Y)  不同数据项不冲突
```

## 3.2 冲突等价



两个调度冲突等价，当且仅当：
- 包含相同的操作
- 每对冲突操作在两个调度中的顺序相同

**示例分析**：
```
调度S1: R1(X) W1(X) R2(X) W2(X)
调度S2: R1(X) R2(X) W1(X) W2(X)

冲突操作分析：
- W1(X) 与 R2(X)：S1中W1在前，S2中R2在前 → 顺序不同
- W1(X) 与 W2(X)：两个调度中都是W1在前 → 顺序相同
- R1(X) 与 W2(X)：两个调度中都是R1在前 → 顺序相同

结论：S1和S2不是冲突等价的
```

## 3.3 冲突可串行化检测



**方法：通过交换非冲突操作将调度转换为串行调度**

```
调度S: R1(A) R2(B) W1(A) R1(B) W2(B)

步骤1: 找出非冲突操作对
R2(B) 和 W1(A) 不冲突（不同数据项）

步骤2: 交换非冲突操作
原调度: R1(A) R2(B) W1(A) R1(B) W2(B)
交换后: R1(A) W1(A) R2(B) R1(B) W2(B)

步骤3: 继续交换
最终得到: R1(A) W1(A) R1(B) R2(B) W2(B)
这是串行调度（T1完全在T2之前）

结论：原调度是冲突可串行化的
```

---

# 4. 👁️ 视图可串行化



## 4.1 视图等价的概念



**视图等价**比冲突等价更宽松，关注的是每个**读操作能看到什么值**。

两个调度视图等价需要满足：
1. **初始读条件**：如果Ti在S1中首次读取X时没有先前写入，那么在S2中也应如此
2. **读写依赖**：如果Ti在S1中读取由Tj写入的X值，那么在S2中也应如此  
3. **最终写条件**：对每个数据项X，在S1中最后写入X的事务在S2中也应最后写入X

## 4.2 视图可串行化示例



```
调度S: R1(A) W2(A) W1(A) R3(A)

分析读写关系：
- R1(A)：读取初始值（没有事务先写A）
- R3(A)：读取W1(A)写入的值
- 最终A的值：由W1(A)确定

构造等价串行调度：
需要保证：
1. T1仍然读取初始值
2. T3仍然读取T1写入的值
3. T1仍然是最后写入A的事务

可能的串行调度：T1 T2 T3
验证：R1(A) W1(A) W2(A) W1(A) R3(A)  ← 这不对！

正确分析：由于W2(A)在W1(A)之前，但最终T1写入，
这个调度实际上不是视图可串行化的。
```

## 4.3 视图可串行化的重要性



**为什么需要视图可串行化？**

有些调度不是冲突可串行化，但仍然是正确的：
```
调度S: R1(A) W2(A) W3(A) W1(A)

冲突分析：
- W2(A)和W3(A)冲突，不能随意交换
- 无法通过交换得到串行调度

视图分析：
- W2(A)和W3(A)都被W1(A)覆盖，最终结果只看W1(A)
- 从结果角度看，W2和W3的顺序不影响最终状态
```

---

# 5. 📊 串行化图算法



## 5.1 优先图构造



**串行化图（也叫优先图）**是检测冲突可串行化的有效方法。

**构造规则**：
```
1. 为每个事务Ti创建一个节点
2. 对每对冲突操作Pi(X)和Qj(X)（Pi在前）：
   - 如果i ≠ j，添加边Ti → Tj
3. 如果图中无环，则调度是冲突可串行化的
```

**示例分析**：
```
调度S: R1(A) W2(A) R1(B) W1(A) W2(B) R3(B)

找出冲突操作：
- R1(A), W2(A): T1 → T2  (读-写冲突)
- W2(A), W1(A): T2 → T1  (写-写冲突)  
- W1(B), W2(B): T1 → T2  (写-写冲突)
- W2(B), R3(B): T2 → T3  (写-读冲突)

构造图：
T1 → T2 → T3
T2 → T1

发现环：T1 → T2 → T1
结论：不是冲突可串行化的
```

## 5.2 拓扑排序



如果串行化图无环，可以通过**拓扑排序**得到等价的串行调度：

```
无环图示例：
T1 → T2 → T3
T1 → T3

拓扑排序步骤：
1. 找入度为0的节点：T1
2. 移除T1及其出边：T2 → T3
3. 找入度为0的节点：T2  
4. 移除T2及其出边：T3
5. 最后剩下T3

串行顺序：T1, T2, T3
```

## 5.3 算法复杂度



```
时间复杂度：O(n²)
- n是事务数量
- 需要检查所有操作对的冲突关系

空间复杂度：O(n²)  
- 图的边数最多为n(n-1)/2

优化方法：
- 只考虑访问相同数据项的操作
- 使用哈希表加速冲突检测
```

---

# 6. ✅ 并发控制正确性证明



## 6.1 正确性定义



**并发控制协议的正确性**：该协议产生的所有调度都是可串行化的。

**证明方法**：
1. **构造性证明**：显式构造等价的串行调度
2. **图论证明**：证明串行化图无环
3. **不变式证明**：证明系统保持某些不变性质

## 6.2 两阶段锁协议的正确性



**两阶段锁（2PL）**是最经典的并发控制协议。

**协议规则**：
```
阶段1（增长阶段）：只能加锁，不能释放锁
阶段2（收缩阶段）：只能释放锁，不能加锁

示例：
T1: Lock(A) Lock(B) ... Unlock(A) Unlock(B)
     ←增长阶段→     ←收缩阶段→
```

**正确性证明思路**：
```
定理：所有遵循2PL的调度都是冲突可串行化的

证明：
1. 假设有冲突操作Pi(X) < Qj(X)（Pi在Qj前执行）
2. 由于冲突，Ti必须先获得X的锁
3. 由于2PL，Ti在释放X锁后不能再获得任何锁
4. Tj获得X锁时，Ti必须已经释放了X锁
5. 因此Ti的收缩阶段开始时间 < Tj的增长阶段结束时间
6. 这给出了事务的全序关系，对应串行调度
```

## 6.3 时间戳协议的正确性



**基本时间戳协议**：每个事务分配唯一时间戳，较早事务有更高优先级。

**正确性证明**：
```
规则：
- 如果TS(Ti) < TS(Tj)，则Ti的所有操作都在Tj之前

证明要点：
1. 时间戳确定了事务的全序
2. 协议保证这个全序在所有数据项上一致
3. 因此等价于按时间戳顺序的串行执行
```

---

# 7. 🔍 可串行化检测算法



## 7.1 运行时检测



**实时检测算法**在事务执行过程中维护串行化图，一旦发现环就中止事务。

```java
class SerializabilityTester {
    private Graph precedenceGraph;
    private Map<Transaction, Set<DataItem>> accessedItems;
    
    // 检测新操作是否破坏可串行化
    public boolean checkOperation(Transaction t, DataItem item, OpType type) {
        // 找出与当前操作冲突的事务
        Set<Transaction> conflictingTransactions = 
            findConflicts(t, item, type);
        
        // 添加边到优先图
        for (Transaction conflicting : conflictingTransactions) {
            precedenceGraph.addEdge(conflicting, t);
        }
        
        // 检测是否形成环
        return !precedenceGraph.hasCycle();
    }
}
```

## 7.2 批处理检测



**离线检测**：在事务执行完毕后检测整个调度的可串行化性。

```
算法步骤：
1. 记录所有操作的执行顺序
2. 构造完整的串行化图
3. 检测图中是否有环
4. 如果有环，回滚相关事务

优势：
- 允许更多并发（不会因为可能的冲突而阻塞）
- 检测更准确

缺陷：
- 可能需要回滚已提交的事务
- 级联回滚的代价高
```

## 7.3 多版本检测



**MVCC环境下的可串行化检测**更复杂，因为读操作可能读取历史版本。

```
算法要点：
1. 为每个数据项维护版本链
2. 跟踪每个读操作读取的具体版本
3. 构造考虑版本依赖的串行化图
4. 检测快照隔离中的写偏序异常

示例：
T1: R(X)@v1 W(Y)
T2: R(Y)@v1 W(X)  
两个事务都读取初始版本，写入不同数据项
传统检测：无冲突
MVCC检测：发现写偏序，不可串行化
```

---

# 8. 🔗 理论与实践结合



## 8.1 MySQL中的实现



**InnoDB的并发控制策略**：

```sql
-- 查看当前隔离级别
SELECT $$transaction_isolation;

-- 设置串行化隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 分析冲突检测
SHOW ENGINE INNODB STATUS;
```

**实际应用场景**：
```sql
-- 场景：银行转账
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- 加锁读
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- InnoDB会确保这个操作序列的可串行化
```

## 8.2 性能考虑



**理论 vs 实践的权衡**：

```
完全可串行化的代价：
✅ 保证正确性
❌ 并发度低
❌ 死锁可能性高
❌ 响应时间长

实际数据库的折中方案：
🔸 使用较弱的隔离级别（如快照隔离）
🔸 应用层面的补偿机制
🔸 业务逻辑设计避免冲突
```

## 8.3 现代发展



**现代数据库的创新**：

```
乐观并发控制：
- 假设冲突不常发生
- 提交时才检测冲突
- 适合读多写少的场景

确定性调度：
- 预先确定事务执行顺序
- 避免运行时冲突检测
- 分布式环境下的新思路

混合方法：
- 结合锁和时间戳
- 自适应选择协议
- 基于工作负载特征调优
```

---

# 9. 📋 核心要点总结



## 9.1 必须掌握的核心概念



```
🔸 可串行化：并发执行等价于某种串行执行
🔸 冲突可串行化：通过交换非冲突操作可得到串行调度
🔸 视图可串行化：保持读写依赖关系的等价性
🔸 串行化图：检测冲突可串行化的图论方法
🔸 正确性证明：验证并发控制协议的理论基础
```

## 9.2 关键理解要点



**🔹 为什么需要理论基础**
```
实践指导：
- 理解为什么某些操作会冲突
- 设计避免异常的业务逻辑
- 选择合适的隔离级别

性能优化：
- 减少不必要的锁竞争
- 优化事务结构
- 平衡正确性和性能
```

**🔹 不同可串行化概念的关系**
```
包含关系：
串行调度 ⊆ 冲突可串行化 ⊆ 视图可串行化 ⊆ 所有调度

实用性：
- 冲突可串行化：易于检测，广泛应用
- 视图可串行化：理论完备，检测复杂
- 串行调度：绝对安全，性能最差
```

## 9.3 实际应用价值



**业务场景应用**：
- **电商系统**：库存扣减的并发控制
- **金融系统**：账户余额的一致性保证
- **订票系统**：座位分配的冲突避免

**技术选型指导**：
- **高并发场景**：选择乐观并发控制
- **强一致性要求**：使用悲观锁机制
- **读多写少**：MVCC + 快照隔离

## 9.4 学习建议



**🎯 理论学习路径**
```
基础概念 → 数学定义 → 算法理解 → 实际应用

重点掌握：
1. 冲突关系的判断
2. 串行化图的构造
3. 检测算法的原理
4. 与隔离级别的对应关系
```

**🔧 实践练习建议**
```
练习1：分析给定调度的可串行化性
练习2：设计避免冲突的事务结构
练习3：比较不同并发控制协议的性能
练习4：在实际系统中应用理论知识
```

**核心记忆口诀**：
- 可串行化是并发正确性的黄金标准
- 冲突关系决定操作的可交换性
- 串行化图无环则调度可串行化
- 理论指导实践，性能需要权衡