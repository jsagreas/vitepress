---
title: 4、快照读与当前读机制
---
## 📚 目录

1. [MVCC读取机制概述](#1-MVCC读取机制概述)
2. [快照读机制详解](#2-快照读机制详解)
3. [当前读机制详解](#3-当前读机制详解)
4. [快照读与当前读对比](#4-快照读与当前读对比)
5. [读取方式选择策略](#5-读取方式选择策略)
6. [实战应用与优化](#6-实战应用与优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 MVCC读取机制概述


### 1.1 什么是MVCC读取机制


**MVCC读取机制**：在多版本并发控制系统中，数据库提供两种不同的数据读取方式，用来处理并发访问时的数据一致性问题。

```
简单理解：
就像看书有两种方式：
1. 快照读：拍一张照片慢慢看，照片内容不会变
2. 当前读：实时翻阅最新版本，内容可能随时更新
```

**🔸 核心概念**
- **快照读（Snapshot Read）**：读取某个时间点的数据快照，不会被其他事务影响
- **当前读（Current Read）**：读取当前最新的数据版本，会加锁防止其他事务修改

### 1.2 为什么需要两种读取机制


**现实场景问题**：
```
场景1：银行查询余额
用户A查询账户余额时，不希望因为其他人正在转账而看到中间状态

场景2：库存扣减操作  
电商系统扣减库存时，必须读取最新库存数据，避免超卖

场景3：报表统计
生成财务报表时，需要某个时间点的一致性数据快照
```

**🎯 设计目标**
- **数据一致性**：保证读取到的数据在逻辑上是一致的
- **并发性能**：允许多个事务同时读取，提高系统吞吐量
- **灵活选择**：根据业务需求选择合适的读取方式

---

## 2. 📸 快照读机制详解


### 2.1 快照读的基本概念


**🔸 快照读定义**
```
快照读：读取事务开始时或特定时间点的数据版本
特点：读取过程中数据不会发生变化，即使其他事务修改了数据
```

**现实类比**：
```
就像拍照片：
- 拍照瞬间：确定了照片内容
- 看照片时：内容固定不变，不受现实变化影响
- 快照读：确定读取版本后，内容保持一致
```

### 2.2 快照读的实现原理


**🔧 MVCC快照机制**
```
实现原理：
1. 事务开始时创建读视图（Read View）
2. 根据事务ID判断数据版本可见性
3. 从版本链中选择合适的数据版本
4. 返回一致性快照数据

版本链示例：
数据行: name='张三'
版本1: trx_id=100, name='张三'    ← 最新版本
版本2: trx_id=80,  name='李四'    ← 历史版本  
版本3: trx_id=60,  name='王五'    ← 更早版本
```

**💡 读视图机制**
```java
// 简化的读视图结构
class ReadView {
    private long creatorTrxId;      // 创建读视图的事务ID
    private List<Long> activeTrxIds; // 活跃事务ID列表
    private long minTrxId;          // 最小活跃事务ID
    private long maxTrxId;          // 最大事务ID
    
    // 判断版本是否可见
    public boolean isVisible(long trxId) {
        if (trxId < minTrxId) {
            return true;  // 已提交的老事务，可见
        }
        if (trxId >= maxTrxId) {
            return false; // 未来事务，不可见
        }
        return !activeTrxIds.contains(trxId); // 非活跃事务可见
    }
}
```

### 2.3 SELECT普通查询（快照读）


**🔸 基本语法**
```sql
-- 最常见的快照读操作
SELECT * FROM users WHERE id = 1;
SELECT name, age FROM users WHERE status = 'active';
SELECT COUNT(*) FROM orders WHERE date = '2025-01-01';
```

**🔸 快照读特点**
```
1. 无锁读取：不会给读取的数据加任何锁
2. 高并发：多个事务可以同时执行快照读
3. 一致性：同一个事务中多次查询结果相同
4. 性能高：没有锁等待，响应速度快
```

**📊 快照读示例**
```sql
-- 事务A：快照读示例
BEGIN;
-- 创建读视图，确定可见数据版本
SELECT balance FROM account WHERE id = 1; -- 结果：1000

-- 此时事务B修改了数据并提交
-- 事务B: UPDATE account SET balance = 1500 WHERE id = 1; COMMIT;

-- 事务A再次查询，仍然是快照版本
SELECT balance FROM account WHERE id = 1; -- 结果：1000（未变化）
COMMIT;
```

### 2.4 读取时间点固定特性


**🕐 时间点固定机制**
```
固定原理：
- RC（读已提交）：每个SELECT语句开始时创建读视图
- RR（可重复读）：事务开始时创建读视图，整个事务期间复用

读取时间点对比：
READ COMMITTED    vs    REPEATABLE READ
每条SQL创建读视图  vs    事务开始创建读视图
可能读到新提交    vs    读取版本固定
```

**💡 实际应用场景**
```sql
-- 场景：银行转账查询
-- 用户希望查询结果在整个操作过程中保持一致

BEGIN; -- RR级别下创建读视图

-- 查询转出账户余额
SELECT balance FROM account WHERE id = 1; -- 1000元

-- 用户考虑5分钟后...

-- 再次确认余额（快照读保证一致）
SELECT balance FROM account WHERE id = 1; -- 仍然1000元

-- 执行转账操作
UPDATE account SET balance = balance - 500 WHERE id = 1;
COMMIT;
```

### 2.5 无锁读取实现


**🔓 无锁机制优势**
```
传统锁机制问题：
读操作需要加共享锁 → 阻塞写操作 → 降低并发性能

MVCC无锁机制：
读操作不加锁 → 不阻塞写操作 → 提高并发性能

性能对比：
传统方式：读写互斥，串行化程度高
MVCC方式：读写并行，并发度大幅提升
```

**📈 性能优化效果**
```
并发场景分析：
- 100个读操作 + 10个写操作
- 传统锁：读写串行，总时间长
- MVCC：读操作并行，只有写操作需要等待

性能提升：
- 读多写少场景：性能提升5-10倍
- 复杂查询场景：性能提升更明显
- 报表统计场景：几乎不受写操作影响
```

---

## 3. 🔒 当前读机制详解


### 3.1 当前读的基本概念


**🔸 当前读定义**
```
当前读：读取数据的最新版本，并加锁防止其他事务修改
特点：总是读取最新数据，但会产生锁等待
```

**现实类比**：
```
就像查看股票实时价格：
- 必须看最新价格（不能看历史价格）
- 看的时候要"锁定"防止变化
- 确保决策基于最新信息
```

### 3.2 当前读的锁定机制


**🔐 锁定原理**
```
锁定机制：
1. 读取最新版本数据
2. 对读取的数据加锁（共享锁或排他锁）
3. 其他事务无法修改被锁定的数据
4. 当前事务提交后释放锁

锁定范围：
- 行锁：锁定具体的数据行
- 间隙锁：锁定索引间隙，防止插入
- Next-Key锁：行锁+间隙锁的组合
```

### 3.3 SELECT FOR UPDATE（排他锁）


**🔸 基本语法**
```sql
-- 排他锁语法
SELECT * FROM table_name WHERE condition FOR UPDATE;

-- 实际示例
SELECT balance FROM account WHERE id = 1 FOR UPDATE;
SELECT * FROM inventory WHERE product_id = 100 FOR UPDATE;
```

**🎯 使用场景**
```sql
-- 场景1：库存扣减
BEGIN;
-- 锁定商品库存，防止其他订单同时扣减
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
-- stock = 10

-- 检查库存充足后扣减
UPDATE products SET stock = stock - 2 WHERE id = 1;
COMMIT;

-- 场景2：账户余额操作
BEGIN;
-- 锁定账户，防止并发转账
SELECT balance FROM account WHERE id = 1 FOR UPDATE;
-- balance = 1000

-- 确保余额充足后扣款
UPDATE account SET balance = balance - 500 WHERE id = 1;
COMMIT;
```

**⚠️ 注意事项**
```
排他锁特点：
✅ 保证数据最新且独占访问
✅ 防止丢失更新问题
❌ 会阻塞其他事务的读写操作
❌ 可能导致死锁

使用原则：
- 锁定时间尽可能短
- 按相同顺序获取锁
- 避免长时间持有锁
```

### 3.4 SELECT FOR SHARE（共享锁）


**🔸 基本语法**
```sql
-- 共享锁语法
SELECT * FROM table_name WHERE condition FOR SHARE;

-- 实际示例
SELECT * FROM orders WHERE id = 1 FOR SHARE;
SELECT customer_info FROM users WHERE id = 100 FOR SHARE;
```

**🔍 应用场景**
```sql
-- 场景：订单详情查询（防止订单被删除）
BEGIN;
-- 加共享锁，允许其他事务读取，但不允许修改/删除
SELECT * FROM orders WHERE order_id = 'ORD001' FOR SHARE;

-- 根据订单信息进行后续处理
SELECT * FROM order_items WHERE order_id = 'ORD001';

-- 处理完成后释放锁
COMMIT;
```

**📊 共享锁特点**
```
共享锁机制：
✅ 多个事务可以同时持有共享锁
✅ 防止数据被修改或删除  
✅ 允许其他事务读取相同数据
❌ 阻塞排他锁（写操作）

兼容性矩阵：
          无锁   共享锁   排他锁
无锁       ✅     ✅      ✅
共享锁     ✅     ✅      ❌  
排他锁     ✅     ❌      ❌
```

### 3.5 INSERT UPDATE DELETE（隐式当前读）


**🔸 DML操作特点**
```
DML操作天然是当前读：
- INSERT：插入最新数据，检查约束冲突
- UPDATE：基于最新数据进行修改
- DELETE：删除最新版本的数据

锁定行为：
- 自动对操作的行加排他锁
- 防止其他事务同时修改相同数据
- 确保操作的原子性和一致性
```

**💡 实际示例**
```sql
-- UPDATE操作的当前读
UPDATE products SET price = price * 1.1 WHERE category = 'electronics';
-- 等价于：
-- SELECT price FROM products WHERE category = 'electronics' FOR UPDATE;
-- 然后基于最新价格计算新价格

-- DELETE操作的当前读  
DELETE FROM orders WHERE status = 'cancelled' AND create_time < '2024-01-01';
-- 等价于：
-- SELECT * FROM orders WHERE status = 'cancelled' FOR UPDATE;
-- 然后删除符合条件的最新数据

-- INSERT操作的当前读
INSERT INTO users (email, name) VALUES ('test@example.com', '张三');
-- 检查最新的唯一约束冲突
```

---

## 4. ⚖️ 快照读与当前读对比


### 4.1 核心差异对比


| **对比维度** | **快照读** | **当前读** |
|------------|-----------|-----------|
| **🎯 读取版本** | `历史快照版本` | `最新数据版本` |
| **🔒 锁定机制** | `无锁读取` | `加锁读取` |
| **⚡ 并发性能** | `高并发，无阻塞` | `并发受限，可能阻塞` |
| **🎛️ 一致性保证** | `事务内一致` | `全局最新一致` |
| **📊 数据实时性** | `可能读到旧数据` | `总是最新数据` |
| **🚀 响应速度** | `快速响应` | `可能等待锁释放` |

### 4.2 使用场景对比


**📈 快照读适用场景**
```sql
-- 1. 报表统计（需要一致性快照）
SELECT 
    DATE(order_date) as date,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders 
WHERE order_date >= '2025-01-01'
GROUP BY DATE(order_date);

-- 2. 数据浏览（不需要最新数据）
SELECT * FROM products WHERE category = 'books' LIMIT 20;

-- 3. 复杂查询（避免锁等待）
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;
```

**🔐 当前读适用场景**
```sql
-- 1. 库存操作（必须基于最新数据）
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
UPDATE products SET stock = stock - 1 WHERE id = 1;

-- 2. 账户余额操作（防止透支）
SELECT balance FROM account WHERE id = 1 FOR UPDATE;
UPDATE account SET balance = balance - 100 WHERE id = 1;

-- 3. 唯一性检查（防止重复）
SELECT COUNT(*) FROM users WHERE email = 'test@example.com' FOR SHARE;
INSERT INTO users (email, name) VALUES ('test@example.com', '张三');
```

### 4.3 性能影响分析


**📊 并发性能对比**
```
高并发读取场景：
快照读：
- 1000个并发查询 → 同时执行，无等待
- 响应时间：10ms左右
- 系统负载：CPU使用率适中

当前读：
- 1000个并发查询 → 串行等待锁
- 响应时间：10ms * 1000 = 10秒
- 系统负载：大量锁等待，性能下降明显
```

**⚠️ 数据一致性权衡**
```
快照读风险：
- 可能读到过时数据
- 业务决策基于旧信息
- 适合对实时性要求不高的场景

当前读保证：
- 总是读到最新数据  
- 业务决策基于准确信息
- 适合对数据准确性要求高的场景
```

---

## 5. 🎯 读取方式选择策略


### 5.1 业务场景判断标准


**🔍 选择决策树**
```
业务需求分析：
├── 是否需要最新数据？
│   ├── 是 → 当前读
│   └── 否 → 继续判断
├── 是否涉及数据修改？
│   ├── 是 → 当前读  
│   └── 否 → 继续判断
├── 对并发性能要求高？
│   ├── 是 → 快照读
│   └── 否 → 当前读
└── 数据一致性要求？
    ├── 事务内一致 → 快照读
    └── 全局一致 → 当前读
```

### 5.2 具体场景选择指南


**📋 快照读场景清单**
```
✅ 适合快照读的场景：
- 📊 数据统计和报表生成
- 🔍 普通数据查询和浏览
- 📋 列表展示和分页查询  
- 🔍 搜索和筛选操作
- 📈 历史数据分析
- 👥 用户信息展示

原因：这些场景对数据实时性要求不高，更注重查询性能
```

**🔒 当前读场景清单**
```
✅ 适合当前读的场景：
- 💰 金融交易操作（转账、支付）
- 📦 库存扣减操作
- 🎫 座位预订、票务系统
- 🔢 计数器更新（点赞、浏览量）
- ✅ 状态检查后的操作
- 🆔 唯一性验证

原因：这些场景必须基于最新数据做决策，避免业务错误
```

### 5.3 混合使用策略


**🔄 组合使用模式**
```sql
-- 模式1：先快照读后当前读
-- 场景：商品详情页 → 立即购买

-- 1. 快照读：展示商品信息（性能优先）
SELECT name, description, price FROM products WHERE id = 1;

-- 2. 当前读：购买时检查库存（准确性优先）  
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

**⚖️ 读取策略配置**
```sql
-- 根据业务重要程度选择
-- 重要业务：强制当前读
SELECT balance FROM vip_account WHERE id = 1 FOR UPDATE;

-- 一般业务：默认快照读
SELECT balance FROM regular_account WHERE id = 1;

-- 批量操作：快照读 + 批量当前读
-- 1. 快照读筛选候选数据
SELECT id FROM orders WHERE status = 'pending';

-- 2. 批量当前读处理
UPDATE orders SET status = 'processing' 
WHERE id IN (1,2,3) AND status = 'pending';
```

### 5.4 性能优化建议


**🚀 快照读优化**
```sql
-- 1. 合理使用索引
SELECT * FROM users WHERE create_time >= '2025-01-01'
-- 确保create_time有索引

-- 2. 避免全表扫描
SELECT * FROM orders WHERE status IN ('paid', 'shipped')  
-- 确保status字段有索引

-- 3. 控制查询结果集大小
SELECT * FROM products WHERE category = 'books' LIMIT 100;
-- 使用LIMIT控制返回数据量
```

**🔐 当前读优化**
```sql
-- 1. 缩小锁定范围
SELECT balance FROM account WHERE id = 1 FOR UPDATE;
-- 只锁定需要的行，避免锁定整个表

-- 2. 减少锁持有时间
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
-- 立即进行业务逻辑处理，不要有其他耗时操作
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT; -- 尽快提交释放锁

-- 3. 按顺序获取锁（防止死锁）
-- 总是按照id顺序获取锁
SELECT * FROM account WHERE id IN (1, 2) ORDER BY id FOR UPDATE;
```

---

## 6. 🛠️ 实战应用与优化


### 6.1 电商场景实战


**🛒 购物车到订单转换**
```sql
-- 场景：用户结算购物车商品

-- 步骤1：快照读展示购物车（用户确认）
SELECT 
    p.name,
    p.price,
    c.quantity,
    p.price * c.quantity as subtotal
FROM cart c
JOIN products p ON c.product_id = p.id  
WHERE c.user_id = 1001;

-- 步骤2：当前读检查库存并锁定（确保有货）
BEGIN;

-- 锁定所有相关商品，检查库存
SELECT p.id, p.stock, c.quantity
FROM cart c
JOIN products p ON c.product_id = p.id
WHERE c.user_id = 1001
FOR UPDATE;

-- 检查库存充足后创建订单
INSERT INTO orders (user_id, total_amount, status) 
VALUES (1001, 299.99, 'pending');

-- 扣减库存
UPDATE products p
JOIN cart c ON p.id = c.product_id
SET p.stock = p.stock - c.quantity
WHERE c.user_id = 1001;

-- 清空购物车
DELETE FROM cart WHERE user_id = 1001;

COMMIT;
```

### 6.2 金融场景实战


**💳 银行转账操作**
```sql
-- 场景：用户A向用户B转账500元

-- 错误做法：使用快照读（可能导致透支）
/*
SELECT balance FROM account WHERE id = 1; -- 快照读，可能读到旧数据
UPDATE account SET balance = balance - 500 WHERE id = 1;
*/

-- 正确做法：使用当前读
BEGIN;

-- 当前读锁定转出账户，确保余额准确
SELECT balance FROM account WHERE id = 1 FOR UPDATE;
-- 假设返回 balance = 800

-- 检查余额充足
IF balance >= 500 THEN
    -- 执行转账
    UPDATE account SET balance = balance - 500 WHERE id = 1;
    UPDATE account SET balance = balance + 500 WHERE id = 2;
    
    -- 记录转账日志
    INSERT INTO transfer_log (from_account, to_account, amount, status)
    VALUES (1, 2, 500, 'success');
ELSE
    -- 余额不足，回滚事务
    ROLLBACK;
END IF;

COMMIT;
```

### 6.3 秒杀场景优化


**⚡ 高并发秒杀优化**
```sql
-- 场景：商品秒杀，1000人抢100件商品

-- 优化前：每个请求都当前读（性能差）
/*
SELECT stock FROM products WHERE id = 1 FOR UPDATE; -- 串行化
UPDATE products SET stock = stock - 1 WHERE id = 1;
*/

-- 优化后：预检查 + 当前读
-- 步骤1：快照读预检查（过滤大部分请求）
SELECT stock FROM products WHERE id = 1;
IF stock <= 0 THEN
    RETURN '商品已售完';
END IF;

-- 步骤2：通过预检查才进行当前读
BEGIN;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;
IF stock > 0 THEN
    UPDATE products SET stock = stock - 1 WHERE id = 1;
    -- 创建订单
    INSERT INTO orders (user_id, product_id, quantity)
    VALUES (1001, 1, 1);
    COMMIT;
    RETURN '抢购成功';
ELSE
    ROLLBACK;
    RETURN '商品已售完';
END IF;
```

### 6.4 报表生成优化


**📊 大数据量报表优化**
```sql
-- 场景：生成日销售报表

-- 优化策略：全程使用快照读，确保数据一致性
BEGIN; -- 在RR级别下创建统一读视图

-- 订单统计（快照读）
SELECT 
    DATE(create_time) as sale_date,
    COUNT(*) as order_count,
    SUM(total_amount) as total_sales
FROM orders 
WHERE create_time >= CURDATE()
GROUP BY DATE(create_time);

-- 商品销量统计（快照读，与订单数据一致）
SELECT 
    p.name,
    SUM(oi.quantity) as sold_quantity,
    SUM(oi.price * oi.quantity) as revenue
FROM order_items oi
JOIN products p ON oi.product_id = p.id
JOIN orders o ON oi.order_id = o.id
WHERE o.create_time >= CURDATE()
GROUP BY p.id, p.name
ORDER BY sold_quantity DESC;

COMMIT; -- 释放读视图
```

### 6.5 死锁预防策略


**🔒 死锁预防最佳实践**
```sql
-- 问题场景：两个事务互相等待对方的锁

-- 死锁示例（避免这样做）：
-- 事务A：锁定账户1 → 等待账户2
-- 事务B：锁定账户2 → 等待账户1

-- 解决方案：按固定顺序获取锁
-- 转账函数：总是按账户ID升序获取锁
DELIMITER $$
CREATE PROCEDURE safe_transfer(
    IN from_account_id INT,
    IN to_account_id INT, 
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE min_id INT;
    DECLARE max_id INT;
    
    -- 确定加锁顺序
    SET min_id = LEAST(from_account_id, to_account_id);
    SET max_id = GREATEST(from_account_id, to_account_id);
    
    START TRANSACTION;
    
    -- 按顺序获取锁，防止死锁
    SELECT balance FROM account WHERE id = min_id FOR UPDATE;
    SELECT balance FROM account WHERE id = max_id FOR UPDATE;
    
    -- 执行转账逻辑
    UPDATE account SET balance = balance - amount WHERE id = from_account_id;
    UPDATE account SET balance = balance + amount WHERE id = to_account_id;
    
    COMMIT;
END$$
DELIMITER ;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 快照读：读取历史版本，无锁高并发，适合查询场景
🔸 当前读：读取最新版本，加锁保证准确，适合修改场景  
🔸 锁定机制：FOR UPDATE(排他锁)，FOR SHARE(共享锁)
🔸 选择策略：根据业务需求平衡性能与一致性
🔸 优化原则：缩小锁范围，减少锁时间，避免死锁
```

### 7.2 关键理解要点


**🔹 快照读的价值**
```
性能优势：
- 无锁并发，大幅提升系统吞吐量
- 避免读写冲突，减少等待时间
- 支持复杂查询，不影响写操作

一致性保证：
- 事务内数据一致，避免中间状态
- 适合报表统计等场景
- 通过MVCC实现高并发下的一致性读取
```

**🔹 当前读的必要性**
```
准确性保证：
- 总是基于最新数据做决策
- 防止并发修改导致的业务错误
- 确保关键操作的数据准确性

安全性保证：
- 通过锁机制防止数据竞争
- 避免丢失更新等并发问题
- 保证事务的隔离性
```

**🔹 选择策略的智慧**
```
业务导向：
- 查询展示类 → 快照读（性能优先）
- 交易操作类 → 当前读（准确性优先）
- 混合场景 → 分阶段选择合适机制

性能平衡：
- 不是所有场景都需要最新数据
- 适度使用当前读，避免性能过度损失
- 通过预检查等策略优化当前读性能
```

### 7.3 实际应用指导


**✅ 最佳实践**
- **快照读场景**：数据展示、报表统计、复杂查询
- **当前读场景**：金融交易、库存操作、状态变更
- **锁粒度控制**：只锁定必要的行，避免大范围锁定
- **锁时间控制**：尽快完成业务逻辑，及时释放锁
- **死锁预防**：按固定顺序获取锁，设置合理超时

**⚠️ 常见陷阱**
```
快照读陷阱：
- 在需要最新数据的场景误用快照读
- 长事务导致读取过时数据
- 忽略了数据实时性要求

当前读陷阱：
- 过度使用导致性能问题
- 长时间持有锁导致阻塞
- 获取锁顺序不当导致死锁
- 不必要的锁定范围过大
```

### 7.4 性能优化要点


**🚀 读取性能优化**
```
快照读优化：
- 合理使用索引减少扫描范围
- 控制查询结果集大小
- 避免不必要的关联查询
- 利用覆盖索引减少回表

当前读优化：
- 精确定位锁定行，避免全表锁
- 减少事务执行时间
- 合理设计索引支持锁定查询
- 使用批量操作减少锁开销
```

**核心记忆**：
- 快照读无锁高效适合查询，当前读加锁准确适合修改
- 根据业务需求选择读取方式，平衡性能与准确性
- 掌握锁定机制和优化策略，避免性能问题和死锁
- 在高并发场景下，合理使用两种读取方式是关键