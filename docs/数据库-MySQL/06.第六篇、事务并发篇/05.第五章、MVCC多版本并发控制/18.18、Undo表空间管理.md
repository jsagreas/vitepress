---
title: 18、Undo表空间管理
---
## 📚 目录

1. [Undo表空间基础概念](#1-undo表空间基础概念)
2. [Undo表空间配置管理](#2-undo表空间配置管理)
3. [独立Undo表空间](#3-独立undo表空间)
4. [Undo段管理机制](#4-undo段管理机制)
5. [Undo日志分组策略](#5-undo日志分组策略)
6. [表空间扩展与收缩](#6-表空间扩展与收缩)
7. [Undo表空间监控](#7-undo表空间监控)
8. [空间使用优化](#8-空间使用优化)
9. [表空间故障处理](#9-表空间故障处理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔰 Undo表空间基础概念


### 1.1 什么是Undo表空间


**简单理解**：Undo表空间就像是数据库的"后悔药仓库"

```
生活类比：
就像你用Word写文档时的撤销功能
- 你打错字了，按Ctrl+Z可以撤销
- 数据库也需要这样的"撤销"能力
- Undo表空间就是存放这些"撤销信息"的地方
```

**核心作用**：
- 🔄 **事务回滚**：当事务失败时，能够撤销所有修改
- 📖 **一致性读**：让查询看到一致的数据快照
- 🔒 **MVCC支持**：实现多版本并发控制

### 1.2 Undo表空间的工作原理


```
数据修改过程：
原始数据: name='张三', age=25
修改操作: UPDATE users SET age=26 WHERE name='张三'

工作流程：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   原始数据      │    │   Undo记录      │    │   新数据        │
│  name='张三'    │───▶│  name='张三'    │───▶│  name='张三'    │
│  age=25         │    │  age=25         │    │  age=26         │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                            ↑
                       存储在Undo表空间
```

**为什么需要Undo**：
```
场景1：事务回滚
- 事务执行了一半出错了
- 需要把所有修改都撤销回去
- Undo记录告诉我们"修改前是什么样子"

场景2：并发读取
- 用户A正在修改数据
- 用户B想查询数据
- 用户B看到的应该是修改前的旧数据
- 这叫"一致性读"
```

### 1.3 Undo表空间的类型


**系统表空间 vs 独立表空间**：

```
传统方式（系统表空间）：
┌─────────────────────────────────┐
│         系统表空间               │
│  ┌─────────┐ ┌─────────────┐   │
│  │数据字典 │ │  Undo数据   │   │
│  └─────────┘ └─────────────┘   │
│  ┌─────────────────────────┐   │
│  │      其他系统数据       │   │
│  └─────────────────────────┘   │
└─────────────────────────────────┘
问题：所有数据混在一起，不好管理

现代方式（独立表空间）：
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  系统表空间 │  │ Undo表空间1 │  │ Undo表空间2 │
│   数据字典  │  │  Undo数据   │  │  Undo数据   │
│   系统数据  │  │             │  │             │
└─────────────┘  └─────────────┘  └─────────────┘
优势：分离管理，性能更好
```

---

## 2. ⚙️ Undo表空间配置管理


### 2.1 基本配置参数


**核心参数说明**：

| 参数名称 | **作用** | **推荐值** | **说明** |
|---------|---------|-----------|---------|
| `innodb_undo_tablespaces` | **Undo表空间数量** | `2-4个` | `设置独立Undo表空间的个数` |
| `innodb_undo_directory` | **存储目录** | `独立目录` | `Undo表空间文件存放位置` |
| `innodb_max_undo_log_size` | **单个表空间大小限制** | `1GB` | `超过此值会触发截断操作` |
| `innodb_undo_log_truncate` | **自动截断开关** | `ON` | `启用自动清理过大的Undo表空间` |

### 2.2 创建独立Undo表空间


**方法1：初始化时配置**
```sql
-- 在my.cnf中配置
[mysqld]
innodb_undo_tablespaces = 3
innodb_undo_directory = /data/mysql/undo
innodb_max_undo_log_size = 1G
innodb_undo_log_truncate = ON
```

**方法2：运行时添加**
```sql
-- 动态创建新的Undo表空间
CREATE UNDO TABLESPACE undo_003 
ADD DATAFILE '/data/mysql/undo/undo_003.ibu';

-- 查看创建结果
SELECT TABLESPACE_NAME, FILE_NAME, FILE_TYPE 
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME LIKE 'undo%';
```

### 2.3 配置验证与查看


```sql
-- 查看当前Undo表空间配置
SHOW VARIABLES LIKE '%undo%';

-- 查看Undo表空间状态
SELECT 
    TABLESPACE_NAME,
    FILE_NAME,
    TOTAL_EXTENTS,
    EXTENT_SIZE,
    INITIAL_SIZE/1024/1024 AS SIZE_MB,
    STATUS
FROM INFORMATION_SCHEMA.FILES 
WHERE FILE_TYPE = 'UNDO LOG';
```

> 💡 **配置建议**  
> 对于生产环境，建议配置2-4个Undo表空间，这样可以在一个表空间进行截断清理时，其他表空间继续提供服务，避免性能影响。

---

## 3. 🏗️ 独立Undo表空间


### 3.1 为什么使用独立Undo表空间


**传统方式的问题**：
```
系统表空间存储Undo的问题：
┌─────────────────────────────────┐
│         ibdata1文件             │
│  ┌─────────┐ ┌─────────────┐   │  ← 所有数据混在一个文件
│  │数据字典 │ │  Undo数据   │   │  ← Undo数据无法单独管理
│  └─────────┘ └─────────────┘   │  ← 文件只能增长，不能缩小
│  ┌─────────────────────────┐   │  ← 影响整体性能
│  │      其他系统数据       │   │
│  └─────────────────────────┘   │
└─────────────────────────────────┘

主要问题：
1. 文件只增不减，磁盘空间浪费
2. 所有数据混合，I/O性能差
3. 无法针对Undo进行专门优化
4. 备份恢复复杂
```

**独立表空间的优势**：
```
独立Undo表空间的好处：
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  系统表空间 │  │ Undo表空间1 │  │ Undo表空间2 │
│             │  │             │  │             │
│  数据字典   │  │  事务1-100  │  │ 事务101-200 │
│  系统数据   │  │  Undo数据   │  │  Undo数据   │
└─────────────┘  └─────────────┘  └─────────────┘
                       ↓               ↓
                   可以截断清理     可以截断清理

优势：
✅ 可以自动收缩，回收磁盘空间
✅ I/O性能更好，专门优化
✅ 可以放在不同磁盘上
✅ 备份恢复更灵活
```

### 3.2 独立表空间的创建管理


**创建步骤**：
```sql
-- 步骤1：创建Undo表空间
CREATE UNDO TABLESPACE undo_001 
ADD DATAFILE '/data/mysql/undo/undo_001.ibu';

-- 步骤2：激活表空间
ALTER UNDO TABLESPACE undo_001 SET ACTIVE;

-- 步骤3：验证创建结果
SELECT 
    TABLESPACE_NAME,
    FILE_NAME,
    STATE
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES 
WHERE NAME LIKE 'undo%';
```

**表空间状态管理**：
```sql
-- 设置为活跃状态（可以分配新事务）
ALTER UNDO TABLESPACE undo_001 SET ACTIVE;

-- 设置为非活跃状态（不分配新事务，等待清理）
ALTER UNDO TABLESPACE undo_001 SET INACTIVE;

-- 删除表空间（必须先设为INACTIVE并等待清理完成）
DROP UNDO TABLESPACE undo_001;
```

### 3.3 表空间状态说明


```
Undo表空间的生命周期：
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  EMPTY  │───▶│ ACTIVE  │───▶│INACTIVE │───▶│DROPPED  │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
     ↑              ↑              ↑              ↑
  刚创建时      正常使用中     准备清理中      已删除

状态详解：
• EMPTY：刚创建，还没有事务使用
• ACTIVE：正在使用，可以分配给新事务
• INACTIVE：停止分配新事务，等待现有事务完成
• 清理完成后才能删除
```

---

## 4. 📦 Undo段管理机制


### 4.1 什么是Undo段


**通俗理解**：Undo段就像是"事务专用的储物柜"

```
现实类比：
超市寄存柜 = Undo表空间
每个柜子 = Undo段
顾客的物品 = 事务的Undo记录

工作流程：
1. 顾客来了，分配一个空柜子
2. 把东西放进去
3. 购物结束，清空柜子，给下一个顾客用
```

**Undo段的结构**：
```
Undo表空间内部结构：
┌─────────────────────────────────┐
│         Undo表空间              │
│  ┌─────────┐ ┌─────────────┐   │
│  │ Undo段1 │ │   Undo段2   │   │  ← 每个段服务一个事务
│  │事务ID123│ │  事务ID124  │   │
│  │ Undo记录│ │  Undo记录   │   │
│  └─────────┘ └─────────────┘   │
│  ┌─────────────┐ ┌─────────┐   │
│  │   Undo段3   │ │ 空闲段  │   │
│  │  事务ID125  │ │         │   │
│  │  Undo记录   │ │         │   │
│  └─────────────┘ └─────────┘   │
└─────────────────────────────────┘
```

### 4.2 段的分配与回收


**段分配策略**：
```sql
-- 事务开始时的段分配
-- 系统自动完成，用户不需要手动操作

-- 查看当前段的使用情况
SELECT 
    space_id,
    segment_id,
    n_used,
    n_free,
    n_free_frag
FROM INFORMATION_SCHEMA.INNODB_SYS_SEGMENTS
WHERE type = 'UNDO';
```

**段回收机制**：
```
段的生命周期：
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│分配给事务│───▶│填充数据 │───▶│事务提交 │───▶│段被回收 │
└─────────┘    └─────────┘    └─────────┘    └─────────┘

回收条件：
1. 事务已经提交或回滚
2. 没有其他事务需要读取这些Undo记录
3. 达到了可以安全清理的时间点

自动回收：
- 由后台线程定期执行
- 优先回收最老的、不再需要的段
```

### 4.3 段管理监控


```sql
-- 查看段使用统计
SELECT 
    TABLESPACE_NAME,
    COUNT(*) as segment_count,
    SUM(EXTENT_SIZE) as total_size
FROM INFORMATION_SCHEMA.FILES f
JOIN INFORMATION_SCHEMA.INNODB_SYS_SEGMENTS s 
    ON f.TABLESPACE_NAME = s.space_name
WHERE f.FILE_TYPE = 'UNDO LOG'
GROUP BY TABLESPACE_NAME;

-- 查看活跃事务占用的段
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_isolation_level,
    trx_undo_no
FROM INFORMATION_SCHEMA.INNODB_TRX
ORDER BY trx_started;
```

---

## 5. 📋 Undo日志分组策略


### 5.1 什么是Undo日志分组


**通俗解释**：就像把不同类型的垃圾分类处理一样

```
生活类比：
垃圾分类：
┌─────────┐  ┌─────────┐  ┌─────────┐
│可回收垃圾│  │厨余垃圾 │  │有害垃圾 │
└─────────┘  └─────────┘  └─────────┘

Undo日志分组：
┌─────────┐  ┌─────────┐  ┌─────────┐
│INSERT类型│  │UPDATE类型│  │DELETE类型│
│Undo日志  │  │Undo日志  │  │Undo日志  │
└─────────┘  └─────────┘  └─────────┘

目的：不同类型的操作，处理方式不同
```

### 5.2 分组的实现机制


**按事务类型分组**：
```
只读事务组：
┌─────────────────────┐
│     只读事务组      │
│  SELECT查询事务     │  ← 不需要Undo段
│  不修改数据         │  ← 资源消耗小
└─────────────────────┘

读写事务组：
┌─────────────────────┐
│     读写事务组      │
│  INSERT/UPDATE/     │  ← 需要Undo段
│  DELETE事务         │  ← 资源消耗大
└─────────────────────┘
```

**按操作类型分组**：
```sql
-- Insert Undo：记录插入操作的撤销信息
-- 特点：撤销时只需要删除记录
INSERT INTO users VALUES (1, '张三', 25);
-- Undo记录：删除ID=1的记录

-- Update Undo：记录更新操作的撤销信息  
-- 特点：撤销时需要恢复旧值
UPDATE users SET age=26 WHERE id=1;
-- Undo记录：将ID=1的age改回25

-- Delete Undo：记录删除操作的撤销信息
-- 特点：撤销时需要重新插入记录
DELETE FROM users WHERE id=1;
-- Undo记录：重新插入(1, '张三', 25)
```

### 5.3 分组的性能优化


**轮换使用策略**：
```
多表空间轮换：
时间轴：  T1    T2    T3    T4    T5
        ↓     ↓     ↓     ↓     ↓
表空间1：[事务1] ----  [事务3] ----  [事务5]
表空间2：----  [事务2] ----  [事务4] ----
表空间3：清理   ----   清理   ----   清理

优势：
- 一个表空间清理时，其他继续服务
- 负载均衡，避免单个表空间过载
- 提高并发处理能力
```

**自动负载均衡**：
```sql
-- 查看各表空间的负载分布
SELECT 
    TABLESPACE_NAME,
    ALLOCATED_SIZE/1024/1024 AS allocated_mb,
    DATA_LENGTH/1024/1024 AS used_mb,
    (ALLOCATED_SIZE - DATA_LENGTH)/1024/1024 AS free_mb
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME LIKE 'undo%'
ORDER BY allocated_mb DESC;
```

---

## 6. 📈 表空间扩展与收缩


### 6.1 自动扩展机制


**扩展触发条件**：
```
表空间扩展时机：
当前使用率 > 85% ────┐
                    ├──► 触发自动扩展
新事务需要空间 ─────┘

扩展过程：
┌─────────┐    ┌─────────────┐    ┌─────────────────┐
│  100MB  │───▶│   200MB     │───▶│     400MB       │
│使用90MB │    │ 使用90MB    │    │   使用90MB      │
└─────────┘    └─────────────┘    └─────────────────┘
   达到阈值        扩展一倍           继续可用
```

**扩展参数配置**：
```sql
-- 查看自动扩展配置
SHOW VARIABLES LIKE 'innodb_autoextend_increment';

-- 设置扩展增量（单位：MB）
SET GLOBAL innodb_autoextend_increment = 64;

-- 查看表空间当前大小和使用情况
SELECT 
    TABLESPACE_NAME,
    INITIAL_SIZE/1024/1024 AS initial_mb,
    TOTAL_EXTENTS * EXTENT_SIZE/1024/1024 AS current_mb,
    AUTOEXTEND_SIZE/1024/1024 AS autoextend_mb
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME LIKE 'undo%';
```

### 6.2 自动收缩（截断）机制


**收缩触发条件**：
```
自动截断的条件：
1. 表空间大小超过 innodb_max_undo_log_size
2. 表空间中的事务都已经提交
3. 没有长时间运行的查询需要旧版本数据
4. innodb_undo_log_truncate = ON

截断过程：
┌─────────────────┐    ┌─────────────┐    ┌─────────┐
│     2GB         │───▶│    1GB      │───▶│ 100MB   │
│ 大量旧数据      │    │清理部分数据 │    │只保留必需│
└─────────────────┘    └─────────────┘    └─────────┘
   超过阈值              开始截断           截断完成
```

**截断配置与监控**：
```sql
-- 配置截断参数
SET GLOBAL innodb_max_undo_log_size = 1073741824; -- 1GB
SET GLOBAL innodb_undo_log_truncate = ON;
SET GLOBAL innodb_purge_rseg_truncate_frequency = 128;

-- 监控截断状态
SELECT 
    TABLESPACE_NAME,
    FILE_SIZE/1024/1024 AS size_mb,
    CASE 
        WHEN FILE_SIZE > $$innodb_max_undo_log_size 
        THEN 'Need Truncate'
        ELSE 'OK'
    END AS status
FROM INFORMATION_SCHEMA.FILES 
WHERE FILE_TYPE = 'UNDO LOG';
```

### 6.3 手动管理空间


**手动收缩步骤**：
```sql
-- 步骤1：设置表空间为非活跃
ALTER UNDO TABLESPACE undo_002 SET INACTIVE;

-- 步骤2：等待事务完成（可能需要等待）
-- 查看是否还有活跃事务
SELECT COUNT(*) as active_transactions
FROM INFORMATION_SCHEMA.INNODB_TRX;

-- 步骤3：确认可以清理
SELECT 
    TABLESPACE_NAME,
    STATE
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES 
WHERE NAME = 'undo_002';

-- 步骤4：截断会自动进行，或重新激活
ALTER UNDO TABLESPACE undo_002 SET ACTIVE;
```

---

## 7. 📊 Undo表空间监控


### 7.1 关键监控指标


**空间使用监控**：
```sql
-- 综合监控视图
SELECT 
    TABLESPACE_NAME,
    FILE_NAME,
    TOTAL_EXTENTS,
    EXTENT_SIZE/1024 AS extent_size_kb,
    INITIAL_SIZE/1024/1024 AS initial_mb,
    MAXIMUM_SIZE/1024/1024 AS max_mb,
    AUTOEXTEND_SIZE/1024/1024 AS autoextend_mb,
    DATA_LENGTH/1024/1024 AS used_mb,
    (TOTAL_EXTENTS * EXTENT_SIZE - DATA_LENGTH)/1024/1024 AS free_mb,
    ROUND((DATA_LENGTH * 100.0) / (TOTAL_EXTENTS * EXTENT_SIZE), 2) AS usage_pct
FROM INFORMATION_SCHEMA.FILES 
WHERE FILE_TYPE = 'UNDO LOG'
ORDER BY usage_pct DESC;
```

**性能相关监控**：
```sql
-- Undo相关的性能指标
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN (
    'Innodb_undo_tablespaces_total',
    'Innodb_undo_tablespaces_implicit', 
    'Innodb_undo_tablespaces_explicit',
    'Innodb_undo_tablespaces_active'
);

-- 查看事务处理情况
SELECT 
    COUNT(*) as total_transactions,
    COUNT(CASE WHEN trx_state = 'RUNNING' THEN 1 END) as running_transactions,
    MAX(TIME_TO_SEC(TIMEDIFF(NOW(), trx_started))) as longest_transaction_sec
FROM INFORMATION_SCHEMA.INNODB_TRX;
```

### 7.2 自动化监控脚本


**监控脚本示例**：
```sql
-- 创建监控存储过程
DELIMITER //
CREATE PROCEDURE monitor_undo_tablespaces()
BEGIN
    -- 检查空间使用率
    SELECT 
        'SPACE_USAGE' as check_type,
        TABLESPACE_NAME,
        ROUND((DATA_LENGTH * 100.0) / (TOTAL_EXTENTS * EXTENT_SIZE), 2) AS usage_pct,
        CASE 
            WHEN (DATA_LENGTH * 100.0) / (TOTAL_EXTENTS * EXTENT_SIZE) > 90 
            THEN 'CRITICAL'
            WHEN (DATA_LENGTH * 100.0) / (TOTAL_EXTENTS * EXTENT_SIZE) > 80 
            THEN 'WARNING'
            ELSE 'OK'
        END as status
    FROM INFORMATION_SCHEMA.FILES 
    WHERE FILE_TYPE = 'UNDO LOG';
    
    -- 检查长时间运行的事务
    SELECT 
        'LONG_TRANSACTIONS' as check_type,
        trx_id,
        trx_state,
        trx_started,
        TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) as duration_seconds
    FROM INFORMATION_SCHEMA.INNODB_TRX
    WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 300; -- 超过5分钟
END //
DELIMITER ;

-- 运行监控
CALL monitor_undo_tablespaces();
```

### 7.3 告警阈值设置


**建议的告警阈值**：

| 指标 | **警告阈值** | **严重阈值** | **处理建议** |
|------|-------------|-------------|-------------|
| **空间使用率** | `80%` | `90%` | `检查是否有长事务，考虑增加表空间` |
| **长时间事务** | `5分钟` | `30分钟` | `检查事务逻辑，及时提交或回滚` |
| **表空间大小** | `接近max_size` | `达到max_size` | `截断或扩展表空间` |
| **活跃事务数** | `1000` | `5000` | `检查应用逻辑，避免事务堆积` |

---

## 8. ⚡ 空间使用优化


### 8.1 优化策略总览


**优化的核心思路**：
```
优化目标：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  减少产生   │───▶│  及时清理   │───▶│  合理配置   │
│ Undo数据量  │    │ 不需要的数据│    │  表空间参数 │
└─────────────┘    └─────────────┘    └─────────────┘

具体措施：
• 优化事务逻辑，减少长事务
• 及时提交事务，避免积累
• 合理配置截断参数
• 监控并调整表空间大小
```

### 8.2 事务优化


**减少Undo产生**：
```sql
-- 不好的做法：大批量操作在一个事务中
START TRANSACTION;
UPDATE large_table SET status = 'processed'; -- 可能影响百万行
COMMIT;

-- 好的做法：分批处理
DELIMITER //
CREATE PROCEDURE batch_update()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE affected_rows INT;
    
    REPEAT
        START TRANSACTION;
        UPDATE large_table 
        SET status = 'processed' 
        WHERE status = 'pending' 
        LIMIT batch_size;
        
        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        COMMIT;
        
        IF affected_rows < batch_size THEN
            SET done = TRUE;
        END IF;
    UNTIL done END REPEAT;
END //
DELIMITER ;
```

**避免长时间事务**：
```sql
-- 检查长时间运行的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_mysql_thread_id,
    TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) as duration_seconds,
    trx_query
FROM INFORMATION_SCHEMA.INNODB_TRX
WHERE TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) > 60
ORDER BY duration_seconds DESC;

-- 如果必要，可以终止长事务
-- KILL 线程ID;  -- 谨慎使用
```

### 8.3 参数调优


**关键参数优化**：
```sql
-- 调整截断频率（更频繁的清理）
SET GLOBAL innodb_purge_rseg_truncate_frequency = 32; -- 默认128

-- 调整截断大小阈值（更小的阈值）
SET GLOBAL innodb_max_undo_log_size = 536870912; -- 512MB

-- 启用后台清理
SET GLOBAL innodb_undo_log_truncate = ON;

-- 增加清理线程数量
SET GLOBAL innodb_purge_threads = 4; -- 根据CPU核数调整
```

**性能平衡配置**：
```
配置权衡：
┌─────────────────┐    ┌─────────────────┐
│   截断频率高    │    │   截断频率低    │
│   ┌─────────┐   │    │   ┌─────────┐   │
│   │优点：    │   │    │   │优点：    │   │
│   │空间利用好│   │    │   │性能影响小│   │
│   │┌─────────┤   │    │   │┌─────────┤   │
│   ││缺点：    │   │    │   ││缺点：    │   │
│   ││CPU开销大│   │    │   ││空间浪费多│   │
│   │└─────────┘   │    │   │└─────────┘   │
└─────────────────┘    └─────────────────┘

建议：根据业务特点选择合适的平衡点
```

### 8.4 空间回收策略


**主动回收空间**：
```sql
-- 创建空间回收程序
DELIMITER //
CREATE PROCEDURE reclaim_undo_space()
BEGIN
    DECLARE undo_name VARCHAR(64);
    DECLARE done INT DEFAULT FALSE;
    DECLARE undo_cursor CURSOR FOR 
        SELECT TABLESPACE_NAME 
        FROM INFORMATION_SCHEMA.FILES 
        WHERE FILE_TYPE = 'UNDO LOG' 
        AND TOTAL_EXTENTS * EXTENT_SIZE > $$innodb_max_undo_log_size;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN undo_cursor;
    
    reclaim_loop: LOOP
        FETCH undo_cursor INTO undo_name;
        IF done THEN
            LEAVE reclaim_loop;
        END IF;
        
        -- 设置为非活跃，等待截断
        SET @sql = CONCAT('ALTER UNDO TABLESPACE ', undo_name, ' SET INACTIVE');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 等待一段时间后重新激活
        DO SLEEP(60);
        
        SET @sql = CONCAT('ALTER UNDO TABLESPACE ', undo_name, ' SET ACTIVE');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    
    CLOSE undo_cursor;
END //
DELIMITER ;
```

---

## 9. 🔧 表空间故障处理


### 9.1 常见故障类型


**故障分类与症状**：

| 故障类型 | **症状表现** | **可能原因** | **影响程度** |
|----------|-------------|-------------|-------------|
| **空间耗尽** | `无法启动新事务` | `长事务、配置不当` | `严重` |
| **文件损坏** | `启动失败、错误日志` | `磁盘故障、异常关机` | `严重` |
| **性能缓慢** | `事务提交慢` | `表空间过大、I/O瓶颈` | `中等` |
| **无法截断** | `表空间持续增长` | `长时间事务阻塞` | `中等` |

### 9.2 空间耗尽处理


**紧急处理步骤**：
```sql
-- 步骤1：检查当前状况
SELECT 
    TABLESPACE_NAME,
    TOTAL_EXTENTS * EXTENT_SIZE/1024/1024 AS size_mb,
    FREE_EXTENTS * EXTENT_SIZE/1024/1024 AS free_mb,
    ROUND((FREE_EXTENTS * 100.0) / TOTAL_EXTENTS, 2) AS free_pct
FROM INFORMATION_SCHEMA.FILES 
WHERE FILE_TYPE = 'UNDO LOG';

-- 步骤2：查找占用空间的长事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) as duration_sec,
    trx_isolation_level,
    trx_mysql_thread_id
FROM INFORMATION_SCHEMA.INNODB_TRX
ORDER BY trx_started ASC;

-- 步骤3：终止异常长事务（谨慎操作）
-- KILL 异常线程ID;

-- 步骤4：临时增加表空间
CREATE UNDO TABLESPACE undo_emergency 
ADD DATAFILE '/data/mysql/undo/undo_emergency.ibu';
ALTER UNDO TABLESPACE undo_emergency SET ACTIVE;
```

### 9.3 文件损坏恢复


**损坏检测与恢复**：
```sql
-- 检查文件完整性
CHECK TABLE INFORMATION_SCHEMA.FILES;

-- 查看错误日志中的相关信息
-- tail -f /var/log/mysql/error.log | grep -i undo

-- 如果文件损坏，恢复步骤：
-- 1. 停止MySQL服务
-- 2. 从备份恢复损坏的文件
-- 3. 或者删除损坏的表空间，重新创建

-- 创建新的替代表空间
CREATE UNDO TABLESPACE undo_new 
ADD DATAFILE '/data/mysql/undo/undo_new.ibu';

-- 删除损坏的表空间（如果可能）
-- DROP UNDO TABLESPACE undo_damaged;
```

### 9.4 性能问题诊断


**性能分析工具**：
```sql
-- 分析Undo相关的性能指标
SELECT 
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT/1000000000 as total_wait_sec,
    AVG_TIMER_WAIT/1000000 as avg_wait_ms
FROM performance_schema.events_statements_summary_by_event_name
WHERE EVENT_NAME LIKE '%undo%'
ORDER BY total_wait_sec DESC;

-- 查看I/O统计
SELECT 
    FILE_NAME,
    EVENT_NAME,
    COUNT_READ,
    COUNT_WRITE,
    SUM_NUMBER_OF_BYTES_READ/1024/1024 as read_mb,
    SUM_NUMBER_OF_BYTES_WRITE/1024/1024 as write_mb
FROM performance_schema.file_summary_by_instance
WHERE FILE_NAME LIKE '%undo%'
ORDER BY read_mb + write_mb DESC;
```

**优化建议**：
```
性能优化检查清单：
□ 检查是否有长时间运行的事务
□ 验证Undo表空间是否在高速存储设备上
□ 确认innodb_purge_threads配置合理
□ 检查innodb_undo_log_truncate是否启用
□ 监控磁盘I/O使用情况
□ 考虑增加Undo表空间数量分散负载
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 Undo表空间本质：存储事务撤销信息的专用空间，支持MVCC
🔸 独立表空间优势：可截断回收、性能更好、管理更灵活
🔸 段管理机制：每个事务分配独立的Undo段，事务结束后回收
🔸 自动截断功能：当表空间超过阈值时自动清理不需要的数据
🔸 监控的重要性：及时发现问题，避免空间耗尽影响业务
```

### 10.2 关键配置参数


**必须了解的参数**：
```
核心参数清单：
• innodb_undo_tablespaces：表空间数量（建议2-4个）
• innodb_max_undo_log_size：单个表空间大小限制（建议1GB）
• innodb_undo_log_truncate：自动截断开关（必须开启）
• innodb_undo_directory：存储位置（建议独立目录）
• innodb_purge_rseg_truncate_frequency：截断频率（根据负载调整）
```

### 10.3 运维最佳实践


**日常运维要点**：
```
监控检查：
□ 每日检查表空间使用率
□ 监控长时间运行的事务
□ 关注截断操作的执行情况
□ 检查磁盘空间是否充足

性能优化：
□ 避免长时间事务
□ 合理设置截断参数
□ 使用多个表空间分散负载
□ 定期分析Undo相关性能指标

故障预防：
□ 设置合理的告警阈值
□ 备份重要的配置参数
□ 制定应急处理预案
□ 定期验证恢复流程
```

### 10.4 常见问题处理


**问题处理思路**：
```
问题诊断流程：
1. 收集症状信息（错误日志、性能指标）
2. 分析根本原因（空间、事务、配置）
3. 制定处理方案（临时缓解、根本解决）
4. 执行处理操作（谨慎操作、备份先行）
5. 验证处理结果（功能正常、性能恢复）
6. 总结预防措施（避免再次发生）
```

### 10.5 实际应用价值


**业务价值体现**：
- **可靠性保障**：通过Undo机制确保数据一致性和事务原子性
- **性能优化**：合理配置提升数据库并发处理能力
- **存储管理**：有效控制磁盘空间使用，避免无限增长
- **故障恢复**：快速定位和解决Undo相关问题
- **容量规划**：基于监控数据制定合理的容量扩展计划

> 💡 **核心记忆**  
> Undo表空间是MVCC的基础设施，通过独立管理、自动截断、合理监控，可以确保数据库在高并发环境下稳定运行。重点是理解其工作原理，掌握配置方法，建立有效的监控体系。

---

**学习建议**：
1. **理论结合实践**：在测试环境中动手配置和测试各种参数
2. **监控先行**：建立完善的监控体系，及时发现潜在问题
3. **渐进式优化**：根据实际业务负载逐步调整配置参数
4. **故障预案**：提前制定各种故障场景的处理预案