---
title: 8、MVCC版本可见性判断
---
## 📚 目录

1. [版本可见性基础概念](#1-版本可见性基础概念)
2. [事务可见性规则详解](#2-事务可见性规则详解)
3. [版本比较算法机制](#3-版本比较算法机制)
4. [可见性判断完整流程](#4-可见性判断完整流程)
5. [性能优化策略](#5-性能优化策略)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 版本可见性基础概念


### 1.1 什么是版本可见性判断


**简单理解**：版本可见性判断就像图书馆的借阅规则
```
现实场景：
某本书有多个版本（第1版、第2版、第3版）
不同读者只能看到符合条件的版本

数据库场景：
同一行数据有多个版本（事务1修改、事务2修改、事务3修改）
不同事务只能看到符合条件的版本
```

**核心定义**：
- **版本可见性**：确定当前事务能否看到某个数据版本的机制
- **判断规则**：基于事务状态、时间戳、版本链等多个维度
- **目标作用**：保证事务隔离性，实现一致性读取

### 1.2 为什么需要版本可见性判断


**解决的问题**：
```
问题场景：
事务A：读取用户余额
事务B：修改用户余额 +100
事务C：修改用户余额 -50

疑问：事务A应该看到哪个版本的余额？
```

**MVCC的解决方案**：
```
版本链示例：
原始数据：余额=1000 (版本V1，事务ID=100)
    ↓
事务B修改：余额=1100 (版本V2，事务ID=200)  
    ↓
事务C修改：余额=1050 (版本V3，事务ID=300)

版本可见性判断：
• 事务A能否看到V1？→ 检查可见性规则
• 事务A能否看到V2？→ 检查可见性规则  
• 事务A能否看到V3？→ 检查可见性规则
```

### 1.3 版本可见性的核心要素


**关键组成部分**：
```
┌─────────────────────────────────────┐
│           版本可见性判断             │
├─────────────────────────────────────┤
│  当前事务信息     │  目标版本信息    │
│  • 事务ID        │  • 创建事务ID    │
│  • 事务状态      │  • 删除事务ID    │  
│  • 开始时间      │  │版本状态       │
│  • 活跃事务列表   │  • 提交状态      │
└─────────────────────────────────────┘
           ↓
    执行可见性判断算法
           ↓
    返回：可见 / 不可见
```

---

## 2. ⚖️ 事务可见性规则详解


### 2.1 基础可见性规则


**规则一：自己创建的版本总是可见**
```sql
-- 示例场景
BEGIN; -- 事务ID = 100
UPDATE users SET balance = 1500 WHERE id = 1;
SELECT balance FROM users WHERE id = 1; -- 能看到1500
-- 原因：自己修改的数据自己当然能看到
```

**规则二：已提交且早于当前事务的版本可见**
```
时间线示例：
事务50: 修改数据 → 提交 (时间点T1)
事务100: 开始 (时间点T2) → 读取数据
```

**规则三：未提交的其他事务版本不可见**
```sql
-- 事务A（ID=100）
BEGIN;
UPDATE users SET balance = 1500 WHERE id = 1; -- 未提交

-- 事务B（ID=200）  
BEGIN;
SELECT balance FROM users WHERE id = 1; -- 看不到1500，看到原值
-- 原因：事务A还没提交，数据可能回滚
```

### 2.2 活跃事务检查机制


**什么是活跃事务**：
- **定义**：当前正在运行、尚未提交或回滚的事务
- **作用**：判断某个版本的创建者是否还在活跃状态
- **检查方式**：维护活跃事务列表进行快速查找

**活跃事务检查流程**：
```
当前事务要读取版本V：
   ↓
1. 获取版本V的创建事务ID (trx_id)
   ↓
2. 检查trx_id是否在活跃事务列表中
   ↓
3. 如果在活跃列表中 → 版本不可见
   如果不在活跃列表中 → 继续其他检查
```

**代码示例（简化逻辑）**：
```java
public boolean isVersionVisible(Version version, Transaction currentTrx) {
    long versionTrxId = version.getCreatorTrxId();
    
    // 规则1：自己创建的版本总是可见
    if (versionTrxId == currentTrx.getId()) {
        return true;
    }
    
    // 规则2：检查是否在活跃事务列表中
    if (currentTrx.getActiveTrxList().contains(versionTrxId)) {
        return false; // 创建者还活跃，版本不可见
    }
    
    // 规则3：检查版本创建时间是否早于当前事务开始时间
    return version.getCreateTime() < currentTrx.getStartTime();
}
```

### 2.3 提交状态判断


**提交状态的重要性**：
```
场景说明：
事务A创建了版本V，然后...
• 如果事务A提交 → 版本V可能可见（还要看其他条件）
• 如果事务A回滚 → 版本V绝对不可见
• 如果事务A还在运行 → 版本V不可见（除非是自己）
```

**提交状态检查机制**：
```java
public CommitStatus getTransactionStatus(long trxId) {
    // 1. 先检查内存中的活跃事务
    if (activeTrxMap.containsKey(trxId)) {
        return CommitStatus.ACTIVE; // 还在运行
    }
    
    // 2. 检查提交记录
    if (commitLog.isCommitted(trxId)) {
        return CommitStatus.COMMITTED; // 已提交
    }
    
    // 3. 检查回滚记录
    if (rollbackLog.isRolledBack(trxId)) {
        return CommitStatus.ROLLED_BACK; // 已回滚
    }
    
    return CommitStatus.UNKNOWN; // 状态不明
}
```

---

## 3. 🔄 版本比较算法机制


### 3.1 版本链遍历算法


**版本链的结构**：
```
最新版本 (事务300) → 版本2 (事务200) → 版本1 (事务100) → NULL
    ↑                    ↑                  ↑
  可能不可见             需要判断           可能可见
```

**遍历算法流程**：
```
开始读取数据行
    ↓
1. 从最新版本开始检查
    ↓
2. 对当前版本执行可见性判断
    ↓
3. 如果可见 → 返回该版本数据
   如果不可见 → 继续检查下一个版本
    ↓
4. 重复步骤2-3，直到找到可见版本或到达链表末尾
    ↓
5. 如果没找到可见版本 → 返回NULL（数据不存在）
```

**算法实现**：
```java
public RowVersion findVisibleVersion(RowVersionChain chain, Transaction currentTrx) {
    RowVersion current = chain.getLatestVersion();
    
    while (current != null) {
        // 检查当前版本是否可见
        if (isVersionVisible(current, currentTrx)) {
            // 还要检查是否被删除
            if (!isVersionDeleted(current, currentTrx)) {
                return current; // 找到可见且未删除的版本
            }
        }
        
        // 移动到前一个版本
        current = current.getPreviousVersion();
    }
    
    return null; // 没找到可见版本
}
```

### 3.2 删除版本的特殊处理


**删除操作的版本处理**：
```
删除操作不是真正删除数据，而是：
1. 保留原版本数据
2. 标记删除事务ID和删除时间
3. 在可见性判断时考虑删除标记
```

**删除版本可见性判断**：
```java
public boolean isVersionDeleted(RowVersion version, Transaction currentTrx) {
    long deleteTrxId = version.getDeleteTrxId();
    
    // 没有删除标记
    if (deleteTrxId == 0) {
        return false;
    }
    
    // 自己删除的，对自己来说是删除了的
    if (deleteTrxId == currentTrx.getId()) {
        return true;
    }
    
    // 删除事务还在活跃，删除操作未确定
    if (currentTrx.getActiveTrxList().contains(deleteTrxId)) {
        return false; // 删除未确定，当作未删除
    }
    
    // 删除事务已提交，且删除时间早于当前事务开始时间
    return isTransactionCommitted(deleteTrxId) && 
           version.getDeleteTime() < currentTrx.getStartTime();
}
```

### 3.3 版本时间戳比较


**时间戳的作用**：
```
版本时间戳比较解决的问题：
确定版本的创建/删除时间是否在当前事务的可见范围内
```

**时间戳比较规则**：
```
当前事务开始时间：T_start
版本创建时间：T_create  
版本删除时间：T_delete

可见性时间条件：
• T_create < T_start：版本在事务开始前就存在
• T_delete > T_start 或 T_delete = NULL：版本在事务开始后才删除（或未删除）
```

---

## 4. 🎯 可见性判断完整流程


### 4.1 完整判断算法


**算法整体架构**：
```
可见性判断完整流程：

输入：目标版本V，当前事务T
   ↓
步骤1：基础检查
• 自己创建的版本？→ 直接可见
• 版本状态是否有效？
   ↓
步骤2：创建者状态检查  
• 创建事务是否还活跃？→ 不可见
• 创建事务是否已提交？→ 继续检查
• 创建事务是否已回滚？→ 不可见
   ↓
步骤3：时间范围检查
• 版本创建时间是否早于事务开始时间？
   ↓
步骤4：删除状态检查
• 版本是否被删除？
• 删除事务状态如何？
   ↓
输出：可见 / 不可见
```

**完整算法实现**：
```java
public class VisibilityChecker {
    
    public boolean isVersionVisible(RowVersion version, Transaction currentTrx) {
        // 步骤1：基础检查
        if (!isVersionValid(version)) {
            return false;
        }
        
        // 步骤2：检查版本创建的可见性
        if (!isCreateVisible(version, currentTrx)) {
            return false;
        }
        
        // 步骤3：检查版本删除的可见性
        if (isDeleteVisible(version, currentTrx)) {
            return false; // 已删除，不可见
        }
        
        return true;
    }
    
    private boolean isCreateVisible(RowVersion version, Transaction currentTrx) {
        long createTrxId = version.getCreateTrxId();
        
        // 自己创建的总是可见
        if (createTrxId == currentTrx.getId()) {
            return true;
        }
        
        // 创建事务还在活跃
        if (currentTrx.getActiveTrxList().contains(createTrxId)) {
            return false;
        }
        
        // 创建事务必须已提交
        if (!isTransactionCommitted(createTrxId)) {
            return false;
        }
        
        // 创建时间必须早于当前事务开始时间
        return version.getCreateTime() < currentTrx.getStartTime();
    }
    
    private boolean isDeleteVisible(RowVersion version, Transaction currentTrx) {
        long deleteTrxId = version.getDeleteTrxId();
        
        // 没有删除标记
        if (deleteTrxId == 0) {
            return false;
        }
        
        // 自己删除的，对自己可见（已删除）
        if (deleteTrxId == currentTrx.getId()) {
            return true;
        }
        
        // 删除事务还在活跃，删除未确定
        if (currentTrx.getActiveTrxList().contains(deleteTrxId)) {
            return false;
        }
        
        // 删除事务已提交且删除时间早于当前事务开始时间
        return isTransactionCommitted(deleteTrxId) && 
               version.getDeleteTime() < currentTrx.getStartTime();
    }
}
```

### 4.2 可见性判断的执行时机


**何时执行可见性判断**：
```
触发时机：
1. SELECT查询读取数据时
2. UPDATE查询检查当前值时  
3. DELETE查询确认删除目标时
4. 索引扫描过程中
5. 约束检查时
```

**执行流程图**：
```
SQL查询开始
    ↓
定位到数据行
    ↓
获取版本链
    ↓
┌─→ 取当前版本
│      ↓
│   执行可见性判断
│      ↓
│   可见？
│   ├─ 是 → 返回该版本数据
│   └─ 否 → 移动到下一版本
│      ↓
└───有下一版本？
    ├─ 是 → 循环继续
    └─ 否 → 返回空结果
```

### 4.3 判断结果的处理


**可见性判断结果类型**：
```java
public enum VisibilityResult {
    VISIBLE,        // 可见：返回数据给应用
    INVISIBLE,      // 不可见：跳过该版本
    DELETED,        // 已删除：继续查找其他版本
    VERSION_ERROR   // 版本错误：抛出异常
}
```

**结果处理逻辑**：
```java
public Object readRowData(long rowId, Transaction currentTrx) {
    RowVersionChain chain = getVersionChain(rowId);
    RowVersion current = chain.getLatestVersion();
    
    while (current != null) {
        VisibilityResult result = checkVisibility(current, currentTrx);
        
        switch (result) {
            case VISIBLE:
                return current.getData(); // 找到可见版本
                
            case INVISIBLE:
            case DELETED:
                current = current.getPreviousVersion(); // 继续查找
                break;
                
            case VERSION_ERROR:
                throw new DatabaseException("Version chain corrupted");
        }
    }
    
    return null; // 没有可见版本
}
```

---

## 5. ⚡ 性能优化策略


### 5.1 快速路径优化


**优化思路**：
- **问题**：每次都完整执行可见性判断，性能开销大
- **解决**：针对常见场景提供快速判断路径

**快速路径场景**：
```java
public boolean quickVisibilityCheck(RowVersion version, Transaction currentTrx) {
    long createTrxId = version.getCreateTrxId();
    
    // 快速路径1：自己创建的版本
    if (createTrxId == currentTrx.getId()) {
        return !version.isDeleted(); // 只需检查是否被自己删除
    }
    
    // 快速路径2：版本太新（创建事务ID大于当前事务ID）
    if (createTrxId > currentTrx.getId()) {
        return false; // 肯定不可见
    }
    
    // 快速路径3：版本很老且已提交
    if (createTrxId < currentTrx.getOldestActiveTrxId() && 
        isDefinitelyCommitted(createTrxId)) {
        return !isDefinitelyDeleted(version, currentTrx);
    }
    
    // 其他情况走完整判断流程
    return fullVisibilityCheck(version, currentTrx);
}
```

### 5.2 活跃事务列表优化


**优化目标**：减少活跃事务检查的时间复杂度

**数据结构优化**：
```java
public class OptimizedActiveTrxList {
    private Set<Long> activeTrxSet;        // 快速查找：O(1)
    private long minActiveTrxId;           // 最小活跃事务ID
    private long maxActiveTrxId;           // 最大活跃事务ID
    
    public boolean contains(long trxId) {
        // 优化1：范围预检查
        if (trxId < minActiveTrxId || trxId > maxActiveTrxId) {
            return false; // 不在活跃范围内
        }
        
        // 优化2：使用HashSet快速查找
        return activeTrxSet.contains(trxId);
    }
    
    public void updateRange() {
        if (!activeTrxSet.isEmpty()) {
            minActiveTrxId = Collections.min(activeTrxSet);
            maxActiveTrxId = Collections.max(activeTrxSet);
        }
    }
}
```

### 5.3 版本链遍历优化


**优化策略**：
```
问题：版本链可能很长，逐个检查效率低
解决方案：
1. 版本链剪枝：定期清理不需要的旧版本
2. 跳跃式查找：利用时间戳快速跳过明显不可见的版本
3. 缓存机制：缓存最近的可见性判断结果
```

**跳跃式查找实现**：
```java
public RowVersion findVisibleVersionOptimized(RowVersionChain chain, Transaction currentTrx) {
    RowVersion current = chain.getLatestVersion();
    long trxStartTime = currentTrx.getStartTime();
    
    while (current != null) {
        // 优化：如果版本创建时间远晚于事务开始时间，快速跳过
        if (current.getCreateTime() > trxStartTime + TIME_THRESHOLD) {
            current = skipToTimeRange(current, trxStartTime);
            continue;
        }
        
        // 正常可见性检查
        if (isVersionVisible(current, currentTrx)) {
            return current;
        }
        
        current = current.getPreviousVersion();
    }
    
    return null;
}
```

### 5.4 缓存优化机制


**可见性判断缓存**：
```java
public class VisibilityCache {
    private Map<String, Boolean> cache;  // key: "trxId_versionId", value: 可见性
    private long cacheSize = 10000;      // 缓存大小限制
    
    public Boolean getCachedResult(long trxId, long versionId) {
        String key = trxId + "_" + versionId;
        return cache.get(key);
    }
    
    public void cacheResult(long trxId, long versionId, boolean visible) {
        if (cache.size() >= cacheSize) {
            evictOldEntries(); // 清理旧缓存
        }
        
        String key = trxId + "_" + versionId;
        cache.put(key, visible);
    }
}
```

### 5.5 判断准确性保证


**准确性保证机制**：
```
1. 双重检查：关键判断进行二次验证
2. 一致性检查：定期验证版本链的一致性
3. 异常处理：发现不一致时的恢复机制
4. 日志记录：记录异常的可见性判断案例
```

**一致性检查示例**：
```java
public void validateVersionChain(RowVersionChain chain) {
    RowVersion current = chain.getLatestVersion();
    
    while (current != null) {
        RowVersion next = current.getPreviousVersion();
        
        if (next != null) {
            // 检查版本时间序列
            assert current.getCreateTime() >= next.getCreateTime() 
                : "Version chain time order violated";
            
            // 检查事务ID序列
            assert current.getCreateTrxId() >= next.getCreateTrxId() 
                : "Version chain transaction ID order violated";
        }
        
        current = next;
    }
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 版本可见性：确定事务能否看到某个数据版本的机制
🔸 基础规则：自己创建可见、已提交早期版本可见、活跃事务版本不可见
🔸 判断要素：事务状态、时间戳、活跃事务列表、提交状态
🔸 完整流程：基础检查→创建者检查→时间检查→删除检查
🔸 性能优化：快速路径、数据结构优化、缓存机制
```

### 6.2 关键理解要点


**🔹 版本可见性的本质**
```
核心思想：
• 每个事务都有自己的"视角"看数据
• 视角由事务开始时间和活跃事务列表决定
• 保证读取的数据在事务开始时是一致的状态
```

**🔹 判断算法的设计考量**
```
设计原则：
• 准确性：绝不能返回错误的可见性结果
• 性能：针对常见场景进行优化
• 一致性：保证判断结果的逻辑一致
• 可维护性：算法逻辑清晰，便于调试
```

**🔹 性能与准确性的平衡**
```
平衡策略：
• 快速路径处理常见情况
• 完整检查保证准确性
• 缓存机制提升重复查询性能
• 预检查避免不必要的计算
```

### 6.3 实际应用价值


**📊 数据库内核开发**：
- 理解MVCC实现的核心算法
- 掌握事务隔离级别的底层机制
- 优化数据库查询性能

**🔧 系统设计能力**：
- 学习版本控制的设计思想
- 理解并发控制的实现方法
- 掌握缓存优化的实践经验

**🎯 问题诊断技能**：
- 理解事务异常行为的根本原因
- 分析数据一致性问题
- 优化慢查询和锁等待问题

### 6.4 学习要点提醒


**⚠️ 易混淆概念**：
```
版本可见 ≠ 数据存在
• 版本不可见：数据存在但当前事务看不到
• 数据不存在：所有版本都不可见或已被删除

事务提交 ≠ 版本可见  
• 事务提交只是可见的必要条件
• 还需要满足时间戳等其他条件
```

**🔍 调试技巧**：
```
问题诊断方法：
1. 检查事务开始时间和活跃事务列表
2. 追踪版本链的构建过程
3. 验证可见性判断的每个步骤
4. 对比预期结果和实际结果
```

**核心记忆要点**：
- 版本可见性决定事务看到的数据版本
- 判断基于事务状态、时间戳、活跃列表
- 算法分层设计：快速路径+完整检查
- 性能优化不能牺牲准确性
- 理解原理是优化和调试的基础