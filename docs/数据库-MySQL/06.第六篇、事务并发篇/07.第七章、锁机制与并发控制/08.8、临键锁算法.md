---
title: 8、临键锁算法
---
## 📚 目录

1. [临键锁基础概念](#1-临键锁基础概念)
2. [Next-Key Lock算法机制](#2-next-key-lock算法机制)
3. [间隙锁与记录锁组合](#3-间隙锁与记录锁组合)
4. [左开右闭区间规则](#4-左开右闭区间规则)
5. [范围扫描加锁策略](#5-范围扫描加锁策略)
6. [临键锁退化与优化](#6-临键锁退化与优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 临键锁基础概念


### 1.1 什么是临键锁


**简单理解**：临键锁就像给一排停车位加锁
```
停车场场景：
车位编号：1  2  3  4  5  6  7  8  9  10
已停车：  A     C     E        H

临键锁机制：
• 锁住车位E本身（记录锁）
• 锁住车位4-5之间的空隙（间隙锁）
• 防止新车插入到E的附近位置
```

**技术定义**：
- **临键锁（Next-Key Lock）**：记录锁 + 间隙锁的组合
- **作用目标**：防止幻读现象的发生
- **锁定范围**：一个记录及其前面的间隙

### 1.2 为什么需要临键锁


**解决的核心问题**：幻读现象
```sql
-- 事务A：查询年龄在20-30之间的用户
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- 结果：张三(25岁)、李四(28岁)

-- 事务B：插入新用户
INSERT INTO users VALUES (100, '王五', 26);

-- 事务A：再次查询相同条件
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- 结果：张三(25岁)、李四(28岁)、王五(26岁) ← 出现幻读
```

**临键锁的解决方案**：
```
不仅锁住已存在的记录，还锁住可能插入新记录的间隙
这样就能阻止其他事务在范围内插入新数据
```

### 1.3 临键锁的基本组成


**双重锁定机制**：
```
临键锁 = 记录锁 + 间隙锁

记录锁部分：
• 锁定具体的索引记录
• 防止其他事务修改或删除该记录

间隙锁部分：
• 锁定索引记录之间的间隙
• 防止其他事务在间隙中插入新记录
```

---

## 2. ⚡ Next-Key Lock算法机制


### 2.1 算法基本原理


**核心算法逻辑**：当事务需要锁定某个范围时，对范围内每个索引项执行临键锁
```
索引结构示例：
索引值：10, 20, 30, 40, 50

临键锁区间：
(-∞, 10], (10, 20], (20, 30], (30, 40], (40, 50], (50, +∞)
```

**算法执行步骤**：
```java
public class NextKeyLockAlgorithm {
    public void lockRange(int startValue, int endValue) {
        // 1. 定位起始索引位置
        IndexRecord start = findFirstRecord(startValue);
        
        // 2. 定位结束索引位置  
        IndexRecord end = findLastRecord(endValue);
        
        // 3. 对范围内每个记录加临键锁
        IndexRecord current = start;
        while (current != null && current.getValue() <= endValue) {
            applyNextKeyLock(current);
            current = current.getNext();
        }
    }
    
    private void applyNextKeyLock(IndexRecord record) {
        // 加记录锁
        lockRecord(record);
        // 加间隙锁（锁定记录前的间隙）
        lockGap(record.getPrevious(), record);
    }
}
```

### 2.2 算法触发条件


**什么时候使用Next-Key Lock**：
```
触发场景：
1. 可重复读隔离级别下的范围查询
2. 使用唯一索引进行范围扫描
3. 外键约束检查
4. 某些UPDATE/DELETE的WHERE条件
```

**具体SQL示例**：
```sql
-- 场景1：范围查询
SELECT * FROM users WHERE age BETWEEN 25 AND 35;

-- 场景2：不等式查询
SELECT * FROM users WHERE age > 20;

-- 场景3：模糊查询
SELECT * FROM users WHERE name LIKE 'A%';

-- 场景4：IN查询（多个值）
SELECT * FROM users WHERE age IN (25, 30, 35);
```

### 2.3 算法的索引依赖性


**不同索引类型的处理**：
```
主键索引：
• 总是使用临键锁
• 锁定精度最高

唯一索引：
• 等值查询可能退化为记录锁
• 范围查询使用临键锁

普通索引：
• 总是使用临键锁
• 可能需要锁定更多记录
```

---

## 3. 🔗 间隙锁与记录锁组合


### 3.1 记录锁的作用机制


**记录锁基础**：锁定索引中的具体记录，防止其他事务修改
```sql
-- 示例数据
id | name | age
1  | 张三  | 25
2  | 李四  | 30  
3  | 王五  | 35

-- 当执行：SELECT * FROM users WHERE age = 30 FOR UPDATE
-- 记录锁：锁定age=30的索引记录（李四这条记录）
```

**记录锁实现**：
```java
public class RecordLock {
    private Long recordId;
    private LockMode mode; // SHARED 或 EXCLUSIVE
    
    public boolean tryLock(Transaction trx, Long recordId, LockMode mode) {
        if (isLocked(recordId) && !isCompatible(mode)) {
            return false; // 锁冲突
        }
        
        addLock(trx, recordId, mode);
        return true;
    }
}
```

### 3.2 间隙锁的作用机制


**间隙锁基础**：锁定索引记录之间的空隙，防止插入新记录
```
索引记录：10, 20, 30, 40
间隙分布：(-∞,10), (10,20), (20,30), (30,40), (40,+∞)

当锁定记录30时：
• 记录锁：锁定值30本身
• 间隙锁：锁定间隙(20,30)
```

**间隙锁实现逻辑**：
```java
public class GapLock {
    public void lockGap(IndexRecord prev, IndexRecord next) {
        GapRange gap = new GapRange(
            prev != null ? prev.getValue() : MIN_VALUE,
            next != null ? next.getValue() : MAX_VALUE
        );
        
        // 检查是否有插入操作试图进入此间隙
        preventInsertInRange(gap);
    }
    
    private void preventInsertInRange(GapRange gap) {
        // 阻止在此范围内的INSERT操作
        for (Transaction trx : activeTransactions) {
            if (trx.hasInsertInRange(gap)) {
                trx.waitForGapLock(gap);
            }
        }
    }
}
```

### 3.3 组合锁的协同工作


**双重保护机制**：
```
临键锁 = 记录锁 + 间隙锁

保护效果：
• 记录锁：防止现有数据被修改/删除
• 间隙锁：防止新数据被插入
• 结合效果：范围内数据完全稳定
```

**组合锁的冲突检测**：
```java
public class NextKeyLock {
    private RecordLock recordLock;
    private GapLock gapLock;
    
    public boolean isConflictWith(NextKeyLock other) {
        // 检查记录锁冲突
        if (recordLock.conflictsWith(other.recordLock)) {
            return true;
        }
        
        // 检查间隙锁冲突  
        if (gapLock.conflictsWith(other.gapLock)) {
            return true;
        }
        
        return false;
    }
}
```

---

## 4. 📐 左开右闭区间规则


### 4.1 区间表示法


**左开右闭的含义**：临键锁使用(前一个值, 当前值]的区间表示
```
索引记录：10, 20, 30, 40

临键锁区间：
记录10的临键锁：(-∞, 10]
记录20的临键锁：(10, 20]  
记录30的临键锁：(20, 30]
记录40的临键锁：(30, 40]
```

**为什么采用左开右闭**：
```
设计考虑：
1. 避免重复锁定：相邻记录的间隙不会重叠
2. 边界清晰：每个间隙有明确的归属
3. 实现简单：算法逻辑更直观
```

### 4.2 区间计算算法


**区间边界确定**：
```java
public class IntervalCalculator {
    public LockInterval calculateNextKeyInterval(IndexRecord current) {
        IndexRecord previous = current.getPrevious();
        
        // 确定左边界（开区间）
        Object leftBound = (previous != null) ? 
            previous.getValue() : MIN_VALUE;
            
        // 确定右边界（闭区间）  
        Object rightBound = current.getValue();
        
        return new LockInterval(leftBound, rightBound, false, true);
    }
}
```

### 4.3 区间重叠处理


**相邻区间的处理**：
```
记录序列：10, 20, 30

区间分配：
• 记录10：(-∞, 10]
• 记录20：(10, 20]
• 记录30：(20, 30]

关键点：
• 值10属于第一个区间的右边界
• 值10不属于第二个区间（左开）
• 避免了边界值的重复锁定
```

**插入冲突检测**：
```java
public boolean wouldConflictWithInsert(Object newValue, LockInterval interval) {
    // 检查新值是否落在锁定区间内
    if (interval.isLeftOpen() && newValue.equals(interval.getLeftBound())) {
        return false; // 左开区间，边界值不冲突
    }
    
    if (interval.isRightClosed() && newValue.equals(interval.getRightBound())) {
        return true; // 右闭区间，边界值冲突
    }
    
    return interval.contains(newValue);
}
```

---

## 5. 🔍 范围扫描加锁策略


### 5.1 范围查询的加锁过程


**扫描加锁的基本流程**：
```
执行：SELECT * FROM users WHERE age BETWEEN 25 AND 35;

加锁步骤：
1. 定位到第一个满足条件的记录（age=25）
2. 对该记录加临键锁：(prev_age, 25]
3. 继续扫描下一个记录（age=30）
4. 对该记录加临键锁：(25, 30]
5. 继续直到超出范围（age=40）
6. 对下一个记录也加临键锁：(35, 40]
```

**扫描算法实现**：
```java
public class RangeScanLocking {
    public void lockRange(Object startValue, Object endValue) {
        IndexCursor cursor = index.seek(startValue);
        
        while (cursor.hasNext()) {
            IndexRecord record = cursor.next();
            
            // 对每个记录加临键锁
            applyNextKeyLock(record);
            
            // 检查是否超出范围
            if (record.getValue().compareTo(endValue) > 0) {
                break;
            }
        }
        
        // 注意：还需要锁定超出范围的第一个记录
        if (cursor.hasNext()) {
            applyNextKeyLock(cursor.next());
        }
    }
}
```

### 5.2 不同查询类型的加锁策略


**等值查询**：
```sql
SELECT * FROM users WHERE age = 30;

加锁策略：
• 找到age=30的记录
• 加临键锁：(prev_age, 30]
• 如果是唯一索引，可能退化为记录锁
```

**范围查询**：
```sql  
SELECT * FROM users WHERE age BETWEEN 25 AND 35;

加锁策略：
• 扫描25-35范围内的所有记录
• 每个记录都加临键锁
• 额外锁定超出范围的第一个记录
```

**开放范围查询**：
```sql
SELECT * FROM users WHERE age > 25;

加锁策略：
• 从age>25开始扫描到表尾
• 锁定所有扫描到的记录
• 锁定到正无穷的间隙
```

### 5.3 索引结构对加锁的影响


**聚簇索引（主键）**：
```
特点：数据和索引存储在一起
加锁效果：直接锁定数据行
性能：锁定精度高，冲突少
```

**二级索引**：
```
特点：索引和数据分开存储
加锁过程：
1. 先在二级索引上加锁
2. 再在聚簇索引上加锁
3. 可能产生更多锁冲突
```

**加锁差异示例**：
```java
public class IndexLockingStrategy {
    public void lockWithClusteredIndex(Object value) {
        // 聚簇索引：直接锁定数据
        ClusteredIndexRecord record = clusteredIndex.find(value);
        applyNextKeyLock(record);
    }
    
    public void lockWithSecondaryIndex(Object value) {
        // 二级索引：需要两步锁定
        SecondaryIndexRecord secRecord = secondaryIndex.find(value);
        applyNextKeyLock(secRecord); // 锁定二级索引
        
        // 回表锁定聚簇索引
        Object primaryKey = secRecord.getPrimaryKey();
        ClusteredIndexRecord primRecord = clusteredIndex.find(primaryKey);
        lockRecord(primRecord); // 只需记录锁
    }
}
```

---

## 6. 🔄 临键锁退化与优化


### 6.1 临键锁退化条件


**什么时候临键锁会退化**：
```
退化场景：
1. 唯一索引等值查询命中记录
2. 唯一索引等值查询未命中记录  
3. 某些特定的查询优化
```

**退化示例**：
```sql
-- 场景1：唯一索引等值查询命中
SELECT * FROM users WHERE id = 100; -- id是主键
-- 退化为：记录锁（不需要间隙锁）

-- 场景2：唯一索引等值查询未命中
SELECT * FROM users WHERE id = 999; -- 记录不存在
-- 退化为：间隙锁（不需要记录锁）
```

**退化判断逻辑**：
```java
public LockType determineLockType(IndexRecord record, QueryType query) {
    if (query.isEquality() && index.isUnique()) {
        if (record.exists()) {
            return LockType.RECORD_LOCK; // 退化为记录锁
        } else {
            return LockType.GAP_LOCK; // 退化为间隙锁
        }
    }
    
    return LockType.NEXT_KEY_LOCK; // 使用完整临键锁
}
```

### 6.2 性能优化策略


**减少锁定范围**：
```java
public class OptimizedLocking {
    public void optimizedRangeLock(Object start, Object end) {
        // 优化1：精确定位起始位置
        IndexRecord startRecord = index.seekExact(start);
        if (startRecord == null) {
            startRecord = index.seekNext(start);
        }
        
        // 优化2：提前终止扫描
        IndexRecord current = startRecord;
        while (current != null && current.getValue().compareTo(end) <= 0) {
            // 优化3：检查是否可以退化
            LockType lockType = determineLockType(current, query);
            applyLock(current, lockType);
            
            current = current.getNext();
        }
    }
}
```

**锁升级机制**：
```
锁升级策略：
• 当锁定记录数量过多时
• 将多个临键锁升级为表锁
• 减少锁管理开销
• 但可能增加锁冲突
```

### 6.3 异常处理机制


**死锁检测**：
```java
public class DeadlockDetector {
    public void checkDeadlock(Transaction trx, NextKeyLock requestedLock) {
        // 构建等待图
        WaitGraph graph = buildWaitGraph();
        
        // 检测环路
        if (graph.hasCycle()) {
            // 选择代价最小的事务进行回滚
            Transaction victim = selectVictim(graph.getCycle());
            rollbackTransaction(victim);
        }
    }
}
```

**锁超时处理**：
```java
public class LockTimeoutHandler {
    public boolean waitForLock(NextKeyLock lock, long timeoutMs) {
        long startTime = System.currentTimeMillis();
        
        while (!lock.tryAcquire()) {
            if (System.currentTimeMillis() - startTime > timeoutMs) {
                throw new LockTimeoutException("Lock wait timeout");
            }
            
            Thread.sleep(10); // 短暂等待
        }
        
        return true;
    }
}
```

**锁一致性检查**：
```java
public void validateLockConsistency() {
    // 检查锁的区间是否有重叠
    List<NextKeyLock> locks = getAllActiveLocks();
    
    for (int i = 0; i < locks.size() - 1; i++) {
        NextKeyLock current = locks.get(i);
        NextKeyLock next = locks.get(i + 1);
        
        if (current.getInterval().overlaps(next.getInterval())) {
            throw new LockConsistencyException("Lock intervals overlap");
        }
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 临键锁本质：记录锁+间隙锁的组合，防止幻读
🔸 算法机制：对范围内每个索引记录加临键锁
🔸 区间规则：左开右闭区间(prev, current]
🔸 扫描策略：范围查询时逐个记录加锁
🔸 退化条件：唯一索引等值查询可能退化
🔸 性能优化：精确定位、提前终止、锁升级
```

### 7.2 关键理解要点


**🔹 临键锁的设计思想**：
```
核心理念：
• 既要保护现有数据（记录锁）
• 又要保护数据间隙（间隙锁）  
• 实现范围查询的完全稳定性
• 是解决幻读问题的根本方案
```

**🔹 左开右闭区间的优势**：
```
设计优点：
• 避免相邻区间重叠
• 边界归属明确
• 算法实现简洁
• 冲突检测高效
```

**🔹 索引类型的影响**：
```
影响因素：
• 唯一索引可能触发退化
• 聚簇索引锁定精度更高
• 二级索引需要双重锁定
• 索引结构影响性能
```

### 7.3 实际应用价值


**数据库应用开发**：
- 理解事务隔离级别的实现机制
- 优化范围查询的锁定策略  
- 设计高并发应用的数据访问模式

**性能调优技能**：
- 分析锁等待和死锁问题
- 优化索引设计减少锁冲突
- 调整查询方式避免过度锁定

**系统架构设计**：
- 理解并发控制的底层原理
- 设计分布式锁的实现方案
- 评估不同隔离级别的性能影响

### 7.4 学习要点提醒


**⚠️ 常见误区**：
```
误区1：认为临键锁只锁记录
正确：临键锁=记录锁+间隙锁

误区2：认为所有查询都用临键锁  
正确：唯一索引等值查询可能退化

误区3：忽视索引类型的影响
正确：不同索引类型加锁策略不同
```

**🔍 实践建议**：
```
优化策略：
1. 优先使用主键和唯一索引查询
2. 避免不必要的范围查询
3. 合理设计索引减少锁冲突
4. 监控锁等待和死锁情况
```

**核心记忆口诀**：
- 临键锁定双保险，记录间隙都不漏
- 左开右闭区间明，范围扫描逐个锁  
- 唯一等值可退化，索引类型影响大
- 性能优化有策略，异常处理要完善