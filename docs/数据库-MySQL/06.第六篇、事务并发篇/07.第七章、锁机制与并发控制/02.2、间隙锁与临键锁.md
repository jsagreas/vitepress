---
title: 2、间隙锁与临键锁
---
## 📚 目录

1. [锁机制基础概念](#1-锁机制基础概念)
2. [间隙锁Gap Lock详解](#2-间隙锁gap-lock详解)
3. [临键锁Next-Key Lock机制](#3-临键锁next-key-lock机制)
4. [幻读防护实现原理](#4-幻读防护实现原理)
5. [锁定范围与加锁规则](#5-锁定范围与加锁规则)
6. [实际应用场景分析](#6-实际应用场景分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 锁机制基础概念


### 1.1 什么是数据库锁


**简单理解**：锁就像现实生活中的门锁，确保同一时间只有合适的人能访问资源。

在数据库中，锁是**并发控制机制**，用来解决多个事务同时操作数据时可能出现的问题：
- **脏读**：读到未提交的数据
- **不可重复读**：同一事务中多次读取结果不同
- **幻读**：同一事务中查询结果集发生变化

### 1.2 MySQL中的锁分类


```
锁的层次结构：
┌─────────────────────────────────────┐
│            表级锁                    │
├─────────────────────────────────────┤
│            页级锁                    │
├─────────────────────────────────────┤
│   行级锁（InnoDB引擎的核心）          │
│   ├── 记录锁（Record Lock）          │
│   ├── 间隙锁（Gap Lock）             │
│   └── 临键锁（Next-Key Lock）        │
└─────────────────────────────────────┘
```

**行级锁的三种类型**：
- **记录锁（Record Lock）**：锁定具体的一行记录
- **间隙锁（Gap Lock）**：锁定记录之间的间隙
- **临键锁（Next-Key Lock）**：记录锁 + 间隙锁的组合

> 💡 **为什么需要间隙锁和临键锁？**
> 单纯的记录锁只能防止对已存在记录的修改，但无法防止在记录之间插入新数据，这就会导致幻读问题。

### 1.3 隔离级别与锁的关系


```
隔离级别对应的锁机制：

READ UNCOMMITTED：几乎不使用锁
READ COMMITTED：只使用记录锁
REPEATABLE READ：使用临键锁（间隙锁+记录锁）
SERIALIZABLE：使用表级锁
```

**重点理解**：
- **REPEATABLE READ**是MySQL的默认隔离级别
- 在这个级别下，InnoDB主要使用**临键锁**来防止幻读

---

## 2. 🔧 间隙锁Gap Lock详解


### 2.1 间隙锁的基本概念


**通俗解释**：间隙锁就像在数据记录之间设置"禁止通行"的标志，防止其他事务在这个范围内插入新数据。

**核心特点**：
- **锁定范围**：锁定的是记录之间的空隙，不是记录本身
- **防止插入**：主要目的是阻止其他事务在间隙中插入数据
- **共享特性**：多个事务可以在同一个间隙上持有间隙锁

### 2.2 间隙锁的工作原理


假设有一个用户表，按ID排序的数据如下：
```
现有记录：
┌────┬─────────┬──────┐
│ ID │  Name   │ Age  │
├────┼─────────┼──────┤
│ 1  │ Alice   │ 25   │
│ 5  │ Bob     │ 30   │
│ 10 │ Charlie │ 35   │
│ 15 │ David   │ 40   │
└────┴─────────┴──────┘

间隙分布：
(-∞, 1) | [1] | (1, 5) | [5] | (5, 10) | [10] | (10, 15) | [15] | (15, +∞)
        间隙1    记录   间隙2   记录   间隙3    记录    间隙4     记录    间隙5
```

**间隙锁示例**：
```sql
-- 事务A执行范围查询
SELECT * FROM users WHERE id > 5 AND id < 10 FOR UPDATE;

-- 这会对间隙(5, 10)加间隙锁
-- 此时其他事务无法插入id在5到10之间的记录
```

### 2.3 间隙锁的触发条件


**什么时候会产生间隙锁**：

1. **范围查询**且查询条件使用索引
```sql
-- 会产生间隙锁
SELECT * FROM users WHERE id > 5 FOR UPDATE;
SELECT * FROM users WHERE id BETWEEN 3 AND 8 FOR UPDATE;
```

2. **查询不存在的记录**
```sql
-- 查询id=7的记录（不存在），会在(5,10)间隙加锁
SELECT * FROM users WHERE id = 7 FOR UPDATE;
```

3. **使用唯一索引查询不存在的值**
```sql
-- 即使是唯一索引，查询不存在的值也会加间隙锁
SELECT * FROM users WHERE unique_code = 'NOT_EXISTS' FOR UPDATE;
```

### 2.4 间隙锁的影响范围


**间隙锁定范围计算**：

```sql
-- 示例表数据
CREATE TABLE test_gap (
    id INT PRIMARY KEY,
    value VARCHAR(10)
);

INSERT INTO test_gap VALUES (1, 'a'), (5, 'b'), (10, 'c'), (15, 'd');

-- 场景1：查询范围包含存在的记录
SELECT * FROM test_gap WHERE id > 3 AND id < 12 FOR UPDATE;
```

**锁定分析**：
```
查询条件：id > 3 AND id < 12
涉及记录：5, 10
锁定间隙：
- (3, 5)：间隙锁
- (5, 10)：间隙锁  
- (10, 12)：间隙锁
锁定记录：
- id=5：记录锁
- id=10：记录锁
```

> ⚠️ **注意**：间隙锁只在REPEATABLE READ隔离级别下生效，READ COMMITTED级别不使用间隙锁。

---

## 3. 🔗 临键锁Next-Key Lock机制


### 3.1 临键锁的基本概念


**通俗理解**：临键锁就是把记录锁和间隙锁"打包"在一起，既锁住记录本身，也锁住记录前面的间隙。

**组合机制**：
```
临键锁 = 记录锁 + 间隙锁

具体表现：
┌─────────────────────────────────┐
│     临键锁(Next-Key Lock)       │
├─────────────────┬───────────────┤
│   间隙锁部分     │   记录锁部分   │
│ (前一记录, 当前) │   [当前记录]   │
└─────────────────┴───────────────┘
```

### 3.2 临键锁的算法原理


**Next-Key Locking算法**：

1. **基本单位**：临键锁是InnoDB默认的行锁算法
2. **锁定范围**：一个临键锁锁定一个区间和区间右边的记录
3. **区间表示**：使用左开右闭区间`(previous_record, current_record]`

**实际例子**：
```sql
-- 表中现有记录：1, 5, 10, 15
-- 执行查询
SELECT * FROM users WHERE id = 5 FOR UPDATE;
```

**临键锁分析**：
```
针对id=5的临键锁：
锁定区间：(1, 5]
包含内容：
- 间隙锁：(1, 5) - 防止在1和5之间插入数据
- 记录锁：[5] - 锁定id=5这条记录

实际效果：
✅ 可以插入id=0.5的记录（在锁定范围外）
❌ 不能插入id=3的记录（在间隙(1,5)内）
❌ 不能修改id=5的记录（被记录锁锁定）
✅ 可以插入id=7的记录（在锁定范围外）
```

### 3.3 临键锁的优化规则


**MySQL的优化策略**：

1. **索引等值查询，存在记录，退化为记录锁**
```sql
-- id=5的记录存在且id是主键
SELECT * FROM users WHERE id = 5 FOR UPDATE;
-- 实际只加记录锁，不加间隙锁
```

2. **索引等值查询，不存在记录，退化为间隙锁**
```sql
-- id=7的记录不存在
SELECT * FROM users WHERE id = 7 FOR UPDATE;
-- 只在(5,10)间隙加间隙锁
```

3. **范围查询，使用临键锁**
```sql
-- 范围查询使用完整的临键锁
SELECT * FROM users WHERE id > 5 FOR UPDATE;
```

### 3.4 临键锁组合规则详解


**具体的加锁规则**：

```sql
-- 示例数据：id = 1, 5, 10, 15, 20

-- 场景1：等值查询存在的记录
SELECT * FROM test WHERE id = 10 FOR UPDATE;
-- 结果：只对id=10加记录锁

-- 场景2：等值查询不存在的记录  
SELECT * FROM test WHERE id = 7 FOR UPDATE;
-- 结果：对间隙(5,10)加间隙锁

-- 场景3：范围查询
SELECT * FROM test WHERE id >= 10 FOR UPDATE;
-- 结果：
-- - 对(5,10]加临键锁
-- - 对(10,15]加临键锁  
-- - 对(15,20]加临键锁
-- - 对(20,+∞)加间隙锁
```

---

## 4. 👻 幻读防护实现原理


### 4.1 什么是幻读


**生活化理解**：就像你在房间里数人数，第一次数是5个人，过一会儿再数变成了6个人，但你明明没看到有人进来。

**技术定义**：在同一个事务中，前后两次查询的结果集不同，出现了"幻影"记录。

**幻读示例**：
```sql
-- 事务A
START TRANSACTION;
SELECT COUNT(*) FROM users WHERE age > 25;  -- 结果：3条记录

-- 此时事务B插入了一条age=30的记录并提交

SELECT COUNT(*) FROM users WHERE age > 25;  -- 结果：4条记录 (出现幻读)
COMMIT;
```

### 4.2 间隙锁如何防止幻读


**防护机制**：通过锁定间隙，阻止其他事务插入可能影响查询结果的数据。

**实际过程**：
```sql
-- 事务A在REPEATABLE READ级别下执行
START TRANSACTION;
SELECT * FROM users WHERE age > 25 FOR UPDATE;
```

**加锁分析**：
```
假设age字段有索引，现有记录age为：20, 30, 40

查询条件：age > 25
InnoDB会加以下锁：
1. 对age=30的记录：临键锁(20, 30]
2. 对age=40的记录：临键锁(30, 40] 
3. 对age=40之后：间隙锁(40, +∞)

锁定效果：
❌ 无法插入age=35的记录（被临键锁阻止）
❌ 无法插入age=50的记录（被间隙锁阻止）
✅ 可以插入age=15的记录（不在锁定范围）
```

### 4.3 临键锁的幻读防护策略


**完整防护方案**：

1. **锁定查询范围内的所有间隙**
2. **锁定查询范围内的所有记录**
3. **锁定查询范围边界的扩展间隙**

**示例分析**：
```sql
-- 查询范围：WHERE id BETWEEN 5 AND 15
-- 表中记录：1, 3, 7, 12, 18, 25

SELECT * FROM test WHERE id BETWEEN 5 AND 15 FOR UPDATE;
```

**详细加锁过程**：
```
Step 1：确定影响范围
- 查询条件：5 <= id <= 15
- 涉及记录：7, 12
- 边界扩展：需要考虑5和15的位置

Step 2：加锁决策
- (3, 7]：临键锁（覆盖id=7及其前面间隙）
- (7, 12]：临键锁（覆盖id=12及其前面间隙）
- (12, 18)：间隙锁（防止在12-18间插入数据）

Step 3：防护效果
✅ 防止插入id=6（在间隙(3,7)中）
✅ 防止插入id=10（在间隙(7,12)中）  
✅ 防止插入id=14（在间隙(12,18)中）
❌ 允许插入id=2（不在锁定范围）
❌ 允许插入id=20（不在锁定范围）
```

---

## 5. 📏 锁定范围与加锁规则


### 5.1 索引类型对加锁的影响


**不同索引的加锁行为**：

**主键索引（聚簇索引）**：
```sql
-- 主键等值查询
SELECT * FROM users WHERE id = 10 FOR UPDATE;
-- 加锁：只对id=10这条记录加记录锁（优化后）
```

**唯一索引**：
```sql
-- 唯一索引等值查询存在的记录
SELECT * FROM users WHERE email = 'john@example.com' FOR UPDATE;
-- 加锁：对唯一索引记录加记录锁，对聚簇索引记录加记录锁
```

**普通索引（二级索引）**：
```sql
-- 普通索引等值查询
SELECT * FROM users WHERE name = 'John' FOR UPDATE;
-- 加锁：
-- 1. 对二级索引记录加临键锁
-- 2. 对对应的聚簇索引记录加记录锁
```

### 5.2 范围查询的加锁规则


**范围查询加锁分析**：

```sql
-- 示例表结构和数据
CREATE TABLE lock_test (
    id INT PRIMARY KEY,
    score INT,
    name VARCHAR(20),
    INDEX idx_score (score)
);

INSERT INTO lock_test VALUES 
(1, 85, 'Alice'), (5, 90, 'Bob'), (10, 95, 'Charlie'), (15, 88, 'David');
```

**不同范围查询的加锁行为**：

```sql
-- 场景1：使用主键范围查询
SELECT * FROM lock_test WHERE id > 5 AND id < 15 FOR UPDATE;
```

**加锁分析**：
```
查询范围：id ∈ (5, 15)
影响记录：id=10
加锁结果：
- (5, 10]：临键锁
- (10, 15)：间隙锁

具体效果：
❌ 插入id=8会被阻止（临键锁范围）
❌ 插入id=12会被阻止（间隙锁范围）
✅ 插入id=3可以成功（范围外）
✅ 插入id=16可以成功（范围外）
```

```sql
-- 场景2：使用二级索引范围查询
SELECT * FROM lock_test WHERE score > 85 AND score < 95 FOR UPDATE;
```

**加锁分析**：
```
查询条件：score ∈ (85, 95)
影响记录：score=90 (id=5), score=88 (id=15)

二级索引加锁：
- (85, 88]：临键锁（覆盖score=88）
- (88, 90]：临键锁（覆盖score=90）  
- (90, 95)：间隙锁

聚簇索引加锁：
- id=5：记录锁
- id=15：记录锁
```

### 5.3 特殊情况的加锁规则


**等值查询不存在记录**：
```sql
-- 查询不存在的主键
SELECT * FROM lock_test WHERE id = 7 FOR UPDATE;

-- 加锁分析：
-- id=7不存在，位于(5, 10)间隙中
-- 结果：对(5, 10)加间隙锁
```

**使用LIMIT的影响**：
```sql
-- 带LIMIT的查询
SELECT * FROM lock_test WHERE score > 85 ORDER BY score LIMIT 2 FOR UPDATE;

-- 加锁优化：
-- InnoDB会在找到足够记录后停止加锁
-- 减少不必要的锁范围
```

### 5.4 插入操作的影响


**INSERT操作的加锁**：

```sql
-- 插入新记录
INSERT INTO lock_test VALUES (8, 92, 'Eve');
```

**插入加锁过程**：
```
Step 1：检查插入位置
- 新记录id=8，位于现有记录id=5和id=10之间

Step 2：检查间隙锁冲突
- 如果其他事务已对(5,10)加间隙锁，插入会被阻塞

Step 3：成功插入后的加锁
- 对新插入记录加记录锁
- 防止其他事务立即修改

Step 4：后续影响
- 改变了间隙分布：(5,8), (8,10)
- 影响后续查询的加锁范围
```

---

## 6. 🔍 实际应用场景分析


### 6.1 电商库存扣减场景


**业务需求**：多个用户同时购买商品，需要准确扣减库存，防止超卖。

**问题分析**：
```sql
-- 传统错误做法
SELECT stock FROM products WHERE id = 1001;  -- 查询库存：10
-- 应用层判断库存足够后
UPDATE products SET stock = stock - 1 WHERE id = 1001;  -- 扣减库存
```

**存在的问题**：
- 并发情况下可能出现超卖
- 多个事务同时读取到相同库存值

**正确的解决方案**：
```sql
-- 使用行锁防止并发问题
START TRANSACTION;
SELECT stock FROM products WHERE id = 1001 FOR UPDATE;  -- 加行锁
-- 应用层检查库存
UPDATE products SET stock = stock - 1 WHERE id = 1001;
COMMIT;
```

**加锁分析**：
```
FOR UPDATE的作用：
1. 对id=1001的记录加记录锁
2. 阻止其他事务同时读取和修改
3. 确保库存扣减的原子性

实际效果：
- 事务A获得锁，开始处理
- 事务B、C等待事务A完成
- 避免了超卖情况
```

### 6.2 用户积分排行榜场景


**业务需求**：查询积分排行榜，同时防止其他用户的积分变动影响结果一致性。

```sql
-- 查询前10名用户
SELECT * FROM users 
WHERE score > 0 
ORDER BY score DESC 
LIMIT 10 
FOR UPDATE;
```

**间隙锁作用分析**：
```
假设当前前10名的积分范围：[850, 990]

查询执行后的加锁：
1. 对查询到的10条记录：记录锁
2. 对积分间隙：间隙锁覆盖相关范围
3. 防止插入影响排名的新记录

防护效果：
❌ 阻止插入score=900的新用户（可能影响排名）
❌ 阻止现有用户积分变为900（可能影响排名）
✅ 确保查询结果在事务期间保持一致
```

### 6.3 订单号生成场景


**业务需求**：生成连续的订单号，防止并发时出现重复或间断。

**错误的实现**：
```sql
-- 可能导致订单号重复
SELECT MAX(order_no) FROM orders;  -- 获取最大订单号
-- 应用层计算新订单号
INSERT INTO orders (order_no, ...) VALUES (new_order_no, ...);
```

**正确的实现**：
```sql
-- 方案1：使用间隙锁
START TRANSACTION;
SELECT MAX(order_no) FROM orders FOR UPDATE;  -- 锁定最大值查询
-- 应用层生成新订单号
INSERT INTO orders (order_no, ...) VALUES (new_order_no, ...);
COMMIT;

-- 方案2：使用AUTO_INCREMENT（推荐）
CREATE TABLE orders (
    order_no BIGINT AUTO_INCREMENT PRIMARY KEY,
    ...
);
```

### 6.4 分布式锁实现场景


**使用数据库实现分布式锁**：

```sql
-- 创建锁表
CREATE TABLE distributed_locks (
    lock_name VARCHAR(64) PRIMARY KEY,
    holder VARCHAR(64),
    expire_time TIMESTAMP
);

-- 获取锁
INSERT INTO distributed_locks (lock_name, holder, expire_time) 
VALUES ('resource_lock', 'server1', NOW() + INTERVAL 30 SECOND)
ON DUPLICATE KEY UPDATE lock_name = lock_name;  -- 获取失败时的处理

-- 释放锁
DELETE FROM distributed_locks WHERE lock_name = 'resource_lock' AND holder = 'server1';
```

**间隙锁的作用**：
```
当多个服务器尝试获取同一个锁时：
1. 主键冲突检测依赖唯一索引
2. 间隙锁防止并发插入相同lock_name
3. 确保同一时间只有一个holder获得锁
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 间隙锁：锁定记录之间的间隙，防止插入操作
🔸 临键锁：记录锁+间隙锁的组合，InnoDB的默认锁算法
🔸 幻读防护：通过锁定间隙阻止影响查询结果的插入操作
🔸 加锁范围：根据索引类型和查询条件确定锁定范围
🔸 优化规则：等值查询存在记录时可能退化为记录锁
```

### 7.2 关键理解要点


**🔹 为什么需要间隙锁**
```
根本问题：防止幻读
解决思路：不仅锁定已存在的记录，还要锁定可能插入的位置
实现方式：锁定记录之间的间隙，阻止插入操作
适用范围：REPEATABLE READ隔离级别
```

**🔹 临键锁的优化策略**
```
基本原则：尽量减少锁的范围，提高并发性能
优化1：等值查询存在记录 → 退化为记录锁
优化2：等值查询不存在记录 → 退化为间隙锁  
优化3：范围查询 → 使用完整临键锁
原因：平衡数据一致性和系统性能
```

**🔹 锁冲突的判断原则**
```
记录锁冲突：不同事务不能同时持有同一记录的排他锁
间隙锁兼容：多个事务可以在同一间隙持有间隙锁
插入冲突：插入操作与间隙锁冲突，需要等待
临键锁冲突：既包含记录锁冲突，也包含间隙锁冲突
```

### 7.3 实践应用指导


**🎯 什么时候会用到间隙锁**
```
适用场景：
✅ 需要防止幻读的范围查询
✅ 需要保证数据一致性的业务逻辑
✅ 实现分布式锁等高级功能
✅ 防止并发插入影响业务逻辑

不适用场景：
❌ 简单的单记录操作
❌ 对性能要求极高的场景
❌ 可以容忍幻读的业务
```

**🎯 如何优化锁性能**
```
优化策略：
1. 使用合适的索引：减少锁定范围
2. 缩小事务范围：减少锁持有时间
3. 选择合适的隔离级别：根据业务需求调整
4. 避免长时间事务：防止锁等待超时
5. 合理设计查询条件：减少不必要的锁冲突
```

**🎯 锁问题的诊断方法**
```
监控工具：
- SHOW ENGINE INNODB STATUS：查看锁状态
- information_schema.INNODB_LOCKS：查看当前锁信息
- information_schema.INNODB_LOCK_WAITS：查看锁等待情况
- performance_schema：详细的锁监控数据

常见问题：
- 死锁：两个事务相互等待对方释放锁
- 锁等待超时：事务等待锁时间过长
- 性能下降：过多的锁冲突导致并发下降
```

### 7.4 最佳实践建议


**📝 代码实践**
```sql
-- 推荐：明确的事务边界
START TRANSACTION;
SELECT ... FOR UPDATE;  -- 明确需要加锁的查询
-- 业务逻辑处理
UPDATE/INSERT/DELETE;
COMMIT;

-- 避免：隐式事务和长事务
SET AUTOCOMMIT = 0;  -- 避免忘记提交
-- 长时间的业务处理
COMMIT;  -- 很久之后才提交
```

**🔧 配置优化**
```sql
-- 查看当前锁等待超时设置
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';

-- 根据业务需求调整
SET SESSION innodb_lock_wait_timeout = 10;  -- 10秒超时

-- 死锁检测设置
SHOW VARIABLES LIKE 'innodb_deadlock_detect';
```

**核心记忆口诀**：
> 间隙锁定防插入，临键组合最完整  
> 幻读防护靠锁隙，范围查询加临键  
> 等值存在退记录，不存在时锁间隙  
> 索引类型影响锁，优化规则要牢记