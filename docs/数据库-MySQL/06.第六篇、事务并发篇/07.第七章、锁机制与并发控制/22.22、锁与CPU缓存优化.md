---
title: 22ã€é”ä¸CPUç¼“å­˜ä¼˜åŒ–
---
## ğŸ“š ç›®å½•

1. [é”ä¸CPUç¼“å­˜åŸºç¡€](#1-é”ä¸cpuç¼“å­˜åŸºç¡€)
2. [é”æ•°æ®ç»“æ„ç¼“å­˜å‹å¥½æ€§](#2-é”æ•°æ®ç»“æ„ç¼“å­˜å‹å¥½æ€§)
3. [ç¼“å­˜è¡Œå¯¹é½ä¼˜åŒ–](#3-ç¼“å­˜è¡Œå¯¹é½ä¼˜åŒ–)
4. [ä¼ªå…±äº«é—®é¢˜é¿å…](#4-ä¼ªå…±äº«é—®é¢˜é¿å…)
5. [NUMAæ¶æ„é”ä¼˜åŒ–](#5-numaæ¶æ„é”ä¼˜åŒ–)
6. [CPUäº²å’Œæ€§è®¾ç½®](#6-cpuäº²å’Œæ€§è®¾ç½®)
7. [ç¼“å­˜ä¼˜åŒ–å®Œæ•´ç­–ç•¥](#7-ç¼“å­˜ä¼˜åŒ–å®Œæ•´ç­–ç•¥)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ§  é”ä¸CPUç¼“å­˜åŸºç¡€


### 1.1 CPUç¼“å­˜å±‚æ¬¡ç»“æ„


CPUç¼“å­˜æ˜¯ä½äºå¤„ç†å™¨å’Œå†…å­˜ä¹‹é—´çš„é«˜é€Ÿå­˜å‚¨ï¼Œç”¨äºç¼“è§£CPUä¸å†…å­˜é€Ÿåº¦å·®å¼‚ã€‚ç†è§£ç¼“å­˜ç»“æ„æ˜¯ä¼˜åŒ–é”æ€§èƒ½çš„åŸºç¡€ã€‚

```
CPUç¼“å­˜å±‚æ¬¡ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CPU   â”‚  â† 1 cycle
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L1 Cacheâ”‚  â† 1-3 cyclesï¼Œ32KB-64KBï¼Œæ¯æ ¸ç‹¬æœ‰
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L2 Cacheâ”‚  â† 10-20 cyclesï¼Œ256KB-1MBï¼Œæ¯æ ¸ç‹¬æœ‰  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L3 Cacheâ”‚  â† 20-40 cyclesï¼Œ8MB-32MBï¼Œå¤šæ ¸å…±äº«
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Memory â”‚  â† 100-300 cyclesï¼ŒGBçº§ï¼Œæ‰€æœ‰CPUå…±äº«
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’¡ ç¼“å­˜è¡Œæ¦‚å¿µ**

ç¼“å­˜è¡Œæ˜¯CPUç¼“å­˜çš„åŸºæœ¬å•ä½ï¼Œé€šå¸¸ä¸º64å­—èŠ‚ã€‚CPUä¸ä¼šåªåŠ è½½å•ä¸ªå˜é‡ï¼Œè€Œæ˜¯æ•´ä¸ªç¼“å­˜è¡Œã€‚

```java
// ç¼“å­˜è¡Œç¤ºä¾‹ï¼ˆ64å­—èŠ‚ï¼‰
public class CacheLineExample {
    // è¿™äº›å˜é‡å¯èƒ½åœ¨åŒä¸€ä¸ªç¼“å­˜è¡Œä¸­
    private long value1;    // 8å­—èŠ‚
    private long value2;    // 8å­—èŠ‚  
    private long value3;    // 8å­—èŠ‚
    private long value4;    // 8å­—èŠ‚
    private long value5;    // 8å­—èŠ‚
    private long value6;    // 8å­—èŠ‚
    private long value7;    // 8å­—èŠ‚
    private long value8;    // 8å­—èŠ‚ï¼Œæ€»å…±64å­—èŠ‚
}
```

### 1.2 é”æ“ä½œçš„ç¼“å­˜å½±å“


é”æ“ä½œä¼šå¯¹CPUç¼“å­˜äº§ç”Ÿæ˜¾è‘—å½±å“ï¼Œç†è§£è¿™äº›å½±å“å¯¹ä¼˜åŒ–é”æ€§èƒ½è‡³å…³é‡è¦ã€‚

```
é”æ“ä½œå¯¹ç¼“å­˜çš„å½±å“ï¼š
è·å–é”ï¼šéœ€è¦ç‹¬å è®¿é—®é”å˜é‡ â†’ å¯¼è‡´å…¶ä»–CPUç¼“å­˜å¤±æ•ˆ
é‡Šæ”¾é”ï¼šä¿®æ”¹é”çŠ¶æ€ â†’ é€šçŸ¥å…¶ä»–CPUæ›´æ–°ç¼“å­˜
ç«äº‰é”ï¼šå¤šä¸ªCPUåŒæ—¶è®¿é—® â†’ é¢‘ç¹çš„ç¼“å­˜ä¸€è‡´æ€§åè®®

æ€§èƒ½å¼€é”€ï¼š
ç¼“å­˜æœªå‘½ä¸­ï¼šè®¿é—®é€Ÿåº¦ä¸‹é™100-300å€
ç¼“å­˜ä¸€è‡´æ€§ï¼šé¢å¤–çš„æ€»çº¿é€šä¿¡å¼€é”€
ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼šç ´åCPUç¼“å­˜å±€éƒ¨æ€§
```

### 1.3 ç¼“å­˜ä¸€è‡´æ€§åè®®


å¤šæ ¸ç³»ç»Ÿä¸­ï¼ŒCPUç¼“å­˜ä¸€è‡´æ€§åè®®ç¡®ä¿æ•°æ®çš„æ­£ç¡®æ€§ï¼Œä½†ä¹Ÿå¸¦æ¥æ€§èƒ½å¼€é”€ã€‚

```
MESIåè®®çŠ¶æ€ï¼š
M (Modified)ï¼šç¼“å­˜è¡Œè¢«ä¿®æ”¹ï¼Œä¸å†…å­˜ä¸ä¸€è‡´
E (Exclusive)ï¼šç¼“å­˜è¡Œç‹¬å ä¸”ä¸å†…å­˜ä¸€è‡´  
S (Shared)ï¼šç¼“å­˜è¡Œåœ¨å¤šä¸ªCPUä¸­å…±äº«
I (Invalid)ï¼šç¼“å­˜è¡Œæ— æ•ˆ

çŠ¶æ€è½¬æ¢å¼€é”€ï¼š
S â†’ Mï¼šéœ€è¦é€šçŸ¥å…¶ä»–CPUå¤±æ•ˆè¯¥ç¼“å­˜è¡Œ
M â†’ Sï¼šéœ€è¦å†™å›å†…å­˜å¹¶å…±äº«ç»™å…¶ä»–CPU
```

---

## 2. ğŸ—ï¸ é”æ•°æ®ç»“æ„ç¼“å­˜å‹å¥½æ€§


### 2.1 ç´§å‡‘çš„é”æ•°æ®ç»“æ„


è®¾è®¡ç´§å‡‘çš„é”æ•°æ®ç»“æ„ï¼Œå‡å°‘å†…å­˜å ç”¨ï¼Œæé«˜ç¼“å­˜åˆ©ç”¨ç‡ã€‚

```java
// ç¼“å­˜å‹å¥½çš„é”è®¾è®¡
public class CacheFriendlyLock {
    // å°†ç›¸å…³å­—æ®µç´§å¯†æ’åˆ—
    private volatile int state;        // é”çŠ¶æ€ï¼Œ4å­—èŠ‚
    private volatile int waiters;      // ç­‰å¾…è€…æ•°é‡ï¼Œ4å­—èŠ‚
    private volatile Thread owner;     // é”æŒæœ‰è€…ï¼Œ8å­—èŠ‚ï¼ˆå¼•ç”¨ï¼‰
    // æ€»å…±16å­—èŠ‚ï¼Œèƒ½å¾ˆå¥½åœ°åˆ©ç”¨ç¼“å­˜è¡Œ
    
    public boolean tryLock() {
        return compareAndSwapState(0, 1);
    }
    
    public void unlock() {
        owner = null;
        state = 0;  // volatileå†™ï¼Œç¡®ä¿å¯è§æ€§
    }
}
```

**ğŸ”§ å­—æ®µæ’åˆ—ä¼˜åŒ–**

```java
// ä¼˜åŒ–å‰ï¼šæµªè´¹ç¼“å­˜ç©ºé—´
public class BadLockDesign {
    private volatile boolean locked;    // 1å­—èŠ‚ + 7å­—èŠ‚padding
    private long timestamp;            // 8å­—èŠ‚
    private volatile boolean fair;      // 1å­—èŠ‚ + 7å­—èŠ‚padding  
    private int waiters;               // 4å­—èŠ‚ + 4å­—èŠ‚padding
    // æ€»å…±32å­—èŠ‚ï¼Œä½†å®é™…ä½¿ç”¨åªæœ‰14å­—èŠ‚
}

// ä¼˜åŒ–åï¼šç´§å‡‘å¸ƒå±€
public class GoodLockDesign {
    private volatile int state;        // åŒ…å«lockedå’Œfairæ ‡å¿—
    private volatile int waiters;      // ç­‰å¾…è€…æ•°é‡
    private volatile long timestamp;   // æ—¶é—´æˆ³
    // æ€»å…±16å­—èŠ‚ï¼Œå……åˆ†åˆ©ç”¨ç¼“å­˜è¡Œ
}
```

### 2.2 ä½çº§çŠ¶æ€å‹ç¼©


å°†å¤šä¸ªå¸ƒå°”çŠ¶æ€å‹ç¼©åˆ°å•ä¸ªæ•´æ•°ä¸­ï¼Œå‡å°‘å†…å­˜å ç”¨ã€‚

```java
public class CompactLock {
    private volatile int state;
    
    // çŠ¶æ€ä½å®šä¹‰
    private static final int LOCKED_BIT = 1 << 0;     // æ˜¯å¦å·²é”å®š
    private static final int FAIR_BIT = 1 << 1;       // æ˜¯å¦å…¬å¹³é”
    private static final int REENTRANT_BIT = 1 << 2;  // æ˜¯å¦å¯é‡å…¥
    private static final int COUNT_SHIFT = 16;        // é‡å…¥æ¬¡æ•°åç§»
    
    public boolean isLocked() {
        return (state & LOCKED_BIT) != 0;
    }
    
    public boolean tryLock() {
        int currentState = state;
        if ((currentState & LOCKED_BIT) != 0) {
            return false;  // å·²è¢«é”å®š
        }
        
        int newState = currentState | LOCKED_BIT;
        return compareAndSwapState(currentState, newState);
    }
    
    public int getReentrantCount() {
        return state >>> COUNT_SHIFT;
    }
}
```

### 2.3 é¿å…ä¸å¿…è¦çš„å­—æ®µè®¿é—®


å‡å°‘é”æ“ä½œä¸­çš„å†…å­˜è®¿é—®æ¬¡æ•°ï¼Œç‰¹åˆ«æ˜¯volatileå­—æ®µçš„è®¿é—®ã€‚

```java
public class OptimizedLock {
    private volatile int state;
    
    public boolean tryLockOptimized() {
        // ä¼˜åŒ–ï¼šå…ˆè¿›è¡Œæœ¬åœ°æ£€æŸ¥ï¼Œé¿å…ä¸å¿…è¦çš„CAS
        int currentState = state;
        if (currentState != 0) {
            return false;  // å¿«é€Ÿå¤±è´¥ï¼Œé¿å…CASå¼€é”€
        }
        
        // åªæœ‰åœ¨å¯èƒ½æˆåŠŸæ—¶æ‰æ‰§è¡ŒCAS
        return compareAndSwapState(0, 1);
    }
    
    // é¿å…é¢‘ç¹è¯»å–volatileå­—æ®µ
    public void waitForUnlock() {
        int localState;
        while ((localState = state) != 0) {
            // ä½¿ç”¨æœ¬åœ°å˜é‡å‡å°‘volatileè¯»å–
            Thread.yield();
        }
    }
}
```

---

## 3. ğŸ“ ç¼“å­˜è¡Œå¯¹é½ä¼˜åŒ–


### 3.1 ç¼“å­˜è¡Œå¯¹é½åŸç†


å°†é‡è¦çš„æ•°æ®ç»“æ„å¯¹é½åˆ°ç¼“å­˜è¡Œè¾¹ç•Œï¼Œç¡®ä¿æ•°æ®å®Œæ•´åœ°å­˜å‚¨åœ¨å•ä¸ªç¼“å­˜è¡Œä¸­ã€‚

```
å¯¹é½å‰ï¼š
ç¼“å­˜è¡Œ1: [å…¶ä»–æ•°æ®...][é”çŠ¶æ€çš„ä¸€éƒ¨åˆ†]
ç¼“å­˜è¡Œ2: [é”çŠ¶æ€çš„å…¶ä½™éƒ¨åˆ†][å…¶ä»–æ•°æ®...]
é—®é¢˜ï¼šè®¿é—®é”çŠ¶æ€éœ€è¦åŠ è½½ä¸¤ä¸ªç¼“å­˜è¡Œ

å¯¹é½åï¼š  
ç¼“å­˜è¡Œ1: [å…¶ä»–æ•°æ®........................]
ç¼“å­˜è¡Œ2: [å®Œæ•´çš„é”çŠ¶æ€][padding...........]
ä¼˜åŠ¿ï¼šè®¿é—®é”çŠ¶æ€åªéœ€è¦ä¸€ä¸ªç¼“å­˜è¡Œ
```

**ğŸ”§ Javaä¸­çš„ç¼“å­˜è¡Œå¯¹é½**

```java
// ä½¿ç”¨å¡«å……å®ç°ç¼“å­˜è¡Œå¯¹é½
public class CacheLineAlignedLock {
    // å‰å¡«å……ï¼šç¡®ä¿æ ¸å¿ƒæ•°æ®ä¸ä¸å…¶ä»–å¯¹è±¡å…±äº«ç¼“å­˜è¡Œ
    private long padding1, padding2, padding3, padding4;
    private long padding5, padding6, padding7;
    
    // æ ¸å¿ƒé”æ•°æ®
    private volatile int lockState;
    private volatile Thread owner;
    
    // åå¡«å……ï¼šç¡®ä¿æ ¸å¿ƒæ•°æ®ç‹¬å ç¼“å­˜è¡Œ
    private long padding8, padding9, padding10, padding11;
    private long padding12, padding13, padding14;
    
    public boolean tryLock() {
        return compareAndSwapState(0, 1);
    }
}
```

**âš¡ @Contendedæ³¨è§£ä¼˜åŒ–**

```java
// Java 8+ä¸­çš„@Contendedæ³¨è§£
import sun.misc.Contended;

@Contended
public class ContendedLock {
    @Contended("lockGroup")
    private volatile int state;
    
    @Contended("lockGroup")  
    private volatile Thread owner;
    
    // JVMè‡ªåŠ¨æ·»åŠ å¡«å……ï¼Œé¿å…ä¼ªå…±äº«
}
```

### 3.2 åŠ¨æ€å¯¹é½æ£€æµ‹


åœ¨è¿è¡Œæ—¶æ£€æµ‹ç¼“å­˜è¡Œå¤§å°å¹¶åŠ¨æ€è°ƒæ•´å¯¹é½ç­–ç•¥ã€‚

```java
public class DynamicAlignedLock {
    private static final int CACHE_LINE_SIZE = getCacheLineSize();
    
    // åŠ¨æ€è®¡ç®—æ‰€éœ€çš„å¡«å……å¤§å°
    private static int getCacheLineSize() {
        // å°è¯•æ£€æµ‹ç¼“å­˜è¡Œå¤§å°ï¼Œé»˜è®¤64å­—èŠ‚
        return Integer.getInteger("cache.line.size", 64);
    }
    
    // åˆ›å»ºå¯¹é½çš„é”å®ä¾‹
    public static DynamicAlignedLock createAligned() {
        // åˆ†é…é¢å¤–ç©ºé—´ç”¨äºå¯¹é½
        long address = allocateAlignedMemory(CACHE_LINE_SIZE * 2);
        long alignedAddress = (address + CACHE_LINE_SIZE - 1) & 
                              ~(CACHE_LINE_SIZE - 1);
        return new DynamicAlignedLock(alignedAddress);
    }
}
```

---

## 4. ğŸš« ä¼ªå…±äº«é—®é¢˜é¿å…


### 4.1 ä¼ªå…±äº«ç°è±¡åˆ†æ


ä¼ªå…±äº«å‘ç”Ÿåœ¨å¤šä¸ªçº¿ç¨‹è®¿é—®åŒä¸€ç¼“å­˜è¡Œä¸­çš„ä¸åŒå˜é‡æ—¶ï¼Œå¯¼è‡´ä¸å¿…è¦çš„ç¼“å­˜ä¸€è‡´æ€§å¼€é”€ã€‚

```
ä¼ªå…±äº«ç¤ºä¾‹ï¼š
ç¼“å­˜è¡Œ: [counter1][counter2][flag1][flag2][å…¶ä»–æ•°æ®...]
çº¿ç¨‹1ä¿®æ”¹counter1 â†’ æ•´ä¸ªç¼“å­˜è¡Œå¤±æ•ˆ
çº¿ç¨‹2ä¿®æ”¹counter2 â†’ éœ€è¦é‡æ–°åŠ è½½ç¼“å­˜è¡Œ
ç»“æœï¼šä¸¤ä¸ªæ— å…³å˜é‡ç›¸äº’å½±å“æ€§èƒ½
```

**ğŸ“Š ä¼ªå…±äº«æ€§èƒ½å½±å“**

```java
// äº§ç”Ÿä¼ªå…±äº«çš„ä»£ç 
public class FalseSharingExample {
    private volatile long counter1;  // çº¿ç¨‹1è®¿é—®
    private volatile long counter2;  // çº¿ç¨‹2è®¿é—®
    // å¯èƒ½åœ¨åŒä¸€ç¼“å­˜è¡Œä¸­
    
    // æµ‹è¯•æ–¹æ³•
    public void testFalseSharing() {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000000; i++) {
                counter1++;  // ä¿®æ”¹counter1
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000000; i++) {
                counter2++;  // ä¿®æ”¹counter2ï¼Œå¯èƒ½å¯¼è‡´ä¼ªå…±äº«
            }
        });
        
        // æ€§èƒ½å¯èƒ½æ¯”é¢„æœŸæ…¢å¾ˆå¤š
        t1.start(); t2.start();
    }
}
```

### 4.2 ä¼ªå…±äº«é¿å…ç­–ç•¥


```java
// ç­–ç•¥1ï¼šå¡«å……åˆ†ç¦»
public class PaddingSeparated {
    private volatile long counter1;
    private long padding1, padding2, padding3, padding4;
    private long padding5, padding6, padding7, padding8;  // 64å­—èŠ‚å¡«å……
    private volatile long counter2;
    // counter1å’Œcounter2ç°åœ¨åœ¨ä¸åŒç¼“å­˜è¡Œä¸­
}

// ç­–ç•¥2ï¼šæ•°ç»„åˆ†ç¦»
public class ArraySeparated {
    private static final int CACHE_LINE_SIZE = 64;
    private static final int LONGS_PER_CACHE_LINE = CACHE_LINE_SIZE / 8;
    
    private final long[] counters = new long[LONGS_PER_CACHE_LINE * 2];
    
    public void incrementCounter1() {
        counters[0]++;  // ç¬¬ä¸€ä¸ªç¼“å­˜è¡Œ
    }
    
    public void incrementCounter2() {
        counters[LONGS_PER_CACHE_LINE]++;  // ç¬¬äºŒä¸ªç¼“å­˜è¡Œ
    }
}
```

### 4.3 é”å¯¹è±¡çš„ä¼ªå…±äº«ä¼˜åŒ–


```java
public class FalseSharingFreeLock {
    // å°†é”çŠ¶æ€ä¸å…¶ä»–å­—æ®µåˆ†ç¦»
    @Contended("lockState")
    private volatile int state;
    
    @Contended("statistics") 
    private volatile long acquisitionCount;
    
    @Contended("statistics")
    private volatile long contentionCount;
    
    public boolean tryLock() {
        if (compareAndSwapState(0, 1)) {
            acquisitionCount++;  // ç‹¬ç«‹ç¼“å­˜è¡Œï¼Œä¸å½±å“é”çŠ¶æ€
            return true;
        }
        contentionCount++;  // ç‹¬ç«‹ç¼“å­˜è¡Œï¼Œä¸å½±å“é”çŠ¶æ€
        return false;
    }
}
```

**ğŸ” ä¼ªå…±äº«æ£€æµ‹å·¥å…·**

```java
public class FalseSharingDetector {
    public static void measurePerformance() {
        // æµ‹è¯•æœ‰ä¼ªå…±äº«çš„æƒ…å†µ
        long startTime = System.nanoTime();
        runWithFalseSharing();
        long falseSharingTime = System.nanoTime() - startTime;
        
        // æµ‹è¯•é¿å…ä¼ªå…±äº«çš„æƒ…å†µ
        startTime = System.nanoTime();
        runWithoutFalseSharing();
        long optimizedTime = System.nanoTime() - startTime;
        
        System.out.println("False sharing overhead: " + 
            (falseSharingTime - optimizedTime) / 1_000_000 + "ms");
    }
}
```

---

## 5. ğŸ¢ NUMAæ¶æ„é”ä¼˜åŒ–


### 5.1 NUMAæ¶æ„ç†è§£


NUMAï¼ˆNon-Uniform Memory Accessï¼‰æ¶æ„ä¸­ï¼ŒCPUè®¿é—®æœ¬åœ°å†…å­˜çš„é€Ÿåº¦æ¯”è¿œç¨‹å†…å­˜å¿«å¾—å¤šã€‚

```
NUMAæ¶æ„ç¤ºæ„ï¼š
Node 0          Node 1
â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”
â”‚CPU0 â”‚        â”‚CPU1 â”‚
â”‚CPU1 â”‚        â”‚CPU2 â”‚
â””â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”˜
   â”‚              â”‚
â”Œâ”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”
â”‚Mem0 â”‚â†â”€â”€â”€â”€â”€â†’â”‚Mem1 â”‚
â””â”€â”€â”€â”€â”€â”˜  æ…¢    â””â”€â”€â”€â”€â”€â”˜
   â†‘     è¿æ¥      â†‘
   â””â”€å¿«è¿æ¥â”€â”˜    â””â”€å¿«è¿æ¥â”€â”˜

è®¿é—®é€Ÿåº¦ï¼š
æœ¬åœ°å†…å­˜ï¼š100ns
è¿œç¨‹å†…å­˜ï¼š300nsï¼ˆ3å€æ…¢ï¼‰
```

### 5.2 NUMAæ„ŸçŸ¥çš„é”è®¾è®¡


```java
public class NUMALock {
    private final int nodeCount;
    private final ThreadLocal<Integer> localNode;
    private final AtomicInteger[] nodeCounters;
    
    public NUMALock() {
        this.nodeCount = getNodeCount();
        this.nodeCounters = new AtomicInteger[nodeCount];
        this.localNode = ThreadLocal.withInitial(this::getCurrentNode);
        
        for (int i = 0; i < nodeCount; i++) {
            nodeCounters[i] = new AtomicInteger(0);
        }
    }
    
    public boolean tryLock() {
        int node = localNode.get();
        
        // é¦–å…ˆå°è¯•åœ¨æœ¬åœ°NUMAèŠ‚ç‚¹è·å–é”
        if (nodeCounters[node].compareAndSet(0, 1)) {
            return true;
        }
        
        // æœ¬åœ°èŠ‚ç‚¹å¤±è´¥ï¼Œå°è¯•å…¶ä»–èŠ‚ç‚¹
        for (int i = 0; i < nodeCount; i++) {
            if (i != node && nodeCounters[i].compareAndSet(0, 1)) {
                return true;
            }
        }
        
        return false;
    }
    
    private int getCurrentNode() {
        // è·å–å½“å‰çº¿ç¨‹æ‰€åœ¨çš„NUMAèŠ‚ç‚¹
        return Thread.currentThread().hashCode() % nodeCount;
    }
}
```

### 5.3 å†…å­˜åˆ†é…çš„NUMAä¼˜åŒ–


```java
public class NUMAAllocatedLock {
    
    // ä¸ºæ¯ä¸ªNUMAèŠ‚ç‚¹åˆ†é…ç‹¬ç«‹çš„é”å®ä¾‹
    public static NUMAAllocatedLock create() {
        int node = getCurrentNUMANode();
        return allocateOnNode(node);
    }
    
    // åœ¨æŒ‡å®šNUMAèŠ‚ç‚¹ä¸Šåˆ†é…å†…å­˜
    private static NUMAAllocatedLock allocateOnNode(int node) {
        // ä½¿ç”¨JNAæˆ–JNIè°ƒç”¨ç³»ç»ŸAPI
        // Linux: numa_alloc_onnode()
        // Windows: VirtualAllocExNuma()
        return new NUMAAllocatedLock();
    }
    
    // æ£€æŸ¥å†…å­˜æ˜¯å¦åœ¨æœŸæœ›çš„NUMAèŠ‚ç‚¹ä¸Š
    public boolean verifyMemoryLocation() {
        long address = getObjectAddress(this);
        return getMemoryNode(address) == getCurrentNUMANode();
    }
}
```

---

## 6. ğŸ’» CPUäº²å’Œæ€§è®¾ç½®


### 6.1 CPUäº²å’Œæ€§æ¦‚å¿µ


CPUäº²å’Œæ€§æ˜¯æŒ‡å°†çº¿ç¨‹ç»‘å®šåˆ°ç‰¹å®šçš„CPUæ ¸å¿ƒï¼Œå‡å°‘çº¿ç¨‹åœ¨ä¸åŒæ ¸å¿ƒé—´è¿ç§»çš„å¼€é”€ã€‚

```
æ— äº²å’Œæ€§ï¼ˆçº¿ç¨‹æ¼‚ç§»ï¼‰ï¼š
æ—¶é—´1: Thread1åœ¨CPU0æ‰§è¡Œ
æ—¶é—´2: Thread1è¢«è°ƒåº¦åˆ°CPU2æ‰§è¡Œ  â† ç¼“å­˜å¤±æ•ˆ
æ—¶é—´3: Thread1å›åˆ°CPU0æ‰§è¡Œ     â† éœ€è¦é‡æ–°åŠ è½½ç¼“å­˜

æœ‰äº²å’Œæ€§ï¼ˆçº¿ç¨‹å›ºå®šï¼‰ï¼š
æ—¶é—´1: Thread1åœ¨CPU0æ‰§è¡Œ
æ—¶é—´2: Thread1ä»åœ¨CPU0æ‰§è¡Œ     â† ç¼“å­˜ä¿æŒæœ‰æ•ˆ
æ—¶é—´3: Thread1ç»§ç»­åœ¨CPU0æ‰§è¡Œ   â† ç¼“å­˜å‘½ä¸­ç‡é«˜
```

### 6.2 çº¿ç¨‹CPUäº²å’Œæ€§è®¾ç½®


```java
public class CPUAffinityLock {
    private final Map<Long, Integer> threadToCPU = new ConcurrentHashMap<>();
    
    // è®¾ç½®çº¿ç¨‹çš„CPUäº²å’Œæ€§
    public void setThreadAffinity(int cpuId) {
        long threadId = Thread.currentThread().getId();
        threadToCPU.put(threadId, cpuId);
        
        // ä½¿ç”¨JNIè°ƒç”¨ç³»ç»ŸAPIè®¾ç½®äº²å’Œæ€§
        // Linux: sched_setaffinity()
        // Windows: SetThreadAffinityMask()
        setNativeAffinity(threadId, cpuId);
    }
    
    // ä¸ºé”ç«äº‰è€…åˆ†é…ä¸åŒçš„CPU
    public boolean tryLockWithAffinity() {
        int preferredCPU = getPreferredCPU();
        setThreadAffinity(preferredCPU);
        
        return tryLock();
    }
    
    private int getPreferredCPU() {
        // ç®€å•çš„è´Ÿè½½å‡è¡¡ï¼šè½®è¯¢åˆ†é…CPU
        long threadId = Thread.currentThread().getId();
        return (int) (threadId % Runtime.getRuntime().availableProcessors());
    }
}
```

### 6.3 é”ç«äº‰çš„CPUåˆ†é…ç­–ç•¥


```java
public class SmartAffinityLock {
    private final AtomicInteger cpuAllocator = new AtomicInteger(0);
    private final int availableCPUs = Runtime.getRuntime().availableProcessors();
    
    // ä¸ºé«˜ç«äº‰é”åˆ†é…ä¸“ç”¨CPU
    public void allocateDedicatedCPUs(int lockId) {
        if (isHighContentionLock(lockId)) {
            // ä¸ºç»å¸¸ç«äº‰çš„é”åˆ†é…ç›¸é‚»çš„CPUæ ¸å¿ƒ
            int baseCPU = (lockId * 2) % availableCPUs;
            bindLockToCPUs(lockId, baseCPU, baseCPU + 1);
        }
    }
    
    // åŠ¨æ€è°ƒæ•´CPUåˆ†é…
    public void rebalanceCPUAllocation() {
        for (LockInfo lock : getActiveLocks()) {
            if (lock.getContentionLevel() > THRESHOLD) {
                // é«˜ç«äº‰é”è·å¾—æ›´å¤šCPUèµ„æº
                allocateMoreCPUs(lock);
            } else {
                // ä½ç«äº‰é”é‡Šæ”¾å¤šä½™CPUèµ„æº
                releaseCPUs(lock);
            }
        }
    }
}
```

---

## 7. ğŸš€ ç¼“å­˜ä¼˜åŒ–å®Œæ•´ç­–ç•¥


### 7.1 åˆ†å±‚ä¼˜åŒ–ç­–ç•¥


```
ç¼“å­˜ä¼˜åŒ–åˆ†å±‚ï¼š
L1å±‚ï¼šæ•°æ®ç»“æ„çº§ä¼˜åŒ– â† å­—æ®µå¯¹é½ã€ç´§å‡‘å¸ƒå±€
L2å±‚ï¼šè®¿é—®æ¨¡å¼ä¼˜åŒ–   â† å‡å°‘ç¼“å­˜missã€é¢„å–
L3å±‚ï¼šå¹¶å‘æ¨¡å¼ä¼˜åŒ–   â† é¿å…ä¼ªå…±äº«ã€å‡å°‘ç«äº‰
L4å±‚ï¼šç³»ç»Ÿçº§ä¼˜åŒ–     â† NUMAæ„ŸçŸ¥ã€CPUäº²å’Œæ€§
```

**ğŸ”§ ç»¼åˆä¼˜åŒ–å®ç°**

```java
@Contended
public class FullyOptimizedLock {
    // L1: ç´§å‡‘çš„æ•°æ®ç»“æ„
    @Contended("core")
    private volatile int state;
    
    @Contended("core") 
    private volatile Thread owner;
    
    // L2: å‡å°‘ä¸å¿…è¦çš„å†…å­˜è®¿é—®
    private static final VarHandle STATE_HANDLE;
    static {
        try {
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            STATE_HANDLE = lookup.findVarHandle(FullyOptimizedLock.class, 
                                               "state", int.class);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    
    // L3: é¿å…ä¼ªå…±äº«çš„ç»Ÿè®¡ä¿¡æ¯
    @Contended("stats")
    private volatile long contentionCount;
    
    public boolean tryLock() {
        // L2: ä½¿ç”¨VarHandleå‡å°‘volatileè®¿é—®å¼€é”€
        return STATE_HANDLE.compareAndSet(this, 0, 1);
    }
    
    // L4: NUMAå’ŒCPUäº²å’Œæ€§ä¼˜åŒ–
    public boolean tryLockOptimized() {
        optimizeCPUAffinity();
        ensureNUMALocality();
        return tryLock();
    }
}
```

### 7.2 è‡ªé€‚åº”ç¼“å­˜ä¼˜åŒ–


```java
public class AdaptiveCacheLock {
    private volatile CacheStrategy currentStrategy = CacheStrategy.DEFAULT;
    private final AtomicLong performanceCounter = new AtomicLong(0);
    
    enum CacheStrategy {
        DEFAULT,
        CACHE_FRIENDLY,
        NUMA_OPTIMIZED,
        AFFINITY_BASED
    }
    
    public boolean tryLock() {
        long startTime = System.nanoTime();
        boolean result = tryLockWithStrategy(currentStrategy);
        long duration = System.nanoTime() - startTime;
        
        // æ”¶é›†æ€§èƒ½æ•°æ®
        performanceCounter.addAndGet(duration);
        
        // å®šæœŸè¯„ä¼°å¹¶è°ƒæ•´ç­–ç•¥
        if (shouldAdaptStrategy()) {
            adaptCacheStrategy();
        }
        
        return result;
    }
    
    private void adaptCacheStrategy() {
        CacheStrategy bestStrategy = evaluateStrategies();
        if (bestStrategy != currentStrategy) {
            currentStrategy = bestStrategy;
            System.out.println("Switched to cache strategy: " + bestStrategy);
        }
    }
    
    private CacheStrategy evaluateStrategies() {
        // æµ‹è¯•ä¸åŒç­–ç•¥çš„æ€§èƒ½
        Map<CacheStrategy, Long> performance = new HashMap<>();
        
        for (CacheStrategy strategy : CacheStrategy.values()) {
            performance.put(strategy, benchmarkStrategy(strategy));
        }
        
        // è¿”å›æ€§èƒ½æœ€å¥½çš„ç­–ç•¥
        return performance.entrySet().stream()
            .min(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(CacheStrategy.DEFAULT);
    }
}
```

### 7.3 æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜


```java
public class CachePerformanceMonitor {
    private final Map<String, PerformanceMetrics> lockMetrics = new ConcurrentHashMap<>();
    
    static class PerformanceMetrics {
        volatile long cacheHits = 0;
        volatile long cacheMisses = 0;
        volatile long avgLatency = 0;
        volatile double contentionRate = 0.0;
    }
    
    // ç›‘æ§é”çš„ç¼“å­˜æ€§èƒ½
    public void monitorLockPerformance(String lockName, Runnable lockOperation) {
        long startTime = System.nanoTime();
        long startCacheMisses = getCacheMisses();
        
        lockOperation.run();
        
        long endTime = System.nanoTime();
        long endCacheMisses = getCacheMisses();
        
        updateMetrics(lockName, endTime - startTime, 
                     endCacheMisses - startCacheMisses);
    }
    
    // ç”Ÿæˆä¼˜åŒ–å»ºè®®
    public List<String> generateOptimizationSuggestions(String lockName) {
        PerformanceMetrics metrics = lockMetrics.get(lockName);
        List<String> suggestions = new ArrayList<>();
        
        if (metrics.cacheMisses > metrics.cacheHits) {
            suggestions.add("Consider cache line alignment");
        }
        
        if (metrics.contentionRate > 0.5) {
            suggestions.add("Implement lock splitting or striping");
        }
        
        if (metrics.avgLatency > 1000) {  // 1Î¼s
            suggestions.add("Enable CPU affinity optimization");
        }
        
        return suggestions;
    }
    
    // è·å–CPUç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
    private native long getCacheMisses();
}
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ CPUç¼“å­˜å±‚æ¬¡ï¼šL1/L2/L3ç¼“å­˜çš„ç‰¹ç‚¹å’Œè®¿é—®å»¶è¿Ÿ
ğŸ”¸ ç¼“å­˜è¡Œæ¦‚å¿µï¼š64å­—èŠ‚ä¸ºå•ä½çš„ç¼“å­˜åŠ è½½å’Œå¤±æ•ˆ
ğŸ”¸ ä¼ªå…±äº«é—®é¢˜ï¼šä¸ç›¸å…³å˜é‡å…±äº«ç¼“å­˜è¡Œå¯¼è‡´çš„æ€§èƒ½ä¸‹é™
ğŸ”¸ NUMAæ¶æ„ï¼šéä¸€è‡´å†…å­˜è®¿é—®å¯¹é”æ€§èƒ½çš„å½±å“
ğŸ”¸ CPUäº²å’Œæ€§ï¼šç»‘å®šçº¿ç¨‹åˆ°ç‰¹å®šCPUæ ¸å¿ƒçš„ä¼˜åŒ–
```

### 8.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆç¼“å­˜ä¼˜åŒ–é‡è¦**
```
æ€§èƒ½å·®å¼‚ï¼š
L1ç¼“å­˜å‘½ä¸­ï¼š1-3ä¸ªCPUå‘¨æœŸ
å†…å­˜è®¿é—®ï¼š100-300ä¸ªCPUå‘¨æœŸ
å·®å¼‚ï¼š100å€çš„æ€§èƒ½å·®è·

é”æ“ä½œç‰¹ç‚¹ï¼š
é¢‘ç¹è®¿é—®ï¼šé”çŠ¶æ€è¢«é¢‘ç¹è¯»å†™
ç«äº‰è®¿é—®ï¼šå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®é”
ä¸€è‡´æ€§è¦æ±‚ï¼šå¿…é¡»ä¿è¯æ•°æ®ä¸€è‡´æ€§
```

**ğŸ”¹ ä¼˜åŒ–ç­–ç•¥çš„é€‰æ‹©åŸåˆ™**
```
æ•°æ®ç»“æ„ä¼˜åŒ–ï¼šé€‚ç”¨äºæ‰€æœ‰åœºæ™¯ï¼ŒåŸºç¡€ä¼˜åŒ–
ç¼“å­˜è¡Œå¯¹é½ï¼šé€‚ç”¨äºé«˜é¢‘è®¿é—®çš„é”
ä¼ªå…±äº«é¿å…ï¼šé€‚ç”¨äºå¤šçº¿ç¨‹ç«äº‰æ¿€çƒˆçš„é”  
NUMAä¼˜åŒ–ï¼šé€‚ç”¨äºå¤§å‹å¤šCPUç³»ç»Ÿ
CPUäº²å’Œæ€§ï¼šé€‚ç”¨äºé•¿æ—¶é—´è¿è¡Œçš„é”å¯†é›†ä»»åŠ¡
```

**ğŸ”¹ æ€§èƒ½æµ‹é‡çš„é‡è¦æ€§**
```
ä¼˜åŒ–åŸåˆ™ï¼š
1. å…ˆæµ‹é‡å†ä¼˜åŒ–
2. éªŒè¯ä¼˜åŒ–æ•ˆæœ
3. ç›‘æ§é•¿æœŸæ€§èƒ½
4. æ ¹æ®åœºæ™¯é€‰æ‹©ç­–ç•¥
```

### 8.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ¯ ä¼˜åŒ–å®æ–½æ­¥éª¤**

```
æ­¥éª¤1ï¼šæ€§èƒ½åŸºçº¿æµ‹è¯•
â€¢ æµ‹é‡é”çš„è·å–å»¶è¿Ÿ
â€¢ ç»Ÿè®¡ç¼“å­˜æœªå‘½ä¸­ç‡
â€¢ åˆ†æçº¿ç¨‹ç«äº‰æ¨¡å¼

æ­¥éª¤2ï¼šè¯†åˆ«ç“¶é¢ˆ
â€¢ æ£€æµ‹ä¼ªå…±äº«é—®é¢˜
â€¢ åˆ†æNUMAè®¿é—®æ¨¡å¼
â€¢ è¯„ä¼°CPUè°ƒåº¦æ•ˆç‡

æ­¥éª¤3ï¼šåº”ç”¨ä¼˜åŒ–æŠ€æœ¯
â€¢ å®æ–½ç¼“å­˜è¡Œå¯¹é½
â€¢ è®¾ç½®CPUäº²å’Œæ€§
â€¢ ä¼˜åŒ–æ•°æ®ç»“æ„å¸ƒå±€

æ­¥éª¤4ï¼šéªŒè¯æ•ˆæœ
â€¢ å¯¹æ¯”ä¼˜åŒ–å‰åæ€§èƒ½
â€¢ ç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨
â€¢ è¯„ä¼°ä¼˜åŒ–çš„ç¨³å®šæ€§
```

**âš¡ å¸¸è§ä¼˜åŒ–æŠ€å·§**

| ä¼˜åŒ–ç±»åˆ« | æŠ€æœ¯æ‰‹æ®µ | é€‚ç”¨åœºæ™¯ | é¢„æœŸæ”¶ç›Š |
|----------|----------|----------|----------|
| **æ•°æ®å¸ƒå±€** | å­—æ®µç´§å‡‘æ’åˆ— | æ‰€æœ‰é”ç±»å‹ | 10-20% |
| **ç¼“å­˜å¯¹é½** | @Contendedæ³¨è§£ | é«˜é¢‘è®¿é—®é” | 20-50% |
| **ä¼ªå…±äº«** | å¡«å……åˆ†ç¦» | å¤šçº¿ç¨‹ç«äº‰ | 50-200% |
| **NUMAä¼˜åŒ–** | æœ¬åœ°å†…å­˜åˆ†é… | å¤§å‹ç³»ç»Ÿ | 30-100% |
| **CPUäº²å’Œæ€§** | çº¿ç¨‹ç»‘å®š | é•¿è¿è¡Œä»»åŠ¡ | 15-40% |

### 8.4 ç›‘æ§å’Œè°ƒä¼˜å»ºè®®


**ğŸ“Š å…³é”®ç›‘æ§æŒ‡æ ‡**

```
ç¼“å­˜ç›¸å…³æŒ‡æ ‡ï¼š
â€¢ ç¼“å­˜å‘½ä¸­ç‡ (>90%)
â€¢ ç¼“å­˜æœªå‘½ä¸­å»¶è¿Ÿ (<100ns)
â€¢ ç¼“å­˜ä¸€è‡´æ€§å¼€é”€ (<10%)

é”æ€§èƒ½æŒ‡æ ‡ï¼š
â€¢ é”è·å–å»¶è¿Ÿ (<1Î¼s)
â€¢ é”ç«äº‰ç‡ (<50%)
â€¢ çº¿ç¨‹è°ƒåº¦å¼€é”€ (<5%)

ç³»ç»Ÿçº§æŒ‡æ ‡ï¼š
â€¢ CPUåˆ©ç”¨ç‡ (70-90%)
â€¢ å†…å­˜å¸¦å®½ä½¿ç”¨ (<80%)
â€¢ NUMAè¿œç¨‹è®¿é—®ç‡ (<30%)
```

**ğŸ”§ è°ƒä¼˜æœ€ä½³å®è·µ**

```
æŒç»­ä¼˜åŒ–ï¼š
1. å»ºç«‹æ€§èƒ½ç›‘æ§ä½“ç³»
2. å®šæœŸåˆ†ææ€§èƒ½æ•°æ®
3. æµ‹è¯•ä¸åŒä¼˜åŒ–ç­–ç•¥
4. æ ¹æ®è´Ÿè½½ç‰¹å¾è°ƒæ•´

åœºæ™¯é€‚é…ï¼š
â€¢ é«˜é¢‘å°é”ï¼šé‡ç‚¹ä¼˜åŒ–ç¼“å­˜å‘½ä¸­
â€¢ é•¿æŒæœ‰é”ï¼šé‡ç‚¹ä¼˜åŒ–CPUäº²å’Œæ€§
â€¢ å¤§å¹¶å‘é”ï¼šé‡ç‚¹é¿å…ä¼ªå…±äº«
â€¢ åˆ†å¸ƒå¼é”ï¼šé‡ç‚¹ä¼˜åŒ–NUMAè®¿é—®
```

**ğŸ§  æ ¸å¿ƒè®°å¿†è¦ç‚¹**

- CPUç¼“å­˜å±‚æ¬¡å†³å®šè®¿é—®é€Ÿåº¦ï¼ŒL1æœ€å¿«å†…å­˜æœ€æ…¢
- ç¼“å­˜è¡Œ64å­—èŠ‚ï¼Œä¼ªå…±äº«æ˜¯æ€§èƒ½æ€æ‰‹
- æ•°æ®å¯¹é½å’Œç´§å‡‘å¸ƒå±€æ˜¯åŸºç¡€ä¼˜åŒ–
- NUMAæ„ŸçŸ¥å’ŒCPUäº²å’Œæ€§é€‚ç”¨å¤§å‹ç³»ç»Ÿ
- æ€§èƒ½ç›‘æ§æŒ‡å¯¼ä¼˜åŒ–å†³ç­–ï¼Œæµ‹é‡éªŒè¯æ•ˆæœ