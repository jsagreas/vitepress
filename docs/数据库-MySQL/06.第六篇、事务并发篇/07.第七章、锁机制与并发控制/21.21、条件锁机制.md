---
title: 21ã€æ¡ä»¶é”æœºåˆ¶
---
## ğŸ“š ç›®å½•

1. [æ¡ä»¶ç­‰å¾…æœºåˆ¶](#1-æ¡ä»¶ç­‰å¾…æœºåˆ¶)
2. [é”æ¡ä»¶å˜é‡](#2-é”æ¡ä»¶å˜é‡)
3. [æ¡ä»¶é”åº”ç”¨åœºæ™¯](#3-æ¡ä»¶é”åº”ç”¨åœºæ™¯)
4. [æ¡ä»¶é”æ€§èƒ½ç‰¹æ€§](#4-æ¡ä»¶é”æ€§èƒ½ç‰¹æ€§)
5. [æ¡ä»¶é”å®ç°å¤æ‚æ€§](#5-æ¡ä»¶é”å®ç°å¤æ‚æ€§)
6. [æ¡ä»¶é”å®Œæ•´æœºåˆ¶](#6-æ¡ä»¶é”å®Œæ•´æœºåˆ¶)
7. [æ¡ä»¶é”ä¼˜åŒ–ç­–ç•¥](#7-æ¡ä»¶é”ä¼˜åŒ–ç­–ç•¥)
8. [æ¡ä»¶é”åº”ç”¨æŒ‡å—](#8-æ¡ä»¶é”åº”ç”¨æŒ‡å—)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. â³ æ¡ä»¶ç­‰å¾…æœºåˆ¶


### 1.1 æ¡ä»¶ç­‰å¾…åŸºæœ¬æ¦‚å¿µ


æ¡ä»¶ç­‰å¾…æ˜¯ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œå…è®¸çº¿ç¨‹åœ¨ç‰¹å®šæ¡ä»¶æ»¡è¶³ä¹‹å‰æš‚åœæ‰§è¡Œï¼Œæ¡ä»¶æ»¡è¶³æ—¶è‡ªåŠ¨å”¤é†’ç»§ç»­æ‰§è¡Œã€‚

**ğŸ’¡ ç”Ÿæ´»ç±»æ¯”**ï¼š
å°±åƒåœ¨é¤å…ç­‰ä½ç½® - ä½ ä¸ä¼šä¸€ç›´ç«™åœ¨é—¨å£é—®"æœ‰ä½ç½®å—ï¼Ÿ"ï¼Œè€Œæ˜¯ç•™ä¸ªå·ç ï¼Œæœ‰ä½ç½®æ—¶æœåŠ¡å‘˜ä¸»åŠ¨é€šçŸ¥ä½ ã€‚

**ğŸ”¸ æ ¸å¿ƒæ€æƒ³**
```
ä¼ ç»Ÿè½®è¯¢æ–¹å¼ï¼š
while (æ¡ä»¶ä¸æ»¡è¶³) {
    Thread.sleep(100);  // æµªè´¹CPUèµ„æº
}

æ¡ä»¶ç­‰å¾…æ–¹å¼ï¼š
lock.lock();
try {
    while (æ¡ä»¶ä¸æ»¡è¶³) {
        condition.await();  // é«˜æ•ˆç­‰å¾…
    }
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
} finally {
    lock.unlock();
}
```

### 1.2 ç­‰å¾…æœºåˆ¶çš„å·¥ä½œæµç¨‹


**ğŸ“Š ç­‰å¾…å’Œå”¤é†’æµç¨‹**
```
ç­‰å¾…çº¿ç¨‹æ“ä½œæµç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è·å–é”     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ£€æŸ¥æ¡ä»¶   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ æ¡ä»¶ä¸æ»¡è¶³
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é‡Šæ”¾é”     â”‚ â† condition.await()
â”‚  è¿›å…¥ç­‰å¾…   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚ è¢«å”¤é†’
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é‡æ–°è·å–é” â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é‡æ–°æ£€æŸ¥   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**âš¡ åŸºç¡€å®ç°ç¤ºä¾‹**
```java
public class WaitNotifyExample {
    private final Object lock = new Object();
    private boolean dataReady = false;
    
    // ç­‰å¾…çº¿ç¨‹
    public void waitForData() throws InterruptedException {
        synchronized (lock) {
            while (!dataReady) {
                lock.wait();  // ç­‰å¾…æ¡ä»¶æ»¡è¶³
            }
            // å¤„ç†æ•°æ®
            processData();
        }
    }
    
    // é€šçŸ¥çº¿ç¨‹
    public void setDataReady() {
        synchronized (lock) {
            dataReady = true;
            lock.notify();  // å”¤é†’ç­‰å¾…çº¿ç¨‹
        }
    }
}
```

### 1.3 ç­‰å¾…æœºåˆ¶çš„ä¼˜åŠ¿


**âœ… ç›¸æ¯”è½®è¯¢çš„ä¼˜åŠ¿**
```
èµ„æºåˆ©ç”¨ç‡ï¼š
â€¢ è½®è¯¢ï¼šæŒç»­æ¶ˆè€—CPUèµ„æº
â€¢ æ¡ä»¶ç­‰å¾…ï¼šçº¿ç¨‹ä¼‘çœ ï¼Œä¸æ¶ˆè€—CPU

å“åº”åŠæ—¶æ€§ï¼š
â€¢ è½®è¯¢ï¼šæœ‰æ£€æŸ¥é—´éš”ï¼Œå­˜åœ¨å»¶è¿Ÿ
â€¢ æ¡ä»¶ç­‰å¾…ï¼šç«‹å³å“åº”æ¡ä»¶å˜åŒ–

ç³»ç»Ÿè´Ÿè½½ï¼š
â€¢ è½®è¯¢ï¼šå¢åŠ ç³»ç»Ÿè´Ÿè½½
â€¢ æ¡ä»¶ç­‰å¾…ï¼šå‡å°‘ä¸å¿…è¦çš„è®¡ç®—
```

---

## 2. ğŸ”— é”æ¡ä»¶å˜é‡


### 2.1 æ¡ä»¶å˜é‡åŸºæœ¬æ¦‚å¿µ


æ¡ä»¶å˜é‡ï¼ˆCondition Variableï¼‰æ˜¯ä¸é”é…åˆä½¿ç”¨çš„åŒæ­¥åŸè¯­ï¼Œæä¾›æ¯”wait/notifyæ›´å¼ºå¤§å’Œçµæ´»çš„ç­‰å¾…æœºåˆ¶ã€‚

**ğŸ”¸ Javaä¸­çš„Conditionæ¥å£**
```java
public class ConditionExample {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private boolean ready = false;
    
    public void waitUntilReady() throws InterruptedException {
        lock.lock();
        try {
            while (!ready) {
                condition.await();  // ç­‰å¾…æ¡ä»¶
            }
            // æ¡ä»¶æ»¡è¶³ï¼Œæ‰§è¡Œä¸šåŠ¡é€»è¾‘
        } finally {
            lock.unlock();
        }
    }
    
    public void signalReady() {
        lock.lock();
        try {
            ready = true;
            condition.signal();  // å”¤é†’ç­‰å¾…çº¿ç¨‹
        } finally {
            lock.unlock();
        }
    }
}
```

### 2.2 å¤šæ¡ä»¶å˜é‡åº”ç”¨


**ğŸ¯ ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹**
```java
public class BoundedBuffer<T> {
    private final T[] buffer;
    private int count, putIndex, takeIndex;
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();   // ç¼“å†²åŒºä¸æ»¡
    private final Condition notEmpty = lock.newCondition();  // ç¼“å†²åŒºä¸ç©º
    
    public void put(T item) throws InterruptedException {
        lock.lock();
        try {
            while (count == buffer.length) {
                notFull.await();  // ç­‰å¾…ç¼“å†²åŒºä¸æ»¡
            }
            buffer[putIndex] = item;
            putIndex = (putIndex + 1) % buffer.length;
            count++;
            notEmpty.signal();  // é€šçŸ¥æ¶ˆè´¹è€…
        } finally {
            lock.unlock();
        }
    }
    
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();  // ç­‰å¾…ç¼“å†²åŒºä¸ç©º
            }
            T item = buffer[takeIndex];
            takeIndex = (takeIndex + 1) % buffer.length;
            count--;
            notFull.signal();  // é€šçŸ¥ç”Ÿäº§è€…
            return item;
        } finally {
            lock.unlock();
        }
    }
}
```

### 2.3 æ¡ä»¶å˜é‡çš„é«˜çº§ç‰¹æ€§


**â° è¶…æ—¶ç­‰å¾…æœºåˆ¶**
```java
public class TimeoutConditionExample {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    
    public boolean waitWithTimeout(long timeoutMs) throws InterruptedException {
        lock.lock();
        try {
            long deadline = System.currentTimeMillis() + timeoutMs;
            
            while (!conditionSatisfied()) {
                long remaining = deadline - System.currentTimeMillis();
                if (remaining <= 0) {
                    return false;  // è¶…æ—¶
                }
                condition.await(remaining, TimeUnit.MILLISECONDS);
            }
            return true;  // æ¡ä»¶æ»¡è¶³
        } finally {
            lock.unlock();
        }
    }
}
```

---

## 3. ğŸ¯ æ¡ä»¶é”åº”ç”¨åœºæ™¯


### 3.1 ç»å…¸åº”ç”¨åœºæ™¯


**ğŸ“‹ åœºæ™¯åˆ†ç±»**
```
èµ„æºç®¡ç†ç±»ï¼š
ğŸ”¸ è¿æ¥æ± ï¼šç­‰å¾…å¯ç”¨è¿æ¥
ğŸ”¸ çº¿ç¨‹æ± ï¼šç­‰å¾…ä»»åŠ¡æˆ–å·¥ä½œçº¿ç¨‹
ğŸ”¸ å†…å­˜æ± ï¼šç­‰å¾…å¯ç”¨å†…å­˜å—

åè°ƒç±»ï¼š
ğŸ”¸ éšœç¢å™¨ï¼šç­‰å¾…æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾æ£€æŸ¥ç‚¹
ğŸ”¸ ä¿¡å·é‡ï¼šç­‰å¾…è®¸å¯å¯ç”¨
ğŸ”¸ å€’è®¡æ—¶ï¼šç­‰å¾…äº‹ä»¶å®Œæˆ

çŠ¶æ€åŒæ­¥ç±»ï¼š
ğŸ”¸ åˆå§‹åŒ–å®Œæˆï¼šç­‰å¾…ç»„ä»¶åˆå§‹åŒ–
ğŸ”¸ æ•°æ®å°±ç»ªï¼šç­‰å¾…æ•°æ®åŠ è½½å®Œæˆ
ğŸ”¸ ä»»åŠ¡å®Œæˆï¼šç­‰å¾…å¼‚æ­¥ä»»åŠ¡ç»“æŸ
```

### 3.2 è¿æ¥æ± å®ç°


**ğŸŠ æ•°æ®åº“è¿æ¥æ± ç¤ºä¾‹**
```java
public class SimpleConnectionPool {
    private final Queue<Connection> available = new LinkedList<>();
    private final Set<Connection> inUse = new HashSet<>();
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition connectionAvailable = lock.newCondition();
    
    public Connection getConnection() throws InterruptedException {
        lock.lock();
        try {
            while (available.isEmpty()) {
                connectionAvailable.await();  // ç­‰å¾…è¿æ¥å¯ç”¨
            }
            Connection conn = available.poll();
            inUse.add(conn);
            return conn;
        } finally {
            lock.unlock();
        }
    }
    
    public void returnConnection(Connection conn) {
        lock.lock();
        try {
            if (inUse.remove(conn)) {
                available.offer(conn);
                connectionAvailable.signal();  // é€šçŸ¥ç­‰å¾…çº¿ç¨‹
            }
        } finally {
            lock.unlock();
        }
    }
}
```

### 3.3 ä»»åŠ¡åè°ƒåœºæ™¯


**ğŸš© CyclicBarrierå®ç°åŸç†**
```java
public class SimpleCyclicBarrier {
    private final int parties;
    private int count;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition allArrived = lock.newCondition();
    
    public SimpleCyclicBarrier(int parties) {
        this.parties = parties;
        this.count = parties;
    }
    
    public void await() throws InterruptedException {
        lock.lock();
        try {
            count--;
            if (count == 0) {
                // æœ€åä¸€ä¸ªçº¿ç¨‹åˆ°è¾¾ï¼Œå”¤é†’æ‰€æœ‰ç­‰å¾…è€…
                count = parties;  // é‡ç½®è®¡æ•°å™¨
                allArrived.signalAll();
            } else {
                // ç­‰å¾…å…¶ä»–çº¿ç¨‹åˆ°è¾¾
                while (count > 0) {
                    allArrived.await();
                }
            }
        } finally {
            lock.unlock();
        }
    }
}
```

---

## 4. âš¡ æ¡ä»¶é”æ€§èƒ½ç‰¹æ€§


### 4.1 æ€§èƒ½ä¼˜åŠ¿åˆ†æ


**ğŸ“Š æ€§èƒ½å¯¹æ¯”**
```
ä¼ ç»Ÿè½®è¯¢ vs æ¡ä»¶ç­‰å¾…ï¼š

CPUä½¿ç”¨ç‡ï¼š
â€¢ è½®è¯¢ï¼šæŒç»­100%ä½¿ç”¨
â€¢ æ¡ä»¶ç­‰å¾…ï¼šæ¥è¿‘0%ä½¿ç”¨

å“åº”å»¶è¿Ÿï¼š
â€¢ è½®è¯¢ï¼šå¹³å‡å»¶è¿Ÿ = è½®è¯¢é—´éš”/2
â€¢ æ¡ä»¶ç­‰å¾…ï¼šå‡ ä¹é›¶å»¶è¿Ÿ

å†…å­˜å¼€é”€ï¼š
â€¢ è½®è¯¢ï¼šéœ€è¦é¢å¤–çš„è®¡æ—¶å™¨
â€¢ æ¡ä»¶ç­‰å¾…ï¼šåªéœ€è¦å°‘é‡åŒæ­¥åŸè¯­

æ‰©å±•æ€§ï¼š
â€¢ è½®è¯¢ï¼šçº¿ç¨‹å¢åŠ ï¼Œæ€§èƒ½çº¿æ€§ä¸‹é™
â€¢ æ¡ä»¶ç­‰å¾…ï¼šçº¿ç¨‹å¢åŠ ï¼Œæ€§èƒ½åŸºæœ¬ä¸å˜
```

### 4.2 æ€§èƒ½æµ‹è¯•ç¤ºä¾‹


**ğŸ”¬ æ€§èƒ½æµ‹è¯•ä»£ç **
```java
public class ConditionPerformanceTest {
    private static final int THREAD_COUNT = 100;
    private static final int ITERATIONS = 10000;
    
    // æµ‹è¯•æ¡ä»¶ç­‰å¾…æ€§èƒ½
    public void testConditionPerformance() throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        AtomicBoolean ready = new AtomicBoolean(false);
        
        long startTime = System.currentTimeMillis();
        
        // å¯åŠ¨ç­‰å¾…çº¿ç¨‹
        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(() -> {
                lock.lock();
                try {
                    while (!ready.get()) {
                        condition.await();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    lock.unlock();
                }
            }).start();
        }
        
        Thread.sleep(100);  // ç­‰å¾…çº¿ç¨‹å¯åŠ¨
        
        // å”¤é†’æ‰€æœ‰çº¿ç¨‹
        lock.lock();
        try {
            ready.set(true);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("æ¡ä»¶ç­‰å¾…è€—æ—¶: " + (endTime - startTime) + "ms");
    }
}
```

### 4.3 æ€§èƒ½è°ƒä¼˜è¦ç‚¹


**ğŸ¯ ä¼˜åŒ–ç­–ç•¥**
```
å‡å°‘é”ç«äº‰ï¼š
â€¢ ä½¿ç”¨è¯»å†™é”åˆ†ç¦»è¯»å†™æ“ä½œ
â€¢ ç»†åŒ–é”çš„ç²’åº¦
â€¢ é¿å…åœ¨é”å†…æ‰§è¡Œè€—æ—¶æ“ä½œ

é€‰æ‹©åˆé€‚çš„å”¤é†’ç­–ç•¥ï¼š
â€¢ signal()ï¼šå”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œæ€§èƒ½æ›´å¥½
â€¢ signalAll()ï¼šå”¤é†’æ‰€æœ‰çº¿ç¨‹ï¼Œæ›´å®‰å…¨

æ¡ä»¶æ£€æŸ¥ä¼˜åŒ–ï¼š
â€¢ ä½¿ç”¨whileå¾ªç¯è€Œä¸æ˜¯if
â€¢ é¿å…è™šå‡å”¤é†’é—®é¢˜
â€¢ æ¡ä»¶æ£€æŸ¥é€»è¾‘è¦ç®€å•é«˜æ•ˆ
```

---

## 5. ğŸ”§ æ¡ä»¶é”å®ç°å¤æ‚æ€§


### 5.1 å®ç°å¤æ‚æ€§åˆ†æ


**ğŸ§© å¤æ‚æ€§æ¥æº**
```
åŒæ­¥åŸè¯­å¤æ‚æ€§ï¼š
â€¢ éœ€è¦æ­£ç¡®å¤„ç†çº¿ç¨‹çŠ¶æ€è½¬æ¢
â€¢ é¿å…æ­»é”å’Œæ´»é”é—®é¢˜
â€¢ å¤„ç†ä¸­æ–­å’Œå¼‚å¸¸æƒ…å†µ

å†…å­˜æ¨¡å‹å¤æ‚æ€§ï¼š
â€¢ ç¡®ä¿å¯è§æ€§å’Œæœ‰åºæ€§
â€¢ å¤„ç†ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜
â€¢ é¿å…æŒ‡ä»¤é‡æ’åºå½±å“

é”™è¯¯å¤„ç†å¤æ‚æ€§ï¼š
â€¢ å¼‚å¸¸æƒ…å†µä¸‹çš„èµ„æºæ¸…ç†
â€¢ ä¸­æ–­å¤„ç†çš„æ­£ç¡®æ€§
â€¢ è¶…æ—¶æœºåˆ¶çš„å‡†ç¡®æ€§
```

### 5.2 å¸¸è§å®ç°é™·é˜±


**âš ï¸ è™šå‡å”¤é†’é—®é¢˜**
```java
// é”™è¯¯çš„å®ç°æ–¹å¼
public void wrongWaitImplementation() throws InterruptedException {
    lock.lock();
    try {
        if (!condition) {  // é”™è¯¯ï¼šä½¿ç”¨ifè€Œä¸æ˜¯while
            conditionVar.await();
        }
        // å¯èƒ½æ¡ä»¶ä»ç„¶ä¸æ»¡è¶³
    } finally {
        lock.unlock();
    }
}

// æ­£ç¡®çš„å®ç°æ–¹å¼
public void correctWaitImplementation() throws InterruptedException {
    lock.lock();
    try {
        while (!condition) {  // æ­£ç¡®ï¼šä½¿ç”¨whileå¾ªç¯
            conditionVar.await();
        }
        // ç¡®ä¿æ¡ä»¶æ»¡è¶³
    } finally {
        lock.unlock();
    }
}
```

### 5.3 çº¿ç¨‹å®‰å…¨å®ç°


**ğŸ”’ å®Œæ•´çš„çº¿ç¨‹å®‰å…¨å®ç°**
```java
public class ThreadSafeConditionExample {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private volatile boolean conditionMet = false;
    
    public void waitForCondition() throws InterruptedException {
        lock.lock();
        try {
            while (!conditionMet) {
                try {
                    condition.await();
                } catch (InterruptedException e) {
                    // å¤„ç†ä¸­æ–­ï¼Œæ¢å¤ä¸­æ–­çŠ¶æ€
                    Thread.currentThread().interrupt();
                    throw e;
                }
            }
            // æ¡ä»¶æ»¡è¶³ï¼Œæ‰§è¡Œä¸šåŠ¡é€»è¾‘
            processWithConditionMet();
        } finally {
            lock.unlock();
        }
    }
    
    public void signalCondition() {
        lock.lock();
        try {
            conditionMet = true;
            condition.signalAll();  // ä½¿ç”¨signalAll()æ›´å®‰å…¨
        } finally {
            lock.unlock();
        }
    }
    
    private void processWithConditionMet() {
        // ä¸šåŠ¡é€»è¾‘å¤„ç†
    }
}
```

---

## 6. ğŸ”„ æ¡ä»¶é”å®Œæ•´æœºåˆ¶


### 6.1 å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†


**ğŸ“Š æ¡ä»¶é”ç”Ÿå‘½å‘¨æœŸ**
```
åˆå§‹åŒ–é˜¶æ®µï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åˆ›å»ºé”å¯¹è±¡ â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åˆ›å»ºæ¡ä»¶å˜é‡â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åˆå§‹åŒ–çŠ¶æ€ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä½¿ç”¨é˜¶æ®µï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç­‰å¾…çº¿ç¨‹   â”‚    â”‚  é€šçŸ¥çº¿ç¨‹   â”‚
â”‚  è·å–é”     â”‚    â”‚  è·å–é”     â”‚
â”‚  æ£€æŸ¥æ¡ä»¶   â”‚    â”‚  ä¿®æ”¹çŠ¶æ€   â”‚
â”‚  ç­‰å¾…/ç»§ç»­  â”‚    â”‚  å‘é€é€šçŸ¥   â”‚
â”‚  é‡Šæ”¾é”     â”‚    â”‚  é‡Šæ”¾é”     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¸…ç†é˜¶æ®µï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¡®ä¿æ— ç­‰å¾… â”‚
â”‚  æ¸…ç†èµ„æº   â”‚
â”‚  é”€æ¯å¯¹è±¡   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 çŠ¶æ€ç®¡ç†æœºåˆ¶


**ğŸ® çŠ¶æ€è½¬æ¢å®ç°**
```java
public class StatefulConditionLock {
    private enum State { WAITING, READY, PROCESSING, COMPLETED }
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition stateChanged = lock.newCondition();
    private volatile State currentState = State.WAITING;
    
    public void waitForState(State targetState) throws InterruptedException {
        lock.lock();
        try {
            while (currentState != targetState) {
                stateChanged.await();
            }
        } finally {
            lock.unlock();
        }
    }
    
    public void transitionTo(State newState) {
        lock.lock();
        try {
            State oldState = currentState;
            currentState = newState;
            
            // è®°å½•çŠ¶æ€è½¬æ¢æ—¥å¿—
            logStateTransition(oldState, newState);
            
            // é€šçŸ¥æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
            stateChanged.signalAll();
        } finally {
            lock.unlock();
        }
    }
    
    private void logStateTransition(State from, State to) {
        System.out.println("çŠ¶æ€è½¬æ¢: " + from + " -> " + to);
    }
}
```

### 6.3 å¼‚å¸¸å¤„ç†æœºåˆ¶


**ğŸ›¡ï¸ å¥å£®çš„å¼‚å¸¸å¤„ç†**
```java
public class RobustConditionLock {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private final AtomicBoolean shutdown = new AtomicBoolean(false);
    
    public boolean waitWithTimeout(long timeoutMs) throws InterruptedException {
        if (shutdown.get()) {
            throw new IllegalStateException("æ¡ä»¶é”å·²å…³é—­");
        }
        
        lock.lock();
        try {
            long deadline = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeoutMs);
            
            while (!conditionSatisfied() && !shutdown.get()) {
                long remaining = deadline - System.nanoTime();
                if (remaining <= 0) {
                    return false;  // è¶…æ—¶
                }
                
                try {
                    condition.awaitNanos(remaining);
                } catch (InterruptedException e) {
                    // æ¢å¤ä¸­æ–­çŠ¶æ€å¹¶é‡æ–°æŠ›å‡º
                    Thread.currentThread().interrupt();
                    throw e;
                }
            }
            
            return conditionSatisfied() && !shutdown.get();
        } finally {
            lock.unlock();
        }
    }
    
    public void shutdown() {
        lock.lock();
        try {
            shutdown.set(true);
            condition.signalAll();  // å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
        } finally {
            lock.unlock();
        }
    }
}
```

---

## 7. ğŸš€ æ¡ä»¶é”ä¼˜åŒ–ç­–ç•¥


### 7.1 æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯


**âš¡ é”åˆ†ç¦»ä¼˜åŒ–**
```java
public class OptimizedConditionLock {
    // è¯»å†™åˆ†ç¦»é”
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private final Condition writeCondition = writeLock.newCondition();
    
    private volatile boolean dataReady = false;
    
    // è¯»æ“ä½œä½¿ç”¨è¯»é”
    public boolean checkDataReady() {
        readLock.lock();
        try {
            return dataReady;
        } finally {
            readLock.unlock();
        }
    }
    
    // å†™æ“ä½œå’Œç­‰å¾…ä½¿ç”¨å†™é”
    public void waitForData() throws InterruptedException {
        writeLock.lock();
        try {
            while (!dataReady) {
                writeCondition.await();
            }
            // å¤„ç†æ•°æ®
        } finally {
            writeLock.unlock();
        }
    }
    
    public void setDataReady() {
        writeLock.lock();
        try {
            dataReady = true;
            writeCondition.signalAll();
        } finally {
            writeLock.unlock();
        }
    }
}
```

### 7.2 æ‰¹é‡æ“ä½œä¼˜åŒ–


**ğŸ“¦ æ‰¹é‡å”¤é†’ç­–ç•¥**
```java
public class BatchConditionNotifier {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition batchReady = lock.newCondition();
    private final Queue<String> pendingItems = new LinkedList<>();
    private final int batchSize = 10;
    
    public void addItem(String item) {
        lock.lock();
        try {
            pendingItems.offer(item);
            
            // è¾¾åˆ°æ‰¹é‡å¤§å°æ—¶æ‰¹é‡é€šçŸ¥
            if (pendingItems.size() >= batchSize) {
                batchReady.signalAll();  // æ‰¹é‡å”¤é†’
            }
        } finally {
            lock.unlock();
        }
    }
    
    public List<String> waitForBatch() throws InterruptedException {
        lock.lock();
        try {
            while (pendingItems.size() < batchSize) {
                batchReady.await();
            }
            
            // æ‰¹é‡å–å‡ºæ•°æ®
            List<String> batch = new ArrayList<>();
            for (int i = 0; i < batchSize && !pendingItems.isEmpty(); i++) {
                batch.add(pendingItems.poll());
            }
            return batch;
        } finally {
            lock.unlock();
        }
    }
}
```

### 7.3 è‡ªé€‚åº”ä¼˜åŒ–


**ğŸ§  æ™ºèƒ½ç­‰å¾…ç­–ç•¥**
```java
public class AdaptiveConditionLock {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private final AtomicLong waitCount = new AtomicLong(0);
    private final AtomicLong signalCount = new AtomicLong(0);
    
    public void smartWait() throws InterruptedException {
        lock.lock();
        try {
            waitCount.incrementAndGet();
            
            // æ ¹æ®å†å²æ•°æ®é€‰æ‹©ç­‰å¾…ç­–ç•¥
            long waitRatio = waitCount.get() * 100 / Math.max(signalCount.get(), 1);
            
            if (waitRatio > 80) {
                // ç­‰å¾…é¢‘ç¹ï¼Œä½¿ç”¨çŸ­è¶…æ—¶
                condition.await(100, TimeUnit.MILLISECONDS);
            } else {
                // ç­‰å¾…ä¸é¢‘ç¹ï¼Œå¯ä»¥é•¿æ—¶é—´ç­‰å¾…
                condition.await();
            }
        } finally {
            lock.unlock();
        }
    }
    
    public void smartSignal() {
        lock.lock();
        try {
            signalCount.incrementAndGet();
            condition.signal();
        } finally {
            lock.unlock();
        }
    }
}
```

---

## 8. ğŸ“– æ¡ä»¶é”åº”ç”¨æŒ‡å—


### 8.1 æœ€ä½³å®è·µåŸåˆ™


**ğŸ¯ è®¾è®¡åŸåˆ™**
```
å®‰å…¨æ€§åŸåˆ™ï¼š
ğŸ”¸ æ€»æ˜¯åœ¨whileå¾ªç¯ä¸­æ£€æŸ¥æ¡ä»¶
ğŸ”¸ æ­£ç¡®å¤„ç†InterruptedException
ğŸ”¸ ä½¿ç”¨try-finallyç¡®ä¿é”é‡Šæ”¾

æ€§èƒ½åŸåˆ™ï¼š
ğŸ”¸ é”çš„ç²’åº¦è¦é€‚ä¸­
ğŸ”¸ é¿å…åœ¨é”å†…æ‰§è¡Œè€—æ—¶æ“ä½œ
ğŸ”¸ é€‰æ‹©åˆé€‚çš„é€šçŸ¥ç­–ç•¥ï¼ˆsignal vs signalAllï¼‰

å¯ç»´æŠ¤æ€§åŸåˆ™ï¼š
ğŸ”¸ æ¡ä»¶é€»è¾‘è¦ç®€å•æ¸…æ™°
ğŸ”¸ æä¾›è¶…æ—¶æœºåˆ¶
ğŸ”¸ è®°å½•å¿…è¦çš„æ—¥å¿—ä¿¡æ¯
```

### 8.2 é€‰æ‹©æŒ‡å¯¼æ¡†æ¶


**ğŸ“Š æŠ€æœ¯é€‰æ‹©çŸ©é˜µ**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åº”ç”¨åœºæ™¯   â”‚ æ¡ä»¶å¤æ‚åº¦  â”‚ å¹¶å‘ç¨‹åº¦    â”‚ æ¨èæ–¹æ¡ˆ    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç®€å•ç­‰å¾…     â”‚    ä½       â”‚     ä½      â”‚ wait/notify â”‚
â”‚ å¤šæ¡ä»¶ç­‰å¾…   â”‚    é«˜       â”‚     ä¸­      â”‚ Condition   â”‚
â”‚ é«˜å¹¶å‘åŒæ­¥   â”‚    ä¸­       â”‚     é«˜      â”‚ CountDownLatchâ”‚
â”‚ å¾ªç¯åŒæ­¥     â”‚    ä½       â”‚     é«˜      â”‚ CyclicBarrierâ”‚
â”‚ èµ„æºæ± ç®¡ç†   â”‚    ä¸­       â”‚     é«˜      â”‚ Semaphore   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.3 å¸¸è§é—®é¢˜è§£å†³


**ğŸ› ï¸ é—®é¢˜è¯Šæ–­æŒ‡å—**
```java
public class ConditionDebuggingHelper {
    private final Map<String, Long> waitTimes = new ConcurrentHashMap<>();
    private final AtomicLong totalWaits = new AtomicLong(0);
    
    public void debugWait(String threadName, Condition condition) 
            throws InterruptedException {
        long startTime = System.currentTimeMillis();
        totalWaits.incrementAndGet();
        
        try {
            condition.await();
        } finally {
            long waitTime = System.currentTimeMillis() - startTime;
            waitTimes.put(threadName, waitTime);
            
            // è¾“å‡ºè°ƒè¯•ä¿¡æ¯
            if (waitTime > 1000) {  // ç­‰å¾…è¶…è¿‡1ç§’
                System.out.println("è­¦å‘Š: çº¿ç¨‹ " + threadName + 
                    " ç­‰å¾…æ—¶é—´è¿‡é•¿: " + waitTime + "ms");
            }
        }
    }
    
    public void printStatistics() {
        System.out.println("æ€»ç­‰å¾…æ¬¡æ•°: " + totalWaits.get());
        System.out.println("å¹³å‡ç­‰å¾…æ—¶é—´: " + 
            waitTimes.values().stream()
                .mapToLong(Long::longValue)
                .average()
                .orElse(0.0) + "ms");
    }
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ æ¡ä»¶ç­‰å¾…ï¼šé«˜æ•ˆçš„çº¿ç¨‹åŒæ­¥æœºåˆ¶ï¼Œé¿å…CPUæµªè´¹
ğŸ”¸ æ¡ä»¶å˜é‡ï¼šä¸é”é…åˆä½¿ç”¨çš„åŒæ­¥åŸè¯­ï¼Œæ”¯æŒç²¾ç¡®æ§åˆ¶
ğŸ”¸ è™šå‡å”¤é†’ï¼šå¿…é¡»ç”¨whileå¾ªç¯æ£€æŸ¥æ¡ä»¶ï¼Œè€Œä¸æ˜¯if
ğŸ”¸ è¶…æ—¶æœºåˆ¶ï¼šé¿å…æ— é™ç­‰å¾…ï¼Œæä¾›ç³»ç»Ÿå¥å£®æ€§
ğŸ”¸ å¼‚å¸¸å¤„ç†ï¼šæ­£ç¡®å¤„ç†ä¸­æ–­å’Œå¼‚å¸¸æƒ…å†µ
```

### 9.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ æ¡ä»¶ç­‰å¾… vs è½®è¯¢**
```
æ•ˆç‡å¯¹æ¯”ï¼š
â€¢ æ¡ä»¶ç­‰å¾…ï¼šé›¶CPUæ¶ˆè€—ï¼Œç«‹å³å“åº”
â€¢ è½®è¯¢ï¼šæŒç»­CPUæ¶ˆè€—ï¼Œæœ‰å“åº”å»¶è¿Ÿ

é€‚ç”¨åœºæ™¯ï¼š
â€¢ æ¡ä»¶ç­‰å¾…ï¼šé•¿æ—¶é—´ç­‰å¾…ï¼Œæ¡ä»¶å˜åŒ–ä¸é¢‘ç¹
â€¢ è½®è¯¢ï¼šçŸ­æ—¶é—´ç­‰å¾…ï¼Œæ¡ä»¶å˜åŒ–é¢‘ç¹
```

**ğŸ”¹ signal vs signalAll**
```
signal()ç‰¹ç‚¹ï¼š
â€¢ åªå”¤é†’ä¸€ä¸ªç­‰å¾…çº¿ç¨‹
â€¢ æ€§èƒ½æ›´å¥½ï¼Œèµ„æºç«äº‰å°
â€¢ é€‚ç”¨äºæ¡ä»¶æ»¡è¶³æ—¶åªéœ€è¦ä¸€ä¸ªçº¿ç¨‹ç»§ç»­

signalAll()ç‰¹ç‚¹ï¼š
â€¢ å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
â€¢ æ›´å®‰å…¨ï¼Œé¿å…ä¿¡å·ä¸¢å¤±
â€¢ é€‚ç”¨äºæ¡ä»¶æ»¡è¶³æ—¶å¤šä¸ªçº¿ç¨‹éƒ½å¯ä»¥ç»§ç»­
```

### 9.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ¯ åº”ç”¨åœºæ™¯é€‰æ‹©**
```
èµ„æºç®¡ç†ï¼š
â€¢ è¿æ¥æ± ï¼šç­‰å¾…å¯ç”¨è¿æ¥
â€¢ ç¼“å†²åŒºï¼šç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å¼
â€¢ ä¿¡å·é‡ï¼šæ§åˆ¶å¹¶å‘è®¿é—®æ•°é‡

ä»»åŠ¡åè°ƒï¼š
â€¢ åˆå§‹åŒ–ï¼šç­‰å¾…ç»„ä»¶å‡†å¤‡å°±ç»ª
â€¢ æ‰¹å¤„ç†ï¼šç­‰å¾…æ‰¹é‡æ•°æ®å‡†å¤‡
â€¢ é˜¶æ®µåŒæ­¥ï¼šç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆå½“å‰é˜¶æ®µ

çŠ¶æ€åŒæ­¥ï¼š
â€¢ é…ç½®æ›´æ–°ï¼šç­‰å¾…é…ç½®é‡æ–°åŠ è½½
â€¢ æ•°æ®åˆ·æ–°ï¼šç­‰å¾…ç¼“å­˜æ›´æ–°å®Œæˆ
â€¢ æœåŠ¡çŠ¶æ€ï¼šç­‰å¾…æœåŠ¡å¯åŠ¨å®Œæˆ
```

**ğŸ”§ å®ç°è¦ç‚¹**
```
ä»£ç è§„èŒƒï¼š
â€¢ æ€»æ˜¯åœ¨åŒæ­¥å—å†…æ“ä½œæ¡ä»¶å˜é‡
â€¢ ä½¿ç”¨whileå¾ªç¯æ£€æŸ¥æ¡ä»¶
â€¢ æ­£ç¡®å¤„ç†InterruptedException

æ€§èƒ½ä¼˜åŒ–ï¼š
â€¢ å‡å°‘é”æŒæœ‰æ—¶é—´
â€¢ é¿å…ä¸å¿…è¦çš„signalAll()
â€¢ åˆç†è®¾ç½®è¶…æ—¶æ—¶é—´

é”™è¯¯å¤„ç†ï¼š
â€¢ æä¾›ä¼˜é›…çš„å…³é—­æœºåˆ¶
â€¢ è®°å½•ç­‰å¾…å’Œå”¤é†’çš„æ—¥å¿—
â€¢ ç›‘æ§ç­‰å¾…æ—¶é—´å’Œé¢‘ç‡
```

### 9.4 å­¦ä¹ å»ºè®®


**ğŸ“š æ·±å…¥å­¦ä¹ è·¯å¾„**
```
åŸºç¡€ç†è®ºï¼š
â€¢ æ“ä½œç³»ç»ŸåŒæ­¥åŸè¯­
â€¢ Javaå†…å­˜æ¨¡å‹
â€¢ å¹¶å‘ç¼–ç¨‹ç†è®º

å®è·µæŠ€èƒ½ï¼š
â€¢ java.util.concurrentåŒ…
â€¢ é”çš„å„ç§å®ç°å’Œåº”ç”¨
â€¢ å¹¶å‘è°ƒè¯•å’Œæ€§èƒ½åˆ†æ

è¿›é˜¶ä¸»é¢˜ï¼š
â€¢ æ— é”ç¼–ç¨‹æŠ€æœ¯
â€¢ åˆ†å¸ƒå¼é”å’Œåè°ƒ
â€¢ å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼
```

**âš ï¸ å¸¸è§è¯¯åŒº**
```
è®¾è®¡è¯¯åŒºï¼š
â€¢ è¿‡åº¦ä½¿ç”¨signalAll()å¯¼è‡´æ€§èƒ½é—®é¢˜
â€¢ æ²¡æœ‰è®¾ç½®è¶…æ—¶æœºåˆ¶å¯¼è‡´æ­»ç­‰
â€¢ æ¡ä»¶æ£€æŸ¥é€»è¾‘è¿‡äºå¤æ‚

å®ç°è¯¯åŒºï¼š
â€¢ ä½¿ç”¨ifè€Œä¸æ˜¯whileæ£€æŸ¥æ¡ä»¶
â€¢ å¿˜è®°åœ¨finallyä¸­é‡Šæ”¾é”
â€¢ æ²¡æœ‰æ­£ç¡®å¤„ç†ä¸­æ–­å¼‚å¸¸

è°ƒè¯•è¯¯åŒºï¼š
â€¢ å¿½ç•¥è™šå‡å”¤é†’çš„å¯èƒ½æ€§
â€¢ æ²¡æœ‰ç›‘æ§ç­‰å¾…æ—¶é—´å’Œé¢‘ç‡
â€¢ ç¼ºä¹è¶³å¤Ÿçš„æ—¥å¿—è®°å½•
```

**æ ¸å¿ƒè®°å¿†**ï¼š
- æ¡ä»¶é”æ˜¯é«˜æ•ˆçš„çº¿ç¨‹åè°ƒæœºåˆ¶
- å¿…é¡»ç”¨whileå¾ªç¯æ£€æŸ¥æ¡ä»¶ï¼Œé˜²æ­¢è™šå‡å”¤é†’
- é€‰æ‹©signalè¿˜æ˜¯signalAllè¦æ ¹æ®å…·ä½“åœºæ™¯
- å¼‚å¸¸å¤„ç†å’Œè¶…æ—¶æœºåˆ¶æ˜¯å¥å£®æ€§çš„ä¿è¯
- æ€§èƒ½ä¼˜åŒ–è¦å¹³è¡¡å®‰å…¨æ€§å’Œæ•ˆç‡