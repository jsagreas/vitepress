---
title: 3、事务并发控制策略
---
## 📚 目录

1. [事务并发控制概述](#1-事务并发控制概述)
2. [悲观并发控制PCC策略](#2-悲观并发控制PCC策略)
3. [乐观并发控制OCC策略](#3-乐观并发控制OCC策略)
4. [多版本并发控制MVCC策略](#4-多版本并发控制MVCC策略)
5. [时间戳排序控制](#5-时间戳排序控制)
6. [锁协议深入解析](#6-锁协议深入解析)
7. [策略选择决策树](#7-策略选择决策树)
8. [策略组合优化](#8-策略组合优化)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 事务并发控制概述


### 1.1 什么是事务并发控制


**核心概念**：并发控制就是管理多个事务同时访问数据库时的协调机制，确保数据一致性和事务隔离性。

```
简单理解：
假如银行系统中，张三和李四同时向王五转账:
- 张三转账: 王五余额 1000 → 1500 (+500)
- 李四转账: 王五余额 1000 → 1300 (+300)

没有并发控制：可能最终余额是1300(丢失了张三的500)
有并发控制：最终余额正确是1800
```

### 1.2 并发控制的根本问题


**💡 核心挑战**：如何在保证性能的同时，防止以下问题：

| 问题类型 | **含义** | **举例** |
|---------|----------|----------|
| 🔄 **脏读** | 读到未提交的数据 | A事务修改但未提交，B事务读到了修改值 |
| 🔄 **不可重复读** | 同一事务内多次读取结果不同 | A事务内第一次读100，第二次读150 |
| 👻 **幻读** | 读取范围时出现新记录 | A事务查询所有记录，B事务插入新记录 |
| 💥 **更新丢失** | 并发修改导致更新覆盖 | A和B同时修改，A的修改被B覆盖 |

### 1.3 并发控制策略分类


```
并发控制策略体系:

📍 按控制时机分类:
├─ 悲观控制(PCC): 事前预防
├─ 乐观控制(OCC): 事后检测  
└─ 混合控制: 组合使用

📍 按控制机制分类:
├─ 锁机制: 2PL协议族
├─ 时间戳: 排序机制
├─ 多版本: MVCC机制
└─ 验证机制: 冲突检测
```

---

## 2. 🚫 悲观并发控制PCC策略


### 2.1 悲观控制基本思想


**核心理念**：假设冲突很可能发生，所以提前加锁防止冲突。

```sql
-- 悲观锁示例
BEGIN;
SELECT balance FROM account WHERE id = 1 FOR UPDATE;  -- 加排他锁
UPDATE account SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

**🎯 工作流程**：
```
事务开始
    ↓
获取所需锁
    ↓
执行操作
    ↓  
提交/回滚
    ↓
释放锁
```

### 2.2 两阶段锁协议(2PL)


**📋 基本2PL规则**：
- **扩展阶段**：只能获取锁，不能释放锁
- **收缩阶段**：只能释放锁，不能获取新锁

```sql
-- 2PL协议示例
BEGIN;
-- 扩展阶段：获取锁
SELECT * FROM account WHERE id = 1 FOR UPDATE;
SELECT * FROM account WHERE id = 2 FOR UPDATE;

-- 执行业务逻辑
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;

-- 收缩阶段：提交时释放所有锁
COMMIT;
```

### 2.3 严格两阶段锁(S2PL)


**🔒 S2PL特点**：所有排他锁必须在事务提交/回滚时才能释放。

```sql
-- S2PL在MySQL中的体现
BEGIN;
UPDATE account SET balance = balance - 100 WHERE id = 1;  -- 自动加排他锁
-- 锁会一直持有到事务结束
COMMIT;  -- 此时才释放锁
```

### 2.4 强严格两阶段锁(SS2PL)


**🔐 SS2PL特点**：所有锁(包括共享锁)都必须在事务结束时释放。

```sql
-- SS2PL示例
BEGIN;
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;  -- 共享锁
SELECT * FROM account WHERE id = 2 FOR UPDATE;         -- 排他锁
-- 所有锁都在事务结束时释放
COMMIT;
```

### 2.5 多粒度锁协议


**📏 锁粒度层次**：
```
数据库级别
    ↓
表级别  
    ↓
页级别
    ↓
行级别
```

**🎯 意图锁机制**：
```sql
-- MySQL中的意图锁自动管理
BEGIN;
SELECT * FROM user WHERE id = 1 FOR UPDATE;
-- MySQL自动加：
-- 1. 表级意图排他锁(IX)
-- 2. 行级排他锁(X)
```

**📊 锁兼容矩阵**：

| 请求\持有 | **IS** | **IX** | **S** | **X** |
|-----------|--------|--------|-------|-------|
| **IS** | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ |
| **S** | ✅ | ❌ | ✅ | ❌ |
| **X** | ❌ | ❌ | ❌ | ❌ |

### 2.6 悲观控制的优缺点


**✅ 优点**：
- 冲突检测简单直接
- 数据一致性保证强
- 实现相对简单

**❌ 缺点**：
- 可能造成死锁
- 并发度相对较低
- 长事务影响性能

---

## 3. 🎲 乐观并发控制OCC策略


### 3.1 乐观控制基本思想


**核心理念**：假设冲突很少发生，允许事务并发执行，在提交时检测冲突。

**🔄 三阶段模型**：
```
阶段1: 读取阶段
├─ 读取数据到本地
├─ 记录读写集合  
└─ 执行计算

阶段2: 验证阶段  
├─ 检测冲突
├─ 验证数据版本
└─ 决定提交/回滚

阶段3: 写入阶段
├─ 写入修改
├─ 更新版本号
└─ 完成提交
```

### 3.2 版本号机制实现


```sql
-- 乐观锁的版本号实现
CREATE TABLE account (
    id INT PRIMARY KEY,
    balance DECIMAL(10,2),
    version INT DEFAULT 0  -- 版本号字段
);

-- 乐观锁更新流程
-- 1. 读取数据和版本号
SELECT id, balance, version FROM account WHERE id = 1;
-- 假设读到: balance=1000, version=5

-- 2. 业务计算后更新(检查版本号)
UPDATE account 
SET balance = 900, version = version + 1 
WHERE id = 1 AND version = 5;  -- 版本号必须匹配

-- 3. 检查影响行数判断是否成功
-- affected_rows = 1: 成功
-- affected_rows = 0: 冲突，需要重试
```

### 3.3 冲突检测机制


**📋 检测规则**：
```java
// 冲突检测伪代码
boolean validateTransaction(Transaction Ti) {
    for (Transaction Tj : committedTransactions) {
        if (Tj.commitTime > Ti.startTime) {
            // 检查读写冲突
            if (hasConflict(Ti.readSet, Tj.writeSet) || 
                hasConflict(Ti.writeSet, Tj.writeSet)) {
                return false;  // 检测到冲突
            }
        }
    }
    return true;  // 无冲突
}
```

### 3.4 MySQL中的乐观锁实现


```sql
-- 方法1: 版本号方式
UPDATE user SET name = 'new_name', version = version + 1 
WHERE id = 1 AND version = 10;

-- 方法2: 时间戳方式  
UPDATE user SET name = 'new_name', update_time = NOW()
WHERE id = 1 AND update_time = '2023-01-01 10:00:00';

-- 方法3: 状态标记方式
UPDATE order_item SET quantity = 5, status = 'modified'
WHERE id = 1 AND status = 'normal';
```

### 3.5 乐观控制的优缺点


**✅ 优点**：
- 并发度高，无锁等待
- 无死锁问题
- 读操作不阻塞

**❌ 缺点**：
- 冲突频繁时性能差
- 需要重试机制
- 实现相对复杂

---

## 4. 📚 多版本并发控制MVCC策略


### 4.1 MVCC基本原理


**核心思想**：为每个数据项维护多个版本，读操作访问合适的版本，写操作创建新版本。

```
MVCC版本链示例:
account_id=1的版本链:
[最新] balance=800, version=3, created_by=T3 
   ↓
       balance=900, version=2, created_by=T2
   ↓  
       balance=1000, version=1, created_by=T1 [最老]

不同事务看到不同版本:
- T1开始时: 看到version=1
- T2开始时: 看到version=2  
- T3开始时: 看到version=3
```

### 4.2 MySQL的MVCC实现


**🔍 InnoDB的MVCC机制**：
```sql
-- MySQL InnoDB自动维护版本信息
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    -- 隐藏字段(InnoDB自动维护):
    -- DB_TRX_ID: 创建该记录的事务ID
    -- DB_ROLL_PTR: 指向回滚段的指针
    -- DB_ROW_ID: 行ID(如果没有主键)
);
```

**📋 版本可见性规则**：
```java
// 版本可见性判断伪代码
boolean isVisible(Record record, Transaction currentTx) {
    if (record.trxId == currentTx.id) {
        return true;  // 自己创建的版本可见
    }
    
    if (record.trxId < currentTx.minActiveTrxId) {
        return true;  // 已提交的老事务可见
    }
    
    if (record.trxId在currentTx的活跃事务列表中) {
        return false; // 未提交的事务不可见
    }
    
    return true;  // 其他情况可见
}
```

### 4.3 MVCC的读取模式


**📖 读取类型对比**：

| 读取类型 | **说明** | **示例** | **版本选择** |
|---------|----------|----------|-------------|
| 🔍 **快照读** | 读历史版本 | `SELECT * FROM user` | 根据ReadView选择 |
| 🔒 **当前读** | 读最新版本并加锁 | `SELECT FOR UPDATE` | 总是最新版本 |

```sql
-- 快照读示例
BEGIN;
SELECT * FROM account WHERE id = 1;  -- 快照读，不加锁
-- 即使其他事务修改了数据，这里读到的还是快照版本

-- 当前读示例  
SELECT * FROM account WHERE id = 1 FOR UPDATE;  -- 当前读，加锁
-- 读取最新提交的版本，并对记录加锁
```

### 4.4 MVCC版本清理


**🧹 版本清理机制**：
```
清理时机:
├─ 后台purge线程定期清理
├─ 当版本链过长时触发
└─ 系统空间不足时清理

清理规则:
├─ 没有事务需要的旧版本
├─ 已经完全提交的事务版本
└─ 超过配置保留时间的版本
```

### 4.5 MVCC的优缺点


**✅ 优点**：
- 读写不互相阻塞
- 支持一致性读
- 无需读锁

**❌ 缺点**：
- 存储空间开销
- 版本管理复杂
- 清理机制需要优化

---

## 5. ⏰ 时间戳排序控制


### 5.1 时间戳排序基本原理


**核心思想**：为每个事务分配时间戳，按时间戳顺序调度事务执行。

```
时间戳分配方式:
├─ 系统时钟: 使用当前系统时间
├─ 逻辑计数器: 递增计数器
└─ 混合方式: 时钟+计数器

调度规则:
较早时间戳的事务优先执行
```

### 5.2 基本时间戳排序


**📋 调度规则**：
```java
// 基本时间戳调度伪代码
class TimestampScheduler {
    boolean canRead(Transaction tx, DataItem item) {
        return tx.timestamp >= item.lastWriteTimestamp;
    }
    
    boolean canWrite(Transaction tx, DataItem item) {
        return tx.timestamp >= item.lastReadTimestamp && 
               tx.timestamp >= item.lastWriteTimestamp;
    }
}
```

### 5.3 多版本时间戳排序


**🔄 多版本机制**：
```sql
-- 时间戳版本管理示例
CREATE TABLE account_versions (
    id INT,
    balance DECIMAL(10,2),
    read_timestamp BIGINT,   -- 最后读取时间戳
    write_timestamp BIGINT,  -- 创建时间戳
    INDEX(id, write_timestamp)
);

-- 读取合适版本
SELECT balance FROM account_versions 
WHERE id = 1 AND write_timestamp <= :tx_timestamp
ORDER BY write_timestamp DESC LIMIT 1;
```

### 5.4 时间戳排序的优缺点


**✅ 优点**：
- 无死锁问题
- 实现相对简单
- 吞吐量可预测

**❌ 缺点**：
- 可能产生饥饿
- 时钟同步问题
- 回滚开销大

---

## 6. 🔐 锁协议深入解析


### 6.1 锁类型详解


**📋 MySQL锁类型体系**：
```
MySQL锁分类:
├─ 按作用范围:
│   ├─ 全局锁: FLUSH TABLES WITH READ LOCK
│   ├─ 表锁: LOCK TABLES
│   └─ 行锁: InnoDB行级锁
├─ 按锁模式:
│   ├─ 共享锁(S): LOCK IN SHARE MODE
│   └─ 排他锁(X): FOR UPDATE
└─ 按算法:
    ├─ Record Lock: 记录锁
    ├─ Gap Lock: 间隙锁  
    └─ Next-Key Lock: 记录+间隙锁
```

### 6.2 MySQL锁机制实践


```sql
-- 记录锁示例
SELECT * FROM user WHERE id = 1 FOR UPDATE;
-- 只锁id=1这一行

-- 间隙锁示例(RR隔离级别)
SELECT * FROM user WHERE id > 10 AND id < 20 FOR UPDATE;
-- 锁住(10,20)这个间隙，防止插入

-- Next-Key锁示例
SELECT * FROM user WHERE age >= 25 FOR UPDATE;
-- 锁住age>=25的记录以及相应间隙
```

### 6.3 死锁检测与处理


**💀 死锁检测机制**：
```sql
-- 查看死锁信息
SHOW ENGINE INNODB STATUS;

-- 死锁预防配置
SET SESSION innodb_lock_wait_timeout = 50;  -- 锁等待超时
SET SESSION innodb_deadlock_detect = ON;    -- 开启死锁检测
```

**🔄 死锁处理策略**：
```
MySQL死锁处理:
├─ 自动检测: 等待图算法
├─ 选择牺牲者: 回滚代价最小的事务
├─ 超时机制: innodb_lock_wait_timeout
└─ 错误返回: ERROR 1213 (40001)
```

---

## 7. 🌳 策略选择决策树


### 7.1 并发控制策略选择流程


```
开始选择策略
        ↓
    读操作为主?
    ↓Yes        ↓No
   MVCC      冲突频率高?
             ↓Yes      ↓No  
            悲观锁   乐观锁
                        ↓
                   长事务多?
                   ↓Yes  ↓No
                  悲观锁  乐观锁
```

### 7.2 详细决策矩阵


| 场景特征 | **推荐策略** | **理由** | **注意事项** |
|---------|-------------|----------|-------------|
| 🔍 **读多写少** | MVCC | 读写不冲突 | 注意版本清理 |
| ✏️ **写多读少** | 悲观锁 | 减少重试开销 | 防止死锁 |
| ⚡ **短事务** | 乐观锁 | 并发度高 | 冲突重试成本低 |
| 🕐 **长事务** | 悲观锁 | 避免长时间重试 | 锁粒度优化 |
| 🔥 **高冲突** | 悲观锁+队列 | 减少无效重试 | 排队机制 |
| 🌊 **低冲突** | 乐观锁 | 最大化并发 | 监控冲突率 |

### 7.3 MySQL具体配置建议


```sql
-- 读密集型系统配置
SET SESSION transaction_isolation = 'READ-COMMITTED';  -- 降低隔离级别
SET SESSION innodb_lock_wait_timeout = 5;              -- 快速失败

-- 写密集型系统配置  
SET SESSION transaction_isolation = 'REPEATABLE-READ'; -- 默认隔离级别
SET SESSION innodb_lock_wait_timeout = 50;             -- 增加等待时间

-- 混合负载配置
-- 在应用层面实现乐观锁+悲观锁组合
```

---

## 8. 🎯 策略组合优化


### 8.1 混合并发控制策略


**🔄 动态策略切换**：
```java
// 策略组合示例
class HybridConcurrencyManager {
    ConcurrencyStrategy selectStrategy(Operation op) {
        if (op.isRead() && conflictRate < 0.1) {
            return MVCC_STRATEGY;
        } else if (op.isWrite() && conflictRate > 0.5) {
            return PESSIMISTIC_STRATEGY;
        } else {
            return OPTIMISTIC_STRATEGY;
        }
    }
}
```

### 8.2 分层并发控制


```
分层策略设计:
应用层: 业务锁(分布式锁)
    ↓
数据库层: 事务锁(2PL/MVCC)
    ↓  
存储层: 物理锁(页锁/行锁)
```

### 8.3 策略动态调整


**📊 监控指标**：
```sql
-- 监控锁等待情况
SELECT 
    EVENT_NAME,
    COUNT_STAR as count,
    AVG_TIMER_WAIT/1000000000 as avg_wait_ms
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%lock%' 
ORDER BY avg_wait_ms DESC;

-- 监控事务冲突
SHOW GLOBAL STATUS LIKE 'Innodb_row_lock%';
```

**⚙️ 自适应调整策略**：
```java
// 自适应策略调整
if (lockWaitTime > threshold) {
    // 锁等待时间过长，切换到乐观锁
    switchToOptimistic();
} else if (retryRate > threshold) {
    // 重试率过高，切换到悲观锁  
    switchToPessimistic();
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 悲观控制(PCC): 事前加锁，防止冲突
🔸 乐观控制(OCC): 事后检测，冲突重试
🔸 多版本控制(MVCC): 版本隔离，读写并发
🔸 时间戳排序: 按序执行，避免死锁
🔸 两阶段锁: 扩展+收缩，保证串行化
🔸 策略选择: 根据场景特征选择最优策略
```

### 9.2 关键理解要点


**🔹 策略选择的核心因素**：
```
冲突频率: 决定乐观vs悲观
读写比例: 影响MVCC效果  
事务长度: 影响锁持有时间
并发程度: 决定锁粒度选择
一致性要求: 决定隔离级别
```

**🔹 MySQL实际应用建议**：
```
默认策略: InnoDB的MVCC+行锁
读密集: 降低隔离级别，使用快照读
写密集: 合理使用悲观锁，控制事务大小  
高并发: 乐观锁+重试机制
长事务: 悲观锁+锁粒度优化
```

### 9.3 实际应用价值


**🎯 业务场景应用**：
- **电商系统**：库存扣减用乐观锁+版本号
- **金融系统**：账户操作用悲观锁+严格2PL
- **社交系统**：内容展示用MVCC+快照读
- **游戏系统**：排行榜用时间戳+乐观锁

**🔧 性能优化实践**：
- **监控并发指标**：锁等待、死锁、重试率
- **动态策略调整**：根据负载特征切换策略
- **合理事务设计**：控制事务大小和持续时间
- **索引优化配合**：减少锁粒度和锁持有时间

**核心记忆**：
- 悲观假设冲突必然发生，提前预防
- 乐观假设冲突很少发生，事后检测  
- MVCC通过版本机制实现读写并发
- 策略选择要基于实际业务场景特征
- 组合使用多种策略效果最佳