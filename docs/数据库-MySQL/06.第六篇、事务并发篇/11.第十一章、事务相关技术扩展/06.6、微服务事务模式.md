---
title: 6、微服务事务模式
---
## 📚 目录

1. [微服务事务模式概述](#1-微服务事务模式概述)
2. [Saga事务模式](#2-Saga事务模式)
3. [TCC事务模式](#3-TCC事务模式)
4. [2PC分布式事务](#4-2PC分布式事务)
5. [事件溯源模式](#5-事件溯源模式)
6. [补偿事务模式](#6-补偿事务模式)
7. [模式对比与选择](#7-模式对比与选择)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 微服务事务模式概述


### 1.1 为什么需要微服务事务模式


微服务架构把原本的单体应用拆分成多个独立的服务，每个服务有自己的数据库。这样就带来了一个问题：**如何保证跨多个服务的操作要么全部成功，要么全部失败？**

```
传统单体应用：
┌─────────────────────────────┐
│       订单系统              │
│  ┌─────────┬─────────────┐  │
│  │订单表   │ 库存表      │  │ ← 一个数据库，用数据库事务
│  │        │            │  │
│  └─────────┴─────────────┘  │
└─────────────────────────────┘

微服务架构：
┌─────────────┐     ┌─────────────┐
│  订单服务    │     │  库存服务    │
│ ┌─────────┐ │     │ ┌─────────┐ │
│ │订单数据库│ │     │ │库存数据库│ │ ← 多个数据库，数据库事务无法跨服务
│ └─────────┘ │     │ └─────────┘ │
└─────────────┘     └─────────────┘
```

**核心挑战**：
- **数据一致性**：如何保证所有服务的数据状态一致
- **网络延迟**：服务间通信可能失败或超时
- **服务故障**：某个服务可能暂时不可用
- **性能要求**：不能因为事务处理影响系统响应速度

### 1.2 微服务事务的基本原则


> 💡 **CAP定理提醒**：在分布式系统中，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)三者不可能同时满足

**ACID vs BASE**：
```
传统ACID（强一致性）：
✓ 原子性：要么全做，要么全不做
✓ 一致性：数据始终保持一致状态  
✓ 隔离性：事务间不相互影响
✓ 持久性：提交后永久保存

微服务BASE（最终一致性）：
✓ 基本可用：系统大部分时间可用
✓ 软状态：允许数据在一段时间内不一致
✓ 最终一致性：系统最终会达到一致状态
```

---

## 2. 📋 Saga事务模式


### 2.1 Saga模式核心思想


**Saga模式**就像是把一个大事务拆分成多个小的本地事务，每个小事务都可以独立提交。如果中间某个步骤失败了，就执行**补偿操作**来撤销之前已经完成的步骤。

```
电商下单流程示例：
步骤1：创建订单    → 成功 ✓
步骤2：扣减库存    → 成功 ✓  
步骤3：扣减积分    → 失败 ✗

补偿流程：
步骤3失败 → 恢复库存（补偿步骤2）→ 取消订单（补偿步骤1）
```

### 2.2 Saga模式的两种实现方式


#### 🎭 编排模式（Orchestration）


有一个**中央协调器**来控制整个事务流程，就像乐队指挥一样。

```
协调器工作流程：
┌─────────────────────────────────────┐
│           Saga协调器                │
│  ┌─────────────────────────────────┐│
│  │ 1. 调用订单服务                 ││
│  │ 2. 调用库存服务                 ││  
│  │ 3. 调用支付服务                 ││
│  │ 4. 如果失败，执行补偿           ││
│  └─────────────────────────────────┘│
└─────────────────────────────────────┘
          │        │        │
          ▼        ▼        ▼
    ┌─────────┐┌─────────┐┌─────────┐
    │订单服务││库存服务││支付服务│
    └─────────┘└─────────┘└─────────┘
```

**简化代码示例**：
```java
@Service
public class OrderSagaOrchestrator {
    
    public void processOrder(OrderRequest request) {
        try {
            // 步骤1：创建订单
            Long orderId = orderService.createOrder(request);
            
            // 步骤2：扣减库存
            inventoryService.deductStock(request.getProductId(), request.getQuantity());
            
            // 步骤3：处理支付
            paymentService.processPayment(request.getPaymentInfo());
            
            // 全部成功，完成订单
            orderService.completeOrder(orderId);
            
        } catch (Exception e) {
            // 执行补偿操作
            compensate(orderId, request);
        }
    }
    
    private void compensate(Long orderId, OrderRequest request) {
        // 补偿：恢复库存
        inventoryService.restoreStock(request.getProductId(), request.getQuantity());
        // 补偿：取消订单
        orderService.cancelOrder(orderId);
    }
}
```

#### 🎪 编舞模式（Choreography）


没有中央协调器，每个服务知道自己完成后应该通知哪个服务，就像群体舞蹈一样。

```
事件驱动流程：
订单服务 ──发布事件──→ 库存服务 ──发布事件──→ 支付服务
   ↑                                        │
   └──────────── 如果支付失败，发布补偿事件 ──┘
```

### 2.3 Saga模式的优缺点


> ⭐ **优点**：
> - 实现相对简单，容易理解
> - 性能较好，没有长时间锁定资源
> - 适合业务流程较长的场景

> ⚠️ **缺点**：
> - 可能出现数据不一致的中间状态
> - 补偿逻辑复杂，需要仔细设计
> - 不适合对一致性要求极高的场景

---

## 3. 🔄 TCC事务模式


### 3.1 TCC模式核心概念


**TCC**是Try-Confirm-Cancel的缩写，把每个操作分成三个阶段：

```
TCC三阶段解释：
┌─────────────────────────────────────────┐
│ Try阶段：   尝试执行，预留资源但不提交   │
│ Confirm阶段：确认提交，完成业务操作     │  
│ Cancel阶段： 取消操作，释放预留资源     │
└─────────────────────────────────────────┘
```

就像你在网上买东西：
- **Try**：把商品放到购物车，商家预留库存
- **Confirm**：确认付款，商家真正扣减库存并发货
- **Cancel**：取消订单，商家释放预留的库存

### 3.2 TCC实现流程


```
TCC完整流程图：
                  TCC事务管理器
                      │
    ┌─────────────────┼─────────────────┐
    │                 │                 │
    ▼                 ▼                 ▼
订单服务          库存服务          支付服务
    │                 │                 │
    ▼                 ▼                 ▼
第一阶段-Try：
tryCreateOrder   tryDeductStock   tryDeductBalance
    │                 │                 │
    ▼                 ▼                 ▼
第二阶段-Confirm（全部Try成功）：
confirmOrder     confirmStock     confirmPayment

第二阶段-Cancel（任何Try失败）：
cancelOrder      cancelStock      cancelPayment
```

**简化代码示例**：
```java
// 库存服务的TCC实现
@Service
public class InventoryTccService {
    
    // Try阶段：预留库存
    public boolean tryDeductStock(String productId, int quantity) {
        // 检查库存是否足够
        if (getAvailableStock(productId) >= quantity) {
            // 预留库存（冻结，但不真正扣减）
            freezeStock(productId, quantity);
            return true;
        }
        return false;
    }
    
    // Confirm阶段：确认扣减
    public void confirmDeductStock(String productId, int quantity) {
        // 将冻结的库存真正扣减
        actualDeductStock(productId, quantity);
    }
    
    // Cancel阶段：释放预留
    public void cancelDeductStock(String productId, int quantity) {
        // 释放冻结的库存
        unfreezeStock(productId, quantity);
    }
}
```

### 3.3 TCC模式的特点


> 🔑 **核心特点**：
> - **强一致性**：Try阶段就检查所有条件，成功率高
> - **资源预留**：提前锁定资源，避免并发问题
> - **两阶段提交**：确保最终数据一致性

> ⚠️ **注意事项**：
> - 每个服务都要实现三个接口，开发复杂度高
> - Try阶段需要预留资源，可能影响系统并发性能
> - 需要处理网络超时、重复调用等问题

---

## 4. 🤝 2PC分布式事务


### 4.1 2PC基本原理


**2PC（Two-Phase Commit）**两阶段提交，就像团队决策一样：先问所有人能不能做，都说能做了再让大家一起做。

```
2PC两个阶段：
阶段一：准备阶段（Prepare）
协调者：大家准备好了吗？
参与者A：我准备好了 ✓
参与者B：我准备好了 ✓  
参与者C：我还没准备好 ✗

阶段二：提交阶段（Commit/Abort）  
协调者：C没准备好，大家都回滚
参与者A：好的，我回滚
参与者B：好的，我回滚
参与者C：好的，我回滚
```

### 4.2 2PC详细流程


```
2PC详细交互流程：
协调者                     参与者A    参与者B    参与者C
   │                         │         │         │
   │─────Prepare请求─────────→│         │         │
   │─────Prepare请求─────────→│─────────│         │
   │─────Prepare请求─────────→│─────────│─────────│
   │                         │         │         │
   │←────准备就绪(Yes)───────│         │         │
   │←────准备就绪(Yes)───────│─────────│         │
   │←────无法准备(No)────────│─────────│─────────│
   │                         │         │         │
   │─────Rollback命令────────→│         │         │
   │─────Rollback命令────────→│─────────│         │
   │─────Rollback命令────────→│─────────│─────────│
   │                         │         │         │
   │←────回滚完成───────────│         │         │
   │←────回滚完成───────────│─────────│         │
   │←────回滚完成───────────│─────────│─────────│
```

### 4.3 2PC的问题与改进


> ⚠️ **2PC的问题**：
> - **阻塞问题**：参与者在准备阶段会锁定资源，直到收到最终指令
> - **单点故障**：协调者挂了，所有参与者都会被阻塞
> - **数据不一致**：网络分区可能导致部分节点收不到指令

**3PC改进（了解即可）**：
```
3PC增加了预提交阶段：
阶段1：CanCommit - 询问是否可以提交
阶段2：PreCommit - 预提交，但还可以中止
阶段3：DoCommit - 真正提交
```

**在微服务中的应用**：
```java
// 使用Seata框架简化2PC
@GlobalTransactional  // 全局事务注解
public void createOrder(OrderRequest request) {
    // 这些操作会自动加入分布式事务
    orderService.create(request);
    inventoryService.deduct(request.getProductId(), request.getQuantity());
    paymentService.pay(request.getPaymentInfo());
    // 如果任何一步失败，自动回滚所有操作
}
```

---

## 5. 📚 事件溯源模式


### 5.1 事件溯源核心理念


**事件溯源**不存储数据的当前状态，而是存储导致当前状态的所有事件序列。就像银行流水一样，不直接存储你的余额，而是存储每一笔收入和支出记录。

```
传统存储方式：
┌─────────────────┐
│ 用户表          │
│ id | name | age │
│ 1  | 张三 | 25  │ ← 只存储当前状态
└─────────────────┘

事件溯源方式：
┌─────────────────────────────────────┐
│ 事件表                               │
│ 事件ID | 用户ID | 事件类型 | 数据   │
│ 1     | 1     | 创建用户 | {name:"张三", age:23} │
│ 2     | 1     | 更新年龄 | {age:24}             │
│ 3     | 1     | 更新年龄 | {age:25}             │ ← 存储所有变化事件
└─────────────────────────────────────┘
当前状态 = 重放所有事件得到
```

### 5.2 事件溯源在微服务事务中的应用


在微服务环境中，每个服务发布事件，其他服务监听事件并更新自己的状态：

```
事件驱动的订单流程：
订单服务 ──发布──→ [订单创建事件] ──→ 库存服务（扣减库存）
   ↓                                    ↓
 更新订单状态                          发布库存扣减事件
   ↓                                    ↓
支付服务（监听订单事件）              积分服务（监听订单事件）
   ↓                                    ↓
处理支付并发布支付事件                  增加积分
```

**简化实现示例**：
```java
// 事件存储
@Entity
public class OrderEvent {
    private Long id;
    private String orderId;
    private String eventType;
    private String eventData;
    private LocalDateTime timestamp;
}

// 订单聚合根
@Service
public class OrderAggregate {
    
    public void createOrder(OrderRequest request) {
        // 发布订单创建事件
        OrderCreatedEvent event = new OrderCreatedEvent(request);
        eventStore.save(event);
        eventPublisher.publish(event);
    }
    
    // 从事件重建当前状态
    public Order getCurrentState(String orderId) {
        List<OrderEvent> events = eventStore.findByOrderId(orderId);
        Order order = new Order();
        for (OrderEvent event : events) {
            order.apply(event);  // 重放事件
        }
        return order;
    }
}
```

### 5.3 事件溯源的优势与挑战


> ⭐ **优势**：
> - **完整历史**：可以重建任意时刻的数据状态
> - **审计友好**：天然的审计日志
> - **天然解耦**：服务通过事件松耦合

> ⚠️ **挑战**：
> - **复杂查询**：查询当前状态需要重放事件，性能可能较差
> - **事件版本**：事件结构变化时的兼容性问题
> - **数据一致性**：事件发布失败可能导致不一致

---

## 6. 🔧 补偿事务模式


### 6.1 补偿事务基本概念


**补偿事务**就是为每个正向操作设计一个反向操作，当流程失败时执行反向操作来撤销已经完成的部分。

```
补偿事务示例：
正向操作：转账A → B（100元）
补偿操作：转账B → A（100元）

订单流程的补偿设计：
┌─────────────────┬─────────────────┐
│   正向操作       │   补偿操作       │
├─────────────────┼─────────────────┤
│ 创建订单        │ 删除订单        │
│ 扣减库存        │ 恢复库存        │  
│ 扣除积分        │ 返还积分        │
│ 发送通知        │ 发送取消通知    │
└─────────────────┴─────────────────┘
```

### 6.2 补偿事务的设计原则


> 💡 **设计原则**：
> - **幂等性**：补偿操作可以重复执行而不会产生副作用
> - **可补偿性**：每个操作都要有对应的补偿操作
> - **顺序性**：补偿通常按照正向操作的逆序执行

**实现示例**：
```java
// 补偿事务接口
public interface CompensationAction {
    void execute();      // 执行正向操作
    void compensate();   // 执行补偿操作
}

// 订单补偿操作
@Component
public class OrderCompensationAction implements CompensationAction {
    
    @Override
    public void execute() {
        // 创建订单
        orderService.createOrder(orderRequest);
    }
    
    @Override  
    public void compensate() {
        // 补偿：取消订单（幂等操作）
        orderService.cancelOrderIfExists(orderRequest.getOrderId());
    }
}

// 补偿事务管理器
@Service
public class CompensationTransactionManager {
    private List<CompensationAction> actions = new ArrayList<>();
    
    public void addAction(CompensationAction action) {
        actions.add(action);
    }
    
    public void executeAll() {
        try {
            for (CompensationAction action : actions) {
                action.execute();
            }
        } catch (Exception e) {
            // 逆序执行补偿
            Collections.reverse(actions);
            for (CompensationAction action : actions) {
                try {
                    action.compensate();
                } catch (Exception compensateException) {
                    // 记录补偿失败日志
                    log.error("补偿操作失败", compensateException);
                }
            }
        }
    }
}
```

### 6.3 补偿事务的注意事项


> ⚠️ **重要提醒**：
> - **不是所有操作都能补偿**：比如发送邮件、调用第三方接口
> - **补偿可能失败**：需要重试机制和人工介入
> - **业务语义**：补偿操作要符合业务逻辑，不能简单地反向操作

---

## 7. 🎯 模式对比与选择


### 7.1 各种模式对比表


| 模式 | **一致性** | **性能** | **复杂度** | **适用场景** |
|------|-----------|---------|-----------|-------------|
| 🎭 **Saga** | `最终一致` | `高` | `中等` | `长业务流程、对一致性要求不严格` |
| 🔄 **TCC** | `强一致` | `中等` | `高` | `对一致性要求高、业务步骤明确` |
| 🤝 **2PC** | `强一致` | `低` | `中等` | `传统企业应用、一致性要求极高` |
| 📚 **事件溯源** | `最终一致` | `中等` | `高` | `需要完整历史、审计要求高` |
| 🔧 **补偿事务** | `最终一致` | `高` | `中等` | `操作可逆、错误恢复重要` |

### 7.2 选择决策树


```
选择微服务事务模式的决策流程：
                    开始
                     │
              ┌──────▼──────┐
              │ 对一致性要求 │
              │   是否严格   │
              └──────┬──────┘
                     │
         ┌───────────┴───────────┐
         │                       │
    ┌────▼────┐             ┌────▼────┐
    │  严格   │             │ 不严格  │
    └────┬────┘             └────┬────┘
         │                       │
    ┌────▼────┐             ┌────▼────┐
    │性能要求高│             │业务流程长│
    └────┬────┘             └────┬────┘
         │                       │
    ┌────▼────┐         ┌───────┴────────┐
    │   TCC   │         │                │
    └─────────┘    ┌────▼────┐      ┌───▼───┐
                   │  Saga   │      │事件溯源│
                   └─────────┘      └───────┘
```

### 7.3 实际项目中的选择建议


> 🎯 **电商系统建议**：
> - **订单流程**：使用Saga模式，业务流程长，允许最终一致性
> - **支付流程**：使用TCC模式，对一致性要求严格
> - **库存管理**：使用补偿事务，便于错误恢复

> 🏦 **金融系统建议**：
> - **转账业务**：使用2PC或TCC，保证强一致性
> - **积分系统**：使用Saga或补偿事务，允许延迟一致性
> - **审计日志**：使用事件溯源，保留完整操作历史

**混合使用示例**：
```java
@Service
public class OrderProcessService {
    
    // 核心订单操作用TCC保证强一致性
    @TccTransaction
    public void processPayment(PaymentRequest request) {
        paymentService.tryPay(request);
        inventoryService.tryDeduct(request);
    }
    
    // 非核心操作用Saga保证最终一致性  
    @SagaTransaction
    public void processNotification(OrderEvent event) {
        emailService.sendEmail(event);
        smsService.sendSms(event);
        pushService.sendPush(event);
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 微服务事务挑战：跨服务数据一致性、网络故障、性能要求
🔸 ACID vs BASE：强一致性 vs 最终一致性的权衡
🔸 五种核心模式：Saga、TCC、2PC、事件溯源、补偿事务
🔸 模式选择原则：根据一致性要求、性能需求、业务复杂度选择
🔸 实际应用：不同业务场景使用不同模式，可以混合使用
```

### 8.2 关键理解要点


**🔹 为什么需要这些模式**：
```
单体应用：
- 数据库事务天然保证ACID
- 操作失败直接回滚，简单可靠

微服务应用：
- 跨服务无法使用数据库事务
- 需要应用层面的事务协调机制
- 要在一致性、可用性、性能间权衡
```

**🔹 各模式的核心思想**：
```
Saga：大事务拆小事务，失败就补偿
TCC：先预留资源，再确认提交
2PC：两阶段协调，保证强一致性
事件溯源：存储事件流，重放得状态
补偿事务：正向操作配反向操作
```

**🔹 选择模式的关键因素**：
```
一致性要求：
- 强一致性 → TCC、2PC
- 最终一致性 → Saga、事件溯源、补偿事务

性能要求：
- 高性能 → Saga、补偿事务
- 性能次要 → 2PC

业务复杂度：
- 复杂业务 → 事件溯源
- 简单业务 → Saga、补偿事务
```

### 8.3 实际应用价值


- **电商平台**：订单、支付、库存的分布式事务处理
- **金融系统**：转账、清算的强一致性保证
- **物流系统**：多环节业务流程的最终一致性
- **社交应用**：用户操作的事件溯源和审计

**💡 学习建议**：
- 从简单的Saga模式开始学习和实践
- 理解每种模式的适用场景，不要追求万能方案
- 在实际项目中根据业务特点选择合适的模式
- 可以在同一个系统中混合使用多种模式

**核心记忆**：
- 微服务事务本质是分布式一致性问题
- 没有银弹，要根据业务特点选择模式
- 最终一致性在很多场景下是可接受的
- 保持简单，优先选择理解和维护成本低的方案