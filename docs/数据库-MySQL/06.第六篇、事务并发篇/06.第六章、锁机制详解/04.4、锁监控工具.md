---
title: 4、锁监控工具
---
## 📚 目录

1. [锁监控工具概述](#1-锁监控工具概述)
2. [SHOW ENGINE INNODB STATUS详解](#2-SHOW-ENGINE-INNODB-STATUS详解)
3. [performance_schema锁监控表](#3-performance_schema锁监控表)
4. [INFORMATION_SCHEMA锁视图](#4-INFORMATION_SCHEMA锁视图)
5. [sys库锁监控视图](#5-sys库锁监控视图)
6. [第三方监控工具](#6-第三方监控工具)
7. [锁等待分析方法](#7-锁等待分析方法)
8. [死锁日志分析](#8-死锁日志分析)
9. [锁优化策略](#9-锁优化策略)
10. [监控告警机制](#10-监控告警机制)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔍 锁监控工具概述


### 1.1 为什么需要锁监控


**锁问题的影响**：
- 🐌 **性能下降**：事务长时间等待，响应变慢
- 💥 **死锁发生**：事务互相等待，系统阻塞
- 😰 **用户体验差**：页面卡顿，操作超时

**监控的作用**：
```
发现问题 → 分析原因 → 优化解决 → 预防再发
    ↓         ↓         ↓         ↓
  慢查询    锁等待    索引优化   代码改进
```

### 1.2 监控工具完整体系


**MySQL内置工具**：
- **SHOW ENGINE INNODB STATUS**：实时锁状态查看
- **performance_schema**：详细的锁监控表
- **INFORMATION_SCHEMA**：锁信息视图
- **sys库**：简化的锁监控视图

**第三方工具**：
- **Percona Toolkit**：专业的MySQL工具包
- **MySQL Workbench**：图形化监控界面
- **Prometheus + Grafana**：现代化监控体系

### 1.3 监控数据分析方法


**分析维度**：
```
┌─ 锁类型 ── 表锁、行锁、MDL锁
├─ 等待时间 ── 短期、长期、超时
├─ 影响范围 ── 单表、多表、全局
└─ 频发程度 ── 偶发、频繁、持续
```

---

## 2. 📊 SHOW ENGINE INNODB STATUS详解


### 2.1 基本使用方法


```sql
-- 查看InnoDB引擎当前状态
SHOW ENGINE INNODB STATUS\G
```

**命令特点**：
- 🔄 **实时状态**：显示当前时刻的锁状态
- 📊 **信息全面**：包含事务、锁、缓冲池等信息
- 💡 **问题诊断**：快速定位锁争用和死锁

### 2.2 锁信息解读


**事务部分（TRANSACTIONS）**：
```
---TRANSACTION 421693775190640, ACTIVE 15 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 8, OS thread handle 140234868246272, query id 1599
localhost root updating
UPDATE users SET balance = balance - 100 WHERE id = 1
```

**关键信息解读**：
- **ACTIVE 15 sec**：事务已活跃15秒
- **LOCK WAIT**：正在等待锁
- **1 row lock(s)**：持有1个行锁
- **thread id 8**：MySQL线程ID

### 2.3 死锁信息查看


**最近死锁记录**：
```
------------------------
LATEST DETECTED DEADLOCK
------------------------
2024-01-20 11:30:15 0x7f8b2c001700
*** (1) TRANSACTION:
TRANSACTION 421693775190641, ACTIVE 5 sec starting index read
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2 page no 3 n bits 72 index PRIMARY
*** (2) TRANSACTION:
TRANSACTION 421693775190642, ACTIVE 3 sec starting index read
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 2 page no 3 n bits 72 index PRIMARY
*** WE ROLL BACK TRANSACTION (1)
```

> 💡 **解读技巧**：关注事务ID、等待的锁、持有的锁，以及最终被回滚的事务

---

## 3. 📈 performance_schema锁监控表


### 3.1 启用performance_schema


```sql
-- 检查是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 启用锁监控（需要重启）
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%lock%';
```

### 3.2 核心监控表


**data_locks表**：
```sql
-- 查看当前所有锁
SELECT 
    OBJECT_NAME,
    LOCK_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    THREAD_ID
FROM performance_schema.data_locks;
```

**data_lock_waits表**：
```sql
-- 查看锁等待关系
SELECT 
    requesting_thread_id,
    blocking_thread_id,
    requested_lock_id,
    blocking_lock_id
FROM performance_schema.data_lock_waits;
```

### 3.3 实用查询示例


**查找锁等待**：
```sql
SELECT 
    r.trx_id AS requesting_trx,
    r.trx_mysql_thread_id AS requesting_thread,
    b.trx_id AS blocking_trx,
    b.trx_mysql_thread_id AS blocking_thread,
    w.requested_lock_id,
    w.blocking_lock_id
FROM performance_schema.data_lock_waits w
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_engine_transaction_id
JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_engine_transaction_id;
```

---

## 4. 🗄️ INFORMATION_SCHEMA锁视图


### 4.1 innodb_trx事务视图


```sql
-- 查看所有活跃事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.innodb_trx;
```

**字段说明**：
- **trx_state**：事务状态（RUNNING、LOCK WAIT）
- **trx_started**：事务开始时间
- **trx_query**：当前执行的SQL

### 4.2 innodb_locks锁视图


```sql
-- 查看当前锁信息（MySQL 5.7及之前）
SELECT 
    lock_id,
    lock_trx_id,
    lock_mode,
    lock_type,
    lock_table,
    lock_index
FROM information_schema.innodb_locks;
```

### 4.3 processlist进程视图


```sql
-- 查看所有连接状态
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM information_schema.processlist
WHERE STATE LIKE '%lock%';
```

---

## 5. 🛠️ sys库锁监控视图


### 5.1 sys库简介


**sys库的优势**：
- 📊 **预定义视图**：常用的监控查询已经封装好
- 🎯 **简化操作**：复杂的查询变成简单的SELECT
- 📈 **性能友好**：优化过的查询逻辑

### 5.2 核心锁监控视图


**innodb_lock_waits视图**：
```sql
-- 查看锁等待详情
SELECT 
    wait_started,
    wait_age,
    locked_table,
    locked_index,
    locked_type,
    waiting_query,
    blocking_query
FROM sys.innodb_lock_waits;
```

**schema_table_lock_waits视图**：
```sql
-- 查看表级锁等待
SELECT 
    object_schema,
    object_name,
    waiting_thread_id,
    waiting_query,
    blocking_thread_id,
    blocking_query
FROM sys.schema_table_lock_waits;
```

### 5.3 实用监控查询


**长时间锁等待**：
```sql
-- 查找等待超过30秒的锁
SELECT * FROM sys.innodb_lock_waits 
WHERE wait_age > 30;
```

**频繁锁等待的表**：
```sql
-- 按表统计锁等待次数
SELECT 
    locked_table,
    COUNT(*) as wait_count
FROM sys.innodb_lock_waits 
GROUP BY locked_table 
ORDER BY wait_count DESC;
```

---

## 6. 🔧 第三方监控工具


### 6.1 Percona Toolkit


**pt-deadlock-logger**：
```bash
# 监控死锁并记录到文件
pt-deadlock-logger --dest /var/log/mysql-deadlocks.log \
    --user=root --password=xxx
```

**pt-kill**：
```bash
# 杀死长时间运行的查询
pt-kill --victims all --interval 5 \
    --busy-time 60 --kill --print
```

### 6.2 MySQL Workbench


**Performance Dashboard**：
- 📊 **实时监控**：CPU、内存、锁等指标
- 🔍 **查询分析**：慢查询和锁等待分析
- 📈 **历史趋势**：性能指标的时间趋势

### 6.3 Prometheus + Grafana


**mysql_exporter配置**：
```yaml
# 监控MySQL锁指标
- name: mysql_info_schema_innodb_trx
  query: "SELECT COUNT(*) as count FROM information_schema.innodb_trx"
  metrics:
    - count:
        usage: "GAUGE"
        description: "Number of active transactions"
```

---

## 7. 🔍 锁等待分析方法


### 7.1 识别锁等待问题


**问题症状**：
```
应用层面：
- 页面响应慢 ⏰
- 操作超时 ❌
- 用户投诉增多 😤

数据库层面：
- 活跃事务增多 📈
- 锁等待时间长 ⏳
- CPU使用率低但响应慢 🐌
```

### 7.2 分析步骤


**Step 1：确认是否存在锁等待**：
```sql
-- 快速检查
SELECT COUNT(*) FROM information_schema.innodb_trx 
WHERE trx_state = 'LOCK WAIT';
```

**Step 2：找出等待关系**：
```sql
-- 查看具体的锁等待
SELECT * FROM sys.innodb_lock_waits;
```

**Step 3：分析根本原因**：
```sql
-- 查看阻塞查询的详情
SELECT 
    trx_id,
    trx_started,
    trx_query,
    trx_rows_locked
FROM information_schema.innodb_trx 
WHERE trx_mysql_thread_id = <blocking_thread_id>;
```

### 7.3 常见锁等待场景


| 场景 | **表现** | **原因** | **解决方法** |
|------|---------|----------|-------------|
| **大事务阻塞** | 大量小事务等待 | 长时间未提交的事务 | 拆分大事务，及时提交 |
| **热点行争用** | 同一行频繁冲突 | 业务设计问题 | 优化业务逻辑，避免热点 |
| **索引缺失** | 表级锁升级 | WHERE条件无索引 | 添加合适的索引 |
| **死锁频发** | 事务被频繁回滚 | 事务顺序不一致 | 统一锁定顺序 |

---

## 8. 💀 死锁日志分析


### 8.1 开启死锁日志


```sql
-- 开启InnoDB监控（会记录死锁信息）
SET GLOBAL innodb_print_all_deadlocks = ON;

-- 查看错误日志设置
SHOW VARIABLES LIKE 'log_error';
```

### 8.2 死锁日志格式


**典型死锁日志**：
```
2024-01-20 11:30:15 0x7f8b2c001700
*** (1) TRANSACTION:
TRANSACTION 421693775190641, ACTIVE 5 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 15, OS thread handle 140234867182336, query id 1854
localhost root updating
UPDATE accounts SET balance = balance - 100 WHERE id = 1

*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2 page no 3 n bits 72 index PRIMARY of table `test`.`accounts` 
trx id 421693775190641 lock_mode X locks rec but not gap waiting

*** (2) TRANSACTION:
TRANSACTION 421693775190642, ACTIVE 3 sec starting index read
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 16, OS thread handle 140234868246272, query id 1855
localhost root updating
UPDATE accounts SET balance = balance + 100 WHERE id = 2

*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 2 page no 3 n bits 72 index PRIMARY of table `test`.`accounts` 
trx id 421693775190642 lock_mode X locks rec but not gap

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 2 page no 3 n bits 72 index PRIMARY of table `test`.`accounts` 
trx id 421693775190642 lock_mode X locks rec but not gap waiting

*** WE ROLL BACK TRANSACTION (1)
```

### 8.3 死锁分析要点


**分析重点**：
- 🔍 **事务执行的SQL**：了解业务逻辑
- 🔒 **锁的类型和范围**：行锁还是表锁
- ⏰ **事务的执行时间**：是否有长事务
- 🔄 **循环等待关系**：谁等待谁

**预防措施**：
```sql
-- 统一锁定顺序（避免死锁）
-- ❌ 错误的做法
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- ✅ 正确的做法（按ID排序）
UPDATE accounts SET balance = balance - 100 WHERE id = LEAST(1,2);
UPDATE accounts SET balance = balance + 100 WHERE id = GREATEST(1,2);
```

---

## 9. ⚡ 锁优化策略


### 9.1 减少锁争用


**缩短事务时间**：
```sql
-- ❌ 不好的做法
BEGIN;
SELECT * FROM products WHERE category = 'electronics';
-- 长时间的业务逻辑处理...
UPDATE products SET status = 'processed' WHERE category = 'electronics';
COMMIT;

-- ✅ 好的做法
-- 先查询，业务逻辑处理完后再开启事务
SELECT id FROM products WHERE category = 'electronics';
-- 业务逻辑处理...
BEGIN;
UPDATE products SET status = 'processed' WHERE id IN (1,2,3);
COMMIT;
```

**使用更精确的WHERE条件**：
```sql
-- ❌ 锁定范围过大
UPDATE users SET status = 'active' WHERE age > 18;

-- ✅ 使用索引，减少锁定范围
UPDATE users SET status = 'active' WHERE id IN (1,2,3,4,5);
```

### 9.2 优化索引设计


**避免全表扫描**：
```sql
-- 为WHERE条件添加索引
CREATE INDEX idx_user_age ON users(age);
CREATE INDEX idx_product_category ON products(category);

-- 复合索引优化
CREATE INDEX idx_order_status_date ON orders(status, created_date);
```

### 9.3 事务设计优化


**拆分大事务**：
```sql
-- ❌ 大事务
BEGIN;
UPDATE table1 SET ... WHERE ...;  -- 影响100万行
UPDATE table2 SET ... WHERE ...;  -- 影响50万行
COMMIT;

-- ✅ 拆分处理
-- 分批处理，每批1000行
DELIMITER $$
CREATE PROCEDURE batch_update()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    
    REPEAT
        BEGIN;
        UPDATE table1 SET ... WHERE ... LIMIT batch_size;
        COMMIT;
        
        SELECT ROW_COUNT() INTO @affected_rows;
        SET done = (@affected_rows < batch_size);
    UNTIL done END REPEAT;
END$$
DELIMITER ;
```

---

## 10. 🚨 监控告警机制


### 10.1 关键监控指标


**锁相关指标**：
```sql
-- 活跃事务数
SELECT COUNT(*) as active_trx FROM information_schema.innodb_trx;

-- 锁等待事务数
SELECT COUNT(*) as lock_wait_trx FROM information_schema.innodb_trx 
WHERE trx_state = 'LOCK WAIT';

-- 平均锁等待时间
SELECT AVG(wait_age) as avg_wait_time FROM sys.innodb_lock_waits;

-- 死锁频率（需要从错误日志统计）
```

### 10.2 告警阈值设定


| 指标 | **告警阈值** | **严重程度** | **处理建议** |
|------|-------------|-------------|-------------|
| **活跃事务数** | >100 | ⚠️ 警告 | 检查是否有大事务 |
| **锁等待事务数** | >10 | 🚨 严重 | 立即分析锁等待原因 |
| **锁等待时间** | >30秒 | 🚨 严重 | 考虑杀死阻塞查询 |
| **死锁频率** | >5次/小时 | ⚠️ 警告 | 优化事务逻辑 |

### 10.3 自动化处理


**监控脚本示例**：
```bash
#!/bin/bash
# lock_monitor.sh

MYSQL_CMD="mysql -u monitor -p$password"

# 检查锁等待
LOCK_WAITS=$($MYSQL_CMD -e "SELECT COUNT(*) FROM information_schema.innodb_trx WHERE trx_state = 'LOCK WAIT'" | tail -1)

if [ $LOCK_WAITS -gt 10 ]; then
    echo "警告：发现 $LOCK_WAITS 个锁等待事务" | mail -s "数据库锁等待告警" admin@company.com
    
    # 记录详细信息
    $MYSQL_CMD -e "SELECT * FROM sys.innodb_lock_waits" > /var/log/mysql/lock_waits_$(date +%Y%m%d_%H%M%S).log
fi
```

**自动杀死长时间查询**：
```sql
-- 创建存储过程杀死长时间运行的查询
DELIMITER $$
CREATE PROCEDURE kill_long_queries()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE thread_id INT;
    DECLARE cur CURSOR FOR 
        SELECT ID FROM information_schema.processlist 
        WHERE COMMAND != 'Sleep' AND TIME > 300;  -- 5分钟
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO thread_id;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        SET @sql = CONCAT('KILL QUERY ', thread_id);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    CLOSE cur;
END$$
DELIMITER ;

-- 设置定时任务（每分钟执行一次）
CREATE EVENT kill_long_queries_event
ON SCHEDULE EVERY 1 MINUTE
DO CALL kill_long_queries();
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 SHOW ENGINE INNODB STATUS：快速查看锁状态的首选工具
🔸 performance_schema：详细的锁监控表，提供精确的锁信息
🔸 INFORMATION_SCHEMA：事务和锁的视图，便于查询分析
🔸 sys库：简化的锁监控视图，常用查询已预定义
🔸 第三方工具：Percona Toolkit等专业工具增强监控能力
```

### 11.2 关键理解要点


**🔹 监控工具的选择**
```
快速诊断：SHOW ENGINE INNODB STATUS
详细分析：performance_schema + sys库
历史趋势：第三方监控系统
自动化：脚本 + 定时任务
```

**🔹 锁问题的分析思路**
```
发现问题：监控指标异常 → 查看锁状态 → 确认锁等待
分析原因：查看SQL语句 → 分析索引使用 → 检查事务逻辑  
解决问题：优化SQL → 调整索引 → 改进事务设计
预防再发：监控告警 → 定期检查 → 代码规范
```

**🔹 死锁分析的要点**
```
关注信息：事务SQL、锁类型、等待关系、持有时间
分析方法：找循环等待 → 确认冲突资源 → 优化锁顺序
预防措施：统一锁定顺序 → 缩短事务时间 → 避免长事务
```

### 11.3 实际应用指导


**日常监控**：
- ✅ **定期检查**：每日查看锁等待情况
- ✅ **关键指标**：活跃事务数、锁等待时间、死锁频率
- ✅ **告警机制**：设置合理的阈值和通知方式
- ✅ **历史分析**：保留监控数据，分析趋势变化

**问题处理**：
- ✅ **快速定位**：使用内置工具快速找到问题
- ✅ **深入分析**：结合多个监控表全面分析
- ✅ **及时处理**：必要时杀死阻塞查询
- ✅ **根本解决**：从SQL和事务设计层面优化

### 11.4 记忆要点


```
🧠 记忆口诀
监控工具要熟练，内置第三方都要用
锁等待分析有方法，先看状态再查因
死锁日志仔细读，循环等待是关键
优化策略记心中，索引事务都重要
告警机制不能少，自动处理更高效
```

**工具使用优先级**：
1. **SHOW ENGINE INNODB STATUS**：快速查看当前状态
2. **sys.innodb_lock_waits**：查看锁等待详情
3. **performance_schema**：深入分析锁信息
4. **第三方工具**：专业监控和自动化处理