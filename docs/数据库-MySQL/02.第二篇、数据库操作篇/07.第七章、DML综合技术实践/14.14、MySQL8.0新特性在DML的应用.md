---
title: 14、MySQL8.0新特性在DML的应用
---
## 📚 目录

1. [MySQL 8.0 DML新特性概述](#1-mysql-80-dml新特性概述)
2. [不可见索引Invisible Index](#2-不可见索引invisible-index)
3. [多值索引Multi-Valued Index](#3-多值索引multi-valued-index)
4. [CTE公用表表达式在DML中应用](#4-cte公用表表达式在dml中应用)
5. [窗口函数与DML结合](#5-窗口函数与dml结合)
6. [角色管理Role在DML权限控制](#6-角色管理role在dml权限控制)
7. [JSON函数在DML中使用](#7-json函数在dml中使用)
8. [资源组Resource Group配置](#8-资源组resource-group配置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 MySQL 8.0 DML新特性概述


### 1.1 MySQL 8.0带来的DML革命


**💡 DML新特性的价值**
MySQL 8.0在数据操作语言(DML)方面带来了重大改进，让数据库操作更加高效、灵活和现代化。

```
简单理解：
就像手机从功能机升级到智能机：
- 以前：基本的增删改查功能
- 现在：智能化的数据处理能力

MySQL 8.0 = 数据库界的"智能手机"
```

**🎯 核心改进方向**
- **索引技术升级**：不可见索引、多值索引
- **查询能力增强**：CTE、窗口函数  
- **权限管理现代化**：角色管理系统
- **JSON支持完善**：原生JSON函数
- **资源管理精细化**：资源组控制

### 1.2 新特性对DML的影响


**📊 DML操作增强对比**

| DML操作 | **MySQL 5.7** | **MySQL 8.0新增** | **实际好处** |
|---------|---------------|-------------------|-------------|
| **SELECT查询** | 基本查询语法 | CTE、窗口函数、多值索引 | 复杂查询更简单 |
| **INSERT插入** | 基本插入 | JSON函数增强、资源组控制 | JSON数据处理更强 |
| **UPDATE更新** | 基本更新 | CTE结合、不可见索引测试 | 复杂更新更高效 |
| **DELETE删除** | 基本删除 | 角色权限控制、资源组限制 | 权限管理更精细 |

---

## 2. 👻 不可见索引Invisible Index


### 2.1 什么是不可见索引


**💡 不可见索引概念**
不可见索引就是"存在但不被使用"的索引，MySQL知道它存在，但查询优化器会忽略它。

```
生活比喻：
就像家里的备用钥匙：
- 钥匙确实存在（索引创建了）
- 平时不用它开门（查询不使用）
- 需要时可以启用（测试时可见）
- 随时可以扔掉（删除索引）

作用：安全测试索引效果，不影响生产查询
```

### 2.2 不可见索引的核心作用


**🎯 主要用途**
```
索引测试：
- 创建索引但不让查询使用
- 观察索引维护的开销
- 确认索引确实被正确创建

软删除：
- 删除索引前先设为不可见
- 观察一段时间确认没有性能问题
- 避免误删重要索引的风险

渐进部署：
- 在生产环境先创建不可见索引
- 经过充分测试后再设为可见
- 降低新索引带来的风险
```

### 2.3 不可见索引操作


**🔧 创建和管理不可见索引**
```sql
-- 创建不可见索引
CREATE INDEX idx_user_email ON users(email) INVISIBLE;

-- 创建表时指定不可见索引
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    category_id INT,
    price DECIMAL(10,2),
    INDEX idx_category (category_id) INVISIBLE,
    INDEX idx_price (price) INVISIBLE
);

-- 将现有索引设为不可见
ALTER TABLE users ALTER INDEX idx_user_email INVISIBLE;

-- 将不可见索引设为可见
ALTER TABLE users ALTER INDEX idx_user_email VISIBLE;

-- 删除不可见索引
DROP INDEX idx_user_email ON users;
```

### 2.4 不可见索引测试实例


**🔍 索引效果测试流程**
```sql
-- 步骤1：创建测试表和数据
CREATE TABLE test_orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    amount DECIMAL(10,2)
);

-- 插入测试数据
INSERT INTO test_orders (user_id, order_date, amount)
SELECT 
    FLOOR(RAND() * 1000) + 1,
    DATE_ADD('2024-01-01', INTERVAL FLOOR(RAND() * 365) DAY),
    ROUND(RAND() * 1000, 2)
FROM 
    (SELECT 1 UNION SELECT 2 UNION SELECT 3) t1,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3) t2,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3) t3;

-- 步骤2：测试无索引的查询性能
EXPLAIN SELECT * FROM test_orders WHERE user_id = 100;
-- 结果：全表扫描，type=ALL，rows=很多

-- 步骤3：创建不可见索引
CREATE INDEX idx_user_id ON test_orders(user_id) INVISIBLE;

-- 步骤4：验证索引不被使用（应该还是全表扫描）
EXPLAIN SELECT * FROM test_orders WHERE user_id = 100;
-- 结果：仍然全表扫描，证明索引被忽略

-- 步骤5：临时启用优化器使用不可见索引
SET SESSION optimizer_switch = 'use_invisible_indexes=on';
EXPLAIN SELECT * FROM test_orders WHERE user_id = 100;
-- 结果：使用索引，type=ref，rows=少量

-- 步骤6：确认无问题后将索引设为可见
SET SESSION optimizer_switch = 'use_invisible_indexes=off';
ALTER TABLE test_orders ALTER INDEX idx_user_id VISIBLE;
```

### 2.5 不可见索引最佳实践


**🎯 实用技巧**
```sql
-- 查看表的所有索引状态
SELECT 
    INDEX_NAME,
    COLUMN_NAME,
    IS_VISIBLE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND TABLE_NAME = 'your_table'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;

-- 批量管理不可见索引
-- 将所有非主键索引设为不可见（用于测试）
SET @sql = '';
SELECT GROUP_CONCAT(
    CONCAT('ALTER TABLE ', TABLE_NAME, ' ALTER INDEX ', INDEX_NAME, ' INVISIBLE')
    SEPARATOR '; '
) INTO @sql
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'test_db' 
  AND INDEX_NAME != 'PRIMARY'
  AND IS_VISIBLE = 'YES';

-- 执行生成的SQL（需要使用存储过程或手动执行）
```

---

## 3. 📊 多值索引Multi-Valued Index


### 3.1 什么是多值索引


**💡 多值索引概念**
多值索引是专门为JSON数组字段设计的索引类型，可以对JSON数组中的每个元素建立索引。

```
传统索引问题：
JSON字段：{"tags": ["mysql", "database", "sql"]}
- 普通索引无法索引数组中的单个元素
- 查询"包含mysql标签"需要全表扫描

多值索引解决方案：
- 为JSON数组的每个元素分别建立索引项
- 可以高效查询"包含特定值的数组"
```

### 3.2 多值索引的工作原理


**🔧 工作机制详解**
```
普通索引：一个文档 → 一个索引项
多值索引：一个文档 → 多个索引项（数组元素个数）

示例数据：
{"id": 1, "tags": ["mysql", "php", "web"]}
{"id": 2, "tags": ["python", "django"]}
{"id": 3, "tags": ["mysql", "python"]}

普通索引存储：
无法建立有效索引

多值索引存储：
"mysql"  → [1, 3]
"php"    → [1]  
"web"    → [1]
"python" → [2, 3]
"django" → [2]
```

### 3.3 多值索引创建和使用


**🔧 创建多值索引**
```sql
-- 创建测试表
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    tags JSON,
    metadata JSON
);

-- 创建多值索引
CREATE INDEX idx_tags ON articles ((CAST(tags->'$[*]' AS CHAR(50) ARRAY)));

-- 或者使用更简洁的语法（MySQL 8.0.17+）
ALTER TABLE articles ADD INDEX idx_tags ((CAST(tags->'$[*]' AS CHAR(50) ARRAY)));
```

**📝 插入测试数据**
```sql
INSERT INTO articles (title, tags) VALUES
('MySQL学习指南', '["mysql", "database", "sql"]'),
('PHP开发实战', '["php", "web", "mysql"]'),
('Python数据分析', '["python", "data", "analysis"]'),
('前端框架对比', '["javascript", "vue", "react"]'),
('全栈开发', '["mysql", "php", "javascript", "vue"]');
```

**🔍 查询使用多值索引**
```sql
-- 查询包含特定标签的文章
SELECT id, title 
FROM articles 
WHERE JSON_CONTAINS(tags, '"mysql"');

-- 查询包含多个标签之一的文章
SELECT id, title 
FROM articles 
WHERE JSON_OVERLAPS(tags, '["mysql", "python"]');

-- 查看执行计划，确认使用了多值索引
EXPLAIN SELECT id, title 
FROM articles 
WHERE JSON_CONTAINS(tags, '"mysql"');
-- 应该显示 type: range, key: idx_tags
```

### 3.4 多值索引的限制和注意事项


**⚠️ 重要限制**
```sql
-- 限制1：只能用于JSON数组
-- ✓ 正确：CAST(json_column->'$[*]' AS CHAR(50) ARRAY)
-- ❌ 错误：CAST(varchar_column AS CHAR(50) ARRAY)

-- 限制2：数组元素类型必须一致
-- ✓ 正确：["tag1", "tag2", "tag3"]
-- ❌ 错误：["tag1", 123, true]

-- 限制3：有大小限制
-- 数组元素数量不能超过100个
-- 单个元素长度不能超过定义的长度
```

**💡 性能考虑**
```sql
-- 查看多值索引的存储开销
SELECT 
    INDEX_NAME,
    STAT_NAME,
    STAT_VALUE,
    STAT_DESCRIPTION
FROM mysql.innodb_index_stats 
WHERE TABLE_NAME = 'articles' 
  AND INDEX_NAME = 'idx_tags';

-- 多值索引会占用更多空间：
-- 普通索引：1行数据 = 1个索引项
-- 多值索引：1行数据 = N个索引项（N为数组元素个数）
```

---

## 4. 🔄 CTE公用表表达式在DML中应用


### 4.1 什么是CTE公用表表达式


**💡 CTE基本概念**
CTE(Common Table Expression)公用表表达式是一种临时命名的查询结果集，可以在同一个SQL语句中被多次引用。

```
简单理解：
就像Excel中的"命名区域"：
- 给一个复杂的数据区域起个名字
- 后续可以直接用这个名字引用
- 让复杂计算变得清晰易懂

CTE = SQL中的"临时视图" + "可重复使用"
```

### 4.2 CTE在DML中的应用场景


**🎯 UPDATE操作中使用CTE**
```sql
-- 场景：根据复杂计算结果更新员工薪资

-- 使用CTE计算每个部门的平均薪资
WITH dept_avg AS (
    SELECT 
        department_id,
        AVG(salary) as avg_salary
    FROM employees 
    GROUP BY department_id
),
salary_adjustment AS (
    SELECT 
        e.employee_id,
        e.salary,
        da.avg_salary,
        CASE 
            WHEN e.salary < da.avg_salary * 0.8 THEN e.salary * 1.1
            WHEN e.salary > da.avg_salary * 1.2 THEN e.salary * 0.95
            ELSE e.salary
        END as new_salary
    FROM employees e
    JOIN dept_avg da ON e.department_id = da.department_id
)
UPDATE employees e
JOIN salary_adjustment sa ON e.employee_id = sa.employee_id
SET e.salary = sa.new_salary
WHERE e.salary != sa.new_salary;
```

**🗑️ DELETE操作中使用CTE**
```sql
-- 场景：删除重复数据，保留最新的记录

-- 使用CTE找出重复数据
WITH duplicate_records AS (
    SELECT 
        id,
        email,
        ROW_NUMBER() OVER (PARTITION BY email ORDER BY created_at DESC) as rn
    FROM users
    WHERE email IS NOT NULL
),
records_to_delete AS (
    SELECT id 
    FROM duplicate_records 
    WHERE rn > 1
)
DELETE u FROM users u
JOIN records_to_delete rtd ON u.id = rtd.id;
```

### 4.3 递归CTE在DML中的应用


**🔄 递归CTE概念**
递归CTE可以处理层次数据，非常适合处理树形结构的DML操作。

```sql
-- 场景：更新组织架构中所有下属的管理路径

-- 创建测试表
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT,
    management_path VARCHAR(500)
);

-- 使用递归CTE更新管理路径
WITH RECURSIVE emp_hierarchy AS (
    -- 基础情况：顶级管理者
    SELECT 
        id,
        name,
        manager_id,
        CAST(name AS CHAR(500)) as path,
        0 as level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归情况：下属员工
    SELECT 
        e.id,
        e.name,
        e.manager_id,
        CONCAT(eh.path, ' -> ', e.name) as path,
        eh.level + 1
    FROM employees e
    JOIN emp_hierarchy eh ON e.manager_id = eh.id
)
UPDATE employees e
JOIN emp_hierarchy eh ON e.id = eh.id
SET e.management_path = eh.path;
```

### 4.4 CTE与传统子查询对比


**📊 性能和可读性对比**
```sql
-- 传统子查询方式（复杂难懂）
UPDATE products p1
SET price = price * 1.1
WHERE category_id IN (
    SELECT category_id 
    FROM (
        SELECT category_id, AVG(price) as avg_price
        FROM products 
        GROUP BY category_id
        HAVING AVG(price) < (
            SELECT AVG(price) * 0.8 
            FROM products
        )
    ) low_price_categories
);

-- CTE方式（清晰易懂）
WITH overall_avg AS (
    SELECT AVG(price) as total_avg 
    FROM products
),
low_price_categories AS (
    SELECT category_id
    FROM products p, overall_avg oa
    GROUP BY category_id
    HAVING AVG(p.price) < oa.total_avg * 0.8
)
UPDATE products p
JOIN low_price_categories lpc ON p.category_id = lpc.category_id
SET p.price = p.price * 1.1;
```

**✅ CTE优势**
- **可读性好**：逻辑分层清晰，易于理解
- **可维护性强**：修改某部分逻辑不影响其他部分
- **可重用性**：同一个CTE可以被多次引用
- **性能优化**：优化器可以更好地优化执行计划

---

## 5. 📈 窗口函数与DML结合


### 5.1 什么是窗口函数


**💡 窗口函数概念**
窗口函数可以在不改变结果集行数的情况下，对数据进行分组计算，每行都能看到分组的聚合结果。

```
简单理解：
传统GROUP BY：把数据"压缩"成汇总行
窗口函数：在每行数据上"贴标签"显示汇总信息

例子：班级成绩表
- GROUP BY：显示各班平均分（只有班级汇总行）
- 窗口函数：每个学生都能看到自己班的平均分
```

### 5.2 窗口函数在UPDATE中的应用


**🔧 排名更新场景**
```sql
-- 场景：根据销售额更新销售员排名

-- 创建销售表
CREATE TABLE sales_rep (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    sales_amount DECIMAL(12,2),
    department_rank INT,
    overall_rank INT
);

-- 使用窗口函数计算排名并更新
WITH ranked_sales AS (
    SELECT 
        id,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY sales_amount DESC) as dept_rank,
        ROW_NUMBER() OVER (ORDER BY sales_amount DESC) as overall_rank
    FROM sales_rep
)
UPDATE sales_rep sr
JOIN ranked_sales rs ON sr.id = rs.id
SET 
    sr.department_rank = rs.dept_rank,
    sr.overall_rank = rs.overall_rank;
```

**📊 百分比和比例计算**
```sql
-- 场景：更新每个员工的薪资在部门中的百分位

WITH salary_percentiles AS (
    SELECT 
        id,
        salary,
        PERCENT_RANK() OVER (PARTITION BY department_id ORDER BY salary) as salary_percentile,
        salary / SUM(salary) OVER (PARTITION BY department_id) as salary_ratio
    FROM employees
)
UPDATE employees e
JOIN salary_percentiles sp ON e.id = sp.id
SET 
    e.salary_percentile = sp.salary_percentile,
    e.department_salary_ratio = sp.salary_ratio;
```

### 5.3 窗口函数在DELETE中的应用


**🗑️ 智能数据清理**
```sql
-- 场景：保留每个用户最近的10条日志，删除更老的记录

WITH log_ranking AS (
    SELECT 
        id,
        user_id,
        created_at,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
    FROM user_logs
)
DELETE ul FROM user_logs ul
JOIN log_ranking lr ON ul.id = lr.id
WHERE lr.rn > 10;
```

**📅 时间窗口数据清理**
```sql
-- 场景：删除每天除了峰值时段外的冗余监控数据

WITH hourly_stats AS (
    SELECT 
        id,
        DATE_FORMAT(created_at, '%Y-%m-%d %H:00:00') as hour_slot,
        cpu_usage,
        ROW_NUMBER() OVER (
            PARTITION BY DATE_FORMAT(created_at, '%Y-%m-%d %H:00:00') 
            ORDER BY cpu_usage DESC
        ) as usage_rank
    FROM system_monitors
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY)
)
DELETE sm FROM system_monitors sm
JOIN hourly_stats hs ON sm.id = hs.id
WHERE hs.usage_rank > 5;  -- 每小时只保留CPU使用率最高的5条记录
```

### 5.4 窗口函数常用场景


**📋 常用窗口函数分类**

| 函数类型 | **函数名** | **DML应用场景** | **示例** |
|---------|-----------|---------------|----------|
| **排名函数** | `ROW_NUMBER(), RANK(), DENSE_RANK()` | 排名更新、重复数据删除 | 更新销售排名 |
| **聚合函数** | `SUM(), AVG(), COUNT() OVER()` | 比例计算、汇总更新 | 计算部门占比 |
| **取值函数** | `LAG(), LEAD(), FIRST_VALUE()` | 时序数据处理 | 计算环比增长 |
| **分位函数** | `PERCENT_RANK(), NTILE()` | 分层分组 | 客户价值分层 |

---

## 6. 👥 角色管理Role在DML权限控制


### 6.1 什么是角色管理


**💡 角色管理概念**
角色(Role)是一组权限的集合，可以把相关权限打包成角色，然后将角色分配给用户，简化权限管理。

```
传统权限管理问题：
- 每个用户单独分配权限
- 权限重复、管理复杂
- 人员变动时需要逐个调整权限

角色管理解决方案：
- 定义角色（如：开发者、分析师、管理员）
- 为角色分配权限
- 用户继承角色权限
- 就像"职位"决定"权限"
```

### 6.2 角色创建和权限分配


**🔧 角色基础操作**
```sql
-- 创建角色
CREATE ROLE 'app_developer';
CREATE ROLE 'data_analyst';  
CREATE ROLE 'db_admin';

-- 为角色分配DML权限
-- 开发者角色：可以对开发库进行增删改查
GRANT SELECT, INSERT, UPDATE, DELETE ON dev_database.* TO 'app_developer';
GRANT CREATE, DROP, ALTER ON dev_database.* TO 'app_developer';

-- 数据分析师角色：只能查询和统计
GRANT SELECT ON prod_database.* TO 'data_analyst';
GRANT SELECT ON information_schema.* TO 'data_analyst';

-- 数据库管理员角色：完全控制权限
GRANT ALL PRIVILEGES ON *.* TO 'db_admin' WITH GRANT OPTION;
```

**👤 用户和角色关联**
```sql
-- 创建用户
CREATE USER 'zhang_san'@'%' IDENTIFIED BY 'password123';
CREATE USER 'li_si'@'%' IDENTIFIED BY 'password456';
CREATE USER 'wang_wu'@'%' IDENTIFIED BY 'password789';

-- 分配角色给用户
GRANT 'app_developer' TO 'zhang_san'@'%';
GRANT 'data_analyst' TO 'li_si'@'%';
GRANT 'db_admin' TO 'wang_wu'@'%';

-- 设置默认角色（登录时自动激活）
SET DEFAULT ROLE 'app_developer' TO 'zhang_san'@'%';
SET DEFAULT ROLE 'data_analyst' TO 'li_si'@'%';
SET DEFAULT ROLE 'db_admin' TO 'wang_wu'@'%';
```

### 6.3 细粒度DML权限控制


**🎯 表级别权限控制**
```sql
-- 创建不同级别的角色

-- 只读分析师：只能查询特定表
CREATE ROLE 'readonly_analyst';
GRANT SELECT ON sales.orders TO 'readonly_analyst';
GRANT SELECT ON sales.customers TO 'readonly_analyst';
-- 注意：不包括敏感的 sales.customer_private_info 表

-- 业务操作员：可以修改业务数据
CREATE ROLE 'business_operator'; 
GRANT SELECT, INSERT, UPDATE ON sales.orders TO 'business_operator';
GRANT SELECT, UPDATE ON sales.customers TO 'business_operator';
-- 注意：不包括DELETE权限，防止误删

-- 数据维护员：可以清理历史数据
CREATE ROLE 'data_maintainer';
GRANT SELECT, DELETE ON logs.* TO 'data_maintainer';
GRANT SELECT ON sales.* TO 'data_maintainer';
```

**🔒 列级别权限控制**
```sql
-- MySQL 8.0支持更细粒度的列权限控制

-- 创建客服角色：可以查看客户基本信息，但不能看敏感信息
CREATE ROLE 'customer_service';

-- 只允许查询特定列
GRANT SELECT (id, name, phone, email) ON customers TO 'customer_service';
-- 不允许查询：ssn（社保号）, salary（薪资）等敏感字段

-- 只允许更新特定列
GRANT UPDATE (phone, email, address) ON customers TO 'customer_service';
-- 不允许更新：credit_limit, vip_level等关键字段
```

### 6.4 动态权限管理


**🔄 运行时权限控制**
```sql
-- 查看用户当前激活的角色
SELECT CURRENT_ROLE();

-- 查看用户拥有的所有角色
SHOW GRANTS FOR 'zhang_san'@'%';

-- 用户可以在会话中切换角色
SET ROLE 'app_developer';  -- 激活开发者角色
SET ROLE NONE;             -- 停用所有角色
SET ROLE ALL;              -- 激活所有拥有的角色

-- 查看角色的权限详情
SHOW GRANTS FOR 'app_developer';
```

**🔍 权限审计和监控**
```sql
-- 查看谁有什么权限
SELECT 
    GRANTEE as '用户/角色',
    TABLE_SCHEMA as '数据库',
    PRIVILEGE_TYPE as '权限类型',
    IS_GRANTABLE as '可转授'
FROM information_schema.USER_PRIVILEGES
WHERE GRANTEE LIKE '%developer%';

-- 查看角色分配情况
SELECT 
    FROM_USER as '角色',
    TO_USER as '用户',
    WITH_ADMIN_OPTION as '管理权限'
FROM mysql.role_edges;
```

### 6.5 角色管理最佳实践


**🎯 角色设计原则**
```sql
-- 按职能设计角色层次
CREATE ROLE 'junior_developer';      -- 初级开发
CREATE ROLE 'senior_developer';      -- 高级开发  
CREATE ROLE 'team_lead';             -- 团队负责人
CREATE ROLE 'project_manager';       -- 项目经理

-- 角色继承（高级角色包含低级角色权限）
GRANT 'junior_developer' TO 'senior_developer';
GRANT 'senior_developer' TO 'team_lead';
GRANT 'team_lead' TO 'project_manager';

-- 权限分层分配
-- 初级：只能查询和插入测试数据
GRANT SELECT, INSERT ON test_db.* TO 'junior_developer';

-- 高级：增加更新和生产环境查询权限  
GRANT UPDATE ON test_db.* TO 'senior_developer';
GRANT SELECT ON prod_db.* TO 'senior_developer';

-- 负责人：增加删除和用户管理权限
GRANT DELETE ON test_db.* TO 'team_lead';
GRANT CREATE USER, GRANT OPTION ON *.* TO 'team_lead';
```

---

## 7. 📋 JSON函数在DML中使用


### 7.1 MySQL 8.0 JSON函数增强


**💡 JSON函数概述**
MySQL 8.0大幅增强了JSON数据类型的处理能力，提供了丰富的函数来操作JSON数据。

```
JSON在现代应用中的重要性：
- API接口大量使用JSON格式
- 配置信息常用JSON存储  
- 用户个性化设置用JSON保存
- 日志和事件数据用JSON记录

MySQL 8.0让JSON操作像操作普通字段一样简单
```

### 7.2 JSON数据的插入和更新


**📝 JSON数据插入**
```sql
-- 创建包含JSON字段的表
CREATE TABLE user_profiles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    profile JSON,
    settings JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入JSON数据
INSERT INTO user_profiles (username, profile, settings) VALUES
('张三', 
 JSON_OBJECT('age', 25, 'city', '北京', 'hobbies', JSON_ARRAY('读书', '游泳', '编程')),
 JSON_OBJECT('theme', 'dark', 'language', 'zh-CN', 'notifications', true)
),
('李四',
 '{"age": 30, "city": "上海", "hobbies": ["电影", "旅行"]}',
 '{"theme": "light", "language": "en-US", "notifications": false}'
);
```

**🔄 JSON数据更新**
```sql
-- 更新JSON对象的特定字段
UPDATE user_profiles 
SET profile = JSON_SET(profile, '$.age', 26)
WHERE username = '张三';

-- 添加新的JSON字段
UPDATE user_profiles 
SET profile = JSON_INSERT(profile, '$.phone', '13800138000')
WHERE username = '张三';

-- 删除JSON字段
UPDATE user_profiles 
SET profile = JSON_REMOVE(profile, '$.hobbies[0]')
WHERE username = '张三';

-- 替换整个JSON对象
UPDATE user_profiles 
SET settings = JSON_REPLACE(settings, '$.theme', 'auto', '$.language', 'zh-CN')
WHERE username = '李四';
```

### 7.3 JSON查询和条件筛选


**🔍 JSON数据查询**
```sql
-- 查询JSON字段的值
SELECT 
    username,
    profile->>'$.age' as age,
    profile->>'$.city' as city,
    JSON_EXTRACT(profile, '$.hobbies') as hobbies
FROM user_profiles;

-- 基于JSON字段值的条件查询
SELECT username, profile->>'$.city' as city
FROM user_profiles 
WHERE profile->>'$.age' > 25;

-- 查询JSON数组包含特定值
SELECT username 
FROM user_profiles 
WHERE JSON_CONTAINS(profile->>'$.hobbies', '"编程"');

-- 查询JSON对象包含特定键
SELECT username 
FROM user_profiles 
WHERE JSON_CONTAINS_PATH(profile, 'one', '$.phone');
```

### 7.4 复杂JSON操作


**🔧 JSON数组操作**
```sql
-- 向JSON数组添加元素
UPDATE user_profiles 
SET profile = JSON_ARRAY_APPEND(profile, '$.hobbies', '摄影')
WHERE username = '张三';

-- 从JSON数组移除元素
UPDATE user_profiles 
SET profile = JSON_REMOVE(profile, '$.hobbies[1]')
WHERE username = '张三';

-- 合并JSON对象
UPDATE user_profiles 
SET profile = JSON_MERGE_PATCH(
    profile, 
    '{"education": "本科", "work_years": 5}'
)
WHERE username = '李四';
```

**📊 JSON聚合和统计**
```sql
-- 统计各城市用户数量
SELECT 
    profile->>'$.city' as city,
    COUNT(*) as user_count
FROM user_profiles 
WHERE profile->>'$.city' IS NOT NULL
GROUP BY profile->>'$.city';

-- 统计用户爱好分布（需要展开JSON数组）
WITH hobbies_expanded AS (
    SELECT 
        username,
        JSON_UNQUOTE(JSON_EXTRACT(profile, CONCAT('$.hobbies[', n.n, ']'))) as hobby
    FROM user_profiles,
         (SELECT 0 n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) n
    WHERE JSON_EXTRACT(profile, CONCAT('$.hobbies[', n.n, ']')) IS NOT NULL
)
SELECT hobby, COUNT(*) as count
FROM hobbies_expanded 
WHERE hobby IS NOT NULL
GROUP BY hobby
ORDER BY count DESC;
```

### 7.5 JSON函数性能优化


**⚡ JSON索引优化**
```sql
-- 为JSON字段的特定路径创建索引
ALTER TABLE user_profiles 
ADD INDEX idx_age ((CAST(profile->>'$.age' AS UNSIGNED)));

ALTER TABLE user_profiles 
ADD INDEX idx_city ((CAST(profile->>'$.city' AS CHAR(50))));

-- 创建多值索引（用于JSON数组）
ALTER TABLE user_profiles 
ADD INDEX idx_hobbies ((CAST(profile->'$.hobbies[*]' AS CHAR(50) ARRAY)));
```

**📊 JSON查询性能对比**
```sql
-- 无索引查询（慢）
SELECT * FROM user_profiles WHERE profile->>'$.age' > 25;
-- EXPLAIN显示：type=ALL，全表扫描

-- 有索引查询（快）
-- 创建索引后相同查询
-- EXPLAIN显示：type=range，使用索引
```

---

## 8. 🔧 资源组Resource Group配置


### 8.1 什么是资源组


**💡 资源组概念**
资源组是MySQL 8.0引入的新特性，可以控制不同类型的SQL语句使用的系统资源（CPU、内存等）。

```
简单理解：
就像电脑的"进程优先级"：
- 重要任务分配更多CPU
- 后台任务限制资源使用
- 避免某个任务影响整体性能

MySQL资源组 = 给SQL语句分配"优先级"和"资源配额"
```

### 8.2 资源组的类型和配置


**🔧 系统默认资源组**
```sql
-- 查看系统默认资源组
SELECT * FROM information_schema.RESOURCE_GROUPS;

默认资源组：
- SYS_default：系统默认组，普通用户连接
- USR_default：用户默认组，管理员连接
```

**🎯 自定义资源组创建**
```sql
-- 创建高优先级资源组（用于重要业务查询）
CREATE RESOURCE GROUP rg_oltp_high
    TYPE = USER           -- 用户类型资源组
    VCPU = 0-3           -- 绑定CPU核心0-3
    THREAD_PRIORITY = 5;  -- 线程优先级（-20到19，值越小优先级越高）

-- 创建低优先级资源组（用于批量数据处理）  
CREATE RESOURCE GROUP rg_batch_low
    TYPE = USER
    VCPU = 4-7           -- 绑定CPU核心4-7
    THREAD_PRIORITY = 10; -- 较低优先级

-- 创建分析专用资源组
CREATE RESOURCE GROUP rg_analytics
    TYPE = USER  
    VCPU = 8-11          -- 专用CPU核心
    THREAD_PRIORITY = 0   -- 高优先级
    ENABLE;              -- 启用资源组
```

### 8.3 DML操作中使用资源组


**⚡ 为查询指定资源组**
```sql
-- 重要的在线查询使用高优先级资源组
SELECT /*+ RESOURCE_GROUP(rg_oltp_high) */ 
    customer_id, order_amount, order_date
FROM orders 
WHERE order_date >= CURDATE()
  AND status = 'pending';

-- 批量数据处理使用低优先级资源组
UPDATE /*+ RESOURCE_GROUP(rg_batch_low) */ 
    order_archive 
SET processed_flag = 1 
WHERE created_date < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 数据分析查询使用专用资源组
SELECT /*+ RESOURCE_GROUP(rg_analytics) */
    DATE_FORMAT(order_date, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(amount) as total_amount
FROM orders 
WHERE order_date >= '2024-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m');
```

### 8.4 会话级别资源组设置


**🔄 为整个会话设置资源组**
```sql
-- 设置当前会话的资源组
SET RESOURCE GROUP rg_analytics;

-- 之后该会话的所有SQL都使用指定资源组
SELECT COUNT(*) FROM large_table;  -- 使用rg_analytics资源组
UPDATE stats_table SET updated_at = NOW();  -- 也使用rg_analytics

-- 查看当前会话的资源组
SELECT RESOURCE_GROUP_NAME() as current_resource_group;

-- 恢复默认资源组
SET RESOURCE GROUP USR_default;
```

### 8.5 资源组管理和监控


**📊 资源组状态监控**
```sql
-- 查看资源组的当前状态
SELECT 
    RESOURCE_GROUP_NAME,
    RESOURCE_GROUP_TYPE,
    RESOURCE_GROUP_ENABLED,
    VCPU_IDS,
    THREAD_PRIORITY
FROM information_schema.RESOURCE_GROUPS;

-- 查看当前有哪些线程在使用资源组
SELECT 
    THREAD_ID,
    PROCESSLIST_ID,
    PROCESSLIST_USER,
    PROCESSLIST_DB,
    RESOURCE_GROUP
FROM performance_schema.threads 
WHERE RESOURCE_GROUP != 'SYS_default';

-- 监控资源组的CPU使用情况
SELECT 
    rg.RESOURCE_GROUP_NAME,
    COUNT(t.THREAD_ID) as active_threads,
    GROUP_CONCAT(t.PROCESSLIST_INFO SEPARATOR '; ') as running_queries
FROM information_schema.RESOURCE_GROUPS rg
LEFT JOIN performance_schema.threads t ON rg.RESOURCE_GROUP_NAME = t.RESOURCE_GROUP
WHERE rg.RESOURCE_GROUP_ENABLED = 'YES'
GROUP BY rg.RESOURCE_GROUP_NAME;
```

### 8.6 资源组使用场景


**🎯 典型应用场景**
```sql
-- 场景1：在线业务与离线分析分离
-- 在线业务：快速响应，优先CPU
CREATE RESOURCE GROUP rg_online
    TYPE = USER VCPU = 0-3 THREAD_PRIORITY = -5;

-- 离线分析：允许使用更多资源，但优先级低
CREATE RESOURCE GROUP rg_offline  
    TYPE = USER VCPU = 4-15 THREAD_PRIORITY = 10;

-- 场景2：不同业务系统的资源隔离
-- 订单系统：核心业务，最高优先级
CREATE RESOURCE GROUP rg_order_system
    TYPE = USER VCPU = 0-1 THREAD_PRIORITY = -10;

-- 日志系统：后台任务，最低优先级
CREATE RESOURCE GROUP rg_log_system
    TYPE = USER VCPU = 14-15 THREAD_PRIORITY = 15;
```

**⚠️ 资源组使用注意事项**
```
注意事项：
1. 需要Linux系统支持（Windows不支持）
2. 需要CAP_SYS_NICE权限才能设置线程优先级
3. VCPU绑定需要谨慎，避免资源浪费
4. 过度限制可能导致死锁或性能问题

最佳实践：
✓ 先在测试环境验证效果
✓ 监控系统整体CPU使用情况
✓ 为关键业务预留足够资源
✓ 定期检查资源组配置的合理性
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


**🔸 MySQL 8.0 DML新特性体系**
```
索引增强：
✓ 不可见索引 - 安全测试索引效果
✓ 多值索引 - 高效处理JSON数组查询

查询增强：  
✓ CTE公用表表达式 - 简化复杂查询逻辑
✓ 窗口函数 - 不改变行数的聚合计算

权限增强：
✓ 角色管理 - 权限管理现代化
✓ 细粒度权限 - 列级别权限控制

数据处理增强：
✓ JSON函数完善 - 原生JSON操作能力
✓ 资源组管理 - 精细化资源控制
```

### 9.2 实际应用价值


**🎯 企业级应用场景**
```
开发测试环境：
- 不可见索引：安全测试新索引效果
- 角色管理：开发、测试、运维权限分离
- 资源组：开发任务与测试任务资源隔离

生产运维环境：
- CTE和窗口函数：复杂数据分析和报表
- JSON函数：用户配置、日志分析、API数据处理
- 多值索引：标签系统、分类搜索优化

数据分析场景：
- 窗口函数：排名、趋势、同比环比计算
- CTE：多层数据处理、递归查询
- 资源组：分析任务不影响在线业务
```

### 9.3 技术选择指导


**📊 特性选择决策表**

| 业务需求 | **推荐特性** | **使用理由** | **注意事项** |
|---------|-------------|-------------|-------------|
| **索引测试** | 不可见索引 | 安全、可回滚 | 需要充分测试时间 |
| **JSON数组搜索** | 多值索引 | 性能提升显著 | 注意存储开销 |
| **复杂报表查询** | CTE + 窗口函数 | 逻辑清晰、性能好 | 需要MySQL 8.0+ |
| **权限管理** | 角色系统 | 管理便捷、安全 | 需要重新设计权限体系 |
| **配置数据存储** | JSON函数 | 灵活、原生支持 | 注意数据结构设计 |
| **资源控制** | 资源组 | 性能隔离 | 仅Linux支持 |

### 9.4 升级迁移建议


**🔄 从MySQL 5.7升级到8.0的DML改进点**
```sql
-- 升级前：复杂的子查询
SELECT * FROM (
    SELECT *, 
           @row_number := CASE 
               WHEN @prev_dept = department_id THEN @row_number + 1 
               ELSE 1 
           END AS rn,
           @prev_dept := department_id
    FROM employees, (SELECT @row_number := 0, @prev_dept := '') r
    ORDER BY department_id, salary DESC
) ranked
WHERE rn <= 3;

-- 升级后：简洁的窗口函数
SELECT *
FROM (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn
    FROM employees
) ranked
WHERE rn <= 3;
```

**🎯 实施建议**
```
渐进式应用：
1. 先应用安全的特性（不可见索引、角色管理）
2. 然后应用查询增强特性（CTE、窗口函数）
3. 最后应用高级特性（资源组、多值索引）

团队培训：
✓ 重点培训CTE和窗口函数（提升最明显）
✓ JSON函数按需培训（有JSON需求时）
✓ 资源组培训给DBA（运维需要）

性能验证：
✓ 在测试环境充分验证新特性效果
✓ 监控升级后的系统性能变化
✓ 准备回滚方案以防出现问题
```

### 9.5 学习路径建议


**📚 推荐学习顺序**
```
第一阶段（基础）：
1. 不可见索引 - 容易理解，风险低
2. 基础JSON函数 - 现代应用必需
3. 简单CTE应用 - 替代复杂子查询

第二阶段（进阶）：
4. 窗口函数 - 大幅提升查询能力
5. 角色管理 - 现代化权限控制
6. 多值索引 - JSON数组性能优化

第三阶段（高级）：
7. 递归CTE - 处理层次数据
8. 资源组配置 - 精细化资源管理
9. 综合应用 - 多特性组合使用
```

**🔑 核心记忆**
```
MySQL 8.0 DML新特性让数据操作更加：
- 安全：不可见索引、角色管理
- 高效：多值索引、窗口函数、CTE
- 灵活：JSON函数、资源组
- 现代：符合现代应用开发需求

掌握这些特性是从传统DBA向现代数据工程师转变的必经之路
```