---
title: 8、ALTER在线表结构变更
---
## 📚 目录

1. [ALTER TABLE基础概念](#1-alter-table基础概念)
2. [ALTER TABLE语法详解](#2-alter-table语法详解)
3. [在线DDL核心机制](#3-在线ddl核心机制)
4. [大表结构变更策略](#4-大表结构变更策略)
5. [实际应用与最佳实践](#5-实际应用与最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 ALTER TABLE基础概念


### 1.1 什么是ALTER TABLE？


**🔸 基本概念**
ALTER TABLE是SQL中用来**修改已存在表结构**的命令，就像装修房子一样：

```
房子装修类比：
🏠 原始房子 = 现有数据表
🔨 装修工具 = ALTER TABLE命令
🏗️ 装修方案 = 结构变更操作

装修类型：
• 增加房间 = 添加字段（ADD COLUMN）
• 拆除房间 = 删除字段（DROP COLUMN）  
• 改造房间 = 修改字段（MODIFY COLUMN）
• 房子改名 = 表重命名（RENAME TABLE）
```

**🔸 为什么需要ALTER TABLE？**
```
业务发展需求：
📱 新功能上线 → 需要新字段存储数据
🔄 业务调整 → 修改字段类型或长度
🗑️ 功能下线 → 删除不需要的字段
📊 性能优化 → 添加索引、修改存储引擎
```

### 1.2 传统DDL vs 在线DDL


**🔸 传统DDL的问题**
```
传统表结构变更过程：
1. 锁定整张表（排他锁）
2. 创建新表结构
3. 复制所有数据到新表
4. 删除旧表，重命名新表
5. 释放锁

问题：
❌ 表锁定时间长，无法读写
❌ 大表变更可能需要几小时
❌ 业务中断，用户体验差
❌ 占用额外存储空间
```

**🔸 在线DDL的优势**
```
在线DDL核心思想：
变更过程中保持表的可读写性

优势：
✅ 最小化锁时间
✅ 减少业务中断
✅ 提高变更成功率
✅ 支持更灵活的变更策略
```

---

## 2. 📝 ALTER TABLE语法详解


### 2.1 添加删除字段操作


**🔸 添加字段（ADD COLUMN）**
```sql
-- 基本语法
ALTER TABLE table_name 
ADD COLUMN column_name data_type [约束];

-- 实际示例
ALTER TABLE users 
ADD COLUMN phone VARCHAR(20) NOT NULL DEFAULT '';

-- 添加多个字段
ALTER TABLE users 
ADD COLUMN phone VARCHAR(20),
ADD COLUMN address TEXT;

-- 指定字段位置
ALTER TABLE users 
ADD COLUMN age INT AFTER name;  -- 在name字段后面

ALTER TABLE users 
ADD COLUMN id INT FIRST;        -- 在第一个位置
```

**💡 添加字段的注意事项**
```
新字段的默认值处理：
• NOT NULL字段：必须指定DEFAULT值
• NULL字段：默认值为NULL
• 大表添加字段：考虑性能影响

实际应用场景：
📱 新功能：添加用户头像字段
🔐 安全升级：添加密码加密字段
📊 数据分析：添加创建时间字段
```

**🔸 删除字段（DROP COLUMN）**
```sql
-- 基本语法
ALTER TABLE table_name 
DROP COLUMN column_name;

-- 实际示例
ALTER TABLE users 
DROP COLUMN old_field;

-- 删除多个字段
ALTER TABLE users 
DROP COLUMN field1,
DROP COLUMN field2;
```

**⚠️ 删除字段风险**
```
删除前检查：
🔍 确认字段不被应用程序使用
🔍 检查是否有索引依赖
🔍 确认是否有外键引用
🔍 备份数据以防恢复需要

风险控制：
1. 先在测试环境验证
2. 业务低峰期操作
3. 提前通知相关开发人员
```

### 2.2 修改字段操作


**🔸 修改字段属性（MODIFY COLUMN）**
```sql
-- MySQL语法
ALTER TABLE users 
MODIFY COLUMN name VARCHAR(100) NOT NULL;

-- 修改字段类型和约束
ALTER TABLE users 
MODIFY COLUMN age INT UNSIGNED DEFAULT 0;
```

**🔸 字段重命名（CHANGE COLUMN）**
```sql
-- MySQL语法：CHANGE可以同时改名和类型
ALTER TABLE users 
CHANGE COLUMN old_name new_name VARCHAR(50);

-- 只改名，保持类型不变
ALTER TABLE users 
CHANGE COLUMN username user_name VARCHAR(50);
```

**📊 字段修改对比表**

| 操作类型 | MySQL语法 | PostgreSQL语法 | 影响 |
|---------|-----------|----------------|------|
| **改类型** | `MODIFY COLUMN` | `ALTER COLUMN ... TYPE` | 可能需要重建 |
| **改名** | `CHANGE COLUMN` | `RENAME COLUMN` | 仅元数据更新 |
| **改约束** | `MODIFY COLUMN` | `ALTER COLUMN SET/DROP` | 影响较小 |
| **改默认值** | `ALTER COLUMN SET DEFAULT` | `ALTER COLUMN SET DEFAULT` | 仅影响新记录 |

### 2.3 表重命名操作


**🔸 表重命名（RENAME TABLE）**
```sql
-- 单表重命名
RENAME TABLE old_table TO new_table;

-- 多表重命名
RENAME TABLE 
    table1 TO table1_old,
    table1_new TO table1;

-- ALTER TABLE方式
ALTER TABLE old_table RENAME TO new_table;
```

**🔄 重命名的原子性**
```
RENAME TABLE的优势：
✅ 操作是原子的，要么全成功要么全失败
✅ 锁定时间极短，几乎不影响业务
✅ 可以实现表的瞬间切换

典型应用场景：
🔄 数据迁移：新表准备好后瞬间切换
🔧 表结构升级：零停机时间更新
📊 数据归档：将历史数据表重命名
```

---

## 3. 🚀 在线DDL核心机制


### 3.1 在线DDL算法选择


**🔸 ALGORITHM参数详解**
在线DDL提供两种算法，就像装修房子的两种方案：

```sql
ALTER TABLE users 
ADD COLUMN phone VARCHAR(20),
ALGORITHM = INPLACE,  -- 算法选择
LOCK = NONE;          -- 锁级别选择
```

**🔧 ALGORITHM=COPY（复制算法）**
```
工作原理：
1. 创建新表结构
2. 复制所有数据到新表
3. 删除旧表，重命名新表

类比：推倒重建房子
🏠 → 🚧 → 🏠

特点：
❌ 耗时长，需要复制所有数据
❌ 占用双倍存储空间
❌ 锁定时间长
✅ 兼容性好，所有变更都支持
```

**🚀 ALGORITHM=INPLACE（就地算法）**
```
工作原理：
1. 在原表基础上直接修改
2. 只修改元数据或重新组织数据
3. 最小化数据复制

类比：装修改造房子
🏠 → 🔨 → 🏠

特点：
✅ 速度快，减少数据复制
✅ 节省存储空间
✅ 锁定时间短
❌ 不是所有操作都支持
```

**📊 算法选择对比**

| 操作类型 | INPLACE支持 | 推荐算法 | 原因 |
|---------|-------------|----------|------|
| **添加字段** | ✅ | `INPLACE` | 只需修改元数据 |
| **删除字段** | ✅ | `INPLACE` | 逻辑删除，速度快 |
| **修改字段类型** | 部分支持 | 看情况 | 兼容类型用INPLACE |
| **添加索引** | ✅ | `INPLACE` | 专门优化过 |
| **修改存储引擎** | ❌ | `COPY` | 必须重建表 |

### 3.2 锁等级控制机制


**🔸 LOCK参数详解**
锁等级决定了变更过程中**其他操作的可用性**：

```sql
ALTER TABLE users 
ADD COLUMN phone VARCHAR(20),
LOCK = NONE;  -- 允许并发读写
```

**🔒 锁等级分类**

| 锁级别 | 读操作 | 写操作 | 适用场景 |
|--------|--------|--------|----------|
| **NONE** | ✅ 允许 | ✅ 允许 | 理想情况，零影响 |
| **SHARED** | ✅ 允许 | ❌ 阻塞 | 允许查询，禁止修改 |
| **EXCLUSIVE** | ❌ 阻塞 | ❌ 阻塞 | 完全锁定，传统方式 |

**🎯 锁选择策略**
```
业务影响评估：
LOCK=NONE：
• 适用：大部分在线DDL操作
• 影响：几乎无影响，业务正常运行

LOCK=SHARED：
• 适用：需要阻止写入的场景
• 影响：只读操作正常，写入需等待

LOCK=EXCLUSIVE：
• 适用：复杂结构变更
• 影响：表完全不可用，业务中断
```

### 3.3 在线DDL工作流程


**🔸 在线DDL执行过程**
```
执行阶段流程：

阶段1：准备阶段（Prepare）
├─ 检查DDL语句合法性
├─ 确定使用的算法和锁级别
├─ 获取必要的元数据锁
└─ 创建临时文件（如需要）

阶段2：执行阶段（Execute）  
├─ 应用结构变更
├─ 重建索引（如需要）
├─ 记录并发DML操作
└─ 验证数据一致性

阶段3：提交阶段（Commit）
├─ 应用增量变更
├─ 更新数据字典
├─ 释放临时资源
└─ 释放所有锁
```

**⏱️ 时序图**
```
用户会话A          MySQL服务器         用户会话B
    |                   |                   |
    |--ALTER TABLE----->|                   |
    |   ADD COLUMN      |                   |
    |                   |--获取MDL锁------->|
    |                   |                   |
    |                   |===执行DDL变更===| |
    |                   |                   |--SELECT查询--->|
    |                   |                   |<--正常返回-----|
    |                   |                   |                |
    |                   |--应用增量变更--->|                |
    |<--变更完成--------|                   |                |
    |                   |--释放MDL锁------>|                |
```

---

## 4. 🔧 大表结构变更策略


### 4.1 大表变更面临的挑战


**🔸 什么是大表？**
```
大表的判断标准：
📊 数据量：超过1000万行记录
💾 存储：表大小超过10GB
⏱️ 操作：单次查询超过30秒
🔄 并发：高并发读写的核心业务表

大表变更的风险：
❌ 长时间锁表，业务中断
❌ 主从复制延迟
❌ 磁盘空间不足
❌ 操作失败后回滚困难
```

### 4.2 大表在线DDL策略


**🔸 MySQL 5.7+在线DDL改进**
```
支持的在线操作（ALGORITHM=INPLACE, LOCK=NONE）：

✅ 添加字段：
ALTER TABLE big_table 
ADD COLUMN new_field VARCHAR(100),
ALGORITHM=INPLACE, LOCK=NONE;

✅ 删除字段：
ALTER TABLE big_table 
DROP COLUMN old_field,
ALGORITHM=INPLACE, LOCK=NONE;

✅ 添加索引：
ALTER TABLE big_table 
ADD INDEX idx_name (column_name),
ALGORITHM=INPLACE, LOCK=NONE;

⚠️ 需要复制的操作：
• 修改字段类型（不兼容）
• 修改存储引擎
• 添加主键（表无主键时）
```

**🔸 pt-online-schema-change工具**
```
第三方解决方案，适用于MySQL 5.6及更早版本：

工作原理：
1. 创建新表结构
2. 使用触发器同步变更
3. 分批复制数据
4. 原子性切换表名

优势：
✅ 支持任何结构变更
✅ 可以暂停和恢复
✅ 对业务影响最小
✅ 支持进度监控
```

### 4.3 大表变更最佳实践


**🔸 变更前的准备工作**
```
💾 空间检查：
• 确保有足够磁盘空间（至少2倍表大小）
• 检查临时目录空间
• 监控磁盘使用率

⏰ 时间规划：
• 选择业务低峰期
• 预估变更时间
• 准备回滚方案

📋 风险评估：
• 分析表的读写频率
• 确认相关应用的依赖关系
• 制定应急预案
```

**🔸 分阶段变更策略**
```
策略1：分步执行
-- 第一步：添加字段
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- 第二步：填充数据（应用层处理）
UPDATE users SET phone = '' WHERE phone IS NULL;

-- 第三步：添加约束
ALTER TABLE users MODIFY COLUMN phone VARCHAR(20) NOT NULL;

策略2：影子表切换
1. 创建新结构的影子表
2. 使用程序同步数据
3. 验证数据一致性  
4. 快速切换表名
```

**🔸 变更监控与回滚**
```sql
-- 监控DDL进程
SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE INFO LIKE 'ALTER TABLE%';

-- 查看DDL进度（MySQL 8.0+）
SELECT 
    EVENT_NAME,
    CURRENT_COUNT,
    TOTAL_COUNT,
    PROGRESS
FROM performance_schema.events_stages_current 
WHERE EVENT_NAME LIKE 'stage/innodb/alter%';

-- 紧急停止DDL
KILL QUERY process_id;
```

---

## 5. 💻 实际应用与最佳实践


### 5.1 常见变更场景实例


**🔸 场景1：电商系统用户表扩展**
```sql
-- 需求：用户表添加手机号验证功能
-- 表信息：users表，2000万记录，200GB大小

-- 方案选择：在线DDL
ALTER TABLE users 
ADD COLUMN phone VARCHAR(20) DEFAULT '',
ADD COLUMN phone_verified TINYINT DEFAULT 0,
ALGORITHM=INPLACE, 
LOCK=NONE;

-- 优势：
✅ 用户注册登录不受影响
✅ 执行时间约10分钟
✅ 无需额外存储空间
```

**🔸 场景2：订单表字段类型优化**
```sql
-- 需求：订单金额字段从INT改为DECIMAL
-- 挑战：涉及金钱计算，精度要求高

-- 传统方案（需要停机）：
ALTER TABLE orders 
MODIFY COLUMN amount DECIMAL(10,2);

-- 在线方案：
-- 1. 添加新字段
ALTER TABLE orders 
ADD COLUMN amount_new DECIMAL(10,2),
ALGORITHM=INPLACE, LOCK=NONE;

-- 2. 应用层逐步迁移数据
UPDATE orders 
SET amount_new = amount/100 
WHERE amount_new IS NULL 
LIMIT 10000;

-- 3. 验证完成后切换使用新字段
```

### 5.2 性能优化技巧


**🔸 优化参数设置**
```sql
-- 增加排序缓冲区，加速索引创建
SET SESSION sort_buffer_size = 256*1024*1024;

-- 设置在线DDL最大内存
SET SESSION innodb_online_alter_log_max_size = 1GB;

-- 调整并发级别
SET SESSION innodb_ddl_threads = 4;
```

**🔸 监控关键指标**
```
实时监控项目：
📊 CPU使用率：DDL操作CPU密集
💾 内存使用：临时排序缓冲区
🔄 磁盘IO：数据复制和索引重建
🔒 锁等待：检查是否有阻塞
```

### 5.3 常见问题与解决方案


**❓ 问题1：在线DDL失败怎么办？**
```
常见失败原因：
❌ 磁盘空间不足
❌ 内存不够用
❌ 长时间运行被中断
❌ 并发冲突

解决方案：
🔍 分析失败原因，调整参数
🔄 使用分步执行策略
📈 增加系统资源
⏰ 选择更合适的时间窗口
```

**❓ 问题2：如何估算变更时间？**
```
时间估算方法：
📊 数据量 × 处理速度 = 基本时间
🔧 变更类型影响系数
🏃‍♂️ 系统负载影响

经验数据：
• 添加字段：1000万行约5-10分钟
• 添加索引：取决于字段数据分布
• 修改类型：可能需要重建，时间较长

测试方法：
在测试环境用相同数据量测试
```

### 5.4 变更安全检查清单


**📋 变更前检查清单**
```
✅ 备份确认：
   • 确认有最新的完整备份
   • 验证备份的可恢复性
   
✅ 影响评估：
   • 分析变更对应用的影响
   • 确认相关代码已经适配
   
✅ 资源准备：
   • 检查磁盘空间充足
   • 确认系统负载较低
   
✅ 监控准备：
   • 准备监控DDL进度的工具
   • 设置告警机制
   
✅ 回滚预案：
   • 准备回滚SQL语句
   • 确认回滚步骤
```

---

## 6. 📋 核心要点总结


### 6.1 ALTER TABLE核心概念


```
🎯 基本理解：
• ALTER TABLE = 修改表结构的SQL命令
• 就像装修房子，改变房间布局和功能
• 包括添加、删除、修改字段等操作

🔧 操作分类：
• ADD COLUMN：添加新字段，扩展表功能
• DROP COLUMN：删除字段，简化表结构
• MODIFY/CHANGE：修改字段属性或名称
• RENAME TABLE：表重命名，瞬间切换
```

### 6.2 在线DDL核心机制


```
🚀 在线DDL优势：
• 最小化业务中断时间
• 支持并发读写操作
• 提高大表变更的可行性

🔸 算法选择原则：
• INPLACE：优先选择，速度快空间省
• COPY：兼容性好，复杂变更必需

🔒 锁级别控制：
• NONE：理想状态，无锁执行
• SHARED：允许读取，阻塞写入
• EXCLUSIVE：完全锁定，传统方式
```

### 6.3 大表变更策略


```
🏗️ 变更策略选择：
• 小表：直接ALTER TABLE
• 中表：使用在线DDL
• 大表：考虑分步执行或工具辅助

📊 风险控制要点：
• 充分的准备和测试
• 选择合适的时间窗口
• 实时监控执行过程
• 准备完善的回滚方案
```

### 6.4 实际应用指导


```
💡 最佳实践总结：
• 优先使用在线DDL，减少业务影响
• 大表变更要充分测试和规划
• 监控系统资源，确保变更顺利
• 保持良好的变更记录和文档

🔧 技术选型建议：
• MySQL 5.7+：原生在线DDL已经很强大
• 早期版本：考虑pt-online-schema-change
• 超大表：可能需要分库分表解决
```

**核心记忆口诀**：
- ALTER TABLE改结构，添加删除和修改
- 在线DDL减中断，INPLACE算法优先选
- 锁级别控制很重要，NONE最佳SHARED可
- 大表变更需谨慎，测试监控不能少