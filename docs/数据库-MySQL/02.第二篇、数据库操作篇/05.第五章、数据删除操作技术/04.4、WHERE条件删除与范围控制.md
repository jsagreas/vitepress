---
title: 4、WHERE条件删除与范围控制
---
## 📚 目录

1. [WHERE条件删除基础概念](#1-WHERE条件删除基础概念)
2. [WHERE条件的构建与优化](#2-WHERE条件的构建与优化)
3. [复杂WHERE条件设计](#3-复杂WHERE条件设计)
4. [WHERE条件安全性检查](#4-WHERE条件安全性检查)
5. [范围控制与性能优化](#5-范围控制与性能优化)
6. [实际应用案例分析](#6-实际应用案例分析)
7. [核心要点总结](#7-核心要点总结)

---

📍 **当前位置**：数据库操作 > 数据删除 > WHERE条件控制  
🔗 **前置知识**：基本SQL语法、DELETE语句基础  
🔗 **后续学习**：批量删除、事务控制、删除性能优化

📊 **学习指南**
- 难度等级：★★★☆☆
- 预计时间：2-3小时
- 前置要求：SQL基础语法

---

## 1. 🎯 WHERE条件删除基础概念


### 1.1 什么是WHERE条件删除


> **💡 核心理解**  
> WHERE条件删除就像"有选择性的清理"，不是把所有东西都扔掉，而是按照特定标准筛选出要删除的内容。

**🔸 基本定义**
```sql
-- 基本语法
DELETE FROM 表名 WHERE 条件;

-- 生活类比
-- 就像清理衣柜：只扔掉过时的、破损的衣服，保留有用的
```

**💭 生活类比理解**
```
┌─ 💭 生活类比 ─────────────────┐
│ 删除数据 = 清理房间            │
│ • WHERE条件 = 清理标准        │
│ • 没有WHERE = 把房间全清空     │
│ • 精确WHERE = 只扔垃圾        │
│ • 模糊WHERE = 可能扔错东西    │
└───────────────────────────────┘
```

### 1.2 为什么需要WHERE条件


**🚫 危险操作：不带WHERE的删除**
```sql
-- 危险！会删除整张表的所有数据
DELETE FROM users;

-- 就像：把整个通讯录都删掉了
```

**✅ 安全操作：带WHERE条件的删除**
```sql
-- 安全：只删除特定条件的数据
DELETE FROM users WHERE status = 'inactive';

-- 就像：只删除不活跃的联系人
```

### 1.3 WHERE条件删除的基本语法


**📖 语法结构**
```sql
DELETE FROM table_name 
WHERE condition1 [AND|OR condition2...];
```

**🔸 基础示例**
```sql
-- 删除单个条件
DELETE FROM products WHERE price = 0;

-- 删除多个条件（AND）
DELETE FROM users WHERE age < 18 AND status = 'inactive';

-- 删除多个条件（OR）
DELETE FROM logs WHERE level = 'DEBUG' OR created_date < '2024-01-01';
```

---

## 2. 🔧 WHERE条件的构建与优化


### 2.1 基本WHERE条件类型


#### 📊 等值条件


**🔸 精确匹配**
```sql
-- 删除特定用户
DELETE FROM users WHERE user_id = 12345;

-- 删除特定状态的记录
DELETE FROM orders WHERE status = 'cancelled';
```

**💡 理解要点**
- 等值条件是最安全的删除方式
- 通常基于主键或唯一索引，执行效率高
- 误删风险最低

#### 📈 范围条件


**🔸 数值范围**
```sql
-- 删除过期数据（30天前）
DELETE FROM logs 
WHERE created_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 删除价格范围内的商品
DELETE FROM products 
WHERE price BETWEEN 0 AND 10;
```

**🔸 时间范围**
```sql
-- 删除指定时间段的数据
DELETE FROM access_logs 
WHERE log_date >= '2024-01-01' 
  AND log_date <= '2024-01-31';

-- 删除N天前的临时数据
DELETE FROM temp_files 
WHERE created_at < CURDATE() - INTERVAL 7 DAY;
```

#### 🔍 模糊匹配条件


**🔸 LIKE模式匹配**
```sql
-- 删除测试用户（用户名包含test）
DELETE FROM users WHERE username LIKE '%test%';

-- 删除特定前缀的文件记录
DELETE FROM file_records WHERE filename LIKE 'temp_%';
```

**⚠️ 注意事项**
```
模糊匹配的风险：
• '%关键词%' 可能匹配到意外数据
• 执行前务必先用 SELECT 验证结果
• 建议先备份相关数据
```

#### 📝 空值和非空条件


**🔸 空值处理**
```sql
-- 删除空值记录
DELETE FROM contacts WHERE email IS NULL;

-- 删除空字符串记录
DELETE FROM products WHERE description = '' OR description IS NULL;

-- 删除有效数据外的记录
DELETE FROM users WHERE phone IS NULL AND email IS NULL;
```

### 2.2 WHERE条件的性能优化


#### 🚀 索引优化策略


**🔸 利用索引的WHERE条件**
```sql
-- 好的做法：使用索引列
DELETE FROM users WHERE user_id = 12345;  -- 主键索引
DELETE FROM orders WHERE order_date = '2024-01-01';  -- 如果有日期索引

-- 不好的做法：避免在索引列上使用函数
DELETE FROM users WHERE UPPER(username) = 'ADMIN';  -- 会导致索引失效
```

**📈 索引使用效果对比**
```
性能对比：
有索引条件：    ██████████ 100% (毫秒级)
无索引条件：    ███░░░░░░░ 30% (秒级)
函数条件：      ██░░░░░░░░ 20% (更慢)
```

#### ⚡ 批量删除优化


**🔸 大数据量删除策略**
```sql
-- 方法1：分批删除（推荐）
DELETE FROM large_table 
WHERE created_date < '2024-01-01' 
LIMIT 1000;
-- 重复执行直到删除完成

-- 方法2：使用事务控制
START TRANSACTION;
DELETE FROM users WHERE status = 'inactive' LIMIT 500;
COMMIT;
```

**🔧 为什么要分批删除**
```
大批量删除的问题：
• 锁定时间过长，影响其他操作
• 可能导致日志文件过大
• 回滚空间需求巨大
• 系统响应变慢

分批删除的优势：
• 减少锁定时间
• 控制资源占用
• 可以中途停止
• 降低系统压力
```

### 2.3 WHERE条件的逻辑组合


#### 🔗 AND逻辑组合


**🔸 多条件同时满足**
```sql
-- 删除同时满足多个条件的记录
DELETE FROM users 
WHERE age < 18 
  AND registration_date < '2023-01-01'
  AND last_login IS NULL;
```

**💭 逻辑理解**
```
AND条件就像"过滤漏斗"：
所有条件都必须满足才会被删除
条件越多，删除的数据越少（更安全）
```

#### 🔀 OR逻辑组合


**🔸 多条件任一满足**
```sql
-- 删除满足任一条件的记录
DELETE FROM temp_data 
WHERE status = 'expired' 
   OR created_date < '2024-01-01'
   OR file_size = 0;
```

**💭 逻辑理解**
```
OR条件就像"多个入口"：
满足任何一个条件都会被删除
条件越多，删除的数据越多（需谨慎）
```

#### 🎯 复杂逻辑组合


**🔸 括号控制优先级**
```sql
-- 复杂条件组合
DELETE FROM user_sessions 
WHERE (status = 'expired' OR last_activity < DATE_SUB(NOW(), INTERVAL 1 DAY))
  AND user_type != 'admin';
```

**📊 逻辑优先级说明**
```
优先级顺序（高到低）：
1. 括号 ()
2. NOT
3. AND  
4. OR

示例理解：
(A OR B) AND C  ≠  A OR B AND C
前者：(A或B) 且 C
后者：A 或 (B且C)
```

---

## 3. 🛠️ 复杂WHERE条件设计


### 3.1 子查询条件删除


#### 🔍 EXISTS子查询


**🔸 基于存在性删除**
```sql
-- 删除没有订单的用户
DELETE FROM users 
WHERE NOT EXISTS (
    SELECT 1 FROM orders WHERE orders.user_id = users.user_id
);
```

**💭 理解EXISTS**
```
EXISTS就像"检查清单"：
• EXISTS: 如果子查询返回至少一行，条件为真
• NOT EXISTS: 如果子查询返回0行，条件为真
• 只关心是否存在，不关心具体返回什么数据
```

#### 📋 IN子查询


**🔸 基于列表删除**
```sql
-- 删除特定部门的员工
DELETE FROM employees 
WHERE department_id IN (
    SELECT dept_id FROM departments WHERE status = 'closed'
);

-- 删除重复数据（保留ID最小的）
DELETE FROM products 
WHERE id NOT IN (
    SELECT MIN(id) FROM products GROUP BY name
);
```

### 3.2 关联表条件删除


#### 🔗 JOIN条件删除


**🔸 多表关联删除**
```sql
-- MySQL语法：删除关联表中的数据
DELETE u FROM users u
INNER JOIN user_profiles p ON u.user_id = p.user_id
WHERE p.account_type = 'trial' AND p.expires_date < NOW();

-- 标准SQL语法（兼容性更好）
DELETE FROM users 
WHERE user_id IN (
    SELECT user_id FROM user_profiles 
    WHERE account_type = 'trial' AND expires_date < NOW()
);
```

**🔸 关联删除示例场景**
```sql
-- 场景：删除无效的购物车项目
-- （商品已下架或库存为0）
DELETE FROM cart_items 
WHERE product_id IN (
    SELECT product_id FROM products 
    WHERE status = 'discontinued' OR stock = 0
);
```

### 3.3 条件表达式高级用法


#### 🧮 CASE条件删除


**🔸 条件分支删除**
```sql
-- 根据不同条件删除不同数据
DELETE FROM user_actions 
WHERE 
    CASE 
        WHEN action_type = 'login' THEN created_date < DATE_SUB(NOW(), INTERVAL 90 DAY)
        WHEN action_type = 'view' THEN created_date < DATE_SUB(NOW(), INTERVAL 30 DAY)
        WHEN action_type = 'download' THEN created_date < DATE_SUB(NOW(), INTERVAL 365 DAY)
        ELSE FALSE
    END;
```

#### 📊 正则表达式条件


**🔸 模式匹配删除**
```sql
-- MySQL：使用正则表达式
DELETE FROM temp_files 
WHERE filename REGEXP '^temp_[0-9]{8}_.*\.tmp$';

-- PostgreSQL：使用正则表达式
DELETE FROM logs 
WHERE message ~ '^ERROR:.*timeout.*$';
```

---

## 4. 🔒 WHERE条件安全性检查


### 4.1 删除前的安全验证


#### 🔍 预览删除结果


**🔸 删除前先查询**
```sql
-- 第一步：先查看要删除的数据
SELECT COUNT(*) FROM users WHERE last_login < '2023-01-01';
SELECT * FROM users WHERE last_login < '2023-01-01' LIMIT 10;

-- 第二步：确认无误后执行删除
DELETE FROM users WHERE last_login < '2023-01-01';
```

**💡 安全删除流程**
```
安全删除步骤：
1. 编写SELECT语句预览 ✓
2. 检查数据条数和内容 ✓  
3. 备份相关数据 ✓
4. 在测试环境验证 ✓
5. 正式环境执行删除 ✓
6. 验证删除结果 ✓
```

#### 🛡️ 防误删机制


**🔸 事务保护**
```sql
-- 使用事务确保安全
BEGIN;
DELETE FROM products WHERE price = 0;
-- 检查删除结果
SELECT COUNT(*) FROM products;
-- 如果结果正确则提交，否则回滚
COMMIT;  -- 或 ROLLBACK;
```

**🔸 限制条件验证**
```sql
-- 添加额外的安全检查
DELETE FROM users 
WHERE status = 'inactive' 
  AND last_login < DATE_SUB(NOW(), INTERVAL 365 DAY)
  AND created_date < DATE_SUB(NOW(), INTERVAL 30 DAY)  -- 避免删除新注册用户
  LIMIT 1000;  -- 限制删除数量
```

### 4.2 WHERE条件的风险识别


#### ⚠️ 常见危险条件


**🔸 过于宽泛的条件**
```sql
-- 危险：条件过于宽泛
DELETE FROM users WHERE name LIKE '%a%';  -- 可能删除大量数据

-- 危险：只基于单个模糊字段
DELETE FROM products WHERE description LIKE '%test%';

-- 改进：增加更严格的限制条件
DELETE FROM products 
WHERE description LIKE '%test%' 
  AND category = 'test_category'
  AND created_by = 'test_user';
```

**🔸 空值条件的陷阱**
```sql
-- 可能有风险：空值判断
DELETE FROM contacts WHERE phone = '';  -- 只删除空字符串
DELETE FROM contacts WHERE phone IS NULL;  -- 只删除NULL值

-- 更安全：组合条件
DELETE FROM contacts 
WHERE (phone IS NULL OR phone = '')
  AND email IS NOT NULL  -- 确保还有其他联系方式
  AND status = 'inactive';
```

#### 🔍 条件验证方法


**🔸 数据量验证**
```sql
-- 验证删除数量是否合理
SELECT COUNT(*) as delete_count 
FROM users 
WHERE status = 'inactive';

-- 如果数量异常大，需要重新检查条件
-- 正常情况下，单次删除不应超过总数据的10%
```

**🔸 关键数据保护**
```sql
-- 确保不会删除重要数据
SELECT COUNT(*) as admin_count
FROM users 
WHERE status = 'inactive' AND role = 'admin';

-- 如果查询结果大于0，说明条件有问题
-- 管理员账户不应该被标记为inactive
```

---

## 5. ⚡ 范围控制与性能优化


### 5.1 时间范围控制


#### 📅 日期范围最佳实践


**🔸 常用时间范围模式**
```sql
-- 删除30天前的日志
DELETE FROM access_logs 
WHERE log_date < DATE_SUB(CURDATE(), INTERVAL 30 DAY);

-- 删除指定月份的数据
DELETE FROM monthly_reports 
WHERE report_month BETWEEN '2024-01' AND '2024-03';

-- 删除今天之前的临时数据
DELETE FROM temp_cache 
WHERE created_date < CURDATE();
```

**⏰ 时间函数对比**
| 函数 | **用途** | **返回格式** | **示例** |
|------|---------|-------------|----------|
| `NOW()` | 当前日期时间 | YYYY-MM-DD HH:MM:SS | 2024-01-15 14:30:25 |
| `CURDATE()` | 当前日期 | YYYY-MM-DD | 2024-01-15 |
| `CURTIME()` | 当前时间 | HH:MM:SS | 14:30:25 |
| `DATE_SUB()` | 日期减法 | 同输入格式 | 2024-01-14 14:30:25 |

#### 🎯 分区表的范围删除


**🔸 按分区删除（高效）**
```sql
-- 删除整个分区（极快）
ALTER TABLE sales_data DROP PARTITION p_2023_q1;

-- 按分区键删除
DELETE FROM sales_data WHERE sale_date >= '2024-01-01';
```

### 5.2 数据量范围控制


#### 📊 LIMIT控制删除量


**🔸 分批删除大数据**
```sql
-- 分批删除：每次删除1000条
DELETE FROM large_table 
WHERE status = 'processed' 
LIMIT 1000;

-- 配合循环使用（伪代码）
WHILE (affected_rows > 0) {
    DELETE FROM table WHERE condition LIMIT 1000;
    SLEEP(1);  -- 给系统缓冲时间
}
```

**🔸 删除进度监控**
```sql
-- 监控删除进度
SELECT 
    COUNT(*) as remaining_count,
    (SELECT COUNT(*) FROM original_backup) as total_count,
    ROUND(
        (1 - COUNT(*) / (SELECT COUNT(*) FROM original_backup)) * 100, 2
    ) as progress_percent
FROM large_table 
WHERE status = 'to_delete';
```

### 5.3 性能优化技巧


#### 🏃 执行计划分析


**🔸 分析DELETE性能**
```sql
-- 查看执行计划
EXPLAIN DELETE FROM users WHERE last_login < '2023-01-01';

-- 优化建议：
-- 1. 确保WHERE条件列有索引
-- 2. 避免在WHERE中使用函数
-- 3. 使用LIMIT控制批次大小
```

#### 🔧 索引策略优化


**🔸 删除操作的索引考虑**
```sql
-- 为常用删除条件创建索引
CREATE INDEX idx_user_last_login ON users(last_login);
CREATE INDEX idx_log_created_date ON logs(created_date);

-- 复合索引支持多条件删除
CREATE INDEX idx_user_status_date ON users(status, last_login);
```

**📈 索引对删除性能的影响**
```
无索引删除：
扫描方式：全表扫描
时间复杂度：O(n)
适用场景：小表或删除大部分数据

有索引删除：
扫描方式：索引扫描
时间复杂度：O(log n)  
适用场景：大表精确删除
```

---

## 6. 🎯 实际应用案例分析


### 6.1 日志数据清理


#### 📝 系统日志清理策略


**🔸 按日志级别和时间清理**
```sql
-- 清理调试日志（保留7天）
DELETE FROM system_logs 
WHERE log_level = 'DEBUG' 
  AND created_time < DATE_SUB(NOW(), INTERVAL 7 DAY)
LIMIT 5000;

-- 清理信息日志（保留30天）  
DELETE FROM system_logs 
WHERE log_level = 'INFO'
  AND created_time < DATE_SUB(NOW(), INTERVAL 30 DAY)
LIMIT 5000;

-- 错误日志保留更久（90天）
DELETE FROM system_logs 
WHERE log_level = 'ERROR'
  AND created_time < DATE_SUB(NOW(), INTERVAL 90 DAY)
LIMIT 1000;
```

**🔧 自动化清理脚本**
```sql
-- 创建存储过程自动清理
DELIMITER $$
CREATE PROCEDURE CleanupLogs()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    
    -- 循环删除直到无数据
    REPEAT
        DELETE FROM system_logs 
        WHERE log_level = 'DEBUG' 
          AND created_time < DATE_SUB(NOW(), INTERVAL 7 DAY)
        LIMIT batch_size;
        
    UNTIL ROW_COUNT() = 0 END REPEAT;
END$$
DELIMITER ;

-- 定期调用
CALL CleanupLogs();
```

### 6.2 用户数据清理


#### 👤 非活跃用户清理


**🔸 多维度判断非活跃用户**
```sql
-- 删除长期非活跃用户
DELETE FROM users 
WHERE status = 'inactive'
  AND last_login < DATE_SUB(NOW(), INTERVAL 365 DAY)  -- 一年未登录
  AND registration_date < DATE_SUB(NOW(), INTERVAL 30 DAY)  -- 注册超过30天
  AND role != 'admin'  -- 保护管理员账户
  AND (
      SELECT COUNT(*) FROM orders WHERE orders.user_id = users.user_id
  ) = 0;  -- 没有订单记录
```

**🔒 VIP用户保护**
```sql
-- 确保不会误删VIP用户
DELETE FROM users 
WHERE status = 'inactive'
  AND user_id NOT IN (
      SELECT user_id FROM vip_members WHERE status = 'active'
  )
  AND user_id NOT IN (
      SELECT user_id FROM recent_purchases 
      WHERE purchase_date > DATE_SUB(NOW(), INTERVAL 180 DAY)
  );
```

### 6.3 缓存数据清理


#### 🗂️ 临时文件清理


**🔸 按文件类型和时间清理**
```sql
-- 清理不同类型的临时文件
DELETE FROM temp_files 
WHERE 
    -- 图片缓存（保留3天）
    (file_type = 'image' AND created_date < DATE_SUB(NOW(), INTERVAL 3 DAY))
    OR 
    -- 文档缓存（保留7天）
    (file_type = 'document' AND created_date < DATE_SUB(NOW(), INTERVAL 7 DAY))
    OR
    -- 视频缓存（保留1天）
    (file_type = 'video' AND created_date < DATE_SUB(NOW(), INTERVAL 1 DAY))
    OR
    -- 空文件立即删除
    (file_size = 0);
```

#### 🧹 会话数据清理


**🔸 过期会话清理**
```sql
-- 清理过期的用户会话
DELETE FROM user_sessions 
WHERE 
    -- 未登录用户的临时会话（30分钟）
    (user_id IS NULL AND created_time < DATE_SUB(NOW(), INTERVAL 30 MINUTE))
    OR
    -- 已登录用户的过期会话（7天）
    (user_id IS NOT NULL AND last_activity < DATE_SUB(NOW(), INTERVAL 7 DAY))
    OR
    -- 标记为已注销的会话
    (status = 'logged_out');
```

---

## 7. 🔍 WHERE条件最佳实践


### 7.1 安全检查清单


📋 **删除前必检项目**
- [ ] **数据预览**：用SELECT先查看要删除的数据
- [ ] **数量检查**：确认删除数量在合理范围内
- [ ] **备份确认**：重要数据已备份
- [ ] **条件验证**：WHERE条件逻辑正确
- [ ] **权限确认**：有足够的删除权限
- [ ] **影响评估**：评估对业务的影响

### 7.2 性能优化指南


**⚡ 性能优化策略**
```
🔸 索引优化：
• 为WHERE条件列创建合适索引
• 避免在索引列上使用函数
• 利用复合索引支持多条件查询

🔸 批量处理：
• 大数据量删除采用分批策略
• 控制每批删除的数量（1000-10000条）
• 批次间适当延迟，避免系统压力过大

🔸 时间选择：
• 在业务低峰期执行大批量删除
• 避免在事务高峰期执行
• 监控系统资源使用情况
```

### 7.3 错误处理与回滚


**🔧 错误处理机制**
```sql
-- 带错误处理的删除操作
START TRANSACTION;

-- 设置保存点
SAVEPOINT before_delete;

-- 执行删除
DELETE FROM user_data WHERE status = 'expired';

-- 检查结果
SELECT ROW_COUNT() as deleted_rows;

-- 如果删除数量异常，回滚到保存点
-- ROLLBACK TO before_delete;

-- 如果正常，提交事务
COMMIT;
```

**📊 删除结果验证**
```sql
-- 验证删除效果
SELECT 
    'Before' as timing,
    COUNT(*) as record_count 
FROM backup_table
UNION ALL
SELECT 
    'After' as timing,
    COUNT(*) as record_count 
FROM main_table;
```

---

## 8. 🛠️ 高级WHERE条件技巧


### 8.1 窗口函数在删除中的应用


#### 📊 基于排名的删除


**🔸 删除重复数据（保留最新）**
```sql
-- 使用窗口函数标识重复数据
DELETE FROM products 
WHERE id NOT IN (
    SELECT id FROM (
        SELECT id,
               ROW_NUMBER() OVER (
                   PARTITION BY name, category 
                   ORDER BY created_date DESC
               ) as rn
        FROM products
    ) ranked
    WHERE rn = 1
);
```

**💡 窗口函数删除原理**
```
工作步骤：
1. 按业务字段分组（PARTITION BY）
2. 组内按时间排序（ORDER BY）
3. 给每行分配序号（ROW_NUMBER）
4. 保留序号为1的记录（最新）
5. 删除其他重复记录
```

### 8.2 动态WHERE条件构建


#### 🔄 参数化删除条件


**🔸 存储过程中的动态条件**
```sql
DELIMITER $$
CREATE PROCEDURE DynamicDelete(
    IN table_name VARCHAR(64),
    IN condition_field VARCHAR(64),
    IN condition_value VARCHAR(255),
    IN time_limit INT
)
BEGIN
    SET @sql = CONCAT(
        'DELETE FROM ', table_name,
        ' WHERE ', condition_field, ' = ''', condition_value, '''',
        ' AND created_date < DATE_SUB(NOW(), INTERVAL ', time_limit, ' DAY)',
        ' LIMIT 1000'
    );
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    SELECT ROW_COUNT() as deleted_rows;
END$$
DELIMITER ;

-- 调用示例
CALL DynamicDelete('temp_data', 'status', 'expired', 7);
```

### 8.3 条件组合的高级模式


#### 🎲 复杂业务逻辑删除


**🔸 电商业务删除示例**
```sql
-- 删除无效的购物车数据
DELETE FROM shopping_cart 
WHERE 
    -- 商品已下架
    product_id IN (SELECT id FROM products WHERE status = 'discontinued')
    OR
    -- 用户已注销
    user_id IN (SELECT id FROM users WHERE status = 'deleted')
    OR  
    -- 购物车超过30天未更新
    (updated_time < DATE_SUB(NOW(), INTERVAL 30 DAY))
    OR
    -- 商品价格异常（可能是数据错误）
    product_id IN (
        SELECT id FROM products WHERE price <= 0 OR price > 999999
    );
```

**🔸 用户行为数据清理**
```sql
-- 清理用户行为追踪数据
DELETE FROM user_behavior_logs 
WHERE 
    -- 测试用户的数据
    (user_id IN (SELECT id FROM users WHERE email LIKE '%test%'))
    OR
    -- 爬虫访问数据（基于行为特征）
    (
        action_type = 'page_view' 
        AND time_spent < 1  -- 停留时间过短
        AND user_agent LIKE '%bot%'
    )
    OR
    -- 过期的行为数据
    (created_date < DATE_SUB(NOW(), INTERVAL 90 DAY))
    AND event_type NOT IN ('purchase', 'registration');  -- 保留重要事件
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 WHERE条件删除：有选择性的数据清理，而不是全部删除
🔸 安全第一原则：删除前必须预览，重要数据必须备份
🔸 条件构建：等值、范围、模糊、空值等不同类型条件
🔸 性能优化：利用索引、分批删除、避免全表扫描
🔸 风险控制：防止误删、限制删除量、事务保护
```

### 9.2 关键理解要点


**🔹 WHERE条件的本质作用**
```
数据筛选器：
• WHERE条件 = 筛选规则
• 没有WHERE = 删除所有（极危险）
• 精确WHERE = 精准删除（安全）
• 模糊WHERE = 范围删除（需谨慎）
```

**🔹 安全删除的思维模式**
```
删除前三问：
1. 删除的是什么数据？（SELECT先预览）
2. 为什么要删除？（业务逻辑确认）
3. 删除后能恢复吗？（备份和回滚策略）

删除后三查：
1. 删除了多少条？（ROW_COUNT检查）
2. 还剩什么数据？（剩余数据验证）
3. 业务是否正常？（功能测试）
```

**🔹 性能与安全的平衡**
```
性能考虑：
• 使用索引提高WHERE条件效率
• 分批删除避免长时间锁定
• 选择合适的删除时机

安全考虑：
• 事务保护支持回滚
• 限制单次删除数量
• 多层条件验证防误删
```

### 9.3 实际应用指导


**🎯 典型应用场景**
- **数据清理**：定期清理过期、无效、冗余数据
- **性能优化**：删除影响查询性能的垃圾数据
- **存储管理**：控制数据库大小，节省存储空间
- **合规要求**：按法规要求删除用户个人数据
- **系统维护**：清理测试数据、临时数据

**🔧 最佳实践总结**
```
DELETE操作黄金法则：

1. 🔍 先SELECT后DELETE
   SELECT * FROM table WHERE conditions;  -- 预览
   DELETE FROM table WHERE conditions;    -- 执行

2. 🔒 事务保护
   BEGIN; DELETE...; 检查结果; COMMIT/ROLLBACK;

3. 📊 分批处理  
   大量数据用LIMIT分批，避免长时间锁定

4. 📋 条件严格
   多个条件组合，确保删除精准

5. 🛡️ 备份先行
   重要数据删除前必须备份
```

**🧠 记忆技巧**
```
🎵 WHERE删除口诀：
"条件明确才删除，预览备份要记牢
分批处理性能好，事务保护最重要"
```

**📍 学习检查清单**
- [ ] 理解WHERE条件删除的基本语法
- [ ] 掌握不同类型条件的写法
- [ ] 了解删除操作的安全检查方法
- [ ] 熟悉性能优化的关键技巧
- [ ] 能够处理复杂的业务删除场景

**🔗 相关知识链接**
- 前置学习：[DELETE语句基础](#)
- 相关主题：[数据库索引优化](#)
- 进阶学习：[批量删除策略](#)

**核心记忆**：
- WHERE条件删除是精准数据清理的基础技能
- 安全第一，性能第二，业务逻辑第三
- 条件越精确，删除越安全
- 分批处理是大数据删除的最佳实践