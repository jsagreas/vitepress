---
title: 29、多版本DELETE与MVCC交互
---
## 📚 目录

1. [MVCC与DELETE基础概念](#1-MVCC与DELETE基础概念)
2. [DELETE操作版本链管理](#2-DELETE操作版本链管理)
3. [删除可见性判断机制](#3-删除可见性判断机制)
4. [旧版本数据清理机制](#4-旧版本数据清理机制)
5. [长事务对DELETE的影响](#5-长事务对DELETE的影响)
6. [版本链长度控制策略](#6-版本链长度控制策略)
7. [MVCC性能监控与优化](#7-MVCC性能监控与优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 MVCC与DELETE基础概念


### 1.1 什么是MVCC

**MVCC**（多版本并发控制）是MySQL保证数据一致性的核心机制，简单说就是**"给每行数据保存多个版本"**。

```
现实生活类比：
文档编辑 = 数据修改
版本历史 = MVCC版本链

Word文档编辑：
├── 版本1：原始文档
├── 版本2：张三修改后  
├── 版本3：李四修改后
└── 版本4：王五删除后

每个人都能看到他开始编辑时的版本，不会互相干扰
```

**🔸 MVCC核心思想**
- **读不阻塞写**：读操作不会阻塞写操作
- **写不阻塞读**：写操作不会阻塞读操作  
- **版本隔离**：每个事务看到的是一致的数据快照
- **并发控制**：通过版本管理实现事务隔离

### 1.2 DELETE在MVCC中的特殊性

**DELETE不是真删除**，而是"标记删除"：

```
用户感知：DELETE FROM users WHERE id=1;  # 数据"消失"了
实际情况：数据还在，只是标记为"已删除"

删除标记过程：
原始数据：[id=1, name='张三', version=1, deleted=false]
DELETE后：[id=1, name='张三', version=2, deleted=true]

新事务查询：看不到这条数据（因为deleted=true）
老事务查询：仍能看到数据（因为看的是version=1）
```

### 1.3 为什么需要版本链

**多版本存在的原因**：支持不同事务看到不同的数据状态

```
时间线示例：
T1: 事务A开始 -----------> 事务A结束
T2:     事务B开始(DELETE) -----> 事务B结束  
T3:              事务C开始 ----------> 事务C结束

数据版本：
版本1：原始数据（T1时刻）
版本2：删除标记（T2时刻）

查询结果：
事务A：能看到数据（读版本1）
事务B：看不到数据（读版本2）  
事务C：看不到数据（读版本2）
```

---

## 2. 🔗 DELETE操作版本链管理


### 2.1 InnoDB行记录结构

在InnoDB中，每行数据都包含隐藏字段来支持MVCC：

```
行记录结构：
┌──────────┬──────────┬──────────┬──────────┬──────────┐
│   用户数据  │   DB_TRX_ID │ DB_ROLL_PTR │ DB_ROW_ID │  删除标记  │
│ (id,name) │  (事务ID)   │ (回滚指针)   │  (行ID)   │ (delete_mark) │
└──────────┴──────────┴──────────┴──────────┴──────────┘

字段说明：
- DB_TRX_ID：最后修改此行的事务ID
- DB_ROLL_PTR：指向undo log中的前一个版本
- DB_ROW_ID：自动生成的行ID（无主键时使用）
- 删除标记：标识该行是否被删除
```

### 2.2 DELETE操作的版本链构建

**🔸 版本链形成过程**
```sql
-- 初始数据
INSERT INTO users VALUES (1, '张三');  -- 事务100

-- 更新操作
UPDATE users SET name='张三modified' WHERE id=1;  -- 事务101

-- 删除操作  
DELETE FROM users WHERE id=1;  -- 事务102
```

**🔸 版本链结构图**
```
当前版本（内存中）：
┌─────────────────────────────────────┐
│ id=1, name='张三modified'           │
│ DB_TRX_ID=102, delete_mark=true     │ ← DELETE设置删除标记
│ DB_ROLL_PTR → undo log              │
└─────────────────────────────────────┘
                    │
                    ▼
undo log 版本链：
┌─────────────────────────────────────┐
│ 版本2：id=1, name='张三modified'     │ ← UPDATE创建的版本
│ DB_TRX_ID=101, delete_mark=false    │
│ DB_ROLL_PTR → 下一个版本             │
└─────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────┐
│ 版本1：id=1, name='张三'            │ ← INSERT创建的版本
│ DB_TRX_ID=100, delete_mark=false    │
│ DB_ROLL_PTR = NULL                 │
└─────────────────────────────────────┘
```

### 2.3 DELETE版本链特点

**🔸 删除标记机制**
```
DELETE操作特点：
- 不物理删除数据
- 在当前版本设置delete_mark=true
- 版本链保持完整，历史版本仍然存在
- 新版本仍然指向旧版本的undo log

与UPDATE的区别：
UPDATE：创建新版本，旧版本进入undo log
DELETE：在当前版本打标记，旧版本仍在undo log
```

---

## 3. 👁️ 删除可见性判断机制


### 3.1 Read View机制

**Read View**是MVCC的核心，它就像"事务开始时的数据快照"。

```
Read View包含信息：
┌─────────────────────────────────────┐
│ m_low_limit_id：    当前最大事务ID+1  │ ← 比这个大的事务都看不到
│ m_up_limit_id：     最小活跃事务ID   │ ← 比这个小的已提交事务都能看到
│ m_creator_trx_id：  创建者事务ID     │ ← 当前事务ID
│ m_ids：            活跃事务ID列表    │ ← 正在运行的事务
└─────────────────────────────────────┘
```

### 3.2 删除数据的可见性规则

**🔸 可见性判断流程**
```
判断步骤（按顺序）：

1. 检查删除标记
   ├── 如果delete_mark=false → 数据未删除，继续判断
   └── 如果delete_mark=true → 数据已删除，需要判断删除是否可见

2. 判断删除事务可见性
   ├── 删除事务ID < m_up_limit_id → 删除可见，数据不可见
   ├── 删除事务ID >= m_low_limit_id → 删除不可见，数据可见
   ├── 删除事务ID在m_ids中 → 删除不可见，数据可见
   └── 其他情况 → 删除可见，数据不可见

3. 查找历史版本
   └── 如果当前版本不可见，沿着版本链查找可见版本
```

### 3.3 删除可见性示例

**🔸 具体场景分析**
```sql
-- 时间T1：事务A开始（事务ID=100）
BEGIN;

-- 时间T2：事务B删除数据（事务ID=101）  
DELETE FROM users WHERE id=1;
COMMIT;

-- 时间T3：事务A查询数据
SELECT * FROM users WHERE id=1;  -- 仍然能看到数据！
```

**🔸 可见性判断过程**
```
事务A的Read View（T1时刻创建）：
├── m_up_limit_id = 100      # 最小活跃事务
├── m_low_limit_id = 102     # 下一个事务ID  
├── m_creator_trx_id = 100   # 当前事务
└── m_ids = [100]           # 活跃事务列表

数据行状态（T3时刻）：
├── DB_TRX_ID = 101         # 删除事务ID
├── delete_mark = true       # 已标记删除
└── 历史版本：DB_TRX_ID = 99 # 原始版本

判断过程：
1. 检查删除标记：delete_mark=true，数据被删除
2. 检查删除事务可见性：101在[100,102)范围内，但101不在m_ids中
3. 结论：删除操作对事务A不可见
4. 结果：事务A仍能看到删除前的数据
```

---

## 4. 🧹 旧版本数据清理机制


### 4.1 Purge线程工作原理

**Purge线程**是MySQL的"清洁工"，负责清理不再需要的历史版本数据。

```
Purge线程工作流程：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   扫描undo log   │ -> │  判断版本可清理   │ -> │   物理删除数据   │
│   找到旧版本     │    │   (无事务使用)   │    │   (真正删除)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 何时可以清理删除的数据

**🔸 清理条件**
```
数据可以被物理删除的条件：
1. 数据被标记为删除（delete_mark=true）
2. 没有任何活跃事务需要看到这个版本
3. 所有可能访问该版本的Read View都已失效

判断逻辑：
最小活跃事务ID > 删除事务ID → 可以清理
```

**🔸 清理时机**
```
Purge触发条件：
- undo log达到一定大小
- 定期清理任务（后台线程）
- 手动触发清理

清理频率控制：
innodb_purge_batch_size = 300    # 每次清理的页数
innodb_purge_threads = 4         # 清理线程数
```

### 4.3 清理过程详解

**🔸 物理删除步骤**
```
步骤1：扫描undo log
├── 找到标记删除的记录
├── 检查删除事务ID
└── 判断是否可以清理

步骤2：验证清理条件
├── 获取当前最小活跃事务ID
├── 比较删除事务ID与最小活跃事务ID
└── 确认没有事务还需要该版本

步骤3：执行物理删除
├── 从主键索引中删除记录
├── 从二级索引中删除记录
├── 清理undo log记录
└── 释放存储空间
```

---

## 5. ⏳ 长事务对DELETE的影响


### 5.1 长事务问题分析

**长事务**是指运行时间很长的事务，它会严重影响DELETE操作的效率。

```
长事务影响示意：
时间轴：
T1 ────────────────────────────────────────→ 长事务A
T2    DELETE ───→ 完成
T3         DELETE ───→ 完成  
T4              DELETE ───→ 完成

问题：
- 长事务A阻止了所有DELETE数据的物理清理
- 版本链越来越长
- 存储空间无法回收
- 查询性能下降
```

### 5.2 长事务影响的具体表现

**🔸 存储空间问题**
```sql
-- 场景：长事务运行期间大量DELETE操作
BEGIN;  -- 长事务开始

-- 其他会话执行大量删除
DELETE FROM orders WHERE create_time < '2023-01-01';  -- 删除100万条
DELETE FROM logs WHERE log_time < '2023-06-01';       -- 删除500万条

-- 问题表现：
-- 1. 磁盘空间不减少（数据未物理删除）
-- 2. 表空间持续增长
-- 3. 备份文件仍然很大
```

**🔸 性能影响**
```
长版本链导致的性能问题：

查询性能下降：
├── 需要遍历更长的版本链
├── 更多的undo log访问
└── 缓存命中率下降

写入性能影响：
├── undo log空间占用增大
├── 清理工作积压
└── 锁等待时间增加
```

### 5.3 长事务检测方法

**🔸 查找长事务**
```sql
-- 查看当前活跃事务
SELECT 
    trx_id,
    trx_started,
    trx_query,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_seconds
FROM information_schema.INNODB_TRX
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 60
ORDER BY trx_started;

-- 查看事务持有的锁
SELECT * FROM performance_schema.data_locks 
WHERE THREAD_ID IN (
    SELECT THREAD_ID FROM performance_schema.threads 
    WHERE PROCESSLIST_ID IN (连接ID)
);
```

---

## 6. 📏 版本链长度控制策略


### 6.1 版本链长度监控

**🔸 版本链长度的影响因素**
```
影响版本链长度的因素：

事务频率：
├── 高频UPDATE/DELETE → 版本链增长快
└── 读多写少 → 版本链相对稳定

事务持续时间：
├── 长事务 → 阻止版本清理
└── 短事务 → 版本快速清理

清理效率：
├── Purge线程性能
└── undo log大小限制
```

**🔸 监控版本链长度**
```sql
-- 查看undo log使用情况
SHOW ENGINE INNODB STATUS\G

-- 关注以下指标：
-- History list length: 版本链总长度
-- Purge done for trx's n:o < 清理进度
-- Undo log entries: undo记录数量

-- 查看表空间使用情况
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    ROUND(DATA_LENGTH/1024/1024, 2) as 'Data(MB)',
    ROUND(INDEX_LENGTH/1024/1024, 2) as 'Index(MB)'
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY DATA_LENGTH DESC;
```

### 6.2 版本链长度控制参数

**🔸 关键配置参数**
```ini
[mysqld]
# Purge线程配置
innodb_purge_threads = 4             # 清理线程数量
innodb_purge_batch_size = 300        # 每次清理页数
innodb_max_purge_lag = 0             # 最大清理延迟

# undo log配置
innodb_undo_tablespaces = 3          # undo表空间数量
innodb_undo_log_truncate = ON        # 允许截断undo log
innodb_max_undo_log_size = 1G        # undo log最大大小
```

**🔸 参数调优建议**
```
高DELETE场景优化：
innodb_purge_threads = 8             # 增加清理线程
innodb_purge_batch_size = 500        # 增大批处理大小

低DELETE场景：
innodb_purge_threads = 1             # 减少资源占用
innodb_purge_batch_size = 20         # 减小批处理大小
```

---

## 7. 📊 MVCC性能监控与优化


### 7.1 关键性能指标监控

**🔸 核心监控指标**
```sql
-- 查看MVCC相关状态
SHOW ENGINE INNODB STATUS\G

-- 重点关注指标：
/*
TRANSACTIONS
------------
History list length 1234         # 版本链长度（重要）
Purge done for trx's n:o < 5678  # 清理进度
Total large memory allocated 0   # 大内存分配

INDIVIDUAL BUFFER POOL INFO
---------------------------
Buffer pool hit rate: 99.8%      # 缓冲池命中率
```

**🔸 性能问题识别**
```
问题识别指标：

版本链过长：
├── History list length > 10000
├── 表明有长事务或清理跟不上
└── 需要检查长事务和调整清理参数

清理滞后：
├── Purge进度远落后于当前事务ID
├── 大量undo log积压
└── 需要增加清理线程或批处理大小

缓存命中率下降：
├── Buffer pool hit rate < 95%
├── 可能因为版本链过长导致缓存效率低
└── 需要优化查询或增加缓冲池
```

### 7.2 DELETE性能优化策略

**🔸 应用层优化**
```sql
-- 优化策略1：分批删除
-- 避免一次删除大量数据
DELIMITER $$
CREATE PROCEDURE batch_delete()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_size INT DEFAULT 1000;
    
    REPEAT
        DELETE FROM large_table 
        WHERE create_time < '2023-01-01' 
        LIMIT batch_size;
        
        -- 检查影响行数
        SELECT ROW_COUNT() INTO @affected_rows;
        
        -- 提交当前批次
        COMMIT;
        -- 短暂休息，避免持续高负载
        SELECT SLEEP(0.1);
        
    UNTIL @affected_rows < batch_size END REPEAT;
END$$
DELIMITER ;
```

**🔸 事务管理优化**
```sql
-- 优化策略2：控制事务大小
-- 避免在长事务中执行DELETE

-- ❌ 不好的做法
BEGIN;
SELECT * FROM big_table WHERE complex_condition;  -- 长时间查询
-- ... 其他操作 ...
DELETE FROM another_table WHERE id < 1000;        -- 在长事务中删除
COMMIT;

-- ✅ 好的做法  
BEGIN;
DELETE FROM another_table WHERE id < 1000;        -- 独立短事务删除
COMMIT;

BEGIN;
SELECT * FROM big_table WHERE complex_condition;  -- 查询放在另一个事务
COMMIT;
```

### 7.3 系统级优化配置

**🔸 MVCC相关参数优化**
```ini
[mysqld]
# 事务隔离级别（影响MVCC行为）
transaction-isolation = READ-COMMITTED    # 减少版本链访问

# undo log优化
innodb_undo_log_truncate = ON            # 启用undo log截断
innodb_purge_rseg_truncate_frequency = 128  # 截断频率

# 缓冲池优化
innodb_buffer_pool_size = 8G             # 增大缓冲池
innodb_buffer_pool_instances = 8         # 多实例减少竞争
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念

```
🔸 DELETE本质：不是物理删除，而是标记删除（delete_mark=true）
🔸 版本链机制：DELETE后数据仍在版本链中，支持事务隔离
🔸 可见性规则：通过Read View判断删除数据是否对当前事务可见
🔸 Purge清理：后台线程负责物理删除不再需要的版本数据
🔸 长事务影响：长事务会阻止版本数据清理，导致空间和性能问题
```

### 8.2 关键理解要点


**🔹 为什么DELETE不立即删除**
```
设计原因：
- 支持事务隔离：其他事务可能还需要看到删除前的数据
- 保证一致性：避免读操作看到"一半删除"的状态
- 性能考虑：标记删除比物理删除更快

实际影响：
- 磁盘空间不会立即释放
- 需要等待Purge线程清理
- 可能出现"删除了但空间不减少"的现象
```

**🔹 Read View与删除可见性**
```
核心原理：
- Read View在事务开始时创建
- 记录了"哪些事务的修改可以看到"
- DELETE操作也是一种修改，同样受可见性规则约束

实际表现：
- 删除前开始的事务：仍能看到删除的数据
- 删除后开始的事务：看不到删除的数据
- 这就是"快照隔离"的体现
```

**🔹 长事务的危害**
```
直接影响：
- 阻止Purge线程清理删除的数据
- 版本链持续增长
- 存储空间无法回收

间接影响：
- 查询需要遍历更长的版本链
- 缓存效率下降
- 整体性能恶化

解决思路：
- 避免长事务
- 分批处理大量DELETE
- 监控和及时处理异常事务
```

### 8.3 实际应用指导


**🔸 DELETE操作最佳实践**
```
生产环境建议：

分批删除大量数据：
✅ 设置合理的批次大小（1000-10000行）
✅ 每批次后COMMIT并短暂休息
✅ 避免一次删除百万级数据

控制事务大小：
✅ DELETE操作使用独立短事务
✅ 避免在长查询事务中执行DELETE
✅ 及时提交或回滚事务

监控版本链长度：
✅ 定期检查 History list length
✅ 关注 Purge 清理进度
✅ 监控表空间使用情况
```

**🔸 故障排查思路**
```
DELETE性能问题排查：
1. 检查是否有长事务：
   SELECT * FROM information_schema.INNODB_TRX;

2. 检查版本链长度：
   SHOW ENGINE INNODB STATUS\G

3. 检查Purge线程状态：
   # 查看Purge线程是否正常工作

4. 检查删除数据量：
   # 评估是否一次删除过多数据

解决方案：
- 终止异常长事务
- 分批执行大量DELETE
- 调整Purge相关参数
- 考虑使用TRUNCATE（如果合适）
```

**🔸 性能优化建议**
```
参数调优：
- 增加 innodb_purge_threads 数量
- 调整 innodb_purge_batch_size 大小
- 启用 innodb_undo_log_truncate

应用优化：
- 使用分批删除代替大批量删除
- 避免在业务高峰期执行大量DELETE
- 定期清理历史数据，避免积压

监控告警：
- History list length 超过阈值告警
- 长事务超过时间阈值告警
- 表空间增长异常告警
```

**核心记忆口诀**：
```
DELETE标记不真删，版本链中有记录
Read View定可见，长事务阻清理
Purge线程做清洁，参数调优促性能
分批删除是良策，监控告警保稳定
```