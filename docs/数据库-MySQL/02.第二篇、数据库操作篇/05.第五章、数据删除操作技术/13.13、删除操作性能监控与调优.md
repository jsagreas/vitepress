---
title: 13、删除操作性能监控与调优
---
## 📚 目录

1. [删除操作性能基础](#1-删除操作性能基础)
2. [删除索引优化策略](#2-删除索引优化策略)
3. [批量删除优化技术](#3-批量删除优化技术)
4. [删除锁机制优化](#4-删除锁机制优化)
5. [删除IO性能调优](#5-删除IO性能调优)
6. [删除监控与瓶颈分析](#6-删除监控与瓶颈分析)
7. [删除性能调优实战](#7-删除性能调优实战)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 删除操作性能基础


### 1.1 删除操作的本质


> **💡 核心理解**  
> 删除操作不是简单的"擦除"数据，而是涉及索引维护、空间回收、锁管理等复杂过程

**🔸 删除操作的完整流程**
```
删除一条记录的背后发生了什么：

用户执行: DELETE FROM users WHERE id = 123

数据库内部流程：
┌─────────────────────────────────────┐
│ 1. 解析SQL语句                      │
├─────────────────────────────────────┤
│ 2. 制定执行计划                     │
├─────────────────────────────────────┤
│ 3. 获取必要的锁                     │
├─────────────────────────────────────┤
│ 4. 定位要删除的记录                 │
├─────────────────────────────────────┤
│ 5. 更新所有相关索引                 │
├─────────────────────────────────────┤
│ 6. 标记数据页为可回收               │
├─────────────────────────────────────┤
│ 7. 记录事务日志                     │
├─────────────────────────────────────┤
│ 8. 释放锁资源                       │
└─────────────────────────────────────┘
```

**为什么删除比查询慢？**
- **查询**：只需要读取数据，不改变任何结构
- **删除**：需要更新主索引、所有二级索引、回收空间、记录日志

### 1.2 删除操作的性能影响因素


**📊 主要性能瓶颈**

| 影响因素 | **性能影响** | **典型场景** | **优化难度** |
|---------|-------------|-------------|-------------|
| 🔍 **索引数量** | 每个索引都要更新 | 表有5+个索引 | ⭐⭐⭐☆☆ |
| 🔒 **锁竞争** | 大量并发删除冲突 | 热点数据删除 | ⭐⭐⭐⭐☆ |
| 💾 **IO压力** | 磁盘读写频繁 | 大批量删除 | ⭐⭐⭐⭐⭐ |
| 📝 **日志写入** | 事务日志同步写 | 高频删除操作 | ⭐⭐⭐☆☆ |

> **⚠️ 常见误区**  
> 很多人认为删除就是"把数据扔掉"，实际上删除是数据库中最复杂的操作之一

**🧠 记忆技巧**：删除慢的原因 = **索引锁IO日志**
- **索**引要更新
- **锁**要获取释放  
- **I**O操作频繁
- **日**志要记录

---

## 2. 🔍 删除索引优化策略


### 2.1 删除操作对索引的影响


**什么是索引？简单理解**
```
把索引想象成书的目录：

原始数据表（像书的正文）：
页1: user_id=1, name="张三", age=25
页2: user_id=2, name="李四", age=30  
页3: user_id=3, name="王五", age=22

主键索引（像按页码排序的目录）：
id=1 → 页1
id=2 → 页2  
id=3 → 页3

年龄索引（像按主题分类的目录）：
age=22 → 页3
age=25 → 页1
age=30 → 页2

删除id=2的记录时，要同时删除：
- 主键索引中的 "id=2 → 页2"
- 年龄索引中的 "age=30 → 页2"
```

### 2.2 二级索引维护开销


**🔸 删除时二级索引维护过程**

```
删除操作的索引维护流程：

表结构：users (id, name, email, age, department)
索引：主键(id) + email索引 + age索引 + department索引

执行：DELETE FROM users WHERE id = 1001

索引维护步骤：
┌──────────────────┐    ┌──────────────────┐
│  1. 查找主记录    │ →  │  通过主键定位    │
├──────────────────┤    ├──────────────────┤
│  2. 读取所有字段  │ →  │  获取email,age等  │
├──────────────────┤    ├──────────────────┤
│  3. 删除email索引 │ →  │  定位并删除条目  │
├──────────────────┤    ├──────────────────┤
│  4. 删除age索引   │ →  │  定位并删除条目  │
├──────────────────┤    ├──────────────────┤
│  5. 删除dept索引  │ →  │  定位并删除条目  │
├──────────────────┤    ├──────────────────┤
│  6. 删除主记录    │ →  │  最后删除主数据  │
└──────────────────┘    └──────────────────┘

性能开销：每个索引都要进行一次查找+删除操作
```

**📈 索引数量对删除性能的影响**

```
测试结果对比（删除10万条记录）：

索引数量     删除时间     相对性能
   1个        10秒        基准
   3个        35秒        3.5倍
   5个        65秒        6.5倍
   8个       120秒       12倍

结论：索引越多，删除越慢，几乎是线性增长关系
```

### 2.3 删除索引优化方法


**🔧 索引优化策略**

```sql
-- ❌ 不好的做法：盲目创建索引
CREATE INDEX idx_user_name ON users(name);
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_user_phone ON users(phone);
CREATE INDEX idx_user_address ON users(address);
-- 删除时要维护4个额外索引，性能很差

-- ✅ 优化做法：合理设计索引
-- 只为真正需要的查询创建索引
CREATE INDEX idx_user_email ON users(email);  -- 登录查询需要
CREATE INDEX idx_user_dept_status ON users(department, status);  -- 组合查询需要

-- 对于主要用于删除的表，索引越少越好
```

**🎯 删除操作索引选择原则**

> **📌 核心原则**  
> 为删除操作选择索引时，优先选择**选择性最高**（能过滤最多数据）的索引

```
选择性计算公式：
选择性 = 不重复值数量 / 总记录数

示例分析：
表：orders (100万条记录)
- order_id: 1000000个不重复值，选择性 = 1.0 (最佳)
- user_id: 50000个不重复值，选择性 = 0.05 
- status: 5个不重复值，选择性 = 0.000005 (最差)

删除SQL：DELETE FROM orders WHERE user_id = 123 AND status = 'cancelled'

索引选择策略：
✅ 优先走user_id索引（选择性0.05，能过滤掉95%数据）
❌ 避免走status索引（选择性太低，要扫描很多数据）
```

---

## 3. 📦 批量删除优化技术


### 3.1 批量删除的挑战


**为什么批量删除这么慢？**

想象一下搬家的场景：
- **单条删除**：像一件一件搬东西，每次都要上下楼
- **批量删除**：像一车一车搬，效率高但要考虑车的载重

```
批量删除的主要问题：

1. 长时间锁定：
   DELETE FROM logs WHERE create_time < '2023-01-01'
   可能锁定表几分钟，影响其他操作

2. 内存压力：
   一次删除100万条记录，需要大量内存缓存

3. 事务日志暴增：
   每条删除都要记录日志，日志文件快速增长

4. 主从同步延迟：
   大量删除操作导致从库应用延迟
```

### 3.2 分批删除优化策略


**🔄 分批删除的核心思想**

```sql
-- ❌ 错误做法：一次性删除大量数据
DELETE FROM user_logs WHERE create_time < '2023-01-01';
-- 可能影响：锁定时间长、内存占用大、主从延迟

-- ✅ 正确做法：分批删除
DELIMITER //
CREATE PROCEDURE batch_delete_logs()
BEGIN
    DECLARE done INT DEFAULT 0;
    
    -- 每次删除1000条，避免长时间锁定
    REPEAT
        DELETE FROM user_logs 
        WHERE create_time < '2023-01-01' 
        LIMIT 1000;
        
        -- 检查是否还有数据要删除
        SELECT ROW_COUNT() INTO done;
        
        -- 短暂休息，释放压力
        SELECT SLEEP(0.1);
        
    UNTIL done = 0 END REPEAT;
END //
DELIMITER ;

CALL batch_delete_logs();
```

**📊 分批删除效果对比**

```
删除100万条记录的对比：

一次性删除：
┌─────────────────────────────────────────┐
│ ████████████████████████████████████    │ 280秒
└─────────────────────────────────────────┘
锁定时间：280秒连续锁定

分批删除（每批1000条）：
┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ... 1000次
└─┘ └─┘ └─┘ └─┘ └─┘
总时间：320秒，但每次锁定仅0.3秒

结论：总时间略长，但用户体验大幅提升
```

### 3.3 批量删除的高级优化


**🚀 批量删除优化技巧**

```sql
-- 技巧1：利用主键范围删除，避免全表扫描
-- ❌ 效率低：基于时间字段删除
DELETE FROM orders WHERE create_time < '2023-01-01' LIMIT 1000;

-- ✅ 效率高：基于主键范围删除
DELETE FROM orders WHERE id BETWEEN 1 AND 1000;
DELETE FROM orders WHERE id BETWEEN 1001 AND 2000;
-- 主键删除直接定位，不需要扫描

-- 技巧2：先查询再删除，减少不必要的锁定
-- 第一步：查询要删除的主键
SELECT id FROM orders WHERE create_time < '2023-01-01' LIMIT 1000;

-- 第二步：基于主键精确删除
DELETE FROM orders WHERE id IN (1,2,3...1000);
```

**⚡ 极速批量删除：分区表删除**

```sql
-- 如果数据按时间分区，删除整个分区最快
-- 相当于直接删除文件，不需要逐条处理

-- 查看分区情况
SHOW PARTITIONS FROM orders;

-- 删除整个分区（秒级完成）
ALTER TABLE orders DROP PARTITION p_2022_q1;

-- 对比：
-- 逐条删除100万记录：5-10分钟
-- 删除分区：5-10秒
```

---

## 4. 🔒 删除锁机制优化


### 4.1 删除操作的锁机制


**🔸 删除锁的工作原理**

把数据库的锁想象成图书馆的规则：
- **共享锁**：多人可以同时读同一本书
- **排他锁**：某人在写书时，其他人不能读也不能写

```
删除操作的锁获取过程：

步骤1：获取意向排他锁(IX锁)
┌────────────────┐
│   表级 IX锁    │ ← 告诉其他人"我要删除数据了"
└────────────────┘

步骤2：获取行级排他锁(X锁)  
┌────────────────┐
│  记录行 X锁    │ ← 锁定具体要删除的行
└────────────────┘

步骤3：执行删除操作
┌────────────────┐
│   删除数据     │ ← 真正的删除动作
└────────────────┘

步骤4：提交事务，释放所有锁
┌────────────────┐
│   释放锁       │ ← 其他操作可以继续
└────────────────┘
```

### 4.2 删除锁冲突场景


**🔥 常见锁冲突情况**

```
场景1：热点数据删除冲突
用户A：DELETE FROM products WHERE id = 100;  -- 获取X锁
用户B：SELECT * FROM products WHERE id = 100; -- 等待X锁释放
用户C：UPDATE products SET price = 99 WHERE id = 100; -- 等待X锁释放

结果：用户B和C都要等用户A的删除操作完成

场景2：大批量删除阻塞其他操作
管理员：DELETE FROM logs WHERE create_time < '2023-01-01'; -- 长时间X锁
普通用户：INSERT INTO logs VALUES (...); -- 等待锁释放
```

### 4.3 删除锁优化策略


**🔧 锁优化的核心方法**

```sql
-- 优化1：缩短锁持有时间
-- ❌ 长时间锁定
BEGIN;
DELETE FROM orders WHERE status = 'cancelled'; -- 可能删除很多行
-- ... 其他复杂操作
COMMIT;

-- ✅ 快速锁定
BEGIN;
DELETE FROM orders WHERE id = 1001; -- 精确删除单行
COMMIT;

-- 优化2：使用合适的隔离级别
-- 读未提交：锁持有时间最短，但可能读到脏数据
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 优化3：避开高峰期执行大批量删除
-- 在业务低峰期（如凌晨）执行大量删除操作
```

**📊 锁等待时间优化效果**

```
优化前后对比：

优化前（一次删除10万条）：
等待队列：[查询1] [查询2] [查询3] ... [查询n]
等待时间：平均45秒

优化后（分批删除，每批1000条）：  
等待队列：[查询1] [查询2] [查询3] ... 
等待时间：平均0.5秒

用户感受：从"卡死"变成"流畅"
```

---

## 5. 💾 删除IO性能调优


### 5.1 删除操作的IO特点


**🔸 删除IO模式分析**

```
删除操作涉及的IO类型：

随机读IO：
┌─────────────┐
│ 定位要删除  │ ← 根据WHERE条件查找记录
│ 的记录位置  │
└─────────────┘

随机写IO：
┌─────────────┐
│ 更新各个索引│ ← 修改主键索引、二级索引
└─────────────┘

顺序写IO：
┌─────────────┐
│ 写事务日志  │ ← 记录删除操作到日志文件
└─────────────┘

后台IO：
┌─────────────┐
│ 空间回收    │ ← 后台进程回收删除的空间
└─────────────┘
```

**为什么删除IO压力大？**
- **读放大**：删除一条记录可能要读取多个索引页
- **写放大**：删除一条记录可能要写多个索引页和日志
- **碎片化**：删除导致页面碎片，影响后续读取性能

### 5.2 InnoDB删除IO优化


**🔧 innodb_io_capacity删除优化**

```sql
-- innodb_io_capacity是什么？
-- 简单理解：告诉MySQL你的磁盘有多快，让它合理安排IO

-- 查看当前设置
SHOW VARIABLES LIKE 'innodb_io_capacity%';

-- 根据磁盘类型调整：
-- 机械硬盘：200
SET GLOBAL innodb_io_capacity = 200;

-- SATA SSD：2000  
SET GLOBAL innodb_io_capacity = 2000;

-- NVMe SSD：5000
SET GLOBAL innodb_io_capacity = 5000;

-- 为什么要调整？
-- 设置过低：删除时IO不充分利用，删除慢
-- 设置过高：IO压力过大，影响查询性能
```

**📊 IO优化效果对比**

```
删除100万条记录的IO性能测试：

机械硬盘 (io_capacity=200)：
IO利用率: ████████░░ 80%   删除时间: 15分钟

SSD硬盘 (io_capacity=2000)：
IO利用率: ██████████ 95%   删除时间: 3分钟

优化建议：
🔸 定期检查磁盘IO能力
🔸 根据硬件调整io_capacity参数
🔸 监控删除时的IO等待情况
```

### 5.3 删除操作IO模式优化


**⚡ 删除并行度优化**

```sql
-- 控制删除操作的并行度
-- innodb_purge_threads：控制后台清理线程数

-- 查看当前设置
SHOW VARIABLES LIKE 'innodb_purge_threads';

-- 根据CPU核心数调整（一般设置为CPU核心数的1/4到1/2）
-- 4核CPU：设置为2
SET GLOBAL innodb_purge_threads = 2;

-- 8核CPU：设置为4  
SET GLOBAL innodb_purge_threads = 4;

-- 16核CPU：设置为8
SET GLOBAL innodb_purge_threads = 8;
```

**🔄 删除操作IO优化实践**

```sql
-- 实践技巧1：合理安排删除时间
-- 在IO压力较小的时间段执行大批量删除

-- 实践技巧2：预热缓存
-- 大批量删除前，先预热相关索引页到内存
SELECT COUNT(*) FROM orders WHERE create_time < '2023-01-01';

-- 实践技巧3：监控IO等待
-- 删除过程中监控IO等待情况
SHOW PROCESSLIST;  -- 查看是否有大量"等待IO"的进程
```

---

## 6. 📊 删除监控与瓶颈分析


### 6.1 删除性能监控指标


**🎯 核心监控指标**

| 监控指标 | **正常范围** | **异常表现** | **问题定位** |
|---------|-------------|-------------|-------------|
| **删除TPS** | 稳定增长 | 突然下降 | 可能遇到瓶颈 |
| **锁等待时间** | <1秒 | >5秒 | 锁竞争激烈 |
| **IO等待率** | <30% | >70% | IO成为瓶颈 |
| **缓冲池命中率** | >95% | <90% | 内存不足 |

**🔍 监控SQL示例**

```sql
-- 监控删除操作性能
SELECT 
    SCHEMA_NAME as '数据库',
    SUM_TIMER_WAIT/1000000000 as '总耗时(秒)',
    COUNT_STAR as '执行次数',
    AVG_TIMER_WAIT/1000000000 as '平均耗时(秒)',
    SUM_ROWS_AFFECTED as '影响行数'
FROM performance_schema.events_statements_summary_by_digest 
WHERE DIGEST_TEXT LIKE '%DELETE%'
ORDER BY SUM_TIMER_WAIT DESC;

-- 监控锁等待情况
SELECT 
    r.trx_id as '等待事务ID',
    r.trx_mysql_thread_id as '线程ID', 
    TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW()) as '等待时间(秒)',
    r.trx_query as '等待的SQL'
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

### 6.2 删除瓶颈分析方法


**🔍 瓶颈诊断流程**

```
删除性能问题诊断：

步骤1：确定瓶颈类型
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  CPU瓶颈？  │ →  │  IO瓶颈？   │ →  │  锁瓶颈？   │
│ CPU使用率>90%│    │IO等待率>70% │    │锁等待时间长│
└─────────────┘    └─────────────┘    └─────────────┘

步骤2：分析具体原因
CPU瓶颈 → 索引过多？计算复杂？
IO瓶颈 → 磁盘慢？缓存不足？
锁瓶颈 → 并发冲突？长事务？

步骤3：制定优化策略
针对性优化，逐个击破
```

**🧪 瓶颈分析实例**

```sql
-- 案例：某电商系统删除过期订单缓慢

-- 1. 检查执行计划
EXPLAIN DELETE FROM orders WHERE create_time < '2023-01-01';

-- 结果分析：
-- type: ALL (全表扫描，性能差)
-- rows: 1000000 (要扫描100万行)
-- Extra: Using where (没用到索引)

-- 2. 检查索引使用
SHOW INDEX FROM orders;

-- 发现问题：create_time字段没有索引！

-- 3. 优化方案
CREATE INDEX idx_create_time ON orders(create_time);

-- 4. 验证优化效果
EXPLAIN DELETE FROM orders WHERE create_time < '2023-01-01';
-- type: range (范围扫描，性能好)
-- rows: 50000 (只需扫描5万行)

-- 性能提升：从10分钟优化到30秒
```

### 6.3 删除监控工具与指标


**📈 监控工具推荐**

```bash
# 1. MySQL内置监控
# 实时查看删除操作状态
mysql> SHOW PROCESSLIST;
mysql> SHOW ENGINE INNODB STATUS;

# 2. 系统级监控
# 监控IO使用情况
iostat -x 1

# 监控CPU使用情况  
top -p `pgrep mysqld`

# 3. 专业监控工具
# Percona Toolkit - 删除操作分析
pt-query-digest slow.log | grep DELETE

# MySQLTuner - 整体性能分析
perl mysqltuner.pl
```

**🎯 关键监控指标设置**

```sql
-- 启用性能监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%statement/%';

-- 监控慢删除操作
SET GLOBAL long_query_time = 2;  -- 超过2秒的删除记录到慢日志
SET GLOBAL log_queries_not_using_indexes = ON;  -- 记录没用索引的删除

-- 设置监控阈值
-- 删除TPS < 100：性能较差，需要优化
-- 锁等待时间 > 5秒：锁竞争严重
-- IO等待率 > 70%：IO成为瓶颈
```

---

## 7. 🛠️ 删除性能调优实战


### 7.1 实战案例：电商订单删除优化


**📋 问题场景**
```
业务需求：
- 每天删除30天前的过期订单
- 订单表：1000万条记录
- 每天新增：10万条订单
- 问题：删除操作耗时2小时，影响正常业务

表结构：
orders (
  id BIGINT PRIMARY KEY,
  user_id INT,
  create_time DATETIME,
  status VARCHAR(20),
  amount DECIMAL(10,2)
)

索引：
- PRIMARY KEY (id)
- KEY idx_user_id (user_id)  
- KEY idx_create_time (create_time)
- KEY idx_status (status)
```

**🔍 问题分析过程**

```sql
-- 步骤1：分析现有删除SQL
DELETE FROM orders WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 步骤2：查看执行计划
EXPLAIN DELETE FROM orders WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 结果分析：
-- type: range (使用了create_time索引，好)
-- rows: 300000 (要删除30万行，量大)
-- 问题：一次性删除太多，锁时间长

-- 步骤3：查看锁等待情况  
SELECT * FROM information_schema.innodb_lock_waits;
-- 发现：大量SELECT操作在等待删除完成
```

**⚡ 优化解决方案**

```sql
-- 解决方案：分批+定时删除

-- 1. 创建分批删除存储过程
DELIMITER //
CREATE PROCEDURE delete_expired_orders()
BEGIN
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE deleted_rows INT DEFAULT 0;
    DECLARE total_deleted INT DEFAULT 0;
    
    -- 分批删除，每批1000条
    REPEAT
        DELETE FROM orders 
        WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY)
        LIMIT batch_size;
        
        SET deleted_rows = ROW_COUNT();
        SET total_deleted = total_deleted + deleted_rows;
        
        -- 每批间隔0.1秒，释放压力
        SELECT SLEEP(0.1);
        
    UNTIL deleted_rows = 0 END REPEAT;
    
    -- 记录删除结果
    INSERT INTO delete_log VALUES (NOW(), total_deleted);
END //
DELIMITER ;

-- 2. 设置定时任务（每小时执行一次）
CREATE EVENT delete_expired_orders_event
ON SCHEDULE EVERY 1 HOUR
STARTS '2024-01-01 02:00:00'  -- 凌晨2点开始
DO CALL delete_expired_orders();
```

**📊 优化效果**

```
优化前：
删除时间: ████████████████████████ 2小时
影响业务: 🔴 严重影响
锁等待: 🔴 大量查询等待

优化后：
删除时间: ██████ 20分钟
影响业务: 🟢 基本无影响  
锁等待: 🟢 几乎无等待

关键改进：
- 单次锁定时间：从2小时 → 0.1秒
- 用户感受：从"系统卡死" → "正常使用"
- 删除效率：分散到全天，平缓处理
```

### 7.2 实战案例：日志表清理优化


**📋 场景描述**
```
系统：用户行为日志系统
数据量：每天产生500万条日志
保留期：只保留最近7天的日志
问题：删除旧日志时系统几乎不可用

日志表结构：
user_logs (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id INT,
  action VARCHAR(50),
  create_time DATETIME,
  ip_address VARCHAR(45)
)

索引情况：
- 主键索引：id
- 用户索引：user_id  
- 时间索引：create_time
```

**🚀 终极优化方案：分区表**

```sql
-- 解决思路：按天分区，删除变成"丢弃分区"

-- 1. 创建分区表结构
CREATE TABLE user_logs_new (
  id BIGINT AUTO_INCREMENT,
  user_id INT,
  action VARCHAR(50), 
  create_time DATETIME,
  ip_address VARCHAR(45),
  PRIMARY KEY (id, create_time),
  KEY idx_user_id (user_id)
) 
PARTITION BY RANGE (TO_DAYS(create_time)) (
  PARTITION p20240101 VALUES LESS THAN (TO_DAYS('2024-01-02')),
  PARTITION p20240102 VALUES LESS THAN (TO_DAYS('2024-01-03')),
  PARTITION p20240103 VALUES LESS THAN (TO_DAYS('2024-01-04')),
  -- ... 更多分区
  PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 2. 自动管理分区
DELIMITER //
CREATE PROCEDURE manage_log_partitions()
BEGIN
    -- 删除7天前的分区
    SET @sql = CONCAT('ALTER TABLE user_logs_new DROP PARTITION p', 
                     DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 7 DAY), '%Y%m%d'));
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    
    -- 创建明天的分区
    SET @sql = CONCAT('ALTER TABLE user_logs_new ADD PARTITION (',
                     'PARTITION p', DATE_FORMAT(DATE_ADD(NOW(), INTERVAL 1 DAY), '%Y%m%d'),
                     ' VALUES LESS THAN (TO_DAYS(''', DATE_ADD(NOW(), INTERVAL 2 DAY), ''')))');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
END //
DELIMITER ;

-- 3. 设置每日自动执行
CREATE EVENT manage_partitions_event  
ON SCHEDULE EVERY 1 DAY
STARTS '2024-01-01 01:00:00'
DO CALL manage_log_partitions();
```

**⚡ 性能提升效果**

```
优化前（逐条删除）：
删除500万条记录：
时间: ████████████████████████████████ 3小时
影响: 🔴 系统基本不可用

优化后（分区删除）：
删除整个分区：
时间: █ 5秒
影响: 🟢 用户无感知

性能提升：从3小时 → 5秒，提升2160倍！
```

### 7.3 实战案例：用户数据删除优化


**📋 复杂场景：关联数据删除**

```sql
-- 场景：用户注销时删除所有相关数据
-- 涉及表：users, orders, order_items, user_logs, user_preferences

-- ❌ 原始做法：逐表删除
DELETE FROM user_preferences WHERE user_id = 12345;
DELETE FROM user_logs WHERE user_id = 12345;  
DELETE FROM order_items WHERE order_id IN (SELECT id FROM orders WHERE user_id = 12345);
DELETE FROM orders WHERE user_id = 12345;
DELETE FROM users WHERE id = 12345;
-- 问题：5个独立事务，可能部分成功部分失败

-- ✅ 优化做法：事务+批量+顺序
BEGIN;

-- 按依赖关系倒序删除
DELETE FROM order_items WHERE order_id IN (
    SELECT id FROM orders WHERE user_id = 12345
);

DELETE FROM orders WHERE user_id = 12345;
DELETE FROM user_logs WHERE user_id = 12345;  
DELETE FROM user_preferences WHERE user_id = 12345;
DELETE FROM users WHERE id = 12345;

COMMIT;
```

**🔧 关联删除优化技巧**

```sql
-- 技巧1：使用临时表优化子查询
-- ❌ 性能差：子查询在DELETE中
DELETE FROM order_items WHERE order_id IN (
    SELECT id FROM orders WHERE user_id = 12345
);

-- ✅ 性能好：先查询到临时表
CREATE TEMPORARY TABLE temp_orders AS 
SELECT id FROM orders WHERE user_id = 12345;

DELETE FROM order_items WHERE order_id IN (
    SELECT id FROM temp_orders
);

DROP TEMPORARY TABLE temp_orders;

-- 技巧2：利用外键级联删除
-- 设置合适的外键约束，自动处理关联删除
ALTER TABLE orders ADD CONSTRAINT fk_user_id 
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE CASCADE;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 删除本质：不是简单擦除，而是索引维护+空间回收+日志记录
🔸 性能瓶颈：索引数量、锁竞争、IO压力是三大瓶颈
🔸 优化策略：分批执行、索引优化、锁时间控制、IO参数调优
🔸 监控重点：删除TPS、锁等待、IO等待、缓存命中率
```

### 8.2 删除优化的核心方法


**🎯 优化决策树**

```
删除性能慢？
├─ 删除量大？
│  ├─ 是 → 分批删除 / 分区删除
│  └─ 否 → 检查索引和锁
├─ 索引太多？
│  ├─ 是 → 删除不必要的索引
│  └─ 否 → 检查WHERE条件索引
├─ 锁等待长？
│  ├─ 是 → 缩短事务时间
│  └─ 否 → 检查IO性能
└─ IO等待高？
   ├─ 是 → 调整io_capacity参数
   └─ 否 → 检查其他瓶颈
```

**🔧 实用优化技巧**

| 问题类型 | **解决方案** | **适用场景** | **效果** |
|---------|-------------|-------------|---------|
| 🐌 **删除太慢** | 分批删除 | 大量数据删除 | 减少锁时间 |
| 🔒 **锁等待多** | 精确WHERE条件 | 高并发删除 | 减少锁冲突 |
| 💾 **IO压力大** | 调整io_capacity | SSD硬盘 | 充分利用IO |
| 📊 **索引多** | 删除无用索引 | 写多读少场景 | 减少维护开销 |

### 8.3 删除性能调优最佳实践


**📌 核心最佳实践**

> **🔥 删除优化金三角**
> 1. **减少影响范围**：精确WHERE条件，减少无关数据扫描
> 2. **缩短锁定时间**：分批操作，快进快出
> 3. **优化IO效率**：合理参数，充分利用硬件

**🎪 记忆口诀**
```
删除优化三字经：
批量分，索引精，锁时短
IO调，监控看，瓶颈找
分区快，外键联，事务包
```

**⚡ 快速诊断清单**
- [ ] 检查WHERE条件是否有合适索引
- [ ] 确认删除量是否需要分批处理  
- [ ] 监控删除过程的锁等待情况
- [ ] 观察IO使用率是否合理
- [ ] 评估是否可以使用分区删除
- [ ] 考虑在业务低峰期执行大批量删除

**🌟 进阶优化方向**
- **读写分离**：删除操作在主库，查询分流到从库
- **异步删除**：将删除任务放入队列，异步处理
- **归档策略**：冷数据归档而非直接删除，保留数据价值

**🎯 实际应用价值**
- **系统稳定性**：避免删除操作拖垮整个系统
- **用户体验**：减少因删除导致的响应延迟
- **运维效率**：自动化删除管理，减少人工干预
- **成本控制**：合理的删除策略减少存储成本

**核心记忆**：
删除看似简单实则复杂，索引锁IO是关键，分批监控巧优化，性能提升用户赞！