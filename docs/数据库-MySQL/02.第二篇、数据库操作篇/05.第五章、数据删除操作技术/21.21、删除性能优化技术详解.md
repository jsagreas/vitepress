---
title: 21、删除性能优化技术详解
---
## 📚 目录

1. [删除操作性能概述](#1-删除操作性能概述)
2. [删除索引优化技术](#2-删除索引优化技术)
3. [批量删除优化策略](#3-批量删除优化策略)
4. [删除锁优化机制](#4-删除锁优化机制)
5. [I/O性能优化配置](#5-io性能优化配置)
6. [删除操作监控分析](#6-删除操作监控分析)
7. [删除瓶颈识别与调优](#7-删除瓶颈识别与调优)
8. [删除性能最佳实践](#8-删除性能最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 删除操作性能概述


### 1.1 删除操作的性能挑战


**🔸 删除操作比插入更复杂**
```
插入操作：只需要写入数据和索引
删除操作：需要处理更多事项

删除操作涉及的工作：
┌─────────────────┐
│  查找要删除的行  │ ← 需要索引扫描
└─────────────────┘
         ↓
┌─────────────────┐
│  标记行为删除   │ ← InnoDB逻辑删除
└─────────────────┘
         ↓
┌─────────────────┐
│  更新所有索引   │ ← 二级索引维护
└─────────────────┘
         ↓
┌─────────────────┐
│  释放页面空间   │ ← 空间回收
└─────────────────┘
```

**💡 为什么删除操作慢**
- **索引维护开销**：每个索引都需要更新
- **锁竞争问题**：删除时需要获取行锁
- **I/O放大效应**：可能触发页面合并
- **事务日志开销**：需要记录undo和redo日志

### 1.2 删除性能影响因素


**🔸 主要性能因素**
```
1. 表结构因素
   ├── 索引数量：索引越多，删除越慢
   ├── 行大小：大行删除涉及更多I/O
   └── 表大小：大表删除定位更困难

2. 删除模式因素
   ├── 删除条件：WHERE条件复杂度
   ├── 删除范围：单行vs批量删除
   └── 删除频率：并发删除操作数量

3. 系统资源因素
   ├── I/O性能：磁盘读写能力
   ├── 内存大小：缓冲池命中率
   └── CPU性能：索引维护计算能力
```

### 1.3 删除性能基准测试


```sql
-- 创建测试表
CREATE TABLE delete_test (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_name (name),
    INDEX idx_email (email),
    INDEX idx_created (created_at)
);

-- 插入测试数据
INSERT INTO delete_test (id, name, email) 
SELECT 
    seq,
    CONCAT('user_', seq),
    CONCAT('user_', seq, '@example.com')
FROM seq_1_to_1000000;
```

**性能测试结果对比**
| **删除方式** | **1万行** | **10万行** | **100万行** |
|-------------|----------|-----------|-------------|
| **单行删除** | 0.1秒 | 1秒 | 10秒 |
| **小批量删除(100行)** | 0.05秒 | 0.5秒 | 5秒 |
| **大批量删除(10000行)** | 0.02秒 | 0.2秒 | 2秒 |

---

## 2. 🔍 删除索引优化技术


### 2.1 删除操作索引选择策略


**🔸 InnoDB删除操作的索引使用**
```sql
-- 场景1：使用主键删除（最快）
DELETE FROM users WHERE id = 12345;
-- 执行计划：直接通过主键定位，无二级索引查询

-- 场景2：使用唯一索引删除（较快）
DELETE FROM users WHERE email = 'user@example.com';
-- 执行计划：唯一索引定位 → 主键定位

-- 场景3：使用普通索引删除（中等）
DELETE FROM users WHERE name = 'John';
-- 执行计划：普通索引扫描 → 主键定位

-- 场景4：无索引条件删除（最慢）
DELETE FROM users WHERE description LIKE '%test%';
-- 执行计划：全表扫描，极慢
```

**💡 索引选择优化原则**
```
最优删除条件：
1. 主键条件 > 唯一索引 > 普通索引 > 无索引
2. 单列索引 > 复合索引（部分匹配）
3. 选择性高的索引 > 选择性低的索引
4. 避免函数和表达式条件
```

### 2.2 删除时二级索引维护机制


**🔸 二级索引维护过程**
```
删除一行数据时的索引维护：

主键索引：
users_pk: [1001] → [1002] → [1004] → ...
删除1003后，主键索引中移除对应项

二级索引name：
name_idx: [Alice,1001] → [Bob,1003] → [Charlie,1004]
删除1003后，需要移除[Bob,1003]项

二级索引email：  
email_idx: [a@x.com,1001] → [b@x.com,1003] → [c@x.com,1004]
删除1003后，需要移除[b@x.com,1003]项

总结：删除一行需要维护所有包含该行的索引
```

**🔧 减少索引维护开销的方法**
```sql
-- 方法1：删除前先删除不必要的索引
-- 查看表的索引情况
SHOW INDEX FROM users;

-- 删除不常用的索引
DROP INDEX idx_rarely_used ON users;

-- 方法2：延迟索引更新（适用于批量操作）
SET foreign_key_checks = 0;  -- 临时关闭外键检查
SET unique_checks = 0;       -- 临时关闭唯一性检查

-- 执行批量删除
DELETE FROM users WHERE created_at < '2023-01-01';

-- 恢复检查
SET foreign_key_checks = 1;
SET unique_checks = 1;
```

### 2.3 复合索引删除优化


**🔸 复合索引的删除性能**
```sql
-- 创建复合索引
CREATE INDEX idx_name_email ON users (name, email);

-- 高效删除：使用索引前缀
DELETE FROM users WHERE name = 'John';  -- 可以使用索引

-- 低效删除：无法使用索引
DELETE FROM users WHERE email = 'john@example.com';  -- 无法使用复合索引
```

**删除条件与索引匹配效果**
| **删除条件** | **索引匹配** | **性能** |
|-------------|-------------|---------|
| `WHERE name = 'John'` | ✅ 前缀匹配 | 高 |
| `WHERE name = 'John' AND email = 'john@x.com'` | ✅ 完全匹配 | 最高 |
| `WHERE email = 'john@x.com'` | ❌ 无法匹配 | 低 |
| `WHERE name LIKE 'J%'` | ⚠️ 范围匹配 | 中 |

---

## 3. 📦 批量删除优化策略


### 3.1 批量删除的挑战


**🔸 大批量删除的问题**
```sql
-- 危险操作：一次删除大量数据
DELETE FROM logs WHERE created_at < '2023-01-01';
-- 可能删除几百万行数据

潜在问题：
├── 长事务：占用大量锁资源
├── 日志膨胀：产生大量redo/undo日志  
├── 主从延迟：影响复制性能
├── 阻塞其他操作：长时间持有锁
└── 回滚风险：失败时回滚耗时极长
```

### 3.2 分批删除策略


**🔸 小批量分批删除**
```sql
-- 优化方案：分批次删除
DELIMITER $$
CREATE PROCEDURE batch_delete_logs()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE batch_size INT DEFAULT 1000;
    DECLARE affected_rows INT DEFAULT 0;
    
    -- 开始分批删除
    REPEAT
        -- 每次删除1000行
        DELETE FROM logs 
        WHERE created_at < '2023-01-01'
        LIMIT 1000;
        
        -- 获取影响行数
        SET affected_rows = ROW_COUNT();
        
        -- 短暂休息，释放锁和缓解压力
        DO SLEEP(0.01);  -- 10毫秒
        
    UNTIL affected_rows < batch_size END REPEAT;
END$$
DELIMITER ;

-- 执行分批删除
CALL batch_delete_logs();
```

**💡 分批删除的优势**
- **减少锁持有时间**：每批操作后释放锁
- **控制事务大小**：避免超大事务
- **减少主从延迟**：给复制留出时间
- **便于监控**：可以观察删除进度

### 3.3 批量删除并行度优化


**🔸 删除操作并行度配置**
```sql
-- 查看当前并行配置
SHOW VARIABLES LIKE 'innodb_thread_concurrency';
SHOW VARIABLES LIKE 'innodb_read_io_threads';
SHOW VARIABLES LIKE 'innodb_write_io_threads';

-- 临时调整并行度（适用于批量删除期间）
SET GLOBAL innodb_thread_concurrency = 0;  -- 0表示不限制
SET GLOBAL innodb_adaptive_max_sleep_delay = 50000;  -- 微秒
```

**🔧 多线程并行删除**
```sql
-- 方案：按ID范围并行删除
-- 线程1删除：
DELETE FROM logs WHERE id >= 1 AND id < 100000 AND created_at < '2023-01-01';

-- 线程2删除：  
DELETE FROM logs WHERE id >= 100000 AND id < 200000 AND created_at < '2023-01-01';

-- 线程3删除：
DELETE FROM logs WHERE id >= 200000 AND id < 300000 AND created_at < '2023-01-01';

-- 注意：确保ID范围不重叠，避免死锁
```

### 3.4 删除进度监控


```sql
-- 创建删除进度监控表
CREATE TABLE delete_progress (
    table_name VARCHAR(100),
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    total_rows INT,
    deleted_rows INT,
    progress_pct DECIMAL(5,2),
    status VARCHAR(20)
);

-- 删除进度跟踪存储过程
DELIMITER $$
CREATE PROCEDURE track_delete_progress(
    IN table_name VARCHAR(100),
    IN batch_size INT
)
BEGIN
    DECLARE total_rows INT DEFAULT 0;
    DECLARE deleted_rows INT DEFAULT 0;
    
    -- 记录开始
    SELECT COUNT(*) INTO total_rows FROM logs WHERE created_at < '2023-01-01';
    INSERT INTO delete_progress VALUES (table_name, NOW(), NULL, total_rows, 0, 0, 'RUNNING');
    
    -- 分批删除循环
    WHILE deleted_rows < total_rows DO
        DELETE FROM logs WHERE created_at < '2023-01-01' LIMIT batch_size;
        SET deleted_rows = deleted_rows + ROW_COUNT();
        
        -- 更新进度
        UPDATE delete_progress 
        SET deleted_rows = deleted_rows,
            progress_pct = (deleted_rows / total_rows) * 100
        WHERE table_name = table_name AND status = 'RUNNING';
        
        DO SLEEP(0.01);
    END WHILE;
    
    -- 记录完成
    UPDATE delete_progress 
    SET end_time = NOW(), status = 'COMPLETED' 
    WHERE table_name = table_name AND status = 'RUNNING';
END$$
DELIMITER ;
```

---

## 4. 🔒 删除锁优化机制


### 4.1 删除操作的锁机制


**🔸 InnoDB删除锁类型**
```
删除操作涉及的锁：

行级锁：
├── X锁（排他锁）：锁定被删除的行
├── Gap锁：防止幻读（可重复读级别）
└── Next-Key锁：行锁+Gap锁组合

表级锁：
├── 意向排他锁（IX）：表示对表中某些行加X锁
└── 元数据锁（MDL）：保护表结构

锁申请顺序：
表级MDL锁 → 表级IX锁 → 行级X锁
```

**🔧 锁等待监控**
```sql
-- 查看当前锁等待情况
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;

-- 查看锁等待超时设置
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';
```

### 4.2 减少锁争用策略


**🔸 事务隔离级别优化**
```sql
-- 降低隔离级别减少锁范围（谨慎使用）
-- 当前会话设置为READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- READ COMMITTED下的删除锁行为：
-- ✅ 只对删除的行加锁，不加Gap锁
-- ✅ 减少锁争用
-- ⚠️ 可能出现幻读

-- 示例：
START TRANSACTION;
DELETE FROM users WHERE age > 65;  -- 只锁匹配行，不锁间隙
COMMIT;
```

**🔸 快速事务处理**
```sql
-- 优化前：长事务
START TRANSACTION;
-- 复杂业务逻辑...
SELECT COUNT(*) FROM related_table;  -- 额外查询
DELETE FROM users WHERE condition;
-- 更多业务逻辑...
COMMIT;

-- 优化后：短事务
-- 先执行查询和业务逻辑
SELECT COUNT(*) FROM related_table;
-- 业务逻辑处理...

-- 快速删除事务
START TRANSACTION;
DELETE FROM users WHERE condition;
COMMIT;
```

### 4.3 死锁预防策略


**🔸 删除操作死锁场景**
```sql
-- 死锁场景：两个会话删除顺序不同
-- 会话1：
START TRANSACTION;
DELETE FROM users WHERE id = 100;  -- 锁定id=100
DELETE FROM users WHERE id = 200;  -- 等待id=200

-- 会话2（同时执行）：
START TRANSACTION;  
DELETE FROM users WHERE id = 200;  -- 锁定id=200
DELETE FROM users WHERE id = 100;  -- 等待id=100 → 死锁！
```

**🔧 死锁预防方法**
```sql
-- 方法1：统一删除顺序
-- 总是按主键升序删除
DELETE FROM users WHERE id IN (100, 200) ORDER BY id;

-- 方法2：使用LOCK IN SHARE MODE预先获取锁
START TRANSACTION;
SELECT id FROM users WHERE condition ORDER BY id FOR UPDATE;  -- 预先排序获取锁
DELETE FROM users WHERE condition;
COMMIT;

-- 方法3：设置死锁超时
SET SESSION innodb_lock_wait_timeout = 10;  -- 10秒超时
```

---

## 5. 💾 I/O性能优化配置


### 5.1 删除操作I/O模式分析


**🔸 删除操作的I/O特征**
```
删除操作I/O模式：

读I/O：
├── 索引页读取：定位要删除的行
├── 数据页读取：读取行数据
└── Undo页读取：事务回滚信息

写I/O：
├── 数据页写入：标记删除（逻辑删除）
├── 索引页写入：更新索引结构
├── Redo日志写入：事务持久性保证  
└── Undo日志写入：回滚信息记录

I/O放大现象：
删除1行 → 可能涉及10+页面的I/O操作
```

### 5.2 innodb_io_capacity删除优化


**🔸 I/O容量参数调优**
```sql
-- 查看当前I/O配置
SHOW VARIABLES LIKE 'innodb_io_capacity%';

-- 当前配置：
-- innodb_io_capacity = 200          （普通I/O容量）
-- innodb_io_capacity_max = 2000     （最大I/O容量）

-- SSD优化配置：
SET GLOBAL innodb_io_capacity = 2000;      -- 提高到2000
SET GLOBAL innodb_io_capacity_max = 20000; -- 提高到20000

-- 机械硬盘配置：
SET GLOBAL innodb_io_capacity = 100;       -- 保守设置
SET GLOBAL innodb_io_capacity_max = 1000;  -- 适中设置
```

**💡 I/O容量配置指导**
```
存储类型与建议配置：

SSD存储：
├── innodb_io_capacity: 2000-10000
├── innodb_io_capacity_max: 20000-100000
└── 特点：随机I/O性能优秀

NVMe SSD：
├── innodb_io_capacity: 10000-50000  
├── innodb_io_capacity_max: 100000+
└── 特点：极高的I/O性能

机械硬盘：
├── innodb_io_capacity: 100-200
├── innodb_io_capacity_max: 1000-2000
└── 特点：顺序I/O好，随机I/O差

如何测试最优值：
1. 使用fio工具测试磁盘IOPS
2. 逐步调整参数观察性能
3. 监控I/O利用率和响应时间
```

### 5.3 缓冲池优化


**🔸 InnoDB缓冲池配置**
```sql
-- 查看缓冲池配置
SHOW VARIABLES LIKE 'innodb_buffer_pool%';

-- 关键参数：
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';        -- 缓冲池大小
SHOW VARIABLES LIKE 'innodb_buffer_pool_instances';   -- 缓冲池实例数

-- 删除操作缓冲池优化
SET GLOBAL innodb_buffer_pool_size = 8G;              -- 设置为可用内存的70-80%
SET GLOBAL innodb_buffer_pool_instances = 8;          -- 多实例减少锁争用

-- 查看缓冲池命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read_requests';
SHOW STATUS LIKE 'Innodb_buffer_pool_reads';

-- 计算命中率：
-- 命中率 = (read_requests - reads) / read_requests * 100%
-- 目标：命中率 > 99%
```

### 5.4 日志系统优化


**🔸 Redo日志优化**
```sql
-- Redo日志配置
SHOW VARIABLES LIKE 'innodb_log_file_size';    -- 单个日志文件大小
SHOW VARIABLES LIKE 'innodb_log_files_in_group'; -- 日志文件数量  
SHOW VARIABLES LIKE 'innodb_log_buffer_size';  -- 日志缓冲区大小

-- 删除密集场景优化配置：
-- my.cnf配置：
[mysqld]
innodb_log_file_size = 1G              # 大日志文件减少切换
innodb_log_files_in_group = 3          # 3个日志文件
innodb_log_buffer_size = 64M           # 大缓冲区减少刷盘
innodb_flush_log_at_trx_commit = 2     # 每秒刷盘（性能优化）
```

**🔧 Double Write优化**
```sql
-- Double Write缓冲区配置
SHOW VARIABLES LIKE 'innodb_doublewrite%';

-- SSD环境可以考虑关闭Double Write（提升性能，但有风险）
SET GLOBAL innodb_doublewrite = OFF;

-- 注意：关闭后需要确保：
-- 1. SSD有断电保护
-- 2. 文件系统支持原子写
-- 3. 做好数据备份
```

---

## 6. 📊 删除操作监控分析


### 6.1 删除性能监控指标


**🔸 关键性能指标**
```sql
-- 1. 删除操作统计
SHOW STATUS LIKE 'Com_delete%';
-- Com_delete: 总删除次数
-- Com_delete_multi: 多表删除次数

-- 2. InnoDB删除统计  
SHOW STATUS LIKE 'Innodb_rows_deleted';
-- 显示通过InnoDB删除的行数

-- 3. 锁等待统计
SHOW STATUS LIKE 'Innodb_lock_wait%';
-- Innodb_lock_wait_time: 总等待时间
-- Innodb_lock_waits: 等待次数

-- 4. I/O统计
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';
SHOW STATUS LIKE 'Innodb_data_read%';
SHOW STATUS LIKE 'Innodb_data_write%';
```

### 6.2 删除性能监控查询


**🔸 实时监控SQL**
```sql
-- 监控当前正在执行的删除操作
SELECT 
    p.ID,
    p.USER,
    p.HOST,
    p.DB,
    p.COMMAND,
    p.TIME,
    p.STATE,
    p.INFO
FROM information_schema.PROCESSLIST p
WHERE p.INFO LIKE '%DELETE%' 
   OR p.INFO LIKE '%delete%'
ORDER BY p.TIME DESC;

-- 监控删除操作的锁等待
SELECT 
    l.lock_trx_id,
    l.lock_mode,
    l.lock_type,
    l.lock_table,
    l.lock_index,
    t.trx_query,
    t.trx_state,
    t.trx_started,
    t.trx_mysql_thread_id
FROM information_schema.innodb_locks l
JOIN information_schema.innodb_trx t ON l.lock_trx_id = t.trx_id
WHERE t.trx_query LIKE '%DELETE%';
```

### 6.3 性能基线建立


**🔸 删除性能基线测试**
```sql
-- 创建性能测试脚本
DELIMITER $$
CREATE PROCEDURE delete_performance_test()
BEGIN
    DECLARE start_time TIMESTAMP DEFAULT NOW();
    DECLARE end_time TIMESTAMP;
    DECLARE deleted_rows INT DEFAULT 0;
    
    -- 记录开始状态
    SELECT VARIABLE_VALUE INTO @start_reads 
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads';
    
    SELECT VARIABLE_VALUE INTO @start_read_requests
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests';
    
    -- 执行删除操作
    DELETE FROM test_table WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);
    SET deleted_rows = ROW_COUNT();
    SET end_time = NOW();
    
    -- 记录结束状态  
    SELECT VARIABLE_VALUE INTO @end_reads 
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads';
    
    SELECT VARIABLE_VALUE INTO @end_read_requests
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests';
    
    -- 输出性能报告
    SELECT 
        deleted_rows AS '删除行数',
        TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000 AS '耗时(ms)',
        deleted_rows / (TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000000) AS '删除速率(行/秒)',
        (@end_reads - @start_reads) AS '物理读次数',
        (@end_read_requests - @start_read_requests) AS '逻辑读次数',
        ((@end_read_requests - @start_read_requests - @end_reads + @start_reads) / 
         (@end_read_requests - @start_read_requests)) * 100 AS '缓冲池命中率(%)';
END$$
DELIMITER ;
```

---

## 7. 🔧 删除瓶颈识别与调优


### 7.1 删除瓶颈分析方法


**🔸 性能瓶颈识别步骤**
```
删除性能问题诊断流程：

第1步：确定症状
├── 删除操作很慢？
├── 删除时系统卡顿？  
├── 删除引起锁等待？
└── 删除后空间不释放？

第2步：收集信息
├── 查看删除SQL的执行计划
├── 监控系统资源使用率
├── 检查锁等待和死锁日志
└── 分析I/O和缓冲池状态

第3步：定位瓶颈
├── CPU瓶颈：高计算复杂度
├── I/O瓶颈：磁盘读写能力不足
├── 内存瓶颈：缓冲池命中率低
├── 锁瓶颈：锁争用严重
└── 索引瓶颈：索引设计不合理
```

### 7.2 常见删除瓶颈场景


**🔸 瓶颈场景1：索引过多**
```sql
-- 问题：表有太多索引，删除时需要维护所有索引
SHOW INDEX FROM user_logs;  -- 假设有8个索引

-- 分析影响：
-- 删除1行 → 需要更新8个索引 → I/O放大8倍

-- 解决方案：
-- 1. 删除不必要的索引
DROP INDEX idx_rarely_used ON user_logs;

-- 2. 合并相似索引  
DROP INDEX idx_name;
DROP INDEX idx_email;
CREATE INDEX idx_name_email ON user_logs(name, email);

-- 3. 临时删除索引（大批量删除时）
DROP INDEX idx_temp ON user_logs;
-- 执行大批量删除
DELETE FROM user_logs WHERE condition;
-- 重建索引
CREATE INDEX idx_temp ON user_logs(column);
```

**🔸 瓶颈场景2：删除条件低选择性**
```sql
-- 问题：删除条件匹配太多行
DELETE FROM orders WHERE status = 'completed';  -- 可能匹配50%的行

-- 分析执行计划：
EXPLAIN DELETE FROM orders WHERE status = 'completed';
-- type: ALL (全表扫描)
-- rows: 500万 (扫描行数)

-- 解决方案：
-- 1. 增加更具选择性的条件
DELETE FROM orders 
WHERE status = 'completed' 
  AND created_at < '2023-01-01';  -- 组合条件提高选择性

-- 2. 创建复合索引
CREATE INDEX idx_status_created ON orders(status, created_at);
```

**🔸 瓶颈场景3：大事务阻塞**
```sql
-- 问题：大批量删除在单个事务中
START TRANSACTION;
DELETE FROM logs WHERE created_at < '2023-01-01';  -- 删除100万行
COMMIT;

-- 问题分析：
-- ✗ 事务过大，占用大量锁
-- ✗ redo/undo日志膨胀  
-- ✗ 阻塞其他操作

-- 解决方案：分批删除
DELIMITER $$
CREATE PROCEDURE optimized_batch_delete()
BEGIN
    DECLARE batch_count INT DEFAULT 0;
    
    REPEAT
        DELETE FROM logs 
        WHERE created_at < '2023-01-01' 
        LIMIT 5000;  -- 小批量删除
        
        SET batch_count = batch_count + ROW_COUNT();
        
        -- 每删除5万行后休息一下
        IF batch_count % 50000 = 0 THEN
            DO SLEEP(1);  -- 休息1秒
        END IF;
        
    UNTIL ROW_COUNT() < 5000 END REPEAT;
END$$
DELIMITER ;
```

### 7.3 删除性能调优工具


**🔸 使用Performance Schema分析**
```sql
-- 启用Performance Schema相关监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'statement/sql/delete%';

UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'events_statements%';

-- 执行删除操作后分析
SELECT 
    event_name,
    count_star AS '执行次数',
    avg_timer_wait/1000000000 AS '平均耗时(秒)',
    sum_lock_time/1000000000 AS '总锁等待时间(秒)',
    sum_rows_affected AS '总影响行数',
    sum_rows_examined AS '总扫描行数'
FROM performance_schema.events_statements_summary_by_event_name
WHERE event_name LIKE '%delete%'
ORDER BY avg_timer_wait DESC;
```

---

## 8. ✨ 删除性能最佳实践


### 8.1 删除操作设计原则


**🔸 高效删除的设计原则**
```
1. 索引原则
   ├── 删除条件尽量使用主键或唯一索引
   ├── 避免在删除频繁的表上创建过多索引
   └── 定期分析和清理无用索引

2. 事务原则  
   ├── 删除事务尽量短小
   ├── 大批量删除分批进行
   └── 避免在删除事务中执行其他耗时操作

3. 并发原则
   ├── 控制并发删除的数量
   ├── 使用合适的事务隔离级别
   └── 避免长时间持有锁

4. 监控原则
   ├── 建立删除性能基线
   ├── 监控删除操作的关键指标
   └── 及时发现和处理性能问题
```

### 8.2 生产环境删除策略


**🔸 日志表删除策略**
```sql
-- 场景：定期清理应用日志表
-- 表结构：logs(id, user_id, action, created_at, ...)
-- 数据量：每天100万行新增，保留30天数据

-- 策略1：按时间分区（推荐）
CREATE TABLE logs (
    id BIGINT AUTO_INCREMENT,
    user_id INT,
    action VARCHAR(100),
    created_at TIMESTAMP,
    PRIMARY KEY (id, created_at),
    INDEX idx_user_created (user_id, created_at)
) PARTITION BY RANGE (TO_DAYS(created_at)) (
    PARTITION p202401 VALUES LESS THAN (TO_DAYS('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (TO_DAYS('2024-03-01')),
    -- 更多分区...
);

-- 删除整个分区（极快）
ALTER TABLE logs DROP PARTITION p202401;

-- 策略2：分批删除（无分区时）
CREATE EVENT delete_old_logs
ON SCHEDULE EVERY 1 HOUR
DO
  CALL batch_delete_logs_by_date(DATE_SUB(NOW(), INTERVAL 30 DAY), 5000);
```

**🔸 用户数据删除策略**
```sql
-- 场景：用户注销后删除相关数据
-- 涉及多表：users, user_profiles, user_orders, user_logs

-- 策略：软删除 + 异步硬删除
-- 1. 软删除（立即执行）
UPDATE users SET deleted_at = NOW() WHERE id = 12345;

-- 2. 异步硬删除（后台定期执行）
DELIMITER $$
CREATE PROCEDURE hard_delete_user_data()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE user_id INT;
    
    -- 获取30天前软删除的用户
    DECLARE user_cursor CURSOR FOR
        SELECT id FROM users 
        WHERE deleted_at IS NOT NULL 
          AND deleted_at < DATE_SUB(NOW(), INTERVAL 30 DAY)
        LIMIT 100;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN user_cursor;
    
    delete_loop: LOOP
        FETCH user_cursor INTO user_id;
        IF done THEN
            LEAVE delete_loop;
        END IF;
        
        -- 删除相关数据
        DELETE FROM user_logs WHERE user_id = user_id LIMIT 1000;
        DELETE FROM user_orders WHERE user_id = user_id LIMIT 1000;  
        DELETE FROM user_profiles WHERE user_id = user_id;
        DELETE FROM users WHERE id = user_id;
        
        -- 短暂休息
        DO SLEEP(0.01);
        
    END LOOP;
    
    CLOSE user_cursor;
END$$
DELIMITER ;

-- 设置定期执行
CREATE EVENT hard_delete_users
ON SCHEDULE EVERY 1 DAY
DO CALL hard_delete_user_data();
```

### 8.3 删除性能优化清单


**🔸 删除前检查清单**
```
准备阶段：
☐ 确认删除条件是否使用了合适的索引
☐ 评估删除数据量和预期耗时  
☐ 检查是否有其他依赖该数据的应用
☐ 确保有完整的数据备份

执行阶段：
☐ 在业务低峰期执行删除操作
☐ 监控删除进度和系统资源使用
☐ 准备回滚方案（如有必要）
☐ 关注主从复制延迟情况

完成阶段：
☐ 确认删除结果正确
☐ 检查表空间是否需要回收
☐ 更新统计信息（如有必要）
☐ 记录删除操作日志
```

---

## 9. 📋 核心要点总结


### 9.1 删除性能优化要点


**🔸 索引优化要点**
```
✅ 删除条件优先使用主键和唯一索引
✅ 减少不必要的二级索引
✅ 合理设计复合索引
✅ 定期清理无用索引
❌ 避免在WHERE条件中使用函数
❌ 避免低选择性的删除条件
```

**🔸 批量删除要点**  
```
✅ 大批量删除分批进行
✅ 控制每批删除的行数（建议1000-10000行）
✅ 批次间适当休息释放锁
✅ 监控删除进度和系统状态
❌ 避免单事务删除大量数据
❌ 避免高峰期执行大批量删除
```

### 9.2 性能参数配置总结


| **参数名称** | **推荐值** | **作用说明** |
|-------------|-----------|-------------|
| `innodb_io_capacity` | SSD:2000-10000<br>HDD:100-200 | 控制I/O容量 |
| `innodb_io_capacity_max` | SSD:20000+<br>HDD:1000-2000 | 最大I/O容量 |
| `innodb_buffer_pool_size` | 内存的70-80% | 缓冲池大小 |
| `innodb_lock_wait_timeout` | 10-50秒 | 锁等待超时 |
| `innodb_thread_concurrency` | 0（不限制）或CPU核数×2 | 并发线程数 |

### 9.3 监控指标总结


**🔸 关键监控指标**
```
性能指标：
├── 删除操作QPS：Com_delete/秒
├── 平均删除耗时：通过慢查询日志监控
├── 删除影响行数：Innodb_rows_deleted
└── 缓冲池命中率：>99%

资源指标：
├── I/O利用率：<80%
├── CPU使用率：<70%
├── 内存使用率：<85%
└── 磁盘空间使用率：<80%

锁指标：
├── 锁等待次数：Innodb_lock_waits
├── 锁等待时间：Innodb_lock_wait_time
├── 死锁次数：Innodb_deadlocks
└── 长事务数量：>5秒的事务数
```

### 9.4 故障排查指南


```
删除慢问题排查：
1. 检查执行计划 → EXPLAIN DELETE语句
2. 检查索引使用 → 是否全表扫描
3. 检查锁等待 → information_schema.innodb_lock_waits
4. 检查I/O状态 → iostat -x 1
5. 检查缓冲池 → SHOW ENGINE INNODB STATUS

删除阻塞问题排查：  
1. 查找阻塞源 → SHOW PROCESSLIST
2. 分析锁持有 → information_schema.innodb_trx
3. 检查事务大小 → trx_rows_modified
4. 评估回滚风险 → undo log size
5. 决定处理方式 → KILL或等待
```

---

> 💡 **核心记忆口诀**
> 
> **删除优化三要素：索引选择要精准，批量操作要分段，锁持有时间要短暂**
> 
> **性能调优四步法：监控发现瓶颈点，分析定位根本因，参数调优验证果，持续观察保稳定**