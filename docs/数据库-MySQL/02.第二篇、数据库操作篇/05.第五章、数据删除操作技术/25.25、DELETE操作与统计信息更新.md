---
title: 25、DELETE操作与统计信息更新
---
## 📚 目录

1. [DELETE操作对统计信息的影响](#1-DELETE操作对统计信息的影响)
2. [表统计信息自动更新机制](#2-表统计信息自动更新机制)
3. [索引统计信息维护](#3-索引统计信息维护)
4. [统计信息收集策略](#4-统计信息收集策略)
5. [ANALYZE TABLE使用指南](#5-ANALYZE-TABLE使用指南)
6. [统计信息对查询计划的影响](#6-统计信息对查询计划的影响)
7. [自动统计信息配置优化](#7-自动统计信息配置优化)
8. [统计信息监控与维护](#8-统计信息监控与维护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🗑️ DELETE操作对统计信息的影响


### 1.1 什么是统计信息


**简单理解**：统计信息就像是MySQL给每张表和索引做的"体检报告"，记录了表的大小、数据分布、索引效率等关键信息，帮助优化器制定最佳的查询执行计划。

```
统计信息包含的内容：

表级统计信息：
┌─────────────────┬─────────────────┬─────────────────┐
│ 统计项目         │ 作用             │ 举例说明         │
├─────────────────┼─────────────────┼─────────────────┤
│ 表总行数         │ 估算查询成本     │ users表：100万行 │
│ 平均行长度       │ 计算IO成本       │ 平均200字节/行   │
│ 数据文件大小     │ 存储空间规划     │ 200MB数据文件    │
│ 最后更新时间     │ 统计信息新鲜度   │ 2小时前更新      │
└─────────────────┴─────────────────┴─────────────────┘

索引级统计信息：
┌─────────────────┬─────────────────┬─────────────────┐
│ 统计项目         │ 作用             │ 举例说明         │
├─────────────────┼─────────────────┼─────────────────┤
│ 索引基数         │ 选择索引的依据   │ age列：80个不同值│
│ 索引页数         │ 计算索引扫描成本 │ 500个索引页      │
│ 值分布直方图     │ 估算选择性       │ 20-30岁占60%     │
│ 索引深度         │ 计算查找层次     │ B+树深度为3      │
└─────────────────┴─────────────────┴─────────────────┘
```

### 1.2 DELETE操作如何影响统计信息


**🔸 直接影响**：
```
DELETE语句执行后的统计变化：

原始状态：
表 users：1,000,000 行
索引 idx_age：基数 80 (年龄范围20-99)
索引 idx_city：基数 500 (500个城市)

执行：DELETE FROM users WHERE age BETWEEN 60 AND 80;
删除了 200,000 行数据

影响分析：
┌─────────────────┬─────────────┬─────────────┬─────────────┐
│ 统计项目         │ 删除前       │ 删除后       │ 变化程度     │
├─────────────────┼─────────────┼─────────────┼─────────────┤
│ 表总行数         │ 1,000,000   │ 800,000     │ -20%        │
│ age索引基数      │ 80          │ 59          │ -26%        │
│ city索引基数     │ 500         │ 500         │ 无变化       │
│ 年龄分布         │ 均匀分布     │ 中老年缺失   │ 严重倾斜     │
└─────────────────┴─────────────┴─────────────┴─────────────┘

查询计划影响：
• 全表扫描成本降低（行数减少）
• age相关查询可能选择不同索引
• 年龄范围查询的估算可能不准确
```

**🔸 间接影响**：
```
连锁反应分析：

统计信息过期
    │
    ▼
优化器使用旧统计信息
    │
    ▼
生成非最优执行计划
    │
    ▼
查询性能下降
    │
    ▼
系统整体性能受影响

具体示例：
1. DELETE删除了大量数据，但统计信息未更新
2. 优化器仍认为表很大，选择索引扫描
3. 实际上全表扫描可能更快（数据少了）
4. 查询执行时间变长，用户体验下降
```

### 1.3 DELETE操作类型对统计信息的不同影响


**🔸 按删除规模分类**：
```
小规模DELETE（< 5%数据）：
• 统计信息影响：微小
• 更新策略：可延迟更新
• 性能影响：基本无感知

中等规模DELETE（5%-20%数据）：
• 统计信息影响：中等
• 更新策略：建议及时更新
• 性能影响：可能出现计划偏差

大规模DELETE（> 20%数据）：
• 统计信息影响：显著
• 更新策略：必须立即更新
• 性能影响：严重影响查询性能
```

**🔸 按删除模式分类**：
```
随机删除：
DELETE FROM users WHERE id IN (随机ID列表);
• 对所有索引均有影响
• 数据分布保持相对均匀
• 统计信息线性下降

集中删除：
DELETE FROM users WHERE create_date < '2020-01-01';
• 主要影响时间相关索引
• 数据分布出现明显偏斜
• 部分统计信息急剧变化

条件删除：
DELETE FROM users WHERE status = 'inactive';
• 主要影响status相关索引
• 其他索引基数基本不变
• 需要重点更新相关索引统计
```

---

## 2. 🔄 表统计信息自动更新机制


### 2.1 自动更新触发条件


**MySQL统计信息自动更新规则**：
```
InnoDB存储引擎的自动更新条件：

表变化阈值：
• 表总行数 < 2000：任何变化都触发更新
• 表总行数 ≥ 2000：变化行数 > 总行数 * 10% + 2000

计算示例：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 表行数       │ 更新阈值     │ DELETE行数   │ 是否触发更新 │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 1,000       │ 任何变化     │ 10          │ ✅ 是        │
│ 10,000      │ 3,000       │ 2,000       │ ❌ 否        │
│ 10,000      │ 3,000       │ 3,500       │ ✅ 是        │
│ 100,000     │ 12,000      │ 15,000      │ ✅ 是        │
│ 1,000,000   │ 102,000     │ 50,000      │ ❌ 否        │
└─────────────┴─────────────┴─────────────┴─────────────┘

关键配置参数：
innodb_stats_auto_recalc = ON    # 启用自动更新
innodb_stats_threshold = 10      # 变化阈值百分比
```

### 2.2 自动更新执行时机


**🔸 更新时机策略**：
```cpp
class StatisticsUpdateScheduler {
private:
    struct UpdateTrigger {
        TableID table_id;
        size_t changed_rows;
        time_t last_update;
        bool force_update;
    };
    
    queue<UpdateTrigger> pending_updates;
    thread worker_thread;
    
public:
    // DELETE操作后检查是否需要更新统计
    void checkAfterDelete(TableID table_id, size_t deleted_rows) {
        TableInfo info = getTableInfo(table_id);
        
        // 计算变化比例
        double change_ratio = (double)deleted_rows / info.total_rows;
        
        // 判断是否达到更新阈值
        bool should_update = false;
        
        if (info.total_rows < 2000) {
            should_update = (deleted_rows > 0);
        } else {
            size_t threshold = info.total_rows * 0.1 + 2000;
            should_update = (deleted_rows >= threshold);
        }
        
        if (should_update) {
            scheduleStatisticsUpdate(table_id, false);
        }
    }
    
    // 调度统计信息更新
    void scheduleStatisticsUpdate(TableID table_id, bool immediate) {
        UpdateTrigger trigger = {
            table_id,
            0,
            time(nullptr),
            immediate
        };
        
        if (immediate) {
            // 立即更新
            updateTableStatistics(table_id);
        } else {
            // 加入队列，后台处理
            pending_updates.push(trigger);
        }
    }
};
```

### 2.3 统计信息更新过程


**🔸 更新执行流程**：
```
统计信息更新的完整过程：

DELETE操作完成
    │
    ▼
┌─────────────────────────────────┐
│ 1. 检查变化阈值                  │
│    计算删除行数占总行数的比例     │
└─────────────┬───────────────────┘
              │ 达到阈值
              ▼
┌─────────────────────────────────┐
│ 2. 启动后台统计更新任务          │
│    避免阻塞用户操作              │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 3. 采样数据页                   │
│    • 随机采样或全扫描            │
│    • 计算新的行数和基数          │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 4. 更新系统表                   │
│    • mysql.innodb_table_stats   │
│    • mysql.innodb_index_stats   │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 5. 刷新优化器缓存               │
│    使新统计信息生效              │
└─────────────────────────────────┘
```

**🔸 采样策略详解**：
```sql
-- 查看当前采样配置
SHOW VARIABLES LIKE 'innodb_stats_sample_pages';

-- 采样策略对比
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 采样页数     │ 精确度       │ 更新耗时     │ 适用场景     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 8 (默认)    │ 较低         │ 很快         │ 大表快速更新 │
│ 20          │ 中等         │ 快           │ 平衡选择     │
│ 50          │ 较高         │ 中等         │ 重要表更新   │
│ 100+        │ 很高         │ 慢           │ 关键业务表   │
└─────────────┴─────────────┴─────────────┴─────────────┘

-- 配置示例
SET GLOBAL innodb_stats_sample_pages = 20;

-- 针对特定表设置
ALTER TABLE important_users 
STATS_SAMPLE_PAGES = 50;
```

---

## 3. 📊 索引统计信息维护


### 3.1 DELETE后索引统计变化


**索引统计信息的核心指标**：
```
索引基数（Cardinality）：索引列中不同值的数量
选择性（Selectivity）：基数/总行数，值越高选择性越好
分布直方图：值在索引中的分布情况
```

**🔸 DELETE对不同索引的影响示例**：
```sql
-- 假设有一个用户表
CREATE TABLE users (
    id INT PRIMARY KEY,
    age INT,
    city VARCHAR(50),
    status ENUM('active', 'inactive', 'banned'),
    create_date DATE,
    
    INDEX idx_age (age),
    INDEX idx_city (city), 
    INDEX idx_status (status),
    INDEX idx_date (create_date)
);

-- 原始数据分布
SELECT 
    COUNT(*) as total_rows,                    -- 1,000,000
    COUNT(DISTINCT age) as age_cardinality,    -- 80 (20-99岁)
    COUNT(DISTINCT city) as city_cardinality,  -- 500 (500个城市)
    COUNT(DISTINCT status) as status_cardinality, -- 3 (三种状态)
    COUNT(DISTINCT create_date) as date_cardinality -- 1000 (近3年)
FROM users;
```

**🔸 不同DELETE模式的索引影响**：
```
模式1：按年龄删除
DELETE FROM users WHERE age > 65;  -- 删除老年用户

索引影响分析：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 索引名称     │ 删除前基数   │ 删除后基数   │ 影响程度     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ idx_age     │ 80          │ 65          │ 🔴 高影响    │
│ idx_city    │ 500         │ 500         │ 🟡 中等影响  │
│ idx_status  │ 3           │ 3           │ 🟢 低影响    │
│ idx_date    │ 1000        │ 1000        │ 🟢 低影响    │
└─────────────┴─────────────┴─────────────┴─────────────┘

模式2：按状态删除  
DELETE FROM users WHERE status = 'inactive';  -- 删除非活跃用户

索引影响分析：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 索引名称     │ 删除前基数   │ 删除后基数   │ 影响程度     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ idx_age     │ 80          │ 80          │ 🟢 低影响    │
│ idx_city    │ 500         │ 500         │ 🟢 低影响    │
│ idx_status  │ 3           │ 2           │ 🔴 高影响    │
│ idx_date    │ 1000        │ 1000        │ 🟢 低影响    │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

### 3.2 索引统计信息更新策略


**🔸 渐进式更新机制**：
```cpp
class IndexStatisticsManager {
private:
    struct IndexStats {
        size_t cardinality;          // 基数
        vector<double> histogram;    // 直方图
        time_t last_update;          // 最后更新时间
        double accuracy;             // 准确度评估
    };
    
    map<IndexID, IndexStats> index_statistics;
    
public:
    // DELETE后更新索引统计
    void updateAfterDelete(IndexID index_id, 
                          const vector<Value>& deleted_values) {
        IndexStats& stats = index_statistics[index_id];
        
        // 方法1：增量更新（快速但可能不准确）
        if (shouldUseIncrementalUpdate(deleted_values.size())) {
            updateIncremental(stats, deleted_values);
        } 
        // 方法2：重新采样（慢但准确）
        else {
            updateBySampling(index_id, stats);
        }
        
        stats.last_update = time(nullptr);
        
        // 评估统计信息的准确度
        stats.accuracy = estimateAccuracy(stats);
        
        // 如果准确度太低，标记需要全面更新
        if (stats.accuracy < 0.8) {
            scheduleFullUpdate(index_id);
        }
    }
    
private:
    // 增量更新算法
    void updateIncremental(IndexStats& stats, 
                          const vector<Value>& deleted_values) {
        // 统计删除值的分布
        map<Value, int> deleted_distribution;
        for (const Value& val : deleted_values) {
            deleted_distribution[val]++;
        }
        
        // 更新直方图
        for (auto& [value, count] : deleted_distribution) {
            int bucket = findHistogramBucket(value);
            stats.histogram[bucket] -= count;
            
            // 如果某个值完全被删除，基数减1
            if (stats.histogram[bucket] == 0) {
                stats.cardinality--;
            }
        }
    }
};
```

---

## 4. 📈 统计信息收集策略


### 4.1 收集策略类型


**🔸 主动收集 vs 被动收集**：
```
主动收集（Proactive）：
• 触发条件：定时任务、系统空闲期
• 优点：统计信息始终保持新鲜
• 缺点：消耗额外系统资源
• 适用：重要的生产表

被动收集（Reactive）：  
• 触发条件：数据变化达到阈值
• 优点：按需更新，节省资源
• 缺点：可能出现统计信息滞后
• 适用：一般业务表

混合策略（Hybrid）：
• 重要表：主动+被动双重保障
• 一般表：主要依赖被动收集
• 临时表：禁用自动收集
```

### 4.2 收集策略配置


**🔸 全局统计配置**：
```sql
-- 查看当前统计信息配置
SHOW VARIABLES LIKE 'innodb_stats%';

-- 关键配置参数说明
┌──────────────────────────────┬─────────────┬─────────────────────┐
│ 参数名称                      │ 默认值       │ 作用说明             │
├──────────────────────────────┼─────────────┼─────────────────────┤
│ innodb_stats_auto_recalc     │ ON          │ 启用自动更新         │
│ innodb_stats_persistent      │ ON          │ 统计信息持久化存储   │
│ innodb_stats_sample_pages    │ 8           │ 采样页数             │
│ innodb_stats_transient_sample_pages │ 8   │ 非持久化表采样页数   │
│ innodb_stats_include_delete_marked │ OFF │ 是否包含删除标记的行 │
└──────────────────────────────┴─────────────┴─────────────────────┘

-- 实际配置示例
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_sample_pages = 20;  -- 提高精确度
SET GLOBAL innodb_stats_persistent = ON;    -- 重启后保留统计信息
```

**🔸 表级统计配置**：
```sql
-- 为特定表自定义统计策略
ALTER TABLE users 
    STATS_AUTO_RECALC = 1,           -- 启用自动更新
    STATS_PERSISTENT = 1,            -- 持久化统计
    STATS_SAMPLE_PAGES = 50;         -- 使用更多采样页

-- 禁用某个表的自动统计更新（适用于临时表）
ALTER TABLE temp_data 
    STATS_AUTO_RECALC = 0;

-- 查看表的统计配置
SELECT 
    table_name,
    stats_auto_recalc,
    stats_persistent, 
    stats_sample_pages
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

### 4.3 智能收集策略


**🔸 基于工作负载的自适应策略**：
```cpp
class AdaptiveStatisticsCollector {
private:
    struct TableWorkload {
        double read_frequency;       // 读取频率
        double write_frequency;      // 写入频率
        double query_complexity;     // 查询复杂度
        time_t peak_hours[24];       // 高峰时段
    };
    
    map<TableID, TableWorkload> workloads;
    
public:
    // 根据工作负载调整收集策略
    CollectionStrategy determineStrategy(TableID table_id) {
        TableWorkload& workload = workloads[table_id];
        
        CollectionStrategy strategy;
        
        // 高频读取的表需要更精确的统计
        if (workload.read_frequency > 1000) {  // 每秒1000次以上查询
            strategy.sample_pages = 100;      // 增加采样页数
            strategy.update_threshold = 0.05; // 降低更新阈值到5%
            strategy.priority = HIGH;
        } 
        // 低频访问的表可以使用较粗糙的统计
        else if (workload.read_frequency < 10) {
            strategy.sample_pages = 8;         // 使用默认采样
            strategy.update_threshold = 0.2;   // 提高更新阈值到20%
            strategy.priority = LOW;
        } 
        // 普通表使用标准策略
        else {
            strategy.sample_pages = 20;
            strategy.update_threshold = 0.1;
            strategy.priority = NORMAL;
        }
        
        // 避免在高峰期更新统计信息
        if (isInPeakHours(workload.peak_hours)) {
            strategy.defer_update = true;
        }
        
        return strategy;
    }
};
```

**🔸 分层收集策略**：
```
根据表的重要性采用不同策略：

核心业务表（如订单表、用户表）：
• 采样页数：50-100页
• 更新阈值：5%
• 更新频率：变化后立即更新
• 监控级别：实时监控

重要业务表（如商品表、库存表）：
• 采样页数：20-50页  
• 更新阈值：10%
• 更新频率：变化后延迟更新
• 监控级别：每小时检查

一般业务表（如日志表、临时表）：
• 采样页数：8-20页
• 更新阈值：20%
• 更新频率：定期批量更新
• 监控级别：每日检查

配置示例：
-- 核心表配置
ALTER TABLE orders 
    STATS_SAMPLE_PAGES = 100,
    STATS_AUTO_RECALC = 1;

-- 一般表配置  
ALTER TABLE logs
    STATS_SAMPLE_PAGES = 8,
    STATS_AUTO_RECALC = 0;  -- 手动控制更新
```

---

## 5. 🔍 ANALYZE TABLE使用指南


### 5.1 ANALYZE TABLE基本用法


**什么时候需要手动执行ANALYZE TABLE**：
```
必须执行的场景：
• 大批量DELETE后（删除>20%数据）
• 数据导入完成后
• 发现查询计划明显不合理时
• 自动统计更新被禁用的表

建议执行的场景：
• 业务高峰期前的准备
• 数据库维护窗口期间
• 发现统计信息明显过期时
```

**🔸 基本语法和选项**：
```sql
-- 基本用法
ANALYZE TABLE users;

-- 分析多个表
ANALYZE TABLE users, orders, products;

-- 只更新索引统计（MySQL 8.0+）
ANALYZE TABLE users UPDATE HISTOGRAM ON age, city;

-- 删除直方图
ANALYZE TABLE users DROP HISTOGRAM ON age;

-- 查看分析结果
ANALYZE TABLE users;
+---------------+---------+----------+----------+
| Table         | Op      | Msg_type | Msg_text |
+---------------+---------+----------+----------+
| test.users    | analyze | status   | OK       |
+---------------+---------+----------+----------+
```

### 5.2 ANALYZE TABLE执行过程


**🔸 内部执行流程**：
```
ANALYZE TABLE执行的详细步骤：

用户执行 ANALYZE TABLE users;
    │
    ▼
┌─────────────────────────────────┐
│ 1. 获取表的排他锁                │
│    防止并发修改影响统计准确性     │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 2. 扫描表和索引页面              │
│    • 按配置的采样页数扫描        │
│    • 收集行数、键值分布等信息    │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 3. 计算统计指标                 │
│    • 计算基数和选择性           │
│    • 生成值分布直方图           │
│    • 估算空间使用情况           │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 4. 更新系统统计表               │
│    • information_schema.statistics │
│    • mysql.innodb_table_stats    │
│    • mysql.innodb_index_stats    │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 5. 释放锁并通知优化器            │
│    新统计信息立即生效            │
└─────────────────────────────────┘
```

### 5.3 ANALYZE TABLE使用时机


**🔸 最佳执行时机**：
```
业务场景驱动的执行时机：

数据维护后：
• 场景：每月清理过期数据
• 操作：DELETE FROM logs WHERE date < DATE_SUB(NOW(), INTERVAL 3 MONTH);
• 时机：清理完成后立即执行 ANALYZE TABLE logs;

批量数据迁移后：
• 场景：历史数据归档
• 操作：DELETE FROM orders WHERE year < 2020;
• 时机：迁移完成后执行 ANALYZE TABLE orders;

业务高峰前：
• 场景：双11、618等大促前
• 操作：ANALYZE TABLE products, orders, users;
• 时机：活动开始前2-4小时执行

定期维护：
• 场景：每周数据库维护
• 操作：批量分析所有重要表
• 时机：业务低峰期（如凌晨2-5点）
```

**🔸 执行时机的自动化管理**：
```sql
-- 创建定期统计更新的存储过程
DELIMITER //
CREATE PROCEDURE UpdateTableStatistics()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE table_name VARCHAR(100);
    DECLARE change_rate DECIMAL(5,2);
    
    -- 查找需要更新统计信息的表
    DECLARE table_cursor CURSOR FOR
        SELECT t.table_name,
               (t.auto_increment - s.last_analyzed_rows) / s.last_analyzed_rows * 100
        FROM information_schema.tables t
        JOIN mysql.innodb_table_stats s ON t.table_name = s.table_name
        WHERE t.table_schema = DATABASE()
          AND t.engine = 'InnoDB'
          AND (t.auto_increment - s.last_analyzed_rows) / s.last_analyzed_rows > 0.1;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    update_loop: LOOP
        FETCH table_cursor INTO table_name, change_rate;
        IF done THEN
            LEAVE update_loop;
        END IF;
        
        -- 根据变化率决定采样页数
        IF change_rate > 0.5 THEN
            SET @sql = CONCAT('ALTER TABLE ', table_name, ' STATS_SAMPLE_PAGES = 100');
            PREPARE stmt FROM @sql;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;
        END IF;
        
        -- 执行统计更新
        SET @sql = CONCAT('ANALYZE TABLE ', table_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE table_cursor;
END //
DELIMITER ;

-- 设置定期执行
-- 每天凌晨3点执行统计更新
CREATE EVENT update_statistics_daily
ON SCHEDULE EVERY 1 DAY STARTS '2025-09-02 03:00:00'
DO CALL UpdateTableStatistics();
```

### 5.4 ANALYZE TABLE性能考虑


**🔸 执行成本分析**：
```
ANALYZE TABLE的资源消耗：

CPU消耗：
• 页面扫描：中等CPU使用
• 统计计算：较高CPU使用（特别是直方图生成）
• 系统表更新：低CPU使用

内存消耗：
• 采样缓冲区：采样页数 × 16KB
• 计算缓冲区：统计信息临时存储
• 通常总内存消耗 < 100MB

IO消耗：  
• 随机页面读取：采样时的磁盘读取
• 系统表写入：更新统计信息的磁盘写入
• IO模式：主要是随机读，写入量很少

时间消耗估算：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ 表大小       │ 采样页数     │ 预估耗时     │ 影响评估     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ < 1GB       │ 20          │ < 10秒      │ 影响很小     │
│ 1-10GB      │ 50          │ 30秒-2分钟  │ 轻微影响     │
│ 10-100GB    │ 100         │ 2-10分钟    │ 中等影响     │
│ > 100GB     │ 200         │ 10分钟以上   │ 显著影响     │
└─────────────┴─────────────┴─────────────┴─────────────┘

优化建议：
• 在业务低峰期执行
• 大表可以分批处理
• 监控执行过程，避免影响业务
```

---

## 6. 🎯 统计信息对查询计划的影响


### 6.1 查询优化器如何使用统计信息


**优化器决策过程**：就像医生根据检查报告制定治疗方案一样，MySQL优化器根据统计信息来选择最佳的查询执行计划。

```
查询优化器的统计信息使用流程：

收到SQL查询
    │
    ▼
┌─────────────────────────────────┐
│ 1. 读取相关表的统计信息          │
│    • 表行数、平均行长度          │
│    • 索引基数、选择性           │
│    • 数据分布直方图             │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 2. 评估不同执行路径的成本        │
│    • 全表扫描 vs 索引扫描       │
│    • 不同索引的选择             │
│    • 表连接顺序                │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 3. 选择成本最低的执行计划        │
│    基于统计信息计算的成本模型    │
└─────────────┬───────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│ 4. 生成最终执行计划              │
│    确定访问方法和执行顺序        │
└─────────────────────────────────┘
```

### 6.2 统计信息过期的查询计划影响


**🔸 实际案例分析**：
```sql
-- 场景：用户表删除了大量数据
-- 原始表：1,000,000 行用户数据
-- DELETE操作：删除了 800,000 行历史用户  
-- 当前表：200,000 行活跃用户

-- 统计信息未更新时的查询计划
EXPLAIN SELECT * FROM users WHERE age BETWEEN 25 AND 35;

+----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows   | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+
|  1 | SIMPLE      | users | range | idx_age       | idx_age | 5       | NULL | 250000 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+--------+-------------+

-- 问题分析：
-- 优化器估算需要扫描25万行（基于旧统计信息）
-- 实际只需要扫描5万行（基于新的数据量）
-- 可能选择了不合适的执行计划

-- 更新统计信息后的查询计划
ANALYZE TABLE users;
EXPLAIN SELECT * FROM users WHERE age BETWEEN 25 AND 35;

+----+-------------+-------+-------+---------------+---------+---------+------+-------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows  | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+-------+-------------+
|  1 | SIMPLE      | users | range | idx_age       | idx_age | 5       | NULL | 50000 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+-------+-------------+

-- 改善效果：
-- 行数估算更准确：50,000 行
-- 可能选择更优的执行计划
-- 查询性能显著提升
```

### 6.3 查询计划偏差的检测


**🔸 执行计划偏差识别**：
```sql
-- 创建查询计划监控视图
CREATE VIEW query_plan_analysis AS
SELECT 
    digest_text,
    count_star as execution_count,
    avg_timer_wait/1000000000 as avg_duration_sec,
    avg_rows_examined,
    avg_rows_sent,
    avg_rows_examined/avg_rows_sent as scan_ratio,  -- 扫描效率
    first_seen,
    last_seen
FROM performance_schema.events_statements_summary_by_digest
WHERE digest_text IS NOT NULL
ORDER BY avg_timer_wait DESC;

-- 识别可能的统计信息问题
SELECT 
    digest_text,
    avg_duration_sec,
    scan_ratio,
    CASE 
        WHEN scan_ratio > 100 THEN '统计信息可能过期'
        WHEN scan_ratio > 10 THEN '需要检查索引'
        ELSE '正常'
    END as diagnosis
FROM query_plan_analysis
WHERE execution_count > 100  -- 只关注高频查询
  AND scan_ratio > 5;        -- 扫描效率低的查询
```

**🔸 查询计划变化监控**：
```cpp
class QueryPlanMonitor {
private:
    struct QuerySignature {
        string sql_template;     // SQL模板
        string plan_hash;        // 执行计划hash
        double avg_cost;         // 平均成本
        time_t last_seen;        // 最后执行时间
    };
    
    map<string, QuerySignature> baseline_plans;
    
public:
    // 检测查询计划是否发生显著变化
    bool detectPlanRegression(const string& sql, 
                             const ExecutionPlan& current_plan) {
        string sql_template = normalizeSql(sql);
        string current_hash = hashExecutionPlan(current_plan);
        
        if (baseline_plans.find(sql_template) == baseline_plans.end()) {
            // 新查询，建立基准
            establishBaseline(sql_template, current_plan);
            return false;
        }
        
        QuerySignature& baseline = baseline_plans[sql_template];
        
        // 检查计划是否发生变化
        if (baseline.plan_hash != current_hash) {
            double cost_change = (current_plan.estimated_cost - baseline.avg_cost) 
                                / baseline.avg_cost;
            
            // 成本增加超过50%，可能是统计信息问题
            if (cost_change > 0.5) {
                triggerStatisticsCheck(sql_template);
                return true;
            }
        }
        
        return false;
    }
    
    // 触发统计信息检查
    void triggerStatisticsCheck(const string& sql_template) {
        // 分析SQL涉及的表
        vector<string> tables = extractTables(sql_template);
        
        for (const string& table : tables) {
            // 检查统计信息的新鲜度
            time_t last_update = getStatisticsLastUpdate(table);
            if (time(nullptr) - last_update > 3600) {  // 1小时前的统计
                scheduleAnalyzeTable(table);
            }
        }
    }
};
```

### 6.4 统计信息质量评估


**🔸 统计信息准确度评估**：
```sql
-- 评估统计信息的准确度
SELECT 
    table_name,
    table_rows as estimated_rows,
    (SELECT COUNT(*) FROM information_schema.tables 
     WHERE table_name = t.table_name) as actual_rows,
    ABS(table_rows - (SELECT COUNT(*) FROM information_schema.tables 
                      WHERE table_name = t.table_name)) / table_rows * 100 as error_rate
FROM information_schema.tables t
WHERE table_schema = DATABASE()
  AND engine = 'InnoDB'
HAVING error_rate > 20;  -- 误差超过20%的表

-- 结果示例
┌─────────────┬─────────────┬─────────────┬─────────────┐
│ table_name  │ estimated   │ actual_rows │ error_rate  │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ users       │ 1000000     │ 200000      │ 80.0%       │
│ orders      │ 500000      │ 480000      │ 4.0%        │
│ products    │ 10000       │ 12000       │ 20.0%       │
└─────────────┴─────────────┴─────────────┴─────────────┘

-- 对误差大的表执行ANALYZE
ANALYZE TABLE users, products;
```

---

## 7. ⚙️ 自动统计信息配置优化


### 7.1 核心配置参数详解


**🔸 自动更新相关配置**：
```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'innodb_stats%';

-- 核心参数配置说明
┌────────────────────────────────┬─────────────┬─────────────────────────────┐
│ 参数名称                        │ 推荐值       │ 配置说明                     │
├────────────────────────────────┼─────────────┼─────────────────────────────┤
│ innodb_stats_auto_recalc       │ ON          │ 开启自动统计更新             │
│ innodb_stats_persistent        │ ON          │ 统计信息持久化到磁盘         │
│ innodb_stats_sample_pages      │ 20          │ 默认采样页数                 │
│ innodb_stats_include_delete_marked │ OFF     │ 不包含标记删除的行           │
│ innodb_stats_method           │ nulls_equal │ NULL值处理方法               │
│ innodb_stats_traditional      │ OFF         │ 使用新的统计算法             │
└────────────────────────────────┴─────────────┴─────────────────────────────┘
```

**🔸 根据业务特点优化配置**：
```sql
-- 高频读取业务的优化配置
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_sample_pages = 50;      -- 提高采样精度
SET GLOBAL innodb_stats_persistent = ON;

-- 高频写入业务的优化配置  
SET GLOBAL innodb_stats_auto_recalc = OFF;      -- 关闭自动更新
-- 改为定期手动更新，避免影响写入性能

-- 读写混合业务的平衡配置
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_sample_pages = 20;      -- 平衡精度和性能
-- 配合业务低峰期的定期ANALYZE
```

### 7.2 分表统计策略


**🔸 基于表特征的差异化配置**：
```sql
-- 针对不同类型表的配置策略

-- 核心业务表：高精度统计
ALTER TABLE users 
    STATS_AUTO_RECALC = 1,
    STATS_PERSISTENT = 1,
    STATS_SAMPLE_PAGES = 100;

ALTER TABLE orders
    STATS_AUTO_RECALC = 1, 
    STATS_PERSISTENT = 1,
    STATS_SAMPLE_PAGES = 80;

-- 日志类表：低精度统计  
ALTER TABLE access_logs
    STATS_AUTO_RECALC = 0,           -- 禁用自动更新
    STATS_PERSISTENT = 1,
    STATS_SAMPLE_PAGES = 8;

-- 临时表：最小化统计开销
ALTER TABLE temp_calculation
    STATS_AUTO_RECALC = 0,
    STATS_PERSISTENT = 0;            -- 不持久化统计信息

-- 历史数据表：中等精度
ALTER TABLE orders_history  
    STATS_AUTO_RECALC = 1,
    STATS_SAMPLE_PAGES = 20;
```

### 7.3 动态配置管理


**🔸 基于负载的动态调整**：
```cpp
class DynamicStatsConfigManager {
private:
    struct TableLoadMetrics {
        double qps;                  // 每秒查询数
        double dps;                  // 每秒删除数
        double complexity_score;     // 查询复杂度评分
        time_t last_major_delete;    // 最后一次大删除时间
    };
    
    map<TableID, TableLoadMetrics> load_metrics;
    
public:
    // 根据负载动态调整统计配置
    void adjustStatisticsConfig() {
        for (auto& [table_id, metrics] : load_metrics) {
            StatsConfig new_config = calculateOptimalConfig(metrics);
            applyConfigToTable(table_id, new_config);
        }
    }
    
private:
    StatsConfig calculateOptimalConfig(const TableLoadMetrics& metrics) {
        StatsConfig config;
        
        // 高频查询表需要更精确的统计
        if (metrics.qps > 100) {
            config.sample_pages = 50;
            config.auto_recalc = true;
            config.update_threshold = 0.05;  // 5%变化就更新
        }
        // 高频写入表适当降低统计更新频率
        else if (metrics.dps > 50) {
            config.sample_pages = 20;
            config.auto_recalc = true; 
            config.update_threshold = 0.15;  // 15%变化才更新
        }
        // 复杂查询表需要更详细的直方图
        else if (metrics.complexity_score > 0.8) {
            config.sample_pages = 100;
            config.enable_histogram = true;
            config.histogram_buckets = 100;
        }
        // 普通表使用默认配置
        else {
            config.sample_pages = 20;
            config.auto_recalc = true;
            config.update_threshold = 0.1;
        }
        
        return config;
    }
};
```

---

## 8. 📊 统计信息监控与维护


### 8.1 统计信息监控指标


**🔸 关键监控指标**：
```sql
-- 创建统计信息监控视图
CREATE VIEW statistics_health_monitor AS
SELECT 
    t.table_schema,
    t.table_name,
    t.table_rows as estimated_rows,
    ts.last_update,
    TIMESTAMPDIFF(HOUR, ts.last_update, NOW()) as hours_since_update,
    
    -- 计算统计信息新鲜度评分
    CASE 
        WHEN TIMESTAMPDIFF(HOUR, ts.last_update, NOW()) < 1 THEN '🟢 新鲜'
        WHEN TIMESTAMPDIFF(HOUR, ts.last_update, NOW()) < 24 THEN '🟡 一般'
        WHEN TIMESTAMPDIFF(HOUR, ts.last_update, NOW()) < 168 THEN '🟠 过期'
        ELSE '🔴 严重过期'
    END as freshness_status,
    
    -- 评估统计信息的重要性
    CASE 
        WHEN t.table_rows > 1000000 THEN '🔥 高优先级'
        WHEN t.table_rows > 100000 THEN '⚡ 中优先级'
        ELSE '📋 低优先级'
    END as priority_level

FROM information_schema.tables t
LEFT JOIN mysql.innodb_table_stats ts ON t.table_name = ts.table_name
WHERE t.table_schema = DATABASE()
  AND t.engine = 'InnoDB'
ORDER BY t.table_rows DESC;

-- 查看监控结果
SELECT * FROM statistics_health_monitor;
```

**🔸 自动化监控脚本**：
```sql
-- 创建统计信息健康检查存储过程
DELIMITER //
CREATE PROCEDURE CheckStatisticsHealth()
BEGIN
    DECLARE alert_count INT DEFAULT 0;
    
    -- 检查严重过期的重要表
    SELECT COUNT(*) INTO alert_count
    FROM statistics_health_monitor  
    WHERE priority_level = '🔥 高优先级'
      AND freshness_status IN ('🟠 过期', '🔴 严重过期');
    
    IF alert_count > 0 THEN
        -- 记录告警信息
        INSERT INTO statistics_alerts (alert_time, alert_type, message)
        SELECT 
            NOW(),
            'STATS_OUTDATED',
            CONCAT('发现 ', alert_count, ' 个重要表的统计信息严重过期')
        FROM DUAL;
        
        -- 自动更新严重过期的重要表
        BEGIN
            DECLARE done INT DEFAULT FALSE;
            DECLARE table_name VARCHAR(100);
            
            DECLARE table_cursor CURSOR FOR
                SELECT t.table_name
                FROM statistics_health_monitor t
                WHERE t.priority_level = '🔥 高优先级'
                  AND t.freshness_status IN ('🟠 过期', '🔴 严重过期');
            
            DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
            
            OPEN table_cursor;
            
            update_loop: LOOP
                FETCH table_cursor INTO table_name;
                IF done THEN LEAVE update_loop; END IF;
                
                SET @sql = CONCAT('ANALYZE TABLE ', table_name);
                PREPARE stmt FROM @sql;
                EXECUTE stmt;
                DEALLOCATE PREPARE stmt;
                
            END LOOP;
            
            CLOSE table_cursor;
        END;
    END IF;
END //
DELIMITER ;

-- 设置定期健康检查
CREATE EVENT statistics_health_check
ON SCHEDULE EVERY 2 HOUR  -- 每2小时检查一次
DO CALL CheckStatisticsHealth();
```

### 8.2 DELETE操作的统计监控


**🔸 DELETE操作对统计信息影响的监控**：
```sql
-- 创建DELETE操作影响监控表
CREATE TABLE delete_impact_log (
    log_id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(100),
    delete_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    rows_deleted INT,
    rows_before INT,
    rows_after INT,
    delete_ratio DECIMAL(5,2),
    stats_updated BOOLEAN DEFAULT FALSE,
    performance_impact_score DECIMAL(3,2)
);

-- 监控DELETE操作的存储过程
DELIMITER //
CREATE PROCEDURE LogDeleteImpact(
    IN p_table_name VARCHAR(100),
    IN p_rows_deleted INT
)
BEGIN
    DECLARE v_rows_before INT;
    DECLARE v_rows_after INT;
    DECLARE v_delete_ratio DECIMAL(5,2);
    DECLARE v_impact_score DECIMAL(3,2);
    
    -- 获取删除前后的行数
    SET v_rows_after = (SELECT table_rows 
                       FROM information_schema.tables 
                       WHERE table_name = p_table_name);
    SET v_rows_before = v_rows_after + p_rows_deleted;
    SET v_delete_ratio = (p_rows_deleted / v_rows_before) * 100;
    
    -- 计算性能影响评分
    SET v_impact_score = CASE 
        WHEN v_delete_ratio > 50 THEN 1.0   -- 严重影响
        WHEN v_delete_ratio > 20 THEN 0.7   -- 中等影响  
        WHEN v_delete_ratio > 5 THEN 0.3    -- 轻微影响
        ELSE 0.1                            -- 很小影响
    END;
    
    -- 记录影响日志
    INSERT INTO delete_impact_log (
        table_name, rows_deleted, rows_before, rows_after,
        delete_ratio, performance_impact_score
    ) VALUES (
        p_table_name, p_rows_deleted, v_rows_before, v_rows_after,
        v_delete_ratio, v_impact_score
    );
    
    -- 如果影响较大，触发统计更新
    IF v_delete_ratio > 10 THEN
        SET @sql = CONCAT('ANALYZE TABLE ', p_table_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 标记统计信息已更新
        UPDATE delete_impact_log 
        SET stats_updated = TRUE 
        WHERE table_name = p_table_name 
          AND delete_time = (SELECT MAX(delete_time) 
                            FROM delete_impact_log 
                            WHERE table_name = p_table_name);
    END IF;
END //
DELIMITER ;
```

### 8.3 统计信息维护最佳实践


**🔸 维护策略矩阵**：
```
基于表特征的维护策略：

┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐
│ 表类型       │ 数据变化频率 │ 查询频率     │ 更新策略     │ 监控频率     │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 核心业务表   │ 高          │ 极高         │ 实时自动更新 │ 每小时       │
│ 分析报表表   │ 低          │ 高          │ 每日定时更新 │ 每日         │
│ 日志记录表   │ 极高        │ 低          │ 每周批量更新 │ 每周         │
│ 配置参数表   │ 极低        │ 中等         │ 手动触发更新 │ 每月         │
│ 临时处理表   │ 高          │ 低          │ 禁用统计更新 │ 不监控       │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘

实施配置：
-- 核心业务表
ALTER TABLE users, orders, products
    STATS_AUTO_RECALC = 1,
    STATS_SAMPLE_PAGES = 50;

-- 分析报表表
ALTER TABLE daily_reports, monthly_summary  
    STATS_AUTO_RECALC = 0;  -- 定时手动更新
    
-- 日志表  
ALTER TABLE access_logs, error_logs
    STATS_AUTO_RECALC = 0,
    STATS_SAMPLE_PAGES = 8;  -- 降低采样精度
```

**🔸 维护时间窗口规划**：
```
统计信息维护时间安排：

每日维护（凌晨2:00-4:00）：
• 更新核心业务表统计
• 检查统计信息健康度
• 处理accumulated的更新需求

每周维护（周日凌晨1:00-5:00）：
• 全面更新所有表统计信息
• 清理统计信息历史记录
• 优化统计信息配置

每月维护（月初周末）：
• 评估统计信息策略效果
• 调整采样参数
• 清理过期的监控数据

紧急维护（按需触发）：
• 大规模DELETE后立即更新
• 查询性能异常时检查统计
• 系统升级后重建统计
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 统计信息本质：MySQL优化器制定查询计划的重要依据
🔸 DELETE影响机制：删除操作会改变表和索引的统计特征
🔸 自动更新机制：MySQL会根据数据变化自动更新统计信息
🔸 ANALYZE TABLE作用：手动触发统计信息的精确更新
🔸 配置优化原则：根据业务特点选择合适的统计策略
🔸 监控维护重要性：确保统计信息的准确性和时效性
```

### 9.2 关键理解要点


**🔹 为什么DELETE后要关注统计信息**
```
核心原因：
• 查询计划依赖：优化器基于统计信息选择执行计划
• 性能直接影响：过期统计导致非最优计划，性能下降
• 成本估算偏差：错误的行数估算影响索引选择
• 累积效应：多次DELETE的累积影响可能很严重

类比理解：
就像GPS导航需要实时路况信息一样，
MySQL优化器需要准确的统计信息来选择最佳路径。
如果路况信息过期，就可能选择拥堵的路线。
```

**🔹 自动更新 vs 手动更新的选择**
```
自动更新的优势：
• 及时性：数据变化后及时更新
• 便利性：无需人工干预
• 一致性：所有表采用统一策略

手动更新的优势：
• 可控性：在合适的时机执行
• 精确性：可以使用更高的采样精度
• 性能保护：避免在业务高峰期执行

选择原则：
• 核心表：自动+定期手动双重保障
• 一般表：主要依赖自动更新
• 特殊表：根据具体情况定制策略
```

**🔹 监控的重要性**
```
监控解决的问题：
• 及时发现：统计信息过期或不准确
• 性能保障：避免因统计问题导致的性能下降
• 趋势分析：了解数据变化对系统的影响
• 容量规划：基于统计信息做容量预测

监控的关键指标：
• 统计信息新鲜度：最后更新时间
• 统计信息准确度：估算值与实际值的偏差
• DELETE操作影响度：删除比例和频率
• 查询计划稳定性：执行计划的变化情况
```

### 9.3 实际应用价值


**架构设计指导**：
- **DELETE策略制定**：大批量删除前后的统计信息维护计划
- **监控体系建设**：建立统计信息健康度监控机制
- **配置优化方案**：根据业务特点制定差异化统计策略
- **性能调优方向**：通过统计信息分析定位性能瓶颈

**运维最佳实践**：
- **预防性维护**：定期检查和更新统计信息
- **故障快速定位**：通过统计信息偏差识别性能问题
- **容量规划支持**：基于准确统计信息做扩容决策
- **自动化运维**：建立统计信息的自动化维护流程

### 9.4 常见问题解答


**Q1：DELETE操作后一定要执行ANALYZE TABLE吗？**
```
答：不一定，需要根据删除规模判断
• 删除 < 5%数据：通常不需要立即更新
• 删除 5-20%数据：建议在业务低峰期执行
• 删除 > 20%数据：强烈建议立即执行
• 删除特定条件数据：如果影响查询条件的统计分布，建议执行

判断标准：
如果DELETE操作显著改变了数据分布特征，
或者涉及经常用作查询条件的列，就应该更新统计信息。
```

**Q2：为什么有时候执行了ANALYZE TABLE，查询还是很慢？**
```
答：可能存在多种原因
• 统计信息只是影响因素之一：索引设计、SQL写法也很重要
• 采样精度不够：可以增加STATS_SAMPLE_PAGES提高精度
• 数据分布不均匀：某些极端情况下采样可能不代表整体
• 查询计划缓存：可能需要清空plan cache让新统计生效

解决方法：
1. 检查索引是否合适
2. 增加采样页数重新分析
3. 使用FLUSH STATUS清空缓存
4. 考虑是否需要添加直方图统计
```

**Q3：自动统计更新会影响业务性能吗？**
```
答：影响通常很小，但需要合理配置
• CPU影响：通常 < 5%，主要是采样计算
• IO影响：随机读取采样页面，影响较小
• 锁影响：更新统计信息时会短暂持有锁

优化建议：
• 合理设置采样页数，平衡精度和性能
• 监控统计更新的执行时间
• 对于超大表，考虑在业务低峰期手动更新
• 可以临时禁用自动更新，改为定时批量更新
```

**Q4：如何知道统计信息是否需要更新？**
```
答：通过多种方式来判断
• 查看统计信息新鲜度：检查最后更新时间
• 对比估算行数和实际行数：误差 > 20%需要更新
• 监控查询计划变化：执行计划异常变化
• 关注查询性能：相同查询性能明显下降

实用SQL：
SELECT table_name, table_rows, 
       TIMESTAMPDIFF(HOUR, update_time, NOW()) as hours_old
FROM information_schema.tables 
WHERE table_schema = DATABASE() 
  AND TIMESTAMPDIFF(HOUR, update_time, NOW()) > 24;
```

### 9.5 学习建议和进阶方向


**循序渐进的学习路径**：
```
第1阶段：理解基础概念
• 什么是统计信息及其作用
• DELETE操作如何影响统计信息
• ANALYZE TABLE的基本用法

第2阶段：掌握配置和监控
• 统计信息相关参数配置
• 建立监控和告警机制
• 理解不同业务场景的策略选择

第3阶段：深入优化实践
• 基于统计信息进行性能调优
• 解决复杂的查询计划问题
• 建立自动化维护体系

第4阶段：高级应用
• 大规模系统的统计信息管理
• 结合监控数据做容量规划
• 统计信息对分布式系统的影响
```

**实践练习建议**：
- **模拟DELETE场景**：在测试环境模拟各种删除操作，观察统计信息变化
- **性能对比测试**：对比统计信息更新前后的查询性能差异  
- **监控系统搭建**：建立统计信息健康度监控dashboard
- **自动化脚本开发**：编写统计信息维护的自动化脚本

**核心记忆要点**：
- DELETE操作会显著影响统计信息的准确性
- 统计信息是查询优化器制定执行计划的重要依据
- 需要在自动更新和手动控制之间找到平衡
- 监控和维护统计信息是保证数据库性能的重要环节
- 不同业务场景需要采用不同的统计信息策略