---
title: 23、分区表删除与存储空间回收
---
## 📚 目录

1. [分区表删除操作概述](#1-分区表删除操作概述)
2. [分区表TRUNCATE处理机制](#2-分区表truncate处理机制)
3. [分区表DELETE特性分析](#3-分区表delete特性分析)
4. [分区删除策略设计](#4-分区删除策略设计)
5. [存储空间回收机制](#5-存储空间回收机制)
6. [分区删除性能优化](#6-分区删除性能优化)
7. [实际应用与最佳实践](#7-实际应用与最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📊 分区表删除操作概述


### 1.1 什么是分区表删除


> 💡 **通俗理解**：分区表删除就像清理一个有多个抽屉的文件柜，你可以清空某个抽屉，也可以直接把整个抽屉拿掉

**分区表删除操作类型**：
```
分区表数据清理方式：
┌─ 普通删除操作 ─┐
│ DELETE FROM    │ ← 删除满足条件的数据行
│ table WHERE... │
└────────────────┘
         │
┌─ 分区级删除操作 ─┐
│ DROP PARTITION  │ ← 删除整个分区
│ TRUNCATE        │ ← 清空分区数据
│ PARTITION       │
└─────────────────┘
```

**分区删除的核心优势**：
- 🚀 **删除速度快**：直接删除分区文件，无需逐行删除
- 💾 **空间回收快**：立即释放磁盘空间
- 🔒 **锁定时间短**：避免长时间锁定整个表
- 📈 **性能影响小**：不产生大量binlog和undo log

### 1.2 分区表删除场景


**典型应用场景**：
```
时间序列数据管理：
┌─ 日志表分区 ─┐
│ 2024-01月    │ ← 可以整月删除
│ 2024-02月    │
│ 2024-03月    │ ← 当前活跃分区
└──────────────┘

业务数据归档：
┌─ 订单表分区 ─┐  
│ 已完成订单   │ ← 定期清理老数据
│ 进行中订单   │
│ 新建订单     │ ← 保留最新数据  
└──────────────┘
```

### 1.3 分区表vs普通表删除对比


| 操作类型 | **删除方式** | **执行速度** | **资源消耗** | **空间回收** |
|---------|-------------|-------------|-------------|-------------|
| **普通表DELETE** | `逐行删除` | `慢(O(n))` | `高(undo+binlog)` | `需要OPTIMIZE` |
| **普通表TRUNCATE** | `重建表结构` | `快` | `中等` | `立即回收` |
| **分区DROP** | `删除分区文件` | `最快` | `极低` | `立即回收` |
| **分区TRUNCATE** | `清空分区` | `快` | `低` | `立即回收` |

---

## 2. 🔄 分区表TRUNCATE处理机制


### 2.1 分区表TRUNCATE工作原理


> 📖 **机制说明**：分区表的TRUNCATE可以针对单个分区或整个表进行，处理机制有所不同

**TRUNCATE操作类型**：
```
分区表TRUNCATE操作分类：
┌─ 整表TRUNCATE ─┐
│ TRUNCATE TABLE │ ← 清空所有分区
│ partition_table│
└────────────────┘
         │
┌─ 单分区TRUNCATE ─┐
│ ALTER TABLE      │ ← 清空指定分区
│ partition_table  │
│ TRUNCATE         │
│ PARTITION p1     │
└──────────────────┘
```

**TRUNCATE执行流程**：
```
分区TRUNCATE执行过程：
客户端请求 ────► MySQL解析器 ────► 存储引擎
    │               │               │
    │               │               │
    ▼               ▼               ▼
TRUNCATE命令    验证权限和语法    删除分区数据文件
    │               │               │
    │               │               │
    ▼               ▼               ▼
指定分区      获取表级锁        重建分区结构
    │               │               │
    │               │               │
    ▼               ▼               ▼
立即执行      记录DDL日志       释放锁并返回
```

### 2.2 单分区TRUNCATE操作


**单分区TRUNCATE语法**：
```sql
-- 清空指定分区的数据
ALTER TABLE orders 
TRUNCATE PARTITION p_2023_01;

-- 同时清空多个分区
ALTER TABLE orders 
TRUNCATE PARTITION p_2023_01, p_2023_02;

-- 检查分区状态
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH,
    INDEX_LENGTH
FROM information_schema.PARTITIONS 
WHERE TABLE_NAME = 'orders';
```

**TRUNCATE vs DELETE性能对比**：

<details>
<summary>🔧 性能测试示例</summary>

```sql
-- 创建测试分区表
CREATE TABLE test_partition (
    id INT AUTO_INCREMENT,
    created_date DATE,
    data VARCHAR(100),
    PRIMARY KEY (id, created_date)
) PARTITION BY RANGE (YEAR(created_date)) (
    PARTITION p_2022 VALUES LESS THAN (2023),
    PARTITION p_2023 VALUES LESS THAN (2024),
    PARTITION p_2024 VALUES LESS THAN (2025)
);

-- 插入测试数据 (100万条)
INSERT INTO test_partition (created_date, data) 
SELECT 
    DATE_ADD('2023-01-01', INTERVAL RAND() * 365 DAY),
    CONCAT('test_data_', RAND())
FROM 
    (SELECT 1 UNION SELECT 2 UNION SELECT 3) t1,
    (SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) t2,
    information_schema.columns LIMIT 1000000;

-- 性能对比测试
-- DELETE方式 (通常需要几分钟)
DELETE FROM test_partition 
WHERE YEAR(created_date) = 2023;

-- TRUNCATE方式 (通常几秒钟)  
ALTER TABLE test_partition 
TRUNCATE PARTITION p_2023;
```

</details>

### 2.3 整表TRUNCATE特殊处理


**整表TRUNCATE执行逻辑**：
```sql
-- 整表TRUNCATE
TRUNCATE TABLE orders;

-- 等价于对所有分区执行TRUNCATE
-- 但执行效率更高，因为可以并行处理
```

**整表TRUNCATE的特点**：
- ✅ **原子操作**：要么全部成功，要么全部失败
- ✅ **并行处理**：可以同时清空多个分区
- ✅ **元数据保留**：保持分区结构不变
- ⚠️ **全表锁定**：执行期间其他操作被阻塞

---

## 3. ❌ 分区表DELETE特性分析


### 3.1 分区表DELETE工作机制


> 📝 **核心理解**：分区表的DELETE操作具有分区剪裁优化，只影响相关分区

**分区剪裁(Partition Pruning)原理**：
```sql
-- 示例：按日期分区的订单表
CREATE TABLE orders (
    order_id INT,
    order_date DATE,
    customer_id INT,
    amount DECIMAL(10,2),
    PRIMARY KEY (order_id, order_date)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p_2022 VALUES LESS THAN (2023),
    PARTITION p_2023 VALUES LESS THAN (2024), 
    PARTITION p_2024 VALUES LESS THAN (2025)
);

-- 删除2023年的订单（只影响p_2023分区）
DELETE FROM orders 
WHERE order_date >= '2023-01-01' 
  AND order_date < '2024-01-01';
```

**分区剪裁执行过程**：
```
DELETE语句分区剪裁过程：
┌─ 分析WHERE条件 ─┐
│ order_date      │
│ >= '2023-01-01' │ 
│ < '2024-01-01'  │
└─────────────────┘
         │
         ▼
┌─ 确定影响分区 ─┐
│ 只需扫描:      │
│ p_2023分区     │ ← 大幅减少扫描范围
│ 跳过其他分区   │
└─────────────────┘
         │
         ▼  
┌─ 执行删除操作 ─┐
│ 在p_2023分区  │
│ 中删除匹配行   │
└─────────────────┘
```

### 3.2 分区表DELETE性能特征


**性能优势分析**：
```
分区表DELETE性能优势：
┌─ 扫描范围缩小 ─┐
│ 普通表: 全表   │ 1000万行 → 需要扫描全部
│ 分区表: 单分区 │ 100万行  → 只扫描相关分区
└────────────────┘
         │
         ▼
┌─ 锁定范围减少 ─┐
│ 只锁定相关分区 │ ← 提高并发性
│ 其他分区可访问 │
└────────────────┘
         │
         ▼
┌─ IO操作优化 ─┐
│ 读取数据量少  │ ← 减少磁盘IO
│ 缓存命中率高  │
└───────────────┘
```

**DELETE性能监控**：
```sql
-- 查看DELETE操作的分区剪裁情况
EXPLAIN PARTITIONS 
DELETE FROM orders 
WHERE order_date = '2023-06-15';

-- 输出示例：
-- partitions: p_2023  ← 只影响一个分区

-- 监控分区级别的删除统计
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    AVG_ROW_LENGTH,
    DATA_LENGTH 
FROM information_schema.PARTITIONS 
WHERE TABLE_SCHEMA = 'your_db' 
  AND TABLE_NAME = 'orders';
```

### 3.3 批量DELETE优化策略


**大批量DELETE问题**：
```
大批量DELETE可能的问题：
┌─ 长时间锁定 ─┐
│ 删除100万行  │ ← 可能锁定几分钟
│ 阻塞其他操作 │
└──────────────┘
         │
         ▼
┌─ 事务日志膨胀 ─┐
│ binlog增大     │ ← 影响主从同步
│ undo log增大   │ ← 占用大量空间
└────────────────┘
```

**分批删除策略**：
```sql
-- 分批删除示例
DELIMITER $$
CREATE PROCEDURE batch_delete_orders(
    IN start_date DATE,
    IN end_date DATE,
    IN batch_size INT DEFAULT 1000
)
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE del_count INT;
    
    REPEAT
        DELETE FROM orders 
        WHERE order_date >= start_date 
          AND order_date <= end_date 
        LIMIT batch_size;
        
        SET del_count = ROW_COUNT();
        
        -- 短暂休息，释放锁
        DO SLEEP(0.01);
        
    UNTIL del_count < batch_size END REPEAT;
END$$
DELIMITER ;

-- 调用分批删除
CALL batch_delete_orders('2023-01-01', '2023-03-31', 5000);
```

---

## 4. 🎯 分区删除策略设计


### 4.1 基于时间的删除策略


> 💡 **应用场景**：日志表、监控数据、历史订单等时间敏感数据的自动清理

**滑动窗口删除策略**：
```
时间窗口滑动删除：
时间线: ──┬──┬──┬──┬──┬──┬──┬──►
         │  │  │  │  │  │  │  │
分区:    P1 P2 P3 P4 P5 P6 P7 P8
状态:    删 删 删 保 保 保 保 当前

规则: 保留最近4个月数据，自动删除老分区
```

**自动删除脚本示例**：
```sql
-- 创建自动删除存储过程
DELIMITER $$
CREATE PROCEDURE auto_cleanup_log_partitions()
BEGIN
    DECLARE v_partition_name VARCHAR(64);
    DECLARE v_partition_desc VARCHAR(255);
    DECLARE done INT DEFAULT 0;
    
    -- 游标：查找3个月前的分区
    DECLARE partition_cursor CURSOR FOR
        SELECT PARTITION_NAME, PARTITION_DESCRIPTION
        FROM information_schema.PARTITIONS 
        WHERE TABLE_SCHEMA = DATABASE()
          AND TABLE_NAME = 'access_log'
          AND PARTITION_NAME IS NOT NULL
          AND CAST(PARTITION_DESCRIPTION AS SIGNED) <= UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 3 MONTH));
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN partition_cursor;
    
    cleanup_loop: LOOP
        FETCH partition_cursor INTO v_partition_name, v_partition_desc;
        
        IF done THEN
            LEAVE cleanup_loop;
        END IF;
        
        -- 执行分区删除
        SET @sql = CONCAT('ALTER TABLE access_log DROP PARTITION ', v_partition_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 记录删除日志
        INSERT INTO partition_cleanup_log 
        VALUES (NOW(), 'access_log', v_partition_name, 'DROPPED');
        
    END LOOP;
    
    CLOSE partition_cursor;
END$$
DELIMITER ;

-- 设置定时任务每天执行
CREATE EVENT IF NOT EXISTS daily_partition_cleanup
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURRENT_DATE + INTERVAL 1 DAY, '02:00:00')
DO CALL auto_cleanup_log_partitions();
```

### 4.2 基于容量的删除策略


**容量阈值删除逻辑**：
```sql
-- 监控分区大小并自动删除
CREATE PROCEDURE cleanup_by_size_limit(
    IN table_name VARCHAR(64),
    IN size_limit_gb INT
)
BEGIN
    DECLARE total_size_gb DECIMAL(10,2);
    DECLARE oldest_partition VARCHAR(64);
    
    -- 计算当前表的总大小
    SELECT ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 / 1024, 2)
    INTO total_size_gb
    FROM information_schema.PARTITIONS 
    WHERE TABLE_SCHEMA = DATABASE() 
      AND TABLE_NAME = table_name;
    
    -- 如果超过限制，删除最老的分区
    WHILE total_size_gb > size_limit_gb DO
        -- 找到最老的分区
        SELECT PARTITION_NAME INTO oldest_partition
        FROM information_schema.PARTITIONS 
        WHERE TABLE_SCHEMA = DATABASE() 
          AND TABLE_NAME = table_name
          AND PARTITION_NAME IS NOT NULL
        ORDER BY PARTITION_ORDINAL_POSITION
        LIMIT 1;
        
        -- 删除最老分区
        SET @sql = CONCAT('ALTER TABLE ', table_name, ' DROP PARTITION ', oldest_partition);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 重新计算大小
        SELECT ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 / 1024, 2)
        INTO total_size_gb
        FROM information_schema.PARTITIONS 
        WHERE TABLE_SCHEMA = DATABASE() 
          AND TABLE_NAME = table_name;
    END WHILE;
END$$
```

### 4.3 条件化删除策略


**业务规则驱动的删除**：
```sql
-- 基于业务条件的智能删除
CREATE PROCEDURE smart_order_cleanup()
BEGIN
    DECLARE v_partition VARCHAR(64);
    DECLARE v_min_date DATE;
    DECLARE v_has_active_orders INT;
    
    -- 检查每个历史分区
    FOR partition_record IN (
        SELECT PARTITION_NAME, 
               STR_TO_DATE(SUBSTRING(PARTITION_NAME, 3), '%Y_%m') as partition_date
        FROM information_schema.PARTITIONS 
        WHERE TABLE_NAME = 'orders' 
          AND PARTITION_NAME LIKE 'p_%'
          AND STR_TO_DATE(SUBSTRING(PARTITION_NAME, 3), '%Y_%m') < DATE_SUB(NOW(), INTERVAL 6 MONTH)
    )
    DO
        -- 检查是否还有未完成的订单
        SELECT COUNT(*) INTO v_has_active_orders
        FROM orders PARTITION (partition_record.PARTITION_NAME)
        WHERE status IN ('pending', 'processing');
        
        -- 只删除没有活跃订单的历史分区
        IF v_has_active_orders = 0 THEN
            SET @sql = CONCAT('ALTER TABLE orders DROP PARTITION ', partition_record.PARTITION_NAME);
            PREPARE stmt FROM @sql;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;
        END IF;
    END FOR;
END$$
```

---

## 5. 💾 存储空间回收机制


### 5.1 分区删除的空间回收原理


> 📖 **机制说明**：分区删除时，存储空间的回收是立即的，不像普通表删除需要额外操作

**空间回收对比**：
```
普通表DELETE空间回收：
DELETE操作 ──► 标记删除 ──► 空间未释放 ──► OPTIMIZE TABLE ──► 空间回收
   │            │            │              │                │
   慢          慢          需要手动         很慢              完成

分区DROP空间回收：
DROP PARTITION ──► 删除文件 ──► 空间立即释放
   │               │            │
   快              快           立即完成
```

**分区文件管理机制**：
```
MySQL分区文件存储结构：
/var/lib/mysql/database/
├── orders.frm           ← 表结构文件
├── orders#P#p_2022.MYD  ← 分区数据文件
├── orders#P#p_2022.MYI  ← 分区索引文件  
├── orders#P#p_2023.MYD
├── orders#P#p_2023.MYI
└── orders#P#p_2024.MYD
    orders#P#p_2024.MYI

DROP PARTITION操作直接删除对应的.MYD和.MYI文件
```

### 5.2 不同存储引擎的空间回收


**InnoDB分区空间回收**：
```sql
-- InnoDB分区表空间回收
-- 使用innodb_file_per_table=ON时，每个分区有独立文件

-- 查看分区文件大小
SELECT 
    PARTITION_NAME,
    ROUND(DATA_LENGTH/1024/1024, 2) AS 'Data Size(MB)',
    ROUND(INDEX_LENGTH/1024/1024, 2) AS 'Index Size(MB)',
    ROUND((DATA_LENGTH+INDEX_LENGTH)/1024/1024, 2) AS 'Total Size(MB)'
FROM information_schema.PARTITIONS 
WHERE TABLE_SCHEMA = 'your_db' 
  AND TABLE_NAME = 'orders'
  AND PARTITION_NAME IS NOT NULL;

-- 删除分区后立即释放空间
ALTER TABLE orders DROP PARTITION p_2022;
-- 对应的.ibd文件立即被删除，空间释放
```

**MyISAM分区空间回收**：
```sql
-- MyISAM分区表空间回收更直接
-- 每个分区对应独立的.MYD和.MYI文件

-- 删除分区
ALTER TABLE log_table DROP PARTITION p_old;
-- 对应的.MYD和.MYI文件立即删除，空间释放

-- 检查文件系统空间
-- Linux: df -h
-- Windows: dir *.MYD
```

### 5.3 空间回收验证与监控


**空间回收验证方法**：

<details>
<summary>🔧 空间回收监控脚本</summary>

```bash
#!/bin/bash
# 分区删除前后空间监控脚本

DB_NAME="your_database"
TABLE_NAME="your_table"
MYSQL_USER="root"
MYSQL_PASS="password"

echo "=== 分区删除前空间统计 ==="
mysql -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    PARTITION_NAME,
    ROUND(DATA_LENGTH/1024/1024, 2) AS 'Data_MB',
    ROUND(INDEX_LENGTH/1024/1024, 2) AS 'Index_MB',
    ROUND((DATA_LENGTH+INDEX_LENGTH)/1024/1024, 2) AS 'Total_MB'
FROM information_schema.PARTITIONS 
WHERE TABLE_SCHEMA = '${DB_NAME}' 
  AND TABLE_NAME = '${TABLE_NAME}'
  AND PARTITION_NAME IS NOT NULL;
"

# 记录磁盘空间
echo "=== 磁盘空间使用情况 ==="
df -h /var/lib/mysql

# 执行分区删除（这里需要根据实际情况修改）
echo "=== 执行分区删除 ==="
mysql -u${MYSQL_USER} -p${MYSQL_PASS} -e "
ALTER TABLE ${DB_NAME}.${TABLE_NAME} DROP PARTITION p_old;
"

# 删除后验证
echo "=== 分区删除后空间统计 ==="
mysql -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    PARTITION_NAME,
    ROUND(DATA_LENGTH/1024/1024, 2) AS 'Data_MB',
    ROUND(INDEX_LENGTH/1024/1024, 2) AS 'Index_MB',
    ROUND((DATA_LENGTH+INDEX_LENGTH)/1024/1024, 2) AS 'Total_MB'
FROM information_schema.PARTITIONS 
WHERE TABLE_SCHEMA = '${DB_NAME}' 
  AND TABLE_NAME = '${TABLE_NAME}'
  AND PARTITION_NAME IS NOT NULL;
"

echo "=== 删除后磁盘空间使用情况 ==="
df -h /var/lib/mysql
```

</details>

---

## 6. ⚡ 分区删除性能优化


### 6.1 删除操作性能分析


**性能影响因素**：
```
分区删除性能影响因素：
┌─ 分区大小 ─┐
│ 小分区(<1GB) │ ← 毫秒级删除
│ 中分区(1-10GB)│ ← 秒级删除  
│ 大分区(>10GB) │ ← 可能需要几十秒
└──────────────┘
         │
┌─ 存储引擎 ─┐
│ MyISAM     │ ← 删除最快
│ InnoDB     │ ← 需要清理事务信息
└────────────┘
         │  
┌─ 系统负载 ─┐
│ IO繁忙     │ ← 删除变慢
│ 内存不足   │ ← 影响清理速度
└────────────┘
```

### 6.2 批量分区删除优化


**并发删除策略**：
```sql
-- 串行删除多个分区（传统方式）
ALTER TABLE orders DROP PARTITION p_2020_01;
ALTER TABLE orders DROP PARTITION p_2020_02;  
ALTER TABLE orders DROP PARTITION p_2020_03;
-- 问题：逐个删除，总时间长

-- 批量删除多个分区（优化方式）
ALTER TABLE orders 
DROP PARTITION p_2020_01, p_2020_02, p_2020_03;
-- 优势：一次操作，减少元数据锁定次数
```

**删除时机优化**：
```sql
-- 选择合适的删除时机
-- 1. 业务低峰期执行
-- 2. 避免与备份、维护任务冲突
-- 3. 监控系统负载

-- 智能删除调度
CREATE PROCEDURE smart_partition_drop(
    IN target_partition VARCHAR(64)
)
BEGIN
    DECLARE current_load DECIMAL(5,2);
    
    -- 检查系统负载
    SELECT VARIABLE_VALUE INTO current_load
    FROM information_schema.GLOBAL_STATUS 
    WHERE VARIABLE_NAME = 'Threads_running';
    
    -- 负载过高时等待
    WHILE current_load > 50 DO
        DO SLEEP(30);
        SELECT VARIABLE_VALUE INTO current_load
        FROM information_schema.GLOBAL_STATUS 
        WHERE VARIABLE_NAME = 'Threads_running';
    END WHILE;
    
    -- 执行删除
    SET @sql = CONCAT('ALTER TABLE orders DROP PARTITION ', target_partition);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$
```

### 6.3 删除操作监控优化


**实时监控删除进度**：
```sql
-- 监控长时间运行的DDL操作
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM information_schema.PROCESSLIST 
WHERE INFO LIKE '%DROP PARTITION%'
   OR INFO LIKE '%TRUNCATE PARTITION%';

-- 监控元数据锁等待
SELECT 
    OBJECT_TYPE,
    OBJECT_SCHEMA,
    OBJECT_NAME,
    LOCK_TYPE,
    LOCK_STATUS,
    THREAD_ID
FROM performance_schema.metadata_locks 
WHERE OBJECT_NAME = 'your_table_name';
```

**删除性能基准测试**：

<details>
<summary>📊 分区删除性能测试</summary>

```sql
-- 创建性能测试表
CREATE TABLE perf_test_partition (
    id BIGINT AUTO_INCREMENT,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    data TEXT,
    PRIMARY KEY (id, created_time)
) PARTITION BY RANGE (UNIX_TIMESTAMP(created_time)) (
    PARTITION p_202301 VALUES LESS THAN (UNIX_TIMESTAMP('2023-02-01')),
    PARTITION p_202302 VALUES LESS THAN (UNIX_TIMESTAMP('2023-03-01')),
    PARTITION p_202303 VALUES LESS THAN (UNIX_TIMESTAMP('2023-04-01'))
);

-- 插入测试数据
INSERT INTO perf_test_partition (data) 
SELECT CONCAT('test_data_', n) 
FROM (
    SELECT a.N + b.N * 10 + c.N * 100 + d.N * 1000 as n
    FROM 
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) a,
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) b,
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) c,
    (SELECT 0 as N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) d
) numbers
LIMIT 1000000;

-- 性能测试：DELETE vs TRUNCATE vs DROP
-- 测试1：DELETE删除
SET @start_time = NOW(6);
DELETE FROM perf_test_partition PARTITION(p_202301);
SET @delete_time = TIMESTAMPDIFF(MICROSECOND, @start_time, NOW(6));

-- 测试2：TRUNCATE删除  
SET @start_time = NOW(6);
ALTER TABLE perf_test_partition TRUNCATE PARTITION p_202302;
SET @truncate_time = TIMESTAMPDIFF(MICROSECOND, @start_time, NOW(6));

-- 测试3：DROP删除
SET @start_time = NOW(6);
ALTER TABLE perf_test_partition DROP PARTITION p_202303;
SET @drop_time = TIMESTAMPDIFF(MICROSECOND, @start_time, NOW(6));

-- 输出结果对比
SELECT 
    @delete_time as 'DELETE_microseconds',
    @truncate_time as 'TRUNCATE_microseconds', 
    @drop_time as 'DROP_microseconds';
```

</details>

---

## 7. 🔧 实际应用与最佳实践


### 7.1 日志表分区删除实践


**典型日志表设计**：
```sql
-- 访问日志表设计
CREATE TABLE access_log (
    log_id BIGINT AUTO_INCREMENT,
    access_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id INT,
    ip_address VARCHAR(45),
    url_path VARCHAR(500),
    response_code INT,
    response_time INT,
    PRIMARY KEY (log_id, access_time),
    INDEX idx_user_time (user_id, access_time),
    INDEX idx_ip_time (ip_address, access_time)
) PARTITION BY RANGE (UNIX_TIMESTAMP(access_time)) (
    PARTITION p_202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p_202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01')),
    PARTITION p_202403 VALUES LESS THAN (UNIX_TIMESTAMP('2024-04-01')),
    PARTITION p_202404 VALUES LESS THAN (UNIX_TIMESTAMP('2024-05-01')),
    PARTITION p_current VALUES LESS THAN MAXVALUE
);
```

**自动化日志清理策略**：
```sql
-- 日志保留策略：保留3个月，删除3个月前的数据
CREATE PROCEDURE cleanup_access_log()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE v_partition_name VARCHAR(64);
    DECLARE v_partition_desc BIGINT;
    DECLARE v_cutoff_time BIGINT;
    
    -- 计算3个月前的时间戳
    SET v_cutoff_time = UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL 3 MONTH));
    
    -- 游标：查找需要删除的分区
    DECLARE partition_cursor CURSOR FOR
        SELECT PARTITION_NAME, CAST(PARTITION_DESCRIPTION AS UNSIGNED) as part_desc
        FROM information_schema.PARTITIONS 
        WHERE TABLE_SCHEMA = DATABASE()
          AND TABLE_NAME = 'access_log'
          AND PARTITION_NAME != 'p_current'
          AND PARTITION_DESCRIPTION != 'MAXVALUE'
          AND CAST(PARTITION_DESCRIPTION AS UNSIGNED) <= v_cutoff_time;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN partition_cursor;
    
    cleanup_loop: LOOP
        FETCH partition_cursor INTO v_partition_name, v_partition_desc;
        
        IF done THEN
            LEAVE cleanup_loop;
        END IF;
        
        -- 记录删除前的统计信息
        INSERT INTO log_cleanup_history (
            table_name, 
            partition_name, 
            rows_before_delete, 
            size_before_delete_mb,
            cleanup_time
        )
        SELECT 
            'access_log',
            v_partition_name,
            TABLE_ROWS,
            ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2),
            NOW()
        FROM information_schema.PARTITIONS
        WHERE TABLE_NAME = 'access_log' 
          AND PARTITION_NAME = v_partition_name;
        
        -- 执行分区删除
        SET @sql = CONCAT('ALTER TABLE access_log DROP PARTITION ', v_partition_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 记录成功删除
        UPDATE log_cleanup_history 
        SET status = 'SUCCESS', rows_deleted = rows_before_delete
        WHERE table_name = 'access_log' 
          AND partition_name = v_partition_name 
          AND cleanup_time = (SELECT MAX(cleanup_time) FROM log_cleanup_history WHERE partition_name = v_partition_name);
        
    END LOOP;
    
    CLOSE partition_cursor;
    
    -- 添加新的未来分区
    CALL add_future_log_partitions();
END$$
```

### 7.2 历史数据归档删除


**分阶段数据归档策略**：
```sql
-- 订单数据分阶段处理
CREATE PROCEDURE archive_old_orders()
BEGIN
    DECLARE v_archive_date DATE;
    DECLARE v_partition_name VARCHAR(64);
    
    -- 设置归档策略：1年前的已完成订单
    SET v_archive_date = DATE_SUB(CURDATE(), INTERVAL 12 MONTH);
    
    -- 第一阶段：将老数据导出到归档表
    INSERT INTO orders_archive 
    SELECT * FROM orders 
    WHERE order_date < v_archive_date 
      AND order_status = 'completed';
    
    -- 第二阶段：验证归档数据完整性
    IF (SELECT COUNT(*) FROM orders WHERE order_date < v_archive_date AND order_status = 'completed') = 
       (SELECT COUNT(*) FROM orders_archive WHERE order_date < v_archive_date) THEN
       
        -- 第三阶段：删除已归档的分区
        SET v_partition_name = CONCAT('p_', YEAR(v_archive_date), '_', LPAD(MONTH(v_archive_date), 2, '0'));
        
        SET @sql = CONCAT('ALTER TABLE orders DROP PARTITION ', v_partition_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 记录归档操作
        INSERT INTO archive_log VALUES (NOW(), 'orders', v_partition_name, 'ARCHIVED_AND_DROPPED');
    ELSE
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Archive verification failed';
    END IF;
END$$
```

### 7.3 监控数据清理实践


**实时监控数据清理**：
```sql
-- 监控指标表分区清理
CREATE PROCEDURE cleanup_monitoring_data()
BEGIN
    DECLARE v_retention_hours INT DEFAULT 168; -- 保留7天数据
    DECLARE v_cutoff_time BIGINT;
    
    SET v_cutoff_time = UNIX_TIMESTAMP(DATE_SUB(NOW(), INTERVAL v_retention_hours HOUR));
    
    -- 清理CPU使用率监控数据
    DELETE FROM cpu_usage_log 
    WHERE UNIX_TIMESTAMP(timestamp) < v_cutoff_time;
    
    -- 清理内存使用监控数据  
    DELETE FROM memory_usage_log 
    WHERE UNIX_TIMESTAMP(timestamp) < v_cutoff_time;
    
    -- 清理磁盘IO监控数据
    DELETE FROM disk_io_log 
    WHERE UNIX_TIMESTAMP(timestamp) < v_cutoff_time;
    
    -- 对于大表使用分区删除
    ALTER TABLE network_traffic_log 
    DROP PARTITION p_old;
    
    -- 重建分区结构
    CALL rebuild_monitoring_partitions();
END$$

-- 设置自动执行
CREATE EVENT daily_monitoring_cleanup
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURRENT_DATE + INTERVAL 1 DAY, '01:00:00')
DO CALL cleanup_monitoring_data();
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 分区删除优势：速度快、空间立即回收、锁定时间短
🔸 TRUNCATE机制：可针对单分区或整表，比DELETE效率高
🔸 DELETE特性：支持分区剪裁，只影响相关分区
🔸 删除策略：基于时间、容量、业务规则的智能删除
🔸 空间回收：分区删除立即释放磁盘空间，无需额外操作
🔸 性能优化：批量删除、时机选择、监控优化
```

### 8.2 关键理解要点


**🔹 分区删除的核心价值**
```
效率提升：
- DROP PARTITION：秒级删除大量数据
- 空间回收：立即释放磁盘空间
- 锁定优化：只影响相关分区，提高并发性
- 日志减少：不产生大量binlog和undo log
```

**🔹 不同删除方式的选择**
```
选择标准：
- 删除整个分区 → 使用DROP PARTITION
- 清空分区数据 → 使用TRUNCATE PARTITION  
- 条件删除部分数据 → 使用DELETE（支持分区剪裁）
- 批量删除 → 考虑分批处理或DROP整个分区
```

**🔹 存储空间回收的重要性**
```
立即回收的价值：
- 释放磁盘空间，避免存储不足
- 减少备份时间和存储成本
- 提高文件系统性能
- 便于容量规划和管理
```

### 8.3 实际应用指导


**分区删除最佳实践**：
- **制定策略**：根据业务需求设计数据保留策略
- **自动化执行**：使用存储过程和定时任务自动清理
- **安全验证**：删除前备份重要数据，删除后验证结果
- **性能优化**：选择合适时机，批量删除多个分区

**监控和维护要点**：
- **容量监控**：定期检查分区大小和总体容量
- **性能监控**：监控删除操作的执行时间和系统影响
- **日志记录**：记录所有分区删除操作，便于审计和回滚
- **故障恢复**：制定分区意外删除的恢复预案

**常见问题避免**：
- **误删分区**：建立严格的删除确认机制
- **删除时机**：避免在业务高峰期执行大量删除
- **依赖检查**：删除前确认没有应用依赖该分区数据
- **空间监控**：删除后验证空间确实被释放

**核心记忆要点**：
- 分区删除速度快，空间立即回收
- TRUNCATE和DROP针对分区，DELETE支持条件删除
- 制定合理的数据保留和清理策略
- 自动化执行，加强监控，确保安全可靠