---
title: 6、DELETE与TRUNCATE性能对比
---
## 📚 目录

1. [DELETE与TRUNCATE基本概念](#1-DELETE与TRUNCATE基本概念)
2. [工作原理深度对比](#2-工作原理深度对比)
3. [事务特性与回滚机制](#3-事务特性与回滚机制)
4. [自增ID与约束处理](#4-自增ID与约束处理)
5. [触发器与binlog行为差异](#5-触发器与binlog行为差异)
6. [性能对比与存储影响](#6-性能对比与存储影响)
7. [分区表与存储引擎实现](#7-分区表与存储引擎实现)
8. [实际应用选择指南](#8-实际应用选择指南)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🗂️ DELETE与TRUNCATE基本概念


### 1.1 基本定义对比


**DELETE语句**
```sql
-- 基本语法
DELETE FROM table_name [WHERE condition];

-- 核心特点
逐行删除：一条一条地删除记录
条件删除：可以指定WHERE条件
DML操作：数据操作语言，属于事务性操作
```

**TRUNCATE语句**
```sql
-- 基本语法
TRUNCATE TABLE table_name;

-- 核心特点
整表清空：一次性清空整个表
无条件操作：不能使用WHERE条件
DDL操作：数据定义语言，非事务性操作
```

### 1.2 操作对象差异


```
操作范围对比：

DELETE：
┌─────────────┐
│    表数据    │ ← 可以删除部分行
│ ┌─────────┐ │
│ │删除范围 │ │ ← WHERE条件控制
│ └─────────┘ │
│             │
└─────────────┘

TRUNCATE：
┌─────────────┐
│    表数据    │ ← 必须删除所有行
│█████████████│
│█████████████│ ← 整表清空
│█████████████│
└─────────────┘
```

### 1.3 使用场景初步判断


**什么时候用DELETE**：
- ✅ 需要删除部分数据（有WHERE条件）
- ✅ 需要在事务中控制删除操作
- ✅ 需要触发器正常执行
- ✅ 表有外键关系

**什么时候用TRUNCATE**：
- ✅ 需要清空整个表
- ✅ 追求最快的删除速度
- ✅ 希望重置自增ID
- ✅ 表没有复杂的约束关系

---

## 2. ⚙️ 工作原理深度对比


### 2.1 DELETE逐行删除机制


**🔍 DELETE工作原理**
```
DELETE执行过程：

第1步：解析WHERE条件
┌─────────────┐
│   查询优化   │ ← 确定删除哪些行
└─────────────┘
         ↓
第2步：逐行扫描删除
┌─────────────┐
│  行1：检查  │ → 符合条件？ → 删除 → 记录日志
├─────────────┤
│  行2：检查  │ → 符合条件？ → 跳过
├─────────────┤
│  行3：检查  │ → 符合条件？ → 删除 → 记录日志
└─────────────┘
         ↓
第3步：更新索引和统计信息
```

**📊 DELETE执行细节**
```sql
-- DELETE实际执行的内部操作
DELETE FROM users WHERE age > 60;

内部执行步骤：
1. 全表扫描或索引扫描找到符合条件的行
2. 对每一行执行：
   - 检查外键约束
   - 执行BEFORE DELETE触发器
   - 标记行为删除状态
   - 写入undo日志（支持回滚）
   - 写入redo日志（持久化保证）
   - 执行AFTER DELETE触发器
3. 更新表统计信息
4. 提交事务
```

### 2.2 TRUNCATE快速清空机制


**⚡ TRUNCATE工作原理**
```
TRUNCATE执行过程：

第1步：检查约束条件
┌─────────────┐
│ 外键检查    │ ← 有外键引用？报错退出
│ 权限检查    │ ← 是否有TRUNCATE权限？
└─────────────┘
         ↓
第2步：直接重置表结构
┌─────────────┐
│ 释放数据页  │ ← 直接释放所有数据页
│ 重置索引    │ ← 重建索引结构
│ 重置计数器  │ ← 自增ID归零
└─────────────┘
         ↓
第3步：更新系统元数据
```

**🚀 TRUNCATE内部实现**
```sql
-- TRUNCATE实际执行的内部操作
TRUNCATE TABLE users;

内部执行步骤：
1. 获取表的排他锁
2. 检查外键约束（如果有，直接报错）
3. 不逐行删除，而是：
   - 直接释放表的所有数据页
   - 重置表的元数据
   - 重置自增计数器
   - 重建索引结构（空索引）
4. 更新数据字典
5. 释放锁
```

### 2.3 底层存储操作差异


**DELETE的存储操作**：
```
存储层面的DELETE：

数据页状态变化：
┌─────────────┐     ┌─────────────┐
│ 行1│行2│行3 │ →   │ ___│行2│___ │
│ 行4│行5│行6 │     │ 行4│___│行6 │
└─────────────┘     └─────────────┘
删除行1、行3、行5      标记删除，空间可复用

特点：
• 行级标记删除
• 空间暂不回收
• 需要后续VACUUM清理（PostgreSQL）
• 或等待MySQL的purge线程清理
```

**TRUNCATE的存储操作**：
```
存储层面的TRUNCATE：

整个表空间重置：
┌─────────────┐     ┌─────────────┐
│ 数据页1     │     │             │
│ 数据页2     │ →   │   空表       │
│ 数据页3     │     │             │
│ 索引页      │     │   新索引     │
└─────────────┘     └─────────────┘

特点：
• 直接释放所有数据页
• 立即回收表空间
• 重新分配表文件
• 索引重建为空结构
```

---

## 3. 🔄 事务特性与回滚机制


### 3.1 事务属性根本差异


> 💡 **核心区别**：DELETE是DML操作，TRUNCATE是DDL操作

**DELETE事务特性**：
```sql
-- DELETE支持完整事务控制
BEGIN;
    DELETE FROM orders WHERE order_date < '2023-01-01';
    -- 可以查看删除结果
    SELECT COUNT(*) FROM orders;
    -- 如果不满意可以回滚
ROLLBACK;  -- ✅ 可以回滚，数据恢复
```

**TRUNCATE事务特性**：
```sql
-- TRUNCATE的事务行为（MySQL）
BEGIN;
    TRUNCATE TABLE temp_data;
    -- 立即提交，无法回滚
ROLLBACK;  -- ❌ 无效！数据已经没了

-- PostgreSQL中TRUNCATE可以回滚
BEGIN;
    TRUNCATE TABLE temp_data;
ROLLBACK;  -- ✅ PostgreSQL支持回滚
```

### 3.2 不同数据库的事务行为


| 数据库系统 | **DELETE回滚** | **TRUNCATE回滚** | **说明** |
|-----------|---------------|-----------------|---------|
| **MySQL** | `✅ 支持` | `❌ 不支持` | `TRUNCATE立即提交` |
| **PostgreSQL** | `✅ 支持` | `✅ 支持` | `TRUNCATE可在事务中回滚` |
| **Oracle** | `✅ 支持` | `❌ 不支持` | `TRUNCATE是DDL，立即提交` |
| **SQL Server** | `✅ 支持` | `❌ 不支持` | `TRUNCATE不能回滚` |

### 3.3 回滚机制详解


**DELETE回滚原理**：
```
DELETE回滚过程：

执行阶段：
数据行状态：[存在] → [标记删除] → [写入undo日志]

回滚阶段：
读取undo日志：[已删除行的原始数据]
恢复数据行：[标记删除] → [恢复存在]
清理日志：[清除本次事务的undo记录]

示例场景：
┌─────────────┐ DELETE ┌─────────────┐ ROLLBACK ┌─────────────┐
│ id=1, 张三  │   →    │ (已删除)    │    →     │ id=1, 张三  │
│ id=2, 李四  │        │ id=2, 李四  │          │ id=2, 李四  │
└─────────────┘        └─────────────┘          └─────────────┘
```

**TRUNCATE无法回滚原理**：
```
TRUNCATE执行过程：

MySQL/Oracle执行：
表结构：[包含数据] → [释放数据页] → [自动提交]
                ↑
            无undo日志记录
            
PostgreSQL执行：
表结构：[包含数据] → [标记清空] → [事务提交时执行]
                ↑
            有事务上下文
```

---

## 4. 🔢 自增ID与约束处理


### 4.1 自增ID重置行为


**DELETE对自增ID的影响**：
```sql
-- 测试DELETE对自增ID的影响
CREATE TABLE test_delete (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50)
);

INSERT INTO test_delete (name) VALUES ('张三'), ('李四'), ('王五');
-- 结果：id = 1, 2, 3

DELETE FROM test_delete WHERE id = 3;
INSERT INTO test_delete (name) VALUES ('赵六');
-- 结果：赵六的id = 4（继续递增）

DELETE FROM test_delete;  -- 删除所有行
INSERT INTO test_delete (name) VALUES ('钱七');
-- 结果：钱七的id = 5（继续递增，不重置）
```

**TRUNCATE对自增ID的影响**：
```sql
-- 测试TRUNCATE对自增ID的影响
TRUNCATE TABLE test_delete;
INSERT INTO test_delete (name) VALUES ('孙八');
-- 结果：孙八的id = 1（重置为1）

自增计数器重置：
执行前：AUTO_INCREMENT = 5
执行后：AUTO_INCREMENT = 1
```

### 4.2 自增ID重置机制解析


**为什么DELETE不重置自增ID**：
```
DELETE保持连续性原理：

内存中的自增计数器：
┌─────────────┐
│当前值: 5    │ ← 记录下一个分配的ID
│已用值: 1-4  │ ← 即使删除了，计数器不回退
└─────────────┘

优势：
• 保证ID唯一性
• 避免主键冲突
• 维护数据关联关系

应用场景：
订单表中删除订单，订单号不应该重复使用
```

**为什么TRUNCATE重置自增ID**：
```
TRUNCATE重置原理：

表元数据重置：
┌─────────────┐     ┌─────────────┐
│ 表数据: 存在 │ →   │ 表数据: 空  │
│ 自增值: 5   │     │ 自增值: 1   │
│ 索引: 有数据 │     │ 索引: 空    │
└─────────────┘     └─────────────┘

重置逻辑：
• 整表重建，恢复初始状态
• 所有计数器归零
• 相当于重新创建表
```

### 4.3 外键约束检查差异


**DELETE的外键检查**：
```sql
-- DELETE会检查外键约束
CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50));
CREATE TABLE orders (
    id INT PRIMARY KEY, 
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 插入测试数据
INSERT INTO users VALUES (1, '张三');
INSERT INTO orders VALUES (1, 1);

-- DELETE检查外键
DELETE FROM users WHERE id = 1;
-- ❌ 错误：Cannot delete parent row: foreign key constraint fails

-- 必须先删除子表记录
DELETE FROM orders WHERE user_id = 1;
DELETE FROM users WHERE id = 1;  -- ✅ 成功
```

**TRUNCATE的外键检查**：
```sql
-- TRUNCATE对外键更严格
TRUNCATE TABLE orders;  -- ✅ 成功，清空子表

TRUNCATE TABLE users;   -- ❌ 错误，即使orders表为空
-- 错误：Cannot truncate a table referenced in a foreign key constraint

-- 必须先删除外键约束或删除引用表
ALTER TABLE orders DROP FOREIGN KEY fk_user_id;
TRUNCATE TABLE users;   -- ✅ 现在可以成功
```

### 4.4 约束检查机制对比


```
约束检查流程对比：

DELETE约束检查：
用户执行DELETE → 查找要删除的行 → 逐行检查外键 → 执行删除

TRUNCATE约束检查：
用户执行TRUNCATE → 检查表是否被外键引用 → 有引用直接报错
                                        ↓
                                    无引用直接清空
                                    
实际影响：
• DELETE：只要被删除行没有外键引用就可以
• TRUNCATE：表被任何外键引用就不能执行
```

---

## 5. 🔥 触发器与binlog行为差异


### 5.1 触发器执行差异


**DELETE触发器执行**：
```sql
-- 创建删除触发器
DELIMITER $$
CREATE TRIGGER user_delete_log 
BEFORE DELETE ON users
FOR EACH ROW
BEGIN
    INSERT INTO delete_log (table_name, deleted_id, delete_time)
    VALUES ('users', OLD.id, NOW());
END$$
DELIMITER ;

-- DELETE会触发触发器
DELETE FROM users WHERE id = 1;
-- ✅ 触发器执行，delete_log表会有记录

-- 删除1000行，触发器执行1000次
DELETE FROM users WHERE created_date < '2023-01-01';
-- ⚠️ 性能影响：每行删除都要执行触发器逻辑
```

**TRUNCATE触发器行为**：
```sql
-- TRUNCATE不会触发任何触发器
TRUNCATE TABLE users;
-- ❌ 触发器不执行，delete_log表不会有记录

原因解析：
TRUNCATE是DDL操作，操作的是表结构层面
不是逐行删除，所以不会触发行级触发器
无法获取被删除行的数据（没有OLD记录）
```

### 5.2 触发器影响分析


**触发器性能影响对比**：
```
DELETE + 触发器场景：

表数据：100万行
触发器：记录删除日志 + 更新统计表

DELETE性能消耗：
┌─────────────┐
│删除100万行  │ ← 基础删除时间
├─────────────┤
│触发器100万次│ ← 额外触发器时间
├─────────────┤  
│日志写入     │ ← 每行写日志时间
└─────────────┘
总时间 ≈ 删除时间 × 3-5倍

TRUNCATE性能：
┌─────────────┐
│直接清空表   │ ← 秒级完成
└─────────────┘
无触发器开销
```

### 5.3 二进制日志（binlog）差异


**DELETE的binlog记录**：
```sql
-- DELETE会详细记录每行变化
DELETE FROM users WHERE age > 60;

binlog记录内容（ROW格式）：
## DELETE FROM test.users

## WHERE

##   @1=1001 /* id */

##   @2='张三' /* name */  

##   @3=65 /* age */

## DELETE FROM test.users

## WHERE

##   @1=1002 /* id */

##   @2='李四' /* name */

##   @3=70 /* age */


特点：
• 记录每行的完整数据
• 支持主从复制
• 支持数据恢复
• 日志量大，占用存储空间
```

**TRUNCATE的binlog记录**：
```sql
-- TRUNCATE只记录DDL语句本身
TRUNCATE TABLE users;

binlog记录内容：
TRUNCATE TABLE `test`.`users`

特点：
• 只记录一条DDL语句
• 不记录具体数据内容
• 主从复制时直接执行TRUNCATE
• 日志量极小
• ⚠️ 无法基于binlog恢复具体数据
```

### 5.4 主从复制影响


**主从复制行为对比**：
```
DELETE主从复制：
主库执行DELETE → 记录详细binlog → 从库重放每行删除
优势：从库可以精确重现主库的删除操作
风险：大量删除时主从延迟可能较大

TRUNCATE主从复制：
主库执行TRUNCATE → 记录DDL语句 → 从库执行TRUNCATE
优势：复制速度极快，几乎无延迟
风险：如果从库有不同数据，可能导致不一致

实际应用考虑：
• 主从数据必须完全一致才能安全使用TRUNCATE
• DELETE更安全但复制延迟更大
• TRUNCATE更快但要求环境更严格
```

---

## 6. 📈 性能对比与存储影响


### 6.1 性能基准测试


**🏃‍♂️ 删除速度对比**
```
测试环境：
• 表数据：1000万行记录
• 表大小：约2GB
• 服务器：16核CPU，64GB内存，SSD存储

DELETE性能测试：
DELETE FROM test_table;
执行时间：15-25分钟
CPU使用：持续高负载
内存使用：大量undo日志缓存
磁盘IO：大量随机写入

TRUNCATE性能测试：
TRUNCATE TABLE test_table;
执行时间：2-5秒
CPU使用：短暂峰值后恢复
内存使用：基本无额外消耗
磁盘IO：少量元数据更新

性能差异：DELETE比TRUNCATE慢300-750倍！
```

### 6.2 资源消耗详细分析


**DELETE资源消耗**：
```
CPU消耗：
┌─────────────┐
│ 行扫描CPU   │ ← 全表或索引扫描
├─────────────┤
│ 约束检查CPU │ ← 外键、触发器检查  
├─────────────┤
│ 日志写入CPU │ ← undo/redo日志处理
└─────────────┘

内存消耗：
┌─────────────┐
│ undo日志缓存│ ← 支持回滚，占用大量内存
├─────────────┤
│ redo日志缓存│ ← 持久化保证
├─────────────┤
│ 索引缓存    │ ← 索引页面更新
└─────────────┘

磁盘IO：
┌─────────────┐
│ 数据页读取  │ ← 读取要删除的行
├─────────────┤
│ undo日志写入│ ← 回滚信息写磁盘
├─────────────┤
│ redo日志写入│ ← 持久化日志写磁盘
├─────────────┤
│ 索引页更新  │ ← 索引结构调整
└─────────────┘
```

**TRUNCATE资源消耗**：
```
CPU消耗：
┌─────────────┐
│ 元数据更新  │ ← 更新数据字典，CPU消耗极小
└─────────────┘

内存消耗：
┌─────────────┐
│ 锁信息      │ ← 临时表锁，内存占用很小
└─────────────┘

磁盘IO：
┌─────────────┐
│ 数据页释放  │ ← 批量释放，IO量小
├─────────────┤
│ 元数据更新  │ ← 更新表统计信息
└─────────────┘
```

### 6.3 表空间回收机制


**DELETE空间回收**：
```sql
-- DELETE删除后的空间状态
DELETE FROM large_table WHERE created_date < '2023-01-01';

空间回收情况：
┌─────────────────┐
│ 逻辑删除行空间   │ ← 标记删除，空间未释放
│ 可重复使用       │ ← 新插入数据可以使用这些空间
│ 但文件大小不减少 │ ← 表文件大小保持不变
└─────────────────┘

手动回收空间：
-- MySQL
OPTIMIZE TABLE large_table;  -- 重建表，回收空间

-- PostgreSQL  
VACUUM FULL large_table;     -- 完全清理，回收空间
```

**TRUNCATE空间回收**：
```sql
-- TRUNCATE立即回收所有空间
TRUNCATE TABLE large_table;

空间回收效果：
┌─────────────────┐     ┌─────────────┐
│ 表文件: 2GB     │ →   │ 表文件: 几KB │
│ 索引文件: 500MB │     │ 索引文件: 几KB│
└─────────────────┘     └─────────────┘

立即效果：
• 磁盘空间立即释放
• 文件系统显示空间减少
• 无需额外的维护操作
```

### 6.4 锁机制对比


**DELETE锁行为**：
```sql
-- DELETE使用行级锁
DELETE FROM users WHERE age > 60;

锁机制：
┌─────────────┐
│ 行1: X锁    │ ← 删除时对行加排他锁
├─────────────┤
│ 行2: 无锁   │ ← 不删除的行可以并发访问
├─────────────┤
│ 行3: X锁    │ ← 删除时对行加排他锁
└─────────────┘

并发性：其他事务可以访问未删除的行
```

**TRUNCATE锁行为**：
```sql
-- TRUNCATE使用表级锁
TRUNCATE TABLE users;

锁机制：
┌─────────────┐
│ 整表: X锁   │ ← 对整个表加排他锁
│ 无法并发访问 │ ← 任何其他操作都要等待
└─────────────┘

并发性：完全阻塞其他事务对表的访问
```

---

## 7. 🔧 分区表与存储引擎实现


### 7.1 分区表TRUNCATE处理


**分区表TRUNCATE语法**：
```sql
-- 创建分区表
CREATE TABLE sales_data (
    id INT,
    sale_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- 清空特定分区
ALTER TABLE sales_data TRUNCATE PARTITION p2022;
-- ✅ 只清空2022年的数据，其他分区不受影响

-- 清空多个分区
ALTER TABLE sales_data TRUNCATE PARTITION p2022, p2023;

-- 清空整个分区表
TRUNCATE TABLE sales_data;
-- ✅ 清空所有分区
```

**分区TRUNCATE优势**：
```
分区级别的精确控制：

传统DELETE删除历史数据：
DELETE FROM sales_data WHERE sale_date < '2023-01-01';
• 需要扫描整表
• 逐行检查日期条件
• 性能随数据量线性下降

分区TRUNCATE删除历史数据：
ALTER TABLE sales_data TRUNCATE PARTITION p2022;
• 直接删除整个分区
• 无需扫描数据
• 性能与数据量无关，秒级完成
```

### 7.2 存储引擎实现差异


**InnoDB存储引擎**：
```sql
-- InnoDB中的TRUNCATE实现
TRUNCATE TABLE innodb_table;

InnoDB内部实现：
第1步：获取表的DDL锁
第2步：创建新的表空间文件
第3步：重建表结构元数据  
第4步：删除旧的表空间文件
第5步：更新数据字典
第6步：释放锁

特点：
• 原子操作，要么全部成功要么全部失败
• 表空间文件完全重建
• 自增值重置为1
• 不产生undo日志
```

**MyISAM存储引擎**：
```sql
-- MyISAM中的TRUNCATE实现  
TRUNCATE TABLE myisam_table;

MyISAM内部实现：
第1步：锁定表文件
第2步：清空.MYD数据文件
第3步：清空.MYI索引文件
第4步：重置.frm文件中的自增计数器
第5步：释放锁

特点：
• 直接操作文件系统
• 速度极快，几乎瞬间完成
• 文件大小立即变为0
• 无事务支持
```

### 7.3 不同存储引擎性能对比


| 存储引擎 | **DELETE性能** | **TRUNCATE性能** | **空间回收** | **事务支持** |
|---------|---------------|-----------------|-------------|-------------|
| **InnoDB** | `慢，有事务开销` | `快，DDL操作` | `TRUNCATE立即回收` | `DELETE支持事务` |
| **MyISAM** | `较快，无事务` | `极快，文件操作` | `TRUNCATE立即回收` | `都不支持事务` |
| **Memory** | `快，内存操作` | `极快，内存清零` | `内存立即释放` | `都不支持事务` |

### 7.4 存储引擎选择建议


**根据需求选择策略**：
```
高并发OLTP系统：
推荐：InnoDB + DELETE
原因：需要事务支持，数据一致性要求高
注意：避免大批量DELETE，考虑分批删除

数据仓库ETL：
推荐：InnoDB + TRUNCATE  
原因：定期清空临时表，追求处理速度
注意：确保无外键约束

日志轮转系统：
推荐：MyISAM + TRUNCATE
原因：写入频繁，定期清空，无事务需求
注意：注意并发控制
```

---

## 8. 🎯 实际应用选择指南


### 8.1 场景选择决策树


```
删除操作选择决策：

需要删除部分数据？
├─ 是 → 只能用DELETE
└─ 否 → 需要清空整表
    ├─ 需要事务控制？
    │   ├─ 是 → 用DELETE（或PostgreSQL的TRUNCATE）
    │   └─ 否 → 继续判断
    ├─ 表有外键引用？
    │   ├─ 是 → 用DELETE
    │   └─ 否 → 继续判断  
    ├─ 需要触发器执行？
    │   ├─ 是 → 用DELETE
    │   └─ 否 → 继续判断
    ├─ 追求最快速度？
    │   ├─ 是 → 用TRUNCATE
    │   └─ 否 → 根据具体需求选择
    └─ 需要保留自增ID？
        ├─ 是 → 用DELETE
        └─ 否 → 用TRUNCATE
```

### 8.2 典型应用场景


**🗂️ 数据清理场景**
```sql
-- 场景1：清理过期日志数据
-- 需求：删除30天前的日志，保留最近数据
DELETE FROM access_log WHERE created_time < DATE_SUB(NOW(), INTERVAL 30 DAY);
-- ✅ 使用DELETE，因为需要条件删除

-- 场景2：清空临时表
-- 需求：ETL过程中清空中间表
TRUNCATE TABLE tmp_import_data;
-- ✅ 使用TRUNCATE，追求速度

-- 场景3：重置测试数据
-- 需求：测试环境重置，保持表结构
TRUNCATE TABLE user_test_data;
-- ✅ 使用TRUNCATE，快速重置
```

**📊 数据迁移场景**
```sql
-- 场景4：历史数据归档
-- 步骤1：备份历史数据
INSERT INTO users_archive SELECT * FROM users WHERE created_date < '2023-01-01';

-- 步骤2：删除历史数据
DELETE FROM users WHERE created_date < '2023-01-01';
-- ✅ 使用DELETE，可以精确控制删除范围，支持回滚

-- 场景5：表重建优化
-- 需求：表碎片整理，重置自增ID
CREATE TABLE users_new LIKE users;
INSERT INTO users_new SELECT * FROM users WHERE status = 'active';
DROP TABLE users;
RENAME TABLE users_new TO users;
-- 或者直接
TRUNCATE TABLE users;
INSERT INTO users SELECT * FROM users_backup WHERE status = 'active';
```

### 8.3 性能优化策略


**DELETE性能优化**：
```sql
-- 优化策略1：分批删除
DELIMITER $$
CREATE PROCEDURE batch_delete()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    
    REPEAT
        DELETE FROM large_table 
        WHERE created_date < '2023-01-01' 
        LIMIT 10000;  -- 每次删除1万行
        
        -- 给其他事务让路
        SELECT SLEEP(0.1);
    UNTIL ROW_COUNT() = 0 END REPEAT;
END$$
DELIMITER ;

优势：
• 减少锁定时间
• 避免事务日志过大
• 提高并发性能
```

**TRUNCATE使用优化**：
```sql
-- 优化策略：先备份再清空
-- 步骤1：快速备份需要保留的数据
CREATE TABLE users_keep AS 
SELECT * FROM users WHERE status = 'active';

-- 步骤2：快速清空原表
TRUNCATE TABLE users;

-- 步骤3：恢复需要保留的数据
INSERT INTO users SELECT * FROM users_keep;
DROP TABLE users_keep;

适用场景：
• 需要删除大部分数据，保留少部分
• 保留数据量远小于删除数据量
• 可以接受短暂的停机时间
```

### 8.4 安全使用建议


> ⚠️ **重要提醒**：生产环境使用需要极度谨慎

**DELETE安全实践**：
```sql
-- ✅ 好习惯：先查询再删除
SELECT COUNT(*) FROM users WHERE last_login < '2022-01-01';
-- 确认要删除的行数合理

-- ✅ 使用事务保护
BEGIN;
DELETE FROM users WHERE last_login < '2022-01-01';
-- 检查删除结果
SELECT COUNT(*) FROM users;
-- 确认无误后提交
COMMIT;

-- ✅ 备份后删除
mysqldump -u root -p database_name users > users_backup.sql
DELETE FROM users WHERE last_login < '2022-01-01';
```

**TRUNCATE安全实践**：
```sql
-- ✅ 确认表没有重要数据
SELECT COUNT(*), MIN(created_date), MAX(created_date) FROM temp_table;

-- ✅ 检查外键约束
SELECT 
    TABLE_NAME,
    CONSTRAINT_NAME,
    REFERENCED_TABLE_NAME
FROM information_schema.KEY_COLUMN_USAGE 
WHERE REFERENCED_TABLE_NAME = 'target_table';

-- ✅ 生产环境谨慎使用
-- 建议：先在测试环境验证
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心差异


```
🔸 操作类型：DELETE是DML，TRUNCATE是DDL
🔸 删除方式：DELETE逐行删除，TRUNCATE整表清空
🔸 条件支持：DELETE支持WHERE，TRUNCATE不支持
🔸 事务支持：DELETE完全支持，TRUNCATE多数数据库不支持
🔸 回滚能力：DELETE可回滚，TRUNCATE通常不可回滚
🔸 自增重置：DELETE不重置，TRUNCATE重置为1
🔸 触发器：DELETE执行触发器，TRUNCATE不执行
🔸 性能差异：TRUNCATE比DELETE快几百倍
```

### 9.2 选择决策要点


**选择DELETE的情况**：
```
✅ 需要删除部分数据（有WHERE条件）
✅ 需要事务保护和回滚能力
✅ 表有外键约束关系
✅ 需要触发器正常执行
✅ 需要详细的binlog记录
✅ 希望保持自增ID连续性
```

**选择TRUNCATE的情况**：
```
✅ 需要清空整个表
✅ 追求最快的删除速度
✅ 希望立即回收表空间
✅ 希望重置自增ID
✅ 表没有外键约束
✅ 不需要触发器执行
✅ 可以接受无法回滚的风险
```

### 9.3 性能与安全平衡


**性能优先场景**：
- **数据清理**：定期清空临时表、日志表
- **测试环境**：快速重置测试数据
- **ETL过程**：数据加工中间表清空

**安全优先场景**：
- **生产数据**：用户数据、订单数据等关键业务数据
- **审计要求**：需要详细删除日志的合规场景
- **复杂关联**：有外键、触发器的复杂表结构

### 9.4 最佳实践建议


**通用最佳实践**：
```
1. 【数据备份】：重要数据删除前必须备份
2. 【测试验证】：生产操作前在测试环境验证
3. 【权限控制】：严格控制TRUNCATE权限
4. 【监控告警】：大批量删除操作要有监控
5. 【错峰执行】：大数据量删除选择业务低峰期
```

**代码规范建议**：
```sql
-- ✅ 推荐的安全删除模式
-- 第1步：确认删除范围
SELECT COUNT(*) FROM table_name WHERE condition;

-- 第2步：小批量删除（如果数据量大）
DELETE FROM table_name WHERE condition LIMIT 1000;

-- 第3步：检查删除结果
SELECT COUNT(*) FROM table_name WHERE condition;

-- ❌ 避免的危险操作
DELETE FROM important_table;  -- 无WHERE条件，风险极高
TRUNCATE TABLE production_users;  -- 生产用户表，风险极高
```

### 9.5 记忆要点


> 🔥 **核心记忆口诀**

**DELETE与TRUNCATE选择**：
- ***条件删除找DELETE，整表清空用TRUNCATE***
- ***要回滚选DELETE，要速度选TRUNCATE***  
- ***有外键用DELETE，重置ID用TRUNCATE***

**性能记忆**：
- ***DELETE按行扫，TRUNCATE秒杀完***
- ***空间回收TRUNCATE强，事务安全DELETE棒***

**安全记忆**：
- ***生产环境需谨慎，备份测试再执行***
- ***TRUNCATE虽然快，回滚不了要当心***

**技术本质**：
- ***DELETE是DML事务操作，TRUNCATE是DDL结构操作***
- ***理解本质抓关键，选择使用不会错***