---
title: 11、UPDATE锁机制与并发处理
---
## 📚 目录

1. [UPDATE锁机制基础](#1-UPDATE锁机制基础)
2. [行锁与表锁的选择策略](#2-行锁与表锁的选择策略)
3. [SELECT FOR UPDATE详解](#3-SELECT-FOR-UPDATE详解)
4. [并发更新冲突与解决方案](#4-并发更新冲突与解决方案)
5. [乐观锁与悲观锁策略](#5-乐观锁与悲观锁策略)
6. [MVCC更新版本链机制](#6-MVCC更新版本链机制)
7. [死锁诊断与预防](#7-死锁诊断与预防)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 UPDATE锁机制基础


### 1.1 什么是更新锁


**💡 通俗理解**：更新锁就像"排队买票"的机制
```
想象电影院售票：
🎫 普通观看 = SELECT查询（不影响其他人）
🔒 买票过程 = UPDATE操作（需要排队，一个一个来）
🚫 占座标记 = 锁机制（防止重复售卖同一座位）

数据库更新时：
读取数据 → 获取锁 → 修改数据 → 释放锁
确保同一时间只有一个操作在修改特定数据
```

### 1.2 更新操作的锁定过程


**🔄 UPDATE执行流程**
```
第1步：解析SQL，确定要更新的行
第2步：获取相应的锁（行锁或表锁）
第3步：读取当前数据到内存
第4步：执行数据修改
第5步：写入修改结果
第6步：提交事务，释放锁
```

**📊 锁定过程示意图**
```
事务A: UPDATE users SET age=25 WHERE id=1;

时间轴：
T1 ──→ 获取id=1行的排他锁
T2 ──→ 读取id=1的当前数据
T3 ──→ 修改age值为25  
T4 ──→ 写入新数据
T5 ──→ 提交事务
T6 ──→ 释放锁，其他事务可以访问

其他事务在T1-T6期间访问id=1会被阻塞等待
```

### 1.3 更新锁的类型


**🔸 排他锁（X Lock）- UPDATE的核心锁**
```
特性：
✅ 一次只能有一个事务持有
❌ 持有期间，其他事务不能读写该数据
🎯 目的：确保数据修改的原子性

锁定范围：
- 行级：只锁定被修改的具体行
- 表级：锁定整个表（性能较差）
```

**🔸 意向锁（Intention Lock）**
```
作用：表明事务打算在表的某些行上加锁
类型：
- 意向共享锁（IS）：准备加共享锁
- 意向排他锁（IX）：准备加排他锁

目的：提高锁管理效率，快速判断表级冲突
```

---

## 2. ⚖️ 行锁与表锁的选择策略


### 2.1 InnoDB行锁机制


**🎯 行锁的优势**
```
并发性能好：
- 不同行的修改可以并发进行
- 只有修改同一行时才会冲突
- 适合高并发OLTP应用

锁定粒度小：
- 只锁定实际被修改的行
- 其他行的操作不受影响
- 减少锁等待时间
```

**💻 行锁示例**
```sql
-- 会话A: 更新id=1的用户
UPDATE users SET age=25 WHERE id=1;

-- 会话B: 同时更新id=2的用户（不会阻塞）
UPDATE users SET age=30 WHERE id=2;

-- 会话C: 更新id=1的用户（会被阻塞等待）
UPDATE users SET name='张三' WHERE id=1;
```

### 2.2 MyISAM表锁机制


**🔸 表锁特性**
```
锁定范围大：
- 锁定整个表，无法并发修改
- 简单高效，开销小
- 适合读多写少的场景

并发性能差：
- 同时只能有一个写操作
- 读操作可以并发
- 不适合高并发修改
```

**📊 行锁vs表锁对比**

| 特性 | **InnoDB行锁** | **MyISAM表锁** | **说明** |
|------|---------------|---------------|----------|
| 🔐 **锁粒度** | `行级` | `表级` | 行锁更精细 |
| ⚡ **并发性** | `高` | 低 | 行锁支持更高并发 |
| 💾 **内存开销** | 大 | `小` | 行锁需要更多内存 |
| 🔧 **实现复杂度** | 复杂 | `简单` | 表锁实现更简单 |
| 🎯 **适用场景** | `OLTP高并发` | OLAP分析 | 根据业务选择 |

### 2.3 锁升级机制


**🔄 何时会发生锁升级**
```
触发条件：
1️⃣ 锁定行数过多（通常超过5000行）
2️⃣ 内存中锁结构占用过多
3️⃣ 无法使用索引的批量更新

升级过程：
行锁 → 页锁 → 表锁
粒度变大，并发性下降
```

**💡 避免锁升级的方法**
```sql
-- 不好的做法：可能导致锁升级
UPDATE users SET status='active' WHERE create_time < '2023-01-01';

-- 更好的做法：分批处理
UPDATE users SET status='active' 
WHERE create_time < '2023-01-01' 
LIMIT 1000;
```

---

## 3. 🔒 SELECT FOR UPDATE详解


### 3.1 SELECT FOR UPDATE的作用


**💡 通俗理解**：提前"预订座位"
```
普通SELECT：只是看看座位是否空闲
SELECT FOR UPDATE：先占住座位，再慢慢考虑买不买票

数据库场景：
普通SELECT：读取数据，其他事务仍可修改
SELECT FOR UPDATE：读取并锁定数据，其他事务必须等待
```

### 3.2 使用语法和场景


**💻 基本语法**
```sql
-- 锁定特定行
SELECT * FROM users WHERE id=1 FOR UPDATE;

-- 锁定查询结果的所有行
SELECT * FROM orders WHERE user_id=100 FOR UPDATE;

-- 超时控制（避免无限等待）
SELECT * FROM products WHERE id=1 FOR UPDATE NOWAIT;
SELECT * FROM products WHERE id=1 FOR UPDATE SKIP LOCKED;
```

**🎯 典型应用场景**
```sql
-- 场景1：库存扣减（防止超卖）
BEGIN;
SELECT stock FROM products WHERE id=1 FOR UPDATE;
-- 检查库存是否充足
UPDATE products SET stock=stock-1 WHERE id=1;
COMMIT;

-- 场景2：账户转账（防止余额不足）
BEGIN;
SELECT balance FROM accounts WHERE id=1 FOR UPDATE;
-- 检查余额是否充足  
UPDATE accounts SET balance=balance-100 WHERE id=1;
UPDATE accounts SET balance=balance+100 WHERE id=2;
COMMIT;
```

### 3.3 FOR UPDATE的锁定范围


**🔸 根据查询条件决定锁定范围**
```sql
-- 主键查询：只锁定一行
SELECT * FROM users WHERE id=1 FOR UPDATE;

-- 唯一索引：锁定匹配的行
SELECT * FROM users WHERE email='test@qq.com' FOR UPDATE;

-- 非唯一索引：锁定所有匹配行
SELECT * FROM users WHERE status='active' FOR UPDATE;

-- 无索引：可能锁定整个表（危险！）
SELECT * FROM users WHERE nickname='张三' FOR UPDATE;
```

**⚠️ 注意事项**
```
🚨 避免锁定过多行：
- 确保WHERE条件使用索引
- 使用LIMIT限制锁定行数
- 避免在无索引字段上使用

🚨 避免长时间持锁：
- 尽快提交事务
- 使用NOWAIT避免长时间等待
- 考虑使用SKIP LOCKED处理热点数据
```

---

## 4. 🔥 并发更新冲突与解决方案


### 4.1 丢失更新问题


**💡 什么是丢失更新**
```
第一类丢失更新（脏写）：
时间  事务A              事务B
T1   读取 balance=1000    
T2                      读取 balance=1000
T3   balance=800        
T4   写入 balance=800    
T5                      balance=500
T6                      写入 balance=500
结果：A的修改被B覆盖，丢失了

第二类丢失更新（不可重复读）：
基于过期数据进行更新，导致逻辑错误
```

**🎯 丢失更新的实际场景**
```sql
-- 经典场景：库存并发扣减
-- 事务A和B同时执行以下逻辑：
SELECT stock FROM products WHERE id=1;  -- 都读到stock=10
-- A: 扣减2个，计算后stock=8
-- B: 扣减3个，计算后stock=7  
UPDATE products SET stock=8 WHERE id=1;  -- A先提交
UPDATE products SET stock=7 WHERE id=1;  -- B后提交，覆盖A的结果

实际问题：应该剩余5个库存，但实际剩余7个
```

### 4.2 解决丢失更新的方案


**🔧 方案1：使用SELECT FOR UPDATE**
```sql
-- 正确的库存扣减
BEGIN;
SELECT stock FROM products WHERE id=1 FOR UPDATE;  -- 提前锁定
-- 其他事务必须等待，避免并发修改
UPDATE products SET stock=stock-2 WHERE id=1;
COMMIT;
```

**🔧 方案2：使用原子更新**
```sql
-- 直接在UPDATE中进行计算，避免读取
UPDATE products SET stock=stock-2 
WHERE id=1 AND stock>=2;

-- 检查影响的行数确认是否成功
if (affected_rows == 0) {
    // 库存不足或商品不存在
    throw new InsufficientStockException();
}
```

**🔧 方案3：使用版本号控制**
```sql
-- 表结构包含version字段
SELECT id, stock, version FROM products WHERE id=1;

-- 更新时检查版本号
UPDATE products 
SET stock=stock-2, version=version+1 
WHERE id=1 AND version=#{原版本号};

-- 如果影响行数为0，说明数据已被其他事务修改
```

### 4.3 并发更新性能优化


**⚡ 减少锁等待时间**
```sql
-- 不好的做法：长时间持锁
BEGIN;
SELECT * FROM orders WHERE user_id=1 FOR UPDATE;
-- ... 复杂的业务逻辑处理（耗时较长）
UPDATE orders SET status='paid' WHERE user_id=1;
COMMIT;

-- 更好的做法：缩短锁持有时间
-- 先处理业务逻辑
-- 最后再快速加锁更新
BEGIN;
UPDATE orders SET status='paid' WHERE user_id=1 AND status='pending';
COMMIT;
```

**🎯 热点数据处理策略**
```sql
-- 对于热点商品，使用SKIP LOCKED避免排队
SELECT id, stock FROM products 
WHERE category='hot' AND stock>0 
FOR UPDATE SKIP LOCKED 
LIMIT 10;

-- 或者使用队列分摊压力
-- 将热点更新请求放入消息队列异步处理
```

---

## 5. 🔄 乐观锁与悲观锁策略


### 5.1 悲观锁策略


**💡 悲观锁理念**："假设一定会发生冲突"
```
核心思想：
- 先获取锁，再进行操作
- 确保操作期间数据不被其他事务修改
- 适合冲突频率高的场景

实现方式：
SELECT FOR UPDATE、排他锁
```

**💻 悲观锁实现示例**
```sql
-- Java伪代码配合SQL
public void transferMoney(int fromAccount, int toAccount, int amount) {
    Connection conn = getConnection();
    conn.setAutoCommit(false);
    
    try {
        // 悲观锁：先锁定账户
        PreparedStatement ps1 = conn.prepareStatement(
            "SELECT balance FROM accounts WHERE id=? FOR UPDATE");
        ps1.setInt(1, fromAccount);
        ResultSet rs = ps1.executeQuery();
        
        int balance = rs.getInt("balance");
        if (balance < amount) {
            throw new InsufficientFundsException();
        }
        
        // 执行转账
        PreparedStatement ps2 = conn.prepareStatement(
            "UPDATE accounts SET balance=balance-? WHERE id=?");
        ps2.setInt(1, amount);
        ps2.setInt(2, fromAccount);
        ps2.executeUpdate();
        
        PreparedStatement ps3 = conn.prepareStatement(
            "UPDATE accounts SET balance=balance+? WHERE id=?");
        ps3.setInt(1, amount);
        ps3.setInt(2, toAccount);
        ps3.executeUpdate();
        
        conn.commit();
    } catch (Exception e) {
        conn.rollback();
        throw e;
    }
}
```

### 5.2 乐观锁策略


**💡 乐观锁理念**："假设不会发生冲突"
```
核心思想：
- 不加锁，直接进行操作
- 提交时检查是否有冲突
- 有冲突就重试，适合冲突较少的场景

实现方式：
版本号、时间戳、CAS比较交换
```

**💻 乐观锁实现示例**
```sql
-- 方式1：版本号机制
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    stock INT,
    version INT DEFAULT 1
);

-- 查询时获取版本号
SELECT id, stock, version FROM products WHERE id=1;

-- 更新时检查版本号
UPDATE products 
SET stock=stock-2, version=version+1 
WHERE id=1 AND version=#{currentVersion};

-- 方式2：时间戳机制  
ALTER TABLE products ADD COLUMN update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;

-- 更新时检查时间戳
UPDATE products 
SET stock=stock-2 
WHERE id=1 AND update_time=#{lastUpdateTime};
```

### 5.3 乐观锁vs悲观锁选择


**📊 对比分析表**

| 方面 | **悲观锁** | **乐观锁** | **推荐场景** |
|------|-----------|-----------|-------------|
| 🎯 **冲突处理** | `事前预防` | 事后检测 | 高冲突用悲观锁 |
| ⚡ **性能** | 可能阻塞 | `无阻塞` | 低冲突用乐观锁 |
| 🔧 **实现复杂度** | `简单` | 需要重试机制 | 简单业务用悲观锁 |
| 💾 **资源消耗** | 锁开销 | `重试开销` | 根据实际测试选择 |
| 🛡️ **数据安全** | `强一致性` | 最终一致性 | 强一致性用悲观锁 |

**🎯 选择指导原则**
```
使用悲观锁的场景：
✅ 写操作频繁，冲突概率高
✅ 对数据一致性要求严格
✅ 失败重试代价高
✅ 如：库存扣减、账户转账

使用乐观锁的场景：  
✅ 读多写少，冲突概率低
✅ 对响应时间敏感
✅ 可以接受重试
✅ 如：用户信息更新、商品评价
```

---

## 6. 🔄 MVCC更新版本链机制


### 6.1 MVCC基本原理


**💡 什么是MVCC**
```
MVCC = Multi-Version Concurrency Control（多版本并发控制）

通俗理解：数据的"历史版本管理"
就像Git版本控制：
- 每次修改创建新版本
- 旧版本保留一段时间  
- 不同事务看到不同版本的数据
- 读写互不阻塞
```

**🔸 MVCC的核心组件**
```
1️⃣ 版本链：每行数据的多个版本通过指针连接
2️⃣ 事务ID：每个事务有唯一的递增ID
3️⃣ ReadView：事务的可见性视图
4️⃣ Undo Log：存储数据的历史版本
```

### 6.2 更新时的版本链维护


**🔄 UPDATE操作的版本链过程**
```
原始数据：
┌─────────────────────────────────┐
│ id=1, name='张三', age=25, trx_id=100 │
└─────────────────────────────────┘

执行：UPDATE users SET age=26 WHERE id=1; (事务ID=200)

版本链变化：
新版本 ──→ 旧版本
┌─────────────────────────────────┐    ┌─────────────────────────────────┐
│ id=1, name='张三', age=26, trx_id=200 │──→│ id=1, name='张三', age=25, trx_id=100 │
└─────────────────────────────────┘    └─────────────────────────────────┘

新事务看到age=26，已提交的老事务根据ReadView可能看到age=25
```

**🔗 版本链结构详解**
```
每条记录包含的隐藏字段：
- DB_TRX_ID：最后修改该记录的事务ID
- DB_ROLL_PTR：指向Undo Log中上一个版本的指针  
- DB_ROW_ID：如果没有主键，InnoDB会生成的行ID

版本链示例：
最新版本(age=28,trx_id=300) ──→ 版本2(age=26,trx_id=200) ──→ 版本1(age=25,trx_id=100)
```

### 6.3 ReadView与可见性判断


**👁️ ReadView的构成**
```
ReadView包含：
- creator_trx_id：创建ReadView的事务ID
- m_ids：活跃事务ID列表（未提交的事务）
- min_trx_id：最小活跃事务ID
- max_trx_id：下一个要分配的事务ID

可见性判断规则：
1. 如果记录的trx_id等于creator_trx_id → 可见（自己修改的）
2. 如果记录的trx_id小于min_trx_id → 可见（已经提交的老事务）
3. 如果记录的trx_id在m_ids中 → 不可见（未提交的事务）
4. 否则 → 可见（已经提交的新事务）
```

**💻 MVCC实际示例**
```sql
-- 时刻T1：事务A开始，创建ReadView
-- ReadView: {creator_trx_id=100, m_ids=[], min_trx_id=100, max_trx_id=101}

-- 时刻T2：事务B修改数据但未提交
UPDATE users SET age=30 WHERE id=1; -- 事务ID=101

-- 时刻T3：事务A查询数据
SELECT age FROM users WHERE id=1;
-- ReadView判断：trx_id=101在活跃事务中，不可见
-- 沿着版本链查找，返回age=25（事务B修改前的值）

-- 时刻T4：事务B提交，事务A再次查询
SELECT age FROM users WHERE id=1;
-- 仍然返回age=25（可重复读隔离级别）
```

### 6.4 MVCC的优势与限制


**✅ MVCC的优势**
```
1️⃣ 读写不阻塞：SELECT不需要等待UPDATE完成
2️⃣ 一致性快照：同一事务内多次读取结果一致
3️⃣ 并发性能高：大大减少锁竞争
4️⃣ 减少死锁：读操作不加锁，降低死锁概率
```

**❌ MVCC的限制**
```
1️⃣ 额外存储开销：需要维护版本链和Undo Log
2️⃣ 版本清理成本：需要定期清理过期版本
3️⃣ 长事务问题：长事务会阻止版本清理，影响性能
4️⃣ 幻读问题：在某些隔离级别下仍然存在
```

---

## 7. 💀 死锁诊断与预防


### 7.1 UPDATE死锁的典型场景


**💡 什么是死锁**
```
死锁 = 两个或多个事务互相等待对方释放锁

经典场景："拿着筷子等勺子"
事务A：拿着锁1，等待锁2  
事务B：拿着锁2，等待锁1
结果：双方都等待，永远无法继续
```

**🔸 UPDATE死锁场景分析**
```sql
-- 场景1：不同顺序访问相同资源
-- 事务A                    事务B
UPDATE users SET age=25     UPDATE users SET name='李四'
WHERE id=1;                WHERE id=2;

UPDATE users SET name='张三' UPDATE users SET age=30  
WHERE id=2;                WHERE id=1;
-- A等待B释放id=2的锁       -- B等待A释放id=1的锁 → 死锁！

-- 场景2：升级锁冲突
-- 事务A                    事务B
SELECT * FROM users        SELECT * FROM users
WHERE id=1 FOR UPDATE;     WHERE id=1 FOR UPDATE;
-- A获得锁                  -- B等待

-- 如果A再次SELECT FOR UPDATE同一行，可能形成死锁
```

### 7.2 死锁检测与处理


**🔍 InnoDB的死锁检测**
```
自动检测机制：
1️⃣ InnoDB持续监控锁等待图
2️⃣ 检测到环形等待就判定为死锁
3️⃣ 选择代价最小的事务进行回滚
4️⃣ 被选中的事务收到死锁错误

死锁信息查看：
SHOW ENGINE INNODB STATUS;
-- 显示最近一次死锁的详细信息
```

**💻 死锁处理代码示例**
```java
public void updateWithDeadlockRetry(int userId, String newName) {
    int maxRetries = 3;
    int attempt = 0;
    
    while (attempt < maxRetries) {
        try {
            // 尝试执行更新
            executeUpdate("UPDATE users SET name=? WHERE id=?", 
                         newName, userId);
            return; // 成功则退出
            
        } catch (SQLException e) {
            if (isDeadlockException(e) && attempt < maxRetries - 1) {
                attempt++;
                // 随机延迟后重试，避免立即再次冲突
                Thread.sleep((int)(Math.random() * 100));
            } else {
                throw e; // 非死锁异常或重试次数耗尽
            }
        }
    }
}
```

### 7.3 死锁预防策略


**🛡️ 预防策略1：统一访问顺序**
```sql
-- 不好的做法：随机访问顺序
UPDATE table1 SET col1='a' WHERE id IN (3,1,2);
UPDATE table2 SET col2='b' WHERE id IN (1,3,2);

-- 好的做法：按主键排序访问
UPDATE table1 SET col1='a' WHERE id IN (1,2,3) ORDER BY id;
UPDATE table2 SET col2='b' WHERE id IN (1,2,3) ORDER BY id;
```

**🛡️ 预防策略2：缩短事务时间**
```sql
-- 不好的做法：长事务
BEGIN;
UPDATE users SET status='processing' WHERE id=1;
-- ... 长时间的业务处理 ...
-- ... 可能包含网络调用、文件IO等 ...
UPDATE users SET status='completed' WHERE id=1;
COMMIT;

-- 好的做法：最小化事务范围
-- 先完成业务处理
processBusinessLogic();

-- 快速执行数据库事务
BEGIN;
UPDATE users SET status='completed' WHERE id=1;
COMMIT;
```

**🛡️ 预防策略3：使用合适的索引**
```sql
-- 没有索引：可能锁定整个表
UPDATE users SET age=age+1 WHERE name='张三';

-- 有索引：只锁定匹配的行
-- 先添加索引
CREATE INDEX idx_name ON users(name);
-- 然后执行更新，锁定范围更精确
UPDATE users SET age=age+1 WHERE name='张三';
```

### 7.4 死锁监控与调优


**📊 监控指标**
```sql
-- 查看死锁统计
SHOW STATUS LIKE 'Innodb_deadlocks';

-- 查看锁等待情况
SELECT * FROM information_schema.innodb_locks;
SELECT * FROM information_schema.innodb_lock_waits;

-- 查看事务状态
SELECT * FROM information_schema.innodb_trx;
```

**⚡ 调优参数**
```sql
-- 设置死锁检测开关（通常保持开启）
SET GLOBAL innodb_deadlock_detect = ON;

-- 设置锁等待超时时间
SET GLOBAL innodb_lock_wait_timeout = 50;

-- 日志设置，记录死锁信息
SET GLOBAL log_error_verbosity = 3;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 更新锁 = 确保数据修改原子性的排他锁机制
🔸 行锁vs表锁 = 不同粒度的锁定策略，影响并发性能
🔸 SELECT FOR UPDATE = 提前锁定数据，防止并发修改
🔸 丢失更新 = 并发环境下数据修改相互覆盖的问题  
🔸 乐观锁vs悲观锁 = 两种不同的并发控制哲学
🔸 MVCC = 多版本并发控制，读写不互相阻塞
🔸 死锁 = 多个事务互相等待造成的僵局
```

### 8.2 关键理解要点


**🔹 为什么需要更新锁**
```
并发修改的问题：
- 数据不一致：两个事务同时修改同一数据
- 丢失更新：后提交的事务覆盖先提交的结果
- 逻辑错误：基于过期数据进行业务计算

更新锁的作用：
- 确保同一时间只有一个事务能修改数据
- 保证数据修改的原子性和一致性
- 防止并发修改导致的业务逻辑错误
```

**🔹 如何选择锁策略**
```
业务特征分析：
高并发低冲突 → 乐观锁 + 行锁
高并发高冲突 → 悲观锁 + 行锁  
低并发简单场景 → 表锁
关键数据更新 → SELECT FOR UPDATE
```

**🔹 MVCC的核心价值**
```
解决的问题：
- 读写冲突：SELECT不再需要等待UPDATE
- 一致性快照：事务内多次读取结果一致
- 并发性能：大幅减少锁竞争

实现原理：
- 为每行数据维护多个版本
- 不同事务看到不同版本的数据
- 通过版本链和ReadView控制可见性
```

### 8.3 实际应用指导


**💼 业务场景应用**
```
电商库存管理：
✅ 使用SELECT FOR UPDATE防止超卖
✅ 原子更新避免库存计算错误
✅ 分批处理避免锁定过多数据

金融账户操作：  
✅ 悲观锁确保余额计算准确
✅ 统一访问顺序避免死锁
✅ 缩短事务时间减少锁等待

用户信息维护：
✅ 乐观锁处理低频更新
✅ 版本号机制检测并发修改
✅ 重试机制处理偶发冲突
```

**🔧 性能优化实践**
```
锁优化原则：
1️⃣ 锁粒度越小越好（行锁优于表锁）
2️⃣ 持锁时间越短越好（快速提交事务）
3️⃣ 锁数量越少越好（避免锁升级）
4️⃣ 访问顺序要一致（避免死锁）

监控要点：
- 死锁频率和原因分析
- 锁等待时间和队列长度  
- 长事务对系统的影响
- MVCC版本链的清理效率
```

**🚨 常见问题与解决**
```
问题1：频繁死锁
解决：统一资源访问顺序，减少事务时间

问题2：锁等待超时
解决：优化查询使用索引，考虑分批处理

问题3：并发性能差
解决：从表锁改为行锁，使用乐观锁策略

问题4：数据不一致
解决：使用SELECT FOR UPDATE，版本号控制
```

**核心记忆**：
- 更新操作天然需要排他锁保护数据一致性
- 锁粒度影响并发性能，行锁优于表锁
- SELECT FOR UPDATE是防止并发修改的利器
- 乐观锁适合低冲突，悲观锁适合高冲突场景
- MVCC让读写并行，大幅提升数据库性能
- 预防死锁比检测死锁更重要