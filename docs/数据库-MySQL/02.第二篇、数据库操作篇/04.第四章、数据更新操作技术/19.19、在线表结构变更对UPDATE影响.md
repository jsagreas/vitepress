---
title: 19、在线表结构变更对UPDATE影响
---
## 📚 目录

1. [在线表结构变更概述](#1-在线表结构变更概述)
2. [DDL与DML操作并发机制](#2-ddl与dml操作并发机制)
3. [元数据锁MDL详解](#3-元数据锁mdl详解)
4. [Online DDL期间UPDATE行为](#4-online-ddl期间update行为)
5. [实际影响场景分析](#5-实际影响场景分析)
6. [优化策略与最佳实践](#6-优化策略与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔧 在线表结构变更概述


### 1.1 什么是在线表结构变更


**简单理解**：在线表结构变更就像在高速公路上修路，既要保证交通正常运行，又要完成道路改造。

```
传统DDL操作：
CREATE TABLE backup_table AS SELECT * FROM original_table;
DROP TABLE original_table;
RENAME TABLE backup_table TO original_table;
↓
问题：整个过程中表不可用，业务中断

Online DDL操作：
ALTER TABLE users ADD COLUMN phone VARCHAR(20);
↓
优势：表结构变更时，业务可以继续读写数据
```

### 1.2 Online DDL的核心价值


**为什么需要Online DDL？**
- 🎯 **业务连续性**：避免长时间的业务中断
- 🎯 **用户体验**：用户感知不到表结构变更过程
- 🎯 **运维灵活性**：可以在业务高峰期进行必要的结构调整
- 🎯 **风险控制**：减少因停机维护带来的业务风险

### 1.3 MySQL Online DDL发展历程


```
MySQL版本与Online DDL支持：

MySQL 5.5及之前：
- 大部分DDL操作需要锁表
- 业务必须停机维护

MySQL 5.6：
- 引入Online DDL特性
- 支持部分操作的在线执行

MySQL 5.7：
- 扩展Online DDL支持范围
- 优化锁机制

MySQL 8.0：
- 进一步完善Online DDL
- 支持更多复杂操作
```

---

## 2. ⚙️ DDL与DML操作并发机制


### 2.1 DDL和DML的基本概念


**DDL (Data Definition Language) - 数据定义语言**
- **含义**：用于定义和修改数据库结构的语句
- **常见操作**：CREATE、ALTER、DROP、TRUNCATE
- **影响范围**：表结构、索引结构、约束等

**DML (Data Manipulation Language) - 数据操作语言**  
- **含义**：用于操作数据内容的语句
- **常见操作**：SELECT、INSERT、UPDATE、DELETE
- **影响范围**：表中的具体数据

### 2.2 并发冲突的根本原因


**为什么DDL和DML会冲突？**

```
想象一下同时进行的两个操作：

操作A（DDL）：正在给表添加新列
ALTER TABLE users ADD COLUMN age INT;

操作B（DML）：正在更新用户数据
UPDATE users SET name = 'John' WHERE id = 1;

冲突原因：
1. DDL需要修改表的元数据结构
2. DML需要基于当前表结构操作数据
3. 如果结构正在变化，DML不知道该按哪个结构执行
```

### 2.3 MySQL的并发控制策略


**三层锁机制保证并发安全**：

```
MySQL的锁层次结构：

1. 元数据锁（MDL）     ← 保护表结构不被同时修改
   ↓
2. 表级锁（Table Lock） ← 保护表数据的一致性
   ↓  
3. 行级锁（Row Lock）   ← 保护具体行数据
```

**并发控制流程**：
```
DDL操作流程：
1. 获取MDL写锁 → 确保独占修改表结构
2. 执行结构变更 → 安全地修改表定义
3. 释放MDL写锁 → 允许其他操作继续

DML操作流程：
1. 获取MDL读锁 → 确保表结构稳定
2. 获取行级锁 → 锁定要修改的具体行
3. 执行数据操作 → 基于稳定结构操作数据
4. 释放所有锁 → 完成操作
```

### 2.4 兼容性矩阵


| DDL操作 | 并发SELECT | 并发INSERT | 并发UPDATE | 并发DELETE |
|---------|------------|------------|------------|------------|
| **ADD COLUMN** | ✅ 允许 | ✅ 允许 | ✅ 允许 | ✅ 允许 |
| **DROP COLUMN** | ✅ 允许 | ❌ 阻塞 | ❌ 阻塞 | ✅ 允许 |
| **ADD INDEX** | ✅ 允许 | ✅ 允许 | ✅ 允许 | ✅ 允许 |
| **DROP INDEX** | ✅ 允许 | ✅ 允许 | ✅ 允许 | ✅ 允许 |
| **CHANGE COLUMN TYPE** | ❌ 阻塞 | ❌ 阻塞 | ❌ 阻塞 | ❌ 阻塞 |

---

## 3. 🔐 元数据锁MDL详解


### 3.1 什么是元数据锁


**简单理解**：元数据锁(MDL)就像图书馆的"图书整理牌"，当管理员在整理某个书架时，读者暂时不能取用那个书架的书。

**MDL的作用**：
- 🎯 **保护表结构**：确保DDL操作时表结构不被并发修改
- 🎯 **维护一致性**：保证DML操作基于稳定的表结构执行
- 🎯 **防止冲突**：避免结构变更和数据操作的相互干扰

### 3.2 MDL锁的类型和级别


**MDL锁类型分类**：

```
MDL锁的层次结构：

MDL_INTENTION_EXCLUSIVE  ← 意向排他锁（最高级别）
    ↓
MDL_EXCLUSIVE           ← 排他锁（DDL写操作）
    ↓  
MDL_SHARED_WRITE        ← 共享写锁（DML写操作）
    ↓
MDL_SHARED_READ         ← 共享读锁（DML读操作）
    ↓
MDL_SHARED              ← 共享锁（最低级别）
```

**各类型锁的使用场景**：

| 锁类型 | 使用操作 | 排他性 | 典型场景 |
|--------|----------|--------|----------|
| **MDL_EXCLUSIVE** | ALTER TABLE、DROP TABLE | 排斥所有其他锁 | 表结构变更 |
| **MDL_SHARED_WRITE** | INSERT、UPDATE、DELETE | 与读锁兼容 | 数据写入操作 |
| **MDL_SHARED_READ** | SELECT | 与写锁兼容 | 数据读取操作 |

### 3.3 MDL锁的获取和释放机制


**锁获取过程**：
```sql
-- 示例：UPDATE操作的MDL锁获取过程

UPDATE users SET name = 'John' WHERE id = 1;

-- 内部执行步骤：
-- 1. 请求MDL_SHARED_WRITE锁
-- 2. 检查是否与现有锁冲突
-- 3. 获取成功后执行UPDATE
-- 4. 事务提交/回滚时释放MDL锁
```

**锁等待队列机制**：
```
当出现锁冲突时的排队情况：

时间线：
T1: ALTER TABLE users ADD COLUMN age INT;    ← 获得MDL_EXCLUSIVE
T2: UPDATE users SET name='A' WHERE id=1;   ← 等待MDL_SHARED_WRITE  
T3: SELECT * FROM users WHERE id=2;         ← 等待MDL_SHARED_READ
T4: UPDATE users SET name='B' WHERE id=3;   ← 等待MDL_SHARED_WRITE

等待队列：[T2(WRITE), T3(READ), T4(WRITE)]
当T1完成后，T2、T3、T4按顺序获取锁
```

### 3.4 MDL锁超时和死锁处理


**超时配置**：
```sql
-- 查看MDL锁等待超时设置
SHOW VARIABLES LIKE 'lock_wait_timeout';

-- 设置MDL锁等待超时时间（秒）
SET SESSION lock_wait_timeout = 60;
```

**死锁检测示例**：
```sql
-- 查看当前MDL锁等待情况
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id;
```

---

## 4. 🔄 Online DDL期间UPDATE行为


### 4.1 Online DDL的执行阶段


**Online DDL三阶段执行模型**：

```
Online DDL执行过程：

阶段1：准备阶段（Prepare Phase）
┌─────────────────────────────────┐
│ • 获取MDL排他锁                   │
│ • 创建临时表结构                  │ ← 短暂阻塞UPDATE
│ • 设置在线日志捕获                │
│ • 释放MDL排他锁，降级为共享锁      │
└─────────────────────────────────┘

阶段2：执行阶段（Execute Phase）  
┌─────────────────────────────────┐
│ • 并发执行DDL操作                │
│ • 同时记录DML变更到在线日志        │ ← UPDATE可以正常执行
│ • 构建新的表结构/索引             │
└─────────────────────────────────┘

阶段3：提交阶段（Commit Phase）
┌─────────────────────────────────┐
│ • 再次获取MDL排他锁               │
│ • 应用在线日志中的DML变更         │ ← 短暂阻塞UPDATE
│ • 切换到新表结构                 │
│ • 清理临时文件                   │
└─────────────────────────────────┘
```

### 4.2 不同DDL操作对UPDATE的具体影响


**添加列操作**：
```sql
-- DDL操作
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- 并发UPDATE行为
UPDATE users SET name = 'John' WHERE id = 1;
```

**影响分析**：
- ✅ **执行阶段**：UPDATE可以正常执行，性能几乎无影响
- ⚠️ **准备阶段**：短暂阻塞（通常<1秒）
- ⚠️ **提交阶段**：短暂阻塞（通常<1秒）

**删除列操作**：
```sql
-- DDL操作  
ALTER TABLE users DROP COLUMN email;

-- 并发UPDATE行为
UPDATE users SET name = 'John' WHERE id = 1;    -- 正常执行
UPDATE users SET email = 'new@email.com' WHERE id = 1;  -- 会出错
```

**影响分析**：
- ✅ **不涉及删除列的UPDATE**：可以正常执行
- ❌ **涉及删除列的UPDATE**：会返回"Column not found"错误

### 4.3 在线日志机制详解


**在线日志的作用**：
```
在线日志就像"变更记录本"：

DDL执行期间发生的UPDATE操作：
┌──────────────────────────────────┐
│ 原表：users                       │
│ UPDATE users SET name='A' WHERE id=1; │ ← 记录到在线日志
│ UPDATE users SET name='B' WHERE id=2; │ ← 记录到在线日志  
│ UPDATE users SET name='C' WHERE id=3; │ ← 记录到在线日志
└──────────────────────────────────┘

DDL完成后：
┌──────────────────────────────────┐
│ 新表：users (加了phone列)          │
│ 应用在线日志中的所有UPDATE变更      │ ← 保证数据一致性
└──────────────────────────────────┘
```

**在线日志的限制**：
- 📊 **空间限制**：由`innodb_online_alter_log_max_size`参数控制
- 📊 **默认大小**：128MB
- ⚠️ **超出限制**：DDL操作会失败并回滚

### 4.4 UPDATE操作的具体表现


**正常情况下的UPDATE执行**：
```sql
-- 监控Online DDL期间的UPDATE性能
SELECT 
    thread_id,
    event_name,
    sql_text,
    timer_wait/1000000000 as duration_seconds
FROM performance_schema.events_statements_history 
WHERE sql_text LIKE '%UPDATE%'
AND event_name = 'statement/sql/update'
ORDER BY timer_start DESC
LIMIT 10;
```

**性能对比数据**：
| 场景 | 平均响应时间 | CPU使用率 | 内存使用 |
|------|-------------|-----------|----------|
| **无DDL时的UPDATE** | 5ms | 正常 | 正常 |
| **Online DDL期间UPDATE** | 8ms | +20% | +10% |
| **传统DDL期间** | 超时/阻塞 | 很高 | 很高 |

---

## 5. 📊 实际影响场景分析


### 5.1 高并发UPDATE场景


**场景描述**：电商系统在促销期间，需要给商品表添加"折扣率"字段，同时有大量订单在更新商品库存。

```sql
-- 业务背景
-- 商品表：1000万行数据
-- 并发UPDATE：每秒1000次库存更新
-- DDL需求：添加discount_rate列

-- DDL操作
ALTER TABLE products ADD COLUMN discount_rate DECIMAL(3,2) DEFAULT 0.00;

-- 并发UPDATE操作
UPDATE products SET stock = stock - 1 WHERE product_id = 12345;
UPDATE products SET stock = stock - 2 WHERE product_id = 12346;
-- ... 每秒1000次类似操作
```

**影响分析**：
```
时间轴分析：

T0: 开始执行ALTER TABLE
    ├─ 准备阶段 (0-2秒)
    │  └─ UPDATE操作阻塞约1.5秒
    ├─ 执行阶段 (2-300秒) 
    │  └─ UPDATE操作正常执行，轻微性能下降
    └─ 提交阶段 (300-302秒)
       └─ UPDATE操作阻塞约1秒

总体影响：
- 阻塞时间：约2.5秒
- 性能影响：执行阶段响应时间增加20%
- 业务影响：可接受范围内
```

### 5.2 长事务影响场景


**场景描述**：数据分析任务正在执行长时间的UPDATE操作，同时需要进行表结构调整。

```sql
-- 长事务UPDATE（可能运行10分钟）
START TRANSACTION;
UPDATE large_table SET status = 'processed' 
WHERE create_time < '2024-01-01' 
AND status = 'pending';
-- 影响500万行数据，需要10分钟

-- 同时执行DDL
ALTER TABLE large_table ADD INDEX idx_status (status);
```

**问题分析**：
```
冲突情况：
┌─────────────────────────────────┐
│ 长事务UPDATE持有MDL_SHARED_WRITE  │
│ 时间：0分钟 → 10分钟             │
└─────────────────────────────────┘
           ↓ 冲突
┌─────────────────────────────────┐  
│ ALTER需要MDL_EXCLUSIVE           │
│ 等待：从第3分钟开始等待           │
│ 超时：等待到lock_wait_timeout    │
└─────────────────────────────────┘

结果：
- DDL操作超时失败
- 长事务继续执行不受影响
- 其他短UPDATE被DDL阻塞
```

### 5.3 批量UPDATE场景


**场景描述**：系统升级时需要批量更新用户数据，同时要添加新的索引。

```sql
-- 批量UPDATE操作
UPDATE users SET last_login = NOW() 
WHERE last_login < '2024-01-01';
-- 影响100万用户数据

-- 同时添加索引
ALTER TABLE users ADD INDEX idx_last_login (last_login);
```

**优化策略**：
```sql
-- 方案1：分批执行UPDATE，避免长事务
DELIMITER //
CREATE PROCEDURE batch_update()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE batch_size INT DEFAULT 10000;
    
    WHILE done = 0 DO
        UPDATE users SET last_login = NOW() 
        WHERE last_login < '2024-01-01' 
        LIMIT batch_size;
        
        IF ROW_COUNT() = 0 THEN
            SET done = 1;
        END IF;
        
        -- 给DDL机会执行
        DO SLEEP(0.1);
    END WHILE;
END //
DELIMITER ;

-- 方案2：错峰执行
-- 先完成DDL，再执行批量UPDATE
-- 或者在业务低峰期执行
```

---

## 6. 🛠️ 优化策略与最佳实践


### 6.1 DDL操作时机选择


**最佳执行时间窗口**：
```
业务流量分析：
     高峰期        低峰期       高峰期
  ┌──────────┐              ┌──────────┐
  │          │              │          │
──┤ 避免DDL  ├──────────────┤ 避免DDL  ├──
  │          │   推荐DDL    │          │
  └──────────┘              └──────────┘
   8:00-12:00   12:00-14:00  14:00-18:00

最佳实践：
✅ 业务低峰期执行（如凌晨2-6点）
✅ 节假日或周末执行
✅ 维护窗口期执行
❌ 避免业务高峰期执行
❌ 避免重要活动期间执行
```

### 6.2 UPDATE操作优化策略


**减少MDL锁冲突的UPDATE写法**：
```sql
-- 不推荐：长时间持有锁的写法
START TRANSACTION;
UPDATE users SET status = 'active' WHERE create_time < '2024-01-01';
-- 可能影响百万行数据，持锁时间长
COMMIT;

-- 推荐：分批处理的写法
DELIMITER //
CREATE PROCEDURE optimized_update()
BEGIN
    DECLARE batch_count INT;
    
    REPEAT
        START TRANSACTION;
        UPDATE users SET status = 'active' 
        WHERE create_time < '2024-01-01' 
        AND status != 'active'
        LIMIT 1000;
        
        SET batch_count = ROW_COUNT();
        COMMIT;
        
        -- 释放锁，给DDL机会
        DO SLEEP(0.01);
    UNTIL batch_count = 0 END REPEAT;
END //
DELIMITER ;
```

**UPDATE语句优化技巧**：
```sql
-- 优化1：使用索引覆盖
-- 确保WHERE条件能使用索引
UPDATE users SET last_login = NOW() 
WHERE user_id = 12345;  -- user_id有索引

-- 优化2：避免全表扫描  
-- 不推荐
UPDATE users SET status = 'inactive' 
WHERE YEAR(create_time) = 2023;

-- 推荐
UPDATE users SET status = 'inactive'
WHERE create_time >= '2023-01-01' 
AND create_time < '2024-01-01';

-- 优化3：减少锁定范围
UPDATE users SET name = 'John' 
WHERE id = 1 
LIMIT 1;  -- 明确指定LIMIT
```

### 6.3 监控和预警机制


**MDL锁监控查询**：
```sql
-- 监控当前MDL锁等待情况
SELECT 
    p.id as connection_id,
    p.user,
    p.host,
    p.db,
    p.command,
    p.time as duration_seconds,
    p.state,
    p.info as current_query
FROM information_schema.processlist p
WHERE p.state LIKE '%Waiting for table metadata lock%'
ORDER BY p.time DESC;

-- 监控长时间运行的事务
SELECT 
    trx_id,
    trx_mysql_thread_id,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_seconds,
    trx_query
FROM information_schema.innodb_trx 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 30
ORDER BY trx_started;
```

**自动化监控脚本**：
```bash
#!/bin/bash
# MDL锁监控脚本

MYSQL_CMD="mysql -u monitor -p'password' -h localhost"

# 检查MDL锁等待
MDL_WAIT_COUNT=$(${MYSQL_CMD} -e "
SELECT COUNT(*) as cnt 
FROM information_schema.processlist 
WHERE state LIKE '%metadata lock%';" | tail -1)

if [ ${MDL_WAIT_COUNT} -gt 5 ]; then
    echo "警告：发现${MDL_WAIT_COUNT}个MDL锁等待"
    # 发送告警通知
fi

# 检查长事务
LONG_TRX_COUNT=$(${MYSQL_CMD} -e "
SELECT COUNT(*) as cnt 
FROM information_schema.innodb_trx 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300;" | tail -1)

if [ ${LONG_TRX_COUNT} -gt 0 ]; then
    echo "警告：发现${LONG_TRX_COUNT}个长事务"
fi
```

### 6.4 应急处理方案


**DDL阻塞时的处理步骤**：
```sql
-- 步骤1：识别阻塞的DDL
SHOW PROCESSLIST;
-- 找到State为"Waiting for table metadata lock"的DDL

-- 步骤2：找到持锁的事务
SELECT 
    trx_mysql_thread_id,
    trx_query,
    trx_started
FROM information_schema.innodb_trx;

-- 步骤3：评估是否可以终止长事务
-- 如果是不重要的查询，可以考虑终止
KILL CONNECTION [thread_id];

-- 步骤4：如果无法终止，考虑取消DDL
-- Ctrl+C 或者 KILL QUERY [ddl_thread_id]
```

**UPDATE阻塞时的处理方案**：
```sql
-- 方案1：调整UPDATE为小批量执行
-- 将大的UPDATE拆分成多个小事务

-- 方案2：错峰执行
-- 等待DDL完成后再执行UPDATE

-- 方案3：使用pt-online-schema-change工具
-- 对于大表的复杂DDL操作
pt-online-schema-change \
  --alter "ADD COLUMN phone VARCHAR(20)" \
  --execute \
  h=localhost,D=mydb,t=users
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Online DDL：MySQL 5.6+支持的在线表结构变更技术
🔸 元数据锁MDL：保护表结构一致性的锁机制
🔸 三阶段执行：准备→执行→提交的DDL执行模型
🔸 在线日志：记录DDL期间DML变更的临时存储
🔸 锁兼容性：不同操作间的锁冲突和兼容关系
🔸 并发控制：通过锁机制保证DDL和DML的并发安全
```

### 7.2 关键理解要点


**🔹 为什么需要MDL锁**
```
数据库就像一个正在装修的房子：
- MDL锁是"装修许可证"，确保装修时房客安全
- DDL是"装修工人"，需要排他性地修改房屋结构  
- UPDATE是"房客活动"，需要在稳定的房屋结构中进行
- 没有MDL锁，就可能出现"墙壁拆了一半，房客还在用电"的危险情况
```

**🔹 Online DDL的本质**
```
Online DDL像"边营业边装修"：
- 准备阶段：短暂停业，做装修准备（获取排他锁）
- 执行阶段：正常营业，后台装修（允许并发操作）
- 提交阶段：短暂停业，完成装修收尾（再次获取排他锁）
总体效果：最小化对业务的影响
```

**🔹 UPDATE在DDL期间的表现**
```
UPDATE的三种状态：
- 正常执行：DDL执行阶段，UPDATE几乎无感知
- 短暂等待：DDL准备和提交阶段，等待数秒
- 长时间阻塞：遇到不支持Online的DDL操作
```

### 7.3 实际应用价值


**🎯 生产环境决策指导**
- 📍 **DDL时机选择**：业务低峰期执行，避免影响用户体验
- 📍 **操作类型评估**：优先选择支持Online的DDL操作类型
- 📍 **风险控制**：设置合理的锁等待超时时间
- 📍 **应急预案**：准备DDL阻塞时的处理方案

**🎯 性能优化实践**  
- 📍 **UPDATE优化**：使用小批量事务，避免长时间持锁
- 📍 **监控告警**：实时监控MDL锁等待和长事务
- 📍 **工具选择**：对于超大表使用pt-online-schema-change
- 📍 **测试验证**：在测试环境验证DDL对业务的影响

**🎯 故障排查能力**
- 📍 **识别问题**：快速定位DDL和UPDATE的冲突点
- 📍 **分析原因**：理解锁等待的根本原因  
- 📍 **解决方案**：选择合适的处理策略
- 📍 **预防措施**：建立完善的变更流程

### 7.4 注意事项和限制


**⚠️ Online DDL的限制**
- 🚨 **在线日志空间**：超出限制会导致DDL失败
- 🚨 **操作类型限制**：不是所有DDL都支持Online执行
- 🚨 **版本依赖**：MySQL版本影响Online DDL支持范围
- 🚨 **存储引擎限制**：主要支持InnoDB，MyISAM支持有限

**⚠️ 性能考虑**
- 🚨 **资源消耗**：DDL期间会增加CPU和内存使用
- 🚨 **磁盘空间**：临时文件可能占用额外存储空间
- 🚨 **网络延迟**：主从复制延迟可能增加
- 🚨 **并发性能**：DML操作响应时间可能轻微增加

**核心记忆口诀**：
```
Online DDL三阶段，准备提交短阻塞
执行阶段可并发，UPDATE基本无感知  
MDL锁保护结构稳，长事务避免冲突
监控预警要及时，错峰执行最稳妥
```