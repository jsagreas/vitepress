---
title: 18、Oracle到MySQL迁移实践
---
## 📚 目录

1. [Oracle到MySQL迁移概述](#1-Oracle到MySQL迁移概述)
2. [Oracle数据类型映射详解](#2-Oracle数据类型映射详解)
3. [Oracle SQL语法转换](#3-Oracle-SQL语法转换)
4. [Oracle存储过程迁移](#4-Oracle存储过程迁移)
5. [Oracle迁移常见问题处理](#5-Oracle迁移常见问题处理)
6. [迁移工具与最佳实践](#6-迁移工具与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔄 Oracle到MySQL迁移概述


### 1.1 为什么要从Oracle迁移到MySQL


> 💡 **迁移动机**  
> 企业选择从Oracle迁移到MySQL主要出于成本控制、开源生态和云原生需求的考虑

**🔸 主要驱动因素**
```
成本因素：
• Oracle许可费用昂贵（按CPU核心收费）
• MySQL开源免费，大幅降低IT成本
• 云厂商MySQL服务成本更低

技术因素：
• MySQL生态更开放，社区活跃
• 云原生支持更好
• 与现代开发栈集成度高

业务因素：
• 避免厂商绑定
• 提高技术栈灵活性
• 符合数字化转型趋势
```

### 1.2 迁移面临的核心挑战


**⚠️ 主要技术挑战**

| 挑战类型 | **Oracle特性** | **MySQL对应** | **影响程度** |
|---------|---------------|--------------|-------------|
| 🔤 **数据类型** | `NUMBER, CLOB, BLOB` | `DECIMAL, TEXT, LONGBLOB` | `高` |
| 📝 **SQL语法** | `ROWNUM, (+)连接, DECODE` | `LIMIT, LEFT JOIN, CASE` | `中` |
| 🔧 **存储过程** | `PL/SQL语法丰富` | `MySQL存储过程语法简单` | `高` |
| 🎯 **事务特性** | `读一致性, 回滚段` | `MVCC机制不同` | `中` |
| 📊 **性能优化** | `Hint, 执行计划` | `索引策略不同` | `高` |

### 1.3 迁移基本流程


```
Oracle迁移到MySQL标准流程：

第一阶段：评估分析
┌─────────────────────┐
│ 1. 数据库结构分析    │ ← 表结构、索引、约束
├─────────────────────┤
│ 2. 应用代码审计      │ ← SQL语句、存储过程
├─────────────────────┤  
│ 3. 数据量评估        │ ← 数据大小、迁移时间
├─────────────────────┤
│ 4. 风险点识别        │ ← 兼容性问题梳理
└─────────────────────┘

第二阶段：方案设计
┌─────────────────────┐
│ 1. 数据类型映射      │ ← 制定转换规则
├─────────────────────┤
│ 2. SQL语法改写       │ ← 语法兼容性处理
├─────────────────────┤
│ 3. 存储过程重写      │ ← PL/SQL转MySQL
├─────────────────────┤
│ 4. 迁移工具选择      │ ← 自动化工具评估
└─────────────────────┘

第三阶段：实施迁移
┌─────────────────────┐
│ 1. 测试环境验证      │ ← 小规模验证
├─────────────────────┤
│ 2. 数据迁移执行      │ ← 批量数据转移
├─────────────────────┤
│ 3. 应用改造部署      │ ← 代码适配上线
├─────────────────────┤
│ 4. 性能调优验证      │ ← 性能对比优化
└─────────────────────┘
```

---

## 2. 🔄 Oracle数据类型映射详解


### 2.1 数值类型映射


> 📖 **概念说明**  
> Oracle和MySQL在数值类型上差异较大，需要仔细映射以避免精度丢失和溢出问题

**🔸 整数类型映射**

| Oracle类型 | **取值范围** | **MySQL映射** | **说明** |
|-----------|-------------|--------------|---------|
| `NUMBER(p)` | `p位整数` | `BIGINT` | `通用整数映射` |
| `NUMBER(1)` | `0-9` | `TINYINT` | `单位数字` |
| `NUMBER(3)` | `-999~999` | `SMALLINT` | `小整数` |
| `NUMBER(5)` | `-99999~99999` | `INT` | `标准整数` |
| `NUMBER(10)` | `10位整数` | `BIGINT` | `大整数` |

**🔸 小数类型映射**

```sql
-- Oracle数值类型示例
Oracle: NUMBER(10,2)    -- 总长度10位，小数2位
MySQL:  DECIMAL(10,2)   -- 精确对应

Oracle: NUMBER          -- 无限制精度
MySQL:  DECIMAL(65,10)  -- MySQL最大精度

Oracle: FLOAT           -- 浮点数
MySQL:  DOUBLE          -- 双精度浮点
```

**💡 映射要点**
```
精度保持：
• NUMBER类型要映射为DECIMAL，不要用FLOAT
• FLOAT/DOUBLE可能有精度误差
• 金融数据必须使用DECIMAL

范围检查：
• Oracle NUMBER范围更大，MySQL可能溢出
• 建议迁移前检查数据最大最小值
• 必要时调整MySQL字段长度
```

### 2.2 字符类型映射


**🔸 定长字符类型**

| Oracle类型 | **最大长度** | **MySQL映射** | **注意事项** |
|-----------|-------------|--------------|-------------|
| `CHAR(n)` | `2000字节` | `CHAR(n)` | `长度相同，注意字符集` |
| `NCHAR(n)` | `1000字符` | `CHAR(n) CHARACTER SET utf8mb4` | `Unicode字符` |

**🔸 变长字符类型**

```sql
-- Oracle字符类型映射
Oracle: VARCHAR2(4000)     → MySQL: VARCHAR(4000)
Oracle: NVARCHAR2(2000)    → MySQL: VARCHAR(2000) CHARACTER SET utf8mb4
Oracle: LONG               → MySQL: LONGTEXT

-- 大文本类型映射
Oracle: CLOB               → MySQL: LONGTEXT
Oracle: NCLOB              → MySQL: LONGTEXT CHARACTER SET utf8mb4
```

**⚠️ 字符集注意事项**
```
Oracle字符集：
• 支持多种字符集（GBK、UTF8等）
• NCHAR/NVARCHAR2专门存储Unicode

MySQL字符集：
• utf8：最多3字节，不支持emoji
• utf8mb4：最多4字节，完整Unicode支持
• 迁移建议统一使用utf8mb4

迁移实践：
ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

### 2.3 日期时间类型映射


**🔸 日期时间类型对照**

| Oracle类型 | **存储内容** | **MySQL映射** | **转换说明** |
|-----------|-------------|--------------|-------------|
| `DATE` | `日期+时间` | `DATETIME` | `Oracle DATE包含时间` |
| `TIMESTAMP` | `精确时间戳` | `TIMESTAMP` | `时区处理需注意` |
| `TIMESTAMP WITH TIME ZONE` | `带时区时间戳` | `TIMESTAMP` | `需要时区转换` |

**💡 日期迁移示例**
```sql
-- Oracle日期查询
SELECT TO_CHAR(order_date, 'YYYY-MM-DD HH24:MI:SS') FROM orders;

-- MySQL对应查询
SELECT DATE_FORMAT(order_date, '%Y-%m-%d %H:%i:%s') FROM orders;

-- Oracle日期比较
WHERE order_date >= DATE '2024-01-01'

-- MySQL对应
WHERE order_date >= '2024-01-01 00:00:00'
```

### 2.4 二进制类型映射


**🔸 二进制大对象映射**

```sql
-- Oracle二进制类型
Oracle: BLOB               → MySQL: LONGBLOB
Oracle: RAW(2000)          → MySQL: VARBINARY(2000)
Oracle: LONG RAW           → MySQL: LONGBLOB

-- 实际迁移示例
-- Oracle表结构
CREATE TABLE documents (
    id NUMBER PRIMARY KEY,
    content BLOB,
    thumbnail RAW(1000)
);

-- MySQL对应结构
CREATE TABLE documents (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    content LONGBLOB,
    thumbnail VARBINARY(1000)
);
```

### 2.5 特殊类型处理


**🔸 Oracle特有类型**

```sql
-- Oracle特殊类型及处理方案
Oracle: ROWID              → MySQL: 删除或用AUTO_INCREMENT替代
Oracle: UROWID             → MySQL: 删除或用AUTO_INCREMENT替代
Oracle: XMLType            → MySQL: JSON或TEXT
Oracle: INTERVAL           → MySQL: 用数值类型存储秒数

-- XMLType迁移示例
-- Oracle
xml_data XMLType

-- MySQL方案1：使用JSON
xml_data JSON

-- MySQL方案2：使用TEXT
xml_data TEXT
```

---

## 3. 🔄 Oracle SQL语法转换


### 3.1 分页查询语法转换


> 💡 **核心差异**  
> Oracle使用ROWNUM进行分页，MySQL使用LIMIT语法，两者逻辑完全不同

**🔸 分页语法对比**

```sql
-- Oracle分页查询（复杂但功能强大）
-- 查询第11-20条记录
SELECT * FROM (
    SELECT t.*, ROWNUM rn FROM (
        SELECT * FROM employees ORDER BY salary DESC
    ) t WHERE ROWNUM <= 20
) WHERE rn > 10;

-- MySQL分页查询（简洁直观）
-- 查询第11-20条记录
SELECT * FROM employees 
ORDER BY salary DESC 
LIMIT 10, 10;  -- 跳过10条，取10条
```

**📊 分页语法转换规则**

| Oracle模式 | **MySQL等价写法** | **性能对比** |
|-----------|------------------|-------------|
| `ROWNUM <= n` | `LIMIT n` | `MySQL更高效` |
| `ROWNUM BETWEEN m AND n` | `LIMIT m-1, n-m+1` | `MySQL语法更简洁` |
| `ROW_NUMBER() OVER()` | `LIMIT + OFFSET` | `功能相当` |

### 3.2 外连接语法转换


**🔸 Oracle外连接特殊语法**

```sql
-- Oracle独有的(+)外连接语法
-- 左外连接
SELECT e.name, d.dept_name
FROM employees e, departments d
WHERE e.dept_id = d.dept_id(+);

-- MySQL标准外连接语法
SELECT e.name, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

-- Oracle右外连接
SELECT e.name, d.dept_name  
FROM employees e, departments d
WHERE e.dept_id(+) = d.dept_id;

-- MySQL对应
SELECT e.name, d.dept_name
FROM employees e  
RIGHT JOIN departments d ON e.dept_id = d.dept_id;
```

### 3.3 字符串函数转换


**🔸 常用字符串函数映射**

| Oracle函数 | **MySQL函数** | **功能说明** | **示例转换** |
|-----------|--------------|-------------|-------------|
| `SUBSTR` | `SUBSTRING` | `子串提取` | `SUBSTR(str,1,5)` → `SUBSTRING(str,1,5)` |
| `LENGTH` | `CHAR_LENGTH` | `字符长度` | `LENGTH(str)` → `CHAR_LENGTH(str)` |
| `INSTR` | `LOCATE` | `查找位置` | `INSTR(str,'x')` → `LOCATE('x',str)` |
| `DECODE` | `CASE WHEN` | `条件选择` | 见下方详细示例 |

**💻 DECODE函数转换详解**
```sql
-- Oracle DECODE语法（类似switch语句）
SELECT name, 
       DECODE(status, 1, '激活', 2, '禁用', 3, '待审核', '未知') as status_name
FROM users;

-- MySQL CASE WHEN语法
SELECT name,
       CASE status
           WHEN 1 THEN '激活'
           WHEN 2 THEN '禁用' 
           WHEN 3 THEN '待审核'
           ELSE '未知'
       END as status_name
FROM users;

-- 复杂DECODE转换
-- Oracle
DECODE(SIGN(salary - 5000), 1, '高薪', 0, '标准', -1, '低薪')

-- MySQL  
CASE 
    WHEN salary > 5000 THEN '高薪'
    WHEN salary = 5000 THEN '标准'
    WHEN salary < 5000 THEN '低薪'
END
```

### 3.4 日期函数转换


**🔸 日期处理函数映射**

```sql
-- Oracle日期函数转换示例

-- 1. 日期格式化
Oracle: TO_CHAR(order_date, 'YYYY-MM-DD')
MySQL:  DATE_FORMAT(order_date, '%Y-%m-%d')

-- 2. 字符串转日期
Oracle: TO_DATE('2024-01-01', 'YYYY-MM-DD')  
MySQL:  STR_TO_DATE('2024-01-01', '%Y-%m-%d')

-- 3. 日期计算
Oracle: order_date + 30                    -- 加30天
MySQL:  DATE_ADD(order_date, INTERVAL 30 DAY)

Oracle: ADD_MONTHS(order_date, 3)          -- 加3个月
MySQL:  DATE_ADD(order_date, INTERVAL 3 MONTH)

-- 4. 系统时间
Oracle: SYSDATE                            -- 当前时间
MySQL:  NOW()

Oracle: SYSTIMESTAMP                       -- 精确时间戳
MySQL:  NOW(6)                            -- 6位微秒精度
```

### 3.5 聚合查询转换


**🔸 分组统计语法差异**

```sql
-- Oracle分组查询示例
SELECT dept_id, 
       COUNT(*) as emp_count,
       AVG(salary) as avg_salary,
       RANK() OVER (ORDER BY AVG(salary) DESC) as salary_rank
FROM employees 
GROUP BY dept_id
HAVING COUNT(*) > 5;

-- MySQL对应（基本相同，但某些函数可能不支持）
SELECT dept_id,
       COUNT(*) as emp_count, 
       AVG(salary) as avg_salary,
       RANK() OVER (ORDER BY AVG(salary) DESC) as salary_rank
FROM employees
GROUP BY dept_id  
HAVING COUNT(*) > 5;

-- Oracle特有的CONNECT BY递归查询
-- Oracle
SELECT name, level
FROM employees  
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;

-- MySQL替代方案（使用WITH RECURSIVE）
WITH RECURSIVE emp_hierarchy AS (
    -- 锚点：顶级员工
    SELECT employee_id, name, manager_id, 1 as level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- 递归：下级员工  
    SELECT e.employee_id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    JOIN emp_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT name, level FROM emp_hierarchy;
```

---

## 4. 🛠️ Oracle存储过程迁移


### 4.1 存储过程语法差异


> 📖 **关键概念**  
> Oracle的PL/SQL是功能强大的编程语言，而MySQL的存储过程语法相对简单，迁移时需要重新设计逻辑

**🔸 基本语法对比**

```sql
-- Oracle PL/SQL存储过程
CREATE OR REPLACE PROCEDURE update_salary(
    p_emp_id IN NUMBER,
    p_percentage IN NUMBER
) IS
    v_current_salary NUMBER;
    v_new_salary NUMBER;
BEGIN
    -- 查询当前薪资
    SELECT salary INTO v_current_salary  
    FROM employees 
    WHERE employee_id = p_emp_id;
    
    -- 计算新薪资
    v_new_salary := v_current_salary * (1 + p_percentage/100);
    
    -- 更新薪资
    UPDATE employees 
    SET salary = v_new_salary 
    WHERE employee_id = p_emp_id;
    
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, '员工不存在');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
```

```sql
-- MySQL对应存储过程
DELIMITER //
CREATE PROCEDURE update_salary(
    IN p_emp_id INT,
    IN p_percentage DECIMAL(5,2)
)
BEGIN
    DECLARE v_current_salary DECIMAL(10,2);
    DECLARE v_new_salary DECIMAL(10,2);
    DECLARE v_count INT DEFAULT 0;
    
    -- 声明异常处理
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_count = 0;
    
    -- 检查员工是否存在
    SELECT COUNT(*) INTO v_count FROM employees WHERE employee_id = p_emp_id;
    
    IF v_count = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '员工不存在';
    END IF;
    
    -- 查询当前薪资
    SELECT salary INTO v_current_salary 
    FROM employees 
    WHERE employee_id = p_emp_id;
    
    -- 计算新薪资
    SET v_new_salary = v_current_salary * (1 + p_percentage/100);
    
    -- 更新薪资
    UPDATE employees 
    SET salary = v_new_salary 
    WHERE employee_id = p_emp_id;
    
END//
DELIMITER ;
```

### 4.2 异常处理转换


**🔸 异常处理机制对比**

```sql
-- Oracle异常处理（功能强大）
BEGIN
    -- 业务逻辑
    UPDATE employees SET salary = salary * 1.1;
    
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20002, '唯一约束冲突');
    WHEN NO_DATA_FOUND THEN  
        RAISE_APPLICATION_ERROR(-20001, '未找到数据');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20999, '未知错误: ' || SQLERRM);
END;

-- MySQL异常处理（相对简单）
BEGIN
    DECLARE EXIT HANDLER FOR 1062  -- 重复键错误
    BEGIN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '唯一约束冲突';
    END;
    
    DECLARE EXIT HANDLER FOR NOT FOUND
    BEGIN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '未找到数据';
    END;
    
    -- 业务逻辑
    UPDATE employees SET salary = salary * 1.1;
    
END;
```

### 4.3 游标处理转换


**🔸 游标使用对比**

```sql
-- Oracle游标处理
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, salary FROM employees WHERE dept_id = 10;
    
    v_emp_id employees.employee_id%TYPE;
    v_salary employees.salary%TYPE;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_emp_id, v_salary;
        EXIT WHEN emp_cursor%NOTFOUND;
        
        -- 处理每行数据
        UPDATE employees 
        SET salary = v_salary * 1.1 
        WHERE employee_id = v_emp_id;
    END LOOP;
    CLOSE emp_cursor;
END;

-- MySQL游标处理
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_emp_id INT;
    DECLARE v_salary DECIMAL(10,2);
    
    -- 声明游标
    DECLARE emp_cursor CURSOR FOR
        SELECT employee_id, salary FROM employees WHERE dept_id = 10;
    
    -- 声明结束标志
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN emp_cursor;
    
    read_loop: LOOP
        FETCH emp_cursor INTO v_emp_id, v_salary;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 处理每行数据
        UPDATE employees 
        SET salary = v_salary * 1.1 
        WHERE employee_id = v_emp_id;
    END LOOP;
    
    CLOSE emp_cursor;
END;
```

### 4.4 函数迁移转换


**🔸 存储函数语法差异**

```sql
-- Oracle函数
CREATE OR REPLACE FUNCTION get_dept_name(p_dept_id NUMBER)
RETURN VARCHAR2
IS
    v_dept_name departments.department_name%TYPE;
BEGIN
    SELECT department_name INTO v_dept_name
    FROM departments
    WHERE department_id = p_dept_id;
    
    RETURN v_dept_name;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN '未知部门';
END;

-- MySQL函数
DELIMITER //
CREATE FUNCTION get_dept_name(p_dept_id INT)
RETURNS VARCHAR(100)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_dept_name VARCHAR(100);
    DECLARE v_count INT DEFAULT 0;
    
    SELECT COUNT(*) INTO v_count 
    FROM departments 
    WHERE department_id = p_dept_id;
    
    IF v_count = 0 THEN
        RETURN '未知部门';
    END IF;
    
    SELECT department_name INTO v_dept_name
    FROM departments  
    WHERE department_id = p_dept_id;
    
    RETURN v_dept_name;
END//
DELIMITER ;
```

---

## 5. ⚠️ Oracle迁移常见问题处理


### 5.1 字符串连接问题


**🔸 字符串拼接语法差异**

```sql
-- Oracle字符串连接（使用||操作符）
SELECT first_name || ' ' || last_name as full_name
FROM employees;

-- Oracle NULL值处理
SELECT first_name || NVL(middle_name, '') || last_name as full_name  
FROM employees;

-- MySQL字符串连接（使用CONCAT函数）
SELECT CONCAT(first_name, ' ', last_name) as full_name
FROM employees;

-- MySQL NULL值处理（CONCAT遇到NULL返回NULL）
SELECT CONCAT(first_name, IFNULL(middle_name, ''), last_name) as full_name
FROM employees;

-- 或者使用CONCAT_WS（遇到NULL自动忽略）
SELECT CONCAT_WS(' ', first_name, middle_name, last_name) as full_name
FROM employees;
```

### 5.2 自增序列问题


**🔸 Oracle序列 vs MySQL自增**

```sql
-- Oracle序列机制
-- 1. 创建序列
CREATE SEQUENCE emp_seq
    START WITH 1
    INCREMENT BY 1
    NOCACHE;

-- 2. 使用序列
INSERT INTO employees (employee_id, name) 
VALUES (emp_seq.NEXTVAL, 'John');

-- 3. 查询下一个值
SELECT emp_seq.NEXTVAL FROM DUAL;

-- MySQL自增机制（更简单）
-- 1. 创建自增表
CREATE TABLE employees (
    employee_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100)
);

-- 2. 插入数据（自动生成ID）
INSERT INTO employees (name) VALUES ('John');

-- 3. 获取最后插入的ID
SELECT LAST_INSERT_ID();
```

**⚠️ 序列迁移注意事项**
```
迁移策略：
1. 将Oracle序列改为MySQL AUTO_INCREMENT
2. 确保初始值设置正确：
   ALTER TABLE employees AUTO_INCREMENT = 1001;
3. 应用代码中删除序列引用
4. 使用LAST_INSERT_ID()获取新生成的ID

潜在问题：
• 批量插入时ID获取方式不同
• 分布式环境下ID生成策略需调整
• 某些应用可能依赖序列的特定行为
```

### 5.3 事务隔离级别差异


**🔸 事务行为差异**

| 特性 | **Oracle默认** | **MySQL默认** | **迁移影响** |
|------|---------------|--------------|-------------|
| 🔒 **隔离级别** | `READ COMMITTED` | `REPEATABLE READ` | `幻读行为不同` |
| 📖 **读一致性** | `语句级读一致性` | `事务级读一致性` | `查询结果可能不同` |
| ↩️ **回滚机制** | `自动回滚段` | `undo log` | `性能特征不同` |
| 🔐 **锁机制** | `行级锁+多版本` | `行级锁+间隙锁` | `并发行为差异` |

```sql
-- Oracle读一致性示例
-- 会话1
UPDATE employees SET salary = 6000 WHERE id = 1;
-- 未提交

-- 会话2（Oracle会看到更新前的数据）
SELECT salary FROM employees WHERE id = 1;  -- 返回原值5000

-- MySQL在REPEATABLE READ下也是看到原值
-- 但具体实现机制不同
```

### 5.4 NULL值处理差异


**🔸 NULL值比较和处理**

```sql
-- Oracle NULL值处理
-- 1. 空字符串与NULL
Oracle: '' IS NULL          -- TRUE（Oracle中空字符串就是NULL）
MySQL:  '' IS NULL          -- FALSE（MySQL区分空字符串和NULL）

-- 2. NULL值函数
Oracle: NVL(column, 'default')           -- NULL值替换
MySQL:  IFNULL(column, 'default')        -- 对应函数

Oracle: NVL2(column, 'not_null', 'null') -- 根据NULL判断返回
MySQL:  IF(column IS NULL, 'null', 'not_null')  -- 对应写法

-- 3. 字符串连接NULL值
Oracle: 'Hello' || NULL     -- 返回 'Hello'
MySQL:  CONCAT('Hello', NULL)  -- 返回 NULL
```

### 5.5 性能优化迁移


**🔸 Oracle Hint vs MySQL优化**

```sql
-- Oracle使用Hint优化
SELECT /*+ INDEX(e, emp_name_idx) */ 
       name, salary
FROM employees e
WHERE name LIKE 'John%';

-- MySQL优化策略（不支持Hint，需要其他方法）
-- 1. 强制使用索引
SELECT name, salary
FROM employees FORCE INDEX (emp_name_idx)
WHERE name LIKE 'John%';

-- 2. 通过查询重写优化
-- 确保索引能被有效使用
SELECT name, salary  
FROM employees
WHERE name >= 'John' AND name < 'Joho'  -- 范围查询更高效
```

**📊 执行计划分析对比**

```sql
-- Oracle执行计划查看
EXPLAIN PLAN FOR SELECT * FROM employees WHERE dept_id = 10;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

-- MySQL执行计划查看  
EXPLAIN SELECT * FROM employees WHERE dept_id = 10;
-- 或者更详细的
EXPLAIN FORMAT=JSON SELECT * FROM employees WHERE dept_id = 10;
```

---

## 6. 🛠️ 迁移工具与最佳实践


### 6.1 主流迁移工具对比


**🔸 工具选择指南**

| 工具名称 | **适用场景** | **优势** | **劣势** |
|---------|-------------|---------|---------|
| 🔧 **MySQL Workbench** | `小型项目` | `图形界面，操作简单` | `功能有限，大数据性能差` |
| ⚡ **DTS工具** | `云环境迁移` | `阿里云等云厂商工具，自动化程度高` | `依赖云平台` |
| 🔄 **Kettle/PDI** | `复杂ETL需求` | `可视化流程，转换灵活` | `学习成本高` |
| 💻 **自定义脚本** | `特殊需求` | `完全可控，针对性强` | `开发成本高` |

### 6.2 数据迁移最佳实践


**🔸 分阶段迁移策略**

```
数据迁移三步走：

第一步：结构迁移
┌─────────────────────┐
│ 1. 表结构转换        │ ← DDL语句生成和执行
│ 2. 索引重建          │ ← 根据MySQL特点优化
│ 3. 约束条件迁移      │ ← 外键、检查约束等
│ 4. 视图和触发器      │ ← 语法适配改写
└─────────────────────┘

第二步：数据迁移  
┌─────────────────────┐
│ 1. 历史数据批量导入  │ ← 停机时间内完成
│ 2. 增量数据同步      │ ← 双写或binlog同步
│ 3. 数据一致性校验    │ ← 确保数据完整性
└─────────────────────┘

第三步：应用切换
┌─────────────────────┐  
│ 1. 应用代码改造      │ ← SQL语法适配
│ 2. 连接参数调整      │ ← 数据库连接配置
│ 3. 性能测试验证      │ ← 压力测试
│ 4. 监控告警配置      │ ← 运维体系建立
└─────────────────────┘
```

### 6.3 迁移验证方法


**🔍 数据一致性校验**

```sql
-- 1. 记录数量对比
-- Oracle
SELECT COUNT(*) FROM employees;

-- MySQL  
SELECT COUNT(*) FROM employees;

-- 2. 数据抽样对比
-- Oracle
SELECT * FROM employees WHERE ROWNUM <= 100 ORDER BY employee_id;

-- MySQL
SELECT * FROM employees ORDER BY employee_id LIMIT 100;

-- 3. 关键字段校验
-- 检查关键业务字段的数值分布
SELECT 
    MIN(salary) as min_salary,
    MAX(salary) as max_salary, 
    AVG(salary) as avg_salary,
    COUNT(DISTINCT dept_id) as dept_count
FROM employees;
```

**⚡ 性能对比测试**

```sql
-- 典型查询性能测试
-- 1. 单表查询
SELECT * FROM employees WHERE dept_id = 10;

-- 2. 关联查询  
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- 3. 聚合查询
SELECT dept_id, COUNT(*), AVG(salary)
FROM employees  
GROUP BY dept_id;

-- 分别在Oracle和MySQL上执行，对比：
-- • 执行时间
-- • CPU使用率  
-- • 内存消耗
-- • IO操作次数
```

### 6.4 回滚预案


**🔙 迁移失败回滚策略**

```
回滚准备清单：

数据备份：
✅ Oracle完整数据备份
✅ 迁移前应用代码备份  
✅ 配置文件备份
✅ 数据库连接信息备份

快速切换方案：
✅ 负载均衡器配置快速切换
✅ DNS记录快速修改
✅ 应用配置热更新
✅ 数据库连接池快速重配

验证机制：
✅ 关键业务功能验证脚本
✅ 数据一致性检查脚本
✅ 性能基准对比工具
✅ 用户访问监控
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的迁移要点


> 🎯 **核心理念**  
> Oracle到MySQL迁移不是简单的数据复制，而是一次技术栈的升级改造

**🔸 关键成功因素**
```
📊 充分的前期评估：
• 详细分析现有Oracle使用情况
• 识别所有兼容性问题点
• 制定详细的迁移计划

🛠️ 完善的工具支持：
• 选择合适的迁移工具
• 开发必要的自定义脚本
• 建立完整的测试环境

👥 团队技能准备：
• 培训团队MySQL知识
• 建立MySQL运维能力
• 制定应急处理预案
```

### 7.2 数据类型映射核心原则


```
🔸 精度优先：数值类型优先保证精度，避免使用FLOAT
🔸 字符集统一：统一使用utf8mb4字符集
🔸 日期格式标准化：统一使用DATETIME类型
🔸 二进制类型：根据数据大小选择合适的BLOB类型
🔸 特殊类型：Oracle特有类型需要业务逻辑配合改造
```

### 7.3 SQL语法转换要点


```
🔸 分页查询：ROWNUM → LIMIT语法
🔸 外连接：(+) → 标准JOIN语法  
🔸 字符串函数：SUBSTR/LENGTH/INSTR → 对应MySQL函数
🔸 条件选择：DECODE → CASE WHEN语法
🔸 日期处理：TO_CHAR/TO_DATE → DATE_FORMAT/STR_TO_DATE
🔸 递归查询：CONNECT BY → WITH RECURSIVE
```

### 7.4 存储过程迁移要点


```
🔸 语法适配：PL/SQL → MySQL存储过程语法
🔸 异常处理：Oracle异常 → MySQL HANDLER机制
🔸 游标处理：语法结构需要重新组织
🔸 函数迁移：返回值类型和异常处理机制调整
🔸 业务逻辑：复杂逻辑可能需要应用层实现
```

### 7.5 常见问题解决方案


**⚠️ 高频问题与解决**
```
字符串连接NULL问题：
• 问题：MySQL CONCAT遇到NULL返回NULL
• 解决：使用IFNULL或CONCAT_WS函数

分页性能问题：
• 问题：大偏移量LIMIT性能差
• 解决：使用基于索引的分页方案

字符集乱码问题：
• 问题：Oracle GBK到MySQL UTF8转换
• 解决：统一使用utf8mb4，数据导入前转换

序列依赖问题：
• 问题：应用代码大量使用Oracle序列
• 解决：改造为AUTO_INCREMENT或UUID方案
```

### 7.6 迁移成功的关键指标


**📈 迁移质量评估**
```
功能完整性：
✅ 所有业务功能正常运行
✅ 数据查询结果一致
✅ 报表统计数据准确

性能指标：
✅ 响应时间不超过原系统120%
✅ 并发处理能力不降低
✅ 存储空间使用合理

稳定性指标：
✅ 连续运行7天无故障
✅ 数据一致性校验通过
✅ 备份恢复机制正常
```

### 7.7 迁移后持续优化


**🚀 后续优化方向**
```
性能调优：
• 根据MySQL特点重新设计索引策略
• 调整数据库参数配置
• 优化慢查询

架构升级：
• 考虑读写分离架构
• 引入缓存层减轻数据库压力
• 微服务化改造

运维体系：
• 建立MySQL专业运维团队
• 完善监控告警体系
• 制定容灾备份策略
```

**🎯 长期价值实现**
- **成本节约**：大幅降低数据库许可成本
- **技术灵活性**：摆脱厂商绑定，提高架构自主性
- **云原生转型**：为容器化、微服务化打下基础
- **团队能力**：提升团队对开源技术栈的掌控力

**核心记忆口诀**：
```
Oracle迁移MySQL，规划先行是关键
数据类型要映射，SQL语法需转换  
存储过程重设计，常见问题早预案
工具选择要恰当，验证测试保平安
```