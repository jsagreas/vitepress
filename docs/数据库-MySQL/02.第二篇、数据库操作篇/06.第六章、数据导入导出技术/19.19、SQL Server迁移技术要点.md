---
title: 19、SQL Server迁移技术要点
---
## 📚 目录

1. [SQL Server迁移概述](#1-SQL-Server迁移概述)
2. [数据类型映射详解](#2-数据类型映射详解)
3. [SQL Server到MySQL迁移策略](#3-SQL-Server到MySQL迁移策略)
4. [T-SQL语法转换技巧](#4-T-SQL语法转换技巧)
5. [字符集处理方案](#5-字符集处理方案)
6. [迁移性能优化技巧](#6-迁移性能优化技巧)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚀 SQL Server迁移概述


### 1.1 什么是数据库迁移


> 💡 **一句话理解**：数据库迁移就像搬家，把数据从一个数据库"房子"搬到另一个数据库"房子"，但要保证东西不丢、不坏、还能正常使用。

**🔸 迁移的本质含义**
```
数据库迁移包含三个层面：
📊 数据迁移：把表中的数据完整转移过去
🏗️ 结构迁移：把表结构、索引、约束等重建
🔧 逻辑迁移：把存储过程、触发器、函数等转换
```

### 1.2 为什么要做SQL Server迁移


**💰 成本考虑**
```
SQL Server：商业许可，成本高昂
• Windows Server许可费
• SQL Server许可费 
• 维护和支持费用

MySQL：开源免费
• 社区版本完全免费
• 企业版本价格相对便宜
• 庞大的开源社区支持
```

**🌍 跨平台需求**
```
SQL Server限制：
• 主要运行在Windows平台
• Linux支持相对较新

MySQL优势：
• 支持Windows、Linux、macOS
• 云平台广泛支持
• 容器化部署友好
```

**📈 技术发展趋势**
```
互联网公司偏好：
• 大部分互联网公司使用MySQL
• 开源技术栈更受青睐
• 社区生态更加活跃

人才市场：
• MySQL技能需求更大
• 学习资源更丰富
• 职业发展机会更多
```

### 1.3 迁移面临的主要挑战


**🎯 核心挑战分析**
```
┌─ 迁移挑战地图 ────────────────────┐
│                                    │
│  数据类型差异 ←→ 语法不兼容        │
│       ↓              ↓             │
│  字符集问题 ←→ 性能差异            │
│       ↓              ↓             │
│  业务逻辑 ←→ 运维习惯              │
│                                    │
└────────────────────────────────────┘
```

---

## 2. 🔄 数据类型映射详解


### 2.1 数值类型映射


> **🤔 常见疑问**：为什么不能直接复制数据？
> **💡 答案**：就像不同国家的插头形状不同，不同数据库的数据类型"接口"也不一样，需要转换器。

**📊 数值类型对应关系**

| SQL Server类型 | MySQL对应类型 | **说明** | **注意事项** |
|----------------|---------------|----------|--------------|
| `TINYINT` | `TINYINT` | 8位整数，0-255 | ✅ 直接对应 |
| `SMALLINT` | `SMALLINT` | 16位整数 | ✅ 完全兼容 |
| `INT` | `INT` | 32位整数 | ✅ 无需转换 |
| `BIGINT` | `BIGINT` | 64位整数 | ✅ 完全对应 |
| `REAL` | `FLOAT` | 单精度浮点数 | ⚠️ 精度可能有差异 |
| `FLOAT` | `DOUBLE` | 双精度浮点数 | ✅ 基本兼容 |
| `DECIMAL(p,s)` | `DECIMAL(p,s)` | 精确数值 | ✅ 参数相同即可 |
| `MONEY` | `DECIMAL(19,4)` | 货币类型 | 🔄 需要转换 |
| `SMALLMONEY` | `DECIMAL(10,4)` | 小额货币 | 🔄 需要转换 |

**💻 数值类型转换示例**
```sql
-- SQL Server原始表结构
CREATE TABLE Products (
    ProductID INT IDENTITY(1,1),
    Price MONEY,
    Discount REAL,
    Weight DECIMAL(8,2)
);

-- MySQL转换后结构
CREATE TABLE Products (
    ProductID INT AUTO_INCREMENT PRIMARY KEY,
    Price DECIMAL(19,4),           -- MONEY转为DECIMAL
    Discount FLOAT,                -- REAL转为FLOAT  
    Weight DECIMAL(8,2)            -- DECIMAL保持不变
);
```

### 2.2 字符串类型映射


**📝 字符串类型对应**

| SQL Server类型 | MySQL对应类型 | **长度限制** | **使用建议** |
|----------------|---------------|--------------|--------------|
| `CHAR(n)` | `CHAR(n)` | 最大255字符 | ✅ 短固定长度文本 |
| `VARCHAR(n)` | `VARCHAR(n)` | 最大65535字符 | ✅ 可变长度文本 |
| `NCHAR(n)` | `CHAR(n)` | Unicode转UTF8 | 🔄 注意字符集 |
| `NVARCHAR(n)` | `VARCHAR(n)` | Unicode转UTF8 | 🔄 长度可能翻倍 |
| `TEXT` | `TEXT` | 大文本 | ⚠️ 建议用VARCHAR |
| `NTEXT` | `LONGTEXT` | Unicode大文本 | 🔄 需要转换 |
| `VARCHAR(MAX)` | `LONGTEXT` | 超长文本 | 🔄 类型调整 |

> ⚠️ **重要提醒**：`NVARCHAR`在SQL Server中是Unicode，一个字符占2字节；在MySQL中UTF8一个中文字符占3字节，长度设置需要相应调整。

**🔧 字符串转换实例**
```sql
-- SQL Server原始结构
CREATE TABLE Users (
    UserName NVARCHAR(50),        -- Unicode，最多50个字符
    Description NVARCHAR(MAX),    -- 无限长度Unicode文本
    Code CHAR(10)                 -- 固定10位编码
);

-- MySQL转换建议
CREATE TABLE Users (
    UserName VARCHAR(150),        -- 50*3=150，预留Unicode空间
    Description LONGTEXT,         -- 对应NVARCHAR(MAX)
    Code CHAR(10)                 -- 保持不变
) CHARACTER SET utf8mb4;          -- 使用完整Unicode字符集
```

### 2.3 日期时间类型映射


**📅 时间类型对应关系**

| SQL Server类型 | MySQL对应类型 | **精度** | **范围差异** |
|----------------|---------------|----------|--------------|
| `DATETIME` | `DATETIME` | 微秒 | 范围略有不同 |
| `DATETIME2` | `DATETIME(6)` | 微秒 | 🔄 指定精度 |
| `DATE` | `DATE` | 日期 | ✅ 完全兼容 |
| `TIME` | `TIME` | 时间 | ✅ 基本兼容 |
| `TIMESTAMP` | `TIMESTAMP` | 时间戳 | ⚠️ 行为差异大 |
| `SMALLDATETIME` | `DATETIME` | 分钟 | 🔄 精度提升 |

> **🤔 新手困惑**：为什么TIMESTAMP类型差异这么大？
> **💡 解释**：SQL Server的TIMESTAMP实际是行版本号（类似乐观锁），跟时间无关；MySQL的TIMESTAMP才是真正的时间戳。

**⏰ 时间类型转换案例**
```sql
-- SQL Server原始表
CREATE TABLE Orders (
    OrderID INT,
    OrderDate DATETIME2(3),         -- 精确到毫秒
    CreateTime SMALLDATETIME,       -- 精确到分钟
    RowVersion TIMESTAMP            -- 行版本号，不是时间！
);

-- MySQL转换方案
CREATE TABLE Orders (
    OrderID INT,
    OrderDate DATETIME(3),          -- 保持毫秒精度
    CreateTime DATETIME,            -- 提升为DATETIME
    RowVersion BIGINT DEFAULT 1     -- 转为版本号字段
    -- 或者添加：UpdateTime TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 2.4 特殊类型映射


**🔸 二进制和其他类型**

| SQL Server类型 | MySQL对应类型 | **转换说明** |
|----------------|---------------|--------------|
| `BIT` | `TINYINT(1)` | 布尔值 |
| `BINARY(n)` | `BINARY(n)` | 固定长度二进制 |
| `VARBINARY(n)` | `VARBINARY(n)` | 可变长度二进制 |
| `IMAGE` | `LONGBLOB` | 大二进制对象 |
| `UNIQUEIDENTIFIER` | `CHAR(36)` | GUID转字符串 |
| `XML` | `JSON` 或 `LONGTEXT` | 结构化数据 |

**🔧 特殊类型处理示例**
```sql
-- SQL Server GUID和XML处理
CREATE TABLE Documents (
    DocID UNIQUEIDENTIFIER DEFAULT NEWID(),
    Content XML,
    IsActive BIT DEFAULT 1
);

-- MySQL转换方案
CREATE TABLE Documents (
    DocID CHAR(36) DEFAULT (UUID()),  -- MySQL 8.0+支持UUID()
    Content JSON,                     -- 建议用JSON存储结构化数据
    IsActive TINYINT(1) DEFAULT 1     -- BIT转为TINYINT
);
```

---

## 3. 🎯 SQL Server到MySQL迁移策略


### 3.1 迁移方法选择


**🛠️ 迁移工具对比**

```
手工迁移流程：
数据导出 → 结构转换 → 数据清洗 → 导入验证
   ↓           ↓          ↓         ↓
CSV/SQL     手动修改    脚本处理   人工检查

优势：完全可控，成本低
缺陷：工作量大，容易出错
适用：小型项目，数据量<1GB
```

**⚡ 专业工具迁移**

| 工具名称 | **类型** | **优势** | **适用场景** |
|---------|----------|----------|--------------|
| `MySQL Workbench Migration Wizard` | 🆓 免费官方 | 界面友好，支持多种源 | 中小型迁移 |
| `Navicat Data Transfer` | 💰 商业 | 操作简单，可视化强 | 快速迁移 |
| `AWS Database Migration Service` | ☁️ 云服务 | 实时迁移，最小停机 | 生产环境 |
| `自定义脚本` | 🔧 定制 | 完全可控，成本低 | 复杂需求 |

### 3.2 迁移前准备工作


**🔍 环境分析清单**
```
✅ 源数据库分析：
• 数据库版本：SQL Server 2012/2016/2019?
• 数据量大小：表数量、行数、存储大小
• 字符集编码：默认排序规则是什么？
• 特殊功能：是否使用存储过程、触发器、函数？
• 业务依赖：哪些应用连接此数据库？

✅ 目标环境准备：
• MySQL版本选择：建议8.0+获得更好兼容性
• 字符集设置：utf8mb4支持完整Unicode
• 存储引擎：InnoDB支持事务和外键
• 配置优化：缓冲池、连接数等参数调整
```

**📋 迁移计划制定**
```
阶段一：测试迁移 (1-2周)
┌─ 测试环境迁移 ─────────────────┐
│ • 选择小部分数据测试            │
│ • 验证数据类型转换是否正确      │
│ • 测试应用程序兼容性            │
│ • 记录遇到的问题和解决方案      │
└─────────────────────────────────┘

阶段二：全量迁移 (1-3天)  
┌─ 生产环境迁移 ─────────────────┐
│ • 选择业务低峰期执行            │
│ • 数据库停机维护                │
│ • 执行完整迁移流程              │
│ • 数据一致性验证                │
└─────────────────────────────────┘

阶段三：切换验证 (1周)
┌─ 业务验证阶段 ─────────────────┐
│ • 应用程序切换到MySQL           │
│ • 功能完整性测试                │
│ • 性能对比验证                  │
│ • 问题修复和优化                │
└─────────────────────────────────┘
```

### 3.3 迁移风险评估


**⚠️ 主要风险点**

| 风险类型 | **风险描述** | **预防措施** | **应急方案** |
|---------|-------------|-------------|-------------|
| 🔴 **数据丢失** | 迁移过程中数据丢失 | 完整备份+测试验证 | 从备份恢复 |
| 🟡 **业务中断** | 停机时间过长 | 充分测试+夜间迁移 | 快速回滚 |
| 🟠 **功能异常** | 应用功能不正常 | 兼容性测试+代码调整 | 紧急修复 |
| 🟣 **性能下降** | 查询速度变慢 | 索引优化+参数调优 | 性能优化 |

---

## 4. 🔄 数据类型映射详解


### 4.1 复杂数据类型处理


**🔸 IDENTITY自增字段转换**

```sql
-- SQL Server自增字段
CREATE TABLE Users (
    UserID INT IDENTITY(1,1) PRIMARY KEY,  -- 从1开始，每次增加1
    UserName NVARCHAR(50)
);

-- MySQL对应写法
CREATE TABLE Users (
    UserID INT AUTO_INCREMENT PRIMARY KEY, -- MySQL的自增语法
    UserName VARCHAR(150)                   -- Unicode长度调整
);

-- 注意：如果需要保持原有ID值
ALTER TABLE Users AUTO_INCREMENT = 1001;  -- 设置起始值
```

> **💡 理解要点**：`IDENTITY`和`AUTO_INCREMENT`功能相同，但语法不同。就像不同品牌的遥控器，功能一样但按键位置不同。

**🔸 UNIQUEIDENTIFIER处理**

```sql
-- SQL Server使用GUID
CREATE TABLE Orders (
    OrderID UNIQUEIDENTIFIER DEFAULT NEWID(),
    CustomerID INT
);

-- MySQL转换方案1：保持GUID格式
CREATE TABLE Orders (
    OrderID CHAR(36) DEFAULT (UUID()),     -- MySQL 8.0+支持UUID()函数
    CustomerID INT
);

-- MySQL转换方案2：简化为自增ID（推荐）
CREATE TABLE Orders (
    OrderID BIGINT AUTO_INCREMENT PRIMARY KEY,
    OrderGUID CHAR(36) DEFAULT (UUID()),   -- 保留GUID作为业务字段
    CustomerID INT
);
```

### 4.2 文本类型深度处理


**🔤 Unicode文本处理技巧**

```sql
-- SQL Server Unicode文本
CREATE TABLE Articles (
    Title NVARCHAR(200),           -- 支持中文、emoji等
    Content NVARCHAR(MAX),         -- 无限长度
    Summary NTEXT                  -- 旧版大文本类型
);

-- MySQL最佳转换实践
CREATE TABLE Articles (
    Title VARCHAR(600),            -- 200*3=600，预留Unicode空间
    Content LONGTEXT,              -- 对应NVARCHAR(MAX)
    Summary LONGTEXT               -- 统一使用LONGTEXT
) CHARACTER SET utf8mb4           -- 支持完整Unicode，包括emoji
  COLLATE utf8mb4_unicode_ci;     -- Unicode标准排序
```

> **🎯 实用技巧**：遇到中文数据，MySQL字符集必须设置为`utf8mb4`，不是`utf8`。这是因为MySQL的`utf8`只支持3字节UTF-8，不支持emoji等4字节字符。

### 4.3 日期时间类型深度解析


**📅 复杂时间类型处理**

```sql
-- SQL Server复杂时间字段
CREATE TABLE Events (
    EventID INT,
    StartTime DATETIME2(7),        -- 高精度时间，100纳秒
    EndDate DATE,                  -- 只要日期
    Duration TIME(3),              -- 时间间隔，毫秒精度
    RowVersion TIMESTAMP           -- 行版本号，非时间！
);

-- MySQL转换策略
CREATE TABLE Events (
    EventID INT,
    StartTime DATETIME(6),         -- 微秒精度，已足够
    EndDate DATE,                  -- 保持不变
    Duration TIME(3),              -- 保持毫秒精度
    RowVersion BIGINT DEFAULT 1,   -- 转为版本号
    UpdateTime TIMESTAMP DEFAULT CURRENT_TIMESTAMP 
               ON UPDATE CURRENT_TIMESTAMP  -- 真正的时间戳
);
```

**⏰ 时区处理注意事项**
```sql
-- 如果涉及跨时区应用
CREATE TABLE GlobalEvents (
    EventTime DATETIME,            -- 统一使用UTC时间存储
    TimeZone VARCHAR(50),          -- 单独存储时区信息
    LocalTime VARCHAR(25)          -- 或者存储本地时间字符串
);

-- 应用层处理时区转换
-- PHP示例：date_default_timezone_set('Asia/Shanghai');
-- Java示例：ZonedDateTime.now(ZoneId.of("Asia/Shanghai"))
```

---

## 5. 🎯 SQL Server到MySQL迁移策略


### 5.1 整体迁移流程


**🔄 标准迁移流程图**
```
准备阶段              迁移执行阶段              验证阶段
    |                       |                      |
┌─ 环境分析 ─┐         ┌─ 结构迁移 ─┐         ┌─ 数据验证 ─┐
│ • 数据库版本 │   →    │ • 表结构转换 │   →    │ • 行数对比   │
│ • 数据量评估 │        │ • 索引重建   │        │ • 数据抽样   │
│ • 依赖关系   │        │ • 约束调整   │        │ • 功能测试   │
└──────────────┘         └──────────────┘         └──────────────┘
        |                       |                      |
┌─ 迁移方案 ─┐         ┌─ 数据迁移 ─┐         ┌─ 性能优化 ─┐
│ • 工具选择   │   →    │ • 批量导出   │   →    │ • 索引优化   │
│ • 时间安排   │        │ • 数据转换   │        │ • 参数调优   │
│ • 风险预案   │        │ • 增量同步   │        │ • 监控设置   │
└──────────────┘         └──────────────┘         └──────────────┘
```

### 5.2 数据导出策略


**📤 SQL Server数据导出方法**

**方法一：使用BCP工具**
```cmd
# 导出表数据为CSV格式
bcp "SELECT * FROM MyDB.dbo.Users" queryout "users.csv" 
    -c -t"," -r"\n" -S"ServerName" -T

# 参数说明：
# -c：字符格式
# -t","：字段分隔符为逗号  
# -r"\n"：行分隔符为换行
# -T：使用Windows身份验证
```

**方法二：使用SSMS导出向导**
```
操作步骤：
1. 右键数据库 → 任务 → 导出数据
2. 选择数据源：SQL Server
3. 选择目标：平面文件或Excel
4. 选择要导出的表
5. 执行导出任务

优势：图形界面，操作简单
适用：小量数据，一次性迁移
```

**方法三：自定义SQL脚本**
```sql
-- 生成INSERT语句的存储过程
DECLARE @sql NVARCHAR(MAX) = '';
SELECT @sql = @sql + 
'INSERT INTO Users VALUES (' +
    CAST(UserID AS NVARCHAR) + ',' +
    '''' + UserName + ''',' +
    '''' + CONVERT(VARCHAR, CreateDate, 120) + '''' +
');' + CHAR(13)
FROM Users;

PRINT @sql;  -- 输出所有INSERT语句
```

### 5.3 MySQL数据导入策略


**📥 高效导入方法**

**方法一：LOAD DATA导入（推荐）**
```sql
-- 最快的批量导入方式
LOAD DATA INFILE '/path/to/users.csv'
INTO TABLE Users
FIELDS TERMINATED BY ','           -- 字段分隔符
OPTIONALLY ENCLOSED BY '"'         -- 字段包围符
LINES TERMINATED BY '\n'           -- 行分隔符
IGNORE 1 ROWS                      -- 跳过标题行
(UserID, UserName, @CreateDate)    -- 字段映射
SET CreateDate = STR_TO_DATE(@CreateDate, '%Y-%m-%d %H:%i:%s');
```

**方法二：MySQL Workbench导入**
```
操作步骤：
1. 打开MySQL Workbench
2. 连接到目标数据库
3. 右键表 → Table Data Import Wizard
4. 选择CSV文件
5. 配置字段映射
6. 执行导入

适用：中等数据量，需要字段映射
```

### 5.4 增量数据同步


**🔄 增量同步策略**

```sql
-- 在SQL Server中标记新增和修改的数据
ALTER TABLE Users ADD LastModified DATETIME2 DEFAULT GETDATE();

-- 创建触发器自动更新时间戳
CREATE TRIGGER TR_Users_Update
ON Users
AFTER UPDATE
AS
BEGIN
    UPDATE Users 
    SET LastModified = GETDATE()
    WHERE UserID IN (SELECT UserID FROM inserted);
END;

-- 增量导出脚本
SELECT * FROM Users 
WHERE LastModified > '2025-09-01 00:00:00'  -- 上次同步时间
ORDER BY LastModified;
```

**⚡ 增量同步自动化**
```bash
#!/bin/bash
# 增量同步脚本示例

LAST_SYNC=$(cat /tmp/last_sync_time.txt)
CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')

# 导出增量数据
sqlcmd -S server -Q "SELECT * FROM Users WHERE LastModified > '$LAST_SYNC'" -o /tmp/delta.csv

# 导入到MySQL
mysql -u user -p database < /tmp/delta.csv

# 更新同步时间
echo $CURRENT_TIME > /tmp/last_sync_time.txt
```

---

## 6. 🔧 T-SQL语法转换技巧


### 6.1 基本语法差异


> **💡 核心理解**：T-SQL是SQL Server的方言，MySQL有自己的语法习惯。就像说普通话的人去广东，基本能听懂，但有些表达方式需要调整。

**🔸 字符串操作差异**

| 功能 | **SQL Server (T-SQL)** | **MySQL** | **说明** |
|------|----------------------|-----------|----------|
| 字符串拼接 | `'Hello' + 'World'` | `CONCAT('Hello', 'World')` | MySQL不支持+号拼接 |
| 字符串长度 | `LEN(str)` | `LENGTH(str)` | 函数名不同 |
| 子字符串 | `SUBSTRING(str, 1, 5)` | `SUBSTRING(str, 1, 5)` | ✅ 兼容 |
| 字符串替换 | `REPLACE(str, 'old', 'new')` | `REPLACE(str, 'old', 'new')` | ✅ 兼容 |
| 大小写转换 | `UPPER(str)`, `LOWER(str)` | `UPPER(str)`, `LOWER(str)` | ✅ 兼容 |

**💻 字符串转换示例**
```sql
-- SQL Server原始查询
SELECT UserName + ' (' + Email + ')' AS DisplayName,
       LEN(UserName) AS NameLength
FROM Users
WHERE UserName LIKE '%admin%';

-- MySQL转换后
SELECT CONCAT(UserName, ' (', Email, ')') AS DisplayName,
       LENGTH(UserName) AS NameLength  
FROM Users
WHERE UserName LIKE '%admin%';
```

### 6.2 日期函数转换


**📅 日期函数对比**

| 功能 | **SQL Server** | **MySQL** | **转换说明** |
|------|----------------|-----------|-------------|
| 当前时间 | `GETDATE()` | `NOW()` | 函数名不同 |
| 日期格式化 | `FORMAT(date, 'yyyy-MM-dd')` | `DATE_FORMAT(date, '%Y-%m-%d')` | 格式符不同 |
| 日期加减 | `DATEADD(day, 7, date)` | `DATE_ADD(date, INTERVAL 7 DAY)` | 语法结构不同 |
| 日期差值 | `DATEDIFF(day, date1, date2)` | `DATEDIFF(date2, date1)` | 参数顺序相反 |
| 日期部分 | `YEAR(date)`, `MONTH(date)` | `YEAR(date)`, `MONTH(date)` | ✅ 兼容 |

**⏰ 日期函数转换实例**
```sql
-- SQL Server复杂日期查询
SELECT 
    OrderID,
    GETDATE() AS CurrentTime,
    FORMAT(OrderDate, 'yyyy年MM月dd日') AS FormattedDate,
    DATEADD(day, 30, OrderDate) AS DueDate,
    DATEDIFF(day, OrderDate, GETDATE()) AS DaysAgo
FROM Orders
WHERE OrderDate >= DATEADD(month, -3, GETDATE());

-- MySQL转换版本
SELECT 
    OrderID,
    NOW() AS CurrentTime,
    DATE_FORMAT(OrderDate, '%Y年%m月%d日') AS FormattedDate,
    DATE_ADD(OrderDate, INTERVAL 30 DAY) AS DueDate,
    DATEDIFF(NOW(), OrderDate) AS DaysAgo
FROM Orders  
WHERE OrderDate >= DATE_SUB(NOW(), INTERVAL 3 MONTH);
```

### 6.3 条件语句转换


**🔀 条件逻辑处理**

```sql
-- SQL Server的CASE语句（基本兼容）
SELECT 
    UserName,
    CASE 
        WHEN Age < 18 THEN '未成年'
        WHEN Age BETWEEN 18 AND 60 THEN '成年人'
        ELSE '老年人'
    END AS AgeGroup
FROM Users;

-- MySQL版本（几乎无需修改）
SELECT 
    UserName,
    CASE 
        WHEN Age < 18 THEN '未成年'
        WHEN Age BETWEEN 18 AND 60 THEN '成年人'  
        ELSE '老年人'
    END AS AgeGroup
FROM Users;
```

**🔸 IIF函数转换**
```sql
-- SQL Server 2012+的IIF函数
SELECT UserName,
       IIF(IsActive = 1, '活跃', '非活跃') AS Status
FROM Users;

-- MySQL转换（使用IF函数）
SELECT UserName,
       IF(IsActive = 1, '活跃', '非活跃') AS Status
FROM Users;
```

### 6.4 分页查询转换


**📄 分页语法差异**

```sql
-- SQL Server 2012+的OFFSET...FETCH
SELECT UserID, UserName, Email
FROM Users
ORDER BY UserID
OFFSET 20 ROWS           -- 跳过前20行
FETCH NEXT 10 ROWS ONLY; -- 取接下来10行

-- MySQL的LIMIT语法
SELECT UserID, UserName, Email
FROM Users  
ORDER BY UserID
LIMIT 20, 10;            -- 从第20行开始，取10行

-- 或者MySQL 8.0+也支持OFFSET语法
SELECT UserID, UserName, Email
FROM Users
ORDER BY UserID
LIMIT 10 OFFSET 20;      -- 跳过20行，取10行
```

### 6.5 聚合函数转换


**📊 窗口函数处理**

```sql
-- SQL Server窗口函数
SELECT 
    UserName,
    Salary,
    ROW_NUMBER() OVER (ORDER BY Salary DESC) AS SalaryRank,
    LAG(Salary, 1) OVER (ORDER BY Salary DESC) AS PrevSalary
FROM Employees;

-- MySQL 8.0+完全支持（无需转换）
SELECT 
    UserName,
    Salary,
    ROW_NUMBER() OVER (ORDER BY Salary DESC) AS SalaryRank,
    LAG(Salary, 1) OVER (ORDER BY Salary DESC) AS PrevSalary
FROM Employees;

-- MySQL 5.7及以下版本替代方案
SELECT 
    UserName,
    Salary,
    @row_number := @row_number + 1 AS SalaryRank
FROM Employees, (SELECT @row_number := 0) AS t
ORDER BY Salary DESC;
```

---

## 7. 🔤 字符集处理方案


### 7.1 字符集基础概念


> **💡 通俗理解**：字符集就像不同的"字典"，规定了每个字符用什么数字编码。SQL Server和MySQL用的"字典"不完全一样，所以搬家时要做"翻译"。

**🔸 主要字符集对比**

| 数据库 | **默认字符集** | **Unicode支持** | **中文支持** |
|-------|----------------|-----------------|-------------|
| SQL Server | `SQL_Latin1_General_CP1_CI_AS` | ✅ NVARCHAR | ✅ 完整支持 |
| MySQL | `utf8mb4` (推荐) | ✅ 原生支持 | ✅ 完整支持 |
| MySQL | `utf8` (旧版) | ⚠️ 不完整 | ⚠️ 不支持emoji |

**🔧 字符集检查命令**
```sql
-- 检查SQL Server字符集
SELECT DATABASEPROPERTYEX('YourDB', 'Collation') AS DatabaseCollation;
SELECT SERVERPROPERTY('Collation') AS ServerCollation;

-- 检查MySQL字符集
SHOW VARIABLES LIKE 'character_set%';
SHOW VARIABLES LIKE 'collation%';
```

### 7.2 字符集迁移最佳实践


**✅ 推荐配置方案**

```sql
-- MySQL服务器级别配置（my.cnf）
[mysql]
default-character-set = utf8mb4

[mysqld]
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

-- 数据库级别设置
CREATE DATABASE NewDB 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- 表级别设置
CREATE TABLE Users (
    UserName VARCHAR(150)
) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

> **📌 记忆要点**：记住`utf8mb4`这个关键词，它是MySQL中真正完整的UTF-8实现，支持所有Unicode字符包括emoji。

### 7.3 字符集转换问题处理


**🔄 编码转换流程**
```
SQL Server数据导出
        ↓
┌─ 编码检测和转换 ─────────────┐
│ • 检测原始编码               │
│ • 转换为UTF-8格式           │  
│ • 验证转换结果               │
└─────────────────────────────┘
        ↓
MySQL导入前预处理
        ↓
┌─ 导入参数配置 ───────────────┐
│ CHARACTER SET utf8mb4        │
│ COLLATE utf8mb4_unicode_ci   │
└─────────────────────────────┘
```

**💻 编码问题修复脚本**
```bash
#!/bin/bash
# 文件编码转换脚本

# 检测文件编码
file_encoding=$(file -b --mime-encoding users.csv)
echo "原始编码: $file_encoding"

# 转换为UTF-8
if [ "$file_encoding" != "utf-8" ]; then
    iconv -f $file_encoding -t utf-8 users.csv > users_utf8.csv
    echo "已转换为UTF-8编码"
fi

# 验证转换结果
head -n 5 users_utf8.csv
```

### 7.4 中文数据处理注意事项


**🇨🇳 中文字符特殊处理**

```sql
-- SQL Server中文数据示例
INSERT INTO Users VALUES (N'张三', N'用户描述信息');

-- 迁移到MySQL时的注意事项
INSERT INTO Users VALUES ('张三', '用户描述信息');
-- 注意：MySQL中不需要N前缀，但必须确保连接字符集正确

-- 应用程序连接字符集设置
-- PHP: mysqli_set_charset($link, "utf8mb4");
-- Java: ?useUnicode=true&characterEncoding=utf8mb4
-- Python: charset='utf8mb4'
```

**⚠️ 常见字符集问题**
```
问题1：中文显示乱码
原因：字符集设置不一致
解决：统一使用utf8mb4

问题2：emoji无法存储  
原因：使用了utf8而非utf8mb4
解决：升级到utf8mb4字符集

问题3：排序结果不正确
原因：排序规则(Collation)不合适
解决：使用utf8mb4_unicode_ci
```

---

## 8. ⚡ 迁移性能优化技巧


### 8.1 导出性能优化


**🚀 SQL Server导出优化**

```sql
-- 优化大表导出查询
-- 避免SELECT *，明确指定字段
SELECT UserID, UserName, Email, CreateDate
FROM Users WITH (NOLOCK)          -- 允许脏读，提升速度
WHERE CreateDate >= '2020-01-01'  -- 分批导出
ORDER BY UserID;                  -- 利用聚集索引排序

-- 分批导出大表数据
DECLARE @BatchSize INT = 10000;
DECLARE @StartID INT = 1;
DECLARE @MaxID INT = (SELECT MAX(UserID) FROM Users);

WHILE @StartID <= @MaxID
BEGIN
    SELECT UserID, UserName, Email
    FROM Users
    WHERE UserID BETWEEN @StartID AND (@StartID + @BatchSize - 1);
    
    SET @StartID = @StartID + @BatchSize;
END
```

**📊 导出性能监控**
```sql
-- 监控导出进度
SELECT 
    session_id,
    command,
    percent_complete,
    estimated_completion_time,
    start_time
FROM sys.dm_exec_requests 
WHERE command LIKE '%BACKUP%' OR command LIKE '%RESTORE%';
```

### 8.2 导入性能优化


**⚡ MySQL导入优化配置**

```sql
-- 临时关闭约束和索引（大批量导入时）
SET FOREIGN_KEY_CHECKS = 0;        -- 关闭外键检查
SET UNIQUE_CHECKS = 0;              -- 关闭唯一性检查
SET SQL_LOG_BIN = 0;                -- 关闭二进制日志（如果允许）

-- 调整缓冲区大小
SET GLOBAL innodb_buffer_pool_size = 2G;      -- 增加缓冲池
SET GLOBAL bulk_insert_buffer_size = 256M;    -- 增加批量插入缓冲
SET GLOBAL max_allowed_packet = 1G;           -- 增加包大小限制

-- 执行导入
LOAD DATA INFILE '/path/to/large_table.csv'
INTO TABLE LargeTable
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n';

-- 恢复设置
SET FOREIGN_KEY_CHECKS = 1;
SET UNIQUE_CHECKS = 1;
SET SQL_LOG_BIN = 1;
```

**🔧 索引重建策略**
```sql
-- 先删除非主键索引，导入后重建
-- 1. 记录原有索引
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
  AND INDEX_NAME != 'PRIMARY';

-- 2. 删除索引
DROP INDEX idx_username ON Users;
DROP INDEX idx_email ON Users;

-- 3. 导入数据（速度更快）
LOAD DATA INFILE...

-- 4. 重建索引
CREATE INDEX idx_username ON Users(UserName);
CREATE INDEX idx_email ON Users(Email);
```

### 8.3 大数据量迁移策略


**📦 分块迁移方案**

```
大表分块策略：
┌─ 水平分割 ────────────────────┐
│ 按时间分块：                   │
│ • 2020年数据 → 块1            │
│ • 2021年数据 → 块2            │
│ • 2022年数据 → 块3            │
│                               │
│ 按ID范围分块：                │
│ • ID 1-100万 → 块1           │
│ • ID 100万-200万 → 块2       │
│ • ID 200万-300万 → 块3       │
└───────────────────────────────┘
```

**🔄 并行迁移实现**
```bash
#!/bin/bash
# 并行导出脚本

export_table_range() {
    local start_id=$1
    local end_id=$2
    local output_file=$3
    
    sqlcmd -S server -Q "
        SELECT * FROM Users 
        WHERE UserID BETWEEN $start_id AND $end_id
    " -o $output_file
}

# 启动多个并行任务
export_table_range 1 100000 "users_part1.csv" &
export_table_range 100001 200000 "users_part2.csv" &  
export_table_range 200001 300000 "users_part3.csv" &

# 等待所有任务完成
wait

echo "所有导出任务完成"
```

### 8.4 网络传输优化


**🌐 数据传输优化**

```
传输优化策略：
┌─ 数据压缩 ────────────────────┐
│ • 导出时压缩：gzip、zip        │
│ • 网络传输：减少带宽占用       │
│ • 导入时解压：自动处理         │
└───────────────────────────────┘

┌─ 分批传输 ────────────────────┐
│ • 避免大文件传输超时           │
│ • 支持断点续传                 │
│ • 便于进度监控                 │
└───────────────────────────────┘
```

**💻 压缩传输示例**
```bash
# 导出并压缩
bcp "SELECT * FROM LargeTable" queryout "data.csv" -c -t"," -S server -T
gzip data.csv                    # 压缩文件

# 传输到目标服务器
scp data.csv.gz user@mysql-server:/tmp/

# 在MySQL服务器解压并导入
gunzip /tmp/data.csv.gz
mysql -u root -p database -e "
    LOAD DATA INFILE '/tmp/data.csv' 
    INTO TABLE LargeTable 
    FIELDS TERMINATED BY ',';
"
```

---

## 9. 🔧 存储过程和函数迁移


### 9.1 存储过程语法转换


> **💡 核心理解**：存储过程就像数据库里的"小程序"，不同数据库的"编程语言"语法不同，需要"翻译"。

**🔸 基本语法对比**

```sql
-- SQL Server存储过程
CREATE PROCEDURE GetUserInfo
    @UserID INT,
    @UserName NVARCHAR(50) OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT @UserName = UserName 
    FROM Users 
    WHERE UserID = @UserID;
    
    IF $$ROWCOUNT = 0
        THROW 50000, '用户不存在', 1;
END

-- MySQL存储过程转换
DELIMITER $$
CREATE PROCEDURE GetUserInfo(
    IN p_UserID INT,
    OUT p_UserName VARCHAR(150)
)
BEGIN
    DECLARE EXIT HANDLER FOR NOT FOUND
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '用户不存在';
    
    SELECT UserName INTO p_UserName
    FROM Users 
    WHERE UserID = p_UserID;
END$$
DELIMITER ;
```

**🔄 关键差异说明**
```
参数声明：
SQL Server: @参数名 类型
MySQL:     IN/OUT 参数名 类型

变量赋值：
SQL Server: SELECT @var = value FROM table
MySQL:     SELECT value INTO var FROM table

错误处理：
SQL Server: THROW语句
MySQL:     SIGNAL SQLSTATE语句

计数检查：
SQL Server: $$ROWCOUNT
MySQL:     ROW_COUNT()函数
```

### 9.2 函数转换技巧


**🔧 用户定义函数转换**

```sql
-- SQL Server标量函数
CREATE FUNCTION CalculateAge(@BirthDate DATE)
RETURNS INT
AS
BEGIN
    RETURN DATEDIFF(year, @BirthDate, GETDATE());
END

-- MySQL函数转换
DELIMITER $$
CREATE FUNCTION CalculateAge(birth_date DATE)
RETURNS INT
READS SQL DATA
DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, birth_date, NOW());
END$$
DELIMITER ;
```

### 9.3 触发器迁移


**⚡ 触发器语法转换**

```sql
-- SQL Server触发器
CREATE TRIGGER tr_Users_Audit
ON Users
AFTER INSERT, UPDATE
AS
BEGIN
    INSERT INTO UserAudit (UserID, Action, ActionTime)
    SELECT UserID, 'MODIFIED', GETDATE()
    FROM inserted;
END

-- MySQL触发器转换
DELIMITER $$
CREATE TRIGGER tr_Users_Audit_Insert
AFTER INSERT ON Users
FOR EACH ROW
BEGIN
    INSERT INTO UserAudit (UserID, Action, ActionTime)
    VALUES (NEW.UserID, 'INSERT', NOW());
END$$

CREATE TRIGGER tr_Users_Audit_Update  
AFTER UPDATE ON Users
FOR EACH ROW
BEGIN
    INSERT INTO UserAudit (UserID, Action, ActionTime)
    VALUES (NEW.UserID, 'UPDATE', NOW());
END$$
DELIMITER ;
```

> **🎯 实用提示**：MySQL需要为INSERT和UPDATE分别创建触发器，不能像SQL Server那样在一个触发器中处理多个事件。

---

## 10. 🛠️ 迁移工具实战


### 10.1 MySQL Workbench迁移向导


**🖥️ 图形化迁移步骤**

```
迁移向导操作流程：
第1步：设置源数据库连接
┌─────────────────────────────┐
│ 数据库类型：Microsoft SQL Server │
│ 服务器地址：192.168.1.100   │
│ 端口：1433                  │
│ 数据库名：SourceDB          │
│ 用户名：sa                  │
└─────────────────────────────┘

第2步：设置目标数据库连接  
┌─────────────────────────────┐
│ 数据库类型：MySQL           │
│ 服务器地址：localhost       │
│ 端口：3306                  │
│ 数据库名：TargetDB          │
│ 用户名：root                │
└─────────────────────────────┘

第3步：选择迁移对象
• 选择要迁移的数据库
• 选择要迁移的表
• 选择要迁移的其他对象（视图、存储过程等）

第4步：数据类型映射检查
• 自动映射结果检查
• 手动调整有问题的映射
• 预览转换后的表结构

第5步：执行迁移
• 结构迁移：创建表、索引、约束
• 数据迁移：批量导入数据
• 验证迁移：检查数据完整性
```

### 10.2 命令行工具迁移


**⚡ 高效命令行方案**

```bash
#!/bin/bash
# 完整迁移自动化脚本

# 配置信息
SQLSERVER_HOST="192.168.1.100"
MYSQL_HOST="192.168.1.200"
DATABASE_NAME="MyApp"

echo "开始SQL Server到MySQL迁移..."

# 第1步：导出SQL Server结构
echo "导出数据库结构..."
sqlcmd -S $SQLSERVER_HOST -Q "
    SELECT 
        'CREATE TABLE ' + TABLE_NAME + ' (' + 
        STUFF((
            SELECT ', ' + COLUMN_NAME + ' ' + DATA_TYPE + 
                   CASE 
                       WHEN CHARACTER_MAXIMUM_LENGTH IS NOT NULL 
                       THEN '(' + CAST(CHARACTER_MAXIMUM_LENGTH AS VARCHAR) + ')'
                       ELSE ''
                   END
            FROM INFORMATION_SCHEMA.COLUMNS c2
            WHERE c2.TABLE_NAME = c1.TABLE_NAME
            FOR XML PATH('')
        ), 1, 2, '') + ');'
    FROM INFORMATION_SCHEMA.TABLES c1
    WHERE TABLE_TYPE = 'BASE TABLE';
" -o schema.sql

# 第2步：转换SQL语法
sed -i 's/NVARCHAR/VARCHAR/g' schema.sql      # 字符类型转换
sed -i 's/DATETIME2/DATETIME/g' schema.sql    # 时间类型转换
sed -i 's/BIT/TINYINT(1)/g' schema.sql        # 布尔类型转换

# 第3步：导入表结构到MySQL
mysql -h $MYSQL_HOST -u root -p $DATABASE_NAME < schema.sql

echo "迁移完成！"
```

### 10.3 数据一致性验证


**✅ 验证检查清单**

```sql
-- 数据行数验证
-- SQL Server
SELECT 
    TABLE_NAME,
    SUM(row_count) AS TotalRows
FROM sys.dm_db_partition_stats ps
JOIN sys.objects o ON ps.object_id = o.object_id
WHERE o.type = 'U'
GROUP BY o.name;

-- MySQL  
SELECT 
    TABLE_NAME,
    TABLE_ROWS
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'your_database'
  AND TABLE_TYPE = 'BASE TABLE';
```

**🔍 数据抽样验证**
```sql
-- 关键表数据抽样对比
-- 检查前100条和后100条数据
(SELECT * FROM Users ORDER BY UserID LIMIT 100)
UNION ALL
(SELECT * FROM Users ORDER BY UserID DESC LIMIT 100);

-- 统计数据验证
SELECT 
    COUNT(*) AS TotalUsers,
    COUNT(DISTINCT Email) AS UniqueEmails,
    MIN(CreateDate) AS EarliestUser,
    MAX(CreateDate) AS LatestUser
FROM Users;
```

### 10.4 迁移回滚方案


**🔙 回滚策略设计**

```
回滚准备：
┌─ 迁移前备份 ───────────────────┐
│ • SQL Server完整备份           │
│ • MySQL空数据库快照            │
│ • 应用程序配置备份             │
│ • 网络配置备份                 │
└───────────────────────────────┘

快速回滚流程：
问题发现 → 停止应用 → 切换数据库连接 → 验证功能 → 恢复服务
   (5分钟)   (2分钟)     (1分钟)      (10分钟)   (2分钟)

总回滚时间：约20分钟
```

---

## 11. 📋 实际迁移案例分析


### 11.1 电商系统迁移案例


**📊 项目背景**
```
系统规模：
• 数据库大小：500GB
• 表数量：150个
• 日均访问：100万次查询
• 核心表：用户、订单、商品、库存

业务要求：
• 停机时间<4小时
• 数据零丢失
• 功能无影响
• 性能不下降
```

**🎯 迁移方案设计**
```
方案选择：混合迁移策略

静态数据表（历史订单、已完成交易）：
• 使用离线迁移
• 可以提前迁移
• 不影响业务

动态数据表（当前库存、用户会话）：
• 使用在线迁移
• 最小化停机时间
• 数据一致性要求高

迁移时间安排：
┌─ 预迁移阶段 ──────────────────┐
│ 周一-周三：历史数据迁移        │
│ 周四-周五：增量数据同步        │
└───────────────────────────────┘
┌─ 正式迁移 ────────────────────┐
│ 周六凌晨2点：业务停机          │
│ 2:00-4:00：核心表迁移         │
│ 4:00-5:00：数据验证           │
│ 5:00-6:00：应用切换测试       │
└───────────────────────────────┘
```

### 11.2 迁移过程问题处理


**🚨 常见问题及解决方案**

```
问题1：字符编码乱码
现象：中文用户名显示为???
原因：字符集设置不正确
解决：
• 检查导出文件编码：file -bi data.csv
• 转换文件编码：iconv -f gbk -t utf-8 data.csv > data_utf8.csv
• 设置MySQL连接字符集：SET NAMES utf8mb4;

问题2：自增ID冲突
现象：新数据插入时主键冲突
原因：AUTO_INCREMENT值设置不正确
解决：
• 查找最大ID：SELECT MAX(UserID) FROM Users;
• 重设起始值：ALTER TABLE Users AUTO_INCREMENT = 10001;

问题3：日期格式错误
现象：日期数据导入失败
原因：日期格式不兼容
解决：
• 统一日期格式：DATE_FORMAT(date, '%Y-%m-%d %H:%i:%s')
• 设置SQL模式：SET sql_mode = 'ALLOW_INVALID_DATES';
```

---

## 12. 🏆 核心要点总结


### 12.1 必须掌握的核心概念


```
🔸 迁移本质：数据、结构、逻辑三个层面的完整转移
🔸 类型映射：理解两种数据库的数据类型差异和转换规则
🔸 语法转换：掌握T-SQL到MySQL语法的主要差异点
🔸 字符集处理：统一使用utf8mb4，避免编码问题
🔸 性能优化：分批处理、并行执行、参数调优
```

### 12.2 关键理解要点


**🔹 为什么需要迁移**
```
成本考虑：
• SQL Server许可费用高
• MySQL开源免费
• 运维成本更低

技术趋势：
• 互联网公司主流选择
• 云原生友好
• 生态更丰富
```

**🔹 迁移成功的关键因素**
```
充分准备：
• 详细的迁移计划
• 完整的环境分析  
• 充足的测试验证

技术保障：
• 正确的类型映射
• 完善的语法转换
• 可靠的数据验证

风险控制：
• 完整的备份策略
• 快速的回滚方案
• 实时的监控告警
```

### 12.3 实际应用指导


**📋 迁移前检查清单**
- [ ] 完成数据库版本和字符集分析
- [ ] 制定详细的迁移计划和时间表
- [ ] 准备测试环境并完成验证迁移
- [ ] 设计数据类型映射和语法转换方案
- [ ] 配置MySQL环境和性能参数
- [ ] 准备回滚方案和应急预案
- [ ] 与业务团队沟通停机时间安排

**⚖️ 工具选择建议**
```
小型项目（<10GB）：
→ MySQL Workbench迁移向导
→ 图形界面，操作简单

中型项目（10GB-100GB）：
→ 自定义脚本 + 分批处理
→ 可控性强，性能更好

大型项目（>100GB）：
→ 专业迁移工具 + 增量同步
→ AWS DMS、阿里云DTS等

企业级项目：
→ 分阶段迁移 + 双写策略
→ 最小化业务风险
```

**🎯 迁移成功评估标准**
```
数据完整性：✅ 行数一致，抽样验证通过
功能正确性：✅ 业务功能全部正常
性能要求：✅ 响应时间符合要求  
稳定性：✅ 连续运行无异常
用户体验：✅ 用户无感知切换
```

> **💡 一句话总结**：SQL Server到MySQL迁移的核心是"三分技术，七分准备"，充分的准备和测试是迁移成功的关键。

### 12.4 学习建议和进阶方向


**📚 深入学习路径**
```
基础技能：
• 熟练掌握SQL Server和MySQL语法差异
• 理解字符集和数据类型转换原理
• 掌握基本的迁移工具使用

进阶技能：
• 大数据量迁移的性能优化技巧
• 复杂业务逻辑的迁移策略
• 实时迁移和零停机迁移方案

专家技能：
• 异构数据库迁移架构设计
• 数据库迁移自动化平台建设
• 企业级迁移项目管理经验
```

**🔗 相关知识链接**
- ← 前置知识：SQL基础语法、数据库原理
- → 后续学习：MySQL优化、分布式数据库迁移

**核心记忆口诀**：
```
┌─ 迁移要诀 ────────────────────┐
│ 类型映射要准确，语法转换别遗漏 │
│ 字符集统一用utf8mb4不出错     │
│ 分批迁移保性能，验证回滚保安全 │
│ 充分准备是关键，测试验证保成功 │
└───────────────────────────────┘
```