---
title: 2、DML语句分类与执行流程
---
## 📚 目录

1. [DML语句概述与分类](#1-dml语句概述与分类)
2. [SQL语句执行流程详解](#2-sql语句执行流程详解)
3. [解析器Parser工作原理](#3-解析器parser工作原理)
4. [优化器Optimizer处理机制](#4-优化器optimizer处理机制)
5. [执行器Executor执行过程](#5-执行器executor执行过程)
6. [DML语句生命周期管理](#6-dml语句生命周期管理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📝 DML语句概述与分类


### 1.1 什么是DML语句


**🔸 核心定义**
```
DML：Data Manipulation Language，数据操作语言
作用：用于对数据库表中的数据进行增删改查操作
特点：直接操作表中的数据记录，是日常使用最频繁的SQL类型
```

**💡 DML vs 其他SQL语言类型**

| 语言类型 | **全称** | **作用** | **典型语句** |
|---------|---------|---------|-------------|
| 🔸 **DML** | `数据操作语言` | `操作表中数据` | `SELECT、INSERT、UPDATE、DELETE` |
| 🔧 **DDL** | `数据定义语言` | `定义数据库结构` | `CREATE、ALTER、DROP` |
| 🔒 **DCL** | `数据控制语言` | `控制访问权限` | `GRANT、REVOKE` |
| 📋 **TCL** | `事务控制语言` | `管理事务` | `COMMIT、ROLLBACK` |

### 1.2 DML语句分类体系


**🏗️ 四大核心操作类型**
```
DML语句分类：
├── SELECT：数据查询操作
│   ├── 简单查询：基础字段选择
│   ├── 条件查询：WHERE子句筛选
│   ├── 连接查询：多表关联
│   └── 子查询：嵌套查询语句
│
├── INSERT：数据插入操作
│   ├── 单行插入：一次插入一条记录
│   ├── 批量插入：一次插入多条记录
│   └── 查询插入：从其他表查询后插入
│
├── UPDATE：数据更新操作
│   ├── 简单更新：基础字段修改
│   ├── 条件更新：WHERE子句限定范围
│   └── 连接更新：多表联合更新
│
└── DELETE：数据删除操作
    ├── 简单删除：基础记录删除
    ├── 条件删除：WHERE子句限定范围
    └── 连接删除：多表关联删除
```

### 1.3 DML语句使用频率分析


**📊 实际使用情况统计**
```
业务系统中DML使用比例：
┌─────────────────────────────┐
│ SELECT查询：约80%           │ ← 读多写少的典型特征
├─────────────────────────────┤
│ INSERT插入：约15%           │ ← 新数据产生
├─────────────────────────────┤
│ UPDATE更新：约4%            │ ← 数据修正和状态变更
├─────────────────────────────┤
│ DELETE删除：约1%            │ ← 数据清理和过期删除
└─────────────────────────────┘

说明：不同业务场景比例会有差异
```

**🎯 不同场景的DML特点**

| 应用场景 | **SELECT** | **INSERT** | **UPDATE** | **DELETE** |
|---------|-----------|-----------|-----------|-----------|
| 📰 **内容网站** | `95%` | `3%` | `1.5%` | `0.5%` |
| 🛒 **电商平台** | `75%` | `20%` | `4%` | `1%` |
| 📊 **数据分析** | `98%` | `1%` | `0.5%` | `0.5%` |
| 💰 **交易系统** | `60%` | `25%` | `10%` | `5%` |

---

## 2. ⚡ SQL语句执行流程详解


### 2.1 SQL执行的完整生命周期


**🔄 从客户端到存储引擎的完整流程**
```
客户端应用程序
      │
      ▼
┌─────────────────┐
│  连接层处理      │ ← 身份验证、连接池管理
│ Connection Layer │
└─────────────────┘
      │
      ▼
┌─────────────────┐
│  查询缓存检查    │ ← Query Cache（MySQL 8.0已移除）
│  Query Cache     │
└─────────────────┘
      │ cache miss
      ▼
┌─────────────────┐
│  解析器处理      │ ← 词法分析、语法分析
│  Parser          │
└─────────────────┘
      │
      ▼
┌─────────────────┐
│  优化器处理      │ ← 查询计划生成、成本估算
│  Optimizer       │
└─────────────────┘
      │
      ▼
┌─────────────────┐
│  执行器处理      │ ← 权限检查、执行计划调用
│  Executor        │
└─────────────────┘
      │
      ▼
┌─────────────────┐
│  存储引擎操作    │ ← InnoDB/MyISAM数据读写
│  Storage Engine  │
└─────────────────┘
```

### 2.2 连接层Connection Layer处理 🔥


**🔌 连接建立与管理**
```
连接层主要职责：
├── 身份验证：验证用户名密码
├── 权限获取：加载用户权限信息
├── 连接管理：维护客户端连接状态
├── 线程分配：为连接分配处理线程
└── 协议处理：处理不同的通信协议

连接建立流程：
客户端连接请求 → 身份验证 → 权限检查 → 分配线程 → 连接建立
```

**💡 连接层关键配置**
```sql
-- 查看连接相关配置
SHOW VARIABLES LIKE 'max_connections';        -- 最大连接数
SHOW VARIABLES LIKE 'wait_timeout';           -- 连接超时时间
SHOW VARIABLES LIKE 'interactive_timeout';    -- 交互式连接超时

-- 查看当前连接状态
SHOW PROCESSLIST;  -- 显示当前所有连接
```

### 2.3 查询缓存Query Cache处理 🔥


**⚠️ 重要说明：MySQL 8.0已完全移除Query Cache功能**

**🗂️ Query Cache工作原理（历史功能）**
```
查询缓存机制：
┌─────────────────────────────┐
│ SQL语句 → 计算HASH值        │
│    ↓                       │
│ 检查缓存中是否存在该HASH     │
│    ↓                       │
│ 存在：直接返回缓存结果       │
│ 不存在：执行查询并缓存结果   │
└─────────────────────────────┘

缓存失效条件：
• 表结构发生变化
• 表数据发生任何修改
• 查询语句完全不同（大小写敏感）
```

**🚫 为什么MySQL 8.0移除了Query Cache**
- **缓存失效频繁**：任何写操作都会清空相关表的所有缓存
- **锁竞争严重**：查询缓存使用全局锁，高并发性能下降
- **命中率低**：实际生产环境中缓存命中率往往很低
- **维护复杂**：缓存管理逻辑复杂，容易出现问题

---

## 3. 🔍 解析器Parser工作原理


### 3.1 词法分析与语义分析 🔥


**📝 词法分析（Lexical Analysis）过程**
```
原始SQL语句：
SELECT user_name FROM users WHERE age > 18;

词法分析结果：
┌─────────────────────────────────────┐
│ TOKEN_TYPE    │  TOKEN_VALUE        │
├─────────────────────────────────────┤
│ KEYWORD       │  SELECT             │
│ IDENTIFIER    │  user_name          │
│ KEYWORD       │  FROM               │
│ IDENTIFIER    │  users              │
│ KEYWORD       │  WHERE              │
│ IDENTIFIER    │  age                │
│ OPERATOR      │  >                  │
│ NUMBER        │  18                 │
│ DELIMITER     │  ;                  │
└─────────────────────────────────────┘
```

**🌳 语法树生成 🔥**
```
语法树结构示例：
                  SELECT
                /        \
        SELECT_LIST      FROM_CLAUSE
             │                │
         user_name          users
                              │
                        WHERE_CLAUSE
                              │
                         CONDITION
                        /    │    \
                     age     >     18

这棵树描述了SQL语句的完整结构关系
```

### 3.2 语法检查机制 🔸


**✅ 语法检查的层次**
```
第一层：基本语法检查
├── 关键字拼写是否正确
├── 标点符号是否匹配
├── 语句结构是否完整
└── 数据类型是否合法

第二层：语义检查
├── 表名是否存在
├── 字段名是否存在
├── 权限是否满足
└── 数据类型是否兼容
```

**❌ 常见语法错误类型**

| 错误类型 | **示例** | **错误原因** | **正确写法** |
|---------|---------|-------------|-------------|
| 🔸 **拼写错误** | `SLECT * FROM users` | `关键字拼写错误` | `SELECT * FROM users` |
| 🔸 **语法错误** | `SELECT * users` | `缺少FROM关键字` | `SELECT * FROM users` |
| 🔸 **标识符错误** | `SELECT * FROM user-table` | `标识符包含非法字符` | `SELECT * FROM user_table` |
| 🔸 **引号不匹配** | `SELECT 'hello FROM users` | `字符串引号不匹配` | `SELECT 'hello' FROM users` |

### 3.3 语法错误处理流程 🔸


**🔧 错误处理机制**
```
语法错误发现流程：
解析器发现错误 → 记录错误位置 → 生成错误信息 → 返回客户端

错误信息组成：
├── 错误代码：如1064（语法错误）
├── 错误描述：详细的错误说明
├── 错误位置：指出错误在SQL中的位置
└── 修改建议：可能的修正方案
```

**💡 典型错误示例**
```sql
-- 错误的SQL语句
SELECT user_name user_age FROM users WHERE;

-- MySQL错误提示
ERROR 1064 (42000): You have an error in your SQL syntax; 
check the manual that corresponds to your MySQL server version 
for the right syntax to use near 'WHERE' at line 1
```

---

## 4. 🎯 优化器Optimizer处理机制


### 4.1 查询优化器的核心任务


**🧠 优化器的工作内容**
```
查询优化器主要职责：
├── 生成执行计划：确定数据访问路径
├── 选择索引：决定使用哪个索引
├── 确定连接顺序：多表连接的最优顺序
├── 成本估算：评估不同方案的执行成本
└── 计划缓存：缓存执行计划以提高效率
```

**⚖️ 成本估算模型**
```
总成本 = CPU成本 + I/O成本 + 网络成本

具体计算因素：
┌─────────────────────────────┐
│ I/O成本：                   │
│ • 磁盘页面读取次数           │
│ • 随机读取 vs 顺序读取       │
│ • 缓存命中率影响             │
├─────────────────────────────┤
│ CPU成本：                   │
│ • 记录比较次数               │
│ • 函数计算复杂度             │
│ • 排序和分组操作             │
├─────────────────────────────┤
│ 内存成本：                   │
│ • 临时表创建                 │
│ • 排序缓冲区使用             │
│ • 连接缓冲区使用             │
└─────────────────────────────┘
```

### 4.2 执行计划生成过程


**📋 执行计划的组成要素**
```sql
-- 查看执行计划
EXPLAIN SELECT u.name, o.total 
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE u.age > 25;

-- 执行计划输出示例：
+----+-------------+-------+-------+--------+---------+------+
| id | select_type | table | type  | key    | key_len | rows |
+----+-------------+-------+-------+--------+---------+------+
|  1 | SIMPLE      | u     | range | age_idx| 4       | 100  |
|  1 | SIMPLE      | o     | ref   | user_id| 4       | 5    |
+----+-------------+-------+-------+--------+---------+------+
```

**🔍 执行计划关键字段解释**

| 字段名 | **含义** | **重要程度** | **优化关注点** |
|--------|---------|-------------|---------------|
| **type** | `访问类型` | `⭐⭐⭐⭐⭐` | `const > eq_ref > ref > range > ALL` |
| **key** | `使用的索引` | `⭐⭐⭐⭐` | `NULL表示未使用索引，需要优化` |
| **rows** | `扫描行数` | `⭐⭐⭐⭐` | `数值越小越好，影响性能` |
| **Extra** | `额外信息` | `⭐⭐⭐` | `Using filesort、Using temporary需关注` |

### 4.3 索引选择策略


**🎯 索引选择的决策因素**
```
索引选择考虑因素：
├── 选择性：索引列值的唯一性
├── 覆盖性：索引是否包含所需字段
├── 排序性：是否避免额外排序操作
└── 维护成本：索引维护的开销

选择性计算公式：
选择性 = COUNT(DISTINCT column) / COUNT(*)
选择性越接近1，索引效果越好
```

**💡 优化器索引选择示例**
```sql
-- 假设有以下索引：
-- idx_age：单列索引（age）
-- idx_name_age：复合索引（name, age）

-- 查询1：优化器选择idx_age
SELECT * FROM users WHERE age = 25;

-- 查询2：优化器选择idx_name_age（覆盖索引）
SELECT name, age FROM users WHERE age = 25;

-- 查询3：优化器选择idx_name_age（前缀匹配）
SELECT * FROM users WHERE name = 'John' AND age = 25;
```

---

## 5. 🚀 执行器Executor执行过程


### 5.1 执行器的核心职责


**⚙️ 执行器工作流程**
```
执行器处理步骤：
├── 权限检查：验证用户是否有执行权限
├── 执行计划调用：按照优化器生成的计划执行
├── 存储引擎接口：调用存储引擎API
├── 结果集处理：整理查询结果
└── 错误处理：处理执行过程中的异常
```

### 5.2 元数据锁MDL获取 🔥


**🔒 元数据锁的作用**
```
MDL锁保护对象：
├── 表结构信息：防止DDL和DML并发冲突
├── 表的元数据：确保结构信息一致性
├── 存储过程：保护存储过程定义
└── 视图定义：保护视图结构信息

MDL锁类型：
┌─────────────────────────────┐
│ 共享读锁(SHARED_READ)：      │
│ • SELECT语句获取            │
│ • 允许并发读取              │
│ • 阻止表结构修改            │
├─────────────────────────────┤
│ 共享写锁(SHARED_WRITE)：     │
│ • INSERT/UPDATE/DELETE获取  │
│ • 允许并发DML操作           │
│ • 阻止表结构修改            │
├─────────────────────────────┤
│ 排他锁(EXCLUSIVE)：         │
│ • DDL语句获取               │
│ • 阻止所有并发操作          │
│ • 用于表结构修改            │
└─────────────────────────────┘
```

**⚠️ MDL锁等待问题**
```sql
-- 查看MDL锁等待情况
SELECT * FROM information_schema.metadata_locks 
WHERE lock_status = 'PENDING';

-- 常见MDL锁等待场景：
-- 1. 长时间运行的查询阻止DDL操作
-- 2. 未提交的事务持有MDL锁
-- 3. 表维护操作期间的并发访问
```

### 5.3 存储引擎接口调用


**🔌 存储引擎抽象层**
```
执行器与存储引擎的交互：
执行器 → Handler接口 → 具体存储引擎

常见存储引擎操作：
├── 打开表：ha_open()
├── 读取记录：ha_read_first()、ha_read_next()
├── 写入记录：ha_write_row()
├── 更新记录：ha_update_row()
├── 删除记录：ha_delete_row()
└── 关闭表：ha_close()
```

**📊 不同DML操作的执行特点**

| DML类型 | **执行特点** | **存储引擎调用** | **性能考虑** |
|---------|-------------|----------------|-------------|
| **SELECT** | `只读操作，可并发` | `ha_read_*系列` | `索引使用、缓存命中` |
| **INSERT** | `写入操作，需要锁` | `ha_write_row` | `主键冲突、唯一性检查` |
| **UPDATE** | `修改操作，行级锁` | `ha_update_row` | `WHERE条件过滤效率` |
| **DELETE** | `删除操作，行级锁` | `ha_delete_row` | `级联删除、外键约束` |

---

## 6. ⏰ DML语句生命周期管理


### 6.1 从连接到断开的完整周期


**🔄 DML语句完整生命周期**
```
时间轴：客户端连接 → SQL执行 → 结果返回 → 连接释放

详细阶段：
┌─────────────────────────────────────────────┐
│ 1. 连接建立(Connection Establishment)        │
│    ├── TCP连接建立                          │
│    ├── MySQL握手协议                        │
│    └── 身份验证完成                          │
├─────────────────────────────────────────────┤
│ 2. SQL接收与排队(SQL Reception & Queue)      │
│    ├── 接收SQL语句                          │
│    ├── 语句排队等待                          │
│    └── 分配处理线程                          │
├─────────────────────────────────────────────┤
│ 3. SQL解析与优化(Parse & Optimize)          │
│    ├── 词法语法分析                          │
│    ├── 查询计划生成                          │
│    └── 执行方案确定                          │
├─────────────────────────────────────────────┤
│ 4. 执行与数据访问(Execute & Data Access)     │
│    ├── MDL锁获取                            │
│    ├── 存储引擎调用                          │
│    └── 数据读写操作                          │
├─────────────────────────────────────────────┤
│ 5. 结果返回(Result Return)                  │
│    ├── 结果集格式化                          │
│    ├── 网络传输返回                          │
│    └── 资源清理释放                          │
└─────────────────────────────────────────────┘
```

### 6.2 性能监控与诊断


**📊 关键性能指标**
```sql
-- 查看SQL执行统计
SELECT * FROM performance_schema.events_statements_summary_by_digest 
ORDER BY avg_timer_wait DESC LIMIT 10;

-- 查看慢查询日志
SHOW VARIABLES LIKE 'slow_query_log%';
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;

-- 实时监控SQL执行
SHOW PROCESSLIST;
```

**⚡ 性能优化检查清单**
- ✅ **索引使用情况**：是否使用了合适的索引
- ✅ **执行计划分析**：type字段是否为const、eq_ref、ref
- ✅ **扫描行数**：rows字段是否过大
- ✅ **临时表使用**：Extra字段是否有Using temporary
- ✅ **排序操作**：Extra字段是否有Using filesort
- ✅ **锁等待时间**：是否存在锁争用问题

### 6.3 错误处理与恢复机制


**🔧 错误分类与处理**
```
SQL执行错误分类：
├── 语法错误：解析阶段发现，立即返回
├── 权限错误：执行前检查，拒绝执行
├── 数据错误：执行过程中发现，回滚操作
└── 系统错误：资源不足等，延迟重试

错误恢复策略：
┌─────────────────────────────┐
│ 自动重试：                   │
│ • 死锁检测后自动重试         │
│ • 临时资源不足时重试         │
├─────────────────────────────┤
│ 事务回滚：                   │
│ • 数据完整性错误时回滚       │
│ • 约束违反时回滚             │
├─────────────────────────────┤
│ 连接重置：                   │
│ • 连接异常时重建连接         │
│ • 超时后重新建立会话         │
└─────────────────────────────┘
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 DML分类：SELECT查询、INSERT插入、UPDATE更新、DELETE删除
🔸 执行流程：连接→解析→优化→执行→返回五个核心阶段
🔸 解析器：词法分析→语法分析→语法树生成的完整过程
🔸 优化器：执行计划生成、索引选择、成本估算的决策机制
🔸 执行器：MDL锁获取、存储引擎调用、结果集处理的执行过程
```

### 7.2 关键理解要点


**🔹 为什么需要这么复杂的执行流程**
```
性能优化需要：
• 解析器确保SQL语句正确无误
• 优化器选择最高效的执行方案
• 执行器协调各组件协同工作
• 缓存机制减少重复计算开销

安全性保障：
• 连接层进行身份验证和权限控制
• 解析器防止SQL注入等安全问题
• MDL锁保证并发操作的数据一致性
```

**🔹 执行效率的关键影响因素**
```
解析阶段：
• 语法复杂度影响解析时间
• 预编译语句可以跳过解析过程

优化阶段：
• 表统计信息准确性影响计划质量
• 索引设计直接影响执行效率

执行阶段：
• 锁争用情况影响并发性能
• 存储引擎特性影响I/O效率
```

### 7.3 实际应用指导


**🎯 性能优化的实践建议**

```
SQL编写最佳实践：
├── 避免SELECT *，只查询需要的字段
├── 合理使用WHERE条件，提高过滤效率
├── 适当使用LIMIT限制结果集大小
└── 预编译语句减少解析开销

索引设计原则：
├── 为WHERE条件创建合适索引
├── 考虑覆盖索引减少回表操作
├── 复合索引注意字段顺序
└── 定期维护索引统计信息

监控和诊断：
├── 定期分析慢查询日志
├── 使用EXPLAIN分析执行计划
├── 监控MDL锁等待情况
└── 关注系统资源使用情况
```

**🔧 故障诊断思路**
- **语法错误**：检查SQL语句拼写和结构
- **性能问题**：分析执行计划，检查索引使用
- **锁等待**：查看当前会话和锁状态
- **权限问题**：确认用户权限配置
- **资源不足**：监控内存、CPU、磁盘使用情况

**核心记忆**：
- DML是日常使用最频繁的SQL语句类型
- SQL执行经历连接、解析、优化、执行、返回五个阶段
- 理解执行流程有助于性能优化和问题诊断
- 优化器的执行计划选择直接影响查询性能
- MDL锁机制保障并发操作的数据一致性