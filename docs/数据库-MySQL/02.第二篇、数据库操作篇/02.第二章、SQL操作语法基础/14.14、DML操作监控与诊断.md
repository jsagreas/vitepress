---
title: 14、DML操作监控与诊断
---
## 📚 目录

1. [DML监控概述](#1-dml监控概述)
2. [DML性能监控指标](#2-dml性能监控指标)
3. [慢查询日志分析](#3-慢查询日志分析)
4. [Performance_Schema监控](#4-performance_schema监控)
5. [INFORMATION_SCHEMA统计表](#5-information_schema统计表)
6. [sys监控视图](#6-sys监控视图)
7. [events_statements_summary监控](#7-events_statements_summary监控)
8. [DML操作行数统计ROW_COUNT()](#8-dml操作行数统计row_count)
9. [Handler状态变量监控](#9-handler状态变量监控)
10. [InnoDB监控指标](#10-innodb监控指标)
11. [实时性能诊断](#11-实时性能诊断)
12. [异常检测与告警](#12-异常检测与告警)
13. [核心要点总结](#13-核心要点总结)

---

## 1. 🔍 DML监控概述


### 1.1 什么是DML操作监控


**💡 监控的本质**
DML操作监控就像给数据库装了一个"健康监测仪"，实时观察INSERT、UPDATE、DELETE操作的执行情况。

```
简单理解：
就像医院里的心电监护仪：
- 实时显示心跳 → 实时显示SQL执行
- 记录异常波动 → 记录慢查询和错误
- 预警危险状态 → 预警性能问题

让我们能及时发现和解决数据库性能问题
```

### 1.2 监控的重要意义


**🎯 核心价值**
- **性能优化**：找出执行慢的DML语句进行优化
- **资源管控**：监控CPU、内存、IO使用情况
- **问题定位**：快速定位数据库性能瓶颈
- **容量规划**：基于历史数据预测未来需求
- **故障预防**：提前发现潜在问题

### 1.3 监控体系架构


```
MySQL监控体系架构：

应用层监控
    ↓
慢查询日志 ← → Performance_Schema ← → INFORMATION_SCHEMA
    ↓                    ↓                      ↓
系统状态变量 ← → InnoDB状态监控 ← → sys监控视图
    ↓                    ↓                      ↓
实时诊断工具 ← → 告警系统 ← → 性能分析报告
```

---

## 2. 📊 DML性能监控指标


### 2.1 核心性能指标分类


**⚡ 执行性能指标**
```
执行时间类：
- 查询执行时间 → 衡量SQL响应速度
- 锁等待时间 → 衡量并发冲突程度
- IO等待时间 → 衡量存储性能影响

执行效率类：
- 扫描行数 → 衡量查询效率
- 返回行数 → 衡量结果集大小
- 索引使用率 → 衡量索引优化程度
```

**🔢 操作统计指标**
```sql
-- 查看DML操作统计
SHOW GLOBAL STATUS LIKE 'Com_select';
SHOW GLOBAL STATUS LIKE 'Com_insert';  
SHOW GLOBAL STATUS LIKE 'Com_update';
SHOW GLOBAL STATUS LIKE 'Com_delete';

-- 结果示例：
-- Com_select: 125847    -- SELECT语句执行次数
-- Com_insert: 8934      -- INSERT语句执行次数  
-- Com_update: 3421      -- UPDATE语句执行次数
-- Com_delete: 567       -- DELETE语句执行次数
```

### 2.2 关键性能指标详解


**📈 QPS/TPS指标**
```sql
-- 计算每秒查询数(QPS)
SELECT 
    VARIABLE_VALUE as current_queries,
    (@previous := IFNULL(@previous, VARIABLE_VALUE)) as previous,
    (VARIABLE_VALUE - @previous) as queries_per_second
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Queries';

-- 计算事务处理数(TPS)  
SELECT 
    VARIABLE_VALUE as current_commits,
    (@prev_commit := IFNULL(@prev_commit, VARIABLE_VALUE)) as prev,
    (VARIABLE_VALUE - @prev_commit) as transactions_per_second
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Com_commit';
```

**📊 响应时间分布**
```sql
-- 查看查询执行时间分布
SELECT 
    COUNT_STAR as query_count,
    AVG_TIMER_WAIT/1000000000 as avg_duration_seconds,
    MAX_TIMER_WAIT/1000000000 as max_duration_seconds
FROM performance_schema.events_statements_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'statement/sql/%'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 10;
```

### 2.3 资源使用监控


**💾 内存使用指标**
```sql
-- 查看内存相关状态
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    VARIABLE_VALUE/1024/1024 as value_mb
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN (
    'Innodb_buffer_pool_pages_total',
    'Innodb_buffer_pool_pages_data', 
    'Innodb_buffer_pool_pages_dirty',
    'Innodb_buffer_pool_pages_free'
);
```

**💿 IO操作指标**
```sql
-- 查看IO相关统计
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN (
    'Innodb_data_reads',        -- 数据页读取次数
    'Innodb_data_writes',       -- 数据页写入次数
    'Innodb_data_read',         -- 读取的数据量
    'Innodb_data_written',      -- 写入的数据量
    'Innodb_log_writes'         -- 日志写入次数
);
```

### 2.4 监控指标阈值设定


**⚠️ 关键阈值参考**

| 指标类型 | **监控项** | **正常范围** | **警告阈值** | **严重阈值** |
|---------|-----------|-------------|-------------|-------------|
| **响应时间** | `平均查询时间` | `< 100ms` | `> 500ms` | `> 2s` |
| **并发度** | `Threads_running` | `< CPU核数×2` | `> CPU核数×4` | `> CPU核数×8` |
| **缓存命中** | `Buffer Pool命中率` | `> 95%` | `< 90%` | `< 80%` |
| **锁等待** | `平均锁等待时间` | `< 10ms` | `> 100ms` | `> 1s` |

---

## 3. 🐌 慢查询日志分析


### 3.1 慢查询日志基础配置


**⚙️ 启用慢查询日志**
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;

-- 设置慢查询时间阈值（单位：秒）
SET GLOBAL long_query_time = 2;

-- 记录未使用索引的查询
SET GLOBAL log_queries_not_using_indexes = ON;

-- 设置日志文件位置
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';

-- 查看当前配置
SHOW VARIABLES LIKE '%slow%';
```

### 3.2 慢查询日志格式解读


**📄 日志条目示例**
```
# Time: 2025-01-21T11:30:45.123456Z
# User@Host: webapp[webapp] @ [192.168.1.100]
# Thread_id: 123  Schema: ecommerce  QC_hit: No
# Query_time: 5.234567  Lock_time: 0.000123  Rows_sent: 1000  Rows_examined: 50000
# Rows_affected: 0  Bytes_sent: 45678
SET timestamp=1642771845;
SELECT u.name, COUNT(o.id) as order_count 
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.created_at > '2024-01-01' 
GROUP BY u.id 
ORDER BY order_count DESC;
```

**🔍 关键字段含义**
```
Query_time: 5.234567     → 查询执行时间：5.23秒
Lock_time: 0.000123      → 锁等待时间：0.12毫秒  
Rows_sent: 1000          → 返回给客户端的行数
Rows_examined: 50000     → 扫描检查的行数
Rows_affected: 0         → 影响的行数（INSERT/UPDATE/DELETE）

效率分析：
扫描50000行，只返回1000行，效率较低，需要优化
```

### 3.3 慢查询日志分析工具


**🛠️ mysqldumpslow工具**
```bash
# 分析慢查询日志
mysqldumpslow /var/log/mysql/slow.log

# 显示最耗时的10个查询
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 显示扫描行数最多的10个查询  
mysqldumpslow -s r -t 10 /var/log/mysql/slow.log

# 显示访问次数最多的10个查询
mysqldumpslow -s c -t 10 /var/log/mysql/slow.log

# 过滤掉锁等待时间，只看查询时间
mysqldumpslow -s t -t 10 -g 'Lock_time: 0' /var/log/mysql/slow.log
```

### 3.4 慢查询分析实战


**📊 典型慢查询分析**
```sql
-- 示例慢查询
SELECT 
    u.username,
    COUNT(o.id) as order_count,
    SUM(o.amount) as total_amount
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
WHERE u.status = 'active' 
  AND o.created_at >= '2024-01-01'
GROUP BY u.id, u.username
ORDER BY total_amount DESC
LIMIT 100;

-- 使用EXPLAIN分析执行计划
EXPLAIN FORMAT=JSON 
SELECT u.username, COUNT(o.id) as order_count...;
```

**🔧 优化建议**
```sql
-- 针对上述慢查询的优化措施：

-- 1. 添加复合索引
CREATE INDEX idx_users_status_id ON users(status, id);
CREATE INDEX idx_orders_userid_createdat ON orders(user_id, created_at);

-- 2. 优化查询条件
-- 将条件前置，减少JOIN后的数据量
SELECT 
    u.username,
    sub.order_count,
    sub.total_amount
FROM users u
INNER JOIN (
    SELECT 
        user_id,
        COUNT(id) as order_count,
        SUM(amount) as total_amount
    FROM orders 
    WHERE created_at >= '2024-01-01'
    GROUP BY user_id
) sub ON u.id = sub.user_id
WHERE u.status = 'active'
ORDER BY sub.total_amount DESC
LIMIT 100;
```

---

## 4. 📈 Performance_Schema监控


### 4.1 Performance_Schema简介


**💡 什么是Performance_Schema**
Performance_Schema是MySQL的性能监控引擎，就像数据库的"黑匣子"，详细记录所有操作的性能数据。

```
功能特点：
- 实时监控 → 不需要重启数据库
- 详细记录 → 记录每个操作的详细信息  
- 低开销 → 对性能影响很小
- 可配置 → 可以选择监控哪些事件
```

### 4.2 启用Performance_Schema


**⚙️ 基础配置**
```sql
-- 检查Performance_Schema是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 如果未启用，需要在my.cnf中添加：
-- [mysqld]
-- performance_schema = ON

-- 查看监控的事件类型
SELECT * FROM performance_schema.setup_instruments
WHERE NAME LIKE '%statement%' AND ENABLED = 'YES';

-- 查看监控的消费者
SELECT * FROM performance_schema.setup_consumers
WHERE ENABLED = 'YES';
```

### 4.3 核心监控表介绍


**📋 主要监控表分类**
```
实时监控表：
- events_statements_current     → 当前执行的语句
- events_waits_current         → 当前等待事件
- processlist                  → 进程列表

历史监控表：
- events_statements_history    → 最近的语句历史
- events_statements_summary_*  → 语句执行统计摘要

配置管理表：
- setup_instruments           → 监控项配置
- setup_consumers            → 消费者配置
```

### 4.4 实时监控应用


**🔴 监控当前执行的DML操作**
```sql
-- 查看当前正在执行的语句
SELECT 
    THREAD_ID,
    EVENT_ID,
    CURRENT_SCHEMA,
    SQL_TEXT,
    TIMER_WAIT/1000000000 as duration_seconds,
    LOCK_TIME/1000000000 as lock_seconds,
    ROWS_SENT,
    ROWS_EXAMINED
FROM performance_schema.events_statements_current
WHERE SQL_TEXT IS NOT NULL
ORDER BY TIMER_WAIT DESC;

-- 查看正在等待的事件
SELECT 
    THREAD_ID,
    EVENT_NAME,
    TIMER_WAIT/1000000000 as wait_seconds,
    OBJECT_SCHEMA,
    OBJECT_NAME,
    OPERATION
FROM performance_schema.events_waits_current
WHERE TIMER_WAIT IS NOT NULL
ORDER BY TIMER_WAIT DESC;
```

**📊 历史执行统计**
```sql
-- 查看最近执行的DML语句统计
SELECT 
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000 as avg_duration,
    MAX_TIMER_WAIT/1000000000 as max_duration,
    SUM_ROWS_SENT as total_rows_sent,
    SUM_ROWS_EXAMINED as total_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME IS NOT NULL
  AND DIGEST_TEXT LIKE '%UPDATE%' OR DIGEST_TEXT LIKE '%INSERT%' OR DIGEST_TEXT LIKE '%DELETE%'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;
```

---

## 5. 📊 INFORMATION_SCHEMA统计表


### 5.1 INFORMATION_SCHEMA概述


**💡 统计表的作用**
INFORMATION_SCHEMA是MySQL的"信息中心"，存储了数据库的元数据和统计信息，让我们可以查询数据库的结构和状态。

```
主要功能：
- 数据库结构信息 → 表、列、索引结构
- 统计信息 → 表大小、行数、索引使用情况
- 状态信息 → 服务器状态、变量值
- 权限信息 → 用户权限、角色信息
```

### 5.2 核心统计表详解


**📋 重要统计表**
```sql
-- TABLES表：表的统计信息
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_ROWS,                    -- 估算行数
    DATA_LENGTH/1024/1024 as data_mb,     -- 数据大小MB
    INDEX_LENGTH/1024/1024 as index_mb,   -- 索引大小MB
    AUTO_INCREMENT,                -- 自增值
    CREATE_TIME,                   -- 创建时间
    UPDATE_TIME                    -- 更新时间
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY DATA_LENGTH DESC;

-- COLUMNS表：列的详细信息
SELECT 
    TABLE_NAME,
    COLUMN_NAME,
    DATA_TYPE,
    IS_NULLABLE,
    COLUMN_DEFAULT,
    CHARACTER_SET_NAME,
    COLLATION_NAME
FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = 'your_database'
  AND TABLE_NAME = 'users';
```

### 5.3 统计信息查询实例


**🔍 表空间使用统计**
```sql
-- 查看数据库空间使用情况
SELECT 
    TABLE_SCHEMA as database_name,
    COUNT(*) as table_count,
    ROUND(SUM(DATA_LENGTH)/1024/1024, 2) as data_mb,
    ROUND(SUM(INDEX_LENGTH)/1024/1024, 2) as index_mb,
    ROUND(SUM(DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) as total_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
GROUP BY TABLE_SCHEMA
ORDER BY total_mb DESC;

-- 查看最大的表
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_ROWS,
    ROUND(DATA_LENGTH/1024/1024, 2) as data_mb,
    ROUND(INDEX_LENGTH/1024/1024, 2) as index_mb,
    ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) as total_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC
LIMIT 10;
```

### 5.4 索引使用情况分析


**📊 索引统计分析**
```sql
-- 查看索引信息
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX,          -- 在索引中的位置
    CARDINALITY,           -- 唯一值数量
    INDEX_TYPE             -- 索引类型
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
  AND TABLE_NAME = 'orders'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 查找没有主键的表
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME
FROM information_schema.TABLES t
WHERE t.TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
  AND NOT EXISTS (
    SELECT 1 FROM information_schema.STATISTICS s
    WHERE s.TABLE_SCHEMA = t.TABLE_SCHEMA
      AND s.TABLE_NAME = t.TABLE_NAME
      AND s.INDEX_NAME = 'PRIMARY'
  );
```

---

## 6. 👁️ sys监控视图


### 6.1 sys数据库简介


**💡 sys数据库的优势**
sys数据库是MySQL 5.7+版本提供的监控视图集合，将Performance_Schema的复杂查询封装成易用的视图。

```
主要优势：
- 开箱即用 → 预定义的监控视图，直接查询
- 人性化 → 结果易读，单位自动转换
- 全面覆盖 → 涵盖性能、IO、内存、锁等各个方面
- 持续更新 → MySQL官方维护，跟随版本升级
```

### 6.2 核心监控视图


**📊 语句分析视图**
```sql
-- 查看执行最慢的语句
SELECT * FROM sys.statements_with_runtimes_in_95th_percentile
LIMIT 10;

-- 查看全表扫描的语句
SELECT * FROM sys.statements_with_full_table_scans
LIMIT 10;

-- 查看临时表使用情况
SELECT * FROM sys.statements_with_temp_tables
LIMIT 10;

-- 查看排序使用情况
SELECT * FROM sys.statements_with_sorting
LIMIT 10;
```

### 6.3 IO监控视图


**💿 IO性能分析**
```sql
-- 查看IO使用最多的文件
SELECT * FROM sys.io_global_by_file_by_bytes
LIMIT 10;

-- 查看IO等待最多的文件
SELECT * FROM sys.io_global_by_wait_by_latency
LIMIT 10;

-- 查看表的IO统计
SELECT * FROM sys.io_by_thread_by_latency
WHERE user IS NOT NULL
LIMIT 10;
```

### 6.4 用户和连接监控


**👥 用户活动监控**
```sql
-- 查看用户连接统计
SELECT * FROM sys.user_summary;

-- 查看用户的语句统计
SELECT * FROM sys.user_summary_by_statement_type;

-- 查看用户的文件IO统计  
SELECT * FROM sys.user_summary_by_file_io;

-- 当前活跃连接
SELECT 
    conn_id,
    user,
    db,
    command,
    current_statement,
    statement_latency,
    progress,
    lock_latency,
    rows_examined,
    rows_sent
FROM sys.processlist
WHERE command != 'Sleep'
ORDER BY statement_latency DESC;
```

### 6.5 内存使用监控


**🧠 内存分析视图**
```sql
-- 查看内存使用概览
SELECT * FROM sys.memory_global_total;

-- 按用户查看内存使用
SELECT * FROM sys.memory_by_user_by_current_bytes
ORDER BY current_allocated DESC;

-- 按线程查看内存使用
SELECT * FROM sys.memory_by_thread_by_current_bytes
WHERE thread_id IS NOT NULL
ORDER BY current_allocated DESC
LIMIT 10;

-- 按事件查看内存使用
SELECT * FROM sys.memory_global_by_current_bytes
ORDER BY current_allocated DESC
LIMIT 10;
```

---

## 7. 📈 events_statements_summary监控


### 7.1 statements_summary表详解


**💡 摘要表的作用**
events_statements_summary系列表是Performance_Schema中最重要的监控表，记录SQL语句执行的统计摘要信息。

```
摘要表分类：
- events_statements_summary_global_by_event_name    → 按事件名全局统计
- events_statements_summary_by_digest               → 按SQL摘要统计  
- events_statements_summary_by_thread_by_event_name → 按线程和事件统计
- events_statements_summary_by_user_by_event_name   → 按用户和事件统计
- events_statements_summary_by_host_by_event_name   → 按主机和事件统计
```

### 7.2 核心统计字段


**📊 重要统计字段说明**
```sql
-- 查看字段含义
DESCRIBE performance_schema.events_statements_summary_by_digest;

/*
关键字段说明：
COUNT_STAR          → 执行次数
SUM_TIMER_WAIT      → 总执行时间
MIN_TIMER_WAIT      → 最短执行时间  
AVG_TIMER_WAIT      → 平均执行时间
MAX_TIMER_WAIT      → 最长执行时间

SUM_LOCK_TIME       → 总锁等待时间
SUM_ERRORS          → 错误总数
SUM_WARNINGS        → 警告总数

SUM_ROWS_AFFECTED   → 影响行数总和
SUM_ROWS_SENT       → 发送行数总和
SUM_ROWS_EXAMINED   → 扫描行数总和

SUM_SELECT_FULL_JOIN      → 全表连接次数
SUM_SELECT_FULL_RANGE_JOIN → 范围连接次数
SUM_SELECT_RANGE          → 范围查询次数
SUM_SELECT_SCAN           → 全表扫描次数
SUM_SORT_MERGE_PASSES     → 排序合并次数
SUM_SORT_RANGE            → 排序范围查询次数
SUM_SORT_ROWS             → 排序行数
SUM_SORT_SCAN             → 排序扫描次数
*/
```

### 7.3 性能分析实战


**🔍 SQL性能Top分析**
```sql
-- 查看平均执行时间最长的SQL
SELECT 
    SCHEMA_NAME as db_name,
    DIGEST_TEXT as sql_text,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec,
    MAX_TIMER_WAIT/1000000000 as max_time_sec,
    SUM_ROWS_EXAMINED/COUNT_STAR as avg_rows_examined,
    SUM_ROWS_SENT/COUNT_STAR as avg_rows_sent
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME IS NOT NULL
  AND COUNT_STAR > 0
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;

-- 查看执行次数最多的SQL
SELECT 
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 100) as sql_snippet,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec,
    SUM_TIMER_WAIT/1000000000 as total_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME IS NOT NULL
ORDER BY COUNT_STAR DESC
LIMIT 20;
```

### 7.4 DML操作统计分析


**🔧 DML操作深度分析**
```sql
-- 分析UPDATE操作性能
SELECT 
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR as update_count,
    AVG_TIMER_WAIT/1000000000 as avg_duration,
    SUM_ROWS_AFFECTED as total_rows_updated,
    SUM_ROWS_EXAMINED as total_rows_scanned,
    ROUND(SUM_ROWS_EXAMINED/SUM_ROWS_AFFECTED, 2) as scan_to_update_ratio
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%UPDATE%'
  AND SCHEMA_NAME IS NOT NULL
  AND SUM_ROWS_AFFECTED > 0
ORDER BY scan_to_update_ratio DESC
LIMIT 10;

-- 分析INSERT操作性能
SELECT 
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR as insert_count,
    AVG_TIMER_WAIT/1000000000 as avg_duration,
    SUM_ROWS_AFFECTED as total_rows_inserted,
    SUM_ERRORS as error_count,
    SUM_WARNINGS as warning_count
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%INSERT%'
  AND SCHEMA_NAME IS NOT NULL
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 10;
```

### 7.5 监控数据重置和维护


**🔄 摘要表维护**
```sql
-- 重置所有统计数据
CALL sys.ps_truncate_all_tables(FALSE);

-- 只重置events_statements_summary相关表
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
TRUNCATE TABLE performance_schema.events_statements_summary_global_by_event_name;

-- 查看摘要表数据量
SELECT 
    TABLE_NAME,
    TABLE_ROWS
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'performance_schema'
  AND TABLE_NAME LIKE '%events_statements_summary%';

-- 设置摘要表最大记录数
SELECT * FROM performance_schema.setup_instruments
WHERE NAME = 'statement/sql/select';

-- 如果需要调整，修改my.cnf：
-- performance-schema-max-digest-length = 1024
-- performance-schema-max-sql-text-length = 1024
```

---

## 8. 📊 DML操作行数统计ROW_COUNT()


### 8.1 ROW_COUNT()函数详解


**💡 函数功能说明**
ROW_COUNT()是MySQL内置函数，返回最近一条DML语句影响的行数，是监控DML操作效果的重要工具。

```
函数特点：
- 实时返回 → 执行DML后立即获取影响行数
- 仅限DML → 只对INSERT、UPDATE、DELETE有效
- 会话级别 → 每个连接独立计算
- 自动重置 → 每次DML执行后更新
```

### 8.2 ROW_COUNT()使用方法


**🔧 基本使用语法**
```sql
-- 基本语法
SELECT ROW_COUNT();

-- INSERT操作示例
INSERT INTO users (name, email, created_at) 
VALUES 
    ('Alice', 'alice@email.com', NOW()),
    ('Bob', 'bob@email.com', NOW()),
    ('Charlie', 'charlie@email.com', NOW());
    
SELECT ROW_COUNT();  -- 返回：3（插入了3行）

-- UPDATE操作示例
UPDATE users 
SET last_login = NOW() 
WHERE created_at >= '2025-01-01';

SELECT ROW_COUNT();  -- 返回：实际更新的行数

-- DELETE操作示例  
DELETE FROM users 
WHERE status = 'inactive' 
  AND last_login < '2024-01-01';
  
SELECT ROW_COUNT();  -- 返回：实际删除的行数
```

### 8.3 ROW_COUNT()返回值规则


**📋 返回值含义**
```sql
-- 不同情况的返回值
/* 
返回值 > 0：成功影响的行数
返回值 = 0：没有行被影响（条件不匹配）
返回值 = -1：语句返回结果集（SELECT语句）
返回值 = -1：语句失败或不是DML语句
*/

-- 示例验证
-- 情况1：成功更新
UPDATE products SET price = price * 1.1 WHERE category = 'electronics';
SELECT ROW_COUNT();  -- 假设返回：150

-- 情况2：条件不匹配，没有行被更新
UPDATE products SET price = 999 WHERE id = 999999;  -- 不存在的ID
SELECT ROW_COUNT();  -- 返回：0

-- 情况3：SELECT语句
SELECT * FROM products LIMIT 10;
SELECT ROW_COUNT();  -- 返回：-1

-- 情况4：语法错误
UPDATE products SET invalid_column = 123;  -- 错误的列名
SELECT ROW_COUNT();  -- 返回：-1
```

### 8.4 实际应用场景


**🎯 业务应用实例**
```sql
-- 场景1：批量操作验证
DELIMITER //
CREATE PROCEDURE update_user_status()
BEGIN
    DECLARE affected_rows INT DEFAULT 0;
    
    -- 执行批量更新
    UPDATE users 
    SET status = 'inactive' 
    WHERE last_login < DATE_SUB(NOW(), INTERVAL 90 DAY);
    
    -- 获取影响行数
    SET affected_rows = ROW_COUNT();
    
    -- 记录日志
    INSERT INTO operation_log (operation, affected_rows, created_at)
    VALUES ('deactivate_inactive_users', affected_rows, NOW());
    
    -- 返回结果
    SELECT CONCAT('Updated ', affected_rows, ' users') as result;
END //
DELIMITER ;

-- 场景2：安全删除验证
DELIMITER //
CREATE PROCEDURE safe_delete_orders(IN days_old INT)
BEGIN
    DECLARE del_count INT DEFAULT 0;
    
    -- 执行删除
    DELETE FROM orders 
    WHERE status = 'cancelled' 
      AND created_at < DATE_SUB(NOW(), INTERVAL days_old DAY);
    
    -- 检查删除行数
    SET del_count = ROW_COUNT();
    
    -- 如果删除过多，回滚
    IF del_count > 1000 THEN
        ROLLBACK;
        SELECT 'Operation cancelled: too many rows affected' as warning;
    ELSE
        COMMIT;
        SELECT CONCAT('Successfully deleted ', del_count, ' orders') as result;
    END IF;
END //
DELIMITER ;
```

### 8.5 ROW_COUNT()监控应用


**📊 集成监控系统**
```sql
-- 创建DML操作监控表
CREATE TABLE dml_operation_monitor (
    id INT AUTO_INCREMENT PRIMARY KEY,
    operation_type ENUM('INSERT', 'UPDATE', 'DELETE'),
    table_name VARCHAR(64),
    affected_rows INT,
    execution_time DECIMAL(10,6),
    executed_by VARCHAR(64),
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 监控存储过程
DELIMITER //
CREATE PROCEDURE monitor_dml_operation(
    IN op_type VARCHAR(10),
    IN table_name VARCHAR(64),
    IN sql_text TEXT
)
BEGIN
    DECLARE start_time DECIMAL(20,6);
    DECLARE end_time DECIMAL(20,6);
    DECLARE affected_count INT;
    
    -- 记录开始时间
    SET start_time = UNIX_TIMESTAMP(NOW(6));
    
    -- 执行SQL（这里只是示例，实际需要动态执行）
    -- SET @sql = sql_text;
    -- PREPARE stmt FROM @sql;
    -- EXECUTE stmt;
    -- DEALLOCATE PREPARE stmt;
    
    -- 记录结束时间和影响行数
    SET end_time = UNIX_TIMESTAMP(NOW(6));
    SET affected_count = ROW_COUNT();
    
    -- 插入监控记录
    INSERT INTO dml_operation_monitor 
        (operation_type, table_name, affected_rows, execution_time, executed_by)
    VALUES 
        (op_type, table_name, affected_count, end_time - start_time, USER());
        
END //
DELIMITER ;
```

---

## 9. 🔧 Handler状态变量监控


### 9.1 Handler状态变量概述


**💡 什么是Handler状态变量**
Handler状态变量记录了MySQL存储引擎执行各种操作的统计信息，是深入了解数据库内部操作的重要指标。

```
Handler的含义：
MySQL服务层与存储引擎层之间的接口调用统计
每次SQL执行时，服务层会调用存储引擎的各种Handler方法
这些变量记录了每种操作的累计次数

主要作用：
- 分析查询效率 → 了解是否使用了索引
- 识别性能瓶颈 → 发现过多的全表扫描  
- 优化索引设计 → 基于访问模式优化
```

### 9.2 核心Handler变量详解


**📊 重要Handler变量**
```sql
-- 查看所有Handler状态变量
SHOW STATUS LIKE 'Handler_%';

-- 核心变量解释：
/*
Handler_read_first      → 读取索引第一行的次数
Handler_read_key        → 根据键读取行的次数  
Handler_read_next       → 按索引顺序读取下一行的次数
Handler_read_prev       → 按索引顺序读取上一行的次数
Handler_read_rnd        → 根据固定位置读取行的次数
Handler_read_rnd_next   → 读取数据文件下一行的次数（全表扫描）

Handler_write           → 插入行的次数
Handler_update          → 更新行的次数  
Handler_delete          → 删除行的次数

Handler_commit          → 事务提交次数
Handler_rollback        → 事务回滚次数
*/
```

### 9.3 Handler变量分析实例


**🔍 索引使用效率分析**
```sql
-- 重置Handler计数器（测试前）
FLUSH STATUS;

-- 执行测试查询
SELECT * FROM orders 
WHERE customer_id = 12345 
ORDER BY created_at DESC 
LIMIT 10;

-- 查看Handler统计
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM information_schema.SESSION_STATUS
WHERE VARIABLE_NAME IN (
    'Handler_read_first',
    'Handler_read_key', 
    'Handler_read_next',
    'Handler_read_rnd',
    'Handler_read_rnd_next'
)
AND VARIABLE_VALUE > 0;

/* 结果分析：
Handler_read_key = 1        → 使用了索引定位（好）
Handler_read_next = 9       → 按索引顺序读取了9行（好）
Handler_read_rnd_next = 0   → 没有全表扫描（好）

如果Handler_read_rnd_next很大，说明发生了全表扫描
*/
```

### 9.4 DML操作Handler分析


**🔧 INSERT操作分析**
```sql
-- 重置计数器
FLUSH STATUS;

-- 执行INSERT操作
INSERT INTO products (name, price, category_id, created_at)
VALUES ('New Product', 99.99, 5, NOW());

-- 查看Handler统计
SELECT 
    'Handler_write' as operation,
    VARIABLE_VALUE as count
FROM information_schema.SESSION_STATUS
WHERE VARIABLE_NAME = 'Handler_write'

UNION ALL

SELECT 
    'Handler_read_key' as operation,
    VARIABLE_VALUE as count  
FROM information_schema.SESSION_STATUS
WHERE VARIABLE_NAME = 'Handler_read_key';

/* 
分析结果：
Handler_write = 1           → 插入了1行
Handler_read_key > 0        → 可能检查了唯一性约束或外键
*/
```

**🔄 UPDATE操作分析**
```sql
-- 重置计数器
FLUSH STATUS;

-- 执行UPDATE操作
UPDATE products 
SET price = price * 1.1,
    updated_at = NOW()
WHERE category_id = 5;

-- 查看详细Handler统计
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Handler_read_first' THEN '读取索引第一行'
        WHEN VARIABLE_NAME = 'Handler_read_key' THEN '根据键读取行'
        WHEN VARIABLE_NAME = 'Handler_read_next' THEN '索引顺序读取'
        WHEN VARIABLE_NAME = 'Handler_read_rnd_next' THEN '全表扫描读取'
        WHEN VARIABLE_NAME = 'Handler_update' THEN '更新行数'
        ELSE '其他操作'
    END as description
FROM information_schema.SESSION_STATUS
WHERE VARIABLE_NAME IN (
    'Handler_read_first',
    'Handler_read_key',
    'Handler_read_next', 
    'Handler_read_rnd_next',
    'Handler_update'
)
AND VARIABLE_VALUE > 0;
```

### 9.5 全局Handler监控


**📈 系统级Handler监控**
```sql
-- 创建Handler监控视图
CREATE VIEW handler_monitor AS
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME LIKE '%read%' THEN 'READ_OPERATIONS'
        WHEN VARIABLE_NAME LIKE '%write%' THEN 'WRITE_OPERATIONS'  
        WHEN VARIABLE_NAME LIKE '%commit%' OR VARIABLE_NAME LIKE '%rollback%' THEN 'TRANSACTION_OPERATIONS'
        ELSE 'OTHER_OPERATIONS'
    END as operation_category
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME LIKE 'Handler_%'
  AND VARIABLE_VALUE > 0;

-- 查看读操作统计
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    ROUND(VARIABLE_VALUE * 100.0 / total.total_reads, 2) as percentage
FROM handler_monitor hm,
     (SELECT SUM(VARIABLE_VALUE) as total_reads 
      FROM handler_monitor 
      WHERE operation_category = 'READ_OPERATIONS') total
WHERE hm.operation_category = 'READ_OPERATIONS'
ORDER BY VARIABLE_VALUE DESC;
```

### 9.6 Handler性能诊断


**🚨 性能问题识别**
```sql
-- 识别潜在性能问题
SELECT 
    'Full Table Scans' as issue_type,
    VARIABLE_VALUE as count,
    CASE 
        WHEN VARIABLE_VALUE > 1000000 THEN 'CRITICAL'
        WHEN VARIABLE_VALUE > 100000 THEN 'WARNING' 
        ELSE 'NORMAL'
    END as severity
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Handler_read_rnd_next'

UNION ALL

SELECT 
    'Index Scan Efficiency' as issue_type,
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_key') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_rnd_next' + 1) * 100, 2
    ) as ratio,
    CASE 
        WHEN (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_key') /
             (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_rnd_next' + 1) > 10 
        THEN 'GOOD'
        WHEN (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_key') /
             (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_rnd_next' + 1) > 1
        THEN 'FAIR'
        ELSE 'POOR'
    END as assessment;

-- Handler操作比率分析
SELECT 
    'Index Usage Ratio' as metric,
    ROUND(
        (h_key.key_reads + h_next.next_reads) * 100.0 / 
        (h_key.key_reads + h_next.next_reads + h_rnd.rnd_reads), 2
    ) as percentage
FROM 
    (SELECT VARIABLE_VALUE as key_reads FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_key') h_key,
    (SELECT VARIABLE_VALUE as next_reads FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_next') h_next,
    (SELECT VARIABLE_VALUE as rnd_reads FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Handler_read_rnd_next') h_rnd;
```

---

## 10. 🏗️ InnoDB监控指标


### 10.1 InnoDB监控体系概述


**💡 InnoDB监控的重要性**
InnoDB是MySQL最重要的存储引擎，其性能直接影响整个数据库系统。监控InnoDB各项指标能帮助我们深入了解存储层的运行状况。

```
InnoDB监控维度：
- 缓冲池监控 → 内存使用效率
- 事务监控 → 并发处理能力
- 锁监控 → 锁争用情况
- IO监控 → 磁盘读写性能
- 日志监控 → 事务日志状态
```

### 10.2 InnoDB缓冲池监控


**🧠 缓冲池性能指标**
```sql
-- 查看缓冲池基本状态
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_total' THEN '总页数'
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_data' THEN '数据页数'
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_free' THEN '空闲页数'
        WHEN VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty' THEN '脏页数'
        ELSE '其他'
    END as description
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME IN (
    'Innodb_buffer_pool_pages_total',
    'Innodb_buffer_pool_pages_data', 
    'Innodb_buffer_pool_pages_free',
    'Innodb_buffer_pool_pages_dirty'
);

-- 计算缓冲池使用率
SELECT 
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
    ) as buffer_pool_usage_percent,
    
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
    ) as dirty_page_percent;
```

**📊 缓冲池命中率分析**
```sql
-- 计算缓冲池命中率
SELECT 
    reads.reads as physical_reads,
    requests.requests as logical_reads,
    ROUND(
        (1 - (reads.reads / requests.requests)) * 100, 4
    ) as buffer_pool_hit_ratio_percent
FROM 
    (SELECT VARIABLE_VALUE as reads FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') reads,
    (SELECT VARIABLE_VALUE as requests FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') requests;

-- 缓冲池详细统计
SELECT 
    'Read Requests' as metric,
    FORMAT(VARIABLE_VALUE, 0) as value
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'

UNION ALL

SELECT 
    'Physical Reads' as metric,
    FORMAT(VARIABLE_VALUE, 0) as value
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads'

UNION ALL

SELECT 
    'Read Ahead' as metric,
    FORMAT(VARIABLE_VALUE, 0) as value
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead'

UNION ALL

SELECT 
    'Read Ahead Evicted' as metric,
    FORMAT(VARIABLE_VALUE, 0) as value
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_ahead_evicted';
```

### 10.3 InnoDB锁监控


**🔒 锁状态监控**
```sql
-- 查看当前锁等待情况
SELECT 
    r.trx_id as waiting_trx_id,
    r.trx_mysql_thread_id as waiting_thread,
    r.trx_query as waiting_query,
    b.trx_id as blocking_trx_id,
    b.trx_mysql_thread_id as blocking_thread,
    b.trx_query as blocking_query
FROM information_schema.INNODB_LOCK_WAITS w
INNER JOIN information_schema.INNODB_TRX r ON r.trx_id = w.requesting_trx_id
INNER JOIN information_schema.INNODB_TRX b ON b.trx_id = w.blocking_trx_id;

-- 查看锁等待统计
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Innodb_row_lock_current_waits' THEN '当前等待行锁数'
        WHEN VARIABLE_NAME = 'Innodb_row_lock_waits' THEN '总行锁等待次数' 
        WHEN VARIABLE_NAME = 'Innodb_row_lock_time' THEN '总行锁等待时间(ms)'
        WHEN VARIABLE_NAME = 'Innodb_row_lock_time_avg' THEN '平均行锁等待时间(ms)'
        WHEN VARIABLE_NAME = 'Innodb_row_lock_time_max' THEN '最大行锁等待时间(ms)'
        ELSE '其他'
    END as description
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME LIKE 'Innodb_row_lock%';
```

### 10.4 InnoDB事务监控


**⚡ 事务状态分析**
```sql
-- 查看活跃事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_requested_lock_id,
    trx_wait_started,
    trx_weight,
    trx_mysql_thread_id,
    trx_query,
    trx_rows_locked,
    trx_rows_modified
FROM information_schema.INNODB_TRX
ORDER BY trx_started;

-- 事务统计信息
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Innodb_trx_rseg_history_len' THEN 'Undo日志长度'
        WHEN VARIABLE_NAME = 'Com_begin' THEN 'BEGIN语句数'
        WHEN VARIABLE_NAME = 'Com_commit' THEN 'COMMIT语句数'
        WHEN VARIABLE_NAME = 'Com_rollback' THEN 'ROLLBACK语句数'
        ELSE '其他'
    END as description
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME IN (
    'Innodb_trx_rseg_history_len',
    'Com_begin',
    'Com_commit', 
    'Com_rollback'
);
```

### 10.5 InnoDB IO监控


**💿 IO性能监控**
```sql
-- InnoDB数据文件IO统计
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Innodb_data_reads' THEN '数据读取次数'
        WHEN VARIABLE_NAME = 'Innodb_data_writes' THEN '数据写入次数'
        WHEN VARIABLE_NAME = 'Innodb_data_read' THEN '读取数据量(字节)'
        WHEN VARIABLE_NAME = 'Innodb_data_written' THEN '写入数据量(字节)'
        WHEN VARIABLE_NAME = 'Innodb_data_fsyncs' THEN '文件同步次数'
        ELSE '其他'
    END as description
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME IN (
    'Innodb_data_reads',
    'Innodb_data_writes',
    'Innodb_data_read', 
    'Innodb_data_written',
    'Innodb_data_fsyncs'
);

-- 计算IO效率指标
SELECT 
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_data_read') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_data_reads')
    ) as avg_read_size_bytes,
    
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_data_written') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_data_writes')  
    ) as avg_write_size_bytes;
```

### 10.6 InnoDB日志监控


**📝 事务日志监控**
```sql
-- InnoDB日志相关状态
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Innodb_log_waits' THEN '日志缓冲等待次数'
        WHEN VARIABLE_NAME = 'Innodb_log_writes' THEN '日志写入次数'
        WHEN VARIABLE_NAME = 'Innodb_log_write_requests' THEN '日志写请求次数'  
        WHEN VARIABLE_NAME = 'Innodb_os_log_written' THEN '写入操作系统的日志量'
        WHEN VARIABLE_NAME = 'Innodb_os_log_fsyncs' THEN '日志文件同步次数'
        ELSE '其他'
    END as description
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME LIKE 'Innodb_log%' OR VARIABLE_NAME LIKE 'Innodb_os_log%';

-- 日志性能分析
SELECT 
    log_writes.writes as log_writes,
    log_requests.requests as log_requests,
    ROUND(log_writes.writes * 100.0 / log_requests.requests, 2) as log_write_ratio_percent
FROM 
    (SELECT VARIABLE_VALUE as writes FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_log_writes') log_writes,
    (SELECT VARIABLE_VALUE as requests FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_log_write_requests') log_requests;
```

### 10.7 InnoDB综合监控视图


**📊 InnoDB健康度评估**
```sql
-- 创建InnoDB监控摘要视图
CREATE VIEW innodb_health_summary AS
SELECT 
    'Buffer Pool Hit Ratio' as metric,
    CONCAT(
        ROUND(
            (1 - (
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
            )) * 100, 2
        ), '%'
    ) as value,
    CASE 
        WHEN (1 - (
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        )) * 100 >= 95 THEN 'GOOD'
        WHEN (1 - (
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        )) * 100 >= 85 THEN 'FAIR'
        ELSE 'POOR'
    END as status

UNION ALL

SELECT 
    'Buffer Pool Usage' as metric,
    CONCAT(
        ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
        ), '%'
    ) as value,
    CASE 
        WHEN (
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100
        ) BETWEEN 60 AND 85 THEN 'GOOD'
        WHEN (
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100
        ) > 95 THEN 'HIGH'
        ELSE 'LOW'
    END as status

UNION ALL

SELECT 
    'Average Lock Wait Time' as metric,
    CONCAT(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_row_lock_time_avg'),
        ' ms'
    ) as value,
    CASE 
        WHEN (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_row_lock_time_avg') < 100 THEN 'GOOD'
        WHEN (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_row_lock_time_avg') < 1000 THEN 'FAIR'
        ELSE 'POOR'  
    END as status;

-- 使用监控视图
SELECT * FROM innodb_health_summary;
```

---

## 11. ⚡ 实时性能诊断


### 11.1 实时诊断概述


**💡 实时诊断的价值**
实时性能诊断就像给数据库配备了"实时体检仪"，能够即时发现和分析正在发生的性能问题。

```
实时诊断的优势：
- 及时发现 → 问题出现时立即发现
- 准确定位 → 精确找到问题根源
- 快速响应 → 缩短故障处理时间
- 预防恶化 → 防止小问题变成大故障

诊断维度：
- 当前执行SQL → 找出正在运行的慢查询
- 锁等待分析 → 识别锁冲突和死锁
- 资源使用监控 → 监控CPU、内存、IO使用
- 连接状态分析 → 分析客户端连接情况
```

### 11.2 当前执行SQL诊断


**🔍 正在执行的慢查询**
```sql
-- 查看当前正在执行的SQL语句（按执行时间排序）
SELECT 
    p.ID as process_id,
    p.USER as db_user,
    p.HOST as client_host,
    p.DB as database_name,
    p.COMMAND as command_type,
    p.TIME as execution_time_seconds,
    p.STATE as current_state,
    LEFT(p.INFO, 100) as sql_snippet
FROM information_schema.PROCESSLIST p
WHERE p.COMMAND != 'Sleep' 
  AND p.TIME > 2  -- 执行超过2秒的查询
  AND p.INFO IS NOT NULL
ORDER BY p.TIME DESC;

-- 使用Performance_Schema查看当前执行的详细信息
SELECT 
    esc.THREAD_ID,
    esc.SQL_TEXT,
    esc.CURRENT_SCHEMA,
    ROUND(esc.TIMER_WAIT/1000000000, 2) as execution_time_sec,
    esc.LOCK_TIME/1000000000 as lock_time_sec,
    esc.ROWS_EXAMINED,
    esc.ROWS_SENT,
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_HOST
FROM performance_schema.events_statements_current esc
JOIN performance_schema.threads t ON esc.THREAD_ID = t.THREAD_ID
WHERE esc.SQL_TEXT IS NOT NULL
  AND esc.TIMER_WAIT > 2000000000  -- 超过2秒的查询
ORDER BY esc.TIMER_WAIT DESC;
```

### 11.3 锁等待实时诊断


**🔒 锁冲突分析**
```sql
-- MySQL 8.0+ 锁等待分析
SELECT 
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_started AS waiting_started,
    LEFT(r.trx_query, 100) AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_started AS blocking_started,
    LEFT(b.trx_query, 100) AS blocking_query,
    TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) AS wait_time_seconds
FROM information_schema.INNODB_TRX r
JOIN information_schema.INNODB_TRX b ON r.trx_wait_started IS NOT NULL
WHERE r.trx_state = 'LOCK WAIT'
ORDER BY r.trx_started;

-- 使用sys.innodb_lock_waits视图（更简洁）
SELECT 
    waiting_trx_id,
    waiting_thread,
    waiting_query,
    blocking_trx_id,
    blocking_thread,
    blocking_query,
    wait_age,
    sql_kill_blocking_query
FROM sys.innodb_lock_waits;

-- 死锁检测查询
SELECT 
    ENGINE,
    TYPE,
    NAME,
    STATUS
FROM information_schema.ENGINES
WHERE ENGINE = 'InnoDB';

-- 查看最近的死锁信息（需要开启innodb_print_all_deadlocks）
SHOW ENGINE INNODB STATUS\G
```

### 11.4 连接状态实时分析


**🔗 连接监控**
```sql
-- 连接状态统计
SELECT 
    COMMAND,
    COUNT(*) as connection_count,
    AVG(TIME) as avg_time_seconds,
    MAX(TIME) as max_time_seconds
FROM information_schema.PROCESSLIST
GROUP BY COMMAND
ORDER BY connection_count DESC;

-- 用户连接分布
SELECT 
    USER as db_user,
    HOST as client_host,
    COUNT(*) as connection_count,
    SUM(CASE WHEN COMMAND != 'Sleep' THEN 1 ELSE 0 END) as active_connections
FROM information_schema.PROCESSLIST
GROUP BY USER, HOST
ORDER BY connection_count DESC;

-- 数据库使用统计
SELECT 
    IFNULL(DB, 'No Database') as database_name,
    COUNT(*) as connection_count,
    COUNT(DISTINCT USER) as unique_users
FROM information_schema.PROCESSLIST
GROUP BY DB
ORDER BY connection_count DESC;

-- 长时间空闲连接
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME as idle_seconds,
    ROUND(TIME/60, 2) as idle_minutes
FROM information_schema.PROCESSLIST
WHERE COMMAND = 'Sleep'
  AND TIME > 3600  -- 空闲超过1小时
ORDER BY TIME DESC;
```

### 11.5 资源使用实时监控


**💻 系统资源监控**
```sql
-- CPU使用相关指标
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Threads_running' THEN '正在运行的线程数'
        WHEN VARIABLE_NAME = 'Threads_connected' THEN '已连接线程数'
        WHEN VARIABLE_NAME = 'Threads_created' THEN '创建的线程总数'
        WHEN VARIABLE_NAME = 'Threads_cached' THEN '缓存的线程数'
        ELSE '其他'
    END as description
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME IN (
    'Threads_running',
    'Threads_connected', 
    'Threads_created',
    'Threads_cached'
);

-- 查询执行统计（QPS）
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    @previous_value := IFNULL(@previous_value, VARIABLE_VALUE) as previous_value,
    VARIABLE_VALUE - @previous_value as delta
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Queries';

-- 临时表使用监控
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME IN (
    'Created_tmp_tables',           -- 创建临时表总数
    'Created_tmp_disk_tables',      -- 磁盘临时表数
    'Created_tmp_files'             -- 临时文件数
);

-- 计算临时表磁盘使用率
SELECT 
    tmp_disk.disk_tables,
    tmp_total.total_tables,
    ROUND(tmp_disk.disk_tables * 100.0 / tmp_total.total_tables, 2) as disk_tmp_table_ratio
FROM 
    (SELECT VARIABLE_VALUE as disk_tables FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') tmp_disk,
    (SELECT VARIABLE_VALUE as total_tables FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_tables') tmp_total;
```

### 11.6 实时诊断工具函数


**🛠️ 诊断工具集**
```sql
-- 创建实时诊断存储过程
DELIMITER //
CREATE PROCEDURE realtime_performance_diagnosis()
BEGIN
    -- 显示当前最耗时的查询
    SELECT '=== 当前执行最慢的查询 ===' as diagnosis_section;
    
    SELECT 
        ID,
        USER,
        DB,
        COMMAND,
        TIME,
        STATE,
        LEFT(INFO, 200) as query_snippet
    FROM information_schema.PROCESSLIST
    WHERE COMMAND != 'Sleep' AND TIME > 1
    ORDER BY TIME DESC
    LIMIT 5;
    
    -- 显示锁等待情况
    SELECT '=== 当前锁等待情况 ===' as diagnosis_section;
    
    SELECT COUNT(*) as lock_wait_count
    FROM information_schema.INNODB_TRX
    WHERE trx_state = 'LOCK WAIT';
    
    -- 显示连接统计
    SELECT '=== 连接状态统计 ===' as diagnosis_section;
    
    SELECT 
        COMMAND,
        COUNT(*) as count
    FROM information_schema.PROCESSLIST
    GROUP BY COMMAND
    ORDER BY count DESC;
    
    -- 显示关键性能指标
    SELECT '=== 关键性能指标 ===' as diagnosis_section;
    
    SELECT 
        'Threads_running' as metric,
        VARIABLE_VALUE as current_value,
        CASE 
            WHEN VARIABLE_VALUE > 20 THEN 'HIGH'
            WHEN VARIABLE_VALUE > 10 THEN 'MEDIUM' 
            ELSE 'NORMAL'
        END as status
    FROM information_schema.GLOBAL_STATUS
    WHERE VARIABLE_NAME = 'Threads_running'
    
    UNION ALL
    
    SELECT 
        'Buffer_pool_hit_ratio' as metric,
        CONCAT(
            ROUND(
                (1 - (
                    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
                )) * 100, 2
            ), '%'
        ) as current_value,
        CASE 
            WHEN (1 - (
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
            )) * 100 > 95 THEN 'GOOD'
            WHEN (1 - (
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')  
            )) * 100 > 85 THEN 'FAIR'
            ELSE 'POOR'
        END as status;
        
END //
DELIMITER ;

-- 使用诊断工具
CALL realtime_performance_diagnosis();
```

---

## 12. 🚨 异常检测与告警


### 12.1 异常检测体系


**💡 异常检测原理**
异常检测就像数据库的"安全警报系统"，通过监控关键指标的异常变化，及时发现并报告潜在问题。

```
检测维度：
- 性能异常 → 响应时间突然变慢
- 资源异常 → CPU、内存、磁盘使用异常  
- 连接异常 → 连接数突然激增或骤减
- 错误异常 → 错误率突然上升
- 容量异常 → 存储空间接近上限

检测方法：
- 阈值检测 → 设定固定阈值进行比较
- 趋势检测 → 分析指标变化趋势
- 异常点检测 → 识别偏离正常模式的数据点
- 基线对比 → 与历史同期数据对比
```

### 12.2 性能异常检测


**⚡ 响应时间异常检测**
```sql
-- 创建性能基线表
CREATE TABLE performance_baseline (
    id INT AUTO_INCREMENT PRIMARY KEY,
    metric_name VARCHAR(100),
    baseline_value DECIMAL(15,4),
    threshold_warning DECIMAL(15,4),
    threshold_critical DECIMAL(15,4),
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 初始化性能基线
INSERT INTO performance_baseline (metric_name, baseline_value, threshold_warning, threshold_critical) VALUES
('avg_query_time', 0.1, 0.5, 2.0),
('threads_running', 5, 20, 50),
('buffer_pool_hit_ratio', 98.5, 95.0, 90.0),
('connections_usage_ratio', 30.0, 70.0, 90.0),
('slow_queries_per_minute', 1.0, 10.0, 50.0);

-- 实时性能异常检测函数
DELIMITER //
CREATE FUNCTION detect_performance_anomaly(metric_name VARCHAR(100), current_value DECIMAL(15,4))
RETURNS VARCHAR(20)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE baseline DECIMAL(15,4);
    DECLARE warning_threshold DECIMAL(15,4);
    DECLARE critical_threshold DECIMAL(15,4);
    
    SELECT baseline_value, threshold_warning, threshold_critical
    INTO baseline, warning_threshold, critical_threshold
    FROM performance_baseline
    WHERE performance_baseline.metric_name = metric_name;
    
    IF current_value >= critical_threshold THEN
        RETURN 'CRITICAL';
    ELSEIF current_value >= warning_threshold THEN
        RETURN 'WARNING';
    ELSE
        RETURN 'NORMAL';
    END IF;
END //
DELIMITER ;

-- 使用异常检测
SELECT 
    'Current Threads Running' as metric,
    VARIABLE_VALUE as current_value,
    detect_performance_anomaly('threads_running', VARIABLE_VALUE) as alert_level
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Threads_running';
```

### 12.3 资源使用异常检测


**💾 资源监控告警**
```sql
-- 创建资源使用异常检测视图
CREATE VIEW resource_anomaly_detection AS
SELECT 
    'Connection Usage' as resource_type,
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_VARIABLES WHERE VARIABLE_NAME = 'max_connections') * 100, 2
    ) as usage_percentage,
    CASE 
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_VARIABLES WHERE VARIABLE_NAME = 'max_connections') * 100, 2
        ) > 90 THEN 'CRITICAL'
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_VARIABLES WHERE VARIABLE_NAME = 'max_connections') * 100, 2
        ) > 70 THEN 'WARNING'
        ELSE 'NORMAL'
    END as alert_level

UNION ALL

SELECT 
    'Buffer Pool Usage' as resource_type,
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
    ) as usage_percentage,
    CASE 
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
        ) > 95 THEN 'WARNING'
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
        ) < 60 THEN 'LOW_USAGE'
        ELSE 'NORMAL'
    END as alert_level

UNION ALL

SELECT 
    'Temp Table Disk Usage' as resource_type,
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2
    ) as usage_percentage,
    CASE 
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2
        ) > 25 THEN 'CRITICAL'
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2
        ) > 10 THEN 'WARNING'
        ELSE 'NORMAL'
    END as alert_level;

-- 查看资源异常情况
SELECT * FROM resource_anomaly_detection 
WHERE alert_level IN ('WARNING', 'CRITICAL');
```

### 12.4 DML操作异常检测


**🔧 DML异常模式识别**
```sql
-- DML操作统计表（用于存储历史数据）
CREATE TABLE dml_stats_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    record_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    selects_per_second DECIMAL(10,2),
    inserts_per_second DECIMAL(10,2),
    updates_per_second DECIMAL(10,2),
    deletes_per_second DECIMAL(10,2),
    slow_queries_count INT,
    avg_query_time DECIMAL(10,6)
);

-- DML异常检测存储过程
DELIMITER //
CREATE PROCEDURE detect_dml_anomalies()
BEGIN
    DECLARE current_selects INT;
    DECLARE current_inserts INT; 
    DECLARE current_updates INT;
    DECLARE current_deletes INT;
    DECLARE current_slow_queries INT;
    
    -- 获取当前统计值
    SELECT VARIABLE_VALUE INTO current_selects FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Com_select';
    SELECT VARIABLE_VALUE INTO current_inserts FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Com_insert';
    SELECT VARIABLE_VALUE INTO current_updates FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Com_update';
    SELECT VARIABLE_VALUE INTO current_deletes FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Com_delete';
    SELECT VARIABLE_VALUE INTO current_slow_queries FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Slow_queries';
    
    -- 异常检测逻辑
    SELECT 
        'DML_ANOMALY_CHECK' as check_type,
        CASE 
            WHEN current_slow_queries > (
                SELECT AVG(slow_queries_count) * 3 
                FROM dml_stats_history 
                WHERE record_time >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
            ) THEN 'CRITICAL: Slow queries spike detected'
            
            WHEN current_updates > (
                SELECT AVG(updates_per_second) * 5
                FROM dml_stats_history
                WHERE record_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
            ) THEN 'WARNING: Unusual UPDATE activity'
            
            WHEN current_deletes > (
                SELECT AVG(deletes_per_second) * 10
                FROM dml_stats_history  
                WHERE record_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
            ) THEN 'CRITICAL: Massive DELETE operation detected'
            
            ELSE 'NORMAL'
        END as anomaly_status,
        NOW() as check_time;
        
END //
DELIMITER ;
```

### 12.5 告警系统实现


**📢 综合告警系统**
```sql
-- 告警日志表
CREATE TABLE alert_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    alert_level ENUM('INFO', 'WARNING', 'CRITICAL'),
    alert_type VARCHAR(50),
    alert_message TEXT,
    metric_name VARCHAR(100),
    current_value VARCHAR(100),
    threshold_value VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP NULL,
    status ENUM('ACTIVE', 'RESOLVED') DEFAULT 'ACTIVE'
);

-- 综合告警检测存储过程
DELIMITER //
CREATE PROCEDURE comprehensive_alert_check()
BEGIN
    -- 检查连接数异常
    INSERT INTO alert_log (alert_level, alert_type, alert_message, metric_name, current_value, threshold_value)
    SELECT 
        CASE 
            WHEN connection_ratio > 90 THEN 'CRITICAL'
            WHEN connection_ratio > 70 THEN 'WARNING'
        END as alert_level,
        'CONNECTION_USAGE' as alert_type,
        CONCAT('连接使用率过高: ', connection_ratio, '%') as alert_message,
        'connection_usage_ratio' as metric_name,
        CONCAT(connection_ratio, '%') as current_value,
        '70%' as threshold_value
    FROM (
        SELECT ROUND(
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Threads_connected') /
            (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_VARIABLES WHERE VARIABLE_NAME = 'max_connections') * 100, 2
        ) as connection_ratio
    ) conn_check
    WHERE connection_ratio > 70;
    
    -- 检查缓冲池命中率异常  
    INSERT INTO alert_log (alert_level, alert_type, alert_message, metric_name, current_value, threshold_value)
    SELECT 
        CASE 
            WHEN hit_ratio < 85 THEN 'CRITICAL'
            WHEN hit_ratio < 95 THEN 'WARNING'
        END as alert_level,
        'BUFFER_POOL_HIT_RATIO' as alert_type,
        CONCAT('缓冲池命中率过低: ', hit_ratio, '%') as alert_message,
        'buffer_pool_hit_ratio' as metric_name,
        CONCAT(hit_ratio, '%') as current_value,
        '95%' as threshold_value
    FROM (
        SELECT ROUND(
            (1 - (
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
            )) * 100, 2
        ) as hit_ratio
    ) hit_check
    WHERE hit_ratio < 95;
    
    -- 检查长时间运行的查询
    INSERT INTO alert_log (alert_level, alert_type, alert_message, metric_name, current_value)
    SELECT 
        'WARNING' as alert_level,
        'LONG_RUNNING_QUERY' as alert_type,
        CONCAT('发现长时间运行查询，进程ID: ', ID, ', 用户: ', USER, ', 执行时间: ', TIME, '秒') as alert_message,
        'long_running_query' as metric_name,
        CONCAT(TIME, ' seconds') as current_value
    FROM information_schema.PROCESSLIST
    WHERE COMMAND != 'Sleep' 
      AND TIME > 300  -- 超过5分钟
      AND INFO IS NOT NULL;
    
    -- 检查锁等待
    INSERT INTO alert_log (alert_level, alert_type, alert_message, metric_name, current_value)
    SELECT 
        'CRITICAL' as alert_level,
        'LOCK_WAIT' as alert_type,
        CONCAT('发现锁等待，等待事务ID: ', trx_id, ', 等待时间: ', TIMESTAMPDIFF(SECOND, trx_started, NOW()), '秒') as alert_message,
        'lock_wait_time' as metric_name,
        CONCAT(TIMESTAMPDIFF(SECOND, trx_started, NOW()), ' seconds') as current_value
    FROM information_schema.INNODB_TRX
    WHERE trx_state = 'LOCK WAIT'
      AND TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 30;  -- 等待超过30秒
    
END //
DELIMITER ;

-- 定期执行告警检测（可以通过cron调用）
-- CALL comprehensive_alert_check();

-- 查看活跃告警
SELECT 
    alert_level,
    alert_type,
    alert_message,
    current_value,
    created_at
FROM alert_log 
WHERE status = 'ACTIVE'
  AND created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY 
    FIELD(alert_level, 'CRITICAL', 'WARNING', 'INFO'),
    created_at DESC;
```

### 12.6 告警通知机制


**📱 告警通知实现**
```sql
-- 告警通知配置表
CREATE TABLE alert_notification_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    alert_type VARCHAR(50),
    alert_level ENUM('INFO', 'WARNING', 'CRITICAL'),
    notification_method ENUM('EMAIL', 'SMS', 'WEBHOOK'),
    notification_target VARCHAR(255),
    is_enabled BOOLEAN DEFAULT TRUE,
    cooldown_minutes INT DEFAULT 30  -- 冷却时间，避免重复告警
);

-- 插入通知配置示例
INSERT INTO alert_notification_config (alert_type, alert_level, notification_method, notification_target) VALUES
('CONNECTION_USAGE', 'CRITICAL', 'EMAIL', 'dba@company.com'),
('BUFFER_POOL_HIT_RATIO', 'WARNING', 'EMAIL', 'dba@company.com'),
('LOCK_WAIT', 'CRITICAL', 'SMS', '13800138000'),
('LONG_RUNNING_QUERY', 'WARNING', 'WEBHOOK', 'http://monitoring.company.com/webhook');

-- 告警摘要报告生成
CREATE VIEW daily_alert_summary AS
SELECT 
    DATE(created_at) as alert_date,
    alert_level,
    alert_type,
    COUNT(*) as alert_count,
    MIN(created_at) as first_occurrence,
    MAX(created_at) as last_occurrence
FROM alert_log
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY DATE(created_at), alert_level, alert_type
ORDER BY alert_date DESC, FIELD(alert_level, 'CRITICAL', 'WARNING', 'INFO');

-- 使用摘要报告
SELECT * FROM daily_alert_summary;
```

---

## 13. 📋 核心要点总结


### 13.1 必须掌握的监控体系


**🔸 监控层次理解**
```
系统级监控：
✓ 慢查询日志 - 发现性能问题的第一道防线
✓ Performance_Schema - 详细的性能数据记录
✓ INFORMATION_SCHEMA - 数据库结构和统计信息
✓ sys监控视图 - 易用的性能分析工具

操作级监控：
✓ ROW_COUNT() - DML操作行数统计
✓ Handler变量 - 存储引擎操作统计
✓ InnoDB指标 - 存储引擎性能指标
```

**🔸 关键监控指标**
```
性能指标：
✓ 查询响应时间 - 反映系统性能
✓ QPS/TPS - 反映系统吞吐量
✓ 缓冲池命中率 - 反映内存使用效率
✓ 索引使用率 - 反映查询优化程度

资源指标：
✓ CPU使用率（Threads_running）
✓ 内存使用率（Buffer Pool使用情况）
✓ 连接使用率（连接数/最大连接数）
✓ IO使用率（读写操作统计）
```

### 13.2 实用监控技能


**🛠️ 核心监控查询**
```sql
-- 实时性能监控
SELECT * FROM sys.statements_with_runtimes_in_95th_percentile LIMIT 10;

-- 资源使用监控  
SELECT * FROM sys.memory_global_total;

-- 连接状态监控
SELECT * FROM sys.processlist WHERE command != 'Sleep';

-- InnoDB健康检查
SELECT * FROM sys.innodb_lock_waits;

-- Handler操作统计
SHOW STATUS LIKE 'Handler_%';
```

**📊 监控数据分析技巧**
```
趋势分析：
- 对比不同时间段的指标变化
- 识别性能下降或资源消耗增长趋势
- 基于历史数据预测未来需求

异常检测：
- 设置合理的告警阈值
- 识别偏离正常模式的异常点
- 区分正常业务波动和真实异常

根因分析：
- 从症状出发，逐层深入分析
- 结合多个维度的监控数据
- 找到性能问题的根本原因
```

### 13.3 监控最佳实践


**🎯 监控策略**
```
分层监控：
1. 宏观监控 - 系统整体健康状况
2. 应用监控 - 具体业务模块性能  
3. 细节监控 - 单个SQL语句执行情况

定期维护：
- 定期清理历史监控数据
- 更新监控基线和阈值
- 优化监控查询本身的性能
- 验证告警机制的有效性

持续改进：
- 根据实际经验调整监控策略
- 增加新的监控维度和指标
- 优化告警规则，减少误报
- 建立监控数据的分析报告
```

**⚠️ 监控注意事项**
```
性能影响：
- 监控本身也会消耗系统资源
- Performance_Schema会有一定开销
- 避免过于频繁的监控查询
- 在业务高峰期适当减少监控频率

数据准确性：
- INFORMATION_SCHEMA中的统计信息可能不完全准确
- ROW_COUNT()只反映最近一次DML操作
- Handler变量是累积值，需要计算差值
- 缓冲池命中率需要足够的样本量才准确

告警策略：
- 避免告警疲劳，设置合理的告警频率
- 区分不同级别的告警，采用不同的通知方式
- 建立告警升级机制
- 定期回顾和优化告警规则
```

### 13.4 故障处理指南


**🔍 性能问题诊断流程**
```
1. 现象确认
   → 确认具体的性能问题症状
   → 收集用户反馈和错误信息

2. 快速定位  
   → 查看当前执行的慢查询
   → 检查锁等待和死锁情况
   → 分析系统资源使用状况

3. 深入分析
   → 分析慢查询日志找出问题SQL
   → 使用EXPLAIN分析执行计划
   → 检查相关表的索引情况

4. 解决方案
   → 优化问题SQL语句
   → 添加或调整索引
   → 调整系统参数配置
   → 必要时进行应用代码优化

5. 效果验证
   → 监控修复后的性能指标
   → 确认问题是否彻底解决
   → 建立预防措施避免再次发生
```

**核心记忆**：
- DML监控是数据库性能管理的核心环节
- 多层次、多维度的监控体系能全面反映数据库健康状况  
- 实时诊断和异常告警是及时发现和解决问题的关键
- 持续监控和优化是保证数据库稳定运行的基础