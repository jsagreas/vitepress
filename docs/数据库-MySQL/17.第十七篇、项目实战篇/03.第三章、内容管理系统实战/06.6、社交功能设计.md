---
title: 6、社交功能设计
---
## 📚 目录

1. [社交功能核心概念](#1-社交功能核心概念)
2. [用户互动模型设计](#2-用户互动模型设计)
3. [评论系统实现](#3-评论系统实现)
4. [点赞收藏机制](#4-点赞收藏机制)
5. [用户关注系统](#5-用户关注系统)
6. [社交数据分析](#6-社交数据分析)
7. [内容推荐算法](#7-内容推荐算法)
8. [社区管理功能](#8-社区管理功能)
9. [性能优化策略](#9-性能优化策略)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌟 社交功能核心概念


### 1.1 什么是社交功能


**🔸 基本定义**
社交功能就是让用户之间能够互动交流的功能模块。简单说，就是让用户能够评论、点赞、关注、分享内容，形成一个有活力的社区生态。

**🔸 为什么需要社交功能**
```
传统网站：用户只能浏览内容，像看报纸一样
社交网站：用户可以互动交流，像朋友聚会一样

好处：
• 提高用户粘性：用户有了互动就不容易离开
• 增加内容价值：好内容通过社交传播得更广  
• 形成社区氛围：用户之间产生连接和归属感
• 商业价值提升：活跃用户带来更多商业机会
```

### 1.2 社交功能核心要素


**🔸 用户关系网络**
```
单向关注：微博模式，A关注B，B不一定关注A
双向好友：微信模式，A和B互相确认才成为好友
粉丝体系：知乎模式，有影响力的用户积累粉丝
```

**🔸 内容互动方式**
```
点赞：表达认同，成本最低的互动方式
评论：深度交流，表达具体观点
分享：传播扩散，让更多人看到内容
收藏：个人标记，方便后续查看
```

### 1.3 社交功能架构概览


```
用户层 ──▶ 互动层 ──▶ 内容层 ──▶ 数据层
  │         │         │         │
  │         │         │         │
用户信息   评论点赞   文章视频   MySQL存储
用户关系   分享收藏   动态消息   缓存优化
用户画像   消息通知   推荐算法   实时统计
```

---

## 2. 👥 用户互动模型设计


### 2.1 用户基础信息表


**🔸 用户表结构设计**

用户表就是存储每个人基本信息的地方，就像身份证一样记录用户的基本资料。

```sql
-- 用户基础信息表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,      -- 用户名，必须唯一
    nickname VARCHAR(100),                     -- 昵称，可以重复
    email VARCHAR(255) UNIQUE,                 -- 邮箱
    avatar VARCHAR(500),                       -- 头像URL
    bio TEXT,                                  -- 个人简介
    follower_count INT DEFAULT 0,              -- 粉丝数
    following_count INT DEFAULT 0,             -- 关注数
    post_count INT DEFAULT 0,                  -- 发帖数
    like_count INT DEFAULT 0,                  -- 获赞数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_username (username),
    INDEX idx_email (email)
);
```

**🔸 字段含义解释**
- `follower_count`: 有多少人关注了这个用户
- `following_count`: 这个用户关注了多少人  
- `post_count`: 用户发布了多少条内容
- `like_count`: 用户获得的总点赞数

> 💡 **设计思路**  
> 把统计数据直接存在用户表里，这样查询用户信息时不需要临时计算，速度更快。这叫做"数据冗余换性能"。

### 2.2 用户扩展信息表


有些用户信息不是必需的，单独放一张表可以让主表更轻量。

```sql
-- 用户扩展信息表
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    gender TINYINT,                    -- 性别：0未知，1男，2女
    birthday DATE,                     -- 生日
    location VARCHAR(100),             -- 所在地
    website VARCHAR(255),              -- 个人网站
    phone VARCHAR(20),                 -- 手机号
    level TINYINT DEFAULT 1,           -- 用户等级
    points INT DEFAULT 0,              -- 积分
    status TINYINT DEFAULT 1,          -- 状态：1正常，0禁用
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### 2.3 用户互动行为统计


**🔸 用户行为分析的重要性**

想知道用户喜欢什么、经常做什么，就需要统计用户的各种行为。这就像商店老板观察顾客喜欢买什么商品一样。

```sql
-- 用户行为统计表
CREATE TABLE user_statistics (
    user_id INT PRIMARY KEY,
    daily_login_count INT DEFAULT 0,        -- 每日登录次数
    weekly_post_count INT DEFAULT 0,        -- 每周发帖数
    monthly_like_given INT DEFAULT 0,       -- 每月点赞数
    total_comment_count INT DEFAULT 0,      -- 总评论数
    total_share_count INT DEFAULT 0,        -- 总分享数
    last_active_time TIMESTAMP,             -- 最后活跃时间
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

---

## 3. 💬 评论系统实现


### 3.1 评论系统基本概念


**🔸 什么是评论系统**

评论系统就是让用户对内容发表看法的功能。就像看电影后和朋友讨论剧情一样，用户可以对文章、视频等内容进行评论交流。

**🔸 评论的层级结构**

```
文章《如何学好MySQL》
├── 张三：讲得很清楚！            (一级评论)
│   ├── 李四：@张三 同感          (二级评论，回复张三)
│   └── 王五：@张三 有道理        (二级评论，回复张三)
├── 赵六：还有更深入的内容吗？    (一级评论)  
│   └── 作者：@赵六 后面会写      (二级评论，回复赵六)
└── 小明：收藏了！                (一级评论)
```

### 3.2 评论表结构设计


**🔸 核心评论表**

```sql
-- 评论表
CREATE TABLE comments (
    id INT PRIMARY KEY AUTO_INCREMENT,
    content_id INT NOT NULL,               -- 被评论的内容ID
    content_type VARCHAR(20) NOT NULL,     -- 内容类型：article、video、post
    user_id INT NOT NULL,                  -- 评论者ID
    parent_id INT DEFAULT 0,               -- 父评论ID，0表示一级评论
    root_id INT DEFAULT 0,                 -- 根评论ID，便于查询整个评论树
    content TEXT NOT NULL,                 -- 评论内容
    like_count INT DEFAULT 0,              -- 点赞数
    reply_count INT DEFAULT 0,             -- 回复数
    status TINYINT DEFAULT 1,              -- 状态：1正常，0删除，-1审核中
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_content (content_id, content_type),
    INDEX idx_user (user_id),
    INDEX idx_parent (parent_id),
    INDEX idx_root (root_id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

**🔸 字段详细解释**
- `parent_id`: 这条评论是回复哪条评论的，0表示直接评论内容
- `root_id`: 整个评论串的根评论，方便一次查出完整对话
- `content_type`: 因为可能有文章、视频、动态等多种内容类型

### 3.3 多级评论树形结构实现


**🔸 查询评论的完整对话**

想要显示一篇文章的所有评论，需要按照树形结构组织：

```sql
-- 查询某篇文章的所有评论（树形结构）
SELECT 
    c.id,
    c.parent_id,
    c.root_id,
    c.content,
    c.like_count,
    c.created_at,
    u.nickname,
    u.avatar
FROM comments c
JOIN users u ON c.user_id = u.id
WHERE c.content_id = 123 
  AND c.content_type = 'article'
  AND c.status = 1
ORDER BY 
    c.root_id ASC,          -- 先按根评论排序
    c.created_at ASC;       -- 再按时间排序
```

**🔸 评论统计更新**

当有新评论时，需要更新相关的统计数据：

```sql
-- 添加评论的存储过程
DELIMITER //
CREATE PROCEDURE AddComment(
    IN p_content_id INT,
    IN p_content_type VARCHAR(20),
    IN p_user_id INT,
    IN p_parent_id INT,
    IN p_content TEXT
)
BEGIN
    DECLARE v_root_id INT DEFAULT 0;
    DECLARE v_comment_id INT;
    
    START TRANSACTION;
    
    -- 确定根评论ID
    IF p_parent_id > 0 THEN
        SELECT IFNULL(root_id, parent_id) INTO v_root_id 
        FROM comments 
        WHERE id = p_parent_id;
    END IF;
    
    -- 插入评论
    INSERT INTO comments (content_id, content_type, user_id, parent_id, root_id, content)
    VALUES (p_content_id, p_content_type, p_user_id, p_parent_id, v_root_id, p_content);
    
    SET v_comment_id = LAST_INSERT_ID();
    
    -- 更新父评论的回复数
    IF p_parent_id > 0 THEN
        UPDATE comments SET reply_count = reply_count + 1 WHERE id = p_parent_id;
    END IF;
    
    -- 更新用户评论总数
    UPDATE user_statistics SET total_comment_count = total_comment_count + 1 
    WHERE user_id = p_user_id;
    
    COMMIT;
    
    SELECT v_comment_id AS comment_id;
END //
DELIMITER ;
```

### 3.4 评论内容安全处理


**🔸 敏感词过滤**

评论系统必须要有内容审核，防止不良信息传播：

```sql
-- 敏感词库表
CREATE TABLE sensitive_words (
    id INT PRIMARY KEY AUTO_INCREMENT,
    word VARCHAR(50) NOT NULL,
    level TINYINT NOT NULL,      -- 敏感等级：1轻微，2中等，3严重
    action VARCHAR(20) NOT NULL, -- 处理方式：filter替换，block阻止
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_word (word)
);

-- 评论审核记录表
CREATE TABLE comment_reviews (
    id INT PRIMARY KEY AUTO_INCREMENT,
    comment_id INT NOT NULL,
    reviewer_id INT,                    -- 审核人ID
    status VARCHAR(20) NOT NULL,        -- pending、approved、rejected
    reason TEXT,                        -- 审核原因
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (comment_id) REFERENCES comments(id)
);
```

---

## 4. 👍 点赞收藏机制


### 4.1 点赞系统设计思路


**🔸 点赞的本质**

点赞就是用户表达"我喜欢这个内容"的最简单方式。就像现实中竖大拇指一样，成本很低但意义明确。

**🔸 点赞系统的挑战**
```
数据量大：热门内容可能有几万、几十万点赞
查询频繁：每次显示内容都要知道点赞数和用户是否点过赞
防重复：一个用户只能对同一内容点赞一次
性能要求：点赞操作要秒级响应
```

### 4.2 点赞表结构设计


**🔸 用户点赞记录表**

```sql
-- 点赞记录表
CREATE TABLE user_likes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,                   -- 点赞的用户
    content_id INT NOT NULL,                -- 被点赞的内容
    content_type VARCHAR(20) NOT NULL,      -- 内容类型
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_content (user_id, content_id, content_type),
    INDEX idx_content (content_id, content_type),
    INDEX idx_user_time (user_id, created_at)
);
```

**🔸 为什么用联合唯一索引**

`UNIQUE KEY uk_user_content (user_id, content_id, content_type)` 这个索引确保：
- 同一个用户对同一内容只能点赞一次
- 查询时可以快速判断用户是否已点赞
- 防止重复点赞的数据

### 4.3 点赞操作实现


**🔸 点赞/取消点赞的逻辑**

```sql
-- 点赞操作存储过程
DELIMITER //
CREATE PROCEDURE ToggleLike(
    IN p_user_id INT,
    IN p_content_id INT,
    IN p_content_type VARCHAR(20),
    OUT p_result VARCHAR(20)  -- 返回：liked 或 unliked
)
BEGIN
    DECLARE v_exists INT DEFAULT 0;
    DECLARE v_target_table VARCHAR(50);
    
    START TRANSACTION;
    
    -- 检查是否已经点赞
    SELECT COUNT(*) INTO v_exists
    FROM user_likes 
    WHERE user_id = p_user_id 
      AND content_id = p_content_id 
      AND content_type = p_content_type;
    
    -- 确定要更新的目标表
    CASE p_content_type
        WHEN 'article' THEN SET v_target_table = 'articles';
        WHEN 'comment' THEN SET v_target_table = 'comments';
        WHEN 'post' THEN SET v_target_table = 'posts';
    END CASE;
    
    IF v_exists > 0 THEN
        -- 取消点赞
        DELETE FROM user_likes 
        WHERE user_id = p_user_id 
          AND content_id = p_content_id 
          AND content_type = p_content_type;
          
        -- 更新内容的点赞数
        SET @sql = CONCAT('UPDATE ', v_target_table, 
                         ' SET like_count = like_count - 1 WHERE id = ', p_content_id);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        
        SET p_result = 'unliked';
    ELSE
        -- 添加点赞
        INSERT INTO user_likes (user_id, content_id, content_type) 
        VALUES (p_user_id, p_content_id, p_content_type);
        
        -- 更新内容的点赞数
        SET @sql = CONCAT('UPDATE ', v_target_table, 
                         ' SET like_count = like_count + 1 WHERE id = ', p_content_id);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        
        SET p_result = 'liked';
    END IF;
    
    COMMIT;
END //
DELIMITER ;
```

### 4.4 收藏系统设计


**🔸 收藏与点赞的区别**

```
点赞：表达认同，公开的，影响内容排序
收藏：个人标记，私密的，方便后续查看

就像现实中：
点赞 = 鼓掌表示赞同
收藏 = 拿回家慢慢研究
```

**🔸 收藏表结构**

```sql
-- 用户收藏表
CREATE TABLE user_favorites (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    content_id INT NOT NULL,
    content_type VARCHAR(20) NOT NULL,
    folder_id INT DEFAULT 0,                -- 收藏夹ID，0表示默认收藏夹
    note TEXT,                              -- 收藏备注
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_content (user_id, content_id, content_type),
    INDEX idx_user_folder (user_id, folder_id),
    INDEX idx_content (content_id, content_type)
);

-- 收藏夹表
CREATE TABLE favorite_folders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    name VARCHAR(50) NOT NULL,              -- 收藏夹名称
    description TEXT,                       -- 描述
    item_count INT DEFAULT 0,               -- 收藏数量
    is_public TINYINT DEFAULT 0,            -- 是否公开：0私密，1公开
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user (user_id)
);
```

---

## 5. 🤝 用户关注系统


### 5.1 关注关系模型


**🔸 关注关系的本质**

关注就是用户对其他用户的"订阅"行为。就像订阅报纸一样，关注某人后就能看到他发布的内容动态。

**🔸 关注关系类型**
```
单向关注：A关注B，B不一定关注A（微博模式）
双向好友：A和B互相关注后成为好友（微信模式）
粉丝关系：有影响力的用户被很多人关注（明星模式）
```

### 5.2 关注关系表设计


**🔸 用户关注表**

```sql
-- 用户关注关系表
CREATE TABLE user_follows (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    follower_id INT NOT NULL,               -- 关注者（粉丝）
    following_id INT NOT NULL,              -- 被关注者
    status TINYINT DEFAULT 1,               -- 状态：1正常，0取消，-1拉黑
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_follow (follower_id, following_id),
    INDEX idx_follower (follower_id),
    INDEX idx_following (following_id),
    INDEX idx_status (status)
);
```

**🔸 字段含义说明**
- `follower_id`: 主动关注别人的用户（粉丝）
- `following_id`: 被关注的用户（博主）
- `status`: 关系状态，支持拉黑功能

### 5.3 关注操作实现


**🔸 关注/取消关注逻辑**

```sql
-- 关注操作存储过程
DELIMITER //
CREATE PROCEDURE FollowUser(
    IN p_follower_id INT,
    IN p_following_id INT,
    OUT p_result VARCHAR(20)
)
BEGIN
    DECLARE v_exists INT DEFAULT 0;
    DECLARE v_current_status TINYINT DEFAULT 0;
    
    -- 不能关注自己
    IF p_follower_id = p_following_id THEN
        SET p_result = 'cannot_follow_self';
        LEAVE proc_label;
    END IF;
    
    START TRANSACTION;
    
    -- 检查是否已经存在关注关系
    SELECT COUNT(*), IFNULL(MAX(status), 0) 
    INTO v_exists, v_current_status
    FROM user_follows 
    WHERE follower_id = p_follower_id AND following_id = p_following_id;
    
    IF v_exists > 0 THEN
        IF v_current_status = 1 THEN
            -- 取消关注
            UPDATE user_follows 
            SET status = 0, updated_at = CURRENT_TIMESTAMP
            WHERE follower_id = p_follower_id AND following_id = p_following_id;
            
            -- 更新统计数据
            UPDATE users SET following_count = following_count - 1 WHERE id = p_follower_id;
            UPDATE users SET follower_count = follower_count - 1 WHERE id = p_following_id;
            
            SET p_result = 'unfollowed';
        ELSE
            -- 重新关注
            UPDATE user_follows 
            SET status = 1, updated_at = CURRENT_TIMESTAMP
            WHERE follower_id = p_follower_id AND following_id = p_following_id;
            
            -- 更新统计数据
            UPDATE users SET following_count = following_count + 1 WHERE id = p_follower_id;
            UPDATE users SET follower_count = follower_count + 1 WHERE id = p_following_id;
            
            SET p_result = 'followed';
        END IF;
    ELSE
        -- 新建关注关系
        INSERT INTO user_follows (follower_id, following_id, status) 
        VALUES (p_follower_id, p_following_id, 1);
        
        -- 更新统计数据
        UPDATE users SET following_count = following_count + 1 WHERE id = p_follower_id;
        UPDATE users SET follower_count = follower_count + 1 WHERE id = p_following_id;
        
        SET p_result = 'followed';
    END IF;
    
    COMMIT;
END //
DELIMITER ;
```

### 5.4 用户关系图谱分析


**🔸 关注关系查询**

```sql
-- 查询用户的关注列表（我关注的人）
SELECT 
    u.id,
    u.nickname,
    u.avatar,
    u.follower_count,
    uf.created_at as follow_time
FROM user_follows uf
JOIN users u ON uf.following_id = u.id
WHERE uf.follower_id = 123 
  AND uf.status = 1
ORDER BY uf.created_at DESC;

-- 查询用户的粉丝列表（关注我的人）
SELECT 
    u.id,
    u.nickname,
    u.avatar,
    u.follower_count,
    uf.created_at as follow_time
FROM user_follows uf
JOIN users u ON uf.follower_id = u.id
WHERE uf.following_id = 123 
  AND uf.status = 1
ORDER BY uf.created_at DESC;

-- 查询共同关注（A和B都关注的人）
SELECT 
    u.id,
    u.nickname,
    u.avatar
FROM user_follows uf1
JOIN user_follows uf2 ON uf1.following_id = uf2.following_id
JOIN users u ON uf1.following_id = u.id
WHERE uf1.follower_id = 123    -- 用户A
  AND uf2.follower_id = 456    -- 用户B
  AND uf1.status = 1 
  AND uf2.status = 1;
```

---

## 6. 📊 社交数据分析


### 6.1 用户行为数据收集


**🔸 用户行为追踪的意义**

通过分析用户行为，我们可以了解：
- 用户喜欢什么内容
- 什么时间最活跃  
- 社交关系如何影响行为
- 如何提升用户参与度

就像商店分析顾客购买习惯，来优化商品摆放和促销策略一样。

**🔸 用户行为记录表**

```sql
-- 用户行为日志表
CREATE TABLE user_behaviors (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    action VARCHAR(50) NOT NULL,           -- 行为类型：view、like、share、comment
    target_id INT NOT NULL,                -- 目标对象ID
    target_type VARCHAR(20) NOT NULL,      -- 目标类型：article、user、comment
    session_id VARCHAR(100),               -- 会话ID
    ip_address VARCHAR(45),                -- IP地址
    user_agent TEXT,                       -- 浏览器信息
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user_action (user_id, action),
    INDEX idx_target (target_id, target_type),
    INDEX idx_time (created_at),
    PARTITION BY RANGE (UNIX_TIMESTAMP(created_at)) (
        PARTITION p202501 VALUES LESS THAN (UNIX_TIMESTAMP('2025-02-01')),
        PARTITION p202502 VALUES LESS THAN (UNIX_TIMESTAMP('2025-03-01')),
        PARTITION p202503 VALUES LESS THAN (UNIX_TIMESTAMP('2025-04-01'))
    )
);
```

### 6.2 用户画像构建


**🔸 什么是用户画像**

用户画像就是给每个用户贴标签，描述他的特征和偏好。就像给朋友写介绍信一样：这人喜欢科技、经常晚上活跃、偏爱长文章等。

**🔸 用户画像数据表**

```sql
-- 用户画像标签表
CREATE TABLE user_tags (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,      -- 标签名称
    category VARCHAR(30) NOT NULL,         -- 标签分类：interest、behavior、demographic
    description TEXT,                      -- 标签描述
    weight DECIMAL(3,2) DEFAULT 1.00,      -- 标签权重
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户标签关系表
CREATE TABLE user_tag_relations (
    user_id INT NOT NULL,
    tag_id INT NOT NULL,
    score DECIMAL(5,2) DEFAULT 0.00,       -- 标签得分
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    PRIMARY KEY (user_id, tag_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (tag_id) REFERENCES user_tags(id)
);
```

**🔸 用户画像分析查询**

```sql
-- 分析用户兴趣偏好
SELECT 
    ut.name as tag_name,
    ut.category,
    utr.score,
    COUNT(*) as user_count
FROM user_tag_relations utr
JOIN user_tags ut ON utr.tag_id = ut.id
WHERE utr.user_id = 123
ORDER BY utr.score DESC
LIMIT 10;

-- 找相似用户（有相同标签的用户）
SELECT 
    u2.id,
    u2.nickname,
    COUNT(*) as common_tags,
    AVG(utr1.score) as avg_score
FROM user_tag_relations utr1
JOIN user_tag_relations utr2 ON utr1.tag_id = utr2.tag_id
JOIN users u2 ON utr2.user_id = u2.id
WHERE utr1.user_id = 123 
  AND utr2.user_id != 123
GROUP BY u2.id, u2.nickname
HAVING common_tags >= 3
ORDER BY common_tags DESC, avg_score DESC;
```

### 6.3 社交影响力分析


**🔸 影响力评估指标**

```sql
-- 用户影响力分析视图
CREATE VIEW user_influence_analysis AS
SELECT 
    u.id,
    u.nickname,
    u.follower_count,
    u.post_count,
    COALESCE(content_stats.total_likes, 0) as total_content_likes,
    COALESCE(content_stats.total_comments, 0) as total_content_comments,
    COALESCE(content_stats.total_shares, 0) as total_content_shares,
    -- 计算影响力得分
    (
        u.follower_count * 0.3 + 
        COALESCE(content_stats.total_likes, 0) * 0.4 + 
        COALESCE(content_stats.total_comments, 0) * 0.2 + 
        COALESCE(content_stats.total_shares, 0) * 0.1
    ) as influence_score
FROM users u
LEFT JOIN (
    SELECT 
        author_id,
        SUM(like_count) as total_likes,
        SUM(comment_count) as total_comments,
        SUM(share_count) as total_shares
    FROM posts 
    WHERE status = 1
    GROUP BY author_id
) content_stats ON u.id = content_stats.author_id;
```

---

## 7. 🎯 内容推荐算法


### 7.1 推荐算法基本原理


**🔸 为什么需要推荐算法**

当平台内容越来越多时，用户很难找到自己感兴趣的内容。推荐算法就像一个贴心的朋友，根据你的喜好主动推荐可能感兴趣的内容。

**🔸 推荐算法分类**
```
协同过滤：看和你相似的人喜欢什么，推荐给你
内容推荐：分析内容特征，推荐相似内容
热门推荐：推荐当前最受欢迎的内容  
社交推荐：推荐你关注的人发布的内容
```

### 7.2 基于协同过滤的推荐


**🔸 用户相似度计算**

```sql
-- 计算用户相似度（基于点赞行为）
SELECT 
    ul2.user_id as similar_user,
    COUNT(*) as common_likes,
    COUNT(*) / (
        SELECT COUNT(*) FROM user_likes WHERE user_id = 123
    ) as similarity_score
FROM user_likes ul1
JOIN user_likes ul2 ON ul1.content_id = ul2.content_id 
                   AND ul1.content_type = ul2.content_type
WHERE ul1.user_id = 123 
  AND ul2.user_id != 123
GROUP BY ul2.user_id
HAVING common_likes >= 3
ORDER BY similarity_score DESC
LIMIT 20;
```

**🔸 基于相似用户的内容推荐**

```sql
-- 推荐相似用户喜欢的内容
SELECT 
    p.id,
    p.title,
    p.like_count,
    COUNT(DISTINCT ul.user_id) as liked_by_similar_users,
    AVG(similarity.similarity_score) as avg_similarity
FROM posts p
JOIN user_likes ul ON p.id = ul.content_id AND ul.content_type = 'post'
JOIN (
    -- 找相似用户的子查询
    SELECT 
        ul2.user_id as similar_user,
        COUNT(*) / (SELECT COUNT(*) FROM user_likes WHERE user_id = 123) as similarity_score
    FROM user_likes ul1
    JOIN user_likes ul2 ON ul1.content_id = ul2.content_id
    WHERE ul1.user_id = 123 AND ul2.user_id != 123
    GROUP BY ul2.user_id
    HAVING COUNT(*) >= 3
) similarity ON ul.user_id = similarity.similar_user
WHERE p.id NOT IN (
    SELECT content_id FROM user_likes 
    WHERE user_id = 123 AND content_type = 'post'
)
GROUP BY p.id, p.title, p.like_count
ORDER BY liked_by_similar_users DESC, avg_similarity DESC
LIMIT 10;
```

### 7.3 内容推荐优化


**🔸 推荐结果记录表**

```sql
-- 推荐记录表
CREATE TABLE recommendation_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    content_id INT NOT NULL,
    content_type VARCHAR(20) NOT NULL,
    algorithm VARCHAR(50) NOT NULL,        -- 推荐算法：collaborative、content、hot
    score DECIMAL(8,4) NOT NULL,           -- 推荐分数
    position INT NOT NULL,                 -- 推荐位置
    is_clicked TINYINT DEFAULT 0,          -- 是否点击
    is_liked TINYINT DEFAULT 0,            -- 是否点赞
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user_time (user_id, created_at),
    INDEX idx_content (content_id, content_type)
);

-- 推荐效果统计
SELECT 
    algorithm,
    COUNT(*) as total_recommendations,
    SUM(is_clicked) as total_clicks,
    SUM(is_liked) as total_likes,
    SUM(is_clicked) / COUNT(*) * 100 as click_rate,
    SUM(is_liked) / COUNT(*) * 100 as like_rate
FROM recommendation_logs
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY algorithm
ORDER BY click_rate DESC;
```

---

## 8. 🛡️ 社区管理功能


### 8.1 内容审核机制


**🔸 为什么需要内容审核**

社区就像一个公共场所，需要维持秩序。内容审核就像保安，确保不良内容不会影响其他用户的体验。

**🔸 审核策略**
```
机器预审：使用关键词过滤、AI识别等技术初步筛查
人工复审：对机器标记的内容进行人工确认
用户举报：让社区用户参与监督
事后处理：对已发布内容的投诉处理
```

### 8.2 举报处理系统


**🔸 举报记录表**

```sql
-- 举报记录表
CREATE TABLE reports (
    id INT PRIMARY KEY AUTO_INCREMENT,
    reporter_id INT NOT NULL,              -- 举报人
    target_id INT NOT NULL,                -- 被举报对象ID
    target_type VARCHAR(20) NOT NULL,      -- 被举报类型：post、comment、user
    reason VARCHAR(100) NOT NULL,          -- 举报原因
    description TEXT,                      -- 详细描述
    status VARCHAR(20) DEFAULT 'pending',  -- 处理状态：pending、processing、resolved
    reviewer_id INT,                       -- 审核员ID
    result VARCHAR(50),                    -- 处理结果：no_violation、warning、delete、ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP NULL,
    
    INDEX idx_target (target_id, target_type),
    INDEX idx_status (status),
    INDEX idx_reporter (reporter_id)
);

-- 处理举报的存储过程
DELIMITER //
CREATE PROCEDURE ProcessReport(
    IN p_report_id INT,
    IN p_reviewer_id INT,
    IN p_result VARCHAR(50),
    IN p_note TEXT
)
BEGIN
    DECLARE v_target_id INT;
    DECLARE v_target_type VARCHAR(20);
    DECLARE v_reporter_id INT;
    
    START TRANSACTION;
    
    -- 获取举报信息
    SELECT target_id, target_type, reporter_id
    INTO v_target_id, v_target_type, v_reporter_id
    FROM reports WHERE id = p_report_id;
    
    -- 更新举报状态
    UPDATE reports 
    SET status = 'resolved',
        reviewer_id = p_reviewer_id,
        result = p_result,
        resolved_at = CURRENT_TIMESTAMP
    WHERE id = p_report_id;
    
    -- 根据处理结果执行相应操作
    CASE p_result
        WHEN 'delete' THEN
            CASE v_target_type
                WHEN 'post' THEN 
                    UPDATE posts SET status = -1 WHERE id = v_target_id;
                WHEN 'comment' THEN 
                    UPDATE comments SET status = 0 WHERE id = v_target_id;
            END CASE;
        WHEN 'warning' THEN
            -- 给用户发警告通知
            INSERT INTO user_notifications (user_id, type, content)
            SELECT user_id, 'warning', p_note
            FROM posts WHERE id = v_target_id AND v_target_type = 'post'
            UNION
            SELECT user_id, 'warning', p_note  
            FROM comments WHERE id = v_target_id AND v_target_type = 'comment';
    END CASE;
    
    COMMIT;
END //
DELIMITER ;
```

### 8.3 社区治理自动化


**🔸 违规行为积分系统**

```sql
-- 用户违规记录表
CREATE TABLE user_violations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    violation_type VARCHAR(50) NOT NULL,   -- 违规类型
    points INT NOT NULL,                   -- 违规积分
    description TEXT,                      -- 违规描述
    status VARCHAR(20) DEFAULT 'active',   -- 状态：active、expired
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,                  -- 过期时间
    
    INDEX idx_user (user_id),
    INDEX idx_status_expires (status, expires_at)
);

-- 自动处罚规则
SELECT 
    user_id,
    SUM(points) as total_violation_points
FROM user_violations 
WHERE status = 'active' 
  AND (expires_at IS NULL OR expires_at > NOW())
GROUP BY user_id
HAVING total_violation_points >= 100;  -- 达到100分自动封禁
```

---

## 9. ⚡ 性能优化策略


### 9.1 数据库优化


**🔸 读写分离策略**

社交功能读多写少的特点，适合使用读写分离：

```sql
-- 主库（写操作）：用户发布、点赞、评论
-- 从库（读操作）：内容浏览、统计查询

-- 配置读写分离的视图
CREATE VIEW posts_read AS 
SELECT * FROM posts WHERE status = 1;

CREATE VIEW comments_read AS
SELECT * FROM comments WHERE status = 1;
```

**🔸 分表分库策略**

```sql
-- 按用户ID分表的用户行为表
CREATE TABLE user_behaviors_0 LIKE user_behaviors;
CREATE TABLE user_behaviors_1 LIKE user_behaviors;
CREATE TABLE user_behaviors_2 LIKE user_behaviors;
CREATE TABLE user_behaviors_3 LIKE user_behaviors;

-- 分表路由函数
DELIMITER //
CREATE FUNCTION GetBehaviorTable(p_user_id INT) 
RETURNS VARCHAR(50)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_table_suffix INT;
    SET v_table_suffix = p_user_id % 4;
    RETURN CONCAT('user_behaviors_', v_table_suffix);
END //
DELIMITER ;
```

### 9.2 缓存优化策略


**🔸 多级缓存架构**

```
L1缓存：应用内存缓存（用户会话、热点数据）
L2缓存：Redis集群（用户信息、内容详情、关系数据）
L3缓存：CDN（静态资源、热门内容）

缓存更新策略：
- 写入时更新缓存（Write Through）
- 删除时清理缓存（Cache Aside）  
- 定时刷新热点数据（Scheduled Refresh）
```

**🔸 缓存键设计规范**

```
用户信息：user:info:{user_id}
用户关注列表：user:following:{user_id}
用户粉丝列表：user:followers:{user_id}
内容详情：content:{type}:{id}
内容点赞数：content:likes:{type}:{id}
热门内容：trending:content:{category}
```

### 9.3 社交关系数据存储优化


**🔸 关注关系的双向索引**

```sql
-- 为了优化关注关系查询，建立双向索引表
CREATE TABLE user_follows_index (
    user_id INT NOT NULL,
    relation_type ENUM('following', 'follower') NOT NULL,
    related_user_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (user_id, relation_type, related_user_id),
    INDEX idx_related_user (related_user_id, relation_type)
);

-- 当用户A关注用户B时，同时写入两条记录：
-- (A, 'following', B) - A的关注列表中包含B
-- (B, 'follower', A)  - B的粉丝列表中包含A
```

---

## 10. 📋 核心要点总结


### 10.1 社交功能设计要点


**🔸 核心设计原则**
```
🎯 用户体验优先：操作简单、响应快速、交互自然
⚖️ 性能与功能平衡：在功能丰富和系统性能间找平衡
🛡️ 安全与开放并重：既要防止滥用，又要鼓励互动
📊 数据驱动优化：基于用户行为数据持续改进
```

**🔸 数据库设计关键**
```
📋 表结构设计：
• 用户表：存储基本信息和统计数据
• 关系表：记录用户间的关注、点赞等关系
• 行为表：追踪用户的各种互动行为
• 审核表：保障社区内容质量

🔧 索引优化：
• 复合索引：支持多维度查询
• 唯一索引：防止重复操作
• 分区表：处理大数据量
```

### 10.2 关键技术实现


**🔸 评论系统**
- **多级结构**: 支持评论的评论，形成对话树
- **性能优化**: 通过root_id快速查询完整对话
- **内容安全**: 敏感词过滤和人工审核结合

**🔸 点赞收藏**
- **防重复**: 联合唯一索引确保一人一赞
- **实时统计**: 通过存储过程维护计数器
- **分类管理**: 支持不同类型内容的点赞

**🔸 关注系统**
- **关系建模**: 清晰的follower/following模型
- **双向索引**: 支持快速查询关注和粉丝列表
- **状态管理**: 支持取消关注、拉黑等操作

### 10.3 性能优化策略


**🔸 数据库层面**
```
读写分离：读操作走从库，写操作走主库
分表分库：按用户或时间维度分片
索引优化：根据查询模式建立合适索引
数据归档：定期清理过期数据
```

**🔸 应用层面**
```
缓存策略：多级缓存减少数据库压力
异步处理：点赞、评论等操作异步更新统计
批量操作：合并多个小操作减少数据库连接
连接池：复用数据库连接
```

### 10.4 实际应用建议


**🔸 功能规划**
```
📈 渐进式实现：
第一阶段：基础点赞评论
第二阶段：用户关注和推荐  
第三阶段：高级分析和治理

🎯 重点关注：
• 用户体验：响应速度和操作便利性
• 数据质量：准确的统计和分析数据
• 系统稳定：高并发下的稳定运行
```

**🔸 运维监控**
```
📊 关键指标：
• 活跃用户数和互动频率
• 系统响应时间和错误率
• 数据库性能和缓存命中率
• 内容质量和用户举报处理效率

⚠️ 风险控制：
• 防刷机制：避免恶意刷赞刷评论
• 内容审核：及时处理违规内容
• 性能预警：监控系统负载状况
```

**核心记忆要点**:
- 社交功能核心是用户关系和内容互动
- 数据库设计要考虑性能、安全和扩展性
- 缓存和索引是性能优化的关键手段
- 内容审核和社区治理同样重要
- 基于数据分析持续优化用户体验