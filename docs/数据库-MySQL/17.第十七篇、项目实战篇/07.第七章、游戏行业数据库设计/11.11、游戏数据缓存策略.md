---
title: 11ã€æ¸¸æˆæ•°æ®ç¼“å­˜ç­–ç•¥
---
## ğŸ“š ç›®å½•

1. [æ¸¸æˆç¼“å­˜åŸºç¡€æ¦‚å¿µ](#1-æ¸¸æˆç¼“å­˜åŸºç¡€æ¦‚å¿µ)
2. [Redisç¼“å­˜æ¶æ„è®¾è®¡](#2-Redisç¼“å­˜æ¶æ„è®¾è®¡)
3. [çƒ­ç‚¹æ•°æ®ç¼“å­˜ç­–ç•¥](#3-çƒ­ç‚¹æ•°æ®ç¼“å­˜ç­–ç•¥)
4. [ç¼“å­˜æ›´æ–°ä¸ä¸€è‡´æ€§](#4-ç¼“å­˜æ›´æ–°ä¸ä¸€è‡´æ€§)
5. [å¤šçº§ç¼“å­˜æ¶æ„](#5-å¤šçº§ç¼“å­˜æ¶æ„)
6. [ç¼“å­˜é¢„çƒ­ä¸æ™ºèƒ½æ·˜æ±°](#6-ç¼“å­˜é¢„çƒ­ä¸æ™ºèƒ½æ·˜æ±°)
7. [ç¼“å­˜å®‰å…¨ä¸æ€§èƒ½ç›‘æ§](#7-ç¼“å­˜å®‰å…¨ä¸æ€§èƒ½ç›‘æ§)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ® æ¸¸æˆç¼“å­˜åŸºç¡€æ¦‚å¿µ


### 1.1 ä¸ºä»€ä¹ˆæ¸¸æˆéœ€è¦ç¼“å­˜


> **ğŸ’¡ æ ¸å¿ƒç†è§£**  
> æ¸¸æˆç¼“å­˜å°±åƒæ¸¸æˆå…é‡Œçš„"å¿«é€Ÿé€šé“" - æŠŠæœ€å¸¸ç”¨çš„æ•°æ®æ”¾åœ¨æœ€å®¹æ˜“æ‹¿åˆ°çš„åœ°æ–¹

**æ¸¸æˆåœºæ™¯çš„ç‰¹æ®Šæ€§ï¼š**
```
ä¼ ç»Ÿç½‘ç«™ï¼šç”¨æˆ·å¶å°”è®¿é—®ï¼Œæ•°æ®ç›¸å¯¹ç¨³å®š
æ¸¸æˆç³»ç»Ÿï¼šç©å®¶æŒç»­åœ¨çº¿ï¼Œæ•°æ®å®æ—¶å˜åŒ–

å…·ä½“è¡¨ç°ï¼š
â€¢ ç©å®¶çŠ¶æ€ï¼šè¡€é‡ã€ç»éªŒã€ä½ç½® â†’ æ¯«ç§’çº§æ›´æ–°
â€¢ æ’è¡Œæ¦œï¼šå®æ—¶å˜åŒ–ï¼Œé«˜é¢‘æŸ¥è¯¢
â€¢ å•†åŸæ•°æ®ï¼šçƒ­é—¨é“å…·è¢«é¢‘ç¹è´­ä¹°
â€¢ èŠå¤©è®°å½•ï¼šå¤§é‡å¹¶å‘è¯»å†™
```

### 1.2 æ¸¸æˆç¼“å­˜çš„æ ¸å¿ƒä½œç”¨


**ğŸ”¸ è§£å†³çš„æ ¸å¿ƒé—®é¢˜ï¼š**

| **é—®é¢˜åœºæ™¯** | **æ²¡æœ‰ç¼“å­˜** | **ä½¿ç”¨ç¼“å­˜å** | **æ”¹å–„æ•ˆæœ** |
|-------------|-------------|---------------|-------------|
| `ç©å®¶ç™»å½•` | æ•°æ®åº“æŸ¥è¯¢100ms | RedisæŸ¥è¯¢2ms | **é€Ÿåº¦æå‡50å€** |
| `æ’è¡Œæ¦œæŸ¥è¯¢` | æ¯æ¬¡è®¡ç®—500ms | ç›´æ¥è¯»å–5ms | **å“åº”æå‡100å€** |
| `å•†åŸæµè§ˆ` | æ•°æ®åº“å‹åŠ›å¤§ | ç¼“å­˜æ‰¿æ‹…90%è¯·æ±‚ | **æ•°æ®åº“è´Ÿè½½é™ä½** |

### 1.3 ç¼“å­˜vsæ•°æ®åº“çš„åˆ†å·¥


```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ¸¸æˆç³»ç»Ÿ                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ç¼“å­˜å±‚ Redis   â”‚    æ•°æ®åº“ MySQL       â”‚
â”‚                â”‚                       â”‚
â”‚ â€¢ çƒ­ç‚¹æ•°æ®      â”‚ â€¢ å®Œæ•´æŒä¹…åŒ–æ•°æ®        â”‚
â”‚ â€¢ ä¸´æ—¶çŠ¶æ€      â”‚ â€¢ é‡è¦ä¸šåŠ¡æ•°æ®          â”‚
â”‚ â€¢ å®æ—¶è®¡ç®—ç»“æœ  â”‚ â€¢ å†å²è®°å½•             â”‚
â”‚ â€¢ ä¼šè¯ä¿¡æ¯      â”‚ â€¢ é…ç½®ä¿¡æ¯             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç®€å•ç†è§£ï¼š
Redis = å·¥ä½œå°ï¼ˆç»å¸¸ç”¨çš„å·¥å…·æ”¾è¿™é‡Œï¼‰
MySQL = ä»“åº“ï¼ˆæ‰€æœ‰ä¸œè¥¿æœ€ç»ˆéƒ½å­˜è¿™é‡Œï¼‰
```

---

## 2. ğŸ—ï¸ Redisç¼“å­˜æ¶æ„è®¾è®¡


### 2.1 å•æœºRedisæ¶æ„


**â­ é€‚ç”¨åœºæ™¯ï¼š** å°å‹æ¸¸æˆï¼Œç©å®¶æ•°é‡ < 10ä¸‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ¸¸æˆå®¢æˆ·ç«¯  â”‚â”€â”€â”€â–¶â”‚   æ¸¸æˆæœåŠ¡å™¨  â”‚â”€â”€â”€â–¶â”‚   Rediså•æœº   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   MySQLæ•°æ®åº“ â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’» åŸºç¡€é…ç½®ç¤ºä¾‹ï¼š**
```bash
# redis.conf æ ¸å¿ƒé…ç½®
maxmemory 4gb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
```

### 2.2 Redisä¸»ä»æ¶æ„


**â­ é€‚ç”¨åœºæ™¯ï¼š** ä¸­å‹æ¸¸æˆï¼Œç©å®¶æ•°é‡ 10ä¸‡-100ä¸‡

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Redisä¸»åº“  â”‚ â† å†™æ“ä½œ
                    â”‚   (å†™å…¥)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼            â–¼            â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Redisä»åº“1  â”‚ â”‚ Redisä»åº“2  â”‚ â”‚ Redisä»åº“3  â”‚
      â”‚  (è¯»å–)     â”‚ â”‚  (è¯»å–)     â”‚ â”‚  (è¯»å–)     â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”§ é…ç½®è¦ç‚¹ï¼š**
```python
# Pythonè¿æ¥ç¤ºä¾‹
import redis
from redis.sentinel import Sentinel

# é…ç½®å“¨å…µ
sentinel = Sentinel([('localhost', 26379)])
master = sentinel.master_for('mymaster')
slave = sentinel.slave_for('mymaster')

# å†™ä¸»åº“ï¼Œè¯»ä»åº“
def set_player_data(player_id, data):
    master.hset(f"player:{player_id}", mapping=data)

def get_player_data(player_id):
    return slave.hgetall(f"player:{player_id}")
```

### 2.3 Redisé›†ç¾¤æ¶æ„


**â­ é€‚ç”¨åœºæ™¯ï¼š** å¤§å‹æ¸¸æˆï¼Œç©å®¶æ•°é‡ > 100ä¸‡

```
æ¸¸æˆæ•°æ®åˆ†ç‰‡å­˜å‚¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Redisé›†ç¾¤                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   èŠ‚ç‚¹1     â”‚    èŠ‚ç‚¹2    â”‚    èŠ‚ç‚¹3    â”‚    èŠ‚ç‚¹4    â”‚
â”‚  slot 0-4095â”‚slot 4096-8191â”‚slot 8192-12287â”‚slot 12288-16383â”‚
â”‚             â”‚             â”‚             â”‚             â”‚
â”‚ ç©å®¶Aæ•°æ®   â”‚  ç©å®¶Bæ•°æ®  â”‚  ç©å®¶Cæ•°æ®  â”‚  ç©å®¶Dæ•°æ®  â”‚
â”‚ æ’è¡Œæ¦œ1-25% â”‚ æ’è¡Œæ¦œ26-50%â”‚ æ’è¡Œæ¦œ51-75%â”‚ æ’è¡Œæ¦œ76-100%â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. ğŸ”¥ çƒ­ç‚¹æ•°æ®ç¼“å­˜ç­–ç•¥


### 3.1 è¯†åˆ«æ¸¸æˆçƒ­ç‚¹æ•°æ®


> **ğŸ¯ å®è·µåº”ç”¨**  
> çƒ­ç‚¹æ•°æ®å°±åƒæ¸¸æˆé‡Œçš„"çˆ†æ¬¾é“å…·" - å¤§å®¶éƒ½æƒ³è¦ï¼Œè®¿é—®é‡ç‰¹åˆ«é«˜

**ğŸ”¸ æ¸¸æˆä¸­çš„çƒ­ç‚¹æ•°æ®ç±»å‹ï¼š**

| **æ•°æ®ç±»å‹** | **è®¿é—®ç‰¹å¾** | **ç¼“å­˜ç­–ç•¥** | **è¿‡æœŸæ—¶é—´** |
|-------------|-------------|-------------|-------------|
| `ç©å®¶åŸºç¡€ä¿¡æ¯` | ç™»å½•æ—¶è¯»å–ï¼Œæ¸¸æˆä¸­é¢‘ç¹æ›´æ–° | `hashå­˜å‚¨` | **30åˆ†é’Ÿ** |
| `æ¸¸æˆæ’è¡Œæ¦œ` | é«˜é¢‘æŸ¥è¯¢ï¼Œå®šæœŸæ›´æ–° | `zsetå­˜å‚¨` | **5åˆ†é’Ÿ** |
| `å•†åŸçƒ­é—¨é“å…·` | å¤§é‡ç©å®¶æµè§ˆè´­ä¹° | `stringå­˜å‚¨` | **10åˆ†é’Ÿ** |
| `èŠå¤©è®°å½•` | å®æ—¶è¯»å†™ | `listå­˜å‚¨` | **1å°æ—¶** |

### 3.2 çƒ­ç‚¹æ•°æ®ç¼“å­˜å®ç°


**ğŸ“ ç©å®¶æ•°æ®ç¼“å­˜ï¼š**
```python
class PlayerCache:
    def __init__(self, redis_client):
        self.redis = redis_client
        
    def cache_player_info(self, player_id, player_data):
        """ç¼“å­˜ç©å®¶åŸºç¡€ä¿¡æ¯"""
        key = f"player:{player_id}:info"
        
        # ä½¿ç”¨hashå­˜å‚¨ï¼Œæ–¹ä¾¿å•å­—æ®µæ›´æ–°
        self.redis.hset(key, mapping={
            'name': player_data['name'],
            'level': player_data['level'],
            'exp': player_data['exp'],
            'gold': player_data['gold']
        })
        
        # è®¾ç½®è¿‡æœŸæ—¶é—´30åˆ†é’Ÿ
        self.redis.expire(key, 1800)
    
    def get_player_info(self, player_id):
        """è·å–ç©å®¶ä¿¡æ¯"""
        key = f"player:{player_id}:info"
        return self.redis.hgetall(key)
    
    def update_player_gold(self, player_id, new_gold):
        """æ›´æ–°ç©å®¶é‡‘å¸ï¼ˆå•å­—æ®µæ›´æ–°ï¼‰"""
        key = f"player:{player_id}:info"
        self.redis.hset(key, 'gold', new_gold)
```

**ğŸ“Š æ’è¡Œæ¦œç¼“å­˜ï¼š**
```python
class RankingCache:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def update_ranking(self, ranking_type, player_id, score):
        """æ›´æ–°æ’è¡Œæ¦œ"""
        key = f"ranking:{ranking_type}"
        
        # ä½¿ç”¨zsetå­˜å‚¨ï¼Œè‡ªåŠ¨æ’åº
        self.redis.zadd(key, {player_id: score})
        
        # åªä¿ç•™å‰100å
        self.redis.zremrangebyrank(key, 0, -101)
        
        # 5åˆ†é’Ÿè¿‡æœŸï¼Œå¼ºåˆ¶åˆ·æ–°
        self.redis.expire(key, 300)
    
    def get_top_players(self, ranking_type, limit=10):
        """è·å–æ’è¡Œæ¦œå‰Nå"""
        key = f"ranking:{ranking_type}"
        
        # æŒ‰åˆ†æ•°å€’åºè·å–
        return self.redis.zrevrange(key, 0, limit-1, withscores=True)
```

### 3.3 ç¼“å­˜ç©¿é€é˜²æŠ¤


> **âš ï¸ æ³¨æ„äº‹é¡¹**  
> ç¼“å­˜ç©¿é€å°±åƒ"é»‘å®¢æ”»å‡»" - æ•…æ„æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®ï¼Œç»•è¿‡ç¼“å­˜ç›´å‡»æ•°æ®åº“

**ğŸ›¡ï¸ å¸ƒéš†è¿‡æ»¤å™¨é˜²æŠ¤ï¼š**
```python
from pybloom_live import BloomFilter

class CachePenetrationProtection:
    def __init__(self, redis_client):
        self.redis = redis_client
        # åˆ›å»ºå¸ƒéš†è¿‡æ»¤å™¨ï¼Œé¢„è®¡100ä¸‡ç©å®¶ï¼Œè¯¯åˆ¤ç‡0.1%
        self.bloom_filter = BloomFilter(capacity=1000000, error_rate=0.001)
        
    def add_valid_player(self, player_id):
        """æ·»åŠ æœ‰æ•ˆç©å®¶IDåˆ°å¸ƒéš†è¿‡æ»¤å™¨"""
        self.bloom_filter.add(str(player_id))
    
    def is_valid_player(self, player_id):
        """æ£€æŸ¥ç©å®¶IDæ˜¯å¦å¯èƒ½å­˜åœ¨"""
        return str(player_id) in self.bloom_filter
    
    def get_player_safe(self, player_id):
        """å®‰å…¨è·å–ç©å®¶ä¿¡æ¯"""
        # å…ˆç”¨å¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥
        if not self.is_valid_player(player_id):
            return None  # è‚¯å®šä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›
        
        # å¯èƒ½å­˜åœ¨ï¼Œç»§ç»­æ­£å¸¸æµç¨‹
        return self.get_player_from_cache_or_db(player_id)
```

---

## 4. ğŸ”„ ç¼“å­˜æ›´æ–°ä¸ä¸€è‡´æ€§


### 4.1 ç¼“å­˜æ›´æ–°ç­–ç•¥å¯¹æ¯”


> **ğŸ“‹ å…³é”®ç†è§£**  
> ç¼“å­˜æ›´æ–°å°±åƒ"ä¿æŒä¿¡æ¯åŒæ­¥" - è¦ç¡®ä¿ç¼“å­˜é‡Œçš„æ•°æ®å’Œæ•°æ®åº“é‡Œçš„æ•°æ®ä¸€è‡´

| **ç­–ç•¥** | **æ“ä½œæµç¨‹** | **ä¼˜ç‚¹** | **ç¼ºç‚¹** | **é€‚ç”¨åœºæ™¯** |
|---------|-------------|---------|---------|-------------|
| **Cache Aside** | `æ›´æ–°DB â†’ åˆ é™¤ç¼“å­˜` | ç®€å•å¯é  | å¯èƒ½ç¼“å­˜miss | ğŸ“± **ç©å®¶ä¿¡æ¯æ›´æ–°** |
| **Write Through** | `åŒæ—¶æ›´æ–°DBå’Œç¼“å­˜` | æ•°æ®ä¸€è‡´æ€§å¥½ | å†™æ€§èƒ½è¾ƒä½ | ğŸ’° **é‡‘å¸æ‰£å‡æ“ä½œ** |
| **Write Behind** | `å…ˆæ›´æ–°ç¼“å­˜ â†’ å¼‚æ­¥æ›´æ–°DB` | å†™æ€§èƒ½æœ€é«˜ | å¯èƒ½æ•°æ®ä¸¢å¤± | ğŸ“Š **å®æ—¶æ’è¡Œæ¦œ** |

### 4.2 Cache Asideæ¨¡å¼å®ç°


**ğŸ’» æœ€å¸¸ç”¨çš„ç¼“å­˜æ›´æ–°æ¨¡å¼ï¼š**
```python
class GameDataService:
    def __init__(self, redis_client, mysql_client):
        self.redis = redis_client
        self.mysql = mysql_client
    
    def update_player_level(self, player_id, new_level):
        """æ›´æ–°ç©å®¶ç­‰çº§"""
        try:
            # 1. å…ˆæ›´æ–°æ•°æ®åº“
            self.mysql.execute(
                "UPDATE players SET level = %s WHERE id = %s",
                (new_level, player_id)
            )
            self.mysql.commit()
            
            # 2. åˆ é™¤ç¼“å­˜ï¼Œä¸‹æ¬¡è¯»å–æ—¶é‡æ–°åŠ è½½
            cache_key = f"player:{player_id}:info"
            self.redis.delete(cache_key)
            
            return True
            
        except Exception as e:
            self.mysql.rollback()
            print(f"æ›´æ–°å¤±è´¥: {e}")
            return False
    
    def get_player_level(self, player_id):
        """è·å–ç©å®¶ç­‰çº§"""
        cache_key = f"player:{player_id}:info"
        
        # 1. å…ˆä»ç¼“å­˜è¯»å–
        cached_data = self.redis.hget(cache_key, 'level')
        if cached_data:
            return int(cached_data)
        
        # 2. ç¼“å­˜missï¼Œä»æ•°æ®åº“è¯»å–
        result = self.mysql.execute(
            "SELECT level FROM players WHERE id = %s", 
            (player_id,)
        ).fetchone()
        
        if result:
            level = result[0]
            # 3. å†™å…¥ç¼“å­˜
            self.redis.hset(cache_key, 'level', level)
            self.redis.expire(cache_key, 1800)  # 30åˆ†é’Ÿè¿‡æœŸ
            return level
            
        return None
```

### 4.3 åˆ†å¸ƒå¼ç¼“å­˜ä¸€è‡´æ€§


**ğŸ”§ ä½¿ç”¨åˆ†å¸ƒå¼é”ä¿è¯ä¸€è‡´æ€§ï¼š**
```python
import time
import uuid

class DistributedLock:
    def __init__(self, redis_client, key, timeout=10):
        self.redis = redis_client
        self.key = f"lock:{key}"
        self.timeout = timeout
        self.identifier = str(uuid.uuid4())
    
    def acquire(self):
        """è·å–åˆ†å¸ƒå¼é”"""
        end_time = time.time() + self.timeout
        
        while time.time() < end_time:
            # å°è¯•è·å–é”ï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´é˜²æ­»é”
            if self.redis.set(self.key, self.identifier, 
                            nx=True, ex=self.timeout):
                return True
            time.sleep(0.001)  # 1msåé‡è¯•
        
        return False
    
    def release(self):
        """é‡Šæ”¾åˆ†å¸ƒå¼é”"""
        # ä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """
        return self.redis.eval(lua_script, 1, self.key, self.identifier)

# ä½¿ç”¨åˆ†å¸ƒå¼é”æ›´æ–°çƒ­ç‚¹æ•°æ®
def update_ranking_safe(player_id, new_score):
    """å®‰å…¨æ›´æ–°æ’è¡Œæ¦œ"""
    lock = DistributedLock(redis, f"ranking:level:{player_id}")
    
    if lock.acquire():
        try:
            # æ‰§è¡Œæ›´æ–°æ“ä½œ
            update_player_ranking(player_id, new_score)
        finally:
            lock.release()
    else:
        print("è·å–é”å¤±è´¥ï¼Œç¨åé‡è¯•")
```

---

## 5. ğŸ¢ å¤šçº§ç¼“å­˜æ¶æ„


### 5.1 å¤šçº§ç¼“å­˜è®¾è®¡æ€è·¯


> **ğŸ§  è®°å¿†è¦ç‚¹**  
> å¤šçº§ç¼“å­˜å°±åƒ"å¤šå±‚å‚¨ç‰©æŸœ" - è¶Šå¸¸ç”¨çš„ä¸œè¥¿æ”¾å¾—è¶Šè¿‘ï¼Œè¶Šå°‘ç”¨çš„æ”¾å¾—è¶Šè¿œ

```
æ¸¸æˆå¤šçº§ç¼“å­˜æ¶æ„ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®¢æˆ·ç«¯                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    åº”ç”¨å†…å­˜ç¼“å­˜ï¼ˆæœ€å¿«ï¼‰              â”‚
â”‚  â”‚  æœ¬åœ°ç¼“å­˜   â”‚    â€¢ ç©å®¶å½“å‰è¡€é‡ã€ä½ç½®               â”‚
â”‚  â”‚   L1 Cache  â”‚    â€¢ å½“å‰åœºæ™¯æ•°æ®                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ ä¿å­˜1-5åˆ†é’Ÿ                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æœåŠ¡å™¨ç«¯                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Redisç¼“å­˜ï¼ˆå¿«ï¼‰                  â”‚
â”‚  â”‚   Redis     â”‚    â€¢ ç©å®¶åŸºç¡€ä¿¡æ¯                     â”‚
â”‚  â”‚   L2 Cache  â”‚    â€¢ æ’è¡Œæ¦œæ•°æ®                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ ä¿å­˜10-30åˆ†é’Ÿ                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    MySQLæ•°æ®åº“ï¼ˆæ…¢ä½†å®Œæ•´ï¼‰          â”‚
â”‚  â”‚   MySQL     â”‚    â€¢ æ‰€æœ‰æŒä¹…åŒ–æ•°æ®                   â”‚
â”‚  â”‚  L3 Storage â”‚    â€¢ å†å²è®°å½•                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ æ°¸ä¹…ä¿å­˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 æœ¬åœ°ç¼“å­˜å®ç°


**ğŸ’¾ åº”ç”¨å†…å­˜ç¼“å­˜ï¼š**
```python
import time
from threading import Lock

class LocalCache:
    def __init__(self, max_size=1000, default_ttl=300):
        self.cache = {}
        self.timestamps = {}
        self.max_size = max_size
        self.default_ttl = default_ttl
        self.lock = Lock()
    
    def get(self, key):
        """è·å–ç¼“å­˜æ•°æ®"""
        with self.lock:
            if key not in self.cache:
                return None
            
            # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            if time.time() - self.timestamps[key] > self.default_ttl:
                del self.cache[key]
                del self.timestamps[key]
                return None
            
            return self.cache[key]
    
    def set(self, key, value, ttl=None):
        """è®¾ç½®ç¼“å­˜æ•°æ®"""
        if ttl is None:
            ttl = self.default_ttl
            
        with self.lock:
            # å¦‚æœç¼“å­˜æ»¡äº†ï¼Œåˆ é™¤æœ€æ—§çš„æ•°æ®
            if len(self.cache) >= self.max_size:
                oldest_key = min(self.timestamps.keys(), 
                               key=lambda k: self.timestamps[k])
                del self.cache[oldest_key]
                del self.timestamps[oldest_key]
            
            self.cache[key] = value
            self.timestamps[key] = time.time()

# æ¸¸æˆä¸­çš„ä½¿ç”¨ç¤ºä¾‹
class GameService:
    def __init__(self):
        self.local_cache = LocalCache(max_size=500)
        self.redis = redis.Redis()
    
    def get_player_info(self, player_id):
        """å¤šçº§ç¼“å­˜è·å–ç©å®¶ä¿¡æ¯"""
        # 1. å…ˆæŸ¥æœ¬åœ°ç¼“å­˜ï¼ˆæœ€å¿«ï¼‰
        cache_key = f"player_info_{player_id}"
        player_info = self.local_cache.get(cache_key)
        if player_info:
            return player_info
        
        # 2. æŸ¥Redisç¼“å­˜ï¼ˆè¾ƒå¿«ï¼‰
        redis_key = f"player:{player_id}:info"
        player_info = self.redis.hgetall(redis_key)
        if player_info:
            # å†™å…¥æœ¬åœ°ç¼“å­˜
            self.local_cache.set(cache_key, player_info)
            return player_info
        
        # 3. æŸ¥æ•°æ®åº“ï¼ˆæ…¢ï¼‰
        player_info = self.load_from_database(player_id)
        if player_info:
            # å†™å…¥Rediså’Œæœ¬åœ°ç¼“å­˜
            self.redis.hset(redis_key, mapping=player_info)
            self.local_cache.set(cache_key, player_info)
        
        return player_info
```

---

## 6. ğŸš€ ç¼“å­˜é¢„çƒ­ä¸æ™ºèƒ½æ·˜æ±°


### 6.1 ç¼“å­˜é¢„çƒ­ç­–ç•¥


> **ğŸ’¡ æ ¸å¿ƒç†è§£**  
> ç¼“å­˜é¢„çƒ­å°±åƒ"æå‰å‡†å¤‡" - åœ¨ç©å®¶éœ€è¦ä¹‹å‰å°±æŠŠæ•°æ®å‡†å¤‡å¥½

**ğŸ”¸ æ¸¸æˆåœºæ™¯çš„é¢„çƒ­éœ€æ±‚ï¼š**

```
é¢„çƒ­æ—¶æœºï¼š
âœ… æœåŠ¡å™¨å¯åŠ¨æ—¶       â†’ é¢„çƒ­åŸºç¡€é…ç½®æ•°æ®
âœ… æ–°æ´»åŠ¨å¼€å§‹å‰       â†’ é¢„çƒ­æ´»åŠ¨ç›¸å…³æ•°æ®  
âœ… ç”¨æˆ·ç™»å½•å         â†’ é¢„çƒ­ç©å®¶ç›¸å…³æ•°æ®
âœ… è®¿é—®é‡æ¿€å¢å‰       â†’ é¢„çƒ­çƒ­ç‚¹æ•°æ®
```

**ğŸ“ é¢„çƒ­å®ç°ç¤ºä¾‹ï¼š**
```python
class CacheWarming:
    def __init__(self, redis_client, mysql_client):
        self.redis = redis_client
        self.mysql = mysql_client
    
    def warm_up_rankings(self):
        """é¢„çƒ­æ’è¡Œæ¦œæ•°æ®"""
        print("å¼€å§‹é¢„çƒ­æ’è¡Œæ¦œæ•°æ®...")
        
        # é¢„çƒ­å„ç§æ’è¡Œæ¦œ
        ranking_types = ['level', 'gold', 'combat_power']
        
        for ranking_type in ranking_types:
            # ä»æ•°æ®åº“è·å–top100ç©å®¶
            sql = f"""
            SELECT player_id, {ranking_type} 
            FROM players 
            ORDER BY {ranking_type} DESC 
            LIMIT 100
            """
            
            results = self.mysql.execute(sql).fetchall()
            
            if results:
                # æ‰¹é‡å†™å…¥Redis
                key = f"ranking:{ranking_type}"
                ranking_data = {str(row[0]): row[1] for row in results}
                
                self.redis.zadd(key, ranking_data)
                self.redis.expire(key, 3600)  # 1å°æ—¶è¿‡æœŸ
                
                print(f"é¢„çƒ­ {ranking_type} æ’è¡Œæ¦œå®Œæˆï¼Œå…±{len(results)}æ¡è®°å½•")
    
    def warm_up_player_data(self, player_id):
        """ç©å®¶ç™»å½•æ—¶é¢„çƒ­ç›¸å…³æ•°æ®"""
        # é¢„çƒ­ç©å®¶åŸºç¡€ä¿¡æ¯
        player_info = self.load_player_from_db(player_id)
        if player_info:
            key = f"player:{player_id}:info"
            self.redis.hset(key, mapping=player_info)
            
        # é¢„çƒ­ç©å®¶å¥½å‹åˆ—è¡¨
        friends = self.load_friends_from_db(player_id)
        if friends:
            key = f"player:{player_id}:friends"
            self.redis.sadd(key, *friends)
            
        # é¢„çƒ­ç©å®¶èƒŒåŒ…ä¿¡æ¯
        inventory = self.load_inventory_from_db(player_id)
        if inventory:
            key = f"player:{player_id}:inventory"
            self.redis.hset(key, mapping=inventory)
```

### 6.2 æ™ºèƒ½ç¼“å­˜æ·˜æ±°


**ğŸ¯ LRU + TTL ç»„åˆç­–ç•¥ï¼š**
```python
class SmartCacheEviction:
    def __init__(self, redis_client):
        self.redis = redis_client
        
        # ä¸åŒç±»å‹æ•°æ®çš„TTLç­–ç•¥
        self.ttl_config = {
            'player:*:info': 1800,      # ç©å®¶ä¿¡æ¯30åˆ†é’Ÿ
            'ranking:*': 300,           # æ’è¡Œæ¦œ5åˆ†é’Ÿ
            'config:*': 3600,          # é…ç½®æ•°æ®1å°æ—¶
            'chat:*': 600,             # èŠå¤©è®°å½•10åˆ†é’Ÿ
        }
    
    def set_with_smart_ttl(self, key, value):
        """æ ¹æ®keyç±»å‹è®¾ç½®æ™ºèƒ½TTL"""
        ttl = 1800  # é»˜è®¤30åˆ†é’Ÿ
        
        # æ ¹æ®keyæ¨¡å¼åŒ¹é…TTL
        for pattern, pattern_ttl in self.ttl_config.items():
            if self.match_pattern(key, pattern):
                ttl = pattern_ttl
                break
        
        # æ ¹æ®æ•°æ®è®¿é—®é¢‘ç‡è°ƒæ•´TTL
        access_count = self.get_access_count(key)
        if access_count > 100:  # é«˜é¢‘è®¿é—®æ•°æ®å»¶é•¿TTL
            ttl = int(ttl * 1.5)
        elif access_count < 10:  # ä½é¢‘è®¿é—®æ•°æ®ç¼©çŸ­TTL
            ttl = int(ttl * 0.5)
        
        self.redis.setex(key, ttl, value)
        self.update_access_count(key)
    
    def match_pattern(self, key, pattern):
        """ç®€å•çš„æ¨¡å¼åŒ¹é…"""
        pattern_parts = pattern.split('*')
        if len(pattern_parts) == 2:
            return key.startswith(pattern_parts[0]) and key.endswith(pattern_parts[1])
        return False
    
    def cleanup_expired_data(self):
        """å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®"""
        # è·å–æ‰€æœ‰key
        all_keys = self.redis.keys('*')
        expired_count = 0
        
        for key in all_keys:
            ttl = self.redis.ttl(key)
            if ttl == -1:  # æ²¡æœ‰è¿‡æœŸæ—¶é—´çš„key
                # ä¸ºå…¶è®¾ç½®é»˜è®¤è¿‡æœŸæ—¶é—´
                self.redis.expire(key, 3600)
            elif ttl == -2:  # å·²è¿‡æœŸçš„key
                expired_count += 1
        
        print(f"æ¸…ç†äº† {expired_count} ä¸ªè¿‡æœŸé”®")
```

### 6.3 ç¼“å­˜æ•°æ®å‹ç¼©


**ğŸ’¾ èŠ‚çœå†…å­˜çš„å‹ç¼©ç­–ç•¥ï¼š**
```python
import json
import zlib
import pickle

class CacheCompression:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def set_compressed(self, key, data, compress_threshold=1024):
        """å‹ç¼©å­˜å‚¨æ•°æ®"""
        # åºåˆ—åŒ–æ•°æ®
        serialized = pickle.dumps(data)
        
        # å¦‚æœæ•°æ®å¤§äºé˜ˆå€¼ï¼Œè¿›è¡Œå‹ç¼©
        if len(serialized) > compress_threshold:
            compressed = zlib.compress(serialized)
            # æ ‡è®°ä¸ºå‹ç¼©æ•°æ®
            self.redis.set(f"{key}:compressed", compressed)
            # è®°å½•å‹ç¼©ä¿¡æ¯
            compression_ratio = len(compressed) / len(serialized)
            print(f"æ•°æ®å‹ç¼©å®Œæˆï¼Œå‹ç¼©ç‡: {compression_ratio:.2f}")
        else:
            # å°æ•°æ®ä¸å‹ç¼©
            self.redis.set(key, serialized)
    
    def get_compressed(self, key):
        """è·å–å‹ç¼©æ•°æ®"""
        # å…ˆå°è¯•è·å–å‹ç¼©æ•°æ®
        compressed_key = f"{key}:compressed"
        compressed_data = self.redis.get(compressed_key)
        
        if compressed_data:
            # è§£å‹ç¼©
            decompressed = zlib.decompress(compressed_data)
            return pickle.loads(decompressed)
        else:
            # è·å–æœªå‹ç¼©æ•°æ®
            data = self.redis.get(key)
            return pickle.loads(data) if data else None

# ä½¿ç”¨ç¤ºä¾‹ï¼šå¤§æ•°æ®å¯¹è±¡å‹ç¼©å­˜å‚¨
class PlayerInventory:
    def save_large_inventory(self, player_id, inventory_data):
        """ä¿å­˜å¤§å‹èƒŒåŒ…æ•°æ®ï¼ˆå¯èƒ½æœ‰ä¸Šåƒä¸ªé“å…·ï¼‰"""
        cache = CacheCompression(self.redis)
        key = f"player:{player_id}:inventory"
        
        # å‹ç¼©å­˜å‚¨
        cache.set_compressed(key, inventory_data)
```

---

## 7. ğŸ›¡ï¸ ç¼“å­˜å®‰å…¨ä¸æ€§èƒ½ç›‘æ§


### 7.1 ç¼“å­˜é›ªå´©é˜²æŠ¤


> **âš ï¸ æ³¨æ„äº‹é¡¹**  
> ç¼“å­˜é›ªå´©å°±åƒ"æœåŠ¡å™¨å´©æºƒè¿é”ååº”" - å¤§é‡ç¼“å­˜åŒæ—¶å¤±æ•ˆï¼Œæ‰€æœ‰è¯·æ±‚æ¶Œå‘æ•°æ®åº“

**ğŸ›¡ï¸ é˜²æŠ¤ç­–ç•¥ï¼š**

| **é˜²æŠ¤æ–¹æ³•** | **å®ç°åŸç†** | **é€‚ç”¨åœºæ™¯** |
|-------------|-------------|-------------|
| **éšæœºTTL** | è¿‡æœŸæ—¶é—´ + éšæœºå€¼ | ğŸ® **æ‰€æœ‰ç¼“å­˜æ•°æ®** |
| **ç†”æ–­æœºåˆ¶** | æ•°æ®åº“å‹åŠ›è¿‡å¤§æ—¶æ‹’ç»æœåŠ¡ | ğŸš¨ **ç´§æ€¥ä¿æŠ¤** |
| **å¤šçº§ç¼“å­˜** | æœ¬åœ°ç¼“å­˜ + Redisç¼“å­˜ | ğŸ“± **æ ¸å¿ƒåŠŸèƒ½** |

```python
import random
import time
from functools import wraps

class AvalancheProtection:
    def __init__(self, redis_client, mysql_client):
        self.redis = redis_client
        self.mysql = mysql_client
        self.circuit_breaker = {'is_open': False, 'fail_count': 0}
    
    def set_with_random_ttl(self, key, value, base_ttl=1800):
        """è®¾ç½®éšæœºTTLé˜²æ­¢ç¼“å­˜é›ªå´©"""
        # åŸºç¡€TTL + éšæœºæ—¶é—´ï¼ˆé˜²æ­¢åŒæ—¶è¿‡æœŸï¼‰
        random_ttl = base_ttl + random.randint(0, 300)  # 0-5åˆ†é’Ÿéšæœº
        self.redis.setex(key, random_ttl, value)
    
    def circuit_breaker_decorator(self, func):
        """ç†”æ–­å™¨è£…é¥°å™¨"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            # å¦‚æœç†”æ–­å™¨æ‰“å¼€ï¼Œç›´æ¥è¿”å›é»˜è®¤å€¼
            if self.circuit_breaker['is_open']:
                return None
            
            try:
                result = func(*args, **kwargs)
                # æˆåŠŸåˆ™é‡ç½®å¤±è´¥è®¡æ•°
                self.circuit_breaker['fail_count'] = 0
                return result
                
            except Exception as e:
                # å¤±è´¥è®¡æ•°å¢åŠ 
                self.circuit_breaker['fail_count'] += 1
                
                # å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼ï¼Œæ‰“å¼€ç†”æ–­å™¨
                if self.circuit_breaker['fail_count'] >= 5:
                    self.circuit_breaker['is_open'] = True
                    print("ç†”æ–­å™¨æ‰“å¼€ï¼Œæš‚åœæ•°æ®åº“è®¿é—®")
                    
                    # 30ç§’åè‡ªåŠ¨å…³é—­ç†”æ–­å™¨
                    self.schedule_circuit_reset(30)
                
                return None
        return wrapper
    
    def get_player_info_safe(self, player_id):
        """å®‰å…¨è·å–ç©å®¶ä¿¡æ¯"""
        key = f"player:{player_id}:info"
        
        # 1. å°è¯•ä»ç¼“å­˜è·å–
        cached_data = self.redis.get(key)
        if cached_data:
            return json.loads(cached_data)
        
        # 2. ä½¿ç”¨ç†”æ–­å™¨ä¿æŠ¤çš„æ•°æ®åº“æŸ¥è¯¢
        @self.circuit_breaker_decorator
        def load_from_db():
            return self.mysql.execute(
                "SELECT * FROM players WHERE id = %s", (player_id,)
            ).fetchone()
        
        data = load_from_db()
        if data:
            # ä½¿ç”¨éšæœºTTLå­˜å‚¨
            self.set_with_random_ttl(key, json.dumps(data))
        
        return data
```

### 7.2 ç¼“å­˜æ€§èƒ½ç›‘æ§


**ğŸ“Š å…³é”®ç›‘æ§æŒ‡æ ‡ï¼š**
```python
import time
from collections import defaultdict, deque

class CacheMonitor:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.metrics = {
            'hit_count': 0,
            'miss_count': 0,
            'error_count': 0,
            'response_times': deque(maxlen=1000),  # æœ€è¿‘1000æ¬¡å“åº”æ—¶é—´
        }
        self.key_access_count = defaultdict(int)
    
    def record_cache_hit(self, key, response_time):
        """è®°å½•ç¼“å­˜å‘½ä¸­"""
        self.metrics['hit_count'] += 1
        self.metrics['response_times'].append(response_time)
        self.key_access_count[key] += 1
    
    def record_cache_miss(self, key, response_time):
        """è®°å½•ç¼“å­˜æœªå‘½ä¸­"""
        self.metrics['miss_count'] += 1
        self.metrics['response_times'].append(response_time)
    
    def get_cache_stats(self):
        """è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯"""
        total_requests = self.metrics['hit_count'] + self.metrics['miss_count']
        hit_rate = self.metrics['hit_count'] / total_requests if total_requests > 0 else 0
        
        response_times = list(self.metrics['response_times'])
        avg_response_time = sum(response_times) / len(response_times) if response_times else 0
        
        return {
            'hit_rate': f"{hit_rate:.2%}",
            'total_requests': total_requests,
            'avg_response_time': f"{avg_response_time:.2f}ms",
            'redis_memory_usage': self.get_redis_memory_info(),
            'top_accessed_keys': self.get_top_accessed_keys(10)
        }
    
    def get_redis_memory_info(self):
        """è·å–Rediså†…å­˜ä½¿ç”¨æƒ…å†µ"""
        info = self.redis.info('memory')
        used_memory = info.get('used_memory_human', 'N/A')
        max_memory = info.get('maxmemory_human', 'N/A')
        
        return f"{used_memory} / {max_memory}"
    
    def get_top_accessed_keys(self, top_n=10):
        """è·å–è®¿é—®æœ€é¢‘ç¹çš„key"""
        sorted_keys = sorted(
            self.key_access_count.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        return sorted_keys[:top_n]

# ç›‘æ§è£…é¥°å™¨
def cache_monitor(monitor):
    def decorator(func):
        @wraps(func)
        def wrapper(self, key, *args, **kwargs):
            start_time = time.time()
            
            try:
                result = func(self, key, *args, **kwargs)
                response_time = (time.time() - start_time) * 1000
                
                if result:
                    monitor.record_cache_hit(key, response_time)
                else:
                    monitor.record_cache_miss(key, response_time)
                
                return result
                
            except Exception as e:
                monitor.metrics['error_count'] += 1
                raise e
                
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
monitor = CacheMonitor(redis_client)

class MonitoredCacheService:
    @cache_monitor(monitor)
    def get_from_cache(self, key):
        return self.redis.get(key)
```

### 7.3 ç¼“å­˜æˆæœ¬ä¼˜åŒ–


**ğŸ’° æˆæœ¬æ§åˆ¶ç­–ç•¥ï¼š**
```python
class CacheCostOptimizer:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def analyze_memory_usage(self):
        """åˆ†æå†…å­˜ä½¿ç”¨æƒ…å†µ"""
        # è·å–æ‰€æœ‰keyçš„å†…å­˜å ç”¨
        key_sizes = {}
        sample_keys = self.redis.scan(count=1000)[1]  # é‡‡æ ·1000ä¸ªkey
        
        for key in sample_keys:
            try:
                size = self.redis.memory_usage(key)
                key_type = key.decode().split(':')[0] if ':' in key.decode() else 'unknown'
                
                if key_type not in key_sizes:
                    key_sizes[key_type] = {'total_size': 0, 'count': 0}
                
                key_sizes[key_type]['total_size'] += size
                key_sizes[key_type]['count'] += 1
            except:
                continue
        
        # è®¡ç®—æ¯ç§ç±»å‹çš„å¹³å‡å¤§å°
        for key_type, stats in key_sizes.items():
            avg_size = stats['total_size'] / stats['count']
            print(f"{key_type}: å¹³å‡å¤§å° {avg_size:.0f} å­—èŠ‚, æ•°é‡ {stats['count']}")
        
        return key_sizes
    
    def optimize_by_access_pattern(self):
        """æ ¹æ®è®¿é—®æ¨¡å¼ä¼˜åŒ–"""
        # è·å–è®¿é—®ç»Ÿè®¡
        stats = monitor.get_cache_stats()
        top_keys = stats['top_accessed_keys']
        
        print("ğŸ”¥ é«˜é¢‘è®¿é—®keyï¼ˆå»ºè®®å¢åŠ TTLï¼‰:")
        for key, count in top_keys[:5]:
            current_ttl = self.redis.ttl(key)
            print(f"  {key}: è®¿é—®{count}æ¬¡, å½“å‰TTL {current_ttl}ç§’")
        
        # æŸ¥æ‰¾ä½é¢‘è®¿é—®çš„key
        all_keys = self.redis.keys('*')
        low_access_keys = []
        
        for key in all_keys:
            access_count = monitor.key_access_count.get(key.decode(), 0)
            if access_count < 5:  # ä½é¢‘è®¿é—®
                low_access_keys.append((key, access_count))
        
        print("â„ï¸ ä½é¢‘è®¿é—®keyï¼ˆå»ºè®®ç¼©çŸ­TTLæˆ–åˆ é™¤ï¼‰:")
        for key, count in low_access_keys[:10]:
            print(f"  {key}: ä»…è®¿é—®{count}æ¬¡")
        
        return {'high_frequency': top_keys, 'low_frequency': low_access_keys}
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ ç¼“å­˜æœ¬è´¨ï¼šæŠŠç»å¸¸ç”¨çš„æ•°æ®æ”¾åœ¨å¿«é€Ÿè®¿é—®çš„åœ°æ–¹
ğŸ”¸ æ¶æ„é€‰æ‹©ï¼šå•æœºâ†’ä¸»ä»â†’é›†ç¾¤ï¼Œæ ¹æ®æ¸¸æˆè§„æ¨¡é€‰æ‹©
ğŸ”¸ çƒ­ç‚¹è¯†åˆ«ï¼šç©å®¶ä¿¡æ¯ã€æ’è¡Œæ¦œã€å•†åŸæ•°æ®æ˜¯é‡ç‚¹
ğŸ”¸ æ›´æ–°ç­–ç•¥ï¼šCache Asideæ¨¡å¼æœ€å¸¸ç”¨ï¼Œç®€å•å¯é 
ğŸ”¸ å¤šçº§ç¼“å­˜ï¼šæœ¬åœ°ç¼“å­˜â†’Redisâ†’æ•°æ®åº“ï¼Œä¸‰çº§å­˜å‚¨
ğŸ”¸ é¢„çƒ­æœºåˆ¶ï¼šæå‰åŠ è½½æ•°æ®ï¼Œé¿å…é¦–æ¬¡è®¿é—®æ…¢
ğŸ”¸ å®‰å…¨é˜²æŠ¤ï¼šç¼“å­˜é›ªå´©ã€ç©¿é€ã€å‡»ç©¿çš„é˜²æŠ¤æ–¹æ³•
```

### 8.2 å®æˆ˜åº”ç”¨æŒ‡å—


**ğŸ® æ¸¸æˆåœºæ™¯ç¼“å­˜é€‰æ‹©ï¼š**

| **æ¸¸æˆåœºæ™¯** | **æ¨èç¼“å­˜ç­–ç•¥** | **å…³é”®é…ç½®** |
|-------------|-----------------|-------------|
| `ç©å®¶ç™»å½•` | å¤šçº§ç¼“å­˜ + é¢„çƒ­ | æœ¬åœ°5åˆ†é’Ÿ + Redis30åˆ†é’Ÿ |
| `æ’è¡Œæ¦œ` | Redis ZSet + å®šæ—¶æ›´æ–° | 5åˆ†é’Ÿè¿‡æœŸï¼Œæ‰¹é‡æ›´æ–° |
| `èŠå¤©ç³»ç»Ÿ` | Redis List + æ»‘åŠ¨çª—å£ | ä¿ç•™æœ€è¿‘1000æ¡ |
| `å•†åŸæ•°æ®` | Redis Hash + é•¿TTL | çƒ­é—¨å•†å“1å°æ—¶è¿‡æœŸ |

**âš¡ æ€§èƒ½ä¼˜åŒ–è¦ç‚¹ï¼š**
- **è¯»å¤šå†™å°‘**ï¼šé€‚åˆç¼“å­˜ï¼ŒTTLå¯ä»¥é•¿ä¸€äº›
- **å†™å¤šè¯»å°‘**ï¼šè°¨æ…ä½¿ç”¨ç¼“å­˜ï¼Œæˆ–ç¼©çŸ­TTL
- **çƒ­ç‚¹æ•°æ®**ï¼šä½¿ç”¨å¤šçº§ç¼“å­˜ + é¢„çƒ­
- **å¤§æ•°æ®**ï¼šè€ƒè™‘å‹ç¼©å­˜å‚¨

**ğŸ›¡ï¸ å®‰å…¨ä¿æŠ¤ç­–ç•¥ï¼š**
- **éšæœºTTL**ï¼šé˜²æ­¢ç¼“å­˜é›ªå´©
- **å¸ƒéš†è¿‡æ»¤å™¨**ï¼šé˜²æ­¢ç¼“å­˜ç©¿é€  
- **åˆ†å¸ƒå¼é”**ï¼šé˜²æ­¢ç¼“å­˜å‡»ç©¿
- **ç†”æ–­æœºåˆ¶**ï¼šä¿æŠ¤æ•°æ®åº“

### 8.3 ç›‘æ§ä¸è¿ç»´è¦ç‚¹


```
å…³é”®ç›‘æ§æŒ‡æ ‡ï¼š
â€¢ ç¼“å­˜å‘½ä¸­ç‡ï¼š>90% ä¸ºä¼˜ç§€
â€¢ å“åº”æ—¶é—´ï¼š<10ms ä¸ºä¼˜ç§€  
â€¢ å†…å­˜ä½¿ç”¨ç‡ï¼š<80% ä¸ºå®‰å…¨
â€¢ é”™è¯¯ç‡ï¼š<1% ä¸ºæ­£å¸¸

ä¼˜åŒ–å»ºè®®ï¼š
â€¢ å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
â€¢ æ ¹æ®è®¿é—®æ¨¡å¼è°ƒæ•´TTL
â€¢ ç›‘æ§çƒ­ç‚¹keyï¼Œåˆç†åˆ†å¸ƒ
â€¢ å‹ç¼©å¤§æ•°æ®å¯¹è±¡
```

**ğŸ¯ æ ¸å¿ƒè®°å¿†ï¼š**
- ç¼“å­˜æ˜¯ä¸ºäº†å¿«ï¼Œä½†è¦ä¿è¯æ•°æ®æ­£ç¡®
- å¤šçº§ç¼“å­˜æ¶æ„ï¼Œå±‚å±‚é€’è¿›ä¿æŠ¤
- é¢„çƒ­å’Œæ™ºèƒ½æ·˜æ±°ï¼Œè®©ç¼“å­˜æ›´é«˜æ•ˆ
- ç›‘æ§å’Œé˜²æŠ¤ï¼Œä¿è¯ç³»ç»Ÿç¨³å®šè¿è¡Œ

