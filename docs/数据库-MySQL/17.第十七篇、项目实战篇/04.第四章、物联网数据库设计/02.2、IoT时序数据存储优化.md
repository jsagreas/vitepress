---
title: 2、IoT时序数据存储优化
---
## 📚 目录

1. [时序数据基础概念](#1-时序数据基础概念)
2. [时序数据模型设计](#2-时序数据模型设计)
3. [分区策略设计](#3-分区策略设计)
4. [数据压缩与存储优化](#4-数据压缩与存储优化)
5. [冷热数据分层管理](#5-冷热数据分层管理)
6. [查询性能优化](#6-查询性能优化)
7. [专用时序数据库方案](#7-专用时序数据库方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌟 时序数据基础概念


### 1.1 什么是时序数据


**🔸 基本定义**
时序数据就是**按时间顺序产生的数据**，每条记录都带有时间戳。在物联网场景中，各种传感器持续不断地产生数据。

```
简单理解：
温度传感器每秒上报一次数据：
2024-01-15 10:00:01  温度: 25.6°C
2024-01-15 10:00:02  温度: 25.7°C  
2024-01-15 10:00:03  温度: 25.8°C
...

这就是典型的时序数据
```

### 1.2 IoT时序数据特点


**🔸 数据特征分析**
```
数据量特点：
├── 写入频率高：每秒可能有数万条数据
├── 数据量巨大：单日可达TB级别
├── 写多读少：主要是存储，查询相对较少
└── 时间有序：数据按时间顺序到达

数据模式特点：
├── 结构相对固定：同类设备数据格式一致
├── 数值型为主：温度、湿度、压力等数值
├── 历史不变：已经产生的数据基本不会修改
└── 时效性强：越新的数据越有价值
```

### 1.3 传统数据库的挑战


**⚠️ 为什么传统MySQL不适合**
```
性能问题：
• 写入性能：传统B+树索引写入慢
• 存储空间：每行数据开销大
• 查询效率：时间范围查询不够优化

举例说明：
1000个传感器 × 每秒1条数据 × 86400秒 = 8640万条/天
传统MySQL表结构开销大，存储和查询都会有问题
```

---

## 2. 🏗️ 时序数据模型设计


### 2.1 传统关系模型 vs 时序模型


**📊 设计对比**
```sql
-- ❌ 传统设计（问题较多）
CREATE TABLE sensor_data (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    device_id VARCHAR(50),
    sensor_type VARCHAR(20),
    value DECIMAL(10,2),
    unit VARCHAR(10),
    timestamp DATETIME,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ✅ 时序优化设计
CREATE TABLE sensor_data_timeseries (
    timestamp TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2), 
    pressure DECIMAL(7,2),
    PRIMARY KEY (timestamp, device_id)
) PARTITION BY RANGE (UNIX_TIMESTAMP(timestamp));
```

### 2.2 时序数据建模原则


**🔸 核心设计原则**

**时间戳作为主键**：
```
为什么这样设计？
• 时间戳是天然的排序字段
• 查询时基本都会带时间范围条件
• 有利于分区和索引优化

示例：
PRIMARY KEY (timestamp, device_id)
-- 时间在前，设备ID在后
```

**宽表设计**：
```sql
-- ✅ 推荐：一个设备的多个指标存在一行
CREATE TABLE iot_metrics (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32),
    temperature DECIMAL(5,2),    -- 温度
    humidity DECIMAL(5,2),       -- 湿度  
    pressure DECIMAL(7,2),       -- 压力
    battery_level TINYINT,       -- 电量
    PRIMARY KEY (ts, device_id)
);

-- ❌ 不推荐：每个指标一行（窄表）
CREATE TABLE iot_narrow (
    ts TIMESTAMP,
    device_id VARCHAR(32), 
    metric_name VARCHAR(20),     -- temperature/humidity/pressure
    metric_value DECIMAL(10,2)
);
```

**为什么用宽表？**
- **减少连接查询**：一次查询获取设备所有指标
- **提高写入效率**：一次写入多个指标
- **便于分析**：同一时刻的多个指标容易关联分析

### 2.3 数据类型优化


**🔸 精确选择数据类型**
```sql
-- 针对IoT数据特点优化
CREATE TABLE optimized_iot_data (
    -- 时间戳：毫秒精度足够
    ts TIMESTAMP(3) NOT NULL,
    
    -- 设备ID：固定长度更高效
    device_id CHAR(32) NOT NULL,
    
    -- 温度：-40到100度，1位小数 
    temperature DECIMAL(4,1),
    
    -- 湿度：0-100%，1位小数
    humidity DECIMAL(4,1),
    
    -- 电量：0-100%，整数即可
    battery_level TINYINT UNSIGNED,
    
    PRIMARY KEY (ts, device_id)
);
```

**类型选择说明**：
- `TIMESTAMP(3)`：毫秒精度，比`DATETIME`节省空间
- `CHAR(32)`：固定长度比`VARCHAR`查询更快
- `DECIMAL(4,1)`：精确小数，比`FLOAT`节省空间
- `TINYINT`：1字节存储0-255，适合百分比数据

---

## 3. 📅 分区策略设计


### 3.1 为什么需要分区


**🔸 分区的核心作用**
```
数据量问题：
IoT系统每天产生几千万条数据
如果都放在一个表里，查询会越来越慢

分区解决方案：
按时间将数据分散到多个子表中
查询时只扫描相关分区，大大提升性能
```

### 3.2 时间分区策略


**📈 按日分区（推荐）**
```sql
-- 创建按日分区的表
CREATE TABLE iot_data_daily (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2),
    PRIMARY KEY (ts, device_id)
) PARTITION BY RANGE (TO_DAYS(ts)) (
    PARTITION p20240115 VALUES LESS THAN (TO_DAYS('2024-01-16')),
    PARTITION p20240116 VALUES LESS THAN (TO_DAYS('2024-01-17')),
    PARTITION p20240117 VALUES LESS THAN (TO_DAYS('2024-01-18')),
    -- 可以用脚本自动创建未来分区
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**自动管理分区**：
```sql
-- 创建存储过程，每日自动创建新分区
DELIMITER $$
CREATE PROCEDURE CreateDailyPartition()
BEGIN
    DECLARE partition_name VARCHAR(20);
    DECLARE partition_date DATE;
    
    SET partition_date = DATE_ADD(CURDATE(), INTERVAL 7 DAY);
    SET partition_name = CONCAT('p', DATE_FORMAT(partition_date, '%Y%m%d'));
    
    SET @sql = CONCAT(
        'ALTER TABLE iot_data_daily ADD PARTITION (',
        'PARTITION ', partition_name, 
        ' VALUES LESS THAN (TO_DAYS(''', partition_date, ''')))'
    );
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$
DELIMITER ;
```

### 3.3 复合分区策略


**🔸 时间+设备分区**
```sql
-- 先按时间分区，再按设备子分区
CREATE TABLE iot_data_compound (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2),
    PRIMARY KEY (ts, device_id)
) 
PARTITION BY RANGE (TO_DAYS(ts))
SUBPARTITION BY HASH (CRC32(device_id))
SUBPARTITIONS 4 (
    PARTITION p20240115 VALUES LESS THAN (TO_DAYS('2024-01-16')),
    PARTITION p20240116 VALUES LESS THAN (TO_DAYS('2024-01-17'))
);
```

**适用场景**：
- **单日数据量超过1000万**：需要进一步细分
- **设备数量很多**：按设备散列可以平均分布数据
- **经常按设备查询**：子分区能提升单设备查询性能

---

## 4. 🗜️ 数据压缩与存储优化


### 4.1 数据压缩算法


**🔸 为什么需要压缩**
```
存储成本考虑：
1TB原始数据 → 压缩后200GB → 节省80%存储空间
按年计算，存储成本节省非常可观

IoT数据压缩特点：
• 数据相似性高：相邻时间点数据变化小
• 数值范围有限：温度通常在-40到100度之间
• 重复模式多：同类传感器数据模式相似
```

**行级压缩示例**：
```sql
-- 启用行压缩
CREATE TABLE iot_data_compressed (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL, 
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2)
) ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
```

### 4.2 数据降采样（Downsampling）


**🔸 什么是降采样**
降采样就是**减少数据密度**，比如把每秒一条数据变成每分钟一条数据，通过聚合计算保留关键信息。

**实现方案**：
```sql
-- 原始数据：每秒一条
-- 目标：生成每分钟的汇总数据

-- 创建分钟级汇总表
CREATE TABLE iot_data_1min (
    ts_minute TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    temp_avg DECIMAL(5,2),      -- 平均温度
    temp_min DECIMAL(5,2),      -- 最低温度  
    temp_max DECIMAL(5,2),      -- 最高温度
    humidity_avg DECIMAL(5,2),   -- 平均湿度
    sample_count INT,           -- 样本数量
    PRIMARY KEY (ts_minute, device_id)
);

-- 降采样聚合查询
INSERT INTO iot_data_1min
SELECT 
    DATE_FORMAT(ts, '%Y-%m-%d %H:%i:00') as ts_minute,
    device_id,
    AVG(temperature) as temp_avg,
    MIN(temperature) as temp_min, 
    MAX(temperature) as temp_max,
    AVG(humidity) as humidity_avg,
    COUNT(*) as sample_count
FROM iot_data_raw
WHERE ts >= '2024-01-15 00:00:00' 
  AND ts < '2024-01-15 01:00:00'
GROUP BY DATE_FORMAT(ts, '%Y-%m-%d %H:%i:00'), device_id;
```

### 4.3 多级数据存储


**🔸 分层存储策略**
```
数据分层设计：
├── 原始数据层：保存1-7天，秒级精度
├── 分钟汇总层：保存1-3个月，分钟级精度  
├── 小时汇总层：保存1-2年，小时级精度
└── 天汇总层：永久保存，天级精度

存储空间对比：
原始数据：86400条/天/设备
分钟汇总：1440条/天/设备  (压缩60倍)
小时汇总：24条/天/设备    (压缩3600倍)
天汇总：1条/天/设备      (压缩86400倍)
```

**实现代码**：
```sql
-- 每小时执行的数据汇总任务
CREATE EVENT hourly_aggregation
ON SCHEDULE EVERY 1 HOUR
STARTS CURRENT_TIMESTAMP
DO
BEGIN
    -- 生成上小时的分钟级汇总
    INSERT INTO iot_data_1min 
    SELECT 
        DATE_FORMAT(ts, '%Y-%m-%d %H:%i:00') as ts_minute,
        device_id,
        AVG(temperature), MIN(temperature), MAX(temperature),
        AVG(humidity),
        COUNT(*)
    FROM iot_data_raw
    WHERE ts >= DATE_SUB(NOW(), INTERVAL 2 HOUR)
      AND ts < DATE_SUB(NOW(), INTERVAL 1 HOUR)  
    GROUP BY DATE_FORMAT(ts, '%Y-%m-%d %H:%i:00'), device_id;
    
    -- 删除7天前的原始数据
    DELETE FROM iot_data_raw 
    WHERE ts < DATE_SUB(NOW(), INTERVAL 7 DAY);
END;
```

---

## 5. ❄️🔥 冷热数据分层管理


### 5.1 冷热数据概念


**🔸 数据温度分类**
```
热数据 (Hot Data)：
• 时间范围：最近1-7天
• 访问频率：经常查询和分析
• 存储要求：高性能SSD存储
• 查询延迟：毫秒级响应

温数据 (Warm Data)：
• 时间范围：1周-3个月  
• 访问频率：偶尔查询
• 存储要求：普通SSD或高速机械硬盘
• 查询延迟：秒级响应可接受

冷数据 (Cold Data)：
• 时间范围：3个月以上
• 访问频率：很少查询，主要用于合规和备份
• 存储要求：低成本机械硬盘或对象存储
• 查询延迟：分钟级响应可接受
```

### 5.2 分层存储实现


**📊 MySQL分层架构**
```
存储层次架构：
┌─────────────────┐
│   热数据区域     │ ← MySQL主库，SSD存储，7天数据
├─────────────────┤
│   温数据区域     │ ← MySQL从库，SATA SSD，3个月数据  
├─────────────────┤
│   冷数据区域     │ ← 归档库，机械硬盘，历史数据
└─────────────────┘
```

**实现方案**：
```sql
-- 热数据表（高频访问）
CREATE TABLE iot_data_hot (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2),
    PRIMARY KEY (ts, device_id)
) ENGINE=InnoDB;

-- 冷数据表（归档存储）  
CREATE TABLE iot_data_cold (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL,
    temperature DECIMAL(5,2), 
    humidity DECIMAL(5,2),
    PRIMARY KEY (ts, device_id)
) ENGINE=MyISAM  -- MyISAM压缩比更高
  ROW_FORMAT=COMPRESSED;
```

### 5.3 自动数据迁移


**🔸 冷热数据自动迁移**
```sql
-- 每日执行的数据迁移任务
DELIMITER $$
CREATE PROCEDURE MoveDataToCold()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE migrate_date DATE;
    
    -- 计算需要迁移的日期（7天前）
    SET migrate_date = DATE_SUB(CURDATE(), INTERVAL 7 DAY);
    
    -- 将热数据迁移到冷存储
    INSERT INTO iot_data_cold
    SELECT * FROM iot_data_hot  
    WHERE DATE(ts) = migrate_date;
    
    -- 删除已迁移的热数据
    DELETE FROM iot_data_hot
    WHERE DATE(ts) = migrate_date;
    
    -- 记录迁移日志
    INSERT INTO migration_log (migrate_date, record_count)
    SELECT migrate_date, ROW_COUNT();
END$$
DELIMITER ;

-- 创建定时任务
CREATE EVENT daily_migration
ON SCHEDULE EVERY 1 DAY  
STARTS '2024-01-01 02:00:00'
DO CALL MoveDataToCold();
```

---

## 6. ⚡ 查询性能优化


### 6.1 时序查询特点


**🔸 IoT查询模式分析**
```
常见查询类型：
• 时间范围查询：最近24小时的温度数据
• 设备状态查询：某个设备的最新数据
• 聚合分析查询：每小时平均温度
• 异常数据查询：温度超过阈值的记录

查询特点：
• 90%以上的查询都带时间条件
• 经常需要按设备分组
• 聚合查询比明细查询多
• 查询时间窗口相对固定
```

### 6.2 时序索引优化


**📊 索引设计策略**
```sql
-- ✅ 时序数据专用索引
CREATE TABLE iot_data_optimized (
    ts TIMESTAMP NOT NULL,
    device_id VARCHAR(32) NOT NULL, 
    temperature DECIMAL(5,2),
    humidity DECIMAL(5,2),
    
    -- 主键：时间+设备
    PRIMARY KEY (ts, device_id),
    
    -- 设备+时间索引（用于单设备查询）
    INDEX idx_device_time (device_id, ts),
    
    -- 温度范围索引（用于异常检测）
    INDEX idx_temp_range (temperature, ts)
);
```

**索引使用说明**：
```sql
-- ✅ 利用主键索引的查询
SELECT * FROM iot_data_optimized
WHERE ts BETWEEN '2024-01-15 10:00:00' AND '2024-01-15 11:00:00';

-- ✅ 利用设备索引的查询  
SELECT * FROM iot_data_optimized  
WHERE device_id = 'sensor_001'
  AND ts >= '2024-01-15 00:00:00';

-- ✅ 利用温度索引的查询
SELECT device_id, ts, temperature FROM iot_data_optimized
WHERE temperature > 35.0 
  AND ts >= '2024-01-15 00:00:00';
```

### 6.3 时间窗口查询优化


**🔸 窗口查询实现**
```sql
-- 滑动窗口平均值计算
SELECT 
    device_id,
    ts,
    temperature,
    -- 计算5分钟滑动平均
    AVG(temperature) OVER (
        PARTITION BY device_id 
        ORDER BY ts 
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) as temp_5min_avg
FROM iot_data_optimized
WHERE ts BETWEEN '2024-01-15 10:00:00' AND '2024-01-15 11:00:00'
ORDER BY device_id, ts;
```

**时间分组聚合**：
```sql
-- 按小时分组的高效聚合
SELECT 
    DATE_FORMAT(ts, '%Y-%m-%d %H:00:00') as hour_time,
    device_id,
    AVG(temperature) as avg_temp,
    MIN(temperature) as min_temp,
    MAX(temperature) as max_temp,
    COUNT(*) as sample_count
FROM iot_data_optimized
WHERE ts BETWEEN '2024-01-15 00:00:00' AND '2024-01-16 00:00:00'
GROUP BY DATE_FORMAT(ts, '%Y-%m-%d %H:00:00'), device_id
ORDER BY hour_time, device_id;
```

---

## 7. 🏢 专用时序数据库方案


### 7.1 InfluxDB时序数据库


**🔸 为什么选择专用时序数据库**
```
MySQL的限制：
• 写入性能：B+树索引写入较慢
• 存储效率：行存储对时序数据不够紧凑
• 查询优化：缺少时序专用的查询优化

InfluxDB的优势：
• 列存储：相同字段数据连续存储，压缩效果好
• 时序索引：专门针对时间序列优化的索引结构  
• 内置函数：丰富的时序分析函数
• 自动压缩：自动进行数据压缩和降采样
```

**基本概念对比**：
```
MySQL概念        InfluxDB概念        说明
数据库           Database           顶层容器
表              Measurement        类似表的概念
行              Point              一条时序数据记录
主键            Time + Tags        时间戳+标签组合
字段            Fields             存储数值的字段
索引            Tags               用于索引的标签字段
```

### 7.2 InfluxDB数据模型


**🔸 时序数据结构设计**
```sql
-- InfluxDB数据写入示例（Line Protocol格式）
-- measurement,tag1=value1,tag2=value2 field1=value1,field2=value2 timestamp

-- 写入温湿度数据
temperature,device=sensor_001,location=room_a value=25.6 1642248001000000000
humidity,device=sensor_001,location=room_a value=65.2 1642248001000000000

-- 对应的查询
SELECT mean(value) FROM temperature 
WHERE device='sensor_001' 
  AND time >= now() - 1h 
GROUP BY time(5m);
```

**数据结构设计原则**：
```
Tags（标签）：用于索引和分组
• device_id: 设备标识
• sensor_type: 传感器类型  
• location: 位置信息
特点：字符串类型，会建立索引，用于WHERE和GROUP BY

Fields（字段）：实际的数值数据
• temperature: 温度值
• humidity: 湿度值
• battery_level: 电量
特点：数值类型，不建索引，用于聚合计算
```

### 7.3 混合架构方案


**🔸 MySQL + InfluxDB混合方案**
```
架构设计：
┌─────────────────┐    ┌─────────────────┐
│   MySQL数据库    │    │  InfluxDB数据库  │
│                │    │                │  
│ • 设备管理信息   │←──→│ • 时序数据存储   │
│ • 用户权限管理   │    │ • 实时数据分析   │
│ • 告警规则配置   │    │ • 历史数据查询   │
└─────────────────┘    └─────────────────┘
```

**数据流转方案**：
```java
// Java代码示例：混合存储
@Service
public class IoTDataService {
    
    @Autowired
    private InfluxDBTemplate influxDB;
    
    @Autowired  
    private DeviceMapper deviceMapper;
    
    // 写入时序数据
    public void saveTimeSeriesData(IoTDataPoint data) {
        // 1. 写入InfluxDB（时序数据）
        Point point = Point.measurement("sensor_data")
                .time(data.getTimestamp(), TimeUnit.MILLISECONDS)
                .tag("device_id", data.getDeviceId()) 
                .tag("sensor_type", data.getSensorType())
                .field("value", data.getValue())
                .build();
        
        influxDB.write(point);
        
        // 2. 更新MySQL（设备最新状态）
        deviceMapper.updateLastSeen(data.getDeviceId(), data.getTimestamp());
    }
    
    // 查询历史数据
    public List<IoTDataPoint> getHistoryData(String deviceId, 
                                           Date startTime, Date endTime) {
        String query = String.format(
            "SELECT * FROM sensor_data WHERE device_id='%s' " +
            "AND time >= '%s' AND time <= '%s'",
            deviceId, startTime.toInstant(), endTime.toInstant()
        );
        
        return influxDB.query(new Query(query));
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 时序数据本质：按时间顺序产生，写多读少，数据量巨大
🔸 存储挑战：传统数据库在大规模时序数据面前性能不足
🔸 优化策略：分区、压缩、降采样、冷热分离四大核心技术
🔸 专业方案：InfluxDB等专用时序数据库更适合大规模场景
```

### 8.2 关键优化技术


**🔹 分区策略**
```
时间分区：按日/周/月分区，提升查询性能
复合分区：时间+设备双重分区，进一步优化
自动管理：脚本自动创建和删除分区，减少运维成本
```

**🔹 数据压缩**  
```
行级压缩：MySQL行压缩，节省存储空间
降采样：秒级→分钟级→小时级，多层数据汇总
智能压缩：根据数据特点选择最佳压缩算法
```

**🔹 冷热分离**
```
分层存储：热数据SSD、冷数据机械硬盘
自动迁移：定时任务自动将老数据迁移到冷存储
成本优化：根据访问频率选择存储介质，节省成本
```

### 8.3 实际应用建议


**数据量级别选择**：
- **< 百万条/天**：MySQL基础优化即可
- **百万-千万条/天**：MySQL + 分区 + 压缩
- **> 千万条/天**：考虑InfluxDB等专用时序数据库

**查询模式优化**：
- **实时查询**：热数据区，毫秒级响应
- **分析查询**：预聚合数据，降低计算成本  
- **历史查询**：冷数据区，可接受较长响应时间

**存储成本控制**：
- **原始数据**：保留7-30天
- **分钟汇总**：保留3-6个月
- **小时汇总**：保留1-2年
- **天汇总**：永久保存

### 8.4 技术选型指导


**MySQL适用场景**：
- ✅ 中小规模IoT系统（<1000设备）
- ✅ 对事务一致性要求高
- ✅ 需要复杂的关联查询
- ✅ 团队MySQL技能成熟

**InfluxDB适用场景**：  
- ✅ 大规模IoT系统（>1000设备）
- ✅ 纯时序数据分析
- ✅ 对写入性能要求极高
- ✅ 需要复杂时序分析功能

**核心记忆要点**：
- IoT时序数据的核心挑战是**大数据量**和**高写入频率**
- 解决方案的核心是**分而治之**：分区分层，降采样压缩
- 技术选择要**因地制宜**：根据数据规模和业务需求选择合适方案
- 成本控制要**冷热分明**：新数据高性能，老数据低成本