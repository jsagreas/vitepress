---
title: 7ã€å®æ—¶é€šä¿¡
---
## ğŸ“š ç›®å½•

1. [å®æ—¶é€šä¿¡åŸºç¡€æ¦‚å¿µ](#1-å®æ—¶é€šä¿¡åŸºç¡€æ¦‚å¿µ)
2. [WebSocketè¿æ¥ç®¡ç†](#2-WebSocketè¿æ¥ç®¡ç†)
3. [æ¶ˆæ¯å®æ—¶æ¨é€æœºåˆ¶](#3-æ¶ˆæ¯å®æ—¶æ¨é€æœºåˆ¶)
4. [åœ¨çº¿çŠ¶æ€åŒæ­¥](#4-åœ¨çº¿çŠ¶æ€åŒæ­¥)
5. [æ¶ˆæ¯å¯é ä¼ è¾“](#5-æ¶ˆæ¯å¯é ä¼ è¾“)
6. [é•¿è¿æ¥è´Ÿè½½å‡è¡¡](#6-é•¿è¿æ¥è´Ÿè½½å‡è¡¡)
7. [æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ](#7-æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ)
8. [IMç³»ç»Ÿæ¶æ„è®¾è®¡](#8-IMç³»ç»Ÿæ¶æ„è®¾è®¡)
9. [æ¶ˆæ¯è·¯ç”±ä¸åºåˆ—ä¿è¯](#9-æ¶ˆæ¯è·¯ç”±ä¸åºåˆ—ä¿è¯)
10. [å¤šåª’ä½“å®æ—¶é€šä¿¡](#10-å¤šåª’ä½“å®æ—¶é€šä¿¡)
11. [å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–](#11-å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–)
12. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#12-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ’¬ å®æ—¶é€šä¿¡åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯å®æ—¶é€šä¿¡


**æ ¸å¿ƒå®šä¹‰**ï¼šå®æ—¶é€šä¿¡æ˜¯æŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªç”¨æˆ·ä¹‹é—´èƒ½å¤Ÿç«‹å³äº¤æ¢ä¿¡æ¯çš„é€šä¿¡æ–¹å¼ï¼Œå¼ºè°ƒæ¶ˆæ¯çš„å³æ—¶æ€§å’ŒåŒå‘æ€§ã€‚

```
ä¼ ç»ŸHTTPé€šä¿¡ï¼š
å®¢æˆ·ç«¯ â”€â”€è¯·æ±‚â”€â”€> æœåŠ¡å™¨
å®¢æˆ·ç«¯ <â”€â”€å“åº”â”€â”€ æœåŠ¡å™¨
ç‰¹ç‚¹ï¼šå•å‘ã€è¢«åŠ¨ã€å»¶è¿Ÿé«˜

å®æ—¶é€šä¿¡ï¼š
å®¢æˆ·ç«¯ <â•â•åŒå‘è¿æ¥â•â•> æœåŠ¡å™¨
ç‰¹ç‚¹ï¼šåŒå‘ã€ä¸»åŠ¨æ¨é€ã€å»¶è¿Ÿä½
```

### 1.2 å®æ—¶é€šä¿¡çš„æ ¸å¿ƒç‰¹å¾


**ğŸ”¸ å³æ—¶æ€§**
- æ¶ˆæ¯å‘é€åç«‹å³åˆ°è¾¾æ¥æ”¶æ–¹
- ç«¯åˆ°ç«¯å»¶è¿Ÿé€šå¸¸åœ¨100msä»¥å†…
- æ”¯æŒå®æ—¶äº¤äº’ä½“éªŒ

**ğŸ”¸ åŒå‘æ€§**
- æœåŠ¡å™¨å¯ä¸»åŠ¨å‘å®¢æˆ·ç«¯æ¨é€æ¶ˆæ¯
- å®¢æˆ·ç«¯ä¹Ÿå¯éšæ—¶å‘é€æ¶ˆæ¯ç»™æœåŠ¡å™¨
- æ‰“ç ´äº†HTTPçš„è¯·æ±‚-å“åº”æ¨¡å¼

**ğŸ”¸ æŒç»­è¿æ¥**
- å»ºç«‹é•¿ä¹…çš„ç½‘ç»œè¿æ¥
- é¿å…é¢‘ç¹çš„è¿æ¥å»ºç«‹å’Œæ–­å¼€
- å‡å°‘ç½‘ç»œå¼€é”€å’Œå»¶è¿Ÿ

### 1.3 å®æ—¶é€šä¿¡çš„åº”ç”¨åœºæ™¯


```
ğŸ“± ç¤¾äº¤èŠå¤©ï¼šå¾®ä¿¡ã€QQã€é’‰é’‰
ğŸ® åœ¨çº¿æ¸¸æˆï¼šå®æ—¶å¯¹æˆ˜ã€çŠ¶æ€åŒæ­¥
ğŸ“ˆ é‡‘èäº¤æ˜“ï¼šè‚¡ä»·æ¨é€ã€äº¤æ˜“ç¡®è®¤
ğŸ¥ åŒ»ç–—ç›‘æ§ï¼šæ‚£è€…çŠ¶æ€å®æ—¶ç›‘æ§
ğŸš— ç‰©è”ç½‘ï¼šè®¾å¤‡çŠ¶æ€å®æ—¶ä¸ŠæŠ¥
ğŸ“º ç›´æ’­äº’åŠ¨ï¼šå¼¹å¹•ã€ç¤¼ç‰©ã€è¿éº¦
```

---

## 2. ğŸ”Œ WebSocketè¿æ¥ç®¡ç†


### 2.1 WebSocketåŸºç¡€åŸç†


**WebSocket**æ˜¯ä¸€ç§åœ¨TCPè¿æ¥ä¸Šè¿›è¡Œå…¨åŒå·¥é€šä¿¡çš„åè®®ï¼Œå®ƒè§£å†³äº†HTTPåè®®æ— æ³•ä¸»åŠ¨æ¨é€çš„é—®é¢˜ã€‚

```
WebSocketæ¡æ‰‹è¿‡ç¨‹ï¼š
å®¢æˆ·ç«¯                     æœåŠ¡å™¨
   |                        |
   |â”€â”€HTTP Upgradeè¯·æ±‚â”€â”€â”€â”€>|
   |   Connection: Upgrade   |
   |   Upgrade: websocket   |
   |                        |
   |<â”€â”€HTTP 101å“åº”â”€â”€â”€â”€â”€â”€â”€â”€|
   |   åˆ‡æ¢åˆ°WebSocketåè®®   |
   |                        |
   |<â•â•WebSocketé€šä¿¡â•â•â•â•â•â•>|
```

### 2.2 è¿æ¥å»ºç«‹ä¸ç»´æŠ¤


**ğŸ”§ è¿æ¥å»ºç«‹ä»£ç ç¤ºä¾‹**ï¼š
```javascript
// å®¢æˆ·ç«¯è¿æ¥å»ºç«‹
const socket = new WebSocket('ws://localhost:8080/chat');

socket.onopen = function(event) {
    console.log('WebSocketè¿æ¥å·²å»ºç«‹');
    // å‘é€è®¤è¯ä¿¡æ¯
    socket.send(JSON.stringify({
        type: 'auth',
        token: localStorage.getItem('userToken')
    }));
};

socket.onmessage = function(event) {
    const message = JSON.parse(event.data);
    handleMessage(message);
};

socket.onerror = function(error) {
    console.error('WebSocketé”™è¯¯:', error);
    // é‡è¿æœºåˆ¶
    setTimeout(reconnect, 3000);
};
```

**ğŸ”§ æœåŠ¡ç«¯è¿æ¥ç®¡ç†**ï¼š
```java
@Component
public class WebSocketManager {
    // å­˜å‚¨æ´»è·ƒè¿æ¥
    private Map<String, WebSocketSession> connections = new ConcurrentHashMap<>();
    
    public void addConnection(String userId, WebSocketSession session) {
        connections.put(userId, session);
        updateUserOnlineStatus(userId, true);
    }
    
    public void removeConnection(String userId) {
        connections.remove(userId);
        updateUserOnlineStatus(userId, false);
    }
    
    // å‘æŒ‡å®šç”¨æˆ·å‘é€æ¶ˆæ¯
    public void sendToUser(String userId, Object message) {
        WebSocketSession session = connections.get(userId);
        if (session != null && session.isOpen()) {
            try {
                session.sendMessage(new TextMessage(JSON.toJSONString(message)));
            } catch (IOException e) {
                removeConnection(userId);
            }
        }
    }
}
```

### 2.3 è¿æ¥ä¿æ´»æœºåˆ¶


**å¿ƒè·³æ£€æµ‹**æ˜¯ç¡®ä¿è¿æ¥æœ‰æ•ˆæ€§çš„é‡è¦æœºåˆ¶ï¼š

```
å¿ƒè·³æœºåˆ¶æµç¨‹ï¼š
å®¢æˆ·ç«¯                     æœåŠ¡å™¨
   |                        |
   |â”€â”€pingâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>|
   |                        |
   |<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€pongâ”€â”€|
   |                        |
   |    (30ç§’åé‡å¤)        |

å¦‚æœè¿ç»­3æ¬¡å¿ƒè·³å¤±è´¥ï¼Œåˆ™è®¤ä¸ºè¿æ¥æ–­å¼€
```

**ğŸ”§ å¿ƒè·³å®ç°ç¤ºä¾‹**ï¼š
```javascript
// å®¢æˆ·ç«¯å¿ƒè·³
function startHeartbeat() {
    setInterval(() => {
        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'ping' }));
        }
    }, 30000);
}

// å¤„ç†å¿ƒè·³å“åº”
socket.onmessage = function(event) {
    const data = JSON.parse(event.data);
    if (data.type === 'pong') {
        lastHeartbeat = Date.now();
    }
};
```

---

## 3. ğŸ“¨ æ¶ˆæ¯å®æ—¶æ¨é€æœºåˆ¶


### 3.1 æ¨é€æ¨¡å‹è®¾è®¡


å®æ—¶æ¨é€é‡‡ç”¨**å‘å¸ƒ-è®¢é˜…æ¨¡å¼**ï¼Œå®ç°æ¶ˆæ¯çš„é«˜æ•ˆåˆ†å‘ï¼š

```
æ¨é€æ¶æ„å›¾ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”¨æˆ·A   â”‚    â”‚   æ¨é€æœåŠ¡   â”‚    â”‚ ç”¨æˆ·B   â”‚
â”‚         â”‚â”€â”€â”€>â”‚             â”‚â”€â”€â”€>â”‚         â”‚
â”‚ å‘é€æ¶ˆæ¯ â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ æ¥æ”¶æ¶ˆæ¯ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”‚æ¶ˆæ¯é˜Ÿåˆ—â”‚ â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
               â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
               â”‚ â”‚è·¯ç”±è§„åˆ™â”‚ â”‚
               â””â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”˜
                 â”‚         â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ ç”¨æˆ·C   â”‚ â”‚ ç”¨æˆ·D   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ¶ˆæ¯ç±»å‹ä¸æ ¼å¼


**ğŸ”¸ ç»Ÿä¸€æ¶ˆæ¯æ ¼å¼**ï¼š
```json
{
  "id": "msg_123456789",
  "type": "text|image|file|system",
  "from": "user_001",
  "to": "user_002|group_001",
  "content": "æ¶ˆæ¯å†…å®¹",
  "timestamp": 1642147200000,
  "extra": {
    "replyTo": "msg_123456788",
    "mentions": ["user_003"]
  }
}
```

**ğŸ”§ æ¶ˆæ¯æ¨é€å®ç°**ï¼š
```java
@Service
public class MessagePushService {
    
    @Autowired
    private WebSocketManager webSocketManager;
    
    @Autowired
    private MessageQueue messageQueue;
    
    // å•èŠæ¶ˆæ¯æ¨é€
    public void pushPrivateMessage(String fromUser, String toUser, String content) {
        Message message = Message.builder()
            .id(generateMessageId())
            .type("text")
            .from(fromUser)
            .to(toUser)
            .content(content)
            .timestamp(System.currentTimeMillis())
            .build();
        
        // å­˜å‚¨æ¶ˆæ¯
        messageRepository.save(message);
        
        // å®æ—¶æ¨é€ç»™æ¥æ”¶æ–¹
        webSocketManager.sendToUser(toUser, message);
        
        // å¦‚æœæ¥æ”¶æ–¹ä¸åœ¨çº¿ï¼ŒåŠ å…¥æ¶ˆæ¯é˜Ÿåˆ—ç­‰å¾…
        if (!webSocketManager.isUserOnline(toUser)) {
            messageQueue.addPendingMessage(toUser, message);
        }
    }
    
    // ç¾¤èŠæ¶ˆæ¯æ¨é€
    public void pushGroupMessage(String fromUser, String groupId, String content) {
        List<String> members = groupService.getGroupMembers(groupId);
        
        Message message = Message.builder()
            .id(generateMessageId())
            .type("text")
            .from(fromUser)
            .to(groupId)
            .content(content)
            .timestamp(System.currentTimeMillis())
            .build();
        
        messageRepository.save(message);
        
        // æ¨é€ç»™æ‰€æœ‰åœ¨çº¿æˆå‘˜ï¼ˆé™¤å‘é€è€…å¤–ï¼‰
        members.stream()
            .filter(member -> !member.equals(fromUser))
            .forEach(member -> {
                if (webSocketManager.isUserOnline(member)) {
                    webSocketManager.sendToUser(member, message);
                } else {
                    messageQueue.addPendingMessage(member, message);
                }
            });
    }
}
```

### 3.3 æ¶ˆæ¯æ¨é€ä¼˜åŒ–ç­–ç•¥


**ğŸ”¸ æ‰¹é‡æ¨é€**ï¼š
```java
// é¿å…å•ä¸ªæ¶ˆæ¯å•ç‹¬æ¨é€ï¼Œé‡‡ç”¨æ‰¹é‡å¤„ç†
public void batchPushMessages() {
    List<PendingMessage> batch = messageQueue.getBatch(100);
    
    // æŒ‰ç”¨æˆ·åˆ†ç»„
    Map<String, List<Message>> userMessages = batch.stream()
        .collect(Collectors.groupingBy(
            PendingMessage::getUserId,
            Collectors.mapping(PendingMessage::getMessage, Collectors.toList())
        ));
    
    // æ‰¹é‡æ¨é€
    userMessages.forEach((userId, messages) -> {
        if (webSocketManager.isUserOnline(userId)) {
            webSocketManager.sendBatchToUser(userId, messages);
        }
    });
}
```

---

## 4. ğŸ‘¥ åœ¨çº¿çŠ¶æ€åŒæ­¥


### 4.1 åœ¨çº¿çŠ¶æ€ç®¡ç†


**åœ¨çº¿çŠ¶æ€**æ˜¯å®æ—¶é€šä¿¡ç³»ç»Ÿçš„é‡è¦åŠŸèƒ½ï¼Œç”¨æˆ·éœ€è¦çŸ¥é“è”ç³»äººçš„åœ¨çº¿æƒ…å†µã€‚

```
ç”¨æˆ·çŠ¶æ€ç±»å‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åœ¨çº¿ (Online)â”‚ â† æ´»è·ƒä½¿ç”¨ä¸­
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç¦»å¼€ (Away)  â”‚ â† ä¸€æ®µæ—¶é—´æ— æ“ä½œ
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¿™ç¢Œ (Busy)  â”‚ â† æ‰‹åŠ¨è®¾ç½®å¿™ç¢ŒçŠ¶æ€
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç¦»çº¿ (Offline)â”‚ â† æ–­å¼€è¿æ¥
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”§ çŠ¶æ€ç®¡ç†å®ç°**ï¼š
```java
@Component
public class UserStatusManager {
    
    // ç”¨æˆ·çŠ¶æ€ç¼“å­˜ (Redis)
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String USER_STATUS_KEY = "user_status:";
    private static final int STATUS_EXPIRE_SECONDS = 300; // 5åˆ†é’Ÿè¿‡æœŸ
    
    // æ›´æ–°ç”¨æˆ·åœ¨çº¿çŠ¶æ€
    public void updateUserStatus(String userId, UserStatus status) {
        String key = USER_STATUS_KEY + userId;
        
        UserStatusInfo statusInfo = UserStatusInfo.builder()
            .userId(userId)
            .status(status)
            .lastActiveTime(System.currentTimeMillis())
            .build();
        
        redisTemplate.opsForValue().set(key, JSON.toJSONString(statusInfo), 
                                      STATUS_EXPIRE_SECONDS, TimeUnit.SECONDS);
        
        // é€šçŸ¥å¥½å‹çŠ¶æ€å˜åŒ–
        notifyContactsStatusChange(userId, status);
    }
    
    // æ‰¹é‡è·å–å¥½å‹åœ¨çº¿çŠ¶æ€
    public Map<String, UserStatus> getFriendsStatus(String userId) {
        List<String> friendIds = friendService.getFriendIds(userId);
        
        List<String> keys = friendIds.stream()
            .map(id -> USER_STATUS_KEY + id)
            .collect(Collectors.toList());
        
        List<String> values = redisTemplate.opsForValue().multiGet(keys);
        
        Map<String, UserStatus> statusMap = new HashMap<>();
        for (int i = 0; i < friendIds.size(); i++) {
            String value = values.get(i);
            if (value != null) {
                UserStatusInfo info = JSON.parseObject(value, UserStatusInfo.class);
                statusMap.put(friendIds.get(i), info.getStatus());
            } else {
                statusMap.put(friendIds.get(i), UserStatus.OFFLINE);
            }
        }
        
        return statusMap;
    }
}
```

### 4.2 çŠ¶æ€å˜åŒ–é€šçŸ¥


**ğŸ”§ çŠ¶æ€åŒæ­¥æœºåˆ¶**ï¼š
```java
// é€šçŸ¥å¥½å‹çŠ¶æ€å˜åŒ–
private void notifyContactsStatusChange(String userId, UserStatus newStatus) {
    List<String> contacts = friendService.getFriendIds(userId);
    
    StatusChangeNotification notification = StatusChangeNotification.builder()
        .userId(userId)
        .newStatus(newStatus)
        .timestamp(System.currentTimeMillis())
        .build();
    
    // åªé€šçŸ¥åœ¨çº¿çš„å¥½å‹
    contacts.stream()
        .filter(webSocketManager::isUserOnline)
        .forEach(contactId -> 
            webSocketManager.sendToUser(contactId, notification)
        );
}
```

### 4.3 è‡ªåŠ¨çŠ¶æ€æ£€æµ‹


**ğŸ”¸ æ´»è·ƒåº¦æ£€æµ‹**ï¼š
```javascript
// å®¢æˆ·ç«¯æ´»è·ƒåº¦æ£€æµ‹
let lastActivityTime = Date.now();
let statusCheckInterval;

// ç›‘å¬ç”¨æˆ·æ´»åŠ¨
['click', 'keypress', 'mousemove', 'scroll'].forEach(event => {
    document.addEventListener(event, () => {
        lastActivityTime = Date.now();
        
        // å¦‚æœå½“å‰æ˜¯AwayçŠ¶æ€ï¼Œè‡ªåŠ¨åˆ‡æ¢ä¸ºOnline
        if (currentStatus === 'away') {
            updateStatus('online');
        }
    });
});

// å®šæ—¶æ£€æŸ¥çŠ¶æ€
function startStatusCheck() {
    statusCheckInterval = setInterval(() => {
        const inactiveTime = Date.now() - lastActivityTime;
        
        // 5åˆ†é’Ÿæ— æ´»åŠ¨è‡ªåŠ¨è®¾ä¸ºAway
        if (inactiveTime > 5 * 60 * 1000 && currentStatus === 'online') {
            updateStatus('away');
        }
    }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
}
```

---

## 5. ğŸ›¡ï¸ æ¶ˆæ¯å¯é ä¼ è¾“


### 5.1 æ¶ˆæ¯ç¡®è®¤æœºåˆ¶


ä¸ºç¡®ä¿æ¶ˆæ¯å¯é ä¼ è¾“ï¼Œéœ€è¦å®ç°**æ¶ˆæ¯ç¡®è®¤æœºåˆ¶**ï¼š

```
æ¶ˆæ¯ç¡®è®¤æµç¨‹ï¼š
å‘é€æ–¹                     æ¥æ”¶æ–¹
   |                        |
   |â”€â”€æ¶ˆæ¯(msg_id:123)â”€â”€â”€â”€>|
   |                        |
   |<â”€â”€â”€ç¡®è®¤(msg_id:123)â”€â”€|
   |                        |
   
å¦‚æœåœ¨è¶…æ—¶æ—¶é—´å†…æœªæ”¶åˆ°ç¡®è®¤ï¼Œåˆ™é‡å‘æ¶ˆæ¯
```

**ğŸ”§ ç¡®è®¤æœºåˆ¶å®ç°**ï¼š
```java
@Component
public class ReliableMessageService {
    
    // æœªç¡®è®¤æ¶ˆæ¯ç¼“å­˜
    private Map<String, PendingMessage> pendingMessages = new ConcurrentHashMap<>();
    private ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(5);
    
    public void sendReliableMessage(String toUser, Message message) {
        // æ·»åŠ åˆ°å¾…ç¡®è®¤åˆ—è¡¨
        PendingMessage pending = new PendingMessage(message, System.currentTimeMillis());
        pendingMessages.put(message.getId(), pending);
        
        // å‘é€æ¶ˆæ¯
        webSocketManager.sendToUser(toUser, message);
        
        // è®¾ç½®é‡å‘å®šæ—¶å™¨
        scheduleRetry(message.getId(), toUser, 3000); // 3ç§’åé‡è¯•
    }
    
    public void handleMessageAck(String messageId) {
        pendingMessages.remove(messageId);
    }
    
    private void scheduleRetry(String messageId, String toUser, long delayMs) {
        retryExecutor.schedule(() -> {
            PendingMessage pending = pendingMessages.get(messageId);
            if (pending != null && pending.getRetryCount() < 3) {
                pending.incrementRetry();
                webSocketManager.sendToUser(toUser, pending.getMessage());
                scheduleRetry(messageId, toUser, delayMs * 2); // æŒ‡æ•°é€€é¿
            } else {
                // é‡è¯•å¤±è´¥ï¼Œæ ‡è®°ä¸ºå¤±è´¥
                pendingMessages.remove(messageId);
                handleMessageDeliveryFailed(messageId);
            }
        }, delayMs, TimeUnit.MILLISECONDS);
    }
}
```

### 5.2 æ¶ˆæ¯æŒä¹…åŒ–å­˜å‚¨


**ğŸ”¸ æ¶ˆæ¯å­˜å‚¨ç­–ç•¥**ï¼š
```sql
-- æ¶ˆæ¯è¡¨è®¾è®¡
CREATE TABLE messages (
    id VARCHAR(64) PRIMARY KEY,
    type VARCHAR(20) NOT NULL,
    from_user VARCHAR(64) NOT NULL,
    to_user VARCHAR(64),
    group_id VARCHAR(64),
    content TEXT NOT NULL,
    timestamp BIGINT NOT NULL,
    status TINYINT DEFAULT 0,  -- 0:å‘é€ä¸­ 1:å·²é€è¾¾ 2:å·²è¯»
    extra JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_from_user_time (from_user, timestamp),
    INDEX idx_to_user_time (to_user, timestamp),
    INDEX idx_group_time (group_id, timestamp)
);

-- æ¶ˆæ¯çŠ¶æ€è¡¨
CREATE TABLE message_status (
    message_id VARCHAR(64),
    user_id VARCHAR(64),
    status TINYINT,  -- 1:å·²é€è¾¾ 2:å·²è¯»
    timestamp BIGINT,
    PRIMARY KEY (message_id, user_id)
);
```

### 5.3 ç¦»çº¿æ¶ˆæ¯å¤„ç†


**ğŸ”§ ç¦»çº¿æ¶ˆæ¯æ¨é€**ï¼š
```java
@Service
public class OfflineMessageService {
    
    public void handleUserOnline(String userId) {
        // ç”¨æˆ·ä¸Šçº¿æ—¶æ¨é€ç¦»çº¿æ¶ˆæ¯
        List<Message> offlineMessages = getOfflineMessages(userId);
        
        if (!offlineMessages.isEmpty()) {
            // æŒ‰æ—¶é—´é¡ºåºæ¨é€
            offlineMessages.sort(Comparator.comparing(Message::getTimestamp));
            
            for (Message message : offlineMessages) {
                webSocketManager.sendToUser(userId, message);
                // æ ‡è®°ä¸ºå·²é€è¾¾
                updateMessageStatus(message.getId(), userId, MessageStatus.DELIVERED);
            }
            
            // æ¸…é™¤ç¦»çº¿æ¶ˆæ¯
            clearOfflineMessages(userId);
        }
    }
    
    private List<Message> getOfflineMessages(String userId) {
        return messageRepository.findPendingMessages(userId);
    }
}
```

---

## 6. âš–ï¸ é•¿è¿æ¥è´Ÿè½½å‡è¡¡


### 6.1 è´Ÿè½½å‡è¡¡æŒ‘æˆ˜


é•¿è¿æ¥çš„è´Ÿè½½å‡è¡¡æ¯”HTTPè¯·æ±‚æ›´å¤æ‚ï¼Œå› ä¸ºè¿æ¥å…·æœ‰**çŠ¶æ€æ€§**å’Œ**æŒç»­æ€§**ï¼š

```
æŒ‘æˆ˜åˆ†æï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HTTPçŸ­è¿æ¥è´Ÿè½½å‡è¡¡   â”‚
â”‚                     â”‚
â”‚ è¯·æ±‚ â†’ ä»»æ„æœåŠ¡å™¨    â”‚
â”‚ æ— çŠ¶æ€ï¼Œæ˜“äºåˆ†å‘     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ WebSocketé•¿è¿æ¥è´Ÿè½½  â”‚
â”‚                     â”‚
â”‚ è¿æ¥ â†’ å›ºå®šæœåŠ¡å™¨    â”‚
â”‚ æœ‰çŠ¶æ€ï¼Œéš¾ä»¥è¿ç§»     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 è´Ÿè½½å‡è¡¡ç­–ç•¥


**ğŸ”¸ ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•**ï¼š
```java
@Component
public class ConsistentHashLoadBalancer {
    
    private TreeMap<Integer, String> serverRing = new TreeMap<>();
    private List<String> servers;
    
    public void addServer(String server) {
        for (int i = 0; i < 100; i++) { // è™šæ‹ŸèŠ‚ç‚¹
            int hash = hash(server + "_" + i);
            serverRing.put(hash, server);
        }
    }
    
    public String getServer(String userId) {
        int userHash = hash(userId);
        Map.Entry<Integer, String> entry = serverRing.ceilingEntry(userHash);
        
        if (entry == null) {
            entry = serverRing.firstEntry();
        }
        
        return entry.getValue();
    }
    
    private int hash(String key) {
        return key.hashCode();
    }
}
```

**ğŸ”¸ è¿æ¥åˆ†å‘æœºåˆ¶**ï¼š
```java
@Component
public class ConnectionDispatcher {
    
    @Autowired
    private ConsistentHashLoadBalancer loadBalancer;
    
    public void handleNewConnection(String userId, WebSocketSession session) {
        // æ ¹æ®ç”¨æˆ·IDåˆ†é…æœåŠ¡å™¨
        String targetServer = loadBalancer.getServer(userId);
        
        if (isCurrentServer(targetServer)) {
            // åœ¨å½“å‰æœåŠ¡å™¨å¤„ç†
            webSocketManager.addConnection(userId, session);
        } else {
            // é‡å®šå‘åˆ°ç›®æ ‡æœåŠ¡å™¨
            redirectConnection(session, targetServer);
        }
    }
    
    private void redirectConnection(WebSocketSession session, String targetServer) {
        try {
            session.sendMessage(new TextMessage(JSON.toJSONString(
                Map.of("type", "redirect", "server", targetServer)
            )));
            session.close();
        } catch (IOException e) {
            logger.error("è¿æ¥é‡å®šå‘å¤±è´¥", e);
        }
    }
}
```

### 6.3 æœåŠ¡å™¨é—´é€šä¿¡


**ğŸ”§ è·¨æœåŠ¡å™¨æ¶ˆæ¯è½¬å‘**ï¼š
```java
@Component
public class CrossServerMessaging {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String MESSAGE_CHANNEL = "cross_server_message";
    
    // å‘é€è·¨æœåŠ¡å™¨æ¶ˆæ¯
    public void sendCrossServerMessage(String targetUserId, Message message) {
        String targetServer = loadBalancer.getServer(targetUserId);
        
        if (!isCurrentServer(targetServer)) {
            CrossServerMessage crossMessage = CrossServerMessage.builder()
                .targetServer(targetServer)
                .targetUserId(targetUserId)
                .message(message)
                .build();
            
            // é€šè¿‡Rediså‘å¸ƒæ¶ˆæ¯
            redisTemplate.convertAndSend(MESSAGE_CHANNEL, JSON.toJSONString(crossMessage));
        } else {
            // æœ¬åœ°å¤„ç†
            webSocketManager.sendToUser(targetUserId, message);
        }
    }
    
    // æ¥æ”¶è·¨æœåŠ¡å™¨æ¶ˆæ¯
    @EventListener
    public void handleCrossServerMessage(String messageJson) {
        CrossServerMessage crossMessage = JSON.parseObject(messageJson, CrossServerMessage.class);
        
        if (isCurrentServer(crossMessage.getTargetServer())) {
            webSocketManager.sendToUser(
                crossMessage.getTargetUserId(), 
                crossMessage.getMessage()
            );
        }
    }
}
```

---

## 7. ğŸ“® æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ


### 7.1 æ¶ˆæ¯é˜Ÿåˆ—çš„ä½œç”¨


åœ¨å¤§è§„æ¨¡å®æ—¶é€šä¿¡ç³»ç»Ÿä¸­ï¼Œ**æ¶ˆæ¯é˜Ÿåˆ—**æ‰¿æ‹…é‡è¦ä½œç”¨ï¼š

```
æ¶ˆæ¯é˜Ÿåˆ—ä½œç”¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç”Ÿäº§è€…     â”‚â”€â”€> â”‚  æ¶ˆæ¯é˜Ÿåˆ—    â”‚â”€â”€> â”‚   æ¶ˆè´¹è€…     â”‚
â”‚ (å‘é€æ¶ˆæ¯)   â”‚    â”‚             â”‚    â”‚ (å¤„ç†æ¶ˆæ¯)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ â”‚ é˜Ÿåˆ—1   â”‚ â”‚
                   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                   â”‚ â”‚ é˜Ÿåˆ—2   â”‚ â”‚
                   â””â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”˜
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜åŠ¿ï¼š
- å‰Šå³°å¡«è°·ï¼šå¤„ç†çªå‘æµé‡
- è§£è€¦ç³»ç»Ÿï¼šç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ç‹¬ç«‹
- å¯é æŠ•é€’ï¼šæ¶ˆæ¯ä¸ä¸¢å¤±
- å¼‚æ­¥å¤„ç†ï¼šæé«˜å“åº”é€Ÿåº¦
```

### 7.2 åŸºäºRabbitMQçš„å®ç°


**ğŸ”§ æ¶ˆæ¯é˜Ÿåˆ—é…ç½®**ï¼š
```java
@Configuration
@EnableRabbit
public class RabbitMQConfig {
    
    // å®šä¹‰æ¶ˆæ¯äº¤æ¢å™¨
    @Bean
    public DirectExchange messageExchange() {
        return new DirectExchange("message.exchange", true, false);
    }
    
    // å®šä¹‰æ¶ˆæ¯é˜Ÿåˆ—
    @Bean
    public Queue messageQueue() {
        return QueueBuilder.durable("message.queue")
                .withArgument("x-message-ttl", 60000) // æ¶ˆæ¯TTL 60ç§’
                .build();
    }
    
    // ç»‘å®šé˜Ÿåˆ—åˆ°äº¤æ¢å™¨
    @Bean
    public Binding messageBinding() {
        return BindingBuilder.bind(messageQueue())
                .to(messageExchange())
                .with("message.routing.key");
    }
}
```

**ğŸ”§ æ¶ˆæ¯ç”Ÿäº§è€…**ï¼š
```java
@Component
public class MessageProducer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendMessage(String userId, Message message) {
        try {
            MessageWrapper wrapper = MessageWrapper.builder()
                .targetUserId(userId)
                .message(message)
                .timestamp(System.currentTimeMillis())
                .build();
            
            rabbitTemplate.convertAndSend(
                "message.exchange",
                "message.routing.key",
                JSON.toJSONString(wrapper)
            );
            
        } catch (Exception e) {
            logger.error("å‘é€æ¶ˆæ¯åˆ°é˜Ÿåˆ—å¤±è´¥", e);
            // é™çº§å¤„ç†ï¼šç›´æ¥æ¨é€
            webSocketManager.sendToUser(userId, message);
        }
    }
}
```

**ğŸ”§ æ¶ˆæ¯æ¶ˆè´¹è€…**ï¼š
```java
@Component
public class MessageConsumer {
    
    @Autowired
    private WebSocketManager webSocketManager;
    
    @RabbitListener(queues = "message.queue")
    public void handleMessage(String messageJson) {
        try {
            MessageWrapper wrapper = JSON.parseObject(messageJson, MessageWrapper.class);
            
            String userId = wrapper.getTargetUserId();
            Message message = wrapper.getMessage();
            
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨çº¿
            if (webSocketManager.isUserOnline(userId)) {
                webSocketManager.sendToUser(userId, message);
            } else {
                // ç”¨æˆ·ä¸åœ¨çº¿ï¼Œå­˜å‚¨ä¸ºç¦»çº¿æ¶ˆæ¯
                offlineMessageService.storeOfflineMessage(userId, message);
            }
            
        } catch (Exception e) {
            logger.error("å¤„ç†é˜Ÿåˆ—æ¶ˆæ¯å¤±è´¥", e);
        }
    }
}
```

### 7.3 æ¶ˆæ¯ä¼˜å…ˆçº§å¤„ç†


**ğŸ”§ ä¼˜å…ˆçº§é˜Ÿåˆ—å®ç°**ï¼š
```java
@Configuration
public class PriorityQueueConfig {
    
    @Bean
    public Queue highPriorityQueue() {
        return QueueBuilder.durable("message.high.priority")
                .withArgument("x-max-priority", 10)
                .build();
    }
    
    @Bean
    public Queue normalPriorityQueue() {
        return QueueBuilder.durable("message.normal.priority")
                .build();
    }
}

// å‘é€æ—¶æŒ‡å®šä¼˜å…ˆçº§
public void sendPriorityMessage(String userId, Message message, int priority) {
    String routingKey = priority > 5 ? "high.priority" : "normal.priority";
    
    rabbitTemplate.convertAndSend(
        "message.exchange",
        routingKey,
        JSON.toJSONString(message),
        msg -> {
            msg.getMessageProperties().setPriority(priority);
            return msg;
        }
    );
}
```

---

## 8. ğŸ—ï¸ IMç³»ç»Ÿæ¶æ„è®¾è®¡


### 8.1 æ•´ä½“æ¶æ„è®¾è®¡


**ç°ä»£IMç³»ç»Ÿ**é‡‡ç”¨**å¾®æœåŠ¡æ¶æ„**ï¼Œå®ç°é«˜å¯ç”¨å’Œå¯æ‰©å±•ï¼š

```
IMç³»ç»Ÿæ•´ä½“æ¶æ„ï¼š

            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   è´Ÿè½½å‡è¡¡å™¨     â”‚
            â”‚   (Nginx/LVS)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚             â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ ç½‘å…³æœåŠ¡ â”‚   â”‚ ç½‘å…³æœåŠ¡ â”‚   â”‚ ç½‘å…³æœåŠ¡ â”‚
   â”‚ Gateway â”‚   â”‚ Gateway â”‚   â”‚ Gateway â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                â”‚                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚è¿æ¥æœåŠ¡  â”‚    â”‚   æ¶ˆæ¯æœåŠ¡   â”‚    â”‚çŠ¶æ€æœåŠ¡  â”‚
â”‚Connectionâ”‚    â”‚   Message   â”‚    â”‚ Status  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                â”‚                â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   æ•°æ®å±‚     â”‚
              â”‚ MySQL/Redis â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.2 æ ¸å¿ƒæœåŠ¡æ¨¡å—


**ğŸ”¸ è¿æ¥æœåŠ¡ (Connection Service)**
- ç®¡ç†WebSocketè¿æ¥
- å¤„ç†ç”¨æˆ·è®¤è¯
- ç»´æŠ¤è¿æ¥çŠ¶æ€
- è´Ÿè½½å‡è¡¡åˆ†å‘

**ğŸ”¸ æ¶ˆæ¯æœåŠ¡ (Message Service)**
- å¤„ç†æ¶ˆæ¯è·¯ç”±
- æ¶ˆæ¯æŒä¹…åŒ–å­˜å‚¨
- æ¶ˆæ¯æ ¼å¼è½¬æ¢
- æ¶ˆæ¯æ¨é€é€»è¾‘

**ğŸ”¸ çŠ¶æ€æœåŠ¡ (Status Service)**  
- ç”¨æˆ·åœ¨çº¿çŠ¶æ€ç®¡ç†
- çŠ¶æ€å˜åŒ–é€šçŸ¥
- å¥½å‹å…³ç³»ç»´æŠ¤

**ğŸ”§ æœåŠ¡æ³¨å†Œä¸å‘ç°**ï¼š
```java
@SpringBootApplication
@EnableEurekaClient
public class IMConnectionService {
    
    @Value("${server.port}")
    private String serverPort;
    
    @PostConstruct
    public void registerService() {
        // æ³¨å†ŒæœåŠ¡å®ä¾‹
        ServiceInstance instance = ServiceInstance.builder()
            .serviceName("im-connection-service")
            .host(getLocalIP())
            .port(Integer.parseInt(serverPort))
            .build();
            
        serviceRegistry.register(instance);
    }
}
```

### 8.3 æ•°æ®å­˜å‚¨è®¾è®¡


**ğŸ”¸ åˆ†åº“åˆ†è¡¨ç­–ç•¥**ï¼š
```sql
-- ç”¨æˆ·è¡¨ (æŒ‰ç”¨æˆ·ID hashåˆ†ç‰‡)
CREATE TABLE user_info_0 (
    user_id VARCHAR(64) PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    nickname VARCHAR(100),
    avatar_url VARCHAR(200),
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ¶ˆæ¯è¡¨ (æŒ‰æ—¶é—´åˆ†ç‰‡)
CREATE TABLE messages_202501 (
    id VARCHAR(64) PRIMARY KEY,
    from_user VARCHAR(64) NOT NULL,
    to_user VARCHAR(64),
    group_id VARCHAR(64),
    content TEXT NOT NULL,
    msg_type TINYINT NOT NULL,
    timestamp BIGINT NOT NULL,
    INDEX idx_from_time (from_user, timestamp),
    INDEX idx_to_time (to_user, timestamp)
);

-- ç¾¤ç»„è¡¨
CREATE TABLE group_info (
    group_id VARCHAR(64) PRIMARY KEY,
    group_name VARCHAR(100) NOT NULL,
    owner_id VARCHAR(64) NOT NULL,
    member_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 9. ğŸ”„ æ¶ˆæ¯è·¯ç”±ä¸åºåˆ—ä¿è¯


### 9.1 æ¶ˆæ¯è·¯ç”±ç®—æ³•


**æ¶ˆæ¯è·¯ç”±**è´Ÿè´£å°†æ¶ˆæ¯ä»å‘é€æ–¹å‡†ç¡®ä¼ é€’åˆ°æ¥æ”¶æ–¹ï¼š

```
è·¯ç”±å†³ç­–æµç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ¥æ”¶æ¶ˆæ¯     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”    No   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚å•èŠï¼Ÿ  â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ ç¾¤èŠè·¯ç”±å¤„ç† â”‚
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚Yes
   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”    No   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚åœ¨çº¿ï¼Ÿ  â”‚â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ ç¦»çº¿æ¶ˆæ¯å¤„ç† â”‚
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚Yes
   â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
   â”‚ç›´æ¥æ¨é€ â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ”§ è·¯ç”±ç®—æ³•å®ç°**ï¼š
```java
@Service
public class MessageRouter {
    
    public void routeMessage(Message message) {
        if (message.getToUser() != null) {
            // å•èŠæ¶ˆæ¯è·¯ç”±
            routePrivateMessage(message);
        } else if (message.getGroupId() != null) {
            // ç¾¤èŠæ¶ˆæ¯è·¯ç”±
            routeGroupMessage(message);
        }
    }
    
    private void routePrivateMessage(Message message) {
        String toUser = message.getToUser();
        String targetServer = loadBalancer.getServer(toUser);
        
        if (isCurrentServer(targetServer)) {
            // æœ¬åœ°ç”¨æˆ·
            if (webSocketManager.isUserOnline(toUser)) {
                webSocketManager.sendToUser(toUser, message);
            } else {
                offlineMessageService.storeMessage(toUser, message);
            }
        } else {
            // è·¨æœåŠ¡å™¨è½¬å‘
            crossServerMessaging.sendCrossServerMessage(toUser, message);
        }
    }
    
    private void routeGroupMessage(Message message) {
        String groupId = message.getGroupId();
        List<String> members = groupService.getGroupMembers(groupId);
        
        // è·å–æˆå‘˜åˆ†å¸ƒçš„æœåŠ¡å™¨
        Map<String, List<String>> serverMembers = members.stream()
            .collect(Collectors.groupingBy(loadBalancer::getServer));
        
        // æŒ‰æœåŠ¡å™¨æ‰¹é‡å‘é€
        serverMembers.forEach((server, users) -> {
            if (isCurrentServer(server)) {
                // æœ¬åœ°æ‰¹é‡å‘é€
                users.forEach(user -> {
                    if (webSocketManager.isUserOnline(user)) {
                        webSocketManager.sendToUser(user, message);
                    }
                });
            } else {
                // è·¨æœåŠ¡å™¨æ‰¹é‡è½¬å‘
                crossServerMessaging.sendBatchCrossServerMessage(server, users, message);
            }
        });
    }
}
```

### 9.2 æ¶ˆæ¯åºåˆ—ä¿è¯


**æ¶ˆæ¯é¡ºåºæ€§**å¯¹äºèŠå¤©ä½“éªŒè‡³å…³é‡è¦ï¼Œéœ€è¦ä¿è¯æ¶ˆæ¯æŒ‰å‘é€é¡ºåºåˆ°è¾¾ï¼š

**ğŸ”¸ åºåˆ—å·æœºåˆ¶**ï¼š
```java
@Component
public class MessageSequencer {
    
    // ä¸ºæ¯ä¸ªä¼šè¯ç»´æŠ¤åºåˆ—å·
    private Map<String, AtomicLong> sessionSequence = new ConcurrentHashMap<>();
    
    public Message addSequence(Message message) {
        String sessionKey = generateSessionKey(message);
        
        AtomicLong sequence = sessionSequence.computeIfAbsent(
            sessionKey, k -> new AtomicLong(0)
        );
        
        message.setSequence(sequence.incrementAndGet());
        return message;
    }
    
    private String generateSessionKey(Message message) {
        if (message.getToUser() != null) {
            // å•èŠä¼šè¯ï¼šä¸¤ä¸ªç”¨æˆ·IDæ’åºç»„åˆ
            List<String> users = Arrays.asList(message.getFromUser(), message.getToUser());
            Collections.sort(users);
            return "private:" + String.join("_", users);
        } else {
            // ç¾¤èŠä¼šè¯
            return "group:" + message.getGroupId();
        }
    }
}
```

**ğŸ”¸ æ¶ˆæ¯æ’åºå¤„ç†**ï¼š
```java
@Component
public class MessageOrderProcessor {
    
    // æ¶ˆæ¯ç¼“å­˜ï¼Œç­‰å¾…ä¹±åºæ¶ˆæ¯
    private Map<String, Queue<Message>> messageBuffer = new ConcurrentHashMap<>();
    
    public void processMessage(Message message, String sessionKey) {
        Queue<Message> buffer = messageBuffer.computeIfAbsent(
            sessionKey, k -> new PriorityQueue<>(
                Comparator.comparing(Message::getSequence)
            )
        );
        
        buffer.offer(message);
        
        // å¤„ç†è¿ç»­çš„æ¶ˆæ¯
        processConsecutiveMessages(sessionKey);
    }
    
    private void processConsecutiveMessages(String sessionKey) {
        Queue<Message> buffer = messageBuffer.get(sessionKey);
        long expectedSequence = getExpectedSequence(sessionKey);
        
        while (!buffer.isEmpty() && 
               buffer.peek().getSequence() == expectedSequence) {
            
            Message message = buffer.poll();
            deliverMessage(message);
            expectedSequence++;
        }
        
        updateExpectedSequence(sessionKey, expectedSequence);
    }
}
```

---

## 10. ğŸ“¹ å¤šåª’ä½“å®æ—¶é€šä¿¡


### 10.1 å¤šåª’ä½“æ¶ˆæ¯ç±»å‹


ç°ä»£IMç³»ç»Ÿæ”¯æŒå¤šç§åª’ä½“ç±»å‹çš„æ¶ˆæ¯ï¼š

```
åª’ä½“æ¶ˆæ¯åˆ†ç±»ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ–‡æœ¬æ¶ˆæ¯   â”‚ â† çº¯æ–‡æœ¬ã€è¡¨æƒ…ã€@æåŠ
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚   å›¾ç‰‡æ¶ˆæ¯   â”‚ â† JPEGã€PNGã€GIFã€WebP
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   è¯­éŸ³æ¶ˆæ¯   â”‚ â† AMRã€AACã€MP3
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   è§†é¢‘æ¶ˆæ¯   â”‚ â† MP4ã€AVIã€MOV
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ–‡ä»¶æ¶ˆæ¯   â”‚ â† æ–‡æ¡£ã€å‹ç¼©åŒ…ç­‰
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10.2 æ–‡ä»¶ä¸Šä¼ ä¸å­˜å‚¨


**ğŸ”§ æ–‡ä»¶ä¸Šä¼ å¤„ç†**ï¼š
```java
@RestController
@RequestMapping("/api/media")
public class MediaController {
    
    @Autowired
    private MinioClient minioClient;
    
    @PostMapping("/upload")
    public ResponseEntity<FileUploadResponse> uploadFile(
            @RequestParam("file") MultipartFile file,
            @RequestParam("type") String mediaType) {
        
        try {
            // éªŒè¯æ–‡ä»¶ç±»å‹å’Œå¤§å°
            validateFile(file, mediaType);
            
            // ç”Ÿæˆæ–‡ä»¶å
            String fileName = generateFileName(file.getOriginalFilename());
            String bucketName = getBucketByType(mediaType);
            
            // ä¸Šä¼ åˆ°å¯¹è±¡å­˜å‚¨
            minioClient.putObject(
                PutObjectArgs.builder()
                    .bucket(bucketName)
                    .object(fileName)
                    .stream(file.getInputStream(), file.getSize(), -1)
                    .contentType(file.getContentType())
                    .build()
            );
            
            // ç”Ÿæˆè®¿é—®URL
            String fileUrl = generateFileUrl(bucketName, fileName);
            
            FileUploadResponse response = FileUploadResponse.builder()
                .fileId(fileName)
                .fileUrl(fileUrl)
                .fileSize(file.getSize())
                .mimeType(file.getContentType())
                .build();
                
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            logger.error("æ–‡ä»¶ä¸Šä¼ å¤±è´¥", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    private void validateFile(MultipartFile file, String mediaType) {
        long maxSize = getMaxSizeByType(mediaType);
        if (file.getSize() > maxSize) {
            throw new IllegalArgumentException("æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶");
        }
        
        List<String> allowedTypes = getAllowedTypesByCategory(mediaType);
        if (!allowedTypes.contains(file.getContentType())) {
            throw new IllegalArgumentException("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹");
        }
    }
}
```

### 10.3 è¯­éŸ³æ¶ˆæ¯å¤„ç†


**ğŸ”§ è¯­éŸ³æ¶ˆæ¯ç‰¹æ®Šå¤„ç†**ï¼š
```java
@Service
public class VoiceMessageService {
    
    public void processVoiceMessage(String userId, MultipartFile voiceFile) {
        try {
            // éŸ³é¢‘æ ¼å¼è½¬æ¢ (è½¬ä¸ºAACæ ¼å¼èŠ‚çœå¸¦å®½)
            byte[] convertedAudio = audioConverter.convertToAAC(voiceFile.getBytes());
            
            // æå–éŸ³é¢‘æ—¶é•¿
            int duration = audioAnalyzer.getDuration(convertedAudio);
            
            // è¯­éŸ³è¯†åˆ« (å¯é€‰)
            String transcript = speechToTextService.recognize(convertedAudio);
            
            // æ„å»ºè¯­éŸ³æ¶ˆæ¯
            VoiceMessage voiceMessage = VoiceMessage.builder()
                .audioUrl(uploadAudio(convertedAudio))
                .duration(duration)
                .transcript(transcript)
                .format("aac")
                .build();
                
            // å‘é€æ¶ˆæ¯
            messagePushService.pushVoiceMessage(userId, voiceMessage);
            
        } catch (Exception e) {
            logger.error("è¯­éŸ³æ¶ˆæ¯å¤„ç†å¤±è´¥", e);
        }
    }
}
```

### 10.4 å®æ—¶éŸ³è§†é¢‘é€šè¯


**ğŸ”¸ WebRTCé›†æˆ**ï¼š
```javascript
// å‘èµ·éŸ³è§†é¢‘é€šè¯
class VideoCallManager {
    constructor() {
        this.localStream = null;
        this.peerConnection = null;
        this.socket = null;
    }
    
    async startCall(targetUserId, isVideoCall = false) {
        try {
            // è·å–æœ¬åœ°åª’ä½“æµ
            this.localStream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                video: isVideoCall
            });
            
            // åˆ›å»ºRTCPeerConnection
            this.peerConnection = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });
            
            // æ·»åŠ æœ¬åœ°æµ
            this.localStream.getTracks().forEach(track => {
                this.peerConnection.addTrack(track, this.localStream);
            });
            
            // å¤„ç†ICEå€™é€‰
            this.peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    this.socket.send(JSON.stringify({
                        type: 'ice-candidate',
                        to: targetUserId,
                        candidate: event.candidate
                    }));
                }
            };
            
            // åˆ›å»ºå¹¶å‘é€Offer
            const offer = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(offer);
            
            this.socket.send(JSON.stringify({
                type: 'call-offer',
                to: targetUserId,
                offer: offer,
                isVideo: isVideoCall
            }));
            
        } catch (error) {
            console.error('å‘èµ·é€šè¯å¤±è´¥:', error);
        }
    }
    
    async handleCallOffer(offer, fromUserId) {
        // å¤„ç†æ¥ç”µoffer
        await this.peerConnection.setRemoteDescription(offer);
        
        const answer = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(answer);
        
        this.socket.send(JSON.stringify({
            type: 'call-answer',
            to: fromUserId,
            answer: answer
        }));
    }
}
```

---

## 11. ğŸ”’ å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–


### 11.1 ç«¯åˆ°ç«¯åŠ å¯†


**æ¶ˆæ¯å®‰å…¨**æ˜¯IMç³»ç»Ÿçš„é‡è¦è€ƒè™‘ï¼Œå®ç°ç«¯åˆ°ç«¯åŠ å¯†ä¿æŠ¤éšç§ï¼š

```
åŠ å¯†é€šä¿¡æµç¨‹ï¼š
ç”¨æˆ·A                     æœåŠ¡å™¨                     ç”¨æˆ·B
  |                        |                        |
  |â”€ç”Ÿæˆå¯†é’¥å¯¹â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|â”€ç”Ÿæˆå¯†é’¥å¯¹
  |                        |                        |
  |â”€å…¬é’¥äº¤æ¢â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ä¸­è½¬â”€â”€â”€â”€â”€â”€â”€â”€|â”€å…¬é’¥äº¤æ¢
  |                        |                        |
  |â”€åŠ å¯†æ¶ˆæ¯â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ä¸­è½¬â”€â”€â”€â”€â”€â”€â”€â”€|â”€è§£å¯†æ¶ˆæ¯
  |  (ç”¨Bçš„å…¬é’¥åŠ å¯†)        |    (æœåŠ¡å™¨æ— æ³•è§£å¯†)     | (ç”¨Açš„ç§é’¥è§£å¯†)
```

**ğŸ”§ åŠ å¯†å®ç°ç¤ºä¾‹**ï¼š
```java
@Service
public class MessageEncryptionService {
    
    @Autowired
    private RSAKeyService keyService;
    
    public EncryptedMessage encryptMessage(String toUserId, String plainText) {
        try {
            // è·å–æ¥æ”¶æ–¹å…¬é’¥
            PublicKey publicKey = keyService.getPublicKey(toUserId);
            
            // ä½¿ç”¨AESå¯¹ç§°åŠ å¯†æ¶ˆæ¯å†…å®¹
            SecretKey aesKey = generateAESKey();
            byte[] encryptedContent = encryptWithAES(plainText, aesKey);
            
            // ä½¿ç”¨RSAåŠ å¯†AESå¯†é’¥
            byte[] encryptedAESKey = encryptWithRSA(aesKey.getEncoded(), publicKey);
            
            return EncryptedMessage.builder()
                .encryptedContent(Base64.encode(encryptedContent))
                .encryptedKey(Base64.encode(encryptedAESKey))
                .algorithm("AES-256-GCM")
                .build();
                
        } catch (Exception e) {
            logger.error("æ¶ˆæ¯åŠ å¯†å¤±è´¥", e);
            throw new EncryptionException("æ¶ˆæ¯åŠ å¯†å¤±è´¥");
        }
    }
    
    public String decryptMessage(EncryptedMessage encMessage, String userId) {
        try {
            // è·å–ç”¨æˆ·ç§é’¥
            PrivateKey privateKey = keyService.getPrivateKey(userId);
            
            // è§£å¯†AESå¯†é’¥
            byte[] decryptedAESKey = decryptWithRSA(
                Base64.decode(encMessage.getEncryptedKey()), 
                privateKey
            );
            
            SecretKey aesKey = new SecretKeySpec(decryptedAESKey, "AES");
            
            // è§£å¯†æ¶ˆæ¯å†…å®¹
            byte[] decryptedContent = decryptWithAES(
                Base64.decode(encMessage.getEncryptedContent()), 
                aesKey
            );
            
            return new String(decryptedContent, StandardCharsets.UTF_8);
            
        } catch (Exception e) {
            logger.error("æ¶ˆæ¯è§£å¯†å¤±è´¥", e);
            throw new DecryptionException("æ¶ˆæ¯è§£å¯†å¤±è´¥");
        }
    }
}
```

### 11.2 é€šä¿¡è´¨é‡ç›‘æ§


**ğŸ”§ æ€§èƒ½ç›‘æ§å®ç°**ï¼š
```java
@Component
public class CommunicationMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Timer messageLatencyTimer;
    private final Counter messageCounter;
    
    public CommunicationMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.messageLatencyTimer = Timer.builder("message.latency")
            .description("æ¶ˆæ¯å»¶è¿Ÿç›‘æ§")
            .register(meterRegistry);
        this.messageCounter = Counter.builder("message.count")
            .description("æ¶ˆæ¯æ•°é‡ç»Ÿè®¡")
            .register(meterRegistry);
    }
    
    public void recordMessageSent(String messageId, long timestamp) {
        messageCounter.increment(Tags.of("type", "sent"));
        
        // è®°å½•å‘é€æ—¶é—´
        RedisTemplate.opsForValue().set(
            "msg_sent:" + messageId, 
            String.valueOf(timestamp), 
            Duration.ofMinutes(5)
        );
    }
    
    public void recordMessageReceived(String messageId) {
        messageCounter.increment(Tags.of("type", "received"));
        
        // è®¡ç®—ç«¯åˆ°ç«¯å»¶è¿Ÿ
        String sentTimeStr = RedisTemplate.opsForValue().get("msg_sent:" + messageId);
        if (sentTimeStr != null) {
            long sentTime = Long.parseLong(sentTimeStr);
            long latency = System.currentTimeMillis() - sentTime;
            messageLatencyTimer.record(Duration.ofMillis(latency));
        }
    }
    
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿç»Ÿè®¡
    public void reportMetrics() {
        long totalMessages = messageCounter.count();
        double avgLatency = messageLatencyTimer.mean(TimeUnit.MILLISECONDS);
        
        logger.info("æ¶ˆæ¯ç»Ÿè®¡ - æ€»æ•°: {}, å¹³å‡å»¶è¿Ÿ: {}ms", totalMessages, avgLatency);
        
        // å‘é€å‘Šè­¦
        if (avgLatency > 1000) { // å»¶è¿Ÿè¶…è¿‡1ç§’
            alertService.sendAlert("æ¶ˆæ¯å»¶è¿Ÿè¿‡é«˜: " + avgLatency + "ms");
        }
    }
}
```

### 11.3 å¼±ç½‘ç»œä¼˜åŒ–


**ğŸ”§ ç½‘ç»œé€‚åº”æ€§ä¼˜åŒ–**ï¼š
```java
@Service
public class NetworkOptimizationService {
    
    public void optimizeForNetworkQuality(String userId, NetworkQuality quality) {
        ConnectionConfig config = getConnectionConfig(userId);
        
        switch (quality) {
            case POOR:
                // å¼±ç½‘ç»œä¼˜åŒ–
                config.setHeartbeatInterval(60000); // å¢åŠ å¿ƒè·³é—´éš”
                config.setMessageBatchSize(1);      // å•æ¡æ¶ˆæ¯å‘é€
                config.setCompressionEnabled(true); // å¯ç”¨å‹ç¼©
                config.setRetryMaxTimes(5);         // å¢åŠ é‡è¯•æ¬¡æ•°
                break;
                
            case FAIR:
                config.setHeartbeatInterval(30000);
                config.setMessageBatchSize(5);
                config.setCompressionEnabled(true);
                config.setRetryMaxTimes(3);
                break;
                
            case GOOD:
                config.setHeartbeatInterval(15000);
                config.setMessageBatchSize(10);
                config.setCompressionEnabled(false);
                config.setRetryMaxTimes(2);
                break;
        }
        
        updateConnectionConfig(userId, config);
    }
    
    // ç½‘ç»œè´¨é‡æ£€æµ‹
    @EventListener
    public void handleNetworkQualityChange(NetworkQualityEvent event) {
        String userId = event.getUserId();
        NetworkQuality quality = detectNetworkQuality(userId);
        
        optimizeForNetworkQuality(userId, quality);
        
        // é€šçŸ¥å®¢æˆ·ç«¯è°ƒæ•´ç­–ç•¥
        NetworkOptimizationMessage message = NetworkOptimizationMessage.builder()
            .type("network_optimization")
            .quality(quality.name())
            .suggestions(getOptimizationSuggestions(quality))
            .build();
            
        webSocketManager.sendToUser(userId, message);
    }
}
```

### 11.4 å¤§è§„æ¨¡è¿æ¥ç®¡ç†


**ğŸ”§ è¿æ¥æ± ç®¡ç†**ï¼š
```java
@Component
public class ConnectionPoolManager {
    
    private final int MAX_CONNECTIONS_PER_SERVER = 100000;
    private final AtomicInteger currentConnections = new AtomicInteger(0);
    private final Map<String, ConnectionInfo> connectionMap = new ConcurrentHashMap<>();
    
    public boolean acceptConnection(String userId, WebSocketSession session) {
        if (currentConnections.get() >= MAX_CONNECTIONS_PER_SERVER) {
            // è¿æ¥æ•°è¾¾åˆ°ä¸Šé™ï¼Œæ‹’ç»æ–°è¿æ¥
            logger.warn("æœåŠ¡å™¨è¿æ¥æ•°è¾¾åˆ°ä¸Šé™ï¼Œæ‹’ç»ç”¨æˆ· {} çš„è¿æ¥", userId);
            return false;
        }
        
        ConnectionInfo connInfo = ConnectionInfo.builder()
            .userId(userId)
            .session(session)
            .connectTime(System.currentTimeMillis())
            .lastActiveTime(System.currentTimeMillis())
            .build();
            
        connectionMap.put(userId, connInfo);
        currentConnections.incrementAndGet();
        
        // å¯åŠ¨è¿æ¥ç›‘æ§
        startConnectionMonitoring(userId);
        
        return true;
    }
    
    public void closeConnection(String userId) {
        ConnectionInfo connInfo = connectionMap.remove(userId);
        if (connInfo != null) {
            try {
                connInfo.getSession().close();
            } catch (IOException e) {
                logger.error("å…³é—­è¿æ¥å¤±è´¥", e);
            }
            currentConnections.decrementAndGet();
        }
    }
    
    // å®šæœŸæ¸…ç†æ— æ•ˆè¿æ¥
    @Scheduled(fixedRate = 30000)
    public void cleanupInactiveConnections() {
        long now = System.currentTimeMillis();
        long timeout = 5 * 60 * 1000; // 5åˆ†é’Ÿè¶…æ—¶
        
        connectionMap.entrySet().removeIf(entry -> {
            ConnectionInfo info = entry.getValue();
            if (now - info.getLastActiveTime() > timeout) {
                closeConnection(entry.getKey());
                return true;
            }
            return false;
        });
    }
}
```

---

## 12. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 12.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ å®æ—¶é€šä¿¡åŸºç¡€ï¼šWebSocketåè®®ã€é•¿è¿æ¥ç®¡ç†ã€åŒå‘é€šä¿¡
ğŸ”¸ è¿æ¥ç®¡ç†ï¼šè¿æ¥å»ºç«‹ã€å¿ƒè·³ä¿æ´»ã€æ–­çº¿é‡è¿ã€è¿æ¥æ± ç®¡ç†
ğŸ”¸ æ¶ˆæ¯æ¨é€ï¼šå‘å¸ƒè®¢é˜…æ¨¡å¼ã€æ¶ˆæ¯è·¯ç”±ã€å®æ—¶æ¨é€ã€ç¦»çº¿æ¶ˆæ¯
ğŸ”¸ çŠ¶æ€åŒæ­¥ï¼šåœ¨çº¿çŠ¶æ€ç®¡ç†ã€çŠ¶æ€å˜åŒ–é€šçŸ¥ã€æ´»è·ƒåº¦æ£€æµ‹
ğŸ”¸ å¯é ä¼ è¾“ï¼šæ¶ˆæ¯ç¡®è®¤æœºåˆ¶ã€é‡è¯•ç­–ç•¥ã€æ¶ˆæ¯æŒä¹…åŒ–
ğŸ”¸ è´Ÿè½½å‡è¡¡ï¼šä¸€è‡´æ€§å“ˆå¸Œã€è¿æ¥åˆ†å‘ã€è·¨æœåŠ¡å™¨é€šä¿¡
ğŸ”¸ ç³»ç»Ÿæ¶æ„ï¼šå¾®æœåŠ¡è®¾è®¡ã€æœåŠ¡æ³¨å†Œå‘ç°ã€æ•°æ®å­˜å‚¨åˆ†ç‰‡
ğŸ”¸ å®‰å…¨ä¼˜åŒ–ï¼šç«¯åˆ°ç«¯åŠ å¯†ã€æ€§èƒ½ç›‘æ§ã€å¼±ç½‘ç»œé€‚é…
```

### 12.2 å…³é”®æŠ€æœ¯ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆé€‰æ‹©WebSocket**
```
HTTPè½®è¯¢çš„é—®é¢˜ï¼š
- æœåŠ¡å™¨æ— æ³•ä¸»åŠ¨æ¨é€
- é¢‘ç¹çš„è¯·æ±‚å»ºç«‹å¼€é”€å¤§
- å®æ—¶æ€§å·®ï¼Œå»¶è¿Ÿé«˜

WebSocketä¼˜åŠ¿ï¼š
- å…¨åŒå·¥é€šä¿¡
- è¿æ¥å¤ç”¨ï¼Œå¼€é”€ä½
- å®æ—¶æ€§å¼ºï¼Œå»¶è¿Ÿä½
- æ”¯æŒäºŒè¿›åˆ¶æ•°æ®ä¼ è¾“
```

**ğŸ”¹ æ¶ˆæ¯å¯é æ€§å¦‚ä½•ä¿è¯**
```
å¤šå±‚ä¿éšœæœºåˆ¶ï¼š
1. åº”ç”¨å±‚ï¼šæ¶ˆæ¯ç¡®è®¤ + é‡è¯•æœºåˆ¶
2. ä¼ è¾“å±‚ï¼šTCPå¯é ä¼ è¾“
3. å­˜å‚¨å±‚ï¼šæ¶ˆæ¯æŒä¹…åŒ–å­˜å‚¨
4. ç›‘æ§å±‚ï¼šå®æ—¶ç›‘æ§ + å‘Šè­¦
```

**ğŸ”¹ å¤§è§„æ¨¡ç³»ç»Ÿå¦‚ä½•è®¾è®¡**
```
æ°´å¹³æ‰©å±•ç­–ç•¥ï¼š
- è¿æ¥å±‚ï¼šè´Ÿè½½å‡è¡¡ + è¿æ¥åˆ†å‘
- é€»è¾‘å±‚ï¼šå¾®æœåŠ¡æ‹†åˆ† + æ— çŠ¶æ€è®¾è®¡
- å­˜å‚¨å±‚ï¼šåˆ†åº“åˆ†è¡¨ + è¯»å†™åˆ†ç¦»
- ç¼“å­˜å±‚ï¼šRedisé›†ç¾¤ + æ•°æ®åˆ†ç‰‡
```

### 12.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ“± é€‚ç”¨åœºæ™¯**ï¼š
- âœ… å³æ—¶é€šè®¯åº”ç”¨ (å¾®ä¿¡ã€é’‰é’‰)
- âœ… å®æ—¶åä½œå·¥å…· (åœ¨çº¿æ–‡æ¡£ã€ç™½æ¿)
- âœ… åœ¨çº¿æ¸¸æˆ (å®æ—¶å¯¹æˆ˜ã€çŠ¶æ€åŒæ­¥)
- âœ… é‡‘èäº¤æ˜“ (è¡Œæƒ…æ¨é€ã€äº¤æ˜“ç¡®è®¤)
- âœ… ç‰©è”ç½‘åº”ç”¨ (è®¾å¤‡ç›‘æ§ã€æ•°æ®ä¸ŠæŠ¥)

**ğŸ”§ æŠ€æœ¯é€‰å‹å»ºè®®**ï¼š
```
å°è§„æ¨¡åº”ç”¨ï¼ˆ<1ä¸‡ç”¨æˆ·ï¼‰ï¼š
- å•ä½“æ¶æ„ + WebSocket
- MySQL + Redis
- ç®€å•çš„è´Ÿè½½å‡è¡¡

ä¸­ç­‰è§„æ¨¡ï¼ˆ1-10ä¸‡ç”¨æˆ·ï¼‰ï¼š
- å¾®æœåŠ¡æ¶æ„
- æ¶ˆæ¯é˜Ÿåˆ— (RabbitMQ/Kafka)
- åˆ†å¸ƒå¼ç¼“å­˜

å¤§è§„æ¨¡åº”ç”¨ï¼ˆ>10ä¸‡ç”¨æˆ·ï¼‰ï¼š
- äº‘åŸç”Ÿæ¶æ„
- å®¹å™¨åŒ–éƒ¨ç½² (Kubernetes)
- åˆ†å¸ƒå¼å­˜å‚¨å’Œè®¡ç®—
```

**âš ï¸ å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ**ï¼š
```
è¿æ¥é¢‘ç¹æ–­å¼€ï¼š
â†’ æ£€æŸ¥ç½‘ç»œè´¨é‡å’Œå¿ƒè·³æœºåˆ¶
â†’ å®ç°æ–­çº¿é‡è¿å’ŒæŒ‡æ•°é€€é¿

æ¶ˆæ¯ä¸¢å¤±ï¼š
â†’ æ·»åŠ æ¶ˆæ¯ç¡®è®¤æœºåˆ¶
â†’ å®ç°æ¶ˆæ¯æŒä¹…åŒ–å­˜å‚¨

æ€§èƒ½ç“¶é¢ˆï¼š
â†’ è¿æ¥åˆ†å‘å’Œè´Ÿè½½å‡è¡¡
â†’ æ¶ˆæ¯é˜Ÿåˆ—å‰Šå³°å¡«è°·

å®‰å…¨é—®é¢˜ï¼š
â†’ å®ç°ç«¯åˆ°ç«¯åŠ å¯†
â†’ åŠ å¼ºèº«ä»½è®¤è¯å’Œæˆæƒ
```

### 12.4 å‘å±•è¶‹åŠ¿


**ğŸš€ æŠ€æœ¯å‘å±•æ–¹å‘**ï¼š
- **5Gç½‘ç»œ**ï¼šæ›´ä½å»¶è¿Ÿå’Œæ›´é«˜å¸¦å®½
- **è¾¹ç¼˜è®¡ç®—**ï¼šå°±è¿‘å¤„ç†å‡å°‘å»¶è¿Ÿ  
- **AIé›†æˆ**ï¼šæ™ºèƒ½æ¶ˆæ¯è¿‡æ»¤å’Œå†…å®¹ç†è§£
- **WebRTCæ¼”è¿›**ï¼šæ›´å¥½çš„éŸ³è§†é¢‘é€šä¿¡è´¨é‡
- **åŒºå—é“¾**ï¼šå»ä¸­å¿ƒåŒ–çš„é€šä¿¡æ¶æ„

**æ ¸å¿ƒè®°å¿†è¦ç‚¹**ï¼š
- å®æ—¶é€šä¿¡ä»¥ç”¨æˆ·ä½“éªŒä¸ºæ ¸å¿ƒï¼Œå»¶è¿Ÿæ˜¯å…³é”®æŒ‡æ ‡
- ç³»ç»Ÿè®¾è®¡éœ€è¦è€ƒè™‘å¯é æ€§ã€å¯æ‰©å±•æ€§å’Œå®‰å…¨æ€§
- WebSocketæ˜¯å®ç°å®æ—¶é€šä¿¡çš„ä¸»æµæŠ€æœ¯é€‰æ‹©
- å¤§è§„æ¨¡ç³»ç»Ÿéœ€è¦å¾®æœåŠ¡æ¶æ„å’Œåˆ†å¸ƒå¼è®¾è®¡
- ç›‘æ§å’Œä¼˜åŒ–æ˜¯ä¿éšœç³»ç»Ÿç¨³å®šè¿è¡Œçš„é‡è¦æ‰‹æ®µ