---
title: 15、资金流水设计
---
## 📚 目录

1. [资金流水模型设计](#1-资金流水模型设计)
2. [流水唯一性保障](#2-流水唯一性保障)
3. [流水状态管理](#3-流水状态管理)
4. [流水查询优化](#4-流水查询优化)
5. [流水数据分片策略](#5-流水数据分片策略)
6. [流水审计要求](#6-流水审计要求)
7. [流水性能设计](#7-流水性能设计)
8. [流水数据压缩与归档](#8-流水数据压缩与归档)
9. [流水实时分析与监控](#9-流水实时分析与监控)
10. [流水安全与权限控制](#10-流水安全与权限控制)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 💰 资金流水模型设计


### 1.1 什么是资金流水


**💡 通俗解释**：
资金流水就像银行账单一样，记录每一笔钱的进出情况。想象你的银行卡，每次刷卡、转账、存钱，都会产生一条流水记录。

```
生活中的例子：
小明账户余额：1000元
转账给小红：500元  → 产生一条流水：支出500元
收到工资：3000元   → 产生一条流水：收入3000元
当前余额：3500元
```

### 1.2 核心表结构设计


**🔸 主流水表设计**
```sql
-- 资金流水主表
CREATE TABLE fund_flow (
    flow_id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '流水ID',
    flow_no VARCHAR(64) UNIQUE NOT NULL COMMENT '流水号',
    biz_type VARCHAR(32) NOT NULL COMMENT '业务类型',
    account_id BIGINT NOT NULL COMMENT '账户ID', 
    amount DECIMAL(18,2) NOT NULL COMMENT '金额',
    flow_type TINYINT NOT NULL COMMENT '流水类型:1收入2支出',
    balance_before DECIMAL(18,2) NOT NULL COMMENT '交易前余额',
    balance_after DECIMAL(18,2) NOT NULL COMMENT '交易后余额',
    status TINYINT DEFAULT 1 COMMENT '状态:1成功2失败3处理中',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 索引设计
    INDEX idx_account_time (account_id, create_time),
    INDEX idx_flow_no (flow_no),
    INDEX idx_biz_type_time (biz_type, create_time),
    INDEX idx_status_time (status, create_time)
) ENGINE=InnoDB COMMENT='资金流水表';
```

**🔸 扩展信息表**
```sql
-- 流水扩展信息表
CREATE TABLE fund_flow_ext (
    flow_id BIGINT PRIMARY KEY COMMENT '流水ID',
    source_account_id BIGINT COMMENT '来源账户ID',
    target_account_id BIGINT COMMENT '目标账户ID',
    channel VARCHAR(32) COMMENT '渠道：app/web/api',
    terminal_id VARCHAR(64) COMMENT '终端ID',
    operator_id BIGINT COMMENT '操作员ID',
    remark VARCHAR(500) COMMENT '备注',
    ext_data JSON COMMENT '扩展数据',
    
    FOREIGN KEY (flow_id) REFERENCES fund_flow(flow_id)
) ENGINE=InnoDB COMMENT='流水扩展信息表';
```

### 1.3 设计理念说明


**🎯 为什么这样设计**：
```
分表原因：
• 主表：核心字段，查询频繁，保持轻量
• 扩展表：详细信息，按需查询，避免主表过宽

字段含义：
• flow_no：业务流水号，全局唯一，便于追踪
• balance_before/after：交易前后余额，用于对账
• status：流水状态，支持异步处理场景
```

---

## 2. 🔐 流水唯一性保障


### 2.1 流水号生成策略


**💡 什么是流水号唯一性**：
就像身份证号码一样，每个人只能有一个，流水号也必须全局唯一，不能重复。

**🔸 分布式流水号生成**
```sql
-- 流水号规则：业务类型 + 日期 + 序列号
-- 示例：PAY20250115000001
CREATE TABLE flow_sequence (
    seq_date DATE PRIMARY KEY COMMENT '日期',
    biz_type VARCHAR(32) NOT NULL COMMENT '业务类型',
    current_seq INT NOT NULL DEFAULT 0 COMMENT '当前序列号',
    
    UNIQUE KEY uk_date_biz (seq_date, biz_type)
) ENGINE=InnoDB COMMENT='流水序列号表';
```

**🔸 生成流水号的存储过程**
```sql
DELIMITER //
CREATE PROCEDURE GetFlowNo(
    IN p_biz_type VARCHAR(32),
    OUT p_flow_no VARCHAR(64)
)
BEGIN
    DECLARE v_seq INT DEFAULT 0;
    DECLARE v_date DATE DEFAULT CURDATE();
    
    -- 获取并更新序列号
    INSERT INTO flow_sequence (seq_date, biz_type, current_seq) 
    VALUES (v_date, p_biz_type, 1)
    ON DUPLICATE KEY UPDATE current_seq = current_seq + 1;
    
    -- 获取序列号
    SELECT current_seq INTO v_seq 
    FROM flow_sequence 
    WHERE seq_date = v_date AND biz_type = p_biz_type;
    
    -- 生成流水号
    SET p_flow_no = CONCAT(p_biz_type, DATE_FORMAT(v_date, '%Y%m%d'), 
                          LPAD(v_seq, 6, '0'));
END //
DELIMITER ;
```

### 2.2 幂等性保障


**💡 什么是幂等性**：
简单说就是"重复操作不会产生副作用"。比如你按了两次转账按钮，只会转一次账，不会转两次。

**🔸 幂等控制表**
```sql
CREATE TABLE idempotent_control (
    request_id VARCHAR(64) PRIMARY KEY COMMENT '请求唯一标识',
    flow_id BIGINT COMMENT '对应的流水ID',
    status TINYINT DEFAULT 0 COMMENT '状态:0处理中1成功2失败',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expire_time DATETIME NOT NULL COMMENT '过期时间',
    
    INDEX idx_expire (expire_time)
) ENGINE=InnoDB COMMENT='幂等控制表';
```

---

## 3. 🔄 流水状态管理


### 3.1 状态流转设计


**💡 为什么需要状态管理**：
金融交易可能失败、需要重试或人工处理，就像快递有"已发货、运输中、已签收"等状态。

```
流水状态流转图：
    [处理中] ──成功──→ [成功]
       │
       │
    失败─→ [失败] ──重试──→ [处理中]
```

**🔸 状态枚举定义**
```sql
-- 状态字典表
CREATE TABLE flow_status_dict (
    status_code TINYINT PRIMARY KEY,
    status_name VARCHAR(32) NOT NULL,
    description VARCHAR(100),
    can_retry TINYINT DEFAULT 0 COMMENT '是否可重试'
) ENGINE=InnoDB;

INSERT INTO flow_status_dict VALUES 
(0, '处理中', '交易正在处理', 0),
(1, '成功', '交易成功', 0),
(2, '失败', '交易失败', 1),
(3, '超时', '交易超时', 1),
(4, '待审核', '需人工审核', 0);
```

### 3.2 状态变更记录


**🔸 状态变更日志表**
```sql
CREATE TABLE flow_status_log (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    flow_id BIGINT NOT NULL COMMENT '流水ID',
    old_status TINYINT COMMENT '原状态',
    new_status TINYINT NOT NULL COMMENT '新状态',
    reason VARCHAR(200) COMMENT '变更原因',
    operator VARCHAR(64) COMMENT '操作者',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_flow_id (flow_id),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB COMMENT='流水状态变更日志';
```

---

## 4. 🔍 流水查询优化


### 4.1 常见查询场景


**💡 用户最关心什么**：
- 我的账户最近有哪些流水？
- 某笔交易的详细信息？
- 某个时间段的收支统计？

### 4.2 索引优化设计


**🔸 复合索引策略**
```sql
-- 按账户查询流水（最常用）
ALTER TABLE fund_flow ADD INDEX idx_account_time (account_id, create_time DESC);

-- 按业务类型查询
ALTER TABLE fund_flow ADD INDEX idx_biz_account_time (biz_type, account_id, create_time DESC);

-- 按状态查询（运营使用）
ALTER TABLE fund_flow ADD INDEX idx_status_time (status, create_time DESC);

-- 按金额范围查询
ALTER TABLE fund_flow ADD INDEX idx_amount_time (amount, create_time DESC);
```

### 4.3 分页查询优化


**🔸 游标分页实现**
```sql
-- 避免深分页问题的游标查询
SELECT * FROM fund_flow 
WHERE account_id = 123456 
  AND flow_id < 1000000  -- 游标位置
ORDER BY flow_id DESC 
LIMIT 20;
```

**🔸 查询封装示例**
```sql
-- 账户流水查询存储过程
DELIMITER //
CREATE PROCEDURE QueryAccountFlow(
    IN p_account_id BIGINT,
    IN p_start_time DATETIME,
    IN p_end_time DATETIME,
    IN p_flow_type TINYINT,
    IN p_page_size INT DEFAULT 20,
    IN p_cursor_id BIGINT DEFAULT 0
)
BEGIN
    SELECT f.flow_id, f.flow_no, f.amount, f.flow_type,
           f.balance_after, f.create_time, f.status,
           e.remark
    FROM fund_flow f
    LEFT JOIN fund_flow_ext e ON f.flow_id = e.flow_id
    WHERE f.account_id = p_account_id
      AND f.create_time >= p_start_time
      AND f.create_time <= p_end_time
      AND (p_flow_type IS NULL OR f.flow_type = p_flow_type)
      AND (p_cursor_id = 0 OR f.flow_id < p_cursor_id)
    ORDER BY f.flow_id DESC
    LIMIT p_page_size;
END //
DELIMITER ;
```

---

## 5. 🗂️ 流水数据分片策略


### 5.1 为什么需要分片


**💡 通俗理解**：
想象一个图书馆，如果所有书都放在一个书架上，找书会很慢。分片就是按类别分成多个书架，提高查找效率。

### 5.2 水平分片设计


**🔸 按账户ID分片**
```sql
-- 分片规则：account_id % 16
-- 创建16个分片表

CREATE TABLE fund_flow_00 LIKE fund_flow;
CREATE TABLE fund_flow_01 LIKE fund_flow;
-- ... 其他14个表

-- 分片路由函数
DELIMITER //
CREATE FUNCTION GetFlowTable(p_account_id BIGINT) 
RETURNS VARCHAR(32)
DETERMINISTIC
BEGIN
    DECLARE v_suffix VARCHAR(2);
    SET v_suffix = LPAD(p_account_id % 16, 2, '0');
    RETURN CONCAT('fund_flow_', v_suffix);
END //
DELIMITER ;
```

### 5.3 时间维度分片


**🔸 按月份分表**
```sql
-- 按月分表：fund_flow_202501, fund_flow_202502...
CREATE TABLE fund_flow_template (
    flow_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    flow_no VARCHAR(64) UNIQUE NOT NULL,
    -- 其他字段...
) ENGINE=InnoDB;

-- 自动创建月表的存储过程
DELIMITER //
CREATE PROCEDURE CreateMonthlyTable(IN p_month VARCHAR(6))
BEGIN
    SET @sql = CONCAT('CREATE TABLE IF NOT EXISTS fund_flow_', p_month, 
                     ' LIKE fund_flow_template');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END //
DELIMITER ;
```

---

## 6. 📋 流水审计要求


### 6.1 审计日志设计


**💡 什么是审计**：
就像监控摄像头一样，记录所有对流水数据的操作，确保数据安全和可追溯。

**🔸 审计日志表**
```sql
CREATE TABLE fund_flow_audit (
    audit_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    flow_id BIGINT NOT NULL COMMENT '流水ID',
    operation VARCHAR(32) NOT NULL COMMENT '操作类型:INSERT/UPDATE/DELETE',
    old_data JSON COMMENT '变更前数据',
    new_data JSON COMMENT '变更后数据',
    operator VARCHAR(64) NOT NULL COMMENT '操作者',
    ip_address VARCHAR(45) COMMENT 'IP地址',
    user_agent VARCHAR(500) COMMENT '客户端信息',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_flow_id (flow_id),
    INDEX idx_operator_time (operator, create_time),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB COMMENT='流水审计日志';
```

### 6.2 触发器自动审计


**🔸 审计触发器**
```sql
-- 流水更新审计触发器
DELIMITER //
CREATE TRIGGER fund_flow_update_audit
AFTER UPDATE ON fund_flow
FOR EACH ROW
BEGIN
    INSERT INTO fund_flow_audit (
        flow_id, operation, old_data, new_data, 
        operator, create_time
    ) VALUES (
        NEW.flow_id, 'UPDATE',
        JSON_OBJECT('status', OLD.status, 'amount', OLD.amount),
        JSON_OBJECT('status', NEW.status, 'amount', NEW.amount),
        USER(), NOW()
    );
END //
DELIMITER ;
```

---

## 7. ⚡ 流水性能设计


### 7.1 读写分离架构


**💡 读写分离的好处**：
就像银行柜台，一个窗口专门办理存取款（写），另一个窗口专门查询余额（读），提高整体效率。

```
架构示意图：
应用层
  ├── 写操作 ──→ 主库（Master）
  └── 读操作 ──→ 从库（Slave1, Slave2）
```

### 7.2 缓存策略设计


**🔸 热点数据缓存**
```sql
-- 账户最新流水缓存设计
-- Redis Key: account_flow:{account_id}
-- Value: 最近20条流水的JSON数组

-- 流水写入时更新缓存
DELIMITER //
CREATE PROCEDURE InsertFlowWithCache(
    IN p_account_id BIGINT,
    IN p_amount DECIMAL(18,2),
    IN p_flow_type TINYINT,
    IN p_remark VARCHAR(500)
)
BEGIN
    DECLARE v_flow_id BIGINT;
    DECLARE v_flow_no VARCHAR(64);
    
    START TRANSACTION;
    
    -- 生成流水号
    CALL GetFlowNo('TXN', v_flow_no);
    
    -- 插入流水
    INSERT INTO fund_flow (flow_no, account_id, amount, flow_type, status)
    VALUES (v_flow_no, p_account_id, p_amount, p_flow_type, 1);
    
    SET v_flow_id = LAST_INSERT_ID();
    
    -- 插入扩展信息
    INSERT INTO fund_flow_ext (flow_id, remark)
    VALUES (v_flow_id, p_remark);
    
    COMMIT;
    
    -- 通知应用层更新缓存
    SELECT v_flow_id as flow_id, v_flow_no as flow_no;
END //
DELIMITER ;
```

### 7.3 批量处理优化


**🔸 批量插入优化**
```sql
-- 批量插入流水（用于对账等场景）
INSERT INTO fund_flow (flow_no, account_id, amount, flow_type, status) VALUES
('TXN20250115000001', 123456, 100.00, 1, 1),
('TXN20250115000002', 123457, 200.00, 1, 1),
('TXN20250115000003', 123458, 300.00, 1, 1)
ON DUPLICATE KEY UPDATE 
    amount = VALUES(amount),
    update_time = CURRENT_TIMESTAMP;
```

---

## 8. 🗜️ 流水数据压缩与归档


### 8.1 历史数据压缩策略


**💡 为什么要压缩**：
就像整理衣柜，把不常用的冬装压缩打包存放，节省空间但需要时还能取出来。

**🔸 压缩规则设计**
```sql
-- 历史流水归档表
CREATE TABLE fund_flow_archive (
    archive_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    account_id BIGINT NOT NULL,
    month VARCHAR(7) NOT NULL COMMENT '归档月份:2025-01',
    flow_count INT NOT NULL COMMENT '流水笔数',
    total_income DECIMAL(18,2) DEFAULT 0 COMMENT '总收入',
    total_expense DECIMAL(18,2) DEFAULT 0 COMMENT '总支出',
    compressed_data LONGBLOB COMMENT '压缩后的流水详情',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_account_month (account_id, month),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB COMMENT='流水归档表';
```

**🔸 归档存储过程**
```sql
DELIMITER //
CREATE PROCEDURE ArchiveFlowData(IN p_archive_month VARCHAR(7))
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_account_id BIGINT;
    DECLARE v_flow_data LONGTEXT;
    
    -- 游标定义
    DECLARE account_cursor CURSOR FOR
        SELECT account_id FROM fund_flow 
        WHERE DATE_FORMAT(create_time, '%Y-%m') = p_archive_month
        GROUP BY account_id;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    START TRANSACTION;
    
    OPEN account_cursor;
    read_loop: LOOP
        FETCH account_cursor INTO v_account_id;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 获取账户当月流水数据
        SELECT JSON_ARRAYAGG(
            JSON_OBJECT(
                'flow_no', flow_no,
                'amount', amount,
                'flow_type', flow_type,
                'create_time', create_time
            )
        ) INTO v_flow_data
        FROM fund_flow 
        WHERE account_id = v_account_id 
          AND DATE_FORMAT(create_time, '%Y-%m') = p_archive_month;
        
        -- 插入归档数据
        INSERT INTO fund_flow_archive (
            account_id, month, compressed_data
        ) VALUES (
            v_account_id, p_archive_month, COMPRESS(v_flow_data)
        );
        
    END LOOP;
    
    CLOSE account_cursor;
    COMMIT;
END //
DELIMITER ;
```

---

## 9. 📊 流水实时分析与监控


### 9.1 异常检测设计


**💡 什么是异常检测**：
就像银行会监控你的消费习惯，如果突然出现大额异常交易会及时提醒。

**🔸 异常规则表**
```sql
CREATE TABLE flow_anomaly_rules (
    rule_id INT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(64) NOT NULL,
    rule_type VARCHAR(32) NOT NULL COMMENT '规则类型:AMOUNT/FREQUENCY/PATTERN',
    threshold_value DECIMAL(18,2) COMMENT '阈值',
    time_window INT COMMENT '时间窗口(秒)',
    status TINYINT DEFAULT 1 COMMENT '状态:1启用0停用',
    
    INDEX idx_rule_type (rule_type)
) ENGINE=InnoDB;

-- 初始化异常规则
INSERT INTO flow_anomaly_rules VALUES
(1, '单笔大额交易', 'AMOUNT', 50000.00, 0, 1),
(2, '高频交易', 'FREQUENCY', 10, 300, 1),
(3, '异常时间交易', 'PATTERN', 0, 0, 1);
```

### 9.2 实时统计监控


**🔸 实时统计视图**
```sql
-- 账户今日流水统计视图
CREATE VIEW v_account_daily_summary AS
SELECT 
    account_id,
    DATE(create_time) as stat_date,
    SUM(CASE WHEN flow_type = 1 THEN amount ELSE 0 END) as income,
    SUM(CASE WHEN flow_type = 2 THEN amount ELSE 0 END) as expense,
    COUNT(*) as flow_count,
    MAX(amount) as max_amount,
    AVG(amount) as avg_amount
FROM fund_flow 
WHERE create_time >= CURDATE()
GROUP BY account_id, DATE(create_time);
```

### 9.3 数据挖掘分析


**🔸 交易模式分析**
```sql
-- 用户消费模式分析
SELECT 
    account_id,
    HOUR(create_time) as hour_of_day,
    COUNT(*) as transaction_count,
    AVG(amount) as avg_amount,
    -- 计算该时间段交易占比
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(PARTITION BY account_id) as percentage
FROM fund_flow
WHERE flow_type = 2 -- 支出
  AND create_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY account_id, HOUR(create_time)
HAVING transaction_count >= 5
ORDER BY account_id, hour_of_day;
```

---

## 10. 🔒 流水安全与权限控制


### 10.1 数据脱敏设计


**💡 什么是数据脱敏**：
就像给敏感信息打马赛克，保护用户隐私的同时还能进行业务分析。

**🔸 脱敏函数设计**
```sql
-- 金额脱敏函数
DELIMITER //
CREATE FUNCTION MaskAmount(p_amount DECIMAL(18,2), p_user_role VARCHAR(32))
RETURNS VARCHAR(32)
DETERMINISTIC
BEGIN
    IF p_user_role IN ('ADMIN', 'AUDITOR') THEN
        RETURN CAST(p_amount AS CHAR);
    ELSEIF p_user_role = 'OPERATOR' THEN
        RETURN CONCAT(LEFT(CAST(p_amount AS CHAR), 2), '****');
    ELSE
        RETURN '****';
    END IF;
END //
DELIMITER ;

-- 脱敏查询视图
CREATE VIEW v_fund_flow_masked AS
SELECT 
    flow_id,
    flow_no,
    account_id,
    MaskAmount(amount, @user_role) as amount,
    flow_type,
    create_time
FROM fund_flow;
```

### 10.2 访问权限控制


**🔸 权限控制表**
```sql
CREATE TABLE flow_access_control (
    control_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    account_id BIGINT NOT NULL,
    access_type VARCHAR(32) NOT NULL COMMENT '权限类型:READ/WRITE/ADMIN',
    grant_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expire_time DATETIME COMMENT '过期时间',
    
    UNIQUE KEY uk_user_account_type (user_id, account_id, access_type),
    INDEX idx_user_id (user_id),
    INDEX idx_account_id (account_id)
) ENGINE=InnoDB;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 资金流水：记录每笔资金变动的明细，是金融系统的核心数据
🔸 流水唯一性：通过全局唯一的流水号保证数据一致性
🔸 状态管理：支持流水的生命周期管理和异常处理
🔸 查询优化：通过合理的索引和分片提升查询性能
🔸 审计要求：完整记录数据变更历史，确保合规性
🔸 安全控制：数据脱敏和权限控制保护敏感信息
```

### 11.2 关键设计原则


**🔹 数据设计原则**
```
主表轻量化：
• 核心字段保持简洁，提升查询效率
• 扩展信息单独存储，按需关联

唯一性保障：
• 流水号全局唯一，防止重复记录
• 幂等控制表防止重复提交

状态可追踪：
• 状态变更完整记录
• 支持异常处理和重试机制
```

**🔹 性能优化原则**
```
索引设计：
• 按查询场景设计复合索引
• 避免过多索引影响写入性能

分片策略：
• 按账户ID水平分片分散压力
• 按时间维度归档历史数据

缓存应用：
• 热点数据缓存提升响应速度
• 读写分离减少主库压力
```

### 11.3 实际应用价值


**🎯 业务场景应用**
- **银行系统**：存取款、转账、理财流水记录
- **支付平台**：充值、消费、提现流水管理  
- **电商平台**：订单支付、退款、佣金流水
- **金融机构**：投资交易、利息计算、风控分析

**🔧 技术实践价值**
- **数据一致性**：通过流水保证资金数据准确性
- **性能优化**：合理的分片和索引设计提升系统性能
- **审计合规**：完整的审计日志满足金融监管要求
- **风险控制**：实时监控和异常检测降低风险

### 11.4 核心记忆要点


**💡 设计要点记忆**
```
┌─ 流水设计核心 ────────────────┐
│ 唯一标识：流水号全局唯一      │
│ 状态管理：支持异常处理        │
│ 索引优化：按查询场景设计      │
│ 分片策略：账户+时间双维度     │
│ 审计合规：操作全程可追踪      │
│ 安全防护：脱敏+权限双保险     │
└──────────────────────────────┘
```

**🔑 一句话总结**：流水设计要保证数据准确、查询高效、审计完整、安全可控

**📌 面试重点**：
- 如何保证流水号唯一性？
- 大数据量下的查询优化方案？
- 流水状态管理的最佳实践？
- 分片策略的选择依据？

**核心记忆口诀**：
- 流水设计很重要，唯一状态不能少
- 索引分片提性能，审计安全要做好
- 压缩归档节空间，监控分析价值高