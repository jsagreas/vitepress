---
title: 5、支付系统设计
---
## 📚 目录

1. [支付系统概述](#1-支付系统概述)
2. [支付流水表设计](#2-支付流水表设计)
3. [支付渠道抽象](#3-支付渠道抽象)
4. [支付状态管理](#4-支付状态管理)
5. [异步通知处理](#5-异步通知处理)
6. [支付对账机制](#6-支付对账机制)
7. [退款流程设计](#7-退款流程设计)
8. [支付安全控制](#8-支付安全控制)
9. [高级特性设计](#9-高级特性设计)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 💰 支付系统概述


### 1.1 什么是支付系统


**🔸 支付系统定义**
支付系统是电商平台的核心组件，负责处理用户的付款行为。简单说，就是用户下单后，把钱从用户账户转移到商家账户的整个过程。

```
用户买商品的完整流程：
用户下单 → 选择支付方式 → 输入支付信息 → 支付系统处理 → 扣款成功 → 订单完成

就像现实中在商店买东西：
选商品 → 去收银台 → 掏钱/刷卡 → 收银员收款 → 拿走商品
```

### 1.2 支付系统核心职责


**🎯 主要功能**
- **收款处理**：接收用户的支付请求，调用银行或第三方支付
- **状态追踪**：记录每笔支付的详细状态和变化过程
- **安全防护**：防止重复支付、欺诈交易等安全问题
- **对账结算**：与银行或支付机构进行资金对账
- **异常处理**：处理支付失败、超时、异常等情况

### 1.3 支付系统架构概览


```
支付系统整体架构：

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   订单系统   │────│   支付系统   │────│  第三方支付  │
│             │    │             │    │ (微信/支付宝) │
└─────────────┘    └─────────────┘    └─────────────┘
                          │
                   ┌─────────────┐
                   │   对账系统   │
                   └─────────────┘
```

---

## 2. 📊 支付流水表设计


### 2.1 支付流水表的作用


**💡 为什么需要支付流水表**
支付流水表就像银行的交易记录，记录每一笔支付的详细信息。无论支付成功还是失败，都要有记录，这样才能追查问题和进行对账。

### 2.2 核心支付流水表设计


```sql
-- 支付流水主表
CREATE TABLE payment_transaction (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_no VARCHAR(64) NOT NULL COMMENT '支付流水号(全局唯一)',
    order_id BIGINT NOT NULL COMMENT '关联订单ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    
    -- 金额信息
    amount DECIMAL(10,2) NOT NULL COMMENT '支付金额',
    currency VARCHAR(8) DEFAULT 'CNY' COMMENT '币种',
    
    -- 支付渠道信息
    payment_channel VARCHAR(32) NOT NULL COMMENT '支付渠道(alipay/wechat/union)',
    payment_method VARCHAR(32) NOT NULL COMMENT '支付方式(scan/h5/app)',
    
    -- 状态信息
    status TINYINT NOT NULL DEFAULT 1 COMMENT '支付状态:1待支付,2支付中,3成功,4失败,5取消',
    
    -- 第三方信息
    third_party_no VARCHAR(128) COMMENT '第三方支付单号',
    third_party_response TEXT COMMENT '第三方响应数据',
    
    -- 时间信息
    expire_time DATETIME NOT NULL COMMENT '支付过期时间',
    paid_time DATETIME COMMENT '支付完成时间',
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 索引
    UNIQUE KEY uk_transaction_no (transaction_no),
    KEY idx_order_id (order_id),
    KEY idx_user_id (user_id),
    KEY idx_status_created (status, created_time)
) COMMENT='支付交易流水表';
```

### 2.3 支付状态变更记录表


```sql
-- 支付状态变更日志表
CREATE TABLE payment_status_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_no VARCHAR(64) NOT NULL COMMENT '支付流水号',
    old_status TINYINT COMMENT '原状态',
    new_status TINYINT NOT NULL COMMENT '新状态',
    change_reason VARCHAR(255) COMMENT '状态变更原因',
    operator VARCHAR(64) COMMENT '操作者(system/user/admin)',
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    KEY idx_transaction_no (transaction_no),
    KEY idx_created_time (created_time)
) COMMENT='支付状态变更日志表';
```

**🔸 设计要点说明**
- **transaction_no**：全局唯一的支付流水号，便于追踪
- **金额字段**：使用DECIMAL避免浮点数精度问题
- **状态字段**：用数字表示，便于索引和查询
- **时间字段**：记录关键时间点，便于超时处理和统计

---

## 3. 🔗 支付渠道抽象


### 3.1 支付渠道抽象的必要性


**🤔 为什么要抽象支付渠道**
电商平台通常支持多种支付方式：支付宝、微信支付、银联等。每种支付方式的接口都不同，如果不抽象，代码会很混乱。抽象就是建立统一的接口标准。

```
不抽象的问题：
if (channel == "alipay") {
    // 调用支付宝接口，参数格式A
} else if (channel == "wechat") {
    // 调用微信接口，参数格式B  
} else if (channel == "union") {
    // 调用银联接口，参数格式C
}
// 每增加一种支付方式，都要修改这里

抽象后的好处：
PaymentChannel channel = getChannel(channelType);
channel.pay(paymentRequest); // 统一接口
```

### 3.2 支付渠道配置表


```sql
-- 支付渠道配置表
CREATE TABLE payment_channel_config (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    channel_code VARCHAR(32) NOT NULL COMMENT '渠道编码',
    channel_name VARCHAR(64) NOT NULL COMMENT '渠道名称',
    
    -- 配置信息
    app_id VARCHAR(128) COMMENT '应用ID',
    secret_key VARCHAR(256) COMMENT '密钥(加密存储)',
    gateway_url VARCHAR(255) COMMENT '网关地址',
    notify_url VARCHAR(255) COMMENT '异步通知地址',
    
    -- 功能开关
    is_enabled TINYINT(1) DEFAULT 1 COMMENT '是否启用:0禁用,1启用',
    support_refund TINYINT(1) DEFAULT 1 COMMENT '是否支持退款',
    
    -- 限额配置
    min_amount DECIMAL(10,2) DEFAULT 0.01 COMMENT '最小支付金额',
    max_amount DECIMAL(10,2) DEFAULT 50000.00 COMMENT '最大支付金额',
    day_limit_amount DECIMAL(12,2) COMMENT '日限额',
    
    -- 手续费配置
    fee_rate DECIMAL(6,4) DEFAULT 0.006 COMMENT '手续费率',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_channel_code (channel_code)
) COMMENT='支付渠道配置表';
```

### 3.3 支付渠道接口抽象


**💻 Java接口示例**
```java
// 支付渠道统一接口
public interface PaymentChannel {
    
    /**
     * 创建支付订单
     * @param request 支付请求
     * @return 支付响应(包含支付链接或二维码)
     */
    PaymentResponse createPayment(PaymentRequest request);
    
    /**
     * 查询支付状态
     * @param transactionNo 支付流水号
     * @return 支付状态
     */
    PaymentStatus queryPayment(String transactionNo);
    
    /**
     * 处理异步通知
     * @param notifyData 通知数据
     * @return 处理结果
     */
    NotifyResult handleNotify(String notifyData);
    
    /**
     * 申请退款
     * @param refundRequest 退款请求
     * @return 退款响应
     */
    RefundResponse refund(RefundRequest refundRequest);
}
```

---

## 4. 🔄 支付状态管理


### 4.1 支付状态定义


**📋 支付状态说明**
支付状态就像快递的状态一样，从"待发货"到"已签收"有很多中间状态。支付也是如此：

```
支付状态流转图：

待支付(1) ──用户支付──▶ 支付中(2) ──支付成功──▶ 支付成功(3)
    │                      │
    │                      └──支付失败──▶ 支付失败(4)
    │
    └──用户取消──▶ 支付取消(5)
```

### 4.2 支付状态枚举设计


```sql
-- 支付状态对照表
/*
状态值  状态名称    说明
1      待支付     用户还未付款
2      支付中     正在处理支付
3      支付成功   支付完成
4      支付失败   支付异常
5      支付取消   用户主动取消
*/
```

### 4.3 状态管理核心逻辑


**⚡ 状态变更规则**
```java
public class PaymentStatusManager {
    
    /**
     * 检查状态变更是否合法
     */
    public boolean isValidStatusChange(int oldStatus, int newStatus) {
        // 待支付 → 支付中、取消
        if (oldStatus == 1) {
            return newStatus == 2 || newStatus == 5;
        }
        // 支付中 → 成功、失败
        if (oldStatus == 2) {
            return newStatus == 3 || newStatus == 4;
        }
        // 其他状态不能变更
        return false;
    }
    
    /**
     * 更新支付状态
     */
    public void updateStatus(String transactionNo, int newStatus, String reason) {
        // 1. 查询当前状态
        Payment payment = queryPayment(transactionNo);
        
        // 2. 检查状态变更合法性
        if (!isValidStatusChange(payment.getStatus(), newStatus)) {
            throw new IllegalStatusException("状态变更不合法");
        }
        
        // 3. 更新状态并记录日志
        updatePaymentStatus(transactionNo, newStatus);
        recordStatusLog(transactionNo, payment.getStatus(), newStatus, reason);
    }
}
```

---

## 5. 🔔 异步通知处理


### 5.1 异步通知的原理


**🤔 什么是异步通知**
用户支付后，第三方支付(如支付宝)会主动发送支付结果给我们的系统。这就像快递员送货后发短信通知你一样。

```
异步通知流程：

用户 ──支付──▶ 支付宝 ──扣款成功──▶ 银行
                 │
                 └──发送通知──▶ 我们的系统

时间差：支付宝处理需要几秒钟，所以是"异步"的
```

### 5.2 异步通知表设计


```sql
-- 支付异步通知记录表
CREATE TABLE payment_notify_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_no VARCHAR(64) NOT NULL COMMENT '支付流水号',
    channel VARCHAR(32) NOT NULL COMMENT '支付渠道',
    
    -- 通知内容
    notify_id VARCHAR(128) COMMENT '通知ID',
    notify_data TEXT NOT NULL COMMENT '通知原始数据',
    notify_time DATETIME COMMENT '通知时间',
    
    -- 处理状态
    process_status TINYINT DEFAULT 1 COMMENT '处理状态:1待处理,2处理成功,3处理失败',
    process_result VARCHAR(500) COMMENT '处理结果',
    retry_count INT DEFAULT 0 COMMENT '重试次数',
    
    -- 验签结果
    verify_result TINYINT COMMENT '验签结果:1成功,0失败',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    KEY idx_transaction_no (transaction_no),
    KEY idx_process_status (process_status),
    KEY idx_created_time (created_time)
) COMMENT='支付异步通知记录表';
```

### 5.3 异步通知处理逻辑


```java
@RestController
public class PaymentNotifyController {
    
    /**
     * 接收支付宝异步通知
     */
    @PostMapping("/notify/alipay")
    public String handleAlipayNotify(@RequestBody String notifyData) {
        try {
            // 1. 记录通知日志
            logNotify(notifyData, "alipay");
            
            // 2. 验证签名(防止恶意请求)
            if (!verifySignature(notifyData, "alipay")) {
                return "FAIL"; // 验签失败
            }
            
            // 3. 解析通知数据
            NotifyResult result = parseNotifyData(notifyData, "alipay");
            
            // 4. 更新支付状态
            updatePaymentStatus(result.getTransactionNo(), result.getStatus());
            
            // 5. 返回成功(告诉支付宝不用再通知了)
            return "SUCCESS";
            
        } catch (Exception e) {
            // 返回失败，支付宝会重复通知
            return "FAIL";
        }
    }
}
```

**🔸 异步通知关键点**
- **幂等处理**：同一笔支付可能收到多次通知，要防止重复处理
- **验签机制**：验证通知确实来自支付宝，防止恶意攻击
- **失败重试**：如果处理失败，支付宝会重复发送通知

---

## 6. ⚖️ 支付对账机制


### 6.1 对账的重要性


**💰 为什么要对账**
对账就是核对我们系统的记录和银行/支付机构的记录是否一致。就像你每月核对银行卡账单一样，防止出现资金差异。

```
对账发现的问题：
- 我们记录用户支付成功，但银行说没收到钱
- 银行说收到钱了，但我们系统没更新状态
- 金额不一致等问题
```

### 6.2 对账数据表设计


```sql
-- 对账批次表
CREATE TABLE reconcile_batch (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    batch_no VARCHAR(64) NOT NULL COMMENT '批次号',
    channel VARCHAR(32) NOT NULL COMMENT '对账渠道',
    reconcile_date DATE NOT NULL COMMENT '对账日期',
    
    -- 统计信息
    total_count INT DEFAULT 0 COMMENT '总交易笔数',
    success_count INT DEFAULT 0 COMMENT '成功交易笔数',
    total_amount DECIMAL(12,2) DEFAULT 0 COMMENT '总交易金额',
    
    -- 对账结果
    status TINYINT DEFAULT 1 COMMENT '对账状态:1对账中,2对账成功,3有差异',
    diff_count INT DEFAULT 0 COMMENT '差异笔数',
    
    file_path VARCHAR(255) COMMENT '对账文件路径',
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_batch_no (batch_no),
    KEY idx_channel_date (channel, reconcile_date)
) COMMENT='对账批次表';

-- 对账差异表
CREATE TABLE reconcile_diff (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    batch_no VARCHAR(64) NOT NULL COMMENT '批次号',
    transaction_no VARCHAR(64) NOT NULL COMMENT '交易流水号',
    
    diff_type TINYINT NOT NULL COMMENT '差异类型:1金额差异,2状态差异,3我方多账,4对方多账',
    
    -- 我方记录
    our_amount DECIMAL(10,2) COMMENT '我方金额',
    our_status TINYINT COMMENT '我方状态',
    
    -- 对方记录  
    their_amount DECIMAL(10,2) COMMENT '对方金额',
    their_status TINYINT COMMENT '对方状态',
    
    -- 处理状态
    handle_status TINYINT DEFAULT 1 COMMENT '处理状态:1待处理,2已处理',
    handle_result VARCHAR(500) COMMENT '处理结果',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    KEY idx_batch_no (batch_no),
    KEY idx_transaction_no (transaction_no)
) COMMENT='对账差异表';
```

### 6.3 自动对账流程


```java
@Service
public class ReconcileService {
    
    /**
     * 执行日对账
     */
    @Scheduled(cron = "0 30 1 * * ?") // 每天凌晨1:30执行
    public void dailyReconcile() {
        String yesterday = LocalDate.now().minusDays(1).toString();
        
        // 对每个支付渠道进行对账
        List<String> channels = Arrays.asList("alipay", "wechat", "union");
        for (String channel : channels) {
            reconcileChannel(channel, yesterday);
        }
    }
    
    private void reconcileChannel(String channel, String date) {
        // 1. 下载对账文件
        String filePath = downloadReconcileFile(channel, date);
        
        // 2. 解析对账文件
        List<ReconcileRecord> theirRecords = parseReconcileFile(filePath);
        
        // 3. 查询我方记录
        List<PaymentRecord> ourRecords = queryOurRecords(channel, date);
        
        // 4. 对比记录，找出差异
        List<ReconcileDiff> diffs = compareRecords(ourRecords, theirRecords);
        
        // 5. 保存对账结果
        saveReconcileResult(channel, date, diffs);
        
        // 6. 发送对账报告
        sendReconcileReport(channel, date, diffs);
    }
}
```

---

## 7. 💸 退款流程设计


### 7.1 退款业务场景


**🔄 退款的常见场景**
- **用户主动退款**：不喜欢商品，申请退款
- **商家拒绝发货**：库存不足，主动退款
- **系统异常退款**：重复支付等异常情况

### 7.2 退款表设计


```sql
-- 退款申请表
CREATE TABLE refund_request (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    refund_no VARCHAR(64) NOT NULL COMMENT '退款单号',
    transaction_no VARCHAR(64) NOT NULL COMMENT '原支付流水号',
    order_id BIGINT NOT NULL COMMENT '订单ID',
    
    -- 退款信息
    refund_amount DECIMAL(10,2) NOT NULL COMMENT '退款金额',
    refund_reason VARCHAR(255) COMMENT '退款原因',
    refund_type TINYINT NOT NULL COMMENT '退款类型:1用户申请,2商家主动,3系统异常',
    
    -- 状态信息
    status TINYINT NOT NULL DEFAULT 1 COMMENT '退款状态:1待处理,2退款中,3退款成功,4退款失败',
    
    -- 第三方信息
    third_party_refund_no VARCHAR(128) COMMENT '第三方退款单号',
    
    -- 时间信息
    apply_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '申请时间',
    process_time DATETIME COMMENT '处理时间',
    success_time DATETIME COMMENT '退款成功时间',
    
    -- 操作人信息
    applicant_id BIGINT COMMENT '申请人ID',
    processor_id BIGINT COMMENT '处理人ID',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_refund_no (refund_no),
    KEY idx_transaction_no (transaction_no),
    KEY idx_order_id (order_id),
    KEY idx_status_created (status, created_time)
) COMMENT='退款申请表';
```

### 7.3 退款处理逻辑


```java
@Service
public class RefundService {
    
    /**
     * 申请退款
     */
    public RefundResult applyRefund(RefundRequest request) {
        // 1. 校验退款条件
        validateRefundCondition(request);
        
        // 2. 创建退款单
        String refundNo = generateRefundNo();
        saveRefundRequest(refundNo, request);
        
        // 3. 调用第三方退款接口
        ThirdPartyRefundResult result = callThirdPartyRefund(request);
        
        // 4. 更新退款状态
        if (result.isSuccess()) {
            updateRefundStatus(refundNo, RefundStatus.PROCESSING);
        } else {
            updateRefundStatus(refundNo, RefundStatus.FAILED);
        }
        
        return new RefundResult(refundNo, result.isSuccess());
    }
    
    /**
     * 校验退款条件
     */
    private void validateRefundCondition(RefundRequest request) {
        // 检查原支付是否存在且成功
        Payment payment = queryPayment(request.getTransactionNo());
        if (payment == null || payment.getStatus() != PaymentStatus.SUCCESS) {
            throw new RefundException("原支付不存在或未成功");
        }
        
        // 检查退款金额是否超过原支付金额
        if (request.getRefundAmount().compareTo(payment.getAmount()) > 0) {
            throw new RefundException("退款金额不能超过原支付金额");
        }
        
        // 检查是否已经退款
        if (hasRefunded(request.getTransactionNo())) {
            throw new RefundException("该支付已经退款");
        }
    }
}
```

---

## 8. 🔒 支付安全控制


### 8.1 支付安全威胁


**⚠️ 常见安全问题**
- **重复支付**：用户点击多次支付按钮
- **金额篡改**：恶意修改支付金额
- **恶意通知**：伪造支付成功通知
- **信息泄露**：支付信息被窃取

### 8.2 幂等性控制


**🔒 防重复支付机制**
```java
@Service
public class PaymentIdempotentService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * 创建支付时的幂等性检查
     */
    public boolean checkIdempotent(Long orderId, Long userId) {
        String key = "payment:idempotent:" + orderId + ":" + userId;
        
        // 尝试设置锁，过期时间30分钟
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(key, "1", Duration.ofMinutes(30));
            
        if (!success) {
            throw new DuplicatePaymentException("重复支付请求");
        }
        
        return true;
    }
    
    /**
     * 支付完成后释放锁
     */
    public void releaseIdempotent(Long orderId, Long userId) {
        String key = "payment:idempotent:" + orderId + ":" + userId;
        redisTemplate.delete(key);
    }
}
```

### 8.3 数据加密存储


```sql
-- 敏感数据加密存储示例
CREATE TABLE payment_sensitive_data (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_no VARCHAR(64) NOT NULL,
    
    -- 加密存储的敏感信息
    encrypted_card_no VARCHAR(512) COMMENT '加密后的卡号',
    encrypted_phone VARCHAR(256) COMMENT '加密后的手机号',
    encrypted_id_card VARCHAR(512) COMMENT '加密后的身份证号',
    
    -- 加密相关信息
    encrypt_version VARCHAR(16) NOT NULL DEFAULT 'AES256' COMMENT '加密版本',
    key_id VARCHAR(64) NOT NULL COMMENT '密钥ID',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_transaction_no (transaction_no)
) COMMENT='支付敏感数据表';
```

### 8.4 风控规则配置


```sql
-- 支付风控规则表
CREATE TABLE payment_risk_rule (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(128) NOT NULL COMMENT '规则名称',
    rule_type TINYINT NOT NULL COMMENT '规则类型:1金额限制,2频次限制,3异常IP',
    
    -- 规则条件
    rule_condition JSON COMMENT '规则条件配置',
    -- 示例: {"max_amount":10000,"time_window":3600,"max_count":5}
    
    -- 规则动作
    action_type TINYINT NOT NULL COMMENT '触发动作:1拒绝,2人工审核,3延迟处理',
    
    -- 开关和权重
    is_enabled TINYINT(1) DEFAULT 1 COMMENT '是否启用',
    priority INT DEFAULT 0 COMMENT '优先级',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT='支付风控规则表';
```

---

## 9. 🚀 高级特性设计


### 9.1 智能支付路由


**🧠 支付路由的作用**
智能路由就是根据不同条件选择最合适的支付渠道。比如：
- **小额支付**选择手续费低的渠道
- **大额支付**选择稳定性好的渠道  
- **某渠道故障**时自动切换到备用渠道

```sql
-- 支付路由规则表
CREATE TABLE payment_route_rule (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(128) NOT NULL COMMENT '路由规则名称',
    
    -- 匹配条件
    min_amount DECIMAL(10,2) COMMENT '最小金额',
    max_amount DECIMAL(10,2) COMMENT '最大金额',
    user_level VARCHAR(32) COMMENT '用户等级',
    time_range VARCHAR(64) COMMENT '时间范围',
    
    -- 路由结果
    primary_channel VARCHAR(32) NOT NULL COMMENT '主渠道',
    backup_channels VARCHAR(255) COMMENT '备用渠道(逗号分隔)',
    
    -- 权重和开关
    weight INT DEFAULT 100 COMMENT '权重(越大优先级越高)',
    is_enabled TINYINT(1) DEFAULT 1 COMMENT '是否启用',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) COMMENT='支付路由规则表';
```

### 9.2 支付失败重试机制


```java
@Component
public class PaymentRetryHandler {
    
    /**
     * 支付重试策略
     */
    public void retryPayment(String transactionNo) {
        Payment payment = queryPayment(transactionNo);
        
        // 获取重试配置
        RetryConfig config = getRetryConfig(payment.getChannel());
        
        for (int i = 0; i < config.getMaxRetry(); i++) {
            try {
                // 重试支付
                PaymentResult result = doPayment(payment);
                if (result.isSuccess()) {
                    break; // 成功则停止重试
                }
            } catch (Exception e) {
                // 记录重试失败日志
                logRetryFailed(transactionNo, i + 1, e.getMessage());
            }
            
            // 等待一段时间再重试(指数退避)
            waitForRetry(config.getBaseDelay() * Math.pow(2, i));
        }
    }
}
```

### 9.3 多币种汇率处理


```sql
-- 汇率表
CREATE TABLE exchange_rate (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    from_currency VARCHAR(8) NOT NULL COMMENT '源币种',
    to_currency VARCHAR(8) NOT NULL COMMENT '目标币种',
    rate DECIMAL(12,6) NOT NULL COMMENT '汇率',
    
    -- 数据源信息
    rate_source VARCHAR(32) NOT NULL COMMENT '汇率来源',
    effective_time DATETIME NOT NULL COMMENT '生效时间',
    expire_time DATETIME COMMENT '失效时间',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_currency_time (from_currency, to_currency, effective_time),
    KEY idx_effective_time (effective_time)
) COMMENT='汇率表';
```

### 9.4 支付成功率监控


```sql
-- 支付成功率统计表
CREATE TABLE payment_success_stats (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    stat_date DATE NOT NULL COMMENT '统计日期',
    channel VARCHAR(32) NOT NULL COMMENT '支付渠道',
    
    -- 统计数据
    total_count INT NOT NULL DEFAULT 0 COMMENT '总支付笔数',
    success_count INT NOT NULL DEFAULT 0 COMMENT '成功笔数',
    success_rate DECIMAL(5,4) NOT NULL DEFAULT 0 COMMENT '成功率',
    
    -- 金额统计
    total_amount DECIMAL(15,2) NOT NULL DEFAULT 0 COMMENT '总金额',
    success_amount DECIMAL(15,2) NOT NULL DEFAULT 0 COMMENT '成功金额',
    
    created_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_date_channel (stat_date, channel),
    KEY idx_stat_date (stat_date)
) COMMENT='支付成功率统计表';
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 支付流水：记录每笔支付的完整信息，是支付系统的基础
🔸 渠道抽象：统一不同支付方式的接口，便于扩展和维护
🔸 状态管理：严格控制支付状态流转，保证数据一致性
🔸 异步通知：处理第三方支付的回调通知，更新支付状态
🔸 对账机制：定期核对资金，确保系统和银行数据一致
🔸 安全控制：防重复支付、数据加密、风控拦截等安全措施
```

### 10.2 关键设计原则


**🔹 数据一致性原则**
```
- 支付状态变更要有明确的流转规则
- 重要操作要记录详细日志便于追踪
- 使用事务保证数据的原子性
```

**🔹 系统可用性原则**
```  
- 支付渠道要有备用方案
- 异步通知要有重试机制
- 关键服务要有监控告警
```

**🔹 安全性原则**
```
- 敏感数据要加密存储
- 所有操作要有幂等性控制
- 建立完善的风控规则
```

### 10.3 实际应用建议


**💡 开发建议**
- **支付流水号**：使用全局唯一ID，便于分库分表和问题追踪
- **金额处理**：统一使用DECIMAL类型，避免浮点数精度问题
- **状态机**：明确定义状态流转规则，防止状态混乱
- **异步处理**：支付回调要做好幂等性控制
- **监控告警**：建立完善的支付成功率和异常监控

**🎯 运维建议**  
- **日常对账**：每天自动执行对账，及时发现资金问题
- **性能监控**：关注支付接口响应时间和成功率
- **安全审计**：定期检查支付安全日志，防范风险
- **容灾备份**：重要数据要有多重备份机制

**核心记忆**：
- 支付系统核心是资金安全和数据一致性
- 抽象设计让系统更容易扩展和维护  
- 完善的监控和对账机制是系统稳定运行的保障
- 安全控制要贯穿支付流程的每个环节