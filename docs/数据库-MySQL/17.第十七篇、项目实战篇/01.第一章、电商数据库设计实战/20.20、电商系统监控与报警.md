---
title: 20、电商系统监控与报警
---
## 📚 目录

1. [监控体系概述](#1-监控体系概述)
2. [业务指标监控](#2-业务指标监控)
3. [系统性能监控](#3-系统性能监控)
4. [异常事件告警](#4-异常事件告警)
5. [数据质量检查](#5-数据质量检查)
6. [实时监控大屏](#6-实时监控大屏)
7. [APM应用性能监控](#7-APM应用性能监控)
8. [业务埋点设计](#8-业务埋点设计)
9. [告警优化策略](#9-告警优化策略)
10. [智能异常检测](#10-智能异常检测)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 监控体系概述


### 1.1 什么是电商监控体系


**监控体系**：就像给电商系统装上"体检设备"，时刻关注系统健康状况

```
监控就像医院的体检：
- 定期检查各项指标（血压、心率等）
- 发现异常立即报警
- 预防问题比治疗更重要

电商监控也一样：
- 监控订单量、支付成功率等业务指标
- 监控CPU、内存等系统指标
- 异常时立即通知相关人员
```

### 1.2 监控体系架构


```
┌─────────────────────────────────────────────────┐
│                 监控体系架构                      │
├─────────────────────────────────────────────────┤
│  业务监控层    │  系统监控层    │  基础设施监控层   │
│  - 订单监控    │  - 应用性能    │  - 服务器监控    │
│  - 用户行为    │  - 数据库性能  │  - 网络监控      │
│  - 支付监控    │  - 缓存监控    │  - 存储监控      │
├─────────────────────────────────────────────────┤
│              数据采集与处理层                      │
│  - 日志收集    │  - 指标计算    │  - 数据存储     │
├─────────────────────────────────────────────────┤
│              告警与可视化层                       │
│  - 告警规则    │  - 监控大屏    │  - 报表分析     │
└─────────────────────────────────────────────────┘
```

### 1.3 监控的核心价值


**为什么要做监控？**
- **及早发现问题**：在用户感知前发现系统异常
- **快速定位故障**：缩短故障排查时间
- **数据驱动决策**：基于监控数据优化业务
- **保障用户体验**：确保系统稳定运行

---

## 2. 📊 业务指标监控


### 2.1 核心业务指标


**什么是业务指标？**
业务指标就像商店老板每天关心的数据：今天来了多少客人？卖了多少东西？赚了多少钱？

```sql
-- 核心业务指标监控表
CREATE TABLE business_metrics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    metric_name VARCHAR(100) NOT NULL COMMENT '指标名称',
    metric_value DECIMAL(15,2) NOT NULL COMMENT '指标值',
    metric_time DATETIME NOT NULL COMMENT '统计时间',
    business_date DATE NOT NULL COMMENT '业务日期',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 订单相关指标
INSERT INTO business_metrics VALUES
(1, 'daily_orders', 1250, '2025-09-10 23:59:59', '2025-09-10', NOW()),
(2, 'daily_gmv', 156780.50, '2025-09-10 23:59:59', '2025-09-10', NOW()),
(3, 'conversion_rate', 3.25, '2025-09-10 23:59:59', '2025-09-10', NOW());
```

### 2.2 关键业务监控指标


| 指标类型 | 具体指标 | 监控目的 | 正常范围 |
|---------|----------|----------|----------|
| **📋 订单指标** | 日订单量 | 监控业务规模 | 基于历史数据±20% |
| | 订单转化率 | 监控用户购买意愿 | >2.5% |
| | 平均订单金额 | 监控客单价 | 基于历史数据±15% |
| **💰 支付指标** | 支付成功率 | 监控支付系统健康度 | >98% |
| | 支付响应时间 | 监控支付体验 | <3秒 |
| **👥 用户指标** | 日活跃用户 | 监控用户粘性 | 基于历史数据±10% |
| | 新用户注册量 | 监控用户增长 | >100/天 |

### 2.3 业务监控实现


```sql
-- 实时业务指标计算
CREATE VIEW real_time_business_metrics AS
SELECT 
    DATE(created_at) as business_date,
    COUNT(*) as daily_orders,
    SUM(total_amount) as daily_gmv,
    AVG(total_amount) as avg_order_value,
    COUNT(DISTINCT user_id) as active_users
FROM orders 
WHERE created_at >= CURDATE()
GROUP BY DATE(created_at);

-- 支付成功率监控
CREATE VIEW payment_success_rate AS
SELECT 
    DATE(created_at) as business_date,
    COUNT(*) as total_payments,
    SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) as success_payments,
    ROUND(
        SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 
        2
    ) as success_rate
FROM payments
WHERE created_at >= CURDATE()
GROUP BY DATE(created_at);
```

---

## 3. ⚡ 系统性能监控


### 3.1 系统性能监控概念


**系统性能监控**：就像监控汽车的油耗、发动机转速一样，监控服务器的CPU、内存、数据库等运行状态

### 3.2 核心性能指标


```
服务器监控指标：
┌─────────────┬─────────────┬─────────────┐
│   CPU使用率  │   内存使用率  │   磁盘使用率  │
│    < 80%    │    < 85%    │    < 90%    │
├─────────────┼─────────────┼─────────────┤
│   网络IO     │    磁盘IO    │   负载均衡   │
│   < 80%     │   < 1000    │    < 5.0    │
└─────────────┴─────────────┴─────────────┘

数据库监控指标：
┌─────────────┬─────────────┬─────────────┐
│   查询响应时间│   连接数使用率│   慢查询数量  │
│    < 500ms  │    < 80%    │    < 10/分钟 │
├─────────────┼─────────────┼─────────────┤
│   锁等待时间  │   缓存命中率  │   主从延迟   │
│    < 100ms  │    > 90%    │    < 1秒    │
└─────────────┴─────────────┴─────────────┘
```

### 3.3 性能监控实现


```sql
-- 系统性能监控表
CREATE TABLE system_performance (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    server_name VARCHAR(50) NOT NULL COMMENT '服务器名称',
    metric_type ENUM('CPU', 'MEMORY', 'DISK', 'NETWORK') NOT NULL COMMENT '指标类型',
    metric_value DECIMAL(5,2) NOT NULL COMMENT '指标值(%)',
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '检查时间',
    INDEX idx_server_time (server_name, check_time)
);

-- 数据库性能监控
CREATE TABLE db_performance (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    db_instance VARCHAR(50) NOT NULL COMMENT '数据库实例',
    slow_query_count INT DEFAULT 0 COMMENT '慢查询数量',
    avg_response_time INT DEFAULT 0 COMMENT '平均响应时间(ms)',
    connection_usage DECIMAL(5,2) DEFAULT 0 COMMENT '连接使用率(%)',
    cache_hit_rate DECIMAL(5,2) DEFAULT 0 COMMENT '缓存命中率(%)',
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 4. 🚨 异常事件告警


### 4.1 告警机制概念


**告警系统**：就像烟雾报警器，当检测到"危险"时立即发出警报

```
告警工作流程：
指标采集 → 阈值判断 → 触发告警 → 发送通知 → 人员处理

例如：
CPU使用率 > 80% → 触发告警 → 发送短信/邮件 → 运维人员查看
```

### 4.2 告警等级设计


| 告警等级 | 严重程度 | 响应时间 | 通知方式 | 处理要求 |
|---------|----------|----------|----------|----------|
| 🔴 **P0-致命** | 业务完全中断 | 5分钟内 | 短信+电话+微信 | 立即处理 |
| 🟠 **P1-严重** | 核心功能异常 | 15分钟内 | 短信+微信 | 30分钟内响应 |
| 🟡 **P2-警告** | 性能下降 | 30分钟内 | 微信+邮件 | 2小时内响应 |
| 🟢 **P3-提醒** | 指标异常 | 1小时内 | 邮件 | 工作时间处理 |

### 4.3 告警规则配置


```sql
-- 告警规则配置表
CREATE TABLE alert_rules (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(100) NOT NULL COMMENT '规则名称',
    metric_type VARCHAR(50) NOT NULL COMMENT '指标类型',
    condition_type ENUM('>', '<', '>=', '<=', '=', '!=') NOT NULL COMMENT '条件类型',
    threshold_value DECIMAL(10,2) NOT NULL COMMENT '阈值',
    alert_level ENUM('P0', 'P1', 'P2', 'P3') NOT NULL COMMENT '告警等级',
    notification_channels VARCHAR(200) NOT NULL COMMENT '通知渠道',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例告警规则
INSERT INTO alert_rules VALUES
(1, 'CPU使用率过高', 'CPU_USAGE', '>', 80.00, 'P1', 'sms,wechat', TRUE, NOW()),
(2, '支付成功率过低', 'PAYMENT_SUCCESS_RATE', '<', 95.00, 'P0', 'sms,phone,wechat', TRUE, NOW()),
(3, '订单量异常下降', 'DAILY_ORDERS', '<', 1000.00, 'P2', 'wechat,email', TRUE, NOW());

-- 告警记录表
CREATE TABLE alert_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_id BIGINT NOT NULL COMMENT '规则ID',
    alert_content TEXT NOT NULL COMMENT '告警内容',
    alert_level ENUM('P0', 'P1', 'P2', 'P3') NOT NULL COMMENT '告警等级',
    alert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '告警时间',
    status ENUM('OPEN', 'PROCESSING', 'RESOLVED', 'IGNORED') DEFAULT 'OPEN' COMMENT '处理状态',
    handler VARCHAR(50) COMMENT '处理人',
    resolve_time TIMESTAMP NULL COMMENT '解决时间',
    FOREIGN KEY (rule_id) REFERENCES alert_rules(id)
);
```

---

## 5. 🔍 数据质量检查


### 5.1 数据质量概念


**数据质量**：就像食品安全检查，确保数据的"新鲜度"和"准确性"

```
数据质量的四个维度：
完整性 - 数据是否缺失？
准确性 - 数据是否正确？
一致性 - 不同地方的数据是否一致？
及时性 - 数据是否及时更新？
```

### 5.2 数据质量检查规则


```sql
-- 数据质量检查配置
CREATE TABLE data_quality_rules (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(100) NOT NULL COMMENT '规则名称',
    table_name VARCHAR(50) NOT NULL COMMENT '表名',
    check_type ENUM('COMPLETENESS', 'ACCURACY', 'CONSISTENCY', 'TIMELINESS') NOT NULL COMMENT '检查类型',
    check_sql TEXT NOT NULL COMMENT '检查SQL',
    expected_result VARCHAR(100) NOT NULL COMMENT '期望结果',
    alert_threshold INT DEFAULT 0 COMMENT '告警阈值',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例数据质量规则
INSERT INTO data_quality_rules VALUES
(1, '订单金额完整性检查', 'orders', 'COMPLETENESS', 
 'SELECT COUNT(*) FROM orders WHERE total_amount IS NULL OR total_amount = 0', 
 '0', 0, TRUE, NOW()),

(2, '用户数据一致性检查', 'users', 'CONSISTENCY',
 'SELECT COUNT(*) FROM users u LEFT JOIN user_profiles p ON u.id = p.user_id WHERE p.user_id IS NULL',
 '0', 10, TRUE, NOW()),

(3, '订单状态准确性检查', 'orders', 'ACCURACY',
 'SELECT COUNT(*) FROM orders WHERE status NOT IN ("PENDING", "PAID", "SHIPPED", "COMPLETED", "CANCELLED")',
 '0', 0, TRUE, NOW());

-- 数据质量检查结果
CREATE TABLE data_quality_results (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_id BIGINT NOT NULL COMMENT '规则ID',
    check_result VARCHAR(100) NOT NULL COMMENT '检查结果',
    is_passed BOOLEAN NOT NULL COMMENT '是否通过',
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '检查时间',
    error_detail TEXT COMMENT '错误详情',
    FOREIGN KEY (rule_id) REFERENCES data_quality_rules(id)
);
```

### 5.3 自动化数据质量检查


```sql
-- 创建数据质量检查存储过程
DELIMITER //
CREATE PROCEDURE CheckDataQuality()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE rule_id BIGINT;
    DECLARE check_sql TEXT;
    DECLARE expected_result VARCHAR(100);
    DECLARE actual_result VARCHAR(100);
    DECLARE is_passed BOOLEAN DEFAULT FALSE;
    
    DECLARE rule_cursor CURSOR FOR 
        SELECT id, check_sql, expected_result 
        FROM data_quality_rules 
        WHERE is_active = TRUE;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN rule_cursor;
    
    read_loop: LOOP
        FETCH rule_cursor INTO rule_id, check_sql, expected_result;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 执行检查SQL（这里简化处理）
        SET actual_result = '0'; -- 实际应该执行动态SQL
        SET is_passed = (actual_result = expected_result);
        
        -- 记录检查结果
        INSERT INTO data_quality_results (rule_id, check_result, is_passed, check_time)
        VALUES (rule_id, actual_result, is_passed, NOW());
        
    END LOOP;
    
    CLOSE rule_cursor;
END //
DELIMITER ;
```

---

## 6. 📺 实时监控大屏


### 6.1 监控大屏概念


**监控大屏**：就像机场的航班信息大屏，实时显示关键信息，让人一目了然

```
监控大屏布局设计：
┌─────────────────────────────────────────────────┐
│                 电商监控中心                      │
├──────────────────┬──────────────────────────────┤
│    实时订单数     │         今日GMV            │
│      1,258       │      ¥1,456,780            │
├──────────────────┼──────────────────────────────┤
│   支付成功率      │        系统健康度           │
│     98.5%       │         正常               │
├─────────────────────────────────────────────────┤
│              实时告警信息                        │
│  🟡 数据库连接数过高 (15:30)                     │
│  🟢 Redis缓存命中率正常 (15:25)                  │
└─────────────────────────────────────────────────┘
```

### 6.2 大屏数据准备


```sql
-- 大屏数据汇总表
CREATE TABLE dashboard_metrics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    metric_key VARCHAR(50) NOT NULL COMMENT '指标键',
    metric_name VARCHAR(100) NOT NULL COMMENT '指标名称',
    metric_value VARCHAR(100) NOT NULL COMMENT '指标值',
    metric_unit VARCHAR(20) COMMENT '单位',
    display_order INT DEFAULT 0 COMMENT '显示顺序',
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_metric_key (metric_key)
);

-- 实时更新大屏数据的存储过程
DELIMITER //
CREATE PROCEDURE UpdateDashboardMetrics()
BEGIN
    -- 更新实时订单数
    INSERT INTO dashboard_metrics (metric_key, metric_name, metric_value, metric_unit, display_order)
    VALUES ('real_time_orders', '实时订单数', 
           (SELECT COUNT(*) FROM orders WHERE DATE(created_at) = CURDATE()), 
           '个', 1)
    ON DUPLICATE KEY UPDATE 
        metric_value = VALUES(metric_value),
        update_time = NOW();
    
    -- 更新今日GMV
    INSERT INTO dashboard_metrics (metric_key, metric_name, metric_value, metric_unit, display_order)
    VALUES ('today_gmv', '今日GMV', 
           (SELECT COALESCE(SUM(total_amount), 0) FROM orders WHERE DATE(created_at) = CURDATE()), 
           '元', 2)
    ON DUPLICATE KEY UPDATE 
        metric_value = VALUES(metric_value),
        update_time = NOW();
    
    -- 更新支付成功率
    INSERT INTO dashboard_metrics (metric_key, metric_name, metric_value, metric_unit, display_order)
    VALUES ('payment_success_rate', '支付成功率',
           (SELECT CONCAT(ROUND(
               SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2
           ), '%') FROM payments WHERE DATE(created_at) = CURDATE()),
           '', 3)
    ON DUPLICATE KEY UPDATE 
        metric_value = VALUES(metric_value),
        update_time = NOW();
END //
DELIMITER ;
```

---

## 7. 🔧 APM应用性能监控


### 7.1 APM概念解释


**APM（Application Performance Monitoring）**：应用性能监控，就像给应用装上"健康监测器"

```
APM监控什么？
┌─────────────────────────────────────────────────┐
│                APM监控范围                       │
├─────────────────────────────────────────────────┤
│  响应时间     │  错误率      │  吞吐量          │
│  用户体验     │  资源使用    │  依赖关系        │
│  代码性能     │  数据库查询  │  缓存效率        │
└─────────────────────────────────────────────────┘

就像汽车仪表盘：
- 速度表 = 响应时间
- 油表 = 资源使用情况  
- 故障灯 = 错误率
- 里程表 = 吞吐量
```

### 7.2 APM关键指标


```sql
-- APM性能指标表
CREATE TABLE apm_metrics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    service_name VARCHAR(50) NOT NULL COMMENT '服务名称',
    api_path VARCHAR(200) NOT NULL COMMENT 'API路径',
    response_time INT NOT NULL COMMENT '响应时间(ms)',
    status_code INT NOT NULL COMMENT 'HTTP状态码',
    error_message TEXT COMMENT '错误信息',
    user_id BIGINT COMMENT '用户ID',
    trace_id VARCHAR(100) COMMENT '追踪ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '请求时间',
    INDEX idx_service_time (service_name, created_at),
    INDEX idx_api_time (api_path, created_at)
);

-- APM汇总统计视图
CREATE VIEW apm_summary AS
SELECT 
    service_name,
    api_path,
    COUNT(*) as total_requests,
    AVG(response_time) as avg_response_time,
    MAX(response_time) as max_response_time,
    MIN(response_time) as min_response_time,
    SUM(CASE WHEN status_code >= 500 THEN 1 ELSE 0 END) as server_errors,
    SUM(CASE WHEN status_code >= 400 AND status_code < 500 THEN 1 ELSE 0 END) as client_errors,
    ROUND(
        (COUNT(*) - SUM(CASE WHEN status_code >= 400 THEN 1 ELSE 0 END)) * 100.0 / COUNT(*), 2
    ) as success_rate
FROM apm_metrics 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY service_name, api_path;
```

---

## 8. 📍 业务埋点设计


### 8.1 埋点概念解释


**业务埋点**：就像在关键路口安装摄像头，记录用户的行为轨迹

```
用户购物流程埋点：
首页浏览 → 商品搜索 → 商品详情 → 加入购物车 → 提交订单 → 支付完成
   ↓         ↓         ↓          ↓          ↓          ↓
  埋点1     埋点2     埋点3      埋点4      埋点5      埋点6

每个埋点记录：
- 谁：用户ID
- 什么时候：时间戳  
- 在哪里：页面/功能
- 做了什么：具体行为
- 结果如何：成功/失败
```

### 8.2 埋点数据设计


```sql
-- 用户行为埋点表
CREATE TABLE user_behavior_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT COMMENT '用户ID',
    session_id VARCHAR(100) NOT NULL COMMENT '会话ID',
    event_type VARCHAR(50) NOT NULL COMMENT '事件类型',
    event_name VARCHAR(100) NOT NULL COMMENT '事件名称',
    page_path VARCHAR(200) COMMENT '页面路径',
    element_id VARCHAR(100) COMMENT '元素ID',
    properties JSON COMMENT '事件属性',
    device_info JSON COMMENT '设备信息',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '事件时间',
    INDEX idx_user_time (user_id, created_at),
    INDEX idx_event_time (event_type, created_at),
    INDEX idx_session_time (session_id, created_at)
);

-- 插入埋点数据示例
INSERT INTO user_behavior_logs (user_id, session_id, event_type, event_name, page_path, properties) VALUES
(12345, 'sess_abc123', 'page_view', '商品详情页浏览', '/product/123', '{"product_id": 123, "category": "电子产品"}'),
(12345, 'sess_abc123', 'click', '加入购物车', '/product/123', '{"product_id": 123, "quantity": 2, "price": 299.00}'),
(12345, 'sess_abc123', 'purchase', '订单提交', '/checkout', '{"order_id": 789, "total_amount": 598.00}');
```

### 8.3 埋点分析查询


```sql
-- 用户行为漏斗分析
SELECT 
    '商品浏览' as step_name,
    COUNT(DISTINCT user_id) as user_count,
    1 as step_order
FROM user_behavior_logs 
WHERE event_type = 'page_view' AND page_path LIKE '/product/%'
AND created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)

UNION ALL

SELECT 
    '加入购物车' as step_name,
    COUNT(DISTINCT user_id) as user_count,
    2 as step_order
FROM user_behavior_logs 
WHERE event_name = '加入购物车'
AND created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)

UNION ALL

SELECT 
    '提交订单' as step_name,
    COUNT(DISTINCT user_id) as user_count,
    3 as step_order
FROM user_behavior_logs 
WHERE event_name = '订单提交'
AND created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)

ORDER BY step_order;
```

---

## 9. 🎛️ 告警优化策略


### 9.1 告警收敛策略


**告警收敛**：避免"狼来了"效应，减少无用告警

```
告警收敛的几种方式：
┌─────────────────────────────────────────────────┐
│               告警收敛策略                       │
├─────────────────────────────────────────────────┤
│  时间收敛     │  相同告警5分钟内只发送一次        │
│  数量收敛     │  同类告警达到阈值才发送          │
│  级别收敛     │  低级别告警被高级别告警抑制       │
│  依赖收敛     │  根据系统依赖关系过滤告警        │
└─────────────────────────────────────────────────┘
```

### 9.2 告警收敛配置


```sql
-- 告警收敛规则表
CREATE TABLE alert_suppression_rules (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(100) NOT NULL COMMENT '规则名称',
    suppression_type ENUM('TIME', 'COUNT', 'LEVEL', 'DEPENDENCY') NOT NULL COMMENT '收敛类型',
    source_alert_type VARCHAR(50) NOT NULL COMMENT '源告警类型',
    suppression_window INT NOT NULL COMMENT '收敛窗口(分钟)',
    suppression_threshold INT DEFAULT 1 COMMENT '收敛阈值',
    is_active BOOLEAN DEFAULT TRUE COMMENT '是否启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 示例收敛规则
INSERT INTO alert_suppression_rules VALUES
(1, 'CPU告警时间收敛', 'TIME', 'CPU_HIGH', 5, 1, TRUE, NOW()),
(2, '数据库连接告警数量收敛', 'COUNT', 'DB_CONNECTION_HIGH', 10, 3, TRUE, NOW()),
(3, '服务器宕机抑制其他告警', 'DEPENDENCY', 'SERVER_DOWN', 30, 1, TRUE, NOW());

-- 告警发送记录表
CREATE TABLE alert_sent_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    alert_type VARCHAR(50) NOT NULL COMMENT '告警类型',
    alert_content TEXT NOT NULL COMMENT '告警内容',
    sent_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '发送时间',
    suppression_rule_id BIGINT COMMENT '收敛规则ID',
    is_suppressed BOOLEAN DEFAULT FALSE COMMENT '是否被收敛',
    INDEX idx_type_time (alert_type, sent_time)
);
```

### 9.3 智能降噪算法


```sql
-- 创建告警降噪函数
DELIMITER //
CREATE FUNCTION ShouldSendAlert(
    p_alert_type VARCHAR(50),
    p_current_time TIMESTAMP
) RETURNS BOOLEAN
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_suppression_window INT DEFAULT 0;
    DECLARE v_last_sent_time TIMESTAMP;
    DECLARE v_should_send BOOLEAN DEFAULT TRUE;
    
    -- 获取收敛窗口配置
    SELECT suppression_window INTO v_suppression_window
    FROM alert_suppression_rules 
    WHERE source_alert_type = p_alert_type 
      AND suppression_type = 'TIME' 
      AND is_active = TRUE
    LIMIT 1;
    
    IF v_suppression_window > 0 THEN
        -- 查找最近发送的告警时间
        SELECT sent_time INTO v_last_sent_time
        FROM alert_sent_records 
        WHERE alert_type = p_alert_type 
          AND is_suppressed = FALSE
        ORDER BY sent_time DESC 
        LIMIT 1;
        
        -- 判断是否在收敛窗口内
        IF v_last_sent_time IS NOT NULL AND 
           TIMESTAMPDIFF(MINUTE, v_last_sent_time, p_current_time) < v_suppression_window THEN
            SET v_should_send = FALSE;
        END IF;
    END IF;
    
    RETURN v_should_send;
END //
DELIMITER ;
```

---

## 10. 🤖 智能异常检测


### 10.1 异常检测概念


**智能异常检测**：就像有经验的医生，不仅看单个指标，还会综合分析各种症状

```
传统阈值告警 vs 智能异常检测：

传统方式：
订单量 < 1000 → 告警
问题：节假日、促销期间正常波动也会告警

智能方式：  
基于历史数据学习正常模式
考虑时间因素（工作日/周末/节假日）
识别真正的异常模式
```

### 10.2 异常检测算法实现


```sql
-- 异常检测基线数据表
CREATE TABLE anomaly_baseline (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    metric_name VARCHAR(100) NOT NULL COMMENT '指标名称',
    time_pattern VARCHAR(20) NOT NULL COMMENT '时间模式(hourly/daily/weekly)',
    pattern_key VARCHAR(50) NOT NULL COMMENT '模式键(如:monday_09)',
    avg_value DECIMAL(15,2) NOT NULL COMMENT '平均值',
    std_deviation DECIMAL(15,2) NOT NULL COMMENT '标准差',
    min_value DECIMAL(15,2) NOT NULL COMMENT '最小值',
    max_value DECIMAL(15,2) NOT NULL COMMENT '最大值',
    sample_count INT NOT NULL COMMENT '样本数量',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_metric_pattern (metric_name, time_pattern, pattern_key)
);

-- 异常检测结果表
CREATE TABLE anomaly_detection_results (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    metric_name VARCHAR(100) NOT NULL COMMENT '指标名称',
    current_value DECIMAL(15,2) NOT NULL COMMENT '当前值',
    expected_range_min DECIMAL(15,2) NOT NULL COMMENT '期望范围最小值',
    expected_range_max DECIMAL(15,2) NOT NULL COMMENT '期望范围最大值',
    anomaly_score DECIMAL(5,4) NOT NULL COMMENT '异常分数(0-1)',
    anomaly_type ENUM('HIGH', 'LOW', 'NORMAL') NOT NULL COMMENT '异常类型',
    detection_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '检测时间',
    INDEX idx_metric_time (metric_name, detection_time)
);

-- 异常检测存储过程
DELIMITER //
CREATE PROCEDURE DetectAnomaly(
    IN p_metric_name VARCHAR(100),
    IN p_current_value DECIMAL(15,2),
    IN p_detection_time TIMESTAMP
)
BEGIN
    DECLARE v_pattern_key VARCHAR(50);
    DECLARE v_avg_value DECIMAL(15,2) DEFAULT 0;
    DECLARE v_std_deviation DECIMAL(15,2) DEFAULT 0;
    DECLARE v_range_min DECIMAL(15,2);
    DECLARE v_range_max DECIMAL(15,2);
    DECLARE v_anomaly_score DECIMAL(5,4) DEFAULT 0;
    DECLARE v_anomaly_type VARCHAR(10) DEFAULT 'NORMAL';
    
    -- 生成时间模式键（例如：monday_09 表示周一9点）
    SET v_pattern_key = CONCAT(
        LOWER(DAYNAME(p_detection_time)), '_',
        LPAD(HOUR(p_detection_time), 2, '0')
    );
    
    -- 获取基线数据
    SELECT avg_value, std_deviation INTO v_avg_value, v_std_deviation
    FROM anomaly_baseline
    WHERE metric_name = p_metric_name
      AND time_pattern = 'hourly'
      AND pattern_key = v_pattern_key;
    
    IF v_avg_value > 0 THEN
        -- 计算期望范围（均值 ± 2倍标准差）
        SET v_range_min = v_avg_value - (2 * v_std_deviation);
        SET v_range_max = v_avg_value + (2 * v_std_deviation);
        
        -- 计算异常分数
        IF p_current_value < v_range_min THEN
            SET v_anomaly_score = (v_range_min - p_current_value) / v_std_deviation;
            SET v_anomaly_type = 'LOW';
        ELSEIF p_current_value > v_range_max THEN
            SET v_anomaly_score = (p_current_value - v_range_max) / v_std_deviation;
            SET v_anomaly_type = 'HIGH';
        ELSE
            SET v_anomaly_score = 0;
            SET v_anomaly_type = 'NORMAL';
        END IF;
        
        -- 记录检测结果
        INSERT INTO anomaly_detection_results (
            metric_name, current_value, expected_range_min, expected_range_max,
            anomaly_score, anomaly_type, detection_time
        ) VALUES (
            p_metric_name, p_current_value, v_range_min, v_range_max,
            LEAST(v_anomaly_score, 1.0), v_anomaly_type, p_detection_time
        );
    END IF;
END //
DELIMITER ;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 监控体系：分为业务监控、系统监控、基础设施监控三层
🔸 业务指标：订单量、GMV、转化率等核心业务数据监控  
🔸 告警机制：P0-P3四级告警，不同等级不同响应要求
🔸 数据质量：完整性、准确性、一致性、及时性四个维度
🔸 APM监控：应用性能监控，关注响应时间、错误率、吞吐量
🔸 业务埋点：记录用户行为轨迹，支持数据分析和业务优化
```

### 11.2 关键理解要点


**🔹 监控的本质目的**
```
不是为了监控而监控：
- 监控是手段，保障业务稳定是目的
- 重要的是快速发现和解决问题
- 监控数据要能指导业务决策
```

**🔹 告警设计原则**
```
告警要有价值：
- 能够快速响应的告警才有意义
- 避免告警疲劳，重要告警被忽视
- 告警要有明确的处理流程
```

**🔹 数据驱动的重要性**
```
用数据说话：
- 监控数据要支撑业务决策
- 通过数据发现业务增长机会
- 数据质量直接影响决策质量
```

### 11.3 实际应用价值


- **业务保障**：及时发现业务异常，保障用户体验
- **性能优化**：通过监控数据发现性能瓶颈
- **成本控制**：监控资源使用情况，优化成本
- **业务洞察**：通过用户行为数据发现业务机会
- **风险预警**：提前发现潜在问题，降低业务风险

**核心记忆**：
- 监控体系要全面覆盖，重点突出
- 告警要及时准确，避免噪音干扰  
- 数据质量是监控效果的基础保障
- 智能化是监控系统发展的方向