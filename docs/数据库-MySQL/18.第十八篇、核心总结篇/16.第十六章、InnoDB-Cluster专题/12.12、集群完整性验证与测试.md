---
title: 12、集群完整性验证与测试
---
## 📚 目录

1. [集群状态检查](#1-集群状态检查)
2. [数据一致性验证](#2-数据一致性验证)
3. [故障转移测试](#3-故障转移测试)
4. [读写分离测试](#4-读写分离测试)
5. [性能基准测试](#5-性能基准测试)
6. [连接测试验证](#6-连接测试验证)
7. [日志检查分析](#7-日志检查分析)
8. [集群健康评估](#8-集群健康评估)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 集群状态检查


### 1.1 cluster.status() 基础检查


**什么是cluster.status()**
`cluster.status()`是MySQL Shell中最重要的集群检查命令，就像给集群做"体检"一样，能告诉你集群的整体健康状况。

```javascript
// 连接到MySQL Shell
mysqlsh root@localhost:3306

// 获取集群对象
var cluster = dba.getCluster('myCluster')

// 检查集群状态
cluster.status()
```

**状态输出解读**
```
集群状态信息解读：
┌─────────────────────────────────────┐
│ clusterName: "myCluster"           │ ← 集群名称
│ defaultReplicaSet:                 │ ← 默认副本集
│   ├─ name: "default"               │ ← 副本集名称
│   ├─ primary: "mysql-1:3306"       │ ← 主节点
│   ├─ ssl: "REQUIRED"               │ ← SSL设置
│   ├─ status: "OK"                  │ ← 整体状态
│   └─ topology:                     │ ← 节点拓扑
│       ├─ mysql-1:3306 (PRIMARY)    │ ← 主节点状态
│       ├─ mysql-2:3306 (SECONDARY)  │ ← 从节点状态
│       └─ mysql-3:3306 (SECONDARY)  │ ← 从节点状态
└─────────────────────────────────────┘
```

### 1.2 详细状态检查


**extended选项使用**
```javascript
// 获取详细状态信息
cluster.status({extended: true})

// 获取查询统计信息
cluster.status({queryMembers: true})
```

**关键状态指标含义**
```
状态值含义对照表：
┌──────────────┬─────────────────────────────┐
│ 状态值       │ 含义                        │
├──────────────┼─────────────────────────────┤
│ ONLINE       │ 节点正常运行，可以处理请求   │
│ RECOVERING   │ 节点正在恢复数据            │
│ OFFLINE      │ 节点离线，无法连接          │
│ ERROR        │ 节点出现错误                │
│ UNREACHABLE  │ 节点网络不可达              │
│ MISSING      │ 节点从配置中丢失            │
└──────────────┴─────────────────────────────┘
```

### 1.3 常见问题诊断


**集群状态异常处理**
```javascript
// 检查特定实例状态
cluster.describe()

// 重新扫描集群拓扑
cluster.rescan()

// 强制刷新状态
dba.rebootClusterFromCompleteOutage('myCluster')
```

---

## 2. 📊 数据一致性验证


### 2.1 什么是数据一致性


**数据一致性的含义**
数据一致性就像确保"所有人看到的账本都是一样的"。在MySQL集群中，意味着所有节点上的数据都应该完全相同。

```
数据一致性示意图：
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   主节点     │───▶│   从节点1    │───▶│   从节点2    │
│ user_id: 123 │    │ user_id: 123 │    │ user_id: 123 │
│ name: "张三" │    │ name: "张三" │    │ name: "张三" │
│ age: 25      │    │ age: 25      │    │ age: 25      │
└──────────────┘    └──────────────┘    └──────────────┘
        ↑                   ↑                   ↑
     数据写入          自动同步          自动同步
```

### 2.2 检查数据同步状态


**Group Replication状态检查**
```sql
-- 查看Group Replication状态
SELECT * FROM performance_schema.replication_group_members;

-- 检查同步延迟
SELECT 
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE
FROM performance_schema.replication_group_members;
```

**输出结果示例**
```
检查结果解读：
┌─────────────┬─────────┬──────────┬───────────┐
│ MEMBER_HOST │ PORT    │ STATE    │ ROLE      │
├─────────────┼─────────┼──────────┼───────────┤
│ mysql-1     │ 3306    │ ONLINE   │ PRIMARY   │ ← 主节点正常
│ mysql-2     │ 3306    │ ONLINE   │ SECONDARY │ ← 从节点正常
│ mysql-3     │ 3306    │ ONLINE   │ SECONDARY │ ← 从节点正常
└─────────────┴─────────┴──────────┴───────────┘
```

### 2.3 数据一致性测试脚本


**创建测试数据**
```sql
-- 在主节点创建测试表
CREATE DATABASE consistency_test;
USE consistency_test;

CREATE TABLE test_data (
    id INT AUTO_INCREMENT PRIMARY KEY,
    content VARCHAR(100),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入测试数据
INSERT INTO test_data (content) VALUES 
('Test data 1'),
('Test data 2'),
('Test data 3');
```

**验证数据同步**
```bash
#!/bin/bash
# 数据一致性检查脚本

MYSQL_USER="root"
MYSQL_PASS="password"
NODES=("mysql-1:3306" "mysql-2:3306" "mysql-3:3306")

echo "开始数据一致性检查..."

for node in "${NODES[@]}"; do
    echo "检查节点: $node"
    mysql -h$(echo $node | cut -d: -f1) -P$(echo $node | cut -d: -f2) \
          -u$MYSQL_USER -p$MYSQL_PASS \
          -e "SELECT COUNT(*) as record_count FROM consistency_test.test_data;"
done
```

---

## 3. ⚡ 故障转移测试


### 3.1 故障转移机制理解


**什么是故障转移**
故障转移就像公司的备用经理制度，当主经理出问题时，备用经理自动接管工作，保证业务不中断。

```
故障转移过程示意：
正常状态：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  主节点     │───▶│  从节点1    │───▶│  从节点2    │
│ (处理写入)  │    │ (处理读取)  │    │ (处理读取)  │
└─────────────┘    └─────────────┘    └─────────────┘

主节点故障：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  ❌主节点   │    │ ⭐新主节点  │───▶│  从节点2    │
│  (已失效)   │    │ (自动提升)  │    │ (继续工作)  │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 3.2 模拟主节点故障


**手动停止主节点**
```bash
# 方法1：停止MySQL服务
sudo systemctl stop mysql

# 方法2：模拟网络故障
sudo iptables -A INPUT -p tcp --dport 3306 -j DROP
sudo iptables -A OUTPUT -p tcp --sport 3306 -j DROP

# 方法3：强制杀死进程
sudo kill -9 $(pgrep mysqld)
```

**监控故障转移过程**
```javascript
// 持续监控集群状态
while(true) {
    print(new Date().toISOString());
    cluster.status();
    sleep(5);
}
```

### 3.3 故障转移测试步骤


**完整测试流程**
```
测试步骤时间轴：
T0: 集群正常运行，记录主节点
    ├─ 执行cluster.status()确认状态
    └─ 记录当前PRIMARY节点

T1: 停止主节点服务
    ├─ systemctl stop mysql
    └─ 观察集群反应时间

T2: 监控选举过程 (通常10-30秒)
    ├─ 新主节点选举
    ├─ 节点状态变更
    └─ 连接重新路由

T3: 验证新主节点功能
    ├─ 测试写入操作
    ├─ 测试读取操作
    └─ 检查数据一致性

T4: 恢复原主节点
    ├─ 启动原节点
    ├─ 自动加入集群
    └─ 成为从节点
```

### 3.4 故障转移验证脚本


```bash
#!/bin/bash
# 故障转移测试脚本

ROUTER_HOST="mysql-router"
ROUTER_PORT="6446"

echo "=== 故障转移测试开始 ==="

# 测试写入功能
test_write() {
    local timestamp=$(date +%s)
    mysql -h$ROUTER_HOST -P$ROUTER_PORT -uroot -ppassword \
          -e "INSERT INTO test.failover_test VALUES($timestamp, 'Test during failover');"
    
    if [ $? -eq 0 ]; then
        echo "✅ 写入测试成功: $timestamp"
    else
        echo "❌ 写入测试失败: $timestamp"
    fi
}

# 连续测试
for i in {1..60}; do
    echo "测试轮次: $i"
    test_write
    sleep 2
done
```

---

## 4. 🔄 读写分离测试


### 4.1 读写分离原理


**读写分离的概念**
读写分离就像图书馆的管理方式：借书还书在总台办理（写操作），查阅资料可以在各个阅览室（读操作），这样避免总台拥挤，提高效率。

```
读写分离架构图：
                 ┌─────────────────┐
                 │   MySQL Router  │
                 │   (智能路由)    │
                 └─────────┬───────┘
                          │
                ┌─────────┴─────────┐
                │                   │
        写操作 ↓                   ↓ 读操作
    ┌─────────────┐         ┌─────────────┐
    │  主节点     │────────▶│  从节点     │
    │ (PORT:6446) │  同步   │ (PORT:6447) │
    │ 写入专用     │         │ 读取专用     │
    └─────────────┘         └─────────────┘
```

### 4.2 MySQL Router配置验证


**检查Router配置**
```ini
# /etc/mysqlrouter/mysqlrouter.conf
[routing:primary]
bind_address = 0.0.0.0
bind_port = 6446
destinations = metadata-cache://myCluster/default?role=PRIMARY
routing_strategy = first-available

[routing:secondary] 
bind_address = 0.0.0.0
bind_port = 6447
destinations = metadata-cache://myCluster/default?role=SECONDARY
routing_strategy = round-robin
```

**验证端口监听**
```bash
# 检查Router端口状态
netstat -tlnp | grep mysqlrouter

# 预期输出
tcp  0.0.0.0:6446  LISTEN  mysqlrouter  # 写端口
tcp  0.0.0.0:6447  LISTEN  mysqlrouter  # 读端口
```

### 4.3 读写分离功能测试


**写操作测试**
```sql
-- 连接写端口 (6446)
mysql -h mysql-router -P 6446 -u root -p

-- 创建测试表
CREATE DATABASE rw_test;
USE rw_test;

CREATE TABLE write_test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    operation_type VARCHAR(10),
    node_info VARCHAR(50),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入数据
INSERT INTO write_test (operation_type, node_info) 
VALUES ('WRITE', $$hostname);
```

**读操作测试**
```sql
-- 连接读端口 (6447)
mysql -h mysql-router -P 6447 -u root -p

-- 查询数据，验证能读到刚才写入的数据
SELECT 
    operation_type,
    node_info,
    $$hostname as current_node,
    created_time 
FROM rw_test.write_test;
```

### 4.4 负载均衡验证


**读负载均衡测试脚本**
```bash
#!/bin/bash
# 读负载均衡测试

ROUTER_HOST="mysql-router"
READ_PORT="6447"

echo "=== 读负载均衡测试 ==="

for i in {1..10}; do
    echo "第 $i 次查询："
    mysql -h$ROUTER_HOST -P$READ_PORT -uroot -ppassword \
          -e "SELECT $$hostname as server_name, NOW() as query_time;"
    sleep 1
done
```

**预期结果分析**
```
负载均衡效果验证：
┌────────────┬─────────────────────┐
│ 查询次数   │ 实际处理节点        │
├────────────┼─────────────────────┤
│ 查询 1-3   │ mysql-2            │ ← 轮询到从节点1
│ 查询 4-6   │ mysql-3            │ ← 轮询到从节点2  
│ 查询 7-9   │ mysql-2            │ ← 再次轮询到从节点1
│ 查询 10    │ mysql-3            │ ← 继续轮询
└────────────┴─────────────────────┘

✅ 读请求均匀分布到各从节点
✅ 写请求只路由到主节点
```

---

## 5. 📈 性能基准测试


### 5.1 性能测试工具选择


**mysqlslap 基础压测**
`mysqlslap`是MySQL自带的压力测试工具，就像给数据库做"体能测试"，看它能承受多大的访问压力。

```bash
# 基础读写测试
mysqlslap \
  --host=mysql-router \
  --port=6446 \
  --user=root \
  --password=password \
  --concurrency=50 \
  --iterations=3 \
  --auto-generate-sql \
  --auto-generate-sql-load-type=mixed \
  --auto-generate-sql-add-autoincrement \
  --number-of-queries=1000
```

**参数含义解释**
```
mysqlslap参数说明：
┌─────────────────────┬──────────────────────────┐
│ 参数                │ 含义                     │
├─────────────────────┼──────────────────────────┤
│ --concurrency=50    │ 模拟50个并发用户         │
│ --iterations=3      │ 重复测试3次取平均值      │
│ --auto-generate-sql │ 自动生成测试SQL          │
│ --load-type=mixed   │ 混合读写操作            │
│ --number-of-queries │ 总查询数量              │
└─────────────────────┴──────────────────────────┘
```

### 5.2 集群性能对比测试


**单节点 vs 集群性能**
```bash
#!/bin/bash
# 性能对比测试脚本

echo "=== 集群性能基准测试 ==="

# 测试单主节点性能
echo "1. 测试单主节点 (写)："
mysqlslap \
  --host=mysql-1 \
  --port=3306 \
  --user=root \
  --password=password \
  --concurrency=100 \
  --iterations=3 \
  --auto-generate-sql \
  --auto-generate-sql-load-type=write \
  --number-of-queries=10000

# 测试集群写性能 (通过Router)
echo "2. 测试集群写性能："
mysqlslap \
  --host=mysql-router \
  --port=6446 \
  --user=root \
  --password=password \
  --concurrency=100 \
  --iterations=3 \
  --auto-generate-sql \
  --auto-generate-sql-load-type=write \
  --number-of-queries=10000

# 测试集群读性能 (读写分离)
echo "3. 测试集群读性能："
mysqlslap \
  --host=mysql-router \
  --port=6447 \
  --user=root \
  --password=password \
  --concurrency=100 \
  --iterations=3 \
  --auto-generate-sql \
  --auto-generate-sql-load-type=read \
  --number-of-queries=10000
```

### 5.3 性能指标监控


**关键性能指标**
```sql
-- 查看连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看QPS (每秒查询数)
SHOW STATUS LIKE 'Questions';

-- 查看TPS (每秒事务数)  
SHOW STATUS LIKE 'Com_commit';
SHOW STATUS LIKE 'Com_rollback';

-- 查看缓冲池状态
SHOW STATUS LIKE 'Innodb_buffer_pool%';
```

**性能监控脚本**
```bash
#!/bin/bash
# 实时性能监控

NODES=("mysql-1:3306" "mysql-2:3306" "mysql-3:3306")

while true; do
    echo "=== $(date) ==="
    for node in "${NODES[@]}"; do
        echo "节点: $node"
        mysql -h$(echo $node | cut -d: -f1) -P$(echo $node | cut -d: -f2) \
              -uroot -ppassword \
              -e "SELECT 
                    $$hostname as hostname,
                    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME='Threads_connected') as connections,
                    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME='Questions') as questions;"
    done
    echo "---"
    sleep 10
done
```

---

## 6. 🔌 连接测试验证


### 6.1 连接池配置验证


**什么是连接池**
连接池就像停车场，预先准备好一定数量的"停车位"（数据库连接），应用需要时直接使用，用完归还，避免频繁创建销毁连接的开销。

```
连接池工作原理：
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   应用程序      │    │    连接池        │    │   MySQL集群     │
│                 │    │ ┌──────────────┐ │    │                 │
│ 请求连接 ────────────▶│ │ 连接1 (空闲) │ │────────▶ 主节点     │
│                 │    │ │ 连接2 (使用中)│ │    │                 │
│ 归还连接 ◀──────────│ │ 连接3 (空闲) │ │    │                 │
│                 │    │ │ ...          │ │    │                 │
└─────────────────┘    │ └──────────────┘ │    └─────────────────┘
                       └──────────────────┘
```

**检查连接池状态**
```sql
-- 查看当前连接数
SELECT 
    $$max_connections as max_conn,
    $$max_user_connections as max_user_conn,
    (SELECT count(*) FROM information_schema.processlist) as current_conn;

-- 查看连接详情
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE
FROM information_schema.processlist
WHERE USER != 'system user'
ORDER BY TIME DESC;
```

### 6.2 应用连接测试


**Java连接测试示例**
```java
// 简单的连接测试代码
import java.sql.*;

public class ClusterConnectionTest {
    // 写连接配置
    private static final String WRITE_URL = "jdbc:mysql://mysql-router:6446/test";
    // 读连接配置  
    private static final String READ_URL = "jdbc:mysql://mysql-router:6447/test";
    
    public static void main(String[] args) {
        testWriteConnection();
        testReadConnection();
    }
    
    // 测试写连接
    public static void testWriteConnection() {
        try (Connection conn = DriverManager.getConnection(
                WRITE_URL, "root", "password")) {
            
            Statement stmt = conn.createStatement();
            
            // 插入测试数据
            String insertSQL = "INSERT INTO connection_test (test_type, timestamp) " +
                              "VALUES ('WRITE_TEST', NOW())";
            int result = stmt.executeUpdate(insertSQL);
            
            System.out.println("✅ 写连接测试成功，插入 " + result + " 条记录");
            
        } catch (SQLException e) {
            System.out.println("❌ 写连接测试失败: " + e.getMessage());
        }
    }
    
    // 测试读连接
    public static void testReadConnection() {
        try (Connection conn = DriverManager.getConnection(
                READ_URL, "root", "password")) {
            
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(
                "SELECT COUNT(*) as total FROM connection_test");
            
            if (rs.next()) {
                System.out.println("✅ 读连接测试成功，共 " + 
                                 rs.getInt("total") + " 条记录");
            }
            
        } catch (SQLException e) {
            System.out.println("❌ 读连接测试失败: " + e.getMessage());
        }
    }
}
```

### 6.3 连接故障转移测试


**模拟连接中断**
```bash
#!/bin/bash
# 连接故障转移测试

echo "=== 连接故障转移测试 ==="

# 创建测试脚本
cat > connection_test.py << 'EOF'
import mysql.connector
import time
import threading

def continuous_write_test():
    """持续写入测试"""
    config = {
        'host': 'mysql-router',
        'port': 6446,
        'user': 'root',
        'password': 'password',
        'database': 'test',
        'autocommit': True
    }
    
    counter = 0
    while True:
        try:
            conn = mysql.connector.connect(**config)
            cursor = conn.cursor()
            
            counter += 1
            cursor.execute(
                "INSERT INTO failover_test (id, message) VALUES (%s, %s)",
                (counter, f"Test message {counter}")
            )
            
            print(f"✅ 成功写入记录 {counter}")
            
            conn.close()
            time.sleep(1)
            
        except Exception as e:
            print(f"❌ 写入失败 {counter}: {e}")
            time.sleep(2)

if __name__ == "__main__":
    continuous_write_test()
EOF

# 启动测试
python3 connection_test.py &

# 等待几秒后模拟故障
sleep 10
echo "模拟主节点故障..."
ssh mysql-1 "sudo systemctl stop mysql"

# 继续观察连接恢复情况
wait
```

---

## 7. 📋 日志检查分析


### 7.1 MySQL错误日志分析


**错误日志位置**
```bash
# 查找MySQL错误日志位置
mysql -e "SHOW VARIABLES LIKE 'log_error';"

# 常见位置
/var/log/mysql/error.log          # Ubuntu/Debian
/var/log/mysqld.log              # CentOS/RHEL
/usr/local/mysql/data/mysql.err  # 编译安装
```

**关键日志内容检查**
```bash
# 检查Group Replication相关日志
grep -i "group.replication" /var/log/mysql/error.log | tail -20

# 检查错误和警告
grep -E "(ERROR|WARNING)" /var/log/mysql/error.log | tail -10

# 检查连接问题
grep -i "connection" /var/log/mysql/error.log | tail -10
```

### 7.2 Group Replication状态日志


**重要日志事件识别**
```
关键日志事件类型：
┌─────────────────────┬────────────────────────────┐
│ 日志关键字          │ 含义                       │
├─────────────────────┼────────────────────────────┤
│ Member joined       │ 新成员加入集群             │
│ Member left         │ 成员离开集群               │ 
│ Primary election    │ 主节点选举                 │
│ State changed       │ 节点状态变更               │
│ Recovery completed  │ 数据恢复完成               │
│ Conflict detected   │ 检测到数据冲突             │
└─────────────────────┴────────────────────────────┘
```

**日志分析脚本**
```bash
#!/bin/bash
# MySQL集群日志分析脚本

LOG_FILE="/var/log/mysql/error.log"
echo "=== MySQL InnoDB Cluster 日志分析 ==="

echo "1. 最近的Group Replication事件："
grep -i "group.replication" $LOG_FILE | tail -5

echo -e "\n2. 最近的错误信息："
grep "ERROR" $LOG_FILE | tail -5

echo -e "\n3. 集群成员变动："
grep -E "(Member.*joined|Member.*left)" $LOG_FILE | tail -5

echo -e "\n4. 主节点选举记录："
grep -i "primary.*election" $LOG_FILE | tail -3

echo -e "\n5. 最近的警告信息："
grep "WARNING" $LOG_FILE | tail -5
```

### 7.3 Router日志分析


**MySQL Router日志检查**
```bash
# Router日志位置
/var/log/mysqlrouter/mysqlrouter.log

# 检查路由决策日志
grep -i "routing" /var/log/mysqlrouter/mysqlrouter.log | tail -10

# 检查连接失败日志
grep -i "connection.*failed" /var/log/mysqlrouter/mysqlrouter.log | tail -10

# 检查元数据缓存刷新
grep -i "metadata.*refresh" /var/log/mysqlrouter/mysqlrouter.log | tail -10
```

---

## 8. 🏥 集群健康评估


### 8.1 综合健康评分


**健康评估维度**
```
集群健康评估体系：
┌─────────────────┬──────────┬─────────────────────┐
│ 评估维度        │ 权重     │ 检查项目            │
├─────────────────┼──────────┼─────────────────────┤
│ 节点可用性      │ 30%      │ 所有节点在线状态    │
│ 数据一致性      │ 25%      │ 主从数据同步状态    │
│ 性能指标        │ 20%      │ 响应时间、吞吐量    │
│ 连接状态        │ 15%      │ 连接数、连接成功率  │
│ 资源使用        │ 10%      │ CPU、内存、磁盘     │
└─────────────────┴──────────┴─────────────────────┘
```

### 8.2 自动化健康检查脚本


```bash
#!/bin/bash
# 集群健康自动检查脚本

CLUSTER_NAME="myCluster"
ROUTER_HOST="mysql-router"
NODES=("mysql-1" "mysql-2" "mysql-3")

echo "=== MySQL InnoDB Cluster 健康检查报告 ==="
echo "检查时间: $(date)"
echo "集群名称: $CLUSTER_NAME"
echo ""

# 1. 节点可用性检查
echo "🔍 1. 节点可用性检查"
available_nodes=0
total_nodes=${#NODES[@]}

for node in "${NODES[@]}"; do
    if mysql -h$node -P3306 -uroot -ppassword -e "SELECT 1;" >/dev/null 2>&1; then
        echo "  ✅ $node: 在线"
        ((available_nodes++))
    else
        echo "  ❌ $node: 离线"
    fi
done

availability_score=$((available_nodes * 100 / total_nodes))
echo "  可用性得分: $availability_score% ($available_nodes/$total_nodes)"
echo ""

# 2. 集群状态检查
echo "🔍 2. 集群状态检查"
cluster_status=$(mysqlsh --uri root:password@mysql-1:3306 \
    --sql -e "SELECT 'OK';" 2>/dev/null)

if [[ $cluster_status == *"OK"* ]]; then
    echo "  ✅ 集群连接正常"
    status_score=100
else
    echo "  ❌ 集群连接异常"
    status_score=0
fi
echo ""

# 3. Router连接检查
echo "🔍 3. Router连接检查"
write_test=$(mysql -h$ROUTER_HOST -P6446 -uroot -ppassword \
    -e "SELECT 'WRITE_OK';" 2>/dev/null)
read_test=$(mysql -h$ROUTER_HOST -P6447 -uroot -ppassword \
    -e "SELECT 'READ_OK';" 2>/dev/null)

router_score=0
if [[ $write_test == *"WRITE_OK"* ]]; then
    echo "  ✅ 写端口 (6446) 正常"
    ((router_score+=50))
else
    echo "  ❌ 写端口 (6446) 异常"
fi

if [[ $read_test == *"READ_OK"* ]]; then
    echo "  ✅ 读端口 (6447) 正常"  
    ((router_score+=50))
else
    echo "  ❌ 读端口 (6447) 异常"
fi
echo "  Router得分: $router_score%"
echo ""

# 4. 性能快速检查
echo "🔍 4. 性能快速检查"
response_time=$(timeout 5 mysql -h$ROUTER_HOST -P6446 -uroot -ppassword \
    -e "SELECT BENCHMARK(1000000, MD5('test'));" 2>/dev/null)

if [ $? -eq 0 ]; then
    echo "  ✅ 性能测试完成"
    performance_score=85
else
    echo "  ❌ 性能测试超时"
    performance_score=60
fi
echo "  性能得分: $performance_score%"
echo ""

# 5. 综合评分
echo "📊 综合健康评分"
total_score=$((availability_score * 30 / 100 + status_score * 25 / 100 + router_score * 20 / 100 + performance_score * 25 / 100))

echo "  节点可用性: $availability_score% (权重30%)"
echo "  集群状态:   $status_score% (权重25%)"  
echo "  Router连接: $router_score% (权重20%)"
echo "  性能指标:   $performance_score% (权重25%)"
echo ""
echo "🎯 总体健康得分: $total_score%"

if [ $total_score -ge 90 ]; then
    echo "🟢 集群状态: 优秀"
elif [ $total_score -ge 80 ]; then
    echo "🟡 集群状态: 良好"
elif [ $total_score -ge 70 ]; then
    echo "🟠 集群状态: 一般，建议检查"
else
    echo "🔴 集群状态: 异常，需要立即处理"
fi

echo ""
echo "=== 检查完成 ==="
```

### 8.3 告警规则配置


**关键告警指标**
```
告警级别定义：
┌─────────┬─────────────┬─────────────────────────┐
│ 告警级别│ 触发条件    │ 处理建议                │
├─────────┼─────────────┼─────────────────────────┤
│ 🔴紧急  │ 主节点离线  │ 立即人工介入处理        │
│ 🟠严重  │ >1个节点离线│ 30分钟内处理           │
│ 🟡警告  │ 连接数>80%  │ 2小时内关注            │
│ 🟢信息  │ 性能下降20% │ 日常巡检时处理         │
└─────────┴─────────────┴─────────────────────────┘
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的检查方法


```
🔸 cluster.status()：最重要的集群状态检查命令
🔸 数据一致性：确保所有节点数据同步正确  
🔸 故障转移：测试集群的高可用能力
🔸 读写分离：验证Router的负载均衡功能
🔸 性能基准：了解集群的处理能力上限
🔸 连接测试：确保应用能正常连接使用
🔸 日志分析：通过日志诊断问题根因
🔸 健康评估：建立综合的监控体系
```

### 9.2 关键理解要点


**🔹 检查的系统性思维**
```
完整的检查体系：
状态检查 → 功能验证 → 性能测试 → 故障模拟 → 日志分析

每个环节都不可缺少：
- 状态检查：确认基础运行状态
- 功能验证：确保核心功能正常  
- 性能测试：了解系统能力边界
- 故障模拟：验证高可用机制
- 日志分析：问题诊断和预防
```

**🔹 测试的渐进性原则**
```
测试强度递增：
基础连通性 → 正常功能 → 异常场景 → 极限压力

风险控制：
- 先在测试环境完整验证
- 生产环境从轻到重逐步测试
- 准备好回滚和应急方案
```

### 9.3 实际应用价值


**运维实践指导**：
- **日常巡检**：使用健康检查脚本定期检查
- **故障处理**：通过日志分析快速定位问题
- **性能优化**：基于基准测试数据调优配置
- **容量规划**：根据压测结果规划扩容时机

**最佳实践建议**：
- 建立自动化监控和告警机制
- 定期进行故障转移演练
- 保留详细的测试和运维文档
- 持续优化检查脚本和告警规则

**核心记忆要点**：
- 集群检查要全面系统，不能遗漏关键环节
- 故障转移是高可用的核心，必须定期验证
- 性能基准为容量规划提供数据支撑
- 日志分析是问题诊断的重要手段
- 自动化检查提高运维效率和准确性