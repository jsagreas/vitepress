---
title: 17、InnoDB Cluster 日常运维操作
---
## 📚 目录

1. [集群状态监控](#1-集群状态监控)
2. [节点健康检查](#2-节点健康检查)
3. [性能指标收集](#3-性能指标收集)
4. [日志文件管理](#4-日志文件管理)
5. [备份策略制定](#5-备份策略制定)
6. [维护窗口管理](#6-维护窗口管理)
7. [例行检查清单](#7-例行检查清单)
8. [运维自动化脚本](#8-运维自动化脚本)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 集群状态监控


### 1.1 什么是集群状态监控


**核心概念**：集群状态监控就是时刻关注你的MySQL集群是否正常工作，就像医生给病人量体温、测血压一样。

```
简单理解：
想象你管理一个团队，你需要知道：
- 每个人是否在岗
- 工作是否正常
- 有没有人生病请假
- 团队协作是否顺畅

InnoDB Cluster监控也是一样的道理
```

### 1.2 基本状态检查命令


**🔸 快速查看集群整体状态**
```javascript
// 连接到MySQL Shell
mysqlsh --uri root@主节点IP:3306

// 获取集群对象
var cluster = dba.getCluster('myCluster')

// 查看集群状态 - 最常用的命令
cluster.status()
```

**输出结果解读**：
```json
{
    "clusterName": "myCluster",
    "defaultReplicaSet": {
        "name": "default",
        "primary": "mysql-node1:3306",    // 主节点
        "ssl": "REQUIRED",
        "status": "OK",                   // 整体状态：OK表示正常
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.",
        "topology": {
            "mysql-node1:3306": {
                "address": "mysql-node1:3306",
                "mode": "R/W",            // 读写模式，说明是主节点
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"        // 节点状态正常
            },
            "mysql-node2:3306": {
                "address": "mysql-node2:3306", 
                "mode": "R/O",            // 只读模式，说明是从节点
                "readReplicas": {},
                "role": "HA", 
                "status": "ONLINE"
            },
            "mysql-node3:3306": {
                "address": "mysql-node3:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            }
        }
    }
}
```

### 1.3 关键状态指标解读


**🔸 集群级别状态**

| 状态值 | 含义 | 说明 | 处理建议 |
|--------|------|------|----------|
| `OK` | 正常 | 集群运行良好，可以容忍节点故障 | 无需处理 |
| `OK_PARTIAL` | 部分正常 | 有节点离线，但仍可提供服务 | 尽快修复离线节点 |
| `OK_NO_TOLERANCE` | 无容错 | 只有一个节点在线，无法容错 | **紧急**：立即恢复其他节点 |
| `NOT_OK` | 不正常 | 集群无法正常工作 | **紧急**：立即排查修复 |

**🔸 节点级别状态**

| 状态值 | 含义 | 说明 |
|--------|------|------|
| `ONLINE` | 在线 | 节点正常工作 |
| `OFFLINE` | 离线 | 节点无法连接或已停止 |
| `RECOVERING` | 恢复中 | 节点正在同步数据 |
| `ERROR` | 错误 | 节点有严重问题 |
| `UNREACHABLE` | 不可达 | 网络连接问题 |

### 1.4 监控脚本示例


**🔸 简单的状态检查脚本**
```bash
#!/bin/bash
# cluster_check.sh - 集群状态检查脚本

MYSQL_SHELL="/usr/bin/mysqlsh"
PRIMARY_HOST="192.168.1.10"
MYSQL_USER="admin"
MYSQL_PASS="your_password"

echo "=== MySQL InnoDB Cluster 状态检查 ==="
echo "检查时间: $(date)"
echo ""

# 执行状态检查
$MYSQL_SHELL --uri ${MYSQL_USER}:${MYSQL_PASS}@${PRIMARY_HOST}:3306 \
  --sql -e "
    var cluster = dba.getCluster();
    var status = cluster.status();
    print('集群状态:', status.defaultReplicaSet.status);
    print('状态描述:', status.defaultReplicaSet.statusText);
  " 2>/dev/null

echo ""
echo "=== 检查完成 ==="
```

---

## 2. 🏥 节点健康检查


### 2.1 什么是节点健康检查


**通俗解释**：就像定期体检一样，检查集群中每个MySQL节点是否健康。主要看几个方面：
- **连接状态**：能不能连上
- **复制状态**：数据同步是否正常
- **资源使用**：CPU、内存、磁盘是否正常
- **错误日志**：有没有异常报错

### 2.2 连接状态检查


**🔸 基本连接测试**
```bash
# 测试每个节点是否能连接
mysql -h 192.168.1.10 -u admin -p -e "SELECT 'Node1 连接正常'"
mysql -h 192.168.1.11 -u admin -p -e "SELECT 'Node2 连接正常'"  
mysql -h 192.168.1.12 -u admin -p -e "SELECT 'Node3 连接正常'"
```

**🔸 详细连接信息检查**
```sql
-- 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 查看最大连接数
SHOW VARIABLES LIKE 'max_connections';

-- 查看连接使用率
SELECT 
    VARIABLE_VALUE as current_connections,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
     WHERE VARIABLE_NAME = 'max_connections') as max_connections,
    ROUND((VARIABLE_VALUE / 
           (SELECT VARIABLE_VALUE FROM performance_schema.global_variables 
            WHERE VARIABLE_NAME = 'max_connections')) * 100, 2) as connection_usage_percent
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Threads_connected';
```

### 2.3 复制状态检查


**🔸 Group Replication 状态检查**
```sql
-- 查看组复制状态
SELECT 
    MEMBER_HOST,
    MEMBER_PORT, 
    MEMBER_STATE,           -- 成员状态
    MEMBER_ROLE             -- 成员角色（PRIMARY/SECONDARY）
FROM performance_schema.replication_group_members;
```

**正常输出示例**：
```
+---------------+-------------+--------------+-------------+
| MEMBER_HOST   | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE |
+---------------+-------------+--------------+-------------+
| mysql-node1   |        3306 | ONLINE       | PRIMARY     |
| mysql-node2   |        3306 | ONLINE       | SECONDARY   |
| mysql-node3   |        3306 | ONLINE       | SECONDARY   |
+---------------+-------------+--------------+-------------+
```

**🔸 复制延迟检查**
```sql
-- 查看复制延迟情况
SELECT 
    CHANNEL_NAME,
    COUNT_TRANSACTIONS_IN_QUEUE as pending_transactions,
    COUNT_TRANSACTIONS_CHECKED as checked_transactions,
    COUNT_TRANSACTIONS_DETECTED_CONFLICTS as conflict_transactions
FROM performance_schema.replication_group_member_stats;
```

### 2.4 资源使用情况检查


**🔸 系统资源脚本**
```bash
#!/bin/bash
# health_check.sh - 节点健康检查

check_node_health() {
    local host=$1
    echo "=== 检查节点: $host ==="
    
    # CPU使用率
    echo "CPU使用率:"
    ssh $host "top -bn1 | grep 'Cpu(s)' | awk '{print \$2}' | cut -d'%' -f1"
    
    # 内存使用情况  
    echo "内存使用情况:"
    ssh $host "free -h"
    
    # 磁盘使用情况
    echo "磁盘使用情况:"
    ssh $host "df -h | grep -v tmpfs"
    
    # MySQL进程状态
    echo "MySQL进程:"
    ssh $host "ps aux | grep mysql | grep -v grep"
    
    echo ""
}

# 检查所有节点
check_node_health "192.168.1.10"
check_node_health "192.168.1.11" 
check_node_health "192.168.1.12"
```

---

## 3. 📈 性能指标收集


### 3.1 性能监控的重要性


**为什么要监控性能**：
- **提前发现问题**：在用户感受到之前发现性能下降
- **容量规划**：了解资源使用趋势，提前扩容
- **优化依据**：有数据支撑的优化决策
- **故障排查**：性能数据是排查问题的重要线索

### 3.2 关键性能指标


**🔸 数据库层面指标**

```sql
-- 查询性能统计
SELECT 
    SCHEMA_NAME as database_name,
    SUM(COUNT_READ) as total_reads,
    SUM(COUNT_WRITE) as total_writes,
    SUM(SUM_TIMER_READ)/1000000000 as read_time_seconds,
    SUM(SUM_TIMER_WRITE)/1000000000 as write_time_seconds
FROM performance_schema.table_io_waits_summary_by_table
WHERE SCHEMA_NAME NOT IN ('mysql', 'information_schema', 'performance_schema')
GROUP BY SCHEMA_NAME;
```

**🔸 连接和线程统计**
```sql
-- 连接统计
SELECT 
    'Current Connections' as metric,
    VARIABLE_VALUE as value
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Threads_connected'

UNION ALL

SELECT 
    'Total Connections',
    VARIABLE_VALUE
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Connections'

UNION ALL

SELECT 
    'Aborted Connections',
    VARIABLE_VALUE  
FROM performance_schema.global_status
WHERE VARIABLE_NAME = 'Aborted_connects';
```

### 3.3 性能监控脚本


**🔸 综合性能收集脚本**
```bash
#!/bin/bash
# performance_collect.sh - 性能指标收集

MYSQL_USER="monitor"
MYSQL_PASS="monitor_pass"
OUTPUT_DIR="/var/log/mysql-monitor"
DATE=$(date +%Y%m%d_%H%M%S)

# 确保输出目录存在
mkdir -p $OUTPUT_DIR

collect_performance_data() {
    local host=$1
    local output_file="$OUTPUT_DIR/perf_${host//./}_$DATE.log"
    
    echo "=== 性能数据收集: $host ===" > $output_file
    echo "收集时间: $(date)" >> $output_file
    echo "" >> $output_file
    
    # QPS统计
    mysql -h $host -u $MYSQL_USER -p$MYSQL_PASS -e "
        SELECT 
            'QPS' as metric,
            ROUND(VARIABLE_VALUE/$$uptime, 2) as value
        FROM performance_schema.global_status 
        WHERE VARIABLE_NAME = 'Questions';
    " >> $output_file 2>/dev/null
    
    # TPS统计  
    mysql -h $host -u $MYSQL_USER -p$MYSQL_PASS -e "
        SELECT 
            'TPS' as metric,
            ROUND((COM_COMMIT + COM_ROLLBACK)/$$uptime, 2) as value
        FROM 
            (SELECT VARIABLE_VALUE as COM_COMMIT 
             FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Com_commit') a,
            (SELECT VARIABLE_VALUE as COM_ROLLBACK 
             FROM performance_schema.global_status 
             WHERE VARIABLE_NAME = 'Com_rollback') b;
    " >> $output_file 2>/dev/null
    
    # 慢查询统计
    mysql -h $host -u $MYSQL_USER -p$MYSQL_PASS -e "
        SELECT 
            'Slow Queries' as metric,
            VARIABLE_VALUE as value
        FROM performance_schema.global_status 
        WHERE VARIABLE_NAME = 'Slow_queries';
    " >> $output_file 2>/dev/null
}

# 收集所有节点数据
collect_performance_data "192.168.1.10"
collect_performance_data "192.168.1.11"
collect_performance_data "192.168.1.12"

echo "性能数据收集完成，文件保存在: $OUTPUT_DIR"
```

---

## 4. 📝 日志文件管理


### 4.1 日志文件的重要性


**通俗理解**：日志就像是数据库的"日记本"，记录了所有重要的事情：
- **错误日志**：记录出错的信息，相当于"问题记录本"
- **慢查询日志**：记录执行慢的SQL，相当于"性能问题记录"
- **二进制日志**：记录数据变更，相当于"操作记录本"
- **审计日志**：记录谁做了什么，相当于"安全记录"

### 4.2 重要日志文件位置


**🔸 默认日志文件路径**
```bash
# 查看日志文件配置
mysql -e "SHOW VARIABLES LIKE '%log%';" | grep -E "(error|slow|bin)"

# 常见日志文件位置
/var/log/mysql/error.log          # 错误日志
/var/log/mysql/mysql-slow.log     # 慢查询日志  
/var/lib/mysql/mysql-bin.*        # 二进制日志
```

**🔸 查看当前日志配置**
```sql
-- 查看错误日志位置
SHOW VARIABLES LIKE 'log_error';

-- 查看慢查询日志配置
SHOW VARIABLES LIKE 'slow_query_log%';

-- 查看二进制日志配置  
SHOW VARIABLES LIKE 'log_bin%';
```

### 4.3 日志轮转和清理


**🔸 日志轮转配置**
```bash
# /etc/logrotate.d/mysql-cluster
/var/log/mysql/*.log {
    daily                    # 每天轮转
    missingok               # 文件不存在不报错
    rotate 30               # 保留30天
    compress                # 压缩旧日志
    delaycompress          # 延迟压缩
    notifempty             # 空文件不轮转
    create 640 mysql mysql  # 创建新文件的权限
    postrotate
        # 重新打开日志文件
        if test -x /usr/bin/mysqladmin && \
           /usr/bin/mysqladmin ping &>/dev/null
        then
           /usr/bin/mysqladmin flush-logs
        fi
    endscript
}
```

**🔸 二进制日志清理脚本**
```bash
#!/bin/bash
# binlog_cleanup.sh - 二进制日志清理

MYSQL_USER="admin"
MYSQL_PASS="your_password"
RETAIN_DAYS=7  # 保留天数

echo "开始清理 $RETAIN_DAYS 天前的二进制日志..."

# 获取要清理的日志文件
mysql -u $MYSQL_USER -p$MYSQL_PASS -e "
    PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL $RETAIN_DAYS DAY);
    SHOW BINARY LOGS;
"

echo "二进制日志清理完成"
```

### 4.4 日志监控告警


**🔸 错误日志监控脚本**
```bash
#!/bin/bash
# error_log_monitor.sh - 错误日志监控

ERROR_LOG="/var/log/mysql/error.log"
ALERT_EMAIL="admin@company.com"
LAST_CHECK_FILE="/tmp/mysql_error_lastcheck"

# 获取上次检查时间
if [ -f "$LAST_CHECK_FILE" ]; then
    LAST_CHECK=$(cat $LAST_CHECK_FILE)
else
    LAST_CHECK=$(date -d "1 hour ago" '+%Y-%m-%d %H:%M:%S')
fi

# 更新检查时间
echo $(date '+%Y-%m-%d %H:%M:%S') > $LAST_CHECK_FILE

# 检查错误日志中的新错误
NEW_ERRORS=$(awk -v start="$LAST_CHECK" '
    $0 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
        if ($1 " " $2 > start && ($0 ~ /ERROR/ || $0 ~ /FATAL/)) {
            print $0
        }
    }
' $ERROR_LOG)

# 如果有新错误，发送告警
if [ ! -z "$NEW_ERRORS" ]; then
    echo "发现MySQL错误，发送告警邮件..."
    echo "MySQL错误日志告警 - $(hostname)" | \
        mail -s "MySQL错误告警" $ALERT_EMAIL << EOF
检查时间: $(date)
服务器: $(hostname)
错误内容:
$NEW_ERRORS
EOF
fi
```

---

## 5. 💾 备份策略制定


### 5.1 备份策略的重要性


**为什么需要备份策略**：
- **数据保护**：防止硬件故障、人为误操作导致数据丢失
- **业务连续性**：快速恢复保证业务不中断
- **合规要求**：很多行业有数据备份的法规要求
- **灾难恢复**：应对机房断电、自然灾害等极端情况

### 5.2 备份类型和选择


**🔸 备份类型对比**

| 备份类型 | 优点 | 缺点 | 适用场景 |
|----------|------|------|----------|
| **全量备份** | 恢复简单，数据完整 | 耗时长，占用空间大 | 定期基础备份 |
| **增量备份** | 速度快，占用空间小 | 恢复复杂，需要多个文件 | 日常备份 |
| **差异备份** | 恢复相对简单 | 占用空间逐渐增大 | 周期性备份 |

**🔸 常用备份工具**

```bash
# 1. mysqldump - 逻辑备份
mysqldump --all-databases \
          --single-transaction \
          --routines \
          --triggers \
          --master-data=2 > full_backup.sql

# 2. mysqlpump - 并行逻辑备份  
mysqlpump --all-databases \
          --single-transaction \
          --default-parallelism=4 > full_backup_parallel.sql

# 3. MySQL Enterprise Backup - 物理备份（商业版）
mysqlbackup --backup-dir=/backup/$(date +%Y%m%d) backup-and-apply-log

# 4. Percona XtraBackup - 物理备份（开源）
xtrabackup --backup --target-dir=/backup/$(date +%Y%m%d)
```

### 5.3 集群备份策略


**🔸 InnoDB Cluster 备份最佳实践**

```bash
#!/bin/bash
# cluster_backup.sh - 集群备份脚本

BACKUP_DIR="/backup/mysql-cluster"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_PATH="$BACKUP_DIR/$DATE"
MYSQL_USER="backup_user"
MYSQL_PASS="backup_password"

# 创建备份目录
mkdir -p $BACKUP_PATH

echo "=== MySQL InnoDB Cluster 备份开始 ==="
echo "备份时间: $(date)"
echo "备份路径: $BACKUP_PATH"

# 从从节点进行备份，减少对主节点的影响
SECONDARY_NODE="192.168.1.11"  # 选择一个从节点

echo "从从节点 $SECONDARY_NODE 进行备份..."

# 1. 数据库结构备份
mysqldump -h $SECONDARY_NODE -u $MYSQL_USER -p$MYSQL_PASS \
          --no-data \
          --all-databases \
          --routines \
          --triggers > $BACKUP_PATH/schema_backup.sql

# 2. 全量数据备份
mysqldump -h $SECONDARY_NODE -u $MYSQL_USER -p$MYSQL_PASS \
          --single-transaction \
          --all-databases \
          --routines \
          --triggers \
          --master-data=2 > $BACKUP_PATH/full_backup.sql

# 3. 集群配置备份
mysql -h $SECONDARY_NODE -u $MYSQL_USER -p$MYSQL_PASS -e "
    SELECT * FROM mysql.servers;
    SELECT * FROM performance_schema.replication_group_members;
" > $BACKUP_PATH/cluster_config.txt

# 4. 压缩备份文件
cd $BACKUP_DIR
tar -czf ${DATE}_cluster_backup.tar.gz $DATE/
rm -rf $DATE/

echo "备份完成: ${DATE}_cluster_backup.tar.gz"
echo "备份大小: $(du -h ${DATE}_cluster_backup.tar.gz | cut -f1)"
```

### 5.4 备份验证和恢复测试


**🔸 备份验证脚本**
```bash
#!/bin/bash
# backup_verify.sh - 备份验证

BACKUP_FILE="$1"
TEST_DB="backup_test_$(date +%s)"

if [ -z "$BACKUP_FILE" ]; then
    echo "用法: $0 <备份文件路径>"
    exit 1
fi

echo "=== 备份文件验证 ==="
echo "备份文件: $BACKUP_FILE"

# 1. 检查文件完整性
if [ ! -f "$BACKUP_FILE" ]; then
    echo "错误: 备份文件不存在"
    exit 1
fi

echo "文件大小: $(du -h $BACKUP_FILE | cut -f1)"

# 2. 创建测试数据库并恢复
echo "创建测试数据库: $TEST_DB"
mysql -e "CREATE DATABASE $TEST_DB;"

echo "测试恢复数据..."
if mysql $TEST_DB < $BACKUP_FILE; then
    echo "✅ 备份文件可以正常恢复"
    
    # 检查恢复的数据
    TABLE_COUNT=$(mysql -N -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$TEST_DB';")
    echo "恢复的表数量: $TABLE_COUNT"
    
else
    echo "❌ 备份文件恢复失败"
fi

# 3. 清理测试数据库
echo "清理测试数据库..."
mysql -e "DROP DATABASE $TEST_DB;"

echo "验证完成"
```

---

## 6. 🔧 维护窗口管理


### 6.1 什么是维护窗口


**通俗解释**：维护窗口就是专门安排的"停机维护时间"，就像商场在深夜关门后进行清洁维护一样。在这个时间段内：
- **计划内停机**：进行系统升级、配置修改
- **数据维护**：备份、索引重建、数据清理
- **硬件维护**：更换设备、扩容等

### 6.2 维护窗口规划


**🔸 维护窗口选择原则**

```
最佳时间窗口选择：
┌─────────────────────────────────────┐
│ 时间段        │ 业务影响 │ 推荐程度  │
├─────────────────────────────────────┤
│ 02:00-06:00  │ 极低     │ ★★★★★   │
│ 22:00-02:00  │ 低       │ ★★★★☆   │
│ 06:00-08:00  │ 中       │ ★★☆☆☆   │
│ 其他时间      │ 高       │ ★☆☆☆☆   │
└─────────────────────────────────────┘

考虑因素：
• 业务访问量最低的时间段
• 用户分布的时区差异
• 节假日和特殊时期避免
• 足够的时间窗口完成维护
```

**🔸 维护分类和时间安排**

| 维护类型 | 频率 | 推荐时间窗口 | 预计耗时 |
|----------|------|--------------|----------|
| **日常备份** | 每天 | 凌晨2:00-3:00 | 30-60分钟 |
| **索引优化** | 每周 | 周末凌晨2:00-4:00 | 1-2小时 |
| **系统更新** | 每月 | 月末周末凌晨 | 2-4小时 |
| **硬件维护** | 季度 | 节假日前 | 4-8小时 |

### 6.3 维护窗口执行流程


**🔸 维护前准备清单**
```bash
#!/bin/bash
# maintenance_prepare.sh - 维护前准备检查

echo "=== 维护窗口前准备检查 ==="
echo "检查时间: $(date)"
echo ""

# 1. 备份检查
echo "1. 检查最新备份..."
LATEST_BACKUP=$(ls -t /backup/mysql-cluster/*.tar.gz | head -1)
if [ ! -z "$LATEST_BACKUP" ]; then
    echo "   ✅ 最新备份: $LATEST_BACKUP"
    echo "   ✅ 备份时间: $(stat -c %y $LATEST_BACKUP)"
else
    echo "   ❌ 没有找到备份文件"
    exit 1
fi

# 2. 集群状态检查
echo ""
echo "2. 检查集群状态..."
mysqlsh --uri admin:password@192.168.1.10:3306 --sql -e "
var cluster = dba.getCluster();
var status = cluster.status();
if (status.defaultReplicaSet.status == 'OK') {
    print('✅ 集群状态正常');
} else {
    print('❌ 集群状态异常: ' + status.defaultReplicaSet.status);
}
" 2>/dev/null

# 3. 检查运行中的关键任务
echo ""
echo "3. 检查运行中的任务..."
LONG_QUERIES=$(mysql -N -e "
SELECT COUNT(*) FROM information_schema.processlist 
WHERE command != 'Sleep' AND time > 300;
")
if [ "$LONG_QUERIES" -eq 0 ]; then
    echo "   ✅ 没有长时间运行的查询"
else
    echo "   ⚠️  有 $LONG_QUERIES 个长时间运行的查询"
fi

# 4. 磁盘空间检查
echo ""
echo "4. 检查磁盘空间..."
DISK_USAGE=$(df /var/lib/mysql | awk 'NR==2 {print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -lt 80 ]; then
    echo "   ✅ 磁盘使用率: ${DISK_USAGE}%"
else
    echo "   ⚠️  磁盘使用率较高: ${DISK_USAGE}%"
fi

echo ""
echo "=== 准备检查完成 ==="
```

### 6.4 维护期间的监控


**🔸 维护过程监控脚本**
```bash
#!/bin/bash
# maintenance_monitor.sh - 维护过程监控

MAINTENANCE_LOG="/var/log/mysql-maintenance.log"
MONITOR_INTERVAL=30  # 监控间隔（秒）

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $MAINTENANCE_LOG
}

monitor_maintenance() {
    log_message "开始维护期间监控..."
    
    while true; do
        # 检查MySQL服务状态
        if systemctl is-active mysql >/dev/null 2>&1; then
            log_message "✅ MySQL服务运行正常"
        else
            log_message "❌ MySQL服务异常"
        fi
        
        # 检查集群连接
        if mysql -e "SELECT 1" >/dev/null 2>&1; then
            log_message "✅ 数据库连接正常"
        else
            log_message "❌ 数据库连接失败"
        fi
        
        # 检查系统资源
        CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
        MEM_USAGE=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100.0}')
        log_message "系统资源 - CPU: ${CPU_USAGE}%, 内存: ${MEM_USAGE}%"
        
        sleep $MONITOR_INTERVAL
    done
}

# 启动监控
monitor_maintenance
```

---

## 7. ✅ 例行检查清单


### 7.1 日常检查清单


**🔸 每日必检项目**
```
□ 集群整体状态检查
  └─ 运行命令: cluster.status()
  └─ 确认状态: OK
  └─ 检查时间: ________

□ 节点在线状态检查  
  └─ 节点1 (192.168.1.10): □ ONLINE
  └─ 节点2 (192.168.1.11): □ ONLINE  
  └─ 节点3 (192.168.1.12): □ ONLINE

□ 错误日志检查
  └─ 新增ERROR数量: ________
  └─ 新增WARNING数量: ________
  └─ 需要关注的错误: ________

□ 备份状态检查
  └─ 昨日备份完成: □ 是 □ 否
  └─ 备份文件大小: ________
  └─ 备份耗时: ________

□ 性能指标检查
  └─ 当前连接数: ________
  └─ QPS: ________
  └─ 慢查询数量: ________

□ 系统资源检查
  └─ CPU使用率: ________%
  └─ 内存使用率: ________% 
  └─ 磁盘使用率: ________%
```

### 7.2 周检查清单


**🔸 每周深度检查**
```bash
#!/bin/bash
# weekly_check.sh - 周检查脚本

echo "=== MySQL InnoDB Cluster 周检查 ==="
echo "检查日期: $(date)"
echo ""

# 1. 性能趋势分析
echo "1. 性能趋势分析"
mysql -e "
SELECT 
    '过去7天平均QPS' as metric,
    ROUND(AVG(VARIABLE_VALUE)/86400, 2) as value
FROM 
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Questions') as q;

SELECT 
    '过去7天慢查询' as metric,
    VARIABLE_VALUE as value
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Slow_queries';
"

# 2. 存储空间分析
echo ""
echo "2. 存储空间分析"
mysql -e "
SELECT 
    table_schema as '数据库',
    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as '大小(MB)'
FROM information_schema.tables 
WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql')
GROUP BY table_schema
ORDER BY SUM(data_length + index_length) DESC;
"

# 3. 索引使用情况
echo ""
echo "3. 未使用的索引"
mysql -e "
SELECT 
    OBJECT_SCHEMA as database_name,
    OBJECT_NAME as table_name,
    INDEX_NAME as index_name
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE INDEX_NAME IS NOT NULL
AND INDEX_NAME != 'PRIMARY'
AND COUNT_STAR = 0
ORDER BY OBJECT_SCHEMA, OBJECT_NAME;
"

# 4. 连接统计
echo ""
echo "4. 连接统计"
mysql -e "
SELECT 
    'Max_used_connections' as metric,
    VARIABLE_VALUE as value
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Max_used_connections'

UNION ALL

SELECT 
    'Aborted_connects',
    VARIABLE_VALUE
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Aborted_connects';
"

echo ""
echo "=== 周检查完成 ==="
```

### 7.3 月检查清单


**🔸 每月全面检查**
```
□ 备份恢复测试
  └─ 选择备份文件: ________
  └─ 恢复测试结果: □ 成功 □ 失败
  └─ 恢复耗时: ________

□ 安全检查
  └─ 用户权限审核: □ 完成
  └─ 密码策略检查: □ 符合要求
  └─ SSL证书到期检查: ________

□ 容量规划
  └─ 数据增长率: ________% 
  └─ 预计满容时间: ________
  └─ 扩容计划: □ 需要 □ 暂不需要

□ 性能优化
  └─ 慢查询分析: □ 完成
  └─ 索引优化建议: ________
  └─ 配置调优建议: ________

□ 文档更新
  └─ 运维文档更新: □ 完成
  └─ 应急预案更新: □ 完成
  └─ 联系人信息更新: □ 完成
```

---

## 8. 🤖 运维自动化脚本


### 8.1 自动化监控脚本


**🔸 综合监控脚本**
```bash
#!/bin/bash
# mysql_cluster_monitor.sh - 综合监控脚本

# 配置文件
CONFIG_FILE="/etc/mysql-monitor.conf"
if [ -f "$CONFIG_FILE" ]; then
    source $CONFIG_FILE
else
    # 默认配置
    MYSQL_USER="monitor"
    MYSQL_PASS="monitor_pass"
    ALERT_EMAIL="admin@company.com"
    NODES=("192.168.1.10" "192.168.1.11" "192.168.1.12")
fi

LOG_FILE="/var/log/mysql-cluster-monitor.log"
ALERT_THRESHOLD_CPU=80
ALERT_THRESHOLD_MEM=85
ALERT_THRESHOLD_DISK=90

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

send_alert() {
    local subject="$1"
    local message="$2"
    echo "$message" | mail -s "$subject" $ALERT_EMAIL
    log_message "发送告警: $subject"
}

check_cluster_status() {
    log_message "检查集群状态..."
    
    local status_output=$(mysqlsh --uri ${MYSQL_USER}:${MYSQL_PASS}@${NODES[0]}:3306 \
        --sql -e "var cluster = dba.getCluster(); print(JSON.stringify(cluster.status()));" 2>/dev/null)
    
    if echo "$status_output" | grep -q '"status":"OK"'; then
        log_message "✅ 集群状态正常"
        return 0
    else
        log_message "❌ 集群状态异常"
        send_alert "MySQL集群状态告警" "集群状态异常，需要立即检查。\n\n状态输出:\n$status_output"
        return 1
    fi
}

check_node_resources() {
    local node=$1
    log_message "检查节点资源: $node"
    
    # CPU检查
    local cpu_usage=$(ssh $node "top -bn1 | grep 'Cpu(s)' | awk '{print \$2}' | cut -d'%' -f1" 2>/dev/null)
    if (( $(echo "$cpu_usage > $ALERT_THRESHOLD_CPU" | bc -l) )); then
        send_alert "节点CPU告警" "节点 $node CPU使用率过高: ${cpu_usage}%"
    fi
    
    # 内存检查
    local mem_usage=$(ssh $node "free | grep Mem | awk '{printf \"%.1f\", \$3/\$2 * 100.0}'" 2>/dev/null)
    if (( $(echo "$mem_usage > $ALERT_THRESHOLD_MEM" | bc -l) )); then
        send_alert "节点内存告警" "节点 $node 内存使用率过高: ${mem_usage}%"
    fi
    
    # 磁盘检查
    local disk_usage=$(ssh $node "df /var/lib/mysql | awk 'NR==2 {print \$5}' | sed 's/%//'" 2>/dev/null)
    if [ "$disk_usage" -gt "$ALERT_THRESHOLD_DISK" ]; then
        send_alert "节点磁盘告警" "节点 $node 磁盘使用率过高: ${disk_usage}%"
    fi
    
    log_message "节点 $node 资源状态 - CPU: ${cpu_usage}%, 内存: ${mem_usage}%, 磁盘: ${disk_usage}%"
}

main() {
    log_message "=== 开始自动监控检查 ==="
    
    # 检查集群状态
    check_cluster_status
    
    # 检查各节点资源
    for node in "${NODES[@]}"; do
        check_node_resources $node
    done
    
    log_message "=== 监控检查完成 ==="
    echo ""
}

# 执行主函数
main
```

### 8.2 自动故障恢复脚本


**🔸 节点自动恢复脚本**
```bash
#!/bin/bash
# auto_recovery.sh - 自动故障恢复

MYSQL_USER="admin"
MYSQL_PASS="admin_pass"
CLUSTER_NODES=("192.168.1.10" "192.168.1.11" "192.168.1.12")
LOG_FILE="/var/log/mysql-auto-recovery.log"

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

check_node_status() {
    local node=$1
    if mysql -h $node -u $MYSQL_USER -p$MYSQL_PASS -e "SELECT 1" >/dev/null 2>&1; then
        return 0  # 节点正常
    else
        return 1  # 节点异常
    fi
}

restart_mysql_service() {
    local node=$1
    log_message "尝试重启节点 $node 的MySQL服务..."
    
    if ssh $node "sudo systemctl restart mysql" 2>/dev/null; then
        log_message "✅ 节点 $node MySQL服务重启成功"
        sleep 30  # 等待服务完全启动
        
        if check_node_status $node; then
            log_message "✅ 节点 $node 恢复正常"
            return 0
        else
            log_message "❌ 节点 $node 重启后仍无法连接"
            return 1
        fi
    else
        log_message "❌ 节点 $node MySQL服务重启失败"
        return 1
    fi
}

rejoin_cluster() {
    local node=$1
    log_message "尝试将节点 $node 重新加入集群..."
    
    # 找到一个正常的节点作为管理节点
    local mgmt_node=""
    for n in "${CLUSTER_NODES[@]}"; do
        if [ "$n" != "$node" ] && check_node_status $n; then
            mgmt_node=$n
            break
        fi
    done
    
    if [ -z "$mgmt_node" ]; then
        log_message "❌ 没有找到可用的管理节点"
        return 1
    fi
    
    # 执行重新加入操作
    local rejoin_result=$(mysqlsh --uri ${MYSQL_USER}:${MYSQL_PASS}@${mgmt_node}:3306 \
        --sql -e "
            var cluster = dba.getCluster();
            cluster.rejoinInstance('${MYSQL_USER}:${MYSQL_PASS}@${node}:3306');
        " 2>&1)
    
    if echo "$rejoin_result" | grep -q "successfully rejoined"; then
        log_message "✅ 节点 $node 成功重新加入集群"
        return 0
    else
        log_message "❌ 节点 $node 重新加入集群失败: $rejoin_result"
        return 1
    fi
}

auto_recovery() {
    log_message "=== 开始自动故障恢复检查 ==="
    
    for node in "${CLUSTER_NODES[@]}"; do
        if ! check_node_status $node; then
            log_message "⚠️  检测到节点 $node 异常，开始恢复流程..."
            
            # 步骤1: 重启MySQL服务
            if restart_mysql_service $node; then
                # 步骤2: 重新加入集群
                if ! rejoin_cluster $node; then
                    log_message "❌ 节点 $node 自动恢复失败，需要人工干预"
                    # 发送告警通知
                    echo "节点 $node 自动恢复失败，请立即检查处理。" | \
                        mail -s "MySQL集群节点恢复失败告警" admin@company.com
                fi
            else
                log_message "❌ 节点 $node 服务重启失败，需要人工干预"
            fi
        else
            log_message "✅ 节点 $node 状态正常"
        fi
    done
    
    log_message "=== 自动故障恢复检查完成 ==="
}

# 执行自动恢复
auto_recovery
```

### 8.3 定时任务配置


**🔸 Crontab 配置示例**
```bash
# 编辑定时任务
crontab -e

# 添加以下任务
# 每5分钟检查集群状态
*/5 * * * * /usr/local/bin/mysql_cluster_monitor.sh >/dev/null 2>&1

# 每天凌晨2点执行备份
0 2 * * * /usr/local/bin/cluster_backup.sh >/dev/null 2>&1

# 每小时检查并清理日志
0 * * * * /usr/local/bin/log_cleanup.sh >/dev/null 2>&1

# 每天早上8点发送状态报告
0 8 * * * /usr/local/bin/daily_report.sh | mail -s "MySQL集群日报" admin@company.com

# 每周日凌晨3点执行深度检查
0 3 * * 0 /usr/local/bin/weekly_check.sh >/dev/null 2>&1

# 每月1号进行备份验证
0 4 1 * * /usr/local/bin/backup_verify.sh /backup/mysql-cluster/latest >/dev/null 2>&1
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心操作


```
🔸 集群状态监控：cluster.status() 是最重要的命令
🔸 节点健康检查：连接状态、复制状态、资源使用情况
🔸 性能指标收集：QPS、TPS、连接数、慢查询统计
🔸 日志管理：错误日志、慢查询日志、二进制日志的轮转清理
🔸 备份策略：全量备份+增量备份，从从节点备份减少影响
🔸 维护窗口：选择业务低峰期，做好充分准备和监控
🔸 例行检查：建立日常、周、月检查清单
🔸 自动化运维：监控脚本、故障恢复、定时任务
```

### 9.2 关键理解要点


**🔹 运维工作的重点**
```
预防为主：
- 通过监控提前发现问题
- 定期检查防止小问题变大问题
- 制定应急预案应对突发情况

数据安全：
- 定期备份是底线
- 备份验证确保可用性
- 多重备份策略降低风险

业务连续性：
- 选择合适的维护窗口
- 最小化业务影响
- 快速故障恢复能力
```

**🔹 自动化的价值**
```
提高效率：
- 减少重复性人工操作
- 24小时不间断监控
- 标准化的操作流程

降低风险：
- 避免人为操作失误
- 及时发现和处理问题
- 规范化的恢复流程
```

### 9.3 实际应用建议


**🔧 运维最佳实践**
- **建立监控体系**：完整的监控覆盖，及时告警
- **制定SOP**：标准化操作流程，减少人为错误
- **定期演练**：故障恢复流程定期演练验证
- **文档管理**：及时更新运维文档和应急预案
- **技能提升**：持续学习新的运维技术和工具

**⚠️ 常见陷阱**
- **过度依赖自动化**：自动化是辅助，不能完全替代人工判断
- **忽视备份验证**：备份文件损坏时才发现问题为时已晚
- **维护窗口准备不足**：临时出现问题时间不够用
- **监控指标过多**：重要告警被淹没在大量信息中

**核心记忆**：
- 监控是眼睛，备份是保险，自动化是助手
- 预防胜于治疗，准备胜于应急
- 简单可靠的方案胜过复杂精巧的设计
- 定期检查和演练是运维工作的基石