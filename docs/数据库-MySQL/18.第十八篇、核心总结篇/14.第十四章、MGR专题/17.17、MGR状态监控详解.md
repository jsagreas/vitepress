---
title: 17、MGR状态监控详解
---
## 📚 目录

1. [MGR监控概述](#1-MGR监控概述)
2. [核心监控表详解](#2-核心监控表详解)
3. [成员状态与角色监控](#3-成员状态与角色监控)
4. [性能指标监控](#4-性能指标监控)
5. [健康状态评估](#5-健康状态评估)
6. [监控脚本开发](#6-监控脚本开发)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 MGR监控概述


### 1.1 什么是MGR监控

**简单理解**：MGR监控就是实时查看MySQL组复制集群的"健康体检报告"，让你随时知道集群状态好不好。

**为什么需要监控**：
```
想象MGR集群是一个团队：
- 需要知道团队成员是否都在线
- 需要知道谁是队长（Primary）
- 需要知道工作进度如何
- 需要发现问题并及时解决

MGR监控就是这个"团队管理系统"
```

### 1.2 监控的核心目标

**🎯 主要监控内容**：
- **成员状态**：哪些节点在线，哪些掉线了
- **角色分配**：谁是主节点，谁是从节点
- **数据同步**：数据是否及时同步，有没有延迟
- **性能表现**：处理速度如何，有没有瓶颈
- **错误情况**：有没有冲突、认证失败等问题

### 1.3 MGR监控架构

```
应用层监控工具
    ↓
MySQL Performance Schema
    ↓
MGR插件内部状态
    ↓
底层网络和存储状态

监控数据流向：
底层状态 → Performance Schema表 → 监控查询 → 告警系统
```

---

## 2. 📊 核心监控表详解


### 2.1 replication_group_members表

**作用**：这是MGR最重要的监控表，显示集群中所有成员的基本信息。

**🔸 核心字段解释**：
```sql
SELECT 
    CHANNEL_NAME,           -- 复制通道名称
    MEMBER_ID,             -- 成员UUID标识
    MEMBER_HOST,           -- 成员主机地址
    MEMBER_PORT,           -- 成员端口号
    MEMBER_STATE,          -- 成员状态（重点）
    MEMBER_ROLE,           -- 成员角色（重点）
    MEMBER_VERSION         -- MySQL版本
FROM performance_schema.replication_group_members;
```

**实际查询示例**：
```sql
-- 查看集群成员状态
mysql> SELECT 
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE
FROM performance_schema.replication_group_members;

+-------------+-------------+--------------+-------------+
| MEMBER_HOST | MEMBER_PORT | MEMBER_STATE | MEMBER_ROLE |
+-------------+-------------+--------------+-------------+
| 192.168.1.10| 3306        | ONLINE       | PRIMARY     |
| 192.168.1.11| 3306        | ONLINE       | SECONDARY   |
| 192.168.1.12| 3306        | RECOVERING   | SECONDARY   |
+-------------+-------------+--------------+-------------+
```

### 2.2 replication_group_member_stats表

**作用**：提供每个成员的详细性能统计信息，是性能监控的核心。

**🔸 关键性能指标**：
```sql
SELECT 
    CHANNEL_NAME,
    VIEW_ID,                           -- 视图ID
    MEMBER_ID,
    COUNT_TRANSACTIONS_IN_QUEUE,      -- 待处理事务数
    COUNT_TRANSACTIONS_CHECKED,       -- 已检查事务数
    COUNT_CONFLICTS_DETECTED,         -- 检测到的冲突数
    COUNT_TRANSACTIONS_VALIDATING,    -- 正在验证的事务数
    TRANSACTIONS_COMMITTED_ALL_MEMBERS, -- 所有成员都提交的事务
    LAST_CONFLICT_FREE_TRANSACTION,   -- 最后一个无冲突事务
    COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE, -- 远程事务队列长度
    COUNT_TRANSACTIONS_REMOTE_APPLIED, -- 已应用的远程事务数
    COUNT_TRANSACTIONS_LOCAL_PROPOSED, -- 本地提议的事务数
    COUNT_TRANSACTIONS_LOCAL_ROLLBACK  -- 本地回滚的事务数
FROM performance_schema.replication_group_member_stats;
```

---

## 3. 🏷️ 成员状态与角色监控


### 3.1 MEMBER_STATE状态详解

**状态含义通俗解释**：

| 状态 | **通俗含义** | **技术说明** | **是否正常** |
|------|-------------|-------------|--------------|
| **ONLINE** | `成员正常在线工作` | `完全可用，能处理读写` | ✅ **正常** |
| **RECOVERING** | `成员正在追赶数据` | `正在同步落后的数据` | ⚠️ **临时状态** |
| **OFFLINE** | `成员已离线` | `不可用，已脱离集群` | ❌ **异常** |
| **ERROR** | `成员出现错误` | `遇到无法恢复的错误` | ❌ **严重异常** |
| **UNREACHABLE** | `成员网络不通` | `其他成员联系不上它` | ❌ **网络问题** |

**状态监控脚本**：
```bash
#!/bin/bash
# 检查成员状态
mysql -e "
SELECT 
    CONCAT(MEMBER_HOST, ':', MEMBER_PORT) AS Member,
    MEMBER_STATE,
    CASE 
        WHEN MEMBER_STATE = 'ONLINE' THEN '✅ 正常'
        WHEN MEMBER_STATE = 'RECOVERING' THEN '⚠️ 恢复中'
        WHEN MEMBER_STATE = 'OFFLINE' THEN '❌ 离线'
        WHEN MEMBER_STATE = 'ERROR' THEN '🚨 错误'
        WHEN MEMBER_STATE = 'UNREACHABLE' THEN '🔌 网络断开'
    END AS Status_CN
FROM performance_schema.replication_group_members;
"
```

### 3.2 MEMBER_ROLE角色监控

**角色含义**：
- **PRIMARY**：主节点，可以处理读写操作
- **SECONDARY**：从节点，通常只能处理读操作

**单主模式 vs 多主模式**：
```
单主模式（Single-Primary）：
NODE1 (PRIMARY)   ← 只有这个能写
NODE2 (SECONDARY) ← 只能读
NODE3 (SECONDARY) ← 只能读

多主模式（Multi-Primary）：
NODE1 (PRIMARY)   ← 可以写
NODE2 (PRIMARY)   ← 可以写  
NODE3 (PRIMARY)   ← 可以写
```

**角色监控查询**：
```sql
-- 查看当前主节点
SELECT 
    CONCAT(MEMBER_HOST, ':', MEMBER_PORT) AS Primary_Node
FROM performance_schema.replication_group_members 
WHERE MEMBER_ROLE = 'PRIMARY' AND MEMBER_STATE = 'ONLINE';

-- 统计角色分布
SELECT 
    MEMBER_ROLE,
    COUNT(*) AS Node_Count,
    GROUP_CONCAT(CONCAT(MEMBER_HOST, ':', MEMBER_PORT)) AS Nodes
FROM performance_schema.replication_group_members 
WHERE MEMBER_STATE = 'ONLINE'
GROUP BY MEMBER_ROLE;
```

---

## 4. 📈 性能指标监控


### 4.1 复制延迟监控

**什么是复制延迟**：从节点执行主节点的操作需要时间，这个时间差就是延迟。

**关键延迟指标**：
```sql
-- 监控事务队列长度（队列越长，延迟越大）
SELECT 
    MEMBER_ID,
    SUBSTRING(MEMBER_ID, 1, 8) AS Short_ID,
    COUNT_TRANSACTIONS_IN_QUEUE AS Queue_Length,
    COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE AS Remote_Queue,
    CASE 
        WHEN COUNT_TRANSACTIONS_IN_QUEUE = 0 THEN '✅ 无延迟'
        WHEN COUNT_TRANSACTIONS_IN_QUEUE < 10 THEN '⚠️ 轻微延迟'
        WHEN COUNT_TRANSACTIONS_IN_QUEUE < 100 THEN '🔶 中等延迟'
        ELSE '🚨 严重延迟'
    END AS Delay_Status
FROM performance_schema.replication_group_member_stats;
```

### 4.2 事务冲突监控

**什么是事务冲突**：多个节点同时修改相同数据时发生的冲突。

**冲突监控查询**：
```sql
-- 监控事务冲突情况
SELECT 
    MEMBER_ID,
    COUNT_CONFLICTS_DETECTED AS Total_Conflicts,
    COUNT_TRANSACTIONS_LOCAL_ROLLBACK AS Local_Rollbacks,
    ROUND(
        (COUNT_CONFLICTS_DETECTED / NULLIF(COUNT_TRANSACTIONS_CHECKED, 0)) * 100, 2
    ) AS Conflict_Rate_Percent
FROM performance_schema.replication_group_member_stats
WHERE COUNT_TRANSACTIONS_CHECKED > 0;
```

**冲突率评估**：
```
冲突率标准：
- 0-1%：   ✅ 优秀，正常水平
- 1-5%：   ⚠️ 注意，需要观察
- 5-10%：  🔶 偏高，需要优化
- >10%：   🚨 严重，必须处理
```

### 4.3 认证队列监控

**认证队列作用**：MGR需要验证每个事务的合法性，队列过长说明验证跟不上。

```sql
-- 认证性能监控
SELECT 
    MEMBER_ID,
    COUNT_TRANSACTIONS_VALIDATING AS Validating_Count,
    COUNT_TRANSACTIONS_CHECKED AS Checked_Total,
    CASE 
        WHEN COUNT_TRANSACTIONS_VALIDATING = 0 THEN '✅ 认证正常'
        WHEN COUNT_TRANSACTIONS_VALIDATING < 5 THEN '⚠️ 认证轻微积压'
        ELSE '🚨 认证严重积压'
    END AS Certification_Status
FROM performance_schema.replication_group_member_stats;
```

---

## 5. 🏥 健康状态评估


### 5.1 集群整体健康检查

```sql
-- 集群健康状态一览表
SELECT 
    'Member Status' AS Check_Item,
    CASE 
        WHEN COUNT(*) = SUM(CASE WHEN MEMBER_STATE = 'ONLINE' THEN 1 ELSE 0 END)
        THEN CONCAT('✅ 全部在线 (', COUNT(*), '个节点)')
        ELSE CONCAT('⚠️ ', 
                   SUM(CASE WHEN MEMBER_STATE = 'ONLINE' THEN 1 ELSE 0 END), 
                   '/', COUNT(*), ' 节点在线')
    END AS Status
FROM performance_schema.replication_group_members

UNION ALL

SELECT 
    'Primary Node' AS Check_Item,
    CASE 
        WHEN COUNT(*) = 1 THEN '✅ 主节点正常'
        WHEN COUNT(*) = 0 THEN '🚨 无主节点'
        ELSE '🚨 多主节点异常'
    END AS Status
FROM performance_schema.replication_group_members 
WHERE MEMBER_ROLE = 'PRIMARY' AND MEMBER_STATE = 'ONLINE';
```

### 5.2 性能健康评分

```sql
-- 性能健康评分
SELECT 
    CONCAT(MEMBER_HOST, ':', MEMBER_PORT) AS Node,
    CASE 
        WHEN COUNT_TRANSACTIONS_IN_QUEUE = 0 
             AND COUNT_CONFLICTS_DETECTED < 10 
        THEN '🟢 优秀 (95-100分)'
        
        WHEN COUNT_TRANSACTIONS_IN_QUEUE < 10 
             AND COUNT_CONFLICTS_DETECTED < 50 
        THEN '🟡 良好 (80-94分)'
        
        WHEN COUNT_TRANSACTIONS_IN_QUEUE < 100 
             AND COUNT_CONFLICTS_DETECTED < 100 
        THEN '🟠 一般 (60-79分)'
        
        ELSE '🔴 需要关注 (<60分)'
    END AS Health_Score,
    
    CONCAT('队列:', COUNT_TRANSACTIONS_IN_QUEUE, 
           ' 冲突:', COUNT_CONFLICTS_DETECTED) AS Details

FROM performance_schema.replication_group_member_stats rgms
JOIN performance_schema.replication_group_members rgm 
    ON rgms.MEMBER_ID = rgm.MEMBER_ID
WHERE rgm.MEMBER_STATE = 'ONLINE';
```

---

## 6. 🛠️ 监控脚本开发


### 6.1 基础监控脚本

```bash
#!/bin/bash
# MGR基础监控脚本

MYSQL_CMD="mysql -u monitor -p'password' -h localhost"

echo "=== MGR集群监控报告 ==="
echo "时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo

# 1. 集群成员状态
echo "【1. 集群成员状态】"
$MYSQL_CMD -e "
SELECT 
    CONCAT(MEMBER_HOST, ':', MEMBER_PORT) AS '节点',
    MEMBER_STATE AS '状态',
    MEMBER_ROLE AS '角色'
FROM performance_schema.replication_group_members
ORDER BY MEMBER_ROLE DESC, MEMBER_HOST;
" 2>/dev/null

echo

# 2. 性能指标概览
echo "【2. 性能指标概览】"
$MYSQL_CMD -e "
SELECT 
    SUBSTRING(rgms.MEMBER_ID, 1, 12) AS '成员ID',
    rgms.COUNT_TRANSACTIONS_IN_QUEUE AS '队列长度',
    rgms.COUNT_CONFLICTS_DETECTED AS '冲突数',
    rgms.COUNT_TRANSACTIONS_LOCAL_ROLLBACK AS '回滚数'
FROM performance_schema.replication_group_member_stats rgms
JOIN performance_schema.replication_group_members rgm 
    ON rgms.MEMBER_ID = rgm.MEMBER_ID
WHERE rgm.MEMBER_STATE = 'ONLINE';
" 2>/dev/null
```

### 6.2 告警监控脚本

```bash
#!/bin/bash
# MGR告警监控脚本

MYSQL_CMD="mysql -u monitor -p'password' -h localhost"
ALERT_EMAIL="admin@company.com"

# 检查离线节点
check_offline_members() {
    offline_count=$(
        $MYSQL_CMD -sN -e "
        SELECT COUNT(*) 
        FROM performance_schema.replication_group_members 
        WHERE MEMBER_STATE != 'ONLINE';" 2>/dev/null
    )
    
    if [ "$offline_count" -gt 0 ]; then
        echo "🚨 告警：发现 $offline_count 个离线节点"
        
        # 获取离线节点详情
        $MYSQL_CMD -e "
        SELECT 
            CONCAT(MEMBER_HOST, ':', MEMBER_PORT) AS '离线节点',
            MEMBER_STATE AS '状态'
        FROM performance_schema.replication_group_members 
        WHERE MEMBER_STATE != 'ONLINE';
        " 2>/dev/null
        
        return 1
    fi
    return 0
}

# 检查主节点
check_primary_node() {
    primary_count=$(
        $MYSQL_CMD -sN -e "
        SELECT COUNT(*) 
        FROM performance_schema.replication_group_members 
        WHERE MEMBER_ROLE = 'PRIMARY' AND MEMBER_STATE = 'ONLINE';" 2>/dev/null
    )
    
    if [ "$primary_count" -ne 1 ]; then
        echo "🚨 告警：主节点数量异常 ($primary_count 个)"
        return 1
    fi
    return 0
}

# 检查复制延迟
check_replication_lag() {
    max_queue=$(
        $MYSQL_CMD -sN -e "
        SELECT MAX(COUNT_TRANSACTIONS_IN_QUEUE) 
        FROM performance_schema.replication_group_member_stats;" 2>/dev/null
    )
    
    if [ "$max_queue" -gt 100 ]; then
        echo "⚠️ 警告：复制队列过长 ($max_queue)"
        return 1
    fi
    return 0
}

# 执行检查
echo "=== MGR告警检查 $(date) ==="
alert_flag=0

if ! check_offline_members; then
    alert_flag=1
fi

if ! check_primary_node; then
    alert_flag=1
fi

if ! check_replication_lag; then
    alert_flag=1
fi

if [ $alert_flag -eq 0 ]; then
    echo "✅ 所有检查通过，集群状态正常"
else
    echo "📧 发送告警邮件..."
    # 这里可以添加邮件发送逻辑
fi
```

### 6.3 性能监控脚本

```bash
#!/bin/bash
# MGR性能监控脚本

MYSQL_CMD="mysql -u monitor -p'password' -h localhost"
LOG_FILE="/var/log/mgr_performance.log"

# 记录性能数据
log_performance() {
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 获取性能数据
    $MYSQL_CMD -sN -e "
    SELECT 
        '$timestamp',
        rgm.MEMBER_HOST,
        rgm.MEMBER_PORT,
        rgm.MEMBER_STATE,
        rgm.MEMBER_ROLE,
        rgms.COUNT_TRANSACTIONS_IN_QUEUE,
        rgms.COUNT_CONFLICTS_DETECTED,
        rgms.COUNT_TRANSACTIONS_LOCAL_ROLLBACK
    FROM performance_schema.replication_group_members rgm
    JOIN performance_schema.replication_group_member_stats rgms 
        ON rgm.MEMBER_ID = rgms.MEMBER_ID;
    " 2>/dev/null >> $LOG_FILE
}

# 生成性能报告
generate_report() {
    echo "=== MGR性能报告 ==="
    echo "时间范围：最近1小时"
    echo
    
    # 平均队列长度
    echo "【平均队列长度】"
    tail -60 $LOG_FILE | awk '{
        queue[$2":"$3] += $6
        count[$2":"$3]++
    } END {
        for(node in queue) {
            printf "%-20s: %.1f\n", node, queue[node]/count[node]
        }
    }'
    
    echo
    
    # 冲突统计
    echo "【冲突统计】" 
    tail -60 $LOG_FILE | awk '{
        conflicts[$2":"$3] += $7
    } END {
        for(node in conflicts) {
            printf "%-20s: %d\n", node, conflicts[node]
        }
    }'
}

# 根据参数执行不同操作
case "$1" in
    "log")
        log_performance
        ;;
    "report")
        generate_report
        ;;
    *)
        echo "用法: $0 {log|report}"
        echo "  log    - 记录性能数据"
        echo "  report - 生成性能报告"
        ;;
esac
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的监控要点


```
🔸 核心监控表：replication_group_members 和 replication_group_member_stats
🔸 关键状态：ONLINE、RECOVERING、OFFLINE、ERROR、UNREACHABLE
🔸 重要角色：PRIMARY（主节点）、SECONDARY（从节点）
🔸 性能指标：队列长度、冲突数、延迟情况
🔸 健康评估：成员状态、主节点检查、性能评分
🔸 监控脚本：基础监控、告警检查、性能记录
```

### 7.2 监控最佳实践


**🔹 监控频率建议**：
```
实时监控（每分钟）：
- 成员状态检查
- 主节点状态检查
- 严重告警检查

常规监控（每5分钟）：
- 性能指标收集
- 队列长度检查
- 冲突统计

深度监控（每小时）：
- 性能趋势分析
- 历史数据汇总
- 容量规划数据
```

**🔹 告警阈值建议**：
```
立即告警：
- 任何节点 OFFLINE 或 ERROR
- 无 PRIMARY 节点或多个 PRIMARY
- 队列长度 > 1000

警告告警：
- 节点状态 RECOVERING 超过30分钟
- 队列长度 > 100
- 冲突率 > 5%

信息告警：
- 新节点加入集群
- 主节点切换
- 性能指标异常波动
```

### 7.3 常见问题诊断


**🔹 节点离线问题**：
```
检查步骤：
1. 查看 MEMBER_STATE 状态
2. 检查网络连接
3. 查看 MySQL 错误日志
4. 验证 MGR 配置参数
```

**🔹 复制延迟问题**：
```
分析方法：
1. 查看队列长度趋势
2. 检查系统资源使用
3. 分析事务大小和频率
4. 优化网络和存储性能
```

**🔹 冲突过多问题**：
```
解决思路：
1. 分析冲突的表和操作类型
2. 优化应用程序逻辑
3. 考虑分片或分区策略
4. 调整事务大小
```

### 7.4 监控工具选择


**自研脚本优势**：
- 完全可控，可定制化
- 贴合业务需求
- 成本低

**第三方工具推荐**：
- **MySQL Enterprise Monitor**：官方商业工具
- **Percona Monitoring and Management**：开源免费
- **Zabbix + 自定义模板**：企业级监控
- **Prometheus + Grafana**：现代化监控栈

**监控平台集成**：
```
数据采集：MySQL Performance Schema
     ↓
数据处理：监控脚本/Exporter  
     ↓
数据存储：时序数据库
     ↓
数据展示：Dashboard
     ↓
告警通知：邮件/短信/钉钉
```

**核心记忆**：
- MGR监控围绕成员状态和性能指标展开
- 重点关注 ONLINE 状态和 PRIMARY 角色
- 队列长度和冲突数是关键性能指标  
- 及时发现问题比完美监控更重要
- 监控脚本要简单实用，告警要精准有效