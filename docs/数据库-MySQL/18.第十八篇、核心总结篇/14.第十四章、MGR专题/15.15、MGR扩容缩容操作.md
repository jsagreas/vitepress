---
title: 15、MGR扩容缩容操作
---
## 📚 目录

1. [MGR扩容缩容概述](#1-MGR扩容缩容概述)
2. [集群在线扩容操作](#2-集群在线扩容操作)
3. [集群安全缩容操作](#3-集群安全缩容操作)
4. [扩缩容影响评估与监控](#4-扩缩容影响评估与监控)
5. [自动化扩缩容方案](#5-自动化扩缩容方案)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 MGR扩容缩容概述


### 1.1 什么是MGR扩容缩容


**扩容**就是给现有的MySQL MGR集群增加新的数据库节点，**缩容**就是从集群中移除部分节点。简单来说：
- **扩容**：3个节点变成5个节点，增强集群处理能力
- **缩容**：5个节点变成3个节点，减少资源消耗

```
扩容示例：
原集群：[节点A] [节点B] [节点C]
扩容后：[节点A] [节点B] [节点C] [节点D] [节点E]

缩容示例：
原集群：[节点A] [节点B] [节点C] [节点D] [节点E]
缩容后：[节点A] [节点B] [节点C]
```

### 1.2 为什么需要扩缩容


**扩容的常见原因**：
- 📈 **业务增长**：用户量增加，读写压力增大
- 🔧 **性能优化**：分散负载，提高查询响应速度
- 🛡️ **高可用增强**：更多节点提供更强的容错能力
- 📊 **读写分离**：增加只读节点处理查询请求

**缩容的常见原因**：
- 💰 **成本控制**：业务量下降，减少服务器开支
- 🔧 **资源整合**：硬件升级后单节点性能提升
- 🏗️ **架构调整**：业务重构导致的集群规模调整

### 1.3 MGR扩缩容的特点


**MGR的优势**：
```
在线操作：扩缩容过程中服务不中断
自动同步：新节点会自动同步所有数据
一致性保证：扩缩容过程保持数据一致性
简化运维：相比传统主从复制更容易操作
```

**需要注意的限制**：
- 📊 **节点数量限制**：建议不超过9个节点
- 🔄 **网络要求**：所有节点间网络延迟要低
- ⚖️ **奇数节点**：避免脑裂，建议保持奇数个节点
- 💾 **资源消耗**：节点越多，网络通信开销越大

---

## 2. ➕ 集群在线扩容操作


### 2.1 新节点准备工作


在给MGR集群添加新节点前，需要做好充分准备：

**🔧 硬件环境准备**
```
CPU要求：
- 建议与现有节点配置一致
- 最低4核心，推荐8核心以上

内存要求：
- 建议与现有节点一致
- 最低8GB，推荐16GB以上

存储要求：
- 使用SSD硬盘提升IO性能
- 确保有足够空间存储完整数据
```

**📦 软件环境准备**
```bash
# 1. 安装MySQL 8.0（与集群版本一致）
sudo apt update
sudo apt install mysql-server-8.0

# 2. 检查MySQL版本
mysql --version
# 输出：mysql Ver 8.0.35-0ubuntu0.22.04.1

# 3. 确保防火墙开放必要端口
sudo ufw allow 3306    # MySQL端口
sudo ufw allow 33061   # Group Replication端口
```

**⚙️ MySQL配置准备**
```ini
# /etc/mysql/mysql.conf.d/mysqld.cnf

[mysqld]
# 基础配置
server_id = 4                           # 新节点唯一ID
bind_address = 0.0.0.0
port = 3306

# Group Replication核心配置
plugin_load_add = 'group_replication.so'
group_replication_group_name = "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot = OFF
group_replication_local_address = "192.168.1.14:33061"
group_replication_group_seeds = "192.168.1.11:33061,192.168.1.12:33061,192.168.1.13:33061"

# 性能优化配置
innodb_buffer_pool_size = 2G
innodb_log_file_size = 256M
```

### 2.2 扩容操作步骤详解


**步骤1：准备新节点数据**

新节点需要有完整的数据才能加入集群：

```bash
# 方法一：从现有节点创建备份
# 在现有节点上执行
mysqldump -u root -p --single-transaction --routines --triggers --all-databases > backup.sql

# 在新节点上恢复
mysql -u root -p < backup.sql
```

```bash
# 方法二：使用MySQL Clone插件（推荐）
# 在新节点上执行
mysql -u root -p

# MySQL命令行中：
SET GLOBAL clone_valid_donor_list = '192.168.1.11:3306';
CLONE INSTANCE FROM 'cloneuser'@'192.168.1.11':3306
IDENTIFIED BY 'clonepass';
```

**步骤2：启动Group Replication**

```sql
-- 在新节点上执行
-- 1. 创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'replpass';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 2. 配置复制通道
CHANGE MASTER TO MASTER_USER='repl', MASTER_PASSWORD='replpass'
FOR CHANNEL 'group_replication_recovery';

-- 3. 启动Group Replication
START GROUP_REPLICATION;
```

**步骤3：验证扩容结果**

```sql
-- 检查节点状态
SELECT MEMBER_ID, MEMBER_HOST, MEMBER_PORT, MEMBER_STATE 
FROM performance_schema.replication_group_members;

-- 正常输出应该包含新节点：
-- +--------------------------------------+---------------+-------------+--------------+
-- | MEMBER_ID                            | MEMBER_HOST   | MEMBER_PORT | MEMBER_STATE |
-- +--------------------------------------+---------------+-------------+--------------+
-- | 6c97b4c8-b5f7-11ee-9999-0242ac110011 | 192.168.1.11  |        3306 | ONLINE       |
-- | 6c97b4c8-b5f7-11ee-9999-0242ac110012 | 192.168.1.12  |        3306 | ONLINE       |
-- | 6c97b4c8-b5f7-11ee-9999-0242ac110013 | 192.168.1.13  |        3306 | ONLINE       |
-- | 6c97b4c8-b5f7-11ee-9999-0242ac110014 | 192.168.1.14  |        3306 | ONLINE       |
-- +--------------------------------------+---------------+-------------+--------------+
```

### 2.3 扩容验证检查


**📊 数据一致性检查**
```sql
-- 在新节点上检查数据
SELECT COUNT(*) FROM information_schema.tables;

-- 在原节点上检查相同数据
-- 确保数量一致

-- 检查关键业务表的数据行数
SELECT COUNT(*) FROM your_important_table;
```

**🔄 复制状态检查**
```sql
-- 检查复制延迟
SELECT MEMBER_HOST, 
       COUNT_TRANSACTIONS_IN_QUEUE,
       COUNT_TRANSACTIONS_CHECKED,
       COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE
FROM performance_schema.replication_group_member_stats;
```

**⚡ 性能影响测试**
```bash
# 简单的读写测试
# 创建测试表
mysql -u root -p -e "
CREATE DATABASE IF NOT EXISTS test_db;
USE test_db;
CREATE TABLE test_table (id INT AUTO_INCREMENT PRIMARY KEY, data VARCHAR(100));
"

# 插入测试数据
for i in {1..1000}; do
    mysql -u root -p test_db -e "INSERT INTO test_table (data) VALUES ('test_data_$i');"
done

# 检查所有节点数据是否一致
mysql -u root -p test_db -e "SELECT COUNT(*) FROM test_table;"
```

---

## 3. ➖ 集群安全缩容操作


### 3.1 缩容前的评估工作


在移除MGR节点前，必须做好充分评估：

**🎯 影响评估清单**
```
业务影响评估：
□ 当前读写负载分布
□ 移除节点后的负载重分布
□ 是否影响业务连接池配置
□ 客户端连接是否需要调整

技术风险评估：
□ 仲裁节点数量是否足够（避免脑裂）
□ 剩余节点性能是否能承受增加的负载
□ 数据迁移是否需要特殊处理
□ 是否有业务直连要移除的节点
```

**⚖️ 仲裁节点保护**

MGR使用多数派仲裁机制，必须保证剩余节点数量 > 总节点数/2：

```
原则：保持奇数个节点，避免脑裂

安全的缩容场景：
5节点 → 3节点 ✅ (3 > 5/2)
4节点 → 3节点 ✅ (3 > 4/2)  
3节点 → 2节点 ❌ (2 = 3/2，可能脑裂)

推荐的节点数量：
生产环境：3个或5个节点
测试环境：可以使用单节点
```

### 3.2 节点下线流程


**步骤1：确认要移除的节点**

```sql
-- 查看当前所有节点
SELECT MEMBER_ID, MEMBER_HOST, MEMBER_PORT, MEMBER_STATE, MEMBER_ROLE 
FROM performance_schema.replication_group_members;

-- 确定要移除的节点（比如192.168.1.15）
-- 记录该节点的MEMBER_ID
```

**步骤2：优雅停止目标节点**

```sql
-- 在要移除的节点上执行
-- 1. 停止接受新的写入请求
SET GLOBAL super_read_only = ON;

-- 2. 等待事务队列清空
SELECT COUNT_TRANSACTIONS_IN_QUEUE 
FROM performance_schema.replication_group_member_stats 
WHERE MEMBER_ID = $$server_uuid;

-- 3. 停止Group Replication
STOP GROUP_REPLICATION;
```

**步骤3：从其他节点移除该成员**

```sql
-- 在任意剩余节点上执行
-- 查看Group Replication状态
SELECT * FROM performance_schema.replication_group_members;

-- 正常情况下，停止GR的节点会自动从视图中移除
-- 如果没有自动移除，可以等待超时自动清理
```

**步骤4：清理配置信息**

```bash
# 在被移除的节点上
# 1. 停止MySQL服务
sudo systemctl stop mysql

# 2. 清理Group Replication相关配置（可选）
# 编辑 /etc/mysql/mysql.conf.d/mysqld.cnf
# 注释掉Group Replication相关配置

# 3. 如果不再需要，可以完全卸载
sudo apt remove mysql-server
```

### 3.3 数据迁移策略


在某些场景下，被移除的节点可能承载特殊业务：

**📊 业务连接迁移**
```python
# 应用程序连接池配置调整示例
# 原配置：连接3个节点
MYSQL_HOSTS = [
    "192.168.1.11:3306",
    "192.168.1.12:3306", 
    "192.168.1.13:3306"
]

# 缩容后：移除其中一个节点
MYSQL_HOSTS = [
    "192.168.1.11:3306",
    "192.168.1.12:3306"
]
```

**🔄 负载重分布验证**
```sql
-- 监控剩余节点的负载情况
-- 检查CPU使用率
SELECT THREAD_ID, PROCESSLIST_USER, PROCESSLIST_HOST, PROCESSLIST_COMMAND 
FROM performance_schema.threads 
WHERE PROCESSLIST_COMMAND IS NOT NULL;

-- 检查连接数
SHOW GLOBAL STATUS LIKE 'Threads_connected';

-- 检查QPS
SHOW GLOBAL STATUS LIKE 'Questions';
```

---

## 4. 📊 扩缩容影响评估与监控


### 4.1 容量规划方法


**📈 负载评估模型**

扩容前需要评估当前负载和未来需求：

```
当前负载指标：
- QPS（每秒查询数）
- TPS（每秒事务数）  
- 连接数峰值
- CPU利用率
- 内存使用率
- 磁盘IO

扩容决策公式：
新节点数 = 当前节点数 × (预期负载增长 / 当前节点平均承载能力)

示例计算：
当前：3节点，总QPS=3000，CPU平均70%
预期：QPS增长到6000
计算：6000/3000 = 2倍增长
建议：扩容到5-6个节点
```

**📊 容量规划工具**

```bash
# 简单的负载监控脚本
#!/bin/bash
# monitor_load.sh

while true; do
    echo "=== $(date) ==="
    
    # MySQL连接数
    mysql -u monitor -p -e "SHOW GLOBAL STATUS LIKE 'Threads_connected';"
    
    # QPS统计
    mysql -u monitor -p -e "SHOW GLOBAL STATUS LIKE 'Questions';"
    
    # CPU和内存使用率
    top -bn1 | grep "Cpu(s)"
    free -h
    
    echo "===================="
    sleep 60
done
```

### 4.2 扩缩容监控指标


**🔍 关键监控指标**

```sql
-- 1. Group Replication健康状态
SELECT 
    MEMBER_HOST,
    MEMBER_STATE,
    MEMBER_ROLE,
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE
FROM performance_schema.replication_group_member_stats 
JOIN performance_schema.replication_group_members USING(MEMBER_ID);
```

```sql
-- 2. 复制延迟监控
SELECT 
    MEMBER_HOST,
    COUNT_TRANSACTIONS_IN_QUEUE as "待处理事务",
    COUNT_TRANSACTIONS_CHECKED as "已检查事务",
    COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE as "应用队列长度"
FROM performance_schema.replication_group_member_stats
JOIN performance_schema.replication_group_members USING(MEMBER_ID);
```

**⚠️ 告警阈值设置**

| 指标 | 正常范围 | 警告阈值 | 严重阈值 |
|------|----------|----------|----------|
| **复制延迟** | < 100 事务 | > 500 事务 | > 1000 事务 |
| **节点状态** | ONLINE | RECOVERING | ERROR |
| **CPU使用率** | < 70% | > 80% | > 90% |
| **内存使用率** | < 80% | > 85% | > 95% |
| **连接数** | < 80% max | > 90% max | > 95% max |

### 4.3 性能影响分析


**📊 扩容对性能的影响**

```
正面影响：
✅ 读负载分散，单节点压力减小
✅ 更多节点提供服务，整体吞吐量提升
✅ 故障容错能力增强

负面影响：
❌ 网络通信开销增加（O(n²)增长）
❌ 事务提交需要更多节点确认，延迟可能增加
❌ 管理复杂度提升

性能测试结果示例：
3节点 → 5节点扩容后：
- 读QPS提升40%
- 写TPS下降5%（网络开销）
- 事务延迟增加10ms
```

**🔄 缩容对性能的影响**

```
正面影响：
✅ 网络通信开销减少
✅ 事务提交确认更快
✅ 管理复杂度降低

负面影响：
❌ 单节点负载增加
❌ 故障容错能力下降
❌ 可能出现性能瓶颈

风险评估：
5节点 → 3节点缩容：
- 单节点负载增加67%
- 需确保剩余节点有足够性能
- 监控CPU/内存/IO指标
```

---

## 5. 🤖 自动化扩缩容方案


### 5.1 自动化扩容脚本


**🔧 基于负载的自动扩容**

```bash
#!/bin/bash
# auto_scale_up.sh - MGR自动扩容脚本

# 配置参数
THRESHOLD_CPU=80          # CPU阈值
THRESHOLD_CONNECTIONS=80  # 连接数阈值百分比
MAX_NODES=7              # 最大节点数
CHECK_INTERVAL=300       # 检查间隔（秒）

# 获取当前集群状态
get_cluster_status() {
    mysql -u monitor -pmonitorpass -e "
    SELECT COUNT(*) as node_count 
    FROM performance_schema.replication_group_members 
    WHERE MEMBER_STATE='ONLINE';" -N
}

# 检查负载指标
check_load() {
    # 检查CPU使用率
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    
    # 检查连接数
    CURRENT_CONN=$(mysql -u monitor -pmonitorpass -e "SHOW GLOBAL STATUS LIKE 'Threads_connected';" -N | cut -f2)
    MAX_CONN=$(mysql -u monitor -pmonitorpass -e "SHOW VARIABLES LIKE 'max_connections';" -N | cut -f2)
    CONN_USAGE=$((CURRENT_CONN * 100 / MAX_CONN))
    
    echo "CPU: ${CPU_USAGE}%, Connections: ${CONN_USAGE}%"
    
    # 判断是否需要扩容
    if (( $(echo "$CPU_USAGE > $THRESHOLD_CPU" | bc -l) )) || (( CONN_USAGE > THRESHOLD_CONNECTIONS )); then
        return 0  # 需要扩容
    else
        return 1  # 不需要扩容
    fi
}

# 执行扩容操作
perform_scale_up() {
    CURRENT_NODES=$(get_cluster_status)
    
    if (( CURRENT_NODES >= MAX_NODES )); then
        echo "已达到最大节点数 $MAX_NODES，无法继续扩容"
        return 1
    fi
    
    echo "开始自动扩容..."
    
    # 这里调用具体的扩容脚本
    # ./add_new_node.sh
    
    echo "扩容操作已触发，请检查新节点状态"
}

# 主循环
while true; do
    echo "=== $(date) ==="
    
    if check_load; then
        echo "负载超过阈值，准备扩容"
        perform_scale_up
        # 扩容后等待更长时间再次检查
        sleep $((CHECK_INTERVAL * 3))
    else
        echo "负载正常，无需扩容"
        sleep $CHECK_INTERVAL
    fi
done
```

### 5.2 基于云平台的自动化


**☁️ 使用Docker Swarm自动扩容**

```yaml
# docker-compose.yml
version: '3.8'
services:
  mysql-mgr:
    image: mysql:8.0
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 30s
      resources:
        limits:
          cpus: '2'
          memory: 4G
        reservations:
          cpus: '1'
          memory: 2G
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: testdb
    configs:
      - source: mysql_config
        target: /etc/mysql/conf.d/mysql.cnf
    networks:
      - mgr_network

configs:
  mysql_config:
    file: ./mysql.cnf

networks:
  mgr_network:
    driver: overlay
```

```bash
# 自动扩容命令
# 扩容到5个节点
docker service scale mysql-mgr_mysql-mgr=5

# 缩容到3个节点  
docker service scale mysql-mgr_mysql-mgr=3
```

### 5.3 监控集成方案


**📊 Prometheus + Grafana监控**

```yaml
# prometheus.yml 配置片段
scrape_configs:
  - job_name: 'mysql-mgr'
    static_configs:
      - targets: 
        - '192.168.1.11:9104'  # MySQL Exporter
        - '192.168.1.12:9104'
        - '192.168.1.13:9104'
    scrape_interval: 30s
    
# 告警规则
groups:
  - name: mgr_alerts
    rules:
      - alert: MGR_HighCPU
        expr: cpu_usage > 80
        for: 5m
        annotations:
          summary: "MGR节点CPU使用率过高"
          
      - alert: MGR_HighConnections  
        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections > 0.8
        for: 5m
        annotations:
          summary: "MGR节点连接数过高"
```

**🔔 自动化响应**

```python
# alertmanager_webhook.py
from flask import Flask, request
import subprocess
import json

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def handle_alert():
    data = request.get_json()
    
    for alert in data.get('alerts', []):
        alert_name = alert.get('labels', {}).get('alertname')
        
        if alert_name == 'MGR_HighCPU':
            # 触发自动扩容
            result = subprocess.run(['./auto_scale_up.sh'], 
                                  capture_output=True, text=True)
            print(f"自动扩容结果: {result.stdout}")
            
        elif alert_name == 'MGR_LowLoad':
            # 触发自动缩容（谨慎操作）
            print("检测到低负载，建议人工评估是否缩容")
    
    return 'OK'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=9093)
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 扩容本质：在线增加节点，提升集群处理能力
🔸 缩容本质：安全移除节点，保持仲裁机制正常
🔸 操作特点：MGR支持在线扩缩容，服务不中断
🔸 关键限制：节点数量建议不超过9个，保持奇数个节点
🔸 核心原则：扩容前做好准备，缩容前评估影响
```

### 6.2 实际操作要点


**🔹 扩容操作核心步骤**
```
1. 准备新节点（硬件、软件、配置）
2. 同步数据（Clone插件或备份恢复）
3. 加入集群（START GROUP_REPLICATION）
4. 验证结果（检查节点状态和数据一致性）
```

**🔹 缩容操作核心步骤**
```
1. 评估影响（仲裁机制、业务连接）
2. 优雅下线（停止写入、清空队列、停止GR）
3. 配置调整（应用连接池、负载重分布）
4. 监控验证（剩余节点负载、性能指标）
```

**🔹 关键注意事项**
```
仲裁保护：剩余节点数 > 总节点数/2
数据一致性：扩容后验证数据完整性
性能影响：监控网络开销和事务延迟
业务连续性：调整应用连接配置
```

### 6.3 最佳实践建议


**📊 容量规划**
- 基于历史负载数据制定扩容策略
- 考虑业务增长预期，预留足够容量
- 定期评估集群性能，及时调整规模

**🔧 自动化运维**
- 建立监控告警体系，及时发现问题
- 开发自动化脚本，提高运维效率
- 结合云平台能力，实现弹性伸缩

**⚠️ 风险控制**
- 扩缩容前做好备份，确保数据安全
- 在测试环境先验证操作流程
- 制定回滚方案，应对异常情况

**核心记忆**：
- MGR扩缩容支持在线操作，保证服务连续性
- 扩容重点在准备工作，缩容重点在影响评估
- 始终保持奇数个节点，避免脑裂风险
- 监控和自动化是提升运维效率的关键