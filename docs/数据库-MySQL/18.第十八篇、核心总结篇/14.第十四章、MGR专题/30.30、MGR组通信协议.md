---
title: 30ã€MGRç»„é€šä¿¡åè®®
---
## ğŸ“š ç›®å½•

1. [MGRç»„é€šä¿¡åè®®æ¦‚è¿°](#1-MGRç»„é€šä¿¡åè®®æ¦‚è¿°)
2. [GCSé€šä¿¡å±‚æ¶æ„](#2-GCSé€šä¿¡å±‚æ¶æ„)
3. [XCOMåè®®è¯¦è§£](#3-XCOMåè®®è¯¦è§£)
4. [æ¶ˆæ¯ä¼ é€’æœºåˆ¶](#4-æ¶ˆæ¯ä¼ é€’æœºåˆ¶)
5. [æ•…éšœæ£€æµ‹ä¸è§†å›¾å˜æ›´](#5-æ•…éšœæ£€æµ‹ä¸è§†å›¾å˜æ›´)
6. [ç½‘ç»œåˆ†åŒºå¤„ç†](#6-ç½‘ç»œåˆ†åŒºå¤„ç†)
7. [é€šä¿¡å®‰å…¨ä¸åŠ å¯†](#7-é€šä¿¡å®‰å…¨ä¸åŠ å¯†)
8. [åè®®è°ƒè¯•ä¸æ•…éšœåˆ†æ](#8-åè®®è°ƒè¯•ä¸æ•…éšœåˆ†æ)
9. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#9-æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
10. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#10-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸŒ MGRç»„é€šä¿¡åè®®æ¦‚è¿°


### 1.1 ä»€ä¹ˆæ˜¯ç»„é€šä¿¡åè®®


**ğŸ’¡ ç”Ÿæ´»ç±»æ¯”**
> æƒ³è±¡ä¸€ä¸ªå¾®ä¿¡ç¾¤èŠï¼Œç¾¤é‡Œçš„æ¯ä¸ªäººéƒ½èƒ½çœ‹åˆ°æ‰€æœ‰æ¶ˆæ¯ï¼Œæ¶ˆæ¯æŒ‰é¡ºåºæ˜¾ç¤ºï¼Œå³ä½¿æœ‰äººç½‘ç»œä¸å¥½æš‚æ—¶æ‰çº¿ï¼Œé‡æ–°ä¸Šçº¿åä¹Ÿèƒ½çœ‹åˆ°ä¹‹å‰çš„æ¶ˆæ¯ã€‚MGRçš„ç»„é€šä¿¡åè®®å°±æ˜¯è¿™æ ·ä¸€ä¸ª"æ•°æ®åº“ç¾¤èŠ"ç³»ç»Ÿã€‚

**ğŸ”¸ æ ¸å¿ƒå®šä¹‰**
```
ç»„é€šä¿¡åè®®ï¼šç¡®ä¿åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å¤šä¸ªèŠ‚ç‚¹èƒ½å¤Ÿ
â€¢ å¯é åœ°ä¼ é€’æ¶ˆæ¯
â€¢ ä¿è¯æ¶ˆæ¯é¡ºåºä¸€è‡´
â€¢ å¤„ç†èŠ‚ç‚¹æ•…éšœå’Œç½‘ç»œåˆ†åŒº
â€¢ ç»´æŠ¤ç¾¤ç»„æˆå‘˜è§†å›¾
```

**ğŸ“Š MGRé€šä¿¡åè®®æ ˆ**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     MySQL Server        â”‚ â† åº”ç”¨å±‚ï¼šäº‹åŠ¡å¤„ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Group Replication     â”‚ â† MGRæ’ä»¶ï¼šå¤åˆ¶é€»è¾‘
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    GCS (Group Comm)     â”‚ â† GCSå±‚ï¼šç»„é€šä¿¡æŠ½è±¡
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       XCOM             â”‚ â† XCOMåè®®ï¼šä¸€è‡´æ€§ç®—æ³•
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Network Layer       â”‚ â† ç½‘ç»œå±‚ï¼šTCP/SSL
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦ç»„é€šä¿¡åè®®


**ğŸ¤” æ²¡æœ‰ç»„é€šä¿¡åè®®ä¼šæ€æ ·ï¼Ÿ**
```
é—®é¢˜åœºæ™¯ï¼š
èŠ‚ç‚¹A: æ‰§è¡Œäº‹åŠ¡1ï¼Œé€šçŸ¥Bã€C
èŠ‚ç‚¹B: æ‰§è¡Œäº‹åŠ¡2ï¼Œé€šçŸ¥Aã€C  
èŠ‚ç‚¹C: æ‰§è¡Œäº‹åŠ¡3ï¼Œé€šçŸ¥Aã€B

å¯èƒ½å‡ºç°çš„é—®é¢˜ï¼š
âŒ æ¶ˆæ¯ä¸¢å¤±ï¼šç½‘ç»œæ•…éšœå¯¼è‡´é€šçŸ¥å¤±è´¥
âŒ é¡ºåºæ··ä¹±ï¼šä¸åŒèŠ‚ç‚¹çœ‹åˆ°ä¸åŒçš„æ‰§è¡Œé¡ºåº
âŒ è„‘è£‚ï¼šç½‘ç»œåˆ†åŒºå¯¼è‡´å¤šä¸ª"ä¸»"èŠ‚ç‚¹
âŒ æ•°æ®ä¸ä¸€è‡´ï¼šæœ€ç»ˆå„èŠ‚ç‚¹æ•°æ®ä¸åŒ
```

**âœ… ç»„é€šä¿¡åè®®è§£å†³æ–¹æ¡ˆ**
```
ä¿è¯æœºåˆ¶ï¼š
ğŸ”¸ æ¶ˆæ¯å¯é ä¼ é€’ï¼šç¡®ä¿æ‰€æœ‰å­˜æ´»èŠ‚ç‚¹éƒ½èƒ½æ”¶åˆ°
ğŸ”¸ å…¨åºå¹¿æ’­ï¼šæ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒçš„æ¶ˆæ¯é¡ºåº  
ğŸ”¸ æ•…éšœæ£€æµ‹ï¼šåŠæ—¶å‘ç°èŠ‚ç‚¹æ•…éšœ
ğŸ”¸ æˆå‘˜ç®¡ç†ï¼šç»´æŠ¤å½“å‰ç¾¤ç»„æˆå‘˜åˆ—è¡¨
ğŸ”¸ ç½‘ç»œåˆ†åŒºå¤„ç†ï¼šé˜²æ­¢è„‘è£‚é—®é¢˜
```

### 1.3 MGRé€šä¿¡åè®®çš„ç‰¹ç‚¹


**ğŸ“‹ æ ¸å¿ƒç‰¹æ€§**
- **åŸå­å¹¿æ’­**ï¼šæ¶ˆæ¯è¦ä¹ˆè¢«æ‰€æœ‰èŠ‚ç‚¹æ¥æ”¶ï¼Œè¦ä¹ˆéƒ½ä¸æ¥æ”¶
- **å…¨åºä¿è¯**ï¼šæ‰€æœ‰èŠ‚ç‚¹æŒ‰ç›¸åŒé¡ºåºå¤„ç†æ¶ˆæ¯
- **æ•…éšœé€æ˜**ï¼šå¯¹ä¸Šå±‚åº”ç”¨éšè—ç½‘ç»œæ•…éšœç»†èŠ‚
- **åŠ¨æ€æˆå‘˜**ï¼šæ”¯æŒèŠ‚ç‚¹åŠ¨æ€åŠ å…¥å’Œç¦»å¼€
- **åˆ†åŒºå®¹é”™**ï¼šå¤„ç†ç½‘ç»œåˆ†åŒºå’Œæ¢å¤

---

## 2. ğŸ—ï¸ GCSé€šä¿¡å±‚æ¶æ„


### 2.1 GCSå±‚æ˜¯ä»€ä¹ˆ


**ğŸ”¸ GCSå®šä¹‰**
```
GCS (Group Communication Service)ï¼šç»„é€šä¿¡æœåŠ¡
ä½œç”¨ï¼šä¸ºMGRæä¾›ç»Ÿä¸€çš„ç»„é€šä¿¡æ¥å£
ä½ç½®ï¼šMGRæ’ä»¶å’Œåº•å±‚XCOMåè®®ä¹‹é—´çš„æŠ½è±¡å±‚
```

**ğŸ¯ è®¾è®¡ç†å¿µ**
> GCSå±‚å°±åƒæ˜¯"ç¿»è¯‘å®˜"ï¼ŒæŠŠMGRçš„é«˜çº§éœ€æ±‚ç¿»è¯‘æˆåº•å±‚XCOMåè®®èƒ½ç†è§£çš„æŒ‡ä»¤ï¼ŒåŒæ—¶æŠŠXCOMçš„å¤æ‚ç»†èŠ‚åŒ…è£…æˆMGRå®¹æ˜“ä½¿ç”¨çš„æ¥å£ã€‚

### 2.2 GCSå±‚æ¶æ„ç»„ä»¶


**ğŸ“Š GCSå±‚ç»“æ„å›¾**
```
MGR Plugin
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           GCS Layer             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Message Service â”‚ View Service â”‚ â† æœåŠ¡æ¥å£
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Event Handler â”‚ State Mgmt   â”‚ â† äº‹ä»¶å¤„ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Communication Interface       â”‚ â† é€šä¿¡æ¥å£
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
XCOM Protocol
```

**ğŸ”§ æ ¸å¿ƒç»„ä»¶åŠŸèƒ½**

**æ¶ˆæ¯æœåŠ¡ (Message Service)**
```
åŠŸèƒ½ï¼š
â€¢ æ¶ˆæ¯å‘é€ï¼šå¹¿æ’­äº‹åŠ¡æ—¥å¿—åˆ°å…¶ä»–èŠ‚ç‚¹
â€¢ æ¶ˆæ¯æ¥æ”¶ï¼šå¤„ç†æ¥è‡ªå…¶ä»–èŠ‚ç‚¹çš„æ¶ˆæ¯
â€¢ æ¶ˆæ¯æ’åºï¼šç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒé¡ºåº
â€¢ æ¶ˆæ¯è¿‡æ»¤ï¼šè¿‡æ»¤é‡å¤æˆ–æ— æ•ˆæ¶ˆæ¯

ç¤ºä¾‹æ¶ˆæ¯ç±»å‹ï¼š
- äº‹åŠ¡æäº¤æ¶ˆæ¯ï¼štransaction_commit_message
- è§†å›¾å˜æ›´æ¶ˆæ¯ï¼šview_change_message  
- æ¢å¤æ¶ˆæ¯ï¼šrecovery_message
```

**è§†å›¾æœåŠ¡ (View Service)**
```
åŠŸèƒ½ï¼š
â€¢ æˆå‘˜ç®¡ç†ï¼šç»´æŠ¤å½“å‰ç»„æˆå‘˜åˆ—è¡¨
â€¢ è§†å›¾å˜æ›´ï¼šå¤„ç†èŠ‚ç‚¹åŠ å…¥/ç¦»å¼€äº‹ä»¶
â€¢ çŠ¶æ€åŒæ­¥ï¼šåŒæ­¥å„èŠ‚ç‚¹çš„è§†å›¾çŠ¶æ€
â€¢ æ•…éšœæ£€æµ‹ï¼šæ£€æµ‹èŠ‚ç‚¹æ˜¯å¦æ­£å¸¸å·¥ä½œ

è§†å›¾ä¿¡æ¯åŒ…å«ï¼š
- æˆå‘˜åˆ—è¡¨ï¼šå½“å‰æ´»è·ƒçš„èŠ‚ç‚¹ID
- è§†å›¾IDï¼šæ ‡è¯†è§†å›¾çš„ç‰ˆæœ¬å·
- ä¸»èŠ‚ç‚¹ï¼šå½“å‰çš„PrimaryèŠ‚ç‚¹
- çŠ¶æ€ä¿¡æ¯ï¼šå„èŠ‚ç‚¹çš„çŠ¶æ€
```

### 2.3 GCSæ¥å£è®¾è®¡


**ğŸ“ ä¸»è¦APIæ¥å£**
```cpp
class GCS_interface {
public:
    // æ¶ˆæ¯æ“ä½œ
    virtual int send_message(const GCS_message& msg) = 0;
    virtual int receive_message(GCS_message& msg) = 0;
    
    // è§†å›¾æ“ä½œ  
    virtual int join_group(const string& group_id) = 0;
    virtual int leave_group() = 0;
    virtual GCS_view get_current_view() = 0;
    
    // äº‹ä»¶å¤„ç†
    virtual void register_event_handler(GCS_event_handler* handler) = 0;
    
    // é…ç½®ç®¡ç†
    virtual int configure(const GCS_config& config) = 0;
};
```

**ğŸ’» ä½¿ç”¨ç¤ºä¾‹**
```cpp
// MGRæ’ä»¶ä½¿ç”¨GCSå‘é€äº‹åŠ¡æ¶ˆæ¯
void MGR_plugin::broadcast_transaction() {
    // 1. æ„é€ æ¶ˆæ¯
    GCS_message msg;
    msg.set_type(TRANSACTION_MESSAGE);
    msg.set_payload(transaction_data);
    
    // 2. é€šè¿‡GCSå‘é€
    int result = gcs_interface->send_message(msg);
    
    if (result == GCS_OK) {
        // æ¶ˆæ¯å‘é€æˆåŠŸ
        log_info("Transaction broadcasted successfully");
    } else {
        // å¤„ç†å‘é€å¤±è´¥
        handle_send_error(result);
    }
}
```

---

## 3. âš™ï¸ XCOMåè®®è¯¦è§£


### 3.1 XCOMåè®®æ¦‚è¿°


**ğŸ”¸ XCOMæ˜¯ä»€ä¹ˆ**
```
XCOMï¼šMGRåº•å±‚ä½¿ç”¨çš„åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®
æ¥æºï¼šåŸºäºPaxosç®—æ³•çš„å®ç°
ç›®æ ‡ï¼šåœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­è¾¾æˆä¸€è‡´æ€§å†³ç­–
ç‰¹ç‚¹ï¼šå®¹é”™ã€é«˜æ•ˆã€å¯æ‰©å±•
```

**ğŸ  ç”Ÿæ´»ç±»æ¯”**
> XCOMåè®®å°±åƒæ˜¯ä¸€ä¸ª"æ°‘ä¸»æŠ•ç¥¨ç³»ç»Ÿ"ã€‚å½“ç¾¤ç»„éœ€è¦åšå†³å®šæ—¶ï¼ˆæ¯”å¦‚æ¥å—ä¸€ä¸ªæ–°çš„äº‹åŠ¡ï¼‰ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½å‚ä¸æŠ•ç¥¨ï¼Œåªæœ‰è·å¾—å¤§å¤šæ•°æ”¯æŒçš„å†³å®šæ‰ä¼šè¢«æ‰§è¡Œï¼Œè¿™æ ·å³ä½¿å°‘æ•°èŠ‚ç‚¹å‡ºç°é—®é¢˜ä¹Ÿä¸ä¼šå½±å“æ•´ä½“å†³ç­–ã€‚

### 3.2 XCOMåè®®æ ¸å¿ƒæ¦‚å¿µ


**ğŸ“‹ åŸºæœ¬æ¦‚å¿µè§£é‡Š**

**Proposerï¼ˆæè®®è€…ï¼‰**
```
ä½œç”¨ï¼šæå‡ºæ–°çš„ææ¡ˆï¼ˆæ¯”å¦‚ä¸€ä¸ªäº‹åŠ¡ï¼‰
èŒè´£ï¼š
â€¢ ç”Ÿæˆå”¯ä¸€çš„ææ¡ˆç¼–å·
â€¢ å‘Acceptorå‘é€ææ¡ˆ
â€¢ æ”¶é›†æŠ•ç¥¨ç»“æœ
â€¢ å†³å®šææ¡ˆæ˜¯å¦é€šè¿‡

åœ¨MGRä¸­ï¼šé€šå¸¸æ˜¯PrimaryèŠ‚ç‚¹
```

**Acceptorï¼ˆæ¥å—è€…ï¼‰**
```
ä½œç”¨ï¼šå¯¹ææ¡ˆè¿›è¡ŒæŠ•ç¥¨
èŒè´£ï¼š
â€¢ æ¥æ”¶Proposerçš„ææ¡ˆ
â€¢ æ ¹æ®ç®—æ³•è§„åˆ™è¿›è¡ŒæŠ•ç¥¨
â€¢ ä¿å­˜å·²æ¥å—çš„ææ¡ˆ
â€¢ ç¡®ä¿ä¸€è‡´æ€§çº¦æŸ

åœ¨MGRä¸­ï¼šæ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯Acceptor
```

**Learnerï¼ˆå­¦ä¹ è€…ï¼‰**
```
ä½œç”¨ï¼šå­¦ä¹ å·²ç»è¾¾æˆä¸€è‡´çš„å†³å®š
èŒè´£ï¼š
â€¢ è·å–å·²ç¡®å®šçš„ææ¡ˆ
â€¢ æ‰§è¡Œç›¸åº”çš„æ“ä½œ
â€¢ ä¿æŒä¸å…¶ä»–èŠ‚ç‚¹åŒæ­¥

åœ¨MGRä¸­ï¼šæ‰€æœ‰èŠ‚ç‚¹åŒæ—¶ä¹Ÿæ˜¯Learner
```

### 3.3 XCOMåè®®å·¥ä½œæµç¨‹


**ğŸ“Š åè®®æ‰§è¡Œæµç¨‹**
```
é˜¶æ®µ1ï¼šPrepare (å‡†å¤‡é˜¶æ®µ)
Proposer â†’ Acceptors: Prepare(n)
Acceptors â†’ Proposer: Promise(n, å·²æ¥å—çš„æœ€å¤§ææ¡ˆ)

é˜¶æ®µ2ï¼šAccept (æ¥å—é˜¶æ®µ)  
Proposer â†’ Acceptors: Accept(n, value)
Acceptors â†’ Proposer: Accepted(n, value)

é˜¶æ®µ3ï¼šCommit (æäº¤é˜¶æ®µ)
Proposer â†’ All: Commit(n, value)
All Nodes: æ‰§è¡Œvalueå¯¹åº”çš„æ“ä½œ
```

**ğŸ’¡ å…·ä½“ç¤ºä¾‹ï¼šäº‹åŠ¡æäº¤è¿‡ç¨‹**
```
åœºæ™¯ï¼šNode1è¦æäº¤ä¸€ä¸ªäº‹åŠ¡

æ­¥éª¤1ï¼šPrepareé˜¶æ®µ
Node1 â†’ Node2,Node3: "æˆ‘æƒ³æäº¤ææ¡ˆ#100"
Node2 â†’ Node1: "åŒæ„ï¼Œæˆ‘ä¹‹å‰æ¥å—çš„æœ€å¤§ææ¡ˆæ˜¯#95"  
Node3 â†’ Node1: "åŒæ„ï¼Œæˆ‘ä¹‹å‰æ¥å—çš„æœ€å¤§ææ¡ˆæ˜¯#98"

æ­¥éª¤2ï¼šAccepté˜¶æ®µ
Node1 â†’ Node2,Node3: "è¯·æ¥å—ææ¡ˆ#100ï¼šäº‹åŠ¡XYZ"
Node2 â†’ Node1: "å·²æ¥å—ææ¡ˆ#100"
Node3 â†’ Node1: "å·²æ¥å—ææ¡ˆ#100"

æ­¥éª¤3ï¼šCommité˜¶æ®µ
Node1 â†’ All: "ææ¡ˆ#100å·²é€šè¿‡ï¼Œæ‰§è¡Œäº‹åŠ¡XYZ"
All Nodes: æ‰§è¡Œäº‹åŠ¡XYZï¼Œæ›´æ–°æ•°æ®
```

### 3.4 XCOMåè®®çš„ä¼˜åŒ–


**âš¡ Multi-Paxosä¼˜åŒ–**
```
é—®é¢˜ï¼šç»å…¸Paxosæ¯æ¬¡å†³ç­–éƒ½è¦ä¸¤ä¸ªé˜¶æ®µï¼Œæ•ˆç‡ä½
è§£å†³ï¼šé€‰å‡ºä¸€ä¸ªLeaderï¼Œå‡å°‘Prepareé˜¶æ®µ

ä¼˜åŒ–åæµç¨‹ï¼š
Leaderç›´æ¥è¿›å…¥Accepté˜¶æ®µ
Only when Leader changes: é‡æ–°è¿›è¡ŒPrepare
```

**ğŸ”§ MGRä¸­çš„XCOMä¼˜åŒ–**
```
æ‰¹é‡å¤„ç†ï¼š
â€¢ å°†å¤šä¸ªå°äº‹åŠ¡æ‰“åŒ…æˆä¸€ä¸ªææ¡ˆ
â€¢ å‡å°‘ç½‘ç»œå¾€è¿”æ¬¡æ•°
â€¢ æé«˜æ•´ä½“ååé‡

æµæ°´çº¿å¤„ç†ï¼š
â€¢ ä¸ç­‰å‰ä¸€ä¸ªææ¡ˆå®Œæˆå°±å¼€å§‹ä¸‹ä¸€ä¸ª
â€¢ ææ¡ˆç¼–å·è¿ç»­åˆ†é…
â€¢ å¹¶è¡Œå¤„ç†å¤šä¸ªææ¡ˆ

æœ¬åœ°ä¼˜åŒ–ï¼š
â€¢ å•èŠ‚ç‚¹äº‹åŠ¡æœ¬åœ°æ‰§è¡Œ
â€¢ åªå¯¹å¤šèŠ‚ç‚¹å†²çªäº‹åŠ¡ä½¿ç”¨XCOM
â€¢ å‡å°‘ä¸å¿…è¦çš„ç½‘ç»œé€šä¿¡
```

---

## 4. ğŸ“¨ æ¶ˆæ¯ä¼ é€’æœºåˆ¶


### 4.1 æ¶ˆæ¯ç±»å‹ä¸ç»“æ„


**ğŸ“‹ MGRæ¶ˆæ¯åˆ†ç±»**
```
æŒ‰åŠŸèƒ½åˆ†ç±»ï¼š
ğŸ”¸ æ•°æ®æ¶ˆæ¯ï¼šäº‹åŠ¡å†…å®¹ã€çŠ¶æ€æ›´æ–°
ğŸ”¸ æ§åˆ¶æ¶ˆæ¯ï¼šè§†å›¾å˜æ›´ã€é…ç½®ä¿®æ”¹  
ğŸ”¸ æ¢å¤æ¶ˆæ¯ï¼šèŠ‚ç‚¹é‡æ–°åŠ å…¥æ—¶çš„æ•°æ®åŒæ­¥
ğŸ”¸ å¿ƒè·³æ¶ˆæ¯ï¼šæ£€æµ‹èŠ‚ç‚¹æ˜¯å¦å­˜æ´»

æŒ‰ä¼˜å…ˆçº§åˆ†ç±»ï¼š
ğŸ”¸ ç´§æ€¥æ¶ˆæ¯ï¼šæ•…éšœæ£€æµ‹ã€è§†å›¾å˜æ›´
ğŸ”¸ æ™®é€šæ¶ˆæ¯ï¼šå¸¸è§„äº‹åŠ¡
ğŸ”¸ æ‰¹é‡æ¶ˆæ¯ï¼šæ‰¹å¤„ç†äº‹åŠ¡
```

**ğŸ“Š æ¶ˆæ¯ç»“æ„è¯¦è§£**
```
MGRæ¶ˆæ¯æ ¼å¼ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Message Headerâ”‚ â† æ¶ˆæ¯å¤´ï¼šç±»å‹ã€å¤§å°ã€æ—¶é—´æˆ³
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Sender Info   â”‚ â† å‘é€è€…ï¼šèŠ‚ç‚¹IDã€è§†å›¾ç‰ˆæœ¬
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Sequence Info â”‚ â† åºåˆ—ï¼šæ¶ˆæ¯åºå·ã€ä¾èµ–å…³ç³»
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Payload Data  â”‚ â† è´Ÿè½½ï¼šå®é™…æ•°æ®å†…å®¹
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Checksum      â”‚ â† æ ¡éªŒï¼šæ•°æ®å®Œæ•´æ€§éªŒè¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’» æ¶ˆæ¯ç»“æ„ä»£ç ç¤ºä¾‹**
```cpp
struct GCS_Message {
    // æ¶ˆæ¯å¤´
    struct Header {
        uint32_t message_type;     // æ¶ˆæ¯ç±»å‹
        uint32_t payload_size;     // è´Ÿè½½å¤§å°
        uint64_t timestamp;        // æ—¶é—´æˆ³
        uint32_t checksum;         // æ ¡éªŒå’Œ
    } header;
    
    // å‘é€è€…ä¿¡æ¯
    struct Sender {
        string node_id;            // èŠ‚ç‚¹æ ‡è¯†
        uint64_t view_id;          // è§†å›¾ç‰ˆæœ¬
        uint64_t sequence_num;     // åºåˆ—å·
    } sender;
    
    // æ¶ˆæ¯å†…å®¹
    vector<uint8_t> payload;       // å®é™…æ•°æ®
};
```

### 4.2 æ¶ˆæ¯é¡ºåºä¿è¯æœºåˆ¶


**ğŸ”¸ ä¸ºä»€ä¹ˆéœ€è¦æ¶ˆæ¯é¡ºåº**
```
é—®é¢˜åœºæ™¯ï¼š
èŠ‚ç‚¹Aå‘é€ï¼šINSERT INTO t1 VALUES(1)
èŠ‚ç‚¹Bå‘é€ï¼šUPDATE t1 SET id=2 WHERE id=1

å¦‚æœé¡ºåºæ··ä¹±ï¼š
Node1çœ‹åˆ°: UPDATEå…ˆæ‰§è¡Œ â†’ å¤±è´¥ï¼ŒINSERTåæ‰§è¡Œ â†’ æœ€ç»ˆid=1
Node2çœ‹åˆ°: INSERTå…ˆæ‰§è¡Œ â†’ æˆåŠŸï¼ŒUPDATEåæ‰§è¡Œ â†’ æœ€ç»ˆid=2
ç»“æœï¼šæ•°æ®ä¸ä¸€è‡´ï¼
```

**âœ… å…¨åºå¹¿æ’­æœºåˆ¶**
```
å…¨åºå¹¿æ’­åŸç†ï¼š
1. æ¯ä¸ªæ¶ˆæ¯åˆ†é…å…¨å±€å”¯ä¸€åºå·
2. æ‰€æœ‰èŠ‚ç‚¹æŒ‰åºå·é¡ºåºå¤„ç†æ¶ˆæ¯
3. ä¹±åºåˆ°è¾¾çš„æ¶ˆæ¯ç­‰å¾…æ’åº
4. ç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒé¡ºåº

å®ç°æ–¹å¼ï¼š
â€¢ ä½¿ç”¨XCOMåè®®çš„ææ¡ˆç¼–å·ä½œä¸ºåºå·
â€¢ èŠ‚ç‚¹ç¼“å­˜ä¹±åºæ¶ˆæ¯ç›´åˆ°èƒ½æŒ‰åºå¤„ç†
â€¢ å®šæœŸæ£€æŸ¥æ¶ˆæ¯é—´éš™å¹¶è¯·æ±‚é‡ä¼ 
```

**ğŸ”§ æ¶ˆæ¯æ’åºç®—æ³•**
```cpp
class MessageOrderManager {
private:
    uint64_t next_expected_seq;           // æœŸå¾…çš„ä¸‹ä¸€ä¸ªåºå·
    map<uint64_t, GCS_Message> buffer;   // ä¹±åºæ¶ˆæ¯ç¼“å­˜
    
public:
    bool process_message(const GCS_Message& msg) {
        uint64_t seq = msg.sender.sequence_num;
        
        if (seq == next_expected_seq) {
            // æ­£å¥½æ˜¯æœŸå¾…çš„æ¶ˆæ¯ï¼Œç«‹å³å¤„ç†
            execute_message(msg);
            next_expected_seq++;
            
            // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦æœ‰åç»­æ¶ˆæ¯
            process_buffered_messages();
            return true;
        } 
        else if (seq > next_expected_seq) {
            // ä¹±åºåˆ°è¾¾ï¼Œå…ˆç¼“å­˜
            buffer[seq] = msg;
            return false;
        }
        else {
            // é‡å¤æ¶ˆæ¯ï¼Œå¿½ç•¥
            return false;
        }
    }
    
private:
    void process_buffered_messages() {
        while (buffer.count(next_expected_seq)) {
            execute_message(buffer[next_expected_seq]);
            buffer.erase(next_expected_seq);
            next_expected_seq++;
        }
    }
};
```

### 4.3 æ¶ˆæ¯å¯é ä¼ é€’


**ğŸ›¡ï¸ æ¶ˆæ¯å¯é æ€§ä¿éšœ**
```
å¯é æ€§è¦æ±‚ï¼š
â€¢ å‘é€çš„æ¶ˆæ¯æœ€ç»ˆéƒ½èƒ½è¢«æ¥æ”¶
â€¢ ä¸ä¼šä¸¢å¤±ä»»ä½•æ¶ˆæ¯
â€¢ ä¸ä¼šé‡å¤å¤„ç†åŒä¸€æ¶ˆæ¯
â€¢ æ£€æµ‹å¹¶é‡ä¼ ä¸¢å¤±çš„æ¶ˆæ¯
```

**ğŸ“Š å¯é ä¼ é€’æœºåˆ¶**
```
å‘é€ç«¯ä¿éšœï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. æ¶ˆæ¯æŒä¹…åŒ–    â”‚ â† å‘é€å‰å†™å…¥æœ¬åœ°æ—¥å¿—
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. ç¡®è®¤ç­‰å¾…      â”‚ â† ç­‰å¾…æ¥æ”¶æ–¹ç¡®è®¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. è¶…æ—¶é‡ä¼       â”‚ â† è¶…æ—¶åé‡æ–°å‘é€
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. å¤±è´¥å¤„ç†      â”‚ â† å¤šæ¬¡å¤±è´¥åæ ‡è®°èŠ‚ç‚¹æ•…éšœ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¥æ”¶ç«¯ä¿éšœï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. é‡å¤æ£€æµ‹      â”‚ â† æ£€æŸ¥æ¶ˆæ¯åºå·é¿å…é‡å¤
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. å®Œæ•´æ€§éªŒè¯    â”‚ â† æ ¡éªŒå’ŒéªŒè¯æ¶ˆæ¯å®Œæ•´
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. é¡ºåºæ£€æŸ¥      â”‚ â† ç¡®ä¿æŒ‰åºå¤„ç†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. ç¡®è®¤å›å¤      â”‚ â† å‘é€ç¡®è®¤æ¶ˆæ¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’» é‡ä¼ æœºåˆ¶å®ç°**
```cpp
class ReliableMessaging {
private:
    struct PendingMessage {
        GCS_Message message;
        time_t sent_time;
        int retry_count;
        set<string> acked_nodes;
    };
    
    map<uint64_t, PendingMessage> pending_messages;
    
public:
    void send_reliable(const GCS_Message& msg) {
        // 1. åˆ†é…åºå·
        uint64_t seq = generate_sequence_number();
        
        // 2. è®°å½•å¾…ç¡®è®¤æ¶ˆæ¯
        PendingMessage pending;
        pending.message = msg;
        pending.sent_time = time(nullptr);
        pending.retry_count = 0;
        pending_messages[seq] = pending;
        
        // 3. å‘é€æ¶ˆæ¯
        send_to_all_nodes(msg);
        
        // 4. å¯åŠ¨è¶…æ—¶æ£€æŸ¥
        schedule_timeout_check(seq);
    }
    
    void handle_acknowledgment(uint64_t seq, const string& node_id) {
        if (pending_messages.count(seq)) {
            pending_messages[seq].acked_nodes.insert(node_id);
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èŠ‚ç‚¹éƒ½ç¡®è®¤äº†
            if (all_nodes_acknowledged(seq)) {
                pending_messages.erase(seq);
            }
        }
    }
    
    void handle_timeout(uint64_t seq) {
        if (pending_messages.count(seq)) {
            PendingMessage& pending = pending_messages[seq];
            
            if (pending.retry_count < MAX_RETRIES) {
                // é‡ä¼ æ¶ˆæ¯
                resend_message(pending.message);
                pending.retry_count++;
                pending.sent_time = time(nullptr);
            } else {
                // æ ‡è®°èŠ‚ç‚¹æ•…éšœ
                mark_nodes_as_failed(pending.acked_nodes);
            }
        }
    }
};
```

---

## 5. ğŸ”§ æ•…éšœæ£€æµ‹ä¸è§†å›¾å˜æ›´


### 5.1 æ•…éšœæ£€æµ‹æœºåˆ¶


**ğŸ”¸ ä»€ä¹ˆæ˜¯æ•…éšœæ£€æµ‹**
```
æ•…éšœæ£€æµ‹ï¼šåŠæ—¶å‘ç°ç»„å†…èŠ‚ç‚¹æ˜¯å¦æ­£å¸¸å·¥ä½œ
é‡è¦æ€§ï¼šå¿«é€Ÿå‘ç°æ•…éšœï¼Œé¿å…ç­‰å¾…è¶…æ—¶
æŒ‘æˆ˜ï¼šåŒºåˆ†çœŸæ•…éšœå’Œç½‘ç»œå»¶è¿Ÿ
```

**ğŸ’“ å¿ƒè·³æ£€æµ‹æœºåˆ¶**
> å°±åƒåŒ»ç”Ÿç»™ç—…äººé‡è„‰æä¸€æ ·ï¼ŒMGRé€šè¿‡å®šæœŸçš„"å¿ƒè·³"æ¶ˆæ¯æ¥æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿˜"æ´»ç€"ã€‚

**ğŸ“Š æ•…éšœæ£€æµ‹ç®—æ³•**
```
å¿ƒè·³æœºåˆ¶ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ èŠ‚ç‚¹A            â”‚     å¿ƒè·³æ¶ˆæ¯     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ¯éš”Tç§’          â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   â”‚ èŠ‚ç‚¹Bã€Cã€D      â”‚
â”‚ å‘é€å¿ƒè·³         â”‚                 â”‚ è®°å½•æ¥æ”¶æ—¶é—´     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ•…éšœåˆ¤æ–­ï¼š
if (å½“å‰æ—¶é—´ - ä¸Šæ¬¡å¿ƒè·³æ—¶é—´ > æ•…éšœè¶…æ—¶é˜ˆå€¼) {
    æ ‡è®°èŠ‚ç‚¹ä¸ºç–‘ä¼¼æ•…éšœ;
    å¯åŠ¨æ•…éšœç¡®è®¤æµç¨‹;
}
```

**âš ï¸ è¯¯åˆ¤å¤„ç†**
```
ç½‘ç»œå»¶è¿Ÿ vs çœŸæ•…éšœï¼š
âŒ ç®€å•è¶…æ—¶ï¼šç½‘ç»œæ…¢å°±è¯¯åˆ¤ä¸ºæ•…éšœ
âœ… å¤šé‡ç¡®è®¤ï¼šå¤šä¸ªèŠ‚ç‚¹ç¡®è®¤æ‰åˆ¤æ–­æ•…éšœ

å®ç°æ–¹å¼ï¼š
1. ç–‘ä¼¼æ•…éšœé˜¶æ®µï¼šå•ä¸ªèŠ‚ç‚¹æ£€æµ‹åˆ°è¶…æ—¶
2. æ•…éšœç¡®è®¤é˜¶æ®µï¼šå‘å…¶ä»–èŠ‚ç‚¹è¯¢é—®
3. æ•…éšœç¡®å®šé˜¶æ®µï¼šå¤§å¤šæ•°èŠ‚ç‚¹ç¡®è®¤æ•…éšœ
4. è§†å›¾å˜æ›´é˜¶æ®µï¼šä»ç»„ä¸­ç§»é™¤æ•…éšœèŠ‚ç‚¹
```

**ğŸ’» æ•…éšœæ£€æµ‹å®ç°**
```cpp
class FailureDetector {
private:
    struct NodeStatus {
        time_t last_heartbeat;
        int missed_heartbeats;
        bool suspected_failed;
    };
    
    map<string, NodeStatus> node_status;
    const int FAILURE_TIMEOUT = 30;  // 30ç§’æ•…éšœè¶…æ—¶
    const int MAX_MISSED = 3;        // æœ€å¤§é”™è¿‡å¿ƒè·³æ•°
    
public:
    void update_heartbeat(const string& node_id) {
        node_status[node_id].last_heartbeat = time(nullptr);
        node_status[node_id].missed_heartbeats = 0;
        node_status[node_id].suspected_failed = false;
    }
    
    void check_failures() {
        time_t now = time(nullptr);
        
        for (auto& [node_id, status] : node_status) {
            if (now - status.last_heartbeat > FAILURE_TIMEOUT) {
                if (!status.suspected_failed) {
                    // ç¬¬ä¸€æ¬¡æ£€æµ‹åˆ°ç–‘ä¼¼æ•…éšœ
                    status.suspected_failed = true;
                    request_failure_confirmation(node_id);
                }
            }
        }
    }
    
    void handle_failure_confirmation(const string& node_id, 
                                   const vector<string>& confirming_nodes) {
        // å¦‚æœå¤§å¤šæ•°èŠ‚ç‚¹ç¡®è®¤æ•…éšœï¼Œåˆ™è§¦å‘è§†å›¾å˜æ›´
        if (confirming_nodes.size() > total_nodes / 2) {
            trigger_view_change(node_id, "FAILED");
        }
    }
};
```

### 5.2 è§†å›¾å˜æ›´åè®®


**ğŸ”¸ ä»€ä¹ˆæ˜¯è§†å›¾å˜æ›´**
```
è§†å›¾(View)ï¼šå½“å‰ç»„çš„æˆå‘˜åˆ—è¡¨å’ŒçŠ¶æ€
è§†å›¾å˜æ›´ï¼šå½“ç»„æˆå‘˜å‘ç”Ÿå˜åŒ–æ—¶æ›´æ–°è§†å›¾
è§¦å‘æ¡ä»¶ï¼š
â€¢ èŠ‚ç‚¹æ•…éšœ
â€¢ æ–°èŠ‚ç‚¹åŠ å…¥
â€¢ èŠ‚ç‚¹ä¸»åŠ¨ç¦»å¼€
â€¢ ç½‘ç»œåˆ†åŒºæ¢å¤
```

**ğŸ“‹ è§†å›¾å˜æ›´æµç¨‹**
```
è§†å›¾å˜æ›´è¿‡ç¨‹ï¼š
1. æ£€æµ‹å˜æ›´äº‹ä»¶ â†’ èŠ‚ç‚¹æ•…éšœ/åŠ å…¥/ç¦»å¼€
2. æè®®æ–°è§†å›¾   â†’ ç”Ÿæˆæ–°çš„æˆå‘˜åˆ—è¡¨
3. è¾¾æˆä¸€è‡´æ€§   â†’ æ‰€æœ‰èŠ‚ç‚¹åŒæ„æ–°è§†å›¾
4. å®‰è£…æ–°è§†å›¾   â†’ åˆ‡æ¢åˆ°æ–°çš„ç»„é…ç½®
5. é€šçŸ¥åº”ç”¨å±‚   â†’ MGRå¤„ç†çŠ¶æ€å˜åŒ–
```

**ğŸ’¡ è§†å›¾å˜æ›´ç¤ºä¾‹**
```
åœºæ™¯ï¼š3èŠ‚ç‚¹ç»„ä¸­Node2æ•…éšœ

å½“å‰è§†å›¾: View#5 {Node1, Node2, Node3}

æ­¥éª¤1ï¼šæ•…éšœæ£€æµ‹
Node1æ£€æµ‹åˆ°Node2å¿ƒè·³è¶…æ—¶
Node3ä¹Ÿæ£€æµ‹åˆ°Node2å¿ƒè·³è¶…æ—¶

æ­¥éª¤2ï¼šæè®®æ–°è§†å›¾
Node1æè®®: View#6 {Node1, Node3} (ç§»é™¤Node2)

æ­¥éª¤3ï¼šè¾¾æˆä¸€è‡´
Node1 â†’ Node3: "åŒæ„åˆ‡æ¢åˆ°View#6å—ï¼Ÿ"
Node3 â†’ Node1: "åŒæ„"

æ­¥éª¤4ï¼šå®‰è£…æ–°è§†å›¾
Both nodes switch to View#6 {Node1, Node3}

æ­¥éª¤5ï¼šçŠ¶æ€è°ƒæ•´
â€¢ é‡æ–°è®¡ç®—æ³•å®šäººæ•° (ä»2ä¸ªå˜æˆ1ä¸ª)
â€¢ å¦‚æœNode2æ˜¯Primaryï¼Œé€‰ä¸¾æ–°Primary
â€¢ æ›´æ–°å¤åˆ¶æ‹“æ‰‘
```

**ğŸ”§ è§†å›¾å˜æ›´çŠ¶æ€æœº**
```cpp
enum ViewChangeState {
    STABLE,           // ç¨³å®šçŠ¶æ€ï¼Œæ­£å¸¸å·¥ä½œ
    PREPARING,        // å‡†å¤‡å˜æ›´ï¼Œæ”¶é›†ä¿¡æ¯
    PROPOSING,        // æè®®æ–°è§†å›¾
    VOTING,           // æŠ•ç¥¨è¡¨å†³
    INSTALLING,       // å®‰è£…æ–°è§†å›¾
    FAILED            // å˜æ›´å¤±è´¥
};

class ViewChangeManager {
private:
    ViewChangeState current_state;
    GCS_View current_view;
    GCS_View proposed_view;
    
public:
    void handle_failure_detected(const string& failed_node) {
        if (current_state == STABLE) {
            // å¼€å§‹è§†å›¾å˜æ›´æµç¨‹
            current_state = PREPARING;
            
            // ç”Ÿæˆæ–°è§†å›¾ï¼ˆç§»é™¤æ•…éšœèŠ‚ç‚¹ï¼‰
            proposed_view = current_view;
            proposed_view.remove_member(failed_node);
            proposed_view.increment_version();
            
            // å‘å…¶ä»–èŠ‚ç‚¹æè®®
            current_state = PROPOSING;
            broadcast_view_proposal(proposed_view);
        }
    }
    
    void handle_view_vote(const string& voter, bool accept) {
        if (current_state == VOTING) {
            record_vote(voter, accept);
            
            if (received_majority_votes()) {
                if (votes_are_positive()) {
                    // å®‰è£…æ–°è§†å›¾
                    current_state = INSTALLING;
                    install_new_view(proposed_view);
                } else {
                    // ææ¡ˆè¢«æ‹’ç»
                    current_state = FAILED;
                    handle_proposal_rejection();
                }
            }
        }
    }
};
```

### 5.3 è§†å›¾å˜æ›´çš„å½±å“


**ğŸ“Š è§†å›¾å˜æ›´å¯¹ç³»ç»Ÿçš„å½±å“**
```
æ³•å®šäººæ•°å˜åŒ–ï¼š
æ—§è§†å›¾: 3èŠ‚ç‚¹ï¼Œæ³•å®šäººæ•°=2
æ–°è§†å›¾: 2èŠ‚ç‚¹ï¼Œæ³•å®šäººæ•°=1 (å¯èƒ½å¯¼è‡´è„‘è£‚é£é™©)

è§’è‰²é‡æ–°åˆ†é…ï¼š
â€¢ PrimaryèŠ‚ç‚¹æ•…éšœ â†’ é‡æ–°é€‰ä¸¾Primary
â€¢ SecondaryèŠ‚ç‚¹æ•…éšœ â†’ è°ƒæ•´å¤åˆ¶é“¾è·¯

æ€§èƒ½å½±å“ï¼š
â€¢ å˜æ›´æœŸé—´æš‚åœäº‹åŠ¡å¤„ç†
â€¢ é‡æ–°å»ºç«‹è¿æ¥å’ŒåŒæ­¥
â€¢ å¯èƒ½è§¦å‘æ•°æ®æ¢å¤æµç¨‹
```

**âš ï¸ è§†å›¾å˜æ›´æ³¨æ„äº‹é¡¹**
```
è„‘è£‚é£é™©ï¼š
é—®é¢˜ï¼šç½‘ç»œåˆ†åŒºå¯¼è‡´ç»„åˆ†è£‚æˆä¸¤éƒ¨åˆ†
è§£å†³ï¼šä¸¥æ ¼æ‰§è¡Œæ³•å®šäººæ•°è§„åˆ™

æ•°æ®ä¸€è‡´æ€§ï¼š
é—®é¢˜ï¼šå˜æ›´è¿‡ç¨‹ä¸­çš„äº‹åŠ¡å¦‚ä½•å¤„ç†
è§£å†³ï¼šå˜æ›´å‰å®Œæˆå¾…å¤„ç†äº‹åŠ¡

æ¢å¤å¤„ç†ï¼š
é—®é¢˜ï¼šæ•…éšœèŠ‚ç‚¹æ¢å¤åå¦‚ä½•é‡æ–°åŠ å…¥
è§£å†³ï¼šå…ˆåŒæ­¥æ•°æ®ï¼Œå†åŠ å…¥ç»„
```

---

## 6. ğŸŒ ç½‘ç»œåˆ†åŒºå¤„ç†


### 6.1 ä»€ä¹ˆæ˜¯ç½‘ç»œåˆ†åŒº


**ğŸ”¸ ç½‘ç»œåˆ†åŒºå®šä¹‰**
```
ç½‘ç»œåˆ†åŒº(Network Partition)ï¼šç½‘ç»œæ•…éšœå¯¼è‡´ç»„è¢«åˆ†å‰²æˆå¤šä¸ªæ— æ³•é€šä¿¡çš„éƒ¨åˆ†
åˆ«åï¼šè„‘è£‚(Split-Brain)é—®é¢˜
å±é™©ï¼šå¯èƒ½äº§ç”Ÿå¤šä¸ª"æ´»è·ƒ"çš„ä¸»èŠ‚ç‚¹
```

**ğŸ  ç”Ÿæ´»ç±»æ¯”**
> æƒ³è±¡ä¸€ä¸ªå…¬å¸å› ä¸ºç”µè¯ç³»ç»Ÿæ•…éšœï¼Œä¸Šæµ·åŠå…¬å®¤å’ŒåŒ—äº¬åŠå…¬å®¤æ— æ³•é€šä¿¡ã€‚ä¸¤è¾¹éƒ½è®¤ä¸ºå¯¹æ–¹å‡ºäº†é—®é¢˜ï¼Œéƒ½æƒ³åšå†³ç­–ã€‚å¦‚æœä¸å¤„ç†å¥½ï¼Œå°±ä¼šå‡ºç°ä¸¤ä¸ª"æ€»ç»ç†"åŒæ—¶å‘å·æ–½ä»¤çš„æ··ä¹±å±€é¢ã€‚

**ğŸ“Š ç½‘ç»œåˆ†åŒºç¤ºä¾‹**
```
æ­£å¸¸æƒ…å†µï¼š
Node1 â†â”€â”€â†’ Node2 â†â”€â”€â†’ Node3
  â†‘                      â†‘
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç½‘ç»œåˆ†åŒºï¼š
Node1     âœ—âœ—âœ—    Node2 â†â”€â”€â†’ Node3
åˆ†åŒºA              åˆ†åŒºB
(1ä¸ªèŠ‚ç‚¹)          (2ä¸ªèŠ‚ç‚¹)

é—®é¢˜ï¼š
â€¢ åˆ†åŒºAè®¤ä¸ºNode2ã€Node3æ•…éšœäº†
â€¢ åˆ†åŒºBè®¤ä¸ºNode1æ•…éšœäº†  
â€¢ ä¸¤è¾¹éƒ½æƒ³ç»§ç»­æä¾›æœåŠ¡
â€¢ å¯èƒ½äº§ç”Ÿæ•°æ®å†²çª
```

### 6.2 æ³•å®šäººæ•°æœºåˆ¶


**ğŸ”¸ æ³•å®šäººæ•°(Quorum)æ¦‚å¿µ**
```
æ³•å®šäººæ•°ï¼šç»„èƒ½å¤Ÿæ­£å¸¸å·¥ä½œæ‰€éœ€çš„æœ€å°‘èŠ‚ç‚¹æ•°
è®¡ç®—å…¬å¼ï¼šæ³•å®šäººæ•° = âŒŠèŠ‚ç‚¹æ€»æ•°/2âŒ‹ + 1
ç›®çš„ï¼šç¡®ä¿åªæœ‰ä¸€ä¸ªåˆ†åŒºèƒ½ç»§ç»­å·¥ä½œ
```

**ğŸ“‹ æ³•å®šäººæ•°è®¡ç®—**
```
èŠ‚ç‚¹æ•°é‡ â†’ æ³•å®šäººæ•° â†’ å®¹é”™èƒ½åŠ›
3ä¸ªèŠ‚ç‚¹ â†’ 2ä¸ªæ³•å®š â†’ å®¹å¿1ä¸ªæ•…éšœ
5ä¸ªèŠ‚ç‚¹ â†’ 3ä¸ªæ³•å®š â†’ å®¹å¿2ä¸ªæ•…éšœ  
7ä¸ªèŠ‚ç‚¹ â†’ 4ä¸ªæ³•å®š â†’ å®¹å¿3ä¸ªæ•…éšœ

å¥‡æ•°èŠ‚ç‚¹çš„ä¼˜åŠ¿ï¼š
å¶æ•°èŠ‚ç‚¹å¯èƒ½å¯¼è‡´ä¸¤ä¸ªç›¸ç­‰çš„åˆ†åŒºéƒ½æ— æ³•è¾¾åˆ°æ³•å®šäººæ•°
å¥‡æ•°èŠ‚ç‚¹ç¡®ä¿æ€»æœ‰ä¸€ä¸ªåˆ†åŒºèƒ½è¾¾åˆ°æ³•å®šäººæ•°
```

**âœ… æ³•å®šäººæ•°ä¿æŠ¤æœºåˆ¶**
```cpp
class QuorumManager {
private:
    int total_nodes;
    int alive_nodes;
    int quorum_size;
    
public:
    QuorumManager(int total) : total_nodes(total) {
        quorum_size = (total_nodes / 2) + 1;
        alive_nodes = total_nodes;
    }
    
    bool has_quorum() const {
        return alive_nodes >= quorum_size;
    }
    
    void node_failed(const string& node_id) {
        alive_nodes--;
        
        if (!has_quorum()) {
            // å¤±å»æ³•å®šäººæ•°ï¼Œåœæ­¢æœåŠ¡
            log_error("Lost quorum! Stopping group operations");
            stop_group_operations();
        }
    }
    
    void node_recovered(const string& node_id) {
        alive_nodes++;
        
        if (has_quorum() && !is_group_active()) {
            // æ¢å¤æ³•å®šäººæ•°ï¼Œå¯ä»¥é‡æ–°æä¾›æœåŠ¡
            log_info("Quorum restored! Resuming operations");
            resume_group_operations();
        }
    }
};
```

### 6.3 ç½‘ç»œåˆ†åŒºæ£€æµ‹


**ğŸ” åˆ†åŒºæ£€æµ‹æ–¹æ³•**
```
æ£€æµ‹æœºåˆ¶ï¼š
1. å¿ƒè·³ä¸¢å¤±ï¼šæ— æ³•æ”¶åˆ°å…¶ä»–èŠ‚ç‚¹å¿ƒè·³
2. è¿æ¥æ–­å¼€ï¼šTCPè¿æ¥å¼‚å¸¸æ–­å¼€
3. å“åº”è¶…æ—¶ï¼šè¯·æ±‚æ— å“åº”
4. è·¯ç”±å¤±æ•ˆï¼šç½‘ç»œå±‚è·¯ç”±ä¸å¯è¾¾

æ£€æµ‹æŒ‘æˆ˜ï¼š
â€¢ åŒºåˆ†ç½‘ç»œæ…¢å’Œç½‘ç»œæ–­å¼€
â€¢ é¿å…è¯¯åˆ¤ä¸´æ—¶ç½‘ç»œæŠ–åŠ¨
â€¢ å¿«é€Ÿæ£€æµ‹çœŸæ­£çš„åˆ†åŒº
```

**ğŸ“Š åˆ†åŒºæ£€æµ‹ç®—æ³•**
```
å¤šé‡æ£€æµ‹æœºåˆ¶ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. å¿ƒè·³æ£€æµ‹      â”‚ â† å®šæœŸå¿ƒè·³åŒ…æ£€æŸ¥
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. è¿æ¥çŠ¶æ€      â”‚ â† TCPè¿æ¥çŠ¶æ€ç›‘æ§
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚ 3. ç½‘ç»œæ¢æµ‹      â”‚ â† Ping/tracerouteæ£€æŸ¥
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. ç¬¬ä¸‰æ–¹ä»²è£    â”‚ â† å¤–éƒ¨ä»²è£æœåŠ¡ç¡®è®¤
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åˆ¤æ–­é€»è¾‘ï¼š
if (å¿ƒè·³è¶…æ—¶ && è¿æ¥æ–­å¼€ && ç½‘ç»œä¸å¯è¾¾) {
    if (ç¬¬ä¸‰æ–¹ç¡®è®¤ç½‘ç»œåˆ†åŒº) {
        ç¡®è®¤å‘ç”Ÿç½‘ç»œåˆ†åŒº;
    } else {
        å¯èƒ½æ˜¯æœ¬åœ°ç½‘ç»œé—®é¢˜;
    }
}
```

**ğŸ’» åˆ†åŒºæ£€æµ‹å®ç°**
```cpp
class NetworkPartitionDetector {
private:
    struct NodeConnectivity {
        bool heartbeat_ok;
        bool tcp_connected;
        bool network_reachable;
        time_t last_check;
    };
    
    map<string, NodeConnectivity> connectivity_status;
    
public:
    void check_partition() {
        int unreachable_nodes = 0;
        int total_nodes = connectivity_status.size();
        
        for (auto& [node_id, status] : connectivity_status) {
            // å¤šé‡æ£€æŸ¥
            bool is_reachable = check_heartbeat(node_id) &&
                              check_tcp_connection(node_id) &&
                              check_network_ping(node_id);
            
            if (!is_reachable) {
                unreachable_nodes++;
            }
        }
        
        // åˆ¤æ–­æ˜¯å¦å‘ç”Ÿåˆ†åŒº
        if (unreachable_nodes > total_nodes / 2) {
            // æ— æ³•è¿æ¥å¤§å¤šæ•°èŠ‚ç‚¹ï¼Œå¯èƒ½å‘ç”Ÿåˆ†åŒº
            handle_potential_partition(unreachable_nodes);
        }
    }
    
private:
    void handle_potential_partition(int unreachable_count) {
        // 1. åœæ­¢æ¥å—æ–°çš„å†™å…¥æ“ä½œ
        set_read_only_mode(true);
        
        // 2. å°è¯•é€šè¿‡ä»²è£æœåŠ¡ç¡®è®¤
        if (consult_arbitrator()) {
            // ç¡®è®¤åˆ†åŒºï¼Œä¿æŒåªè¯»çŠ¶æ€
            log_warning("Network partition confirmed, entering read-only mode");
        } else {
            // å¯èƒ½æ˜¯æœ¬åœ°ç½‘ç»œé—®é¢˜ï¼Œå°è¯•æ¢å¤
            attempt_network_recovery();
        }
    }
};
```

### 6.4 åˆ†åŒºæ¢å¤å¤„ç†


**ğŸ”„ ç½‘ç»œåˆ†åŒºæ¢å¤**
```
æ¢å¤æ£€æµ‹ï¼š
â€¢ å¿ƒè·³æ¢å¤ï¼šé‡æ–°æ”¶åˆ°å…¶ä»–èŠ‚ç‚¹å¿ƒè·³
â€¢ è¿æ¥é‡å»ºï¼šTCPè¿æ¥é‡æ–°å»ºç«‹
â€¢ ç½‘ç»œå¯è¾¾ï¼šèƒ½å¤Ÿæ­£å¸¸é€šä¿¡

æ¢å¤æŒ‘æˆ˜ï¼š
â€¢ æ•°æ®åŒæ­¥ï¼šåˆ†åŒºæœŸé—´çš„æ•°æ®å·®å¼‚
â€¢ çŠ¶æ€åˆå¹¶ï¼šä¸åŒåˆ†åŒºçš„çŠ¶æ€å†²çª
â€¢ ä¸€è‡´æ€§ä¿è¯ï¼šç¡®ä¿æœ€ç»ˆæ•°æ®ä¸€è‡´
```

**ğŸ“Š åˆ†åŒºæ¢å¤æµç¨‹**
```
åˆ†åŒºæ¢å¤æ­¥éª¤ï¼š
1. ç½‘ç»œæ¢å¤æ£€æµ‹ â†’ ç¡®è®¤èŠ‚ç‚¹é—´å¯ä»¥é€šä¿¡
2. è§†å›¾é‡æ–°æ„å»º â†’ é‡æ–°å‘ç°æ‰€æœ‰èŠ‚ç‚¹
3. æ•°æ®çŠ¶æ€æ¯”è¾ƒ â†’ æ£€æŸ¥åˆ†åŒºæœŸé—´çš„å˜åŒ–
4. å†²çªè§£å†³     â†’ å¤„ç†æ•°æ®å†²çª
5. çŠ¶æ€åŒæ­¥     â†’ ç»Ÿä¸€æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€
6. æœåŠ¡æ¢å¤     â†’ æ¢å¤æ­£å¸¸æœåŠ¡
```

**ğŸ’» æ¢å¤å¤„ç†å®ç°**
```cpp
class PartitionRecoveryManager {
public:
    void handle_partition_recovery() {
        log_info("Starting partition recovery process");
        
        // 1. é‡æ–°å‘ç°èŠ‚ç‚¹
        vector<string> recovered_nodes = rediscover_nodes();
        
        // 2. æ¯”è¾ƒæ•°æ®çŠ¶æ€
        map<string, uint64_t> node_states = collect_node_states(recovered_nodes);
        
        // 3. æ£€æµ‹å†²çª
        vector<ConflictInfo> conflicts = detect_conflicts(node_states);
        
        if (!conflicts.empty()) {
            // 4. è§£å†³å†²çª
            resolve_conflicts(conflicts);
        }
        
        // 5. åŒæ­¥æ•°æ®
        synchronize_all_nodes(recovered_nodes);
        
        // 6. é‡å»ºè§†å›¾
        GCS_View new_view = build_unified_view(recovered_nodes);
        install_view(new_view);
        
        // 7. æ¢å¤æœåŠ¡
        set_read_only_mode(false);
        log_info("Partition recovery completed");
    }
    
private:
    void resolve_conflicts(const vector<ConflictInfo>& conflicts) {
        for (const auto& conflict : conflicts) {
            // å†²çªè§£å†³ç­–ç•¥ï¼šé€‰æ‹©æœ€å¤§GTIDçš„ç‰ˆæœ¬
            string winning_node = select_winning_version(conflict);
            
            // å°†è·èƒœç‰ˆæœ¬åŒæ­¥åˆ°å…¶ä»–èŠ‚ç‚¹
            propagate_winning_version(conflict, winning_node);
        }
    }
};
```

---

## 7. ğŸ”’ é€šä¿¡å®‰å…¨ä¸åŠ å¯†


### 7.1 MGRé€šä¿¡å®‰å…¨éœ€æ±‚


**ğŸ›¡ï¸ å®‰å…¨å¨èƒåˆ†æ**
```
ç½‘ç»œå¨èƒï¼š
â€¢ æ•°æ®çªƒå¬ï¼šæ•æ„Ÿæ•°æ®è¢«æˆªè·
â€¢ æ¶ˆæ¯ç¯¡æ”¹ï¼šæ¶æ„ä¿®æ”¹ä¼ è¾“å†…å®¹
â€¢ èº«ä»½å†’å……ï¼šä¼ªè£…æˆåˆæ³•èŠ‚ç‚¹
â€¢ é‡æ”¾æ”»å‡»ï¼šé‡å¤å‘é€æ—§æ¶ˆæ¯
â€¢ æ‹’ç»æœåŠ¡ï¼šæ¶æ„å¹²æ‰°é€šä¿¡
```

**ğŸ” å®‰å…¨éœ€æ±‚**
```
æœºå¯†æ€§(Confidentiality)ï¼š
é˜²æ­¢æ•°æ®æ³„éœ²ï¼Œä½¿ç”¨åŠ å¯†ä¿æŠ¤ä¼ è¾“å†…å®¹

å®Œæ•´æ€§(Integrity)ï¼š  
é˜²æ­¢æ•°æ®ç¯¡æ”¹ï¼Œä½¿ç”¨æ•°å­—ç­¾åéªŒè¯å†…å®¹

èº«ä»½è®¤è¯(Authentication)ï¼š
ç¡®ä¿é€šä¿¡åŒæ–¹èº«ä»½ï¼Œä½¿ç”¨è¯ä¹¦éªŒè¯èº«ä»½

ä¸å¯å¦è®¤(Non-repudiation)ï¼š
é˜²æ­¢å¦è®¤å‘é€è¡Œä¸ºï¼Œä½¿ç”¨æ•°å­—ç­¾åè¯æ˜

å¯ç”¨æ€§(Availability)ï¼š
ç¡®ä¿æœåŠ¡æ­£å¸¸è¿è¡Œï¼Œé˜²å¾¡æ‹’ç»æœåŠ¡æ”»å‡»
```

### 7.2 SSL/TLSåŠ å¯†æœºåˆ¶


**ğŸ”¸ MGRåŠ å¯†é…ç½®**
```sql
-- å¯ç”¨MGR SSLåŠ å¯†
SET GLOBAL group_replication_ssl_mode = 'REQUIRED';
SET GLOBAL group_replication_recovery_use_ssl = 1;

-- é…ç½®SSLè¯ä¹¦
SET GLOBAL group_replication_recovery_ssl_ca = '/path/to/ca.pem';
SET GLOBAL group_replication_recovery_ssl_cert = '/path/to/client-cert.pem';
SET GLOBAL group_replication_recovery_ssl_key = '/path/to/client-key.pem';
```

**ğŸ“Š SSLæ¡æ‰‹æµç¨‹**
```
MGRèŠ‚ç‚¹é—´SSLæ¡æ‰‹ï¼š
å®¢æˆ·ç«¯èŠ‚ç‚¹                    æœåŠ¡ç«¯èŠ‚ç‚¹
    |                            |
    |----ClientHello------------>|
    |                            |
    |<---ServerHello------------| 
    |<---Certificate-------------|  â† å‘é€æœåŠ¡ç«¯è¯ä¹¦
    |<---ServerHelloDone---------|
    |                            |
    |----Certificate------------>|  â† å‘é€å®¢æˆ·ç«¯è¯ä¹¦  
    |----ClientKeyExchange------>|
    |----CertificateVerify------>|
    |----ChangeCipherSpec------->|
    |----Finished-------------->|
    |                            |
    |<---ChangeCipherSpec--------|
    |<---Finished---------------|
    |                            |
    |  <åŠ å¯†é€šä¿¡å¼€å§‹>              |
```

**ğŸ”§ SSLé…ç½®æœ€ä½³å®è·µ**
```bash
# 1. ç”ŸæˆCAæ ¹è¯ä¹¦
openssl genrsa -out ca-key.pem 4096
openssl req -new -x509 -days 365 -key ca-key.pem -out ca.pem

# 2. ç”ŸæˆèŠ‚ç‚¹è¯ä¹¦
openssl genrsa -out server-key.pem 2048
openssl req -new -key server-key.pem -out server-req.pem
openssl x509 -req -days 365 -in server-req.pem -CA ca.pem -CAkey ca-key.pem -out server-cert.pem

# 3. éªŒè¯è¯ä¹¦
openssl verify -CAfile ca.pem server-cert.pem
```

### 7.3 æ¶ˆæ¯è®¤è¯ä¸å®Œæ•´æ€§


**ğŸ“ æ¶ˆæ¯è®¤è¯ç (MAC)**
```
HMACæœºåˆ¶ï¼š
â€¢ ä½¿ç”¨å…±äº«å¯†é’¥ç”Ÿæˆæ¶ˆæ¯æ‘˜è¦
â€¢ æ¥æ”¶æ–¹ç”¨ç›¸åŒå¯†é’¥éªŒè¯æ‘˜è¦
â€¢ ç¡®ä¿æ¶ˆæ¯æœªè¢«ç¯¡æ”¹
â€¢ éªŒè¯å‘é€æ–¹èº«ä»½
```

**ğŸ’» æ¶ˆæ¯å®Œæ•´æ€§å®ç°**
```cpp
class MessageAuthentication {
private:
    string shared_secret;  // ç»„å†…å…±äº«å¯†é’¥
    
public:
    // å‘é€æ–¹ï¼šç”Ÿæˆæ¶ˆæ¯è®¤è¯ç 
    string generate_mac(const GCS_Message& msg) {
        // è®¡ç®—æ¶ˆæ¯å†…å®¹çš„HMAC
        string message_content = serialize_message(msg);
        return hmac_sha256(shared_secret, message_content);
    }
    
    // æ¥æ”¶æ–¹ï¼šéªŒè¯æ¶ˆæ¯è®¤è¯ç 
    bool verify_mac(const GCS_Message& msg, const string& received_mac) {
        string expected_mac = generate_mac(msg);
        return secure_compare(expected_mac, received_mac);
    }
    
    // é˜²æ—¶åºæ”»å‡»çš„å®‰å…¨æ¯”è¾ƒ
    bool secure_compare(const string& a, const string& b) {
        if (a.length() != b.length()) return false;
        
        bool result = true;
        for (size_t i = 0; i < a.length(); i++) {
            result &= (a[i] == b[i]);
        }
        return result;
    }
};
```

### 7.4 å¯†é’¥ç®¡ç†


**ğŸ—ï¸ å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†**
```
å¯†é’¥ç®¡ç†æµç¨‹ï¼š
1. å¯†é’¥ç”Ÿæˆ â†’ ä½¿ç”¨å¼ºéšæœºæ•°ç”Ÿæˆå™¨
2. å¯†é’¥åˆ†å‘ â†’ å®‰å…¨åœ°åˆ†å‘ç»™ç»„æˆå‘˜
3. å¯†é’¥ä½¿ç”¨ â†’ åŠ å¯†å’Œè®¤è¯æ¶ˆæ¯
4. å¯†é’¥è½®æ¢ â†’ å®šæœŸæ›´æ¢å¯†é’¥
5. å¯†é’¥é”€æ¯ â†’ å®‰å…¨åˆ é™¤æ—§å¯†é’¥
```

**ğŸ“Š å¯†é’¥è½®æ¢æœºåˆ¶**
```cpp
class KeyManager {
private:
    struct GroupKey {
        uint64_t version;      // å¯†é’¥ç‰ˆæœ¬
        string key_data;       // å¯†é’¥å†…å®¹
        time_t created_time;   // åˆ›å»ºæ—¶é—´
        time_t expire_time;    // è¿‡æœŸæ—¶é—´
    };
    
    map<uint64_t, GroupKey> keys;  // å¯†é’¥ç‰ˆæœ¬å†å²
    uint64_t current_version;      // å½“å‰ä½¿ç”¨ç‰ˆæœ¬
    
public:
    void rotate_key() {
        // 1. ç”Ÿæˆæ–°å¯†é’¥
        GroupKey new_key;
        new_key.version = current_version + 1;
        new_key.key_data = generate_random_key(256);  // 256ä½å¯†é’¥
        new_key.created_time = time(nullptr);
        new_key.expire_time = new_key.created_time + KEY_LIFETIME;
        
        // 2. åˆ†å‘æ–°å¯†é’¥ç»™æ‰€æœ‰èŠ‚ç‚¹
        distribute_new_key(new_key);
        
        // 3. ç­‰å¾…æ‰€æœ‰èŠ‚ç‚¹ç¡®è®¤
        wait_for_key_confirmation(new_key.version);
        
        // 4. åˆ‡æ¢åˆ°æ–°å¯†é’¥
        current_version = new_key.version;
        keys[current_version] = new_key;
        
        // 5. æ¸…ç†è¿‡æœŸå¯†é’¥
        cleanup_expired_keys();
    }
    
private:
    string generate_random_key(int bits) {
        // ä½¿ç”¨åŠ å¯†å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨
        vector<uint8_t> key_bytes(bits / 8);
        RAND_bytes(key_bytes.data(), key_bytes.size());
        return bytes_to_hex(key_bytes);
    }
};
```

---

## 8. ğŸ” åè®®è°ƒè¯•ä¸æ•…éšœåˆ†æ


### 8.1 MGRé€šä¿¡åè®®è°ƒè¯•


**ğŸ› ï¸ è°ƒè¯•å·¥å…·ä¸æ–¹æ³•**
```
å†…ç½®è°ƒè¯•åŠŸèƒ½ï¼š
â€¢ Performance Schemaï¼šç›‘æ§MGRå†…éƒ¨çŠ¶æ€
â€¢ é”™è¯¯æ—¥å¿—ï¼šè®°å½•åè®®å¼‚å¸¸ä¿¡æ¯
â€¢ çŠ¶æ€å˜é‡ï¼šæ˜¾ç¤ºå®æ—¶ç»Ÿè®¡ä¿¡æ¯
â€¢ XCOMæ—¥å¿—ï¼šåº•å±‚åè®®è¯¦ç»†æ—¥å¿—
```

**ğŸ“Š å…³é”®ç›‘æ§è¡¨**
```sql
-- æŸ¥çœ‹ç»„æˆå‘˜çŠ¶æ€
SELECT * FROM performance_schema.replication_group_members;

-- æŸ¥çœ‹é€šä¿¡ç»Ÿè®¡
SELECT * FROM performance_schema.replication_group_communication_information;

-- æŸ¥çœ‹æ¶ˆæ¯ç»Ÿè®¡
SELECT * FROM performance_schema.replication_connection_status;

-- æŸ¥çœ‹XCOMç»Ÿè®¡
SHOW STATUS LIKE 'group_replication%';
```

**ğŸ”§ è°ƒè¯•é…ç½®**
```sql
-- å¯ç”¨è¯¦ç»†æ—¥å¿—
SET GLOBAL log_error_verbosity = 3;
SET GLOBAL group_replication_communication_debug_options = 'GCS_DEBUG_ALL';

-- å¯ç”¨XCOMè°ƒè¯•
SET GLOBAL group_replication_communication_debug_options = 'XCOM_DEBUG_ALL';

-- ç›‘æ§ç½‘ç»œç»Ÿè®¡
SET GLOBAL group_replication_communication_statistics = ON;
```

### 8.2 å¸¸è§åè®®æ•…éšœåˆ†æ


**âš ï¸ å…¸å‹æ•…éšœåœºæ™¯**

**æ¶ˆæ¯ä¼ é€’è¶…æ—¶**
```
æ•…éšœç°è±¡ï¼š
â€¢ èŠ‚ç‚¹æ— å“åº”
â€¢ äº‹åŠ¡æäº¤ç¼“æ…¢
â€¢ å¤§é‡è¶…æ—¶é”™è¯¯

æ•…éšœåŸå› ï¼š
â€¢ ç½‘ç»œå»¶è¿Ÿè¿‡é«˜
â€¢ èŠ‚ç‚¹æ€§èƒ½ä¸è¶³
â€¢ æ¶ˆæ¯é˜Ÿåˆ—ç§¯å‹
â€¢ ç£ç›˜IOç“¶é¢ˆ

åˆ†ææ–¹æ³•ï¼š
-- æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ
SHOW STATUS LIKE 'group_replication_communication_round_trip_time';

-- æ£€æŸ¥æ¶ˆæ¯é˜Ÿåˆ—
SHOW STATUS LIKE 'group_replication_communication_sent_messages';
SHOW STATUS LIKE 'group_replication_communication_received_messages';

-- æ£€æŸ¥èŠ‚ç‚¹è´Ÿè½½
SHOW PROCESSLIST;
SHOW STATUS LIKE 'threads%';
```

**è§†å›¾å˜æ›´å¤±è´¥**
```
æ•…éšœç°è±¡ï¼š
â€¢ èŠ‚ç‚¹æ— æ³•åŠ å…¥ç»„
â€¢ è§†å›¾é•¿æ—¶é—´ä¸æ›´æ–°
â€¢ ç»„çŠ¶æ€ä¸ä¸€è‡´

æ•…éšœåŸå› ï¼š
â€¢ ç½‘ç»œåˆ†åŒº
â€¢ é…ç½®ä¸åŒ¹é…
â€¢ è®¤è¯å¤±è´¥
â€¢ èµ„æºä¸è¶³

è¯Šæ–­æ­¥éª¤ï¼š
1. æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
ping other_node_ip
telnet other_node_ip 33061

2. æ£€æŸ¥é…ç½®ä¸€è‡´æ€§
SHOW VARIABLES LIKE 'group_replication%';

3. æ£€æŸ¥é”™è¯¯æ—¥å¿—
tail -f /var/log/mysql/error.log | grep -i "group replication"
```

**XCOMåè®®å¼‚å¸¸**
```
æ•…éšœç°è±¡ï¼š
â€¢ æ¶ˆæ¯æ— æ³•è¾¾æˆä¸€è‡´
â€¢ XCOMè¿›ç¨‹å´©æºƒ
â€¢ åè®®ç‰ˆæœ¬ä¸å…¼å®¹

åˆ†ææ–¹æ³•ï¼š
-- æ£€æŸ¥XCOMçŠ¶æ€
SHOW STATUS LIKE 'group_replication_primary_member';

-- æ£€æŸ¥åè®®ç‰ˆæœ¬
SELECT * FROM performance_schema.replication_group_members 
WHERE member_role = 'PRIMARY';

-- å¯ç”¨XCOMè¯¦ç»†æ—¥å¿—
SET GLOBAL group_replication_communication_debug_options = 'XCOM_DEBUG_BASIC';
```

### 8.3 æ€§èƒ½åˆ†æä¸ä¼˜åŒ–


**ğŸ“ˆ æ€§èƒ½ç›‘æ§æŒ‡æ ‡**
```sql
-- å…³é”®æ€§èƒ½æŒ‡æ ‡æŸ¥è¯¢
SELECT 
    member_id,
    member_state,
    member_role,
    member_version
FROM performance_schema.replication_group_members;

-- é€šä¿¡æ€§èƒ½ç»Ÿè®¡
SELECT 
    sent_transactions,
    received_transactions,
    sent_transaction_size,
    received_transaction_size
FROM performance_schema.replication_group_communication_information;

-- ç½‘ç»œå»¶è¿Ÿåˆ†æ  
SHOW STATUS LIKE 'group_replication_communication_round_trip_time';
```

**âš¡ æ€§èƒ½ä¼˜åŒ–å»ºè®®**
```
ç½‘ç»œå±‚ä¼˜åŒ–ï¼š
â€¢ ä½¿ç”¨é«˜é€Ÿç½‘ç»œï¼ˆåƒå…†ä»¥ä¸Šï¼‰
â€¢ å‡å°‘ç½‘ç»œè·³æ•°
â€¢ å¯ç”¨TCP Nagleç®—æ³•ç¦ç”¨
â€¢ è°ƒæ•´TCPç¼“å†²åŒºå¤§å°

åº”ç”¨å±‚ä¼˜åŒ–ï¼š
â€¢ æ‰¹é‡æäº¤äº‹åŠ¡
â€¢ å‡å°‘å¤§äº‹åŠ¡æ“ä½œ
â€¢ ä¼˜åŒ–äº‹åŠ¡å†²çª
â€¢ ä½¿ç”¨è¯»å†™åˆ†ç¦»

ç³»ç»Ÿå±‚ä¼˜åŒ–ï¼š
â€¢ è°ƒæ•´ç³»ç»Ÿå†…æ ¸å‚æ•°
â€¢ ä¼˜åŒ–ç£ç›˜IOæ€§èƒ½
â€¢ é…ç½®å……è¶³å†…å­˜
â€¢ ä½¿ç”¨SSDå­˜å‚¨
```

---

## 9. ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


### 9.1 é€šä¿¡æ€§èƒ½ä¼˜åŒ–


**ğŸ“Š æ€§èƒ½ç“¶é¢ˆåˆ†æ**
```
å¸¸è§æ€§èƒ½ç“¶é¢ˆï¼š
â€¢ ç½‘ç»œå¸¦å®½é™åˆ¶
â€¢ æ¶ˆæ¯åºåˆ—åŒ–å¼€é”€
â€¢ åŠ å¯†è§£å¯†å¼€é”€
â€¢ å†…å­˜æ‹·è´å¼€é”€
â€¢ é”ç«äº‰å¼€é”€
```

**âš¡ ç½‘ç»œå±‚ä¼˜åŒ–**
```bash
# TCPå‚æ•°è°ƒä¼˜
echo 'net.core.rmem_max = 134217728' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 134217728' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_rmem = 4096 65536 134217728' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_wmem = 4096 65536 134217728' >> /etc/sysctl.conf

# ç¦ç”¨Nagleç®—æ³•ï¼ˆå‡å°‘å»¶è¿Ÿï¼‰
echo 'net.ipv4.tcp_nodelay = 1' >> /etc/sysctl.conf

# å¯ç”¨TCPçª—å£ç¼©æ”¾
echo 'net.ipv4.tcp_window_scaling = 1' >> /etc/sysctl.conf

sysctl -p
```

**ğŸ’» æ¶ˆæ¯æ‰¹å¤„ç†ä¼˜åŒ–**
```cpp
class MessageBatcher {
private:
    vector<GCS_Message> pending_messages;
    size_t max_batch_size = 100;
    time_t batch_timeout = 10;  // 10ms
    
public:
    void add_message(const GCS_Message& msg) {
        pending_messages.push_back(msg);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€æ‰¹æ¬¡
        if (pending_messages.size() >= max_batch_size ||
            should_flush_by_timeout()) {
            flush_batch();
        }
    }
    
private:
    void flush_batch() {
        if (pending_messages.empty()) return;
        
        // 1. åˆ›å»ºæ‰¹é‡æ¶ˆæ¯
        GCS_BatchMessage batch_msg;
        batch_msg.set_messages(pending_messages);
        
        // 2. å‹ç¼©æ‰¹é‡æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰
        if (batch_msg.size() > COMPRESSION_THRESHOLD) {
            batch_msg.compress();
        }
        
        // 3. å‘é€æ‰¹é‡æ¶ˆæ¯
        send_to_all_nodes(batch_msg);
        
        // 4. æ¸…ç©ºå¾…å¤„ç†é˜Ÿåˆ—
        pending_messages.clear();
    }
};
```

### 9.2 å†…å­˜ä¸CPUä¼˜åŒ–


**ğŸ§  å†…å­˜æ± ç®¡ç†**
```cpp
class MessageMemoryPool {
private:
    struct MemoryBlock {
        size_t size;
        void* data;
        bool in_use;
    };
    
    vector<MemoryBlock> memory_blocks;
    mutex pool_mutex;
    
public:
    void* allocate(size_t size) {
        lock_guard<mutex> lock(pool_mutex);
        
        // æŸ¥æ‰¾åˆé€‚çš„ç©ºé—²å—
        for (auto& block : memory_blocks) {
            if (!block.in_use && block.size >= size) {
                block.in_use = true;
                return block.data;
            }
        }
        
        // æ²¡æœ‰åˆé€‚çš„å—ï¼Œåˆ†é…æ–°çš„
        MemoryBlock new_block;
        new_block.size = max(size, DEFAULT_BLOCK_SIZE);
        new_block.data = malloc(new_block.size);
        new_block.in_use = true;
        
        memory_blocks.push_back(new_block);
        return new_block.data;
    }
    
    void deallocate(void* ptr) {
        lock_guard<mutex> lock(pool_mutex);
        
        for (auto& block : memory_blocks) {
            if (block.data == ptr) {
                block.in_use = false;
                break;
            }
        }
    }
};
```

**âš¡ é›¶æ‹·è´ä¼˜åŒ–**
```cpp
class ZeroCopyMessage {
private:
    vector<iovec> io_vectors;  // åˆ†æ•£èšé›†IO
    
public:
    void add_data_reference(const void* data, size_t size) {
        // ä¸æ‹·è´æ•°æ®ï¼Œåªä¿å­˜å¼•ç”¨
        iovec vec;
        vec.iov_base = const_cast<void*>(data);
        vec.iov_len = size;
        io_vectors.push_back(vec);
    }
    
    ssize_t send_to_socket(int socket_fd) {
        // ä½¿ç”¨writevå®ç°é›¶æ‹·è´å‘é€
        return writev(socket_fd, io_vectors.data(), io_vectors.size());
    }
};
```

### 9.3 å¹¶å‘å¤„ç†ä¼˜åŒ–


**ğŸ”„ æ— é”é˜Ÿåˆ—**
```cpp
template<typename T>
class LockFreeQueue {
private:
    struct Node {
        atomic<T*> data;
        atomic<Node*> next;
    };
    
    atomic<Node*> head;
    atomic<Node*> tail;
    
public:
    void enqueue(T item) {
        Node* new_node = new Node;
        T* data = new T(move(item));
        new_node->data.store(data);
        new_node->next.store(nullptr);
        
        Node* prev_tail = tail.exchange(new_node);
        prev_tail->next.store(new_node);
    }
    
    bool dequeue(T& result) {
        Node* head_node = head.load();
        Node* next = head_node->next.load();
        
        if (next == nullptr) {
            return false;  // é˜Ÿåˆ—ä¸ºç©º
        }
        
        T* data = next->data.load();
        if (head.compare_exchange_weak(head_node, next)) {
            result = *data;
            delete data;
            delete head_node;
            return true;
        }
        
        return false;  // å¹¶å‘å†²çªï¼Œé‡è¯•
    }
};
```

**ğŸ¯ å·¥ä½œçº¿ç¨‹æ± **
```cpp
class MessageProcessorPool {
private:
    vector<thread> worker_threads;
    LockFreeQueue<GCS_Message> message_queue;
    atomic<bool> running;
    
public:
    MessageProcessorPool(int thread_count) : running(true) {
        for (int i = 0; i < thread_count; i++) {
            worker_threads.emplace_back(&MessageProcessorPool::worker_loop, this);
        }
    }
    
    void submit_message(const GCS_Message& msg) {
        message_queue.enqueue(msg);
    }
    
private:
    void worker_loop() {
        GCS_Message msg;
        
        while (running.load()) {
            if (message_queue.dequeue(msg)) {
                process_message(msg);
            } else {
                // é˜Ÿåˆ—ä¸ºç©ºï¼ŒçŸ­æš‚ä¼‘çœ 
                this_thread::sleep_for(chrono::microseconds(100));
            }
        }
    }
};
```

---

## 10. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 10.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ ç»„é€šä¿¡åè®®ï¼šMGRçš„é€šä¿¡åŸºç¡€ï¼Œç¡®ä¿å¯é ã€æœ‰åºçš„æ¶ˆæ¯ä¼ é€’
ğŸ”¸ GCSæŠ½è±¡å±‚ï¼šæä¾›ç»Ÿä¸€æ¥å£ï¼Œéš”ç¦»åº•å±‚åè®®å¤æ‚æ€§
ğŸ”¸ XCOMåè®®ï¼šåŸºäºPaxosçš„ä¸€è‡´æ€§ç®—æ³•ï¼Œä¿è¯åˆ†å¸ƒå¼ä¸€è‡´æ€§
ğŸ”¸ æ¶ˆæ¯é¡ºåºï¼šå…¨åºå¹¿æ’­ç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒçš„æ¶ˆæ¯é¡ºåº
ğŸ”¸ æ•…éšœæ£€æµ‹ï¼šå¿ƒè·³æœºåˆ¶åŠæ—¶å‘ç°èŠ‚ç‚¹æ•…éšœ
ğŸ”¸ è§†å›¾å˜æ›´ï¼šå¤„ç†ç»„æˆå‘˜å˜åŒ–ï¼Œç»´æŠ¤ç»„çŠ¶æ€ä¸€è‡´æ€§
ğŸ”¸ ç½‘ç»œåˆ†åŒºï¼šæ³•å®šäººæ•°æœºåˆ¶é˜²æ­¢è„‘è£‚é—®é¢˜
ğŸ”¸ é€šä¿¡å®‰å…¨ï¼šSSL/TLSåŠ å¯†ä¿æŠ¤æ•°æ®ä¼ è¾“å®‰å…¨
```

### 10.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ åè®®åˆ†å±‚çš„ä»·å€¼**
```
åˆ†å±‚è®¾è®¡å¥½å¤„ï¼š
â€¢ èŒè´£åˆ†ç¦»ï¼šæ¯å±‚ä¸“æ³¨ç‰¹å®šåŠŸèƒ½
â€¢ æ˜“äºç»´æŠ¤ï¼šä¿®æ”¹ä¸€å±‚ä¸å½±å“å…¶ä»–å±‚
â€¢ å¯æ‰©å±•æ€§ï¼šå¯ä»¥æ›¿æ¢åº•å±‚å®ç°
â€¢ å¤ç”¨æ€§ï¼šä¸Šå±‚åè®®å¯ç”¨äºå…¶ä»–åœºæ™¯

MGRåè®®æ ˆä»·å€¼ï¼š
â€¢ GCSå±‚å±è”½XCOMå¤æ‚æ€§
â€¢ XCOMä¸“æ³¨ä¸€è‡´æ€§ç®—æ³•
â€¢ ç½‘ç»œå±‚å¤„ç†ä¼ è¾“ç»†èŠ‚
â€¢ åº”ç”¨å±‚ä¸“æ³¨ä¸šåŠ¡é€»è¾‘
```

**ğŸ”¹ ä¸€è‡´æ€§ä¸æ€§èƒ½çš„å¹³è¡¡**
```
ä¸€è‡´æ€§è¦æ±‚ï¼š
â€¢ æ‰€æœ‰èŠ‚ç‚¹æ•°æ®å¿…é¡»ä¸€è‡´
â€¢ äº‹åŠ¡é¡ºåºå¿…é¡»ä¿æŒä¸€è‡´
â€¢ æ•…éšœæ¢å¤åçŠ¶æ€ä¸€è‡´

æ€§èƒ½æŒ‘æˆ˜ï¼š
â€¢ ç½‘ç»œå»¶è¿Ÿå½±å“å“åº”æ—¶é—´
â€¢ å¤šèŠ‚ç‚¹é€šä¿¡å¢åŠ å¼€é”€
â€¢ åŠ å¯†è§£å¯†æ¶ˆè€—CPUèµ„æº

å¹³è¡¡ç­–ç•¥ï¼š
â€¢ æ‰¹é‡å¤„ç†å‡å°‘ç½‘ç»œå¼€é”€
â€¢ æœ¬åœ°è¯»å‡å°‘ç½‘ç»œè®¿é—®
â€¢ å¼‚æ­¥å¤„ç†æé«˜å¹¶å‘æ€§
â€¢ ç¼“å­˜æœºåˆ¶å‡å°‘é‡å¤è®¡ç®—
```

**ğŸ”¹ æ•…éšœå¤„ç†çš„é‡è¦æ€§**
```
æ•…éšœçš„ä¸å¯é¿å…æ€§ï¼š
â€¢ ç½‘ç»œæ•…éšœï¼šå»¶è¿Ÿã€ä¸¢åŒ…ã€åˆ†åŒº
â€¢ èŠ‚ç‚¹æ•…éšœï¼šç¡¬ä»¶ã€è½¯ä»¶ã€é…ç½®
â€¢ äººä¸ºé”™è¯¯ï¼šè¯¯æ“ä½œã€é…ç½®é”™è¯¯

æ•…éšœå¤„ç†ç­–ç•¥ï¼š
â€¢ å¿«é€Ÿæ£€æµ‹ï¼šåŠæ—¶å‘ç°æ•…éšœ
â€¢ è‡ªåŠ¨æ¢å¤ï¼šæ— éœ€äººå·¥å¹²é¢„
â€¢ æ•°æ®ä¿æŠ¤ï¼šç¡®ä¿æ•°æ®ä¸ä¸¢å¤±
â€¢ æœåŠ¡è¿ç»­ï¼šæœ€å°åŒ–æœåŠ¡ä¸­æ–­
```

### 10.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ğŸ“Š éƒ¨ç½²æœ€ä½³å®è·µ**
```
ç½‘ç»œè§„åˆ’ï¼š
âœ… ä½¿ç”¨ä¸“ç”¨ç½‘ç»œè¿æ¥MGRèŠ‚ç‚¹
âœ… ç¡®ä¿ä½å»¶è¿Ÿã€é«˜å¸¦å®½ç½‘ç»œ
âœ… é…ç½®å†—ä½™ç½‘ç»œè·¯å¾„
âœ… ç›‘æ§ç½‘ç»œè´¨é‡æŒ‡æ ‡

èŠ‚ç‚¹é…ç½®ï¼š
âœ… ä½¿ç”¨å¥‡æ•°ä¸ªèŠ‚ç‚¹ï¼ˆ3ã€5ã€7ï¼‰
âœ… åœ°ç†åˆ†å¸ƒè€ƒè™‘å»¶è¿Ÿå½±å“
âœ… ç¡¬ä»¶é…ç½®ä¿æŒä¸€è‡´
âœ… æ—¶é—´åŒæ­¥é…ç½®NTP

å®‰å…¨é…ç½®ï¼š
âœ… å¯ç”¨SSL/TLSåŠ å¯†
âœ… é…ç½®é˜²ç«å¢™è§„åˆ™
âœ… å®šæœŸè½®æ¢å¯†é’¥
âœ… ç›‘æ§å®‰å…¨äº‹ä»¶
```

**ğŸ”§ æ•…éšœé¢„é˜²ç­–ç•¥**
```
ç›‘æ§å‘Šè­¦ï¼š
â€¢ ç½‘ç»œå»¶è¿Ÿç›‘æ§
â€¢ èŠ‚ç‚¹çŠ¶æ€ç›‘æ§
â€¢ æ¶ˆæ¯é˜Ÿåˆ—ç›‘æ§
â€¢ æ€§èƒ½æŒ‡æ ‡ç›‘æ§

å®šæœŸç»´æŠ¤ï¼š
â€¢ æ—¥å¿—æ–‡ä»¶æ¸…ç†
â€¢ æ€§èƒ½æ•°æ®åˆ†æ
â€¢ é…ç½®ä¸€è‡´æ€§æ£€æŸ¥
â€¢ å®‰å…¨è¡¥ä¸æ›´æ–°

å®¹é‡è§„åˆ’ï¼š
â€¢ è¯„ä¼°ç½‘ç»œå¸¦å®½éœ€æ±‚
â€¢ è®¡ç®—å­˜å‚¨ç©ºé—´å¢é•¿
â€¢ é¢„æµ‹æ€§èƒ½ç“¶é¢ˆ
â€¢ åˆ¶å®šæ‰©å®¹è®¡åˆ’
```

**ğŸš¨ æ•…éšœåº”æ€¥å¤„ç†**
```
æ•…éšœåˆ†ç±»ä¸å¤„ç†ï¼š

ç½‘ç»œæ•…éšœï¼š
1. æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
2. ç¡®è®¤é˜²ç«å¢™é…ç½®
3. éªŒè¯DNSè§£æ
4. æ£€æŸ¥è·¯ç”±è¡¨

èŠ‚ç‚¹æ•…éšœï¼š
1. æ£€æŸ¥èŠ‚ç‚¹çŠ¶æ€
2. æŸ¥çœ‹é”™è¯¯æ—¥å¿—
3. éªŒè¯èµ„æºä½¿ç”¨
4. é‡å¯æ•…éšœèŠ‚ç‚¹

é…ç½®æ•…éšœï¼š
1. å¯¹æ¯”èŠ‚ç‚¹é…ç½®
2. æ£€æŸ¥æƒé™è®¾ç½®
3. éªŒè¯è¯ä¹¦æœ‰æ•ˆæ€§
4. æ¢å¤æ­£ç¡®é…ç½®
```

### 10.4 å­¦ä¹ æ£€æŸ¥ç‚¹


**ğŸ“ è‡ªæˆ‘æ£€æµ‹é¢˜ç›®**
```
ğŸ¤” æ¦‚å¿µç†è§£æ£€æŸ¥ï¼š
Q1: è§£é‡Šä¸ºä»€ä¹ˆMGRéœ€è¦å…¨åºå¹¿æ’­ï¼Ÿ
Q2: XCOMåè®®å¦‚ä½•ä¿è¯ä¸€è‡´æ€§ï¼Ÿ
Q3: ç½‘ç»œåˆ†åŒºæ—¶æ³•å®šäººæ•°æœºåˆ¶å¦‚ä½•å·¥ä½œï¼Ÿ
Q4: è§†å›¾å˜æ›´è¿‡ç¨‹åŒ…å«å“ªäº›å…³é”®æ­¥éª¤ï¼Ÿ

ğŸ’ª å®è·µèƒ½åŠ›æ£€æŸ¥ï¼š
Q5: å¦‚ä½•é…ç½®MGRçš„SSLåŠ å¯†ï¼Ÿ
Q6: ç½‘ç»œæ•…éšœæ—¶å¦‚ä½•è¯Šæ–­é—®é¢˜ï¼Ÿ
Q7: å¦‚ä½•ä¼˜åŒ–MGRçš„é€šä¿¡æ€§èƒ½ï¼Ÿ
Q8: æ•…éšœèŠ‚ç‚¹æ¢å¤éœ€è¦å“ªäº›æ­¥éª¤ï¼Ÿ
```

**âœ… æŒæ¡ç¨‹åº¦è¯„ä¼°**
```
åŸºç¡€çº§åˆ« (â­â­â­)ï¼š
â€¢ ç†è§£ç»„é€šä¿¡åè®®çš„ä½œç”¨
â€¢ æŒæ¡åŸºæœ¬çš„æ•…éšœæ£€æµ‹åŸç†
â€¢ äº†è§£SSLåŠ å¯†çš„é‡è¦æ€§
â€¢ èƒ½å¤Ÿè¿›è¡ŒåŸºæœ¬çš„æ•…éšœè¯Šæ–­

è¿›é˜¶çº§åˆ« (â­â­â­â­)ï¼š
â€¢ æ·±å…¥ç†è§£XCOMåè®®å·¥ä½œåŸç†
â€¢ æŒæ¡è§†å›¾å˜æ›´çš„è¯¦ç»†æµç¨‹
â€¢ èƒ½å¤Ÿè¿›è¡Œæ€§èƒ½è°ƒä¼˜
â€¢ ç†Ÿç»ƒå¤„ç†ç½‘ç»œåˆ†åŒºé—®é¢˜

ä¸“å®¶çº§åˆ« (â­â­â­â­â­)ï¼š
â€¢ ç²¾é€šåè®®åº•å±‚å®ç°ç»†èŠ‚
â€¢ èƒ½å¤Ÿè®¾è®¡ä¼˜åŒ–æ–¹æ¡ˆ
â€¢ å…·å¤‡æ•…éšœé¢„é˜²èƒ½åŠ›
â€¢ å¯ä»¥è¿›è¡Œæ¶æ„è®¾è®¡
```

### 10.5 æ ¸å¿ƒè®°å¿†è¦ç‚¹


**ğŸ¯ ä¸€å¥è¯æ€»ç»“**
> MGRç»„é€šä¿¡åè®®é€šè¿‡GCSæŠ½è±¡å±‚å’ŒXCOMä¸€è‡´æ€§ç®—æ³•ï¼Œå®ç°äº†åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„å¯é æ¶ˆæ¯ä¼ é€’ã€æ•…éšœæ£€æµ‹å’Œä¸€è‡´æ€§ä¿è¯ã€‚

**ğŸ”‘ å…³é”®æ¦‚å¿µè®°å¿†**
```
åè®®åˆ†å±‚ï¼šåº”ç”¨â†’GCSâ†’XCOMâ†’ç½‘ç»œ
æ¶ˆæ¯ä¿è¯ï¼šå¯é ä¼ é€’ + å…¨åºå¹¿æ’­
æ•…éšœå¤„ç†ï¼šå¿ƒè·³æ£€æµ‹ + è§†å›¾å˜æ›´
åˆ†åŒºé˜²æŠ¤ï¼šæ³•å®šäººæ•° + å¤šé‡ç¡®è®¤
å®‰å…¨é€šä¿¡ï¼šSSLåŠ å¯† + æ¶ˆæ¯è®¤è¯
```

**ğŸ“š æ‰©å±•å­¦ä¹ å»ºè®®**
```
æ·±å…¥å­¦ä¹ æ–¹å‘ï¼š
ğŸ”¸ Paxosç®—æ³•åŸç†ä¸å®ç°
ğŸ”¸ åˆ†å¸ƒå¼ç³»ç»Ÿä¸€è‡´æ€§ç†è®º
ğŸ”¸ ç½‘ç»œåè®®è®¾è®¡ä¸ä¼˜åŒ–
ğŸ”¸ é«˜å¯ç”¨æ¶æ„è®¾è®¡æ¨¡å¼

å®è·µé¡¹ç›®æ¨èï¼š
ğŸ”¸ æ­å»ºMGRæµ‹è¯•ç¯å¢ƒ
ğŸ”¸ æ¨¡æ‹Ÿç½‘ç»œæ•…éšœåœºæ™¯
ğŸ”¸ æ€§èƒ½å‹æµ‹ä¸è°ƒä¼˜
ğŸ”¸ ç›‘æ§ç³»ç»Ÿå»ºè®¾

ç›¸å…³æŠ€æœ¯å¯¹æ¯”ï¼š
ğŸ”¸ MySQL MGR vs Galera Cluster
ğŸ”¸ XCOM vs Raftåè®®
ğŸ”¸ åŒæ­¥å¤åˆ¶ vs å¼‚æ­¥å¤åˆ¶
ğŸ”¸ ä¸»ä»æ¶æ„ vs å¤šä¸»æ¶æ„
```

**ğŸ’¡ å®æˆ˜åº”ç”¨æç¤º**
```
ç”Ÿäº§ç¯å¢ƒæ³¨æ„äº‹é¡¹ï¼š
âš ï¸ ç½‘ç»œè´¨é‡æ˜¯æˆåŠŸçš„å…³é”®
âš ï¸ ç›‘æ§å‘Šè­¦å¿…é¡»å®Œå–„
âš ï¸ æ•…éšœé¢„æ¡ˆè¦å®šæœŸæ¼”ç»ƒ
âš ï¸ æ€§èƒ½åŸºçº¿è¦å»ºç«‹è·Ÿè¸ª

å¸¸è§é”™è¯¯é¿å…ï¼š
âŒ å¿½è§†ç½‘ç»œå»¶è¿Ÿå½±å“
âŒ é…ç½®ä¸ä¸€è‡´å¯¼è‡´é—®é¢˜
âŒ ç¼ºä¹æœ‰æ•ˆçš„ç›‘æ§
âŒ æ•…éšœå¤„ç†ä¸åŠæ—¶

æˆåŠŸç»éªŒåˆ†äº«ï¼š
âœ… å……åˆ†çš„å‰æœŸè§„åˆ’
âœ… å®Œå–„çš„æµ‹è¯•éªŒè¯
âœ… æŒç»­çš„æ€§èƒ½ä¼˜åŒ–
âœ… å®šæœŸçš„è¿ç»´ç»´æŠ¤
```

---

**ğŸ“ å­¦ä¹ æˆæœæ€»ç»“**

é€šè¿‡å­¦ä¹ MGRç»„é€šä¿¡åè®®ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†ï¼š

1. **ç†è®ºåŸºç¡€**ï¼šåˆ†å¸ƒå¼ä¸€è‡´æ€§ã€ç»„é€šä¿¡åŸç†ã€æ•…éšœæ£€æµ‹æœºåˆ¶
2. **æŠ€æœ¯ç»†èŠ‚**ï¼šGCSæ¶æ„ã€XCOMåè®®ã€æ¶ˆæ¯ä¼ é€’æœºåˆ¶  
3. **å®è·µèƒ½åŠ›**ï¼šé…ç½®è°ƒä¼˜ã€æ•…éšœè¯Šæ–­ã€æ€§èƒ½ä¼˜åŒ–
4. **è¿ç»´æŠ€èƒ½**ï¼šç›‘æ§å‘Šè­¦ã€åº”æ€¥å¤„ç†ã€å®¹é‡è§„åˆ’

è¿™äº›çŸ¥è¯†å°†å¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£å’Œè¿ç»´MySQL Group Replicationï¼Œä¸ºæ„å»ºé«˜å¯ç”¨çš„æ•°æ®åº“é›†ç¾¤å¥ å®šåšå®åŸºç¡€ã€‚

è®°ä½ï¼š**ç†è®ºæŒ‡å¯¼å®è·µï¼Œå®è·µéªŒè¯ç†è®º**ã€‚åœ¨å®é™…å·¥ä½œä¸­è¦å¤šåŠ¨æ‰‹å®éªŒï¼Œå¤šè§‚å¯Ÿæ—¥å¿—ï¼Œå¤šæ€»ç»“ç»éªŒï¼Œæ‰èƒ½çœŸæ­£æŒæ¡è¿™é—¨æŠ€æœ¯ã€‚