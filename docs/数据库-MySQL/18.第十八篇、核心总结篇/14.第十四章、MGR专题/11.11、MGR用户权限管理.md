---
title: 11、MGR用户权限管理
---
## 📚 目录

1. [MGR用户权限基础概念](#1-MGR用户权限基础概念)
2. [复制用户创建与配置](#2-复制用户创建与配置)
3. [核心权限详解](#3-核心权限详解)
4. [SSL用户认证配置](#4-SSL用户认证配置)
5. [权限最小化实践](#5-权限最小化实践)
6. [安全加固与审计](#6-安全加固与审计)
7. [用户管理脚本](#7-用户管理脚本)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 MGR用户权限基础概念


### 1.1 什么是MGR用户权限管理


**通俗理解**：就像公司里不同岗位的人需要不同的门禁卡一样，MySQL MGR中的不同功能也需要不同级别的"权限卡"。

```
现实中的权限管理：           MySQL MGR权限管理：
┌─────────────────┐           ┌─────────────────┐
│     CEO         │           │  SUPER用户      │ ← 最高权限
├─────────────────┤           ├─────────────────┤
│   部门经理       │           │ 复制管理用户     │ ← 集群管理
├─────────────────┤           ├─────────────────┤
│   普通员工       │           │ 应用连接用户     │ ← 业务访问
└─────────────────┘           └─────────────────┘
```

### 1.2 MGR权限体系架构


**🔸 权限层次结构**
```
MGR权限金字塔：

                管理员用户 (root)
                     |
            ┌────────┼────────┐
            |                 |
      集群管理用户         复制恢复用户
      (repl_user)         (recovery_user)
            |                 |
    ┌───────┼───────┐        |
    |               |        |
监控用户        备份用户   应用用户
(monitor)      (backup)   (app_user)
```

### 1.3 为什么需要精细化权限管理


**🎯 核心目的**
```
安全性：
• 防止权限滥用，降低安全风险
• 限制用户只能执行必要操作
• 避免误操作导致集群问题

管理性：
• 清晰的职责分工
• 便于权限审计和追踪
• 符合安全合规要求

稳定性：
• 减少人为误操作
• 保护关键系统配置
• 确保集群稳定运行
```

---

## 2. 👤 复制用户创建与配置


### 2.1 复制用户的作用


**通俗解释**：复制用户就像是"数据搬运工"，专门负责在MGR集群节点之间搬运数据，确保所有节点的数据保持一致。

**🔸 复制用户职责**
```
主要工作：
• 连接到其他MGR节点
• 传输二进制日志数据
• 接收和应用复制事务
• 维护集群数据一致性

工作流程：
节点A ----[复制用户]----> 节点B
  |                         |
  |--[数据变更]-----------> |--[应用变更]
  |                         |
  |<--[确认应用]------------|
```

### 2.2 创建复制用户


**📝 基本创建步骤**

```sql
-- 步骤1：创建复制用户
CREATE USER 'repl_user'@'%' IDENTIFIED BY 'Repl@123456';

-- 步骤2：授予复制权限
GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';

-- 步骤3：授予MGR管理权限
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'repl_user'@'%';

-- 步骤4：刷新权限
FLUSH PRIVILEGES;
```

**🔧 详细配置示例**

```sql
-- 创建专用的MGR复制用户
CREATE USER 'mgr_repl'@'192.168.1.%' 
IDENTIFIED BY 'MgrRepl@2024!' 
PASSWORD EXPIRE INTERVAL 90 DAY;

-- 授予必要权限
GRANT REPLICATION SLAVE ON *.* TO 'mgr_repl'@'192.168.1.%';
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_repl'@'192.168.1.%';
GRANT CONNECTION_ADMIN ON *.* TO 'mgr_repl'@'192.168.1.%';

-- 设置用户属性
ALTER USER 'mgr_repl'@'192.168.1.%' 
ATTRIBUTE '{"purpose": "MGR replication", "created": "2024-01-15"}';

FLUSH PRIVILEGES;
```

### 2.3 配置group_replication_recovery_user


**🔸 什么是recovery_user**

通俗理解：当MGR节点重新加入集群时，需要一个"向导"来帮助它追上其他节点的数据进度，recovery_user就是这个向导。

```sql
-- 配置恢复用户
SET GLOBAL group_replication_recovery_user = 'mgr_repl';
SET GLOBAL group_replication_recovery_password = 'MgrRepl@2024!';

-- 验证配置
SHOW VARIABLES LIKE 'group_replication_recovery%';
```

**💡 最佳实践配置**

```sql
-- 方式1：使用专门的恢复用户
CREATE USER 'mgr_recovery'@'192.168.1.%' 
IDENTIFIED BY 'Recovery@2024!';

GRANT REPLICATION SLAVE ON *.* TO 'mgr_recovery'@'192.168.1.%';
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_recovery'@'192.168.1.%';

-- 配置到MGR
SET PERSIST group_replication_recovery_user = 'mgr_recovery';
SET PERSIST group_replication_recovery_password = 'Recovery@2024!';
```

---

## 3. 🛡️ 核心权限详解


### 3.1 REPLICATION SLAVE权限


**🔸 权限含义**

通俗解释：这个权限就像是"数据接收许可证"，有了它，用户才能从其他MySQL服务器接收复制的数据。

**权限作用范围**
```
REPLICATION SLAVE权限功能：

数据接收：
• 连接到主库或其他节点
• 读取二进制日志内容
• 接收复制事务数据

状态查询：
• 查看复制状态信息
• 监控复制延迟情况
• 检查复制错误信息
```

**📝 授权示例**

```sql
-- 基础授权
GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';

-- 查看权限
SHOW GRANTS FOR 'repl_user'@'%';

-- 验证权限
SELECT User, Host, Repl_slave_priv FROM mysql.user 
WHERE User = 'repl_user';
```

### 3.2 GROUP_REPLICATION_ADMIN权限


**🔸 权限含义**

通俗解释：这是MGR的"管理员徽章"，拥有它才能控制MGR集群的启动、停止和配置变更。

**权限功能详解**
```
GROUP_REPLICATION_ADMIN权限功能：

集群控制：
• START GROUP_REPLICATION
• STOP GROUP_REPLICATION  
• 修改MGR相关配置参数

节点管理：
• 添加新节点到集群
• 从集群中移除节点
• 处理节点故障切换

配置管理：
• 修改group_replication_*参数
• 设置集群相关配置
• 管理集群拓扑变更
```

**📝 权限配置示例**

```sql
-- 创建MGR管理用户
CREATE USER 'mgr_admin'@'localhost' 
IDENTIFIED BY 'MgrAdmin@2024!';

-- 授予MGR管理权限
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_admin'@'localhost';

-- 测试权限
-- 使用mgr_admin用户连接
START GROUP_REPLICATION;
STOP GROUP_REPLICATION;
```

### 3.3 CONNECTION_ADMIN权限


**🔸 权限含义**

通俗解释：这个权限是"连接管理员证书"，允许用户管理数据库连接，即使在连接数达到上限时也能连接。

**权限应用场景**
```
CONNECTION_ADMIN权限用途：

紧急访问：
• 在max_connections达到上限时仍可连接
• 用于紧急故障处理
• 避免因连接数满而无法管理

连接管理：
• 终止其他用户连接
• 查看连接状态信息
• 管理连接资源分配
```

**📝 配置示例**

```sql
-- 创建紧急管理用户
CREATE USER 'emergency_admin'@'localhost' 
IDENTIFIED BY 'Emergency@2024!';

-- 授予连接管理权限
GRANT CONNECTION_ADMIN ON *.* TO 'emergency_admin'@'localhost';
GRANT PROCESS ON *.* TO 'emergency_admin'@'localhost';

-- 测试连接管理
SHOW PROCESSLIST;
KILL CONNECTION 123;
```

### 3.4 BACKUP_ADMIN权限


**🔸 权限含义**

通俗解释：这是"备份专员证书"，拥有它的用户可以执行数据库备份操作和相关的维护任务。

**权限功能范围**
```
BACKUP_ADMIN权限功能：

备份操作：
• 执行mysqldump备份
• 使用MySQL Shell备份
• 执行增量备份操作

锁管理：
• LOCK INSTANCE FOR BACKUP
• UNLOCK INSTANCE
• 管理备份期间的锁定

表维护：
• FLUSH TABLES
• FLUSH LOGS
• 执行表优化和修复
```

**📝 备份用户配置**

```sql
-- 创建备份专用用户
CREATE USER 'backup_user'@'localhost' 
IDENTIFIED BY 'Backup@2024!';

-- 授予备份相关权限
GRANT BACKUP_ADMIN ON *.* TO 'backup_user'@'localhost';
GRANT PROCESS ON *.* TO 'backup_user'@'localhost';
GRANT RELOAD ON *.* TO 'backup_user'@'localhost';
GRANT LOCK TABLES ON *.* TO 'backup_user'@'localhost';
GRANT REPLICATION CLIENT ON *.* TO 'backup_user'@'localhost';

-- 测试备份权限
LOCK INSTANCE FOR BACKUP;
-- 执行备份操作...
UNLOCK INSTANCE;
```

---

## 4. 🔒 SSL用户认证配置


### 4.1 SSL认证基础概念


**通俗理解**：SSL认证就像网上银行的数字证书，确保MGR节点之间的通信是加密和安全的，防止数据被窃听或篡改。

**🔸 SSL认证优势**
```
安全传输：
• 数据传输加密
• 防止中间人攻击
• 保护敏感信息

身份验证：
• 确认节点身份
• 防止恶意节点接入
• 增强集群安全性

合规要求：
• 满足安全合规标准
• 符合数据保护法规
• 提升整体安全等级
```

### 4.2 生成SSL证书


**📝 证书生成步骤**

```bash
# 步骤1：创建证书目录
mkdir -p /etc/mysql/ssl
cd /etc/mysql/ssl

# 步骤2：生成CA私钥
openssl genrsa -out ca-key.pem 4096

# 步骤3：生成CA证书
openssl req -new -x509 -nodes -days 3650 \
  -key ca-key.pem -out ca.pem \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=MGR/CN=MGR-CA"

# 步骤4：生成服务器私钥
openssl genrsa -out server-key.pem 4096

# 步骤5：生成服务器证书请求
openssl req -new -key server-key.pem -out server-req.pem \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=MGR/CN=mgr-node"

# 步骤6：生成服务器证书
openssl x509 -req -in server-req.pem -days 3650 \
  -CA ca.pem -CAkey ca-key.pem -set_serial 01 \
  -out server-cert.pem

# 步骤7：生成客户端私钥和证书
openssl genrsa -out client-key.pem 4096
openssl req -new -key client-key.pem -out client-req.pem \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=MGR/CN=mgr-client"
openssl x509 -req -in client-req.pem -days 3650 \
  -CA ca.pem -CAkey ca-key.pem -set_serial 02 \
  -out client-cert.pem

# 步骤8：设置权限
chmod 600 *-key.pem
chmod 644 *.pem
chown mysql:mysql *.pem
```

### 4.3 配置SSL用户认证


**📝 用户SSL配置**

```sql
-- 创建要求SSL连接的用户
CREATE USER 'ssl_repl_user'@'%' 
IDENTIFIED BY 'SslRepl@2024!' 
REQUIRE SSL;

-- 创建要求证书认证的用户
CREATE USER 'cert_repl_user'@'%' 
IDENTIFIED BY 'CertRepl@2024!' 
REQUIRE X509;

-- 创建要求特定证书的用户
CREATE USER 'specific_cert_user'@'%' 
IDENTIFIED BY 'SpecCert@2024!' 
REQUIRE SUBJECT '/C=CN/ST=Beijing/L=Beijing/O=MGR/CN=mgr-client';

-- 授予复制权限
GRANT REPLICATION SLAVE ON *.* TO 'ssl_repl_user'@'%';
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'ssl_repl_user'@'%';
```

**🔧 MGR SSL配置**

```sql
-- 配置MGR使用SSL
SET PERSIST group_replication_recovery_use_ssl = ON;
SET PERSIST group_replication_recovery_ssl_ca = '/etc/mysql/ssl/ca.pem';
SET PERSIST group_replication_recovery_ssl_cert = '/etc/mysql/ssl/client-cert.pem';
SET PERSIST group_replication_recovery_ssl_key = '/etc/mysql/ssl/client-key.pem';

-- 验证SSL配置
SHOW VARIABLES LIKE 'group_replication_recovery_ssl%';
```

---

## 5. 🎯 权限最小化实践


### 5.1 权限最小化原则


**通俗理解**：就像给员工发工作证一样，只给他完成工作所必需的权限，不给多余的权限，这样既保证工作能完成，又保证安全。

**🔸 最小化原则要点**
```
基本原则：
• 只授予必要权限
• 按职责划分用户
• 定期审查权限
• 及时回收无用权限

实施策略：
• 角色化管理
• 权限分层
• 时间限制
• 范围限制
```

### 5.2 角色化权限管理


**📝 创建权限角色**

```sql
-- 创建MGR管理角色
CREATE ROLE 'mgr_admin_role';
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_admin_role';
GRANT CONNECTION_ADMIN ON *.* TO 'mgr_admin_role';
GRANT PROCESS ON *.* TO 'mgr_admin_role';

-- 创建复制用户角色
CREATE ROLE 'mgr_repl_role';
GRANT REPLICATION SLAVE ON *.* TO 'mgr_repl_role';
GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_repl_role';

-- 创建监控用户角色
CREATE ROLE 'mgr_monitor_role';
GRANT PROCESS ON *.* TO 'mgr_monitor_role';
GRANT REPLICATION CLIENT ON *.* TO 'mgr_monitor_role';
GRANT SELECT ON performance_schema.* TO 'mgr_monitor_role';

-- 创建备份用户角色
CREATE ROLE 'mgr_backup_role';
GRANT BACKUP_ADMIN ON *.* TO 'mgr_backup_role';
GRANT RELOAD ON *.* TO 'mgr_backup_role';
GRANT LOCK TABLES ON *.* TO 'mgr_backup_role';
```

**📝 分配角色给用户**

```sql
-- 创建用户并分配角色
CREATE USER 'mgr_admin'@'localhost' IDENTIFIED BY 'Admin@2024!';
GRANT 'mgr_admin_role' TO 'mgr_admin'@'localhost';

CREATE USER 'mgr_repl'@'%' IDENTIFIED BY 'Repl@2024!';
GRANT 'mgr_repl_role' TO 'mgr_repl'@'%';

CREATE USER 'mgr_monitor'@'%' IDENTIFIED BY 'Monitor@2024!';
GRANT 'mgr_monitor_role' TO 'mgr_monitor'@'%';

-- 设置默认角色
ALTER USER 'mgr_admin'@'localhost' DEFAULT ROLE 'mgr_admin_role';
ALTER USER 'mgr_repl'@'%' DEFAULT ROLE 'mgr_repl_role';
ALTER USER 'mgr_monitor'@'%' DEFAULT ROLE 'mgr_monitor_role';
```

### 5.3 权限范围限制


**📝 IP地址限制**

```sql
-- 限制管理用户只能从特定IP连接
CREATE USER 'mgr_admin'@'192.168.1.10' IDENTIFIED BY 'Admin@2024!';
CREATE USER 'mgr_admin'@'192.168.1.11' IDENTIFIED BY 'Admin@2024!';
CREATE USER 'mgr_admin'@'192.168.1.12' IDENTIFIED BY 'Admin@2024!';

-- 限制复制用户只能从内网连接
CREATE USER 'mgr_repl'@'192.168.1.%' IDENTIFIED BY 'Repl@2024!';
CREATE USER 'mgr_repl'@'10.0.0.%' IDENTIFIED BY 'Repl@2024!';
```

**📝 时间限制配置**

```sql
-- 设置密码过期时间
CREATE USER 'temp_admin'@'%' 
IDENTIFIED BY 'Temp@2024!' 
PASSWORD EXPIRE INTERVAL 30 DAY;

-- 设置账户锁定策略
ALTER USER 'mgr_admin'@'localhost' 
FAILED_LOGIN_ATTEMPTS 3 
PASSWORD_LOCK_TIME 1;
```

---

## 6. 🔍 安全加固与审计


### 6.1 用户密码策略


**🔸 密码策略配置**

```sql
-- 查看当前密码策略
SHOW VARIABLES LIKE 'validate_password%';

-- 配置强密码策略
SET GLOBAL validate_password.policy = STRONG;
SET GLOBAL validate_password.length = 12;
SET GLOBAL validate_password.mixed_case_count = 1;
SET GLOBAL validate_password.number_count = 1;
SET GLOBAL validate_password.special_char_count = 1;

-- 持久化配置
SET PERSIST validate_password.policy = STRONG;
SET PERSIST validate_password.length = 12;
```

**📝 密码管理最佳实践**

```sql
-- 创建符合安全要求的用户
CREATE USER 'secure_user'@'%' 
IDENTIFIED BY 'SecurePass@2024!' 
PASSWORD EXPIRE INTERVAL 90 DAY
FAILED_LOGIN_ATTEMPTS 5
PASSWORD_LOCK_TIME 2;

-- 强制用户首次登录修改密码
ALTER USER 'new_user'@'%' PASSWORD EXPIRE;

-- 设置密码历史记录
ALTER USER 'mgr_admin'@'localhost' PASSWORD HISTORY 5;
```

### 6.2 权限审计检查


**📝 权限审计脚本**

```sql
-- 检查高权限用户
SELECT User, Host, Super_priv, Grant_priv 
FROM mysql.user 
WHERE Super_priv = 'Y' OR Grant_priv = 'Y';

-- 检查空密码用户
SELECT User, Host, authentication_string 
FROM mysql.user 
WHERE authentication_string = '';

-- 检查MGR相关权限
SELECT User, Host 
FROM mysql.user u
JOIN mysql.global_grants g ON u.User = g.User AND u.Host = g.Host
WHERE g.Priv = 'GROUP_REPLICATION_ADMIN';

-- 检查复制权限用户
SELECT User, Host, Repl_slave_priv, Repl_client_priv 
FROM mysql.user 
WHERE Repl_slave_priv = 'Y' OR Repl_client_priv = 'Y';
```

**📊 权限审计报告**

| 检查项目 | 检查内容 | 安全建议 |
|---------|----------|----------|
| **高权限用户** | `SUPER`、`GRANT`权限 | 限制高权限用户数量 |
| **空密码账户** | `authentication_string = ''` | 禁用空密码账户 |
| **匿名用户** | `User = ''` | 删除匿名用户 |
| **复制用户** | `REPLICATION SLAVE`权限 | 使用专用复制账户 |
| **过期密码** | `password_expired = 'Y'` | 及时更新过期密码 |

### 6.3 安全加固措施


**📝 基础安全加固**

```sql
-- 删除匿名用户
DELETE FROM mysql.user WHERE User = '';

-- 删除测试数据库
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db = 'test' OR Db = 'test\\_%';

-- 禁用远程root登录
DELETE FROM mysql.user WHERE User = 'root' AND Host != 'localhost';

-- 创建专门的管理用户替代root
CREATE USER 'myadmin'@'localhost' IDENTIFIED BY 'MyAdmin@2024!';
GRANT ALL PRIVILEGES ON *.* TO 'myadmin'@'localhost' WITH GRANT OPTION;

FLUSH PRIVILEGES;
```

**🔧 MGR专项安全配置**

```sql
-- 配置SSL加密
SET PERSIST group_replication_ssl_mode = REQUIRED;
SET PERSIST group_replication_recovery_use_ssl = ON;

-- 配置IP白名单
SET PERSIST group_replication_ip_allowlist = '192.168.1.10,192.168.1.11,192.168.1.12';

-- 启用binlog加密
SET PERSIST binlog_encryption = ON;
SET PERSIST binlog_rotate_encryption_master_key_at_startup = ON;
```

---

## 7. 📝 用户管理脚本


### 7.1 用户创建脚本


**📝 MGR用户批量创建脚本**

```bash
#!/bin/bash
# mgr_user_setup.sh - MGR用户批量创建脚本

# 配置变量
MYSQL_HOST="localhost"
MYSQL_ROOT_USER="root"
MYSQL_ROOT_PASS="RootPass@2024"

# MGR节点IP列表
MGR_NODES=("192.168.1.10" "192.168.1.11" "192.168.1.12")

# 用户密码配置
REPL_PASSWORD="MgrRepl@$(date +%Y)"
ADMIN_PASSWORD="MgrAdmin@$(date +%Y)"
MONITOR_PASSWORD="MgrMonitor@$(date +%Y)"
BACKUP_PASSWORD="MgrBackup@$(date +%Y)"

echo "=== MGR用户创建脚本开始执行 ==="

# 函数：执行SQL命令
execute_sql() {
    local sql_command="$1"
    mysql -h${MYSQL_HOST} -u${MYSQL_ROOT_USER} -p${MYSQL_ROOT_PASS} -e "${sql_command}"
    if [ $? -eq 0 ]; then
        echo "✅ SQL执行成功: ${sql_command:0:50}..."
    else
        echo "❌ SQL执行失败: ${sql_command:0:50}..."
        exit 1
    fi
}

# 1. 创建MGR复制用户
echo "--- 创建MGR复制用户 ---"
for node in "${MGR_NODES[@]}"; do
    execute_sql "CREATE USER IF NOT EXISTS 'mgr_repl'@'${node}' IDENTIFIED BY '${REPL_PASSWORD}';"
    execute_sql "GRANT REPLICATION SLAVE ON *.* TO 'mgr_repl'@'${node}';"
    execute_sql "GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_repl'@'${node}';"
done

# 2. 创建MGR管理用户
echo "--- 创建MGR管理用户 ---"
for node in "${MGR_NODES[@]}"; do
    execute_sql "CREATE USER IF NOT EXISTS 'mgr_admin'@'${node}' IDENTIFIED BY '${ADMIN_PASSWORD}';"
    execute_sql "GRANT GROUP_REPLICATION_ADMIN ON *.* TO 'mgr_admin'@'${node}';"
    execute_sql "GRANT CONNECTION_ADMIN ON *.* TO 'mgr_admin'@'${node}';"
    execute_sql "GRANT PROCESS ON *.* TO 'mgr_admin'@'${node}';"
done

# 3. 创建监控用户
echo "--- 创建监控用户 ---"
execute_sql "CREATE USER IF NOT EXISTS 'mgr_monitor'@'%' IDENTIFIED BY '${MONITOR_PASSWORD}';"
execute_sql "GRANT PROCESS ON *.* TO 'mgr_monitor'@'%';"
execute_sql "GRANT REPLICATION CLIENT ON *.* TO 'mgr_monitor'@'%';"
execute_sql "GRANT SELECT ON performance_schema.* TO 'mgr_monitor'@'%';"
execute_sql "GRANT SELECT ON information_schema.* TO 'mgr_monitor'@'%';"

# 4. 创建备份用户
echo "--- 创建备份用户 ---"
execute_sql "CREATE USER IF NOT EXISTS 'mgr_backup'@'localhost' IDENTIFIED BY '${BACKUP_PASSWORD}';"
execute_sql "GRANT BACKUP_ADMIN ON *.* TO 'mgr_backup'@'localhost';"
execute_sql "GRANT RELOAD ON *.* TO 'mgr_backup'@'localhost';"
execute_sql "GRANT LOCK TABLES ON *.* TO 'mgr_backup'@'localhost';"
execute_sql "GRANT REPLICATION CLIENT ON *.* TO 'mgr_backup'@'localhost';"

# 5. 刷新权限
execute_sql "FLUSH PRIVILEGES;"

echo "=== 用户创建完成，密码信息 ==="
echo "复制用户密码: ${REPL_PASSWORD}"
echo "管理用户密码: ${ADMIN_PASSWORD}"
echo "监控用户密码: ${MONITOR_PASSWORD}"
echo "备份用户密码: ${BACKUP_PASSWORD}"
echo "请妥善保存这些密码！"
```

### 7.2 权限检查脚本


**📝 权限审计脚本**

```bash
#!/bin/bash
# mgr_permission_check.sh - MGR权限检查脚本

MYSQL_HOST="localhost"
MYSQL_USER="root"
MYSQL_PASS="RootPass@2024"

echo "=== MGR权限检查报告 ==="
echo "检查时间: $(date)"
echo ""

# 1. 检查MGR相关用户
echo "--- 1. MGR相关用户列表 ---"
mysql -h${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    User, 
    Host, 
    account_locked, 
    password_expired,
    password_last_changed
FROM mysql.user 
WHERE User LIKE '%mgr%' OR User LIKE '%repl%'
ORDER BY User, Host;" 2>/dev/null

# 2. 检查高权限用户
echo ""
echo "--- 2. 高权限用户检查 ---"
mysql -h${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    User, 
    Host, 
    Super_priv, 
    Grant_priv,
    Create_user_priv
FROM mysql.user 
WHERE Super_priv = 'Y' OR Grant_priv = 'Y' OR Create_user_priv = 'Y'
ORDER BY User;" 2>/dev/null

# 3. 检查复制权限
echo ""
echo "--- 3. 复制权限用户 ---"
mysql -h${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    User, 
    Host, 
    Repl_slave_priv, 
    Repl_client_priv
FROM mysql.user 
WHERE Repl_slave_priv = 'Y' OR Repl_client_priv = 'Y'
ORDER BY User;" 2>/dev/null

# 4. 检查空密码用户
echo ""
echo "--- 4. 安全风险检查 ---"
mysql -h${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    User, 
    Host,
    CASE 
        WHEN authentication_string = '' THEN '空密码'
        WHEN User = '' THEN '匿名用户'
        ELSE '正常'
    END as 安全状态
FROM mysql.user 
WHERE authentication_string = '' OR User = '';" 2>/dev/null

# 5. 检查MGR全局权限
echo ""
echo "--- 5. MGR相关全局权限 ---"
mysql -h${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_PASS} -e "
SELECT 
    User, 
    Host, 
    Priv as 权限名称
FROM mysql.global_grants 
WHERE Priv LIKE '%GROUP_REPLICATION%' 
   OR Priv LIKE '%BACKUP%'
   OR Priv LIKE '%CONNECTION%'
ORDER BY User, Priv;" 2>/dev/null

echo ""
echo "=== 权限检查完成 ==="
```

### 7.3 用户维护脚本


**📝 密码更新脚本**

```bash
#!/bin/bash
# mgr_password_rotation.sh - MGR用户密码轮换脚本

MYSQL_HOST="localhost"
MYSQL_ROOT_USER="root"
MYSQL_ROOT_PASS="RootPass@2024"

# 生成新密码
generate_password() {
    echo "Mgr$(openssl rand -base64 12 | tr -d '=+/' | cut -c1-8)@$(date +%Y)"
}

echo "=== MGR用户密码轮换开始 ==="

# 获取需要更新的用户列表
users=$(mysql -h${MYSQL_HOST} -u${MYSQL_ROOT_USER} -p${MYSQL_ROOT_PASS} -sN -e "
SELECT CONCAT(User, '@', Host) 
FROM mysql.user 
WHERE User LIKE '%mgr%' 
AND password_last_changed < DATE_SUB(NOW(), INTERVAL 90 DAY);" 2>/dev/null)

if [ -z "$users" ]; then
    echo "没有需要更新密码的用户"
    exit 0
fi

echo "需要更新密码的用户:"
echo "$users"
echo ""

# 更新密码
for user_host in $users; do
    user=$(echo $user_host | cut -d'@' -f1)
    host=$(echo $user_host | cut -d'@' -f2)
    new_password=$(generate_password)
    
    echo "更新用户 ${user}@${host} 的密码..."
    
    mysql -h${MYSQL_HOST} -u${MYSQL_ROOT_USER} -p${MYSQL_ROOT_PASS} -e "
    ALTER USER '${user}'@'${host}' IDENTIFIED BY '${new_password}';" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "✅ ${user}@${host} 密码更新成功"
        echo "新密码: ${new_password}"
        echo "请及时通知相关人员更新配置"
    else
        echo "❌ ${user}@${host} 密码更新失败"
    fi
    echo ""
done

echo "=== 密码轮换完成 ==="
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 MGR用户权限：分层管理，职责明确，权限最小化
🔸 复制用户：专门负责节点间数据同步的特殊账户
🔸 核心权限：REPLICATION SLAVE、GROUP_REPLICATION_ADMIN等
🔸 SSL认证：确保MGR通信安全的重要机制
🔸 安全加固：密码策略、权限审计、风险控制
```

### 8.2 关键理解要点


**🔹 权限设计原则**
```
最小权限原则：
• 只给必需的权限，不给多余权限
• 按用户职责分配不同权限级别
• 定期审查和清理无用权限

分层管理原则：
• 管理员 > 操作员 > 监控员 > 应用用户
• 不同层级有不同的权限范围
• 避免权限交叉和混乱
```

**🔹 复制用户重要性**
```
为什么需要专门的复制用户：
• MGR节点间需要相互连接传输数据
• 复制用户是这个连接的"钥匙"
• 权限配置错误会导致复制失败
• 安全配置保护集群通信安全
```

**🔹 SSL认证价值**
```
SSL认证的作用：
• 加密传输：防止数据被窃听
• 身份验证：确认连接方身份
• 完整性校验：防止数据被篡改
• 合规要求：满足安全标准
```

### 8.3 实际应用价值


**💼 生产环境应用**
- **权限规划**：根据团队角色设计权限体系
- **安全加固**：实施多层次的安全防护措施
- **运维管理**：建立权限审计和维护流程
- **故障处理**：快速定位和解决权限相关问题

**🛡️ 安全防护**
- **权限控制**：防止未授权访问和操作
- **审计追踪**：记录和监控权限使用情况
- **风险控制**：及时发现和处理安全威胁
- **合规保障**：满足行业安全规范要求

**📈 运维效率**
- **自动化管理**：使用脚本批量管理用户权限
- **标准化流程**：建立规范的权限管理流程
- **监控告警**：及时发现权限异常和安全问题
- **文档管理**：完善的权限配置和操作文档

**🔧 最佳实践建议**
- 定期更新密码，使用强密码策略
- 启用SSL加密，保护通信安全
- 实施权限分离，避免权限过度集中
- 建立审计机制，定期检查权限配置
- 制定应急流程，快速处理安全事件

**核心记忆**：
- MGR权限管理是集群安全的基础
- 复制用户是节点通信的关键
- 权限最小化原则不可违背
- SSL认证是生产环境必选项
- 定期审计确保权限合规性