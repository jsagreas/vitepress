---
title: 13、MGR集群成员管理
---
## 📚 目录

1. [MGR成员管理概述](#1-MGR成员管理概述)
2. [节点加入集群操作](#2-节点加入集群操作)
3. [节点退出集群操作](#3-节点退出集群操作)
4. [成员状态监控与查询](#4-成员状态监控与查询)
5. [节点权重与角色管理](#5-节点权重与角色管理)
6. [成员视图变更处理](#6-成员视图变更处理)
7. [动态成员管理策略](#7-动态成员管理策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 MGR成员管理概述


### 1.1 什么是MGR成员管理


**简单理解**：MGR成员管理就是对MySQL Group Replication集群中各个节点进行添加、删除、监控和维护的操作

```
MGR集群示意图：
    节点A (Primary)    ←─┐
         ↕              │ 集群成员管理
    节点B (Secondary)  ←─┤ • 加入/退出
         ↕              │ • 状态监控  
    节点C (Secondary)  ←─┤ • 角色切换
         ↕              │ • 健康检查
    节点D (Secondary)  ←─┘
```

**核心管理内容**：
- 🔧 **节点生命周期管理** - 加入、退出、重启
- 📊 **状态监控** - 实时查看各节点健康状态
- ⚖️ **负载均衡** - 权重配置和角色分配
- 🔄 **故障处理** - 自动故障转移和恢复

### 1.2 成员管理的重要性


**为什么需要成员管理**：
```
业务连续性：
├─ 节点故障时快速剔除故障节点
├─ 新增节点时平滑加入集群
├─ 维护期间优雅下线节点
└─ 角色切换保证服务不中断

性能优化：
├─ 根据硬件配置调整节点权重
├─ 优化读写负载分布
├─ 动态调整集群规模
└─ 监控瓶颈节点性能
```

---

## 2. ➕ 节点加入集群操作


### 2.1 标准加入流程


**节点加入集群的完整步骤**：

```
步骤流程图：
准备新节点 → 配置MGR参数 → 启动Group Replication → 等待数据同步 → 验证加入成功

详细说明：
┌─────────────────────────────────────────────────────────────────┐
│ 1. 准备阶段    │ 2. 配置阶段    │ 3. 启动阶段    │ 4. 验证阶段    │
├─────────────────────────────────────────────────────────────────┤
│ • 硬件检查     │ • MGR参数配置  │ • 启动插件     │ • 状态检查     │
│ • 网络连通性   │ • 集群信息设置 │ • 数据同步     │ • 性能测试     │
│ • MySQL版本    │ • 安全认证     │ • 角色分配     │ • 日志检查     │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 新节点配置准备


**🔸 基础环境配置**
```sql
-- 1. 检查MySQL版本兼容性
SELECT VERSION();

-- 2. 确保必要插件已安装
SHOW PLUGINS;

-- 3. 配置MGR基础参数
SET GLOBAL group_replication_group_name = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa';
SET GLOBAL group_replication_start_on_boot = OFF;
SET GLOBAL group_replication_bootstrap_group = OFF;
```

**🔸 网络和安全配置**
```sql
-- 配置本地地址
SET GLOBAL group_replication_local_address = '192.168.1.10:33061';

-- 配置种子节点列表
SET GLOBAL group_replication_group_seeds = '192.168.1.11:33061,192.168.1.12:33061';

-- 配置SSL（推荐）
SET GLOBAL group_replication_ssl_mode = 'REQUIRED';
```

### 2.3 执行加入操作


**🔸 启动Group Replication**
```sql
-- 在新节点上执行
START GROUP_REPLICATION;

-- 检查启动状态
SELECT * FROM performance_schema.replication_group_members;
```

**🔸 监控加入过程**
```sql
-- 查看同步进度
SELECT 
    MEMBER_STATE,
    MEMBER_ROLE,
    MEMBER_HOST,
    MEMBER_PORT
FROM performance_schema.replication_group_members
WHERE MEMBER_ID = $$server_uuid;

-- 状态说明：
-- RECOVERING: 正在同步数据
-- ONLINE: 已成功加入并同步完成
-- ERROR: 加入失败
```

### 2.4 加入过程故障排查


**常见加入失败原因**：
```sql
-- 1. 检查错误日志
SHOW GLOBAL STATUS LIKE 'group_replication_primary_member';

-- 2. 网络连接问题
SELECT * FROM performance_schema.replication_connection_status;

-- 3. 版本兼容性问题  
SELECT * FROM performance_schema.global_variables 
WHERE VARIABLE_NAME LIKE 'group_replication%';
```

**> ⚠️ 注意**：新节点加入时会自动从Primary节点获取全量数据，大型数据库可能需要较长时间

---

## 3. ➖ 节点退出集群操作


### 3.1 优雅退出流程


**计划内节点退出步骤**：

```
优雅退出流程图：
业务流量切换 → 等待事务完成 → 停止Group Replication → 节点下线 → 清理配置

时间线：
0分钟     5分钟      10分钟     15分钟     20分钟
  │         │          │          │          │
业务切换  等待同步   停止服务   节点下线   清理完成
```

### 3.2 Secondary节点退出


**🔸 Secondary节点安全退出**
```sql
-- 1. 检查当前节点角色
SELECT 
    MEMBER_HOST,
    MEMBER_ROLE,
    MEMBER_STATE
FROM performance_schema.replication_group_members
WHERE MEMBER_ID = $$server_uuid;

-- 2. 确保数据同步完成
SELECT 
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_TRANSACTIONS_CHECKED
FROM performance_schema.replication_group_member_stats
WHERE MEMBER_ID = $$server_uuid;

-- 3. 停止Group Replication
STOP GROUP_REPLICATION;
```

### 3.3 Primary节点退出


**🔸 Primary节点特殊处理**
```sql
-- 1. 触发选举新的Primary（自动进行）
-- 在停止前，集群会自动选举新的Primary节点

-- 2. 等待选举完成
SELECT 
    MEMBER_HOST,
    MEMBER_ROLE
FROM performance_schema.replication_group_members
WHERE MEMBER_ROLE = 'PRIMARY';

-- 3. 确认新Primary后停止
STOP GROUP_REPLICATION;
```

### 3.4 强制退出处理


**紧急情况下的强制退出**：
```sql
-- 1. 强制停止（谨慎使用）
STOP GROUP_REPLICATION;

-- 2. 如果无法正常停止，重置配置
RESET SLAVE ALL FOR CHANNEL 'group_replication_applier';
RESET SLAVE ALL FOR CHANNEL 'group_replication_recovery';

-- 3. 清理组复制配置
SET GLOBAL group_replication_group_name = '';
```

**> ⚠️ 警告**：强制退出可能导致数据不一致，仅在紧急情况使用

---

## 4. 📊 成员状态监控与查询


### 4.1 核心监控视图


**🔸 replication_group_members视图**
```sql
-- 查看所有集群成员基本信息
SELECT 
    MEMBER_ID,
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE,
    MEMBER_VERSION
FROM performance_schema.replication_group_members;

-- 输出示例：
┌─────────────────┬─────────────┬─────────┬─────────┬───────────┬──────────────┐
│    MEMBER_ID    │ MEMBER_HOST │  PORT   │ STATE   │   ROLE    │   VERSION    │
├─────────────────┼─────────────┼─────────┼─────────┼───────────┼──────────────┤
│ uuid-node-1     │ 192.168.1.11│  3306   │ ONLINE  │ PRIMARY   │ 8.0.32-24    │
│ uuid-node-2     │ 192.168.1.12│  3306   │ ONLINE  │ SECONDARY │ 8.0.32-24    │
│ uuid-node-3     │ 192.168.1.13│  3306   │ ONLINE  │ SECONDARY │ 8.0.32-24    │
└─────────────────┴─────────────┴─────────┴─────────┴───────────┴──────────────┘
```

**🔸 replication_group_member_stats视图**
```sql
-- 查看成员详细统计信息
SELECT 
    MEMBER_ID,
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_TRANSACTIONS_CHECKED,
    COUNT_CONFLICTS_DETECTED,
    COUNT_TRANSACTIONS_ROWS_VALIDATING
FROM performance_schema.replication_group_member_stats;
```

### 4.2 健康状态检查


**🔸 成员状态含义解析**
```sql
-- 成员状态检查脚本
SELECT 
    MEMBER_HOST,
    MEMBER_STATE,
    CASE MEMBER_STATE
        WHEN 'ONLINE' THEN '✅ 正常运行'
        WHEN 'RECOVERING' THEN '🔄 数据同步中'
        WHEN 'OFFLINE' THEN '❌ 离线状态'
        WHEN 'ERROR' THEN '🚫 错误状态'
        WHEN 'UNREACHABLE' THEN '🔌 网络不通'
        ELSE '❓ 未知状态'
    END AS STATUS_DESC
FROM performance_schema.replication_group_members;
```

**状态类型详解**：
| 状态 | **含义** | **处理建议** |
|------|----------|--------------|
| 🟢 **ONLINE** | `节点正常运行，可提供服务` | `正常状态，无需处理` |
| 🟡 **RECOVERING** | `正在恢复数据，暂时只读` | `等待恢复完成，监控进度` |
| 🔴 **OFFLINE** | `节点已离线，不参与复制` | `检查节点状态，重新启动` |
| 🚫 **ERROR** | `节点出现错误，需要修复` | `查看错误日志，手动修复` |
| ⚡ **UNREACHABLE** | `网络连接中断` | `检查网络连接，修复网络` |

### 4.3 性能监控指标


**🔸 事务队列监控**
```sql
-- 监控事务处理性能
SELECT 
    MEMBER_HOST,
    COUNT_TRANSACTIONS_IN_QUEUE AS '待处理事务',
    COUNT_TRANSACTIONS_CHECKED AS '已检查事务',
    COUNT_CONFLICTS_DETECTED AS '冲突检测次数',
    ROUND(
        COUNT_TRANSACTIONS_CHECKED / 
        (COUNT_TRANSACTIONS_CHECKED + COUNT_TRANSACTIONS_IN_QUEUE) * 100, 2
    ) AS '处理完成率%'
FROM performance_schema.replication_group_member_stats;
```

**🔸 复制延迟监控**
```sql
-- 查看复制延迟
SELECT 
    CHANNEL_NAME,
    SERVICE_STATE,
    LAST_ERROR_MESSAGE,
    LAST_ERROR_TIMESTAMP
FROM performance_schema.replication_connection_status
WHERE CHANNEL_NAME LIKE 'group_replication%';
```

---

## 5. ⚖️ 节点权重与角色管理


### 5.1 节点权重配置


**什么是节点权重**：决定节点在Primary选举中的优先级

```sql
-- 查看当前权重配置
SELECT $$group_replication_member_weight;

-- 设置节点权重（0-100，越高优先级越高）
SET GLOBAL group_replication_member_weight = 90;  -- 高性能节点
SET GLOBAL group_replication_member_weight = 50;  -- 普通节点  
SET GLOBAL group_replication_member_weight = 10;  -- 备用节点
```

**权重配置策略**：
```
高权重节点（80-100）：
├─ 高性能硬件配置
├─ 网络条件良好
├─ 负载较轻
└─ 优先作为Primary

中等权重节点（40-70）：
├─ 中等硬件配置
├─ 作为Secondary节点
├─ 承担读取负载
└─ Primary候选节点

低权重节点（0-30）：
├─ 硬件配置较低
├─ 网络条件一般
├─ 仅作为数据备份
└─ 不参与Primary选举
```

### 5.2 角色切换操作


**🔸 手动切换Primary**
```sql
-- 方法1：停止当前Primary的Group Replication
-- 在当前Primary节点执行
STOP GROUP_REPLICATION;
-- 集群自动选举新的Primary

-- 方法2：使用MySQL Shell切换（推荐）
-- mysqlsh连接到集群后执行
-- cluster.setPrimaryInstance('newprimary:3306')
```

**🔸 监控角色切换过程**
```sql
-- 实时查看角色状态
SELECT 
    MEMBER_HOST,
    MEMBER_ROLE,
    MEMBER_STATE,
    NOW() AS CHECK_TIME
FROM performance_schema.replication_group_members
ORDER BY MEMBER_ROLE DESC;
```

### 5.3 节点选举机制


**Primary选举规则**：
```
选举优先级排序：
1. 权重最高的ONLINE节点
2. 权重相同时选择server_uuid最小的节点
3. 所有SECONDARY节点参与选举投票
4. 获得多数票的节点成为新Primary

选举触发条件：
├─ 当前Primary节点离线
├─ 当前Primary节点出现ERROR状态  
├─ 网络分区导致Primary不可达
└─ 手动触发角色切换
```

---

## 6. 🔄 成员视图变更处理


### 6.1 什么是成员视图变更


**成员视图变更**：集群成员状态发生变化时，所有节点需要更新集群成员信息

```
视图变更示例：
原始视图: [NodeA(Primary), NodeB(Secondary), NodeC(Secondary)]
                              ↓
            NodeB故障离线
                              ↓  
新视图:   [NodeA(Primary), NodeC(Secondary)]

变更过程：
1. 检测到NodeB离线
2. 触发成员视图变更
3. 所有节点更新成员列表
4. 重新分配负载
```

### 6.2 视图变更监控


**🔸 查看视图变更历史**
```sql
-- 查看最近的视图变更
SELECT 
    MEMBER_ID,
    MEMBER_HOST,
    MEMBER_STATE,
    LAST_HEARTBEAT_TIMESTAMP
FROM performance_schema.replication_group_members;

-- 监控视图变更频率
SELECT 
    COUNT(*) AS view_changes,
    DATE(NOW()) AS check_date
FROM performance_schema.replication_group_members;
```

**🔸 视图变更事件处理**
```sql
-- 检查是否有pending的视图变更
SELECT 
    COUNT(*) AS pending_changes
FROM performance_schema.replication_group_members 
WHERE MEMBER_STATE IN ('RECOVERING', 'UNREACHABLE');

-- 查看错误的成员
SELECT 
    MEMBER_HOST,
    MEMBER_STATE,
    'Need manual intervention' AS action_required
FROM performance_schema.replication_group_members 
WHERE MEMBER_STATE = 'ERROR';
```

### 6.3 视图变更故障处理


**处理不健康的成员**：
```sql
-- 1. 识别问题节点
SELECT 
    MEMBER_HOST,
    MEMBER_STATE,
    TIMESTAMPDIFF(MINUTE, LAST_HEARTBEAT_TIMESTAMP, NOW()) AS minutes_since_heartbeat
FROM performance_schema.replication_group_members
WHERE MEMBER_STATE != 'ONLINE';

-- 2. 强制移除故障节点（谨慎操作）
-- 在故障节点恢复前，可能需要手动从集群中移除
```

---

## 7. 🎛️ 动态成员管理策略


### 7.1 自动化管理脚本


**🔸 成员健康检查脚本**
```bash
#!/bin/bash
# MGR集群健康检查脚本

check_mgr_health() {
    mysql -u monitor -p"$MONITOR_PASS" -e "
    SELECT 
        MEMBER_HOST,
        MEMBER_STATE,
        MEMBER_ROLE,
        CASE 
            WHEN MEMBER_STATE = 'ONLINE' THEN 'OK'
            WHEN MEMBER_STATE = 'RECOVERING' THEN 'SYNCING'
            ELSE 'ERROR'
        END AS STATUS
    FROM performance_schema.replication_group_members;
    "
}

# 检查并发送告警
check_mgr_health | grep ERROR && send_alert
```

**🔸 自动故障转移脚本**
```bash
#!/bin/bash
# 自动故障处理

handle_failed_member() {
    FAILED_HOST=$1
    
    # 1. 尝试重启节点
    ssh $FAILED_HOST "systemctl restart mysql"
    
    # 2. 等待30秒检查恢复状态
    sleep 30
    
    # 3. 如果仍然失败，从集群移除
    if ! check_member_online $FAILED_HOST; then
        echo "Removing failed member: $FAILED_HOST"
        # 执行移除操作
    fi
}
```

### 7.2 容量规划与扩缩容


**🔸 集群扩容策略**
```sql
-- 扩容前评估
SELECT 
    COUNT(*) AS current_members,
    AVG(COUNT_TRANSACTIONS_IN_QUEUE) AS avg_queue_size,
    MAX(COUNT_TRANSACTIONS_IN_QUEUE) AS max_queue_size
FROM performance_schema.replication_group_member_stats;

-- 扩容时机判断：
-- 1. 平均队列长度 > 100
-- 2. 最大队列长度 > 500  
-- 3. CPU使用率持续 > 80%
-- 4. 读取负载分布不均
```

**🔸 集群缩容考虑**
```sql
-- 缩容前检查
SELECT 
    MEMBER_HOST,
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_CONFLICTS_DETECTED
FROM performance_schema.replication_group_member_stats
ORDER BY COUNT_TRANSACTIONS_IN_QUEUE;

-- 优先移除负载最轻的节点
-- 确保至少保留3个节点（保证高可用）
```

### 7.3 维护窗口管理


**计划维护的最佳实践**：
```
维护流程：
1. 提前通知 → 2. 流量切换 → 3. 节点下线 → 4. 执行维护 → 5. 节点上线

时间规划：
├─ 低峰期维护：凌晨2-6点
├─ 逐台维护：避免同时维护多台
├─ 预留回滚时间：至少1小时
└─ 监控强化：维护期间加强监控
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 成员生命周期：加入 → 在线 → 角色切换 → 离线退出
🔸 状态监控：ONLINE、RECOVERING、ERROR、OFFLINE、UNREACHABLE
🔸 角色管理：Primary选举、权重配置、手动切换
🔸 视图变更：成员状态变化时的集群信息同步机制
🔸 故障处理：自动检测、告警通知、故障转移
```

### 8.2 关键理解要点


**🔹 成员管理的核心原则**
```
高可用优先：
├─ 至少保持3个节点在线
├─ Primary故障时快速选举新Primary
├─ Secondary故障时不影响写入服务
└─ 网络分区时选择多数派继续服务

数据一致性：
├─ 新节点加入前必须完成数据同步
├─ 节点退出前确保事务处理完成
├─ 冲突检测和解决机制
└─ 分布式事务的一致性保证
```

**🔹 监控重点指标**
```
关键监控项：
├─ 成员状态：所有节点应为ONLINE状态
├─ 事务队列：队列长度反映同步性能
├─ 冲突检测：冲突次数影响性能
├─ 网络延迟：影响复制速度
└─ 选举频率：频繁选举说明集群不稳定
```

### 8.3 实际运维建议


**🔸 日常运维检查清单**
```sql
-- 每日检查脚本
-- 1. 检查所有成员状态
SELECT MEMBER_HOST, MEMBER_STATE, MEMBER_ROLE 
FROM performance_schema.replication_group_members;

-- 2. 检查事务队列情况
SELECT MEMBER_HOST, COUNT_TRANSACTIONS_IN_QUEUE 
FROM performance_schema.replication_group_member_stats;

-- 3. 检查是否有冲突
SELECT SUM(COUNT_CONFLICTS_DETECTED) AS total_conflicts
FROM performance_schema.replication_group_member_stats;
```

**🔸 故障应急处理流程**
```
故障等级分类：
├─ P0级：Primary节点故障 → 立即触发选举，5分钟内恢复
├─ P1级：Secondary节点故障 → 30分钟内恢复或移除
├─ P2级：性能异常 → 1小时内定位并优化
└─ P3级：告警误报 → 2小时内调整监控阈值
```

**核心记忆要点**：
- MGR成员管理是保证集群高可用的关键
- 成员状态监控要实时进行，异常要快速响应
- 权重配置影响Primary选举，需要合理规划
- 视图变更频繁说明集群不稳定，需要排查原因
- 自动化脚本能提高运维效率和响应速度