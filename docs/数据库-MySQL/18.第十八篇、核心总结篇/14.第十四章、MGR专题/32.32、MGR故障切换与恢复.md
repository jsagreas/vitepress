---
title: 32、MGR故障切换与恢复
---
## 📚 目录

1. [MGR故障切换基本概念](#1-MGR故障切换基本概念)
2. [故障检测机制详解](#2-故障检测机制详解)
3. [自动故障切换流程](#3-自动故障切换流程)
4. [主节点选举机制](#4-主节点选举机制)
5. [故障恢复策略](#5-故障恢复策略)
6. [手动故障切换操作](#6-手动故障切换操作)
7. [切换监控与优化](#7-切换监控与优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 MGR故障切换基本概念


### 1.1 什么是MGR故障切换


**简单理解**：故障切换就像公司老板突然生病，副总经理自动接替工作，确保公司正常运转。

```
MGR故障切换 = 主节点出问题时，从节点自动变成新主节点

为什么需要故障切换？
✅ 保证业务连续性：主库挂了，从库顶上
✅ 减少停机时间：自动切换，无需人工干预
✅ 保护数据安全：防止数据丢失和不一致
```

**故障切换的本质**：
- **角色转换**：从节点变成主节点
- **服务迁移**：应用连接切换到新主节点
- **数据保护**：确保数据完整性和一致性

### 1.2 MGR故障切换类型


```
📊 故障切换类型对比

自动故障切换（Auto Failover）：
┌─────────────────────────────────┐
│ 主节点故障 → MGR自动检测        │
│          ↓                     │
│ 从节点自动提升为新主节点         │
│          ↓                     │
│ 应用自动连接到新主节点          │
└─────────────────────────────────┘

手动故障切换（Manual Failover）：
┌─────────────────────────────────┐
│ DBA手动执行切换命令            │
│          ↓                     │
│ 指定某个从节点升级为主节点       │
│          ↓                     │
│ 手动修改应用连接配置            │
└─────────────────────────────────┘
```

**两种方式的选择**：
- **自动切换**：适合7×24小时无人值守环境
- **手动切换**：适合计划维护或需要精确控制的场景

### 1.3 故障切换的核心目标


```
🎯 故障切换要达到的目标

业务连续性：
• RTO（恢复时间目标）< 30秒
• RPO（恢复点目标）= 0（无数据丢失）
• 应用感知最小化

数据一致性：
• 所有节点数据同步
• 避免脑裂问题
• 防止数据冲突

高可用性：
• 单点故障不影响服务
• 快速故障检测和恢复
• 自动化程度高
```

---

## 2. 🔍 故障检测机制详解


### 2.1 MGR故障检测原理


**通俗解释**：就像一群朋友约定每5分钟互相发个消息报平安，如果某人超时没回复，大家就知道他可能出事了。

```
MGR故障检测流程：

步骤1：心跳检测
节点A ──ping──> 节点B
节点A <──pong── 节点B
      ↓
   正常状态

步骤2：超时检测  
节点A ──ping──> 节点B
节点A <──❌── 节点B（无响应）
      ↓
   疑似故障

步骤3：故障确认
节点A ──确认──> 节点C
节点C ──确认──> 节点A
      ↓
   故障确定
```

### 2.2 关键检测参数


**重要参数配置**：
```sql
-- 群组通信检测间隔（心跳间隔）
SET GLOBAL group_replication_member_expel_timeout = 60;

-- 故障检测超时时间
SET GLOBAL group_replication_unreachable_majority_timeout = 0;

-- 网络分区检测
SET GLOBAL group_replication_autorejoin_tries = 3;
```

**参数含义解释**：
- `member_expel_timeout`：多久没心跳就认为节点故障（默认60秒）
- `unreachable_majority_timeout`：网络分区时的处理策略
- `autorejoin_tries`：节点自动重新加入集群的尝试次数

### 2.3 故障检测类型


```
🔍 MGR能检测的故障类型

节点级故障：
• MySQL进程崩溃
• 操作系统宕机  
• 服务器断电
• 内存不足导致OOM

网络故障：
• 网络分区（脑裂）
• 网络延迟过高
• 网络丢包严重
• 交换机故障

应用层故障：
• 磁盘空间不足
• 磁盘IO异常
• CPU使用率过高
• 复制延迟过大
```

**检测时间对比**：
```
故障类型          检测时间
进程崩溃          5-10秒
服务器宕机        10-30秒  
网络分区          30-60秒
性能问题          60-120秒
```

### 2.4 误判预防机制


**避免误判的方法**：
```
多重验证机制：
┌──────────────────────────────────┐
│ 步骤1：初步检测（单节点判断）     │
│ 步骤2：交叉验证（多节点确认）     │
│ 步骤3：最终决策（集群共识）       │
└──────────────────────────────────┘

时间缓冲：
• 网络抖动容忍：5秒内的短暂中断忽略
• 多次确认：连续3次检测失败才判定故障
• 渐进式检测：检测频率逐步提高
```

---

## 3. ⚡ 自动故障切换流程


### 3.1 自动切换完整流程


**整个过程就像选班长**：原班长生病了，大家投票选新班长，新班长上任处理班级事务。

```
自动故障切换详细流程：

第1阶段：故障检测（5-10秒）
主节点异常 → 从节点检测到 → 开始切换流程
    ↓
第2阶段：节点选举（10-20秒）  
剩余节点投票 → 选出新主节点 → 角色转换
    ↓
第3阶段：服务恢复（5-15秒）
新主节点就绪 → 开始接受写请求 → 通知应用层
    ↓
第4阶段：集群同步（持续进行）
新主节点同步 → 其他从节点同步 → 集群状态正常
```

### 3.2 切换流程代码示例


**监控切换状态的SQL**：
```sql
-- 查看集群当前状态
SELECT 
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE,
    MEMBER_VERSION
FROM performance_schema.replication_group_members;

-- 检查是否正在进行故障切换
SELECT 
    CHANNEL_NAME,
    SERVICE_STATE,
    LAST_ERROR_MESSAGE
FROM performance_schema.replication_connection_status;
```

**切换后的验证**：
```sql
-- 验证新主节点是否可写
CREATE TABLE failover_test (id INT PRIMARY KEY, test_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
INSERT INTO failover_test (id) VALUES (1);
SELECT * FROM failover_test;
DROP TABLE failover_test;

-- 检查所有节点数据是否一致
SELECT $$server_uuid, $$hostname, COUNT(*) FROM your_table;
```

### 3.3 切换时间优化


```
🚀 优化切换速度的方法

网络优化：
• 使用专用网络：避免网络拥塞
• 调整心跳间隔：适当缩短检测时间
• 网络设备优化：减少网络延迟

配置优化：
• 合理设置超时参数
• 启用并行复制：提高同步速度
• 优化日志配置：减少IO开销

硬件优化：
• SSD存储：提高IO性能
• 充足内存：减少磁盘交换
• 高性能网卡：提高网络吞吐
```

---

## 4. 🗳️ 主节点选举机制


### 4.1 选举算法原理


**通俗理解**：就像公司选总经理，要看资历（数据完整性）、能力（性能）、得票数（节点支持）。

```
MGR主节点选举考虑因素：

优先级排序：
1️⃣ 数据完整性（最重要）
   → 哪个节点的数据最新、最完整
   
2️⃣ 节点权重设置
   → group_replication_member_weight参数
   
3️⃣ 服务器UUID
   → 相同条件下，UUID较小的节点优先
   
4️⃣ 网络连通性
   → 能与多数节点通信的节点优先
```

### 4.2 选举过程详解


```
选举流程图：

故障发生
    ↓
剩余节点检测到主节点失联
    ↓
开始选举投票
    ↓
┌─────────────────────────────────┐
│ 候选节点1：权重=100，数据最新    │ ← 最可能当选
│ 候选节点2：权重=50，数据略旧     │
│ 候选节点3：权重=30，数据较旧     │
└─────────────────────────────────┘
    ↓
多数节点投票决定
    ↓
新主节点产生并接管服务
```

**选举配置示例**：
```sql
-- 设置节点权重（权重越高，越优先被选为主节点）
SET GLOBAL group_replication_member_weight = 100;

-- 查看当前权重配置
SELECT 
    MEMBER_HOST,
    MEMBER_WEIGHT,
    MEMBER_ROLE,
    MEMBER_STATE
FROM performance_schema.replication_group_member_stats;
```

### 4.3 选举策略优化


```
📊 不同场景的选举策略

高性能场景：
• 性能最强的服务器设置最高权重
• 确保主节点能处理高并发

地理分布场景：  
• 每个机房设置一个高权重节点
• 避免跨机房的主从复制延迟

成本控制场景：
• 高配置服务器做主节点
• 低配置服务器做从节点
```

---

## 5. 🔄 故障恢复策略


### 5.1 故障节点恢复流程


**故障恢复就像员工病假后回来上班**：需要了解这段时间发生了什么，补上落下的工作。

```
节点恢复步骤：

第1步：问题修复
硬件故障 → 更换硬件 → 系统启动
软件故障 → 修复配置 → 服务重启
网络故障 → 修复网络 → 连通性恢复

第2步：数据同步
启动MySQL → 连接到集群 → 自动数据同步
     ↓
增量同步 → 全量同步（如需要）→ 同步完成

第3步：状态恢复
同步完成 → 节点状态变为ONLINE → 可以承担读写负载
```

### 5.2 数据一致性保证


```sql
-- 恢复节点时检查数据一致性
-- 1. 检查GTID位点
SELECT $$global.gtid_executed;

-- 2. 检查binlog位置
SHOW MASTER STATUS;

-- 3. 对比关键表数据
SELECT COUNT(*), MAX(update_time) FROM critical_table;

-- 4. 验证恢复完成
SELECT MEMBER_STATE FROM performance_schema.replication_group_members 
WHERE MEMBER_HOST = '恢复节点IP';
```

### 5.3 恢复时间优化


```
⚡ 加速恢复的方法

并行恢复：
• 启用多线程复制
• slave_parallel_workers = 8
• slave_parallel_type = LOGICAL_CLOCK

增量备份：
• 定期备份增量数据
• 使用xtrabackup等工具
• 减少全量同步时间

网络优化：
• 专用同步网络
• 调整TCP参数
• 使用高速网络设备
```

**恢复时间对比**：
```
数据量        增量恢复    全量恢复
100GB        5-10分钟    2-4小时
500GB        15-30分钟   8-12小时  
1TB          30-60分钟   16-24小时
```

---

## 6. 🛠️ 手动故障切换操作


### 6.1 何时需要手动切换


**手动切换的使用场景**：
```
计划维护：
• 主节点硬件升级
• 操作系统补丁更新
• MySQL版本升级
• 数据库参数调整

性能优化：
• 负载重新分布
• 主节点性能问题
• 网络拓扑优化
• 机房迁移

应急处理：
• 自动切换失败
• 需要指定特定节点
• 数据一致性问题
• 网络分区恢复
```

### 6.2 手动切换操作步骤


**完整的手动切换流程**：

```sql
-- 步骤1：停止当前主节点的写入（在应用层操作）
-- 确保没有新的写入请求

-- 步骤2：在当前主节点设置只读
SET GLOBAL read_only = 1;
SET GLOBAL super_read_only = 1;

-- 步骤3：等待所有从节点同步完成
-- 在所有从节点检查同步状态
SELECT MEMBER_STATE, MEMBER_ROLE 
FROM performance_schema.replication_group_members;

-- 步骤4：停止当前主节点的Group Replication
STOP GROUP_REPLICATION;

-- 步骤5：在新主节点启动为主模式
SET GLOBAL group_replication_bootstrap_group = ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group = OFF;

-- 步骤6：其他节点重新加入集群
-- 在其他节点执行
START GROUP_REPLICATION;

-- 步骤7：验证切换结果
SELECT MEMBER_HOST, MEMBER_ROLE, MEMBER_STATE 
FROM performance_schema.replication_group_members;
```

### 6.3 切换验证方法


```sql
-- 验证新主节点可写性
CREATE DATABASE switch_test;
USE switch_test;
CREATE TABLE test_table (id INT PRIMARY KEY, switch_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
INSERT INTO test_table (id) VALUES (1);

-- 验证从节点同步
-- 在从节点检查数据是否已同步
SELECT * FROM switch_test.test_table;

-- 清理测试数据
DROP DATABASE switch_test;

-- 验证集群状态
SELECT 
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE
FROM performance_schema.replication_group_members
ORDER BY MEMBER_ROLE DESC;
```

---

## 7. 📊 切换监控与优化


### 7.1 监控关键指标


**需要监控的重要指标**：

```sql
-- 1. 集群健康状态监控
SELECT 
    MEMBER_HOST,
    MEMBER_STATE,
    MEMBER_ROLE,
    IF(MEMBER_STATE='ONLINE', '正常', '异常') as status
FROM performance_schema.replication_group_members;

-- 2. 复制延迟监控  
SELECT 
    CHANNEL_NAME,
    COUNT_TRANSACTIONS_IN_QUEUE as 待同步事务数,
    COUNT_TRANSACTIONS_CHECKED as 已检查事务数
FROM performance_schema.replication_group_member_stats;

-- 3. 网络连接监控
SELECT 
    COUNT(*) as 在线节点数,
    SUM(CASE WHEN MEMBER_STATE='ONLINE' THEN 1 ELSE 0 END) as 健康节点数
FROM performance_schema.replication_group_members;
```

### 7.2 告警设置


```
🚨 关键告警阈值设置

节点状态告警：
• 节点OFFLINE超过30秒 → 紧急告警
• 节点RECOVERING超过10分钟 → 严重告警
• 主节点切换 → 信息告警

性能告警：
• 复制延迟超过5秒 → 警告告警
• 待同步事务超过1000 → 严重告警
• 网络分区检测 → 紧急告警

业务告警：
• 集群不可写超过30秒 → 紧急告警  
• 数据不一致检测 → 严重告警
• 自动切换失败 → 紧急告警
```

### 7.3 性能调优建议


```
⚙️ MGR故障切换性能调优

网络层优化：
group_replication_member_expel_timeout = 30     # 减少检测时间
group_replication_poll_spin_loops = 1000        # 提高检测频率

复制层优化：  
binlog_transaction_dependency_tracking = WRITESET  # 提高并行度
slave_parallel_workers = 8                         # 增加并行线程
slave_preserve_commit_order = ON                   # 保证顺序

存储层优化：
innodb_flush_log_at_trx_commit = 2              # 平衡性能和安全
sync_binlog = 1000                              # 减少IO开销
innodb_log_file_size = 1G                       # 增大日志文件
```

**调优效果对比**：
```
调优项目          调优前    调优后    提升幅度
故障检测时间      60秒      15秒      75%
切换完成时间      120秒     30秒      75%
数据同步速度      10MB/s    50MB/s    400%
```

### 7.4 切换测试方法


**定期故障切换演练**：

```bash
#!/bin/bash
# MGR故障切换测试脚本

echo "=== MGR故障切换测试开始 ==="

# 1. 记录当前主节点
CURRENT_PRIMARY=$(mysql -e "SELECT MEMBER_HOST FROM performance_schema.replication_group_members WHERE MEMBER_ROLE='PRIMARY'" -s -N)
echo "当前主节点: $CURRENT_PRIMARY"

# 2. 模拟主节点故障（停止MySQL服务）
echo "模拟主节点故障..."
ssh $CURRENT_PRIMARY "systemctl stop mysql"

# 3. 等待自动切换
echo "等待自动故障切换..."
sleep 30

# 4. 检查新主节点
NEW_PRIMARY=$(mysql -e "SELECT MEMBER_HOST FROM performance_schema.replication_group_members WHERE MEMBER_ROLE='PRIMARY'" -s -N)
echo "新主节点: $NEW_PRIMARY"

# 5. 测试写入功能
mysql -e "CREATE TABLE IF NOT EXISTS failover_test_$(date +%s) (id INT PRIMARY KEY AUTO_INCREMENT, test_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP)"
echo "写入测试完成"

# 6. 恢复原主节点
echo "恢复原主节点..."
ssh $CURRENT_PRIMARY "systemctl start mysql"
sleep 60

echo "=== 故障切换测试完成 ==="
```

---

## 8. 📋 核心要点总结


### 8.1 故障切换核心概念


```
🔸 MGR故障切换：主节点故障时自动或手动切换到从节点
🔸 故障检测：通过心跳机制检测节点状态
🔸 主节点选举：基于权重、数据完整性等因素选择新主节点
🔸 恢复策略：故障节点修复后重新加入集群
🔸 监控告警：实时监控切换状态和性能指标
```

### 8.2 关键理解要点


**🔹 故障切换的核心价值**
```
业务连续性：
• 避免单点故障影响业务
• 快速恢复服务可用性
• 最小化停机时间

数据安全：
• 保证数据一致性
• 防止数据丢失
• 避免脑裂问题
```

**🔹 自动 vs 手动切换的选择**
```
自动切换适用场景：
• 7×24小时无人值守
• 对RTO要求极高
• 故障类型简单明确

手动切换适用场景：
• 计划维护时间窗口
• 需要精确控制切换时机
• 复杂故障需要人工判断
```

**🔹 性能优化的重点**
```
检测速度：合理设置心跳和超时参数
切换速度：优化网络和存储性能
恢复速度：并行复制和增量同步
```

### 8.3 实际应用价值


**🎯 生产环境应用指导**

```
高可用架构设计：
• 至少3节点部署，避免脑裂
• 跨机房部署，提高容灾能力
• 专用网络，减少网络故障影响

运维操作规范：
• 定期故障切换演练
• 完善监控告警体系
• 制定应急响应流程

性能调优策略：
• 根据业务需求调整参数
• 定期检查和优化配置
• 监控性能指标变化
```

**常见问题及解决方案**：
```
切换时间过长：
→ 优化网络配置
→ 调整心跳参数
→ 升级硬件配置

数据不一致：
→ 检查复制配置
→ 验证GTID设置
→ 确保网络稳定

自动切换失败：
→ 检查节点权重配置
→ 验证网络连通性
→ 查看错误日志
```

### 8.4 最佳实践建议


```
部署建议：
• 奇数节点部署（3、5、7节点）
• 节点分布在不同物理位置
• 使用专用的心跳网络

配置建议：
• 根据网络环境调整超时参数
• 设置合理的节点权重
• 启用自动重新加入功能

监控建议：
• 实时监控集群状态
• 设置多层次告警
• 定期进行故障演练

应急预案：
• 制定详细的故障处理流程
• 准备自动化脚本
• 建立快速响应机制
```

**核心记忆口诀**：
- 故障检测要及时，心跳超时设合理
- 主节点选举看权重，数据完整是第一
- 自动切换保连续，手动切换更精确
- 监控告警不能少，定期演练很重要