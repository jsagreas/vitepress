---
title: 7、mysqldumpslow慢查询分析
---
## 📚 目录

1. [慢查询日志基础概念](#1-慢查询日志基础概念)
2. [mysqldumpslow工具详解](#2-mysqldumpslow工具详解)
3. [核心分析功能](#3-核心分析功能)
4. [实战操作指南](#4-实战操作指南)
5. [性能优化实践](#5-性能优化实践)
6. [自动化监控方案](#6-自动化监控方案)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🐌 慢查询日志基础概念


### 1.1 什么是慢查询日志


**基本概念**：慢查询日志是MySQL内置的性能分析工具，用于记录执行时间超过设定阈值的SQL语句。

```
简单理解：
就像是给数据库装了一个"计时器"
- 每条SQL语句执行时都会被计时
- 执行时间超过设定值的查询会被记录下来
- 这些记录就形成了慢查询日志文件
```

**为什么需要慢查询分析**：
- 🎯 **性能瓶颈识别**：快速找出拖慢系统的查询
- 📊 **优化方向指导**：明确哪些SQL需要优化
- 📈 **性能监控**：长期跟踪数据库性能变化
- 🔧 **问题诊断**：分析系统响应缓慢的根本原因

### 1.2 慢查询日志启用配置


**基础配置参数**：
```sql
-- 查看当前慢查询配置
SHOW VARIABLES LIKE '%slow%';

-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';

-- 设置慢查询阈值（秒）
SET GLOBAL long_query_time = 2;

-- 设置日志文件位置
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
```

**配置文件设置**：
```ini
# my.cnf 配置
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 2
log_queries_not_using_indexes = 1
```

### 1.3 慢查询日志格式解读


**日志条目结构**：
```
# Time: 2025-12-13T10:30:25.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 1500  Rows_examined: 50000
use ecommerce;
SET timestamp=1702461025;
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.order_date >= '2025-01-01' 
ORDER BY o.order_date DESC;
```

**字段含义详解**：
```
📅 Time: 查询结束时间
👤 User@Host: 执行用户和客户端信息
🧵 Thread_id: MySQL线程ID
📊 Query_time: 总执行时间（秒）
🔒 Lock_time: 等待锁的时间（秒）
📤 Rows_sent: 返回给客户端的行数
🔍 Rows_examined: 服务器层检查的行数
```

---

## 2. 🛠️ mysqldumpslow工具详解


### 2.1 工具基本概念


**mysqldumpslow是什么**：
MySQL官方提供的慢查询日志分析工具，用于解析和汇总慢查询日志文件。

```
工具作用简单理解：
原始慢查询日志 → 一条条独立的记录，难以分析
mysqldumpslow → 将相似查询归类汇总，生成分析报告

比如：
SELECT * FROM users WHERE id = 1;
SELECT * FROM users WHERE id = 2;
SELECT * FROM users WHERE id = 999;

会被归类为：
SELECT * FROM users WHERE id = N; （执行了3次）
```

### 2.2 核心功能特点


**主要能力**：
- 🔄 **查询模式归类**：将相似SQL语句合并统计
- 📊 **执行次数统计**：显示每种查询模式的执行频率
- ⏱️ **时间统计分析**：计算平均、最大执行时间
- 🎯 **排序过滤**：按不同条件排序和过滤结果
- 📋 **报告格式输出**：生成易读的分析报告

### 2.3 基本语法结构


```bash
mysqldumpslow [选项] [日志文件路径]

# 基础用法示例
mysqldumpslow /var/log/mysql/slow.log

# 常用选项组合
mysqldumpslow -s c -t 10 /var/log/mysql/slow.log
```

**主要选项说明**：

| 选项 | 含义 | 示例用法 |
|------|------|----------|
| `-s` | **排序方式** | `-s c` 按执行次数排序 |
| `-t` | **显示条数** | `-t 10` 只显示前10条 |
| `-a` | **不抽象化** | 不将数字和字符串抽象为N和'S' |
| `-l` | **总时间排序** | 按总执行时间排序 |
| `-g` | **模式匹配** | `-g 'SELECT'` 只分析SELECT语句 |

---

## 3. 📊 核心分析功能


### 3.1 查询模式归类机制


**抽象化原理**：
mysqldumpslow会将SQL语句中的具体值替换为占位符，实现模式归类。

```
原始查询：
SELECT * FROM users WHERE age > 25 AND name = 'john'
SELECT * FROM users WHERE age > 30 AND name = 'mary'
SELECT * FROM users WHERE age > 18 AND name = 'bob'

归类后：
SELECT * FROM users WHERE age > N AND name = 'S'
执行次数：3次
```

**抽象化规则**：
- **数字** → `N`
- **字符串** → `'S'`
- **多个数字** → `N,N,N...`
- **IN条件** → `IN(N+ VALUES)`

### 3.2 排序方式详解


**按执行次数排序 (`-s c`)**：
```bash
mysqldumpslow -s c -t 5 slow.log

# 输出示例：
Count: 1500  Time=2.34s (3510s)  Lock=0.01s (15s)  Rows=10.5 (15750), app_user[app_user]@[192.168.1.100]
  SELECT * FROM products WHERE category_id = N
```

**按平均执行时间排序 (`-s t`)**：
```bash
mysqldumpslow -s t -t 5 slow.log

# 识别最耗时的查询类型
```

**按总执行时间排序 (`-s at`)**：
```bash
mysqldumpslow -s at -t 5 slow.log

# 找出消耗总时间最多的查询
```

### 3.3 过滤条件设置


**模式匹配过滤**：
```bash
# 只分析SELECT语句
mysqldumpslow -g 'SELECT' slow.log

# 只分析特定表的查询
mysqldumpslow -g 'users' slow.log

# 排除特定查询
mysqldumpslow -g 'SELECT' --invert-match slow.log
```

**时间范围过滤**：
```bash
# 分析最近的慢查询（需要配合其他工具）
tail -n 1000 slow.log | mysqldumpslow -s c -t 10
```

---

## 4. 🎯 实战操作指南


### 4.1 基础分析流程


**第一步：查看整体情况**
```bash
# 查看慢查询总体统计
mysqldumpslow -s c slow.log | head -20

# 输出理解：
Count: 850   Time=3.45s (2932s)  Lock=0.02s (17s)  Rows=25.3 (21505)
|      |     |        |          |         |       |      |
|      |     |        |          |         |       |      └─ 总返回行数
|      |     |        |          |         |       └─ 平均返回行数  
|      |     |        |          |         └─ 总锁等待时间
|      |     |        |          └─ 平均锁等待时间
|      |     |        └─ 总执行时间
|      |     └─ 平均执行时间
|      └─ 执行次数
└─ 查询模式
```

**第二步：识别高频查询**
```bash
# 按执行次数排序，找出最频繁的查询
mysqldumpslow -s c -t 10 slow.log

# 关注指标：
# - 执行次数多的查询优先优化
# - 即使单次时间不长，总影响也很大
```

**第三步：识别耗时查询**
```bash
# 按平均时间排序，找出最慢的查询
mysqldumpslow -s t -t 10 slow.log

# 关注指标：
# - 平均执行时间超过5秒的查询
# - 检查是否缺少索引或查询逻辑问题
```

### 4.2 专项分析场景


**场景1：电商系统订单查询分析**
```bash
# 分析订单相关的慢查询
mysqldumpslow -g 'orders' slow.log

# 常见问题模式：
Count: 200  Time=4.2s (840s)  Rows=1500.0 (300000)
  SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id 
  WHERE o.order_date BETWEEN 'S' AND 'S'

# 问题分析：
# - JOIN查询返回大量数据
# - 可能缺少日期范围索引
# - 考虑分页查询优化
```

**场景2：用户系统登录查询分析**
```bash
# 分析用户登录相关查询
mysqldumpslow -g 'SELECT.*users.*password' slow.log

Count: 50  Time=2.1s (105s)  Lock=0.5s (25s)  Rows=1.0 (50)
  SELECT * FROM users WHERE username = 'S' AND password = 'S'

# 问题分析：
# - 锁等待时间较长
# - 可能是表锁或行锁竞争
# - 检查是否有长事务占用
```

### 4.3 性能瓶颈识别方法


**瓶颈识别流程图**：
```
慢查询分析流程
      |
      ▼
┌─────────────┐
│ 统计分析    │ → 执行次数 Top 10
│ (Count排序) │ → 平均时间 Top 10  
└─────────────┘ → 总时间 Top 10
      |
      ▼
┌─────────────┐
│ 问题分类    │ → 高频低耗时：优化索引
│ (模式识别)  │ → 低频高耗时：重写SQL
└─────────────┘ → 高频高耗时：紧急处理
      |
      ▼
┌─────────────┐
│ 具体分析    │ → EXPLAIN执行计划
│ (深入调查)  │ → 索引使用情况
└─────────────┘ → 表结构检查
```

---

## 5. 🚀 性能优化实践


### 5.1 基于分析结果的优化策略


**优化决策矩阵**：

| 查询特征 | 执行次数 | 平均时间 | 优化策略 | 优先级 |
|----------|----------|----------|----------|--------|
| **高频快查询** | 很高 | 较低 | 微调索引 | 🔸 中等 |
| **高频慢查询** | 很高 | 很高 | **立即优化** | 🚨 **紧急** |
| **低频慢查询** | 较低 | 很高 | 重写SQL | 🔥 高 |
| **低频快查询** | 较低 | 较低 | 暂缓处理 | ℹ️ 低 |

### 5.2 常见查询优化案例


**案例1：缺少索引的查询**
```bash
# 分析结果显示：
Count: 500  Time=8.5s (4250s)  Rows=1.0 (500)
  SELECT * FROM orders WHERE customer_id = N AND order_status = 'S'

# 问题诊断：
mysql> EXPLAIN SELECT * FROM orders WHERE customer_id = 123 AND order_status = 'shipped'\G
*************************** 1. row ***************************
           type: ALL          ← 全表扫描
           rows: 500000        ← 检查50万行
           Extra: Using where  ← 使用WHERE过滤
```

**优化方案**：
```sql
-- 创建复合索引
CREATE INDEX idx_customer_status ON orders(customer_id, order_status);

-- 优化后执行时间：8.5s → 0.05s
```

**案例2：JOIN查询优化**
```bash
# 分析结果显示：
Count: 100  Time=12.3s (1230s)  Rows=5000.0 (500000)
  SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id 
  JOIN products p ON o.product_id = p.id WHERE o.order_date > 'S'

# 优化思路：
# 1. 检查JOIN字段索引
# 2. 优化WHERE条件
# 3. 减少返回字段
```

**优化后SQL**：
```sql
-- 只返回需要的字段，添加索引
SELECT o.order_id, c.name, p.title 
FROM orders o 
JOIN customers c ON o.customer_id = c.id 
JOIN products p ON o.product_id = p.id 
WHERE o.order_date > '2025-01-01'
AND o.order_date < '2025-12-31';  -- 添加上界

-- 创建必要索引
CREATE INDEX idx_order_date ON orders(order_date);
```

### 5.3 查询优化建议生成


**自动化优化建议脚本**：
```bash
#!/bin/bash
# slow_query_advisor.sh

SLOW_LOG="/var/log/mysql/slow.log"
REPORT_FILE="/tmp/slow_query_report.txt"

echo "=== MySQL慢查询优化建议报告 ===" > $REPORT_FILE
echo "生成时间：$(date)" >> $REPORT_FILE
echo "" >> $REPORT_FILE

# 1. 高频查询分析
echo "📊 执行次数最多的查询（需要索引优化）：" >> $REPORT_FILE
mysqldumpslow -s c -t 5 $SLOW_LOG | head -20 >> $REPORT_FILE

# 2. 最耗时查询分析  
echo "" >> $REPORT_FILE
echo "⏱️  平均执行时间最长的查询（需要重写）：" >> $REPORT_FILE
mysqldumpslow -s t -t 5 $SLOW_LOG | head -20 >> $REPORT_FILE

# 3. 总耗时最多查询
echo "" >> $REPORT_FILE
echo "🔥 总执行时间最多的查询（优先处理）：" >> $REPORT_FILE
mysqldumpslow -s at -t 5 $SLOW_LOG | head -20 >> $REPORT_FILE

echo "报告已生成：$REPORT_FILE"
```

---

## 6. 🤖 自动化监控方案


### 6.1 定时分析脚本


**每日慢查询分析脚本**：
```bash
#!/bin/bash
# daily_slow_analysis.sh

MYSQL_SLOW_LOG="/var/log/mysql/slow.log"
REPORT_DIR="/var/log/mysql/reports"
DATE=$(date +%Y%m%d)
REPORT_FILE="$REPORT_DIR/slow_analysis_$DATE.txt"

# 确保报告目录存在
mkdir -p $REPORT_DIR

# 生成分析报告
{
    echo "============================================"
    echo "MySQL慢查询日志分析报告"
    echo "报告日期：$(date '+%Y-%m-%d %H:%M:%S')"
    echo "日志文件：$MYSQL_SLOW_LOG"
    echo "============================================"
    echo ""
    
    # 基础统计信息
    echo "📈 基础统计："
    echo "慢查询总数：$(grep -c "Query_time" $MYSQL_SLOW_LOG)"
    echo "日志文件大小：$(du -h $MYSQL_SLOW_LOG | cut -f1)"
    echo ""
    
    # Top 10 高频查询
    echo "🔥 执行次数最多的查询 (Top 10)："
    echo "--------------------------------------------"
    mysqldumpslow -s c -t 10 $MYSQL_SLOW_LOG
    echo ""
    
    # Top 10 最慢查询
    echo "⏰ 平均执行时间最长的查询 (Top 10)："
    echo "--------------------------------------------"
    mysqldumpslow -s t -t 10 $MYSQL_SLOW_LOG
    echo ""
    
    # 总耗时最多查询
    echo "💰 总执行时间最多的查询 (Top 5)："
    echo "--------------------------------------------"
    mysqldumpslow -s at -t 5 $MYSQL_SLOW_LOG
    
} > $REPORT_FILE

echo "慢查询分析完成，报告保存至：$REPORT_FILE"

# 发送邮件通知（可选）
if command -v mail &> /dev/null; then
    mail -s "MySQL慢查询日报 - $(date +%Y-%m-%d)" admin@company.com < $REPORT_FILE
fi
```

### 6.2 实时监控告警


**慢查询实时监控脚本**：
```bash
#!/bin/bash
# real_time_slow_monitor.sh

SLOW_LOG="/var/log/mysql/slow.log"
ALERT_THRESHOLD=10  # 告警阈值：平均执行时间超过10秒
CHECK_INTERVAL=300  # 检查间隔：5分钟

while true; do
    # 获取最近5分钟的慢查询
    RECENT_SLOW=$(tail -n 100 $SLOW_LOG | grep "Query_time" | tail -10)
    
    # 检查是否有超过阈值的查询
    CRITICAL_QUERIES=$(echo "$RECENT_SLOW" | awk -v threshold=$ALERT_THRESHOLD '
        /Query_time/ {
            if ($4 > threshold) {
                print "🚨 发现严重慢查询，执行时间：" $4 "秒"
            }
        }')
    
    if [ ! -z "$CRITICAL_QUERIES" ]; then
        echo "$(date): $CRITICAL_QUERIES" | tee -a /var/log/mysql/slow_alerts.log
        
        # 发送钉钉/企业微信告警（示例）
        # curl -X POST "https://your-webhook-url" -d "严重慢查询告警: $CRITICAL_QUERIES"
    fi
    
    sleep $CHECK_INTERVAL
done
```

### 6.3 性能监控集成


**与监控系统集成的指标采集**：
```bash
#!/bin/bash
# slow_query_metrics.sh
# 用于Prometheus/Grafana监控

SLOW_LOG="/var/log/mysql/slow.log"
METRICS_FILE="/tmp/mysql_slow_metrics.prom"

# 生成Prometheus格式的指标
{
    echo "# HELP mysql_slow_queries_total Total number of slow queries"
    echo "# TYPE mysql_slow_queries_total counter"
    
    # 慢查询总数
    TOTAL_SLOW=$(grep -c "Query_time" $SLOW_LOG)
    echo "mysql_slow_queries_total $TOTAL_SLOW"
    
    # 按时间段统计慢查询数量
    LAST_HOUR=$(grep "$(date -d '1 hour ago' '+%Y-%m-%dT%H')" $SLOW_LOG | grep -c "Query_time")
    echo "mysql_slow_queries_last_hour $LAST_HOUR"
    
    # 平均执行时间
    AVG_TIME=$(tail -100 $SLOW_LOG | grep "Query_time" | awk '{sum+=$4; count++} END {if(count>0) print sum/count; else print 0}')
    echo "mysql_slow_queries_avg_time $AVG_TIME"
    
} > $METRICS_FILE

echo "指标已生成：$METRICS_FILE"
```

**Grafana仪表板配置示例**：
```json
{
  "dashboard": {
    "title": "MySQL慢查询监控",
    "panels": [
      {
        "title": "慢查询趋势",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(mysql_slow_queries_total[5m])",
            "legendFormat": "慢查询频率"
          }
        ]
      },
      {
        "title": "平均执行时间",
        "type": "singlestat",
        "targets": [
          {
            "expr": "mysql_slow_queries_avg_time",
            "legendFormat": "平均时间(秒)"
          }
        ]
      }
    ]
  }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 mysqldumpslow本质：MySQL官方慢查询日志分析工具
🔸 核心功能：查询归类、统计分析、性能瓶颈识别
🔸 分析维度：执行次数、执行时间、锁等待时间、返回行数
🔸 排序方式：按次数(-s c)、按时间(-s t)、按总时间(-s at)
🔸 实际价值：快速定位性能问题，指导SQL优化方向
```

### 7.2 关键理解要点


**🔹 查询模式归类的意义**
```
理解要点：
- 将相似的SQL语句合并统计
- 避免被大量相似查询刷屏
- 更容易识别真正的性能模式
- 数字和字符串会被抽象为N和'S'
```

**🔹 分析报告的解读方法**
```
报告格式：Count: 执行次数 Time=平均时间(总时间) Lock=平均锁时间(总锁时间) Rows=平均行数(总行数)

关注重点：
- Count高：说明查询频繁，即使单次快也要优化
- Time高：说明查询慢，需要重点检查
- Lock高：说明锁竞争严重，检查事务和索引
- Rows大：说明返回数据多，考虑分页或字段筛选
```

**🔹 优化策略的选择原则**
```
优先级判断：
高频 + 高耗时 = 最高优先级（立即处理）
高频 + 低耗时 = 中等优先级（优化索引）
低频 + 高耗时 = 高优先级（重写SQL）
低频 + 低耗时 = 低优先级（暂缓处理）
```

### 7.3 实际应用价值


**🎯 日常运维场景**
- **性能监控**：定期分析慢查询日志，及时发现性能问题
- **容量规划**：通过查询模式预估系统负载
- **故障排查**：系统响应慢时快速定位SQL问题
- **版本升级**：升级前后性能对比分析

**🔧 开发优化场景**
- **代码审查**：新功能上线前的SQL性能检查
- **压测分析**：压力测试后的性能瓶颈识别
- **索引设计**：基于实际查询模式设计索引策略
- **架构优化**：识别需要缓存或分库分表的查询

### 7.4 最佳实践建议


**📊 监控建议**
```
定期分析：
- 每日：自动生成慢查询报告
- 每周：深度分析Top查询的优化效果
- 每月：整体性能趋势分析

告警设置：
- 单次查询超过10秒：立即告警
- 慢查询数量激增：趋势告警  
- 新出现的慢查询模式：变化告警
```

**🛠️ 工具配合使用**
```
完整分析链条：
mysqldumpslow → 识别问题SQL
EXPLAIN → 分析执行计划
pt-query-digest → 更详细的分析
SHOW PROCESSLIST → 实时监控
Performance Schema → 深度性能分析
```

**核心记忆**：
- mysqldumpslow是慢查询分析的第一步工具
- 通过归类统计快速识别性能瓶颈
- 结合执行次数和时间确定优化优先级
- 自动化监控比手动分析更有价值
- 分析结果要转化为具体的优化行动