---
title: 12、pt-kill连接管理工具
---
## 📚 目录

1. [pt-kill工具概述](#1-pt-kill工具概述)
2. [连接进程管理基础](#2-连接进程管理基础)
3. [核心功能详解](#3-核心功能详解)
4. [实用场景与策略](#4-实用场景与策略)
5. [安全保护与监控](#5-安全保护与监控)
6. [运维自动化应用](#6-运维自动化应用)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔧 pt-kill工具概述


### 1.1 什么是pt-kill


**简单理解**：pt-kill就像是MySQL数据库的"任务管理器"，专门用来管理和终止数据库连接进程。

```
类比理解：
Windows任务管理器 → 管理系统进程
pt-kill工具 → 管理MySQL连接进程

都能查看运行状态、终止异常进程
```

**🔸 核心作用**
- **连接清理**：自动清理长时间运行的查询
- **资源释放**：释放被占用的数据库资源  
- **性能优化**：防止慢查询拖垮数据库性能
- **故障处理**：快速处理连接异常问题

### 1.2 为什么需要pt-kill


**常见数据库连接问题**：
```
问题场景1：慢查询堆积
某个查询执行了2小时还没完成 → 占用大量资源 → 影响其他查询

问题场景2：空闲连接过多  
应用程序创建连接后忘记关闭 → 连接数达到上限 → 新请求被拒绝

问题场景3：死锁或锁等待
多个查询相互等待 → 形成死锁 → 系统假死
```

**传统解决方式的局限**：
- **手动处理**：需要人工监控和干预，效率低
- **简单脚本**：功能单一，缺乏灵活性
- **缺乏保护**：容易误杀重要连接

### 1.3 pt-kill的核心优势


```
智能化特点：
✅ 条件过滤 - 只杀符合条件的连接
✅ 安全保护 - 避免误杀重要连接  
✅ 批量处理 - 高效处理大量连接
✅ 日志记录 - 完整的操作记录
✅ 监控集成 - 与监控系统无缝对接
```

---

## 2. 🔍 连接进程管理基础


### 2.1 MySQL连接状态详解


**连接的生命周期**：
```
连接建立 → 执行查询 → 等待/空闲 → 连接关闭

各阶段可能的状态：
┌─────────────┐
│ Sleep       │ ← 空闲等待新命令
├─────────────┤  
│ Query       │ ← 正在执行查询
├─────────────┤
│ Locked      │ ← 等待表锁
├─────────────┤
│ Sorting     │ ← 正在排序
├─────────────┤
│ Copying     │ ← 复制临时表
└─────────────┘
```

**关键状态说明**：

**Sleep状态**
- **含义**：连接空闲，等待客户端发送新命令
- **正常情况**：短时间Sleep是正常的
- **异常情况**：长时间Sleep可能是连接泄露

**Query状态**  
- **含义**：正在执行SQL语句
- **正常情况**：快速执行完成
- **异常情况**：长时间Query通常是慢查询

**Locked状态**
- **含义**：等待获取表锁或行锁
- **风险**：容易形成锁等待链，影响性能

### 2.2 连接信息的获取


**查看当前连接**：
```sql
-- 基础命令查看连接
SHOW PROCESSLIST;

-- 完整信息查看
SHOW FULL PROCESSLIST;
```

**连接信息字段解释**：
```
Id: 连接ID（唯一标识）
User: 连接用户名
Host: 客户端IP地址和端口
db: 当前使用的数据库
Command: 当前执行的命令类型
Time: 当前状态持续时间（秒）
State: 连接当前状态
Info: 正在执行的SQL语句
```

**实际查看示例**：
```
+----+------+-----------+------+---------+------+-------+------------------+
| Id | User | Host      | db   | Command | Time | State | Info             |
+----+------+-----------+------+---------+------+-------+------------------+  
| 15 | root | localhost | test | Query   | 120  | Locked| SELECT * FROM... |
| 23 | app  | 10.0.1.5  | prod | Sleep   | 3600 | NULL  | NULL             |
+----+------+-----------+------+---------+------+-------+------------------+
```

### 2.3 问题连接的识别


**慢查询识别标准**：
```
时间维度：
🔸 执行超过30秒的SELECT查询
🔸 执行超过10秒的UPDATE/DELETE查询  
🔸 执行超过5秒的INSERT查询

状态维度：
🔸 长时间处于Locked状态的连接
🔸 长时间处于Copying/Sorting状态的连接
🔸 超过1小时的Sleep连接
```

**空闲连接识别**：
```sql
-- 查找长时间空闲的连接
SELECT Id, User, Host, Time 
FROM information_schema.PROCESSLIST 
WHERE Command = 'Sleep' 
AND Time > 3600;  -- 超过1小时的空闲连接
```

---

## 3. ⚙️ 核心功能详解


### 3.1 基础使用语法


**pt-kill基本语法结构**：
```bash
pt-kill [选项] [DSN数据源]

常用选项格式：
--选项名称=值
--选项名称 值
```

**最简单的使用示例**：
```bash
# 查看帮助信息
pt-kill --help

# 连接到本地MySQL并显示进程（不实际杀掉）
pt-kill --host=localhost --user=root --password=密码 --print
```

### 3.2 连接参数配置


**数据源连接(DSN)配置**：
```bash
# 方式1：命令行参数
pt-kill --host=192.168.1.100 --port=3306 --user=admin --password=pass123

# 方式2：DSN格式
pt-kill h=192.168.1.100,P=3306,u=admin,p=pass123

# 方式3：配置文件
pt-kill --defaults-file=/etc/mysql/pt-kill.cnf
```

**配置文件示例**：
```ini
# /etc/mysql/pt-kill.cnf
[client]
host = 192.168.1.100
port = 3306  
user = pt_kill_user
password = secure_password
```

### 3.3 条件过滤设置


**时间条件过滤**：
```bash
# 杀掉运行超过60秒的查询
pt-kill --busy-time=60 --kill

# 杀掉空闲超过3600秒(1小时)的连接
pt-kill --idle-time=3600 --kill
```

**状态条件过滤**：
```bash
# 只处理特定状态的连接
pt-kill --match-state="Locked" --kill

# 排除特定状态的连接  
pt-kill --ignore-state="Sleep" --kill
```

**用户和数据库过滤**：
```bash
# 只处理特定用户的连接
pt-kill --match-user="app_user" --kill

# 排除管理员用户
pt-kill --ignore-user="root,admin" --kill

# 只处理特定数据库的连接
pt-kill --match-db="test_db" --kill
```

### 3.4 查询内容过滤


**SQL语句模式匹配**：
```bash
# 杀掉包含特定关键字的查询
pt-kill --match-info="SELECT.*large_table" --kill

# 排除特定类型的查询
pt-kill --ignore-info="SHOW|DESC|EXPLAIN" --kill
```

**正则表达式使用**：
```bash
# 使用正则表达式匹配复杂模式
pt-kill --match-info="SELECT.*FROM.*WHERE.*LIKE.*%" --kill
```

### 3.5 执行模式控制


**预览模式（不实际执行）**：
```bash
# 只显示会被杀掉的进程，不实际执行
pt-kill --busy-time=60 --print

# 显示完整的匹配信息
pt-kill --busy-time=60 --print --verbose
```

**实际执行模式**：
```bash
# 真正杀掉符合条件的进程
pt-kill --busy-time=60 --kill

# 杀掉进程并显示详细信息
pt-kill --busy-time=60 --kill --print
```

### 3.6 批量操作参数


**处理频率控制**：
```bash
# 每5秒检查一次
pt-kill --busy-time=60 --kill --interval=5

# 持续运行，直到手动停止
pt-kill --busy-time=60 --kill --daemonize
```

**批量限制设置**：
```bash
# 每次最多杀掉10个进程
pt-kill --busy-time=60 --kill --max-count=10

# 运行10轮后自动停止
pt-kill --busy-time=60 --kill --iterations=10
```

---

## 4. 🎯 实用场景与策略


### 4.1 长时间查询终止


**场景描述**：开发人员执行了一个复杂查询，运行了很长时间没有结果，需要终止。

**解决策略**：
```bash
# 步骤1：先预览会被终止的查询
pt-kill --host=localhost --user=root --password=pass \
        --busy-time=300 --print

# 步骤2：确认无误后执行终止
pt-kill --host=localhost --user=root --password=pass \
        --busy-time=300 --kill --print

# 输出示例：
# KILL 125 (Query 310 sec) SELECT * FROM large_table WHERE...
```

**分级处理策略**：
```bash
# 温和处理：先终止超过10分钟的查询
pt-kill --busy-time=600 --kill --print

# 严格处理：终止超过5分钟的查询（紧急情况）
pt-kill --busy-time=300 --kill --print

# 极端情况：终止超过1分钟的查询
pt-kill --busy-time=60 --kill --print
```

### 4.2 空闲连接清理


**空闲连接的危害**：
```
资源消耗：
每个连接占用内存：~256KB - 1MB
连接数限制：达到max_connections后拒绝新连接

性能影响：
连接池耗尽 → 应用程序等待 → 用户体验下降
```

**清理策略实现**：
```bash
# 温和清理：清理超过2小时的空闲连接
pt-kill --idle-time=7200 --match-command="Sleep" --kill

# 严格清理：清理超过30分钟的空闲连接
pt-kill --idle-time=1800 --match-command="Sleep" --kill

# 保护重要用户的连接
pt-kill --idle-time=1800 --match-command="Sleep" \
        --ignore-user="root,admin,monitor" --kill
```

### 4.3 锁等待处理


**锁等待问题的识别**：
```bash
# 查找等待锁的进程
pt-kill --match-state="Locked" --print

# 查找长时间锁等待的进程  
pt-kill --match-state="Locked" --busy-time=30 --print
```

**锁等待处理策略**：
```bash
# 策略1：保守处理，只杀死长时间锁等待的进程
pt-kill --match-state="Locked" --busy-time=60 --kill

# 策略2：激进处理，快速释放所有锁等待
pt-kill --match-state="Locked" --busy-time=10 --kill

# 策略3：分类处理，区分读写操作
pt-kill --match-state="Locked" --match-info="SELECT" \
        --busy-time=30 --kill  # 读操作30秒超时

pt-kill --match-state="Locked" --match-info="UPDATE|DELETE" \
        --busy-time=60 --kill  # 写操作60秒超时
```

### 4.4 特定查询类型处理


**慢SELECT查询处理**：
```bash
# 终止长时间的SELECT查询
pt-kill --match-info="^SELECT" --busy-time=120 --kill

# 终止特定表的查询
pt-kill --match-info="SELECT.*FROM big_table" --busy-time=60 --kill
```

**批量操作监控**：
```bash
# 监控大批量UPDATE操作
pt-kill --match-info="UPDATE.*SET" --busy-time=300 --print

# 控制批量DELETE操作
pt-kill --match-info="DELETE.*FROM" --busy-time=180 --kill
```

### 4.5 按业务场景分类处理


**业务高峰期保护策略**：
```bash
# 工作时间：更严格的超时控制
pt-kill --busy-time=60 --ignore-user="important_app" --kill

# 维护窗口：宽松的超时控制
pt-kill --busy-time=1800 --kill
```

**不同环境的差异化策略**：
```bash
# 开发环境：快速清理，避免影响开发
pt-kill --busy-time=30 --idle-time=600 --kill

# 测试环境：中等严格程度
pt-kill --busy-time=120 --idle-time=1800 --kill  

# 生产环境：保守策略，保护业务
pt-kill --busy-time=300 --idle-time=3600 \
        --ignore-user="app_user,report_user" --kill
```

---

## 5. 🛡️ 安全保护与监控


### 5.1 安全保护机制


**用户权限保护**：
```bash
# 保护管理员账户不被误杀
pt-kill --ignore-user="root,admin,dba" --kill

# 保护重要业务账户
pt-kill --ignore-user="payment_app,order_system" --kill

# 只处理特定的应用账户
pt-kill --match-user="temp_user,test_user" --kill
```

**连接类型保护**：
```bash
# 保护复制相关的连接
pt-kill --ignore-command="Binlog Dump,Connect" --kill

# 保护系统内部连接
pt-kill --ignore-info="SHOW|FLUSH|OPTIMIZE" --kill
```

**数据库保护**：
```bash
# 排除系统数据库
pt-kill --ignore-db="mysql,information_schema,performance_schema" --kill

# 只处理特定的测试数据库
pt-kill --match-db="test_.*" --kill
```

### 5.2 测试与验证


**安全测试流程**：
```bash
# 第1步：预览模式测试
pt-kill --busy-time=60 --print --verbose

# 第2步：限制数量测试
pt-kill --busy-time=60 --kill --max-count=1

# 第3步：逐步放宽限制
pt-kill --busy-time=60 --kill --max-count=5

# 第4步：正式运行
pt-kill --busy-time=60 --kill
```

**回滚和恢复**：
```bash
# 记录操作前的状态
mysql -e "SHOW PROCESSLIST" > before_kill.log

# 执行pt-kill操作
pt-kill --busy-time=60 --kill > kill_operations.log

# 检查操作后的状态  
mysql -e "SHOW PROCESSLIST" > after_kill.log
```

### 5.3 日志记录功能


**日志配置**：
```bash
# 记录详细的操作日志
pt-kill --busy-time=60 --kill --log=/var/log/pt-kill.log

# 同时输出到控制台和日志文件
pt-kill --busy-time=60 --kill --log=/var/log/pt-kill.log --print
```

**日志内容示例**：
```
2025-09-12 10:30:15 KILL 1234 (Query 125 sec) user:app_user host:192.168.1.10
2025-09-12 10:30:16 KILL 1235 (Sleep 3605 sec) user:test_user host:192.168.1.20
```

**日志轮转配置**：
```bash
# 使用logrotate管理pt-kill日志
# /etc/logrotate.d/pt-kill
/var/log/pt-kill.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    create 644 mysql mysql
}
```

### 5.4 监控告警集成


**基础监控脚本**：
```bash
#!/bin/bash
# pt-kill监控脚本

LOG_FILE="/var/log/pt-kill.log"
KILL_COUNT=$(tail -100 $LOG_FILE | grep "$(date '+%Y-%m-%d %H:')" | wc -l)

if [ $KILL_COUNT -gt 10 ]; then
    echo "WARNING: pt-kill杀掉了 $KILL_COUNT 个进程在过去1小时内"
    # 发送告警邮件或消息
    echo "pt-kill异常活跃" | mail -s "数据库连接异常" admin@company.com
fi
```

**与监控系统集成**：
```bash
# 输出监控指标格式
pt-kill --busy-time=60 --print | wc -l > /tmp/pt_kill_candidates.count

# Prometheus监控指标
echo "mysql_long_queries $(cat /tmp/pt_kill_candidates.count)" > /var/lib/node_exporter/pt_kill.prom
```

### 5.5 紧急情况处理


**紧急停止所有查询**：
```bash
# 紧急情况：停止所有非管理员查询
pt-kill --ignore-user="root" --busy-time=1 --kill --max-count=100

# 极端情况：停止所有查询（除了当前连接）
pt-kill --ignore-self --busy-time=0 --kill
```

**快速恢复检查**：
```bash
# 检查数据库是否恢复正常
mysql -e "SHOW PROCESSLIST; SHOW ENGINE INNODB STATUS\G" | grep -E "LOCK WAIT|deadlock"
```

---

## 6. 🤖 运维自动化应用


### 6.1 定时任务自动化


**cron定时任务配置**：
```bash
# 编辑crontab
crontab -e

# 每5分钟清理长时间查询
*/5 * * * * /usr/local/bin/pt-kill --busy-time=300 --kill --log=/var/log/pt-kill.log

# 每小时清理空闲连接
0 * * * * /usr/local/bin/pt-kill --idle-time=3600 --kill --log=/var/log/pt-kill.log

# 每天凌晨2点深度清理
0 2 * * * /usr/local/bin/pt-kill --busy-time=60 --idle-time=1800 --kill
```

**不同时段的差异化策略**：
```bash
# 工作时间脚本 (8:00-18:00)
#!/bin/bash
# /opt/scripts/pt-kill-work-hours.sh
pt-kill --host=localhost --user=pt_user --password=pass \
        --busy-time=120 --idle-time=1800 \
        --ignore-user="important_app" \
        --kill --log=/var/log/pt-kill-work.log

# 非工作时间脚本 (18:01-7:59)  
#!/bin/bash
# /opt/scripts/pt-kill-off-hours.sh
pt-kill --host=localhost --user=pt_user --password=pass \
        --busy-time=600 --idle-time=7200 \
        --kill --log=/var/log/pt-kill-off.log
```

**cron配置示例**：
```bash
# 工作时间每10分钟执行一次
*/10 8-18 * * 1-5 /opt/scripts/pt-kill-work-hours.sh

# 非工作时间每30分钟执行一次
*/30 19-23,0-7 * * * /opt/scripts/pt-kill-off-hours.sh
*/30 * * * 0,6 /opt/scripts/pt-kill-off-hours.sh
```

### 6.2 监控脚本集成


**健康检查脚本**：
```bash
#!/bin/bash
# MySQL连接健康检查脚本

MYSQL_HOST="localhost"
MYSQL_USER="monitor"  
MYSQL_PASS="monitor_pass"

# 检查长时间查询数量
LONG_QUERIES=$(mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASS -e \
"SELECT COUNT(*) FROM information_schema.PROCESSLIST WHERE Time > 300 AND Command != 'Sleep';" \
-N -B)

echo "长时间查询数量: $LONG_QUERIES"

# 如果超过阈值，执行pt-kill
if [ $LONG_QUERIES -gt 5 ]; then
    echo "检测到过多长时间查询，执行清理..."
    pt-kill --host=$MYSQL_HOST --user=$MYSQL_USER --password=$MYSQL_PASS \
            --busy-time=300 --kill --log=/var/log/auto-pt-kill.log
    
    # 发送告警
    echo "自动执行了pt-kill清理，清理了长时间查询" | \
    mail -s "MySQL自动清理告警" dba@company.com
fi
```

### 6.3 告警响应自动化


**基于告警的自动响应**：
```bash
#!/bin/bash
# 告警响应脚本：当收到MySQL连接过多告警时自动执行

# 参数：$1 = 告警级别, $2 = 连接数
ALERT_LEVEL=$1
CONNECTION_COUNT=$2

case $ALERT_LEVEL in
    "warning")
        # 警告级别：温和清理
        pt-kill --idle-time=1800 --kill --max-count=20
        ;;
    "critical")
        # 严重级别：激进清理
        pt-kill --idle-time=900 --busy-time=120 --kill --max-count=50
        ;;
    "emergency")
        # 紧急级别：强制清理
        pt-kill --ignore-user="root" --busy-time=30 --kill --max-count=100
        ;;
esac

echo "执行级别: $ALERT_LEVEL, 当前连接数: $CONNECTION_COUNT" >> /var/log/auto-response.log
```

### 6.4 配置管理自动化


**配置文件模板**：
```ini
# pt-kill配置模板
# /etc/mysql/pt-kill-{environment}.cnf

[client]
host = {{MYSQL_HOST}}
port = {{MYSQL_PORT}}
user = {{PT_KILL_USER}}
password = {{PT_KILL_PASSWORD}}

[pt-kill]
busy-time = {{BUSY_TIME_THRESHOLD}}
idle-time = {{IDLE_TIME_THRESHOLD}}
ignore-user = {{PROTECTED_USERS}}
log = {{LOG_FILE_PATH}}
```

**环境变量配置脚本**：
```bash
#!/bin/bash
# 环境配置脚本

# 根据环境设置不同的参数
case $ENVIRONMENT in
    "dev")
        BUSY_TIME=30
        IDLE_TIME=600
        PROTECTED_USERS="root,dev_admin"
        ;;
    "test")
        BUSY_TIME=120
        IDLE_TIME=1800
        PROTECTED_USERS="root,test_admin"
        ;;
    "prod")
        BUSY_TIME=300
        IDLE_TIME=3600
        PROTECTED_USERS="root,prod_admin,app_user"
        ;;
esac

# 生成配置文件
envsubst < /templates/pt-kill.cnf.template > /etc/mysql/pt-kill.cnf
```

### 6.5 容器化部署


**Docker部署示例**：
```dockerfile
# Dockerfile
FROM percona/percona-toolkit:latest

# 复制配置和脚本
COPY pt-kill-config/ /etc/pt-kill/
COPY scripts/ /opt/pt-kill-scripts/

# 设置执行权限
RUN chmod +x /opt/pt-kill-scripts/*.sh

# 运行定时任务
CMD ["crond", "-f"]
```

**Docker Compose配置**：
```yaml
version: '3.8'
services:
  pt-kill-service:
    build: .
    environment:
      - MYSQL_HOST=mysql-server
      - MYSQL_USER=pt_kill
      - MYSQL_PASSWORD=secure_pass
    volumes:
      - ./logs:/var/log
      - ./config:/etc/pt-kill
    restart: unless-stopped
```

**Kubernetes CronJob部署**：
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mysql-pt-kill
spec:
  schedule: "*/10 * * * *"  # 每10分钟执行
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: pt-kill
            image: percona/percona-toolkit:latest
            command:
            - /bin/bash
            - -c
            - pt-kill --defaults-file=/etc/mysql/pt-kill.cnf --busy-time=300 --kill
            volumeMounts:
            - name: config
              mountPath: /etc/mysql
          volumes:
          - name: config
            configMap:
              name: pt-kill-config
          restartPolicy: OnFailure
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 pt-kill本质：MySQL连接进程管理工具，类似任务管理器
🔸 核心功能：终止长时间查询、清理空闲连接、释放锁等待
🔸 安全机制：条件过滤、用户保护、批量限制、日志记录
🔸 自动化：定时任务、监控集成、告警响应、配置管理
🔸 应用场景：性能优化、故障处理、资源管理、运维自动化
```

### 7.2 关键使用要点


**🔹 基本使用原则**
```
先预览再执行：
使用 --print 参数先查看会被影响的进程

分步骤操作：
从宽松条件开始，逐步收紧条件

保护重要连接：
使用 --ignore-user 保护管理员和重要业务账户

记录操作日志：
使用 --log 参数记录所有操作便于审计
```

**🔹 条件设置策略**
```
时间阈值设置：
慢查询：SELECT(120s), UPDATE/DELETE(60s), INSERT(30s)
空闲连接：开发环境(10分钟), 生产环境(1小时)

用户过滤策略：
保护用户：root, admin, 重要业务账户
处理用户：临时账户, 测试账户, 问题账户

状态过滤重点：
优先处理：Locked, Copying, Sorting
谨慎处理：Query（可能是正常业务）
```

**🔹 安全防护要点**
```
权限控制：
创建专门的pt-kill用户，只给必要权限
不要使用root用户执行pt-kill

测试验证：
新环境先用 --print 模式测试
逐步放宽条件，观察效果

监控告警：
记录pt-kill执行次数和影响范围
异常情况及时告警

备份恢复：
操作前记录当前连接状态
保留详细的操作日志
```

### 7.3 实际应用指导


**适用场景判断**：
```
✅ 适合使用pt-kill的情况：
• 慢查询堆积影响性能
• 空闲连接过多占用资源  
• 锁等待导致业务阻塞
• 定期维护和清理需求

❌ 不适合使用pt-kill的情况：
• 数据库正常运行时随意使用
• 不了解业务逻辑的生产环境
• 没有备份和恢复预案的情况
• 缺乏监控和告警的环境
```

**最佳实践建议**：
```
环境配置：
开发环境：激进策略，快速清理
测试环境：中等策略，平衡性能和稳定性  
生产环境：保守策略，优先保护业务

操作流程：
1. 分析问题：确定需要处理的连接类型
2. 制定策略：设置合适的过滤条件
3. 测试验证：先用预览模式验证
4. 执行操作：小批量分步执行
5. 监控观察：观察执行效果和系统状态
6. 记录总结：记录操作过程和结果
```

### 7.4 故障排查要点


**常见问题及解决**：
```
问题1：pt-kill误杀重要连接
解决：完善 --ignore-user 和 --ignore-info 过滤条件

问题2：pt-kill执行后性能没改善
解决：检查是否还有其他性能瓶颈，如磁盘IO、内存不足

问题3：pt-kill执行频率过高  
解决：调整时间阈值，优化应用程序连接管理

问题4：日志文件过大
解决：配置日志轮转，定期清理历史日志
```

**监控指标建议**：
```
关键指标：
• pt-kill执行次数/小时
• 被终止的连接数量  
• 执行前后的连接数变化
• 数据库性能指标改善情况

告警阈值：
• pt-kill每小时执行超过10次
• 单次终止连接超过50个
• 连续多次执行无效果
```

**核心记忆要点**：
- pt-kill是MySQL连接管理的利器，但需要谨慎使用
- 先预览后执行，保护重要用户，记录详细日志
- 根据环境制定不同策略，开发激进，生产保守
- 结合监控告警，实现智能化的自动运维管理