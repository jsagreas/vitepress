---
title: 35、MySQL Shell新一代客户端
---
## 📚 目录

1. [MySQL Shell概述](#1-mysql-shell概述)
2. [三大工作模式详解](#2-三大工作模式详解)
3. [文档存储功能](#3-文档存储功能)
4. [集群管理核心功能](#4-集群管理核心功能)
5. [自动化运维脚本](#5-自动化运维脚本)
6. [插件扩展机制](#6-插件扩展机制)
7. [开发效率提升特性](#7-开发效率提升特性)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 MySQL Shell概述


### 1.1 什么是MySQL Shell


**🔸 核心定义**
MySQL Shell是MySQL官方推出的**新一代交互式客户端工具**，它不仅仅是传统mysql命令行的升级版，更是一个功能强大的**多语言开发平台**。

```
传统mysql客户端：只能执行SQL语句
MySQL Shell：SQL + JavaScript + Python + 集群管理 + 文档存储
```

> 💡 **通俗理解**：如果说传统mysql客户端是"计算器"，那么MySQL Shell就是"智能手机"——功能更丰富，操作更便捷，能做的事情更多。

### 1.2 核心优势对比


```
传统mysql客户端 vs MySQL Shell：

功能范围：
传统客户端：仅SQL查询
MySQL Shell：SQL + 脚本 + 集群管理 + JSON文档

操作体验：
传统客户端：命令行界面
MySQL Shell：智能提示 + 语法高亮 + 自动补全

开发支持：
传统客户端：无编程支持
MySQL Shell：JavaScript/Python原生支持

运维能力：
传统客户端：基本查询
MySQL Shell：自动化脚本 + 集群管理 + 备份恢复
```

### 1.3 应用场景


**📋 主要用途**
- **开发阶段**：数据库开发、测试、调试
- **运维阶段**：集群管理、自动化运维、监控脚本
- **数据处理**：JSON文档操作、数据迁移、批量处理

---

## 2. ⚙️ 三大工作模式详解


MySQL Shell支持三种工作模式，可以随时切换，每种模式都有自己的特点和用途。

### 2.1 SQL模式 - 传统数据库操作


**🔸 模式特点**
SQL模式就是我们熟悉的传统SQL查询模式，但比传统客户端更智能。

```sql
-- 切换到SQL模式
\sql

-- 连接数据库
\connect root@localhost:3306

-- 执行SQL查询
SELECT * FROM users WHERE age > 18;

-- 查看表结构（增强显示）
DESCRIBE products;
```

**💡 增强特性**
- **智能提示**：输入时自动提示表名、字段名
- **语法高亮**：SQL关键字彩色显示
- **结果美化**：查询结果格式更清晰易读
- **历史记录**：可查看和重用之前的SQL命令

### 2.2 JavaScript模式 - 现代化脚本支持


**🔸 模式特点**
JavaScript模式让你能用现代编程语言操作MySQL，特别适合复杂的数据处理和自动化任务。

```javascript
// 切换到JavaScript模式
\js

// 建立数据库连接
var session = mysql.getSession('root@localhost:3306/testdb');

// 执行SQL并处理结果
var result = session.sql('SELECT * FROM users').execute();
var rows = result.fetchAll();

// 用JavaScript处理数据
rows.forEach(function(row) {
    if (row[2] > 18) {  // age字段
        print('成年用户: ' + row[1]);  // name字段
    }
});

// 批量数据处理
var userData = [
    {name: '张三', age: 25, email: 'zhang@email.com'},
    {name: '李四', age: 30, email: 'li@email.com'}
];

userData.forEach(function(user) {
    session.sql('INSERT INTO users (name, age, email) VALUES (?, ?, ?)')
           .bind(user.name, user.age, user.email)
           .execute();
});
```

**🎯 适用场景**
- **数据转换**：复杂的数据格式转换
- **批量处理**：大量数据的批量操作
- **逻辑处理**：需要条件判断的数据处理

### 2.3 Python模式 - 数据科学友好


**🔸 模式特点**
Python模式特别适合数据分析、科学计算和与Python生态系统集成。

```python
# 切换到Python模式
\py

# 连接数据库
session = mysql.get_session('root@localhost:3306/analytics')

# 执行查询
result = session.sql('SELECT product_id, sales_amount FROM sales').execute()

# 转换为Python数据结构
sales_data = []
for row in result.fetch_all():
    sales_data.append({
        'product_id': row[0],
        'amount': row[1]
    })

# 数据分析处理
total_sales = sum(item['amount'] for item in sales_data)
avg_sales = total_sales / len(sales_data)

print(f"总销售额: {total_sales}")
print(f"平均销售额: {avg_sales}")

# 数据清洗示例
clean_data = []
for item in sales_data:
    if item['amount'] > 0:  # 过滤无效数据
        clean_data.append(item)

print(f"有效数据条数: {len(clean_data)}")
```

**🎯 适用场景**
- **数据分析**：统计分析、数据挖掘
- **机器学习**：模型训练的数据准备
- **报表生成**：复杂报表的数据处理

---

## 3. 📄 文档存储功能


MySQL Shell的一个重要特性是支持**JSON文档存储**，让MySQL既能处理关系型数据，又能处理文档型数据。

### 3.1 文档存储概念


**🔸 什么是文档存储**
```
关系型存储：        文档型存储：
+----+------+       {
| id | name |         "id": 1,
+----+------+         "name": "张三",
| 1  | 张三 |         "profile": {
| 2  | 李四 |           "age": 25,
+----+------+           "hobbies": ["读书", "游泳"]
                      }
                    }
```

> 💡 **通俗理解**：关系型存储像表格，每个数据必须按列排列；文档存储像文件夹，每个文档可以有不同的结构，更灵活。

### 3.2 创建和操作文档集合


```javascript
// 切换到JavaScript模式
\js

// 连接到支持文档存储的数据库
var session = mysql.getSession('root@localhost:33060/docdb');

// 获取或创建文档集合（相当于表）
var users = session.getSchema('docdb').getCollection('users');

// 添加JSON文档
users.add({
    "name": "张三",
    "age": 25,
    "profile": {
        "email": "zhang@email.com",
        "phone": "138****1234",
        "address": {
            "city": "北京",
            "district": "朝阳区"
        }
    },
    "hobbies": ["读书", "游泳", "编程"],
    "created_at": new Date()
}).execute();

// 批量添加文档
users.add([
    {"name": "李四", "age": 30, "department": "技术部"},
    {"name": "王五", "age": 28, "department": "产品部"}
]).execute();
```

### 3.3 查询JSON文档


```javascript
// 查找所有文档
var allUsers = users.find().execute();
print("所有用户数量:", allUsers.count());

// 条件查询
var youngUsers = users.find('age < 30').execute();
youngUsers.fetchAll().forEach(function(doc) {
    print("年轻用户:", doc.name, "年龄:", doc.age);
});

// 复杂查询（嵌套字段）
var beijingUsers = users.find('profile.address.city = "北京"').execute();

// 数组字段查询
var programmers = users.find('"编程" in hobbies').execute();

// 组合查询
var techYoungUsers = users.find('age < 30 AND department = "技术部"').execute();
```

### 3.4 更新和删除文档


```javascript
// 更新文档
users.modify('name = "张三"')
     .set('profile.phone', '139****5678')
     .set('updated_at', new Date())
     .execute();

// 添加数组元素
users.modify('name = "张三"')
     .arrayAppend('hobbies', '旅游')
     .execute();

// 删除文档
users.remove('age > 50').execute();
```

**🎯 文档存储优势**
- **灵活结构**：不需要预定义schema
- **嵌套数据**：自然支持复杂的嵌套结构
- **快速开发**：减少表关联，开发更快
- **JSON原生**：与现代Web应用完美配合

---

## 4. 🔧 集群管理核心功能


MySQL Shell的集群管理功能是其最强大的特性之一，特别是**InnoDB Cluster**管理。

### 4.1 InnoDB Cluster概述


**🔸 什么是InnoDB Cluster**
```
传统主从复制：
Master → Slave1
      → Slave2    (单点故障风险)

InnoDB Cluster：
Node1 ⟷ Node2 ⟷ Node3    (自动故障切换)
```

> 💡 **通俗理解**：InnoDB Cluster像一个"智能团队"，如果队长(主节点)出问题了，其他成员会自动选出新队长，业务不中断。

### 4.2 创建InnoDB Cluster


```javascript
// 第一步：配置实例
dba.configureInstance('root@node1:3306');
dba.configureInstance('root@node2:3306');
dba.configureInstance('root@node3:3306');

// 第二步：创建集群（在第一个节点上）
\connect root@node1:3306
var cluster = dba.createCluster('MyCluster');

// 第三步：添加其他节点
cluster.addInstance('root@node2:3306');
cluster.addInstance('root@node3:3306');

// 检查集群状态
cluster.status();
```

**输出示例：**
```
{
    "clusterName": "MyCluster",
    "defaultReplicaSet": {
        "name": "default",
        "primary": "node1:3306",
        "ssl": "REQUIRED",
        "status": "OK",
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.",
        "topology": {
            "node1:3306": {
                "address": "node1:3306",
                "mode": "R/W",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "node2:3306": {
                "address": "node2:3306",
                "mode": "R/O",
                "role": "HA",
                "status": "ONLINE"
            }
        }
    }
}
```

### 4.3 集群运维操作


```javascript
// 连接到现有集群
var cluster = dba.getCluster();

// 查看详细状态
cluster.describe();

// 重启集群节点
cluster.rebootClusterFromCompleteOutage();

// 移除故障节点
cluster.removeInstance('root@node2:3306');

// 强制重新配置
cluster.forceQuorumUsingPartitionOf('root@node1:3306');

// 修复实例
cluster.rejoinInstance('root@node2:3306');
```

### 4.4 MySQL Router配置


**🔸 什么是MySQL Router**
MySQL Router是一个**轻量级中间件**，负责将应用的数据库连接智能路由到集群中的合适节点。

```bash
# 安装后自动配置Router
mysqlrouter --bootstrap root@node1:3306 --directory /opt/myrouter

# 启动Router
/opt/myrouter/start.sh
```

**Router配置文件示例：**
```ini
[routing:myapp_rw]
bind_address = 0.0.0.0
bind_port = 6446
destinations = node1:3306,node2:3306,node3:3306
routing_strategy = first-available
protocol = classic

[routing:myapp_ro]
bind_address = 0.0.0.0  
bind_port = 6447
destinations = node1:3306,node2:3306,node3:3306
routing_strategy = round-robin-with-fallback
protocol = classic
```

**应用连接方式：**
```javascript
// 读写连接（自动路由到主节点）
var rwSession = mysql.getSession('app_user@router_host:6446/mydb');

// 只读连接（负载均衡到从节点）
var roSession = mysql.getSession('app_user@router_host:6447/mydb');
```

---

## 5. 🤖 自动化运维脚本


MySQL Shell支持编写复杂的自动化运维脚本，大幅提升运维效率。

### 5.1 数据库备份脚本


```javascript
// 完整备份脚本
function backupDatabase(host, schema, backupDir) {
    print(`开始备份数据库: ${schema}`);
    
    // 连接数据库
    var session = mysql.getSession(host);
    
    // 创建备份目录
    var timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    var backupPath = `${backupDir}/${schema}_${timestamp}`;
    
    try {
        // 使用util.dumpSchemas进行备份
        util.dumpSchemas([schema], backupPath, {
            "consistent": true,
            "gtids": "all",
            "triggers": true,
            "events": true,
            "routines": true
        });
        
        print(`备份完成: ${backupPath}`);
        return true;
    } catch (error) {
        print(`备份失败: ${error.message}`);
        return false;
    } finally {
        session.close();
    }
}

// 调用备份函数
backupDatabase('root@localhost:3306', 'myapp', '/backup/mysql');
```

### 5.2 监控脚本


```javascript
// 数据库健康检查脚本
function healthCheck(clusterName) {
    print("=== MySQL集群健康检查 ===");
    
    try {
        var cluster = dba.getCluster(clusterName);
        var status = cluster.status();
        
        // 检查集群状态
        if (status.defaultReplicaSet.status === "OK") {
            print("✅ 集群状态: 正常");
        } else {
            print("❌ 集群状态: " + status.defaultReplicaSet.status);
        }
        
        // 检查各节点状态
        var topology = status.defaultReplicaSet.topology;
        for (let node in topology) {
            var nodeStatus = topology[node].status;
            var nodeRole = topology[node].mode;
            
            if (nodeStatus === "ONLINE") {
                print(`✅ 节点${node}: ${nodeRole} - 在线`);
            } else {
                print(`❌ 节点${node}: ${nodeRole} - ${nodeStatus}`);
            }
        }
        
        // 检查性能指标
        checkPerformanceMetrics();
        
    } catch (error) {
        print("检查失败: " + error.message);
    }
}

function checkPerformanceMetrics() {
    var session = mysql.getSession();
    
    // 检查连接数
    var result = session.sql("SHOW STATUS LIKE 'Threads_connected'").execute();
    var connections = result.fetchOne()[1];
    print(`当前连接数: ${connections}`);
    
    // 检查慢查询
    result = session.sql("SHOW STATUS LIKE 'Slow_queries'").execute();
    var slowQueries = result.fetchOne()[1];
    print(`慢查询数量: ${slowQueries}`);
    
    session.close();
}

// 定期执行健康检查
healthCheck("MyCluster");
```

### 5.3 数据迁移脚本


```javascript
// 数据迁移脚本
function migrateData(sourceHost, targetHost, schemaName) {
    print(`开始数据迁移: ${schemaName}`);
    
    var sourceSession = mysql.getSession(sourceHost);
    var targetSession = mysql.getSession(targetHost);
    
    try {
        // 获取源数据库的表列表
        var tables = sourceSession.sql(`
            SELECT table_name FROM information_schema.tables 
            WHERE table_schema = '${schemaName}'
        `).execute();
        
        while (var table = tables.fetchOne()) {
            var tableName = table[0];
            print(`迁移表: ${tableName}`);
            
            // 获取表数据
            var data = sourceSession.sql(`SELECT * FROM ${schemaName}.${tableName}`).execute();
            var rows = data.fetchAll();
            
            // 批量插入目标数据库
            if (rows.length > 0) {
                var columns = data.getColumns();
                var columnNames = columns.map(col => col.getColumnName()).join(',');
                var placeholders = columns.map(() => '?').join(',');
                
                var insertSql = `INSERT INTO ${schemaName}.${tableName} (${columnNames}) VALUES (${placeholders})`;
                
                rows.forEach(row => {
                    targetSession.sql(insertSql).bind(row).execute();
                });
            }
            
            print(`✅ 表${tableName}迁移完成，共${rows.length}条记录`);
        }
        
        print("数据迁移完成！");
        
    } catch (error) {
        print(`迁移失败: ${error.message}`);
    } finally {
        sourceSession.close();
        targetSession.close();
    }
}
```

---

## 6. 🔌 插件扩展机制


MySQL Shell支持插件扩展，可以自定义功能来满足特定需求。

### 6.1 插件基础概念


**🔸 什么是插件**
插件是一个**JavaScript或Python文件**，包含自定义的函数和工具，可以扩展MySQL Shell的功能。

```
插件目录结构：
~/.mysqlsh/plugins/
├── mytools/
│   ├── init.js          # 插件入口文件
│   ├── backup.js        # 备份工具
│   └── monitor.js       # 监控工具
```

### 6.2 创建自定义插件


**init.js - 插件入口文件：**
```javascript
// ~/.mysqlsh/plugins/mytools/init.js

// 定义插件对象
var mytools = shell.createExtensionObject();

// 注册插件函数
shell.addExtensionObjectMember(mytools, "backup", backup);
shell.addExtensionObjectMember(mytools, "monitor", monitor);
shell.addExtensionObjectMember(mytools, "cleanup", cleanup);

// 注册到全局
shell.registerGlobal("mytools", mytools, {
    brief: "自定义数据库工具集合",
    details: [
        "这个插件提供了数据库备份、监控、清理等实用工具"
    ]
});

print("MyTools插件已加载");
```

**backup.js - 备份工具：**
```javascript
// ~/.mysqlsh/plugins/mytools/backup.js

function backup(connection, options) {
    options = options || {};
    
    // 默认配置
    var config = {
        outputDir: options.outputDir || "/tmp/mysql_backup",
        compression: options.compression || "gzip",
        parallel: options.parallel || 4
    };
    
    print(`使用配置进行备份: ${JSON.stringify(config)}`);
    
    try {
        // 连接数据库
        var session = mysql.getSession(connection);
        
        // 获取数据库列表
        var schemas = session.sql("SHOW DATABASES").execute();
        var schemaList = [];
        
        while (var schema = schemas.fetchOne()) {
            var schemaName = schema[0];
            if (!['information_schema', 'performance_schema', 'mysql', 'sys'].includes(schemaName)) {
                schemaList.push(schemaName);
            }
        }
        
        print(`发现${schemaList.length}个用户数据库`);
        
        // 执行备份
        util.dumpSchemas(schemaList, config.outputDir, {
            consistent: true,
            compression: config.compression,
            threads: config.parallel
        });
        
        print("备份完成！");
        
    } catch (error) {
        print(`备份失败: ${error.message}`);
    }
}
```

### 6.3 使用插件


```javascript
// MySQL Shell中使用插件
\js

// 使用自定义备份工具
mytools.backup('root@localhost:3306', {
    outputDir: '/backup/daily',
    compression: 'zstd',
    parallel: 8
});

// 使用监控工具
mytools.monitor('MyCluster');

// 使用清理工具
mytools.cleanup('root@localhost:3306', {
    days: 30,  // 清理30天前的日志
    slowLog: true,
    binLog: true
});
```

### 6.4 插件最佳实践


```javascript
// 插件开发最佳实践

// 1. 参数验证
function validateConnection(connection) {
    if (!connection) {
        throw new Error("连接字符串不能为空");
    }
    // 更多验证逻辑...
}

// 2. 错误处理
function safeExecute(func, errorMessage) {
    try {
        return func();
    } catch (error) {
        print(`${errorMessage}: ${error.message}`);
        return null;
    }
}

// 3. 日志记录
function log(level, message) {
    var timestamp = new Date().toISOString();
    print(`[${timestamp}] [${level}] ${message}`);
}

// 4. 配置管理
var defaultConfig = {
    timeout: 30000,
    retryCount: 3,
    logLevel: 'INFO'
};

function mergeConfig(userConfig) {
    return Object.assign({}, defaultConfig, userConfig);
}
```

---

## 7. 💼 开发效率提升特性


MySQL Shell提供了多种特性来提升开发效率。

### 7.1 智能提示和补全


**🔸 自动补全功能**
```sql
-- 输入时自动提示
SELECT u.name, u.a[TAB]  -- 自动补全为 age
FROM users u
WHERE u.c[TAB]           -- 自动补全为 created_at
```

**🔸 语法检查**
```javascript
// 实时语法检查
var session = mysql.getSession('root@localhost:3306');

// 拼写错误会有提示
session.sql('SELCT * FROM users');  // 提示：可能想输入 SELECT
```

### 7.2 历史命令管理


```javascript
// 查看命令历史
\history

// 搜索历史命令
\history search backup

// 重新执行历史命令
\history 15  // 执行第15条历史命令

// 清空历史
\history clear
```

### 7.3 会话管理


```javascript
// 保存当前会话配置
\saveAs mydev

// 恢复已保存的会话
\load mydev

// 列出所有保存的会话
\sessions

// 克隆当前会话
\clone production_readonly
```

### 7.4 批处理模式


```bash
# 执行脚本文件
mysqlsh --file=/path/to/script.js

# 批处理模式（无交互）
mysqlsh --batch --file=/path/to/batch.sql

# 通过管道执行
echo "SELECT NOW();" | mysqlsh --sql --uri=root@localhost
```

### 7.5 输出格式化


```javascript
// 设置输出格式
\format table    // 表格格式（默认）
\format tabbed   // 制表符分隔
\format vertical // 垂直格式
\format json     // JSON格式

// JSON格式输出示例
var result = session.sql('SELECT * FROM users LIMIT 2').execute();
result.fetchAll();

// 输出：
[
    {
        "id": 1,
        "name": "张三",
        "age": 25
    },
    {
        "id": 2, 
        "name": "李四",
        "age": 30
    }
]
```

### 7.6 调试功能


```javascript
// 开启调试模式
\debug

// 查看执行计划
session.sql('EXPLAIN SELECT * FROM users WHERE age > 25').execute();

// 性能分析
session.sql('SELECT * FROM users').execute();
// 自动显示查询耗时和资源使用情况

// 慢查询分析
util.debug.collectSlowSQLs(session, 1000);  // 收集执行时间>1秒的SQL
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 MySQL Shell本质：新一代多语言数据库客户端工具
🔸 三大模式：SQL模式、JavaScript模式、Python模式
🔸 文档存储：支持JSON文档的存储和查询
🔸 集群管理：InnoDB Cluster的创建和维护
🔸 自动化运维：通过脚本实现复杂的运维任务
🔸 插件扩展：自定义功能扩展MySQL Shell能力
```

### 8.2 关键理解要点


**🔹 为什么选择MySQL Shell**
```
传统痛点：
- mysql客户端功能单一，只能执行SQL
- 复杂运维任务需要多个工具配合
- 缺乏现代化的开发体验

MySQL Shell优势：
- 一个工具解决多种需求
- 现代编程语言支持
- 智能提示和自动补全
- 强大的集群管理能力
```

**🔹 三种模式的选择原则**
```
SQL模式：
✅ 传统数据库查询
✅ 快速数据查看
✅ 简单的CRUD操作

JavaScript模式：
✅ 复杂的数据处理逻辑
✅ JSON文档操作
✅ 自动化脚本编写
✅ 集群管理操作

Python模式：
✅ 数据分析和科学计算
✅ 机器学习数据准备
✅ 与Python生态系统集成
```

**🔹 文档存储的适用场景**
```
适合场景：
- 产品目录（属性不固定）
- 用户配置（个性化设置）
- 日志记录（格式多样）
- IoT数据（传感器数据结构不一）

不适合场景：
- 强一致性要求的财务数据
- 复杂的多表关联查询
- 事务性要求很高的业务
```

### 8.3 实际应用指导


**📋 开发阶段应用**
- **原型开发**：快速验证数据模型
- **数据导入**：批量数据处理和清洗
- **测试脚本**：自动化测试数据准备

**🔧 运维阶段应用**  
- **集群部署**：InnoDB Cluster自动化部署
- **监控脚本**：定期健康检查和性能监控
- **备份恢复**：自动化备份策略实施

**🚀 效率提升技巧**
```
日常使用建议：
1. 设置常用连接别名
2. 编写常用操作的插件
3. 利用历史命令功能
4. 合理使用批处理模式
5. 掌握快捷键和自动补全
```

### 8.4 学习路径建议


**🎯 初级阶段**
- 掌握三种模式的基本使用
- 熟悉常用的shell命令
- 学会基本的JavaScript/Python语法

**🎯 中级阶段** 
- 学习InnoDB Cluster的创建和管理
- 编写简单的自动化脚本
- 掌握文档存储的使用

**🎯 高级阶段**
- 开发自定义插件
- 编写复杂的运维脚本
- 集成到CI/CD流程中

**核心记忆**：
- MySQL Shell = SQL + 脚本 + 集群管理 + 文档存储
- 三种模式各有所长，按需选择使用
- 文档存储让MySQL更灵活，适合现代应用
- 集群管理功能是高可用架构的核心工具
- 自动化脚本大幅提升运维效率
- 插件机制让功能无限扩展