---
title: 20、分区关键字
---
## 📚 目录

1. [PARTITION分区基础概念](#1-PARTITION分区基础概念)
2. [RANGE范围分区详解](#2-RANGE范围分区详解)
3. [LIST列表分区应用](#3-LIST列表分区应用)
4. [HASH哈希分区机制](#4-HASH哈希分区机制)
5. [LINEAR线性哈希算法](#5-LINEAR线性哈希算法)
6. [SUBPARTITION子分区技术](#6-SUBPARTITION子分区技术)
7. [MAXVALUE最大值使用](#7-MAXVALUE最大值使用)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗂️ PARTITION分区基础概念


### 1.1 什么是分区


**分区（PARTITION）**：把一张大表按照某种规则拆分成多个小的物理存储单元，但对应用程序来说仍然是一张表。

简单理解，就像把一个大抽屉分成多个小格子：
```
原来的大表：          分区后的表：
┌─────────────┐       ┌──┬──┬──┬──┐
│             │  =>   │P1│P2│P3│P4│
│  10万条数据  │       │  │  │  │  │
│             │       └──┴──┴──┴──┘
└─────────────┘       每个分区存储不同数据
```

### 1.2 分区的核心作用


**🎯 为什么要分区**：
- **提升查询性能**：只查询相关分区，避免全表扫描
- **便于数据管理**：可以单独管理某个时间段的数据
- **提高并发性**：不同分区可以并行操作
- **简化维护**：可以单独备份、删除某个分区

**💡 通俗比喻**：
```
分区就像图书馆的分类书架：
- 不分区：所有书混在一起，找书很慢
- 分区后：按类别分架，找计算机类书籍只需要去对应书架
```

### 1.3 分区与分表的区别


| 特性 | **分区** | **分表** |
|------|----------|----------|
| **表数量** | 逻辑上仍是1张表 | 物理上是多张表 |
| **SQL操作** | 无需修改SQL | 需要修改SQL指定表名 |
| **跨分区查询** | 自动处理 | 需要UNION操作 |
| **维护复杂度** | 相对简单 | 相对复杂 |

### 1.4 分区的基本语法结构


```sql
CREATE TABLE 表名 (
    列定义...
)
PARTITION BY 分区类型 (分区表达式)
(
    PARTITION 分区名1 VALUES ...,
    PARTITION 分区名2 VALUES ...,
    ...
);
```

---

## 2. 📊 RANGE范围分区详解


### 2.1 RANGE分区概念


**RANGE分区**：根据某个列的值范围来分配数据到不同分区。

**核心特点**：
- 按连续的数值范围划分
- 常用于时间、ID等有序数据
- 每个分区存储一个范围内的数据

### 2.2 RANGE分区工作原理


```
用户数据按ID范围分区：

分区P1: ID 1-1000     ┌──────────────┐
分区P2: ID 1001-2000  │ 插入ID=1500  │ → 自动存入P2分区
分区P3: ID 2001-3000  │ 查询ID<500   │ → 只查P1分区
分区P4: ID >3000      └──────────────┘
```

### 2.3 基于时间的RANGE分区示例


**场景**：订单表按年份分区

```sql
-- 创建按年份分区的订单表
CREATE TABLE orders (
    order_id INT NOT NULL,
    customer_id INT,
    order_date DATE NOT NULL,
    amount DECIMAL(10,2)
)
PARTITION BY RANGE (YEAR(order_date))
(
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**数据分布效果**：
```
2020年订单 → p2020分区
2021年订单 → p2021分区  
2022年订单 → p2022分区
2023年订单 → p2023分区
2024年及以后 → p_future分区
```

### 2.4 基于数值的RANGE分区示例


**场景**：用户表按ID范围分区

```sql
CREATE TABLE users (
    user_id INT NOT NULL,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at DATETIME
)
PARTITION BY RANGE (user_id)
(
    PARTITION p1 VALUES LESS THAN (10000),
    PARTITION p2 VALUES LESS THAN (20000),
    PARTITION p3 VALUES LESS THAN (30000),
    PARTITION p_max VALUES LESS THAN MAXVALUE
);
```

### 2.5 RANGE分区的查询优化


**分区裁剪（Partition Pruning）**：
```sql
-- 查询2021年订单，只会扫描p2021分区
SELECT * FROM orders 
WHERE order_date BETWEEN '2021-01-01' AND '2021-12-31';

-- 查看执行计划
EXPLAIN PARTITIONS 
SELECT * FROM orders WHERE order_date = '2021-06-15';
-- 结果显示：partitions: p2021  (只查询一个分区)
```

---

## 3. 📝 LIST列表分区应用


### 3.1 LIST分区概念


**LIST分区**：根据某个列的离散值列表来分配数据。

**核心特点**：
- 按预定义的值列表划分
- 适合有明确分类的数据
- 每个分区存储特定值的数据

### 3.2 LIST分区工作原理


```
按地区分区示例：

华北分区: 北京,天津,河北     ┌─────────────────┐
华东分区: 上海,江苏,浙江  →  │ 用户地区=上海    │ → 存入华东分区
华南分区: 广东,广西,海南     │ 查询华北地区用户 │ → 只查华北分区
其他分区: 其余省份           └─────────────────┘
```

### 3.3 按地区的LIST分区示例


```sql
-- 创建按地区分区的用户表
CREATE TABLE users_by_region (
    user_id INT NOT NULL,
    username VARCHAR(50),
    province VARCHAR(20),
    city VARCHAR(50)
)
PARTITION BY LIST COLUMNS(province)
(
    PARTITION p_north VALUES IN ('北京','天津','河北','山西','内蒙古'),
    PARTITION p_east VALUES IN ('上海','江苏','浙江','安徽','福建','江西','山东'),
    PARTITION p_south VALUES IN ('广东','广西','海南'),
    PARTITION p_west VALUES IN ('重庆','四川','贵州','云南','西藏','陕西','甘肃','青海','宁夏','新疆')
);
```

### 3.4 按状态的LIST分区示例


```sql
-- 订单状态分区
CREATE TABLE orders_by_status (
    order_id INT NOT NULL,
    customer_id INT,
    status VARCHAR(20),
    amount DECIMAL(10,2)
)
PARTITION BY LIST COLUMNS(status)
(
    PARTITION p_pending VALUES IN ('pending', 'processing'),
    PARTITION p_completed VALUES IN ('completed', 'delivered'),
    PARTITION p_cancelled VALUES IN ('cancelled', 'refunded')
);
```

### 3.5 LIST分区的优势场景


**🎯 最适用场景**：
- **地理位置分区**：按省份、地区划分
- **状态分区**：按订单状态、用户状态划分  
- **类别分区**：按商品类别、部门划分
- **业务线分区**：按不同业务模块划分

**💡 查询优化效果**：
```sql
-- 只查询华东地区用户，只扫描p_east分区
SELECT * FROM users_by_region 
WHERE province IN ('上海','江苏','浙江');

-- 只查询已完成订单，只扫描p_completed分区  
SELECT * FROM orders_by_status 
WHERE status = 'completed';
```

---

## 4. 🔄 HASH哈希分区机制


### 4.1 HASH分区概念


**HASH分区**：根据哈希函数计算结果来分配数据到不同分区。

**核心特点**：
- 数据分布相对均匀
- 系统自动分配，无需手动指定范围
- 适合数据分布没有明显规律的场景

### 4.2 HASH分区工作原理


```
HASH分区分配过程：

用户ID → HASH函数 → 余数 → 分区
   1001 → hash(1001) → 1 → P1分区
   1002 → hash(1002) → 2 → P2分区  
   1003 → hash(1003) → 3 → P3分区
   1004 → hash(1004) → 0 → P0分区

计算公式：分区号 = hash(分区键) % 分区数量
```

### 4.3 HASH分区示例


```sql
-- 按用户ID进行哈希分区
CREATE TABLE user_orders (
    order_id INT NOT NULL,
    user_id INT NOT NULL,
    product_id INT,
    order_date DATE,
    amount DECIMAL(10,2)
)
PARTITION BY HASH(user_id)
PARTITIONS 4;  -- 创建4个分区：p0, p1, p2, p3
```

**数据分布效果**：
```
用户数据自动均匀分布到4个分区：
P0: user_id % 4 = 0 的用户订单
P1: user_id % 4 = 1 的用户订单
P2: user_id % 4 = 2 的用户订单
P3: user_id % 4 = 3 的用户订单
```

### 4.4 HASH分区的优缺点


**✅ 优点**：
- **数据分布均匀**：避免某个分区数据过多
- **配置简单**：无需定义复杂的分区规则
- **自动负载均衡**：系统自动分配数据

**❌ 缺点**：
- **范围查询效率低**：可能需要查询所有分区
- **扩容复杂**：增加分区需要重新分配数据
- **数据倾斜风险**：哈希函数选择不当可能导致不均匀

### 4.5 HASH分区使用建议


**🎯 适用场景**：
```sql
-- 1. 用户相关数据按用户ID分区
PARTITION BY HASH(user_id) PARTITIONS 8;

-- 2. 订单数据按订单ID分区  
PARTITION BY HASH(order_id) PARTITIONS 6;

-- 3. 日志数据按时间戳分区
PARTITION BY HASH(UNIX_TIMESTAMP(created_at)) PARTITIONS 10;
```

---

## 5. 📈 LINEAR线性哈希算法


### 5.1 LINEAR概念


**LINEAR HASH**：线性哈希算法，是传统HASH分区的改进版本。

**核心特点**：
- 使用"powers-of-two"算法代替取模运算
- 动态扩容时数据重新分布更高效
- 分区增删对现有数据影响更小

### 5.2 LINEAR vs 普通HASH对比


**算法差异**：
```
普通HASH算法：
分区号 = hash(key) % 分区数量

LINEAR HASH算法：  
分区号 = hash(key) & (2^n - 1)  // 使用位运算
```

**扩容对比**：
```
普通HASH扩容（4个分区 → 5个分区）：
原来: hash(key) % 4
现在: hash(key) % 5
影响: 几乎所有数据需要重新计算分区

LINEAR HASH扩容：
使用2的幂次方算法，影响更少的数据
```

### 5.3 LINEAR HASH分区示例


```sql
-- 创建线性哈希分区表
CREATE TABLE user_activities (
    activity_id INT NOT NULL,
    user_id INT NOT NULL,
    activity_type VARCHAR(50),
    created_at DATETIME
)
PARTITION BY LINEAR HASH(user_id)
PARTITIONS 4;
```

### 5.4 LINEAR分区的扩容操作


```sql
-- 原始4个分区的表
-- 动态增加分区到8个
ALTER TABLE user_activities 
ADD PARTITION PARTITIONS 4;

-- 查看分区信息
SELECT 
    PARTITION_NAME,
    TABLE_ROWS 
FROM information_schema.PARTITIONS 
WHERE TABLE_NAME = 'user_activities';
```

### 5.5 LINEAR的实际应用


**🎯 选择LINEAR的场景**：
- **需要动态扩容**：业务快速增长，分区需要经常调整
- **大数据量**：数据量巨大，普通HASH扩容成本太高
- **高并发写入**：需要经常调整分区策略

**💡 性能特点**：
```
数据分布：LINEAR HASH可能不如普通HASH均匀
扩容效率：LINEAR HASH明显优于普通HASH
查询性能：两者基本相当
```

---

## 6. 🏗️ SUBPARTITION子分区技术


### 6.1 子分区概念


**SUBPARTITION（子分区）**：在主分区的基础上再次分区，形成两级分区结构。

**核心特点**：
- 主分区 + 子分区的二级结构
- 更细粒度的数据划分
- 适合多维度数据分区需求

### 6.2 子分区结构图示


```
主分区结构：
┌─────────────────────────────────────────────────────┐
│                     订单表                           │
├──────────────┬──────────────┬──────────────────────┤
│   2020年     │    2021年     │       2022年         │
│   主分区     │    主分区     │       主分区         │
└──────────────┴──────────────┴──────────────────────┘

添加子分区后：
┌─────────────────────────────────────────────────────┐
│                     订单表                           │
├──────────────┬──────────────┬──────────────────────┤
│   2020年     │    2021年     │       2022年         │
├───┬───┬───┬──┼───┬───┬───┬──┼───┬───┬───┬─────────┤
│华北│华东│华南│其他│华北│华东│华南│其他│华北│华东│华南│其他  │
└───┴───┴───┴──┴───┴───┴───┴──┴───┴───┴───┴─────────┘
  子分区（按地区）      子分区（按地区）   子分区（按地区）
```

### 6.3 RANGE+HASH子分区示例


```sql
-- 主分区按时间，子分区按哈希
CREATE TABLE orders_subpartition (
    order_id INT NOT NULL,
    user_id INT NOT NULL,
    order_date DATE NOT NULL,
    amount DECIMAL(10,2),
    region VARCHAR(20)
)
PARTITION BY RANGE (YEAR(order_date))
SUBPARTITION BY HASH(user_id)
SUBPARTITIONS 4  -- 每个主分区下有4个子分区
(
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**实际分区结构**：
```
p2021 主分区：
├── p2021sp0 (user_id % 4 = 0)
├── p2021sp1 (user_id % 4 = 1)  
├── p2021sp2 (user_id % 4 = 2)
└── p2021sp3 (user_id % 4 = 3)

p2022 主分区：
├── p2022sp0 (user_id % 4 = 0)
├── p2022sp1 (user_id % 4 = 1)
├── p2022sp2 (user_id % 4 = 2)  
└── p2022sp3 (user_id % 4 = 3)
```

### 6.4 RANGE+LIST子分区示例


```sql
-- 主分区按时间，子分区按地区列表
CREATE TABLE sales_data (
    sale_id INT NOT NULL,
    product_id INT,
    sale_date DATE NOT NULL,
    region VARCHAR(20),
    amount DECIMAL(10,2)
)
PARTITION BY RANGE (YEAR(sale_date))
SUBPARTITION BY LIST COLUMNS(region)
(
    PARTITION p2022 VALUES LESS THAN (2023)
    (
        SUBPARTITION p2022_north VALUES IN ('北京','天津','河北'),
        SUBPARTITION p2022_east VALUES IN ('上海','江苏','浙江'),
        SUBPARTITION p2022_south VALUES IN ('广东','广西','海南')
    ),
    PARTITION p2023 VALUES LESS THAN (2024)
    (
        SUBPARTITION p2023_north VALUES IN ('北京','天津','河北'),
        SUBPARTITION p2023_east VALUES IN ('上海','江苏','浙江'), 
        SUBPARTITION p2023_south VALUES IN ('广东','广西','海南')
    )
);
```

### 6.5 子分区的查询优化


**精确定位查询**：
```sql
-- 查询2022年华东地区销售数据
-- 只扫描 p2022_east 一个子分区
SELECT * FROM sales_data 
WHERE sale_date BETWEEN '2022-01-01' AND '2022-12-31'
  AND region = '上海';

-- 查看执行计划
EXPLAIN PARTITIONS 
SELECT * FROM sales_data 
WHERE YEAR(sale_date) = 2022 AND region = '江苏';
-- 结果：partitions: p2022_east
```

---

## 7. ♾️ MAXVALUE最大值使用


### 7.1 MAXVALUE概念


**MAXVALUE**：表示无穷大的特殊值，用于RANGE分区中定义最后一个分区的上界。

**核心作用**：
- 捕获所有大于指定值的数据
- 避免插入数据时出现"无分区匹配"错误
- 为未来数据预留分区空间

### 7.2 MAXVALUE的必要性


**❌ 没有MAXVALUE的问题**：
```sql
-- 错误示例：缺少MAXVALUE分区
CREATE TABLE test_orders (
    order_id INT,
    order_date DATE
)
PARTITION BY RANGE (YEAR(order_date))
(
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023)
    -- 缺少处理2023年及以后数据的分区
);

-- 插入2024年数据会报错
INSERT INTO test_orders VALUES (1, '2024-01-01');
-- 错误：Table has no partition for value 2024
```

**✅ 使用MAXVALUE解决**：
```sql
CREATE TABLE orders (
    order_id INT,
    order_date DATE  
)
PARTITION BY RANGE (YEAR(order_date))
(
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p_future VALUES LESS THAN MAXVALUE  -- 处理所有未来数据
);
```

### 7.3 MAXVALUE在不同场景的应用


**时间分区中的MAXVALUE**：
```sql
-- 按月份分区，最后用MAXVALUE
CREATE TABLE monthly_sales (
    sale_id INT,
    sale_date DATE,
    amount DECIMAL(10,2)
)
PARTITION BY RANGE (TO_DAYS(sale_date))
(
    PARTITION p202301 VALUES LESS THAN (TO_DAYS('2023-02-01')),
    PARTITION p202302 VALUES LESS THAN (TO_DAYS('2023-03-01')),
    PARTITION p202303 VALUES LESS THAN (TO_DAYS('2023-04-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**数值分区中的MAXVALUE**：
```sql
-- 按金额范围分区
CREATE TABLE transactions (
    trans_id INT,
    amount DECIMAL(10,2),
    trans_date DATE
)
PARTITION BY RANGE (amount)
(
    PARTITION p_small VALUES LESS THAN (1000),      -- 小额交易
    PARTITION p_medium VALUES LESS THAN (10000),    -- 中额交易  
    PARTITION p_large VALUES LESS THAN (100000),    -- 大额交易
    PARTITION p_huge VALUES LESS THAN MAXVALUE      -- 超大额交易
);
```

### 7.4 MAXVALUE分区管理


**动态添加新分区**：
```sql
-- 假设当前有MAXVALUE分区，要添加2024年分区
-- 1. 先重组MAXVALUE分区
ALTER TABLE orders 
REORGANIZE PARTITION p_future INTO (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025), 
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**查看MAXVALUE分区数据**：
```sql
-- 查看各分区的数据量
SELECT 
    PARTITION_NAME,
    PARTITION_DESCRIPTION,
    TABLE_ROWS
FROM information_schema.PARTITIONS 
WHERE TABLE_NAME = 'orders'
ORDER BY PARTITION_ORDINAL_POSITION;
```

### 7.5 MAXVALUE使用最佳实践


**🎯 设计建议**：
- **总是添加MAXVALUE分区**：避免插入数据失败
- **定期维护MAXVALUE分区**：当数据量过大时及时拆分
- **监控MAXVALUE分区大小**：防止单个分区过大影响性能

**⚠️ 注意事项**：
- MAXVALUE分区只能是最后一个分区
- 不能在MAXVALUE分区后再添加新分区
- 需要通过REORGANIZE操作来拆分MAXVALUE分区

---

## 8. 📋 核心要点总结


### 8.1 分区技术核心概念


```
🔸 PARTITION：将大表拆分成多个物理存储单元的技术
🔸 RANGE分区：按值范围划分，适合时间、ID等有序数据
🔸 LIST分区：按预定义值列表划分，适合分类数据  
🔸 HASH分区：按哈希算法划分，数据分布均匀
🔸 LINEAR：线性哈希算法，扩容更高效
🔸 SUBPARTITION：二级分区，更细粒度的数据划分
🔸 MAXVALUE：无穷大值，处理范围分区的边界情况
```

### 8.2 分区选择指南


| 数据特征 | **推荐分区类型** | **典型应用** |
|---------|-----------------|-------------|
| **时间序列数据** | `RANGE分区` | 订单表、日志表、交易记录 |
| **地区/状态分类** | `LIST分区` | 用户表、产品分类表 |  
| **均匀分布需求** | `HASH分区` | 会话数据、缓存表 |
| **需要动态扩容** | `LINEAR HASH` | 快速增长的业务表 |
| **多维度划分** | `子分区` | 大型数据仓库表 |

### 8.3 分区设计最佳实践


**🎯 设计原则**：
```
选择合适的分区键：
- 查询条件中经常使用的列
- 数据分布相对均匀的列
- 避免经常变更的列

合理规划分区数量：
- 分区过少：单分区数据量大，性能提升有限  
- 分区过多：元数据开销大，管理复杂

预留扩展空间：
- RANGE分区使用MAXVALUE
- 预估未来数据增长趋势
- 制定分区维护策略
```

**⚡ 性能优化要点**：
```
分区裁剪优化：
- WHERE条件包含分区键
- 避免跨分区的复杂查询
- 利用分区并行查询

维护操作优化：  
- 定期清理历史分区数据
- 合理设置分区保留策略
- 监控分区大小和性能指标
```

### 8.4 常见应用场景


**📊 实际业务应用**：
- **电商订单系统**：按下单时间RANGE分区，提升历史订单查询效率
- **用户行为日志**：按日期+用户ID子分区，支持用户轨迹分析
- **金融交易系统**：按交易金额RANGE分区，便于风控数据分析
- **内容管理系统**：按内容类型LIST分区，提升分类内容检索速度

**🔧 运维管理**：
- **数据归档**：定期删除历史分区，释放存储空间
- **性能监控**：跟踪各分区的查询性能和数据分布
- **容量规划**：根据业务增长预测分区扩容需求
- **故障恢复**：单个分区故障不影响整体业务可用性

**核心记忆**：
- 分区是物理拆分逻辑统一，提升大表查询性能的利器
- 选择合适的分区类型和分区键是成功的关键  
- MAXVALUE和子分区技术让分区方案更加灵活完善
- 定期维护和监控是保证分区效果的重要保障