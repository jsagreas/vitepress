---
title: 18、系统函数关键字
---
## 📚 目录

1. [DATABASE当前数据库](#1-database当前数据库)
2. [USER当前用户](#2-user当前用户)
3. [VERSION版本信息](#3-version版本信息)
4. [CONNECTION_ID连接ID](#4-connection_id连接id)
5. [LAST_INSERT_ID最后插入ID](#5-last_insert_id最后插入id)
6. [ROW_COUNT影响行数](#6-row_count影响行数)
7. [FOUND_ROWS查找行数](#7-found_rows查找行数)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗄️ DATABASE当前数据库


### 1.1 基本概念


**🔸 什么是DATABASE函数**
```
DATABASE()函数就像一个"当前位置指示器"
作用：告诉你现在正在使用哪个数据库
返回值：当前选中的数据库名称
```

**💡 通俗理解**
想象你在一个大图书馆里，有很多个房间（数据库），DATABASE()函数就是告诉你"我现在在哪个房间里"。

### 1.2 语法格式


```sql
-- 基本语法（无参数）
DATABASE()

-- 等效函数
SCHEMA()  -- 完全一样的功能
```

### 1.3 返回值说明


| 情况 | 返回值 | 含义 |
|------|--------|------|
| **已选择数据库** | `'mydb'` | 返回数据库名称字符串 |
| **未选择数据库** | `NULL` | 返回空值 |

### 1.4 实际使用场景


**🎯 场景1：检查当前工作环境**
```sql
-- 查看当前在哪个数据库
SELECT DATABASE();

-- 输出示例：
-- +------------+
-- | DATABASE() |
-- +------------+
-- | school     |
-- +------------+
```

**🎯 场景2：脚本中的安全检查**
```sql
-- 确保在正确的数据库中执行操作
SELECT CASE 
    WHEN DATABASE() = 'production' THEN '✅ 正确的生产环境'
    WHEN DATABASE() IS NULL THEN '❌ 未选择数据库'
    ELSE '⚠️ 当前数据库：' + DATABASE()
END AS 环境检查;
```

**🎯 场景3：动态生成SQL语句**
```sql
-- 生成备份命令
SELECT CONCAT('mysqldump ', DATABASE(), ' > backup_', DATABASE(), '.sql') AS 备份命令;
```

### 1.5 注意事项


```
⚠️ 重要提醒：
• DATABASE()不需要参数，加括号即可
• 如果没有USE语句选择数据库，返回NULL
• 区分大小写取决于操作系统（Linux区分，Windows不区分）
```

---

## 2. 👤 USER当前用户


### 2.1 基本概念


**🔸 什么是USER函数**
```
USER()函数是一个"身份识别器"
作用：显示当前连接MySQL的用户信息
格式：用户名@主机名
```

**💡 通俗理解**
就像门卫问你"你是谁？从哪里来？"，USER()函数回答的就是"我是张三，从192.168.1.100这台电脑来的"。

### 2.2 相关函数对比


```sql
-- 三个相关函数的区别
SELECT USER();           -- 当前用户@主机 (登录信息)
SELECT CURRENT_USER();   -- 当前用户@主机 (权限匹配后)
SELECT SYSTEM_USER();    -- 系统用户信息
```

**📊 函数对比表**

| 函数 | 返回内容 | 实际含义 |
|------|----------|----------|
| **USER()** | `root@localhost` | 登录时使用的用户名和主机 |
| **CURRENT_USER()** | `root@%` | 实际匹配的权限用户 |
| **SYSTEM_USER()** | `root@localhost` | 系统层面的用户信息 |

### 2.3 实际使用场景


**🎯 场景1：查看当前登录用户**
```sql
-- 简单查询当前用户
SELECT USER() AS 当前用户;

-- 输出示例：
-- +------------------+
-- | 当前用户         |
-- +------------------+
-- | admin@localhost  |
-- +------------------+
```

**🎯 场景2：权限管理和审计**
```sql
-- 记录操作日志
INSERT INTO operation_log (user_name, operation_time, action)
VALUES (USER(), NOW(), '查询用户信息');

-- 检查用户权限级别
SELECT USER() AS 登录用户, CURRENT_USER() AS 权限用户;
```

**🎯 场景3：多用户环境下的数据隔离**
```sql
-- 根据用户显示不同数据
SELECT * FROM orders 
WHERE 
  CASE 
    WHEN USER() LIKE 'admin@%' THEN TRUE  -- 管理员看全部
    ELSE customer_name = SUBSTRING_INDEX(USER(), '@', 1)  -- 普通用户看自己的
  END;
```

### 2.4 用户格式解析


```
用户格式：username@hostname

示例分析：
'root@localhost'     → 本地登录的root用户
'admin@192.168.1.1'  → 从IP 192.168.1.1登录的admin用户
'user@%'             → 可以从任意主机登录的user用户
```

---

## 3. 📟 VERSION版本信息


### 3.1 基本概念


**🔸 什么是VERSION函数**
```
VERSION()函数是MySQL的"身份证"
作用：显示MySQL服务器的版本信息
包含：版本号、编译信息、操作系统信息
```

**💡 通俗理解**
就像查看手机的"关于本机"，VERSION()告诉你这个MySQL是什么版本，什么时候编译的，运行在什么系统上。

### 2.2 版本信息格式


```
典型格式：主版本.次版本.修订版本-额外信息

示例：
8.0.35-MySQL Community Server - GPL
│ │ │   │
│ │ │   └── 额外信息（社区版、许可证）
│ │ └────── 修订版本（bug修复）
│ └──────── 次版本（功能更新）
└────────── 主版本（重大变更）
```

### 3.3 实际使用场景


**🎯 场景1：环境检查**
```sql
-- 查看MySQL版本
SELECT VERSION() AS MySQL版本;

-- 输出示例：
-- +--------------------------------+
-- | MySQL版本                      |
-- +--------------------------------+
-- | 8.0.35-MySQL Community Server |
-- +--------------------------------+
```

**🎯 场景2：兼容性检查**
```sql
-- 检查是否支持某个特性（如窗口函数需要8.0+）
SELECT 
  VERSION() AS 当前版本,
  CASE 
    WHEN SUBSTRING_INDEX(VERSION(), '.', 1) >= '8' 
    THEN '✅ 支持窗口函数' 
    ELSE '❌ 不支持窗口函数'
  END AS 兼容性检查;
```

**🎯 场景3：系统信息收集**
```sql
-- 收集完整的环境信息
SELECT 
  VERSION() AS 数据库版本,
  DATABASE() AS 当前数据库,
  USER() AS 当前用户,
  NOW() AS 当前时间;
```

### 3.4 版本解读技巧


```
📋 版本号含义：
• 8.0.x   → MySQL 8.0系列（最新主流版本）
• 5.7.x   → MySQL 5.7系列（较老但稳定）
• 5.6.x   → MySQL 5.6系列（已停止支持）

🏷️ 版本类型：
• Community Server → 社区免费版
• Commercial       → 商业付费版
• GPL             → 开源许可证
```

---

## 4. 🔗 CONNECTION_ID连接ID


### 4.1 基本概念


**🔸 什么是CONNECTION_ID**
```
CONNECTION_ID()是每个数据库连接的"身份证号"
作用：为每个MySQL连接分配唯一标识符
特点：数字型，从1开始递增，重启后重置
```

**💡 通俗理解**
想象MySQL是一个餐厅，每个顾客（连接）进来都会拿到一个号码牌，CONNECTION_ID()就是告诉你自己的号码牌是多少。

### 4.2 连接ID的特点


```
连接ID特性：
┌─────────────────────────────────────┐
│ • 唯一性：每个连接都有不同的ID      │
│ • 递增性：新连接ID比旧连接大        │
│ • 重置性：服务器重启后从1重新开始   │
│ • 持续性：连接期间ID保持不变        │
└─────────────────────────────────────┘
```

### 4.3 实际使用场景


**🎯 场景1：识别当前连接**
```sql
-- 查看自己的连接ID
SELECT CONNECTION_ID() AS 我的连接ID;

-- 输出示例：
-- +--------------+
-- | 我的连接ID   |
-- +--------------+
-- |          123 |
-- +--------------+
```

**🎯 场景2：监控数据库连接**
```sql
-- 查看所有活跃连接
SHOW PROCESSLIST;

-- 结合CONNECTION_ID()标识自己的连接
SELECT 
  Id,
  User,
  Host,
  db,
  Command,
  CASE WHEN Id = CONNECTION_ID() THEN '👈 这是我' ELSE '' END AS 标记
FROM INFORMATION_SCHEMA.PROCESSLIST;
```

**🎯 场景3：终止特定连接**
```sql
-- 终止指定连接（需要管理员权限）
KILL 123;  -- 终止连接ID为123的连接

-- 查看要终止的连接信息
SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE ID = 123;
```

### 4.4 实际应用价值


```
🔧 实际用途：
• 连接跟踪：在日志中记录是哪个连接执行的操作
• 性能监控：识别长时间运行的连接
• 问题排查：定位有问题的连接并终止
• 负载均衡：统计连接数量和分布
```

---

## 5. 🔢 LAST_INSERT_ID最后插入ID


### 5.1 基本概念


**🔸 什么是LAST_INSERT_ID**
```
LAST_INSERT_ID()是MySQL的"插入记录器"
作用：返回最近一次INSERT操作生成的自增ID
范围：只针对当前连接，不会被其他连接影响
```

**💡 通俗理解**
就像银行取号机，每次你办业务都会给你一个排队号，LAST_INSERT_ID()就是告诉你刚刚取的号码是多少。

### 5.2 工作原理


```
工作机制示意：
                用户连接A                    用户连接B
                    │                          │
         INSERT INTO users (name)      INSERT INTO users (name) 
         VALUES ('张三')               VALUES ('李四')
                    │                          │
                返回 ID=100                  返回 ID=101
                    │                          │
         SELECT LAST_INSERT_ID()       SELECT LAST_INSERT_ID()
                    │                          │
                返回 100                     返回 101

🔸 关键点：每个连接维护自己的LAST_INSERT_ID值
```

### 5.3 使用语法


```sql
-- 基本用法
LAST_INSERT_ID()

-- 带参数用法（设置值）
LAST_INSERT_ID(value)
```

### 5.4 实际使用场景


**🎯 场景1：获取新插入记录的ID**
```sql
-- 插入用户数据
INSERT INTO users (name, email) 
VALUES ('张三', 'zhangsan@example.com');

-- 获取刚插入记录的ID
SELECT LAST_INSERT_ID() AS 新用户ID;

-- 输出示例：
-- +-----------+
-- | 新用户ID  |
-- +-----------+
-- |       156 |
-- +-----------+
```

**🎯 场景2：关联表插入**
```sql
-- 先插入主表
INSERT INTO orders (customer_name, order_date) 
VALUES ('张三', NOW());

-- 获取订单ID，用于插入明细
SET @order_id = LAST_INSERT_ID();

-- 插入订单明细
INSERT INTO order_items (order_id, product_name, quantity)
VALUES 
  (@order_id, '苹果', 5),
  (@order_id, '香蕉', 3);
```

**🎯 场景3：批量插入后获取起始ID**
```sql
-- 批量插入多条记录
INSERT INTO products (name, price) VALUES
('商品A', 100),
('商品B', 200),
('商品C', 300);

-- 获取第一条记录的ID（起始ID）
SELECT LAST_INSERT_ID() AS 起始ID;

-- 如果起始ID是50，那么三条记录的ID分别是50、51、52
```

### 5.5 重要注意事项


```
⚠️ 关键要点：
• 只对AUTO_INCREMENT字段有效
• 连接隔离：每个连接有自己的值
• UPDATE无效：UPDATE操作不会改变这个值
• 批量插入：返回第一条记录的ID
• 失败重置：INSERT失败时值不变
```

**❌ 常见错误**
```sql
-- 错误：UPDATE不会更新LAST_INSERT_ID
UPDATE users SET name='李四' WHERE id=1;
SELECT LAST_INSERT_ID(); -- 仍然是之前的值

-- 错误：没有自增字段的表
INSERT INTO temp_table (data) VALUES ('test');  -- temp_table没有AUTO_INCREMENT
SELECT LAST_INSERT_ID(); -- 返回0或之前的值
```

---

## 6. 📊 ROW_COUNT影响行数


### 6.1 基本概念


**🔸 什么是ROW_COUNT**
```
ROW_COUNT()是SQL操作的"影响计数器"
作用：返回最近一次DML操作影响的行数
支持：INSERT、UPDATE、DELETE、REPLACE语句
```

**💡 通俗理解**
就像统计员，ROW_COUNT()会告诉你"刚才的操作处理了多少条数据"。

### 6.2 返回值说明


**📊 不同操作的返回值**

| 操作类型 | 返回值 | 说明 |
|----------|--------|------|
| **INSERT** | 插入的行数 | 成功插入几条就返回几 |
| **UPDATE** | 实际修改的行数 | 只计算真正改变的行 |
| **DELETE** | 删除的行数 | 成功删除几条就返回几 |
| **SELECT** | -1 | SELECT不影响数据，返回-1 |

### 6.3 实际使用场景


**🎯 场景1：INSERT操作确认**
```sql
-- 插入数据
INSERT INTO users (name, email) VALUES
('张三', 'zhang@example.com'),
('李四', 'li@example.com');

-- 检查插入结果
SELECT ROW_COUNT() AS 插入行数;

-- 输出示例：
-- +-----------+
-- | 插入行数  |
-- +-----------+
-- |         2 |
-- +-----------+
```

**🎯 场景2：UPDATE操作验证**
```sql
-- 更新数据
UPDATE products 
SET price = price * 1.1 
WHERE category = '电子产品';

-- 查看影响行数
SELECT ROW_COUNT() AS 更新行数;

-- 根据结果判断操作是否成功
SELECT 
  CASE 
    WHEN ROW_COUNT() > 0 THEN CONCAT('✅ 成功更新了', ROW_COUNT(), '条记录')
    WHEN ROW_COUNT() = 0 THEN '⚠️ 没有符合条件的记录'
    ELSE '❌ 操作失败'
  END AS 操作结果;
```

**🎯 场景3：DELETE操作监控**
```sql
-- 删除过期数据
DELETE FROM logs 
WHERE create_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 记录删除情况
INSERT INTO cleanup_log (operation, affected_rows, operation_time)
VALUES ('删除30天前日志', ROW_COUNT(), NOW());
```

### 6.4 特殊情况说明


**🔍 UPDATE的特殊情况**
```sql
-- 情况1：值没有实际改变
UPDATE users SET name = '张三' WHERE name = '张三';
SELECT ROW_COUNT(); -- 返回0，因为值没有变化

-- 情况2：条件匹配但值相同
UPDATE users SET age = 25 WHERE id = 1 AND age = 25;
SELECT ROW_COUNT(); -- 返回0

-- 情况3：真正的更新
UPDATE users SET age = 26 WHERE id = 1 AND age = 25;
SELECT ROW_COUNT(); -- 返回1
```

### 6.5 实践应用技巧


```
💡 最佳实践：
• 立即检查：执行DML语句后立即调用ROW_COUNT()
• 错误处理：根据返回值判断操作是否符合预期
• 日志记录：将影响行数记录到操作日志中
• 批量操作：验证批量操作的完整性
```

**🎯 完整示例：带错误处理的更新**
```sql
-- 安全的更新操作
UPDATE users 
SET status = 'active' 
WHERE last_login > DATE_SUB(NOW(), INTERVAL 7 DAY);

-- 获取影响行数
SET @affected = ROW_COUNT();

-- 根据结果决定下一步操作
SELECT 
  CASE 
    WHEN @affected > 100 THEN '⚠️ 影响行数过多，请检查条件'
    WHEN @affected > 0 THEN CONCAT('✅ 成功激活', @affected, '个用户')
    ELSE '📝 没有用户需要激活'
  END AS 操作结果;
```

---

## 7. 🔍 FOUND_ROWS查找行数


### 7.1 基本概念


**🔸 什么是FOUND_ROWS**
```
FOUND_ROWS()是SELECT查询的"计数专家"
作用：返回最近一次SELECT语句找到的行数
特点：配合SQL_CALC_FOUND_ROWS使用时显示真正威力
```

**💡 通俗理解**
想象你在图书馆找书，FOUND_ROWS()告诉你"总共找到了多少本相关的书"，即使你只拿了其中几本。

### 7.2 两种使用模式


**🔸 普通模式**
```sql
-- 普通SELECT查询
SELECT * FROM users WHERE age > 18;
SELECT FOUND_ROWS(); -- 返回上面查询的结果行数
```

**🔸 SQL_CALC_FOUND_ROWS模式**
```sql
-- 使用SQL_CALC_FOUND_ROWS
SELECT SQL_CALC_FOUND_ROWS * FROM users 
WHERE age > 18 
LIMIT 10;

SELECT FOUND_ROWS(); -- 返回满足WHERE条件的总行数，忽略LIMIT
```

### 7.3 实际使用场景


**🎯 场景1：分页查询的总数统计**
```sql
-- 分页查询：第1页，每页10条
SELECT SQL_CALC_FOUND_ROWS 
  id, name, email 
FROM users 
WHERE status = 'active' 
ORDER BY create_time DESC 
LIMIT 0, 10;

-- 获取总记录数（用于计算总页数）
SELECT FOUND_ROWS() AS 总记录数;

-- 计算分页信息
SELECT 
  FOUND_ROWS() AS 总记录数,
  CEIL(FOUND_ROWS() / 10) AS 总页数,
  1 AS 当前页;
```

**🎯 场景2：搜索结果统计**
```sql
-- 搜索用户（只显示前20条）
SELECT SQL_CALC_FOUND_ROWS 
  name, email 
FROM users 
WHERE name LIKE '%张%' 
LIMIT 20;

-- 显示搜索统计信息
SELECT 
  CONCAT('找到 ', FOUND_ROWS(), ' 个相关用户，显示前20个') AS 搜索结果;
```

**🎯 场景3：数据导出进度**
```sql
-- 分批导出数据
SELECT SQL_CALC_FOUND_ROWS * 
FROM large_table 
WHERE export_flag = 0 
LIMIT 1000;

-- 显示导出进度
SELECT 
  1000 AS 本批导出,
  FOUND_ROWS() AS 总待导出,
  CONCAT(ROUND(1000/FOUND_ROWS()*100, 2), '%') AS 完成进度;
```

### 7.4 性能考虑


```
⚠️ 性能注意事项：

使用SQL_CALC_FOUND_ROWS的代价：
┌─────────────────────────────────────┐
│ ✅ 优点：一次查询获得数据+总数       │
│ ❌ 缺点：需要扫描所有匹配行         │
│ 💡 建议：大表慎用，考虑缓存总数     │
└─────────────────────────────────────┘
```

**🔍 性能对比示例**
```sql
-- 方法1：使用SQL_CALC_FOUND_ROWS（可能慢）
SELECT SQL_CALC_FOUND_ROWS * FROM big_table WHERE condition LIMIT 10;
SELECT FOUND_ROWS();

-- 方法2：分开查询（可能更快）
SELECT COUNT(*) FROM big_table WHERE condition;  -- 获取总数
SELECT * FROM big_table WHERE condition LIMIT 10; -- 获取数据
```

### 7.5 替代方案


**🎯 现代替代方法**
```sql
-- MySQL 8.0+ 窗口函数方法
SELECT 
  *,
  COUNT(*) OVER() AS total_rows
FROM users 
WHERE status = 'active' 
ORDER BY create_time DESC 
LIMIT 10;

-- 这样一次查询就能同时获得数据和总数
```

### 7.6 实践建议


```
💡 使用建议：
• 小表：可以放心使用SQL_CALC_FOUND_ROWS
• 大表：考虑缓存总数或使用估算值
• 分页：评估是否真的需要精确总数
• 搜索：可以显示"约xxx条结果"而不是精确数字
```

---

## 8. 📋 核心要点总结


### 8.1 系统函数速查表


| 函数 | 作用 | 返回值 | 使用场景 |
|------|------|--------|----------|
| **DATABASE()** | 当前数据库名 | 字符串/NULL | 环境检查、脚本验证 |
| **USER()** | 当前用户信息 | 用户@主机 | 权限管理、审计日志 |
| **VERSION()** | MySQL版本 | 版本字符串 | 兼容性检查、环境信息 |
| **CONNECTION_ID()** | 连接标识 | 数字 | 连接监控、问题排查 |
| **LAST_INSERT_ID()** | 最后插入ID | 数字 | 关联插入、获取新ID |
| **ROW_COUNT()** | 影响行数 | 数字 | 操作确认、错误处理 |
| **FOUND_ROWS()** | 查找行数 | 数字 | 分页查询、搜索统计 |

### 8.2 核心记忆要点


**🔸 连接相关函数**
```
DATABASE() → 告诉你在哪个"房间"（数据库）
USER()     → 告诉你是"谁"从"哪里来"
CONNECTION_ID() → 你的"号码牌"（连接标识）
VERSION()  → MySQL的"身份证"（版本信息）
```

**🔸 操作相关函数**
```
LAST_INSERT_ID() → 刚刚插入记录的"身份证号"
ROW_COUNT()      → 刚才操作"处理了多少条"
FOUND_ROWS()     → 查询"找到了多少条"
```

### 8.3 使用注意事项


**⚠️ 重要提醒**
```
连接隔离性：
• LAST_INSERT_ID()：每个连接独立
• ROW_COUNT()：每个连接独立  
• CONNECTION_ID()：每个连接唯一

时效性：
• 这些函数值会被下一次相同类型操作覆盖
• 需要立即获取，不要延迟调用

NULL值处理：
• DATABASE()在未选择数据库时返回NULL
• 其他函数一般不会返回NULL
```

### 8.4 实际应用组合


**🎯 完整的操作日志记录**
```sql
-- 插入数据并记录完整日志
INSERT INTO users (name, email) VALUES ('张三', 'zhang@example.com');

INSERT INTO operation_log (
  database_name,
  user_info, 
  connection_id,
  mysql_version,
  new_record_id,
  affected_rows,
  operation_time
) VALUES (
  DATABASE(),           -- 当前数据库
  USER(),              -- 操作用户
  CONNECTION_ID(),     -- 连接ID
  VERSION(),           -- MySQL版本
  LAST_INSERT_ID(),    -- 新记录ID
  ROW_COUNT(),         -- 影响行数
  NOW()                -- 操作时间
);
```

**🎯 环境信息一览**
```sql
-- 获取完整的环境信息
SELECT 
  DATABASE() AS 当前数据库,
  USER() AS 当前用户,
  CONNECTION_ID() AS 连接ID,
  VERSION() AS MySQL版本,
  NOW() AS 当前时间;
```

### 8.5 学习建议


```
📚 掌握顺序：
1. 先理解每个函数的基本概念和作用
2. 通过简单例子熟悉语法
3. 理解函数之间的区别和联系
4. 在实际项目中综合运用

🎯 实践要点：
• 多动手：在测试环境中亲自执行示例
• 多观察：注意不同情况下的返回值
• 多思考：考虑在自己项目中如何使用
• 多总结：建立自己的使用经验库
```

**核心记忆口诀**：
```
数据库当前在哪里，DATABASE函数告诉你
用户身份要知晓，USER函数最可靠  
版本信息很重要，VERSION一查便知道
连接编号不会乱，CONNECTION_ID做标签
插入记录要编号，LAST_INSERT_ID找到
影响多少要统计，ROW_COUNT来计算
查询结果有多少，FOUND_ROWS告诉你
```