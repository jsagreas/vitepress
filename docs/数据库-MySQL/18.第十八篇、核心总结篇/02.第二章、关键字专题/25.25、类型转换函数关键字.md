---
title: 25、类型转换函数关键字
---
## 📚 目录

1. [CAST类型转换](#1-CAST类型转换)
2. [CONVERT转换函数](#2-CONVERT转换函数)
3. [BINARY二进制转换](#3-BINARY二进制转换)
4. [CHARSET字符集](#4-CHARSET字符集)
5. [COLLATION排序规则](#5-COLLATION排序规则)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 CAST类型转换


### 1.1 CAST基本概念


**🔸 核心定义**
```
CAST：将一个数据类型强制转换为另一个数据类型
作用：解决不同数据类型之间的兼容性问题
本质：告诉数据库"把这个数据当作另一种类型来处理"
```

**💡 为什么需要类型转换**
```
生活类比：
就像你有一张身份证照片(字符串)，但银行系统需要数字ID(整数)
需要"翻译"一下，让不同系统能够互相理解

实际问题：
• 用户输入的"123"是字符串，但需要做数学运算
• 数据库存储的日期是文本格式，需要转为日期类型
• 两个表关联时，字段类型不匹配
```

### 1.2 CAST语法详解


**📋 标准语法格式**
```sql
CAST(expression AS target_type)

-- 基本结构解释：
-- expression：要转换的原始数据
-- AS：关键字，表示"转换为"
-- target_type：目标数据类型
```

**🎯 常用转换示例**
```sql
-- 字符串转数字
SELECT CAST('123' AS INT);           -- 结果：123
SELECT CAST('45.67' AS DECIMAL(5,2)); -- 结果：45.67

-- 数字转字符串  
SELECT CAST(123 AS VARCHAR(10));     -- 结果：'123'
SELECT CAST(45.67 AS CHAR(10));      -- 结果：'45.67'

-- 日期时间转换
SELECT CAST('2024-01-15' AS DATE);   -- 结果：2024-01-15
SELECT CAST('12:30:45' AS TIME);     -- 结果：12:30:45
```

### 1.3 支持的数据类型转换


| 源类型 | **目标类型** | **转换效果** | **注意事项** |
|---------|------------|-------------|-------------|
| 🔤 **VARCHAR** | `INT` | `字符'123'→数字123` | `字符串必须是有效数字` |
| 🔢 **INT** | `VARCHAR` | `数字123→字符'123'` | `总是成功` |
| 📅 **DATE** | `VARCHAR` | `日期→'2024-01-15'` | `格式固定` |
| 🔤 **VARCHAR** | `DATE` | `'2024-01-15'→日期` | `格式必须正确` |
| 💰 **DECIMAL** | `INT` | `45.67→45` | `会截断小数部分` |

### 1.4 实际应用场景


**🎪 场景1：用户输入处理**
```sql
-- 用户在网页输入框输入"25"，但数据库需要整数
INSERT INTO users (age) 
VALUES (CAST('25' AS INT));

-- 批量处理文本数据
UPDATE products 
SET price_numeric = CAST(price_text AS DECIMAL(10,2))
WHERE price_text IS NOT NULL;
```

**🔍 场景2：数据查询优化**
```sql
-- 将用户ID从字符串转为数字进行比较（提高性能）
SELECT * FROM orders 
WHERE CAST(user_id AS INT) > 1000;

-- 日期字符串转换后进行日期运算
SELECT * FROM logs 
WHERE CAST(log_date AS DATE) >= '2024-01-01';
```

**⚠️ 转换失败处理**
```sql
-- 安全转换：当转换失败时不报错，返回NULL
SELECT 
    CASE 
        WHEN value REGEXP '^[0-9]+$' THEN CAST(value AS INT)
        ELSE NULL
    END as safe_number
FROM input_table;
```

---

## 2. 🔧 CONVERT转换函数


### 2.1 CONVERT基本概念


**🔸 核心定义**
```
CONVERT：MySQL特有的类型转换函数
特点：比CAST功能更丰富，语法更灵活
优势：支持字符编码转换，提供更多控制选项
```

**🆚 CONVERT vs CAST对比**
```
相同点：
• 都能进行基本的数据类型转换
• 都是SQL标准函数

不同点：
CONVERT - MySQL专用，功能丰富，支持编码转换
CAST    - SQL标准，跨数据库兼容，语法简单

选择建议：
• 需要字符编码转换 → 用CONVERT
• 需要跨数据库兼容 → 用CAST  
• 简单类型转换 → 两者都可以
```

### 2.2 CONVERT语法格式


**📋 基本类型转换语法**
```sql
CONVERT(expression, target_type)

-- 示例：
SELECT CONVERT('123', SIGNED);      -- 转为有符号整数
SELECT CONVERT('123', UNSIGNED);    -- 转为无符号整数
SELECT CONVERT(123, CHAR);          -- 转为字符串
```

**🌐 字符编码转换语法**
```sql
CONVERT(string USING charset_name)

-- 示例：
SELECT CONVERT('中文' USING utf8);   -- 转为UTF8编码
SELECT CONVERT('Hello' USING latin1); -- 转为Latin1编码
```

### 2.3 CONVERT支持的类型


**📊 数值类型转换**
```sql
-- 整数类型
SELECT CONVERT('123', SIGNED INTEGER);    -- 有符号整数
SELECT CONVERT('123', UNSIGNED INTEGER);  -- 无符号整数

-- 浮点类型  
SELECT CONVERT('45.67', DECIMAL(5,2));    -- 指定精度的小数
SELECT CONVERT('45.67', DOUBLE);          -- 双精度浮点数
```

**🔤 字符类型转换**
```sql
-- 字符串类型
SELECT CONVERT(123, CHAR(10));            -- 固定长度字符串
SELECT CONVERT(123, VARCHAR(50));         -- 可变长度字符串
SELECT CONVERT('HELLO', BINARY(10));      -- 二进制字符串
```

**📅 日期时间转换**
```sql
-- 日期时间类型
SELECT CONVERT('2024-01-15', DATE);       -- 日期
SELECT CONVERT('12:30:45', TIME);         -- 时间
SELECT CONVERT('2024-01-15 12:30:45', DATETIME); -- 日期时间
```

### 2.4 字符编码转换实战


**🌍 编码转换的实际用途**
```sql
-- 处理不同编码的数据导入
INSERT INTO utf8_table (content)
SELECT CONVERT(gbk_content USING utf8) 
FROM gbk_source_table;

-- 解决中文显示乱码问题
SELECT 
    user_name,
    CONVERT(user_comment USING utf8mb4) as comment_utf8
FROM users 
WHERE user_comment IS NOT NULL;
```

**🔧 编码问题诊断**
```sql
-- 查看字符串的字符集
SELECT CHARSET('中文字符');

-- 查看字符串长度（字节数 vs 字符数）
SELECT 
    LENGTH('中文') as byte_length,        -- 字节长度
    CHAR_LENGTH('中文') as char_length;   -- 字符长度
```

---

## 3. 🔢 BINARY二进制转换


### 3.1 BINARY基本概念


**🔸 核心定义**
```
BINARY：将字符串转换为二进制字符串
作用：强制区分大小写比较，提高字符串匹配精度
原理：将字符按照ASCII/UTF-8编码转为二进制表示
```

**💡 为什么需要二进制转换**
```
问题场景：
默认情况下，MySQL字符串比较是不区分大小写的
'Hello' = 'HELLO' 会返回 TRUE

使用BINARY后：
BINARY 'Hello' = BINARY 'HELLO' 返回 FALSE

实际应用：
• 密码验证（区分大小写）
• 用户名注册（避免重复）
• 文件名比较（Linux系统区分大小写）
```

### 3.2 BINARY使用方法


**📋 基本语法**
```sql
-- 方法1：BINARY关键字
SELECT * FROM users WHERE BINARY username = 'Admin';

-- 方法2：BINARY()函数
SELECT * FROM users WHERE BINARY(username) = 'Admin';

-- 方法3：CONVERT转换
SELECT * FROM users WHERE username = CONVERT('Admin' USING BINARY);
```

**🎯 实际应用示例**
```sql
-- 区分大小写的用户登录
SELECT user_id, username 
FROM users 
WHERE BINARY username = 'AdminUser' 
  AND BINARY password = 'SecurePass123';

-- 检查是否存在大小写不同的重复用户名
SELECT username, COUNT(*) as count
FROM users 
GROUP BY BINARY username
HAVING count > 1;
```

### 3.3 BINARY vs 普通比较


**📊 对比示例**
```sql
-- 创建测试数据
CREATE TABLE test_case (
    id INT,
    name VARCHAR(50)
);

INSERT INTO test_case VALUES 
(1, 'hello'),
(2, 'Hello'), 
(3, 'HELLO');

-- 普通比较（不区分大小写）
SELECT * FROM test_case WHERE name = 'hello';
-- 结果：返回所有3条记录

-- BINARY比较（区分大小写）  
SELECT * FROM test_case WHERE BINARY name = 'hello';
-- 结果：只返回第1条记录
```

### 3.4 BINARY的性能考虑


**⚡ 性能影响分析**
```sql
-- 性能测试示例
-- 普通索引查询（快）
SELECT * FROM large_table WHERE username = 'admin';

-- BINARY查询（相对慢，无法使用索引）
SELECT * FROM large_table WHERE BINARY username = 'admin';

-- 优化方案：创建区分大小写的列
ALTER TABLE users ADD COLUMN username_binary VARCHAR(50) BINARY;
CREATE INDEX idx_username_binary ON users(username_binary);
```

---

## 4. 🌐 CHARSET字符集


### 4.1 字符集基本概念


**🔸 核心定义**
```
CHARSET：字符集，定义了字符与数字编码的对应关系
作用：决定数据库能存储和显示哪些字符
重要性：影响数据存储、查询、排序的正确性
```

**🌍 常见字符集类型**
```
UTF8MB4：
• 完整的UTF-8实现，支持4字节字符
• 能存储emoji表情符号
• 目前推荐使用的字符集

UTF8：  
• MySQL的3字节UTF-8实现
• 不支持emoji等4字节字符
• 逐渐被UTF8MB4替代

LATIN1：
• 单字节字符集，主要支持西欧语言
• 存储效率高，但支持字符有限

GBK：
• 支持中文简体字符
• 双字节编码
```

### 4.2 查看和设置字符集


**🔍 查看字符集信息**
```sql
-- 查看数据库字符集
SHOW VARIABLES LIKE 'character_set%';

-- 查看表的字符集
SHOW CREATE TABLE users;

-- 查看列的字符集
SHOW FULL COLUMNS FROM users;

-- 查看支持的所有字符集
SHOW CHARACTER SET;
```

**⚙️ 设置字符集**
```sql
-- 创建数据库时指定字符集
CREATE DATABASE mydb 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- 创建表时指定字符集
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100) CHARACTER SET utf8mb4
) CHARACTER SET utf8mb4;

-- 修改现有表的字符集
ALTER TABLE users CONVERT TO CHARACTER SET utf8mb4;
```

### 4.3 字符集转换实践


**🔄 字符集转换操作**
```sql
-- 查看字符串的字符集
SELECT CHARSET('Hello World');
SELECT CHARSET('你好世界');

-- 转换字符集
SELECT CONVERT('Hello' USING utf8mb4);
SELECT CONVERT('你好' USING gbk);

-- 解决乱码问题
UPDATE users 
SET name = CONVERT(name USING utf8mb4)
WHERE CHARSET(name) != 'utf8mb4';
```

### 4.4 字符集常见问题


**❌ 常见问题及解决**

**问题1：emoji表情存储失败**
```sql
-- 错误：使用utf8字符集
INSERT INTO posts (content) VALUES ('今天心情很好😊');
-- 报错：Incorrect string value

-- 解决：使用utf8mb4字符集
ALTER TABLE posts CONVERT TO CHARACTER SET utf8mb4;
INSERT INTO posts (content) VALUES ('今天心情很好😊');
-- 成功存储
```

**问题2：中文显示乱码**
```sql
-- 诊断步骤
-- 1. 检查数据库字符集
SHOW VARIABLES LIKE 'character_set_database';

-- 2. 检查表字符集
SHOW CREATE TABLE users;

-- 3. 检查连接字符集
SHOW VARIABLES LIKE 'character_set_connection';

-- 解决方案
SET NAMES utf8mb4;  -- 设置连接字符集
```

---

## 5. 📝 COLLATION排序规则


### 5.1 排序规则基本概念


**🔸 核心定义**
```
COLLATION：排序规则，定义字符的比较和排序方式
作用：决定查询结果的排序顺序和字符串比较规则
与字符集关系：字符集定义字符，排序规则定义顺序
```

**🎯 排序规则的影响**
```
影响范围：
• ORDER BY排序结果
• WHERE条件比较
• GROUP BY分组
• 索引的构建和使用
• DISTINCT去重操作

生活类比：
字符集像"字典收录的所有字"
排序规则像"字典的排列顺序"（拼音、笔画、部首等）
```

### 5.2 常用排序规则


**📊 UTF8MB4排序规则对比**

| 排序规则 | **特点** | **区分大小写** | **适用场景** |
|---------|---------|-------------|-------------|
| `utf8mb4_general_ci` | `通用规则，性能好` | `否` | `一般查询，性能要求高` |
| `utf8mb4_unicode_ci` | `严格Unicode标准` | `否` | `多语言环境，准确性要求高` |
| `utf8mb4_bin` | `二进制比较` | `是` | `需要区分大小写的场景` |
| `utf8mb4_0900_ai_ci` | `新版本默认规则` | `否` | `MySQL 8.0推荐使用` |

### 5.3 排序规则实际效果


**🔤 大小写敏感性测试**
```sql
-- 创建测试表
CREATE TABLE test_collation (
    id INT,
    name_ci VARCHAR(50) COLLATE utf8mb4_general_ci,    -- 不区分大小写
    name_bin VARCHAR(50) COLLATE utf8mb4_bin           -- 区分大小写
);

INSERT INTO test_collation VALUES 
(1, 'apple', 'apple'),
(2, 'Apple', 'Apple'),
(3, 'APPLE', 'APPLE');

-- 不区分大小写的查询
SELECT * FROM test_collation WHERE name_ci = 'apple';
-- 结果：返回所有3条记录

-- 区分大小写的查询  
SELECT * FROM test_collation WHERE name_bin = 'apple';
-- 结果：只返回第1条记录
```

**📈 排序效果对比**
```sql
-- 数字和字母混合排序
CREATE TABLE sort_test (
    value VARCHAR(10) COLLATE utf8mb4_general_ci
);

INSERT INTO sort_test VALUES ('a1'), ('A2'), ('b1'), ('B2'), ('10'), ('2');

-- 使用不同排序规则
SELECT value FROM sort_test ORDER BY value;
-- general_ci结果：10, 2, a1, A2, b1, B2

SELECT value FROM sort_test ORDER BY value COLLATE utf8mb4_bin;
-- bin结果：10, 2, A2, B2, a1, b1
```

### 5.4 设置和修改排序规则


**⚙️ 设置排序规则**
```sql
-- 数据库级别设置
CREATE DATABASE mydb 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- 表级别设置
CREATE TABLE users (
    id INT,
    username VARCHAR(50)
) COLLATE utf8mb4_bin;

-- 列级别设置
CREATE TABLE products (
    id INT,
    name VARCHAR(100) COLLATE utf8mb4_unicode_ci,
    code VARCHAR(50) COLLATE utf8mb4_bin
);
```

**🔧 修改现有排序规则**
```sql
-- 修改表的默认排序规则
ALTER TABLE users COLLATE utf8mb4_unicode_ci;

-- 修改列的排序规则
ALTER TABLE users 
MODIFY username VARCHAR(50) COLLATE utf8mb4_bin;

-- 查询时临时指定排序规则
SELECT * FROM users 
ORDER BY username COLLATE utf8mb4_bin;
```

### 5.5 排序规则性能优化


**⚡ 性能考虑因素**
```sql
-- 性能测试：不同排序规则的查询速度

-- 1. general_ci（最快）
SELECT COUNT(*) FROM large_table 
WHERE name COLLATE utf8mb4_general_ci = 'test';

-- 2. unicode_ci（较慢，但更准确）
SELECT COUNT(*) FROM large_table 
WHERE name COLLATE utf8mb4_unicode_ci = 'test';

-- 3. bin（中等速度）
SELECT COUNT(*) FROM large_table 
WHERE name COLLATE utf8mb4_bin = 'test';
```

**🎯 选择建议**
```
性能优先 → utf8mb4_general_ci
• 适合：高并发查询，对排序准确性要求不高

准确性优先 → utf8mb4_unicode_ci  
• 适合：多语言环境，需要标准Unicode排序

安全性优先 → utf8mb4_bin
• 适合：密码字段，需要区分大小写
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 CAST：SQL标准的类型转换函数，跨数据库兼容
🔸 CONVERT：MySQL特有转换函数，支持编码转换  
🔸 BINARY：强制二进制比较，区分大小写
🔸 CHARSET：字符集，定义字符编码方式
🔸 COLLATION：排序规则，定义字符比较和排序方式
```

### 6.2 关键理解要点


**🔹 类型转换的本质**
```
核心原理：
• 类型转换是数据表示方式的改变
• 不是数据本身的改变，而是解释方式的改变
• 就像同一个数字123，可以当整数用，也可以当字符串用

安全转换：
• 数字→字符串：总是安全的
• 字符串→数字：可能失败，需要验证格式
• 日期转换：格式必须正确
```

**🔹 字符编码的重要性**
```
编码选择原则：
• 新项目首选 utf8mb4
• 需要emoji支持 → 必须用utf8mb4
• 只有英文数字 → latin1效率最高
• 中文项目 → utf8mb4或gbk

常见问题：
• 乱码：编码不匹配导致
• 存储失败：字符集不支持特定字符
• 排序异常：排序规则设置不当
```

**🔹 排序规则的选择策略**
```
选择依据：
• 性能要求高 → general_ci
• 多语言准确性 → unicode_ci  
• 区分大小写 → bin
• 默认推荐 → unicode_ci（平衡性能和准确性）
```

### 6.3 实际应用价值


**🎯 解决的核心问题**
- **数据兼容性**：不同系统间的数据交换
- **国际化支持**：多语言网站和应用
- **数据精确性**：确保查询和排序的准确性
- **性能优化**：选择合适的转换方式提高效率

**🔧 最佳实践总结**
```
类型转换最佳实践：
1. 优先使用CAST（标准兼容）
2. 需要编码转换时使用CONVERT
3. 转换前验证数据格式
4. 处理转换异常情况

字符集配置最佳实践：
1. 新项目统一使用utf8mb4
2. 数据库、表、列保持字符集一致
3. 应用连接也要设置正确字符集
4. 定期检查和修复编码问题

排序规则选择最佳实践：
1. 根据业务需求选择合适规则
2. 敏感数据（密码）使用bin规则
3. 用户交互数据使用ci规则
4. 性能敏感场景优先考虑general_ci
```

### 6.4 记忆要点


**🧠 一句话精华**
```
CAST标准转换，CONVERT功能强
BINARY区分大小写，CHARSET定字符
COLLATION管排序，选对很重要
```

**🎯 核心记忆锚点**
- 看到类型不匹配 → 想到CAST/CONVERT
- 看到大小写问题 → 想到BINARY  
- 看到乱码显示 → 想到CHARSET字符集
- 看到排序异常 → 想到COLLATION排序规则
- 需要emoji支持 → 必须用utf8mb4

**✅ 学习检查清单**
- [ ] 能正确使用CAST进行基本类型转换
- [ ] 能区分CAST和CONVERT的使用场景
- [ ] 理解BINARY的作用和使用时机
- [ ] 能为新项目选择合适的字符集
- [ ] 能根据业务需求设置正确的排序规则
- [ ] 能诊断和解决常见的编码问题

**核心记忆**：
- 类型转换解决兼容问题，字符编码保证正确显示
- CAST通用CONVERT强大，BINARY严格区分大小写
- UTF8MB4现代首选，排序规则影响查询结果