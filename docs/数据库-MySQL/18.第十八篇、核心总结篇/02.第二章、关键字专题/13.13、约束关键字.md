---
title: 13、约束关键字
---
## 📚 目录

1. [约束概述](#1-约束概述)
2. [主键与唯一性约束](#2-主键与唯一性约束)
3. [外键与引用约束](#3-外键与引用约束)
4. [数据类型约束](#4-数据类型约束)
5. [字符集与排序约束](#5-字符集与排序约束)
6. [外键操作约束](#6-外键操作约束)
7. [约束管理与实践](#7-约束管理与实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ 约束概述


### 1.1 什么是数据库约束


**简单理解**：约束就像给数据库设置的"规则"，确保存入的数据符合要求

```
现实类比：
- 身份证号必须是18位 ← 这是长度约束
- 年龄不能为负数 ← 这是范围约束  
- 每个人的身份证号都不同 ← 这是唯一性约束
- 学生必须属于某个班级 ← 这是引用约束
```

**约束的核心作用**：
- 🛡️ **数据完整性**：保证数据的正确性和一致性
- 🚫 **防止错误**：阻止不合法的数据插入
- 🔗 **维护关系**：确保表之间的关联关系正确
- 📝 **业务规则**：强制执行业务逻辑规则

### 1.2 约束分类架构


```
MySQL约束体系结构：
├─ 列级约束
│   ├─ NOT NULL（非空约束）
│   ├─ DEFAULT（默认值约束）  
│   ├─ AUTO_INCREMENT（自动递增）
│   ├─ UNSIGNED（无符号）
│   ├─ SIGNED（有符号）
│   ├─ ZEROFILL（零填充）
│   └─ BINARY（二进制属性）
├─ 表级约束
│   ├─ PRIMARY KEY（主键约束）
│   ├─ UNIQUE（唯一约束）
│   ├─ FOREIGN KEY（外键约束）
│   ├─ CHECK（检查约束）
│   └─ INDEX/KEY（索引键）
├─ 引用约束
│   ├─ REFERENCES（引用表）
│   ├─ MATCH（匹配模式）
│   └─ 级联操作（CASCADE/SET/RESTRICT等）
└─ 字符约束
    ├─ CHARACTER SET（字符集）
    ├─ COLLATE（排序规则）
    └─ COMMENT（注释）
```

---

## 2. 🔑 主键与唯一性约束


### 2.1 PRIMARY主键约束


**什么是主键**：表中用来唯一标识每一行记录的列或列组合

```sql
-- 单列主键
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100)
);

-- 复合主键
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);

-- 使用CONSTRAINT命名主键
CREATE TABLE students (
    id INT,
    name VARCHAR(50),
    CONSTRAINT pk_students PRIMARY KEY (id)
);
```

**主键的特性**：
- ✅ **唯一性**：每个主键值都是唯一的
- ✅ **非空性**：主键不能为NULL
- ✅ **不可变性**：主键值一般不应该修改
- ✅ **索引性**：MySQL自动为主键创建聚集索引

### 2.2 UNIQUE唯一约束


**什么是唯一约束**：确保列中的所有值都是唯一的，但允许NULL值

```sql
-- 列级唯一约束
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20) UNIQUE
);

-- 表级唯一约束
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE KEY uk_email (email),
    UNIQUE KEY uk_phone (phone)
);

-- 复合唯一约束
CREATE TABLE courses (
    id INT PRIMARY KEY,
    course_code VARCHAR(10),
    semester VARCHAR(10),
    UNIQUE KEY uk_course_semester (course_code, semester)
);
```

**UNIQUE与PRIMARY KEY的区别**：

| 特性 | **PRIMARY KEY** | **UNIQUE** |
|------|-----------------|------------|
| 🔸 **NULL值** | `不允许NULL` | `允许NULL（但只能有一个）` |
| 🔸 **数量限制** | `每表只能有一个` | `每表可以有多个` |
| 🔸 **索引类型** | `聚集索引` | `非聚集索引` |
| 🔸 **外键引用** | `可以被外键引用` | `可以被外键引用` |

### 2.3 KEY键约束与INDEX索引键


**KEY和INDEX的关系**：在MySQL中，KEY和INDEX是同义词

```sql
-- 普通索引（提高查询性能）
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(50),
    KEY idx_name (name),           -- 等同于 INDEX idx_name (name)
    INDEX idx_age_city (age, city) -- 复合索引
);

-- 不同类型的索引
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    description TEXT,
    
    -- 普通索引
    KEY idx_name (name),
    
    -- 唯一索引
    UNIQUE KEY uk_name (name),
    
    -- 复合索引
    KEY idx_name_price (name, price),
    
    -- 全文索引
    FULLTEXT KEY ft_description (description)
);
```

**索引的作用**：
- ⚡ **加速查询**：大幅提升SELECT性能
- 🎯 **加速排序**：ORDER BY操作更快
- 🔗 **加速连接**：JOIN操作更高效
- 📊 **唯一性保证**：UNIQUE索引确保数据唯一

### 2.4 CONSTRAINT约束名


**为什么要给约束命名**：便于管理和维护约束

```sql
-- 命名约束的好处
CREATE TABLE orders (
    id INT,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    
    -- 命名主键约束
    CONSTRAINT pk_orders PRIMARY KEY (id),
    
    -- 命名外键约束
    CONSTRAINT fk_orders_customer 
        FOREIGN KEY (customer_id) REFERENCES customers(id),
    
    -- 命名检查约束
    CONSTRAINT chk_orders_amount 
        CHECK (total_amount > 0),
    
    -- 命名唯一约束
    CONSTRAINT uk_orders_date_customer 
        UNIQUE (customer_id, order_date)
);

-- 删除命名约束
ALTER TABLE orders DROP CONSTRAINT chk_orders_amount;
ALTER TABLE orders DROP FOREIGN KEY fk_orders_customer;
```

**约束命名规范**：
```
常用命名前缀：
├─ pk_  ← 主键约束 (Primary Key)
├─ fk_  ← 外键约束 (Foreign Key)  
├─ uk_  ← 唯一约束 (Unique Key)
├─ chk_ ← 检查约束 (Check)
├─ df_  ← 默认值约束 (Default)
└─ idx_ ← 普通索引 (Index)

命名格式：前缀_表名_列名
例如：fk_orders_customer_id
```

---

## 3. 🔗 外键与引用约束


### 3.1 FOREIGN外键约束


**什么是外键**：用来建立和加强两个表之间链接的列

```sql
-- 创建父表
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- 创建子表（包含外键）
CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    
    -- 外键约束
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 使用CONSTRAINT命名外键
CREATE TABLE order_items (
    id INT PRIMARY KEY,
    order_id INT,
    product_id INT,
    quantity INT,
    
    CONSTRAINT fk_items_order 
        FOREIGN KEY (order_id) REFERENCES orders(id),
    CONSTRAINT fk_items_product 
        FOREIGN KEY (product_id) REFERENCES products(id)
);
```

**外键的作用**：
- 🔗 **维护引用完整性**：确保引用的记录存在
- 🚫 **防止孤儿记录**：不能插入引用不存在记录的数据
- 🛡️ **防止意外删除**：不能删除被引用的父记录
- 📊 **数据一致性**：保持相关表之间的数据一致

### 3.2 REFERENCES引用表


**REFERENCES的作用**：指定外键引用的目标表和列

```sql
-- 基本引用语法
CREATE TABLE orders (
    id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 引用复合主键
CREATE TABLE order_details (
    order_id INT,
    product_id INT,
    line_number INT,
    quantity INT,
    
    FOREIGN KEY (order_id, product_id) 
        REFERENCES order_items(order_id, product_id)
);

-- 引用唯一键
CREATE TABLE user_profiles (
    id INT PRIMARY KEY,
    user_email VARCHAR(100),
    bio TEXT,
    
    FOREIGN KEY (user_email) REFERENCES users(email)  -- 引用UNIQUE列
);
```

**引用规则**：
- ✅ **引用列必须是主键或唯一键**
- ✅ **数据类型必须完全匹配**  
- ✅ **字符集和排序规则必须相同**
- ✅ **引用的表必须使用相同的存储引擎**

### 3.3 MATCH匹配模式


**匹配模式的作用**：定义复合外键的匹配规则

```sql
-- MATCH选项（MySQL支持有限）
CREATE TABLE order_items (
    order_id INT,
    customer_id INT,
    product_id INT,
    
    -- 完全匹配：所有列都必须匹配或都为NULL
    FOREIGN KEY (order_id, customer_id) 
        REFERENCES orders(id, customer_id) 
        MATCH FULL,
    
    -- 简单匹配：任何非NULL值都必须在引用表中找到匹配
    FOREIGN KEY (product_id) 
        REFERENCES products(id) 
        MATCH SIMPLE
);
```

**三种匹配模式**：

| 匹配模式 | **描述** | **行为** |
|----------|----------|----------|
| 🔸 **SIMPLE** | `简单匹配（默认）` | `任何非NULL外键值必须在引用表中存在` |
| 🔸 **FULL** | `完全匹配` | `所有外键列要么都为NULL，要么都有匹配值` |
| 🔸 **PARTIAL** | `部分匹配` | `MySQL不支持此模式` |

> ⚠️ **注意**：MySQL主要支持SIMPLE匹配模式，FULL模式支持有限

---

## 4. 📊 数据类型约束


### 4.1 NOT非空约束与NULL允许空值


**NULL值的含义**：表示"未知"或"无值"，不等于空字符串或0

```sql
-- NOT NULL约束
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,      -- 必填字段
    email VARCHAR(100) NOT NULL,    -- 必填字段
    phone VARCHAR(20),              -- 可选字段（允许NULL）
    age INT NULL                    -- 明确允许NULL（可省略NULL关键字）
);

-- 插入测试
INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@example.com');  -- 成功
INSERT INTO users (id, name) VALUES (2, 'Jane');  -- 失败：email不能为NULL
```

**NULL值的特殊性**：
```sql
-- NULL值比较的特殊性
SELECT * FROM users WHERE phone = NULL;     -- 错误写法，返回空结果
SELECT * FROM users WHERE phone IS NULL;    -- 正确写法
SELECT * FROM users WHERE phone IS NOT NULL; -- 查找非空值

-- NULL值参与运算
SELECT name, age + 10 FROM users;  -- 如果age是NULL，结果也是NULL
SELECT name, COALESCE(age, 0) + 10 FROM users;  -- 使用COALESCE处理NULL
```

### 4.2 DEFAULT默认值约束


**默认值的作用**：当插入数据时未指定值，自动使用默认值

```sql
-- 各种类型的默认值
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) DEFAULT 0.00,          -- 数字默认值
    status VARCHAR(20) DEFAULT 'active',        -- 字符串默认值
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- 时间戳默认值
    is_featured BOOLEAN DEFAULT FALSE,          -- 布尔默认值
    description TEXT DEFAULT NULL              -- 显式NULL默认值
);

-- 表达式作为默认值
CREATE TABLE orders (
    id INT PRIMARY KEY,
    order_number VARCHAR(20) DEFAULT (CONCAT('ORD', YEAR(CURDATE()), LPAD(CONNECTION_ID(), 6, '0'))),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**默认值的使用**：
```sql
-- 插入时使用默认值
INSERT INTO products (id, name) VALUES (1, 'Laptop');  -- price使用默认值0.00

-- 显式使用DEFAULT关键字
INSERT INTO products (id, name, price, status) 
VALUES (2, 'Mouse', DEFAULT, DEFAULT);

-- 修改默认值
ALTER TABLE products ALTER COLUMN status SET DEFAULT 'inactive';
```

### 4.3 AUTO_INCREMENT自动递增


**自动递增的作用**：为新插入的记录自动生成唯一的整数值

```sql
-- 基本AUTO_INCREMENT使用
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- 自动递增主键
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- 自定义起始值
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2)
) AUTO_INCREMENT = 1000;  -- 从1000开始

-- 插入数据
INSERT INTO users (name, email) VALUES ('John', 'john@example.com');    -- id自动为1
INSERT INTO users (name, email) VALUES ('Jane', 'jane@example.com');    -- id自动为2
```

**AUTO_INCREMENT的特点**：
- 🔢 **仅适用于整数类型**：INT、BIGINT等
- 🔑 **必须是键的一部分**：通常是主键或唯一键
- ⬆️ **单调递增**：每次插入值都比之前的大
- 🎯 **每表只能有一个**：一个表只能有一个AUTO_INCREMENT列

```sql
-- 管理AUTO_INCREMENT值
-- 查看当前AUTO_INCREMENT值
SHOW TABLE STATUS LIKE 'users';

-- 重置AUTO_INCREMENT值
ALTER TABLE users AUTO_INCREMENT = 100;

-- 获取最后插入的ID
INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com');
SELECT LAST_INSERT_ID();  -- 返回刚插入记录的id
```

### 4.4 UNSIGNED无符号与SIGNED有符号


**数值符号约束**：决定数字列是否可以存储负数

```sql
-- 有符号vs无符号对比
CREATE TABLE number_examples (
    id INT AUTO_INCREMENT PRIMARY KEY,
    signed_int INT SIGNED,              -- 有符号：-2147483648 到 2147483647
    unsigned_int INT UNSIGNED,          -- 无符号：0 到 4294967295
    signed_tinyint TINYINT SIGNED,      -- 有符号：-128 到 127  
    unsigned_tinyint TINYINT UNSIGNED,  -- 无符号：0 到 255
    price DECIMAL(10,2) UNSIGNED        -- 价格不能为负数
);

-- 年龄字段使用无符号（年龄不会为负）
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age TINYINT UNSIGNED,  -- 0-255，足够表示年龄
    balance DECIMAL(15,2) SIGNED  -- 账户余额可能为负
);
```

**选择原则**：
```
使用UNSIGNED的场景：
✅ 年龄、数量、价格等不会为负的值
✅ 主键ID（永远为正）
✅ 统计计数（如访问量、点赞数）

使用SIGNED的场景：  
✅ 账户余额（可能为负）
✅ 坐标值（可能为负）
✅ 温度值（可能为负）
✅ 默认情况（不确定时选择有符号）
```

### 4.5 ZEROFILL零填充


**零填充的作用**：用前导零填充数字，使其达到指定的显示宽度

```sql
-- ZEROFILL示例
CREATE TABLE products (
    id INT(6) ZEROFILL AUTO_INCREMENT PRIMARY KEY,  -- 显示为000001, 000002
    product_code INT(8) ZEROFILL,                    -- 手动指定的产品编码
    name VARCHAR(100)
);

-- 插入数据查看效果
INSERT INTO products (product_code, name) VALUES (123, 'Laptop');
-- 查询结果：id=000001, product_code=00000123

-- ZEROFILL自动隐含UNSIGNED
CREATE TABLE demo (
    zero_filled INT(5) ZEROFILL,  -- 自动变为 INT(5) UNSIGNED ZEROFILL
    normal_int INT(5)
);
```

**ZEROFILL的特点**：
- 🔢 **仅影响显示**：不改变存储的实际值
- 🚫 **自动UNSIGNED**：ZEROFILL列自动变为无符号
- 📊 **显示宽度**：INT(5)表示显示宽度5位
- ⚠️ **已废弃**：MySQL 8.0中已标记为废弃特性

> ⚠️ **注意**：ZEROFILL在现代MySQL版本中不推荐使用，应用程序格式化更灵活

### 4.6 BINARY二进制属性


**BINARY属性的作用**：使字符串比较区分大小写

```sql
-- BINARY属性示例
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50) BINARY,      -- 区分大小写的用户名
    email VARCHAR(100),               -- 不区分大小写（默认）
    password_hash CHAR(64) BINARY     -- 密码哈希（区分大小写）
);

-- 插入测试数据
INSERT INTO users VALUES (1, 'John', 'john@example.com', 'hash123');
INSERT INTO users VALUES (2, 'JOHN', 'JOHN@example.com', 'HASH123');

-- 查询对比
SELECT * FROM users WHERE username = 'john';     -- 只返回第一条
SELECT * FROM users WHERE username = 'John';     -- 只返回第一条  
SELECT * FROM users WHERE username = 'JOHN';     -- 只返回第二条

SELECT * FROM users WHERE email = 'john@example.com';  -- 返回两条（不区分大小写）
```

**BINARY vs COLLATION**：
```sql
-- 使用BINARY属性
CREATE TABLE t1 (name VARCHAR(50) BINARY);

-- 使用区分大小写的排序规则（推荐）
CREATE TABLE t2 (name VARCHAR(50) COLLATE utf8mb4_bin);

-- 两者效果类似，但COLLATE方式更明确
```

---

## 5. 🌍 字符集与排序约束


### 5.1 CHARACTER字符集


**什么是字符集**：定义数据库可以存储哪些字符的字符集合

```sql
-- 查看支持的字符集
SHOW CHARACTER SET;

-- 常用字符集对比
CREATE TABLE charset_demo (
    id INT PRIMARY KEY,
    latin1_col VARCHAR(100) CHARACTER SET latin1,    -- 只支持西欧字符
    utf8_col VARCHAR(100) CHARACTER SET utf8,        -- 支持大部分Unicode（3字节）
    utf8mb4_col VARCHAR(100) CHARACTER SET utf8mb4   -- 完整Unicode支持（4字节）
);

-- 设置表默认字符集
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    bio TEXT
) CHARACTER SET utf8mb4;

-- 设置数据库默认字符集
CREATE DATABASE myapp CHARACTER SET utf8mb4;
```

**字符集选择指南**：
```
utf8mb4：推荐选择
✅ 完整的Unicode支持
✅ 支持emoji表情符号
✅ 支持各种语言文字
✅ MySQL 8.0默认字符集

utf8：逐步淘汰
⚠️ 不完整的Unicode（最大3字节）
⚠️ 不支持emoji和某些字符
⚠️ 可能导致数据截断

latin1：特殊场景
❌ 仅支持西欧字符
❌ 不支持中文等多语言
✅ 存储效率高（1字节/字符）
```

### 5.2 COLLATE排序规则


**什么是排序规则**：定义字符的排序和比较规则

```sql
-- 不同排序规则的效果
CREATE TABLE collation_demo (
    id INT PRIMARY KEY,
    name_ci VARCHAR(50) COLLATE utf8mb4_general_ci,    -- 不区分大小写
    name_cs VARCHAR(50) COLLATE utf8mb4_bin,           -- 区分大小写
    name_accent VARCHAR(50) COLLATE utf8mb4_unicode_ci  -- 不区分重音符号
);

-- 插入测试数据
INSERT INTO collation_demo VALUES (1, 'Apple', 'Apple', 'café');
INSERT INTO collation_demo VALUES (2, 'apple', 'apple', 'cafe');

-- 查询对比
SELECT * FROM collation_demo WHERE name_ci = 'apple';     -- 返回两条记录
SELECT * FROM collation_demo WHERE name_cs = 'apple';     -- 只返回第二条
SELECT * FROM collation_demo WHERE name_accent = 'cafe';  -- 可能返回两条
```

**常用排序规则**：
```
utf8mb4_general_ci：
├─ 速度快，精度一般
├─ 不区分大小写
├─ 适合一般应用

utf8mb4_unicode_ci：
├─ 速度慢，精度高  
├─ 正确处理各种语言
├─ 适合多语言应用

utf8mb4_bin：
├─ 二进制比较
├─ 区分大小写
├─ 适合敏感数据
```

```sql
-- 在查询中临时指定排序规则
SELECT * FROM users 
WHERE name COLLATE utf8mb4_bin = 'John';  -- 区分大小写查询

-- 排序时指定规则
SELECT * FROM users 
ORDER BY name COLLATE utf8mb4_unicode_ci;  -- 按Unicode规则排序
```

### 5.3 COMMENT注释


**注释的作用**：为表、列添加说明文档，提高代码可读性

```sql
-- 表和列的注释
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户唯一标识',
    username VARCHAR(50) NOT NULL COMMENT '用户名，用于登录',
    email VARCHAR(100) UNIQUE COMMENT '电子邮箱地址',
    password_hash CHAR(64) COMMENT 'SHA256密码哈希值',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '账户创建时间',
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active' 
           COMMENT '账户状态：active活跃，inactive非活跃，banned封禁'
) COMMENT = '用户账户信息表';

-- 约束注释
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID',
    customer_id INT COMMENT '客户ID，关联customers表',
    
    CONSTRAINT fk_orders_customer 
        FOREIGN KEY (customer_id) REFERENCES customers(id)
        ON DELETE CASCADE
        COMMENT '客户外键约束，客户删除时级联删除订单'
) COMMENT = '订单信息表，存储所有订单数据';
```

**查看注释**：
```sql
-- 查看表结构和注释
SHOW CREATE TABLE users;
DESC users;

-- 查看表注释
SELECT TABLE_COMMENT 
FROM information_schema.TABLES 
WHERE TABLE_NAME = 'users';

-- 查看列注释  
SELECT COLUMN_NAME, COLUMN_COMMENT
FROM information_schema.COLUMNS
WHERE TABLE_NAME = 'users';
```

**注释最佳实践**：
```
好的注释示例：
✅ user_id INT COMMENT '用户ID，关联users表主键'
✅ status ENUM('pending','completed') COMMENT '订单状态：pending待处理，completed已完成'
✅ price DECIMAL(10,2) COMMENT '商品价格，单位：元'

避免的注释：
❌ id INT COMMENT 'id'  （无意义重复）
❌ name VARCHAR(50) COMMENT 'name field'  （显而易见）
❌ 过长的注释（超过100个字符）
```

---

## 6. 🔄 外键操作约束


### 6.1 CHECK检查约束


**CHECK约束的作用**：定义列值必须满足的条件表达式

```sql
-- MySQL 8.0+ 支持CHECK约束
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) CHECK (price > 0) COMMENT '价格必须大于0',
    discount_rate DECIMAL(3,2) 
        CHECK (discount_rate >= 0 AND discount_rate <= 1) 
        COMMENT '折扣率0-1之间',
    category ENUM('electronics', 'clothing', 'books') NOT NULL,
    stock_quantity INT UNSIGNED 
        CHECK (stock_quantity >= 0) 
        COMMENT '库存不能为负数'
);

-- 命名CHECK约束
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    age INT,
    salary DECIMAL(10,2),
    department VARCHAR(50),
    
    CONSTRAINT chk_employee_age 
        CHECK (age >= 18 AND age <= 65),
    CONSTRAINT chk_employee_salary 
        CHECK (salary > 0),
    CONSTRAINT chk_employee_dept 
        CHECK (department IN ('IT', 'HR', 'Finance', 'Marketing'))
);
```

**复杂CHECK约束示例**：
```sql
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    ship_date DATE,
    total_amount DECIMAL(10,2) NOT NULL,
    status ENUM('pending', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    
    -- 发货日期不能早于订单日期
    CONSTRAINT chk_ship_after_order 
        CHECK (ship_date IS NULL OR ship_date >= order_date),
    
    -- 总金额必须大于0
    CONSTRAINT chk_positive_amount 
        CHECK (total_amount > 0),
    
    -- 已发货的订单必须有发货日期
    CONSTRAINT chk_shipped_date 
        CHECK (status != 'shipped' OR ship_date IS NOT NULL)
);
```

> ⚠️ **注意**：MySQL 8.0之前的版本虽然接受CHECK语法，但不会实际执行检查

### 6.2 级联操作：CASCADE、SET、RESTRICT、NO_ACTION


**级联操作的作用**：定义当父表记录变化时，子表记录的处理方式

```sql
-- 创建父表
CREATE TABLE customers (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE
);

-- 不同级联操作示例
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    total_amount DECIMAL(10,2),
    
    -- CASCADE：级联删除和更新
    CONSTRAINT fk_orders_customer_cascade
        FOREIGN KEY (customer_id) REFERENCES customers(id)
        ON DELETE CASCADE           -- 删除客户时，删除其所有订单
        ON UPDATE CASCADE           -- 更新客户ID时，同步更新订单中的customer_id
);

CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    product_name VARCHAR(100),
    quantity INT,
    
    -- RESTRICT：限制操作
    CONSTRAINT fk_items_order_restrict
        FOREIGN KEY (order_id) REFERENCES orders(id)
        ON DELETE RESTRICT          -- 有订单项时不能删除订单
        ON UPDATE RESTRICT          -- 有订单项时不能更新订单ID
);

CREATE TABLE payments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    amount DECIMAL(10,2),
    payment_date DATE,
    
    -- SET NULL：设置为NULL
    CONSTRAINT fk_payments_order_null
        FOREIGN KEY (order_id) REFERENCES orders(id)
        ON DELETE SET NULL          -- 删除订单时，将payment.order_id设为NULL
        ON UPDATE SET NULL          -- 更新订单ID时，将payment.order_id设为NULL
);
```

### 6.3 ON_DELETE删除时与ON_UPDATE更新时


**详细的级联操作类型**：

| 操作类型 | **ON DELETE** | **ON UPDATE** | **说明** |
|----------|---------------|---------------|----------|
| 🔸 **CASCADE** | `删除父记录时删除子记录` | `更新父记录时同步更新子记录` | `级联传播操作` |
| 🔸 **SET NULL** | `删除父记录时子记录外键置NULL` | `更新父记录时子记录外键置NULL` | `外键列必须允许NULL` |
| 🔸 **SET DEFAULT** | `删除父记录时子记录外键置默认值` | `更新父记录时子记录外键置默认值` | `外键列必须有默认值` |
| 🔸 **RESTRICT** | `有子记录时禁止删除父记录` | `有子记录时禁止更新父记录` | `保护性限制` |
| 🔸 **NO ACTION** | `与RESTRICT相同` | `与RESTRICT相同` | `默认行为` |

**实际应用示例**：
```sql
-- 用户-订单-订单项的完整示例
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 用户删除时，其订单也删除（CASCADE）
    CONSTRAINT fk_orders_user
        FOREIGN KEY (user_id) REFERENCES users(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);

CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    
    -- 订单删除时，订单项也删除（CASCADE）
    CONSTRAINT fk_items_order
        FOREIGN KEY (order_id) REFERENCES orders(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);

CREATE TABLE user_profiles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT UNIQUE,
    bio TEXT,
    avatar_url VARCHAR(255),
    
    -- 用户删除时，个人资料置为NULL（SET NULL）
    -- 这样可以保留历史数据用于分析
    CONSTRAINT fk_profile_user
        FOREIGN KEY (user_id) REFERENCES users(id)
        ON DELETE SET NULL
        ON UPDATE CASCADE
);
```

**级联操作的注意事项**：
```
CASCADE使用场景：
✅ 主从关系密切（如订单-订单项）
✅ 删除主记录时从记录无意义
✅ 需要保持数据一致性

RESTRICT使用场景：
✅ 需要保护重要数据不被误删
✅ 删除前需要人工确认
✅ 有业务审核流程

SET NULL使用场景：
✅ 需要保留历史记录
✅ 外键关系不是强制性的
✅ 用于审计和数据分析
```

---

## 7. 🛠️ 约束管理与实践


### 7.1 约束的添加与删除


**添加约束**：
```sql
-- 添加主键约束
ALTER TABLE users ADD CONSTRAINT pk_users PRIMARY KEY (id);

-- 添加外键约束
ALTER TABLE orders 
ADD CONSTRAINT fk_orders_customer 
    FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE CASCADE ON UPDATE CASCADE;

-- 添加唯一约束
ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email);

-- 添加检查约束
ALTER TABLE products 
ADD CONSTRAINT chk_products_price CHECK (price > 0);

-- 添加索引
ALTER TABLE users ADD INDEX idx_users_name (name);
```

**删除约束**：
```sql
-- 删除主键约束（需要先删除AUTO_INCREMENT）
ALTER TABLE users MODIFY id INT;                    -- 去掉AUTO_INCREMENT
ALTER TABLE users DROP PRIMARY KEY;                 -- 删除主键

-- 删除外键约束
ALTER TABLE orders DROP FOREIGN KEY fk_orders_customer;

-- 删除唯一约束
ALTER TABLE users DROP INDEX uk_users_email;

-- 删除检查约束
ALTER TABLE products DROP CHECK chk_products_price;

-- 删除索引
ALTER TABLE users DROP INDEX idx_users_name;
```

### 7.2 约束信息查询


**查看表的所有约束**：
```sql
-- 查看表结构
DESC users;
SHOW CREATE TABLE users;

-- 查看约束详细信息
SELECT 
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE,
    TABLE_NAME,
    COLUMN_NAME
FROM information_schema.TABLE_CONSTRAINTS tc
JOIN information_schema.KEY_COLUMN_USAGE kcu 
    ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE tc.TABLE_NAME = 'users';

-- 查看外键约束
SELECT 
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME,
    DELETE_RULE,
    UPDATE_RULE
FROM information_schema.KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_NAME = 'customers';
```

### 7.3 约束性能影响


**约束对性能的影响**：
```sql
-- 外键约束的性能考虑
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    
    -- 外键约束会影响INSERT/UPDATE/DELETE性能
    -- 因为需要检查引用完整性
    FOREIGN KEY (customer_id) REFERENCES customers(id),
    
    -- 建议为外键列创建索引加速查找
    INDEX idx_orders_customer (customer_id)
);

-- CHECK约束的性能影响
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    
    -- 简单CHECK约束性能影响小
    CHECK (price > 0),
    
    -- 复杂CHECK约束可能影响性能
    CHECK (price BETWEEN 0.01 AND 99999.99 AND MOD(price * 100, 1) = 0)
);
```

**性能优化建议**：
```
索引策略：
✅ 为外键列创建索引
✅ 为经常查询的列创建索引
✅ 考虑复合索引的列顺序

约束设计：
✅ 使用简单的CHECK约束
✅ 避免过于复杂的级联关系
✅ 在业务逻辑和数据库约束间平衡

批量操作：
✅ 批量插入时考虑暂时禁用外键检查
✅ 使用事务保证操作的原子性
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 约束分类：列级约束、表级约束、引用约束
🔸 完整性保证：主键唯一性、外键引用完整性、数据类型约束
🔸 级联操作：CASCADE级联、RESTRICT限制、SET NULL置空
🔸 字符处理：CHARACTER SET字符集、COLLATE排序规则
🔸 自动机制：AUTO_INCREMENT自动递增、DEFAULT默认值
```

### 8.2 关键理解要点


**🔹 主键与唯一约束的区别**
```
PRIMARY KEY：
✅ 每表只能有一个
✅ 不允许NULL值
✅ 自动创建聚集索引
✅ 通常用作外键引用目标

UNIQUE：
✅ 每表可以有多个
✅ 允许一个NULL值
✅ 创建非聚集索引
✅ 也可以用作外键引用目标
```

**🔹 外键约束的深层含义**
```
作用机制：
├─ 插入子记录时检查父记录是否存在
├─ 删除/更新父记录时根据级联规则处理子记录
├─ 保证数据库的引用完整性
└─ 防止产生孤儿记录

性能影响：
├─ INSERT性能：需要检查父表
├─ DELETE/UPDATE性能：需要检查子表
├─ 查询性能：外键列需要建立索引
└─ 锁定影响：可能产生额外的锁
```

**🔹 约束命名的重要性**
```
好处：
✅ 便于维护和管理
✅ 错误信息更清晰
✅ 便于脚本化操作
✅ 团队协作更高效

命名规范：
├─ pk_tablename  （主键）
├─ fk_table_column  （外键）
├─ uk_table_column  （唯一键）
├─ chk_table_condition  （检查约束）
└─ idx_table_column  （索引）
```

### 8.3 实际应用指导


**🔸 约束设计原则**
```sql
-- 1. 合理使用主键
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- 使用BIGINT防止溢出
    uuid CHAR(36) UNIQUE,                   -- 业务ID用UUID
    username VARCHAR(50) UNIQUE NOT NULL
);

-- 2. 谨慎设计外键
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT,
    
    -- 考虑是否真的需要外键约束
    -- 高并发场景可能只在应用层检查
    FOREIGN KEY (user_id) REFERENCES users(id) 
        ON DELETE RESTRICT  -- 避免意外删除用户
);

-- 3. 适当使用CHECK约束  
CREATE TABLE products (
    price DECIMAL(10,2) CHECK (price >= 0),    -- 简单有效
    status ENUM('active', 'inactive') NOT NULL  -- 枚举比复杂CHECK更好
);
```

**🔸 常见约束错误与解决**
```sql
-- 错误1：外键类型不匹配
-- 错误示例
CREATE TABLE orders (
    user_id INT,  -- INT类型
    FOREIGN KEY (user_id) REFERENCES users(id)  -- 如果users.id是BIGINT则报错
);

-- 正确示例
CREATE TABLE orders (
    user_id BIGINT,  -- 与引用列类型完全匹配
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 错误2：字符集不匹配
-- 确保外键列字符集相同
ALTER TABLE orders MODIFY user_code VARCHAR(20) CHARACTER SET utf8mb4;
```

**🔸 性能优化建议**
```sql
-- 1. 为外键创建索引
CREATE TABLE order_items (
    order_id BIGINT,
    product_id BIGINT,
    
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (product_id) REFERENCES products(id),
    
    -- 重要：为外键列创建索引
    INDEX idx_order_id (order_id),
    INDEX idx_product_id (product_id)
);

-- 2. 批量操作时的约束处理
SET FOREIGN_KEY_CHECKS = 0;  -- 临时禁用外键检查
-- 执行批量插入操作
SET FOREIGN_KEY_CHECKS = 1;  -- 恢复外键检查
```

**核心记忆要点**：
- 约束是数据库的"安全卫士"，保证数据质量
- 主键确保唯一性，外键维护关系完整性
- 合理的约束设计在数据安全和性能间找平衡
- 约束命名规范化，便于维护和团队协作
- 理解约束的性能影响，在高并发场景下谨慎使用