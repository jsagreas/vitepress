---
title: 3、数据查询语言DQL关键字
---
## 📚 目录

1. [数据去重查询：DISTINCT与ALL](#1-数据去重查询distinct与all)
2. [字段别名设置：AS别名](#2-字段别名设置as别名)
3. [排序控制：ORDER BY与ASC/DESC](#3-排序控制order-by与ascdesc)
4. [数据分组：GROUP BY](#4-数据分组group-by)
5. [分组条件过滤：HAVING](#5-分组条件过滤having)
6. [结果数量控制：LIMIT与OFFSET](#6-结果数量控制limit与offset)
7. [集合运算：UNION/INTERSECT/EXCEPT](#7-集合运算unionintersectexcept)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 数据去重查询：DISTINCT与ALL


### 1.1 DISTINCT去重的含义


**什么是DISTINCT？**
DISTINCT就像是一个"过滤器"，它的作用是**去除查询结果中的重复行**。想象你在统计班级里有多少种不同的兴趣爱好，你不会重复统计相同的爱好。

```
没有DISTINCT的情况：
学生表中的爱好字段
张三 → 篮球
李四 → 足球  
王五 → 篮球
赵六 → 游泳
钱七 → 篮球

查询结果：篮球, 足球, 篮球, 游泳, 篮球（有重复）

使用DISTINCT的情况：
查询结果：篮球, 足球, 游泳（去除重复）
```

### 1.2 DISTINCT基本用法


**语法结构：**
```sql
SELECT DISTINCT 字段名 FROM 表名;
```

**实例演示：**
```sql
-- 查询所有不重复的城市
SELECT DISTINCT city FROM users;

-- 查询多个字段的组合去重
SELECT DISTINCT department, position FROM employees;
```

> 💡 **重要理解**
> 
> DISTINCT作用于**整行数据**，只有当所有指定字段的值都完全相同时，才会被认为是重复行

### 1.3 ALL关键字说明


**什么是ALL？**
ALL是SELECT的默认行为，表示**返回所有行，包括重复行**。通常我们不需要显式写出ALL，因为它是默认的。

```sql
-- 这两种写法效果完全一样
SELECT city FROM users;
SELECT ALL city FROM users;
```

### 1.4 去重的实际应用场景


**📊 常见使用场景：**

| 场景 | 示例查询 | 说明 |
|------|----------|------|
| **统计分类** | `SELECT DISTINCT category FROM products` | 查看商品有哪些分类 |
| **用户分析** | `SELECT DISTINCT age FROM users` | 统计用户年龄分布 |
| **地域统计** | `SELECT DISTINCT province, city FROM orders` | 统计订单覆盖的省市 |

---

## 2. 🏷️ 字段别名设置：AS别名


### 2.1 什么是别名


**别名的本质含义：**
别名就是给查询结果中的字段或表**起一个更容易理解的名字**。就像给人起外号一样，让结果更直观易懂。

```
原始字段名：user_first_name（程序员命名风格）
使用别名后：姓名（人类更容易理解）
```

### 2.2 字段别名的使用


**基础语法：**
```sql
SELECT 字段名 AS 别名 FROM 表名;
-- AS关键字可以省略
SELECT 字段名 别名 FROM 表名;
```

**实用示例：**
```sql
-- 让查询结果更易读
SELECT 
    user_name AS 用户名,
    user_age AS 年龄,
    user_email AS 邮箱
FROM users;

-- 计算字段使用别名
SELECT 
    price * quantity AS 总金额,
    order_date AS 下单日期
FROM orders;
```

### 2.3 表别名的使用


**什么时候需要表别名？**
当查询涉及**多个表**时，表别名可以让SQL语句更简洁，避免字段名冲突。

```sql
-- 使用表别名简化多表查询
SELECT 
    u.name AS 用户名,
    o.total AS 订单金额
FROM users AS u, orders AS o
WHERE u.id = o.user_id;
```

### 2.4 别名使用的注意事项


> ⚠️ **重要提醒**
> 
> 别名只在查询结果中生效，不会改变数据库中的实际字段名

**📋 别名最佳实践：**
- ✅ 使用有意义的中文名称提高可读性
- ✅ 复杂计算结果必须使用别名
- ✅ 多表查询时使用简短的表别名
- ❌ 避免使用SQL关键字作为别名

---

## 3. 📊 排序控制：ORDER BY与ASC/DESC


### 3.1 排序的基本概念


**为什么需要排序？**
数据库返回的数据默认**没有固定顺序**，排序让我们可以按照指定规则整理数据，就像整理书架一样。

```
未排序的学生成绩：
张三: 85分, 李四: 92分, 王五: 78分, 赵六: 95分

按成绩排序后：
赵六: 95分, 李四: 92分, 张三: 85分, 王五: 78分
```

### 3.2 ORDER BY基础语法


**核心语法结构：**
```sql
SELECT 字段列表 
FROM 表名 
ORDER BY 字段名 [ASC|DESC];
```

**关键词含义：**
- **ORDER BY**：按照指定字段排序
- **ASC**：升序排列（从小到大，默认方式）
- **DESC**：降序排列（从大到小）

### 3.3 单字段排序示例


```sql
-- 按价格从低到高排序（升序）
SELECT product_name, price 
FROM products 
ORDER BY price ASC;

-- 按创建时间从新到旧排序（降序）
SELECT title, create_time 
FROM articles 
ORDER BY create_time DESC;
```

### 3.4 多字段排序


**多字段排序规则：**
先按第一个字段排序，如果第一个字段相同，再按第二个字段排序，依此类推。

```sql
-- 先按部门排序，同部门内再按薪资排序
SELECT name, department, salary
FROM employees
ORDER BY department ASC, salary DESC;
```

**排序优先级示例：**
```
原始数据：
张三, 技术部, 8000
李四, 技术部, 12000  
王五, 销售部, 6000
赵六, 技术部, 10000

排序结果：
李四, 技术部, 12000  ← 技术部中薪资最高
赵六, 技术部, 10000  ← 技术部中薪资第二
张三, 技术部, 8000   ← 技术部中薪资最低
王五, 销售部, 6000   ← 销售部
```

### 3.5 排序的性能考虑


> 📈 **性能提示**
> 
> 排序操作需要消耗计算资源，对大数据量的排序建议在排序字段上建立索引

---

## 4. 🗂️ 数据分组：GROUP BY


### 4.1 分组的核心概念


**什么是数据分组？**
分组就是把具有**相同特征的数据归类到一起**，然后对每一组进行统计计算。就像把班级学生按性别分组统计人数一样。

```
学生数据分组示例：
原始数据：
张三, 男, 数学, 85
李四, 女, 数学, 92  
王五, 男, 英语, 78
赵六, 女, 英语, 88

按性别分组：
男生组：张三(85), 王五(78) → 平均分: 81.5
女生组：李四(92), 赵六(88) → 平均分: 90
```

### 4.2 GROUP BY基础语法


**语法结构：**
```sql
SELECT 分组字段, 聚合函数(字段)
FROM 表名
GROUP BY 分组字段;
```

**常用聚合函数：**

| 函数 | 含义 | 示例 |
|------|------|------|
| `COUNT()` | 统计数量 | `COUNT(*)` 统计总行数 |
| `SUM()` | 求和 | `SUM(salary)` 计算总薪资 |
| `AVG()` | 平均值 | `AVG(score)` 计算平均分 |
| `MAX()` | 最大值 | `MAX(age)` 找最大年龄 |
| `MIN()` | 最小值 | `MIN(price)` 找最低价格 |

### 4.3 分组查询实例


```sql
-- 统计每个部门的员工数量
SELECT department, COUNT(*) AS 员工数量
FROM employees
GROUP BY department;

-- 计算每个类别商品的平均价格
SELECT category, AVG(price) AS 平均价格
FROM products  
GROUP BY category;

-- 统计每个月的订单总金额
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') AS 月份,
    SUM(total_amount) AS 月度销售额
FROM orders
GROUP BY DATE_FORMAT(order_date, '%Y-%m');
```

### 4.4 分组规则说明


> ⚠️ **重要规则**
> 
> 使用GROUP BY时，SELECT语句中只能包含：
> - 分组字段
> - 聚合函数的结果
> - 常量值

**错误示例：**
```sql
-- ❌ 错误：name字段不在GROUP BY中，也不是聚合函数
SELECT name, department, COUNT(*)
FROM employees
GROUP BY department;
```

**正确示例：**
```sql
-- ✅ 正确：只选择分组字段和聚合结果
SELECT department, COUNT(*) AS 人数
FROM employees
GROUP BY department;
```

---

## 5. 🔍 分组条件过滤：HAVING


### 5.1 HAVING与WHERE的区别


**核心区别理解：**

```
数据处理流程：
原始数据 → WHERE过滤 → GROUP BY分组 → 聚合计算 → HAVING过滤 → 最终结果
```

- **WHERE**：对**原始数据行**进行过滤（分组前）
- **HAVING**：对**分组后的聚合结果**进行过滤（分组后）

### 5.2 什么时候使用HAVING


**使用场景：**
当你需要根据**聚合函数的结果**来筛选分组时，必须使用HAVING。

```sql
-- 查找员工数量大于5人的部门
SELECT department, COUNT(*) AS 员工数量
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;

-- WHERE无法实现上述功能，因为COUNT(*)是聚合结果
```

### 5.3 HAVING语法结构


```sql
SELECT 字段列表
FROM 表名
[WHERE 行过滤条件]
GROUP BY 分组字段
HAVING 分组过滤条件
[ORDER BY 排序字段];
```

### 5.4 HAVING实际应用


```sql
-- 查找平均分大于80的班级
SELECT class_name, AVG(score) AS 平均分
FROM students
GROUP BY class_name
HAVING AVG(score) > 80;

-- 查找销售额超过10万的月份
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') AS 月份,
    SUM(amount) AS 月销售额
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m')
HAVING SUM(amount) > 100000
ORDER BY 月份;
```

### 5.5 WHERE与HAVING的性能差异


> 💡 **性能建议**
> 
> 能用WHERE的条件尽量用WHERE，因为WHERE在分组前过滤，处理的数据量更小

**性能对比示例：**
```sql
-- ✅ 推荐：先用WHERE减少数据量
SELECT department, AVG(salary) AS 平均薪资
FROM employees
WHERE hire_date > '2020-01-01'  -- 先过滤
GROUP BY department
HAVING AVG(salary) > 8000;      -- 再过滤聚合结果

-- ❌ 不推荐：直接在HAVING中写能用WHERE的条件
SELECT department, AVG(salary) AS 平均薪资
FROM employees
GROUP BY department
HAVING AVG(salary) > 8000 AND hire_date > '2020-01-01';  -- 错误写法
```

---

## 6. 📏 结果数量控制：LIMIT与OFFSET


### 6.1 为什么需要限制结果数量


**实际需求场景：**
- 📱 **分页显示**：网页每页只显示10条记录
- 🔝 **排行榜**：只显示前5名用户
- ⚡ **性能优化**：避免一次查询过多数据

```
数据库有10万条用户记录
用户只需要看第1页的20条 → 使用LIMIT控制
```

### 6.2 LIMIT基础用法


**语法格式：**
```sql
SELECT 字段列表 FROM 表名 LIMIT 数量;
SELECT 字段列表 FROM 表名 LIMIT 偏移量, 数量;
```

**基础示例：**
```sql
-- 只取前5条记录
SELECT * FROM users ORDER BY create_time DESC LIMIT 5;

-- 跳过前10条，取接下来的5条
SELECT * FROM products ORDER BY price LIMIT 10, 5;
```

### 6.3 OFFSET的作用


**OFFSET的含义：**
OFFSET表示**跳过多少条记录**，从指定位置开始取数据。

```sql
-- 标准语法（更清晰）
SELECT * FROM users 
ORDER BY id 
LIMIT 20 OFFSET 40;  -- 跳过前40条，取20条

-- MySQL简化语法
SELECT * FROM users 
ORDER BY id 
LIMIT 40, 20;        -- 跳过40条，取20条
```

### 6.4 分页查询实现


**分页公式：**
```
页码从1开始：
第1页：LIMIT 20 OFFSET 0    (跳过0条)
第2页：LIMIT 20 OFFSET 20   (跳过20条)  
第3页：LIMIT 20 OFFSET 40   (跳过40条)

计算公式：OFFSET = (页码 - 1) × 每页数量
```

**分页查询示例：**
```sql
-- 每页显示10条，查询第3页
SET @page_size = 10;
SET @page_num = 3;
SET @offset = (@page_num - 1) * @page_size;

SELECT id, name, email 
FROM users 
ORDER BY create_time DESC
LIMIT @page_size OFFSET @offset;
```

### 6.5 Top N查询


```sql
-- 查询销售额最高的3个产品
SELECT product_name, sales_amount
FROM products
ORDER BY sales_amount DESC
LIMIT 3;

-- 查询每个类别中价格最高的产品
SELECT category, product_name, price
FROM (
    SELECT category, product_name, price,
           ROW_NUMBER() OVER(PARTITION BY category ORDER BY price DESC) as rn
    FROM products
) ranked
WHERE rn = 1;
```

---

## 7. 🔗 集合运算：UNION/INTERSECT/EXCEPT


### 7.1 集合运算的概念


**什么是集合运算？**
集合运算就像数学中的集合操作，把**两个或多个查询结果**按照特定规则合并。

```
集合A：{张三, 李四, 王五}
集合B：{王五, 赵六, 孙七}

并集(UNION)：    {张三, 李四, 王五, 赵六, 孙七}
交集(INTERSECT)：{王五}  
差集(EXCEPT)：   {张三, 李四}
```

### 7.2 UNION联合查询


**UNION的作用：**
将多个SELECT查询的结果**合并成一个结果集**，自动去除重复行。

**语法结构：**
```sql
SELECT 字段列表 FROM 表1
UNION
SELECT 字段列表 FROM 表2;
```

**实际应用示例：**
```sql
-- 合并活跃用户和VIP用户列表
SELECT user_id, user_name, 'active' as user_type
FROM active_users
WHERE last_login > DATE_SUB(NOW(), INTERVAL 30 DAY)

UNION

SELECT user_id, user_name, 'vip' as user_type  
FROM vip_users
WHERE status = 'active';
```

### 7.3 UNION ALL与UNION的区别


**关键区别：**

| 操作 | 去重 | 性能 | 使用场景 |
|------|------|------|----------|
| **UNION** | ✅ 自动去重 | 较慢 | 不需要重复数据 |
| **UNION ALL** | ❌ 保留重复 | 更快 | 允许重复数据 |

```sql
-- UNION：会去除重复行
SELECT city FROM users_north
UNION  
SELECT city FROM users_south;

-- UNION ALL：保留所有行，包括重复
SELECT city FROM users_north
UNION ALL
SELECT city FROM users_south;
```

### 7.4 INTERSECT交集操作


**交集的含义：**
返回同时存在于两个查询结果中的行。

> ⚠️ **数据库支持说明**
> 
> MySQL不直接支持INTERSECT，需要用其他方式实现

**MySQL中实现交集：**
```sql
-- 使用INNER JOIN实现交集
SELECT DISTINCT u1.user_id, u1.user_name
FROM active_users u1
INNER JOIN vip_users u2 ON u1.user_id = u2.user_id;

-- 使用EXISTS实现交集  
SELECT user_id, user_name
FROM active_users a
WHERE EXISTS (
    SELECT 1 FROM vip_users v 
    WHERE v.user_id = a.user_id
);
```

### 7.5 EXCEPT差集操作


**差集的含义：**
返回存在于第一个查询但不存在于第二个查询中的行。

**MySQL中实现差集：**
```sql
-- 使用LEFT JOIN实现差集
SELECT u1.user_id, u1.user_name
FROM all_users u1
LEFT JOIN vip_users u2 ON u1.user_id = u2.user_id
WHERE u2.user_id IS NULL;

-- 使用NOT EXISTS实现差集
SELECT user_id, user_name  
FROM all_users a
WHERE NOT EXISTS (
    SELECT 1 FROM vip_users v
    WHERE v.user_id = a.user_id
);
```

### 7.6 集合运算的使用规则


**📋 重要规则：**

> ⚠️ **使用限制**
> 
> - 参与运算的查询必须有**相同数量的列**
> - 对应列的**数据类型必须兼容**
> - 列名以第一个查询为准

**正确示例：**
```sql
-- ✅ 正确：列数相同，类型兼容
SELECT user_id, user_name FROM active_users
UNION
SELECT customer_id, customer_name FROM customers;
```

**错误示例：**
```sql
-- ❌ 错误：列数不同
SELECT user_id, user_name FROM users
UNION  
SELECT product_id, product_name, price FROM products;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 DISTINCT：去除重复行，让结果更准确
🔸 AS别名：让查询结果更易读，计算字段必须使用
🔸 ORDER BY：控制结果排序，ASC升序/DESC降序
🔸 GROUP BY：数据分组统计，配合聚合函数使用
🔸 HAVING：分组后过滤，针对聚合结果的条件
🔸 LIMIT/OFFSET：控制返回行数，实现分页查询
🔸 UNION：合并查询结果，UNION ALL保留重复
```

### 8.2 关键理解要点


**🔹 执行顺序理解**
```
SQL执行顺序：
FROM → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT
```

**🔹 WHERE vs HAVING的本质区别**
```
WHERE：过滤原始数据行（分组前）
HAVING：过滤聚合结果（分组后）
```

**🔹 分组查询的核心规则**
```
GROUP BY后，SELECT只能包含：
- 分组字段
- 聚合函数结果
- 常量值
```

### 8.3 实际应用指导


**📊 常用查询模式：**

| 需求类型 | 关键字组合 | 示例场景 |
|----------|------------|----------|
| **去重统计** | `DISTINCT` | 统计不同城市数量 |
| **排名查询** | `ORDER BY + LIMIT` | 销售排行榜前10名 |
| **分组统计** | `GROUP BY + COUNT/SUM` | 各部门员工统计 |
| **分页显示** | `LIMIT + OFFSET` | 网页分页展示 |
| **数据合并** | `UNION/UNION ALL` | 合并多表相似数据 |

**🎯 查询优化建议：**
- ✅ 能用WHERE的条件不要放在HAVING中
- ✅ 排序字段建议添加索引提高性能  
- ✅ 大数据量分页使用覆盖索引优化
- ✅ UNION ALL性能优于UNION，按需选择
- ✅ 分组字段选择性要好，避免产生过多分组

**核心记忆口诀：**
- 去重用DISTINCT，别名用AS
- 排序ORDER BY，分组GROUP统计
- HAVING过滤组，LIMIT控制量
- UNION合结果，WHERE与HAVING分场合