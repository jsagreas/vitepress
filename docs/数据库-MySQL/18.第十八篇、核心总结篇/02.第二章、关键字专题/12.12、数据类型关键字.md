---
title: 12、数据类型关键字
---
## 📚 目录

1. [数据类型概述](#1-数据类型概述)
2. [整数类型详解](#2-整数类型详解)
3. [小数类型详解](#3-小数类型详解)
4. [位和布尔类型](#4-位和布尔类型)
5. [字符串类型详解](#5-字符串类型详解)
6. [二进制数据类型](#6-二进制数据类型)
7. [日期时间类型](#7-日期时间类型)
8. [JSON数据类型](#8-JSON数据类型)
9. [几何数据类型](#9-几何数据类型)
10. [枚举和集合类型](#10-枚举和集合类型)
11. [数据类型选择指南](#11-数据类型选择指南)
12. [核心要点总结](#12-核心要点总结)

---

## 1. 🗂️ 数据类型概述


### 1.1 什么是数据类型


**数据类型**就是告诉MySQL你要存储什么样的数据，就像生活中的储物柜一样：

```
现实生活对比：
书柜 → 存放书籍 → TEXT类型（存储文本）
保险箱 → 存放重要文件 → BLOB类型（存储二进制）
日历 → 记录日期 → DATE类型（存储日期）
计算器 → 处理数字 → INT类型（存储整数）
```

**为什么需要数据类型？**
- 🎯 **存储优化**：不同类型占用的空间不同
- 🎯 **性能提升**：MySQL能更好地处理和索引数据  
- 🎯 **数据完整性**：防止存储不合适的数据

### 1.2 MySQL数据类型分类


```
数据类型家族图：

MySQL数据类型
├── 数值类型
│   ├── 整数类型（TINYINT、INT、BIGINT等）
│   └── 小数类型（DECIMAL、FLOAT、DOUBLE等）
├── 字符串类型
│   ├── 字符类型（CHAR、VARCHAR等）
│   └── 文本类型（TEXT、LONGTEXT等）
├── 二进制类型（BINARY、BLOB等）
├── 日期时间类型（DATE、TIME、DATETIME等）
├── JSON类型
├── 几何类型（POINT、POLYGON等）
└── 特殊类型（ENUM、SET、BIT等）
```

---

## 2. 🔢 整数类型详解


### 2.1 整数类型家族概览


| 类型名称 | **别名** | **字节数** | **取值范围（有符号）** | **取值范围（无符号）** |
|---------|---------|-----------|---------------------|-------------------|
| `TINYINT` | - | 1字节 | -128 到 127 | 0 到 255 |
| `SMALLINT` | - | 2字节 | -32,768 到 32,767 | 0 到 65,535 |
| `MEDIUMINT` | - | 3字节 | -8,388,608 到 8,388,607 | 0 到 16,777,215 |
| `INT` | `INTEGER` | 4字节 | -2,147,483,648 到 2,147,483,647 | 0 到 4,294,967,295 |
| `BIGINT` | - | 8字节 | -9223372036854775808 到 9223372036854775807 | 0 到 18446744073709551615 |

### 2.2 TINYINT微整型


**TINYINT**就是"袖珍版整数"，只占1个字节空间。

**典型应用场景**：
```sql
-- 用户状态：0=禁用，1=启用
user_status TINYINT DEFAULT 1

-- 年龄字段（人的年龄不会超过255）
age TINYINT UNSIGNED

-- 评分等级（1-5星评价）
rating TINYINT CHECK (rating BETWEEN 1 AND 5)
```

**💡 使用技巧**：
- 存储布尔值时，`TINYINT(1)`比`BOOLEAN`更明确
- 年龄、状态码、小范围计数器的首选
- 加上`UNSIGNED`可以存储0-255的数值

### 2.3 SMALLINT小整型


**SMALLINT**是"小号整数"，占2个字节，适合存储中等范围的数字。

**典型应用场景**：
```sql
-- 商品库存数量
stock_quantity SMALLINT UNSIGNED

-- 端口号（0-65535）
port_number SMALLINT UNSIGNED

-- 年份（比如1900-2100）
birth_year SMALLINT
```

**记忆方法**：想象成"小"超市的商品数量，几万件商品够用了。

### 2.4 MEDIUMINT中整型


**MEDIUMINT**是MySQL特有的"中号整数"，占3个字节，在其他数据库中不常见。

**典型应用场景**：
```sql
-- 网站访问量（日PV）
daily_page_views MEDIUMINT UNSIGNED

-- 中型城市人口数量
population MEDIUMINT UNSIGNED

-- 商品编号（百万级别）
product_id MEDIUMINT UNSIGNED AUTO_INCREMENT
```

**使用建议**：
- 当`SMALLINT`不够用，但`INT`又显得浪费时使用
- 主要用于节省存储空间

### 2.5 INT和INTEGER整型


**INT**和**INTEGER**是完全相同的，就像"电梯"和"升降机"是一个东西。

**典型应用场景**：
```sql
-- 用户ID（最常用）
user_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY

-- 价格（分为单位，避免浮点精度问题）
price_cents INT UNSIGNED

-- 订单数量
order_quantity INT
```

**为什么INT最常用？**
- 4字节空间够用：能存储42亿个不同数值
- 性能最佳：CPU处理32位整数最高效
- 兼容性好：所有编程语言都很好支持

### 2.6 BIGINT长整型


**BIGINT**是"超大号整数"，占8个字节，能存储天文数字级别的数据。

**典型应用场景**：
```sql
-- 全球唯一ID（雪花算法生成）
global_id BIGINT UNSIGNED

-- 金额（分为单位，大额交易）
amount_cents BIGINT

-- 时间戳（毫秒级Unix时间戳）
created_timestamp BIGINT
```

**使用注意**：
- 大部分编程语言需要使用长整型变量接收
- 存储空间是INT的2倍，非必要不使用

### 2.7 SERIAL序列


**SERIAL**是`BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE`的简写。

```sql
-- 等价写法
id SERIAL  -- 简写
-- 等同于
id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE KEY
```

**使用场景**：
- 快速创建自增主键
- 代码更简洁易读

---

## 3. 💰 小数类型详解


### 3.1 精确小数类型


#### DECIMAL定点数


**DECIMAL**是"精确小数"，不会有精度丢失问题，就像银行计算器一样精确。

```sql
-- 语法：DECIMAL(总位数, 小数位数)
price DECIMAL(10,2)  -- 最大99999999.99

-- 金钱计算（推荐）
account_balance DECIMAL(15,2)  -- 支持千万级金额

-- 百分比（保留4位小数）
interest_rate DECIMAL(6,4)  -- 如99.9999%
```

**同义词家族**：
- `DEC` = `DECIMAL`
- `NUMERIC` = `DECIMAL`  
- `FIXED` = `DECIMAL`

**💡 记忆方法**：DECIMAL = "绝对精确"，金钱计算首选！

#### 使用示例对比

```sql
-- ✅ 正确：财务数据用DECIMAL
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    total_amount DECIMAL(10,2),  -- 精确到分
    tax_rate DECIMAL(5,4)        -- 税率保留4位小数
);

-- ❌ 错误：金钱用浮点数会有精度问题
price FLOAT  -- 可能出现 9.99 变成 9.989999
```

### 3.2 近似小数类型


#### FLOAT浮点数


**FLOAT**是"单精度浮点数"，占4个字节，适合科学计算但不适合金钱。

```sql
-- 科学测量数据
temperature FLOAT        -- 温度值
gps_latitude FLOAT      -- GPS纬度
cpu_usage FLOAT         -- CPU使用率（百分比）
```

**特点**：
- 存储空间小（4字节）
- 计算速度快
- 有精度误差（约7位有效数字）

#### DOUBLE双精度 和 REAL实数


**DOUBLE**是"双精度浮点数"，**REAL**在MySQL中等同于DOUBLE。

```sql
-- 高精度科学计算
calculation_result DOUBLE

-- 统计分析数据
average_score REAL      -- REAL等同于DOUBLE
```

**DOUBLE vs FLOAT对比**：

| 特性 | **FLOAT** | **DOUBLE** |
|------|-----------|------------|
| 存储空间 | 4字节 | 8字节 |
| 有效数字 | 约7位 | 约15位 |
| 精度 | 单精度 | 双精度 |
| 使用场景 | 一般科学计算 | 高精度计算 |

### 3.3 小数类型选择指南


```
选择决策树：

存储小数
├── 需要绝对精确？
│   ├── 是 → DECIMAL（金钱、财务）
│   └── 否 → 继续判断
├── 存储空间重要？
│   ├── 是 → FLOAT（一般计算）
│   └── 否 → DOUBLE（高精度计算）
```

---

## 4. 🔘 位和布尔类型


### 4.1 BIT位类型


**BIT类型**用来存储位值，就像开关一样，可以是0或1。

```sql
-- 语法：BIT(位数)
user_permissions BIT(8)   -- 8位权限标志
is_vip BIT(1)            -- 单个标志位

-- 设置位值
INSERT INTO users (user_permissions) VALUES (b'10110001');
-- 或者用十进制
INSERT INTO users (user_permissions) VALUES (177);
```

**实际应用场景**：
```sql
-- 权限系统（每位代表一种权限）
CREATE TABLE user_roles (
    user_id INT,
    permissions BIT(8)  -- 8种权限开关
    -- 位7:管理员 位6:编辑 位5:删除 位4:写入 位3:读取...
);
```

### 4.2 布尔类型家族


#### BOOLEAN和BOOL布尔型


**BOOLEAN**和**BOOL**是完全相同的，在MySQL中实际上是`TINYINT(1)`的别名。

```sql
-- 这三种写法完全等价
is_active BOOLEAN
is_active BOOL  
is_active TINYINT(1)

-- 使用示例
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOL DEFAULT FALSE
);

-- 插入数据
INSERT INTO users (is_active, is_verified) VALUES (TRUE, FALSE);
INSERT INTO users (is_active, is_verified) VALUES (1, 0);  -- 等价写法
```

**布尔值的表示**：

| 输入值 | **存储值** | **含义** |
|-------|-----------|---------|
| `TRUE`, `1` | 1 | 真 |
| `FALSE`, `0` | 0 | 假 |

**💡 使用建议**：
- 虽然`BOOLEAN`和`TINYINT(1)`相同，但用`BOOLEAN`更语义化
- 字段命名建议用`is_`、`has_`、`can_`开头

---

## 5. 📝 字符串类型详解


### 5.1 固定长度字符串


#### CHAR定长字符


**CHAR**是"定长字符串"，就像固定格式的表格，不管实际内容多少，都占用固定空间。

```sql
-- 语法：CHAR(长度)，最大255字符
country_code CHAR(2)     -- 国家代码：CN, US, JP
gender CHAR(1)           -- 性别：M, F
phone_number CHAR(11)    -- 手机号码（固定11位）
```

**CHAR的特点**：
```
存储示例：CHAR(10)
输入 "Hello"     → 存储 "Hello     "（后面补5个空格）
输入 "MySQL"     → 存储 "MySQL     "（后面补5个空格）
输入 "Programming" → 报错（超过10字符限制）
```

**适用场景**：
- 长度固定的数据（身份证号、邮编、国家代码）
- 查询性能要求高的短字符串
- 需要填充对齐的场景

### 5.2 变长字符串


#### VARCHAR变长字符


**VARCHAR**是"变长字符串"，就像伸缩袋，根据实际内容调整占用空间。

```sql
-- 语法：VARCHAR(最大长度)
username VARCHAR(50)      -- 用户名，最长50字符
email VARCHAR(100)        -- 邮箱地址
product_name VARCHAR(255) -- 商品名称
```

**VARCHAR的特点**：
```
存储示例：VARCHAR(10)
输入 "Hello"   → 存储 "Hello"（只占用5字符+长度信息）
输入 "MySQL"   → 存储 "MySQL"（只占用5字符+长度信息）
输入 "Hi"      → 存储 "Hi"（只占用2字符+长度信息）
```

**CHAR vs VARCHAR对比**：

| 特性 | **CHAR** | **VARCHAR** |
|------|----------|-------------|
| 存储方式 | 固定长度 | 变长存储 |
| 空间利用 | 可能浪费空间 | 节省空间 |
| 查询性能 | 更快 | 稍慢 |
| 适用场景 | 长度固定 | 长度变化 |

### 5.3 文本类型家族


#### TEXT文本类型详解


文本类型就像不同大小的书籍，用来存储大量文字内容：

```
文本类型大小对比：
TINYTEXT   → 便签纸（255字符）
TEXT       → 普通文章（65,535字符）
MEDIUMTEXT → 长篇小说（16,777,215字符）
LONGTEXT   → 百科全书（4,294,967,295字符）
```

#### TINYTEXT微文本

```sql
-- 适合短评论、标签
product_tags TINYTEXT     -- 商品标签
short_comment TINYTEXT    -- 短评论
```

#### TEXT文本

```sql
-- 适合文章内容、产品描述
article_content TEXT      -- 文章正文
product_description TEXT  -- 产品详情
user_bio TEXT            -- 用户简介
```

#### MEDIUMTEXT中文本

```sql
-- 适合长文档、详细日志
system_log MEDIUMTEXT     -- 系统日志
legal_document MEDIUMTEXT -- 法律文档
```

#### LONGTEXT长文本

```sql
-- 适合超大文档、完整备份
database_backup LONGTEXT  -- 数据备份
complete_novel LONGTEXT   -- 完整小说
```

**💡 选择建议**：
- 一般文章内容：用`TEXT`
- 短评论、标签：用`TINYTEXT`
- 超大文档：用`LONGTEXT`
- 按实际需求选择，避免过度设计

---

## 6. 💾 二进制数据类型


### 6.1 二进制字符串


#### BINARY二进制字符串


**BINARY**是固定长度的二进制数据，类似CHAR但存储的是字节而不是字符。

```sql
-- 存储固定长度的二进制数据
password_hash BINARY(32)  -- MD5哈希值（32字节）
uuid_field BINARY(16)     -- UUID二进制格式
```

#### VARBINARY变长二进制


**VARBINARY**是变长二进制数据，类似VARCHAR但针对二进制。

```sql
-- 存储变长二进制数据  
encrypted_data VARBINARY(1000)  -- 加密数据
token VARBINARY(255)            -- 访问令牌
```

### 6.2 BLOB二进制大对象家族


BLOB类型用来存储二进制大数据，就像不同大小的保险箱：

```
BLOB家族存储能力：
TINYBLOB   → 小盒子（255字节）
BLOB       → 普通盒子（65KB）
MEDIUMBLOB → 大盒子（16MB）
LONGBLOB   → 超大盒子（4GB）
```

#### TINYBLOB微二进制

```sql
-- 小图标、缩略图
small_icon TINYBLOB      -- 小图标文件
thumbnail TINYBLOB       -- 缩略图
```

#### BLOB二进制

```sql
-- 普通图片、小文件
profile_picture BLOB     -- 头像图片
document_file BLOB       -- 小文档文件
```

#### MEDIUMBLOB中二进制

```sql
-- 较大图片、音频文件
high_res_image MEDIUMBLOB  -- 高分辨率图片
audio_file MEDIUMBLOB      -- 音频文件
```

#### LONGBLOB长二进制

```sql
-- 视频文件、大型文档
video_content LONGBLOB     -- 视频文件
backup_data LONGBLOB       -- 备份数据
```

**⚠️ 使用建议**：
- 尽量避免在数据库中存储大文件
- 推荐存储文件路径，文件放在文件系统中
- 如必须存储，选择合适大小的BLOB类型

---

## 7. ⏰ 日期时间类型


### 7.1 日期时间家族概览


```
日期时间类型用途：
DATE      → 只要日期：2024-03-15
TIME      → 只要时间：14:30:25
DATETIME  → 日期+时间：2024-03-15 14:30:25
TIMESTAMP → 时间戳：自动更新的日期时间
YEAR      → 只要年份：2024
```

### 7.2 DATE日期


**DATE**只存储日期，不包含时间信息。

```sql
-- 存储生日、注册日期等
birth_date DATE          -- 出生日期
registration_date DATE   -- 注册日期
event_date DATE         -- 事件日期

-- 插入示例
INSERT INTO users (birth_date) VALUES ('1990-05-15');
INSERT INTO events (event_date) VALUES (CURDATE());  -- 当前日期
```

**日期范围**：1000-01-01 到 9999-12-31

### 7.3 TIME时间


**TIME**只存储时间，不包含日期信息。

```sql
-- 存储营业时间、课程时长等
opening_time TIME        -- 营业时间：09:00:00
closing_time TIME        -- 关门时间：22:30:00
duration TIME           -- 持续时间

-- 插入示例
INSERT INTO stores (opening_time, closing_time) 
VALUES ('09:00:00', '22:30:00');
```

**时间范围**：-838:59:59 到 838:59:59（可以表示负时间和超过24小时）

### 7.4 DATETIME日期时间


**DATETIME**存储完整的日期和时间信息，是最常用的时间类型。

```sql
-- 存储创建时间、最后登录等
created_at DATETIME      -- 创建时间
updated_at DATETIME      -- 更新时间
last_login DATETIME      -- 最后登录

-- 插入示例
INSERT INTO posts (title, created_at) 
VALUES ('MySQL学习', '2024-03-15 14:30:25');

INSERT INTO users (last_login) 
VALUES (NOW());  -- 当前日期时间
```

**日期时间范围**：1000-01-01 00:00:00 到 9999-12-31 23:59:59

### 7.5 TIMESTAMP时间戳


**TIMESTAMP**是特殊的时间类型，有自动更新功能。

```sql
-- 自动设置创建时间和更新时间
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**TIMESTAMP特殊功能**：
- 自动设置当前时间
- 记录更新时自动更新
- 受时区影响（DATETIME不受时区影响）

**DATETIME vs TIMESTAMP对比**：

| 特性 | **DATETIME** | **TIMESTAMP** |
|------|--------------|---------------|
| 存储空间 | 8字节 | 4字节 |
| 时间范围 | 1000年-9999年 | 1970年-2038年 |
| 时区处理 | 不受时区影响 | 受时区影响 |
| 自动更新 | 不支持 | 支持 |

### 7.6 YEAR年份


**YEAR**只存储年份信息，占用1个字节。

```sql
-- 存储毕业年份、生产年份等
graduation_year YEAR     -- 毕业年份
production_year YEAR     -- 生产年份

-- 插入示例
INSERT INTO graduates (name, graduation_year) 
VALUES ('张三', 2024);
```

**年份范围**：1901-2155

---

## 8. 📄 JSON数据类型


### 8.1 JSON类型概述


**JSON类型**是MySQL 5.7引入的原生JSON数据类型，可以存储和查询JSON格式的数据。

```sql
-- 存储用户配置、商品属性等
user_settings JSON       -- 用户个性化设置
product_specs JSON       -- 商品规格参数
log_data JSON           -- 日志数据
```

### 8.2 JSON使用示例


```sql
-- 创建表
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    profile JSON
);

-- 插入JSON数据
INSERT INTO users (name, profile) VALUES 
('张三', '{"age": 25, "city": "北京", "hobbies": ["读书", "游泳"]}'),
('李四', '{"age": 30, "city": "上海", "married": true}');

-- 查询JSON数据
SELECT name, profile->'$.age' as age FROM users;
SELECT name FROM users WHERE profile->'$.city' = '北京';
```

### 8.3 JSON的优势


**相比存储JSON字符串的优势**：
- ✅ **自动验证**：插入时自动验证JSON格式
- ✅ **高效查询**：支持索引和专门的查询函数
- ✅ **节省空间**：二进制存储更紧凑
- ✅ **数据完整性**：确保JSON格式正确

**适用场景**：
- 用户个性化配置
- 商品的动态属性
- 日志和监控数据
- 灵活的扩展字段

---

## 9. 🗺️ 几何数据类型


### 9.1 几何类型概述


MySQL支持多种几何数据类型，用于存储地理信息和空间数据：

```
几何类型层次：
GEOMETRY        ← 基础几何类型（所有几何类型的父类）
├── POINT       ← 点（经纬度坐标）
├── LINESTRING  ← 线串（路线、边界线）
├── POLYGON     ← 多边形（区域、行政区划）
├── MULTIPOINT  ← 多点集合
├── MULTILINESTRING ← 多线串集合
├── MULTIPOLYGON ← 多多边形集合
└── GEOMETRYCOLLECTION ← 几何集合
```

### 9.2 基础几何类型


#### POINT点类型


**POINT**存储一个点的坐标，最常用于存储位置信息。

```sql
-- 存储商店位置、用户位置
store_location POINT     -- 商店坐标
user_location POINT      -- 用户位置

-- 插入点数据（经度, 纬度）
INSERT INTO stores (name, store_location) 
VALUES ('北京店', POINT(116.4074, 39.9042));  -- 北京天安门坐标
```

#### LINESTRING线串类型


**LINESTRING**存储一系列连接的点，形成线段或路径。

```sql
-- 存储配送路线、行政边界
delivery_route LINESTRING    -- 配送路线
city_boundary LINESTRING     -- 城市边界

-- 插入线串数据
INSERT INTO routes (name, delivery_route) 
VALUES ('配送路线1', LINESTRING(POINT(116.4074, 39.9042), POINT(116.4075, 39.9043)));
```

#### POLYGON多边形类型


**POLYGON**存储多边形区域，如行政区划、服务范围等。

```sql
-- 存储服务区域、行政区划
service_area POLYGON         -- 服务覆盖区域
district_boundary POLYGON    -- 行政区边界
```

### 9.3 复合几何类型


#### MULTIPOINT多点类型

```sql
-- 存储连锁店的所有门店位置
chain_locations MULTIPOINT
```

#### MULTILINESTRING多线串

```sql
-- 存储复杂的交通网络
transport_network MULTILINESTRING
```

#### MULTIPOLYGON多多边形

```sql
-- 存储不连续的管辖区域
jurisdiction_areas MULTIPOLYGON
```

#### GEOMETRYCOLLECTION几何集合

```sql
-- 存储混合的几何对象
mixed_geometries GEOMETRYCOLLECTION
```

### 9.4 几何类型的实际应用


```sql
-- 地图应用示例
CREATE TABLE locations (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    location POINT,              -- 具体位置
    service_area POLYGON,        -- 服务范围
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 查找附近的位置（需要空间索引）
SELECT name FROM locations 
WHERE ST_Distance(location, POINT(116.4074, 39.9042)) < 1000;  -- 1公里内
```

**⚠️ 使用注意**：
- 需要创建空间索引来提升查询性能
- 坐标系统要保持一致
- 适合GIS系统和位置服务

---

## 10. 🏷️ 枚举和集合类型


### 10.1 ENUM枚举类型


**ENUM**就像多选一的选择题，只能从预定义的选项中选择一个值。

```sql
-- 语法：ENUM('选项1', '选项2', '选项3', ...)
gender ENUM('男', '女', '未知') DEFAULT '未知'
status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending'
priority ENUM('low', 'medium', 'high') DEFAULT 'medium'
```

**ENUM的实际应用**：
```sql
-- 用户表示例
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    gender ENUM('male', 'female', 'other') DEFAULT 'other',
    status ENUM('active', 'inactive', 'suspended') DEFAULT 'active'
);

-- 插入数据
INSERT INTO users (username, gender, status) VALUES 
('张三', 'male', 'active'),
('李四', 'female', 'inactive');

-- 查询特定状态的用户
SELECT * FROM users WHERE status = 'active';
```

**ENUM的优势**：
- ✅ **节省空间**：内部用数字存储（1,2,3...）
- ✅ **数据完整性**：只能插入预定义的值
- ✅ **查询高效**：MySQL优化查询性能
- ✅ **代码可读性**：意义明确

### 10.2 SET集合类型


**SET**就像多选题，可以从预定义选项中选择多个值。

```sql
-- 语法：SET('选项1', '选项2', '选项3', ...)
hobbies SET('读书', '游泳', '跑步', '音乐', '电影')
permissions SET('read', 'write', 'delete', 'admin')
features SET('wifi', 'parking', 'elevator', 'gym')
```

**SET的实际应用**：
```sql
-- 商品特性表
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    features SET('new', 'hot', 'discount', 'recommended', 'limited')
);

-- 插入数据（可以选择多个特性）
INSERT INTO products (name, features) VALUES 
('笔记本电脑', 'new,hot,recommended'),
('手机', 'hot,discount'),
('耳机', 'new,limited');

-- 查询包含特定特性的商品
SELECT * FROM products WHERE FIND_IN_SET('hot', features);
SELECT * FROM products WHERE features LIKE '%new%';
```

### 10.3 ENUM vs SET 选择指南


```
使用决策：

需要存储选项
├── 只能选一个？
│   ├── 是 → ENUM（单选）
│   │   └── 例：性别、状态、优先级
│   └── 否 → SET（多选）
│       └── 例：兴趣爱好、权限、特性标签
```

**对比总结**：

| 特性 | **ENUM** | **SET** |
|------|----------|---------|
| 选择方式 | 单选（选择一个） | 多选（选择多个） |
| 存储方式 | 数字索引 | 位掩码 |
| 最大选项 | 65,535个 | 64个 |
| 典型应用 | 状态、类型、等级 | 标签、权限、特性 |

**💡 使用建议**：
- 选项相对固定时使用ENUM/SET
- 需要经常增删选项时，考虑用关联表
- 注意选项的顺序，后续修改可能影响已存储的数据

---

## 11. 🎯 数据类型选择指南


### 11.1 性能优化考虑


**存储空间对比表**：

| 数据类型 | **存储空间** | **适用数值范围** | **推荐场景** |
|---------|------------|----------------|-------------|
| `TINYINT` | 1字节 | -128~127 | 状态码、年龄 |
| `SMALLINT` | 2字节 | -32K~32K | 库存、端口号 |
| `INT` | 4字节 | -21亿~21亿 | 用户ID、订单数 |
| `BIGINT` | 8字节 | 超大数值 | 全局ID、金额(分) |
| `DECIMAL(10,2)` | 5字节 | 精确小数 | 金钱、价格 |
| `FLOAT` | 4字节 | 近似小数 | 科学计算 |
| `DOUBLE` | 8字节 | 高精度近似 | 复杂计算 |

### 11.2 常见业务场景的类型选择


**用户系统**：
```sql
CREATE TABLE users (
    user_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,     -- 用户ID
    username VARCHAR(50) NOT NULL,                       -- 用户名
    email VARCHAR(100) UNIQUE,                           -- 邮箱
    age TINYINT UNSIGNED,                                -- 年龄
    gender ENUM('male', 'female', 'other'),              -- 性别
    balance DECIMAL(10,2) DEFAULT 0.00,                  -- 余额
    is_active BOOLEAN DEFAULT TRUE,                      -- 激活状态
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,      -- 创建时间
    profile JSON                                         -- 扩展信息
);
```

**商品系统**：
```sql
CREATE TABLE products (
    product_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 商品ID
    name VARCHAR(255) NOT NULL,                          -- 商品名称
    price DECIMAL(8,2) NOT NULL,                         -- 价格
    stock SMALLINT UNSIGNED DEFAULT 0,                   -- 库存
    category ENUM('electronics', 'clothing', 'books'),   -- 分类
    features SET('new', 'hot', 'discount'),              -- 特性标签
    description TEXT,                                     -- 描述
    images JSON,                                          -- 图片链接
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP        -- 创建时间
);
```

### 11.3 数据类型选择决策树


```
选择数据类型决策流程：

开始选择类型
├── 存储数字？
│   ├── 整数 → 按范围选择TINYINT/SMALLINT/INT/BIGINT
│   └── 小数 → 精确用DECIMAL，近似用FLOAT/DOUBLE
├── 存储文字？
│   ├── 长度固定 → CHAR
│   ├── 长度变化 → VARCHAR
│   └── 大量文本 → TEXT系列
├── 存储时间？
│   ├── 只要日期 → DATE
│   ├── 只要时间 → TIME
│   ├── 需要时区 → TIMESTAMP
│   └── 完整时间 → DATETIME
├── 存储选项？
│   ├── 单选 → ENUM
│   └── 多选 → SET
├── 存储二进制？
│   └── BLOB系列或BINARY
├── 存储JSON？
│   └── JSON类型
└── 存储地理位置？
    └── GEOMETRY系列
```

### 11.4 性能优化建议


**索引友好的类型选择**：
```sql
-- ✅ 好的选择：整数类型索引效率高
user_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY

-- ✅ 好的选择：适当长度的VARCHAR
username VARCHAR(50) NOT NULL

-- ❌ 避免：过长的VARCHAR影响索引性能
description VARCHAR(5000)  -- 改为TEXT类型

-- ❌ 避免：TEXT/BLOB类型不适合做主键
PRIMARY KEY (description TEXT)  -- 错误用法
```

**存储空间优化**：
```sql
-- 原则：够用就好，不要过度设计

-- ✅ 合理：年龄用TINYINT
age TINYINT UNSIGNED  -- 0-255足够

-- ❌ 浪费：年龄用INT
age INT  -- 浪费3个字节

-- ✅ 合理：状态用ENUM
status ENUM('pending', 'approved', 'rejected')

-- ❌ 浪费：状态用VARCHAR
status VARCHAR(20)  -- 占用更多空间
```

---

## 12. 📋 核心要点总结


### 12.1 必须掌握的核心概念


```
🔸 数据类型本质：告诉MySQL如何存储和处理数据
🔸 存储优化原则：选择合适大小，避免浪费空间
🔸 精度问题：金钱用DECIMAL，科学计算用FLOAT/DOUBLE
🔸 字符串选择：固定长度用CHAR，变长用VARCHAR，大文本用TEXT
🔸 时间处理：根据需求选择DATE/TIME/DATETIME/TIMESTAMP
🔸 特殊类型：ENUM单选、SET多选、JSON存储结构化数据
```

### 12.2 关键理解要点


**🔹 整数类型的选择逻辑**
```
存储范围递增：
TINYINT(1字节) → SMALLINT(2字节) → MEDIUMINT(3字节) → INT(4字节) → BIGINT(8字节)

选择原则：
- 够用就好，不要过度设计
- INT是最常用的，性能最佳
- BIGINT适合超大数值
```

**🔹 小数类型的关键区别**
```
精确 vs 近似：
DECIMAL → 绝对精确，金钱计算首选
FLOAT/DOUBLE → 近似值，科学计算使用

记忆要点：
- 钱的问题用DECIMAL
- 科学计算用FLOAT/DOUBLE
- 精度要求高用DOUBLE而不是FLOAT
```

**🔹 字符串类型的使用场景**
```
长度特征：
CHAR → 固定长度，补空格，查询快
VARCHAR → 变长存储，节省空间
TEXT → 大文本，不能设默认值

选择原则：
- 长度固定（如国家代码）→ CHAR
- 长度变化（如用户名）→ VARCHAR  
- 大量文字（如文章）→ TEXT
```

### 12.3 实际应用最佳实践


**数据库设计建议**：
- 🎯 **主键选择**：一般用`INT UNSIGNED AUTO_INCREMENT`
- 🎯 **金钱字段**：必须用`DECIMAL`，以分为单位存储
- 🎯 **状态字段**：优先使用`ENUM`而不是`VARCHAR`
- 🎯 **时间字段**：创建时间用`TIMESTAMP`，业务时间用`DATETIME`
- 🎯 **布尔字段**：用`BOOLEAN`而不是`TINYINT`（语义更清晰）
- 🎯 **扩展字段**：考虑使用`JSON`类型存储灵活数据

**性能优化要点**：
- 选择最小满足需求的数据类型
- 避免在TEXT/BLOB字段上建索引
- 字符串长度设置要合理，不要过长
- 经常查询的字段选择索引友好的类型

**常见错误避免**：
- ❌ 金钱用FLOAT存储（精度丢失）
- ❌ 所有整数都用INT（空间浪费）
- ❌ 所有字符串都用VARCHAR(255)（设计懒惰）
- ❌ 不考虑NULL值处理
- ❌ 忽视字符集和排序规则的影响

**记忆口诀**：
```
整数看范围，够用就最好
小数分精确，金钱DECIMAL保
字符看长度，固定CHAR变VARCHAR
时间有四种，按需选择很重要
枚举单选项，集合可多标
JSON存结构，几何存坐标
```