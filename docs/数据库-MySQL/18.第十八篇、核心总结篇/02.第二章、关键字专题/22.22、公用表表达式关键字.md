---
title: 22、公用表表达式关键字
---
## 📚 目录

1. [公用表表达式基础概念](#1-公用表表达式基础概念)
2. [WITH关键字详解](#2-WITH关键字详解)
3. [RECURSIVE递归机制](#3-RECURSIVE递归机制)
4. [实际应用场景](#4-实际应用场景)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 📊 公用表表达式基础概念


### 1.1 什么是公用表表达式(CTE)


**🔸 核心定义**
```
CTE (Common Table Expression) - 公用表表达式
本质：一个临时的"虚拟表"，只在当前查询中存在
作用：让复杂查询变得更清晰、更容易理解和维护
```

**💡 生活类比理解**
```
想象你在做菜：
传统方式：把所有食材混在一起直接炒 (复杂的嵌套查询)
CTE方式：先把食材分类准备好，再按步骤烹饪 (分步骤的清晰查询)

就像做菜前的"备菜"步骤，CTE让你先准备好"半成品数据"
然后在主查询中使用这些准备好的数据
```

### 1.2 CTE解决什么问题


**🎯 核心问题**
```
问题1：复杂的嵌套子查询难以理解
传统写法：
SELECT * FROM (
  SELECT * FROM (
    SELECT name, salary FROM employees WHERE dept = 'IT'
  ) t1 WHERE salary > 5000
) t2;

CTE写法：
WITH it_employees AS (
  SELECT name, salary FROM employees WHERE dept = 'IT'
),
high_salary AS (
  SELECT * FROM it_employees WHERE salary > 5000  
)
SELECT * FROM high_salary;
```

**✅ CTE的优势**
- **可读性强**：像阅读文章一样自上而下理解查询逻辑
- **可维护性好**：修改某个步骤不影响其他部分
- **可重用性**：同一个CTE可以在查询中多次使用
- **调试方便**：可以单独测试每个CTE的结果

### 1.3 CTE的基本语法结构


**📋 语法模板**
```sql
WITH cte_name AS (
    -- CTE的查询定义
    SELECT column1, column2 
    FROM table_name 
    WHERE conditions
)
-- 主查询，可以使用上面定义的CTE
SELECT * FROM cte_name;
```

**🔧 实际示例**
```sql
-- 示例：查找销售额前10的销售员及其详细信息
WITH top_salesmen AS (
    -- 先找出销售额前10的销售员
    SELECT salesman_id, SUM(amount) as total_sales
    FROM orders 
    GROUP BY salesman_id
    ORDER BY total_sales DESC
    LIMIT 10
)
-- 然后获取这些销售员的详细信息
SELECT e.name, e.department, ts.total_sales
FROM employees e
JOIN top_salesmen ts ON e.id = ts.salesman_id;
```

---

## 2. 🔑 WITH关键字详解


### 2.1 WITH关键字的含义和作用


**🔸 WITH关键字本质**
```
WITH = "伴随着"、"带着"的意思
SQL语义：伴随着这些临时表定义，执行后面的主查询
```

**💭 理解角度**
```
可以把WITH理解为：
"带着这些准备好的数据表，我要执行下面的查询"

就像说话时的铺垫：
"带着刚才讨论的那些前提条件，我们来看这个问题..."
```

### 2.2 WITH的基本用法


#### 🔧 单个CTE定义


```sql
-- 语法：WITH + CTE名称 + AS + (查询定义)
WITH department_stats AS (
    SELECT 
        department,
        COUNT(*) as emp_count,
        AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
)
SELECT * FROM department_stats 
WHERE avg_salary > 50000;
```

**🎯 关键理解点**
- `WITH`告诉数据库："我要定义一个临时表"
- `department_stats`是我给这个临时表起的名字
- `AS`后面的括号内容定义了这个临时表的数据来源
- 主查询可以像使用普通表一样使用这个CTE

#### 🔗 多个CTE定义


```sql
-- 可以用逗号连接多个CTE定义
WITH 
sales_summary AS (
    SELECT 
        product_id, 
        SUM(quantity) as total_sold,
        SUM(amount) as total_revenue
    FROM orders 
    GROUP BY product_id
),
product_categories AS (
    SELECT 
        p.id,
        p.name,
        p.category,
        p.price
    FROM products p
    WHERE p.status = 'active'
)
-- 主查询可以使用多个CTE
SELECT 
    pc.name,
    pc.category,
    ss.total_sold,
    ss.total_revenue
FROM product_categories pc
LEFT JOIN sales_summary ss ON pc.id = ss.product_id;
```

### 2.3 WITH的使用规则和限制


**📋 重要规则**

> **💡 提示**：CTE必须紧跟在主查询之前定义

```sql
-- ✅ 正确用法
WITH my_cte AS (SELECT ...)
SELECT * FROM my_cte;

-- ❌ 错误用法：不能在其他地方单独使用CTE
WITH my_cte AS (SELECT ...);
-- 这里没有主查询，会报错
```

> **⚠️ 注意**：CTE只在当前查询语句中有效

```sql
-- CTE的作用域仅限于当前查询
WITH temp_data AS (SELECT id, name FROM users)
SELECT * FROM temp_data;  -- 有效

-- 下一个查询无法使用上面的CTE
SELECT * FROM temp_data;  -- 报错：表不存在
```

### 2.4 WITH vs 子查询对比


**📊 对比分析**

| 特性 | **WITH (CTE)** | **子查询 (Subquery)** |
|------|----------------|----------------------|
| **可读性** | `极好，自上而下阅读` | `较差，嵌套层次深` |
| **维护性** | `很好，模块化结构` | `困难，牵一发动全身` |
| **重用性** | `支持，可多次引用` | `不支持，需重复编写` |
| **性能** | `通常相同，优化器处理` | `通常相同` |
| **调试** | `容易，可单独测试` | `困难，难以分步调试` |

**🔧 实际对比示例**

```sql
-- 使用子查询的复杂写法
SELECT 
    e.name,
    dept_avg.avg_salary,
    e.salary - dept_avg.avg_salary as salary_diff
FROM employees e
JOIN (
    SELECT 
        department,
        AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
) dept_avg ON e.department = dept_avg.department
WHERE e.salary > (
    SELECT AVG(salary) * 1.2 
    FROM employees 
    WHERE department = e.department
);

-- 使用CTE的清晰写法
WITH 
department_averages AS (
    SELECT 
        department,
        AVG(salary) as avg_salary
    FROM employees
    GROUP BY department
),
high_performers AS (
    SELECT 
        e.*,
        da.avg_salary,
        e.salary - da.avg_salary as salary_diff
    FROM employees e
    JOIN department_averages da ON e.department = da.department
    WHERE e.salary > da.avg_salary * 1.2
)
SELECT 
    name,
    avg_salary,
    salary_diff
FROM high_performers;
```

---

## 3. 🔄 RECURSIVE递归机制


### 3.1 什么是递归CTE


**🔸 RECURSIVE关键字含义**
```
RECURSIVE = 递归的，自己调用自己的
在CTE中：允许查询结果引用自身，实现递归操作
```

**🌳 生活类比理解**
```
递归就像家族族谱：
- 从祖先开始
- 找到祖先的子女
- 再找子女的子女
- 一直找下去，直到没有后代

递归CTE的工作方式：
1. 设定起始点（祖先）
2. 基于上一步结果找下一层（子女）
3. 重复第2步，直到没有新结果
```

### 3.2 递归CTE的语法结构


**📋 递归CTE模板**
```sql
WITH RECURSIVE cte_name AS (
    -- 基础部分（锚点查询）：递归的起始点
    SELECT initial_columns
    FROM initial_table
    WHERE base_conditions
    
    UNION ALL
    
    -- 递归部分：引用自身的查询
    SELECT recursive_columns
    FROM some_table
    JOIN cte_name ON join_conditions  -- 引用自身
    WHERE recursive_conditions
)
SELECT * FROM cte_name;
```

**🔧 核心组成部分**
```
1. RECURSIVE关键字：告诉数据库这是递归CTE
2. 基础部分：递归的起始数据（第一层）
3. UNION ALL：连接基础部分和递归部分
4. 递归部分：引用CTE自身的查询（后续层）
```

### 3.3 递归CTE工作原理


**⚡ 执行步骤详解**

```
执行过程（以组织架构为例）：

第1轮：执行基础部分
- 找到所有CEO（顶层管理者）
- 结果：[CEO]

第2轮：执行递归部分  
- 基于第1轮结果找直接下属
- 结果：[CEO, VP1, VP2, VP3]

第3轮：继续递归
- 基于第2轮新增的VP找他们的下属
- 结果：[CEO, VP1, VP2, VP3, Manager1, Manager2, ...]

...重复直到没有新结果
```

### 3.4 递归CTE实际应用


#### 🏢 组织架构查询


```sql
-- 查询某个员工的所有下属（包括间接下属）
WITH RECURSIVE employee_hierarchy AS (
    -- 基础部分：找到指定的起始员工
    SELECT 
        id,
        name,
        manager_id,
        1 as level  -- 记录层级
    FROM employees 
    WHERE id = 100  -- 从员工ID=100开始
    
    UNION ALL
    
    -- 递归部分：找到每一层的直接下属
    SELECT 
        e.id,
        e.name,
        e.manager_id,
        eh.level + 1  -- 层级递增
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.id
)
SELECT 
    name,
    level,
    REPEAT('  ', level-1) || name as indented_name  -- 缩进显示层级
FROM employee_hierarchy
ORDER BY level, name;
```

**📋 执行结果示例**
```
name        level   indented_name
----------- ------- ---------------
张三         1       张三
  李四       2         李四
  王五       2         王五  
    赵六     3           赵六
    钱七     3           钱七
```

#### 🗂️ 分类树结构查询


```sql
-- 查询产品分类的完整树结构
WITH RECURSIVE category_tree AS (
    -- 基础部分：找到所有根分类（没有父分类的）
    SELECT 
        id,
        name,
        parent_id,
        name as full_path,  -- 完整路径
        0 as depth
    FROM categories 
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- 递归部分：逐层找子分类
    SELECT 
        c.id,
        c.name,
        c.parent_id,
        ct.full_path || ' > ' || c.name,  -- 构建完整路径
        ct.depth + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT 
    id,
    name,
    full_path,
    depth
FROM category_tree
ORDER BY full_path;
```

**📋 查询结果示例**
```
full_path                    depth
---------------------------- -----
电子产品                      0
电子产品 > 手机                1
电子产品 > 手机 > 苹果          2
电子产品 > 手机 > 华为          2
电子产品 > 电脑                1
服装                          0
服装 > 男装                    1
服装 > 女装                    1
```

### 3.5 递归深度控制


**⚠️ 防止无限递归**

> **注意**：递归CTE可能陷入无限循环，需要设置终止条件

```sql
-- 方法1：限制递归深度
WITH RECURSIVE hierarchy AS (
    SELECT id, name, manager_id, 0 as level
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN hierarchy h ON e.manager_id = h.id
    WHERE h.level < 10  -- 限制最多10层
)
SELECT * FROM hierarchy;

-- 方法2：检测环形引用
WITH RECURSIVE hierarchy AS (
    SELECT 
        id, name, manager_id, 
        ARRAY[id] as path  -- 记录访问路径
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT 
        e.id, e.name, e.manager_id,
        h.path || e.id
    FROM employees e
    JOIN hierarchy h ON e.manager_id = h.id
    WHERE e.id <> ALL(h.path)  -- 避免重复访问
)
SELECT * FROM hierarchy;
```

---

## 4. 🎯 实际应用场景


### 4.1 数据分析场景


#### 📊 销售数据分析


```sql
-- 多维度销售分析
WITH 
monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', order_date) as month,
        product_category,
        SUM(amount) as monthly_amount,
        COUNT(*) as order_count
    FROM orders 
    WHERE order_date >= '2024-01-01'
    GROUP BY DATE_TRUNC('month', order_date), product_category
),
category_totals AS (
    SELECT 
        product_category,
        SUM(monthly_amount) as total_amount,
        AVG(monthly_amount) as avg_monthly
    FROM monthly_sales
    GROUP BY product_category
),
top_categories AS (
    SELECT product_category
    FROM category_totals
    ORDER BY total_amount DESC
    LIMIT 5
)
-- 最终分析结果
SELECT 
    ms.month,
    ms.product_category,
    ms.monthly_amount,
    ct.avg_monthly,
    ROUND(ms.monthly_amount / ct.avg_monthly * 100, 2) as performance_ratio
FROM monthly_sales ms
JOIN category_totals ct ON ms.product_category = ct.product_category
WHERE ms.product_category IN (SELECT product_category FROM top_categories)
ORDER BY ms.month, ms.monthly_amount DESC;
```

#### 📈 同期对比分析


```sql
-- 年度同期对比
WITH 
current_year AS (
    SELECT 
        EXTRACT(month FROM order_date) as month,
        SUM(amount) as current_sales
    FROM orders 
    WHERE EXTRACT(year FROM order_date) = 2024
    GROUP BY EXTRACT(month FROM order_date)
),
previous_year AS (
    SELECT 
        EXTRACT(month FROM order_date) as month,
        SUM(amount) as previous_sales
    FROM orders 
    WHERE EXTRACT(year FROM order_date) = 2023
    GROUP BY EXTRACT(month FROM order_date)
)
SELECT 
    cy.month,
    cy.current_sales,
    py.previous_sales,
    cy.current_sales - py.previous_sales as sales_diff,
    ROUND((cy.current_sales - py.previous_sales) / py.previous_sales * 100, 2) as growth_rate
FROM current_year cy
LEFT JOIN previous_year py ON cy.month = py.month
ORDER BY cy.month;
```

### 4.2 层次数据处理


#### 🌳 评论回复系统


```sql
-- 获取文章的完整评论树
WITH RECURSIVE comment_tree AS (
    -- 基础：顶级评论
    SELECT 
        id,
        content,
        user_name,
        parent_id,
        article_id,
        created_at,
        0 as level,
        CAST(id AS VARCHAR) as sort_path
    FROM comments 
    WHERE article_id = 123 AND parent_id IS NULL
    
    UNION ALL
    
    -- 递归：回复评论
    SELECT 
        c.id,
        c.content,
        c.user_name,
        c.parent_id,
        c.article_id,
        c.created_at,
        ct.level + 1,
        ct.sort_path || '-' || CAST(c.id AS VARCHAR)
    FROM comments c
    JOIN comment_tree ct ON c.parent_id = ct.id
)
SELECT 
    id,
    REPEAT('  ', level) || content as indented_content,
    user_name,
    level,
    created_at
FROM comment_tree
ORDER BY sort_path;
```

#### 🗺️ 地理区域查询


```sql
-- 查询某个区域的所有子区域
WITH RECURSIVE region_hierarchy AS (
    -- 起点：指定省份
    SELECT 
        id, name, parent_id, 
        name as full_name,
        1 as level
    FROM regions 
    WHERE name = '广东省'
    
    UNION ALL
    
    -- 递归：市、区县、街道等
    SELECT 
        r.id, r.name, r.parent_id,
        rh.full_name || ' > ' || r.name,
        rh.level + 1
    FROM regions r
    JOIN region_hierarchy rh ON r.parent_id = rh.id
)
SELECT 
    level,
    COUNT(*) as region_count,
    STRING_AGG(name, ', ') as region_names
FROM region_hierarchy
GROUP BY level
ORDER BY level;
```

### 4.3 业务报表生成


#### 📋 多级汇总报表


```sql
-- 企业组织架构的销售业绩汇总
WITH RECURSIVE org_sales AS (
    -- 基础：部门经理层级
    SELECT 
        e.id as emp_id,
        e.name as emp_name,
        e.department,
        COALESCE(SUM(o.amount), 0) as direct_sales,
        0 as team_sales,  -- 将在后续计算
        1 as level
    FROM employees e
    LEFT JOIN orders o ON e.id = o.salesman_id
    WHERE e.position = 'Manager'
    GROUP BY e.id, e.name, e.department
    
    UNION ALL
    
    -- 递归：下属员工
    SELECT 
        e.id,
        e.name,
        e.department,
        COALESCE(SUM(o.amount), 0),
        0,
        os.level + 1
    FROM employees e
    LEFT JOIN orders o ON e.id = o.salesman_id
    JOIN org_sales os ON e.manager_id = os.emp_id
    GROUP BY e.id, e.name, e.department, os.level
),
-- 计算团队总销售额
team_totals AS (
    SELECT 
        department,
        SUM(direct_sales) as total_team_sales
    FROM org_sales
    GROUP BY department
)
SELECT 
    os.department,
    os.emp_name,
    os.direct_sales,
    tt.total_team_sales,
    ROUND(os.direct_sales / tt.total_team_sales * 100, 2) as contribution_rate
FROM org_sales os
JOIN team_totals tt ON os.department = tt.department
WHERE os.level = 1  -- 只显示经理级别的汇总
ORDER BY tt.total_team_sales DESC;
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 CTE本质：临时虚拟表，只在当前查询中存在
🔸 WITH关键字：引入CTE定义的标志，意为"伴随着"
🔸 RECURSIVE机制：允许查询引用自身，实现递归操作
🔸 执行顺序：先执行所有CTE定义，再执行主查询
🔸 作用域限制：CTE只在定义它的查询语句中有效
```

### 5.2 关键理解要点


**🔹 什么时候使用CTE**
```
✅ 适用场景：
- 复杂查询需要分步骤处理
- 同一子查询需要多次使用
- 需要递归处理层次数据
- 希望提高代码可读性和维护性

❌ 不适用场景：
- 简单的单表查询
- 性能要求极高且子查询很简单
- 需要跨多个查询语句重用（应考虑视图或表变量）
```

**🔹 递归CTE的关键点**
```
核心组成：
1. 基础部分（起始条件）
2. UNION ALL连接  
3. 递归部分（自引用）
4. 终止条件（防止无限循环）

常见应用：
- 组织架构遍历
- 分类树展示
- 路径查找
- 层次数据统计
```

### 5.3 实际应用价值


**🎯 业务价值**
- **提高开发效率**：复杂查询拆分成易理解的步骤
- **降低维护成本**：模块化查询便于修改和调试
- **增强代码复用**：同一CTE可在查询中多次引用
- **处理层次数据**：递归CTE是处理树形结构的利器

**🔧 技术优势**
- **可读性**：自上而下的逻辑流程清晰
- **调试性**：可以独立测试每个CTE的结果  
- **性能**：现代数据库优化器能很好地处理CTE
- **标准化**：SQL标准语法，跨数据库兼容性好

### 5.4 学习建议


**📚 学习路径**
```
1. 掌握基础WITH语法和简单CTE
2. 理解CTE与子查询的区别和优势
3. 学习多CTE组合使用
4. 掌握递归CTE的原理和应用
5. 在实际项目中多实践复杂场景
```

**🧠 记忆要点**
```
CTE记忆口诀：
WITH定义临时表，递归自己调自己
分步查询更清晰，复杂逻辑不费力
层次数据找根源，递归展开见全貌
```

**核心记忆**：
- CTE是SQL查询的"预处理步骤"，让复杂查询变简单
- WITH关键字引入临时表定义，提高查询可读性
- RECURSIVE实现自引用，专门处理层次结构数据
- 掌握CTE能显著提升SQL编写和维护效率