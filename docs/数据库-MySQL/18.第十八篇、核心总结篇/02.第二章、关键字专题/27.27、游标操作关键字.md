---
title: 27、游标操作关键字
---
## 📚 目录

1. [游标基础概念](#1-游标基础概念)
2. [CURSOR游标声明](#2-CURSOR游标声明)
3. [OPEN打开游标](#3-OPEN打开游标)
4. [FETCH获取数据](#4-FETCH获取数据)
5. [CLOSE关闭游标](#5-CLOSE关闭游标)
6. [FOUND找到数据状态](#6-FOUND找到数据状态)
7. [NOTFOUND未找到数据状态](#7-NOTFOUND未找到数据状态)
8. [SQLSTATE SQL状态码](#8-SQLSTATE-SQL状态码)
9. [SQLWARNING SQL警告处理](#9-SQLWARNING-SQL警告处理)
10. [SQLEXCEPTION SQL异常处理](#10-SQLEXCEPTION-SQL异常处理)
11. [游标操作完整流程](#11-游标操作完整流程)
12. [核心要点总结](#12-核心要点总结)

---

## 1. 🎯 游标基础概念


### 1.1 什么是游标


**🔸 通俗理解**
```
游标就像是数据库结果集的"指针"或"书签"

类比理解：
书本阅读 ──────────→ 数据库查询
    │                     │
书签指向当前页 ──────→ 游标指向当前行
    │                     │
翻页读取内容 ────────→ 逐行获取数据
```

**💡 游标的本质**
- **定位工具**：在查询结果中定位当前位置
- **逐行处理**：一次处理一行数据，而不是整个结果集
- **内存控制**：避免大量数据同时加载到内存

### 1.2 为什么需要游标


**🚫 没有游标的问题**
```sql
-- 传统方式：一次性获取所有数据
SELECT * FROM users WHERE age > 18;
-- 问题：如果有100万条记录，内存可能爆掉！
```

**✅ 使用游标的优势**
```
控制内存使用：
┌─────────────────┐
│  大结果集       │ ──→ 逐行处理 ──→ 💾 内存友好
│  (100万条)      │
└─────────────────┘

精确控制处理：
┌─ 处理逻辑 ─┐
│ IF age < 25 │ ──→ 🎯 针对每行做不同处理  
│ THEN ...    │
└─────────────┘
```

### 1.3 游标的工作原理


**📊 游标生命周期**
```
声明阶段     打开阶段     获取阶段     关闭阶段
┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐
│ CURSOR │─→│  OPEN  │─→│ FETCH  │─→│ CLOSE  │
│  声明   │  │  打开   │  │ 循环   │  │  关闭   │
└────────┘  └────────┘  └────────┘  └────────┘
     │           │           │           │
定义查询语句   执行查询    逐行读取    释放资源
```

---

## 2. 📝 CURSOR游标声明


### 2.1 CURSOR声明的含义


**🔸 什么是CURSOR声明**
```
CURSOR声明就是告诉数据库：
"我要准备一个工具，用来一行一行地处理这个查询的结果"

就像声明一个变量，但这个变量是用来存放查询结果的
```

### 2.2 CURSOR声明语法


**💻 基础声明语法**
```sql
-- MySQL风格
DECLARE cursor_name CURSOR FOR 
    SELECT column1, column2 FROM table_name WHERE condition;

-- Oracle风格  
CURSOR cursor_name IS
    SELECT column1, column2 FROM table_name WHERE condition;
```

### 2.3 CURSOR声明实例详解


**🎯 实际例子**
```sql
-- 声明一个处理用户数据的游标
DECLARE user_cursor CURSOR FOR
    SELECT user_id, username, email 
    FROM users 
    WHERE status = 'active';
```

**📋 声明解释**
```
DECLARE user_cursor：声明一个名叫"user_cursor"的游标
CURSOR FOR：关键字，表示这是游标声明
SELECT查询：定义游标要处理哪些数据
```

### 2.4 声明时的注意事项


**⚠️ 重要提醒**
```
声明位置：
┌─────────────────────┐
│ 1. 变量声明区域     │ ← 游标必须在这里声明
├─────────────────────┤  
│ 2. 异常处理声明区域  │
├─────────────────────┤
│ 3. 主要执行逻辑     │
└─────────────────────┘

命名规范：
✅ user_cursor, order_cursor (清楚表达用途)
❌ c1, cursor1 (含义不明确)
```

---

## 3. 🚀 OPEN打开游标


### 3.1 OPEN的作用和含义


**🔸 OPEN做什么**
```
OPEN就是"启动"游标，执行你声明时写的SQL查询

类比：
声明游标 = 写好菜单 📜
OPEN游标 = 开始做菜 🍳
FETCH数据 = 一道菜一道菜上桌 🍽️
```

### 3.2 OPEN语法格式


**💻 基础语法**
```sql
OPEN cursor_name;
```

**📊 OPEN操作流程**
```
OPEN user_cursor 执行过程：

步骤1️⃣ 执行SELECT查询
     ↓
步骤2️⃣ 建立结果集
     ↓  
步骤3️⃣ 游标指向第一行之前
     ↓
步骤4️⃣ 准备好供FETCH使用
```

### 3.3 OPEN的实际应用


**🎯 完整示例**
```sql
-- 1. 先声明游标
DECLARE user_cursor CURSOR FOR
    SELECT user_id, username FROM users WHERE age > 18;

-- 2. 然后打开游标    
OPEN user_cursor;
-- 此时查询已执行，结果集已准备好

-- 3. 接下来就可以FETCH了
```

### 3.4 OPEN操作的内部机制


**🔧 OPEN时发生了什么**
```
数据库内部动作：
┌─────────────────────────────┐
│ 1. 解析和编译SQL语句        │
│ 2. 执行查询获得结果集       │  
│ 3. 在内存中建立游标结构     │
│ 4. 初始化游标位置指针       │
└─────────────────────────────┘

内存状态：
结果集：[Row1][Row2][Row3][Row4]...
游标位置：    ↑
          (指向第一行前面)
```

---

## 4. 📥 FETCH获取数据


### 4.1 FETCH的核心概念


**🔸 FETCH是什么**
```
FETCH = 取一行数据
就像从传送带上拿一个包裹，每次FETCH拿一个

传送带模型：
[数据1] [数据2] [数据3] [数据4] ...
   ↑
 游标位置
每次FETCH，游标向前移动一位
```

### 4.2 FETCH语法详解


**💻 基本语法**
```sql
-- 将获取的数据存入变量
FETCH cursor_name INTO variable1, variable2, ...;

-- 或者存入记录类型
FETCH cursor_name INTO record_variable;
```

### 4.3 FETCH实际使用示例


**🎯 完整的FETCH流程**
```sql
-- 1. 声明变量接收数据
DECLARE v_user_id INT;
DECLARE v_username VARCHAR(50);

-- 2. 声明游标
DECLARE user_cursor CURSOR FOR
    SELECT user_id, username FROM users;

-- 3. 打开游标
OPEN user_cursor;

-- 4. 获取第一行数据
FETCH user_cursor INTO v_user_id, v_username;
-- 现在v_user_id和v_username包含第一行的数据

-- 5. 获取第二行数据
FETCH user_cursor INTO v_user_id, v_username;
-- 现在变量包含第二行的数据
```

### 4.4 FETCH的数据流转过程


**📊 数据流转图示**
```
游标结果集                    变量存储区
┌─────────────────┐          ┌─────────────────┐
│ [101, "张三"]    │ ────→    │ v_user_id = 101 │
│ [102, "李四"]    │ FETCH    │ v_username="张三"│
│ [103, "王五"]    │          └─────────────────┘
│      ...        │
└─────────────────┘
       ↑
   游标当前位置
```

### 4.5 FETCH的重要特点


**⚠️ 关键理解点**
```
FETCH的特点：
🔸 一次只取一行：不管结果集多大，每次FETCH只拿一行
🔸 游标自动前移：FETCH后游标自动指向下一行
🔸 顺序访问：只能按顺序往前，不能回退
🔸 数据类型匹配：变量类型要和查询字段类型对应
```

---

## 5. 🔒 CLOSE关闭游标


### 5.1 CLOSE的必要性


**🔸 为什么要CLOSE**
```
使用游标就像借书，用完必须还回去

资源占用：
┌─────────────────┐
│     内存         │ ← 游标占用内存存储结果集
├─────────────────┤
│   数据库连接     │ ← 占用数据库连接资源  
├─────────────────┤
│   系统句柄       │ ← 占用系统文件句柄
└─────────────────┘

不关闭的后果：
❌ 内存泄漏
❌ 连接池耗尽  
❌ 系统性能下降
```

### 5.2 CLOSE语法和使用


**💻 CLOSE语法**
```sql
CLOSE cursor_name;
```

**🎯 完整的游标生命周期**
```sql
-- 完整使用流程
BEGIN
    -- 1. 声明阶段
    DECLARE user_cursor CURSOR FOR SELECT * FROM users;
    
    -- 2. 打开阶段  
    OPEN user_cursor;
    
    -- 3. 使用阶段
    FETCH user_cursor INTO variables;
    -- ... 处理数据 ...
    
    -- 4. 关闭阶段（重要！）
    CLOSE user_cursor;
END;
```

### 5.3 CLOSE的内部机制


**🔧 CLOSE时发生什么**
```
关闭操作内部动作：
┌─────────────────────────────┐
│ 1. 释放结果集占用的内存     │
│ 2. 释放数据库连接资源       │
│ 3. 清理游标相关的数据结构   │  
│ 4. 标记游标为已关闭状态     │
└─────────────────────────────┘

资源释放过程：
占用状态 ──CLOSE──→ 释放状态
💾 内存使用中      💾 内存已释放
🔗 连接占用中      🔗 连接已释放
```

---

## 6. ✅ FOUND找到数据状态


### 6.1 FOUND状态的含义


**🔸 FOUND是什么**
```
FOUND是一个状态标识，告诉你：
"刚才的FETCH操作是否成功取到了数据"

就像问：
"刚才从盒子里拿东西，拿到了吗？"
FOUND = TRUE  → "拿到了！" 
FOUND = FALSE → "盒子空了，没拿到"
```

### 6.2 FOUND的检测方法


**💻 不同数据库的FOUND检测**
```sql
-- MySQL方式
FETCH user_cursor INTO v_id, v_name;
IF NOT cur.%NOTFOUND THEN
    -- 找到数据了，继续处理
END IF;

-- Oracle方式  
FETCH user_cursor INTO v_id, v_name;
IF user_cursor%FOUND THEN
    -- 找到数据了，继续处理
END IF;

-- PostgreSQL方式
IF FOUND THEN
    -- 找到数据了，继续处理  
END IF;
```

### 6.3 FOUND状态的判断时机


**📊 FOUND状态变化图示**
```
FETCH操作状态变化：

第1次FETCH：
┌─────────────────┐
│ 有数据 → FOUND  │ ── 返回第1行数据
└─────────────────┘

第2次FETCH：  
┌─────────────────┐
│ 有数据 → FOUND  │ ── 返回第2行数据
└─────────────────┘

第N次FETCH：
┌─────────────────┐
│ 无数据→NOTFOUND │ ── 没有更多数据了
└─────────────────┘
```

### 6.4 FOUND在循环中的应用


**🎯 典型使用模式**
```sql
-- 循环处理所有数据
OPEN user_cursor;
LOOP
    FETCH user_cursor INTO v_id, v_name;
    
    -- 检查是否还有数据
    IF user_cursor%NOTFOUND THEN
        EXIT; -- 没数据了，跳出循环
    END IF;
    
    -- 处理当前行数据
    DBMS_OUTPUT.PUT_LINE('用户ID: ' || v_id || ', 姓名: ' || v_name);
END LOOP;
CLOSE user_cursor;
```

---

## 7. ❌ NOTFOUND未找到数据状态


### 7.1 NOTFOUND状态详解


**🔸 NOTFOUND的含义**
```
NOTFOUND是FOUND的反面，表示：
"刚才的FETCH没有取到数据"

常见情况：
1. 游标已经读到结果集的末尾
2. 结果集本身就是空的
3. FETCH之前没有OPEN游标
```

### 7.2 NOTFOUND的检测语法


**💻 各种检测方式**
```sql
-- Oracle风格
IF user_cursor%NOTFOUND THEN
    DBMS_OUTPUT.PUT_LINE('没有更多数据了');
END IF;

-- MySQL风格  
DECLARE no_more_rows BOOLEAN DEFAULT FALSE;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET no_more_rows = TRUE;

FETCH user_cursor INTO v_id, v_name;
IF no_more_rows THEN
    -- 没有更多数据
END IF;
```

### 7.3 NOTFOUND的实际应用场景


**🎯 循环退出条件**
```sql
-- 使用NOTFOUND控制循环
BEGIN
    OPEN user_cursor;
    
    LOOP
        FETCH user_cursor INTO v_user_id, v_username;
        
        -- 核心判断：没数据就退出
        EXIT WHEN user_cursor%NOTFOUND;
        
        -- 有数据就处理
        process_user_data(v_user_id, v_username);
    END LOOP;
    
    CLOSE user_cursor;
END;
```

### 7.4 NOTFOUND状态的注意事项


**⚠️ 重要提醒**
```
NOTFOUND检查时机：
┌─────────────────────────────┐
│ ✅ 正确：每次FETCH后立即检查 │
│ ❌ 错误：处理数据后再检查    │
│ ❌ 错误：忘记检查NOTFOUND   │
└─────────────────────────────┘

后果分析：
忘记检查 → 死循环 → 系统卡死
检查太晚 → 处理无效数据 → 逻辑错误
```

---

## 8. 🔍 SQLSTATE SQL状态码


### 8.1 SQLSTATE基础概念


**🔸 SQLSTATE是什么**
```
SQLSTATE是一个5位的状态码，告诉你SQL执行的结果

类比交通灯：
🟢 '00000' = 绿灯 = 成功执行
🟡 '01xxx' = 黄灯 = 警告信息  
🔴 '其他'  = 红灯 = 出现错误

格式：XXXXX (5位字符)
前2位：状态类别
后3位：具体状态
```

### 8.2 常见SQLSTATE状态码


**📊 重要状态码对照表**

| **状态码** | **含义** | **说明** | **处理方式** |
|------------|----------|----------|-------------|
| `00000` | **成功** | `操作正常完成` | `继续执行` |
| `01000` | **警告** | `有警告信息` | `检查警告内容` |
| `02000` | **无数据** | `FETCH无更多数据` | `正常结束循环` |
| `23000` | **约束违反** | `主键、外键等约束` | `检查数据有效性` |
| `42000` | **语法错误** | `SQL语法有问题` | `检查SQL语句` |
| `08000` | **连接异常** | `数据库连接问题` | `重新连接` |

### 8.3 SQLSTATE的获取方法


**💻 获取SQLSTATE的方式**
```sql
-- Oracle方式
BEGIN
    -- 执行可能出错的操作
    FETCH user_cursor INTO v_id, v_name;
EXCEPTION
    WHEN OTHERS THEN
        v_sqlstate := SQLSTATE;
        DBMS_OUTPUT.PUT_LINE('错误状态码: ' || v_sqlstate);
END;

-- MySQL方式
DECLARE EXIT HANDLER FOR SQLSTATE '02000' 
BEGIN
    SET done = 1;
END;
```

### 8.4 SQLSTATE在游标中的应用


**🎯 游标操作中的状态检查**
```sql
-- 完整的状态检查示例
DECLARE v_sqlstate VARCHAR(5);

BEGIN
    OPEN user_cursor;
    
    LOOP
        FETCH user_cursor INTO v_id, v_name;
        
        -- 检查SQLSTATE
        CASE SQLSTATE
            WHEN '00000' THEN
                -- 成功获取数据，继续处理
                process_data(v_id, v_name);
            WHEN '02000' THEN  
                -- 没有更多数据，正常退出
                EXIT;
            ELSE
                -- 其他错误，记录并处理
                log_error('FETCH失败，状态码: ' || SQLSTATE);
                EXIT;
        END CASE;
    END LOOP;
    
    CLOSE user_cursor;
END;
```

---

## 9. ⚠️ SQLWARNING SQL警告处理


### 9.1 SQLWARNING概念解析


**🔸 什么是SQLWARNING**
```
SQLWARNING表示SQL执行时的警告状态

警告 vs 错误的区别：
┌─────────────────┐    ┌─────────────────┐
│   错误 ERROR    │    │   警告 WARNING  │  
│                 │    │                 │
│ • 操作失败      │    │ • 操作成功      │
│ • 必须处理      │    │ • 建议关注      │  
│ • 阻止继续执行  │    │ • 可以继续执行  │
└─────────────────┘    └─────────────────┘
```

### 9.2 常见的SQL警告情况


**📋 典型警告场景**
```sql
-- 1. 数据截断警告
INSERT INTO users (name) VALUES ('这是一个很长的名字超过了字段长度限制');
-- 警告：数据被截断

-- 2. 空值转换警告  
SELECT AVG(salary) FROM employees WHERE department IS NULL;
-- 警告：计算中包含NULL值

-- 3. 权限警告
GRANT SELECT ON table1 TO user1;
-- 警告：用户已经有该权限

-- 4. 游标相关警告
FETCH user_cursor INTO v_id, v_name;
-- 警告：游标接近结果集末尾
```

### 9.3 SQLWARNING的检测和处理


**💻 警告检测语法**
```sql
-- Oracle风格的警告处理
DECLARE 
    warning_occurred BOOLEAN := FALSE;
BEGIN
    -- 执行可能产生警告的操作
    FETCH user_cursor INTO v_id, v_name;
    
    -- 检查是否有警告
    IF SQLWARNING THEN
        warning_occurred := TRUE;
        DBMS_OUTPUT.PUT_LINE('警告: SQLSTATE = ' || SQLSTATE);
        -- 可以选择继续执行或特殊处理
    END IF;
    
    -- 继续正常处理逻辑
    IF NOT warning_occurred THEN
        process_normal_data(v_id, v_name);
    END IF;
END;
```

### 9.4 警告处理的最佳实践


**🎯 推荐的处理策略**
```sql
-- 分级处理警告
BEGIN
    OPEN user_cursor;
    
    LOOP
        FETCH user_cursor INTO v_id, v_name;
        
        IF user_cursor%NOTFOUND THEN
            EXIT; -- 正常结束
        END IF;
        
        -- 检查并分类处理警告
        IF SQLWARNING THEN
            CASE SQLSTATE
                WHEN '01000' THEN
                    -- 一般警告，记录日志但继续
                    write_log('一般警告: ' || SQLSTATE);
                WHEN '01004' THEN  
                    -- 数据截断警告，需要特别关注
                    write_log('数据截断警告，请检查数据');
                ELSE
                    -- 其他警告
                    write_log('未知警告: ' || SQLSTATE);
            END CASE;
        END IF;
        
        -- 继续处理数据
        process_user_data(v_id, v_name);
    END LOOP;
    
    CLOSE user_cursor;
END;
```

---

## 10. 🚨 SQLEXCEPTION SQL异常处理


### 10.1 SQLEXCEPTION基本概念


**🔸 什么是SQLEXCEPTION**
```
SQLEXCEPTION表示SQL执行过程中发生的严重错误

异常的特点：
┌─────────────────────────────┐
│ 🔴 阻止程序正常执行         │
│ 🔴 必须进行错误处理         │  
│ 🔴 可能导致数据不一致       │
│ 🔴 需要回滚或补救措施       │
└─────────────────────────────┘

异常 vs 警告 vs 正常：
正常执行 ──→ 继续
警告状态 ──→ 记录后继续  
异常状态 ──→ 必须处理
```

### 10.2 游标操作中的常见异常


**📊 典型异常场景**

| **异常类型** | **SQLSTATE** | **发生场景** | **处理方式** |
|--------------|--------------|--------------|--------------|
| **游标未打开** | `24000` | `FETCH前忘记OPEN` | `先OPEN再FETCH` |
| **游标已关闭** | `24000` | `CLOSE后再FETCH` | `重新OPEN游标` |
| **类型不匹配** | `07006` | `变量类型与字段不符` | `检查变量类型` |
| **内存不足** | `53200` | `结果集太大` | `分批处理数据` |
| **连接中断** | `08S01` | `网络或服务器问题` | `重新连接重试` |

### 10.3 异常处理语法


**💻 异常处理的语法结构**
```sql
-- Oracle风格的异常处理
DECLARE
    user_cursor CURSOR FOR SELECT * FROM users;
    v_id NUMBER;
    v_name VARCHAR2(50);
BEGIN
    OPEN user_cursor;
    
    LOOP
        BEGIN
            FETCH user_cursor INTO v_id, v_name;
            EXIT WHEN user_cursor%NOTFOUND;
            
            -- 处理数据
            process_user_data(v_id, v_name);
            
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- 特定异常处理
                DBMS_OUTPUT.PUT_LINE('没有找到数据');
                EXIT;
            WHEN TOO_MANY_ROWS THEN
                -- 另一种特定异常
                DBMS_OUTPUT.PUT_LINE('返回了多行数据');
            WHEN OTHERS THEN
                -- 通用异常处理
                DBMS_OUTPUT.PUT_LINE('发生未知错误: ' || SQLERRM);
                -- 记录错误信息
                log_error('游标操作异常', SQLCODE, SQLERRM);
        END;
    END LOOP;
    
    CLOSE user_cursor;
EXCEPTION
    -- 外层异常处理
    WHEN OTHERS THEN
        -- 确保游标被关闭
        IF user_cursor%ISOPEN THEN
            CLOSE user_cursor;
        END IF;
        RAISE; -- 重新抛出异常
END;
```

### 10.4 异常处理最佳实践


**🎯 推荐的异常处理模式**
```sql
-- 完整的异常处理框架
CREATE OR REPLACE PROCEDURE process_users AS
    CURSOR user_cursor IS SELECT user_id, username FROM users;
    v_user_id NUMBER;
    v_username VARCHAR2(100);
    v_processed_count NUMBER := 0;
    v_error_count NUMBER := 0;
BEGIN
    -- 开始处理
    DBMS_OUTPUT.PUT_LINE('开始处理用户数据...');
    
    OPEN user_cursor;
    
    LOOP
        BEGIN
            -- 获取数据
            FETCH user_cursor INTO v_user_id, v_username;
            EXIT WHEN user_cursor%NOTFOUND;
            
            -- 处理单行数据
            process_single_user(v_user_id, v_username);
            v_processed_count := v_processed_count + 1;
            
        EXCEPTION
            WHEN OTHERS THEN
                -- 记录错误但继续处理其他数据
                v_error_count := v_error_count + 1;
                log_error('处理用户失败', v_user_id, SQLERRM);
        END;
    END LOOP;
    
    CLOSE user_cursor;
    
    -- 输出处理结果
    DBMS_OUTPUT.PUT_LINE('处理完成！');
    DBMS_OUTPUT.PUT_LINE('成功处理: ' || v_processed_count || ' 条记录');
    DBMS_OUTPUT.PUT_LINE('错误数量: ' || v_error_count || ' 条记录');
    
EXCEPTION
    WHEN OTHERS THEN
        -- 最外层的异常保护
        IF user_cursor%ISOPEN THEN
            CLOSE user_cursor;
        END IF;
        
        -- 记录严重错误
        log_fatal_error('游标处理程序异常', SQLCODE, SQLERRM);
        RAISE;
END process_users;
```

---

## 11. 🔄 游标操作完整流程


### 11.1 标准游标操作流程


**📊 完整操作流程图**
```
游标操作标准流程：

开始
  │
  ├─ 1️⃣ 声明变量
  │     ├─ 接收数据的变量
  │     └─ 控制变量（计数器等）
  │
  ├─ 2️⃣ 声明游标  
  │     └─ DECLARE CURSOR FOR SELECT...
  │
  ├─ 3️⃣ 声明异常处理
  │     ├─ NOTFOUND处理  
  │     └─ 其他异常处理
  │
  ├─ 4️⃣ 打开游标
  │     └─ OPEN cursor_name
  │
  ├─ 5️⃣ 循环处理数据
  │     ├─ FETCH数据到变量
  │     ├─ 检查FOUND状态
  │     ├─ 处理当前行数据
  │     └─ 继续循环
  │
  ├─ 6️⃣ 关闭游标
  │     └─ CLOSE cursor_name
  │
结束
```

### 11.2 完整示例代码


**🎯 综合实例：用户数据批量处理**
```sql
CREATE OR REPLACE PROCEDURE batch_process_users AS
    -- 1. 声明接收数据的变量
    v_user_id       NUMBER;
    v_username      VARCHAR2(100); 
    v_email         VARCHAR2(200);
    v_status        VARCHAR2(20);
    
    -- 2. 声明控制变量
    v_total_count   NUMBER := 0;
    v_active_count  NUMBER := 0;
    v_error_count   NUMBER := 0;
    
    -- 3. 声明游标
    CURSOR user_cursor IS
        SELECT user_id, username, email, status
        FROM users
        WHERE created_date >= SYSDATE - 30  -- 最近30天的用户
        ORDER BY user_id;
    
    -- 4. 声明异常处理标识
    v_fetch_status  VARCHAR2(10) := 'OK';
    
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== 开始批量处理用户数据 ===');
    DBMS_OUTPUT.PUT_LINE('处理时间: ' || TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));
    
    -- 5. 打开游标
    OPEN user_cursor;
    
    -- 6. 主处理循环
    LOOP
        BEGIN
            -- 6.1 获取一行数据
            FETCH user_cursor INTO v_user_id, v_username, v_email, v_status;
            
            -- 6.2 检查是否还有数据
            IF user_cursor%NOTFOUND THEN
                DBMS_OUTPUT.PUT_LINE('所有数据处理完成');
                EXIT; -- 退出循环
            END IF;
            
            -- 6.3 计数
            v_total_count := v_total_count + 1;
            
            -- 6.4 根据状态处理数据
            CASE v_status
                WHEN 'active' THEN
                    -- 处理活跃用户
                    process_active_user(v_user_id, v_username, v_email);
                    v_active_count := v_active_count + 1;
                    
                WHEN 'inactive' THEN  
                    -- 处理非活跃用户
                    process_inactive_user(v_user_id);
                    
                WHEN 'blocked' THEN
                    -- 处理被阻止用户
                    review_blocked_user(v_user_id);
                    
                ELSE
                    -- 未知状态
                    DBMS_OUTPUT.PUT_LINE('未知用户状态: ' || v_status || 
                                       ' (用户ID: ' || v_user_id || ')');
            END CASE;
            
            -- 6.5 每处理100条显示进度
            IF MOD(v_total_count, 100) = 0 THEN
                DBMS_OUTPUT.PUT_LINE('已处理 ' || v_total_count || ' 条记录...');
            END IF;
            
        EXCEPTION
            WHEN OTHERS THEN
                -- 单行处理异常，记录但继续处理其他数据
                v_error_count := v_error_count + 1;
                DBMS_OUTPUT.PUT_LINE('处理用户ID ' || v_user_id || 
                                   ' 时发生错误: ' || SQLERRM);
                -- 继续下一条记录
        END;
    END LOOP;
    
    -- 7. 关闭游标
    CLOSE user_cursor;
    
    -- 8. 输出处理统计
    DBMS_OUTPUT.PUT_LINE('=== 处理完成统计 ===');
    DBMS_OUTPUT.PUT_LINE('总处理记录数: ' || v_total_count);
    DBMS_OUTPUT.PUT_LINE('活跃用户数: ' || v_active_count);
    DBMS_OUTPUT.PUT_LINE('错误记录数: ' || v_error_count);
    DBMS_OUTPUT.PUT_LINE('成功率: ' || 
                        ROUND((v_total_count - v_error_count) / v_total_count * 100, 2) || '%');
    
EXCEPTION
    WHEN OTHERS THEN
        -- 最外层异常处理
        DBMS_OUTPUT.PUT_LINE('程序执行异常: ' || SQLERRM);
        
        -- 确保游标被关闭
        IF user_cursor%ISOPEN THEN
            CLOSE user_cursor;
            DBMS_OUTPUT.PUT_LINE('游标已强制关闭');
        END IF;
        
        -- 重新抛出异常供调用者处理
        RAISE;
END batch_process_users;
```

### 11.3 流程中的关键检查点


**⚠️ 重要检查清单**
```
操作前检查：
☑️ 变量声明是否完整
☑️ 游标SQL语句是否正确
☑️ 异常处理是否覆盖全面

操作中检查：
☑️ 每次FETCH后检查FOUND状态  
☑️ 数据类型是否匹配
☑️ 处理逻辑是否正确
☑️ 异常是否得到妥善处理

操作后检查：
☑️ 游标是否正确关闭
☑️ 资源是否完全释放
☑️ 统计信息是否准确
☑️ 日志记录是否完整
```

---

## 12. 📋 核心要点总结


### 12.1 必须掌握的核心概念


```
🔸 游标本质：数据库结果集的逐行访问工具，像书签一样定位当前处理位置
🔸 生命周期：声明 → 打开 → 获取 → 关闭，四个阶段缺一不可
🔸 状态管理：通过FOUND/NOTFOUND判断数据获取状态，控制处理流程
🔸 异常处理：使用SQLSTATE、SQLWARNING、SQLEXCEPTION保证程序健壮性
🔸 资源控制：及时关闭游标释放资源，避免内存泄漏和连接耗尽
```

### 12.2 关键操作要点


**🔹 声明阶段（CURSOR）**
```
核心要点：
• 在正确位置声明游标（变量声明区域）
• SQL语句要语法正确且符合业务需求
• 游标命名要有意义，便于理解和维护
```

**🔹 打开阶段（OPEN）**
```
核心要点：
• OPEN时SQL查询才真正执行
• 打开后游标指向第一行之前的位置
• 确保OPEN成功后才能进行FETCH操作
```

**🔹 获取阶段（FETCH）**  
```
核心要点：
• 一次FETCH只获取一行数据
• 变量类型必须与查询字段类型匹配
• 每次FETCH后游标自动向前移动一位
```

**🔹 关闭阶段（CLOSE）**
```
核心要点：
• 必须关闭游标释放系统资源
• 在异常处理中也要保证游标关闭
• 关闭后的游标不能再进行FETCH操作
```

### 12.3 状态检测要点


**🔹 FOUND/NOTFOUND状态**
```
使用场景：
• 控制循环继续或退出
• 判断FETCH是否成功获取到数据  
• 区分正常结束和异常结束

检测时机：
• 每次FETCH操作后立即检测
• 在数据处理逻辑之前进行判断
```

**🔹 SQLSTATE状态码**
```
重要状态码：
• '00000'：操作成功
• '02000'：没有更多数据（对应NOTFOUND）
• '01000'：有警告信息
• 其他：各种错误状态

应用价值：
• 精确了解SQL执行状态
• 进行细致的错误分类处理
```

### 12.4 异常处理要点


**🔹 SQLWARNING警告处理**
```
处理原则：
• 警告不影响继续执行，但需要关注
• 记录警告信息便于后续分析
• 根据警告类型决定是否需要特殊处理
```

**🔹 SQLEXCEPTION异常处理**  
```
处理策略：
• 分层处理：单行异常 + 整体异常
• 资源保护：确保异常时也能关闭游标
• 错误恢复：记录错误信息，尽可能继续处理
```

### 12.5 实际应用指导


**🎯 适用场景**
- **大数据量处理**：避免内存溢出，逐行处理
- **复杂业务逻辑**：需要对每行数据进行不同处理
- **批量数据转换**：ETL过程中的数据清洗和转换  
- **报表生成**：需要逐行计算和汇总的复杂报表

**🔧 性能优化建议**
```
查询优化：
• 在CURSOR声明中使用合适的WHERE条件
• 添加必要的ORDER BY提高数据处理效率
• 只查询需要的字段，避免SELECT *

处理优化：
• 批量提交，避免逐行提交事务
• 合理设置缓冲区大小
• 及时关闭不用的游标释放资源

监控建议：
• 记录处理进度和统计信息
• 监控内存使用情况
• 跟踪异常发生频率和类型
```

**🔹 常见陷阱和避免方法**
```
陷阱1：忘记关闭游标
解决：在异常处理中也要检查并关闭游标

陷阱2：FETCH后不检查FOUND状态
解决：每次FETCH后立即检查，控制循环

陷阱3：变量类型不匹配
解决：确保接收变量类型与查询字段类型一致

陷阱4：在错误位置声明游标
解决：严格按照数据库语法要求在正确区域声明
```

**核心记忆口诀**：
- 游标操作四步走：声明打开取关闭
- 状态检测不能少：FOUND NOTFOUND控制好
- 异常处理要周全：警告错误都要管
- 资源释放是关键：及时关闭避免泄漏

> 💡 **学习建议**：游标操作虽然步骤较多，但每个步骤都有明确的作用。建议通过实际编写代码来加深理解，特别是要重点练习异常处理和状态检测，这是写出健壮游标程序的关键。