---
title: 24、加密哈希函数关键字
---
## 📚 目录

1. [加密哈希函数基础概念](#1-加密哈希函数基础概念)
2. [消息摘要函数（MD5）](#2-消息摘要函数md5)
3. [安全哈希算法（SHA系列）](#3-安全哈希算法sha系列)
4. [密码处理函数](#4-密码处理函数)
5. [对称加密函数](#5-对称加密函数)
6. [编码解码函数](#6-编码解码函数)
7. [数据压缩函数](#7-数据压缩函数)
8. [校验与随机函数](#8-校验与随机函数)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 加密哈希函数基础概念


### 1.1 什么是加密哈希函数


**🎯 通俗理解**：
加密哈希函数就像是给数据做"指纹识别"的工具。就像每个人的指纹都不一样，哈希函数能把任意长度的数据转换成固定长度的"数字指纹"。

```
简单类比：
原始数据 = 一本书的内容
哈希值 = 这本书的"身份证号码"
特点：不同的书有不同的身份证号，相同的书总是同一个号码
```

**🔸 核心特征**：
- **固定输出**：无论输入多长，输出长度固定
- **单向性**：只能从数据算出哈希值，不能反推
- **确定性**：相同输入总是产生相同输出
- **敏感性**：输入微小变化，输出完全不同

### 1.2 在MySQL中的作用


**💡 实际用途**：
```
🔸 密码存储：用户密码不明文保存，存储哈希值
🔸 数据校验：检查数据是否被篡改
🔸 唯一标识：为数据生成唯一ID
🔸 索引优化：对长文本生成短哈希建索引
```

**📊 应用场景对比**：
| 场景 | 传统方式 | 哈希函数方式 | 优势 |
|------|----------|--------------|------|
| 🔐 **密码存储** | 明文保存 | 存储MD5/SHA值 | 安全性高 |
| 📝 **数据校验** | 逐字节比较 | 比较哈希值 | 速度快 |
| 🔍 **快速查找** | 全文搜索 | 哈希索引 | 效率高 |

---

## 2. 📝 消息摘要函数（MD5）


### 2.1 MD5基本概念


**🎯 MD5是什么**：
MD5（Message Digest 5）是一种广泛使用的消息摘要算法。可以把它理解为给数据生成一个128位（32个字符）的"身份证号码"。

```sql
-- MD5基本使用
SELECT MD5('Hello World') as hash_value;
-- 结果：b10a8db164e0754105b7a99be72e3fe5
```

**🔸 MD5特点**：
```
输出长度：固定32个字符（128位）
运算速度：非常快
安全级别：⭐⭐ (现在被认为不够安全)
适用场景：数据校验、非安全场景的唯一标识
```

### 2.2 MD5实际应用


**💻 典型使用场景**：

```sql
-- 1. 用户密码存储（简单示例，实际应该加盐）
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    password_hash VARCHAR(32)  -- 存储MD5值
);

-- 插入用户（密码会被MD5加密）
INSERT INTO users (id, username, password_hash) 
VALUES (1, 'john', MD5('mypassword123'));

-- 用户登录验证
SELECT * FROM users 
WHERE username = 'john' 
  AND password_hash = MD5('mypassword123');
```

```sql
-- 2. 数据完整性校验
-- 为重要数据生成校验码
SELECT 
    id,
    content,
    MD5(content) as checksum
FROM important_documents;
```

**⚠️ 安全提醒**：
```
MD5安全性问题：
❌ 容易被暴力破解
❌ 存在哈希碰撞风险
❌ 不适合存储敏感密码

✅ 仍可用于：
- 文件完整性校验
- 非敏感数据的唯一标识
- 缓存key生成
```

### 2.3 MD5使用最佳实践


**🛠️ 实用技巧**：

```sql
-- 为长文本建立哈希索引
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    content_hash VARCHAR(32) GENERATED ALWAYS AS (MD5(content))
);

-- 通过哈希快速查找重复内容
SELECT a1.id, a2.id, a1.title
FROM articles a1
JOIN articles a2 ON a1.content_hash = a2.content_hash
WHERE a1.id < a2.id;  -- 避免重复对比
```

---

## 3. 🛡️ 安全哈希算法（SHA系列）


### 3.1 SHA1安全哈希


**🎯 SHA1是什么**：
SHA1（Secure Hash Algorithm 1）是比MD5更安全的哈希算法，输出160位（40个字符）的哈希值。就像是给数据制作更复杂的"指纹"。

```sql
-- SHA1基本使用
SELECT SHA1('Hello World') as sha1_hash;
-- 结果：0a4d55a8d778e5022fab701977c5d840bbc486d0
```

**🔸 SHA1特点**：
```
输出长度：40个字符（160位）
安全性：⭐⭐⭐ (比MD5强，但也不够现代标准)
速度：较快
用途：Git版本控制、数字签名等
```

### 3.2 SHA2安全哈希2


**🎯 SHA2是什么**：
SHA2是SHA算法的升级版，包含多种变体（SHA-224, SHA-256, SHA-384, SHA-512）。其中SHA-256最常用，输出256位（64个字符）。

```sql
-- SHA2基本使用（默认是SHA-256）
SELECT SHA2('Hello World', 256) as sha256_hash;
-- 结果：a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3

-- 不同位数的SHA2
SELECT 
    SHA2('Hello World', 224) as sha224,
    SHA2('Hello World', 256) as sha256,
    SHA2('Hello World', 384) as sha384,
    SHA2('Hello World', 512) as sha512;
```

**🔸 SHA2安全级别对比**：
| 算法 | 输出长度 | 安全级别 | 推荐使用 |
|------|----------|----------|----------|
| **SHA-224** | 56字符 | ⭐⭐⭐⭐ | 空间敏感场景 |
| **SHA-256** | 64字符 | ⭐⭐⭐⭐⭐ | 通用推荐 |
| **SHA-384** | 96字符 | ⭐⭐⭐⭐⭐ | 高安全需求 |
| **SHA-512** | 128字符 | ⭐⭐⭐⭐⭐ | 最高安全 |

### 3.3 SHA系列实际应用


**💻 现代密码存储方案**：

```sql
-- 创建现代化用户表
CREATE TABLE secure_users (
    id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    password_hash VARCHAR(64),  -- SHA-256输出
    salt VARCHAR(32),           -- 盐值
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 模拟用户注册（带盐的SHA-256）
SET @username = 'alice';
SET @password = 'secretpassword';
SET @salt = SHA1(CONCAT(@username, NOW(), RAND()));  -- 生成随机盐

INSERT INTO secure_users (username, password_hash, salt)
VALUES (
    @username,
    SHA2(CONCAT(@password, @salt), 256),  -- 密码+盐的SHA-256
    @salt
);
```

**🔍 数字签名验证**：

```sql
-- 重要文档的数字签名
CREATE TABLE documents (
    id INT PRIMARY KEY,
    title VARCHAR(255),
    content LONGTEXT,
    signature VARCHAR(128) GENERATED ALWAYS AS (
        SHA2(CONCAT(title, content, created_at), 512)
    ),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

## 4. 🔑 密码处理函数


### 4.1 PASSWORD密码函数


**🎯 PASSWORD函数是什么**：
PASSWORD是MySQL专门用于用户认证的密码哈希函数。它主要用于MySQL内部用户账户管理，不建议在应用程序中使用。

```sql
-- PASSWORD函数使用（注意：已弃用）
SELECT PASSWORD('mypassword') as mysql_password;
-- 结果类似：*6C8989366EAF75BB670AD120B9AED49FFFFFF
```

**⚠️ 重要提醒**：
```
PASSWORD函数状态：
❌ MySQL 5.7开始弃用
❌ MySQL 8.0已移除
❌ 不适合应用程序使用
✅ 仅用于理解MySQL内部机制
```

### 4.2 OLD_PASSWORD旧密码函数


**🎯 OLD_PASSWORD是什么**：
这是MySQL早期版本使用的密码哈希函数，现在完全不推荐使用。

```sql
-- OLD_PASSWORD使用示例（已弃用，仅作了解）
-- SELECT OLD_PASSWORD('password123');
```

**🚫 安全警告**：
```
OLD_PASSWORD问题：
❌ 安全性极低
❌ 容易被破解
❌ 已被完全废弃
❌ 绝不应在生产环境使用
```

### 4.3 现代密码处理建议


**🛡️ 推荐的密码处理方案**：

```sql
-- 方案1：使用SHA-256 + 盐
CREATE TABLE modern_users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE,
    password_hash VARCHAR(64),
    salt VARCHAR(32),
    INDEX idx_email (email)
);

-- 用户注册流程
DELIMITER //
CREATE PROCEDURE RegisterUser(
    IN p_email VARCHAR(255),
    IN p_password TEXT
)
BEGIN
    DECLARE v_salt VARCHAR(32);
    
    -- 生成随机盐
    SET v_salt = SHA1(CONCAT(p_email, NOW(6), CONNECTION_ID()));
    
    -- 插入用户
    INSERT INTO modern_users (email, password_hash, salt)
    VALUES (
        p_email,
        SHA2(CONCAT(p_password, v_salt), 256),
        v_salt
    );
END //
DELIMITER ;
```

**💡 安全最佳实践**：
```
🔸 总是使用盐值（Salt）
🔸 每个用户使用不同的盐
🔸 选择SHA-256或更强的算法
🔸 在应用层实现密码强度检查
🔸 考虑使用bcrypt、scrypt等专用密码库
```

---

## 5. 🔒 对称加密函数


### 5.1 DES加密解密函数


**🎯 DES是什么**：
DES（Data Encryption Standard）是一种对称加密算法。对称加密就像用同一把钥匙既能锁门又能开门，加密和解密使用相同的密钥。

```sql
-- DES_ENCRYPT基本使用
SET @original_text = 'Secret Message';
SET @password = 'mykey123';

-- 加密数据
SET @encrypted = DES_ENCRYPT(@original_text, @password);
SELECT HEX(@encrypted) as encrypted_hex;

-- 解密数据
SET @decrypted = DES_DECRYPT(@encrypted, @password);
SELECT @decrypted as decrypted_text;
```

**🔸 DES特点**：
```
密钥长度：56位（实际64位，8位为校验）
安全性：⭐⭐ (现代标准下安全性不足)
速度：较快
用途：历史遗留系统，不推荐新项目使用
```

**⚠️ DES安全问题**：
```
为什么DES不够安全：
❌ 密钥太短（56位），容易被暴力破解
❌ 1999年就能在22小时内破解
❌ 现代计算机几秒钟就能破解
✅ 替代方案：使用AES加密
```

### 5.2 AES加密解密函数


**🎯 AES是什么**：
AES（Advanced Encryption Standard）是现代标准的对称加密算法，比DES安全得多。它支持128位、192位、256位密钥。

```sql
-- AES_ENCRYPT基本使用
SET @message = 'Top Secret Information';
SET @key = 'my-secret-key-16-bytes';

-- AES加密
SET @encrypted = AES_ENCRYPT(@message, @key);
SELECT HEX(@encrypted) as aes_encrypted;

-- AES解密
SET @decrypted = AES_DECRYPT(@encrypted, @key);
SELECT @decrypted as original_message;
```

**📊 AES安全级别对比**：
| 密钥长度 | 安全级别 | 破解难度 | 推荐用途 |
|----------|----------|----------|----------|
| **128位** | ⭐⭐⭐⭐⭐ | 几乎不可能 | 一般商用 |
| **192位** | ⭐⭐⭐⭐⭐ | 理论上不可能 | 高安全需求 |
| **256位** | ⭐⭐⭐⭐⭐ | 完全不可能 | 军用级别 |

### 5.3 对称加密实际应用


**💼 敏感数据存储**：

```sql
-- 创建包含加密字段的表
CREATE TABLE customer_data (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    encrypted_ssn BLOB,        -- 加密的社会保险号
    encrypted_credit_card BLOB, -- 加密的信用卡号
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入加密数据
SET @encryption_key = 'company-master-key-32-characters';

INSERT INTO customer_data (name, encrypted_ssn, encrypted_credit_card)
VALUES (
    'John Doe',
    AES_ENCRYPT('123-45-6789', @encryption_key),
    AES_ENCRYPT('4532-1234-5678-9012', @encryption_key)
);

-- 查询时解密
SELECT 
    id,
    name,
    AES_DECRYPT(encrypted_ssn, @encryption_key) as ssn,
    AES_DECRYPT(encrypted_credit_card, @encryption_key) as credit_card
FROM customer_data
WHERE id = 1;
```

**🔒 应用级加密策略**：

```sql
-- 创建加密函数简化操作
DELIMITER //
CREATE FUNCTION EncryptData(plain_text TEXT, user_key VARCHAR(255))
RETURNS BLOB
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE master_key VARCHAR(255) DEFAULT 'your-master-key-here';
    RETURN AES_ENCRYPT(plain_text, CONCAT(master_key, user_key));
END //

CREATE FUNCTION DecryptData(encrypted_data BLOB, user_key VARCHAR(255))
RETURNS TEXT
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE master_key VARCHAR(255) DEFAULT 'your-master-key-here';
    RETURN AES_DECRYPT(encrypted_data, CONCAT(master_key, user_key));
END //
DELIMITER ;
```

**💡 加密最佳实践**：
```
🔸 密钥管理：
- 使用强随机密钥（至少16字节）
- 定期轮换密钥
- 分离存储密钥和数据

🔸 性能考虑：
- 只加密真正敏感的数据
- 考虑加密对查询性能的影响
- 在应用层进行加解密可能更高效

🔸 法规遵从：
- 了解数据保护法规要求
- 记录加密策略和密钥管理过程
```

---

## 6. 🔄 编码解码函数


### 6.1 ENCODE和DECODE函数


**🎯 编码解码是什么**：
ENCODE和DECODE是MySQL提供的简单加密函数，主要用于数据的混淆，而不是真正的安全加密。可以理解为给数据"化妆"，让它看起来不一样。

```sql
-- ENCODE/DECODE基本使用
SET @original = 'Confidential Data';
SET @password = 'mysecret';

-- 编码数据
SET @encoded = ENCODE(@original, @password);
SELECT HEX(@encoded) as encoded_hex;

-- 解码数据
SET @decoded = DECODE(@encoded, @password);
SELECT @decoded as decoded_text;
```

**⚠️ 重要提醒**：
```
ENCODE/DECODE函数状态：
❌ MySQL 5.7开始弃用
❌ 安全性不足
❌ 不适合真正的数据保护
✅ 可用于简单的数据混淆
```

### 6.2 现代编码解码方案


**🔧 替代方案建议**：

```sql
-- 使用Base64编码（不是加密，只是编码）
SELECT 
    TO_BASE64('Hello World') as base64_encoded,
    FROM_BASE64(TO_BASE64('Hello World')) as base64_decoded;

-- 结果：
-- base64_encoded: SGVsbG8gV29ybGQ=
-- base64_decoded: Hello World
```

**📊 编码vs加密对比**：
| 类型 | 目的 | 安全性 | 可逆性 | 使用场景 |
|------|------|--------|--------|----------|
| **编码** | 数据格式转换 | ❌ 无安全性 | ✅ 容易逆转 | 数据传输、存储 |
| **加密** | 数据保护 | ✅ 高安全性 | 🔑 需要密钥 | 敏感信息保护 |

### 6.3 实用编码技巧


**💻 Base64在实际应用中的使用**：

```sql
-- 存储二进制数据为文本格式
CREATE TABLE file_storage (
    id INT PRIMARY KEY AUTO_INCREMENT,
    filename VARCHAR(255),
    file_content LONGTEXT,  -- Base64编码的文件内容
    original_size INT,
    upload_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 模拟文件上传（在实际应用中，这会在应用层处理）
INSERT INTO file_storage (filename, file_content, original_size)
VALUES (
    'document.pdf',
    TO_BASE64('这里是文件的二进制内容'),
    LENGTH('这里是文件的二进制内容')
);

-- 获取文件内容
SELECT 
    filename,
    FROM_BASE64(file_content) as file_binary,
    original_size
FROM file_storage 
WHERE filename = 'document.pdf';
```

---

## 7. 📦 数据压缩函数


### 7.1 COMPRESS压缩函数


**🎯 压缩是什么**：
COMPRESS函数可以压缩数据，减少存储空间。就像把衣服塞进真空压缩袋，同样的东西占用更少的空间。

```sql
-- COMPRESS基本使用
SET @original_text = REPEAT('Hello World! ', 1000);  -- 创建重复文本
SET @compressed = COMPRESS(@original_text);

SELECT 
    LENGTH(@original_text) as original_size,
    LENGTH(@compressed) as compressed_size,
    ROUND(LENGTH(@compressed) / LENGTH(@original_text) * 100, 2) as compression_ratio;
```

**🔸 压缩效果演示**：
```sql
-- 比较不同类型数据的压缩效果
SELECT 
    'Random text' as data_type,
    LENGTH(COMPRESS(MD5(RAND()))) as compressed_size
UNION
SELECT 
    'Repeated text' as data_type,
    LENGTH(COMPRESS(REPEAT('ABCD', 250))) as compressed_size
UNION
SELECT 
    'JSON data' as data_type,
    LENGTH(COMPRESS('{"name":"John","age":30,"city":"New York"}')) as compressed_size;
```

### 7.2 UNCOMPRESS解压缩函数


**🎯 解压缩原理**：
UNCOMPRESS函数将压缩的数据还原为原始格式，就像把真空压缩袋打开，衣服恢复原状。

```sql
-- UNCOMPRESS基本使用
SET @original = 'This is a long text that will be compressed and then uncompressed';
SET @compressed = COMPRESS(@original);
SET @uncompressed = UNCOMPRESS(@compressed);

SELECT 
    @original as original_text,
    @uncompressed as recovered_text,
    (@original = @uncompressed) as is_identical;
```

### 7.3 UNCOMPRESSED_LENGTH未压缩长度


**🎯 获取原始长度**：
这个函数可以告诉你压缩数据的原始长度，而不需要真正解压缩。

```sql
-- UNCOMPRESSED_LENGTH使用
SET @data = REPEAT('MySQL compression example ', 100);
SET @compressed = COMPRESS(@data);

SELECT 
    LENGTH(@data) as original_length,
    LENGTH(@compressed) as compressed_length,
    UNCOMPRESSED_LENGTH(@compressed) as reported_original_length,
    (LENGTH(@data) = UNCOMPRESSED_LENGTH(@compressed)) as length_match;
```

### 7.4 压缩函数实际应用


**💾 大文本存储优化**：

```sql
-- 创建支持压缩的文章表
CREATE TABLE articles_compressed (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    content_compressed LONGBLOB,     -- 压缩后的内容
    original_length INT,             -- 原始长度
    compression_ratio DECIMAL(5,2),  -- 压缩比
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入压缩文章
SET @article_content = REPEAT('这是一篇很长的文章内容...', 500);
SET @compressed_content = COMPRESS(@article_content);

INSERT INTO articles_compressed 
(title, content_compressed, original_length, compression_ratio)
VALUES (
    '压缩测试文章',
    @compressed_content,
    LENGTH(@article_content),
    ROUND(LENGTH(@compressed_content) / LENGTH(@article_content) * 100, 2)
);

-- 查询时解压缩
SELECT 
    id,
    title,
    UNCOMPRESS(content_compressed) as content,
    original_length,
    compression_ratio
FROM articles_compressed
WHERE id = 1;
```

**📊 压缩效果分析**：

```sql
-- 分析压缩效果的查询
SELECT 
    title,
    original_length,
    LENGTH(content_compressed) as compressed_length,
    compression_ratio,
    CASE 
        WHEN compression_ratio < 50 THEN '高压缩率'
        WHEN compression_ratio < 80 THEN '中等压缩率'
        ELSE '低压缩率'
    END as compression_level
FROM articles_compressed
ORDER BY compression_ratio;
```

**💡 压缩使用建议**：
```
🔸 适合压缩的数据：
- 重复性高的文本
- JSON/XML格式数据
- 日志文件
- 大段文字内容

🔸 不适合压缩的数据：
- 已经压缩过的数据（如图片、视频）
- 短文本（压缩开销可能更大）
- 频繁查询的小数据

🔸 性能考虑：
- 压缩增加CPU开销
- 减少存储空间和I/O
- 适合读多写少的场景
```

---

## 8. 🔍 校验与随机函数


### 8.1 CRC32循环冗余校验


**🎯 CRC32是什么**：
CRC32（循环冗余校验）是一种错误检测方法。可以把它理解为给数据生成一个"校验码"，用来检查数据是否被损坏或篡改。

```sql
-- CRC32基本使用
SELECT 
    CRC32('Hello World') as crc32_value,
    CRC32('Hello World!') as crc32_different;  -- 注意差异

-- 结果示例：
-- crc32_value: 4192936109
-- crc32_different: 4082564468
```

**🔸 CRC32特点**：
```
输出：32位无符号整数
特点：对输入变化非常敏感
用途：快速数据完整性检查
限制：不是加密哈希，安全性较低
```

### 8.2 CRC32实际应用


**📋 数据完整性监控**：

```sql
-- 创建带校验码的数据表
CREATE TABLE data_with_checksum (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    important_data TEXT,
    data_checksum INT GENERATED ALWAYS AS (CRC32(important_data)),
    last_modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_checksum (data_checksum)
);

-- 插入数据（校验码自动生成）
INSERT INTO data_with_checksum (user_id, important_data)
VALUES 
    (1, '用户的重要配置信息'),
    (2, '另一个用户的数据');

-- 检查数据完整性
SELECT 
    id,
    user_id,
    important_data,
    data_checksum,
    CRC32(important_data) as current_checksum,
    (data_checksum = CRC32(important_data)) as integrity_check
FROM data_with_checksum;
```

**🔍 快速重复数据检测**：

```sql
-- 使用CRC32快速找出可能重复的数据
CREATE TABLE documents (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    content LONGTEXT,
    content_crc32 INT GENERATED ALWAYS AS (CRC32(content)),
    INDEX idx_crc32 (content_crc32)
);

-- 查找可能重复的文档（基于CRC32）
SELECT 
    content_crc32,
    COUNT(*) as duplicate_count,
    GROUP_CONCAT(id) as document_ids
FROM documents
GROUP BY content_crc32
HAVING COUNT(*) > 1;
```

### 8.3 RANDOM_BYTES随机字节生成


**🎯 RANDOM_BYTES是什么**：
RANDOM_BYTES函数生成指定长度的随机字节序列，常用于生成密码学安全的随机数、盐值、令牌等。

```sql
-- RANDOM_BYTES基本使用
SELECT 
    HEX(RANDOM_BYTES(16)) as random_hex_32_chars,  -- 16字节=32个十六进制字符
    HEX(RANDOM_BYTES(8)) as random_hex_16_chars,   -- 8字节=16个十六进制字符
    HEX(RANDOM_BYTES(32)) as random_hex_64_chars;  -- 32字节=64个十六进制字符
```

**🔒 生成安全令牌**：

```sql
-- 创建用户会话表
CREATE TABLE user_sessions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    session_token VARCHAR(64),  -- 存储十六进制令牌
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    INDEX idx_token (session_token),
    INDEX idx_user (user_id)
);

-- 生成用户会话
INSERT INTO user_sessions (user_id, session_token, expires_at)
VALUES (
    1,
    HEX(RANDOM_BYTES(32)),  -- 生成64字符的随机令牌
    DATE_ADD(NOW(), INTERVAL 24 HOUR)
);

-- 验证会话令牌
SELECT user_id, created_at
FROM user_sessions 
WHERE session_token = ? 
  AND expires_at > NOW();
```

### 8.4 随机数据生成应用


**🎲 生成各种随机标识符**：

```sql
-- 创建随机标识符生成函数
DELIMITER //
CREATE FUNCTION GenerateRandomID(length INT)
RETURNS VARCHAR(255)
READS SQL DATA
DETERMINISTIC
BEGIN
    RETURN LEFT(HEX(RANDOM_BYTES(CEIL(length/2))), length);
END //

CREATE FUNCTION GenerateSecureSalt()
RETURNS VARCHAR(32)
READS SQL DATA
DETERMINISTIC
BEGIN
    RETURN HEX(RANDOM_BYTES(16));
END //
DELIMITER ;

-- 使用随机函数
SELECT 
    GenerateRandomID(10) as short_id,
    GenerateRandomID(20) as medium_id,
    GenerateSecureSalt() as secure_salt;
```

**💳 生成测试数据**：

```sql
-- 为开发环境生成测试用户
INSERT INTO test_users (username, email, password_hash, salt)
SELECT 
    CONCAT('user_', GenerateRandomID(8)) as username,
    CONCAT(GenerateRandomID(6), '@test.com') as email,
    SHA2(CONCAT('testpass', GenerateSecureSalt()), 256) as password_hash,
    GenerateSecureSalt() as salt
FROM (
    SELECT 1 as n UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5
) numbers;
```

**💡 随机数据使用建议**：
```
🔸 安全用途：
- 会话令牌生成
- 密码重置令牌
- API密钥生成
- 加密盐值

🔸 测试用途：
- 生成测试数据
- 创建唯一标识符
- 模拟随机用户行为

🔸 注意事项：
- RANDOM_BYTES是密码学安全的
- 每次调用都产生不同结果
- 适合对安全性有要求的场景
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 加密哈希基础：单向函数，固定输出，微小变化导致巨大差异
🔸 安全级别认知：MD5 < SHA1 < SHA2，现代应用推荐SHA-256
🔸 对称加密原理：同一密钥加密解密，AES比DES更安全
🔸 编码vs加密：编码是格式转换，加密是安全保护
🔸 压缩优化：适合重复数据，需权衡CPU与存储
🔸 校验与随机：CRC32快速校验，RANDOM_BYTES安全随机
```

### 9.2 实际应用指导


**🎯 函数选择决策表**：

| 使用场景 | 推荐函数 | 安全级别 | 说明 |
|----------|----------|----------|------|
| 🔐 **密码存储** | SHA2(256) + 盐 | ⭐⭐⭐⭐⭐ | 现代标准 |
| 📝 **数据校验** | MD5或SHA1 | ⭐⭐⭐ | 非安全场景可用 |
| 🔒 **敏感数据** | AES_ENCRYPT/DECRYPT | ⭐⭐⭐⭐⭐ | 可逆加密 |
| 🎲 **随机令牌** | RANDOM_BYTES | ⭐⭐⭐⭐⭐ | 密码学安全 |
| 📦 **大文本存储** | COMPRESS/UNCOMPRESS | ⭐⭐⭐ | 节省空间 |

**🛡️ 安全最佳实践**：

```
密码存储安全准则：
✅ 使用SHA-256或更强算法
✅ 每个密码使用不同随机盐
✅ 盐值长度至少16字节
✅ 考虑使用专门的密码库（如bcrypt）

数据加密准则：
✅ 敏感数据使用AES加密
✅ 密钥独立于数据存储
✅ 定期轮换加密密钥
✅ 记录加密策略文档

性能优化准则：
✅ 只对必要数据进行加密/哈希
✅ 合理使用压缩功能
✅ 为哈希字段建立索引
✅ 在应用层处理复杂加密逻辑
```

### 9.3 实际应用价值


**💼 业务场景应用**：
- **用户认证系统**：SHA-256+盐存储密码，RANDOM_BYTES生成会话令牌
- **数据完整性保护**：CRC32快速校验，MD5/SHA用于重要数据
- **敏感信息存储**：AES加密个人信息，信用卡数据等
- **大数据存储优化**：COMPRESS压缩日志文件，节省存储成本
- **API安全设计**：RANDOM_BYTES生成API密钥，SHA-256验证请求

**🔧 开发实践要点**：
- **选择合适算法**：根据安全需求选择函数，不盲目使用
- **密钥管理规范**：建立完善的密钥生成、存储、轮换机制
- **性能监控调优**：监控加密操作对数据库性能的影响
- **法规合规遵守**：了解数据保护法规，确保加密方案合规

**核心记忆口诀**：
- 哈希单向不可逆，校验数据用CRC
- SHA胜过MD5强，密码存储加点盐
- AES加密最安全，对称密钥要管好  
- 压缩节省存储空间，随机字节保安全