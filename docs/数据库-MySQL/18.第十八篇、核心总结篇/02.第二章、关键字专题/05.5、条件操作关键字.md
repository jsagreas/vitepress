---
title: 5、条件操作关键字
---
## 📚 目录

1. [逻辑运算符](#1-逻辑运算符)
2. [范围与包含运算符](#2-范围与包含运算符)
3. [模式匹配运算符](#3-模式匹配运算符)
4. [空值处理运算符](#4-空值处理运算符)
5. [存在性检查运算符](#5-存在性检查运算符)
6. [量化比较运算符](#6-量化比较运算符)
7. [逻辑值与特殊匹配](#7-逻辑值与特殊匹配)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔗 逻辑运算符


### 1.1 AND 逻辑与


**💡 概念含义**  
AND就像现实中的"**并且**"，要求**所有条件同时满足**才算成功。想象一下招聘要求："需要本科学历**并且**有3年工作经验**并且**会使用Python"，只有三个条件都满足才能应聘成功。

**🎯 工作原理**
```
AND运算真值表：
条件A | 条件B | 结果
-----|-------|-----
 真   |  真   | 真 ✅
 真   |  假   | 假 ❌  
 假   |  真   | 假 ❌
 假   |  假   | 假 ❌
```

**⚡ 实际应用示例**
```sql
-- 查找年龄在25到35岁之间，并且薪资大于8000的员工
SELECT * FROM employees 
WHERE age >= 25 AND age <= 35 AND salary > 8000;

-- 查找特定部门的高级员工
SELECT * FROM employees 
WHERE department = 'IT' AND position = 'Senior' AND status = 'Active';
```

**🔧 使用技巧**
- AND条件**从左到右**逐个检查，第一个假条件会**短路**后续检查
- 把最容易为假的条件放在前面，提高查询效率
- 多个AND条件可以用括号分组，让逻辑更清晰

### 1.2 OR 逻辑或


**💡 概念含义**  
OR就像现实中的"**或者**"，只要**任意一个条件满足**就算成功。比如电影票优惠："学生**或者**老人**或者**军人可享受半价"，满足其中任何一个身份就能享受优惠。

**🎯 工作原理**
```
OR运算真值表：
条件A | 条件B | 结果
-----|-------|-----
 真   |  真   | 真 ✅
 真   |  假   | 真 ✅
 假   |  真   | 真 ✅
 假   |  假   | 假 ❌
```

**⚡ 实际应用示例**
```sql
-- 查找IT部门或销售部门的员工
SELECT * FROM employees 
WHERE department = 'IT' OR department = 'Sales';

-- 查找高薪或高职位的员工
SELECT * FROM employees 
WHERE salary > 15000 OR position LIKE '%Manager%' OR position LIKE '%Director%';
```

**🔧 使用技巧**
- OR条件找到第一个真值就会**短路**停止检查
- 把最可能为真的条件放在前面
- 复杂OR条件建议用IN替代：`department IN ('IT', 'Sales')`

### 1.3 NOT 逻辑非


**💡 概念含义**  
NOT就像现实中的"**不是**"、"**除了**"，表示**相反的条件**。比如："招聘除了实习生以外的所有员工"，就是要"**不是**实习生"的员工。

**🎯 工作原理**
```
NOT运算真值表：
原条件 | NOT结果
------|--------
  真   |   假 ❌
  假   |   真 ✅
```

**⚡ 实际应用示例**
```sql
-- 查找不在IT部门的员工
SELECT * FROM employees 
WHERE NOT department = 'IT';
-- 等同于：WHERE department != 'IT'

-- 查找没有离职的员工
SELECT * FROM employees 
WHERE NOT status = 'Terminated';

-- 查找年龄不在30-40岁的员工
SELECT * FROM employees 
WHERE NOT (age >= 30 AND age <= 40);
```

**🔧 使用技巧**
- `NOT =` 通常可以用 `!=` 或 `<>` 替代
- 注意NULL值的特殊处理：`NOT NULL` 仍然是NULL
- 复杂条件用NOT时要加括号避免歧义

---

## 2. 📊 范围与包含运算符


### 2.1 IN 包含于


**💡 概念含义**  
IN就像现实中的"**属于这个名单**"。想象一个VIP客户名单，只要客户ID在这个名单里，就享受特殊服务。IN检查某个值是否**存在于指定的值列表中**。

**🎯 工作原理**
```
IN运算逻辑：
值 IN (值1, 值2, 值3, ...)
相当于：值 = 值1 OR 值 = 值2 OR 值 = 值3 OR ...
```

**⚡ 实际应用示例**
```sql
-- 查找特定部门的员工
SELECT * FROM employees 
WHERE department IN ('IT', 'Sales', 'Marketing');

-- 查找特定等级的产品
SELECT * FROM products 
WHERE category_id IN (1, 3, 5, 7);

-- 使用子查询的IN
SELECT * FROM orders 
WHERE customer_id IN (
    SELECT id FROM customers WHERE city = 'Beijing'
);
```

**🔧 使用技巧**
- IN比多个OR条件**更简洁易读**
- 支持**子查询**：`IN (SELECT ...)`
- 空列表 `IN ()` 永远返回FALSE
- NULL值需要特别注意：`NULL IN (1,2,3)` 结果是NULL

### 2.2 BETWEEN 范围内


**💡 概念含义**  
BETWEEN就像现实中的"**在...之间**"。比如说"年龄在18到65岁之间可以工作"，BETWEEN用来检查某个值是否**落在指定的范围内**（包含边界值）。

**🎯 工作原理**
```
BETWEEN语法：
值 BETWEEN 最小值 AND 最大值
相当于：值 >= 最小值 AND 值 <= 最大值

注意：包含边界值（闭区间）
```

**⚡ 实际应用示例**
```sql
-- 查找特定年龄段的员工
SELECT * FROM employees 
WHERE age BETWEEN 25 AND 35;

-- 查找特定价格区间的产品
SELECT * FROM products 
WHERE price BETWEEN 100.00 AND 500.00;

-- 查找特定日期范围的订单
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';

-- NOT BETWEEN 排除范围
SELECT * FROM employees 
WHERE salary NOT BETWEEN 5000 AND 8000;
```

**🔧 使用技巧**
- BETWEEN**包含边界值**（25和35都会被包含）
- 对于日期范围，注意时间部分：`'2024-01-01 00:00:00'` 到 `'2024-01-01 23:59:59'`
- 字符串也可以用BETWEEN：`name BETWEEN 'A' AND 'M'`

---

## 3. 🔍 模式匹配运算符


### 3.1 LIKE 模糊匹配


**💡 概念含义**  
LIKE就像现实中的"**模糊搜索**"。当你在搜索引擎输入"苹果手机"时，会找到包含这些字的所有结果。LIKE用来**模糊匹配文本模式**，不需要完全相同。

**🎯 通配符说明**
```
LIKE通配符：
% ：匹配任意长度的字符串（包括空串）
_ ：匹配单个字符

模式示例：
'张%'     → 以"张"开头的所有字符串
'%明'     → 以"明"结尾的所有字符串  
'%李%'    → 包含"李"的所有字符串
'张_'     → "张"后面跟一个字符（如：张三、张四）
'__部门'  → 四个字符，以"部门"结尾（如：技术部门、销售部门）
```

**⚡ 实际应用示例**
```sql
-- 查找姓张的员工
SELECT * FROM employees WHERE name LIKE '张%';

-- 查找包含"经理"职位的员工
SELECT * FROM employees WHERE position LIKE '%经理%';

-- 查找手机号以138开头的客户
SELECT * FROM customers WHERE phone LIKE '138%';

-- 查找邮箱是gmail的用户
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- 查找产品名称为三个字符的
SELECT * FROM products WHERE name LIKE '___';
```

**⚠️ 注意事项**
- LIKE区分大小写（某些数据库不区分）
- 特殊字符需要转义：`LIKE '50\%优惠' ESCAPE '\'`
- 通配符在开头会**影响索引效率**：`'%张'` 比 `'张%'` 慢

### 3.2 REGEXP/RLIKE 正则表达式


**💡 概念含义**  
REGEXP就像**高级的模式匹配**，比LIKE更强大。如果LIKE是普通搜索，那REGEXP就是**专业搜索工具**，可以用复杂的规则来匹配文本模式。

**🎯 常用正则模式**
```
基础正则符号：
^     → 字符串开头
$     → 字符串结尾  
.     → 任意单个字符
*     → 前面字符重复0次或多次
+     → 前面字符重复1次或多次
?     → 前面字符重复0次或1次
[abc] → 匹配a或b或c
[0-9] → 匹配任意数字
\d    → 匹配数字（部分数据库支持）
```

**⚡ 实际应用示例**
```sql
-- 查找手机号格式正确的客户（11位数字）
SELECT * FROM customers 
WHERE phone REGEXP '^[0-9]{11}$';

-- 查找邮箱格式的用户
SELECT * FROM users 
WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- 查找包含数字的产品名称
SELECT * FROM products 
WHERE name REGEXP '[0-9]';

-- 查找以A、B、C开头的客户名称
SELECT * FROM customers 
WHERE name REGEXP '^[ABC]';
```

**🔧 使用建议**
- REGEXP功能强大但**性能开销大**，简单匹配优先用LIKE
- 不同数据库的正则语法略有差异
- 复杂正则表达式建议先测试验证

---

## 4. ⚪ 空值处理运算符


### 4.1 IS 空值判断


**💡 概念含义**  
IS专门用来**检查空值**。为什么不能用等号呢？因为NULL是"**未知**"的意思，任何值与NULL比较都是未知的，包括NULL本身。所以必须用专门的IS来判断。

**🎯 空值判断语法**
```
正确的空值检查：
IS NULL     → 判断是否为空
IS NOT NULL → 判断是否不为空

错误的方式：
= NULL      → 永远返回NULL（未知）
!= NULL     → 永远返回NULL（未知）
```

**⚡ 实际应用示例**
```sql
-- 查找没有填写邮箱的用户
SELECT * FROM users WHERE email IS NULL;

-- 查找已经填写了手机号的客户
SELECT * FROM customers WHERE phone IS NOT NULL;

-- 查找没有分配部门的员工
SELECT * FROM employees WHERE department IS NULL;

-- 统计空值数量
SELECT COUNT(*) as total_users,
       COUNT(email) as users_with_email,
       COUNT(*) - COUNT(email) as users_without_email
FROM users;
```

### 4.2 NULL 空值概念


**💡 概念含义**  
NULL不是**空字符串**，不是**0**，而是表示"**数据缺失**"或"**未知值**"。就像调查问卷中有人没有回答某个问题，这个答案就是NULL - 我们不知道他的想法。

**🎯 NULL的特殊性质**
```
NULL的运算规律：
NULL + 任何值 = NULL
NULL - 任何值 = NULL  
NULL * 任何值 = NULL
NULL / 任何值 = NULL
NULL = NULL 的结果是NULL（不是TRUE）
NULL != NULL 的结果是NULL（不是TRUE）

NULL在逻辑运算中：
TRUE AND NULL = NULL
FALSE AND NULL = FALSE
TRUE OR NULL = TRUE  
FALSE OR NULL = NULL
```

**⚡ 实际应用示例**
```sql
-- 用COALESCE处理NULL值
SELECT name, 
       COALESCE(email, '未填写') as email_status,
       COALESCE(phone, '未填写') as phone_status
FROM users;

-- 用IFNULL/ISNULL处理NULL（MySQL语法）
SELECT name,
       IFNULL(salary, 0) as salary_display
FROM employees;

-- 计算时排除NULL值
SELECT AVG(salary) FROM employees;  -- 自动排除NULL值
SELECT COUNT(email) FROM users;     -- 只计算非NULL值
```

**🔧 处理建议**
- 设计表时尽量避免允许NULL，用默认值代替
- 查询时始终考虑NULL值的影响
- 使用聚合函数时注意NULL值会被忽略

---

## 5. ✅ 存在性检查运算符


### 5.1 EXISTS 存在性检查


**💡 概念含义**  
EXISTS就像现实中的"**确认存在**"。比如在图书馆查询："是否存在这个作者写的书？"不关心具体有几本，只关心**有还是没有**。EXISTS检查子查询**是否返回至少一行数据**。

**🎯 工作原理**
```
EXISTS运算逻辑：
EXISTS (子查询) 
→ 如果子查询返回至少1行：TRUE
→ 如果子查询返回0行：FALSE

NOT EXISTS (子查询)
→ 与EXISTS相反
```

**⚡ 实际应用示例**
```sql
-- 查找有订单的客户
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.id
);

-- 查找没有订单的客户  
SELECT * FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.id
);

-- 查找有员工的部门
SELECT * FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e 
    WHERE e.department_id = d.id
);
```

**🔧 性能优化技巧**
- EXISTS只关心**是否存在**，所以子查询用`SELECT 1`比`SELECT *`更高效
- EXISTS通常比IN性能更好，特别是大数据量时
- EXISTS可以处理NULL值，而IN遇到NULL可能有意外结果

---

## 6. 🔢 量化比较运算符


### 6.1 ANY 任意一个


**💡 概念含义**  
ANY就像现实中的"**只要有一个满足就行**"。比如："薪资比任意一个销售员工高就算高薪员工"，只要比其中任何一个销售员工薪资高即可。

**🎯 工作原理**
```
ANY运算逻辑：
值 > ANY (子查询结果集)
→ 只要大于结果集中任意一个值就为TRUE
→ 相当于：值 > MIN(子查询结果集)

值 = ANY (子查询结果集)  
→ 相当于：值 IN (子查询结果集)
```

**⚡ 实际应用示例**
```sql
-- 查找薪资比任意一个经理高的员工
SELECT * FROM employees 
WHERE salary > ANY (
    SELECT salary FROM employees 
    WHERE position LIKE '%经理%'
);

-- 查找销量比任意一个销售员工好的员工
SELECT * FROM employees 
WHERE sales_amount > ANY (
    SELECT sales_amount FROM employees 
    WHERE department = 'Sales'
);
```

### 6.2 ALL 全部


**💡 概念含义**  
ALL就像现实中的"**必须全部满足**"。比如："薪资比所有销售员工都高才算真正的高薪"，必须比每一个销售员工的薪资都高。

**🎯 工作原理**
```
ALL运算逻辑：
值 > ALL (子查询结果集)
→ 必须大于结果集中所有值才为TRUE
→ 相当于：值 > MAX(子查询结果集)

值 < ALL (子查询结果集)
→ 必须小于结果集中所有值才为TRUE  
→ 相当于：值 < MIN(子查询结果集)
```

**⚡ 实际应用示例**
```sql
-- 查找薪资比所有经理都高的员工
SELECT * FROM employees 
WHERE salary > ALL (
    SELECT salary FROM employees 
    WHERE position LIKE '%经理%'
);

-- 查找年龄比所有实习生都大的员工
SELECT * FROM employees 
WHERE age > ALL (
    SELECT age FROM employees 
    WHERE position = '实习生'
);
```

### 6.3 SOME 部分


**💡 概念含义**  
SOME其实就是**ANY的别名**，功能完全相同。就像"某些"和"任意一些"是同一个意思，SOME和ANY在SQL中是完全等价的。

**⚡ 应用示例**
```sql
-- SOME和ANY完全等价
SELECT * FROM employees 
WHERE salary > SOME (SELECT salary FROM employees WHERE department = 'IT');

-- 等同于
SELECT * FROM employees 
WHERE salary > ANY (SELECT salary FROM employees WHERE department = 'IT');
```

---

## 7. 🎭 逻辑值与特殊匹配


### 7.1 TRUE/FALSE/UNKNOWN 逻辑值


**💡 概念含义**  
在SQL的世界里，除了TRUE（真）和FALSE（假），还有第三种状态：UNKNOWN（未知）。这是因为数据库中存在NULL值，任何涉及NULL的逻辑运算结果都是未知的。

**🎯 三值逻辑系统**
```
SQL中的逻辑值：
TRUE    → 条件成立，包含在结果中
FALSE   → 条件不成立，不包含在结果中  
UNKNOWN → 条件未知，不包含在结果中

关键点：WHERE子句只返回TRUE的行，FALSE和UNKNOWN都会被排除
```

**⚡ 实际示例**
```sql
-- 直接使用逻辑值
SELECT * FROM products WHERE is_active = TRUE;
SELECT * FROM employees WHERE is_manager = FALSE;

-- 逻辑值在计算中的应用
SELECT name, 
       (salary > 10000) as is_high_salary,
       (age < 30) as is_young
FROM employees;
```

### 7.2 SOUNDS 声音匹配


**💡 概念含义**  
SOUNDS LIKE用于**音似匹配**，主要在英文环境中查找发音相似的词。比如查找"Smith"时也能找到"Smyth"。这在处理姓名拼写变体时很有用。

**⚡ 应用示例**
```sql
-- 查找发音相似的姓名（主要用于英文）
SELECT * FROM customers 
WHERE last_name SOUNDS LIKE 'Smith';

-- 可能匹配：Smith, Smyth, Smitt 等
```

**📝 使用说明**
- 主要用于**英文文本**匹配
- 不同数据库实现可能不同
- 中文环境下用途有限

### 7.3 MATCH 全文匹配


**💡 概念含义**  
MATCH AGAINST是**全文搜索**功能，类似于搜索引擎的文本搜索。它不是简单的字符串匹配，而是基于**相关性评分**的智能搜索，能够理解词语的重要性和相关度。

**🎯 全文搜索模式**
```
MATCH AGAINST 搜索模式：

自然语言模式（默认）：
MATCH(列名) AGAINST('搜索词')
→ 按相关性排序，返回评分

布尔模式：  
MATCH(列名) AGAINST('搜索词' IN BOOLEAN MODE)
→ 支持 +必须包含 -必须排除 *通配符

查询扩展模式：
MATCH(列名) AGAINST('搜索词' WITH QUERY EXPANSION)  
→ 自动扩展相关搜索词
```

**⚡ 实际应用示例**
```sql
-- 创建全文索引（MySQL示例）
ALTER TABLE articles ADD FULLTEXT(title, content);

-- 自然语言全文搜索
SELECT *, MATCH(title, content) AGAINST('数据库 优化') as relevance
FROM articles 
WHERE MATCH(title, content) AGAINST('数据库 优化')
ORDER BY relevance DESC;

-- 布尔模式搜索
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('+数据库 +性能 -删除' IN BOOLEAN MODE);

-- 必须包含"数据库"和"性能"，但不能包含"删除"
```

**🔧 使用要点**
- 需要先创建**FULLTEXT索引**
- 对短词（通常<4个字符）可能不起作用
- 返回结果按**相关性评分**排序
- 性能通常比LIKE模糊匹配更好

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🎯 逻辑运算优先级**
```
运算符优先级（从高到低）：
1. () 括号
2. NOT  
3. AND
4. OR

记忆技巧：括号 > 非 > 与 > 或
```

**⚠️ 空值处理要点**
```sql
NULL值的特殊规则：
✅ 正确：WHERE column IS NULL
❌ 错误：WHERE column = NULL

✅ 正确：WHERE column IS NOT NULL  
❌ 错误：WHERE column != NULL

记住：NULL表示未知，任何与NULL的比较都是未知
```

**🔍 性能优化建议**

| 运算符类型 | **性能建议** | **原因说明** |
|-----------|-------------|-------------|
| `AND/OR` | `把选择性高的条件放前面` | `利用短路求值提前结束` |
| `IN` | `优于多个OR条件` | `更简洁，某些情况下更快` |
| `BETWEEN` | `优于>= AND <=` | `语义更清晰，可能有优化` |
| `LIKE` | `避免通配符开头` | `'张%'比'%张'快很多` |
| `EXISTS` | `通常比IN快` | `特别是大数据量时` |
| `REGEXP` | `谨慎使用` | `功能强大但性能开销大` |

### 8.2 实战使用模式


**🔄 常见组合模式**
```sql
-- 模式1：多条件筛选
SELECT * FROM employees 
WHERE department = 'IT' 
  AND (salary BETWEEN 8000 AND 15000)
  AND status = 'Active'
  AND hire_date >= '2020-01-01';

-- 模式2：存在性检查
SELECT c.* FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.id 
    AND o.order_date >= '2024-01-01'
);

-- 模式3：模糊搜索组合
SELECT * FROM products 
WHERE (name LIKE '%手机%' OR description LIKE '%手机%')
  AND price BETWEEN 1000 AND 5000
  AND is_active = TRUE;
```

**🛠️ 调试技巧**
```sql
-- 逐步构建复杂查询
-- 第1步：基础条件
SELECT * FROM table WHERE condition1;

-- 第2步：添加AND条件  
SELECT * FROM table WHERE condition1 AND condition2;

-- 第3步：添加OR条件
SELECT * FROM table WHERE (condition1 AND condition2) OR condition3;

-- 使用COUNT(*)检查结果数量
SELECT COUNT(*) FROM table WHERE your_conditions;
```

### 8.3 最佳实践总结


**✅ 推荐做法**
- 复杂条件用**括号明确优先级**
- 空值检查始终用**IS NULL/IS NOT NULL**
- 大数据量时优先考虑**EXISTS而不是IN**
- **LIKE模糊匹配避免通配符开头**
- 多个值匹配用**IN而不是多个OR**

**❌ 避免错误**
- 不要用`= NULL`检查空值
- 不要忽略NULL值在逻辑运算中的影响
- 不要在大表上使用开头通配符的LIKE
- 不要过度使用正则表达式

**🎯 记忆口诀**
```
AND要全真，OR一真即可
IN比OR简，EXISTS比IN快  
NULL用IS判，等号永不行
LIKE避开头，正则要谨慎
括号明优先，性能要考虑
```

**核心理念**：SQL条件操作符是数据查询的基础工具，理解每个操作符的**真实含义**比记住语法更重要。在实际使用中，始终要考虑**数据特点**、**性能影响**和**逻辑正确性**。