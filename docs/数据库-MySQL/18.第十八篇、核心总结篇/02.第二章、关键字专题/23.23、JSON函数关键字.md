---
title: 23、JSON函数关键字
---
## 📚 目录

1. [JSON函数基础概念](#1-JSON函数基础概念)
2. [数据提取函数](#2-数据提取函数)
3. [数据修改函数](#3-数据修改函数)
4. [数据创建函数](#4-数据创建函数)
5. [验证与检查函数](#5-验证与检查函数)
6. [搜索与分析函数](#6-搜索与分析函数)
7. [聚合函数](#7-聚合函数)
8. [实用工具函数](#8-实用工具函数)
9. [类型转换函数](#9-类型转换函数)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 JSON函数基础概念


### 1.1 什么是MySQL JSON函数


**通俗理解**：
JSON函数就像是专门处理JSON数据的工具箱。想象JSON数据是一个复杂的多层抽屉柜，JSON函数就是各种专用工具，帮你：
- 🔍 **查找工具**：从抽屉里找出想要的东西
- ✏️ **修改工具**：改变抽屉里的内容
- 📦 **组装工具**：制作新的抽屉柜
- ✅ **检验工具**：确认抽屉柜的质量

### 1.2 为什么需要JSON函数


**实际应用场景**：
```
传统关系型数据 vs JSON数据：

用户信息（传统）：
姓名：张三  年龄：25  城市：北京

用户配置（JSON）：
{
  "theme": "dark",
  "languages": ["中文", "English"],
  "preferences": {
    "notification": true,
    "privacy": "high"
  }
}
```

**JSON的优势**：
- 📊 **灵活结构**：可以存储复杂的嵌套数据
- 🔄 **易于扩展**：添加新字段不需要修改表结构
- 🌐 **通用格式**：前端JavaScript直接使用

### 1.3 MySQL JSON支持概览


**核心特性**：
```
MySQL 5.7+：原生JSON数据类型
优势：
• 自动验证JSON格式
• 优化存储空间
• 支持索引查询
• 丰富的操作函数
```

---

## 2. 🔍 数据提取函数


### 2.1 JSON_EXTRACT - JSON数据的万能提取器


**🔸 核心概念**：
`JSON_EXTRACT`就像从复杂的文件柜中精确找出你要的文件。它使用"JSON路径"来定位数据，就像邮政地址一样精确。

**语法格式**：
```sql
JSON_EXTRACT(json_doc, path[, path] ...)
-- 简写语法
json_doc->path  -- 相当于 JSON_EXTRACT(json_doc, path)
```

**📍 路径语法详解**：
```
路径符号说明：
$ = 根节点（整个JSON的起点）
. = 对象成员访问
[] = 数组元素访问
* = 通配符

示例路径：
$.name          -- 根级别的name字段
$.address.city  -- address对象下的city字段
$.hobbies[0]    -- hobbies数组的第一个元素
$.items[*].name -- items数组中所有元素的name字段
```

**💡 实际应用示例**：
```sql
-- 假设有用户表存储JSON配置
CREATE TABLE users (
    id INT PRIMARY KEY,
    profile JSON
);

-- 插入测试数据
INSERT INTO users VALUES (1, '{
  "name": "张三",
  "age": 28,
  "address": {
    "city": "北京",
    "district": "朝阳区"
  },
  "hobbies": ["编程", "阅读", "旅游"]
}');

-- 提取姓名
SELECT JSON_EXTRACT(profile, '$.name') FROM users WHERE id = 1;
-- 结果: "张三" (带引号的JSON字符串)

-- 使用简写语法
SELECT profile->'$.name' FROM users WHERE id = 1;
-- 结果: "张三"

-- 提取嵌套数据
SELECT profile->'$.address.city' FROM users WHERE id = 1;
-- 结果: "北京"

-- 提取数组元素
SELECT profile->'$.hobbies[0]' FROM users WHERE id = 1;
-- 结果: "编程"
```

**⚡ 实用技巧**：
```sql
-- 提取多个路径
SELECT JSON_EXTRACT(profile, '$.name', '$.age') FROM users;
-- 结果: ["张三", 28]

-- 使用通配符提取数组所有元素
SELECT profile->'$.hobbies[*]' FROM users;
-- 结果: ["编程", "阅读", "旅游"]
```

### 2.2 JSON_UNQUOTE - 去掉烦人的引号


**🔸 核心概念**：
`JSON_UNQUOTE`的作用就是把JSON字符串的外层引号去掉，把JSON格式的数据变成普通的MySQL数据。

**为什么需要UNQUOTE？**
```
JSON_EXTRACT返回的是JSON格式：
profile->'$.name' 返回 "张三" （带引号的JSON字符串）

实际应用中我们往往需要纯文本：
JSON_UNQUOTE(profile->'$.name') 返回 张三 （普通字符串）
```

**简写语法**：
```sql
-- 这两种写法完全等价
JSON_UNQUOTE(JSON_EXTRACT(json_doc, path))
json_doc->>path  -- MySQL 5.7+ 的便捷语法
```

**💡 实际应用**：
```sql
-- 在WHERE条件中使用
SELECT * FROM users 
WHERE profile->>'$.name' = '张三';

-- 在字符串拼接中使用
SELECT CONCAT('用户姓名：', profile->>'$.name') FROM users;

-- 数值运算（自动类型转换）
SELECT profile->>'$.age' + 5 AS next_year_age FROM users;
```

### 2.3 JSON_QUOTE - 给数据加上JSON包装


**🔸 核心概念**：
`JSON_QUOTE`的作用是把普通数据包装成JSON格式，主要用于数据预处理和安全性。

**语法格式**：
```sql
JSON_QUOTE(string)
```

**实际用途**：
```sql
-- 处理包含特殊字符的字符串
SELECT JSON_QUOTE('包含"引号"的文本');
-- 结果: "包含\"引号\"的文本"

-- 确保数据符合JSON格式要求
SET @user_input = 'Hello\nWorld';
SELECT JSON_QUOTE(@user_input);
-- 结果: "Hello\\nWorld"
```

---

## 3. ✏️ 数据修改函数


### 3.1 JSON_SET - JSON数据的修改专家


**🔸 核心概念**：
`JSON_SET`就像一个智能编辑器，它可以：
- 🔄 **更新**已存在的数据
- ➕ **添加**不存在的数据
- 📍 **指定位置**精确操作

**语法格式**：
```sql
JSON_SET(json_doc, path, val[, path, val] ...)
```

**💡 实际应用示例**：
```sql
SET @json = '{"name": "张三", "age": 25}';

-- 修改已存在的字段
SELECT JSON_SET(@json, '$.age', 28);
-- 结果: {"age": 28, "name": "张三"}

-- 添加新字段
SELECT JSON_SET(@json, '$.city', '北京');
-- 结果: {"age": 25, "city": "北京", "name": "张三"}

-- 同时操作多个字段
SELECT JSON_SET(@json, '$.age', 28, '$.city', '北京', '$.status', 'active');
-- 结果: {"age": 28, "city": "北京", "name": "张三", "status": "active"}
```

**🔄 数组操作示例**：
```sql
SET @json = '{"hobbies": ["编程", "阅读"]}';

-- 修改数组指定位置
SELECT JSON_SET(@json, '$.hobbies[1]', '写作');
-- 结果: {"hobbies": ["编程", "写作"]}

-- 添加数组元素（超出索引会自动扩展，中间填null）
SELECT JSON_SET(@json, '$.hobbies[3]', '旅游');
-- 结果: {"hobbies": ["编程", "阅读", null, "旅游"]}
```

### 3.2 JSON_INSERT - 只添加不覆盖


**🔸 核心概念**：
`JSON_INSERT`是"安全插入"，只在路径不存在时才添加数据，已存在的数据不会被覆盖。

**与JSON_SET的区别**：
```sql
SET @json = '{"name": "张三", "age": 25}';

-- JSON_SET：总是设置值（更新或新增）
SELECT JSON_SET(@json, '$.age', 30, '$.city', '北京');
-- 结果: {"age": 30, "city": "北京", "name": "张三"}  -- age被更新

-- JSON_INSERT：只在不存在时添加
SELECT JSON_INSERT(@json, '$.age', 30, '$.city', '北京');
-- 结果: {"age": 25, "city": "北京", "name": "张三"}  -- age保持原值
```

**💡 实际应用场景**：
```sql
-- 用户配置初始化（不覆盖已有配置）
UPDATE users 
SET profile = JSON_INSERT(
    profile, 
    '$.theme', 'light',           -- 默认主题
    '$.notifications', true,      -- 默认通知开启
    '$.language', 'zh-CN'        -- 默认语言
) 
WHERE id = 1;
```

### 3.3 JSON_REPLACE - 只替换已存在的


**🔸 核心概念**：
`JSON_REPLACE`是"安全替换"，只替换已存在的路径，不会添加新的路径。

**语法特点**：
```sql
SET @json = '{"name": "张三", "age": 25}';

-- 只替换存在的字段
SELECT JSON_REPLACE(@json, '$.age', 30, '$.city', '北京');
-- 结果: {"age": 30, "name": "张三"}  -- city不会被添加
```

**⚡ 三个修改函数对比**：

| 函数 | **已存在路径** | **不存在路径** | **使用场景** |
|------|----------------|----------------|--------------|
| `JSON_SET` | `✅ 替换` | `✅ 添加` | `通用修改` |
| `JSON_INSERT` | `❌ 保留原值` | `✅ 添加` | `初始化设置` |
| `JSON_REPLACE` | `✅ 替换` | `❌ 忽略` | `安全更新` |

### 3.4 JSON_REMOVE - 删除不需要的数据


**🔸 核心概念**：
`JSON_REMOVE`用于删除JSON中的指定路径，支持同时删除多个路径。

**语法格式**：
```sql
JSON_REMOVE(json_doc, path[, path] ...)
```

**💡 实际应用**：
```sql
SET @json = '{"name": "张三", "age": 25, "temp": "临时数据", "hobbies": ["编程", "阅读", "旅游"]}';

-- 删除单个字段
SELECT JSON_REMOVE(@json, '$.temp');
-- 结果: {"age": 25, "hobbies": ["编程", "阅读", "旅游"], "name": "张三"}

-- 删除多个字段
SELECT JSON_REMOVE(@json, '$.temp', '$.age');
-- 结果: {"hobbies": ["编程", "阅读", "旅游"], "name": "张三"}

-- 删除数组元素
SELECT JSON_REMOVE(@json, '$.hobbies[1]');
-- 结果: {"age": 25, "hobbies": ["编程", "旅游"], "name": "张三", "temp": "临时数据"}
```

**⚠️ 注意事项**：
```sql
-- 删除不存在的路径不会报错
SELECT JSON_REMOVE(@json, '$.nonexistent');
-- 结果: 返回原JSON（不变）

-- 数组删除后会自动调整索引
SET @arr = '["A", "B", "C", "D"]';
SELECT JSON_REMOVE(@arr, '$[1]');  -- 删除B
-- 结果: ["A", "C", "D"]  -- C和D的索引自动前移
```

---

## 4. 🔄 JSON合并函数


### 4.1 JSON_MERGE_PRESERVE - 保留式合并


**🔸 核心概念**：
`JSON_MERGE_PRESERVE`会保留所有数据，重复的键会合并成数组。这是一种"不丢失任何信息"的合并方式。

**合并规则**：
```
对象 + 对象 = 合并对象（重复键变数组）
数组 + 数组 = 连接数组
对象 + 数组 = 将对象加入数组
标量 + 标量 = 合并成数组
```

**💡 实际应用示例**：
```sql
-- 对象合并（不同键）
SELECT JSON_MERGE_PRESERVE('{"a": 1}', '{"b": 2}');
-- 结果: {"a": 1, "b": 2}

-- 对象合并（相同键）
SELECT JSON_MERGE_PRESERVE('{"a": 1}', '{"a": 2}');
-- 结果: {"a": [1, 2]}  -- 相同键合并为数组

-- 数组合并
SELECT JSON_MERGE_PRESERVE('[1, 2]', '[3, 4]');
-- 结果: [1, 2, 3, 4]

-- 复杂示例：用户权限合并
SET @user_perms = '{"read": ["posts"], "write": ["comments"]}';
SET @role_perms = '{"read": ["users"], "admin": ["settings"]}';
SELECT JSON_MERGE_PRESERVE(@user_perms, @role_perms);
-- 结果: {"admin": ["settings"], "read": ["posts", "users"], "write": ["comments"]}
```

### 4.2 JSON_MERGE_PATCH - 补丁式合并


**🔸 核心概念**：
`JSON_MERGE_PATCH`遵循RFC 7396标准，后面的值会覆盖前面的值，主要用于配置更新场景。

**合并规则**：
```
• 相同键：后面的值完全覆盖前面的值
• null值：删除对应的键
• 嵌套对象：递归合并
```

**💡 实际应用示例**：
```sql
-- 简单覆盖
SELECT JSON_MERGE_PATCH('{"a": 1}', '{"a": 2}');
-- 结果: {"a": 2}  -- 覆盖，不是数组

-- 使用null删除键
SELECT JSON_MERGE_PATCH('{"a": 1, "b": 2}', '{"a": null}');
-- 结果: {"b": 2}  -- a被删除

-- 配置更新场景
SET @old_config = '{"theme": "light", "lang": "en", "notifications": {"email": true, "sms": false}}';
SET @updates = '{"theme": "dark", "notifications": {"email": false}}';
SELECT JSON_MERGE_PATCH(@old_config, @updates);
-- 结果: {"lang": "en", "notifications": {"email": false, "sms": false}, "theme": "dark"}
```

### 4.3 JSON_MERGE - 传统合并（已弃用）


**⚠️ 重要说明**：
`JSON_MERGE`在MySQL 8.0中已被弃用，推荐使用`JSON_MERGE_PRESERVE`替代。

**🔄 合并函数对比**：

| 场景 | **JSON_MERGE_PRESERVE** | **JSON_MERGE_PATCH** |
|------|-------------------------|----------------------|
| `配置更新` | `保留历史值（数组）` | `✅ 覆盖更新` |
| `数据合并` | `✅ 保留所有信息` | `可能丢失数据` |
| `权限累积` | `✅ 权限叠加` | `权限覆盖` |
| `标准兼容` | `MySQL特有` | `✅ RFC 7396标准` |

---

## 5. 📦 数据创建函数


### 5.1 JSON_ARRAY - 快速创建数组


**🔸 核心概念**：
`JSON_ARRAY`就像一个智能打包机，把多个值自动包装成JSON数组格式。

**语法格式**：
```sql
JSON_ARRAY([val[, val] ...])
```

**💡 实际应用示例**：
```sql
-- 创建简单数组
SELECT JSON_ARRAY(1, 2, 3, 'hello');
-- 结果: [1, 2, 3, "hello"]

-- 创建空数组
SELECT JSON_ARRAY();
-- 结果: []

-- 处理NULL值
SELECT JSON_ARRAY(1, NULL, 3);
-- 结果: [1, null, 3]  -- NULL自动转为JSON null

-- 在查询中使用
SELECT 
    name,
    JSON_ARRAY(phone, email) as contacts
FROM users;
```

**🔄 动态数组创建**：
```sql
-- 根据条件创建数组
SELECT 
    JSON_ARRAY(
        IF(phone IS NOT NULL, phone, NULL),
        IF(email IS NOT NULL, email, NULL)
    ) as available_contacts
FROM users;
```

### 5.2 JSON_OBJECT - 快速创建对象


**🔸 核心概念**：
`JSON_OBJECT`像一个键值对组装器，把成对的参数自动组装成JSON对象。

**语法格式**：
```sql
JSON_OBJECT([key, val[, key, val] ...])
```

**💡 实际应用示例**：
```sql
-- 创建简单对象
SELECT JSON_OBJECT('name', '张三', 'age', 25);
-- 结果: {"age": 25, "name": "张三"}

-- 创建空对象
SELECT JSON_OBJECT();
-- 结果: {}

-- 在查询中动态创建对象
SELECT 
    JSON_OBJECT(
        'id', id,
        'name', name,
        'age', age,
        'created', created_at
    ) as user_json
FROM users;
```

**⚡ 实用技巧**：
```sql
-- 嵌套对象创建
SELECT JSON_OBJECT(
    'user', JSON_OBJECT('name', '张三', 'age', 25),
    'settings', JSON_OBJECT('theme', 'dark', 'lang', 'zh')
);
-- 结果: {"settings": {"lang": "zh", "theme": "dark"}, "user": {"age": 25, "name": "张三"}}

-- 条件键值对
SELECT JSON_OBJECT(
    'name', name,
    'phone', IF(phone_public = 1, phone, NULL),
    'email', IF(email_public = 1, email, NULL)
) FROM users;
```

---

## 6. ✅ 验证与检查函数


### 6.1 JSON_VALID - JSON格式验证器


**🔸 核心概念**：
`JSON_VALID`就像一个JSON格式检查员，判断给定的文本是否符合JSON语法规范。

**语法格式**：
```sql
JSON_VALID(val)
-- 返回: 1（有效）或 0（无效）
```

**💡 实际应用示例**：
```sql
-- 基本验证
SELECT JSON_VALID('{"name": "张三"}');  -- 结果: 1
SELECT JSON_VALID('{"name": 张三}');    -- 结果: 0（缺少引号）
SELECT JSON_VALID('[1, 2, 3]');       -- 结果: 1
SELECT JSON_VALID('[1, 2, 3,]');      -- 结果: 0（多余逗号）

-- 在数据导入时验证
SELECT 
    raw_data,
    JSON_VALID(raw_data) as is_valid_json
FROM import_table
WHERE JSON_VALID(raw_data) = 0;  -- 找出无效的JSON
```

**🛠️ 实际应用场景**：
```sql
-- 数据清洗：过滤无效JSON
CREATE TABLE clean_data AS
SELECT * FROM raw_data 
WHERE JSON_VALID(json_column) = 1;

-- 约束检查：确保字段是有效JSON
ALTER TABLE user_profiles 
ADD CONSTRAINT check_valid_json 
CHECK (JSON_VALID(profile_data) = 1);
```

### 6.2 JSON_TYPE - 数据类型识别器


**🔸 核心概念**：
`JSON_TYPE`告诉你JSON值的具体类型，就像一个数据类型探测器。

**返回值类型**：
```
NULL      - JSON null值
BOOLEAN   - 布尔值（true/false）
INTEGER   - 整数
DECIMAL   - 小数
STRING    - 字符串
ARRAY     - 数组
OBJECT    - 对象
```

**💡 实际应用示例**：
```sql
-- 检测不同类型
SELECT JSON_TYPE('null');          -- 结果: NULL
SELECT JSON_TYPE('true');          -- 结果: BOOLEAN
SELECT JSON_TYPE('123');           -- 结果: INTEGER
SELECT JSON_TYPE('123.45');        -- 结果: DECIMAL
SELECT JSON_TYPE('"hello"');       -- 结果: STRING
SELECT JSON_TYPE('[1,2,3]');       -- 结果: ARRAY
SELECT JSON_TYPE('{"a": 1}');      -- 结果: OBJECT

-- 检测JSON字段中的数据类型
SELECT 
    JSON_EXTRACT(profile, '$.age') as age_value,
    JSON_TYPE(JSON_EXTRACT(profile, '$.age')) as age_type
FROM users;
```

**🔄 类型判断应用**：
```sql
-- 根据类型执行不同操作
SELECT 
    CASE JSON_TYPE(profile->'$.preferences')
        WHEN 'OBJECT' THEN '复杂配置'
        WHEN 'ARRAY' THEN '列表配置'  
        WHEN 'STRING' THEN '简单配置'
        ELSE '未知配置'
    END as config_type
FROM users;
```

### 6.3 JSON_CONTAINS - 包含关系检查


**🔸 核心概念**：
`JSON_CONTAINS`检查一个JSON是否包含另一个JSON，就像检查大箱子里是否装着小箱子。

**语法格式**：
```sql
JSON_CONTAINS(target, candidate[, path])
-- 返回: 1（包含）或 0（不包含）
```

**包含规则**：
```
数组包含：目标数组包含候选数组的所有元素
对象包含：目标对象包含候选对象的所有键值对
标量包含：值完全相等
```

**💡 实际应用示例**：
```sql
-- 数组包含检查
SELECT JSON_CONTAINS('[1, 2, 3, 4]', '[2, 3]');  -- 结果: 1
SELECT JSON_CONTAINS('[1, 2, 3, 4]', '[2, 5]');  -- 结果: 0

-- 对象包含检查
SELECT JSON_CONTAINS(
    '{"name": "张三", "age": 25, "city": "北京"}',
    '{"name": "张三", "age": 25}'
);  -- 结果: 1

-- 在指定路径检查
SET @json = '{"users": [{"name": "张三", "role": "admin"}, {"name": "李四", "role": "user"}]}';
SELECT JSON_CONTAINS(@json, '{"role": "admin"}', '$.users[0]');  -- 结果: 1
```

**🔍 实际查询应用**：
```sql
-- 查找具有特定权限的用户
SELECT * FROM users 
WHERE JSON_CONTAINS(permissions, '["read", "write"]');

-- 查找包含特定配置的用户
SELECT * FROM users 
WHERE JSON_CONTAINS(profile, '{"notifications": {"email": true}}');
```

### 6.4 JSON_CONTAINS_PATH - 路径存在检查


**🔸 核心概念**：
`JSON_CONTAINS_PATH`检查JSON中是否存在指定路径，就像检查文件夹结构中是否存在某个目录。

**语法格式**：
```sql
JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] ...)
-- one_or_all: 'one'（任一存在）或 'all'（全部存在）
```

**💡 实际应用示例**：
```sql
SET @json = '{"name": "张三", "address": {"city": "北京", "district": "朝阳区"}}';

-- 检查单个路径
SELECT JSON_CONTAINS_PATH(@json, 'one', '$.name');         -- 结果: 1
SELECT JSON_CONTAINS_PATH(@json, 'one', '$.phone');        -- 结果: 0

-- 检查多个路径（任一存在）
SELECT JSON_CONTAINS_PATH(@json, 'one', '$.name', '$.phone');  -- 结果: 1

-- 检查多个路径（全部存在）  
SELECT JSON_CONTAINS_PATH(@json, 'all', '$.name', '$.address.city');  -- 结果: 1
SELECT JSON_CONTAINS_PATH(@json, 'all', '$.name', '$.phone');          -- 结果: 0
```

**🛠️ 数据质量检查应用**：
```sql
-- 检查必填字段是否完整
SELECT 
    id,
    JSON_CONTAINS_PATH(profile, 'all', '$.name', '$.email', '$.phone') as profile_complete
FROM users;

-- 查找缺少关键信息的记录
SELECT * FROM users 
WHERE JSON_CONTAINS_PATH(profile, 'one', '$.email', '$.phone') = 0;
```

---

## 7. 🔎 搜索与分析函数


### 7.1 JSON_KEYS - 获取对象键名


**🔸 核心概念**：
`JSON_KEYS`就像一个钥匙提取器，从JSON对象中提取出所有的键名，返回一个包含键名的数组。

**语法格式**：
```sql
JSON_KEYS(json_doc[, path])
```

**💡 实际应用示例**：
```sql
SET @json = '{"name": "张三", "age": 25, "city": "北京", "hobbies": ["编程", "阅读"]}';

-- 获取根级别所有键
SELECT JSON_KEYS(@json);
-- 结果: ["age", "city", "hobbies", "name"]

-- 获取嵌套对象的键
SET @nested = '{"user": {"name": "张三", "profile": {"theme": "dark", "lang": "zh"}}}';
SELECT JSON_KEYS(@nested, '$.user.profile');
-- 结果: ["lang", "theme"]
```

**🔄 实际应用场景**：
```sql
-- 动态获取用户配置的所有选项
SELECT 
    id,
    JSON_KEYS(profile, '$.preferences') as available_settings
FROM users;

-- 检查配置完整性
SELECT 
    id,
    JSON_LENGTH(JSON_KEYS(profile)) as config_count,
    profile
FROM users 
WHERE JSON_LENGTH(JSON_KEYS(profile)) < 5;  -- 配置项少于5个的用户
```

### 7.2 JSON_SEARCH - JSON内容搜索


**🔸 核心概念**：
`JSON_SEARCH`是JSON中的搜索引擎，可以查找包含特定值的路径，支持通配符匹配。

**语法格式**：
```sql
JSON_SEARCH(json_doc, one_or_all, search_str[, escape_char[, path] ...])
-- one_or_all: 'one'（找到第一个）或 'all'（找到所有）
-- search_str: 支持通配符 % 和 _
```

**💡 实际应用示例**：
```sql
SET @json = '{
    "users": [
        {"name": "张三", "email": "zhangsan@email.com"},
        {"name": "李四", "email": "lisi@email.com"},
        {"name": "张伟", "email": "zhangwei@email.com"}
    ]
}';

-- 精确搜索
SELECT JSON_SEARCH(@json, 'one', '张三');
-- 结果: "$.users[0].name"

-- 通配符搜索（找所有张姓）
SELECT JSON_SEARCH(@json, 'all', '张%');
-- 结果: ["$.users[0].name", "$.users[2].name"]

-- 在指定路径下搜索
SELECT JSON_SEARCH(@json, 'all', '%@email.com', NULL, '$.users[*].email');
-- 结果: ["$.users[0].email", "$.users[1].email", "$.users[2].email"]
```

**🔍 实际查询应用**：
```sql
-- 搜索包含特定关键词的用户
SELECT 
    id,
    profile,
    JSON_SEARCH(profile, 'all', '%管理%') as admin_paths
FROM users 
WHERE JSON_SEARCH(profile, 'one', '%管理%') IS NOT NULL;
```

### 7.3 JSON_LENGTH - 获取长度信息


**🔸 核心概念**：
`JSON_LENGTH`测量JSON数据的长度，对于不同类型返回不同含义的长度值。

**长度规则**：
```
数组：元素个数
对象：键值对个数  
标量：始终返回1
NULL：返回NULL
```

**💡 实际应用示例**：
```sql
-- 不同类型的长度
SELECT JSON_LENGTH('[1, 2, 3, 4]');           -- 结果: 4（数组元素个数）
SELECT JSON_LENGTH('{"a": 1, "b": 2, "c": 3}'); -- 结果: 3（对象属性个数）
SELECT JSON_LENGTH('"hello"');                -- 结果: 1（标量值）

-- 嵌套路径长度
SET @json = '{"hobbies": ["编程", "阅读", "旅游"], "skills": {"js": 5, "python": 4}}';
SELECT JSON_LENGTH(@json, '$.hobbies');       -- 结果: 3
SELECT JSON_LENGTH(@json, '$.skills');        -- 结果: 2
```

**📊 数据分析应用**：
```sql
-- 分析用户兴趣广度
SELECT 
    AVG(JSON_LENGTH(profile, '$.hobbies')) as avg_hobbies,
    MAX(JSON_LENGTH(profile, '$.hobbies')) as max_hobbies,
    MIN(JSON_LENGTH(profile, '$.hobbies')) as min_hobbies
FROM users 
WHERE JSON_CONTAINS_PATH(profile, 'one', '$.hobbies');

-- 查找配置最丰富的用户
SELECT * FROM users 
ORDER BY JSON_LENGTH(profile) DESC 
LIMIT 10;
```

### 7.4 JSON_DEPTH - 获取嵌套深度


**🔸 核心概念**：
`JSON_DEPTH`测量JSON数据的嵌套层数，就像测量建筑物的楼层高度。

**深度计算**：
```
标量值：深度 1
空数组/对象：深度 1
[1, 2, 3]：深度 2（数组包含标量）
{"a": {"b": 1}}：深度 3（对象嵌套对象）
```

**💡 实际应用示例**：
```sql
-- 不同复杂度的深度
SELECT JSON_DEPTH('1');                    -- 结果: 1
SELECT JSON_DEPTH('[1, 2, 3]');          -- 结果: 2  
SELECT JSON_DEPTH('{"a": {"b": {"c": 1}}}'); -- 结果: 4

-- 分析数据复杂度
SELECT 
    id,
    profile,
    JSON_DEPTH(profile) as complexity
FROM users 
ORDER BY JSON_DEPTH(profile) DESC;
```

**📈 数据复杂度分析**：
```sql
-- 统计不同复杂度的数据分布
SELECT 
    JSON_DEPTH(profile) as depth,
    COUNT(*) as count
FROM users 
GROUP BY JSON_DEPTH(profile)
ORDER BY depth;
```

---

## 8. 📊 聚合函数


### 8.1 JSON_ARRAYAGG - 数组聚合函数


**🔸 核心概念**：
`JSON_ARRAYAGG`就像一个收集器，把查询结果中的多个值收集成一个JSON数组。它是GROUP BY的好伙伴。

**语法格式**：
```sql
JSON_ARRAYAGG(col_or_expr [ORDER BY ...])
```

**💡 实际应用示例**：
```sql
-- 假设有以下订单表
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    product_name VARCHAR(100),
    price DECIMAL(10,2),
    order_date DATE
);

-- 插入示例数据
INSERT INTO orders VALUES 
(1, 100, '笔记本电脑', 5999.00, '2024-01-15'),
(2, 100, '鼠标', 99.00, '2024-01-15'),
(3, 100, '键盘', 299.00, '2024-01-16'),
(4, 101, '手机', 3999.00, '2024-01-16');

-- 聚合每个用户的购买商品
SELECT 
    user_id,
    JSON_ARRAYAGG(product_name) as products,
    JSON_ARRAYAGG(price ORDER BY price DESC) as prices
FROM orders 
GROUP BY user_id;

/*
结果:
user_id | products                              | prices
100     | ["笔记本电脑", "鼠标", "键盘"]         | [5999.00, 299.00, 99.00]
101     | ["手机"]                             | [3999.00]
*/
```

**🔄 复杂聚合示例**：
```sql
-- 聚合为结构化JSON
SELECT 
    user_id,
    JSON_ARRAYAGG(
        JSON_OBJECT(
            'product', product_name,
            'price', price,
            'date', order_date
        )
        ORDER BY order_date
    ) as order_history
FROM orders 
GROUP BY user_id;
```

### 8.2 JSON_OBJECTAGG - 对象聚合函数


**🔸 核心概念**：
`JSON_OBJECTAGG`把查询结果聚合成JSON对象，需要提供键和值两个参数。

**语法格式**：
```sql
JSON_OBJECTAGG(key, value)
```

**💡 实际应用示例**：
```sql
-- 将用户的多个属性聚合成对象
CREATE TABLE user_attributes (
    user_id INT,
    attr_name VARCHAR(50),
    attr_value VARCHAR(100)
);

INSERT INTO user_attributes VALUES
(1, 'name', '张三'),
(1, 'age', '25'),
(1, 'city', '北京'),
(2, 'name', '李四'),
(2, 'age', '30');

-- 聚合用户属性
SELECT 
    user_id,
    JSON_OBJECTAGG(attr_name, attr_value) as user_profile
FROM user_attributes 
GROUP BY user_id;

/*
结果:
user_id | user_profile
1       | {"age": "25", "city": "北京", "name": "张三"}
2       | {"age": "30", "name": "李四"}
*/
```

**🔄 实际业务应用**：
```sql
-- 商品销售统计聚合
SELECT 
    DATE(order_date) as sale_date,
    JSON_OBJECTAGG(product_name, total_sales) as daily_sales
FROM (
    SELECT 
        order_date,
        product_name,
        SUM(price) as total_sales
    FROM orders 
    GROUP BY order_date, product_name
) as product_totals
GROUP BY DATE(order_date);
```

---

## 9. 🛠️ 实用工具函数


### 9.1 JSON_PRETTY - JSON美化输出


**🔸 核心概念**：
`JSON_PRETTY`把紧凑的JSON格式化成易读的多行格式，就像代码美化工具。

**语法格式**：
```sql
JSON_PRETTY(json_val)
```

**💡 实际应用示例**：
```sql
SET @compact = '{"name":"张三","age":25,"address":{"city":"北京","district":"朝阳区"},"hobbies":["编程","阅读"]}';

SELECT JSON_PRETTY(@compact);
/*
结果：
{
  "age": 25,
  "address": {
    "city": "北京", 
    "district": "朝阳区"
  },
  "hobbies": [
    "编程",
    "阅读"
  ],
  "name": "张三"
}
*/
```

**🔍 调试和查看应用**：
```sql
-- 美化查看用户配置
SELECT 
    id,
    JSON_PRETTY(profile) as formatted_profile
FROM users 
WHERE id = 1;

-- 在日志记录中使用
INSERT INTO debug_logs (message, json_data) 
VALUES ('用户配置更新', JSON_PRETTY(@user_config));
```

### 9.2 JSON_STORAGE_SIZE - 存储大小计算


**🔸 核心概念**：
`JSON_STORAGE_SIZE`返回JSON值在MySQL中实际占用的存储字节数，用于存储空间分析。

**语法格式**：
```sql
JSON_STORAGE_SIZE(json_val)
```

**💡 实际应用示例**：
```sql
-- 计算不同JSON的存储大小
SELECT JSON_STORAGE_SIZE('{"name": "张三"}');           -- 结果: 约20字节
SELECT JSON_STORAGE_SIZE('[1, 2, 3, 4, 5]');          -- 结果: 约15字节

-- 分析表中JSON字段的存储占用
SELECT 
    id,
    JSON_STORAGE_SIZE(profile) as profile_size,
    CHAR_LENGTH(profile) as profile_length
FROM users 
ORDER BY JSON_STORAGE_SIZE(profile) DESC
LIMIT 10;
```

**📊 存储优化应用**：
```sql
-- 找出占用存储最大的JSON记录
SELECT 
    AVG(JSON_STORAGE_SIZE(profile)) as avg_size,
    MAX(JSON_STORAGE_SIZE(profile)) as max_size,
    MIN(JSON_STORAGE_SIZE(profile)) as min_size
FROM users;

-- 存储空间清理建议
SELECT 
    id,
    JSON_STORAGE_SIZE(profile) as current_size,
    JSON_STORAGE_SIZE(JSON_REMOVE(profile, '$.temp_data')) as optimized_size
FROM users 
WHERE JSON_CONTAINS_PATH(profile, 'one', '$.temp_data');
```

---

## 10. 🔄 类型转换函数


### 10.1 CAST - 通用类型转换


**🔸 核心概念**：
`CAST`函数可以在JSON和其他MySQL数据类型之间进行转换，是数据类型转换的桥梁。

**语法格式**：
```sql
CAST(value AS type)
-- 常用类型: JSON, CHAR, DECIMAL, DATETIME, DATE, TIME等
```

**💡 JSON转换示例**：
```sql
-- 字符串转JSON
SELECT CAST('{"name": "张三", "age": 25}' AS JSON);
-- 结果: {"age": 25, "name": "张三"}

-- JSON转字符串  
SET @json = JSON_OBJECT('name', '张三', 'age', 25);
SELECT CAST(@json AS CHAR);
-- 结果: {"age": 25, "name": "张三"}

-- JSON数值提取并转换
SELECT 
    profile->>'$.age' as age_string,
    CAST(profile->>'$.age' AS UNSIGNED) as age_number,
    CAST(profile->>'$.created' AS DATETIME) as created_datetime
FROM users;
```

**🔄 实际应用场景**：
```sql
-- JSON配置转换为查询条件
SELECT * FROM products 
WHERE price BETWEEN 
    CAST(JSON_EXTRACT(@price_range, '$.min') AS DECIMAL(10,2)) 
    AND 
    CAST(JSON_EXTRACT(@price_range, '$.max') AS DECIMAL(10,2));

-- 日期范围查询
SELECT * FROM orders 
WHERE order_date >= CAST(JSON_UNQUOTE(JSON_EXTRACT(@date_filter, '$.start_date')) AS DATE);
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心函数


**🎯 数据提取（最常用）**：
```
JSON_EXTRACT / ->     : 提取JSON值（带引号）
JSON_UNQUOTE / ->>    : 提取JSON值（去引号）
JSON_KEYS            : 获取对象所有键名
JSON_LENGTH          : 获取数组/对象长度
```

**✏️ 数据修改（重要）**：
```
JSON_SET            : 设置值（更新+新增）
JSON_INSERT         : 插入值（仅新增）
JSON_REPLACE        : 替换值（仅更新）
JSON_REMOVE         : 删除指定路径
```

**📦 数据创建（实用）**：
```
JSON_OBJECT         : 创建JSON对象
JSON_ARRAY          : 创建JSON数组
JSON_MERGE_PATCH    : 合并JSON（覆盖式）
JSON_MERGE_PRESERVE : 合并JSON（保留式）
```

**✅ 验证检查（安全）**：
```
JSON_VALID          : 验证JSON格式
JSON_TYPE           : 获取数据类型
JSON_CONTAINS       : 检查包含关系
JSON_CONTAINS_PATH  : 检查路径存在
```

### 11.2 函数选择指南


**🔍 数据查询场景**：
```
简单取值    → 使用 ->> 操作符
复杂路径    → 使用 JSON_EXTRACT
条件查询    → 使用 JSON_CONTAINS
存在检查    → 使用 JSON_CONTAINS_PATH
```

**📝 数据更新场景**：
```
初始化配置  → 使用 JSON_INSERT
更新配置   → 使用 JSON_SET  
安全更新   → 使用 JSON_REPLACE
删除配置   → 使用 JSON_REMOVE
```

**🔄 数据合并场景**：
```
配置更新   → 使用 JSON_MERGE_PATCH
数据汇总   → 使用 JSON_MERGE_PRESERVE
权限累积   → 使用 JSON_MERGE_PRESERVE
```

### 11.3 性能优化建议


**⚡ 查询优化**：
```sql
-- 创建虚拟列索引
ALTER TABLE users ADD COLUMN name_virtual VARCHAR(100) 
AS (JSON_UNQUOTE(JSON_EXTRACT(profile, '$.name'))) VIRTUAL;

CREATE INDEX idx_name ON users(name_virtual);

-- 使用生成列优化查询
SELECT * FROM users WHERE name_virtual = '张三';  -- 快
-- 而不是
SELECT * FROM users WHERE profile->>'$.name' = '张三';  -- 慢
```

**💾 存储优化**：
```sql
-- 定期清理临时数据
UPDATE users SET profile = JSON_REMOVE(profile, '$.temp_data');

-- 压缩JSON存储
UPDATE users SET profile = JSON_COMPACT(profile);
```

### 11.4 最佳实践


**🔒 安全实践**：
- 始终验证输入JSON格式（`JSON_VALID`）
- 使用参数化查询避免JSON注入
- 对外部输入使用`JSON_QUOTE`转义

**📊 性能实践**：
- 为常查询字段创建虚拟列索引
- 避免在大表上直接使用复杂JSON函数
- 使用`JSON_STORAGE_SIZE`监控存储使用

**🛠️ 开发实践**：
- 使用`JSON_PRETTY`格式化调试输出
- 用`JSON_TYPE`验证数据类型
- 选择合适的合并函数避免数据丢失

### 11.5 常见使用误区


**❌ 错误做法**：
```sql
-- 错误：忘记去引号
WHERE profile->'$.age' = 25  -- 比较 "25" 和 25（失败）

-- 错误：路径写法错误  
WHERE profile->'$age' = 25   -- 缺少点号

-- 错误：使用错误的合并函数
JSON_MERGE_PATCH('{"a":[1,2]}', '{"a":[3,4]}')  -- 结果: {"a":[3,4]} 覆盖了
```

**✅ 正确做法**：
```sql
-- 正确：使用->>或JSON_UNQUOTE去引号
WHERE profile->>'$.age' = 25

-- 正确：路径语法
WHERE profile->>'$.age' = 25

-- 正确：选择合适的合并函数
JSON_MERGE_PRESERVE('{"a":[1,2]}', '{"a":[3,4]}')  -- 结果: {"a":[1,2,3,4]} 保留了
```

### 11.6 学习路径建议


**🎯 初级阶段（1-2周）**：
```
掌握基础概念：JSON路径语法
熟练使用：JSON_EXTRACT, JSON_UNQUOTE, JSON_SET
理解区别：-> 和 ->> 操作符
实践练习：基本的增删改查操作
```

**📈 中级阶段（2-3周）**：
```  
掌握验证：JSON_VALID, JSON_TYPE, JSON_CONTAINS
学会合并：JSON_MERGE_PATCH vs JSON_MERGE_PRESERVE
熟练聚合：JSON_ARRAYAGG, JSON_OBJECTAGG
性能优化：虚拟列索引的使用
```

**🚀 高级阶段（1-2周）**：
```
深入理解：存储机制和性能优化
复杂查询：多层嵌套JSON的处理
实战项目：在实际业务中应用JSON函数
故障排查：JSON相关问题的调试和解决
```

**核心记忆口诀**：
- 提取用箭头，单箭头带引号，双箭头纯文本
- 修改三兄弟：SET全能，INSERT新增，REPLACE更新  
- 合并有区别：PATCH覆盖，PRESERVE保留
- 验证很重要：VALID格式，TYPE类型，CONTAINS包含
- 路径要准确：美元符号做根，点号访问属性