---
title: 21、窗口函数关键字
---
## 📚 目录

1. [窗口函数基本概念](#1-窗口函数基本概念)
2. [OVER窗口核心语法](#2-OVER窗口核心语法)
3. [PARTITION分区详解](#3-PARTITION分区详解)
4. [ROWS与RANGE边界控制](#4-ROWS与RANGE边界控制)
5. [边界关键字详解](#5-边界关键字详解)
6. [排名类窗口函数](#6-排名类窗口函数)
7. [偏移类窗口函数](#7-偏移类窗口函数)
8. [取值类窗口函数](#8-取值类窗口函数)
9. [实战应用场景](#9-实战应用场景)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 窗口函数基本概念


### 1.1 什么是窗口函数


**🔸 生活化理解**：
想象你在看一场马拉松比赛，你站在某个位置（当前行），可以：
- 看到你前面的选手（PRECEDING）
- 看到你后面的选手（FOLLOWING）  
- 看到当前位置的选手（CURRENT）
- 统计某个区间内的信息（窗口范围）

```
马拉松选手排列：
选手A  选手B  [你]  选手C  选手D
  ↑      ↑     ↑     ↑      ↑
前面   前面   当前   后面    后面
```

**💡 技术定义**：
窗口函数是一种特殊的SQL函数，它可以：
- **保留所有行**：不像GROUP BY会合并数据
- **跨行计算**：基于相关行的集合进行计算
- **分析数据**：提供排名、累计、比较等分析功能

### 1.2 窗口函数 vs 聚合函数


```
📊 对比理解：

聚合函数（GROUP BY）：
员工表 → 按部门分组 → 每部门一行结果
销售部：总销售额 1000万
技术部：总销售额 800万

窗口函数（OVER）：
员工表 → 每个员工保留 → 同时显示部门总额
张三(销售部)：个人100万，部门总计1000万
李四(销售部)：个人200万，部门总计1000万
王五(技术部)：个人150万，部门总计800万
```

### 1.3 基本语法结构


```sql
-- 窗口函数基本语法
窗口函数名() OVER (
    PARTITION BY 分区字段    -- 可选：数据分组
    ORDER BY 排序字段       -- 可选：排序规则
    ROWS/RANGE 边界定义     -- 可选：窗口范围
)
```

**🎯 语法组件说明**：
- **窗口函数名**：如ROW_NUMBER、SUM、LAG等
- **OVER子句**：定义窗口范围和计算规则
- **PARTITION BY**：数据分区，类似GROUP BY
- **ORDER BY**：窗口内排序
- **ROWS/RANGE**：精确定义窗口边界

---

## 2. 🪟 OVER窗口核心语法


### 2.1 OVER子句的作用


**🔸 核心作用**：
OVER就像给每一行数据"开了一扇窗"，通过这扇窗可以：
- 看到相关的其他行数据
- 基于这些数据进行计算
- 计算结果添加到当前行

```
想象一个班级成绩表：
学生    成绩    通过OVER窗口可以看到：
张三    85      → 全班平均分、排名、比前一名差多少
李四    92      → 全班平均分、排名、比前一名差多少  
王五    78      → 全班平均分、排名、比前一名差多少
```

### 2.2 OVER的三种形式


**📝 空OVER窗口**：
```sql
-- 计算全表累计和
SELECT 
    员工姓名,
    月薪,
    SUM(月薪) OVER() as 全公司工资总和
FROM 员工表;
```

**💡 含义**：整个结果集作为一个窗口，每行都能看到全部数据

**📝 带PARTITION的OVER**：
```sql
-- 按部门计算累计和  
SELECT 
    员工姓名,
    部门,
    月薪,
    SUM(月薪) OVER(PARTITION BY 部门) as 部门工资总和
FROM 员工表;
```

**💡 含义**：按部门分组，每个部门内的窗口独立计算

**📝 完整OVER窗口**：
```sql
-- 按部门分组，按薪资排序，计算累计
SELECT 
    员工姓名,
    部门,
    月薪,
    SUM(月薪) OVER(
        PARTITION BY 部门 
        ORDER BY 月薪 DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as 部门累计工资
FROM 员工表;
```

### 2.3 OVER使用场景


**🎯 典型应用**：
```
报表分析：每行显示明细 + 汇总信息
排名计算：保持原数据 + 添加排名列
趋势分析：当前值 + 历史对比
移动计算：滑动窗口统计
```

---

## 3. 🗂️ PARTITION分区详解


### 3.1 PARTITION BY的本质


**🔸 生活化理解**：
PARTITION BY就像把一个大教室按照某个标准分成几个小组：
```
全班50人 → 按性别分区 → 男生组25人 + 女生组25人
每个小组内部独立计算排名、平均分等指标
```

**💡 技术含义**：
- 将数据按指定字段分组
- 每个分组内窗口函数独立计算
- 不同分组之间互不影响

### 3.2 PARTITION BY语法


```sql
-- 基本语法
PARTITION BY 字段1 [, 字段2, ...]

-- 单字段分区
SELECT 
    学生姓名,
    班级,
    成绩,
    ROW_NUMBER() OVER(PARTITION BY 班级 ORDER BY 成绩 DESC) as 班级排名
FROM 成绩表;
```

**📊 执行过程**：
```
原始数据：
学生    班级    成绩
张三    1班     85
李四    1班     92  
王五    2班     78
赵六    2班     88

PARTITION BY 班级后：
分区1(1班)：张三85, 李四92 → 独立排名
分区2(2班)：王五78, 赵六88 → 独立排名

结果：
张三    1班     85    2    (1班内排第2)
李四    1班     92    1    (1班内排第1)
王五    2班     78    2    (2班内排第2)  
赵六    2班     88    1    (2班内排第1)
```

### 3.3 多字段分区


```sql
-- 按部门和职级双重分区
SELECT 
    员工姓名,
    部门,
    职级, 
    薪资,
    AVG(薪资) OVER(PARTITION BY 部门, 职级) as 同级平均薪资
FROM 员工表;
```

**🔍 分区逻辑**：
```
多重分区效果：
销售部-初级：一组
销售部-中级：一组  
销售部-高级：一组
技术部-初级：一组
技术部-中级：一组
技术部-高级：一组

每组内独立计算平均薪资
```

### 3.4 不使用PARTITION的影响


```sql
-- 不分区：全局排名
ROW_NUMBER() OVER(ORDER BY 成绩 DESC)

-- 分区：组内排名  
ROW_NUMBER() OVER(PARTITION BY 班级 ORDER BY 成绩 DESC)
```

**对比效果**：
```
不分区结果：
李四    1班    92    1    (全校第1)
赵六    2班    88    2    (全校第2)
张三    1班    85    3    (全校第3)
王五    2班    78    4    (全校第4)

分区结果：
李四    1班    92    1    (1班第1)
张三    1班    85    2    (1班第2)
赵六    2班    88    1    (2班第1)
王五    2班    78    2    (2班第2)
```

---

## 4. 📏 ROWS与RANGE边界控制


### 4.1 边界控制的作用


**🔸 生活化理解**：
想象你在看股票K线图，你可以设定：
- 只看当天（CURRENT ROW）
- 看最近3天（ROWS 2 PRECEDING）
- 看最近一周（ROWS 6 PRECEDING）
- 看从开始到现在（UNBOUNDED PRECEDING）

**💡 技术含义**：
ROWS和RANGE用来精确定义窗口函数计算时包含哪些行数据

### 4.2 ROWS vs RANGE区别


**🔸 ROWS（物理行）**：
```sql
-- 按物理行数计算，不管值是否相同
SUM(销售额) OVER(
    ORDER BY 日期 
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
) 
```

**含义**：取当前行及前面2行，共3行数据

**🔸 RANGE（逻辑范围）**：
```sql
-- 按值的范围计算，相同值的行都包含
SUM(销售额) OVER(
    ORDER BY 日期
    RANGE BETWEEN 2 PRECEDING AND CURRENT ROW
)
```

**含义**：取当前值及前面2个不同值的所有行

### 4.3 对比示例


```
示例数据：
日期        销售额    ROWS计算    RANGE计算
2024-01-01   100     100         100
2024-01-02   200     300(前1行)   300(前1天) 
2024-01-02   150     450(前2行)   450(相同日期一起算)
2024-01-03   300     650(前2行)   750(前2天的所有行)
```

**🎯 选择建议**：
- **ROWS**：适用于固定行数的移动窗口
- **RANGE**：适用于基于值范围的逻辑窗口

---

## 5. 🎚️ 边界关键字详解


### 5.1 PRECEDING（之前）


**🔸 含义**：当前行之前的行
```sql
-- 前面3行
3 PRECEDING

-- 从开始到前面1行
UNBOUNDED PRECEDING
```

**💡 实际应用**：
```sql
-- 计算最近3个月销售额
SELECT 
    月份,
    销售额,
    SUM(销售额) OVER(
        ORDER BY 月份
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as 近3月销售额
FROM 月销售表;
```

### 5.2 FOLLOWING（之后）


**🔸 含义**：当前行之后的行
```sql
-- 后面2行
2 FOLLOWING

-- 从后面1行到结尾
1 FOLLOWING AND UNBOUNDED FOLLOWING
```

**💡 实际应用**：
```sql
-- 计算未来3天的预估销售
SELECT 
    日期,
    实际销售,
    AVG(预估销售) OVER(
        ORDER BY 日期
        ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
    ) as 未来3天平均预估
FROM 销售预测表;
```

### 5.3 CURRENT ROW（当前行）


**🔸 含义**：当前正在处理的行
```sql
-- 只包含当前行
CURRENT ROW

-- 从开始到当前行（累计）
UNBOUNDED PRECEDING AND CURRENT ROW
```

**💡 累计计算示例**：
```sql
-- 累计销售额
SELECT 
    日期,
    销售额,
    SUM(销售额) OVER(
        ORDER BY 日期
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as 累计销售额
FROM 日销售表;
```

### 5.4 UNBOUNDED（无界）


**🔸 含义**：无限制边界
- **UNBOUNDED PRECEDING**：从第一行开始
- **UNBOUNDED FOLLOWING**：到最后一行结束

```sql
-- 全窗口计算
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING

-- 等价于
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
-- 相当于不指定边界
```

### 5.5 常用边界组合


```sql
-- 累计到当前
UNBOUNDED PRECEDING AND CURRENT ROW

-- 当前行前后各1行  
1 PRECEDING AND 1 FOLLOWING

-- 前3行到当前行
3 PRECEDING AND CURRENT ROW

-- 当前行到后2行
CURRENT ROW AND 2 FOLLOWING

-- 全部数据
UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

---

## 6. 🏆 排名类窗口函数


### 6.1 ROW_NUMBER行号


**🔸 作用**：给每行分配唯一的序号，即使值相同也不重复

```sql
-- 基本用法
SELECT 
    学生姓名,
    成绩,
    ROW_NUMBER() OVER(ORDER BY 成绩 DESC) as 行号
FROM 成绩表;
```

**💡 结果特点**：
```
学生    成绩    行号
李四    92      1
王五    90      2  
张三    90      3    ← 相同成绩也是不同行号
赵六    85      4
```

**🎯 应用场景**：
- 数据分页：取第11-20条记录
- 去重：每组保留第1条
- 生成主键：为数据添加唯一标识

### 6.2 RANK排名


**🔸 作用**：相同值获得相同排名，但会跳过名次

```sql
SELECT 
    学生姓名,
    成绩,
    RANK() OVER(ORDER BY 成绩 DESC) as 排名
FROM 成绩表;
```

**💡 结果特点**：
```
学生    成绩    排名
李四    92      1
王五    90      2
张三    90      2    ← 并列第2名
赵六    85      4    ← 跳过第3名，直接第4名
```

**🎯 应用场景**：
- 体育比赛排名
- 销售业绩排行
- 考试成绩排序

### 6.3 DENSE_RANK密集排名


**🔸 作用**：相同值获得相同排名，不跳过名次

```sql
SELECT 
    学生姓名,
    成绩,
    DENSE_RANK() OVER(ORDER BY 成绩 DESC) as 密集排名
FROM 成绩表;
```

**💡 结果特点**：
```
学生    成绩    密集排名
李四    92      1
王五    90      2
张三    90      2    ← 并列第2名  
赵六    85      3    ← 不跳过，直接第3名
```

### 6.4 三种排名函数对比


| 函数 | **相同值处理** | **名次跳跃** | **适用场景** |
|------|-------------|------------|------------|
| `ROW_NUMBER` | 不同行号 | 无跳跃 | 唯一标识、分页 |
| `RANK` | 相同排名 | 有跳跃 | 传统排名、比赛 |
| `DENSE_RANK` | 相同排名 | 无跳跃 | 等级分类、评分 |

**🔍 实际对比**：
```
成绩: 95, 90, 90, 85, 80

ROW_NUMBER: 1, 2, 3, 4, 5
RANK:       1, 2, 2, 4, 5  
DENSE_RANK: 1, 2, 2, 3, 4
```

---

## 7. ⏱️ 偏移类窗口函数


### 7.1 LAG滞后函数


**🔸 作用**：获取当前行之前指定行数的值

```sql
-- 基本语法
LAG(字段名, 偏移行数, 默认值) OVER([PARTITION BY ...] ORDER BY ...)
```

**💡 生活化理解**：
就像回头看，看前面第N个人在干什么
```
队伍: [A] [B] [C] [D] [E]
当前是C，LAG(1)看到B，LAG(2)看到A
```

**📝 实际应用**：
```sql
-- 计算销售额环比增长
SELECT 
    月份,
    销售额,
    LAG(销售额, 1) OVER(ORDER BY 月份) as 上月销售额,
    销售额 - LAG(销售额, 1) OVER(ORDER BY 月份) as 环比增长
FROM 月销售表;
```

**结果示例**：
```
月份      销售额    上月销售额    环比增长
2024-01   1000      NULL         NULL
2024-02   1200      1000         200
2024-03   1500      1200         300
```

### 7.2 LEAD超前函数


**🔸 作用**：获取当前行之后指定行数的值

```sql
-- 基本语法  
LEAD(字段名, 偏移行数, 默认值) OVER([PARTITION BY ...] ORDER BY ...)
```

**💡 生活化理解**：
就像向前看，看后面第N个人在干什么
```
队伍: [A] [B] [C] [D] [E]  
当前是C，LEAD(1)看到D，LEAD(2)看到E
```

**📝 实际应用**：
```sql
-- 预测下月销售趋势
SELECT 
    月份,
    销售额,
    LEAD(预估销售, 1) OVER(ORDER BY 月份) as 下月预估,
    LEAD(预估销售, 1) OVER(ORDER BY 月份) - 销售额 as 预期增长
FROM 销售预测表;
```

### 7.3 偏移函数的默认值


```sql
-- 没有默认值：返回NULL
LAG(销售额, 1) OVER(ORDER BY 日期)

-- 设置默认值：返回指定值
LAG(销售额, 1, 0) OVER(ORDER BY 日期)
```

**🎯 实用技巧**：
```sql
-- 计算增长率，避免NULL
SELECT 
    日期,
    销售额,
    ROUND(
        (销售额 - LAG(销售额, 1, 销售额) OVER(ORDER BY 日期)) 
        / LAG(销售额, 1, 销售额) OVER(ORDER BY 日期) * 100, 2
    ) as 增长率百分比
FROM 销售表;
```

---

## 8. 📊 取值类窗口函数


### 8.1 FIRST_VALUE第一个值


**🔸 作用**：获取窗口内第一行的值

```sql
-- 基本语法
FIRST_VALUE(字段名) OVER(
    [PARTITION BY ...] 
    ORDER BY ... 
    [ROWS/RANGE ...]
)
```

**💡 生活化理解**：
在一个排好序的队伍中，总能知道第一个人是谁
```
按成绩排序: [第1名] [第2名] [第3名] [第4名]
每行都能知道第1名是谁
```

**📝 实际应用**：
```sql
-- 显示部门最高薪资
SELECT 
    员工姓名,
    部门,
    薪资,
    FIRST_VALUE(薪资) OVER(
        PARTITION BY 部门 
        ORDER BY 薪资 DESC
    ) as 部门最高薪资
FROM 员工表;
```

**结果示例**：
```
员工    部门    薪资    部门最高薪资
张三    销售    8000    10000
李四    销售    10000   10000  ← 部门最高
王五    销售    6000    10000
赵六    技术    12000   12000  ← 部门最高
```

### 8.2 LAST_VALUE最后值


**🔸 作用**：获取窗口内最后一行的值

```sql
-- 基本语法
LAST_VALUE(字段名) OVER(
    [PARTITION BY ...] 
    ORDER BY ... 
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

**⚠️ 重要注意**：
LAST_VALUE需要明确指定窗口边界，否则可能得不到期望结果

```sql
-- 错误用法：只能看到当前行
LAST_VALUE(薪资) OVER(ORDER BY 薪资)

-- 正确用法：看到整个窗口
LAST_VALUE(薪资) OVER(
    ORDER BY 薪资
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

**📝 实际应用**：
```sql
-- 显示部门最低薪资
SELECT 
    员工姓名,
    部门,
    薪资,
    LAST_VALUE(薪资) OVER(
        PARTITION BY 部门 
        ORDER BY 薪资DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) as 部门最低薪资
FROM 员工表;
```

### 8.3 取值函数的边界问题


**🔍 默认边界行为**：
```sql
-- 默认边界：从开始到当前行
ORDER BY 字段
-- 等价于
ORDER BY 字段 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
```

**💡 边界对LAST_VALUE的影响**：
```
数据: A(10), B(20), C(30)

默认边界下LAST_VALUE:
A行: LAST_VALUE = A (只看到A)
B行: LAST_VALUE = B (看到A,B)  
C行: LAST_VALUE = C (看到A,B,C)

完整边界下LAST_VALUE:
A行: LAST_VALUE = C (看到全部A,B,C)
B行: LAST_VALUE = C (看到全部A,B,C)
C行: LAST_VALUE = C (看到全部A,B,C)
```

---

## 9. 🛠️ 实战应用场景


### 9.1 销售数据分析


```sql
-- 综合销售分析报表
SELECT 
    销售日期,
    销售员,
    销售额,
    -- 排名分析
    ROW_NUMBER() OVER(ORDER BY 销售额 DESC) as 总排名,
    RANK() OVER(PARTITION BY 销售员 ORDER BY 销售额 DESC) as 个人销售排名,
    
    -- 趋势分析  
    LAG(销售额, 1) OVER(PARTITION BY 销售员 ORDER BY 销售日期) as 前一天销售,
    销售额 - LAG(销售额, 1) OVER(PARTITION BY 销售员 ORDER BY 销售日期) as 日增长,
    
    -- 累计分析
    SUM(销售额) OVER(
        PARTITION BY 销售员 
        ORDER BY 销售日期
        ROWS UNBOUNDED PRECEDING
    ) as 个人累计销售,
    
    -- 移动平均
    AVG(销售额) OVER(
        PARTITION BY 销售员
        ORDER BY 销售日期  
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as 一周移动平均
    
FROM 销售表
ORDER BY 销售员, 销售日期;
```

### 9.2 学生成绩分析


```sql
-- 学生成绩综合分析
SELECT 
    学生姓名,
    班级,
    科目,
    成绩,
    
    -- 多维度排名
    RANK() OVER(ORDER BY 成绩 DESC) as 全校排名,
    RANK() OVER(PARTITION BY 班级 ORDER BY 成绩 DESC) as 班级排名,
    RANK() OVER(PARTITION BY 科目 ORDER BY 成绩 DESC) as 科目排名,
    
    -- 分数对比
    成绩 - AVG(成绩) OVER(PARTITION BY 班级) as 班级平均分差,
    成绩 - FIRST_VALUE(成绩) OVER(PARTITION BY 班级 ORDER BY 成绩 DESC) as 与班级第一差距,
    
    -- 百分位排名
    PERCENT_RANK() OVER(ORDER BY 成绩) as 百分位排名
    
FROM 成绩表
ORDER BY 班级, 成绩 DESC;
```

### 9.3 库存管理分析


```sql
-- 库存变化趋势分析
SELECT 
    日期,
    商品名称,
    入库数量,
    出库数量,
    
    -- 库存累计
    SUM(入库数量 - 出库数量) OVER(
        PARTITION BY 商品名称
        ORDER BY 日期
        ROWS UNBOUNDED PRECEDING  
    ) as 当前库存,
    
    -- 移动平均
    AVG(出库数量) OVER(
        PARTITION BY 商品名称
        ORDER BY 日期
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as 一周平均出库,
    
    -- 预警分析
    CASE 
        WHEN SUM(入库数量 - 出库数量) OVER(
            PARTITION BY 商品名称 ORDER BY 日期 ROWS UNBOUNDED PRECEDING
        ) < 100 THEN '库存不足'
        ELSE '库存正常' 
    END as 库存状态
    
FROM 库存表
ORDER BY 商品名称, 日期;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 窗口函数本质：在保留原始数据的基础上，增加跨行计算能力
🔸 OVER子句：定义计算窗口的核心语法
🔸 PARTITION BY：数据分区，实现组内独立计算  
🔸 ORDER BY：窗口内排序，影响计算结果
🔸 ROWS/RANGE：精确控制窗口边界范围
```

### 10.2 关键理解要点


**🔹 窗口函数的优势**：
```
vs 聚合函数：
- 保留明细数据，不需要GROUP BY
- 支持复杂的跨行计算
- 一次查询完成多种分析

vs 子查询：
- 性能更优，一次扫描完成
- 语法更简洁，逻辑更清晰
- 支持复杂的窗口边界控制
```

**🔹 边界控制的重要性**：
```
默认边界：UNBOUNDED PRECEDING AND CURRENT ROW
- 适合累计计算
- FIRST_VALUE正常工作
- LAST_VALUE可能不符合预期

完整边界：UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING  
- 适合全窗口计算
- LAST_VALUE正常工作
- 所有行看到相同的窗口
```

**🔹 函数选择指南**：
```
排名需求：
- 唯一序号 → ROW_NUMBER
- 传统排名 → RANK  
- 密集排名 → DENSE_RANK

取值需求：
- 前一行值 → LAG
- 后一行值 → LEAD
- 窗口首值 → FIRST_VALUE
- 窗口末值 → LAST_VALUE
```

### 10.3 实际应用价值


- **数据分析**：排名、趋势、对比分析一次完成
- **报表开发**：明细与汇总同时展示
- **性能优化**：减少子查询，提升查询效率
- **业务洞察**：支持复杂的业务分析场景

### 10.4 学习进度清单


学习检查：
- [ ] 理解窗口函数与聚合函数的区别
- [ ] 掌握OVER子句的三种基本形式  
- [ ] 熟练使用PARTITION BY进行数据分区
- [ ] 理解ROWS和RANGE的边界控制
- [ ] 掌握所有边界关键字的含义
- [ ] 熟练使用三种排名函数
- [ ] 掌握LAG和LEAD的偏移计算
- [ ] 正确使用FIRST_VALUE和LAST_VALUE
- [ ] 能够编写复合窗口函数查询
- [ ] 应用到实际业务场景分析

**🎯 学习建议**：
1. **动手实践**：每个函数都要亲自编写SQL验证
2. **场景理解**：结合实际业务需求来学习
3. **对比学习**：理解不同函数的适用场景
4. **性能意识**：关注窗口函数的执行效率

**核心记忆**：
- 窗口函数保留原数据，增加分析能力
- OVER子句定义窗口，PARTITION分组计算  
- 边界控制很关键，影响函数计算结果
- 排名偏移取值类，各有专门应用场景