---
title: 11、事务控制关键字
---
## 📚 目录

1. [事务基础概念](#1-事务基础概念)
2. [START/BEGIN 开始事务](#2-start-begin-开始事务)
3. [COMMIT 提交事务](#3-commit-提交事务)
4. [ROLLBACK 回滚事务](#4-rollback-回滚事务)
5. [SAVEPOINT 保存点机制](#5-savepoint-保存点机制)
6. [RELEASE 释放保存点](#6-release-释放保存点)
7. [TRANSACTION 事务语法](#7-transaction-事务语法)
8. [AUTOCOMMIT 自动提交](#8-autocommit-自动提交)
9. [事务控制实战应用](#9-事务控制实战应用)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 事务基础概念


### 1.1 什么是事务


**🔸 简单理解**
事务就像**银行转账**一样 - 要么全部成功，要么全部失败，不能出现转了一半的情况。

```
比如张三给李四转账100元：
✅ 正常情况：张三账户-100 → 李四账户+100 → 都成功
❌ 异常情况：张三账户-100 → 系统故障 → 钱丢了？

事务的作用：确保要么都成功，要么都不变
```

**🔸 专业定义**
事务（Transaction）是数据库中**一组操作的集合**，这些操作要么**全部执行成功**，要么**全部不执行**，是数据库保证数据一致性的重要机制。

### 1.2 事务的四大特性（ACID）


| 特性 | **英文** | **含义** | **通俗解释** |
|------|---------|---------|-------------|
| 🔹 **原子性** | `Atomicity` | `要么全做，要么不做` | `像原子一样不可分割` |
| 🔹 **一致性** | `Consistency` | `数据保持逻辑正确` | `业务规则不被破坏` |
| 🔹 **隔离性** | `Isolation` | `不同事务互不干扰` | `各自独立执行` |
| 🔹 **持久性** | `Durability` | `提交后永久保存` | `不会莫名其妙丢失` |

### 1.3 为什么需要事务控制


```
没有事务控制的问题：

场景：网上购物下单
步骤1：减少商品库存 ✅
步骤2：增加订单记录 ✅  
步骤3：扣减用户余额 ❌ 系统故障

结果：商品没了，钱也没扣，订单却生成了！

有事务控制：
如果任何一步失败 → 全部回滚 → 就像什么都没发生
```

---

## 2. 🚀 START/BEGIN 开始事务


### 2.1 START TRANSACTION 详解


**🔸 基本含义**
`START TRANSACTION` 就是告诉数据库："我要开始一组相关操作了，请帮我记录下来，如果中途出问题，我可能要全部撤销"。

**🔸 语法格式**
```sql
-- 标准语法
START TRANSACTION;

-- 可选参数（不常用）
START TRANSACTION READ ONLY;    -- 只读事务
START TRANSACTION READ WRITE;   -- 读写事务（默认）
```

### 2.2 BEGIN 语句


**🔸 作用与START相同**
```sql
-- 以下两种写法效果完全一样
START TRANSACTION;
-- 或者
BEGIN;
```

**🔸 不同数据库的支持**
```
MySQL：    START TRANSACTION 和 BEGIN 都支持
Oracle：   主要使用 BEGIN（存储过程中）
SQL Server：BEGIN TRANSACTION
PostgreSQL：BEGIN 或 START TRANSACTION
```

### 2.3 实际使用示例


```sql
-- 示例：转账操作
START TRANSACTION;

-- 这里开始记录所有操作，等待最终决定提交或回滚
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;

-- 还没有真正生效，只是在事务中记录了这些变更
```

> 💡 **理解要点**: START/BEGIN 只是开启事务，真正的数据变更要等到 COMMIT 才会永久生效。

---

## 3. ✅ COMMIT 提交事务


### 3.1 COMMIT 的作用


**🔸 简单理解**
`COMMIT` 就是对数据库说："我确认这些操作都没问题，请正式执行并保存"。

就像**网购确认收货**一样：
- 收到货物 → 检查没问题 → 点击确认收货 → 钱正式转给卖家
- 执行SQL → 检查没错误 → 执行COMMIT → 数据正式保存

### 3.2 COMMIT 语法


```sql
-- 基本语法
COMMIT;

-- 完整事务示例
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1;
INSERT INTO orders (user_id, product_id, quantity) VALUES (1, 1, 1);
UPDATE users SET balance = balance - 99.9 WHERE id = 1;
COMMIT;  -- 确认提交，所有变更生效
```

### 3.3 COMMIT 执行过程


```
事务执行流程：

步骤1：START TRANSACTION
       ↓
步骤2：执行各种SQL操作 (在内存中记录，未真正修改磁盘)
       ↓  
步骤3：检查所有操作是否正确
       ↓
步骤4：COMMIT (正式写入磁盘，永久保存)
       ↓
步骤5：释放锁资源，事务结束
```

> 💡 **重要理解**: COMMIT之前的操作都是**临时的**，只有COMMIT后才是**永久的**。

---

## 4. ↩️ ROLLBACK 回滚事务


### 4.1 ROLLBACK 的含义


**🔸 通俗解释**
`ROLLBACK` 就是"后悔药" - 告诉数据库："刚才的操作我不要了，请恢复到事务开始前的状态"。

就像**撤销键 Ctrl+Z**：
- 写错了文档 → 按Ctrl+Z → 回到修改前状态
- SQL出错了 → 执行ROLLBACK → 回到事务开始前状态

### 4.2 什么时候用ROLLBACK


```sql
-- 场景1：手动回滚（发现逻辑错误）
START TRANSACTION;
UPDATE accounts SET balance = balance - 1000 WHERE user_id = 1;
-- 突然发现金额输错了，应该是100不是1000
ROLLBACK;  -- 撤销，账户余额不变

-- 场景2：程序自动回滚（捕获异常）
START TRANSACTION;
UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 1;
-- 假如这里出现除零错误或约束违反
-- 程序检测到异常，自动执行 ROLLBACK
```

### 4.3 ROLLBACK 语法


```sql
-- 完全回滚到事务开始
ROLLBACK;

-- 回滚到指定保存点（稍后详解）
ROLLBACK TO savepoint_name;
```

### 4.4 回滚示例


```sql
-- 完整的错误处理示例
START TRANSACTION;

UPDATE products SET stock = stock - 1 WHERE id = 1;

-- 检查库存是否足够
IF (SELECT stock FROM products WHERE id = 1) < 0 THEN
    ROLLBACK;  -- 库存不足，回滚
    SELECT '库存不足，订单取消' AS message;
ELSE
    INSERT INTO orders (product_id, quantity) VALUES (1, 1);
    COMMIT;    -- 一切正常，提交
    SELECT '订单创建成功' AS message;
END IF;
```

> ⚠️ **注意**: ROLLBACK后整个事务结束，需要重新START TRANSACTION才能开始新事务。

---

## 5. 📌 SAVEPOINT 保存点机制


### 5.1 SAVEPOINT 是什么


**🔸 形象比喻**
SAVEPOINT 就像游戏中的**存档点**：
- 打游戏时在关键位置存档
- 如果后面失败了，可以回到存档点继续
- 不用重新开始整个游戏

在数据库中：
- 在事务中设置多个存档点
- 出错时可以回滚到任意存档点
- 不用撤销整个事务

### 5.2 SAVEPOINT 语法


```sql
-- 创建保存点
SAVEPOINT savepoint_name;

-- 回滚到保存点  
ROLLBACK TO savepoint_name;

-- 删除保存点
RELEASE SAVEPOINT savepoint_name;
```

### 5.3 SAVEPOINT 实际应用


```sql
-- 复杂业务场景：批量处理订单
START TRANSACTION;

-- 处理第一批订单
INSERT INTO orders (user_id, amount) VALUES (1, 100);
UPDATE users SET balance = balance - 100 WHERE id = 1;
SAVEPOINT batch1;  -- 第一批完成，设置存档点

-- 处理第二批订单
INSERT INTO orders (user_id, amount) VALUES (2, 200);  
UPDATE users SET balance = balance - 200 WHERE id = 2;
SAVEPOINT batch2;  -- 第二批完成，再设存档点

-- 处理第三批订单时出错
INSERT INTO orders (user_id, amount) VALUES (3, 999999);  -- 金额异常
-- 发现问题，只回滚第三批，保留前两批
ROLLBACK TO batch2;

-- 继续处理正确的第三批
INSERT INTO orders (user_id, amount) VALUES (3, 300);
UPDATE users SET balance = balance - 300 WHERE id = 3;

COMMIT;  -- 提交所有正确的操作
```

### 5.4 保存点的层级结构


```
事务保存点示意图：

START TRANSACTION
    ↓
执行操作A → SAVEPOINT sp1
    ↓
执行操作B → SAVEPOINT sp2  
    ↓
执行操作C → SAVEPOINT sp3
    ↓
出现错误 → ROLLBACK TO sp2 (撤销操作C，保留A和B)
    ↓  
执行操作D → COMMIT (提交A、B、D)
```

> 💡 **使用技巧**: 在复杂业务逻辑中，可以把每个业务步骤设为一个保存点，方便精确回滚。

---

## 6. 🗑️ RELEASE 释放保存点


### 6.1 RELEASE 的作用


**🔸 简单理解**
`RELEASE SAVEPOINT` 就是删除不需要的存档点，释放内存空间。

就像**删除游戏存档**：
- 确定不会回到某个存档点了
- 删除它来节省存储空间
- 但不影响游戏进度

### 6.2 为什么要释放保存点


```sql
-- 问题：创建太多保存点会占用资源
START TRANSACTION;

SAVEPOINT sp1;
-- 一些操作...
SAVEPOINT sp2;  
-- 一些操作...
SAVEPOINT sp3;
-- 一些操作...

-- 如果确定不会回到sp1了，可以释放它
RELEASE SAVEPOINT sp1;  -- 释放资源，但sp2和sp3仍然有效
```

### 6.3 RELEASE 语法与示例


```sql
-- 基本语法
RELEASE SAVEPOINT savepoint_name;

-- 实际应用示例
START TRANSACTION;

-- 第一阶段：验证用户权限
SELECT * FROM users WHERE id = 1 AND status = 'active';
SAVEPOINT check_user;

-- 第二阶段：检查商品库存  
SELECT * FROM products WHERE id = 1 AND stock > 0;
SAVEPOINT check_stock;

-- 第一阶段已确认没问题，释放对应保存点
RELEASE SAVEPOINT check_user;

-- 第三阶段：创建订单
INSERT INTO orders (user_id, product_id) VALUES (1, 1);

-- 如果出错，还可以回到检查库存的地方
-- ROLLBACK TO check_stock;  (check_user已被释放，无法回滚到那里)

COMMIT;
```

> ⚠️ **注意**: 释放保存点是**不可逆**的，释放后就不能再回滚到该点了。

---

## 7. 📋 TRANSACTION 事务语法


### 7.1 TRANSACTION 关键字的使用


**🔸 基本理解**
`TRANSACTION` 通常和其他关键字配合使用，用来明确指定事务相关操作。

### 7.2 各种TRANSACTION语法


```sql
-- 开始事务（明确指定）
START TRANSACTION;
BEGIN TRANSACTION;  -- SQL Server风格

-- 提交事务（完整写法）
COMMIT TRANSACTION;  -- 等同于 COMMIT;

-- 回滚事务（完整写法）  
ROLLBACK TRANSACTION;  -- 等同于 ROLLBACK;

-- 带名称的事务（SQL Server）
BEGIN TRANSACTION order_process;
-- ... 操作 ...
COMMIT TRANSACTION order_process;
```

### 7.3 事务属性设置


```sql
-- 设置事务隔离级别
START TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置事务访问模式
START TRANSACTION READ ONLY;   -- 只读事务
START TRANSACTION READ WRITE;  -- 读写事务（默认）
```

### 7.4 完整事务语法示例


```sql
-- MySQL风格的完整事务
START TRANSACTION;
    -- 业务逻辑
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- SQL Server风格的命名事务
BEGIN TRANSACTION transfer_money;
    -- 业务逻辑  
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT TRANSACTION transfer_money;
```

> 📝 **实用建议**: 大多数情况下使用简短形式（START、COMMIT、ROLLBACK）就足够了。

---

## 8. ⚡ AUTOCOMMIT 自动提交


### 8.1 AUTOCOMMIT 是什么


**🔸 通俗解释**
`AUTOCOMMIT` 就像**自动保存功能**：
- Word文档开启自动保存 → 每次修改都自动存盘
- 数据库开启自动提交 → 每条SQL都自动COMMIT

默认情况下，大多数数据库都开启了自动提交模式。

### 8.2 自动提交的工作方式


```
AUTOCOMMIT = ON (默认情况)：
每条SQL语句 = 一个独立事务

INSERT INTO users (name) VALUES ('张三');  -- 自动提交
UPDATE users SET age = 25 WHERE id = 1;    -- 自动提交  
DELETE FROM users WHERE id = 2;            -- 自动提交

AUTOCOMMIT = OFF：
需要手动控制事务

INSERT INTO users (name) VALUES ('张三');  -- 未提交
UPDATE users SET age = 25 WHERE id = 1;    -- 未提交
COMMIT;  -- 手动提交上面两条语句
```

### 8.3 AUTOCOMMIT 控制语法


```sql
-- 查看当前自动提交状态
SHOW VARIABLES LIKE 'autocommit';

-- 关闭自动提交（当前会话）
SET AUTOCOMMIT = 0;
SET AUTOCOMMIT = OFF;

-- 开启自动提交
SET AUTOCOMMIT = 1;  
SET AUTOCOMMIT = ON;
```

### 8.4 自动提交实战示例


```sql
-- 示例1：默认自动提交模式
SELECT $$autocommit;  -- 结果：1 (开启状态)

INSERT INTO logs (message) VALUES ('用户登录');
-- 这条语句立即生效，相当于：
-- START TRANSACTION;
-- INSERT INTO logs (message) VALUES ('用户登录');  
-- COMMIT;

-- 示例2：关闭自动提交
SET AUTOCOMMIT = 0;

INSERT INTO logs (message) VALUES ('开始处理订单');
UPDATE orders SET status = 'processing' WHERE id = 1;
-- 这时数据还没有真正保存

-- 手动决定提交或回滚
COMMIT;   -- 确认提交
-- 或者 ROLLBACK;  -- 撤销操作
```

### 8.5 什么时候关闭自动提交


**🔸 需要关闭AUTOCOMMIT的场景：**
- ✅ **批量操作**：需要确保多条SQL要么全成功，要么全失败
- ✅ **复杂业务**：包含多个步骤的业务逻辑
- ✅ **数据迁移**：大量数据操作，需要可控回滚
- ✅ **测试环境**：方便撤销测试数据

**🔸 保持AUTOCOMMIT开启的场景：**
- ✅ **简单查询**：只是查看数据，不涉及复杂事务
- ✅ **单条操作**：每次只执行一条独立的SQL语句
- ✅ **Web应用**：大多数Web应用的数据库操作

> 💡 **最佳实践**: 在应用程序中通常保持AUTOCOMMIT开启，在需要事务时显式使用START TRANSACTION。

---

## 9. 🎯 事务控制实战应用


### 9.1 电商订单处理


```sql
-- 完整的下单流程事务控制
START TRANSACTION;

-- 步骤1：检查商品库存
SELECT stock FROM products WHERE id = 1;
SAVEPOINT check_inventory;

-- 步骤2：减少库存
UPDATE products SET stock = stock - 1 WHERE id = 1;

-- 步骤3：创建订单
INSERT INTO orders (user_id, product_id, quantity, amount) 
VALUES (1, 1, 1, 99.99);
SAVEPOINT create_order;

-- 步骤4：扣减用户余额
UPDATE users SET balance = balance - 99.99 WHERE id = 1;

-- 步骤5：检查余额是否足够
IF (SELECT balance FROM users WHERE id = 1) < 0 THEN
    ROLLBACK TO create_order;  -- 余额不足，回滚到订单创建前
    SELECT '余额不足，订单已取消' AS result;
ELSE
    COMMIT;  -- 一切正常，提交事务
    SELECT '订单创建成功' AS result;
END IF;
```

### 9.2 银行转账系统


```sql
-- 转账业务的完整事务控制
START TRANSACTION;

-- 设置变量
SET @from_account = 1001;
SET @to_account = 1002;  
SET @amount = 500.00;

-- 步骤1：检查转出账户余额
SELECT balance INTO @from_balance 
FROM accounts WHERE account_id = @from_account;

-- 步骤2：验证余额充足
IF @from_balance < @amount THEN
    ROLLBACK;
    SELECT '余额不足，转账失败' AS message;
ELSE
    -- 步骤3：转出金额
    UPDATE accounts 
    SET balance = balance - @amount 
    WHERE account_id = @from_account;
    
    SAVEPOINT debit_complete;
    
    -- 步骤4：转入金额  
    UPDATE accounts 
    SET balance = balance + @amount 
    WHERE account_id = @to_account;
    
    -- 步骤5：记录转账日志
    INSERT INTO transfer_log (from_account, to_account, amount, transfer_time)
    VALUES (@from_account, @to_account, @amount, NOW());
    
    COMMIT;
    SELECT '转账成功' AS message;
END IF;
```

### 9.3 批量数据处理


```sql
-- 批量导入用户数据（带错误处理）
SET AUTOCOMMIT = 0;  -- 关闭自动提交

START TRANSACTION;

-- 批处理开始
INSERT INTO users (name, email) VALUES ('用户1', 'user1@email.com');
INSERT INTO users (name, email) VALUES ('用户2', 'user2@email.com');
SAVEPOINT batch1;

INSERT INTO users (name, email) VALUES ('用户3', 'user3@email.com');  
INSERT INTO users (name, email) VALUES ('用户4', 'user4@email.com');
SAVEPOINT batch2;

-- 假设这里有重复邮箱导致错误
INSERT INTO users (name, email) VALUES ('用户5', 'user1@email.com');  
-- 出错！回滚到batch2，保留前4个用户
ROLLBACK TO batch2;

-- 继续处理正确的数据
INSERT INTO users (name, email) VALUES ('用户5', 'user5@email.com');

COMMIT;  -- 提交成功的4个用户数据

SET AUTOCOMMIT = 1;  -- 恢复自动提交
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 事务本质：一组操作要么全成功，要么全失败
🔸 START/BEGIN：开始事务，开启"记录模式"
🔸 COMMIT：确认提交，让变更永久生效  
🔸 ROLLBACK：撤销回滚，恢复到事务开始前
🔸 SAVEPOINT：设置存档点，支持部分回滚
🔸 RELEASE：释放保存点，节省系统资源
🔸 AUTOCOMMIT：控制自动提交模式的开关
```

### 10.2 关键理解要点


**🔹 事务的生命周期**
```
开始阶段：START TRANSACTION 
         ↓
执行阶段：各种 INSERT/UPDATE/DELETE 操作
         ↓  
决策阶段：COMMIT (成功) 或 ROLLBACK (失败)
         ↓
结束阶段：事务完成，释放资源
```

**🔹 保存点的精妙之处**
```
没有保存点：出错后只能全部撤销
有了保存点：可以精确回滚到任意位置

就像游戏存档：
- 可以回到任意存档点
- 不用重新开始整个游戏  
- 大大提高容错能力
```

**🔹 自动提交的选择**
```
开启AUTOCOMMIT：适合简单操作，每条SQL立即生效
关闭AUTOCOMMIT：适合复杂业务，手动控制事务边界

大多数情况：保持自动提交开启，需要时用显式事务
```

### 10.3 实际应用指导


**🎯 事务使用场景判断**
- ✅ **金融操作**：转账、支付、充值等
- ✅ **电商业务**：下单、库存管理、积分变动
- ✅ **用户管理**：注册流程、权限变更
- ✅ **批量处理**：数据导入、批量更新
- ✅ **关联操作**：主表和从表同时更新

**🛠️ 最佳实践原则**
```
1. 事务尽可能短小：减少锁定时间
2. 避免长时间事务：防止锁等待超时  
3. 合理使用保存点：复杂逻辑的精确控制
4. 及时释放资源：RELEASE不需要的保存点
5. 异常处理完整：确保错误时能正确回滚
```

**⚠️ 常见陷阱避免**
- **忘记COMMIT**：事务一直占用锁资源
- **无限等待**：两个事务互相等待对方释放锁
- **部分成功**：没有用事务导致数据不一致
- **过度使用**：简单操作不需要显式事务

### 10.4 不同数据库的差异


| 数据库 | **开始事务** | **特色功能** | **注意事项** |
|--------|-------------|-------------|-------------|
| 🟢 **MySQL** | `START TRANSACTION` | `支持所有标准功能` | `InnoDB引擎才支持事务` |
| 🔵 **Oracle** | `自动开始事务` | `回滚段管理` | `DDL语句自动提交` |
| 🟡 **SQL Server** | `BEGIN TRANSACTION` | `命名事务支持` | `嵌套事务计数器` |
| 🟣 **PostgreSQL** | `BEGIN` | `SERIALIZABLE隔离级别` | `DDL语句可回滚` |

**核心记忆口诀**：
```
事务控制八个词，START开始要牢记
COMMIT提交变永久，ROLLBACK回滚悔棋子  
SAVEPOINT存档有妙用，RELEASE释放省资源
TRANSACTION明确指定，AUTOCOMMIT自动提交
```