---
title: 23、BINLOG过滤与路由规则
---
## 📚 目录

1. [BINLOG过滤基础概念](#1-BINLOG过滤基础概念)
2. [数据库级过滤规则](#2-数据库级过滤规则)
3. [表级过滤规则](#3-表级过滤规则)
4. [通配符与正则过滤](#4-通配符与正则过滤)
5. [过滤规则优先级](#5-过滤规则优先级)
6. [复制过滤配置](#6-复制过滤配置)
7. [性能影响与优化](#7-性能影响与优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 BINLOG过滤基础概念


### 1.1 什么是BINLOG过滤


**简单理解**：BINLOG过滤就像是给数据库操作设置了一个"筛子"，只让符合条件的操作记录到二进制日志中。

```
现实类比：
邮件过滤器 → 只接收重要邮件，垃圾邮件直接丢弃
BINLOG过滤 → 只记录指定的数据库/表操作，其他操作不记录

作用效果：
原始操作：插入用户表、更新订单表、删除日志表
过滤后：只记录用户表和订单表操作，日志表操作忽略
```

### 1.2 过滤的核心作用


**🔹 为什么需要过滤？**
```
减少存储空间：
- 临时表、日志表的操作通常不需要记录
- 测试数据的操作可以过滤掉
- 减少BINLOG文件大小

提升复制性能：
- 从库不需要复制所有操作
- 减少网络传输量
- 加快从库同步速度

增强安全性：
- 敏感数据库的操作可以不记录
- 防止敏感信息泄露到从库
```

### 1.3 过滤的基本原理


**工作机制图示**：
```
SQL操作 → 过滤规则检查 → 符合条件？ → 写入BINLOG
   ↓              ↓           ↓             ↓
UPDATE user    检查规则     user表在      记录到BINLOG
SET name=?     user表过滤   包含列表中    ✓ 执行写入

UPDATE temp    检查规则     temp表在      跳过记录
SET data=?     temp表过滤   忽略列表中    ✗ 不写入
```

**🔧 过滤发生的位置**
```
主库端过滤：
- 在写入BINLOG前过滤
- 配置binlog_do_db、binlog_ignore_db
- 影响所有从库

从库端过滤：
- 在应用BINLOG时过滤  
- 配置replicate_do_db、replicate_ignore_db
- 只影响当前从库
```

---

## 2. 💾 数据库级过滤规则


### 2.1 binlog_do_db配置详解


**🔸 基本概念**：`binlog_do_db`指定哪些数据库的操作需要记录到BINLOG中

```ini
# my.cnf配置示例
[mysqld]
# 只记录这些数据库的操作
binlog_do_db = userdb
binlog_do_db = orderdb
binlog_do_db = productdb

# 多个数据库可以分行配置
```

**📝 配置说明**
```
生效方式：
- 只能在配置文件中设置
- 重启MySQL后生效
- 动态修改不支持

匹配规则：
- 精确匹配数据库名
- 区分大小写
- 不支持通配符
```

**💡 实际使用示例**
```sql
-- 当前默认数据库是userdb
USE userdb;
UPDATE users SET name='张三' WHERE id=1;
-- ✓ 会记录到BINLOG（userdb在允许列表中）

-- 切换到日志数据库
USE logdb;  
INSERT INTO access_log VALUES(NOW(), 'login');
-- ✗ 不会记录到BINLOG（logdb不在允许列表中）

-- 跨数据库操作
USE userdb;
UPDATE logdb.access_log SET status=1;
-- ✗ 不会记录（当前数据库是userdb，但操作的是logdb表）
```

### 2.2 binlog_ignore_db配置详解


**🔸 基本概念**：`binlog_ignore_db`指定哪些数据库的操作不记录到BINLOG中

```ini
# my.cnf配置示例
[mysqld]
# 忽略这些数据库的操作
binlog_ignore_db = information_schema
binlog_ignore_db = performance_schema
binlog_ignore_db = mysql
binlog_ignore_db = test
binlog_ignore_db = tempdb
```

**⚠️ 重要注意事项**
```
跨数据库操作的陷阱：
USE userdb;  -- 当前数据库：userdb
UPDATE tempdb.data SET value=1;  
-- 结果：会记录到BINLOG！
-- 原因：判断依据是当前数据库(userdb)，不是操作的表所在数据库

正确的做法：
USE tempdb;  -- 切换到要忽略的数据库
UPDATE data SET value=1;
-- 结果：不会记录到BINLOG
```

### 2.3 数据库级过滤的最佳实践


**📋 配置建议**
```ini
# 推荐的基础配置
[mysqld]
# 明确指定需要复制的业务数据库
binlog_do_db = userdb
binlog_do_db = orderdb  
binlog_do_db = productdb

# 忽略系统和临时数据库
binlog_ignore_db = information_schema
binlog_ignore_db = performance_schema  
binlog_ignore_db = mysql
binlog_ignore_db = sys
binlog_ignore_db = test
binlog_ignore_db = temp
```

**🔍 配置验证方法**
```sql
-- 查看当前过滤配置
SHOW VARIABLES LIKE 'binlog_do_db';
SHOW VARIABLES LIKE 'binlog_ignore_db';

-- 测试过滤效果
SHOW BINARY LOGS;
SHOW BINLOG EVENTS IN 'mysql-bin.000001' LIMIT 10;
```

---

## 3. 📋 表级过滤规则


### 3.1 表级过滤的优势


**🔹 为什么需要表级过滤？**
```
更精细控制：
数据库级：只能按整个数据库过滤
表级：可以精确到具体表

实际需求场景：
- 用户数据库中有用户表(需要复制)和日志表(不需要复制)
- 订单数据库中有订单表(需要复制)和临时表(不需要复制)
- 同一个数据库内的不同表有不同的复制需求
```

### 3.2 主库端表级过滤


**配置方式**（需要自定义实现）：
```sql
-- MySQL原生不直接支持主库端表级过滤
-- 可以通过以下方式实现：

-- 方法1：使用触发器控制
DELIMITER $$
CREATE TRIGGER ignore_temp_table_binlog
BEFORE INSERT ON temp_table
FOR EACH ROW
BEGIN
  -- 在触发器中不执行实际插入
  -- 或者使用SET sql_log_bin=0临时关闭
END$$
DELIMITER ;

-- 方法2：应用层控制
-- 在应用代码中对特定表操作使用：
SET sql_log_bin=0;  -- 临时关闭BINLOG
UPDATE temp_table SET data='test';
SET sql_log_bin=1;  -- 重新开启BINLOG
```

### 3.3 从库端表级过滤


**🔧 replicate_do_table配置**
```ini
# my.cnf配置
[mysqld]
# 只复制指定的表
replicate_do_table = userdb.users
replicate_do_table = userdb.profiles  
replicate_do_table = orderdb.orders
replicate_do_table = orderdb.order_items
```

**🔧 replicate_ignore_table配置**
```ini
# my.cnf配置  
[mysqld]
# 忽略指定的表
replicate_ignore_table = userdb.access_log
replicate_ignore_table = userdb.temp_data
replicate_ignore_table = orderdb.cache_table
```

**📊 表级过滤配置对比**

| 配置项 | **作用** | **适用场景** | **注意事项** |
|--------|----------|-------------|-------------|
| `replicate_do_table` | `只复制指定表` | `明确知道需要复制的表` | `需要逐一列出所有表` |
| `replicate_ignore_table` | `忽略指定表` | `大部分表需要复制，少数不需要` | `新增表默认会复制` |

---

## 4. 🔍 通配符与正则过滤


### 4.1 通配符过滤规则


**🔸 replicate_wild_do_table配置**
```ini
# my.cnf配置
[mysqld]
# 使用通配符匹配表名
replicate_wild_do_table = userdb.user_%    # 匹配user_开头的表
replicate_wild_do_table = orderdb.order_%  # 匹配order_开头的表  
replicate_wild_do_table = %.main_%         # 匹配所有数据库中main_开头的表
```

**🔸 replicate_wild_ignore_table配置**
```ini
# my.cnf配置
[mysqld]
# 忽略匹配的表
replicate_wild_ignore_table = %.temp_%     # 忽略所有temp_开头的表
replicate_wild_ignore_table = %.log_%      # 忽略所有log_开头的表
replicate_wild_ignore_table = %.cache_%    # 忽略所有cache_开头的表
```

**💡 通配符规则说明**
```
支持的通配符：
% - 匹配任意字符序列（包括空字符）
_ - 匹配单个字符

匹配示例：
user_%  匹配：user_info, user_profile, user_settings
user_%  不匹配：users, userdata, admin_user

log_%   匹配：log_access, log_error, log_2024
log_%   不匹配：logs, application_log
```

### 4.2 正则表达式过滤


**🔧 使用正则过滤**（通过自定义脚本实现）
```bash
#!/bin/bash
# binlog_filter.sh - 基于正则的BINLOG过滤脚本

# 定义过滤规则
IGNORE_PATTERNS=(
    "temp_[0-9]+"           # 忽略temp_数字的表
    ".*_backup$"            # 忽略以_backup结尾的表
    "test_.*_[0-9]{8}"      # 忽略test_开头_日期结尾的表
)

# 解析BINLOG并应用过滤
mysqlbinlog mysql-bin.000001 | while read line; do
    should_filter=false
    
    for pattern in "${IGNORE_PATTERNS[@]}"; do
        if [[ $line =~ $pattern ]]; then
            should_filter=true
            break
        fi
    done
    
    if [[ $should_filter == false ]]; then
        echo "$line"
    fi
done
```

**📝 正则过滤的应用场景**
```
动态表名过滤：
- 按日期分区的表：log_20240101, log_20240102
- 临时表：temp_1234567890
- 测试表：test_feature_20240101

复杂命名规则：
- 业务模块表：user_basic, user_extend, user_relation
- 系统表：sys_config, sys_monitor, sys_cache
```

---

## 5. ⚖️ 过滤规则优先级


### 5.1 规则优先级机制


**🔸 优先级顺序**（从高到低）
```
1. replicate_do_table (精确表名)
2. replicate_ignore_table (精确表名)  
3. replicate_wild_do_table (通配符表名)
4. replicate_wild_ignore_table (通配符表名)
5. replicate_do_db (数据库名)
6. replicate_ignore_db (数据库名)
```

**📊 优先级判断流程图**
```
接收到BINLOG事件
        ↓
是否在replicate_do_table中？ → 是 → 复制
        ↓ 否
是否在replicate_ignore_table中？ → 是 → 忽略  
        ↓ 否
是否匹配replicate_wild_do_table？ → 是 → 复制
        ↓ 否
是否匹配replicate_wild_ignore_table？ → 是 → 忽略
        ↓ 否
当前数据库在replicate_do_db中？ → 是 → 复制
        ↓ 否
当前数据库在replicate_ignore_db中？ → 是 → 忽略
        ↓ 否
默认复制
```

### 5.2 优先级实例分析


**配置示例**：
```ini
[mysqld]
# 精确表配置
replicate_do_table = userdb.users
replicate_ignore_table = userdb.user_temp

# 通配符配置
replicate_wild_do_table = userdb.user_%
replicate_wild_ignore_table = %.temp_%

# 数据库配置
replicate_do_db = userdb
replicate_ignore_db = logdb
```

**🧪 测试不同表的处理结果**
```sql
-- 测试用例分析
userdb.users        → 复制 (精确匹配replicate_do_table)
userdb.user_temp    → 忽略 (精确匹配replicate_ignore_table)
userdb.user_profile → 复制 (通配符匹配replicate_wild_do_table)
userdb.temp_cache   → 忽略 (通配符匹配replicate_wild_ignore_table)
userdb.orders       → 复制 (数据库级replicate_do_db)
logdb.access_log    → 忽略 (数据库级replicate_ignore_db)
```

### 5.3 优先级冲突处理


**⚠️ 常见冲突情况**
```
情况1：do和ignore同时匹配
配置：
replicate_do_table = userdb.user_log
replicate_ignore_table = userdb.user_log

结果：复制 (do规则优先级更高)

情况2：精确和通配符冲突  
配置：
replicate_ignore_table = userdb.user_temp
replicate_wild_do_table = userdb.user_%

表名：userdb.user_temp
结果：忽略 (精确匹配优先级更高)
```

---

## 6. 🔄 复制过滤配置


### 6.1 从库复制过滤配置


**🔧 完整的从库过滤配置示例**
```ini
# my.cnf - 从库配置
[mysqld]
# 服务器ID
server_id = 2

# 复制相关基础配置
log_bin = mysql-bin
relay_log = relay-bin
read_only = 1

# 数据库级过滤
replicate_do_db = userdb
replicate_do_db = orderdb
replicate_ignore_db = information_schema
replicate_ignore_db = performance_schema
replicate_ignore_db = mysql
replicate_ignore_db = sys

# 表级精确过滤
replicate_do_table = userdb.users
replicate_do_table = userdb.user_profiles
replicate_ignore_table = userdb.access_log
replicate_ignore_table = userdb.session_data

# 表级通配符过滤  
replicate_wild_do_table = orderdb.order_%
replicate_wild_ignore_table = %.temp_%
replicate_wild_ignore_table = %.cache_%
replicate_wild_ignore_table = %.log_%
```

### 6.2 动态修改过滤规则


**📝 运行时修改方法**
```sql
-- 查看当前复制过滤配置
SHOW SLAVE STATUS\G

-- 停止复制
STOP SLAVE;

-- 动态添加过滤规则（需要重启生效）
-- 以下命令仅用于测试，生产环境建议修改配置文件

-- 重新启动复制
START SLAVE;

-- 验证过滤效果
SHOW SLAVE STATUS\G
```

**🔄 过滤规则变更流程**
```
规划变更 → 测试环境验证 → 备份配置 → 停止复制 → 修改配置 → 重启MySQL → 启动复制 → 验证效果
```

### 6.3 多从库不同过滤策略


**🏗️ 多从库架构示例**
```
主库 (mysql-master)
├── 从库1 (mysql-slave1) - 完整复制
│   └── 复制所有数据库和表
├── 从库2 (mysql-slave2) - 业务数据复制  
│   └── 只复制userdb和orderdb
└── 从库3 (mysql-slave3) - 分析数据复制
    └── 只复制userdb.users和orderdb.orders
```

**配置对比**：
```ini
# 从库1配置 - 完整复制
[mysqld]
server_id = 101
# 不配置任何过滤规则，复制所有内容

# 从库2配置 - 业务数据
[mysqld]  
server_id = 102
replicate_do_db = userdb
replicate_do_db = orderdb

# 从库3配置 - 分析数据
[mysqld]
server_id = 103  
replicate_do_table = userdb.users
replicate_do_table = orderdb.orders
```

---

## 7. ⚡ 性能影响与优化


### 7.1 过滤对性能的影响


**🔹 主库端过滤影响**
```
CPU使用：
- 规则匹配需要消耗CPU资源
- 复杂正则表达式匹配成本更高
- 大量过滤规则增加判断时间

I/O影响：
- 过滤掉的操作不写入BINLOG
- 减少磁盘写入量
- 降低BINLOG文件大小

内存使用：
- 过滤规则缓存在内存中
- 规则数量过多占用内存
```

**🔹 从库端过滤影响**
```
网络传输：
- 从库端过滤不能减少网络传输
- 所有BINLOG事件仍需要传输到从库
- 在从库端才进行过滤判断

应用延迟：
- 过滤规则匹配增加延迟
- 复杂规则影响复制速度
- 大量忽略事件仍需要处理
```

### 7.2 性能优化建议


**📈 优化策略**
```
规则设计优化：
✅ 优先使用精确匹配而非通配符
✅ 减少过滤规则数量
✅ 避免复杂的正则表达式
✅ 合并相似的过滤规则

配置位置优化：
✅ 优先在主库端过滤(减少传输)
✅ 从库端过滤作为补充
✅ 避免重复过滤配置

监控和调优：
✅ 监控BINLOG大小变化
✅ 检查复制延迟情况
✅ 定期审查过滤规则的有效性
```

### 7.3 过滤性能测试


**🧪 性能测试方法**
```sql
-- 测试前记录基准数据
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE 
FROM performance_schema.global_status 
WHERE VARIABLE_NAME IN (
    'Binlog_cache_use',
    'Binlog_cache_disk_use',
    'Slave_running'
);

-- 执行大量测试数据
INSERT INTO test_table SELECT * FROM large_table;

-- 测试后对比性能指标
SHOW SLAVE STATUS\G
SHOW BINARY LOGS;
```

**📊 性能评估指标**
```
主库指标：
- BINLOG文件大小减少百分比
- 写入延迟变化
- CPU使用率变化

从库指标：  
- 复制延迟 (Seconds_Behind_Master)
- 网络传输量
- 规则匹配耗时
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 过滤基本概念：选择性记录或复制数据库操作到BINLOG
🔸 过滤类型：数据库级、表级、通配符、正则表达式过滤
🔸 配置位置：主库端过滤 vs 从库端过滤的区别和应用
🔸 优先级机制：精确匹配 > 通配符匹配 > 数据库级匹配
🔸 性能影响：过滤规则的性能代价和优化策略
```

### 8.2 关键理解要点


**🔹 主库端 vs 从库端过滤的选择**
```
主库端过滤 (binlog_do_db/binlog_ignore_db)：
优势：减少BINLOG大小，降低网络传输
劣势：影响所有从库，配置变更需要重启

从库端过滤 (replicate_*系列)：
优势：每个从库可以独立配置，灵活性高
劣势：仍需要传输所有数据，只在应用时过滤
```

**🔹 过滤规则设计原则**
```
明确性原则：
- 精确指定需要/不需要的数据库和表
- 避免模糊的通配符规则

性能原则：
- 优先使用精确匹配
- 减少规则数量和复杂度

维护原则：
- 定期审查过滤规则的有效性
- 文档记录每个规则的用途
```

**🔹 常见陷阱和注意事项**
```
跨数据库操作陷阱：
USE db1;
UPDATE db2.table1 SET col=1;  -- 按当前数据库db1判断，不是db2

通配符匹配范围：
%.temp_%  匹配所有数据库的temp_开头表，可能过于宽泛

优先级混淆：
精确表名配置的优先级高于通配符配置
```

### 8.3 实际应用指导


**📋 配置建议清单**
```
基础配置：
□ 明确业务数据库和系统数据库的划分
□ 配置忽略MySQL系统数据库
□ 设置忽略临时表和日志表

高级配置：
□ 使用表级过滤实现精细控制
□ 合理使用通配符简化配置
□ 设置多从库不同过滤策略

运维配置：
□ 建立过滤规则变更流程
□ 监控过滤效果和性能影响
□ 定期审查和优化过滤规则
```

**🔧 最佳实践要点**
```
设计阶段：
- 在系统设计时就考虑BINLOG过滤需求
- 建立清晰的数据库和表命名规范
- 区分业务数据、系统数据、临时数据

实施阶段：
- 在测试环境充分验证过滤规则
- 采用渐进式部署策略
- 保留配置变更的回滚方案

运维阶段：
- 监控BINLOG大小和复制延迟
- 定期检查过滤规则的有效性
- 建立过滤规则的文档和变更记录
```

**💡 故障排查要点**
```
复制中断排查：
1. 检查过滤规则是否过于严格
2. 确认表名和数据库名的大小写
3. 验证通配符规则的匹配范围

性能问题排查：
1. 统计过滤规则的匹配频率
2. 检查复杂正则表达式的性能影响
3. 对比过滤前后的性能指标

数据一致性问题：
1. 确认主从过滤配置的一致性
2. 检查跨数据库操作的过滤逻辑
3. 验证优先级规则的正确应用
```

**核心记忆**：
- BINLOG过滤是选择性记录和复制的关键技术
- 主库端过滤减存储，从库端过滤增灵活
- 精确匹配优先级最高，通配符次之，数据库级最低
- 过滤规则要平衡功能需求和性能影响
- 测试验证是过滤配置成功的重要保障