---
title: 5、ProxySQL用户认证与权限管理
---
## 📚 目录

1. [ProxySQL用户认证概述](#1-ProxySQL用户认证概述)
2. [mysql_users表管理](#2-mysql_users表管理)
3. [用户认证配置详解](#3-用户认证配置详解)
4. [密码管理策略](#4-密码管理策略)
5. [用户属性与权限设置](#5-用户属性与权限设置)
6. [连接控制与监控](#6-连接控制与监控)
7. [高级认证特性](#7-高级认证特性)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 ProxySQL用户认证概述


### 1.1 什么是ProxySQL用户认证


**🔸 基本概念**
```
ProxySQL用户认证：控制谁可以连接到ProxySQL的安全机制
作用：验证客户端身份，决定是否允许连接
位置：客户端和后端MySQL之间的中间认证层
```

**💡 认证流程示意**
```
客户端应用
    ↓ [用户名+密码]
ProxySQL认证层 ← mysql_users表验证
    ↓ [认证通过]
后端MySQL服务器
```

### 1.2 为什么需要ProxySQL用户认证


**🎯 核心价值**
```
🔸 统一入口：所有应用通过ProxySQL统一认证
🔸 安全隔离：隐藏后端MySQL的真实用户信息
🔸 权限控制：精细化的用户权限管理
🔸 连接管理：控制用户连接数和行为
🔸 审计监控：记录用户访问行为
```

**实际应用场景**
- **多应用环境**：不同应用使用不同的ProxySQL用户
- **权限分离**：开发、测试、生产环境用户隔离
- **安全加固**：避免直接暴露MySQL用户给应用

### 1.3 ProxySQL认证 vs MySQL认证


```
ProxySQL认证（前端）          MySQL认证（后端）
┌─────────────────┐         ┌─────────────────┐
│ 应用用户认证     │ ------> │ 实际MySQL用户   │
│ 权限控制        │         │ 数据库权限      │
│ 连接数限制      │         │ SQL执行权限     │
└─────────────────┘         └─────────────────┘

特点对比：
ProxySQL用户：面向应用，控制连接行为
MySQL用户：面向数据库，控制数据权限
```

---

## 2. 📋 mysql_users表管理


### 2.1 mysql_users表结构详解


**🔸 核心字段说明**
```sql
-- 查看mysql_users表结构
SELECT * FROM mysql_users;

主要字段含义：
username      : 用户名（必填）
password      : 密码（明文或hash）
active        : 是否激活（0=禁用，1=启用）
use_ssl       : 是否使用SSL（0=否，1=是）
default_hostgroup : 默认主机组ID
default_schema    : 默认数据库
schema_locked     : 是否锁定schema
transaction_persistent : 事务持久化
fast_forward      : 快速转发模式
backend_username  : 后端MySQL用户名
backend_password  : 后端MySQL密码
max_connections   : 最大连接数限制
```

### 2.2 基础用户管理操作


**🔧 创建用户**
```sql
-- 1. 插入新用户到mysql_users表
INSERT INTO mysql_users (
    username, 
    password, 
    active, 
    default_hostgroup, 
    max_connections
) VALUES (
    'app_user',           -- 应用用户名
    'app_password',       -- 用户密码
    1,                    -- 激活状态
    0,                    -- 默认读写组
    100                   -- 最大100个连接
);

-- 2. 加载配置到运行时
LOAD MYSQL USERS TO RUNTIME;

-- 3. 保存到磁盘
SAVE MYSQL USERS TO DISK;
```

**📝 用户查询与修改**
```sql
-- 查询所有用户
SELECT username, active, default_hostgroup, max_connections 
FROM mysql_users;

-- 修改用户密码
UPDATE mysql_users 
SET password = 'new_password' 
WHERE username = 'app_user';

-- 禁用用户
UPDATE mysql_users 
SET active = 0 
WHERE username = 'app_user';

-- 应用更改
LOAD MYSQL USERS TO RUNTIME;
```

**🗑️ 删除用户**
```sql
-- 删除用户
DELETE FROM mysql_users WHERE username = 'app_user';

-- 应用更改并保存
LOAD MYSQL USERS TO RUNTIME;
SAVE MYSQL USERS TO DISK;
```

### 2.3 批量用户管理


**📊 批量导入用户**
```sql
-- 批量插入多个用户
INSERT INTO mysql_users (username, password, active, default_hostgroup) VALUES
('dev_user', 'dev_pass', 1, 1),      -- 开发用户，只读组
('test_user', 'test_pass', 1, 1),    -- 测试用户，只读组  
('prod_user', 'prod_pass', 1, 0),    -- 生产用户，读写组
('report_user', 'report_pass', 1, 2); -- 报表用户，报表组

LOAD MYSQL USERS TO RUNTIME;
```

**🔄 用户配置模板**
```sql
-- 创建标准化的用户配置函数
-- 应用型用户模板
INSERT INTO mysql_users (
    username, password, active, 
    default_hostgroup, default_schema,
    max_connections, transaction_persistent
) VALUES (
    ?, ?,                    -- 用户名和密码
    1,                       -- 默认激活
    0,                       -- 读写组
    'app_db',               -- 默认数据库
    50,                      -- 中等连接数
    1                        -- 事务持久化
);
```

---

## 3. 🔑 用户认证配置详解


### 3.1 密码认证方式


**🔸 明文密码认证**
```sql
-- 最简单的明文密码方式
INSERT INTO mysql_users (username, password, active, default_hostgroup) 
VALUES ('user1', 'plaintext_password', 1, 0);

优点：配置简单，调试方便
缺点：安全性较低，密码明文存储
适用：开发测试环境
```

**🔒 Hash密码认证**
```sql
-- 使用MySQL密码hash
-- 先在MySQL中生成hash
SELECT PASSWORD('my_password');
-- 结果：*6C8989366EAF75BB670AD120B9F4673203B54F2E

-- 在ProxySQL中使用hash
INSERT INTO mysql_users (username, password, active, default_hostgroup) 
VALUES ('user2', '*6C8989366EAF75BB670AD120B9F4673203B54F2E', 1, 0);

优点：密码不明文存储
缺点：需要额外生成hash
适用：生产环境推荐
```

### 3.2 后端用户映射


**🔗 前后端用户分离**
```sql
-- ProxySQL用户 ≠ MySQL用户的映射关系
INSERT INTO mysql_users (
    username,           -- ProxySQL前端用户
    password,          -- ProxySQL认证密码
    active,
    default_hostgroup,
    backend_username,   -- 后端MySQL用户名
    backend_password    -- 后端MySQL密码
) VALUES (
    'app_frontend',     -- 应用连接的用户名
    'app_password',     -- 应用认证密码
    1, 0,
    'mysql_backend',    -- 实际MySQL用户
    'mysql_password'    -- MySQL用户密码
);

LOAD MYSQL USERS TO RUNTIME;
```

**💡 映射机制详解**
```
连接流程：
1. 应用使用 'app_frontend'/'app_password' 连接ProxySQL
2. ProxySQL验证通过后，使用 'mysql_backend'/'mysql_password' 连接MySQL
3. 实现前后端用户完全分离

好处：
- 应用无需知道真实MySQL用户信息
- 可以多个ProxySQL用户映射到同一个MySQL用户
- 便于统一管理和权限控制
```

### 3.3 默认用户组配置


**🎯 用户组分配策略**
```sql
-- 根据用户类型分配不同的默认主机组
INSERT INTO mysql_users (username, password, active, default_hostgroup) VALUES
-- 读写用户：默认主写库
('rw_user', 'rw_pass', 1, 0),        -- 主机组0：读写组
-- 只读用户：默认从库  
('ro_user', 'ro_pass', 1, 1),        -- 主机组1：只读组
-- 报表用户：专用报表库
('report_user', 'report_pass', 1, 2), -- 主机组2：报表组
-- 管理用户：DBA专用
('admin_user', 'admin_pass', 1, 3);   -- 主机组3：管理组

LOAD MYSQL USERS TO RUNTIME;
```

**📊 用户组权限对照表**

| 用户类型 | **default_hostgroup** | **权限说明** | **适用场景** |
|---------|---------------------|-------------|-------------|
| **读写用户** | `0` | `完整读写权限` | `业务应用` |
| **只读用户** | `1` | `仅查询权限` | `报表查询` |
| **报表用户** | `2` | `大查询优化` | `数据分析` |
| **管理用户** | `3` | `管理维护权限` | `DBA操作` |

---

## 4. 🔒 密码管理策略


### 4.1 密码安全策略


**🛡️ 密码强度要求**
```sql
-- 推荐的密码策略示例
-- 强密码：至少8位，包含大小写字母、数字、特殊字符

-- 生产环境用户密码示例
INSERT INTO mysql_users (username, password, active, default_hostgroup) VALUES
('prod_app', 'ProdApp#2024!', 1, 0),     -- 生产应用
('prod_ro', 'ReadOnly$2024', 1, 1),      -- 生产只读
('prod_dba', 'DbaAdmin@2024#', 1, 3);    -- DBA管理

-- 定期密码轮换策略
-- 建议每季度更新一次生产密码
```

**🔄 密码轮换实施**
```sql
-- 密码轮换步骤
-- 1. 生成新密码
UPDATE mysql_users 
SET password = 'NewPassword#2024!' 
WHERE username = 'prod_app';

-- 2. 测试验证
-- 使用新密码测试连接

-- 3. 应用到运行时
LOAD MYSQL USERS TO RUNTIME;

-- 4. 更新应用配置
-- 修改应用程序的数据库连接配置

-- 5. 保存配置
SAVE MYSQL USERS TO DISK;
```

### 4.2 密码存储最佳实践


**📋 安全存储建议**
```sql
-- 方式1：使用MySQL PASSWORD()函数
SELECT PASSWORD('secure_password_123');

-- 方式2：使用外部密码管理工具
-- 将生成的hash存储在ProxySQL中
INSERT INTO mysql_users (username, password, active, default_hostgroup) 
VALUES ('secure_user', '*HASH_FROM_EXTERNAL_TOOL', 1, 0);

-- 方式3：环境变量管理
-- 在启动脚本中从环境变量读取密码配置
```

---

## 5. ⚙️ 用户属性与权限设置


### 5.1 用户属性详解


**🔸 Schema相关属性**
```sql
-- schema_locked：锁定用户只能访问指定数据库
INSERT INTO mysql_users (
    username, password, active,
    default_hostgroup, default_schema, schema_locked
) VALUES (
    'locked_user', 'password', 1,
    0, 'specific_db', 1    -- 只能访问specific_db数据库
);

-- 应用场景：
-- 1. 多租户环境，每个租户只访问自己的数据库
-- 2. 安全要求高的环境，限制用户跨库访问
```

**⚡ 性能相关属性**
```sql
-- fast_forward：快速转发模式
INSERT INTO mysql_users (
    username, password, active,
    default_hostgroup, fast_forward
) VALUES (
    'fast_user', 'password', 1,
    0, 1                   -- 启用快速转发
);

-- 快速转发说明：
-- 启用时：跳过ProxySQL的一些处理逻辑，提高性能
-- 禁用时：完整的ProxySQL功能，包括查询路由、缓存等
```

### 5.2 事务处理属性


**🔄 事务持久化配置**
```sql
-- transaction_persistent：事务持久化
INSERT INTO mysql_users (
    username, password, active,
    default_hostgroup, transaction_persistent
) VALUES (
    'trans_user', 'password', 1,
    0, 1                   -- 启用事务持久化
);

-- 事务持久化含义：
-- 启用(1)：事务期间保持同一后端连接，保证事务一致性
-- 禁用(0)：事务中可能切换后端连接，性能更好但可能影响一致性
```

**📊 事务配置选择指南**

| 应用场景 | **transaction_persistent** | **说明** | **适用情况** |
|---------|--------------------------|---------|-------------|
| **OLTP业务** | `1` | `保证事务一致性` | `金融、电商等` |
| **只读查询** | `0` | `提高连接复用` | `报表、分析等` |
| **批量处理** | `1` | `避免事务异常` | `ETL、数据同步` |

### 5.3 SSL和安全属性


**🔒 SSL配置**
```sql
-- use_ssl：强制SSL连接
INSERT INTO mysql_users (
    username, password, active,
    default_hostgroup, use_ssl
) VALUES (
    'ssl_user', 'password', 1,
    0, 1                   -- 强制使用SSL
);

-- SSL使用场景：
-- 1. 跨网络传输，需要加密保护
-- 2. 敏感数据访问，要求高安全性
-- 3. 合规要求，必须加密传输
```

---

## 6. 📊 连接控制与监控


### 6.1 连接数限制管理


**🔢 max_connections设置**
```sql
-- 根据用户类型设置不同的连接数限制
INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES
('app_user', 'pass', 1, 0, 100),      -- 应用用户：100连接
('batch_user', 'pass', 1, 0, 10),     -- 批处理：10连接
('report_user', 'pass', 1, 1, 50),    -- 报表用户：50连接
('admin_user', 'pass', 1, 3, 5);      -- 管理用户：5连接

LOAD MYSQL USERS TO RUNTIME;
```

**⚖️ 连接数规划策略**
```
连接数设置原则：

🔸 应用类型考虑：
  - Web应用：根据并发用户数 × 1.5
  - 批处理：较小值，避免占用过多资源
  - 报表查询：中等值，平衡性能和资源

🔸 系统资源考虑：
  - 总连接数不超过MySQL max_connections
  - 考虑ProxySQL自身内存消耗
  - 预留管理和监控连接

🔸 业务特性考虑：
  - 高峰期连接需求
  - 连接保持时间
  - 突发访问模式
```

### 6.2 用户连接监控


**📈 连接状态查询**
```sql
-- 查看当前用户连接统计
SELECT * FROM stats_mysql_users;

-- 主要字段说明：
-- username：用户名
-- frontend_connections：前端连接数
-- frontend_max_connections：最大前端连接数
-- backend_connections：后端连接数
```

**🔍 实时连接监控**
```sql
-- 监控脚本示例
SELECT 
    username,
    frontend_connections as current_conn,
    frontend_max_connections as max_conn,
    ROUND(frontend_connections/frontend_max_connections*100, 2) as usage_pct
FROM stats_mysql_users 
WHERE frontend_connections > 0
ORDER BY usage_pct DESC;

-- 结果示例：
-- username    current_conn  max_conn  usage_pct
-- app_user    45           100       45.00
-- report_user 23           50        46.00
```

### 6.3 连接异常处理


**⚠️ 连接数超限处理**
```sql
-- 当用户连接数达到限制时的处理

-- 1. 查看超限用户
SELECT username, frontend_connections, frontend_max_connections
FROM stats_mysql_users 
WHERE frontend_connections >= frontend_max_connections;

-- 2. 临时调整连接数限制
UPDATE mysql_users 
SET max_connections = 150 
WHERE username = 'app_user';

LOAD MYSQL USERS TO RUNTIME;

-- 3. 查看连接详情
SELECT * FROM stats_mysql_connection_pool 
WHERE username = 'app_user';
```

---

## 7. 🚀 高级认证特性


### 7.1 认证插件支持


**🔌 MySQL认证插件兼容**
```sql
-- ProxySQL支持MySQL的各种认证插件
-- mysql_native_password（默认）
-- caching_sha2_password（MySQL 8.0默认）
-- sha256_password

-- 配置示例：无需特殊设置，ProxySQL自动适配
INSERT INTO mysql_users (username, password, active, default_hostgroup) 
VALUES ('mysql8_user', 'password', 1, 0);

-- ProxySQL会根据后端MySQL版本自动选择合适的认证方式
```

### 7.2 动态用户管理


**🔄 热更新用户配置**
```sql
-- 用户配置的三层结构
-- MEMORY（运行时） ← RUNTIME（内存） ← DISK（磁盘）

-- 1. 修改MEMORY层（立即生效）
UPDATE mysql_users SET active = 0 WHERE username = 'temp_user';

-- 2. 加载到RUNTIME（持久化到运行时）
LOAD MYSQL USERS TO RUNTIME;

-- 3. 保存到DISK（持久化到磁盘）
SAVE MYSQL USERS TO DISK;

-- 配置层级说明：
-- MEMORY：临时修改，重启ProxySQL后丢失
-- RUNTIME：运行时配置，重启后需要从DISK加载
-- DISK：永久配置，重启后自动加载
```

### 7.3 用户组权限映射


**🎯 复杂权限场景**
```sql
-- 场景：同一用户在不同时间段访问不同主机组
-- 通过查询规则实现动态路由

-- 1. 创建用户
INSERT INTO mysql_users (username, password, active, default_hostgroup) 
VALUES ('flex_user', 'password', 1, 0);

-- 2. 配置查询规则（在mysql_query_rules中）
-- 白天：读写操作 → 主库组(0)
-- 夜间：大查询 → 报表组(2)

-- 3. 结合时间窗口实现智能路由
-- 这种方式比简单的default_hostgroup更灵活
```

---

## 8. 💼 实际应用场景


### 8.1 多环境用户隔离


**🏗️ 开发/测试/生产环境**
```sql
-- 环境隔离用户配置方案
-- 开发环境用户
INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES
('dev_app', 'dev_password', 1, 1, 20),     -- 开发应用，只读组
('dev_dba', 'dev_dba_pass', 1, 0, 5);     -- 开发DBA，读写组

-- 测试环境用户  
INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES
('test_app', 'test_password', 1, 1, 30),   -- 测试应用，只读组
('test_dba', 'test_dba_pass', 1, 0, 5);   -- 测试DBA，读写组

-- 生产环境用户
INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES
('prod_app', 'prod_password', 1, 0, 100),  -- 生产应用，读写组
('prod_ro', 'prod_ro_pass', 1, 1, 50),     -- 生产只读，只读组
('prod_dba', 'prod_dba_pass', 1, 3, 10);   -- 生产DBA，管理组

LOAD MYSQL USERS TO RUNTIME;
SAVE MYSQL USERS TO DISK;
```

### 8.2 微服务架构用户管理


**🔗 服务化用户配置**
```sql
-- 为不同微服务创建专用用户
INSERT INTO mysql_users (username, password, active, default_hostgroup, default_schema, schema_locked, max_connections) VALUES
-- 用户服务
('user_service', 'user_pass', 1, 0, 'user_db', 1, 50),
-- 订单服务  
('order_service', 'order_pass', 1, 0, 'order_db', 1, 80),
-- 支付服务
('payment_service', 'payment_pass', 1, 0, 'payment_db', 1, 30),
-- 商品服务
('product_service', 'product_pass', 1, 1, 'product_db', 1, 60);  -- 只读

-- 优势：
-- 1. 服务间数据隔离
-- 2. 独立的连接数控制
-- 3. 精细化的权限管理
-- 4. 便于审计和监控
```

### 8.3 读写分离场景配置


**📖 读写分离用户策略**
```sql
-- 读写分离专用用户配置
INSERT INTO mysql_users (username, password, active, default_hostgroup, transaction_persistent, max_connections) VALUES
-- 写操作用户：默认主库，事务持久化
('app_writer', 'write_pass', 1, 0, 1, 50),
-- 读操作用户：默认从库，无需事务持久化  
('app_reader', 'read_pass', 1, 1, 0, 100),
-- 报表用户：专用报表库，大查询优化
('app_reporter', 'report_pass', 1, 2, 0, 20);

-- 应用层使用建议：
-- 1. 写操作使用 app_writer
-- 2. 查询操作使用 app_reader  
-- 3. 报表分析使用 app_reporter
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 ProxySQL用户认证：前端认证层，控制应用访问权限
🔸 mysql_users表：用户配置的核心表，包含所有用户信息
🔸 前后端用户分离：ProxySQL用户≠MySQL用户，实现安全隔离
🔸 用户属性配置：连接数、默认组、SSL、事务等属性控制
🔸 三层配置管理：MEMORY→RUNTIME→DISK的配置生效机制
```

### 9.2 关键理解要点


**🔹 用户认证的本质**
```
理解要点：
- ProxySQL用户是应用连接的身份标识
- 通过用户属性控制应用的数据库访问行为
- 实现应用和数据库之间的安全隔离层
```

**🔹 连接数管理的重要性**
```
核心价值：
- 防止单个应用占用过多连接资源
- 保护数据库免受连接数攻击
- 实现不同业务的资源隔离
```

**🔹 密码安全的最佳实践**
```
安全原则：
- 生产环境避免明文密码
- 定期轮换密码策略
- 使用强密码组合
- 前后端密码分离管理
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **多租户系统**：每个租户使用独立的ProxySQL用户
- **微服务架构**：服务间数据访问隔离和权限控制
- **读写分离**：不同操作类型使用不同用户和主机组
- **环境隔离**：开发、测试、生产环境的用户权限分离

**🔧 运维实践价值**
- **安全加固**：隐藏真实MySQL用户信息
- **权限管控**：精细化的用户权限和行为控制
- **监控审计**：用户级别的连接和操作监控
- **故障隔离**：问题应用不影响其他业务

### 9.4 常见问题与解决


**❓ 用户无法连接**
```
排查步骤：
1. 检查用户是否存在且激活：SELECT * FROM mysql_users WHERE username='xxx'
2. 验证密码是否正确
3. 确认配置是否加载到运行时：LOAD MYSQL USERS TO RUNTIME
4. 检查连接数是否达到限制
```

**❓ 连接数限制问题**
```
解决方案：
1. 查看当前连接数：SELECT * FROM stats_mysql_users
2. 调整max_connections参数
3. 优化应用连接池配置
4. 分析连接使用模式
```

**核心记忆**：
- ProxySQL用户认证是应用访问数据库的第一道安全屏障
- mysql_users表是用户管理的核心，包含用户的所有属性配置
- 合理的用户权限设计是系统安全和性能的重要保障
- 三层配置管理确保配置的灵活性和持久性