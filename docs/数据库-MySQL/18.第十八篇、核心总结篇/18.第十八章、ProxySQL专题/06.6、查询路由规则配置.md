---
title: 6、查询路由规则配置
---
## 📚 目录

1. [查询路由规则概述](#1-查询路由规则概述)
2. [mysql_query_rules表详解](#2-mysql_query_rules表详解)
3. [查询匹配机制](#3-查询匹配机制)
4. [路由规则配置实战](#4-路由规则配置实战)
5. [高级功能配置](#5-高级功能配置)
6. [最佳实践与优化](#6-最佳实践与优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 查询路由规则概述


### 1.1 什么是查询路由规则


**💡 通俗理解**
想象一下邮局的分拣员，他们根据信封上的地址把信件分发到不同的投递员手中。ProxySQL的查询路由规则就像这个分拣员，它会检查每条SQL语句，然后决定把这条SQL发送到哪个数据库服务器。

```
客户端发送SQL  →  ProxySQL检查规则  →  路由到目标服务器

例如：
SELECT语句 → 发送到只读从库
INSERT语句 → 发送到主库
复杂查询   → 发送到分析专用库
```

**🔍 核心作用**
- **智能分发**：根据SQL内容自动选择最合适的数据库
- **性能优化**：让不同类型的查询在最合适的服务器上执行
- **负载均衡**：避免某台服务器承受过大压力
- **业务隔离**：重要查询和普通查询分开处理

### 1.2 为什么需要查询路由


**🏗️ 现实场景分析**

```
传统方案的问题：
应用程序 → 直连数据库
├─ 所有查询都打到主库
├─ 读写混合造成性能瓶颈
└─ 无法灵活调度资源

ProxySQL路由方案：
应用程序 → ProxySQL → 智能路由
├─ 读查询 → 从库（性能好）
├─ 写操作 → 主库（数据一致）
├─ 分析查询 → 专用服务器
└─ 缓存查询 → 内存缓存
```

**📊 实际收益**
- **性能提升**：读写分离可提升30-50%查询性能
- **资源优化**：合理利用各服务器资源
- **稳定性增强**：避免单点过载
- **扩展灵活**：新增服务器无需修改应用代码

---

## 2. 📋 mysql_query_rules表详解


### 2.1 核心配置表结构


**🔧 mysql_query_rules表字段详解**

```sql
-- 查看规则表结构
SELECT * FROM mysql_query_rules ORDER BY rule_id;
```

**主要字段说明：**

| 字段名 | 类型 | **作用说明** | **示例值** |
|--------|------|-------------|-----------|
| `rule_id` | INT | `规则唯一标识，执行优先级` | `1, 2, 3...` |
| `match_pattern` | VARCHAR | `SQL匹配正则表达式` | `^SELECT.*` |
| `destination_hostgroup` | INT | `目标服务器组ID` | `0, 1, 2` |
| `apply` | INT | `是否应用规则（0/1）` | `1` |
| `active` | INT | `规则是否激活（0/1）` | `1` |

```
💡 理解要点：
rule_id数字越小，优先级越高
就像排队一样，1号比2号先被处理
```

### 2.2 关键字段深入解析


**🎯 match_pattern（匹配模式）**

```sql
-- 示例：匹配所有SELECT查询
match_pattern = '^SELECT.*'

-- 示例：匹配特定表的查询
match_pattern = '.*FROM users.*'

-- 示例：匹配INSERT操作
match_pattern = '^INSERT.*'
```

**🏷️ destination_hostgroup（目标主机组）**

```
主机组划分原则：
hostgroup 0 → 主库（写操作）
hostgroup 1 → 从库（读操作）
hostgroup 2 → 分析库（复杂查询）
hostgroup 3 → 缓存组（高频查询）
```

**⚙️ 控制字段组合**

```sql
-- 完整规则示例
INSERT INTO mysql_query_rules(
  rule_id,
  match_pattern,
  destination_hostgroup,
  apply,
  active
) VALUES (
  1,                    -- 最高优先级
  '^SELECT.*',         -- 匹配所有SELECT
  1,                   -- 路由到从库组
  1,                   -- 应用此规则
  1                    -- 规则激活
);
```

### 2.3 规则管理命令


**📝 基本操作命令**

```sql
-- 查看当前所有规则
SELECT rule_id, match_pattern, destination_hostgroup, apply 
FROM mysql_query_rules 
ORDER BY rule_id;

-- 添加新规则
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) 
VALUES (10, '^SELECT COUNT.*', 2, 1);

-- 修改现有规则
UPDATE mysql_query_rules 
SET destination_hostgroup = 3 
WHERE rule_id = 10;

-- 删除规则
DELETE FROM mysql_query_rules WHERE rule_id = 10;

-- 加载配置到运行时
LOAD MYSQL QUERY RULES TO RUNTIME;

-- 保存到磁盘
SAVE MYSQL QUERY RULES TO DISK;
```

---

## 3. 🔍 查询匹配机制


### 3.1 正则表达式匹配原理


**📖 正则表达式基础**

```
常用正则符号：
^     → 行开始
$     → 行结束
.*    → 任意字符
\w+   → 单词字符
\d+   → 数字
|     → 或条件
()    → 分组
[]    → 字符类
```

**🎯 实用匹配模式**

```sql
-- 1. 读操作匹配
match_pattern = '^SELECT.*'
-- 解释：以SELECT开头的所有语句

-- 2. 写操作匹配  
match_pattern = '^(INSERT|UPDATE|DELETE).*'
-- 解释：以INSERT、UPDATE或DELETE开头的语句

-- 3. 特定表匹配
match_pattern = '.*FROM orders.*'
-- 解释：包含"FROM orders"的查询

-- 4. 用户相关查询
match_pattern = '.*users.*WHERE.*id.*=.*'
-- 解释：查询users表且有WHERE id条件的语句
```

### 3.2 匹配执行流程


**🔄 规则执行顺序**

```
查询路由执行流程：
                           
客户端SQL请求
    ↓
┌─────────────────┐
│ ProxySQL接收    │
└─────────────────┘
    ↓
┌─────────────────┐
│ 按rule_id排序   │ ← 1, 2, 3, 4...
└─────────────────┘
    ↓
┌─────────────────┐
│ 逐个匹配规则    │ ← 使用正则表达式
└─────────────────┘
    ↓
┌─────────────────┐
│ 找到匹配规则    │ ← 第一个匹配的规则
└─────────────────┘
    ↓
┌─────────────────┐
│ 路由到目标组    │ ← destination_hostgroup
└─────────────────┘
```

**⚡ 关键特性**
- **顺序执行**：按rule_id从小到大检查
- **首次匹配**：找到第一个匹配规则就停止
- **默认路由**：没有匹配规则时使用默认主机组

### 3.3 匹配优先级策略


**🎖️ 优先级设计原则**

```sql
-- 优先级规划示例
-- 规则1: 最高优先级 - 特殊业务查询
INSERT INTO mysql_query_rules VALUES
(1, '.*urgent.*', 3, 1, 1);

-- 规则2: 写操作路由到主库  
INSERT INTO mysql_query_rules VALUES
(10, '^(INSERT|UPDATE|DELETE).*', 0, 1, 1);

-- 规则3: 普通读操作路由到从库
INSERT INTO mysql_query_rules VALUES
(20, '^SELECT.*', 1, 1, 1);

-- 规则4: 默认兜底规则
INSERT INTO mysql_query_rules VALUES
(999, '.*', 0, 1, 1);
```

**📋 优先级规划建议**

| 优先级范围 | **用途** | **示例** |
|-----------|---------|----------|
| `1-10` | `特殊业务规则` | `紧急查询、VIP用户` |
| `11-50` | `写操作规则` | `INSERT、UPDATE、DELETE` |
| `51-100` | `读操作规则` | `SELECT查询分类` |
| `101-200` | `表级别规则` | `特定表的路由` |
| `900-999` | `默认规则` | `兜底和通用规则` |

---

## 4. 🛠️ 路由规则配置实战


### 4.1 读写分离基础配置


**📝 基础读写分离规则**

```sql
-- 步骤1: 清空现有规则
DELETE FROM mysql_query_rules;

-- 步骤2: 添加写操作规则（高优先级）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(1, '^INSERT.*', 0, 1),
(2, '^UPDATE.*', 0, 1), 
(3, '^DELETE.*', 0, 1),
(4, '^REPLACE.*', 0, 1);

-- 步骤3: 添加读操作规则
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(10, '^SELECT.*', 1, 1);

-- 步骤4: 添加DDL操作规则
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(5, '^CREATE.*', 0, 1),
(6, '^ALTER.*', 0, 1),
(7, '^DROP.*', 0, 1);

-- 步骤5: 应用配置
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

**🔍 配置效果验证**

```sql
-- 查看规则列表
SELECT rule_id, match_pattern, destination_hostgroup, apply 
FROM mysql_query_rules 
ORDER BY rule_id;

-- 测试SQL路由（在ProxySQL管理端口执行）
SELECT * FROM stats_mysql_query_digest ORDER BY count_star DESC LIMIT 5;
```

### 4.2 高级路由场景配置


**🎯 场景1：按表分类路由**

```sql
-- 重要表查询路由到专用服务器
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(15, '.*FROM orders.*', 2, 1),          -- 订单表查询
(16, '.*FROM payments.*', 2, 1),        -- 支付表查询
(17, '.*FROM user_profiles.*', 3, 1);   -- 用户资料查询

-- 日志表查询路由到分析服务器
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(25, '.*FROM access_logs.*', 4, 1),
(26, '.*FROM error_logs.*', 4, 1);
```

**🎯 场景2：按查询复杂度路由**

```sql
-- 复杂分析查询路由到专用分析库
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(30, '.*GROUP BY.*HAVING.*', 5, 1),     -- 分组聚合查询
(31, '.*ORDER BY.*LIMIT.*[0-9]{4,}.*', 5, 1), -- 大量数据排序
(32, '.*JOIN.*JOIN.*', 5, 1);           -- 多表连接

-- 简单查询保持在从库
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(40, '^SELECT.*WHERE.*id.*=.*', 1, 1);  -- 主键查询
```

**🎯 场景3：用户级别路由**

```sql
-- 根据用户注释进行路由
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(8, '.*\/\*.*priority.*high.*\*\/.*', 0, 1),  -- 高优先级查询到主库
(9, '.*\/\*.*priority.*low.*\*\/.*', 6, 1);   -- 低优先级查询到备用库
```

<details>
<summary>💡 用户注释使用示例</summary>

```sql
-- 应用程序中使用注释标记
SELECT /*priority=high*/ * FROM orders WHERE status = 'pending';
SELECT /*priority=low*/ * FROM logs WHERE date < '2023-01-01';
```
</details>

### 4.3 条件组合路由


**🔗 复杂条件匹配**

```sql
-- 组合条件示例：特定时间的报表查询
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(50, '.*SELECT.*reports.*WHERE.*date.*BETWEEN.*', 7, 1);

-- 大数据量查询识别
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(51, '.*COUNT\(\*\).*FROM.*', 8, 1),        -- 计数查询
(52, '.*SUM\(.*\).*GROUP BY.*', 8, 1);      -- 聚合查询
```

**📊 规则测试和调试**

```sql
-- 查看匹配统计
SELECT 
  rule_id,
  match_digest,
  match_pattern,
  count_star as 匹配次数
FROM stats_mysql_query_rules 
WHERE count_star > 0
ORDER BY count_star DESC;

-- 查看未匹配的查询
SELECT 
  digest_text,
  count_star
FROM stats_mysql_query_digest 
WHERE hostgroup = -1  -- -1表示未匹配到规则
LIMIT 10;
```

---

## 5. ⚙️ 高级功能配置


### 5.1 查询重写功能


**🔄 什么是查询重写**
查询重写就像给SQL语句做"翻译"，把客户端发来的SQL改成更优化的版本，或者添加一些条件。

```sql
-- 基础重写规则配置
INSERT INTO mysql_query_rules(
  rule_id, 
  match_pattern, 
  replace_pattern,
  destination_hostgroup,
  apply
) VALUES (
  100,
  '^SELECT \* FROM users$',          -- 匹配：SELECT * FROM users
  'SELECT id,name,email FROM users',  -- 重写为：只查询需要的字段
  1,
  1
);
```

**🎯 实用重写场景**

```sql
-- 场景1: 自动添加LIMIT防止全表扫描
INSERT INTO mysql_query_rules VALUES
(101, '^SELECT.*FROM.*(?!.*LIMIT)', 'SELECT ? FROM ? LIMIT 1000', 1, 1);

-- 场景2: 强制添加索引提示
INSERT INTO mysql_query_rules VALUES  
(102, 'SELECT.*FROM orders WHERE', 'SELECT ? FROM orders USE INDEX(idx_date) WHERE ?', 1, 1);

-- 场景3: 查询条件优化
INSERT INTO mysql_query_rules VALUES
(103, 'SELECT.*FROM logs WHERE date.*', 'SELECT ? FROM logs_partitioned WHERE date ? AND status != "deleted"', 1, 1);
```

### 5.2 查询缓存控制


**💾 缓存机制配置**

```sql
-- 启用查询缓存
INSERT INTO mysql_query_rules(
  rule_id,
  match_pattern,
  cache_ttl,           -- 缓存时间（毫秒）
  destination_hostgroup,
  apply
) VALUES (
  200,
  '.*SELECT.*FROM config.*',  -- 配置表查询
  300000,                     -- 缓存5分钟
  1,
  1
);
```

**🕐 不同缓存策略**

| 查询类型 | **缓存时长** | **适用场景** |
|----------|-------------|-------------|
| `配置数据` | `5-30分钟` | `系统配置、字典表` |
| `统计数据` | `1-5分钟` | `实时统计、仪表板` |
| `历史数据` | `1-24小时` | `报表数据、历史记录` |
| `用户信息` | `30秒-5分钟` | `用户资料、权限信息` |

```sql
-- 分级缓存配置示例
INSERT INTO mysql_query_rules VALUES
(201, '.*FROM system_config.*', NULL, 1, 1, NULL, NULL, NULL, NULL, 1800000, NULL),  -- 30分钟
(202, '.*COUNT.*FROM orders.*', NULL, 1, 1, NULL, NULL, NULL, NULL, 60000, NULL),    -- 1分钟  
(203, '.*FROM user_sessions.*', NULL, 1, 1, NULL, NULL, NULL, NULL, 30000, NULL);    -- 30秒
```

### 5.3 查询超时和重试设置


**⏰ 超时控制配置**

```sql
-- 为不同类型查询设置超时
INSERT INTO mysql_query_rules(
  rule_id,
  match_pattern,
  timeout,              -- 超时时间（毫秒）
  destination_hostgroup,
  apply
) VALUES 
(300, '.*SELECT.*JOIN.*JOIN.*', 30000, 5, 1),      -- 复杂查询30秒超时
(301, '.*SELECT.*FROM.*WHERE.*id.*', 5000, 1, 1),  -- 主键查询5秒超时
(302, '.*INSERT.*VALUES.*', 10000, 0, 1);          -- 插入操作10秒超时
```

**🔄 重试机制配置**

```sql
-- 查询重试配置
INSERT INTO mysql_query_rules(
  rule_id,
  match_pattern,
  retries,              -- 重试次数
  destination_hostgroup,
  apply
) VALUES
(310, '.*SELECT.*', 2, 1, 1),          -- 读查询重试2次
(311, '.*INSERT.*', 1, 0, 1),          -- 插入操作重试1次
(312, '.*UPDATE.*DELETE.*', 0, 0, 1);  -- 写操作不重试
```

### 5.4 查询统计和监控


**📊 监控配置**

```sql
-- 启用查询统计
INSERT INTO mysql_query_rules(
  rule_id,
  match_pattern,
  log,                  -- 是否记录日志（0/1）
  destination_hostgroup,
  apply
) VALUES
(400, '.*SELECT.*FROM orders.*', 1, 1, 1),  -- 记录订单查询
(401, '.*UPDATE.*SET.*WHERE.*', 1, 0, 1),   -- 记录更新操作
(402, '.*SLOW_QUERY.*', 1, 5, 1);           -- 记录慢查询
```

**🔍 监控查询命令**

```sql
-- 查看规则匹配统计
SELECT 
  rule_id,
  hits,
  count_star,
  sum_time,
  min_time,
  max_time
FROM stats_mysql_query_rules 
WHERE hits > 0;

-- 查看查询延迟分布
SELECT 
  hostgroup,
  digest_text,
  count_star,
  sum_time/count_star as avg_time_ms
FROM stats_mysql_query_digest 
ORDER BY avg_time_ms DESC
LIMIT 10;
```

---

## 6. 🏆 最佳实践与优化


### 6.1 规则设计最佳实践


**📏 规则设计原则**

```
🎯 优先级原则：
1-10   → 紧急和特殊业务
11-50  → 写操作（数据一致性重要）
51-100 → 复杂读操作  
101-200 → 普通读操作
900+   → 默认兜底规则

🔍 匹配原则：
- 具体规则优于通用规则
- 表级规则优于全局规则
- 业务规则优于技术规则
```

**✅ 推荐配置模板**

```sql
-- 完整的生产环境配置模板
DELETE FROM mysql_query_rules;

-- 1. 特殊业务规则（最高优先级）
INSERT INTO mysql_query_rules VALUES
(1, '.*\/\*.*urgent.*\*\/.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'urgent queries'),
(5, '.*\/\*.*readonly.*\*\/.*', 1, 1, 1, NULL, NULL, NULL, NULL, NULL, 'force readonly');

-- 2. 写操作规则
INSERT INTO mysql_query_rules VALUES
(11, '^INSERT.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'insert operations'),
(12, '^UPDATE.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'update operations'),
(13, '^DELETE.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'delete operations'),
(14, '^REPLACE.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'replace operations');

-- 3. DDL操作
INSERT INTO mysql_query_rules VALUES
(15, '^CREATE.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'ddl create'),
(16, '^ALTER.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'ddl alter'),
(17, '^DROP.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'ddl drop');

-- 4. 复杂查询路由到分析服务器
INSERT INTO mysql_query_rules VALUES
(51, '.*GROUP BY.*ORDER BY.*', 2, 1, 1, NULL, NULL, NULL, NULL, NULL, 'complex analytics'),
(52, '.*JOIN.*JOIN.*', 2, 1, 1, NULL, NULL, NULL, NULL, NULL, 'multi-join queries'),
(53, '.*COUNT\(\*\).*', 2, 1, 1, NULL, NULL, NULL, NULL, NULL, 'count queries');

-- 5. 普通读操作到从库
INSERT INTO mysql_query_rules VALUES
(101, '^SELECT.*', 1, 1, 1, NULL, NULL, NULL, NULL, NULL, 'general select');

-- 6. 默认兜底规则
INSERT INTO mysql_query_rules VALUES
(999, '.*', 0, 1, 1, NULL, NULL, NULL, NULL, NULL, 'default fallback');

LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

### 6.2 性能优化策略


**⚡ 规则优化技巧**

```sql
-- 1. 避免过度复杂的正则表达式
-- ❌ 不推荐：复杂正则影响性能
match_pattern = '^SELECT.*FROM\s+(orders|payments|transactions).*WHERE.*status\s*=\s*["\']?(active|pending|processing)["\']?.*'

-- ✅ 推荐：简单精确的匹配
match_pattern = '^SELECT.*FROM orders.*'
match_pattern = '.*WHERE status.*active.*'
```

**📊 性能监控指标**

```sql
-- 监控规则执行效率
SELECT 
  rule_id,
  hits,
  count_star,
  sum_time/1000 as total_time_sec,
  (sum_time/count_star)/1000 as avg_time_sec
FROM stats_mysql_query_rules 
WHERE count_star > 0
ORDER BY sum_time DESC;

-- 识别未匹配的查询
SELECT 
  digest_text,
  count_star,
  sum_time/1000 as total_time_sec
FROM stats_mysql_query_digest 
WHERE hostgroup = -1
ORDER BY count_star DESC
LIMIT 10;
```

### 6.3 故障排查和调试


**🔧 常见问题诊断**

```sql
-- 1. 检查规则是否生效
SELECT 
  rule_id,
  match_pattern,
  destination_hostgroup,
  active,
  hits
FROM mysql_query_rules 
WHERE active = 1
ORDER BY rule_id;

-- 2. 查看实际路由情况
SELECT 
  hostgroup,
  schemaname,
  digest_text,
  count_star
FROM stats_mysql_query_digest
WHERE count_star > 0
ORDER BY count_star DESC
LIMIT 20;

-- 3. 检查连接分布
SELECT 
  hostgroup,
  srv_host,
  srv_port,
  status,
  ConnUsed,
  ConnFree,
  ConnOK,
  ConnERR
FROM stats_mysql_connection_pool;
```

**🚨 常见问题和解决方案**

| 问题现象 | **可能原因** | **解决方案** |
|---------|-------------|-------------|
| `所有查询都到主库` | `读规则优先级太低` | `调整rule_id，确保读规则在写规则后` |
| `某些查询不匹配` | `正则表达式不准确` | `使用.*测试，逐步精确化` |
| `性能下降` | `规则过多或过复杂` | `简化正则，减少规则数量` |
| `路由不生效` | `配置未加载到运行时` | `执行LOAD TO RUNTIME` |

**🔍 调试技巧**

```sql
-- 调试单个查询的路由
-- 1. 先添加测试规则
INSERT INTO mysql_query_rules VALUES
(1, '.*', 99, 1, 1, NULL, NULL, NULL, NULL, NULL, 'debug rule');

-- 2. 执行测试查询后检查
SELECT * FROM stats_mysql_query_digest WHERE hostgroup = 99;

-- 3. 删除测试规则
DELETE FROM mysql_query_rules WHERE rule_id = 1;
LOAD MYSQL QUERY RULES TO RUNTIME;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 查询路由本质：根据SQL内容智能分发到不同数据库服务器
🔸 mysql_query_rules表：ProxySQL路由规则的核心配置表
🔸 正则匹配机制：使用match_pattern字段匹配SQL语句
🔸 优先级执行：按rule_id从小到大顺序执行，首次匹配即停止
🔸 主机组概念：destination_hostgroup指定查询的目标服务器组
🔸 规则生效流程：配置→加载到运行时→保存到磁盘
```

### 7.2 关键理解要点


**🔹 路由规则设计思路**
```
优先级规划：
特殊业务 > 写操作 > 复杂查询 > 普通查询 > 默认规则

匹配原则：
具体匹配 > 模糊匹配 > 通用匹配
```

**🔹 性能优化要点**
```
规则设计：
- 避免过度复杂的正则表达式
- 合理设置规则优先级
- 定期清理无效规则

监控重点：
- 规则匹配次数和延迟
- 未匹配查询的识别
- 各主机组的负载分布
```

**🔹 常用配置模式**
```
基础读写分离：
写操作(INSERT/UPDATE/DELETE) → 主库(hostgroup 0)
读操作(SELECT) → 从库(hostgroup 1)

业务隔离：
重要查询 → 专用服务器
分析查询 → 分析专用库
缓存查询 → 内存缓存
```

### 7.3 实际应用价值


- **数据库性能优化**：通过读写分离和负载均衡显著提升性能
- **资源合理利用**：让不同类型查询在最适合的服务器上执行  
- **业务隔离保障**：重要业务和普通业务分开处理
- **运维管理简化**：应用程序无需修改即可实现复杂路由逻辑
- **扩展性增强**：新增服务器和调整路由策略都很灵活

### 7.4 学习建议和下一步


**📚 深入学习路径**
1. **实践基础配置**：搭建简单的读写分离环境
2. **掌握正则表达式**：熟练使用各种匹配模式
3. **监控和调优**：学会分析路由效果和性能指标
4. **高级功能探索**：查询重写、缓存、故障转移等

**🎯 核心记忆口诀**
- 路由规则按优先级，首次匹配就停止
- 写操作主库保一致，读操作从库提性能  
- 正则匹配要精准，监控统计常查看
- 配置完成记加载，保存磁盘防丢失

**⚠️ 注意事项**
- 规则修改后必须执行`LOAD TO RUNTIME`才能生效
- 生产环境修改前务必在测试环境验证
- 定期监控规则匹配情况和性能指标
- 备份重要的路由规则配置