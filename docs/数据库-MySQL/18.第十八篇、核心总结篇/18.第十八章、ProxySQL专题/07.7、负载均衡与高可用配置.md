---
title: 7、负载均衡与高可用配置
---
## 📚 目录

1. [ProxySQL负载均衡基础](#1-ProxySQL负载均衡基础)
2. [负载均衡算法详解](#2-负载均衡算法详解)
3. [权重分配与连接池配置](#3-权重分配与连接池配置)
4. [故障检测与自动转移](#4-故障检测与自动转移)
5. [读写分离与会话保持](#5-读写分离与会话保持)
6. [高可用架构设计](#6-高可用架构设计)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 ProxySQL负载均衡基础


### 1.1 什么是ProxySQL负载均衡


**💡 简单理解**：想象你去餐厅吃饭，有3个服务员可以为你服务。负载均衡就像餐厅经理，决定让哪个服务员来为你服务，确保每个服务员的工作量都差不多，没有人太忙或太闲。

**🔸 核心定义**
```
ProxySQL负载均衡：
• 作用：将客户端的数据库请求合理分配给多个MySQL服务器
• 目标：提高系统性能，避免单台服务器过载
• 方式：根据不同算法和策略自动选择最合适的服务器
```

**🏗️ 工作架构图**
```
客户端应用
    ↓
ProxySQL中间件 ← 负载均衡决策中心
    ↓
┌─────────┬─────────┬─────────┐
│MySQL-1  │MySQL-2  │MySQL-3  │
│ 主库    │ 从库1   │ 从库2   │
└─────────┴─────────┴─────────┘
```

### 1.2 为什么需要负载均衡


**📈 解决的核心问题**
```
单点过载：
• 问题：一台MySQL服务器承受所有请求
• 后果：响应变慢、服务器崩溃、业务中断

资源浪费：
• 问题：其他MySQL服务器空闲
• 后果：硬件投资浪费、系统整体性能差

可用性差：
• 问题：单台服务器故障影响整个系统
• 后果：业务中断、数据访问失败
```

**✅ 负载均衡的好处**
- **性能提升**：多台服务器并行处理，整体吞吐量增加
- **高可用性**：单台故障不影响整体服务
- **资源优化**：充分利用所有服务器资源
- **可扩展性**：可以随时增加新的服务器

---

## 2. ⚖️ 负载均衡算法详解


### 2.1 轮询算法（Round Robin）


**🔄 工作原理**：就像排队买票，每个人依次排队，轮到谁就是谁

```sql
-- ProxySQL配置轮询算法
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight) VALUES
(0, '192.168.1.10', 3306, 1000),  -- 权重相同
(0, '192.168.1.11', 3306, 1000),  -- 实现轮询
(0, '192.168.1.12', 3306, 1000);

-- 设置算法类型
UPDATE mysql_servers SET comment='round_robin' WHERE hostgroup_id=0;
```

**📊 请求分配示例**
```
请求序列：    目标服务器：
请求1   →    MySQL-1
请求2   →    MySQL-2  
请求3   →    MySQL-3
请求4   →    MySQL-1 (重新开始)
请求5   →    MySQL-2
```

**🎯 适用场景**
- ✅ **服务器性能相近**：所有MySQL服务器配置基本一致
- ✅ **请求复杂度相似**：每个请求的处理时间差不多
- ❌ **避免场景**：服务器性能差异很大的情况

### 2.2 加权轮询算法（Weighted Round Robin）


**⚖️ 工作原理**：根据服务器的处理能力分配不同的权重，能力强的服务器处理更多请求

```sql
-- 配置加权轮询
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight) VALUES
(0, '192.168.1.10', 3306, 3000),  -- 高性能服务器，权重3000
(0, '192.168.1.11', 3306, 2000),  -- 中等性能，权重2000
(0, '192.168.1.12', 3306, 1000);  -- 较低性能，权重1000

LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
```

**📈 权重分配示例**
```
总权重：3000 + 2000 + 1000 = 6000

实际分配比例：
MySQL-1: 3000/6000 = 50% 的请求
MySQL-2: 2000/6000 = 33% 的请求  
MySQL-3: 1000/6000 = 17% 的请求
```

**💡 权重设置建议**
```
根据服务器配置设置权重：
• CPU核心数比例：8核:4核:2核 = 4000:2000:1000
• 内存大小比例：32G:16G:8G = 4000:2000:1000
• 磁盘性能比例：SSD:SATA:机械 = 3000:2000:1000
```

### 2.3 最少连接算法（Least Connections）


**🔗 工作原理**：总是选择当前连接数最少的服务器，确保负载最均衡

```sql
-- 查看当前连接状态
SELECT hostgroup_id, srv_host, srv_port, status, 
       ConnUsed, ConnFree, ConnOK, ConnERR
FROM stats_mysql_connection_pool;

-- 配置最少连接算法
UPDATE global_variables SET variable_value='least_connections' 
WHERE variable_name='mysql-default_query_routing';
```

**📊 连接状态示例**
```
当前状态：
MySQL-1: 活跃连接 15个
MySQL-2: 活跃连接 8个   ← 选择这个
MySQL-3: 活跃连接 12个

新请求会被分配给MySQL-2（连接数最少）
```

**🎯 适用场景**
- ✅ **长连接应用**：连接保持时间较长的业务
- ✅ **请求处理时间差异大**：有些查询快，有些查询慢
- ✅ **追求最佳负载均衡**：希望服务器负载尽可能平均

---

## 3. 🔧 权重分配与连接池配置


### 3.1 权重分配策略


**📋 权重设置原则**

> 💡 **核心思想**
> 
> 权重不是拍脑袋决定的，要根据服务器的实际能力科学设置

**🔸 硬件性能评估**
```sql
-- 性能测试脚本示例
-- 1. CPU性能权重
SELECT 
    CASE 
        WHEN cpu_cores >= 16 THEN 4000
        WHEN cpu_cores >= 8 THEN 3000  
        WHEN cpu_cores >= 4 THEN 2000
        ELSE 1000 
    END AS cpu_weight;

-- 2. 内存容量权重  
SELECT 
    CASE 
        WHEN memory_gb >= 64 THEN 4000
        WHEN memory_gb >= 32 THEN 3000
        WHEN memory_gb >= 16 THEN 2000  
        ELSE 1000
    END AS memory_weight;
```

**📊 权重配置实例**
```sql
-- 实际生产环境配置
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight, comment) VALUES
-- 主库组 (写操作)
(0, 'mysql-master.example.com', 3306, 5000, 'Master-高性能-32C64G'),

-- 从库组 (读操作) 
(1, 'mysql-slave1.example.com', 3306, 4000, 'Slave1-高性能-16C32G'),
(1, 'mysql-slave2.example.com', 3306, 3000, 'Slave2-中等-8C16G'),
(1, 'mysql-slave3.example.com', 3306, 2000, 'Slave3-较低-4C8G');
```

### 3.2 连接池核心配置


**🏊 连接池就像游泳池**：提前准备好一定数量的连接，需要时直接使用，用完放回池子，避免频繁建立和关闭连接的开销。

**🔸 关键参数详解**
```sql
-- 连接池大小配置
UPDATE global_variables SET variable_value='200' 
WHERE variable_name='mysql-default_max_connections';  -- 每个服务器最大连接数

UPDATE global_variables SET variable_value='50' 
WHERE variable_name='mysql-default_max_replication_lag';  -- 主从延迟阈值(秒)

UPDATE global_variables SET variable_value='10000' 
WHERE variable_name='mysql-connect_timeout_server';  -- 连接超时时间(毫秒)

UPDATE global_variables SET variable_value='8000' 
WHERE variable_name='mysql-ping_timeout_server';  -- 心跳超时时间(毫秒)
```

**📈 连接池优化策略**
```sql
-- 根据业务特点调整连接池
-- 1. 高并发场景
UPDATE global_variables SET variable_value='500' 
WHERE variable_name='mysql-default_max_connections';

-- 2. 长连接应用  
UPDATE global_variables SET variable_value='28800' 
WHERE variable_name='mysql-wait_timeout';  -- 8小时超时

-- 3. 短连接应用
UPDATE global_variables SET variable_value='60' 
WHERE variable_name='mysql-wait_timeout';  -- 1分钟超时
```

### 3.3 连接复用优化


**🔄 连接复用的含义**：多个客户端请求共享同一个到MySQL的连接，避免频繁建立新连接

```sql
-- 连接复用配置
UPDATE global_variables SET variable_value='true' 
WHERE variable_name='mysql-connection_warming';  -- 连接预热

UPDATE global_variables SET variable_value='10' 
WHERE variable_name='mysql-free_connections_pct';  -- 空闲连接保持百分比

-- 查看连接复用效果
SELECT hostgroup_id, srv_host, srv_port,
       ConnUsed,   -- 正在使用的连接
       ConnFree,   -- 空闲可用的连接  
       ConnOK,     -- 总的成功连接
       Queries     -- 处理的查询数
FROM stats_mysql_connection_pool
ORDER BY hostgroup_id, srv_host;
```

---

## 4. 🔍 故障检测与自动转移


### 4.1 健康检查机制


**❤️ 健康检查就像体检**：定期检查MySQL服务器是否正常工作，发现问题及时处理

**🔸 检查类型**
```sql
-- 1. 基础连通性检查 (ping检查)
UPDATE global_variables SET variable_value='10000' 
WHERE variable_name='mysql-ping_interval_server_msec';  -- 10秒检查一次

-- 2. 深度健康检查 (自定义SQL)
UPDATE global_variables SET variable_value='SELECT 1' 
WHERE variable_name='mysql-ping_timeout_server';

-- 3. 主从延迟检查
UPDATE mysql_servers SET max_replication_lag=30 
WHERE hostgroup_id=1;  -- 从库延迟超过30秒就排除
```

**📊 健康状态监控**
```sql
-- 查看服务器健康状态
SELECT hostgroup_id, hostname, port, status, weight,
       CASE status
           WHEN 'ONLINE' THEN '✅ 健康'
           WHEN 'OFFLINE_SOFT' THEN '⚠️ 软下线'  
           WHEN 'OFFLINE_HARD' THEN '❌ 硬下线'
           WHEN 'SHUNNED' THEN '🚫 临时排除'
       END AS status_desc
FROM mysql_servers
ORDER BY hostgroup_id, hostname;
```

### 4.2 故障检测配置


**🚨 故障检测参数详解**

> ⚠️ **重要提醒**
> 
> 故障检测要平衡敏感度和稳定性：太敏感会误判，太迟钝会影响可用性

```sql
-- 故障检测核心配置
UPDATE global_variables SET variable_value='3' 
WHERE variable_name='mysql-max_connections_failures';  -- 连续3次失败就标记故障

UPDATE global_variables SET variable_value='5' 
WHERE variable_name='mysql-query_timeout';  -- 查询超时5秒

UPDATE global_variables SET variable_value='600' 
WHERE variable_name='mysql-shun_on_failures';  -- 故障后排除10分钟

UPDATE global_variables SET variable_value='10' 
WHERE variable_name='mysql-shun_recovery_time_sec';  -- 10秒后尝试恢复
```

**🔄 故障恢复流程**
```
故障检测流程：
正常状态 → 连接失败 → 重试检查 → 多次失败 → 标记SHUNNED → 定期重试 → 恢复正常

状态转换：
ONLINE ──[故障]──→ SHUNNED ──[恢复]──→ ONLINE
   ↓                    ↑
   └──[手动下线]──→ OFFLINE_SOFT
```

### 4.3 自动故障转移


**🔄 自动转移的工作原理**：当主库故障时，自动将写操作转移到备用主库，保证业务连续性

```sql
-- 故障转移配置示例
-- 1. 主库组配置（支持故障转移）
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight, status, comment) VALUES
(0, 'mysql-master1.example.com', 3306, 5000, 'ONLINE', 'Primary Master'),
(0, 'mysql-master2.example.com', 3306, 4000, 'OFFLINE_SOFT', 'Backup Master');

-- 2. 故障转移脚本触发
UPDATE mysql_servers SET status='OFFLINE_HARD' 
WHERE hostname='mysql-master1.example.com' AND hostgroup_id=0;

UPDATE mysql_servers SET status='ONLINE' 
WHERE hostname='mysql-master2.example.com' AND hostgroup_id=0;

LOAD MYSQL SERVERS TO RUNTIME;
```

**⚡ 快速故障转移脚本**
```bash
#!/bin/bash
# 故障检测和自动转移脚本

MASTER1="mysql-master1.example.com"
MASTER2="mysql-master2.example.com"
PROXYSQL_ADMIN="mysql -h127.0.0.1 -P6032 -uadmin -padmin"

# 检查主库1状态
if ! mysqladmin ping -h$MASTER1 -uroot -p'password' --silent; then
    echo "主库1故障，开始自动转移..."
    
    # 下线故障主库
    $PROXYSQL_ADMIN -e "UPDATE mysql_servers SET status='OFFLINE_HARD' 
                        WHERE hostname='$MASTER1' AND hostgroup_id=0;"
    
    # 激活备用主库  
    $PROXYSQL_ADMIN -e "UPDATE mysql_servers SET status='ONLINE' 
                        WHERE hostname='$MASTER2' AND hostgroup_id=0;"
    
    # 应用配置
    $PROXYSQL_ADMIN -e "LOAD MYSQL SERVERS TO RUNTIME;"
    
    echo "故障转移完成！"
fi
```

---

## 5. 📖 读写分离与会话保持


### 5.1 读写分离实现原理


**📚 读写分离就像图书馆**：写书（写操作）只能在特定区域进行，但看书（读操作）可以在多个阅览室同时进行

**🔸 基本概念**
```
读写分离的核心：
• 写操作(INSERT/UPDATE/DELETE) → 主库(Master)
• 读操作(SELECT) → 从库(Slave)  
• 目标：减轻主库压力，提高整体性能
```

**🏗️ 读写分离架构**
```
客户端应用
    ↓
ProxySQL (路由决策)
    ↓
┌──写操作──→ 主库(Master)
│              ↓ 数据同步
└──读操作──→ 从库1、从库2、从库3
```

### 5.2 读写分离配置


**📋 主从服务器组配置**
```sql
-- 1. 定义主库组（写操作）
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight, comment) VALUES
(0, 'mysql-master.example.com', 3306, 5000, '主库-写操作');

-- 2. 定义从库组（读操作）  
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight, comment) VALUES
(1, 'mysql-slave1.example.com', 3306, 4000, '从库1-读操作'),
(1, 'mysql-slave2.example.com', 3306, 3000, '从库2-读操作'),
(1, 'mysql-slave3.example.com', 3306, 2000, '从库3-读操作');

-- 3. 设置复制延迟检查
UPDATE mysql_servers SET max_replication_lag=10 WHERE hostgroup_id=1;
```

**🔀 查询路由规则配置**
```sql
-- 配置读写分离规则
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup, apply, comment) VALUES
-- 写操作路由到主库
(1, 1, '^INSERT.*', 0, 1, '插入操作→主库'),
(2, 1, '^UPDATE.*', 0, 1, '更新操作→主库'), 
(3, 1, '^DELETE.*', 0, 1, '删除操作→主库'),
(4, 1, '^REPLACE.*', 0, 1, '替换操作→主库'),

-- 读操作路由到从库
(10, 1, '^SELECT.*', 1, 1, '查询操作→从库');

-- 应用规则
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

### 5.3 会话保持机制


**🔗 会话保持的重要性**：确保同一个客户端连接的相关操作能够保持一致性

> 💡 **为什么需要会话保持？**
> 
> 想象你在银行转账：先查余额（读操作），再转账（写操作）。如果查余额时连接的是从库，转账时连接主库，但主从有延迟，可能看到的余额是旧数据，导致业务逻辑错误。

**🔸 会话保持配置**
```sql
-- 1. 事务内保持会话
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup, apply, comment) VALUES
(20, 1, '^BEGIN', 0, 1, '事务开始→主库'),
(21, 1, '^START TRANSACTION', 0, 1, '事务开始→主库'),
(22, 1, '^COMMIT', 0, 1, '事务提交→主库'),
(23, 1, '^ROLLBACK', 0, 1, '事务回滚→主库');

-- 2. 临时表操作保持会话
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup, apply, comment) VALUES
(30, 1, '.*CREATE TEMPORARY.*', 0, 1, '临时表→主库'),
(31, 1, '.*tmp.*', 0, 1, '临时表操作→主库');
```

**⚖️ 会话保持策略选择**
```sql
-- 策略1：严格会话保持（所有操作都在主库）
UPDATE mysql_users SET default_hostgroup=0 
WHERE username='strict_user';

-- 策略2：智能会话保持（读写分离+特殊情况会话保持）  
UPDATE mysql_users SET default_hostgroup=1 
WHERE username='normal_user';

-- 策略3：完全读写分离（性能优先）
UPDATE mysql_users SET default_hostgroup=1, 
       max_connections=100 
WHERE username='readonly_user';
```

---

## 6. 🏗️ 高可用架构设计


### 6.1 高可用架构模式


**🏢 企业级高可用架构**：就像建大楼，要有多重保险，确保任何一个部分出问题都不会影响整体

**🔸 经典高可用架构**
```
负载均衡器 (LVS/HAProxy)
    ↓
┌─────────────┬─────────────┐
│  ProxySQL-1 │  ProxySQL-2 │ ← 中间件高可用
│   (主)      │   (备)      │
└─────────────┴─────────────┘
    ↓
┌──────────────────────────────┐
│      MySQL集群               │
│  ┌─────────┬─────────────┐   │
│  │ Master  │   Master    │   │ ← 主库高可用
│  │ (主)    │   (备)      │   │
│  └─────────┴─────────────┘   │
│      ↓           ↓           │
│  ┌─────────┬─────────────┐   │
│  │ Slave-1 │   Slave-2   │   │ ← 从库高可用  
│  └─────────┴─────────────┘   │
└──────────────────────────────┘
```

### 6.2 ProxySQL集群配置


**🔄 ProxySQL集群同步**：多个ProxySQL实例之间保持配置同步，实现中间件层的高可用

```sql
-- ProxySQL集群配置
-- 1. 节点1配置
INSERT INTO proxysql_servers (hostname, port, weight, comment) VALUES
('proxysql-1.example.com', 6032, 1000, 'ProxySQL节点1'),
('proxysql-2.example.com', 6032, 1000, 'ProxySQL节点2'),
('proxysql-3.example.com', 6032, 1000, 'ProxySQL节点3');

-- 2. 启用集群同步
UPDATE global_variables SET variable_value='true' 
WHERE variable_name='admin-cluster_sync_enabled';

UPDATE global_variables SET variable_value='proxysql-cluster' 
WHERE variable_name='admin-cluster_username';

UPDATE global_variables SET variable_value='cluster_password' 
WHERE variable_name='admin-cluster_password';

-- 3. 应用集群配置
LOAD PROXYSQL SERVERS TO RUNTIME;
SAVE PROXYSQL SERVERS TO DISK;
```

### 6.3 服务器降级策略


**📉 降级策略的含义**：当服务器出现问题但还能提供部分服务时，降低其权重或限制其处理的请求类型

**🔸 智能降级配置**
```sql
-- 1. 性能降级（降低权重）
UPDATE mysql_servers SET weight=500 
WHERE hostname='mysql-slave2.example.com' 
  AND comment LIKE '%性能下降%';

-- 2. 功能降级（只处理简单查询）
INSERT INTO mysql_query_rules (rule_id, active, match_pattern, destination_hostgroup, apply, comment) VALUES
(100, 1, '^SELECT.*WHERE.*LIMIT.*', 2, 1, '简单查询→降级服务器'),
(101, 1, '^SELECT COUNT.*', 2, 1, '计数查询→降级服务器');

-- 3. 临时排除（完全移除）
UPDATE mysql_servers SET status='OFFLINE_SOFT' 
WHERE hostname='mysql-slave3.example.com' 
  AND comment LIKE '%临时维护%';
```

**📊 降级策略监控**
```sql
-- 监控降级状态
SELECT 
    hostname,
    port,
    status,
    weight,
    CASE 
        WHEN weight < 1000 THEN '⚠️ 性能降级'
        WHEN status = 'OFFLINE_SOFT' THEN '📉 功能降级'  
        WHEN status = 'OFFLINE_HARD' THEN '❌ 完全下线'
        ELSE '✅ 正常服务'
    END AS service_level
FROM mysql_servers
ORDER BY hostgroup_id, weight DESC;
```

### 6.4 监控与告警系统


**📊 完整的监控体系**
```sql
-- 1. 连接池状态监控
SELECT 
    hostgroup_id,
    srv_host,
    srv_port,
    status,
    ConnUsed,
    ConnFree,
    ConnOK,
    ConnERR,
    ROUND(ConnUsed*100.0/(ConnUsed+ConnFree), 2) AS usage_pct
FROM stats_mysql_connection_pool
WHERE status = 'ONLINE';

-- 2. 查询性能监控  
SELECT 
    hostgroup,
    schemaname,
    username,
    digest_text,
    count_star,
    sum_time,
    ROUND(sum_time/count_star/1000, 2) AS avg_time_ms
FROM stats_mysql_query_digest 
WHERE count_star > 100
ORDER BY sum_time DESC LIMIT 10;

-- 3. 错误监控
SELECT 
    hostgroup,
    srv_host,
    srv_port,
    Queries,
    ConnERR,
    ROUND(ConnERR*100.0/Queries, 2) AS error_rate_pct
FROM stats_mysql_connection_pool
WHERE ConnERR > 0
ORDER BY error_rate_pct DESC;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 负载均衡算法：轮询、加权轮询、最少连接的原理和适用场景
🔸 权重配置：根据服务器性能科学设置权重值
🔸 连接池管理：合理配置连接数、超时时间、复用策略
🔸 故障检测：健康检查、自动故障转移、恢复机制
🔸 读写分离：查询路由规则、会话保持、一致性保证
🔸 高可用设计：多层高可用、集群同步、降级策略
```

### 7.2 关键理解要点


**🔹 负载均衡不是万能的**
```
需要考虑的因素：
• 服务器硬件差异：权重要反映真实性能差距
• 请求复杂度：简单查询和复杂分析的处理时间差异很大
• 网络延迟：就近分配比跨地域分配效果更好
• 数据一致性：读写分离要平衡性能和一致性
```

**🔹 故障处理要快速而谨慎**
```
平衡原则：
• 检测要快：及时发现问题，避免影响用户体验
• 判断要准：避免误判导致不必要的故障转移
• 恢复要稳：故障恢复后要平滑过渡，不能造成新问题
• 通知要及时：相关人员要第一时间知道故障情况
```

**🔹 高可用是系统工程**
```
不只是配置：
• 架构设计：从一开始就要考虑高可用
• 监控体系：全方位的状态监控和性能监控
• 应急预案：明确的故障处理流程和责任分工
• 定期演练：定期测试故障转移和恢复流程
```

### 7.3 实际应用价值


**🎯 生产环境最佳实践**
- **负载均衡**：根据业务特点选择合适算法，定期调整权重
- **故障处理**：建立完善的监控告警，制定应急处理预案
- **读写分离**：在性能和一致性之间找到最佳平衡点
- **高可用设计**：多层保险，单点故障不影响整体服务

**核心记忆口诀**：
- 负载均衡选算法，权重配置看性能
- 故障检测要及时，自动转移保可用  
- 读写分离提性能，会话保持保一致
- 高可用靠架构，监控告警不可少