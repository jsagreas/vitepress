---
title: 23、MHA与Keepalived集成
---
## 📚 目录

1. [MHA与Keepalived集成概述](#1-MHA与Keepalived集成概述)
2. [Keepalived基础与VRRP协议](#2-Keepalived基础与VRRP协议)
3. [VIP高可用架构设计](#3-VIP高可用架构设计)
4. [Keepalived详细配置](#4-Keepalived详细配置)
5. [健康检查脚本设计](#5-健康检查脚本设计)
6. [故障切换协调机制](#6-故障切换协调机制)
7. [脑裂问题处理](#7-脑裂问题处理)
8. [监控告警体系](#8-监控告警体系)
9. [故障排查指南](#9-故障排查指南)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔗 MHA与Keepalived集成概述


### 1.1 为什么需要集成Keepalived


**简单理解**：MHA负责数据库故障切换，Keepalived负责IP地址故障切换

```
没有Keepalived的问题：
应用程序 → 192.168.1.100 (Master数据库)
Master宕机后：
应用程序 → 192.168.1.100 (已经无法连接)
新Master：192.168.1.101 (应用程序不知道新地址)

结果：需要手动修改应用配置，影响业务

有了Keepalived：
应用程序 → 192.168.1.200 (VIP虚拟IP)
Master宕机后：
VIP自动漂移到新Master → 192.168.1.101
应用程序仍然连接 → 192.168.1.200 (无需修改配置)

结果：业务无感知故障切换
```

### 1.2 集成架构原理


**🏗️ 整体架构**
```
              应用程序
                 |
         192.168.1.200 (VIP)
                 |
    ┌────────────┼────────────┐
    |            |            |
 Master       Slave1       Slave2
   +MHA         +MHA         +MHA
+Keepalived  +Keepalived  +Keepalived
192.168.1.100 192.168.1.101 192.168.1.102
```

**核心组件协作**：
- **MHA**：监控数据库状态，执行故障切换
- **Keepalived**：管理VIP，处理网络层故障切换
- **VRRP协议**：确保同一时间只有一个节点持有VIP

### 1.3 集成优势


**🎯 核心价值**
```
业务连续性：
• 应用程序无需修改连接配置
• 故障切换对业务透明
• 减少故障恢复时间

运维便利性：
• 统一的访问入口
• 自动化故障处理
• 简化网络配置管理

可靠性提升：
• 双重保障机制
• 网络层+应用层故障检测
• 防止单点故障
```

---

## 2. 🌐 Keepalived基础与VRRP协议


### 2.1 什么是Keepalived


**通俗解释**：Keepalived就像一个"IP地址保镖"

```
生活类比：
你有一个重要的电话号码(VIP)，这个号码需要24小时有人接听
你安排了3个人轮班接听(3台服务器)
当正在值班的人出问题时，其他人立即接管电话
外面打电话的人永远能打通，不知道换了人

技术对应：
VIP = 虚拟IP地址
轮班的人 = 不同的服务器
接听电话 = 处理网络请求
换人接管 = VIP自动切换
```

### 2.2 VRRP协议详解


**🔸 VRRP核心概念**
```
VRRP = Virtual Router Redundancy Protocol (虚拟路由冗余协议)

基本角色：
┌─────────────┬──────────────┬────────────────┐
│    角色     │   英文名称   │     主要职责   │
├─────────────┼──────────────┼────────────────┤
│   主节点    │    Master    │ 持有VIP，处理请求│
│   备节点    │    Backup    │ 待机，监控Master │
│   故障节点  │    Fault     │ 已故障，不参与选举│
└─────────────┴──────────────┴────────────────┘
```

**🔄 VRRP工作流程**
```
正常状态：
Master  ──[心跳包]──> Backup1, Backup2
(每秒发送VRRP通告包)

故障发生：
Master  ──✗ 停止发送心跳
         
选举过程：
Backup1 (优先级100) vs Backup2 (优先级90)
→ Backup1获胜，升级为Master
→ VIP从旧Master漂移到新Master

通知机制：
新Master发送免费ARP，通知网络设备更新MAC表
```

### 2.3 优先级与抢占机制


**🏆 优先级规则**
```
优先级范围：1-254 (数字越大优先级越高)
特殊值：255 (VIP拥有者，即当前Master)

选举规则：
1. 优先级最高的成为Master
2. 优先级相同时，IP地址大的获胜
3. Master故障时，最高优先级的Backup接管

抢占模式：
启用抢占：高优先级节点恢复后会抢回Master角色
禁用抢占：避免频繁切换，保持稳定性
```

---

## 3. 🎯 VIP高可用架构设计


### 3.1 网络规划


**📋 IP地址规划**
```
服务器规划：
┌──────────────┬─────────────────┬──────────────┬─────────────┐
│   服务器名   │    物理IP      │   角色      │  优先级    │
├──────────────┼─────────────────┼──────────────┼─────────────┤
│   db-master  │ 192.168.1.100  │   Master    │    120     │
│   db-slave1  │ 192.168.1.101  │   Slave     │    110     │
│   db-slave2  │ 192.168.1.102  │   Slave     │    100     │
│              │ 192.168.1.200  │    VIP      │     -      │
└──────────────┴─────────────────┴──────────────┴─────────────┘

网络要求：
• 所有节点在同一网段
• VIP在同一网段内可用
• 防火墙允许VRRP协议（IP协议号112）
```

### 3.2 架构拓扑


**🌐 网络拓扑图**
```
                    Internet
                        |
                   [Load Balancer]
                        |
                192.168.1.200 (VIP)
                        |
    ┌───────────────────┼───────────────────┐
    |                   |                   |
[db-master]        [db-slave1]        [db-slave2]
192.168.1.100      192.168.1.101      192.168.1.102
    |                   |                   |
 [MHA Node]         [MHA Node]         [MHA Node]
 [Keepalived]       [Keepalived]       [Keepalived]
   优先级:120         优先级:110         优先级:100

数据同步：
Master ──[binlog]──> Slave1 ──[relay log]──> Slave2
```

### 3.3 切换场景设计


**⚡ 故障切换流程**
```
场景1：Master数据库故障
┌─────────────────────────────────────────┐
│ 1. MHA检测到Master数据库不可用          │
│ 2. MHA执行数据库层面的故障切换          │
│ 3. Keepalived健康检查失败               │
│ 4. VIP自动切换到新的Master              │
│ 5. 应用程序继续正常访问VIP              │
└─────────────────────────────────────────┘

场景2：Master服务器故障
┌─────────────────────────────────────────┐
│ 1. Keepalived心跳中断                   │
│ 2. Backup节点检测到Master离线           │
│ 3. 最高优先级的Backup接管VIP            │
│ 4. 同时触发MHA故障切换流程              │
└─────────────────────────────────────────┘

场景3：网络故障
┌─────────────────────────────────────────┐
│ 1. 网络分区导致部分节点失联             │
│ 2. 脑裂检测机制启动                     │
│ 3. 通过多种检测方式确认真实状态         │
│ 4. 执行相应的切换或恢复操作             │
└─────────────────────────────────────────┘
```

---

## 4. ⚙️ Keepalived详细配置


### 4.1 Master节点配置


**📝 /etc/keepalived/keepalived.conf (Master)**
```bash
global_defs {
    # 全局配置
    router_id MYSQL_HA_MASTER    # 路由器标识，集群内唯一
    script_user root             # 脚本执行用户
    enable_script_security       # 启用脚本安全检查
}

# 健康检查脚本定义
vrrp_script check_mysql {
    script "/etc/keepalived/scripts/check_mysql.sh"
    interval 3      # 检查间隔3秒
    weight -20      # 检查失败时降低优先级20
    fall 3          # 连续失败3次才认为故障
    rise 2          # 连续成功2次才认为恢复
    timeout 5       # 脚本执行超时时间5秒
}

# VRRP实例配置
vrrp_instance VI_1 {
    state MASTER                    # 初始状态为MASTER
    interface eth0                  # 监听的网络接口
    virtual_router_id 51           # 虚拟路由ID（0-255）
    priority 120                   # 优先级，Master最高
    advert_int 1                   # 心跳间隔1秒
    
    # 认证配置（防止非法节点加入）
    authentication {
        auth_type PASS             # 认证类型
        auth_pass mysql_ha_2024    # 认证密码，集群内统一
    }
    
    # 虚拟IP配置
    virtual_ipaddress {
        192.168.1.200/24 dev eth0  # VIP地址和掩码
    }
    
    # 引用健康检查脚本
    track_script {
        check_mysql
    }
    
    # 状态变化时执行的脚本
    notify_master "/etc/keepalived/scripts/notify_master.sh"
    notify_backup "/etc/keepalived/scripts/notify_backup.sh"
    notify_fault  "/etc/keepalived/scripts/notify_fault.sh"
    notify_stop   "/etc/keepalived/scripts/notify_stop.sh"
}
```

### 4.2 Backup节点配置


**📝 /etc/keepalived/keepalived.conf (Backup)**
```bash
global_defs {
    router_id MYSQL_HA_BACKUP1   # 每个节点的ID要不同
    script_user root
    enable_script_security
}

vrrp_script check_mysql {
    script "/etc/keepalived/scripts/check_mysql.sh"
    interval 3
    weight -20
    fall 3
    rise 2
    timeout 5
}

vrrp_instance VI_1 {
    state BACKUP                   # 初始状态为BACKUP
    interface eth0
    virtual_router_id 51          # 必须与Master相同
    priority 110                  # 优先级低于Master
    advert_int 1
    
    # 抢占模式配置
    nopreempt                     # 禁止抢占，避免频繁切换
    
    authentication {
        auth_type PASS
        auth_pass mysql_ha_2024   # 必须与Master相同
    }
    
    virtual_ipaddress {
        192.168.1.200/24 dev eth0
    }
    
    track_script {
        check_mysql
    }
    
    notify_master "/etc/keepalived/scripts/notify_master.sh"
    notify_backup "/etc/keepalived/scripts/notify_backup.sh"
    notify_fault  "/etc/keepalived/scripts/notify_fault.sh"
    notify_stop   "/etc/keepalived/scripts/notify_stop.sh"
}
```

### 4.3 关键参数详解


**🔧 重要参数说明**
```
virtual_router_id：
• 取值范围：0-255
• 同一VRRP组内必须相同
• 不同VRRP组必须不同
• 建议按业务分配：DB=51, Web=52, Cache=53

priority优先级：
• Master：120 (最高)
• Backup1：110 (次高)  
• Backup2：100 (最低)
• 预留10的差值，便于调整

advert_int心跳间隔：
• 默认1秒，可根据网络情况调整
• 网络较差时可设为2-3秒
• 设置过大会影响故障检测速度

preempt抢占模式：
• 启用：高优先级节点恢复后自动抢回Master
• 禁用(nopreempt)：避免频繁切换，推荐生产环境使用
```

---

## 5. 🔍 健康检查脚本设计


### 5.1 MySQL健康检查脚本


**📄 /etc/keepalived/scripts/check_mysql.sh**
```bash
#!/bin/bash

# MySQL健康检查脚本
# 功能：检查MySQL服务状态、连接性、主从复制状态

# 配置参数
MYSQL_HOST="127.0.0.1"
MYSQL_PORT="3306"
MYSQL_USER="keepalived_check"
MYSQL_PASSWORD="your_password"
MYSQL_SOCKET="/tmp/mysql.sock"

# 日志文件
LOG_FILE="/var/log/keepalived/mysql_check.log"

# 记录日志函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') $1" >> $LOG_FILE
}

# 检查MySQL进程是否存在
check_mysql_process() {
    if ! pgrep -f mysqld > /dev/null; then
        log_message "ERROR: MySQL进程不存在"
        return 1
    fi
    return 0
}

# 检查MySQL端口是否监听
check_mysql_port() {
    if ! netstat -tlnp | grep -q ":$MYSQL_PORT "; then
        log_message "ERROR: MySQL端口$MYSQL_PORT 未监听"
        return 1
    fi
    return 0
}

# 检查MySQL连接性
check_mysql_connection() {
    # 使用mysqladmin ping检查连接
    if ! mysqladmin -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASSWORD ping > /dev/null 2>&1; then
        log_message "ERROR: 无法连接到MySQL服务器"
        return 1
    fi
    return 0
}

# 检查MySQL只读状态
check_mysql_readonly() {
    # 检查是否为只读模式（slave不应该接收写入）
    readonly_status=$(mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASSWORD -e "SELECT $$read_only;" 2>/dev/null | tail -n 1)
    
    if [ "$readonly_status" = "1" ]; then
        log_message "WARNING: MySQL处于只读模式"
        # 注意：对于Slave节点，只读模式是正常的
        # 这里需要根据实际情况判断是否为异常
    fi
    return 0
}

# 检查主从复制状态（仅在Slave节点执行）
check_slave_status() {
    # 判断当前节点是否为Slave
    slave_status=$(mysql -h$MYSQL_HOST -P$MYSQL_PORT -u$MYSQL_USER -p$MYSQL_PASSWORD -e "SHOW SLAVE STATUS\G" 2>/dev/null)
    
    if [ ! -z "$slave_status" ]; then
        # 检查复制线程状态
        io_running=$(echo "$slave_status" | grep "Slave_IO_Running:" | awk '{print $2}')
        sql_running=$(echo "$slave_status" | grep "Slave_SQL_Running:" | awk '{print $2}')
        
        if [ "$io_running" != "Yes" ] || [ "$sql_running" != "Yes" ]; then
            log_message "ERROR: MySQL主从复制异常 IO:$io_running SQL:$sql_running"
            return 1
        fi
        
        # 检查复制延迟
        seconds_behind=$(echo "$slave_status" | grep "Seconds_Behind_Master:" | awk '{print $2}')
        if [ "$seconds_behind" != "0" ] && [ "$seconds_behind" != "NULL" ]; then
            if [ "$seconds_behind" -gt 60 ]; then
                log_message "WARNING: MySQL复制延迟${seconds_behind}秒"
            fi
        fi
    fi
    return 0
}

# 主检查函数
main() {
    log_message "开始MySQL健康检查"
    
    # 逐步检查各项指标
    if ! check_mysql_process; then
        exit 1
    fi
    
    if ! check_mysql_port; then
        exit 1
    fi
    
    if ! check_mysql_connection; then
        exit 1
    fi
    
    check_mysql_readonly
    check_slave_status
    
    log_message "MySQL健康检查通过"
    exit 0
}

# 创建日志目录
mkdir -p $(dirname $LOG_FILE)

# 执行主函数
main
```

### 5.2 通知脚本设计


**📄 状态变化通知脚本示例**
```bash
# /etc/keepalived/scripts/notify_master.sh
#!/bin/bash
# 当节点成为Master时执行

LOG_FILE="/var/log/keepalived/notify.log"
echo "$(date '+%Y-%m-%d %H:%M:%S') 节点成为MASTER，VIP已绑定" >> $LOG_FILE

# 可以在这里执行其他操作：
# 1. 发送告警通知
# 2. 更新配置文件
# 3. 启动相关服务
# 4. 记录状态到监控系统

# 示例：发送邮件通知
echo "MySQL Master切换通知：$(hostname) 已成为新的Master节点" | mail -s "MySQL HA状态变更" admin@company.com

# /etc/keepalived/scripts/notify_backup.sh
#!/bin/bash
# 当节点成为Backup时执行

LOG_FILE="/var/log/keepalived/notify.log"
echo "$(date '+%Y-%m-%d %H:%M:%S') 节点成为BACKUP，VIP已释放" >> $LOG_FILE

# /etc/keepalived/scripts/notify_fault.sh
#!/bin/bash
# 当节点故障时执行

LOG_FILE="/var/log/keepalived/notify.log"
echo "$(date '+%Y-%m-%d %H:%M:%S') 节点进入FAULT状态" >> $LOG_FILE

# 发送紧急告警
echo "紧急告警：MySQL节点$(hostname)进入故障状态" | mail -s "MySQL HA故障告警" admin@company.com
```

### 5.3 高级健康检查


**🔬 深度健康检查逻辑**
```bash
# 高级检查项目
check_mysql_performance() {
    # 检查MySQL性能指标
    # 1. 连接数是否过多
    connections=$(mysql -e "SHOW STATUS LIKE 'Threads_connected';" | tail -n 1 | awk '{print $2}')
    max_connections=$(mysql -e "SHOW VARIABLES LIKE 'max_connections';" | tail -n 1 | awk '{print $2}')
    
    usage_percent=$((connections * 100 / max_connections))
    if [ $usage_percent -gt 80 ]; then
        log_message "WARNING: 连接数使用率${usage_percent}%，当前连接${connections}/${max_connections}"
    fi
    
    # 2. 检查锁等待
    lock_waits=$(mysql -e "SHOW STATUS LIKE 'Table_locks_waited';" | tail -n 1 | awk '{print $2}')
    if [ $lock_waits -gt 100 ]; then
        log_message "WARNING: 表锁等待次数过高：$lock_waits"
    fi
    
    # 3. 检查慢查询
    slow_queries=$(mysql -e "SHOW STATUS LIKE 'Slow_queries';" | tail -n 1 | awk '{print $2}')
    log_message "INFO: 当前慢查询数量：$slow_queries"
}

# 业务层面检查
check_business_logic() {
    # 执行简单的业务查询，确保数据库可用
    test_query="SELECT 1"
    if ! mysql -e "$test_query" > /dev/null 2>&1; then
        log_message "ERROR: 业务测试查询失败"
        return 1
    fi
    
    # 检查关键业务表是否可访问
    important_tables=("users" "orders" "products")
    for table in "${important_tables[@]}"; do
        if ! mysql -e "SELECT COUNT(*) FROM $table LIMIT 1" > /dev/null 2>&1; then
            log_message "ERROR: 关键表$table 不可访问"
            return 1
        fi
    done
    
    return 0
}
```

---

## 6. 🔄 故障切换协调机制


### 6.1 MHA与Keepalived协调原理


**🤝 协调机制流程**
```
协调场景分析：

场景1：MySQL故障，服务器正常
┌─────────────────────────────────────────┐
│ 1. MySQL服务崩溃                        │
│ 2. Keepalived健康检查失败               │
│ 3. VIP切换到Backup节点                  │
│ 4. MHA检测到Master故障                  │
│ 5. MHA执行故障切换                      │
│ 6. 新Master启动后，VIP已在正确节点      │
└─────────────────────────────────────────┘

场景2：服务器故障
┌─────────────────────────────────────────┐
│ 1. 服务器宕机                           │
│ 2. Keepalived心跳中断                   │
│ 3. VIP立即切换                          │
│ 4. MHA同时检测到故障                    │
│ 5. 两个系统同步执行切换                 │
└─────────────────────────────────────────┘

关键协调点：
• 健康检查脚本是连接两个系统的桥梁
• VIP切换速度快于MHA故障切换
• 需要确保VIP在正确的节点上
```

### 6.2 切换时序控制


**⏰ 切换时序设计**
```
理想切换时序：
T0: 故障发生
T1: Keepalived检测到故障（3秒内）
T2: VIP切换完成（1秒内）
T3: MHA开始故障切换（可能需要几十秒）
T4: 数据库故障切换完成
T5: 服务完全恢复

时序控制要点：
1. VIP切换必须快于数据库切换
2. 避免VIP指向未准备好的数据库
3. 确保新Master完全就绪后才接收请求
```

### 6.3 切换状态同步


**📊 状态同步机制**
```bash
# 状态同步脚本示例
sync_mha_keepalived_status() {
    # 获取当前MHA状态
    mha_master=$(masterha_check_status --conf=/etc/mha/app1.cnf | grep "Current master" | awk '{print $3}')
    
    # 获取当前VIP所在节点
    vip_node=$(ip addr show | grep "192.168.1.200" | head -n1)
    
    # 检查状态是否一致
    if [ ! -z "$vip_node" ]; then
        current_host=$(hostname)
        if [ "$mha_master" != "$current_host" ]; then
            log_message "WARNING: MHA Master($mha_master)与VIP节点($current_host)不一致"
            # 可以选择：
            # 1. 重新切换VIP
            # 2. 触发MHA重新选举
            # 3. 发送告警等待人工处理
        fi
    fi
}

# 在Keepalived通知脚本中调用
sync_mha_keepalived_status
```

---

## 7. 🧠 脑裂问题处理


### 7.1 什么是脑裂


**🧠 脑裂现象解释**
```
脑裂 = Split Brain：网络分区导致集群被分割成多个独立部分

危险场景：
原始状态：
节点A (Master, VIP) ←→ 节点B (Backup)
              网络正常

网络故障后：
节点A (认为自己是Master, 持有VIP)  ✗  节点B (认为A故障，升级为Master, 也持有VIP)

结果：
• 两个节点都认为自己是Master
• 两个节点都可能持有VIP  
• 数据可能不一致
• 应用可能连接到不同的Master

比喻：就像一个国家突然有了两个皇帝，各自都认为自己是正统
```

### 7.2 脑裂检测机制


**🔍 多重检测方法**
```bash
# 脑裂检测脚本
#!/bin/bash
# /etc/keepalived/scripts/split_brain_check.sh

# 配置其他节点IP
OTHER_NODES=("192.168.1.101" "192.168.1.102")
GATEWAY="192.168.1.1"

# 网络连通性检测
check_network_connectivity() {
    local reachable_nodes=0
    
    # 检测到其他节点的连通性
    for node in "${OTHER_NODES[@]}"; do
        if ping -c 3 -W 2 $node > /dev/null 2>&1; then
            reachable_nodes=$((reachable_nodes + 1))
            log_message "INFO: 节点$node 可达"
        else
            log_message "WARNING: 节点$node 不可达"
        fi
    done
    
    # 检测到网关的连通性
    if ping -c 3 -W 2 $GATEWAY > /dev/null 2>&1; then
        log_message "INFO: 网关$GATEWAY 可达"
        return 0
    else
        log_message "ERROR: 网关$GATEWAY 不可达，可能是本地网络问题"
        return 1
    fi
}

# 通过数据库检测
check_database_split_brain() {
    # 检查其他节点的数据库状态
    for node in "${OTHER_NODES[@]}"; do
        # 尝试连接其他节点的数据库
        if mysql -h$node -ucheck_user -ppassword -e "SELECT $$server_id" > /dev/null 2>&1; then
            log_message "WARNING: 检测到节点$node 的数据库仍在运行，可能存在脑裂"
            return 1
        fi
    done
    return 0
}

# 通过共享存储检测（如果有的话）
check_shared_storage() {
    # 检查共享存储上的心跳文件
    HEARTBEAT_FILE="/shared/storage/heartbeat"
    
    if [ -f "$HEARTBEAT_FILE" ]; then
        # 读取其他节点的心跳时间戳
        last_heartbeat=$(cat $HEARTBEAT_FILE)
        current_time=$(date +%s)
        time_diff=$((current_time - last_heartbeat))
        
        if [ $time_diff -lt 10 ]; then
            log_message "WARNING: 检测到其他节点的活跃心跳，可能存在脑裂"
            return 1
        fi
    fi
    
    # 写入自己的心跳
    echo $(date +%s) > $HEARTBEAT_FILE
    return 0
}
```

### 7.3 脑裂处理策略


**🛡️ 处理策略**
```
策略1：仲裁机制
┌─────────────────────────────────────────┐
│ • 引入第三方仲裁节点（如Zookeeper）    │
│ • 只有能连接到仲裁节点的才能成为Master │
│ • 适用于对可用性要求极高的场景         │
└─────────────────────────────────────────┘

策略2：优先级策略
┌─────────────────────────────────────────┐
│ • 预设节点优先级顺序                   │
│ • 脑裂时优先级低的节点主动放弃         │
│ • 简单有效，但可能影响性能最优选择     │
└─────────────────────────────────────────┘

策略3：静默策略
┌─────────────────────────────────────────┐
│ • 检测到脑裂时，所有节点都停止服务     │
│ • 等待人工干预解决                     │
│ • 最安全但影响可用性                   │
└─────────────────────────────────────────┘

策略4：资源隔离
┌─────────────────────────────────────────┐
│ • 通过STONITH技术强制关闭故障节点      │
│ • 确保只有一个节点提供服务             │
│ • 需要硬件支持（如IPMI、iLO）          │
└─────────────────────────────────────────┘
```

### 7.4 脑裂预防配置


**⚙️ 预防性配置**
```bash
# Keepalived配置中添加脑裂检测
vrrp_script check_split_brain {
    script "/etc/keepalived/scripts/split_brain_check.sh"
    interval 10
    weight -100     # 检测到脑裂时大幅降低优先级
    fall 2
    rise 1
}

vrrp_instance VI_1 {
    # ... 其他配置 ...
    
    track_script {
        check_mysql
        check_split_brain   # 添加脑裂检测
    }
    
    # 添加更多的网络检测
    track_interface {
        eth0 weight -50     # 主网卡故障时降低优先级
        eth1 weight -20     # 备用网卡故障时适度降低
    }
}

# 在notify脚本中添加脑裂处理
notify_master "/etc/keepalived/scripts/notify_master_with_split_brain_check.sh"
```

---

## 8. 📊 监控告警体系


### 8.1 监控指标设计


**📈 关键监控指标**
```
Keepalived层面：
┌─────────────────┬──────────────┬─────────────┬──────────────┐
│    监控项目     │   正常值     │   告警阈值  │   紧急阈值   │
├─────────────────┼──────────────┼─────────────┼──────────────┤
│ VRRP状态        │ MASTER/BACKUP│    FAULT    │   长时间FAULT│
│ VIP绑定状态     │     正常     │   未绑定    │     脑裂     │
│ 心跳包丢失率    │     < 1%     │    > 5%     │    > 10%     │
│ 状态切换频率    │   < 1次/天   │  > 3次/天   │   > 10次/天  │
└─────────────────┴──────────────┴─────────────┴──────────────┘

MySQL层面：
┌─────────────────┬──────────────┬─────────────┬──────────────┐
│    监控项目     │   正常值     │   告警阈值  │   紧急阈值   │
├─────────────────┼──────────────┼─────────────┼──────────────┤
│ 数据库连接性    │     可连接   │   连接失败  │   持续失败   │
│ 主从复制状态    │ IO/SQL:Yes   │   任一No    │   双线程异常 │
│ 复制延迟        │     < 1秒    │    > 60秒   │    > 300秒   │
│ 连接数使用率    │     < 70%    │    > 80%    │     > 90%    │
└─────────────────┴──────────────┴─────────────┴──────────────┘
```

### 8.2 监控脚本实现


**📄 综合监控脚本**
```bash
#!/bin/bash
# /opt/monitoring/mha_keepalived_monitor.sh

# 配置参数
MONITOR_INTERVAL=30
LOG_FILE="/var/log/monitoring/mha_keepalived.log"
ALERT_FILE="/var/log/monitoring/alerts.log"

# 告警函数
send_alert() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message" >> $ALERT_FILE
    
    case $level in
        "CRITICAL")
            # 发送紧急告警（短信、电话、邮件）
            echo "$message" | mail -s "CRITICAL: MySQL HA故障" admin@company.com
            # curl -X POST "https://api.sms.com/send" -d "message=$message&phone=13800138000"
            ;;
        "WARNING")
            # 发送警告（邮件、钉钉）
            echo "$message" | mail -s "WARNING: MySQL HA警告" admin@company.com
            ;;
        "INFO")
            # 记录信息
            echo "[$timestamp] [INFO] $message" >> $LOG_FILE
            ;;
    esac
}

# 检查Keepalived状态
check_keepalived_status() {
    if ! systemctl is-active keepalived > /dev/null 2>&1; then
        send_alert "CRITICAL" "Keepalived服务未运行"
        return 1
    fi
    
    # 检查VIP绑定状态
    local vip_status=$(ip addr show | grep "192.168.1.200")
    if [ ! -z "$vip_status" ]; then
        # 当前节点持有VIP
        local vrrp_state=$(grep "state" /etc/keepalived/keepalived.conf | head -n1 | awk '{print $2}')
        send_alert "INFO" "当前节点持有VIP，角色：$vrrp_state"
        
        # 检查是否存在脑裂
        check_split_brain_monitoring
    else
        send_alert "INFO" "当前节点未持有VIP，处于Backup状态"
    fi
}

# 脑裂监控
check_split_brain_monitoring() {
    local nodes_with_vip=0
    local all_nodes=("192.168.1.100" "192.168.1.101" "192.168.1.102")
    
    for node in "${all_nodes[@]}"; do
        if ssh $node "ip addr show | grep 192.168.1.200" > /dev/null 2>&1; then
            nodes_with_vip=$((nodes_with_vip + 1))
        fi
    done
    
    if [ $nodes_with_vip -gt 1 ]; then
        send_alert "CRITICAL" "检测到脑裂：$nodes_with_vip 个节点同时持有VIP"
    fi
}

# 检查MHA状态
check_mha_status() {
    # 检查MHA Manager进程
    if ! pgrep -f "masterha_manager" > /dev/null; then
        send_alert "WARNING" "MHA Manager进程未运行"
    fi
    
    # 检查MHA配置文件状态
    local mha_status=$(masterha_check_status --conf=/etc/mha/app1.cnf 2>/dev/null)
    local exit_code=$?
    
    case $exit_code in
        0)
            send_alert "INFO" "MHA状态正常"
            ;;
        1)
            send_alert "WARNING" "MHA检测到故障或配置问题"
            ;;
        2)
            send_alert "CRITICAL" "MHA Manager未运行"
            ;;
        *)
            send_alert "WARNING" "MHA状态检查异常，退出码：$exit_code"
            ;;
    esac
}

# 性能指标监控
check_performance_metrics() {
    # MySQL连接数监控
    local connections=$(mysql -e "SHOW STATUS LIKE 'Threads_connected';" 2>/dev/null | tail -n 1 | awk '{print $2}')
    local max_connections=$(mysql -e "SHOW VARIABLES LIKE 'max_connections';" 2>/dev/null | tail -n 1 | awk '{print $2}')
    
    if [ ! -z "$connections" ] && [ ! -z "$max_connections" ]; then
        local usage_percent=$((connections * 100 / max_connections))
        if [ $usage_percent -gt 90 ]; then
            send_alert "CRITICAL" "MySQL连接数使用率${usage_percent}%，当前连接${connections}/${max_connections}"
        elif [ $usage_percent -gt 80 ]; then
            send_alert "WARNING" "MySQL连接数使用率${usage_percent}%，当前连接${connections}/${max_connections}"
        fi
    fi
    
    # 主从复制延迟监控
    local slave_status=$(mysql -e "SHOW SLAVE STATUS\G" 2>/dev/null)
    if [ ! -z "$slave_status" ]; then
        local seconds_behind=$(echo "$slave_status" | grep "Seconds_Behind_Master:" | awk '{print $2}')
        if [ "$seconds_behind" != "0" ] && [ "$seconds_behind" != "NULL" ]; then
            if [ "$seconds_behind" -gt 300 ]; then
                send_alert "CRITICAL" "MySQL复制延迟${seconds_behind}秒"
            elif [ "$seconds_behind" -gt 60 ]; then
                send_alert "WARNING" "MySQL复制延迟${seconds_behind}秒"
            fi
        fi
    fi
}

# 生成监控报告
generate_monitoring_report() {
    local report_file="/var/log/monitoring/daily_report_$(date +%Y%m%d).log"
    
    {
        echo "========== MySQL HA 日常监控报告 =========="
        echo "报告时间：$(date '+%Y-%m-%d %H:%M:%S')"
        echo ""
        
        echo "1. Keepalived状态："
        systemctl status keepalived --no-pager
        echo ""
        
        echo "2. VIP绑定状态："
        ip addr show | grep "192.168.1.200" || echo "VIP未绑定到当前节点"
        echo ""
        
        echo "3. MySQL状态："
        mysql -e "SELECT $$hostname, $$server_id, $$read_only;" 2>/dev/null || echo "MySQL连接失败"
        echo ""
        
        echo "4. 网络连通性："
        ping -c 3 192.168.1.100 > /dev/null && echo "192.168.1.100: OK" || echo "192.168.1.100: FAIL"
        ping -c 3 192.168.1.101 > /dev/null && echo "192.168.1.101: OK" || echo "192.168.1.101: FAIL"
        ping -c 3 192.168.1.102 > /dev/null && echo "192.168.1.102: OK" || echo "192.168.1.102: FAIL"
        echo ""
        
        echo "============================================"
    } > $report_file
    
    send_alert "INFO" "日常监控报告已生成：$report_file"
}

# 主监控循环
main_monitoring_loop() {
    while true; do
        check_keepalived_status
        check_mha_status
        check_performance_metrics
        
        sleep $MONITOR_INTERVAL
    done
}

# 根据参数执行不同功能
case "$1" in
    "start")
        main_monitoring_loop
        ;;
    "report")
        generate_monitoring_report
        ;;
    "check")
        check_keepalived_status
        check_mha_status
        check_performance_metrics
        ;;
    *)
        echo "用法: $0 {start|report|check}"
        exit 1
        ;;
esac
```

### 8.3 监控集成配置


**🔧 与监控系统集成**
```bash
# Zabbix监控配置示例
# /etc/zabbix/zabbix_agentd.d/mysql_ha.conf

# Keepalived VIP状态
UserParameter=keepalived.vip.status,ip addr show | grep -c "192.168.1.200"

# Keepalived进程状态
UserParameter=keepalived.process.status,systemctl is-active keepalived

# MHA状态检查
UserParameter=mha.status,masterha_check_status --conf=/etc/mha/app1.cnf > /dev/null 2>&1; echo $?

# MySQL主从复制延迟
UserParameter=mysql.slave.lag,mysql -e "SHOW SLAVE STATUS\G" 2>/dev/null | grep "Seconds_Behind_Master:" | awk '{print $2}' | head -n1

# Prometheus监控配置示例
# /etc/prometheus/node_exporter/mysql_ha.prom

# HELP mysql_ha_vip_status VIP binding status
# TYPE mysql_ha_vip_status gauge
mysql_ha_vip_status $(ip addr show | grep -c "192.168.1.200")

# HELP mysql_ha_keepalived_status Keepalived service status  
# TYPE mysql_ha_keepalived_status gauge
mysql_ha_keepalived_status $(systemctl is-active keepalived > /dev/null && echo 1 || echo 0)
```

---

## 9. 🔧 故障排查指南


### 9.1 常见故障现象


**❗ 故障症状分类**
```
VIP相关故障：
┌─────────────────┬──────────────────┬─────────────────┐
│   故障现象      │     可能原因     │    排查方法     │
├─────────────────┼──────────────────┼─────────────────┤
│ VIP无法访问     │ 网络配置问题     │ ping、telnet测试│
│ VIP频繁切换     │ 健康检查误报     │ 查看检查脚本日志│
│ VIP绑定失败     │ 网卡配置问题     │ ip addr命令检查 │
│ 脑裂现象        │ 网络分区        │ 网络连通性测试  │
└─────────────────┴──────────────────┴─────────────────┘

服务相关故障：
┌─────────────────┬──────────────────┬─────────────────┐
│   故障现象      │     可能原因     │    排查方法     │
├─────────────────┼──────────────────┼─────────────────┤
│ Keepalived不启动│ 配置文件语法错误 │ 检查配置语法    │
│ 健康检查失败    │ MySQL服务异常    │ 手动执行检查脚本│
│ 状态切换异常    │ 权限或脚本问题   │ 查看系统日志    │
│ 认证失败        │ 密码或认证配置   │ 检查auth配置    │
└─────────────────┴──────────────────┴─────────────────┘
```

### 9.2 诊断命令集合


**🔍 常用诊断命令**
```bash
# 1. Keepalived状态检查
# 查看Keepalived服务状态
systemctl status keepalived -l

# 查看Keepalived进程
ps aux | grep keepalived

# 查看VIP绑定状态
ip addr show | grep "192.168.1.200"

# 查看VRRP包
tcpdump -i eth0 vrrp

# 2. 网络连通性检查
# 检查节点间连通性
ping -c 5 192.168.1.101

# 检查VRRP组播
ping -c 3 224.0.0.18

# 检查端口监听
netstat -tlnp | grep :3306

# 3. 日志分析
# Keepalived日志
tail -f /var/log/messages | grep keepalived

# 自定义健康检查日志
tail -f /var/log/keepalived/mysql_check.log

# 系统日志中的网络相关信息
journalctl -u keepalived -f

# 4. 配置验证
# 检查配置文件语法
keepalived -t -f /etc/keepalived/keepalived.conf

# 查看当前VRRP状态
cat /proc/net/vrrp

# 检查脚本权限
ls -la /etc/keepalived/scripts/

# 5. MySQL相关检查
# 检查MySQL连接
mysql -h 192.168.1.200 -e "SELECT $$hostname, $$server_id;"

# 检查主从状态
mysql -e "SHOW SLAVE STATUS\G"

# 检查MySQL进程
pgrep -f mysqld
```

### 9.3 故障处理流程


**🔄 标准处理流程**
```
故障发现：
┌─────────────────────────────────────────┐
│ 1. 监控告警或用户反馈                   │
│ 2. 确认故障现象和影响范围               │
│ 3. 记录故障发生时间和初始状态           │
└─────────────────────────────────────────┘
            ↓
初步诊断：
┌─────────────────────────────────────────┐
│ 1. 检查VIP绑定状态                      │
│ 2. 检查Keepalived服务状态               │
│ 3. 检查MySQL服务状态                    │
│ 4. 查看相关日志                         │
└─────────────────────────────────────────┘
            ↓
深入分析：
┌─────────────────────────────────────────┐
│ 1. 分析日志中的错误信息                 │
│ 2. 检查网络连通性                       │
│ 3. 验证配置文件正确性                   │
│ 4. 测试健康检查脚本                     │
└─────────────────────────────────────────┘
            ↓
问题修复：
┌─────────────────────────────────────────┐
│ 1. 根据诊断结果实施修复措施             │
│ 2. 验证修复效果                         │
│ 3. 测试故障切换功能                     │
│ 4. 恢复正常服务                         │
└─────────────────────────────────────────┘
            ↓
总结记录：
┌─────────────────────────────────────────┐
│ 1. 记录故障原因和解决方案               │
│ 2. 更新故障处理文档                     │
│ 3. 评估是否需要改进监控或配置           │
│ 4. 制定预防措施                         │
└─────────────────────────────────────────┘
```

### 9.4 故障案例分析


**📋 典型故障案例**
```
案例1：VIP频繁切换
现象：VIP在节点间频繁切换，每隔几分钟切换一次
原因分析：
• 健康检查脚本设置过于敏感
• 网络偶发性延迟
• MySQL服务偶发性卡顿

解决方案：
• 调整健康检查的fall和rise参数
• 增加超时时间和重试机制
• 优化MySQL配置减少卡顿

预防措施：
• 建立更完善的性能监控
• 定期压力测试验证稳定性

案例2：脑裂导致数据不一致
现象：网络故障后出现两个Master，数据出现分叉
原因分析：
• 网络分区导致节点间失联
• 缺乏有效的脑裂检测机制
• 自动故障切换过于激进

解决方案：
• 实施数据恢复和合并
• 添加脑裂检测脚本
• 引入仲裁机制

预防措施：
• 部署多链路网络
• 实施共享存储心跳检测

案例3：健康检查脚本失效
现象：MySQL故障但VIP未切换
原因分析：
• 健康检查脚本存在逻辑漏洞
• 脚本执行权限问题
• 检查项目不够全面

解决方案：
• 修复脚本逻辑问题
• 调整文件权限和属主
• 增加更多检查维度

预防措施：
• 定期测试健康检查脚本
• 建立脚本代码审查机制
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 集成原理：MHA负责数据库层，Keepalived负责网络层
🔸 VIP机制：虚拟IP提供统一访问入口，自动故障切换
🔸 VRRP协议：确保同一时间只有一个节点持有VIP
🔸 健康检查：连接两个系统的桥梁，决定切换时机
🔸 脑裂问题：网络分区导致的多Master问题及其防范
🔸 监控告警：及时发现问题，保障系统稳定运行
```

### 10.2 关键理解要点


**🔹 为什么需要MHA+Keepalived**
```
单纯MHA的问题：
• 故障切换后IP地址改变
• 应用需要修改配置
• 增加恢复时间和复杂度

MHA+Keepalived的优势：
• VIP提供固定访问入口
• 应用程序无感知切换
• 网络层和数据层双重保障
• 自动化程度更高
```

**🔹 配置的关键要素**
```
优先级设计：
• 主从节点要有明确的优先级差异
• 预留调整空间便于维护
• 考虑性能和位置因素

健康检查设计：
• 检查项目要全面但不能过于敏感
• 超时和重试参数要合理
• 脚本要有充分的容错机制

脑裂防范：
• 多种检测方式结合
• 明确的处理策略
• 必要时选择可用性或一致性
```

**🔹 监控的重要性**
```
预防性监控：
• 发现潜在问题避免故障
• 性能趋势分析
• 容量规划依据

故障监控：
• 快速发现和定位问题
• 自动化告警和处理
• 故障影响最小化

运维监控：
• 操作规范性检查
• 配置变更追踪
• 安全风险识别
```

### 10.3 实际应用价值


**💼 生产环境应用**
- **高可用保障**：提供99.9%以上的服务可用性
- **业务连续性**：故障切换对业务几乎无感知
- **运维效率**：自动化故障处理减少人工干预
- **成本控制**：避免业务中断带来的损失

**🔧 运维实践要点**
- **配置管理**：版本控制、变更审批、回滚机制
- **测试验证**：定期故障切换演练、压力测试
- **监控完善**：全方位监控、及时告警、趋势分析
- **文档维护**：操作手册、故障处理流程、经验总结

### 10.4 注意事项和最佳实践


**⚠️ 重要注意事项**
```
配置安全：
• 认证密码要足够复杂
• 脚本文件权限要严格控制
• 避免在脚本中硬编码敏感信息

网络规划：
• 确保VRRP组播通信正常
• 防火墙规则要正确配置
• 网络设备要支持快速MAC学习

测试验证：
• 新配置要在测试环境验证
• 定期进行故障切换演练
• 压力测试验证性能表现
```

**💡 最佳实践建议**
```
部署实践：
• 使用配置管理工具统一部署
• 建立标准化的部署流程
• 做好配置文件的版本管理

监控实践：
• 建立分层监控体系
• 设置合理的告警阈值
• 建立故障处理知识库

维护实践：
• 定期检查和更新配置
• 保持软件版本的及时更新
• 建立详细的操作日志
```

**🎯 学习建议**
```
理论学习：
• 深入理解VRRP协议原理
• 掌握MySQL主从复制机制
• 学习Linux网络配置知识

实践操作：
• 搭建测试环境动手练习
• 模拟各种故障场景
• 熟练掌握故障排查方法

持续提升：
• 关注技术发展趋势
• 学习其他高可用方案
• 参与技术社区交流
```

**核心记忆口诀**：
- MHA管数据库，Keepalived管网络
- VIP提供统一入口，VRRP保证唯一性
- 健康检查是桥梁，监控告警是眼睛
- 脑裂防范很重要，故障演练不可少