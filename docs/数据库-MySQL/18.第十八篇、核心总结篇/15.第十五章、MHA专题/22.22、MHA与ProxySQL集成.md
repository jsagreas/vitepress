---
title: 22、MHA与ProxySQL集成
---
## 📚 目录

1. [ProxySQL核心概念](#1-ProxySQL核心概念)
2. [MHA与ProxySQL架构集成](#2-MHA与ProxySQL架构集成)
3. [读写分离配置详解](#3-读写分离配置详解)
4. [连接池管理与优化](#4-连接池管理与优化)
5. [故障切换自动化配合](#5-故障切换自动化配合)
6. [健康检查与监控配置](#6-健康检查与监控配置)
7. [路由规则与负载均衡](#7-路由规则与负载均衡)
8. [性能优化策略](#8-性能优化策略)
9. [故障排查指南](#9-故障排查指南)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌐 ProxySQL核心概念


### 1.1 ProxySQL是什么


**简单理解**：ProxySQL就像是一个"聪明的数据库代理人"，它站在应用程序和MySQL数据库之间，帮助管理连接、分发请求。

```
传统模式：
应用程序 ——直接连接——> MySQL数据库
问题：应用需要自己处理读写分离、故障切换

ProxySQL模式：
应用程序 ——> ProxySQL ——> MySQL主从集群
好处：ProxySQL自动处理复杂的数据库逻辑
```

**核心作用**：
- **读写分离**：自动把读请求发给从库，写请求发给主库
- **连接池**：复用数据库连接，提高性能
- **负载均衡**：多个从库之间分配读请求
- **故障切换**：主库挂了自动切换到新主库
- **查询路由**：根据SQL语句类型智能路由

### 1.2 ProxySQL架构特点


**分层架构设计**：
```
┌─────────────────────────────────────┐
│           应用程序层                │
├─────────────────────────────────────┤
│          ProxySQL代理层             │ ← 统一入口
│  ┌─────────┬─────────┬─────────┐    │
│  │连接池   │查询路由 │负载均衡 │    │
│  └─────────┴─────────┴─────────┘    │
├─────────────────────────────────────┤
│        MySQL数据库集群              │
│  ┌─────────┬─────────┬─────────┐    │
│  │ 主库    │ 从库1   │ 从库2   │    │
│  └─────────┴─────────┴─────────┘    │
└─────────────────────────────────────┘
```

**核心组件**：
- **Admin接口**：管理和配置ProxySQL
- **MySQL接口**：接收应用程序的连接请求
- **后端连接池**：管理到MySQL的连接
- **查询处理器**：分析和路由SQL查询
- **监控模块**：实时监控后端数据库状态

### 1.3 ProxySQL配置概念


**配置存储结构**：
```
ProxySQL配置分为三层：
┌─────────────────┐
│    RUNTIME      │ ← 当前运行的配置
├─────────────────┤
│    MEMORY       │ ← 内存中的配置（可修改）
├─────────────────┤
│    DISK         │ ← 磁盘持久化配置
└─────────────────┘

配置生效流程：
MEMORY → RUNTIME (加载到运行时)
MEMORY → DISK (保存到磁盘)
```

**配置管理命令**：
```sql
-- 将内存配置加载到运行时
LOAD MYSQL SERVERS TO RUNTIME;

-- 将内存配置保存到磁盘
SAVE MYSQL SERVERS TO DISK;

-- 从磁盘加载配置到内存
LOAD MYSQL SERVERS FROM DISK;
```

---

## 2. 🔗 MHA与ProxySQL架构集成


### 2.1 集成架构设计


**整体架构图**：
```
                    应用程序集群
                         │
                    ┌─────────┐
                    │ProxySQL │ ← 单点接入
                    │(VIP)    │
                    └─────────┘
                         │
     ┌───────────────────┼───────────────────┐
     │                   │                   │
┌─────────┐         ┌─────────┐         ┌─────────┐
│MySQL主库│ ←MHA监控→│MySQL从库1│ ←MHA监控→│MySQL从库2│
│(写)     │         │(读)     │         │(读)     │
└─────────┘         └─────────┘         └─────────┘
     │                   │                   │
     └───────────────────┼───────────────────┘
                         │
                   ┌─────────┐
                   │MHA管理节点│ ← 故障检测和切换
                   └─────────┘
```

**组件职责划分**：
- **MHA**：负责故障检测、主从切换、数据补齐
- **ProxySQL**：负责连接管理、读写分离、负载均衡
- **应用程序**：只需连接ProxySQL，无需关心底层复杂性

### 2.2 集成的核心优势


**解决的关键问题**：

```
问题1：应用程序如何感知主库切换？
传统方案：应用程序需要修改配置，重启
集成方案：ProxySQL自动更新后端服务器，应用无感知

问题2：故障切换期间的连接处理？
传统方案：连接中断，需要应用程序重连
集成方案：ProxySQL自动重路由，连接保持

问题3：读写分离的复杂配置？
传统方案：应用程序需要维护多个数据源
集成方案：ProxySQL统一管理，应用只需一个连接
```

### 2.3 部署架构选择


**单ProxySQL部署**：
```
优点：简单，成本低
缺点：ProxySQL成为单点故障
适用：小型应用，对可用性要求不高
```

**多ProxySQL + VIP部署**：
```
┌─────────────────┐    ┌─────────────────┐
│   ProxySQL1     │    │   ProxySQL2     │
│   (Master)      │    │   (Standby)     │
│   VIP: 主       │    │   VIP: 备       │
└─────────────────┘    └─────────────────┘
         │                       │
         └───────────┬───────────┘
                     │
               MySQL集群

优点：高可用，无单点故障
缺点：配置复杂，需要额外的VIP管理
适用：生产环境，高可用要求
```

---

## 3. 📖 读写分离配置详解


### 3.1 读写分离基本原理


**什么是读写分离**：
就像图书馆分为"借书处"和"还书处"一样，数据库也可以分为"写数据的地方"（主库）和"读数据的地方"（从库）。

```
传统模式（所有操作都在主库）：
SELECT、INSERT、UPDATE、DELETE ——> 主库
问题：主库压力大，性能瓶颈

读写分离模式：
SELECT ——————————————————————————> 从库（读操作）
INSERT、UPDATE、DELETE ——————————> 主库（写操作）
好处：分散压力，提高整体性能
```

### 3.2 服务器组配置


**配置后端服务器**：
```sql
-- 连接ProxySQL管理接口
mysql -h 127.0.0.1 -P6032 -uadmin -padmin

-- 配置主库（写组）
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight, status) VALUES
(0, '192.168.1.10', 3306, 1000, 'ONLINE');  -- 主库，hostgroup_id=0

-- 配置从库（读组）
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight, status) VALUES
(1, '192.168.1.11', 3306, 900, 'ONLINE'),   -- 从库1，hostgroup_id=1
(1, '192.168.1.12', 3306, 900, 'ONLINE');   -- 从库2，hostgroup_id=1

-- 应用配置
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
```

**服务器组说明**：
- **hostgroup_id=0**：写组，只有主库
- **hostgroup_id=1**：读组，包含所有从库
- **weight**：权重，数值越大分配的连接越多
- **status**：状态，ONLINE表示可用

### 3.3 查询路由规则配置


**基本路由规则**：
```sql
-- 写操作路由到主库组（hostgroup 0）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(1, '^SELECT.*FOR UPDATE$', 0, 1),           -- SELECT FOR UPDATE 到主库
(2, '^INSERT.*', 0, 1),                      -- INSERT 到主库
(3, '^UPDATE.*', 0, 1),                      -- UPDATE 到主库  
(4, '^DELETE.*', 0, 1),                      -- DELETE 到主库
(5, '^REPLACE.*', 0, 1),                     -- REPLACE 到主库
(6, '^ALTER.*', 0, 1),                       -- ALTER 到主库
(7, '^CREATE.*', 0, 1),                      -- CREATE 到主库
(8, '^DROP.*', 0, 1);                        -- DROP 到主库

-- 读操作路由到从库组（hostgroup 1）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(10, '^SELECT.*', 1, 1);                     -- 普通SELECT 到从库

-- 应用配置
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

**特殊场景处理**：
```sql
-- 强制某些查询到主库（保证数据一致性）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(15, '^SELECT.*FROM user_session.*', 0, 1),  -- 用户会话查询到主库
(16, '^SELECT.*FROM payment.*', 0, 1);       -- 支付相关查询到主库
```

### 3.4 读写分离验证


**验证配置是否生效**：
```sql
-- 查看路由规则
SELECT rule_id, match_pattern, destination_hostgroup 
FROM mysql_query_rules 
WHERE active=1 ORDER BY rule_id;

-- 查看服务器状态
SELECT hostgroup_id, hostname, port, status, weight 
FROM mysql_servers;

-- 实时监控查询路由
SELECT * FROM stats_mysql_query_rules ORDER BY hits DESC;
```

**测试读写分离**：
```bash
# 连接ProxySQL（应用程序视角）
mysql -h127.0.0.1 -P6033 -uapp_user -ppassword

# 执行写操作（应该路由到主库）
mysql> INSERT INTO test_table VALUES (1, 'test');

# 执行读操作（应该路由到从库）
mysql> SELECT * FROM test_table;

# 查看连接统计
mysql> SELECT * FROM stats_mysql_connection_pool;
```

---

## 4. 🔧 连接池管理与优化


### 4.1 连接池基本概念


**什么是连接池**：
想象一下出租车和公交车的区别：
- **没有连接池**：像打车，每次都要重新叫车（建立连接），用完就走（关闭连接）
- **有连接池**：像公交车，车一直在路上（连接保持），乘客上下车（复用连接）

```
传统连接模式：
应用请求 → 建立连接 → 执行SQL → 关闭连接
问题：频繁建立/关闭连接消耗资源

连接池模式：
应用请求 → 从池中取连接 → 执行SQL → 归还连接到池
好处：连接复用，减少开销
```

### 4.2 连接池配置参数


**关键配置参数**：
```sql
-- 配置用户连接池参数
INSERT INTO mysql_users(username, password, default_hostgroup, max_connections) VALUES
('app_user', 'password123', 1, 200);  -- 默认读组，最大200连接

-- 配置全局连接池参数
SET mysql-max_connections=2048;              -- ProxySQL最大连接数
SET mysql-default_max_connections=200;       -- 每个后端服务器默认最大连接
SET mysql-connection_delay_multiplex_ms=0;   -- 连接复用延迟
SET mysql-connection_max_age_ms=0;           -- 连接最大存活时间
SET mysql-ping_interval_server_msec=10000;   -- 后端服务器ping间隔

-- 应用配置
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

**参数详细说明**：
- **max_connections**：用户最大连接数，防止某个用户占用过多连接
- **default_max_connections**：每个后端MySQL服务器的最大连接数
- **connection_delay_multiplex_ms**：连接复用延迟，0表示立即复用
- **ping_interval_server_msec**：ProxySQL ping后端服务器的间隔

### 4.3 连接池监控


**监控连接池状态**：
```sql
-- 查看连接池统计
SELECT * FROM stats_mysql_connection_pool;

-- 查看用户连接统计  
SELECT * FROM stats_mysql_users;

-- 查看全局连接统计
SELECT * FROM stats_mysql_global;

-- 实时监控活跃连接
SELECT hostgroup, srv_host, srv_port, 
       ConnUsed, ConnFree, ConnOK, ConnERR
FROM stats_mysql_connection_pool
ORDER BY ConnUsed DESC;
```

**连接池健康检查**：
```sql
-- 检查连接池是否有异常
SELECT 
    hostgroup,
    srv_host,
    ConnUsed,
    ConnFree,
    ConnERR,
    ROUND(ConnERR*100.0/(ConnUsed+ConnFree+ConnERR), 2) as error_rate
FROM stats_mysql_connection_pool
WHERE ConnERR > 0;
```

### 4.4 连接池优化策略


**性能优化要点**：

> 💡 **优化原则**：根据实际业务负载调整连接池大小

```sql
-- 1. 根据业务峰值设置合理的连接数
-- 经验公式：max_connections = 并发用户数 × 1.2

-- 2. 启用连接复用
SET mysql-connection_delay_multiplex_ms=0;

-- 3. 设置合理的连接超时
SET mysql-connect_timeout_server=1000;      -- 连接超时1秒
SET mysql-ping_timeout_server=200;          -- ping超时200ms

-- 4. 监控并调整
-- 如果ConnUsed接近max_connections，需要增加连接数
-- 如果ConnFree过多，可以适当减少连接数
```

**常见问题处理**：
```sql
-- 问题1：连接数不够用
-- 解决：增加max_connections
UPDATE mysql_users SET max_connections=500 WHERE username='app_user';

-- 问题2：连接错误率高
-- 解决：检查网络或MySQL服务器状态
SELECT * FROM mysql_servers WHERE status='OFFLINE_HARD';

-- 问题3：连接池不平衡
-- 解决：调整权重
UPDATE mysql_servers SET weight=1200 WHERE hostname='192.168.1.11';
```

---

## 5. 🔄 故障切换自动化配合


### 5.1 故障切换流程设计


**MHA + ProxySQL故障切换流程**：
```
正常状态：
应用 → ProxySQL → 主库(写) + 从库(读)

故障发生：
1. MHA检测到主库故障
2. MHA执行主从切换
3. MHA通知ProxySQL更新配置
4. ProxySQL重新路由请求
5. 应用无感知继续工作

故障恢复后：
应用 → ProxySQL → 新主库(写) + 从库(读)
```

### 5.2 MHA切换脚本集成


**master_ip_failover脚本修改**：
```bash
#!/usr/bin/env perl
# /usr/local/bin/master_ip_failover

# ProxySQL配置
my $proxysql_host = "127.0.0.1";
my $proxysql_port = 6032;
my $proxysql_user = "admin";
my $proxysql_pass = "admin";

sub update_proxysql {
    my ($old_master_ip, $new_master_ip) = @_;
    
    # 连接ProxySQL管理接口
    my $proxysql_cmd = "mysql -h$proxysql_host -P$proxysql_port -u$proxysql_user -p$proxysql_pass -e";
    
    # 更新主库配置
    system("$proxysql_cmd \"UPDATE mysql_servers SET hostname='$new_master_ip' WHERE hostgroup_id=0;\"");
    
    # 移除故障的旧主库
    system("$proxysql_cmd \"DELETE FROM mysql_servers WHERE hostname='$old_master_ip' AND hostgroup_id=0;\"");
    
    # 应用配置
    system("$proxysql_cmd \"LOAD MYSQL SERVERS TO RUNTIME;\"");
    system("$proxysql_cmd \"SAVE MYSQL SERVERS TO DISK;\"");
    
    print "ProxySQL配置已更新: $old_master_ip -> $new_master_ip\n";
}
```

**master_ip_online_change脚本**：
```bash
#!/usr/bin/env perl
# 在线切换时也更新ProxySQL配置

sub main {
    # ... 原有的在线切换逻辑 ...
    
    # 切换完成后更新ProxySQL
    if ($command eq "start") {
        update_proxysql($orig_master_ip, $new_master_ip);
    }
}
```

### 5.3 ProxySQL健康检查配置


**配置健康检查参数**：
```sql
-- 配置MySQL服务器健康检查
SET mysql-monitor_username='monitor';
SET mysql-monitor_password='monitor123';
SET mysql-monitor_history=600000;              -- 监控历史保留10分钟
SET mysql-monitor_connect_interval=60000;      -- 连接检查间隔60秒
SET mysql-monitor_ping_interval=10000;         -- ping检查间隔10秒
SET mysql-monitor_read_only_interval=1500;     -- 只读检查间隔1.5秒
SET mysql-monitor_replication_lag_interval=5000; -- 复制延迟检查间隔5秒

-- 应用配置
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

**监控表查看**：
```sql
-- 查看连接监控状态
SELECT * FROM monitor.mysql_server_connect_log 
ORDER BY time_start_us DESC LIMIT 10;

-- 查看ping监控状态  
SELECT * FROM monitor.mysql_server_ping_log 
ORDER BY time_start_us DESC LIMIT 10;

-- 查看只读状态监控
SELECT * FROM monitor.mysql_server_read_only_log 
ORDER BY time_start_us DESC LIMIT 10;
```

### 5.4 自动故障检测和恢复


**故障自动处理脚本**：
```bash
#!/bin/bash
# /usr/local/bin/proxysql_failover_handler.sh

PROXYSQL_HOST="127.0.0.1"
PROXYSQL_PORT="6032"
PROXYSQL_USER="admin"
PROXYSQL_PASS="admin"

# 检查服务器状态
check_server_status() {
    local hostname=$1
    local hostgroup=$2
    
    # 查询服务器状态
    status=$(mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS \
        -se "SELECT status FROM mysql_servers WHERE hostname='$hostname' AND hostgroup_id=$hostgroup;")
    
    echo $status
}

# 自动下线故障服务器
offline_failed_server() {
    local hostname=$1
    local hostgroup=$2
    
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
UPDATE mysql_servers 
SET status='OFFLINE_SOFT' 
WHERE hostname='$hostname' AND hostgroup_id=$hostgroup;
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
EOF
    
    echo "服务器 $hostname 已自动下线"
}

# 主循环
while true; do
    # 检查所有服务器状态
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS \
        -se "SELECT hostname, hostgroup_id, status FROM mysql_servers;" | \
    while read hostname hostgroup status; do
        if [[ "$status" == "SHUNNED" ]]; then
            offline_failed_server $hostname $hostgroup
        fi
    done
    
    sleep 30
done
```

---

## 6. 🔍 健康检查与监控配置


### 6.1 ProxySQL监控体系


**监控架构图**：
```
┌─────────────────────────────────────────────┐
│              监控大屏                        │
├─────────────────────────────────────────────┤
│     Grafana + Prometheus + Alertmanager     │
├─────────────────────────────────────────────┤
│              ProxySQL                       │
│  ┌─────────┬─────────┬─────────┬─────────┐  │
│  │连接监控 │查询监控 │延迟监控 │错误监控 │  │
│  └─────────┴─────────┴─────────┴─────────┘  │
├─────────────────────────────────────────────┤
│           MySQL集群健康状态                  │
└─────────────────────────────────────────────┘
```

### 6.2 关键监控指标配置


**连接相关监控**：
```sql
-- 监控连接池使用率
SELECT 
    hostgroup,
    srv_host,
    ConnUsed,
    ConnFree,
    ROUND(ConnUsed*100.0/(ConnUsed+ConnFree), 2) as usage_rate
FROM stats_mysql_connection_pool;

-- 监控连接错误率
SELECT 
    hostgroup,
    srv_host,
    ConnERR,
    ConnOK,
    ROUND(ConnERR*100.0/(ConnERR+ConnOK), 2) as error_rate
FROM stats_mysql_connection_pool
WHERE ConnERR > 0;
```

**查询性能监控**：
```sql
-- 监控查询响应时间
SELECT 
    hostgroup,
    digest_text,
    count_star,
    sum_time,
    ROUND(sum_time/count_star/1000, 2) as avg_time_ms
FROM stats_mysql_query_digest 
ORDER BY sum_time DESC LIMIT 10;

-- 监控慢查询
SELECT 
    hostgroup,
    digest_text,
    max_time/1000 as max_time_ms,
    count_star
FROM stats_mysql_query_digest 
WHERE max_time > 1000000  -- 超过1秒的查询
ORDER BY max_time DESC;
```

### 6.3 告警规则配置


**Prometheus监控配置**：
```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'proxysql'
    static_configs:
      - targets: ['proxysql-server:6032']
    metrics_path: '/metrics'
    scrape_interval: 15s

# 告警规则 alert_rules.yml
groups:
  - name: proxysql_alerts
    rules:
    # 连接池使用率过高
    - alert: ProxySQLConnectionPoolHigh
      expr: proxysql_connection_pool_used_ratio > 0.8
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "ProxySQL连接池使用率过高"
        
    # 查询错误率过高  
    - alert: ProxySQLQueryErrorHigh
      expr: proxysql_query_error_rate > 0.05
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "ProxySQL查询错误率超过5%"
        
    # 后端服务器下线
    - alert: ProxySQLBackendDown
      expr: proxysql_backend_status == 0
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "ProxySQL后端服务器下线"
```

**监控脚本示例**：
```bash
#!/bin/bash
# /usr/local/bin/proxysql_monitor.sh

PROXYSQL_HOST="127.0.0.1"
PROXYSQL_PORT="6032"
PROXYSQL_USER="admin" 
PROXYSQL_PASS="admin"

# 检查连接池状态
check_connection_pool() {
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
SELECT 
    CONCAT(hostgroup, '_', srv_host) as server,
    ConnUsed,
    ConnFree, 
    ROUND(ConnUsed*100.0/(ConnUsed+ConnFree), 2) as usage_rate
FROM stats_mysql_connection_pool
WHERE ConnUsed+ConnFree > 0;
EOF
}

# 检查后端服务器状态
check_backend_status() {
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
SELECT 
    hostgroup_id,
    hostname,
    port,
    status,
    weight
FROM mysql_servers
ORDER BY hostgroup_id, hostname;
EOF
}

# 检查查询统计
check_query_stats() {
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
SELECT 
    rule_id,
    hits,
    destination_hostgroup
FROM stats_mysql_query_rules
WHERE hits > 0
ORDER BY hits DESC
LIMIT 10;
EOF
}

echo "=== ProxySQL监控报告 $(date) ==="
echo ">>> 连接池状态:"
check_connection_pool
echo ">>> 后端服务器状态:"
check_backend_status  
echo ">>> 查询路由统计:"
check_query_stats
```

### 6.4 日志监控配置


**ProxySQL日志配置**：
```sql
-- 配置日志级别
SET mysql-eventslog_filename='/var/lib/proxysql/proxysql.log';
SET mysql-eventslog_filesize=104857600;  -- 100MB
SET mysql-eventslog_default_log_level=6; -- INFO级别

-- 配置审计日志
SET mysql-auditlog_filename='/var/lib/proxysql/proxysql_audit.log';
SET mysql-auditlog_filesize=104857600;

-- 应用配置
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

**日志分析脚本**：
```bash
#!/bin/bash
# 分析ProxySQL错误日志

LOG_FILE="/var/lib/proxysql/proxysql.log"

echo "=== 最近1小时的错误统计 ==="
grep -E "ERROR|CRITICAL" $LOG_FILE | \
    grep "$(date '+%Y-%m-%d %H')" | \
    awk '{print $4}' | sort | uniq -c | sort -rn

echo "=== 连接失败统计 ==="  
grep "connection failed" $LOG_FILE | \
    grep "$(date '+%Y-%m-%d')" | wc -l

echo "=== 查询错误统计 ==="
grep "query error" $LOG_FILE | \
    grep "$(date '+%Y-%m-%d')" | wc -l
```

---

## 7. 🎯 路由规则与负载均衡


### 7.1 查询路由规则设计


**路由规则设计原则**：
- **写操作必须到主库**：保证数据一致性
- **读操作优先从库**：减少主库压力
- **特殊查询特殊处理**：如事务内查询、实时性要求高的查询

**完整路由规则配置**：
```sql
-- 清理现有规则
DELETE FROM mysql_query_rules;

-- 1. 事务相关查询（必须主库）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(100, '^BEGIN', 0, 1),
(101, '^START TRANSACTION', 0, 1),
(102, '^COMMIT', 0, 1),
(103, '^ROLLBACK', 0, 1);

-- 2. 写操作（必须主库）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(200, '^INSERT\s+', 0, 1),
(201, '^UPDATE\s+', 0, 1),
(202, '^DELETE\s+', 0, 1),
(203, '^REPLACE\s+', 0, 1),
(204, '^ALTER\s+', 0, 1),
(205, '^CREATE\s+', 0, 1),
(206, '^DROP\s+', 0, 1),
(207, '^TRUNCATE\s+', 0, 1);

-- 3. 特殊SELECT（必须主库）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(300, '^SELECT.*FOR UPDATE', 0, 1),           -- 加锁查询
(301, '^SELECT.*LOCK IN SHARE MODE', 0, 1),   -- 共享锁查询
(302, '^SELECT.*INTO OUTFILE', 0, 1),         -- 导出查询
(303, '^SELECT.*user_session.*', 0, 1),       -- 用户会话查询
(304, '^SELECT.*payment.*', 0, 1);            -- 支付相关查询

-- 4. 普通读操作（从库）
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(400, '^SELECT\s+', 1, 1),                    -- 普通SELECT查询
(401, '^SHOW\s+', 1, 1),                      -- SHOW查询
(402, '^DESCRIBE\s+', 1, 1),                  -- DESCRIBE查询
(403, '^EXPLAIN\s+', 1, 1);                   -- EXPLAIN查询

-- 应用配置
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

### 7.2 负载均衡策略


**权重配置策略**：
```sql
-- 根据服务器性能配置权重
UPDATE mysql_servers SET weight=1000 WHERE hostname='192.168.1.10';  -- 主库
UPDATE mysql_servers SET weight=900 WHERE hostname='192.168.1.11';   -- 从库1（性能好）
UPDATE mysql_servers SET weight=600 WHERE hostname='192.168.1.12';   -- 从库2（性能一般）
UPDATE mysql_servers SET weight=300 WHERE hostname='192.168.1.13';   -- 从库3（备用）

-- 应用配置
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
```

**负载均衡算法说明**：
```
ProxySQL使用加权轮询算法：
- 权重越高，分配的连接越多
- 权重比例 = 服务器权重 / 总权重
- 例如：900/(900+600+300) = 50% 的连接分配给从库1
```

### 7.3 动态路由调整


**根据延迟动态调整权重**：
```sql
-- 创建动态调整脚本
-- /usr/local/bin/dynamic_weight_adjust.sh

#!/bin/bash
PROXYSQL_HOST="127.0.0.1"
PROXYSQL_PORT="6032"
PROXYSQL_USER="admin"
PROXYSQL_PASS="admin"

# 检查复制延迟
check_replication_lag() {
    local hostname=$1
    local lag=$(mysql -h$hostname -e "SHOW SLAVE STATUS\G" | grep "Seconds_Behind_Master" | awk '{print $2}')
    echo ${lag:-0}
}

# 根据延迟调整权重
adjust_weight() {
    local hostname=$1
    local lag=$2
    local new_weight
    
    if [ $lag -le 1 ]; then
        new_weight=900    # 延迟1秒内，正常权重
    elif [ $lag -le 5 ]; then
        new_weight=600    # 延迟1-5秒，降低权重
    elif [ $lag -le 10 ]; then
        new_weight=300    # 延迟5-10秒，大幅降低权重
    else
        new_weight=0      # 延迟超过10秒，停止分配
    fi
    
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
UPDATE mysql_servers SET weight=$new_weight 
WHERE hostname='$hostname' AND hostgroup_id=1;
LOAD MYSQL SERVERS TO RUNTIME;
EOF
}

# 主循环
while true; do
    # 获取所有从库
    slaves=$(mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS \
        -se "SELECT hostname FROM mysql_servers WHERE hostgroup_id=1;")
    
    for slave in $slaves; do
        lag=$(check_replication_lag $slave)
        adjust_weight $slave $lag
        echo "$(date): $slave 延迟 ${lag}秒，权重已调整"
    done
    
    sleep 60  # 每分钟检查一次
done
```

### 7.4 查询路由监控


**路由效果监控**：
```sql
-- 查看路由规则命中统计
SELECT 
    rule_id,
    hits,
    destination_hostgroup,
    match_pattern
FROM stats_mysql_query_rules 
WHERE hits > 0
ORDER BY hits DESC;

-- 查看各hostgroup的查询分布
SELECT 
    hostgroup,
    schemaname,
    username,
    digest_text,
    count_star
FROM stats_mysql_query_digest 
ORDER BY count_star DESC
LIMIT 20;

-- 查看连接分布
SELECT 
    hostgroup,
    srv_host,
    ConnUsed,
    ConnFree,
    Queries
FROM stats_mysql_connection_pool
ORDER BY hostgroup, srv_host;
```

**路由规则优化**：
```sql
-- 分析未命中的查询
SELECT digest_text, count_star 
FROM stats_mysql_query_digest 
WHERE hostgroup = -1  -- -1表示没有匹配到规则
ORDER BY count_star DESC
LIMIT 10;

-- 根据分析结果添加新规则
INSERT INTO mysql_query_rules(rule_id, match_pattern, destination_hostgroup, apply) VALUES
(500, '^SELECT.*COUNT\(\*\).*', 1, 1);  -- 统计查询走从库
```

---

## 8. ⚡ 性能优化策略


### 8.1 连接优化策略


**连接池参数优化**：
```sql
-- 1. 连接数优化
SET mysql-max_connections=4096;                    -- 增加最大连接数
SET mysql-default_max_connections=300;             -- 单个后端服务器连接数
SET mysql-stacksize=1048576;                       -- 增加栈大小

-- 2. 连接复用优化
SET mysql-connection_delay_multiplex_ms=0;         -- 禁用连接复用延迟
SET mysql-connection_max_age_ms=3600000;           -- 连接最大存活1小时
SET mysql-free_connections_pct=10;                 -- 保持10%空闲连接

-- 3. 超时参数优化
SET mysql-connect_timeout_server=1000;             -- 连接超时1秒
SET mysql-ping_timeout_server=200;                 -- ping超时200ms
SET mysql-query_timeout=30000;                     -- 查询超时30秒

-- 4. 认证缓存优化
SET mysql-have_ssl=true;                           -- 启用SSL支持
SET mysql-default_authentication_plugin='mysql_native_password';

-- 应用配置
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

### 8.2 查询缓存优化


**查询缓存配置**：
```sql
-- 启用查询缓存
SET mysql-query_cache_size_MB=256;                 -- 查询缓存256MB
SET mysql-query_cache_timeout=3600;                -- 缓存1小时
SET mysql-query_cache_stores_empty_result=1;       -- 缓存空结果

-- 配置缓存规则
INSERT INTO mysql_query_rules(rule_id, cache_ttl, match_pattern, destination_hostgroup, apply) VALUES
(600, 3600000, '^SELECT.*FROM product.*', 1, 1),   -- 商品查询缓存1小时
(601, 1800000, '^SELECT.*FROM category.*', 1, 1),  -- 分类查询缓存30分钟
(602, 300000, '^SELECT.*FROM config.*', 1, 1);     -- 配置查询缓存5分钟

-- 应用配置
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

**缓存效果监控**：
```sql
-- 查看缓存命中率
SELECT 
    digest_text,
    count_star,
    sum_time,
    cache_hit,
    cache_miss,
    ROUND(cache_hit*100.0/(cache_hit+cache_miss), 2) as cache_hit_rate
FROM stats_mysql_query_digest 
WHERE cache_hit + cache_miss > 0
ORDER BY cache_hit_rate DESC;
```

### 8.3 网络优化策略


**网络参数调优**：
```sql
-- 1. 缓冲区优化
SET mysql-default_charset='utf8mb4';               -- 设置字符集
SET mysql-default_collation_connection='utf8mb4_unicode_ci';
SET mysql-default_sql_mode='TRADITIONAL';

-- 2. 压缩优化
SET mysql-compression_algorithm='zlib';            -- 启用压缩
SET mysql-compression_level=6;                     -- 压缩级别

-- 3. 网络超时优化
SET mysql-poll_timeout=2000;                       -- 轮询超时2秒
SET mysql-poll_timeout_on_failure=100;             -- 失败时轮询超时100ms

-- 4. 数据包优化
SET mysql-threshold_query_length=524288;           -- 长查询阈值512KB
SET mysql-threshold_resultset_size=4194304;        -- 结果集阈值4MB
```

### 8.4 性能监控和分析


**性能分析SQL**：
```sql
-- 1. 查看最耗时的查询
SELECT 
    hostgroup,
    digest_text,
    count_star,
    sum_time/1000000 as total_time_sec,
    ROUND(sum_time/count_star/1000, 2) as avg_time_ms,
    max_time/1000 as max_time_ms
FROM stats_mysql_query_digest 
ORDER BY sum_time DESC 
LIMIT 20;

-- 2. 查看连接池效率
SELECT 
    hostgroup,
    srv_host,
    ConnUsed,
    ConnFree,
    ConnOK,
    ConnERR,
    Queries,
    ROUND(Queries/ConnOK, 2) as queries_per_conn
FROM stats_mysql_connection_pool
WHERE ConnOK > 0
ORDER BY queries_per_conn DESC;

-- 3. 查看内存使用情况
SHOW GLOBAL STATUS LIKE 'query_cache%';
```

**性能优化检查清单**：
```markdown
✅ **连接层面**：
- [ ] 连接池大小合理配置
- [ ] 连接复用率 > 80%
- [ ] 连接错误率 < 1%

✅ **查询层面**：
- [ ] 慢查询比例 < 5%
- [ ] 缓存命中率 > 70%
- [ ] 路由规则覆盖率 > 95%

✅ **网络层面**：
- [ ] 网络延迟 < 1ms
- [ ] 数据包丢失率 < 0.1%
- [ ] 带宽利用率 < 80%

✅ **系统层面**：
- [ ] CPU使用率 < 70%
- [ ] 内存使用率 < 80%
- [ ] 磁盘IO等待 < 10%
```

---

## 9. 🛠️ 故障排查指南


### 9.1 常见故障类型


**故障分类和症状**：
```
1. 连接问题：
   - 症状：应用无法连接ProxySQL
   - 表现：连接超时、连接被拒绝

2. 路由问题：
   - 症状：查询路由到错误的服务器
   - 表现：读取到旧数据、写入失败

3. 性能问题：
   - 症状：查询响应慢
   - 表现：页面加载慢、超时

4. 同步问题：
   - 症状：主从数据不一致
   - 表现：读取数据与写入数据不符
```

### 9.2 故障诊断步骤


**第一步：基础状态检查**：
```bash
# 1. 检查ProxySQL进程状态
ps aux | grep proxysql
netstat -tlnp | grep 6033

# 2. 检查ProxySQL连接
mysql -h127.0.0.1 -P6033 -uapp_user -ppassword -e "SELECT 1;"

# 3. 检查ProxySQL管理接口
mysql -h127.0.0.1 -P6032 -uadmin -padmin -e "SELECT version();"
```

**第二步：服务器状态检查**：
```sql
-- 连接ProxySQL管理接口
mysql -h127.0.0.1 -P6032 -uadmin -padmin

-- 检查后端服务器状态
SELECT hostgroup_id, hostname, port, status, weight, comment 
FROM mysql_servers 
ORDER BY hostgroup_id;

-- 检查连接池状态
SELECT hostgroup, srv_host, ConnUsed, ConnFree, ConnOK, ConnERR
FROM stats_mysql_connection_pool;

-- 检查监控日志
SELECT * FROM monitor.mysql_server_connect_log 
WHERE time_start_us > UNIX_TIMESTAMP(NOW() - INTERVAL 10 MINUTE) * 1000000
ORDER BY time_start_us DESC;
```

### 9.3 具体问题排查


**连接问题排查**：
```sql
-- 1. 检查用户配置
SELECT username, password, default_hostgroup, max_connections 
FROM mysql_users;

-- 2. 检查连接限制
SELECT variable_name, variable_value 
FROM global_variables 
WHERE variable_name LIKE '%connection%';

-- 3. 检查连接错误
SELECT srv_host, ConnERR, last_error 
FROM stats_mysql_connection_pool 
WHERE ConnERR > 0;
```

**路由问题排查**：
```sql
-- 1. 检查路由规则
SELECT rule_id, match_pattern, destination_hostgroup, hits 
FROM mysql_query_rules 
WHERE active=1 
ORDER BY rule_id;

-- 2. 测试路由规则
SELECT * FROM stats_mysql_query_rules 
WHERE hits > 0 
ORDER BY hits DESC;

-- 3. 检查未匹配的查询
SELECT digest_text, count_star 
FROM stats_mysql_query_digest 
WHERE hostgroup = -1;  -- 未匹配到规则的查询
```

**性能问题排查**：
```sql
-- 1. 检查慢查询
SELECT 
    hostgroup,
    digest_text,
    count_star,
    sum_time/1000000 as total_time_sec,
    max_time/1000 as max_time_ms
FROM stats_mysql_query_digest 
WHERE max_time > 1000000  -- 超过1秒
ORDER BY max_time DESC;

-- 2. 检查连接池利用率
SELECT 
    hostgroup,
    srv_host,
    ConnUsed,
    ConnFree,
    ROUND(ConnUsed*100.0/(ConnUsed+ConnFree), 2) as usage_rate
FROM stats_mysql_connection_pool
WHERE ConnUsed + ConnFree > 0;
```

### 9.4 故障处理方案


**应急处理步骤**：
```bash
#!/bin/bash
# 故障应急处理脚本

PROXYSQL_HOST="127.0.0.1"
PROXYSQL_PORT="6032"
PROXYSQL_USER="admin"
PROXYSQL_PASS="admin"

# 1. 快速下线故障服务器
offline_server() {
    local hostname=$1
    local hostgroup=$2
    
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
UPDATE mysql_servers 
SET status='OFFLINE_SOFT' 
WHERE hostname='$hostname' AND hostgroup_id=$hostgroup;
LOAD MYSQL SERVERS TO RUNTIME;
EOF
    echo "服务器 $hostname 已下线"
}

# 2. 重置连接池
reset_connection_pool() {
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
PROXYSQL KILL CONNECTION $hostgroup;
EOF
    echo "连接池已重置"
}

# 3. 重新加载配置
reload_config() {
    mysql -h$PROXYSQL_HOST -P$PROXYSQL_PORT -u$PROXYSQL_USER -p$PROXYSQL_PASS <<EOF
LOAD MYSQL SERVERS FROM DISK;
LOAD MYSQL USERS FROM DISK;
LOAD MYSQL QUERY RULES FROM DISK;
LOAD MYSQL VARIABLES FROM DISK;
LOAD MYSQL SERVERS TO RUNTIME;
LOAD MYSQL USERS TO RUNTIME;
LOAD MYSQL QUERY RULES TO RUNTIME;
LOAD MYSQL VARIABLES TO RUNTIME;
EOF
    echo "配置已重新加载"
}

# 根据参数执行对应操作
case "$1" in
    "offline")
        offline_server $2 $3
        ;;
    "reset")
        reset_connection_pool
        ;;
    "reload")
        reload_config
        ;;
    *)
        echo "用法: $0 {offline|reset|reload} [hostname] [hostgroup]"
        ;;
esac
```

### 9.5 预防性维护


**定期维护检查**：
```bash
#!/bin/bash
# 定期维护脚本

# 1. 清理统计表
mysql -h127.0.0.1 -P6032 -uadmin -padmin <<EOF
-- 清理超过7天的统计数据
DELETE FROM monitor.mysql_server_connect_log 
WHERE time_start_us < UNIX_TIMESTAMP(NOW() - INTERVAL 7 DAY) * 1000000;

DELETE FROM monitor.mysql_server_ping_log 
WHERE time_start_us < UNIX_TIMESTAMP(NOW() - INTERVAL 7 DAY) * 1000000;

-- 重置查询统计
PROXYSQL FLUSH QUERY CACHE;
EOF

# 2. 备份配置
mysqldump -h127.0.0.1 -P6032 -uadmin -padmin \
    --single-transaction --routines --triggers \
    main > /backup/proxysql_config_$(date +%Y%m%d).sql

# 3. 日志轮转
logrotate /etc/logrotate.d/proxysql

echo "定期维护完成: $(date)"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 ProxySQL本质：智能数据库代理，提供统一访问入口
🔸 读写分离：自动路由读写请求到不同服务器组
🔸 连接池：复用数据库连接，提高性能和稳定性
🔸 故障切换：配合MHA实现自动化故障处理
🔸 负载均衡：智能分配请求到多个后端服务器
```

### 10.2 关键配置要点


**🔹 配置管理三层架构**：
```
配置流程：MEMORY → RUNTIME → DISK
- MEMORY：临时修改配置
- RUNTIME：生效的运行配置  
- DISK：持久化保存配置
```

**🔹 读写分离关键配置**：
```
服务器组划分：
- hostgroup_id=0：写组（主库）
- hostgroup_id=1：读组（从库）

路由规则优先级：
1. 事务相关（必须主库）
2. 写操作（必须主库）
3. 特殊SELECT（必须主库）
4. 普通读操作（从库）
```

**🔹 性能优化要点**：
```
连接池优化：
- 合理设置连接数上限
- 启用连接复用
- 配置超时参数

查询优化：
- 启用查询缓存
- 优化路由规则
- 监控慢查询

网络优化：
- 启用压缩
- 调整缓冲区大小
- 优化超时设置
```

### 10.3 运维最佳实践


**🎯 监控要点**：
```
关键指标：
✅ 连接池使用率 < 80%
✅ 查询响应时间 < 100ms
✅ 连接错误率 < 1%
✅ 路由规则覆盖率 > 95%
✅ 缓存命中率 > 70%
```

**🔧 故障处理流程**：
```
1. 立即检查：ProxySQL进程和连接状态
2. 诊断定位：后端服务器状态和连接池
3. 应急处理：下线故障服务器或重置连接池
4. 根因分析：查看日志和监控数据
5. 预防措施：优化配置和完善监控
```

**⚠️ 注意事项**：
```
配置安全：
- 修改默认管理密码
- 限制管理接口访问
- 定期备份配置

数据一致性：
- 写操作必须路由到主库
- 事务内查询保持在同一服务器
- 监控主从复制延迟

高可用设计：
- ProxySQL本身要避免单点故障
- 配合MHA实现自动故障切换
- 建立完善的监控告警体系
```

### 10.4 实际应用价值


**业务价值**：
- **透明化**：应用程序无需修改即可享受读写分离
- **高可用**：自动故障切换，最小化业务中断
- **性能提升**：连接池和负载均衡显著提高性能
- **运维简化**：统一管理入口，降低维护复杂度

**技术价值**：
- **架构解耦**：应用与数据库架构解耦
- **弹性扩展**：便于动态添加删除数据库节点
- **监控集中**：统一的监控和管理视图
- **故障隔离**：单个数据库故障不影响整体服务

**核心记忆口诀**：
- ProxySQL做代理，读写分离要牢记
- 连接池复用高效率，路由规则要合理
- 配合MHA自动切，监控告警不能缺
- 性能优化抓重点，故障处理要及时