---
title: 14、MHA故障切换脚本
---
## 📚 目录

1. [MHA故障切换脚本概述](#1-MHA故障切换脚本概述)
2. [master_ip_failover脚本详解](#2-master_ip_failover脚本详解)
3. [send_report脚本配置](#3-send_report脚本配置)
4. [power_manager脚本实现](#4-power_manager脚本实现)
5. [shutdown_script脚本开发](#5-shutdown_script脚本开发)
6. [脚本权限与调试](#6-脚本权限与调试)
7. [错误处理与测试验证](#7-错误处理与测试验证)
8. [自定义脚本开发](#8-自定义脚本开发)
9. [脚本最佳实践](#9-脚本最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔧 MHA故障切换脚本概述


### 1.1 什么是MHA故障切换脚本


**通俗理解**：MHA故障切换脚本就像是数据库集群的"应急预案"，当主数据库出现故障时，这些脚本会自动执行各种应急操作，确保数据库服务能够快速恢复。

```
简单比喻：
就像火灾时的自动化消防系统
- 检测到火灾 → 自动报警
- 启动灭火装置 → 自动切换IP
- 通知相关人员 → 发送故障报告
- 切断电源保护 → 关闭故障主机
```

### 1.2 MHA脚本的核心作用


**四大核心脚本功能**：

| 脚本名称 | **主要作用** | **执行时机** | **重要程度** |
|---------|-------------|-------------|-------------|
| 🔄 **master_ip_failover** | `IP地址切换` | `故障切换时` | `★★★★★` |
| 📧 **send_report** | `故障通知报告` | `切换完成后` | `★★★★☆` |
| ⚡ **power_manager** | `主机电源管理` | `故障检测时` | `★★★☆☆` |
| 🛑 **shutdown_script** | `安全关闭服务` | `切换开始前` | `★★★★☆` |

### 1.3 脚本执行流程图


```
故障检测
    ↓
执行shutdown_script (可选)
    ↓
数据恢复和同步
    ↓
执行master_ip_failover
    ↓
启动新主库服务
    ↓
执行send_report
    ↓
切换完成
```

---

## 2. 🔄 master_ip_failover脚本详解


### 2.1 脚本作用原理


**核心功能**：实现虚拟IP地址的自动切换，让应用程序无感知地连接到新的主数据库。

> 💡 **通俗解释**：就像手机号码携转，你的号码不变，但是运营商换了。应用程序还是连接同一个IP，但实际指向的数据库服务器已经切换了。

**工作原理**：
```
切换前：
应用 → VIP(192.168.1.100) → 主库A(192.168.1.10)

切换后：
应用 → VIP(192.168.1.100) → 主库B(192.168.1.11)
```

### 2.2 脚本参数详解


**脚本调用格式**：
```bash
master_ip_failover --command=start|stop|stopssh|status \
                  --orig_master_host=主机名 \
                  --orig_master_ip=原主库IP \
                  --new_master_host=主机名 \
                  --new_master_ip=新主库IP
```

**参数含义说明**：

| 参数 | **含义** | **何时使用** |
|------|---------|-------------|
| `start` | 在新主库上启动VIP | 切换完成，启动新主库时 |
| `stop` | 在原主库上停止VIP | 切换开始，停止原主库时 |
| `stopssh` | 通过SSH停止原主库VIP | 原主库无法直接访问时 |
| `status` | 检查VIP状态 | 切换前的状态检查 |

### 2.3 实际脚本示例


```bash
#!/usr/bin/env perl

# master_ip_failover脚本示例
use strict;
use warnings FATAL => 'all';
use Getopt::Long;

# 配置虚拟IP信息
my $vip = '192.168.1.100';          # 虚拟IP地址
my $gateway = '192.168.1.1';        # 网关地址
my $interface = 'eth0';              # 网络接口
my $ssh_user = 'root';               # SSH用户

# 获取命令行参数
my ($command, $orig_master_host, $orig_master_ip, $new_master_host, $new_master_ip);
GetOptions(
    'command=s'          => \$command,
    'orig_master_host=s' => \$orig_master_host,
    'orig_master_ip=s'   => \$orig_master_ip,
    'new_master_host=s'  => \$new_master_host,
    'new_master_ip=s'    => \$new_master_ip,
);

# 根据命令执行相应操作
if ($command eq "stop" || $command eq "stopssh") {
    # 停止原主库上的VIP
    my $exit_code = stop_vip();
    exit $exit_code;
} elsif ($command eq "start") {
    # 在新主库上启动VIP
    my $exit_code = start_vip();
    exit $exit_code;
} elsif ($command eq "status") {
    # 检查VIP状态
    my $exit_code = status_vip();
    exit $exit_code;
}

# 停止VIP的函数
sub stop_vip() {
    print "正在停止VIP $vip...\n";
    my $cmd = "ip addr del $vip/24 dev $interface";
    system($cmd);
    return 0;
}

# 启动VIP的函数
sub start_vip() {
    print "正在启动VIP $vip...\n";
    my $cmd = "ip addr add $vip/24 dev $interface && arping -c 3 -A $vip -I $interface";
    system($cmd);
    return 0;
}

# 检查VIP状态的函数
sub status_vip() {
    my $cmd = "ip addr show $interface | grep $vip";
    my $result = `$cmd`;
    if ($result) {
        print "VIP $vip 已配置\n";
        return 0;
    } else {
        print "VIP $vip 未配置\n";
        return 1;
    }
}
```

### 2.4 脚本关键技术点


**IP切换技术**：
```bash
# 添加VIP到网卡
ip addr add 192.168.1.100/24 dev eth0

# 发送免费ARP通告网络VIP已迁移
arping -c 3 -A 192.168.1.100 -I eth0

# 删除VIP
ip addr del 192.168.1.100/24 dev eth0
```

> ⚠️ **重要提醒**：`arping`命令很关键，它告诉网络中的所有设备"这个IP现在在我这里"，确保网络流量能正确路由到新主库。

---

## 3. 📧 send_report脚本配置


### 3.1 脚本功能说明


**作用**：故障切换完成后，自动发送详细的切换报告，让管理员及时了解切换情况。

> 💡 **通俗理解**：就像医院的手术报告，详细记录了整个"抢救"过程，包括故障原因、处理步骤、最终结果等。

**报告内容包括**：
- 🕐 故障发生时间
- 💥 故障原因分析  
- 🔄 切换执行过程
- ✅ 切换结果状态
- 📊 数据一致性检查
- ⏱️ 服务中断时长

### 3.2 脚本实现示例


```bash
#!/usr/bin/env perl

use strict;
use warnings;
use MIME::Lite;

# 邮件配置
my $smtp_server = 'smtp.company.com';
my $mail_from = 'mha-alert@company.com';
my @mail_to = ('dba@company.com', 'ops@company.com');

# 获取MHA传递的参数
my $orig_master_host = $ARGV[0];    # 原主库主机
my $new_master_host = $ARGV[1];     # 新主库主机  
my $new_master_port = $ARGV[2];     # 新主库端口
my $subject = $ARGV[3];             # 邮件主题

# 构建邮件内容
my $body = build_report_content();

# 发送邮件
send_email($subject, $body);

sub build_report_content {
    my $report = "";
    
    $report .= "=" x 50 . "\n";
    $report .= "MHA 故障切换报告\n";
    $report .= "=" x 50 . "\n\n";
    
    $report .= "切换时间: " . localtime() . "\n";
    $report .= "原主库: $orig_master_host\n";
    $report .= "新主库: $new_master_host:$new_master_port\n\n";
    
    $report .= "切换详情:\n";
    $report .= "- 原主库状态: 故障不可访问\n";
    $report .= "- 数据恢复: 已完成\n";
    $report .= "- VIP切换: 已完成\n";
    $report .= "- 新主库状态: 正常运行\n\n";
    
    $report .= "请验证应用连接和数据一致性！\n";
    
    return $report;
}

sub send_email {
    my ($subject, $body) = @_;
    
    foreach my $to_addr (@mail_to) {
        my $msg = MIME::Lite->new(
            From     => $mail_from,
            To       => $to_addr,
            Subject  => $subject,
            Data     => $body,
        );
        
        $msg->send('smtp', $smtp_server);
        print "邮件已发送到: $to_addr\n";
    }
}
```

### 3.3 高级报告功能


**增强版报告内容**：
```perl
# 添加详细的系统状态检查
sub get_system_status {
    my $status = "";
    
    # 检查新主库状态
    $status .= "新主库连接测试:\n";
    my $mysql_check = `mysql -h$new_master_host -P$new_master_port -e "SELECT 1" 2>&1`;
    if ($? == 0) {
        $status .= "✅ MySQL连接正常\n";
    } else {
        $status .= "❌ MySQL连接异常\n";
    }
    
    # 检查从库状态
    $status .= "\n从库同步状态:\n";
    my @slaves = get_slave_list();
    foreach my $slave (@slaves) {
        my $slave_status = check_slave_status($slave);
        $status .= "- $slave: $slave_status\n";
    }
    
    return $status;
}
```

---

## 4. ⚡ power_manager脚本实现


### 4.1 脚本作用原理


**功能**：通过IPMI、iLO等硬件管理接口，远程控制故障主机的电源，防止"脑裂"现象。

> 💡 **通俗解释**：就像智能插座的远程控制，当检测到主数据库出现问题时，可以远程"拔掉插头"，确保故障机器不会继续对外提供服务，避免数据不一致。

**脑裂现象**：
```
正常情况：
应用 → 主库A (正常工作)
     → 从库B (同步数据)

脑裂情况：
应用 → 主库A (网络断开，但仍在运行)
     → 从库B (被提升为新主库)
     
结果：两个主库同时存在，数据会不一致！
```

### 4.2 IPMI电源管理示例


```bash
#!/bin/bash

# power_manager脚本 - IPMI版本
# 参数: $1=主机名, $2=操作(status|off|on|reset)

ORIG_MASTER_HOST=$1
COMMAND=$2

# IPMI配置信息
IPMI_USER="admin"
IPMI_PASS="password"
IPMI_HOST="${ORIG_MASTER_HOST}-ipmi"  # IPMI管理IP

case $COMMAND in
    status)
        echo "检查 $ORIG_MASTER_HOST 电源状态..."
        ipmitool -I lanplus -H $IPMI_HOST -U $IPMI_USER -P $IPMI_PASS power status
        ;;
    off)
        echo "强制关闭 $ORIG_MASTER_HOST 电源..."
        ipmitool -I lanplus -H $IPMI_HOST -U $IPMI_USER -P $IPMI_PASS power off
        
        # 等待关机完成
        sleep 10
        
        # 验证关机状态
        STATUS=$(ipmitool -I lanplus -H $IPMI_HOST -U $IPMI_USER -P $IPMI_PASS power status)
        if [[ $STATUS == *"off"* ]]; then
            echo "✅ $ORIG_MASTER_HOST 已成功关机"
            exit 0
        else
            echo "❌ $ORIG_MASTER_HOST 关机失败"
            exit 1
        fi
        ;;
    on)
        echo "启动 $ORIG_MASTER_HOST 电源..."
        ipmitool -I lanplus -H $IPMI_HOST -U $IPMI_USER -P $IPMI_PASS power on
        ;;
    reset)
        echo "重启 $ORIG_MASTER_HOST..."
        ipmitool -I lanplus -H $IPMI_HOST -U $IPMI_USER -P $IPMI_PASS power reset
        ;;
    *)
        echo "用法: $0 <主机名> <status|off|on|reset>"
        exit 1
        ;;
esac
```

### 4.3 VMware虚拟机电源管理


```bash
#!/bin/bash

# VMware环境的电源管理脚本
VCENTER_HOST="vcenter.company.com"
VCENTER_USER="administrator@vsphere.local"
VCENTER_PASS="password"
VM_NAME=$1
COMMAND=$2

case $COMMAND in
    off)
        echo "正在关闭虚拟机 $VM_NAME..."
        # 使用govc工具控制VMware虚拟机
        govc vm.power -off -force $VM_NAME
        ;;
    on)
        echo "正在启动虚拟机 $VM_NAME..."
        govc vm.power -on $VM_NAME
        ;;
    status)
        echo "检查虚拟机 $VM_NAME 状态..."
        govc vm.info $VM_NAME | grep "Power state"
        ;;
esac
```

### 4.4 安全注意事项


> ⚠️ **重要安全提醒**：
> 
> - **确认故障**：只有在确认主库真正故障时才执行电源关闭
> - **备份验证**：执行前确保数据已经安全备份或恢复
> - **权限控制**：严格控制电源管理脚本的执行权限
> - **日志记录**：详细记录每次电源操作的日志

---

## 5. 🛑 shutdown_script脚本开发


### 5.1 脚本执行时机


**作用**：在故障切换开始前，优雅地关闭原主库上的MySQL服务和相关进程。

> 💡 **通俗理解**：就像关闭电脑时的"正常关机"流程，先保存数据、关闭程序，最后才断电，避免数据损坏。

**执行时机图**：
```
检测到主库故障
       ↓
执行shutdown_script (如果主库还能访问)
       ↓
等待MySQL服务正常关闭
       ↓
开始数据恢复和切换流程
```

### 5.2 脚本实现示例


```bash
#!/bin/bash

# shutdown_script - MySQL优雅关闭脚本
ORIG_MASTER_HOST=$1
ORIG_MASTER_PORT=${2:-3306}

echo "$(date): 开始执行 MySQL 优雅关闭..."

# MySQL连接配置
MYSQL_USER="mha"
MYSQL_PASS="mha_password"

# 1. 停止新连接
echo "步骤1: 禁用新的数据库连接..."
mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
      -e "SET GLOBAL read_only=1;" 2>/dev/null

# 2. 等待现有连接完成
echo "步骤2: 等待现有连接完成..."
for i in {1..30}; do
    CONN_COUNT=$(mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
                 -e "SHOW PROCESSLIST;" 2>/dev/null | wc -l)
    
    if [ $CONN_COUNT -le 3 ]; then
        echo "活跃连接数: $CONN_COUNT，可以安全关闭"
        break
    fi
    
    echo "等待连接关闭... 当前活跃连接数: $CONN_COUNT"
    sleep 2
done

# 3. 刷新日志
echo "步骤3: 刷新所有日志到磁盘..."
mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
      -e "FLUSH LOGS; FLUSH TABLES WITH READ LOCK;" 2>/dev/null

# 4. 关闭MySQL服务
echo "步骤4: 关闭MySQL服务..."
ssh $ORIG_MASTER_HOST "systemctl stop mysql" 2>/dev/null

# 5. 验证关闭结果
sleep 5
if ! mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
     -e "SELECT 1;" 2>/dev/null; then
    echo "✅ MySQL服务已成功关闭"
    exit 0
else
    echo "❌ MySQL服务关闭失败"
    exit 1
fi
```

### 5.3 增强版关闭脚本


```bash
#!/bin/bash

# 增强版shutdown_script，包含更多安全检查
ORIG_MASTER_HOST=$1
ORIG_MASTER_PORT=${2:-3306}
LOG_FILE="/var/log/mha/shutdown_$(date +%Y%m%d_%H%M%S).log"

# 记录日志函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" | tee -a $LOG_FILE
}

log_message "开始执行MySQL优雅关闭流程"

# 检查MySQL是否还能连接
if ! mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
     -e "SELECT 1;" 2>/dev/null; then
    log_message "MySQL已无法连接，跳过优雅关闭流程"
    exit 0
fi

# 获取当前binlog位置（用于数据恢复参考）
BINLOG_INFO=$(mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
              -e "SHOW MASTER STATUS\G" 2>/dev/null)
log_message "当前binlog位置: $BINLOG_INFO"

# 设置只读模式
log_message "设置数据库为只读模式..."
mysql -h$ORIG_MASTER_HOST -P$ORIG_MASTER_PORT -u$MYSQL_USER -p$MYSQL_PASS \
      -e "SET GLOBAL read_only=1; SET GLOBAL super_read_only=1;" 2>/dev/null

# 等待从库同步完成
log_message "等待从库同步完成..."
sleep 5

# 关闭MySQL
log_message "关闭MySQL服务..."
ssh $ORIG_MASTER_HOST "systemctl stop mysql"

log_message "MySQL优雅关闭流程完成"
```

---

## 6. 🔐 脚本权限与调试


### 6.1 脚本权限设置


**文件权限配置**：
```bash
# 设置脚本执行权限
chmod 755 /usr/local/bin/master_ip_failover
chmod 755 /usr/local/bin/send_report  
chmod 755 /usr/local/bin/power_manager
chmod 755 /usr/local/bin/shutdown_script

# 设置所有者
chown mha:mha /usr/local/bin/master_ip_failover
chown mha:mha /usr/local/bin/send_report
chown mha:mha /usr/local/bin/power_manager
chown mha:mha /usr/local/bin/shutdown_script
```

**用户权限要求**：

| 脚本 | **需要的权限** | **权限说明** |
|------|---------------|-------------|
| `master_ip_failover` | `网络配置权限` | 能够添加/删除IP地址 |
| `send_report` | `邮件发送权限` | 访问SMTP服务器 |
| `power_manager` | `IPMI管理权限` | 硬件电源控制 |
| `shutdown_script` | `MySQL管理权限` | 连接和关闭MySQL |

### 6.2 SSH免密配置


**关键配置**：
```bash
# 在MHA Manager上生成密钥对
ssh-keygen -t rsa -b 2048

# 复制公钥到所有MySQL服务器
ssh-copy-id root@mysql-master1
ssh-copy-id root@mysql-master2  
ssh-copy-id root@mysql-slave1
ssh-copy-id root@mysql-slave2

# 测试SSH免密登录
ssh root@mysql-master1 "hostname"
```

### 6.3 脚本调试方法


**单独测试脚本**：
```bash
# 测试master_ip_failover脚本
/usr/local/bin/master_ip_failover \
  --command=status \
  --orig_master_host=mysql-master1 \
  --orig_master_ip=192.168.1.10 \
  --new_master_host=mysql-master2 \
  --new_master_ip=192.168.1.11

# 测试send_report脚本
/usr/local/bin/send_report \
  mysql-master1 mysql-master2 3306 "MHA测试报告"

# 测试power_manager脚本  
/usr/local/bin/power_manager mysql-master1 status
```

**调试技巧**：
```bash
# 1. 添加调试输出
set -x  # 显示执行的每个命令
echo "DEBUG: 变量值 = $variable"

# 2. 重定向错误输出
command 2>&1 | tee debug.log

# 3. 检查返回值
if [ $? -eq 0 ]; then
    echo "命令执行成功"
else
    echo "命令执行失败，返回值: $?"
fi
```

---

## 7. ❌ 错误处理与测试验证


### 7.1 常见错误类型


**网络相关错误**：
```bash
# VIP添加失败
RTNETLINK answers: File exists
# 解决方案：先检查VIP是否已存在
ip addr show eth0 | grep 192.168.1.100 || ip addr add 192.168.1.100/24 dev eth0

# ARP更新失败  
arping: sendto: Network is unreachable
# 解决方案：检查网络接口和路由配置
```

**权限相关错误**：
```bash
# SSH连接失败
Permission denied (publickey)
# 解决方案：检查SSH密钥配置

# MySQL连接失败
Access denied for user 'mha'@'host'
# 解决方案：检查MySQL用户权限
```

### 7.2 错误处理机制


**脚本容错设计**：
```bash
#!/bin/bash

# 错误处理函数
handle_error() {
    local exit_code=$1
    local error_msg=$2
    
    echo "❌ 错误: $error_msg (退出码: $exit_code)"
    
    # 记录错误日志
    echo "$(date): ERROR - $error_msg" >> /var/log/mha/script_errors.log
    
    # 发送错误通知（可选）
    send_error_notification "$error_msg"
    
    exit $exit_code
}

# 设置错误陷阱
trap 'handle_error $? "脚本在第$LINENO行执行失败"' ERR

# 示例：带错误处理的IP切换
add_vip() {
    local vip=$1
    local interface=$2
    
    # 检查接口是否存在
    if ! ip link show $interface >/dev/null 2>&1; then
        handle_error 1 "网络接口 $interface 不存在"
    fi
    
    # 添加VIP
    if ! ip addr add $vip/24 dev $interface 2>/dev/null; then
        # 检查是否已经存在
        if ip addr show $interface | grep -q $vip; then
            echo "⚠️ VIP $vip 已存在，跳过添加"
        else
            handle_error 1 "添加VIP $vip 失败"
        fi
    fi
    
    # 发送ARP通告
    if ! arping -c 3 -A $vip -I $interface >/dev/null 2>&1; then
        echo "⚠️ ARP通告失败，但VIP已添加"
    fi
    
    echo "✅ VIP $vip 添加成功"
}
```

### 7.3 测试验证方法


**完整测试流程**：

```bash
#!/bin/bash

# MHA脚本测试套件
TEST_LOG="/var/log/mha/test_$(date +%Y%m%d_%H%M%S).log"

test_log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" | tee -a $TEST_LOG
}

# 1. 测试网络配置
test_network() {
    test_log "开始网络配置测试..."
    
    # 测试VIP添加
    if ip addr add 192.168.1.200/24 dev eth0 2>/dev/null; then
        test_log "✅ VIP添加测试通过"
        ip addr del 192.168.1.200/24 dev eth0
    else
        test_log "❌ VIP添加测试失败"
        return 1
    fi
    
    # 测试ARP命令
    if command -v arping >/dev/null 2>&1; then
        test_log "✅ arping命令可用"
    else
        test_log "❌ arping命令不可用，请安装iputils-arping"
        return 1
    fi
}

# 2. 测试MySQL连接
test_mysql() {
    test_log "开始MySQL连接测试..."
    
    local hosts=("mysql-master1" "mysql-master2" "mysql-slave1")
    
    for host in "${hosts[@]}"; do
        if mysql -h$host -umha -pmha_password -e "SELECT 1;" >/dev/null 2>&1; then
            test_log "✅ $host MySQL连接正常"
        else
            test_log "❌ $host MySQL连接失败"
            return 1
        fi
    done
}

# 3. 测试SSH连接
test_ssh() {
    test_log "开始SSH连接测试..."
    
    local hosts=("mysql-master1" "mysql-master2" "mysql-slave1")
    
    for host in "${hosts[@]}"; do
        if ssh -o ConnectTimeout=5 root@$host "hostname" >/dev/null 2>&1; then
            test_log "✅ $host SSH连接正常"
        else
            test_log "❌ $host SSH连接失败"
            return 1
        fi
    done
}

# 4. 测试脚本语法
test_scripts() {
    test_log "开始脚本语法测试..."
    
    local scripts=(
        "/usr/local/bin/master_ip_failover"
        "/usr/local/bin/send_report"
        "/usr/local/bin/power_manager"
        "/usr/local/bin/shutdown_script"
    )
    
    for script in "${scripts[@]}"; do
        if [ -f "$script" ]; then
            if bash -n "$script" 2>/dev/null; then
                test_log "✅ $script 语法检查通过"
            else
                test_log "❌ $script 语法检查失败"
                return 1
            fi
        else
            test_log "⚠️ $script 文件不存在"
        fi
    done
}

# 执行所有测试
main() {
    test_log "=== MHA脚本测试开始 ==="
    
    test_network || exit 1
    test_mysql || exit 1  
    test_ssh || exit 1
    test_scripts || exit 1
    
    test_log "=== 所有测试通过！==="
}

main
```

---

## 8. 🛠️ 自定义脚本开发


### 8.1 脚本开发规范


**编程语言选择**：

| 语言 | **优势** | **适用场景** |
|------|---------|-------------|
| `Bash/Shell` | 简单直接，系统集成好 | 系统命令调用，简单逻辑 |
| `Perl` | MHA原生支持，功能强大 | 复杂文本处理，网络操作 |
| `Python` | 现代化，库丰富 | 复杂业务逻辑，API调用 |

**代码规范要求**：
```bash
#!/bin/bash

# 脚本头部信息
# 文件名: custom_script.sh
# 作用: 自定义MHA处理逻辑
# 作者: DBA团队
# 版本: 1.0
# 更新: 2024-09-11

# 全局配置
set -euo pipefail  # 严格错误处理
export PATH="/usr/local/bin:/usr/bin:/bin"

# 常量定义
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
readonly LOG_FILE="/var/log/mha/${SCRIPT_NAME%.*}.log"

# 通用函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$SCRIPT_NAME] $*" | tee -a "$LOG_FILE"
}

error_exit() {
    log "ERROR: $*" >&2
    exit 1
}
```

### 8.2 高级脚本示例


**智能VIP切换脚本**：
```python
#!/usr/bin/env python3

import sys
import subprocess
import time
import argparse
import logging
from typing import Dict, List

class SmartFailover:
    """智能故障切换脚本"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.logger = self._setup_logging()
    
    def _setup_logging(self):
        """设置日志"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('/var/log/mha/smart_failover.log'),
                logging.StreamHandler()
            ]
        )
        return logging.getLogger(__name__)
    
    def check_network_connectivity(self, target_ip: str) -> bool:
        """检查网络连通性"""
        try:
            result = subprocess.run(
                ['ping', '-c', '3', '-W', '3', target_ip],
                capture_output=True, text=True, timeout=10
            )
            return result.returncode == 0
        except subprocess.TimeoutExpired:
            return False
    
    def get_interface_for_ip(self, ip: str) -> str:
        """自动检测IP对应的网络接口"""
        try:
            result = subprocess.run(
                ['ip', 'route', 'get', ip],
                capture_output=True, text=True, check=True
            )
            
            for line in result.stdout.split('\n'):
                if 'dev' in line:
                    parts = line.split()
                    dev_index = parts.index('dev')
                    if dev_index + 1 < len(parts):
                        return parts[dev_index + 1]
        except subprocess.CalledProcessError:
            pass
        
        return 'eth0'  # 默认接口
    
    def manage_vip(self, action: str, vip: str, interface: str = None) -> bool:
        """管理虚拟IP"""
        if not interface:
            interface = self.get_interface_for_ip(vip)
        
        self.logger.info(f"执行VIP操作: {action} {vip} on {interface}")
        
        try:
            if action == 'add':
                # 检查VIP是否已存在
                check_cmd = ['ip', 'addr', 'show', interface]
                result = subprocess.run(check_cmd, capture_output=True, text=True)
                
                if vip in result.stdout:
                    self.logger.warning(f"VIP {vip} 已存在于 {interface}")
                    return True
                
                # 添加VIP
                add_cmd = ['ip', 'addr', 'add', f'{vip}/24', 'dev', interface]
                subprocess.run(add_cmd, check=True)
                
                # 发送ARP通告
                arp_cmd = ['arping', '-c', '3', '-A', vip, '-I', interface]
                subprocess.run(arp_cmd, capture_output=True)
                
                self.logger.info(f"VIP {vip} 添加成功")
                return True
                
            elif action == 'remove':
                remove_cmd = ['ip', 'addr', 'del', f'{vip}/24', 'dev', interface]
                subprocess.run(remove_cmd, check=True)
                
                self.logger.info(f"VIP {vip} 删除成功")
                return True
                
        except subprocess.CalledProcessError as e:
            self.logger.error(f"VIP操作失败: {e}")
            return False
    
    def failover(self, args) -> int:
        """执行故障切换"""
        command = args.command
        vip = self.config['vip']
        
        if command == 'stop':
            # 停止原主库VIP
            if self.manage_vip('remove', vip):
                return 0
            else:
                return 1
                
        elif command == 'start':
            # 启动新主库VIP
            if self.manage_vip('add', vip):
                # 等待网络收敛
                time.sleep(2)
                
                # 验证VIP可达性
                if self.check_network_connectivity(vip):
                    self.logger.info("VIP切换成功，网络可达")
                    return 0
                else:
                    self.logger.warning("VIP已添加但网络不可达")
                    return 1
            else:
                return 1
                
        elif command == 'status':
            # 检查VIP状态
            interface = self.get_interface_for_ip(vip)
            result = subprocess.run(
                ['ip', 'addr', 'show', interface],
                capture_output=True, text=True
            )
            
            if vip in result.stdout:
                print(f"VIP {vip} 已配置")
                return 0
            else:
                print(f"VIP {vip} 未配置")
                return 1
        
        return 1

def main():
    # 配置参数
    config = {
        'vip': '192.168.1.100',
    }
    
    # 解析命令行参数
    parser = argparse.ArgumentParser(description='智能故障切换脚本')
    parser.add_argument('--command', required=True, 
                       choices=['start', 'stop', 'status'],
                       help='执行的命令')
    parser.add_argument('--orig_master_host', help='原主库主机名')
    parser.add_argument('--orig_master_ip', help='原主库IP')
    parser.add_argument('--new_master_host', help='新主库主机名')
    parser.add_argument('--new_master_ip', help='新主库IP')
    
    args = parser.parse_args()
    
    # 执行故障切换
    failover = SmartFailover(config)
    exit_code = failover.failover(args)
    
    sys.exit(exit_code)

if __name__ == '__main__':
    main()
```

### 8.3 脚本集成技巧


**配置文件外部化**：
```bash
# /etc/mha/scripts.conf
VIP="192.168.1.100"
INTERFACE="eth0"
SMTP_SERVER="smtp.company.com"
MAIL_FROM="mha@company.com"
MAIL_TO="dba@company.com,ops@company.com"
IPMI_USER="admin"
IPMI_PASS="password"

# 在脚本中读取配置
source /etc/mha/scripts.conf
```

**模块化设计**：
```bash
# lib/common.sh - 通用函数库
check_mysql_connection() {
    local host=$1
    local port=$2
    local user=$3
    local pass=$4
    
    mysql -h$host -P$port -u$user -p$pass -e "SELECT 1;" >/dev/null 2>&1
}

send_notification() {
    local subject=$1
    local message=$2
    
    echo "$message" | mail -s "$subject" $MAIL_TO
}

# 在主脚本中引用
source /usr/local/lib/mha/common.sh
```

---

## 9. 📋 脚本最佳实践


### 9.1 安全性最佳实践


**密码管理**：
```bash
# ❌ 错误做法：明文密码
MYSQL_PASS="password123"

# ✅ 正确做法：使用配置文件
source /etc/mha/secure.conf  # 权限600，只有mha用户可读

# ✅ 更好做法：使用MySQL配置文件
mysql --defaults-file=/etc/mha/.my.cnf -e "SELECT 1;"

# .my.cnf内容
[client]
user=mha
password=secure_password
```

**权限最小化原则**：
```bash
# 创建专用的MHA用户
useradd -r -s /bin/bash -d /home/mha mha

# 设置sudo权限，只允许特定命令
# /etc/sudoers.d/mha
mha ALL=(root) NOPASSWD: /sbin/ip, /usr/sbin/arping, /bin/systemctl
```

### 9.2 可维护性最佳实践


**版本控制**：
```bash
#!/bin/bash
# 脚本版本信息
SCRIPT_VERSION="2.1.0"
SCRIPT_AUTHOR="DBA Team"
LAST_UPDATE="2024-09-11"

show_version() {
    cat << EOF
脚本名称: $(basename $0)
版本号: $SCRIPT_VERSION
作者: $SCRIPT_AUTHOR
最后更新: $LAST_UPDATE
EOF
}
```

**日志标准化**：
```bash
# 统一的日志格式
LOG_FORMAT='%(asctime)s [%(levelname)s] %(name)s: %(message)s'

# 日志轮转配置 - /etc/logrotate.d/mha-scripts
/var/log/mha/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    create 644 mha mha
    postrotate
        /bin/kill -HUP $(cat /var/run/rsyslogd.pid 2>/dev/null) 2>/dev/null || true
    endscript
}
```

### 9.3 性能优化最佳实践


**并发控制**：
```bash
# 使用锁文件防止脚本重复执行
LOCK_FILE="/var/run/mha_failover.lock"

acquire_lock() {
    if [ -f "$LOCK_FILE" ]; then
        local pid=$(cat "$LOCK_FILE")
        if ps -p $pid > /dev/null; then
            echo "脚本已在运行 (PID: $pid)"
            exit 1
        else
            echo "发现僵尸锁文件，清理中..."
            rm -f "$LOCK_FILE"
        fi
    fi
    
    echo $$ > "$LOCK_FILE"
}

release_lock() {
    rm -f "$LOCK_FILE"
}

# 设置陷阱确保锁文件被清理
trap release_lock EXIT
```

**超时控制**：
```bash
# 为关键操作设置超时
timeout_execute() {
    local timeout=$1
    local command="$2"
    
    timeout $timeout bash -c "$command"
    local exit_code=$?
    
    if [ $exit_code -eq 124 ]; then
        echo "命令执行超时: $command"
        return 1
    fi
    
    return $exit_code
}

# 使用示例
if timeout_execute 30 "mysql -e 'SELECT 1;'"; then
    echo "MySQL连接正常"
else
    echo "MySQL连接超时或失败"
fi
```

### 9.4 监控与告警最佳实践


**健康检查脚本**：
```bash
#!/bin/bash

# mha_health_check.sh - MHA环境健康检查
check_mha_status() {
    echo "=== MHA服务状态检查 ==="
    
    # 检查MHA Manager进程
    if pgrep -f masterha_manager >/dev/null; then
        echo "✅ MHA Manager 正在运行"
    else
        echo "❌ MHA Manager 未运行"
        return 1
    fi
    
    # 检查配置文件
    if masterha_check_ssh --conf=/etc/mha/app1.cnf; then
        echo "✅ SSH配置正常"
    else
        echo "❌ SSH配置异常"
        return 1
    fi
    
    if masterha_check_repl --conf=/etc/mha/app1.cnf; then
        echo "✅ 复制配置正常"
    else
        echo "❌ 复制配置异常"
        return 1
    fi
    
    # 检查脚本文件
    local scripts=(
        "/usr/local/bin/master_ip_failover"
        "/usr/local/bin/send_report"
    )
    
    for script in "${scripts[@]}"; do
        if [ -x "$script" ]; then
            echo "✅ $script 可执行"
        else
            echo "❌ $script 不可执行或不存在"
            return 1
        fi
    done
    
    echo "=== 所有检查通过 ==="
    return 0
}

# 定期执行健康检查（crontab）
# */5 * * * * /usr/local/bin/mha_health_check.sh || echo "MHA健康检查失败" | mail -s "MHA Alert" dba@company.com
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 故障切换脚本是MHA自动化的关键组件
🔸 master_ip_failover负责VIP切换，确保应用无感知
🔸 send_report提供故障通知，让管理员及时了解情况
🔸 power_manager防止脑裂，确保数据一致性
🔸 shutdown_script实现优雅关闭，保护数据安全
🔸 脚本权限和调试是成功部署的基础
🔸 错误处理和测试验证确保脚本可靠性
🔸 自定义开发满足特殊业务需求
🔸 最佳实践保证脚本的安全性和可维护性
```

### 10.2 关键理解要点


**🔹 脚本的本质作用**
```
故障切换脚本 = 数据库集群的"应急预案"
- 自动化执行复杂的故障处理流程
- 减少人工干预，提高故障恢复速度
- 确保数据安全和服务连续性
```

**🔹 VIP切换的核心原理**
```
虚拟IP(VIP) = 数据库服务的"门牌号"
- 应用程序连接固定的VIP地址
- 故障时VIP自动迁移到新主库
- 实现应用程序无感知的服务切换
```

**🔹 脚本的重要性排序**
```
1. master_ip_failover (★★★★★) - 核心功能，必须实现
2. shutdown_script (★★★★☆) - 数据安全，强烈推荐  
3. send_report (★★★★☆) - 运维监控，建议实现
4. power_manager (★★★☆☆) - 防止脑裂，特定场景需要
```

### 10.3 实际应用指导


**脚本部署顺序**：
1. 🚀 **准备阶段**：配置SSH免密、MySQL权限
2. 🔧 **开发阶段**：编写和测试各个脚本
3. 🛡️ **安全阶段**：设置权限、密码管理
4. ✅ **验证阶段**：全面测试脚本功能
5. 📊 **监控阶段**：部署健康检查和告警

**故障排查思路**：
```
脚本执行失败时的检查顺序：
1. 检查脚本权限和路径
2. 验证SSH连接和MySQL权限
3. 检查网络配置和VIP冲突
4. 查看详细的错误日志
5. 手动执行脚本命令进行调试
```

**性能优化要点**：
- ⚡ **超时控制**：为所有网络操作设置合理超时
- 🔒 **并发控制**：防止脚本重复执行
- 📝 **日志管理**：详细记录但避免日志过大
- 🎯 **错误恢复**：实现智能的错误恢复机制

### 10.4 企业级应用建议


**生产环境要求**：
- 📋 **文档完善**：详细的脚本说明和操作手册
- 🔄 **版本管理**：使用Git管理脚本版本
- 🧪 **测试环境**：在测试环境充分验证
- 👥 **团队培训**：确保团队成员都了解脚本机制
- 📊 **定期审查**：定期检查和更新脚本

**核心记忆要点**：
- MHA脚本是故障切换的自动化实现
- VIP切换让应用无感知故障恢复
- 权限配置和错误处理是脚本可靠性的基础
- 测试验证是脚本成功部署的关键
- 最佳实践确保脚本在生产环境稳定运行