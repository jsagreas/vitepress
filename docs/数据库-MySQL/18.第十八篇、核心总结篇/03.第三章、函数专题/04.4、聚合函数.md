---
title: 4、聚合函数
---
## 📚 目录

1. [聚合函数概述](#1-聚合函数概述)
2. [基础聚合函数](#2-基础聚合函数)
3. [字符串聚合函数](#3-字符串聚合函数)
4. [聚合函数使用技巧](#4-聚合函数使用技巧)
5. [实战应用场景](#5-实战应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📊 聚合函数概述


### 1.1 什么是聚合函数


**🔸 通俗理解**
聚合函数就像是数据的"统计员"，它们能把一大堆数据"合并"成一个结果。比如你有100个学生的成绩，想知道平均分是多少，这时候就需要用聚合函数来帮你计算。

```
原始数据：[85, 92, 78, 90, 88, 76, 94]
聚合结果：平均分 = 86.14
```

### 1.2 聚合函数的特点


**💡 核心特征**
```
多行输入 → 单行输出
例如：1000条销售记录 → 总销售额：￥50万

工作方式：
┌─ 数据行1 ─┐
├─ 数据行2 ─┤
├─ 数据行3 ─┤  →  聚合函数  →  单个结果
├─ 数据行4 ─┤
└─ 数据行5 ─┘
```

**🎯 使用场景**
- **统计分析**：计算总数、平均值、最大最小值
- **报表生成**：汇总数据制作报表
- **数据分析**：从大量数据中提取关键信息

---

## 2. 🔢 基础聚合函数


### 2.1 COUNT函数 - 数据统计员


**🔸 COUNT(*)总行数**

**含义解释**：COUNT(*)就像点名一样，数一数表里一共有多少行数据，不管这行数据是否有空值。

```sql
-- 统计订单表总共有多少条记录
SELECT COUNT(*) AS 总订单数 FROM orders;

-- 结果示例
总订单数
-------
 1523
```

**🔸 COUNT(expr)非空值计数**

**含义解释**：COUNT(列名)比较挑剔，只数那些不是NULL的值，空值会被忽略。

```sql
-- 统计有多少顾客留了电话号码
SELECT COUNT(phone) AS 有电话顾客数 FROM customers;

-- 实际对比
SELECT 
    COUNT(*) AS 总顾客数,
    COUNT(phone) AS 有电话顾客数,
    COUNT(*) - COUNT(phone) AS 没留电话顾客数
FROM customers;
```

**🔸 COUNT(DISTINCT expr)去重计数**

**含义解释**：先把重复的值去掉，再数有多少个不同的值。就像统计班级里有多少个不同的姓氏。

```sql
-- 统计有多少个不同的商品类别
SELECT COUNT(DISTINCT category) AS 商品类别数 FROM products;

-- 对比：总商品数 vs 不同类别数
SELECT 
    COUNT(*) AS 总商品数,
    COUNT(DISTINCT category) AS 不同类别数
FROM products;
```

### 2.2 SUM函数 - 求和计算器


**含义解释**：SUM就是把所有数值加起来，就像计算购物车里所有商品的总价。

```sql
-- 计算本月总销售额
SELECT SUM(amount) AS 本月销售额 FROM orders 
WHERE MONTH(order_date) = MONTH(NOW());

-- 按类别统计销售额
SELECT 
    category AS 商品类别,
    SUM(sales_amount) AS 类别销售额
FROM products 
GROUP BY category;
```

**⚠️ 注意事项**
- SUM只能用于数值类型的列
- 如果所有值都是NULL，SUM返回NULL
- 空值会被自动忽略

### 2.3 AVG函数 - 平均值计算器


**含义解释**：AVG帮你算平均数，就像计算班级平均成绩一样简单。

```sql
-- 计算商品平均价格
SELECT AVG(price) AS 平均价格 FROM products;

-- 按部门计算平均工资
SELECT 
    department AS 部门,
    AVG(salary) AS 平均工资,
    ROUND(AVG(salary), 2) AS 平均工资_保留两位小数
FROM employees 
GROUP BY department;
```

**💡 实用技巧**
```sql
-- 计算高于平均价格的商品数量
SELECT COUNT(*) AS 高价商品数量
FROM products 
WHERE price > (SELECT AVG(price) FROM products);
```

### 2.4 MIN/MAX函数 - 最值查找器


**含义解释**：MIN找最小值，MAX找最大值，就像在一堆数字中找到最高分和最低分。

```sql
-- 找出最贵和最便宜的商品价格
SELECT 
    MIN(price) AS 最低价格,
    MAX(price) AS 最高价格,
    MAX(price) - MIN(price) AS 价格差
FROM products;

-- 找出每个类别的价格范围
SELECT 
    category AS 商品类别,
    MIN(price) AS 最低价,
    MAX(price) AS 最高价
FROM products 
GROUP BY category;
```

**🔍 高级用法**
```sql
-- 找出最新和最早的订单日期
SELECT 
    MIN(order_date) AS 最早订单,
    MAX(order_date) AS 最新订单,
    DATEDIFF(MAX(order_date), MIN(order_date)) AS 业务天数
FROM orders;
```

---

## 3. 🔤 字符串聚合函数


### 3.1 GROUP_CONCAT基础用法


**含义解释**：GROUP_CONCAT就像一个"字符串收集器"，它把同一组的多个文本值合并成一个长字符串，用逗号分隔。

```sql
-- 查看每个顾客都买了哪些商品
SELECT 
    customer_name AS 顾客姓名,
    GROUP_CONCAT(product_name) AS 购买商品列表
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
GROUP BY customer_name;

-- 结果示例
顾客姓名    购买商品列表
-------    ----------------------------------
张三       iPhone13,MacBook,AirPods
李四       iPad,iPhone12,充电器
```

**🎯 实际应用场景**
- **标签管理**：把用户的多个标签合并显示
- **权限列表**：显示用户拥有的所有权限
- **商品属性**：合并显示商品的多个特性

### 3.2 GROUP_CONCAT排序连接


**含义解释**：在合并字符串之前，先把它们按照某个规则排序，让结果更有序。

```sql
-- 按价格从高到低显示顾客购买的商品
SELECT 
    customer_name AS 顾客姓名,
    GROUP_CONCAT(product_name ORDER BY price DESC) AS 商品列表_按价格排序
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
GROUP BY customer_name;

-- 按购买时间排序
SELECT 
    customer_name AS 顾客姓名,
    GROUP_CONCAT(product_name ORDER BY order_date) AS 购买历史
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
GROUP BY customer_name;
```

### 3.3 GROUP_CONCAT指定分隔符


**含义解释**：默认用逗号分隔，但你可以指定任何分隔符，让结果更美观或符合特定格式。

```sql
-- 用分号分隔商品名称
SELECT 
    category AS 商品类别,
    GROUP_CONCAT(product_name SEPARATOR '; ') AS 商品列表
FROM products 
GROUP BY category;

-- 用换行符分隔，适合显示
SELECT 
    department AS 部门,
    GROUP_CONCAT(employee_name SEPARATOR '\n') AS 员工列表
FROM employees 
GROUP BY department;

-- 用特殊符号分隔
SELECT 
    customer_id,
    GROUP_CONCAT(product_name SEPARATOR ' | ') AS 商品清单
FROM orders o
JOIN products p ON o.product_id = p.id
GROUP BY customer_id;
```

**🔧 高级组合用法**
```sql
-- 同时使用排序和自定义分隔符
SELECT 
    category AS 商品类别,
    GROUP_CONCAT(
        CONCAT(product_name, '(¥', price, ')')
        ORDER BY price DESC 
        SEPARATOR ' → '
    ) AS 商品价格列表
FROM products 
GROUP BY category;

-- 结果示例：手机 → iPhone13(¥6999) → 小米11(¥3999) → 红米(¥1299)
```

---

## 4. 🛠️ 聚合函数使用技巧


### 4.1 与GROUP BY配合使用


**含义解释**：GROUP BY就像把数据分成不同的小组，然后聚合函数对每个小组分别计算。

```sql
-- 按部门统计员工信息
SELECT 
    department AS 部门,
    COUNT(*) AS 员工总数,
    AVG(salary) AS 平均工资,
    MIN(salary) AS 最低工资,
    MAX(salary) AS 最高工资,
    SUM(salary) AS 部门工资总额
FROM employees 
GROUP BY department;
```

**📊 数据分组示意图**
```
原始数据：
员工A - 技术部 - 8000
员工B - 技术部 - 9000  
员工C - 销售部 - 6000
员工D - 销售部 - 7000

GROUP BY department后：
技术部组：[员工A-8000, 员工B-9000] → AVG=8500, COUNT=2
销售部组：[员工C-6000, 员工D-7000] → AVG=6500, COUNT=2
```

### 4.2 HAVING条件过滤


**含义解释**：HAVING是专门用来过滤分组后结果的，就像WHERE过滤行数据一样。

```sql
-- 找出平均工资超过8000的部门
SELECT 
    department AS 部门,
    AVG(salary) AS 平均工资,
    COUNT(*) AS 员工数
FROM employees 
GROUP BY department
HAVING AVG(salary) > 8000;

-- WHERE vs HAVING的区别
SELECT 
    category AS 商品类别,
    COUNT(*) AS 商品数量,
    AVG(price) AS 平均价格
FROM products 
WHERE price > 100  -- 先过滤：只看价格>100的商品
GROUP BY category
HAVING COUNT(*) >= 5;  -- 再过滤：只看商品数量>=5的类别
```

### 4.3 聚合函数嵌套使用


```sql
-- 找出销售额最高的商品类别
SELECT category, SUM(sales_amount) as 类别销售额
FROM products 
GROUP BY category
ORDER BY SUM(sales_amount) DESC
LIMIT 1;

-- 计算各部门工资的标准差
SELECT 
    department,
    SQRT(
        AVG(salary * salary) - AVG(salary) * AVG(salary)
    ) AS 工资标准差
FROM employees 
GROUP BY department;
```

---

## 5. 🎯 实战应用场景


### 5.1 销售数据分析


```sql
-- 销售报表：按月统计销售情况
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') AS 月份,
    COUNT(*) AS 订单数量,
    COUNT(DISTINCT customer_id) AS 客户数量,
    SUM(amount) AS 总销售额,
    AVG(amount) AS 平均订单金额,
    GROUP_CONCAT(DISTINCT product_name ORDER BY amount DESC SEPARATOR ', ') AS 热销商品
FROM orders o
JOIN products p ON o.product_id = p.id
WHERE order_date >= '2024-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m')
ORDER BY 月份;
```

### 5.2 用户行为分析


```sql
-- 用户活跃度分析
SELECT 
    customer_name AS 客户姓名,
    COUNT(*) AS 购买次数,
    SUM(amount) AS 消费总额,
    AVG(amount) AS 平均消费,
    MIN(order_date) AS 首次购买,
    MAX(order_date) AS 最近购买,
    DATEDIFF(MAX(order_date), MIN(order_date)) AS 活跃天数,
    GROUP_CONCAT(
        CONCAT(product_name, '×', quantity) 
        ORDER BY order_date 
        SEPARATOR ' → '
    ) AS 购买轨迹
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
GROUP BY customer_id, customer_name
HAVING COUNT(*) >= 3  -- 至少购买3次的客户
ORDER BY 消费总额 DESC;
```

### 5.3 库存统计报告


```sql
-- 库存和销售综合报告
SELECT 
    p.category AS 商品类别,
    COUNT(DISTINCT p.id) AS 商品种类数,
    SUM(p.stock) AS 总库存量,
    AVG(p.price) AS 平均价格,
    COALESCE(SUM(o.quantity), 0) AS 总销量,
    COALESCE(SUM(o.amount), 0) AS 总销售额,
    GROUP_CONCAT(
        CASE 
            WHEN p.stock < 10 THEN CONCAT(p.product_name, '(库存不足)')
            ELSE NULL 
        END
        SEPARATOR ', '
    ) AS 库存预警商品
FROM products p
LEFT JOIN orders o ON p.id = o.product_id
GROUP BY p.category
ORDER BY 总销售额 DESC;
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 聚合函数本质：多行数据 → 单个结果
🔸 基础统计：COUNT计数、SUM求和、AVG平均、MIN/MAX最值
🔸 字符串聚合：GROUP_CONCAT合并文本，支持排序和自定义分隔符
🔸 分组统计：GROUP BY分组 + 聚合函数 = 分类统计
🔸 条件过滤：HAVING过滤分组结果，WHERE过滤原始数据
```

### 6.2 关键理解要点


**🔹 COUNT函数的三种形式**
```
COUNT(*) → 数所有行（包括NULL）
COUNT(列名) → 数非空值
COUNT(DISTINCT 列名) → 数不重复的非空值

实际应用：
总用户数：COUNT(*)
活跃用户数：COUNT(last_login_date)  
不同城市数：COUNT(DISTINCT city)
```

**🔹 GROUP_CONCAT的强大之处**
```
基础用法：合并字符串
排序用法：按特定顺序合并
分隔符：自定义显示格式

实际应用：
商品标签：GROUP_CONCAT(tag)
购买历史：GROUP_CONCAT(product ORDER BY date)
权限列表：GROUP_CONCAT(permission SEPARATOR '; ')
```

**🔹 GROUP BY + HAVING 组合拳**
```
执行顺序：
1. WHERE过滤原始数据
2. GROUP BY分组
3. 聚合函数计算
4. HAVING过滤分组结果
5. ORDER BY排序

记忆口诀：先筛选，再分组，算结果，后过滤
```

### 6.3 实际应用指导


**✅ 适用场景**
- **数据统计**：销售报表、用户分析、库存统计
- **业务分析**：趋势分析、排行榜、汇总报告
- **数据清洗**：去重统计、数据质量检查

**⚠️ 注意事项**
- NULL值处理：大部分聚合函数忽略NULL
- 性能考虑：大数据量时注意索引优化
- 结果验证：聚合结果要与业务逻辑一致

**🎯 最佳实践**
```sql
-- 1. 给聚合结果起有意义的别名
SELECT COUNT(*) AS 总订单数, SUM(amount) AS 总销售额

-- 2. 合理使用DISTINCT避免重复计算
SELECT COUNT(DISTINCT customer_id) AS 活跃客户数

-- 3. 结合CASE WHEN实现条件统计
SELECT 
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS 已完成订单,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) AS 待处理订单

-- 4. 使用COALESCE处理NULL值
SELECT COALESCE(SUM(amount), 0) AS 销售额  -- NULL时返回0
```

**💡 记忆口诀**
```
聚合函数好理解，多行数据变一个
COUNT数量SUM求和，AVG平均MIN/MAX找
GROUP_CONCAT串联接，ORDER排序SEP分隔
GROUP BY来分组，HAVING过滤很重要
```