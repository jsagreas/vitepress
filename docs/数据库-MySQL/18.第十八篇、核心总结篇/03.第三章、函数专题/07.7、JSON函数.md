---
title: 7、JSON函数
---
## 📚 目录

1. [JSON函数概述](#1-JSON函数概述)
2. [JSON基础操作](#2-JSON基础操作)
3. [JSON查询函数](#3-JSON查询函数)
4. [JSON修改函数](#4-JSON修改函数)
5. [JSON函数实践应用](#5-JSON函数实践应用)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 JSON函数概述


### 1.1 什么是JSON函数


**📋 基本概念**
JSON函数是MySQL 5.7版本引入的一套专门处理JSON数据的内置函数。JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，在现代Web开发中广泛使用。

**🎯 为什么需要JSON函数**
```
传统关系型数据库的局限：
- 只能存储结构化数据
- 表结构固定，扩展困难
- 处理半结构化数据复杂

JSON数据的优势：
- 灵活的数据结构
- 易于扩展和修改
- 符合现代应用需求
```

**💡 JSON在MySQL中的地位**
```
数据存储方式对比：

传统方式：
用户表: id, name, email
地址表: user_id, province, city, street

JSON方式：
用户表: id, name, email, address(JSON)
{
  "province": "北京市",
  "city": "海淀区", 
  "street": "中关村大街1号"
}
```

### 1.2 JSON数据类型基础


**🔸 JSON数据格式**
```sql
-- JSON对象格式
{"name": "张三", "age": 25, "married": false}

-- JSON数组格式  
[1, 2, 3, "hello", true]

-- 复杂嵌套格式
{
  "user": {
    "name": "李四",
    "hobbies": ["reading", "swimming"],
    "address": {
      "city": "上海",
      "district": "浦东新区"
    }
  }
}
```

**⚠️ JSON数据特点**
- **大小写敏感**：`{"Name": "张三"}` 和 `{"name": "张三"}` 是不同的
- **双引号必需**：键名必须用双引号包围
- **数据类型丰富**：支持字符串、数字、布尔值、null、对象、数组

---

## 2. 🛠️ JSON基础操作


### 2.1 JSON_ARRAY - 创建JSON数组


**📝 基本语法**
```sql
JSON_ARRAY([value1, value2, ...])
```

**💡 作用和含义**
`JSON_ARRAY`函数用于将多个值组合成一个JSON数组。就像把多个物品装进一个盒子里，这个盒子就是JSON数组。

**🔧 基础使用示例**
```sql
-- 创建简单数组
SELECT JSON_ARRAY(1, 2, 3, 4) AS numbers;
-- 结果: [1, 2, 3, 4]

-- 创建混合类型数组  
SELECT JSON_ARRAY('张三', 25, true, null) AS mixed_array;
-- 结果: ["张三", 25, true, null]

-- 创建空数组
SELECT JSON_ARRAY() AS empty_array;
-- 结果: []
```

**🎯 实际应用场景**
```sql
-- 存储用户的兴趣爱好
INSERT INTO users (name, hobbies) 
VALUES ('王五', JSON_ARRAY('篮球', '游泳', '阅读'));

-- 存储商品的标签
UPDATE products 
SET tags = JSON_ARRAY('热销', '新品', '限时优惠') 
WHERE product_id = 1;
```

### 2.2 JSON_OBJECT - 创建JSON对象


**📝 基本语法**
```sql
JSON_OBJECT(key1, value1, key2, value2, ...)
```

**💡 作用和含义**
`JSON_OBJECT`函数用于创建JSON对象，类似于创建一个带标签的储物柜，每个标签（key）对应一个物品（value）。

**🔧 基础使用示例**
```sql
-- 创建用户信息对象
SELECT JSON_OBJECT(
  'name', '赵六',
  'age', 28,
  'city', '深圳'
) AS user_info;
-- 结果: {"age": 28, "city": "深圳", "name": "赵六"}

-- 创建嵌套对象
SELECT JSON_OBJECT(
  'user', JSON_OBJECT('name', '钱七', 'age', 30),
  'scores', JSON_ARRAY(85, 92, 78)
) AS complex_object;
```

**🎯 实际应用场景**
```sql
-- 存储订单详情
INSERT INTO orders (order_no, details) 
VALUES ('ORD001', JSON_OBJECT(
  'total_amount', 299.50,
  'items_count', 3,
  'shipping_fee', 15.00,
  'discount', 30.00
));

-- 更新产品配置信息
UPDATE products 
SET config = JSON_OBJECT(
  'color', '红色',
  'size', 'XL', 
  'material', '纯棉'
)
WHERE product_id = 100;
```

### 2.3 JSON_VALID - 验证JSON格式


**📝 基本语法**
```sql
JSON_VALID(json_text)
```

**💡 作用和含义**
`JSON_VALID`函数用于检查一个字符串是否是有效的JSON格式。就像检查员检查包裹是否符合标准一样，返回1表示有效，返回0表示无效。

**🔧 基础使用示例**
```sql
-- 检查有效的JSON
SELECT JSON_VALID('{"name": "测试", "age": 25}') AS is_valid;
-- 结果: 1

-- 检查无效的JSON（缺少引号）
SELECT JSON_VALID('{name: "测试", age: 25}') AS is_valid;
-- 结果: 0

-- 检查数组格式
SELECT JSON_VALID('[1, 2, 3]') AS is_valid;
-- 结果: 1

-- 检查普通字符串
SELECT JSON_VALID('hello world') AS is_valid;
-- 结果: 0
```

**🎯 实际应用场景**
```sql
-- 数据导入前验证
SELECT 
  import_data,
  JSON_VALID(import_data) AS is_json_valid
FROM temp_import_table
WHERE JSON_VALID(import_data) = 0;  -- 找出无效数据

-- 约束条件中使用
ALTER TABLE config_table 
ADD CONSTRAINT check_json_format 
CHECK (JSON_VALID(json_config) = 1);
```

---

## 3. 🔍 JSON查询函数


### 3.1 JSON_EXTRACT - 提取JSON值


**📝 基本语法**
```sql
JSON_EXTRACT(json_doc, path)
```

**💡 作用和含义**
`JSON_EXTRACT`函数用于从JSON文档中提取指定路径的值。就像使用地址找到特定的房间一样，path参数就是"地址"，用来定位JSON中的具体数据。

**🗂️ JSON路径语法说明**
```
路径语法规则：

$ - 根节点
.key - 对象的键
[index] - 数组的索引（从0开始）
.* - 所有成员
[*] - 所有元素

路径示例：
$.name          - 根级别的name字段
$.user.age      - user对象的age字段  
$.hobbies[0]    - hobbies数组的第一个元素
$.addresses[*]  - addresses数组的所有元素
```

**🔧 基础使用示例**
```sql
-- 创建测试数据
SET @json_doc = '{
  "name": "张三",
  "age": 25,
  "hobbies": ["篮球", "游泳", "阅读"],
  "address": {
    "city": "北京",
    "district": "海淀区"
  }
}';

-- 提取简单字段
SELECT JSON_EXTRACT(@json_doc, '$.name') AS name;
-- 结果: "张三"

-- 提取嵌套对象
SELECT JSON_EXTRACT(@json_doc, '$.address.city') AS city;
-- 结果: "北京"

-- 提取数组元素
SELECT JSON_EXTRACT(@json_doc, '$.hobbies[0]') AS first_hobby;
-- 结果: "篮球"

-- 提取整个数组
SELECT JSON_EXTRACT(@json_doc, '$.hobbies') AS all_hobbies;
-- 结果: ["篮球", "游泳", "阅读"]
```

**🎯 实际应用场景**
```sql
-- 查询特定城市的用户
SELECT user_id, name 
FROM users 
WHERE JSON_EXTRACT(profile, '$.address.city') = '上海';

-- 统计不同年龄段的用户数量
SELECT 
  CASE 
    WHEN JSON_EXTRACT(profile, '$.age') < 25 THEN '青年'
    WHEN JSON_EXTRACT(profile, '$.age') < 35 THEN '青壮年'
    ELSE '中年'
  END AS age_group,
  COUNT(*) AS user_count
FROM users
GROUP BY age_group;
```

### 3.2 JSON提取操作符（-> 和 ->>）


**📝 基本语法**
```sql
column -> path    -- 提取JSON值（保留引号）
column ->> path   -- 提取JSON值（去除引号）
```

**💡 作用和含义**
这两个操作符是`JSON_EXTRACT`的简化写法：
- `->` 操作符相当于`JSON_EXTRACT`，会保留字符串值的引号
- `->>` 操作符会去除字符串值的引号，返回纯文本

**🔧 基础使用示例**
```sql
-- 使用 -> 操作符（保留引号）
SELECT 
  name,
  profile -> '$.age' AS age_with_quotes,
  profile -> '$.address.city' AS city_with_quotes
FROM users;
-- age_with_quotes: 25 (数字不带引号)
-- city_with_quotes: "北京" (字符串带引号)

-- 使用 ->> 操作符（去除引号）  
SELECT 
  name,
  profile ->> '$.age' AS age_clean,
  profile ->> '$.address.city' AS city_clean
FROM users;
-- age_clean: 25
-- city_clean: 北京 (字符串不带引号)
```

**🔍 两种操作符的区别对比**
```sql
SET @json_data = '{"name": "李四", "score": 85.5, "active": true}';

-- 对比差异
SELECT 
  JSON_EXTRACT(@json_data, '$.name') AS extract_result,
  @json_data -> '$.name' AS arrow_result,
  @json_data ->> '$.name' AS double_arrow_result;

-- 结果对比：
-- extract_result: "李四"     (带引号)
-- arrow_result: "李四"       (带引号) 
-- double_arrow_result: 李四   (不带引号)
```

**🎯 实际应用场景**
```sql
-- WHERE条件中使用（推荐使用 ->>）
SELECT * FROM products 
WHERE price_info ->> '$.currency' = 'CNY';

-- 排序中使用
SELECT name, score_info ->> '$.total' AS total_score
FROM students 
ORDER BY CAST(score_info ->> '$.total' AS DECIMAL(5,2)) DESC;

-- 与其他函数结合使用
SELECT 
  name,
  UPPER(profile ->> '$.address.city') AS city_upper
FROM users;
```

### 3.3 JSON_KEYS - 获取所有键


**📝 基本语法**
```sql
JSON_KEYS(json_doc [, path])
```

**💡 作用和含义**
`JSON_KEYS`函数用于获取JSON对象中所有的键名，就像获取一个储物柜里所有标签的列表。如果指定了path参数，则获取指定路径下对象的所有键。

**🔧 基础使用示例**
```sql
-- 获取根级别的所有键
SET @user_data = '{
  "name": "王五", 
  "age": 30, 
  "email": "wangwu@example.com",
  "address": {"city": "广州", "district": "天河区"}
}';

SELECT JSON_KEYS(@user_data) AS root_keys;
-- 结果: ["age", "name", "email", "address"]

-- 获取嵌套对象的键
SELECT JSON_KEYS(@user_data, '$.address') AS address_keys;
-- 结果: ["city", "district"]

-- 处理数组（返回NULL）
SET @array_data = '["apple", "banana", "orange"]';
SELECT JSON_KEYS(@array_data) AS array_keys;
-- 结果: NULL (数组没有键，只有索引)
```

**🎯 实际应用场景**
```sql
-- 分析JSON数据结构
SELECT 
  user_id,
  JSON_KEYS(profile) AS profile_fields
FROM users 
LIMIT 5;

-- 检查必需字段是否存在
SELECT user_id, name
FROM users 
WHERE JSON_CONTAINS(JSON_KEYS(profile), '"email"') = 0;  -- 缺少email字段的用户

-- 统计不同配置项的使用情况
SELECT 
  JSON_UNQUOTE(JSON_EXTRACT(keys_data.key_name, '$')) AS config_key,
  COUNT(*) AS usage_count
FROM (
  SELECT JSON_KEYS(config) AS all_keys FROM products
) AS config_data
CROSS JOIN JSON_TABLE(
  config_data.all_keys, 
  '$[*]' COLUMNS (key_name JSON PATH '$')
) AS keys_data
GROUP BY config_key;
```

### 3.4 JSON_LENGTH - 获取长度


**📝 基本语法**
```sql
JSON_LENGTH(json_doc [, path])
```

**💡 作用和含义**
`JSON_LENGTH`函数用于获取JSON值的长度：
- 对于JSON对象：返回键值对的数量
- 对于JSON数组：返回元素的数量  
- 对于标量值：返回1
- 对于NULL：返回NULL

**🔧 基础使用示例**
```sql
-- JSON对象的长度
SET @obj_data = '{"name": "张三", "age": 25, "city": "北京"}';
SELECT JSON_LENGTH(@obj_data) AS object_length;
-- 结果: 3 (3个键值对)

-- JSON数组的长度
SET @array_data = '["apple", "banana", "orange", "grape"]';
SELECT JSON_LENGTH(@array_data) AS array_length;
-- 结果: 4 (4个元素)

-- 嵌套对象的长度
SET @nested_data = '{
  "user": {"name": "李四", "age": 28},
  "hobbies": ["reading", "swimming", "cooking"],
  "active": true
}';

SELECT 
  JSON_LENGTH(@nested_data) AS root_length,
  JSON_LENGTH(@nested_data, '$.user') AS user_length,
  JSON_LENGTH(@nested_data, '$.hobbies') AS hobbies_length;
-- 结果: 3, 2, 3

-- 标量值的长度
SELECT JSON_LENGTH('"hello"') AS string_length;
-- 结果: 1

SELECT JSON_LENGTH('42') AS number_length;
-- 结果: 1
```

**🎯 实际应用场景**
```sql
-- 查找拥有特定数量兴趣爱好的用户
SELECT user_id, name
FROM users 
WHERE JSON_LENGTH(profile, '$.hobbies') >= 3;

-- 统计购物车商品数量
SELECT 
  user_id,
  JSON_LENGTH(cart_items) AS items_count,
  CASE 
    WHEN JSON_LENGTH(cart_items) = 0 THEN '空购物车'
    WHEN JSON_LENGTH(cart_items) <= 3 THEN '少量商品'
    WHEN JSON_LENGTH(cart_items) <= 10 THEN '适中商品'
    ELSE '大量商品'
  END AS cart_status
FROM shopping_carts;

-- 验证数据完整性
SELECT order_id
FROM orders 
WHERE JSON_LENGTH(order_details) = 0  -- 找出没有详情的订单
   OR JSON_LENGTH(order_details) IS NULL;
```

---

## 4. ✏️ JSON修改函数


### 4.1 JSON_SET - 设置JSON值


**📝 基本语法**
```sql
JSON_SET(json_doc, path, val [, path, val] ...)
```

**💡 作用和含义**
`JSON_SET`函数用于设置JSON文档中指定路径的值。它具有"万能"特性：
- 如果路径存在，则**更新**该值
- 如果路径不存在，则**创建**该路径和值
- 可以同时设置多个路径

**🔧 基础使用示例**
```sql
-- 基础数据
SET @user_json = '{"name": "张三", "age": 25, "city": "北京"}';

-- 更新已存在的字段
SELECT JSON_SET(@user_json, '$.age', 26) AS updated_age;
-- 结果: {"age": 26, "city": "北京", "name": "张三"}

-- 添加新字段
SELECT JSON_SET(@user_json, '$.email', 'zhangsan@example.com') AS added_email;
-- 结果: {"age": 25, "city": "北京", "email": "zhangsan@example.com", "name": "张三"}

-- 同时设置多个值
SELECT JSON_SET(
  @user_json, 
  '$.age', 27,
  '$.phone', '13800138000',
  '$.married', true
) AS multiple_updates;

-- 设置嵌套对象
SELECT JSON_SET(
  @user_json, 
  '$.address', JSON_OBJECT('province', '北京市', 'district', '海淀区')
) AS nested_object;
```

**🎯 实际应用场景**
```sql
-- 更新用户资料
UPDATE users 
SET profile = JSON_SET(
  profile,
  '$.last_login', NOW(),
  '$.login_count', COALESCE(profile ->> '$.login_count', 0) + 1
)
WHERE user_id = 123;

-- 添加商品新属性
UPDATE products 
SET attributes = JSON_SET(
  COALESCE(attributes, '{}'),  -- 如果attributes为NULL，使用空对象
  '$.promotion', true,
  '$.discount_rate', 0.15
)
WHERE category = 'electronics';

-- 批量更新配置
UPDATE system_config 
SET config_data = JSON_SET(
  config_data,
  '$.version', '2.1.0',
  '$.last_updated', NOW(),
  '$.features.dark_mode', true
);
```

### 4.2 JSON_INSERT - 插入JSON值


**📝 基本语法**
```sql
JSON_INSERT(json_doc, path, val [, path, val] ...)
```

**💡 作用和含义**
`JSON_INSERT`函数用于向JSON文档中插入新值，但有一个重要特点：
- 如果路径**不存在**，则**插入**新值
- 如果路径**已存在**，则**不做任何操作**（保持原值不变）

这就像"只添加不覆盖"的安全模式。

**🔧 基础使用示例**
```sql
SET @base_json = '{"name": "李四", "age": 30}';

-- 插入新字段（成功）
SELECT JSON_INSERT(@base_json, '$.email', 'lisi@example.com') AS inserted_new;
-- 结果: {"age": 30, "email": "lisi@example.com", "name": "李四"}

-- 尝试插入已存在的字段（无效果）
SELECT JSON_INSERT(@base_json, '$.age', 35) AS insert_existing;
-- 结果: {"age": 30, "name": "李四"} (age仍然是30，没有变化)

-- 混合操作：部分成功，部分失败
SELECT JSON_INSERT(
  @base_json,
  '$.age', 35,           -- 已存在，不会插入
  '$.phone', '13900139000', -- 不存在，会插入
  '$.address', '上海'     -- 不存在，会插入
) AS mixed_insert;
-- 结果: {"age": 30, "address": "上海", "name": "李四", "phone": "13900139000"}
```

**🔍 JSON_INSERT vs JSON_SET 对比**
```sql
SET @demo_json = '{"name": "王五", "score": 85}';

-- JSON_SET：总是设置值（更新或创建）
SELECT 
  JSON_SET(@demo_json, '$.score', 95) AS set_existing,    -- 更新已存在
  JSON_SET(@demo_json, '$.grade', 'A') AS set_new;       -- 创建新的

-- JSON_INSERT：只插入不存在的值
SELECT 
  JSON_INSERT(@demo_json, '$.score', 95) AS insert_existing,  -- 忽略已存在
  JSON_INSERT(@demo_json, '$.grade', 'A') AS insert_new;     -- 插入新的
```

**🎯 实际应用场景**
```sql
-- 初始化用户默认设置（不覆盖已有设置）
UPDATE users 
SET preferences = JSON_INSERT(
  COALESCE(preferences, '{}'),
  '$.theme', 'light',
  '$.language', 'zh-CN',
  '$.notifications', true,
  '$.auto_save', true
)
WHERE preferences IS NULL OR JSON_LENGTH(preferences) = 0;

-- 为商品添加默认属性（避免覆盖现有配置）
UPDATE products 
SET metadata = JSON_INSERT(
  COALESCE(metadata, '{}'),
  '$.created_date', NOW(),
  '$.version', '1.0',
  '$.tags', JSON_ARRAY()
)
WHERE product_id IN (SELECT id FROM new_products);
```

### 4.3 JSON_REPLACE - 替换JSON值


**📝 基本语法**
```sql
JSON_REPLACE(json_doc, path, val [, path, val] ...)
```

**💡 作用和含义**
`JSON_REPLACE`函数用于替换JSON文档中已存在的值：
- 如果路径**存在**，则**替换**该值
- 如果路径**不存在**，则**不做任何操作**

这是一个"只改不增"的安全更新模式。

**🔧 基础使用示例**
```sql
SET @product_json = '{
  "name": "iPhone 14",
  "price": 5999,
  "color": "白色",
  "storage": "128GB"
}';

-- 替换已存在的字段（成功）
SELECT JSON_REPLACE(@product_json, '$.price', 5499) AS updated_price;
-- 结果: {"color": "白色", "name": "iPhone 14", "price": 5499, "storage": "128GB"}

-- 尝试替换不存在的字段（无效果）
SELECT JSON_REPLACE(@product_json, '$.warranty', '2年') AS add_warranty;
-- 结果: {"color": "白色", "name": "iPhone 14", "price": 5999, "storage": "128GB"} (没有变化)

-- 批量替换
SELECT JSON_REPLACE(
  @product_json,
  '$.price', 5299,
  '$.color', '黑色',
  '$.brand', 'Apple'  -- 不存在，不会添加
) AS batch_replace;
```

**🔍 三种修改函数的对比总结**
```sql
SET @test_json = '{"name": "测试", "age": 25}';

-- 对比三种函数的行为
SELECT 
  '原始数据' AS operation,
  @test_json AS result
UNION ALL
SELECT 
  'JSON_SET' AS operation,
  JSON_SET(@test_json, '$.age', 30, '$.city', '北京') AS result
UNION ALL  
SELECT 
  'JSON_INSERT' AS operation,
  JSON_INSERT(@test_json, '$.age', 30, '$.city', '北京') AS result
UNION ALL
SELECT 
  'JSON_REPLACE' AS operation,
  JSON_REPLACE(@test_json, '$.age', 30, '$.city', '北京') AS result;

/*
结果对比：
原始数据:    {"age": 25, "name": "测试"}
JSON_SET:    {"age": 30, "city": "北京", "name": "测试"}     -- 全部操作
JSON_INSERT: {"age": 25, "city": "北京", "name": "测试"}     -- 只插入新的
JSON_REPLACE:{"age": 30, "name": "测试"}                   -- 只替换存在的
*/
```

**🎯 实际应用场景**
```sql
-- 更新产品价格（只更新已有产品，不添加新字段）
UPDATE products 
SET price_info = JSON_REPLACE(
  price_info,
  '$.regular_price', new_price,
  '$.updated_date', NOW()
)
WHERE price_info IS NOT NULL;

-- 修正用户信息中的错误数据
UPDATE users 
SET profile = JSON_REPLACE(
  profile,
  '$.phone', REGEXP_REPLACE(profile ->> '$.phone', '[^0-9]', ''),  -- 清理电话号码
  '$.email', LOWER(profile ->> '$.email')  -- 邮箱转小写
)
WHERE profile ->> '$.phone' IS NOT NULL;
```

### 4.4 JSON_REMOVE - 删除JSON值


**📝 基本语法**
```sql
JSON_REMOVE(json_doc, path [, path] ...)
```

**💡 作用和含义**
`JSON_REMOVE`函数用于从JSON文档中删除指定路径的值：
- 删除指定的键值对（对象）或元素（数组）
- 如果路径不存在，不会报错，直接返回原JSON
- 可以同时删除多个路径
- 删除后会重新整理JSON结构

**🔧 基础使用示例**
```sql
SET @user_data = '{
  "name": "赵六",
  "age": 28,
  "email": "zhaoliu@example.com",
  "temp_token": "abc123",
  "debug_info": {"last_action": "login", "ip": "192.168.1.1"}
}';

-- 删除单个字段
SELECT JSON_REMOVE(@user_data, '$.temp_token') AS removed_token;
-- 结果: {"age": 28, "debug_info": {"ip": "192.168.1.1", "last_action": "login"}, "email": "zhaoliu@example.com", "name": "赵六"}

-- 删除多个字段
SELECT JSON_REMOVE(@user_data, '$.temp_token', '$.debug_info') AS cleaned_data;
-- 结果: {"age": 28, "email": "zhaoliu@example.com", "name": "赵六"}

-- 删除嵌套字段
SELECT JSON_REMOVE(@user_data, '$.debug_info.ip') AS removed_nested;
-- 结果: debug_info对象中只保留last_action字段

-- 删除不存在的字段（不会报错）
SELECT JSON_REMOVE(@user_data, '$.nonexistent') AS no_change;
-- 结果: 返回原始JSON，没有变化
```

**🔧 数组删除示例**
```sql
SET @hobbies_data = '{
  "name": "小明",
  "hobbies": ["篮球", "游泳", "阅读", "旅游", "摄影"]
}';

-- 删除数组中的特定元素（按索引）
SELECT JSON_REMOVE(@hobbies_data, '$.hobbies[1]') AS removed_hobby;
-- 结果: hobbies变为["篮球", "阅读", "旅游", "摄影"] (删除了"游泳")

-- 删除多个数组元素（注意索引变化）
SELECT JSON_REMOVE(@hobbies_data, '$.hobbies[4]', '$.hobbies[1]') AS removed_multiple;
-- 注意：删除时从后往前删，避免索引变化影响

-- 删除整个数组
SELECT JSON_REMOVE(@hobbies_data, '$.hobbies') AS removed_array;
-- 结果: {"name": "小明"}
```

**⚠️ 数组删除的注意事项**
```sql
-- 错误方式：同时删除相邻元素
SET @array_json = '{"items": ["a", "b", "c", "d", "e"]}';

-- 问题：删除items[1]后，原来的items[2]变成了items[1]
SELECT JSON_REMOVE(@array_json, '$.items[1]', '$.items[2]') AS wrong_way;

-- 正确方式：从后往前删除
SELECT JSON_REMOVE(@array_json, '$.items[2]', '$.items[1]') AS right_way;
```

**🎯 实际应用场景**
```sql
-- 清理用户敏感信息
UPDATE users 
SET profile = JSON_REMOVE(
  profile, 
  '$.password_hint',
  '$.last_login_ip',
  '$.session_data'
)
WHERE account_status = 'deactivated';

-- 删除过期的临时数据
UPDATE orders 
SET order_data = JSON_REMOVE(
  order_data,
  '$.temp_calculations',
  '$.draft_notes',
  '$.processing_logs'
)
WHERE order_status = 'completed' 
  AND created_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 批量清理产品的调试信息
UPDATE products 
SET metadata = JSON_REMOVE(
  metadata,
  '$.debug',
  '$.test_data',
  '$.internal_notes'
)
WHERE status = 'published';
```

---

## 5. 🎯 JSON函数实践应用


### 5.1 电商系统中的JSON应用


**📦 商品属性管理**
```sql
-- 创建商品表
CREATE TABLE products (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  category VARCHAR(50),
  attributes JSON,  -- 存储动态属性
  pricing JSON,     -- 存储价格信息
  inventory JSON    -- 存储库存信息
);

-- 插入商品数据
INSERT INTO products (name, category, attributes, pricing, inventory) VALUES
('iPhone 14 Pro', 'smartphone', 
 JSON_OBJECT(
   'brand', 'Apple',
   'color', JSON_ARRAY('深空黑', '银色', '金色', '暗紫色'),
   'storage', JSON_ARRAY('128GB', '256GB', '512GB', '1TB'),
   'screen_size', '6.1英寸',
   'camera', JSON_OBJECT('main', '48MP', 'ultra_wide', '12MP', 'telephoto', '12MP')
 ),
 JSON_OBJECT('base_price', 7999, 'currency', 'CNY', 'discount', 0.95),
 JSON_OBJECT('total_stock', 1500, 'available', 1200, 'reserved', 300)
);

-- 查询特定品牌的商品
SELECT 
  name,
  attributes ->> '$.brand' AS brand,
  pricing ->> '$.base_price' AS price
FROM products 
WHERE attributes ->> '$.brand' = 'Apple';

-- 更新库存信息
UPDATE products 
SET inventory = JSON_SET(
  inventory,
  '$.available', inventory ->> '$.available' - 1,
  '$.last_updated', NOW()
)
WHERE id = 1 AND inventory ->> '$.available' > 0;
```

### 5.2 用户管理系统


**👤 用户画像与偏好**
```sql
-- 用户表设计
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) UNIQUE,
  email VARCHAR(100),
  profile JSON,      -- 基本信息
  preferences JSON,  -- 用户偏好
  activity_log JSON  -- 活动记录
);

-- 用户注册时初始化
INSERT INTO users (username, email, profile, preferences) VALUES
('zhangsan', 'zhangsan@example.com',
 JSON_OBJECT(
   'real_name', '张三',
   'age', 28,
   'gender', 'male',
   'location', JSON_OBJECT('province', '北京市', 'city', '海淀区'),
   'registration_date', NOW()
 ),
 JSON_OBJECT(
   'language', 'zh-CN',
   'theme', 'light',
   'notifications', JSON_OBJECT('email', true, 'sms', false, 'push', true),
   'privacy', JSON_OBJECT('profile_public', false, 'show_online_status', true)
 )
);

-- 更新用户偏好
UPDATE users 
SET preferences = JSON_SET(
  preferences,
  '$.theme', 'dark',
  '$.notifications.email', false
)
WHERE username = 'zhangsan';

-- 记录用户活动
UPDATE users 
SET activity_log = JSON_SET(
  COALESCE(activity_log, '{}'),
  '$.last_login', NOW(),
  '$.login_count', COALESCE(activity_log ->> '$.login_count', 0) + 1,
  CONCAT('$.recent_actions[', JSON_LENGTH(COALESCE(activity_log -> '$.recent_actions', '[]')), ']'),
  JSON_OBJECT('action', 'login', 'timestamp', NOW(), 'ip', '192.168.1.100')
)
WHERE username = 'zhangsan';
```

### 5.3 配置管理系统


**⚙️ 系统配置动态管理**
```sql
-- 系统配置表
CREATE TABLE system_config (
  id INT PRIMARY KEY AUTO_INCREMENT,
  module VARCHAR(50),
  config_name VARCHAR(100),
  config_data JSON,
  version VARCHAR(20),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 插入邮件服务配置
INSERT INTO system_config (module, config_name, config_data, version) VALUES
('email', 'smtp_settings', 
 JSON_OBJECT(
   'host', 'smtp.example.com',
   'port', 587,
   'security', 'TLS',
   'auth', JSON_OBJECT('username', 'admin@example.com', 'password_encrypted', true),
   'limits', JSON_OBJECT('daily_limit', 10000, 'rate_limit', 100),
   'templates', JSON_ARRAY('welcome', 'reset_password', 'notification')
 ), 
 '1.0'
);

-- 更新配置
UPDATE system_config 
SET 
  config_data = JSON_SET(
    config_data,
    '$.limits.daily_limit', 15000,
    '$.backup_host', 'smtp-backup.example.com'
  ),
  version = '1.1'
WHERE module = 'email' AND config_name = 'smtp_settings';

-- 查询特定配置项
SELECT 
  config_data ->> '$.host' AS smtp_host,
  config_data ->> '$.limits.daily_limit' AS daily_limit
FROM system_config 
WHERE module = 'email' AND config_name = 'smtp_settings';
```

### 5.4 性能监控与分析


**📊 数据分析查询技巧**
```sql
-- 分析用户地域分布
SELECT 
  profile ->> '$.location.province' AS province,
  COUNT(*) AS user_count,
  ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users), 2) AS percentage
FROM users 
WHERE profile ->> '$.location.province' IS NOT NULL
GROUP BY province
ORDER BY user_count DESC;

-- 分析商品价格区间分布
SELECT 
  CASE 
    WHEN CAST(pricing ->> '$.base_price' AS DECIMAL) < 1000 THEN '低价位(< 1000)'
    WHEN CAST(pricing ->> '$.base_price' AS DECIMAL) < 5000 THEN '中价位(1000-5000)'
    WHEN CAST(pricing ->> '$.base_price' AS DECIMAL) < 10000 THEN '高价位(5000-10000)'
    ELSE '奢侈品(> 10000)'
  END AS price_range,
  COUNT(*) AS product_count
FROM products 
WHERE pricing ->> '$.base_price' IS NOT NULL
GROUP BY price_range
ORDER BY MIN(CAST(pricing ->> '$.base_price' AS DECIMAL));

-- 查找配置异常的数据
SELECT 
  id, 
  name,
  'Missing required attributes' AS issue
FROM products 
WHERE JSON_CONTAINS_PATH(attributes, 'one', '$.brand', '$.category') = 0

UNION ALL

SELECT 
  id,
  name, 
  'Invalid price data' AS issue
FROM products 
WHERE pricing ->> '$.base_price' IS NULL 
   OR CAST(pricing ->> '$.base_price' AS DECIMAL) <= 0;
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 JSON函数本质：MySQL 5.7+提供的处理JSON数据的专用工具集
🔸 JSON路径语法：$ 根节点、.key 对象键、[index] 数组索引
🔸 创建函数：JSON_ARRAY创建数组、JSON_OBJECT创建对象、JSON_VALID验证格式
🔸 查询函数：JSON_EXTRACT提取值、->/->>操作符简化查询、JSON_KEYS获取键名、JSON_LENGTH获取长度
🔸 修改函数：JSON_SET万能设置、JSON_INSERT只插入、JSON_REPLACE只替换、JSON_REMOVE删除
```

### 6.2 关键理解要点


**🔹 JSON函数的设计哲学**
```
灵活性 vs 性能：
- JSON提供了关系型数据库的灵活性扩展
- 但查询性能通常低于传统的列存储
- 适合半结构化数据，不适合高频查询的核心字段

数据一致性：
- JSON数据缺乏严格的模式约束
- 需要在应用层面保证数据格式的一致性
- 建议结合CHECK约束使用JSON_VALID函数
```

**🔹 三种修改函数的使用场景**
```
JSON_SET - 万能更新：
✅ 用户资料更新、系统配置修改
✅ 需要"存在则更新，不存在则创建"的场景

JSON_INSERT - 安全插入：
✅ 初始化默认配置、避免覆盖现有数据
✅ 数据迁移时的安全操作

JSON_REPLACE - 精确替换：
✅ 修正已存在的错误数据
✅ 版本升级时的字段更新
```

**🔹 性能优化建议**
```
索引策略：
- 对频繁查询的JSON路径创建虚拟列索引
- 例：ALTER TABLE users ADD COLUMN city VARCHAR(50) AS (profile ->> '$.location.city'), ADD INDEX(city);

数据结构设计：
- 核心业务字段仍使用传统列存储
- JSON用于扩展属性、配置信息、日志数据
- 避免在JSON中存储经常JOIN的关联键
```

### 6.3 实际应用价值


**🎯 典型应用场景**
- **电商系统**：商品动态属性、用户偏好设置、购物车数据
- **内容管理**：文章元数据、标签系统、多媒体信息
- **系统配置**：应用设置、权限配置、功能开关
- **日志分析**：结构化日志、事件追踪、用户行为分析
- **API数据**：第三方接口数据存储、临时数据缓存

**🔧 最佳实践总结**
```
设计原则：
1. JSON用于"变化频繁"的数据，不用于"核心稳定"的数据
2. 保持JSON结构的相对稳定，避免频繁变更格式
3. 在应用层面实现JSON数据的验证和约束
4. 合理使用索引，提升查询性能

编码规范：
1. 统一JSON字段命名规范（如使用下划线分隔）
2. 建立JSON数据的版本管理机制
3. 提供JSON数据的备份和恢复方案
4. 做好JSON数据的文档说明
```

**🚨 常见陷阱和注意事项**
```
类型转换问题：
- JSON中的数字和字符串需要明确类型转换
- 使用CAST函数进行显式类型转换

路径语法错误：
- 注意JSON路径的大小写敏感性
- 数组索引从0开始，不是从1开始

性能问题：
- 避免在大表的JSON字段上进行复杂查询
- 考虑使用生成列和索引优化查询性能

数据一致性：
- JSON数据缺乏外键约束，需要应用层面保证一致性
- 定期检查JSON数据的格式和完整性
```

**核心记忆口诀**：
- JSON函数处理半结构化，五七版本开始支持化
- 创建查询修改三大类，路径语法要记牢靠化  
- SET万能INSERT安全，REPLACE精准REMOVE清除化
- 电商配置日志场景多，灵活性能要平衡化