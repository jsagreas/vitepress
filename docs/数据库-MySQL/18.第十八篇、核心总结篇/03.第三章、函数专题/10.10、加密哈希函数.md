---
title: 10、加密哈希函数
---
## 📚 目录

1. [哈希函数基础概念](#1-哈希函数基础概念)
2. [MD5哈希函数详解](#2-MD5哈希函数详解)
3. [SHA1哈希函数详解](#3-SHA1哈希函数详解)
4. [SHA2哈希函数详解](#4-SHA2哈希函数详解)
5. [哈希函数对比分析](#5-哈希函数对比分析)
6. [实际应用场景](#6-实际应用场景)
7. [安全性考虑](#7-安全性考虑)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 哈希函数基础概念


### 1.1 什么是哈希函数


**简单理解**：哈希函数就像一个"数字指纹生成器"，无论你输入什么内容，它都会生成一个固定长度的"指纹"。

```
输入数据（任意长度） → 哈希函数 → 固定长度的哈希值
```

**核心特点**：
- ✅ **单向性**：从原文可以算出哈希值，但从哈希值无法逆推原文
- ✅ **确定性**：同样的输入永远得到同样的哈希值
- ✅ **雪崩效应**：输入微小变化会导致输出巨大变化
- ✅ **固定长度**：无论输入多长，输出长度都固定

### 1.2 哈希函数的作用


**主要用途**：
```
🔸 密码存储：不直接存储明文密码，存储哈希值
🔸 数据完整性验证：检查数据是否被篡改
🔸 数字签名：验证数据来源的真实性
🔸 去重处理：快速判断两个数据是否相同
```

**生活中的类比**：
就像每个人的指纹一样，哈希值是数据的"唯一标识"。即使两个文件99.99%相同，它们的哈希值也会完全不同。

### 1.3 MySQL中的哈希函数位置


**功能分类**：
```
MySQL函数体系
├── 字符串函数
├── 数值函数  
├── 日期时间函数
├── 条件函数
├── 聚合函数
└── 加密哈希函数 ← 我们讲的内容
    ├── MD5()
    ├── SHA1()
    └── SHA2()
```

---

## 2. 🔑 MD5哈希函数详解


### 2.1 MD5函数基本概念


**MD5定义**：Message Digest Algorithm 5（消息摘要算法第5版）

**语法格式**：
```sql
MD5(str)
```

**返回结果**：
- 固定返回 **32位十六进制字符串**
- 无论输入多长，输出都是32个字符

### 2.2 MD5函数使用示例


**基础使用**：
```sql
-- 对字符串进行MD5加密
SELECT MD5('Hello World');
-- 结果：b10a8db164e0754105b7a99be72e3fe5

-- 对数字进行MD5加密
SELECT MD5('123456');
-- 结果：e10adc3949ba59abbe56e057f20f883e

-- 对中文进行MD5加密
SELECT MD5('你好');
-- 结果：7eca689f0d3389d9dea66ae112e5cfd7
```

**实际应用示例**：
```sql
-- 用户注册时存储密码的MD5值
INSERT INTO users (username, password_hash) 
VALUES ('张三', MD5('mypassword123'));

-- 用户登录验证
SELECT * FROM users 
WHERE username = '张三' 
AND password_hash = MD5('mypassword123');

-- 查看文件内容是否变化
SELECT filename, MD5(file_content) as content_hash 
FROM file_table;
```

### 2.3 MD5的特点和限制


**优点**：
- ✅ 计算速度快
- ✅ 输出长度固定（32字符）
- ✅ 广泛支持，兼容性好

**缺点**：
- ❌ 安全性较低，容易被暴力破解
- ❌ 存在哈希碰撞风险
- ❌ 不适合高安全性要求的场景

> **⚠️ 安全提醒**：MD5已被认为不够安全，建议在新项目中使用SHA2等更安全的哈希算法。

---

## 3. 🛡️ SHA1哈希函数详解


### 3.1 SHA1函数基本概念


**SHA1定义**：Secure Hash Algorithm 1（安全哈希算法第1版）

**语法格式**：
```sql
SHA1(str)
```

**返回结果**：
- 固定返回 **40位十六进制字符串**
- 比MD5更长，安全性相对更高

### 3.2 SHA1函数使用示例


**基础使用**：
```sql
-- 对字符串进行SHA1加密
SELECT SHA1('Hello World');
-- 结果：0a4d55a8d778e5022fab701977c5d840bbc486d0

-- 对密码进行SHA1加密
SELECT SHA1('123456');
-- 结果：7c4a8d09ca3762af61e59520943dc26494f8941b

-- SHA1与MD5对比
SELECT 
    'Hello' as input,
    MD5('Hello') as md5_hash,
    SHA1('Hello') as sha1_hash;
```

**实际应用示例**：
```sql
-- 使用SHA1存储用户密码
CREATE TABLE user_accounts (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50),
    password_sha1 CHAR(40)  -- SHA1固定40字符
);

INSERT INTO user_accounts (username, password_sha1) 
VALUES ('李四', SHA1('securepass456'));

-- 验证登录
SELECT username FROM user_accounts 
WHERE username = '李四' 
AND password_sha1 = SHA1('securepass456');
```

### 3.3 SHA1与MD5的对比


| 特性 | **MD5** | **SHA1** |
|------|---------|----------|
| **输出长度** | `32字符 (128位)` | `40字符 (160位)` |
| **安全性** | `较低` | `中等` |
| **计算速度** | `更快` | `稍慢` |
| **碰撞概率** | `较高` | `较低` |
| **推荐使用** | `不推荐` | `谨慎使用` |

---

## 4. 🚀 SHA2哈希函数详解


### 4.1 SHA2函数基本概念


**SHA2定义**：Secure Hash Algorithm 2（安全哈希算法第2版），是目前最安全的哈希算法系列。

**语法格式**：
```sql
SHA2(str, hash_length)
```

**参数说明**：
- `str`：要加密的字符串
- `hash_length`：哈希长度，可选值：**224、256、384、512**

### 4.2 SHA2支持的哈希长度


**长度选项详解**：
```
SHA2-224：输出 56 个十六进制字符 (224位)
SHA2-256：输出 64 个十六进制字符 (256位) ← 最常用
SHA2-384：输出 96 个十六进制字符 (384位)
SHA2-512：输出128个十六进制字符 (512位) ← 最安全
```

### 4.3 SHA2函数使用示例


**不同长度的SHA2**：
```sql
-- SHA2-256 (最常用)
SELECT SHA2('Hello World', 256);
-- 结果：a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e

-- SHA2-512 (最安全)
SELECT SHA2('Hello World', 512);
-- 结果：2c74fd17edafd80e8447b0d46741ee243b7eb74dd2149a0ab1b9246fb30382f27e853d8585719e0e67cbda0daa8f51671064615d645ae27acb15bfb1447f459b

-- 对比不同长度
SELECT 
    'password123' as input,
    SHA2('password123', 224) as sha224,
    SHA2('password123', 256) as sha256,
    SHA2('password123', 384) as sha384,
    SHA2('password123', 512) as sha512;
```

**实际应用示例**：
```sql
-- 现代安全的用户表设计
CREATE TABLE secure_users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,
    password_hash CHAR(64),  -- SHA2-256固定64字符
    salt VARCHAR(32),        -- 盐值增强安全性
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 带盐值的密码存储
SET @salt = 'randomsalt123';
INSERT INTO secure_users (username, password_hash, salt) 
VALUES ('王五', SHA2(CONCAT('userpass789', @salt), 256), @salt);

-- 安全的登录验证
SELECT username FROM secure_users 
WHERE username = '王五' 
AND password_hash = SHA2(CONCAT('userpass789', salt), 256);
```

### 4.4 SHA2长度选择建议


**选择指南**：
```
🔸 SHA2-256：
  ✅ 平衡安全性和性能
  ✅ 最广泛使用
  ✅ 适合大多数应用场景

🔸 SHA2-512：
  ✅ 最高安全性
  ❌ 计算开销更大
  ✅ 适合高安全要求场景

🔸 SHA2-224/384：
  ⚠️ 特殊需求场景使用
  ⚠️ 不如256和512常见
```

---

## 5. ⚖️ 哈希函数对比分析


### 5.1 安全性对比


**安全级别排序**：
```
SHA2-512 > SHA2-256 > SHA1 > MD5

最安全 ←————————————————————→ 最不安全
```

**详细对比表**：

| 哈希函数 | **输出长度** | **安全级别** | **计算速度** | **推荐使用** |
|----------|-------------|-------------|-------------|-------------|
| **MD5** | `32字符` | `⭐` | `🚀🚀🚀` | `❌ 不推荐` |
| **SHA1** | `40字符` | `⭐⭐` | `🚀🚀` | `⚠️ 谨慎使用` |
| **SHA2-256** | `64字符` | `⭐⭐⭐⭐` | `🚀` | `✅ 推荐` |
| **SHA2-512** | `128字符` | `⭐⭐⭐⭐⭐` | `🚀` | `✅ 高安全场景` |

### 5.2 性能对比测试


**执行时间对比**：
```sql
-- 测试不同哈希函数的性能
SELECT 
    BENCHMARK(1000000, MD5('test string')) as md5_time,
    BENCHMARK(1000000, SHA1('test string')) as sha1_time,
    BENCHMARK(1000000, SHA2('test string', 256)) as sha256_time;
```

**性能结果**：
```
MD5     ： 最快 (基准 1.0x)
SHA1    ： 稍慢 (约 1.2x)
SHA2-256： 较慢 (约 1.5x)
SHA2-512： 最慢 (约 2.0x)
```

### 5.3 应用场景选择


**场景匹配指南**：
```
🔸 数据去重、缓存键：
  → MD5 (性能优先，安全性要求不高)

🔸 文件校验、数据完整性：
  → SHA2-256 (平衡安全性和性能)

🔸 密码存储、敏感数据：
  → SHA2-256 + 盐值 (标准做法)

🔸 金融、军用级安全：
  → SHA2-512 + 盐值 (最高安全性)
```

---

## 6. 💼 实际应用场景


### 6.1 用户密码管理


**传统做法（不安全）**：
```sql
-- ❌ 错误做法：直接存储明文密码
CREATE TABLE users_bad (
    username VARCHAR(50),
    password VARCHAR(50)  -- 明文密码，极不安全！
);
```

**现代安全做法**：
```sql
-- ✅ 正确做法：哈希+盐值存储
CREATE TABLE users_secure (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,
    password_hash CHAR(64),    -- SHA2-256哈希值
    salt VARCHAR(32),          -- 随机盐值
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户注册流程
DELIMITER $$
CREATE PROCEDURE RegisterUser(
    IN p_username VARCHAR(50), 
    IN p_password VARCHAR(50)
)
BEGIN
    DECLARE v_salt VARCHAR(32);
    SET v_salt = MD5(CONCAT(p_username, NOW(), RAND()));
    
    INSERT INTO users_secure (username, password_hash, salt)
    VALUES (p_username, SHA2(CONCAT(p_password, v_salt), 256), v_salt);
END$$
DELIMITER ;
```

### 6.2 数据完整性验证


**文件完整性检查**：
```sql
-- 文件管理表
CREATE TABLE file_records (
    id INT PRIMARY KEY AUTO_INCREMENT,
    filename VARCHAR(255),
    file_content LONGTEXT,
    content_hash CHAR(64),  -- SHA2-256校验和
    upload_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 上传文件时计算哈希
INSERT INTO file_records (filename, file_content, content_hash)
VALUES ('document.txt', 'file content here...', 
        SHA2('file content here...', 256));

-- 验证文件是否被篡改
SELECT 
    filename,
    CASE 
        WHEN content_hash = SHA2(file_content, 256) 
        THEN '✅ 文件完整' 
        ELSE '❌ 文件已被修改' 
    END as integrity_status
FROM file_records;
```

### 6.3 API接口签名验证


**接口安全验证**：
```sql
-- API调用记录表
CREATE TABLE api_calls (
    id INT PRIMARY KEY AUTO_INCREMENT,
    api_key VARCHAR(64),
    request_data TEXT,
    signature CHAR(64),      -- 请求签名
    call_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 生成API签名
SET @api_secret = 'your_secret_key_here';
SET @request_data = '{"user_id":123,"action":"transfer","amount":1000}';

INSERT INTO api_calls (api_key, request_data, signature)
VALUES ('client_api_key_123', @request_data,
        SHA2(CONCAT(@request_data, @api_secret), 256));

-- 验证API签名
SELECT 
    id,
    CASE 
        WHEN signature = SHA2(CONCAT(request_data, 'your_secret_key_here'), 256)
        THEN '✅ 签名有效'
        ELSE '❌ 签名无效'
    END as signature_status
FROM api_calls;
```

### 6.4 数据去重处理


**高效去重**：
```sql
-- 内容去重表
CREATE TABLE content_items (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    content TEXT,
    content_hash CHAR(32) UNIQUE,  -- MD5用于快速去重
    INDEX idx_hash (content_hash)
);

-- 插入内容前检查重复
INSERT IGNORE INTO content_items (title, content, content_hash)
VALUES ('文章标题', '文章内容...', MD5('文章内容...'));

-- 查找重复内容
SELECT content_hash, COUNT(*) as duplicate_count
FROM content_items
GROUP BY content_hash
HAVING COUNT(*) > 1;
```

---

## 7. 🔒 安全性考虑


### 7.1 哈希函数的安全威胁


**常见攻击方式**：
```
🔸 暴力破解：尝试所有可能的密码组合
🔸 字典攻击：使用常见密码字典进行攻击
🔸 彩虹表攻击：预计算的哈希值对照表
🔸 哈希碰撞：找到产生相同哈希值的不同输入
```

**威胁级别评估**：
```
MD5：
❌ 容易被彩虹表破解
❌ 存在已知碰撞攻击
❌ 不适合密码存储

SHA1：
⚠️ 理论上存在碰撞风险
⚠️ 不建议用于新项目
⚠️ 仅适用于非安全关键场景

SHA2：
✅ 目前无实际碰撞攻击
✅ 适合密码存储
✅ 推荐用于安全场景
```

### 7.2 提升安全性的方法


**盐值（Salt）的使用**：
```sql
-- ✅ 使用盐值增强安全性
SET @password = 'user_password_123';
SET @salt = 'random_salt_xyz';

-- 盐值+密码组合哈希
SELECT SHA2(CONCAT(@password, @salt), 256) as secure_hash;

-- 更安全的做法：密码+盐值+胡椒值
SET @pepper = 'system_wide_secret';
SELECT SHA2(CONCAT(@password, @salt, @pepper), 256) as very_secure_hash;
```

**密码策略建议**：
```sql
-- 创建安全的用户认证系统
CREATE TABLE auth_users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,
    password_hash CHAR(64),     -- SHA2-256
    salt VARCHAR(32),           -- 随机盐值
    pepper_version INT DEFAULT 1, -- 胡椒值版本
    failed_attempts INT DEFAULT 0, -- 失败尝试次数
    locked_until TIMESTAMP NULL,   -- 锁定到期时间
    last_login TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 7.3 最佳实践建议


**安全开发原则**：
```
🔸 永远不要存储明文密码
🔸 使用强随机盐值（每个密码独有）
🔸 选择合适的哈希算法（推荐SHA2-256）
🔸 实施账户锁定机制防止暴力破解
🔸 定期更新哈希算法和安全策略
🔸 记录和监控异常登录行为
```

**代码实现示例**：
```sql
-- 安全的密码验证存储过程
DELIMITER $$
CREATE PROCEDURE SecureLogin(
    IN p_username VARCHAR(50),
    IN p_password VARCHAR(50),
    OUT p_result VARCHAR(20)
)
BEGIN
    DECLARE v_stored_hash CHAR(64);
    DECLARE v_salt VARCHAR(32);
    DECLARE v_failed_attempts INT;
    DECLARE v_locked_until TIMESTAMP;
    
    -- 获取用户信息
    SELECT password_hash, salt, failed_attempts, locked_until
    INTO v_stored_hash, v_salt, v_failed_attempts, v_locked_until
    FROM auth_users WHERE username = p_username;
    
    -- 检查账户是否被锁定
    IF v_locked_until IS NOT NULL AND v_locked_until > NOW() THEN
        SET p_result = 'ACCOUNT_LOCKED';
    -- 验证密码
    ELSEIF SHA2(CONCAT(p_password, v_salt), 256) = v_stored_hash THEN
        -- 登录成功，重置失败次数
        UPDATE auth_users 
        SET failed_attempts = 0, last_login = NOW()
        WHERE username = p_username;
        SET p_result = 'SUCCESS';
    ELSE
        -- 登录失败，增加失败次数
        SET v_failed_attempts = v_failed_attempts + 1;
        UPDATE auth_users 
        SET failed_attempts = v_failed_attempts,
            locked_until = CASE WHEN v_failed_attempts >= 5 
                          THEN DATE_ADD(NOW(), INTERVAL 30 MINUTE)
                          ELSE locked_until END
        WHERE username = p_username;
        SET p_result = 'INVALID_CREDENTIALS';
    END IF;
END$$
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 哈希函数本质：单向加密，生成固定长度的数字指纹
🔸 MD5函数：32字符输出，速度快但安全性低，不推荐新项目使用
🔸 SHA1函数：40字符输出，安全性中等，谨慎使用
🔸 SHA2函数：支持多种长度(224/256/384/512)，目前最安全的选择
🔸 盐值机制：增强密码安全性，防止彩虹表攻击
```

### 8.2 关键使用要点


**🔹 函数选择原则**
```
性能优先场景：MD5() - 仅用于非安全关键的去重等
平衡场景：SHA2(str, 256) - 最常用的安全选择  
高安全场景：SHA2(str, 512) - 最高安全级别
兼容性考虑：SHA1() - 仅在必须兼容旧系统时使用
```

**🔹 安全实施要点**
```
密码存储：必须使用SHA2 + 随机盐值
数据校验：SHA2-256足够，无需512
API签名：SHA2-256 + 密钥组合
去重处理：MD5可用，注重性能
```

**🔹 语法使用要点**
```sql
-- MD5使用
MD5('输入字符串')  -- 返回32字符

-- SHA1使用  
SHA1('输入字符串') -- 返回40字符

-- SHA2使用
SHA2('输入字符串', 256) -- 返回64字符
SHA2('输入字符串', 512) -- 返回128字符
```

### 8.3 实际应用价值


**💼 业务场景应用**
- **用户系统**：安全的密码存储和验证机制
- **文件管理**：数据完整性校验和版本控制
- **API安全**：接口签名验证和防篡改
- **数据去重**：高效的重复内容识别
- **审计日志**：数据变更的可追溯性验证

**🔧 开发实践价值**
- **安全合规**：满足数据保护法规要求
- **性能优化**：合理选择哈希算法平衡安全和性能
- **系统设计**：构建可靠的身份认证和数据校验机制
- **运维监控**：通过哈希值快速检测数据异常

**核心记忆口诀**：
- MD5快速但不安全，SHA1中等需谨慎
- SHA2系列最可靠，256常用512最强
- 密码存储加盐值，数据校验保完整
- 安全第一选算法，性能平衡看场景