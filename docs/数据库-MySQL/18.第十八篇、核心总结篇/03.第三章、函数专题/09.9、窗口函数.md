---
title: 9、窗口函数
---
## 📚 目录

1. [窗口函数基础概念](#1-窗口函数基础概念)
2. [排名函数详解](#2-排名函数详解)
3. [值访问函数详解](#3-值访问函数详解)
4. [聚合窗口函数详解](#4-聚合窗口函数详解)
5. [窗口语法与实践](#5-窗口语法与实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1.🎯 窗口函数基础概念


### 1.1 什么是窗口函数


> 💡 **简单理解**：窗口函数就像是"透过窗户看数据"，可以在不改变原始行数的情况下，对一组相关的行进行计算。

**核心特点**：
```
普通聚合函数：多行变一行
SELECT department, COUNT(*) FROM employees GROUP BY department;
结果：每个部门一行汇总数据

窗口函数：保持原行数，添加计算列
SELECT employee_id, salary, 
       COUNT(*) OVER(PARTITION BY department) as dept_count
FROM employees;
结果：每个员工一行，同时显示所在部门的总人数
```

### 1.2 窗口函数的基本语法


**标准语法结构**：
```sql
函数名() OVER(
    [PARTITION BY 列名]    -- 分组：按什么划分窗口
    [ORDER BY 列名]        -- 排序：窗口内如何排序
    [ROWS/RANGE ...]       -- 窗口范围：具体计算哪些行
)
```

### 1.3 窗口函数 vs 传统方法


**传统做法的局限**：
```sql
-- ❌ 想要每个员工信息 + 部门平均薪资，需要子查询
SELECT e.*, 
       (SELECT AVG(salary) FROM employees e2 
        WHERE e2.department = e.department) as dept_avg
FROM employees e;
-- 问题：性能差，写法复杂

-- ✅ 窗口函数：简洁高效
SELECT employee_id, salary, department,
       AVG(salary) OVER(PARTITION BY department) as dept_avg
FROM employees;
```

---

## 2. 🏆 排名函数详解


### 2.1 ROW_NUMBER() - 行号函数


**📋 核心概念**：为每一行分配一个唯一的连续数字，就像给学生排队编号一样。

**基本语法**：
```sql
ROW_NUMBER() OVER([PARTITION BY 列名] ORDER BY 列名)
```

**实际应用示例**：
```sql
-- 员工表按薪资排序，每人一个唯一编号
SELECT employee_id, name, salary,
       ROW_NUMBER() OVER(ORDER BY salary DESC) as row_num
FROM employees;

结果示例：
| employee_id | name  | salary | row_num |
|-------------|-------|---------|---------|
| 101         | Alice | 8000   | 1       |
| 102         | Bob   | 7500   | 2       |
| 103         | Carol | 7500   | 3       |  -- 即使薪资相同，行号也不同
| 104         | David | 7000   | 4       |
```

### 2.2 RANK() - 排名函数(有并列间隔)


**📋 核心概念**：当数值相同时给相同排名，但会在后续排名中留出间隔。

**与ROW_NUMBER()的区别**：
```
ROW_NUMBER(): 1, 2, 3, 4, 5...  (永远连续)
RANK():       1, 2, 2, 4, 5...  (并列后跳跃)
```

**实际应用示例**：
```sql
-- 按薪资排名，相同薪资并列排名
SELECT employee_id, name, salary,
       RANK() OVER(ORDER BY salary DESC) as salary_rank
FROM employees;

结果示例：
| employee_id | name  | salary | salary_rank |
|-------------|-------|---------|-------------|
| 101         | Alice | 8000   | 1           |
| 102         | Bob   | 7500   | 2           |
| 103         | Carol | 7500   | 2           |  -- 并列第2名
| 104         | David | 7000   | 4           |  -- 跳过第3名，直接第4名
```

### 2.3 DENSE_RANK() - 密集排名(无间隔)


**📋 核心概念**：相同数值给相同排名，但后续排名不留间隔，保持连续。

**三种排名函数对比**：
```sql
SELECT name, salary,
       ROW_NUMBER() OVER(ORDER BY salary DESC) as row_num,
       RANK() OVER(ORDER BY salary DESC) as rank_num,
       DENSE_RANK() OVER(ORDER BY salary DESC) as dense_rank_num
FROM employees;

结果对比：
| name  | salary | row_num | rank_num | dense_rank_num |
|-------|--------|---------|----------|----------------|
| Alice | 8000   | 1       | 1        | 1              |
| Bob   | 7500   | 2       | 2        | 2              |
| Carol | 7500   | 3       | 2        | 2              |
| David | 7000   | 4       | 4        | 3              |  -- 注意这里的区别
| Eve   | 6500   | 5       | 5        | 4              |
```

### 2.4 排名函数的分组应用


**按部门分别排名**：
```sql
-- 每个部门内部按薪资排名
SELECT department, name, salary,
       RANK() OVER(PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees;

结果示例：
| department | name  | salary | dept_rank |
|------------|-------|---------|-----------|
| IT         | Alice | 8000   | 1         |
| IT         | Bob   | 7500   | 2         |
| Sales      | Carol | 7500   | 1         |  -- Sales部门的第1名
| Sales      | David | 7000   | 2         |  -- Sales部门的第2名
```

> 🔧 **实践应用**：
> - `ROW_NUMBER()`: 需要唯一编号时使用（如分页）
> - `RANK()`: 传统排名方式（如考试排名）
> - `DENSE_RANK()`: 紧凑排名（如等级评定）

---

## 3. 🔍 值访问函数详解


### 3.1 LAG() - 访问前N行值


**📋 核心概念**：LAG就是"滞后"的意思，可以获取当前行前面第N行的数据值。

**语法格式**：
```sql
LAG(表达式, 偏移量, 默认值) OVER([PARTITION BY 列名] ORDER BY 列名)
```

**参数说明**：
- `表达式`: 要获取的列或计算式
- `偏移量`: 向前几行（默认1行）
- `默认值`: 如果没有前面的行，返回什么值

**实际应用示例**：
```sql
-- 计算每月销售额与上月的对比
SELECT month_name, sales_amount,
       LAG(sales_amount, 1, 0) OVER(ORDER BY month_id) as prev_month_sales,
       sales_amount - LAG(sales_amount, 1, 0) OVER(ORDER BY month_id) as growth
FROM monthly_sales;

结果示例：
| month_name | sales_amount | prev_month_sales | growth |
|------------|--------------|------------------|---------|
| January    | 10000       | 0                | 10000  |
| February   | 12000       | 10000            | 2000   |
| March      | 11000       | 12000            | -1000  |
```

### 3.2 LEAD() - 访问后N行值


**📋 核心概念**：LEAD是"领先"的意思，可以获取当前行后面第N行的数据值。

**实际应用示例**：
```sql
-- 预测下月销售趋势
SELECT month_name, sales_amount,
       LEAD(sales_amount, 1) OVER(ORDER BY month_id) as next_month_sales,
       CASE 
           WHEN LEAD(sales_amount, 1) OVER(ORDER BY month_id) > sales_amount 
           THEN '上升趋势'
           WHEN LEAD(sales_amount, 1) OVER(ORDER BY month_id) < sales_amount 
           THEN '下降趋势'
           ELSE '持平'
       END as trend
FROM monthly_sales;
```

### 3.3 FIRST_VALUE() - 第一个值


**📋 核心概念**：获取窗口范围内第一行的值。

**实际应用示例**：
```sql
-- 每个部门员工与本部门最高薪资的对比
SELECT department, name, salary,
       FIRST_VALUE(salary) OVER(
           PARTITION BY department 
           ORDER BY salary DESC
       ) as dept_max_salary,
       salary * 100.0 / FIRST_VALUE(salary) OVER(
           PARTITION BY department 
           ORDER BY salary DESC
       ) as salary_percentage
FROM employees;

结果示例：
| department | name  | salary | dept_max_salary | salary_percentage |
|------------|-------|---------|-----------------|-------------------|
| IT         | Alice | 8000   | 8000            | 100.0            |
| IT         | Bob   | 7500   | 8000            | 93.75            |
| Sales      | Carol | 7500   | 7500            | 100.0            |
```

### 3.4 LAST_VALUE() - 最后一个值


**📋 核心概念**：获取窗口范围内最后一行的值。

> ⚠️ **重要注意**：LAST_VALUE()需要特别注意窗口范围的定义，否则可能得不到预期结果。

**正确使用方式**：
```sql
-- 指定完整的窗口范围
SELECT department, name, salary,
       LAST_VALUE(salary) OVER(
           PARTITION BY department 
           ORDER BY salary DESC
           ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
       ) as dept_min_salary
FROM employees;
```

### 3.5 值访问函数的组合应用


**前后对比分析**：
```sql
-- 股价变化分析
SELECT date, price,
       LAG(price, 1) OVER(ORDER BY date) as prev_price,
       LEAD(price, 1) OVER(ORDER BY date) as next_price,
       price - LAG(price, 1, price) OVER(ORDER BY date) as daily_change,
       FIRST_VALUE(price) OVER(ORDER BY date) as year_start_price,
       price - FIRST_VALUE(price) OVER(ORDER BY date) as ytd_change
FROM stock_prices
ORDER BY date;
```

---

## 4. 📊 聚合窗口函数详解


### 4.1 SUM() OVER() - 窗口求和


**📋 核心概念**：在指定窗口范围内计算累计和或移动和，每行都显示一个和值。

**累计求和示例**：
```sql
-- 计算累计销售额
SELECT month_name, sales_amount,
       SUM(sales_amount) OVER(ORDER BY month_id) as cumulative_sales
FROM monthly_sales;

结果示例：
| month_name | sales_amount | cumulative_sales |
|------------|--------------|------------------|
| January    | 10000       | 10000            |
| February   | 12000       | 22000            |  -- 10000+12000
| March      | 11000       | 33000            |  -- 10000+12000+11000
| April      | 13000       | 46000            |  -- 前面所有月份之和
```

**移动窗口求和**：
```sql
-- 计算最近3个月的移动销售总额
SELECT month_name, sales_amount,
       SUM(sales_amount) OVER(
           ORDER BY month_id 
           ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       ) as rolling_3month_sales
FROM monthly_sales;

结果示例：
| month_name | sales_amount | rolling_3month_sales |
|------------|--------------|---------------------|
| January    | 10000       | 10000               |  -- 只有1个月
| February   | 12000       | 22000               |  -- 2个月之和
| March      | 11000       | 33000               |  -- 3个月之和
| April      | 13000       | 36000               |  -- 最近3个月：12000+11000+13000
```

### 4.2 AVG() OVER() - 窗口平均值


**📋 核心概念**：计算指定窗口范围内的平均值，常用于移动平均线分析。

**移动平均计算**：
```sql
-- 股价的5日移动平均线
SELECT date, price,
       AVG(price) OVER(
           ORDER BY date 
           ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
       ) as ma5,
       AVG(price) OVER(
           ORDER BY date 
           ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
       ) as ma20
FROM stock_prices;
```

**分组平均对比**：
```sql
-- 员工薪资与部门平均薪资对比
SELECT department, name, salary,
       AVG(salary) OVER(PARTITION BY department) as dept_avg,
       salary - AVG(salary) OVER(PARTITION BY department) as diff_from_avg,
       CASE 
           WHEN salary > AVG(salary) OVER(PARTITION BY department) 
           THEN '高于平均'
           ELSE '低于平均'
       END as performance
FROM employees;
```

### 4.3 COUNT() OVER() - 窗口计数


**📋 核心概念**：统计窗口范围内满足条件的行数。

**基本计数应用**：
```sql
-- 统计每个部门的人数（每行都显示）
SELECT employee_id, name, department,
       COUNT(*) OVER(PARTITION BY department) as dept_size,
       COUNT(*) OVER() as total_employees
FROM employees;

结果示例：
| employee_id | name  | department | dept_size | total_employees |
|-------------|-------|------------|-----------|-----------------|
| 101         | Alice | IT         | 3         | 10              |
| 102         | Bob   | IT         | 3         | 10              |
| 103         | Carol | Sales      | 2         | 10              |
| 104         | David | Sales      | 2         | 10              |
```

**累计计数**：
```sql
-- 累计入职人数统计
SELECT hire_date, name,
       COUNT(*) OVER(ORDER BY hire_date) as cumulative_hires
FROM employees
ORDER BY hire_date;
```

---

## 5. 🔧 窗口语法与实践


### 5.1 PARTITION BY 子句详解


**📋 核心概念**：PARTITION BY就像是给数据"分组"，在每个组内单独进行窗口计算。

```sql
-- 窗口分区示意图
数据表：
┌─────────────┬──────────┬────────┐
│ department  │   name   │ salary │
├─────────────┼──────────┼────────┤
│ IT          │ Alice    │ 8000   │
│ IT          │ Bob      │ 7500   │
│ Sales       │ Carol    │ 7500   │
│ Sales       │ David    │ 7000   │
└─────────────┴──────────┴────────┘

PARTITION BY department 后的逻辑分组：
IT组：     Sales组：
Alice 8000    Carol 7500
Bob   7500    David 7000
```

**分区与不分区的对比**：
```sql
-- 不分区：全局排名
SELECT department, name, salary,
       RANK() OVER(ORDER BY salary DESC) as global_rank
FROM employees;

-- 分区：部门内排名
SELECT department, name, salary,
       RANK() OVER(PARTITION BY department ORDER BY salary DESC) as dept_rank
FROM employees;
```

### 5.2 ORDER BY 子句详解


**📋 核心概念**：ORDER BY决定窗口内数据的排序方式，影响排名和累计计算的结果。

**排序方向的影响**：
```sql
-- 薪资从高到低排名
SELECT name, salary,
       RANK() OVER(ORDER BY salary DESC) as rank_desc,
       RANK() OVER(ORDER BY salary ASC) as rank_asc
FROM employees;

结果对比：
| name  | salary | rank_desc | rank_asc |
|-------|--------|-----------|----------|
| Alice | 8000   | 1         | 4        |
| Bob   | 7500   | 2         | 2        |
| Carol | 7500   | 2         | 2        |
| David | 7000   | 4         | 1        |
```

### 5.3 窗口框架(ROWS/RANGE)


**📋 核心概念**：定义窗口函数具体计算哪些行的数据。

**常用窗口框架**：
```sql
-- 从开始到当前行
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- 当前行的前2行到后1行
ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING

-- 前3行到当前行
ROWS BETWEEN 3 PRECEDING AND CURRENT ROW

-- 当前行到最后
ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
```

**实际应用示例**：
```sql
-- 不同窗口框架的累计和对比
SELECT month_name, sales_amount,
       SUM(sales_amount) OVER(
           ORDER BY month_id 
           ROWS UNBOUNDED PRECEDING
       ) as cumulative_sum,
       SUM(sales_amount) OVER(
           ORDER BY month_id 
           ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       ) as rolling_3month_sum
FROM monthly_sales;
```

### 5.4 实际业务场景应用


**场景1：销售排行榜**
```sql
-- 销售员业绩排行（显示排名、业绩、超越人数）
SELECT salesperson, sales_amount,
       DENSE_RANK() OVER(ORDER BY sales_amount DESC) as rank_position,
       COUNT(*) OVER(ORDER BY sales_amount DESC 
                     ROWS UNBOUNDED PRECEDING) - 1 as people_behind,
       ROUND(sales_amount * 100.0 / 
             SUM(sales_amount) OVER(), 2) as percentage_of_total
FROM sales_performance;
```

**场景2：同比增长分析**
```sql
-- 月度销售同比增长
SELECT year, month, sales_amount,
       LAG(sales_amount, 12) OVER(ORDER BY year, month) as same_month_last_year,
       ROUND((sales_amount - LAG(sales_amount, 12) OVER(ORDER BY year, month)) * 100.0 / 
             LAG(sales_amount, 12) OVER(ORDER BY year, month), 2) as yoy_growth_pct
FROM monthly_sales
WHERE LAG(sales_amount, 12) OVER(ORDER BY year, month) IS NOT NULL;
```

**场景3：分级管理**
```sql
-- 将员工按薪资分为高、中、低三档
SELECT name, salary,
       NTILE(3) OVER(ORDER BY salary DESC) as salary_tier,
       CASE NTILE(3) OVER(ORDER BY salary DESC)
           WHEN 1 THEN '高薪档'
           WHEN 2 THEN '中薪档'
           WHEN 3 THEN '低薪档'
       END as salary_level
FROM employees;
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 窗口函数本质：在保持原有行数的基础上，添加基于一组相关行的计算结果
🔸 语法结构：函数名() OVER(PARTITION BY ... ORDER BY ... ROWS/RANGE ...)
🔸 三大类别：排名函数、值访问函数、聚合窗口函数
🔸 核心优势：比子查询更高效，比GROUP BY更灵活
```

### 6.2 各函数适用场景速查


| 函数类型 | **主要用途** | **典型场景** |
|---------|-------------|-------------|
| 🏆 **ROW_NUMBER()** | `唯一行号` | `分页查询、去重` |
| 🏆 **RANK()** | `传统排名` | `成绩排名、销售排行` |
| 🏆 **DENSE_RANK()** | `紧凑排名` | `等级划分、评级系统` |
| 🔍 **LAG()** | `获取前面行` | `同比分析、趋势对比` |
| 🔍 **LEAD()** | `获取后面行` | `预测分析、提前预警` |
| 🔍 **FIRST_VALUE()** | `窗口首值` | `与最大值对比` |
| 🔍 **LAST_VALUE()** | `窗口末值` | `与最小值对比` |
| 📊 **SUM() OVER()** | `累计/移动求和` | `累计销售、移动总额` |
| 📊 **AVG() OVER()** | `移动平均` | `股价均线、平均分析` |
| 📊 **COUNT() OVER()** | `窗口计数` | `分组统计、累计计数` |

### 6.3 关键语法要点


**🔹 PARTITION BY 理解要点**
```
作用：数据分组，在每组内独立计算
不写：对所有数据进行计算
写了：在每个分组内单独计算
```

**🔹 ORDER BY 理解要点**
```
作用：确定窗口内的排序规则
影响：排名函数的结果、累计计算的顺序
必需：排名函数和累计计算必须有ORDER BY
```

**🔹 窗口框架理解要点**
```
默认：RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
累计：从开始到当前行
移动：固定大小的滑动窗口
```

### 6.4 实际应用最佳实践


```
性能优化：
✅ 在ORDER BY的列上建立索引
✅ 合理使用PARTITION BY减少计算范围
✅ 避免在窗口函数中使用复杂表达式

常见错误：
❌ LAST_VALUE()忘记指定完整窗口范围
❌ 排名函数忘记ORDER BY
❌ LAG/LEAD的默认值设置不当

实用技巧：
💡 使用NTILE()进行数据分级
💡 结合CASE WHEN进行条件判断
💡 多个窗口函数组合使用分析数据
```

**核心记忆口诀**：
- 窗口函数保行数，透过窗户看数据
- 排名访问加聚合，三大类型要记清
- PARTITION分组ORDER排序，窗口范围要明确
- 业务场景多实践，数据分析更高效

> 🚀 **进阶学习建议**：
> 1. 多练习实际业务场景的SQL编写
> 2. 学习窗口函数的性能优化技巧
> 3. 掌握与其他SQL功能的组合使用
> 4. 了解不同数据库的窗口函数差异