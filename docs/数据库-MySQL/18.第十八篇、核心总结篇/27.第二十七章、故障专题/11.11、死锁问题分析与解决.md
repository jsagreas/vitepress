---
title: 11、死锁问题分析与解决
---
## 📚 目录

1. [死锁基本概念](#1-死锁基本概念)
2. [死锁形成原因与机制](#2-死锁形成原因与机制)
3. [死锁检测与日志分析](#3-死锁检测与日志分析)
4. [死锁受害者选择策略](#4-死锁受害者选择策略)
5. [死锁预防与优化策略](#5-死锁预防与优化策略)
6. [死锁监控与告警](#6-死锁监控与告警)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 死锁基本概念


### 1.1 什么是死锁


**简单理解**：死锁就像两个人都想通过一扇门，但都不愿意让对方先过，结果谁都过不去

```
现实场景：
张三拿着钥匙A，想要钥匙B
李四拿着钥匙B，想要钥匙A
两人都不放手，永远僵持下去

数据库场景：
事务1：锁住了表A，等待表B的锁
事务2：锁住了表B，等待表A的锁  
两个事务互相等待，形成死锁
```

**🔸 死锁的本质特征**
```
循环等待：多个事务形成等待环路
资源竞争：争夺有限的锁资源  
无法自解：不外力干预永远无法解决
系统阻塞：影响数据库正常运行
```

### 1.2 死锁产生的必要条件


> 💡 **记忆技巧**：死锁产生需要同时满足4个条件，缺一不可

| 条件 | **含义** | **数据库场景举例** |
|------|----------|-------------------|
| 🔒 **互斥** | `资源不能被多个进程同时使用` | `写锁不能共享，只能一个事务持有` |
| 🤲 **持有并等待** | `已持有资源还想获取其他资源` | `事务A持有表1的锁，还想要表2的锁` |
| 🚫 **不可剥夺** | `资源不能被强制释放` | `事务提交前不会主动释放锁` |
| 🔄 **循环等待** | `形成等待环路` | `A等B，B等C，C等A形成环路` |

### 1.3 死锁的影响


**🔸 对业务的影响**
```
性能影响：
• 事务回滚，业务操作失败
• 用户体验差，页面响应慢
• 系统吞吐量下降

稳定性影响：
• 频繁死锁可能导致服务不可用
• 连锁反应影响其他正常事务
• 极端情况下需要重启数据库
```

---

## 2. ⚙️ 死锁形成原因与机制


### 2.1 典型死锁场景


#### 🔄 **场景1：不同顺序访问相同资源**


**问题描述**：两个事务以不同顺序访问相同的表，导致交叉锁等待

```sql
-- 事务A的执行顺序
BEGIN;
UPDATE user_table SET status = 1 WHERE id = 100;    -- 锁住user表的id=100
UPDATE order_table SET amount = 200 WHERE user_id = 100;  -- 等待order表锁

-- 事务B的执行顺序（同时进行）
BEGIN;
UPDATE order_table SET status = 'paid' WHERE id = 500;    -- 锁住order表的id=500
UPDATE user_table SET balance = balance - 200 WHERE id = 100;  -- 等待user表锁

-- 结果：A等B释放order表锁，B等A释放user表锁 → 死锁！
```

**形成过程图解**：
```
时间线：
T1: 事务A锁住user表     事务B锁住order表
T2: 事务A请求order表锁  事务B请求user表锁
T3: ↓等待↓             ↓等待↓
T4: 死锁检测触发，回滚其中一个事务
```

#### 🔄 **场景2：索引锁升级冲突**


**问题描述**：不同事务在同一个表上获取不同类型的锁，发生冲突

```sql
-- 事务A：范围查询（获取范围锁）
BEGIN;
SELECT * FROM products WHERE price BETWEEN 100 AND 200 FOR UPDATE;

-- 事务B：精确更新（需要行锁）
BEGIN;  
UPDATE products SET price = 150 WHERE id = 1001;  -- id=1001的价格在100-200范围内

-- 冲突：A的范围锁包含了B要更新的行，B无法获取行锁
--       B的行锁阻止了A进一步操作
```

### 2.2 循环等待识别


**🔍 循环等待的识别方法**

> 💡 **核心思路**：画出事务等待图，查看是否形成环路

```
等待图示例：
事务1 → 等待 → 资源A （被事务2持有）
   ↑                     ↓
   |                  事务2
   |                     ↓
资源B ← 等待 ← 事务2 → 等待 → 资源C
   ↑                            ↓
   |                         事务3
   |                            ↓
事务1 ← 等待 ← 资源B ← 等待 ← 事务3

发现环路：事务1 → 事务2 → 事务3 → 事务1
```

**识别步骤**：
1. **收集等待关系**：哪个事务在等待哪个资源
2. **建立等待图**：用图的方式表示等待关系
3. **检测环路**：使用深度优先搜索查找环路
4. **确定死锁**：发现环路即存在死锁

### 2.3 常见死锁触发模式


**🔸 按业务场景分类**

```
电商订单处理：
• 用户下单 + 扣减库存 + 更新用户余额
• 三个表的访问顺序不一致容易死锁

金融转账业务：
• 账户A扣款 + 账户B加款 + 记录流水
• 两个账户的锁定顺序要保持一致

批量数据处理：
• 大批量UPDATE/INSERT操作
• 容易产生大量行锁冲突
```

**🔸 按锁类型分类**

| 锁组合类型 | **死锁概率** | **典型场景** | **预防重点** |
|-----------|-------------|-------------|-------------|
| 🔒 **行锁 vs 行锁** | `高` | `并发更新同一批数据` | `统一访问顺序` |
| 🔒 **表锁 vs 行锁** | `中` | `DDL与DML并发执行` | `避免大事务` |
| 🔒 **间隙锁冲突** | `中` | `范围查询 + 插入操作` | `减少范围查询锁定` |
| 🔒 **外键约束锁** | `低` | `父子表同时更新` | `优化外键设计` |

---

## 3. 🔍 死锁检测与日志分析


### 3.1 MySQL死锁检测机制


**🔸 InnoDB死锁检测原理**

```
检测时机：
• 每次获取锁时进行检测
• 发现等待关系时构建等待图
• 实时检测，无需额外配置

检测算法：
• 基于等待图的深度优先搜索
• 时间复杂度O(n²)，n为事务数
• 检测到环路立即触发死锁处理
```

**相关配置参数**：
```sql
-- 查看死锁检测配置
SHOW VARIABLES LIKE 'innodb_deadlock_detect';

-- 死锁等待超时时间（默认50秒）
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';

-- 打印死锁信息到错误日志
SET GLOBAL innodb_print_all_deadlocks = ON;
```

### 3.2 死锁日志分析详解


**🔸 获取死锁信息的方法**

```sql
-- 方法1：查看最近一次死锁信息
SHOW ENGINE INNODB STATUS;

-- 方法2：查看所有死锁日志（需要开启innodb_print_all_deadlocks）
-- 查看MySQL错误日志文件

-- 方法3：通过performance_schema监控
SELECT * FROM performance_schema.events_statements_history 
WHERE sql_text LIKE '%deadlock%';
```

**🔸 死锁日志解读实例**

```
------------------------
LATEST DETECTED DEADLOCK
------------------------
2025-09-12 10:30:15 0x7f8b8c000700
*** (1) TRANSACTION:
TRANSACTION 421394382475, ACTIVE 0 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 locks held, txn writes to binlog, reads only index
MySQL thread id 12345, OS thread handle 139987, query id 987654321 localhost root updating
UPDATE user_table SET balance = balance - 100 WHERE user_id = 1001

*** (2) TRANSACTION:  
TRANSACTION 421394382476, ACTIVE 0 sec starting index read
mysql tables in use 1, locked 1
3 locks held, txn reads 1 writes to binlog, writes 2
MySQL thread id 12346, OS thread handle 139988, query id 987654322 localhost root updating  
UPDATE order_table SET status = 'paid' WHERE order_id = 2001

*** WE ROLL BACK TRANSACTION (2)
```

**日志关键信息解读**：

| 信息项 | **含义** | **分析要点** |
|--------|----------|-------------|
| `TRANSACTION ID` | `事务唯一标识` | `用于跟踪具体事务` |
| `ACTIVE time` | `事务活跃时间` | `时间长说明事务复杂` |
| `locks held` | `已持有锁数量` | `锁数量多容易冲突` |
| `LOCK WAIT` | `正在等待的锁` | `冲突点所在` |
| `WE ROLL BACK` | `被回滚的事务` | `受害者事务` |

### 3.3 死锁分析步骤


**🔍 系统化分析流程**

```
第一步：收集基础信息
• 死锁发生时间和频率  
• 涉及的表和SQL语句
• 事务的执行顺序

第二步：分析锁冲突
• 哪些资源发生冲突
• 锁的类型和范围
• 事务的持锁时间

第三步：找出根本原因  
• 业务逻辑设计问题
• SQL语句执行顺序
• 索引设计不合理

第四步：制定解决方案
• 短期：调整业务逻辑
• 长期：优化表结构和索引
```

**🔧 分析工具和技巧**

```sql
-- 实时监控锁等待情况
SELECT 
    r.trx_id AS waiting_trx_id,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx_id,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query
FROM 
    information_schema.innodb_lock_waits w
    INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
    INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;

-- 查看当前锁定情况
SELECT * FROM information_schema.innodb_locks;

-- 查看事务列表
SELECT * FROM information_schema.innodb_trx;
```

---

## 4. 🎯 死锁受害者选择策略


### 4.1 受害者选择算法


**🔸 MySQL选择受害者的标准**

> 💡 **核心原则**：选择代价最小的事务进行回滚

```
选择标准（按优先级排序）：

1. 事务权重（undo log数量）
   • 修改数据越少的事务越容易被选为受害者
   • 回滚代价小，对系统影响最小

2. 事务活跃时间
   • 运行时间短的事务优先被回滚
   • 避免长时间运行的事务前功尽弃

3. 锁持有数量
   • 持有锁少的事务优先被回滚
   • 减少对其他事务的影响

4. 事务优先级
   • 某些情况下考虑业务优先级
   • 一般情况下所有事务优先级相同
```

### 4.2 受害者选择实例


**🔸 具体场景分析**

```sql
-- 场景：两个事务发生死锁

-- 事务A：大量数据修改操作
BEGIN;
UPDATE products SET price = price * 1.1 WHERE category = 'electronics';  -- 影响10000行
UPDATE inventory SET quantity = quantity - 1 WHERE product_id IN (...);   -- 影响5000行
-- 等待另一个表的锁...

-- 事务B：简单查询更新  
BEGIN;
UPDATE user_profile SET last_login = NOW() WHERE user_id = 12345;  -- 影响1行
-- 等待products表的锁...

-- 选择结果：事务B被选为受害者
-- 原因：事务B修改数据少，回滚代价小
```

**权重计算示例**：
```
事务A权重评估：
• undo log条目：15000条
• 运行时间：2.5秒  
• 持有锁数量：50个
• 总权重：高

事务B权重评估：
• undo log条目：1条
• 运行时间：0.1秒
• 持有锁数量：2个  
• 总权重：低

结论：选择事务B作为受害者
```

### 4.3 受害者处理机制


**🔸 回滚处理流程**

```
步骤1：检测到死锁
• InnoDB死锁检测器发现环路
• 立即开始受害者选择算法

步骤2：选择受害者
• 根据权重算法选择代价最小的事务
• 标记该事务为需要回滚

步骤3：执行回滚
• 撤销受害者事务的所有修改
• 释放该事务持有的所有锁
• 向客户端返回死锁错误

步骤4：其他事务继续
• 被阻塞的事务获得锁继续执行
• 系统恢复正常运行状态
```

**🔸 客户端处理**

```java
// Java应用中处理死锁异常
try {
    // 执行数据库操作
    connection.setAutoCommit(false);
    // ... 业务SQL操作
    connection.commit();
} catch (SQLException e) {
    if (e.getErrorCode() == 1213) {  // MySQL死锁错误码
        // 死锁重试逻辑
        int retryCount = 3;
        while (retryCount > 0) {
            try {
                Thread.sleep(100);  // 短暂等待
                // 重新执行业务操作
                retryBusinessOperation();
                break;
            } catch (SQLException retryE) {
                retryCount--;
                if (retryCount == 0) {
                    throw retryE;  // 重试失败，抛出异常
                }
            }
        }
    }
    connection.rollback();
}
```

---

## 5. 🛡️ 死锁预防与优化策略


### 5.1 事务设计优化


**🔸 核心设计原则**

> 💡 **记住一句话**：让事务又快又小，按顺序访问资源

**原则1：保持事务简短**
```sql
-- ❌ 错误示例：事务过长
BEGIN;
SELECT * FROM large_table WHERE condition;  -- 可能很慢
UPDATE user_table SET status = 1;
-- 中间可能有复杂业务逻辑处理
UPDATE order_table SET amount = 100;
COMMIT;

-- ✅ 正确示例：拆分事务
-- 事务1：处理用户状态
BEGIN;
UPDATE user_table SET status = 1 WHERE user_id = 123;
COMMIT;

-- 事务2：处理订单
BEGIN;  
UPDATE order_table SET amount = 100 WHERE order_id = 456;
COMMIT;
```

**原则2：统一资源访问顺序**
```sql
-- ❌ 错误示例：不同顺序访问
-- 线程A的访问顺序
UPDATE table_a SET value = 1;
UPDATE table_b SET value = 2;

-- 线程B的访问顺序  
UPDATE table_b SET value = 3;
UPDATE table_a SET value = 4;

-- ✅ 正确示例：统一访问顺序
-- 约定：总是先访问table_a，再访问table_b
-- 所有业务代码都遵循这个顺序
UPDATE table_a SET value = 1;
UPDATE table_b SET value = 2;
```

### 5.2 索引顺序优化


**🔸 索引对死锁的影响**

> 🔍 **关键理解**：索引的选择直接影响锁的粒度和范围

```sql
-- 示例表结构
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status)
);

-- ❌ 容易产生死锁的查询
-- 使用了非唯一索引，锁定范围大
UPDATE orders SET amount = 100 WHERE status = 'pending';

-- ✅ 优化后的查询  
-- 使用主键或唯一索引，锁定范围小
UPDATE orders SET amount = 100 WHERE id = 12345;
```

**索引优化策略**：

| 优化方向 | **具体措施** | **效果** |
|---------|-------------|---------|
| 🎯 **减少锁范围** | `使用唯一索引而不是普通索引` | `减少锁冲突概率` |
| ⚡ **提高查询效率** | `为WHERE条件创建合适的索引` | `减少锁持有时间` |
| 🔄 **避免范围锁** | `精确条件查询，避免BETWEEN/LIKE` | `减少间隙锁冲突` |
| 📊 **复合索引设计** | `多列索引覆盖查询条件` | `避免回表操作` |

### 5.3 业务层面预防策略


**🔸 分布式锁替代数据库锁**

```java
// 使用Redis分布式锁避免数据库死锁
@Service
public class OrderService {
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    public void transferMoney(Long fromUserId, Long toUserId, BigDecimal amount) {
        // 确保锁的顺序：ID小的在前
        Long firstId = Math.min(fromUserId, toUserId);
        Long secondId = Math.max(fromUserId, toUserId);
        
        String lockKey1 = "user_lock:" + firstId;
        String lockKey2 = "user_lock:" + secondId;
        
        try {
            // 按顺序获取锁，避免死锁
            if (redisTemplate.opsForValue().setIfAbsent(lockKey1, "1", Duration.ofSeconds(30))) {
                if (redisTemplate.opsForValue().setIfAbsent(lockKey2, "1", Duration.ofSeconds(30))) {
                    // 执行转账业务
                    doTransfer(fromUserId, toUserId, amount);
                }
            }
        } finally {
            // 释放锁
            redisTemplate.delete(lockKey1);
            redisTemplate.delete(lockKey2);
        }
    }
}
```

**🔸 批量操作优化**

```sql
-- ❌ 容易死锁的批量操作
-- 每次操作一行，容易与其他事务冲突
BEGIN;
UPDATE products SET price = price * 1.1 WHERE id = 1;
UPDATE products SET price = price * 1.1 WHERE id = 2;
-- ... 逐行更新
COMMIT;

-- ✅ 优化的批量操作
-- 使用IN语句减少锁持有时间
BEGIN;
UPDATE products SET price = price * 1.1 WHERE id IN (1,2,3,4,5);
COMMIT;

-- 或者使用LIMIT分批处理
UPDATE products SET price = price * 1.1 
WHERE category = 'electronics' 
ORDER BY id LIMIT 1000;
```

### 5.4 配置参数优化


**🔸 关键参数调优**

```sql
-- 调整锁等待超时时间（默认50秒）
SET GLOBAL innodb_lock_wait_timeout = 10;

-- 开启死锁检测（默认开启）
SET GLOBAL innodb_deadlock_detect = ON;

-- 调整事务隔离级别（降低到READ COMMITTED）
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 开启死锁日志记录
SET GLOBAL innodb_print_all_deadlocks = ON;
```

**参数说明**：

| 参数 | **作用** | **建议值** | **注意事项** |
|------|----------|-----------|-------------|
| `innodb_lock_wait_timeout` | `锁等待超时时间` | `10-30秒` | `过短影响正常业务` |
| `innodb_deadlock_detect` | `死锁检测开关` | `ON` | `高并发时可能影响性能` |
| `transaction_isolation` | `事务隔离级别` | `READ-COMMITTED` | `降低锁冲突但可能有幻读` |

---

## 6. 📊 死锁监控与告警


### 6.1 监控指标设计


**🔸 核心监控指标**

> 📈 **监控目标**：及时发现死锁问题，评估系统健康度

```sql
-- 监控SQL：死锁统计查询
-- 查看死锁发生频率
SELECT 
    DATE(created_time) as date,
    COUNT(*) as deadlock_count
FROM mysql.general_log 
WHERE command_type = 'Query' 
  AND argument LIKE '%deadlock%'
GROUP BY DATE(created_time)
ORDER BY date DESC;

-- 查看当前锁等待情况
SELECT 
    COUNT(*) as waiting_transactions,
    AVG(time_to_sec(timediff(now(), trx_started))) as avg_wait_time
FROM information_schema.innodb_trx 
WHERE trx_state = 'LOCK WAIT';

-- 查看锁持有情况
SELECT 
    lock_table,
    lock_mode,
    COUNT(*) as lock_count
FROM information_schema.innodb_locks
GROUP BY lock_table, lock_mode;
```

**监控维度**：

| 维度 | **指标** | **正常范围** | **告警阈值** |
|------|----------|-------------|-------------|
| 🔢 **死锁频率** | `每小时死锁次数` | `< 5次` | `> 20次` |
| ⏱️ **锁等待时间** | `平均等待时长` | `< 1秒` | `> 10秒` |
| 📊 **锁等待数量** | `同时等待的事务数` | `< 10个` | `> 50个` |
| 📈 **死锁增长趋势** | `日环比增长率` | `< 20%` | `> 100%` |

### 6.2 告警系统设计


**🔸 多级告警策略**

```bash
# 告警级别定义
WARNING:  死锁频率超过正常值（5-20次/小时）
CRITICAL: 死锁频率严重超标（>20次/小时）
URGENT:   出现死锁风暴（>100次/小时）

# 告警触发条件
Level 1: 5分钟内死锁超过5次
Level 2: 1分钟内死锁超过10次  
Level 3: 30秒内死锁超过20次
```

**🔸 自动化监控脚本**

```bash
#!/bin/bash
# 死锁监控脚本 deadlock_monitor.sh

# 配置参数
MYSQL_HOST="localhost"
MYSQL_USER="monitor"
MYSQL_PASS="password"
WARNING_THRESHOLD=5
CRITICAL_THRESHOLD=20

# 获取最近5分钟死锁数量
DEADLOCK_COUNT=$(mysql -h${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_PASS} -e "
    SELECT COUNT(*) FROM information_schema.innodb_metrics 
    WHERE name = 'lock_deadlocks' 
    AND time_enabled > DATE_SUB(NOW(), INTERVAL 5 MINUTE)
" 2>/dev/null | tail -1)

# 告警逻辑
if [ $DEADLOCK_COUNT -gt $CRITICAL_THRESHOLD ]; then
    echo "CRITICAL: 死锁数量严重超标 ($DEADLOCK_COUNT)" 
    # 发送紧急告警
    curl -X POST "http://alert-service/critical" \
         -d "message=MySQL死锁严重超标: $DEADLOCK_COUNT 次"
elif [ $DEADLOCK_COUNT -gt $WARNING_THRESHOLD ]; then
    echo "WARNING: 死锁数量超过阈值 ($DEADLOCK_COUNT)"
    # 发送警告通知
    curl -X POST "http://alert-service/warning" \
         -d "message=MySQL死锁超过阈值: $DEADLOCK_COUNT 次"
fi

# 记录监控日志
echo "$(date): 死锁监控 - 数量: $DEADLOCK_COUNT" >> /var/log/mysql_deadlock.log
```

### 6.3 可视化监控面板


**🔸 Grafana监控面板设计**

```json
{
  "dashboard": {
    "title": "MySQL死锁监控",
    "panels": [
      {
        "title": "死锁趋势图",
        "type": "graph",
        "targets": [
          {
            "query": "SELECT time, deadlock_count FROM mysql_deadlock_metrics",
            "refId": "A"
          }
        ]
      },
      {
        "title": "当前锁等待",
        "type": "stat",
        "targets": [
          {
            "query": "SELECT COUNT(*) FROM information_schema.innodb_trx WHERE trx_state = 'LOCK WAIT'"
          }
        ]
      },
      {
        "title": "热点表分析",
        "type": "table",
        "targets": [
          {
            "query": "SELECT lock_table, COUNT(*) as lock_count FROM information_schema.innodb_locks GROUP BY lock_table ORDER BY lock_count DESC LIMIT 10"
          }
        ]
      }
    ]
  }
}
```

**🔸 关键监控视图**

```
实时监控视图：
┌─────────────────────────────────────────┐
│ MySQL死锁监控面板                        │
├─────────────────────────────────────────┤
│ 当前死锁数: 3  │ 锁等待数: 12  │ 平均等待: 2.3s │
├─────────────────────────────────────────┤
│ 死锁趋势图 (最近24小时)                   │
│     ▁▂▃▅▆▅▃▂▁                          │
│ 12 ┤                                    │
│  8 ┤     ▆▆                             │
│  4 ┤  ▃▃    ▃▃                          │
│  0 └──────────────────────────────────  │
│    00:00  06:00  12:00  18:00  24:00   │
├─────────────────────────────────────────┤
│ 热点表排行                               │
│ 1. orders_table     (45个锁)            │
│ 2. user_accounts    (23个锁)            │
│ 3. product_inventory (12个锁)           │
└─────────────────────────────────────────┘
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的关键概念


```
🔸 死锁本质：多个事务相互等待对方释放资源，形成循环等待
🔸 形成条件：互斥、持有并等待、不可剥夺、循环等待
🔸 检测机制：InnoDB自动检测，基于等待图算法
🔸 受害者选择：选择代价最小的事务回滚
🔸 预防策略：统一访问顺序、保持事务简短、优化索引设计
```

### 7.2 关键预防原则


**🔹 事务设计三要素**
```
快：事务执行时间要短，减少锁持有时间
小：事务操作数据量要少，降低冲突概率  
序：资源访问顺序要统一，避免循环等待
```

**🔹 索引优化重点**
```
精确性：使用唯一索引替代普通索引
覆盖性：创建覆盖索引避免回表
有序性：利用索引顺序减少排序锁
```

**🔹 监控告警要点**
```
及时性：实时监控死锁发生情况
准确性：设置合理的告警阈值
可操作：告警信息要包含具体的解决建议
```

### 7.3 实战解决思路


**🎯 遇到死锁问题的分析步骤**

```
第一步：查看死锁日志
• 使用 SHOW ENGINE INNODB STATUS
• 分析涉及的表和SQL语句
• 确定死锁的具体原因

第二步：定位业务场景
• 找出产生死锁的业务操作
• 分析并发执行的事务逻辑
• 确定资源访问的顺序问题

第三步：制定解决方案
• 短期：调整SQL语句和事务逻辑
• 中期：优化索引和表结构
• 长期：重新设计业务架构

第四步：验证和监控
• 测试修改后的效果
• 建立监控告警机制
• 持续观察系统状态
```

**🔧 常用解决技巧**
- **资源排序法**：按照统一的顺序访问资源
- **超时重试法**：捕获死锁异常，自动重试
- **锁粒度控制**：使用合适的索引减少锁范围
- **分布式锁**：用外部锁机制替代数据库锁

**💡 记忆口诀**：
- 死锁预防记住"快小序"：事务要快，范围要小，顺序要统一
- 死锁分析记住"日志先行"：先看日志找原因，再定方案验效果
- 死锁监控记住"防患未然"：监控指标要全面，告警响应要及时