---
title: 17、主从数据不一致故障
---
## 📚 目录

1. [主从数据不一致概述](#1-主从数据不一致概述)
2. [数据一致性检查方法](#2-数据一致性检查方法)
3. [常见不一致原因分析](#3-常见不一致原因分析)
4. [主从数据对比工具](#4-主从数据对比工具)
5. [数据同步修复策略](#5-数据同步修复策略)
6. [预防措施与最佳实践](#6-预防措施与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 主从数据不一致概述


### 1.1 什么是主从数据不一致


**简单理解**：就是主库（写数据的地方）和从库（读数据的地方）的数据不一样了

```
正常情况：
主库：订单表有100条记录
从库：订单表也有100条记录，内容完全一样

不一致情况：
主库：订单表有100条记录
从库：订单表只有95条记录，或者内容有差异
```

### 1.2 不一致的表现形式


**🔸 数据量不一致**
```sql
-- 主库查询结果
SELECT COUNT(*) FROM orders;  -- 结果：1000

-- 从库查询结果  
SELECT COUNT(*) FROM orders;  -- 结果：995
```

**🔸 数据内容不一致**
```sql
-- 主库某条记录
SELECT * FROM users WHERE id=123;
-- 结果：name='张三', status='active'

-- 从库相同记录
SELECT * FROM users WHERE id=123; 
-- 结果：name='张三', status='inactive'
```

**🔸 表结构不一致**
```sql
-- 主库表结构
DESC products;
-- 包含字段：id, name, price, created_at, updated_at

-- 从库表结构
DESC products;
-- 包含字段：id, name, price, created_at
-- 缺少 updated_at 字段
```

### 1.3 不一致带来的业务影响


**💥 实际业务问题**
- **读写分离错误**：用户在主库下单成功，但从库查不到订单
- **报表数据错误**：财务报表基于从库统计，结果不准确
- **缓存更新失败**：应用基于从库数据更新缓存，数据过期
- **数据分析偏差**：BI系统基于从库分析，得出错误结论

---

## 2. 🔎 数据一致性检查方法


### 2.1 基础检查命令


**检查复制状态**
```sql
-- 在从库执行
SHOW SLAVE STATUS\G

-- 重点关注这些字段
Slave_IO_Running: Yes           -- IO线程是否正常
Slave_SQL_Running: Yes          -- SQL线程是否正常
Seconds_Behind_Master: 0        -- 延迟秒数
Last_IO_Error:                  -- IO错误信息
Last_SQL_Error:                 -- SQL错误信息
```

**检查主从位置**
```sql
-- 主库执行
SHOW MASTER STATUS;
-- 记录：File 和 Position

-- 从库执行
SHOW SLAVE STATUS\G
-- 对比：Master_Log_File, Read_Master_Log_Pos, Exec_Master_Log_Pos
```

### 2.2 数据量对比检查


**表级别数据量检查**
```sql
-- 创建检查脚本
-- 在主库和从库都执行
SELECT 
    table_name,
    table_rows,
    data_length,
    index_length
FROM information_schema.tables 
WHERE table_schema = 'your_database'
ORDER BY table_name;
```

**关键业务表详细检查**
```sql
-- 检查订单表数据量
SELECT 
    DATE(created_at) as date,
    COUNT(*) as order_count
FROM orders 
GROUP BY DATE(created_at)
ORDER BY date DESC
LIMIT 7;
```

### 2.3 数据内容校验


**快速校验方法**
```sql
-- 使用校验和检查
SELECT 
    COUNT(*) as row_count,
    SUM(CRC32(CONCAT_WS(',', id, name, email, created_at))) as checksum
FROM users;
```

**分段校验方法**
```sql
-- 按时间段检查
SELECT 
    HOUR(created_at) as hour,
    COUNT(*) as count,
    SUM(CRC32(CONCAT_WS(',', id, amount, status))) as checksum
FROM orders 
WHERE DATE(created_at) = '2025-01-15'
GROUP BY HOUR(created_at);
```

---

## 3. 🔍 常见不一致原因分析


### 3.1 复制过滤问题


**什么是复制过滤**：就是设置哪些数据库或表要同步，哪些不同步

```
典型问题场景：
1. 主库有数据库 A、B、C
2. 从库配置只同步数据库 A、B
3. 应用程序在数据库 C 中插入数据
4. 结果：主库有数据，从库没有
```

**检查复制过滤配置**
```sql
-- 从库执行
SHOW SLAVE STATUS\G

-- 查看这些字段
Replicate_Do_DB:                -- 只复制这些数据库
Replicate_Ignore_DB:            -- 忽略这些数据库  
Replicate_Do_Table:             -- 只复制这些表
Replicate_Ignore_Table:         -- 忽略这些表
Replicate_Wild_Do_Table:        -- 通配符复制表
Replicate_Wild_Ignore_Table:    -- 通配符忽略表
```

**配置文件检查**
```ini
# my.cnf 从库配置
[mysqld]
# 只复制特定数据库
replicate-do-db=app_db
replicate-do-db=log_db

# 忽略特定表
replicate-ignore-table=app_db.temp_table
replicate-ignore-table=app_db.cache_table
```

### 3.2 字符集不一致


**问题表现**：中文数据在主从库显示不同

```sql
-- 检查字符集设置
-- 主库和从库都执行
SHOW VARIABLES LIKE 'character_set%';
SHOW VARIABLES LIKE 'collation%';

-- 检查表字符集
SELECT 
    table_name,
    table_collation
FROM information_schema.tables 
WHERE table_schema = 'your_database';

-- 检查字段字符集
SELECT 
    table_name,
    column_name,
    character_set_name,
    collation_name
FROM information_schema.columns 
WHERE table_schema = 'your_database'
AND character_set_name IS NOT NULL;
```

**常见字符集问题**
```
主库：utf8mb4 (支持emoji)
从库：utf8 (不支持emoji)

结果：包含emoji的数据无法正确复制
```

### 3.3 时区设置差异


**问题场景**：时间字段在主从库显示不同

```sql
-- 检查时区设置
SHOW VARIABLES LIKE '%time_zone%';

-- 常见问题
主库：time_zone = '+08:00'  (北京时间)
从库：time_zone = 'SYSTEM'  (系统时间，可能是UTC)
```

**时区不一致的影响**
```sql
-- 主库插入数据
INSERT INTO logs (message, created_at) 
VALUES ('test', '2025-01-15 14:30:00');

-- 主库查询：2025-01-15 14:30:00
-- 从库查询：2025-01-15 06:30:00 (相差8小时)
```

### 3.4 表结构不一致


**常见结构差异**

| 问题类型 | **主库** | **从库** | **后果** |
|---------|---------|---------|---------|
| **缺少字段** | `有updated_at字段` | `无updated_at字段` | `复制中断` |
| **字段类型不同** | `INT` | `VARCHAR` | `数据转换错误` |
| **索引不同** | `有唯一索引` | `无唯一索引` | `允许重复数据` |
| **默认值不同** | `DEFAULT 0` | `DEFAULT NULL` | `数据不一致` |

**检查表结构**
```sql
-- 生成表结构对比脚本
SELECT 
    CONCAT('-- Table: ', table_name) as comment,
    CONCAT('SHOW CREATE TABLE ', table_name, ';') as show_create
FROM information_schema.tables 
WHERE table_schema = 'your_database'
ORDER BY table_name;
```

---

## 4. 🔧 主从数据对比工具


### 4.1 pt-table-checksum 工具


**什么是pt-table-checksum**：专门用来检查主从数据是否一致的工具

**安装和使用**
```bash
# 安装 percona-toolkit
# CentOS/RHEL
yum install percona-toolkit

# Ubuntu/Debian  
apt-get install percona-toolkit

# 基本使用
pt-table-checksum \
  --host=主库IP \
  --user=检查用户 \
  --password=密码 \
  --databases=数据库名 \
  --tables=表名
```

**检查结果解读**
```
TS            ERRORS  DIFFS  ROWS  CHUNKS  SKIPPED    TIME TABLE
01-15T14:30:01      0      1  1000       4        0   0.125 app_db.users
01-15T14:30:02      0      0  5000      10        0   0.234 app_db.orders
```

- **ERRORS**: 错误数量，应该为0
- **DIFFS**: 差异数量，0表示一致
- **ROWS**: 检查的行数
- **TIME**: 检查耗时

### 4.2 自定义数据对比脚本


**简单的数据量对比**
```bash
#!/bin/bash
# compare_table_rows.sh

MASTER_HOST="192.168.1.10"
SLAVE_HOST="192.168.1.11"
DATABASE="app_db"
USER="monitor"
PASSWORD="password"

# 获取所有表名
TABLES=$(mysql -h$MASTER_HOST -u$USER -p$PASSWORD -e "SHOW TABLES FROM $DATABASE" | grep -v Tables_in)

echo "表名,主库行数,从库行数,差异"
for table in $TABLES; do
    master_count=$(mysql -h$MASTER_HOST -u$USER -p$PASSWORD -e "SELECT COUNT(*) FROM $DATABASE.$table" | tail -1)
    slave_count=$(mysql -h$SLAVE_HOST -u$USER -p$PASSWORD -e "SELECT COUNT(*) FROM $DATABASE.$table" | tail -1)
    diff=$((master_count - slave_count))
    echo "$table,$master_count,$slave_count,$diff"
done
```

**数据内容校验脚本**
```sql
-- 创建校验函数
DELIMITER $$
CREATE FUNCTION table_checksum(db_name VARCHAR(64), table_name VARCHAR(64))
RETURNS VARCHAR(32)
READS SQL DATA
BEGIN
    DECLARE result VARCHAR(32);
    SET @sql = CONCAT('SELECT MD5(GROUP_CONCAT(
        MD5(CONCAT_WS(",", ', 
        (SELECT GROUP_CONCAT(column_name) 
         FROM information_schema.columns 
         WHERE table_schema = "', db_name, '" 
         AND table_name = "', table_name, '"'), '))
    )) FROM ', db_name, '.', table_name);
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    RETURN @result;
END$$
DELIMITER ;
```

---

## 5. 🔧 数据同步修复策略


### 5.1 重新同步（最安全）


**什么时候用重新同步**：
- 数据差异很大
- 不确定具体哪些数据有问题
- 有充足的维护时间

**重新同步步骤**
```sql
-- 步骤1：停止从库复制
STOP SLAVE;

-- 步骤2：主库锁表并备份
-- 在主库执行
FLUSH TABLES WITH READ LOCK;
SHOW MASTER STATUS;  -- 记录位置

-- 步骤3：导出数据
mysqldump -h主库IP -u用户 -p密码 \
  --single-transaction \
  --routines \
  --triggers \
  数据库名 > backup.sql

-- 步骤4：主库解锁
UNLOCK TABLES;

-- 步骤5：从库导入数据
mysql -h从库IP -u用户 -p密码 数据库名 < backup.sql

-- 步骤6：重新配置复制
CHANGE MASTER TO
  MASTER_LOG_FILE='记录的日志文件',
  MASTER_LOG_POS=记录的位置;

-- 步骤7：启动复制
START SLAVE;
```

### 5.2 pt-table-sync 修复


**增量修复方法**：只修复有差异的数据

```bash
# 先用 pt-table-checksum 找出差异
pt-table-checksum --host=主库IP --user=用户 --password=密码

# 然后用 pt-table-sync 修复差异
pt-table-sync \
  --execute \  # 真正执行修复
  --host=主库IP \
  --user=用户 \
  --password=密码 \
  数据库名.表名
```

**修复单个表**
```bash
# 只修复特定表
pt-table-sync \
  --execute \
  --print \    # 显示执行的SQL
  h=主库IP,u=用户,p=密码 \
  h=从库IP,u=用户,p=密码 \
  --databases app_db \
  --tables users
```

### 5.3 手动数据修复


**适用场景**：差异很少，可以手动处理

**缺失数据修复**
```sql
-- 1. 找出主库有而从库没有的数据
-- 在主库执行
SELECT * FROM users 
WHERE id NOT IN (
    SELECT id FROM users  -- 这里需要连接从库查询
);

-- 2. 导出缺失数据
mysqldump -h主库IP -u用户 -p密码 \
  --where="id IN (123,124,125)" \
  数据库名 表名 > missing_data.sql

-- 3. 导入到从库
mysql -h从库IP -u用户 -p密码 数据库名 < missing_data.sql
```

**内容不一致修复**
```sql
-- 比较主从库特定记录
-- 主库
SELECT * FROM orders WHERE id = 1001;

-- 从库  
SELECT * FROM orders WHERE id = 1001;

-- 手动更新从库（如果确认主库数据正确）
UPDATE orders 
SET status = 'completed', updated_at = '2025-01-15 14:30:00'
WHERE id = 1001;
```

---

## 6. 🛡️ 预防措施与最佳实践


### 6.1 复制配置最佳实践


**从库配置优化**
```ini
# my.cnf 从库配置
[mysqld]
# 基础复制配置
server-id = 2
log-bin = mysql-bin
relay-log = relay-bin

# 安全配置
read-only = 1                    # 从库只读
super-read-only = 1              # 超级用户也只读
slave-skip-errors = 1062,1032    # 跳过特定错误（谨慎使用）

# 性能配置
slave-parallel-workers = 4       # 并行复制线程数
slave-parallel-type = LOGICAL_CLOCK
relay-log-info-repository = TABLE
master-info-repository = TABLE

# 一致性配置
sync-relay-log = 1
sync-relay-log-info = 1
```

**主库配置优化**
```ini
# my.cnf 主库配置
[mysqld]
server-id = 1
log-bin = mysql-bin

# 二进制日志配置
binlog-format = ROW              # 行格式，最安全
binlog-row-image = FULL          # 记录完整行信息
sync-binlog = 1                  # 每次提交都同步到磁盘
expire-logs-days = 7             # 日志保留天数

# 事务配置
innodb-flush-log-at-trx-commit = 1  # 每次事务提交都刷盘
```

### 6.2 监控和告警设置


**复制延迟监控**
```sql
-- 创建监控脚本
#!/bin/bash
# monitor_replication.sh

SLAVE_HOST="192.168.1.11"
USER="monitor"
PASSWORD="password"
THRESHOLD=10  # 延迟阈值(秒)

delay=$(mysql -h$SLAVE_HOST -u$USER -p$PASSWORD -e "SHOW SLAVE STATUS\G" | grep Seconds_Behind_Master | awk '{print $2}')

if [ "$delay" = "NULL" ]; then
    echo "复制已停止！"
    # 发送告警
elif [ "$delay" -gt "$THRESHOLD" ]; then
    echo "复制延迟: ${delay}秒，超过阈值！"
    # 发送告警
else
    echo "复制正常，延迟: ${delay}秒"
fi
```

**数据一致性检查定时任务**
```bash
# crontab 配置
# 每天凌晨2点检查数据一致性
0 2 * * * /usr/bin/pt-table-checksum --host=主库IP --user=检查用户 --password=密码 --quiet
```

### 6.3 应用层面的预防


**读写分离注意事项**

```
应用设计原则：
1. 写操作后立即读取 → 从主库读
2. 统计报表等延迟不敏感 → 从从库读  
3. 重要业务逻辑 → 从主库读写
4. 缓存更新 → 基于主库数据
```

**代码示例**
```python
# Python 示例
class DatabaseManager:
    def __init__(self):
        self.master_db = connect_to_master()
        self.slave_db = connect_to_slave()
    
    def create_order(self, order_data):
        # 写操作用主库
        order_id = self.master_db.insert('orders', order_data)
        return order_id
    
    def get_order(self, order_id, from_master=False):
        if from_master:
            # 重要查询用主库
            return self.master_db.select('orders', order_id)
        else:
            # 一般查询用从库
            return self.slave_db.select('orders', order_id)
    
    def get_order_after_create(self, order_id):
        # 创建后立即查询，必须用主库
        return self.get_order(order_id, from_master=True)
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 主从不一致：主库和从库的数据不完全相同
🔸 检查方法：pt-table-checksum + 手动SQL检查
🔸 常见原因：复制过滤、字符集、时区、表结构差异  
🔸 修复策略：重新同步、pt-table-sync、手动修复
🔸 预防措施：正确配置、监控告警、应用设计
```

### 7.2 关键理解要点


**🔹 数据一致性的重要性**
```
业务影响：
- 用户体验：下单后查不到订单
- 决策错误：基于错误数据做决策
- 财务风险：报表数据不准确
- 系统稳定：缓存更新异常
```

**🔹 检查方法的选择**
```
日常检查：
- pt-table-checksum：全面检查
- 自定义脚本：特定业务检查
- 监控系统：实时状态检查

紧急排查：
- SHOW SLAVE STATUS：复制状态
- 表行数对比：快速发现问题
- 关键数据抽查：确认影响范围
```

**🔹 修复策略的权衡**
```
重新同步：
✅ 最安全可靠
❌ 停机时间长

增量修复：
✅ 停机时间短
❌ 可能有遗漏

手动修复：
✅ 精确可控
❌ 工作量大
```

### 7.3 实际应用指导


**故障处理流程**
```
1. 快速评估：检查复制状态和延迟
2. 影响分析：确定数据差异范围和业务影响
3. 应急措施：必要时切换应用到主库读取
4. 制定方案：根据差异程度选择修复方法
5. 执行修复：按计划执行修复操作
6. 验证结果：确认数据一致性恢复
7. 预防改进：分析原因并优化配置
```

**日常维护建议**
- **每日检查**：复制状态和延迟
- **每周检查**：数据一致性全面检查
- **每月回顾**：分析历史问题和趋势
- **季度优化**：配置参数调整和性能优化

**核心记忆要点**：
- 主从不一致影响业务，必须及时发现和处理
- pt-table-checksum是最可靠的检查工具
- 重新同步是最安全的修复方法
- 预防胜于治疗，正确配置是关键
- 应用层面的读写分离设计要考虑一致性需求