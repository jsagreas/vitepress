---
title: 18、慢查询性能故障
---
## 📚 目录


1. [慢查询基础概念](#1-慢查询基础概念)
2. [慢查询日志分析](#2-慢查询日志分析)
3. [查询执行计划异常诊断](#3-查询执行计划异常诊断)
4. [索引失效问题排查](#4-索引失效问题排查)
5. [统计信息与优化器问题](#5-统计信息与优化器问题)
6. [临时表与缓冲区问题](#6-临时表与缓冲区问题)
7. [查询缓存相关问题](#7-查询缓存相关问题)
8. [性能回归分析方法](#8-性能回归分析方法)
9. [故障排查流程总结](#9-故障排查流程总结)

---

## 1. 🐌 慢查询基础概念



### 1.1 什么是慢查询



**💡 简单理解**：慢查询就是执行时间超过设定阈值的SQL语句，就像排队买东西时有人办事特别慢一样

```
正常查询：   [SQL] -----> [结果]  (0.1秒)
慢查询：     [SQL] -----------> [结果]  (5秒)

影响：阻塞其他操作，占用数据库资源，用户等待时间长
```

**🔸 慢查询的危害**
- **用户体验差**：页面加载慢，操作卡顿
- **资源占用**：CPU、内存、磁盘IO被大量消耗  
- **连锁反应**：一个慢查询可能导致整个系统变慢
- **并发下降**：数据库连接被占用，处理能力下降

### 1.2 慢查询阈值设置



**⚙️ 关键参数**：`long_query_time`

```sql
-- 查看当前慢查询阈值（单位：秒）
SHOW VARIABLES LIKE 'long_query_time';

-- 设置慢查询阈值为2秒
SET GLOBAL long_query_time = 2;

-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;
```

**🎯 阈值设置建议**
- **在线系统**：1-2秒（用户体验要求高）
- **数据分析**：5-10秒（复杂查询较多）
- **批处理**：10-30秒（大数据量处理）

---

## 2. 📊 慢查询日志分析



### 2.1 慢查询日志位置与格式



**📂 日志文件位置**
```sql
-- 查看慢查询日志配置
SHOW VARIABLES LIKE '%slow_query%';

-- 典型输出
slow_query_log          = ON
slow_query_log_file     = /var/lib/mysql/slow.log
```

**📄 日志格式解读**
```
# Time: 2025-01-15T10:30:45.123456Z

# User@Host: app_user[app_user] @  [192.168.1.100]

# Thread_id: 12345  Schema: ecommerce  QC_hit: No

# Query_time: 5.234567  Lock_time: 0.000123

# Rows_sent: 1000  Rows_examined: 500000

SET timestamp=1705314645;
SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.created_at > '2025-01-01';
```

**🔍 字段含义说明**
- `Query_time`：**查询总耗时**，包括等待和执行时间
- `Lock_time`：**锁等待时间**，等待获取锁的时间
- `Rows_sent`：**返回行数**，查询结果的记录数
- `Rows_examined`：**扫描行数**，检查过的记录数（关键指标）

### 2.2 使用mysqldumpslow分析



**🛠️ mysqldumpslow工具**：MySQL自带的慢查询日志分析工具

```bash
# 显示执行时间最长的10条查询

mysqldumpslow -s t -t 10 /var/lib/mysql/slow.log

# 显示返回记录数最多的10条查询  

mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log

# 显示访问次数最多的10条查询

mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log

# 获取含有left join的查询

mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/slow.log
```

**📈 分析重点关注**
```
关注指标优先级：
1️⃣ Count（出现次数）- 频繁执行的慢查询影响最大
2️⃣ Time（平均执行时间）- 单次耗时长的查询  
3️⃣ Rows（扫描行数）- 全表扫描或大范围扫描
4️⃣ Lock（锁等待时间）- 并发冲突问题
```

### 2.3 pt-query-digest工具



**🔧 更强大的分析工具**：Percona Toolkit中的pt-query-digest

```bash
# 安装Percona Toolkit

yum install percona-toolkit

# 分析慢查询日志

pt-query-digest /var/lib/mysql/slow.log

# 生成详细报告

pt-query-digest --review h=localhost,D=test,t=query_review \
  --create-review-table /var/lib/mysql/slow.log
```

**📊 pt-query-digest优势**
- **查询指纹**：将相似查询归类分析
- **统计信息**：更详细的执行统计
- **可视化**：更友好的报告格式
- **历史对比**：支持历史数据对比分析

---

## 3. 🔍 查询执行计划异常诊断



### 3.1 EXPLAIN执行计划基础



**💡 什么是执行计划**：MySQL告诉你它打算如何执行这条SQL的"作战计划"

```sql
-- 查看执行计划
EXPLAIN SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.created_at > '2025-01-01';
```

**📋 EXPLAIN输出字段解读**

| 字段 | 含义 | 重点关注 |
|------|------|----------|
| `id` | 查询序列号 | 执行顺序 |
| `select_type` | 查询类型 | 子查询、联合查询等 |
| `table` | 表名 | 涉及的表 |
| `type` | 访问类型 | **性能关键指标** |
| `key` | 使用的索引 | 是否用上索引 |
| `rows` | 扫描行数 | **性能关键指标** |
| `Extra` | 额外信息 | 临时表、排序等 |

### 3.2 type字段性能分析



**🚦 访问类型性能排序**（从好到坏）

```
性能等级：
🟢 system > const > eq_ref > ref > range
🟡 index > ALL 🔴

详细说明：
┌─────────┬──────────────┬─────────────────┐
│ 类型    │ 性能级别     │ 典型场景        │
├─────────┼──────────────┼─────────────────┤
│ const   │ 🟢 最优      │ 主键或唯一索引  │
│ eq_ref  │ 🟢 很好      │ 主键JOIN        │
│ ref     │ 🟢 好        │ 普通索引等值查询│
│ range   │ 🟡 一般      │ 范围查询        │
│ index   │ 🔴 差        │ 索引全扫描      │
│ ALL     │ 🔴 最差      │ 全表扫描        │
└─────────┴──────────────┴─────────────────┘
```

**⚠️ 危险信号识别**
```sql
-- 全表扫描 - 最需要优化
type = ALL AND rows > 1000

-- 索引全扫描 - 需要关注  
type = index AND rows很大

-- 范围扫描行数过多 - 可能需要优化
type = range AND rows > 10000
```

### 3.3 Extra字段重要信息



**📝 Extra字段关键信息解读**

```
🔴 需要立即优化：
- Using filesort        ：需要额外排序（无法使用索引排序）
- Using temporary       ：使用临时表
- Using where; Using join buffer：JOIN缓冲区，通常因为没有合适索引

🟡 需要关注：
- Using index condition ：索引条件下推
- Using where          ：WHERE条件过滤

🟢 良好状态：
- Using index          ：覆盖索引，性能很好
- Using index for group-by：GROUP BY使用索引
```

**🛠️ 实际案例分析**

```sql
-- 问题SQL
EXPLAIN SELECT customer_name, order_total 
FROM orders o JOIN customers c ON o.customer_id = c.id 
WHERE o.created_at BETWEEN '2024-01-01' AND '2024-12-31' 
ORDER BY o.created_at DESC;

-- 可能的问题执行计划
┌─────┬─────────┬───────┬──────┬─────┬──────────┬────────────────────────┐
│ id  │ table   │ type  │ key  │ rows │ Extra                            │
├─────┼─────────┼───────┼──────┼─────┼──────────┼────────────────────────┤
│  1  │ o       │ ALL   │ NULL │50000│ Using where; Using filesort      │
│  1  │ c       │ eq_ref│ PK   │   1 │ NULL                            │
└─────┴─────────┴───────┴──────┴─────┴──────────┴────────────────────────┘

问题分析：
❌ orders表全表扫描（type=ALL）
❌ 需要额外排序（Using filesort）
❌ 扫描5万行数据
```

---

## 4. 🔑 索引失效问题排查



### 4.1 常见索引失效场景



**🚫 索引失效的典型原因**

#### **函数操作导致失效**


```sql
-- ❌ 错误：对索引列使用函数
SELECT * FROM orders WHERE YEAR(created_at) = 2024;

-- ✅ 正确：避免函数操作
SELECT * FROM orders 
WHERE created_at >= '2024-01-01' 
AND created_at < '2025-01-01';
```

#### **隐式类型转换**


```sql
-- ❌ 错误：字符串列与数字比较
SELECT * FROM users WHERE phone = 13800138000;  -- phone是varchar

-- ✅ 正确：类型匹配
SELECT * FROM users WHERE phone = '13800138000';
```

#### **LIKE通配符位置**


```sql
-- ❌ 错误：前导通配符
SELECT * FROM products WHERE product_name LIKE '%iPhone%';

-- ✅ 正确：后置通配符可以使用索引
SELECT * FROM products WHERE product_name LIKE 'iPhone%';
```

#### **OR条件使用不当**


```sql
-- ❌ 错误：OR条件中有非索引列
SELECT * FROM orders WHERE order_id = 123 OR remark LIKE '%urgent%';

-- ✅ 正确：使用UNION或确保所有列都有索引
SELECT * FROM orders WHERE order_id = 123
UNION 
SELECT * FROM orders WHERE remark LIKE '%urgent%';
```

### 4.2 索引选择性分析



**📊 什么是索引选择性**：索引列不同值的比例，选择性越高索引效果越好

```sql
-- 计算列的选择性
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) as selectivity,
    COUNT(DISTINCT column_name) as unique_values,
    COUNT(*) as total_rows
FROM table_name;

-- 示例：分析用户表性别列的选择性
SELECT 
    COUNT(DISTINCT gender) / COUNT(*) as selectivity,
    COUNT(DISTINCT gender) as unique_values
FROM users;
-- 结果：selectivity = 0.5 (男/女两个值，选择性较低)
```

**🎯 选择性评估标准**
```
索引选择性评判：
🟢 > 0.8  ：选择性很高，索引效果好
🟡 0.3-0.8：选择性中等，可考虑复合索引  
🔴 < 0.3  ：选择性低，单独建索引意义不大

实际建议：
- 主键、唯一键：选择性 = 1.0（最佳）
- 用户ID、订单号：选择性通常很高
- 状态、类型字段：选择性通常较低
```

### 4.3 复合索引使用问题



**📚 复合索引的最左前缀原则**

```sql
-- 创建复合索引
CREATE INDEX idx_user_city_age ON users(city, age, gender);

-- ✅ 可以使用索引的查询
SELECT * FROM users WHERE city = '北京';                    -- 使用索引
SELECT * FROM users WHERE city = '北京' AND age = 25;       -- 使用索引  
SELECT * FROM users WHERE city = '北京' AND age = 25 AND gender = 'M'; -- 使用索引

-- ❌ 无法使用索引的查询
SELECT * FROM users WHERE age = 25;                         -- 跳过了city
SELECT * FROM users WHERE gender = 'M';                     -- 跳过了city和age
SELECT * FROM users WHERE city = '北京' AND gender = 'M';   -- 跳过了age
```

**🔍 复合索引优化技巧**

```
索引列顺序优化原则：
1️⃣ 等值查询的列放前面
2️⃣ 选择性高的列放前面  
3️⃣ 查询频率高的列放前面
4️⃣ 范围查询的列放最后

示例设计：
订单查询索引：(status, user_id, created_at)
- status: 等值查询频繁
- user_id: 选择性高
- created_at: 通常做范围查询
```

---

## 5. 📈 统计信息与优化器问题



### 5.1 统计信息的作用



**💡 什么是统计信息**：MySQL收集的关于表和索引的数据分布信息，优化器据此制定执行计划

```
统计信息包含：
┌─────────────────┬──────────────────────┐
│ 信息类型        │ 作用                 │
├─────────────────┼──────────────────────┤
│ 表行数          │ 估算查询成本         │
│ 索引基数        │ 判断索引选择性       │
│ 数据分布        │ 优化JOIN顺序         │
│ NULL值比例      │ 影响WHERE条件估算    │
└─────────────────┴──────────────────────┘
```

### 5.2 统计信息过期问题



**⚠️ 统计信息过期的症状**
- 执行计划突然变差
- 原本快的查询变慢
- 优化器选择了错误的索引
- JOIN顺序不合理

**🔧 检查和更新统计信息**

```sql
-- 查看表的统计信息
SELECT table_name, table_rows, avg_row_length, data_length
FROM information_schema.tables 
WHERE table_schema = 'your_database';

-- 查看索引统计信息
SELECT table_name, index_name, cardinality
FROM information_schema.statistics 
WHERE table_schema = 'your_database'
ORDER BY table_name, seq_in_index;

-- 手动更新统计信息
ANALYZE TABLE table_name;

-- 批量更新所有表统计信息
SELECT CONCAT('ANALYZE TABLE ', table_name, ';') 
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

**📅 统计信息更新策略**
```
自动更新触发条件：
- 表数据变化超过10%时自动触发
- 可通过innodb_stats_auto_recalc控制

手动更新时机：
🔸 大批量数据导入后
🔸 删除大量数据后  
🔸 发现执行计划异常时
🔸 定期维护（如每周一次）
```

### 5.3 优化器提示和强制索引



**🎯 当优化器选择错误时的干预方法**

```sql
-- 强制使用特定索引
SELECT * FROM orders USE INDEX(idx_created_at) 
WHERE created_at > '2024-01-01';

-- 忽略特定索引
SELECT * FROM orders IGNORE INDEX(idx_status) 
WHERE status = 'completed';

-- 强制索引（比USE INDEX更强制）
SELECT * FROM orders FORCE INDEX(idx_user_created) 
WHERE user_id = 123 AND created_at > '2024-01-01';
```

**⚠️ 使用强制索引的注意事项**
```
💡 使用场景：
✅ 统计信息明显过期且无法及时更新
✅ 优化器选择明显错误的执行计划
✅ 临时解决性能问题

⚠️ 潜在风险：
❌ 数据变化后可能不再适用
❌ 影响SQL的可移植性
❌ 可能掩盖真正的问题

🔧 最佳实践：
- 优先修复根本问题（更新统计信息）
- 临时使用，定期review
- 添加注释说明使用原因
```

---

## 6. 💾 临时表与缓冲区问题



### 6.1 临时表产生原因



**📝 什么时候会产生临时表**：当MySQL无法在内存中完成操作时，会创建临时表

```
临时表产生的典型场景：

🔸 ORDER BY子句无法使用索引排序
🔸 GROUP BY子句无法使用索引分组
🔸 DISTINCT操作需要去重
🔸 UNION操作合并结果集
🔸 子查询中的大结果集
🔸 复杂的JOIN操作
```

**🔍 识别临时表使用**

```sql
-- 查看临时表使用情况
SHOW SESSION STATUS LIKE 'Created_tmp%';

-- 输出示例
Created_tmp_disk_tables    : 125    -- 磁盘临时表数量（关注重点）
Created_tmp_files         : 6      -- 临时文件数量  
Created_tmp_tables        : 1580   -- 总临时表数量

-- 临时表使用率计算
SELECT 
    (Created_tmp_disk_tables / Created_tmp_tables) * 100 as disk_tmp_table_pct;
```

**🚨 危险信号**
```
磁盘临时表比例 > 25%：需要优化
磁盘临时表比例 > 50%：严重问题

影响：
- 磁盘IO增加，性能显著下降
- 查询时间大幅增长
- 系统负载升高
```

### 6.2 排序缓冲区问题



**⚙️ 排序缓冲区参数**

```sql
-- 查看排序相关参数
SHOW VARIABLES LIKE '%sort%';

-- 关键参数说明
sort_buffer_size        = 2M      -- 每个连接的排序缓冲区大小
max_sort_length        = 1024     -- 排序字段最大长度
max_length_for_sort_data = 4096   -- 排序数据最大长度
```

**🔧 排序缓冲区优化**

```sql
-- 查看排序操作统计
SHOW SESSION STATUS LIKE 'Sort%';

-- 关键指标解读
Sort_merge_passes      : 0        -- 多路归并次数（应该为0）
Sort_range            : 156       -- 范围排序次数
Sort_rows             : 58000     -- 排序行数
Sort_scan             : 12        -- 全表扫描排序次数

-- 如果Sort_merge_passes > 0，需要增加缓冲区
SET sort_buffer_size = 4 * 1024 * 1024;  -- 增加到4MB
```

### 6.3 临时表优化策略



**🎯 减少临时表使用的方法**

#### **优化ORDER BY**


```sql
-- ❌ 产生临时表的查询
SELECT user_id, COUNT(*) as order_count 
FROM orders 
GROUP BY user_id 
ORDER BY order_count DESC;

-- ✅ 优化后（如果有合适索引）
SELECT user_id, COUNT(*) as order_count 
FROM orders 
GROUP BY user_id 
ORDER BY user_id;  -- 利用GROUP BY的索引顺序
```

#### **优化GROUP BY**


```sql
-- 创建合适的索引支持GROUP BY
CREATE INDEX idx_orders_user_status ON orders(user_id, status);

-- GROUP BY可以利用索引，避免临时表
SELECT user_id, status, COUNT(*) 
FROM orders 
GROUP BY user_id, status;
```

#### **增加内存缓冲区**


```sql
-- 增加临时表内存限制
SET tmp_table_size = 64 * 1024 * 1024;     -- 64MB
SET max_heap_table_size = 64 * 1024 * 1024; -- 64MB

-- 注意：两个参数取较小值生效
```

---

## 7. 🗂️ 查询缓存相关问题



### 7.1 查询缓存机制



**💡 查询缓存工作原理**：MySQL将查询结果缓存在内存中，相同查询直接返回缓存结果

```
查询缓存流程：
┌─────────┐    ┌──────────┐    ┌─────────┐
│ SQL查询 │───▶│ 缓存检查 │───▶│ 返回结果│
└─────────┘    └──────────┘    └─────────┘
                     │
                     ▼ 缓存未命中
               ┌──────────┐    ┌─────────┐
               │ 执行查询 │───▶│ 缓存结果│
               └──────────┘    └─────────┘
```

**⚙️ 查询缓存参数**
```sql
-- 查看查询缓存配置
SHOW VARIABLES LIKE 'query_cache%';

-- 关键参数说明
query_cache_type = ON           -- 是否启用查询缓存
query_cache_size = 16M          -- 缓存总大小
query_cache_limit = 1M          -- 单个查询结果最大缓存大小
query_cache_min_res_unit = 4K   -- 缓存块最小单位
```

### 7.2 查询缓存性能监控



**📊 缓存效果分析**

```sql
-- 查看查询缓存状态
SHOW STATUS LIKE 'Qcache%';

-- 关键指标解读
Qcache_hits             : 158000   -- 缓存命中次数
Qcache_inserts          : 25000    -- 缓存插入次数  
Qcache_not_cached       : 13000    -- 未缓存查询次数
Qcache_queries_in_cache : 1200     -- 当前缓存的查询数
Qcache_free_memory      : 12M      -- 剩余缓存内存

-- 计算缓存命中率
SELECT 
    Qcache_hits / (Qcache_hits + Qcache_inserts + Qcache_not_cached) * 100 
    as cache_hit_rate;
```

**🎯 缓存效果评估**
```
缓存命中率评估：
🟢 > 80%  ：缓存效果很好
🟡 50-80% ：缓存效果一般，可优化
🔴 < 50%  ：缓存效果差，考虑关闭

低命中率原因：
❌ 查询结果变化频繁
❌ 查询语句差异较大  
❌ 表数据更新频繁
❌ 缓存空间不足
```

### 7.3 查询缓存使用问题



**⚠️ 查询缓存的副作用**

```
缓存失效触发条件：
🔸 表结构变化（ALTER TABLE）
🔸 任何数据修改（INSERT/UPDATE/DELETE）  
🔸 缓存空间不足时的LRU清理
🔸 服务器重启

高更新频率表的问题：
- 缓存频繁失效，命中率低
- 缓存维护开销大于收益
- 可能影响写入性能
```

**🔧 查询缓存优化策略**

```sql
-- 针对特定查询禁用缓存
SELECT SQL_NO_CACHE * FROM high_update_table;

-- 针对特定查询强制缓存
SELECT SQL_CACHE * FROM static_config_table;

-- 根据业务场景调整缓存策略
-- 适合缓存：配置表、字典表、报表数据
-- 不适合缓存：实时数据、频繁更新的表
```

**💡 现代替代方案**
```
MySQL 8.0已移除查询缓存，建议使用：
🔸 应用层缓存（Redis、Memcached）
🔸 查询结果集缓存
🔸 页面缓存
🔸 CDN缓存

优势：
- 更灵活的缓存策略
- 跨数据库实例共享
- 更好的缓存穿透处理
```

---

## 8. 📉 性能回归分析方法



### 8.1 性能基线建立



**📊 什么是性能基线**：系统正常运行时的性能标准，用于对比和发现性能退化

```
性能基线指标：
┌─────────────────┬─────────────────┬──────────────┐
│ 指标类型        │ 监控内容        │ 正常范围     │
├─────────────────┼─────────────────┼──────────────┤
│ 查询响应时间    │ 平均/P95/P99    │ < 100ms      │
│ QPS/TPS        │ 每秒查询/事务数  │ 1000-5000    │
│ 慢查询数量      │ 每分钟慢查询数  │ < 10个       │
│ 连接数         │ 活跃连接数      │ < 100        │
│ CPU使用率      │ 数据库CPU占用   │ < 70%        │
│ 内存使用率      │ 缓冲池命中率    │ > 95%        │
└─────────────────┴─────────────────┴──────────────┘
```

**🔧 建立基线的方法**

```sql
-- 收集性能快照
SELECT 
    SCHEMA_NAME as db_name,
    SUM(COUNT_STAR) as total_queries,
    SUM(SUM_TIMER_WAIT)/1000000000000 as total_time_sec,
    AVG(AVG_TIMER_WAIT)/1000000000 as avg_time_ms
FROM performance_schema.events_statements_summary_by_digest
GROUP BY SCHEMA_NAME;

-- 创建性能监控表存储历史数据
CREATE TABLE performance_baseline (
    id INT AUTO_INCREMENT PRIMARY KEY,
    metric_name VARCHAR(50),
    metric_value DECIMAL(10,2),
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 8.2 性能回归检测



**🚨 性能回归的识别信号**

```
回归检测指标：
🔴 响应时间增加 > 50%
🔴 慢查询数量增加 > 100%  
🔴 QPS下降 > 30%
🔴 CPU使用率增加 > 50%
🔴 错误率增加 > 10%

检测方法：
1️⃣ 实时监控告警
2️⃣ 定期性能报告对比
3️⃣ 用户反馈异常
4️⃣ 应用日志分析
```

**📈 性能趋势分析**

```sql
-- 查询最近一周的性能趋势
SELECT 
    DATE(recorded_at) as date,
    AVG(CASE WHEN metric_name = 'avg_query_time' THEN metric_value END) as avg_time,
    AVG(CASE WHEN metric_name = 'slow_query_count' THEN metric_value END) as slow_queries
FROM performance_baseline 
WHERE recorded_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY DATE(recorded_at)
ORDER BY date;

-- 计算性能变化百分比
SELECT 
    current_week.avg_time,
    last_week.avg_time,
    ((current_week.avg_time - last_week.avg_time) / last_week.avg_time) * 100 as change_pct
FROM 
    (SELECT AVG(metric_value) as avg_time FROM performance_baseline 
     WHERE metric_name = 'avg_query_time' AND recorded_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)) current_week,
    (SELECT AVG(metric_value) as avg_time FROM performance_baseline 
     WHERE metric_name = 'avg_query_time' AND recorded_at BETWEEN DATE_SUB(NOW(), INTERVAL 14 DAY) AND DATE_SUB(NOW(), INTERVAL 7 DAY)) last_week;
```

### 8.3 回归原因分析



**🔍 常见回归原因及排查方法**

#### **代码变更导致的回归**


```
排查重点：
🔸 新上线的SQL语句
🔸 查询条件的变化
🔸 JOIN逻辑的调整
🔸 索引的添加或删除

排查方法：
1. 对比上线前后的慢查询日志
2. 检查新增的SQL执行计划
3. 确认索引使用情况变化
```

#### **数据增长导致的回归**


```sql
-- 检查表数据增长情况
SELECT 
    table_name,
    table_rows,
    ROUND(data_length/1024/1024, 2) as data_size_mb,
    ROUND(index_length/1024/1024, 2) as index_size_mb
FROM information_schema.tables 
WHERE table_schema = 'your_database'
ORDER BY table_rows DESC;

-- 对比历史数据量
SELECT 
    CURDATE() as check_date,
    COUNT(*) as current_rows,
    (COUNT(*) - (SELECT baseline_rows FROM data_growth_baseline WHERE table_name = 'orders')) as growth
FROM orders;
```

#### **系统资源变化导致的回归**


```bash
# 检查系统资源使用情况

top -p $(pgrep mysqld)

# 检查磁盘IO情况  

iostat -x 1 5

# 检查内存使用情况

free -m

# 检查MySQL缓冲池状态

mysql> SHOW ENGINE INNODB STATUS\G
```

---

## 9. 🔧 故障排查流程总结



### 9.1 慢查询故障排查流程



```
慢查询问题排查步骤：

第一步：问题确认
├─ 确认慢查询数量和频率
├─ 识别最耗时的查询语句  
├─ 评估对业务的影响程度
└─ 收集用户反馈和错误日志

第二步：日志分析  
├─ 分析慢查询日志
├─ 使用mysqldumpslow或pt-query-digest
├─ 识别问题SQL的模式
└─ 统计各类查询的分布

第三步：执行计划检查
├─ EXPLAIN分析问题SQL
├─ 检查type、rows、Extra字段
├─ 确认索引使用情况
└─ 识别全表扫描和临时表

第四步：索引优化
├─ 检查索引是否存在
├─ 分析索引选择性
├─ 验证索引使用情况
└─ 创建或优化索引

第五步：统计信息更新
├─ 检查统计信息是否过期
├─ 手动更新表统计信息
├─ 验证执行计划改善
└─ 监控性能变化

第六步：系统参数优化
├─ 调整缓冲区大小
├─ 优化临时表参数
├─ 配置查询缓存
└─ 监控系统资源使用
```

### 9.2 应急处理方案



**🚨 线上慢查询应急处理**

```sql
-- 1. 立即识别正在执行的慢查询
SELECT 
    id, user, host, db, command, time, state, info
FROM information_schema.processlist 
WHERE time > 30 AND command != 'Sleep'
ORDER BY time DESC;

-- 2. 必要时终止异常查询
KILL QUERY thread_id;  -- 终止查询但保持连接
KILL CONNECTION thread_id;  -- 终止连接

-- 3. 临时禁用查询缓存（如果影响性能）
SET GLOBAL query_cache_type = OFF;

-- 4. 强制使用索引（临时措施）
-- 在问题SQL中添加FORCE INDEX提示
```

**⚡ 快速缓解措施**
```
优先级处理顺序：

🔴 紧急措施（5分钟内）：
- 终止异常的长时间查询
- 重启应用连接池
- 临时增加数据库连接数

🟡 短期措施（30分钟内）：
- 强制使用正确索引  
- 更新过期的统计信息
- 调整关键缓冲区参数

🟢 长期措施（1-3天内）：
- 创建缺失的索引
- 优化查询SQL语句
- 建立监控告警机制
```

### 9.3 预防措施



**🛡️ 慢查询预防策略**

```
代码层面：
✅ SQL代码review制度
✅ 强制使用EXPLAIN检查执行计划
✅ 禁止SELECT *，明确指定字段
✅ 合理使用分页，避免大结果集
✅ 避免复杂的子查询和多表JOIN

数据库层面：
✅ 定期维护索引，删除无用索引
✅ 定期更新统计信息
✅ 合理设置慢查询阈值
✅ 配置适当的缓冲区大小
✅ 定期分析慢查询日志

监控层面：
✅ 实时性能监控和告警
✅ 定期性能基线对比
✅ 自动化性能测试
✅ 容量规划和预测
✅ 故障应急响应流程
```

**📊 持续优化建议**

```
建立完善的性能管理体系：

📈 监控体系：
- 实时性能指标监控
- 慢查询自动分析报告
- 性能趋势分析
- 容量预警机制

🔧 优化流程：
- 定期SQL性能审计
- 索引使用效果评估  
- 参数配置优化review
- 硬件资源评估

📚 知识积累：
- 常见性能问题库
- 优化案例分享
- 最佳实践文档
- 团队培训计划
```

---

# 📋 核心要点总结



## 🎯 必须掌握的关键技能



**🔸 慢查询识别**：快速定位性能问题的根源
**🔸 执行计划分析**：理解MySQL的查询执行策略  
**🔸 索引优化**：合理设计和使用索引提升性能
**🔸 统计信息维护**：保证优化器做出正确决策
**🔸 系统参数调优**：优化缓冲区和临时表配置
**🔸 性能监控**：建立完善的性能基线和告警机制

## 💡 关键理解要点



**🔹 慢查询不仅仅是SQL问题**
```
系统性思考：
- SQL语句编写质量
- 索引设计是否合理
- 统计信息是否准确
- 系统参数是否优化
- 硬件资源是否充足
```

**🔹 性能优化是一个持续过程**
```
优化循环：
监控发现问题 → 分析根本原因 → 制定优化方案 → 
实施优化措施 → 验证优化效果 → 建立预防机制
```

**🔹 预防胜于治疗**
```
预防为主：
- 代码review和SQL规范
- 完善的监控告警体系
- 定期的性能健康检查
- 容量规划和预测
```

## 🚀 实际应用价值



- **快速故障定位**：通过系统化的排查流程快速定位问题
- **性能持续优化**：建立性能基线和趋势分析机制
- **预防性维护**：通过监控和规范减少性能问题发生
- **应急响应能力**：掌握线上问题的快速处理方法

**核心记忆**：
- 慢查询分析要看日志、执行计划、索引使用三个方面
- 索引失效通常由函数操作、类型转换、通配符使用不当造成
- 统计信息过期是执行计划突然变差的常见原因
- 临时表和磁盘排序是性能杀手，需要重点关注
- 性能回归分析需要建立基线和趋势监控
- 预防措施比故障处理更重要