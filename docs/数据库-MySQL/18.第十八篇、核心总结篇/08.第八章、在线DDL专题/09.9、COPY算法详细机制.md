---
title: 9、COPY算法详细机制
---
## 📚 目录

1. [COPY算法基本概念](#1-COPY算法基本概念)
2. [COPY算法工作原理](#2-COPY算法工作原理)
3. [临时表创建与数据拷贝](#3-临时表创建与数据拷贝)
4. [索引重建与表切换](#4-索引重建与表切换)
5. [资源消耗与性能影响](#5-资源消耗与性能影响)
6. [并发控制与回滚机制](#6-并发控制与回滚机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💿 COPY算法基本概念


### 1.1 什么是COPY算法


> 💡 **COPY算法**：MySQL中最传统的DDL操作方式，通过创建新表、拷贝数据、切换表名来完成表结构变更。

**本质理解**：
```
简单比喻：就像重新装修房子
- 先建一个新房子（临时表）
- 把旧房子的东西全部搬到新房子（数据拷贝）
- 拆掉旧房子，新房子改名（表切换）
```

**核心特点**：
- ✅ **兼容性强** - 支持所有MySQL版本和存储引擎
- ✅ **功能完整** - 可以处理任何类型的表结构变更
- ❌ **资源消耗大** - 需要额外磁盘空间和大量I/O
- ❌ **锁定时间长** - 整个过程表基本不可用

### 1.2 COPY算法的使用场景


**必须使用COPY的情况**：
```sql
-- 1. 修改列的数据类型（缩小精度）
ALTER TABLE users MODIFY COLUMN age TINYINT;

-- 2. 修改字符集
ALTER TABLE users CONVERT TO CHARACTER SET utf8mb4;

-- 3. 某些存储引擎不支持Online DDL的操作
ALTER TABLE myisam_table ADD COLUMN new_col INT;
```

**手动强制使用COPY**：
```sql
-- 明确指定使用COPY算法
ALTER TABLE users 
ADD COLUMN email VARCHAR(100),
ALGORITHM=COPY;
```

---

## 2. ⚙️ COPY算法工作原理


### 2.1 整体执行流程


```
COPY算法执行步骤：

步骤1: 表结构分析
    ↓
步骤2: 创建临时表
    ↓
步骤3: 数据逐行拷贝  ← 最耗时的阶段
    ↓
步骤4: 索引重建
    ↓
步骤5: 表名切换     ← 需要排他锁
    ↓
步骤6: 清理旧表
```

### 2.2 详细工作机制


**阶段一：准备阶段**
```
做什么：
- 解析ALTER语句，确定要修改的内容
- 检查表结构是否允许修改
- 创建新的表结构定义

锁定情况：
- 获取共享元数据锁（Shared MDL）
- 此时表可以正常读写

耗时：
- 很短，通常几毫秒
```

**阶段二：临时表创建**
```
做什么：
- 根据新的表结构创建临时表
- 临时表名通常为 #sql_序列号
- 设置与原表相同的存储引擎参数

文件系统变化：
原表：users.frm, users.ibd
新增：#sql_1234.frm, #sql_1234.ibd

注意事项：
- 临时表与原表在同一个数据目录
- 需要足够的磁盘空间
```

### 2.3 数据拷贝的具体过程


**逐行读取与写入**：
```
FOR 原表的每一行 {
    1. 从原表读取一行数据
    2. 根据新表结构转换数据格式
    3. 将转换后的数据写入临时表
    4. 处理默认值、计算列等特殊情况
}

数据流向：
原表磁盘 → 内存缓冲区 → 数据转换 → 临时表磁盘
```

**数据转换示例**：
```sql
-- 原表结构
CREATE TABLE users (
    id INT,
    name VARCHAR(50),
    age INT
);

-- 要修改为
ALTER TABLE users ADD COLUMN email VARCHAR(100) DEFAULT 'unknown@example.com';

-- 拷贝时的数据转换
原数据: (1, 'John', 25)
新数据: (1, 'John', 25, 'unknown@example.com')  -- 自动添加默认值
```

---

## 3. 📋 临时表创建与数据拷贝


### 3.1 临时表的创建过程


**临时表命名规则**：
```
格式：#sql_{进程ID}_{序列号}
示例：#sql_1a2b_0    (进程ID: 1a2b, 序列号: 0)

为什么这样命名：
- # 开头表示临时文件
- 包含进程ID避免冲突
- 序列号支持同一连接多个DDL操作
```

**临时表属性继承**：
```
从原表继承的属性：
✅ 存储引擎类型
✅ 字符集设置
✅ 表级别的选项（如 ROW_FORMAT）
✅ 分区信息（如果有）

不继承的属性：
❌ 自增计数器值（会重新计算）
❌ 表统计信息
❌ 触发器（DDL完成后重新关联）
```

### 3.2 数据拷贝的内部机制


**读取策略**：
```
MySQL如何读取原表数据：

顺序扫描（Sequential Scan）：
┌─────────────────────────────────┐
│ 页1 → 页2 → 页3 → ... → 页N    │
│  ↓     ↓     ↓           ↓      │
│ 读取   读取   读取       读取     │
└─────────────────────────────────┘

优点：I/O效率高，顺序读取速度快
缺点：大表耗时长，期间表几乎不可用
```

**写入策略**：
```
MySQL如何写入临时表：

批量写入优化：
- 使用较大的缓冲区
- 延迟索引更新
- 批量提交减少日志写入

写入顺序：
1. 先写入所有数据行
2. 再统一创建索引
3. 最后更新表统计信息
```

### 3.3 数据一致性保证


**事务处理机制**：
```
COPY算法的事务特点：

单个大事务：
- 整个拷贝过程在一个事务中
- 要么全部成功，要么全部回滚
- 产生大量的undo日志

示例：
BEGIN;
  -- 创建临时表
  -- 拷贝所有数据（可能几百万行）
  -- 重建所有索引
COMMIT;  -- 或者 ROLLBACK
```

**数据快照机制**：
```
如何保证数据一致性：

时间点快照：
拷贝开始时刻 = T0
┌──────────────────────────────┐
│ T0时刻的数据状态             │
│ 即使后续有新的DML操作       │
│ 拷贝过程中看到的仍是T0状态   │
└──────────────────────────────┘

实现原理：
- 利用MVCC（多版本并发控制）
- 读取一致性视图中的数据
- 忽略拷贝过程中的新增修改
```

---

## 4. 🔧 索引重建与表切换


### 4.1 索引重建过程


**索引重建的时机**：
```
为什么要重建索引：
- 新表结构可能改变了列定义
- 数据类型变更影响索引存储
- 需要为新增列创建索引

重建顺序：
1. 主键索引（PRIMARY KEY）
2. 唯一索引（UNIQUE KEY）  
3. 普通索引（KEY）
4. 全文索引（FULLTEXT）
```

**索引重建算法**：
```
内部排序 + 归并算法：

步骤1: 数据排序
┌─────────────────────────────┐
│ 内存排序缓冲区               │
│ [索引键值1, 索引键值2, ...] │
└─────────────────────────────┘
           ↓
步骤2: 写入索引页
┌─────────────────────────────┐
│ 索引页1 → 索引页2 → ...     │
└─────────────────────────────┘

参数影响：
sort_buffer_size: 排序缓冲区大小
myisam_sort_buffer_size: MyISAM引擎专用
```

### 4.2 原子表切换操作


**切换过程详解**：
```
表切换的关键步骤：

步骤1: 获取排他锁
┌─────────────────────────────┐
│ LOCK TABLES users WRITE     │  ← 此时表完全不可访问
└─────────────────────────────┘

步骤2: 原子重命名
原表：users → users_old
临时表：#sql_1234 → users

步骤3: 释放锁
┌─────────────────────────────┐
│ UNLOCK TABLES               │  ← 新表开始接受访问
└─────────────────────────────┘

步骤4: 删除旧表
DROP TABLE users_old;
```

**原子性保证机制**：
```
为什么表切换是原子的：

文件系统层面：
- 重命名操作在文件系统中是原子的
- 要么成功（用户看到新表）
- 要么失败（用户继续看到旧表）

MySQL层面：
- 数据字典的更新是事务性的
- 元数据锁确保操作的串行化
```

### 4.3 切换过程的锁定影响


**锁定时间分析**：
```
总DDL时间构成：

┌─ 准备阶段 ─┬─ 拷贝阶段 ─┬─ 切换阶段 ─┐
│ 几毫秒      │ 几分钟-几小时 │ 几秒钟      │
│ 共享锁      │ 共享锁        │ 排他锁      │
│ 可读写      │ 可读，写阻塞   │ 完全阻塞    │
└────────────┴──────────────┴────────────┘

关键理解：
- 大部分时间表是可读的
- 但写操作会被阻塞
- 只有最后几秒钟完全不可用
```

---

## 5. 📊 资源消耗与性能影响


### 5.1 磁盘空间需求


**空间需求计算**：
```
基本公式：
所需额外空间 = 原表大小 + 索引大小 + 临时空间

详细计算：
┌─────────────────────────────────────┐
│ 原表数据: 10GB                       │
│ 原表索引: 2GB                        │
│ 临时表数据: 10GB（完全复制）          │
│ 临时表索引: 2GB（重新构建）           │
│ 操作缓冲: 1GB（排序等临时用途）       │
│ ================================   │
│ 总计需要: 25GB 额外空间               │
└─────────────────────────────────────┘

安全建议：
预留 1.5-2 倍原表大小的空间
```

**空间不足的后果**：
```sql
-- 典型错误信息
ERROR 1114 (HY000): The table 'users' is full

-- 磁盘空间不足
ERROR 28 (HY000): No space left on device

-- 临时目录空间不足  
ERROR 126 (HY000): Incorrect key file for table 'users'; try to repair it
```

### 5.2 I/O资源消耗


**I/O操作分析**：
```
COPY算法的I/O模式：

读操作：
原表全表扫描: 顺序读取，I/O密集
┌──────────────────────────────┐
│ 磁盘 → 内存 → CPU处理        │
│ 1GB/s  速度受限于磁盘性能     │
└──────────────────────────────┘

写操作：
临时表数据写入: 顺序写入 + 随机写入
┌──────────────────────────────┐
│ 数据写入: 顺序，速度较快      │
│ 索引构建: 随机，速度较慢      │
└──────────────────────────────┘

总I/O量 ≈ 2 × 原表大小 + 索引重建开销
```

**性能优化参数**：
```sql
-- 关键配置参数
SET innodb_buffer_pool_size = '8G';      -- 增大缓冲池
SET sort_buffer_size = '256M';           -- 排序缓冲区
SET read_buffer_size = '2M';             -- 读缓冲区
SET bulk_insert_buffer_size = '256M';    -- 批量插入缓冲

-- 临时禁用不必要功能
SET foreign_key_checks = 0;              -- 临时禁用外键检查
SET unique_checks = 0;                   -- 临时禁用唯一性检查
```

### 5.3 操作时间估算


**时间估算公式**：
```
基础估算：
拷贝时间 = 数据量(GB) / 磁盘吞吐量(GB/s) × 1.5倍系数

示例计算：
原表大小: 100GB
磁盘读速度: 200MB/s
磁盘写速度: 150MB/s

读取时间: 100GB / 0.2GB/s = 500秒
写入时间: 100GB / 0.15GB/s = 667秒
索引重建: 额外200-300秒
总时间: ≈ 20-25分钟
```

**影响因素**：
```
时间影响因素权重分析：

磁盘类型:           ████████████ 40%
数据量大小:         ████████     30%
索引复杂度:         ██████       20%
系统负载:           ███          10%

具体对比：
HDD磁盘: 100MB/s   → 基线时间
SSD磁盘: 500MB/s   → 时间缩短80%
NVMe磁盘: 2GB/s    → 时间缩短95%
```

---

## 6. 🔒 并发控制与回滚机制


### 6.1 并发限制影响


**锁定级别详解**：
```
COPY算法的锁定机制：

元数据锁（MDL）层面：
┌─────────────────────────────────┐
│ DDL操作: 需要EXCLUSIVE MDL      │
│ SELECT: 需要SHARED MDL          │
│ INSERT/UPDATE/DELETE: 需要      │
│         SHARED_WRITE MDL        │
└─────────────────────────────────┘

冲突矩阵：
        │ DDL   │ SELECT │ DML   │
DDL     │ ❌    │ ❌     │ ❌    │
SELECT  │ ❌    │ ✅     │ ✅    │
DML     │ ❌    │ ✅     │ ✅    │
```

**实际并发影响**：
```sql
-- 场景1：DDL执行期间的查询
-- Session 1
ALTER TABLE users ADD COLUMN email VARCHAR(100);  -- 执行中

-- Session 2  
SELECT * FROM users WHERE id = 1;  
-- 状态：Waiting for table metadata lock

-- Session 3
INSERT INTO users (name, age) VALUES ('Alice', 25);
-- 状态：Waiting for table metadata lock
```

### 6.2 回滚机制实现


**回滚触发条件**：
```
什么情况下会回滚：

系统错误：
- 磁盘空间不足
- 内存不足
- 系统崩溃

数据错误：
- 数据类型转换失败
- 约束冲突
- 字符集转换错误

用户操作：
- 手动取消（KILL QUERY）
- 连接断开
```

**回滚过程详解**：
```
回滚的具体步骤：

步骤1: 停止数据拷贝
┌─────────────────────────────┐
│ 检测到错误或取消信号         │
│ 立即停止当前的拷贝操作       │
└─────────────────────────────┘

步骤2: 事务回滚
┌─────────────────────────────┐
│ ROLLBACK 当前DDL事务        │
│ 释放所有已分配的资源        │
└─────────────────────────────┘

步骤3: 清理临时文件
┌─────────────────────────────┐
│ 删除临时表文件              │
│ 清理相关的日志记录          │
└─────────────────────────────┘

步骤4: 释放锁
┌─────────────────────────────┐
│ 释放元数据锁                │
│ 表恢复正常访问状态          │
└─────────────────────────────┘
```

### 6.3 故障恢复机制


**崩溃恢复处理**：
```
MySQL重启后的处理：

发现场景：
- 存在 #sql_ 开头的临时文件
- DDL操作状态记录在binlog中
- 数据字典状态不一致

自动处理：
1. 检查临时表的完整性
2. 确定DDL操作的进度
3. 决定继续完成还是回滚

策略选择：
┌─────────────────────────────┐
│ 如果临时表完整且拷贝完成     │
│ → 尝试完成表切换            │
│                            │
│ 如果临时表不完整或损坏      │
│ → 删除临时表，回滚操作      │
└─────────────────────────────┘
```

**数据一致性保证**：
```
COPY算法的一致性机制：

原子性（Atomicity）：
- 整个DDL在一个事务中
- 要么全部成功，要么全部失败

一致性（Consistency）：
- 新表结构符合所有约束
- 数据转换正确无误

隔离性（Isolation）：
- 通过元数据锁实现
- 其他事务看不到中间状态

持久性（Durability）：
- 成功后的修改持久保存
- 失败后的状态完全恢复
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 COPY算法本质：通过创建新表、拷贝数据、切换表名完成DDL
🔸 执行阶段：准备→创建临时表→数据拷贝→索引重建→表切换→清理
🔸 资源需求：2倍磁盘空间，大量I/O，长时间锁定
🔸 并发影响：大部分时间可读，写操作被阻塞，切换时完全锁定
🔸 适用场景：不支持Online DDL的操作，或明确指定ALGORITHM=COPY
```

### 7.2 关键理解要点


**🔹 为什么COPY算法效率低**
```
根本原因：
- 需要完整拷贝所有数据（即使只修改表结构）
- 无法利用MySQL的增量修改能力
- I/O密集型操作，受磁盘性能限制

设计局限：
- 早期MySQL版本的唯一方案
- 为了保证兼容性而保留
- 某些复杂变更仍然必需
```

**🔹 临时表的作用和风险**
```
作用价值：
- 提供完整的数据备份
- 支持复杂的数据结构变更
- 保证操作的原子性

潜在风险：
- 磁盘空间不足导致失败
- 长时间占用大量资源
- 影响其他应用的性能
```

**🔹 锁定机制的平衡**
```
设计考虑：
- 大部分时间允许读取（维持业务基本可用）
- 阻塞写入（保证数据一致性）
- 最短时间完全锁定（原子切换）

实际影响：
- 查询操作基本不受影响
- 写入操作会排队等待
- 切换瞬间所有操作暂停
```

### 7.3 实际应用指导


**🔹 使用建议**
```
优先选择：
✅ 小表（< 1GB）的快速修改
✅ 不支持Online DDL的必要操作
✅ 测试环境的表结构调整

谨慎使用：
⚠️ 大表（> 10GB）的修改
⚠️ 高并发业务的生产环境
⚠️ 磁盘空间紧张的系统

避免使用：
❌ 超大表（> 100GB）除非必要
❌ 7×24关键业务系统
❌ 磁盘空间不足2倍表大小
```

**🔹 最佳实践**
```
操作前准备：
- 确认磁盘空间充足（2倍表大小）
- 选择业务低峰期执行
- 备份重要数据
- 评估预期执行时间

执行过程：
- 监控磁盘空间使用
- 关注系统负载变化
- 准备回滚方案
- 保持与业务方沟通

异常处理：
- 建立监控告警
- 准备快速回滚程序
- 设置操作超时时间
- 制定应急处理流程
```

### 7.4 性能优化要点


**🔹 硬件优化**
```
存储优化：
- 使用SSD替代HDD（提升5-10倍速度）
- 增大内存缓冲区配置
- 使用RAID提高I/O并发能力

系统优化：
- 调整MySQL缓冲池大小
- 优化排序缓冲区参数
- 临时禁用不必要的检查
```

**🔹 时机选择**
```
最佳时机：
- 业务低峰期（凌晨2-6点）
- 周末或节假日
- 维护窗口期

避免时机：
- 业务高峰期
- 备份运行期间
- 其他大型维护操作同时进行
```

**核心记忆**：
- COPY算法是MySQL DDL的传统方案，通过完整拷贝实现变更
- 需要2倍磁盘空间，执行时间长，但兼容性最好
- 大部分时间可读但写入阻塞，切换瞬间完全锁定
- 适合小表快速修改，大表需谨慎评估资源和时间成本