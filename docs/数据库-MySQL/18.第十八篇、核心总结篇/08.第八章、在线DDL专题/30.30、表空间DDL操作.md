---
title: 30、表空间DDL操作
---
## 📚 目录

1. [表空间基础概念](#1-表空间基础概念)
2. [CREATE TABLESPACE创建操作](#2-create-tablespace创建操作)
3. [ALTER TABLESPACE修改操作](#3-alter-tablespace修改操作)
4. [DROP TABLESPACE删除操作](#4-drop-tablespace删除操作)
5. [表空间移动操作](#5-表空间移动操作)
6. [表空间大小调整](#6-表空间大小调整)
7. [表空间监控与管理](#7-表空间监控与管理)
8. [性能优化策略](#8-性能优化策略)
9. [故障处理与恢复](#9-故障处理与恢复)
10. [最佳实践与安全考虑](#10-最佳实践与安全考虑)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🏗️ 表空间基础概念


### 1.1 什么是表空间


**🔸 表空间本质理解**
```
简单说：表空间就像是一个"数据仓库"
- 想象成一个大仓库，里面存放着数据库的表和索引
- 每个仓库有自己的地址(文件路径)和容量限制
- 可以有多个仓库分别存放不同类型的数据
```

**💡 生活类比**
> 就像图书馆的不同书库：
> - 文学书库存放文学类书籍  
> - 科技书库存放科技类书籍
> - 每个书库有独立的管理和容量控制

### 1.2 MySQL中的表空间类型


**📊 表空间分类对比**

| 表空间类型 | **用途** | **特点** | **适用场景** |
|-----------|---------|---------|-------------|
| **系统表空间** | `存储系统数据` | `不可删除，自动管理` | `系统表、undo日志` |
| **独立表空间** | `存储单个表数据` | `一表一文件，可移动` | `普通业务表` |
| **通用表空间** | `存储多个表数据` | `共享文件，统一管理` | `相关表集中存储` |
| **临时表空间** | `存储临时数据` | `会话结束自动清理` | `排序、分组操作` |

### 1.3 表空间的工作原理


**🔄 数据存储流程**
```
用户写入数据 → 选择表空间 → 分配数据页 → 写入磁盘文件
     ↑              ↓
   应用层        物理存储层
     ↑              ↓  
索引查询 ← 读取数据页 ← 定位表空间文件
```

**🏠 表空间架构图**
```
MySQL实例
├── 系统表空间 (ibdata1)
│   ├── 数据字典
│   ├── Undo日志
│   └── 双写缓冲区
├── 独立表空间 (.ibd文件)
│   ├── table1.ibd
│   ├── table2.ibd  
│   └── table3.ibd
└── 通用表空间 (自定义.ibd)
    ├── 表空间A
    │   ├── tableA1
    │   └── tableA2
    └── 表空间B
        ├── tableB1
        └── tableB2
```

### 1.4 表空间DDL的重要性


**⭐ 为什么需要掌握表空间操作**
- **性能优化**：不同业务数据分离存储，提升I/O效率
- **空间管理**：灵活控制存储空间分配和回收
- **备份恢复**：可以按表空间进行精确备份
- **运维管理**：方便数据迁移和存储扩展

---

## 2. 🔨 CREATE TABLESPACE创建操作


### 2.1 基本语法结构


**📝 CREATE TABLESPACE完整语法**
```sql
CREATE TABLESPACE 表空间名称
ADD DATAFILE '文件路径'
[FILE_BLOCK_SIZE = 块大小]
[ENCRYPTION = {'Y'|'N'}]
[ENGINE [=] 存储引擎名]
```

### 2.2 创建通用表空间详解


**🎯 基础创建示例**
```sql
-- 创建最简单的通用表空间
CREATE TABLESPACE ts_business 
ADD DATAFILE '/var/lib/mysql/ts_business.ibd';
```

**💡 参数详解**
- `ts_business`：表空间名称，建议用有意义的命名
- `ADD DATAFILE`：指定数据文件的存储路径
- `.ibd`：InnoDB数据文件的标准扩展名

### 2.3 高级创建选项


**🔧 指定文件块大小**
```sql
-- 创建指定块大小的表空间
CREATE TABLESPACE ts_large_data
ADD DATAFILE '/data/mysql/large_data.ibd'
FILE_BLOCK_SIZE = 16K;
```

**🔒 创建加密表空间**
```sql
-- 创建加密表空间(需要配置keyring插件)
CREATE TABLESPACE ts_sensitive 
ADD DATAFILE '/secure/mysql/sensitive.ibd'
ENCRYPTION = 'Y';
```

**🎪 完整配置示例**
```sql
-- 生产环境完整配置
CREATE TABLESPACE ts_ecommerce
ADD DATAFILE '/data/mysql/ecommerce/ts_ecommerce.ibd'  
FILE_BLOCK_SIZE = 16K
ENCRYPTION = 'Y'
ENGINE = InnoDB;
```

### 2.4 表空间创建最佳实践


**📋 创建检查清单**
- [ ] 确认磁盘空间充足
- [ ] 选择合适的文件路径
- [ ] 设置适当的文件权限
- [ ] 考虑是否需要加密
- [ ] 规划表空间命名规范

**⚠️ 常见创建错误**
```sql
-- ❌ 错误：路径不存在
CREATE TABLESPACE ts_test 
ADD DATAFILE '/nonexistent/path/test.ibd';
-- Error: Can't create/write to file

-- ✅ 正确：确保路径存在且有权限
CREATE TABLESPACE ts_test 
ADD DATAFILE '/var/lib/mysql/test.ibd';
```

### 2.5 创建后验证


**🔍 验证表空间创建成功**
```sql
-- 查看所有表空间
SELECT 
    TABLESPACE_NAME,
    FILE_NAME,
    FILE_SIZE/1024/1024 AS 'Size(MB)',
    STATUS
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME IS NOT NULL;

-- 查看特定表空间
SHOW CREATE TABLESPACE ts_business;
```

---

## 3. ⚙️ ALTER TABLESPACE修改操作


### 3.1 ALTER TABLESPACE基本概念


**🔸 修改操作的本质**
```
ALTER TABLESPACE主要用于：
✓ 修改表空间属性
✓ 重命名表空间  
✓ 改变加密状态
✗ 不能修改数据文件路径(需要重建)
```

### 3.2 表空间重命名


**📝 重命名语法**
```sql
-- 基本重命名语法
ALTER TABLESPACE 旧名称 RENAME TO 新名称;
```

**💼 实际应用示例**
```sql
-- 业务场景：项目重命名
ALTER TABLESPACE ts_old_project RENAME TO ts_new_project;

-- 验证重命名结果
SELECT TABLESPACE_NAME, FILE_NAME 
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME = 'ts_new_project';
```

### 3.3 修改加密状态


**🔒 加密操作详解**
```sql
-- 启用表空间加密
ALTER TABLESPACE ts_business ENCRYPTION = 'Y';

-- 禁用表空间加密  
ALTER TABLESPACE ts_business ENCRYPTION = 'N';
```

**⚠️ 加密注意事项**
```
加密要求：
1. 必须安装并配置keyring插件
2. 需要SUPER权限或ENCRYPTION_KEY_ADMIN权限
3. 加密过程可能较耗时，建议在业务低峰期操作
4. 加密后性能会有一定影响(通常5-15%)
```

### 3.4 修改操作的限制


**❌ 不支持的修改操作**
```sql
-- 以下操作都是不支持的：

-- ❌ 不能直接修改文件路径
ALTER TABLESPACE ts_test 
ADD DATAFILE '/new/path/test.ibd';  -- 错误

-- ❌ 不能修改FILE_BLOCK_SIZE
ALTER TABLESPACE ts_test 
FILE_BLOCK_SIZE = 32K;  -- 错误

-- ❌ 不能直接扩展文件大小
ALTER TABLESPACE ts_test EXTEND SIZE 1G;  -- 错误
```

### 3.5 修改操作的监控


**📊 监控修改进度**
```sql
-- 查看正在进行的DDL操作
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE INFO LIKE '%ALTER TABLESPACE%';

-- 查看表空间当前状态
SELECT 
    TABLESPACE_NAME,
    ENCRYPTION,
    STATUS
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES;
```

---

## 4. 🗑️ DROP TABLESPACE删除操作


### 4.1 删除表空间基础


**🔸 删除操作的本质**
```
DROP TABLESPACE的作用：
- 删除表空间定义信息
- 删除对应的数据文件
- 释放占用的磁盘空间
- 清理系统元数据
```

**⚠️ 删除前提条件**
```
表空间必须满足以下条件才能删除：
✓ 表空间为空(不包含任何表)
✓ 表空间不是系统表空间
✓ 当前没有活跃的事务使用该表空间
```

### 4.2 删除操作语法


**📝 基本删除语法**
```sql
DROP TABLESPACE 表空间名称;
```

**💼 完整删除流程示例**
```sql
-- 步骤1：检查表空间中的表
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLESPACE_NAME
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLESPACE_NAME = 'ts_business';

-- 步骤2：移除表空间中的表(如果有)
ALTER TABLE business.orders TABLESPACE = innodb_system;
ALTER TABLE business.customers TABLESPACE = innodb_system;

-- 步骤3：删除空表空间
DROP TABLESPACE ts_business;
```

### 4.3 删除前的安全检查


**🔍 安全检查脚本**
```sql
-- 检查表空间使用情况
SELECT 
    ts.NAME AS tablespace_name,
    COUNT(t.NAME) AS table_count,
    ts.FLAG AS flags
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES ts
LEFT JOIN INFORMATION_SCHEMA.INNODB_TABLES t ON ts.SPACE = t.SPACE
WHERE ts.NAME = 'ts_business'
GROUP BY ts.NAME;

-- 检查表空间文件大小
SELECT 
    FILE_NAME,
    ROUND(FILE_SIZE/1024/1024, 2) AS 'Size_MB',
    STATUS
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME = 'ts_business';
```

### 4.4 删除操作的常见错误


**❌ 典型错误场景**
```sql
-- 错误1：表空间不为空
DROP TABLESPACE ts_business;
-- Error: Tablespace `ts_business` is not empty

-- 错误2：表空间不存在  
DROP TABLESPACE ts_nonexistent;
-- Error: Tablespace 'ts_nonexistent' doesn't exist

-- 错误3：尝试删除系统表空间
DROP TABLESPACE innodb_system;
-- Error: Cannot drop system tablespace
```

**✅ 正确的错误处理**
```sql
-- 安全删除的完整流程
-- 1. 检查表空间是否存在
SELECT COUNT(*) as exists_count
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES 
WHERE NAME = 'ts_business';

-- 2. 检查是否为空
SELECT COUNT(*) as table_count  
FROM INFORMATION_SCHEMA.INNODB_TABLES t
JOIN INFORMATION_SCHEMA.INNODB_TABLESPACES ts ON t.SPACE = ts.SPACE
WHERE ts.NAME = 'ts_business';

-- 3. 如果满足条件，则删除
DROP TABLESPACE IF EXISTS ts_business;
```

### 4.5 删除后的清理验证


**✅ 删除成功验证**
```sql
-- 验证表空间已删除
SELECT TABLESPACE_NAME 
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES 
WHERE NAME = 'ts_business';
-- 应该返回空结果

-- 验证文件是否已删除(需要系统层面检查)
-- 在操作系统层面检查文件是否还存在
-- ls -la /var/lib/mysql/ts_business.ibd
```

---

## 5. 📦 表空间移动操作


### 5.1 表空间移动的概念


**🔸 移动操作的本质**
```
表空间移动包含两种场景：
1. 物理文件迁移：改变数据文件存储位置
2. 逻辑归属迁移：将表从一个表空间移动到另一个
```

**🏠 移动场景类比**
> 就像搬家：
> - 可以把整个家(表空间)搬到新地址
> - 也可以把家具(表)从一个房间搬到另一个房间

### 5.2 表在表空间间的移动


**📝 表移动语法**
```sql
-- 将表移动到指定表空间
ALTER TABLE 表名 TABLESPACE = 目标表空间名;

-- 将表移动到系统表空间
ALTER TABLE 表名 TABLESPACE = innodb_system;

-- 将表移动到独立表空间
ALTER TABLE 表名 TABLESPACE = innodb_file_per_table;
```

**💼 实际移动示例**
```sql
-- 场景：将订单表移动到专用的业务表空间
-- 步骤1：创建目标表空间
CREATE TABLESPACE ts_orders
ADD DATAFILE '/data/mysql/orders.ibd';

-- 步骤2：移动表
ALTER TABLE ecommerce.orders TABLESPACE = ts_orders;

-- 步骤3：验证移动结果
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME, 
    TABLESPACE_NAME,
    TABLE_ROWS
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME = 'orders';
```

### 5.3 批量表移动操作


**🔄 批量移动脚本**
```sql
-- 将多个相关表移动到同一表空间
SET @target_tablespace = 'ts_user_data';

-- 用户相关表批量移动
ALTER TABLE app.users TABLESPACE = ts_user_data;
ALTER TABLE app.user_profiles TABLESPACE = ts_user_data;  
ALTER TABLE app.user_preferences TABLESPACE = ts_user_data;

-- 动态生成移动SQL(示例)
SELECT CONCAT(
    'ALTER TABLE ', TABLE_SCHEMA, '.', TABLE_NAME, 
    ' TABLESPACE = ts_user_data;'
) AS move_sql
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'app' 
  AND TABLE_NAME LIKE 'user%'
  AND ENGINE = 'InnoDB';
```

### 5.4 表空间文件物理移动


**⚠️ 文件移动的复杂性**
```
MySQL不支持在线修改表空间文件路径
需要通过以下步骤实现：
1. 备份数据
2. 删除原表空间  
3. 在新位置创建表空间
4. 恢复数据
```

**📋 文件移动完整流程**
```sql
-- 步骤1：备份表数据
CREATE TABLE orders_backup AS SELECT * FROM orders;

-- 步骤2：将表移出表空间
ALTER TABLE orders TABLESPACE = innodb_system;

-- 步骤3：删除原表空间
DROP TABLESPACE ts_orders;

-- 步骤4：在新位置创建表空间
CREATE TABLESPACE ts_orders
ADD DATAFILE '/new/path/orders.ibd';

-- 步骤5：将表移入新表空间
ALTER TABLE orders TABLESPACE = ts_orders;

-- 步骤6：验证数据完整性
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM orders_backup;

-- 步骤7：清理备份表
DROP TABLE orders_backup;
```

### 5.5 移动操作的性能考虑


**⚡ 性能影响分析**
```
移动操作的性能影响：
- 表移动：涉及数据复制，时间与表大小成正比
- 大表移动：可能需要几小时到几天
- 业务影响：移动期间表可能锁定
- I/O压力：大量磁盘读写操作
```

**📊 移动进度监控**
```sql
-- 监控移动操作进度
SELECT 
    ID,
    USER,
    HOST, 
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO,
    PROGRESS
FROM INFORMATION_SCHEMA.PROCESSLIST 
WHERE INFO LIKE '%ALTER TABLE%TABLESPACE%';

-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G
```

**🎯 移动最佳实践**
- ✅ 选择业务低峰期进行
- ✅ 提前评估移动时间
- ✅ 做好完整备份
- ✅ 监控磁盘空间使用
- ✅ 设置合理的超时时间

---

## 6. 📏 表空间大小调整


### 6.1 表空间大小管理原理


**🔸 大小调整的本质**
```
MySQL中的表空间大小：
- 自动增长：默认行为，根据数据增长自动扩展
- 文件大小：由实际存储的数据量决定
- 空间回收：删除数据后空间可能不会立即释放
```

**💡 大小管理类比**
> 就像一个可伸缩的储物箱：
> - 装东西时自动变大
> - 取出东西时不一定立即变小
> - 需要手动整理才能回收空间

### 6.2 查看表空间大小信息


**📊 查看大小的多种方法**
```sql
-- 方法1：查看文件级别的大小信息
SELECT 
    TABLESPACE_NAME,
    FILE_NAME,
    ROUND(FILE_SIZE/1024/1024, 2) AS 'File_Size_MB',
    ROUND(FREE_EXTENTS*EXTENT_SIZE/1024/1024, 2) AS 'Free_Space_MB',
    ROUND((FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/1024/1024, 2) AS 'Used_Space_MB'
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME IS NOT NULL;

-- 方法2：查看表空间使用统计
SELECT 
    ts.NAME AS tablespace_name,
    ts.FLAG AS flags,
    COUNT(t.NAME) AS table_count,
    ROUND(SUM(t.FILE_SIZE)/1024/1024, 2) AS 'Total_Size_MB'
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES ts
LEFT JOIN INFORMATION_SCHEMA.INNODB_TABLES t ON ts.SPACE = t.SPACE
GROUP BY ts.NAME, ts.FLAG;
```

### 6.3 空间回收操作


**🔄 回收表空间的方法**

**方法1：OPTIMIZE TABLE**
```sql
-- 优化表以回收空间
OPTIMIZE TABLE orders;

-- 批量优化表空间中的所有表
SELECT CONCAT('OPTIMIZE TABLE ', TABLE_SCHEMA, '.', TABLE_NAME, ';') AS optimize_sql
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLESPACE_NAME = 'ts_business'
  AND ENGINE = 'InnoDB';
```

**方法2：ALTER TABLE重建**
```sql
-- 通过重建表来回收空间
ALTER TABLE orders ENGINE = InnoDB;

-- 或者使用ALGORITHM=COPY强制重建
ALTER TABLE orders FORCE, ALGORITHM=COPY;
```

### 6.4 空间使用分析


**🔍 详细的空间分析查询**
```sql
-- 分析表空间中各表的空间使用情况
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    t.ENGINE,
    ROUND(((t.DATA_LENGTH + t.INDEX_LENGTH) / 1024 / 1024), 2) AS 'Total_Size_MB',
    ROUND((t.DATA_LENGTH / 1024 / 1024), 2) AS 'Data_Size_MB',
    ROUND((t.INDEX_LENGTH / 1024 / 1024), 2) AS 'Index_Size_MB',
    ROUND((t.DATA_FREE / 1024 / 1024), 2) AS 'Free_Space_MB',
    t.TABLE_ROWS,
    ts.TABLESPACE_NAME
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN (
    SELECT TABLE_SCHEMA, TABLE_NAME, TABLESPACE_NAME 
    FROM INFORMATION_SCHEMA.TABLES 
    WHERE TABLESPACE_NAME IS NOT NULL
) ts ON t.TABLE_SCHEMA = ts.TABLE_SCHEMA AND t.TABLE_NAME = ts.TABLE_NAME
WHERE t.ENGINE = 'InnoDB'
  AND t.TABLE_SCHEMA NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
ORDER BY (t.DATA_LENGTH + t.INDEX_LENGTH) DESC;
```

### 6.5 空间预警和监控


**📈 建立空间监控机制**
```sql
-- 创建空间监控视图
CREATE VIEW v_tablespace_usage AS
SELECT 
    TABLESPACE_NAME,
    ROUND(FILE_SIZE/1024/1024, 2) AS 'Total_MB',
    ROUND((FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/1024/1024, 2) AS 'Used_MB',
    ROUND(FREE_EXTENTS*EXTENT_SIZE/1024/1024, 2) AS 'Free_MB',
    ROUND((FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE*100, 2) AS 'Usage_Percent',
    STATUS
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME IS NOT NULL;

-- 查询使用率超过80%的表空间
SELECT * FROM v_tablespace_usage 
WHERE Usage_Percent > 80
ORDER BY Usage_Percent DESC;
```

**⚠️ 空间告警设置**
```sql
-- 空间告警脚本示例
DELIMITER //
CREATE PROCEDURE sp_check_tablespace_usage()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE ts_name VARCHAR(64);
    DECLARE usage_pct DECIMAL(5,2);
    
    DECLARE cur CURSOR FOR 
        SELECT TABLESPACE_NAME, Usage_Percent 
        FROM v_tablespace_usage 
        WHERE Usage_Percent > 85;
        
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO ts_name, usage_pct;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 这里可以发送告警通知
        SELECT CONCAT('WARNING: Tablespace ', ts_name, 
                     ' usage is ', usage_pct, '%') AS alert_message;
    END LOOP;
    
    CLOSE cur;
END //
DELIMITER ;
```

---

## 7. 📊 表空间监控与管理


### 7.1 监控体系概述


**🔸 监控的重要维度**
```
表空间监控需要关注：
✓ 空间使用率：防止空间不足
✓ I/O性能：识别热点文件
✓ 表分布：了解数据分布情况
✓ 增长趋势：预测容量需求
✓ 健康状态：及时发现问题
```

### 7.2 核心监控查询


**📊 综合监控仪表板**
```sql
-- 表空间概览查询
SELECT 
    'Tablespace Overview' AS metric_type,
    COUNT(*) AS total_tablespaces,
    COUNT(CASE WHEN TABLESPACE_NAME LIKE 'ts_%' THEN 1 END) AS custom_tablespaces,
    ROUND(SUM(FILE_SIZE)/1024/1024/1024, 2) AS 'total_size_gb'
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME IS NOT NULL

UNION ALL

-- 表分布统计
SELECT 
    'Table Distribution' AS metric_type,
    COUNT(DISTINCT TABLESPACE_NAME) AS tablespace_count,
    COUNT(*) AS total_tables,
    ROUND(AVG(table_count), 2) AS avg_tables_per_tablespace
FROM (
    SELECT 
        TABLESPACE_NAME,
        COUNT(*) AS table_count
    FROM INFORMATION_SCHEMA.TABLES 
    WHERE TABLESPACE_NAME IS NOT NULL
    GROUP BY TABLESPACE_NAME
) t;
```

### 7.3 性能监控指标


**⚡ I/O性能监控**
```sql
-- 表空间I/O统计(需要开启performance_schema)
SELECT 
    OBJECT_SCHEMA AS database_name,
    OBJECT_NAME AS table_name,
    INDEX_NAME,
    COUNT_READ,
    COUNT_WRITE, 
    SUM_TIMER_READ/1000000000000 AS 'read_time_sec',
    SUM_TIMER_WRITE/1000000000000 AS 'write_time_sec'
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')
  AND COUNT_READ + COUNT_WRITE > 0
ORDER BY (COUNT_READ + COUNT_WRITE) DESC
LIMIT 20;

-- 文件I/O统计
SELECT 
    FILE_NAME,
    EVENT_NAME,
    COUNT_READ,
    COUNT_WRITE,
    SUM_NUMBER_OF_BYTES_READ/1024/1024 AS 'read_mb',
    SUM_NUMBER_OF_BYTES_WRITE/1024/1024 AS 'write_mb'
FROM performance_schema.file_summary_by_instance
WHERE FILE_NAME LIKE '%.ibd'
  AND (COUNT_READ > 0 OR COUNT_WRITE > 0)
ORDER BY (SUM_NUMBER_OF_BYTES_READ + SUM_NUMBER_OF_BYTES_WRITE) DESC;
```

### 7.4 自动化监控脚本


**🤖 监控存储过程**
```sql
DELIMITER //
CREATE PROCEDURE sp_tablespace_health_check()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE ts_name VARCHAR(64);
    DECLARE usage_pct DECIMAL(5,2);
    DECLARE file_size_mb DECIMAL(10,2);
    
    -- 临时表存储检查结果
    CREATE TEMPORARY TABLE IF NOT EXISTS temp_health_check (
        tablespace_name VARCHAR(64),
        issue_type VARCHAR(50),
        issue_description TEXT,
        severity ENUM('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')
    );
    
    -- 检查1：空间使用率过高
    INSERT INTO temp_health_check
    SELECT 
        TABLESPACE_NAME,
        'High Usage' AS issue_type,
        CONCAT('Usage: ', ROUND((FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE*100, 2), '%') AS issue_description,
        CASE 
            WHEN (FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE > 0.95 THEN 'CRITICAL'
            WHEN (FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE > 0.85 THEN 'HIGH'
            WHEN (FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE > 0.75 THEN 'MEDIUM'
            ELSE 'LOW'
        END AS severity
    FROM INFORMATION_SCHEMA.FILES 
    WHERE TABLESPACE_NAME IS NOT NULL
      AND (FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE > 0.75;
    
    -- 检查2：大文件识别
    INSERT INTO temp_health_check
    SELECT 
        TABLESPACE_NAME,
        'Large File' AS issue_type,
        CONCAT('File size: ', ROUND(FILE_SIZE/1024/1024/1024, 2), ' GB') AS issue_description,
        CASE 
            WHEN FILE_SIZE/1024/1024/1024 > 100 THEN 'HIGH'
            WHEN FILE_SIZE/1024/1024/1024 > 50 THEN 'MEDIUM'
            ELSE 'LOW'
        END AS severity
    FROM INFORMATION_SCHEMA.FILES 
    WHERE TABLESPACE_NAME IS NOT NULL
      AND FILE_SIZE/1024/1024/1024 > 10;
    
    -- 显示检查结果
    SELECT * FROM temp_health_check 
    ORDER BY 
        CASE severity 
            WHEN 'CRITICAL' THEN 1 
            WHEN 'HIGH' THEN 2 
            WHEN 'MEDIUM' THEN 3 
            ELSE 4 
        END;
    
    DROP TEMPORARY TABLE temp_health_check;
END //
DELIMITER ;

-- 执行健康检查
CALL sp_tablespace_health_check();
```

### 7.5 监控最佳实践


**📋 监控策略清单**
- [ ] **定期巡检**：每日检查空间使用情况
- [ ] **自动告警**：设置阈值触发告警
- [ ] **趋势分析**：记录历史数据，分析增长趋势
- [ ] **性能基线**：建立正常情况下的性能基线
- [ ] **容量规划**：基于监控数据进行容量规划

**🎯 关键监控指标**
```
空间类指标：
- 使用率 > 80% (告警)
- 使用率 > 90% (紧急)
- 剩余空间 < 5GB (告警)

性能类指标：
- 读写延迟异常增高
- I/O等待时间过长
- 并发访问冲突

健康类指标：
- 文件损坏检测
- 权限异常检测
- 磁盘错误检测
```

---

## 8. ⚡ 性能优化策略


### 8.1 表空间性能优化原理


**🔸 性能优化的核心思路**
```
表空间性能优化主要从以下角度：
1. I/O分离：将不同访问模式的数据分开存储
2. 并行处理：利用多个表空间实现并行I/O
3. 热点分散：避免热点数据集中在单一文件
4. 存储优化：选择合适的存储介质和配置
```

**💡 性能优化类比**
> 就像城市交通规划：
> - 主干道和支路分离(热点数据和普通数据分离)
> - 多条道路并行(多个表空间并行I/O)
> - 避免拥堵点(分散热点访问)

### 8.2 I/O优化策略


**🚀 多表空间I/O并行化**
```sql
-- 策略1：按业务模块分离表空间
-- 用户数据表空间
CREATE TABLESPACE ts_user_data
ADD DATAFILE '/data1/mysql/user_data.ibd';

-- 订单数据表空间  
CREATE TABLESPACE ts_order_data
ADD DATAFILE '/data2/mysql/order_data.ibd';

-- 日志数据表空间
CREATE TABLESPACE ts_log_data  
ADD DATAFILE '/data3/mysql/log_data.ibd';

-- 将相关表移动到对应表空间
ALTER TABLE users TABLESPACE = ts_user_data;
ALTER TABLE user_profiles TABLESPACE = ts_user_data;

ALTER TABLE orders TABLESPACE = ts_order_data;
ALTER TABLE order_items TABLESPACE = ts_order_data;

ALTER TABLE access_logs TABLESPACE = ts_log_data;
ALTER TABLE error_logs TABLESPACE = ts_log_data;
```

**📊 I/O分布效果验证**
```sql
-- 检查I/O分布情况
SELECT 
    SUBSTRING_INDEX(FILE_NAME, '/', -1) AS file_name,
    TABLESPACE_NAME,
    COUNT_READ,
    COUNT_WRITE,
    ROUND(SUM_NUMBER_OF_BYTES_READ/1024/1024, 2) AS 'read_mb',
    ROUND(SUM_NUMBER_OF_BYTES_WRITE/1024/1024, 2) AS 'write_mb'
FROM performance_schema.file_summary_by_instance f
JOIN INFORMATION_SCHEMA.FILES inf ON f.FILE_NAME = inf.FILE_NAME
WHERE inf.TABLESPACE_NAME IS NOT NULL
ORDER BY (COUNT_READ + COUNT_WRITE) DESC;
```

### 8.3 热点数据优化


**🔥 热点数据识别与优化**
```sql
-- 识别热点表
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    SUM(tio.COUNT_READ + tio.COUNT_WRITE) AS total_io,
    SUM(tio.COUNT_READ) AS total_reads,
    SUM(tio.COUNT_WRITE) AS total_writes,
    ROUND(SUM(tio.SUM_TIMER_WAIT)/1000000000000, 2) AS 'total_wait_sec'
FROM performance_schema.table_io_waits_summary_by_table tio
JOIN INFORMATION_SCHEMA.TABLES t ON tio.OBJECT_SCHEMA = t.TABLE_SCHEMA 
                                 AND tio.OBJECT_NAME = t.TABLE_NAME
WHERE t.ENGINE = 'InnoDB'
GROUP BY t.TABLE_SCHEMA, t.TABLE_NAME
HAVING total_io > 10000
ORDER BY total_io DESC;

-- 为热点表创建专用表空间
CREATE TABLESPACE ts_hot_data
ADD DATAFILE '/ssd/mysql/hot_data.ibd';  -- 使用SSD存储

-- 移动热点表到SSD表空间
ALTER TABLE ecommerce.products TABLESPACE = ts_hot_data;
ALTER TABLE ecommerce.inventory TABLESPACE = ts_hot_data;
```

### 8.4 存储配置优化


**⚙️ 表空间块大小优化**
```sql
-- 根据数据特点选择合适的块大小
-- 小数据量，随机访问多：使用较小块
CREATE TABLESPACE ts_small_blocks
ADD DATAFILE '/data/mysql/small_blocks.ibd'
FILE_BLOCK_SIZE = 4K;

-- 大数据量，顺序访问多：使用较大块  
CREATE TABLESPACE ts_large_blocks
ADD DATAFILE '/data/mysql/large_blocks.ibd'
FILE_BLOCK_SIZE = 64K;

-- OLTP业务：推荐16K(默认)
CREATE TABLESPACE ts_oltp
ADD DATAFILE '/data/mysql/oltp.ibd'
FILE_BLOCK_SIZE = 16K;
```

**📊 块大小性能对比测试**
```sql
-- 创建测试表来对比不同块大小的性能
-- (在实际环境中需要使用benchmark工具)

-- 4K块大小测试表
CREATE TABLE test_4k (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data VARCHAR(1000),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) TABLESPACE = ts_small_blocks;

-- 16K块大小测试表  
CREATE TABLE test_16k (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data VARCHAR(1000),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) TABLESPACE = ts_oltp;

-- 64K块大小测试表
CREATE TABLE test_64k (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data VARCHAR(1000), 
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) TABLESPACE = ts_large_blocks;
```

### 8.5 性能监控与调优


**📈 性能指标监控**
```sql
-- 创建性能监控视图
CREATE VIEW v_tablespace_performance AS
SELECT 
    ts.TABLESPACE_NAME,
    COUNT(DISTINCT t.TABLE_NAME) AS table_count,
    SUM(tio.COUNT_READ) AS total_reads,
    SUM(tio.COUNT_WRITE) AS total_writes,
    ROUND(AVG(tio.SUM_TIMER_READ/tio.COUNT_READ)/1000000, 2) AS 'avg_read_ms',
    ROUND(AVG(tio.SUM_TIMER_WRITE/tio.COUNT_WRITE)/1000000, 2) AS 'avg_write_ms',
    ROUND(SUM(f.SUM_NUMBER_OF_BYTES_READ)/1024/1024, 2) AS 'total_read_mb',
    ROUND(SUM(f.SUM_NUMBER_OF_BYTES_WRITE)/1024/1024, 2) AS 'total_write_mb'
FROM INFORMATION_SCHEMA.TABLES t
JOIN performance_schema.table_io_waits_summary_by_table tio 
    ON t.TABLE_SCHEMA = tio.OBJECT_SCHEMA AND t.TABLE_NAME = tio.OBJECT_NAME
JOIN INFORMATION_SCHEMA.FILES inf ON inf.TABLESPACE_NAME = t.TABLESPACE_NAME
JOIN performance_schema.file_summary_by_instance f ON inf.FILE_NAME = f.FILE_NAME
WHERE t.TABLESPACE_NAME IS NOT NULL
  AND tio.COUNT_READ + tio.COUNT_WRITE > 0
GROUP BY ts.TABLESPACE_NAME;
```

**🎯 性能优化检查清单**
- [ ] **分析访问模式**：OLTP vs OLAP
- [ ] **评估数据量**：大表 vs 小表
- [ ] **识别热点**：高频访问的表和数据
- [ ] **存储分层**：SSD vs HDD
- [ ] **I/O并行**：多个表空间分布
- [ ] **定期检查**：监控性能指标变化

---

## 9. 🚨 故障处理与恢复


### 9.1 常见故障类型


**🔸 表空间故障分类**
```
文件级故障：
- 数据文件损坏或丢失
- 权限问题导致无法访问
- 磁盘空间不足

逻辑故障：
- 表空间元数据不一致
- 表空间状态异常
- 加密密钥丢失

性能故障：
- I/O性能急剧下降
- 锁等待时间过长
- 空间碎片过多
```

### 9.2 故障诊断方法


**🔍 系统性故障诊断**
```sql
-- 1. 检查表空间状态
SELECT 
    TABLESPACE_NAME,
    STATUS,
    FILE_NAME,
    FILE_SIZE/1024/1024 AS 'size_mb'
FROM INFORMATION_SCHEMA.FILES 
WHERE TABLESPACE_NAME IS NOT NULL
  AND STATUS != 'NORMAL';

-- 2. 检查错误日志相关信息
-- 需要查看MySQL错误日志文件
-- tail -f /var/log/mysql/error.log | grep -i tablespace

-- 3. 检查InnoDB状态
SHOW ENGINE INNODB STATUS\G

-- 4. 检查表完整性
CHECK TABLE your_table_name;

-- 5. 检查表空间中的表状态
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_COMMENT,
    CREATE_TIME,
    UPDATE_TIME
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLESPACE_NAME = 'problem_tablespace';
```

### 9.3 文件损坏恢复


**💾 数据文件恢复流程**
```sql
-- 场景：表空间文件损坏
-- 步骤1：立即停止相关业务写入

-- 步骤2：检查损坏程度
-- 尝试访问表看是否报错
SELECT COUNT(*) FROM damaged_table;
-- 如果报错类似：Table 'test/damaged_table' doesn't exist in engine

-- 步骤3：从备份恢复(推荐方案)
-- 恢复整个数据库实例到最近的备份点
-- mysqlbackup --backup-dir=/backup/latest restore

-- 步骤4：如果没有备份，尝试强制恢复
SET innodb_force_recovery = 1;  -- 谨慎使用
RESTART MYSQL;

-- 步骤5：导出可恢复的数据  
CREATE TABLE recovered_data AS 
SELECT * FROM damaged_table;  -- 能读取多少是多少

-- 步骤6：重建表空间和表
DROP TABLE damaged_table;
DROP TABLESPACE problem_tablespace;

CREATE TABLESPACE new_tablespace
ADD DATAFILE '/data/mysql/new_file.ibd';

CREATE TABLE new_table (
    -- 重建表结构
) TABLESPACE = new_tablespace;

INSERT INTO new_table SELECT * FROM recovered_data;
```

### 9.4 空间不足处理


**📦 磁盘空间不足应急处理**
```sql
-- 紧急空间清理步骤

-- 1. 立即识别大表和可清理数据
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) AS 'size_mb',
    TABLE_ROWS,
    UPDATE_TIME
FROM INFORMATION_SCHEMA.TABLES 
WHERE ENGINE = 'InnoDB'
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC
LIMIT 10;

-- 2. 清理临时数据和日志
DELETE FROM log_table WHERE created_time < DATE_SUB(NOW(), INTERVAL 7 DAY);
DELETE FROM temp_data WHERE status = 'completed';

-- 3. 优化表回收空间
OPTIMIZE TABLE large_table1;
OPTIMIZE TABLE large_table2;

-- 4. 移动大表到其他磁盘
CREATE TABLESPACE ts_emergency
ADD DATAFILE '/other_disk/emergency.ibd';

ALTER TABLE large_table TABLESPACE = ts_emergency;

-- 5. 如果极度紧急，暂时关闭binlog
SET sql_log_bin = 0;  -- 仅当前会话
-- 执行大量删除操作
-- 恢复binlog
SET sql_log_bin = 1;
```

### 9.5 权限和访问问题


**🔐 权限问题诊断与修复**
```bash
# 系统层面检查文件权限
ls -la /var/lib/mysql/*.ibd
# 确保MySQL用户有读写权限

# 修复权限问题
chown mysql:mysql /var/lib/mysql/*.ibd
chmod 660 /var/lib/mysql/*.ibd

# 检查目录权限
ls -ld /var/lib/mysql/
# 确保目录有执行权限
```

```sql
-- MySQL层面权限检查
-- 检查用户对表空间的访问权限
SELECT 
    USER,
    HOST,
    CREATE_TABLESPACE_PRIV,
    ALTER_PRIV,
    DROP_PRIV
FROM mysql.user 
WHERE USER = 'your_user';

-- 检查表级权限
SHOW GRANTS FOR 'username'@'hostname';
```

### 9.6 故障预防措施


**🛡️ 故障预防最佳实践**
```
预防措施清单：

✓ 定期备份：
  - 全量备份：每周一次
  - 增量备份：每天一次  
  - 二进制日志：实时备份

✓ 监控告警：
  - 磁盘空间监控
  - 文件访问权限监控
  - 性能异常监控

✓ 容量规划：
  - 预估数据增长
  - 预留30%空间缓冲
  - 制定扩容计划

✓ 测试演练：
  - 定期故障恢复演练
  - 备份恢复测试
  - 应急预案验证
```

**📋 故障应急预案模板**
```sql
-- 应急预案SQL脚本示例
-- 1. 快速诊断脚本
CREATE PROCEDURE sp_emergency_diagnosis()
BEGIN
    SELECT 'Checking tablespace status...' AS step;
    SELECT TABLESPACE_NAME, STATUS FROM INFORMATION_SCHEMA.FILES 
    WHERE STATUS != 'NORMAL';
    
    SELECT 'Checking disk space...' AS step;
    SELECT ROUND(SUM(FILE_SIZE)/1024/1024/1024, 2) AS 'total_gb'
    FROM INFORMATION_SCHEMA.FILES;
    
    SELECT 'Checking large tables...' AS step;
    SELECT TABLE_SCHEMA, TABLE_NAME, 
           ROUND((DATA_LENGTH + INDEX_LENGTH)/1024/1024, 2) AS 'size_mb'
    FROM INFORMATION_SCHEMA.TABLES 
    WHERE (DATA_LENGTH + INDEX_LENGTH) > 100*1024*1024
    ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC LIMIT 5;
END;

-- 2. 应急清理脚本  
CREATE PROCEDURE sp_emergency_cleanup()
BEGIN
    -- 清理7天前的日志数据
    DELETE FROM access_logs WHERE log_date < DATE_SUB(CURDATE(), INTERVAL 7 DAY);
    
    -- 优化大表
    SET @sql = '';
    SELECT GROUP_CONCAT(CONCAT('OPTIMIZE TABLE ', TABLE_SCHEMA, '.', TABLE_NAME) SEPARATOR '; ')
    INTO @sql
    FROM INFORMATION_SCHEMA.TABLES 
    WHERE (DATA_LENGTH + INDEX_LENGTH) > 500*1024*1024;
    
    -- 这里需要动态执行SQL或手动执行
    SELECT @sql AS cleanup_sql;
END;
```

---

## 10. 🔒 最佳实践与安全考虑


### 10.1 表空间设计最佳实践


**🎯 设计原则**
```
表空间设计的核心原则：
1. 业务隔离：不同业务使用不同表空间
2. 访问模式分离：OLTP和OLAP数据分开
3. 生命周期管理：临时数据和持久数据分开
4. 性能考虑：热点数据和冷数据分开
5. 安全考虑：敏感数据和普通数据分开
```

**📋 命名规范建议**
```sql
-- 推荐的表空间命名规范
-- 格式：ts_[业务模块]_[数据类型]_[环境]

-- 业务模块表空间
CREATE TABLESPACE ts_user_data_prod;      -- 用户数据生产环境
CREATE TABLESPACE ts_order_data_prod;     -- 订单数据生产环境
CREATE TABLESPACE ts_log_data_prod;       -- 日志数据生产环境

-- 按数据特性分类  
CREATE TABLESPACE ts_hot_data_prod;       -- 热点数据
CREATE TABLESPACE ts_archive_data_prod;   -- 归档数据
CREATE TABLESPACE ts_temp_data_prod;      -- 临时数据

-- 按安全级别分类
CREATE TABLESPACE ts_sensitive_data_prod; -- 敏感数据
CREATE TABLESPACE ts_public_data_prod;    -- 公开数据
```

### 10.2 安全配置最佳实践


**🔐 数据加密配置**
```sql
-- 1. 为敏感数据启用表空间加密
CREATE TABLESPACE ts_user_private
ADD DATAFILE '/secure/mysql/user_private.ibd'
ENCRYPTION = 'Y';

-- 2. 配置密钥管理
-- 在my.cnf中配置keyring插件
-- [mysqld]
-- early-plugin-load=keyring_file.so
-- keyring_file_data=/var/lib/mysql-keyring/keyring

-- 3. 验证加密状态
SELECT 
    TABLESPACE_NAME,
    ENCRYPTION
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES
WHERE ENCRYPTION = 'Y';

-- 4. 将敏感表移动到加密表空间
ALTER TABLE user_credentials TABLESPACE = ts_user_private;
ALTER TABLE payment_info TABLESPACE = ts_user_private;
```

**🛡️ 访问控制配置**
```sql
-- 创建专门的表空间管理用户
CREATE USER 'tablespace_admin'@'localhost' 
IDENTIFIED BY 'strong_password_here';

-- 授予表空间管理权限
GRANT CREATE TABLESPACE ON *.* TO 'tablespace_admin'@'localhost';
GRANT ALTER ON *.* TO 'tablespace_admin'@'localhost';
GRANT DROP ON *.* TO 'tablespace_admin'@'localhost';

-- 普通用户只授予必要权限
CREATE USER 'app_user'@'%' IDENTIFIED BY 'app_password';
GRANT SELECT, INSERT, UPDATE, DELETE ON business.* TO 'app_user'@'%';

-- 审计表空间操作
-- 启用general log记录DDL操作
SET GLOBAL general_log = 'ON';
SET GLOBAL log_output = 'TABLE';
```

### 10.3 备份与恢复策略


**💾 分级备份策略**
```bash
#!/bin/bash
# 表空间分级备份脚本示例

# 1. 热数据表空间 - 每小时增量备份
mysql -e "FLUSH TABLES WITH READ LOCK; 
          SYSTEM cp /data/mysql/ts_hot_data.ibd /backup/hourly/;
          UNLOCK TABLES;"

# 2. 重要业务数据 - 每6小时备份
mysqlbackup --backup-dir=/backup/business_data \
            --include-tables=business.* backup

# 3. 归档数据 - 每日备份
mysqlbackup --backup-dir=/backup/archive_data \
            --include-tables=archive.* backup

# 4. 日志数据 - 每周备份
mysqldump --single-transaction \
          --routines --triggers \
          --databases logs > /backup/weekly/logs_$(date +%Y%m%d).sql
```

**🔄 恢复策略验证**
```sql
-- 定期验证备份可恢复性
-- 1. 创建测试环境
CREATE DATABASE backup_test;

-- 2. 恢复到测试环境
-- mysqlbackup --backup-dir=/backup/latest \
--            --datadir=/var/lib/mysql_test copy-back

-- 3. 验证数据完整性
USE backup_test;
SELECT COUNT(*) FROM critical_table;
CHECKSUM TABLE critical_table;

-- 4. 记录验证结果
INSERT INTO backup_validation_log (
    backup_date, 
    table_name, 
    record_count, 
    checksum_value, 
    validation_status
) VALUES (
    NOW(), 
    'critical_table', 
    (SELECT COUNT(*) FROM critical_table),
    (SELECT CHECKSUM FROM CHECKSUM TABLE critical_table),
    'SUCCESS'
);
```

### 10.4 运维自动化脚本


**🤖 自动化运维脚本**
```sql
-- 表空间健康检查自动化
DELIMITER //
CREATE PROCEDURE sp_daily_tablespace_maintenance()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE ts_name VARCHAR(64);
    DECLARE usage_pct DECIMAL(5,2);
    
    -- 游标定义
    DECLARE cur CURSOR FOR 
        SELECT 
            TABLESPACE_NAME,
            ROUND((FILE_SIZE-FREE_EXTENTS*EXTENT_SIZE)/FILE_SIZE*100, 2)
        FROM INFORMATION_SCHEMA.FILES 
        WHERE TABLESPACE_NAME IS NOT NULL;
        
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 创建维护日志表
    CREATE TABLE IF NOT EXISTS tablespace_maintenance_log (
        log_id INT AUTO_INCREMENT PRIMARY KEY,
        log_date DATE,
        tablespace_name VARCHAR(64),
        action_type VARCHAR(50),
        details TEXT,
        status ENUM('SUCCESS', 'FAILED', 'WARNING')
    );
    
    OPEN cur;
    
    maintenance_loop: LOOP
        FETCH cur INTO ts_name, usage_pct;
        IF done THEN
            LEAVE maintenance_loop;
        END IF;
        
        -- 空间使用率检查
        IF usage_pct > 85 THEN
            INSERT INTO tablespace_maintenance_log 
            VALUES (NULL, CURDATE(), ts_name, 'SPACE_WARNING', 
                    CONCAT('Usage: ', usage_pct, '%'), 'WARNING');
        END IF;
        
        -- 如果使用率过高，尝试优化
        IF usage_pct > 90 THEN
            -- 这里可以添加自动优化逻辑
            INSERT INTO tablespace_maintenance_log 
            VALUES (NULL, CURDATE(), ts_name, 'AUTO_OPTIMIZE', 
                    'Triggered automatic optimization', 'SUCCESS');
        END IF;
        
    END LOOP;
    
    CLOSE cur;
    
    -- 清理30天前的日志
    DELETE FROM tablespace_maintenance_log 
    WHERE log_date < DATE_SUB(CURDATE(), INTERVAL 30 DAY);
    
END //
DELIMITER ;

-- 设置定时任务执行(需要配置事件调度器)
-- SET GLOBAL event_scheduler = ON;
-- CREATE EVENT ev_daily_maintenance
-- ON SCHEDULE EVERY 1 DAY
-- STARTS TIMESTAMP(CURRENT_DATE) + INTERVAL 2 HOUR
-- DO CALL sp_daily_tablespace_maintenance();
```

### 10.5 性能基线建立


**📊 建立性能基线**
```sql
-- 创建性能基线记录表
CREATE TABLE tablespace_performance_baseline (
    baseline_id INT AUTO_INCREMENT PRIMARY KEY,
    tablespace_name VARCHAR(64),
    measurement_date DATE,
    avg_read_latency_ms DECIMAL(10,3),
    avg_write_latency_ms DECIMAL(10,3),
    total_iops BIGINT,
    space_usage_pct DECIMAL(5,2),
    table_count INT,
    baseline_type ENUM('DAILY', 'WEEKLY', 'MONTHLY')
);

-- 收集基线数据的存储过程
DELIMITER //
CREATE PROCEDURE sp_collect_performance_baseline(IN baseline_type VARCHAR(10))
BEGIN
    INSERT INTO tablespace_performance_baseline (
        tablespace_name,
        measurement_date,
        avg_read_latency_ms,
        avg_write_latency_ms, 
        total_iops,
        space_usage_pct,
        table_count,
        baseline_type
    )
    SELECT 
        inf.TABLESPACE_NAME,
        CURDATE(),
        ROUND(AVG(f.SUM_TIMER_READ/f.COUNT_READ)/1000000, 3),
        ROUND(AVG(f.SUM_TIMER_WRITE/f.COUNT_WRITE)/1000000, 3),
        SUM(f.COUNT_READ + f.COUNT_WRITE),
        ROUND((inf.FILE_SIZE-inf.FREE_EXTENTS*inf.EXTENT_SIZE)/inf.FILE_SIZE*100, 2),
        COUNT(DISTINCT t.TABLE_NAME),
        baseline_type
    FROM INFORMATION_SCHEMA.FILES inf
    LEFT JOIN performance_schema.file_summary_by_instance f 
        ON inf.FILE_NAME = f.FILE_NAME
    LEFT JOIN INFORMATION_SCHEMA.TABLES t 
        ON inf.TABLESPACE_NAME = t.TABLESPACE_NAME
    WHERE inf.TABLESPACE_NAME IS NOT NULL
      AND f.COUNT_READ > 0
    GROUP BY inf.TABLESPACE_NAME, inf.FILE_SIZE, inf.FREE_EXTENTS, inf.EXTENT_SIZE;
END //
DELIMITER ;

-- 性能异常检测
DELIMITER //
CREATE PROCEDURE sp_detect_performance_anomalies()
BEGIN
    SELECT 
        current.tablespace_name,
        current.measurement_date,
        current.avg_read_latency_ms,
        baseline.avg_read_latency_ms AS baseline_read_latency,
        ROUND((current.avg_read_latency_ms - baseline.avg_read_latency_ms) / baseline.avg_read_latency_ms * 100, 2) AS read_latency_change_pct,
        CASE 
            WHEN current.avg_read_latency_ms > baseline.avg_read_latency_ms * 1.5 THEN 'HIGH'
            WHEN current.avg_read_latency_ms > baseline.avg_read_latency_ms * 1.2 THEN 'MEDIUM'
            ELSE 'NORMAL'
        END AS alert_level
    FROM tablespace_performance_baseline current
    JOIN (
        SELECT 
            tablespace_name,
            AVG(avg_read_latency_ms) AS avg_read_latency_ms
        FROM tablespace_performance_baseline 
        WHERE measurement_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
          AND baseline_type = 'DAILY'
        GROUP BY tablespace_name
    ) baseline ON current.tablespace_name = baseline.tablespace_name
    WHERE current.measurement_date = CURDATE()
      AND (current.avg_read_latency_ms > baseline.avg_read_latency_ms * 1.2)
    ORDER BY read_latency_change_pct DESC;
END //
DELIMITER ;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


**🔸 表空间DDL操作精要**
```
CREATE TABLESPACE：
✓ 基本语法：CREATE TABLESPACE name ADD DATAFILE 'path'
✓ 关键参数：FILE_BLOCK_SIZE、ENCRYPTION
✓ 应用场景：业务数据分离、性能优化

ALTER TABLESPACE：
✓ 重命名：RENAME TO new_name
✓ 加密控制：ENCRYPTION = 'Y'/'N'
✓ 限制：不能修改文件路径和块大小

DROP TABLESPACE：
✓ 前提条件：必须为空表空间
✓ 安全检查：确认无表占用
✓ 清理验证：确保文件已删除
```

### 11.2 关键理解要点


**🔹 表空间的本质作用**
```
数据组织：
- 按业务逻辑分组存储数据
- 实现数据的物理隔离
- 便于独立管理和维护

性能优化：
- 分散I/O压力到多个文件
- 支持并行读写操作  
- 优化存储介质使用

运维管理：
- 简化备份恢复策略
- 支持精确的容量控制
- 便于数据迁移操作
```

**🔹 操作安全性原则**
```
操作前检查：
- 确认表空间状态和内容
- 验证磁盘空间充足
- 检查权限和依赖关系

操作中监控：
- 监控操作进度和性能影响
- 关注错误日志和告警信息
- 确保业务访问正常

操作后验证：
- 验证操作结果正确性
- 检查数据完整性
- 更新监控和文档
```

### 11.3 实际应用价值


**💼 业务应用场景**
- **电商系统**：用户数据、订单数据、商品数据分别存储
- **金融系统**：交易数据、风控数据、历史数据物理隔离
- **内容平台**：热点内容、归档内容、用户生成内容分层存储
- **IoT平台**：实时数据、历史数据、设备数据分类管理

**🔧 运维实践要点**
- **容量规划**：基于业务增长预测，制定表空间扩容策略
- **性能调优**：通过I/O分离和热点分散提升系统性能
- **故障恢复**：利用表空间隔离，实现精确的故障恢复
- **安全合规**：通过加密表空间保护敏感数据

### 11.4 学习检查点


**📝 自我检测清单**
- [ ] 能够独立创建不同配置的表空间
- [ ] 理解表空间修改操作的限制和原因
- [ ] 掌握安全删除表空间的完整流程
- [ ] 能够设计合理的表空间布局方案
- [ ] 具备表空间故障诊断和处理能力
- [ ] 了解表空间性能优化的核心策略

**🎯 进阶学习建议**
- **深入学习**：InnoDB存储引擎内部结构
- **实践项目**：搭建多表空间的测试环境
- **性能测试**：对比不同表空间配置的性能差异
- **运维工具**：学习使用专业的MySQL管理工具

### 11.5 常见误区避免


**❌ 典型错误认知**
```
错误1：认为表空间越多越好
✓ 正确：合理规划，避免过度分片

错误2：忽视表空间的维护成本  
✓ 正确：考虑管理复杂度和运维成本

错误3：不做充分的测试就在生产环境操作
✓ 正确：在测试环境充分验证后再上线

错误4：不制定故障恢复预案
✓ 正确：制定详细的应急处理流程
```

**⚠️ 重要注意事项**
- 表空间操作可能涉及大量数据移动，务必在业务低峰期执行
- 删除表空间前务必确认数据已备份，操作不可逆
- 加密表空间需要配置密钥管理，注意密钥安全
- 表空间文件路径变更需要重建，不支持在线修改

### 11.6 扩展学习方向


**📚 相关技术扩展**
```
存储引擎层面：
- InnoDB内部结构深入理解
- 页面管理和缓冲池机制
- 事务和锁机制的关系

系统架构层面：
- 分布式存储架构设计
- 数据分片和路由策略
- 异地多活架构实现

运维自动化：
- 基于监控的自动化运维
- 容器化MySQL部署
- 云原生数据库管理
```

**🚀 技能提升路径**
1. **基础巩固**：熟练掌握所有DDL操作
2. **实践应用**：在真实项目中应用表空间技术
3. **性能调优**：深入理解性能优化原理
4. **故障处理**：积累故障诊断和处理经验
5. **架构设计**：能够设计复杂的存储架构

**核心记忆口诀**：
- 创建表空间重规划，路径大小加密全
- 修改操作有限制，重命加密可变更  
- 删除之前先检查，空间为零才安全
- 移动分离提性能，监控运维保稳定