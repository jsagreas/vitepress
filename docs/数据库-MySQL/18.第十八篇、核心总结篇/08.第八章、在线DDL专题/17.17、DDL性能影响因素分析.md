---
title: 17、DDL性能影响因素分析
---
## 📚 目录

1. [DDL性能影响概述](#1-DDL性能影响概述)
2. [表大小与数据类型影响](#2-表大小与数据类型影响)
3. [索引相关影响因素](#3-索引相关影响因素)
4. [存储引擎差异分析](#4-存储引擎差异分析)
5. [硬件资源影响分析](#5-硬件资源影响分析)
6. [系统配置与网络因素](#6-系统配置与网络因素)
7. [并发负载与缓存影响](#7-并发负载与缓存影响)
8. [性能瓶颈识别与优化](#8-性能瓶颈识别与优化)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 DDL性能影响概述


### 1.1 什么是DDL性能影响


**DDL性能影响**就是指执行数据库结构变更操作时，各种因素对执行速度和系统资源消耗的影响程度。

```
简单理解：
就像装修房子一样：
- 房子越大 → 装修时间越长 (表大小影响)
- 装修项目越多 → 耗时越长 (索引数量影响)  
- 材料质量不同 → 施工难度不同 (数据类型影响)
- 工人技能不同 → 效率不同 (存储引擎差异)
```

### 1.2 影响因素分类体系


**🔸 数据层面因素**
```
表数据量：
• 表大小直接影响DDL执行时间
• 数据量越大，重组成本越高

数据类型复杂度：
• 简单类型 vs 复杂类型处理成本
• 可变长度字段的额外开销
```

**🔸 结构层面因素**
```
索引结构：
• 索引数量：每个索引都需要重建
• 索引类型：不同类型重建成本不同
• 索引大小：影响I/O和内存使用
```

**🔸 系统层面因素**
```
硬件资源：
• CPU：处理能力影响计算密集型操作
• 内存：缓冲区大小影响I/O效率
• 存储：磁盘性能影响数据读写速度

系统配置：
• MySQL参数设置
• 操作系统配置
• 网络环境配置
```

### 1.3 性能影响的表现形式


| 影响表现 | **具体症状** | **影响程度** | **常见原因** |
|---------|------------|-------------|-------------|
| 🐌 **执行缓慢** | `DDL操作耗时数小时` | `严重` | `大表、多索引、资源不足` |
| 🔒 **锁定时间长** | `表长时间不可访问` | `严重` | `传统DDL方式、高并发` |
| 💾 **资源占用高** | `CPU/内存/磁盘占用率高` | `中等` | `配置不当、硬件不足` |
| 🌐 **网络延迟** | `操作响应延迟` | `轻微` | `网络带宽、延迟问题` |

---

## 2. 📊 表大小与数据类型影响


### 2.1 表大小对DDL性能的影响


**🔸 表大小影响机制**
```
影响原理：
DDL操作通常需要：
1. 读取原表数据
2. 创建新表结构  
3. 数据迁移/重组
4. 更新元数据
5. 清理临时文件

数据量越大 → 每个步骤耗时越长
```

**📈 表大小与执行时间关系**
```
小表 (< 1GB)：
执行时间：秒级到分钟级
影响：基本可忽略

中表 (1GB - 100GB)：
执行时间：分钟级到小时级  
影响：需要考虑业务影响

大表 (> 100GB)：
执行时间：小时级到天级
影响：严重影响业务连续性

示例对比：
表大小     添加列耗时    添加索引耗时
10MB      2秒          5秒
1GB       30秒         2分钟
100GB     30分钟       2小时
1TB       5小时        1天
```

### 2.2 数据类型影响分析


**🔸 数据类型复杂度分级**

**简单数据类型（处理快）**：
```sql
-- 整数类型
INT, BIGINT, SMALLINT

-- 定长字符类型  
CHAR(10)

-- 日期时间类型
DATE, DATETIME

特点：
• 存储空间固定
• 处理逻辑简单
• 转换成本低
```

**复杂数据类型（处理慢）**：
```sql
-- 可变长字符类型
VARCHAR(255), TEXT

-- 二进制类型
BLOB, LONGBLOB

-- JSON类型
JSON

-- 枚举类型
ENUM('a','b','c')

特点：
• 存储空间可变
• 需要额外处理逻辑
• 转换验证复杂
```

**🔧 数据类型转换成本**
```
转换复杂度等级：

低成本转换：
INT → BIGINT          # 扩大范围，兼容
CHAR(10) → CHAR(20)   # 扩大长度

中成本转换：
VARCHAR(50) → VARCHAR(100)  # 长度扩展
INT → VARCHAR(20)           # 类型改变但兼容

高成本转换：
VARCHAR → INT         # 需要数据验证
TEXT → JSON          # 需要格式验证  
DATETIME → TIMESTAMP # 时区转换
```

### 2.3 行数与列数的影响


**🔸 行数影响分析**
```
影响公式：DDL耗时 ≈ 行数 × 行处理时间

行处理时间取决于：
• 行大小：列数多、数据长度大
• 索引数量：每行需要更新多个索引
• 数据类型：复杂类型处理慢

实际测试数据：
行数        平均行大小    添加列耗时
100万      100字节      30秒
1000万     100字节      5分钟
1亿        100字节      50分钟
1000万     1KB          30分钟
```

**🔸 列数影响分析**
```
列数影响因素：

内存使用：
• 更多列 → 更大的行缓冲区
• 影响排序和临时表操作

I/O开销：
• 列数多 → 每次读写数据量大
• 磁盘I/O次数增加

处理复杂度：
• 更多列需要更多验证
• 约束检查成本增加
```

---

## 3. 🗂️ 索引相关影响因素


### 3.1 索引数量对性能的影响


**🔸 索引重建机制**
```
DDL操作时的索引处理：

传统方式：
1. 删除所有索引
2. 执行表结构变更
3. 重新创建所有索引

Instant DDL方式：
1. 保持索引结构不变
2. 仅更新元数据
3. 避免索引重建

影响对比：
索引数量    传统DDL耗时    Instant DDL耗时
0个索引     基准时间      基准时间
5个索引     基准×3        基准×1.1
10个索引    基准×6        基准×1.2
20个索引    基准×12       基准×1.4
```

**📊 索引数量影响实测数据**
```
测试环境：1000万行数据表

索引配置          添加列耗时    内存使用    磁盘I/O
仅主键            2分钟        500MB      低
主键+5个普通索引   8分钟        1.5GB      中
主键+10个索引     15分钟       3GB        高
主键+20个索引     35分钟       6GB        很高

关键发现：
• 索引数量与耗时呈线性关系
• 内存使用随索引数量激增
• I/O压力是主要瓶颈
```

### 3.2 索引类型的影响差异


**🔸 不同索引类型的重建成本**

| 索引类型 | **重建复杂度** | **耗时特点** | **资源消耗** |
|---------|--------------|-------------|-------------|
| 🔑 **主键索引** | `最高` | `需要全表重组` | `CPU+I/O密集` |
| 📋 **普通索引** | `中等` | `重建B+树结构` | `I/O密集` |
| 🔍 **唯一索引** | `较高` | `需要唯一性检查` | `CPU+I/O` |
| 📝 **全文索引** | `很高` | `重建词典和倒排表` | `CPU密集` |
| 🌐 **空间索引** | `较高` | `重建空间数据结构` | `CPU+内存` |

**🔧 索引类型影响示例**
```sql
-- 主键变更影响最大（需要重组）
ALTER TABLE large_table DROP PRIMARY KEY;
-- 耗时：可能数小时

-- 普通索引影响中等
ALTER TABLE large_table ADD INDEX idx_name(name);
-- 耗时：通常分钟到小时级

-- 全文索引影响较大（词典重建）
ALTER TABLE large_table ADD FULLTEXT INDEX ft_content(content);
-- 耗时：取决于文本数据量

-- 复合索引影响取决于列数和数据分布
ALTER TABLE large_table ADD INDEX idx_composite(col1, col2, col3);
-- 耗时：比单列索引更长
```

### 3.3 索引大小与数据分布影响


**🔸 索引大小计算**
```
索引大小影响因素：

基础计算公式：
索引大小 ≈ 行数 × (索引列大小 + 指针大小)

实际考虑因素：
• 列数据类型：INT(4字节) vs VARCHAR(N字节)
• 数据重复度：重复多的压缩效果好
• 索引类型：聚簇索引包含所有列数据
• 页填充率：通常75-80%填充

示例计算：
表：1000万行
索引：INT列（4字节）+ 指针（6字节）
索引大小 ≈ 10,000,000 × 10字节 ≈ 95MB
```

**🔸 数据分布对索引性能的影响**
```
数据分布类型：

均匀分布：
• 索引树平衡
• 查询性能稳定
• 重建效率高

倾斜分布：
• 索引树不平衡
• 部分叶子节点过大
• 重建时间延长

顺序数据：
• 索引构建快
• 但可能造成热点
• 适合B+树结构

随机数据：
• 索引构建慢
• 树结构平衡
• 查询性能好
```

---

## 4. 🔧 存储引擎差异分析


### 4.1 InnoDB与MyISAM的DDL差异


**🔸 InnoDB存储引擎特点**
```
DDL执行特性：
• 支持事务：DDL操作可以回滚
• 行级锁定：并发性能更好
• 外键支持：需要检查外键约束
• 聚簇索引：主键索引包含全部数据

DDL性能特点：
优势：
✅ 支持Online DDL
✅ 更好的并发处理
✅ 支持Instant DDL

劣势：
❌ 外键检查增加耗时
❌ 事务日志开销
❌ 更复杂的内部结构
```

**🔸 MyISAM存储引擎特点**
```
DDL执行特性：
• 表级锁定：整表锁定期间不可访问
• 无事务支持：操作不可回滚
• 无外键约束：检查步骤更少
• 非聚簇索引：索引和数据分离

DDL性能特点：
优势：
✅ 结构简单，处理快
✅ 无事务开销
✅ 索引重建较快

劣势：
❌ 表级锁影响并发
❌ 不支持Online DDL
❌ 操作不可回滚
```

### 4.2 存储引擎性能对比


**📊 实际性能测试对比**
```
测试场景：1000万行数据表，添加普通索引

存储引擎    执行时间    锁定时间    并发影响    回滚支持
InnoDB     15分钟      30秒       轻微       支持
MyISAM     8分钟       15分钟     严重       不支持
Memory     2分钟       10分钟     严重       不支持
Archive    不支持      -          -          -

关键对比点：
• InnoDB虽然执行时间长，但锁定时间短
• MyISAM执行快但影响并发访问
• Memory引擎最快但数据易丢失
```

### 4.3 存储引擎选择建议


**🎯 DDL场景下的引擎选择**
```
生产环境建议：
首选InnoDB：
• 支持Online DDL
• 事务安全保障
• 更好的并发性能
• 支持外键约束

特殊场景考虑：
临时表操作：Memory引擎
只读数据仓库：MyISAM可考虑
归档数据：Archive引擎

切换策略：
MyISAM → InnoDB迁移：
ALTER TABLE table_name ENGINE=InnoDB;
```

---

## 5. 💻 硬件资源影响分析


### 5.1 CPU使用率影响


**🔸 CPU在DDL中的作用**
```
CPU密集型操作：
• 数据类型转换
• 索引键值计算
• 排序操作
• 压缩/解压缩
• 校验和计算

CPU影响表现：
单核CPU：
• DDL操作串行化
• 耗时线性增长
• 无法并行处理

多核CPU：
• 部分操作可并行
• 排序可以多线程
• 索引构建可并发

实测数据：
CPU核数    DDL耗时    CPU使用率
2核       基准       95%
4核       基准×0.7   80%
8核       基准×0.5   60%
16核      基准×0.4   40%
```

**🔧 CPU性能优化配置**
```sql
-- 调整排序缓冲区大小
SET sort_buffer_size = 256M;

-- 调整批量插入缓冲区
SET bulk_insert_buffer_size = 256M;

-- 调整索引创建的排序缓冲区
SET myisam_sort_buffer_size = 512M;

-- 并行DDL配置（MySQL 8.0+）
SET innodb_ddl_threads = 4;
```

### 5.2 内存使用影响


**🔸 内存在DDL中的关键作用**
```
内存使用场景：
1. 排序缓冲区：用于索引构建时排序
2. 数据缓冲区：缓存表数据页
3. 索引缓冲区：缓存索引页
4. 临时表空间：存储中间结果
5. 连接缓冲区：客户端连接使用

内存不足的影响：
• 频繁磁盘交换
• 临时文件使用增加
• 排序操作变慢
• 整体性能下降
```

**📊 内存配置影响测试**
```
测试场景：5000万行表添加索引

可用内存    执行时间    磁盘I/O    临时文件
2GB        120分钟     很高       8GB
8GB        45分钟      高         2GB
16GB       25分钟      中等       500MB
32GB       20分钟      低         100MB

关键内存参数：
innodb_buffer_pool_size：至少数据大小的50%
sort_buffer_size：256M-1GB
join_buffer_size：256M
tmp_table_size：1GB
```

### 5.3 I/O性能瓶颈分析


**🔸 磁盘I/O影响机制**
```
I/O密集型操作：
• 表数据扫描
• 索引数据读取
• 临时文件写入
• 结果数据写回

I/O性能指标：
IOPS（每秒I/O操作）：
• 机械硬盘：100-200 IOPS
• SATA SSD：10,000-50,000 IOPS  
• NVMe SSD：100,000-500,000 IOPS

吞吐量（MB/s）：
• 机械硬盘：100-200 MB/s
• SATA SSD：500-600 MB/s
• NVMe SSD：2,000-7,000 MB/s
```

**🔧 I/O性能优化策略**
```
硬件层面：
• 使用SSD替代机械硬盘
• 配置RAID提高并发I/O
• 分离数据和日志文件到不同磁盘

软件层面：
• 调整innodb_io_capacity参数
• 优化innodb_flush_method设置
• 合理配置innodb_log_file_size

-- I/O相关参数优化
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_io_capacity_max = 4000;
SET GLOBAL innodb_flush_method = 'O_DIRECT';
```

---

## 6. ⚙️ 系统配置与网络因素


### 6.1 MySQL系统配置影响


**🔸 关键配置参数分析**

**缓冲池配置**：
```sql
-- InnoDB缓冲池大小（最重要）
innodb_buffer_pool_size = 16G  # 建议物理内存的70-80%

-- 缓冲池实例数
innodb_buffer_pool_instances = 8  # 大内存时分割缓冲池

-- 缓冲池预加载
innodb_buffer_pool_load_at_startup = ON
innodb_buffer_pool_dump_at_shutdown = ON
```

**日志配置**：
```sql
-- 重做日志大小
innodb_log_file_size = 2G  # 影响DDL恢复时间

-- 日志缓冲区大小
innodb_log_buffer_size = 256M

-- 刷新策略
innodb_flush_log_at_trx_commit = 2  # DDL时可以适当放宽
```

**并发配置**：
```sql
-- 最大连接数
max_connections = 1000

-- DDL并发线程（MySQL 8.0+）
innodb_ddl_threads = 4

-- 并行查询线程
innodb_parallel_read_threads = 8
```

### 6.2 操作系统级优化


**🔸 文件系统选择**
```
文件系统性能对比：

ext4文件系统：
• 通用性好，稳定性高
• 大文件支持良好
• 性能中等

XFS文件系统：
• 大文件性能更好
• 并发I/O优秀
• 适合数据库应用

推荐挂载参数：
/dev/sdb1 /var/lib/mysql xfs defaults,noatime,nodiratime 0 0

noatime：不更新访问时间，减少I/O
nodiratime：不更新目录访问时间
```

**🔸 内核参数调优**
```bash
# 调整虚拟内存参数
echo 1 > /proc/sys/vm/swappiness          # 减少交换使用
echo 0 > /proc/sys/vm/zone_reclaim_mode   # 禁用NUMA区域回收

# 调整文件描述符限制
echo "mysql soft nofile 65535" >> /etc/security/limits.conf
echo "mysql hard nofile 65535" >> /etc/security/limits.conf

# 调整网络参数
echo "net.core.rmem_max = 134217728" >> /etc/sysctl.conf
echo "net.core.wmem_max = 134217728" >> /etc/sysctl.conf
```

### 6.3 网络延迟因素分析


**🔸 网络对DDL的影响**
```
网络影响场景：

客户端执行DDL：
• 命令传输延迟
• 结果返回延迟
• 大结果集传输影响

主从复制场景：
• DDL语句同步延迟
• 二进制日志传输
• 从库执行延迟

网络延迟测试：
本地连接：      < 1ms
局域网连接：    1-5ms
广域网连接：    10-100ms
跨地域连接：    100-500ms
```

**🔧 网络优化策略**
```sql
-- 调整网络缓冲区
SET GLOBAL net_buffer_length = 32768;
SET GLOBAL max_allowed_packet = 1073741824;  # 1GB

-- 调整连接超时
SET GLOBAL wait_timeout = 28800;
SET GLOBAL interactive_timeout = 28800;

-- 启用压缩传输（慢网络环境）
mysql -C -h remote_host -u user -p
```

---

## 7. 🚦 并发负载与缓存影响


### 7.1 并发负载对DDL的影响


**🔸 并发场景分析**
```
并发类型影响：

读并发：
• SELECT查询与DDL并行
• Online DDL可以处理
• 传统DDL会阻塞读操作

写并发：
• INSERT/UPDATE/DELETE与DDL冲突
• 需要等待DDL完成或DDL等待写操作
• 可能造成锁等待

混合并发：
• 读写操作同时存在
• DDL执行复杂度增加
• 需要精确的锁管理
```

**📊 并发负载实测数据**
```
测试场景：1000万行表添加索引

并发类型        DDL耗时    查询延迟    系统负载
无并发          15分钟     N/A        低
100个读并发     18分钟     50ms       中
50个写并发      25分钟     200ms      高
混合并发        30分钟     300ms      很高

关键发现：
• 写并发对DDL影响最大
• 读并发影响相对较小
• 混合负载最复杂
```

### 7.2 缓存命中率影响


**🔸 缓存类型与DDL关系**

**InnoDB Buffer Pool缓存**：
```sql
-- 查看缓存命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';

缓存状态影响：
高命中率（>95%）：
• DDL执行快
• 内存操作为主
• 减少磁盘I/O

低命中率（<80%）：
• DDL执行慢
• 频繁磁盘访问
• I/O成为瓶颈

-- 预热缓存策略
SELECT COUNT(*) FROM large_table FORCE INDEX(PRIMARY);
```

**查询缓存影响**：
```sql
-- DDL操作会使查询缓存失效
SHOW STATUS LIKE 'Qcache%';

缓存失效影响：
• DDL执行时清空相关缓存
• 执行后查询性能临时下降
• 需要重新构建缓存

-- 可以考虑临时禁用查询缓存
SET GLOBAL query_cache_size = 0;
```

### 7.3 系统负载监控与调整


**🔧 负载监控指标**
```bash
# CPU使用率监控
top -p `pidof mysqld`

# 内存使用监控  
free -h

# I/O使用监控
iostat -x 1

# MySQL进程监控
SHOW PROCESSLIST;
SHOW STATUS LIKE 'Threads_%';
```

**⚡ 负载调整策略**
```sql
-- 动态调整并发连接数
SET GLOBAL max_connections = 500;

-- 调整查询缓存
SET GLOBAL query_cache_limit = 8M;

-- 调整临时表大小
SET GLOBAL tmp_table_size = 512M;
SET GLOBAL max_heap_table_size = 512M;

-- 监控当前DDL进度（MySQL 8.0+）
SELECT * FROM performance_schema.events_stages_current 
WHERE EVENT_NAME LIKE 'stage/innodb/alter%';
```

---

## 8. 🔍 性能瓶颈识别与优化


### 8.1 瓶颈识别方法


**🔸 性能瓶颈分类**
```
I/O瓶颈识别：
症状：
• 磁盘使用率持续100%
• 平均等待时间高
• 缓存命中率低

检测命令：
iostat -x 1
iotop
```

**CPU瓶颈识别**：
```
症状：
• CPU使用率持续高负载
• 系统响应慢
• 排序操作频繁

检测方法：
top -p `pidof mysqld`
perf top
```

**内存瓶颈识别**：
```
症状：
• 交换空间使用增加
• 缓冲区命中率下降
• 临时文件使用多

检测方法：
free -h
swapon -s
```

### 8.2 MySQL性能分析工具


**🔧 内置性能分析**
```sql
-- 启用性能分析
SET profiling = 1;

-- 执行DDL操作
ALTER TABLE test_table ADD COLUMN new_col INT;

-- 查看执行分析
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;

-- 查看详细I/O统计
SHOW PROFILE BLOCK IO FOR QUERY 1;
```

**📊 Performance Schema监控**
```sql
-- 监控DDL阶段
SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE '%alter%';

-- 监控锁等待
SELECT * FROM performance_schema.data_locks;

-- 监控I/O统计
SELECT * FROM performance_schema.file_summary_by_instance 
WHERE FILE_NAME LIKE '%ibd';
```

### 8.3 优化策略总结


**🎯 针对性优化方案**

**I/O瓶颈优化**：
```sql
-- 增加I/O容量配置
SET GLOBAL innodb_io_capacity = 4000;
SET GLOBAL innodb_io_capacity_max = 8000;

-- 优化刷新策略
SET GLOBAL innodb_flush_neighbors = 0;  # SSD环境
SET GLOBAL innodb_flush_method = 'O_DIRECT';

-- 分离表空间
CREATE TABLE new_table (...) DATA DIRECTORY = '/fast_ssd/';
```

**CPU瓶颈优化**：
```sql
-- 启用并行DDL（MySQL 8.0+）
SET GLOBAL innodb_ddl_threads = 8;

-- 优化排序参数
SET sort_buffer_size = 1G;
SET read_rnd_buffer_size = 256M;

-- 调整并发参数
SET GLOBAL innodb_thread_concurrency = 0;  # 自动调整
```

**内存瓶颈优化**：
```sql
-- 增加缓冲池
SET GLOBAL innodb_buffer_pool_size = 32G;

-- 优化临时表设置
SET GLOBAL tmp_table_size = 2G;
SET GLOBAL max_heap_table_size = 2G;

-- 调整连接缓冲区
SET GLOBAL join_buffer_size = 512M;
```

**🔄 综合优化流程**
```
1. 性能基线测试
   ↓
2. 瓶颈识别分析
   ↓  
3. 针对性参数调优
   ↓
4. 效果验证测试
   ↓
5. 持续监控优化
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 影响因素分层：数据层、结构层、系统层三个维度
🔸 表大小影响：数据量是影响DDL性能的基础因素
🔸 索引数量影响：每个索引都需要重建，成倍增加耗时
🔸 存储引擎差异：InnoDB支持Online DDL，MyISAM不支持
🔸 硬件资源：CPU、内存、I/O是三大硬件瓶颈
🔸 系统配置：MySQL参数配置直接影响DDL性能
🔸 并发负载：写并发对DDL影响最大
🔸 缓存命中率：高命中率显著提升DDL性能
```

### 9.2 关键理解要点


**🔹 性能影响的本质**
```
根本原理：
DDL操作 = 数据读取 + 结构变更 + 数据写入 + 索引重建

每个环节都受到不同因素影响：
• 数据读取：受I/O性能和缓存命中率影响
• 结构变更：受CPU性能和内存大小影响  
• 数据写入：受磁盘性能和文件系统影响
• 索引重建：受索引数量和类型影响
```

**🔹 优化的优先级**
```
优化优先级排序：
1. 表大小控制：分批处理大表
2. 索引优化：减少不必要索引
3. 硬件升级：SSD、大内存优先
4. 参数调优：针对瓶颈调整
5. 并发控制：避免高峰期执行
```

**🔹 实际应用策略**
```
生产环境建议：
• 大表DDL必须在维护窗口执行
• 提前进行性能测试和容量规划
• 监控系统资源使用情况
• 准备回滚方案
• 使用Online DDL减少影响
```

### 9.3 实际应用价值


**📈 性能优化收益**
- **执行时间缩短**：合理优化可缩短50-80%执行时间
- **业务影响降低**：Online DDL将锁定时间从小时级降到秒级
- **资源利用提升**：针对性优化提高硬件利用效率
- **稳定性增强**：避免资源不足导致的系统问题

**🔧 运维实践指导**
- **容量规划**：基于性能因素进行准确的时间评估
- **监控告警**：建立DDL性能监控和异常告警机制
- **优化策略**：根据瓶颈类型选择对应的优化方法
- **风险控制**：通过测试环境验证优化效果

**核心记忆**：
- 表越大索引越多，DDL耗时成倍增长
- I/O内存CPU三大硬件，哪个不足都是瓶颈
- InnoDB支持在线DDL，MyISAM只能离线操作
- 缓存命中率越高，DDL执行速度越快
- 系统参数要调优，并发负载要控制