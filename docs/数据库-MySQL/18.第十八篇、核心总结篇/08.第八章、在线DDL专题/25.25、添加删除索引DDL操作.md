---
title: 25、添加删除索引DDL操作
---
## 📚 目录

1. [索引DDL操作基础概念](#1-索引DDL操作基础概念)
2. [CREATE INDEX创建索引详解](#2-CREATE-INDEX创建索引详解)
3. [DROP INDEX删除索引操作](#3-DROP-INDEX删除索引操作)
4. [索引类型与选择策略](#4-索引类型与选择策略)
5. [在线索引构建与监控](#5-在线索引构建与监控)
6. [索引管理最佳实践](#6-索引管理最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 索引DDL操作基础概念


### 1.1 什么是索引DDL操作


**🔸 索引DDL的本质**
```
索引DDL = 数据定义语言中的索引操作
简单理解：就是创建、删除、修改索引的SQL命令

生活类比：
📚 索引 = 书的目录
DDL操作 = 给书添加目录、删除目录、重新整理目录
```

**💡 为什么需要索引DDL操作**
```
问题场景：
• 查询速度慢 → 需要添加索引加速
• 存储空间不足 → 需要删除无用索引
• 业务需求变化 → 需要调整索引策略
• 数据库优化 → 需要重建索引

解决方案：
通过DDL操作动态调整索引结构
```

### 1.2 索引DDL操作的分类


**📋 主要操作类型**
```
┌─────────────────────────────────────┐
│           索引DDL操作                │
├─────────────────────────────────────┤
│ CREATE INDEX  → 创建新索引          │
│ DROP INDEX    → 删除现有索引        │  
│ ALTER INDEX   → 修改索引属性        │
│ RENAME INDEX  → 重命名索引          │
└─────────────────────────────────────┘
```

**🎯 操作重要程度**
- 🔴 **必须掌握**：CREATE INDEX, DROP INDEX
- 🟡 **建议了解**：ALTER INDEX, RENAME INDEX  
- 🟢 **拓展知识**：索引重建、分区索引

---

## 2. 🏗️ CREATE INDEX创建索引详解


### 2.1 基本CREATE INDEX语法


**📝 标准语法格式**
```sql
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
ON table_name (column1, column2, ...)
[USING index_type]
[algorithm_option | lock_option];
```

**🔍 语法要素解释**
```
CREATE INDEX：创建索引的关键字
index_name：给索引起个名字（自己定义）
table_name：在哪张表上创建索引
(column1, column2)：基于哪些列创建索引
USING：指定索引类型（BTREE、HASH等）
```

### 2.2 单列索引创建


**💡 最简单的索引创建**
```sql
-- 在users表的email列创建索引
CREATE INDEX idx_email ON users(email);

-- 实际效果类比：
-- 原来找邮箱要一行行翻 📄📄📄
-- 现在有了邮箱目录 📋 直接定位
```

**🔧 带选项的单列索引**
```sql
-- 创建唯一索引（不允许重复值）
CREATE UNIQUE INDEX idx_username ON users(username);

-- 指定索引算法
CREATE INDEX idx_age ON users(age) USING BTREE;
```

### 2.3 复合索引创建


**🔗 什么是复合索引**
```
复合索引 = 基于多个列的索引
就像电话本：先按姓氏排序，姓氏相同再按名字排序

例子：
CREATE INDEX idx_name_age ON users(last_name, first_name, age);

查询优化场景：
✅ WHERE last_name = 'Zhang'                    -- 能用索引
✅ WHERE last_name = 'Zhang' AND first_name = 'Wei'  -- 能用索引  
✅ WHERE last_name = 'Zhang' AND age = 25       -- 能用索引
❌ WHERE first_name = 'Wei'                     -- 不能用索引
❌ WHERE age = 25                               -- 不能用索引
```

**📊 复合索引的顺序重要性**
```
索引顺序规则：最左前缀匹配
CREATE INDEX idx_abc ON table(a, b, c);

可以优化的查询：
• WHERE a = ?
• WHERE a = ? AND b = ?  
• WHERE a = ? AND b = ? AND c = ?

不能优化的查询：
• WHERE b = ?
• WHERE c = ?
• WHERE b = ? AND c = ?
```

### 2.4 特殊类型索引创建


**📝 全文索引（FULLTEXT）**
```sql
-- 创建全文索引（用于文本搜索）
CREATE FULLTEXT INDEX idx_content ON articles(title, content);

-- 使用场景：
-- 在文章标题和内容中搜索关键词
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 索引');
```

**🗺️ 空间索引（SPATIAL）**
```sql
-- 创建空间索引（用于地理位置数据）
CREATE SPATIAL INDEX idx_location ON stores(location);

-- 使用场景：
-- 查找附近的商店
SELECT * FROM stores 
WHERE ST_Distance(location, POINT(116.4, 39.9)) < 1000;
```

### 2.5 在线索引创建算法


**⚡ 算法选择对比**
```sql
-- COPY算法：创建临时表，影响性能
CREATE INDEX idx_name ON users(name) ALGORITHM=COPY;

-- INPLACE算法：原地修改，推荐使用
CREATE INDEX idx_name ON users(name) ALGORITHM=INPLACE;

-- INSTANT算法：瞬间完成（MySQL 8.0+）
CREATE INDEX idx_name ON users(name) ALGORITHM=INSTANT;
```

**🔒 锁定级别选择**
```sql
-- NONE：不锁表，允许并发读写（推荐）
CREATE INDEX idx_name ON users(name) LOCK=NONE;

-- SHARED：共享锁，允许读，禁止写
CREATE INDEX idx_name ON users(name) LOCK=SHARED;

-- EXCLUSIVE：排他锁，禁止读写（避免使用）
CREATE INDEX idx_name ON users(name) LOCK=EXCLUSIVE;
```

---

## 3. 🗑️ DROP INDEX删除索引操作


### 3.1 基本DROP INDEX语法


**📝 删除语法格式**
```sql
-- 方式1：使用DROP INDEX
DROP INDEX index_name ON table_name;

-- 方式2：使用ALTER TABLE
ALTER TABLE table_name DROP INDEX index_name;
```

**💡 删除索引示例**
```sql
-- 删除用户表的邮箱索引
DROP INDEX idx_email ON users;

-- 删除复合索引
DROP INDEX idx_name_age ON users;

-- 删除主键索引（特殊语法）
ALTER TABLE users DROP PRIMARY KEY;
```

### 3.2 删除前的检查工作


**🔍 检查索引使用情况**
```sql
-- 查看表的所有索引
SHOW INDEX FROM users;

-- 检查索引使用统计
SELECT * FROM sys.schema_unused_indexes 
WHERE object_schema = 'your_database' 
  AND object_name = 'users';
```

**⚠️ 删除前的注意事项**
```
删除索引检查清单：
✅ 确认索引没有被重要查询使用
✅ 检查是否有外键约束依赖
✅ 评估删除后对性能的影响
✅ 备份重要数据（如果需要）
```

### 3.3 批量删除索引


**🗂️ 查找无用索引**
```sql
-- 查找从未使用的索引
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    s.INDEX_NAME,
    s.COLUMN_NAME
FROM information_schema.TABLES t
JOIN information_schema.STATISTICS s ON t.TABLE_NAME = s.TABLE_NAME
LEFT JOIN sys.schema_unused_indexes u ON s.INDEX_NAME = u.index_name
WHERE t.TABLE_SCHEMA = 'your_database'
  AND u.index_name IS NOT NULL;
```

**🔧 生成删除脚本**
```sql
-- 生成删除无用索引的SQL脚本
SELECT CONCAT('DROP INDEX ', INDEX_NAME, ' ON ', TABLE_NAME, ';') AS drop_sql
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
  AND INDEX_NAME IN (
    SELECT index_name FROM sys.schema_unused_indexes 
    WHERE object_schema = 'your_database'
  );
```

---

## 4. 🎯 索引类型与选择策略


### 4.1 主要索引类型详解


**🌳 B-Tree索引（默认类型）**
```
特点：
• 适用于大部分查询场景
• 支持范围查询、排序、分组
• 平衡树结构，查询效率稳定

最佳使用场景：
✅ 等值查询：WHERE id = 100
✅ 范围查询：WHERE age BETWEEN 18 AND 65  
✅ 排序操作：ORDER BY name
✅ 分组操作：GROUP BY category
```

**⚡ Hash索引**
```sql
-- 创建Hash索引（Memory引擎）
CREATE INDEX idx_hash_id ON memory_table(id) USING HASH;

特点：
• 等值查询极快 O(1)
• 不支持范围查询
• 不支持排序

适用场景：
✅ 精确匹配：WHERE id = 123
❌ 范围查询：WHERE id > 100
❌ 排序：ORDER BY id
```

### 4.2 索引选择决策树


**🤔 选择哪种索引类型？**
```
查询类型分析：
    
等值查询为主？
    ↓ 是
Hash索引 (Memory引擎)
    ↓ 否
    
需要范围查询？
    ↓ 是  
B-Tree索引
    ↓ 否
    
文本搜索？
    ↓ 是
FULLTEXT索引
    ↓ 否
    
地理位置？
    ↓ 是
SPATIAL索引
    ↓ 否
    
默认B-Tree索引
```

### 4.3 复合索引设计原则


**📏 列顺序优化原则**
```
设计原则（重要性递减）：
1️⃣ 区分度高的列放前面
2️⃣ 等值查询的列放前面  
3️⃣ 范围查询的列放后面
4️⃣ 排序的列放最后

示例分析：
CREATE INDEX idx_order ON orders(status, user_id, create_time);

查询分析：
WHERE status = 'paid'           -- 区分度高，放第一
  AND user_id = 12345           -- 等值查询，放第二  
  AND create_time > '2024-01-01' -- 范围查询，放第三
ORDER BY create_time;           -- 排序，放最后
```

**📊 索引选择性计算**
```sql
-- 计算列的选择性（值越接近1越好）
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS selectivity,
    'column_name' AS column_name
FROM table_name;

-- 选择性参考标准：
-- > 0.1：适合做索引
-- > 0.5：非常适合做索引首列
-- < 0.01：不适合单独做索引
```

---

## 5. 📊 在线索引构建与监控


### 5.1 在线DDL的工作原理


**🔄 在线索引构建流程**
```
阶段1：准备阶段
┌─────────────────┐
│ 获取表的元数据   │ ← 短暂锁表
│ 创建临时索引文件 │
└─────────────────┘
          ↓
阶段2：构建阶段  
┌─────────────────┐
│ 扫描表数据      │ ← 允许并发读写
│ 构建索引结构    │ ← 记录变更日志
└─────────────────┘
          ↓
阶段3：应用阶段
┌─────────────────┐
│ 应用变更日志    │ ← 短暂锁表
│ 切换索引文件    │
└─────────────────┘
```

**⏱️ 时间成本分析**
```
影响因素：
• 表大小：数据量越大，构建时间越长
• 索引复杂度：复合索引比单列索引慢
• 系统负载：高并发环境下会更慢
• 磁盘性能：SSD比HDD快很多

时间估算：
小表（< 1GB）：   几秒到几分钟
中表（1-10GB）：  几分钟到半小时  
大表（> 10GB）：  半小时到几小时
```

### 5.2 索引构建监控


**📈 监控索引创建进度**
```sql
-- 查看当前DDL操作进度
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM information_schema.PROCESSLIST 
WHERE COMMAND = 'Query' 
  AND INFO LIKE '%CREATE INDEX%';
```

**🔍 性能监控指标**
```sql
-- 监控索引构建的系统资源使用
SELECT 
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT/1000000000 AS TOTAL_TIME_SEC,
    AVG_TIMER_WAIT/1000000000 AS AVG_TIME_SEC
FROM performance_schema.events_statements_summary_by_event_name 
WHERE EVENT_NAME LIKE '%sql/create_index%';
```

### 5.3 大表索引构建策略


**🎯 分步构建策略**
```sql
-- 策略1：业务低峰期构建
-- 选择凌晨2-6点等低峰时段

-- 策略2：使用ALGORITHM和LOCK控制
CREATE INDEX idx_big_table 
ON big_table(column1, column2) 
ALGORITHM=INPLACE 
LOCK=NONE;

-- 策略3：分批处理（对于超大表）
-- 可以考虑分区表，分别在每个分区创建索引
```

**⚠️ 风险控制措施**
```
建设前检查：
✅ 磁盘空间充足（预留2倍表大小）
✅ 系统负载较低
✅ 备份数据已完成
✅ 回滚计划已准备

监控指标：
📊 CPU使用率 < 80%
📊 磁盘I/O < 90%  
📊 内存使用 < 85%
📊 连接数 < 最大连接数的70%
```

---

## 6. 🎛️ 索引管理最佳实践


### 6.1 索引命名规范


**📝 推荐命名规则**
```
命名模式：
• 单列索引：idx_[表名]_[列名]
• 复合索引：idx_[表名]_[列1]_[列2]
• 唯一索引：uk_[表名]_[列名]  
• 外键索引：fk_[表名]_[外键表]

示例：
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE UNIQUE INDEX uk_users_username ON users(username);
```

**🎯 命名规范的好处**
```
规范命名的优势：
✅ 一眼看出索引用途
✅ 便于团队协作维护
✅ 避免重复创建索引
✅ 方便自动化管理脚本
```

### 6.2 索引维护策略


**🔄 定期索引健康检查**
```sql
-- 检查索引碎片率
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    ROUND(DATA_FREE/1024/1024, 2) AS FRAGMENTATION_MB
FROM information_schema.TABLES 
WHERE DATA_FREE > 0 
  AND TABLE_SCHEMA = 'your_database';

-- 重建碎片化严重的索引
ALTER TABLE table_name FORCE;
```

**📊 索引使用情况分析**
```sql
-- 创建索引使用统计视图
CREATE VIEW index_usage_stats AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch,
    idx_tup_read + idx_tup_fetch as total_reads
FROM pg_stat_user_indexes 
ORDER BY total_reads DESC;
```

### 6.3 索引优化建议


**💡 常见索引优化场景**
```
场景1：慢查询优化
问题：SELECT * FROM orders WHERE customer_id = ? AND status = ?
解决：CREATE INDEX idx_orders_customer_status ON orders(customer_id, status);

场景2：排序优化  
问题：SELECT * FROM products ORDER BY price, rating;
解决：CREATE INDEX idx_products_price_rating ON products(price, rating);

场景3：分组优化
问题：SELECT category, COUNT(*) FROM products GROUP BY category;
解决：CREATE INDEX idx_products_category ON products(category);
```

**🎯 索引创建决策流程**
```
创建索引决策树：

查询是否频繁？
    ↓ 否 → 不创建索引
    ↓ 是
    
表数据量是否大？
    ↓ 否 → 可能不需要索引  
    ↓ 是
    
查询性能是否慢？
    ↓ 否 → 暂不创建
    ↓ 是
    
分析查询模式 → 设计合适索引 → 创建并测试
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


**🔸 索引DDL操作本质**
```
CREATE INDEX：为表创建新的索引结构
DROP INDEX：删除现有的索引结构
核心目的：优化查询性能，管理存储空间
```

**🔸 索引类型选择**
```
B-Tree：通用索引，适用于大多数场景
Hash：等值查询快，不支持范围查询
FULLTEXT：全文搜索专用
SPATIAL：地理位置数据专用
```

**🔸 复合索引原则**
```
最左前缀匹配：索引只能从左侧开始使用
列顺序重要：区分度高的列放前面
设计合理：避免冗余和过度索引
```

### 7.2 关键理解要点


**🔹 在线DDL的价值**
```
传统DDL问题：
- 需要锁表，影响业务
- 创建时间长，用户等待
- 风险高，可能导致服务中断

在线DDL优势：
- 允许并发读写操作
- 最小化锁定时间
- 业务影响降到最低
```

**🔹 索引管理的平衡**
```
索引带来的好处：
✅ 查询速度提升
✅ 排序分组优化
✅ 唯一性约束

索引带来的成本：
❌ 存储空间增加
❌ 写入性能下降  
❌ 维护开销增大
```

### 7.3 实际应用指导


**🎯 创建索引的时机**
```
适合创建索引：
• 经常出现在WHERE条件中的列
• 频繁用于JOIN的列  
• 经常用于ORDER BY的列
• 大表上的查询优化

不适合创建索引：
• 很少查询的列
• 频繁更新的列
• 区分度很低的列（如性别）
• 小表（< 1000行）
```

**🔧 索引维护流程**
```
日常维护检查清单：
📋 监控慢查询日志
📋 分析索引使用统计
📋 检查索引碎片情况
📋 清理无用索引
📋 优化重复索引
```

### 7.4 最佳实践总结


**💡 索引设计原则**
- **精准设计**：根据实际查询模式设计索引
- **适度原则**：避免过度索引影响写入性能
- **命名规范**：使用统一的索引命名规则
- **定期维护**：建立索引健康检查机制

**⚡ 性能优化要点**
- **选择合适的算法**：INPLACE > COPY > DEFAULT
- **控制锁定级别**：LOCK=NONE > SHARED > EXCLUSIVE  
- **监控构建过程**：关注系统资源使用情况
- **制定回滚计划**：准备索引删除的应急方案

**🎯 一句话精华**：
索引DDL就像给书本整理目录，创建合适的目录让查找更快，删除无用的目录节省空间

**🧠 记忆锚点**：
看到查询慢想到CREATE INDEX，看到空间不足想到DROP INDEX，看到业务变化想到索引调整