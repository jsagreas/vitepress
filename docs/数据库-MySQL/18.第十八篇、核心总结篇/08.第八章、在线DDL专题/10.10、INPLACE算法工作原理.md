---
title: 10、INPLACE算法工作原理
---
## 📚 目录

1. [INPLACE算法概念](#1-INPLACE算法概念)
2. [原地结构修改机制](#2-原地结构修改机制)
3. [核心工作流程](#3-核心工作流程)
4. [并发DML支持原理](#4-并发DML支持原理)
5. [异常恢复与性能优化](#5-异常恢复与性能优化)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔧 INPLACE算法概念


### 1.1 什么是INPLACE算法


**基本定义**：INPLACE（原地）算法是MySQL中一种**直接在原表上修改结构**的DDL实现方式，避免了重建整个表的开销。

```
传统COPY算法：
原表 → 创建新表 → 数据迁移 → 替换表名 → 删除原表

INPLACE算法：
原表 → 直接修改结构 → 保持数据位置 → 完成变更
```

**核心理念**：
- **就地修改**：在原有存储空间上直接调整结构
- **最小化数据移动**：尽可能减少数据的物理迁移
- **支持并发**：DDL执行期间允许DML操作
- **快速完成**：相比重建表，速度显著提升

### 1.2 适用场景分析


**✅ 适合INPLACE的操作**：
```sql
-- 添加普通索引
ALTER TABLE users ADD INDEX idx_email (email);

-- 删除索引
ALTER TABLE users DROP INDEX idx_phone;

-- 添加列（表末尾）
ALTER TABLE users ADD COLUMN last_login DATETIME;

-- 修改列默认值
ALTER TABLE users ALTER COLUMN status SET DEFAULT 'active';

-- 重命名列
ALTER TABLE users CHANGE old_name new_name VARCHAR(100);
```

**❌ 不适合INPLACE的操作**：
```sql
-- 修改列数据类型
ALTER TABLE users MODIFY COLUMN age BIGINT;

-- 添加主键
ALTER TABLE users ADD PRIMARY KEY (id);

-- 修改字符集
ALTER TABLE users CONVERT TO CHARACTER SET utf8mb4;
```

### 1.3 INPLACE vs 其他算法对比


| 算法类型 | **数据迁移** | **表锁时间** | **并发DML** | **磁盘空间** | **执行速度** |
|---------|-------------|-------------|-------------|-------------|-------------|
| **COPY** | `完全重建` | `长时间锁定` | `❌ 不支持` | `需要2倍空间` | `很慢` |
| **INPLACE** | `最小化移动` | `短暂锁定` | `✅ 支持` | `少量临时空间` | `快速` |
| **INSTANT** | `无数据移动` | `瞬间完成` | `✅ 完全支持` | `几乎无额外空间` | `极快` |

---

## 2. 🏗️ 原地结构修改机制


### 2.1 数据页面重组原理


**页面结构调整**：INPLACE算法通过重新组织数据页内部结构来实现列的添加或修改。

```
原始页面结构：
┌─────────────────────────────────────┐
│ 页头 │ 记录1 │ 记录2 │ 记录3 │ 空闲空间 │
└─────────────────────────────────────┘

添加列后的页面结构：
┌──────────────────────────────────────────────┐
│ 页头 │ 记录1* │ 记录2* │ 记录3* │ 空闲空间 │
└──────────────────────────────────────────────┘
注：记录*表示扩展了新列的记录
```

**重组过程**：
1. **空间检查**：确认页面是否有足够空间存储新列
2. **记录重写**：逐条重写记录，添加新列数据
3. **指针更新**：更新页面内部的记录指针
4. **空间整理**：整理页面碎片，优化存储效率

### 2.2 行格式调整机制


**动态行格式**：MySQL使用动态行格式来支持INPLACE操作。

```sql
-- 查看表的行格式
SHOW TABLE STATUS LIKE 'users'\G

-- 结果示例
Row_format: Dynamic  -- 支持INPLACE操作
```

**行格式调整步骤**：
```
步骤1：分析新列规格
- 数据类型：VARCHAR(100)
- 是否允许NULL：YES
- 默认值：NULL

步骤2：计算空间需求
- 变长字段长度：2字节长度前缀
- NULL位图：1位标识
- 实际数据：根据内容动态分配

步骤3：调整行结构
- 扩展NULL位图
- 添加长度信息
- 预留数据空间
```

### 2.3 索引树调整策略


**B+树结构维护**：添加索引时，INPLACE算法需要构建新的B+树结构。

```
索引构建过程：
原表数据 → 排序 → 构建B+树 → 更新元数据

     Root
    /    \
 Leaf1   Leaf2   ← 新索引的叶子节点
   |       |
 数据页   数据页   ← 指向原表数据
```

**增量索引构建**：
- **边扫描边构建**：一边读取表数据，一边构建索引
- **内存排序**：利用`sort_buffer_size`进行内存排序
- **临时文件**：超出内存时使用临时文件辅助排序
- **指针更新**：构建完成后更新索引指针

---

## 3. 🔄 核心工作流程


### 3.1 INPLACE执行的三个阶段


**🔸 准备阶段（Prepare Phase）**
```
1. 元数据锁定
   - 获取MDL（Metadata Lock）
   - 防止并发DDL冲突

2. 结构验证
   - 检查操作是否支持INPLACE
   - 验证表结构兼容性

3. 资源分配
   - 分配临时空间
   - 准备变更日志文件
```

**🔸 执行阶段（Execute Phase）**
```
并行处理流程：

主线程：                  后台线程：
  |                        |
  ├─ 创建变更日志            ├─ 扫描表数据
  ├─ 允许DML操作            ├─ 构建新索引
  ├─ 记录DML变更            ├─ 调整行格式
  └─ 监控进度              └─ 更新统计信息
```

**🔸 提交阶段（Commit Phase）**
```
1. 停止DML记录
   - 获取排他锁
   - 停止接收新的DML

2. 应用变更日志
   - 重放执行期间的DML操作
   - 确保数据一致性

3. 切换元数据
   - 更新数据字典
   - 激活新的表结构

4. 清理资源
   - 释放临时文件
   - 清理变更日志
```

### 3.2 元数据更新过程


**数据字典更新**：
```sql
-- MySQL 8.0 数据字典表
SELECT * FROM INFORMATION_SCHEMA.INNODB_TABLES 
WHERE NAME = 'test/users';

-- 更新过程
更新前：table_id=123, columns=5, indexes=2
更新中：创建新的元数据记录
更新后：table_id=123, columns=6, indexes=3
```

**原子性保证**：
- **事务性更新**：所有元数据更新在一个事务中完成
- **回滚支持**：失败时能够完整回滚到原始状态
- **一致性检查**：确保元数据与实际存储结构一致

### 3.3 临时空间使用策略


**临时文件管理**：
```bash
# 临时文件位置
ls -la /tmp/#sql*.tmp

# 示例文件
-rw-rw---- 1 mysql mysql 134217728 Sep 11 14:30 #sql_1234_1.tmp
```

**空间使用优化**：
```sql
-- 控制临时目录
SET GLOBAL innodb_tmpdir = '/data/mysql/tmp';

-- 监控空间使用
SELECT 
  TABLE_SCHEMA,
  TABLE_NAME,
  DATA_LENGTH + INDEX_LENGTH as 'Size(Bytes)'
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME LIKE '#sql%';
```

---

## 4. 🚀 并发DML支持原理


### 4.1 变更日志机制


**Online DDL日志**：在INPLACE执行期间，所有的DML操作都会被记录到特殊的日志文件中。

```
DML变更日志结构：
┌─────────────────────────────────────────┐
│ 日志头部 │ 操作类型 │ 主键值 │ 变更数据 │
├─────────────────────────────────────────┤
│ Header  │ INSERT  │  1001  │ 新记录   │
│ Header  │ UPDATE  │  1002  │ 旧→新    │
│ Header  │ DELETE  │  1003  │ 删除标记  │
└─────────────────────────────────────────┘
```

**日志记录过程**：
```sql
-- 用户执行DML
INSERT INTO users (name, email) VALUES ('张三', 'zhang@example.com');

-- 系统记录变更
Log Entry: {
  type: 'INSERT',
  table_id: 123,
  primary_key: 1001,
  row_data: '张三,zhang@example.com'
}
```

### 4.2 DML并发控制


**锁机制协调**：
```
读操作（SELECT）：
┌─────────────────┐
│ 共享元数据锁     │ ← 允许并发读取
└─────────────────┘

写操作（INSERT/UPDATE/DELETE）：
┌─────────────────┐
│ 行级锁          │ ← 正常的行锁机制
│ + 变更日志记录   │ ← 额外记录到日志
└─────────────────┘

DDL操作：
┌─────────────────┐
│ 排他元数据锁     │ ← 仅在开始和结束时
│ （极短时间）     │
└─────────────────┘
```

**并发性能监控**：
```sql
-- 查看当前DDL进度
SELECT 
  SQL_TEXT,
  STAGE,
  WORK_COMPLETED,
  WORK_ESTIMATED
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE '%alter%';

-- 示例输出
SQL_TEXT: ALTER TABLE users ADD INDEX idx_email (email)
STAGE: creating index
WORK_COMPLETED: 75
WORK_ESTIMATED: 100
```

### 4.3 中间状态管理


**状态转换图**：
```
表状态转换：
NORMAL → PREPARE → BUILDING → APPLYING → NORMAL
  ↑                                         ↓
  └─────────── ROLLBACK ←──────────────────┘
```

**中间状态特征**：
- **BUILDING状态**：主体DDL工作进行中，DML正常执行
- **APPLYING状态**：应用变更日志，短暂阻塞DML
- **ROLLBACK状态**：异常情况下的回滚恢复

---

## 5. ⚡ 异常恢复与性能优化


### 5.1 异常恢复处理


**故障恢复机制**：
```
系统崩溃后的恢复流程：

1. 检查未完成的DDL
   - 扫描临时文件
   - 检查变更日志

2. 确定恢复策略
   ┌─ 接近完成 → 继续执行
   ├─ 刚刚开始 → 回滚清理
   └─ 中间状态 → 智能判断

3. 执行恢复操作
   - 应用或回滚变更
   - 清理临时资源
   - 更新元数据状态
```

**回滚机制**：
```sql
-- 手动中止DDL（MySQL 8.0+）
KILL QUERY connection_id;

-- 系统自动回滚流程
1. 停止DDL进程
2. 回滚已应用的变更
3. 删除临时文件
4. 恢复原始元数据
5. 释放所有锁
```

### 5.2 性能优化策略


**内存优化配置**：
```sql
-- 排序缓冲区大小
SET SESSION sort_buffer_size = 268435456;  -- 256MB

-- 读缓冲区大小
SET SESSION read_buffer_size = 2097152;    -- 2MB

-- 临时表大小
SET SESSION tmp_table_size = 134217728;    -- 128MB
```

**I/O优化参数**：
```sql
-- 控制并发度
SET GLOBAL innodb_ddl_threads = 4;

-- 日志刷盘策略
SET GLOBAL innodb_flush_log_at_trx_commit = 2;

-- 缓冲池配置
SET GLOBAL innodb_buffer_pool_size = '80%';
```

### 5.3 监控与调优实践


**性能监控指标**：
```sql
-- DDL执行状态
SELECT 
  THREAD_ID,
  EVENT_NAME,
  SQL_TEXT,
  CURRENT_SCHEMA,
  MESSAGE_TEXT
FROM performance_schema.events_statements_current
WHERE SQL_TEXT LIKE '%ALTER%';

-- 资源使用情况
SELECT 
  EVENT_NAME,
  COUNT_STAR,
  SUM_TIMER_WAIT/1000000000 as 'Duration(s)',
  AVG_TIMER_WAIT/1000000000 as 'Avg_Duration(s)'
FROM performance_schema.events_waits_summary_global_by_event_name
WHERE EVENT_NAME LIKE '%ddl%'
ORDER BY SUM_TIMER_WAIT DESC;
```

**调优建议**：
```
🔸 合理选择执行时机
- 避开业务高峰期
- 选择从库先执行（主从架构）

🔸 优化表结构设计
- 使用合适的行格式
- 预留足够的页面空间

🔸 监控系统资源
- CPU使用率
- 磁盘I/O负载
- 内存占用情况

🔸 分阶段执行
- 大表分批处理
- 复杂变更拆分为多个步骤
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 INPLACE本质：在原表上直接修改结构，避免完整重建
🔸 工作原理：通过页面重组、行格式调整、索引构建实现
🔸 并发支持：利用变更日志记录DML，支持在线执行
🔸 三阶段流程：准备→执行→提交，确保原子性和一致性
🔸 异常恢复：完整的回滚机制和故障恢复能力
```

### 6.2 关键理解要点


**🔹 为什么INPLACE比COPY快**：
```
根本原因：
- 避免全表数据复制
- 减少磁盘I/O操作
- 支持并行处理
- 最小化锁定时间

性能提升：
- 小表：提升3-5倍
- 大表：提升10-50倍
- 超大表：提升数百倍
```

**🔹 并发DML如何保证一致性**：
```
技术手段：
- 变更日志记录所有DML
- 最终一致性应用
- 行级锁协调
- 元数据锁保护

一致性保证：
- 事务性操作
- 原子提交
- 回滚能力
```

**🔹 何时选择INPLACE算法**：
```
优先选择场景：
✅ 添加/删除索引
✅ 添加列（非主键）
✅ 修改列属性（兼容性变更）
✅ 大表操作且要求在线

谨慎使用场景：
⚠️ 系统资源紧张
⚠️ 磁盘空间不足
⚠️ 高并发写入场景
```

### 6.3 实际应用指导


**💡 最佳实践**：
- **事前规划**：评估操作类型，选择合适的算法
- **资源准备**：确保足够的临时空间和内存
- **时机选择**：避开业务高峰期执行
- **监控跟踪**：实时监控执行进度和系统状态
- **备份保险**：执行前做好完整备份

**⚠️ 注意事项**：
- INPLACE不等于零影响，仍需谨慎规划
- 超大表操作可能持续数小时，需要耐心等待
- 变更日志可能占用大量空间，注意磁盘容量
- 某些操作仍然需要表锁，影响并发性能

**核心记忆**：
- INPLACE算法通过原地修改避免重建表的开销
- 支持在线DDL，但不等于零影响
- 变更日志是并发DML支持的关键技术
- 合理的参数配置和监控是成功的保障