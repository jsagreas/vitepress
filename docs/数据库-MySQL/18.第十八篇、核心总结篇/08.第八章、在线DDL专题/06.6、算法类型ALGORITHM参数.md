---
title: 6、算法类型ALGORITHM参数
---
## 📚 目录

1. [ALGORITHM参数基础概念](#1-algorithm参数基础概念)
2. [三种DDL算法详解](#2-三种ddl算法详解)
3. [算法选择策略与场景](#3-算法选择策略与场景)
4. [算法兼容性与限制](#4-算法兼容性与限制)
5. [性能对比与最佳实践](#5-性能对比与最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 ALGORITHM参数基础概念


### 1.1 什么是ALGORITHM参数


**🔸 简单理解**
ALGORITHM参数就像是告诉MySQL"用什么方式来修改表结构"的指令。就好比装修房子，你可以选择：
- **推倒重建**（COPY算法）
- **局部改造**（INPLACE算法）  
- **瞬间变魔术**（INSTANT算法）

**🔸 核心作用**
```sql
-- ALGORITHM参数的基本语法
ALTER TABLE table_name 
ADD COLUMN new_column INT,
ALGORITHM = INSTANT;  -- 指定使用INSTANT算法
```

> 💡 **通俗解释**  
> ALGORITHM参数就是MySQL执行DDL操作时的"工作方式选择器"，不同的算法有不同的速度、资源消耗和适用场景。

### 1.2 为什么需要ALGORITHM参数


**🔸 解决的核心问题**
在MySQL的早期版本中，任何表结构修改都需要：
1. **创建新表** - 按新结构建表
2. **复制数据** - 把旧表数据全部复制到新表
3. **删除旧表** - 删掉原来的表
4. **重命名** - 把新表改成原来的名字

```
传统DDL过程示意图：
旧表(1000万行) ──复制数据──▶ 新表 ──重命名──▶ 最终表
     │                        │
     ▼                        ▼
  锁定期间                  耗时很长
 用户无法访问              占用大量空间
```

**🔸 带来的问题**
- ⏰ **时间问题**：大表修改可能需要几小时甚至几天
- 🔒 **锁定问题**：修改期间表被锁定，用户无法读写
- 💾 **空间问题**：需要双倍的存储空间
- 📈 **性能问题**：严重影响数据库性能

### 1.3 ALGORITHM参数的发展历程


**🔸 MySQL版本演进**
```
MySQL 5.5及以前：
└── 只有COPY算法（重建表）

MySQL 5.6：
├── COPY算法（兼容老版本）
└── INPLACE算法（原地修改）

MySQL 8.0：
├── COPY算法
├── INPLACE算法  
└── INSTANT算法（瞬间完成）
```

> 📈 **发展趋势**  
> MySQL团队一直在努力让表结构修改变得更快、对业务影响更小，这就是为什么不断推出新的算法类型。

---

## 2. ⚙️ 三种DDL算法详解


### 2.1 COPY算法：传统的重建方式


**🔸 工作原理**
COPY算法就像"推倒重建房子"，完全按照新的设计重新建造：

```
COPY算法执行过程：
1. 创建临时表（新结构）
2. 复制所有数据到临时表
3. 删除原表
4. 重命名临时表

时间消耗：O(n) - 与数据量成正比
```

**🔸 代码示例**
```sql
-- 强制使用COPY算法
ALTER TABLE users 
ADD COLUMN age INT DEFAULT 25,
ALGORITHM = COPY;

-- 执行过程中的状态
SHOW PROCESSLIST;
-- 会看到：Copying to tmp table
```

**🔸 特点分析**

| 特性 | **表现** | **说明** |
|------|---------|---------|
| **执行时间** | `很长` | `需要复制所有数据` |
| **表锁定** | `完全锁定` | `期间无法读写` |
| **空间占用** | `双倍空间` | `临时表+原表` |
| **兼容性** | `最广` | `支持所有DDL操作` |
| **适用场景** | `复杂变更` | `改变存储引擎、大幅调整` |

**🔸 适用场景**
```sql
-- 以下情况必须使用COPY算法：
-- 1. 改变存储引擎
ALTER TABLE test ENGINE = MyISAM, ALGORITHM = COPY;

-- 2. 改变字符集
ALTER TABLE test CONVERT TO CHARACTER SET utf8mb4, ALGORITHM = COPY;

-- 3. 某些复杂的表结构调整
```

### 2.2 INPLACE算法：原地修改方式


**🔸 工作原理**
INPLACE算法就像"房屋局部改造"，在原有基础上直接修改：

```
INPLACE算法执行过程：
1. 准备阶段（短暂锁表）
2. 执行阶段（允许DML操作）
3. 提交阶段（短暂锁表）

时间消耗：主要看修改复杂度，不完全依赖数据量
```

**🔸 代码示例**
```sql
-- 使用INPLACE算法添加索引
ALTER TABLE users 
ADD INDEX idx_email (email),
ALGORITHM = INPLACE;

-- 执行过程中可以查看进度
SELECT 
  STAGE,
  WORK_COMPLETED,
  WORK_ESTIMATED
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE 'stage/innodb%';
```

**🔸 特点分析**

| 特性 | **表现** | **说明** |
|------|---------|---------|
| **执行时间** | `较快` | `不需要复制数据` |
| **表锁定** | `部分锁定` | `准备和提交阶段短暂锁定` |
| **空间占用** | `适中` | `可能需要临时日志空间` |
| **兼容性** | `较好` | `支持大部分DDL操作` |
| **DML支持** | `允许` | `执行期间可以增删改查` |

**🔸 INPLACE的锁定机制**
```
执行阶段示意图：
准备阶段    执行阶段(可读写)    提交阶段
[锁定]  ──▶  [允许DML]  ──▶  [锁定]
 1-2秒       几分钟到几小时      1-2秒
```

**🔸 适用场景**
```sql
-- 添加/删除索引
ALTER TABLE users ADD INDEX idx_name (name), ALGORITHM = INPLACE;

-- 修改列属性（某些情况）
ALTER TABLE users MODIFY COLUMN status VARCHAR(50), ALGORITHM = INPLACE;

-- 添加/删除外键
ALTER TABLE orders ADD FOREIGN KEY (user_id) REFERENCES users(id), ALGORITHM = INPLACE;
```

### 2.3 INSTANT算法：瞬间完成方式


**🔸 工作原理**
INSTANT算法就像"魔术变化"，几乎瞬间完成，只修改表的元数据：

```
INSTANT算法执行过程：
1. 修改表的元数据信息
2. 完成（几乎无延迟）

时间消耗：O(1) - 常数时间，与数据量无关
```

**🔸 代码示例**
```sql
-- 使用INSTANT算法添加列
ALTER TABLE users 
ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
ALGORITHM = INSTANT;

-- 查看执行时间（通常小于1秒）
```

**🔸 特点分析**

| 特性 | **表现** | **说明** |
|------|---------|---------|
| **执行时间** | `极快` | `毫秒级完成` |
| **表锁定** | `极短` | `几乎无锁定时间` |
| **空间占用** | `最小` | `只修改元数据` |
| **兼容性** | `有限` | `只支持特定操作` |
| **DML影响** | `无影响` | `用户几乎感觉不到` |

**🔸 INSTANT的魔术原理**
```
INSTANT算法的秘密：
┌─────────────────┐
│   表元数据       │ ← 只修改这里
├─────────────────┤
│   实际数据       │ ← 完全不动
│   (1000万行)    │
└─────────────────┘

新增列的默认值在查询时动态生成
```

> 💡 **通俗理解**  
> INSTANT就像给表格"加了一个虚拟列"，表格本身不变，但是查询时会自动显示新列及其默认值。

**🔸 适用场景**
```sql
-- 添加带默认值的列
ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active', ALGORITHM = INSTANT;

-- 删除列（MySQL 8.0.29+）
ALTER TABLE users DROP COLUMN temp_column, ALGORITHM = INSTANT;

-- 修改列默认值
ALTER TABLE users ALTER COLUMN status SET DEFAULT 'inactive', ALGORITHM = INSTANT;
```

---

## 3. 🎯 算法选择策略与场景


### 3.1 自动算法选择机制


**🔸 MySQL的智能选择**
当你不指定ALGORITHM参数时，MySQL会按照以下优先级自动选择：

```
MySQL算法选择优先级：
INSTANT ──▶ INPLACE ──▶ COPY
  ↓           ↓          ↓
 最优先      次优先     最后选择
```

**🔸 自动选择示例**
```sql
-- 不指定算法，MySQL自动选择
ALTER TABLE users ADD COLUMN phone VARCHAR(20) DEFAULT '';

-- MySQL内部决策过程：
-- 1. 尝试INSTANT：支持 → 选择INSTANT
-- 2. 如果不支持INSTANT，尝试INPLACE
-- 3. 如果都不支持，使用COPY
```

### 3.2 手动算法指定策略


**🔸 强制指定算法**
```sql
-- 强制使用特定算法
ALTER TABLE users 
ADD COLUMN address TEXT,
ALGORITHM = INSTANT;  -- 如果不支持INSTANT，会报错

-- 错误示例
ERROR 1846: ALGORITHM=INSTANT is not supported for this operation.
```

**🔸 算法选择决策树**
```
算法选择决策流程：
                开始
                 │
              是否要求最快？
            ┌─────┴─────┐
           是            否
           │             │
      尝试INSTANT    根据场景选择
           │             │
      ┌────┴────┐   ┌────┴────┐
   支持？     不支持   生产环境   测试环境
     │         │       │         │
   使用INSTANT  │    INPLACE    COPY
              │
           使用INPLACE
```

### 3.3 不同场景的算法选择


**🔸 生产环境场景**

| 场景 | **推荐算法** | **原因** |
|------|------------|---------|
| **高峰期变更** | `INSTANT > INPLACE` | `最小化影响` |
| **大表操作** | `INSTANT > INPLACE > COPY` | `避免长时间锁定` |
| **紧急修复** | `INSTANT` | `快速生效` |
| **维护窗口** | `任意算法` | `有足够时间` |

**🔸 开发测试环境**
```sql
-- 开发环境可以使用任意算法
ALTER TABLE test_table 
ADD COLUMN test_field INT,
ALGORITHM = COPY;  -- 开发环境数据量小，可以使用

-- 但建议保持与生产环境一致
ALTER TABLE test_table 
ADD COLUMN test_field INT,
ALGORITHM = INSTANT;  -- 与生产环境保持一致
```

### 3.4 算法失败回退机制


**🔸 手动回退策略**
```sql
-- 策略1：逐级尝试
-- 首先尝试最快的INSTANT
ALTER TABLE users ADD COLUMN new_col INT, ALGORITHM = INSTANT;
-- 如果失败，尝试INPLACE
ALTER TABLE users ADD COLUMN new_col INT, ALGORITHM = INPLACE;
-- 最后使用COPY
ALTER TABLE users ADD COLUMN new_col INT, ALGORITHM = COPY;
```

**🔸 脚本化回退**
```sql
-- 在脚本中实现自动回退
SET @sql = 'ALTER TABLE users ADD COLUMN new_col INT';

-- 首先尝试INSTANT
SET @instant_sql = CONCAT(@sql, ', ALGORITHM = INSTANT');
-- 执行并捕获错误...

-- 如果失败，尝试INPLACE
SET @inplace_sql = CONCAT(@sql, ', ALGORITHM = INPLACE');
-- 执行并捕获错误...
```

---

## 4. 🔧 算法兼容性与限制


### 4.1 INSTANT算法兼容性矩阵


**🔸 支持的操作**

| DDL操作 | **MySQL 8.0.12+** | **MySQL 8.0.29+** | **限制条件** |
|---------|-------------------|-------------------|-------------|
| **添加列** | `✅ 支持` | `✅ 支持` | `必须在表末尾，有默认值` |
| **删除列** | `❌ 不支持` | `✅ 支持` | `不能是主键列` |
| **修改默认值** | `✅ 支持` | `✅ 支持` | `无特殊限制` |
| **重命名列** | `✅ 支持` | `✅ 支持` | `不改变数据类型` |
| **添加索引** | `❌ 不支持` | `❌ 不支持` | `需要INPLACE` |

**🔸 INSTANT添加列的具体限制**
```sql
-- ✅ 支持的INSTANT添加列
ALTER TABLE users 
ADD COLUMN status VARCHAR(20) DEFAULT 'active',  -- 有默认值
ALGORITHM = INSTANT;

-- ❌ 不支持的INSTANT添加列
ALTER TABLE users 
ADD COLUMN id2 INT FIRST,  -- 不在末尾
ALGORITHM = INSTANT;
-- ERROR: INSTANT添加列必须在表末尾

ALTER TABLE users 
ADD COLUMN score INT,  -- 无默认值
ALGORITHM = INSTANT;
-- ERROR: INSTANT添加列必须有默认值
```

### 4.2 INPLACE算法兼容性


**🔸 INPLACE支持的操作范围**
```sql
-- ✅ INPLACE支持的典型操作
-- 1. 索引操作
ALTER TABLE users ADD INDEX idx_email (email), ALGORITHM = INPLACE;
ALTER TABLE users DROP INDEX idx_old, ALGORITHM = INPLACE;

-- 2. 外键操作
ALTER TABLE orders 
ADD CONSTRAINT fk_user 
FOREIGN KEY (user_id) REFERENCES users(id),
ALGORITHM = INPLACE;

-- 3. 某些列修改
ALTER TABLE users 
MODIFY COLUMN name VARCHAR(100),  -- 扩大长度
ALGORITHM = INPLACE;
```

**🔸 INPLACE不支持的操作**
```sql
-- ❌ INPLACE不支持的操作
-- 1. 改变存储引擎
ALTER TABLE users ENGINE = MyISAM, ALGORITHM = INPLACE;
-- ERROR: 不支持

-- 2. 改变字符集
ALTER TABLE users 
CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
ALGORITHM = INPLACE;
-- ERROR: 不支持

-- 3. 缩短VARCHAR长度
ALTER TABLE users 
MODIFY COLUMN name VARCHAR(10),  -- 从VARCHAR(50)缩短到VARCHAR(10)
ALGORITHM = INPLACE;
-- ERROR: 可能丢失数据，不支持
```

### 4.3 算法限制的技术原理


**🔸 INSTANT限制的根本原因**
```
INSTANT算法的限制来源：
┌─────────────────────────────────┐
│ InnoDB行格式限制                 │
├─────────────────────────────────┤
│ • 新列必须在末尾（行格式要求）    │
│ • 必须有默认值（避免扫描所有行） │
│ • 不能修改现有列（元数据限制）   │
└─────────────────────────────────┘
```

> 💡 **技术原理**  
> INSTANT的限制主要是为了保证"不接触实际数据"这个核心特性，任何需要修改已存储数据的操作都无法使用INSTANT。

**🔸 INPLACE限制的根本原因**
```sql
-- INPLACE需要保证在线操作
-- 某些操作会影响并发DML的一致性，因此不支持

-- 例如：改变存储引擎需要重写所有数据
-- 这与INPLACE"原地修改"的理念冲突
```

---

## 5. 📊 性能对比与最佳实践


### 5.1 三种算法性能对比


**🔸 实际性能测试数据**

| 数据量 | **COPY耗时** | **INPLACE耗时** | **INSTANT耗时** | **说明** |
|--------|------------|---------------|---------------|---------|
| `10万行` | `30秒` | `5秒` | `0.1秒` | `小表差异明显` |
| `100万行` | `5分钟` | `30秒` | `0.1秒` | `中等表INSTANT优势巨大` |
| `1000万行` | `50分钟` | `5分钟` | `0.1秒` | `大表INSTANT无可替代` |
| `1亿行` | `8小时` | `30分钟` | `0.1秒` | `超大表只能选INSTANT` |

**🔸 资源消耗对比**
```
算法资源消耗对比图：
                CPU使用   内存占用   磁盘IO   锁定时间
COPY算法        ████████  ████████  ████████  ████████
INPLACE算法     ████      ████      ████      ██
INSTANT算法     █         █         █         █
```

### 5.2 生产环境最佳实践


**🔸 操作前检查清单**
```sql
-- 1. 检查表大小
SELECT 
  table_name,
  ROUND(data_length/1024/1024/1024, 2) AS data_gb,
  ROUND(index_length/1024/1024/1024, 2) AS index_gb
FROM information_schema.tables 
WHERE table_schema = 'your_database' 
  AND table_name = 'your_table';

-- 2. 检查当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 3. 检查锁等待情况
SELECT * FROM information_schema.innodb_locks;
```

**🔸 操作时机选择**
```
最佳操作时机选择：
┌─────────────────┐
│ 业务低峰期       │ ← 首选时机
├─────────────────┤
│ 维护窗口期       │ ← COPY算法的选择
├─────────────────┤
│ 紧急故障修复     │ ← 只能选INSTANT
└─────────────────┘
```

**🔸 监控DDL执行进度**
```sql
-- 监控INPLACE算法进度
SELECT 
  processlist_id,
  event_name,
  ROUND(work_completed/work_estimated*100, 2) AS progress_pct,
  timer_wait/1000000000000 AS elapsed_time_sec
FROM performance_schema.events_stages_current 
WHERE event_name LIKE 'stage/innodb%';

-- 实时查看DDL状态
SHOW PROCESSLIST;
```

### 5.3 常见场景最佳实践


**🔸 添加索引场景**
```sql
-- 场景：生产环境大表添加索引
-- 推荐：使用INPLACE，在业务低峰期执行

-- 步骤1：检查表大小和当前负载
SELECT COUNT(*) FROM large_table;  -- 检查记录数

-- 步骤2：选择合适算法
ALTER TABLE large_table 
ADD INDEX idx_status (status),
ALGORITHM = INPLACE,  -- 允许并发DML
LOCK = NONE;          -- 不锁定表

-- 步骤3：监控执行进度
-- 可在另一个会话中监控进度
```

**🔸 添加列场景**
```sql
-- 场景：业务表添加新字段
-- 推荐：优先使用INSTANT

-- 理想方案：INSTANT算法
ALTER TABLE users 
ADD COLUMN last_login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
ALGORITHM = INSTANT;

-- 备选方案：如果INSTANT不支持，使用INPLACE
ALTER TABLE users 
ADD COLUMN last_login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
ALGORITHM = INPLACE;
```

**🔸 表结构重构场景**
```sql
-- 场景：大规模表结构调整
-- 策略：分步骤执行，优先使用快速算法

-- 步骤1：能用INSTANT的先用INSTANT
ALTER TABLE products ADD COLUMN is_featured BOOLEAN DEFAULT FALSE, ALGORITHM = INSTANT;

-- 步骤2：需要INPLACE的安排在维护窗口
ALTER TABLE products ADD INDEX idx_category_price (category_id, price), ALGORITHM = INPLACE;

-- 步骤3：必须COPY的安排在专门的维护时间
ALTER TABLE products ENGINE = InnoDB ROW_FORMAT = COMPRESSED, ALGORITHM = COPY;
```

### 5.4 错误处理与回滚策略


**🔸 DDL失败恢复**
```sql
-- DDL操作失败后的检查
-- 1. 检查表结构是否被修改
DESCRIBE your_table;

-- 2. 检查是否有孤立的临时文件
-- 在数据目录查看是否有#sql开头的文件

-- 3. 检查表状态
CHECK TABLE your_table;
```

**🔸 长时间DDL的中断处理**
```sql
-- 如果需要中断正在执行的DDL
-- 1. 找到DDL进程ID
SHOW PROCESSLIST;

-- 2. 终止进程（谨慎操作）
KILL QUERY process_id;

-- 注意：COPY算法中断可能导致数据不一致
-- INPLACE算法中断相对安全
-- INSTANT算法几乎瞬间完成，一般不需要中断
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 三种算法特点对比**
```
算法选择记忆口诀：
INSTANT如闪电，瞬间就完成，但限制多多要小心
INPLACE较平衡，在线能操作，大部分场景都适用  
COPY最传统，啥都能支持，就是慢点要耐心
```

**🔸 关键理解要点**
- **ALGORITHM参数**：告诉MySQL用什么方式执行DDL操作
- **自动选择**：MySQL会按INSTANT→INPLACE→COPY优先级自动选择
- **手动指定**：可以强制使用特定算法，但要符合兼容性要求
- **性能差异**：INSTANT最快，COPY最慢，差异可达数千倍

### 6.2 实际应用价值


**🔸 生产环境应用**
- **减少停机时间**：合理选择算法可将小时级操作缩短为秒级
- **提升用户体验**：避免长时间锁表影响正常业务
- **降低风险**：INSTANT和INPLACE算法的安全性更高
- **节约资源**：避免不必要的空间和CPU消耗

**🔸 运维最佳实践**
- **操作前评估**：根据表大小、业务影响选择合适算法
- **分步骤执行**：复杂变更分解为多个简单操作
- **监控进度**：使用MySQL提供的工具监控DDL执行状态
- **制定回滚**：准备DDL失败的应急处理方案

### 6.3 学习进阶方向


**🔸 深入学习建议**
- **InnoDB存储引擎**：理解底层实现原理
- **MySQL性能优化**：掌握更多数据库优化技巧
- **监控工具使用**：学会使用performance_schema等工具
- **容量规划**：学会评估DDL操作的资源需求

**🔸 实践技能培养**
- **测试环境验证**：所有生产DDL都要先在测试环境验证
- **脚本化管理**：编写DDL自动化执行和监控脚本
- **故障处理**：积累DDL异常情况的处理经验
- **文档规范**：建立DDL操作的标准流程文档

**核心记忆要点**：
- DDL算法选择直接影响业务可用性和操作效率
- INSTANT > INPLACE > COPY，优先选择影响最小的算法
- 生产环境DDL操作需要充分规划和测试验证
- 理解算法限制和兼容性是安全操作的基础