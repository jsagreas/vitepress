---
title: 38、锁等待分析方法
---
## 📚 目录

1. [锁等待分析基础](#1-锁等待分析基础)
2. [等待分析工具详解](#2-等待分析工具详解)
3. [等待链分析技术](#3-等待链分析技术)
4. [阻塞关系图构建](#4-阻塞关系图构建)
5. [等待时间统计与分析](#5-等待时间统计与分析)
6. [热点锁识别方法](#6-热点锁识别方法)
7. [分析报告生成](#7-分析报告生成)
8. [性能瓶颈定位与优化](#8-性能瓶颈定位与优化)
9. [自动化监控与预警](#9-自动化监控与预警)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 锁等待分析基础


### 1.1 什么是锁等待


**定义理解**：
锁等待就是某个事务想要获取一个资源的锁，但这个资源已经被另一个事务锁定，所以只能排队等待。

```
生活中的类比：
银行柜台办业务 → 数据库事务
正在办理的客户 → 持有锁的事务
排队等待的客户 → 等待锁的事务
柜台窗口 → 被锁定的资源
```

**等待分析的本质**：
找出谁在等什么锁、等了多久、为什么等这么久，然后想办法解决排队问题。

### 1.2 等待分析目标


**🎯 核心目标**：
```
📊 发现问题：哪里发生了锁等待？
🔍 定位原因：为什么会发生等待？
⏱️ 量化影响：等待造成了多大性能损失？
🛠️ 制定方案：如何解决和预防？
```

**分析维度**：
```
时间维度：什么时候发生等待？持续多久？
空间维度：哪些表、哪些记录发生等待？
事务维度：哪些事务参与了等待？
影响维度：对系统性能造成了什么影响？
```

### 1.3 等待类型分类


**按锁的层级分类**：
```
┌─────────────┐
│  表级等待   │ ← 整个表被锁，其他事务等待
├─────────────┤
│  页级等待   │ ← 数据页被锁，其他事务等待
├─────────────┤
│  行级等待   │ ← 特定行被锁，其他事务等待
└─────────────┘
```

**按等待原因分类**：
- **排他锁等待**：事务A持有排他锁，事务B等待获取任何锁
- **共享锁等待**：事务A持有排他锁，事务B等待获取共享锁
- **死锁等待**：多个事务相互等待，形成死循环

---

## 2. 🔧 等待分析工具详解


### 2.1 performance_schema工具


**什么是performance_schema**：
这是MySQL内置的性能监控工具，就像医院的检查设备，可以查看数据库的各种"健康指标"。

**核心监控表**：
```sql
-- 查看当前锁等待情况
SELECT 
    waiting.thread_id AS waiting_thread,
    waiting.event_name AS waiting_event,
    waiting_query.sql_text AS waiting_query,
    blocking.thread_id AS blocking_thread,
    blocking_query.sql_text AS blocking_query,
    waiting.timer_wait/1000000000 AS wait_seconds
FROM performance_schema.events_waits_current waiting
JOIN performance_schema.threads waiting_threads 
    ON waiting.thread_id = waiting_threads.thread_id
LEFT JOIN performance_schema.events_statements_current waiting_query
    ON waiting.thread_id = waiting_query.thread_id
LEFT JOIN performance_schema.data_lock_waits dlw
    ON waiting.thread_id = dlw.requesting_thread_id
LEFT JOIN performance_schema.threads blocking_threads
    ON dlw.blocking_thread_id = blocking_threads.thread_id
LEFT JOIN performance_schema.events_statements_current blocking_query
    ON blocking_threads.thread_id = blocking_query.thread_id
WHERE waiting.event_name LIKE '%lock%'
AND waiting.state = 'ACTIVE';
```

> 💡 **理解要点**  
> 这个查询就像查看排队情况：谁在排队、排什么队、前面是谁、等了多久。

### 2.2 INFORMATION_SCHEMA工具


**INNODB锁信息表**：
```sql
-- 查看当前持有的锁
SELECT 
    lock_id,
    lock_trx_id,
    lock_mode,
    lock_type,
    lock_table,
    lock_index,
    lock_data
FROM INFORMATION_SCHEMA.INNODB_LOCKS;

-- 查看锁等待关系
SELECT 
    r.trx_id AS requesting_trx,
    r.trx_mysql_thread_id AS requesting_thread,
    b.trx_id AS blocking_trx,
    b.trx_mysql_thread_id AS blocking_thread,
    w.requesting_lock_id,
    w.blocking_lock_id
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
JOIN INFORMATION_SCHEMA.INNODB_TRX r ON w.requesting_trx_id = r.trx_id
JOIN INFORMATION_SCHEMA.INNODB_TRX b ON w.blocking_trx_id = b.trx_id;
```

### 2.3 sys schema工具


**sys schema简介**：
这是MySQL提供的一套简化查询工具，把复杂的performance_schema查询包装成简单易用的视图。

```sql
-- 查看当前锁等待（简化版）
SELECT * FROM sys.innodb_lock_waits;

-- 查看锁等待摘要
SELECT * FROM sys.x$innodb_lock_waits;

-- 查看持锁事务信息
SELECT 
    trx_id,
    trx_state,
    trx_started,
    trx_requested_lock_id,
    trx_wait_started,
    trx_weight,
    trx_mysql_thread_id,
    trx_query
FROM sys.innodb_trx_summary;
```

### 2.4 分析工具选择指南


| 工具类型 | **使用场景** | **优势** | **劣势** |
|---------|------------|----------|----------|
| 🔍 **performance_schema** | `详细分析，历史追踪` | `信息全面，实时监控` | `查询复杂，性能开销大` |
| 📊 **INFORMATION_SCHEMA** | `当前状态查看` | `查询简单，开销小` | `信息有限，无历史数据` |
| 🛠️ **sys schema** | `快速诊断，日常监控` | `使用简单，预制视图` | `定制性差，功能固定` |

---

## 3. 🔗 等待链分析技术


### 3.1 什么是等待链


**概念理解**：
等待链就像排队买票，A等B，B等C，C等D，形成一个等待的链条。在数据库中，事务之间也会形成这样的等待关系。

```
等待链示例：
事务1 → 等待 → 事务2 → 等待 → 事务3 → 等待 → 事务4（持有锁）
  ↑                                              ↓
排队的人                                    正在办事的人
```

### 3.2 等待链识别方法


**递归查询构建等待链**：
```sql
-- 构建等待链的递归查询
WITH RECURSIVE wait_chain AS (
    -- 找到等待链的起点（被等待但不等待别人的事务）
    SELECT 
        blocking_trx_id AS trx_id,
        blocking_trx_id AS root_blocker,
        requesting_trx_id AS next_waiter,
        0 AS level,
        CAST(blocking_trx_id AS CHAR(200)) AS chain_path
    FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS
    WHERE blocking_trx_id NOT IN (
        SELECT requesting_trx_id 
        FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS
    )
    
    UNION ALL
    
    -- 递归构建等待链
    SELECT 
        w.requesting_trx_id,
        wc.root_blocker,
        w.requesting_trx_id,
        wc.level + 1,
        CONCAT(wc.chain_path, ' -> ', w.requesting_trx_id)
    FROM wait_chain wc
    JOIN INFORMATION_SCHEMA.INNODB_LOCK_WAITS w 
        ON wc.next_waiter = w.blocking_trx_id
    WHERE wc.level < 10  -- 防止无限递归
)
SELECT 
    root_blocker AS '链头事务',
    trx_id AS '当前事务',
    level AS '等待层级',
    chain_path AS '等待路径'
FROM wait_chain 
ORDER BY root_blocker, level;
```

### 3.3 等待链分析指标


**关键指标**：
```
🔸 链长度：等待链包含多少个事务
🔸 链深度：最深的等待层级是多少
🔸 链头事务：谁是罪魁祸首（最初的阻塞者）
🔸 等待时间：整个链条等了多久
🔸 影响范围：多少个事务被阻塞
```

**分析示例**：
```sql
-- 分析等待链统计
SELECT 
    root_blocker,
    COUNT(*) AS chain_length,
    MAX(level) AS max_depth,
    MIN(wait_started) AS chain_start_time,
    MAX(TIMESTAMPDIFF(SECOND, wait_started, NOW())) AS max_wait_seconds
FROM (
    -- 这里放入上面的递归查询
) chain_analysis
GROUP BY root_blocker
ORDER BY chain_length DESC, max_wait_seconds DESC;
```

---

## 4. 📊 阻塞关系图构建


### 4.1 阻塞关系理解


**什么是阻塞关系**：
就像交通路口，红绿灯（锁）控制车辆（事务）通行。某个方向的车辆阻塞了，其他方向的车也要等待。

```
阻塞关系图示：
     事务A(持锁)
        ↓ 阻塞
     事务B(等待)
        ↓ 阻塞
     事务C(等待)
        ↓ 阻塞  
     事务D(等待)
```

### 4.2 关系图数据收集


**收集阻塞关系数据**：
```sql
CREATE TEMPORARY TABLE blocking_relationships AS
SELECT 
    b.trx_id AS blocker_trx,
    b.trx_mysql_thread_id AS blocker_thread,
    b.trx_query AS blocker_query,
    TIMESTAMPDIFF(SECOND, b.trx_started, NOW()) AS blocker_duration,
    
    r.trx_id AS waiter_trx,
    r.trx_mysql_thread_id AS waiter_thread,
    r.trx_query AS waiter_query,
    TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW()) AS wait_duration,
    
    l.lock_table,
    l.lock_index,
    l.lock_type,
    l.lock_mode
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
JOIN INFORMATION_SCHEMA.INNODB_TRX b ON w.blocking_trx_id = b.trx_id
JOIN INFORMATION_SCHEMA.INNODB_TRX r ON w.requesting_trx_id = r.trx_id
JOIN INFORMATION_SCHEMA.INNODB_LOCKS l ON w.blocking_lock_id = l.lock_id;
```

### 4.3 关系图可视化


**生成图形化报告**：
```sql
-- 生成阻塞关系摘要
SELECT 
    CONCAT('TRX-', blocker_trx) AS '阻塞者',
    CONCAT('TRX-', waiter_trx) AS '等待者',
    lock_table AS '争用资源',
    lock_mode AS '锁模式',
    wait_duration AS '等待秒数',
    CASE 
        WHEN wait_duration < 5 THEN '轻微'
        WHEN wait_duration < 30 THEN '中等'
        WHEN wait_duration < 120 THEN '严重'
        ELSE '极严重'
    END AS '严重程度'
FROM blocking_relationships
ORDER BY wait_duration DESC;
```

---

## 5. ⏱️ 等待时间统计与分析


### 5.1 等待时间的重要性


**为什么关注等待时间**：
等待时间就像交通堵塞的时长，直接影响用户体验和系统性能。时间越长，问题越严重。

### 5.2 时间统计维度


**多维度时间统计**：
```sql
-- 按时间段统计等待情况
SELECT 
    DATE_FORMAT(FROM_UNIXTIME(UNIX_TIMESTAMP() - 3600), '%H:00') AS hour_start,
    COUNT(*) AS wait_events,
    AVG(timer_wait/1000000000) AS avg_wait_seconds,
    MAX(timer_wait/1000000000) AS max_wait_seconds,
    SUM(timer_wait/1000000000) AS total_wait_seconds
FROM performance_schema.events_waits_history
WHERE event_name LIKE '%lock%'
AND timer_start > (UNIX_TIMESTAMP() - 3600) * 1000000000
GROUP BY hour_start
ORDER BY hour_start;

-- 按锁类型统计等待时间
SELECT 
    SUBSTRING_INDEX(event_name, '/', -1) AS lock_type,
    COUNT(*) AS wait_count,
    AVG(timer_wait/1000000000) AS avg_wait_seconds,
    PERCENTILE_CONT(0.5) WITHIN GROUP (
        ORDER BY timer_wait/1000000000
    ) AS median_wait_seconds,
    PERCENTILE_CONT(0.95) WITHIN GROUP (
        ORDER BY timer_wait/1000000000  
    ) AS p95_wait_seconds
FROM performance_schema.events_waits_history
WHERE event_name LIKE '%lock%'
AND timer_end IS NOT NULL
GROUP BY lock_type
ORDER BY avg_wait_seconds DESC;
```

### 5.3 等待时间阈值设定


**等待时间严重程度分级**：
```sql
-- 定义等待时间阈值
SET @light_threshold = 1;      -- 1秒以下：轻微
SET @moderate_threshold = 5;   -- 1-5秒：中等  
SET @severe_threshold = 30;    -- 5-30秒：严重
SET @critical_threshold = 120; -- 30秒以上：极严重

-- 按严重程度统计
SELECT 
    CASE 
        WHEN timer_wait/1000000000 <= @light_threshold THEN '轻微(≤1s)'
        WHEN timer_wait/1000000000 <= @moderate_threshold THEN '中等(1-5s)'
        WHEN timer_wait/1000000000 <= @severe_threshold THEN '严重(5-30s)'
        WHEN timer_wait/1000000000 <= @critical_threshold THEN '极严重(30-120s)'
        ELSE '超危险(>120s)'
    END AS severity_level,
    COUNT(*) AS event_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) AS percentage
FROM performance_schema.events_waits_history
WHERE event_name LIKE '%lock%' 
AND timer_end IS NOT NULL
GROUP BY severity_level
ORDER BY 
    CASE severity_level
        WHEN '轻微(≤1s)' THEN 1
        WHEN '中等(1-5s)' THEN 2  
        WHEN '严重(5-30s)' THEN 3
        WHEN '极严重(30-120s)' THEN 4
        ELSE 5
    END;
```

---

## 6. 🔥 热点锁识别方法


### 6.1 什么是热点锁


**热点锁理解**：
就像热门景点的售票窗口，大家都要去那里买票，所以排队最长。热点锁就是被很多事务竞争的锁。

### 6.2 热点锁识别策略


**基于争用频率识别**：
```sql
-- 识别最常被争用的资源
SELECT 
    CONCAT(lock_table, '.', IFNULL(lock_index, 'PRIMARY')) AS resource,
    lock_mode,
    COUNT(*) AS contention_count,
    COUNT(DISTINCT requesting_trx_id) AS waiting_transactions,
    AVG(TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW())) AS avg_wait_seconds
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
JOIN INFORMATION_SCHEMA.INNODB_LOCKS l ON w.requesting_lock_id = l.lock_id
WHERE l.lock_table NOT LIKE '%information_schema%'
AND l.lock_table NOT LIKE '%performance_schema%'
GROUP BY resource, lock_mode
HAVING contention_count >= 3  -- 至少3次争用才算热点
ORDER BY contention_count DESC, avg_wait_seconds DESC
LIMIT 20;
```

**基于等待时间识别**：
```sql
-- 按累计等待时间识别热点
SELECT 
    lock_table AS table_name,
    lock_index AS index_name,
    lock_mode,
    COUNT(*) AS wait_events,
    SUM(TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW())) AS total_wait_seconds,
    AVG(TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW())) AS avg_wait_seconds
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
JOIN INFORMATION_SCHEMA.INNODB_LOCKS l ON w.requesting_lock_id = l.lock_id
GROUP BY table_name, index_name, lock_mode
ORDER BY total_wait_seconds DESC
LIMIT 15;
```

### 6.3 热点锁影响评估


**热点锁评估矩阵**：

| 争用频率 | **低等待时间** | **中等等待时间** | **高等待时间** |
|---------|--------------|----------------|--------------|
| **高频率** | `🟡 关注监控` | `🟠 重点优化` | `🔴 紧急处理` |
| **中频率** | `🟢 正常范围` | `🟡 关注监控` | `🟠 重点优化` |
| **低频率** | `🟢 正常范围` | `🟢 正常范围` | `🟡 关注监控` |

---

## 7. 📋 分析报告生成


### 7.1 报告结构设计


**锁等待分析报告模板**：
```sql
-- 创建分析报告存储过程
DELIMITER //
CREATE PROCEDURE GenerateLockAnalysisReport()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    
    -- 报告头部信息
    SELECT '=== MySQL锁等待分析报告 ===' AS report_title,
           NOW() AS analysis_time,
           $$hostname AS server_host;
    
    -- 1. 整体等待概况
    SELECT '1. 整体等待概况' AS section;
    
    SELECT 
        COUNT(*) AS current_waits,
        COUNT(DISTINCT requesting_trx_id) AS waiting_transactions,
        COUNT(DISTINCT blocking_trx_id) AS blocking_transactions,
        AVG(TIMESTAMPDIFF(SECOND, 
            (SELECT MIN(trx_wait_started) FROM INFORMATION_SCHEMA.INNODB_TRX 
             WHERE trx_id = requesting_trx_id), NOW())) AS avg_wait_seconds,
        MAX(TIMESTAMPDIFF(SECOND, 
            (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
             WHERE trx_id = requesting_trx_id), NOW())) AS max_wait_seconds
    FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
    
    -- 2. 热点资源TOP10
    SELECT '2. 热点争用资源 TOP10' AS section;
    
    SELECT 
        RANK() OVER (ORDER BY COUNT(*) DESC) AS rank_no,
        lock_table AS table_name,
        IFNULL(lock_index, 'PRIMARY') AS index_name,
        lock_mode,
        COUNT(*) AS contention_count,
        ROUND(AVG(TIMESTAMPDIFF(SECOND, 
            (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
             WHERE trx_id = requesting_trx_id), NOW())), 2) AS avg_wait_seconds
    FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
    JOIN INFORMATION_SCHEMA.INNODB_LOCKS l ON w.requesting_lock_id = l.lock_id
    GROUP BY lock_table, lock_index, lock_mode
    ORDER BY contention_count DESC
    LIMIT 10;
    
    -- 3. 长等待事务TOP10  
    SELECT '3. 长等待事务 TOP10' AS section;
    
    SELECT 
        RANK() OVER (ORDER BY TIMESTAMPDIFF(SECOND, trx_wait_started, NOW()) DESC) AS rank_no,
        trx_id,
        trx_mysql_thread_id AS thread_id,
        TIMESTAMPDIFF(SECOND, trx_wait_started, NOW()) AS wait_seconds,
        trx_requested_lock_id AS waiting_lock,
        LEFT(trx_query, 100) AS query_preview
    FROM INFORMATION_SCHEMA.INNODB_TRX
    WHERE trx_state = 'LOCK WAIT'
    ORDER BY wait_seconds DESC
    LIMIT 10;
    
    -- 4. 问题事务识别
    SELECT '4. 问题事务识别' AS section;
    
    SELECT 
        trx_id,
        trx_mysql_thread_id,
        trx_state,
        TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS running_seconds,
        trx_rows_locked,
        trx_rows_modified,
        LEFT(trx_query, 200) AS current_query
    FROM INFORMATION_SCHEMA.INNODB_TRX
    WHERE (TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300)  -- 运行超过5分钟
       OR (trx_rows_locked > 10000)  -- 锁定行数过多
       OR (trx_rows_modified > 1000)  -- 修改行数过多
    ORDER BY running_seconds DESC;

END //
DELIMITER ;
```

### 7.2 自动化报告生成


**定时报告脚本**：
```bash
#!/bin/bash
# 每小时生成锁等待分析报告

MYSQL_CMD="mysql -h${DB_HOST} -u${DB_USER} -p${DB_PASS}"
REPORT_DIR="/var/log/mysql/lock_analysis"
TIMESTAMP=$(date '+%Y%m%d_%H%M%S')

# 确保报告目录存在
mkdir -p ${REPORT_DIR}

# 生成报告
${MYSQL_CMD} -e "CALL GenerateLockAnalysisReport();" > ${REPORT_DIR}/lock_report_${TIMESTAMP}.txt

# 检查是否有严重等待（超过30秒）
SEVERE_WAITS=$(${MYSQL_CMD} -sN -e "
SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_TRX 
WHERE trx_state = 'LOCK WAIT' 
AND TIMESTAMPDIFF(SECOND, trx_wait_started, NOW()) > 30;")

# 如果有严重等待，发送告警
if [ ${SEVERE_WAITS} -gt 0 ]; then
    echo "发现 ${SEVERE_WAITS} 个严重锁等待！" | \
    mail -s "MySQL锁等待告警 - $(date)" admin@company.com
fi
```

---

## 8. 🛠️ 性能瓶颈定位与优化


### 8.1 瓶颈定位方法


**定位思路**：
```
第一步：找到等待最多的资源（where）
第二步：找到持锁最久的事务（who）  
第三步：分析锁争用的原因（why）
第四步：制定优化方案（how）
```

**瓶颈定位查询**：
```sql
-- 综合瓶颈分析
SELECT 
    '资源争用分析' AS analysis_type,
    CONCAT(l.lock_table, '.', IFNULL(l.lock_index, 'PRIMARY')) AS resource,
    COUNT(DISTINCT w.requesting_trx_id) AS waiting_trx_count,
    COUNT(*) AS total_waits,
    AVG(TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW())) AS avg_wait_time,
    MAX(TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW())) AS max_wait_time,
    
    -- 分析持锁事务特征
    AVG(TIMESTAMPDIFF(SECOND, b.trx_started, NOW())) AS avg_blocker_duration,
    AVG(b.trx_rows_locked) AS avg_locked_rows,
    AVG(b.trx_rows_modified) AS avg_modified_rows

FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
JOIN INFORMATION_SCHEMA.INNODB_LOCKS l ON w.requesting_lock_id = l.lock_id
JOIN INFORMATION_SCHEMA.INNODB_TRX r ON w.requesting_trx_id = r.trx_id  
JOIN INFORMATION_SCHEMA.INNODB_TRX b ON w.blocking_trx_id = b.trx_id
GROUP BY resource
HAVING waiting_trx_count >= 2  -- 至少2个事务在等待
ORDER BY total_waits DESC, avg_wait_time DESC;
```

### 8.2 优化建议生成


**自动优化建议**：
```sql
-- 基于分析结果生成优化建议
SELECT 
    resource,
    waiting_trx_count,
    avg_wait_time,
    CASE 
        WHEN avg_wait_time > 60 AND waiting_trx_count > 5 THEN 
            '建议：1.检查索引效率 2.优化事务大小 3.考虑分表'
        WHEN avg_wait_time > 30 AND waiting_trx_count > 3 THEN
            '建议：1.优化查询语句 2.缩短事务时间 3.调整并发控制'
        WHEN avg_locked_rows > 10000 THEN
            '建议：1.避免大批量操作 2.分批处理数据 3.使用分页'
        WHEN avg_blocker_duration > 300 THEN
            '建议：1.检查长事务 2.优化业务逻辑 3.设置事务超时'
        ELSE
            '建议：1.持续监控 2.优化查询性能'
    END AS optimization_advice
FROM (
    -- 这里是上面的瓶颈分析查询结果
    SELECT 
        CONCAT(l.lock_table, '.', IFNULL(l.lock_index, 'PRIMARY')) AS resource,
        COUNT(DISTINCT w.requesting_trx_id) AS waiting_trx_count,
        AVG(TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW())) AS avg_wait_time,
        AVG(TIMESTAMPDIFF(SECOND, b.trx_started, NOW())) AS avg_blocker_duration,
        AVG(b.trx_rows_locked) AS avg_locked_rows
    FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS w
    JOIN INFORMATION_SCHEMA.INNODB_LOCKS l ON w.requesting_lock_id = l.lock_id
    JOIN INFORMATION_SCHEMA.INNODB_TRX r ON w.requesting_trx_id = r.trx_id  
    JOIN INFORMATION_SCHEMA.INNODB_TRX b ON w.blocking_trx_id = b.trx_id
    GROUP BY resource
    HAVING waiting_trx_count >= 2
) analysis_result;
```

---

## 9. 🤖 自动化监控与预警


### 9.1 监控指标设计


**核心监控指标**：
```sql
-- 监控指标采集
CREATE OR REPLACE VIEW lock_monitoring_metrics AS
SELECT 
    -- 基础指标
    COUNT(*) AS current_waits,
    COUNT(DISTINCT requesting_trx_id) AS waiting_transactions,
    
    -- 时间指标  
    AVG(TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW())) AS avg_wait_seconds,
    MAX(TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW())) AS max_wait_seconds,
         
    -- 严重程度统计
    SUM(CASE WHEN TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW()) > 30 THEN 1 ELSE 0 END) AS severe_waits,
    SUM(CASE WHEN TIMESTAMPDIFF(SECOND, 
        (SELECT trx_wait_started FROM INFORMATION_SCHEMA.INNODB_TRX 
         WHERE trx_id = requesting_trx_id), NOW()) > 120 THEN 1 ELSE 0 END) AS critical_waits,
        
    NOW() AS snapshot_time
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```

### 9.2 预警规则设定


**预警阈值配置**：
```sql
-- 预警规则表
CREATE TABLE lock_alert_rules (
    rule_name VARCHAR(50) PRIMARY KEY,
    metric_name VARCHAR(50) NOT NULL,
    threshold_value DECIMAL(10,2) NOT NULL,
    alert_level ENUM('INFO', 'WARNING', 'CRITICAL') NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入预警规则
INSERT INTO lock_alert_rules VALUES
('等待事务数量告警', 'waiting_transactions', 10, 'WARNING', TRUE, NOW()),
('严重等待告警', 'severe_waits', 5, 'CRITICAL', TRUE, NOW()),
('极严重等待告警', 'critical_waits', 1, 'CRITICAL', TRUE, NOW()),
('平均等待时间告警', 'avg_wait_seconds', 15, 'WARNING', TRUE, NOW()),
('最大等待时间告警', 'max_wait_seconds', 60, 'CRITICAL', TRUE, NOW());
```

**预警检查存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE CheckLockAlerts()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_rule_name VARCHAR(50);
    DECLARE v_metric_name VARCHAR(50);  
    DECLARE v_threshold DECIMAL(10,2);
    DECLARE v_alert_level VARCHAR(20);
    DECLARE v_current_value DECIMAL(10,2);
    
    DECLARE rule_cursor CURSOR FOR 
        SELECT rule_name, metric_name, threshold_value, alert_level
        FROM lock_alert_rules WHERE enabled = TRUE;
        
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 获取当前监控指标
    CREATE TEMPORARY TABLE current_metrics AS
    SELECT * FROM lock_monitoring_metrics;
    
    OPEN rule_cursor;
    
    check_loop: LOOP
        FETCH rule_cursor INTO v_rule_name, v_metric_name, v_threshold, v_alert_level;
        
        IF done THEN
            LEAVE check_loop;
        END IF;
        
        -- 动态获取指标值
        SET @sql = CONCAT('SELECT ', v_metric_name, ' FROM current_metrics INTO @current_value');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        SET v_current_value = @current_value;
        
        -- 检查是否超过阈值
        IF v_current_value > v_threshold THEN
            INSERT INTO lock_alert_log (
                rule_name, metric_name, current_value, threshold_value, 
                alert_level, alert_time
            ) VALUES (
                v_rule_name, v_metric_name, v_current_value, v_threshold,
                v_alert_level, NOW()
            );
            
            -- 发送告警通知（可以调用外部脚本）
            SELECT CONCAT('ALERT: ', v_rule_name, ' - 当前值:', v_current_value, 
                         ' 超过阈值:', v_threshold) AS alert_message;
        END IF;
        
    END LOOP;
    
    CLOSE rule_cursor;
    DROP TEMPORARY TABLE current_metrics;
    
END //
DELIMITER ;
```

### 9.3 预警通知机制


**多渠道通知**：
```bash
#!/bin/bash
# 锁等待预警通知脚本

DB_HOST="localhost"
DB_USER="monitor"
DB_PASS="password"

# 检查预警
mysql -h${DB_HOST} -u${DB_USER} -p${DB_PASS} -e "CALL CheckLockAlerts();" | \
while read alert_line; do
    if [[ $alert_line == ALERT:* ]]; then
        # 邮件通知
        echo "$alert_line" | mail -s "MySQL锁等待告警" admin@company.com
        
        # 短信通知（调用短信接口）
        curl -X POST "https://sms.api.com/send" \
             -d "phone=13800138000&message=$alert_line"
             
        # 钉钉/企业微信通知
        curl -X POST "https://oapi.dingtalk.com/robot/send?access_token=xxx" \
             -H "Content-Type: application/json" \
             -d "{\"msgtype\":\"text\",\"text\":{\"content\":\"$alert_line\"}}"
    fi
done
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的分析方法


```
🔸 基础工具：performance_schema、INFORMATION_SCHEMA、sys schema
🔸 等待链分析：递归查询构建完整等待关系
🔸 热点识别：基于争用频率和等待时间双重标准
🔸 时间统计：多维度统计等待时间分布
🔸 阻塞关系：构建事务间的阻塞关系图
```

### 10.2 关键分析思路


**🔹 分析的系统方法**：
```
WHO：谁在等待？谁在阻塞？
WHAT：等什么锁？锁什么资源？
WHERE：哪个表？哪个索引？
WHEN：什么时候开始等？等了多久？
WHY：为什么会等待？根本原因是什么？
HOW：怎么解决？怎么预防？
```

**🔹 优化的优先级原则**：
```
1. 先解决严重等待（>30秒）
2. 再处理热点争用（高频率）
3. 最后优化一般性能问题
4. 建立长期监控机制
```

### 10.3 实践应用指南


**📈 日常监控重点**：
- 每5分钟检查一次当前等待情况
- 每小时生成一次分析报告
- 每天分析等待趋势变化
- 每周评估优化效果

**⚠️ 紧急处理流程**：
1. **发现告警** → 立即查看当前等待状况
2. **定位根因** → 找出最长等待链的源头
3. **应急处理** → 必要时KILL阻塞事务
4. **后续分析** → 分析原因制定改进方案

**💡 预防性措施**：
- 合理设计索引减少锁争用
- 控制事务大小和持续时间
- 优化查询减少锁定范围
- 建立完善的监控预警体系

**核心记忆**：
- 锁等待分析重在找到瓶颈根源
- 工具使用要结合具体场景选择
- 预警机制比事后分析更重要
- 优化方案要考虑业务影响程度