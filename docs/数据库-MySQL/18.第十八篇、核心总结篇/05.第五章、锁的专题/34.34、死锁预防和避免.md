---
title: 34、死锁预防和避免
---
## 📚 目录

1. [死锁预防与避免概述](#1-死锁预防与避免概述)
2. [死锁预防策略](#2-死锁预防策略)
3. [死锁避免策略](#3-死锁避免策略)
4. [MySQL实际应用策略](#4-MySQL实际应用策略)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🔒 死锁预防与避免概述


### 1.1 什么是死锁预防和避免


**死锁预防（Prevention）**：就像制定交通规则一样，在系统设计时就制定严格的规则，让死锁从根本上无法发生。

**死锁避免（Avoidance）**：就像智能导航系统一样，实时监控当前状态，如果发现可能导致死锁的路径就避开它。

```
生活类比理解：
预防 = 交通规则：所有车都必须靠右行驶（永远不会正面相撞）
避免 = 智能导航：检测到前方堵车就绕行（动态调整路径）
```

### 1.2 两种策略的根本区别


**🔸 预防策略特点：**
```
实施时机：系统设计阶段
工作方式：破坏死锁产生的必要条件
代价：限制较多，性能可能受影响
效果：100%不会发生死锁
```

**🔸 避免策略特点：**
```
实施时机：运行过程中
工作方式：动态检测和调整
代价：需要实时计算，开销较大
效果：在保证安全的前提下最大化并发
```

### 1.3 死锁产生的四个必要条件回顾


要理解预防策略，先回顾死锁的四个必要条件：

```
互斥条件：资源只能被一个事务占用
持有等待：占用资源的同时等待其他资源  
不可剥夺：不能强制释放其他事务的资源
循环等待：事务间形成环形等待链
```

**💡 核心理解：** 预防策略就是破坏这四个条件中的至少一个，让死锁无法形成。

---

## 2. 🛡️ 死锁预防策略


### 2.1 资源排序策略


**核心思想：** 所有事务都必须按照固定的顺序申请锁资源，就像银行排队一样，大家都按号码顺序来。

**🔧 实现原理：**
```
原理：破坏"循环等待"条件
方法：给所有锁对象编号，事务只能按编号从小到大申请锁
结果：不可能形成环形等待
```

**📝 代码示例：**
```sql
-- ❌ 错误做法：容易死锁
-- 事务A
BEGIN;
UPDATE table1 SET value=1 WHERE id=1;  -- 先锁table1
UPDATE table2 SET value=2 WHERE id=2;  -- 后锁table2
COMMIT;

-- 事务B  
BEGIN;
UPDATE table2 SET value=3 WHERE id=2;  -- 先锁table2
UPDATE table1 SET value=4 WHERE id=1;  -- 后锁table1 → 死锁！
COMMIT;

-- ✅ 正确做法：资源排序
-- 规定：总是先锁id小的表，再锁id大的表
-- 事务A和B都必须遵循：table1(id=1) → table2(id=2)
BEGIN;
UPDATE table1 SET value=1 WHERE id=1;  -- 先锁id=1
UPDATE table2 SET value=2 WHERE id=2;  -- 后锁id=2
COMMIT;
```

**🎯 应用场景：**
```
业务层面：
• 转账业务：总是先锁账号小的，再锁账号大的
• 批量操作：按主键ID排序后再处理
• 多表更新：按表名或表ID排序

技术层面：
• ORM框架：内置资源排序逻辑
• 存储过程：标准化锁获取顺序
• 应用程序：统一的锁获取规范
```

### 2.2 超时机制策略


**核心思想：** 设置等待时间限制，就像排队有时间限制一样，超时就放弃。

**🔧 MySQL配置：**
```sql
-- 设置锁等待超时时间（秒）
SET innodb_lock_wait_timeout = 5;

-- 查看当前设置
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';
```

**📊 超时机制原理：**
```
正常情况：事务A → 申请锁 → 获得锁 → 执行 → 释放锁
死锁情况：事务A → 申请锁 → 等待... → 超时 → 自动回滚

优点：
• 简单易实现
• 能够自动解除死锁
• 不需要复杂的检测算法

缺点：  
• 可能误伤正常的长等待
• 超时时间难以设置合适
• 用户体验可能不好
```

### 2.3 一次性锁申请策略


**核心思想：** 事务开始时就申请所有需要的锁，要么全部获得，要么全部放弃。

**🔧 实现方式：**
```sql
-- 方式1：使用LOCK TABLES（表级锁）
LOCK TABLES 
  accounts_table READ,
  transfer_log WRITE,
  balance_history WRITE;
  
-- 执行所有操作
UPDATE accounts_table SET balance = balance - 100 WHERE id = 1;
UPDATE accounts_table SET balance = balance + 100 WHERE id = 2;
INSERT INTO transfer_log VALUES (...);

-- 释放所有锁
UNLOCK TABLES;

-- 方式2：使用SELECT ... FOR UPDATE预先锁定
BEGIN;
-- 一次性锁定所有需要的行
SELECT * FROM accounts WHERE id IN (1, 2) ORDER BY id FOR UPDATE;
-- 然后执行业务逻辑
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

**⚖️ 优缺点分析：**

| 维度 | **优点** ✅ | **缺点** ❌ |
|------|-------------|-------------|
| **死锁** | `完全避免死锁` | `可能长时间占用资源` |
| **性能** | `减少锁申请开销` | `降低并发度` |
| **实现** | `逻辑相对简单` | `需要预知所有资源` |

### 2.4 锁顺序规范策略


**核心思想：** 制定应用层面的锁获取规范，所有开发人员都必须遵守。

**📋 规范示例：**
```
规范1：数据库锁获取顺序
1. 先获取表级锁，后获取行级锁
2. 同级别锁按照表名字典序获取
3. 行锁按照主键ID升序获取

规范2：业务逻辑锁获取顺序  
1. 用户相关锁 → 订单相关锁 → 商品相关锁
2. 同类业务锁按照ID升序获取

规范3：跨系统锁获取顺序
1. 本地锁 → 分布式锁
2. 核心业务锁 → 次要业务锁
```

**🛠️ 实际应用：**
```java
// Java示例：统一的锁获取工具类
public class LockOrderManager {
    
    // 按照规定顺序获取多个账户的锁
    public static void lockAccounts(List<Long> accountIds) {
        // 排序确保一致的获取顺序
        Collections.sort(accountIds);
        
        for (Long accountId : accountIds) {
            acquireAccountLock(accountId);
        }
    }
    
    // 转账业务：标准化锁获取
    public static void transfer(Long fromId, Long toId, BigDecimal amount) {
        // 总是按ID大小顺序获取锁
        Long firstId = Math.min(fromId, toId);
        Long secondId = Math.max(fromId, toId);
        
        lockAccounts(Arrays.asList(firstId, secondId));
        try {
            // 执行转账逻辑
            doTransfer(fromId, toId, amount);
        } finally {
            // 释放锁
            unlockAccounts(Arrays.asList(firstId, secondId));
        }
    }
}
```

---

## 3. 🎯 死锁避免策略


### 3.1 银行家算法概述


**核心思想：** 就像银行放贷一样，在给出资源前先评估是否会导致系统进入不安全状态。

**🏦 银行家算法类比：**
```
银行放贷逻辑：
1. 客户申请贷款
2. 银行评估：如果放贷，还有足够资金应对其他客户需求吗？
3. 如果安全：放贷；如果不安全：拒绝或延迟

数据库锁分配：
1. 事务申请锁
2. 系统评估：如果给予锁，系统还能保证所有事务正常完成吗？
3. 如果安全：分配锁；如果不安全：等待
```

### 3.2 安全状态检测


**安全状态定义：** 存在一个事务执行序列，让所有事务都能顺利完成。

**🔍 检测过程示例：**
```
当前状态：
事务T1：持有锁A，还需要锁B
事务T2：持有锁B，还需要锁C  
事务T3：持有锁C，还需要锁A

检测结果：T1→T2→T3→T1 形成循环，不安全！

安全的调整：
让T3先完成并释放锁C
然后T2获得锁C，完成并释放锁B
最后T1获得锁B，完成所有操作
```

### 3.3 动态资源分配


**核心策略：** 实时监控资源使用情况，动态决定是否分配新的锁。

**📊 分配决策矩阵：**
```
评估维度：
1. 当前锁持有情况
2. 事务的资源需求预测
3. 系统整体负载状态
4. 历史死锁发生概率

决策规则：
IF (系统处于安全状态 AND 分配后仍安全) 
    THEN 立即分配锁
ELSE IF (有可能通过等待变安全)
    THEN 延迟分配
ELSE  
    THEN 拒绝请求或建议重试
```

### 3.4 实现成本分析


**💰 银行家算法的实际成本：**
```
计算成本：
• 每次锁申请都需要安全性检测
• 需要维护复杂的资源分配矩阵
• O(n³)的算法复杂度

存储成本：
• 需要记录所有事务的资源需求
• 维护系统状态快照
• 额外的元数据存储

性能影响：
• 锁申请延迟增加
• 系统吞吐量可能下降
• 内存消耗增大
```

**⚡ MySQL中的实际考虑：**
```
MySQL为什么不使用银行家算法：
1. 计算开销太大，影响性能
2. 很难准确预测事务的资源需求
3. Web应用的事务模式相对简单
4. 有更简单有效的替代方案

MySQL实际采用的策略：
1. 死锁检测 + 自动回滚
2. 锁等待超时机制  
3. 鼓励应用层规范化锁使用
```

---

## 4. 🚀 MySQL实际应用策略


### 4.1 应用层控制策略


**业务设计层面的死锁预防：**

**🔧 策略1：缩短事务时间**
```sql
-- ❌ 容易死锁的长事务
BEGIN;
-- 复杂计算逻辑（耗时长）
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 更多业务逻辑...
COMMIT;

-- ✅ 优化后的短事务
-- 先在应用层完成计算
BigDecimal newBalance = calculateNewBalance(accountId);
-- 快速执行数据库操作
BEGIN;
UPDATE accounts SET balance = ? WHERE id = ?;
COMMIT;
```

**🔧 策略2：读写分离**
```sql
-- ❌ 读写混合容易冲突
BEGIN;
SELECT count(*) FROM orders WHERE user_id = 1;  -- 读操作
UPDATE user_stats SET order_count = ? WHERE id = 1;  -- 写操作
COMMIT;

-- ✅ 分离读写操作
-- 读操作使用只读事务
SET TRANSACTION READ ONLY;
SELECT count(*) FROM orders WHERE user_id = 1;

-- 写操作单独事务
BEGIN;
UPDATE user_stats SET order_count = ? WHERE id = 1;
COMMIT;
```

### 4.2 事务重试机制


**智能重试策略：**

```java
public class DeadlockRetryHandler {
    
    private static final int MAX_RETRY = 3;
    private static final int BASE_DELAY = 100; // 毫秒
    
    public void executeWithRetry(Runnable transaction) {
        int attempt = 0;
        
        while (attempt < MAX_RETRY) {
            try {
                transaction.run();
                return; // 成功执行，退出
                
            } catch (DeadlockException e) {
                attempt++;
                
                if (attempt >= MAX_RETRY) {
                    throw new BusinessException("事务执行失败，已重试" + MAX_RETRY + "次");
                }
                
                // 指数退避：等待时间逐渐增加
                int delay = BASE_DELAY * (1 << attempt);
                try {
                    Thread.sleep(delay + new Random().nextInt(delay));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("重试被中断", ie);
                }
            }
        }
    }
}
```

### 4.3 MySQL配置优化


**🔧 关键参数调优：**
```sql
-- 死锁检测（默认开启，建议保持）
SET GLOBAL innodb_deadlock_detect = ON;

-- 锁等待超时时间（根据业务调整）
SET GLOBAL innodb_lock_wait_timeout = 10;

-- 事务隔离级别（降低隔离级别可减少死锁）
-- 但要权衡数据一致性需求
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 查看死锁信息
SHOW ENGINE INNODB STATUS;
```

### 4.4 监控和诊断


**📊 死锁监控指标：**
```sql
-- 查看死锁统计
SELECT 
    ENGINE,
    EVENT_NAME,
    COUNT_STAR as deadlock_count
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE EVENT_NAME LIKE '%deadlock%';

-- 分析最近的死锁信息
SHOW ENGINE INNODB STATUS;
-- 查看 "LATEST DETECTED DEADLOCK" 部分
```

**🔧 应用监控代码：**
```java
@Component 
public class DeadlockMonitor {
    
    private final MeterRegistry meterRegistry;
    private Counter deadlockCounter;
    
    @PostConstruct
    public void init() {
        this.deadlockCounter = Counter.builder("database.deadlock.count")
                .description("数据库死锁次数")
                .register(meterRegistry);
    }
    
    @EventListener
    public void handleDeadlock(DeadlockDetectedEvent event) {
        deadlockCounter.increment();
        
        // 记录详细日志
        log.warn("检测到死锁: 事务={}, SQL={}, 重试次数={}", 
                event.getTransactionId(),
                event.getSql(),
                event.getRetryCount());
    }
}
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 死锁预防：在系统设计时就防止死锁发生
🔸 死锁避免：运行时动态检测和规避死锁风险
🔸 资源排序：所有事务按固定顺序申请锁资源
🔸 超时机制：设置锁等待时间限制，超时自动回滚
🔸 一次性申请：事务开始时申请所有需要的锁
🔸 银行家算法：动态评估资源分配的安全性
🔸 应用层控制：通过业务设计和代码规范预防死锁
```

### 5.2 实际应用指导


**🔹 策略选择原则：**
```
高并发系统：优先考虑应用层控制 + 超时机制
关键业务：资源排序 + 事务重试
简单场景：超时机制 + 死锁检测
复杂系统：多种策略组合使用
```

**🔹 性能与安全权衡：**
```
完全预防死锁：安全性最高，但并发性能可能受限
动态避免死锁：性能较好，但实现复杂度高
检测后回滚：实现简单，但可能影响用户体验
```

### 5.3 最佳实践建议


**💡 开发规范：**
- 制定统一的锁获取顺序规范
- 尽量缩短事务持有锁的时间
- 合理设置锁等待超时时间
- 实现智能重试机制
- 加强死锁监控和告警

**🔧 系统设计：**
- 优先考虑应用层面的死锁预防
- 合理选择事务隔离级别
- 避免长事务和复杂的嵌套事务
- 设计时考虑读写分离

**📊 运维监控：**
- 监控死锁发生频率和趋势
- 分析死锁的具体原因和SQL语句
- 建立死锁问题的快速响应机制

**🎯 核心记忆：**
- 预防胜于治疗：设计阶段就要考虑死锁预防
- 简单有效：应用层控制往往比复杂算法更实用
- 持续监控：死锁问题需要持续关注和优化
- 权衡取舍：安全性和性能之间要找到平衡点