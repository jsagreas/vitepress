---
title: 4、锁的基本分类体系
---
## 📚 目录

1. [锁分类概述](#1-锁分类概述)
2. [按粒度分类](#2-按粒度分类)
3. [按模式分类](#3-按模式分类)
4. [按功能分类](#4-按功能分类)
5. [按实现分类](#5-按实现分类)
6. [按作用范围分类](#6-按作用范围分类)
7. [按持续时间分类](#7-按持续时间分类)
8. [锁层次结构](#8-锁层次结构)
9. [分类相互关系](#9-分类相互关系)
10. [实际应用选择](#10-实际应用选择)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔍 锁分类概述


### 1.1 为什么要分类锁


**问题背景**：数据库中有很多种锁，不同场景需要不同的锁

想象一下图书馆的管理：
- 有些书只能一个人看（独占锁）
- 有些书可以多人同时看（共享锁）
- 管理员可能锁整个书架（表锁）
- 也可能只锁一本书（行锁）

数据库锁也是这个道理，需要根据不同的使用场景来分类和选择。

### 1.2 分类标准总览


```
MySQL锁分类的6个维度：

📏 按粒度分类
   ├─ 表锁：锁整张表
   ├─ 行锁：锁单行数据  
   └─ 页锁：锁数据页

🔐 按模式分类
   ├─ 共享锁：可以多个一起读
   └─ 排他锁：只能一个独占

🎯 按功能分类
   ├─ 读锁：保护读操作
   └─ 写锁：保护写操作

⚙️ 按实现分类
   ├─ 悲观锁：先锁定再操作
   └─ 乐观锁：操作时才检查

🌍 按作用范围分类
   ├─ 全局锁：影响整个数据库
   ├─ 库锁：影响单个数据库
   └─ 表对象锁：影响表或索引

⏰按持续时间分类
   ├─ 临时锁：事务结束就释放
   └─ 持久锁：手动释放
```

---

## 2. 📏 按粒度分类


### 2.1 表锁（Table Lock）


**🔸 核心概念**
```
表锁就像锁住整个房间
- 一旦锁住，整张表都被保护
- 实现简单，开销小
- 但并发性差，一锁锁全表
```

**💡 工作原理**
```sql
-- 手动加表锁的语法
LOCK TABLES user_info READ;    -- 给表加读锁
LOCK TABLES user_info WRITE;   -- 给表加写锁
UNLOCK TABLES;                 -- 释放所有锁
```

**📊 表锁特点分析**
| 特点 | **读锁(READ)** | **写锁(WRITE)** |
|------|---------------|----------------|
| 🔍 **本会话** | `可以读，不能写` | `可以读写，不能访问其他表` |
| 👥 **其他会话** | `可以读，写操作被阻塞` | `读写操作都被阻塞` |
| ⚡ **并发性** | `多个读可以并发` | `完全串行化执行` |

### 2.2 行锁（Row Lock）


**🔸 核心概念**
```
行锁就像锁住房间里的一张桌子
- 只锁定需要的具体数据行
- 并发性好，不同行可以同时操作
- 但实现复杂，开销较大
```

**💡 InnoDB行锁机制**
```sql
-- 行锁通过索引实现，没有索引会升级为表锁
SELECT * FROM user_info WHERE id = 1 FOR UPDATE;  -- 排他行锁
SELECT * FROM user_info WHERE id = 1 LOCK IN SHARE MODE;  -- 共享行锁

-- 危险：没有索引的条件会导致全表扫描，升级为表锁
SELECT * FROM user_info WHERE name = 'zhangsan' FOR UPDATE;
```

> ⚠️ **重要提醒**
> InnoDB的行锁是通过索引实现的！如果查询条件没有使用索引，会升级为表锁，严重影响并发性能。

### 2.3 页锁（Page Lock）


**🔸 核心概念**
```
页锁介于表锁和行锁之间
- 锁定数据页（通常8KB）
- 比行锁开销小，比表锁并发性好
- 但可能锁住不需要的数据
```

**实际应用场景**
- BDB存储引擎使用页锁
- 现在MySQL主要用InnoDB，很少遇到页锁
- 了解概念即可，实际开发中不常用

### 2.4 粒度选择原则


```
🎯 选择原则：

表锁适用场景：
✅ 大量数据的批量操作
✅ 数据仓库的ETL过程  
✅ 备份和维护操作
❌ 高并发的OLTP系统

行锁适用场景：
✅ 高并发的在线事务处理
✅ 精确的数据修改操作
✅ 长时间运行的复杂事务
❌ 全表扫描的大批量操作

记忆口诀：
粒度越小并发越好，开销越大性能考虑
粒度越大开销越小，并发受限要权衡
```

---

## 3. 🔐 按模式分类


### 3.1 共享锁（Shared Lock）


**🔸 核心概念**
```
共享锁就像图书馆的书，可以多人同时阅读
- 多个事务可以同时获取共享锁
- 有共享锁时，不能获取排他锁
- 也叫读锁（Read Lock）、S锁
```

**💡 获取方式**
```sql
-- 显式加共享锁
SELECT * FROM user_info WHERE id = 1 LOCK IN SHARE MODE;

-- 普通SELECT在可重复读隔离级别下会加共享锁
-- （实际上InnoDB使用MVCC，不加锁）
SELECT * FROM user_info WHERE id = 1;
```

**共享锁兼容性表**
| 当前锁 | **请求共享锁** | **请求排他锁** |
|-------|--------------|--------------|
| 🔓 **无锁** | `✅ 可以获取` | `✅ 可以获取` |
| 🔒 **共享锁** | `✅ 可以获取` | `❌ 需要等待` |
| 🚫 **排他锁** | `❌ 需要等待` | `❌ 需要等待` |

### 3.2 排他锁（Exclusive Lock）


**🔸 核心概念**
```
排他锁就像独占的办公室，只能一个人使用
- 只有一个事务可以获取排他锁
- 有排他锁时，其他锁都不能获取
- 也叫写锁（Write Lock）、X锁
```

**💡 获取方式**
```sql
-- 显式加排他锁
SELECT * FROM user_info WHERE id = 1 FOR UPDATE;

-- DML操作自动加排他锁
UPDATE user_info SET name = 'lisi' WHERE id = 1;
DELETE FROM user_info WHERE id = 1;
INSERT INTO user_info(name) VALUES('wangwu');
```

### 3.3 锁模式实战示例


**🛠️ 实际场景演示**
```sql
-- 会话1：获取共享锁
START TRANSACTION;
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;
-- 查询成功，获得共享锁

-- 会话2：尝试获取共享锁  
START TRANSACTION;
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;
-- 查询成功！可以同时持有共享锁

-- 会话3：尝试获取排他锁
START TRANSACTION;
SELECT * FROM account WHERE id = 1 FOR UPDATE;
-- 被阻塞！必须等待共享锁释放

-- 会话1和会话2：提交事务释放锁
COMMIT;
-- 会话3立即获得排他锁
```

---

## 4. 🎯 按功能分类


### 4.1 读锁（Read Lock）


**🔸 核心概念**
```
读锁专门保护读操作
- 允许多个读操作同时进行
- 防止读操作时数据被修改
- 就是共享锁的另一个名字
```

**应用场景分析**
```
适用场景：
📊 报表统计：需要读取大量数据进行计算
🔍 数据查询：确保查询过程中数据不变
📋 数据导出：保证导出数据的一致性

实际例子：
电商系统生成销售报表时，需要确保统计期间
销售数据不被修改，保证报表的准确性
```

### 4.2 写锁（Write Lock）


**🔸 核心概念**
```
写锁专门保护写操作
- 只允许一个写操作进行
- 写操作期间禁止其他读写操作
- 就是排他锁的另一个名字
```

**应用场景分析**
```
适用场景：
💰 转账操作：修改账户余额时需要排他锁
📦 库存扣减：避免超卖问题
🎫 秒杀活动：防止商品被重复购买

实际例子：
用户转账时，必须锁定相关账户记录，
防止并发操作导致数据不一致
```

### 4.3 功能分类的实际意义


```
🎯 理解要点：

读锁 = 共享锁：
- 名字不同，本质相同
- 强调保护读操作的功能
- 允许并发读，提高查询性能

写锁 = 排他锁：  
- 名字不同，本质相同
- 强调保护写操作的功能
- 独占资源，保证数据一致性

选择依据：
看操作类型 → SELECT用读锁，INSERT/UPDATE/DELETE用写锁
看并发需求 → 允许并发读用读锁，需要独占用写锁
```

---

## 5. ⚙️ 按实现分类


### 5.1 悲观锁（Pessimistic Locking）


**🔸 核心概念**
```
悲观锁的思维：
"我觉得肯定会有冲突，所以先锁住再说"
- 操作前就获取锁
- 锁住资源直到操作完成
- MySQL的锁机制就是悲观锁
```

**💡 实现方式**
```sql
-- 悲观锁的典型用法
START TRANSACTION;

-- 先锁定要操作的数据
SELECT balance FROM account WHERE id = 1 FOR UPDATE;

-- 然后进行业务逻辑处理
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;

COMMIT;
```

**优缺点分析**
```
✅ 优点：
- 数据一致性有保障
- 适合冲突频繁的场景
- 实现简单，逻辑清晰

❌ 缺点：
- 并发性能较差
- 可能导致死锁
- 锁持有时间长
```

### 5.2 乐观锁（Optimistic Locking）


**🔸 核心概念**
```
乐观锁的思维：
"我觉得冲突很少，先做再检查"
- 操作时不加锁
- 提交前检查数据是否被修改
- 通过版本号或时间戳实现
```

**💡 实现方式**
```sql
-- 方式1：版本号机制
-- 表结构需要version字段
SELECT id, balance, version FROM account WHERE id = 1;
-- 假设查询到：id=1, balance=1000, version=5

-- 更新时检查版本号
UPDATE account 
SET balance = balance - 100, version = version + 1 
WHERE id = 1 AND version = 5;

-- 如果更新影响行数为0，说明被其他事务修改过

-- 方式2：时间戳机制  
UPDATE account 
SET balance = balance - 100, update_time = NOW()
WHERE id = 1 AND update_time = '2025-01-15 10:30:00';
```

**优缺点分析**
```
✅ 优点：
- 并发性能好
- 不会产生死锁
- 适合读多写少场景

❌ 缺点：
- 需要额外的版本字段
- 冲突时需要重试逻辑
- 实现相对复杂
```

### 5.3 悲观锁 vs 乐观锁选择


```
🎯 选择标准：

悲观锁适用：
- 写操作频繁的系统
- 数据冲突概率高
- 对数据一致性要求极高
- 例如：银行转账、库存扣减

乐观锁适用：
- 读操作频繁的系统  
- 数据冲突概率低
- 对并发性能要求高
- 例如：用户信息更新、文章点赞

实际选择：
大部分情况下，MySQL默认使用悲观锁
高并发场景可以考虑应用层实现乐观锁
```

---

## 6. 🌍 按作用范围分类


### 6.1 全局锁（Global Lock）


**🔸 核心概念**
```
全局锁影响整个MySQL实例
- 锁定后整个数据库只读
- 主要用于数据备份
- 影响范围最大，慎用
```

**💡 使用方式**
```sql
-- 加全局锁
FLUSH TABLES WITH READ LOCK;

-- 此时整个MySQL实例只读
-- 所有写操作都会被阻塞

-- 释放全局锁
UNLOCK TABLES;
```

**典型应用场景**
```
🛠️ 主要用途：

1. 全库备份：
   - 保证备份数据的一致性
   - 避免备份过程中数据变更

2. 主从复制：
   - 初始化从库时使用
   - 确保数据同步的起点一致

⚠️ 注意事项：
全局锁会让整个数据库不可写入，
生产环境使用需要在业务低峰期进行
```

### 6.2 库锁（Database Lock）


**🔸 核心概念**
```
库锁影响单个数据库
- 可以锁定特定的数据库
- 不影响其他数据库的操作
- 粒度比全局锁小
```

**实际应用较少**
- MySQL中库锁使用场景有限
- 大多数情况使用表锁就足够了
- 了解概念即可

### 6.3 表对象锁（Table Object Lock）


**🔸 核心概念**
```
表对象锁保护表结构和索引
- 表锁：保护表数据
- 元数据锁：保护表结构
- 意向锁：多级锁协议
```

**💡 元数据锁（MDL）**
```sql
-- 当执行DDL操作时，会自动加MDL锁
ALTER TABLE user_info ADD COLUMN age INT;

-- MDL锁保护表结构不被并发修改
-- 例如：正在查询时，不能删除表
```

**意向锁机制**
```
意向锁的作用：
提高锁检测的效率

例如：
- 某行已经有行级排他锁
- 其他事务想加表级共享锁
- 通过意向锁快速判断冲突，无需逐行检查

意向锁类型：
IS锁：意向共享锁
IX锁：意向排他锁
```

---

## 7. ⏰ 按持续时间分类


### 7.1 临时锁（Temporary Lock）


**🔸 核心概念**
```
临时锁随事务自动管理
- 事务开始时获取
- 事务结束时自动释放
- 不需要手动管理
```

**典型例子**
```sql
-- 事务中的锁都是临时锁
START TRANSACTION;

SELECT * FROM user_info WHERE id = 1 FOR UPDATE;  -- 获取锁
UPDATE user_info SET name = 'lisi' WHERE id = 1;

COMMIT;  -- 自动释放所有锁
```

### 7.2 持久锁（Persistent Lock）


**🔸 核心概念**
```
持久锁需要手动释放
- 不随事务结束而释放
- 主要是表级别的锁
- 需要显式UNLOCK命令
```

**典型例子**
```sql
-- 表锁是持久锁
LOCK TABLES user_info READ;

-- 即使没有事务，锁也持续存在
SELECT * FROM user_info;  -- 可以执行

-- 必须手动释放
UNLOCK TABLES;
```

### 7.3 持续时间选择原则


```
🎯 使用建议：

临时锁（推荐）：
- 自动管理，不容易忘记
- 符合ACID特性
- 大部分场景的首选

持久锁（谨慎使用）：
- 需要手动管理
- 容易忘记释放造成阻塞
- 仅在特殊场景使用

最佳实践：
优先使用事务+临时锁
避免使用持久锁，除非特殊需求
```

---

## 8. 🏗️ 锁层次结构


### 8.1 MySQL锁的层次架构


```
MySQL锁层次结构：

🌐 实例级别
   ├─ 全局锁（FTWRL）
   └─ 全局读锁
   
🏢 库级别  
   ├─ 库锁（较少使用）
   └─ 元数据锁
   
📋 表级别
   ├─ 表锁（Table Lock）
   ├─ 意向锁（Intention Lock）
   └─ 元数据锁（MDL Lock）
   
📄 页级别
   └─ 页锁（Page Lock）
   
📝 行级别
   ├─ 记录锁（Record Lock）
   ├─ 间隙锁（Gap Lock）  
   └─ Next-key锁
```

### 8.2 层次兼容性规则


**🔸 基本原则**
```
上级锁影响下级锁：
- 有表锁时，行锁无法获取
- 有全局锁时，所有下级锁都受影响

同级锁互斥规则：
- 排他锁与任何锁互斥
- 共享锁之间兼容

意向锁机制：
- 获取行锁前，先获取对应的意向锁
- 提高锁冲突检测效率
```

### 8.3 层次结构的实际意义


```
🎯 理解要点：

1. 锁升级：
   条件不当时，行锁可能升级为表锁
   影响并发性能

2. 死锁避免：
   了解层次有助于设计避免死锁的方案

3. 性能优化：
   选择合适粒度的锁，平衡并发与开销

记忆方法：
锁的粒度从大到小：实例→库→表→页→行
影响范围从大到小，并发性从小到大
```

---

## 9. 🔗 分类相互关系


### 9.1 不同分类维度的关系


```
分类维度关系图：

粒度分类 ←→ 模式分类
  ↓           ↓
表锁     ←→  共享锁/排他锁
行锁     ←→  共享锁/排他锁
  ↓           ↓  
功能分类 ←→ 实现分类
  ↓           ↓
读锁     ←→  悲观锁
写锁     ←→  乐观锁
```

### 9.2 典型组合模式


**🔸 常见锁组合**

| 组合类型 | **粒度** | **模式** | **功能** | **实现** |
|---------|---------|---------|---------|---------|
| 🔍 **查询锁** | `行锁` | `共享锁` | `读锁` | `悲观锁` |
| ✏️ **更新锁** | `行锁` | `排他锁` | `写锁` | `悲观锁` |
| 📊 **报表锁** | `表锁` | `共享锁` | `读锁` | `悲观锁` |
| 🔧 **维护锁** | `表锁` | `排他锁` | `写锁` | `悲观锁` |

### 9.3 分类选择的决策树


```
🌳 锁选择决策流程：

数据量大小？
├─ 大数据量 → 考虑表锁
└─ 小数据量 → 考虑行锁
    ↓
    操作类型？
    ├─ 只读操作 → 共享锁
    └─ 读写操作 → 排他锁
        ↓
        冲突频率？
        ├─ 频繁冲突 → 悲观锁
        └─ 少量冲突 → 乐观锁
            ↓
            持续时间？
            ├─ 短期操作 → 临时锁
            └─ 长期操作 → 持久锁
```

---

## 10. 🎯 实际应用选择


### 10.1 典型业务场景分析


**🛒 电商秒杀场景**
```sql
-- 悲观锁方案：行级排他锁
START TRANSACTION;
SELECT stock FROM product WHERE id = 1 FOR UPDATE;
-- 检查库存
IF stock > 0 THEN
    UPDATE product SET stock = stock - 1 WHERE id = 1;
    INSERT INTO order_info(...) VALUES(...);
END IF;
COMMIT;

推荐指数：★★★★☆
适用：中等并发，数据一致性要求高
```

**📊 数据分析场景**
```sql
-- 表级共享锁方案
LOCK TABLES sales_data READ;
SELECT 
    DATE(create_time) as date,
    SUM(amount) as total_sales
FROM sales_data 
WHERE create_time >= '2025-01-01'
GROUP BY DATE(create_time);
UNLOCK TABLES;

推荐指数：★★★★★
适用：大数据量统计，短时间内数据不变
```

### 10.2 性能对比分析


**📈 不同锁机制的性能表现**

| 场景类型 | **表锁** | **行锁** | **乐观锁** |
|---------|---------|---------|-----------|
| 🚀 **高并发读** | `★★☆☆☆` | `★★★★☆` | `★★★★★` |
| ✏️ **高并发写** | `★☆☆☆☆` | `★★★★☆` | `★★★☆☆` |
| 📊 **批量操作** | `★★★★★` | `★★☆☆☆` | `★☆☆☆☆` |
| 💾 **内存开销** | `★★★★★` | `★★★☆☆` | `★★★★☆` |
| 🔧 **实现复杂度** | `★★★★★` | `★★★☆☆` | `★★☆☆☆` |

### 10.3 选择建议总结


```
🎯 实际选择指南：

默认选择：
✅ InnoDB引擎 + 行级锁 + 悲观锁
✅ 适合90%的常规业务场景

特殊优化：
🔸 读多写少 → 考虑乐观锁
🔸 批量操作 → 考虑表锁  
🔸 数据分析 → 考虑共享锁
🔸 数据备份 → 考虑全局锁

避免陷阱：
❌ 没有索引导致行锁升级
❌ 长事务持有锁时间过长
❌ 不合理的锁顺序导致死锁
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的分类体系


```
🔸 按粒度：表锁、行锁、页锁（粒度越小并发越好）
🔸 按模式：共享锁、排他锁（读操作用共享，写操作用排他）
🔸 按功能：读锁、写锁（就是共享锁和排他锁的别名）
🔸 按实现：悲观锁、乐观锁（先锁定vs先操作后检查）
🔸 按范围：全局锁、库锁、表对象锁（影响范围不同）
🔸 按时间：临时锁、持久锁（自动释放vs手动释放）
```

### 11.2 关键理解要点


**🔹 分类不是孤立的**
```
理解要点：
- 同一个锁可以从多个维度分类
- 例如：SELECT ... FOR UPDATE是"行级排他悲观临时锁"
- 不同维度的分类可以组合使用
```

**🔹 选择锁的核心原则**
```
平衡三要素：
🎯 并发性能：粒度越小越好
🔒 数据安全：保护级别够用就行
⚡ 系统开销：实现复杂度适中

实际应用：
大部分情况选择InnoDB行锁就够用
特殊场景才考虑其他锁机制
```

**🔹 常见问题及避免**
```
典型问题：
1. 行锁升级为表锁（没有使用索引）
2. 死锁（锁顺序不当）
3. 锁等待超时（长事务）

避免方法：
1. 确保WHERE条件使用索引
2. 统一锁获取顺序
3. 控制事务大小和时间
```

### 11.3 实际应用价值


**📈 性能调优方面**
- 根据业务特点选择合适的锁粒度
- 通过锁监控发现性能瓶颈
- 优化SQL避免不必要的锁升级

**🔧 系统设计方面**
- 设计数据库架构时考虑锁的影响
- 制定事务边界和锁策略
- 规划高并发场景的锁机制

**核心记忆**：
- 锁分类多维度，组合使用有技巧
- 粒度模式是基础，功能实现看场景
- 范围时间辅助选，性能安全要平衡
- 实际应用靠经验，监控调优是关键