---
title: 37、performance_schema锁监控
---
## 📚 目录

1. [performance_schema架构概述](#1-performance_schema架构概述)
2. [核心锁监控表详解](#2-核心锁监控表详解)
3. [监控配置与启用](#3-监控配置与启用)
4. [实际监控查询分析](#4-实际监控查询分析)
5. [性能开销与优化](#5-性能开销与优化)
6. [问题定位最佳实践](#6-问题定位最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 performance_schema架构概述


### 1.1 什么是performance_schema


**💡 核心定义**
```
performance_schema：MySQL的性能监控引擎
本质：一个特殊的存储引擎，专门收集数据库运行时的性能数据
目标：提供实时的性能监控和问题诊断能力
```

**🏗️ 架构设计理念**
```
设计思路：
┌─────────────────┐
│   MySQL Server  │ ← 应用层数据库操作
├─────────────────┤
│ performance_    │ ← 监控层，收集性能数据
│ schema engine   │
├─────────────────┤
│   存储层引擎     │ ← 底层数据存储
└─────────────────┘

核心特点：
• 内存型存储：数据保存在内存中，重启后清空
• 实时收集：动态捕获数据库运行状态
• 低侵入性：尽量减少对正常业务的影响
• 丰富维度：涵盖锁、IO、内存、连接等各个方面
```

### 1.2 锁监控的重要意义


**🎯 为什么需要锁监控**
```
业务痛点：
• 数据库响应慢，但不知道哪里有锁等待
• 死锁频发，无法定位具体原因
• 并发性能差，不清楚锁竞争情况
• 问题排查困难，缺乏有效监控手段

解决价值：
• 实时了解锁的使用状况
• 快速定位锁等待和死锁问题
• 分析锁竞争的热点和模式
• 为性能优化提供数据依据
```

**📊 监控维度覆盖**
```
锁类型监控：
• 表级锁（Table-level locks）
• 行级锁（Row-level locks）  
• 元数据锁（Metadata locks）
• 意向锁（Intention locks）

监控状态：
• 锁持有状态（Lock granted）
• 锁等待状态（Lock waiting）
• 锁冲突关系（Lock conflicts）
• 锁持有时长（Lock duration）
```

---

## 2. 📋 核心锁监控表详解


### 2.1 data_locks表：当前锁状态


**🔸 表结构与含义**
```sql
-- 查看data_locks表结构
DESC performance_schema.data_locks;

核心字段解读：
┌─────────────────┬──────────────────────────────────┐
│ 字段名           │ 含义说明                          │
├─────────────────┼──────────────────────────────────┤
│ ENGINE          │ 存储引擎（通常是InnoDB）           │
│ OBJECT_SCHEMA   │ 数据库名                          │
│ OBJECT_NAME     │ 表名                              │
│ INDEX_NAME      │ 索引名（行锁时显示）               │
│ LOCK_TYPE       │ 锁类型（TABLE/RECORD）            │
│ LOCK_MODE       │ 锁模式（S/X/IS/IX等）             │
│ LOCK_STATUS     │ 锁状态（GRANTED/WAITING）         │
│ LOCK_DATA       │ 锁定的数据（行锁显示主键值）        │
│ THREAD_ID       │ 持有锁的线程ID                    │
└─────────────────┴──────────────────────────────────┘
```

**💡 锁模式详解**
```
表级锁模式：
• IS（Intent Share）：意向共享锁
• IX（Intent Exclusive）：意向排他锁
• S（Share）：表级共享锁
• X（Exclusive）：表级排他锁

行级锁模式：
• S：行级共享锁（SELECT ... FOR SHARE）
• X：行级排他锁（SELECT ... FOR UPDATE）
• S,GAP：共享间隙锁
• X,GAP：排他间隙锁
• S,REC_NOT_GAP：共享记录锁（不锁间隙）
• X,REC_NOT_GAP：排他记录锁（不锁间隙）
```

**📝 实际查询示例**
```sql
-- 查看当前所有锁信息
SELECT 
    ENGINE,
    OBJECT_SCHEMA AS `数据库`,
    OBJECT_NAME AS `表名`,
    INDEX_NAME AS `索引`,
    LOCK_TYPE AS `锁类型`,
    LOCK_MODE AS `锁模式`,
    LOCK_STATUS AS `状态`,
    LOCK_DATA AS `锁定数据`
FROM performance_schema.data_locks
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY OBJECT_SCHEMA, OBJECT_NAME;
```

### 2.2 data_lock_waits表：锁等待关系


**🔸 表的作用**
```
作用：记录锁等待的依赖关系
关键信息：谁在等待谁的锁，等待什么类型的锁

核心字段：
┌──────────────────┬─────────────────────────────┐
│ 字段名            │ 含义                         │
├──────────────────┼─────────────────────────────┤
│ REQUESTING_*     │ 请求锁的事务信息（等待方）    │
│ BLOCKING_*       │ 阻塞锁的事务信息（持有方）    │
│ ENGINE           │ 存储引擎                     │
└──────────────────┴─────────────────────────────┘
```

**📊 锁等待分析查询**
```sql
-- 分析当前锁等待情况
SELECT 
    dlw.REQUESTING_THREAD_ID AS `等待线程`,
    dlw.BLOCKING_THREAD_ID AS `阻塞线程`,
    r.OBJECT_SCHEMA AS `数据库`,
    r.OBJECT_NAME AS `表名`,
    r.LOCK_MODE AS `请求锁模式`,
    b.LOCK_MODE AS `阻塞锁模式`,
    r.LOCK_DATA AS `等待数据`,
    b.LOCK_DATA AS `阻塞数据`
FROM performance_schema.data_lock_waits dlw
JOIN performance_schema.data_locks r 
    ON dlw.REQUESTING_ENGINE_LOCK_ID = r.ENGINE_LOCK_ID
JOIN performance_schema.data_locks b 
    ON dlw.BLOCKING_ENGINE_LOCK_ID = b.ENGINE_LOCK_ID;
```

### 2.3 metadata_locks表：元数据锁


**🔸 元数据锁的重要性**
```
什么是元数据锁：
保护数据库对象结构信息的锁，防止结构变更时的并发问题

典型场景：
• ALTER TABLE时需要获取排他元数据锁
• SELECT查询时获取共享元数据锁
• DROP TABLE时需要排他元数据锁
```

**📝 监控元数据锁**
```sql
-- 查看元数据锁情况
SELECT 
    OBJECT_SCHEMA AS `数据库`,
    OBJECT_NAME AS `对象名`,
    OBJECT_TYPE AS `对象类型`,
    LOCK_TYPE AS `锁类型`,
    LOCK_STATUS AS `锁状态`,
    OWNER_THREAD_ID AS `持有线程`
FROM performance_schema.metadata_locks
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY OBJECT_SCHEMA, OBJECT_NAME;
```

---

## 3. ⚙️ 监控配置与启用


### 3.1 基础配置检查


**🔧 检查performance_schema状态**
```sql
-- 检查performance_schema是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 查看相关配置参数
SHOW VARIABLES LIKE 'performance_schema%';

重要参数说明：
• performance_schema = ON：必须启用
• performance_schema_max_table_instances：表实例数量限制
• performance_schema_max_thread_instances：线程实例数量限制
```

### 3.2 锁监控器配置


**🔸 配置监控器状态**
```sql
-- 查看锁相关监控器状态
SELECT 
    NAME AS `监控器名称`,
    ENABLED AS `是否启用`,
    TIMED AS `是否计时`
FROM performance_schema.setup_instruments 
WHERE NAME LIKE '%lock%' 
    OR NAME LIKE '%latch%'
ORDER BY NAME;
```

**📝 启用关键监控器**
```sql
-- 启用数据锁监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME = 'wait/lock/table/sql/handler';

-- 启用元数据锁监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME = 'wait/lock/metadata/sql/mdl';

-- 启用行锁监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME LIKE 'wait/lock/table/%';
```

### 3.3 消费者配置


**🔸 配置数据消费者**
```sql
-- 查看消费者状态
SELECT * FROM performance_schema.setup_consumers;

-- 启用关键消费者
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES'
WHERE NAME IN (
    'global_instrumentation',
    'thread_instrumentation', 
    'statements_digest'
);
```

---

## 4. 🔍 实际监控查询分析


### 4.1 综合锁状态分析


**📊 创建锁监控视图**
```sql
-- 创建综合锁监控视图
CREATE OR REPLACE VIEW v_lock_monitor AS
SELECT 
    dl.ENGINE AS `存储引擎`,
    dl.OBJECT_SCHEMA AS `数据库`,
    dl.OBJECT_NAME AS `表名`,
    dl.INDEX_NAME AS `索引`,
    dl.LOCK_TYPE AS `锁类型`,
    dl.LOCK_MODE AS `锁模式`,
    dl.LOCK_STATUS AS `锁状态`,
    dl.LOCK_DATA AS `锁数据`,
    t.PROCESSLIST_ID AS `连接ID`,
    t.PROCESSLIST_USER AS `用户`,
    t.PROCESSLIST_HOST AS `主机`,
    t.PROCESSLIST_DB AS `当前数据库`,
    t.PROCESSLIST_COMMAND AS `命令`,
    t.PROCESSLIST_TIME AS `执行时间`,
    t.PROCESSLIST_INFO AS `SQL语句`
FROM performance_schema.data_locks dl
LEFT JOIN performance_schema.threads t 
    ON dl.THREAD_ID = t.THREAD_ID
WHERE dl.OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY dl.OBJECT_SCHEMA, dl.OBJECT_NAME, dl.LOCK_STATUS DESC;
```

### 4.2 锁等待链分析


**🔗 识别锁等待链**
```sql
-- 分析锁等待链和阻塞关系
SELECT 
    CONCAT('等待线程:', dlw.REQUESTING_THREAD_ID, 
           ' 被线程:', dlw.BLOCKING_THREAD_ID, ' 阻塞') AS `阻塞关系`,
    req_t.PROCESSLIST_ID AS `等待连接ID`,
    req_t.PROCESSLIST_USER AS `等待用户`,
    LEFT(req_t.PROCESSLIST_INFO, 100) AS `等待SQL`,
    blk_t.PROCESSLIST_ID AS `阻塞连接ID`, 
    blk_t.PROCESSLIST_USER AS `阻塞用户`,
    LEFT(blk_t.PROCESSLIST_INFO, 100) AS `阻塞SQL`,
    r.OBJECT_NAME AS `表名`,
    r.LOCK_MODE AS `请求锁模式`,
    b.LOCK_MODE AS `持有锁模式`
FROM performance_schema.data_lock_waits dlw
JOIN performance_schema.data_locks r 
    ON dlw.REQUESTING_ENGINE_LOCK_ID = r.ENGINE_LOCK_ID
JOIN performance_schema.data_locks b 
    ON dlw.BLOCKING_ENGINE_LOCK_ID = b.ENGINE_LOCK_ID  
LEFT JOIN performance_schema.threads req_t
    ON dlw.REQUESTING_THREAD_ID = req_t.THREAD_ID
LEFT JOIN performance_schema.threads blk_t
    ON dlw.BLOCKING_THREAD_ID = blk_t.THREAD_ID;
```

### 4.3 表级锁统计分析


**📈 表锁使用统计**
```sql
-- 统计各表的锁使用情况
SELECT 
    OBJECT_SCHEMA AS `数据库`,
    OBJECT_NAME AS `表名`,
    COUNT(*) AS `总锁数`,
    SUM(CASE WHEN LOCK_STATUS = 'GRANTED' THEN 1 ELSE 0 END) AS `已获得锁`,
    SUM(CASE WHEN LOCK_STATUS = 'WAITING' THEN 1 ELSE 0 END) AS `等待锁`,
    SUM(CASE WHEN LOCK_TYPE = 'TABLE' THEN 1 ELSE 0 END) AS `表锁数`,
    SUM(CASE WHEN LOCK_TYPE = 'RECORD' THEN 1 ELSE 0 END) AS `行锁数`,
    GROUP_CONCAT(DISTINCT LOCK_MODE) AS `锁模式列表`
FROM performance_schema.data_locks
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
GROUP BY OBJECT_SCHEMA, OBJECT_NAME
ORDER BY `等待锁` DESC, `总锁数` DESC;
```

---

## 5. ⚡ 性能开销与优化


### 5.1 监控开销分析


**💰 性能开销的来源**
```
主要开销：
• 数据收集：每次锁操作都需要记录信息
• 内存占用：监控数据保存在内存中
• CPU消耗：数据收集和整理需要CPU资源
• 查询开销：监控查询本身也消耗资源

影响因素：
• 并发连接数：连接越多，监控数据越多
• 锁操作频率：锁操作越频繁，开销越大
• 启用监控器数量：监控项目越多，开销越大
• 查询复杂度：复杂查询消耗更多资源
```

**📊 开销评估查询**
```sql
-- 评估performance_schema内存使用
SELECT 
    EVENT_NAME AS `事件名称`,
    COUNT_ALLOC AS `分配次数`,
    COUNT_FREE AS `释放次数`,
    SUM_NUMBER_OF_BYTES_ALLOC AS `分配字节数`,
    SUM_NUMBER_OF_BYTES_FREE AS `释放字节数`,
    LOW_COUNT_USED AS `最少使用`,
    HIGH_COUNT_USED AS `最多使用`
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME LIKE '%performance_schema%'
ORDER BY SUM_NUMBER_OF_BYTES_ALLOC DESC;
```

### 5.2 优化策略


**🎯 监控优化建议**
```sql
-- 只监控关键数据库
SELECT 
    OBJECT_SCHEMA,
    COUNT(*) as lock_count
FROM performance_schema.data_locks
GROUP BY OBJECT_SCHEMA
ORDER BY lock_count DESC;

优化策略：
• 选择性监控：只监控重要的数据库和表
• 定时清理：定期清理历史监控数据
• 合理配置：根据实际需要配置监控器
• 分时监控：在非高峰期进行详细监控
```

**⚙️ 配置优化示例**
```sql
-- 只监控特定数据库的锁
CREATE VIEW v_business_locks AS
SELECT * FROM performance_schema.data_locks
WHERE OBJECT_SCHEMA IN ('order_db', 'user_db', 'product_db');

-- 定期清理监控数据的存储过程
DELIMITER //
CREATE PROCEDURE sp_cleanup_lock_monitoring()
BEGIN
    -- 这里可以添加清理逻辑
    -- performance_schema数据在重启后自动清空
    -- 可以考虑导出重要数据到历史表
    SELECT '监控数据清理完成' AS result;
END //
DELIMITER ;
```

---

## 6. 🛠️ 问题定位最佳实践


### 6.1 常见锁问题诊断


**🚨 死锁问题分析**
```sql
-- 检查最近的死锁信息
SHOW ENGINE INNODB STATUS;

-- 结合performance_schema分析死锁模式
-- 查找频繁冲突的表和索引
SELECT 
    OBJECT_NAME AS `表名`,
    INDEX_NAME AS `索引`,
    COUNT(*) AS `冲突次数`,
    GROUP_CONCAT(DISTINCT LOCK_MODE) AS `冲突锁模式`
FROM performance_schema.data_locks
WHERE LOCK_STATUS = 'WAITING'
    AND OBJECT_SCHEMA = 'your_database'
GROUP BY OBJECT_NAME, INDEX_NAME
ORDER BY `冲突次数` DESC;
```

**⏱️ 长时间锁等待分析**
```sql
-- 找出长时间等待的锁
SELECT 
    r.OBJECT_NAME AS `表名`,
    r.LOCK_MODE AS `等待锁模式`,
    r.LOCK_DATA AS `等待数据`,
    req_t.PROCESSLIST_TIME AS `等待时间秒`,
    req_t.PROCESSLIST_INFO AS `等待SQL`,
    blk_t.PROCESSLIST_INFO AS `阻塞SQL`
FROM performance_schema.data_lock_waits dlw
JOIN performance_schema.data_locks r 
    ON dlw.REQUESTING_ENGINE_LOCK_ID = r.ENGINE_LOCK_ID
JOIN performance_schema.data_locks b 
    ON dlw.BLOCKING_ENGINE_LOCK_ID = b.ENGINE_LOCK_ID
JOIN performance_schema.threads req_t
    ON dlw.REQUESTING_THREAD_ID = req_t.THREAD_ID
JOIN performance_schema.threads blk_t
    ON dlw.BLOCKING_THREAD_ID = blk_t.THREAD_ID
WHERE req_t.PROCESSLIST_TIME > 10  -- 等待超过10秒
ORDER BY req_t.PROCESSLIST_TIME DESC;
```

### 6.2 监控告警设置


**📢 创建监控告警**
```sql
-- 创建锁监控告警存储过程
DELIMITER //
CREATE PROCEDURE sp_lock_alert_check()
BEGIN
    DECLARE lock_wait_count INT DEFAULT 0;
    DECLARE long_wait_count INT DEFAULT 0;
    
    -- 检查锁等待数量
    SELECT COUNT(*) INTO lock_wait_count
    FROM performance_schema.data_lock_waits;
    
    -- 检查长时间等待
    SELECT COUNT(*) INTO long_wait_count
    FROM performance_schema.data_lock_waits dlw
    JOIN performance_schema.threads t
        ON dlw.REQUESTING_THREAD_ID = t.THREAD_ID
    WHERE t.PROCESSLIST_TIME > 30;
    
    -- 输出告警信息
    IF lock_wait_count > 10 THEN
        SELECT CONCAT('告警：当前锁等待数量过多，共', lock_wait_count, '个') AS alert_message;
    END IF;
    
    IF long_wait_count > 0 THEN
        SELECT CONCAT('告警：存在长时间锁等待，共', long_wait_count, '个') AS alert_message;
    END IF;
    
END //
DELIMITER ;

-- 设置定时执行（需要配合cron或其他调度工具）
-- CALL sp_lock_alert_check();
```

### 6.3 问题处理流程


**🔄 标准处理流程**
```
步骤1：快速识别问题
┌─────────────────┐
│  检查锁等待数量  │ → 确定问题严重程度
└─────────────────┘

步骤2：分析锁冲突
┌─────────────────┐
│  查看等待关系    │ → 找出阻塞源头
└─────────────────┘

步骤3：定位具体原因  
┌─────────────────┐
│  分析SQL语句    │ → 优化查询或事务
└─────────────────┘

步骤4：采取解决措施
┌─────────────────┐
│  终止或优化     │ → 恢复正常运行
└─────────────────┘
```

**🛠️ 应急处理工具**
```sql
-- 紧急情况下终止长时间等待的连接
-- 注意：使用前请确认影响范围
SELECT 
    CONCAT('KILL ', t.PROCESSLIST_ID, ';') AS `终止命令`,
    t.PROCESSLIST_TIME AS `等待时间`,
    t.PROCESSLIST_INFO AS `SQL语句`
FROM performance_schema.data_lock_waits dlw
JOIN performance_schema.threads t
    ON dlw.REQUESTING_THREAD_ID = t.THREAD_ID
WHERE t.PROCESSLIST_TIME > 60  -- 等待超过1分钟
ORDER BY t.PROCESSLIST_TIME DESC;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 performance_schema本质：MySQL的实时性能监控引擎
🔸 三大核心表：data_locks（锁状态）、data_lock_waits（等待关系）、metadata_locks（元数据锁）
🔸 监控配置：需要正确配置监控器和消费者
🔸 性能平衡：监控功能与系统开销之间的权衡
🔸 问题诊断：通过锁监控快速定位并发问题
```

### 7.2 关键理解要点


**🔹 监控数据的含义**
```
锁状态理解：
• GRANTED：已经获得锁，正在使用
• WAITING：等待获取锁，被其他事务阻塞

锁类型区分：
• TABLE：表级锁，影响整个表
• RECORD：行级锁，只影响特定行

锁模式解读：
• S/IS：共享类型，多个事务可以同时持有
• X/IX：排他类型，同时只能有一个事务持有
```

**🔹 监控的实际价值**
```
日常运维：
• 及时发现锁竞争热点
• 快速定位性能瓶颈
• 预防死锁问题发生

问题排查：
• 准确找到阻塞源头
• 分析锁等待链条
• 为优化提供数据支持
```

### 7.3 实际应用指导


**🎯 监控策略建议**
- **分层监控**：根据业务重要性设置不同监控级别
- **定时检查**：建立定期的锁状态检查机制  
- **告警机制**：设置合理的告警阈值和通知方式
- **性能权衡**：在监控完整性和系统性能间找平衡

**🔧 优化实践**
- **索引优化**：通过监控发现索引使用问题
- **事务优化**：减少事务持有锁的时间
- **SQL优化**：避免不必要的锁竞争
- **架构优化**：通过读写分离等减少锁冲突

### 7.4 注意事项


**⚠️ 使用限制**
```
数据特点：
• 内存存储：重启后数据丢失
• 实时性：只能看到当前状态，无历史数据
• 开销考量：监控本身会消耗系统资源

使用建议：
• 不要在生产环境过度监控
• 重要数据及时导出保存
• 结合其他监控工具使用
• 定期评估监控效果和开销
```

**核心记忆**：
- performance_schema是锁监控的利器，三大核心表提供全面锁信息
- 合理配置监控器，平衡监控需求和性能开销  
- 掌握锁状态分析方法，快速定位并发问题根源
- 建立标准监控流程，提高问题处理效率