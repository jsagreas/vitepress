---
title: 46、分布式锁实现
---
## 📚 目录

1. [分布式锁基础概念](#1-分布式锁基础概念)
2. [分布式锁需求场景](#2-分布式锁需求场景)
3. [MySQL分布式锁实现](#3-mysql分布式锁实现)
4. [Redis分布式锁实现](#4-redis分布式锁实现)
5. [ZooKeeper分布式锁](#5-zookeeper分布式锁)
6. [方案对比与选择](#6-方案对比与选择)
7. [故障处理与最佳实践](#7-故障处理与最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 分布式锁基础概念


### 1.1 什么是分布式锁


**简单理解**：分布式锁就像是**多个房间共享一把钥匙**

```
单机环境（一个房间）：
线程A  线程B  线程C
  |      |      |
  ↓      ↓      ↓
   共享资源（一把锁保护）

分布式环境（多个房间）：
机器A    机器B    机器C
线程1    线程2    线程3
  |        |        |
  ↓        ↓        ↓
    共享资源（需要全局锁）
```

### 1.2 分布式锁的本质


**核心问题**：在分布式系统中，如何保证同一时刻只有一个进程能执行特定操作？

::: tip 💡 生活类比
就像多个人要使用同一台打印机：
- **单机情况**：办公室里的人排队使用
- **分布式情况**：不同楼层的人都想用，需要一个全楼通用的"使用权限牌"
:::

**分布式锁的特征**：
- ✅ **互斥性**：同一时刻只有一个客户端能持有锁
- ✅ **防死锁**：即使持有锁的进程崩溃，锁也能被释放
- ✅ **容错性**：少数节点挂掉不影响锁服务
- ✅ **一致性**：在分布式环境下锁的状态保持一致

### 1.3 为什么需要分布式锁


**传统锁的局限**：
```java
// 这种锁只能在单个JVM内生效
synchronized (this) {
    // 修改共享资源
    count++;
}
```

**分布式场景的问题**：
```
服务器A: count = 100, 执行 count++
服务器B: count = 100, 执行 count++  
结果: count = 101 (期望是102)

原因：两台服务器的锁互不影响！
```

---

## 2. 🎯 分布式锁需求场景


### 2.1 典型应用场景


**🛒 电商秒杀场景**
```
问题描述：
商品库存 100 件
用户并发下单 1000 人
多台服务器同时处理请求

没有分布式锁的后果：
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 服务器A  │  │ 服务器B  │  │ 服务器C  │
│ 读库存:100│  │ 读库存:100│  │ 读库存:100│
│ 卖出:50  │  │ 卖出:30  │  │ 卖出:40  │
│ 库存:50  │  │ 库存:70  │  │ 库存:60  │
└─────────┘  └─────────┘  └─────────┘
最终库存可能是50、60、或70，数据不一致！
```

**📊 分布式任务调度**
```
定时任务：每天凌晨2点数据统计
集群部署：3台服务器都有这个定时任务

问题：没有分布式锁会导致重复执行
┌─────────────────────────────────┐
│ 02:00:00 服务器A开始执行         │
│ 02:00:01 服务器B也开始执行       │  ← 重复了！
│ 02:00:02 服务器C也开始执行       │  ← 重复了！
└─────────────────────────────────┘
```

**💳 分布式ID生成**
```
需求：全局唯一的订单号生成
方案：时间戳 + 机器ID + 序列号

没有锁的问题：
机器A: 20231201120001001
机器B: 20231201120001001  ← ID重复了！
```

### 2.2 核心需求分析


| 场景类型 | **主要需求** | **性能要求** | **一致性要求** |
|---------|-------------|-------------|---------------|
| 🛒 **电商秒杀** | 库存准确性 | 极高 | 强一致性 |
| 📊 **定时任务** | 避免重复执行 | 中等 | 最终一致性 |
| 💰 **资金操作** | 绝对准确 | 中等 | 强一致性 |
| 📝 **缓存更新** | 避免并发更新 | 高 | 弱一致性 |

---

## 3. 💾 MySQL分布式锁实现


### 3.1 基于唯一索引的实现


**实现原理**：利用数据库**唯一约束**特性

```sql
-- 创建锁表
CREATE TABLE distributed_lock (
    lock_name VARCHAR(64) NOT NULL COMMENT '锁名称',
    lock_holder VARCHAR(64) NOT NULL COMMENT '持有者标识', 
    expire_time TIMESTAMP NOT NULL COMMENT '过期时间',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (lock_name)
) ENGINE=InnoDB;
```

**🔒 获取锁的逻辑**：
```java
public class MySQLDistributedLock {
    
    /**
     * 尝试获取锁
     * @param lockName 锁名称
     * @param holder 持有者标识（通常是机器IP+进程ID）
     * @param expireSeconds 锁过期时间（秒）
     * @return 是否成功获取锁
     */
    public boolean tryLock(String lockName, String holder, int expireSeconds) {
        String sql = """
            INSERT INTO distributed_lock (lock_name, lock_holder, expire_time) 
            VALUES (?, ?, DATE_ADD(NOW(), INTERVAL ? SECOND))
            """;
        
        try {
            int rows = jdbcTemplate.update(sql, lockName, holder, expireSeconds);
            return rows == 1; // 插入成功表示获得锁
        } catch (DuplicateKeyException e) {
            // 主键重复，说明锁已被其他进程持有
            return false;
        }
    }
}
```

### 3.2 锁的释放与续期


**🔓 释放锁**：
```java
public boolean releaseLock(String lockName, String holder) {
    String sql = """
        DELETE FROM distributed_lock 
        WHERE lock_name = ? AND lock_holder = ?
        """;
    
    int rows = jdbcTemplate.update(sql, lockName, holder);
    return rows == 1;
}
```

**⏰ 自动清理过期锁**：
```java
@Scheduled(fixedDelay = 30000) // 每30秒执行一次
public void cleanExpiredLocks() {
    String sql = "DELETE FROM distributed_lock WHERE expire_time < NOW()";
    int cleaned = jdbcTemplate.update(sql);
    if (cleaned > 0) {
        log.info("清理过期锁数量: {}", cleaned);
    }
}
```

### 3.3 完整的使用示例


```java
@Service
public class OrderService {
    
    @Autowired
    private MySQLDistributedLock distributedLock;
    
    /**
     * 秒杀商品扣库存
     */
    public boolean seckillProduct(Long productId, String userId) {
        String lockName = "seckill_product_" + productId;
        String holder = getLocalHostAddress() + "_" + Thread.currentThread().getId();
        
        // 尝试获取锁，5秒过期
        boolean lockAcquired = distributedLock.tryLock(lockName, holder, 5);
        
        if (!lockAcquired) {
            return false; // 获取锁失败，说明有其他请求在处理
        }
        
        try {
            // 执行秒杀逻辑
            return doSeckill(productId, userId);
        } finally {
            // 确保释放锁
            distributedLock.releaseLock(lockName, holder);
        }
    }
    
    private boolean doSeckill(Long productId, String userId) {
        // 1. 查询库存
        int stock = productMapper.getStock(productId);
        if (stock <= 0) {
            return false;
        }
        
        // 2. 扣减库存
        productMapper.decreaseStock(productId, 1);
        
        // 3. 创建订单
        orderMapper.createOrder(productId, userId);
        
        return true;
    }
}
```

### 3.4 MySQL方案的优缺点


::: tip ✅ 优点
- **简单易懂**：基于熟悉的数据库操作
- **强一致性**：利用数据库ACID特性
- **持久化**：锁状态持久存储，服务重启不丢失
- **可观测**：可以直接查询锁状态
:::

::: warning ⚠️ 缺点
- **性能较低**：每次加锁都是数据库操作
- **单点故障**：数据库挂了，锁服务不可用
- **锁粒度粗**：基于表级别的操作
- **清理复杂**：需要定时任务清理过期锁
:::

---

## 4. 🔴 Redis分布式锁实现


### 4.1 基本SETNX实现


**实现原理**：利用Redis的`SETNX`命令（SET if Not eXists）

```java
@Component
public class RedisDistributedLock {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * 尝试获取锁（基础版本）
     */
    public boolean tryLock(String lockKey, String requestId, int expireTime) {
        // SETNX + EXPIRE 组合（非原子性，有问题！）
        Boolean result = redisTemplate.opsForValue().setIfAbsent(lockKey, requestId);
        if (Boolean.TRUE.equals(result)) {
            // 设置过期时间
            redisTemplate.expire(lockKey, expireTime, TimeUnit.SECONDS);
            return true;
        }
        return false;
    }
}
```

**❌ 上述实现的问题**：
```
时间线问题：
T1: SETNX成功获得锁
T2: 准备设置过期时间
T3: 进程崩溃，过期时间没设置上
结果: 死锁！锁永远不会过期
```

### 4.2 正确的原子性实现


**使用SET命令的EX和NX参数**：
```java
public boolean tryLock(String lockKey, String requestId, int expireTime) {
    // 原子性操作：SET key value EX seconds NX
    String result = redisTemplate.execute(
        (RedisCallback<String>) connection -> {
            return connection.set(
                lockKey.getBytes(),
                requestId.getBytes(), 
                Expiration.seconds(expireTime),
                RedisStringCommands.SetOption.SET_IF_ABSENT
            );
        }
    );
    
    return "OK".equals(result);
}
```

**使用Lua脚本确保原子性**：
```java
public class RedisDistributedLock {
    
    // 获取锁的Lua脚本
    private static final String LOCK_LUA_SCRIPT = """
        if redis.call('SET', KEYS[1], ARGV[1], 'EX', ARGV[2], 'NX') then
            return 1
        else
            return 0
        end
        """;
    
    // 释放锁的Lua脚本
    private static final String UNLOCK_LUA_SCRIPT = """
        if redis.call('GET', KEYS[1]) == ARGV[1] then
            return redis.call('DEL', KEYS[1])
        else
            return 0
        end
        """;
    
    public boolean tryLock(String lockKey, String requestId, int expireTime) {
        Long result = redisTemplate.execute(
            RedisScript.of(LOCK_LUA_SCRIPT, Long.class),
            Collections.singletonList(lockKey),
            requestId,
            String.valueOf(expireTime)
        );
        
        return Long.valueOf(1).equals(result);
    }
    
    public boolean releaseLock(String lockKey, String requestId) {
        Long result = redisTemplate.execute(
            RedisScript.of(UNLOCK_LUA_SCRIPT, Long.class),
            Collections.singletonList(lockKey),
            requestId
        );
        
        return Long.valueOf(1).equals(result);
    }
}
```

### 4.3 自动续期机制


**问题场景**：业务执行时间可能超过锁的过期时间

```java
public class RedisLockWithRenewal {
    
    private final ScheduledExecutorService renewalExecutor = 
        Executors.newScheduledThreadPool(1);
    
    public boolean tryLockWithRenewal(String lockKey, String requestId, int expireTime) {
        boolean locked = tryLock(lockKey, requestId, expireTime);
        
        if (locked) {
            // 启动续期任务，每1/3过期时间续期一次
            scheduleRenewal(lockKey, requestId, expireTime);
        }
        
        return locked;
    }
    
    private void scheduleRenewal(String lockKey, String requestId, int expireTime) {
        renewalExecutor.scheduleAtFixedRate(
            () -> renewLock(lockKey, requestId, expireTime),
            expireTime / 3, // 初始延迟
            expireTime / 3, // 续期间隔
            TimeUnit.SECONDS
        );
    }
    
    private void renewLock(String lockKey, String requestId, int expireTime) {
        String renewScript = """
            if redis.call('GET', KEYS[1]) == ARGV[1] then
                return redis.call('EXPIRE', KEYS[1], ARGV[2])
            else
                return 0
            end
            """;
            
        redisTemplate.execute(
            RedisScript.of(renewScript, Long.class),
            Collections.singletonList(lockKey),
            requestId,
            String.valueOf(expireTime)
        );
    }
}
```

### 4.4 实际使用示例


```java
@Service
public class ProductService {
    
    @Autowired
    private RedisDistributedLock redisLock;
    
    public void updateProductInfo(Long productId, ProductInfo info) {
        String lockKey = "product_update_" + productId;
        String requestId = UUID.randomUUID().toString();
        
        try {
            // 尝试获取锁，30秒过期
            if (redisLock.tryLock(lockKey, requestId, 30)) {
                // 执行更新逻辑
                doUpdateProduct(productId, info);
            } else {
                throw new BusinessException("系统繁忙，请稍后重试");
            }
        } finally {
            redisLock.releaseLock(lockKey, requestId);
        }
    }
}
```

---

## 5. 🦓 ZooKeeper分布式锁


### 5.1 ZooKeeper锁的原理


**基本概念**：ZooKeeper是一个分布式协调服务

```
ZooKeeper节点结构：
/locks
  ├── /order-lock-0000000001  ← 临时顺序节点
  ├── /order-lock-0000000002  ← 临时顺序节点  
  ├── /order-lock-0000000003  ← 临时顺序节点
  └── ...

获锁规则：序号最小的节点获得锁
```

**🔐 加锁流程**：
```
客户端A                    ZooKeeper集群                客户端B
   |                           |                         |
   |-- 创建临时顺序节点 ------->|                         |
   |                           |<------ 创建节点 ---------|
   |<-- 返回节点路径 ----------|                         |
   |                           |-- 返回节点路径 --------->|
   |                           |                         |
   |-- 获取所有子节点 --------->|                         |
   |<-- 返回节点列表 ----------|                         |
   |                           |                         |
判断自己是否最小             判断自己不是最小
获得锁                     监听前一个节点
```

### 5.2 Java实现示例


```java
public class ZKDistributedLock {
    
    private ZooKeeper zooKeeper;
    private String lockPath;
    private String currentPath;
    private CountDownLatch connectedLatch = new CountDownLatch(1);
    private CountDownLatch lockLatch = new CountDownLatch(1);
    
    public ZKDistributedLock(String connectString, String lockPath) {
        this.lockPath = lockPath;
        try {
            // 连接ZooKeeper
            zooKeeper = new ZooKeeper(connectString, 5000, event -> {
                if (event.getState() == Event.KeeperState.SyncConnected) {
                    connectedLatch.countDown();
                }
            });
            
            connectedLatch.await();
            
            // 创建根节点
            if (zooKeeper.exists(lockPath, false) == null) {
                zooKeeper.create(lockPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                    CreateMode.PERSISTENT);
            }
        } catch (Exception e) {
            throw new RuntimeException("初始化ZK锁失败", e);
        }
    }
    
    /**
     * 获取锁
     */
    public void lock() throws Exception {
        // 1. 创建临时顺序节点
        currentPath = zooKeeper.create(
            lockPath + "/lock-", 
            null,
            ZooDefs.Ids.OPEN_ACL_UNSAFE,
            CreateMode.EPHEMERAL_SEQUENTIAL
        );
        
        // 2. 判断是否获得锁
        if (checkLock()) {
            return; // 获得锁
        } else {
            // 3. 没获得锁，等待
            lockLatch.await();
        }
    }
    
    /**
     * 检查是否获得锁
     */
    private boolean checkLock() throws Exception {
        // 获取所有子节点
        List<String> children = zooKeeper.getChildren(lockPath, false);
        Collections.sort(children);
        
        String currentNode = currentPath.substring(lockPath.length() + 1);
        int index = children.indexOf(currentNode);
        
        if (index == 0) {
            // 当前节点是最小的，获得锁
            return true;
        } else {
            // 监听前一个节点
            String prevNode = children.get(index - 1);
            zooKeeper.exists(lockPath + "/" + prevNode, event -> {
                if (event.getType() == Event.EventType.NodeDeleted) {
                    lockLatch.countDown();
                }
            });
            
            return false;
        }
    }
    
    /**
     * 释放锁
     */
    public void unlock() throws Exception {
        if (currentPath != null) {
            zooKeeper.delete(currentPath, -1);
            currentPath = null;
        }
    }
}
```

### 5.3 使用示例


```java
@Service
public class TaskService {
    
    public void executeOnlyOnce(String taskId) {
        ZKDistributedLock lock = new ZKDistributedLock(
            "localhost:2181", 
            "/distributed-locks"
        );
        
        try {
            lock.lock();
            
            // 执行业务逻辑
            System.out.println("开始执行任务: " + taskId);
            Thread.sleep(5000); // 模拟任务执行
            System.out.println("任务执行完成: " + taskId);
            
        } catch (Exception e) {
            log.error("任务执行失败", e);
        } finally {
            try {
                lock.unlock();
            } catch (Exception e) {
                log.error("释放锁失败", e);
            }
        }
    }
}
```

---

## 6. ⚖️ 方案对比与选择


### 6.1 性能对比分析


| 锁方案 | **TPS** | **延迟** | **内存占用** | **CPU占用** |
|-------|---------|---------|-------------|-------------|
| **MySQL** | ~1000 | 10-50ms | 低 | 中 |
| **Redis** | ~10000 | 1-5ms | 中 | 低 |
| **ZooKeeper** | ~3000 | 5-20ms | 高 | 中 |

### 6.2 一致性与可用性权衡


```
CAP理论在分布式锁中的体现：

MySQL方案：
├── 一致性：强（ACID保证）
├── 可用性：中（单点故障）
└── 分区容错：弱（依赖网络）

Redis方案：
├── 一致性：最终（异步复制）
├── 可用性：高（主从切换）
└── 分区容错：强（集群模式）

ZooKeeper方案：
├── 一致性：强（ZAB协议）
├── 可用性：高（集群容错）
└── 分区容错：强（过半机制）
```

### 6.3 选择建议


::: tip 💡 选择指南

**选MySQL的场景**：
- ✅ 对一致性要求极高（金融场景）
- ✅ 团队对数据库运维成熟
- ✅ 锁竞争不激烈
- ✅ 已有MySQL基础设施

**选Redis的场景**：
- ✅ 高并发场景（秒杀、抢购）
- ✅ 对性能要求高
- ✅ 可接受最终一致性
- ✅ 已有Redis集群

**选ZooKeeper的场景**：
- ✅ 需要强一致性
- ✅ 节点管理复杂
- ✅ 配置管理需求
- ✅ 分布式协调场景多
:::

---

## 7. 🛠️ 故障处理与最佳实践


### 7.1 死锁问题处理


**死锁场景1：进程崩溃未释放锁**
```java
public class LockTimeoutHandler {
    
    /**
     * 带超时的锁获取
     */
    public boolean tryLockWithTimeout(String lockKey, String requestId, 
                                     int expireTime, int timeoutSeconds) {
        long startTime = System.currentTimeMillis();
        long timeout = timeoutSeconds * 1000L;
        
        while (System.currentTimeMillis() - startTime < timeout) {
            if (tryLock(lockKey, requestId, expireTime)) {
                return true;
            }
            
            try {
                Thread.sleep(100); // 短暂等待后重试
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }
        
        return false; // 超时未获得锁
    }
}
```

**死锁场景2：锁租约续期失败**
```java
@Component  
public class LockHealthChecker {
    
    @Scheduled(fixedDelay = 10000) // 每10秒检查一次
    public void checkLockHealth() {
        // 检查持有的锁是否还有效
        for (String lockKey : heldLocks.keySet()) {
            if (!isLockValid(lockKey)) {
                // 锁失效，清理本地状态
                heldLocks.remove(lockKey);
                log.warn("检测到锁失效: {}", lockKey);
            }
        }
    }
    
    private boolean isLockValid(String lockKey) {
        // 检查锁是否仍然存在且属于当前进程
        String holder = redisTemplate.opsForValue().get(lockKey);
        return Objects.equals(holder, getCurrentRequestId());
    }
}
```

### 7.2 锁超时处理策略


**业务超时vs锁超时**：
```java
public class SmartLockManager {
    
    public <T> T executeWithLock(String lockKey, int lockTimeout, 
                                int businessTimeout, Supplier<T> business) {
        
        String requestId = UUID.randomUUID().toString();
        
        // 确保锁超时 > 业务超时
        if (lockTimeout <= businessTimeout) {
            lockTimeout = businessTimeout + 10; // 额外10秒缓冲
        }
        
        if (!tryLock(lockKey, requestId, lockTimeout)) {
            throw new BusinessException("获取锁超时");
        }
        
        try {
            // 使用CompletableFuture控制业务执行超时
            return CompletableFuture.supplyAsync(business)
                    .get(businessTimeout, TimeUnit.SECONDS);
                    
        } catch (TimeoutException e) {
            // 业务执行超时，但锁还在，安全释放
            log.warn("业务执行超时，锁仍有效: {}", lockKey);
            throw new BusinessException("业务执行超时");
        } finally {
            releaseLock(lockKey, requestId);
        }
    }
}
```

### 7.3 最佳实践总结


**🔸 锁的粒度设计**
```java
// ❌ 锁粒度太粗
public void updateUser(Long userId) {
    lock("user_update"); // 所有用户更新都被阻塞
    // ...
}

// ✅ 锁粒度合适
public void updateUser(Long userId) {
    lock("user_update_" + userId); // 只锁定特定用户
    // ...
}
```

**🔸 异常处理与资源清理**
```java
public class RobustLockOperation {
    
    public void safeOperation(String lockKey) {
        String requestId = null;
        boolean lockAcquired = false;
        
        try {
            requestId = generateRequestId();
            lockAcquired = tryLock(lockKey, requestId, 30);
            
            if (!lockAcquired) {
                throw new BusinessException("获取锁失败");
            }
            
            // 执行业务逻辑
            doBusiness();
            
        } catch (Exception e) {
            log.error("业务执行失败", e);
            // 根据业务需要决定是否重试
            handleBusinessException(e);
        } finally {
            // 确保锁被释放
            if (lockAcquired && requestId != null) {
                try {
                    releaseLock(lockKey, requestId);
                } catch (Exception e) {
                    log.error("释放锁失败: {}", lockKey, e);
                }
            }
        }
    }
}
```

**🔸 监控与告警**
```java
@Component
public class LockMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public boolean tryLockWithMetrics(String lockKey, String requestId, int expireTime) {
        Timer.Sample sample = Timer.start(meterRegistry);
        boolean success = false;
        
        try {
            success = doTryLock(lockKey, requestId, expireTime);
            return success;
        } finally {
            sample.stop(Timer.builder("distributed_lock_acquire")
                    .tag("key", lockKey)
                    .tag("success", String.valueOf(success))
                    .register(meterRegistry));
        }
    }
    
    @EventListener
    public void handleLockTimeout(LockTimeoutEvent event) {
        // 发送告警
        alertService.sendAlert("分布式锁超时", 
            "锁Key: " + event.getLockKey() + ", 超时时间: " + event.getTimeout());
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 分布式锁本质：在分布式环境中实现互斥访问的协调机制
🔸 三种主流方案：MySQL（基于数据库）、Redis（基于缓存）、ZooKeeper（基于协调服务）
🔸 核心特性：互斥性、防死锁、容错性、一致性保证
🔸 实现要点：原子操作、超时机制、异常处理、监控告警
```

### 8.2 关键理解要点


**🔹 方案选择的权衡**
```
性能要求：Redis > ZooKeeper > MySQL
一致性要求：ZooKeeper ≈ MySQL > Redis  
运维复杂度：MySQL < Redis < ZooKeeper
开发复杂度：MySQL < Redis < ZooKeeper
```

**🔹 常见问题的解决思路**
```
死锁问题 → 设置合理超时时间 + 异常清理机制
性能问题 → 优化锁粒度 + 选择高性能方案  
一致性问题 → 选择强一致性方案 + 完善的冲突处理
可用性问题 → 集群部署 + 故障转移机制
```

**🔹 实际应用的注意事项**
```
锁粒度：细粒度减少竞争，粗粒度简化逻辑
超时设置：锁超时 > 业务超时 + 缓冲时间  
异常处理：确保锁能被释放，避免死锁
监控告警：跟踪锁的获取成功率和执行时间
```

### 8.3 实际应用指导


**📊 场景选型指导**
- **高并发秒杀**：选Redis，注重性能和吞吐量
- **资金转账**：选MySQL或ZooKeeper，注重一致性
- **定时任务**：选ZooKeeper，注重协调和管理
- **缓存更新**：选Redis，注重简单和高效

**🛠️ 开发最佳实践**
- 总是在finally块中释放锁
- 设置合理的锁超时时间
- 使用唯一的请求ID标识锁持有者
- 添加完善的监控和日志
- 考虑业务的幂等性设计

**💡 核心记忆口诀**：
- 分布式锁解决并发，三大方案各有专长
- MySQL稳定一致强，Redis高效性能棒  
- ZooKeeper协调好，选择方案看需要
- 超时异常要处理，监控告警不能少