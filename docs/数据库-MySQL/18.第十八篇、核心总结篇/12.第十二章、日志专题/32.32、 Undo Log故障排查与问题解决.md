---
title: 32、 Undo Log故障排查与问题解决
---
## 📚 目录

1. [Undo Log常见故障概览](#1-undo-log常见故障概览)
2. [Undo Log空间耗尽问题](#2-undo-log空间耗尽问题)
3. [History List过长问题](#3-history-list过长问题)
4. [Purge线程停滞问题](#4-purge线程停滞问题)
5. [长事务导致的问题](#5-长事务导致的问题)
6. [Undo Log损坏检测与修复](#6-undo-log损坏检测与修复)
7. [事务回滚异常处理](#7-事务回滚异常处理)
8. [MVCC读取异常排查](#8-mvcc读取异常排查)
9. [应急处理方案](#9-应急处理方案)
10. [故障预防措施](#10-故障预防措施)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🚨 Undo Log常见故障概览


### 1.1 什么是Undo Log故障

**简单理解**：就像你的"后悔药"出了问题，要么吃不到，要么药效不好，要么药箱塞满了。

```
现实类比：
Undo Log = 银行的交易撤销记录
- 空间耗尽 = 记录本写满了
- History List过长 = 待处理的撤销单太多
- Purge停滞 = 清理工作停止了
- 长事务问题 = 某笔交易一直不结束
```

### 1.2 故障分类与影响


**🔸 按严重程度分类**
```
🔴 严重故障（影响业务）：
• Undo Log空间耗尽 → 新事务无法启动
• 事务回滚失败 → 数据不一致
• Undo Log损坏 → 数据库崩溃

🟡 性能故障（影响效率）：
• History List过长 → 查询变慢
• Purge线程停滞 → 空间不释放
• 长事务堆积 → 并发性下降

🟢 轻微故障（需要关注）：
• MVCC读取异常 → 偶发查询错误
• Undo表空间碎片 → 空间利用率低
```

### 1.3 故障排查思路图


```
故障发现
    ↓
快速定位故障类型
    ↓
┌─────────────┬─────────────┬─────────────┐
│ 空间类问题   │ 性能类问题   │ 数据类问题   │
└─────────────┴─────────────┴─────────────┘
    ↓              ↓              ↓
查看空间使用     分析History List  检查数据一致性
    ↓              ↓              ↓
处理方案选择     优化配置参数     修复或恢复
    ↓              ↓              ↓
应急处理 → 根本原因分析 → 预防措施
```

---

## 2. 💾 Undo Log空间耗尽问题


### 2.1 问题表现与识别


**🔸 典型症状**
```sql
-- 错误信息示例
ERROR 1114 (HY000): The table 'tablename' is full
ERROR 1712 (HY000): Undo log record is too big

-- 空间使用检查
SELECT 
    tablespace_name,
    file_name,
    ROUND(total_size/1024/1024/1024, 2) AS total_gb,
    ROUND(data_free/1024/1024/1024, 2) AS free_gb,
    ROUND((total_size-data_free)/total_size*100, 2) AS used_percent
FROM information_schema.FILES 
WHERE tablespace_name LIKE 'innodb_undo_%';
```

**💡 生活类比**
```
就像手机存储空间不足：
- 症状：无法安装新APP（无法创建新事务）
- 原因：垃圾文件太多（历史版本未清理）
- 解决：清理垃圾+扩容（清理Undo+增加空间）
```

### 2.2 快速诊断方法


**📊 检查Undo表空间使用情况**
```sql
-- 查看Undo表空间状态
SHOW ENGINE INNODB STATUS\G

-- 关注这些关键信息：
/*
TRANSACTIONS
------------
Trx id counter 123456
Purge done for trx's n:o < 123400 undo n:o < 0
History list length 1000  ← 关键指标
*/

-- 查看具体的Undo表空间
SELECT 
    space_name,
    space_type,
    state,
    ROUND(total_size/1024/1024, 2) AS size_mb
FROM information_schema.INNODB_TABLESPACES 
WHERE space_name LIKE 'innodb_undo_%';
```

### 2.3 解决方案


**🔧 紧急处理步骤**
```sql
-- 步骤1：释放已提交事务的Undo记录
SET GLOBAL innodb_purge_threads = 4;
SET GLOBAL innodb_max_purge_lag = 0;

-- 步骤2：强制触发Purge操作
-- 等待一段时间让Purge线程工作

-- 步骤3：增加Undo表空间（如果需要）
ALTER UNDO TABLESPACE innodb_undo_001 SET INACTIVE;
-- 等待状态变为empty后
DROP UNDO TABLESPACE innodb_undo_001;
CREATE UNDO TABLESPACE innodb_undo_001 
ADD DATAFILE 'undo_001.ibu' ENGINE=InnoDB;
```

**📌 重要提醒**
> **⚠️ 注意事项**：
> - 不要在高峰期进行Undo表空间操作
> - 操作前一定要备份
> - 确保有足够的磁盘空间

---

## 3. 📈 History List过长问题


### 3.1 什么是History List


**🔸 概念解释**
History List就像银行的"待处理撤销单队列"：
- 每个已提交但未清理的事务都在队列里
- 队列越长，查找历史版本越慢
- 正常情况下应该很短（<1000）

```
History List示意图：
已提交事务：[事务1] → [事务2] → [事务3] → ... → [事务N]
           旧 ←────────────────────────────────→ 新
           
队列长度：N个事务等待Purge清理
影响：读取历史版本需要遍历更多记录
```

### 3.2 问题诊断


**📊 监控History List长度**
```sql
-- 方法1：通过SHOW ENGINE命令
SHOW ENGINE INNODB STATUS\G
-- 查找：History list length 数值

-- 方法2：通过Performance Schema（MySQL 8.0+）
SELECT 
    NAME, 
    COUNT 
FROM performance_schema.global_status 
WHERE NAME = 'Innodb_history_list_length';

-- 方法3：创建监控脚本
SELECT 
    UNIX_TIMESTAMP() as timestamp,
    VARIABLE_VALUE as history_length
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Innodb_history_list_length';
```

**🎯 判断标准**
```
History List长度评估：
• 0-100：    ✅ 正常范围
• 100-1000： 🟡 需要关注
• 1000-5000：🟠 性能影响明显
• >5000：    🔴 严重问题，需要立即处理
```

### 3.3 解决方案


**⚡ 优化Purge参数**
```sql
-- 增加Purge线程数量
SET GLOBAL innodb_purge_threads = 4;

-- 调整Purge批次大小
SET GLOBAL innodb_purge_batch_size = 300;

-- 减少Purge延迟
SET GLOBAL innodb_max_purge_lag = 0;

-- 调整Purge频率
SET GLOBAL innodb_purge_rseg_truncate_frequency = 32;
```

**📋 参数优化建议**

| 参数 | 默认值 | 推荐值 | 说明 |
|------|--------|--------|------|
| `innodb_purge_threads` | 4 | 4-8 | 根据CPU核数调整 |
| `innodb_purge_batch_size` | 300 | 300-1000 | 批处理大小 |
| `innodb_max_purge_lag` | 0 | 0 | 不限制Purge延迟 |

---

## 4. 🛠️ Purge线程停滞问题


### 4.1 Purge线程的作用


**💡 生活类比**
```
Purge线程 = 垃圾清理工：
- 定期清理已经无用的Undo记录
- 释放被占用的存储空间
- 保持系统整洁高效

停滞症状：
- 垃圾越积越多（History List增长）
- 存储空间不释放（Undo表空间持续增大）
- 系统运行越来越慢（查询性能下降）
```

### 4.2 停滞原因诊断


**🔍 检查Purge线程状态**
```sql
-- 查看Purge线程运行状态
SELECT 
    thread_id,
    name,
    type,
    processlist_state,
    processlist_time
FROM performance_schema.threads 
WHERE name LIKE '%purge%';

-- 检查Purge相关状态变量
SHOW GLOBAL STATUS LIKE '%purge%';
```

**📊 常见停滞原因**
```
🔸 原因分析：
1. 长事务阻塞：某个事务一直不提交
2. 锁等待：Purge操作被其他锁阻塞  
3. 配置问题：Purge参数设置不当
4. 硬件瓶颈：IO或CPU资源不足
5. Bug问题：MySQL版本相关问题
```

### 4.3 解决方案


**🚀 重启Purge线程**
```sql
-- 方法1：调整Purge线程数量（触发重启）
SET GLOBAL innodb_purge_threads = 0;
-- 等待几秒
SET GLOBAL innodb_purge_threads = 4;

-- 方法2：通过重新配置参数
SET GLOBAL innodb_purge_batch_size = 20;
SET GLOBAL innodb_purge_batch_size = 300;
```

**🔧 深度排查步骤**
```sql
-- 1. 查找长事务
SELECT 
    trx_id,
    trx_started,
    trx_state,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_seconds
FROM information_schema.INNODB_TRX 
ORDER BY trx_started;

-- 2. 检查锁等待
SELECT 
    waiting_trx_id,
    blocking_trx_id,
    waiting_query,
    blocking_query
FROM performance_schema.data_lock_waits w
JOIN performance_schema.data_locks bl ON bl.lock_id = w.blocking_lock_id
JOIN performance_schema.data_locks wl ON wl.lock_id = w.waiting_lock_id;
```

---

## 5. ⏰ 长事务导致的问题


### 5.1 长事务的危害


**🔸 核心问题**
长事务就像占着厕所不出来的人，影响整个系统：

```
长事务影响示意图：
正常事务：开始 ──→ 处理 ──→ 提交 (耗时短)
长事务：  开始 ──────────────────→ ? (一直占用资源)

影响：
• Undo Log无法清理 → 空间持续增长
• 历史版本堆积 → 查询性能下降  
• 锁资源占用 → 其他事务等待
• MVCC版本链过长 → 读取效率降低
```

### 5.2 长事务检测


**📊 查找长事务的方法**
```sql
-- 查找运行时间超过30秒的事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_seconds,
    trx_requested_lock_id,
    trx_mysql_thread_id,
    trx_query
FROM information_schema.INNODB_TRX 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 30
ORDER BY duration_seconds DESC;

-- 查看当前连接的详细信息
SELECT 
    id,
    user,
    host,
    db,
    command,
    time,
    state,
    LEFT(info, 100) AS query_preview
FROM information_schema.PROCESSLIST 
WHERE time > 30
ORDER BY time DESC;
```

### 5.3 长事务处理策略


**🎯 处理优先级**
```
处理策略选择：
1. 🟢 自然结束：等待事务正常提交（业务允许的情况下）
2. 🟡 友好通知：联系应用方主动结束事务
3. 🟠 强制终止：使用KILL命令中止连接
4. 🔴 紧急重启：重启MySQL服务（最后手段）
```

**⚡ 处理命令**
```sql
-- 查看具体的事务信息
SELECT 
    trx_mysql_thread_id AS connection_id,
    trx_query AS current_query,
    TIMESTAMPDIFF(MINUTE, trx_started, NOW()) AS running_minutes
FROM information_schema.INNODB_TRX 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300;

-- 终止特定连接（谨慎操作）
KILL CONNECTION_ID;  -- 替换为实际的连接ID
```

**📌 操作建议**
> **💡 处理长事务的建议**：
> 1. 先分析事务内容，判断是否可以安全终止
> 2. 联系应用开发者确认业务影响
> 3. 在业务低峰期进行操作
> 4. 准备回滚方案

---

## 6. 🔧 Undo Log损坏检测与修复


### 6.1 损坏类型与表现


**🔸 常见损坏症状**
```sql
-- 典型错误信息
ERROR 1812 (HY000): Tablespace is missing for table
ERROR 1030 (HY000): Got error 168 from storage engine
ERROR 2013 (HY000): Lost connection to MySQL server during query

-- 启动时的错误日志
[ERROR] InnoDB: Database page corruption on disk
[ERROR] InnoDB: Undo tablespace truncation failed
[ERROR] InnoDB: Unable to read tablespace header
```

### 6.2 损坏检测方法


**🔍 系统检查命令**
```sql
-- 检查表完整性
CHECK TABLE table_name;

-- 检查Undo表空间状态
SELECT 
    space_name,
    space_type,
    state,
    purpose
FROM information_schema.INNODB_TABLESPACES 
WHERE space_name LIKE '%undo%';

-- 检查错误日志
-- Linux系统
tail -f /var/log/mysql/error.log | grep -i undo

-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G
```

### 6.3 修复策略


**🛠️ 修复方案选择**

```
损坏程度评估：
┌──────────────┬──────────────┬──────────────┐
│ 轻微损坏     │ 中度损坏     │ 严重损坏     │
├──────────────┼──────────────┼──────────────┤
│ 个别页面错误 │ 表空间部分损坏│ 完全无法启动 │
│ 自动修复     │ 强制恢复模式 │ 数据重建     │
│ innodb_force_│ innodb_force_│ 从备份恢复   │
│ recovery=1   │ recovery=4-6 │ 完整重建     │
└──────────────┴──────────────┴──────────────┘
```

**⚡ 应急修复步骤**
```sql
-- 1. 设置强制恢复模式（在my.cnf中）
[mysqld]
innodb_force_recovery = 1  # 从1开始尝试，最高到6

-- 2. 重启MySQL服务
sudo systemctl restart mysql

-- 3. 如果能启动，立即备份数据
mysqldump --all-databases > emergency_backup.sql

-- 4. 重建损坏的Undo表空间
ALTER UNDO TABLESPACE damaged_undo SET INACTIVE;
DROP UNDO TABLESPACE damaged_undo;
CREATE UNDO TABLESPACE new_undo ADD DATAFILE 'new_undo.ibu';
```

**📋 强制恢复级别说明**

| 级别 | 说明 | 风险 |
|------|------|------|
| 1 | 忽略损坏的页面 | 低 |
| 2 | 阻止主线程运行 | 中 |
| 3 | 不进行事务回滚 | 中 |
| 4 | 阻止插入缓冲合并 | 高 |
| 5 | 不查看Undo日志 | 高 |
| 6 | 不进行前滚操作 | 极高 |

---

## 7. 🔄 事务回滚异常处理


### 7.1 回滚异常的类型


**🔸 常见回滚问题**
```
回滚异常分类：
• 回滚超时：事务过大，回滚时间过长
• 回滚失败：Undo记录损坏或丢失
• 部分回滚：只回滚了部分操作
• 回滚中断：系统异常导致回滚停止
```

### 7.2 异常诊断


**📊 检查回滚状态**
```sql
-- 查看正在回滚的事务
SELECT 
    trx_id,
    trx_state,
    trx_operation_state,
    trx_tables_in_use,
    trx_tables_locked,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration
FROM information_schema.INNODB_TRX 
WHERE trx_state = 'ROLLING BACK';

-- 监控回滚进度（通过InnoDB状态）
SHOW ENGINE INNODB STATUS\G
-- 查找 "ROLLING BACK" 相关信息
```

### 7.3 处理方案


**🚀 处理步骤**
```sql
-- 1. 确认回滚事务的详细信息
SELECT 
    trx_mysql_thread_id,
    trx_query,
    trx_rows_locked,
    trx_rows_modified
FROM information_schema.INNODB_TRX 
WHERE trx_state = 'ROLLING BACK';

-- 2. 如果回滚时间过长，可以考虑：
-- a. 等待自然完成（推荐）
-- b. 重启MySQL服务（最后手段）

-- 3. 检查回滚后的数据一致性
-- 验证关键表的数据完整性
SELECT COUNT(*) FROM important_table WHERE condition;
```

---

## 8. 👀 MVCC读取异常排查


### 8.1 MVCC异常表现


**🔸 典型症状**
```sql
-- 读取到不一致的数据
-- 同一个查询在不同时间返回不同结果（在没有修改的情况下）
-- 读取到"幻象"数据（应该已经删除但仍能看到）
-- 读取不到最新提交的数据（应该能看到但看不到）
```

**💡 理解MVCC读取异常**
```
正常MVCC：
事务A: [读取] ─────→ 看到一致的数据快照
事务B: [修改] ─────→ 不影响事务A的读取

异常MVCC：
事务A: [读取] ─────→ 看到混乱的数据（新旧混合）
原因: Undo Log链断裂或损坏
```

### 8.2 排查方法


**🔍 诊断步骤**
```sql
-- 1. 检查事务隔离级别
SELECT $$transaction_isolation;

-- 2. 查看长时间运行的读事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration,
    trx_isolation_level
FROM information_schema.INNODB_TRX 
WHERE trx_state = 'RUNNING'
ORDER BY trx_started;

-- 3. 检查History List长度
SHOW ENGINE INNODB STATUS\G
-- 查看 History list length

-- 4. 验证数据一致性
START TRANSACTION;
SELECT COUNT(*) FROM test_table;
-- 在另一个会话中修改数据后
SELECT COUNT(*) FROM test_table;  -- 应该看到相同结果
COMMIT;
```

### 8.3 解决方案


**⚡ 修复步骤**
```sql
-- 1. 结束长时间运行的读事务
-- 查找长读事务
SELECT trx_mysql_thread_id 
FROM information_schema.INNODB_TRX 
WHERE trx_state = 'RUNNING' 
AND TIMESTAMPDIFF(MINUTE, trx_started, NOW()) > 30;

-- 2. 强制Purge操作
SET GLOBAL innodb_max_purge_lag = 0;

-- 3. 重新初始化读视图（重新开始事务）
-- 应用端：结束当前事务，重新开始
```

---

## 9. 🚨 应急处理方案


### 9.1 应急响应流程


```
故障发现
    ↓
1分钟内：快速评估影响范围
    ↓
5分钟内：确定故障类型和严重程度
    ↓
┌─────────────┬─────────────┬─────────────┐
│ 业务中断级   │ 性能影响级   │ 监控告警级   │
└─────────────┴─────────────┴─────────────┘
    ↓              ↓              ↓
立即应急处理     计划处理时间     定期解决
    ↓              ↓              ↓
15分钟内恢复    1小时内处理     24小时内处理
```

### 9.2 应急处理工具箱


**🔧 快速命令集合**
```bash
#!/bin/bash
# Undo Log应急处理脚本

# 1. 快速检查Undo状态
mysql -e "
SELECT 
    COUNT(*) as active_transactions,
    MAX(TIMESTAMPDIFF(SECOND, trx_started, NOW())) as max_duration
FROM information_schema.INNODB_TRX;

SHOW GLOBAL STATUS LIKE 'Innodb_history_list_length';
"

# 2. 强制Purge清理
mysql -e "
SET GLOBAL innodb_purge_threads = 4;
SET GLOBAL innodb_max_purge_lag = 0;
SET GLOBAL innodb_purge_batch_size = 300;
"

# 3. 查找长事务
mysql -e "
SELECT 
    trx_mysql_thread_id,
    TIMESTAMPDIFF(MINUTE, trx_started, NOW()) as minutes,
    LEFT(trx_query, 50) as query_preview
FROM information_schema.INNODB_TRX 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300;
"
```

### 9.3 应急决策矩阵


**📋 处理决策表**

| 故障类型 | 业务影响 | 处理时间 | 推荐方案 |
|----------|----------|----------|----------|
| Undo空间耗尽 | 🔴 严重 | 立即 | 强制Purge + 空间扩容 |
| History List过长 | 🟡 中等 | 30分钟 | 优化Purge参数 |
| 长事务堆积 | 🟠 较高 | 15分钟 | 终止长事务 |
| Purge停滞 | 🟡 中等 | 1小时 | 重启Purge线程 |
| Undo损坏 | 🔴 严重 | 立即 | 强制恢复模式 |

---

## 10. 🛡️ 故障预防措施


### 10.1 监控体系建设


**📊 关键监控指标**
```sql
-- 监控SQL脚本
-- 1. Undo空间使用率
SELECT 
    'undo_space_usage' as metric,
    ROUND((total_size-data_free)/total_size*100, 2) as value,
    'percent' as unit
FROM information_schema.FILES 
WHERE tablespace_name LIKE 'innodb_undo_%';

-- 2. History List长度
SELECT 
    'history_list_length' as metric,
    VARIABLE_VALUE as value,
    'count' as unit
FROM performance_schema.global_status 
WHERE VARIABLE_NAME = 'Innodb_history_list_length';

-- 3. 长事务数量
SELECT 
    'long_transactions' as metric,
    COUNT(*) as value,
    'count' as unit
FROM information_schema.INNODB_TRX 
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 300;
```

### 10.2 配置优化建议


**⚙️ 推荐配置参数**
```ini
# my.cnf 推荐配置
[mysqld]

# Undo Log相关配置
innodb_undo_tablespaces = 3              # Undo表空间数量
innodb_undo_log_truncate = ON             # 启用Undo日志截断
innodb_max_undo_log_size = 1GB            # 单个Undo表空间最大大小
innodb_purge_rseg_truncate_frequency = 128 # 截断频率

# Purge相关配置  
innodb_purge_threads = 4                  # Purge线程数
innodb_purge_batch_size = 300             # Purge批处理大小
innodb_max_purge_lag = 0                  # 不限制Purge延迟

# 事务相关配置
innodb_lock_wait_timeout = 50             # 锁等待超时
transaction_isolation = READ-COMMITTED     # 事务隔离级别
```

### 10.3 日常维护检查清单


**📋 每日检查项目**
```
🔸 每日监控（自动化）：
□ History List长度 < 1000
□ Undo空间使用率 < 80%
□ 长事务数量 < 5个
□ Purge线程运行正常

🔸 每周检查（人工）：
□ 查看错误日志中的Undo相关错误
□ 检查Undo表空间碎片情况
□ 分析事务执行时间趋势
□ 验证备份策略有效性

🔸 每月优化（计划）：
□ 分析Undo参数配置合理性
□ 评估是否需要调整表空间大小
□ 检查应用程序事务使用模式
□ 更新监控告警阈值
```

---

## 11. 📋 核心要点总结


### 11.1 故障排查核心思路


```
🔸 排查优先级：
1. 先看影响 → 业务是否中断
2. 再看原因 → 空间/性能/数据问题  
3. 后看方案 → 应急/根本/预防措施
4. 最后验证 → 确保问题彻底解决
```

### 11.2 关键命令速查


**🚀 常用诊断命令**
```sql
-- 综合状态检查
SHOW ENGINE INNODB STATUS\G

-- Undo空间检查  
SELECT tablespace_name, ROUND(total_size/1024/1024, 2) AS size_mb 
FROM information_schema.FILES WHERE tablespace_name LIKE '%undo%';

-- 长事务检查
SELECT trx_id, TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration
FROM information_schema.INNODB_TRX ORDER BY duration DESC;

-- History List检查
SHOW GLOBAL STATUS LIKE 'Innodb_history_list_length';
```

### 11.3 应急处理原则


**💡 处理原则**
```
🔸 安全第一：
• 操作前先备份
• 在低峰期进行维护  
• 准备回滚方案

🔸 效率优先：
• 快速定位问题根源
• 选择影响最小的方案
• 分步骤逐步解决

🔸 预防为主：
• 建立完善监控体系
• 定期检查维护
• 持续优化配置参数
```

### 11.4 实际应用价值


**🎯 掌握这些知识后你能做什么**
- **故障快速定位**：5分钟内确定Undo Log问题类型
- **应急处理能力**：在业务高峰期安全处理故障
- **预防性维护**：通过监控提前发现潜在问题
- **性能优化**：合理配置Undo相关参数提升性能
- **数据保护**：确保事务数据的完整性和一致性

**核心记忆**：
- Undo Log故障主要是空间、性能、数据三大类问题
- 快速诊断比完美方案更重要
- 预防监控胜过事后处理
- 应急处理要在安全前提下追求效率