---
title: 28、 MVCC多版本控制与Undo Log
---
## 📚 目录

1. [MVCC基础概念](#1-MVCC基础概念)
2. [ReadView读视图机制](#2-ReadView读视图机制)
3. [版本链构建与维护](#3-版本链构建与维护)
4. [事务可见性判断算法](#4-事务可见性判断算法)
5. [隔离级别实现原理](#5-隔离级别实现原理)
6. [MVCC性能优化](#6-MVCC性能优化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 MVCC基础概念


### 1.1 什么是MVCC


**通俗理解**：
MVCC就像图书馆的版本管理系统。想象你在写论文时需要查看一本书：
- 这本书可能有第1版、第2版、第3版
- 你开始写论文时看的是第2版
- 即使后来出了第3版，你论文中引用的仍然是第2版的内容
- 这样保证了你的论文内容前后一致

```
现实场景对比：
┌─────────────────┐    ┌─────────────────┐
│   图书版本管理   │    │   MySQL MVCC   │
├─────────────────┤    ├─────────────────┤
│ 第1版 (2020年)  │ ←→ │ 版本1 (事务101) │
│ 第2版 (2021年)  │ ←→ │ 版本2 (事务102) │
│ 第3版 (2022年)  │ ←→ │ 版本3 (事务103) │
└─────────────────┘    └─────────────────┘
读者看到固定版本        事务看到一致快照
```

**核心作用**：
- **解决并发问题**：多个事务同时读写时不会互相干扰
- **提高性能**：读操作不需要加锁，提升并发能力
- **保证一致性**：每个事务看到的数据版本是一致的

### 1.2 为什么需要MVCC


**问题场景**：
```
传统方案的问题：
事务A：SELECT * FROM users WHERE id=1;  -- 读到：张三，年龄25
事务B：UPDATE users SET age=26 WHERE id=1; -- 修改年龄
事务A：SELECT * FROM users WHERE id=1;  -- 读到：张三，年龄26

问题：同一个事务中两次读取结果不一样！
```

**MVCC解决方案**：
```
MVCC的处理方式：
事务A：SELECT * FROM users WHERE id=1;  -- 读到：张三，年龄25
事务B：UPDATE users SET age=26 WHERE id=1; -- 创建新版本
事务A：SELECT * FROM users WHERE id=1;  -- 仍读到：张三，年龄25

结果：事务A始终看到一致的数据版本
```

### 1.3 MVCC核心组件


**🔸 版本信息字段**

每行记录都包含两个隐藏字段：

```
记录结构示意：
┌─────────┬─────────┬──────────────┬───────────────┐
│ 用户数据 │ DB_TRX_ID │ DB_ROLL_PTR  │   其他字段    │
├─────────┼─────────┼──────────────┼───────────────┤
│ 张三,25  │   102    │  0x7f8b4a0  │      ...      │
└─────────┴─────────┴──────────────┴───────────────┘

DB_TRX_ID：创建或最后修改这个版本的事务ID
DB_ROLL_PTR：指向Undo Log中上一个版本的指针
```

**DB_TRX_ID作用**：
- 标识哪个事务创建了这个数据版本
- 用于判断当前事务能否看到这个版本

**DB_ROLL_PTR作用**：
- 指向Undo Log中的历史版本
- 构成版本链，用于回溯历史数据

---

## 2. 👁️ ReadView读视图机制


### 2.1 ReadView是什么


**通俗理解**：
ReadView就像拍照时的快门瞬间，记录了那一刻的"世界状态"：
- 哪些事务已经提交了（可以看到）
- 哪些事务还在进行中（不能看到）
- 哪些事务还没开始（不能看到）

```
拍照时刻的状态记录：
时间点T1：
┌─────────────────────────────────┐
│        ReadView快照             │
├─────────────────────────────────┤
│ 已提交事务：[100, 101, 102]     │
│ 活跃事务：[103, 105, 107]       │
│ 未开始事务：[108, 109, ...]     │
└─────────────────────────────────┘
```

### 2.2 ReadView核心属性


**📊 四个关键属性**：

```
ReadView结构：
┌─────────────────┬──────────────────────────────────┐
│      属性       │              含义                │
├─────────────────┼──────────────────────────────────┤
│ creator_trx_id  │ 创建ReadView的事务ID             │
│ trx_ids         │ 创建时活跃的事务ID列表           │
│ min_trx_id      │ trx_ids中的最小事务ID            │
│ max_trx_id      │ 创建时应分配的下一个事务ID       │
└─────────────────┴──────────────────────────────────┘
```

**属性详解**：

```
实际示例：
当前系统状态：
- 已提交事务：100, 101, 102
- 活跃事务：103, 105, 107
- 事务104创建ReadView

ReadView内容：
creator_trx_id = 104
trx_ids = [103, 105, 107]  // 不包括自己
min_trx_id = 103
max_trx_id = 108  // 下一个要分配的ID
```

### 2.3 ReadView创建时机


**不同隔离级别的差异**：

```
READ COMMITTED（读已提交）：
事务开始 → 执行SQL1 → 创建ReadView1 → 返回结果
        → 执行SQL2 → 创建ReadView2 → 返回结果
每次查询都创建新的ReadView

REPEATABLE READ（可重复读）：
事务开始 → 第一次查询 → 创建ReadView → 返回结果
        → 后续查询 → 使用同一个ReadView → 返回结果
整个事务只有一个ReadView
```

---

## 3. 🔗 版本链构建与维护


### 3.1 版本链的形成过程


**通俗解释**：
版本链就像微信聊天记录，每次修改都会保留历史版本：

```
数据修改历史：
原始数据：张三, age=25, salary=8000
修改1：  张三, age=26, salary=8000  (事务102修改年龄)
修改2：  张三, age=26, salary=9000  (事务105修改工资)

版本链形成：
当前版本(内存) ← 版本2(Undo) ← 版本1(Undo) ← 原始版本(Undo)
```

### 3.2 版本链结构详解


**🔸 完整版本链示例**：

```
假设用户表一条记录的修改历史：

当前最新版本（在数据页中）：
┌─────────────┬───────────┬──────────────┐
│ 张三,26,9000 │ DB_TRX_ID │ DB_ROLL_PTR  │
│             │    105    │  0x7f8b4a0   │
└─────────────┴───────────┴──────────────┘
                             ↓
Undo Log中的版本链：
┌─────────────┬───────────┬──────────────┐
│ 张三,26,8000 │ DB_TRX_ID │ DB_ROLL_PTR  │  ← 版本2
│             │    102    │  0x7f8b3c0   │
└─────────────┴───────────┴──────────────┘
                             ↓
┌─────────────┬───────────┬──────────────┐
│ 张三,25,8000 │ DB_TRX_ID │ DB_ROLL_PTR  │  ← 版本1
│             │    101    │     NULL     │
└─────────────┴───────────┴──────────────┘
```

### 3.3 版本链遍历机制


**🔄 查找可见版本的过程**：

```
查找步骤：
1. 从当前最新版本开始
2. 检查 DB_TRX_ID 是否可见
3. 如果不可见，通过 DB_ROLL_PTR 找到上一版本
4. 重复步骤2-3，直到找到可见版本或链表结束

代码逻辑示意：
current_version = 最新版本
while (current_version != NULL) {
    if (是否可见(current_version.DB_TRX_ID)) {
        return current_version;  // 找到可见版本
    }
    current_version = 根据DB_ROLL_PTR找上一版本;
}
return NULL;  // 没有可见版本
```

---

## 4. 🎲 事务可见性判断算法


### 4.1 可见性判断规则


**核心算法**：判断某个版本的事务ID是否对当前ReadView可见

```
判断流程图：
DB_TRX_ID与ReadView的关系判断
               ↓
    是否等于creator_trx_id？
           ↙        ↘
         是           否
         ↓            ↓
      可见      是否小于min_trx_id？
                   ↙        ↘
                 是           否
                 ↓            ↓
               可见    是否大于等于max_trx_id？
                           ↙        ↘
                         是           否
                         ↓            ↓
                      不可见   是否在trx_ids中？
                                 ↙        ↘
                               是           否
                               ↓            ↓
                            不可见        可见
```

### 4.2 算法详细步骤


**🔸 四个判断条件**：

```
条件1：DB_TRX_ID == creator_trx_id
含义：自己修改的数据
结果：可见 ✅
原因：事务可以看到自己的修改

条件2：DB_TRX_ID < min_trx_id  
含义：比所有活跃事务都早的事务
结果：可见 ✅
原因：这些事务在ReadView创建前就已提交

条件3：DB_TRX_ID >= max_trx_id
含义：在ReadView创建后才开始的事务
结果：不可见 ❌
原因：这些事务在"拍快照"后才开始

条件4：min_trx_id <= DB_TRX_ID < max_trx_id
需要进一步检查：
- 如果在 trx_ids 中：不可见 ❌（还在进行中）
- 如果不在 trx_ids 中：可见 ✅（已经提交）
```

### 4.3 实际判断示例


**📝 具体场景分析**：

```
当前ReadView状态：
creator_trx_id = 104
trx_ids = [103, 105, 107]
min_trx_id = 103  
max_trx_id = 108

版本可见性判断：
┌───────────┬──────────────┬────────┬──────────────┐
│ DB_TRX_ID │   判断条件   │  结果  │     原因     │
├───────────┼──────────────┼────────┼──────────────┤
│    101    │ < min_trx_id │  可见  │ 早期已提交   │
│    102    │ < min_trx_id │  可见  │ 早期已提交   │
│    103    │ 在trx_ids中  │ 不可见 │ 仍在活跃     │
│    104    │ == creator   │  可见  │ 自己的修改   │
│    105    │ 在trx_ids中  │ 不可见 │ 仍在活跃     │
│    106    │不在trx_ids中 │  可见  │ 已经提交     │
│    107    │ 在trx_ids中  │ 不可见 │ 仍在活跃     │
│    108    │ >= max_trx   │ 不可见 │ 还未开始     │
└───────────┴──────────────┴────────┴──────────────┘
```

---

## 5. 🔒 隔离级别实现原理


### 5.1 READ COMMITTED实现


**每次查询创建新ReadView**：

```
时间线示例：
T1: 事务A开始
T2: 事务A执行 SELECT * FROM users WHERE id=1;
    创建ReadView1，读到：张三，age=25
T3: 事务B提交 UPDATE users SET age=26 WHERE id=1;
T4: 事务A执行 SELECT * FROM users WHERE id=1;  
    创建ReadView2，读到：张三，age=26  ← 看到了最新提交的数据

特点：每次查询都能看到最新已提交的数据
```

**ReadView创建对比**：
```
READ COMMITTED模式：
查询1 → ReadView1 → 结果1
查询2 → ReadView2 → 结果2（可能不同）
查询3 → ReadView3 → 结果3（可能不同）
```

### 5.2 REPEATABLE READ实现


**整个事务使用同一个ReadView**：

```
时间线示例：
T1: 事务A开始
T2: 事务A执行 SELECT * FROM users WHERE id=1;
    创建ReadView1，读到：张三，age=25
T3: 事务B提交 UPDATE users SET age=26 WHERE id=1;
T4: 事务A执行 SELECT * FROM users WHERE id=1;
    使用ReadView1，仍读到：张三，age=25  ← 保持一致性

特点：整个事务期间看到的数据保持一致
```

**ReadView使用对比**：
```
REPEATABLE READ模式：
查询1 → ReadView1 → 结果1
查询2 → ReadView1 → 结果1（相同）
查询3 → ReadView1 → 结果1（相同）
```

### 5.3 快照读与当前读


**🔸 两种读取方式的区别**：

```
快照读（Snapshot Read）：
- 不加锁的普通SELECT查询
- 读取基于MVCC的历史版本
- 例如：SELECT * FROM users WHERE id=1;

当前读（Current Read）：
- 加锁的查询或修改操作
- 读取当前最新版本
- 例如：
  SELECT * FROM users WHERE id=1 FOR UPDATE;
  SELECT * FROM users WHERE id=1 LOCK IN SHARE MODE;
  UPDATE/DELETE/INSERT操作
```

**实际场景对比**：

```
并发场景：
事务A（快照读）          事务B（修改数据）
│                       │
├─ SELECT * FROM t1;    │  ← 读到版本1
│                       ├─ UPDATE t1 SET...;
│                       ├─ COMMIT;
├─ SELECT * FROM t1;    │  ← 仍读到版本1（快照读）
│                       │
├─ SELECT * FOR UPDATE; │  ← 读到版本2（当前读）
```

---

## 6. ⚡ MVCC性能优化


### 6.1 长事务的性能影响


**问题描述**：
长时间运行的事务会影响MVCC性能，就像图书馆里有人长期占用老版本书籍：

```
长事务影响示意：
正常情况：
版本1 → 版本2 → 版本3 → 版本4（当前）
        ↑可以清理    ↑可以清理

长事务存在：
版本1 ← 长事务仍在使用
 ↓
版本2 → 版本3 → 版本4（当前）
↑无法清理  ↑无法清理   ↑当前版本

结果：版本链越来越长，查询性能下降
```

**性能问题**：
- **Undo Log积累**：历史版本无法及时清理
- **版本链过长**：查找可见版本需要更多时间
- **内存占用增加**：大量历史版本占用空间

### 6.2 版本链优化策略


**🔧 优化方法**：

```
1. 控制事务运行时间
   ✅ 及时提交或回滚事务
   ✅ 拆分大事务为小事务
   ✅ 避免在事务中进行耗时操作

2. 监控长事务
   ✅ 定期检查 information_schema.innodb_trx
   ✅ 设置合理的事务超时时间
   ✅ 监控Undo Log空间使用

3. 优化查询方式
   ✅ 避免不必要的快照读
   ✅ 合理使用当前读
   ✅ 考虑读写分离架构
```

### 6.3 性能监控指标


**📊 关键监控项**：

```
监控指标：
┌─────────────────┬──────────────────┬────────────────┐
│      指标       │       含义       │    正常范围    │
├─────────────────┼──────────────────┼────────────────┤
│ 活跃事务数量     │ 未提交事务个数   │ < 100个        │
│ 最长事务时间     │ 运行时间最长事务 │ < 5分钟        │
│ Undo Log大小    │ 历史版本占用空间 │ < 磁盘空间20%  │
│ 版本链平均长度   │ 单行平均版本数   │ < 10个版本     │
└─────────────────┴──────────────────┴────────────────┘
```

**监控SQL示例**：
```sql
-- 查看当前活跃事务
SELECT 
    trx_id,
    trx_started,
    trx_state,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration
FROM information_schema.innodb_trx
ORDER BY trx_started;

-- 查看Undo表空间使用情况  
SHOW ENGINE INNODB STATUS\G
```

### 6.4 MVCC与锁机制协作


**🤝 协作关系**：

```
MVCC处理读操作：
- 快照读不需要加锁
- 通过版本链提供一致性视图
- 提高读操作并发性能

锁机制处理写操作：
- 写操作需要加行锁
- 保证写操作的原子性
- 防止并发写冲突

协作效果：
┌──────────┬─────────────┬─────────────┐
│   操作   │    机制     │    效果     │
├──────────┼─────────────┼─────────────┤
│ 读 vs 读 │    MVCC     │  无冲突     │
│ 读 vs 写 │    MVCC     │  无冲突     │  
│ 写 vs 写 │    锁机制    │  有冲突     │
└──────────┴─────────────┴─────────────┘
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 MVCC本质：多版本并发控制，让读写操作不冲突
🔸 ReadView：事务开始时的"快照"，决定能看到哪些数据版本
🔸 版本链：通过Undo Log连接的历史版本链表
🔸 可见性算法：判断某个版本是否对当前事务可见的规则
🔸 隔离级别差异：ReadView创建时机不同，实现不同的隔离效果
```

### 7.2 关键理解要点


**🔹 MVCC的核心价值**：
```
解决的问题：
- 读写并发冲突 → 读操作不阻塞写操作
- 数据一致性 → 事务内部看到一致的数据视图  
- 性能提升 → 减少锁等待时间

实现机制：
- 每个事务看到自己的数据快照
- 通过版本链保存历史数据
- 通过可见性算法选择合适版本
```

**🔹 ReadView的关键作用**：
```
创建时机决定隔离级别：
- READ COMMITTED：每次查询创建 → 能看到最新提交
- REPEATABLE READ：首次查询创建 → 保持一致视图

内容决定可见性：
- 记录活跃事务列表
- 提供可见性判断依据
- 确保数据一致性
```

**🔹 版本链的设计精妙**：
```
存储策略：
- 最新版本存在数据页 → 快速访问
- 历史版本存在Undo Log → 节省空间
- 通过指针连接 → 高效遍历

查找机制：
- 从新到旧遍历版本链
- 使用可见性算法过滤
- 找到第一个可见版本返回
```

### 7.3 实际应用价值


**💼 业务场景应用**：
- **高并发读写**：电商秒杀、金融交易系统
- **数据一致性**：报表查询、数据分析场景  
- **历史数据访问**：审计追踪、版本管理需求

**🔧 优化指导**：
- **事务设计**：控制事务大小和运行时间
- **查询优化**：合理选择快照读和当前读
- **监控运维**：关注长事务和版本链长度

### 7.4 性能优化要点


```
关键优化策略：
✅ 及时提交事务，避免长事务
✅ 合理设计事务边界，减少事务大小
✅ 监控Undo Log使用情况
✅ 定期检查活跃事务状态
✅ 考虑读写分离减轻MVCC压力
```

**核心记忆口诀**：
- MVCC多版本，读写不冲突
- ReadView作快照，决定可见性  
- 版本链连历史，从新找到旧
- 算法判可见，四步来决定
- 隔离靠时机，优化控事务

**重要提醒**：
MVCC是MySQL InnoDB引擎实现高并发的核心技术，理解其原理对于数据库性能优化和并发控制设计至关重要。掌握ReadView机制和可见性算法是深入理解MySQL事务隔离的基础。