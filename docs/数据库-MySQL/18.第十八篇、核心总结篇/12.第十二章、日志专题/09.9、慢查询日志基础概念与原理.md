---
title: 9、慢查询日志基础概念与原理
---
## 📚 目录

1. [慢查询日志定义与作用](#1-慢查询日志定义与作用)
2. [查询执行时间阈值概念](#2-查询执行时间阈值概念)
3. [慢查询记录触发机制](#3-慢查询记录触发机制)
4. [日志记录格式与内容详解](#4-日志记录格式与内容详解)
5. [慢查询对性能的影响分析](#5-慢查询对性能的影响分析)
6. [日志文件存储与管理](#6-日志文件存储与管理)
7. [慢查询与执行计划的关系](#7-慢查询与执行计划的关系)
8. [性能诊断与优化基础](#8-性能诊断与优化基础)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 慢查询日志定义与作用


### 1.1 什么是慢查询日志


**📋 核心定义**
```
慢查询日志(Slow Query Log)：MySQL内置的性能监控工具
作用：自动记录执行时间超过设定阈值的SQL语句
目的：帮助数据库管理员发现和优化性能瓶颈
性质：被动监控，真实反映数据库运行状况
```

> 💡 **通俗理解**：慢查询日志就像是数据库的"体检报告"，专门记录那些"跑得慢"的SQL语句，让我们知道哪些查询拖累了整个系统的性能。

### 1.2 慢查询日志的核心作用


**🎯 主要用途**
```
性能问题定位：
• 找出执行缓慢的SQL语句
• 识别资源消耗大的查询操作
• 发现系统性能瓶颈点

优化指导：
• 为SQL优化提供具体目标
• 指导索引设计和调整
• 辅助数据库结构优化

监控分析：
• 跟踪数据库性能趋势
• 评估优化效果
• 制定性能改进策略
```

### 1.3 为什么需要慢查询日志


**📊 实际价值分析**

```
数据库运行状况：
┌─────────────────┐
│    用户请求     │ ← 大量并发访问
├─────────────────┤
│  应用层查询     │ ← 各种复杂SQL
├─────────────────┤
│   MySQL执行     │ ← 部分查询很慢
├─────────────────┤
│   慢查询日志    │ ← 自动记录问题
└─────────────────┘

问题发现过程：
用户投诉 → 系统卡顿 → 查看慢查询日志 → 定位问题SQL → 优化处理
```

> ⚠️ **重要性**：没有慢查询日志，就像闭着眼睛开车，不知道哪里有问题，更无法针对性优化。

---

## 2. ⏱️ 查询执行时间阈值概念


### 2.1 执行时间阈值的含义


**🔸 基本概念**
```
执行时间阈值(long_query_time)：
定义：触发慢查询记录的最小执行时间
单位：秒(支持微秒精度)
默认值：10秒
可调范围：0-31536000秒(1年)
```

**💡 阈值工作原理**
```
SQL执行流程：
开始执行 → 计算执行时间 → 与阈值比较 → 决定是否记录

判断逻辑：
if (执行时间 > long_query_time) {
    记录到慢查询日志;
}
```

### 2.2 阈值设置的考虑因素


**🎛️ 设置策略**

| 业务类型 | **建议阈值** | **考虑因素** | **适用场景** |
|---------|------------|-------------|-------------|
| 🌐 **Web应用** | `1-2秒` | `用户体验要求高` | `在线交易、查询` |
| 📊 **报表系统** | `5-10秒` | `复杂统计可接受` | `数据分析、BI` |
| 🔄 **批处理** | `30-60秒` | `后台任务容忍度高` | `数据同步、清理` |
| ⚡ **实时系统** | `0.5-1秒` | `响应时间要求极高` | `金融交易、监控` |

### 2.3 阈值配置实践


**🔧 配置方法**
```sql
-- 查看当前阈值设置
SHOW VARIABLES LIKE 'long_query_time';

-- 临时修改阈值(重启后失效)
SET GLOBAL long_query_time = 2;

-- 查看修改后的值
SHOW GLOBAL VARIABLES LIKE 'long_query_time';
```

**📁 永久配置(my.cnf)**
```ini
[mysqld]
# 设置慢查询阈值为2秒
long_query_time = 2

# 记录未使用索引的查询
log_queries_not_using_indexes = ON

# 启用慢查询日志
slow_query_log = ON
```

> 🔧 **实践建议**：刚开始可以设置较小的阈值(如1秒)来发现更多问题，优化后再逐步调整到合适的值。

---

## 3. ⚙️ 慢查询记录触发机制


### 3.1 触发条件详解


**🔸 触发机制原理**
```
慢查询记录的完整触发条件：

必要条件：
✅ slow_query_log = ON (慢查询日志已启用)
✅ 查询执行时间 > long_query_time

可选条件：
🔸 log_queries_not_using_indexes = ON
   → 记录未使用索引的查询(不管执行时间)
🔸 min_examined_row_limit > 0
   → 只记录检查行数超过限制的查询
```

### 3.2 触发流程图解


**📊 触发判断流程**
```
SQL语句执行
     │
     ▼
记录开始时间
     │
     ▼
执行SQL语句
     │
     ▼
计算执行时间
     │
     ▼
执行时间 > 阈值？
     │
   是 │          否
     ▼            │
检查其他条件      │
     │            │
     ▼            │
写入慢查询日志    │
     │            │
     ▼            ▼
   执行结束 ← ← ← ←
```

### 3.3 特殊触发情况


**⚡ 特殊记录规则**
```
未使用索引的查询：
• 即使执行时间很短也可能被记录
• 条件：log_queries_not_using_indexes = ON
• 目的：发现潜在的索引优化机会

管理语句记录：
• 默认不记录DDL语句(CREATE、DROP等)
• 可通过log_slow_admin_statements控制
• 包括：ALTER TABLE、CREATE INDEX等

最小扫描行数限制：
• min_examined_row_limit参数
• 只记录扫描行数超过限制的查询
• 避免记录大量小查询
```

> 📝 **实际应用**：合理配置这些参数可以让慢查询日志更精准地捕获真正有问题的SQL语句。

---

## 4. 📋 日志记录格式与内容详解


### 4.1 慢查询日志格式结构


**📄 标准记录格式**
```sql
# Time: 2024-01-09T10:30:45.123456Z
# User@Host: webapp[webapp] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 1250  Rows_examined: 50000
# Rows_affected: 0  Bytes_sent: 125000
SET timestamp=1704794445;
SELECT p.product_name, p.price, c.category_name 
FROM products p 
JOIN categories c ON p.category_id = c.id 
WHERE p.price > 100 AND p.stock > 0;
```

### 4.2 日志字段详细说明


**🔍 关键字段解析**

| 字段名 | **含义说明** | **示例值** | **重要程度** |
|--------|-------------|-----------|-------------|
| `Time` | 查询执行的时间戳 | `2024-01-09T10:30:45.123456Z` | ⭐⭐⭐ |
| `User@Host` | 执行用户和来源主机 | `webapp[webapp] @ [192.168.1.100]` | ⭐⭐⭐ |
| `Query_time` | **查询总执行时间** | `5.123456` | ⭐⭐⭐⭐⭐ |
| `Lock_time` | **等待锁的时间** | `0.000123` | ⭐⭐⭐⭐ |
| `Rows_sent` | 返回给客户端的行数 | `1250` | ⭐⭐⭐ |
| `Rows_examined` | **扫描的行数** | `50000` | ⭐⭐⭐⭐⭐ |

> 💡 **核心指标**：`Query_time`和`Rows_examined`是最重要的两个指标，前者告诉我们慢在哪里，后者告诉我们为什么慢。

### 4.3 日志内容分析要点


**📊 性能分析关键比值**
```
效率比值计算：

扫描效率 = Rows_sent / Rows_examined
• 理想值：接近1(扫描的都是需要的)
• 问题值：< 0.1(扫描了大量无用数据)

时间分布：
• 执行时间 = Query_time - Lock_time
• 如果Lock_time占比很高，说明锁竞争严重
• 如果执行时间长但Lock_time短，说明查询逻辑有问题
```

**🔧 实际分析示例**
```sql
# 案例1：扫描效率低的查询
# Query_time: 3.456789  Rows_sent: 10  Rows_examined: 1000000
# 分析：扫描了100万行只返回10行，效率极低，需要添加索引

# 案例2：锁等待时间长的查询  
# Query_time: 2.123456  Lock_time: 1.987654
# 分析：90%时间在等锁，需要检查事务处理和锁竞争
```

---

## 5. 📉 慢查询对性能的影响分析


### 5.1 慢查询的直接影响


**⚡ 性能影响机制**
```
系统资源消耗链条：
慢查询 → CPU密集计算 → 内存占用增加 → 磁盘I/O频繁 → 连接池占用

影响范围：
┌─────────────────┐
│   单个查询影响   │ ← 执行时间长，占用资源
├─────────────────┤  
│   连接层面影响   │ ← 连接被长时间占用
├─────────────────┤
│   数据库层面影响 │ ← 整体性能下降
├─────────────────┤
│   应用层面影响   │ ← 用户体验变差
└─────────────────┘
```

### 5.2 慢查询的连锁反应


**🔄 性能恶化循环**
```
慢查询恶化循环：

步骤1：慢查询占用连接时间长
   ↓
步骤2：连接池耗尽，新请求等待
   ↓  
步骤3：等待请求堆积，系统负载升高
   ↓
步骤4：系统资源紧张，查询更慢
   ↓
步骤5：恶性循环，系统瘫痪
```

> ⚠️ **危险信号**：当慢查询数量突然增加时，往往预示着系统即将出现性能危机。

### 5.3 量化性能影响


**📊 性能影响评估**

```
影响程度评估标准：

轻微影响：
• 慢查询占总查询 < 5%
• 平均响应时间增加 < 20%
• 用户基本无感知

中等影响：
• 慢查询占总查询 5-15%
• 平均响应时间增加 20-50%
• 用户开始感觉系统变慢

严重影响：
• 慢查询占总查询 > 15%
• 平均响应时间增加 > 50%
• 系统几乎无法正常使用
```

> 🎯 **优化目标**：将慢查询比例控制在5%以下，平均执行时间控制在业务可接受范围内。

---

## 6. 💾 日志文件存储与管理


### 6.1 日志文件存储位置


**📁 存储路径配置**
```sql
-- 查看慢查询日志相关配置
SHOW VARIABLES LIKE '%slow%';

-- 主要配置项：
slow_query_log          = ON               -- 是否启用
slow_query_log_file     = /var/log/mysql/slow.log  -- 日志文件路径
long_query_time         = 2                -- 阈值设置
```

**🔧 配置文件设置**
```ini
[mysqld]
# 慢查询日志文件路径
slow_query_log_file = /var/log/mysql/mysql-slow.log

# 确保目录存在且MySQL有写权限
# chown mysql:mysql /var/log/mysql/
# chmod 755 /var/log/mysql/
```

### 6.2 日志轮转与管理策略


**🔄 日志轮转必要性**
```
日志文件增长问题：
• 高负载系统每天可产生几GB慢查询日志
• 不及时清理会占满磁盘空间
• 大文件影响日志分析工具性能

轮转策略选择：
时间轮转：每天/每周生成新文件
大小轮转：文件超过指定大小时轮转
混合策略：同时考虑时间和大小
```

**📋 实用轮转配置**
```bash
# 使用logrotate管理慢查询日志
# /etc/logrotate.d/mysql-slow

/var/log/mysql/mysql-slow.log {
    daily                    # 每天轮转
    rotate 30               # 保留30天
    compress               # 压缩旧文件
    delaycompress          # 延迟压缩
    missingok              # 文件不存在不报错
    create 644 mysql mysql # 创建新文件的权限
    postrotate
        # 通知MySQL重新打开日志文件
        /usr/bin/mysqladmin flush-logs
    endscript
}
```

### 6.3 日志文件监控与清理


**📊 监控要点**
```sql
-- 监控慢查询统计信息
SHOW GLOBAL STATUS LIKE '%slow%';

-- 重要指标：
Slow_queries            -- 慢查询总数
Slow_launch_threads     -- 慢启动线程数

-- 计算慢查询率
SET @total_queries = (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Questions');
SET @slow_queries = (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Slow_queries');
SELECT CONCAT(ROUND(@slow_queries / @total_queries * 100, 2), '%') AS slow_query_rate;
```

> 🔍 **监控建议**：建立慢查询率的监控告警，当超过5%时及时介入处理。

---

## 7. 🎯 慢查询与执行计划的关系


### 7.1 执行计划基础概念


**📋 执行计划定义**
```
执行计划(Execution Plan)：
定义：MySQL执行SQL语句时制定的详细执行步骤
作用：描述如何访问表、使用哪些索引、连接顺序等
获取方式：使用EXPLAIN命令查看
```

**🔍 执行计划与慢查询的关系**
```
关系链条：
SQL语句 → 生成执行计划 → 按计划执行 → 记录执行时间

慢查询原因：
┌─────────────────┐
│   执行计划差     │ ← 没有使用适当索引
├─────────────────┤
│   数据量大       │ ← 需要扫描大量数据  
├─────────────────┤
│   资源竞争       │ ← 锁等待、I/O瓶颈
├─────────────────┤
│   SQL逻辑复杂    │ ← 多表连接、子查询
└─────────────────┘
```

### 7.2 通过执行计划分析慢查询


**🔧 分析方法示例**
```sql
-- 步骤1：发现慢查询
# Query_time: 5.123456  Rows_examined: 50000  Rows_sent: 10
SELECT * FROM orders WHERE order_date > '2024-01-01' AND status = 'pending';

-- 步骤2：查看执行计划
EXPLAIN SELECT * FROM orders WHERE order_date > '2024-01-01' AND status = 'pending';

-- 步骤3：分析执行计划
+----+-------+--------+------+---------------+------+---------+------+-------+-------------+
| id | type  | table  | key  | possible_keys | ref  | key_len | rows | Extra | type        |
+----+-------+--------+------+---------------+------+---------+------+-------+-------------+
|  1 | ALL   | orders | NULL | NULL          | NULL | NULL    | 50000| Using where |
+----+-------+--------+------+---------------+------+---------+------+-------+-------------+

-- 问题分析：type=ALL表示全表扫描，没有使用索引
```

### 7.3 执行计划优化指导


**⚡ 优化方向指导**

| 执行计划特征 | **问题诊断** | **优化方向** | **预期效果** |
|-------------|-------------|-------------|-------------|
| `type=ALL` | 全表扫描 | 添加合适索引 | 大幅提升查询速度 |
| `key=NULL` | 未使用索引 | 检查索引设计 | 减少扫描行数 |
| `rows很大` | 扫描行数多 | 优化WHERE条件 | 提高查询精度 |
| `Extra=Using filesort` | 需要额外排序 | 优化ORDER BY | 减少排序开销 |

---

## 8. 🚀 性能诊断与优化基础


### 8.1 慢查询诊断流程


**🔍 系统化诊断步骤**
```
诊断流程：
步骤1：收集慢查询日志数据
   ↓
步骤2：分析查询模式和频率  
   ↓
步骤3：识别最影响性能的SQL
   ↓
步骤4：分析执行计划
   ↓  
步骤5：制定优化策略
   ↓
步骤6：实施优化措施
   ↓
步骤7：验证优化效果
```

### 8.2 常见优化策略


**🎯 优化策略矩阵**

```
索引优化：
✅ 为WHERE条件添加索引
✅ 优化复合索引字段顺序
✅ 删除重复和无用索引

查询优化：
✅ 简化复杂子查询
✅ 优化JOIN连接方式
✅ 限制返回字段和行数

表结构优化：
✅ 合理选择数据类型
✅ 表分区处理大表
✅ 适当的反范式设计
```

### 8.3 优化效果评估


**📊 效果评估指标**
```sql
-- 优化前后对比监控
-- 查询响应时间变化
-- 扫描行数减少比例  
-- 慢查询数量变化
-- 系统整体负载改善

-- 示例：优化效果对比
优化前：Query_time: 5.123s, Rows_examined: 50000
优化后：Query_time: 0.123s, Rows_examined: 500
改善：响应时间提升97.6%，扫描效率提升99%
```

> 🎯 **成功标准**：优化后的查询应该在可接受时间内完成，并且扫描行数与返回行数比例合理。

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 慢查询日志：MySQL自动记录慢SQL的性能监控工具
🔸 执行时间阈值：触发慢查询记录的时间标准
🔸 触发机制：基于执行时间和其他条件的记录规则
🔸 日志格式：包含执行时间、扫描行数等关键性能指标
🔸 性能影响：慢查询是系统性能问题的重要原因
🔸 管理策略：日志轮转、监控和分析的重要性
```

### 9.2 关键理解要点


**🔹 慢查询日志的价值**
```
被动监控：
• 真实反映数据库运行状况
• 无需额外工具即可收集性能数据
• 为优化提供具体目标

问题定位：
• 快速识别性能瓶颈
• 量化查询效率问题
• 指导优化方向选择
```

**🔹 阈值设置的平衡**
```
设置考量：
• 太大：遗漏需要优化的查询
• 太小：产生过多噪音数据
• 合适：根据业务需求和系统负载调整

动态调整：
• 初期设置较小值发现问题
• 优化后逐步调整到合理范围
• 根据系统变化持续调优
```

**🔹 日志分析的重点**
```
关键指标：
• Query_time：直接反映查询性能
• Rows_examined：反映查询效率
• 扫描比例：判断索引使用效果

分析思路：
• 先解决影响最大的慢查询
• 关注查询频率和执行时间的乘积
• 结合执行计划深入分析原因
```

### 9.3 实际应用指导


**🛠️ 实施建议**
- **启用配置**：合理设置阈值和记录条件
- **定期分析**：建立日志分析和优化流程
- **监控告警**：设置慢查询率监控指标
- **持续优化**：根据分析结果不断改进查询性能

**📈 优化流程**
- **收集数据**：启用慢查询日志并收集足够样本
- **分析识别**：找出最影响性能的SQL语句
- **制定方案**：根据执行计划制定优化策略
- **实施验证**：执行优化并验证效果

**核心记忆**：
- 慢查询日志是数据库性能优化的重要工具
- 合理的阈值设置是有效监控的基础
- 日志分析要关注查询时间和扫描效率
- 优化工作需要持续进行和效果验证