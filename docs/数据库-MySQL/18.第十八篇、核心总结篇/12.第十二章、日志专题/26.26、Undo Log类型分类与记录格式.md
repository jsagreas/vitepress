---
title: 26、Undo Log类型分类与记录格式
---
## 📚 目录

1. [Undo Log概述与作用](#1-undo-log概述与作用)
2. [Undo Log类型分类](#2-undo-log类型分类)
3. [INSERT类型Undo Log详解](#3-insert类型undo-log详解)
4. [UPDATE类型Undo Log详解](#4-update类型undo-log详解)
5. [DELETE类型Undo Log详解](#5-delete类型undo-log详解)
6. [Undo Record记录格式解析](#6-undo-record记录格式解析)
7. [关键字段详细说明](#7-关键字段详细说明)
8. [实际案例分析](#8-实际案例分析)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 Undo Log概述与作用


### 1.1 什么是Undo Log


**🔸 通俗理解**
```
想象你在写作业，每写一道题就在草稿纸上记录：
"第3题，原来答案是A，现在改成了B"

Undo Log就像这个草稿纸，记录数据的"变化历史"
当你想撤销操作时，就看草稿纸把数据改回去
```

**📋 核心定义**
- **Undo Log（撤销日志）**：记录事务对数据修改**之前**的数据镜像
- **主要目的**：支持事务回滚、实现MVCC多版本控制
- **存储位置**：专门的Undo表空间（ibdata文件或独立undo文件）

### 1.2 Undo Log的核心作用


**⚡ 两大核心功能**

```
功能1：事务回滚
┌─────────────────┐
│ 用户执行：      │
│ UPDATE age=25   │ ──┐
│ WHERE id=1      │   │ 
└─────────────────┘   │
                      ▼
┌─────────────────┐  Undo Log记录
│ 记录原值：      │  ┌─────────────┐
│ id=1, age=20    │◄─│ age原值=20  │
└─────────────────┘  └─────────────┘
                             ▲
如果回滚 ─────────────────────┘

功能2：MVCC读取历史版本
不同事务可以看到数据的不同历史状态
```

---

## 2. 📂 Undo Log类型分类


### 2.1 按操作类型分类


**🔸 三大基本类型**

```
数据操作类型          对应Undo Log类型
┌─────────────┐     ┌─────────────────┐
│   INSERT    │────▶│  INSERT Undo    │
│   数据插入   │     │  记录如何删除    │
└─────────────┘     └─────────────────┘

┌─────────────┐     ┌─────────────────┐
│   UPDATE    │────▶│  UPDATE Undo    │
│   数据更新   │     │  记录更新前数据  │
└─────────────┘     └─────────────────┘

┌─────────────┐     ┌─────────────────┐
│   DELETE    │────▶│  DELETE Undo    │
│   数据删除   │     │  记录删除前数据  │
└─────────────┘     └─────────────────┘
```

### 2.2 Undo Log记录类型常量


**📊 四种具体记录类型**

| 类型常量 | **数值** | **含义** | **使用场景** |
|---------|---------|----------|-------------|
| `TRX_UNDO_INSERT_REC` | `11` | `INSERT记录的撤销` | `新插入数据的回滚` |
| `TRX_UNDO_UPD_EXIST_REC` | `12` | `UPDATE已存在记录` | `更新操作的回滚` |
| `TRX_UNDO_UPD_DEL_REC` | `13` | `UPDATE删除标记记录` | `恢复被标记删除的记录` |
| `TRX_UNDO_DEL_MARK_REC` | `14` | `DELETE标记记录` | `DELETE操作的回滚` |

> 💡 **理解要点**：MySQL的DELETE不是真正删除，而是打"删除标记"，所以有专门的删除标记类型

---

## 3. ➕ INSERT类型Undo Log详解


### 3.1 INSERT操作的回滚原理


**🎯 核心思想：插入的反向操作是删除**

```
用户操作：
INSERT INTO users (id, name, age) VALUES (100, 'Tom', 25);

Undo Log记录的信息：
┌──────────────────────────────────────┐
│ 记录类型：TRX_UNDO_INSERT_REC        │
│ 主键信息：id = 100                   │
│ 表的table_id：用于定位具体表         │
│ 事务ID：当前事务的trx_id             │
└──────────────────────────────────────┘

回滚时的操作：
DELETE FROM users WHERE id = 100;
```

### 3.2 INSERT Undo记录格式


**📋 TRX_UNDO_INSERT_REC格式详解**

```
INSERT Undo记录结构：
┌─────────────┬─────────────┬─────────────┬─────────────┐
│  记录长度   │   记录类型   │   表ID      │   主键信息   │
│  (2字节)   │   (1字节)   │  (变长)     │   (变长)    │
├─────────────┼─────────────┼─────────────┼─────────────┤
│     n      │     11      │  table_id   │  primary_key│
└─────────────┴─────────────┴─────────────┴─────────────┘

关键字段说明：
🔸 记录长度：整个undo记录的字节数
🔸 记录类型：固定为11（TRX_UNDO_INSERT_REC）
🔸 表ID：标识操作的具体表
🔸 主键信息：用于回滚时精确定位记录
```

### 3.3 INSERT Undo的特点


**⚡ 重要特性**
- **信息最少**：只需记录主键，不需记录完整数据
- **回滚简单**：根据主键直接删除记录
- **存储高效**：相比UPDATE/DELETE类型占用空间最小

```
为什么INSERT Undo最简单？

插入前：记录不存在  ──INSERT──▶ 插入后：记录存在
                                     │
                    ▲                │
                    │                ▼
                 回滚删除 ◀──────── 记录主键即可
```

---

## 4. 🔄 UPDATE类型Undo Log详解


### 4.1 UPDATE操作的回滚原理


**🎯 核心思想：记录更新前的完整数据镜像**

```
用户操作：
UPDATE users SET name='Jerry', age=30 WHERE id=100;

更新前数据：id=100, name='Tom', age=25, status='active'
更新后数据：id=100, name='Jerry', age=30, status='active'

Undo Log必须记录：
┌─────────────────────────────────────────┐
│ 记录类型：TRX_UNDO_UPD_EXIST_REC        │
│ 主键：id = 100                          │
│ 更新前镜像：name='Tom', age=25          │
│ 其他元信息：事务ID、回滚指针等           │
└─────────────────────────────────────────┘
```

### 4.2 UPDATE Undo记录格式


**📋 TRX_UNDO_UPD_EXIST_REC格式详解**

```
UPDATE Undo记录结构：
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ 记录长度 │ 记录类型 │  表ID   │ 主键信息 │更新字段数│ 字段镜像 │
│ (2字节) │ (1字节) │ (变长)  │ (变长)  │ (变长)  │ (变长)  │
├─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│    n    │   12    │table_id │   pk    │   cnt   │old_values│
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘

详细字段说明：
🔸 记录类型：固定为12（TRX_UNDO_UPD_EXIST_REC）
🔸 更新字段数：有多少个字段被更新
🔸 字段镜像：每个更新字段的原始值
```

### 4.3 UPDATE字段镜像格式


**📊 更新前数据的存储格式**

```
字段镜像存储结构：
每个被更新的字段按以下格式存储：

┌─────────────┬─────────────┬─────────────┐
│  字段编号   │  字段长度   │   字段值    │
│  (变长)     │  (变长)     │   (变长)    │
└─────────────┴─────────────┴─────────────┘

实际示例：
UPDATE users SET name='Jerry', age=30 WHERE id=100;

字段镜像记录：
字段1：name字段
  字段编号=2, 长度=3, 值='Tom'
字段2：age字段  
  字段编号=3, 长度=2, 值='25'
```

---

## 5. ❌ DELETE类型Undo Log详解


### 5.1 DELETE操作的回滚原理


**🎯 核心思想：MySQL的DELETE是"假删除"**

```
用户执行：
DELETE FROM users WHERE id=100;

实际操作过程：
┌─────────────────┐    标记删除    ┌─────────────────┐
│ 原始记录：      │ ─────────────▶ │ 删除标记记录：   │
│ id=100         │                │ id=100          │
│ name='Tom'     │                │ name='Tom'      │
│ delete_flag=0  │                │ delete_flag=1   │
└─────────────────┘                └─────────────────┘

记录并未真正删除，只是打上"删除标记"
```

### 5.2 DELETE Undo记录格式


**📋 TRX_UNDO_DEL_MARK_REC格式详解**

```
DELETE Undo记录结构：
┌─────────┬─────────┬─────────┬─────────┬─────────┐
│ 记录长度 │ 记录类型 │  表ID   │ 主键信息 │完整记录值│
│ (2字节) │ (1字节) │ (变长)  │ (变长)  │ (变长)  │
├─────────┼─────────┼─────────┼─────────┼─────────┤
│    n    │   14    │table_id │   pk    │old_record│
└─────────┴─────────┴─────────┴─────────┴─────────┘

关键特点：
🔸 记录类型：固定为14（TRX_UNDO_DEL_MARK_REC）
🔸 完整记录值：保存被删除记录的所有字段值
🔸 信息最全：需要完整恢复被"删除"的记录
```

### 5.3 DELETE回滚过程


**🔄 删除标记的回滚机制**

```
回滚过程：
┌─────────────────┐    清除删除标记   ┌─────────────────┐
│ 删除标记记录：   │ ◀───────────────  │ 恢复的记录：     │
│ id=100          │                   │ id=100          │
│ name='Tom'      │                   │ name='Tom'      │
│ delete_flag=1   │                   │ delete_flag=0   │
└─────────────────┘                   └─────────────────┘

操作：将delete_flag从1改回0，记录"复活"
```

---

## 6. 📋 Undo Record记录格式解析


### 6.1 通用Undo Record结构


**🏗️ 所有类型Undo记录的通用格式**

```
完整Undo Record结构：
┌─────────────────────────────────────────────────────────┐
│                     Undo Record Header                  │
├─────────────┬─────────────┬─────────────┬─────────────┤
│  记录长度   │   记录类型   │  Undo编号   │   表ID      │
│  (2字节)   │   (1字节)   │  (变长)     │  (变长)     │
└─────────────┴─────────────┴─────────────┴─────────────┘
┌─────────────────────────────────────────────────────────┐
│                   具体数据部分                           │
├─────────────┬─────────────┬─────────────┬─────────────┤
│   主键信息   │  事务ID信息  │ 回滚指针信息 │   数据镜像   │
│   (变长)    │   (变长)    │   (变长)    │   (变长)    │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

### 6.2 变长字段的编码规则


**📏 MySQL变长编码机制**

```
变长编码规则：
如果值 < 128      → 用1个字节存储
如果值 < 16384    → 用2个字节存储  
如果值 >= 16384   → 用更多字节存储

编码示例：
值=50    → 编码为：[50]           (1字节)
值=200   → 编码为：[128+72, 128]  (2字节)  
值=1000  → 编码为：[135, 232]     (2字节)

💡 理解：高位用来标识是否还有后续字节
```

---

## 7. 🔑 关键字段详细说明


### 7.1 主键信息存储


**🔍 主键在Undo Log中的作用**

```
主键的重要性：
┌─────────────────┐
│ 主键 = 记录唯一标识符  │ ──┐
└─────────────────┘   │
                      ▼
┌─────────────────────────────────┐
│ 无论INSERT/UPDATE/DELETE       │
│ 都需要主键来精确定位记录         │
│ 回滚时根据主键找到目标记录       │
└─────────────────────────────────┘

主键存储格式：
🔸 单字段主键：直接存储主键值
🔸 复合主键：按主键字段顺序依次存储
🔸 无主键表：使用隐藏的row_id作为主键
```

### 7.2 事务ID（Transaction ID）


**⚡ 事务ID的作用机制**

```
事务ID在Undo Log中的价值：
┌─────────────────┐     ┌─────────────────┐
│  当前事务：     │────▶│  Undo记录：     │
│  trx_id=1001   │     │  trx_id=1001   │
└─────────────────┘     └─────────────────┘
                               │
                               ▼
                        ┌─────────────────┐
                        │  用途：         │
                        │  1.版本控制     │  
                        │  2.垃圾回收     │
                        │  3.可见性判断   │
                        └─────────────────┘
```

**📊 事务ID的具体用途**

| 用途 | **说明** | **实际场景** |
|------|----------|-------------|
| `版本控制` | `标识数据版本归属` | `MVCC读取时判断版本` |
| `垃圾回收` | `清理过期Undo记录` | `事务提交后清理无用日志` |
| `可见性判断` | `判断版本对事务是否可见` | `读取时决定看哪个版本` |

### 7.3 回滚指针（Roll Pointer）


**🔗 回滚指针的链式结构**

```
回滚指针构成：
┌─────────────┬─────────────┬─────────────┐
│  回滚段号   │   页面号    │   记录偏移   │
│  (7位)     │  (32位)     │   (16位)    │
└─────────────┴─────────────┴─────────────┘
       │            │             │
       ▼            ▼             ▼
   指向具体的    指向页面内的   指向记录在页面
   回滚段       Undo页面      中的具体位置

形成版本链：
最新记录 ──roll_ptr──▶ Undo记录1 ──roll_ptr──▶ Undo记录2
```

### 7.4 NULL值处理与位图结构


**🗂️ NULL值的特殊处理机制**

```
NULL值位图结构：
假设表有5个字段，其中第2、4个字段为NULL

位图表示：01010 (从左到右对应字段1-5)
  │││││
  ││││└─ 字段5：非NULL
  │││└── 字段4：NULL
  ││└─── 字段3：非NULL  
  │└──── 字段2：NULL
  └───── 字段1：非NULL

存储优化：
🔸 NULL字段不存储实际值，节省空间
🔸 通过位图快速判断字段是否为NULL
🔸 恢复时根据位图重建NULL状态
```

---

## 8. 💡 实际案例分析


### 8.1 完整操作示例


**📝 用户表更新案例**

```sql
-- 原始表结构
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    email VARCHAR(100)
);

-- 初始数据
INSERT INTO users VALUES (1, 'Alice', 25, 'alice@example.com');
```

**🔄 UPDATE操作全过程**

```sql
-- 执行更新
UPDATE users SET name='Bob', age=30 WHERE id=1;
```

**生成的Undo记录分析：**

```
Undo Record内容：
┌─────────────────────────────────────────┐
│ 记录长度：45字节                         │
│ 记录类型：12 (TRX_UNDO_UPD_EXIST_REC)  │
│ 表ID：table_id                         │
│ 主键：id=1                             │
│ 更新字段数：2                           │
│ 字段1：name字段编号=2, 长度=5, 值='Alice'│
│ 字段2：age字段编号=3, 长度=2, 值='25'   │
│ 事务ID：当前事务ID                      │
│ 回滚指针：指向上一版本                   │
└─────────────────────────────────────────┘
```

### 8.2 回滚操作演示


**↩️ 基于Undo记录的回滚过程**

```
回滚执行步骤：

1. 读取Undo记录
   ├─ 找到主键：id=1
   ├─ 找到更新字段：name, age
   └─ 找到原始值：'Alice', 25

2. 构造回滚SQL
   UPDATE users 
   SET name='Alice', age=25 
   WHERE id=1;

3. 执行回滚操作
   ├─ 根据主键定位记录
   ├─ 恢复字段原始值
   └─ 更新版本信息

4. 结果验证
   数据恢复到更新前状态
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Undo Log本质：记录数据修改前的镜像，支持回滚和MVCC
🔸 三大操作类型：INSERT、UPDATE、DELETE各有对应的Undo记录格式
🔸 记录类型常量：11(INSERT)、12(UPDATE)、13(UPDATE删除)、14(DELETE标记)
🔸 关键字段：主键信息、事务ID、回滚指针、数据镜像
🔸 存储优化：变长编码、NULL位图、按需记录字段
```

### 9.2 重要理解要点


**🔹 为什么不同操作的Undo格式不同**
```
INSERT Undo：
- 只需主键，因为回滚就是删除
- 信息最少，效率最高

UPDATE Undo：  
- 需要完整的更新前镜像
- 支持字段级别的精确回滚

DELETE Undo：
- 需要完整记录，因为要"复活"记录
- MySQL的删除是标记删除，不是物理删除
```

**🔹 版本链的形成机制**
```
每次修改都生成新的Undo记录
通过回滚指针连接，形成版本链
MVCC读取时沿着版本链找到合适版本
```

**🔹 空间优化策略**
```
变长编码：根据数值大小用不同字节数
NULL位图：NULL字段不存储实际值
按需记录：只记录被修改的字段
```

### 9.3 实际应用价值


- **事务回滚**：提供完整的数据恢复机制
- **MVCC实现**：支持多版本并发控制  
- **数据一致性**：保证事务的原子性
- **性能优化**：通过版本链避免锁等待
- **故障恢复**：系统崩溃后的数据恢复

**核心记忆**：
- Undo Log是数据修改的"后悔药"
- 不同操作记录不同信息，INSERT最简单，DELETE最完整  
- 通过主键定位，通过镜像恢复，通过版本链连接
- 变长编码节省空间，NULL位图优化存储