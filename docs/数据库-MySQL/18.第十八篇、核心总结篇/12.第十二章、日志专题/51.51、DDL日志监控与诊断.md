---
title: 51、DDL日志监控与诊断
---
## 📚 目录

1. [DDL监控基础概念](#1-DDL监控基础概念)
2. [Performance Schema DDL监控](#2-Performance-Schema-DDL监控)
3. [Information Schema进程监控](#3-Information-Schema进程监控)
4. [DDL操作性能分析](#4-DDL操作性能分析)
5. [DDL阻塞与锁等待诊断](#5-DDL阻塞与锁等待诊断)
6. [DDL日志文件监控](#6-DDL日志文件监控)
7. [DDL监控告警策略](#7-DDL监控告警策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 DDL监控基础概念


### 1.1 什么是DDL监控


**🔸 基本定义**
> **DDL监控**：对数据库结构变更操作（CREATE、ALTER、DROP等）进行实时跟踪、分析和诊断的过程，就像给数据库装上"体检仪"。

```
DDL监控就像医院的监护仪：
┌─────────────────────────────────────────────────┐
│              数据库"生命体征"监控                  │
├─────────────────┬───────────────────────────────┤
│   DDL执行状态   │        监控内容               │
│   执行时间      │   ←  实时监控这些指标         │
│   资源使用      │                               │
│   锁等待情况    │        发现异常及时告警        │
│   操作进度      │                               │
└─────────────────┴───────────────────────────────┘
```

**💡 监控的核心价值**
- **预防问题**：提前发现可能导致系统故障的DDL操作
- **性能优化**：识别执行缓慢的DDL语句，优化执行策略
- **故障诊断**：快速定位DDL相关的数据库问题
- **容量规划**：了解DDL操作对系统资源的影响

### 1.2 DDL监控的挑战


**⚠️ DDL操作的特殊性**

> **关键理解**：DDL操作不同于普通查询，它们会锁定表结构，影响并发性能，执行时间通常较长。

```
DDL操作特点分析：
┌─────────────────────────────────────────────────┐
│ 特点          影响                解决方案       │
├─────────────────────────────────────────────────┤
│ 执行时间长    阻塞其他操作        进度监控       │
│ 锁定整个表    影响业务访问        锁状态监控     │
│ 资源消耗大    影响系统性能        资源监控       │
│ 不可回滚      操作风险高          审计监控       │
│ 影响复制      主从延迟增加        复制监控       │
└─────────────────────────────────────────────────┘
```

**🎯 监控目标**

| **监控维度** | **监控指标** | **业务价值** |
|-------------|-------------|-------------|
| **执行状态** | `运行中、等待中、完成、失败` | `掌握操作进展，及时干预` |
| **执行时间** | `开始时间、持续时间、预计完成时间` | `评估影响范围，安排维护窗口` |
| **资源消耗** | `CPU、内存、磁盘I/O使用率` | `避免资源瓶颈，保障系统稳定` |
| **锁状态** | `表锁、元数据锁、行锁情况` | `减少锁等待，提高并发性能` |
| **影响范围** | `受影响的连接数、等待查询数` | `评估业务影响，制定应对策略` |

---

## 2. 📊 Performance Schema DDL监控


### 2.1 events_statements_history表详解


**🔸 核心监控表介绍**

> **重要说明**：`performance_schema.events_statements_history`是MySQL提供的专门用于监控SQL语句执行历史的系统表，DDL操作也会记录在其中。

```sql
-- 查看DDL相关的语句执行历史
SELECT 
    event_id,
    sql_text,
    current_schema,
    event_name,
    timer_start,
    timer_end,
    timer_wait/1000000000 AS duration_seconds,
    lock_time/1000000000 AS lock_time_seconds,
    rows_affected,
    rows_sent,
    rows_examined
FROM performance_schema.events_statements_history 
WHERE sql_text REGEXP '^(ALTER|CREATE|DROP|TRUNCATE|RENAME)'
ORDER BY timer_start DESC 
LIMIT 10;
```

**📋 关键字段含义解析**

| **字段名** | **含义** | **示例值** | **用途** |
|-----------|---------|-----------|---------|
| **sql_text** | `执行的SQL语句` | `ALTER TABLE users ADD COLUMN age INT` | `确定具体的DDL操作` |
| **timer_start** | `开始执行时间（皮秒）` | `1642771200000000000` | `计算执行时间` |
| **timer_end** | `结束执行时间（皮秒）` | `1642771260000000000` | `计算执行时间` |
| **timer_wait** | `总执行时间（皮秒）` | `60000000000000` | `性能分析` |
| **lock_time** | `锁等待时间（皮秒）` | `5000000000` | `锁分析` |
| **rows_affected** | `影响的行数` | `1000000` | `评估影响范围` |

### 2.2 实时DDL监控查询


**⚡ 监控正在执行的DDL**

```sql
-- 查看当前正在执行的DDL操作
SELECT 
    p.id AS connection_id,
    p.user,
    p.host,
    p.db,
    p.command,
    p.time AS duration_seconds,
    p.state,
    p.info AS sql_statement
FROM information_schema.processlist p
WHERE p.info REGEXP '^(ALTER|CREATE|DROP|TRUNCATE|RENAME)'
   AND p.command != 'Sleep'
ORDER BY p.time DESC;
```

**📈 DDL执行历史分析**

```sql
-- 分析最近24小时的DDL操作统计
SELECT 
    SUBSTRING_INDEX(sql_text, ' ', 2) AS ddl_type,
    COUNT(*) AS execution_count,
    AVG(timer_wait/1000000000) AS avg_duration_seconds,
    MAX(timer_wait/1000000000) AS max_duration_seconds,
    SUM(CASE WHEN errors > 0 THEN 1 ELSE 0 END) AS error_count
FROM performance_schema.events_statements_history_long
WHERE sql_text REGEXP '^(ALTER|CREATE|DROP|TRUNCATE|RENAME)'
  AND timer_start > (SELECT UNIX_TIMESTAMP(NOW() - INTERVAL 24 HOUR) * 1000000000000)
GROUP BY SUBSTRING_INDEX(sql_text, ' ', 2)
ORDER BY execution_count DESC;
```

### 2.3 Performance Schema配置


**🔧 启用DDL监控功能**

```sql
-- 检查Performance Schema是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 启用语句监控
UPDATE performance_schema.setup_consumers 
SET enabled = 'YES' 
WHERE name LIKE '%statements%';

-- 启用DDL相关的监控器
UPDATE performance_schema.setup_instruments 
SET enabled = 'YES' 
WHERE name LIKE '%statement/sql%';

-- 查看当前配置状态
SELECT name, enabled 
FROM performance_schema.setup_consumers 
WHERE name LIKE '%statements%';
```

---

## 3. 🔄 Information Schema进程监控


### 3.1 processlist表深度应用


**🔸 进程监控原理**

> **核心概念**：`information_schema.processlist`记录了所有活跃的数据库连接，通过它可以实时监控DDL操作的执行状态。

```
进程监控工作流程：
┌─────────────────────────────────────────────────┐
│ 客户端连接 → MySQL进程 → DDL执行 → 状态更新      │
│      ↓           ↓          ↓         ↓        │
│  建立连接    分配进程ID   开始执行   实时状态    │
│      ↓           ↓          ↓         ↓        │
│ processlist记录所有这些信息，实现实时监控       │
└─────────────────────────────────────────────────┘
```

**💻 详细进程信息查询**

```sql
-- 获取DDL操作的详细进程信息
SELECT 
    id,
    user,
    host,
    db,
    command,
    time,
    state,
    info,
    -- 计算执行进度（基于时间估算）
    CASE 
        WHEN time > 300 THEN '长时间执行'
        WHEN time > 60 THEN '中等耗时'
        ELSE '正常执行'
    END AS execution_status
FROM information_schema.processlist
WHERE info IS NOT NULL 
  AND info REGEXP '^(ALTER|CREATE|DROP|TRUNCATE|RENAME)'
ORDER BY time DESC;
```

### 3.2 DDL状态监控


**📊 不同DDL状态解读**

> **状态含义解释**：MySQL在执行DDL时会显示不同的状态，每个状态表示操作的具体阶段。

```sql
-- 监控DDL操作的详细状态
SELECT 
    id,
    time,
    state,
    SUBSTRING(info, 1, 50) AS sql_preview,
    CASE state
        WHEN 'copy to tmp table' THEN '正在复制数据到临时表'
        WHEN 'rename table' THEN '正在重命名表'
        WHEN 'end' THEN '操作即将完成'
        WHEN 'freeing items' THEN '释放资源'
        WHEN 'cleaning up' THEN '清理工作'
        ELSE state
    END AS state_description
FROM information_schema.processlist
WHERE info REGEXP '^ALTER TABLE'
  AND command != 'Sleep';
```

**⏱️ DDL执行进度估算**

```sql
-- 创建DDL监控视图
CREATE OR REPLACE VIEW ddl_monitor AS
SELECT 
    p.id,
    p.user,
    p.db,
    p.time AS duration_seconds,
    p.state,
    SUBSTRING(p.info, 1, 100) AS ddl_statement,
    -- 基于状态判断进度
    CASE 
        WHEN p.state = 'copy to tmp table' THEN '30%'
        WHEN p.state = 'rename table' THEN '90%'
        WHEN p.state = 'end' THEN '95%'
        WHEN p.state = 'freeing items' THEN '98%'
        ELSE '未知'
    END AS estimated_progress,
    -- 执行时间分类
    CASE 
        WHEN p.time < 60 THEN '快速'
        WHEN p.time < 300 THEN '中等'
        WHEN p.time < 1800 THEN '较慢'
        ELSE '超长时间'
    END AS speed_category
FROM information_schema.processlist p
WHERE p.info REGEXP '^(ALTER|CREATE|DROP)'
  AND p.command != 'Sleep';

-- 使用监控视图
SELECT * FROM ddl_monitor ORDER BY duration_seconds DESC;
```

---

## 4. ⚡ DDL操作性能分析


### 4.1 执行时间分析


**📈 DDL性能指标收集**

```sql
-- 创建DDL性能分析存储过程
DELIMITER //
CREATE PROCEDURE analyze_ddl_performance()
BEGIN
    -- 声明变量
    DECLARE done INT DEFAULT FALSE;
    DECLARE stmt_text TEXT;
    DECLARE exec_time DECIMAL(10,3);
    
    -- 分析DDL执行时间分布
    SELECT '=== DDL执行时间分析报告 ===' AS report_title;
    
    -- 按DDL类型分组统计
    SELECT 
        CASE 
            WHEN sql_text LIKE 'ALTER TABLE%' THEN 'ALTER TABLE'
            WHEN sql_text LIKE 'CREATE TABLE%' THEN 'CREATE TABLE'
            WHEN sql_text LIKE 'CREATE INDEX%' THEN 'CREATE INDEX'
            WHEN sql_text LIKE 'DROP%' THEN 'DROP'
            ELSE 'OTHER'
        END AS ddl_type,
        COUNT(*) AS execution_count,
        ROUND(AVG(timer_wait/1000000000), 2) AS avg_seconds,
        ROUND(MAX(timer_wait/1000000000), 2) AS max_seconds,
        ROUND(MIN(timer_wait/1000000000), 2) AS min_seconds
    FROM performance_schema.events_statements_history_long
    WHERE sql_text REGEXP '^(ALTER|CREATE|DROP)'
      AND timer_start > (UNIX_TIMESTAMP(NOW() - INTERVAL 7 DAY) * 1000000000000)
    GROUP BY ddl_type
    ORDER BY avg_seconds DESC;
    
END //
DELIMITER ;

-- 执行性能分析
CALL analyze_ddl_performance();
```

### 4.2 资源使用监控


**🔧 DDL资源消耗分析**

```sql
-- 监控DDL操作的资源使用情况
SELECT 
    p.id,
    p.time,
    SUBSTRING(p.info, 1, 60) AS ddl_operation,
    -- 从performance_schema获取资源使用信息
    t.processlist_id,
    t.thread_id,
    t.name AS thread_name,
    t.type AS thread_type,
    -- 结合系统表获取更多信息
    CASE 
        WHEN p.time > 1800 THEN '资源消耗过高'
        WHEN p.time > 300 THEN '资源消耗较高'
        ELSE '资源消耗正常'
    END AS resource_impact
FROM information_schema.processlist p
JOIN performance_schema.threads t ON p.id = t.processlist_id
WHERE p.info REGEXP '^(ALTER|CREATE|DROP)'
  AND p.command != 'Sleep'
ORDER BY p.time DESC;
```

### 4.3 性能瓶颈识别


**🎯 瓶颈分析方法**

```sql
-- DDL性能瓶颈识别查询
WITH ddl_stats AS (
    SELECT 
        sql_text,
        timer_wait/1000000000 AS duration_seconds,
        lock_time/1000000000 AS lock_seconds,
        rows_examined,
        rows_affected,
        -- 计算锁等待比例
        (lock_time/timer_wait) * 100 AS lock_wait_percentage
    FROM performance_schema.events_statements_history_long
    WHERE sql_text REGEXP '^(ALTER|CREATE|DROP)'
      AND timer_wait > 0
)
SELECT 
    SUBSTRING(sql_text, 1, 80) AS ddl_statement,
    ROUND(duration_seconds, 2) AS total_time,
    ROUND(lock_seconds, 2) AS lock_time,
    ROUND(lock_wait_percentage, 2) AS lock_wait_pct,
    rows_affected,
    -- 性能问题诊断
    CASE 
        WHEN lock_wait_percentage > 50 THEN '锁等待瓶颈'
        WHEN duration_seconds > 300 AND rows_affected < 1000 THEN '执行效率问题'
        WHEN rows_affected > 1000000 THEN '数据量过大'
        ELSE '性能正常'
    END AS bottleneck_analysis
FROM ddl_stats
WHERE duration_seconds > 60  -- 只分析执行时间超过1分钟的DDL
ORDER BY duration_seconds DESC
LIMIT 20;
```

---

## 5. 🔒 DDL阻塞与锁等待诊断


### 5.1 元数据锁监控


**🔸 元数据锁基础概念**

> **关键理解**：DDL操作需要获取元数据锁（metadata lock），这种锁会阻止其他连接同时修改表结构，是DDL阻塞的主要原因。

```
元数据锁工作机制：
┌─────────────────────────────────────────────────┐
│ DDL操作流程中的锁机制                            │
├─────────────────────────────────────────────────┤
│ 1. 请求元数据锁 → 等待现有事务完成               │
│ 2. 获取元数据锁 → 阻止新的DML操作               │
│ 3. 执行DDL操作 → 修改表结构                     │
│ 4. 释放元数据锁 → 恢复正常访问                   │
└─────────────────────────────────────────────────┘
```

**🔍 元数据锁监控查询**

```sql
-- 查看当前的元数据锁等待情况
SELECT 
    mdl.object_schema,
    mdl.object_name,
    mdl.lock_type,
    mdl.lock_duration,
    mdl.lock_status,
    p.id AS blocking_connection_id,
    p.user AS blocking_user,
    p.host AS blocking_host,
    p.time AS blocking_duration,
    p.info AS blocking_statement
FROM performance_schema.metadata_locks mdl
LEFT JOIN information_schema.processlist p ON mdl.owner_thread_id = p.id
WHERE mdl.object_type = 'TABLE'
  AND mdl.lock_status = 'PENDING'
ORDER BY mdl.lock_duration DESC;
```

### 5.2 DDL阻塞诊断


**⚠️ 常见阻塞场景分析**

```sql
-- DDL阻塞综合诊断
SELECT 
    '=== DDL阻塞诊断报告 ===' AS diagnosis_report;

-- 1. 查找被阻塞的DDL操作
SELECT 
    'BLOCKED DDL OPERATIONS:' AS section,
    p.id,
    p.user,
    p.time AS wait_time_seconds,
    SUBSTRING(p.info, 1, 100) AS blocked_ddl
FROM information_schema.processlist p
WHERE p.info REGEXP '^(ALTER|CREATE|DROP)'
  AND p.state = 'Waiting for table metadata lock'
ORDER BY p.time DESC;

-- 2. 查找阻塞DDL的事务
SELECT 
    'BLOCKING TRANSACTIONS:' AS section,
    p.id,
    p.user,
    p.time AS transaction_duration,
    p.state,
    SUBSTRING(COALESCE(p.info, 'NULL'), 1, 100) AS last_statement
FROM information_schema.processlist p
JOIN performance_schema.metadata_locks mdl ON p.id = mdl.owner_thread_id
WHERE mdl.lock_status = 'GRANTED'
  AND mdl.object_type = 'TABLE'
  AND EXISTS (
    SELECT 1 FROM information_schema.processlist p2 
    WHERE p2.state = 'Waiting for table metadata lock'
  )
ORDER BY p.time DESC;
```

### 5.3 锁等待解决方案


**🛠️ 锁等待处理策略**

```sql
-- 创建锁等待处理工具
DELIMITER //
CREATE PROCEDURE resolve_ddl_blocking()
BEGIN
    DECLARE blocking_id INT;
    DECLARE blocking_duration INT;
    DECLARE done INT DEFAULT FALSE;
    
    -- 游标：查找长时间运行的阻塞事务
    DECLARE blocking_cursor CURSOR FOR
        SELECT DISTINCT p.id, p.time
        FROM information_schema.processlist p
        JOIN performance_schema.metadata_locks mdl ON p.id = mdl.owner_thread_id
        WHERE mdl.lock_status = 'GRANTED'
          AND p.time > 300  -- 超过5分钟的事务
          AND EXISTS (
            SELECT 1 FROM information_schema.processlist p2 
            WHERE p2.state = 'Waiting for table metadata lock'
          );
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    SELECT '开始处理DDL阻塞问题...' AS message;
    
    OPEN blocking_cursor;
    
    read_loop: LOOP
        FETCH blocking_cursor INTO blocking_id, blocking_duration;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 输出建议
        SELECT CONCAT('建议终止连接 ', blocking_id, 
                     ' (运行时间: ', blocking_duration, ' 秒)') AS recommendation;
        
        -- 可选：自动终止（谨慎使用）
        -- SET @kill_sql = CONCAT('KILL ', blocking_id);
        -- PREPARE stmt FROM @kill_sql;
        -- EXECUTE stmt;
        -- DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE blocking_cursor;
    
    SELECT '建议手动执行 KILL 命令终止阻塞连接' AS final_advice;
    
END //
DELIMITER ;
```

---

## 6. 📁 DDL日志文件监控


### 6.1 DDL日志文件管理


**🔸 日志文件位置与结构**

> **重要说明**：MySQL的DDL操作会记录在多个日志文件中，包括general log、error log和binary log，需要综合监控。

```
DDL日志文件监控体系：
┌─────────────────────────────────────────────────┐
│ 日志类型        监控内容         监控目的        │
├─────────────────────────────────────────────────┤
│ General Log     所有DDL语句      操作审计       │
│ Error Log       DDL错误信息      故障诊断       │
│ Binary Log      DDL复制信息      主从同步       │
│ DDL Log         DDL原子性信息    崩溃恢复       │
└─────────────────────────────────────────────────┘
```

**📊 日志文件大小监控**

```sql
-- 监控DDL相关日志文件大小
SELECT 
    'DDL日志文件监控' AS monitor_type,
    $$general_log_file AS general_log_path,
    $$log_error AS error_log_path,
    $$log_bin_basename AS binlog_path,
    $$datadir AS data_directory;

-- 创建日志监控表
CREATE TABLE IF NOT EXISTS ddl_log_monitor (
    id INT AUTO_INCREMENT PRIMARY KEY,
    log_type VARCHAR(50),
    log_path VARCHAR(500),
    file_size_mb DECIMAL(10,2),
    check_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20)
);
```

### 6.2 日志大小告警监控


**⚡ 自动化日志监控脚本**

```sql
-- DDL日志健康检查存储过程
DELIMITER //
CREATE PROCEDURE ddl_log_health_check()
BEGIN
    DECLARE log_size_threshold INT DEFAULT 1000; -- MB
    DECLARE warning_count INT DEFAULT 0;
    
    SELECT '=== DDL日志健康检查报告 ===' AS report_header;
    
    -- 检查general log大小（需要系统权限）
    SELECT 
        'General Log检查:' AS check_type,
        $$general_log AS log_enabled,
        $$general_log_file AS log_file,
        CASE 
            WHEN $$general_log = 'ON' THEN '需要定期清理'
            ELSE '当前已关闭'
        END AS recommendation;
    
    -- 检查error log
    SELECT 
        'Error Log检查:' AS check_type,
        $$log_error AS error_log_file,
        '建议定期检查DDL错误信息' AS recommendation;
    
    -- 检查binary log
    SELECT 
        'Binary Log检查:' AS check_type,
        $$log_bin AS binlog_enabled,
        $$expire_logs_days AS retention_days,
        CASE 
            WHEN $$expire_logs_days = 0 THEN '警告：未设置自动清理'
            ELSE CONCAT('自动清理周期: ', $$expire_logs_days, ' 天')
        END AS retention_status;
    
END //
DELIMITER ;

-- 执行健康检查
CALL ddl_log_health_check();
```

---

## 7. 🚨 DDL监控告警策略


### 7.1 告警规则设计


**🎯 关键监控指标与阈值**

| **监控项** | **正常范围** | **告警阈值** | **严重告警** | **处理建议** |
|-----------|-------------|-------------|-------------|-------------|
| **DDL执行时间** | `< 5分钟` | `> 10分钟` | `> 30分钟` | `检查是否需要优化` |
| **锁等待时间** | `< 30秒` | `> 2分钟` | `> 5分钟` | `查找阻塞事务` |
| **并发DDL数量** | `< 3个` | `> 5个` | `> 10个` | `控制并发执行` |
| **表锁定时间** | `< 1分钟` | `> 5分钟` | `> 15分钟` | `优化DDL策略` |
| **日志文件大小** | `< 1GB` | `> 5GB` | `> 10GB` | `清理历史日志` |

### 7.2 监控告警实现


**🔧 告警监控存储过程**

```sql
-- DDL监控告警系统
DELIMITER //
CREATE PROCEDURE ddl_monitoring_alerts()
BEGIN
    DECLARE alert_count INT DEFAULT 0;
    DECLARE max_ddl_time INT;
    DECLARE concurrent_ddl_count INT;
    
    -- 创建临时告警表
    CREATE TEMPORARY TABLE temp_alerts (
        alert_level VARCHAR(20),
        alert_type VARCHAR(50),
        alert_message TEXT,
        alert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- 检查长时间运行的DDL
    SELECT MAX(time), COUNT(*) 
    INTO max_ddl_time, concurrent_ddl_count
    FROM information_schema.processlist
    WHERE info REGEXP '^(ALTER|CREATE|DROP)'
      AND command != 'Sleep';
    
    -- 生成告警信息
    IF max_ddl_time > 1800 THEN  -- 30分钟
        INSERT INTO temp_alerts VALUES 
        ('CRITICAL', 'DDL_EXECUTION_TIME', 
         CONCAT('DDL执行时间超过30分钟: ', max_ddl_time, '秒'), NOW());
        SET alert_count = alert_count + 1;
    ELSEIF max_ddl_time > 600 THEN  -- 10分钟
        INSERT INTO temp_alerts VALUES 
        ('WARNING', 'DDL_EXECUTION_TIME', 
         CONCAT('DDL执行时间超过10分钟: ', max_ddl_time, '秒'), NOW());
        SET alert_count = alert_count + 1;
    END IF;
    
    -- 检查并发DDL数量
    IF concurrent_ddl_count > 10 THEN
        INSERT INTO temp_alerts VALUES 
        ('CRITICAL', 'CONCURRENT_DDL', 
         CONCAT('并发DDL数量过多: ', concurrent_ddl_count, '个'), NOW());
        SET alert_count = alert_count + 1;
    ELSEIF concurrent_ddl_count > 5 THEN
        INSERT INTO temp_alerts VALUES 
        ('WARNING', 'CONCURRENT_DDL', 
         CONCAT('并发DDL数量较多: ', concurrent_ddl_count, '个'), NOW());
        SET alert_count = alert_count + 1;
    END IF;
    
    -- 检查锁等待情况
    SELECT COUNT(*) INTO @lock_wait_count
    FROM information_schema.processlist
    WHERE state = 'Waiting for table metadata lock';
    
    IF @lock_wait_count > 0 THEN
        INSERT INTO temp_alerts VALUES 
        ('WARNING', 'METADATA_LOCK_WAIT', 
         CONCAT('发现元数据锁等待: ', @lock_wait_count, '个连接'), NOW());
        SET alert_count = alert_count + 1;
    END IF;
    
    -- 输出告警结果
    IF alert_count > 0 THEN
        SELECT '发现DDL监控告警!' AS alert_status;
        SELECT * FROM temp_alerts ORDER BY alert_level, alert_time;
    ELSE
        SELECT 'DDL监控状态正常' AS alert_status;
    END IF;
    
    DROP TEMPORARY TABLE temp_alerts;
    
END //
DELIMITER ;

-- 设置定期执行（需要event scheduler）
SET GLOBAL event_scheduler = ON;

CREATE EVENT IF NOT EXISTS ddl_monitor_event
ON SCHEDULE EVERY 5 MINUTE
DO
    CALL ddl_monitoring_alerts();
```

### 7.3 告警通知集成


**📢 告警通知方案**

```sql
-- 创建DDL告警日志表
CREATE TABLE ddl_alert_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    alert_level ENUM('INFO', 'WARNING', 'CRITICAL'),
    alert_type VARCHAR(50),
    alert_message TEXT,
    ddl_statement TEXT,
    connection_id INT,
    alert_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_time TIMESTAMP NULL,
    status ENUM('ACTIVE', 'RESOLVED') DEFAULT 'ACTIVE'
);

-- 告警记录存储过程
DELIMITER //
CREATE PROCEDURE log_ddl_alert(
    IN p_level VARCHAR(20),
    IN p_type VARCHAR(50), 
    IN p_message TEXT,
    IN p_ddl_stmt TEXT,
    IN p_conn_id INT
)
BEGIN
    INSERT INTO ddl_alert_log (
        alert_level, alert_type, alert_message, 
        ddl_statement, connection_id
    ) VALUES (
        p_level, p_type, p_message, p_ddl_stmt, p_conn_id
    );
    
    -- 可以在这里集成外部通知系统
    -- 比如发送邮件、短信、钉钉消息等
    
END //
DELIMITER ;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 DDL监控本质：实时跟踪数据库结构变更操作的执行状态
🔸 监控数据源：Performance Schema + Information Schema + 日志文件
🔸 关键监控点：执行时间、锁状态、资源使用、操作进度  
🔸 核心表：events_statements_history、processlist、metadata_locks
🔸 告警策略：基于阈值的多级告警机制
🔸 故障诊断：锁等待分析、性能瓶颈识别、资源消耗监控
```

### 8.2 关键理解要点


**🔹 DDL监控的独特性**
```
DDL vs DML监控差异：
DDL：执行时间长、锁影响大、不可回滚、影响结构
DML：执行频繁、影响数据、可回滚、影响内容

监控重点：DDL关注执行进度和锁状态，DML关注性能和并发
```

**🔹 Performance Schema的使用技巧**
```
核心表关系：
events_statements_history → 记录SQL执行历史
metadata_locks → 记录元数据锁状态  
threads → 记录线程信息
processlist → 记录进程状态

组合使用：通过JOIN多表获得完整的监控信息
```

**🔹 锁等待问题的诊断思路**
```
诊断步骤：
1. 识别被阻塞的DDL（state = 'Waiting for table metadata lock'）
2. 查找持有锁的事务（metadata_locks表）
3. 分析阻塞原因（长事务、未提交事务）
4. 制定解决方案（终止阻塞连接、优化DDL时机）
```

### 8.3 实际应用价值


**💼 运维实战应用**
- **预防性监控**：提前发现可能影响业务的长时间DDL操作
- **故障快速定位**：通过监控数据快速找到性能问题根源
- **容量规划**：了解DDL操作的资源消耗模式，合理安排维护窗口
- **安全审计**：跟踪所有结构变更操作，满足合规要求

**🎯 最佳实践建议**
```
监控策略：
1. 生产环境必须启用DDL监控
2. 设置合理的告警阈值，避免告警疲劳
3. 定期清理监控数据，避免占用过多空间
4. 结合多种监控手段，获得全面视图

故障处理：
1. 建立DDL操作的标准流程
2. 准备应急处理脚本
3. 定期演练故障处理流程
4. 建立监控数据的历史分析机制
```

**🔧 进阶应用方向**
- **自动化监控**：集成监控系统，实现自动告警和处理
- **性能优化**：基于监控数据优化DDL执行策略
- **容量预测**：分析历史数据，预测未来的资源需求
- **智能诊断**：使用机器学习分析监控数据，智能识别异常

**核心记忆口诀**：
```
DDL监控像体检，实时跟踪保健康
Performance Schema是核心，processlist看状态
锁等待要快速诊断，找到阻塞解难题
告警策略设阈值，预防故障于未然
日志文件要清理，空间监控不能忘
```