---
title: 15、mydumper备份实战操作
---
## 📚 目录

1. [mydumper基础概念](#1-mydumper基础概念)
2. [全库备份操作](#2-全库备份操作)
3. [单库与多表备份](#3-单库与多表备份)
4. [条件与分片备份](#4-条件与分片备份)
5. [增量备份策略](#5-增量备份策略)
6. [定时备份实现](#6-定时备份实现)
7. [备份验证与监控](#7-备份验证与监控)
8. [性能优化实践](#8-性能优化实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 mydumper基础概念


### 1.1 什么是mydumper


**简单理解**：mydumper就像是一个**高效的搬家公司**，专门负责把MySQL数据库里的数据快速、完整地"搬"到备份文件中。

```
传统备份工具：           mydumper并行备份：
    📦                     📦📦📦📦
    ↓                     ↓ ↓ ↓ ↓
   💾                    💾💾💾💾
  单线程                  多线程并行
  速度慢                  速度快
```

**核心优势**：
- **并行处理**：同时处理多个表，就像多个工人同时搬家
- **一致性保证**：确保备份数据在同一时间点，避免数据混乱
- **压缩支持**：自动压缩备份文件，节省存储空间
- **断点续传**：备份中断后可以继续，不用重新开始

### 1.2 mydumper vs mysqldump对比


| 特性对比 | **mysqldump** | **mydumper** | **通俗解释** |
|---------|---------------|--------------|-------------|
| 🚀 **备份速度** | `单线程，慢` | `多线程，快` | `一个人搬家 vs 团队搬家` |
| 📁 **输出格式** | `单个SQL文件` | `多个文件分离` | `打包整体 vs 分类装箱` |
| 🔄 **一致性** | `基本保证` | `强一致性` | `基本对齐 vs 精确同步` |
| 💾 **内存使用** | `可能很高` | `控制合理` | `不限制 vs 有计划` |
| ⚡ **恢复速度** | `较慢` | `并行恢复快` | `逐个恢复 vs 同时恢复` |

---

## 2. 📦 全库备份操作


### 2.1 基本全库备份


**最简单的全库备份**：就像把整个房子的所有东西都搬走

```bash
# 基础全库备份命令
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --outputdir=/backup/full_$(date +%Y%m%d_%H%M%S) \
  --compress \
  --threads=4
```

**命令解释**：
- `--host`：数据库服务器地址（家的地址）
- `--user/--password`：登录账号密码（门禁卡）
- `--outputdir`：备份文件存放目录（搬到哪里）
- `--compress`：压缩备份文件（打包压缩）
- `--threads=4`：使用4个线程（4个搬家工人）

### 2.2 完整全库备份脚本


```bash
#!/bin/bash
# 全库备份脚本示例

# 基础配置
DB_HOST="localhost"
DB_USER="backup_user"
DB_PASS="backup_password"
BACKUP_BASE="/data/mysql_backup"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="${BACKUP_BASE}/full_backup_${DATE}"

echo "🚀 开始全库备份: $(date)"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 执行备份
mydumper \
  --host="$DB_HOST" \
  --user="$DB_USER" \
  --password="$DB_PASS" \
  --outputdir="$BACKUP_DIR" \
  --compress \
  --threads=6 \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --build-empty-files \
  --verbose=2

# 检查备份结果
if [ $? -eq 0 ]; then
    echo "✅ 备份成功完成: $BACKUP_DIR"
    # 记录备份信息
    echo "$(date): Full backup completed - $BACKUP_DIR" >> /var/log/mysql_backup.log
else
    echo "❌ 备份失败"
    exit 1
fi
```

**重要参数说明**：
- `--single-transaction`：保证数据一致性（所有数据在同一时间点）
- `--routines`：备份存储过程和函数
- `--triggers`：备份触发器
- `--events`：备份事件调度器
- `--build-empty-files`：为空表也创建文件

---

## 3. 🎯 单库与多表备份


### 3.1 单库备份操作


**场景**：只备份特定的数据库，就像只搬某一个房间的东西

```bash
# 备份单个数据库
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=ecommerce \
  --outputdir=/backup/ecommerce_$(date +%Y%m%d) \
  --compress \
  --threads=4 \
  --routines \
  --triggers
```

**多数据库备份**：
```bash
# 备份多个指定数据库
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --regex="^(ecommerce|logs|analytics)\." \
  --outputdir=/backup/multi_db_$(date +%Y%m%d) \
  --compress \
  --threads=6
```

### 3.2 多表备份示例


**指定表备份**：
```bash
# 备份特定表
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=ecommerce \
  --tables-list=users,orders,products \
  --outputdir=/backup/important_tables \
  --compress
```

**排除表备份**：
```bash
# 排除某些表（比如日志表、临时表）
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=ecommerce \
  --regex="^(?!.*(_log|_temp|_cache)).*" \
  --outputdir=/backup/business_data \
  --compress
```

---

## 4. 🔍 条件与分片备份


### 4.1 条件备份语法


**什么是条件备份**：只备份满足特定条件的数据，就像只搬走贵重物品

```bash
# 备份最近30天的订单数据
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=ecommerce \
  --tables-list=orders \
  --where="created_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)" \
  --outputdir=/backup/recent_orders \
  --compress
```

**复杂条件示例**：
```bash
# 备份活跃用户数据
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=ecommerce \
  --tables-list=users \
  --where="status='active' AND last_login >= DATE_SUB(NOW(), INTERVAL 90 DAY)" \
  --outputdir=/backup/active_users \
  --compress
```

### 4.2 大表分片备份


**为什么要分片**：大表就像大房子，一次搬不完，需要分批次处理

```bash
# 大表分片备份配置
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --database=ecommerce \
  --tables-list=big_orders_table \
  --rows=100000 \
  --outputdir=/backup/big_table_chunks \
  --compress \
  --threads=8
```

**分片策略实例**：
```
原始大表：10,000,000 行数据
分片设置：--rows=100000
结果：分成 100 个文件
每个文件：约 100,000 行数据

文件示例：
ecommerce.big_orders_table.00000.sql.gz
ecommerce.big_orders_table.00001.sql.gz
...
ecommerce.big_orders_table.00099.sql.gz
```

---

## 5. 📈 增量备份策略


### 5.1 增量备份原理


**增量备份概念**：只备份自上次备份以来发生变化的数据

```
时间轴示例：
周日 -------- 周一 -------- 周二 -------- 周三
 📦           📋          📋          📋
全量备份     增量备份1    增量备份2    增量备份3
(所有数据)   (新增数据)   (新增数据)   (新增数据)
```

### 5.2 基于时间戳的增量备份


```bash
#!/bin/bash
# 增量备份脚本

# 配置参数
LAST_BACKUP_TIME_FILE="/var/log/last_backup_time.txt"
CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')

# 读取上次备份时间
if [ -f "$LAST_BACKUP_TIME_FILE" ]; then
    LAST_TIME=$(cat "$LAST_BACKUP_TIME_FILE")
else
    LAST_TIME="2024-01-01 00:00:00"  # 默认开始时间
fi

echo "📅 增量备份：从 $LAST_TIME 到 $CURRENT_TIME"

# 执行增量备份
mydumper \
  --host=localhost \
  --user=backup_user \
  --password=backup_password \
  --database=ecommerce \
  --where="updated_at >= '$LAST_TIME'" \
  --outputdir="/backup/incremental/inc_$(date +%Y%m%d_%H%M%S)" \
  --compress \
  --threads=4

# 更新备份时间记录
echo "$CURRENT_TIME" > "$LAST_BACKUP_TIME_FILE"
```

### 5.3 基于binlog位置的增量备份


```bash
# 记录binlog位置的完整备份
mydumper \
  --host=localhost \
  --user=root \
  --password=your_password \
  --outputdir=/backup/full_with_binlog \
  --compress \
  --threads=4 \
  --single-transaction \
  --master-data=2

# binlog位置信息会保存在 metadata 文件中
# 后续可以基于这个位置进行增量恢复
```

---

## 6. ⏰ 定时备份实现


### 6.1 完整定时备份脚本


```bash
#!/bin/bash
# /opt/scripts/mysql_backup.sh

# 配置区域
CONFIG_FILE="/etc/mysql_backup.conf"
LOG_FILE="/var/log/mysql_backup.log"
BACKUP_BASE="/data/mysql_backup"
RETENTION_DAYS=7

# 加载配置文件
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
else
    echo "❌ 配置文件不存在: $CONFIG_FILE"
    exit 1
fi

# 日志函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

# 清理旧备份
cleanup_old_backups() {
    log_message "🧹 清理 $RETENTION_DAYS 天前的备份"
    find "$BACKUP_BASE" -name "backup_*" -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;
}

# 执行备份
perform_backup() {
    local backup_type=$1
    local backup_dir="${BACKUP_BASE}/${backup_type}_$(date +%Y%m%d_%H%M%S)"
    
    log_message "🚀 开始 $backup_type 备份"
    
    mkdir -p "$backup_dir"
    
    case $backup_type in
        "full")
            mydumper \
              --host="$DB_HOST" \
              --user="$DB_USER" \
              --password="$DB_PASS" \
              --outputdir="$backup_dir" \
              --compress \
              --threads=6 \
              --single-transaction \
              --routines \
              --triggers \
              --events \
              --verbose=1
            ;;
        "incremental")
            # 增量备份逻辑
            perform_incremental_backup "$backup_dir"
            ;;
    esac
    
    if [ $? -eq 0 ]; then
        log_message "✅ $backup_type 备份成功: $backup_dir"
        # 计算备份大小
        backup_size=$(du -sh "$backup_dir" | cut -f1)
        log_message "📊 备份大小: $backup_size"
    else
        log_message "❌ $backup_type 备份失败"
        return 1
    fi
}

# 主执行逻辑
main() {
    log_message "=== MySQL 备份任务开始 ==="
    
    # 根据星期几决定备份类型
    day_of_week=$(date +%u)  # 1=Monday, 7=Sunday
    
    if [ $day_of_week -eq 7 ]; then
        # 周日执行全量备份
        perform_backup "full"
        cleanup_old_backups
    else
        # 其他时间执行增量备份
        perform_backup "incremental"
    fi
    
    log_message "=== MySQL 备份任务结束 ==="
}

# 执行主函数
main "$@"
```

### 6.2 crontab定时任务配置


```bash
# 编辑定时任务
crontab -e

# 添加定时备份任务
# 每天凌晨2点执行备份
0 2 * * * /opt/scripts/mysql_backup.sh >> /var/log/mysql_backup_cron.log 2>&1

# 每6小时执行一次增量备份
0 */6 * * * /opt/scripts/mysql_backup.sh incremental >> /var/log/mysql_backup_cron.log 2>&1
```

**配置文件示例** (`/etc/mysql_backup.conf`)：
```bash
# MySQL连接配置
DB_HOST="localhost"
DB_USER="backup_user"
DB_PASS="secure_password"

# 备份配置
BACKUP_BASE="/data/mysql_backup"
RETENTION_DAYS=14
COMPRESS_ENABLED="true"
THREADS=8

# 邮件通知配置
NOTIFY_EMAIL="admin@company.com"
SMTP_SERVER="smtp.company.com"
```

---

## 7. ✅ 备份验证与监控


### 7.1 备份文件检查方法


**检查备份完整性**：

```bash
#!/bin/bash
# 备份验证脚本

validate_backup() {
    local backup_dir=$1
    
    echo "🔍 验证备份目录: $backup_dir"
    
    # 1. 检查目录是否存在
    if [ ! -d "$backup_dir" ]; then
        echo "❌ 备份目录不存在"
        return 1
    fi
    
    # 2. 检查元数据文件
    if [ ! -f "$backup_dir/metadata" ]; then
        echo "❌ 元数据文件缺失"
        return 1
    fi
    
    # 3. 检查是否有SQL文件
    sql_files=$(find "$backup_dir" -name "*.sql*" | wc -l)
    if [ $sql_files -eq 0 ]; then
        echo "❌ 没有找到SQL备份文件"
        return 1
    fi
    
    # 4. 验证压缩文件完整性
    if ls "$backup_dir"/*.gz > /dev/null 2>&1; then
        echo "🔍 验证压缩文件完整性..."
        for gz_file in "$backup_dir"/*.gz; do
            if ! gzip -t "$gz_file"; then
                echo "❌ 压缩文件损坏: $gz_file"
                return 1
            fi
        done
    fi
    
    # 5. 统计备份信息
    echo "📊 备份验证报告:"
    echo "   SQL文件数量: $sql_files"
    echo "   备份总大小: $(du -sh "$backup_dir" | cut -f1)"
    echo "   备份时间: $(cat "$backup_dir/metadata" | grep "Started dump" | cut -d: -f2-)"
    
    echo "✅ 备份验证通过"
    return 0
}

# 使用示例
validate_backup "/backup/full_backup_20240115_020000"
```

### 7.2 备份日志分析


**分析mydumper输出日志**：

```bash
# mydumper详细日志分析
analyze_backup_log() {
    local log_file=$1
    
    echo "📋 分析备份日志: $log_file"
    
    # 提取关键信息
    echo "=== 备份统计 ==="
    grep "Dumping.*took" "$log_file" | head -10
    
    echo "=== 性能指标 ==="
    grep "Queue" "$log_file" | tail -5
    
    echo "=== 错误信息 ==="
    grep -i "error\|fail\|warn" "$log_file"
    
    echo "=== 备份完成时间 ==="
    grep "Finished dump" "$log_file"
}
```

### 7.3 性能监控指标


**关键监控指标**：

```bash
# 监控脚本示例
monitor_backup_performance() {
    echo "📊 备份性能监控报告"
    echo "==================="
    
    # CPU使用率
    echo "🖥️  CPU使用率:"
    top -bn1 | grep "mydumper" | awk '{print $9"%"}'
    
    # 内存使用
    echo "💾 内存使用:"
    ps aux | grep mydumper | grep -v grep | awk '{sum+=$6} END {print sum/1024 "MB"}'
    
    # 磁盘IO
    echo "💿 磁盘IO:"
    iostat -x 1 1 | grep -v "^$"
    
    # 网络传输（如果是远程备份）
    echo "🌐 网络传输:"
    iftop -t -s 10 2>/dev/null | tail -3
    
    # 备份速度估算
    backup_dir=$1
    if [ -d "$backup_dir" ]; then
        current_size=$(du -s "$backup_dir" | cut -f1)
        echo "📈 当前备份大小: ${current_size}KB"
    fi
}
```

---

## 8. ⚡ 性能优化实践


### 8.1 备份时间估算


**估算公式和方法**：

```bash
# 备份时间估算脚本
estimate_backup_time() {
    local database=$1
    
    echo "⏱️  估算 $database 备份时间"
    
    # 1. 获取数据库大小
    db_size=$(mysql -e "
        SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'DB Size (MB)'
        FROM information_schema.tables
        WHERE table_schema = '$database';" -N)
    
    echo "📊 数据库大小: ${db_size}MB"
    
    # 2. 估算备份时间（基于历史数据）
    # 假设备份速度为 50MB/分钟
    backup_speed=50
    estimated_minutes=$(echo "scale=1; $db_size / $backup_speed" | bc)
    
    echo "⏰ 预估备份时间: ${estimated_minutes}分钟"
    
    # 3. 推荐线程数
    if [ $(echo "$db_size > 1000" | bc) -eq 1 ]; then
        recommended_threads=8
    elif [ $(echo "$db_size > 500" | bc) -eq 1 ]; then
        recommended_threads=6
    else
        recommended_threads=4
    fi
    
    echo "🧵 推荐线程数: $recommended_threads"
}
```

### 8.2 资源使用控制


**优化配置示例**：

```bash
# 性能优化的mydumper命令
mydumper \
  --host=localhost \
  --user=backup_user \
  --password=backup_password \
  --outputdir=/backup/optimized \
  --compress \
  --threads=8 \
  --rows=50000 \
  --chunk-filesize=100 \
  --compress-protocol \
  --default-character-set=utf8mb4 \
  --single-transaction \
  --verbose=1
```

**参数优化说明**：
- `--threads=8`：根据CPU核心数调整
- `--rows=50000`：每个文件包含行数，影响文件大小
- `--chunk-filesize=100`：每个chunk文件大小(MB)
- `--compress-protocol`：压缩网络传输数据

### 8.3 备份最佳实践


**性能优化建议**：

```
🎯 硬件层面：
├── CPU：多核心支持并行处理
├── 内存：足够内存避免交换
├── 存储：SSD提升IO性能
└── 网络：千兆网络减少传输时间

⚙️ 配置层面：
├── 线程数：通常为CPU核心数
├── 压缩：平衡压缩率和CPU使用
├── 分片：大表分片避免单文件过大
└── 时间：避开业务高峰期执行

📋 运维层面：
├── 监控：实时监控备份进度
├── 验证：备份后立即验证完整性
├── 清理：定期清理过期备份
└── 文档：记录备份配置和流程
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 mydumper本质：MySQL的并行备份工具，比传统工具更快更可靠
🔸 并行优势：多线程同时处理，大幅提升备份速度
🔸 一致性保证：使用事务确保备份数据在同一时间点
🔸 灵活性：支持全库、单库、多表、条件备份等多种方式
🔸 可扩展性：支持压缩、分片、增量等高级功能
```

### 9.2 关键理解要点


**🔹 为什么选择mydumper**：
```
传统工具问题：
- mysqldump：单线程，备份大库时间长
- 物理备份：需要停机或复杂配置

mydumper优势：
- 多线程并行：速度提升3-10倍
- 在线备份：不影响业务运行
- 灵活控制：可按需备份特定数据
```

**🔹 备份策略选择**：
```
全量备份：周期性完整备份，通常周末执行
增量备份：只备份变化数据，日常执行
分片备份：大表分割备份，避免单文件过大
条件备份：按条件筛选数据，减少备份量
```

**🔹 性能优化要点**：
```
线程数配置：根据CPU核心数调整
压缩平衡：压缩率vs处理时间
网络优化：本地备份优于远程备份
时间安排：避开业务高峰期
```

### 9.3 实际应用价值


**📈 业务场景应用**：
- **电商系统**：每日全量+实时增量备份交易数据
- **日志系统**：定期备份历史日志，条件过滤有效数据  
- **开发环境**：快速备份恢复测试数据
- **数据迁移**：高效的跨环境数据传输

**🛠️ 运维实践**：
- **自动化备份**：crontab定时执行，无人值守
- **监控告警**：备份失败及时通知，确保数据安全
- **容量管理**：定期清理过期备份，节省存储空间
- **恢复演练**：定期验证备份可用性

### 9.4 常见问题与解决


**❓ 备份速度慢**：
```
原因分析：
- 线程数不足
- 磁盘IO瓶颈
- 网络传输慢

解决方案：
- 调整--threads参数
- 使用SSD存储
- 本地备份后传输
```

**❓ 备份文件过大**：
```
原因分析：
- 未启用压缩
- 分片设置不当
- 包含不必要数据

解决方案：
- 启用--compress
- 调整--rows参数
- 使用条件备份
```

**❓ 一致性问题**：
```
原因分析：
- 未使用事务
- 备份期间有写操作

解决方案：
- 启用--single-transaction
- 选择业务低峰期备份
```

**核心记忆**：
- mydumper并行快，一致性可靠无差错
- 全量增量相结合，定时备份保安全  
- 线程压缩要合理，监控验证不可少
- 实战优化提性能，业务数据永不丢