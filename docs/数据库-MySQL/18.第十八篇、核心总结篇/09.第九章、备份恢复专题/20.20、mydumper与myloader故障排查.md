---
title: 20、mydumper与myloader故障排查
---
## 📚 目录

1. [常见连接与权限问题](#1-常见连接与权限问题)
2. [系统资源不足处理](#2-系统资源不足处理)
3. [数据一致性与锁定问题](#3-数据一致性与锁定问题)
4. [字符集与编码问题](#4-字符集与编码问题)
5. [版本兼容性与大表处理](#5-版本兼容性与大表处理)
6. [故障恢复与预防措施](#6-故障恢复与预防措施)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔌 常见连接与权限问题


### 1.1 连接失败问题排查


**🚫 连接失败的常见表现**
```bash
# 典型错误信息
ERROR: Can't connect to MySQL server on 'localhost' (111)
ERROR: Access denied for user 'backup'@'localhost' (using password: YES)
ERROR: Unknown database 'test_db'
```

**🔍 问题排查步骤**

```
第一步：检查基础连接
┌─ 连接测试命令 ─────────────────┐
│ mysql -h主机 -u用户 -p密码    │
│ telnet 主机 3306              │
│ ping 主机                     │
└────────────────────────────────┘
```

**💡 连接问题解决方案**

| 错误类型 | **原因分析** | **解决方法** |
|---------|-------------|-------------|
| 🔴 **连接超时** | `网络不通或防火墙阻止` | `检查防火墙、网络连通性` |
| 🔴 **端口拒绝** | `MySQL服务未启动` | `启动MySQL服务` |
| 🔴 **主机解析失败** | `DNS解析问题` | `使用IP地址或修改hosts` |

```bash
# 解决连接超时
# 1. 检查防火墙
sudo ufw status
sudo firewall-cmd --list-ports

# 2. 检查MySQL服务
systemctl status mysql
sudo systemctl start mysql

# 3. 检查端口监听
netstat -tulpn | grep 3306
ss -tulpn | grep 3306
```

### 1.2 权限不足错误解决


**🔐 权限问题的根本原因**
```
为什么会权限不足？
• 用户没有SELECT权限（备份时）
• 用户没有INSERT权限（恢复时）
• 用户没有LOCK TABLES权限
• 用户没有RELOAD权限（刷新权限）
• 用户没有TRIGGER权限（处理触发器）
```

**✅ 权限配置最佳实践**
```sql
-- 创建专用备份用户
CREATE USER 'backup_user'@'%' IDENTIFIED BY 'strong_password';

-- 授予备份所需的最小权限
GRANT SELECT, LOCK TABLES, SHOW VIEW, EVENT, TRIGGER 
ON *.* TO 'backup_user'@'%';

-- 授予恢复所需权限
GRANT INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER 
ON target_db.* TO 'backup_user'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

> 💡 **安全提醒**：生产环境中应该限制用户只能从特定IP连接，将`%`替换为具体IP地址

**🔧 权限故障快速修复**
```bash
# 检查当前用户权限
mysql -u backup_user -p -e "SHOW GRANTS;"

# 测试权限是否足够
mysql -u backup_user -p -e "SELECT COUNT(*) FROM mysql.user;"
mysql -u backup_user -p -e "LOCK TABLES mysql.user READ; UNLOCK TABLES;"
```

### 1.3 网络超时处理


**⏰ 超时问题的常见场景**
```
网络超时通常发生在：
• 大表备份时连接断开
• 跨网络传输大量数据
• 服务器负载过高响应慢
• 网络环境不稳定
```

**🚀 超时优化策略**
```bash
# mydumper超时参数调优
mydumper \
    --host=192.168.1.100 \
    --user=backup_user \
    --password=password \
    --database=mydb \
    --outputdir=/backup \
    --threads=4 \
    --compress \
    --long-query-guard=7200 \      # 长查询保护时间(秒)
    --kill-long-queries \          # 自动杀死长查询
    --socket-timeout=3600          # socket超时时间
```

**📊 网络优化配置**
```bash
# MySQL配置优化
[mysqld]
wait_timeout = 28800              # 连接等待超时
interactive_timeout = 28800       # 交互超时
net_read_timeout = 120           # 网络读取超时
net_write_timeout = 120          # 网络写入超时
max_allowed_packet = 1G          # 最大数据包大小
```

---

## 2. 💾 系统资源不足处理


### 2.1 内存不足问题


**🧠 内存不足的表现症状**
```
典型错误信息：
ERROR: Cannot allocate memory
ERROR: Out of memory (Tried to allocate XXX bytes)
ERROR: MySQL server has gone away
```

**📈 内存使用监控**
```bash
# 实时监控内存使用
top -p $(pgrep mydumper)
htop
watch -n 1 'free -h'

# 查看mydumper进程内存
ps aux | grep mydumper
pmap -x $(pgrep mydumper)
```

**⚙️ 内存优化配置**
```bash
# 调整mydumper内存使用
mydumper \
    --threads=2 \                  # 减少并发线程
    --rows=10000 \                # 减少每次查询行数
    --compress \                   # 启用压缩减少内存
    --chunk-filesize=64 \          # 限制文件大小(MB)
    --no-locks                     # 避免锁定占用内存
```

> ⚠️ **注意**：减少线程数会降低备份速度，但能显著减少内存占用，需要在性能和资源间平衡

### 2.2 磁盘空间问题


**💿 磁盘空间问题预防**
```
磁盘空间计算公式：
所需空间 ≈ 数据库大小 × (1 + 压缩比) × 安全系数

压缩比参考：
• 无压缩：1.0
• gzip压缩：0.3-0.7
• 安全系数：1.5-2.0
```

**📊 空间监控脚本**
```bash
#!/bin/bash
# 磁盘空间检查脚本
check_disk_space() {
    local backup_dir="/backup"
    local min_free_gb=10
    
    # 获取可用空间(GB)
    available=$(df -BG "$backup_dir" | awk 'NR==2 {print $4}' | sed 's/G//')
    
    if [ "$available" -lt "$min_free_gb" ]; then
        echo "❌ 警告：磁盘空间不足，仅剩 ${available}GB"
        echo "🔧 建议：清理旧备份或扩展磁盘空间"
        exit 1
    else
        echo "✅ 磁盘空间充足：${available}GB 可用"
    fi
}

# 使用示例
check_disk_space
```

**🗂️ 磁盘空间优化策略**
```bash
# 1. 启用压缩备份
mydumper --compress --compress-protocol

# 2. 分区备份大表
mydumper --where="id BETWEEN 1 AND 100000"

# 3. 排除不必要的表
mydumper --regex="^(?!test_|temp_|log_)"

# 4. 自动清理旧备份
find /backup -name "*.sql" -mtime +7 -delete
```

### 2.3 I/O性能优化


**⚡ I/O瓶颈识别**
```bash
# 监控磁盘I/O
iostat -x 1 5
iotop -o
watch -n 1 'cat /proc/diskstats'

# 查看mydumper I/O使用
pidstat -d -p $(pgrep mydumper) 1
```

**🚀 I/O性能优化**
```bash
# 优化mydumper I/O
mydumper \
    --compress \                   # 减少写入数据量
    --chunk-filesize=128 \        # 增大文件块大小
    --build-empty-files \         # 并行创建文件
    --omit-from-file=/dev/null \  # 避免额外文件读取
    --threads=4                   # 平衡并发与I/O
```

---

## 3. 🔒 数据一致性与锁定问题


### 3.1 表锁定问题


**🔐 锁定问题的本质理解**
```
为什么会出现锁定问题？
• MyISAM表：备份时自动锁定整个表
• InnoDB表：默认使用一致性读，但某些情况需要锁定
• 混合引擎：不同引擎的锁定机制冲突
• 长事务：阻止表锁定的获取
```

**💡 锁定问题解决方案**

```bash
# 1. 无锁定备份（适用于InnoDB）
mydumper \
    --no-locks \                  # 不使用表锁定
    --single-transaction \        # 使用单一事务
    --routines \                  # 包含存储过程
    --events                      # 包含事件

# 2. 最小锁定影响
mydumper \
    --less-locking \              # 减少锁定时间
    --lock-all-tables \           # 短暂锁定所有表
    --flush-logs                  # 刷新日志后释放锁
```

**🔍 锁定状态监控**
```sql
-- 查看当前锁定状态
SHOW PROCESSLIST;
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;

-- 查看表锁定情况
SHOW OPEN TABLES WHERE In_use > 0;
```

### 3.2 数据不一致错误


**⚠️ 数据不一致的常见原因**
```
数据不一致产生原因：
✗ 备份过程中有写入操作
✗ 主从复制延迟
✗ 不同表在不同时间点备份
✗ 外键约束冲突
✗ 触发器执行异常
```

**✅ 保证数据一致性的方法**
```bash
# 方法1：单事务备份（推荐）
mydumper \
    --single-transaction \        # 保证事务一致性
    --master-data=2 \            # 记录binlog位置
    --flush-logs \               # 刷新日志
    --lock-all-tables            # 确保一致性快照

# 方法2：停机备份（最安全）
# 1. 停止应用写入
# 2. 执行备份
# 3. 恢复应用
```

**🔧 一致性验证方法**
```bash
# 备份后验证数据一致性
#!/bin/bash
verify_backup() {
    local backup_dir="$1"
    local database="$2"
    
    echo "🔍 开始验证备份一致性..."
    
    # 1. 检查备份文件完整性
    if [ ! -f "$backup_dir/metadata" ]; then
        echo "❌ 缺少metadata文件"
        return 1
    fi
    
    # 2. 验证表结构文件
    for schema_file in "$backup_dir"/*-schema.sql; do
        if [ ! -s "$schema_file" ]; then
            echo "❌ 表结构文件为空: $(basename $schema_file)"
            return 1
        fi
    done
    
    # 3. 验证数据文件
    for data_file in "$backup_dir"/*.sql; do
        if grep -q "ERROR" "$data_file"; then
            echo "❌ 数据文件包含错误: $(basename $data_file)"
            return 1
        fi
    done
    
    echo "✅ 备份一致性验证通过"
    return 0
}
```

### 3.3 并发冲突解决


**⚡ 并发冲突的场景**
```
常见并发冲突：
• 多个mydumper实例同时运行
• 备份与业务操作冲突
• myloader并发导入冲突
• 资源竞争导致死锁
```

**🛡️ 并发控制策略**
```bash
# 1. 使用文件锁避免重复执行
#!/bin/bash
LOCK_FILE="/var/lock/mydumper.lock"

if ! flock -n 200; then
    echo "❌ 另一个mydumper进程正在运行"
    exit 1
fi

# 执行备份
mydumper --database=mydb --outputdir=/backup

# 200文件描述符会在脚本结束时自动释放锁
} 200>"$LOCK_FILE"

# 2. 限制并发线程数
mydumper \
    --threads=2 \                 # 控制mydumper线程
    --compress \                  # 减少I/O竞争
    --chunk-filesize=64          # 减少文件数量
```

---

## 4. 🌐 字符集与编码问题


### 4.1 字符集问题诊断


**🔤 字符集问题的常见表现**
```
典型症状：
• 中文显示为乱码 ？？？
• 导入时报错：Incorrect string value
• 数据长度异常
• 特殊字符丢失或变形
```

**🔍 字符集检查方法**
```sql
-- 检查数据库字符集配置
SHOW VARIABLES LIKE 'character%';
SHOW VARIABLES LIKE 'collation%';

-- 检查表字符集
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_COLLATION
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'your_database';

-- 检查列字符集
SELECT 
    COLUMN_NAME,
    CHARACTER_SET_NAME,
    COLLATION_NAME
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE TABLE_SCHEMA = 'your_database';
```

**💡 字符集统一配置**
```bash
# mydumper备份时指定字符集
mydumper \
    --default-character-set=utf8mb4 \  # 指定字符集
    --complete-insert \                # 完整INSERT语句
    --hex-blob \                      # 二进制数据用十六进制
    --set-charset                     # 设置字符集选项

# myloader恢复时字符集处理
myloader \
    --default-character-set=utf8mb4 \  # 指定字符集
    --enable-binlog \                  # 启用binlog
    --overwrite-tables                # 覆盖已存在表
```

### 4.2 编码转换处理


**🔄 编码转换策略**
```bash
# 1. 备份前转换编码
#!/bin/bash
convert_charset() {
    local source_charset="$1"
    local target_charset="$2"
    local backup_dir="$3"
    
    echo "🔄 转换字符集：$source_charset → $target_charset"
    
    for sql_file in "$backup_dir"/*.sql; do
        if [ -f "$sql_file" ]; then
            # 创建备份
            cp "$sql_file" "$sql_file.bak"
            
            # 转换编码
            iconv -f "$source_charset" -t "$target_charset" \
                "$sql_file.bak" > "$sql_file"
            
            # 验证转换结果
            if [ $? -eq 0 ]; then
                echo "✅ 转换成功: $(basename $sql_file)"
                rm "$sql_file.bak"
            else
                echo "❌ 转换失败: $(basename $sql_file)"
                mv "$sql_file.bak" "$sql_file"
            fi
        fi
    done
}

# 使用示例
convert_charset "latin1" "utf8mb4" "/backup/mydb"
```

**🛠️ 字符集修复工具**
```sql
-- 修复表字符集
ALTER TABLE table_name 
CONVERT TO CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

-- 修复列字符集
ALTER TABLE table_name 
MODIFY COLUMN column_name VARCHAR(255) 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;
```

---

## 5. 🔧 版本兼容性与大表处理


### 5.1 版本兼容性问题


**📊 版本兼容性对照表**

| mydumper版本 | **支持MySQL版本** | **主要特性** | **兼容性说明** |
|-------------|------------------|-------------|---------------|
| `0.9.x` | `MySQL 5.5-5.7` | `基础并行备份` | `稳定版本` |
| `0.10.x` | `MySQL 5.7-8.0` | `改进压缩、更好的锁` | `推荐版本` |
| `0.11.x` | `MySQL 8.0+` | `支持新特性、性能优化` | `最新版本` |

**🔍 版本检查与处理**
```bash
# 检查版本兼容性
mysql --version
mydumper --version

# MySQL 8.0特殊处理
mydumper \
    --host=localhost \
    --user=backup_user \
    --password=password \
    --database=mydb \
    --outputdir=/backup \
    --default-auth=mysql_native_password \  # MySQL 8.0认证
    --column-statistics=0                   # 禁用列统计
```

**⚠️ 版本升级注意事项**
```
MySQL 5.7 → 8.0 迁移要点：
• 认证插件变更：caching_sha2_password
• SQL模式更严格：ONLY_FULL_GROUP_BY
• 保留字变化：RANK, DENSE_RANK等
• 字符集默认变更：utf8mb4
```

### 5.2 大表处理问题


**📏 大表的定义与挑战**
```
大表通常指：
• 行数 > 1000万行
• 数据量 > 10GB
• 单表备份时间 > 30分钟
• 占用内存 > 2GB

大表挑战：
• 备份时间过长
• 内存占用过大
• 锁定时间长影响业务
• 恢复速度慢
```

**🚀 大表优化策略**
```bash
# 策略1：分块备份
mydumper \
    --database=bigdb \
    --tables-list=big_table \
    --rows=50000 \               # 每次处理5万行
    --chunk-filesize=1024 \      # 文件大小限制1GB
    --compress \                 # 启用压缩
    --threads=8                  # 增加并发

# 策略2：按条件分割
mydumper \
    --database=bigdb \
    --tables-list=big_table \
    --where="created_date >= '2024-01-01'" \
    --outputdir=/backup/2024

# 策略3：分区表处理
mydumper \
    --database=bigdb \
    --tables-list=partitioned_table \
    --no-locks \                 # 分区表避免锁定
    --single-transaction
```

### 5.3 大表恢复优化


**⚡ 大表恢复加速技巧**
```bash
# myloader大表恢复优化
myloader \
    --directory=/backup \
    --database=target_db \
    --threads=8 \                # 并行恢复
    --queries-per-transaction=1000 \  # 批量提交
    --compress-protocol \        # 压缩传输
    --enable-binlog=0 \         # 临时禁用binlog
    --overwrite-tables

# MySQL配置优化（恢复期间）
[mysqld]
innodb_buffer_pool_size = 8G    # 增大缓冲池
innodb_log_file_size = 2G       # 增大日志文件
innodb_flush_log_at_trx_commit = 2  # 延迟刷新
sync_binlog = 0                 # 禁用同步binlog
```

**📊 大表恢复监控**
```bash
#!/bin/bash
# 恢复进度监控脚本
monitor_restore() {
    local target_db="$1"
    local table_name="$2"
    
    while true; do
        # 获取当前行数
        current_rows=$(mysql -e "SELECT COUNT(*) FROM $target_db.$table_name" 2>/dev/null)
        
        if [ $? -eq 0 ]; then
            echo "$(date): 已恢复 $current_rows 行数据"
        else
            echo "$(date): 表尚未创建或连接失败"
        fi
        
        sleep 30
    done
}

# 使用示例
monitor_restore "mydb" "big_table" &
```

---

## 6. 🛠️ 故障恢复与预防措施


### 6.1 恢复中断处理


**💔 中断恢复的常见原因**
```
恢复中断原因：
• 服务器意外重启
• 网络连接断开
• 磁盘空间不足
• 内存不足导致OOM
• 数据冲突导致失败
```

**🔄 断点续传恢复**
```bash
# myloader支持断点续传
myloader \
    --directory=/backup \
    --database=target_db \
    --resume \                   # 启用断点续传
    --threads=4 \
    --verbose=3                  # 详细日志

# 手动清理已导入数据
cleanup_partial_restore() {
    local database="$1"
    local backup_dir="$2"
    
    echo "🧹 清理部分导入的数据..."
    
    # 获取已完成的表列表
    completed_tables=$(mysql -e "SHOW TABLES FROM $database" | tail -n +2)
    
    # 删除已部分导入的表
    for table in $completed_tables; do
        echo "删除表: $table"
        mysql -e "DROP TABLE IF EXISTS $database.$table"
    done
    
    echo "✅ 清理完成，可以重新开始导入"
}
```

### 6.2 日志错误分析


**📝 关键日志位置**
```bash
# mydumper/myloader日志位置
/var/log/mydumper.log           # 备份日志
/var/log/myloader.log           # 恢复日志
/tmp/mydumper_*.log             # 临时日志

# MySQL错误日志
/var/log/mysql/error.log        # MySQL错误日志
/var/log/mysql/slow.log         # 慢查询日志
```

**🔍 常见错误模式识别**
```bash
#!/bin/bash
# 日志分析脚本
analyze_mydumper_log() {
    local log_file="$1"
    
    echo "📊 mydumper日志分析报告"
    echo "========================"
    
    # 统计错误类型
    echo "🔍 错误类型统计："
    grep -i "error" "$log_file" | \
        sed 's/.*ERROR: //' | \
        sort | uniq -c | sort -nr
    
    # 检查超时问题
    echo -e "\n⏰ 超时问题："
    grep -i "timeout\|timed out" "$log_file" | wc -l
    
    # 检查内存问题
    echo -e "\n🧠 内存问题："
    grep -i "memory\|oom" "$log_file" | wc -l
    
    # 检查权限问题
    echo -e "\n🔐 权限问题："
    grep -i "access denied\|permission" "$log_file" | wc -l
    
    # 最后的错误
    echo -e "\n❌ 最近错误："
    grep -i "error" "$log_file" | tail -5
}

# 使用示例
analyze_mydumper_log "/var/log/mydumper.log"
```

### 6.3 预防措施建议


**🛡️ 故障预防检查清单**

```
备份前检查 (Pre-backup Checklist)：
□ 磁盘空间充足 (>50% 剩余)
□ 内存资源充足 (>2GB 可用)
□ 网络连接稳定
□ MySQL服务正常运行
□ 用户权限正确配置
□ 备份目录可写
□ 没有长时间运行的查询

恢复前检查 (Pre-restore Checklist)：
□ 目标数据库已创建
□ 字符集设置正确
□ 有足够的存储空间
□ 网络连接稳定
□ MySQL配置已优化
□ 备份文件完整性已验证
```

**⚙️ 自动化预防脚本**
```bash
#!/bin/bash
# 备份前环境检查
pre_backup_check() {
    local backup_dir="$1"
    local min_disk_gb="$2"
    local min_memory_gb="$3"
    
    echo "🔍 执行备份前环境检查..."
    
    # 检查磁盘空间
    available_disk=$(df -BG "$backup_dir" | awk 'NR==2 {print $4}' | sed 's/G//')
    if [ "$available_disk" -lt "$min_disk_gb" ]; then
        echo "❌ 磁盘空间不足: ${available_disk}GB < ${min_disk_gb}GB"
        return 1
    fi
    
    # 检查内存
    available_memory=$(free -g | awk 'NR==2 {print $7}')
    if [ "$available_memory" -lt "$min_memory_gb" ]; then
        echo "❌ 可用内存不足: ${available_memory}GB < ${min_memory_gb}GB"
        return 1
    fi
    
    # 检查MySQL连接
    if ! mysql -e "SELECT 1" >/dev/null 2>&1; then
        echo "❌ MySQL连接失败"
        return 1
    fi
    
    # 检查长查询
    long_queries=$(mysql -e "SHOW PROCESSLIST" | grep -v "Sleep" | wc -l)
    if [ "$long_queries" -gt 5 ]; then
        echo "⚠️ 发现 $long_queries 个活跃查询，建议稍后执行备份"
    fi
    
    echo "✅ 环境检查通过"
    return 0
}

# 使用示例
if pre_backup_check "/backup" 20 4; then
    echo "🚀 开始执行备份..."
    mydumper --database=mydb --outputdir=/backup
else
    echo "❌ 环境检查失败，取消备份"
    exit 1
fi
```

**📈 监控与告警配置**
```bash
# 监控脚本配置
#!/bin/bash
# 添加到crontab: */5 * * * *

BACKUP_DIR="/backup"
LOG_FILE="/var/log/backup_monitor.log"

monitor_backup_health() {
    # 检查备份目录大小增长
    current_size=$(du -sb "$BACKUP_DIR" | cut -f1)
    
    # 记录到日志
    echo "$(date): 备份目录大小: $current_size bytes" >> "$LOG_FILE"
    
    # 检查是否有僵尸进程
    zombie_processes=$(ps aux | grep -E "mydumper|myloader" | grep -v grep | wc -l)
    if [ "$zombie_processes" -gt 0 ]; then
        echo "⚠️ 发现 $zombie_processes 个备份/恢复进程运行中" >> "$LOG_FILE"
    fi
    
    # 检查错误日志
    if [ -f "/var/log/mydumper.log" ]; then
        recent_errors=$(grep "$(date '+%Y-%m-%d')" /var/log/mydumper.log | grep -i error | wc -l)
        if [ "$recent_errors" -gt 0 ]; then
            echo "❌ 今日发现 $recent_errors 个错误" >> "$LOG_FILE"
            # 发送告警邮件
            tail -20 /var/log/mydumper.log | mail -s "mydumper错误告警" admin@company.com
        fi
    fi
}

monitor_backup_health
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的故障排查技能


```
🔸 连接问题：快速诊断网络、权限、服务状态
🔸 资源问题：监控并优化内存、磁盘、I/O使用
🔸 一致性问题：理解锁机制，保证数据完整性  
🔸 字符集问题：正确处理编码转换和兼容性
🔸 大表处理：掌握分块、并行、优化策略
🔸 故障恢复：实现断点续传和自动化修复
```

### 7.2 关键理解要点


**🔹 故障排查的思路**
```
系统性排查方法：
环境检查 → 权限验证 → 资源监控 → 日志分析 → 问题定位 → 解决验证

先排除外部因素：
网络 → 权限 → 服务状态 → 配置参数 → 具体错误
```

**🔹 预防胜于治疗**
```
建立完善的预防机制：
• 定期的环境检查
• 完整的监控告警
• 标准的操作流程
• 详细的文档记录
```

**🔹 故障恢复的原则**
```
快速恢复原则：
• 保护现场：保留错误日志和状态
• 快速诊断：使用标准化检查流程
• 最小影响：优先恢复核心功能
• 根本解决：从根源避免问题重复
```

### 7.3 实际应用指导


**📊 故障处理优先级**

| 故障类型 | **紧急程度** | **处理策略** | **预计时间** |
|---------|-------------|-------------|-------------|
| 🔴 **连接失败** | `极高` | `立即检查网络和服务` | `5-15分钟` |
| 🟡 **权限不足** | `高` | `验证和修复权限设置` | `10-30分钟` |
| 🟠 **资源不足** | `中` | `调整参数或增加资源` | `30-60分钟` |
| 🟢 **字符集问题** | `低` | `配置转换和重新处理` | `1-2小时` |

**🛠️ 故障处理工具箱**
```bash
# 快速诊断命令集合
alias check_mysql="systemctl status mysql && mysql -e 'SELECT 1'"
alias check_space="df -h && free -h"
alias check_process="ps aux | grep -E 'mydumper|myloader'"
alias check_locks="mysql -e 'SHOW PROCESSLIST; SHOW OPEN TABLES WHERE In_use > 0'"

# 常用修复命令
alias fix_permissions="GRANT ALL ON *.* TO backup_user@'%'; FLUSH PRIVILEGES"
alias kill_long_queries="mysql -e \"KILL \$(mysql -e 'SHOW PROCESSLIST' | awk '/Query.*[0-9]{3,}/ {print \$1}')\""
```

**🎯 最佳实践总结**
- **备份前**：必须进行环境检查和资源评估
- **备份中**：实时监控进度和资源使用
- **备份后**：验证完整性和一致性
- **问题处理**：遵循标准化排查流程
- **经验积累**：记录问题和解决方案

> 💡 **核心记忆**：mydumper故障排查要系统化、标准化，预防比治疗更重要，快速定位问题比完美解决更有价值

**🔧 实战经验**：
- 80%的问题来自权限和资源不足
- 大部分故障都有明确的错误日志
- 预防性检查能避免90%的常见问题
- 标准化的操作流程是故障处理的关键