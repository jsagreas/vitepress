---
title: 11、表结构映射与字段转换
---
## 📚 目录

1. [Otter映射机制概述](#1-Otter映射机制概述)
2. [表名映射规则配置](#2-表名映射规则配置)
3. [字段名映射详解](#3-字段名映射详解)
4. [数据类型映射转换](#4-数据类型映射转换)
5. [字符集与编码处理](#5-字符集与编码处理)
6. [约束与索引映射](#6-约束与索引映射)
7. [特殊表结构处理](#7-特殊表结构处理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗺️ Otter映射机制概述


### 1.1 什么是表结构映射


**通俗理解**：就像搬家时要把东西从旧房子搬到新房子，Otter的表结构映射就是告诉系统"源数据库的哪张表对应目标数据库的哪张表，字段怎么对应"。

```
源数据库                     目标数据库
┌─────────────┐             ┌─────────────┐
│ user_info   │ ─映射规则─→  │ t_user      │
│ - uid       │             │ - user_id   │
│ - name      │             │ - username  │
│ - email     │             │ - email     │
└─────────────┘             └─────────────┘
```

### 1.2 为什么需要映射机制


**🎯 核心原因**：
- **表名不同**：源库叫`user_info`，目标库叫`t_user`
- **字段名不同**：源库叫`uid`，目标库叫`user_id`
- **数据类型不同**：源库用`VARCHAR(50)`，目标库用`VARCHAR(100)`
- **字符集不同**：源库用`utf8`，目标库用`utf8mb4`

> 💡 **简单理解**：就像翻译官一样，把"中文"翻译成"英文"，Otter把源库的结构"翻译"成目标库能理解的结构。

### 1.3 映射配置的重要性


**❌ 没有正确映射会怎样**：
- 数据同步失败
- 字段对应错误
- 数据类型冲突
- 字符乱码问题

**✅ 正确映射的好处**：
- 数据准确同步
- 自动类型转换
- 灵活表结构适配
- 减少人工干预

---

## 2. 📋 表名映射规则配置


### 2.1 基本表名映射


**配置方式**：在Otter管理界面的数据表配置中设置

```xml
<!-- 表名映射配置示例 -->
<tableMapping>
    <!-- 一对一映射：最常见 -->
    <table source="user_info" target="t_user"/>
    <table source="order_detail" target="order_items"/>
    
    <!-- 带库名的完整映射 -->
    <table source="old_db.user_info" target="new_db.t_user"/>
</tableMapping>
```

### 2.2 表名映射规则类型


| 映射类型 | **说明** | **使用场景** | **配置示例** |
|---------|---------|-------------|-------------|
| **一对一映射** | `一张源表对应一张目标表` | `最常见的情况` | `user_info → t_user` |
| **库名+表名映射** | `指定具体的库和表` | `多库同步时` | `db1.users → db2.t_users` |
| **正则表达式映射** | `批量映射相似表名` | `表名有规律时` | `old_* → new_*` |

### 2.3 表名映射实际配置


**🔧 在Otter管理界面配置**：

```
步骤1：登录Otter管理界面
步骤2：选择对应的Pipeline
步骤3：进入"数据表"配置页面
步骤4：添加表映射关系
```

**📝 配置界面示例**：
```
源表名称：     user_info
目标表名称：   t_user
同步模式：     全量+增量
是否启用：     是
```

> ⚠️ **注意**：表名映射配置后需要重启相关节点才能生效

---

## 3. 🔤 字段名映射详解


### 3.1 字段映射基本概念


**什么是字段映射**：告诉Otter源表的哪个字段对应目标表的哪个字段。

```
用户表字段映射示例：
源表 user_info          目标表 t_user
┌──────────────┐       ┌──────────────┐
│ uid          │ ───→  │ user_id      │
│ user_name    │ ───→  │ username     │  
│ email_addr   │ ───→  │ email        │
│ create_time  │ ───→  │ created_at   │
│ update_time  │ ───→  │ updated_at   │
└──────────────┘       └──────────────┘
```

### 3.2 字段映射配置方法


**📝 XML配置方式**：
```xml
<columnMapping table="user_info">
    <!-- 基本字段映射 -->
    <column source="uid" target="user_id"/>
    <column source="user_name" target="username"/>
    <column source="email_addr" target="email"/>
    
    <!-- 时间字段映射 -->
    <column source="create_time" target="created_at"/>
    <column source="update_time" target="updated_at"/>
</columnMapping>
```

**🖥️ 界面配置方式**：
```
字段映射配置页面：
┌─────────────────────────────────────┐
│ 源字段名    │ 目标字段名    │ 操作   │
├─────────────────────────────────────┤
│ uid        │ user_id      │ [编辑] │
│ user_name  │ username     │ [编辑] │
│ email_addr │ email        │ [编辑] │
└─────────────────────────────────────┘
```

### 3.3 特殊字段映射场景


**🔸 字段合并映射**：
```xml
<!-- 将多个源字段合并到一个目标字段 -->
<column target="full_name">
    <expression>CONCAT(first_name, ' ', last_name)</expression>
</column>
```

**🔸 字段拆分映射**：
```xml
<!-- 将一个源字段拆分到多个目标字段 -->
<column source="full_name" target="first_name">
    <expression>SUBSTRING_INDEX(full_name, ' ', 1)</expression>
</column>
<column source="full_name" target="last_name">
    <expression>SUBSTRING_INDEX(full_name, ' ', -1)</expression>
</column>
```

**🔸 忽略字段映射**：
```xml
<!-- 源表有但目标表不需要的字段 -->
<ignoreColumns>
    <column>temp_field</column>
    <column>debug_info</column>
</ignoreColumns>
```

---

## 4. 🔄 数据类型映射转换


### 4.1 数据类型映射基础


**为什么需要类型映射**：不同数据库的数据类型可能不同，需要转换。

```
MySQL → Oracle 类型映射示例：
┌─────────────┐       ┌─────────────┐
│ VARCHAR(50) │ ───→  │ VARCHAR2(50)│
│ TEXT        │ ───→  │ CLOB        │
│ BIGINT      │ ───→  │ NUMBER(19)  │
│ DATETIME    │ ───→  │ DATE        │
└─────────────┘       └─────────────┘
```

### 4.2 常见数据类型映射规则


**📊 MySQL到MySQL的类型映射**：

| 源类型 | **目标类型** | **转换说明** | **注意事项** |
|--------|-------------|-------------|-------------|
| **VARCHAR(50)** | `VARCHAR(100)` | `长度可以扩大` | `不能缩小长度` |
| **INT** | `BIGINT` | `精度可以提升` | `不能降低精度` |
| **DECIMAL(10,2)** | `DECIMAL(12,2)` | `整数位可扩大` | `小数位保持一致` |
| **DATETIME** | `TIMESTAMP` | `时间类型转换` | `注意时区问题` |

**🔧 类型映射配置**：
```xml
<typeMapping>
    <!-- 字符串类型映射 -->
    <type source="VARCHAR" target="VARCHAR" 
          sourceLength="50" targetLength="100"/>
    
    <!-- 数值类型映射 -->
    <type source="INT" target="BIGINT"/>
    
    <!-- 时间类型映射 -->
    <type source="DATETIME" target="TIMESTAMP"/>
</typeMapping>
```

### 4.3 类型转换的注意事项


**✅ 安全的类型转换**：
- 小精度 → 大精度（INT → BIGINT）
- 短长度 → 长长度（VARCHAR(50) → VARCHAR(100)）
- 兼容类型转换（DATETIME → TIMESTAMP）

**❌ 危险的类型转换**：
- 大精度 → 小精度（可能数据溢出）
- 长长度 → 短长度（可能数据截断）
- 不兼容类型（数字 → 字符串）

> ⚠️ **重要提醒**：类型映射配置错误可能导致数据丢失或同步失败，配置前要仔细验证。

---

## 5. 🌐 字符集与编码处理


### 5.1 字符集问题的根源


**什么是字符集问题**：就像中文和英文的区别，数据库也有不同的"语言"来存储文字。

```
常见字符集对比：
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   latin1    │  │    utf8     │  │   utf8mb4   │
│ 西欧字符集   │  │ 标准UTF-8   │  │ 完整UTF-8   │
│ 不支持中文   │  │ 支持中文    │  │ 支持emoji   │
└─────────────┘  └─────────────┘  └─────────────┘
```

### 5.2 字符集转换配置


**🔧 源库和目标库字符集配置**：
```xml
<characterSet>
    <!-- 源库字符集 -->
    <source charset="utf8" collation="utf8_general_ci"/>
    
    <!-- 目标库字符集 -->
    <target charset="utf8mb4" collation="utf8mb4_unicode_ci"/>
    
    <!-- 转换规则 -->
    <conversion enabled="true" autoDetect="true"/>
</characterSet>
```

**📝 字符集映射配置示例**：

| 源字符集 | **目标字符集** | **兼容性** | **建议** |
|---------|---------------|-----------|----------|
| **latin1** | `utf8` | `✅ 安全` | `推荐升级` |
| **utf8** | `utf8mb4` | `✅ 安全` | `支持emoji` |
| **gbk** | `utf8` | `⚠️ 需测试` | `注意中文字符` |
| **utf8mb4** | `utf8` | `❌ 有风险` | `可能丢失emoji` |

### 5.3 解决字符集问题的步骤


**步骤1：检查源库字符集**
```sql
-- 查看数据库字符集
SHOW VARIABLES LIKE 'character_set%';

-- 查看表字符集
SHOW CREATE TABLE user_info;
```

**步骤2：检查目标库字符集**
```sql
-- 确保目标库字符集兼容
ALTER DATABASE target_db CHARACTER SET utf8mb4;

-- 修改表字符集
ALTER TABLE t_user CONVERT TO CHARACTER SET utf8mb4;
```

**步骤3：配置Otter字符集转换**
```xml
<pipeline>
    <sourceCharset>utf8</sourceCharset>
    <targetCharset>utf8mb4</targetCharset>
    <autoConvert>true</autoConvert>
</pipeline>
```

> 💡 **经验分享**：建议统一使用`utf8mb4`字符集，避免字符集转换问题。

---

## 6. 🔗 约束与索引映射


### 6.1 主键映射策略


**主键映射的重要性**：主键是数据唯一标识，映射错误会导致数据冲突。

```
主键映射示例：
源表 user_info                目标表 t_user
┌─────────────────┐         ┌─────────────────┐
│ id (PRIMARY)    │ ─────→  │ user_id (PK)    │
│ uid (UNIQUE)    │         │ uid (INDEX)     │
│ name            │         │ username        │
└─────────────────┘         └─────────────────┘
```

**🔧 主键映射配置**：
```xml
<primaryKeyMapping>
    <!-- 单字段主键映射 -->
    <primaryKey source="id" target="user_id"/>
    
    <!-- 复合主键映射 -->
    <primaryKey>
        <column source="user_id" target="uid"/>
        <column source="order_id" target="oid"/>
    </primaryKey>
</primaryKeyMapping>
```

### 6.2 索引映射规则


**索引映射配置**：
```xml
<indexMapping>
    <!-- 普通索引映射 -->
    <index source="idx_name" target="idx_username">
        <column source="name" target="username"/>
    </index>
    
    <!-- 唯一索引映射 -->
    <uniqueIndex source="uk_email" target="uk_email_addr">
        <column source="email" target="email_addr"/>
    </uniqueIndex>
    
    <!-- 复合索引映射 -->
    <index source="idx_user_time" target="idx_user_created">
        <column source="user_id" target="uid"/>
        <column source="create_time" target="created_at"/>
    </index>
</indexMapping>
```

### 6.3 约束条件处理


**🔸 外键约束映射**：
```xml
<foreignKeyMapping>
    <foreignKey source="fk_user_id" target="fk_uid">
        <column source="user_id" target="uid"/>
        <referencedTable source="user_info" target="t_user"/>
    </foreignKey>
</foreignKeyMapping>
```

**🔸 默认值映射**：
```xml
<defaultValueMapping>
    <!-- 字段默认值映射 -->
    <column source="status" target="user_status">
        <defaultValue source="1" target="active"/>
    </column>
    
    <!-- 时间默认值映射 -->
    <column source="create_time" target="created_at">
        <defaultValue>CURRENT_TIMESTAMP</defaultValue>
    </column>
</defaultValueMapping>
```

**🔸 检查约束映射**：
```xml
<checkConstraintMapping>
    <constraint source="chk_age" target="chk_user_age">
        <condition source="age >= 0" target="user_age >= 0"/>
    </constraint>
</checkConstraintMapping>
```

---

## 7. 🗂️ 特殊表结构处理


### 7.1 分区表映射


**什么是分区表**：就像把一个大文件夹分成多个小文件夹，分区表把大表分成多个小分区。

```
分区表结构示例：
user_info 表
├── user_info_2023_01 (1月分区)
├── user_info_2023_02 (2月分区) 
├── user_info_2023_03 (3月分区)
└── user_info_2023_04 (4月分区)
```

**🔧 分区表映射配置**：
```xml
<partitionMapping>
    <!-- 分区表整体映射 -->
    <partitionTable source="user_info" target="t_user">
        <!-- 分区策略映射 -->
        <partitionStrategy source="RANGE" target="RANGE"/>
        <partitionColumn source="create_time" target="created_at"/>
    </partitionTable>
    
    <!-- 具体分区映射 -->
    <partition source="user_info_2023_01" target="t_user_202301"/>
    <partition source="user_info_2023_02" target="t_user_202302"/>
</partitionMapping>
```

### 7.2 视图同步处理


**视图同步的特殊性**：视图不是真实的表，而是查询结果的"虚拟表"。

```
视图同步流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   源视图    │───→│  Otter转换  │───→│  目标表/视图 │
│ v_user_info │    │             │    │ v_t_user    │
└─────────────┘    └─────────────┘    └─────────────┘
```

**🔧 视图映射配置**：
```xml
<viewMapping>
    <!-- 视图到表的映射 -->
    <view source="v_user_info" target="t_user_summary" type="table">
        <query>
            SELECT user_id, username, email, created_at 
            FROM t_user WHERE status = 'active'
        </query>
    </view>
    
    <!-- 视图到视图的映射 -->
    <view source="v_order_detail" target="v_order_summary" type="view">
        <createStatement>
            CREATE VIEW v_order_summary AS 
            SELECT order_id, user_id, total_amount 
            FROM order_items
        </createStatement>
    </view>
</viewMapping>
```

### 7.3 临时表和内存表处理


**🔸 临时表处理策略**：
```xml
<temporaryTableMapping>
    <!-- 临时表忽略配置 -->
    <ignorePattern>tmp_*</ignorePattern>
    <ignorePattern>temp_*</ignorePattern>
    
    <!-- 临时表转换配置 -->
    <temporaryTable source="tmp_user_import" target="user_import_log">
        <persistent>true</persistent>  <!-- 转为持久表 -->
    </temporaryTable>
</temporaryTableMapping>
```

**🔸 内存表处理**：
```xml
<memoryTableMapping>
    <!-- 内存表同步配置 -->
    <memoryTable source="cache_user" target="cache_user" engine="MEMORY">
        <syncMode>realtime</syncMode>
        <rebuildInterval>3600</rebuildInterval>  <!-- 1小时重建 -->
    </memoryTable>
</memoryTableMapping>
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 表结构映射：告诉Otter源表和目标表的对应关系
🔸 字段映射：指定源字段和目标字段的一一对应关系  
🔸 类型映射：处理不同数据库间的数据类型差异
🔸 字符集转换：解决不同字符编码间的转换问题
🔸 约束映射：保证主键、索引、外键等约束的正确对应
🔸 特殊表处理：分区表、视图、临时表的特殊同步策略
```

### 8.2 关键配置要点


**🔹 映射配置原则**：
```
安全性优先：
- 确保主键映射正确
- 避免数据类型降级
- 字符集兼容性检查

灵活性考虑：
- 支持字段名称转换
- 允许表结构差异
- 提供默认值映射

性能考虑：
- 合理的索引映射
- 避免不必要的类型转换
- 分区表策略优化
```

**🔹 常见配置错误**：
```
❌ 主键字段映射错误 → 数据冲突
❌ 字符集不兼容 → 中文乱码  
❌ 数据类型不匹配 → 同步失败
❌ 字段长度缩短 → 数据截断
❌ 约束条件缺失 → 数据完整性问题
```

### 8.3 实际应用指导


**🎯 映射配置流程**：
```
步骤1：分析源表和目标表结构差异
步骤2：制定字段映射策略
步骤3：配置数据类型转换规则  
步骤4：处理字符集兼容性
步骤5：设置约束和索引映射
步骤6：测试验证映射效果
```

**🔧 映射优化建议**：
- **提前规划**：在同步前充分分析表结构差异
- **逐步验证**：先小批量测试，再全量同步
- **监控告警**：设置映射失败的告警机制
- **文档记录**：详细记录映射规则和变更历史

**💡 最佳实践总结**：
- 保持源表和目标表结构尽可能一致
- 使用统一的命名规范和数据类型
- 定期检查和更新映射配置
- 建立映射配置的版本管理机制

**核心记忆**：
- 表结构映射是数据同步的基础配置
- 字段映射要保证数据的准确对应
- 类型转换要确保数据的完整性和兼容性
- 特殊表结构需要专门的处理策略