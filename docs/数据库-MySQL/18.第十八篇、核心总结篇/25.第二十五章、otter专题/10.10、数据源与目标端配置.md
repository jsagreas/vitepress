---
title: 10、数据源与目标端配置
---
## 📚 目录


1. [数据源配置基础概念](#1-数据源配置基础概念)
2. [MySQL连接池配置详解](#2-MySQL连接池配置详解)
3. [数据库连接参数优化](#3-数据库连接参数优化)
4. [读写分离配置实战](#4-读写分离配置实战)
5. [连接超时与重试机制](#5-连接超时与重试机制)
6. [异构数据库支持](#6-异构数据库支持)
7. [数据库权限配置](#7-数据库权限配置)
8. [连接池监控与调优](#8-连接池监控与调优)
9. [数据源切换机制](#9-数据源切换机制)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 数据源配置基础概念



### 1.1 什么是DataSource数据源



**通俗理解**：数据源就像是**数据库的入口大门**，告诉Otter从哪里读取数据，往哪里写入数据。

```
简单类比：
数据源 = 银行营业网点地址
- 你需要知道银行在哪里（IP地址、端口）
- 需要有账号密码（用户名、密码）
- 需要知道具体要操作哪个账户（数据库名）
```

**DataSource核心作用**：
- **🔗 建立连接**：告诉Otter如何连接到数据库
- **📍 定位数据**：指定具体要同步的数据库和表
- **🔐 身份验证**：提供访问数据库的用户凭证
- **⚙️ 参数控制**：设置连接的各种参数和行为

### 1.2 Otter中的数据源类型



```
源端数据源（Source）：
┌─────────────┐    同步    ┌─────────────┐
│  MySQL A    │  ───────>  │  MySQL B    │
│ (源数据库)   │           │ (目标数据库) │
└─────────────┘           └─────────────┘

Otter支持的数据源：
✅ MySQL          - 最常用的关系型数据库
✅ Oracle         - 企业级数据库
✅ PostgreSQL     - 开源关系型数据库
✅ SQL Server     - 微软数据库
✅ MongoDB        - 文档型数据库
✅ ElasticSearch  - 搜索引擎数据库
```

### 1.3 数据源配置的基本结构



**Otter数据源配置包含**：
- **基础信息**：名称、类型、描述
- **连接信息**：主机、端口、数据库名
- **认证信息**：用户名、密码
- **连接池设置**：最大连接数、超时时间等
- **高级参数**：编码、时区、SSL等

---

## 2. 🏊‍♂️ MySQL连接池配置详解



### 2.1 什么是连接池



**通俗解释**：连接池就像是**餐厅的座位管理系统**。

```
没有连接池的情况：
客户来了 → 临时搭桌子 → 吃完就拆桌子
问题：效率低，资源浪费

有连接池的情况：
客户来了 → 直接坐现成的桌子 → 吃完桌子留着给下一位
优势：效率高，资源复用
```

**连接池的核心价值**：
- **⚡ 提高性能**：避免频繁创建/销毁连接
- **🎛️ 控制并发**：限制同时连接数，保护数据库
- **🔄 资源复用**：连接可以被多次使用
- **📊 便于监控**：统一管理所有数据库连接

### 2.2 MySQL连接池关键参数



| 参数名称 | 作用说明 | 推荐值 | 注意事项 |
|---------|---------|--------|----------|
| **initialSize** | `初始连接数` | `5-10` | 启动时就创建的连接数 |
| **maxActive** | `最大活跃连接数` | `20-50` | 根据并发量调整 |
| **maxIdle** | `最大空闲连接数` | `10-20` | 避免资源浪费 |
| **minIdle** | `最小空闲连接数` | `5-10` | 保证基本可用性 |
| **maxWait** | `获取连接超时时间` | `30000ms` | 避免无限等待 |

### 2.3 连接池配置示例



```xml
<!-- 基础连接池配置 -->
<dataSource>
    <name>mysql-source</name>
    <type>mysql</type>
    
    <!-- 基本连接信息 -->
    <url>jdbc:mysql://192.168.1.100:3306/test_db</url>
    <username>otter_user</username>
    <password>otter_pass</password>
    
    <!-- 连接池核心参数 -->
    <initialSize>10</initialSize>           <!-- 初始连接数 -->
    <maxActive>30</maxActive>               <!-- 最大连接数 -->
    <maxIdle>20</maxIdle>                   <!-- 最大空闲连接 -->
    <minIdle>5</minIdle>                    <!-- 最小空闲连接 -->
    <maxWait>60000</maxWait>                <!-- 获取连接超时60秒 -->
    
    <!-- 连接验证 -->
    <testOnBorrow>true</testOnBorrow>       <!-- 借用时验证 -->
    <testOnReturn>false</testOnReturn>      <!-- 归还时验证 -->
    <testWhileIdle>true</testWhileIdle>     <!-- 空闲时验证 -->
    <validationQuery>SELECT 1</validationQuery> <!-- 验证SQL -->
</dataSource>
```

### 2.4 连接池大小如何确定



**📊 连接池大小计算公式**：
```
基础公式：连接池大小 = 并发用户数 × 平均持有连接时间 / 平均请求处理时间

实际考虑因素：
🔸 数据库服务器性能
🔸 网络延迟情况  
🔸 业务查询复杂度
🔸 系统高峰期并发量

经验值参考：
- 小型系统：10-20个连接
- 中型系统：20-50个连接  
- 大型系统：50-100个连接
- 超大型系统：根据实际测试调整
```

---

## 3. ⚙️ 数据库连接参数优化



### 3.1 JDBC连接URL参数详解



**完整的MySQL连接URL示例**：
```
jdbc:mysql://hostname:port/database?参数1=值1&参数2=值2

实际例子：
jdbc:mysql://192.168.1.100:3306/otter_db?
    useUnicode=true&                    # 使用Unicode编码
    characterEncoding=UTF-8&            # 字符编码UTF-8
    serverTimezone=Asia/Shanghai&       # 时区设置
    useSSL=false&                       # 是否使用SSL
    allowMultiQueries=true&             # 允许多语句查询
    rewriteBatchedStatements=true       # 批量操作优化
```

### 3.2 核心连接参数说明



#### 🌐 字符编码参数


```
useUnicode=true                    # 启用Unicode支持
characterEncoding=UTF-8            # 设置字符编码

作用：确保中文等特殊字符正确传输
重要性：⭐⭐⭐⭐⭐ 必须设置，否则中文乱码
```

#### ⏰ 时区参数  


```
serverTimezone=Asia/Shanghai       # 服务器时区
useLegacyDatetimeCode=false       # 不使用旧的日期时间代码

作用：确保时间字段的正确性
重要性：⭐⭐⭐⭐ 避免时间偏差8小时问题
```

#### 🚀 性能优化参数


```
rewriteBatchedStatements=true      # 批量操作重写
cachePrepStmts=true               # 缓存预编译语句
prepStmtCacheSize=250             # 预编译语句缓存大小
prepStmtCacheSqlLimit=2048        # 缓存SQL的最大长度

作用：提升SQL执行性能
适用场景：大批量数据同步
```

### 3.3 Otter专用连接参数



```xml
<!-- Otter优化的MySQL连接配置 -->
<connectionProperties>
    <!-- 基础编码设置 -->
    <useUnicode>true</useUnicode>
    <characterEncoding>UTF-8</characterEncoding>
    <serverTimezone>Asia/Shanghai</serverTimezone>
    
    <!-- 性能优化 -->
    <rewriteBatchedStatements>true</rewriteBatchedStatements>
    <cachePrepStmts>true</cachePrepStmts>
    <prepStmtCacheSize>500</prepStmtCacheSize>
    
    <!-- 连接保活 -->
    <autoReconnect>true</autoReconnect>
    <failOverReadOnly>false</failOverReadOnly>
    <maxReconnects>3</maxReconnects>
    
    <!-- 超时控制 -->
    <connectTimeout>60000</connectTimeout>      <!-- 连接超时60秒 -->
    <socketTimeout>300000</socketTimeout>       <!-- 读取超时5分钟 -->
</connectionProperties>
```

---

## 4. 🔀 读写分离配置实战



### 4.1 读写分离原理



**什么是读写分离**：
```
传统单库模式：
应用 ──> MySQL主库 (读+写)
问题：单点压力大，性能瓶颈

读写分离模式：
         ┌─> MySQL从库1 (只读)
应用 ────┼─> MySQL从库2 (只读)  
         └─> MySQL主库   (写+少量读)

优势：
✅ 分散读取压力
✅ 提升查询性能  
✅ 提高系统可用性
```

### 4.2 Otter读写分离配置



**配置思路**：为同一个数据源配置多个连接，分别指定读库和写库。

```xml
<!-- 主库配置（负责写操作） -->
<dataSource id="mysql-master">
    <name>MySQL主库</name>
    <type>mysql</type>
    <role>master</role>                    <!-- 标记为主库 -->
    
    <url>jdbc:mysql://192.168.1.100:3306/otter_db</url>
    <username>otter_writer</username>      <!-- 具有写权限的用户 -->
    <password>writer_pass</password>
    
    <!-- 写库连接池设置（相对较小） -->
    <maxActive>20</maxActive>
    <initialSize>5</initialSize>
</dataSource>

<!-- 从库配置（负责读操作） -->
<dataSource id="mysql-slave1">
    <name>MySQL从库1</name>
    <type>mysql</type>
    <role>slave</role>                     <!-- 标记为从库 -->
    
    <url>jdbc:mysql://192.168.1.101:3306/otter_db</url>
    <username>otter_reader</username>      <!-- 只读权限用户 -->
    <password>reader_pass</password>
    
    <!-- 读库连接池设置（相对较大） -->
    <maxActive>50</maxActive>
    <initialSize>10</initialSize>
</dataSource>

<!-- 读写分离路由规则 -->
<dataSourceRouter>
    <writeDataSource>mysql-master</writeDataSource>
    <readDataSources>
        <dataSource>mysql-slave1</dataSource>
        <dataSource>mysql-slave2</dataSource>
    </readDataSources>
    <loadBalancePolicy>round_robin</loadBalancePolicy>  <!-- 轮询负载均衡 -->
</dataSourceRouter>
```

### 4.3 读写分离注意事项



**⚠️ 主从延迟问题**：
```
问题场景：
1. 写入数据到主库 ✅
2. 立即从从库读取 ❌ (数据还未同步)
3. 读取到旧数据

解决方案：
🔸 强制读主库：重要数据写入后立即读取主库
🔸 延迟读取：写入后等待1-2秒再读取从库  
🔸 读写标记：标记哪些操作必须读主库
```

**💡 最佳实践**：
- **写后读主**：写入操作后的立即查询走主库
- **定时任务读从**：定时统计任务优先使用从库
- **降级机制**：从库故障时自动切换到主库
- **监控延迟**：实时监控主从同步延迟

---

## 5. ⏱️ 连接超时与重试机制



### 5.1 超时机制详解



**为什么需要超时控制**：
```
没有超时的问题：
客户端发送请求 ──> 数据库（网络中断）
客户端一直等待...永远等不到响应 ❌

有超时控制：
客户端发送请求 ──> 数据库（网络中断）
等待30秒后超时，返回错误信息 ✅
```

### 5.2 三种关键超时设置



#### 🔗 连接超时（Connection Timeout）


```xml
<connectTimeout>30000</connectTimeout>     <!-- 30秒连接超时 -->

含义：建立数据库连接的最大等待时间
场景：数据库服务器无响应、网络不通
推荐值：10-60秒
```

#### 📖 读取超时（Socket Timeout）


```xml
<socketTimeout>300000</socketTimeout>      <!-- 5分钟读取超时 -->

含义：执行SQL语句的最大等待时间
场景：复杂查询、大数据量操作
推荐值：1-10分钟（根据业务调整）
```

#### 🎯 获取连接超时（Pool Timeout）


```xml
<maxWait>60000</maxWait>                   <!-- 60秒池超时 -->

含义：从连接池获取连接的最大等待时间
场景：连接池耗尽、高并发访问
推荐值：30-120秒
```

### 5.3 重试机制配置



**重试策略设计**：
```
┌─────────────┐    失败    ┌─────────────┐
│  第1次尝试  │ ────────> │  等待2秒    │
└─────────────┘          └─────────────┘
                               │
                         ┌─────────────┐    失败    ┌─────────────┐
                         │  第2次尝试  │ ────────> │  等待4秒    │
                         └─────────────┘          └─────────────┘
                                                        │
                                                  ┌─────────────┐
                                                  │  第3次尝试  │
                                                  └─────────────┘
                                                        │
                                                  最终失败/成功
```

```xml
<!-- Otter重试机制配置 -->
<retryConfig>
    <maxRetries>3</maxRetries>                    <!-- 最大重试次数 -->
    <retryDelay>2000</retryDelay>                 <!-- 初始重试延迟2秒 -->
    <retryMultiplier>2.0</retryMultiplier>        <!-- 延迟倍数因子 -->
    <maxRetryDelay>10000</maxRetryDelay>          <!-- 最大重试延迟10秒 -->
    
    <!-- 可重试的异常类型 -->
    <retryableExceptions>
        <exception>java.net.SocketTimeoutException</exception>
        <exception>com.mysql.jdbc.exceptions.jdbc4.CommunicationsException</exception>
        <exception>java.net.ConnectException</exception>
    </retryableExceptions>
</retryConfig>
```

### 5.4 超时参数调优指南



| 业务场景 | 连接超时 | 读取超时 | 池超时 | 说明 |
|---------|---------|---------|--------|------|
| **OLTP在线业务** | `10秒` | `30秒` | `30秒` | 快速响应，及时失败 |
| **数据同步任务** | `30秒` | `300秒` | `60秒` | 允许较长处理时间 |
| **批量导入** | `60秒` | `600秒` | `120秒` | 大批量操作容忍度高 |
| **实时分析** | `15秒` | `60秒` | `45秒` | 平衡性能和可用性 |

---

## 6. 🔄 异构数据库支持



### 6.1 什么是异构数据库同步



**异构数据库**：不同类型的数据库系统之间进行数据同步。

```
常见异构同步场景：

MySQL → Oracle          # 从开源迁移到企业级
Oracle → MySQL          # 从企业级迁移到开源  
MySQL → PostgreSQL      # 不同开源数据库间
SQL Server → MySQL      # 跨平台数据迁移
MySQL → ElasticSearch   # 关系型到搜索引擎
MySQL → MongoDB         # 关系型到文档型
```

### 6.2 异构同步的挑战



**🎯 数据类型映射**：
```
MySQL数据类型      →    Oracle数据类型
VARCHAR(255)       →    VARCHAR2(255)
TEXT              →    CLOB
BIGINT            →    NUMBER(19)
DATETIME          →    DATE
DECIMAL(10,2)     →    NUMBER(10,2)

问题：不同数据库的数据类型不完全对应
解决：需要配置类型映射规则
```

**📝 SQL语法差异**：
```
MySQL语法：
LIMIT 10 OFFSET 20

Oracle语法：  
WHERE ROWNUM <= 30 AND ROWNUM > 20

PostgreSQL语法：
LIMIT 10 OFFSET 20

解决：Otter自动转换不同数据库的SQL语法
```

### 6.3 Otter异构配置示例



```xml
<!-- MySQL到Oracle的异构同步配置 -->
<heterogeneousSync>
    <!-- 源端：MySQL -->
    <sourceDataSource>
        <type>mysql</type>
        <url>jdbc:mysql://192.168.1.100:3306/source_db</url>
        <username>mysql_user</username>
        <password>mysql_pass</password>
    </sourceDataSource>
    
    <!-- 目标端：Oracle -->
    <targetDataSource>
        <type>oracle</type>
        <url>jdbc:oracle:thin:@192.168.1.200:1521:orcl</url>
        <username>oracle_user</username>
        <password>oracle_pass</password>
    </targetDataSource>
    
    <!-- 数据类型映射规则 -->
    <typeMapping>
        <mapping source="VARCHAR" target="VARCHAR2" />
        <mapping source="TEXT" target="CLOB" />
        <mapping source="BIGINT" target="NUMBER(19)" />
        <mapping source="DATETIME" target="DATE" />
    </typeMapping>
    
    <!-- 字段映射规则 -->
    <fieldMapping>
        <table name="user_info">
            <field source="create_time" target="created_date" />
            <field source="update_time" target="modified_date" />
        </table>
    </fieldMapping>
</heterogeneousSync>
```

### 6.4 异构同步最佳实践



**💡 建议策略**：

1. **📋 提前规划**：
   - 分析源端和目标端的数据类型差异
   - 制定详细的字段映射计划
   - 考虑数据精度损失问题

2. **🧪 充分测试**：
   - 小数据量先行测试
   - 验证特殊字符和边界值
   - 测试各种异常场景

3. **📊 监控告警**：
   - 监控同步失败率
   - 记录类型转换异常
   - 定期检查数据一致性

---

## 7. 🔐 数据库权限配置



### 7.1 Otter所需的数据库权限



**为什么需要特定权限**：
```
Otter需要执行的操作：
✅ 读取源表数据          → 需要SELECT权限
✅ 解析binlog日志       → 需要REPLICATION权限  
✅ 写入目标表数据        → 需要INSERT/UPDATE/DELETE权限
✅ 创建临时表           → 需要CREATE TEMPORARY TABLES权限
✅ 查询表结构信息        → 需要SHOW VIEW权限
```

### 7.2 MySQL权限配置详解



#### 🔍 源库（Source）权限设置


```sql
-- 创建Otter专用用户
CREATE USER 'otter_source'@'%' IDENTIFIED BY 'strong_password_123';

-- 基础读取权限
GRANT SELECT ON source_db.* TO 'otter_source'@'%';

-- binlog读取权限（必需）
GRANT REPLICATION SLAVE ON *.* TO 'otter_source'@'%';
GRANT REPLICATION CLIENT ON *.* TO 'otter_source'@'%';

-- 查看表结构权限
GRANT SHOW VIEW ON source_db.* TO 'otter_source'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

#### ✍️ 目标库（Target）权限设置


```sql
-- 创建Otter目标库用户  
CREATE USER 'otter_target'@'%' IDENTIFIED BY 'strong_password_456';

-- 完整的写入权限
GRANT SELECT, INSERT, UPDATE, DELETE ON target_db.* TO 'otter_target'@'%';

-- 表结构操作权限（用于自动建表）
GRANT CREATE, ALTER, DROP, INDEX ON target_db.* TO 'otter_target'@'%';

-- 临时表权限（用于批量操作）
GRANT CREATE TEMPORARY TABLES ON target_db.* TO 'otter_target'@'%';

-- 锁表权限（确保数据一致性）
GRANT LOCK TABLES ON target_db.* TO 'otter_target'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

### 7.3 权限验证脚本



```sql
-- 验证源库权限
SHOW GRANTS FOR 'otter_source'@'%';

-- 测试binlog权限
SHOW MASTER STATUS;
SHOW SLAVE HOSTS;

-- 验证目标库权限  
SHOW GRANTS FOR 'otter_target'@'%';

-- 测试表操作权限
USE target_db;
CREATE TEMPORARY TABLE test_temp (id INT);
DROP TEMPORARY TABLE test_temp;
```

### 7.4 安全权限配置原则



**🛡️ 最小权限原则**：
```
原则：只给必需的权限，不给多余权限

源库权限控制：
❌ 不给DROP权限      # 防止误删表
❌ 不给CREATE权限    # 防止创建无关对象
❌ 不给SUPER权限     # 防止系统级操作
✅ 只给SELECT和REPLICATION权限

目标库权限控制：
❌ 不给全局权限      # 限制在特定数据库
❌ 不给USER管理权限  # 防止用户管理操作
✅ 只给数据操作相关权限
```

**🔒 网络访问控制**：
```sql
-- 限制特定IP访问（推荐）
CREATE USER 'otter'@'192.168.1.%' IDENTIFIED BY 'password';

-- 限制特定主机访问
CREATE USER 'otter'@'otter-server.company.com' IDENTIFIED BY 'password';

-- 避免使用通配符（不推荐）
CREATE USER 'otter'@'%' IDENTIFIED BY 'password';
```

---

## 8. 📊 连接池监控与调优



### 8.1 连接池关键监控指标



**📈 核心性能指标**：
```
连接池状态指标：
┌─────────────────┬──────────┬─────────────┐
│   指标名称      │ 正常范围  │   异常表现   │
├─────────────────┼──────────┼─────────────┤
│ 活跃连接数      │ 60-80%   │ 持续>90%    │
│ 空闲连接数      │ 20-40%   │ 长期为0     │
│ 等待队列长度    │ <5       │ 持续>10     │
│ 获取连接耗时    │ <100ms   │ >1000ms     │
│ 连接创建频率    │ 低频     │ 频繁创建    │
│ 连接异常率      │ <1%      │ >5%        │
└─────────────────┴──────────┴─────────────┘
```

### 8.2 Otter连接池监控配置



```xml
<!-- 连接池监控配置 -->
<monitoring>
    <!-- 启用JMX监控 -->
    <jmxEnabled>true</jmxEnabled>
    <jmxPort>9999</jmxPort>
    
    <!-- 性能统计 -->
    <statisticsEnabled>true</statisticsEnabled>
    <statisticsInterval>60</statisticsInterval>    <!-- 60秒统计间隔 -->
    
    <!-- 慢查询监控 -->
    <slowQueryThreshold>5000</slowQueryThreshold>  <!-- 5秒慢查询阈值 -->
    <logSlowQueries>true</logSlowQueries>
    
    <!-- 连接泄漏检测 -->
    <connectionLeakDetection>true</connectionLeakDetection>
    <connectionLeakTimeout>300000</connectionLeakTimeout>  <!-- 5分钟超时 -->
</monitoring>
```

### 8.3 性能调优策略



#### 🎯 连接数调优


```
调优步骤：

1️⃣ 确定基准值
监控当前活跃连接数的峰值和平均值

2️⃣ 压力测试  
逐步增加连接数，观察性能拐点

3️⃣ 找到最优值
平衡性能和资源消耗

调优公式：
最优连接数 = CPU核心数 × 2 + 磁盘数量

例如：8核CPU + 2块SSD = 8×2+2 = 18个连接
```

#### ⚡ 超时参数调优


```xml
<!-- 生产环境推荐配置 -->
<connectionTimeout>30000</connectionTimeout>      <!-- 连接超时30秒 -->
<socketTimeout>60000</socketTimeout>              <!-- 读取超时60秒 -->
<maxWait>45000</maxWait>                          <!-- 获取连接超时45秒 -->

<!-- 高并发场景配置 -->
<connectionTimeout>15000</connectionTimeout>      <!-- 快速失败 -->
<socketTimeout>30000</socketTimeout>              <!-- 减少等待时间 -->
<maxWait>20000</maxWait>                          <!-- 及时释放等待 -->
```

### 8.4 监控告警设置



```yaml
# 连接池告警规则示例

alerts:
  - name: "连接池使用率过高"
    condition: "connection_pool_usage > 0.9"
    duration: "2m"
    action: "发送邮件、短信告警"
    
  - name: "获取连接超时"
    condition: "connection_wait_time > 10000"
    duration: "1m"  
    action: "立即告警，检查数据库状态"
    
  - name: "连接异常率过高"
    condition: "connection_error_rate > 0.05"
    duration: "5m"
    action: "告警并自动重启连接池"
```

---

## 9. 🔄 数据源切换机制



### 9.1 为什么需要数据源切换



**典型应用场景**：
```
场景1：数据库故障切换
主库故障 → 自动切换到备库 → 保证业务连续性

场景2：维护窗口切换  
计划维护 → 提前切换到备用库 → 无感知维护

场景3：读写分离切换
写操作 → 主库
读操作 → 从库（多个从库负载均衡）

场景4：跨机房切换
机房A故障 → 自动切换到机房B → 灾备恢复
```

### 9.2 Otter数据源切换配置



#### 🔄 主备切换配置


```xml
<!-- 主备数据源配置 -->
<dataSourceCluster>
    <clusterId>mysql-cluster</clusterId>
    <switchPolicy>auto</switchPolicy>           <!-- 自动切换策略 -->
    
    <!-- 主数据源 -->
    <primary>
        <dataSourceId>mysql-primary</dataSourceId>
        <url>jdbc:mysql://db-master:3306/otter_db</url>
        <username>otter_user</username>
        <password>otter_pass</password>
        <priority>100</priority>                <!-- 优先级：数字越大优先级越高 -->
    </primary>
    
    <!-- 备数据源 -->
    <secondary>
        <dataSourceId>mysql-secondary</dataSourceId>
        <url>jdbc:mysql://db-slave:3306/otter_db</url>
        <username>otter_user</username>
        <password>otter_pass</password>
        <priority>80</priority>
    </secondary>
    
    <!-- 健康检查配置 -->
    <healthCheck>
        <interval>30000</interval>              <!-- 30秒检查一次 -->
        <timeout>5000</timeout>                 <!-- 5秒超时 -->
        <query>SELECT 1</query>                 <!-- 健康检查SQL -->
        <failureThreshold>3</failureThreshold>  <!-- 连续3次失败才切换 -->
    </healthCheck>
</dataSourceCluster>
```

#### ⚖️ 负载均衡配置


```xml
<!-- 多数据源负载均衡 -->
<loadBalancer>
    <algorithm>round_robin</algorithm>          <!-- 轮询算法 -->
    <!-- 可选算法：round_robin, random, least_connections, weighted -->
    
    <dataSources>
        <dataSource weight="50">                <!-- 权重50% -->
            <url>jdbc:mysql://db1:3306/otter_db</url>
        </dataSource>
        <dataSource weight="30">                <!-- 权重30% -->
            <url>jdbc:mysql://db2:3306/otter_db</url>
        </dataSource>
        <dataSource weight="20">                <!-- 权重20% -->
            <url>jdbc:mysql://db3:3306/otter_db</url>
        </dataSource>
    </dataSources>
</loadBalancer>
```

### 9.3 切换策略详解



**🎯 自动切换策略**：
```
故障检测流程：
1. 定时健康检查 (30秒间隔)
2. 检测到连接失败
3. 重试机制 (连续3次)
4. 确认故障后切换
5. 记录切换日志
6. 通知管理员

切换判断条件：
✅ 连接超时
✅ SQL执行异常  
✅ 网络不可达
✅ 数据库服务停止
❌ 慢查询 (不触发切换)
❌ 偶发异常 (重试解决)
```

**🎛️ 手动切换策略**：
```bash
# Otter管理命令

# 查看数据源状态


otter datasource status

# 手动切换到备库


otter datasource switch --from primary --to secondary

# 查看切换历史


otter datasource history

# 回切到主库  


otter datasource switch --from secondary --to primary
```

### 9.4 切换过程的数据一致性



**🔒 切换时的数据保护**：
```
切换前的准备工作：
1. 停止新的写入操作
2. 等待正在执行的事务完成
3. 确保主从数据同步完成
4. 验证备库数据完整性

切换过程：
1. 将流量切换到备库
2. 更新连接池配置
3. 验证新库可用性
4. 恢复业务操作

切换后的验证：
1. 检查数据同步状态
2. 验证业务功能正常
3. 监控性能指标
4. 记录切换日志
```

---

## 10. 📋 核心要点总结



### 10.1 必须掌握的核心概念



```
🔸 DataSource数据源：Otter连接数据库的入口，包含连接信息和参数配置
🔸 连接池管理：复用数据库连接，提高性能和控制并发数量
🔸 连接参数优化：通过JDBC URL参数优化性能和解决兼容性问题
🔸 读写分离：将读操作和写操作分发到不同的数据库实例
🔸 超时与重试：设置合理的超时时间和重试策略，提高系统稳定性
🔸 异构数据库：支持不同类型数据库之间的数据同步
🔸 权限配置：为Otter分配最小必要权限，确保安全性
🔸 监控调优：实时监控连接池状态，及时发现和解决问题
🔸 数据源切换：实现高可用架构，支持故障自动切换
```

### 10.2 关键配置参数速查



| 配置类别 | 关键参数 | 推荐值 | 作用说明 |
|---------|---------|--------|----------|
| **连接池** | `maxActive` | `20-50` | 最大连接数 |
| **连接池** | `initialSize` | `5-10` | 初始连接数 |
| **超时** | `connectTimeout` | `30000` | 连接超时30秒 |
| **超时** | `socketTimeout` | `60000` | 读取超时60秒 |
| **编码** | `characterEncoding` | `UTF-8` | 字符编码 |
| **时区** | `serverTimezone` | `Asia/Shanghai` | 服务器时区 |
| **性能** | `rewriteBatchedStatements` | `true` | 批量优化 |

### 10.3 最佳实践建议



**🎯 生产环境配置清单**：
- ✅ 使用专用的数据库用户，遵循最小权限原则
- ✅ 配置合理的连接池大小，避免资源浪费  
- ✅ 设置适当的超时时间，平衡性能和稳定性
- ✅ 启用连接池监控，及时发现问题
- ✅ 配置主备切换，确保高可用性
- ✅ 定期检查和优化配置参数
- ✅ 建立完善的告警机制

**⚠️ 常见问题避免**：
- ❌ 不要使用root用户连接数据库
- ❌ 不要设置过大的连接池（浪费资源）
- ❌ 不要忽略字符编码设置（导致乱码）
- ❌ 不要使用默认的超时时间（可能太短或太长）
- ❌ 不要在生产环境直接修改配置（先测试后上线）

### 10.4 故障排查指南



**🔍 常见问题诊断**：
```
连接失败问题：
1. 检查网络连通性：ping、telnet
2. 验证用户权限：登录数据库测试
3. 确认防火墙设置：端口是否开放
4. 查看数据库日志：是否有错误信息

性能问题诊断：
1. 监控连接池使用率：是否达到上限
2. 检查慢查询日志：是否有慢SQL
3. 分析网络延迟：是否网络瓶颈
4. 观察数据库负载：CPU、内存、IO使用率

数据同步问题：
1. 检查权限配置：是否有REPLICATION权限
2. 验证binlog设置：是否正确开启
3. 确认数据一致性：主从数据对比
4. 查看同步延迟：监控复制状态
```

**核心记忆要点**：
- 数据源配置是Otter的基础，决定了数据同步的稳定性和性能
- 连接池是性能优化的关键，需要根据业务特点合理配置
- 权限配置关乎安全，遵循最小权限原则
- 监控和切换机制是高可用的保障，必须认真配置和测试