---
title: 14、复杂查询性能优化
---
## 📚 目录

1. [多表JOIN优化](#1-多表JOIN优化)
2. [子查询与EXISTS优化](#2-子查询与EXISTS优化)
3. [UNION查询优化](#3-UNION查询优化)
4. [分组聚合优化](#4-分组聚合优化)
5. [排序查询优化](#5-排序查询优化)
6. [分页查询优化](#6-分页查询优化)
7. [递归查询优化](#7-递归查询优化)
8. [窗口函数性能](#8-窗口函数性能)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔗 多表JOIN优化


### 1.1 JOIN基本概念


**什么是JOIN？**
JOIN就是把多个表按照某种条件"拼接"在一起查询数据，就像拼图一样。

```
想象一下：
用户表(users) + 订单表(orders) = 完整的用户订单信息

用户表：           订单表：              JOIN结果：
id | name         user_id | amount      name | amount
1  | 张三    +    1       | 100    =    张三 | 100
2  | 李四         2       | 200         李四 | 200
```

### 1.2 JOIN类型详解


#### 🔸 INNER JOIN（内连接）


> 📝 **通俗解释**：只返回两个表都有匹配记录的数据
> 
> 就像找"共同好友"，只显示双方都认识的人

```sql
-- ✅ 正确示例：查询有订单的用户
SELECT u.name, o.amount 
FROM users u 
INNER JOIN orders o ON u.id = o.user_id;
```

**性能优化要点**：
- 🎯 **小表驱动大表**：让记录数少的表作为驱动表
- 🔍 **JOIN字段加索引**：连接字段必须有索引
- ⚡ **避免函数运算**：ON条件中不要使用函数

#### 🔸 LEFT JOIN（左连接）


> 📝 **通俗解释**：返回左表所有记录，右表没有匹配的显示NULL
> 
> 就像"以我为准"，我的信息全要，你有就显示，没有就空着

```sql
-- ✅ 查询所有用户及其订单（包括没下过订单的用户）
SELECT u.name, IFNULL(o.amount, 0) as amount
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id;
```

**LEFT JOIN优化技巧**：

| 场景 | **优化方法** | **说明** |
|------|------------|----------|
| 🔍 **过滤右表** | `WHERE right_table.field IS NOT NULL` | 找出有匹配的记录 |
| 🔍 **过滤空值** | `WHERE right_table.field IS NULL` | 找出没匹配的记录 |
| ⚡ **索引优化** | 右表连接字段加索引 | 提高匹配速度 |

### 1.3 JOIN性能优化策略


#### 🎯 驱动表选择原则


```
原则：小表驱动大表

为什么？
┌─────────────────────────────────────┐
│ 大表(100万) JOIN 小表(1000)         │
│ 需要扫描：100万 × 1000 = 10亿次     │
├─────────────────────────────────────┤
│ 小表(1000) JOIN 大表(100万)         │ ← 推荐
│ 需要扫描：1000 × log(100万) ≈ 2万次  │
└─────────────────────────────────────┘
```

**实际应用示例**：
```sql
-- ❌ 效率低：大表驱动小表
SELECT * FROM large_table l 
JOIN small_table s ON l.id = s.large_id;

-- ✅ 效率高：小表驱动大表  
SELECT * FROM small_table s 
JOIN large_table l ON s.large_id = l.id;
```

#### 🔍 索引优化策略


**JOIN字段索引原则**：

```sql
-- 为JOIN字段创建合适索引
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_order_time ON orders(create_time);

-- 复合索引顺序很重要
CREATE INDEX idx_user_time ON orders(user_id, create_time);
```

> ⚠️ **重要提醒**
> 
> 索引不是越多越好！每个索引都会占用存储空间，并且影响INSERT/UPDATE性能

#### ⚡ 避免JOIN中的性能陷阱


**常见性能问题**：

```sql
-- ❌ 错误：ON条件中使用函数
SELECT * FROM users u 
JOIN orders o ON DATE(u.create_time) = DATE(o.create_time);

-- ✅ 正确：提前计算或使用范围查询
SELECT * FROM users u 
JOIN orders o ON u.create_time >= '2024-01-01' 
                AND u.create_time < '2024-01-02'
                AND o.create_time >= '2024-01-01' 
                AND o.create_time < '2024-01-02';
```

### 1.4 多表JOIN优化实战


**场景**：查询用户、订单、商品信息

```sql
-- 🎯 优化前分析
SELECT u.name, o.amount, p.product_name
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id  
JOIN products p ON oi.product_id = p.id
WHERE u.status = 'active';

-- 优化思路：
-- 1. 确定驱动表顺序
-- 2. 添加必要索引
-- 3. 优化WHERE条件
```

**优化后的查询**：
```sql
-- ✅ 优化后版本
SELECT u.name, o.amount, p.product_name
FROM users u 
    STRAIGHT_JOIN orders o ON u.id = o.user_id
    STRAIGHT_JOIN order_items oi ON o.id = oi.order_id
    STRAIGHT_JOIN products p ON oi.product_id = p.id  
WHERE u.status = 'active'
    AND o.status = 'completed';

-- 对应索引设计
CREATE INDEX idx_users_status ON users(status, id);
CREATE INDEX idx_orders_user ON orders(user_id, status);
CREATE INDEX idx_items_order ON order_items(order_id, product_id);
```

---

## 2. 🔍 子查询与EXISTS优化


### 2.1 子查询基本概念


**什么是子查询？**
子查询就是"查询中套查询"，像俄罗斯套娃一样。

```
主查询：我要找用户信息
    └── 子查询：但只要那些下过订单的用户
        └── 更深层：订单金额大于100的
```

### 2.2 子查询分类及性能特点


#### 📊 按返回结果分类


```
标量子查询：返回单个值
┌─────────────────────────────────┐
│ SELECT name FROM users          │
│ WHERE id = (                    │ ← 括号里返回一个ID
│     SELECT user_id FROM orders  │
│     WHERE amount = 1000         │
│ )                              │
└─────────────────────────────────┘

列子查询：返回一列值  
┌─────────────────────────────────┐
│ SELECT name FROM users          │
│ WHERE id IN (                   │ ← 括号里返回多个ID
│     SELECT user_id FROM orders  │
│     WHERE amount > 100          │
│ )                              │
└─────────────────────────────────┘
```

#### 🔄 按执行方式分类


**相关子查询 vs 非相关子查询**

```sql
-- 非相关子查询（推荐）：子查询可以独立执行
SELECT * FROM users 
WHERE city IN (
    SELECT city FROM branches  -- 这个子查询独立执行一次
    WHERE region = 'north'
);

-- 相关子查询（谨慎使用）：需要外层查询的值
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o     -- 这个子查询要执行N次
    WHERE o.user_id = u.id     -- 依赖外层的u.id
);
```

### 2.3 子查询性能优化技巧


#### 🔄 子查询改JOIN


**核心思路**：把嵌套查询"拉平"成连接查询

```sql
-- ❌ 性能差：子查询版本
SELECT u.name, u.email
FROM users u 
WHERE u.id IN (
    SELECT o.user_id 
    FROM orders o 
    WHERE o.amount > 1000
);

-- ✅ 性能好：JOIN版本
SELECT DISTINCT u.name, u.email
FROM users u 
JOIN orders o ON u.id = o.user_id 
WHERE o.amount > 1000;
```

**为什么JOIN更快？**
```
子查询执行过程：
1. 执行子查询 → 得到用户ID列表
2. 外层查询逐个匹配 → 需要多次表扫描

JOIN执行过程：
1. 两表直接关联 → 一次性完成匹配
2. 利用索引优化 → 大大减少扫描次数
```

#### 🎯 EXISTS vs IN 选择


```sql
-- 当子查询结果集小时，用IN
SELECT * FROM users 
WHERE city IN ('北京', '上海', '广州');  -- 只有3个值

-- 当子查询结果集大时，用EXISTS  
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.user_id = u.id 
    AND o.status = 'active'
);
```

**性能对比**：

| 场景 | **IN适用** | **EXISTS适用** | **原因** |
|------|-----------|---------------|----------|
| 🔍 **子查询结果少** | ✅ | ❌ | IN可以利用索引快速匹配 |
| 🔍 **子查询结果多** | ❌ | ✅ | EXISTS短路求值，找到就停止 |
| 🔍 **需要去重** | ✅ | ❌ | IN天然去重 |
| 🔍 **只关心存在性** | ❌ | ✅ | EXISTS语义更明确 |

### 2.4 复杂子查询优化实战


**场景**：查找每个部门薪资最高的员工

```sql
-- ❌ 低效版本：相关子查询
SELECT e1.name, e1.department, e1.salary
FROM employees e1
WHERE e1.salary = (
    SELECT MAX(e2.salary)      -- 对每个员工都要执行一次
    FROM employees e2 
    WHERE e2.department = e1.department
);

-- ✅ 高效版本1：窗口函数
SELECT name, department, salary
FROM (
    SELECT name, department, salary,
           ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as rn
    FROM employees
) t WHERE rn = 1;

-- ✅ 高效版本2：JOIN子查询  
SELECT e.name, e.department, e.salary
FROM employees e
JOIN (
    SELECT department, MAX(salary) as max_salary
    FROM employees 
    GROUP BY department
) dept_max ON e.department = dept_max.department 
           AND e.salary = dept_max.max_salary;
```

---

## 3. 🔗 UNION查询优化


### 3.1 UNION基本概念


**什么是UNION？**
UNION就是把多个查询结果"叠加"起来，像搭积木一样把结果摞在一起。

```
查询1结果：  查询2结果：     UNION结果：
张三          王五           张三
李四          赵六           李四  
            ↓               王五
          叠加合并           赵六
```

### 3.2 UNION vs UNION ALL


```sql
-- UNION：会去重，性能较慢
SELECT name FROM table1 
UNION 
SELECT name FROM table2;

-- UNION ALL：不去重，性能更快
SELECT name FROM table1 
UNION ALL 
SELECT name FROM table2;
```

**选择原则**：

> 💡 **使用建议**
> 
> - ✅ **确定无重复**：使用UNION ALL
> - ✅ **必须去重**：使用UNION  
> - ✅ **不确定但要求性能**：先用UNION ALL，再手动去重

### 3.3 UNION查询优化技巧


#### 🎯 减少UNION子查询数量


```sql
-- ❌ 效率低：多个UNION
SELECT * FROM orders WHERE status = 'pending'
UNION ALL
SELECT * FROM orders WHERE status = 'processing'  
UNION ALL
SELECT * FROM orders WHERE status = 'shipping';

-- ✅ 效率高：用IN条件
SELECT * FROM orders 
WHERE status IN ('pending', 'processing', 'shipping');
```

#### 📊 UNION结果排序优化


```sql
-- ❌ 错误：每个子查询都排序
(SELECT * FROM table1 ORDER BY create_time)
UNION ALL  
(SELECT * FROM table2 ORDER BY create_time)
ORDER BY create_time;  -- 最终还要重新排序

-- ✅ 正确：只在最后排序
SELECT * FROM table1
UNION ALL
SELECT * FROM table2  
ORDER BY create_time;
```

#### 🔍 利用索引优化UNION


```sql
-- 为UNION的每个子查询优化索引
CREATE INDEX idx_orders_status_time ON orders(status, create_time);
CREATE INDEX idx_archive_status_time ON orders_archive(status, create_time);

-- 优化后的查询
SELECT order_id, amount, create_time
FROM orders 
WHERE status = 'completed' AND create_time >= '2024-01-01'
UNION ALL
SELECT order_id, amount, create_time  
FROM orders_archive
WHERE status = 'completed' AND create_time >= '2024-01-01'
ORDER BY create_time DESC;
```

---

## 4. 📊 分组聚合优化


### 4.1 GROUP BY基本概念


**什么是GROUP BY？**
GROUP BY就是把数据按某个条件"分堆"，然后对每堆数据做统计。

```
原始订单数据：           GROUP BY user_id后：
user_id | amount         user_id | 总金额
   1    |  100              1    |  300  (100+200)
   1    |  200              2    |  150  (150)  
   2    |  150              3    |  400  (400)
   3    |  400
```

### 4.2 GROUP BY性能优化


#### 🔍 索引优化GROUP BY


```sql
-- 为GROUP BY字段创建索引
CREATE INDEX idx_orders_user_time ON orders(user_id, create_time);

-- 优化查询
SELECT user_id, COUNT(*), SUM(amount)
FROM orders 
WHERE create_time >= '2024-01-01'
GROUP BY user_id;
```

**索引选择原则**：
- 🎯 **WHERE条件字段** + **GROUP BY字段** 的复合索引
- ⚡ **顺序很重要**：WHERE条件字段在前，GROUP BY字段在后

#### 📈 HAVING vs WHERE 优化


```sql
-- ❌ 效率低：用HAVING过滤
SELECT user_id, COUNT(*) as order_count
FROM orders 
GROUP BY user_id
HAVING COUNT(*) > 5;        -- 分组后过滤，扫描所有数据

-- ✅ 效率高：用WHERE预先过滤
SELECT user_id, COUNT(*) as order_count  
FROM orders 
WHERE create_time >= '2024-01-01'  -- 先过滤再分组
GROUP BY user_id
HAVING COUNT(*) > 5;
```

> 💡 **记忆口诀**
> 
> WHERE是"事前诸葛亮"，HAVING是"事后诸葛亮"  
> 能用WHERE过滤的，绝不用HAVING

#### 🎯 聚合函数优化技巧


**选择合适的聚合函数**：

```sql
-- 场景：统计每个用户的订单状态分布

-- ❌ 效率一般：多次扫描
SELECT user_id,
       SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
       SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending
FROM orders GROUP BY user_id;

-- ✅ 效率更好：利用索引
-- 为status字段创建索引，分别查询
SELECT user_id, COUNT(*) as completed_count
FROM orders 
WHERE status = 'completed'
GROUP BY user_id;
```

### 4.3 大数据量分组优化


#### 📊 分区分组


```sql
-- 利用分区表优化大数据量分组
-- 按时间分区的订单表
SELECT DATE(create_time) as order_date, 
       COUNT(*), 
       SUM(amount)
FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2024-02-01'    -- 只扫描1月的分区
GROUP BY DATE(create_time);
```

#### ⚡ 预聚合优化


```sql
-- 创建汇总表，定期更新
CREATE TABLE daily_order_summary (
    order_date DATE,
    user_count INT,
    order_count INT,
    total_amount DECIMAL(10,2),
    PRIMARY KEY (order_date)
);

-- 查询时直接使用汇总表
SELECT * FROM daily_order_summary 
WHERE order_date >= '2024-01-01';
```

---

## 5. 📈 排序查询优化


### 5.1 ORDER BY基本原理


**MySQL排序过程**：

```
排序执行流程：
┌─────────────────────┐
│ 1. 扫描数据         │
├─────────────────────┤  
│ 2. 加载到内存       │ ← sort_buffer_size
├─────────────────────┤
│ 3. 内存排序         │ ← 够用就快速排序
├─────────────────────┤
│ 4. 磁盘排序         │ ← 不够就磁盘归并排序
├─────────────────────┤
│ 5. 返回结果         │
└─────────────────────┘
```

### 5.2 利用索引优化排序


#### 🔍 单字段排序优化


```sql
-- 创建排序字段索引
CREATE INDEX idx_orders_create_time ON orders(create_time);

-- 优化后查询（利用索引顺序）
SELECT * FROM orders 
ORDER BY create_time DESC    -- 直接利用索引顺序
LIMIT 10;
```

**索引排序的好处**：
- ✅ **避免filesort**：不需要额外排序操作
- ✅ **减少内存使用**：不需要sort_buffer
- ✅ **提高响应速度**：直接按索引顺序返回

#### 📊 复合字段排序优化


```sql
-- 多字段排序索引设计
CREATE INDEX idx_orders_status_time ON orders(status, create_time);

-- 可以利用索引的查询
SELECT * FROM orders 
WHERE status = 'completed'
ORDER BY create_time DESC;      -- ✅ 利用索引

-- 无法利用索引的查询  
SELECT * FROM orders 
ORDER BY status, amount;        -- ❌ 没有对应索引
```

**索引排序规则**：
- 🎯 **顺序必须匹配**：索引字段顺序要和ORDER BY一致
- 🎯 **方向要一致**：都是ASC或都是DESC
- 🎯 **WHERE + ORDER BY**：WHERE字段要在ORDER BY字段前面

### 5.3 排序性能优化技巧


#### ⚡ 减少排序字段数量


```sql
-- ❌ 排序字段过多
SELECT * FROM orders 
ORDER BY create_time, user_id, amount, status;

-- ✅ 只保留必要排序字段
SELECT * FROM orders 
ORDER BY create_time DESC;
```

#### 🎯 排序 + 分页优化


```sql
-- ❌ 深分页性能差
SELECT * FROM orders 
ORDER BY create_time 
LIMIT 100000, 10;      -- 需要排序10万+10条记录

-- ✅ 利用索引优化深分页
SELECT * FROM orders 
WHERE create_time < (
    SELECT create_time FROM orders 
    ORDER BY create_time 
    LIMIT 100000, 1
)
ORDER BY create_time DESC 
LIMIT 10;
```

---

## 6. 📄 分页查询优化


### 6.1 分页基本概念


**什么是分页？**
分页就是把大量数据"分成小份"显示，像看书一样一页一页翻。

```
数据总量：10000条
每页显示：20条
总页数：500页

第1页：LIMIT 0, 20    (第1-20条)
第2页：LIMIT 20, 20   (第21-40条)  
第3页：LIMIT 40, 20   (第41-60条)
...
```

### 6.2 传统分页的性能问题


**LIMIT深分页问题**：

```sql
-- 查看执行计划会发现问题
EXPLAIN SELECT * FROM orders 
ORDER BY create_time 
LIMIT 100000, 20;

-- MySQL需要：
-- 1. 扫描并排序100020条记录
-- 2. 跳过前100000条
-- 3. 返回接下来20条
```

**性能损耗分析**：
```
页数越深，性能越差：

第1页  (0,20)     : 0.001秒
第100页(2000,20)  : 0.01秒  
第1000页(20000,20): 0.1秒
第10000页...      : 1秒+    ← 用户无法接受
```

### 6.3 分页优化方案


#### 🎯 基于游标的分页（推荐）


**核心思路**：记住上一页的最后一个位置，从这个位置往后取数据

```sql
-- 第一页
SELECT * FROM orders 
WHERE create_time >= '2024-01-01'
ORDER BY create_time DESC 
LIMIT 20;

-- 第二页（假设第一页最后一条的create_time是'2024-01-15 10:30:00'）
SELECT * FROM orders 
WHERE create_time >= '2024-01-01'
  AND create_time < '2024-01-15 10:30:00'  -- 游标位置
ORDER BY create_time DESC 
LIMIT 20;
```

**游标分页优势**：
- ✅ **性能稳定**：无论多深的页面，速度都一样快
- ✅ **数据一致**：不会因为新增数据导致重复显示
- ❌ **无法跳页**：只能顺序翻页，不能直接跳到第N页

#### 📊 子查询分页优化


```sql
-- ❌ 原始低效查询
SELECT * FROM orders 
ORDER BY create_time 
LIMIT 100000, 20;

-- ✅ 子查询优化版本
SELECT o.* FROM orders o
JOIN (
    SELECT id FROM orders 
    ORDER BY create_time 
    LIMIT 100000, 20
) tmp ON o.id = tmp.id
ORDER BY o.create_time;
```

**为什么子查询更快？**
```
原理解析：
1. 内层查询只选择ID字段，减少数据传输
2. 利用覆盖索引，避免回表查询  
3. 外层JOIN只需要20次精确匹配
```

#### 🔢 记录总数优化


```sql
-- ❌ 每次都统计总数（慢）
SELECT COUNT(*) FROM orders WHERE status = 'active';
SELECT * FROM orders WHERE status = 'active' LIMIT 0, 20;

-- ✅ 缓存总数或近似统计
-- 方案1：Redis缓存总数
-- 方案2：使用近似值
SELECT TABLE_ROWS FROM information_schema.TABLES 
WHERE TABLE_NAME = 'orders';
```

### 6.4 不同场景的分页方案


**选择分页方案的决策树**：

```
需要分页查询？
├─ 是否需要跳页？
│  ├─ 需要 → 子查询优化 + 缓存
│  └─ 不需要 → 游标分页（推荐）
└─ 数据量大小？  
   ├─ <10万 → 传统LIMIT可接受
   └─ >10万 → 必须优化
```

---

## 7. 🔄 递归查询优化


### 7.1 递归查询基本概念


**什么是递归查询？**
递归查询用于处理"树形结构"数据，比如组织架构、分类目录等。

```
公司组织架构示例：
     CEO(id=1)
     /        \
  CTO(id=2)   CFO(id=3) 
   /     \        |
研发(id=4) 测试(id=5) 财务(id=6)

数据库存储：
id | name | parent_id
1  | CEO  | NULL
2  | CTO  | 1  
3  | CFO  | 1
4  | 研发  | 2
5  | 测试  | 2  
6  | 财务  | 3
```

### 7.2 MySQL 8.0 CTE递归查询


```sql
-- 查询某部门的所有下级部门
WITH RECURSIVE dept_tree AS (
    -- 基础查询：起始点
    SELECT id, name, parent_id, 1 as level
    FROM departments 
    WHERE id = 2  -- 从CTO开始
    
    UNION ALL
    
    -- 递归查询：下一层
    SELECT d.id, d.name, d.parent_id, dt.level + 1
    FROM departments d
    JOIN dept_tree dt ON d.parent_id = dt.id
    WHERE dt.level < 10  -- 防止无限递归
)
SELECT * FROM dept_tree;
```

### 7.3 递归查询优化技巧


#### 🔍 索引优化


```sql
-- 为递归查询创建专门索引
CREATE INDEX idx_dept_parent ON departments(parent_id);
CREATE INDEX idx_dept_id_parent ON departments(id, parent_id);
```

#### ⚡ 深度限制


```sql
-- 设置递归深度限制，避免死循环
SET SESSION cte_max_recursion_depth = 100;

WITH RECURSIVE tree AS (
    SELECT id, parent_id, 1 as depth
    FROM categories WHERE parent_id IS NULL
    
    UNION ALL
    
    SELECT c.id, c.parent_id, t.depth + 1  
    FROM categories c
    JOIN tree t ON c.parent_id = t.id
    WHERE t.depth < 5  -- 最多5层
)
SELECT * FROM tree;
```

#### 📊 替代方案：路径枚举


**对于读多写少的场景，可以预先计算路径**：

```sql
-- 添加路径字段
ALTER TABLE categories ADD COLUMN path VARCHAR(500);

-- 预先计算并存储完整路径  
UPDATE categories SET path = '/1/2/4/' WHERE id = 4;

-- 查询时直接使用路径匹配
SELECT * FROM categories 
WHERE path LIKE '/1/2/%';  -- 查找id=2下的所有子分类
```

---

## 8. 🏃 窗口函数性能


### 8.1 窗口函数基本概念


**什么是窗口函数？**
窗口函数可以在结果集上"开一个窗口"，对窗口内的数据进行计算，比如排名、累计等。

```sql
-- 计算每个用户的订单排名
SELECT user_id, amount, create_time,
       ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY amount DESC) as rank_in_user
FROM orders;
```

**结果示例**：
```
user_id | amount | create_time | rank_in_user
   1    |  500   | 2024-01-15  |      1
   1    |  300   | 2024-01-10  |      2  
   1    |  100   | 2024-01-05  |      3
   2    |  800   | 2024-01-20  |      1
   2    |  200   | 2024-01-12  |      2
```

### 8.2 常用窗口函数性能对比


#### 📊 排名函数性能


| 函数 | **用途** | **性能** | **使用场景** |
|------|----------|----------|-------------|
| `ROW_NUMBER()` | 连续排名 | ⚡⚡⚡ 最快 | 分页、去重 |
| `RANK()` | 跳跃排名 | ⚡⚡ 较快 | 成绩排名 |
| `DENSE_RANK()` | 密集排名 | ⚡ 一般 | 等级划分 |

```sql
-- 性能最好的分页方案
SELECT * FROM (
    SELECT *, ROW_NUMBER() OVER(ORDER BY create_time) as rn
    FROM orders
) t WHERE rn BETWEEN 100 AND 120;
```

#### 📈 聚合窗口函数优化


```sql
-- ❌ 性能一般：每行都计算累计值
SELECT user_id, amount, create_time,
       SUM(amount) OVER(PARTITION BY user_id ORDER BY create_time 
                       ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as cumulative
FROM orders;

-- ✅ 性能更好：限制窗口大小
SELECT user_id, amount, create_time,
       AVG(amount) OVER(PARTITION BY user_id ORDER BY create_time 
                       ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg
FROM orders;
```

### 8.3 窗口函数优化策略


#### 🔍 合理设计PARTITION BY


```sql
-- 为PARTITION BY字段创建索引
CREATE INDEX idx_orders_user_time ON orders(user_id, create_time);

-- 利用索引的窗口查询
SELECT user_id, amount,
       ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY create_time) as seq
FROM orders 
WHERE user_id IN (1, 2, 3);  -- 减少分区数量
```

#### ⚡ 避免复杂窗口表达式


```sql
-- ❌ 复杂窗口表达式
SELECT *,
       LAG(amount, 1) OVER(PARTITION BY user_id ORDER BY create_time) as prev_amount,
       LEAD(amount, 1) OVER(PARTITION BY user_id ORDER BY create_time) as next_amount  
FROM orders;

-- ✅ 简化或分步处理
-- 先用简单窗口函数，再进行二次处理
```

---

## 9. 📋 核心要点总结


### 9.1 查询优化核心原则


> 💡 **优化金字塔**
> 
> ```
>      避免全表扫描
>     ────────────────
>    │   利用索引查询   │
>   ──────────────────── 
>  │  减少数据传输量    │
> ────────────────────────
>│    选择合适的算法    │
>──────────────────────────
> ```

### 9.2 必须掌握的核心技能


**🔸 JOIN优化**：
- 小表驱动大表原则
- JOIN字段必须有索引
- 避免在ON条件中使用函数

**🔸 子查询优化**：
- 优先考虑改写为JOIN
- EXISTS vs IN的选择策略
- 避免相关子查询

**🔸 分页优化**：  
- 深分页用游标方案
- 子查询优化传统分页
- 合理缓存总数统计

**🔸 排序优化**：
- 利用索引避免filesort
- 复合索引顺序设计
- 减少不必要的排序字段

### 9.3 性能优化检查清单


**📋 查询前检查**：
- [ ] 是否有合适的索引？
- [ ] WHERE条件是否能利用索引？
- [ ] JOIN方式是否合理？
- [ ] 是否返回了不必要的字段？

**📋 执行后检查**：
- [ ] 查看EXPLAIN执行计划
- [ ] 检查是否有全表扫描
- [ ] 确认索引是否被使用
- [ ] 评估查询响应时间

### 9.4 实战优化思路


```
性能问题排查流程：

1. 发现问题 → 慢查询日志
2. 分析原因 → EXPLAIN执行计划  
3. 制定方案 → 索引/改写/分解
4. 实施优化 → 测试验证
5. 监控效果 → 持续观察
```

> ⚠️ **重要提醒**
> 
> 优化是一个持续过程，不要过度优化！
> 先解决最主要的性能瓶颈，再考虑细节优化

**🎯 学习建议**：
- 📚 多实践不同场景的查询优化
- 🔍 养成查看执行计划的习惯  
- ⚡ 关注业务场景选择合适方案
- 📊 定期review和优化现有查询

**核心记忆口诀**：
- 索引先行，小表驱动大表  
- 子查询改JOIN，分页用游标
- 排序利用索引，窗口控制大小
- 执行计划要看，优化效果要量