---
title: 12、索引性能分析与监控
---
## 📚 目录

1. [索引性能监控概述](#1-索引性能监控概述)
2. [索引使用率统计分析](#2-索引使用率统计分析)
3. [索引效率深度分析](#3-索引效率深度分析)
4. [索引扫描类型识别](#4-索引扫描类型识别)
5. [关键性能监控指标](#5-关键性能监控指标)
6. [慢查询索引分析实战](#6-慢查询索引分析实战)
7. [索引建议工具使用](#7-索引建议工具使用)
8. [性能基准测试方法](#8-性能基准测试方法)
9. [索引优化效果评估](#9-索引优化效果评估)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引性能监控概述


### 1.1 什么是索引性能监控


**简单理解**：就像体检一样，定期检查索引的"健康状况"

```
生活类比：
体检报告 → 了解身体状况
索引监控 → 了解索引效果

体检指标：血压、心率、血糖...
索引指标：使用率、扫描行数、命中率...
```

**核心概念**：
- **监控目的**：发现哪些索引有用，哪些没用，哪些需要优化
- **监控对象**：索引使用情况、查询性能、资源消耗
- **监控意义**：避免盲目建索引，提升数据库整体性能

### 1.2 为什么要做索引监控


**现实问题场景**：
```
问题1：索引建了很多，但不知道哪个有用
解决：通过使用率统计，清理无用索引

问题2：查询很慢，不知道索引是否生效  
解决：通过执行计划分析，优化索引设计

问题3：数据库越来越慢，找不到原因
解决：通过性能监控，定位性能瓶颈
```

### 1.3 监控体系架构


```
索引性能监控体系：

   ┌─────────────────┐
   │   应用查询      │
   └─────────┬───────┘
             │
   ┌─────────▼───────┐
   │ MySQL执行引擎   │ ← 记录执行统计
   └─────────┬───────┘
             │
   ┌─────────▼───────┐
   │   监控收集      │ ← performance_schema
   └─────────┬───────┘          information_schema
             │                  慢查询日志
   ┌─────────▼───────┐
   │   分析工具      │ ← EXPLAIN、pt-tools
   └─────────┬───────┘          MySQL Workbench
             │
   ┌─────────▼───────┐
   │   优化建议      │ ← 生成优化方案
   └─────────────────┘
```

---

## 2. 📊 索引使用率统计分析


### 2.1 查看索引使用情况


**基础查询 - 查看哪些索引被使用**：

```sql
-- 查看索引使用统计（MySQL 5.7+）
SELECT 
    object_schema,
    object_name,
    index_name,
    count_fetch,
    count_insert,
    count_update,
    count_delete
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE object_schema = 'your_database'
ORDER BY count_fetch DESC;
```

**实用解释**：
- `count_fetch`：索引被用于查询的次数（重点关注）
- `count_insert/update/delete`：写操作时索引维护次数
- **数值为0表示索引从未被使用**

### 2.2 识别无用索引


**找出从未使用的索引**：

```sql
-- 查找无用索引
SELECT 
    t.table_schema,
    t.table_name,
    t.index_name,
    t.index_type
FROM information_schema.statistics t
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p 
    ON t.table_schema = p.object_schema 
    AND t.table_name = p.object_name 
    AND t.index_name = p.index_name
WHERE t.table_schema = 'your_database'
    AND t.index_name != 'PRIMARY'  -- 排除主键
    AND p.index_name IS NULL       -- 从未被使用
ORDER BY t.table_name, t.index_name;
```

**实战建议**：
```
发现无用索引后的处理：
1. 确认索引确实无用（观察一段时间）
2. 在测试环境删除验证
3. 生产环境谨慎删除
4. 删除前做好备份
```

### 2.3 索引使用率分析


**计算索引使用率**：

```sql
-- 计算索引使用频率
SELECT 
    object_name AS table_name,
    index_name,
    count_fetch AS select_count,
    count_insert AS insert_count,
    count_update AS update_count,
    count_delete AS delete_count,
    (count_fetch + count_insert + count_update + count_delete) AS total_usage,
    ROUND(count_fetch / (count_fetch + count_insert + count_update + count_delete + 1) * 100, 2) AS read_ratio
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
    AND count_fetch > 0
ORDER BY total_usage DESC;
```

**指标含义解释**：
- `total_usage > 1000`：高频使用索引，重点保护
- `read_ratio > 80%`：主要用于查询，优化查询性能
- `read_ratio < 20%`：主要用于写入，考虑写入性能影响

---

## 3. 🔍 索引效率深度分析


### 3.1 索引选择性分析


**什么是选择性**：
选择性 = 不重复值数量 / 总记录数

```
理解选择性：
身份证号选择性 ≈ 1.0  （几乎唯一）
性别选择性 ≈ 0.5      （只有男女两种）
状态选择性 ≈ 0.1      （可能只有几种状态）

选择性越高，索引效果越好！
```

**计算索引选择性**：

```sql
-- 分析字段选择性
SELECT 
    'user_id' AS column_name,
    COUNT(DISTINCT user_id) AS distinct_values,
    COUNT(*) AS total_rows,
    COUNT(DISTINCT user_id) / COUNT(*) AS selectivity,
    CASE 
        WHEN COUNT(DISTINCT user_id) / COUNT(*) > 0.8 THEN '高选择性-建议建索引'
        WHEN COUNT(DISTINCT user_id) / COUNT(*) > 0.3 THEN '中选择性-考虑建索引'  
        ELSE '低选择性-不建议建索引'
    END AS recommendation
FROM user_table

UNION ALL

SELECT 
    'status',
    COUNT(DISTINCT status),
    COUNT(*),
    COUNT(DISTINCT status) / COUNT(*),
    CASE 
        WHEN COUNT(DISTINCT status) / COUNT(*) > 0.8 THEN '高选择性-建议建索引'
        WHEN COUNT(DISTINCT status) / COUNT(*) > 0.3 THEN '中选择性-考虑建索引'  
        ELSE '低选择性-不建议建索引'
    END
FROM user_table;
```

### 3.2 索引碎片分析


**什么是索引碎片**：
就像书籍页码乱了，需要重新整理才能快速找到内容

```sql
-- 检查索引碎片情况
SELECT 
    table_schema,
    table_name,
    ROUND(data_length/1024/1024, 2) AS data_mb,
    ROUND(index_length/1024/1024, 2) AS index_mb,
    ROUND(data_free/1024/1024, 2) AS free_mb,
    ROUND(data_free/(data_length + index_length) * 100, 2) AS fragmentation_ratio
FROM information_schema.tables 
WHERE table_schema = 'your_database'
    AND data_free > 0
ORDER BY fragmentation_ratio DESC;
```

**碎片处理建议**：
```
碎片率 > 30%：严重碎片，需要优化
处理方法：
- OPTIMIZE TABLE table_name;  （MyISAM引擎）
- ALTER TABLE table_name ENGINE=InnoDB;  （InnoDB引擎）
```

### 3.3 索引基数分析


**查看索引基数统计**：

```sql
-- 检查索引基数是否准确
SELECT 
    table_schema,
    table_name,
    index_name,
    cardinality,
    CASE 
        WHEN cardinality IS NULL OR cardinality = 0 THEN '需要更新统计信息'
        WHEN cardinality < 100 THEN '低基数索引'
        WHEN cardinality > 10000 THEN '高基数索引'
        ELSE '中等基数索引'
    END AS cardinality_level
FROM information_schema.statistics
WHERE table_schema = 'your_database'
    AND index_name != 'PRIMARY'
ORDER BY cardinality DESC;
```

**基数优化**：
```sql
-- 更新索引统计信息
ANALYZE TABLE table_name;

-- 重建索引（如果基数严重不准确）
ALTER TABLE table_name DROP INDEX index_name, ADD INDEX index_name (column_name);
```

---

## 4. 🔎 索引扫描类型识别


### 4.1 执行计划中的扫描类型


**各种扫描类型含义**：

| 扫描类型 | **性能** | **含义** | **优化建议** |
|---------|---------|----------|-------------|
| `const` | ⭐⭐⭐⭐⭐ | `主键或唯一索引等值查询` | `最优，无需优化` |
| `eq_ref` | ⭐⭐⭐⭐⭐ | `唯一索引扫描` | `很好，保持现状` |
| `ref` | ⭐⭐⭐⭐ | `非唯一索引等值查询` | `良好，可考虑复合索引` |
| `range` | ⭐⭐⭐ | `索引范围扫描` | `还行，注意范围大小` |
| `index` | ⭐⭐ | `索引全扫描` | `较差，考虑添加WHERE条件` |
| `ALL` | ⭐ | `全表扫描` | `最差，必须优化` |

### 4.2 实战扫描类型分析


**分析具体查询的扫描类型**：

```sql
-- 示例查询
EXPLAIN 
SELECT * FROM orders 
WHERE customer_id = 1001 
  AND order_date >= '2024-01-01';

-- 结果解读
```

```
执行计划示例：
+----+-------------+--------+-------+-------------------+-------------------+
| id | select_type | table  | type  | possible_keys     | key               |
+----+-------------+--------+-------+-------------------+-------------------+
|  1 | SIMPLE      | orders | ref   | idx_customer_id   | idx_customer_id   |
+----+-------------+--------+-------+-------------------+-------------------+

解读：
- type=ref：使用了非唯一索引，性能良好
- key=idx_customer_id：实际使用了customer_id索引
- 建议：可考虑创建(customer_id, order_date)复合索引
```

### 4.3 监控扫描类型分布


**统计不同扫描类型的查询分布**：

```sql
-- 使用pt-query-digest分析慢查询日志中的扫描类型
-- 这里展示分析思路

/*
扫描类型分布分析：
const/eq_ref: 30%  ← 优秀查询
ref: 40%           ← 良好查询  
range: 20%         ← 可接受查询
index/ALL: 10%     ← 需要优化的查询

目标：
- 提高const/eq_ref/ref比例到80%以上
- 降低ALL类型扫描到5%以下
*/
```

---

## 5. 📈 关键性能监控指标


### 5.1 核心性能指标


**索引相关的关键指标**：

```sql
-- 查看索引相关的全局状态
SHOW GLOBAL STATUS WHERE Variable_name IN (
    'Handler_read_first',      -- 索引第一个条目被读取次数
    'Handler_read_key',        -- 通过索引读取行的次数
    'Handler_read_next',       -- 按索引顺序读取下一行次数
    'Handler_read_rnd',        -- 按固定位置读取行的次数
    'Handler_read_rnd_next',   -- 读取下一行的次数（全表扫描）
    'Created_tmp_tables',      -- 创建临时表的次数
    'Created_tmp_disk_tables', -- 创建磁盘临时表的次数
    'Select_full_join',        -- 没有使用索引的JOIN次数
    'Select_range',            -- 使用范围的查询次数
    'Select_scan',             -- 全表扫描次数
    'Sort_merge_passes',       -- 排序算法合并次数
    'Sort_range',              -- 范围排序次数
    'Sort_scan'                -- 全表扫描排序次数
);
```

### 5.2 性能指标解读


**指标含义和优化目标**：

```
✅ 良好指标：
Handler_read_key / Handler_read_rnd_next > 100:1
- 说明：索引读取远多于全表扫描，索引效果好

❌ 问题指标：
Created_tmp_disk_tables / Created_tmp_tables > 0.1
- 说明：超过10%的临时表需要写入磁盘，内存不足

Select_full_join > 0
- 说明：存在没有使用索引的JOIN，需要优化

实际监控示例：
Handler_read_key: 1,000,000        （通过索引读取）
Handler_read_rnd_next: 10,000      （全表扫描读取）  
比例: 100:1 ← 很好的索引使用率
```

### 5.3 实时性能监控设置


**设置监控报警规则**：

```sql
-- 创建监控视图
CREATE VIEW index_performance_monitor AS
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Handler_read_rnd_next' AND VARIABLE_VALUE > 1000000 THEN 'WARNING'
        WHEN VARIABLE_NAME = 'Select_full_join' AND VARIABLE_VALUE > 100 THEN 'CRITICAL'
        WHEN VARIABLE_NAME = 'Created_tmp_disk_tables' AND VARIABLE_VALUE > 1000 THEN 'WARNING'
        ELSE 'OK'
    END AS status,
    NOW() AS check_time
FROM INFORMATION_SCHEMA.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN ('Handler_read_rnd_next', 'Select_full_join', 'Created_tmp_disk_tables');
```

---

## 6. 🐌 慢查询索引分析实战


### 6.1 开启慢查询日志


**配置慢查询监控**：

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录
SET GLOBAL log_queries_not_using_indexes = 1;  -- 记录未使用索引的查询

-- 查看慢查询配置
SHOW VARIABLES LIKE '%slow%';
SHOW VARIABLES LIKE 'long_query_time';
```

### 6.2 慢查询日志分析


**典型慢查询分析流程**：

```
慢查询日志示例：
# Time: 2024-09-12T10:30:15.123456Z
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 100  Rows_examined: 50000
SELECT * FROM orders WHERE status = 'pending' AND created_date > '2024-01-01';

分析步骤：
1. Query_time: 5.12秒 → 查询很慢
2. Rows_examined: 50000 → 扫描了5万行  
3. Rows_sent: 100 → 只返回100行
4. 效率比: 100/50000 = 0.2% → 效率极低

问题诊断：
缺少合适的索引，导致需要扫描大量无关数据
```

### 6.3 慢查询索引优化实例


**实战优化案例**：

```sql
-- 问题查询
SELECT order_id, customer_id, total_amount 
FROM orders 
WHERE status = 'pending' 
  AND created_date >= '2024-01-01'
  AND total_amount > 1000
ORDER BY created_date DESC 
LIMIT 20;

-- 分析执行计划
EXPLAIN SELECT ...;
```

**优化前后对比**：
```
优化前：
- type: ALL (全表扫描)
- rows: 500,000 
- Extra: Using where; Using filesort

优化方案：
CREATE INDEX idx_orders_composite ON orders(status, created_date, total_amount);

优化后：
- type: range (范围扫描)
- rows: 1,000
- Extra: Using index condition

性能提升：
- 查询时间：5.2秒 → 0.1秒
- 扫描行数：500,000 → 1,000  
- 性能提升：52倍
```

---

## 7. 🛠 索引建议工具使用


### 7.1 MySQL原生工具


**使用EXPLAIN分析**：

```sql
-- 基本分析
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';

-- 详细分析  
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE email = 'user@example.com';

-- 实际执行分析
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
```

**EXPLAIN结果关键指标**：
```
重点关注指标：
✅ type: const > eq_ref > ref > range > index > ALL
✅ rows: 扫描行数越少越好
✅ Extra: 
   - Using index: 覆盖索引，很好
   - Using where: 需要过滤，正常
   - Using filesort: 需要排序，可优化
   - Using temporary: 需要临时表，需要优化
```

### 7.2 第三方分析工具


**pt-index-usage工具（Percona Toolkit）**：

```bash
# 分析索引使用情况
pt-index-usage --host=localhost --user=root --password=xxx \
    /var/log/mysql/slow.log

# 输出示例
# Database: ecommerce
# Table: orders  
# Index: idx_customer_id
# Usage: 85% of queries use this index ✅
# Recommendation: Keep this index

# Index: idx_rarely_used  
# Usage: 2% of queries use this index ❌
# Recommendation: Consider dropping this index
```

**MySQL Workbench性能分析**：
```
使用步骤：
1. 连接到MySQL实例
2. 打开Performance Dashboard
3. 选择Performance Reports
4. 查看Index Usage Statistics
5. 根据建议优化索引
```

### 7.3 自动索引建议


**编写索引建议脚本**：

```sql
-- 简化的索引建议查询
SELECT 
    table_name,
    column_name,
    COUNT(*) as usage_count,
    CASE 
        WHEN COUNT(*) > 1000 THEN CONCAT('建议创建索引: CREATE INDEX idx_', table_name, '_', column_name, ' ON ', table_name, '(', column_name, ')')
        WHEN COUNT(*) < 10 THEN '使用频率低，不建议创建索引'
        ELSE '使用频率中等，可考虑创建索引'
    END as recommendation
FROM information_schema.columns c
WHERE table_schema = 'your_database'
    AND data_type IN ('int', 'bigint', 'varchar', 'char', 'date', 'datetime')
GROUP BY table_name, column_name
ORDER BY usage_count DESC;
```

---

## 8. 📊 性能基准测试方法


### 8.1 建立基准测试


**测试环境准备**：

```sql
-- 创建测试表
CREATE TABLE benchmark_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    status VARCHAR(20),
    created_date DATE,
    amount DECIMAL(10,2)
);

-- 插入测试数据
INSERT INTO benchmark_test (user_id, status, created_date, amount)
SELECT 
    FLOOR(RAND() * 10000) + 1,
    CASE FLOOR(RAND() * 4)
        WHEN 0 THEN 'pending'
        WHEN 1 THEN 'completed'  
        WHEN 2 THEN 'cancelled'
        ELSE 'processing'
    END,
    DATE_ADD('2024-01-01', INTERVAL FLOOR(RAND() * 365) DAY),
    ROUND(RAND() * 10000, 2)
FROM information_schema.tables t1, information_schema.tables t2
LIMIT 1000000;  -- 生成100万测试数据
```

### 8.2 基准测试执行


**测试索引性能对比**：

```sql
-- 测试前：清除查询缓存
RESET QUERY CACHE;

-- 测试1：无索引查询性能
SELECT SQL_NO_CACHE COUNT(*) 
FROM benchmark_test 
WHERE status = 'pending' AND created_date > '2024-06-01';
-- 记录执行时间：例如 2.5秒

-- 创建索引
CREATE INDEX idx_status_date ON benchmark_test(status, created_date);

-- 测试2：有索引查询性能  
RESET QUERY CACHE;
SELECT SQL_NO_CACHE COUNT(*) 
FROM benchmark_test 
WHERE status = 'pending' AND created_date > '2024-06-01';
-- 记录执行时间：例如 0.1秒

-- 性能对比：2.5秒 vs 0.1秒，提升25倍
```

### 8.3 压力测试


**使用mysqlslap进行压力测试**：

```bash
# 测试索引对并发查询的影响
mysqlslap --user=root --password=xxx \
    --host=localhost \
    --concurrency=50 \
    --iterations=3 \
    --number-of-queries=1000 \
    --query="SELECT * FROM benchmark_test WHERE status='pending' LIMIT 10" \
    --verbose

# 结果示例：
# Average number of seconds to run all queries: 15.234 seconds
# Minimum number of seconds to run all queries: 14.567 seconds  
# Maximum number of seconds to run all queries: 16.123 seconds
```

---

## 9. ✅ 索引优化效果评估


### 9.1 优化前后对比指标


**关键性能指标对比**：

| 指标类别 | **优化前** | **优化后** | **改善程度** |
|---------|-----------|-----------|-------------|
| `平均查询时间` | `2.5秒` | `0.1秒` | `提升25倍` |
| `扫描行数` | `100万行` | `1000行` | `减少99.9%` |
| `CPU使用率` | `80%` | `20%` | `降低60%` |
| `磁盘IO` | `高` | `低` | `显著降低` |
| `并发处理能力` | `50 TPS` | `500 TPS` | `提升10倍` |

### 9.2 长期效果监控


**建立监控仪表板**：

```sql
-- 创建性能监控表
CREATE TABLE index_performance_log (
    log_date DATE,
    table_name VARCHAR(100),
    avg_query_time DECIMAL(10,4),
    total_queries INT,
    index_usage_ratio DECIMAL(5,2),
    slow_queries_count INT
);

-- 定期插入监控数据（可设置定时任务）
INSERT INTO index_performance_log 
SELECT 
    CURDATE(),
    'orders',
    AVG(query_time),
    COUNT(*),
    (index_queries / total_queries) * 100,
    COUNT(CASE WHEN query_time > 2 THEN 1 END)
FROM query_performance_data 
WHERE date >= CURDATE() - INTERVAL 1 DAY;
```

### 9.3 ROI分析（投资回报率）


**计算索引优化的投资回报**：

```
成本分析：
- 索引创建时间：5分钟
- 存储空间增加：50MB  
- 维护开销：写入性能降低5%

收益分析：
- 查询性能提升：25倍
- 用户体验改善：页面加载从3秒降到0.2秒
- 服务器资源节省：CPU使用率从80%降到20%
- 支撑用户量提升：从1万在线到10万在线

ROI计算：
投入成本 ≈ 1小时人工 + 50MB存储
节省成本 ≈ 减少4台服务器 + 提升用户满意度
投资回报比 > 100:1
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 索引监控本质：定期检查索引健康状况，发现并解决性能问题
🔸 使用率统计：通过performance_schema了解哪些索引被使用
🔸 效率分析：通过选择性、基数、碎片率评估索引质量  
🔸 扫描类型：通过EXPLAIN了解查询执行方式
🔸 性能指标：通过关键指标监控整体性能状况
🔸 慢查询分析：找出性能瓶颈并针对性优化
🔸 工具使用：掌握MySQL原生工具和第三方工具
🔸 基准测试：科学评估优化效果
```

### 10.2 关键理解要点


**🔹 索引监控的本质**：
```
不是为了监控而监控，而是为了：
- 发现无用索引 → 减少存储和维护成本
- 发现性能瓶颈 → 提升查询效率  
- 验证优化效果 → 确保改进有效
- 预防性能问题 → 提前发现趋势
```

**🔹 监控指标的实际意义**：
```
技术指标背后的业务价值：
- 查询时间从3秒到0.1秒 → 用户体验大幅提升
- 扫描行数减少99% → 服务器资源大幅节省  
- 并发能力提升10倍 → 支撑更多用户访问
- CPU使用率降低60% → 硬件成本显著降低
```

**🔹 优化的渐进性**：
```
优化不是一步到位：
第一步：解决最明显的问题（全表扫描）
第二步：优化高频查询（80/20原则）
第三步：精细化调优（边际收益递减）
第四步：持续监控（保持优化效果）
```

### 10.3 实际应用价值


**🎯 业务场景应用**：
- **电商系统**：订单查询优化，支撑大促流量
- **用户系统**：登录验证加速，提升用户体验  
- **报表系统**：复杂查询优化，提高分析效率
- **日志系统**：检索性能优化，快速问题定位

**🔧 运维实践**：
- **定期巡检**：每周检查索引使用情况
- **性能监控**：实时监控关键指标变化
- **优化规划**：基于监控数据制定优化计划
- **效果评估**：量化优化效果，指导后续工作

**💡 最佳实践要点**：
```
监控频率：
- 关键指标：实时监控
- 使用率统计：每日检查  
- 深度分析：每周执行
- 全面评估：每月进行

优化原则：
- 先解决最严重的问题
- 关注高频查询的优化
- 平衡查询和写入性能
- 持续监控验证效果
```

**核心记忆口诀**：
- 监控索引看使用，无用索引要清除
- 慢查询里找问题，执行计划是关键  
- 基准测试量效果，持续监控保长久
- 性能优化非一日，渐进改善见真章