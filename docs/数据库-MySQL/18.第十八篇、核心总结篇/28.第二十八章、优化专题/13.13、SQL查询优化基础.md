---
title: 13、SQL查询优化基础
---
## 📚 目录

1. [查询优化基础概念](#1-查询优化基础概念)
2. [EXPLAIN语句详解](#2-EXPLAIN语句详解)
3. [表连接方式选择](#3-表连接方式选择)
4. [子查询优化策略](#4-子查询优化策略)
5. [查询重写技术](#5-查询重写技术)
6. [优化器提示使用](#6-优化器提示使用)
7. [SQL编写最佳实践](#7-SQL编写最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 查询优化基础概念


### 1.1 什么是查询优化


**简单理解**：查询优化就是让你的SQL语句跑得更快、消耗更少资源

```
优化前：                    优化后：
SELECT * FROM users;        SELECT id, name FROM users 
                           WHERE age > 18 
                           ORDER BY id 
                           LIMIT 100;

区别：
✅ 明确需要的列（不用SELECT *）
✅ 添加过滤条件（WHERE子句）  
✅ 合理排序（利用索引）
✅ 限制结果数量（LIMIT）
```

### 1.2 查询性能的关键指标


**🔸 响应时间（Response Time）**
- **定义**：从发出查询到返回结果的时间
- **影响因素**：CPU、内存、磁盘IO、网络传输

**🔸 吞吐量（Throughput）**
- **定义**：单位时间内能处理的查询数量
- **衡量标准**：QPS（每秒查询数）、TPS（每秒事务数）

**🔸 资源消耗（Resource Usage）**
- **CPU使用率**：计算密集型操作的开销
- **内存占用**：临时表、排序缓冲区的使用
- **磁盘IO**：数据读取和写入的次数

### 1.3 查询性能问题的常见表现


**性能问题症状识别**：
```
🚨 慢查询日志频繁报警
🚨 数据库连接池耗尽
🚨 CPU使用率持续高位
🚨 磁盘IO等待时间过长
🚨 应用响应时间增加
🚨 用户体验明显下降
```

---

## 2. 🔍 EXPLAIN语句详解


### 2.1 EXPLAIN基本用法


**什么是EXPLAIN**：MySQL提供的查询执行计划分析工具

```sql
-- 基本用法
EXPLAIN SELECT * FROM users WHERE age > 25;

-- 详细格式
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE age > 25;

-- 扩展信息
EXPLAIN EXTENDED SELECT * FROM users WHERE age > 25;
SHOW WARNINGS;
```

### 2.2 EXPLAIN输出详解


**执行计划表格解读**：
```
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | users | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1000 |    33.33 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

**🔸 核心字段含义**：

| 字段 | **含义** | **重要性** |
|------|----------|-----------|
| **type** | `扫描方式` | ⭐⭐⭐⭐⭐ |
| **key** | `实际使用的索引` | ⭐⭐⭐⭐⭐ |
| **rows** | `预估扫描行数` | ⭐⭐⭐⭐ |
| **Extra** | `额外执行信息` | ⭐⭐⭐⭐ |
| **filtered** | `过滤后的行百分比` | ⭐⭐⭐ |

### 2.3 type字段详解


**访问类型性能排序**（从快到慢）：
```
const > eq_ref > ref > range > index > ALL

性能分析：
┌─────────┬─────────────┬─────────────────┐
│  类型   │   性能      │     场景        │
├─────────┼─────────────┼─────────────────┤
│ const   │ 最快        │ 主键/唯一索引等值 │
│ eq_ref  │ 很快        │ 主键/唯一索引连接 │  
│ ref     │ 快          │ 普通索引等值查询 │
│ range   │ 较快        │ 索引范围查询     │
│ index   │ 慢          │ 索引全扫描       │
│ ALL     │ 最慢        │ 全表扫描         │
└─────────┴─────────────┴─────────────────┘
```

**具体示例**：
```sql
-- const类型：使用主键等值查询
EXPLAIN SELECT * FROM users WHERE id = 1;
-- type: const, rows: 1

-- ref类型：使用普通索引等值查询  
EXPLAIN SELECT * FROM users WHERE email = 'john@example.com';
-- type: ref, rows: 1-几百

-- range类型：使用索引范围查询
EXPLAIN SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- type: range, rows: 几百-几千

-- ALL类型：全表扫描（需要优化）
EXPLAIN SELECT * FROM users WHERE description LIKE '%keyword%';
-- type: ALL, rows: 全表行数
```

### 2.4 Extra字段常见值


**🔸 性能相关的Extra信息**：
```sql
Using index          -- 覆盖索引，最优情况
Using where          -- 使用WHERE条件过滤
Using index condition -- 索引条件下推
Using temporary      -- 使用临时表（需优化）
Using filesort       -- 使用文件排序（需优化）
Using join buffer    -- 使用连接缓冲区
```

**问题示例与解决**：
```sql
-- 问题：Using temporary + Using filesort
EXPLAIN SELECT age, COUNT(*) FROM users 
GROUP BY age ORDER BY name;

-- 原因：GROUP BY和ORDER BY使用不同字段
-- 解决：调整查询或创建合适索引
CREATE INDEX idx_age_name ON users(age, name);
```

---

## 3. 🔗 表连接方式选择


### 3.1 连接算法类型


**MySQL支持的连接算法**：
```
连接算法性能对比：
┌─────────────────┬─────────────┬─────────────────┐
│    算法类型     │   适用场景   │    时间复杂度   │
├─────────────────┼─────────────┼─────────────────┤
│ Nested Loop     │ 小表驱动大表 │ O(M × N)        │
│ Block Nested    │ 无索引连接   │ O(M × N/块大小) │
│ Index Nested    │ 有索引连接   │ O(M × log N)    │
│ Hash Join       │ 等值连接     │ O(M + N)        │
└─────────────────┴─────────────┴─────────────────┘
```

### 3.2 连接优化策略


**🔸 小表驱动大表原则**
```sql
-- 优化前：大表驱动小表
SELECT u.name, d.dept_name 
FROM users u                    -- 100万行
JOIN departments d              -- 10行  
ON u.dept_id = d.id;

-- 优化后：小表驱动大表  
SELECT u.name, d.dept_name
FROM departments d              -- 10行（驱动表）
JOIN users u                    -- 100万行
ON d.id = u.dept_id;

性能提升原理：
驱动表每一行都要在被驱动表中查找匹配
10次查找 vs 100万次查找
```

**🔸 连接顺序优化**
```sql
-- 三表连接示例
SELECT u.name, o.total, p.product_name
FROM users u                    -- 10万行
JOIN orders o ON u.id = o.user_id     -- 50万行
JOIN products p ON o.product_id = p.id;  -- 1万行

最优连接顺序分析：
1. products（1万） → orders（根据product_id过滤）
2. 中间结果 → users（根据user_id连接）

-- 使用STRAIGHT_JOIN强制顺序
SELECT /*+ STRAIGHT_JOIN */ u.name, o.total, p.product_name  
FROM products p
JOIN orders o ON p.id = o.product_id
JOIN users u ON o.user_id = u.id;
```

### 3.3 连接类型选择


**内连接vs外连接性能对比**：
```sql
-- 内连接（性能更好）
SELECT u.name, o.total 
FROM users u 
INNER JOIN orders o ON u.id = o.user_id;

-- 左外连接（性能稍差）
SELECT u.name, IFNULL(o.total, 0) as total
FROM users u 
LEFT JOIN orders o ON u.id = o.user_id;

性能差异原因：
├─ 内连接：只返回匹配的记录，数据量小
├─ 外连接：需要返回不匹配的记录，数据量大
└─ 外连接：需要额外的NULL值处理
```

**连接条件优化**：
```sql
-- 低效：函数在连接条件中
SELECT u.name, o.total
FROM users u
JOIN orders o ON DATE(u.created_at) = DATE(o.order_date);

-- 高效：避免连接条件中使用函数
SELECT u.name, o.total  
FROM users u
JOIN orders o ON u.created_at >= DATE(o.order_date) 
              AND u.created_at < DATE_ADD(DATE(o.order_date), INTERVAL 1 DAY);
```

---

## 4. 🔄 子查询优化策略


### 4.1 子查询类型识别


**常见子查询分类**：
```sql
-- 标量子查询（返回单个值）
SELECT name, (SELECT COUNT(*) FROM orders WHERE user_id = u.id) as order_count
FROM users u;

-- EXISTS子查询（存在性检查）
SELECT name FROM users u  
WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id);

-- IN子查询（包含检查）
SELECT name FROM users 
WHERE id IN (SELECT user_id FROM orders WHERE total > 1000);

-- 相关子查询vs非相关子查询
相关：子查询引用外层表字段，每行都要执行
非相关：子查询独立，只执行一次
```

### 4.2 子查询转连接优化


**🔸 EXISTS转INNER JOIN**
```sql
-- 优化前：EXISTS子查询
SELECT u.name 
FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.user_id = u.id AND o.status = 'completed'
);

-- 优化后：INNER JOIN
SELECT DISTINCT u.name
FROM users u  
INNER JOIN orders o ON u.id = o.user_id
WHERE o.status = 'completed';

优化效果：
- 减少子查询重复执行
- 利用连接算法优化
- 可能的性能提升：2-10倍
```

**🔸 IN转LEFT JOIN**
```sql
-- 优化前：IN子查询
SELECT name FROM users 
WHERE id IN (
    SELECT user_id FROM orders 
    WHERE total > 1000
);

-- 优化后：LEFT JOIN + IS NOT NULL
SELECT DISTINCT u.name
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.total > 1000  
WHERE o.user_id IS NOT NULL;

注意事项：
- 需要DISTINCT去重
- 注意NULL值处理
- 验证结果正确性
```

### 4.3 子查询性能陷阱


**🔸 相关子查询性能问题**
```sql
-- 性能陷阱：N+1查询问题
SELECT u.name,
       (SELECT COUNT(*) FROM orders WHERE user_id = u.id) as order_count,
       (SELECT MAX(total) FROM orders WHERE user_id = u.id) as max_order
FROM users u;

问题分析：
- 外层查询1万行，子查询执行2万次
- 每个子查询都需要扫描orders表
- 总扫描次数：1万 × 2 × orders表大小

-- 优化方案：合并子查询
SELECT u.name, 
       IFNULL(o.order_count, 0) as order_count,
       IFNULL(o.max_order, 0) as max_order
FROM users u
LEFT JOIN (
    SELECT user_id, 
           COUNT(*) as order_count,
           MAX(total) as max_order
    FROM orders 
    GROUP BY user_id
) o ON u.id = o.user_id;
```

---

## 5. ✏️ 查询重写技术


### 5.1 等价查询转换


**🔸 OR条件优化**
```sql
-- 优化前：OR条件难以使用索引
SELECT * FROM users 
WHERE age = 25 OR age = 30;

-- 优化后：UNION替代OR
SELECT * FROM users WHERE age = 25
UNION 
SELECT * FROM users WHERE age = 30;

-- 更好的方案：IN替代OR
SELECT * FROM users WHERE age IN (25, 30);

性能对比：
OR条件：可能全表扫描
IN条件：可以使用索引范围扫描
UNION：两次索引查询合并
```

**🔸 复杂WHERE条件简化**
```sql
-- 优化前：复杂表达式
SELECT * FROM orders 
WHERE YEAR(order_date) = 2023 AND MONTH(order_date) = 12;

-- 优化后：范围条件
SELECT * FROM orders 
WHERE order_date >= '2023-12-01' 
  AND order_date < '2024-01-01';

优化原理：
- 避免函数计算
- 利用索引范围扫描
- 减少CPU开销
```

### 5.2 查询分解技术


**🔸 复杂查询分解**
```sql
-- 优化前：复杂的一次性查询
SELECT u.name, u.email, 
       COUNT(o.id) as order_count,
       AVG(o.total) as avg_total,
       MAX(o.order_date) as last_order_date,
       (SELECT COUNT(*) FROM reviews r WHERE r.user_id = u.id) as review_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id  
WHERE u.status = 'active'
GROUP BY u.id, u.name, u.email;

-- 优化后：分步查询
-- 步骤1：获取活跃用户
SELECT id, name, email FROM users WHERE status = 'active';

-- 步骤2：获取订单统计
SELECT user_id, 
       COUNT(id) as order_count,
       AVG(total) as avg_total, 
       MAX(order_date) as last_order_date
FROM orders 
WHERE user_id IN (用户ID列表)
GROUP BY user_id;

-- 步骤3：获取评论统计  
SELECT user_id, COUNT(*) as review_count
FROM reviews
WHERE user_id IN (用户ID列表) 
GROUP BY user_id;

-- 步骤4：应用程序中合并结果
```

### 5.3 查询成本估算


**手工估算查询代价**：
```sql
-- 分析表大小和索引
SHOW TABLE STATUS LIKE 'users';
SHOW INDEX FROM users;

-- 估算扫描行数
SELECT COUNT(*) FROM users WHERE age > 25;  -- 实际满足条件的行数

-- 计算选择性
SELECT COUNT(DISTINCT age) / COUNT(*) FROM users;  -- age字段选择性

成本估算公式：
总代价 = IO代价 + CPU代价
IO代价 = 页面读取次数 × 单次IO时间
CPU代价 = 行处理次数 × 单行处理时间
```

---

## 6. 💡 优化器提示使用


### 6.1 索引提示


**强制使用索引**：
```sql
-- USE INDEX：建议使用特定索引
SELECT * FROM users USE INDEX (idx_age) 
WHERE age > 25;

-- FORCE INDEX：强制使用特定索引  
SELECT * FROM users FORCE INDEX (idx_age)
WHERE age > 25 AND name = 'John';

-- IGNORE INDEX：忽略特定索引
SELECT * FROM users IGNORE INDEX (idx_name)
WHERE age > 25;
```

### 6.2 连接提示


**控制连接行为**：
```sql
-- STRAIGHT_JOIN：强制连接顺序
SELECT /*+ STRAIGHT_JOIN */ u.name, o.total
FROM small_table u
JOIN large_table o ON u.id = o.user_id;

-- 指定连接算法
SELECT /*+ USE_NL(u,o) */ u.name, o.total  
FROM users u JOIN orders o ON u.id = o.user_id;

常用连接提示：
├─ USE_NL：使用嵌套循环连接
├─ USE_BNL：使用块嵌套循环连接  
├─ USE_HASH：使用哈希连接
└─ NO_BNL：禁用块嵌套循环连接
```

### 6.3 提示使用场景


**何时需要使用提示**：
```
适用场景：
✅ 统计信息不准确时
✅ 优化器选择错误索引时  
✅ 复杂查询需要人工干预时
✅ 测试不同执行计划时

注意事项：
⚠️ 提示会固化执行计划
⚠️ 数据变化时可能失效
⚠️ 过度使用影响可维护性
⚠️ 升级版本时需要重新测试
```

---

## 7. 📝 SQL编写最佳实践


### 7.1 SELECT语句优化


**🔸 避免SELECT ***
```sql
-- 不推荐：SELECT *
SELECT * FROM users WHERE age > 25;

-- 推荐：明确指定需要的列
SELECT id, name, email FROM users WHERE age > 25;

优化效果：
├─ 减少网络传输
├─ 降低内存占用  
├─ 可能使用覆盖索引
└─ 提高缓存命中率
```

**🔸 合理使用LIMIT**
```sql
-- 大结果集分页优化
-- 不推荐：OFFSET过大
SELECT * FROM users ORDER BY id LIMIT 100000, 20;

-- 推荐：基于主键的分页
SELECT * FROM users 
WHERE id > 上次最大ID 
ORDER BY id LIMIT 20;

-- 推荐：使用游标分页
SELECT * FROM users 
WHERE id > ? 
ORDER BY id LIMIT 20;
```

### 7.2 WHERE条件优化


**🔸 索引列的使用原则**
```sql
-- 能使用索引的情况
WHERE age = 25                    -- 等值查询
WHERE age > 25                    -- 范围查询  
WHERE age IN (25, 30, 35)         -- IN查询
WHERE name LIKE 'John%'           -- 前缀匹配

-- 无法使用索引的情况  
WHERE YEAR(created_at) = 2023     -- 函数计算
WHERE age + 1 = 26                -- 表达式计算
WHERE name LIKE '%John'           -- 后缀匹配
WHERE age <> 25                   -- 不等于（部分情况）
```

**🔸 复合索引使用技巧**
```sql
-- 索引：KEY idx_age_city_name (age, city, name)

-- 能完全使用索引
WHERE age = 25 AND city = 'Beijing' AND name = 'John';

-- 能部分使用索引（age, city）
WHERE age = 25 AND city = 'Beijing';

-- 能使用索引（age）  
WHERE age = 25 AND name = 'John';

-- 无法使用索引（跳过了age）
WHERE city = 'Beijing' AND name = 'John';

最左前缀原则：
复合索引必须从最左边的列开始使用
```

### 7.3 ORDER BY和GROUP BY优化


**🔸 排序优化策略**
```sql
-- 利用索引排序（最快）
SELECT * FROM users ORDER BY id;  -- 主键排序

-- 创建专门的排序索引
CREATE INDEX idx_age_name ON users(age, name);
SELECT * FROM users WHERE age > 25 ORDER BY age, name;

-- 避免文件排序的技巧
SELECT id, name FROM users 
WHERE age > 25 
ORDER BY age, name  
LIMIT 100;  -- 限制结果集大小
```

**🔸 分组优化策略**
```sql
-- 高效的分组查询
SELECT age, COUNT(*) 
FROM users 
WHERE status = 'active'
GROUP BY age 
HAVING COUNT(*) > 10;

-- 优化技巧：
-- 1. WHERE先过滤再分组
-- 2. 为GROUP BY字段创建索引  
-- 3. 合理使用HAVING条件
-- 4. 避免SELECT中使用非分组字段
```

### 7.4 常见反模式避免


**🔸 N+1查询问题**
```sql
-- 问题代码：N+1查询
-- 主查询：1次
SELECT id, name FROM users;

-- 子查询：N次（每个用户一次）
SELECT COUNT(*) FROM orders WHERE user_id = ?;

-- 解决方案：JOIN或子查询
SELECT u.id, u.name, COUNT(o.id) as order_count
FROM users u  
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;
```

**🔸 隐式类型转换**
```sql
-- 问题：字符串列与数字比较
SELECT * FROM users WHERE phone = 12345678901;  -- phone是VARCHAR

-- 解决：保持类型一致
SELECT * FROM users WHERE phone = '12345678901';

类型转换的性能影响：
├─ 无法使用索引
├─ 全表扫描  
├─ CPU开销增加
└─ 查询速度下降
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 EXPLAIN分析：type、key、rows、Extra是关键指标
🔸 连接优化：小表驱动大表，合理选择连接算法
🔸 子查询优化：转换为连接，避免相关子查询
🔸 索引使用：遵循最左前缀原则，避免函数和表达式
🔸 查询重写：OR转IN/UNION，复杂查询分解
```

### 8.2 关键优化思路


**🔹 优化优先级排序**
```
1. 索引优化（影响最大）
   ├─ 创建必要的索引
   ├─ 优化现有索引
   └─ 删除无用索引

2. 查询重写（效果明显）  
   ├─ 子查询转连接
   ├─ OR条件优化
   └─ 复杂查询分解

3. 参数调优（细节优化）
   ├─ 缓冲区大小调整
   ├─ 连接参数优化  
   └─ 超时设置调整
```

**🔹 性能监控指标**
```
响应时间监控：
├─ 平均响应时间 < 100ms（一般查询）
├─ 95%响应时间 < 500ms（复杂查询）
└─ 99%响应时间 < 1s（可接受上限）

资源使用监控：
├─ CPU使用率 < 80%
├─ 内存使用率 < 85%  
├─ 磁盘IO使用率 < 90%
└─ 连接数使用率 < 80%
```

### 8.3 实战优化流程


**🔸 性能问题诊断步骤**
```sql
-- 1. 开启慢查询日志
SET slow_query_log = ON;
SET long_query_time = 0.1;

-- 2. 分析慢查询
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;

-- 3. 使用EXPLAIN分析
EXPLAIN SELECT problematic_query;

-- 4. 查看表和索引状态
SHOW TABLE STATUS LIKE 'table_name';
SHOW INDEX FROM table_name;

-- 5. 应用优化策略
-- 创建索引、重写查询、调整参数等

-- 6. 验证优化效果
-- 重新执行EXPLAIN和性能测试
```

**🔸 索引设计原则**
```
单列索引设计：
✅ 高选择性列优先
✅ WHERE条件常用列  
✅ ORDER BY排序列
✅ GROUP BY分组列

复合索引设计：
✅ 最左前缀原则
✅ 等值条件在前，范围条件在后
✅ 选择性高的列在前  
✅ 覆盖查询需求

索引维护：
✅ 定期分析索引使用情况
✅ 删除无用索引
✅ 合并重复索引
✅ 监控索引维护开销
```

**核心记忆要点**：
- 查询优化是系统性工程，需要多方面配合
- EXPLAIN是最重要的分析工具，必须熟练掌握  
- 索引是查询性能的关键，设计和使用都很重要
- 优化要基于实际数据和查询模式，不能盲目套用
- 持续监控和调优是保持高性能的必要手段