---
title: 11、索引创建与维护操作
---
## 📚 目录

1. [索引创建操作详解](#1-索引创建操作详解)
2. [在线索引创建技术](#2-在线索引创建技术)
3. [索引重建与优化](#3-索引重建与优化)
4. [索引统计信息管理](#4-索引统计信息管理)
5. [索引健康检查与清理](#5-索引健康检查与清理)
6. [索引维护自动化](#6-索引维护自动化)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🛠️ 索引创建操作详解


### 1.1 CREATE INDEX语法全面解析


**基本概念**：索引就像书的目录，帮助MySQL快速找到数据，而不用一页页翻找。

**🔹 标准创建语法**
```sql
-- 基础语法结构
CREATE [UNIQUE] INDEX 索引名称 
ON 表名 (列名1 [ASC|DESC], 列名2 [ASC|DESC], ...)
[USING {BTREE | HASH}]
```

**💡 实际应用示例**
```sql
-- 1. 单列索引创建
CREATE INDEX idx_user_email ON users(email);

-- 2. 复合索引创建
CREATE INDEX idx_order_date_status ON orders(order_date, status);

-- 3. 唯一索引创建
CREATE UNIQUE INDEX idx_user_phone ON users(phone);

-- 4. 指定排序方向
CREATE INDEX idx_product_price ON products(price DESC);

-- 5. 指定索引类型
CREATE INDEX idx_user_age ON users(age) USING BTREE;
```

### 1.2 CREATE INDEX语法优化技巧


**🎯 优化原则**

| **优化方向** | **具体做法** | **效果说明** |
|-------------|-------------|-------------|
| **列顺序优化** | `区分度高的列在前` | 减少扫描行数，提高效率 |
| **长度限制** | `VARCHAR列指定前缀长度` | 节省空间，提升性能 |
| **数据类型** | `选择合适的数据类型` | 减少存储开销 |
| **索引类型** | `根据查询模式选择` | 匹配最佳访问方式 |

**🔧 前缀索引优化**
```sql
-- 为长字符串创建前缀索引
-- 先分析前缀长度的区分度
SELECT 
    COUNT(DISTINCT LEFT(description, 10)) / COUNT(*) as prefix_10,
    COUNT(DISTINCT LEFT(description, 20)) / COUNT(*) as prefix_20,
    COUNT(DISTINCT LEFT(description, 30)) / COUNT(*) as prefix_30
FROM products;

-- 创建合适长度的前缀索引
CREATE INDEX idx_product_desc ON products(description(20));
```

**⚡ 性能优化建议**
```sql
-- 避免：过长的复合索引
CREATE INDEX bad_idx ON orders(customer_id, order_date, status, amount, shipping_address);

-- 推荐：精简的复合索引
CREATE INDEX good_idx ON orders(customer_id, order_date, status);
```

---

## 2. 🚀 在线索引创建技术


### 2.1 在线DDL操作原理


**什么是在线DDL**：在线DDL是MySQL允许在创建索引时不锁定整个表的技术，用户可以继续正常读写数据。

**🔸 传统方式 vs 在线方式对比**

```
传统方式（老版本MySQL）：
用户请求 → [表锁定] → 创建索引 → [解锁] → 正常访问
问题：大表创建索引时，业务完全停止

在线方式（MySQL 5.6+）：
用户请求 → [继续服务] → 后台创建索引 → 完成
优势：业务不中断，用户无感知
```

### 2.2 在线索引创建语法


**🔹 在线创建控制参数**
```sql
-- 设置在线DDL算法
CREATE INDEX idx_user_name ON users(name) 
ALGORITHM = INPLACE,    -- 使用在线算法
LOCK = NONE;           -- 不锁定表

-- 算法选择说明
-- INPLACE: 在线执行，不复制表数据
-- COPY: 离线执行，需要复制整个表
-- DEFAULT: 让MySQL自动选择最优算法
```

**💻 实战操作示例**
```sql
-- 1. 完全在线创建（推荐）
ALTER TABLE orders 
ADD INDEX idx_customer_date (customer_id, order_date)
ALGORITHM = INPLACE, LOCK = NONE;

-- 2. 允许读取，禁止写入
ALTER TABLE products 
ADD INDEX idx_category_price (category_id, price)
ALGORITHM = INPLACE, LOCK = SHARED;

-- 3. 检查是否支持在线DDL
SELECT * FROM information_schema.innodb_ddl_log;
```

### 2.3 在线创建最佳实践


**📋 操作前检查清单**
- ✅ 检查磁盘空间（至少为表大小的2倍）
- ✅ 确认MySQL版本支持（5.6+）
- ✅ 评估业务高峰期，选择合适时间
- ✅ 准备回滚方案

**🔧 监控在线DDL进程**
```sql
-- 查看当前DDL操作进度
SELECT 
    ID,
    STATE,
    INFO,
    TIME
FROM information_schema.processlist 
WHERE COMMAND = 'Query' AND INFO LIKE '%ALTER%';

-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS;
```

---

## 3. 🔄 索引重建与优化


### 3.1 什么时候需要重建索引


**索引重建的必要性**：就像整理书架一样，索引在长期使用后会产生碎片，影响查询效率。

**🎯 重建触发条件**

| **情况** | **触发条件** | **影响** | **解决方案** |
|---------|-------------|---------|-------------|
| **碎片严重** | `碎片率 > 30%` | 查询变慢 | 重建索引 |
| **数据分布变化** | `大量更新操作` | 索引失效 | 重新统计 |
| **表结构调整** | `列类型修改` | 索引不匹配 | 重新创建 |
| **存储引擎切换** | `MyISAM转InnoDB` | 索引格式不同 | 完全重建 |

### 3.2 索引重建操作方法


**🔹 重建索引的几种方式**

```sql
-- 方式1：删除后重建（不推荐，有风险）
DROP INDEX idx_user_email ON users;
CREATE INDEX idx_user_email ON users(email);

-- 方式2：使用ALTER TABLE重建（推荐）
ALTER TABLE users DROP INDEX idx_user_email, 
                  ADD INDEX idx_user_email (email);

-- 方式3：优化表重建所有索引
OPTIMIZE TABLE users;
```

**⚡ 高效重建策略**
```sql
-- 批量重建多个索引（一次性操作，减少表重组次数）
ALTER TABLE orders 
DROP INDEX idx_customer_id,
DROP INDEX idx_order_date,
ADD INDEX idx_customer_id (customer_id),
ADD INDEX idx_order_date (order_date),
ADD INDEX idx_customer_date (customer_id, order_date);
```

### 3.3 索引重建监控


**📊 重建效果评估**
```sql
-- 重建前后性能对比
-- 1. 记录重建前的查询时间
SELECT SQL_NO_CACHE COUNT(*) FROM orders WHERE customer_id = 12345;

-- 2. 执行重建操作
ALTER TABLE orders DROP INDEX idx_customer_id, 
                  ADD INDEX idx_customer_id (customer_id);

-- 3. 测试重建后的查询时间
SELECT SQL_NO_CACHE COUNT(*) FROM orders WHERE customer_id = 12345;
```

---

## 4. 📊 索引统计信息管理


### 4.1 索引统计信息的作用


**什么是索引统计信息**：MySQL存储的关于索引的数据分布情况，帮助查询优化器选择最佳执行计划。

**🔸 统计信息包含内容**
- **基数（Cardinality）**：不同值的数量
- **分布直方图**：数据值的分布情况  
- **空值比例**：NULL值的百分比
- **平均长度**：索引键的平均字节数

### 4.2 查看索引统计信息


**📋 统计信息查询方法**
```sql
-- 1. 查看表的索引统计
SHOW INDEX FROM users;

-- 2. 详细的索引统计信息
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    CARDINALITY,
    SUB_PART
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND TABLE_NAME = 'users';

-- 3. 查看索引使用统计
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database';
```

### 4.3 更新索引统计信息


**🔧 手动更新统计信息**
```sql
-- 1. 分析表，更新统计信息
ANALYZE TABLE users;

-- 2. 分析特定索引
ALTER TABLE users ANALYZE PARTITION ALL;

-- 3. 强制更新统计信息
FLUSH TABLES users WITH READ LOCK;
ANALYZE TABLE users;
UNLOCK TABLES;
```

**⚙️ 自动统计更新配置**
```sql
-- 查看自动统计配置
SHOW VARIABLES LIKE '%innodb_stats%';

-- 设置自动统计更新
SET GLOBAL innodb_stats_auto_recalc = ON;
SET GLOBAL innodb_stats_persistent = ON;
SET GLOBAL innodb_stats_sample_pages = 20;
```

---

## 5. 🧹 索引健康检查与清理


### 5.1 重复索引检测


**什么是重复索引**：功能相同或重叠的索引，浪费存储空间并影响写入性能。

**🔍 重复索引识别方法**
```sql
-- 检测完全重复的索引
SELECT 
    a.table_schema,
    a.table_name,
    a.index_name as index1,
    b.index_name as index2,
    a.column_name
FROM information_schema.statistics a
JOIN information_schema.statistics b ON (
    a.table_schema = b.table_schema AND
    a.table_name = b.table_name AND
    a.column_name = b.column_name AND
    a.seq_in_index = b.seq_in_index AND
    a.index_name != b.index_name
)
WHERE a.table_schema = 'your_database'
ORDER BY a.table_name, a.column_name;
```

**📋 常见重复索引场景**
```sql
-- 场景1：主键和唯一索引重复
ALTER TABLE users ADD PRIMARY KEY (id);           -- 自动创建主键索引
CREATE UNIQUE INDEX idx_user_id ON users(id);     -- 重复！

-- 场景2：单列索引和复合索引重复  
CREATE INDEX idx_customer ON orders(customer_id);           -- 单列索引
CREATE INDEX idx_customer_date ON orders(customer_id, order_date); -- 复合索引
-- customer_id的查询可以使用复合索引，单列索引是多余的
```

### 5.2 未使用索引识别


**🎯 识别无用索引**
```sql
-- 查找从未使用的索引
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    t.INDEX_NAME
FROM information_schema.statistics t
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
  ON t.TABLE_SCHEMA = p.OBJECT_SCHEMA
  AND t.TABLE_NAME = p.OBJECT_NAME  
  AND t.INDEX_NAME = p.INDEX_NAME
WHERE t.TABLE_SCHEMA = 'your_database'
  AND p.INDEX_NAME IS NULL
  AND t.INDEX_NAME != 'PRIMARY';
```

**📊 索引使用频率分析**
```sql
-- 查看索引使用频率排序
SELECT 
    OBJECT_SCHEMA as 'Database',
    OBJECT_NAME as 'Table',
    INDEX_NAME as 'Index',
    COUNT_FETCH as 'Select_Count',
    COUNT_INSERT as 'Insert_Count', 
    COUNT_UPDATE as 'Update_Count',
    COUNT_DELETE as 'Delete_Count'
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_FETCH ASC;
```

### 5.3 索引碎片整理


**🔧 碎片检测与整理**
```sql
-- 检测表和索引碎片
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    DATA_LENGTH,
    INDEX_LENGTH,
    DATA_FREE,
    (DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) * 100 as FragmentationPercent
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
  AND DATA_FREE > 0
ORDER BY FragmentationPercent DESC;

-- 整理碎片
OPTIMIZE TABLE users;
-- 或者
ALTER TABLE users ENGINE = InnoDB;
```

---

## 6. 🤖 索引维护自动化


### 6.1 自动化维护脚本


**📝 索引健康检查脚本**
```bash
#!/bin/bash
# index_health_check.sh

MYSQL_USER="admin"
MYSQL_PASS="password"
DATABASE="your_database"

echo "=== 索引健康检查报告 ===" 
date

echo "1. 检查未使用的索引..."
mysql -u$MYSQL_USER -p$MYSQL_PASS $DATABASE << EOF
SELECT CONCAT('建议删除: ', TABLE_NAME, '.', INDEX_NAME) as suggestion
FROM information_schema.statistics t
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
  ON t.TABLE_SCHEMA = p.OBJECT_SCHEMA AND t.TABLE_NAME = p.OBJECT_NAME  
  AND t.INDEX_NAME = p.INDEX_NAME
WHERE t.TABLE_SCHEMA = '$DATABASE' AND p.INDEX_NAME IS NULL 
  AND t.INDEX_NAME != 'PRIMARY';
EOF

echo "2. 检查碎片严重的表..."
mysql -u$MYSQL_USER -p$MYSQL_PASS $DATABASE << EOF
SELECT 
    TABLE_NAME,
    CONCAT(ROUND((DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) * 100, 2), '%') as fragmentation
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = '$DATABASE' AND DATA_FREE > 0
  AND (DATA_FREE / (DATA_LENGTH + INDEX_LENGTH)) > 0.3;
EOF
```

### 6.2 自动维护策略


**⏰ 定时维护任务**
```sql
-- 创建维护事件（MySQL 5.1+）
CREATE EVENT IF NOT EXISTS index_maintenance
ON SCHEDULE EVERY 1 WEEK 
STARTS '2025-09-15 02:00:00'
DO
BEGIN
    -- 更新统计信息
    CALL update_table_statistics();
    
    -- 清理碎片
    CALL optimize_fragmented_tables();
END;

-- 启用事件调度器
SET GLOBAL event_scheduler = ON;
```

**🔧 维护存储过程**
```sql
DELIMITER //
CREATE PROCEDURE update_table_statistics()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE table_name VARCHAR(255);
    
    -- 游标：获取所有用户表
    DECLARE table_cursor CURSOR FOR
        SELECT TABLE_NAME FROM information_schema.TABLES
        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_TYPE = 'BASE TABLE';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    read_loop: LOOP
        FETCH table_cursor INTO table_name;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 更新表统计信息
        SET @sql = CONCAT('ANALYZE TABLE ', table_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE table_cursor;
END //
DELIMITER ;
```

### 6.3 监控与告警


**📊 索引性能监控**
```sql
-- 创建监控视图
CREATE VIEW v_index_performance AS
SELECT 
    OBJECT_SCHEMA as database_name,
    OBJECT_NAME as table_name,
    INDEX_NAME as index_name,
    COUNT_FETCH as select_count,
    COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE as modify_count,
    ROUND(COUNT_FETCH / (COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE + 1), 2) as read_write_ratio
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema')
ORDER BY select_count DESC;
```

**⚠️ 自动告警配置**
```bash
# 在crontab中添加检查任务
# 每天凌晨检查索引健康状况
0 2 * * * /usr/local/bin/index_health_check.sh | mail -s "索引健康报告" admin@company.com
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 索引创建：CREATE INDEX语法优化，合理选择列顺序和长度
🔸 在线DDL：ALGORITHM=INPLACE，LOCK=NONE实现业务无感知操作
🔸 索引重建：定期整理碎片，保持索引性能最优
🔸 统计信息：ANALYZE TABLE更新统计，帮助优化器选择最佳计划
🔸 健康检查：识别重复、未使用索引，及时清理优化
🔸 自动化维护：脚本化、事件调度实现无人值守维护
```

### 7.2 关键操作要点


**🔹 索引创建最佳实践**
```
选择原则：
- 高频查询条件优先建立索引
- 复合索引注意列的顺序（区分度高的在前）
- 避免过长的索引键（影响性能）
- 合理使用前缀索引节省空间

操作规范：
- 生产环境优先使用在线DDL
- 大表操作选择业务低峰期
- 提前评估磁盘空间需求
- 准备回滚方案
```

**🔹 维护操作时机**
```
定期检查：
✅ 每周检查索引使用情况
✅ 每月分析重复和无用索引  
✅ 季度执行碎片整理
✅ 半年评估索引策略调整

触发维护：
⚡ 查询性能下降时
⚡ 大批量数据变更后
⚡ 表结构调整后
⚡ 存储空间紧张时
```

### 7.3 实际应用指导


**💻 生产环境操作流程**
```
1. 评估阶段
   - 分析业务需求和查询模式
   - 评估索引创建的成本收益
   - 确定操作时间窗口

2. 准备阶段  
   - 备份相关数据
   - 准备回滚脚本
   - 通知相关团队

3. 执行阶段
   - 使用在线DDL操作
   - 实时监控系统状态
   - 记录操作日志

4. 验证阶段
   - 检查索引创建结果
   - 测试查询性能改善
   - 确认业务功能正常
```

**🎯 常见问题解决**
- **创建索引慢**：检查磁盘IO，选择低峰期操作
- **索引不生效**：更新统计信息，检查查询条件匹配度
- **空间占用大**：清理重复索引，使用前缀索引
- **写入性能下降**：评估索引数量，删除无用索引

**核心记忆**：
- 索引创建要在线，业务影响最小化
- 定期维护不可少，统计信息要更新  
- 重复无用及时清，碎片整理保性能
- 自动化运维是方向，监控告警要完善