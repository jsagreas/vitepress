---
title: 26、MySQL性能监控体系
---
## 📚 目录

1. [MySQL性能监控基础概念](#1-MySQL性能监控基础概念)
2. [Performance Schema详解](#2-Performance-Schema详解)
3. [系统状态变量监控](#3-系统状态变量监控)
4. [慢查询监控分析](#4-慢查询监控分析)
5. [实时性能监控](#5-实时性能监控)
6. [性能基线管理](#6-性能基线管理)
7. [监控告警配置](#7-监控告警配置)
8. [性能报表生成](#8-性能报表生成)
9. [监控工具集成](#9-监控工具集成)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 MySQL性能监控基础概念


### 1.1 什么是MySQL性能监控


**直观理解**：就像给汽车装仪表盘一样，性能监控就是给MySQL装各种"仪表"

```
汽车仪表盘        →     MySQL监控
━━━━━━━━━━━━      ━━━━━━━━━━━━━━
速度表            →     查询执行速度
油量表            →     内存使用情况  
温度表            →     CPU负载状态
里程表            →     累计查询次数
```

> 💡 **核心理解**：监控就是实时了解MySQL的"健康状态"，就像医生给病人量血压、测心跳一样

### 1.2 为什么需要性能监控


**业务场景举例**：
```
网站突然变慢了！用户抱怨连天...

没有监控的情况：
🤔 不知道哪里出了问题
🤔 只能盲目猜测和试错
🤔 问题解决时间很长

有监控的情况：
✅ 立即发现慢查询激增
✅ 定位到具体的SQL语句  
✅ 快速优化解决问题
```

**监控的价值**：
- **提前预警**：问题还没爆发就发现苗头
- **快速定位**：出问题时能迅速找到根因
- **性能优化**：通过数据分析找到优化点
- **容量规划**：了解系统增长趋势，提前扩容

### 1.3 监控的核心指标


```
┌─────────────────────────────────────┐
│              MySQL性能监控           │
├─────────────────────────────────────┤
│ 🚀 响应性能  │ ⚡ 查询响应时间       │
│             │ 📊 QPS/TPS指标       │
├─────────────────────────────────────┤
│ 💾 资源使用  │ 🧠 内存占用率         │
│             │ 💿 磁盘I/O速率       │
│             │ 🔥 CPU使用率         │
├─────────────────────────────────────┤
│ 🔍 数据库层面│ 🐌 慢查询统计         │
│             │ 🔒 锁等待情况         │
│             │ 📈 连接数变化         │
└─────────────────────────────────────┘
```

---

## 2. 📊 Performance Schema详解


### 2.1 Performance Schema是什么


**通俗解释**：Performance Schema就像MySQL的"黑匣子"，记录数据库内部发生的一切

```
传统监控方式：              Performance Schema：
━━━━━━━━━━━━              ━━━━━━━━━━━━━━━━━━
只能看到结果              →   能看到详细过程
无法追踪细节              →   事无巨细都记录
猜测性分析                →   基于真实数据
```

> 📌 **重点理解**：它不是一个普通的数据库，而是MySQL专门用来收集性能数据的"监控系统"

### 2.2 Performance Schema的基本使用


**启用Performance Schema**：
```sql
-- 检查是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 如果没启用，需要在配置文件中设置
[mysqld]
performance_schema = ON
```

**核心监控表格**：
```sql
-- 1. 查看当前正在执行的语句
SELECT thread_id, sql_text, rows_examined 
FROM performance_schema.events_statements_current;

-- 2. 查看历史执行的语句统计
SELECT schema_name, digest_text, count_star, avg_timer_wait
FROM performance_schema.events_statements_summary_by_digest
ORDER BY avg_timer_wait DESC LIMIT 10;

-- 3. 查看表的访问统计
SELECT object_schema, object_name, count_read, count_write
FROM performance_schema.table_io_waits_summary_by_table;
```

### 2.3 Performance Schema核心功能


**🔍 语句级别监控**：
```sql
-- 找出执行时间最长的SQL
SELECT 
    DIGEST_TEXT as sql_pattern,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000 as avg_time_seconds,
    MAX_TIMER_WAIT/1000000000 as max_time_seconds
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 5;
```

**🔧 等待事件监控**：
```sql
-- 查看什么操作最耗时
SELECT 
    EVENT_NAME,
    COUNT_STAR as count,
    AVG_TIMER_WAIT/1000000000 as avg_wait_seconds
FROM performance_schema.events_waits_summary_global_by_event_name 
WHERE COUNT_STAR > 0 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

> 💡 **实用技巧**：定期清理历史数据，避免Performance Schema占用太多空间
```sql
-- 清理语句历史数据
TRUNCATE TABLE performance_schema.events_statements_history_long;
```

---

## 3. 📈 系统状态变量监控


### 3.1 什么是状态变量


**简单理解**：状态变量就像汽车的"累计里程数"，记录MySQL运行过程中各种操作的累计次数

```sql
-- 查看所有状态变量
SHOW STATUS;

-- 查看特定状态变量
SHOW STATUS LIKE 'Queries';
SHOW STATUS LIKE 'Connections';
```

### 3.2 核心状态变量详解


**📊 查询相关指标**：

| 变量名 | 含义 | 重要程度 | 正常范围 |
|--------|------|----------|----------|
| `Queries` | 总查询次数 | ⭐⭐⭐ | 持续增长 |
| `Questions` | 客户端查询次数 | ⭐⭐⭐ | 持续增长 |
| `Slow_queries` | 慢查询次数 | 🔥⭐⭐⭐ | 越少越好 |
| `Select_scan` | 全表扫描次数 | ⭐⭐ | 不宜过多 |

```sql
-- 实用的状态变量查询
SELECT 
    VARIABLE_NAME,
    VARIABLE_VALUE,
    CASE 
        WHEN VARIABLE_NAME = 'Slow_queries' THEN '慢查询数量'
        WHEN VARIABLE_NAME = 'Queries' THEN '总查询次数'
        WHEN VARIABLE_NAME = 'Connections' THEN '总连接次数'
    END as description
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME IN ('Slow_queries', 'Queries', 'Connections');
```

**🔗 连接相关指标**：
```sql
-- 连接使用情况
SHOW STATUS LIKE 'Connections';      -- 总连接次数
SHOW STATUS LIKE 'Max_used_connections'; -- 最大并发连接数
SHOW STATUS LIKE 'Threads_connected';    -- 当前连接数

-- 连接成功率计算
SELECT 
    connections.VARIABLE_VALUE as total_connections,
    aborted.VARIABLE_VALUE as aborted_connections,
    ROUND(
        (aborted.VARIABLE_VALUE / connections.VARIABLE_VALUE) * 100, 2
    ) as abort_rate_percent
FROM 
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Connections') connections,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Aborted_connections') aborted;
```

### 3.3 QPS/TPS监控实现


**📊 计算实时QPS**：
```sql
-- 创建监控视图
CREATE VIEW qps_monitor AS
SELECT 
    NOW() as check_time,
    VARIABLE_VALUE as current_queries,
    @prev_queries as prev_queries,
    TIMESTAMPDIFF(SECOND, @prev_time, NOW()) as time_diff,
    ROUND(
        (VARIABLE_VALUE - @prev_queries) / 
        TIMESTAMPDIFF(SECOND, @prev_time, NOW())
    ) as qps,
    @prev_queries := VARIABLE_VALUE,
    @prev_time := NOW()
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Queries';

-- 初始化变量
SET @prev_queries = (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Queries');
SET @prev_time = NOW();

-- 查看实时QPS
SELECT * FROM qps_monitor;
```

> ⚠️ **注意事项**：状态变量是累计值，需要通过差值计算获得实时指标

---

## 4. 🐌 慢查询监控分析


### 4.1 慢查询日志基础


**什么是慢查询**：执行时间超过设定阈值的SQL语句

```
快查询：SELECT * FROM users WHERE id = 1;           (0.001秒)
慢查询：SELECT * FROM orders WHERE create_time > xxx; (3.5秒)

为什么关注慢查询？
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 慢查询直接影响用户体验
- 消耗大量数据库资源  
- 可能导致连锁反应，拖累整个系统
```

### 4.2 慢查询日志配置


```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2;  -- 2秒以上的查询记录为慢查询
SET GLOBAL log_queries_not_using_indexes = 'ON'; -- 记录未使用索引的查询
```

**配置文件设置**：
```ini
[mysqld]
# 启用慢查询日志
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1

# 记录管理语句和未使用索引的查询
log_slow_admin_statements = 1
log_queries_not_using_indexes = 1
```

### 4.3 慢查询分析方法


**📋 手动分析慢查询日志**：
```bash
# 查看慢查询日志内容
tail -f /var/log/mysql/slow.log

# 日志格式示例：
# Time: 2025-09-12T10:30:45.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Query_time: 3.456789  Lock_time: 0.000123  Rows_sent: 1000  Rows_examined: 50000
SELECT * FROM orders WHERE create_time > '2025-01-01' ORDER BY id DESC;
```

**🔧 使用mysqldumpslow分析**：
```bash
# 分析慢查询日志
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 参数说明：
# -s t: 按查询时间排序
# -t 10: 显示前10条
# -s c: 按查询次数排序
# -s r: 按返回记录数排序
```

**📊 通过Performance Schema分析**：
```sql
-- 查找最慢的查询模式
SELECT 
    DIGEST_TEXT as query_pattern,
    COUNT_STAR as execution_count,
    AVG_TIMER_WAIT/1000000000 as avg_seconds,
    MAX_TIMER_WAIT/1000000000 as max_seconds,
    SUM_ROWS_EXAMINED as total_rows_examined,
    SUM_ROWS_SENT as total_rows_sent
FROM performance_schema.events_statements_summary_by_digest 
WHERE AVG_TIMER_WAIT > 1000000000  -- 大于1秒
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

### 4.4 慢查询优化建议


> 💡 **优化思路框架**：
```
慢查询发现 → 执行计划分析 → 索引优化 → SQL重写 → 再次验证

具体步骤：
1️⃣ 使用 EXPLAIN 分析执行计划
2️⃣ 检查是否缺少合适的索引
3️⃣ 考虑SQL语句重写
4️⃣ 验证优化效果
```

---

## 5. ⚡ 实时性能监控


### 5.1 实时监控的重要性


**场景对比**：
```
没有实时监控：           有实时监控：
━━━━━━━━━━━━━━          ━━━━━━━━━━━━
用户反馈 → 问题发现        系统告警 → 主动发现
问题定位困难             实时数据支持定位  
影响范围扩大             及时止损控制影响
```

### 5.2 核心实时监控指标


**📊 关键性能指标仪表板**：
```sql
-- 实时性能监控查询
SELECT 
    'Current Connections' as metric,
    VARIABLE_VALUE as value,
    'connections' as unit
FROM information_schema.GLOBAL_STATUS 
WHERE VARIABLE_NAME = 'Threads_connected'

UNION ALL

SELECT 
    'QPS' as metric,
    ROUND(VARIABLE_VALUE / UPTIME) as value,
    'queries/sec' as unit
FROM 
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Queries') q,
    (SELECT VARIABLE_VALUE as UPTIME FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Uptime') u;
```

**🔍 实时进程监控**：
```sql
-- 查看当前正在执行的查询
SELECT 
    Id,
    User,
    Host,
    db,
    Command,
    Time,
    State,
    LEFT(Info, 100) as Query_Preview
FROM information_schema.PROCESSLIST 
WHERE Command != 'Sleep'
ORDER BY Time DESC;
```

### 5.3 自动化监控脚本


**📜 简单的监控脚本示例**：
```bash
#!/bin/bash
# mysql_monitor.sh

# MySQL连接信息
MYSQL_USER="monitor_user"
MYSQL_PASS="monitor_pass"
MYSQL_HOST="localhost"

# 获取当前连接数
connections=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW STATUS LIKE 'Threads_connected';" | tail -1 | awk '{print $2}')

# 获取慢查询数量
slow_queries=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -h$MYSQL_HOST -e "SHOW STATUS LIKE 'Slow_queries';" | tail -1 | awk '{print $2}')

# 输出监控数据
echo "$(date): Connections=$connections, Slow_Queries=$slow_queries"

# 告警阈值检查
if [ $connections -gt 100 ]; then
    echo "警告：连接数过高 ($connections)"
fi
```

---

## 6. 📏 性能基线管理


### 6.1 什么是性能基线


**通俗理解**：性能基线就像体检报告中的"正常值范围"

```
体检指标              MySQL性能基线
━━━━━━━━━━━━         ━━━━━━━━━━━━━━━━━━
血压：120/80         QPS：正常1000-2000
心率：60-100         响应时间：正常<100ms  
血糖：3.9-6.1        连接数：正常<50
```

> 💡 **基线作用**：当前性能 vs 基线性能 = 判断系统健康状态

### 6.2 建立性能基线


**📊 基线数据收集**：
```sql
-- 创建性能基线表
CREATE TABLE performance_baseline (
    id INT AUTO_INCREMENT PRIMARY KEY,
    metric_name VARCHAR(100),
    metric_value DECIMAL(15,2),
    record_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    business_period VARCHAR(50), -- 业务时期：peak_hour, normal, low
    INDEX idx_metric_time (metric_name, record_time)
);

-- 收集基线数据
INSERT INTO performance_baseline (metric_name, metric_value, business_period)
SELECT 
    'avg_query_time' as metric_name,
    AVG(AVG_TIMER_WAIT)/1000000000 as metric_value,
    CASE 
        WHEN HOUR(NOW()) BETWEEN 9 AND 11 THEN 'peak_hour'
        WHEN HOUR(NOW()) BETWEEN 14 AND 16 THEN 'peak_hour'  
        ELSE 'normal'
    END as business_period
FROM performance_schema.events_statements_summary_by_digest
WHERE COUNT_STAR > 100;
```

### 6.3 基线对比分析


```sql
-- 当前性能 vs 历史基线对比
SELECT 
    current.metric_name,
    current.current_value,
    baseline.baseline_value,
    ROUND(
        ((current.current_value - baseline.baseline_value) / baseline.baseline_value) * 100, 2
    ) as deviation_percent
FROM (
    -- 当前性能数据
    SELECT 'avg_query_time' as metric_name, 
           AVG(AVG_TIMER_WAIT)/1000000000 as current_value
    FROM performance_schema.events_statements_summary_by_digest
    WHERE COUNT_STAR > 10
) current
JOIN (
    -- 基线数据
    SELECT metric_name, AVG(metric_value) as baseline_value
    FROM performance_baseline 
    WHERE metric_name = 'avg_query_time'
    AND record_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    GROUP BY metric_name
) baseline ON current.metric_name = baseline.metric_name;
```

---

## 7. 🚨 监控告警配置


### 7.1 告警体系设计


**📋 告警级别分类**：

```
🔴 紧急告警 (Critical)
   - 数据库无法连接
   - 磁盘空间不足5%
   - 主从复制中断

🟡 警告告警 (Warning)  
   - 慢查询数量激增
   - 连接数超过80%
   - CPU使用率>80%

🟢 提醒告警 (Info)
   - 性能指标异常波动
   - 备份任务完成通知
```

### 7.2 告警规则配置


**📊 基于阈值的告警**：
```sql
-- 创建告警规则表
CREATE TABLE alert_rules (
    id INT AUTO_INCREMENT PRIMARY KEY,
    rule_name VARCHAR(100),
    metric_name VARCHAR(100),
    operator ENUM('>', '<', '=', '>=', '<='),
    threshold_value DECIMAL(15,2),
    alert_level ENUM('critical', 'warning', 'info'),
    enabled BOOLEAN DEFAULT TRUE
);

-- 插入告警规则
INSERT INTO alert_rules (rule_name, metric_name, operator, threshold_value, alert_level)
VALUES 
('慢查询过多', 'slow_query_rate', '>', 5.0, 'warning'),
('连接数过高', 'connection_usage_percent', '>', 80.0, 'warning'),
('磁盘使用率', 'disk_usage_percent', '>', 90.0, 'critical');
```

**🔧 简单告警检查脚本**：
```bash
#!/bin/bash
# alert_check.sh

# 检查慢查询比例
slow_queries=$(mysql -e "SHOW STATUS LIKE 'Slow_queries';" | tail -1 | awk '{print $2}')
total_queries=$(mysql -e "SHOW STATUS LIKE 'Questions';" | tail -1 | awk '{print $2}')

if [ $total_queries -gt 0 ]; then
    slow_rate=$(echo "scale=2; $slow_queries * 100 / $total_queries" | bc)
    if [ $(echo "$slow_rate > 5" | bc) -eq 1 ]; then
        echo "警告：慢查询比例过高 ${slow_rate}%"
        # 这里可以接入邮件或短信告警
    fi
fi
```

---

## 8. 📈 性能报表生成


### 8.1 日常性能报表


**📊 每日性能摘要**：
```sql
-- 每日性能报表
SELECT 
    DATE(NOW()) as report_date,
    '查询性能' as category,
    CONCAT(
        'QPS: ', ROUND(q.queries_per_second),
        ', 平均响应: ', ROUND(avg_response.avg_time, 3), 'ms',
        ', 慢查询: ', slow.slow_count
    ) as summary
FROM (
    SELECT VARIABLE_VALUE / (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Uptime') as queries_per_second
    FROM information_schema.GLOBAL_STATUS 
    WHERE VARIABLE_NAME = 'Questions'
) q,
(
    SELECT AVG(AVG_TIMER_WAIT)/1000000 as avg_time
    FROM performance_schema.events_statements_summary_by_digest
    WHERE COUNT_STAR > 10
) avg_response,
(
    SELECT VARIABLE_VALUE as slow_count
    FROM information_schema.GLOBAL_STATUS 
    WHERE VARIABLE_NAME = 'Slow_queries'
) slow;
```

### 8.2 性能趋势分析


**📈 性能趋势报表**：
```sql
-- 性能趋势分析（需要历史数据表）
CREATE TABLE daily_performance_stats (
    id INT AUTO_INCREMENT PRIMARY KEY,
    stat_date DATE,
    avg_qps DECIMAL(10,2),
    avg_response_time DECIMAL(10,3),
    slow_query_count INT,
    max_connections INT
);

-- 生成趋势报表
SELECT 
    stat_date,
    avg_qps,
    avg_response_time,
    slow_query_count,
    LAG(avg_qps) OVER (ORDER BY stat_date) as prev_qps,
    ROUND(
        ((avg_qps - LAG(avg_qps) OVER (ORDER BY stat_date)) / 
         LAG(avg_qps) OVER (ORDER BY stat_date)) * 100, 2
    ) as qps_change_percent
FROM daily_performance_stats 
WHERE stat_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
ORDER BY stat_date;
```

---

## 9. 🔧 监控工具集成


### 9.1 常用监控工具


**🛠️ 开源监控工具**：

```
┌─────────────────────────────────────────┐
│              监控工具生态                │  
├─────────────────────────────────────────┤
│ Prometheus + Grafana                    │ ← 最流行的组合
│   - 指标采集 + 可视化                   │
│   - 支持告警规则                        │
├─────────────────────────────────────────┤
│ Zabbix                                  │ ← 企业级监控
│   - 完整的监控解决方案                  │
│   - 支持多种数据库                      │  
├─────────────────────────────────────────┤
│ Percona Monitoring and Management       │ ← MySQL专用
│   - 专为MySQL优化                      │
│   - 深度性能分析                        │
└─────────────────────────────────────────┘
```

### 9.2 Prometheus集成示例


**📊 MySQL Exporter配置**：
```yaml
# docker-compose.yml
version: '3'
services:
  mysql-exporter:
    image: prom/mysqld-exporter
    ports:
      - "9104:9104"
    environment:
      - DATA_SOURCE_NAME=monitor_user:password@(mysql:3306)/
    command:
      - --collect.info_schema.processlist
      - --collect.info_schema.tables
      - --collect.perf_schema.eventsstatements
```

**🔍 Grafana仪表板配置**：
```json
{
  "dashboard": {
    "title": "MySQL Performance Dashboard",
    "panels": [
      {
        "title": "QPS",
        "targets": [
          {
            "expr": "rate(mysql_global_status_queries[5m])"
          }
        ]
      },
      {
        "title": "Slow Queries",
        "targets": [
          {
            "expr": "rate(mysql_global_status_slow_queries[5m])"
          }
        ]
      }
    ]
  }
}
```

### 9.3 自定义监控脚本


**🐍 Python监控脚本示例**：
```python
import pymysql
import time
import json

class MySQLMonitor:
    def __init__(self, host, user, password, database):
        self.connection = pymysql.connect(
            host=host, user=user, password=password, database=database
        )
    
    def get_status_variable(self, variable_name):
        """获取状态变量值"""
        with self.connection.cursor() as cursor:
            cursor.execute(f"SHOW STATUS LIKE '{variable_name}'")
            result = cursor.fetchone()
            return int(result[1]) if result else 0
    
    def monitor_qps(self, interval=60):
        """监控QPS"""
        prev_queries = self.get_status_variable('Questions')
        time.sleep(interval)
        current_queries = self.get_status_variable('Questions')
        
        qps = (current_queries - prev_queries) / interval
        return qps
    
    def get_performance_summary(self):
        """获取性能摘要"""
        return {
            'timestamp': time.time(),
            'connections': self.get_status_variable('Threads_connected'),
            'slow_queries': self.get_status_variable('Slow_queries'),
            'qps': self.monitor_qps(5)  # 5秒采样
        }

# 使用示例
monitor = MySQLMonitor('localhost', 'monitor', 'password', 'test')
summary = monitor.get_performance_summary()
print(json.dumps(summary, indent=2))
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 Performance Schema：MySQL内置的性能监控系统
🔸 状态变量：记录MySQL运行状态的累计指标  
🔸 慢查询日志：识别性能问题的重要工具
🔸 性能基线：判断系统健康状态的参考标准
🔸 监控告警：主动发现问题的预警机制
```

### 10.2 关键理解要点


**🔹 监控体系的层次结构**：
```
系统层监控：CPU、内存、磁盘I/O
 ↓
数据库层监控：连接、查询、锁等待
 ↓  
应用层监控：业务指标、用户体验
 ↓
全链路监控：端到端性能分析
```

**🔹 监控数据的分析思路**：
```
数据收集 → 趋势分析 → 异常识别 → 根因定位 → 优化改进

关键原则：
- 先看趋势，再看绝对值
- 结合业务场景分析数据
- 关注异常波动和突变
- 建立完整的分析闭环
```

### 10.3 实际应用建议


> 📌 **监控实施路径**：
```
阶段1️⃣ 基础监控搭建
- 启用慢查询日志
- 配置基本状态变量监控
- 建立简单告警机制

阶段2️⃣ 深度分析工具
- 启用Performance Schema
- 建立性能基线
- 完善告警规则

阶段3️⃣ 自动化运维
- 集成专业监控工具
- 建立自动化分析
- 形成运维闭环
```

**🎯 监控重点关注指标**：
- **响应类**：平均响应时间、慢查询比例
- **吞吐类**：QPS/TPS、并发连接数
- **资源类**：CPU使用率、内存占用、磁盘I/O
- **稳定类**：错误率、可用性、主从延迟

### 10.4 常见问题与解决方案


```
❓ Performance Schema影响性能？
✅ 影响很小(<5%)，收益远大于成本

❓ 慢查询日志文件太大？
✅ 定期轮转日志，只保留最近数据

❓ 监控数据太多无从下手？
✅ 先关注核心指标，建立基线对比

❓ 告警太多产生疲劳？
✅ 调整阈值，分级处理，减少噪音
```

**🔧 最佳实践总结**：
- **持续监控**：7×24小时不间断监控
- **分层告警**：不同级别问题不同处理方式  
- **数据驱动**：基于监控数据做优化决策
- **定期回顾**：定期分析监控数据和告警历史

**核心记忆**：
- 监控是数据库运维的眼睛，没有监控就是盲飞
- Performance Schema是深度分析的利器
- 慢查询日志是发现性能问题的第一线索
- 基线管理让异常检测更准确
- 合理的告警机制是主动运维的基础