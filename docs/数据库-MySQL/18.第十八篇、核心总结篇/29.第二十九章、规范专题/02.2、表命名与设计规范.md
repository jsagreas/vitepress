---
title: 2、表命名与设计规范
---
## 📚 目录


1. [表命名基础规范](#1-表命名基础规范)
2. [业务模块与前缀管理](#2-业务模块与前缀管理)
3. [不同类型表的命名约定](#3-不同类型表的命名约定)
4. [表注释与文档规范](#4-表注释与文档规范)
5. [表关系设计规范](#5-表关系设计规范)
6. [表变更管理规范](#6-表变更管理规范)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📝 表命名基础规范



### 1.1 基本命名规则



**🔸 核心原则**
```
简单来说，表名就是数据库里存储信息的"容器"的名字
就像给文件夹起名字一样，要让别人一看就知道里面放的是什么
```

> **表名命名的黄金法则**
> - **见名知意**：一看表名就知道存储什么数据
> - **统一规范**：整个项目保持一致的命名风格
> - **简洁明了**：既要准确，又不能太冗长

**📋 基础命名要求**

| 规范项目 | **要求说明** | **正确示例** | **错误示例** |
|---------|------------|-------------|-----------|
| 🔤 **字符规范** | `只能使用小写字母、数字、下划线` | `user_info` | `UserInfo, user-info` |
| 📏 **长度限制** | `3-30个字符，建议不超过20个` | `product_category` | `a, very_long_table_name_for_user` |
| 🚫 **禁用词汇** | `避免MySQL关键字和保留字` | `user_list` | `order, select, table` |
| 📖 **可读性** | `用下划线分隔单词，提高可读性` | `order_detail` | `orderdetail, OrderDetail` |

### 1.2 命名格式标准



**🎯 推荐的命名模式**
```
格式：[业务前缀]_[主体名词]_[修饰词]

实际应用：
sys_user_info     → 系统用户信息表
shop_product_spec → 商城商品规格表
log_error_record  → 错误日志记录表
```

**💡 命名思路解析**
```
第一步：确定业务模块
- 用户系统 → user
- 订单系统 → order  
- 商品系统 → product

第二步：明确主要功能
- 基础信息 → info
- 详细资料 → detail
- 配置设置 → config

第三步：添加修饰说明
- 历史数据 → history
- 临时数据 → temp
- 日志记录 → log
```

### 1.3 常见命名错误



**❌ 应该避免的命名方式**
```
1. 使用中文拼音
错误：yonghu_xinxi
正确：user_info

2. 大小写混用
错误：User_Info, userInfo
正确：user_info

3. 使用缩写过度
错误：usr_inf, prd_cat
正确：user_info, product_category

4. 命名过于简单
错误：data, info, temp
正确：user_data, system_info, cache_temp
```

---

## 2. 🏢 业务模块与前缀管理



### 2.1 业务模块划分原则



**🔸 什么是业务模块**
```
简单理解：业务模块就是把整个系统按功能分成不同的"部门"
每个部门负责不同的工作，表名用前缀来标识属于哪个部门

比如一个电商系统：
- 用户部门：负责用户注册、登录、个人信息
- 商品部门：负责商品展示、分类、库存管理  
- 订单部门：负责下单、支付、物流跟踪
```

**📊 常见业务模块划分**

```
系统核心模块：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  用户模块   │    │  权限模块   │    │  系统配置   │
│   user_     │    │   auth_     │    │   sys_      │
└─────────────┘    └─────────────┘    └─────────────┘

业务功能模块：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  商品模块   │    │  订单模块   │    │  支付模块   │
│ product_    │    │  order_     │    │   pay_      │
└─────────────┘    └─────────────┘    └─────────────┘

辅助支撑模块：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  日志模块   │    │  消息模块   │    │  文件模块   │
│   log_      │    │   msg_      │    │  file_      │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 2.2 前缀使用规范



**🏷️ 标准前缀定义**

| 前缀类型 | **前缀示例** | **适用场景** | **表名举例** |
|---------|-------------|-------------|-------------|
| **用户相关** | `user_` | `用户信息、用户行为` | `user_info, user_login_log` |
| **商品相关** | `product_` | `商品管理、分类` | `product_info, product_category` |
| **订单相关** | `order_` | `订单流程、支付` | `order_info, order_item` |
| **系统管理** | `sys_` | `系统配置、权限` | `sys_config, sys_menu` |
| **日志相关** | `log_` | `操作日志、错误日志` | `log_operate, log_error` |
| **消息相关** | `msg_` | `站内信、推送消息` | `msg_user, msg_template` |

**💡 前缀使用最佳实践**
```
1. 前缀要简短明了（3-6个字符）
   ✓ user_    ✓ sys_    ✓ log_
   ✗ user_management_  ✗ system_

2. 团队内部保持一致
   所有人都用 user_ 不要有人用 usr_ 或 u_

3. 避免过度细分
   不要搞太多前缀，一般10个以内就够了

4. 考虑未来扩展
   预留一些通用前缀，方便后续业务发展
```

### 2.3 前缀管理策略



**📋 前缀注册表**
```sql
-- 建议维护一个前缀注册表，避免重复和冲突

CREATE TABLE sys_table_prefix (
    prefix VARCHAR(10) NOT NULL COMMENT '前缀名称',
    module_name VARCHAR(50) NOT NULL COMMENT '模块名称', 
    description TEXT COMMENT '模块描述',
    owner VARCHAR(20) COMMENT '负责人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (prefix)
) COMMENT='表前缀注册表';

-- 示例数据
INSERT INTO sys_table_prefix VALUES 
('user_', '用户模块', '用户注册登录、个人信息管理', '张三', NOW()),
('order_', '订单模块', '订单生成、支付、物流跟踪', '李四', NOW());
```

---

## 3. 📊 不同类型表的命名约定



### 3.1 主业务表命名



**🔸 什么是主业务表**
```
主业务表就是存储核心业务数据的表，是整个系统最重要的表
比如：用户表、商品表、订单表等，这些表的数据是业务运转的基础
```

**📝 主业务表命名规范**
```
格式：[模块前缀]_[核心名词]

示例说明：
user_info        → 用户基本信息表（最核心的用户数据）
product_info     → 商品基本信息表（商品的核心属性）
order_info       → 订单主表（订单的基本信息）
customer_info    → 客户信息表（客户基础资料）
```

### 3.2 关联表与详情表



**🔗 关联表命名**
```
作用：连接两个主表的桥梁表，通常存储多对多关系

命名格式：[主表]_[从表] 或 [主表]_rel_[从表]

实际应用：
user_role        → 用户角色关联表
product_category → 商品分类关联表  
order_product    → 订单商品关联表
course_student   → 课程学生关联表
```

**📋 详情表命名**
```
作用：存储主表的详细信息，通常是一对一或一对多关系

命名格式：[主表]_detail 或 [主表]_item

应用场景：
order_detail     → 订单详情表（订单包含的商品明细）
product_detail   → 商品详情表（商品的详细描述）
user_profile     → 用户档案表（用户的详细资料）
invoice_item     → 发票明细表（发票的条目详情）
```

### 3.3 配置与字典表



**⚙️ 配置表命名**
```sql
-- 配置表：存储系统运行所需的各种设置参数

sys_config       → 系统全局配置表
user_config      → 用户个性化配置表
app_config       → 应用程序配置表
email_config     → 邮件服务配置表

-- 配置表通常的结构
CREATE TABLE sys_config (
    config_key VARCHAR(50) PRIMARY KEY COMMENT '配置键名',
    config_value TEXT COMMENT '配置值',
    config_desc VARCHAR(200) COMMENT '配置说明',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT='系统配置表';
```

**📚 字典表命名**
```sql
-- 字典表：存储系统中各种下拉选项、状态码等枚举数据

sys_dict_type    → 字典类型表（字典的分类）
sys_dict_data    → 字典数据表（具体的字典项）
region_dict      → 地区字典表
status_dict      → 状态字典表

-- 字典表示例结构  
CREATE TABLE sys_dict_data (
    dict_id INT AUTO_INCREMENT PRIMARY KEY,
    dict_type VARCHAR(50) NOT NULL COMMENT '字典类型',
    dict_label VARCHAR(100) COMMENT '字典标签',
    dict_value VARCHAR(100) COMMENT '字典值',
    sort_order INT DEFAULT 0 COMMENT '排序'
) COMMENT='字典数据表';
```

### 3.4 临时表与历史表



**⏰ 临时表命名规范**
```
临时表：存储临时数据，用完就删除的表

命名格式：temp_[业务名称]_[时间标识]

使用场景：
temp_import_user_20250120    → 用户导入临时表
temp_report_data_202501      → 报表数据临时表
temp_calc_result_daily       → 每日计算结果临时表
temp_batch_process_001       → 批处理临时表

注意事项：
1. 临时表要及时清理，避免占用空间
2. 建议加上时间标识，方便识别和清理
3. 可以考虑使用定时任务自动清理过期临时表
```

**📜 历史表命名规范**
```
历史表：存储过期或删除的数据，用于备份和审计

命名格式：[原表名]_history 或 [原表名]_his

数据迁移场景：
user_info          → user_info_history     (用户信息历史表)
order_info         → order_info_history    (订单信息历史表)  
product_info       → product_info_his      (商品信息历史表)
log_operate        → log_operate_history   (操作日志历史表)

历史表结构建议：
1. 保持与原表完全相同的字段结构
2. 添加归档时间字段 archived_at
3. 添加归档原因字段 archive_reason
```

### 3.5 分区表命名规则



**🔄 什么是分区表**
```
分区表就是把一个大表按照某种规则拆分成多个小表
比如按时间分区：把一年的数据分成12个月的分区
这样查询时只需要扫描相关分区，提高查询效率
```

**📅 分区表命名策略**
```
时间分区表：
log_operate_2025     → 2025年操作日志表
log_operate_202501   → 2025年1月操作日志表
sales_data_q1_2025   → 2025年第一季度销售数据表

范围分区表：
user_info_part1      → 用户信息分区表1 (ID: 1-100万)
user_info_part2      → 用户信息分区表2 (ID: 100万-200万)

地区分区表：  
order_info_cn        → 中国区订单表
order_info_us        → 美国区订单表
order_info_eu        → 欧洲区订单表
```

### 3.6 视图命名规范



**👁️ 视图的作用**
```
视图就像是数据库的"快捷方式"
它不存储实际数据，而是保存一个查询语句
每次访问视图时，数据库会执行这个查询并返回结果

优点：
- 简化复杂查询，用户不需要写复杂的SQL
- 隐藏表结构细节，提高安全性
- 统一数据展示格式
```

**📊 视图命名约定**
```
命名格式：v_[业务场景]_[说明] 或 view_[业务场景]

常用视图示例：
v_user_summary       → 用户汇总信息视图
v_order_detail       → 订单详情视图  
v_product_stats      → 商品统计视图
v_sales_report       → 销售报表视图
view_customer_360    → 客户360度视图

创建视图示例：
CREATE VIEW v_user_summary AS
SELECT 
    u.user_id,
    u.username,
    u.email,
    COUNT(o.order_id) as order_count,
    SUM(o.total_amount) as total_spent
FROM user_info u
LEFT JOIN order_info o ON u.user_id = o.user_id  
GROUP BY u.user_id;
```

---

## 4. 📝 表注释与文档规范



### 4.1 表注释标准



**🔸 为什么要写表注释**
```
表注释就像给表写一个"说明书"，告诉别人这个表是做什么用的
特别是在团队协作时，好的注释能让其他人快速理解表的用途
避免出现"这个表是谁建的？存的什么数据？"这样的困惑
```

**📋 注释内容要求**

> **表注释必须包含的信息**
> - **表的用途**：简洁说明存储什么业务数据
> - **关键字段**：重要字段的含义说明
> - **关联关系**：与其他表的关系
> - **特殊说明**：业务规则、使用注意事项

**💡 表注释示例**
```sql
-- 好的表注释示例
CREATE TABLE user_info (
    user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID，主键',
    username VARCHAR(50) NOT NULL COMMENT '用户名，唯一标识，3-20字符',
    email VARCHAR(100) COMMENT '邮箱地址，用于登录和找回密码',
    phone VARCHAR(15) COMMENT '手机号，格式：13800138000',
    status TINYINT DEFAULT 1 COMMENT '状态：1-正常 2-禁用 3-删除',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_username (username),
    INDEX idx_email (email)
) COMMENT='用户基本信息表，存储用户注册信息和基本资料，与user_profile表一对一关联';

-- 不好的注释示例
CREATE TABLE user_info (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100) 
) COMMENT='用户表';  -- 注释太简单，没有说明用途和字段含义
```

### 4.2 字段注释规范



**📝 字段注释的写法**
```sql
-- 基础信息字段
user_id INT COMMENT '用户唯一标识符'
username VARCHAR(50) COMMENT '用户登录名，3-20个字符，不可重复'  
password VARCHAR(255) COMMENT '加密后的用户密码，使用bcrypt算法'

-- 状态类字段
status TINYINT COMMENT '用户状态：0-未激活 1-正常 2-冻结 3-注销'
is_vip BOOLEAN COMMENT '是否VIP用户：true-是 false-否'
gender TINYINT COMMENT '性别：1-男 2-女 0-未知'

-- 时间类字段  
created_at TIMESTAMP COMMENT '创建时间，记录用户注册时间'
last_login_at TIMESTAMP COMMENT '最后登录时间，用于统计用户活跃度'
expired_at TIMESTAMP COMMENT '过期时间，VIP到期时间'

-- 金额类字段
balance DECIMAL(10,2) COMMENT '账户余额，单位：元，保留2位小数'
total_spent DECIMAL(12,2) COMMENT '累计消费金额，单位：元'
```

### 4.3 表设计文档要求



**📊 设计文档模板**
```markdown
# 表设计文档：user_info



## 基本信息


- **表名**：user_info  
- **中文名**：用户信息表
- **用途**：存储用户基本注册信息和账户状态
- **预估数据量**：100万条/年
- **负责人**：张三

## 字段设计


| 字段名 | 类型 | 长度 | 是否必填 | 默认值 | 说明 |
|-------|------|------|---------|--------|------|
| user_id | INT | - | 是 | AUTO | 用户主键ID |
| username | VARCHAR | 50 | 是 | - | 用户名，唯一 |
| email | VARCHAR | 100 | 否 | - | 邮箱地址 |
| status | TINYINT | - | 否 | 1 | 用户状态 |

## 索引设计


- **主键**：user_id
- **唯一键**：username, email  
- **普通索引**：status, created_at

## 关联关系


- **一对一**：user_profile（用户详细信息）
- **一对多**：user_login_log（登录日志）
- **多对多**：通过user_role关联角色表

## 业务规则


1. username必须唯一，3-20个字符
2. email格式必须正确，可为空但不能重复
3. 用户注销后status改为3，数据保留不删除

## 变更记录  


- 2025-01-01：创建表结构 - 张三
- 2025-01-15：增加phone字段 - 李四
```

---

## 5. 🔗 表关系设计规范



### 5.1 表关系类型说明



**🔸 什么是表关系**
```
表关系就是描述不同表之间数据的关联方式
就像现实生活中人与人的关系一样：
- 一个人只能有一个身份证号（一对一）
- 一个班级可以有多个学生（一对多）  
- 一个学生可以选修多门课程，一门课程也有多个学生（多对多）
```

**📊 三种基本关系类型**

```
一对一关系 (1:1)
用户表 ←→ 用户详情表
┌──────────────┐    ┌──────────────┐
│  user_info   │    │ user_profile │
├──────────────┤    ├──────────────┤
│ user_id (PK) │←→  │ user_id (FK) │
│ username     │    │ real_name    │
│ email        │    │ address      │
└──────────────┘    └──────────────┘

一对多关系 (1:N)  
用户表 ←→ 订单表
┌──────────────┐    ┌──────────────┐
│  user_info   │    │  order_info  │
├──────────────┤    ├──────────────┤
│ user_id (PK) │←─┐ │ order_id(PK) │
│ username     │  └→│ user_id (FK) │
│ email        │    │ total_amount │
└──────────────┘    └──────────────┘

多对多关系 (M:N)
学生表 ←→ 课程表
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   student   │  │stu_course   │  │   course    │
├─────────────┤  ├─────────────┤  ├─────────────┤
│student_id(PK│←─┤student_id(FK│  │course_id(PK)│
│ name        │  │course_id(FK)├─→│ name        │
│ class       │  │ score       │  │ teacher     │
└─────────────┘  └─────────────┘  └─────────────┘
```

### 5.2 外键命名规范



**🔑 外键字段命名**
```sql
-- 外键字段命名格式：[关联表名]_[关联字段名]
-- 通常关联的都是主表的主键字段

示例说明：
order_info.user_id     → 关联user_info.user_id
product_info.category_id → 关联category_info.category_id  
order_detail.product_id  → 关联product_info.product_id

-- 特殊情况的命名
parent_id              → 自关联，指向本表的父级记录
creator_user_id        → 创建者用户ID，区别于普通的user_id
manager_user_id        → 管理员用户ID，避免字段名冲突
```

**🗂️ 外键约束命名**
```sql  
-- 外键约束命名格式：fk_[当前表名]_[关联表名]_[字段名]

ALTER TABLE order_info 
ADD CONSTRAINT fk_order_info_user_info_user_id 
FOREIGN KEY (user_id) REFERENCES user_info(user_id);

ALTER TABLE order_detail
ADD CONSTRAINT fk_order_detail_order_info_order_id
FOREIGN KEY (order_id) REFERENCES order_info(order_id);

ALTER TABLE order_detail  
ADD CONSTRAINT fk_order_detail_product_info_product_id
FOREIGN KEY (product_id) REFERENCES product_info(product_id);
```

### 5.3 关联表设计规范



**🔗 中间表设计原则**
```sql
-- 多对多关系必须通过中间表实现
-- 中间表命名：[主表名]_[从表名] 或 [主表名]_rel_[从表名]

-- 用户角色关联表
CREATE TABLE user_role (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '关联ID',
    user_id INT NOT NULL COMMENT '用户ID',  
    role_id INT NOT NULL COMMENT '角色ID',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '分配时间',
    assigned_by INT COMMENT '分配人ID',
    status TINYINT DEFAULT 1 COMMENT '状态：1-有效 0-无效',
    
    UNIQUE KEY uk_user_role (user_id, role_id),
    INDEX idx_user_id (user_id),
    INDEX idx_role_id (role_id),
    
    FOREIGN KEY (user_id) REFERENCES user_info(user_id),
    FOREIGN KEY (role_id) REFERENCES role_info(role_id)
) COMMENT='用户角色关联表，实现用户与角色的多对多关系';

-- 商品标签关联表
CREATE TABLE product_tag (
    product_id INT NOT NULL COMMENT '商品ID',
    tag_id INT NOT NULL COMMENT '标签ID', 
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    PRIMARY KEY (product_id, tag_id),  -- 联合主键
    INDEX idx_tag_id (tag_id)
) COMMENT='商品标签关联表';
```

### 5.4 表关系图规范



**📈 关系图绘制要求**

> **表关系图应该包含的元素**
> - **表结构**：显示主要字段和数据类型
> - **主键标识**：明确标出主键字段（PK）
> - **外键标识**：明确标出外键字段（FK）
> - **关系线**：用线条连接相关表，标注关系类型
> - **注释说明**：重要的业务关系说明

**🎨 关系图示例**
```
电商系统核心表关系图

用户模块                     订单模块                    商品模块
┌─────────────────┐         ┌─────────────────┐        ┌─────────────────┐
│   user_info     │         │   order_info    │        │  product_info   │
├─────────────────┤         ├─────────────────┤        ├─────────────────┤
│ user_id (PK)    │◄────────┤ user_id (FK)    │        │ product_id (PK) │
│ username        │  1:N    │ order_id (PK)   │        │ product_name    │
│ email           │         │ total_amount    │        │ price           │
│ created_at      │         │ status          │        │ stock           │
└─────────────────┘         │ created_at      │        └─────────────────┘
                            └─────────────────┘                 ▲
                                     │                          │
                                     │ 1:N                      │ N:1
                                     ▼                          │
                            ┌─────────────────┐                 │
                            │  order_detail   │                 │
                            ├─────────────────┤                 │
                            │ detail_id (PK)  │                 │
                            │ order_id (FK)   │─────────────────┘
                            │ product_id (FK) │ N:1
                            │ quantity        │
                            │ unit_price      │
                            └─────────────────┘

关系说明：
1. 一个用户可以有多个订单 (user_info 1:N order_info)
2. 一个订单可以包含多个商品 (order_info 1:N order_detail)  
3. 一个商品可以出现在多个订单中 (product_info 1:N order_detail)
```

---

## 6. 📋 表变更管理规范



### 6.1 变更记录规范



**🔸 为什么要记录表变更**
```
数据库表结构的变更就像软件版本更新一样，需要有详细记录
这样做的好处：
1. 出问题时能快速定位是哪次变更导致的
2. 新人加入团队时能了解表结构演进历史
3. 数据库升级时能按照变更记录逐步执行
4. 回滚时有据可查，知道要回到哪个版本
```

**📝 变更记录表设计**
```sql
CREATE TABLE sys_table_change_log (
    change_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '变更ID',
    table_name VARCHAR(64) NOT NULL COMMENT '表名',
    change_type ENUM('CREATE','ALTER','DROP','RENAME') COMMENT '变更类型',
    change_desc TEXT COMMENT '变更描述',
    sql_content TEXT COMMENT '执行的SQL语句',
    change_reason VARCHAR(500) COMMENT '变更原因',
    change_by VARCHAR(50) COMMENT '变更人',
    change_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '变更时间',
    version VARCHAR(20) COMMENT '版本号',
    status ENUM('PENDING','SUCCESS','FAILED','ROLLBACK') DEFAULT 'PENDING' COMMENT '执行状态',
    
    INDEX idx_table_name (table_name),
    INDEX idx_change_at (change_at)
) COMMENT='数据库表变更日志表';
```

### 6.2 变更操作流程



**📊 变更流程图**
```
变更申请 → 代码审查 → 测试验证 → 生产部署 → 记录归档

第一步：变更申请
├─ 填写变更原因和目标
├─ 编写变更SQL脚本  
├─ 评估影响范围和风险
└─ 准备回滚方案

第二步：代码审查
├─ 数据库管理员审查SQL
├─ 检查命名规范是否符合
├─ 评估性能影响
└─ 确认变更的必要性

第三步：测试验证
├─ 在测试环境执行变更
├─ 验证功能是否正常
├─ 测试回滚脚本
└─ 性能测试（如有必要）

第四步：生产部署
├─ 选择合适的维护窗口
├─ 备份相关数据
├─ 执行变更脚本
└─ 验证变更结果

第五步：记录归档
├─ 更新变更日志表
├─ 更新数据库文档
├─ 通知相关团队
└─ 归档变更材料
```

### 6.3 常见变更操作规范



**➕ 新增表的变更记录**
```sql
-- 变更记录示例
INSERT INTO sys_table_change_log (
    table_name, change_type, change_desc, sql_content, 
    change_reason, change_by, version
) VALUES (
    'user_login_log', 'CREATE', '创建用户登录日志表',
    'CREATE TABLE user_login_log (...)', 
    '需要记录用户登录行为，用于安全审计和用户行为分析',
    '张三', 'v1.2.0'
);
```

**🔧 修改表结构的变更记录**
```sql
-- 变更类型：新增字段
INSERT INTO sys_table_change_log VALUES (
    NULL, 'user_info', 'ALTER', '新增用户手机号字段',
    'ALTER TABLE user_info ADD COLUMN phone VARCHAR(15) COMMENT "用户手机号";',
    '支持手机号登录功能，需要存储用户手机号',
    '李四', NOW(), 'v1.2.1', 'SUCCESS'
);

-- 变更类型：修改字段
INSERT INTO sys_table_change_log VALUES (
    NULL, 'user_info', 'ALTER', '扩大用户名长度限制',
    'ALTER TABLE user_info MODIFY username VARCHAR(50);',
    '现有20字符长度限制不够，需要支持更长的用户名',
    '王五', NOW(), 'v1.2.2', 'SUCCESS'
);

-- 变更类型：新增索引
INSERT INTO sys_table_change_log VALUES (
    NULL, 'order_info', 'ALTER', '新增订单状态索引',
    'ALTER TABLE order_info ADD INDEX idx_status (status);',
    '按订单状态查询的场景较多，需要添加索引优化查询性能',
    '赵六', NOW(), 'v1.2.3', 'SUCCESS'
);
```

### 6.4 变更版本管理



**🏷️ 版本号规则**
```
版本号格式：主版本号.次版本号.修订版本号

主版本号：重大功能更新，可能包含不兼容变更
次版本号：新增功能，向下兼容  
修订版本号：bug修复，性能优化

示例：
v1.0.0 → 系统初始版本
v1.1.0 → 新增用户积分功能相关表
v1.1.1 → 修复用户表索引问题
v1.2.0 → 新增订单模块相关表
v2.0.0 → 重构用户模块，调整表结构
```

**📦 数据库迁移脚本管理**
```sql
-- 创建数据库版本表
CREATE TABLE sys_db_version (
    version VARCHAR(20) PRIMARY KEY COMMENT '版本号',
    description TEXT COMMENT '版本描述',
    sql_file VARCHAR(100) COMMENT 'SQL脚本文件名',
    executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '执行时间',
    executed_by VARCHAR(50) COMMENT '执行人',
    execution_time INT COMMENT '执行耗时(秒)',
    
    INDEX idx_executed_at (executed_at)
) COMMENT='数据库版本管理表';

-- 迁移脚本命名规范
-- 格式：V{版本号}__{描述}.sql
V1.1.0__add_user_point_tables.sql
V1.1.1__fix_user_info_index.sql  
V1.2.0__add_order_module_tables.sql
V2.0.0__refactor_user_module.sql
```

---

## 7. 📋 核心要点总结



### 7.1 必须掌握的命名规范



```
🔸 基础命名规则：小写字母+下划线，见名知意
🔸 业务前缀管理：按模块划分，统一前缀标识
🔸 不同类型表：主表、关联表、配置表、临时表、历史表
🔸 视图命名约定：v_开头，体现查询用途
🔸 外键字段命名：[关联表]_[关联字段]格式
```

### 7.2 关键理解要点



**🔹 为什么要统一命名规范**
```
团队协作需要：
- 降低沟通成本，看表名就知道用途
- 减少理解错误，避免业务逻辑混乱
- 提高开发效率，快速定位相关表
- 便于系统维护，新人容易上手

系统扩展需要：
- 为未来功能扩展预留空间
- 保持整体架构的一致性
- 方便自动化工具的处理
```

**🔹 如何选择合适的命名方式**
```
考虑因素：
1. 业务领域：电商、教育、金融等不同领域有不同特点
2. 团队规模：小团队可以简化，大团队需要更严格
3. 系统复杂度：复杂系统需要更细致的分类
4. 发展阶段：初创期可以灵活，成熟期需要稳定

平衡原则：
- 简洁 vs 清晰：优先选择清晰表达，再考虑简化
- 统一 vs 灵活：团队内必须统一，但要为扩展留空间
- 当前 vs 未来：满足当前需求，考虑未来发展
```

### 7.3 实际应用建议



**📊 建立命名规范文档**
```markdown
# 项目数据库命名规范



## 前缀定义


- user_: 用户相关
- product_: 商品相关  
- order_: 订单相关
- sys_: 系统管理
- log_: 日志记录

## 命名检查清单


□ 表名是否符合格式要求
□ 前缀是否正确使用
□ 字段注释是否完整
□ 索引命名是否规范
□ 外键约束是否正确

## 审查要点


1. 新表创建前必须先申请前缀
2. 表结构变更必须记录日志
3. 重要表必须有详细设计文档
4. 定期检查命名规范执行情况
```

**🔧 自动化检查工具**
```sql
-- 检查不符合命名规范的表
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'your_database'
  AND table_name NOT REGEXP '^[a-z][a-z0-9_]*[a-z0-9]$'
  AND table_type = 'BASE TABLE';

-- 检查缺少注释的表  
SELECT table_name
FROM information_schema.tables t
WHERE table_schema = 'your_database'
  AND table_type = 'BASE TABLE' 
  AND (table_comment IS NULL OR table_comment = '');

-- 检查缺少主键的表
SELECT table_name
FROM information_schema.tables t
WHERE table_schema = 'your_database'
  AND table_type = 'BASE TABLE'
  AND NOT EXISTS (
    SELECT 1 FROM information_schema.key_column_usage k
    WHERE k.table_schema = t.table_schema
      AND k.table_name = t.table_name
      AND k.constraint_name = 'PRIMARY'
  );
```

### 7.4 常见问题避免



**❌ 应该避免的做法**
```
命名混乱：
- 同一项目中使用不同的命名风格
- 前缀不统一：user_info 和 usr_detail
- 缩写过度：usr, prd, ord

设计缺陷：
- 表之间关系不清晰
- 缺少必要的关联约束
- 字段含义不明确

文档不全：
- 表和字段缺少注释
- 没有设计文档
- 变更记录不完整
```

**✅ 推荐的最佳实践**
```
规范执行：
- 建立详细的命名规范文档
- 代码审查时检查命名规范
- 使用自动化工具定期检查

文档维护：
- 每个表都有完整的设计文档
- 及时更新表结构变更记录
- 定期回顾和优化规范

团队协作：
- 新人培训时重点讲解规范
- 定期分享规范使用经验
- 收集反馈并持续改进规范
```

**核心记忆口诀**：
- 命名规范要统一，见名知意最重要
- 前缀管理分模块，业务清晰好维护  
- 表间关系要明确，外键约束不能少
- 注释文档要完整，变更记录要做好