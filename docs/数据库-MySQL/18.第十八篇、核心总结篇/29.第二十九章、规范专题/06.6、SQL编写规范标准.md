---
title: 6、SQL编写规范标准
---
## 📚 目录

1. [SQL规范概述](#1-SQL规范概述)
2. [语句格式规范](#2-语句格式规范)
3. [命名约定标准](#3-命名约定标准)
4. [查询语句规范](#4-查询语句规范)
5. [函数使用原则](#5-函数使用原则)
6. [性能优化规范](#6-性能优化规范)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📋 SQL规范概述


### 1.1 为什么需要SQL编写规范


**🔸 现实问题**
```
没有规范的SQL代码就像一团乱麻：
- 看不懂别人写的SQL
- 维护困难，调试痛苦
- 性能问题难以排查
- 团队协作效率低下
```

**🔸 规范的价值**
- **📖 可读性**：代码像文章一样易读易懂
- **🔧 可维护性**：修改和扩展更加容易
- **⚡ 性能保障**：避免常见的性能陷阱
- **👥 团队协作**：统一标准，减少沟通成本

### 1.2 规范适用范围


```
适用场景：
✅ 业务查询SQL
✅ 数据分析脚本  
✅ 存储过程编写
✅ 视图定义语句
✅ 触发器代码
```

### 1.3 规范分类体系


```
SQL编写规范体系：
┌─────────────────┐
│   格式规范       │ ← 大小写、缩进、对齐
├─────────────────┤
│   命名规范       │ ← 表名、字段名、变量名
├─────────────────┤
│   语句规范       │ ← 查询、连接、子查询
├─────────────────┤
│   性能规范       │ ← 索引使用、复杂度控制
└─────────────────┘
```

---

## 2. ✍️ 语句格式规范


### 2.1 关键字大小写规则


**🔸 基本原则**
```sql
-- ✅ 推荐写法：SQL关键字大写，自定义名称小写
SELECT user_id, user_name, create_time
FROM user_info 
WHERE status = 'active'
ORDER BY create_time DESC;

-- ❌ 不推荐：关键字小写，混乱不统一
select USER_ID, User_Name, CREATE_TIME
from User_Info 
where Status = 'active'
order by CREATE_TIME desc;
```

**💡 为什么这样规定？**
- **区分度高**：一眼就能分出哪些是SQL关键字，哪些是自定义内容
- **阅读友好**：大写关键字在代码中更醒目
- **行业标准**：大多数SQL工具和书籍都采用这种写法

**🔸 关键字分类**
```sql
-- 查询关键字
SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT

-- 操作关键字  
INSERT, UPDATE, DELETE, REPLACE

-- 连接关键字
JOIN, INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN

-- 条件关键字
AND, OR, NOT, IN, EXISTS, LIKE, BETWEEN

-- 函数关键字
COUNT, SUM, AVG, MAX, MIN, DATE, SUBSTRING
```

### 2.2 缩进对齐标准


**🔸 基础缩进规则**
```sql
-- ✅ 标准缩进格式
SELECT 
    u.user_id,
    u.user_name,
    u.email,
    p.profile_photo
FROM user_info u
    LEFT JOIN user_profile p ON u.user_id = p.user_id
WHERE 
    u.status = 'active'
    AND u.create_time >= '2024-01-01'
ORDER BY 
    u.create_time DESC,
    u.user_id ASC;
```

**🔸 缩进层次说明**
```
缩进层次结构：
SELECT        ← 基准线(0级缩进)
    字段名     ← 4空格缩进(1级)
FROM          ← 基准线(0级缩进)  
    JOIN语句   ← 4空格缩进(1级)
WHERE         ← 基准线(0级缩进)
    条件语句   ← 4空格缩进(1级)
        子条件 ← 8空格缩进(2级)
```

**🔸 复杂查询缩进示例**
```sql
-- 多表关联查询的缩进格式
SELECT 
    u.user_id,
    u.user_name,
    COUNT(o.order_id) AS order_count,
    SUM(o.total_amount) AS total_spent
FROM user_info u
    LEFT JOIN order_info o ON u.user_id = o.user_id
    LEFT JOIN order_detail od ON o.order_id = od.order_id
WHERE 
    u.status = 'active'
    AND o.order_date >= '2024-01-01'
    AND (
        o.total_amount > 100 
        OR od.product_category = 'electronics'
    )
GROUP BY 
    u.user_id, 
    u.user_name
HAVING 
    COUNT(o.order_id) > 0
ORDER BY 
    total_spent DESC,
    order_count DESC
LIMIT 100;
```

### 2.3 注释编写规范


**🔸 注释类型和用法**
```sql
-- 单行注释：解释某一行的作用
SELECT user_id -- 用户唯一标识符
FROM user_info;

/* 
多行注释：解释整段代码的业务逻辑
用于查询活跃用户的订单统计信息
包括订单数量和消费总额
适用于月度报表生成
*/
SELECT 
    u.user_name,
    COUNT(o.order_id) AS order_count
FROM user_info u
    LEFT JOIN order_info o ON u.user_id = o.user_id
WHERE u.last_login >= DATE_SUB(NOW(), INTERVAL 30 DAY);
```

**🔸 注释最佳实践**
```sql
-- ✅ 好的注释：解释业务逻辑和复杂条件
SELECT 
    product_id,
    -- 计算含税价格（税率8%）
    price * 1.08 AS price_with_tax,
    -- 库存预警：小于10件标记为低库存
    CASE 
        WHEN stock_quantity < 10 THEN '库存不足'
        ELSE '库存充足'
    END AS stock_status
FROM product_info
WHERE 
    -- 只查询上架商品
    status = 'active'
    -- 排除测试数据
    AND product_id NOT LIKE 'TEST_%';

-- ❌ 不好的注释：重复代码内容
SELECT user_id -- 查询用户ID
FROM user_info -- 从用户信息表
WHERE user_id = 1; -- 用户ID等于1
```

### 2.4 长语句换行规则


**🔸 字段列表换行**
```sql
-- ✅ 每个字段占一行，便于阅读和维护
SELECT 
    user_id,
    user_name,
    email,
    phone,
    address,
    create_time,
    update_time
FROM user_info;

-- ❌ 所有字段挤在一行，难以阅读
SELECT user_id, user_name, email, phone, address, create_time, update_time FROM user_info;
```

**🔸 条件语句换行**
```sql
-- ✅ 复杂条件分行写，逻辑清晰
WHERE 
    user_status = 'active'
    AND create_time >= '2024-01-01'
    AND (
        user_type = 'premium' 
        OR total_orders > 10
    );

-- ❌ 条件挤在一行，难以理解
WHERE user_status = 'active' AND create_time >= '2024-01-01' AND (user_type = 'premium' OR total_orders > 10);
```

---

## 3. 🏷️ 命名约定标准


### 3.1 变量命名约定


**🔸 变量命名规则**
```sql
-- ✅ 推荐的变量命名方式
DECLARE @user_count INT;              -- 下划线分隔
DECLARE @start_date DATE;             -- 有意义的名称
DECLARE @max_order_amount DECIMAL;    -- 描述性命名

-- ❌ 不推荐的命名方式
DECLARE @uc INT;                      -- 缩写不明确
DECLARE @startDate DATE;              -- 驼峰式（不统一）
DECLARE @temp1 DECIMAL;               -- 无意义命名
```

**🔸 命名含义要求**
```sql
-- 变量名要能看出用途
DECLARE @current_user_id INT;         -- 当前用户ID
DECLARE @order_total_amount DECIMAL;  -- 订单总金额
DECLARE @is_vip_user BOOLEAN;         -- 是否VIP用户
DECLARE @last_login_date DATE;        -- 最后登录日期

-- 布尔类型变量用 is_, has_, can_ 等前缀
DECLARE @is_active BOOLEAN;           -- 是否激活
DECLARE @has_permission BOOLEAN;      -- 是否有权限
DECLARE @can_delete BOOLEAN;          -- 是否可删除
```

### 3.2 表别名规范


**🔸 别名命名原则**
```sql
-- ✅ 使用表名的有意义缩写
SELECT 
    u.user_name,     -- user_info → u
    p.phone_number,  -- user_profile → p  
    o.order_date     -- order_info → o
FROM user_info u
    LEFT JOIN user_profile p ON u.user_id = p.user_id
    LEFT JOIN order_info o ON u.user_id = o.user_id;

-- ❌ 使用无意义的字母
SELECT 
    a.user_name,
    b.phone_number,
    c.order_date
FROM user_info a
    LEFT JOIN user_profile b ON a.user_id = b.user_id
    LEFT JOIN order_info c ON a.user_id = c.user_id;
```

**🔸 常用表别名约定**
```sql
-- 标准别名对照表
user_info → u          -- 用户信息表
order_info → o         -- 订单信息表  
product_info → p       -- 商品信息表
category_info → c      -- 分类信息表
user_profile → up      -- 用户档案表
order_detail → od      -- 订单详情表
product_detail → pd    -- 商品详情表
```

### 3.3 字段引用规范


**🔸 字段前缀使用**
```sql
-- ✅ 多表查询时必须使用表前缀
SELECT 
    u.user_id,
    u.user_name,
    o.order_id,
    o.total_amount
FROM user_info u
    LEFT JOIN order_info o ON u.user_id = o.user_id;

-- ❌ 不使用前缀容易造成歧义
SELECT 
    user_id,        -- 不知道是哪个表的user_id
    user_name,
    order_id,
    total_amount
FROM user_info u
    LEFT JOIN order_info o ON u.user_id = o.user_id;
```

---

## 4. 🔍 查询语句规范


### 4.1 条件语句规范


**🔸 WHERE条件编写**
```sql
-- ✅ 条件按重要性和过滤效果排序
SELECT user_id, user_name
FROM user_info
WHERE 
    -- 1. 最有效的过滤条件放前面
    status = 'active'
    -- 2. 有索引的字段条件靠前
    AND user_id BETWEEN 1000 AND 2000
    -- 3. 时间范围条件
    AND create_time >= '2024-01-01'
    -- 4. 模糊查询放后面
    AND user_name LIKE '%张%';
```

**🔸 复杂条件组织**
```sql
-- ✅ 用括号明确逻辑关系
SELECT *
FROM order_info
WHERE 
    order_status = 'completed'
    AND (
        -- VIP用户或大额订单
        (user_type = 'vip' AND total_amount > 100)
        OR 
        (user_type = 'regular' AND total_amount > 500)
    )
    AND order_date >= '2024-01-01';
```

### 4.2 连接查询标准


**🔸 JOIN类型选择原则**
```sql
-- INNER JOIN：只要交集数据
SELECT u.user_name, o.order_id
FROM user_info u
    INNER JOIN order_info o ON u.user_id = o.user_id;

-- LEFT JOIN：保留左表所有数据  
SELECT u.user_name, o.order_id
FROM user_info u
    LEFT JOIN order_info o ON u.user_id = o.user_id;

-- 💡 选择原则：
-- 需要所有用户（包括没下单的）→ LEFT JOIN
-- 只需要下过单的用户 → INNER JOIN
```

**🔸 多表连接顺序**
```sql
-- ✅ 按关联关系的逻辑顺序连接
SELECT 
    u.user_name,
    o.order_id,
    od.product_name,
    od.quantity
FROM user_info u                    -- 主表
    LEFT JOIN order_info o          -- 用户的订单
        ON u.user_id = o.user_id
    LEFT JOIN order_detail od       -- 订单的商品详情
        ON o.order_id = od.order_id
WHERE u.status = 'active';
```

### 4.3 子查询使用规范


**🔸 子查询 vs 连接查询**
```sql
-- ✅ 简单情况优先使用JOIN
SELECT u.user_name, u.email
FROM user_info u
    INNER JOIN order_info o ON u.user_id = o.user_id
WHERE o.order_date >= '2024-01-01';

-- ✅ 复杂逻辑使用子查询更清晰
SELECT user_name, email
FROM user_info
WHERE user_id IN (
    SELECT user_id 
    FROM order_info 
    WHERE order_date >= '2024-01-01'
    GROUP BY user_id
    HAVING COUNT(*) > 5  -- 订单数量大于5的用户
);
```

**🔸 EXISTS vs IN**
```sql
-- ✅ 大数据量时使用EXISTS性能更好
SELECT user_name
FROM user_info u
WHERE EXISTS (
    SELECT 1 
    FROM order_info o 
    WHERE o.user_id = u.user_id
    AND o.total_amount > 1000
);

-- 小数据量时IN更直观
SELECT user_name  
FROM user_info
WHERE user_id IN (1001, 1002, 1003);
```

### 4.4 排序规则标准


**🔸 ORDER BY使用规范**
```sql
-- ✅ 明确指定排序方向
SELECT user_id, user_name, create_time
FROM user_info
WHERE status = 'active'
ORDER BY 
    create_time DESC,    -- 最新注册的用户在前
    user_id ASC;         -- 相同时间按ID升序

-- ✅ 多字段排序的业务逻辑
SELECT product_name, price, sales_count
FROM product_info
ORDER BY 
    sales_count DESC,    -- 销量高的在前
    price ASC,           -- 销量相同时价格低的在前
    product_id ASC;      -- 最后按ID排序保证结果稳定
```

### 4.5 分页查询规范


**🔸 LIMIT使用方法**
```sql
-- ✅ 标准分页写法
SELECT user_id, user_name, create_time
FROM user_info
WHERE status = 'active'
ORDER BY create_time DESC
LIMIT 20 OFFSET 40;      -- 第3页，每页20条

-- ✅ 大偏移量时的优化写法
SELECT user_id, user_name, create_time
FROM user_info
WHERE status = 'active'
    AND user_id > 1040   -- 使用上一页的最后一个ID
ORDER BY user_id ASC
LIMIT 20;
```

---

## 5. 🔧 函数使用原则


### 5.1 常用函数规范


**🔸 字符串函数**
```sql
-- ✅ 字符串处理的标准用法
SELECT 
    user_id,
    UPPER(user_name) AS user_name_upper,    -- 转大写
    SUBSTRING(phone, 1, 3) AS area_code,    -- 截取前3位
    CONCAT('用户:', user_name) AS display_name, -- 字符串连接
    LENGTH(email) AS email_length           -- 字符串长度
FROM user_info
WHERE 
    user_name IS NOT NULL
    AND LENGTH(user_name) > 2;
```

**🔸 日期函数**
```sql
-- ✅ 日期处理的常用方法
SELECT 
    user_id,
    create_time,
    DATE(create_time) AS create_date,           -- 提取日期部分
    YEAR(create_time) AS create_year,           -- 提取年份
    DATEDIFF(NOW(), create_time) AS days_ago,   -- 计算天数差
    DATE_ADD(create_time, INTERVAL 1 YEAR) AS next_year -- 日期加1年
FROM user_info
WHERE 
    create_time >= DATE_SUB(NOW(), INTERVAL 30 DAY);   -- 最近30天
```

**🔸 数值函数**
```sql
-- ✅ 数值计算函数
SELECT 
    product_id,
    price,
    ROUND(price * 0.8, 2) AS discounted_price,  -- 8折价格，保留2位小数
    CEIL(price) AS price_ceiling,               -- 向上取整
    FLOOR(price) AS price_floor,                -- 向下取整
    ABS(price - avg_price) AS price_diff        -- 与平均价格的差值
FROM product_info;
```

### 5.2 聚合函数使用


**🔸 基础聚合函数**
```sql
-- ✅ 聚合函数的正确用法
SELECT 
    user_type,
    COUNT(*) AS user_count,                 -- 总数统计
    COUNT(DISTINCT user_id) AS unique_users, -- 去重统计
    AVG(age) AS avg_age,                    -- 平均年龄
    MIN(create_time) AS earliest_register,  -- 最早注册时间
    MAX(create_time) AS latest_register     -- 最晚注册时间
FROM user_info
WHERE status = 'active'
GROUP BY user_type;
```

**🔸 条件聚合**
```sql
-- ✅ 使用CASE语句进行条件统计
SELECT 
    DATE(order_date) AS order_day,
    COUNT(*) AS total_orders,
    SUM(CASE WHEN total_amount > 100 THEN 1 ELSE 0 END) AS high_value_orders,
    SUM(CASE WHEN order_status = 'completed' THEN total_amount ELSE 0 END) AS completed_amount
FROM order_info
WHERE order_date >= '2024-01-01'
GROUP BY DATE(order_date)
ORDER BY order_day DESC;
```

### 5.3 函数性能考虑


**🔸 避免在WHERE中使用函数**
```sql
-- ❌ 在WHERE条件中使用函数影响索引
SELECT * FROM user_info
WHERE YEAR(create_time) = 2024;

-- ✅ 改写为范围查询，可以利用索引
SELECT * FROM user_info
WHERE create_time >= '2024-01-01'
    AND create_time < '2025-01-01';
```

**🔸 函数嵌套控制**
```sql
-- ❌ 过度嵌套的函数调用
SELECT UPPER(LEFT(TRIM(user_name), 10)) FROM user_info;

-- ✅ 分步骤处理，提高可读性
SELECT 
    user_name,
    TRIM(user_name) AS trimmed_name,
    LEFT(TRIM(user_name), 10) AS short_name,
    UPPER(LEFT(TRIM(user_name), 10)) AS final_name
FROM user_info;
```

---

## 6. ⚡ 性能优化规范


### 6.1 SQL复杂度控制


**🔸 复杂度分级**
```
SQL复杂度等级：
🟢 简单查询   ← 单表查询，简单条件
🟡 中等复杂   ← 2-3表连接，聚合计算  
🟠 复杂查询   ← 4+表连接，子查询，窗口函数
🔴 极复杂     ← 多层嵌套，复杂业务逻辑
```

**🔸 复杂查询拆分**
```sql
-- ❌ 过度复杂的单个查询
SELECT 
    u.user_name,
    (SELECT COUNT(*) FROM order_info WHERE user_id = u.user_id) AS order_count,
    (SELECT AVG(total_amount) FROM order_info WHERE user_id = u.user_id) AS avg_amount,
    (SELECT MAX(order_date) FROM order_info WHERE user_id = u.user_id) AS last_order
FROM user_info u
WHERE u.user_id IN (
    SELECT user_id FROM order_info 
    WHERE order_date >= '2024-01-01'
    GROUP BY user_id 
    HAVING COUNT(*) > 5
);

-- ✅ 拆分为多步骤，使用临时表
-- 步骤1：找出活跃用户
CREATE TEMPORARY TABLE active_users AS
SELECT user_id
FROM order_info
WHERE order_date >= '2024-01-01'
GROUP BY user_id
HAVING COUNT(*) > 5;

-- 步骤2：计算用户统计信息
SELECT 
    u.user_name,
    COUNT(o.order_id) AS order_count,
    AVG(o.total_amount) AS avg_amount,
    MAX(o.order_date) AS last_order
FROM user_info u
    INNER JOIN active_users au ON u.user_id = au.user_id
    LEFT JOIN order_info o ON u.user_id = o.user_id
GROUP BY u.user_id, u.user_name;
```

### 6.2 索引使用优化


**🔸 索引友好的查询写法**
```sql
-- ✅ 利用索引的查询方式
SELECT * FROM user_info
WHERE 
    status = 'active'           -- 使用等值查询
    AND user_id BETWEEN 1000 AND 2000  -- 使用范围查询
    AND create_time >= '2024-01-01'     -- 时间范围查询
ORDER BY user_id;               -- 按索引字段排序

-- ❌ 不利于索引的写法
SELECT * FROM user_info
WHERE 
    UPPER(user_name) LIKE '%张%'  -- 函数 + 前缀模糊查询
    OR phone IS NULL            -- OR 条件
ORDER BY RAND();                -- 随机排序
```

### 6.3 查询优化技巧


**🔸 LIMIT使用优化**
```sql
-- ❌ 大偏移量的性能问题
SELECT * FROM user_info
ORDER BY user_id
LIMIT 100000, 20;               -- 需要扫描10万条记录

-- ✅ 使用游标分页
SELECT * FROM user_info
WHERE user_id > 100020          -- 记住上一页最后一个ID
ORDER BY user_id
LIMIT 20;
```

**🔸 数据量控制**
```sql
-- 始终使用合理的LIMIT
SELECT user_id, user_name 
FROM user_info
WHERE status = 'active'
LIMIT 1000;                     -- 防止返回过多数据

-- 大数据量查询时使用流式处理
SELECT user_id, user_name
FROM user_info
WHERE status = 'active'
    AND user_id BETWEEN 1 AND 10000    -- 分批处理
ORDER BY user_id;
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的规范要点


**🔸 格式规范核心**
```sql
-- 标准格式模板
SELECT 
    字段1,
    字段2,
    聚合函数() AS 别名
FROM 表名 别名
    LEFT JOIN 表名2 别名2 ON 连接条件
WHERE 
    过滤条件1
    AND 过滤条件2
GROUP BY 分组字段
HAVING 分组过滤条件
ORDER BY 排序字段 DESC
LIMIT 数量;
```

**🔸 性能优化要点**
- **索引友好**：避免在WHERE中使用函数
- **适量数据**：始终使用LIMIT控制返回量
- **简化逻辑**：复杂查询拆分为多个步骤
- **连接优化**：合理选择JOIN类型

### 7.2 常见错误避免


| 错误类型 | **错误示例** | **正确做法** | **影响** |
|---------|-------------|-------------|---------|
| **格式混乱** | `select*from user where id=1` | `SELECT * FROM user WHERE id = 1` | `可读性差` |
| **无意义命名** | `SELECT a.*, b.* FROM user a, order b` | `SELECT u.*, o.* FROM user u JOIN order o` | `维护困难` |
| **性能陷阱** | `WHERE YEAR(date) = 2024` | `WHERE date >= '2024-01-01'` | `无法使用索引` |
| **逻辑错误** | `WHERE a = 1 OR b = 2 AND c = 3` | `WHERE a = 1 OR (b = 2 AND c = 3)` | `逻辑不明确` |

### 7.3 最佳实践清单


**🔸 编写前检查**
- [ ] 是否需要这个查询？能否用现有数据解决？
- [ ] 查询的业务逻辑是否清晰？
- [ ] 预期返回多少数据？是否需要限制？

**🔸 编写时注意**
- [ ] SQL关键字大写，表名字段名小写
- [ ] 多表查询使用表别名前缀
- [ ] 复杂条件用括号明确逻辑关系
- [ ] 添加必要的注释说明业务逻辑

**🔸 编写后验证**
- [ ] 格式是否规范统一？
- [ ] 是否可能利用现有索引？
- [ ] 查询结果是否符合预期？
- [ ] 其他人是否容易理解？

### 7.4 团队协作建议


**🔸 代码审查重点**
```sql
-- 审查清单
1. 格式规范性：缩进、大小写、注释
2. 命名合理性：表别名、字段引用
3. 逻辑正确性：连接条件、过滤条件  
4. 性能考虑：索引使用、数据量控制
5. 可读性：业务逻辑是否清晰
```

**🔸 规范推广策略**
- **🎓 培训教育**：定期进行SQL规范培训
- **🔧 工具辅助**：使用SQL格式化工具
- **📋 模板提供**：提供常用查询模板
- **👥 相互审查**：建立代码Review机制

**核心记忆口诀**：
- 大写关键字小写名，缩进对齐格式清
- 表名别名要统一，字段前缀防歧义  
- 复杂条件加括号，性能优化记心头
- 注释清晰说业务，团队协作效率高