---
title: 5、约束与触发器规范
---
## 📚 目录

1. [约束基础概念](#1-约束基础概念)
2. [主键约束规范](#2-主键约束规范)
3. [外键约束标准](#3-外键约束标准)
4. [唯一约束设计](#4-唯一约束设计)
5. [检查约束规范](#5-检查约束规范)
6. [非空与默认值约束](#6-非空与默认值约束)
7. [触发器设计规范](#7-触发器设计规范)
8. [约束管理与维护](#8-约束管理与维护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 约束基础概念


### 1.1 什么是数据库约束


**💡 通俗理解**
约束就像是数据库的"规矩"，用来**限制和控制**数据的输入，确保数据的**正确性和完整性**。

```
生活中的类比：
银行开户 → 身份证号必须唯一(唯一约束)
注册账号 → 用户名不能为空(非空约束)
学生选课 → 学号必须存在(外键约束)
年龄输入 → 必须大于0(检查约束)
```

### 1.2 约束的核心作用


**🎯 数据完整性保障**
```
数据完整性的三个层面：

实体完整性：每条记录都是唯一的
- 主键约束保证记录唯一性
- 例：学生表中每个学生ID都不同

参照完整性：表与表之间关系正确
- 外键约束保证关联数据存在
- 例：订单表的客户ID必须在客户表中存在

域完整性：字段值符合业务规则
- 检查约束保证数据合理性
- 例：年龄字段值必须在0-150之间
```

### 1.3 MySQL约束类型图解


```
MySQL约束体系结构：

约束类型
├── 主键约束(PRIMARY KEY)     ← 唯一标识每行数据
├── 外键约束(FOREIGN KEY)     ← 维护表间关系
├── 唯一约束(UNIQUE)          ← 保证字段值唯一
├── 非空约束(NOT NULL)       ← 字段不能为空
├── 默认值约束(DEFAULT)       ← 设置默认值
└── 检查约束(CHECK)          ← 自定义业务规则

约束级别
├── 列级约束  ← 作用于单个列
└── 表级约束  ← 作用于多个列或整个表
```

---

## 2. 🔑 主键约束规范


### 2.1 主键约束的核心概念


**🔸 什么是主键**
主键是表中**唯一标识**每条记录的字段或字段组合，相当于每个人的**身份证号**。

**主键的特点：**
- `🚫 不能重复`：每个主键值都是唯一的
- `🚫 不能为空`：主键字段必须有值
- `🔒 不可变性`：主键值一旦设定，不应该改变
- `⚡ 自动索引`：MySQL会自动为主键创建索引

### 2.2 主键设计规范标准


**📋 主键命名规范**
```sql
-- ✅ 推荐命名方式
-- 单字段主键：直接使用id
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL
);

-- 复合主键：使用pk_前缀 + 表名
CREATE TABLE order_items (
    order_id BIGINT,
    product_id BIGINT,
    quantity INT,
    CONSTRAINT pk_order_items PRIMARY KEY (order_id, product_id)
);
```

**🎯 主键类型选择指南**

| 主键类型 | **适用场景** | **优点** | **缺点** | **推荐度** |
|---------|-------------|---------|---------|-----------|
| `🔢 自增整数` | `通用场景，无特殊要求` | `性能好，空间小` | `不能跨库唯一` | `⭐⭐⭐⭐⭐` |
| `🌍 UUID` | `分布式系统，需全局唯一` | `全局唯一，无冲突` | `存储空间大，性能较差` | `⭐⭐⭐` |
| `📝 业务字段` | `业务含义明确的场景` | `业务意义清晰` | `可能变更，性能不佳` | `⭐⭐` |
| `🔗 复合主键` | `多对多关联表` | `业务意义明确` | `复杂度高，性能较差` | `⭐⭐⭐` |

### 2.3 主键设计最佳实践


**⚡ 性能优化原则**
```sql
-- ✅ 推荐：使用BIGINT自增主键
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ❌ 不推荐：使用业务字段作主键
CREATE TABLE products (
    product_code VARCHAR(50) PRIMARY KEY,  -- 可能变更，查询性能差
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL
);
```

**🔍 复合主键使用场景**
```sql
-- ✅ 适合使用复合主键：多对多关联表
CREATE TABLE student_courses (
    student_id BIGINT,
    course_id BIGINT,
    enrollment_date DATE,
    grade CHAR(2),
    -- 学生+课程的组合是唯一的
    PRIMARY KEY (student_id, course_id)
);

-- 🤔 需要考虑的场景：历史数据表
CREATE TABLE user_login_history (
    user_id BIGINT,
    login_time TIMESTAMP,
    ip_address VARCHAR(45),
    -- 如果同一用户可能同一时间多次登录，需要额外字段
    PRIMARY KEY (user_id, login_time)
);
```

---

## 3. 🔗 外键约束标准


### 3.1 外键约束基础概念


**💡 通俗理解**
外键就像是两张表之间的**"纽带"**，它确保一张表中的数据在另一张表中**确实存在**。

```
生活化理解：
订单表 → 客户表
每个订单必须有对应的客户，不能凭空产生订单
就像快递包裹必须有收件人地址一样

学生表 → 班级表  
每个学生必须属于某个班级，不能没有班级的学生
就像每个员工必须属于某个部门一样
```

### 3.2 外键约束设计规范


**📋 外键命名规范**
```sql
-- 外键命名规则：fk_当前表名_关联表名_字段名
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    customer_id BIGINT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10,2),
    -- 标准的外键定义
    CONSTRAINT fk_orders_customers_customer_id 
        FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

### 3.3 外键操作策略


**🎯 外键约束操作类型**

```
外键操作策略详解：

CASCADE（级联操作）：
├── ON DELETE CASCADE  ← 删除父记录时，自动删除子记录
└── ON UPDATE CASCADE  ← 更新父记录时，自动更新子记录

RESTRICT（限制操作）：
├── ON DELETE RESTRICT ← 有子记录时，禁止删除父记录  
└── ON UPDATE RESTRICT ← 有子记录时，禁止更新父记录

SET NULL（设为空值）：
├── ON DELETE SET NULL ← 删除父记录时，子记录外键设为NULL
└── ON UPDATE SET NULL ← 更新父记录时，子记录外键设为NULL

NO ACTION（无操作）：
└── 检查约束，但不执行任何操作
```

**💻 实际应用示例**
```sql
-- 场景1：订单明细表，订单删除时明细也删除
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    -- 级联删除：订单删除时，订单项也删除
    CONSTRAINT fk_order_items_orders 
        FOREIGN KEY (order_id) REFERENCES orders(id) 
        ON DELETE CASCADE ON UPDATE CASCADE
);

-- 场景2：用户评论表，用户删除时评论保留但用户字段设为NULL
CREATE TABLE comments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    -- 设置为NULL：用户删除时，评论保留但不显示用户
    CONSTRAINT fk_comments_users 
        FOREIGN KEY (user_id) REFERENCES users(id) 
        ON DELETE SET NULL
);
```

### 3.4 外键使用最佳实践


**✅ 外键使用建议**

| 场景类型 | **操作策略** | **适用情况** | **示例** |
|---------|-------------|-------------|---------|
| `📋 主从关系` | `CASCADE` | `主记录删除时从记录也应删除` | `订单-订单明细` |
| `👤 用户关联` | `SET NULL` | `用户删除但内容保留` | `用户-评论` |
| `📊 核心数据` | `RESTRICT` | `重要数据不能随意删除` | `部门-员工` |
| `🔄 历史记录` | `RESTRICT` | `保护历史数据完整性` | `产品-销售记录` |

**⚠️ 外键使用注意事项**
```sql
-- 注意事项1：外键字段必须有索引
-- MySQL会自动为外键创建索引，但最好显式创建

-- 注意事项2：外键类型必须匹配
CREATE TABLE orders (
    customer_id BIGINT,  -- 必须与customers.id类型一致
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 注意事项3：避免循环外键依赖
-- 表A引用表B，表B又引用表A，可能导致无法删除数据
```

---

## 4. 🎯 唯一约束设计


### 4.1 唯一约束基础概念


**💡 通俗理解**
唯一约束确保字段值**不重复**，就像每个人的**手机号码**或**邮箱地址**都是独一无二的。

**唯一约束 vs 主键约束对比：**
```
相同点：
- 都保证值的唯一性
- 都会自动创建索引
- 都不允许重复值

不同点：
- 主键不能为NULL，唯一约束可以为NULL
- 每个表只能有一个主键，但可以有多个唯一约束
- 主键用于标识记录，唯一约束用于业务规则
```

### 4.2 唯一约束设计规范


**📋 单列唯一约束**
```sql
-- 方式1：在字段定义时直接添加
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,  -- 用户名唯一
    email VARCHAR(100) UNIQUE,             -- 邮箱唯一（可以为NULL）
    phone VARCHAR(20) UNIQUE,              -- 手机号唯一
    password_hash VARCHAR(255) NOT NULL
);

-- 方式2：表级约束定义（推荐用于复合唯一约束）
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    phone VARCHAR(20),
    password_hash VARCHAR(255) NOT NULL,
    -- 命名规范：uk_表名_字段名
    CONSTRAINT uk_users_username UNIQUE (username),
    CONSTRAINT uk_users_email UNIQUE (email),
    CONSTRAINT uk_users_phone UNIQUE (phone)
);
```

**🔗 复合唯一约束**
```sql
-- 场景：同一课程，同一学期，学生只能选一次
CREATE TABLE course_selections (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    student_id BIGINT NOT NULL,
    course_id BIGINT NOT NULL,
    semester VARCHAR(20) NOT NULL,
    grade CHAR(2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    -- 复合唯一约束
    CONSTRAINT uk_course_selections_student_course_semester 
        UNIQUE (student_id, course_id, semester)
);
```

### 4.3 唯一约束应用场景


**🎯 常见业务场景**

| 业务场景 | **字段示例** | **约束类型** | **业务含义** |
|---------|-------------|-------------|-------------|
| `👤 用户管理` | `username, email, phone` | `单列唯一` | `账号信息不能重复` |
| `📱 设备管理` | `device_id, serial_number` | `单列唯一` | `设备标识唯一` |
| `📊 业务编码` | `order_number, invoice_code` | `单列唯一` | `业务单据编号唯一` |
| `🎓 学籍管理` | `(student_id, course_id, semester)` | `复合唯一` | `选课记录唯一` |
| `💰 财务记录` | `(account_id, transaction_date, sequence)` | `复合唯一` | `交易流水唯一` |

**💻 实际应用示例**
```sql
-- 示例1：商品SKU管理
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    sku_code VARCHAR(50) NOT NULL,           -- SKU编码必须唯一
    name VARCHAR(200) NOT NULL,
    category_id BIGINT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    -- SKU编码全局唯一
    CONSTRAINT uk_products_sku_code UNIQUE (sku_code)
);

-- 示例2：文章管理（URL别名唯一）
CREATE TABLE articles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    url_slug VARCHAR(100) NOT NULL,          -- URL别名
    content TEXT,
    author_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    -- URL别名必须唯一，用于SEO友好的URL
    CONSTRAINT uk_articles_url_slug UNIQUE (url_slug)
);
```

---

## 5. ✅ 检查约束规范


### 5.1 检查约束基础概念


**💡 通俗理解**  
检查约束是对字段值的**业务规则限制**，就像考试分数必须在0-100之间，年龄必须大于0一样。

> **🔔 注意：** MySQL 8.0版本才完全支持CHECK约束，之前版本会忽略CHECK约束但不报错。

### 5.2 检查约束设计规范


**📋 基本检查约束示例**
```sql
-- 用户信息表，包含年龄和性别检查
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    age INT NOT NULL,
    gender ENUM('M', 'F', 'Other') NOT NULL,
    salary DECIMAL(10,2) DEFAULT 0,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 检查约束命名规范：ck_表名_字段名_描述
    CONSTRAINT ck_users_age_range CHECK (age >= 0 AND age <= 150),
    CONSTRAINT ck_users_salary_positive CHECK (salary >= 0),
    CONSTRAINT ck_users_email_format CHECK (email LIKE '%@%.%')
);
```

### 5.3 常用检查约束模式


**🎯 数值范围检查**
```sql
-- 产品评分表
CREATE TABLE product_reviews (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    rating INT NOT NULL,
    comment TEXT,
    
    -- 评分必须在1-5之间
    CONSTRAINT ck_reviews_rating_range CHECK (rating BETWEEN 1 AND 5)
);

-- 订单表
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    customer_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    
    -- 总金额必须大于0
    CONSTRAINT ck_orders_total_positive CHECK (total_amount > 0),
    -- 折扣金额不能超过总金额
    CONSTRAINT ck_orders_discount_valid CHECK (discount_amount <= total_amount)
);
```

**📅 日期时间检查**
```sql
-- 员工表
CREATE TABLE employees (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birth_date DATE NOT NULL,
    hire_date DATE NOT NULL,
    retirement_date DATE,
    
    -- 出生日期不能晚于入职日期
    CONSTRAINT ck_employees_birth_before_hire CHECK (birth_date < hire_date),
    -- 退休日期必须晚于入职日期
    CONSTRAINT ck_employees_retirement_after_hire 
        CHECK (retirement_date IS NULL OR retirement_date > hire_date)
);
```

### 5.4 检查约束最佳实践


**✅ 设计原则**

| 原则类型 | **说明** | **示例** |
|---------|---------|---------|
| `🎯 业务相关` | `检查约束应该反映真实业务规则` | `年龄范围、价格非负` |
| `⚡ 性能考虑` | `避免复杂的检查逻辑` | `简单比较而非复杂计算` |
| `🔒 数据完整性` | `确保数据的逻辑一致性` | `开始时间早于结束时间` |
| `🔄 可维护性` | `约束逻辑清晰易理解` | `约束命名要有意义` |

**⚠️ 使用注意事项**
```sql
-- ❌ 避免过于复杂的检查约束
CONSTRAINT ck_complex CHECK (
    (status = 'active' AND end_date IS NULL) OR 
    (status = 'inactive' AND end_date IS NOT NULL AND end_date > start_date)
);

-- ✅ 推荐简单清晰的检查约束
CONSTRAINT ck_status_valid CHECK (status IN ('active', 'inactive', 'pending')),
CONSTRAINT ck_dates_logical CHECK (end_date IS NULL OR end_date > start_date);
```

---

## 6. 🔒 非空与默认值约束


### 6.1 非空约束(NOT NULL)


**💡 核心理解**
非空约束确保字段**必须有值**，防止关键信息缺失，就像身份证号码和姓名不能为空一样。

**📋 非空约束设计原则**

```sql
-- 用户表设计示例
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 核心业务字段：必须非空
    username VARCHAR(50) NOT NULL,           -- 用户名必须有
    password_hash VARCHAR(255) NOT NULL,     -- 密码必须有
    email VARCHAR(100) NOT NULL,             -- 邮箱必须有
    
    -- 扩展信息字段：可以为空
    nickname VARCHAR(100),                   -- 昵称可选
    avatar_url VARCHAR(500),                 -- 头像可选
    bio TEXT,                               -- 个人简介可选
    
    -- 系统字段：通常非空且有默认值
    status TINYINT NOT NULL DEFAULT 1,       -- 状态默认激活
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP
);
```

**🎯 非空字段判断原则**

| 字段类型 | **非空建议** | **原因** | **示例** |
|---------|-------------|---------|---------|
| `🔑 业务主键` | `必须非空` | `用于唯一标识记录` | `用户ID、订单编号` |
| `👤 核心业务` | `必须非空` | `业务逻辑必需信息` | `用户名、商品名称` |
| `🔐 安全相关` | `必须非空` | `系统安全要求` | `密码、权限级别` |
| `📊 统计相关` | `必须非空` | `数据分析需要` | `创建时间、状态` |
| `🔧 扩展信息` | `允许为空` | `可选的附加信息` | `昵称、描述` |

### 6.2 默认值约束(DEFAULT)


**💡 核心理解**
默认值约束为字段提供**初始值**，当插入数据时没有指定值时自动使用默认值。

**📋 常用默认值类型**

```sql
CREATE TABLE articles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    
    -- 数值类型默认值
    view_count INT NOT NULL DEFAULT 0,           -- 浏览次数默认0
    like_count INT NOT NULL DEFAULT 0,           -- 点赞数默认0
    
    -- 字符串类型默认值  
    status VARCHAR(20) NOT NULL DEFAULT 'draft', -- 状态默认草稿
    category VARCHAR(50) DEFAULT 'uncategorized', -- 分类默认未分类
    
    -- 布尔类型默认值
    is_published BOOLEAN NOT NULL DEFAULT FALSE, -- 默认未发布
    is_featured BOOLEAN NOT NULL DEFAULT FALSE,  -- 默认非推荐
    
    -- 时间类型默认值
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
    published_at TIMESTAMP NULL DEFAULT NULL
);
```

### 6.3 默认值设计最佳实践


**⚡ 系统字段标准模式**
```sql
-- 推荐的系统字段设计模式
CREATE TABLE standard_table (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    
    -- 业务字段
    name VARCHAR(100) NOT NULL,
    description TEXT,
    
    -- 状态控制字段
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：1-正常，0-禁用，-1-删除',
    sort_order INT NOT NULL DEFAULT 0 COMMENT '排序权重，数值越大越靠前',
    
    -- 审计字段
    created_by BIGINT NOT NULL COMMENT '创建用户ID',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_by BIGINT NULL COMMENT '最后更新用户ID', 
    updated_at TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间'
);
```

**🔍 默认值使用场景**

| 场景类型 | **默认值策略** | **示例** |
|---------|---------------|---------|
| `📊 计数字段` | `DEFAULT 0` | `浏览量、点赞数、库存数量` |
| `🎯 状态字段` | `DEFAULT '初始状态'` | `订单状态、用户状态` |
| `🕐 时间字段` | `DEFAULT CURRENT_TIMESTAMP` | `创建时间、更新时间` |
| `✅ 布尔字段` | `DEFAULT FALSE/TRUE` | `是否删除、是否激活` |
| `🔧 配置字段` | `DEFAULT '默认配置'` | `主题设置、语言偏好` |

---

## 7. ⚡ 触发器设计规范


### 7.1 触发器基础概念


**💡 通俗理解**
触发器就像数据库的**"自动机器人"**，当特定事件发生时(增删改数据)，它会**自动执行**预设的操作。

```
生活化类比：
自动门感应器 → 有人靠近就自动开门
火警报警器   → 检测到烟雾就自动报警
数据库触发器 → 数据变化时自动执行逻辑

实际应用场景：
- 用户注册时自动发送欢迎邮件
- 商品销售时自动扣减库存
- 删除用户时自动清理相关数据
- 数据变更时自动记录操作日志
```

### 7.2 触发器命名规范


**📋 标准命名模式**
```sql
-- 触发器命名规范：trigger_表名_时机_事件_用途
-- 时机：before/after
-- 事件：insert/update/delete
-- 用途：业务描述

-- 示例：用户表插入后触发器，用于初始化用户配置
CREATE TRIGGER trigger_users_after_insert_init_config
AFTER INSERT ON users FOR EACH ROW
BEGIN
    -- 触发器逻辑
END;

-- 示例：订单表更新前触发器，用于数据校验
CREATE TRIGGER trigger_orders_before_update_validate
BEFORE UPDATE ON orders FOR EACH ROW  
BEGIN
    -- 触发器逻辑
END;
```

### 7.3 触发器设计原则


**🎯 核心设计原则**

| 原则类型 | **具体要求** | **原因** | **示例** |
|---------|-------------|---------|---------|
| `⚡ 性能优先` | `逻辑简单，执行快速` | `触发器会影响DML性能` | `避免复杂计算和查询` |
| `🔒 事务安全` | `考虑事务回滚情况` | `触发器在事务内执行` | `使用适当的异常处理` |
| `📝 逻辑清晰` | `单一职责，逻辑明确` | `便于维护和调试` | `一个触发器只做一件事` |
| `🚫 避免循环` | `防止触发器相互调用` | `可能导致无限循环` | `仔细设计触发器链` |

### 7.4 常见触发器应用场景


**📊 自动更新统计信息**
```sql
-- 商品表和库存表
CREATE TABLE products (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    total_stock INT NOT NULL DEFAULT 0,  -- 总库存
    available_stock INT NOT NULL DEFAULT 0  -- 可用库存
);

CREATE TABLE stock_movements (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id BIGINT NOT NULL,
    movement_type ENUM('IN', 'OUT') NOT NULL,  -- 入库/出库
    quantity INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 库存变动触发器：自动更新商品库存
DELIMITER //
CREATE TRIGGER trigger_stock_movements_after_insert_update_product_stock
AFTER INSERT ON stock_movements FOR EACH ROW
BEGIN
    IF NEW.movement_type = 'IN' THEN
        -- 入库：增加库存
        UPDATE products 
        SET total_stock = total_stock + NEW.quantity,
            available_stock = available_stock + NEW.quantity
        WHERE id = NEW.product_id;
    ELSE
        -- 出库：减少库存
        UPDATE products 
        SET available_stock = available_stock - NEW.quantity  
        WHERE id = NEW.product_id;
    END IF;
END//
DELIMITER ;
```

**📝 自动记录操作日志**
```sql
-- 用户操作日志表
CREATE TABLE user_operation_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT,
    operation_type VARCHAR(20),  -- INSERT/UPDATE/DELETE
    table_name VARCHAR(50),
    record_id BIGINT,
    old_values JSON,
    new_values JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户信息变更日志触发器
DELIMITER //
CREATE TRIGGER trigger_users_after_update_log_changes
AFTER UPDATE ON users FOR EACH ROW  
BEGIN
    INSERT INTO user_operation_logs (
        user_id, operation_type, table_name, record_id,
        old_values, new_values
    ) VALUES (
        NEW.id, 'UPDATE', 'users', NEW.id,
        JSON_OBJECT(
            'username', OLD.username,
            'email', OLD.email,
            'status', OLD.status
        ),
        JSON_OBJECT(
            'username', NEW.username, 
            'email', NEW.email,
            'status', NEW.status
        )
    );
END//
DELIMITER ;
```

### 7.5 触发器性能要求


**⚡ 性能优化策略**

```sql
-- ✅ 推荐：简单高效的触发器
DELIMITER //
CREATE TRIGGER trigger_orders_after_insert_update_customer_stats
AFTER INSERT ON orders FOR EACH ROW
BEGIN
    -- 简单的计数更新
    UPDATE customer_stats 
    SET order_count = order_count + 1,
        total_amount = total_amount + NEW.amount
    WHERE customer_id = NEW.customer_id;
END//
DELIMITER ;

-- ❌ 不推荐：复杂耗时的触发器  
DELIMITER //
CREATE TRIGGER trigger_bad_example
AFTER INSERT ON orders FOR EACH ROW
BEGIN
    -- 复杂的统计计算（耗时）
    DECLARE avg_amount DECIMAL(10,2);
    DECLARE customer_level VARCHAR(20);
    
    -- 多表关联查询（慢）
    SELECT AVG(amount) INTO avg_amount
    FROM orders o
    JOIN customers c ON o.customer_id = c.id  
    WHERE o.customer_id = NEW.customer_id
    AND o.created_at >= DATE_SUB(NOW(), INTERVAL 1 YEAR);
    
    -- 复杂的业务逻辑判断
    IF avg_amount > 10000 THEN
        SET customer_level = 'VIP';
    ELSEIF avg_amount > 5000 THEN  
        SET customer_level = 'GOLD';
    ELSE
        SET customer_level = 'NORMAL';
    END IF;
    
    UPDATE customers SET level = customer_level WHERE id = NEW.customer_id;
END//
DELIMITER ;
```

**📊 触发器性能监控**
```sql
-- 查看触发器执行统计
SELECT 
    TRIGGER_SCHEMA,
    TRIGGER_NAME,
    EVENT_MANIPULATION,
    EVENT_OBJECT_TABLE
FROM information_schema.TRIGGERS 
WHERE TRIGGER_SCHEMA = 'your_database';

-- 监控触发器相关的慢查询
-- 查看 slow query log 中触发器相关的慢操作
```

---

## 8. 🛠️ 约束管理与维护


### 8.1 约束文档规范


**📋 约束文档模板**
```sql
/*
=================================================
约束文档：用户管理系统
创建日期：2024-12-30
维护人员：数据库团队
=================================================

表名：users
用途：存储用户基本信息

约束清单：
1. 主键约束：
   - 名称：PRIMARY KEY (id)
   - 字段：id  
   - 说明：用户唯一标识

2. 唯一约束：
   - 名称：uk_users_username
   - 字段：username
   - 说明：用户名全局唯一
   
   - 名称：uk_users_email  
   - 字段：email
   - 说明：邮箱地址全局唯一

3. 外键约束：
   - 名称：fk_users_departments_dept_id
   - 字段：department_id
   - 引用：departments.id
   - 策略：ON DELETE SET NULL
   - 说明：用户所属部门

4. 检查约束：
   - 名称：ck_users_age_range
   - 条件：age >= 0 AND age <= 150
   - 说明：年龄范围校验

=================================================
*/
```

### 8.2 约束变更控制


**🔄 约束变更流程**
```
约束变更管控流程：

1. 变更申请
   ├── 填写变更申请单
   ├── 说明变更原因  
   ├── 评估影响范围
   └── 制定回滚方案

2. 影响评估
   ├── 数据完整性影响
   ├── 应用程序影响
   ├── 性能影响评估
   └── 风险等级判定

3. 变更实施
   ├── 在测试环境验证
   ├── 准备生产环境脚本
   ├── 安排维护时间窗口
   └── 执行变更并监控

4. 变更验证
   ├── 验证约束生效情况
   ├── 检查数据完整性
   ├── 验证应用功能正常
   └── 更新文档记录
```

**💻 约束变更实例**
```sql
-- 变更示例：为现有表添加检查约束

-- 步骤1：检查现有数据是否符合新约束
SELECT COUNT(*) as invalid_records
FROM products 
WHERE price <= 0 OR price > 999999.99;

-- 步骤2：清理不符合约束的数据（如需要）
UPDATE products SET price = 1.00 WHERE price <= 0;

-- 步骤3：添加检查约束
ALTER TABLE products 
ADD CONSTRAINT ck_products_price_range 
CHECK (price > 0 AND price <= 999999.99);

-- 步骤4：验证约束生效
-- 尝试插入无效数据，应该失败
INSERT INTO products (name, price) VALUES ('测试商品', -10.00);
-- Error: Check constraint 'ck_products_price_range' is violated.
```

### 8.3 约束异常处理


**🚨 常见约束异常类型**

| 异常类型 | **错误码** | **处理策略** | **示例场景** |
|---------|-----------|-------------|-------------|
| `🔑 主键冲突` | `1062` | `检查数据唯一性，修改插入值` | `用户ID重复` |
| `🔗 外键约束` | `1452` | `确保关联数据存在` | `订单关联不存在的客户` |
| `✨ 唯一约束` | `1062` | `检查字段值唯一性` | `用户名或邮箱重复` |
| `❌ 非空约束` | `1048` | `提供必需字段值` | `必填字段为空` |
| `✅ 检查约束` | `3819` | `修改数据符合业务规则` | `年龄或价格超出范围` |

**💻 异常处理代码示例**
```java
// Java中处理MySQL约束异常
public class DatabaseExceptionHandler {
    
    public void handleConstraintException(SQLException ex) {
        int errorCode = ex.getErrorCode();
        String errorMessage = ex.getMessage();
        
        switch (errorCode) {
            case 1062: // 主键或唯一约束冲突
                if (errorMessage.contains("PRIMARY")) {
                    throw new BusinessException("记录已存在，请检查主键值");
                } else if (errorMessage.contains("uk_users_email")) {
                    throw new BusinessException("邮箱地址已被使用");
                } else if (errorMessage.contains("uk_users_username")) {
                    throw new BusinessException("用户名已被占用");
                }
                break;
                
            case 1452: // 外键约束违反
                throw new BusinessException("关联数据不存在，请检查数据完整性");
                
            case 1048: // 非空约束违反  
                throw new BusinessException("必填字段不能为空");
                
            case 3819: // 检查约束违反
                throw new BusinessException("数据不符合业务规则要求");
                
            default:
                throw new BusinessException("数据库操作失败：" + errorMessage);
        }
    }
}
```

**🔍 约束监控与诊断**
```sql
-- 查看表的所有约束信息
SELECT 
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM information_schema.KEY_COLUMN_USAGE 
WHERE TABLE_SCHEMA = 'your_database'
AND TABLE_NAME = 'users';

-- 查看检查约束详情
SELECT 
    CONSTRAINT_NAME,
    CHECK_CLAUSE,
    TABLE_NAME
FROM information_schema.CHECK_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'your_database';

-- 监控约束违反的错误日志
SHOW GLOBAL STATUS LIKE 'Com_insert';
SHOW GLOBAL STATUS LIKE 'Com_update';  
-- 结合错误日志分析约束相关的异常
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 约束本质：数据库的"规矩"，保障数据完整性和业务逻辑正确性
🔸 主键约束：每张表的唯一标识，推荐使用自增BIGINT
🔸 外键约束：维护表间关系，合理选择CASCADE/RESTRICT/SET NULL策略  
🔸 唯一约束：保证业务字段不重复，支持NULL值存在
🔸 检查约束：实现业务规则校验，MySQL 8.0+才完全支持
🔸 非空约束：核心业务字段必须设置，扩展字段可选
🔸 默认值约束：提供字段初始值，系统字段标准化设计
🔸 触发器：数据变更时自动执行逻辑，需要控制复杂度
```

### 9.2 约束设计最佳实践


**🎯 设计原则优先级**
```
1. 🔒 数据完整性 > 性能优化
   - 先保证数据正确，再考虑性能
   - 核心业务字段的约束不能妥协

2. 📋 业务逻辑 > 技术实现  
   - 约束要反映真实业务规则
   - 不能为了技术便利违背业务逻辑

3. 🔧 维护简单 > 功能复杂
   - 简单清晰的约束易于维护
   - 避免过度复杂的约束逻辑

4. ⚡ 性能考虑 > 存储空间
   - 合理使用约束提升查询性能
   - 外键自动创建索引要善用
```

**📊 约束使用决策矩阵**

| 约束类型 | **使用频率** | **性能影响** | **维护复杂度** | **推荐场景** |
|---------|-------------|-------------|---------------|-------------|
| `🔑 主键约束` | `⭐⭐⭐⭐⭐` | `✅ 正面` | `🟢 简单` | `所有业务表必须` |
| `🔗 外键约束` | `⭐⭐⭐` | `⚠️ 注意` | `🟡 中等` | `关键业务关联` |
| `✨ 唯一约束` | `⭐⭐⭐⭐` | `✅ 正面` | `🟢 简单` | `业务唯一性要求` |
| `✅ 检查约束` | `⭐⭐` | `⚠️ 注意` | `🟡 中等` | `关键业务规则` |
| `🔒 非空约束` | `⭐⭐⭐⭐⭐` | `✅ 正面` | `🟢 简单` | `核心业务字段` |
| `⚡ 触发器` | `⭐⭐` | `❌ 负面` | `🔴 复杂` | `特殊自动化需求` |

### 9.3 实际应用指导


**🔧 日常开发建议**
- **设计阶段**：根据业务需求合理设计约束，不要过度设计
- **开发阶段**：在代码中合理处理约束异常，提供友好的错误提示  
- **测试阶段**：充分测试约束的各种边界情况
- **上线阶段**：监控约束相关的性能指标和错误日志
- **维护阶段**：定期审查约束的有效性，及时更新文档

**⚠️ 常见误区避免**
```
❌ 误区1：为所有字段都加上约束
   ✅ 正确：只为核心业务字段添加必要约束

❌ 误区2：外键约束会严重影响性能  
   ✅ 正确：合理使用外键约束，利用其提供的索引优化

❌ 误区3：触发器可以解决所有业务逻辑
   ✅ 正确：触发器只用于简单的自动化操作

❌ 误区4：约束一旦创建就不能修改
   ✅ 正确：可以通过规范流程安全地修改约束
```

**🎯 学习进阶路径**
```
基础掌握：
├── 理解各种约束的作用和语法
├── 学会设计合理的约束组合  
└── 掌握基本的异常处理

进阶应用：
├── 复杂业务场景的约束设计
├── 约束对性能的影响分析
└── 分布式环境下的约束策略

高级技能：
├── 约束变更的安全操作流程
├── 约束相关的性能调优
└── 企业级约束管理规范制定
```

**核心记忆口诀**：
```
约束规范保数据，完整一致是关键
主键唯一做标识，外键关联要规范  
检查约束控业务，触发逻辑要简单
文档变更有流程，异常处理要周全
```