---
title: 7、存储过程与函数规范
---
## 📚 目录


1. [存储过程与函数概述](#1-存储过程与函数概述)
2. [命名规范标准](#2-命名规范标准)
3. [参数与返回值规范](#3-参数与返回值规范)
4. [异常处理与事务控制](#4-异常处理与事务控制)
5. [性能优化规范](#5-性能优化规范)
6. [版本管理与文档规范](#6-版本管理与文档规范)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏗️ 存储过程与函数概述



### 1.1 基本概念解释



**🔸 什么是存储过程**
```
存储过程：就像是数据库里的"小程序"
- 把一系列SQL语句打包成一个整体
- 可以接收参数，执行复杂的业务逻辑
- 存储在数据库服务器上，可以重复调用

简单理解：
普通SQL：每次写一条语句做一件事
存储过程：写一个"程序"，一次调用做很多事
```

**🔸 什么是函数**
```
函数：就像数学中的函数一样
- 输入参数，经过计算，返回一个结果
- 专注于计算和数据转换
- 可以在SQL语句中直接调用

区别理解：
存储过程：像一个完整的工作流程
函数：像一个计算器，专门用来算结果
```

### 1.2 使用场景分析



**📋 存储过程适用场景**
```
✅ 复杂的业务逻辑处理
   例：订单结算（更新库存、计算价格、记录日志）

✅ 批量数据处理
   例：月末财务报表生成

✅ 需要事务控制的操作
   例：银行转账（扣款+加款必须同时成功）

✅ 频繁执行的复杂查询
   例：用户权限验证
```

**📋 函数适用场景**
```
✅ 数据计算和转换
   例：计算两点之间距离、格式化日期

✅ 数据验证
   例：验证身份证号码格式

✅ 在查询中进行复杂计算
   例：SELECT user_name, calculate_age(birth_date) FROM users
```

### 1.3 优势与注意事项



**⚡ 主要优势**
```
性能优势：
• 预编译执行，减少解析时间
• 减少网络传输，一次调用完成多个操作
• 可以利用数据库的执行计划缓存

管理优势：
• 业务逻辑集中管理
• 代码复用性强
• 统一的数据操作标准
```

**⚠️ 使用注意事项**
```
潜在问题：
• 调试困难，不如应用程序代码直观
• 数据库移植性差，不同数据库语法不同
• 版本管理复杂，需要专门的管理策略

使用原则：
• 不要把所有业务逻辑都放在存储过程里
• 复杂的计算逻辑优先考虑应用程序处理
• 主要用于数据密集型操作和事务控制
```

---

## 2. 🏷️ 命名规范标准



### 2.1 存储过程命名规范



**📝 基本命名规则**
```
格式：[前缀]_[模块]_[操作]_[对象]

前缀约定：
sp_    - 存储过程 (stored procedure)
proc_  - 存储过程 (procedure)

模块标识：
user_   - 用户相关
order_  - 订单相关  
product_ - 商品相关
sys_    - 系统相关
```

**✅ 命名示例**
```sql
-- 用户相关存储过程
sp_user_create_account        -- 创建用户账户
sp_user_update_profile        -- 更新用户资料
sp_user_delete_inactive       -- 删除非活跃用户
sp_user_get_permissions       -- 获取用户权限

-- 订单相关存储过程
sp_order_create_new           -- 创建新订单
sp_order_update_status        -- 更新订单状态
sp_order_calculate_total      -- 计算订单总金额
sp_order_batch_process        -- 批量处理订单
```

### 2.2 函数命名规范



**📝 函数命名规则**
```
格式：[前缀]_[功能描述]

前缀约定：
fn_    - 函数 (function)
func_  - 函数 (function)

功能描述：
get_    - 获取数据
calc_   - 计算
check_  - 验证检查
format_ - 格式化
convert_ - 转换
```

**✅ 函数命名示例**
```sql
-- 计算类函数
fn_calc_age                   -- 计算年龄
fn_calc_distance             -- 计算距离  
fn_calc_tax                  -- 计算税费

-- 验证类函数
fn_check_email_format        -- 验证邮箱格式
fn_check_phone_valid         -- 验证手机号
fn_check_id_card            -- 验证身份证

-- 格式化函数
fn_format_currency          -- 格式化货币
fn_format_datetime          -- 格式化时间
```

### 2.3 命名最佳实践



**🎯 命名原则**
```
清晰明确：
❌ sp_proc1, fn_func2          (意义不明)
✅ sp_user_create_account      (一看就懂)

动词在前：
❌ sp_account_user_create      (语序混乱)
✅ sp_user_create_account      (动作明确)

避免缩写：
❌ sp_usr_crt_acc             (缩写难懂)
✅ sp_user_create_account      (完整清晰)
```

**📋 命名检查清单**
```
✅ 名称是否清楚表达了功能？
✅ 是否遵循了统一的命名约定？
✅ 是否避免了歧义和混淆？
✅ 是否便于团队成员理解？
✅ 是否符合公司编码标准？
```

---

## 3. 📋 参数与返回值规范



### 3.1 参数命名与类型规范



**🔸 参数命名标准**
```sql
参数命名格式：
输入参数：p_[参数名]     (p = parameter)
输出参数：out_[参数名]   (out = output)
输入输出参数：inout_[参数名] (inout = input/output)

示例：
CREATE PROCEDURE sp_user_create_account(
    IN p_username VARCHAR(50),      -- 输入：用户名
    IN p_email VARCHAR(100),        -- 输入：邮箱  
    IN p_password VARCHAR(255),     -- 输入：密码
    OUT out_user_id INT,            -- 输出：用户ID
    OUT out_result_code INT,        -- 输出：结果码
    OUT out_message VARCHAR(255)    -- 输出：结果信息
)
```

**📊 参数类型选择指南**

| 数据类型 | **使用场景** | **注意事项** |
|---------|------------|-------------|
| `VARCHAR(n)` | `文本数据，如姓名、地址` | `合理设置长度，避免浪费` |
| `INT` | `整数，如ID、数量` | `考虑是否需要UNSIGNED` |
| `DECIMAL(m,d)` | `精确数值，如金额` | `避免使用FLOAT做金额计算` |
| `DATETIME` | `日期时间` | `统一使用UTC时间` |
| `JSON` | `复杂结构数据` | `MySQL 5.7+支持` |

### 3.2 参数验证规范



**🔍 输入参数验证**
```sql
DELIMITER //
CREATE PROCEDURE sp_user_create_account(
    IN p_username VARCHAR(50),
    IN p_email VARCHAR(100),
    IN p_password VARCHAR(255),
    OUT out_result_code INT,
    OUT out_message VARCHAR(255)
)
BEGIN
    -- 声明异常处理
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET out_result_code = -1;
        SET out_message = '系统异常，请稍后重试';
        ROLLBACK;
    END;
    
    -- 参数验证
    IF p_username IS NULL OR LENGTH(TRIM(p_username)) = 0 THEN
        SET out_result_code = 1001;
        SET out_message = '用户名不能为空';
        LEAVE sp_main;
    END IF;
    
    IF LENGTH(p_username) > 50 THEN
        SET out_result_code = 1002; 
        SET out_message = '用户名长度不能超过50个字符';
        LEAVE sp_main;
    END IF;
    
    IF p_email IS NULL OR NOT p_email REGEXP '^[^@]+@[^@]+\.[^@]+$' THEN
        SET out_result_code = 1003;
        SET out_message = '邮箱格式不正确';  
        LEAVE sp_main;
    END IF;
    
    -- 业务逻辑处理
    sp_main: BEGIN
        -- 实际的业务处理代码
        SET out_result_code = 0;
        SET out_message = '创建成功';
    END sp_main;
    
END //
DELIMITER ;
```

### 3.3 返回值规范



**📤 返回值标准化**
```sql
-- 存储过程返回码约定
返回码范围：
0              成功
1000-1999      参数错误
2000-2999      业务逻辑错误  
3000-3999      数据库操作错误
4000-4999      权限相关错误
9999           未知系统错误

-- 函数返回值设计
CREATE FUNCTION fn_calc_user_level(p_points INT)
RETURNS VARCHAR(20)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE v_level VARCHAR(20);
    
    CASE 
        WHEN p_points >= 10000 THEN SET v_level = 'VIP';
        WHEN p_points >= 5000 THEN SET v_level = 'GOLD';
        WHEN p_points >= 1000 THEN SET v_level = 'SILVER';
        ELSE SET v_level = 'BRONZE';
    END CASE;
    
    RETURN v_level;
END;
```

**📋 返回值最佳实践**
```
一致性原则：
• 所有存储过程都应该有统一的返回码体系
• 相同的错误情况使用相同的返回码
• 返回信息要对用户友好，对开发者有诊断价值

清晰性原则：  
• 返回码要有明确含义，不能模糊不清
• 返回信息要准确描述问题和可能的解决方案
• 避免技术术语，使用业务语言描述

完整性原则：
• 每个可能的执行路径都要有明确的返回
• 异常情况要有专门的错误码和信息
• 成功情况也要有明确的成功标识
```

---

## 4. ⚠️ 异常处理与事务控制



### 4.1 异常处理机制



**🔸 异常处理基本概念**
```
什么是异常处理：
就像程序运行时的"保险机制"，当出现意外情况时
能够优雅地处理错误，而不是让程序崩溃

MySQL中的异常处理：
• DECLARE ... HANDLER：声明异常处理器
• SQLSTATE：SQL标准错误码  
• SQLEXCEPTION：SQL异常类型
• GET DIAGNOSTICS：获取详细错误信息
```

**📝 异常处理模板**
```sql
DELIMITER //
CREATE PROCEDURE sp_order_process_payment(
    IN p_order_id INT,
    IN p_payment_amount DECIMAL(10,2),
    OUT out_result_code INT,
    OUT out_message VARCHAR(255)
)
BEGIN
    -- 声明变量
    DECLARE v_order_status VARCHAR(20);
    DECLARE v_order_amount DECIMAL(10,2);
    DECLARE v_error_count INT DEFAULT 0;
    
    -- 异常处理器
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- 获取错误信息
        GET DIAGNOSTICS CONDITION 1
            @errno = MYSQL_ERRNO,
            @sqlstate = RETURNED_SQLSTATE, 
            @message = MESSAGE_TEXT;
            
        SET out_result_code = 3000;
        SET out_message = CONCAT('数据库操作失败: ', @message);
        ROLLBACK;
    END;
    
    -- 业务逻辑异常处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND
    BEGIN
        SET v_error_count = v_error_count + 1;
    END;
    
    START TRANSACTION;
    
    -- 业务逻辑处理
    SELECT order_status, total_amount 
    INTO v_order_status, v_order_amount
    FROM orders 
    WHERE order_id = p_order_id;
    
    -- 检查是否找到订单
    IF v_error_count > 0 THEN
        SET out_result_code = 2001;
        SET out_message = '订单不存在';
        ROLLBACK;
        LEAVE sp_main;
    END IF;
    
    sp_main: BEGIN
        -- 具体的支付处理逻辑
        -- ...
        
        COMMIT;
        SET out_result_code = 0;
        SET out_message = '支付处理成功';
    END sp_main;
    
END //
DELIMITER ;
```

### 4.2 事务控制规范



**🔄 事务控制基本原则**
```
什么是事务：
把多个相关的数据库操作打包成一个整体
要么全部成功，要么全部失败，确保数据一致性

ACID特性：
A - Atomicity（原子性）：要么全做，要么全不做
C - Consistency（一致性）：数据保持一致状态  
I - Isolation（隔离性）：并发事务互不干扰
D - Durability（持久性）：提交后永久保存
```

**📋 事务控制最佳实践**
```sql
-- 标准事务控制模板
DELIMITER //
CREATE PROCEDURE sp_transfer_money(
    IN p_from_account INT,
    IN p_to_account INT,  
    IN p_amount DECIMAL(10,2),
    OUT out_result_code INT,
    OUT out_message VARCHAR(255)
)
BEGIN
    DECLARE v_from_balance DECIMAL(10,2);
    DECLARE v_to_balance DECIMAL(10,2);
    DECLARE v_affected_rows INT;
    
    -- 异常时自动回滚
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET out_result_code = 3000;
        SET out_message = '转账失败，系统异常';
        ROLLBACK;
    END;
    
    -- 开始事务
    START TRANSACTION;
    
    -- 1. 检查转出账户余额（加锁）
    SELECT balance INTO v_from_balance
    FROM accounts 
    WHERE account_id = p_from_account
    FOR UPDATE;  -- 悲观锁，防止并发修改
    
    -- 2. 验证余额是否充足
    IF v_from_balance < p_amount THEN
        SET out_result_code = 2001;
        SET out_message = '余额不足';
        ROLLBACK;
        LEAVE sp_main;
    END IF;
    
    sp_main: BEGIN
        -- 3. 扣除转出金额
        UPDATE accounts 
        SET balance = balance - p_amount,
            updated_time = NOW()
        WHERE account_id = p_from_account;
        
        SET v_affected_rows = ROW_COUNT();
        IF v_affected_rows = 0 THEN
            SET out_result_code = 2002;
            SET out_message = '转出账户更新失败';
            ROLLBACK;
            LEAVE sp_main;
        END IF;
        
        -- 4. 增加转入金额
        UPDATE accounts 
        SET balance = balance + p_amount,
            updated_time = NOW()
        WHERE account_id = p_to_account;
        
        SET v_affected_rows = ROW_COUNT();
        IF v_affected_rows = 0 THEN
            SET out_result_code = 2003;
            SET out_message = '转入账户更新失败';
            ROLLBACK;
            LEAVE sp_main;
        END IF;
        
        -- 5. 记录转账流水
        INSERT INTO transfer_log(
            from_account, to_account, amount, 
            transfer_time, status
        ) VALUES (
            p_from_account, p_to_account, p_amount,
            NOW(), 'SUCCESS'
        );
        
        -- 提交事务
        COMMIT;
        SET out_result_code = 0;
        SET out_message = '转账成功';
    END sp_main;
    
END //
DELIMITER ;
```

### 4.3 并发控制策略



**🔒 锁机制选择**
```sql
-- 悲观锁：假设会发生冲突，提前加锁
SELECT * FROM table_name WHERE id = 1 FOR UPDATE;

-- 乐观锁：假设不会冲突，更新时检查版本
UPDATE table_name 
SET field1 = 'new_value', version = version + 1
WHERE id = 1 AND version = @old_version;

使用场景：
悲观锁：
• 冲突概率高的场景（如抢购、秒杀）
• 对数据一致性要求极高的场景

乐观锁：
• 冲突概率低的场景（如普通更新操作）
• 高并发读多写少的场景
```

---

## 5. ⚡ 性能优化规范



### 5.1 游标使用规范



**🔸 游标基本概念**
```
什么是游标：
就像是数据库查询结果的"指针"
可以逐行处理查询结果，而不是一次性加载所有数据

使用场景：
• 需要逐行处理大量数据
• 复杂的业务逻辑需要对每行数据单独处理
• 无法用单个SQL语句完成的复杂操作
```

**📝 游标使用模板**
```sql
DELIMITER //
CREATE PROCEDURE sp_process_overdue_orders()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_order_id INT;
    DECLARE v_customer_id INT;
    DECLARE v_order_date DATETIME;
    DECLARE v_processed_count INT DEFAULT 0;
    
    -- 声明游标
    DECLARE order_cursor CURSOR FOR
        SELECT order_id, customer_id, order_date
        FROM orders 
        WHERE order_status = 'PENDING' 
        AND DATEDIFF(NOW(), order_date) > 7
        ORDER BY order_date;
    
    -- 声明游标结束处理器
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 打开游标
    OPEN order_cursor;
    
    -- 循环处理
    read_loop: LOOP
        FETCH order_cursor INTO v_order_id, v_customer_id, v_order_date;
        
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 处理每个订单
        CALL sp_handle_overdue_order(v_order_id, v_customer_id);
        SET v_processed_count = v_processed_count + 1;
        
        -- 可选：批量提交，避免长事务
        IF v_processed_count % 100 = 0 THEN
            COMMIT;
            START TRANSACTION;
        END IF;
        
    END LOOP;
    
    -- 关闭游标
    CLOSE order_cursor;
    
    -- 记录处理结果
    INSERT INTO process_log(process_type, processed_count, process_time)
    VALUES ('OVERDUE_ORDERS', v_processed_count, NOW());
    
END //
DELIMITER ;
```

### 5.2 临时表使用规范



**📊 临时表最佳实践**
```sql
-- 创建临时表处理复杂数据
DELIMITER //
CREATE PROCEDURE sp_generate_monthly_report(
    IN p_year INT,
    IN p_month INT
)
BEGIN
    -- 创建临时表存储中间结果
    CREATE TEMPORARY TABLE temp_monthly_stats (
        product_id INT,
        product_name VARCHAR(100),
        total_sales DECIMAL(12,2),
        total_quantity INT,
        avg_price DECIMAL(10,2),
        INDEX idx_product_id (product_id)
    ) ENGINE=InnoDB;
    
    -- 填充基础数据
    INSERT INTO temp_monthly_stats (
        product_id, product_name, total_sales, total_quantity
    )
    SELECT 
        p.product_id,
        p.product_name,
        SUM(oi.price * oi.quantity) as total_sales,
        SUM(oi.quantity) as total_quantity
    FROM products p
    JOIN order_items oi ON p.product_id = oi.product_id
    JOIN orders o ON oi.order_id = o.order_id
    WHERE YEAR(o.order_date) = p_year 
    AND MONTH(o.order_date) = p_month
    GROUP BY p.product_id, p.product_name;
    
    -- 计算平均价格
    UPDATE temp_monthly_stats 
    SET avg_price = total_sales / total_quantity
    WHERE total_quantity > 0;
    
    -- 生成最终报表
    SELECT 
        product_name,
        total_sales,
        total_quantity,
        avg_price,
        CASE 
            WHEN total_sales >= 10000 THEN '热销商品'
            WHEN total_sales >= 5000 THEN '普通商品'
            ELSE '滞销商品'
        END as sales_category
    FROM temp_monthly_stats
    ORDER BY total_sales DESC;
    
    -- 临时表会在存储过程结束时自动删除
END //
DELIMITER ;
```

### 5.3 性能优化策略



**🎯 查询优化原则**
```sql
-- ❌ 避免在存储过程中使用SELECT *
SELECT * FROM large_table WHERE condition;

-- ✅ 明确指定需要的字段
SELECT id, name, status FROM large_table WHERE condition;

-- ❌ 避免在循环中执行SQL查询
WHILE v_counter <= 1000 DO
    SELECT COUNT(*) INTO v_count FROM table WHERE id = v_counter;
    SET v_counter = v_counter + 1;
END WHILE;

-- ✅ 使用批量操作或JOIN查询
SELECT id, COUNT(*) as count 
FROM table 
WHERE id BETWEEN 1 AND 1000
GROUP BY id;
```

**📈 性能监控指标**
```
关键性能指标：
• 执行时间：单次调用耗时
• 锁等待时间：事务锁等待情况
• 内存使用：临时表和变量占用
• CPU使用率：复杂计算的处理器占用
• 磁盘IO：大量数据读写的磁盘压力

监控方法：
• 使用 SHOW PROCESSLIST 查看执行状态
• 通过 performance_schema 分析性能
• 启用慢查询日志记录慢执行的存储过程
• 定期收集执行统计信息
```

---

## 6. 📋 版本管理与文档规范



### 6.1 版本管理策略



**🔄 版本控制规范**
```sql
-- 在存储过程中添加版本信息
DELIMITER //
CREATE PROCEDURE sp_user_create_account(
    -- 参数定义...
)
COMMENT '
功能：创建用户账户
版本：v2.1.0
作者：张三  
创建时间：2025-01-15
修改历史：
  v1.0.0 - 2024-12-01 - 初始版本
  v1.1.0 - 2024-12-15 - 添加邮箱验证
  v2.0.0 - 2025-01-01 - 重构参数验证逻辑
  v2.1.0 - 2025-01-15 - 优化异常处理机制
依赖：无
'
BEGIN
    -- 存储过程内容...
END //
DELIMITER ;
```

**📁 文件组织结构**
```
database/
├── procedures/
│   ├── user/
│   │   ├── sp_user_create_account_v2.1.0.sql
│   │   ├── sp_user_update_profile_v1.2.0.sql
│   │   └── sp_user_delete_inactive_v1.0.0.sql
│   ├── order/
│   │   ├── sp_order_create_new_v1.5.0.sql
│   │   └── sp_order_batch_process_v2.0.0.sql
│   └── system/
│       └── sp_system_cleanup_logs_v1.1.0.sql
├── functions/
│   ├── calculation/
│   │   ├── fn_calc_age_v1.0.0.sql
│   │   └── fn_calc_distance_v1.2.0.sql
│   └── validation/
│       ├── fn_check_email_format_v1.1.0.sql
│       └── fn_check_phone_valid_v1.0.0.sql
└── deployment/
    ├── rollback_scripts/
    └── migration_scripts/
```

### 6.2 文档编写标准



**📚 文档模板**
```markdown
# 存储过程文档


# 基本信息


- **名称**: sp_user_create_account
- **版本**: v2.1.0  
- **分类**: 用户管理
- **作者**: 张三
- **创建时间**: 2025-01-15

# 功能描述


创建新的用户账户，包括参数验证、数据插入和初始化用户配置。

# 输入参数


| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| p_username | VARCHAR(50) | 是 | 用户名，3-50个字符 | 'zhangsan' |
| p_email | VARCHAR(100) | 是 | 邮箱地址 | 'zhang@example.com' |
| p_password | VARCHAR(255) | 是 | 密码（已加密） | 'encrypted_password' |

# 输出参数


| 参数名 | 类型 | 说明 |
|--------|------|------|
| out_user_id | INT | 新创建的用户ID，失败时为NULL |
| out_result_code | INT | 结果码（0=成功，其他=失败） |
| out_message | VARCHAR(255) | 结果描述信息 |

# 返回码说明


- `0`: 创建成功
- `1001`: 用户名不能为空
- `1002`: 用户名长度超限
- `1003`: 邮箱格式错误
- `2001`: 用户名已存在
- `2002`: 邮箱已被使用
- `3000`: 数据库操作失败

# 调用示例


```sql
CALL sp_user_create_account(
    'newuser',
    'newuser@example.com', 
    'encrypted_password_here',
    @user_id,
    @result_code, 
    @message
);

SELECT @user_id, @result_code, @message;
```

# 性能说明


- **平均执行时间**: 50ms
- **并发支持**: 高并发安全
- **资源消耗**: 低内存占用

# 注意事项


1. 密码参数必须在应用层已完成加密
2. 用户名和邮箱会自动转换为小写
3. 创建成功后会自动发送欢迎邮件

# 依赖关系


- 依赖表：users, user_profiles
- 依赖函数：fn_check_email_format
- 外部依赖：邮件服务

# 测试用例


参考：tests/procedures/test_sp_user_create_account.sql
```

### 6.3 测试验证规范



**🧪 测试用例设计**
```sql
-- 测试用例文件：test_sp_user_create_account.sql

-- 测试环境准备
CREATE DATABASE IF NOT EXISTS test_db;
USE test_db;

-- 清理测试数据
DELETE FROM users WHERE username LIKE 'test_%';

-- 测试用例1：正常创建用户
CALL sp_user_create_account(
    'test_user_001',
    'test001@example.com',
    'password_hash_123',
    @user_id,
    @result_code,
    @message
);

-- 验证结果
SELECT 
    CASE 
        WHEN @result_code = 0 AND @user_id IS NOT NULL THEN 'PASS'
        ELSE 'FAIL'
    END as test_result,
    '正常创建用户' as test_case,
    @result_code as result_code,
    @message as message;

-- 测试用例2：用户名为空
CALL sp_user_create_account(
    NULL,
    'test002@example.com',
    'password_hash_123',
    @user_id,
    @result_code,
    @message
);

-- 验证结果
SELECT 
    CASE 
        WHEN @result_code = 1001 THEN 'PASS'
        ELSE 'FAIL'
    END as test_result,
    '用户名为空验证' as test_case,
    @result_code as result_code,
    @message as message;

-- 测试用例3：重复用户名
CALL sp_user_create_account(
    'test_user_001',  -- 重复的用户名
    'test003@example.com',
    'password_hash_123',
    @user_id,
    @result_code,
    @message
);

-- 验证结果  
SELECT 
    CASE 
        WHEN @result_code = 2001 THEN 'PASS'
        ELSE 'FAIL'
    END as test_result,
    '重复用户名验证' as test_case,
    @result_code as result_code,
    @message as message;

-- 性能测试：批量创建用户
SET @start_time = NOW(6);

-- 创建100个测试用户
DROP PROCEDURE IF EXISTS test_batch_create;
DELIMITER //
CREATE PROCEDURE test_batch_create()
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= 100 DO
        CALL sp_user_create_account(
            CONCAT('batch_user_', i),
            CONCAT('batch', i, '@example.com'),
            'password_hash_batch',
            @user_id,
            @result_code,
            @message
        );
        SET i = i + 1;
    END WHILE;
END //
DELIMITER ;

CALL test_batch_create();
SET @end_time = NOW(6);

SELECT 
    TIMESTAMPDIFF(MICROSECOND, @start_time, @end_time) / 1000 as execution_time_ms,
    '批量创建100个用户耗时' as description;

-- 清理测试数据
DELETE FROM users WHERE username LIKE 'test_%' OR username LIKE 'batch_user_%';
```

---

## 7. 📋 核心要点总结



### 7.1 必须掌握的核心概念



```
🔸 存储过程与函数区别：过程执行操作，函数返回结果
🔸 命名规范：统一前缀，清晰表达功能，避免歧义
🔸 参数设计：明确输入输出，合理类型选择，完整验证
🔸 异常处理：声明处理器，优雅处理错误，保证数据一致性
🔸 事务控制：ACID特性，合理锁策略，避免长事务
🔸 性能优化：避免循环查询，合理使用临时表和游标
🔸 版本管理：规范文档，测试验证，变更追踪
```

### 7.2 关键理解要点



**🔹 何时使用存储过程和函数**
```
使用存储过程的场景：
• 复杂的业务流程需要多个步骤协调
• 需要事务控制确保数据一致性
• 频繁调用的复杂操作，提高性能
• 需要统一的数据操作标准

使用函数的场景：
• 数据计算和转换
• 可在SQL语句中直接调用的逻辑
• 无副作用的纯计算操作

不建议使用的场景：
• 简单的CRUD操作用ORM更合适
• 复杂的业务逻辑建议在应用层处理
• 需要频繁修改的业务规则
```

**🔹 性能优化的关键点**
```
查询优化：
• 明确指定字段，避免SELECT *
• 合理使用索引，避免全表扫描
• 批量操作替代循环查询

事务优化：
• 控制事务大小，避免长时间锁定
• 合理选择隔离级别
• 及时提交或回滚事务

资源优化：
• 临时表用完及时清理
• 游标处理完毕及时关闭
• 避免过多的变量声明
```

### 7.3 实际应用指导



**🎯 开发流程建议**
```
设计阶段：
1. 明确功能需求和性能要求
2. 设计输入输出参数
3. 规划异常处理策略
4. 评估性能影响

开发阶段：
1. 遵循命名规范
2. 编写完整的参数验证
3. 实现业务逻辑
4. 添加异常处理和事务控制

测试阶段：
1. 编写全面的测试用例
2. 进行性能测试
3. 验证异常处理逻辑
4. 测试并发场景

部署阶段：
1. 编写部署脚本
2. 准备回滚方案
3. 监控执行性能
4. 收集使用反馈
```

**🔧 维护管理建议**
```
日常维护：
• 定期检查执行性能
• 监控错误日志
• 及时处理异常情况

版本升级：
• 保持向后兼容性
• 提供平滑的升级路径
• 完整的变更文档

团队协作：
• 统一编码标准
• 规范代码审查流程
• 共享最佳实践
• 定期技术分享
```

**核心记忆要点**：
- 存储过程和函数是数据库的"程序"，要像写代码一样规范
- 命名要清晰，参数要验证，异常要处理，事务要控制
- 性能优化重在避免不必要的资源消耗
- 文档和测试是保证质量的重要手段
- 团队协作需要统一的标准和流程