---
title: 4、索引命名与设计规范
---
## 📚 目录

1. [索引基础概念](#1-索引基础概念)
2. [索引命名约定](#2-索引命名约定)
3. [主键索引规范](#3-主键索引规范)
4. [唯一索引标准](#4-唯一索引标准)
5. [普通索引规范](#5-普通索引规范)
6. [复合索引设计原则](#6-复合索引设计原则)
7. [索引长度与前缀索引](#7-索引长度与前缀索引)
8. [索引维护与性能评估](#8-索引维护与性能评估)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📖 索引基础概念


### 1.1 什么是索引


**🔸 通俗理解**
```
索引就像书的目录：
📚 没有索引的表 = 没有目录的书
• 找内容要一页页翻（全表扫描）
• 速度慢，效率低

📋 有索引的表 = 有目录的书  
• 通过目录快速定位（索引查找）
• 速度快，效率高
```

**🔸 技术定义**
- **索引（Index）**：数据库表中数据的有序结构
- **作用**：加速数据查找、排序、分组操作
- **本质**：用空间换时间的优化策略

### 1.2 索引的工作原理


**📊 查找过程对比**
```
无索引查找：                  有索引查找：
┌─────────────┐              ┌─────────────┐
│ id │ name   │              │ 索引B+树    │
├─────────────┤              ├─────────────┤
│ 1  │ 张三   │ ← 扫描       │    root     │
│ 2  │ 李四   │ ← 扫描       │   /    \    │
│ 3  │ 王五   │ ← 扫描       │ leaf   leaf │ → 直接定位
│... │ ...    │ ← 扫描       └─────────────┘
│1000│ 目标   │ ← 找到！
└─────────────┘

时间复杂度：O(n)              时间复杂度：O(log n)
```

### 1.3 索引类型概览


**🏷️ 按功能分类**
- **主键索引**：保证主键唯一性，一个表只能有一个
- **唯一索引**：保证字段唯一性，可以有多个
- **普通索引**：提升查询性能，最常用
- **复合索引**：多个字段组合的索引

**🏗️ 按存储结构分类**
- **聚簇索引**：数据和索引存储在一起
- **非聚簇索引**：索引和数据分开存储

---

## 2. 📝 索引命名约定


### 2.1 索引命名基本规则


**🔸 命名格式标准**
```sql
-- 基本格式：类型前缀_表名_字段名[_字段名]
-- 示例：
idx_user_email          -- 普通索引
uk_user_phone          -- 唯一索引  
pk_user_id            -- 主键索引
idx_order_user_status -- 复合索引
```

**📋 前缀约定说明**

| 索引类型 | 前缀 | 含义 | 示例 |
|---------|------|------|------|
| **主键索引** | `pk_` | Primary Key | `pk_user_id` |
| **唯一索引** | `uk_` | Unique Key | `uk_user_email` |
| **普通索引** | `idx_` | Index | `idx_user_name` |
| **外键索引** | `fk_` | Foreign Key | `fk_order_user_id` |

### 2.2 命名最佳实践


**✅ 推荐做法**
```sql
-- 1. 简洁明了，见名知意
idx_user_created_time    ✅ 好：能看出是用户表的创建时间索引
user_create_time_index   ❌ 差：格式不统一，过于冗长

-- 2. 使用下划线分隔
idx_order_status         ✅ 好：清晰的分隔
idxOrderStatus          ❌ 差：驼峰命名不统一

-- 3. 体现字段顺序（复合索引）
idx_user_age_city       ✅ 好：age在前，city在后
idx_user_city_age       ✅ 好：city在前，age在后（不同的索引）
```

**❌ 避免的做法**
```sql
-- 1. 名称过长
idx_user_information_create_time_and_update_time  ❌ 太长
idx_user_time                                     ✅ 简洁

-- 2. 无意义的名称  
index1, index2, temp_index                        ❌ 无意义
idx_user_email, idx_user_phone                    ✅ 有意义

-- 3. 重复冗余
idx_user_table_user_name                          ❌ 重复user
idx_user_name                                     ✅ 简洁
```

### 2.3 索引注释标准


**💬 注释规范**
```sql
-- 创建索引时添加注释
CREATE INDEX idx_user_email 
ON user(email) 
COMMENT '用户邮箱索引，用于登录查询';

CREATE INDEX idx_order_user_status 
ON order_info(user_id, status) 
COMMENT '订单用户状态复合索引，用于用户订单列表查询';

-- 注释内容要求：
-- ✅ 说明索引用途
-- ✅ 说明查询场景  
-- ✅ 简洁明了
```

---

## 3. 🔑 主键索引规范


### 3.1 主键选择原则


**🎯 主键设计标准**
```sql
-- ✅ 推荐：自增整数主键
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
  name VARCHAR(50) NOT NULL COMMENT '用户名',
  email VARCHAR(100) NOT NULL COMMENT '邮箱'
);

-- ❌ 不推荐：字符串主键
CREATE TABLE user (
  email VARCHAR(100) PRIMARY KEY,    -- 长度不固定，性能差
  name VARCHAR(50) NOT NULL
);
```

**📊 主键类型对比**

| 主键类型 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| **自增整数** | `查询快速` `空间小` `插入高效` | `不能跨库` `可能重复` | `🟢 大部分场景` |
| **UUID** | `全局唯一` `跨库安全` | `空间大` `查询较慢` | `🟡 分布式系统` |
| **业务字段** | `有业务含义` | `可能变更` `性能不稳定` | `🔴 特殊需求` |

### 3.2 主键索引命名


**🏷️ 命名规范**
```sql
-- 显式指定主键索引名称（推荐）
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT,
  name VARCHAR(50) NOT NULL,
  CONSTRAINT pk_user_id PRIMARY KEY (id)
);

-- 系统自动命名（可接受）
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL
);
-- 系统会自动创建名为 PRIMARY 的主键索引
```

### 3.3 复合主键规范


**⚠️ 复合主键使用注意**
```sql
-- 复合主键示例（谨慎使用）
CREATE TABLE user_role (
  user_id BIGINT NOT NULL,
  role_id BIGINT NOT NULL,
  created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY pk_user_role (user_id, role_id)
);

-- 更好的设计：添加自增主键
CREATE TABLE user_role (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  role_id BIGINT NOT NULL,
  created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_user_role (user_id, role_id)
);
```

> 💡 **最佳实践提示**
> 
> 优先使用单一自增整数主键，即使是关联表也建议这样设计。复合主键虽然节省空间，但会增加维护复杂度。

---

## 4. 🔐 唯一索引标准


### 4.1 唯一索引的作用


**🎯 核心功能**
```
唯一索引 = 数据唯一性约束 + 查询性能优化

两个作用：
1. 🛡️  数据约束：防止重复数据插入
2. ⚡ 性能优化：加速基于唯一字段的查询
```

### 4.2 唯一索引创建规范


**✅ 标准创建方式**
```sql
-- 方式1：建表时创建
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(100) NOT NULL,
  phone VARCHAR(20) NOT NULL,
  -- 单字段唯一索引
  UNIQUE KEY uk_user_email (email),
  UNIQUE KEY uk_user_phone (phone)
);

-- 方式2：后续添加
ALTER TABLE user 
ADD UNIQUE KEY uk_user_email (email);

-- 方式3：CREATE INDEX语句
CREATE UNIQUE INDEX uk_user_email 
ON user(email);
```

### 4.3 复合唯一索引


**🔗 多字段唯一约束**
```sql
-- 业务场景：同一个用户在同一个商品上只能有一条收藏记录
CREATE TABLE user_favorite (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  product_id BIGINT NOT NULL,
  created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  -- 复合唯一索引
  UNIQUE KEY uk_user_favorite (user_id, product_id)
);

-- 这样的数据是允许的：
-- (1, 100), (1, 200), (2, 100)  ✅
-- 这样的数据会报错：
-- (1, 100), (1, 100)  ❌ 违反唯一约束
```

### 4.4 唯一索引注意事项


**⚠️ NULL值处理**
```sql
-- NULL值在唯一索引中的特殊行为
CREATE TABLE test (
  id INT AUTO_INCREMENT PRIMARY KEY,
  unique_col VARCHAR(50),
  UNIQUE KEY uk_test_col (unique_col)
);

-- 允许插入多个NULL值
INSERT INTO test (unique_col) VALUES (NULL);  -- ✅ 成功
INSERT INTO test (unique_col) VALUES (NULL);  -- ✅ 成功
INSERT INTO test (unique_col) VALUES ('A');   -- ✅ 成功
INSERT INTO test (unique_col) VALUES ('A');   -- ❌ 错误：重复值
```

> ⚠️ **重要提醒**
> 
> MySQL中，NULL值在唯一索引中不被认为是重复的，可以插入多个NULL值。如果业务上不允许NULL值，应该添加NOT NULL约束。

**🔧 最佳实践建议**
```sql
-- 推荐：唯一字段设置为NOT NULL
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(100) NOT NULL,
  UNIQUE KEY uk_user_email (email)
);
```

---

## 5. 📊 普通索引规范


### 5.1 普通索引适用场景


**🎯 创建时机判断**
```
什么时候需要创建普通索引？

✅ 需要创建：
• WHERE条件中经常使用的字段
• ORDER BY排序的字段  
• GROUP BY分组的字段
• JOIN连接的字段

❌ 不需要创建：
• 很少查询的字段
• 频繁更新的字段
• 数据重复度很高的字段（如性别）
```

### 5.2 单字段索引


**📝 创建语法**
```sql
-- 标准创建方式
CREATE TABLE user (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  age INT,
  city VARCHAR(50),
  created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  -- 为经常查询的字段创建索引
  INDEX idx_user_name (name),
  INDEX idx_user_age (age),
  INDEX idx_user_city (city),
  INDEX idx_user_created_time (created_time)
);
```

**🔍 使用场景示例**
```sql
-- 这些查询会使用到对应的索引
SELECT * FROM user WHERE name = '张三';          -- 使用 idx_user_name
SELECT * FROM user WHERE age = 25;              -- 使用 idx_user_age  
SELECT * FROM user WHERE city = '北京';          -- 使用 idx_user_city
SELECT * FROM user ORDER BY created_time DESC;  -- 使用 idx_user_created_time
```

### 5.3 索引选择性分析


**📈 选择性计算**
```sql
-- 选择性 = 不同值的数量 / 总记录数
-- 选择性越高，索引效果越好

-- 检查字段的选择性
SELECT 
  COUNT(DISTINCT name) / COUNT(*) AS name_selectivity,
  COUNT(DISTINCT age) / COUNT(*) AS age_selectivity,
  COUNT(DISTINCT city) / COUNT(*) AS city_selectivity
FROM user;

-- 结果示例：
-- name_selectivity: 0.85  (高选择性，适合索引)
-- age_selectivity: 0.15   (低选择性，索引效果一般)
-- city_selectivity: 0.05  (很低选择性，不推荐索引)
```

**📊 选择性评估标准**

| 选择性范围 | 索引建议 | 说明 |
|-----------|---------|------|
| **> 0.5** | `🟢 强烈推荐` | 高选择性，索引效果很好 |
| **0.1 - 0.5** | `🟡 可以考虑` | 中等选择性，根据查询频率决定 |
| **< 0.1** | `🔴 不推荐` | 低选择性，索引效果差 |

---

## 6. 🔗 复合索引设计原则


### 6.1 什么是复合索引


**🔸 基本概念**
```
复合索引 = 多个字段组合成的一个索引

例如：idx_user_age_city (age, city)
这个索引包含两个字段：age 和 city

就像电话本：
• 先按姓氏排序（第一个字段）
• 姓氏相同的再按名字排序（第二个字段）
```

**🏗️ 存储结构示意**
```
复合索引 idx_user_age_city (age, city) 的存储：

age | city | 主键ID
----|------|-------
 18 | 北京 |   1
 18 | 上海 |   5  
 20 | 北京 |   3
 20 | 广州 |   7
 25 | 北京 |   2
```

### 6.2 最左前缀原则


**🔸 核心规则**
```
最左前缀原则：复合索引只有从最左边的字段开始，才能使用索引

索引：idx_user_age_city (age, city)

✅ 能使用索引的查询：
WHERE age = 25                    -- 使用索引（最左字段）
WHERE age = 25 AND city = '北京'   -- 使用索引（完整匹配）

❌ 不能使用索引的查询：
WHERE city = '北京'               -- 不能使用（跳过了最左字段）
```

**📝 实际测试示例**
```sql
-- 创建测试表和索引
CREATE TABLE user_test (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  age INT,
  city VARCHAR(50),
  salary INT,
  INDEX idx_age_city_salary (age, city, salary)
);

-- 查询分析
EXPLAIN SELECT * FROM user_test WHERE age = 25;                          -- ✅ 使用索引
EXPLAIN SELECT * FROM user_test WHERE age = 25 AND city = '北京';        -- ✅ 使用索引  
EXPLAIN SELECT * FROM user_test WHERE age = 25 AND salary = 8000;        -- ✅ 部分使用索引
EXPLAIN SELECT * FROM user_test WHERE city = '北京';                     -- ❌ 不使用索引
EXPLAIN SELECT * FROM user_test WHERE city = '北京' AND salary = 8000;   -- ❌ 不使用索引
```

### 6.3 字段顺序设计原则


**🎯 排序规则优先级**
```
复合索引字段顺序原则：

1. 🔍 等值查询字段放前面
2. 📊 选择性高的字段放前面  
3. 📈 范围查询字段放后面
4. 🔢 排序字段考虑放最后
```

**💡 实际设计示例**
```sql
-- 业务场景：经常根据年龄、城市、薪资查询用户
-- 查询模式分析：
-- 1. WHERE age = 25 AND city = '北京'                (等值查询)
-- 2. WHERE age BETWEEN 20 AND 30 AND city = '北京'   (范围查询)  
-- 3. WHERE city = '北京' ORDER BY salary DESC        (排序查询)

-- 字段选择性分析：
-- age: 选择性 0.3
-- city: 选择性 0.1  
-- salary: 选择性 0.8

-- 推荐索引设计：
CREATE INDEX idx_user_age_city_salary ON user (age, city, salary);

-- 设计理由：
-- ✅ age选择性比city高，放前面
-- ✅ 等值查询较多，age和city都放前面
-- ✅ salary选择性最高但主要用于排序，放最后
```

### 6.4 复合索引使用场景


**📋 适用的查询模式**
```sql
-- 索引：idx_user_age_city_salary (age, city, salary)

-- ✅ 高效使用索引的查询：
SELECT * FROM user WHERE age = 25;                                    -- 使用 age
SELECT * FROM user WHERE age = 25 AND city = '北京';                  -- 使用 age, city
SELECT * FROM user WHERE age = 25 AND city = '北京' AND salary > 8000; -- 使用全部字段
SELECT * FROM user WHERE age BETWEEN 20 AND 30 AND city = '北京';     -- age范围 + city等值

-- 🟡 部分使用索引的查询：
SELECT * FROM user WHERE age = 25 AND salary > 8000;                  -- 只使用age，salary无法使用
SELECT * FROM user WHERE age > 20;                                     -- 使用age，但是范围查询效果一般

-- ❌ 无法使用索引的查询：
SELECT * FROM user WHERE city = '北京';                               -- 跳过最左字段
SELECT * FROM user WHERE salary > 8000;                               -- 跳过前面字段
SELECT * FROM user WHERE city = '北京' AND salary > 8000;             -- 跳过最左字段
```

### 6.5 复合索引 vs 多个单索引


**🆚 性能对比**
```sql
-- 方案1：复合索引（推荐）
CREATE INDEX idx_user_age_city ON user (age, city);

-- 方案2：多个单索引
CREATE INDEX idx_user_age ON user (age);
CREATE INDEX idx_user_city ON user (city);

-- 查询：WHERE age = 25 AND city = '北京'
-- 方案1：直接使用复合索引，一次定位 ✅
-- 方案2：MySQL选择其中一个单索引，效果较差 ❌
```

**📊 选择建议**

| 查询模式 | 推荐方案 | 原因 |
|---------|---------|------|
| **多字段组合查询** | `复合索引` | 一次定位，效率最高 |
| **单字段各自查询** | `多个单索引` | 灵活性好，各自优化 |
| **混合查询场景** | `复合索引 + 单索引` | 综合考虑，按需设计 |

---

## 7. 📏 索引长度与前缀索引


### 7.1 索引长度控制原理


**🔸 为什么要控制索引长度**
```
索引长度过长的问题：
• 💾 占用更多存储空间
• 🐌 降低查询性能  
• 📉 减少索引页能存储的索引项数量
• 🔄 增加磁盘I/O次数

解决方案：
使用前缀索引，只对字段的前几个字符建立索引
```

### 7.2 前缀索引使用规范


**📝 前缀索引创建语法**
```sql
-- 语法：CREATE INDEX 索引名 ON 表名 (字段名(长度))

-- 示例：对邮箱字段的前20个字符建立索引
CREATE INDEX idx_user_email_prefix ON user (email(20));

-- 对url字段的前50个字符建立索引
CREATE INDEX idx_article_url_prefix ON article (url(50));
```

### 7.3 前缀长度选择方法


**🔍 选择性分析法**
```sql
-- 分析不同前缀长度的选择性
SELECT 
  COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS prefix_10,
  COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS prefix_15,
  COUNT(DISTINCT LEFT(email, 20)) / COUNT(*) AS prefix_20,
  COUNT(DISTINCT email) / COUNT(*) AS full_column
FROM user;

-- 结果示例：
-- prefix_10: 0.75
-- prefix_15: 0.90  
-- prefix_20: 0.95
-- full_column: 0.96

-- 选择原则：前缀选择性接近完整字段选择性即可
-- 这个例子中，20个字符就足够了
```

**📊 前缀长度推荐标准**

| 字段类型 | 推荐前缀长度 | 说明 |
|---------|------------|------|
| **邮箱地址** | `20-30字符` | 大部分邮箱前缀足够区分 |
| **URL地址** | `50-100字符` | 根据URL结构特点 |
| **用户名** | `10-20字符` | 中文用户名较短 |
| **手机号** | `完整长度` | 11位数字，无需前缀 |
| **身份证号** | `完整长度` | 18位，建议完整索引 |

### 7.4 前缀索引的限制


**⚠️ 使用限制**
```sql
-- 前缀索引无法用于ORDER BY和GROUP BY
CREATE INDEX idx_user_name_prefix ON user (name(10));

-- ❌ 不能使用前缀索引的场景：
SELECT * FROM user ORDER BY name;        -- 无法使用前缀索引排序
SELECT name, COUNT(*) FROM user GROUP BY name;  -- 无法使用前缀索引分组

-- ✅ 可以使用前缀索引的场景：
SELECT * FROM user WHERE name = '张三';   -- 可以使用前缀索引查找
SELECT * FROM user WHERE name LIKE '张%'; -- 可以使用前缀索引模糊匹配
```

### 7.5 函数索引规范


**🔧 MySQL 8.0+ 函数索引**
```sql
-- MySQL 8.0支持函数索引
CREATE INDEX idx_user_email_upper ON user ((UPPER(email)));

-- 使用场景：大小写不敏感查询
SELECT * FROM user WHERE UPPER(email) = 'USER@EXAMPLE.COM';

-- 注意：函数索引使用较少，主要用于特殊业务需求
```

> 💡 **最佳实践建议**
> 
> 1. 优先考虑完整字段索引
> 2. 字段长度超过50字符时考虑前缀索引
> 3. 通过选择性分析确定最优前缀长度
> 4. 注意前缀索引的使用限制

---

## 8. 🔧 索引维护与性能评估


### 8.1 索引监控指标


**📊 关键性能指标**
```sql
-- 查看索引使用统计
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,      -- 索引基数（不同值的数量）
    NULLABLE,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, SEQ_IN_INDEX;

-- 查看未使用的索引（MySQL 5.7+）
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL
AND count_star = 0
AND object_schema = 'your_database'
ORDER BY object_schema, object_name;
```

### 8.2 索引性能分析


**🔍 使用EXPLAIN分析查询**
```sql
-- 分析查询是否使用了索引
EXPLAIN SELECT * FROM user WHERE email = 'user@example.com';

-- 关键字段解读：
-- key: 实际使用的索引名称
-- key_len: 使用的索引长度
-- rows: 预计扫描的行数
-- Extra: 额外信息

-- 好的执行计划特征：
-- ✅ type: const, eq_ref, ref (高效)
-- ❌ type: ALL, index (低效，需要优化)
```

**📋 执行计划type类型解读**

| Type类型 | 性能等级 | 说明 | 示例场景 |
|---------|---------|------|----------|
| **const** | `🟢 最好` | 通过主键或唯一索引查找单行 | `WHERE id = 1` |
| **eq_ref** | `🟢 很好` | 连接查询中使用主键或唯一索引 | `JOIN ON a.id = b.user_id` |
| **ref** | `🟡 良好` | 使用非唯一索引查找 | `WHERE name = '张三'` |
| **range** | `🟡 一般` | 索引范围查询 | `WHERE age BETWEEN 20 AND 30` |
| **index** | `🔴 较差` | 全索引扫描 | `ORDER BY id` 无WHERE条件 |
| **ALL** | `🔴 最差` | 全表扫描 | 没有可用索引 |

### 8.3 索引维护策略


**🔄 定期维护任务**
```sql
-- 1. 重建索引（碎片整理）
ALTER TABLE user ENGINE=InnoDB;  -- 重建整个表
OPTIMIZE TABLE user;              -- 优化表（较少使用）

-- 2. 分析表统计信息
ANALYZE TABLE user;

-- 3. 删除未使用的索引
-- 先确认索引确实未使用
DROP INDEX idx_unused_index ON user;

-- 4. 检查重复索引
SELECT 
    a.TABLE_SCHEMA,
    a.TABLE_NAME,
    a.INDEX_NAME as index1,
    b.INDEX_NAME as index2,
    a.COLUMN_NAME
FROM INFORMATION_SCHEMA.STATISTICS a
JOIN INFORMATION_SCHEMA.STATISTICS b ON (
    a.TABLE_SCHEMA = b.TABLE_SCHEMA
    AND a.TABLE_NAME = b.TABLE_NAME  
    AND a.COLUMN_NAME = b.COLUMN_NAME
    AND a.INDEX_NAME != b.INDEX_NAME
);
```

### 8.4 索引维护规范


**📝 维护检查清单**
```
🔸 每周检查：
□ 查询慢日志，识别需要优化的SQL
□ 检查新增查询是否需要新索引
□ 监控索引使用率统计

🔸 每月检查：
□ 分析索引选择性变化
□ 清理未使用的索引  
□ 检查是否存在重复索引

🔸 每季度检查：
□ 评估索引策略是否需要调整
□ 重建碎片化严重的索引
□ 更新表统计信息
```

### 8.5 索引性能评估标准


**📈 评估方法**
```sql
-- 创建测试表
CREATE TABLE test_index (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(100),
  age INT,
  city VARCHAR(50)
);

-- 插入测试数据（10万条）
-- ... 数据插入 ...

-- 测试无索引查询
SELECT * FROM test_index WHERE name = '张三';
-- 记录执行时间

-- 创建索引
CREATE INDEX idx_test_name ON test_index (name);

-- 测试有索引查询  
SELECT * FROM test_index WHERE name = '张三';
-- 对比执行时间

-- 性能提升评估
-- 查询时间从 100ms 降低到 5ms，提升 20倍 ✅
```

**🎯 性能评估标准**

| 查询响应时间 | 性能等级 | 优化建议 |
|------------|---------|---------|
| **< 10ms** | `🟢 优秀` | 保持现状 |
| **10-100ms** | `🟡 良好` | 可以接受，关注趋势 |
| **100ms-1s** | `🟠 需要优化` | 检查索引设计 |
| **> 1s** | `🔴 严重问题` | 立即优化 |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 索引本质：用空间换时间的数据库优化技术
🔸 命名规范：pk_/uk_/idx_/fk_ + 表名 + 字段名的标准格式
🔸 索引类型：主键索引、唯一索引、普通索引、复合索引
🔸 最左前缀：复合索引必须从最左字段开始才能生效
🔸 前缀索引：长字段通过前缀索引节省空间
🔸 维护监控：定期分析索引使用情况和性能表现
```

### 9.2 关键设计原则


**🎯 索引设计黄金法则**
```
✅ 创建原则：
• 频繁查询的字段需要索引
• 选择性高的字段优先创建索引  
• WHERE、ORDER BY、GROUP BY字段考虑索引
• JOIN关联字段必须有索引

❌ 避免原则：
• 不要为很少使用的字段创建索引
• 避免在频繁更新的字段上建立过多索引
• 不要创建过长的索引
• 避免重复和冗余索引
```

### 9.3 性能优化要点


**⚡ 优化策略**
```
🔍 查询优化：
• 使用EXPLAIN分析执行计划
• 优先使用覆盖索引减少回表
• 合理使用复合索引覆盖多字段查询

📊 监控维护：
• 定期清理未使用的索引
• 监控慢查询日志
• 及时更新表统计信息
• 重建碎片化严重的索引
```

### 9.4 实际应用建议


**💼 业务场景应用**
- **用户系统**：邮箱、手机号唯一索引，用户名普通索引
- **订单系统**：用户ID+状态复合索引，订单号唯一索引  
- **内容系统**：分类ID+发布时间复合索引，标题前缀索引
- **日志系统**：时间范围索引，用户ID索引

**🔧 开发建议**
- **设计阶段**：根据查询模式预先设计索引策略
- **开发阶段**：使用EXPLAIN验证SQL执行计划
- **测试阶段**：在接近生产数据量的环境中测试索引效果  
- **运维阶段**：建立索引监控和维护机制

**核心记忆口诀**：
```
索引命名要规范，前缀统一易识别
主键唯一保约束，普通索引提性能  
复合索引左前缀，字段顺序要合理
长度控制用前缀，维护监控不可缺
```