---
title: 18、gh-ost与传统DDL对比
---
## 📚 目录

1. [传统ALTER TABLE的限制与问题](#1-传统ALTER-TABLE的限制与问题)
2. [gh-ost核心优势分析](#2-gh-ost核心优势分析)
3. [锁表时间与业务影响对比](#3-锁表时间与业务影响对比)
4. [性能开销全面对比](#4-性能开销全面对比)
5. [安全性与风险评估](#5-安全性与风险评估)
6. [适用场景分析指南](#6-适用场景分析指南)
7. [选择决策标准](#7-选择决策标准)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚫 传统ALTER TABLE的限制与问题


### 1.1 传统DDL的工作原理


**🔸 基本工作流程**
传统的`ALTER TABLE`操作本质上是一个"重建表"的过程：

```
传统DDL执行步骤：
┌─────────────────┐
│  1. 锁定原表     │ ← 阻塞所有写操作
├─────────────────┤
│  2. 创建新表结构 │ ← 根据ALTER语句
├─────────────────┤
│  3. 复制全部数据 │ ← 逐行复制到新表
├─────────────────┤
│  4. 重建索引     │ ← 重新构建所有索引
├─────────────────┤
│  5. 替换原表     │ ← 原子性替换
└─────────────────┘
```

**💡 核心问题解释**
这个过程最大的问题是**步骤1的锁定**，它会：
- **阻塞写操作**：所有INSERT、UPDATE、DELETE都被阻塞
- **影响读操作**：虽然可以读，但性能会下降
- **锁定时间长**：整个过程都需要持有锁

### 1.2 传统DDL的核心限制


**🔸 锁表时间过长**
```
表大小对应的锁表时间估算：
1GB数据   ≈ 5-10分钟锁表
10GB数据  ≈ 30-60分钟锁表
100GB数据 ≈ 3-8小时锁表
1TB数据   ≈ 数天锁表

实际影响：
- 用户操作失败
- 应用程序超时
- 业务完全中断
```

**🔸 无法中途取消**
一旦开始执行，传统DDL操作就无法安全停止：
```
问题场景：
1. DDL运行了2小时，发现影响太大
2. 想要取消操作，但已经无法回头
3. 只能等待完成或强制中断(可能导致数据损坏)
4. 强制中断后需要从备份恢复数据
```

**🔸 资源消耗集中**
```
资源使用特点：
CPU使用率：突然飙升到90%以上
磁盘I/O：  持续高负载读写
内存占用：大量缓存被占用
网络带宽：如果涉及复制，网络也会被占满
```

### 1.3 对业务的实际影响


**📊 业务中断影响评估**

| 业务类型 | **影响程度** | **典型后果** | **可接受停机时间** |
|---------|------------|------------|------------------|
| 🛒 **电商系统** | `极高` | `订单丢失、用户流失` | `< 5分钟` |
| 💰 **金融系统** | `严重` | `交易失败、监管问题` | `< 1分钟` |
| 📱 **社交应用** | `较高` | `用户体验下降` | `< 30分钟` |
| 📊 **数据分析** | `中等` | `报表延迟` | `< 2小时` |

**⚠️ 实际案例**
```
某电商公司的教训：
- 计划：晚上2点执行DDL，预计30分钟完成
- 实际：由于数据量增长，执行了3小时
- 结果：错过了早高峰，损失订单超过50万
- 教训：数据量增长速度远超预期
```

---

## 2. 🚀 gh-ost核心优势分析


### 2.1 gh-ost的工作原理


**🔸 核心设计思想**
gh-ost采用**"影子表+binlog追踪"**的方式，完全避免锁表：

```
gh-ost执行流程：
原表(users)          影子表(_users_gho)       
┌─────────────┐     ┌─────────────────┐
│   正常业务   │────▶│   同步变更数据   │
│   读写操作   │     │   (通过binlog)  │
└─────────────┘     └─────────────────┘
       │                      │
       ▼                      ▼
   用户无感知              后台静默复制
                              │
                              ▼
                         原子性切换
```

**💡 关键技术点**
- **影子表**：创建一个新结构的空表，不影响原表
- **binlog解析**：实时解析binlog获取数据变更
- **增量同步**：将变更应用到影子表
- **原子切换**：最后一步快速替换表名

### 2.2 核心优势详解


**✅ 零锁表时间**
```
传统DDL：  [████████████████████] 100%时间锁表
gh-ost：   [                    ]■ 仅切换瞬间锁表

锁表时间对比：
传统方式：几小时到几天
gh-ost：  不到1秒(仅表名切换时)
```

**✅ 可控的负载**
```bash
# 可以精确控制执行速度
--throttle-control-replicas="replica1.db,replica2.db"  # 监控从库延迟
--max-lag-millis=1500                                  # 延迟超过1.5秒自动暂停
--chunk-size=1000                                      # 每批处理1000行
--nice-ratio=2.0                                       # 暂停时间是工作时间的2倍
```

**✅ 随时可暂停/恢复**
```bash
# 发现负载过高，立即暂停
echo "throttle" | nc -U /tmp/gh-ost.sock

# 业务高峰期过后，继续执行  
echo "no-throttle" | nc -U /tmp/gh-ost.sock

# 彻底停止操作
echo "panic" | nc -U /tmp/gh-ost.sock
```

**✅ 实时进度监控**
```bash
# 查看详细进度信息
echo "status" | nc -U /tmp/gh-ost.sock

输出示例：
# Migrating database:table from host:port
# Migration started at: 2024-01-15 10:00:00
# ETA: 2024-01-15 12:30:00 (2h30m remaining)
# Progress: 65.8% (658000/1000000 rows copied)
# Current lag: 120ms
# Throttle reason: none
```

### 2.3 技术实现优势


**🔸 binlog解析技术**
gh-ost通过解析MySQL的binlog来追踪数据变更，这比触发器方式更高效：

```
数据变更追踪对比：
触发器方式：
原表操作 → 触发器执行 → 影子表同步
(增加原表负载)    (影响原表性能)

binlog方式：
原表操作 → binlog记录 → gh-ost解析 → 影子表同步
(正常负载)   (MySQL正常流程)  (独立进程)
```

**🔸 智能限流机制**
```
gh-ost的智能限流：
1. 监控主库负载 → CPU、IO指标
2. 监控从库延迟 → 复制lag时间  
3. 监控业务指标 → 自定义SQL查询
4. 动态调整速度 → 自动暂停/恢复

传统DDL限流：
基本没有 → 全速执行到底
```

---

## 3. ⏱️ 锁表时间与业务影响对比


### 3.1 锁表时间详细对比


**📊 不同数据量的锁表时间**

| 数据量 | **传统DDL锁表时间** | **gh-ost锁表时间** | **业务影响程度** |
|-------|-------------------|------------------|----------------|
| 100MB | `30秒-2分钟` | `< 1秒` | `传统：短暂中断，gh-ost：无影响` |
| 1GB | `5-15分钟` | `< 1秒` | `传统：严重影响，gh-ost：无影响` |
| 10GB | `30分钟-2小时` | `< 1秒` | `传统：业务中断，gh-ost：无影响` |
| 100GB | `3-12小时` | `< 1秒` | `传统：长时间中断，gh-ost：无影响` |
| 1TB | `数天` | `< 1秒` | `传统：不可接受，gh-ost：无影响` |

**💡 实际测试案例**
```
真实生产环境测试：
表大小：500GB，5亿行记录
字段变更：添加一个索引

传统DDL：
- 预计执行时间：8-12小时
- 实际锁表时间：10小时23分钟
- 业务影响：完全中断10小时

gh-ost：
- 总执行时间：6小时45分钟  
- 锁表时间：0.8秒(切换瞬间)
- 业务影响：几乎无感知
```

### 3.2 业务影响对比分析


**🔸 用户体验影响**

```
传统DDL期间用户体验：
时间轴：0────1小时────2小时────完成
状态： │    错误     │   超时   │ 恢复
用户： │ 无法登录    │ 操作失败 │ 正常

gh-ost期间用户体验：  
时间轴：0────1小时────2小时────完成
状态： │    正常     │   正常   │ 正常
用户： │ 无感知使用  │ 无感知   │ 正常
```

**🔸 系统资源影响**

```
CPU使用率对比：
传统DDL：
┌─ 执行期间 ─┐
│ ████████   │ 80-95% (持续高负载)
└───────────┘

gh-ost：
┌─ 执行期间 ─┐  
│ ███░░░░░   │ 30-50% (可控负载)
└───────────┘
```

### 3.3 风险暴露时间


**⚠️ 风险暴露期对比**

| 风险类型 | **传统DDL风险期** | **gh-ost风险期** | **风险说明** |
|---------|-----------------|----------------|------------|
| 🔒 **业务中断** | `整个执行期间` | `< 1秒` | `用户无法正常使用系统` |
| 💥 **操作失败** | `无法回滚` | `可随时停止` | `失败后的恢复难度` |
| 📊 **数据不一致** | `中途失败风险高` | `实时同步保证一致性` | `数据完整性保障` |
| ⚡ **系统故障** | `影响整个集群` | `影响有限` | `故障扩散范围` |

---

## 4. 📈 性能开销全面对比


### 4.1 CPU资源消耗对比


**🔸 CPU使用模式**

```
传统DDL的CPU使用：
时间 │ CPU使用率
────┼─────────
 0  │ ████████████████████ 95%  ← 突然飙升
 1h │ ████████████████████ 90%  ← 持续高负载  
 2h │ ████████████████████ 95%  ← 无法控制
 3h │ █████░░░░░░░░░░░░░░░ 25%  ← 完成后骤降

gh-ost的CPU使用：
时间 │ CPU使用率  
────┼─────────
 0  │ ████░░░░░░░░░░░░░░░░ 20%  ← 平缓开始
 1h │ ██████░░░░░░░░░░░░░░ 30%  ← 可控增长
 2h │ ████░░░░░░░░░░░░░░░░ 20%  ← 自动调节
 3h │ ██░░░░░░░░░░░░░░░░░░ 10%  ← 平缓结束
```

**💡 实际测试数据**
```
相同操作的CPU对比(添加索引到100GB表)：
传统DDL：
- 平均CPU：85%
- 峰值CPU：98%
- CPU瓶颈时长：全程

gh-ost：
- 平均CPU：25%  
- 峰值CPU：45%
- CPU瓶颈时长：无
```

### 4.2 磁盘I/O开销对比


**🔸 磁盘I/O模式**

| 指标 | **传统DDL** | **gh-ost** | **差异说明** |
|-----|-----------|-----------|------------|
| **读取I/O** | `全速读取原表` | `分批读取，可控速度` | `gh-ost可限制读取速度` |
| **写入I/O** | `全速写入临时表` | `增量写入影子表` | `gh-ost写入更平滑` |
| **峰值IOPS** | `达到硬件极限` | `可配置上限` | `gh-ost保护系统稳定性` |
| **I/O持续性** | `持续高负载` | `间歇性负载` | `gh-ost有休眠机制` |

**📊 具体数据对比**
```bash
# 传统DDL的I/O统计
读取速度：1500MB/s (无法控制)
写入速度：800MB/s  (无法控制)  
IOPS：    15000    (达到瓶颈)

# gh-ost的I/O统计(配置限制后)
读取速度：300MB/s  (可配置--throttle-flag-file)
写入速度：200MB/s  (受限于chunk-size)
IOPS：    3000     (在安全范围内)
```

### 4.3 内存使用对比


**🔸 内存消耗模式**

```
传统DDL内存使用：
┌─ 执行开始 ─┐
│ 突然占用   │ ← 大量buffer pool被占用
│ 大块内存   │ ← 排序、临时表空间
│ 持续到结束 │ ← 无法释放
└───────────┘

gh-ost内存使用：
┌─ 执行期间 ─┐
│ 渐进式增长 │ ← 逐步分配内存
│ 可控范围内 │ ← 内存使用可预测  
│ 及时释放   │ ← 定期回收内存
└───────────┘
```

### 4.4 网络带宽影响


**🔸 复制延迟对比**

```
主从复制延迟：
传统DDL：
主库 ──大量binlog──▶ 从库
     (瞬间产生GB级别binlog)
     
从库状态：
- 复制延迟：几小时
- 从库负载：极高
- 业务影响：读写分离失效

gh-ost：
主库 ──平滑binlog──▶ 从库  
     (分散产生，可控速度)
     
从库状态：
- 复制延迟：< 1秒(可配置)
- 从库负载：正常
- 业务影响：无
```

---

## 5. 🛡️ 安全性与风险评估


### 5.1 数据安全性对比


**🔸 数据一致性保障**

```
传统DDL的一致性风险：
1. 执行期间数据被锁定 ✓ (强一致性)
2. 中途失败回滚困难 ✗ (风险高)
3. 无法验证结果正确性 ✗ (盲目信任)

gh-ost的一致性保障：
1. 实时同步保证一致性 ✓ (最终一致性)  
2. 可随时停止和回滚 ✓ (风险可控)
3. 内置数据校验机制 ✓ (结果可验证)
```

**⚠️ 关键风险点分析**

| 风险类型 | **传统DDL风险** | **gh-ost风险** | **风险缓解措施** |
|---------|---------------|---------------|----------------|
| 🔥 **中途失败** | `数据可能损坏，难以恢复` | `影子表可直接删除` | `gh-ost：--panic-flag-file` |
| ⚡ **系统崩溃** | `可能导致表损坏` | `原表完全不受影响` | `gh-ost：原表始终可用` |
| 🐛 **工具Bug** | `直接影响生产数据` | `只影响影子表` | `gh-ost：故障隔离` |
| 📊 **数据不一致** | `中途失败后难以处理` | `实时监控和校验` | `gh-ost：--serve-socket-file` |

### 5.2 操作安全性


**🔸 操作可控性对比**

```bash
# 传统DDL：一旦开始就无法停止
ALTER TABLE users ADD COLUMN age INT;
# 如果想中途停止 → 只能强制杀掉连接 → 可能数据损坏

# gh-ost：完全可控
gh-ost \
  --host="localhost" \
  --database="test" \
  --table="users" \
  --alter="ADD COLUMN age INT" \
  --panic-flag-file="/tmp/gh-ost.panic"    # 紧急停止文件
  --throttle-flag-file="/tmp/gh-ost.throttle"  # 暂停文件
```

**🔸 回滚机制**

```
传统DDL回滚：
执行前：需要完整备份 (耗时耗空间)
执行中：无法回滚
执行后：只能从备份恢复 (可能丢失数据)

gh-ost回滚：
执行前：原表完全不动
执行中：随时可以停止 (echo "panic" | nc -U /tmp/gh-ost.sock)
执行后：如有问题，原表仍然完整
```

### 5.3 监控和告警


**📊 监控能力对比**

```
传统DDL监控：
- 进度：无法准确获知 ✗
- 性能：只能看系统指标 ✗  
- 风险：无法提前预警 ✗
- 控制：无法动态调整 ✗

gh-ost监控：
- 进度：精确到百分比 ✓
- 性能：详细的内置指标 ✓
- 风险：多维度监控告警 ✓
- 控制：实时动态调整 ✓
```

**🔍 实际监控示例**
```bash
# gh-ost提供丰富的监控接口
echo "status" | nc -U /tmp/gh-ost.sock

# 输出详细状态信息：
{
  "Current": 1250000,     # 当前已处理行数
  "Total": 2000000,       # 总行数  
  "Progress": 62.5,       # 完成百分比
  "ETA": "2024-01-15 14:30:00",  # 预计完成时间
  "CurrentLag": "0.12s",  # 当前复制延迟
  "ThrottleReason": "",   # 限流原因
  "IsThrottled": false    # 是否被限流
}
```

---

## 6. 🎯 适用场景分析指南


### 6.1 优先使用gh-ost的场景


**✅ 强烈推荐使用gh-ost**

```
📊 大表DDL操作 (>1GB)：
- 表大小：超过1GB的表
- 执行时间：预计超过10分钟的DDL
- 业务要求：不能接受长时间锁表
- 典型操作：添加列、添加索引、修改列类型

🔄 高可用业务系统：
- 7x24小时服务
- 对停机时间极其敏感  
- 用户量大，并发高
- 金融、电商、社交等核心业务

⚡ 生产环境变更：
- 生产数据库结构变更
- 需要保证业务连续性
- 需要可控的变更过程
- 要求变更可回滚
```

**💡 具体使用建议**

| 业务类型 | **表大小阈值** | **推荐理由** | **关键配置** |
|---------|---------------|------------|------------|
| 🛒 **电商核心表** | `> 100MB` | `订单、商品表不能锁定` | `--max-lag-millis=500` |
| 💰 **金融交易表** | `> 50MB` | `交易数据实时性要求高` | `--throttle-control-replicas` |
| 👥 **用户数据表** | `> 500MB` | `用户操作不能中断` | `--chunk-size=500` |
| 📊 **日志分析表** | `> 5GB` | `大数据量，传统DDL不现实` | `--nice-ratio=3.0` |

### 6.2 可以使用传统DDL的场景


**✅ 传统DDL仍然适用**

```
📅 维护窗口操作：
- 有明确的维护时间窗口
- 可以接受短时间业务中断  
- 表大小较小 (<100MB)
- 操作简单，风险可控

🧪 开发测试环境：
- 非生产环境
- 对业务连续性要求不高
- 快速验证DDL效果
- 学习和实验用途

⚡ 紧急修复：
- 需要立即生效的DDL
- 简单的结构调整
- 小表的快速修改
- 优化器hint等不影响数据的变更
```

### 6.3 场景选择决策树


```
DDL操作决策流程：
                开始DDL变更需求
                       │
                   估算表大小
                       │
              ┌────────┴────────┐
              │                 │  
         表大小 < 100MB      表大小 ≥ 100MB
              │                 │
          评估锁表时间            │
              │                 │
      ┌───────┴───────┐        │
      │               │        │
  锁表时间<5分钟   锁表时间≥5分钟   │
      │               │        │
  可接受业务中断？   ────┴────────┘
      │                      │
  ┌───┴───┐                 │
  │       │                 │
 是      否                 │
  │       │                 │
使用传统DDL  ────────────────┘
              │
          使用gh-ost
```

### 6.4 混合策略建议


**🔧 分阶段实施策略**

```
生产环境DDL最佳实践：

阶段一：评估和准备
1. 评估表大小和影响范围
2. 在测试环境验证操作
3. 选择合适的工具和时机

阶段二：工具选择
小表且可停机 → 传统DDL
大表或不可停机 → gh-ost  

阶段三：执行监控
- 实时监控系统指标
- 准备回滚预案
- 业务功能验证

阶段四：后续优化
- 分析执行效果
- 优化配置参数
- 总结经验教训
```

---

## 7. ⚖️ 选择决策标准


### 7.1 核心决策因子


**📊 决策权重模型**

| 决策因子 | **权重** | **传统DDL得分** | **gh-ost得分** | **说明** |
|---------|---------|---------------|--------------|---------|
| 🕐 **业务连续性** | `40%` | `2分` | `10分` | `最重要因子` |
| ⚡ **执行性能** | `25%` | `8分` | `7分` | `传统DDL更快完成` |
| 🛡️ **操作安全性** | `20%` | `5分` | `9分` | `gh-ost更安全可控` |
| 🔧 **操作复杂度** | `10%` | `9分` | `6分` | `传统DDL更简单` |
| 💰 **学习成本** | `5%` | `10分` | `5分` | `团队熟悉程度` |

**💡 综合得分计算**
```
传统DDL综合得分：
2×0.4 + 8×0.25 + 5×0.2 + 9×0.1 + 10×0.05 = 5.3分

gh-ost综合得分：  
10×0.4 + 7×0.25 + 9×0.2 + 6×0.1 + 5×0.05 = 8.2分

结论：在生产环境中，gh-ost具有明显优势
```

### 7.2 详细评估标准


**🔸 业务连续性评估**

```
评估维度：
1. 可接受停机时间
   - < 1分钟：必须使用gh-ost
   - 1-10分钟：强烈推荐gh-ost  
   - 10-60分钟：推荐gh-ost
   - > 60分钟：可考虑传统DDL

2. 业务高峰期影响
   - 高峰期变更：只能gh-ost
   - 低峰期变更：两者皆可
   - 维护窗口变更：传统DDL可接受

3. 用户影响范围  
   - 核心用户功能：使用gh-ost
   - 边缘功能：可用传统DDL
   - 内部系统：传统DDL可接受
```

**🔸 技术风险评估**

```
风险等级判断：
高风险场景 → 必须使用gh-ost：
- 大表(>10GB)
- 核心业务表
- 无法快速回滚
- 团队经验不足

中风险场景 → 推荐使用gh-ost：
- 中等表(1-10GB) 
- 重要业务表
- 有维护窗口但较短
- 团队有一定经验

低风险场景 → 可使用传统DDL：
- 小表(<1GB)
- 非核心表
- 足够的维护窗口
- 团队经验丰富
```

### 7.3 团队能力评估


**🎯 技能要求对比**

| 技能要求 | **传统DDL** | **gh-ost** | **说明** |
|---------|-----------|-----------|---------|
| 📚 **MySQL基础** | `必需` | `必需` | `两者都需要` |
| 🔧 **DDL语法** | `熟练` | `基础` | `gh-ost简化了语法` |
| 📊 **监控能力** | `基础` | `熟练` | `gh-ost需要更多监控` |
| 🐛 **故障处理** | `熟练` | `中等` | `gh-ost故障更易处理` |
| 🛠️ **工具使用** | `无` | `需要学习` | `gh-ost有学习成本` |

**📈 学习路径建议**
```
gh-ost学习计划：
第1周：理论学习
- 了解gh-ost原理
- 阅读官方文档
- 学习基本参数

第2周：环境搭建  
- 搭建测试环境
- 安装配置gh-ost
- 执行简单测试

第3周：实践练习
- 小表DDL练习
- 监控和控制练习
- 故障模拟和处理

第4周：生产准备
- 制定使用规范
- 准备监控脚本
- 建立应急预案
```

### 7.4 成本效益分析


**💰 总体成本对比**

```
传统DDL成本构成：
直接成本：
- 人员时间成本：中等 (操作简单)
- 系统资源成本：高 (资源占用大)
- 学习培训成本：低 (团队熟悉)

间接成本：
- 业务中断损失：极高 (核心风险)
- 用户体验损失：高 (用户流失)
- 风险处理成本：高 (回滚困难)

gh-ost成本构成：
直接成本：
- 人员时间成本：高 (学习和配置)
- 系统资源成本：低 (资源可控)  
- 学习培训成本：中等 (需要培训)

间接成本：
- 业务中断损失：无 (无业务影响)
- 用户体验损失：无 (用户无感知)
- 风险处理成本：低 (容易回滚)
```

**📊 ROI分析**
```
投资回报率计算：
假设一次大表DDL操作：

传统DDL：
- 直接成本：5000元
- 业务损失：50000元 (按停机成本计算)
- 总成本：55000元

gh-ost：
- 直接成本：8000元 (包含学习成本)
- 业务损失：0元
- 总成本：8000元

节省成本：47000元
ROI = (47000-3000)/3000 × 100% = 1466%
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的关键对比


```
🔸 核心差异：锁表时间是最大区别点
🔸 业务影响：gh-ost几乎零业务影响，传统DDL影响严重
🔸 安全性：gh-ost可控性强，传统DDL风险较高
🔸 适用场景：大表必用gh-ost，小表可选传统DDL
🔸 学习成本：gh-ost需要额外学习，但ROI极高
```

### 8.2 关键决策要点


**🔹 什么时候必须用gh-ost**
```
强制使用场景：
- 表大小 > 10GB
- 7x24小时服务
- 金融、电商等核心业务
- 不能接受任何业务中断
- 需要可控的变更过程
```

**🔹 什么时候可以用传统DDL**
```
可选使用场景：
- 表大小 < 100MB
- 有维护窗口
- 非核心业务系统
- 开发测试环境
- 团队对gh-ost不熟悉且时间紧急
```

**🔹 技术选型建议**
```
选型原则：
1. 业务连续性 > 技术复杂度
2. 长期收益 > 短期成本
3. 安全可控 > 执行速度
4. 团队能力匹配
```

### 8.3 最佳实践建议


**🎯 实施建议**
- **分阶段推广**：从非核心系统开始，逐步推广到核心系统
- **团队培训**：投资团队的gh-ost技能培训，长期收益巨大
- **标准化流程**：建立标准的DDL操作流程和规范
- **监控体系**：完善的监控和告警机制是成功的关键

**⚠️ 关键注意事项**
- **测试验证**：任何生产变更前都要在测试环境充分验证
- **备份策略**：无论使用哪种方法，完整备份都是必需的
- **应急预案**：准备详细的应急处理和回滚方案
- **团队协作**：确保团队所有成员都理解选择的工具和流程

**核心记忆**：
- gh-ost解决了传统DDL锁表时间长的核心痛点
- 业务连续性要求是选择的首要考虑因素
- 学习成本是一次性的，但收益是长期的
- 安全可控的变更过程比快速完成更重要