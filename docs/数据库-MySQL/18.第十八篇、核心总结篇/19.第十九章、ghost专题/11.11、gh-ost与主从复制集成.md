---
title: 11、gh-ost与主从复制集成
---
## 📚 目录

1. [主从复制环境概述](#1-主从复制环境概述)
2. [gh-ost在主从环境的部署策略](#2-gh-ost在主从环境的部署策略)
3. [复制拓扑支持详解](#3-复制拓扑支持详解)
4. [test-on-replica测试模式](#4-test-on-replica测试模式)
5. [migrate-on-replica迁移模式](#5-migrate-on-replica迁移模式)
6. [复制格式要求与检查](#6-复制格式要求与检查)
7. [复制用户权限配置](#7-复制用户权限配置)
8. [复制健康检查机制](#8-复制健康检查机制)
9. [复制异常处理策略](#9-复制异常处理策略)
10. [多级复制支持](#10-多级复制支持)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🌐 主从复制环境概述


### 1.1 什么是MySQL主从复制


**🔸 基本概念**
MySQL主从复制就像是**数据的自动备份和同步系统**，简单来说：
- **主库（Master）**：接收写操作的数据库，相当于"老师"
- **从库（Slave）**：自动复制主库数据的数据库，相当于"学生"
- **复制过程**：从库会自动学习主库的所有数据变化

```
主从复制架构示意图：
┌─────────────┐     binlog     ┌─────────────┐
│   主库       │ ─────────────> │   从库       │
│  (Master)   │               │  (Slave)    │
│             │               │             │
│ 写操作 ←──── │               │ ────→ 读操作 │
└─────────────┘               └─────────────┘
   写入数据                      同步数据
```

### 1.2 主从复制的工作原理


**💡 复制过程详解**
```
步骤1：主库执行SQL → 记录到binlog日志
步骤2：从库IO线程 → 读取主库binlog
步骤3：从库写入relay-log → 中继日志
步骤4：从库SQL线程 → 执行relay-log中的SQL
```

**🔸 核心组件**
- **Binlog**：主库的二进制日志，记录所有数据变更
- **Relay-log**：从库的中继日志，存储从主库复制来的binlog
- **IO线程**：负责从主库拉取binlog数据
- **SQL线程**：负责执行relay-log中的SQL语句

### 1.3 为什么gh-ost需要关注主从复制


**🎯 核心原因**
1. **避免影响业务**：在从库上测试，不影响主库性能
2. **数据一致性**：确保主从数据在迁移过程中保持同步
3. **降低风险**：可以在从库先验证迁移效果
4. **灵活选择**：根据业务需求选择不同的迁移策略

---

## 2. 🚀 gh-ost在主从环境的部署策略


### 2.1 部署模式选择


**📊 三种主要部署模式**

| 模式 | **运行位置** | **适用场景** | **影响范围** |
|------|------------|-------------|-------------|
| 🔸 **直接在主库** | `主库服务器` | `小表、维护窗口` | `直接影响主库性能` |
| 🔸 **test-on-replica** | `从库服务器` | `测试验证` | `仅影响测试从库` |
| 🔸 **migrate-on-replica** | `从库服务器` | `生产迁移` | `从库迁移后切换` |

### 2.2 部署架构示例


**🏗️ 典型主从环境**
```
主从复制拓扑：
┌─────────────┐
│   主库       │ ─┐
│  (Master)   │  │
└─────────────┘  │  binlog复制
                 │
                 ├─> ┌─────────────┐
                 │   │   从库1      │ ← gh-ost测试
                 │   │ (Slave-1)   │
                 │   └─────────────┘
                 │
                 └─> ┌─────────────┐
                     │   从库2      │ ← gh-ost迁移
                     │ (Slave-2)   │
                     └─────────────┘
```

**🔧 部署环境要求**
```bash
# 主库配置要求
server-id = 1
log-bin = mysql-bin
binlog-format = ROW  # 必须是ROW格式

# 从库配置要求
server-id = 2  # 不同于主库
relay-log = relay-bin
read-only = 1  # 建议设置只读
```

### 2.3 网络连接配置


**🌐 连接参数配置**
```bash
# 连接主库
--host=主库IP --port=3306 --user=gh_ost --password=密码

# 指定从库（用于检查复制状态）
--replica-server-id=从库server-id

# 复制相关配置
--max-lag-millis=1500  # 最大复制延迟（毫秒）
--chunk-size=1000      # 每次处理行数
```

---

## 3. 📡 复制拓扑支持详解


### 3.1 支持的复制拓扑


**🔸 简单主从复制**
```
单主单从：
Master ──────> Slave
最简单的复制结构，gh-ost完全支持
```

**🔸 一主多从复制**
```
一主多从：
        Slave-1
       /
Master ────── Slave-2
       \
        Slave-3

gh-ost可以选择任意从库进行操作
```

**🔸 级联复制**
```
级联复制：
Master ──> Slave-1 ──> Slave-2 ──> Slave-3

gh-ost支持多级复制环境
```

### 3.2 拓扑发现机制


**🔍 自动发现功能**
gh-ost会自动检测和分析复制拓扑：

```sql
-- gh-ost执行的检查SQL
SHOW SLAVE STATUS;  -- 检查当前服务器的从库状态
SHOW MASTER STATUS; -- 检查当前服务器的主库状态
SHOW PROCESSLIST;   -- 检查复制线程状态
```

**💡 拓扑检查示例**
```bash
# 让gh-ost自动发现拓扑
gh-ost \
  --host=从库IP \
  --discover-replica-host \  # 自动发现复制关系
  --database=test \
  --table=users \
  --execute
```

### 3.3 复制拓扑验证


**✅ 健康检查项目**
```
🔸 复制连接状态：IO线程和SQL线程是否正常运行
🔸 复制延迟检查：延迟是否在可接受范围内  
🔸 binlog格式验证：是否为ROW格式
🔸 server-id唯一性：各节点server-id是否唯一
🔸 权限完整性：复制用户权限是否足够
```

---

## 4. 🧪 test-on-replica测试模式


### 4.1 test-on-replica模式概述


**🎯 什么是test-on-replica**
这是一个**安全的测试模式**，让你可以在从库上安全地测试gh-ost迁移：
- 在从库上创建ghost表和触发器
- 模拟完整的迁移过程
- **不会影响主库**和生产数据
- 测试完成后自动清理

### 4.2 test-on-replica工作流程


**🔄 详细执行步骤**
```
测试模式流程图：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  连接从库    │ -> │  创建ghost表 │ -> │  复制数据    │
└─────────────┘    └─────────────┘    └─────────────┘
       |                   |                   |
       v                   v                   v
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  验证复制    │ -> │  模拟迁移    │ -> │  自动清理    │
└─────────────┘    └─────────────┘    └─────────────┘
```

**📝 具体操作命令**
```bash
# test-on-replica模式命令
gh-ost \
  --host=从库IP \
  --port=3306 \
  --user=gh_ost \
  --password=密码 \
  --database=test \
  --table=users \
  --test-on-replica \     # 启用测试模式
  --serve-socket-file=/tmp/gh-ost.sock \
  --execute
```

### 4.3 测试模式的验证内容


**🔍 测试验证项目**
```
1. 表结构兼容性：新表结构是否正确创建
2. 数据复制准确性：数据是否完整复制
3. 触发器功能：增量数据是否正确同步
4. 性能影响评估：对从库性能的影响程度
5. 复制延迟控制：是否造成过大的复制延迟
```

### 4.4 测试结果分析


**📊 测试输出信息**
```
2025-09-11 10:30:00 INFO test-on-replica: 开始测试模式
2025-09-11 10:30:05 INFO 创建ghost表: _users_gho
2025-09-11 10:30:10 INFO 创建触发器: 3个触发器已创建
2025-09-11 10:30:15 INFO 开始数据复制: 预计100万行
2025-09-11 10:35:20 INFO 复制完成: 100万行已复制
2025-09-11 10:35:25 INFO 测试成功: 清理临时表和触发器
```

**✅ 成功标准**
- ghost表数据行数与原表一致
- 数据内容完全相同
- 没有复制错误或异常
- 复制延迟控制在设定范围内

---

## 5. 🔄 migrate-on-replica迁移模式


### 5.1 migrate-on-replica模式详解


**🎯 什么是migrate-on-replica**
这是**生产环境推荐的迁移模式**：
- 在从库上执行实际的表结构迁移
- 完成后停止复制，提升从库为新主库
- 或者将从库重新配置到主库进行最终同步

**💡 核心优势**
```
🔸 降低主库压力：迁移过程不影响主库性能
🔸 可以回滚：迁移失败时主库数据未受影响  
🔸 验证安全：可以先验证从库迁移结果
🔸 业务连续：通过主从切换实现无缝迁移
```

### 5.2 migrate-on-replica工作原理


**🔧 详细工作流程**
```
迁移模式流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  在从库迁移  │ -> │  停止复制    │ -> │  验证数据    │
└─────────────┘    └─────────────┘    └─────────────┘
       |                   |                   |
       v                   v                   v
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  主从切换    │ -> │  应用切换    │ -> │  完成迁移    │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 5.3 migrate-on-replica命令详解


**📝 基础迁移命令**
```bash
# migrate-on-replica基础用法
gh-ost \
  --host=从库IP \
  --port=3306 \
  --user=gh_ost \
  --password=密码 \
  --database=production \
  --table=large_table \
  --migrate-on-replica \          # 在从库上迁移
  --chunk-size=2000 \             # 每批处理行数
  --max-lag-millis=2000 \         # 最大复制延迟
  --serve-socket-file=/tmp/gh-ost.sock \
  --execute
```

**🔧 高级配置选项**
```bash
# 带更多配置的完整命令
gh-ost \
  --host=replica.example.com \
  --port=3306 \
  --user=gh_ost \
  --password=secure_password \
  --database=ecommerce \
  --table=orders \
  --migrate-on-replica \
  --assume-rbr \                   # 假定ROW格式
  --cut-over=default \             # 切换方式
  --exact-rowcount \               # 精确行数计算
  --concurrent-rowcount \          # 并发计算行数
  --default-retries=120 \          # 默认重试次数
  --panic-flag-file=/tmp/panic \   # 紧急停止文件
  --postpone-cut-over-flag-file=/tmp/postpone \ # 延迟切换文件
  --serve-socket-file=/tmp/gh-ost.sock \
  --execute
```

### 5.4 迁移后的后续操作


**🔄 主从切换步骤**
```bash
# 步骤1：停止从库复制（在从库执行）
STOP SLAVE;

# 步骤2：记录从库位置
SHOW MASTER STATUS;

# 步骤3：应用切换到新的主库（从库）
# 修改应用配置，指向新的数据库

# 步骤4：配置新的复制关系（可选）
# 将原主库配置为新主库的从库
```

---

## 6. 📄 复制格式要求与检查


### 6.1 binlog格式要求


**🔸 ROW格式的重要性**
gh-ost **必须要求** binlog格式为ROW，这不是可选项：
- **ROW格式**：记录每行数据的实际变化
- **STATEMENT格式**：记录执行的SQL语句（gh-ost不支持）
- **MIXED格式**：混合模式（gh-ost不推荐）

```sql
-- 检查当前binlog格式
SHOW VARIABLES LIKE 'binlog_format';

-- 设置ROW格式（需要重启MySQL）
SET GLOBAL binlog_format = 'ROW';
```

### 6.2 assume-rbr参数详解


**🎯 什么是assume-rbr**
`assume-rbr`告诉gh-ost"相信我，binlog格式就是ROW"：
```bash
# 使用assume-rbr参数
gh-ost \
  --assume-rbr \     # 假定binlog格式为ROW
  ...其他参数
```

**💡 使用场景**
```
✅ 推荐使用情况：
- 确信binlog格式已正确配置为ROW
- 想要跳过格式检查以提高启动速度
- 在大规模环境中减少检查开销

⚠️ 注意事项：
- 如果binlog不是ROW格式，迁移会失败
- 建议先手动确认格式再使用此参数
```

### 6.3 binlog格式检查机制


**🔍 自动检查过程**
```sql
-- gh-ost执行的检查SQL序列
SHOW VARIABLES LIKE 'binlog_format';
SHOW VARIABLES LIKE 'log_bin';
SHOW MASTER STATUS;
SHOW SLAVE STATUS;  -- 如果是从库
```

**📊 检查结果处理**
```
检查结果处理逻辑：
┌─────────────────┐    Yes    ┌─────────────────┐
│ binlog=ROW?     │ ────────> │ 继续执行        │
└─────────────────┘           └─────────────────┘
         │ No
         v
┌─────────────────┐    Yes    ┌─────────────────┐
│ assume-rbr=true?│ ────────> │ 跳过检查        │
└─────────────────┘           └─────────────────┘
         │ No
         v
┌─────────────────┐
│ 报错并退出      │
└─────────────────┘
```

---

## 7. 👤 复制用户权限配置


### 7.1 必需的用户权限


**🔸 复制用户权限清单**
gh-ost需要一个具有足够权限的数据库用户：

```sql
-- 创建gh-ost专用用户
CREATE USER 'gh_ost'@'%' IDENTIFIED BY 'secure_password';

-- 授予必需权限
GRANT SELECT, INSERT, UPDATE, DELETE ON *.* TO 'gh_ost'@'%';
GRANT CREATE, DROP, ALTER, INDEX ON *.* TO 'gh_ost'@'%';
GRANT TRIGGER ON *.* TO 'gh_ost'@'%';
GRANT REPLICATION SLAVE ON *.* TO 'gh_ost'@'%';
GRANT REPLICATION CLIENT ON *.* TO 'gh_ost'@'%';

-- 刷新权限
FLUSH PRIVILEGES;
```

### 7.2 权限详解


**📋 各权限用途说明**

| 权限 | **用途** | **必需性** |
|------|---------|-----------|
| `SELECT` | `读取原表数据` | `必需` |
| `INSERT` | `向ghost表插入数据` | `必需` |
| `UPDATE/DELETE` | `处理增量变更` | `必需` |
| `CREATE/DROP` | `创建和删除ghost表` | `必需` |
| `ALTER` | `修改表结构` | `必需` |
| `TRIGGER` | `创建和删除触发器` | `必需` |
| `REPLICATION SLAVE` | `读取binlog信息` | `必需` |
| `REPLICATION CLIENT` | `查看复制状态` | `必需` |

### 7.3 权限安全配置


**🔒 安全最佳实践**
```sql
-- 1. 限制主机访问
CREATE USER 'gh_ost'@'192.168.1.%' IDENTIFIED BY 'password';

-- 2. 限制数据库访问（如果可能）
GRANT SELECT, INSERT, UPDATE, DELETE ON production.* TO 'gh_ost'@'192.168.1.%';

-- 3. 设置强密码
ALTER USER 'gh_ost'@'192.168.1.%' IDENTIFIED BY 'Very_Secure_Password_2025!';

-- 4. 定期轮换密码
ALTER USER 'gh_ost'@'192.168.1.%' IDENTIFIED BY 'New_Password_2025!';
```

---

## 8. 🏥 复制健康检查机制


### 8.1 复制状态监控


**🔍 健康检查项目**
gh-ost会持续监控复制健康状态：

```sql
-- 主要检查的复制指标
SHOW SLAVE STATUS\G

-- 关键指标解读：
Slave_IO_Running: Yes      -- IO线程状态
Slave_SQL_Running: Yes     -- SQL线程状态  
Seconds_Behind_Master: 0   -- 复制延迟秒数
Last_Error:               -- 最后的错误信息
```

### 8.2 复制延迟控制


**⏱️ 延迟阈值设置**
```bash
# 设置最大允许的复制延迟
gh-ost \
  --max-lag-millis=1500 \    # 最大延迟1.5秒
  --replication-lag-query="SELECT COALESCE(SUM(delay),0) FROM my_lag_table" \
  ...其他参数
```

**💡 延迟检查逻辑**
```
延迟检查流程：
┌─────────────────┐    延迟 > 阈值    ┌─────────────────┐
│ 检查复制延迟     │ ───────────────> │ 暂停数据复制     │
└─────────────────┘                  └─────────────────┘
         │                                    │
         │ 延迟 <= 阈值                        │ 等待延迟降低
         v                                    │
┌─────────────────┐    延迟恢复正常    ┌─────────────────┐
│ 继续数据复制     │ <──────────────── │ 持续监控延迟     │
└─────────────────┘                  └─────────────────┘
```

### 8.3 健康检查配置


**🔧 监控参数设置**
```bash
# 完整的健康检查配置
gh-ost \
  --max-lag-millis=2000 \              # 最大复制延迟
  --replication-lag-query="SHOW SLAVE STATUS" \
  --heartbeat-interval-millis=100 \    # 心跳检查间隔
  --nice-ratio=0.5 \                   # CPU使用限制
  --throttle-control-replicas="replica1:3306,replica2:3306" \
  ...其他参数
```

---

## 9. ⚠️ 复制异常处理策略


### 9.1 常见复制异常


**🚨 典型异常场景**

| 异常类型 | **症状** | **影响** | **处理策略** |
|---------|---------|---------|-------------|
| `复制延迟过大` | `Seconds_Behind_Master > 阈值` | `数据不一致` | `暂停迁移，等待恢复` |
| `IO线程停止` | `Slave_IO_Running: No` | `无法接收binlog` | `检查网络和权限` |
| `SQL线程停止` | `Slave_SQL_Running: No` | `无法执行SQL` | `检查错误日志` |
| `binlog格式错误` | `binlog_format != ROW` | `无法正常工作` | `修改配置重启` |

### 9.2 自动异常处理


**🔄 异常处理机制**
```bash
# 异常处理相关参数
gh-ost \
  --max-lag-millis=1500 \              # 延迟阈值
  --replication-lag-query="..." \      # 自定义延迟检查
  --throttle-control-replicas="..." \  # 控制复制节点
  --panic-flag-file=/tmp/panic \       # 紧急停止文件
  --default-retries=60 \               # 默认重试次数
  ...
```

### 9.3 手动干预机制


**🛠️ 紧急处理方法**
```bash
# 方法1：创建panic文件紧急停止
touch /tmp/panic

# 方法2：通过socket控制
echo "panic" | socat - /tmp/gh-ost.sock

# 方法3：直接终止进程（不推荐）
kill -TERM gh-ost进程ID
```

**📝 异常恢复步骤**
```
1. 分析异常原因：检查MySQL错误日志
2. 修复根本问题：解决网络、权限或配置问题  
3. 清理临时对象：删除ghost表和触发器
4. 重新启动迁移：从上次断点继续或重新开始
```

---

## 10. 🌍 多级复制支持


### 10.1 多级复制架构


**🏗️ 典型多级复制结构**
```
多级复制拓扑：
┌─────────────┐
│   主库       │ 
│  (Master)   │
└─────┬───────┘
      │ binlog
      v
┌─────────────┐        ┌─────────────┐
│   从库1      │ ────>  │   从库1-1    │ ← gh-ost在这里运行
│ (Slave-1)   │ relay  │ (Slave-1-1) │
└─────────────┘  log   └─────────────┘
      │
      v
┌─────────────┐
│   从库2      │
│ (Slave-2)   │
└─────────────┘
```

### 10.2 多级复制配置


**🔧 配置要点**
```sql
-- 各级节点的配置要求
-- 主库配置
server-id = 1
log-bin = mysql-bin
binlog-format = ROW

-- 中间从库配置（既是从库又是主库）
server-id = 2
log-bin = mysql-bin        # 必须开启binlog
log-slave-updates = 1      # 重要：记录从主库复制的更新
binlog-format = ROW

-- 最终从库配置
server-id = 3
relay-log = relay-bin
```

### 10.3 多级环境中的gh-ost使用


**📝 多级复制迁移示例**
```bash
# 在最底层从库运行gh-ost
gh-ost \
  --host=最底层从库IP \
  --port=3306 \
  --user=gh_ost \
  --password=密码 \
  --database=production \
  --table=large_table \
  --migrate-on-replica \           # 在从库迁移
  --assume-rbr \                   # 假定ROW格式
  --max-lag-millis=3000 \          # 多级复制延迟更大
  --chunk-size=500 \               # 减小批次大小
  --throttle-control-replicas="中间从库:3306" \  # 控制中间节点
  --execute
```

**⚠️ 多级复制注意事项**
```
🔸 延迟累积：每一级都会增加复制延迟
🔸 配置复杂：中间节点需要特殊配置
🔸 故障传播：上级故障会影响所有下级
🔸 监控困难：需要监控多个复制链路
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 主从复制：MySQL的数据同步机制，主库写入从库复制
🔸 测试模式：test-on-replica，在从库安全测试迁移过程
🔸 迁移模式：migrate-on-replica，在从库执行实际迁移
🔸 ROW格式：binlog必须使用ROW格式，记录行级变化
🔸 复制延迟：主从之间的数据同步时间差，需要控制
🔸 权限配置：gh-ost用户需要足够的复制和操作权限
```

### 11.2 关键理解要点


**🔹 为什么选择在从库迁移**
```
性能保护：避免影响主库的业务性能
风险控制：迁移失败不影响主库数据
灵活测试：可以先在从库验证迁移效果
业务连续：通过主从切换实现无停机迁移
```

**🔹 复制格式的重要性**
```
ROW格式记录：每行数据的具体变化
STATEMENT格式：只记录SQL语句（不支持）
为什么需要ROW：gh-ost需要知道具体哪些行发生变化
```

**🔹 复制延迟控制原理**
```
监控机制：持续检查Seconds_Behind_Master
阈值控制：超过阈值自动暂停迁移
自动恢复：延迟降低后自动继续迁移
业务保护：避免因迁移导致数据不一致
```

### 11.3 实际应用指导


**📊 部署模式选择**
```
小表迁移（<100万行）：
→ 可以直接在主库迁移
→ 迁移时间短，影响可控

大表迁移（>100万行）：
→ 推荐使用migrate-on-replica
→ 降低主库压力，提高成功率

测试验证场景：
→ 使用test-on-replica模式
→ 验证迁移效果和性能影响
```

**🔧 参数配置建议**
```
网络良好环境：
--max-lag-millis=1500
--chunk-size=2000

网络较差环境：
--max-lag-millis=3000  
--chunk-size=1000

高负载环境：
--nice-ratio=0.5
--throttle-control-replicas配置
```

### 11.4 故障排查指南


**🔍 常见问题和解决方案**
```
问题1：binlog格式错误
现象：启动时报错"binlog format is not ROW"
解决：修改my.cnf设置binlog_format=ROW，重启MySQL

问题2：权限不足
现象：无法创建ghost表或触发器
解决：检查用户权限，补充缺失的权限

问题3：复制延迟过大
现象：迁移频繁暂停等待
解决：增大max-lag-millis或优化复制性能

问题4：从库配置错误
现象：无法检测到复制关系
解决：检查server-id设置和复制配置
```

**核心记忆**：
- gh-ost在主从环境中可以更安全地迁移表结构
- test-on-replica用于测试，migrate-on-replica用于生产  
- binlog格式必须是ROW，复制延迟需要控制
- 复制用户需要足够权限，健康检查机制保证稳定性