---
title: 17、创建索引语法
---
## 📚 目录

1. [索引创建基础概念](#1-索引创建基础概念)
2. [CREATE INDEX语法详解](#2-create-index语法详解)
3. [ALTER TABLE添加索引](#3-alter-table添加索引)
4. [索引类型与选项配置](#4-索引类型与选项配置)
5. [在线索引创建机制](#5-在线索引创建机制)
6. [索引创建监控与故障处理](#6-索引创建监控与故障处理)
7. [权限与最佳实践](#7-权限与最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 索引创建基础概念


### 1.1 什么是索引DDL操作


**DDL含义**：Data Definition Language（数据定义语言），用于定义和管理数据库结构的SQL语句。

**索引DDL就是**：用SQL语句来创建、修改、删除数据库表的索引结构。

```
简单理解：
就像给书做目录一样
- 创建索引 = 给书加目录
- 修改索引 = 重新整理目录
- 删除索引 = 撕掉目录
```

### 1.2 为什么需要索引DDL


**解决的核心问题**：

| 问题场景 | **没有索引的后果** | **创建索引后** |
|---------|-------------------|---------------|
| 🔍 **数据查询** | `扫描整张表，慢如蜗牛` | `直接定位，秒级响应` |
| 📊 **数据排序** | `每次都要重新排序` | `索引本身有序，快速返回` |
| 🔗 **表关联** | `嵌套循环，性能糟糕` | `高效关联，性能提升` |

### 1.3 索引创建的两种主要方式


```
方式对比：

CREATE INDEX 方式：
✅ 专门用于创建索引
✅ 语法清晰，参数丰富
✅ 支持更多高级选项

ALTER TABLE 方式：
✅ 可以同时修改表结构
✅ 在建表后统一添加索引
✅ 适合批量操作
```

---

## 2. 📝 CREATE INDEX语法详解


### 2.1 基本语法结构


**标准语法格式**：
```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (column1[(length)] [ASC|DESC], column2[(length)] [ASC|DESC], ...)
[USING {BTREE | HASH}]
[ALGORITHM = {DEFAULT | INPLACE | COPY}]
[LOCK = {DEFAULT | NONE | SHARED | EXCLUSIVE}]
```

**语法解读**：
- `UNIQUE`：唯一索引，不允许重复值
- `FULLTEXT`：全文索引，用于文本搜索
- `SPATIAL`：空间索引，用于地理数据
- `index_name`：索引名称（自定义）
- `table_name`：要创建索引的表
- `column`：索引包含的字段
- `length`：索引长度（可选）
- `ASC/DESC`：排序方式（升序/降序）

### 2.2 基础索引创建示例


**单字段索引**：
```sql
-- 给用户表的邮箱字段创建索引
CREATE INDEX idx_user_email ON users(email);

-- 实际效果：查询邮箱时速度大幅提升
SELECT * FROM users WHERE email = 'john@example.com';
-- 从全表扫描变成索引查找
```

**复合索引（多字段）**：
```sql
-- 给订单表创建复合索引
CREATE INDEX idx_order_user_date ON orders(user_id, order_date);

-- 这个索引可以优化以下查询：
SELECT * FROM orders WHERE user_id = 123 AND order_date = '2024-01-15';
SELECT * FROM orders WHERE user_id = 123;  -- 也能用到索引
```

### 2.3 特殊类型索引创建


**唯一索引**：
```sql
-- 确保用户名不重复
CREATE UNIQUE INDEX idx_username ON users(username);

-- 如果尝试插入重复用户名会报错
INSERT INTO users(username) VALUES('admin');  -- 第二次插入会失败
```

**全文索引**：
```sql
-- 为文章内容创建全文索引
CREATE FULLTEXT INDEX idx_article_content ON articles(title, content);

-- 支持全文搜索
SELECT * FROM articles WHERE MATCH(title, content) AGAINST('MySQL索引');
```

### 2.4 索引命名规范


**推荐命名规则**：
```sql
-- 单字段索引：idx_表名_字段名
CREATE INDEX idx_users_email ON users(email);

-- 复合索引：idx_表名_字段1_字段2
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);

-- 唯一索引：uk_表名_字段名 (uk = unique key)
CREATE UNIQUE INDEX uk_users_phone ON users(phone);

-- 全文索引：ft_表名_字段名 (ft = fulltext)
CREATE FULLTEXT INDEX ft_articles_content ON articles(content);
```

**为什么要规范命名**：
- 📋 **便于管理**：一看名字就知道索引作用
- 🔍 **便于维护**：快速定位需要的索引
- 👥 **团队协作**：统一标准，减少沟通成本

---

## 3. 🔄 ALTER TABLE添加索引


### 3.1 ALTER TABLE基本语法


**基础语法**：
```sql
ALTER TABLE table_name 
ADD INDEX index_name (column1, column2, ...);

-- 或者使用KEY关键字（INDEX和KEY等价）
ALTER TABLE table_name 
ADD KEY index_name (column1, column2, ...);
```

### 3.2 不同类型索引的添加方式


**普通索引**：
```sql
-- 添加单字段索引
ALTER TABLE users ADD INDEX idx_age (age);

-- 添加复合索引
ALTER TABLE orders ADD INDEX idx_status_date (status, created_at);
```

**唯一索引**：
```sql
-- 添加唯一索引
ALTER TABLE users ADD UNIQUE INDEX uk_email (email);

-- 或者使用UNIQUE KEY
ALTER TABLE users ADD UNIQUE KEY uk_phone (phone);
```

**主键索引**：
```sql
-- 添加主键（自动创建主键索引）
ALTER TABLE users ADD PRIMARY KEY (id);

-- 复合主键
ALTER TABLE user_roles ADD PRIMARY KEY (user_id, role_id);
```

### 3.3 批量添加索引


**一次添加多个索引**：
```sql
ALTER TABLE products 
ADD INDEX idx_category (category_id),
ADD INDEX idx_price (price),
ADD UNIQUE INDEX uk_sku (sku),
ADD FULLTEXT INDEX ft_description (description);
```

**实际应用场景**：
```sql
-- 电商系统商品表索引优化
ALTER TABLE products 
ADD INDEX idx_category_brand (category_id, brand_id),    -- 分类+品牌查询
ADD INDEX idx_price_range (price),                      -- 价格范围查询
ADD INDEX idx_status (status),                          -- 商品状态过滤
ADD INDEX idx_created (created_at);                     -- 时间排序
```

### 3.4 CREATE INDEX vs ALTER TABLE对比


| 特性 | **CREATE INDEX** | **ALTER TABLE** |
|------|------------------|-----------------|
| 🎯 **主要用途** | `专门创建索引` | `修改表结构，顺带加索引` |
| 📝 **语法复杂度** | `相对简单，专注索引` | `功能更全面` |
| ⚡ **执行效率** | `一样的，底层实现相同` | `一样的，底层实现相同` |
| 🔧 **批量操作** | `不支持` | `支持一次加多个索引` |
| 📚 **可读性** | `意图明确` | `适合表结构整体调整` |

---

## 4. ⚙️ 索引类型与选项配置


### 4.1 索引存储引擎选择


**BTREE索引（默认）**：
```sql
-- 明确指定BTREE（通常可以省略，因为是默认值）
CREATE INDEX idx_user_age ON users(age) USING BTREE;
```

**BTREE适用场景**：
- ✅ **范围查询**：`WHERE age BETWEEN 18 AND 30`
- ✅ **排序操作**：`ORDER BY created_at`
- ✅ **前缀匹配**：`WHERE name LIKE 'John%'`

**HASH索引**：
```sql
-- 创建HASH索引（仅Memory引擎支持）
CREATE INDEX idx_session_id ON sessions(session_id) USING HASH;
```

**HASH适用场景**：
- ✅ **等值查询**：`WHERE id = 123`
- ❌ **不支持范围**：不能用于`BETWEEN`、`>`、`<`
- ❌ **不支持排序**：不能用于`ORDER BY`

### 4.2 索引长度设置


**为什么需要设置索引长度**：
```
长文本字段的问题：
如果varchar(500)的字段不设置长度，整个500字符都会被索引
→ 索引文件巨大
→ 查询效率反而下降
→ 内存占用过多
```

**索引长度设置示例**：
```sql
-- 邮箱字段，通常前20个字符就能区分
CREATE INDEX idx_email ON users(email(20));

-- 文章标题，前50个字符通常够用
CREATE INDEX idx_title ON articles(title(50));

-- 查看索引选择性，帮助确定合适长度
SELECT 
  COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) as selectivity_10,
  COUNT(DISTINCT LEFT(email, 20)) / COUNT(*) as selectivity_20,
  COUNT(DISTINCT LEFT(email, 30)) / COUNT(*) as selectivity_30
FROM users;
```

### 4.3 索引排序方向


**升序降序混合索引**：
```sql
-- 订单按时间降序、金额升序排列
CREATE INDEX idx_order_time_amount ON orders(order_date DESC, amount ASC);

-- 这个索引可以优化：
SELECT * FROM orders ORDER BY order_date DESC, amount ASC;
```

**注意事项**：
> ⚠️ **MySQL限制**：同一个索引中，要么都是ASC，要么都是DESC，混合方向的索引在某些版本中支持有限。

### 4.4 索引选项详解


**完整选项示例**：
```sql
CREATE INDEX idx_product_search 
ON products(category_id, price, name(20))
USING BTREE
COMMENT '商品搜索复合索引';
```

**各选项说明**：
- `USING BTREE`：指定索引类型
- `COMMENT`：索引注释，便于维护
- `INVISIBLE`：不可见索引（MySQL 8.0+）
- `VISIBLE`：可见索引（默认）

---

## 5. 🚀 在线索引创建机制


### 5.1 什么是在线索引创建


**传统方式的问题**：
```
老版本MySQL创建索引：
1. 锁定整张表
2. 阻塞所有读写操作
3. 用户体验极差
4. 生产环境不敢随便加索引
```

**在线创建的优势**：
```
MySQL 5.6+在线DDL：
1. 不锁定表，允许并发读写
2. 索引创建过程中业务正常运行
3. 大大降低了索引维护成本
```

### 5.2 算法选择详解


**ALGORITHM参数说明**：

| 算法类型 | **工作方式** | **并发性** | **适用场景** |
|---------|------------|-----------|-------------|
| 🔄 **INPLACE** | `原地修改，不复制表` | `允许并发读写` | `推荐使用，性能最佳` |
| 📋 **COPY** | `复制整张表` | `只允许读，阻塞写` | `老版本兼容` |
| ⚡ **DEFAULT** | `MySQL自动选择` | `取决于具体操作` | `让MySQL决定` |

**算法选择示例**：
```sql
-- 推荐：使用INPLACE算法
CREATE INDEX idx_user_email ON users(email) 
ALGORITHM = INPLACE;

-- 强制使用COPY算法（一般不推荐）
CREATE INDEX idx_user_phone ON users(phone) 
ALGORITHM = COPY;
```

### 5.3 锁定级别控制


**LOCK参数详解**：

```sql
-- 无锁模式：最大并发性
CREATE INDEX idx_order_status ON orders(status) 
ALGORITHM = INPLACE, LOCK = NONE;

-- 共享锁：允许读，阻塞写
CREATE INDEX idx_product_name ON products(name) 
ALGORITHM = INPLACE, LOCK = SHARED;

-- 排他锁：阻塞所有操作（不推荐）
CREATE INDEX idx_user_level ON users(level) 
ALGORITHM = INPLACE, LOCK = EXCLUSIVE;
```

**实际应用建议**：
```sql
-- 生产环境推荐配置
CREATE INDEX idx_critical_field ON important_table(field) 
ALGORITHM = INPLACE, 
LOCK = NONE,
COMMENT = '业务关键索引，在线创建';
```

### 5.4 在线DDL限制与注意事项


**不支持在线操作的情况**：
- 🚫 **创建全文索引**：需要锁表
- 🚫 **修改字段类型**：可能需要重建表
- 🚫 **某些存储引擎**：如MyISAM不支持

**监控在线DDL进程**：
```sql
-- 查看正在执行的DDL操作
SELECT * FROM information_schema.PROCESSLIST 
WHERE COMMAND = 'Query' AND INFO LIKE '%INDEX%';

-- 查看DDL进度（MySQL 8.0+）
SELECT 
  EVENT_NAME,
  WORK_COMPLETED,
  WORK_ESTIMATED
FROM performance_schema.events_stages_current
WHERE EVENT_NAME LIKE '%alter%';
```

---

## 6. 📊 索引创建监控与故障处理


### 6.1 创建过程监控


**监控DDL执行状态**：
```sql
-- 查看当前DDL操作
SHOW PROCESSLIST;

-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G

-- 监控临时表空间使用
SELECT 
  tablespace_name,
  file_name,
  total_extents,
  free_extents,
  (total_extents - free_extents) * extent_size / 1024 / 1024 as used_mb
FROM information_schema.FILES 
WHERE tablespace_name LIKE '%temp%';
```

### 6.2 临时表空间管理


**为什么需要临时表空间**：
```
索引创建过程：
1. MySQL需要对数据进行排序
2. 排序过程需要临时存储空间
3. 如果内存不够，会使用磁盘临时表空间
4. 大表创建索引可能需要很多临时空间
```

**临时表空间配置**：
```sql
-- 查看临时表空间配置
SHOW VARIABLES LIKE '%tmp%';

-- 关键参数：
-- tmp_table_size：内存临时表大小
-- max_heap_table_size：HEAP表最大大小
-- tmpdir：临时文件目录
```

### 6.3 创建失败常见原因


**磁盘空间不足**：
```sql
-- 检查表空间大小
SELECT 
  table_schema,
  table_name,
  ROUND(data_length/1024/1024, 2) as data_mb,
  ROUND(index_length/1024/1024, 2) as index_mb
FROM information_schema.tables 
WHERE table_name = 'your_table';

-- 解决方案：
-- 1. 清理磁盘空间
-- 2. 扩展磁盘容量
-- 3. 调整tmpdir到空间充足的目录
```

**内存不足**：
```sql
-- 检查内存使用
SHOW VARIABLES LIKE '%buffer_pool_size%';

-- 优化建议：
-- 1. 增加innodb_buffer_pool_size
-- 2. 在业务低峰期创建索引
-- 3. 分批创建多个索引
```

**锁等待超时**：
```sql
-- 查看锁等待情况
SELECT * FROM information_schema.INNODB_LOCKS;
SELECT * FROM information_schema.INNODB_LOCK_WAITS;

-- 解决方案：
-- 1. 选择业务低峰期操作
-- 2. 使用ALGORITHM=INPLACE, LOCK=NONE
-- 3. 增加lock_wait_timeout参数
```

### 6.4 故障恢复处理


**创建中断后的处理**：
```sql
-- 检查是否有临时文件残留
SHOW TABLES LIKE '#sql%';

-- 检查表状态
CHECK TABLE table_name;

-- 如果表损坏，进行修复
REPAIR TABLE table_name;

-- 重新创建索引
CREATE INDEX index_name ON table_name(column);
```

---

## 7. 🔐 权限与最佳实践


### 7.1 权限要求检查


**创建索引需要的权限**：
```sql
-- 检查当前用户权限
SHOW GRANTS;

-- 需要的最小权限
GRANT INDEX ON database_name.table_name TO 'username'@'host';

-- 或者ALTER权限也可以
GRANT ALTER ON database_name.table_name TO 'username'@'host';
```

**权限验证示例**：
```sql
-- 测试是否有创建索引权限
CREATE INDEX test_idx ON test_table(test_col);

-- 如果权限不足会报错：
-- ERROR 1142 (42000): INDEX command denied to user
```

### 7.2 生产环境最佳实践


**索引创建检查清单**：

```
创建前检查：
☑️ 确认业务低峰期
☑️ 检查磁盘空间充足
☑️ 确认临时表空间大小
☑️ 评估索引创建时间
☑️ 准备回滚方案

创建时监控：
☑️ 监控系统负载
☑️ 检查锁等待情况
☑️ 观察临时空间使用
☑️ 记录创建时间

创建后验证：
☑️ 检查索引是否生效
☑️ 验证查询性能提升
☑️ 确认无业务影响
☑️ 更新监控指标
```

### 7.3 索引创建性能优化


**大表索引创建策略**：
```sql
-- 1. 调整相关参数
SET SESSION innodb_sort_buffer_size = 64 * 1024 * 1024;  -- 64MB
SET SESSION read_buffer_size = 2 * 1024 * 1024;          -- 2MB

-- 2. 使用最优算法
CREATE INDEX idx_big_table_col ON big_table(column) 
ALGORITHM = INPLACE, 
LOCK = NONE;

-- 3. 分批创建（避免一次创建多个）
CREATE INDEX idx1 ON table(col1);
-- 等待完成后再创建下一个
CREATE INDEX idx2 ON table(col2);
```

### 7.4 索引维护自动化


**自动化脚本示例思路**：
```sql
-- 索引创建状态检查
SELECT 
  TABLE_SCHEMA,
  TABLE_NAME,
  INDEX_NAME,
  COLUMN_NAME,
  CARDINALITY
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME;

-- 可以封装成存储过程或者外部脚本
-- 实现批量索引管理
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 DDL操作本质：用SQL语句管理索引结构
🔸 两种创建方式：CREATE INDEX 和 ALTER TABLE ADD INDEX
🔸 索引类型选择：BTREE（默认）、HASH、FULLTEXT、SPATIAL
🔸 在线DDL优势：允许并发读写，不阻塞业务
🔸 监控与故障处理：关注空间、内存、锁等待问题
```

### 8.2 关键语法模板


**常用创建模板**：
```sql
-- 标准索引创建
CREATE INDEX idx_表名_字段 ON 表名(字段) 
ALGORITHM = INPLACE, LOCK = NONE;

-- 复合索引创建
CREATE INDEX idx_表名_字段1_字段2 ON 表名(字段1, 字段2) 
ALGORITHM = INPLACE, LOCK = NONE;

-- 唯一索引创建
CREATE UNIQUE INDEX uk_表名_字段 ON 表名(字段);
```

### 8.3 实际应用指导


**索引创建决策流程**：
```
1. 分析查询需求 → 确定需要索引的字段
2. 评估数据特征 → 选择合适的索引类型
3. 规划创建时机 → 选择业务低峰期
4. 配置创建参数 → ALGORITHM和LOCK选择
5. 监控创建过程 → 确保不影响业务
6. 验证创建效果 → 检查性能提升
```

**性能优化要点**：
- 🎯 **合理规划**：不要同时创建多个索引
- ⏰ **时机选择**：业务低峰期操作
- 📊 **资源监控**：关注CPU、内存、磁盘IO
- 🔧 **参数调优**：根据表大小调整相关参数

### 8.4 避免的常见错误


```
❌ 错误做法：
- 在业务高峰期创建索引
- 不监控创建过程
- 忽略临时空间需求
- 一次性创建多个索引

✅ 正确做法：
- 选择合适时机
- 实时监控状态
- 预留足够空间
- 逐个创建验证
```

**核心记忆**：
- DDL操作要谨慎，提前做好规划
- 在线创建是首选，INPLACE算法性能佳
- 监控很重要，空间内存要关注
- 权限要检查，最佳实践保平安