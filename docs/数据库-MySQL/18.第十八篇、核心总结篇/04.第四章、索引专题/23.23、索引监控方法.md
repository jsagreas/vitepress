---
title: 23、索引监控方法
---
## 📚 目录

1. [索引监控基础概念](#1-索引监控基础概念)
2. [SHOW INDEX命令详解](#2-SHOW-INDEX命令详解)
3. [INFORMATION_SCHEMA查询技术](#3-INFORMATION_SCHEMA查询技术)
4. [Performance Schema监控](#4-Performance-Schema监控)
5. [索引效率分析方法](#5-索引效率分析方法)
6. [未使用索引检测](#6-未使用索引检测)
7. [重复索引识别](#7-重复索引识别)
8. [索引健康检查体系](#8-索引健康检查体系)
9. [自动化监控方案](#9-自动化监控方案)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引监控基础概念


### 1.1 什么是索引监控


**🔍 索引监控定义**：
索引监控就像给数据库做"体检"，定期检查索引的使用情况、性能表现和健康状态，确保数据库查询效率保持在最佳水平。

**为什么需要监控索引？**
```
就像汽车需要定期保养一样，数据库索引也需要持续关注：

问题场景：
❌ 创建了索引但从不使用 → 浪费存储空间，拖慢写入速度
❌ 索引重复冗余 → 多个索引做同样的事，资源浪费
❌ 缺少必要索引 → 查询缓慢，用户体验差
❌ 索引碎片严重 → 性能逐渐下降

监控价值：
✅ 及时发现问题索引
✅ 优化查询性能
✅ 节省存储空间
✅ 提升整体数据库效率
```

### 1.2 索引监控的核心指标


**📊 关键监控维度**：

```
使用频率维度：
• 索引被查询使用的次数
• 哪些索引从不被使用
• 使用最频繁的热点索引

性能维度：
• 索引查找的平均耗时
• 索引扫描的行数比例
• 索引选择性（区分度）

空间维度：
• 索引占用的磁盘空间
• 索引文件的大小变化
• 碎片化程度

维护成本：
• 索引更新的开销
• 重复索引的数量
• 冗余索引识别
```

### 1.3 MySQL索引监控的工具体系


**🛠️ MySQL内置监控工具**：

```
层级结构：
┌─────────────────────────────┐
│        应用层监控           │ ← 业务SQL性能分析
├─────────────────────────────┤
│    Performance Schema       │ ← 实时性能数据
├─────────────────────────────┤
│   INFORMATION_SCHEMA        │ ← 元数据查询
├─────────────────────────────┤
│      SHOW 命令系列          │ ← 基础状态查看
└─────────────────────────────┘

工具特点对比：
SHOW命令：简单直接，适合快速检查
INFORMATION_SCHEMA：结构化查询，便于编程
Performance Schema：详细性能数据，适合深度分析
```

---

## 2. 💻 SHOW INDEX命令详解


### 2.1 SHOW INDEX基础用法


**基本语法和含义**：
```sql
-- 查看表的所有索引
SHOW INDEX FROM table_name;

-- 查看指定数据库的表索引
SHOW INDEX FROM database_name.table_name;
```

**🔍 输出字段详解**：

| 字段名 | 含义说明 | 实际意义 |
|--------|----------|----------|
| `Table` | 表名 | 索引所属的表 |
| `Non_unique` | 是否唯一 | 0=唯一索引，1=非唯一索引 |
| `Key_name` | 索引名称 | 索引的标识名 |
| `Seq_in_index` | 列在索引中的顺序 | 复合索引中的位置（1,2,3...） |
| `Column_name` | 列名 | 索引包含的列 |
| `Collation` | 排序方式 | A=升序，D=降序，NULL=无排序 |
| `Cardinality` | **基数** | **索引中唯一值的估算数量** |
| `Sub_part` | 前缀长度 | 使用列的前几个字符建索引 |
| `Packed` | 压缩信息 | 索引是否压缩 |
| `Null` | 是否允许NULL | YES=允许，''=不允许 |
| `Index_type` | 索引类型 | BTREE、HASH等 |

### 2.2 实际案例分析


**📝 实战示例**：

```sql
-- 示例：用户表索引检查
SHOW INDEX FROM users;

-- 典型输出解读：
+-------+------------+--------------+--------------+-------------+
| Table | Non_unique | Key_name     | Seq_in_index | Column_name |
+-------+------------+--------------+--------------+-------------+
| users |          0 | PRIMARY      |            1 | id          |
| users |          0 | uk_email     |            1 | email       |
| users |          1 | idx_age_city |            1 | age         |
| users |          1 | idx_age_city |            2 | city        |
| users |          1 | idx_name     |            1 | name        |
+-------+------------+--------------+--------------+-------------+

分析结果：
✅ PRIMARY：主键索引，正常
✅ uk_email：邮箱唯一索引，防重复
✅ idx_age_city：年龄+城市复合索引，适合范围查询
⚠️  idx_name：单列索引，需检查使用频率
```

### 2.3 索引基数分析


**🔢 Cardinality（基数）的重要性**：

```sql
-- 检查索引选择性
SHOW INDEX FROM users WHERE Key_name = 'idx_age';

/* 
基数含义：
- Cardinality = 50，表总行数 = 10000
- 选择性 = 50/10000 = 0.005 (很低，索引效果差)
- 平均每个值对应 200 行数据

选择性评估：
✅ 选择性 > 0.1：优秀索引
⚠️  选择性 0.01-0.1：一般索引  
❌ 选择性 < 0.01：低效索引，考虑删除
*/
```

**基数统计更新**：
```sql
-- 手动更新索引统计信息
ANALYZE TABLE users;

-- 检查更新后的基数
SHOW INDEX FROM users;
```

---

## 3. 🗂️ INFORMATION_SCHEMA查询技术


### 3.1 INFORMATION_SCHEMA概述


**什么是INFORMATION_SCHEMA？**
INFORMATION_SCHEMA就像MySQL的"档案室"，存储了数据库的所有元数据信息，包括表结构、索引信息、约束等。通过标准SQL查询这些信息，比SHOW命令更灵活。

### 3.2 索引信息查询


**📊 基础索引信息查询**：

```sql
-- 查询指定表的所有索引信息
SELECT 
    INDEX_NAME as '索引名',
    COLUMN_NAME as '列名',
    SEQ_IN_INDEX as '列顺序',
    NON_UNIQUE as '是否非唯一',
    INDEX_TYPE as '索引类型'
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND TABLE_NAME = 'users'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;
```

**🔍 索引大小统计查询**：

```sql
-- 查询各表索引占用空间
SELECT 
    TABLE_NAME as '表名',
    ROUND(INDEX_LENGTH/1024/1024, 2) as '索引大小(MB)',
    ROUND(DATA_LENGTH/1024/1024, 2) as '数据大小(MB)',
    ROUND(INDEX_LENGTH/(DATA_LENGTH+INDEX_LENGTH)*100, 2) as '索引占比(%)'
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'your_database'
  AND INDEX_LENGTH > 0
ORDER BY INDEX_LENGTH DESC;
```

### 3.3 重复索引检测查询


**🔄 识别重复索引**：

```sql
-- 检测可能重复的索引
SELECT 
    a.TABLE_NAME,
    a.INDEX_NAME as '索引1',
    b.INDEX_NAME as '索引2',
    a.COLUMN_NAME as '重复列'
FROM INFORMATION_SCHEMA.STATISTICS a
JOIN INFORMATION_SCHEMA.STATISTICS b ON (
    a.TABLE_SCHEMA = b.TABLE_SCHEMA 
    AND a.TABLE_NAME = b.TABLE_NAME
    AND a.COLUMN_NAME = b.COLUMN_NAME
    AND a.INDEX_NAME != b.INDEX_NAME
    AND a.SEQ_IN_INDEX = 1  -- 只检查第一列相同的情况
    AND b.SEQ_IN_INDEX = 1
)
WHERE a.TABLE_SCHEMA = 'your_database'
ORDER BY a.TABLE_NAME, a.COLUMN_NAME;
```

### 3.4 复合索引分析


**📈 复合索引覆盖度分析**：

```sql
-- 分析复合索引的列组合
SELECT 
    INDEX_NAME as '索引名',
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as '列组合',
    COUNT(*) as '列数量',
    MAX(SEQ_IN_INDEX) as '最大序号'
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND TABLE_NAME = 'users'
  AND INDEX_NAME != 'PRIMARY'
GROUP BY INDEX_NAME
HAVING COUNT(*) > 1  -- 只显示复合索引
ORDER BY COUNT(*) DESC;
```

---

## 4. ⚡ Performance Schema监控


### 4.1 Performance Schema简介


**什么是Performance Schema？**
Performance Schema是MySQL的"性能监控仪表盘"，实时收集数据库运行时的各种性能数据，包括索引使用情况、查询执行统计等。

**🔧 启用Performance Schema**：
```sql
-- 检查是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 启用相关监控项（需要重启MySQL）
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME LIKE '%table%io%';
```

### 4.2 索引使用统计


**📊 监控索引使用情况**：

```sql
-- 查看表级别的IO统计
SELECT 
    OBJECT_SCHEMA as '数据库',
    OBJECT_NAME as '表名',
    COUNT_READ as '读取次数',
    COUNT_WRITE as '写入次数',
    SUM_TIMER_READ/1000000000 as '读取时间(秒)',
    SUM_TIMER_WRITE/1000000000 as '写入时间(秒)'
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'your_database'
ORDER BY COUNT_READ DESC;
```

**🔍 索引访问模式分析**：

```sql
-- 查看索引使用的详细统计
SELECT 
    OBJECT_SCHEMA as '数据库',
    OBJECT_NAME as '表名', 
    INDEX_NAME as '索引名',
    COUNT_FETCH as '获取次数',
    COUNT_INSERT as '插入次数',
    COUNT_UPDATE as '更新次数',
    COUNT_DELETE as '删除次数',
    SUM_TIMER_FETCH/1000000000 as '获取耗时(秒)'
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
  AND COUNT_FETCH > 0
ORDER BY COUNT_FETCH DESC;
```

### 4.3 查询语句分析


**🔬 SQL语句性能统计**：

```sql
-- 分析最耗时的查询语句
SELECT 
    DIGEST_TEXT as 'SQL模板',
    COUNT_STAR as '执行次数',
    ROUND(AVG_TIMER_WAIT/1000000000, 2) as '平均耗时(秒)',
    ROUND(SUM_TIMER_WAIT/1000000000, 2) as '总耗时(秒)',
    SUM_ROWS_EXAMINED as '扫描行数',
    SUM_ROWS_SENT as '返回行数'
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'your_database'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

---

## 5. 📈 索引效率分析方法


### 5.1 索引选择性计算


**🧮 什么是索引选择性？**
索引选择性就是"区分度"，衡量索引能多大程度上缩小查询范围。选择性越高，索引效果越好。

**计算方法**：
```sql
-- 计算单列索引选择性
SELECT 
    COLUMN_NAME as '列名',
    COUNT(DISTINCT COLUMN_NAME) as '唯一值数量',
    COUNT(*) as '总行数',
    ROUND(COUNT(DISTINCT COLUMN_NAME)/COUNT(*), 4) as '选择性',
    CASE 
        WHEN COUNT(DISTINCT COLUMN_NAME)/COUNT(*) > 0.1 THEN '优秀'
        WHEN COUNT(DISTINCT COLUMN_NAME)/COUNT(*) > 0.01 THEN '一般'
        ELSE '较差'
    END as '评级'
FROM users
GROUP BY COLUMN_NAME;

-- 实际示例
SELECT 
    '性别' as 列名,
    COUNT(DISTINCT gender) as 唯一值数量,
    COUNT(*) as 总行数,
    ROUND(COUNT(DISTINCT gender)/COUNT(*), 4) as 选择性
FROM users;
-- 结果：性别只有2个值，10万用户，选择性=0.0001（很差）

SELECT 
    'email' as 列名,
    COUNT(DISTINCT email) as 唯一值数量, 
    COUNT(*) as 总行数,
    ROUND(COUNT(DISTINCT email)/COUNT(*), 4) as 选择性
FROM users;
-- 结果：邮箱基本唯一，选择性接近1.0（优秀）
```

### 5.2 复合索引效率分析


**📊 前缀选择性分析**：

```sql
-- 分析复合索引的前缀效果
-- 假设有索引 (age, city, gender)

-- 1. 单独age的选择性
SELECT COUNT(DISTINCT age)/COUNT(*) as age_selectivity FROM users;

-- 2. age+city的选择性  
SELECT COUNT(DISTINCT age, city)/COUNT(*) as age_city_selectivity FROM users;

-- 3. 完整索引的选择性
SELECT COUNT(DISTINCT age, city, gender)/COUNT(*) as full_selectivity FROM users;

/*
分析结果示例：
age_selectivity: 0.05 (年龄50个不同值)
age_city_selectivity: 0.8 (年龄+城市组合区分度高)
full_selectivity: 0.85 (加上性别提升有限)

结论：(age, city) 已经足够，gender列可能是冗余的
*/
```

### 5.3 索引使用率统计


**💹 评估索引实际价值**：

```sql
-- 创建索引使用评估视图
CREATE VIEW index_usage_stats AS
SELECT 
    s.TABLE_SCHEMA as 数据库名,
    s.TABLE_NAME as 表名,
    s.INDEX_NAME as 索引名,
    s.CARDINALITY as 基数,
    IFNULL(p.COUNT_FETCH, 0) as 使用次数,
    ROUND(t.INDEX_LENGTH/1024/1024, 2) as 索引大小MB,
    CASE 
        WHEN p.COUNT_FETCH IS NULL THEN '未使用'
        WHEN p.COUNT_FETCH < 10 THEN '很少使用'
        WHEN p.COUNT_FETCH < 100 THEN '偶尔使用'
        ELSE '经常使用'
    END as 使用频率评级
FROM INFORMATION_SCHEMA.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
    ON s.TABLE_SCHEMA = p.OBJECT_SCHEMA 
    AND s.TABLE_NAME = p.OBJECT_NAME
    AND s.INDEX_NAME = p.INDEX_NAME
JOIN INFORMATION_SCHEMA.TABLES t 
    ON s.TABLE_SCHEMA = t.TABLE_SCHEMA 
    AND s.TABLE_NAME = t.TABLE_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
    AND s.INDEX_NAME != 'PRIMARY'
    AND s.SEQ_IN_INDEX = 1  -- 只显示每个索引一次
ORDER BY 使用次数 DESC;

-- 查询未使用的索引
SELECT * FROM index_usage_stats WHERE 使用频率评级 = '未使用';
```

---

## 6. 🚫 未使用索引检测


### 6.1 识别未使用索引


**为什么要检测未使用索引？**
```
未使用索引就像房间里的无用物品：
❌ 占用存储空间
❌ 拖慢写入操作（每次INSERT/UPDATE/DELETE都要维护索引）
❌ 增加备份时间
❌ 浪费内存缓存
```

**🔍 检测方法**：

```sql
-- 方法1：基于Performance Schema检测
SELECT 
    OBJECT_SCHEMA as '数据库',
    OBJECT_NAME as '表名',
    INDEX_NAME as '索引名'
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE OBJECT_SCHEMA = 'your_database'
  AND INDEX_NAME IS NOT NULL 
  AND INDEX_NAME != 'PRIMARY'
  AND COUNT_FETCH = 0
  AND COUNT_INSERT = 0
  AND COUNT_UPDATE = 0  
  AND COUNT_DELETE = 0;

-- 方法2：结合表信息的完整检测
SELECT 
    s.TABLE_NAME as '表名',
    s.INDEX_NAME as '索引名',
    GROUP_CONCAT(s.COLUMN_NAME ORDER BY s.SEQ_IN_INDEX) as '索引列',
    ROUND(t.INDEX_LENGTH/1024/1024, 2) as '占用空间MB'
FROM INFORMATION_SCHEMA.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
    ON s.TABLE_SCHEMA = p.OBJECT_SCHEMA 
    AND s.TABLE_NAME = p.OBJECT_NAME 
    AND s.INDEX_NAME = p.INDEX_NAME
JOIN INFORMATION_SCHEMA.TABLES t
    ON s.TABLE_SCHEMA = t.TABLE_SCHEMA 
    AND s.TABLE_NAME = t.TABLE_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
  AND s.INDEX_NAME != 'PRIMARY'
  AND (p.COUNT_FETCH IS NULL OR p.COUNT_FETCH = 0)
GROUP BY s.TABLE_NAME, s.INDEX_NAME
ORDER BY t.INDEX_LENGTH DESC;
```

### 6.2 安全删除未使用索引


**⚠️ 删除索引的注意事项**：

```sql
-- 1. 先做备份！
mysqldump -u root -p --single-transaction your_database > backup.sql

-- 2. 在测试环境先删除验证
-- 3. 监控一段时间确认真的不需要

-- 删除未使用索引的标准流程：
-- Step 1: 记录要删除的索引
CREATE TABLE dropped_indexes_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    index_name VARCHAR(64), 
    columns VARCHAR(255),
    drop_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Step 2: 插入删除记录
INSERT INTO dropped_indexes_log (table_name, index_name, columns)
VALUES ('users', 'idx_unused_column', 'unused_column');

-- Step 3: 执行删除
ALTER TABLE users DROP INDEX idx_unused_column;

-- Step 4: 监控性能变化
-- 如有问题可以重建：
-- ALTER TABLE users ADD INDEX idx_unused_column (unused_column);
```

---

## 7. 🔄 重复索引识别


### 7.1 重复索引的类型


**🔍 什么是重复索引？**
```
重复索引类型：

1. 完全重复：
   INDEX idx1 (name)
   INDEX idx2 (name)  ← 完全一样

2. 前缀重复：
   INDEX idx1 (name, age)
   INDEX idx2 (name)  ← idx2是idx1的前缀，通常可删除

3. 逆序重复（较少见）：
   INDEX idx1 (name, age)
   INDEX idx2 (age, name)  ← 顺序不同，某些情况可能都需要
```

### 7.2 重复索引检测脚本


**📊 完整的重复索引检测**：

```sql
-- 检测完全重复的索引
SELECT 
    a.TABLE_NAME as '表名',
    a.INDEX_NAME as '索引1', 
    b.INDEX_NAME as '索引2',
    GROUP_CONCAT(a.COLUMN_NAME ORDER BY a.SEQ_IN_INDEX) as '索引列'
FROM INFORMATION_SCHEMA.STATISTICS a
JOIN INFORMATION_SCHEMA.STATISTICS b ON (
    a.TABLE_SCHEMA = b.TABLE_SCHEMA
    AND a.TABLE_NAME = b.TABLE_NAME  
    AND a.INDEX_NAME < b.INDEX_NAME  -- 避免重复比较
    AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX
    AND a.COLUMN_NAME = b.COLUMN_NAME
)
WHERE a.TABLE_SCHEMA = 'your_database'
GROUP BY a.TABLE_NAME, a.INDEX_NAME, b.INDEX_NAME
HAVING COUNT(*) = (
    SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE TABLE_SCHEMA = a.TABLE_SCHEMA 
      AND TABLE_NAME = a.TABLE_NAME 
      AND INDEX_NAME = a.INDEX_NAME
) AND COUNT(*) = (
    SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS
    WHERE TABLE_SCHEMA = b.TABLE_SCHEMA
      AND TABLE_NAME = b.TABLE_NAME  
      AND INDEX_NAME = b.INDEX_NAME
);
```

**🔍 前缀重复检测**：

```sql
-- 检测前缀重复索引
WITH index_columns AS (
    SELECT 
        TABLE_NAME,
        INDEX_NAME,
        GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns,
        COUNT(*) as column_count
    FROM INFORMATION_SCHEMA.STATISTICS
    WHERE TABLE_SCHEMA = 'your_database'
      AND INDEX_NAME != 'PRIMARY'
    GROUP BY TABLE_NAME, INDEX_NAME
)
SELECT 
    a.TABLE_NAME as '表名',
    a.INDEX_NAME as '较短索引（可能冗余）',
    a.columns as '较短索引列',
    b.INDEX_NAME as '较长索引',
    b.columns as '较长索引列'
FROM index_columns a
JOIN index_columns b ON (
    a.TABLE_NAME = b.TABLE_NAME
    AND a.INDEX_NAME != b.INDEX_NAME
    AND a.column_count < b.column_count
    AND b.columns LIKE CONCAT(a.columns, '%')
)
ORDER BY a.TABLE_NAME, a.INDEX_NAME;
```

### 7.3 重复索引处理建议


**📋 处理策略**：

```sql
-- 分析索引使用情况后再决定删除哪个
SELECT 
    INDEX_NAME as '索引名',
    COUNT_FETCH as '查询使用次数',
    COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE as '修改操作次数',
    SUM_TIMER_FETCH/1000000000 as '查询总耗时秒'
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_database'
  AND OBJECT_NAME = 'users'
  AND INDEX_NAME IN ('idx1', 'idx2')  -- 重复的索引名
ORDER BY COUNT_FETCH DESC;

-- 删除建议：
-- 1. 保留使用频率高的索引
-- 2. 对于前缀重复，通常删除短的索引
-- 3. 考虑查询模式，某些情况可能都需要保留
```

---

## 8. 🏥 索引健康检查体系


### 8.1 建立索引健康评分体系


**🎯 健康评分模型**：

```sql
-- 创建索引健康评估视图
CREATE VIEW index_health_score AS
SELECT 
    s.TABLE_SCHEMA as 数据库名,
    s.TABLE_NAME as 表名,
    s.INDEX_NAME as 索引名,
    
    -- 基础信息
    s.CARDINALITY as 基数,
    ROUND(t.INDEX_LENGTH/1024/1024, 2) as 空间MB,
    
    -- 使用情况评分（40分）
    CASE 
        WHEN IFNULL(p.COUNT_FETCH, 0) = 0 THEN 0
        WHEN IFNULL(p.COUNT_FETCH, 0) < 10 THEN 10
        WHEN IFNULL(p.COUNT_FETCH, 0) < 100 THEN 25
        ELSE 40
    END as 使用频率得分,
    
    -- 选择性评分（30分）
    CASE 
        WHEN s.CARDINALITY IS NULL THEN 0
        WHEN s.CARDINALITY / t.TABLE_ROWS > 0.1 THEN 30
        WHEN s.CARDINALITY / t.TABLE_ROWS > 0.01 THEN 20
        ELSE 5
    END as 选择性得分,
    
    -- 空间效率评分（20分）
    CASE 
        WHEN t.INDEX_LENGTH/1024/1024 < 10 THEN 20
        WHEN t.INDEX_LENGTH/1024/1024 < 100 THEN 15
        ELSE 10
    END as 空间效率得分,
    
    -- 维护成本评分（10分）
    CASE 
        WHEN IFNULL(p.COUNT_INSERT + p.COUNT_UPDATE + p.COUNT_DELETE, 0) < 1000 THEN 10
        WHEN IFNULL(p.COUNT_INSERT + p.COUNT_UPDATE + p.COUNT_DELETE, 0) < 10000 THEN 7
        ELSE 5
    END as 维护成本得分

FROM INFORMATION_SCHEMA.STATISTICS s
JOIN INFORMATION_SCHEMA.TABLES t 
    ON s.TABLE_SCHEMA = t.TABLE_SCHEMA 
    AND s.TABLE_NAME = t.TABLE_NAME
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
    ON s.TABLE_SCHEMA = p.OBJECT_SCHEMA 
    AND s.TABLE_NAME = p.OBJECT_NAME 
    AND s.INDEX_NAME = p.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
  AND s.SEQ_IN_INDEX = 1  -- 每个索引只显示一次
  AND s.INDEX_NAME != 'PRIMARY';

-- 查询健康评分
SELECT 
    *,
    (使用频率得分 + 选择性得分 + 空间效率得分 + 维护成本得分) as 总分,
    CASE 
        WHEN (使用频率得分 + 选择性得分 + 空间效率得分 + 维护成本得分) >= 80 THEN '优秀'
        WHEN (使用频率得分 + 选择性得分 + 空间效率得分 + 维护成本得分) >= 60 THEN '良好'
        WHEN (使用频率得分 + 选择性得分 + 空间效率得分 + 维护成本得分) >= 40 THEN '一般'
        ELSE '需要优化'
    END as 健康等级
FROM index_health_score
ORDER BY 总分 DESC;
```

### 8.2 索引碎片检查


**🧹 检测索引碎片化**：

```sql
-- 检查表和索引的碎片情况
SELECT 
    TABLE_NAME as '表名',
    ROUND(DATA_LENGTH/1024/1024, 2) as '数据大小MB',
    ROUND(INDEX_LENGTH/1024/1024, 2) as '索引大小MB',
    ROUND(DATA_FREE/1024/1024, 2) as '碎片大小MB',
    ROUND(DATA_FREE/(DATA_LENGTH+INDEX_LENGTH)*100, 2) as '碎片率%',
    TABLE_ROWS as '行数估算',
    CASE 
        WHEN DATA_FREE/(DATA_LENGTH+INDEX_LENGTH) > 0.1 THEN '严重碎片'
        WHEN DATA_FREE/(DATA_LENGTH+INDEX_LENGTH) > 0.05 THEN '中等碎片'
        ELSE '碎片较少'
    END as '碎片等级'
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'your_database'
  AND TABLE_TYPE = 'BASE TABLE'
  AND DATA_FREE > 0
ORDER BY DATA_FREE DESC;

-- 碎片整理建议
/*
碎片率 > 10%：建议立即整理
OPTIMIZE TABLE table_name;

碎片率 5-10%：可考虑在业务低峰期整理
碎片率 < 5%：暂不需要整理
*/
```

---

## 9. 🤖 自动化监控方案


### 9.1 监控脚本设计


**📊 自动化监控脚本框架**：

```sql
-- 创建索引监控报告表
CREATE TABLE index_monitor_reports (
    id INT AUTO_INCREMENT PRIMARY KEY,
    report_date DATE,
    table_name VARCHAR(64),
    index_name VARCHAR(64),
    issue_type ENUM('unused', 'duplicate', 'low_selectivity', 'high_fragmentation'),
    issue_description TEXT,
    suggestion TEXT,
    severity ENUM('high', 'medium', 'low'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 自动检测存储过程
DELIMITER //
CREATE PROCEDURE CheckIndexHealth(IN db_name VARCHAR(64))
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_table_name VARCHAR(64);
    DECLARE v_index_name VARCHAR(64);
    DECLARE v_cardinality BIGINT;
    DECLARE v_table_rows BIGINT;
    DECLARE v_count_fetch BIGINT;
    
    -- 游标定义
    DECLARE index_cursor CURSOR FOR 
        SELECT s.TABLE_NAME, s.INDEX_NAME, s.CARDINALITY, t.TABLE_ROWS,
               IFNULL(p.COUNT_FETCH, 0) as COUNT_FETCH
        FROM INFORMATION_SCHEMA.STATISTICS s
        JOIN INFORMATION_SCHEMA.TABLES t 
            ON s.TABLE_SCHEMA = t.TABLE_SCHEMA 
            AND s.TABLE_NAME = t.TABLE_NAME
        LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
            ON s.TABLE_SCHEMA = p.OBJECT_SCHEMA 
            AND s.TABLE_NAME = p.OBJECT_NAME 
            AND s.INDEX_NAME = p.INDEX_NAME
        WHERE s.TABLE_SCHEMA = db_name
          AND s.INDEX_NAME != 'PRIMARY'
          AND s.SEQ_IN_INDEX = 1;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- 清理今日报告
    DELETE FROM index_monitor_reports WHERE report_date = CURDATE();
    
    OPEN index_cursor;
    
    read_loop: LOOP
        FETCH index_cursor INTO v_table_name, v_index_name, v_cardinality, v_table_rows, v_count_fetch;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- 检查未使用索引
        IF v_count_fetch = 0 THEN
            INSERT INTO index_monitor_reports 
                (report_date, table_name, index_name, issue_type, issue_description, suggestion, severity)
            VALUES 
                (CURDATE(), v_table_name, v_index_name, 'unused', 
                 '索引从未被使用', '考虑删除此索引以节省空间和提升写入性能', 'medium');
        END IF;
        
        -- 检查低选择性索引
        IF v_cardinality IS NOT NULL AND v_table_rows > 0 
           AND (v_cardinality / v_table_rows) < 0.01 THEN
            INSERT INTO index_monitor_reports 
                (report_date, table_name, index_name, issue_type, issue_description, suggestion, severity)
            VALUES 
                (CURDATE(), v_table_name, v_index_name, 'low_selectivity', 
                 CONCAT('索引选择性过低: ', ROUND(v_cardinality / v_table_rows * 100, 2), '%'), 
                 '考虑删除或重新设计索引', 'high');
        END IF;
        
    END LOOP;
    
    CLOSE index_cursor;
    
    -- 生成汇总报告
    SELECT 
        issue_type as '问题类型',
        COUNT(*) as '问题数量',
        GROUP_CONCAT(DISTINCT severity) as '严重程度'
    FROM index_monitor_reports 
    WHERE report_date = CURDATE()
    GROUP BY issue_type;
    
END//
DELIMITER ;

-- 执行检查
CALL CheckIndexHealth('your_database');
```

### 9.2 定期报告生成


**📈 生成索引健康报告**：

```sql
-- 生成每日索引健康报告
SELECT 
    CONCAT('=== MySQL索引健康报告 ', CURDATE(), ' ===') as 报告标题
UNION ALL
SELECT CONCAT('数据库: ', 'your_database')
UNION ALL  
SELECT CONCAT('检查时间: ', NOW())
UNION ALL
SELECT '=================================='
UNION ALL
SELECT CONCAT('1. 总体统计')
UNION ALL
SELECT CONCAT('   总索引数: ', COUNT(*))
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' AND INDEX_NAME != 'PRIMARY'
UNION ALL
SELECT CONCAT('   总索引大小: ', 
    ROUND(SUM(INDEX_LENGTH)/1024/1024, 2), 'MB')
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'your_database'
UNION ALL
SELECT '2. 问题索引汇总:'
UNION ALL
SELECT CONCAT('   未使用索引: ', COUNT(*), '个')
FROM index_monitor_reports 
WHERE report_date = CURDATE() AND issue_type = 'unused'
UNION ALL
SELECT CONCAT('   低选择性索引: ', COUNT(*), '个')  
FROM index_monitor_reports
WHERE report_date = CURDATE() AND issue_type = 'low_selectivity'
UNION ALL
SELECT '3. 详细问题列表:'
UNION ALL
SELECT CONCAT('   ', table_name, '.', index_name, ': ', issue_description)
FROM index_monitor_reports
WHERE report_date = CURDATE()
ORDER BY severity DESC;
```

### 9.3 告警和通知机制


**🚨 设置监控告警**：

```bash
#!/bin/bash
# index_monitor.sh - 索引监控脚本

DB_HOST="localhost"
DB_USER="monitor_user"  
DB_PASS="password"
DB_NAME="your_database"
EMAIL="admin@company.com"

# 执行健康检查
mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -e "CALL CheckIndexHealth('$DB_NAME');"

# 检查是否有高优先级问题
HIGH_ISSUES=$(mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -s -N -e "
SELECT COUNT(*) FROM index_monitor_reports 
WHERE report_date = CURDATE() AND severity = 'high';")

if [ "$HIGH_ISSUES" -gt 0 ]; then
    # 发送告警邮件
    mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -e "
    SELECT CONCAT('紧急: 发现 ', COUNT(*), ' 个高优先级索引问题') as message
    FROM index_monitor_reports 
    WHERE report_date = CURDATE() AND severity = 'high';" | \
    mail -s "MySQL索引告警 - $DB_NAME" $EMAIL
fi

# 生成日报（每天早上8点）
if [ "$(date +%H)" = "08" ]; then
    mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME < generate_daily_report.sql | \
    mail -s "MySQL索引日报 - $DB_NAME" $EMAIL
fi
```

**⏰ 设置定时任务**：

```bash
# 添加到crontab
# 每2小时检查一次索引健康状况
0 */2 * * * /path/to/index_monitor.sh

# 每天凌晨3点生成详细报告
0 3 * * * /path/to/generate_detailed_report.sh

# 每周日凌晨2点执行索引维护
0 2 * * 0 /path/to/index_maintenance.sh
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的监控技术


```
🔸 基础监控工具：
• SHOW INDEX：快速查看索引基本信息
• INFORMATION_SCHEMA：结构化查询索引元数据  
• Performance Schema：详细的性能统计数据

🔸 关键监控指标：
• 索引使用频率：识别未使用索引
• 索引选择性：评估索引效率
• 索引大小：控制存储成本
• 查询性能：监控实际效果

🔸 问题检测方法：
• 未使用索引检测：避免资源浪费
• 重复索引识别：消除冗余设计
• 碎片率监控：维护索引性能
• 健康评分体系：综合评估索引价值
```

### 10.2 关键理解要点


**🔹 索引监控的本质目的**：
```
不是为了监控而监控，而是为了：
• 提升查询性能
• 节省存储资源  
• 减少维护成本
• 保持系统稳定
```

**🔹 监控数据的正确解读**：
```
✅ Cardinality高 + 使用频繁 = 优秀索引
⚠️ Cardinality低 + 很少使用 = 考虑删除
❌ 从不使用 + 占用空间大 = 立即删除
🔍 使用频繁 + 选择性低 = 需要重新设计
```

**🔹 自动化监控的价值**：
```
手动检查：费时费力，容易遗漏
自动化监控：
• 持续监控，及时发现问题
• 生成报告，便于决策
• 设置告警，快速响应
• 历史趋势，优化参考
```

### 10.3 实际应用指导


**🛠️ 监控实施建议**：

```
起步阶段：
1. 启用Performance Schema监控
2. 建立基础监控查询
3. 识别明显的问题索引

进阶阶段：  
1. 建立健康评分体系
2. 设置自动化检查脚本
3. 定期生成监控报告

专业阶段：
1. 集成到运维平台
2. 建立告警通知机制  
3. 形成索引维护流程
```

**⚠️ 监控注意事项**：

```
🔴 安全第一：
• 删除索引前必须备份
• 在测试环境先验证
• 监控性能变化

🟡 渐进优化：
• 不要一次性删除大量索引
• 观察一段时间再做决定
• 记录所有变更操作

🟢 持续改进：
• 定期审查监控策略
• 根据业务变化调整
• 建立索引设计规范
```

### 10.4 工具选择建议


| 场景 | 推荐工具 | 使用频率 | 复杂度 |
|------|----------|----------|--------|
| **日常检查** | `SHOW INDEX` | 每天 | ⭐ |
| **深度分析** | `INFORMATION_SCHEMA` | 每周 | ⭐⭐ |
| **性能监控** | `Performance Schema` | 持续 | ⭐⭐⭐ |
| **自动化监控** | `自定义脚本` | 持续 | ⭐⭐⭐⭐ |

### 10.5 最佳实践总结


**🎯 监控策略**：
```
定期检查：每周执行基础健康检查
实时监控：Performance Schema持续收集数据  
问题响应：发现问题及时分析处理
趋势分析：定期回顾历史数据，优化策略
```

**📊 评估标准**：
```
优秀索引：使用频繁 + 选择性高 + 维护成本低
一般索引：偶尔使用 + 选择性中等
问题索引：很少使用 + 选择性低 + 空间大
冗余索引：未使用 + 重复功能
```

**🔧 维护流程**：
```
1. 监控发现问题
2. 分析问题影响
3. 制定解决方案
4. 测试环境验证
5. 生产环境实施
6. 效果跟踪评估
```

**核心记忆**：
- 索引监控是性能优化的重要手段
- 结合多种工具全面了解索引状态
- 自动化监控提升运维效率
- 问题索引及时处理避免资源浪费
- 持续优化索引设计提升数据库性能