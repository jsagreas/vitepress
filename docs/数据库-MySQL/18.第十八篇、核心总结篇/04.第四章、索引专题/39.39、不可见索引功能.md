---
title: 39、不可见索引功能
---
## 📚 目录

1. [不可见索引基本概念](#1-不可见索引基本概念)
2. [索引可见性控制机制](#2-索引可见性控制机制)
3. [不可见索引的工作原理](#3-不可见索引的工作原理)
4. [索引影响评估与测试](#4-索引影响评估与测试)
5. [不可见索引管理实践](#5-不可见索引管理实践)
6. [监控与最佳实践](#6-监控与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 不可见索引基本概念


### 1.1 什么是不可见索引


> 💡 **核心理解**：不可见索引就像"隐身"的索引，数据库会维护它，但查询优化器看不到它

**简单类比**：
```
想象一个图书馆：
📚 正常索引 = 公开目录卡片，读者和管理员都能看到
👻 不可见索引 = 管理员的私人备份目录，只有管理员知道存在
```

**定义解释**：
- **是什么**：MySQL 8.0新增的索引特性，索引在物理上存在但对查询优化器不可见
- **做什么用**：允许DBA安全地测试索引删除的影响，而不用真的删除索引
- **核心价值**：提供了一个"反悔机制"，让索引管理更安全

### 1.2 为什么需要不可见索引


**传统索引删除的痛点**：
```
❌ 传统方式的问题：
1️⃣ 删除索引 → 发现性能下降 → 重建索引
2️⃣ 重建大表索引耗时很长（可能几小时）
3️⃣ 无法快速回滚，影响生产环境

✅ 不可见索引的解决方案：
1️⃣ 设为不可见 → 观察性能 → 确认无影响再删除
2️⃣ 发现问题立即设为可见，秒级恢复
3️⃣ 安全的"试错"机制
```

**实际场景举例**：
```
🏢 电商网站场景：
- 订单表有个很少用的索引 idx_order_status
- DBA怀疑这个索引没用，想删除节省空间
- 传统做法：直接删除，如果有问题就重建（风险大）
- 不可见索引：先设为不可见观察一周，确认无影响再删除
```

### 1.3 不可见索引的特点


**核心特性**：
```
🔸 物理存在：索引数据结构完整保存在磁盘上
🔸 维护更新：INSERT/UPDATE/DELETE时会同步更新索引
🔸 优化器忽略：查询计划制定时完全看不到这个索引
🔸 快速切换：可见/不可见状态瞬间切换
🔸 语法简单：只需ALTER TABLE语句即可控制
```

---

## 2. ⚙️ 索引可见性控制机制


### 2.1 基本语法操作


**创建不可见索引**：
```sql
-- 创建时直接指定为不可见
CREATE INDEX idx_user_email ON users(email) INVISIBLE;

-- 创建普通索引后设为不可见
CREATE INDEX idx_user_phone ON users(phone);
ALTER TABLE users ALTER INDEX idx_user_phone INVISIBLE;
```

**切换索引可见性**：
```sql
-- 设为不可见
ALTER TABLE users ALTER INDEX idx_user_email INVISIBLE;

-- 设为可见
ALTER TABLE users ALTER INDEX idx_user_email VISIBLE;
```

> 💡 **记忆技巧**：INVISIBLE = 隐身，VISIBLE = 可见，就像开关灯一样简单

### 2.2 查看索引可见性状态


**查询索引可见性**：
```sql
-- 查看表的所有索引及可见性
SELECT 
    INDEX_NAME,
    COLUMN_NAME,
    IS_VISIBLE
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database' 
  AND TABLE_NAME = 'users'
ORDER BY INDEX_NAME;
```

**示例输出**：
```
+----------------+-------------+------------+
| INDEX_NAME     | COLUMN_NAME | IS_VISIBLE |
+----------------+-------------+------------+
| PRIMARY        | id          | YES        |
| idx_user_email | email       | NO         |
| idx_user_phone | phone       | YES        |
+----------------+-------------+------------+
```

### 2.3 系统变量控制


**全局控制开关**：
```sql
-- 查看当前设置
SHOW VARIABLES LIKE 'optimizer_switch';

-- 强制优化器使用不可见索引（仅用于测试）
SET optimizer_switch = 'use_invisible_indexes=on';

-- 恢复默认行为
SET optimizer_switch = 'use_invisible_indexes=off';
```

> ⚠️ **注意事项**：`use_invisible_indexes=on`仅用于测试，生产环境不建议开启

---

## 3. 🛠️ 不可见索引的工作原理


### 3.1 优化器处理机制


**查询优化过程对比**：
```
正常索引的优化过程：
用户查询 → 优化器分析 → 发现可用索引 → 选择最优索引 → 执行

不可见索引的优化过程：
用户查询 → 优化器分析 → 跳过不可见索引 → 选择其他索引 → 执行
           ↑
        完全看不到不可见索引
```

**实际演示**：
```sql
-- 创建测试表和数据
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    status VARCHAR(20),
    created_at DATETIME
);

-- 创建不可见索引
CREATE INDEX idx_status ON orders(status) INVISIBLE;

-- 查看执行计划
EXPLAIN SELECT * FROM orders WHERE status = 'pending';
```

**执行计划结果**：
```
+----+-------+--------+------+--------+
| id | type  | table  | key  | rows   |
+----+-------+--------+------+--------+
|  1 | ALL   | orders | NULL | 100000 |  ← 全表扫描，没用索引
+----+-------+--------+------+--------+
```

### 3.2 索引维护机制


**数据修改时的索引维护**：
```
📝 INSERT操作：
普通索引：更新索引 ✓
不可见索引：也要更新索引 ✓

📝 UPDATE操作：
普通索引：更新索引 ✓
不可见索引：也要更新索引 ✓

📝 DELETE操作：
普通索引：删除索引项 ✓
不可见索引：也要删除索引项 ✓
```

> 🔑 **一句话总结**：不可见索引在存储层面和普通索引完全一样，只是优化器看不到

### 3.3 性能影响分析


**不可见索引的开销**：
```
✅ 查询性能：
- 不会被优化器选中，不影响查询计划
- 不占用优化器分析时间

❌ 写入性能：
- INSERT/UPDATE/DELETE时仍需维护索引
- 占用存储空间
- 消耗维护开销

⚖️ 权衡考虑：
- 短期测试：影响可接受
- 长期保留：建议及时清理
```

---

## 4. 📊 索引影响评估与测试


### 4.1 安全的索引删除流程


**推荐的测试流程**：
```
第一步：识别候选索引
   ↓
第二步：设为不可见索引
   ↓
第三步：性能监控观察
   ↓
第四步：确认无影响后删除
```

**详细操作步骤**：
```sql
-- 1. 记录当前索引使用情况
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'your_db' 
  AND INDEX_NAME = 'target_index';

-- 2. 设为不可见
ALTER TABLE your_table ALTER INDEX target_index INVISIBLE;

-- 3. 观察期间持续监控（后续章节详述）

-- 4. 确认安全后删除
DROP INDEX target_index ON your_table;
```

### 4.2 性能监控要点


**关键监控指标**：
```
📈 查询性能指标：
- 查询响应时间
- 慢查询数量
- CPU使用率
- 磁盘IO

📊 业务指标：
- 接口响应时间
- 用户体验指标
- 错误率变化

🕐 监控时间窗口：
- 至少观察24小时
- 包含业务高峰期
- 建议观察一个完整业务周期
```

**监控SQL示例**：
```sql
-- 监控慢查询变化
SELECT 
    SQL_TEXT,
    TIMER_WAIT/1000000000 as EXEC_TIME_SEC,
    LOCK_TIME/1000000000 as LOCK_TIME_SEC
FROM performance_schema.events_statements_history_long
WHERE TIMER_WAIT > 1000000000  -- 超过1秒的查询
ORDER BY TIMER_START DESC
LIMIT 10;
```

### 4.3 回滚机制


**快速恢复方案**：
```sql
-- 发现性能问题，立即恢复索引可见性
ALTER TABLE orders ALTER INDEX idx_status VISIBLE;

-- 验证恢复效果
EXPLAIN SELECT * FROM orders WHERE status = 'pending';
```

**恢复时间对比**：
```
传统方式重建索引：
删除索引 → 发现问题 → 重建索引（可能几小时）

不可见索引方式：
设为不可见 → 发现问题 → 设为可见（几毫秒）
```

---

## 5. 🔧 不可见索引管理实践


### 5.1 批量管理脚本


**批量查看不可见索引**：
```sql
-- 查看数据库中所有不可见索引
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME
FROM INFORMATION_SCHEMA.STATISTICS
WHERE IS_VISIBLE = 'NO'
  AND INDEX_NAME != 'PRIMARY'
ORDER BY TABLE_SCHEMA, TABLE_NAME;
```

**批量操作示例**：
```sql
-- 生成批量设置语句（需要手动执行）
SELECT CONCAT(
    'ALTER TABLE ', TABLE_SCHEMA, '.', TABLE_NAME, 
    ' ALTER INDEX ', INDEX_NAME, ' INVISIBLE;'
) AS sql_statement
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
  AND INDEX_NAME LIKE 'old_%'
  AND IS_VISIBLE = 'YES';
```

### 5.2 索引治理策略


**索引生命周期管理**：
```
🔍 识别阶段：
- 使用performance_schema分析索引使用情况
- 找出长期未使用的索引

🧪 测试阶段：
- 设为不可见索引
- 观察性能影响

✅ 决策阶段：
- 无影响：安全删除
- 有影响：恢复可见，优化查询

📊 监控阶段：
- 定期审查索引使用情况
- 持续优化索引结构
```

**索引使用情况分析**：
```sql
-- 找出可能未使用的索引
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_FETCH,
    COUNT_INSERT + COUNT_UPDATE + COUNT_DELETE as WRITE_COUNT
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'sys')
  AND COUNT_FETCH = 0  -- 从未被查询使用
  AND INDEX_NAME != 'PRIMARY'
ORDER BY WRITE_COUNT DESC;
```

### 5.3 自动化管理


**创建管理存储过程**：
```sql
DELIMITER //
CREATE PROCEDURE ManageInvisibleIndex(
    IN p_schema VARCHAR(64),
    IN p_table VARCHAR(64),
    IN p_index VARCHAR(64),
    IN p_action VARCHAR(10)  -- 'HIDE' or 'SHOW'
)
BEGIN
    DECLARE sql_stmt VARCHAR(200);
    
    IF p_action = 'HIDE' THEN
        SET sql_stmt = CONCAT('ALTER TABLE ', p_schema, '.', p_table, 
                             ' ALTER INDEX ', p_index, ' INVISIBLE');
    ELSEIF p_action = 'SHOW' THEN
        SET sql_stmt = CONCAT('ALTER TABLE ', p_schema, '.', p_table, 
                             ' ALTER INDEX ', p_index, ' VISIBLE');
    END IF;
    
    SET @sql = sql_stmt;
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END //
DELIMITER ;

-- 使用示例
CALL ManageInvisibleIndex('test_db', 'users', 'idx_email', 'HIDE');
```

---

## 6. 📊 监控与最佳实践


### 6.1 监控体系建设


**核心监控指标**：
```sql
-- 创建监控视图
CREATE VIEW v_invisible_index_monitor AS
SELECT 
    s.TABLE_SCHEMA,
    s.TABLE_NAME,
    s.INDEX_NAME,
    s.IS_VISIBLE,
    IFNULL(io.COUNT_FETCH, 0) as FETCH_COUNT,
    IFNULL(io.COUNT_INSERT, 0) as INSERT_COUNT,
    IFNULL(io.COUNT_UPDATE, 0) as UPDATE_COUNT,
    IFNULL(io.COUNT_DELETE, 0) as DELETE_COUNT,
    CONCAT(ROUND(stat.STAT_VALUE/1024/1024, 2), ' MB') as INDEX_SIZE
FROM INFORMATION_SCHEMA.STATISTICS s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage io
    ON s.TABLE_SCHEMA = io.OBJECT_SCHEMA 
    AND s.TABLE_NAME = io.OBJECT_NAME
    AND s.INDEX_NAME = io.INDEX_NAME
LEFT JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS stat
    ON s.TABLE_NAME = stat.NAME
WHERE s.TABLE_SCHEMA NOT IN ('mysql', 'performance_schema', 'sys')
ORDER BY s.TABLE_SCHEMA, s.TABLE_NAME, s.INDEX_NAME;
```

**告警机制设置**：
```sql
-- 检查长期不可见的索引（可能忘记处理）
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    'Long time invisible index found' as ALERT_MESSAGE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE IS_VISIBLE = 'NO'
  AND INDEX_NAME != 'PRIMARY'
  -- 这里可以结合时间戳表来判断不可见时间
;
```

### 6.2 最佳实践总结


| 场景 | **建议做法** | **注意事项** |
|------|-------------|-------------|
| 🔍 **索引清理** | `先设不可见观察→确认无影响→删除` | `观察期至少24小时` |
| 🧪 **新索引测试** | `创建为不可见→测试性能→确认有效再可见` | `避免影响生产查询` |
| 🚨 **紧急回滚** | `立即设为可见恢复性能` | `比重建索引快几千倍` |
| 📊 **索引审计** | `定期检查不可见索引状态` | `避免长期占用资源` |

**操作规范**：
```
✅ 操作前准备：
1. 备份当前索引定义
2. 确认业务低峰期操作
3. 准备性能监控脚本

✅ 操作中监控：
1. 实时监控查询性能
2. 关注慢查询日志
3. 观察系统资源使用

✅ 操作后验证：
1. 确认索引状态正确
2. 验证查询计划变化
3. 评估性能影响结果
```

### 6.3 常见问题与解决


**Q: 不可见索引会影响写入性能吗？**
```
A: 会有影响，因为写入时仍需维护索引
建议：测试期间监控写入性能，及时清理确认不需要的索引
```

**Q: 可以将主键设为不可见吗？**
```
A: 不可以，主键和唯一索引不能设为不可见
原因：这些索引用于保证数据完整性，必须始终可见
```

**Q: 不可见索引占用的空间会释放吗？**
```
A: 不会，索引数据仍然存在
解决：确认不需要后应及时DROP INDEX释放空间
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 不可见索引本质：物理存在但优化器看不见的索引
🔸 核心价值：提供安全的索引删除测试机制
🔸 工作原理：查询时被忽略，写入时仍需维护
🔸 语法操作：CREATE...INVISIBLE，ALTER...INVISIBLE/VISIBLE
🔸 监控要点：性能影响观察，及时清理机制
```

### 7.2 关键理解要点


**🔹 什么时候使用不可见索引**
```
适用场景：
✅ 删除疑似无用索引前的安全测试
✅ 新索引上线前的性能验证
✅ 紧急故障时的快速索引禁用

不适用场景：
❌ 长期禁用索引（应该直接删除）
❌ 主键或唯一索引（语法不支持）
❌ 频繁切换可见性（影响性能）
```

**🔹 与传统方法的优势对比**
```
传统删除索引：
删除 → 监控 → 问题出现 → 重建索引（耗时长，风险大）

不可见索引方法：
隐藏 → 监控 → 问题出现 → 恢复可见（秒级，风险小）

关键差别：可逆性和响应速度
```

### 7.3 实际应用价值


**🎯 DBA日常工作中的价值**
- **索引优化**：安全地测试索引删除对性能的影响
- **容量管理**：逐步清理无用索引，释放存储空间  
- **故障处理**：快速禁用问题索引，恢复系统性能
- **变更管理**：降低索引变更的风险和回滚成本

**🔧 最佳实践流程**
```
1. 识别目标索引 → 使用performance_schema分析
2. 设为不可见 → ALTER TABLE ... ALTER INDEX ... INVISIBLE
3. 性能监控 → 观察慢查询、响应时间等指标  
4. 影响评估 → 确认对业务的实际影响
5. 最终决策 → 恢复可见或彻底删除
```

### 7.4 记忆要点


> 💡 **一句话总结**：不可见索引是MySQL提供的"后悔药"，让索引管理从"一次性决策"变成"可试错的过程"

```
┌─ 记忆口诀 ─────────────────┐
│ 索引隐身优化器看不见        │
│ 物理存在维护不能免          │
│ 安全测试删除有保险          │  
│ 秒级切换胜过重建店          │
└────────────────────────────┘
```

**🔑 关键记忆点**：
- **INVISIBLE** = 索引隐身，优化器看不见
- **物理维护** = 写入时仍需更新索引数据
- **秒级切换** = VISIBLE/INVISIBLE瞬间生效
- **安全测试** = 删除前的"试驾"机制

**核心价值记忆**：让数据库索引管理从"小心翼翼"变成"大胆尝试"，因为有了随时反悔的能力。