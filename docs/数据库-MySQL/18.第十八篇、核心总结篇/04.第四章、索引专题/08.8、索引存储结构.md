---
title: 8、索引存储结构
---
## 📚 目录

1. [索引存储结构概述](#1-索引存储结构概述)
2. [索引页面结构详解](#2-索引页面结构详解)
3. [页头信息组成](#3-页头信息组成)
4. [索引记录格式](#4-索引记录格式)
5. [页目录组织机制](#5-页目录组织机制)
6. [页面空间管理](#6-页面空间管理)
7. [索引页分裂与合并](#7-索引页分裂与合并)
8. [空间利用率与碎片管理](#8-空间利用率与碎片管理)
9. [索引统计与维护](#9-索引统计与维护)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📖 索引存储结构概述


### 1.1 什么是索引存储结构


**💡 通俗理解**
索引存储结构就像图书馆的书架组织方式。想象一下：
- **书架**相当于索引页面
- **书架上的标签**相当于页头信息  
- **书的排列方式**相当于记录格式
- **书架目录**相当于页目录

```
图书馆的组织：                MySQL索引的组织：
┌─────────────┐              ┌─────────────┐
│  书架标签    │              │   页头信息   │
├─────────────┤              ├─────────────┤
│  书1 书2    │              │  记录1 记录2 │
│  书3 书4    │              │  记录3 记录4 │
├─────────────┤              ├─────────────┤
│  目录索引    │              │   页目录    │
└─────────────┘              └─────────────┘
```

### 1.2 索引物理存储的本质


**🔸 核心概念**
```
物理存储：数据在磁盘上的实际存放方式
页面：MySQL存储的基本单位，默认16KB
页面结构：每个页面内部如何组织数据
```

**🎯 为什么要了解存储结构**
- **性能优化**：理解存储原理才能优化查询
- **容量规划**：准确估算索引占用空间
- **故障排查**：分析索引碎片和性能问题
- **设计决策**：选择合适的索引策略

---

## 2. 🏗️ 索引页面结构详解


### 2.1 页面整体布局


**📋 页面结构组成**
```
一个16KB的索引页面布局：

┌─────────────────────────────────────┐ ← 0字节开始
│           文件头(38字节)             │
├─────────────────────────────────────┤ ← 38字节
│           页头(56字节)              │
├─────────────────────────────────────┤ ← 94字节
│            记录区域                 │
│          (存放索引记录)             │
│              ↓                     │
│         (向下增长)                  │
├─────────────────────────────────────┤
│              ...                   │
├─────────────────────────────────────┤
│         (向上增长)                  │
│              ↑                     │
│           页目录区域                │
├─────────────────────────────────────┤ ← 页面末尾-8字节
│           文件尾(8字节)             │
└─────────────────────────────────────┘ ← 16384字节(16KB)
```

### 2.2 页面类型分类


**🔸 索引页面类型**
```
根据存储内容分类：

叶子页面(Leaf Page)：
• 存储实际的索引键值对
• 包含指向数据行的指针
• 是查询的最终目标

非叶子页面(Non-Leaf Page)：  
• 存储索引键和子页面指针
• 用于导航和定位
• 不包含实际数据
```

**💡 页面类型示例**
```
B+树索引结构：

        [根页面]
       /        \
  [内部页面1]  [内部页面2]    ← 非叶子页面
    /    \      /    \
[叶子1][叶子2][叶子3][叶子4]  ← 叶子页面

叶子页面：存储 (索引值, 主键值)
内部页面：存储 (索引值, 子页面指针)
```

### 2.3 页面标识信息


**🔸 页面基本标识**
```sql
-- 查看页面基本信息
SELECT 
    page_number,           -- 页面编号
    page_type,            -- 页面类型
    number_records,       -- 记录数量
    heap_number,          -- 堆记录数
    n_owned             -- 拥有的记录数
FROM information_schema.innodb_buffer_page
WHERE table_name = 'your_table';
```

---

## 3. 📄 页头信息组成


### 3.1 页头结构详解


**🔸 页头信息构成(56字节)**
```
页头信息布局：

偏移量  大小    字段名          含义
0      4      PAGE_N_DIR_SLOTS  页目录槽数量
4      2      PAGE_HEAP_TOP     堆记录顶部位置
6      2      PAGE_N_HEAP       堆记录数量  
8      2      PAGE_FREE         空闲记录链表头
10     2      PAGE_GARBAGE      垃圾字节数
12     2      PAGE_LAST_INSERT  最后插入位置
14     2      PAGE_DIRECTION    插入方向
16     2      PAGE_N_DIRECTION  相同方向插入数
18     2      PAGE_N_RECS       用户记录数
26     8      PAGE_MAX_TRX_ID   最大事务ID
34     2      PAGE_LEVEL        页面层级
36     8      PAGE_INDEX_ID     索引ID
```

### 3.2 关键字段解释


**💡 重要字段含义**

**① PAGE_N_RECS - 用户记录数**
```
含义：页面中实际存储的索引记录数量
作用：快速获知页面记录密度
范围：0 到 页面容量上限

示例：
如果一个页面显示 PAGE_N_RECS = 100
说明这个页面存储了100条索引记录
```

**② PAGE_HEAP_TOP - 堆顶位置**  
```
含义：指示下一条记录的插入位置
作用：管理页面空间分配
特点：随着记录插入向上移动

可用空间 = 16384 - PAGE_HEAP_TOP - 页目录大小
```

**③ PAGE_LEVEL - 页面层级**
```
含义：页面在B+树中的层级
• 叶子页面：PAGE_LEVEL = 0
• 父页面：PAGE_LEVEL = 1  
• 根页面：PAGE_LEVEL = 最大值

作用：确定页面在索引树中的位置
```

### 3.3 页头信息的作用


**🎯 页头信息用途**
```
空间管理：
• 跟踪可用空间大小
• 管理空闲记录链表
• 计算碎片程度

性能优化：
• 插入方向预测
• 页面分裂判断  
• 查询路径优化

维护操作：
• 统计信息更新
• 页面重组判断
• 索引重建决策
```

---

## 4. 📝 索引记录格式


### 4.1 记录存储格式


**🔸 索引记录结构**
```
单条索引记录的组成：

┌───────┬───────┬───────┬───────┬───────┐
│记录头 │键值1  │键值2  │...   │行指针 │
│(5字节)│(变长) │(变长) │      │(变长) │
└───────┴───────┴───────┴───────┴───────┘

记录头信息(5字节)：
• 删除标记(1bit)：记录是否被删除
• 记录类型(3bit)：普通/目录/最小/最大记录
• 下条记录偏移(13bit)：指向下一条记录
• 其他标志位
```

### 4.2 不同索引类型的记录格式


**① 主键索引记录**
```
主键索引的叶子页面记录：
┌───────┬───────┬─────────────┐
│记录头 │主键值 │完整行数据    │
└───────┴───────┴─────────────┘

示例：id为主键的用户表
记录：[头信息][id=123][name=张三,age=25,...]
```

**② 二级索引记录**
```  
二级索引的叶子页面记录：
┌───────┬───────┬───────┐
│记录头 │索引值 │主键值 │
└───────┴───────┴───────┘

示例：name字段的索引
记录：[头信息][name=张三][id=123]
```

**③ 联合索引记录**
```
联合索引记录：
┌───────┬───────┬───────┬───────┬───────┐
│记录头 │列1值  │列2值  │列3值  │主键值 │
└───────┴───────┴───────┴───────┴───────┘

示例：(name,age)联合索引
记录：[头信息][name=张三][age=25][id=123]
```

### 4.3 记录大小计算


**📊 记录大小估算**
```sql
-- 估算索引记录大小
-- 记录大小 = 记录头(5) + 索引列大小 + 主键大小

示例计算：
主键：INT(4字节)
索引列：VARCHAR(50) 最大50字节
联合索引：(name VARCHAR(20), age INT)

单条记录大小：
• 记录头：5字节
• name列：实际长度 + 1字节长度标识  
• age列：4字节
• 主键：4字节
• 总计：约 14 + name实际长度 字节
```

---

## 5. 📂 页目录组织机制


### 5.1 页目录的作用


**💡 什么是页目录**
页目录就像书的目录，帮你快速找到想要的内容：

```
书的目录：                   页目录：
第1章 - 第3页               槽1 - 记录1-10
第2章 - 第15页              槽2 - 记录11-20  
第3章 - 第28页              槽3 - 记录21-30
...                        ...

快速定位 → 直接翻页         快速定位 → 直接找记录
```

### 5.2 页目录结构详解


**🔸 页目录组织方式**
```
页目录结构：

页面末尾向前存储：
┌─────────────────────────────────┐
│           记录区域               │
├─────────────────────────────────┤
│              ...               │
├─────────────────────────────────┤
│  slot_n  slot_n-1  ...  slot_1 │ ← 页目录
├─────────────────────────────────┤
│         文件尾(8字节)           │
└─────────────────────────────────┘

每个slot(槽)：2字节，指向某条记录的偏移量
```

### 5.3 页目录查找机制


**🔍 二分查找过程**
```
查找流程：

1. 确定查找范围：
   • 页目录槽数量：n
   • 查找目标：key_value

2. 二分查找槽：
   ① left = 0, right = n-1
   ② mid = (left + right) / 2
   ③ 比较 slot[mid] 指向记录的键值
   ④ 调整查找范围
   ⑤ 重复直到找到合适的槽

3. 槽内线性查找：
   • 在确定的槽内顺序查找目标记录
```

**💡 查找示例**
```
假设页面有8个槽，查找 key = 156：

槽编号：  0    1    2    3    4    5    6    7
键值：   10   50   100  150  200  250  300  350

第1次：mid=3, slot[3]=150 < 156，left=4
第2次：mid=5, slot[5]=250 > 156，right=4  
第3次：mid=4, slot[4]=200 > 156，right=3
确定：在slot[3]到slot[4]之间线性查找
```

---

## 6. 💾 页面空间管理


### 6.1 页面空间分布


**🔸 页面空间构成**
```
16KB页面空间分配：

┌─────────────────┐ ← 100%
│   文件尾 8B     │
├─────────────────┤ ← 99.95%
│   页目录(变长)   │
├─────────────────┤ ← 变化边界
│   空闲空间      │
├─────────────────┤ ← 变化边界
│   记录区域      │
├─────────────────┤ ← 0.57%
│   页头 56B      │
├─────────────────┤ ← 0.23%  
│   文件头 38B    │
└─────────────────┘ ← 0%

可用空间 = 16384 - 38 - 56 - 8 - 页目录大小 = 约16282字节
```

### 6.2 空间分配策略


**💡 记录插入空间管理**
```
插入新记录时的空间分配：

情况1：有足够连续空间
• 直接在堆顶分配新记录
• 更新 PAGE_HEAP_TOP 指针

情况2：有空闲记录空间  
• 复用已删除记录的空间
• 从 PAGE_FREE 链表中分配

情况3：空间不足
• 触发页面分裂操作
• 创建新页面分担记录
```

### 6.3 空间碎片产生


**⚠️ 碎片产生原因**
```
内部碎片：
• 删除记录后留下的空洞
• 更新记录导致的大小变化
• 记录移动后的剩余空间

外部碎片：
• 页面之间的空隙
• 页面分裂后的不均匀分布
• 批量删除后的空页面
```

**📊 碎片检测**
```sql
-- 检查表的碎片情况
SELECT 
    table_name,
    ROUND(data_length/1024/1024,2) AS data_mb,
    ROUND(index_length/1024/1024,2) AS index_mb,
    ROUND(data_free/1024/1024,2) AS free_mb,
    ROUND(data_free/(data_length+index_length)*100,2) AS fragment_pct
FROM information_schema.tables 
WHERE table_schema = 'your_database'
    AND table_name = 'your_table';
```

---

## 7. 🔄 索引页分裂与合并


### 7.1 页面分裂机制


**💡 什么时候发生页面分裂**
页面分裂就像书架放满了要添加新书架：

```
分裂前：页面快满了
┌─────────────────┐
│ 记录1 记录2     │
│ 记录3 记录4     │
│ 记录5 记录6     │
│ 记录7 ← 96%满   │
└─────────────────┘

分裂后：分成两个页面
┌─────────────────┐  ┌─────────────────┐
│ 记录1 记录2     │  │ 记录5 记录6     │
│ 记录3 记录4     │  │ 记录7 新记录    │
│ ← 50%满         │  │ ← 50%满         │
└─────────────────┘  └─────────────────┘
```

### 7.2 分裂触发条件


**🔸 分裂条件判断**
```
触发分裂的情况：

1. 空间不足：
   • 剩余空间 < 新记录大小 + 页目录预留空间
   • 通常在页面使用率达到93-96%时触发

2. 插入位置：
   • 顺序插入：分裂点通常在页面末尾
   • 随机插入：分裂点在页面中间
   • 逆序插入：分裂点在页面开头
```

### 7.3 页面合并机制


**💡 页面合并时机**
```
合并触发条件：
• 页面使用率低于合并阈值(默认50%)
• 相邻页面总记录数能放入单页
• 删除操作导致页面记录过少

合并过程：
1. 选择合并目标页面(通常是相邻页面)
2. 将源页面记录复制到目标页面
3. 更新页面链表指针
4. 释放源页面空间
5. 更新父页面索引指针
```

### 7.4 分裂合并的影响


**📊 性能影响分析**
```
页面分裂的代价：
✅ 好处：解决空间不足问题
❌ 代价：
  • I/O开销：需要写入新页面
  • 锁开销：需要锁定多个页面
  • 碎片增加：可能产生半空页面

页面合并的代价：
✅ 好处：提高空间利用率，减少碎片
❌ 代价：
  • 合并操作的CPU开销
  • 可能影响并发性能
```

---

## 8. 📈 空间利用率与碎片管理


### 8.1 空间利用率计算


**📊 利用率指标**
```sql
-- 计算页面平均利用率
SELECT 
    index_name,
    stat_name,
    stat_value,
    CASE 
        WHEN stat_name = 'size' THEN stat_value * 16384  -- 页面数 * 页面大小
        WHEN stat_name = 'n_leaf_pages' THEN stat_value * 16384  -- 叶子页数量
    END as size_bytes
FROM mysql.innodb_index_stats 
WHERE table_name = 'your_table'
    AND stat_name IN ('size', 'n_leaf_pages', 'n_diff_pfx01');

-- 计算空间利用率
-- 利用率 = (实际数据大小) / (分配页面大小) * 100%
```

### 8.2 碎片类型与识别


**🔸 碎片分类详解**
```
内部碎片(页面内)：
┌─────────────────┐
│ 记录1  [空洞]   │ ← 删除记录后的空洞
│ 记录2  记录3    │
│ [空洞] 记录4    │ ← 更新记录后的空洞
│ 记录5  记录6    │
└─────────────────┘

外部碎片(页面间)：
页面1: 30%使用率  │  理想状态: 页面1和2合并
页面2: 25%使用率  │  变成一个60%使用率的页面
页面3: 90%使用率  │  页面3保持不变
```

### 8.3 碎片清理策略


**🛠️ 碎片优化方法**

**① 索引重建**
```sql
-- 重建索引清理碎片
ALTER TABLE your_table DROP INDEX index_name;
ALTER TABLE your_table ADD INDEX index_name (column_name);

-- 或者使用
OPTIMIZE TABLE your_table;
```

**② 定期维护**
```sql
-- 检查并清理碎片的维护脚本
-- 1. 检查碎片率
-- 2. 碎片率 > 30% 时执行 OPTIMIZE
-- 3. 监控优化效果

SET @fragment_threshold = 30;

SELECT 
    table_name,
    ROUND(data_free/(data_length+index_length)*100,2) AS fragment_pct
FROM information_schema.tables 
WHERE table_schema = DATABASE()
    AND ROUND(data_free/(data_length+index_length)*100,2) > @fragment_threshold;
```

### 8.4 预防碎片产生


**💡 设计层面优化**
```
减少碎片的设计原则：

1. 合理的主键设计：
   ✅ 使用自增主键：顺序插入，减少页面分裂
   ❌ 避免UUID主键：随机插入，增加分裂

2. 批量操作优化：
   ✅ 批量插入：减少页面分裂次数
   ✅ 按主键顺序删除：利于页面合并

3. 更新策略：
   ✅ 避免增加记录长度的更新
   ✅ 设计时预留字段空间
```

---

## 9. 📊 索引统计与维护


### 9.1 索引统计信息


**📈 统计信息作用**
```
MySQL维护的索引统计：
• 索引基数(cardinality)：不同值的数量
• 页面数量：索引占用的页面总数
• 平均行长度：每条记录的平均大小
• 空间利用率：页面填充程度
```

**🔍 查看统计信息**
```sql
-- 查看索引统计信息
SELECT 
    table_name,
    index_name,
    stat_name,
    stat_value,
    sample_size,
    stat_description
FROM mysql.innodb_index_stats 
WHERE table_name = 'your_table'
ORDER BY index_name, stat_name;

-- 关键统计指标：
-- size: 索引页面总数
-- n_diff_pfx01: 第一列的基数
-- n_leaf_pages: 叶子页面数
-- n_diff_pfx02: 前两列的组合基数(联合索引)
```

### 9.2 统计维护操作


**🔧 更新统计信息**
```sql
-- 手动更新表统计信息
ANALYZE TABLE your_table;

-- 更新指定索引统计
ANALYZE TABLE your_table UPDATE HISTOGRAM ON column_name;

-- 查看统计信息更新时间
SELECT 
    table_name,
    index_name,
    last_update,
    stat_name,
    stat_value
FROM mysql.innodb_index_stats 
WHERE table_name = 'your_table'
ORDER BY last_update DESC;
```

### 9.3 存储空间估算


**📊 索引空间计算公式**
```
索引空间估算公式：

总空间 = 页面数量 × 页面大小(16KB)

页面数量估算：
• 叶子页面数 = 记录总数 / 每页记录数
• 内部页面数 = 叶子页面数 / 扇出系数

每页记录数估算：
• 可用空间 ≈ 16KB - 页头(94B) - 页目录预留
• 每页记录数 = 可用空间 / 平均记录大小

示例计算：
表记录数：1000万
平均记录大小：50字节
每页记录数：16200 / 50 ≈ 324条
叶子页面数：10000000 / 324 ≈ 30864页
内部页面数：30864 / 500 ≈ 62页
总页面数：30864 + 62 = 30926页
索引总大小：30926 × 16KB ≈ 495MB
```

### 9.4 监控指标


**⚡ 关键监控指标**
```sql
-- 索引健康度监控查询
SELECT 
    t.table_name,
    t.table_rows,
    ROUND(t.data_length/1024/1024,2) AS data_mb,
    ROUND(t.index_length/1024/1024,2) AS index_mb,
    ROUND(t.data_free/1024/1024,2) AS free_mb,
    ROUND(t.index_length/t.data_length,2) AS index_ratio,
    ROUND(t.data_free/(t.data_length+t.index_length)*100,2) AS fragment_pct
FROM information_schema.tables t
WHERE t.table_schema = DATABASE()
    AND t.table_type = 'BASE TABLE'
ORDER BY t.index_length DESC;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🔸 索引存储结构基础**
```
页面结构：MySQL存储的基本单位，16KB大小
页头信息：包含页面管理的关键元数据
记录格式：索引键值和指针的存储方式
页目录：实现页面内快速定位的机制
```

### 10.2 关键理解要点


**💡 存储结构的设计原理**
```
分层存储：
• 页面是存储基本单位
• 页内通过页目录实现快速查找
• 页间通过B+树结构连接

空间管理：
• 页头记录空间使用情况
• 空闲空间通过链表管理
• 分裂合并维护空间利用率
```

**💡 性能影响因素**
```
查找效率：
• 页目录支持二分查找
• 记录有序排列便于范围查询
• 页面缓存提高访问速度

空间效率：
• 页面填充率影响存储效率
• 碎片影响空间利用率
• 合理设计减少空间浪费
```

### 10.3 实际应用价值


**🎯 性能优化指导**
```
索引设计优化：
• 选择合适的数据类型减少记录大小
• 联合索引顺序影响存储效率
• 主键设计影响页面分裂频率

维护策略制定：
• 根据碎片率制定清理计划
• 监控页面分裂频率
• 定期更新统计信息

容量规划：
• 准确估算索引空间需求
• 预测数据增长对存储的影响
• 制定合理的硬件配置方案
```

### 10.4 常见问题与解决


**⚠️ 性能问题诊断**
```
页面分裂过多：
原因：随机插入、UUID主键、页面过小
解决：使用自增主键、批量插入、调整页面大小

碎片率过高：
原因：频繁删除更新、页面合并不及时
解决：定期OPTIMIZE、重建索引、优化删除策略

统计信息不准：
原因：自动更新滞后、采样不足
解决：手动ANALYZE、调整统计参数
```

**核心记忆要点**：
- 索引存储以页面为单位，页头管理元信息
- 页目录实现快速定位，记录格式影响存储效率  
- 分裂合并维护空间，碎片管理关系性能
- 统计信息指导优化，监控维护保障稳定