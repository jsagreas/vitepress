---
title: 28、索引失效原因
---
## 📚 目录

1. [索引失效基本概念](#1-索引失效基本概念)
2. [函数运算导致失效](#2-函数运算导致失效)
3. [数据类型转换问题](#3-数据类型转换问题)
4. [模糊查询限制](#4-模糊查询限制)
5. [不等于操作影响](#5-不等于操作影响)
6. [NULL值处理问题](#6-NULL值处理问题)
7. [OR条件影响](#7-OR条件影响)
8. [复合索引失效场景](#8-复合索引失效场景)
9. [索引失效检测方法](#9-索引失效检测方法)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 索引失效基本概念


### 1.1 什么是索引失效


**通俗理解**：索引失效就像图书馆的目录册突然不能用了，你明明建了索引，但查询时MySQL却不用它，还是要全表扫描。

```
生活例子：
你在图书馆找书：
✅ 正常情况：先查目录册，直接定位到书架位置  
❌ 索引失效：目录册用不了，只能一排排书架去找

MySQL中：
✅ 使用索引：直接定位到数据行，速度快
❌ 索引失效：扫描整个表，速度慢
```

### 1.2 索引失效的影响


**性能对比**：
```
数据量：100万条记录

使用索引查询：
- 扫描行数：1-100行
- 查询时间：0.01秒

索引失效后：
- 扫描行数：100万行  
- 查询时间：2-5秒

性能差距：200-500倍！
```

### 1.3 常见失效场景概览


```
索引失效的主要原因：
┌─────────────────────┐
│ 1. 函数运算         │ ← WHERE function(column) = value
├─────────────────────┤
│ 2. 数据类型转换     │ ← WHERE varchar_col = 123
├─────────────────────┤  
│ 3. 字符集不匹配     │ ← 不同字符集表关联
├─────────────────────┤
│ 4. 模糊查询         │ ← WHERE col LIKE '%abc'
├─────────────────────┤
│ 5. 不等于操作       │ ← WHERE col != value
├─────────────────────┤
│ 6. NULL值处理       │ ← WHERE col IS NULL
├─────────────────────┤
│ 7. OR条件           │ ← WHERE col1 = ? OR col2 = ?
├─────────────────────┤
│ 8. 复合索引破坏     │ ← 违反最左前缀原则
└─────────────────────┘
```

---

## 2. 🔧 函数运算导致失效


### 2.1 为什么函数会导致失效


**问题根源**：MySQL无法预知函数的结果，只能对每一行数据执行函数后再比较。

```
错误写法：
SELECT * FROM users WHERE YEAR(birthday) = 1990;

问题分析：
1. MySQL需要对每一行的birthday字段执行YEAR()函数
2. 索引存储的是原始的birthday值，不是YEAR()的结果
3. 无法利用索引快速定位，只能全表扫描

就像：你要求图书管理员找"书名长度为10个字符的书"
他必须把每本书都拿出来数一遍字符数
```

### 2.2 常见函数失效案例


**日期函数失效**：
```sql
-- ❌ 错误写法 - 索引失效
SELECT * FROM orders WHERE YEAR(order_date) = 2023;
SELECT * FROM users WHERE DATE(created_at) = '2023-01-01';

-- ✅ 正确写法 - 使用索引
SELECT * FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2024-01-01';
SELECT * FROM users WHERE created_at >= '2023-01-01' AND created_at < '2023-01-02';
```

**字符串函数失效**：
```sql
-- ❌ 错误写法
SELECT * FROM users WHERE UPPER(name) = 'JOHN';
SELECT * FROM products WHERE LENGTH(title) > 50;

-- ✅ 正确写法
SELECT * FROM users WHERE name = 'JOHN';  -- 如果确定大小写
-- 或使用不区分大小写的排序规则
```

**数学函数失效**：
```sql
-- ❌ 错误写法
SELECT * FROM products WHERE price * 0.8 > 100;

-- ✅ 正确写法
SELECT * FROM products WHERE price > 100 / 0.8;  -- price > 125
```

### 2.3 解决方案


**方案1：改写查询条件**
```sql
-- 将函数应用于条件值，而不是字段
-- 例：查找1990年出生的用户
-- 改写前：WHERE YEAR(birthday) = 1990
-- 改写后：
WHERE birthday >= '1990-01-01' AND birthday <= '1990-12-31'
```

**方案2：使用计算列索引**
```sql
-- 为函数结果创建索引
ALTER TABLE users ADD COLUMN birth_year INT AS (YEAR(birthday));
CREATE INDEX idx_birth_year ON users(birth_year);

-- 查询时使用计算列
SELECT * FROM users WHERE birth_year = 1990;
```

---

## 3. 🔄 数据类型转换问题


### 3.1 隐式类型转换的危害


**问题解释**：就像你用英语问路，对方只会中文，需要翻译才能理解，这个翻译过程让沟通变慢。

```
场景演示：
表结构：phone VARCHAR(11)
索引：CREATE INDEX idx_phone ON users(phone);

-- ❌ 发生隐式转换
SELECT * FROM users WHERE phone = 13800138000;

执行过程：
1. MySQL发现phone是字符串，条件值是数字
2. 将字符串转换为数字：CAST(phone AS UNSIGNED)
3. 相当于：WHERE CAST(phone AS UNSIGNED) = 13800138000
4. 索引失效，因为对phone字段使用了函数
```

### 3.2 常见类型转换场景


**字符串与数字转换**：
```sql
-- 表结构
CREATE TABLE users (
    id INT,
    phone VARCHAR(11),
    age INT
);

-- ❌ 错误写法 - 发生转换
SELECT * FROM users WHERE phone = 13800138000;    -- 数字查字符串
SELECT * FROM users WHERE age = '25';             -- 字符串查数字

-- ✅ 正确写法 - 类型匹配
SELECT * FROM users WHERE phone = '13800138000';  -- 字符串查字符串
SELECT * FROM users WHERE age = 25;               -- 数字查数字
```

**日期类型转换**：
```sql
-- ❌ 可能发生转换
SELECT * FROM orders WHERE created_at = '2023-01-01';

-- ✅ 明确指定类型
SELECT * FROM orders WHERE created_at = DATE('2023-01-01');
```

### 3.3 检测类型转换


**使用EXPLAIN查看警告**：
```sql
-- 执行查询
EXPLAIN SELECT * FROM users WHERE phone = 13800138000;

-- 查看警告信息
SHOW WARNINGS;

-- 可能看到：
-- | Warning | 1292 | Truncated incorrect DOUBLE value: '13800138000a' |
```

### 3.4 字符集转换问题


**不同字符集关联**：
```sql
-- 表A使用utf8字符集
-- 表B使用utf8mb4字符集

-- ❌ 可能发生字符集转换
SELECT * FROM table_a a 
JOIN table_b b ON a.name = b.name;

-- 解决方案：统一字符集
ALTER TABLE table_a CONVERT TO CHARACTER SET utf8mb4;
```

---

## 4. 🔍 模糊查询限制


### 4.1 LIKE查询的索引使用规则


**通俗理解**：就像查字典，你知道单词的开头字母可以快速定位，但如果只知道中间或结尾的字母就很难找。

```
字典查找类比：
✅ 查找"abc"开头的单词 → 直接翻到A部分的abc区域
❌ 查找包含"abc"的单词 → 需要翻遍整本字典
❌ 查找"abc"结尾的单词 → 需要翻遍整本字典

MySQL索引：
✅ name LIKE 'abc%'     → 可以使用索引
❌ name LIKE '%abc'     → 索引失效
❌ name LIKE '%abc%'    → 索引失效
```

### 4.2 LIKE查询的具体场景


**可以使用索引的情况**：
```sql
-- ✅ 前缀匹配 - 可以使用索引
SELECT * FROM users WHERE name LIKE 'John%';
SELECT * FROM products WHERE title LIKE 'iPhone%';

-- 索引扫描过程：
-- 1. 定位到以'John'开头的第一条记录
-- 2. 顺序扫描直到不再以'John'开头
-- 3. 效率很高
```

**无法使用索引的情况**：
```sql
-- ❌ 后缀匹配 - 索引失效
SELECT * FROM users WHERE name LIKE '%son';

-- ❌ 中间包含 - 索引失效  
SELECT * FROM users WHERE name LIKE '%oh%';

-- 原因：索引是按字符串顺序排列的
-- 无法直接定位到包含特定子串的记录
```

### 4.3 模糊查询优化方案


**方案1：改写查询逻辑**
```sql
-- 如果业务允许，尽量使用前缀匹配
-- 例：搜索手机号
-- 改写前：WHERE phone LIKE '%1380%'
-- 改写后：WHERE phone LIKE '1380%'  -- 如果是按号段搜索
```

**方案2：使用全文索引**
```sql
-- 创建全文索引
ALTER TABLE articles ADD FULLTEXT(title, content);

-- 使用全文搜索
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL索引' IN NATURAL LANGUAGE MODE);
```

**方案3：使用专门的搜索引擎**
```
对于复杂的文本搜索需求：
- Elasticsearch：分布式全文搜索
- Solr：企业级搜索平台
- 数据库 + 搜索引擎的混合架构
```

---

## 5. ❗ 不等于操作影响


### 5.1 为什么不等于难以使用索引


**问题本质**：不等于条件筛选出来的数据通常很多，MySQL认为全表扫描可能更快。

```
生活例子：
在图书馆找"不是小说类的书"：
- 小说类可能只占20%的书架
- 不是小说类的占80%的书架
- 与其用目录册找80%的书，不如直接扫描所有书架

MySQL的考虑：
- 如果不等于条件匹配大部分数据
- 走索引需要回表查询很多次
- 全表扫描可能更高效
```

### 5.2 不等于操作的具体情况


**!=和<>操作符**：
```sql
-- ❌ 通常不会使用索引
SELECT * FROM users WHERE status != 'active';
SELECT * FROM orders WHERE amount <> 0;

-- 原因分析：
-- 假设status = 'active'的记录只占10%
-- 那么status != 'active'要返回90%的数据
-- MySQL认为全表扫描更合适
```

**NOT IN操作**：
```sql
-- ❌ 通常不会使用索引
SELECT * FROM users WHERE id NOT IN (1, 2, 3);
SELECT * FROM products WHERE category_id NOT IN (10, 20);
```

### 5.3 优化不等于查询


**方案1：转换为等值查询**
```sql
-- 如果不等于的值种类有限，可以转换
-- 改写前：
SELECT * FROM users WHERE status != 'deleted';

-- 改写后：
SELECT * FROM users WHERE status IN ('active', 'inactive', 'pending');
```

**方案2：使用EXISTS**
```sql
-- 改写前：
SELECT * FROM orders WHERE customer_id NOT IN (
    SELECT id FROM blacklist_customers
);

-- 改写后：
SELECT * FROM orders o
WHERE NOT EXISTS (
    SELECT 1 FROM blacklist_customers b 
    WHERE b.id = o.customer_id
);
```

**方案3：分析数据分布**
```sql
-- 检查数据分布，确定是否适合使用索引
SELECT status, COUNT(*) 
FROM users 
GROUP BY status;

-- 如果不等于条件筛选的数据量很小，可以强制使用索引
SELECT * FROM users FORCE INDEX(idx_status) WHERE status != 'active';
```

---

## 6. 🔄 NULL值处理问题


### 6.1 NULL值与索引的关系


**重要概念**：MySQL中的NULL是"未知"的意思，不是空字符串或0。

```
NULL的特殊性：
- NULL != NULL  （结果是NULL，不是true）
- NULL = NULL   （结果是NULL，不是true）
- NULL与任何值比较都是NULL

索引中的NULL：
- 大多数索引会存储NULL值
- 但NULL值的比较有特殊规则
```

### 6.2 NULL值查询的索引使用


**IS NULL可以使用索引**：
```sql
-- ✅ 可以使用索引
SELECT * FROM users WHERE email IS NULL;

-- 索引扫描过程：
-- 1. 索引中NULL值通常排在最前面或最后面
-- 2. 可以快速定位到NULL值的范围
-- 3. 效率较高
```

**IS NOT NULL的特殊情况**：
```sql
-- 🤔 是否使用索引取决于NULL值的比例
SELECT * FROM users WHERE email IS NOT NULL;

-- 如果NULL值很少：可能使用索引
-- 如果NULL值很多：可能全表扫描
```

### 6.3 NULL值相关的优化


**避免NULL值的设计**：
```sql
-- 设计表时尽量避免NULL
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL DEFAULT '',
    email VARCHAR(100) NOT NULL DEFAULT '',
    status ENUM('active', 'inactive') NOT NULL DEFAULT 'active'
);
```

**NULL值的查询优化**：
```sql
-- 如果业务允许，将NULL值替换为特殊值
UPDATE users SET email = '' WHERE email IS NULL;

-- 查询时使用等值比较
SELECT * FROM users WHERE email = '';
```

---

## 7. 🔀 OR条件影响


### 7.1 OR条件的索引使用规律


**核心规则**：OR条件中所有字段都必须有索引，否则整个查询无法使用索引。

```
OR条件的逻辑：
WHERE col1 = 'A' OR col2 = 'B'

MySQL的处理方式：
1. 如果col1和col2都有索引：可能使用索引合并
2. 如果只有col1有索引：索引失效，全表扫描
3. 如果都没有索引：全表扫描

就像两个入口的检查：
- 两个入口都有快速通道：可以快速通过
- 只有一个入口有快速通道：所有人都要走慢通道
```

### 7.2 OR条件的具体场景


**索引失效的情况**：
```sql
-- 假设只有name字段有索引，email没有索引
-- ❌ 索引失效
SELECT * FROM users WHERE name = 'John' OR email = 'john@email.com';

-- 原因：email没有索引，MySQL只能全表扫描
```

**可能使用索引的情况**：
```sql
-- 假设name和email都有索引
-- ✅ 可能使用索引合并
SELECT * FROM users WHERE name = 'John' OR email = 'john@email.com';

-- MySQL可能的执行策略：
-- 1. 使用name索引找到name='John'的记录
-- 2. 使用email索引找到email='john@email.com'的记录  
-- 3. 合并结果并去重
```

### 7.3 OR条件的优化方案


**方案1：改写为UNION**
```sql
-- 改写前：
SELECT * FROM users WHERE name = 'John' OR email = 'john@email.com';

-- 改写后：
SELECT * FROM users WHERE name = 'John'
UNION
SELECT * FROM users WHERE email = 'john@email.com';

-- 优势：每个子查询都能使用对应的索引
```

**方案2：确保所有OR字段都有索引**
```sql
-- 为OR条件中的所有字段创建索引
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_email ON users(email);
```

**方案3：使用IN替代某些OR条件**
```sql
-- 改写前：
SELECT * FROM users WHERE status = 'active' OR status = 'pending';

-- 改写后：
SELECT * FROM users WHERE status IN ('active', 'pending');
```

---

## 8. 🔗 复合索引失效场景


### 8.1 最左前缀原则详解


**通俗理解**：复合索引就像电话簿，按姓氏+名字排序。你可以用姓氏找人，但不能只用名字找人。

```
复合索引：(name, age, city)
索引结构类似：
('张三', 25, '北京')
('张三', 30, '上海')  
('张四', 20, '广州')
('李五', 35, '深圳')

✅ 可以使用索引的查询：
- WHERE name = '张三'                    （用到name）
- WHERE name = '张三' AND age = 25       （用到name, age）
- WHERE name = '张三' AND city = '北京'   （用到name）

❌ 无法使用索引的查询：
- WHERE age = 25                        （跳过了name）
- WHERE city = '北京'                   （跳过了name）
- WHERE age = 25 AND city = '北京'       （跳过了name）
```

### 8.2 复合索引失效的具体场景


**跳过前缀字段**：
```sql
-- 复合索引：(name, age, city)

-- ❌ 索引失效 - 跳过最左字段
SELECT * FROM users WHERE age = 25;
SELECT * FROM users WHERE city = '北京';

-- ✅ 可以使用索引
SELECT * FROM users WHERE name = '张三';
SELECT * FROM users WHERE name = '张三' AND age = 25;
```

**中间字段使用范围查询**：
```sql
-- 复合索引：(name, age, city)

-- 🤔 部分使用索引
SELECT * FROM users WHERE name = '张三' AND age > 25 AND city = '北京';

-- 解析：
-- ✅ name = '张三' 使用索引
-- ✅ age > 25 使用索引  
-- ❌ city = '北京' 无法使用索引（因为age用了范围查询）
```

**字段顺序错误**：
```sql
-- 复合索引：(name, age, city)

-- ✅ 字段顺序无关紧要，MySQL会优化
SELECT * FROM users WHERE age = 25 AND name = '张三';
-- 等价于：WHERE name = '张三' AND age = 25

-- 但是跳过字段仍然无效：
-- ❌ 即使调整顺序也无法使用索引
SELECT * FROM users WHERE age = 25 AND city = '北京';
```

### 8.3 复合索引优化策略


**策略1：调整索引字段顺序**
```sql
-- 根据查询频率和选择性调整字段顺序
-- 选择性高的字段放前面

-- 分析字段选择性：
SELECT 
    COUNT(DISTINCT name) / COUNT(*) as name_selectivity,
    COUNT(DISTINCT age) / COUNT(*) as age_selectivity,
    COUNT(DISTINCT city) / COUNT(*) as city_selectivity
FROM users;

-- 如果name选择性最高，age其次，city最低
-- 最优顺序：(name, age, city)
```

**策略2：创建多个索引覆盖不同查询模式**
```sql
-- 主要查询模式：
-- 1. WHERE name = ? AND age = ?
-- 2. WHERE city = ? AND age = ?

-- 创建对应的索引：
CREATE INDEX idx_name_age ON users(name, age);
CREATE INDEX idx_city_age ON users(city, age);
```

**策略3：使用覆盖索引**
```sql
-- 如果查询只需要索引中的字段，避免回表
-- 复合索引：(name, age, city)

-- ✅ 覆盖索引查询
SELECT name, age FROM users WHERE name = '张三';
-- 无需回表，直接从索引获取数据
```

---

## 9. 🔍 索引失效检测方法


### 9.1 使用EXPLAIN分析


**基本用法**：
```sql
-- 检查查询是否使用索引
EXPLAIN SELECT * FROM users WHERE name = 'John';

-- 关键字段解读：
-- type: 连接类型，const/eq_ref/ref较好，ALL最差
-- key: 实际使用的索引名称，NULL表示未使用索引
-- rows: 估计扫描的行数，越少越好
-- Extra: 额外信息，"Using index"表示覆盖索引
```

**EXPLAIN输出示例**：
```
+----+-------+------+------+-------+------+------+
| id | type  | key  | rows | Extra                |
+----+-------+------+------+-------+------+------+
| 1  | const | name | 1    | Using index          | ← 很好
| 1  | ALL   | NULL | 1000 | Using where          | ← 很差
+----+-------+------+------+-------+------+------+
```

### 9.2 使用SHOW WARNINGS


**查看优化器警告**：
```sql
-- 执行查询
EXPLAIN SELECT * FROM users WHERE phone = 13800138000;

-- 查看警告
SHOW WARNINGS;

-- 可能的警告信息：
-- 类型转换警告
-- 索引提示
-- 优化器建议
```

### 9.3 监控慢查询日志


**启用慢查询日志**：
```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 超过1秒的查询

-- 查看慢查询日志文件
-- Linux: /var/log/mysql/mysql-slow.log
```

### 9.4 使用Performance Schema


**监控索引使用情况**：
```sql
-- 查看从未使用的索引
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE count_star = 0
AND object_schema != 'mysql'
ORDER BY object_schema, object_name;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的索引失效原因


```
🔸 函数运算：WHERE function(column) = value 导致索引失效
🔸 类型转换：字符串与数字不匹配引起隐式转换  
🔸 模糊查询：LIKE '%abc' 和 LIKE '%abc%' 无法使用索引
🔸 不等于操作：!= 和 <> 通常不使用索引
🔸 OR条件：所有OR字段都必须有索引
🔸 复合索引：必须遵循最左前缀原则
```

### 10.2 关键优化策略


**🔹 查询条件优化**
```
避免对索引字段使用函数 → 改写查询条件
确保数据类型匹配 → 避免隐式转换  
使用前缀匹配 → LIKE 'abc%' 而不是 LIKE '%abc'
转换不等于条件 → 使用IN或EXISTS替代
```

**🔹 索引设计优化**
```
复合索引字段顺序 → 高选择性字段在前
覆盖索引设计 → 减少回表查询
删除无用索引 → 减少维护开销
监控索引使用情况 → 及时发现问题
```

### 10.3 检测和监控方法


**🔹 实时检测工具**
- **EXPLAIN**：分析查询执行计划
- **SHOW WARNINGS**：查看优化器警告
- **慢查询日志**：发现性能问题
- **Performance Schema**：监控索引使用

**🔹 日常监控指标**
```
关键指标：
• 慢查询数量和频率
• 全表扫描的查询
• 未使用的索引
• 索引选择性分析
```

### 10.4 实际应用建议


**开发阶段**：
- 编写SQL时注意索引失效规则
- 使用EXPLAIN验证查询计划
- 避免常见的索引失效写法

**测试阶段**：
- 模拟生产数据量测试
- 监控慢查询和索引使用
- 优化发现的性能问题

**生产阶段**：
- 持续监控慢查询日志
- 定期分析索引使用情况
- 及时优化性能瓶颈

**核心记忆**：
- 索引失效如同地图失效，明明有路却不会走
- 函数类型OR是三大杀手，最左前缀不能破
- EXPLAIN是最好的朋友，慢查询是最大的敌人
- 预防胜于治疗，监控重于优化