---
title: 9、单列索引设计
---
## 📚 目录

1. [单列索引基础概念](#1-单列索引基础概念)
2. [索引列选择标准](#2-索引列选择标准)
3. [查询频率分析与评估](#3-查询频率分析与评估)
4. [选择性评估机制](#4-选择性评估机制)
5. [数据分布对索引的影响](#5-数据分布对索引的影响)
6. [索引创建与命名规范](#6-索引创建与命名规范)
7. [索引长度与数据类型优化](#7-索引长度与数据类型优化)
8. [空值处理机制](#8-空值处理机制)
9. [索引维护成本分析](#9-索引维护成本分析)
10. [性能提升评估方法](#10-性能提升评估方法)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 单列索引基础概念


### 1.1 什么是单列索引


> 💡 **简单理解**：单列索引就像书的目录，帮你快速找到想要的内容，只不过这个目录是基于表中的某一个字段建立的

**单列索引（Single Column Index）**：针对数据表中的**一个字段**创建的索引结构。

```
传统查询方式（无索引）：
┌─────────────────────────────────┐
│ 用户表 users                    │
├─────┬──────────┬─────────┬──────┤
│ id  │ username │ email   │ age  │
├─────┼──────────┼─────────┼──────┤
│ 1   │ alice    │ a@qq    │ 25   │ ← 逐行扫描
│ 2   │ bob      │ b@qq    │ 30   │ ← 逐行扫描  
│ 3   │ charlie  │ c@qq    │ 28   │ ← 逐行扫描
│ ... │ ...      │ ...     │ ...  │ ← 全表扫描
└─────┴──────────┴─────────┴──────┘

带索引查询方式：
索引树 (username字段)      实际数据
      bob                    ↓
     /   \                直接定位到第2行
  alice  charlie           快速找到结果
```

### 1.2 单列索引的工作原理


**核心机制**：MySQL将索引列的值按照**特定顺序**组织成一个**高效的数据结构**（通常是B+树），每个索引项都指向对应的数据行。

```
B+树索引结构示意：
            [M]
          /     \
      [C,F]     [S,W]
     /  |  \   /  |  \
   [A] [D] [H] [P] [T] [Z]
    |   |   |   |   |   |
   行1 行4 行7 行12 行18 行25
```

> 📖 **关键理解**：索引不是魔法，它本质上是一个**排好序的数据副本**，通过有序性实现快速查找

### 1.3 单列索引 vs 其他索引类型


| 索引类型 | **字段数量** | **使用场景** | **优点** | **缺点** |
|---------|-------------|-------------|----------|----------|
| 🔸 **单列索引** | `1个字段` | `简单条件查询` | `创建简单，维护成本低` | `只能优化单字段查询` |
| 🔸 **复合索引** | `多个字段` | `多条件查询` | `覆盖多种查询模式` | `创建复杂，维护成本高` |
| 🔸 **唯一索引** | `1个或多个` | `保证数据唯一性` | `约束+性能双重作用` | `限制数据插入` |
| 🔸 **主键索引** | `1个或多个` | `行记录唯一标识` | `InnoDB默认聚簇索引` | `每表只能有一个` |

---

## 2. 📊 索引列选择标准


### 2.1 核心选择原则


> ⚠️ **重要提醒**：不是所有字段都适合建索引，选错了反而会拖慢数据库性能！

**选择索引列的四大标准**：

```
1. 查询频率高    ← 经常用于WHERE条件的字段
2. 选择性好      ← 重复值少的字段  
3. 数据稳定      ← 不经常更新的字段
4. 数据类型合适  ← 整数比字符串更适合
```

### 2.2 查询频率评估


**🔍 如何判断字段查询频率**：

```sql
-- 示例：分析用户表的查询模式
-- 高频查询场景
SELECT * FROM users WHERE email = 'user@example.com';     ← email字段高频
SELECT * FROM users WHERE username = 'alice';             ← username字段高频
SELECT * FROM users WHERE created_at > '2024-01-01';      ← created_at字段高频

-- 低频查询场景  
SELECT * FROM users WHERE description LIKE '%keyword%';    ← description字段低频
SELECT * FROM users WHERE last_login IS NULL;             ← last_login字段低频
```

> 🔧 **实践建议**：观察应用程序的SQL日志，统计每个字段在WHERE子句中出现的频率

### 2.3 业务场景分析


**常见业务场景的索引策略**：

```
🔸 用户系统
优先索引：email, username, phone  
原因：登录验证、用户查找的核心字段

🔸 订单系统  
优先索引：order_no, user_id, status, created_at
原因：订单查询、状态筛选、时间范围查询

🔸 商品系统
优先索引：category_id, status, price, created_at  
原因：分类浏览、价格排序、上架时间查询
```

---

## 3. 🔎 查询频率分析与评估


### 3.1 SQL日志分析方法


**如何收集查询频率数据**：

```sql
-- 1. 开启慢查询日志
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 0.1;  -- 记录超过0.1秒的查询

-- 2. 开启通用查询日志（短期开启）
SET GLOBAL general_log = 1;

-- 3. 使用Performance Schema分析
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000 as avg_time_sec
FROM performance_schema.events_statements_summary_by_digest 
WHERE DIGEST_TEXT LIKE '%WHERE%'
ORDER BY COUNT_STAR DESC;
```

### 3.2 查询模式识别


**典型查询模式分析**：

```
等值查询模式：
WHERE user_id = 123                    ← 最适合单列索引
WHERE status = 'active'                ← 选择性要考虑

范围查询模式：  
WHERE created_at > '2024-01-01'        ← 时间范围查询
WHERE price BETWEEN 100 AND 500       ← 价格区间查询

模糊查询模式：
WHERE title LIKE '关键词%'             ← 前缀匹配可用索引
WHERE title LIKE '%关键词%'            ← 中间匹配无法用索引
```

> 📝 **记忆技巧**：`LIKE '关键词%'` 可以用索引，`LIKE '%关键词%'` 用不了索引

### 3.3 查询频率量化评估


```
查询频率分级标准：
🔥 高频（> 1000次/天）   ← 必须建索引
🔸 中频（100-1000次/天） ← 建议建索引  
🔹 低频（< 100次/天）    ← 谨慎建索引
❄️ 极低频（< 10次/天）   ← 不建议建索引
```

---

## 4. 📈 选择性评估机制


### 4.1 什么是索引选择性


> 💡 **通俗解释**：选择性就是看这个字段的值有多"独特"，越独特的字段建索引效果越好

**选择性（Selectivity）**：指索引列中**不重复值的数量**与**总记录数**的比值。

```
选择性计算公式：
选择性 = 不重复值数量 ÷ 总记录数

示例计算：
用户表 users (10000条记录)
├─ email字段：9998个不重复值    选择性 = 9998/10000 = 0.9998  ← 极高选择性
├─ username字段：9995个不重复值  选择性 = 9995/10000 = 0.9995  ← 极高选择性  
├─ city字段：50个不重复值       选择性 = 50/10000 = 0.005    ← 低选择性
└─ gender字段：2个不重复值      选择性 = 2/10000 = 0.0002   ← 极低选择性
```

### 4.2 选择性评估SQL


```sql
-- 计算字段选择性的标准方法
SELECT 
    COUNT(DISTINCT column_name) as unique_count,
    COUNT(*) as total_count,
    COUNT(DISTINCT column_name) / COUNT(*) as selectivity,
    CASE 
        WHEN COUNT(DISTINCT column_name) / COUNT(*) > 0.8 THEN '极高选择性-强烈建议建索引'
        WHEN COUNT(DISTINCT column_name) / COUNT(*) > 0.3 THEN '中等选择性-建议建索引'
        WHEN COUNT(DISTINCT column_name) / COUNT(*) > 0.1 THEN '低选择性-谨慎建索引'
        ELSE '极低选择性-不建议建索引'
    END as recommendation
FROM table_name;

-- 批量分析多个字段的选择性
SELECT 
    'email' as column_name,
    COUNT(DISTINCT email) / COUNT(*) as selectivity
FROM users
UNION ALL
SELECT 
    'city' as column_name,
    COUNT(DISTINCT city) / COUNT(*) as selectivity  
FROM users
UNION ALL
SELECT 
    'gender' as column_name,
    COUNT(DISTINCT gender) / COUNT(*) as selectivity
FROM users;
```

### 4.3 选择性判断标准


```
选择性等级划分：
📊 选择性 > 0.8   ← 极高选择性，强烈推荐建索引
📊 选择性 0.3-0.8 ← 中等选择性，建议建索引
📊 选择性 0.1-0.3 ← 低选择性，谨慎建索引  
📊 选择性 < 0.1   ← 极低选择性，不推荐建索引
```

> ⚠️ **特殊情况**：即使选择性低，如果查询频率极高且业务需要，仍可考虑建索引

---

## 5. 📊 数据分布对索引的影响


### 5.1 数据分布模式分析


**数据分布直接影响索引效果**：

```
均匀分布（理想情况）：
值域：1-100，每个值出现100次
索引效果：最佳，查询性能稳定

┌─────────────────────────────────┐
│ 1:100 2:100 3:100 ... 100:100  │ ← 每个值出现次数相同
└─────────────────────────────────┘

倾斜分布（常见情况）：
值域：状态字段 active:9000, inactive:800, pending:200  
索引效果：查询'active'效率低，查询'pending'效率高

┌─────────────────────────────────┐
│ active:█████████████████████    │ ← 热点数据
│ inactive:███                    │ ← 中等数据
│ pending:█                       │ ← 冷门数据
└─────────────────────────────────┘
```

### 5.2 热点数据问题


> 🔥 **热点数据**：某些值出现频率特别高，导致索引效率下降

**热点数据识别方法**：

```sql
-- 分析数据分布，找出热点值
SELECT 
    status,
    COUNT(*) as count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders) as percentage
FROM orders 
GROUP BY status 
ORDER BY count DESC;

-- 结果示例：
-- status    | count | percentage
-- active    | 85000 | 85.0%      ← 热点数据
-- pending   | 10000 | 10.0%      
-- cancelled | 5000  | 5.0%
```

### 5.3 解决数据倾斜的策略


```
策略1：复合索引优化
CREATE INDEX idx_status_created ON orders(status, created_at);
-- 即使status选择性低，加上时间字段可提高整体选择性

策略2：分区表设计  
-- 按热点字段进行分区，分散数据
PARTITION BY LIST(status) (
    PARTITION p_active VALUES IN ('active'),
    PARTITION p_others VALUES IN ('pending', 'cancelled')
);

策略3：业务逻辑优化
-- 避免直接查询热点值，改用时间范围+状态组合查询
WHERE status = 'active' AND created_at > '2024-01-01'
```

---

## 6. 🔧 索引创建与命名规范


### 6.1 索引创建语法详解


**基础创建语法**：

```sql
-- 标准单列索引创建语法
CREATE INDEX 索引名称 ON 表名(列名);

-- 具体示例
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_products_category_id ON products(category_id);

-- 创建时指定索引方法（通常让MySQL自动选择）
CREATE INDEX idx_users_created_at ON users(created_at) USING BTREE;

-- 删除索引
DROP INDEX idx_users_email ON users;
-- 或者使用ALTER语句
ALTER TABLE users DROP INDEX idx_users_email;
```

### 6.2 索引命名规范


> 📝 **命名规范**：好的命名让团队协作更高效，维护更轻松

**推荐命名规范**：

```
命名格式：idx_[表名]_[字段名]_[可选说明]

标准示例：
✅ idx_users_email          ← 用户表email字段索引
✅ idx_orders_user_id       ← 订单表用户ID索引  
✅ idx_products_status      ← 商品表状态索引
✅ idx_logs_created_at      ← 日志表创建时间索引

复杂场景：
✅ idx_orders_status_active ← 特定于active状态的部分索引
✅ idx_users_email_unique   ← 唯一邮箱索引
✅ idx_products_name_text   ← 文本搜索索引

避免的命名：
❌ index1, index2           ← 无意义的序号
❌ user_index              ← 不明确的通用名称
❌ idx                     ← 过于简短
```

### 6.3 索引创建最佳实践


```sql
-- 1. 在非高峰期创建索引
CREATE INDEX idx_users_phone ON users(phone);

-- 2. 创建索引时使用ALGORITHM和LOCK选项（MySQL 5.6+）
CREATE INDEX idx_orders_created_at 
ON orders(created_at) 
ALGORITHM=INPLACE, LOCK=NONE;

-- 3. 创建前检查是否已存在类似索引
SHOW INDEX FROM users WHERE Column_name = 'email';

-- 4. 批量创建多个索引（减少表重建次数）
ALTER TABLE products 
ADD INDEX idx_products_category_id (category_id),
ADD INDEX idx_products_status (status),
ADD INDEX idx_products_price (price);
```

---

## 7. 📏 索引长度与数据类型优化


### 7.1 索引长度限制机制


> 📐 **索引长度**：MySQL对索引键的长度有限制，超过限制会影响性能或报错

**MySQL索引长度限制**：

```
InnoDB引擎限制：
├─ 单个索引键最大长度：3072字节 (MySQL 8.0)
├─ 单个索引键最大长度：767字节 (MySQL 5.6及之前)
├─ 复合索引总长度：3072字节
└─ 前缀索引：可指定使用字段的前N个字符

MyISAM引擎限制：  
├─ 单个索引键最大长度：1000字节
└─ 复合索引总长度：1000字节
```

### 7.2 字符串字段的前缀索引


**什么时候使用前缀索引**：

```sql
-- 场景：邮箱字段很长，但前缀已足够区分
-- 分析前缀长度的选择性
SELECT 
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) as prefix_5,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) as prefix_10,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) as prefix_15,
    COUNT(DISTINCT email) / COUNT(*) as full_length
FROM users;

-- 结果分析：选择性接近完整字段的最短前缀
-- prefix_5: 0.65   prefix_10: 0.95   prefix_15: 0.98   full_length: 0.99

-- 创建前缀索引（选择10个字符）
CREATE INDEX idx_users_email_prefix ON users(email(10));
```

### 7.3 数据类型对索引性能的影响


**不同数据类型的索引性能对比**：

| 数据类型 | **索引性能** | **存储空间** | **比较速度** | **推荐程度** |
|---------|-------------|-------------|-------------|-------------|
| `INT` | `🔥 最优` | `4字节` | `最快` | `⭐⭐⭐⭐⭐` |
| `BIGINT` | `🔥 优秀` | `8字节` | `很快` | `⭐⭐⭐⭐` |
| `VARCHAR(短)` | `🔸 良好` | `变长+开销` | `较快` | `⭐⭐⭐` |
| `VARCHAR(长)` | `🔹 一般` | `变长+开销` | `较慢` | `⭐⭐` |
| `TEXT` | `❌ 较差` | `大+开销` | `慢` | `⭐` |

**数据类型选择建议**：

```sql
-- 推荐：使用整数类型做主键和外键
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,           -- ✅ 整数主键
    user_id INT NOT NULL,                        -- ✅ 整数外键
    order_no VARCHAR(20) NOT NULL,               -- ✅ 适当长度的字符串
    status ENUM('pending','paid','shipped')      -- ✅ 枚举类型效率高
);

-- 避免：过长的字符串字段建索引
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),                          -- ✅ 标题长度适中
    content TEXT,                                -- ❌ 内容字段不适合建普通索引
    summary VARCHAR(500)                         -- 🔸 摘要可考虑前缀索引
);

-- 前缀索引示例
CREATE INDEX idx_articles_summary ON articles(summary(100));
```

---

## 8. 🔍 空值处理机制


### 8.1 MySQL索引对NULL值的处理


> ❓ **NULL值疑惑**：很多人认为索引不能处理NULL值，这是误解！

**MySQL索引NULL值处理机制**：

```sql
-- 创建测试表
CREATE TABLE test_null (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100)
);

-- 插入包含NULL的测试数据
INSERT INTO test_null VALUES 
(1, 'Alice', 'alice@qq.com'),
(2, 'Bob', NULL),                 -- email为NULL
(3, NULL, 'charlie@qq.com'),      -- name为NULL
(4, 'David', 'david@qq.com');

-- 创建索引
CREATE INDEX idx_test_name ON test_null(name);
CREATE INDEX idx_test_email ON test_null(email);
```

### 8.2 NULL值查询的索引使用情况


```sql
-- ✅ 这些查询可以使用索引
EXPLAIN SELECT * FROM test_null WHERE name IS NULL;        -- 可以使用idx_test_name
EXPLAIN SELECT * FROM test_null WHERE email IS NOT NULL;   -- 可以使用idx_test_email  
EXPLAIN SELECT * FROM test_null WHERE name = 'Alice';      -- 可以使用idx_test_name

-- ❌ 这些查询无法高效使用索引
SELECT * FROM test_null WHERE name IS NULL OR name = 'Bob';    -- OR条件复杂
SELECT * FROM test_null WHERE IFNULL(name, '') = '';           -- 函数包装
```

> 💡 **关键理解**：MySQL索引完全支持NULL值，`IS NULL`和`IS NOT NULL`都可以使用索引

### 8.3 NULL值索引的设计考虑


**设计策略**：

```sql
-- 策略1：业务层避免NULL值
CREATE TABLE users_clean (
    id INT PRIMARY KEY,
    email VARCHAR(100) NOT NULL DEFAULT '',      -- 用空字符串代替NULL
    phone VARCHAR(20) NOT NULL DEFAULT '',       -- 用空字符串代替NULL
    status ENUM('active', 'inactive') NOT NULL DEFAULT 'active'
);

-- 策略2：接受NULL值但优化查询
CREATE TABLE users_nullable (
    id INT PRIMARY KEY,
    email VARCHAR(100),                          -- 允许NULL
    phone VARCHAR(20),                           -- 允许NULL
    is_email_provided BOOLEAN GENERATED ALWAYS AS (email IS NOT NULL)  -- 生成列
);

-- 为生成的布尔列创建索引，提高NULL/NOT NULL查询效率
CREATE INDEX idx_users_email_provided ON users_nullable(is_email_provided);
```

---

## 9. 💰 索引维护成本分析


### 9.1 索引的维护成本构成


> 💰 **成本意识**：索引不是免费的，每个索引都有维护成本！

**索引维护成本分析**：

```
索引维护成本 = 存储成本 + 写入成本 + 更新成本

1. 存储成本：
   ├─ 索引文件占用磁盘空间
   ├─ 内存中的索引页面
   └─ 备份时间和空间增加

2. 写入成本：
   ├─ INSERT时需要更新所有索引
   ├─ 索引页面分裂和合并
   └─ 写入放大效应

3. 更新成本：  
   ├─ UPDATE索引列时重新排序
   ├─ DELETE时清理索引项
   └─ 索引碎片整理
```

### 9.2 索引成本量化评估


```sql
-- 查看表和索引的存储空间占用
SELECT 
    table_name,
    ROUND((data_length + index_length) / 1024 / 1024, 2) as total_mb,
    ROUND(data_length / 1024 / 1024, 2) as data_mb,
    ROUND(index_length / 1024 / 1024, 2) as index_mb,
    ROUND(index_length / data_length * 100, 2) as index_ratio
FROM information_schema.tables 
WHERE table_schema = 'your_database'
ORDER BY index_length DESC;

-- 示例结果：
-- table_name | total_mb | data_mb | index_mb | index_ratio
-- orders     | 1250.5   | 800.2   | 450.3    | 56.3%      ← 索引占56%空间
-- users      | 345.8    | 245.1   | 100.7    | 41.1%      ← 索引占41%空间
```

### 9.3 写入性能影响测试


```sql
-- 测试索引对写入性能的影响
-- 无索引表
CREATE TABLE test_no_index (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100),
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 多索引表
CREATE TABLE test_with_index (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100), 
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_name (name),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

-- 写入性能对比测试
-- INSERT 10000条记录，比较耗时
-- 结果：多索引表的写入时间通常是无索引表的2-3倍
```

### 9.4 索引维护策略


```
索引维护最佳实践：

🔸 定期清理无用索引
-- 查找长期未使用的索引
SELECT DISTINCT
    s.schema_name,
    s.table_name, 
    s.index_name
FROM information_schema.statistics s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
    ON s.table_schema = u.object_schema 
    AND s.table_name = u.object_name
    AND s.index_name = u.index_name
WHERE u.index_name IS NULL
    AND s.index_name != 'PRIMARY';

🔸 监控索引使用情况
-- 定期检查索引的使用频率和效果

🔸 批量操作时临时删除索引
-- 大量数据导入前删除非必要索引，导入后重建
```

---

## 10. 📈 性能提升评估方法


### 10.1 索引性能测试方法


**建立索引前后的性能对比**：

```sql
-- 1. 记录建索引前的查询性能
EXPLAIN SELECT * FROM orders WHERE user_id = 12345;
-- 查看执行计划：type=ALL, rows=100000 (全表扫描)

-- 2. 创建索引
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- 3. 记录建索引后的查询性能  
EXPLAIN SELECT * FROM orders WHERE user_id = 12345;
-- 查看执行计划：type=ref, rows=23 (索引查找)

-- 4. 使用BENCHMARK函数测试查询时间
SELECT BENCHMARK(1000, (SELECT COUNT(*) FROM orders WHERE user_id = 12345));
```

### 10.2 执行计划分析要点


**EXPLAIN输出的关键指标**：

```sql
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 关键字段解读：
type: ref                    -- ✅ 使用索引查找（好）
     ALL                     -- ❌ 全表扫描（差）
     
key: idx_users_email        -- ✅ 使用了email索引
     NULL                   -- ❌ 没有使用任何索引
     
rows: 1                     -- ✅ 预估扫描1行
      100000                -- ❌ 预估扫描10万行
      
Extra: Using index          -- ✅ 覆盖索引，最优
       Using where          -- 🔸 使用WHERE过滤
       Using filesort       -- ❌ 需要额外排序
```

### 10.3 性能提升量化指标


**索引效果的量化评估**：

```
性能提升评估公式：

查询速度提升倍数 = 建索引前耗时 ÷ 建索引后耗时

扫描行数减少比例 = (建索引前扫描行数 - 建索引后扫描行数) ÷ 建索引前扫描行数 × 100%

示例计算：
建索引前：扫描100,000行，耗时2.5秒
建索引后：扫描25行，耗时0.01秒

速度提升：2.5 ÷ 0.01 = 250倍
扫描减少：(100,000 - 25) ÷ 100,000 × 100% = 99.975%
```

### 10.4 性能监控工具


```sql
-- 1. 使用Performance Schema监控索引使用
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,
    sum_timer_read/1000000000 as total_read_time_sec
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY count_read DESC;

-- 2. 查看慢查询日志
SHOW VARIABLES LIKE 'slow_query_log%';
SHOW VARIABLES LIKE 'long_query_time';

-- 3. 实时监控正在执行的查询
SHOW PROCESSLIST;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 单列索引本质：为单个字段建立的有序数据结构，加速查询
🔸 选择原则：查询频率高 + 选择性好 + 数据稳定 + 类型合适
🔸 选择性评估：不重复值比例，>0.8极佳，<0.1不推荐
🔸 命名规范：idx_[表名]_[字段名] 格式，便于管理维护
🔸 性能监控：通过EXPLAIN和Performance Schema评估效果
```

### 11.2 关键决策要点


**🔹 什么时候建单列索引**：
```
✅ WHERE条件中频繁出现的字段
✅ ORDER BY排序的字段  
✅ JOIN关联的字段
✅ 选择性 > 0.3的字段
✅ 查询频率 > 100次/天的字段
```

**🔹 什么时候不建单列索引**：
```
❌ 很少查询的字段
❌ 选择性 < 0.1的字段（如性别、状态等）
❌ 频繁更新的字段
❌ TEXT/BLOB等大字段
❌ 计算表达式中的字段
```

### 11.3 实战应用策略


**📊 索引设计流程**：
```
1. 分析业务查询模式
   ↓
2. 统计字段查询频率  
   ↓
3. 计算字段选择性
   ↓
4. 评估维护成本
   ↓
5. 创建索引并测试
   ↓
6. 持续监控和优化
```

**🔧 维护检查清单**：
```
☐ 定期检查索引使用情况
☐ 清理长期未使用的索引
☐ 监控索引占用空间比例
☐ 关注写入性能变化  
☐ 分析慢查询日志
☐ 优化查询语句配合索引
```

### 11.4 常见误区提醒


> ⚠️ **避免这些常见错误**：

```
❌ 误区1：所有字段都建索引
正确做法：只为高频查询字段建索引

❌ 误区2：索引越多越好
正确做法：平衡查询性能和维护成本

❌ 误区3：VARCHAR字段不适合建索引  
正确做法：短VARCHAR字段建索引效果很好

❌ 误区4：NULL值无法使用索引
正确做法：MySQL索引完全支持NULL值查询

❌ 误区5：建了索引就一定会使用
正确做法：查询语句要配合索引设计
```

**核心记忆口诀**：
- 高频查询选择好，单列索引效果佳
- 命名规范维护易，性能监控不可少  
- 成本效益要平衡，避免盲目建索引
- 持续优化是关键，数据驱动做决策