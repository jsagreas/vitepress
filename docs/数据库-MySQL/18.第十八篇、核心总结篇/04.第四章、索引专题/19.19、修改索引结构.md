---
title: 19、修改索引结构
---
## 📚 目录

1. [索引修改操作概述](#1-索引修改操作概述)
2. [索引重命名操作](#2-索引重命名操作)
3. [索引选项修改](#3-索引选项修改)
4. [索引列变更操作](#4-索引列变更操作)
5. [索引类型转换](#5-索引类型转换)
6. [在线修改与数据重组](#6-在线修改与数据重组)
7. [修改过程监控与回滚](#7-修改过程监控与回滚)
8. [性能测试与最佳实践](#8-性能测试与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔧 索引修改操作概述


### 1.1 什么是索引修改

**简单理解**：索引修改就是对已经存在的索引进行调整，就像给房子装修一样，不用推倒重建，只需要改变部分结构。

**索引修改的本质**：
```
传统做法：删除旧索引 → 创建新索引
现代做法：直接修改现有索引结构
优势：减少停机时间，降低对业务的影响
```

### 1.2 为什么需要修改索引

**实际业务场景**：
- 🔄 **业务需求变化**：查询模式发生改变
- 📈 **性能优化需要**：发现索引效率不高
- 🔧 **维护便利性**：索引名称不够清晰
- 📊 **存储优化**：调整索引参数节省空间

**修改vs重建对比**：
```
重建索引流程：
1. DROP INDEX old_index;     ← 删除旧索引（数据暂时无索引）
2. CREATE INDEX new_index;   ← 创建新索引（耗时较长）
风险：中间阶段查询性能严重下降

修改索引流程：
1. ALTER INDEX ... MODIFY;   ← 直接修改（保持索引可用）
风险：相对较小，大部分时间索引仍可用
```

### 1.3 索引修改的支持情况

**MySQL版本支持**：
- **MySQL 5.6+**：支持基本的在线索引修改
- **MySQL 5.7+**：增强了在线修改能力
- **MySQL 8.0+**：提供更多修改选项和更好的性能

**可修改的索引属性**：
```
✅ 支持修改：
• 索引名称
• 索引注释
• 索引可见性（MySQL 8.0+）
• 某些索引选项

⚠️ 部分支持：
• 索引列的顺序
• 索引类型（有限制）

❌ 不支持修改：
• 索引列的数据类型（需要重建）
• 主键约束类型
```

---

## 2. 🏷️ 索引重命名操作


### 2.1 索引重命名的基本语法

**核心语法**：
```sql
-- 基本重命名语法
ALTER TABLE table_name RENAME INDEX old_name TO new_name;
```

### 2.2 实际重命名示例

**场景示例**：公司员工表的索引名称不够规范

```sql
-- 查看当前索引
SHOW INDEX FROM employees;

-- 当前索引名称混乱：
-- idx1 -> 不知道是什么索引
-- index_2 -> 命名不规范
-- emp_idx -> 太简略

-- 重命名为规范名称
ALTER TABLE employees 
RENAME INDEX idx1 TO idx_employee_name;

ALTER TABLE employees 
RENAME INDEX index_2 TO idx_department_salary;

ALTER TABLE employees 
RENAME INDEX emp_idx TO idx_employee_email;
```

### 2.3 重命名注意事项

**重命名规范建议**：
```sql
-- 👍 好的索引命名规范
idx_表名_列名         -- 单列索引
idx_表名_列名1_列名2   -- 复合索引
uk_表名_列名          -- 唯一索引
pk_表名              -- 主键索引

-- 示例
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_order_user_date ON orders(user_id, order_date);
CREATE UNIQUE INDEX uk_user_phone ON users(phone);
```

**重命名限制**：
```sql
-- ❌ 不能重命名的情况
-- 1. 主键索引
ALTER TABLE users RENAME INDEX PRIMARY TO pk_users; -- 错误

-- 2. 外键关联的索引（需要先删除外键）
-- 3. 系统自动生成的某些索引
```

---

## 3. ⚙️ 索引选项修改


### 3.1 什么是索引选项

**索引选项就是索引的"配置参数"**，就像调整汽车的各种设置一样：
- **注释（COMMENT）**：给索引添加说明文字
- **可见性（INVISIBLE/VISIBLE）**：控制索引是否被优化器使用
- **算法选项**：指定索引创建的算法

### 3.2 修改索引注释

**添加或修改注释**：
```sql
-- 为索引添加有意义的注释
ALTER TABLE products 
MODIFY INDEX idx_product_price 
COMMENT '商品价格索引，用于价格范围查询和排序';

-- 查看索引注释
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    INDEX_COMMENT
FROM information_schema.STATISTICS 
WHERE TABLE_NAME = 'products';
```

### 3.3 索引可见性控制（MySQL 8.0+）

**什么是索引可见性**：
控制查询优化器是否能"看到"这个索引。就像给索引戴上"隐身衣"，数据还在，但优化器找不到它。

```sql
-- 让索引"隐身"
ALTER TABLE orders ALTER INDEX idx_order_date INVISIBLE;

-- 让索引"现身"
ALTER TABLE orders ALTER INDEX idx_order_date VISIBLE;

-- 查看索引可见性状态
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    IS_VISIBLE
FROM information_schema.STATISTICS 
WHERE TABLE_NAME = 'orders';
```

**使用场景**：
```sql
-- 🎯 测试索引效果
-- 1. 先让索引隐身，测试没有索引时的查询性能
ALTER TABLE users ALTER INDEX idx_user_age INVISIBLE;
-- 执行查询，记录执行时间

-- 2. 再让索引现身，对比性能差异
ALTER TABLE users ALTER INDEX idx_user_age VISIBLE;
-- 再次执行查询，对比性能

-- 🎯 安全删除索引
-- 先隐身观察一段时间，确认没问题再真正删除
ALTER TABLE products ALTER INDEX idx_old_field INVISIBLE;
-- 观察几天业务是否正常
-- 如果正常，再执行 DROP INDEX
```

---

## 4. 🔄 索引列变更操作


### 4.1 索引列变更的含义

**什么是索引列变更**：
就是改变索引包含哪些列，或者改变列的顺序。就像重新安排书架上书的摆放顺序。

### 4.2 添加列到现有索引

**MySQL的限制**：
```sql
-- ❌ MySQL不支持直接添加列到现有索引
-- 这样的语法是不存在的：
-- ALTER INDEX idx_user_name ADD COLUMN age;

-- ✅ 正确做法：重建索引
-- 1. 先删除旧索引
DROP INDEX idx_user_name ON users;

-- 2. 创建包含更多列的新索引
CREATE INDEX idx_user_name_age ON users(name, age);
```

### 4.3 安全的列变更策略

**在线变更策略**：
```sql
-- 📋 安全变更步骤

-- 1. 创建新的索引（不删除旧索引）
CREATE INDEX idx_user_name_age_new ON users(name, age);

-- 2. 等待新索引创建完成，测试查询性能
-- 使用 EXPLAIN 确认查询使用新索引

-- 3. 删除旧索引
DROP INDEX idx_user_name ON users;

-- 4. 重命名新索引（可选）
ALTER TABLE users RENAME INDEX idx_user_name_age_new TO idx_user_name_age;
```

### 4.4 列顺序的重要性

**为什么列顺序很重要**：
```sql
-- 示例：用户表查询模式
-- 常见查询1：按部门查找用户
SELECT * FROM users WHERE department = '技术部';

-- 常见查询2：按部门和年龄查找用户
SELECT * FROM users WHERE department = '技术部' AND age BETWEEN 25 AND 35;

-- 很少的查询：只按年龄查找
SELECT * FROM users WHERE age = 30;

-- 🎯 最优索引顺序
CREATE INDEX idx_user_dept_age ON users(department, age);
-- department在前，因为两个常见查询都用到它

-- ❌ 次优索引顺序
CREATE INDEX idx_user_age_dept ON users(age, department);
-- 这样的话，只按department查询时效果较差
```

---

## 5. 🔀 索引类型转换


### 5.1 什么是索引类型转换

**简单理解**：
索引类型转换就是把一种类型的索引改成另一种类型，就像把普通自行车改装成电动自行车。

**常见转换需求**：
- **普通索引 → 唯一索引**：发现某列数据确实是唯一的
- **唯一索引 → 普通索引**：业务需求变化，允许重复值
- **BTREE → HASH**：特定查询模式优化（较少使用）

### 5.2 普通索引转换为唯一索引

**转换步骤**：
```sql
-- 📋 安全转换步骤

-- 1. 首先检查数据唯一性
SELECT email, COUNT(*) 
FROM users 
GROUP BY email 
HAVING COUNT(*) > 1;

-- 如果有重复数据，先清理
-- 2. 删除现有普通索引
DROP INDEX idx_user_email ON users;

-- 3. 创建唯一索引
CREATE UNIQUE INDEX uk_user_email ON users(email);
```

**转换注意事项**：
```sql
-- ⚠️ 转换失败的情况
-- 如果数据中有重复值，转换会失败
CREATE UNIQUE INDEX uk_user_phone ON users(phone);
-- ERROR: Duplicate entry 'xxx' for key 'uk_user_phone'

-- 解决方案：先处理重复数据
UPDATE users u1 
SET phone = CONCAT(phone, '_', id)
WHERE EXISTS (
    SELECT 1 FROM users u2 
    WHERE u2.phone = u1.phone AND u2.id != u1.id
);
```

### 5.3 唯一索引转换为普通索引

**转换场景**：
```sql
-- 业务变化：用户现在可以使用相同的手机号注册多个账户

-- 1. 删除唯一索引
DROP INDEX uk_user_phone ON users;

-- 2. 创建普通索引
CREATE INDEX idx_user_phone ON users(phone);
```

---

## 6. 🔄 在线修改与数据重组


### 6.1 什么是在线修改

**在线修改的含义**：
在线修改就是在数据库正常运行、用户正常访问的情况下进行索引修改，不需要停机维护。

**在线 vs 离线对比**：
```
离线修改：
🔒 需要停止应用服务
⏰ 维护窗口时间限制
😰 用户无法访问系统

在线修改：
✅ 应用继续正常运行
🔄 后台逐步完成修改
😊 用户感知不到影响
```

### 6.2 MySQL的在线修改机制

**算法选择**：
```sql
-- ALGORITHM选项控制修改算法
ALTER TABLE users 
ADD INDEX idx_user_city (city)
ALGORITHM = INPLACE;  -- 在线修改

-- 三种算法对比：
-- COPY：     创建临时表，复制所有数据（最慢，需要锁表）
-- INPLACE：  在原表上直接修改（较快，允许并发读写）
-- INSTANT：  立即完成（最快，仅元数据修改）
```

### 6.3 数据重组过程

**重组过程详解**：
```
在线修改的内部过程：

1. 准备阶段
   ├── 获取元数据锁
   ├── 检查修改可行性
   └── 创建临时日志

2. 执行阶段
   ├── 开始构建新索引结构
   ├── 并发处理用户的DML操作
   ├── 记录增量变化到日志
   └── 逐步完成索引构建

3. 提交阶段
   ├── 应用增量日志
   ├── 原子性切换索引
   └── 清理临时资源
```

**监控修改进度**：
```sql
-- 查看当前正在进行的索引操作
SELECT 
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM information_schema.PROCESSLIST 
WHERE INFO LIKE '%ALTER%' OR INFO LIKE '%CREATE INDEX%';

-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G
-- 在输出中查找 "ALTER TABLE" 相关信息
```

---

## 7. 📊 修改过程监控与回滚


### 7.1 修改过程监控

**监控关键指标**：
```sql
-- 1. 监控连接数和锁等待
SHOW PROCESSLIST;

-- 2. 监控InnoDB状态
SHOW ENGINE INNODB STATUS\G

-- 3. 监控表大小变化
SELECT 
    table_name,
    ROUND(((data_length + index_length) / 1024 / 1024), 2) AS 'Size_MB'
FROM information_schema.tables 
WHERE table_schema = 'your_database' 
    AND table_name = 'your_table';

-- 4. 监控索引使用情况
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,
    count_write,
    count_fetch,
    count_insert,
    count_update,
    count_delete
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_name = 'your_table';
```

### 7.2 修改过程中的性能监控

**实时性能监控脚本**：
```bash
#!/bin/bash
# monitor_index_change.sh

echo "开始监控索引修改过程..."
while true; do
    echo "=== $(date) ==="
    
    # 监控当前连接数
    mysql -e "SHOW STATUS LIKE 'Threads_connected';"
    
    # 监控锁等待
    mysql -e "SHOW STATUS LIKE 'Innodb_row_lock_waits';"
    
    # 监控正在执行的ALTER操作
    mysql -e "SELECT COUNT(*) as alter_count FROM information_schema.processlist WHERE info LIKE '%ALTER%';"
    
    sleep 10
done
```

### 7.3 回滚策略制定

**回滚策略规划**：
```sql
-- 📋 回滚策略检查清单

-- 1. 修改前备份索引定义
SELECT 
    CONCAT('CREATE ',
           IF(NON_UNIQUE=0,'UNIQUE ',''),
           'INDEX ', INDEX_NAME,
           ' ON ', TABLE_NAME,
           ' (', GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX), ');'
    ) AS backup_sql
FROM information_schema.STATISTICS 
WHERE TABLE_NAME = 'your_table'
GROUP BY INDEX_NAME;

-- 2. 准备快速回滚SQL
-- 将上面的结果保存为回滚脚本

-- 3. 测试回滚时间
-- 在测试环境中测试回滚操作需要多长时间
```

**紧急回滚操作**：
```sql
-- 如果修改过程中出现严重问题，紧急回滚

-- 1. 首先尝试取消当前操作
KILL QUERY 进程ID;

-- 2. 如果无法取消，等待完成后立即回滚
-- 执行预先准备的回滚SQL

-- 3. 验证回滚结果
SHOW INDEX FROM table_name;
```

---

## 8. 🧪 性能测试与最佳实践


### 8.1 修改前后性能对比

**性能测试框架**：
```sql
-- 📊 性能测试标准流程

-- 1. 修改前性能基准测试
SET @start_time = NOW(6);

-- 执行典型查询
SELECT COUNT(*) FROM users WHERE department = '技术部';
SELECT * FROM users WHERE department = '技术部' AND age BETWEEN 25 AND 35;
SELECT * FROM users WHERE email = 'test@example.com';

SET @end_time = NOW(6);
SELECT TIMESTAMPDIFF(MICROSECOND, @start_time, @end_time) AS before_microseconds;

-- 2. 记录执行计划
EXPLAIN FORMAT=JSON 
SELECT * FROM users WHERE department = '技术部' AND age BETWEEN 25 AND 35;

-- 3. 执行索引修改
-- ... 索引修改操作 ...

-- 4. 修改后性能测试
-- 重复上面的测试，对比结果
```

### 8.2 修改操作最佳实践

**最佳实践清单**：

> 💡 **修改前准备**
> - 在测试环境中先完整测试
> - 准备详细的回滚计划
> - 选择业务低峰期执行
> - 通知相关团队维护时间

> ⚠️ **修改过程注意事项**
> - 使用 `ALGORITHM=INPLACE` 进行在线修改
> - 监控系统负载和锁等待情况
> - 准备好紧急停止的方案
> - 记录修改过程中的关键时间点

> ✅ **修改后验证**
> - 验证索引是否创建成功
> - 测试典型查询的性能
> - 检查应用程序是否正常工作
> - 观察一段时间确保稳定

### 8.3 大表索引修改策略

**大表修改的特殊考虑**：
```sql
-- 对于超大表（>100GB），特殊策略

-- 1. 分批次修改（如果可能）
-- 使用分区表的话，可以分区逐个修改

-- 2. 使用pt-online-schema-change工具
-- pt-online-schema-change --alter "ADD INDEX idx_new (column)" \
--   --execute h=localhost,D=database,t=large_table

-- 3. 主从环境的修改策略
-- 方案1：先在从库修改，然后主从切换
-- 方案2：使用多源复制，零停机迁移
```

**大表修改时间预估**：
```sql
-- 预估修改时间的简单公式
-- 修改时间 ≈ 表大小(GB) × 每GB处理时间

-- 获取表大小
SELECT 
    table_name,
    ROUND(((data_length + index_length) / 1024 / 1024 / 1024), 2) AS 'Size_GB'
FROM information_schema.tables 
WHERE table_schema = 'your_database' 
    AND table_name = 'large_table';

-- 一般经验值：
-- SSD存储：每GB约需要2-5分钟
-- 机械硬盘：每GB约需要5-15分钟
-- 具体时间取决于服务器配置和索引复杂度
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念

```
🔸 索引修改本质：在不重建表的情况下调整索引结构
🔸 在线修改优势：减少停机时间，降低业务影响
🔸 修改类型：重命名、选项修改、列变更、类型转换
🔸 安全策略：充分测试、监控过程、准备回滚
🔸 性能验证：修改前后对比，确保改进效果
```

### 9.2 关键理解要点


**🔹 索引修改 vs 重建的选择**
```
选择修改的情况：
✅ 只是重命名或添加注释
✅ 调整索引可见性
✅ 简单的参数调整

选择重建的情况：
🔄 需要改变索引列
🔄 需要改变列的顺序
🔄 需要改变索引类型
```

**🔹 在线修改的工作原理**
```
核心机制：
• 创建临时日志记录增量变化
• 后台逐步构建新的索引结构
• 最后原子性地切换到新索引
• 清理临时资源

关键优势：
• 大部分时间表仍可正常读写
• 只在最后切换时需要短暂锁定
• 对业务影响最小
```

**🔹 修改过程的风险控制**
```
主要风险：
⚠️ 修改时间过长影响业务
⚠️ 锁等待导致连接堆积
⚠️ 磁盘空间不足导致失败
⚠️ 修改后性能反而下降

控制措施：
✅ 充分的事前测试
✅ 实时的过程监控
✅ 完善的回滚预案
✅ 详细的性能验证
```

### 9.3 实际应用指导

**修改时机选择**：
- 🌙 **业务低峰期**：凌晨2-6点用户访问量最少
- 📊 **负载监控**：CPU使用率<50%，连接数<阈值的70%
- 🔄 **避开备份时间**：不与数据库备份时间冲突
- 📅 **预留充足时间**：确保有足够时间完成和验证

**团队协作要点**：
- 📢 **提前通知**：至少提前24小时通知相关团队
- 🎯 **明确责任**：DBA负责执行，开发负责验证，运维负责监控
- 📋 **文档记录**：详细记录修改过程和结果
- 🚨 **应急联系**：确保关键人员24小时可联系

### 9.4 常见问题与解决方案

```
问题1：修改过程中出现锁等待
解决：监控processlist，必要时kill阻塞查询

问题2：修改时间比预期长很多
解决：检查磁盘IO，考虑分时段执行

问题3：修改后查询性能没有改善
解决：检查查询是否使用了新索引，重新分析查询计划

问题4：修改失败需要回滚
解决：执行预先准备的回滚SQL，验证数据完整性
```

**核心记忆口诀**：
- 修改索引有技巧，在线操作影响小
- 重命名注释可直改，列变更需要巧安排  
- 测试监控不可少，回滚预案要准备好
- 性能对比验证果，最佳实践保成功