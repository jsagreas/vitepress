---
title: 26、慢查询索引优化
---
## 📚 目录

1. [慢查询日志分析](#1-慢查询日志分析)
2. [查询性能诊断](#2-查询性能诊断)
3. [索引缺失识别](#3-索引缺失识别)
4. [索引使用优化](#4-索引使用优化)
5. [查询重写技术](#5-查询重写技术)
6. [索引提示应用](#6-索引提示应用)
7. [查询优化器调优](#7-查询优化器调优)
8. [性能测试验证](#8-性能测试验证)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 慢查询日志分析


### 1.1 什么是慢查询日志


**💡 通俗理解**
```
慢查询日志就像是MySQL的"体检报告"
记录了那些执行时间超过设定阈值的SQL语句
就好比记录那些"跑得慢"的查询，帮我们找出性能瓶颈
```

**🔧 慢查询日志配置**
```sql
-- 启用慢查询日志
SET GLOBAL slow_query_log = ON;

-- 设置慢查询阈值（超过2秒算慢查询）
SET GLOBAL long_query_time = 2;

-- 设置日志文件位置
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';

-- 记录未使用索引的查询
SET GLOBAL log_queries_not_using_indexes = ON;
```

### 1.2 慢查询日志分析方法


**📋 日志内容解读**
```sql
# 典型的慢查询日志条目
# Time: 2025-09-10T14:30:25.123456Z
# User@Host: webapp[webapp] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 3.245678  Lock_time: 0.000123  Rows_sent: 1  Rows_examined: 50000
SELECT * FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-12-31';
```

**🔍 关键指标含义**
```
Query_time: 3.245678    ← 查询总耗时（秒）
Lock_time: 0.000123     ← 等待锁的时间
Rows_sent: 1            ← 返回给客户端的行数
Rows_examined: 50000    ← MySQL扫描的行数

🚨 危险信号：
- Rows_examined 远大于 Rows_sent（扫描了很多无用数据）
- Query_time 过长（超过业务可接受范围）
- Lock_time 较高（可能有锁竞争问题）
```

### 1.3 使用工具分析慢查询


**⚡ mysqldumpslow工具**
```bash
# 按查询次数排序，显示前10个最频繁的慢查询
mysqldumpslow -s c -t 10 /var/log/mysql/slow.log

# 按平均查询时间排序
mysqldumpslow -s at -t 10 /var/log/mysql/slow.log

# 按总查询时间排序
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log
```

**📊 分析结果示例**
```
Count: 127  Time=3.25s (412s)  Lock=0.00s (0s)  Rows=1.0 (127), webapp[webapp]@[192.168.1.100]
SELECT * FROM orders WHERE order_date BETWEEN 'S' AND 'S'

解读：
- 该查询执行了127次
- 平均每次3.25秒，总共耗时412秒
- 平均返回1行数据
- 这是一个高频慢查询，需要重点优化
```

---

## 2. 🔍 查询性能诊断


### 2.1 使用EXPLAIN分析查询


**🎯 EXPLAIN的作用**
```
EXPLAIN就像是MySQL的"X光片"
告诉我们查询是怎么执行的：
- 用了哪些表
- 用了什么索引
- 扫描了多少行
- 连接类型是什么
```

**📋 基础EXPLAIN示例**
```sql
-- 问题查询
EXPLAIN SELECT * FROM orders o 
JOIN customers c ON o.customer_id = c.id 
WHERE o.order_date > '2025-01-01';

-- 结果分析
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | o     | ALL  | NULL          | NULL | NULL    | NULL | 100000 | Using where |
|  1 | SIMPLE      | c     | ALL  | PRIMARY       | NULL | NULL    | NULL | 50000  | Using where |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
```

**🚨 危险信号识别**
```
type = ALL        ← 全表扫描，最危险的信号
key = NULL        ← 没有使用任何索引
rows = 100000     ← 需要扫描大量行
Extra 包含：
- Using filesort     ← 需要额外排序
- Using temporary    ← 使用临时表
- Using where        ← 在存储引擎层之外过滤
```

### 2.2 详细的执行计划分析


**📊 type字段详解（性能从好到坏）**
```
const     ← 常数查询，最快（主键或唯一索引的等值查询）
eq_ref    ← 唯一索引扫描，每个索引键对应一行
ref       ← 非唯一索引扫描，返回匹配某个值的所有行
range     ← 索引范围扫描，比如BETWEEN、>、<
index     ← 全索引扫描，比全表扫描好但仍不理想
ALL       ← 全表扫描，最慢最危险

🎯 优化目标：尽量让type达到ref或以上级别
```

**💡 实际诊断案例**
```sql
-- 慢查询案例
SELECT order_id, total_amount 
FROM orders 
WHERE customer_id = 12345 
  AND order_date BETWEEN '2025-01-01' AND '2025-03-31'
ORDER BY order_date DESC;

-- EXPLAIN结果显示
type: ALL, rows: 500000, Extra: Using where; Using filesort

🔍 问题分析：
1. type=ALL：全表扫描50万行
2. Using filesort：需要额外排序操作
3. 没有合适的索引支持这个查询
```

### 2.3 性能监控关键指标


**⏱️ 查询耗时分解**
```sql
-- 查看详细的执行统计
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;

-- 结果示例
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000087 |
| checking permissions | 0.000012 |
| Opening tables       | 0.000034 |
| init                 | 0.000056 |
| System lock          | 0.000023 |
| optimizing           | 0.000034 |
| statistics           | 0.000156 |
| preparing            | 0.000045 |
| executing            | 0.000012 |
| Sending data         | 2.345678 |  ← 主要耗时在这里
| end                  | 0.000023 |
| query end            | 0.000012 |
| closing tables       | 0.000034 |
| freeing items        | 0.000023 |
+----------------------+----------+

🎯 "Sending data"耗时长说明查询扫描了大量数据
```

---

## 3. 🔎 索引缺失识别


### 3.1 识别缺失索引的方法


**📊 通过慢查询日志识别**
```sql
-- 查找经常出现在WHERE子句中但没有索引的列
SELECT 
    table_schema,
    table_name,
    column_name,
    cardinality  -- 列的唯一值数量
FROM information_schema.statistics 
WHERE table_schema = 'your_database'
ORDER BY cardinality DESC;
```

**🔍 分析查询模式**
```sql
-- 典型的需要索引的查询模式

-- 1. 等值查询（最常见）
SELECT * FROM users WHERE user_id = 12345;
-- 需要索引：user_id

-- 2. 范围查询
SELECT * FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-03-31';
-- 需要索引：order_date

-- 3. 排序查询
SELECT * FROM products ORDER BY price DESC LIMIT 10;
-- 需要索引：price

-- 4. 连接查询
SELECT * FROM orders o JOIN customers c ON o.customer_id = c.id;
-- 需要索引：orders.customer_id, customers.id
```

### 3.2 索引缺失的常见场景


**🚨 高频缺失场景**
```sql
-- 场景1：复合查询条件
SELECT * FROM orders 
WHERE customer_id = 123 AND status = 'pending';
-- 🔧 建议索引：(customer_id, status)

-- 场景2：排序+筛选
SELECT * FROM products 
WHERE category_id = 5 
ORDER BY created_at DESC 
LIMIT 20;
-- 🔧 建议索引：(category_id, created_at)

-- 场景3：模糊查询（特定模式）
SELECT * FROM articles WHERE title LIKE 'MySQL%';
-- 🔧 建议索引：title（前缀匹配可以用索引）

-- 场景4：聚合查询
SELECT customer_id, COUNT(*) 
FROM orders 
WHERE order_date > '2025-01-01' 
GROUP BY customer_id;
-- 🔧 建议索引：(order_date, customer_id)
```

### 3.3 索引创建决策


**⚖️ 是否创建索引的判断标准**
```
✅ 适合创建索引的情况：
- 查询频率高（每天数千次以上）
- 表数据量大（几万行以上）
- 查询结果集相对较小（返回总数据的5%以下）
- 列的选择性好（唯一值多）

❌ 不适合创建索引的情况：
- 查询频率很低（偶尔查询）
- 表数据量很小（几千行以下）
- 频繁更新的列
- 选择性很差的列（如性别字段）
```

**📈 选择性计算**
```sql
-- 计算列的选择性（越接近1越好）
SELECT 
    COUNT(DISTINCT customer_id) / COUNT(*) as selectivity_customer_id,
    COUNT(DISTINCT status) / COUNT(*) as selectivity_status
FROM orders;

-- 结果示例
selectivity_customer_id: 0.85  ← 选择性很好，适合建索引
selectivity_status: 0.05       ← 选择性差，不适合单独建索引
```

---

## 4. ⚡ 索引使用优化


### 4.1 复合索引的设计原则


**🔑 最左前缀原则**
```sql
-- 创建复合索引
CREATE INDEX idx_customer_date_status ON orders (customer_id, order_date, status);

-- ✅ 可以使用索引的查询
SELECT * FROM orders WHERE customer_id = 123;                           -- 使用索引
SELECT * FROM orders WHERE customer_id = 123 AND order_date > '2025-01-01';  -- 使用索引
SELECT * FROM orders WHERE customer_id = 123 AND order_date > '2025-01-01' AND status = 'pending';  -- 完全使用索引

-- ❌ 无法使用索引的查询
SELECT * FROM orders WHERE order_date > '2025-01-01';                   -- 跳过了最左列
SELECT * FROM orders WHERE status = 'pending';                          -- 跳过了最左列
SELECT * FROM orders WHERE order_date > '2025-01-01' AND status = 'pending';  -- 跳过了最左列
```

**💡 索引列顺序设计**
```sql
-- 设计原则：选择性高的列放前面，查询频率高的列放前面

-- 分析各列的使用频率和选择性
SELECT 
    'customer_id' as column_name,
    COUNT(DISTINCT customer_id) / COUNT(*) as selectivity
FROM orders
UNION ALL
SELECT 
    'status',
    COUNT(DISTINCT status) / COUNT(*)
FROM orders
UNION ALL
SELECT 
    'order_date',
    COUNT(DISTINCT DATE(order_date)) / COUNT(*)
FROM orders;

-- 根据结果设计索引顺序
-- 假设 customer_id 选择性0.8，status 选择性0.1，order_date 选择性0.6
-- 推荐顺序：(customer_id, order_date, status)
```

### 4.2 避免索引失效的陷阱


**🚫 常见的索引失效情况**
```sql
-- 1. 在索引列上使用函数
-- ❌ 错误写法
SELECT * FROM orders WHERE YEAR(order_date) = 2025;
-- ✅ 正确写法
SELECT * FROM orders WHERE order_date >= '2025-01-01' AND order_date < '2026-01-01';

-- 2. 使用NOT、!=、<>
-- ❌ 效率低
SELECT * FROM orders WHERE status != 'cancelled';
-- ✅ 更好的写法
SELECT * FROM orders WHERE status IN ('pending', 'confirmed', 'shipped', 'delivered');

-- 3. LIKE使用不当
-- ❌ 无法使用索引
SELECT * FROM products WHERE name LIKE '%iPhone%';
-- ✅ 可以使用索引
SELECT * FROM products WHERE name LIKE 'iPhone%';

-- 4. 隐式类型转换
-- ❌ 索引失效（如果user_id是字符串类型）
SELECT * FROM users WHERE user_id = 12345;
-- ✅ 正确写法
SELECT * FROM users WHERE user_id = '12345';
```

### 4.3 索引覆盖优化


**📋 什么是覆盖索引**
```
覆盖索引就像是"一站式服务"
查询需要的所有列都在索引中，不需要回表查询
这样可以大大提升查询效率
```

**💡 覆盖索引设计实例**
```sql
-- 原始查询
SELECT order_id, customer_id, order_date, total_amount 
FROM orders 
WHERE customer_id = 123 
ORDER BY order_date DESC;

-- 创建覆盖索引（包含查询需要的所有列）
CREATE INDEX idx_customer_cover ON orders (customer_id, order_date, order_id, total_amount);

-- EXPLAIN显示Extra: Using index（表示使用了覆盖索引）
```

**📊 覆盖索引vs普通索引性能对比**
```
普通索引查询过程：
索引查找 → 获取主键 → 回表查询 → 返回结果
┌─────────┐    ┌─────────┐    ┌─────────┐
│  索引树  │───→│  主键值  │───→│  数据页  │
└─────────┘    └─────────┘    └─────────┘

覆盖索引查询过程：
索引查找 → 直接返回结果
┌─────────┐    ┌─────────┐
│  索引树  │───→│  结果   │
└─────────┘    └─────────┘

性能提升：减少50-80%的磁盘IO
```

---

## 5. 🔄 查询重写技术


### 5.1 子查询优化


**🎯 子查询转连接查询**
```sql
-- ❌ 效率低的子查询
SELECT * FROM customers 
WHERE customer_id IN (
    SELECT customer_id FROM orders 
    WHERE order_date > '2025-01-01'
);

-- ✅ 优化为连接查询
SELECT DISTINCT c.* 
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date > '2025-01-01';

-- 📊 性能对比
-- 子查询：对每个customer_id都执行一次子查询
-- 连接查询：一次扫描即可完成
```

**🔧 EXISTS vs IN 的选择**
```sql
-- 当子查询结果集较小时，用IN
SELECT * FROM customers 
WHERE customer_id IN (SELECT customer_id FROM vip_customers);

-- 当主查询结果集较小时，用EXISTS
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.customer_id = c.customer_id 
    AND o.order_date > '2025-01-01'
);

-- 💡 选择原则：
-- 主表小，子表大 → 用EXISTS
-- 主表大，子表小 → 用IN
```

### 5.2 分页查询优化


**📄 LIMIT优化技巧**
```sql
-- ❌ 深度分页效率低
SELECT * FROM orders ORDER BY order_id LIMIT 100000, 20;
-- 问题：需要排序前100020行，然后取最后20行

-- ✅ 使用游标分页
SELECT * FROM orders 
WHERE order_id > 1000000  -- 上一页最后一条记录的ID
ORDER BY order_id 
LIMIT 20;

-- ✅ 延迟关联优化
SELECT o.* FROM orders o
INNER JOIN (
    SELECT order_id FROM orders 
    ORDER BY order_date DESC 
    LIMIT 100000, 20
) tmp ON o.order_id = tmp.order_id;
```

### 5.3 条件查询重写


**⚡ 范围查询优化**
```sql
-- ❌ 效率低的OR查询
SELECT * FROM orders 
WHERE status = 'pending' OR status = 'confirmed' OR status = 'shipped';

-- ✅ 使用IN替代
SELECT * FROM orders 
WHERE status IN ('pending', 'confirmed', 'shipped');

-- ❌ 复杂的日期范围
SELECT * FROM orders 
WHERE (order_date >= '2025-01-01' AND order_date <= '2025-01-31')
   OR (order_date >= '2025-03-01' AND order_date <= '2025-03-31');

-- ✅ 分别查询再UNION
SELECT * FROM orders 
WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31'
UNION ALL
SELECT * FROM orders 
WHERE order_date BETWEEN '2025-03-01' AND '2025-03-31';
```

---

## 6. 💡 索引提示应用


### 6.1 强制索引使用


**🔧 FORCE INDEX的使用**
```sql
-- 场景：优化器选择了错误的索引
EXPLAIN SELECT * FROM orders 
WHERE customer_id = 123 AND order_date > '2025-01-01';
-- 假设优化器选择了order_date索引，但customer_id索引更优

-- 强制使用指定索引
SELECT * FROM orders FORCE INDEX (idx_customer_id)
WHERE customer_id = 123 AND order_date > '2025-01-01';
```

**⚠️ 使用FORCE INDEX的注意事项**
```
🎯 适用场景：
- 优化器统计信息不准确
- 新创建的索引优化器还没有采用
- 临时的性能调优测试

⚠️ 注意事项：
- 不要滥用，会降低查询的灵活性
- 表结构变化时可能导致问题
- 最好配合定期review，及时移除不必要的提示
```

### 6.2 忽略索引设置


**🚫 IGNORE INDEX的应用**
```sql
-- 场景：某个索引导致性能问题
SELECT * FROM products IGNORE INDEX (idx_category_id)
WHERE category_id = 5 AND price > 100;

-- 常见使用场景：
-- 1. 索引统计信息过时，导致错误的成本估算
-- 2. 某个索引因为数据分布变化不再有效
-- 3. 测试不同索引策略的性能差异
```

### 6.3 索引提示的最佳实践


**📋 提示使用策略**
```sql
-- 1. 临时性能调优
SELECT /*+ USE_INDEX(orders, idx_order_date) */ 
       order_id, customer_id 
FROM orders 
WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31';

-- 2. 复杂查询的索引选择
SELECT * FROM orders o
FORCE INDEX (idx_customer_date)
JOIN customers c USE INDEX (PRIMARY) ON o.customer_id = c.id
WHERE o.order_date > '2025-01-01';

-- 3. 分析不同索引的性能
-- 测试场景A：使用索引A
SELECT * FROM orders USE INDEX (idx_customer_id) WHERE customer_id = 123;
-- 测试场景B：使用索引B  
SELECT * FROM orders USE INDEX (idx_order_date) WHERE customer_id = 123;
```

---

## 7. 🎯 查询优化器调优


### 7.1 优化器参数调整


**⚙️ 关键优化器参数**
```sql
-- 查看当前优化器设置
SHOW VARIABLES LIKE 'optimizer%';

-- 关键参数调优
SET optimizer_search_depth = 62;        -- 搜索深度，默认62
SET optimizer_prune_level = 1;          -- 启用剪枝优化
SET optimizer_use_condition_selectivity = 1;  -- 使用条件选择性

-- eq_range_index_dive_limit调优
SET eq_range_index_dive_limit = 200;    -- IN条件中值的数量限制
```

**📊 统计信息更新**
```sql
-- 手动更新表统计信息
ANALYZE TABLE orders;

-- 查看表统计信息
SELECT 
    table_name,
    table_rows,
    avg_row_length,
    data_length,
    index_length,
    update_time
FROM information_schema.tables 
WHERE table_schema = 'your_database'
  AND table_name = 'orders';

-- 💡 定期更新统计信息的重要性
-- 过时的统计信息会导致优化器做出错误决策
-- 建议：对于频繁变化的表，每天更新一次统计信息
```

### 7.2 执行计划分析和干预


**🔍 成本分析**
```sql
-- 查看详细的成本信息（MySQL 8.0+）
EXPLAIN FORMAT=JSON SELECT * FROM orders 
WHERE customer_id = 123 AND order_date > '2025-01-01';

-- 关注的成本指标
{
  "query_cost": "2519.85",           -- 总查询成本
  "read_cost": "2499.85",            -- 读取成本
  "eval_cost": "20.00",              -- 评估成本
  "prefix_cost": "2519.85",          -- 前缀成本
  "data_read_per_join": "160K"       -- 每次连接读取的数据量
}
```

### 7.3 优化器trace分析


**🔬 开启优化器跟踪**
```sql
-- 启用优化器跟踪
SET optimizer_trace="enabled=on";
SET optimizer_trace_max_mem_size=1000000;

-- 执行要分析的查询
SELECT * FROM orders WHERE customer_id = 123;

-- 查看优化器的决策过程
SELECT trace FROM information_schema.optimizer_trace;

-- 关闭跟踪
SET optimizer_trace="enabled=off";
```

**📋 trace信息解读要点**
```json
{
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select * from orders where customer_id = 123"
          }
        ]
      }
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "customer_id = 123",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "customer_id = 123"
                }
              ]
            }
          },
          {
            "table_dependencies": [
              {
                "table": "orders",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": []
              }
            ]
          },
          {
            "ref_optimizer_key_uses": [
              {
                "table": "orders",
                "field": "customer_id",
                "equals": "123",
                "null_rejecting": false
              }
            ]
          }
        ]
      }
    }
  ]
}
```

---

## 8. 📈 性能测试验证


### 8.1 性能测试方法


**⏱️ 查询耗时测试**
```sql
-- 方法1：使用MySQL内置的性能统计
SET profiling = 1;

-- 执行测试查询
SELECT * FROM orders WHERE customer_id = 123;

-- 查看详细耗时
SHOW PROFILES;
SHOW PROFILE CPU, BLOCK IO FOR QUERY 1;

-- 方法2：简单的时间测试
SELECT BENCHMARK(1000, (
    SELECT COUNT(*) FROM orders WHERE customer_id = 123
));
```

**📊 压力测试脚本**
```bash
#!/bin/bash
# 使用sysbench进行MySQL压力测试

# 准备测试数据
sysbench oltp_read_write \
  --mysql-host=localhost \
  --mysql-user=test \
  --mysql-password=test \
  --mysql-db=testdb \
  --tables=4 \
  --table-size=1000000 \
  prepare

# 执行性能测试
sysbench oltp_read_write \
  --mysql-host=localhost \
  --mysql-user=test \
  --mysql-password=test \
  --mysql-db=testdb \
  --tables=4 \
  --table-size=1000000 \
  --threads=16 \
  --time=300 \
  --report-interval=10 \
  run
```

### 8.2 优化效果评估


**📋 关键性能指标对比**
```sql
-- 测试前后的性能对比表格
┌──────────────────┬─────────────┬─────────────┬──────────────┐
│     测试项目     │   优化前    │   优化后    │   提升幅度   │
├──────────────────┼─────────────┼─────────────┼──────────────┤
│   查询响应时间   │    3.2秒    │    0.1秒    │   提升96%    │
│   扫描行数       │   50万行    │   100行     │   减少99.98% │
│   CPU使用率      │     85%     │     15%     │   降低82%    │
│   并发支持       │   50用户    │   500用户   │   提升10倍   │
└──────────────────┴─────────────┴─────────────┴──────────────┘
```

**🎯 监控指标设置**
```sql
-- 设置关键性能监控点
-- 1. 慢查询数量监控
SELECT COUNT(*) as slow_query_count 
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR);

-- 2. 索引使用率监控  
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,
    count_insert,
    count_update,
    count_delete
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY count_read DESC;

-- 3. 表扫描统计
SELECT 
    object_schema,
    object_name,
    count_read,
    count_write,
    count_misc,
    sum_timer_read/1000000000 as read_time_ms
FROM performance_schema.table_io_waits_summary_by_table
WHERE object_schema = 'your_database'
ORDER BY count_read DESC;
```

### 8.3 持续优化策略


**🔄 性能监控自动化**
```sql
-- 创建性能监控视图
CREATE VIEW slow_query_summary AS
SELECT 
    sql_text,
    count_star as exec_count,
    avg_timer_wait/1000000000 as avg_time_ms,
    sum_rows_examined/count_star as avg_rows_examined,
    sum_rows_sent/count_star as avg_rows_sent
FROM performance_schema.events_statements_summary_by_digest
WHERE avg_timer_wait > 1000000000  -- 大于1秒的查询
ORDER BY avg_timer_wait DESC;

-- 定期性能报告
SELECT 
    DATE(FROM_UNIXTIME(first_seen)) as date,
    COUNT(*) as slow_query_types,
    SUM(count_star) as total_slow_queries,
    AVG(avg_timer_wait/1000000000) as avg_response_time
FROM performance_schema.events_statements_summary_by_digest
WHERE avg_timer_wait > 1000000000
GROUP BY DATE(FROM_UNIXTIME(first_seen))
ORDER BY date DESC;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心技能


```
🔸 慢查询识别：通过日志和工具快速定位性能瓶颈
🔸 执行计划分析：读懂EXPLAIN结果，识别优化机会
🔸 索引设计：根据查询模式设计合适的索引
🔸 查询重写：优化SQL语句结构提升性能
🔸 性能测试：验证优化效果，持续监控
```

### 9.2 优化决策流程


**🎯 系统化的优化方法**
```
步骤1️⃣ 问题识别
├─ 启用慢查询日志
├─ 分析慢查询频率和耗时
└─ 确定优化优先级

步骤2️⃣ 原因分析  
├─ 使用EXPLAIN分析执行计划
├─ 识别索引缺失或不当使用
└─ 分析查询逻辑是否合理

步骤3️⃣ 方案设计
├─ 设计合适的索引策略
├─ 重写低效的查询语句
└─ 考虑表结构优化

步骤4️⃣ 实施验证
├─ 在测试环境验证效果
├─ 进行压力测试
└─ 监控生产环境表现

步骤5️⃣ 持续监控
├─ 设置性能监控报警
├─ 定期审查索引使用情况
└─ 根据业务变化调整策略
```

### 9.3 常见优化效果预期


**📊 不同优化手段的效果**
```
索引优化：
- 查询时间：通常可提升80-95%
- 适用场景：WHERE、ORDER BY、JOIN条件
- 注意事项：会增加写入开销

查询重写：
- 查询时间：通常可提升30-60%  
- 适用场景：复杂子查询、不合理的连接
- 注意事项：需要保证结果正确性

覆盖索引：
- 查询时间：可提升50-80%
- 适用场景：频繁查询固定列组合
- 注意事项：会增加索引存储空间

分页优化：
- 深度分页：可提升90%以上
- 适用场景：大数据量的分页查询
- 注意事项：可能需要改变业务逻辑
```

### 9.4 最佳实践建议


**💡 日常维护建议**
```
🔸 预防为主：
- 新功能上线前进行性能测试
- 定期审查慢查询日志
- 监控索引使用情况

🔸 优化策略：
- 优先优化高频查询
- 从简单优化开始（加索引）
- 复杂优化需要充分测试

🔸 监控告警：
- 设置慢查询数量告警
- 监控数据库CPU和IO
- 关注索引命中率变化

🔸 团队协作：
- 建立SQL编写规范
- 定期进行性能培训
- 重要优化需要评审
```

**🎯 核心记忆要点**
```
慢查询日志是发现问题的眼睛
EXPLAIN是分析问题的放大镜  
索引是解决问题的利器
监控是预防问题的雷达
持续优化是保持性能的关键
```

---

> 💡 **学习建议**：理论学习后要在实际环境中练习，通过真实的慢查询案例来加深理解。记住，性能优化是一个持续的过程，需要结合业务场景和数据特点来制定合适的策略。

> 🔗 **扩展学习**：建议深入学习MySQL内核原理、索引底层实现机制，这有助于做出更好的优化决策。