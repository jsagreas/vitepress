---
title: 20、重建索引技术
---
## 📚 目录

1. [索引重建基础概念](#1-索引重建基础概念)
2. [索引碎片产生原理](#2-索引碎片产生原理)
3. [重建触发条件判断](#3-重建触发条件判断)
4. [索引重建技术方案](#4-索引重建技术方案)
5. [重建过程监控管理](#5-重建过程监控管理)
6. [重建策略与时机](#6-重建策略与时机)
7. [风险控制与验证](#7-风险控制与验证)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 索引重建基础概念


### 1.1 什么是索引重建


**简单理解**：索引重建就像整理书架一样，把散乱的书重新按顺序摆放整齐。

```
想象一个图书馆的书架：
原始状态：书本整齐排列 ───────────────
使用一段时间后：[空位][书][空位][书][书][空位] ← 出现空隙和碎片
重建后：[书][书][书][书][书] ────────── ← 重新整理，紧密排列
```

**核心概念**：
- **索引重建**：重新构建索引的物理存储结构
- **目的**：消除碎片，提高查询性能，回收空间
- **本质**：重新组织索引页面，优化存储布局

### 1.2 为什么需要索引重建


**数据库使用过程中的变化**：
```
新建表时：          使用一段时间后：
┌─────────┐        ┌─────────┐
│ Page 1  │ 100%   │ Page 1  │ 60%  ← 部分数据被删除
├─────────┤        ├─────────┤
│ Page 2  │ 100%   │ Page 2  │ 80%  
├─────────┤        ├─────────┤
│ Page 3  │ 100%   │ Page 3  │ 40%  ← 大量空间浪费
└─────────┘        └─────────┘
```

**常见问题**：
- **空间浪费**：删除数据后留下空洞
- **性能下降**：需要读取更多页面才能找到数据
- **内存浪费**：缓存中存储了很多无用的空页面

### 1.3 索引重建的好处


**🔸 空间回收**
```
重建前：100万条记录，占用500MB
删除30%数据后：70万条记录，仍占用500MB
重建后：70万条记录，只占用350MB ← 回收150MB空间
```

**🔸 性能提升**
```
查询效率对比：
重建前：需要扫描100个页面找到70万条记录
重建后：只需扫描70个页面找到70万条记录
性能提升：约30%的查询速度提升
```

---

## 2. 💔 索引碎片产生原理


### 2.1 什么是索引碎片


**通俗解释**：就像一本书的页面被撕掉了一些，剩下的页面之间出现了空隙。

```
完整的索引页面：
┌────────────────────────────────┐
│ [1][2][3][4][5][6][7][8][9][10]│ ← 数据紧密排列
└────────────────────────────────┘

产生碎片后：
┌────────────────────────────────┐
│ [1][_][3][_][_][6][7][_][9][_] │ ← 出现空隙（_表示空位）
└────────────────────────────────┘
```

### 2.2 碎片产生的原因


**🔸 DELETE操作**
```sql
-- 原始数据：id连续 1,2,3,4,5,6,7,8,9,10
DELETE FROM users WHERE id IN (2,4,5,8,10);
-- 结果：留下空隙 1,_,3,_,_,6,7,_,9,_
```

**🔸 UPDATE操作改变记录大小**
```sql
-- 原始记录：name='张三' (占用4字节)
UPDATE users SET name='张三丰师傅' WHERE id=1;
-- 新记录：name='张三丰师傅' (占用12字节)
-- 结果：原位置放不下，移动到其他页面，留下空隙
```

**🔸 不规律的INSERT操作**
```sql
-- 随机插入ID，打乱原有顺序
INSERT INTO users (id, name) VALUES (15, '李四');  -- 插入到中间某个位置
INSERT INTO users (id, name) VALUES (3, '王五');   -- 需要挤入已有数据间
```

### 2.3 碎片类型详解


**🔸 页面内碎片（Internal Fragmentation）**
```
页面内部的空隙：
┌─────────────── Page 1 ──────────────┐
│ [Record1][空隙][Record2][空隙][Record3] │
└────────────────────────────────────┘
问题：页面利用率低，浪费空间
```

**🔸 页面间碎片（External Fragmentation）**
```
页面之间的逻辑顺序混乱：
逻辑顺序：Page1 → Page2 → Page3
物理存储：Page3 → Page1 → Page2
问题：读取时需要跳跃访问，影响性能
```

### 2.4 碎片影响评估


**碎片率计算示例**：
```sql
-- 查看表的碎片信息
SELECT 
    table_name,
    data_length,                    -- 数据占用空间
    index_length,                   -- 索引占用空间  
    data_free,                      -- 碎片空间
    ROUND(data_free/(data_length + index_length + data_free) * 100, 2) AS fragmentation_ratio
FROM information_schema.tables 
WHERE table_schema = 'your_database';
```

**影响程度判断**：
- **碎片率 < 10%**：正常范围，无需处理
- **碎片率 10-30%**：轻度碎片，可考虑重建
- **碎片率 > 30%**：严重碎片，建议立即重建

---

## 3. 🎯 重建触发条件判断


### 3.1 什么时候需要重建索引


**🔸 数据变更频繁的表**
```
典型场景：
- 电商订单表：大量INSERT、UPDATE、DELETE操作
- 用户行为日志：频繁INSERT，定期DELETE历史数据
- 库存表：频繁UPDATE操作

判断标准：
- 每天数据变更量 > 表总量的20%
- 碎片率 > 20%
```

**🔸 查询性能明显下降**
```sql
-- 监控查询性能变化
-- 如果相同查询的执行时间比之前慢30%以上，考虑重建索引

EXPLAIN SELECT * FROM orders WHERE create_time > '2024-01-01';
-- 观察 rows 数量是否异常增加
-- 观察 Extra 是否出现 Using filesort
```

### 3.2 碎片检测方法


**🔸 使用SHOW TABLE STATUS**
```sql
SHOW TABLE STATUS LIKE 'orders'\G

-- 关注这些指标：
-- Data_length: 数据占用空间
-- Index_length: 索引占用空间  
-- Data_free: 碎片空间（重点关注）
```

**🔸 计算碎片率的实用方法**
```sql
SELECT 
    table_name,
    ROUND(data_free/(data_length + index_length) * 100, 2) AS fragmentation_percent,
    CASE 
        WHEN data_free/(data_length + index_length) * 100 < 10 THEN '正常'
        WHEN data_free/(data_length + index_length) * 100 < 30 THEN '需要关注'
        ELSE '需要重建'
    END AS suggestion
FROM information_schema.tables 
WHERE table_schema = DATABASE()
AND table_name = 'your_table';
```

### 3.3 重建条件总结


| 指标类型 | **轻度碎片** | **中度碎片** | **重度碎片** | **处理建议** |
|---------|------------|------------|------------|------------|
| 碎片率 | `5-15%` | `15-30%` | `>30%` | `立即重建` |
| 性能下降 | `<10%` | `10-30%` | `>30%` | `立即重建` |
| 数据变更量 | `<10%/天` | `10-20%/天` | `>20%/天` | `定期重建` |
| 空间浪费 | `<100MB` | `100MB-1GB` | `>1GB` | `立即重建` |

---

## 4. 🛠️ 索引重建技术方案


### 4.1 OPTIMIZE TABLE方案


**🔸 基本语法和原理**
```sql
-- 最简单的重建方法
OPTIMIZE TABLE orders;

-- 执行过程：
-- 1. 创建新的临时表
-- 2. 将数据按主键顺序复制到新表
-- 3. 重建所有索引
-- 4. 删除原表，重命名新表
```

**适用场景**：
- **小表**：数据量 < 100万条
- **维护窗口**：有足够的停机时间
- **简单操作**：不需要复杂控制

**优缺点分析**：
```
✅ 优点：
- 操作简单，一条命令搞定
- 自动回收所有碎片空间
- 重建所有索引，效果最佳

❌ 缺点：  
- 表锁定，影响业务
- 需要额外存储空间（临时表）
- 大表耗时很长
```

### 4.2 在线重建方案（推荐）


**🔸 ALTER TABLE在线重建**
```sql
-- MySQL 5.6+ 支持在线DDL
ALTER TABLE orders ENGINE=InnoDB;

-- 或者显式指定算法
ALTER TABLE orders 
ENGINE=InnoDB, 
ALGORITHM=INPLACE,     -- 原地操作，不创建临时表
LOCK=NONE;             -- 不锁表，允许读写
```

**执行流程图示**：
```
在线重建过程：
                    
用户操作 ──┐        ┌── 继续读写原表
          │        │
          ▼        ▼
    ┌────────────────────┐
    │   原表（可读写）    │ ──┐
    └────────────────────┘   │
                            │ 后台重建
    ┌────────────────────┐   │
    │   新表（后台构建）   │ ◄─┘
    └────────────────────┘
                            │
                            ▼
                     原子切换
```

### 4.3 分批重建方案


**🔸 按分区重建**
```sql
-- 如果表有分区，可以分区逐个重建
ALTER TABLE orders_partitioned 
OPTIMIZE PARTITION p202401, p202402;

-- 好处：
-- 1. 分批处理，减少单次影响
-- 2. 可以在业务低峰期执行
-- 3. 如果出问题，影响范围有限
```

**🔸 按时间段重建**
```sql
-- 对于大表，可以考虑分段处理
-- 1. 先处理历史数据（活跃度低）
-- 2. 再处理近期数据（活跃度高）

-- 创建新表结构
CREATE TABLE orders_new LIKE orders;

-- 分批插入数据
INSERT INTO orders_new 
SELECT * FROM orders 
WHERE create_time < '2024-01-01';

-- 继续处理其他时间段...
```

### 4.4 重建方案选择指南


```
数据量级别与方案选择：

小表（<10万行）：
┌─────────────┐
│ OPTIMIZE    │ ← 推荐方案
│ TABLE       │
└─────────────┘
优点：简单快速
缺点：短暂锁表

中等表（10万-500万行）：
┌─────────────┐
│ ALTER TABLE │ ← 推荐方案  
│ ENGINE      │
└─────────────┘
优点：在线操作
缺点：需要更多空间

大表（>500万行）：
┌─────────────┐
│ 分批重建     │ ← 推荐方案
│ 或第三方工具 │  
└─────────────┘
优点：影响可控
缺点：操作复杂
```

---

## 5. 📊 重建过程监控管理


### 5.1 重建进度监控


**🔸 查看ALTER操作进度**
```sql
-- MySQL 5.7+ 可以查看DDL进度
SELECT 
    EVENT_NAME,
    WORK_COMPLETED,
    WORK_ESTIMATED,
    ROUND(100 * WORK_COMPLETED / WORK_ESTIMATED, 2) AS completion_percentage
FROM performance_schema.events_stages_current 
WHERE EVENT_NAME LIKE 'stage/innodb/alter%';
```

**🔸 监控系统资源使用**
```sql
-- 查看当前连接和锁等待情况
SHOW PROCESSLIST;

-- 查看InnoDB状态
SHOW ENGINE INNODB STATUS\G

-- 关注指标：
-- - Pending normal aio reads/writes (IO压力)
-- - Buffer pool hit rate (缓存命中率)
-- - Log sequence number (日志写入速度)
```

### 5.2 性能影响评估


**重建对系统的影响**：
```
CPU使用率影响：
正常时：     ████░░░░░░ 40%
重建时：     ██████████ 80-90%

磁盘IO影响：
正常时：     ███░░░░░░░ 30%  
重建时：     ██████████ 90-100%

内存使用影响：
正常时：     █████░░░░░ 50%
重建时：     ████████░░ 70-80%
```

**监控脚本示例**：
```bash
#!/bin/bash
# 监控重建过程的系统负载

while true; do
    echo "=== $(date) ==="
    
    # CPU使用率
    echo "CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)"
    
    # 内存使用率  
    echo "Memory: $(free | grep Mem | awk '{printf "%.1f%%", $3/$2 * 100.0}')"
    
    # 磁盘IO
    echo "Disk IO: $(iostat -x 1 1 | tail -1 | awk '{print $10"%"}')"
    
    # MySQL连接数
    echo "Connections: $(mysql -e "SHOW STATUS LIKE 'Threads_connected'" | tail -1 | awk '{print $2}')"
    
    echo "---"
    sleep 30
done
```

### 5.3 异常情况处理


**🔸 重建过程中断处理**
```sql
-- 如果重建过程异常中断，检查表状态
CHECK TABLE orders;

-- 如果表损坏，尝试修复
REPAIR TABLE orders;

-- 最坏情况：从备份恢复
-- 这就是为什么重建前一定要备份！
```

**🔸 空间不足处理**
```bash
# 重建前检查可用空间
df -h /var/lib/mysql

# 如果空间不足，可以：
# 1. 清理临时文件
# 2. 移动其他数据库文件
# 3. 增加磁盘空间
# 4. 使用分批重建方案
```

---

## 6. ⏰ 重建策略与时机


### 6.1 重建时机选择


**🔸 业务低峰期**
```
电商网站的访问模式：
00:00-06:00  ████░░░░░░ 访问量低 ← 最佳重建时间
06:00-09:00  ██████░░░░ 访问量中等
09:00-22:00  ██████████ 访问量高峰 ← 避免重建
22:00-24:00  ██████░░░░ 访问量下降
```

**🔸 定期维护窗口**
```
建议维护计划：
每周：    轻度维护（检查碎片率）
每月：    中度维护（重建中小表）
每季度：   重度维护（重建大表）
每年：    全面维护（系统整体优化）
```

### 6.2 重建策略制定


**🔸 基于表特征的策略**
```sql
-- 制定重建策略的SQL
SELECT 
    table_name,
    table_rows,
    ROUND((data_length + index_length)/1024/1024, 2) AS size_mb,
    ROUND(data_free/(data_length + index_length) * 100, 2) AS fragmentation,
    CASE 
        WHEN table_rows < 100000 AND data_free/(data_length + index_length) > 0.15 
        THEN 'OPTIMIZE TABLE - 低峰期执行'
        WHEN table_rows < 1000000 AND data_free/(data_length + index_length) > 0.20 
        THEN 'ALTER TABLE ENGINE - 计划执行'
        WHEN data_free/(data_length + index_length) > 0.30 
        THEN '分批重建 - 紧急处理'
        ELSE '暂无需要'
    END AS rebuild_strategy
FROM information_schema.tables 
WHERE table_schema = DATABASE() 
ORDER BY fragmentation DESC;
```

### 6.3 重建执行计划


**完整的重建流程**：
```
重建执行步骤：

1. 准备阶段
   ├── 备份表数据 ✓
   ├── 检查磁盘空间 ✓
   ├── 通知相关人员 ✓
   └── 准备回滚方案 ✓

2. 执行阶段  
   ├── 选择重建方案 ✓
   ├── 开始重建操作 ✓
   ├── 监控执行进度 ✓
   └── 处理异常情况 ✓

3. 验证阶段
   ├── 检查表完整性 ✓
   ├── 验证索引有效性 ✓
   ├── 测试业务功能 ✓
   └── 性能对比分析 ✓
```

---

## 7. ⚠️ 风险控制与验证


### 7.1 重建前的风险控制


**🔸 数据备份（必须！）**
```sql
-- 方法1：使用mysqldump
mysqldump -u root -p database_name table_name > table_backup.sql

-- 方法2：创建备份表
CREATE TABLE orders_backup AS SELECT * FROM orders;

-- 方法3：如果有主从复制，确保从库正常
SHOW SLAVE STATUS\G
```

**🔸 空间预算**
```bash
# 检查表大小
SELECT 
    ROUND((data_length + index_length)/1024/1024, 2) AS current_size_mb,
    ROUND(data_length/1024/1024, 2) AS data_size_mb,
    ROUND(index_length/1024/1024, 2) AS index_size_mb
FROM information_schema.tables 
WHERE table_name = 'orders';

# 预估需要空间：通常为表大小的1.5-2倍
```

**🔸 业务影响评估**
```
影响评估表：
┌──────────────┬────────────┬────────────┐
│   重建方案    │  业务影响   │   风险等级  │
├──────────────┼────────────┼────────────┤
│ OPTIMIZE     │ 完全锁表    │   高风险   │
│ ALTER ENGINE │ 可读写      │   中风险   │
│ 分批重建     │ 几乎无影响   │   低风险   │
└──────────────┴────────────┴────────────┘
```

### 7.2 重建后的验证


**🔸 数据完整性验证**
```sql
-- 1. 检查记录数量
SELECT COUNT(*) FROM orders;

-- 2. 检查数据校验和（如果支持）
CHECKSUM TABLE orders;

-- 3. 抽样检查关键数据
SELECT * FROM orders ORDER BY RAND() LIMIT 100;
```

**🔸 索引有效性验证**
```sql
-- 检查所有索引是否正常
SHOW INDEX FROM orders;

-- 验证查询计划是否使用索引
EXPLAIN SELECT * FROM orders WHERE user_id = 12345;
EXPLAIN SELECT * FROM orders WHERE create_time > '2024-01-01';
```

**🔸 性能效果验证**
```sql
-- 重建前后性能对比
-- 执行相同查询，对比执行时间

-- 查询示例
SELECT SQL_NO_CACHE COUNT(*) 
FROM orders 
WHERE status = 'completed' 
AND create_time > '2024-01-01';

-- 记录执行时间，对比重建前后的变化
```

### 7.3 问题回滚方案


**如果重建失败怎么办**：
```sql
-- 方案1：如果有备份表
DROP TABLE orders;
RENAME TABLE orders_backup TO orders;

-- 方案2：从备份文件恢复
mysql -u root -p database_name < table_backup.sql

-- 方案3：如果有主从复制
-- 可以考虑主从切换，使用从库数据
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 索引重建本质：重新整理索引的物理存储，消除碎片
🔸 碎片产生原因：DELETE、UPDATE、无序INSERT导致的空间空洞
🔸 重建触发条件：碎片率>20%，性能下降>30%，大量数据变更
🔸 重建方案选择：小表用OPTIMIZE，中表用ALTER，大表分批处理
🔸 风险控制要点：备份数据、评估空间、选择时机、制定回滚方案
```

### 8.2 关键理解要点


**🔹 为什么会有索引碎片**
```
简单类比：
图书馆书架 = 数据库索引页面
借书还书 = 数据的增删改
书架空隙 = 索引碎片
整理书架 = 索引重建

随着借书还书操作增多，书架会变得凌乱，需要定期整理
```

**🔹 重建方案的选择依据**
```
决策因素：
数据量大小 → 决定重建时间
业务重要程度 → 决定停机窗口
碎片严重程度 → 决定紧急程度
系统资源情况 → 决定执行方式
```

**🔹 重建的收益评估**
```
主要收益：
空间回收：通常能回收20-50%的碎片空间
性能提升：查询速度提升10-30%
缓存效率：相同内存能缓存更多有效数据
维护便利：减少后续维护工作量
```

### 8.3 实际应用指导


**🎯 制定重建计划的步骤**
1. **定期检查**：每周检查表的碎片率
2. **分类处理**：按表大小和重要程度分类
3. **选择时机**：在业务低峰期执行
4. **制定方案**：根据具体情况选择重建方法
5. **做好备份**：重建前必须备份数据
6. **监控执行**：重建过程中密切监控
7. **验证结果**：重建后验证数据和性能

**🔧 实用的监控脚本**
```bash
# 每日碎片检查脚本
mysql -e "
SELECT 
    table_name,
    ROUND(data_free/(data_length + index_length) * 100, 2) AS fragmentation_percent
FROM information_schema.tables 
WHERE table_schema = 'your_database' 
AND data_free/(data_length + index_length) > 0.15
ORDER BY fragmentation_percent DESC;
" > daily_fragmentation_report.txt
```

**🚨 重要注意事项**
- **永远先备份**：没有备份就没有重建
- **选择合适时机**：避免业务高峰期操作
- **监控系统资源**：重建过程消耗大量资源
- **验证操作结果**：确保数据完整性和性能改善
- **制定回滚方案**：准备应对意外情况

### 8.4 经验总结


**✅ 最佳实践**
- 定期检查，预防为主
- 小表直接重建，大表分批处理
- 业务低峰期执行，减少影响
- 重建前后都要验证效果

**❌ 常见误区**
- 不备份就直接重建
- 在业务高峰期执行重建
- 忽视磁盘空间检查
- 重建后不验证效果

**核心记忆口诀**：
- 碎片检查要定期，超过二成需重建
- 备份数据是前提，选对时机很关键  
- 小表直接优化好，大表分批最稳妥
- 重建之后要验证，性能提升才算完