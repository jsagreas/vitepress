---
title: 11、索引选择性分析
---
## 📚 目录

1. [索引选择性基本概念](#1-索引选择性基本概念)
2. [选择性计算与分析](#2-选择性计算与分析)
3. [数据分布统计方法](#3-数据分布统计方法)
4. [索引效果评估策略](#4-索引效果评估策略)
5. [优化建议与实践](#5-优化建议与实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 索引选择性基本概念


### 1.1 什么是索引选择性


**🔸 选择性定义**
```
索引选择性：衡量索引中不重复值占总记录数的比例
通俗理解：这个字段的数据有多"独特"，重复度有多高
目的：评估索引的过滤效果，预测查询性能
```

**💡 生活化理解**
```
想象一个班级点名册：
高选择性：学号字段 - 每个学生都不同，选择性接近1
中选择性：班级字段 - 有几个不同班级，选择性中等  
低选择性：性别字段 - 只有男/女两种，选择性很低

高选择性 = 数据越独特 = 索引过滤效果越好
低选择性 = 数据越重复 = 索引过滤效果越差
```

### 1.2 选择性的作用原理


**🔧 工作机制**
```
查询执行过程：
1. MySQL根据索引选择性评估查询成本
2. 选择性高 → 能快速定位少量数据 → 优先使用索引
3. 选择性低 → 需要访问大量数据 → 可能放弃索引走全表扫描

实际例子：
SELECT * FROM users WHERE gender = '男';  // 选择性低，可能不走索引
SELECT * FROM users WHERE phone = '13800138000';  // 选择性高，必走索引
```

### 1.3 选择性与查询性能的关系


**📊 性能影响对比**

| 选择性范围 | **数据特征** | **索引效果** | **典型场景** |
|-----------|------------|------------|------------|
| **0.8-1.0** | `数据几乎不重复` | `优秀，必走索引` | `主键、唯一键、手机号` |
| **0.5-0.8** | `数据有一定重复` | `良好，通常走索引` | `用户名、邮箱` |
| **0.1-0.5** | `数据重复较多` | `一般，视情况走索引` | `城市、年龄段` |
| **0.0-0.1** | `数据大量重复` | `差，可能不走索引` | `性别、状态标识` |

---

## 2. 📊 选择性计算与分析


### 2.1 选择性计算公式


**🔸 基本计算公式**
```sql
-- 标准选择性计算公式
选择性 = 不重复值的数量 / 总记录数

-- SQL实现
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS selectivity,
    COUNT(DISTINCT column_name) AS unique_values,
    COUNT(*) AS total_rows
FROM table_name;
```

**💻 实际计算示例**
```sql
-- 分析用户表各字段选择性
SELECT 
    'user_id' as field_name,
    COUNT(DISTINCT user_id) / COUNT(*) AS selectivity,
    COUNT(DISTINCT user_id) AS unique_count,
    COUNT(*) AS total_count
FROM users
UNION ALL
SELECT 
    'email' as field_name,
    COUNT(DISTINCT email) / COUNT(*) AS selectivity,
    COUNT(DISTINCT email) AS unique_count,
    COUNT(*) AS total_count
FROM users
UNION ALL
SELECT 
    'gender' as field_name,
    COUNT(DISTINCT gender) / COUNT(*) AS selectivity,
    COUNT(DISTINCT gender) AS unique_count,
    COUNT(*) AS total_count
FROM users;

-- 输出结果示例：
-- field_name | selectivity | unique_count | total_count
-- user_id    | 1.0000      | 100000       | 100000
-- email      | 0.9998      | 99980        | 100000  
-- gender     | 0.0002      | 2            | 100000
```

### 2.2 不同场景的选择性分析


**🎯 唯一性字段分析**
```sql
-- 分析主键和唯一键的选择性
SELECT 
    table_name,
    column_name,
    COUNT(DISTINCT column_value) / COUNT(*) AS selectivity
FROM (
    SELECT 'users' as table_name, 'id' as column_name, id as column_value FROM users
    UNION ALL
    SELECT 'users', 'email', email FROM users
    UNION ALL  
    SELECT 'users', 'phone', phone FROM users
) t
GROUP BY table_name, column_name;
```

**📈 时间字段选择性**
```sql
-- 分析日期时间字段的选择性
SELECT 
    '完整时间戳' as time_type,
    COUNT(DISTINCT created_at) / COUNT(*) AS selectivity
FROM orders
UNION ALL
SELECT 
    '日期部分' as time_type,
    COUNT(DISTINCT DATE(created_at)) / COUNT(*) AS selectivity  
FROM orders
UNION ALL
SELECT 
    '小时部分' as time_type,
    COUNT(DISTINCT HOUR(created_at)) / COUNT(*) AS selectivity
FROM orders;

-- 结果解读：
-- 完整时间戳：选择性很高(0.95+)，适合建索引
-- 日期部分：选择性中等(0.1-0.5)，需评估查询模式
-- 小时部分：选择性很低(0.04)，不适合单独建索引
```

### 2.3 基数估算方法


**🔍 MySQL内部基数估算**
```sql
-- 查看MySQL对索引基数的估算
SHOW INDEX FROM users;

-- 分析索引统计信息
SELECT 
    table_name,
    index_name, 
    column_name,
    cardinality,  -- MySQL估算的基数
    cardinality / (SELECT table_rows FROM information_schema.tables 
                   WHERE table_name = 'users') AS estimated_selectivity
FROM information_schema.statistics 
WHERE table_name = 'users';
```

**⚡ 采样分析技术**
```sql
-- 大表快速采样分析选择性
-- 方法1：随机采样
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS sample_selectivity
FROM (
    SELECT column_name 
    FROM large_table 
    WHERE RAND() < 0.01  -- 采样1%的数据
    LIMIT 10000
) sample_data;

-- 方法2：系统采样  
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) AS sample_selectivity
FROM large_table 
WHERE id % 100 = 0;  -- 每100条取1条
```

---

## 3. 📋 数据分布统计方法


### 3.1 数据分布分析


**🔸 数据分布统计**
```sql
-- 分析数据分布情况
SELECT 
    column_value,
    COUNT(*) as frequency,
    COUNT(*) / (SELECT COUNT(*) FROM table_name) * 100 AS percentage,
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) as rank_order
FROM table_name 
GROUP BY column_value
ORDER BY frequency DESC
LIMIT 20;

-- 实际示例：分析城市字段分布
SELECT 
    city,
    COUNT(*) as user_count,
    ROUND(COUNT(*) / (SELECT COUNT(*) FROM users) * 100, 2) AS percentage
FROM users 
GROUP BY city
ORDER BY user_count DESC
LIMIT 10;

-- 结果示例：
-- city    | user_count | percentage
-- 北京    | 25000      | 25.00%
-- 上海    | 20000      | 20.00%  
-- 深圳    | 15000      | 15.00%
-- 广州    | 10000      | 10.00%
```

### 3.2 直方图统计分析


**📊 MySQL 8.0直方图功能**
```sql
-- 创建直方图统计信息
ANALYZE TABLE users UPDATE HISTOGRAM ON city, age_group WITH 50 BUCKETS;

-- 查看直方图信息
SELECT 
    schema_name,
    table_name, 
    column_name,
    histogram
FROM information_schema.column_statistics 
WHERE table_name = 'users';

-- 删除直方图
ANALYZE TABLE users DROP HISTOGRAM ON city;
```

**🔍 手动直方图分析**
```sql
-- 手动创建年龄分布直方图
SELECT 
    CASE 
        WHEN age BETWEEN 0 AND 18 THEN '0-18'
        WHEN age BETWEEN 19 AND 25 THEN '19-25'
        WHEN age BETWEEN 26 AND 35 THEN '26-35'
        WHEN age BETWEEN 36 AND 50 THEN '36-50'
        ELSE '50+'
    END AS age_group,
    COUNT(*) as count,
    ROUND(COUNT(*) / (SELECT COUNT(*) FROM users) * 100, 2) AS percentage
FROM users 
GROUP BY 
    CASE 
        WHEN age BETWEEN 0 AND 18 THEN '0-18'
        WHEN age BETWEEN 19 AND 25 THEN '19-25'
        WHEN age BETWEEN 26 AND 35 THEN '26-35'
        WHEN age BETWEEN 36 AND 50 THEN '36-50'
        ELSE '50+'
    END
ORDER BY count DESC;
```

### 3.3 唯一值比例分析


**🎯 不同粒度的唯一值分析**
```sql
-- 多字段组合的选择性分析
SELECT 
    'single_column' as combination_type,
    'city' as columns,
    COUNT(DISTINCT city) / COUNT(*) AS selectivity
FROM users
UNION ALL
SELECT 
    'two_columns' as combination_type,
    'city+age_group' as columns,
    COUNT(DISTINCT CONCAT(city, '_', age_group)) / COUNT(*) AS selectivity
FROM users  
UNION ALL
SELECT 
    'three_columns' as combination_type,
    'city+age_group+gender' as columns,
    COUNT(DISTINCT CONCAT(city, '_', age_group, '_', gender)) / COUNT(*) AS selectivity
FROM users;

-- 结果分析：
-- 单列选择性低，组合后选择性提高
-- 帮助决定是否建立复合索引
```

---

## 4. ⚡ 索引效果评估策略


### 4.1 选择性阈值判断


**📏 选择性阈值标准**
```
高效索引阈值：选择性 >= 0.8
- 数据几乎不重复
- 索引过滤效果优秀  
- 强烈推荐建立索引

中等索引阈值：0.3 <= 选择性 < 0.8  
- 数据有一定重复
- 索引有一定效果
- 根据查询频率决定

低效索引阈值：选择性 < 0.3
- 数据重复较多
- 索引效果有限
- 需谨慎考虑是否建立
```

**🔍 阈值判断实现**
```sql
-- 自动评估字段是否适合建索引
SELECT 
    column_name,
    selectivity,
    unique_count,
    total_count,
    CASE 
        WHEN selectivity >= 0.8 THEN '强烈推荐'
        WHEN selectivity >= 0.3 THEN '可以考虑'  
        WHEN selectivity >= 0.1 THEN '需要评估'
        ELSE '不推荐'
    END AS index_recommendation,
    CASE
        WHEN selectivity >= 0.8 THEN '高选择性，索引效果优秀'
        WHEN selectivity >= 0.3 THEN '中等选择性，索引有一定效果'
        WHEN selectivity >= 0.1 THEN '低选择性，索引效果有限'  
        ELSE '极低选择性，可能不走索引'
    END AS effect_description
FROM (
    SELECT 
        'email' as column_name,
        COUNT(DISTINCT email) / COUNT(*) AS selectivity,
        COUNT(DISTINCT email) AS unique_count,
        COUNT(*) AS total_count
    FROM users
) t;
```

### 4.2 索引效果预测


**📊 查询成本预测**
```sql
-- 预测不同选择性下的查询成本
SELECT 
    table_name,
    column_name,
    selectivity,
    total_rows,
    ROUND(total_rows * (1 - selectivity)) AS estimated_filtered_rows,
    CASE 
        WHEN selectivity >= 0.8 THEN 'Index Scan (高效)'
        WHEN selectivity >= 0.3 THEN 'Index Scan (中等)'
        WHEN selectivity >= 0.1 THEN '可能Index Scan'
        ELSE 'Table Scan (全表扫描)'
    END AS predicted_scan_type
FROM (
    SELECT 
        'users' as table_name,
        'status' as column_name,
        COUNT(DISTINCT status) / COUNT(*) AS selectivity,
        COUNT(*) AS total_rows
    FROM users
) analysis;
```

### 4.3 实际执行计划验证


**🔧 执行计划分析**
```sql
-- 验证索引实际使用情况
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';
EXPLAIN SELECT * FROM users WHERE gender = '男';
EXPLAIN SELECT * FROM users WHERE city = '北京';

-- 分析key_len、rows、filtered等指标
-- key_len：索引使用的字节数
-- rows：预计扫描的行数  
-- filtered：过滤后剩余的行数百分比
```

**📈 性能测试对比**
```sql
-- 开启查询分析
SET profiling = 1;

-- 执行测试查询
SELECT * FROM users WHERE email = 'test@example.com';
SELECT * FROM users WHERE gender = '男';

-- 查看性能分析结果
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;
SHOW PROFILE FOR QUERY 2;

-- 对比不同选择性字段的查询耗时
```

---

## 5. 🚀 优化建议与实践


### 5.1 索引建立建议


**✅ 高选择性字段优化**
```sql
-- 推荐建立索引的场景
CREATE INDEX idx_user_email ON users(email);        -- 选择性: 0.99+
CREATE INDEX idx_user_phone ON users(phone);        -- 选择性: 0.99+  
CREATE INDEX idx_order_number ON orders(order_no);  -- 选择性: 1.0

-- 这些字段特点：
-- 1. 数据几乎不重复
-- 2. 查询时能快速定位少量记录
-- 3. 索引维护成本合理
```

**⚠️ 低选择性字段处理**
```sql
-- 低选择性字段的优化策略

-- 策略1：复合索引提高选择性
CREATE INDEX idx_user_status_city ON users(status, city, created_at);
-- 单独status选择性低，组合后选择性提高

-- 策略2：部分索引（MySQL 8.0+）
CREATE INDEX idx_user_active ON users(user_id) WHERE status = 'active';
-- 只对活跃用户建索引

-- 策略3：函数索引
CREATE INDEX idx_user_year ON users((YEAR(created_at)));
-- 对时间函数结果建索引
```

### 5.2 索引优化策略


**🎯 复合索引选择性优化**
```sql
-- 复合索引字段顺序优化原则：选择性高的字段放前面

-- 分析各字段选择性
SELECT 
    'city' as field, COUNT(DISTINCT city) / COUNT(*) AS selectivity FROM users
UNION ALL
SELECT 
    'age_group', COUNT(DISTINCT age_group) / COUNT(*) FROM users  
UNION ALL
SELECT 
    'status', COUNT(DISTINCT status) / COUNT(*) FROM users;

-- 结果：city(0.1) < age_group(0.05) < status(0.02)
-- 优化建议：CREATE INDEX idx_composite ON users(city, age_group, status);
```

**🔧 索引维护优化**
```sql
-- 定期更新索引统计信息
ANALYZE TABLE users;

-- 检查索引使用情况
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,
    count_write,
    count_read / (count_read + count_write) * 100 AS read_percentage
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE object_schema = 'your_database'
ORDER BY count_read DESC;

-- 清理未使用的索引
-- 如果count_read很低，考虑删除该索引
```

### 5.3 监控与调优


**📊 选择性监控**
```sql
-- 创建选择性监控视图
CREATE VIEW v_index_selectivity AS
SELECT 
    t.table_schema,
    t.table_name,
    s.index_name,
    s.column_name,
    s.cardinality,
    t.table_rows,
    ROUND(s.cardinality / t.table_rows, 4) AS selectivity,
    CASE 
        WHEN s.cardinality / t.table_rows >= 0.8 THEN 'EXCELLENT'
        WHEN s.cardinality / t.table_rows >= 0.3 THEN 'GOOD'
        WHEN s.cardinality / t.table_rows >= 0.1 THEN 'FAIR'
        ELSE 'POOR'
    END AS selectivity_grade
FROM information_schema.statistics s
JOIN information_schema.tables t ON s.table_schema = t.table_schema 
    AND s.table_name = t.table_name
WHERE t.table_schema NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY selectivity DESC;

-- 使用监控视图
SELECT * FROM v_index_selectivity WHERE selectivity < 0.1;
```

**⚡ 自动化优化建议**
```sql
-- 生成索引优化建议的存储过程
DELIMITER //
CREATE PROCEDURE analyze_index_selectivity(IN db_name VARCHAR(64))
BEGIN
    SELECT 
        table_name,
        column_name,
        selectivity,
        CASE 
            WHEN selectivity >= 0.8 THEN 
                CONCAT('推荐保留索引: CREATE INDEX idx_', table_name, '_', column_name, ' ON ', table_name, '(', column_name, ');')
            WHEN selectivity >= 0.3 THEN 
                '中等选择性，根据查询频率决定'
            WHEN selectivity >= 0.1 THEN 
                '考虑与其他字段组合建立复合索引'
            ELSE 
                CONCAT('建议删除索引: DROP INDEX idx_', table_name, '_', column_name, ' ON ', table_name, ';')
        END AS recommendation
    FROM v_index_selectivity 
    WHERE table_schema = db_name
    ORDER BY selectivity DESC;
END //
DELIMITER ;

-- 调用分析过程
CALL analyze_index_selectivity('your_database');
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 选择性定义：不重复值数量 / 总记录数，衡量数据独特性
🔸 选择性作用：评估索引过滤效果，预测查询性能
🔸 计算方法：COUNT(DISTINCT column) / COUNT(*)
🔸 阈值标准：>=0.8高效，0.3-0.8中等，<0.3低效
🔸 优化策略：复合索引、部分索引、定期统计更新
```

### 6.2 关键理解要点


**🔹 选择性的实际意义**
```
选择性本质：衡量索引的"筛选能力"
- 高选择性 = 强筛选能力 = 快速定位少量数据
- 低选择性 = 弱筛选能力 = 需要扫描大量数据
- 影响MySQL是否选择使用索引
```

**🔹 选择性与查询性能的关系**
```
性能影响机制：
- 选择性高 → 索引扫描行数少 → 查询快
- 选择性低 → 索引扫描行数多 → 可能不如全表扫描
- MySQL优化器会根据选择性估算成本选择执行方式
```

**🔹 优化思路**
```
单列选择性低 → 考虑复合索引
复合索引 → 选择性高的字段放前面  
数据分布不均 → 考虑部分索引
定期监控 → 及时调整索引策略
```

### 6.3 实际应用指导


**🎯 适合建索引的场景**
- **主键、唯一键**：选择性1.0，必须建索引
- **用户标识**：手机号、邮箱、身份证，选择性高
- **业务编号**：订单号、商品编码，选择性高
- **时间戳**：精确到秒的时间，选择性高

**⚠️ 不适合建索引的场景**  
- **状态字段**：性别、是否删除，选择性极低
- **分类字段**：类型、级别，值域很小
- **布尔字段**：真/假，选择性最低

**🔧 优化实践建议**
- 新建索引前先分析选择性
- 定期检查现有索引的选择性变化
- 删除长期不使用或选择性很低的索引
- 考虑用复合索引替代多个单列索引

**核心记忆**：
- 选择性衡量数据独特性，影响索引效果
- 高选择性字段适合建索引，低选择性需谨慎
- 复合索引可提高整体选择性
- 定期分析和维护是索引优化的关键