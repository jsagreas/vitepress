---
title: 14、唯一索引设计
---
## 📚 目录

1. [唯一索引定义与基本概念](#1-唯一索引定义与基本概念)
2. [唯一性约束机制](#2-唯一性约束机制)
3. [重复值检查原理](#3-重复值检查原理)
4. [性能影响分析](#4-性能影响分析)
5. [复合唯一索引设计](#5-复合唯一索引设计)
6. [部分唯一索引应用](#6-部分唯一索引应用)
7. [唯一冲突处理策略](#7-唯一冲突处理策略)
8. [业务规则实现](#8-业务规则实现)
9. [性能监控与优化](#9-性能监控与优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔧 唯一索引定义与基本概念


### 1.1 什么是唯一索引


**💡 核心定义**
```
唯一索引（Unique Index）：保证索引列中的值唯一性的特殊索引
简单理解：就像身份证号一样，每个人的都不能重复
```

**🎯 唯一索引 vs 普通索引**
```
普通索引：     可以重复    快速查找
唯一索引：     不能重复    快速查找 + 数据唯一性保证

示例对比：
普通索引(姓名)：张三、张三、李四  ← 可以重复
唯一索引(邮箱)：a@qq.com、b@qq.com  ← 必须唯一
```

### 1.2 唯一索引的作用


**🔸 双重功能**
```
功能1：数据约束
• 防止重复数据插入
• 保证业务规则的完整性
• 维护数据的一致性

功能2：查询优化
• 提供快速查询能力
• MySQL知道值是唯一的，可以优化查询计划
• 一旦找到匹配值就停止搜索
```

### 1.3 创建方式对比


**📝 三种创建方式**

```sql
-- 方式1：建表时创建
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE KEY,
    username VARCHAR(50),
    UNIQUE INDEX uk_username (username)
);

-- 方式2：后续添加
ALTER TABLE users ADD UNIQUE INDEX uk_phone (phone);

-- 方式3：直接创建
CREATE UNIQUE INDEX uk_id_card ON users(id_card);
```

---

## 2. ⚖️ 唯一性约束机制


### 2.1 约束检查时机


**🕐 检查时间点**
```
插入操作(INSERT)：
• 检查时机：数据插入前
• 检查内容：新值是否与现有值冲突
• 失败处理：抛出1062错误码

更新操作(UPDATE)：
• 检查时机：数据更新前  
• 检查内容：更新后的值是否造成重复
• 失败处理：回滚更新操作

删除操作(DELETE)：
• 无需检查：删除不会造成重复
• 性能影响：几乎无额外开销
```

### 2.2 NULL值的特殊处理


**🔍 NULL值规则**
```
重要规则：多个NULL值是允许的！

原因解释：
• NULL表示"未知"或"不存在"
• 两个未知值不能判断是否相等
• 因此多个NULL不算重复

实际示例：
email字段设置唯一索引，以下数据是合法的：
用户A：email = 'test@qq.com'
用户B：email = NULL
用户C：email = NULL
用户D：email = 'hello@qq.com'
```

**💻 验证示例**
```sql
-- 创建测试表
CREATE TABLE test_unique (
    id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(100) UNIQUE
);

-- 插入数据测试
INSERT INTO test_unique (email) VALUES ('test@qq.com');
INSERT INTO test_unique (email) VALUES (NULL);
INSERT INTO test_unique (email) VALUES (NULL);  -- 成功！
INSERT INTO test_unique (email) VALUES ('test@qq.com');  -- 失败！

-- 查看结果
SELECT * FROM test_unique;
-- 结果：
-- id | email
-- 1  | test@qq.com
-- 2  | NULL
-- 3  | NULL
```

### 2.3 约束级别设置


**⚙️ 约束严格程度**
```sql
-- 严格模式（推荐生产环境）
SET sql_mode = 'STRICT_TRANS_TABLES';
-- 插入重复值直接报错

-- 宽松模式（开发测试）
SET sql_mode = '';
-- 可能给出警告但继续执行
```

---

## 3. 🔍 重复值检查原理


### 3.1 检查机制深入


**🏗️ 检查流程图**
```
新数据插入流程：

输入新值 → 计算哈希值 → 在B+树中定位 → 检查是否存在
    ↓              ↓             ↓           ↓
 value='a@qq.com' hash(value)   树节点搜索   found/not found
    ↓                                           ↓
存在：抛出错误                           不存在：允许插入
ERROR 1062: Duplicate entry                  ↓
                                        更新索引结构
```

### 3.2 B+树中的检查过程


**🌳 索引结构查找**
```
B+树索引结构示例：

                   [m]
                  /   \
            [a,f,k]   [p,t,z]
           /  |  |  \     ...
    [a,b,c][f,g,h][k,l]   

查找 'g@qq.com' 的过程：
1. 从根节点开始：'g' 在 a-k 范围内
2. 进入左子树：'g' 在 f-h 范围内  
3. 到达叶子节点：检查是否存在 'g@qq.com'
4. 返回结果：存在/不存在
```

### 3.3 检查性能分析


**⚡ 性能特点**
```
时间复杂度：O(log n)
• n为索引记录数量
• 与普通索引查找相同
• 额外开销主要在约束检查逻辑

空间复杂度：O(1)
• 不需要额外存储空间
• 复用现有索引结构

实际性能：
• 100万记录：约需要20次比较
• 1000万记录：约需要24次比较
• 性能表现非常优秀
```

---

## 4. 📊 性能影响分析


### 4.1 插入性能影响


**📈 插入操作性能对比**

| 操作类型 | **无索引** | **普通索引** | **唯一索引** | **性能差异** |
|---------|-----------|-------------|-------------|-------------|
| 🔸 **单条插入** | `100%` | `105%` | `110%` | `+10%开销` |
| 🔸 **批量插入** | `100%` | `120%` | `135%` | `+35%开销` |
| 🔸 **高并发插入** | `100%` | `130%` | `150%` | `+50%开销` |

**🔍 性能影响原因**
```
额外开销来源：
1. 重复值检查：需要在索引中查找
2. 锁机制：防止并发插入相同值
3. 回滚准备：冲突时需要回滚事务
4. 错误处理：生成错误信息的开销
```

### 4.2 更新性能影响


**🔄 更新操作分析**
```sql
-- 性能测试示例
-- 表结构
CREATE TABLE perf_test (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE KEY,
    name VARCHAR(50),
    age INT,
    INDEX idx_name (name)
);

-- 场景1：更新非唯一索引字段（影响小）
UPDATE perf_test SET age = 25 WHERE id = 1;
-- 开销：几乎无额外影响

-- 场景2：更新唯一索引字段（影响大）
UPDATE perf_test SET email = 'new@qq.com' WHERE id = 1;
-- 开销：需要检查新邮箱是否重复
```

### 4.3 删除性能影响


**🗑️ 删除操作特点**
```
性能影响：几乎无额外开销

原因分析：
• 删除不会产生重复值
• 无需进行唯一性检查
• 只需要正常的索引维护操作

实际表现：
• 删除性能与普通索引基本相同
• 是唯一索引开销最小的操作
```

---

## 5. 🔗 复合唯一索引设计


### 5.1 复合唯一索引概念


**💡 什么是复合唯一索引**
```
定义：由多个字段组合构成的唯一索引
核心：组合值必须唯一，单个字段可以重复

生活例子：
• 学校+学号 = 唯一学生
• 年份+月份+商品ID = 唯一销售记录
```

### 5.2 设计实例


**📝 电商订单表设计**
```sql
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    order_date DATE NOT NULL,
    order_no VARCHAR(50) NOT NULL,
    amount DECIMAL(10,2),
    
    -- 复合唯一索引：用户+日期+订单号
    UNIQUE KEY uk_user_date_no (user_id, order_date, order_no),
    
    -- 单独的唯一索引：订单号全局唯一
    UNIQUE KEY uk_order_no (order_no)
);
```

**🎯 业务含义**
```
uk_user_date_no 约束含义：
• 同一用户在同一天不能有相同订单号
• 但不同用户可以有相同订单号
• 同一用户不同日期可以有相同订单号

允许的数据：
用户1, 2023-01-01, ORD001  ✅
用户2, 2023-01-01, ORD001  ✅ (不同用户)
用户1, 2023-01-02, ORD001  ✅ (不同日期)

不允许的数据：
用户1, 2023-01-01, ORD001  
用户1, 2023-01-01, ORD001  ❌ (完全重复)
```

### 5.3 字段顺序的重要性


**🔄 索引字段顺序影响**
```sql
-- 方案A：用户ID在前
UNIQUE KEY uk_user_date (user_id, order_date)

-- 方案B：日期在前  
UNIQUE KEY uk_date_user (order_date, user_id)

查询性能对比：
-- 查询1：根据用户查订单
SELECT * FROM orders WHERE user_id = 123;
-- 方案A：高效 ✅    方案B：低效 ❌

-- 查询2：根据日期查订单
SELECT * FROM orders WHERE order_date = '2023-01-01';
-- 方案A：低效 ❌    方案B：高效 ✅
```

**🎯 设计原则**
```
字段顺序选择标准：
1. 查询频率：常查询的字段放前面
2. 选择性：区分度高的字段放前面
3. 业务逻辑：符合业务查询习惯
```

---

## 6. 🎨 部分唯一索引应用


### 6.1 部分唯一索引概念


**💡 什么是部分唯一索引**
```
定义：只对满足特定条件的记录建立唯一约束
应用场景：某些状态下需要唯一，其他状态下允许重复

典型例子：
• 只有激活的用户邮箱需要唯一
• 只有有效的订单号需要唯一
• 只有发布的文章标题需要唯一
```

### 6.2 MySQL实现方式


**⚠️ MySQL限制说明**
```
重要提醒：
MySQL不直接支持条件唯一索引（如PostgreSQL的WHERE子句）
需要通过其他方式来实现部分唯一性
```

**🔧 替代实现方案**

**方案1：函数索引（MySQL 8.0+）**
```sql
-- 用户表：只有激活用户的邮箱需要唯一
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100),
    status ENUM('active', 'inactive', 'deleted'),
    
    -- 函数唯一索引：只对激活用户的邮箱建立唯一约束
    UNIQUE KEY uk_active_email ((CASE WHEN status = 'active' THEN email END))
);
```

**方案2：辅助字段法**
```sql
-- 创建辅助字段存储需要唯一的值
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    status ENUM('draft', 'published', 'deleted'),
    unique_title VARCHAR(200),  -- 辅助字段
    
    UNIQUE KEY uk_unique_title (unique_title)
);

-- 触发器维护辅助字段
DELIMITER $$
CREATE TRIGGER tr_articles_unique 
BEFORE INSERT ON articles
FOR EACH ROW 
BEGIN
    IF NEW.status = 'published' THEN
        SET NEW.unique_title = NEW.title;
    ELSE
        SET NEW.unique_title = NULL;
    END IF;
END$$
DELIMITER ;
```

### 6.3 实际应用案例


**📱 用户账号管理**
```sql
-- 用户表设计
CREATE TABLE user_accounts (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    status ENUM('active', 'suspended', 'deleted') DEFAULT 'active',
    
    -- 组合唯一索引：状态+用户名
    UNIQUE KEY uk_active_username (status, username),
    
    -- 组合唯一索引：状态+邮箱
    UNIQUE KEY uk_active_email (status, email)
);

-- 业务逻辑
-- 激活用户：username和email必须唯一
-- 删除用户：允许username和email重复使用
```

---

## 7. ⚠️ 唯一冲突处理策略


### 7.1 冲突检测与处理


**🚨 错误码识别**
```sql
-- 唯一约束冲突的错误信息
ERROR 1062 (23000): Duplicate entry 'test@qq.com' for key 'uk_email'

错误码解析：
• 1062：MySQL错误代码
• 23000：SQL标准错误状态
• Duplicate entry：重复条目
• 'test@qq.com'：冲突的值
• 'uk_email'：冲突的索引名
```

### 7.2 应用层处理策略


**🛠️ 策略1：INSERT IGNORE**
```sql
-- 忽略冲突，静默跳过
INSERT IGNORE INTO users (email, name) 
VALUES ('test@qq.com', '张三');

-- 特点：
-- ✅ 不会报错
-- ❌ 无法知道是否真正插入
-- 适用：批量导入，允许跳过重复数据
```

**🔄 策略2：ON DUPLICATE KEY UPDATE**
```sql
-- 冲突时执行更新操作
INSERT INTO users (email, name, login_count) 
VALUES ('test@qq.com', '张三', 1)
ON DUPLICATE KEY UPDATE 
    name = VALUES(name),
    login_count = login_count + 1,
    updated_at = NOW();

-- 特点：
-- ✅ 插入或更新都会成功
-- ✅ 可以自定义更新逻辑
-- 适用：计数器、最新状态更新
```

**🔍 策略3：REPLACE INTO**
```sql
-- 先删除冲突记录，再插入新记录
REPLACE INTO users (email, name) 
VALUES ('test@qq.com', '李四');

-- 特点：
-- ⚠️ 会删除原记录的所有数据
-- ⚠️ 可能影响其他关联数据
-- 适用：完全替换场景
```

### 7.3 应用程序处理模式


**🔧 Java处理示例**
```java
public class UserService {
    
    // 方法1：捕获异常处理
    public boolean insertUser(User user) {
        try {
            userDao.insert(user);
            return true;
        } catch (DuplicateKeyException e) {
            log.warn("用户邮箱已存在: {}", user.getEmail());
            return false;
        }
    }
    
    // 方法2：先查询再插入
    public boolean insertUserSafe(User user) {
        if (userDao.existsByEmail(user.getEmail())) {
            return false;  // 邮箱已存在
        }
        
        try {
            userDao.insert(user);
            return true;
        } catch (DuplicateKeyException e) {
            // 并发情况下仍可能冲突
            return false;
        }
    }
    
    // 方法3：使用ON DUPLICATE KEY UPDATE
    public void insertOrUpdateUser(User user) {
        userDao.insertOrUpdate(user);  // 总是成功
    }
}
```

---

## 8. 💼 业务规则实现


### 8.1 常见业务场景


**📋 用户管理系统**
```sql
-- 用户表设计
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    id_card VARCHAR(18),
    
    -- 业务唯一性约束
    UNIQUE KEY uk_username (username),    -- 用户名唯一
    UNIQUE KEY uk_email (email),          -- 邮箱唯一
    UNIQUE KEY uk_phone (phone),          -- 手机号唯一
    UNIQUE KEY uk_id_card (id_card)       -- 身份证唯一
);
```

**🏪 商品管理系统**
```sql
-- 商品表设计
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT,
    sku VARCHAR(50) NOT NULL,         -- 商品编码
    name VARCHAR(200) NOT NULL,       -- 商品名称
    category_id INT NOT NULL,         -- 分类ID
    brand_id INT NOT NULL,            -- 品牌ID
    
    -- 全局唯一
    UNIQUE KEY uk_sku (sku),
    
    -- 同分类下商品名称唯一
    UNIQUE KEY uk_category_name (category_id, name),
    
    -- 同品牌下商品编码唯一
    UNIQUE KEY uk_brand_sku (brand_id, sku)
);
```

### 8.2 分层唯一性设计


**🏢 组织架构系统**
```sql
-- 组织表设计
CREATE TABLE departments (
    id INT PRIMARY KEY AUTO_INCREMENT,
    code VARCHAR(20) NOT NULL,        -- 部门编码
    name VARCHAR(100) NOT NULL,       -- 部门名称
    parent_id INT,                    -- 上级部门
    level INT NOT NULL,               -- 层级
    
    -- 全公司部门编码唯一
    UNIQUE KEY uk_code (code),
    
    -- 同级部门名称唯一
    UNIQUE KEY uk_parent_name (parent_id, name)
);

-- 示例数据
INSERT INTO departments VALUES
(1, 'ROOT', '总公司', NULL, 1),
(2, 'TECH', '技术部', 1, 2),
(3, 'SALES', '销售部', 1, 2),
(4, 'DEV', '开发组', 2, 3),      -- 技术部下的开发组
(5, 'DEV', '开发组', 3, 3);      -- 销售部下的开发组（允许！）
```

### 8.3 时间维度唯一性


**📅 订单系统设计**
```sql
-- 订单表：同一天内订单号唯一
CREATE TABLE daily_orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_date DATE NOT NULL,
    order_no VARCHAR(20) NOT NULL,
    user_id INT NOT NULL,
    amount DECIMAL(10,2),
    
    -- 每日订单号唯一
    UNIQUE KEY uk_date_order_no (order_date, order_no),
    
    -- 用户当日只能有一个订单（特殊业务）
    UNIQUE KEY uk_user_date (user_id, order_date)
);
```

---

## 9. 📈 性能监控与优化


### 9.1 监控指标


**📊 关键性能指标**
```sql
-- 查看唯一索引使用情况
SHOW INDEX FROM users WHERE Non_unique = 0;

-- 监控重复键错误
SHOW GLOBAL STATUS LIKE 'Handler_write%';
-- Handler_write: 写入请求总数
-- Handler_write_retry: 重试次数（包含唯一约束冲突）

-- 查看表的约束冲突统计
SELECT TABLE_SCHEMA, TABLE_NAME, CONSTRAINT_NAME
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS 
WHERE CONSTRAINT_TYPE = 'UNIQUE';
```

### 9.2 性能优化策略


**⚡ 优化技巧**

**1. 合理设计字段长度**
```sql
-- ❌ 不好的设计
email VARCHAR(500) UNIQUE  -- 过长影响索引性能

-- ✅ 好的设计  
email VARCHAR(100) UNIQUE  -- 足够用且高效
```

**2. 选择合适的数据类型**
```sql
-- ❌ 不好的设计
user_id VARCHAR(20) UNIQUE  -- 字符串比较慢

-- ✅ 好的设计
user_id INT UNIQUE         -- 整数比较快
```

**3. 批量操作优化**
```sql
-- ❌ 单条插入（慢）
INSERT INTO users (email) VALUES ('a@qq.com');
INSERT INTO users (email) VALUES ('b@qq.com');

-- ✅ 批量插入（快）
INSERT IGNORE INTO users (email) VALUES 
('a@qq.com'), ('b@qq.com'), ('c@qq.com');
```

### 9.3 故障排查


**🔍 常见问题诊断**

**问题1：插入性能下降**
```sql
-- 检查是否有死锁
SHOW ENGINE INNODB STATUS;

-- 查看锁等待情况
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```

**问题2：大量重复键错误**
```sql
-- 分析错误日志
SHOW GLOBAL STATUS LIKE 'Handler_write_retry';

-- 检查应用逻辑
-- 1. 是否有并发插入相同数据？
-- 2. 是否缺少事前检查？
-- 3. 是否需要使用INSERT IGNORE？
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 唯一索引本质：既是索引又是约束，保证数据唯一性
🔸 检查机制：插入和更新时进行重复值检查，删除无影响
🔸 NULL处理：多个NULL值是允许的，不算重复
🔸 性能影响：增加10-50%的插入开销，查询性能略有提升
🔸 冲突处理：IGNORE、ON DUPLICATE KEY UPDATE、REPLACE策略
```

### 10.2 关键理解要点


**🔹 什么时候使用唯一索引**
```
适用场景：
✅ 业务要求数据唯一（邮箱、手机号、身份证）
✅ 防止重复插入（订单号、商品编码）
✅ 提高查询性能（经常按唯一值查询）

不适用场景：
❌ 数据天然允许重复（姓名、地址）
❌ 高频插入且无唯一性要求
❌ 临时表或中间表
```

**🔹 复合唯一索引设计原则**
```
设计要点：
• 字段顺序：常查询的放前面
• 业务逻辑：符合实际业务场景
• 性能考虑：区分度高的放前面
• 维护成本：字段数量不宜过多
```

**🔹 性能优化关键点**
```
优化策略：
• 选择合适的数据类型（整数优于字符串）
• 控制字段长度（够用即可）
• 批量操作替代单条操作
• 合理处理冲突（选择合适的策略）
```

### 10.3 实际应用指导


**💼 业务实践**
- **电商系统**：商品SKU、订单号、用户邮箱唯一性
- **用户系统**：用户名、邮箱、手机号唯一约束  
- **内容系统**：文章标题、分类下标题唯一性
- **财务系统**：交易流水号、发票号码唯一性

**🔧 开发建议**
- **设计阶段**：明确哪些字段需要唯一性约束
- **开发阶段**：合理处理唯一冲突异常
- **测试阶段**：测试并发插入和边界情况
- **上线阶段**：监控性能指标和错误率

**核心记忆**：
- 唯一索引=查询优化+数据约束
- 设计时考虑业务场景和查询模式
- 处理冲突要选择合适的策略
- 性能监控和优化不可忽视