---
title: 33、全文索引使用
---
## 📚 目录

1. [全文索引基础概念](#1-全文索引基础概念)
2. [FULLTEXT索引创建与管理](#2-FULLTEXT索引创建与管理)
3. [全文搜索模式详解](#3-全文搜索模式详解)
4. [停用词与词长配置](#4-停用词与词长配置)
5. [相关性排序机制](#5-相关性排序机制)
6. [中文分词支持](#6-中文分词支持)
7. [性能优化与监控](#7-性能优化与监控)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📖 全文索引基础概念


### 1.1 什么是全文索引


**🔸 全文索引的本质**
全文索引就像是给一本厚厚的书做了一个"内容目录"，但不是普通的章节目录，而是把书中每个重要词汇都记录下来，标明它们出现在第几页第几行。

```
传统索引 vs 全文索引的区别：

普通索引：
用户ID: 1001 → 指向具体记录位置
就像电话簿，知道姓名就能找到电话号码

全文索引：
"MySQL" → 出现在第5条、第23条、第156条记录中
"优化" → 出现在第8条、第45条、第234条记录中
就像书籍的关键词索引，一个词可能在多个地方出现
```

**🔸 全文索引解决的问题**
想象你要在一个包含百万篇文章的网站上搜索"MySQL性能优化"，如果用传统的`LIKE`语句：

```sql
-- 传统方式：效率极低
SELECT * FROM articles 
WHERE content LIKE '%MySQL%' AND content LIKE '%性能%' AND content LIKE '%优化%';

-- 问题：
-- 1. 需要扫描每一条记录
-- 2. 无法按相关性排序
-- 3. 不支持复杂搜索语法
```

而全文索引就像有了专业的搜索引擎，能够：
- **快速定位**：直接找到包含关键词的文档
- **相关性排序**：最匹配的结果排在前面
- **智能搜索**：支持复杂的搜索语法

### 1.2 全文索引的工作原理


**🔸 工作机制图解**
```
文档内容                    倒排索引结构
┌─────────────────┐        ┌──────────────────┐
│文档1: MySQL优化  │───────→│MySQL: [1,3,5]    │
│文档2: 数据库设计 │        │优化:  [1,4,7]    │
│文档3: MySQL入门  │        │数据库:[2,4,6]    │
│文档4: 性能优化   │        │设计:  [2,6]      │
│文档5: MySQL高级  │        │入门:  [3,8]      │
└─────────────────┘        │性能:  [4,7,9]    │
                           │高级:  [5,8,9]    │
                           └──────────────────┘
```

**🔸 搜索过程**
当你搜索"MySQL 优化"时：
1. **分词**：将"MySQL 优化"拆分成["MySQL", "优化"]
2. **查找**：在倒排索引中找到这些词
3. **合并**：找出同时包含两个词的文档
4. **排序**：按相关性分数排序返回结果

### 1.3 适用场景


**🔸 适合使用全文索引的场景**
```
✅ 适用场景：
• 文章内容搜索：博客、新闻网站
• 产品描述搜索：电商平台
• 日志内容分析：系统日志检索
• 文档管理系统：企业知识库搜索
• 评论内容搜索：用户评论检索

❌ 不适用场景：
• 精确匹配：用户名、订单号查询
• 数值范围：价格、时间范围查询
• 短文本：标题、标签搜索
• 频繁更新：实时聊天记录
```

---

## 2. 🛠 FULLTEXT索引创建与管理


### 2.1 基础语法与创建方式


**🔸 创建表时定义全文索引**
```sql
-- 创建带全文索引的表
CREATE TABLE articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    author VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 创建全文索引
    FULLTEXT(title, content)  -- 多列组合索引
) ENGINE=InnoDB;

-- 解释：
-- ENGINE=InnoDB：MySQL 5.6+支持InnoDB全文索引
-- FULLTEXT(title, content)：对标题和内容建立联合全文索引
```

**🔸 为已存在的表添加全文索引**
```sql
-- 方法1：使用ALTER TABLE
ALTER TABLE articles ADD FULLTEXT(content);

-- 方法2：使用CREATE INDEX（推荐）
CREATE FULLTEXT INDEX idx_content ON articles(content);

-- 多列全文索引
CREATE FULLTEXT INDEX idx_title_content ON articles(title, content);
```

**🔸 查看已创建的全文索引**
```sql
-- 查看表的索引信息
SHOW INDEX FROM articles WHERE Index_type = 'FULLTEXT';

-- 查看表结构
DESCRIBE articles;

-- 查看创建表的SQL
SHOW CREATE TABLE articles;
```

### 2.2 索引管理操作


**🔸 删除全文索引**
```sql
-- 删除指定的全文索引
DROP INDEX idx_content ON articles;

-- 或使用ALTER TABLE
ALTER TABLE articles DROP INDEX idx_content;
```

**🔸 重建全文索引**
```sql
-- 当需要重建索引时（比如修改了分词配置）
ALTER TABLE articles DROP INDEX idx_content;
CREATE FULLTEXT INDEX idx_content ON articles(content);

-- 或者禁用后重建
ALTER TABLE articles DISABLE KEYS;
-- 执行大量数据操作
ALTER TABLE articles ENABLE KEYS;
```

### 2.3 支持的数据类型


**🔸 可以建立全文索引的字段类型**
```sql
-- 支持的数据类型
CHAR、VARCHAR、TEXT

-- 示例
CREATE TABLE documents (
    id INT PRIMARY KEY,
    title VARCHAR(255),      -- ✅ 支持
    summary TEXT,           -- ✅ 支持  
    content LONGTEXT,       -- ✅ 支持
    tags VARCHAR(500),      -- ✅ 支持
    price DECIMAL(10,2),    -- ❌ 不支持
    created_at DATETIME,    -- ❌ 不支持
    
    FULLTEXT(title, summary, content)
);
```

---

## 3. 🔍 全文搜索模式详解


### 3.1 自然语言搜索模式


**🔸 基本语法**
自然语言模式是最常用的搜索方式，就像我们平时在搜索引擎中输入关键词一样。

```sql
-- 基本搜索语法
SELECT *, MATCH(title, content) AGAINST('MySQL 优化') as score
FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 优化')
ORDER BY score DESC;

-- 解释：
-- MATCH(title, content)：指定要搜索的字段
-- AGAINST('MySQL 优化')：搜索关键词
-- score：相关性得分，分数越高越相关
```

**🔸 自然语言模式特点**
```
特点说明：
• 自动分词：MySQL会自动将"MySQL 优化"拆分成单个词
• 自动排序：结果按相关性自动排序
• 忽略停用词：the、is、and等常见词会被忽略
• 50%规则：如果某个词在超过50%的记录中出现，会被忽略
```

**🔸 实际应用示例**
```sql
-- 搜索文章内容
SELECT 
    id,
    title,
    SUBSTRING(content, 1, 200) as preview,
    MATCH(title, content) AGAINST('数据库性能优化') as relevance
FROM articles 
WHERE MATCH(title, content) AGAINST('数据库性能优化')
ORDER BY relevance DESC
LIMIT 10;

-- 结果会按相关性排序：
-- 1. 标题包含"数据库性能优化"的文章（最相关）
-- 2. 内容多次提到这些词的文章
-- 3. 只包含部分关键词的文章
```

### 3.2 布尔模式搜索


**🔸 布尔模式基础语法**
布尔模式让搜索更精确，就像给搜索引擎下达精确的指令。

```sql
-- 布尔模式基本语法
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL AND 优化' IN BOOLEAN MODE);

-- 常用操作符：
-- +word    必须包含该词
-- -word    必须不包含该词  
-- word*    以word开头的词
-- "phrase" 精确短语匹配
-- (word1 word2) 分组
-- word1 OR word2  或关系
```

**🔸 实用搜索示例**
```sql
-- 1. 必须包含MySQL，但不能包含Oracle
SELECT * FROM articles 
WHERE MATCH(content) AGAINST('+MySQL -Oracle' IN BOOLEAN MODE);

-- 2. 精确短语搜索
SELECT * FROM articles 
WHERE MATCH(content) AGAINST('"性能优化"' IN BOOLEAN MODE);

-- 3. 前缀搜索（查找以"optim"开头的词：optimize, optimization等）
SELECT * FROM articles 
WHERE MATCH(content) AGAINST('optim*' IN BOOLEAN MODE);

-- 4. 复杂组合搜索
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST(
    '+MySQL +(优化 OR 性能) -"备份恢复"' 
    IN BOOLEAN MODE
);
-- 解释：必须有MySQL，必须有"优化"或"性能"，但不能有"备份恢复"
```

**🔸 布尔操作符详解表**

| 操作符 | 含义 | 示例 | 说明 |
|--------|------|------|------|
| `+` | **必须包含** | `+MySQL` | 结果必须包含MySQL |
| `-` | **必须不包含** | `-Oracle` | 结果不能包含Oracle |
| `*` | **通配符** | `optim*` | 匹配optimize、optimization等 |
| `""` | **精确短语** | `"性能优化"` | 完全匹配这个短语 |
| `()` | **分组** | `+(MySQL Oracle)` | MySQL和Oracle至少有一个 |
| `OR` | **或关系** | `MySQL OR PostgreSQL` | 包含其中任一个即可 |

### 3.3 查询扩展功能


**🔸 查询扩展的作用**
查询扩展就像是智能搜索助手，它会根据你的搜索词找到相关的其他词汇，扩大搜索范围。

```sql
-- 查询扩展语法
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL' WITH QUERY EXPANSION);

-- 工作原理：
-- 1. 先用"MySQL"进行常规搜索
-- 2. 分析最相关的结果，提取相关词汇
-- 3. 用原词+相关词再次搜索，获得更多结果
```

**🔸 扩展效果对比**
```sql
-- 不使用扩展
SELECT COUNT(*) as normal_count
FROM articles 
WHERE MATCH(content) AGAINST('MySQL');

-- 使用扩展  
SELECT COUNT(*) as expanded_count
FROM articles 
WHERE MATCH(content) AGAINST('MySQL' WITH QUERY EXPANSION);

-- 扩展后可能会匹配到：
-- 原词：MySQL
-- 相关词：数据库、SQL、InnoDB、优化、性能等
```

---

## 4. ⚙️ 停用词与词长配置


### 4.1 停用词处理机制


**🔸 什么是停用词**
停用词就像是语言中的"噪音词"，它们出现频率很高但对搜索意义不大。

```
英文停用词示例：
the, is, are, and, or, but, in, on, at, to, for, of, with, by

中文停用词示例：  
的, 了, 在, 是, 我, 你, 有, 和, 就, 不, 人, 都, 一, 一个

为什么要过滤停用词：
• 减少索引大小
• 提高搜索效率  
• 避免无意义的匹配
```

**🔸 查看当前停用词表**
```sql
-- 查看停用词相关配置
SHOW VARIABLES LIKE '%ft_stopword%';

-- 查看停用词表内容
SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DEFAULT_STOPWORD;
```

**🔸 自定义停用词表**
```sql
-- 1. 创建自定义停用词表
CREATE TABLE my_stopwords (
    value VARCHAR(30)
) ENGINE=InnoDB;

-- 2. 插入自定义停用词
INSERT INTO my_stopwords VALUES 
('的'), ('了'), ('在'), ('是'), 
('about'), ('after'), ('all'), ('also');

-- 3. 配置使用自定义停用词表
SET GLOBAL innodb_ft_server_stopword_table = 'mydb/my_stopwords';

-- 4. 重建全文索引使配置生效
ALTER TABLE articles DROP INDEX idx_content;
CREATE FULLTEXT INDEX idx_content ON articles(content);
```

### 4.2 最小词长设置


**🔸 词长限制的作用**
MySQL默认只索引长度≥3个字符的词，这是为了避免索引过多无意义的短词。

```sql
-- 查看当前最小词长设置
SHOW VARIABLES LIKE '%ft_min_word_len%';

-- 结果通常是：
-- ft_min_word_len = 4  (对于InnoDB)
-- ft_min_word_len = 4  (对于MyISAM)
```

**🔸 修改最小词长**
```sql
-- 在my.cnf配置文件中设置
[mysqld]
innodb_ft_min_token_size = 2  # InnoDB引擎
ft_min_word_len = 2           # MyISAM引擎

-- 重启MySQL服务后重建索引
ALTER TABLE articles DROP INDEX idx_content;
CREATE FULLTEXT INDEX idx_content ON articles(content);
```

**🔸 词长设置的权衡**
```
较小的最小词长(如2)：
✅ 优点：能搜索更多短词，如"js"、"go"
❌ 缺点：索引更大，可能有更多噪音

较大的最小词长(如4)：
✅ 优点：索引相对小，搜索质量较高
❌ 缺点：无法搜索短词

推荐设置：
• 英文内容：3-4字符
• 中文内容：2字符（因为中文多为单字或双字词）
```

---

## 5. 📊 相关性排序机制


### 5.1 相关性得分计算


**🔸 MySQL如何计算相关性**
MySQL使用改进的TF-IDF算法计算相关性得分，简单理解就是：

```
相关性得分 = 词频(TF) × 逆文档频率(IDF)

词频(TF)：词在文档中出现的次数
逆文档频率(IDF)：词的稀有程度（越稀有分数越高）

举例说明：
文档A：包含"MySQL"3次，"优化"2次  
文档B：包含"MySQL"1次，"优化"5次
如果"优化"比"MySQL"更稀有，那么文档B的得分可能更高
```

**🔸 查看相关性得分**
```sql
-- 显示详细的相关性得分
SELECT 
    id,
    title,
    MATCH(title, content) AGAINST('MySQL 优化') as score,
    -- 分别查看单个词的得分
    MATCH(title, content) AGAINST('MySQL') as mysql_score,
    MATCH(title, content) AGAINST('优化') as optimization_score
FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 优化')
ORDER BY score DESC;
```

### 5.2 影响相关性的因素


**🔸 主要影响因素**
```
1. 词频密度：
   文档中关键词出现的频率越高，相关性越高

2. 词的稀有性：
   在整个数据集中越少见的词，权重越高

3. 文档长度：
   较短的文档中包含关键词，相关性分数更高

4. 词的位置：
   在标题中出现的词比在内容中权重更高

5. 精确匹配：
   精确匹配短语的相关性高于分散匹配
```

**🔸 优化相关性的实践**
```sql
-- 1. 使用权重不同的字段搜索
SELECT 
    *,
    (MATCH(title) AGAINST('MySQL') * 2 +           -- 标题权重×2
     MATCH(content) AGAINST('MySQL') * 1) as weighted_score
FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL')
ORDER BY weighted_score DESC;

-- 2. 结合字段长度进行调整
SELECT 
    *,
    MATCH(title, content) AGAINST('MySQL 优化') as base_score,
    (MATCH(title, content) AGAINST('MySQL 优化') / 
     (CHAR_LENGTH(content) / 1000)) as length_adjusted_score
FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 优化')
ORDER BY length_adjusted_score DESC;
```

---

## 6. 🌏 中文分词支持


### 6.1 中文分词挑战


**🔸 中文分词的特殊性**
中文和英文在分词上有本质区别：

```
英文分词（简单）：
"MySQL database optimization" → ["MySQL", "database", "optimization"]
天然以空格分隔，边界明确

中文分词（复杂）：
"MySQL数据库性能优化" → 可能的分词结果：
方案1: ["MySQL", "数据库", "性能", "优化"]     ✅ 合理
方案2: ["MySQL", "数据", "库性", "能优", "化"] ❌ 不合理  
方案3: ["MySQL", "数据", "库", "性能", "优化"] ❌ 不够精确
```

**🔸 MySQL内置分词的局限性**
```sql
-- MySQL默认使用简单的分词规则
-- 对中文支持有限，主要问题：

-- 1. 无法正确识别中文词汇边界
SELECT * FROM articles 
WHERE MATCH(content) AGAINST('数据库优化');
-- 可能无法匹配到"数据库性能优化"

-- 2. 单字符分词效果差
-- 默认会将"数据库"拆分为"数"、"据"、"库"
-- 搜索意义不大
```

### 6.2 中文分词解决方案


**🔸 方案1：使用ngram解析器**
```sql
-- 配置ngram分词（MySQL 5.7.6+）
-- 在my.cnf中配置
[mysqld]
ngram_token_size = 2  # 设置为2，适合中文双字词

-- 创建使用ngram的全文索引
CREATE TABLE articles_cn (
    id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    FULLTEXT(title, content) WITH PARSER ngram
) ENGINE=InnoDB;
```

**🔸 ngram分词示例**
```sql
-- 插入中文测试数据
INSERT INTO articles_cn VALUES 
(1, 'MySQL数据库优化', 'MySQL数据库性能优化是一个重要话题'),
(2, '数据库设计原则', '好的数据库设计能提高查询性能');

-- ngram分词效果（token_size=2）
-- "MySQL数据库优化" 被分为：
-- "My", "yS", "SQ", "QL", "L数", "数据", "据库", "库优", "优化"

-- 搜索测试
SELECT * FROM articles_cn 
WHERE MATCH(title, content) AGAINST('数据库优化' IN BOOLEAN MODE);
```

**🔸 方案2：应用层分词**
```sql
-- 在应用层使用专业分词工具（如jieba、HanLP）处理
-- 将分词结果存储到额外字段

CREATE TABLE articles_segmented (
    id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    content_segmented TEXT,  -- 存储分词后的结果
    FULLTEXT(content_segmented)
);

-- 应用层处理示例（伪代码）
-- original = "MySQL数据库性能优化技巧"
-- segmented = "MySQL 数据库 性能 优化 技巧"
INSERT INTO articles_segmented VALUES 
(1, 'MySQL优化', 'MySQL数据库性能优化技巧', 'MySQL 数据库 性能 优化 技巧');
```

### 6.3 中文搜索优化


**🔸 混合搜索策略**
```sql
-- 结合多种搜索方式提高召回率
SELECT DISTINCT
    id, title, content,
    MATCH(content) AGAINST('数据库 优化') as score1,
    MATCH(content) AGAINST('数据库优化' IN BOOLEAN MODE) as score2
FROM articles 
WHERE 
    MATCH(content) AGAINST('数据库 优化') 
    OR MATCH(content) AGAINST('数据库优化' IN BOOLEAN MODE)
    OR content LIKE '%数据库%' AND content LIKE '%优化%'
ORDER BY GREATEST(score1, score2) DESC;
```

---

## 7. 📈 性能优化与监控


### 7.1 全文索引性能监控


**🔸 监控关键指标**
```sql
-- 1. 查看全文索引的使用情况
SHOW STATUS LIKE 'Handler_read_rnd_next';
SHOW STATUS LIKE 'Innodb_ft%';

-- 2. 分析慢查询日志中的全文搜索
-- 在my.cnf中启用慢查询日志
[mysqld]
slow_query_log = 1
long_query_time = 0.5
log_queries_not_using_indexes = 1

-- 3. 查看索引大小
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * $$innodb_page_size / 1024 / 1024, 2) AS index_size_mb
FROM INFORMATION_SCHEMA.INNODB_METRICS 
WHERE SUBSYSTEM = 'index';
```

**🔸 性能测试示例**
```sql
-- 对比LIKE vs 全文索引的性能
-- 测试1：使用LIKE（性能差）
SELECT SQL_NO_CACHE COUNT(*) 
FROM articles 
WHERE content LIKE '%MySQL%' AND content LIKE '%优化%';

-- 测试2：使用全文索引（性能好）
SELECT SQL_NO_CACHE COUNT(*) 
FROM articles 
WHERE MATCH(content) AGAINST('MySQL 优化');

-- 查看执行计划
EXPLAIN SELECT * FROM articles 
WHERE MATCH(content) AGAINST('MySQL 优化');
```

### 7.2 优化策略


**🔸 索引优化技巧**
```sql
-- 1. 合理选择索引字段
-- ✅ 好的组合：经常一起搜索的字段
CREATE FULLTEXT INDEX idx_title_content ON articles(title, content);

-- ❌ 不好的组合：不相关的字段
-- CREATE FULLTEXT INDEX idx_mixed ON articles(title, author, tags);

-- 2. 控制索引字段长度
ALTER TABLE articles MODIFY content TEXT;  -- 而不是LONGTEXT
-- 原因：过长的字段会影响索引性能

-- 3. 定期维护索引
OPTIMIZE TABLE articles;  -- 整理索引碎片
```

**🔸 查询优化技巧**
```sql
-- 1. 使用相关性阈值过滤
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 优化')
  AND MATCH(title, content) AGAINST('MySQL 优化') > 0.5  -- 设置最低相关性
ORDER BY MATCH(title, content) AGAINST('MySQL 优化') DESC
LIMIT 20;

-- 2. 结合其他条件缩小搜索范围
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('MySQL 优化')
  AND created_at > DATE_SUB(NOW(), INTERVAL 1 YEAR)  -- 时间过滤
  AND status = 'published'                           -- 状态过滤
ORDER BY MATCH(title, content) AGAINST('MySQL 优化') DESC;

-- 3. 使用覆盖索引
-- 如果只需要少量字段，考虑创建覆盖索引
CREATE INDEX idx_cover ON articles(id, title, created_at);
```

### 7.3 常见问题与解决


**🔸 全文索引常见问题**

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| **搜索结果为空** | 词长小于最小词长 | 调整`ft_min_word_len`配置 |
| **搜索很慢** | 索引过大或查询条件不当 | 优化查询条件，添加其他过滤条件 |
| **相关性不准确** | 数据质量差或分词问题 | 清理数据，优化分词策略 |
| **中文搜索效果差** | 默认分词不支持中文 | 使用ngram或外部分词工具 |
| **索引占用空间大** | 索引字段过多或过长 | 精简索引字段，控制字段长度 |

**🔸 问题排查步骤**
```sql
-- 1. 检查索引是否存在且有效
SHOW INDEX FROM articles WHERE Key_name LIKE '%FULLTEXT%';

-- 2. 检查分词效果
SET @query = 'MySQL 优化';
SELECT @query as original_query,
       MATCH(content) AGAINST(@query) as natural_score,
       MATCH(content) AGAINST(@query IN BOOLEAN MODE) as boolean_score
FROM articles LIMIT 5;

-- 3. 检查数据分布
SELECT 
    CHAR_LENGTH(content) as content_length,
    MATCH(content) AGAINST('MySQL') as mysql_score
FROM articles 
WHERE MATCH(content) AGAINST('MySQL')
ORDER BY mysql_score DESC LIMIT 10;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 全文索引本质：为文本内容建立的倒排索引，支持快速文本搜索
🔸 工作原理：分词→建立倒排索引→查询时匹配→按相关性排序
🔸 三种搜索模式：自然语言、布尔模式、查询扩展
🔸 相关性排序：基于TF-IDF算法，考虑词频和稀有性
🔸 中文分词：需要特殊处理，可使用ngram或外部分词工具
```

### 8.2 实际应用要点


**🔹 何时使用全文索引**
```
✅ 适用场景：
• 文本内容丰富（文章、评论、描述等）
• 需要模糊搜索和相关性排序
• 搜索频率高，性能要求高
• 需要复杂的搜索语法

❌ 不适用场景：
• 精确匹配需求（用普通索引）
• 数值或日期范围查询
• 实时性要求极高的场景
• 文本内容过短或过于规范化
```

**🔹 性能优化原则**
```
索引设计：
• 只对需要搜索的字段建立全文索引
• 控制索引字段的长度和数量
• 定期维护和优化索引

查询优化：
• 合理使用布尔模式提高精确度
• 结合其他条件缩小搜索范围
• 设置相关性阈值过滤低质量结果
• 合理设置LIMIT限制结果数量
```

**🔹 中文处理策略**
```
分词方案：
• 简单场景：使用ngram解析器
• 复杂场景：应用层分词+专业工具
• 混合策略：多种方法结合提高召回率

配置建议：
• 最小词长设为2（适合中文）
• 自定义停用词表
• 根据业务调整ngram_token_size
```

### 8.3 常用SQL模板


**🔸 基础搜索模板**
```sql
-- 1. 简单全文搜索
SELECT *, MATCH(字段名) AGAINST('关键词') as score
FROM 表名 
WHERE MATCH(字段名) AGAINST('关键词')
ORDER BY score DESC LIMIT 10;

-- 2. 布尔模式搜索
SELECT * FROM 表名 
WHERE MATCH(字段名) AGAINST('+必须词 -排除词 "精确短语"' IN BOOLEAN MODE);

-- 3. 带权重的多字段搜索
SELECT *,
    (MATCH(title) AGAINST('关键词') * 2 + 
     MATCH(content) AGAINST('关键词') * 1) as weighted_score
FROM 表名 
WHERE MATCH(title, content) AGAINST('关键词')
ORDER BY weighted_score DESC;
```

**🔸 索引管理模板**
```sql
-- 创建全文索引
CREATE FULLTEXT INDEX 索引名 ON 表名(字段1, 字段2);

-- 查看索引状态
SHOW INDEX FROM 表名 WHERE Index_type = 'FULLTEXT';

-- 重建索引
ALTER TABLE 表名 DROP INDEX 索引名;
CREATE FULLTEXT INDEX 索引名 ON 表名(字段名);
```

**核心记忆口诀**：
- 全文搜索建倒排，分词索引效率快
- 自然布尔两模式，相关排序有门道  
- 中文分词需特殊，ngram应用配置好
- 性能监控要及时，索引维护不能少