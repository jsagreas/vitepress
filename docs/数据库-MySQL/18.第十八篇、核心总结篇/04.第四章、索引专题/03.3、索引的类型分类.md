---
title: 3、索引的类型分类
---
## 📚 目录

1. [MySQL索引分类概览](#1-MySQL索引分类概览)
2. [按数据结构分类详解](#2-按数据结构分类详解)
3. [按列数量分类详解](#3-按列数量分类详解)
4. [按功能分类详解](#4-按功能分类详解)
5. [索引选择策略](#5-索引选择策略)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 MySQL索引分类概览


### 1.1 什么是MySQL索引分类


**简单理解**：就像图书馆里书的分类方法一样，MySQL的索引也有不同的分类标准。

```
图书馆分类类比：
按内容分：文学类、科技类、历史类...
按尺寸分：大开本、小开本...
按语言分：中文书、英文书...

MySQL索引分类：
按数据结构分：B+树、哈希、全文...
按列数量分：单列、复合...
按功能分：普通、唯一、主键...
```

### 1.2 为什么要分类理解索引


**实际意义**：
- **选择合适的索引类型** - 不同场景用不同的索引
- **避免索引浪费** - 不是所有地方都需要索引
- **提升查询性能** - 用对了索引事半功倍

### 1.3 索引分类全景图


```
MySQL索引分类体系
├─ 📊 按数据结构分类
│  ├─ B+树索引 (最常用)
│  ├─ 哈希索引 (内存引擎)
│  ├─ 全文索引 (文本搜索)
│  └─ 空间索引 (地理位置)
├─ 🔢 按列数量分类  
│  ├─ 单列索引 (一个字段)
│  └─ 复合索引 (多个字段)
└─ ⚙️ 按功能分类
   ├─ 普通索引 (基础加速)
   ├─ 唯一索引 (保证唯一)
   ├─ 主键索引 (主键专用)
   ├─ 前缀索引 (节省空间)
   ├─ 部分索引 (条件索引)
   └─ 函数索引 (计算索引)
```

---

## 2. 📊 按数据结构分类详解


### 2.1 B+树索引特性


**🌳 什么是B+树索引**

B+树索引就像一个**多层目录系统**，数据按照树状结构组织，查找时从根节点一层层往下找。

```
B+树结构示意（3层）：
           [根节点]
          /    |    \
      [中间层] [中间层] [中间层]  
     /  |  \   /  |  \   /  |  \
   [叶] [叶] [叶] [叶] [叶] [叶] [叶] [叶] [叶]
    ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
  数据 数据 数据 数据 数据 数据 数据 数据 数据

特点：所有数据都在叶子节点，叶子节点之间有链接
```

**🔍 B+树索引的工作原理**

```sql
-- 假设有个用户表，给年龄字段建立B+树索引
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    INDEX idx_age (age)  -- 这就是B+树索引
);

-- 查询年龄为25的用户
SELECT * FROM users WHERE age = 25;
```

**查找过程**：
1. **从根节点开始** - 根据age=25找到对应的中间节点
2. **逐层向下** - 在中间节点中继续查找
3. **到达叶子节点** - 找到age=25的所有记录
4. **获取数据** - 通过主键回表获取完整数据

**✅ B+树索引优势**
- **查询稳定** - 所有查询都是相同的层数，性能稳定
- **范围查询好** - 叶子节点有链接，范围查询很快
- **存储效率高** - 非叶子节点只存键值，不存数据

**❌ B+树索引劣势**
- **等值查询稍慢** - 必须从根走到叶，不能直接定位

### 2.2 哈希索引特性


**🔑 什么是哈希索引**

哈希索引就像一个**超快的字典**，通过哈希函数直接计算出数据位置。

```
哈希索引工作原理：
输入: age = 25
哈希函数: hash(25) = 1001
直接跳转: 位置1001 → 找到数据

就像：
你说"25岁用户"
我直接告诉你"在第1001个位置"
```

**💡 哈希索引示例**

```sql
-- 在MySQL的MEMORY引擎中可以明确指定哈希索引
CREATE TABLE temp_users (
    id INT,
    age INT,
    INDEX USING HASH (age)  -- 明确指定哈希索引
) ENGINE=MEMORY;
```

**✅ 哈希索引优势**
- **等值查询极快** - O(1)时间复杂度，直接定位
- **内存占用小** - 只存储哈希值和指针

**❌ 哈希索引劣势**
- **不支持范围查询** - 无法查询age > 25这种条件
- **不支持排序** - 哈希值是乱序的
- **哈希冲突** - 不同值可能产生相同哈希值

> 💡 **重要提示**
> 
> InnoDB引擎会自动对热点数据创建自适应哈希索引，你不需要手动创建

### 2.3 全文索引功能


**📝 什么是全文索引**

全文索引专门用于**文本内容搜索**，就像搜索引擎一样，可以在大段文字中快速找到包含特定词汇的记录。

**🔍 全文索引工作原理**

```
全文索引的分词过程：
原文: "MySQL是优秀的数据库系统"
分词: ["MySQL", "是", "优秀", "的", "数据库", "系统"]
索引: MySQL→记录1, 优秀→记录1, 数据库→记录1...

搜索时: 输入"数据库" → 直接找到记录1
```

**💻 全文索引示例**

```sql
-- 创建带全文索引的文章表
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT KEY ft_content (content)  -- 全文索引
);

-- 插入测试数据
INSERT INTO articles VALUES 
(1, '数据库优化', 'MySQL是非常优秀的关系型数据库'),
(2, '编程语言', 'Python和Java都是流行的编程语言');

-- 使用全文搜索
SELECT * FROM articles 
WHERE MATCH(content) AGAINST('数据库' IN NATURAL LANGUAGE MODE);
```

**✅ 全文索引优势**
- **文本搜索专用** - 专门为文本搜索优化
- **支持自然语言** - 可以理解词汇的相关性
- **搜索结果排序** - 按相关度排序结果

**❌ 全文索引局限**
- **中文支持一般** - 对中文分词支持有限
- **存储开销大** - 需要额外的存储空间
- **更新代价高** - 文本变化时索引更新复杂

### 2.4 空间索引应用


**🗺️ 什么是空间索引**

空间索引专门处理**地理位置数据**，比如坐标点、线条、多边形等地理信息。

**📍 空间索引示例**

```sql
-- 创建地点表，包含地理位置信息
CREATE TABLE locations (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    coordinates POINT NOT NULL,
    SPATIAL INDEX sp_coordinates (coordinates)  -- 空间索引
);

-- 插入地理位置数据（北京天安门的经纬度）
INSERT INTO locations VALUES 
(1, '天安门', POINT(116.397128, 39.916527));

-- 查找距离某点1公里内的所有地点
SELECT name FROM locations 
WHERE ST_Distance_Sphere(coordinates, POINT(116.397128, 39.916527)) < 1000;
```

**✅ 空间索引优势**
- **地理查询专用** - 专门优化地理位置查询
- **支持复杂几何** - 点、线、面等复杂几何对象

**❌ 空间索引局限**
- **使用场景专一** - 只适合地理信息系统
- **学习成本高** - 需要掌握空间函数

---

## 3. 🔢 按列数量分类详解


### 3.1 单列索引特点


**📌 什么是单列索引**

单列索引就是**只对一个字段建立的索引**，就像给单个抽屉贴标签一样简单直接。

**💻 单列索引示例**

```sql
-- 用户表
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    email VARCHAR(100),
    created_at DATETIME
);

-- 分别为不同字段创建单列索引
CREATE INDEX idx_name ON users(name);        -- 姓名索引
CREATE INDEX idx_age ON users(age);          -- 年龄索引  
CREATE INDEX idx_email ON users(email);      -- 邮箱索引
CREATE INDEX idx_created ON users(created_at); -- 创建时间索引
```

**🎯 单列索引的使用场景**

| 查询类型 | 示例SQL | 使用索引 |
|---------|---------|----------|
| **等值查询** | `WHERE age = 25` | ✅ idx_age |
| **范围查询** | `WHERE age BETWEEN 20 AND 30` | ✅ idx_age |
| **模糊查询** | `WHERE name LIKE '张%'` | ✅ idx_name |
| **排序查询** | `ORDER BY created_at` | ✅ idx_created |

**✅ 单列索引优势**
- **简单易用** - 容易理解和维护
- **针对性强** - 专门优化单个字段查询
- **存储开销小** - 只索引一个字段

**❌ 单列索引局限**
- **多条件查询效率低** - 多个WHERE条件时效果有限
- **索引数量多** - 每个字段都要单独建索引

### 3.2 复合索引组合


**🔗 什么是复合索引**

复合索引就是**对多个字段组合建立的索引**，就像给多个抽屉建立一个统一的分类系统。

**💡 复合索引的关键概念**

```
复合索引的层次结构：
索引 (name, age, city)

第一层: 按name排序
  ├─ 张三
  │  ├─ 25岁
  │  │  ├─ 北京 → 记录1
  │  │  └─ 上海 → 记录2  
  │  └─ 30岁
  │     └─ 广州 → 记录3
  └─ 李四
     └─ 28岁
        └─ 深圳 → 记录4

最左前缀原则：必须从最左边的字段开始使用
```

**💻 复合索引实战示例**

```sql
-- 创建复合索引
CREATE INDEX idx_name_age_city ON users(name, age, city);

-- ✅ 能使用索引的查询
SELECT * FROM users WHERE name = '张三';                    -- 使用 name
SELECT * FROM users WHERE name = '张三' AND age = 25;       -- 使用 name, age  
SELECT * FROM users WHERE name = '张三' AND age = 25 AND city = '北京'; -- 使用全部

-- ❌ 不能使用索引的查询
SELECT * FROM users WHERE age = 25;                        -- 跳过了name
SELECT * FROM users WHERE city = '北京';                   -- 跳过了name和age
SELECT * FROM users WHERE age = 25 AND city = '北京';      -- 跳过了name
```

**📋 最左前缀原则详解**

> 💡 **最左前缀原则**
> 
> 复合索引(A, B, C)相当于创建了：
> - 索引(A)
> - 索引(A, B)  
> - 索引(A, B, C)
>
> 但**没有**创建索引(B)、索引(C)、索引(B, C)

**🎯 复合索引字段顺序策略**

```sql
-- 根据查询频率和选择性排序
-- 1. 等值条件 > 范围条件
-- 2. 选择性高 > 选择性低
-- 3. 查询频率高 > 查询频率低

-- 好的顺序示例
CREATE INDEX idx_status_type_created ON orders(
    status,      -- 等值查询，选择性高
    type,        -- 等值查询，选择性中等  
    created_at   -- 范围查询，放最后
);

-- 对应的查询
SELECT * FROM orders 
WHERE status = 'completed' 
  AND type = 'online'
  AND created_at >= '2024-01-01';
```

**✅ 复合索引优势**
- **减少索引数量** - 一个复合索引顶多个单列索引
- **多条件查询优化** - 专门为多个条件组合优化
- **避免回表** - 索引包含查询所需的所有字段

**❌ 复合索引注意事项**
- **字段顺序关键** - 顺序错了索引就废了
- **维护成本高** - 字段更新时索引维护复杂
- **存储空间大** - 多个字段占用更多空间

---

## 4. ⚙️ 按功能分类详解


### 4.1 普通索引作用


**📋 什么是普通索引**

普通索引就是**最基础的索引类型**，没有任何约束条件，纯粹为了加快查询速度而存在。

```
普通索引就像：
图书馆的普通分类标签 - 帮你快速找书，但不限制书的内容
```

**💻 普通索引示例**

```sql
-- 创建普通索引的几种方式
-- 方式1：建表时创建
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    category VARCHAR(50),
    INDEX idx_category (category),  -- 普通索引
    INDEX idx_price (price)         -- 普通索引
);

-- 方式2：单独创建
CREATE INDEX idx_product_name ON products(name);

-- 方式3：添加索引
ALTER TABLE products ADD INDEX idx_category_price (category, price);
```

**✅ 普通索引特点**
- **无约束条件** - 字段值可以重复，可以为NULL
- **纯粹加速查询** - 只为提升查询性能
- **使用最广泛** - 大部分索引都是普通索引

### 4.2 唯一索引约束


**🔑 什么是唯一索引**

唯一索引在提供查询加速的同时，还**保证字段值的唯一性**，就像身份证号码一样，每个人都不能重复。

```
唯一索引的双重作用：
1. 查询加速 ← 和普通索引一样
2. 唯一约束 ← 额外的约束功能
```

**💻 唯一索引示例**

```sql
-- 用户表，邮箱必须唯一
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    UNIQUE KEY uk_email (email),    -- 唯一索引
    UNIQUE KEY uk_phone (phone)     -- 唯一索引
);

-- 插入数据测试
INSERT INTO users VALUES (1, 'user1', 'user1@example.com', '13800138000');

-- ❌ 这条插入会失败，因为邮箱重复
INSERT INTO users VALUES (2, 'user2', 'user1@example.com', '13800138001');
-- Error: Duplicate entry 'user1@example.com' for key 'uk_email'
```

**🔍 唯一索引 vs 普通索引性能对比**

| 对比项 | 普通索引 | 唯一索引 |
|-------|---------|----------|
| **查询性能** | 快 | 更快（找到第一个就停止） |
| **插入性能** | 快 | 稍慢（需要检查重复） |
| **更新性能** | 快 | 稍慢（需要检查重复） |
| **存储空间** | 标准 | 相同 |

**✅ 唯一索引优势**
- **数据完整性** - 保证数据不重复
- **查询更快** - 找到匹配值就停止搜索
- **替代主键** - 可以作为逻辑主键使用

**❌ 唯一索引注意事项**
- **插入/更新稍慢** - 需要检查唯一性
- **NULL值处理** - 多个NULL值是允许的

### 4.3 主键索引特殊性


**👑 什么是主键索引**

主键索引是**最特殊的唯一索引**，每个表只能有一个，是表中记录的唯一标识。

```
主键索引的特殊地位：
┌─────────────────┐
│    主键索引      │ ← 表的"身份证"，唯一且非空
├─────────────────┤
│   其他索引       │ ← 都要引用主键索引
└─────────────────┘

在InnoDB中：
- 主键索引 = 聚簇索引（数据和索引存在一起）
- 其他索引 = 二级索引（存储主键值）
```

**💻 主键索引示例**

```sql
-- 创建主键索引
CREATE TABLE orders (
    order_id INT PRIMARY KEY,           -- 主键索引
    user_id INT,
    product_id INT,
    order_date DATETIME,
    INDEX idx_user_id (user_id),        -- 二级索引
    INDEX idx_product_id (product_id)   -- 二级索引
);

-- 主键索引的查询最快
SELECT * FROM orders WHERE order_id = 12345;  -- 直接定位，最快

-- 二级索引需要回表
SELECT * FROM orders WHERE user_id = 100;     -- 先找到主键，再回表
```

**🔍 主键索引 vs 二级索引的查询过程**

```
主键索引查询过程：
1. 通过主键索引直接找到数据行 ✅

二级索引查询过程：  
1. 通过二级索引找到主键值
2. 通过主键值再查找主键索引  
3. 最终找到数据行
```

**✅ 主键索引特点**
- **聚簇存储** - 数据按主键顺序物理存储
- **查询最快** - 不需要回表操作
- **自动创建** - 创建主键时自动创建
- **唯一非空** - 值必须唯一且不能为NULL

### 4.4 前缀索引应用


**✂️ 什么是前缀索引**

前缀索引就是**只对字段的前几个字符建立索引**，就像用姓氏来快速分类人群一样。

```
前缀索引的概念：
完整邮箱: "user123456@verylongdomainname.com" (35字符)
前缀索引: "user123456@ver" (15字符)

优势：节省空间，保持一定的区分度
风险：区分度降低，可能影响查询效率
```

**💻 前缀索引实战**

```sql
-- 分析字段的前缀选择性
-- 查看email字段前缀的区分度
SELECT 
    COUNT(DISTINCT LEFT(email, 5)) / COUNT(*) AS prefix_5,
    COUNT(DISTINCT LEFT(email, 10)) / COUNT(*) AS prefix_10,
    COUNT(DISTINCT LEFT(email, 15)) / COUNT(*) AS prefix_15,
    COUNT(DISTINCT email) / COUNT(*) AS full_column
FROM users;

-- 结果分析：选择区分度较高的前缀长度
-- 假设prefix_15的区分度已经接近full_column

-- 创建前缀索引
CREATE INDEX idx_email_prefix ON users(email(15));

-- 前缀索引的查询
SELECT * FROM users WHERE email = 'user@example.com';  -- 可以使用前缀索引
SELECT * FROM users WHERE email LIKE 'user@exam%';     -- 可以使用前缀索引
```

**📊 前缀长度选择策略**

| 前缀长度 | 存储空间 | 区分度 | 查询效率 | 建议 |
|---------|---------|-------|----------|------|
| **太短（5字符）** | 很小 | 很低 | 差 | ❌ 不推荐 |
| **适中（10-15字符）** | 中等 | 较高 | 好 | ✅ 推荐 |
| **太长（>20字符）** | 较大 | 很高 | 很好 | ⚠️ 看情况 |
| **完整字段** | 最大 | 最高 | 最好 | 💰 成本高 |

**✅ 前缀索引优势**
- **节省存储空间** - 大幅减少索引占用的磁盘空间
- **提升插入性能** - 索引更新更快
- **适合长字符串** - URL、邮箱、文章标题等

**❌ 前缀索引局限**
- **不支持ORDER BY** - 无法用于排序
- **覆盖索引受限** - 无法覆盖完整字段
- **选择性计算复杂** - 需要分析最优前缀长度

### 4.5 部分索引概念


**🎯 什么是部分索引**

部分索引就是**只对满足特定条件的记录建立索引**，就像只给活跃用户建立快速通道一样。

> ⚠️ **MySQL注意**
> 
> MySQL本身不直接支持条件部分索引，但可以通过函数索引和虚拟列实现类似效果

**💡 部分索引的设计思路**

```sql
-- 模拟部分索引：只为活跃用户建立索引
-- 方式1：使用虚拟列 + 索引
ALTER TABLE users 
ADD COLUMN active_status CHAR(1) GENERATED ALWAYS AS (
    CASE WHEN status = 'active' THEN 'Y' ELSE NULL END
) STORED;

CREATE INDEX idx_active_users ON users(active_status, user_id);

-- 方式2：使用函数索引 (MySQL 8.0+)
CREATE INDEX idx_active_users_func ON users((
    CASE WHEN status = 'active' THEN user_id ELSE NULL END
));
```

**📊 部分索引 vs 完整索引对比**

```
用户表数据分布：
总用户数: 1,000,000
活跃用户: 100,000 (10%)
非活跃用户: 900,000 (90%)

完整索引大小: 50MB
部分索引大小: 5MB (节省90%空间)
```

**✅ 部分索引优势**
- **空间效率极高** - 只索引需要的数据
- **维护成本低** - 索引更新量减少
- **查询针对性强** - 专门为特定场景优化

### 4.6 函数索引使用


**🔧 什么是函数索引**

函数索引就是**对字段经过函数计算后的结果建立索引**，就像给计算结果建立快速查找通道。

**💻 函数索引实战示例**

```sql
-- MySQL 8.0+ 支持函数索引
-- 示例1：对日期的年份建立索引
CREATE INDEX idx_year ON orders((YEAR(order_date)));

-- 对应的查询可以使用这个索引
SELECT * FROM orders WHERE YEAR(order_date) = 2024;

-- 示例2：对字符串长度建立索引  
CREATE INDEX idx_name_length ON users((CHAR_LENGTH(name)));

-- 查询名字长度的记录
SELECT * FROM users WHERE CHAR_LENGTH(name) > 10;

-- 示例3：对JSON字段的某个属性建立索引
CREATE INDEX idx_json_age ON users((JSON_EXTRACT(profile, '$.age')));

-- 查询JSON中的age字段
SELECT * FROM users WHERE JSON_EXTRACT(profile, '$.age') > 25;
```

**🎯 常见函数索引应用场景**

| 函数类型 | 示例 | 适用场景 | 查询示例 |
|---------|------|---------|----------|
| **日期函数** | `YEAR(date)` | 按年份查询 | `WHERE YEAR(created_at) = 2024` |
| **字符串函数** | `UPPER(name)` | 大小写无关查询 | `WHERE UPPER(name) = 'JOHN'` |
| **数学函数** | `ABS(amount)` | 绝对值查询 | `WHERE ABS(balance) > 1000` |
| **JSON函数** | `JSON_EXTRACT(data, '$.key')` | JSON属性查询 | `WHERE JSON_EXTRACT(profile, '$.city') = 'Beijing'` |

**✅ 函数索引优势**
- **计算结果查询优化** - 避免全表扫描计算
- **复杂条件支持** - 支持各种函数计算
- **JSON查询友好** - 特别适合JSON数据查询

**❌ 函数索引注意事项**
- **MySQL版本要求** - 需要MySQL 8.0+
- **维护成本高** - 原字段更新时需要重新计算
- **函数必须确定性** - 相同输入必须产生相同输出

---

## 5. 🎯 索引选择策略


### 5.1 选择索引类型的决策树


```
开始选择索引类型
        ↓
    需要唯一约束？
    ├─ 是 → 是主键？
    │      ├─ 是 → 主键索引
    │      └─ 否 → 唯一索引
    └─ 否 → 查询类型？
           ├─ 文本搜索 → 全文索引
           ├─ 地理位置 → 空间索引  
           ├─ 等值查询频繁 → 考虑哈希索引
           └─ 一般查询 → B+树索引
                      ↓
                 多个字段组合查询？
                 ├─ 是 → 复合索引
                 └─ 否 → 单列索引
                        ↓
                   字段很长？
                   ├─ 是 → 前缀索引
                   └─ 否 → 普通索引
```

### 5.2 实际场景选择指南


**🏪 电商系统索引设计**

```sql
-- 商品表索引设计
CREATE TABLE products (
    id INT PRIMARY KEY,                    -- 主键索引
    name VARCHAR(200),                     
    category_id INT,
    price DECIMAL(10,2),
    status ENUM('active','inactive'),
    created_at DATETIME,
    description TEXT
);

-- 索引设计策略
CREATE UNIQUE INDEX uk_name ON products(name);                    -- 商品名唯一
CREATE INDEX idx_category_status ON products(category_id, status); -- 分类+状态查询
CREATE INDEX idx_price_range ON products(price);                  -- 价格范围查询
CREATE INDEX idx_created_time ON products(created_at);            -- 时间排序
CREATE FULLTEXT INDEX ft_description ON products(description);    -- 商品描述搜索
```

**👥 用户系统索引设计**

```sql
-- 用户表索引设计
CREATE TABLE users (
    id INT PRIMARY KEY,                    -- 主键索引
    username VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    status ENUM('active','inactive','banned'),
    created_at DATETIME,
    last_login_at DATETIME
);

-- 索引策略
CREATE UNIQUE INDEX uk_username ON users(username);               -- 用户名唯一
CREATE UNIQUE INDEX uk_email ON users(email(20));                 -- 邮箱前缀索引
CREATE INDEX idx_status_login ON users(status, last_login_at);    -- 活跃用户查询
CREATE INDEX idx_created_time ON users(created_at);               -- 注册时间
```

### 5.3 索引维护建议


**📊 索引监控指标**

```sql
-- 查看索引使用情况
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,        -- 基数（不重复值的数量）
    INDEX_TYPE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, SEQ_IN_INDEX;

-- 查看未使用的索引
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL
  AND count_star = 0
  AND object_schema = 'your_database';
```

**🧹 索引清理策略**

> 💡 **索引维护原则**
> 
> - **定期检查** - 每月检查索引使用情况
> - **删除无用索引** - 清理从不使用的索引
> - **合并重复索引** - 避免功能重复的索引
> - **优化复合索引** - 调整字段顺序提升效率

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 按数据结构：B+树(通用)、哈希(等值)、全文(搜索)、空间(地理)
🔸 按列数量：单列索引(简单)、复合索引(组合，注意最左前缀)
🔸 按功能：普通(加速)、唯一(约束)、主键(特殊)、前缀(节省)
🔸 关键理解：不同类型索引适用不同场景，选择合适的类型很重要
🔸 实战要点：根据查询模式设计索引，定期监控和优化
```

### 6.2 关键决策要点


**🔹 数据结构选择**
```
B+树索引：99%的场景，首选方案
哈希索引：内存表的等值查询，特殊场景
全文索引：文本搜索需求，配合MATCH AGAINST
空间索引：地理位置应用，GIS系统
```

**🔹 列数量选择**
```
单列索引：查询条件简单，字段相对独立
复合索引：多条件组合查询，注意字段顺序
最左前缀：复合索引的核心原则，必须理解
```

**🔹 功能类型选择**
```
主键索引：每表必须，性能最好
唯一索引：需要保证数据唯一性
普通索引：大多数场景的选择
前缀索引：长字符串字段的优化方案
```

### 6.3 实际应用指导


**💡 索引设计最佳实践**
- **先分析查询模式** - 了解业务的查询需求
- **选择合适的索引类型** - 根据数据特点选择
- **控制索引数量** - 太多索引影响写入性能
- **定期维护优化** - 监控使用情况，及时调整

**⚠️ 常见误区避免**
- **不是越多越好** - 索引有维护成本
- **复合索引顺序很重要** - 最左前缀原则
- **前缀索引有局限** - 不支持排序和完整覆盖
- **函数索引需谨慎** - 维护成本较高

**核心记忆**：
- 索引类型要选对，查询性能差别大
- B+树是主流，哈希等值快，全文搜文本，空间查地理
- 单列简单直接，复合组合查询，最左前缀是关键
- 主键最特殊，唯一带约束，普通最常用，前缀省空间