---
title: 40、部分索引设计
---
## 📚 目录

1. [部分索引基本概念](#1-部分索引基本概念)
2. [WHERE条件索引设计](#2-WHERE条件索引设计)
3. [筛选条件策略](#3-筛选条件策略)
4. [空间优化与性能评估](#4-空间优化与性能评估)
5. [创建与维护实践](#5-创建与维护实践)
6. [适用场景分析](#6-适用场景分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 部分索引基本概念


### 1.1 什么是部分索引


**📖 通俗理解**
```
想象一下图书馆的索引卡片：
- 普通索引：为所有书籍都做索引卡片
- 部分索引：只为"重要的书"或"常借的书"做索引卡片

这样做的好处：
✅ 节省索引卡片存储空间
✅ 查找重要书籍更快
✅ 维护索引卡片成本更低
```

**🔸 核心定义**
```
部分索引(Partial Index)：只对表中满足特定条件的行创建索引
原理：通过WHERE条件过滤，只索引需要的数据
目标：在保证查询性能的同时，最大化节省存储空间和维护成本
```

### 1.2 部分索引 vs 普通索引


**📊 对比分析**
```
数据场景：用户表(1000万条记录)
- 活跃用户：100万(10%)
- 非活跃用户：900万(90%)

普通索引：
CREATE INDEX idx_user_email ON users(email);
索引大小：约400MB(所有用户)

部分索引：
CREATE INDEX idx_active_user_email ON users(email) 
WHERE status = 'active';
索引大小：约40MB(仅活跃用户)

结果对比：
🔸 空间节省：90%
🔸 维护成本：降低90%  
🔸 查询速度：活跃用户查询更快
```

### 1.3 部分索引的工作原理


**⚙️ 内部机制**
```
创建过程：
1. 扫描表中所有行
2. 应用WHERE条件进行过滤
3. 只对满足条件的行创建索引项
4. 索引中只包含过滤后的数据

查询匹配：
1. 查询优化器分析SQL语句
2. 检查WHERE条件是否与索引条件兼容
3. 兼容则使用部分索引，否则忽略
```

**💡 关键理解**
部分索引就像是"有条件的电话簿"，只收录满足特定条件的联系人，这样电话簿更薄，查找更快！

---

## 2. 🔍 WHERE条件索引设计


### 2.1 条件设计原则


**🎯 核心设计思路**
```
高选择性原则：
- 选择能过滤掉大量数据的条件
- 例：status = 'active' (过滤90%数据)
- 避免：age > 0 (几乎不过滤数据)

稳定性原则：
- 条件值应该相对稳定
- 例：is_deleted = 0 (删除状态很少变化)
- 避免：last_login_time > CURDATE() (每天都变)

查询匹配原则：
- 条件必须与实际查询兼容
- 索引条件要包含在查询条件中
```

### 2.2 条件类型与应用


**📋 常见条件类型**

#### 🔸 状态过滤条件

```sql
-- 1. 用户状态过滤
CREATE INDEX idx_active_users_email 
ON users(email) 
WHERE status = 'active';

-- 适用查询：
SELECT * FROM users 
WHERE email = 'user@example.com' 
AND status = 'active';  -- ✅ 可以使用索引

-- 不适用查询：
SELECT * FROM users 
WHERE email = 'user@example.com';  -- ❌ 无法使用索引
```

#### 🔸 软删除过滤条件

```sql
-- 2. 排除已删除记录
CREATE INDEX idx_valid_orders_customer 
ON orders(customer_id, order_date) 
WHERE is_deleted = 0;

-- 适用场景：
-- - 99%查询都是查询未删除数据
-- - 已删除数据占比较大但查询很少
```

#### 🔸 时间范围过滤条件

```sql
-- 3. 近期数据索引
CREATE INDEX idx_recent_logs_user 
ON access_logs(user_id, access_time) 
WHERE access_time >= '2024-01-01';

-- 说明：只索引今年的日志数据
-- 历史数据很少查询，不需要索引
```

### 2.3 复合条件设计


**🔧 多条件组合**
```sql
-- 复合条件示例
CREATE INDEX idx_active_premium_users 
ON users(user_id, created_at) 
WHERE status = 'active' 
  AND plan_type = 'premium' 
  AND is_deleted = 0;

-- 设计说明：
-- - 三个条件联合过滤
-- - 针对活跃的付费用户
-- - 过滤掉删除用户
```

**⚖️ 条件选择权衡**
```
过滤效果 vs 查询匹配：
- 过滤太严格：索引很小但适用查询少
- 过滤太宽松：节省空间有限
- 平衡点：过滤70-90%数据，匹配80%查询

示例分析：
condition1: status = 'active' (过滤80%，匹配95%查询) ✅ 推荐
condition2: status IN ('active','pending') (过滤60%，匹配98%查询) 🤔 可考虑  
condition3: created_at > '2023-01-01' (过滤30%，匹配60%查询) ❌ 不推荐
```

---

## 3. 🎨 筛选条件策略


### 3.1 数据分布分析


**📊 分析数据特征**
```sql
-- 1. 分析状态分布
SELECT status, COUNT(*) as count, 
       ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users), 2) as percentage
FROM users 
GROUP BY status;

-- 结果示例：
-- active: 800,000 (80%)  
-- inactive: 150,000 (15%)
-- deleted: 50,000 (5%)

-- 2. 分析查询模式
-- 检查慢查询日志中的WHERE条件分布
-- 统计不同条件的查询频率
```

**🎯 最优条件选择**
```
选择标准：
1. 数据过滤率：60-90%
2. 查询匹配率：>80%
3. 条件稳定性：变化频率<5%

实际案例：
电商订单表 (1000万记录)
- 已完成订单：600万 (60%)
- 进行中订单：300万 (30%)  
- 已取消订单：100万 (10%)

策略选择：
❌ 索引所有：空间大，维护成本高
✅ 索引进行中：数据量适中，查询频繁
❌ 索引已取消：数据量小，查询少
```

### 3.2 业务场景适配


**🏪 电商平台示例**
```sql
-- 商品索引策略
CREATE INDEX idx_available_products_category 
ON products(category_id, price) 
WHERE status = 'available' 
  AND stock_quantity > 0;

-- 业务逻辑：
-- - 90%查询都是查看可购买商品
-- - 下架和缺货商品查询很少
-- - 节省索引空间约70%
```

**🏥 医疗系统示例**
```sql
-- 病历索引策略  
CREATE INDEX idx_active_patients_history
ON medical_records(patient_id, record_date)
WHERE patient_status = 'active'
  AND is_archived = 0;

-- 业务逻辑：
-- - 在院患者病历查询频繁
-- - 归档病历查询很少
-- - 提升当前病历查询速度
```

### 3.3 动态条件策略


**📅 时间窗口策略**
```sql
-- 滑动时间窗口索引
CREATE INDEX idx_recent_transactions 
ON transactions(user_id, amount, transaction_time)
WHERE transaction_time >= CURRENT_DATE - INTERVAL 90 DAY;

-- 维护策略：
-- 1. 定期重建索引(每月)
-- 2. 或创建分区表
-- 3. 配合数据归档策略
```

**🔄 状态迁移考虑**
```
用户状态迁移：
new → active → inactive → deleted

索引策略：
1. 为active状态建索引(查询最频繁)
2. new状态数据量小，查询少，不建索引
3. inactive可考虑单独索引
4. deleted通常不需要索引

注意事项：
- 状态变化会触发索引维护
- 频繁状态变更的字段不适合做条件
```

---

## 4. 📈 空间优化与性能评估


### 4.1 空间优化效果


**💾 存储空间对比**
```sql
-- 测试表：用户表 1000万记录
-- 字段：user_id, email, status, created_at

-- 普通索引
CREATE INDEX idx_email ON users(email);
-- 索引大小：约500MB

-- 部分索引
CREATE INDEX idx_active_email ON users(email) 
WHERE status = 'active';
-- 索引大小：约50MB (仅10%活跃用户)

-- 空间节省：450MB (90%)
```

**📊 空间计算公式**
```
部分索引大小 = 普通索引大小 × 过滤后数据比例

示例计算：
原表大小：10,000,000 行
过滤条件：status = 'active' (10%数据)
索引字段：email (平均50字节)

普通索引大小 ≈ 10,000,000 × 50字节 = 500MB
部分索引大小 ≈ 1,000,000 × 50字节 = 50MB
节省空间 = 500MB - 50MB = 450MB
```

### 4.2 性能提升评估


**⚡ 查询性能对比**
```sql
-- 测试查询：查找活跃用户
SELECT * FROM users 
WHERE email = 'user@example.com' 
AND status = 'active';

-- 普通索引性能：
-- - 索引扫描：需要扫描更多索引页
-- - 回表查询：可能返回无效数据
-- - 总耗时：15ms

-- 部分索引性能：
-- - 索引扫描：只扫描活跃用户索引
-- - 回表查询：都是有效数据
-- - 总耗时：3ms

-- 性能提升：80%
```

**🔧 维护成本降低**
```
维护操作对比：

INSERT操作：
- 普通索引：每次插入都要更新索引
- 部分索引：只有满足条件的行才更新索引
- 减少维护：根据过滤率减少

UPDATE操作：
- 普通索引：每次更新都要维护索引
- 部分索引：只有状态变化才可能影响索引
- 减少维护：状态变更频率决定

DELETE操作：
- 普通索引：删除时要从索引中移除
- 部分索引：可能本来就不在索引中
- 减少维护：大部分删除操作不影响索引
```

### 4.3 性能监控指标


**📋 关键监控指标**
```sql
-- 1. 索引使用统计
SELECT 
    schema_name,
    table_name,
    index_name,
    cardinality,
    sub_part,
    packed,
    nullable,
    index_type
FROM information_schema.statistics 
WHERE table_name = 'users';

-- 2. 查询执行计划
EXPLAIN SELECT * FROM users 
WHERE email = 'test@example.com' 
AND status = 'active';

-- 关注指标：
-- - key: 是否使用了部分索引
-- - rows: 扫描行数
-- - Extra: 额外信息
```

**📈 性能基准测试**
```bash
# 使用sysbench进行基准测试
sysbench oltp_read_write \
  --mysql-host=localhost \
  --mysql-user=test \
  --mysql-password=test \
  --mysql-db=testdb \
  --tables=1 \
  --table_size=10000000 \
  --time=300 \
  --threads=16 \
  run

# 对比指标：
# - QPS (每秒查询数)
# - 平均响应时间
# - 95%分位延迟
```

---

## 5. 🛠️ 创建与维护实践


### 5.1 创建部分索引


**📝 标准创建语法**
```sql
-- 基本语法
CREATE INDEX index_name 
ON table_name (column1, column2, ...) 
WHERE condition;

-- 实际示例
CREATE INDEX idx_active_user_login 
ON users (email, last_login_time) 
WHERE status = 'active' 
  AND is_deleted = 0;
```

**🔧 创建最佳实践**
```sql
-- 1. 在线创建(MySQL 5.7+)
CREATE INDEX idx_active_orders 
ON orders (customer_id, order_date) 
WHERE status IN ('pending', 'processing')
ALGORITHM=INPLACE, LOCK=NONE;

-- 2. 延迟创建(数据量大时)
-- 步骤1：在从库创建索引
-- 步骤2：主从切换
-- 步骤3：在新从库(原主库)创建索引

-- 3. 分批创建(超大表)
-- 使用pt-online-schema-change工具
pt-online-schema-change \
  --alter "ADD INDEX idx_active_users (email) WHERE status='active'" \
  --execute h=localhost,D=mydb,t=users
```

### 5.2 维护策略


**🔄 索引维护周期**
```sql
-- 1. 统计信息更新
ANALYZE TABLE users;

-- 2. 索引重建(可选)
ALTER TABLE users DROP INDEX idx_active_users;
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';

-- 3. 碎片整理
OPTIMIZE TABLE users;
```

**📊 维护监控脚本**
```sql
-- 监控部分索引效果
SELECT 
    t.table_name,
    t.table_rows,
    s.index_name,
    s.cardinality,
    ROUND(s.cardinality / t.table_rows * 100, 2) as index_coverage_pct
FROM information_schema.tables t
JOIN information_schema.statistics s ON t.table_name = s.table_name
WHERE t.table_schema = 'your_database'
  AND s.index_name LIKE '%partial%'
ORDER BY t.table_name, s.index_name;
```

### 5.3 索引维护自动化


**🤖 自动化脚本示例**
```bash
#!/bin/bash
# 部分索引维护脚本

# 1. 检查索引使用情况
mysql -e "
SELECT 
    table_name,
    index_name,
    cardinality,
    NOW() as check_time
FROM information_schema.statistics 
WHERE table_schema = 'production' 
  AND index_name LIKE 'idx_partial_%'
" > /tmp/index_stats.log

# 2. 检查查询性能
mysql -e "
SELECT 
    sql_text,
    exec_count,
    avg_timer_wait/1000000000 as avg_time_ms
FROM performance_schema.events_statements_summary_by_digest 
WHERE sql_text LIKE '%WHERE status%'
ORDER BY avg_timer_wait DESC 
LIMIT 10
" > /tmp/query_performance.log

# 3. 发送监控报告
if [ -s /tmp/index_stats.log ]; then
    mail -s "MySQL Partial Index Report" admin@company.com < /tmp/index_stats.log
fi
```

---

## 6. 🎪 适用场景分析


### 6.1 高适用性场景


**✅ 最佳适用场景**

#### 🔸 软删除系统

```sql
-- 场景：大量历史数据，查询主要针对未删除数据
CREATE INDEX idx_active_products 
ON products(category_id, price) 
WHERE is_deleted = 0;

-- 适用理由：
-- - 删除数据占比20-30%
-- - 99%查询都是查询未删除数据
-- - 显著节省索引空间
```

#### 🔸 状态驱动系统

```sql
-- 场景：订单系统，多种状态，查询集中在活跃状态
CREATE INDEX idx_processing_orders 
ON orders(customer_id, created_at) 
WHERE status IN ('pending', 'processing', 'shipping');

-- 适用理由：
-- - 已完成订单占80%但查询少
-- - 进行中订单查询频繁
-- - 大幅减少索引维护成本
```

#### 🔸 时间分片数据

```sql
-- 场景：日志系统，主要查询近期数据
CREATE INDEX idx_recent_access_logs 
ON access_logs(user_id, endpoint, access_time) 
WHERE access_time >= DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 适用理由：
-- - 历史日志查询极少
-- - 近期日志查询频繁
-- - 避免索引过大影响性能
```

### 6.2 不适用场景


**❌ 避免使用场景**

#### 🔸 条件过滤效果差

```sql
-- 不推荐：过滤效果有限
CREATE INDEX idx_adult_users 
ON users(email) 
WHERE age >= 18;  -- 可能只过滤5%数据

-- 问题：
-- - 节省空间有限
-- - 查询匹配限制
-- - 维护成本下降不明显
```

#### 🔸 条件频繁变化

```sql
-- 不推荐：条件值频繁变化
CREATE INDEX idx_recent_login_users 
ON users(user_id) 
WHERE last_login_time >= CURRENT_DATE;  -- 每天都变

-- 问题：
-- - 需要频繁重建索引
-- - 维护成本可能更高
-- - 查询优化器难以优化
```

#### 🔸 查询模式不匹配

```sql
-- 业务查询：
SELECT * FROM users WHERE email = 'user@example.com';  -- 无状态条件

-- 部分索引：
CREATE INDEX idx_active_users_email 
ON users(email) WHERE status = 'active';  -- 无法使用

-- 问题：
-- - 索引无法被查询使用
-- - 资源浪费
```

### 6.3 场景评估框架


**📋 评估检查清单**
```
数据特征评估：
- [ ] 过滤条件能排除 >50% 数据
- [ ] 条件值相对稳定（变化 <10%/月）
- [ ] 过滤后数据仍有足够查询价值

查询模式评估：
- [ ] >80% 相关查询包含筛选条件
- [ ] 查询性能是当前瓶颈
- [ ] 现有索引效果不理想

维护成本评估：
- [ ] 预期节省空间 >30%
- [ ] 条件变化不会导致频繁重建
- [ ] 有明确的维护计划

业务价值评估：
- [ ] 解决实际性能问题
- [ ] 符合数据访问模式
- [ ] 有可衡量的改进指标
```

**🎯 决策矩阵**
```
评分标准 (1-5分)：

数据过滤效果：
5分：过滤 >80% 数据
4分：过滤 60-80% 数据  
3分：过滤 40-60% 数据
2分：过滤 20-40% 数据
1分：过滤 <20% 数据

查询匹配度：
5分：>90% 查询匹配
4分：70-90% 查询匹配
3分：50-70% 查询匹配
2分：30-50% 查询匹配
1分：<30% 查询匹配

总分 ≥ 8分：强烈推荐
总分 6-7分：可以考虑
总分 ≤ 5分：不建议使用
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 部分索引本质：带条件的索引，只索引满足WHERE条件的数据行
🔸 核心价值：在保证查询性能的前提下，大幅节省存储空间和维护成本
🔸 设计原则：高选择性、高稳定性、高匹配度的条件设计
🔸 适用场景：软删除、状态驱动、时间分片等数据访问模式
🔸 性能优化：空间节省60-90%，查询性能提升50-80%
```

### 7.2 关键理解要点


**🔹 条件设计的平衡艺术**
```
过滤效果 vs 查询匹配：
- 过滤太严：索引小但能用的查询少
- 过滤太松：节省空间有限
- 最佳平衡：过滤70-80%数据，匹配80%查询

稳定性 vs 实时性：
- 太稳定：可能错过新的查询模式
- 太动态：维护成本高
- 最佳策略：根据业务周期定期评估调整
```

**🔹 为什么部分索引这么有效**
```
传统问题：
- 大表索引占用大量空间
- 包含很多不常查询的数据
- 维护成本随数据量线性增长

部分索引解决方案：
- 只索引"热数据"
- 符合80/20原则：20%数据承担80%查询
- 维护成本与有效数据量成正比
```

**🔹 查询优化器的索引选择**
```
匹配规则：
1. 查询WHERE条件必须"包含"索引WHERE条件
2. 包含关系：查询条件 ⊇ 索引条件
3. 优化器会自动判断是否可以使用部分索引

示例理解：
索引条件：status = 'active'
查询条件：status = 'active' AND age > 25  ✅ 可以使用
查询条件：age > 25  ❌ 无法使用
查询条件：status IN ('active', 'pending')  ❌ 无法使用
```

### 7.3 实际应用指导


**🎯 设计决策流程**
```
步骤1：分析数据分布
- 统计各条件值的数据占比
- 识别"冷热"数据分布

步骤2：分析查询模式  
- 收集慢查询日志
- 统计WHERE条件分布

步骤3：计算收益
- 预估空间节省
- 评估性能提升
- 考虑维护成本

步骤4：测试验证
- 在测试环境验证效果
- 监控性能指标变化
- 确认查询匹配情况

步骤5：生产部署
- 选择合适时机创建
- 监控索引使用情况
- 定期评估优化效果
```

**🔧 维护最佳实践**
```
日常监控：
- 索引大小变化趋势
- 查询命中率统计
- 索引维护开销监控

定期评估：
- 每季度检查数据分布变化
- 评估查询模式演变
- 调整或重建不合适的索引

问题排查：
- 查询未使用索引：检查条件匹配
- 索引效果下降：分析数据分布变化
- 维护成本上升：评估条件稳定性
```

### 7.4 常见误区避免


```
❌ 误区1：认为部分索引适用所有场景
✅ 正确：只在特定数据分布和查询模式下有效

❌ 误区2：条件设计过于复杂
✅ 正确：简单、稳定的条件效果更好

❌ 误区3：创建后不监控不维护
✅ 正确：需要持续监控和定期评估

❌ 误区4：期望立竿见影的巨大改进
✅ 正确：效果取决于具体数据和查询特征
```

**💡 记忆要点**
- 部分索引 = 有条件的索引，专注热数据
- 设计原则 = 高过滤 + 高匹配 + 高稳定
- 适用场景 = 冷热数据分离明显的系统
- 核心价值 = 空间优化 + 性能提升 + 成本降低

**🎯 一句话总结**：部分索引通过智能筛选，让索引更小更快更省，是大数据时代的索引优化利器！