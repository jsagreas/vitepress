---
title: 10、复合索引设计
---
## 📚 目录

1. [复合索引概念与原理](#1-复合索引概念与原理)
2. [最左前缀原则详解](#2-最左前缀原则详解)
3. [列顺序设计策略](#3-列顺序设计策略)
4. [索引覆盖设计](#4-索引覆盖设计)
5. [查询类型优化](#5-查询类型优化)
6. [索引长度与选择性](#6-索引长度与选择性)
7. [冗余索引管理](#7-冗余索引管理)
8. [索引监控与维护](#8-索引监控与维护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔗 复合索引概念与原理


### 1.1 什么是复合索引


**复合索引**：就是把多个列组合在一起建立的索引，也叫**联合索引**或**组合索引**。

```
简单理解：
单列索引 = 给一本书按"姓名"排序做目录
复合索引 = 给一本书按"姓名+年龄+部门"排序做目录

好处：一个索引能同时处理多个查询条件
```

### 1.2 复合索引的存储结构


**💡 存储原理图示**：
```
表数据：
ID  姓名   年龄  部门    工资
1   张三   25   技术部   8000
2   李四   23   销售部   6000
3   王五   25   技术部   9000
4   赵六   27   人事部   7000

复合索引 (姓名, 年龄, 部门)：
┌─────────────────────────────┐
│ 索引树结构                    │
├─────────────────────────────┤
│ 李四,23,销售部 → 指向记录2     │
│ 王五,25,技术部 → 指向记录3     │
│ 张三,25,技术部 → 指向记录1     │
│ 赵六,27,人事部 → 指向记录4     │
└─────────────────────────────┘

排序规则：
1. 先按姓名排序
2. 姓名相同时按年龄排序  
3. 姓名年龄都相同时按部门排序
```

### 1.3 复合索引的工作机制


**🔍 查找过程**：
```sql
-- 创建复合索引
CREATE INDEX idx_name_age_dept ON employees(name, age, department);

-- 查询：WHERE name='张三' AND age=25
-- 索引会直接定位到 "张三,25,*" 的位置
-- 然后继续查找匹配的记录
```

**⚡ 核心机制**：
- **有序存储**：按照列的顺序依次排序
- **快速定位**：利用B+树结构快速查找
- **前缀匹配**：只要前面的列匹配，就能利用索引

---

## 2. 🎯 最左前缀原则详解


### 2.1 什么是最左前缀原则


**最左前缀原则**：复合索引只能从最左边的列开始匹配，不能跳过前面的列。

```
想象一本电话簿：
按 "姓氏-名字-电话" 排序

✅ 能快速找到：
- 所有姓"王"的人（有姓氏）
- 姓"王"名"小明"的人（有姓氏+名字）

❌ 无法快速找到：
- 所有叫"小明"的人（跳过了姓氏）
- 所有电话号码是"138xxx"的人（跳过了姓氏和名字）
```

### 2.2 最左前缀规则详解


**📋 索引使用规则表**：

| 索引列顺序 | 查询条件 | 是否使用索引 | 说明 |
|-----------|---------|-------------|------|
| `(a,b,c)` | `WHERE a=1` | ✅ 使用 | 从最左开始 |
| `(a,b,c)` | `WHERE a=1 AND b=2` | ✅ 使用 | 连续匹配 |
| `(a,b,c)` | `WHERE a=1 AND b=2 AND c=3` | ✅ 使用 | 完全匹配 |
| `(a,b,c)` | `WHERE b=2` | ❌ 不使用 | 跳过了a |
| `(a,b,c)` | `WHERE a=1 AND c=3` | ⚠️ 部分使用 | 只用到a列 |
| `(a,b,c)` | `WHERE a>1 AND b=2` | ⚠️ 部分使用 | a用范围，b无法使用 |

### 2.3 实际示例演示


```sql
-- 创建测试表
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(50),
    salary INT
);

-- 创建复合索引
CREATE INDEX idx_name_age_city ON users(name, age, city);
```

**✅ 能完整使用索引的查询**：
```sql
-- 情况1：完全匹配
SELECT * FROM users WHERE name='张三' AND age=25 AND city='北京';

-- 情况2：前缀匹配
SELECT * FROM users WHERE name='张三';
SELECT * FROM users WHERE name='张三' AND age=25;
```

**⚠️ 部分使用索引的查询**：
```sql
-- 只能用到name列
SELECT * FROM users WHERE name='张三' AND city='北京';

-- name用范围查询，age无法使用索引
SELECT * FROM users WHERE name > '张' AND age=25;
```

**❌ 无法使用索引的查询**：
```sql
-- 跳过了name列
SELECT * FROM users WHERE age=25;
SELECT * FROM users WHERE city='北京';
SELECT * FROM users WHERE age=25 AND city='北京';
```

---

## 3. 📊 列顺序设计策略


### 3.1 列顺序的重要性


**为什么顺序重要**：
复合索引的列顺序直接决定了哪些查询能够使用索引，顺序不同效果完全不同。

```
示例对比：
索引1：(name, age, city)     - 适合按姓名查询的场景
索引2：(age, name, city)     - 适合按年龄查询的场景
索引3：(city, name, age)     - 适合按城市查询的场景

同样的三个列，不同的顺序支持的查询完全不同！
```

### 3.2 列顺序设计原则


**🎯 核心设计原则**：

**① 查询频率优先**
```sql
-- 如果经常按name查询，name放最前面
SELECT * FROM users WHERE name = '张三';                    -- 频繁
SELECT * FROM users WHERE name = '张三' AND age = 25;       -- 频繁  
SELECT * FROM users WHERE age = 25;                        -- 偶尔

-- 索引设计：(name, age, city)
```

**② 选择性高的列优先**
```sql
-- 选择性分析
姓名：1000条记录中有900个不同值  - 选择性高 (90%)
年龄：1000条记录中有50个不同值   - 选择性中 (5%)
性别：1000条记录中有2个不同值    - 选择性低 (0.2%)

-- 索引顺序：(姓名, 年龄, 性别)
```

**③ 等值查询优先于范围查询**
```sql
-- 查询类型分析
WHERE name = '张三'        -- 等值查询
WHERE age BETWEEN 20 AND 30  -- 范围查询
WHERE city = '北京'        -- 等值查询

-- 索引顺序：(name, city, age)  
-- 把范围查询的age放最后
```

### 3.3 实际设计示例


**📋 业务场景分析**：
```sql
-- 常见查询模式
SELECT * FROM orders WHERE customer_id = 100;                           -- 90%
SELECT * FROM orders WHERE customer_id = 100 AND status = 'pending';    -- 70%
SELECT * FROM orders WHERE customer_id = 100 AND order_date > '2024-01-01'; -- 50%
SELECT * FROM orders WHERE status = 'pending';                          -- 10%
SELECT * FROM orders WHERE order_date > '2024-01-01';                   -- 5%
```

**🔧 索引设计方案**：
```sql
-- 方案一：按查询频率设计
CREATE INDEX idx_customer_status_date ON orders(customer_id, status, order_date);

-- 分析：
-- ✅ 支持90%的customer_id查询
-- ✅ 支持70%的customer_id+status查询  
-- ✅ 支持50%的customer_id+范围查询
-- ❌ 不支持单独的status查询
```

**🎯 多索引组合策略**：
```sql
-- 主索引：支持最常见查询
CREATE INDEX idx_customer_status_date ON orders(customer_id, status, order_date);

-- 辅助索引：支持其他查询模式
CREATE INDEX idx_status_date ON orders(status, order_date);

-- 覆盖95%以上的查询场景
```

---

## 4. 🎪 索引覆盖设计


### 4.1 什么是索引覆盖


**索引覆盖**：查询所需的所有列都包含在索引中，不需要回表查询原始数据。

```
普通查询流程：
查询 → 查索引 → 找到主键 → 回表查数据 → 返回结果

覆盖索引查询流程：  
查询 → 查索引 → 直接返回结果（省去回表步骤）

好处：减少IO操作，大幅提升查询性能
```

### 4.2 覆盖索引设计原理


**💡 设计思路**：
```sql
-- 原始查询
SELECT name, age, city FROM users WHERE name = '张三';

-- 如果索引是 (name)
-- 流程：索引查找 → 回表获取age,city → 返回结果

-- 如果索引是 (name, age, city)  
-- 流程：索引查找 → 直接返回结果（覆盖索引）
```

**🔄 覆盖索引示意图**：
```
普通索引结构：
索引 (name) → 主键ID → 回表查询完整记录
     ↓
   张三 → ID=1 → 查询表获取(name=张三, age=25, city=北京)

覆盖索引结构：
索引 (name, age, city) → 直接包含所需数据
     ↓
(张三, 25, 北京) → 直接返回，无需回表
```

### 4.3 覆盖索引实践案例


**📊 案例：用户查询优化**
```sql
-- 业务需求：经常查询用户的基本信息
SELECT user_id, name, email, status 
FROM users 
WHERE department = 'tech' AND level >= 3;
```

**🔧 索引设计方案**：
```sql
-- 方案一：普通索引（需要回表）
CREATE INDEX idx_dept_level ON users(department, level);

-- 方案二：覆盖索引（无需回表）
CREATE INDEX idx_dept_level_cover ON users(department, level, user_id, name, email, status);
```

**⚡ 性能对比**：
```
方案一性能：
- 索引查找：找到100条匹配记录的主键
- 回表查询：100次随机IO读取完整记录
- 总耗时：约50ms

方案二性能：
- 索引查找：直接获取所需数据
- 回表查询：0次
- 总耗时：约5ms（提升10倍）
```

### 4.4 覆盖索引设计技巧


**🎯 设计策略**：

**① 常用列包含策略**
```sql
-- 分析常见SELECT列
SELECT name, age FROM users WHERE city = 'beijing';      -- 60%
SELECT name, salary FROM users WHERE city = 'beijing';   -- 30%  
SELECT * FROM users WHERE city = 'beijing';              -- 10%

-- 设计覆盖索引
CREATE INDEX idx_city_cover ON users(city, name, age, salary);
-- 覆盖90%的查询场景
```

**② 主键自动包含原理**
```sql
-- InnoDB中，二级索引自动包含主键
CREATE INDEX idx_name_age ON users(name, age);

-- 实际索引结构：(name, age, id)
-- 因此这个查询也是覆盖索引：
SELECT id, name, age FROM users WHERE name = '张三';
```

---

## 5. 🚀 查询类型优化


### 5.1 等值查询优化


**等值查询**：使用 `=` 操作符的查询，是复合索引利用率最高的场景。

```sql
-- 等值查询示例
SELECT * FROM users WHERE name = '张三' AND age = 25 AND city = '北京';

-- 索引：(name, age, city)
-- 利用情况：完全利用，精确定位到具体记录
```

**🎯 等值查询优化策略**：
```sql
-- 策略1：多条件等值查询
CREATE INDEX idx_multi_equal ON orders(customer_id, status, payment_method);

-- 支持的查询模式：
SELECT * FROM orders WHERE customer_id = 100;                                    -- ✅
SELECT * FROM orders WHERE customer_id = 100 AND status = 'paid';                -- ✅  
SELECT * FROM orders WHERE customer_id = 100 AND status = 'paid' AND payment_method = 'card'; -- ✅
```

### 5.2 范围查询影响


**范围查询问题**：范围查询会截断索引的使用，后续列无法利用索引。

```sql
-- 索引：(name, age, city)
SELECT * FROM users WHERE name = '张' AND age > 20 AND city = '北京';

-- 索引使用情况：
-- ✅ name = '张'     - 等值查询，使用索引
-- ✅ age > 20       - 范围查询，使用索引  
-- ❌ city = '北京'  - 无法使用索引（被age的范围查询截断）
```

**🔧 范围查询优化方案**：
```sql
-- 方案1：调整列顺序，范围查询列放最后
CREATE INDEX idx_name_city_age ON users(name, city, age);

-- 现在支持：
SELECT * FROM users WHERE name = '张三' AND city = '北京' AND age > 20;
-- ✅ name等值 + city等值 + age范围，充分利用索引

-- 方案2：分别建立索引
CREATE INDEX idx_name_city ON users(name, city);  -- 支持等值查询
CREATE INDEX idx_age ON users(age);               -- 支持范围查询
```

### 5.3 排序优化策略


**排序优化原理**：如果ORDER BY的列顺序和索引列顺序一致，可以避免额外排序。

```sql
-- 索引：(name, age, city)
-- ✅ 能利用索引排序的查询：
SELECT * FROM users WHERE name = '张三' ORDER BY age;
SELECT * FROM users WHERE name = '张三' ORDER BY age, city;
SELECT * FROM users ORDER BY name, age;

-- ❌ 无法利用索引排序的查询：
SELECT * FROM users WHERE name = '张三' ORDER BY city;      -- 跳过了age
SELECT * FROM users ORDER BY age;                          -- 跳过了name  
SELECT * FROM users ORDER BY name DESC, age ASC;           -- 排序方向不一致
```

**📊 排序优化实践**：
```sql
-- 业务场景：用户列表页面排序
SELECT id, name, create_time FROM users 
WHERE status = 'active' 
ORDER BY create_time DESC 
LIMIT 20;

-- 优化索引设计：
CREATE INDEX idx_status_createtime ON users(status, create_time DESC);
-- 直接利用索引排序，无需额外sort操作
```

### 5.4 分组查询支持


**GROUP BY优化**：分组列的顺序要与索引列顺序保持一致。

```sql
-- 索引：(department, level, salary)

-- ✅ 能利用索引的分组：
SELECT department, COUNT(*) FROM users GROUP BY department;
SELECT department, level, AVG(salary) FROM users GROUP BY department, level;

-- ❌ 无法利用索引的分组：
SELECT level, COUNT(*) FROM users GROUP BY level;              -- 跳过department
SELECT department, salary, COUNT(*) FROM users GROUP BY department, salary; -- 跳过level
```

**🎯 分组查询优化案例**：
```sql
-- 需求：统计各部门各级别的薪资信息
SELECT department, level, COUNT(*), AVG(salary), MAX(salary)
FROM employees 
WHERE hire_date > '2020-01-01'
GROUP BY department, level;

-- 优化索引：
CREATE INDEX idx_hire_dept_level_salary ON employees(hire_date, department, level, salary);
-- 支持WHERE过滤 + GROUP BY分组 + 覆盖salary聚合
```

---

## 6. 📏 索引长度与选择性


### 6.1 复合索引长度限制


**索引长度限制**：MySQL对索引总长度有限制，需要合理控制。

```
InnoDB引擎限制：
- 索引键最大长度：3072字节（MySQL 5.7+）
- 单个列最大长度：767字节（无前缀）
- 前缀索引可以减少长度

计算示例：
VARCHAR(100) utf8mb4编码 = 100 × 4 = 400字节
复合索引(name, address, description)可能超限
```

**🔧 长度优化策略**：
```sql
-- 问题：索引过长
CREATE INDEX idx_long ON articles(title, content, author, category);
-- title(200) + content(1000) + author(50) + category(50) > 3072字节

-- 解决方案1：使用前缀索引
CREATE INDEX idx_prefix ON articles(title(50), content(100), author, category);

-- 解决方案2：选择性建索引
CREATE INDEX idx_selective ON articles(author, category, title(50));
-- 去掉大字段content，保留核心查询列
```

### 6.2 索引选择性分析


**选择性定义**：不同值的数量与总记录数的比值，选择性越高，索引效果越好。

```sql
-- 计算列的选择性
SELECT 
    COUNT(DISTINCT name) / COUNT(*) as name_selectivity,
    COUNT(DISTINCT age) / COUNT(*) as age_selectivity,
    COUNT(DISTINCT gender) / COUNT(*) as gender_selectivity
FROM users;

-- 结果示例：
-- name_selectivity: 0.95   (选择性高，适合做索引前缀)
-- age_selectivity: 0.05    (选择性中等)  
-- gender_selectivity: 0.002 (选择性低，不适合单独索引)
```

**📊 选择性指导原则**：

| 选择性范围 | 索引建议 | 示例字段 |
|-----------|---------|---------|
| > 0.8 | 适合做主要索引列 | 用户ID、邮箱、手机号 |
| 0.1 - 0.8 | 适合做辅助索引列 | 姓名、地址 |
| 0.01 - 0.1 | 可以做组合索引后缀 | 年龄、部门 |
| < 0.01 | 不建议单独索引 | 性别、状态 |

### 6.3 选择性优化实践


**🎯 实际优化案例**：
```sql
-- 场景：订单表查询优化
-- 查询模式：按客户+状态+时间查询
SELECT * FROM orders 
WHERE customer_id = 100 AND status = 'pending' AND order_date > '2024-01-01';

-- 选择性分析：
SELECT 
    COUNT(DISTINCT customer_id) / COUNT(*) as customer_selectivity,    -- 0.85
    COUNT(DISTINCT status) / COUNT(*) as status_selectivity,           -- 0.05  
    COUNT(DISTINCT DATE(order_date)) / COUNT(*) as date_selectivity    -- 0.15
FROM orders;

-- 索引设计：按选择性排序
CREATE INDEX idx_orders_optimal ON orders(customer_id, order_date, status);
-- customer_id选择性最高放首位
-- order_date其次（且支持范围查询）
-- status选择性最低放最后
```

---

## 7. 🚫 冗余索引管理


### 7.1 什么是冗余索引


**冗余索引**：功能重复或包含关系的索引，浪费存储空间并影响写入性能。

```
示例冗余情况：
索引1：(name)           
索引2：(name, age)      ← 包含了索引1的功能
索引3：(name, age, city) ← 包含了索引1和索引2的功能

实际上只需要索引3就够了！
```

### 7.2 冗余索引类型


**📋 常见冗余类型**：

**① 完全重复索引**
```sql
-- 重复建立相同索引
CREATE INDEX idx_name1 ON users(name);
CREATE INDEX idx_name2 ON users(name);  -- 完全冗余
```

**② 前缀包含冗余**
```sql
-- 后建的索引包含前面的索引功能
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_name_age ON users(name, age);      -- idx_name是冗余的
CREATE INDEX idx_name_age_city ON users(name, age, city); -- 前两个都冗余了
```

**③ 顺序不同的相似索引**
```sql
-- 功能相似但不完全相同
CREATE INDEX idx_name_age ON users(name, age);
CREATE INDEX idx_age_name ON users(age, name);  -- 支持不同查询模式，不是冗余
```

### 7.3 冗余索引检测


**🔍 检测冗余索引的SQL**：
```sql
-- 查看表的所有索引
SHOW INDEX FROM users;

-- 检测可能的冗余索引
SELECT 
    table_name,
    index_name,
    GROUP_CONCAT(column_name ORDER BY seq_in_index) as columns
FROM information_schema.statistics 
WHERE table_schema = 'your_database' 
    AND table_name = 'users'
GROUP BY table_name, index_name
ORDER BY table_name, columns;
```

**⚡ 冗余索引清理策略**：
```sql
-- 分析现有索引
-- 索引1：idx_name (name)
-- 索引2：idx_name_age (name, age)  
-- 索引3：idx_name_age_city (name, age, city)

-- 清理步骤：
-- 1. 确认查询模式，保留最完整的索引
DROP INDEX idx_name ON users;        -- 删除被包含的索引
DROP INDEX idx_name_age ON users;    -- 删除被包含的索引
-- 2. 保留 idx_name_age_city，它能覆盖所有查询需求
```

### 7.4 冗余索引避免策略


**🎯 设计原则**：

**① 统一规划策略**
```sql
-- 设计前先分析所有查询模式
查询1：WHERE name = ?
查询2：WHERE name = ? AND age = ?  
查询3：WHERE name = ? AND age = ? AND city = ?

-- 统一设计：一个索引解决所有问题
CREATE INDEX idx_comprehensive ON users(name, age, city);
```

**② 渐进式优化**
```sql
-- 不要一次性建立所有可能的索引
-- 而是根据实际查询需求逐步添加

-- 第一阶段：基础索引
CREATE INDEX idx_base ON users(name);

-- 第二阶段：发现需要复合查询，升级索引
DROP INDEX idx_base ON users;
CREATE INDEX idx_enhanced ON users(name, age);

-- 第三阶段：需要更多列，再次升级
DROP INDEX idx_enhanced ON users;  
CREATE INDEX idx_final ON users(name, age, city);
```

---

## 8. 📊 索引监控与维护


### 8.1 索引使用情况监控


**监控指标**：了解索引的实际使用情况，发现无用索引。

```sql
-- 查看索引使用统计（MySQL 5.6+）
SELECT 
    object_schema as database_name,
    object_name as table_name,
    index_name,
    count_read,
    count_write,
    count_read/count_write as read_write_ratio
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE object_schema = 'your_database'
ORDER BY count_read DESC;
```

**📈 监控关键指标**：
- **count_read**：索引被读取的次数
- **count_write**：索引被写入的次数  
- **read_write_ratio**：读写比例
- **未使用索引**：count_read = 0 的索引

### 8.2 查询执行计划分析


**EXPLAIN分析**：检查查询是否正确使用了复合索引。

```sql
-- 分析查询执行计划
EXPLAIN SELECT * FROM users 
WHERE name = '张三' AND age = 25 AND city = '北京';

-- 关键字段解读：
-- key: 实际使用的索引名
-- key_len: 使用的索引长度（判断使用了几个列）
-- rows: 预估扫描的行数
-- Extra: 额外信息（Using index表示覆盖索引）
```

**🔍 索引使用分析示例**：
```
# 索引：idx_name_age_city (name, age, city)

EXPLAIN结果分析：
+-------+------+---------------+------------------+---------+------+--------+-------+
| type  | key  | key_len       | ref              | rows    | Extra         |
+-------+------+---------------+------------------+---------+------+--------+-------+
| ref   | idx_name_age_city | 158 | const,const,const | 1    | Using index   |
+-------+------+---------------+------------------+---------+------+--------+-------+

解读：
- key_len=158：使用了所有三个列（完整索引利用）
- rows=1：精确定位，扫描行数很少
- Using index：覆盖索引，无需回表
```

### 8.3 索引维护策略


**🔧 定期维护任务**：

**① 索引碎片整理**
```sql
-- 检查索引碎片情况
SELECT 
    table_name,
    index_name,
    stat_value as pages,
    stat_value * $$innodb_page_size / 1024 / 1024 as size_mb
FROM mysql.innodb_index_stats 
WHERE stat_name = 'n_leaf_pages' 
    AND database_name = 'your_database'
ORDER BY size_mb DESC;

-- 重建索引消除碎片
ALTER TABLE users DROP INDEX idx_name_age_city;
CREATE INDEX idx_name_age_city ON users(name, age, city);
```

**② 索引统计信息更新**
```sql
-- 更新表的统计信息
ANALYZE TABLE users;

-- 检查统计信息是否准确
SELECT 
    table_name,
    column_name,
    cardinality,
    null_count
FROM information_schema.statistics 
WHERE table_schema = 'your_database' AND table_name = 'users';
```

### 8.4 性能监控最佳实践


**📊 监控仪表板指标**：
```sql
-- 1. 慢查询监控
SELECT 
    sql_text,
    exec_count,
    avg_timer_wait/1000000000 as avg_seconds,
    sum_timer_wait/1000000000 as total_seconds
FROM performance_schema.events_statements_summary_by_digest 
WHERE avg_timer_wait > 1000000000  -- 超过1秒的查询
ORDER BY avg_timer_wait DESC;

-- 2. 索引效率监控  
SELECT 
    table_name,
    index_name,
    cardinality,
    cardinality/table_rows as selectivity
FROM information_schema.statistics s
JOIN information_schema.tables t USING(table_schema, table_name)
WHERE table_schema = 'your_database'
ORDER BY selectivity DESC;
```

**⚡ 自动化监控脚本**：
```bash
#!/bin/bash
# 索引监控脚本

# 检查未使用的索引
mysql -e "
SELECT CONCAT('ALTER TABLE ', table_schema, '.', table_name, ' DROP INDEX ', index_name, ';') as drop_statement
FROM information_schema.statistics 
WHERE table_schema = 'your_database' 
    AND index_name NOT IN (
        SELECT index_name 
        FROM performance_schema.table_io_waits_summary_by_index_usage 
        WHERE count_read > 0
    )
    AND index_name != 'PRIMARY';"
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 复合索引本质：多列组合建立的有序索引结构
🔸 最左前缀原则：只能从最左边开始连续匹配，不能跳过
🔸 列顺序策略：查询频率 > 选择性 > 等值优先于范围
🔸 覆盖索引设计：包含查询所需的所有列，避免回表
🔸 冗余索引管理：避免功能重复的索引浪费资源
```

### 9.2 关键设计原则


**🔹 索引设计的平衡艺术**
```
查询性能 vs 存储空间：
- 索引越多查询越快，但占用更多空间
- 需要在性能和存储之间找到平衡点

写入性能 vs 查询性能：
- 索引过多会影响INSERT/UPDATE性能
- 根据业务特点（读多写少 vs 写多读少）调整策略

通用性 vs 专用性：
- 一个复合索引覆盖多种查询 vs 多个专用索引
- 建议优先设计覆盖面广的通用索引
```

**🔹 实际应用指导**
```
小型应用（<100万记录）：
- 索引策略可以相对简单
- 重点关注最常用的查询
- 适度建立复合索引

大型应用（>1000万记录）：
- 索引设计必须精细化
- 需要详细的性能监控
- 定期优化和维护索引

高并发应用：
- 特别注意写入性能影响
- 优先使用覆盖索引减少IO
- 避免过多的冗余索引
```

### 9.3 常见问题与解决方案


**❌ 常见错误**
```
错误1：盲目建立所有可能的索引组合
正确：根据实际查询需求有针对性地建立索引

错误2：忽视列顺序的重要性
正确：按照查询频率和选择性合理安排列顺序

错误3：不监控索引使用情况
正确：定期检查索引效果，清理无用索引

错误4：范围查询列放在前面
正确：范围查询列应该放在等值查询列后面
```

**✅ 最佳实践清单**
```
设计阶段：
□ 分析所有查询模式和频率
□ 计算各列的选择性
□ 按最左前缀原则设计列顺序
□ 考虑覆盖索引的可能性

实施阶段：
□ 先建立核心索引，后续根据需要扩展
□ 使用EXPLAIN验证索引效果
□ 测试各种查询场景的性能

维护阶段：
□ 监控索引使用情况
□ 定期清理冗余索引
□ 根据业务变化调整索引策略
□ 更新索引统计信息
```

**🎯 记忆要点**
- **复合索引是组合拳**：多个列协同工作，效果远超单列索引
- **最左前缀是铁律**：从左到右连续匹配，不能跳跃
- **列顺序定成败**：顺序不同，支持的查询完全不同
- **覆盖索引是神器**：避免回表，性能提升立竿见影
- **监控维护不可少**：索引不是建完就结束，需要持续优化