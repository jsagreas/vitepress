---
title: 22、索引统计信息
---
## 📚 目录

1. [统计信息基础概念](#1-统计信息基础概念)
2. [统计信息的作用机制](#2-统计信息的作用机制)
3. [自动统计更新机制](#3-自动统计更新机制)
4. [手动统计刷新操作](#4-手动统计刷新操作)
5. [统计信息存储与查看](#5-统计信息存储与查看)
6. [直方图统计详解](#6-直方图统计详解)
7. [统计精度控制与优化](#7-统计精度控制与优化)
8. [统计信息监控与维护](#8-统计信息监控与维护)
9. [查询计划优化实践](#9-查询计划优化实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 📊 统计信息基础概念


### 1.1 什么是MySQL统计信息


**通俗理解**：
统计信息就像是MySQL给每张表和每个索引做的"体检报告"。就像医生需要看你的身高体重血压来判断健康状况一样，MySQL优化器需要看表里有多少数据、数据分布如何，才能选择最好的查询方案。

```
生活类比：
选择出行方式 = MySQL选择查询计划
路况信息     = 统计信息
导航软件     = 查询优化器

导航软件根据实时路况选择最快路线
MySQL根据统计信息选择最优查询计划
```

**统计信息包含的内容**：
```sql
-- 主要统计指标
表的行数              -- 这张表有多少条记录
索引的基数            -- 索引中有多少个不重复的值  
数据分布情况          -- 数据是均匀分布还是集中分布
索引深度              -- B+树的层数
页面数量              -- 占用多少个数据页
```

### 1.2 统计信息的重要性


**为什么统计信息这么重要？**

```
案例对比：

错误的统计信息导致的问题：
- 表A实际100万行，统计信息显示100行
- 优化器认为全表扫描很快，选择了错误的计划
- 实际执行时扫描100万行，查询超慢

正确的统计信息的好处：
- 准确了解数据规模和分布
- 选择合适的索引和连接方式
- 避免不必要的全表扫描
- 提高查询执行效率
```

**统计信息影响的决策**：
```
索引选择：
- 走哪个索引？
- 是否使用索引？
- 多个索引如何组合？

连接策略：
- 表连接的顺序
- 连接算法的选择
- 是否使用临时表

资源分配：
- 分配多少内存
- 是否启用并行处理
- 选择排序算法
```

---

## 2. ⚙️ 统计信息的作用机制


### 2.1 优化器如何使用统计信息


**决策流程图**：
```
查询请求
    ↓
解析SQL语句
    ↓
读取统计信息 ←─ 表统计信息、索引统计信息、直方图
    ↓
计算执行代价 ←─ IO代价、CPU代价、内存代价
    ↓
生成执行计划 ←─ 选择最低代价的方案
    ↓
执行查询
```

### 2.2 代价估算机制


**MySQL如何计算查询代价**：

```sql
-- 示例查询
SELECT * FROM users WHERE age BETWEEN 25 AND 35;
```

**优化器的思考过程**：
```
步骤1：分析WHERE条件
- age BETWEEN 25 AND 35
- 需要估算有多少行满足条件

步骤2：查看统计信息
- users表总行数：1,000,000行
- age列的数据分布（直方图）
- age索引的选择性

步骤3：估算满足条件的行数
- 假设age均匀分布在18-65之间
- 25-35年龄段约占总数的21%（10/47）
- 预估结果：1,000,000 × 21% = 210,000行

步骤4：计算不同方案的代价
方案A：使用age索引
- 索引扫描：210,000 × 索引页面代价
- 回表查询：210,000 × 数据页面代价

方案B：全表扫描
- 扫描整表：1,000,000 × 顺序读取代价

步骤5：选择代价最低的方案
```

### 2.3 统计信息的时效性


**统计信息的时效问题**：
```
数据变化情况：
┌─────────────┬──────────────┬─────────────┐
│    时间     │   实际行数    │ 统计信息行数 │
├─────────────┼──────────────┼─────────────┤
│  2024-01-01 │    100,000   │   100,000   │ ✅ 准确
│  2024-06-01 │    500,000   │   100,000   │ ❌ 过时
│  2024-12-01 │  1,000,000   │   100,000   │ ❌ 严重过时
└─────────────┴──────────────┴─────────────┘

影响：
- 过时的统计信息 → 错误的代价估算 → 糟糕的执行计划
```

---

## 3. 🔄 自动统计更新机制


### 3.1 自动更新触发条件


**MySQL什么时候自动更新统计信息？**

```sql
-- 主要触发场景
1. 表数据变化达到阈值
2. 新增大量数据
3. 删除大量数据
4. 索引重建后
5. 表结构修改后
```

**自动更新阈值设置**：
```sql
-- 查看当前设置
SHOW VARIABLES LIKE '%innodb_stats%';

-- 关键参数说明
innodb_stats_auto_recalc = ON    -- 是否自动重新计算
innodb_stats_persistent = ON     -- 统计信息是否持久化
innodb_stats_sample_pages = 20   -- 采样页面数量
```

### 3.2 采样机制详解


**MySQL如何采样统计信息？**

```
采样原理：
┌─────────────────────────────────────┐
│              整张表                  │
│  [页1][页2][页3]...[页N]            │
│     ↓                              │  
│  随机选择20个页面采样                 │
│  [页5][页12][页28]...[页87]         │
│     ↓                              │
│  根据采样结果推算整表统计              │
└─────────────────────────────────────┘

优点：
- 速度快，不需要扫描整表
- 资源消耗低

缺点：
- 可能不够准确
- 数据分布不均时误差较大
```

**采样精度控制**：
```sql
-- 调整采样页面数量
SET GLOBAL innodb_stats_sample_pages = 50;  -- 提高精度，但增加开销

-- 表级别设置
ALTER TABLE users STATS_SAMPLE_PAGES = 100;  -- 只针对特定表
```

### 3.3 自动更新的优缺点


**优点对比**：
```
✅ 自动化管理，减少人工干预
✅ 及时响应数据变化
✅ 保持统计信息相对准确

❌ 更新时机不可控
❌ 可能在业务高峰期执行
❌ 采样精度有限
❌ 无法针对特定查询优化
```

---

## 4. 🛠️ 手动统计刷新操作


### 4.1 ANALYZE TABLE基础用法


**基本语法和作用**：
```sql
-- 最基本的用法
ANALYZE TABLE users;

-- 执行结果示例
┌───────────┬──────────┬──────────┬─────────────────┐
│   Table   │   Op     │ Msg_type │   Msg_text      │
├───────────┼──────────┼──────────┼─────────────────┤
│ db.users  │ analyze  │  status  │      OK         │
└───────────┴──────────┴──────────┴─────────────────┘
```

**什么时候需要手动执行？**
```
必须手动更新的场景：
1. 🔄 大批量数据导入后
2. 📊 查询性能突然下降
3. 🗓️ 定期维护任务
4. 🔧 索引重建后
5. 📈 数据分布发生重大变化

示例场景：
-- 刚导入了100万条历史数据
LOAD DATA INFILE 'users.csv' INTO TABLE users;
ANALYZE TABLE users;  -- 立即更新统计信息
```

### 4.2 ANALYZE TABLE高级选项


**更精确的统计方式**：
```sql
-- 更新所有索引的统计信息
ANALYZE TABLE users UPDATE HISTOGRAM ON age, salary WITH 100 BUCKETS;

-- 删除直方图
ANALYZE TABLE users DROP HISTOGRAM ON age;

-- 批量处理多张表
ANALYZE TABLE users, orders, products;
```

**直方图详解**：
```sql
-- 创建直方图统计
ANALYZE TABLE users UPDATE HISTOGRAM ON age WITH 50 BUCKETS;

-- 直方图的作用
普通统计：只知道age列有1000个不同值
直方图统计：知道每个年龄段的具体分布情况

例如：
18-25岁：30% 的用户
26-35岁：40% 的用户  
36-45岁：20% 的用户
46-60岁：10% 的用户
```

### 4.3 批量统计更新策略


**高效的批量更新方法**：
```sql
-- 方法1：使用存储过程批量处理
DELIMITER //
CREATE PROCEDURE UpdateAllStats()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE table_name VARCHAR(64);
    DECLARE table_cursor CURSOR FOR 
        SELECT TABLE_NAME 
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_TYPE = 'BASE TABLE';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    stats_loop: LOOP
        FETCH table_cursor INTO table_name;
        IF done THEN
            LEAVE stats_loop;
        END IF;
        
        SET @sql = CONCAT('ANALYZE TABLE ', table_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    
    CLOSE table_cursor;
END//
DELIMITER ;

-- 执行批量更新
CALL UpdateAllStats();
```

**定时任务设置**：
```bash
# 在crontab中设置定期更新
# 每天凌晨2点更新统计信息
0 2 * * * mysql -u root -p'password' -e "CALL UpdateAllStats();"

# 或者使用MySQL事件调度器
CREATE EVENT daily_stats_update
ON SCHEDULE EVERY 1 DAY
STARTS '2024-01-01 02:00:00'
DO
  CALL UpdateAllStats();
```

---

## 5. 💾 统计信息存储与查看


### 5.1 统计信息的存储位置


**MySQL在哪里保存统计信息？**

```sql
-- 表级统计信息
SELECT * FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = 'your_database';

-- 重要字段说明
TABLE_ROWS          -- 表的行数（估算值）
AVG_ROW_LENGTH      -- 平均行长度
DATA_LENGTH         -- 数据文件大小  
INDEX_LENGTH        -- 索引文件大小
AUTO_INCREMENT      -- 自增值
UPDATE_TIME         -- 最后更新时间
```

**索引级统计信息**：
```sql
-- 查看索引统计
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,        -- 索引基数（不重复值的数量）
    SUB_PART,
    NULLABLE
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY TABLE_NAME, INDEX_NAME;
```

### 5.2 详细统计信息查看


**查看表的详细统计**：
```sql
-- 方法1：使用SHOW TABLE STATUS
SHOW TABLE STATUS LIKE 'users'\G

-- 输出示例
*************************** 1. row ***************************
           Name: users
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
           Rows: 1048576      -- 行数
 Avg_row_length: 157          -- 平均行长度
    Data_length: 164626432    -- 数据大小（字节）
Max_data_length: 0
   Index_length: 52428800    -- 索引大小（字节）
      Data_free: 7340032
 Auto_increment: 1048577
    Create_time: 2024-01-01 10:00:00
    Update_time: 2024-09-10 15:30:00    -- 最后更新时间
     Check_time: NULL
      Collation: utf8mb4_0900_ai_ci
       Checksum: NULL
 Create_options: 
        Comment: 用户信息表
```

**查看索引选择性**：
```sql
-- 计算索引选择性（越接近1越好）
SELECT 
    INDEX_NAME,
    CARDINALITY,
    TABLE_ROWS,
    ROUND(CARDINALITY / TABLE_ROWS, 4) AS selectivity
FROM 
    INFORMATION_SCHEMA.STATISTICS s
    JOIN INFORMATION_SCHEMA.TABLES t 
    ON s.TABLE_NAME = t.TABLE_NAME 
    AND s.TABLE_SCHEMA = t.TABLE_SCHEMA
WHERE 
    s.TABLE_SCHEMA = 'your_database'
    AND s.TABLE_NAME = 'users'
    AND s.SEQ_IN_INDEX = 1;  -- 只看复合索引的第一列

-- 结果示例
┌─────────────┬─────────────┬────────────┬─────────────┐
│ INDEX_NAME  │ CARDINALITY │ TABLE_ROWS │ selectivity │
├─────────────┼─────────────┼────────────┼─────────────┤
│ PRIMARY     │   1048576   │  1048576   │    1.0000   │ ✅ 完美
│ idx_email   │   1048576   │  1048576   │    1.0000   │ ✅ 完美
│ idx_age     │       48    │  1048576   │    0.0000   │ ❌ 较差
│ idx_gender  │        2    │  1048576   │    0.0000   │ ❌ 很差
└─────────────┴─────────────┴────────────┴─────────────┘
```

### 5.3 直方图信息查看


**查看直方图统计**：
```sql
-- 查看哪些列有直方图
SELECT 
    SCHEMA_NAME,
    TABLE_NAME, 
    COLUMN_NAME,
    HISTOGRAM,
    BUCKET_COUNT
FROM INFORMATION_SCHEMA.COLUMN_STATISTICS;

-- 查看直方图详细内容（JSON格式）
SELECT 
    COLUMN_NAME,
    JSON_PRETTY(HISTOGRAM) AS histogram_data
FROM INFORMATION_SCHEMA.COLUMN_STATISTICS 
WHERE SCHEMA_NAME = 'your_database' 
AND TABLE_NAME = 'users';
```

---

## 6. 📈 直方图统计详解


### 6.1 什么是直方图统计


**直方图的通俗解释**：
```
传统统计信息的局限：
- 只知道列有多少个不同值
- 不知道数据的具体分布情况
- 像只知道班级有50个学生，但不知道男女比例

直方图统计的优势：
- 详细记录数据分布情况  
- 能精确估算范围查询的结果数量
- 像知道班级50个学生中，男生30个，女生20个

生活类比：
传统统计 = 知道水果店有1000个水果
直方图   = 知道苹果300个，橙子200个，香蕉500个
```

### 6.2 直方图的工作原理


**直方图的构建过程**：
```
步骤1：数据采样
从表中采样数据，获取列值分布

步骤2：分桶处理  
将数据值域分成若干个桶（bucket）

步骤3：统计频率
计算每个桶中数据的频率

示例：age列的直方图
原始数据：18,19,20,21...65岁用户
分成10个桶：
桶1：18-22岁，占比15%
桶2：23-27岁，占比20%  
桶3：28-32岁，占比25%
...
桶10：63-67岁，占比5%
```

### 6.3 创建和使用直方图


**创建直方图的最佳实践**：
```sql
-- 为经常用于范围查询的列创建直方图
ANALYZE TABLE users UPDATE HISTOGRAM ON age WITH 50 BUCKETS;
ANALYZE TABLE users UPDATE HISTOGRAM ON salary WITH 100 BUCKETS;
ANALYZE TABLE orders UPDATE HISTOGRAM ON order_date WITH 30 BUCKETS;

-- 选择合适的桶数量
小表（<10万行）：10-20个桶
中表（10-100万行）：50-100个桶  
大表（>100万行）：100-255个桶（最大值）
```

**直方图对查询优化的影响**：
```sql
-- 示例查询：查找25-35岁的用户
SELECT * FROM users WHERE age BETWEEN 25 AND 35;

-- 没有直方图时：
-- 优化器假设数据均匀分布
-- 估算：总行数 × ((35-25)/(最大值-最小值))

-- 有直方图时：
-- 优化器查看直方图中25-35岁的实际分布
-- 得到更准确的行数估算
-- 选择更优的执行计划
```

### 6.4 直方图的维护


**直方图的更新策略**：
```sql
-- 定期更新直方图（数据分布变化较大的列）
-- 可以结合定时任务执行

-- 检查直方图统计的时效性
SELECT 
    TABLE_NAME,
    COLUMN_NAME,
    JSON_EXTRACT(HISTOGRAM, '$.last-updated') AS last_updated
FROM INFORMATION_SCHEMA.COLUMN_STATISTICS
WHERE SCHEMA_NAME = DATABASE();

-- 删除不需要的直方图
ANALYZE TABLE users DROP HISTOGRAM ON obsolete_column;
```

---

## 7. 🎯 统计精度控制与优化


### 7.1 采样精度配置


**影响统计精度的关键参数**：
```sql
-- 全局设置
SET GLOBAL innodb_stats_sample_pages = 20;    -- 默认采样页数
SET GLOBAL innodb_stats_transient_sample_pages = 8;  -- 临时统计采样页数

-- 表级别设置（推荐）
ALTER TABLE users STATS_SAMPLE_PAGES = 100;   -- 提高精度
ALTER TABLE logs STATS_SAMPLE_PAGES = 10;     -- 降低开销
```

**采样页数的选择策略**：
```
小表（<1万行）：
- 采样页数：5-10页
- 原因：数据量小，全量扫描成本低

中表（1-100万行）：  
- 采样页数：20-50页
- 平衡：精度vs性能

大表（>100万行）：
- 采样页数：50-200页  
- 重点：保证统计精度

关键业务表：
- 采样页数：100-500页
- 优先：统计准确性
```

### 7.2 统计精度验证


**如何验证统计信息的准确性**：
```sql
-- 验证行数统计
SELECT 
    (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES 
     WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'users') AS estimated_rows,
    (SELECT COUNT(*) FROM users) AS actual_rows,
    ABS((SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES 
         WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'users') 
        - (SELECT COUNT(*) FROM users)) / (SELECT COUNT(*) FROM users) * 100 AS error_percentage;

-- 结果示例
┌────────────────┬─────────────┬─────────────────┐
│ estimated_rows │ actual_rows │ error_percentage│
├────────────────┼─────────────┼─────────────────┤
│    1048576     │   1050000   │      0.14%      │ ✅ 误差很小
└────────────────┴─────────────┴─────────────────┘
```

**验证索引基数**：
```sql
-- 验证索引选择性
SELECT 
    'email' AS column_name,
    (SELECT CARDINALITY FROM INFORMATION_SCHEMA.STATISTICS 
     WHERE TABLE_NAME = 'users' AND COLUMN_NAME = 'email') AS estimated_cardinality,
    (SELECT COUNT(DISTINCT email) FROM users) AS actual_cardinality;
```

### 7.3 精度优化策略


**不同场景的优化策略**：

<details>
<summary>📋 点击查看详细优化配置</summary>

```sql
-- 1. 高精度配置（关键业务表）
ALTER TABLE critical_table 
    STATS_SAMPLE_PAGES = 200,
    STATS_AUTO_RECALC = 1,
    STATS_PERSISTENT = 1;

-- 创建详细的直方图
ANALYZE TABLE critical_table 
UPDATE HISTOGRAM ON key_column1, key_column2 WITH 100 BUCKETS;

-- 2. 性能优先配置（日志表）
ALTER TABLE log_table 
    STATS_SAMPLE_PAGES = 5,
    STATS_AUTO_RECALC = 0,  -- 关闭自动更新
    STATS_PERSISTENT = 1;

-- 3. 平衡配置（一般业务表）
ALTER TABLE normal_table 
    STATS_SAMPLE_PAGES = 50,
    STATS_AUTO_RECALC = 1,
    STATS_PERSISTENT = 1;
```

</details>

---

## 8. 🔍 统计信息监控与维护


### 8.1 统计信息过期检测


**如何检测统计信息是否过期**：
```sql
-- 检查统计信息更新时间
SELECT 
    TABLE_NAME,
    TABLE_ROWS,
    UPDATE_TIME,
    DATEDIFF(NOW(), UPDATE_TIME) AS days_since_update,
    CASE 
        WHEN DATEDIFF(NOW(), UPDATE_TIME) > 7 THEN '⚠️ 需要更新'
        WHEN DATEDIFF(NOW(), UPDATE_TIME) > 3 THEN '🔔 建议更新'  
        ELSE '✅ 状态良好'
    END AS status
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_TYPE = 'BASE TABLE'
ORDER BY days_since_update DESC;
```

**自动检测脚本**：
```sql
-- 创建监控视图
CREATE VIEW v_stats_health AS
SELECT 
    TABLE_NAME,
    TABLE_ROWS,
    UPDATE_TIME,
    CASE 
        WHEN UPDATE_TIME IS NULL THEN '❌ 从未更新'
        WHEN DATEDIFF(NOW(), UPDATE_TIME) > 7 THEN '⚠️ 严重过期'
        WHEN DATEDIFF(NOW(), UPDATE_TIME) > 3 THEN '🔔 建议更新'
        ELSE '✅ 状态正常'
    END AS health_status,
    DATEDIFF(NOW(), UPDATE_TIME) AS days_old
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_TYPE = 'BASE TABLE';

-- 查看健康状态
SELECT * FROM v_stats_health WHERE health_status != '✅ 状态正常';
```

### 8.2 统计信息监控指标


**关键监控指标**：
```sql
-- 1. 统计信息新鲜度
SELECT 
    AVG(DATEDIFF(NOW(), UPDATE_TIME)) AS avg_days_old,
    MAX(DATEDIFF(NOW(), UPDATE_TIME)) AS max_days_old,
    COUNT(*) AS total_tables,
    SUM(CASE WHEN DATEDIFF(NOW(), UPDATE_TIME) > 7 THEN 1 ELSE 0 END) AS outdated_tables
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = DATABASE() AND TABLE_TYPE = 'BASE TABLE';

-- 2. 统计信息覆盖率
SELECT 
    COUNT(*) AS total_tables,
    SUM(CASE WHEN UPDATE_TIME IS NOT NULL THEN 1 ELSE 0 END) AS tables_with_stats,
    ROUND(SUM(CASE WHEN UPDATE_TIME IS NOT NULL THEN 1 ELSE 0 END) / COUNT(*) * 100, 2) AS coverage_percentage
FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_SCHEMA = DATABASE() AND TABLE_TYPE = 'BASE TABLE';
```

### 8.3 维护任务自动化


**创建自动维护任务**：
```sql
-- 创建统计信息维护存储过程
DELIMITER //
CREATE PROCEDURE MaintainTableStats()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE table_name VARCHAR(64);
    DECLARE days_old INT;
    
    -- 查找需要更新的表
    DECLARE table_cursor CURSOR FOR 
        SELECT TABLE_NAME, DATEDIFF(NOW(), UPDATE_TIME)
        FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_TYPE = 'BASE TABLE'
        AND (UPDATE_TIME IS NULL OR DATEDIFF(NOW(), UPDATE_TIME) > 3);
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN table_cursor;
    
    update_loop: LOOP
        FETCH table_cursor INTO table_name, days_old;
        IF done THEN
            LEAVE update_loop;
        END IF;
        
        -- 更新统计信息
        SET @sql = CONCAT('ANALYZE TABLE ', table_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- 记录日志
        INSERT INTO stats_maintenance_log (table_name, update_time, days_old)
        VALUES (table_name, NOW(), days_old);
        
    END LOOP;
    
    CLOSE table_cursor;
END//
DELIMITER ;

-- 创建日志表
CREATE TABLE stats_maintenance_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    update_time DATETIME,
    days_old INT,
    INDEX idx_update_time (update_time)
);
```

---

## 9. 🚀 查询计划优化实践


### 9.1 统计信息对执行计划的影响


**实际案例分析**：
```sql
-- 示例表和查询
CREATE TABLE user_orders (
    user_id INT,
    order_date DATE,
    amount DECIMAL(10,2),
    INDEX idx_user_id (user_id),
    INDEX idx_order_date (order_date)
);

-- 查询：查找某用户最近一个月的订单
SELECT * FROM user_orders 
WHERE user_id = 12345 
AND order_date >= '2024-08-01';
```

**统计信息影响分析**：
```
场景1：统计信息过时
- user_id=12345 实际有1000个订单
- 统计信息显示只有10个订单
- 优化器错误地选择了索引合并
- 实际执行时性能很差

场景2：统计信息准确  
- 正确反映user_id=12345有1000个订单
- 优化器选择先过滤user_id，再过滤日期
- 执行效率很高

执行计划对比：
错误计划：index_merge(idx_user_id, idx_order_date)
正确计划：idx_user_id -> 再过滤order_date
```

### 9.2 执行计划分析技巧


**使用EXPLAIN分析统计信息影响**：
```sql
-- 查看执行计划
EXPLAIN FORMAT=JSON 
SELECT * FROM user_orders 
WHERE user_id = 12345 
AND order_date >= '2024-08-01'\G

-- 关注关键信息
{
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "123.45"    -- 查询代价
    },
    "table": {
      "table_name": "user_orders",
      "access_type": "ref",      -- 访问方式
      "possible_keys": ["idx_user_id", "idx_order_date"],
      "key": "idx_user_id",      -- 选择的索引
      "rows_examined_per_scan": 1000,  -- 估算扫描行数
      "rows_produced_per_join": 200,   -- 估算结果行数
      "filtered": "20.00"        -- 过滤百分比
    }
  }
}
```

**分析执行计划的关键指标**：
```sql
-- 检查行数估算准确性
EXPLAIN SELECT * FROM user_orders WHERE user_id = 12345;

-- 实际验证
SELECT COUNT(*) FROM user_orders WHERE user_id = 12345;

-- 对比分析
估算行数：1000行（EXPLAIN显示）
实际行数：950行（COUNT查询）
误差率：5.3%（可接受范围）
```

### 9.3 优化实践案例


**案例1：范围查询优化**：
```sql
-- 问题查询：查找特定日期范围的订单
SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';

-- 步骤1：检查统计信息
SHOW TABLE STATUS LIKE 'orders';
SELECT CARDINALITY FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_NAME = 'orders' AND COLUMN_NAME = 'order_date';

-- 步骤2：创建直方图提高精度
ANALYZE TABLE orders UPDATE HISTOGRAM ON order_date WITH 30 BUCKETS;

-- 步骤3：验证优化效果
EXPLAIN SELECT * FROM orders 
WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';
```

**案例2：连接查询优化**：
```sql
-- 问题查询：多表连接性能差
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_date >= '2024-01-01'
GROUP BY u.id, u.name;

-- 优化步骤
-- 1. 更新统计信息
ANALYZE TABLE users;
ANALYZE TABLE orders;

-- 2. 检查连接列的选择性
SELECT 
    COUNT(DISTINCT id) as user_cardinality,
    COUNT(*) as total_users
FROM users;

SELECT 
    COUNT(DISTINCT user_id) as user_id_cardinality,
    COUNT(*) as total_orders  
FROM orders;

-- 3. 创建必要的直方图
ANALYZE TABLE users UPDATE HISTOGRAM ON created_date WITH 50 BUCKETS;
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 统计信息本质：MySQL用于选择最优查询计划的"数据体检报告"
🔸 核心作用：帮助优化器准确估算查询代价，选择最优执行策略
🔸 主要内容：表行数、索引基数、数据分布、直方图统计
🔸 时效性：统计信息会过时，需要定期更新维护
🔸 精度控制：通过采样页数和直方图控制统计精度
```

### 10.2 关键操作要点


**🔹 统计信息更新策略**：
```
自动更新：
✅ 适合大多数场景
✅ 减少维护工作量
❌ 时机不可控
❌ 精度有限

手动更新：  
✅ 时机可控
✅ 精度更高
✅ 可针对性优化
❌ 需要人工干预

推荐策略：
- 关键表：手动定期更新
- 一般表：自动更新为主
- 批量导入后：立即手动更新
```

**🔹 直方图使用原则**：
```
适用场景：
✅ 经常用于范围查询的列
✅ 数据分布不均匀的列
✅ 连接条件中的关键列

不适用场景：
❌ 数据分布非常均匀的列
❌ 很少用于查询条件的列  
❌ 频繁更新的列

桶数选择：
- 小表：10-20个桶
- 中表：50-100个桶
- 大表：100-255个桶
```

### 10.3 性能优化指导


**🎯 监控要点**：
```sql
-- 核心监控指标
1. 统计信息新鲜度：超过7天需要关注
2. 统计精度：估算值与实际值误差<10%
3. 直方图覆盖率：关键查询列应有直方图
4. 执行计划稳定性：避免因统计信息波动导致计划变化
```

**🔧 维护最佳实践**：
```
日常维护：
□ 定期检查统计信息健康状态
□ 为关键查询列创建直方图
□ 监控查询计划变化
□ 设置自动维护任务

应急处理：
□ 查询性能突然下降时首先检查统计信息
□ 大批量数据变更后立即更新统计
□ 重要业务前主动更新关键表统计
```

### 10.4 常见问题与解决方案


**❓ 统计信息相关的常见问题**：

<details>
<summary>🔍 点击查看问题解决方案</summary>

```sql
-- 问题1：查询突然变慢
解决步骤：
1. 检查统计信息更新时间
2. 对比执行计划变化
3. 手动更新统计信息
4. 验证性能恢复

-- 问题2：统计信息不准确
解决方案：
1. 增加采样页数
2. 创建直方图
3. 手动强制更新
4. 定期维护策略

-- 问题3：统计更新影响性能
优化措施：
1. 选择业务低峰期更新
2. 分批次处理大表
3. 调整采样精度
4. 使用异步更新
```

</details>

**🎓 学习建议**：
- **理论理解**：掌握统计信息的作用原理和影响机制
- **实践操作**：熟练使用ANALYZE TABLE和相关查询语句
- **监控维护**：建立定期检查和更新的维护体系
- **问题诊断**：能够通过统计信息分析查询性能问题

> 💡 **核心记忆**：
> 统计信息是查询优化的基础，准确及时的统计信息是高性能MySQL的重要保障。就像地图导航需要实时路况信息一样，MySQL优化器需要准确的统计信息来选择最优路径。