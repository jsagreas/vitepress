---
title: 11、数据同步规则配置
---
## 📚 目录

1. [数据同步规则概述](#1-数据同步规则概述)
2. [表级别同步规则](#2-表级别同步规则)
3. [列级别过滤规则](#3-列级别过滤规则)
4. [数据变换规则](#4-数据变换规则)
5. [路由规则配置](#5-路由规则配置)
6. [条件同步配置](#6-条件同步配置)
7. [同步模式选择](#7-同步模式选择)
8. [批量与实时同步配置](#8-批量与实时同步配置)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 数据同步规则概述


### 1.1 什么是数据同步规则


**简单理解**：数据同步规则就像是给搬家工人的"搬运指南"。告诉工人哪些东西要搬、怎么搬、搬到哪里去。

```
现实搬家场景：           数据同步场景：
搬运工 + 搬运规则        Gravity + 同步规则
    ↓                      ↓
客厅的沙发 → 新房客厅     用户表 → 目标数据库
卧室的床 → 新房卧室       订单表 → 分析系统
厨房用具 → 不搬运         临时表 → 不同步
```

### 1.2 为什么需要同步规则


**核心作用**：
- 🎯 **精准控制**：决定哪些数据需要同步
- 🔄 **灵活变换**：在同步过程中修改数据格式
- 🚀 **性能优化**：避免同步不必要的数据
- 🛡️ **数据安全**：过滤敏感信息

> 💡 **通俗理解**：如果没有规则，就像搬家时什么都往新房搬，连垃圾都搬过去了

### 1.3 Gravity规则体系架构


```
Gravity同步规则层次：

├── 表级别规则（Table Rules）
│   ├── 包含哪些表
│   └── 排除哪些表
│
├── 列级别规则（Column Rules）  
│   ├── 包含哪些字段
│   └── 排除哪些字段
│
├── 数据变换规则（Transform Rules）
│   ├── 字段重命名
│   └── 数据格式转换
│
├── 路由规则（Route Rules）
│   ├── 数据分发策略
│   └── 目标库选择
│
└── 条件规则（Filter Rules）
    ├── 数据过滤条件
    └── 业务逻辑筛选
```

---

## 2. 📋 表级别同步规则


### 2.1 表级别规则基本概念


**什么是表级别规则**：决定哪些数据表要同步，哪些不同步。就像搬家时决定哪个房间的东西要搬。

### 2.2 包含表规则（Include Tables）


**配置方式**：
```yaml
# 方式1：明确指定要同步的表
include-tables:
  - "user_info"           # 用户信息表
  - "order_detail"        # 订单详情表
  - "product_*"           # 所有product开头的表

# 方式2：使用正则表达式
include-tables:
  - "user_.*"             # 所有user开头的表
  - ".*_log$"             # 所有log结尾的表
```

**实际场景举例**：
```
电商系统同步场景：
✅ 要同步的表：
  - user_info （用户基本信息）
  - order_main （订单主表）
  - product_catalog （商品目录）
  
❌ 不需要同步的表：
  - temp_calculation （临时计算表）
  - debug_info （调试信息表）
  - cache_data （缓存数据表）
```

### 2.3 排除表规则（Exclude Tables）


**配置示例**：
```yaml
# 排除敏感或临时数据表
exclude-tables:
  - "password_reset"      # 密码重置表（敏感）
  - "temp_*"              # 所有临时表
  - "backup_*"            # 所有备份表
  - "test_*"              # 所有测试表
```

### 2.4 表规则优先级


| 优先级 | 规则类型 | 说明 | 示例 |
|--------|----------|------|------|
| **高** | `exclude-tables` | 排除规则优先 | 即使在include中，exclude也会生效 |
| **低** | `include-tables` | 包含规则其次 | 只有不在exclude中的才会被包含 |

> ⚠️ **重要**：排除规则的优先级比包含规则高！

**配置示例**：
```yaml
# 这个配置中，user_temp表不会被同步
include-tables:
  - "user_*"              # 包含所有user开头的表
exclude-tables:
  - "user_temp"           # 但排除user_temp表

# 结果：user_info、user_profile会同步，user_temp不会同步
```

---

## 3. 🔍 列级别过滤规则


### 3.1 什么是列级别过滤


**通俗解释**：如果表级别规则决定搬哪个房间，那列级别规则就是决定房间里的哪些物品要搬。

```
表级别：决定整张桌子要不要搬
列级别：决定桌子上的哪些东西要搬

用户表示例：
┌─────────────┬──────────┬──────────┬──────────────┐
│ user_id     │ username │ password │ phone        │
├─────────────┼──────────┼──────────┼──────────────┤
│ ✅ 要同步    │ ✅ 要同步  │ ❌ 不同步  │ ✅ 要同步     │
│ (主键)      │ (用户名)  │ (敏感)   │ (联系方式)   │
└─────────────┴──────────┴──────────┴──────────────┘
```

### 3.2 包含列配置（Include Columns）


**配置语法**：
```yaml
# 为特定表配置要同步的列
column-rules:
  user_info:
    include-columns:
      - "user_id"         # 用户ID
      - "username"        # 用户名  
      - "email"          # 邮箱
      - "created_at"     # 创建时间
      
  order_detail:
    include-columns:
      - "order_id"       # 订单ID
      - "product_id"     # 商品ID
      - "quantity"       # 数量
      - "price"          # 价格
```

### 3.3 排除列配置（Exclude Columns）


**常见排除场景**：
```yaml
column-rules:
  user_info:
    exclude-columns:
      - "password"       # 密码字段（安全考虑）
      - "salt"          # 密码盐值（安全考虑）
      - "login_token"   # 登录令牌（临时数据）
      - "last_ip"       # 最后登录IP（隐私考虑）
      
  financial_record:
    exclude-columns:
      - "bank_account"   # 银行账号（敏感信息）
      - "credit_card"    # 信用卡号（敏感信息）
```

### 3.4 列规则实际应用


**场景1：用户数据同步到分析系统**
```yaml
# 只同步分析需要的用户字段
user_analysis_sync:
  table: "user_info"
  include-columns:
    - "user_id"         # 用户标识
    - "age"            # 年龄（用于分析）
    - "gender"         # 性别（用于分析）
    - "city"           # 城市（用于分析）
    - "register_date"  # 注册日期（用于分析）
  # 排除个人隐私信息
```

**场景2：订单数据同步到报表系统**
```yaml
order_report_sync:
  table: "order_main"
  exclude-columns:
    - "customer_note"   # 客户备注（无分析价值）
    - "internal_memo"   # 内部备注（内部信息）
    - "refund_reason"   # 退款原因（敏感信息）
```

---

## 4. 🔄 数据变换规则


### 4.1 数据变换的基本概念


**什么是数据变换**：在数据搬运过程中，对数据进行"包装"或"重新整理"。就像搬家时把散装的书籍装到书箱里，并贴上标签。

```
搬家场景：                数据变换场景：
书籍 → 装箱 → 贴标签        原始数据 → 转换 → 新格式
衣服 → 折叠 → 分类放置      用户名 → 加密 → 存储
```

### 4.2 字段重命名（Column Rename）


**为什么需要重命名**：
- 🎯 **统一命名**：不同系统的字段名可能不同
- 📝 **语义清晰**：让字段名更容易理解
- 🔄 **兼容性**：适配目标系统的要求

**配置示例**：
```yaml
transform-rules:
  user_info:
    column-mapping:
      "id" → "user_id"           # 统一主键命名
      "name" → "username"        # 更清晰的命名
      "phone" → "mobile_number"  # 统一手机号命名
      "create_time" → "created_at"  # 统一时间戳命名
```

### 4.3 数据格式转换（Data Format Transform）


**常见转换场景**：

**时间格式转换**：
```yaml
time-format-transform:
  user_info:
    "created_at":
      from: "YYYY-MM-DD HH:mm:ss"     # MySQL格式
      to: "timestamp"                  # Unix时间戳
      
  order_main:
    "order_date":
      from: "timestamp"                # Unix时间戳
      to: "YYYY-MM-DD"                # 只保留日期
```

**数据类型转换**：
```yaml
data-type-transform:
  product_info:
    "price":
      from: "string"                   # 字符串价格
      to: "decimal(10,2)"             # 精确小数
      
    "is_active":
      from: "int"                     # 0/1表示
      to: "boolean"                   # true/false表示
```

### 4.4 数据加工规则（Data Processing Rules）


**数据脱敏**：
```yaml
data-masking:
  user_info:
    "phone":
      rule: "mask-middle"             # 138****5678
    "email":  
      rule: "mask-domain"             # user***@example.com
    "id_card":
      rule: "mask-except-last4"       # ************1234
```

**数据计算**：
```yaml
computed-fields:
  order_summary:
    "total_amount":
      formula: "quantity * unit_price"  # 计算总金额
    "discount_rate":
      formula: "discount / original_price * 100"  # 计算折扣率
```

---

## 5. 🗺️ 路由规则配置


### 5.1 什么是路由规则


**通俗理解**：路由规则就像快递配送规则，决定不同的数据"包裹"应该送到哪个"地址"。

```
快递分拣场景：                数据路由场景：
北京的包裹 → 北京配送中心      用户数据 → 用户中心数据库
上海的包裹 → 上海配送中心      订单数据 → 订单处理系统
广州的包裹 → 广州配送中心      日志数据 → 日志分析系统
```

### 5.2 基于表的路由规则


**按业务模块分发**：
```yaml
table-routing:
  # 用户相关表路由到用户服务数据库
  user-service-db:
    target: "user_center_db"
    tables:
      - "user_info"
      - "user_profile"
      - "user_settings"
      
  # 订单相关表路由到订单服务数据库  
  order-service-db:
    target: "order_center_db"
    tables:
      - "order_main"
      - "order_detail"
      - "order_payment"
      
  # 日志表路由到日志分析系统
  log-analysis-db:
    target: "log_analysis_db"
    tables:
      - "*_log"
      - "*_audit"
```

### 5.3 基于数据内容的路由规则


**按地区分发**：
```yaml
content-based-routing:
  user_info:
    routing-rules:
      - condition: "city = '北京'"
        target: "beijing_db"
      - condition: "city = '上海'"  
        target: "shanghai_db"
      - condition: "city = '广州'"
        target: "guangzhou_db"
      - condition: "default"
        target: "default_db"
```

**按时间分发**：
```yaml
time-based-routing:
  order_main:
    routing-rules:
      - condition: "created_at >= '2024-01-01'"
        target: "current_year_db"       # 当年数据
      - condition: "created_at < '2024-01-01'"
        target: "history_db"            # 历史数据
```

### 5.4 负载均衡路由


**轮询分发**：
```yaml
load-balance-routing:
  user_behavior_log:
    strategy: "round-robin"             # 轮询策略
    targets:
      - "analysis_db_1"
      - "analysis_db_2" 
      - "analysis_db_3"
    weight:
      analysis_db_1: 40                 # 40%流量
      analysis_db_2: 35                 # 35%流量
      analysis_db_3: 25                 # 25%流量
```

---

## 6. 🔍 条件同步配置


### 6.1 条件同步的基本概念


**什么是条件同步**：就像有选择性的搬家，只搬符合特定条件的物品。

```
搬家场景：只搬重要的、有用的物品
数据同步：只同步符合业务条件的数据

例子：
✅ 只搬一年内买的家具 → 只同步活跃用户数据
✅ 只搬完好无损的物品 → 只同步状态正常的记录
❌ 不搬损坏的物品     → 不同步删除标记的数据
```

### 6.2 基于字段值的条件过滤


**用户数据过滤**：
```yaml
conditional-sync:
  user_info:
    conditions:
      - field: "status"
        operator: "="
        value: "active"               # 只同步活跃用户
        
      - field: "created_at" 
        operator: ">="
        value: "2023-01-01"           # 只同步2023年后注册的用户
        
      - field: "is_deleted"
        operator: "="
        value: 0                      # 排除已删除用户
```

**订单数据过滤**：
```yaml
order_conditional_sync:
  order_main:
    conditions:
      - field: "order_status"
        operator: "in"
        value: ["paid", "shipped", "completed"]  # 只同步有效订单状态
        
      - field: "order_amount"
        operator: ">"
        value: 0                      # 排除金额为0的订单
```

### 6.3 复合条件配置


**AND条件组合**：
```yaml
complex-conditions:
  user_behavior:
    and-conditions:                   # 所有条件都必须满足
      - field: "user_level"
        operator: ">="
        value: 2                      # 用户等级大于等于2
      - field: "last_login"
        operator: ">="  
        value: "2024-01-01"           # 最近登录时间在2024年后
      - field: "is_vip"
        operator: "="
        value: true                   # 是VIP用户
```

**OR条件组合**：
```yaml
or-conditions:
  important_users:
    or-conditions:                    # 满足任一条件即可
      - field: "is_vip"
        operator: "="
        value: true                   # VIP用户
      - field: "total_consumption"
        operator: ">"
        value: 10000                  # 消费总额超过1万
      - field: "user_type"
        operator: "="
        value: "premium"              # 高级用户
```

### 6.4 动态条件配置


**基于时间的动态过滤**：
```yaml
dynamic-conditions:
  daily_sync:
    time-based-filter:
      field: "updated_at"
      operator: ">="
      value: "today-1day"             # 最近1天更新的数据
      
  incremental_sync:
    incremental-filter:
      field: "sync_timestamp"
      operator: ">"
      value: "last_sync_time"         # 上次同步后的新数据
```

---

## 7. ⚙️ 同步模式选择


### 7.1 同步模式概述


**什么是同步模式**：就像选择搬家方式，是一次性全部搬完，还是分批次搬，还是有新东西就随时搬。

```
搬家模式对比：              数据同步模式对比：

一次性搬家：               全量同步：
全部物品一次搬完            全部数据一次同步完

分批搬家：                 批量同步：  
今天搬客厅，明天搬卧室       按批次分时段同步

随时搬家：                 实时同步：
买了新东西立即搬过去         数据变化立即同步
```

### 7.2 全量同步模式（Full Sync）


**适用场景**：
- 🎯 **初始化数据**：第一次建立同步关系
- 🔄 **数据重建**：目标库需要完全重建
- 📊 **定期刷新**：定期更新所有数据

**配置示例**：
```yaml
full-sync-mode:
  mode: "full"
  schedule: "0 2 * * *"               # 每天凌晨2点全量同步
  tables:
    - "user_info"
    - "product_catalog"
  options:
    batch-size: 10000                 # 每批次处理1万条记录
    parallel-workers: 4               # 4个并行工作线程
```

**执行流程**：
```
第1步：清空目标表（可选）
第2步：从源表读取所有数据
第3步：批量写入目标表
第4步：验证数据一致性
```

### 7.3 增量同步模式（Incremental Sync）


**核心理念**：只同步发生变化的数据，就像只搬新买的家具。

**基于时间戳的增量同步**：
```yaml
incremental-sync:
  mode: "incremental"
  schedule: "*/5 * * * *"             # 每5分钟增量同步
  incremental-column: "updated_at"    # 基于更新时间字段
  tables:
    user_info:
      incremental-column: "updated_at"
    order_main:
      incremental-column: "modified_time"
```

**基于binlog的增量同步**：
```yaml
binlog-incremental:
  mode: "binlog"
  mysql-config:
    server-id: 1001
    binlog-format: "ROW"
  filter:
    databases: ["ecommerce"]
    tables: ["user_info", "order_main"]
```

### 7.4 实时同步模式（Real-time Sync）


**实时同步特点**：
- ⚡ **低延迟**：数据变化几乎实时反映
- 🔄 **持续监听**：持续监控数据变化
- 📈 **高吞吐**：支持高频数据变化

**配置示例**：
```yaml
realtime-sync:
  mode: "realtime"
  source:
    type: "mysql-binlog"
    mysql:
      host: "source-db.example.com"
      port: 3306
      username: "sync_user"
  target:
    type: "kafka"                     # 实时推送到消息队列
    kafka:
      brokers: ["kafka1:9092", "kafka2:9092"]
      topic: "user-events"
```

### 7.5 混合同步模式


**组合模式配置**：
```yaml
hybrid-sync:
  # 全量同步：每天执行一次
  full-sync:
    schedule: "0 1 * * *"
    tables: ["product_catalog", "category_info"]
    
  # 增量同步：每小时执行一次  
  incremental-sync:
    schedule: "0 * * * *"
    tables: ["user_info", "user_profile"]
    
  # 实时同步：关键业务表
  realtime-sync:
    tables: ["order_main", "payment_record"]
```

---

## 8. 📦 批量与实时同步配置


### 8.1 批量同步配置详解


**什么是批量同步**：把数据打包成批次，一批一批地同步。就像装货车，装满一车再发车。

### 8.2 批量大小配置（Batch Size）


**批量大小的影响**：
```
批量太小：                  批量太大：
🔸 同步频繁，性能开销大        🔸 内存占用大
🔸 实时性好                 🔸 失败时影响范围大  
🔸 适合实时性要求高的场景      🔸 适合批量处理场景

最佳实践：
💡 根据数据特点和硬件性能调整
💡 一般建议1000-10000条记录
💡 可以通过测试找到最优值
```

**配置示例**：
```yaml
batch-config:
  # 小表配置：较小批量，保证实时性
  user_info:
    batch-size: 1000
    batch-timeout: "30s"              # 30秒超时
    
  # 大表配置：较大批量，提高效率  
  order_detail:
    batch-size: 10000
    batch-timeout: "300s"             # 5分钟超时
    
  # 日志表配置：超大批量，性能优先
  access_log:
    batch-size: 50000
    batch-timeout: "600s"             # 10分钟超时
```

### 8.3 并发控制配置


**并发处理配置**：
```yaml
concurrency-config:
  parallel-tables: 3                  # 同时处理3张表
  parallel-batches: 2                 # 每张表2个批次并发
  max-connections: 10                 # 最大数据库连接数
  
  # 表级别并发控制
  table-concurrency:
    user_info: 1                      # 重要表单线程处理
    log_table: 4                      # 日志表多线程处理
```

### 8.4 实时同步配置详解


**实时同步的核心配置**：
```yaml
realtime-config:
  # binlog监听配置
  binlog:
    mysql:
      host: "192.168.1.100"
      port: 3306
      username: "replicator"
      password: "password"
      server-id: 1001                 # 唯一服务器ID
      
  # 缓冲区配置  
  buffer:
    size: 10000                       # 缓冲区大小
    flush-interval: "1s"              # 刷新间隔
    max-wait-time: "5s"               # 最大等待时间
    
  # 失败重试配置
  retry:
    max-retries: 3                    # 最大重试次数
    retry-interval: "10s"             # 重试间隔
    exponential-backoff: true         # 指数退避
```

### 8.5 性能优化配置


**网络优化**：
```yaml
network-optimization:
  # 连接池配置
  connection-pool:
    initial-size: 5                   # 初始连接数
    max-size: 20                      # 最大连接数
    max-idle-time: "300s"             # 最大空闲时间
    
  # 数据压缩
  compression:
    enabled: true                     # 启用压缩
    algorithm: "gzip"                 # 压缩算法
    level: 6                          # 压缩级别（1-9）
```

**内存优化**：
```yaml
memory-optimization:
  # JVM配置
  jvm:
    heap-size: "2g"                   # 堆内存大小
    gc-algorithm: "G1GC"              # 垃圾回收算法
    
  # 缓存配置
  cache:
    metadata-cache-size: "100m"       # 元数据缓存
    data-cache-size: "500m"           # 数据缓存
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 数据同步规则：控制数据同步的"指挥官"
🔸 表级别规则：决定哪些表参与同步
🔸 列级别规则：决定表中哪些字段同步
🔸 数据变换规则：在同步过程中修改数据格式
🔸 路由规则：决定数据发送到哪个目标
🔸 条件同步：根据业务条件选择性同步
🔸 同步模式：全量、增量、实时三种基本模式
🔸 批量配置：控制数据处理的批次大小和并发
```

### 9.2 规则配置的最佳实践


**🔹 规则设计原则**
```
安全性优先：
• 敏感数据必须排除或脱敏
• 使用白名单而非黑名单
• 定期审核同步规则

性能优化：
• 合理设置批量大小
• 避免同步不必要的数据
• 使用增量同步而非全量同步

可维护性：
• 规则配置要清晰易懂
• 添加必要的注释说明
• 版本控制和变更记录
```

**🔹 常见配置误区**
```
❌ 同步所有表和字段（浪费资源）
❌ 批量大小设置不合理（性能问题）
❌ 没有考虑数据安全（泄露风险）
❌ 缺少错误处理机制（稳定性问题）

✅ 按需同步，精确控制
✅ 根据实际情况调优参数
✅ 重视数据安全和隐私
✅ 完善的监控和报警机制
```

### 9.3 实际应用场景总结


**📊 电商系统数据同步**
- 用户数据 → 推荐系统（排除敏感信息）
- 订单数据 → 分析平台（实时同步）
- 商品数据 → 搜索引擎（全量+增量）

**📈 数据仓库建设**
- 业务库 → 数据仓库（ETL处理）
- 实时数据 → 实时计算（流处理）
- 历史数据 → 离线分析（批处理）

**🔄 微服务数据同步**
- 用户服务 → 其他服务（用户信息同步）
- 订单服务 → 库存服务（库存扣减）
- 支付服务 → 订单服务（支付状态）

**核心记忆口诀**：
- 同步规则要谨慎，安全性能要兼顾
- 表列过滤精准控，条件路由分得清
- 全量增量实时选，批量大小要调优
- 监控报警不能少，问题排查要及时