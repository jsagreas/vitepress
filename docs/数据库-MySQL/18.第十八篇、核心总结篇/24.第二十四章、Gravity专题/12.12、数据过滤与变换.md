---
title: 12、数据过滤与变换
---
## 📚 目录

1. [数据过滤与变换概述](#1-数据过滤与变换概述)
2. [数据过滤策略](#2-数据过滤策略)
3. [字段映射配置](#3-字段映射配置)
4. [数据类型转换](#4-数据类型转换)
5. [字符集与时间格式转换](#5-字符集与时间格式转换)
6. [数据脱敏配置](#6-数据脱敏配置)
7. [自定义变换函数](#7-自定义变换函数)
8. [条件过滤规则](#8-条件过滤规则)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 数据过滤与变换概述


### 1.1 什么是数据过滤与变换


**简单理解**：就像是给数据做"筛选"和"加工"
- **过滤**：只要符合条件的数据，不要的扔掉
- **变换**：把数据从一种格式改成另一种格式

```
原始数据 → [过滤器] → 符合条件的数据 → [变换器] → 目标格式数据
```

### 1.2 为什么需要数据过滤与变换


**现实场景**：
```
情况1：只同步VIP用户数据
原始：所有用户数据 → 过滤：只要VIP用户 → 结果：VIP用户数据

情况2：隐藏敏感信息
原始：手机号13812345678 → 变换：脱敏处理 → 结果：138****5678

情况3：统一数据格式
原始：时间"2025-01-15" → 变换：格式转换 → 结果："20250115"
```

### 1.3 Gravity中的处理流程


```
MySQL源数据
    ↓
┌─────────────┐
│  数据过滤   │ ← 根据条件筛选数据
├─────────────┤
│  字段映射   │ ← 字段名称对应关系
├─────────────┤
│  类型转换   │ ← 数据类型适配
├─────────────┤
│  格式变换   │ ← 字符集、时间格式等
├─────────────┤
│  数据脱敏   │ ← 敏感信息处理
├─────────────┤
│  自定义函数 │ ← 特殊业务逻辑处理
└─────────────┘
    ↓
目标系统数据
```

---

## 2. 🔍 数据过滤策略


### 2.1 过滤策略基本概念


**什么是数据过滤**：根据预设条件，决定哪些数据要同步，哪些不要

**过滤的三个层面**：
- **表级过滤**：整张表要不要同步
- **行级过滤**：表中哪些行要同步  
- **列级过滤**：行中哪些字段要同步

### 2.2 表级过滤配置


**配置说明**：指定要同步的数据库和表

```json
{
  "source": {
    "host": "source-mysql",
    "schema": "business_db",
    "tables": [
      "users",           // 只同步users表
      "orders",          // 只同步orders表
      "user_profiles"    // 只同步user_profiles表
    ],
    "ignore-tables": [
      "temp_*",          // 忽略所有temp_开头的表
      "log_*",           // 忽略所有log_开头的表
      "cache_data"       // 忽略cache_data表
    ]
  }
}
```

**实际应用场景**：
- 🔸 **生产到测试环境**：只同步核心业务表，忽略日志表
- 🔸 **数据仓库ETL**：只同步业务数据，忽略系统配置表
- 🔸 **多租户系统**：只同步特定租户的表

### 2.3 行级过滤配置


**配置原理**：根据行数据的某些字段值决定是否同步这一行

```json
{
  "filters": [
    {
      "schema": "business_db",
      "table": "users",
      "match-expr": "status = 'active' AND vip_level > 0",
      "action": "include"
    },
    {
      "schema": "business_db", 
      "table": "orders",
      "match-expr": "order_status != 'deleted'",
      "action": "include"
    }
  ]
}
```

**通俗解释**：
- `match-expr`：过滤条件，就像SQL的WHERE语句
- `action: "include"`：符合条件的**要**同步
- `action: "exclude"`：符合条件的**不要**同步

### 2.4 列级过滤配置


**应用场景**：某些敏感字段不需要同步到目标系统

```json
{
  "column-filters": [
    {
      "schema": "business_db",
      "table": "users", 
      "include-columns": [
        "id", "username", "email", "created_at"
      ],
      "exclude-columns": [
        "password", "salt", "secret_key"
      ]
    }
  ]
}
```

**实用技巧**：
- 🔸 **安全考虑**：密码、密钥等敏感字段不同步
- 🔸 **性能优化**：大文本字段（如备注）可以不同步
- 🔸 **业务需要**：只同步下游系统需要的字段

---

## 3. 🗂️ 字段映射配置


### 3.1 字段映射的作用


**简单理解**：就是告诉Gravity"源表的A字段对应目标表的B字段"

```
源表结构：              目标表结构：
user_id      ────────→  id
user_name    ────────→  name  
phone_num    ────────→  mobile
create_time  ────────→  created_at
```

### 3.2 基础字段映射


```json
{
  "field-mappings": [
    {
      "schema": "business_db",
      "table": "users",
      "mappings": {
        "user_id": "id",
        "user_name": "name",
        "phone_num": "mobile",
        "create_time": "created_at"
      }
    }
  ]
}
```

**配置说明**：
- `"user_id": "id"`：源表的user_id字段映射到目标表的id字段
- 如果字段名相同，可以不配置映射关系

### 3.3 复杂字段映射


**字段合并映射**：
```json
{
  "mappings": {
    "first_name + ' ' + last_name": "full_name"
  }
}
```

**字段拆分映射**：
```json
{
  "mappings": {
    "SUBSTRING(full_name, 1, LOCATE(' ', full_name)-1)": "first_name",
    "SUBSTRING(full_name, LOCATE(' ', full_name)+1)": "last_name"
  }
}
```

**常量映射**：
```json
{
  "mappings": {
    "'GRAVITY_SYNC'": "sync_source",
    "NOW()": "sync_time"
  }
}
```

### 3.4 映射配置最佳实践


| 场景 | 配置方式 | 说明 |
|------|----------|------|
| **字段重命名** | `"old_name": "new_name"` | 最常见的映射方式 |
| **添加常量** | `"'固定值'": "target_field"` | 为目标表添加固定值 |
| **字段计算** | `"field1 + field2": "sum_field"` | 简单的字段运算 |
| **条件映射** | `"CASE WHEN ... END": "result"` | 根据条件设置值 |

---

## 4. 🔄 数据类型转换


### 4.1 为什么需要类型转换


**现实问题**：不同数据库系统的数据类型不完全相同

```
MySQL类型      →    目标系统类型
TINYINT(1)     →    BOOLEAN
DATETIME       →    TIMESTAMP  
VARCHAR(255)   →    TEXT
DECIMAL(10,2)  →    NUMERIC
```

### 4.2 自动类型转换


**Gravity默认转换规则**：
```
数值类型转换：
MySQL INT      → PostgreSQL INTEGER
MySQL BIGINT   → PostgreSQL BIGINT
MySQL DECIMAL  → PostgreSQL NUMERIC

字符类型转换：
MySQL VARCHAR  → PostgreSQL VARCHAR
MySQL TEXT     → PostgreSQL TEXT
MySQL CHAR     → PostgreSQL CHAR

时间类型转换：
MySQL DATETIME → PostgreSQL TIMESTAMP
MySQL DATE     → PostgreSQL DATE
MySQL TIME     → PostgreSQL TIME
```

### 4.3 自定义类型转换


```json
{
  "type-mappings": [
    {
      "schema": "business_db",
      "table": "users",
      "column-mappings": {
        "is_vip": {
          "source-type": "TINYINT(1)",
          "target-type": "BOOLEAN",
          "convert-expr": "is_vip = 1"
        },
        "score": {
          "source-type": "VARCHAR(10)",
          "target-type": "INTEGER", 
          "convert-expr": "CAST(score AS SIGNED)"
        }
      }
    }
  ]
}
```

**通俗解释**：
- `source-type`：源数据类型
- `target-type`：目标数据类型
- `convert-expr`：转换表达式，告诉Gravity怎么转换

### 4.4 类型转换注意事项


**⚠️ 转换风险**：
```
精度丢失：
DECIMAL(10,5) → INTEGER  // 小数部分会丢失

数据截断：
VARCHAR(100) → VARCHAR(50)  // 超过50字符的会被截断

格式错误：
VARCHAR "abc" → INTEGER  // 无法转换会报错
```

**🔧 安全转换建议**：
- 数值转换前先验证数据范围
- 字符串转换注意长度限制
- 时间转换注意时区问题
- 重要转换要做数据校验

---

## 5. 🌐 字符集与时间格式转换


### 5.1 字符集转换


**什么是字符集**：简单说就是文字的编码方式

**常见问题**：
```
源系统：UTF8编码的中文"用户"
目标系统：GBK编码要求
结果：可能出现乱码
```

### 5.2 字符集转换配置


```json
{
  "charset-conversion": {
    "source-charset": "utf8mb4",
    "target-charset": "utf8",
    "tables": [
      {
        "schema": "business_db",
        "table": "users",
        "columns": ["username", "nickname", "address"]
      }
    ]
  }
}
```

**配置说明**：
- `source-charset`：源数据库字符集
- `target-charset`：目标系统要求的字符集
- `columns`：需要转换的字段列表

### 5.3 时间格式转换


**时间格式转换场景**：
```
MySQL格式：    "2025-01-15 14:30:25"
目标格式：     "20250115143025"
或者：         "2025/01/15 02:30:25 PM"
```

### 5.4 时间转换配置


```json
{
  "datetime-conversion": [
    {
      "schema": "business_db",
      "table": "orders",
      "column": "order_time",
      "source-format": "YYYY-MM-DD HH:mm:ss",
      "target-format": "YYYYMMDDHHMMSS"
    },
    {
      "schema": "business_db", 
      "table": "users",
      "column": "birthday",
      "source-format": "YYYY-MM-DD",
      "target-format": "MM/DD/YYYY"
    }
  ]
}
```

### 5.5 时区转换处理


```json
{
  "timezone-conversion": {
    "source-timezone": "Asia/Shanghai",
    "target-timezone": "UTC",
    "datetime-columns": [
      "created_at",
      "updated_at", 
      "order_time"
    ]
  }
}
```

**实际应用**：
- 🔸 **全球化系统**：统一转换为UTC时间
- 🔸 **跨时区同步**：北京时间转换为美国时间
- 🔸 **数据仓库**：统一时区便于分析

---

## 6. 🔒 数据脱敏配置


### 6.1 什么是数据脱敏


**通俗解释**：把敏感信息"打码"处理，保护用户隐私

**脱敏例子**：
```
手机号：13812345678  →  138****5678
邮箱：  user@email.com  →  u***@email.com
身份证：110101199001011234  →  110101****1234
姓名：  张三  →  张*
```

### 6.2 脱敏策略配置


```json
{
  "data-masking": [
    {
      "schema": "business_db",
      "table": "users",
      "rules": [
        {
          "column": "mobile",
          "type": "phone",
          "pattern": "${prefix:3}****${suffix:4}"
        },
        {
          "column": "email", 
          "type": "email",
          "pattern": "${prefix:1}***@${domain}"
        },
        {
          "column": "id_card",
          "type": "id_card", 
          "pattern": "${prefix:6}****${suffix:4}"
        },
        {
          "column": "real_name",
          "type": "name",
          "pattern": "${first}*"
        }
      ]
    }
  ]
}
```

### 6.3 常用脱敏规则


| 数据类型 | 脱敏方式 | 示例 |
|----------|----------|------|
| **手机号** | 中间4位打码 | `138****5678` |
| **邮箱** | 用户名部分脱敏 | `u***@email.com` |
| **身份证** | 中间部分打码 | `110101****1234` |
| **姓名** | 保留姓氏 | `张*` |
| **银行卡** | 只保留后4位 | `****1234` |
| **地址** | 具体门牌号脱敏 | `北京市朝阳区***` |

### 6.4 自定义脱敏函数


```json
{
  "custom-masking": [
    {
      "name": "address_mask",
      "function": "CONCAT(SUBSTRING(address, 1, 6), '***')",
      "description": "地址脱敏，保留前6个字符"
    },
    {
      "name": "amount_mask", 
      "function": "CASE WHEN amount > 10000 THEN '***' ELSE CAST(amount AS CHAR) END",
      "description": "金额脱敏，大于1万显示***"
    }
  ]
}
```

### 6.5 脱敏配置注意事项


**⚠️ 重要提醒**：
- 脱敏是**不可逆**操作，脱敏后无法恢复原始数据
- 要根据业务需求选择合适的脱敏程度
- 生产环境配置前要充分测试

**🎯 应用场景**：
- 生产数据同步到测试环境
- 数据提供给第三方合作伙伴
- 数据分析时保护用户隐私

---

## 7. ⚙️ 自定义变换函数


### 7.1 什么是自定义变换函数


**简单理解**：当内置的转换功能满足不了需求时，可以自己写转换逻辑

**应用场景**：
- 复杂的业务规则转换
- 特殊的数据格式处理
- 多字段组合计算

### 7.2 JavaScript变换函数


```javascript
// 配置文件中的自定义函数
{
  "custom-transforms": [
    {
      "name": "userLevelTransform",
      "type": "javascript",
      "code": `
        function transform(row) {
          // 根据积分计算用户等级
          const score = parseInt(row.score) || 0;
          let level;
          if (score >= 10000) {
            level = 'VIP';
          } else if (score >= 5000) {
            level = 'GOLD'; 
          } else if (score >= 1000) {
            level = 'SILVER';
          } else {
            level = 'BRONZE';
          }
          
          row.user_level = level;
          return row;
        }
      `
    }
  ]
}
```

### 7.3 SQL表达式变换


```json
{
  "sql-transforms": [
    {
      "schema": "business_db",
      "table": "orders", 
      "transforms": [
        {
          "target-column": "order_year",
          "expression": "YEAR(order_date)"
        },
        {
          "target-column": "total_with_tax",
          "expression": "total_amount * 1.13"
        },
        {
          "target-column": "customer_type",
          "expression": "CASE WHEN customer_level > 5 THEN 'VIP' ELSE 'NORMAL' END"
        }
      ]
    }
  ]
}
```

### 7.4 外部API调用变换


```json
{
  "api-transforms": [
    {
      "name": "addressGeocode",
      "description": "地址转换为经纬度",
      "api": {
        "url": "https://api.map.baidu.com/geocoding/v3/",
        "method": "GET",
        "params": {
          "address": "${address}",
          "ak": "your_api_key"
        }
      },
      "response-mapping": {
        "result.location.lat": "latitude",
        "result.location.lng": "longitude" 
      }
    }
  ]
}
```

### 7.5 变换函数应用配置


```json
{
  "transform-rules": [
    {
      "schema": "business_db",
      "table": "users",
      "apply-transforms": [
        "userLevelTransform"  // 应用自定义的用户等级转换
      ]
    },
    {
      "schema": "business_db", 
      "table": "addresses",
      "apply-transforms": [
        "addressGeocode"  // 应用地址地理编码转换
      ]
    }
  ]
}
```

---

## 8. 📋 条件过滤规则


### 8.1 条件过滤的应用场景


**实际需求**：
- 只同步最近一年的订单数据
- 只同步状态为"已发布"的文章
- 排除测试用户的数据
- 只同步特定地区的数据

### 8.2 时间条件过滤


```json
{
  "conditional-filters": [
    {
      "schema": "business_db",
      "table": "orders",
      "conditions": [
        {
          "type": "time-range",
          "column": "created_at", 
          "operator": ">=",
          "value": "DATE_SUB(NOW(), INTERVAL 1 YEAR)"
        }
      ]
    }
  ]
}
```

**常用时间过滤**：
- `>= DATE_SUB(NOW(), INTERVAL 1 YEAR)`：最近一年
- `>= DATE_SUB(NOW(), INTERVAL 30 DAY)`：最近30天
- `BETWEEN '2025-01-01' AND '2025-12-31'`：指定年份

### 8.3 状态条件过滤


```json
{
  "conditional-filters": [
    {
      "schema": "business_db",
      "table": "articles",
      "conditions": [
        {
          "type": "status",
          "column": "status",
          "operator": "IN", 
          "value": ["published", "featured"]
        },
        {
          "type": "exclude",
          "column": "is_deleted",
          "operator": "=",
          "value": 1
        }
      ]
    }
  ]
}
```

### 8.4 复合条件过滤


```json
{
  "conditional-filters": [
    {
      "schema": "business_db",
      "table": "users",
      "conditions": [
        {
          "logic": "AND",
          "rules": [
            {
              "column": "status",
              "operator": "=", 
              "value": "active"
            },
            {
              "column": "vip_level",
              "operator": ">",
              "value": 0
            },
            {
              "logic": "OR",
              "rules": [
                {
                  "column": "last_login",
                  "operator": ">=",
                  "value": "DATE_SUB(NOW(), INTERVAL 30 DAY)"
                },
                {
                  "column": "order_count",
                  "operator": ">", 
                  "value": 10
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

**条件逻辑解释**：
- 用户状态是活跃的 **AND**
- VIP等级大于0 **AND** 
- (最近30天有登录 **OR** 订单数量大于10)

### 8.5 动态条件配置


```json
{
  "dynamic-filters": [
    {
      "name": "tenant_filter",
      "description": "多租户数据过滤",
      "condition": "tenant_id = ${TENANT_ID}",
      "parameters": {
        "TENANT_ID": {
          "type": "environment",
          "source": "SYNC_TENANT_ID"
        }
      }
    }
  ]
}
```

**应用场景**：
- 🔸 **多租户系统**：根据租户ID过滤数据
- 🔸 **分环境同步**：根据环境变量过滤不同数据
- 🔸 **权限控制**：根据用户权限过滤可见数据

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 数据过滤：根据条件筛选要同步的数据
🔸 字段映射：源字段与目标字段的对应关系  
🔸 类型转换：不同数据库间的类型适配
🔸 格式转换：字符集、时间格式的标准化
🔸 数据脱敏：敏感信息的保护处理
🔸 自定义函数：复杂业务逻辑的处理
🔸 条件过滤：基于业务规则的数据筛选
```

### 9.2 配置优先级理解


```
配置处理顺序：
1. 表级过滤    ← 决定哪些表要同步
2. 行级过滤    ← 决定表中哪些行要同步  
3. 列级过滤    ← 决定行中哪些字段要同步
4. 字段映射    ← 字段名称转换
5. 数据类型转换 ← 类型适配
6. 格式转换    ← 字符集、时间格式
7. 数据脱敏    ← 敏感信息处理
8. 自定义变换  ← 业务逻辑处理
```

### 9.3 实际应用指导


**🎯 选择合适的过滤策略**：
- **性能优先**：在源头过滤，减少传输数据量
- **安全优先**：敏感数据必须脱敏处理
- **业务优先**：根据下游系统需求配置转换

**🔧 配置最佳实践**：
- 先在测试环境验证配置正确性
- 重要转换要做数据校验
- 复杂逻辑优先使用SQL表达式
- 脱敏配置要充分测试

**⚠️ 常见注意事项**：
- 类型转换可能导致精度丢失
- 脱敏是不可逆操作
- 复杂转换可能影响同步性能
- 条件过滤要考虑数据完整性

**核心记忆**：
- 数据过滤与变换是Gravity的核心功能
- 合理配置能大大提升同步效率和数据质量
- 安全性和性能要平衡考虑
- 配置前一定要充分测试验证