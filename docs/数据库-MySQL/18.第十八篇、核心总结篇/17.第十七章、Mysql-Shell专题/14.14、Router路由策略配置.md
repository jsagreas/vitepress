---
title: 14、Router路由策略配置
---
## 📚 目录

1. [MySQL Router概述](#1-MySQL-Router概述)
2. [路由策略类型详解](#2-路由策略类型详解)
3. [读写路由模式配置](#3-读写路由模式配置)
4. [负载均衡策略](#4-负载均衡策略)
5. [路由规则与目标服务器](#5-路由规则与目标服务器)
6. [高级路由特性](#6-高级路由特性)
7. [故障转移机制](#7-故障转移机制)
8. [实战配置示例](#8-实战配置示例)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌐 MySQL Router概述


### 1.1 什么是MySQL Router


**简单理解**：MySQL Router就像一个"交通指挥员"，帮助应用程序找到正确的数据库服务器。

```
应用程序 → MySQL Router → 合适的MySQL服务器
     ↑           ↑              ↑
   发起请求    智能路由        实际处理
```

> 💡 **核心概念**：Router是一个轻量级的中间件，它接收客户端的数据库连接请求，然后根据预设的规则，将这些请求"指路"到最合适的MySQL服务器上。

**为什么需要Router？**
- **高可用性** ⭐⭐⭐：当某台数据库服务器出故障时，自动切换到其他服务器
- **负载分担** ⭐⭐⭐：把大量请求分散到多台服务器，避免单台服务器过载
- **读写分离** ⭐⭐⭐：写操作去主服务器，读操作去从服务器，提升性能

### 1.2 Router在MySQL架构中的位置


```
应用层 ┌─────────────────┐
      │   Web应用       │
      │   移动应用       │
      └─────────────────┘
              │
路由层 ┌─────────────────┐
      │  MySQL Router   │ ← 智能路由分发
      └─────────────────┘
              │
数据层 ┌─────────────────┐
      │  MySQL集群      │
      │ 主库 │ 从库1 │从库2│
      └─────────────────┘
```

---

## 2. 🚦 路由策略类型详解


### 2.1 read-write路由模式


**什么是read-write模式？**
这是最常用的路由模式，它能自动识别SQL语句的类型，然后决定发送到哪个服务器。

```
客户端SQL请求
       │
   Router分析
       │
  ┌────┴────┐
  │是写操作？│
  └────┬────┘
       │
   ┌───┴───┐
   │  是   │  否
   ▼       ▼
主服务器  从服务器
(写操作)  (读操作)
```

**工作原理**：
- **写操作**（INSERT、UPDATE、DELETE）→ 主服务器
- **读操作**（SELECT）→ 从服务器
- **自动识别**：Router会分析SQL语句，无需应用程序手动指定

**配置示例**：
```ini
[routing:read_write]
bind_address = 0.0.0.0
bind_port = 7001
destinations = mysql-primary:3306,mysql-secondary:3306
routing_strategy = read_write
```

### 2.2 read-only路由配置


**什么是read-only模式？**
这种模式专门处理只读请求，所有连接都会被路由到从服务器（只读服务器）。

> ⚠️ **重要提醒**：在read-only模式下，如果应用程序尝试执行写操作，会收到错误信息。

**适用场景**：
- **报表查询** 📊：生成各种报表，只需要读取数据
- **数据分析** 🔍：进行数据挖掘和分析工作
- **备份验证** 💾：验证备份数据的完整性

**配置示例**：
```ini
[routing:read_only]
bind_address = 0.0.0.0
bind_port = 7002
destinations = mysql-slave1:3306,mysql-slave2:3306
routing_strategy = read_only
```

### 2.3 路由策略对比


| 路由模式 | **适用场景** | **写操作** | **读操作** | **复杂度** |
|---------|------------|-----------|-----------|-----------|
| **read-write** | `常规业务应用` | `主服务器` | `从服务器` | `中等` |
| **read-only** | `只读查询/报表` | `❌ 不支持` | `从服务器` | `简单` |
| **first-available** | `简单负载均衡` | `可用服务器` | `可用服务器` | `简单` |

---

## 3. 🎯 读写路由模式配置


### 3.1 配置文件结构


MySQL Router的配置文件通常是`mysqlrouter.conf`，结构如下：

```
配置文件结构：
┌─────────────────┐
│   [DEFAULT]     │ ← 全局设置
├─────────────────┤
│ [metadata_cache]│ ← 元数据缓存
├─────────────────┤
│   [routing]     │ ← 路由规则
└─────────────────┘
```

### 3.2 读写分离详细配置


**完整配置示例**：
```ini
# 全局配置
[DEFAULT]
logging_folder = /var/log/mysqlrouter
runtime_folder = /var/run/mysqlrouter
config_folder = /etc/mysqlrouter

# 元数据缓存配置
[metadata_cache:myCluster]
router_id = 1
bootstrap_server_addresses = mysql-primary:3306
user = router_user
metadata_cluster = myCluster
ttl = 300

# 读写路由配置
[routing:read_write_split]
bind_address = 0.0.0.0
bind_port = 7001
destinations = metadata-cache://myCluster/default?role=PRIMARY_AND_SECONDARY
routing_strategy = read_write
protocol = classic
```

**配置参数详解**：

- **bind_address** 🔌：Router监听的IP地址
  - `0.0.0.0`：监听所有网络接口
  - `127.0.0.1`：只监听本地接口

- **bind_port** 🚪：Router监听的端口号
  - 通常使用7001-7010范围
  - 避免与MySQL默认端口3306冲突

- **destinations** 🎯：目标服务器列表
  - 可以是具体的服务器地址
  - 也可以从元数据缓存动态获取

### 3.3 读写分离工作流程


```
1. 客户端连接Router
客户端 ──连接──> Router:7001

2. Router解析SQL语句
   ┌─────────────┐
   │ SQL分析器   │
   │"SELECT..."  │ → 读操作
   │"INSERT..."  │ → 写操作
   └─────────────┘

3. 路由到合适的服务器
读操作 → 从服务器 (192.168.1.101:3306)
写操作 → 主服务器 (192.168.1.100:3306)

4. 返回结果给客户端
Router ──结果──> 客户端
```

---

## 4. ⚖️ 负载均衡策略


### 4.1 连接分发算法


**什么是负载均衡？**
简单说就是把大量的数据库连接请求，**均匀地分配**给多台服务器，让每台服务器的工作量保持平衡。

### 4.2 轮询算法（Round Robin）


**工作原理**：像分蛋糕一样，按顺序给每台服务器分配连接。

```
连接分配示例：
连接1 → 服务器A
连接2 → 服务器B  
连接3 → 服务器C
连接4 → 服务器A (重新开始)
连接5 → 服务器B
...
```

**配置示例**：
```ini
[routing:load_balance]
bind_address = 0.0.0.0
bind_port = 7003
destinations = mysql-node1:3306,mysql-node2:3306,mysql-node3:3306
routing_strategy = round-robin
```

**优点**：
- ✅ 分配均匀，每台服务器获得相同数量的连接
- ✅ 实现简单，计算开销小

**缺点**：
- ❌ 不考虑服务器的实际负载情况
- ❌ 不考虑服务器的性能差异

### 4.3 最少连接算法（Least Connections）


**工作原理**：总是把新连接分配给当前连接数最少的服务器。

```
当前连接状态：
服务器A：5个连接  
服务器B：3个连接 ← 新连接优先分配到这里
服务器C：7个连接

下次分配后：
服务器A：5个连接  
服务器B：4个连接
服务器C：7个连接 
```

> 💡 **适用场景**：当服务器性能相近，但连接持续时间差异较大时，这种策略更公平。

### 4.4 负载均衡策略对比


| 策略类型 | **分配原则** | **适用场景** | **计算复杂度** | **推荐指数** |
|---------|------------|-------------|---------------|-------------|
| **轮询** | `按顺序分配` | `服务器性能相同` | `O(1)` | `⭐⭐⭐` |
| **最少连接** | `连接数最少优先` | `连接时长不同` | `O(n)` | `⭐⭐⭐⭐` |
| **加权轮询** | `按权重分配` | `服务器性能不同` | `O(1)` | `⭐⭐⭐⭐⭐` |

---

## 5. 🎛️ 路由规则与目标服务器


### 5.1 路由规则定义


**什么是路由规则？**
路由规则就像是一套"交通规则"，告诉Router在什么情况下，应该把数据库连接引导到哪台服务器。

**规则组成要素**：
```
路由规则 = 匹配条件 + 目标服务器 + 分发策略

例如：
- 匹配条件：读操作
- 目标服务器：从服务器组
- 分发策略：轮询
```

### 5.2 目标服务器配置


**静态配置方式**：
```ini
# 直接指定服务器地址
[routing:static_config]
destinations = 192.168.1.100:3306,192.168.1.101:3306,192.168.1.102:3306
```

**动态配置方式**：
```ini
# 从元数据缓存获取服务器信息
[routing:dynamic_config]
destinations = metadata-cache://myCluster/default?role=SECONDARY
```

**配置方式对比**：

| 配置方式 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|-------------|
| **静态配置** | `简单直接，配置固定` | `需手动维护服务器列表` | `服务器变化不频繁` |
| **动态配置** | `自动发现，动态更新` | `依赖元数据服务` | `集群规模经常变化` |

### 5.3 服务器角色定义


**主服务器（Primary）**：
- **职责** 🔥：处理所有写操作，是数据的"权威来源"
- **特点**：同时可以处理读操作，但优先保证写操作性能

**从服务器（Secondary）**：
- **职责** 📖：主要处理读操作，减轻主服务器压力
- **特点**：数据来自主服务器的复制，可能有轻微延迟

**角色配置示例**：
```ini
# 只路由到主服务器
destinations = metadata-cache://myCluster/default?role=PRIMARY

# 只路由到从服务器  
destinations = metadata-cache://myCluster/default?role=SECONDARY

# 路由到所有服务器
destinations = metadata-cache://myCluster/default?role=PRIMARY_AND_SECONDARY
```

---

## 6. 🔧 高级路由特性


### 6.1 会话粘性设置


**什么是会话粘性？**
会话粘性就是让同一个客户端的所有请求，都固定路由到同一台服务器上，就像"专属服务"一样。

```
会话粘性示例：
客户端A的所有请求 → 始终连接服务器1
客户端B的所有请求 → 始终连接服务器2
客户端C的所有请求 → 始终连接服务器3
```

**为什么需要会话粘性？**
- **事务一致性** 🔒：同一事务的所有SQL必须在同一台服务器执行
- **临时表支持** 📋：临时表只在创建它的连接中可见
- **会话变量** 🔧：SET语句设置的变量需要在同一连接中保持

**配置示例**：
```ini
[routing:sticky_session]
bind_address = 0.0.0.0
bind_port = 7004
destinations = mysql-node1:3306,mysql-node2:3306
routing_strategy = round-robin
mode = read-write
client_ssl_mode = PREFERRED
server_ssl_mode = AS_CLIENT
```

### 6.2 路由权重配置


**什么是路由权重？**
权重就是给不同的服务器分配不同的"工作量"，性能强的服务器分配更多请求，性能弱的分配更少请求。

**权重分配原理**：
```
服务器性能配置：
服务器A：32核CPU，128GB内存 → 权重50
服务器B：16核CPU，64GB内存  → 权重30
服务器C：8核CPU，32GB内存   → 权重20

请求分配比例：
总权重 = 50 + 30 + 20 = 100
服务器A：50% 的请求
服务器B：30% 的请求  
服务器C：20% 的请求
```

> 💡 **实用技巧**：权重设置应该根据服务器的CPU、内存、网络等综合性能来决定，不是简单的线性关系。

### 6.3 连接池管理


**什么是连接池？**
连接池就像一个"连接银行"，提前准备好一些数据库连接，当应用需要时直接"借用"，用完后"归还"，避免频繁建立和关闭连接的开销。

```
连接池工作流程：
┌─────────────────┐
│   应用程序      │
└─────┬───────────┘
      │ 请求连接
┌─────▼───────────┐
│   连接池        │
│ ┌─┐ ┌─┐ ┌─┐ ┌─┐│ ← 预先建立的连接
│ │√│ │√│ │×│ │×││
└─────┬───────────┘
      │ 分配可用连接
┌─────▼───────────┐
│  MySQL服务器    │
└─────────────────┘
```

**连接池配置参数**：
```ini
[routing:connection_pool]
max_connections = 1000        # 最大连接数
max_connect_errors = 100      # 最大连接错误数
connect_timeout = 10          # 连接超时时间（秒）
read_timeout = 30             # 读取超时时间（秒）
```

---

## 7. 🔄 故障转移机制


### 7.1 故障转移规则


**什么是故障转移？**
故障转移就是当某台数据库服务器出现问题时，Router能够自动把请求转移到其他健康的服务器上，保证服务不中断。

**故障检测机制**：
```
健康检查流程：
Router → 定期发送心跳包 → MySQL服务器
         ↓
    收到响应？
         ↓
    ┌────┴────┐
    │  是  │  否  │
    ▼      ▼
   正常    标记故障
          ↓
       触发故障转移
```

### 7.2 故障检测配置


**健康检查参数**：
```ini
[routing:failover]
bind_address = 0.0.0.0
bind_port = 7005
destinations = mysql-primary:3306,mysql-backup:3306
routing_strategy = first-available

# 健康检查设置
connect_timeout = 5           # 连接超时5秒
read_timeout = 10            # 读取超时10秒  
max_connect_errors = 3       # 连续3次错误后标记为故障
```

**故障恢复策略**：
- **自动恢复** 🔄：定期检查故障服务器，恢复后自动加入服务
- **手动恢复** 🔧：需要管理员手动确认服务器状态后恢复服务
- **优雅降级** ⬇️：逐步减少故障服务器的流量，而不是立即停止

### 7.3 故障转移场景


**主服务器故障**：
```
故障前：
应用 → Router → 主服务器 (写操作)
                ↓
              从服务器 (读操作)

故障后：
应用 → Router → 新主服务器 (提升的从服务器)
                ↓  
              其他从服务器 (读操作)
```

**从服务器故障**：
```
故障前：读请求平均分配到3台从服务器
从服务器1 ← 33%
从服务器2 ← 33%  
从服务器3 ← 33%

故障后：读请求重新分配到剩余服务器
从服务器1 ← 50%
从服务器2 ← 50%
从服务器3 ← 故障，停止服务
```

> ⚠️ **注意事项**：故障转移虽然能保证服务连续性，但可能会导致短暂的性能下降，需要合理规划服务器容量。

---

## 8. 🛠️ 实战配置示例


### 8.1 完整生产环境配置


**场景描述**：一个电商网站，有1台主数据库服务器和2台从数据库服务器，需要实现读写分离和负载均衡。

```ini
# /etc/mysqlrouter/mysqlrouter.conf

[DEFAULT]
# 基础设置
logging_folder = /var/log/mysqlrouter
runtime_folder = /var/run/mysqlrouter
config_folder = /etc/mysqlrouter
plugin_folder = /usr/lib64/mysqlrouter
level = INFO

# 元数据缓存配置
[metadata_cache:ecommerce_cluster]
router_id = 1
bootstrap_server_addresses = mysql-master:3306,mysql-slave1:3306,mysql-slave2:3306
user = router_meta_user
metadata_cluster = ecommerce_cluster
ttl = 300
auth_cache_ttl = 3600
auth_cache_refresh_interval = 600

# 读写混合路由 - 应用主入口
[routing:read_write]
bind_address = 0.0.0.0
bind_port = 7001
destinations = metadata-cache://ecommerce_cluster/default?role=PRIMARY_AND_SECONDARY
routing_strategy = read_write
protocol = classic
max_connections = 500
max_connect_errors = 100
connect_timeout = 10
read_timeout = 30

# 只读路由 - 报表和分析
[routing:read_only] 
bind_address = 0.0.0.0
bind_port = 7002
destinations = metadata-cache://ecommerce_cluster/default?role=SECONDARY
routing_strategy = round-robin
protocol = classic
max_connections = 200
max_connect_errors = 50
connect_timeout = 5
read_timeout = 60

# 管理员专用路由 - 直连主库
[routing:admin_access]
bind_address = 127.0.0.1
bind_port = 7003
destinations = metadata-cache://ecommerce_cluster/default?role=PRIMARY
routing_strategy = first-available
protocol = classic
max_connections = 10
```

### 8.2 应用程序连接示例


**Java应用连接配置**：
```java
// 主要业务连接 - 读写混合
String readWriteUrl = "jdbc:mysql://mysql-router:7001/ecommerce" +
    "?useUnicode=true&characterEncoding=utf8" +
    "&autoReconnect=true&failOverReadOnly=false";

// 报表查询连接 - 只读
String readOnlyUrl = "jdbc:mysql://mysql-router:7002/ecommerce" +
    "?useUnicode=true&characterEncoding=utf8" +
    "&autoReconnect=true";

// 数据源配置
HikariConfig config = new HikariConfig();
config.setJdbcUrl(readWriteUrl);
config.setUsername("app_user");
config.setPassword("app_password");
config.setMaximumPoolSize(20);
config.setMinimumIdle(5);
config.setConnectionTimeout(30000);
config.setIdleTimeout(600000);
```

**PHP应用连接示例**：
```php
// 主要业务连接
$readWritePdo = new PDO(
    'mysql:host=mysql-router;port=7001;dbname=ecommerce;charset=utf8mb4',
    'app_user',
    'app_password',
    [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES utf8mb4"
    ]
);

// 只读查询连接
$readOnlyPdo = new PDO(
    'mysql:host=mysql-router;port=7002;dbname=ecommerce;charset=utf8mb4', 
    'app_user',
    'app_password'
);
```

### 8.3 监控和维护脚本


**健康检查脚本**：
```bash
#!/bin/bash
# router_health_check.sh

ROUTER_HOST="localhost"
ROUTER_PORTS=(7001 7002 7003)

echo "MySQL Router健康检查 - $(date)"
echo "================================"

for port in "${ROUTER_PORTS[@]}"; do
    echo -n "检查端口 $port: "
    
    if mysqladmin ping -h $ROUTER_HOST -P $port -u health_check_user --silent 2>/dev/null; then
        echo "✅ 正常"
    else
        echo "❌ 异常"
        # 发送告警通知
        echo "Router端口 $port 检查失败" | mail -s "MySQL Router告警" admin@company.com
    fi
done

echo "================================"
```

**配置重载脚本**：
```bash
#!/bin/bash
# reload_router_config.sh

ROUTER_PID_FILE="/var/run/mysqlrouter/mysqlrouter.pid"

if [ -f "$ROUTER_PID_FILE" ]; then
    PID=$(cat $ROUTER_PID_FILE)
    echo "重载MySQL Router配置..."
    kill -HUP $PID
    
    if [ $? -eq 0 ]; then
        echo "✅ 配置重载成功"
    else
        echo "❌ 配置重载失败"
        exit 1
    fi
else
    echo "❌ MySQL Router未运行"
    exit 1
fi
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 MySQL Router：数据库连接的智能路由中间件
🔸 路由策略：read-write(读写分离)、read-only(只读)、round-robin(轮询)
🔸 负载均衡：均匀分配连接，提升系统整体性能
🔸 故障转移：自动切换到健康服务器，保证服务连续性
🔸 会话粘性：同一客户端固定连接到同一服务器
```

### 9.2 关键配置要点


**🔹 路由策略选择原则**
```
业务场景 → 选择策略：
- 常规Web应用 → read-write (读写分离)
- 数据分析报表 → read-only (只读路由)  
- 简单负载均衡 → round-robin (轮询)
- 高可用需求 → first-available (故障转移)
```

**🔹 性能优化建议**
```
连接池设置：
- max_connections：根据服务器性能设置，避免过载
- connect_timeout：网络环境差时适当增加
- read_timeout：长查询场景需要调大

权重配置：
- 根据服务器CPU、内存、网络综合考虑
- 定期监控调整，避免负载不均
```

**🔹 高可用配置**
```
故障检测：
- 设置合理的超时时间
- 配置多重检查机制
- 建立告警通知机制

故障恢复：
- 自动恢复 vs 手动恢复
- 灰度恢复，逐步增加流量
- 定期演练故障切换流程
```

### 9.3 实际应用价值


**🎯 业务场景应用**
- **电商网站**：读写分离，商品查询走从库，订单处理走主库
- **内容管理**：文章展示走只读路由，内容编辑走读写路由  
- **数据分析**：报表查询专用只读连接，避免影响业务
- **移动应用**：根据功能模块分配不同路由策略

**🔧 运维实践**
- **容量规划**：根据业务增长预估连接数和服务器需求
- **性能监控**：监控各路由的连接数、响应时间、错误率
- **故障演练**：定期进行故障切换演练，验证高可用配置
- **配置管理**：建立配置版本管理，支持快速回滚

### 9.4 常见问题解决


**❓ 连接数过多怎么办？**
```
解决方案：
1. 调整max_connections参数
2. 优化应用连接池配置  
3. 增加Router实例数量
4. 升级服务器硬件配置
```

**❓ 读写分离不生效？**
```
检查项目：
1. SQL语句是否被正确识别
2. 事务中的读操作会路由到主库
3. 客户端是否支持读写分离
4. Router配置是否正确加载
```

**❓ 故障转移延迟太长？**
```
优化措施：
1. 减少connect_timeout时间
2. 减少max_connect_errors阈值
3. 增加健康检查频率
4. 优化网络连接质量
```

**核心记忆**：
- Router是连接的"智能交通指挥员"
- 读写分离让主从各司其职，性能更优
- 负载均衡让服务器"团队合作"不过载  
- 故障转移是"保险机制"，确保服务不中断
- 合理配置是关键，监控维护保稳定