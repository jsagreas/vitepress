---
title: 9、慢查询统计分析方法
---
## 📚 目录

1. [慢查询统计基础概念](#1-慢查询统计基础概念)
2. [查询频率统计分析](#2-查询频率统计分析)
3. [执行时间分布统计](#3-执行时间分布统计)
4. [影响行数统计分析](#4-影响行数统计分析)
5. [查询类型分类统计](#5-查询类型分类统计)
6. [时间段分布分析](#6-时间段分布分析)
7. [用户维度统计](#7-用户维度统计)
8. [数据库维度统计](#8-数据库维度统计)
9. [TOP查询识别方法](#9-TOP查询识别方法)
10. [趋势变化分析](#10-趋势变化分析)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 📊 慢查询统计基础概念


### 1.1 什么是慢查询统计分析


**定义**：慢查询统计分析是对MySQL慢查询日志进行数据挖掘和统计计算，找出系统中的性能瓶颈和优化方向。

> 💡 **通俗理解**：就像医生给病人做体检，通过各种指标数据分析身体健康状况，慢查询统计就是给数据库做"体检"，找出哪里有问题。

### 1.2 为什么需要统计分析


**核心价值**：
- **问题定位** - 快速找到最影响性能的查询
- **优化决策** - 基于数据决定优化优先级
- **趋势监控** - 发现性能变化趋势
- **容量规划** - 预测未来性能需求

### 1.3 分析维度框架


```
慢查询分析的九大维度：

频率维度 ──┐
时间维度 ──┤
影响维度 ──┤── 核心统计指标
类型维度 ──┤
用户维度 ──┤
库表维度 ──┘

时段维度 ──┐
TOP维度 ──┤── 深度分析方法
趋势维度 ──┘
```

---

## 2. 📈 查询频率统计分析


### 2.1 频率统计的含义


**什么是查询频率**：指定时间内某个查询模式出现的次数。

> 📖 **概念解释**：比如 `SELECT * FROM users WHERE id = ?` 这个查询模式，在一小时内执行了500次，频率就是500次/小时。

### 2.2 频率统计方法


**基础统计命令**：
```bash
# 使用mysqldumpslow统计查询频率
mysqldumpslow -s c -t 10 /var/log/mysql/slow.log

# 参数说明：
# -s c : 按照查询次数(count)排序
# -t 10: 显示前10个结果
```

**高级分析工具**：
```bash
# 使用pt-query-digest进行详细分析
pt-query-digest --limit=20 --order-by Query_time:cnt /var/log/mysql/slow.log
```

### 2.3 频率分析重点


**关注指标**：

| 指标名称 | 含义 | 分析价值 |
|---------|------|---------|
| **查询次数** | `总执行次数` | `找出高频查询` |
| **查询占比** | `该查询次数/总查询次数` | `评估影响范围` |
| **平均间隔** | `统计时间/查询次数` | `了解查询密度` |

> ⚠️ **重要提醒**：频率高的查询不一定是最需要优化的，还要结合执行时间和影响行数综合判断。

### 2.4 频率异常识别


**异常模式识别**：
```
正常模式：查询频率相对稳定
异常模式：
├── 突发高频 → 可能是业务异常或攻击
├── 周期性峰值 → 定时任务或业务高峰
└── 持续增长 → 业务增长或程序bug
```

---

## 3. ⏱️ 执行时间分布统计


### 3.1 时间分布的重要性


**为什么要分析时间分布**：不同的查询有不同的时间特征，了解分布规律有助于制定优化策略。

> 🔍 **实际意义**：有些查询偶尔很慢，有些查询始终很慢，优化方法完全不同。

### 3.2 时间分布统计指标


**核心时间指标**：

```
时间分布统计维度：

最小值(Min) ──┐
最大值(Max) ──┤
平均值(Avg) ──┤── 基础统计
中位数(50%) ──┤
95分位数 ────┤
99分位数 ────┘── 高级统计
```

### 3.3 时间分布分析方法


**使用pt-query-digest分析**：
```bash
# 生成详细的时间分布报告
pt-query-digest --limit=10 --order-by Query_time:sum slow.log

# 关注输出中的关键信息：
# Query_time distribution:
#   1us-10us   : ######## (25%)
#   10us-100us : ############ (35%)  
#   100us-1ms  : ############ (35%)
#   1ms-10ms   : ## (5%)
```

**自定义时间区间统计**：
```sql
-- 分析慢查询日志表中的时间分布
SELECT 
  CASE 
    WHEN query_time < 1 THEN '0-1秒'
    WHEN query_time < 5 THEN '1-5秒'
    WHEN query_time < 10 THEN '5-10秒'
    ELSE '10秒以上'
  END AS time_range,
  COUNT(*) as query_count,
  ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM mysql.slow_log), 2) as percentage
FROM mysql.slow_log 
GROUP BY time_range
ORDER BY MIN(query_time);
```

### 3.4 时间分布异常模式


**典型分布模式**：
```
健康模式：大部分查询集中在较短时间区间
问题模式：
├── 双峰分布 → 可能有两类不同性能的查询
├── 长尾分布 → 存在极慢查询拖累整体性能
└── 平均分布 → 查询性能不稳定，需要深入分析
```

---

## 4. 📋 影响行数统计分析


### 4.1 影响行数的含义


**什么是影响行数**：查询处理的数据行数，包括扫描行数和返回行数。

> 💡 **通俗解释**：就像在图书馆找书，影响行数告诉我们翻了多少本书(扫描)，找到了多少本目标书(返回)。

### 4.2 影响行数统计指标


**关键指标说明**：

| 指标 | 英文名 | 含义 | 性能影响 |
|------|--------|------|----------|
| **扫描行数** | `Rows_examined` | `查询过程中检查的行数` | `扫描越多越慢` |
| **返回行数** | `Rows_sent` | `返回给客户端的行数` | `返回越多网络开销越大` |
| **影响行数** | `Rows_affected` | `DML操作影响的行数` | `影响越多锁定时间越长` |

### 4.3 行数分析方法


**效率比分析**：
```sql
-- 计算查询效率比
SELECT 
  sql_text,
  avg_rows_examined,
  avg_rows_sent,
  ROUND(avg_rows_sent / avg_rows_examined * 100, 2) as efficiency_ratio
FROM 
  (SELECT 
     LEFT(sql_text, 100) as sql_text,
     AVG(rows_examined) as avg_rows_examined,
     AVG(rows_sent) as avg_rows_sent
   FROM mysql.slow_log 
   GROUP BY LEFT(sql_text, 100)
  ) t
WHERE avg_rows_examined > 0
ORDER BY efficiency_ratio ASC;
```

> 📊 **效率比解读**：
> - **比例很低(< 1%)**：可能存在索引问题
> - **比例适中(1-20%)**：查询相对合理  
> - **比例很高(> 50%)**：可能查询条件过宽

### 4.4 行数异常模式识别


**异常行数模式**：
```
扫描行数异常：
├── 全表扫描 → rows_examined 接近表总行数
├── 索引失效 → 扫描行数远大于预期
└── 条件过宽 → WHERE条件匹配太多行

返回行数异常：
├── 大结果集 → rows_sent 过大影响网络
├── 无效查询 → rows_sent = 0 但扫描很多行
└── 分页异常 → LIMIT使用不当
```

---

## 5. 🔍 查询类型分类统计


### 5.1 查询类型分类意义


**为什么要分类**：不同类型的查询有不同的性能特点和优化方法。

> 🎯 **实际应用**：SELECT查询关注索引优化，UPDATE关注锁冲突，INSERT关注批量操作等。

### 5.2 主要查询类型


**SQL语句分类**：
```
查询类型分类体系：

读操作 ──┐
        ├── SELECT    → 数据查询
        ├── SELECT COUNT → 统计查询
        └── SELECT DISTINCT → 去重查询

写操作 ──┐
        ├── INSERT    → 数据插入
        ├── UPDATE    → 数据更新
        ├── DELETE    → 数据删除
        └── REPLACE   → 替换插入

DDL操作 ─┐
        ├── CREATE    → 创建对象
        ├── ALTER     → 修改结构
        └── DROP      → 删除对象
```

### 5.3 类型统计方法


**使用正则表达式分类**：
```bash
# 统计不同类型查询的数量
awk '{
  if (/^# Time:/) time = $3 " " $4
  if (/^SELECT/) select_count++
  if (/^INSERT/) insert_count++
  if (/^UPDATE/) update_count++
  if (/^DELETE/) delete_count++
} END {
  print "SELECT:", select_count
  print "INSERT:", insert_count  
  print "UPDATE:", update_count
  print "DELETE:", delete_count
}' /var/log/mysql/slow.log
```

**SQL模式识别**：
```sql
-- 从慢查询日志表中统计类型分布
SELECT 
  CASE 
    WHEN sql_text REGEXP '^SELECT.*COUNT\\(' THEN 'COUNT查询'
    WHEN sql_text REGEXP '^SELECT' THEN 'SELECT查询'
    WHEN sql_text REGEXP '^INSERT' THEN 'INSERT操作'
    WHEN sql_text REGEXP '^UPDATE' THEN 'UPDATE操作'
    WHEN sql_text REGEXP '^DELETE' THEN 'DELETE操作'
    ELSE '其他操作'
  END as query_type,
  COUNT(*) as count,
  AVG(query_time) as avg_time,
  AVG(rows_examined) as avg_rows
FROM mysql.slow_log 
GROUP BY query_type
ORDER BY count DESC;
```

### 5.4 类型特征分析


**各类型性能特征**：

| 查询类型 | 性能特点 | 优化重点 | 常见问题 |
|---------|----------|----------|----------|
| **SELECT** | `读操作，并发度高` | `索引优化` | `全表扫描` |
| **INSERT** | `写操作，锁竞争` | `批量插入` | `自增锁冲突` |
| **UPDATE** | `读写操作，锁时间长` | `索引+锁优化` | `范围锁过大` |
| **DELETE** | `写操作，可能影响大量行` | `分批删除` | `锁等待` |

---

## 6. 🕐 时间段分布分析


### 6.1 时间段分析的价值


**为什么分析时间段**：数据库负载在不同时间段有明显差异，了解规律有助于容量规划和问题定位。

> 📅 **业务场景**：电商系统晚上8-10点是高峰期，银行系统上午9-11点交易集中，不同业务有不同的时间特征。

### 6.2 时间段统计维度


**分析时间粒度**：
```
时间分析层次：

小时级别 ──┐
         ├── 0-23点分布 → 发现业务高峰期
         └── 工作/非工作时间对比

日期级别 ──┐  
         ├── 周一到周日分布 → 发现周期规律
         └── 工作日/节假日对比

月度级别 ──┐
         ├── 月度趋势变化 → 长期趋势分析
         └── 季度业务周期
```

### 6.3 时间段统计实现


**按小时统计**：
```sql
-- 分析各小时慢查询分布
SELECT 
  HOUR(start_time) as hour,
  COUNT(*) as slow_query_count,
  AVG(query_time) as avg_query_time,
  SUM(query_time) as total_time
FROM mysql.slow_log 
WHERE start_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY HOUR(start_time)
ORDER BY hour;
```

**按星期统计**：
```sql
-- 分析各星期的慢查询模式
SELECT 
  DAYNAME(start_time) as day_name,
  DAYOFWEEK(start_time) as day_num,
  COUNT(*) as count,
  AVG(query_time) as avg_time
FROM mysql.slow_log 
GROUP BY DAYOFWEEK(start_time), DAYNAME(start_time)
ORDER BY day_num;
```

### 6.4 时间分布可视化


**时间热力图概念**：
```
小时级热力图示例：
时间段    查询数量    可视化表示
00-01    ██░░░░░░░░ (20)    
01-02    █░░░░░░░░░ (10)    
...
08-09    ██████████ (100)   ← 业务高峰
09-10    ████████░░ (80)    
...
20-21    ████████████ (120) ← 晚高峰
21-22    ██████████░░ (110)
22-23    ████░░░░░░ (40)
23-24    ██░░░░░░░░ (20)
```

> 💡 **分析要点**：通过热力图可以直观看出业务高峰期，合理安排维护时间和资源分配。

---

## 7. 👤 用户维度统计


### 7.1 用户维度分析意义


**为什么要按用户分析**：不同用户或应用可能有不同的查询模式，便于问题定位和资源管理。

> 🎯 **实际场景**：可能某个应用模块有BUG导致大量慢查询，或者某个用户的操作习惯导致性能问题。

### 7.2 用户分析维度


**用户识别方式**：
```
用户识别层次：

数据库用户 ──┐
           ├── root, app_user, readonly_user
           └── 按权限级别分类

连接来源 ────┐
           ├── 应用服务器IP
           ├── 内网/外网访问
           └── 不同业务模块

应用标识 ────┐
           ├── 应用名称(通过连接参数)
           └── 业务模块标识
```

### 7.3 用户维度统计方法


**基础用户统计**：
```sql
-- 按用户统计慢查询情况
SELECT 
  user_host,
  COUNT(*) as query_count,
  AVG(query_time) as avg_time,
  MAX(query_time) as max_time,
  SUM(rows_examined) as total_rows_examined
FROM mysql.slow_log 
WHERE start_time >= DATE_SUB(NOW(), INTERVAL 1 DAY)
GROUP BY user_host
ORDER BY query_count DESC;
```

**用户行为模式分析**：
```sql
-- 分析用户的查询类型分布
SELECT 
  user_host,
  CASE 
    WHEN sql_text REGEXP '^SELECT' THEN 'SELECT'
    WHEN sql_text REGEXP '^INSERT' THEN 'INSERT'
    WHEN sql_text REGEXP '^UPDATE' THEN 'UPDATE'
    WHEN sql_text REGEXP '^DELETE' THEN 'DELETE'
    ELSE 'OTHER'
  END as operation_type,
  COUNT(*) as count
FROM mysql.slow_log 
GROUP BY user_host, operation_type
ORDER BY user_host, count DESC;
```

### 7.4 用户异常检测


**异常用户模式**：
```
用户异常识别：

查询频率异常 ─┐
            ├── 某用户查询次数远超正常
            └── 短时间内大量相同查询

查询模式异常 ─┐
            ├── 用户执行了不该有的权限操作
            ├── 查询复杂度远超平均水平
            └── 异常时间段的查询行为

资源消耗异常 ─┐
            ├── 某用户消耗了过多CPU/IO资源
            └── 单个用户影响整体性能
```

> ⚠️ **安全提醒**：用户异常也可能是安全问题，比如SQL注入攻击或账号被盗用。

---

## 8. 🗄️ 数据库维度统计


### 8.1 数据库维度的重要性


**为什么要按数据库分析**：多数据库环境下，不同业务库可能有不同的性能特征。

> 📊 **实际应用**：电商系统可能有用户库、商品库、订单库等，每个库的查询特点和性能要求都不同。

### 8.2 数据库分析维度


**分析层次结构**：
```
数据库分析层次：

库级别分析 ──┐
           ├── 各数据库的查询分布
           ├── 不同库的性能对比
           └── 库级别的资源消耗

表级别分析 ──┐
           ├── 各表的访问频率
           ├── 表级别的慢查询集中度
           └── 大表vs小表的性能差异

字段级别 ────┐
           ├── 常用查询字段统计
           └── 索引覆盖情况分析
```

### 8.3 数据库维度统计实现


**库级别统计**：
```sql
-- 按数据库统计慢查询分布
SELECT 
  db as database_name,
  COUNT(*) as slow_query_count,
  AVG(query_time) as avg_query_time,
  SUM(query_time) as total_query_time,
  AVG(rows_examined) as avg_rows_examined
FROM mysql.slow_log 
WHERE start_time >= DATE_SUB(NOW(), INTERVAL 7 DAY)
  AND db IS NOT NULL
GROUP BY db
ORDER BY slow_query_count DESC;
```

**表级别统计**：
```bash
# 使用pt-query-digest按表分析
pt-query-digest --group-by tables --limit 10 slow.log
```

### 8.4 数据库性能对比


**性能指标对比**：

| 数据库 | 慢查询数量 | 平均执行时间 | 总耗时占比 | 主要问题 |
|--------|------------|--------------|------------|----------|
| **user_db** | `1,250` | `2.3秒` | `35%` | `用户查询索引不足` |
| **order_db** | `890` | `1.8秒` | `28%` | `订单统计查询复杂` |
| **product_db** | `420` | `0.9秒` | `12%` | `商品搜索待优化` |
| **log_db** | `2,100` | `0.5秒` | `25%` | `日志表数据量大` |

> 💡 **分析重点**：通过对比可以发现哪个业务库是性能瓶颈，优先优化影响最大的库。

---

## 9. 🏆 TOP查询识别方法


### 9.1 TOP查询的定义


**什么是TOP查询**：在各种统计维度中排名靠前的查询，通常是最需要优化的对象。

> 🎯 **优化原则**：80%的性能问题往往来自20%的查询，找到这20%的TOP查询是优化的关键。

### 9.2 TOP查询识别维度


**多维度TOP识别**：
```
TOP查询识别矩阵：

按总耗时排序 ──┐
            ├── 单次最慢查询
            ├── 累计耗时最多查询
            └── 平均耗时最高查询

按影响范围 ────┐
            ├── 扫描行数最多
            ├── 影响行数最多  
            └── 查询频率最高

按资源消耗 ────┐
            ├── CPU消耗最高
            ├── IO操作最多
            └── 内存使用最大
```

### 9.3 TOP查询统计命令


**使用mysqldumpslow**：
```bash
# 按总查询时间排序
mysqldumpslow -s t -t 10 slow.log

# 按平均查询时间排序  
mysqldumpslow -s at -t 10 slow.log

# 按查询次数排序
mysqldumpslow -s c -t 10 slow.log

# 按锁定时间排序
mysqldumpslow -s l -t 10 slow.log
```

**使用pt-query-digest**：
```bash
# 综合分析TOP查询
pt-query-digest --limit=20 --order-by Query_time:sum slow.log

# 按不同维度排序
pt-query-digest --order-by Rows_examined:sum --limit=10 slow.log
```

### 9.4 TOP查询评分机制


**综合评分公式**：
```
查询影响度评分 = 
  (总耗时权重 × 总耗时得分) +
  (频率权重 × 查询频率得分) + 
  (扫描行权重 × 扫描行数得分)

权重分配示例：
├── 总耗时权重: 40%
├── 查询频率权重: 35%  
└── 扫描行数权重: 25%
```

**实际评分实现**：
```sql
-- 计算查询综合影响度评分
SELECT 
  LEFT(sql_text, 100) as query_pattern,
  COUNT(*) as frequency,
  SUM(query_time) as total_time,
  AVG(query_time) as avg_time,
  SUM(rows_examined) as total_rows,
  -- 综合评分计算
  (SUM(query_time) * 0.4 + 
   COUNT(*) * 0.35 + 
   SUM(rows_examined) / 10000 * 0.25) as impact_score
FROM mysql.slow_log 
GROUP BY LEFT(sql_text, 100)
ORDER BY impact_score DESC
LIMIT 20;
```

---

## 10. 📈 趋势变化分析


### 10.1 趋势分析的价值


**为什么要分析趋势**：通过历史数据变化，预测未来性能走向，提前进行容量规划和问题预防。

> 💡 **预防性维护**：就像监测病人的生命体征变化，数据库性能趋势能帮我们在问题严重之前采取行动。

### 10.2 趋势分析维度


**时间序列分析**：
```
趋势分析时间线：

短期趋势(1-7天) ──┐
                ├── 发现突发性能问题
                └── 监控日常波动

中期趋势(1-3个月) ─┐
                ├── 识别性能退化模式
                └── 评估优化效果

长期趋势(3-12个月) ┐
                ├── 容量规划参考
                └── 业务增长影响评估
```

### 10.3 趋势统计实现


**日级趋势统计**：
```sql
-- 按日统计慢查询趋势
SELECT 
  DATE(start_time) as query_date,
  COUNT(*) as daily_slow_queries,
  AVG(query_time) as avg_query_time,
  MAX(query_time) as max_query_time,
  SUM(query_time) as total_query_time
FROM mysql.slow_log 
WHERE start_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(start_time)
ORDER BY query_date;
```

**移动平均趋势**：
```sql
-- 计算7天移动平均
SELECT 
  query_date,
  daily_slow_queries,
  AVG(daily_slow_queries) OVER (
    ORDER BY query_date 
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as ma7_slow_queries
FROM (
  SELECT 
    DATE(start_time) as query_date,
    COUNT(*) as daily_slow_queries
  FROM mysql.slow_log 
  GROUP BY DATE(start_time)
) daily_stats
ORDER BY query_date;
```

### 10.4 趋势异常检测


**异常模式识别**：
```
趋势异常类型：

突增模式 ──┐
         ├── 慢查询数量突然增加 → 可能是新功能上线
         └── 执行时间突然延长 → 可能是数据量增长

突降模式 ──┐
         ├── 慢查询突然减少 → 可能是优化生效
         └── 系统负载突然下降 → 需要检查业务是否正常

周期模式 ──┐
         ├── 规律性的性能波动 → 正常业务周期
         └── 异常的周期变化 → 需要深入分析

趋势模式 ──┐
         ├── 持续恶化趋势 → 需要紧急优化
         └── 持续改善趋势 → 优化措施有效
```

### 10.5 趋势预测方法


**简单线性预测**：
```sql
-- 计算趋势斜率进行简单预测
SELECT 
  -- 使用最小二乘法计算趋势线斜率
  (COUNT(*) * SUM(day_num * slow_count) - SUM(day_num) * SUM(slow_count)) /
  (COUNT(*) * SUM(day_num * day_num) - SUM(day_num) * SUM(day_num)) as trend_slope,
  
  -- 预测未来7天的慢查询数量
  AVG(slow_count) + 
  ((COUNT(*) * SUM(day_num * slow_count) - SUM(day_num) * SUM(slow_count)) /
   (COUNT(*) * SUM(day_num * day_num) - SUM(day_num) * SUM(day_num))) * 7 
   as predicted_7day_count
FROM (
  SELECT 
    DATEDIFF(DATE(start_time), DATE_SUB(CURDATE(), INTERVAL 30 DAY)) as day_num,
    COUNT(*) as slow_count
  FROM mysql.slow_log 
  WHERE start_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
  GROUP BY DATE(start_time)
) trend_data;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 统计分析本质：通过数据挖掘找出性能瓶颈和优化方向
🔸 九大分析维度：频率、时间、影响、类型、时段、用户、数据库、TOP、趋势
🔸 关键性能指标：查询频率、执行时间、影响行数、扫描效率
🔸 异常模式识别：突发异常、持续恶化、周期性问题
🔸 优化决策依据：基于统计数据制定优化优先级
```

### 11.2 关键理解要点


**🔹 统计分析的价值链**：
```
数据收集 → 统计分析 → 问题识别 → 优化决策 → 效果验证 → 持续改进
```

**🔹 多维度分析的重要性**：
```
单一维度分析：可能遗漏重要信息
多维度综合分析：全面了解性能状况
交叉分析：发现隐藏的关联关系
```

**🔹 TOP查询的识别原则**：
```
不仅看单次执行时间：还要看总体影响
不仅看查询频率：还要看资源消耗
不仅看当前状态：还要看变化趋势
```

### 11.3 实际应用指导


**📊 分析工具选择**：
- **mysqldumpslow**：简单快速的基础分析
- **pt-query-digest**：专业详细的深度分析  
- **自定义SQL**：特定场景的灵活分析

**🎯 优化优先级判断**：
```
优先级 = 影响范围 × 问题严重程度 × 解决难易程度

高优先级：影响大 + 问题严重 + 容易解决
中优先级：部分条件满足
低优先级：影响小 + 问题轻微 + 解决复杂
```

**📈 持续监控建议**：
```
日常监控：
├── 每日TOP 10慢查询
├── 异常趋势告警
└── 关键指标变化

定期分析：
├── 周度性能报告
├── 月度趋势分析
└── 季度容量规划
```

### 11.4 常见误区避免


> ⚠️ **分析误区**：
> - **只看执行时间**：忽略查询频率和影响范围
> - **只关注TOP查询**：忽略整体性能趋势
> - **缺乏持续性**：一次性分析缺乏跟踪
> - **孤立分析**：不结合业务场景理解数据

> 💡 **最佳实践**：
> - **多维度综合分析**：全面评估性能状况
> - **结合业务理解**：技术分析要结合业务需求
> - **持续跟踪监控**：建立长期性能管理机制
> - **数据驱动决策**：基于统计数据制定优化策略

**核心记忆**：
- 慢查询统计是性能优化的数据基础
- 多维度分析比单一指标更准确  
- TOP查询识别要综合多个因素
- 趋势分析帮助预防性维护
- 统计分析要持续进行才有价值