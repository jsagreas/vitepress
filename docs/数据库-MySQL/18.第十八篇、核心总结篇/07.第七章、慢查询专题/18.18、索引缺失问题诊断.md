---
title: 18、索引缺失问题诊断
---
## 📚 目录

1. [索引缺失问题概述](#1-索引缺失问题概述)
2. [WHERE条件索引检查](#2-WHERE条件索引检查)
3. [JOIN关联字段索引诊断](#3-JOIN关联字段索引诊断)
4. [ORDER BY排序索引分析](#4-ORDER-BY排序索引分析)
5. [GROUP BY分组索引优化](#5-GROUP-BY分组索引优化)
6. [复合索引使用分析](#6-复合索引使用分析)
7. [索引覆盖度与选择性](#7-索引覆盖度与选择性)
8. [冗余索引识别清理](#8-冗余索引识别清理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 索引缺失问题概述


### 1.1 什么是索引缺失问题


**简单理解**：索引缺失就像图书馆没有目录，找书要翻遍所有书架

```
无索引查询过程：
用户表(100万条记录)
     ↓
WHERE age = 25
     ↓
┌─────────────────────────────────┐
│ 逐行扫描检查：                   │
│ 第1行：age=30 ✗                │
│ 第2行：age=25 ✓ 找到了！        │
│ 第3行：age=28 ✗                │
│ ...继续扫描到最后一行...         │
└─────────────────────────────────┘
平均需要扫描 50万行才能找到目标记录

有索引查询过程：
age索引(B+树结构)
     ↓
WHERE age = 25
     ↓
┌─────────────────────────────────┐
│ 索引树查找：                     │
│ 根节点 → 内部节点 → 叶子节点      │
│ 3次磁盘读取直接定位到目标记录     │
└─────────────────────────────────┘
只需要扫描 3-4 个页面就能找到记录
```

### 1.2 索引缺失的典型症状


**🔸 性能症状识别**
- ⏰ **查询响应慢**：原本毫秒级变成秒级
- 📊 **CPU使用率高**：大量计算资源用于条件判断
- 💾 **IO负载重**：频繁的全表扫描
- 🔄 **并发能力差**：慢查询阻塞其他操作

**🔸 执行计划特征**
```sql
-- 典型的缺失索引执行计划
EXPLAIN SELECT * FROM users WHERE age = 25;

+----+-------+-------+------+---------+------+------+
| id | type  | table | key  | key_len | ref  | rows |
+----+-------+-------+------+---------+------+------+
|  1 | ALL   | users | NULL |    NULL | NULL | 985k |
+----+-------+-------+------+---------+------+------+

关键指标分析：
├─ type = ALL：全表扫描，最差的访问类型
├─ key = NULL：没有使用任何索引
├─ rows = 985k：需要扫描98.5万行
└─ Extra：Using where（在存储引擎层过滤）
```

### 1.3 缺失索引识别方法


**🔧 系统层面识别**
```sql
-- 查看慢查询日志
SHOW VARIABLES LIKE 'slow_query_log%';
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;

-- 分析慢查询
SELECT 
    query_time,
    lock_time,
    rows_examined,
    sql_text
FROM mysql.slow_log 
WHERE rows_examined > 10000;
```

**📊 性能监控识别**
```sql
-- 检查表扫描统计
SHOW GLOBAL STATUS LIKE 'Handler_read%';

重要指标：
├─ Handler_read_first：索引第一个条目读取次数
├─ Handler_read_next：索引下一个条目读取次数  
├─ Handler_read_rnd：随机位置读取次数
└─ Handler_read_rnd_next：数据文件顺序读取次数(全表扫描)

如果 Handler_read_rnd_next 很大，说明有大量全表扫描
```

---

## 2. 🔍 WHERE条件索引检查


### 2.1 单列条件索引诊断


**基础WHERE条件分析**
```sql
-- 问题查询：缺少age字段索引
SELECT * FROM users WHERE age = 25;

-- 执行计划分析
EXPLAIN SELECT * FROM users WHERE age = 25;

诊断步骤：
1️⃣ 检查当前索引：SHOW INDEX FROM users;
2️⃣ 分析执行计划：type=ALL表示全表扫描
3️⃣ 查看扫描行数：rows字段显示扫描的行数
4️⃣ 检查过滤方式：Extra字段的Using where
```

**常见WHERE条件类型**
```sql
-- 等值查询（最需要索引）
SELECT * FROM users WHERE user_id = 12345;
-- 建议：CREATE INDEX idx_user_id ON users(user_id);

-- 范围查询
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
-- 建议：CREATE INDEX idx_age ON users(age);

-- 模糊查询（注意前缀匹配）
SELECT * FROM users WHERE name LIKE 'Zhang%';  -- 可以用索引
SELECT * FROM users WHERE name LIKE '%Zhang'; -- 无法用索引
-- 建议：CREATE INDEX idx_name ON users(name);

-- 日期范围查询
SELECT * FROM orders WHERE created_at >= '2024-01-01';
-- 建议：CREATE INDEX idx_created_at ON orders(created_at);
```

### 2.2 多条件WHERE子句分析


**AND条件组合**
```sql
-- 多个AND条件
SELECT * FROM users 
WHERE age = 25 AND city = 'Beijing' AND status = 'active';

索引策略选择：
方案1：单列索引
├─ CREATE INDEX idx_age ON users(age);
├─ CREATE INDEX idx_city ON users(city);  
└─ CREATE INDEX idx_status ON users(status);
问题：MySQL只能选择其中一个索引，其他条件仍需要全表过滤

方案2：复合索引（推荐）
CREATE INDEX idx_age_city_status ON users(age, city, status);
优势：一个索引就能完全满足查询条件
```

**OR条件处理**
```sql
-- OR条件查询
SELECT * FROM users WHERE age = 25 OR city = 'Beijing';

索引需求：
├─ 需要age字段的索引
├─ 需要city字段的索引
└─ MySQL会使用index_merge优化（如果可能）

-- 查看是否使用了index_merge
EXPLAIN SELECT * FROM users WHERE age = 25 OR city = 'Beijing';
-- Extra字段显示：Using union(idx_age,idx_city)
```

### 2.3 函数和表达式处理


**避免在WHERE中使用函数**
```sql
-- ❌ 错误写法：在列上使用函数
SELECT * FROM orders WHERE YEAR(created_at) = 2024;
-- 问题：无法使用created_at字段的索引

-- ✅ 正确写法：避免在列上使用函数
SELECT * FROM orders 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';
-- 可以有效使用created_at字段的索引

-- ❌ 错误写法：列参与计算
SELECT * FROM products WHERE price * 0.8 > 100;

-- ✅ 正确写法：将计算移到右边
SELECT * FROM products WHERE price > 100 / 0.8;
```

---

## 3. 🔗 JOIN关联字段索引诊断


### 3.1 JOIN连接性能分析


**JOIN操作的索引需求**
```sql
-- 典型的JOIN查询
SELECT u.name, o.total
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active';

索引需求分析：
┌─────────────────┬─────────────────┬─────────────────┐
│     表名        │    需要的索引    │      作用       │
├─────────────────┼─────────────────┼─────────────────┤
│ users          │ idx_status      │ WHERE条件过滤   │
│ users          │ PRIMARY KEY(id) │ JOIN连接（通常已有）│
│ orders         │ idx_user_id     │ JOIN连接查找    │
└─────────────────┴─────────────────┴─────────────────┘
```

**JOIN连接算法与索引**
```sql
-- 嵌套循环连接（Nested Loop Join）
驱动表：users（较小的表）
被驱动表：orders（较大的表）

执行过程：
FOR each row in users WHERE status = 'active':
    在orders表中查找 user_id = users.id 的记录
    
如果orders表的user_id没有索引：
├─ 每次都要全表扫描orders
├─ 复杂度：O(M × N)，M=users行数，N=orders行数
└─ 性能极差

如果orders表的user_id有索引：
├─ 每次通过索引快速定位
├─ 复杂度：O(M × log N)
└─ 性能优秀
```

### 3.2 多表JOIN索引策略


**三表连接示例**
```sql
SELECT u.name, o.total, p.amount
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN payments p ON o.id = p.order_id
WHERE u.city = 'Beijing' 
  AND o.status = 'completed';

完整索引策略：
-- 用户表索引
CREATE INDEX idx_users_city ON users(city);

-- 订单表索引  
CREATE INDEX idx_orders_user_id_status ON orders(user_id, status);

-- 支付表索引
CREATE INDEX idx_payments_order_id ON payments(order_id);

执行计划优化后：
1. 先在users表用city索引过滤
2. 通过user_id索引连接orders表
3. 用status条件进一步过滤orders
4. 通过order_id索引连接payments表
```

### 3.3 LEFT JOIN特殊考虑


**LEFT JOIN的索引特点**
```sql
-- LEFT JOIN查询
SELECT u.name, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active';

索引重点：
├─ 左表(users)：需要WHERE条件的索引
├─ 右表(orders)：需要JOIN条件的索引
└─ 特别注意：即使右表没有匹配记录也要返回左表记录

-- 性能陷阱：在RIGHT JOIN的条件中过滤
SELECT u.name, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 'completed';  -- ⚠️ 这实际上变成了INNER JOIN

-- 正确写法：
SELECT u.name, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed';
```

---

## 4. 📊 ORDER BY排序索引分析


### 4.1 ORDER BY性能问题诊断


**排序操作的性能开销**
```sql
-- 无索引的排序查询
SELECT * FROM users ORDER BY created_at DESC LIMIT 10;

-- 执行计划分析
EXPLAIN SELECT * FROM users ORDER BY created_at DESC LIMIT 10;

问题症状：
├─ Extra: Using filesort（最大的性能杀手）
├─ 需要排序所有记录才能找到TOP 10
├─ 大量CPU和内存资源消耗
└─ 可能创建临时文件进行外部排序

优化前后对比：
无索引：100万行 → 全部排序 → 取前10行 → 耗时3秒
有索引：100万行 → 索引已排序 → 直接取前10行 → 耗时0.01秒
```

**排序索引创建**
```sql
-- 单列排序索引
CREATE INDEX idx_created_at ON users(created_at);

-- 多列排序索引
SELECT * FROM users ORDER BY age ASC, name ASC;
CREATE INDEX idx_age_name ON users(age, name);

-- 混合排序方向
SELECT * FROM users ORDER BY age ASC, name DESC;
CREATE INDEX idx_age_asc_name_desc ON users(age ASC, name DESC);
```

### 4.2 WHERE + ORDER BY组合优化


**条件过滤与排序的索引设计**
```sql
-- 典型的分页查询
SELECT * FROM users 
WHERE status = 'active' 
ORDER BY created_at DESC 
LIMIT 20 OFFSET 100;

索引设计策略：
方案1：分别创建索引
├─ CREATE INDEX idx_status ON users(status);
├─ CREATE INDEX idx_created_at ON users(created_at);
└─ 问题：MySQL只能选择一个索引，另一个条件需要额外处理

方案2：复合索引（推荐）
CREATE INDEX idx_status_created_at ON users(status, created_at DESC);
优势：
├─ WHERE条件可以快速定位
├─ ORDER BY无需额外排序
└─ LIMIT可以提前终止
```

**分页查询的深度翻页问题**
```sql
-- 深度分页性能问题
SELECT * FROM users 
WHERE status = 'active' 
ORDER BY created_at DESC 
LIMIT 20 OFFSET 100000;  -- 跳过10万条记录

问题分析：
├─ 需要扫描并跳过前100000条记录
├─ 即使有索引，性能也会随OFFSET增大而下降
└─ 大OFFSET时的线性性能下降

优化方案：游标分页
-- 第一页
SELECT * FROM users 
WHERE status = 'active' 
ORDER BY created_at DESC 
LIMIT 20;

-- 第二页（使用上一页的最后一个created_at值）
SELECT * FROM users 
WHERE status = 'active' 
  AND created_at < '2024-01-15 10:30:00'
ORDER BY created_at DESC 
LIMIT 20;
```

### 4.3 复杂排序场景


**多字段排序优化**
```sql
-- 复杂排序需求
SELECT * FROM products 
WHERE category_id = 100 
ORDER BY priority DESC, price ASC, created_at DESC;

索引设计：
CREATE INDEX idx_category_priority_price_created 
ON products(category_id, priority DESC, price ASC, created_at DESC);

索引使用分析：
├─ category_id：WHERE条件过滤
├─ priority DESC：第一排序字段
├─ price ASC：第二排序字段  
└─ created_at DESC：第三排序字段
```

---

## 5. 🗂️ GROUP BY分组索引优化


### 5.1 GROUP BY性能问题


**分组操作的性能开销**
```sql
-- 无索引的分组查询
SELECT city, COUNT(*) 
FROM users 
GROUP BY city;

-- 执行计划分析
问题症状：
├─ Extra: Using temporary（创建临时表）
├─ Extra: Using filesort（对临时表排序）
├─ 需要扫描全表进行分组统计
└─ 大量内存和CPU资源消耗

优化前后性能对比：
无索引：全表扫描 → 创建临时表 → 分组统计 → 耗时5秒
有索引：索引扫描 → 直接分组 → 无需临时表 → 耗时0.1秒
```

### 5.2 GROUP BY索引设计


**单列分组索引**
```sql
-- 基础分组查询
SELECT department, COUNT(*) 
FROM employees 
GROUP BY department;

-- 创建分组索引
CREATE INDEX idx_department ON employees(department);

索引工作原理：
├─ B+树叶子节点中相同部门的记录相邻存储
├─ 扫描索引时自然按department分组
├─ 无需额外的排序和临时表操作
└─ 可以使用松散索引扫描（Loose Index Scan）
```

**多列分组索引**
```sql
-- 多维度分组分析
SELECT department, job_level, COUNT(*), AVG(salary)
FROM employees 
GROUP BY department, job_level;

-- 复合分组索引
CREATE INDEX idx_dept_level ON employees(department, job_level);

性能提升：
├─ 相同(department, job_level)组合的记录在索引中相邻
├─ 可以直接从索引获取分组结果
└─ 避免全表扫描和临时表创建
```

### 5.3 GROUP BY + WHERE组合优化


**条件过滤与分组的索引策略**
```sql
-- 带条件的分组查询
SELECT department, COUNT(*) 
FROM employees 
WHERE salary > 50000 
GROUP BY department;

索引设计选择：
方案1：WHERE优先
CREATE INDEX idx_salary_dept ON employees(salary, department);
适用：WHERE条件过滤掉大部分数据的场景

方案2：GROUP BY优先  
CREATE INDEX idx_dept_salary ON employees(department, salary);
适用：需要对大部分数据进行分组的场景

选择依据：
├─ 如果WHERE条件选择性高（过滤掉90%数据）→ 方案1
├─ 如果WHERE条件选择性低（过滤掉10%数据）→ 方案2
└─ 通过EXPLAIN分析具体的rows和filtered来决策
```

### 5.4 聚合函数优化


**COUNT优化策略**
```sql
-- COUNT(*)统计优化
SELECT department, COUNT(*) 
FROM employees 
GROUP BY department;

-- 覆盖索引优化
CREATE INDEX idx_department_covering ON employees(department, employee_id);

优化效果：
├─ 所有需要的数据都在索引中
├─ 无需回表查询原始数据
├─ 大幅减少IO操作
└─ COUNT操作直接在索引上完成

-- 其他聚合函数优化
SELECT department, MAX(salary), MIN(salary)
FROM employees 
GROUP BY department;

-- 包含聚合字段的索引
CREATE INDEX idx_dept_salary ON employees(department, salary);
-- MIN/MAX可以直接从索引的最小/最大值获取
```

---

## 6. 🔧 复合索引使用分析


### 6.1 复合索引的基本原理


**复合索引结构理解**
```sql
-- 创建复合索引
CREATE INDEX idx_age_city_name ON users(age, city, name);

-- 复合索引的逻辑结构
索引值排列：
(18, 'Beijing', 'Alice')
(18, 'Beijing', 'Bob')    
(18, 'Shanghai', 'Charlie')
(19, 'Beijing', 'David')
(19, 'Beijing', 'Eva')
...

排序规则：
1️⃣ 首先按age排序
2️⃣ age相同时按city排序  
3️⃣ age和city都相同时按name排序
```

**最左前缀原则**
```sql
-- 复合索引：idx_age_city_name (age, city, name)

-- ✅ 可以使用索引的查询
SELECT * FROM users WHERE age = 25;                          -- 使用(age)
SELECT * FROM users WHERE age = 25 AND city = 'Beijing';     -- 使用(age, city)
SELECT * FROM users WHERE age = 25 AND city = 'Beijing' AND name = 'Alice'; -- 使用(age, city, name)

-- ❌ 无法使用索引的查询
SELECT * FROM users WHERE city = 'Beijing';                  -- 跳过了age
SELECT * FROM users WHERE name = 'Alice';                    -- 跳过了age和city
SELECT * FROM users WHERE city = 'Beijing' AND name = 'Alice'; -- 跳过了age

-- ⚠️ 部分使用索引的查询
SELECT * FROM users WHERE age = 25 AND name = 'Alice';       -- 只能使用(age)部分
```

### 6.2 复合索引设计策略


**字段顺序设计原则**
```sql
-- 查询分析：确定复合索引的字段顺序
-- 假设有以下查询模式：
-- Q1: WHERE age = ? AND city = ?
-- Q2: WHERE age = ? 
-- Q3: WHERE city = ?
-- Q4: WHERE age = ? AND city = ? AND status = ?

设计思路：
1️⃣ 选择性分析：
   ├─ age字段：选择性中等（1-100岁）
   ├─ city字段：选择性低（几十个城市）
   └─ status字段：选择性很低（active/inactive）

2️⃣ 查询频率分析：
   ├─ 包含age条件的查询：80%
   ├─ 包含city条件的查询：60%  
   └─ 包含status条件的查询：30%

3️⃣ 推荐索引设计：
CREATE INDEX idx_age_city_status ON users(age, city, status);

原因：
├─ age字段查询频率最高，放在最前面
├─ 满足最左前缀原则，支持多种查询组合
└─ 按选择性排序：高选择性字段优先
```

**索引字段数量控制**
```sql
-- ⚠️ 过多字段的复合索引问题
CREATE INDEX idx_too_many_fields ON users(
    age, city, status, department, job_level, salary, created_at
);  -- 7个字段，通常不推荐

问题：
├─ 索引维护成本高：插入/更新/删除都要维护索引
├─ 索引空间占用大：可能比表数据还大
├─ 实际使用率低：很少有查询用到所有7个字段
└─ 维护复杂：难以判断索引的实际价值

建议：
├─ 复合索引字段数量控制在3-5个以内
├─ 根据实际查询模式设计
├─ 定期分析索引使用情况
└─ 删除低效和冗余的索引
```

### 6.3 复合索引性能监控


**索引使用情况分析**
```sql
-- 查看索引使用统计
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    SUB_PART,
    NULLABLE
FROM information_schema.STATISTICS 
WHERE TABLE_NAME = 'users'
ORDER BY TABLE_NAME, SEQ_IN_INDEX;

-- 分析索引选择性
SELECT 
    COUNT(DISTINCT age) as age_distinct,
    COUNT(DISTINCT city) as city_distinct,
    COUNT(DISTINCT CONCAT(age, city)) as age_city_distinct,
    COUNT(*) as total_rows
FROM users;

选择性计算：
├─ age选择性 = age_distinct / total_rows
├─ city选择性 = city_distinct / total_rows  
└─ 复合选择性 = age_city_distinct / total_rows
```

---

## 7. 📈 索引覆盖度与选择性


### 7.1 索引覆盖度分析


**什么是覆盖索引**
```sql
-- 查询需要的字段
SELECT user_id, name, age FROM users WHERE city = 'Beijing';

-- 普通索引
CREATE INDEX idx_city ON users(city);
执行过程：
1. 通过city索引找到满足条件的记录位置
2. 回表查询获取user_id, name, age字段  
3. 两次IO操作：索引查找 + 回表查询

-- 覆盖索引
CREATE INDEX idx_city_covering ON users(city, user_id, name, age);
执行过程：
1. 通过索引直接获取所有需要的字段
2. 无需回表查询
3. 一次IO操作：索引查找即可
```

**覆盖索引设计策略**
```sql
-- 分析常见查询模式
-- Q1: SELECT user_id, name FROM users WHERE city = 'Beijing';
-- Q2: SELECT user_id, age FROM users WHERE city = 'Beijing';  
-- Q3: SELECT name, age FROM users WHERE city = 'Beijing';

-- 设计覆盖索引
CREATE INDEX idx_city_comprehensive ON users(city, user_id, name, age);

优势分析：
├─ 避免回表操作，减少50%的IO
├─ 提高查询响应速度2-5倍
├─ 减少缓冲池压力
└─ 特别适合读多写少的场景

注意事项：
├─ 索引大小会显著增加
├─ 写入性能可能略有下降
├─ 需要权衡查询性能和存储成本
└─ 适合于热点查询的优化
```

### 7.2 索引选择性分析


**选择性计算方法**
```sql
-- 计算单列选择性
SELECT 
    COUNT(DISTINCT age) / COUNT(*) as age_selectivity,
    COUNT(DISTINCT city) / COUNT(*) as city_selectivity,
    COUNT(DISTINCT status) / COUNT(*) as status_selectivity
FROM users;

结果示例：
├─ age_selectivity: 0.85 (高选择性，适合做索引)
├─ city_selectivity: 0.01 (低选择性，索引效果一般)  
└─ status_selectivity: 0.003 (极低选择性，不适合单独索引)

选择性判断标准：
├─ >0.1：高选择性，适合创建索引
├─ 0.01-0.1：中等选择性，结合查询频率考虑
├─ <0.01：低选择性，通常不建议单独索引
└─ 可以考虑与其他字段组成复合索引
```

**复合选择性分析**
```sql
-- 计算复合字段选择性
SELECT 
    COUNT(DISTINCT CONCAT(city, status)) / COUNT(*) as city_status_selectivity,
    COUNT(DISTINCT CONCAT(age, city)) / COUNT(*) as age_city_selectivity
FROM users;

复合选择性评估：
方案1：(city, status) → 选择性 0.05
方案2：(age, city) → 选择性 0.65

结论：age + city的复合索引选择性更好，索引效果更优
```

### 7.3 前缀索引优化


**长字段的前缀索引**
```sql
-- 针对长字符串字段的优化
-- 假设email字段平均长度30字符
ALTER TABLE users ADD INDEX idx_email_full (email);        -- 完整索引
ALTER TABLE users ADD INDEX idx_email_prefix (email(10));  -- 前缀索引

-- 分析前缀长度的选择性
SELECT 
    COUNT(DISTINCT email) as full_distinct,
    COUNT(DISTINCT LEFT(email, 5)) as prefix5_distinct,
    COUNT(DISTINCT LEFT(email, 10)) as prefix10_distinct,
    COUNT(DISTINCT LEFT(email, 15)) as prefix15_distinct,
    COUNT(*) as total_rows
FROM users;

前缀长度选择：
├─ 5字符前缀：选择性60% → 不够
├─ 10字符前缀：选择性90% → 可接受
├─ 15字符前缀：选择性95% → 较好
└─ 完整字段：选择性100% → 最好但存储大

推荐：选择能达到90-95%选择性的最短前缀长度
```

---

## 8. 🧹 冗余索引识别清理


### 8.1 冗余索引类型识别


**完全冗余索引**
```sql
-- 情况1：重复索引
CREATE INDEX idx_user_id_1 ON orders(user_id);
CREATE INDEX idx_user_id_2 ON orders(user_id);  -- 完全冗余

-- 情况2：复合索引包含单列索引
CREATE INDEX idx_age ON users(age);
CREATE INDEX idx_age_city ON users(age, city);  -- idx_age被包含，部分冗余
```

**包含关系冗余**
```sql
-- 索引包含关系分析
现有索引：
├─ idx_a: (age)
├─ idx_b: (age, city)  
├─ idx_c: (age, city, status)
└─ idx_d: (city)

冗余分析：
├─ idx_a被idx_b包含 → 如果查询总是包含city，则idx_a冗余
├─ idx_b被idx_c包含 → 如果查询总是包含status，则idx_b冗余
└─ idx_d独立存在 → 支持单独查询city的场景

清理建议：
根据实际查询模式，保留最有用的索引组合
```

### 8.2 冗余索引检测方法


**系统表查询检测**
```sql
-- 查找重复索引
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    GROUP_CONCAT(INDEX_NAME) as duplicate_indexes,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) as columns,
    COUNT(*) as index_count
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
GROUP BY TABLE_SCHEMA, TABLE_NAME, 
         GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX)
HAVING COUNT(*) > 1;
```

**使用pt-duplicate-key-checker工具**
```bash
# Percona Toolkit工具检测
pt-duplicate-key-checker --host=localhost --user=root --database=your_db

# 输出示例：
# Key idx_user_id_duplicate is a duplicate of idx_user_id
# Key definitions:
#   KEY `idx_user_id` (`user_id`)
#   KEY `idx_user_id_duplicate` (`user_id`)
# To remove this duplicate key, execute:
#   ALTER TABLE `orders` DROP INDEX `idx_user_id_duplicate`;
```

### 8.3 索引使用情况监控


**索引使用统计分析**
```sql
-- 启用索引使用统计
SET GLOBAL userstat = 1;

-- 查看索引使用情况
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    ROWS_READ,
    ROWS_REQUESTED
FROM information_schema.INDEX_STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY ROWS_READ DESC;

-- 识别未使用的索引
SELECT 
    s.TABLE_SCHEMA,
    s.TABLE_NAME,
    s.INDEX_NAME
FROM information_schema.STATISTICS s
LEFT JOIN information_schema.INDEX_STATISTICS i
    ON s.TABLE_SCHEMA = i.TABLE_SCHEMA 
    AND s.TABLE_NAME = i.TABLE_NAME
    AND s.INDEX_NAME = i.INDEX_NAME
WHERE s.TABLE_SCHEMA = 'your_database'
    AND s.INDEX_NAME != 'PRIMARY'
    AND i.INDEX_NAME IS NULL;
```

### 8.4 安全的索引清理流程


**索引删除的安全步骤**
```sql
-- 步骤1：标记待删除索引为不可见（MySQL 8.0+）
ALTER TABLE users ALTER INDEX idx_redundant INVISIBLE;

-- 步骤2：观察1-2周，监控性能指标
-- 检查慢查询日志、应用性能等

-- 步骤3：如果没有问题，正式删除索引
ALTER TABLE users DROP INDEX idx_redundant;

-- 步骤4：如果有问题，恢复索引
ALTER TABLE users ALTER INDEX idx_redundant VISIBLE;
-- 或重新创建：
CREATE INDEX idx_redundant ON users(column_name);
```

**批量清理脚本**
```sql
-- 生成删除冗余索引的脚本
SELECT CONCAT(
    'ALTER TABLE ', TABLE_NAME, 
    ' DROP INDEX ', INDEX_NAME, ';'
) as drop_statement
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database'
    AND INDEX_NAME IN (
        -- 确认的冗余索引列表
        'idx_redundant_1', 'idx_redundant_2'
    );
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的诊断方法


```
🔸 基础诊断工具：EXPLAIN分析执行计划，识别全表扫描
🔸 性能监控：慢查询日志、Handler_read统计指标
🔸 索引分析：SHOW INDEX查看现有索引，分析覆盖情况
🔸 选择性计算：COUNT(DISTINCT)/COUNT(*)评估索引价值
🔸 冗余检测：系统表查询、pt-duplicate-key-checker工具
```

### 9.2 关键优化原则


**🔹 WHERE条件优化**
```
单列索引：高选择性字段优先创建索引
复合索引：遵循最左前缀原则，按查询频率排序
函数使用：避免在WHERE子句中对列使用函数
OR条件：为每个OR分支都需要提供索引支持
```

**🔹 JOIN连接优化**
```
连接字段：JOIN的关联字段必须有索引
驱动表选择：小表驱动大表，减少嵌套循环次数
复合策略：结合WHERE条件设计复合索引
LEFT JOIN：注意区分ON条件和WHERE条件的索引需求
```

**🔹 排序分组优化**
```
ORDER BY：创建排序字段的索引，避免Using filesort
GROUP BY：分组字段需要索引，避免Using temporary
组合查询：WHERE + ORDER BY考虑复合索引设计
分页优化：使用游标分页避免大OFFSET性能问题
```

### 9.3 实际应用指导


**🔸 索引设计流程**
```sql
-- 1. 分析查询模式
SELECT query_text, execution_count 
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY sum_timer_wait DESC LIMIT 10;

-- 2. 识别缺失索引
EXPLAIN FORMAT=JSON SELECT ...;

-- 3. 设计复合索引
根据WHERE条件 + ORDER BY + GROUP BY字段组合

-- 4. 验证索引效果
EXPLAIN分析优化前后的执行计划差异

-- 5. 监控性能表现
观察查询响应时间、CPU使用率、IO负载变化
```

**🔸 索引维护策略**
```sql
-- 定期统计信息更新
ANALYZE TABLE users;

-- 定期检查索引使用情况
SELECT * FROM sys.schema_unused_indexes;

-- 定期清理冗余索引
pt-duplicate-key-checker --host=localhost --database=your_db

-- 性能监控告警
SET GLOBAL long_query_time = 1;
SET GLOBAL slow_query_log = ON;
```

**核心记忆要点**：
- 索引缺失诊断从执行计划的type=ALL和key=NULL开始
- WHERE条件、JOIN字段、ORDER BY、GROUP BY都可能需要索引
- 复合索引设计要考虑最左前缀和查询模式匹配
- 覆盖索引可以避免回表，显著提升查询性能
- 定期监控和清理冗余索引，保持索引体系的健康状态