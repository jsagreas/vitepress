---
title: 13、EXPLAIN输出字段详解
---
## 📚 目录

1. [EXPLAIN输出结构概览](#1-EXPLAIN输出结构概览)
2. [执行顺序标识字段](#2-执行顺序标识字段)
3. [查询类型分析字段](#3-查询类型分析字段)
4. [表和分区信息字段](#4-表和分区信息字段)
5. [索引相关核心字段](#5-索引相关核心字段)
6. [性能评估字段](#6-性能评估字段)
7. [额外执行信息字段](#7-额外执行信息字段)
8. [字段组合分析技巧](#8-字段组合分析技巧)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 EXPLAIN输出结构概览


### 1.1 什么是EXPLAIN输出


**简单理解**：EXPLAIN就像是MySQL给你的一份"查询计划书"，告诉你这条SQL语句会怎么执行。

```sql
-- 基本使用
EXPLAIN SELECT * FROM users WHERE age > 25;
```

**输出结果示例**：
```
+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | users | range | age_idx       | age_idx | 4    | NULL |  100 | Using where |
+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+
```

### 1.2 字段分类理解


```
执行控制字段：
├── id           执行顺序编号
└── select_type  查询类型

表信息字段：
├── table        表名或别名
└── partitions   分区信息

索引字段：
├── type           访问类型
├── possible_keys  可能用到的索引
├── key           实际使用的索引
├── key_len       索引长度
└── ref           索引比较值

性能字段：
├── rows          扫描行数
├── filtered      过滤百分比
└── Extra         额外信息
```

---

## 2. 🏷️ 执行顺序标识字段


### 2.1 id字段 - 查询执行顺序


**简单理解**：id就像是MySQL给每个查询步骤编的号，号码大的先执行。

**🔸 执行规则**
```
规则1：id相同 → 从上到下执行
规则2：id不同 → 数字大的先执行  
规则3：id为NULL → 最后执行（通常是UNION结果）
```

**💡 实际案例解析**

```sql
-- 子查询示例
EXPLAIN SELECT * FROM users 
WHERE department_id IN (
    SELECT id FROM departments WHERE name = 'IT'
);
```

```
执行顺序分析：
+----+-------------+-------------+-------+
| id | select_type | table       | type  |
+----+-------------+-------------+-------+
|  1 | PRIMARY     | users       | ALL   |  ← 第二步执行
|  2 | SUBQUERY    | departments | range |  ← 第一步执行（id=2更大）
+----+-------------+-------------+-------+

执行流程：
步骤1：先执行id=2的子查询，找出IT部门的id
步骤2：再执行id=1的主查询，用部门id过滤用户
```

**🔧 复杂查询示例**

```sql
-- 多层嵌套查询
EXPLAIN SELECT u.name 
FROM users u
WHERE u.salary > (
    SELECT AVG(salary) 
    FROM users u2 
    WHERE u2.department_id = (
        SELECT id FROM departments WHERE name = 'Sales'
    )
);
```

```
执行顺序（从id大到小）：
+----+-------------+-------------+
| id | select_type | table       |
+----+-------------+-------------+
|  1 | PRIMARY     | u           |  ← 第三步
|  2 | SUBQUERY    | u2          |  ← 第二步
|  3 | SUBQUERY    | departments |  ← 第一步（最大id）
+----+-------------+-------------+
```

---

## 3. 🔍 查询类型分析字段


### 3.1 select_type字段 - 查询类型识别


**简单理解**：select_type告诉你这是个什么类型的查询，就像给查询贴个标签。

**🎯 常见类型详解**

| 类型 | **含义** | **什么时候出现** | **性能影响** |
|------|----------|------------------|--------------|
| `SIMPLE` | `最简单的查询` | `没有子查询和UNION` | `★★★★★ 最好` |
| `PRIMARY` | `主查询` | `有子查询时的外层查询` | `★★★★☆ 较好` |
| `SUBQUERY` | `子查询` | `SELECT或WHERE中的子查询` | `★★★☆☆ 一般` |
| `DERIVED` | `派生表` | `FROM子句中的子查询` | `★★☆☆☆ 较慢` |
| `UNION` | `联合查询` | `UNION的第二个及之后的查询` | `★★★☆☆ 看情况` |

**💡 实际示例理解**

```sql
-- SIMPLE类型 - 最简单直接
EXPLAIN SELECT name FROM users WHERE age > 25;
-- select_type: SIMPLE

-- PRIMARY + SUBQUERY类型
EXPLAIN SELECT name FROM users 
WHERE salary > (SELECT AVG(salary) FROM employees);
-- 外层查询: PRIMARY
-- 子查询: SUBQUERY

-- DERIVED类型 - 派生表（临时表）
EXPLAIN SELECT * FROM (
    SELECT department_id, AVG(salary) as avg_sal 
    FROM users GROUP BY department_id
) t WHERE avg_sal > 5000;
-- 子查询: DERIVED (会创建临时表)
```

### 3.2 性能优化建议


**⚡ 优化策略**
```
SIMPLE > PRIMARY > SUBQUERY > DERIVED
     ↑        ↑         ↑         ↑
   最快     较快      注意     需要优化

优化建议：
✅ 尽量保持SIMPLE类型
⚠️ 避免过多DERIVED类型
🔧 考虑将SUBQUERY改写为JOIN
```

---

## 4. 📋 表和分区信息字段


### 4.1 table字段 - 表名显示


**简单理解**：table字段显示当前这一行是在操作哪张表。

**🔸 显示规则**
```
真实表名：users, orders, products
表别名：u, o, p (如果使用了别名)
派生表：<derivedN> (N是对应的id)
联合查询：<unionM,N> (M,N是相关的id)
```

**💡 实际示例**

```sql
-- 普通表名
EXPLAIN SELECT * FROM users;
-- table: users

-- 使用别名
EXPLAIN SELECT u.name FROM users u;
-- table: u

-- 派生表
EXPLAIN SELECT * FROM (SELECT * FROM users) t;
-- table: <derived2>

-- 多表关联
EXPLAIN SELECT u.name, d.name 
FROM users u JOIN departments d ON u.dept_id = d.id;
-- 会出现两行，分别显示 u 和 d
```

### 4.2 partitions字段 - 分区访问信息


**简单理解**：如果表使用了分区，partitions字段会告诉你访问了哪些分区。

**🔧 分区访问示例**

```sql
-- 假设按时间分区的订单表
CREATE TABLE orders (
    id INT,
    order_date DATE,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);

-- 查询特定年份数据
EXPLAIN SELECT * FROM orders WHERE order_date >= '2024-01-01';
-- partitions: p2024,p2025 (只访问相关分区)
```

**📊 分区裁剪效果**
```
全表扫描：访问所有分区 → 性能差
分区裁剪：只访问相关分区 → 性能好

partitions显示：
p2024        → 只访问一个分区 ✅
p2024,p2025  → 访问两个分区 ⚠️
NULL         → 表未分区或访问所有分区
```

---

## 5. 🔑 索引相关核心字段


### 5.1 type字段 - 访问类型（性能关键）


**简单理解**：type字段是性能分析的核心，告诉你MySQL是怎么找数据的。

**🏆 性能排序（从好到坏）**

```
system > const > eq_ref > ref > range > index > ALL
  ↑        ↑       ↑       ↑      ↑       ↑      ↑
最快    非常快    很快     快    一般    较慢   最慢
```

**🔸 各类型详解**

| 类型 | **含义** | **什么时候出现** | **示例** |
|------|----------|------------------|----------|
| `system` | `系统表，只有一行` | `MyISAM引擎的系统表` | `极少见` |
| `const` | `常量查询，最多一行` | `主键或唯一索引等值查询` | `WHERE id = 1` |
| `eq_ref` | `唯一索引扫描` | `JOIN时用主键或唯一索引` | `表关联查询` |
| `ref` | `非唯一索引扫描` | `普通索引等值查询` | `WHERE name = 'Tom'` |
| `range` | `范围扫描` | `>, <, BETWEEN, IN等` | `WHERE age > 25` |
| `index` | `索引全扫描` | `扫描整个索引树` | `ORDER BY索引列` |
| `ALL` | `全表扫描` | `没有合适索引` | `WHERE非索引列` |

**💡 实际案例理解**

```sql
-- const类型 - 最快
EXPLAIN SELECT * FROM users WHERE id = 123;
-- type: const (主键查询)

-- ref类型 - 快
EXPLAIN SELECT * FROM users WHERE name = 'Tom';
-- type: ref (普通索引查询)

-- range类型 - 一般
EXPLAIN SELECT * FROM users WHERE age BETWEEN 25 AND 35;
-- type: range (范围查询)

-- ALL类型 - 最慢（需要优化）
EXPLAIN SELECT * FROM users WHERE phone = '13812345678';
-- type: ALL (没有索引，全表扫描)
```

### 5.2 possible_keys字段 - 可能使用的索引


**简单理解**：MySQL分析这个查询可能会用到哪些索引。

```sql
-- 查看可能的索引
EXPLAIN SELECT * FROM users WHERE age > 25 AND name = 'Tom';
-- possible_keys: age_idx,name_idx (两个索引都可能用到)
```

**🔍 分析要点**
```
NULL：没有合适的索引 → 考虑创建索引
多个索引：MySQL会选择最优的一个
索引很多但没用上：可能查询条件有问题
```

### 5.3 key字段 - 实际使用的索引


**简单理解**：MySQL最终选择使用的索引。

```sql
EXPLAIN SELECT * FROM users WHERE age > 25 AND name = 'Tom';
-- possible_keys: age_idx,name_idx
-- key: name_idx (MySQL选择了name索引)
```

**⚠️ 关键判断**
```
key不为NULL → 使用了索引 ✅
key为NULL → 没用索引，全表扫描 ❌
key与possible_keys不同 → MySQL做了选择
```

### 5.4 key_len字段 - 索引长度计算


**简单理解**：告诉你索引用了多长，可以判断复合索引用了几个字段。

**🔢 长度计算规则**
```
数据类型长度：
INT: 4字节
BIGINT: 8字节
VARCHAR(50): 50*3+2字节 (UTF8编码)
CHAR(10): 10*3字节
DATE: 3字节
DATETIME: 8字节

可空字段: +1字节
变长字段: +2字节
```

**💡 实际应用**

```sql
-- 复合索引 (name, age, city)
CREATE INDEX idx_complex ON users(name(20), age, city(10));

-- 只用name字段
EXPLAIN SELECT * FROM users WHERE name = 'Tom';
-- key_len: 62 (20*3+2=62，只用了name字段)

-- 用name和age字段  
EXPLAIN SELECT * FROM users WHERE name = 'Tom' AND age = 25;
-- key_len: 67 (62+4+1=67，用了name和age字段)

-- 用全部字段
EXPLAIN SELECT * FROM users WHERE name = 'Tom' AND age = 25 AND city = 'Beijing';
-- key_len: 99 (67+10*3+2=99，用了全部字段)
```

### 5.5 ref字段 - 索引比较值


**简单理解**：告诉你索引和什么值做比较。

**🔸 常见值含义**
```
const: 和常量比较 → WHERE id = 123
db.table.column: 和其他表字段比较 → JOIN条件
func: 和函数结果比较 → WHERE id = LAST_INSERT_ID()
NULL: range查询 → WHERE age > 25
```

---

## 6. 📈 性能评估字段


### 6.1 rows字段 - 扫描行数预估


**简单理解**：MySQL预估需要扫描多少行数据才能完成查询。

**⚠️ 重要理解**
```
这是预估值，不是精确值
数值越小越好
需要结合filtered字段看实际效果
```

**💡 实际分析**

```sql
-- 主键查询
EXPLAIN SELECT * FROM users WHERE id = 123;
-- rows: 1 (预估扫描1行)

-- 范围查询
EXPLAIN SELECT * FROM users WHERE age BETWEEN 25 AND 35;
-- rows: 5000 (预估扫描5000行)

-- 全表扫描
EXPLAIN SELECT * FROM users WHERE phone = '13812345678';
-- rows: 100000 (需要扫描全表10万行)
```

### 6.2 filtered字段 - 过滤百分比


**简单理解**：在扫描的行中，有多少比例的行满足WHERE条件。

**📊 计算公式**
```
实际返回行数 = rows × filtered% 

示例：
rows: 1000
filtered: 10.00
实际处理行数: 1000 × 10% = 100行
```

**🎯 优化指标**
```
filtered = 100%: 所有扫描的行都有用 ✅
filtered < 10%: 大量无效扫描，需要优化 ❌
filtered < 1%: 严重的性能问题 🚨
```

---

## 7. 💡 额外执行信息字段


### 7.1 Extra字段 - 额外执行信息


**简单理解**：Extra字段提供查询执行的额外细节，是性能优化的重要线索。

**🔸 常见信息解读**

| Extra信息 | **含义** | **性能影响** | **优化建议** |
|-----------|----------|--------------|--------------|
| `Using where` | `使用WHERE过滤` | `正常` | `考虑索引优化` |
| `Using index` | `覆盖索引` | `★★★★★ 很好` | `保持现状` |
| `Using filesort` | `文件排序` | `★★☆☆☆ 较慢` | `创建排序索引` |
| `Using temporary` | `使用临时表` | `★☆☆☆☆ 慢` | `优化GROUP BY/ORDER BY` |
| `Using index condition` | `索引条件下推` | `★★★★☆ 好` | `正常优化` |

**💡 详细解释**

```sql
-- Using index (覆盖索引) - 最好的情况
CREATE INDEX idx_name_age ON users(name, age);
EXPLAIN SELECT name, age FROM users WHERE name = 'Tom';
-- Extra: Using index (数据直接从索引获取，不用回表)

-- Using filesort - 需要优化
EXPLAIN SELECT * FROM users ORDER BY created_at;
-- Extra: Using filesort (没有排序索引，需要文件排序)

-- 优化后
CREATE INDEX idx_created_at ON users(created_at);
EXPLAIN SELECT * FROM users ORDER BY created_at;
-- Extra: 空 (使用索引排序，没有额外操作)

-- Using temporary - 性能较差
EXPLAIN SELECT department_id, COUNT(*) FROM users GROUP BY department_id;
-- Extra: Using temporary (需要创建临时表)
```

**🚨 需要关注的Extra信息**

```
⚠️ 性能警告信息：
Using filesort    → 考虑创建排序索引
Using temporary   → 优化GROUP BY或DISTINCT
Using where       → 考虑索引覆盖更多条件

✅ 性能良好信息：
Using index       → 覆盖索引，性能很好
Using index condition → 索引下推，性能较好
```

---

## 8. 🧩 字段组合分析技巧


### 8.1 性能分析组合拳


**🎯 核心分析流程**

```
第一步：看type字段
├── const/eq_ref/ref → 性能好 ✅
├── range → 可接受 ⚠️
└── index/ALL → 需要优化 ❌

第二步：看rows字段
├── < 1000 → 小数据量 ✅
├── < 10000 → 中等数据量 ⚠️
└── > 10000 → 大数据量，需要关注 ❌

第三步：看Extra字段
├── Using index → 最佳性能 ✅
├── Using where → 正常 ⚠️
└── Using filesort/temporary → 需要优化 ❌
```

### 8.2 实际案例综合分析


**📊 案例一：性能良好的查询**

```sql
EXPLAIN SELECT name, age FROM users WHERE user_id = 123;
```

```
分析结果：
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | users | const | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+

性能分析：
✅ type: const (主键查询，最快)
✅ rows: 1 (只扫描1行)
✅ Extra: Using index (覆盖索引，不用回表)
总评：性能优秀 ★★★★★
```

**⚠️ 案例二：需要优化的查询**

```sql
EXPLAIN SELECT * FROM users WHERE phone = '13812345678' ORDER BY created_at;
```

```
分析结果：
+----+-------------+-------+------+---------------+------+---------+------+--------+-----------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows   | Extra                       |
+----+-------------+-------+------+---------------+------+---------+------+--------+-----------------------------+
|  1 | SIMPLE      | users | ALL  | NULL          | NULL | NULL    | NULL | 100000 | Using where; Using filesort |
+----+-------------+-------+------+---------------+------+---------+------+--------+-----------------------------+

性能分析：
❌ type: ALL (全表扫描)
❌ key: NULL (没有使用索引)
❌ rows: 100000 (扫描全表)
❌ Extra: Using filesort (文件排序)
总评：性能很差 ★☆☆☆☆

优化建议：
1. CREATE INDEX idx_phone ON users(phone);
2. CREATE INDEX idx_created_at ON users(created_at);
```

### 8.3 多表关联分析技巧


**🔗 JOIN查询分析**

```sql
EXPLAIN SELECT u.name, d.department_name 
FROM users u 
JOIN departments d ON u.department_id = d.id 
WHERE u.age > 25;
```

```
分析要点：
1. 查看驱动表选择 (rows较小的作为驱动表)
2. 关联条件是否使用索引 (type是否为eq_ref/ref)
3. WHERE条件是否有合适索引
4. 是否出现Using temporary

优化策略：
✅ 小表驱动大表
✅ 关联字段创建索引
✅ WHERE条件字段创建索引
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心字段


```
🔸 执行顺序：id字段决定查询执行顺序
🔸 查询类型：select_type识别查询复杂度
🔸 访问类型：type字段是性能分析核心
🔸 索引使用：key和key_len判断索引效果
🔸 扫描效率：rows和filtered评估数据量
🔸 额外信息：Extra提供优化关键线索
```

### 9.2 性能优化核心判断


**🏆 性能排序记忆**
```
type性能：system > const > eq_ref > ref > range > index > ALL
Extra优化：Using index > 正常 > Using filesort/temporary

快速判断公式：
好查询 = const/ref + 小rows + Using index
差查询 = ALL + 大rows + Using filesort
```

**⚡ 优化策略总结**
```
看到ALL类型 → 立即创建索引
看到Using filesort → 创建排序索引  
看到Using temporary → 优化GROUP BY
看到大rows → 检查WHERE条件索引
```

### 9.3 实际应用指导


**🔧 日常分析流程**
```
步骤1：运行EXPLAIN查看执行计划
步骤2：重点关注type、rows、Extra字段
步骤3：识别性能瓶颈点
步骤4：针对性创建或优化索引
步骤5：再次EXPLAIN验证优化效果
```

**📊 性能基线参考**
```
优秀查询：type=const/ref, rows<100, Extra有Using index
良好查询：type=range, rows<1000, Extra正常
需优化：type=ALL, rows>10000, Extra有filesort/temporary
```

### 9.4 记忆要点


**🎯 核心记忆口诀**
```
id大先执行，type看性能
key用没用上，rows扫描量
Extra有线索，组合看效果
ALL要避免，const是最佳
```

**📈 优化优先级**
```
1. 消除ALL类型的全表扫描
2. 减少Using filesort文件排序
3. 避免Using temporary临时表
4. 提高索引覆盖率(Using index)
5. 降低扫描行数(rows字段)
```