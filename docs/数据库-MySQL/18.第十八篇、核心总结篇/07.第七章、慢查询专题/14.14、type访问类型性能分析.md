---
title: 14、type访问类型性能分析
---
## 📚 目录

1. [什么是访问类型type](#1-什么是访问类型type)
2. [最佳性能访问类型](#2-最佳性能访问类型)
3. [常见索引访问类型](#3-常见索引访问类型)
4. [特殊查询访问类型](#4-特殊查询访问类型)
5. [范围和扫描访问类型](#5-范围和扫描访问类型)
6. [访问类型性能对比](#6-访问类型性能对比)
7. [实战优化策略](#7-实战优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 什么是访问类型type


### 1.1 type字段的含义


**type访问类型**就是MySQL告诉我们它打算怎么去找数据的方式。想象一下找书的过程：

```
图书馆找书的方式：
📖 直接知道书架位置 → 最快（类似const）
📚 通过索引卡片找 → 较快（类似ref）  
📑 一排排书架翻找 → 很慢（类似ALL）

MySQL找数据也是同样道理！
```

**通俗理解**：
- type就是MySQL的"找数据策略"
- 不同的type代表不同的查找效率
- 理解type帮我们判断查询是否需要优化

### 1.2 type在EXPLAIN中的位置


```sql
EXPLAIN SELECT * FROM users WHERE id = 1;
```

**输出结果示例**：
```
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| 1  | SIMPLE      | users | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
                                         ↑
                                    这就是type字段
```

### 1.3 为什么type很重要


**性能影响直观对比**：
```
查询10万条数据的耗时对比：

const访问：    [████] 0.1ms   ← 几乎瞬间
ref访问：      [██████] 1ms   ← 很快  
range访问：    [████████] 10ms ← 还可以
ALL访问：      [████████████████████] 1000ms ← 很慢
```

> 💡 **关键理解**
> 
> type字段直接反映了查询的性能好坏，是SQL优化的重要指标！

---

## 2. 🏆 最佳性能访问类型


### 2.1 system - 系统表单行访问


**什么是system类型**：
system是最特殊的访问类型，只有在查询系统表且该表只有一行数据时才会出现。

```sql
-- 系统表查询示例
SELECT $$version_comment;
```

**特点说明**：
- 📊 **性能等级**：⭐⭐⭐⭐⭐ 最优
- 🔍 **查找方式**：直接读取唯一行
- 📈 **扫描行数**：1行
- ⚡ **速度**：几乎瞬间

> ⚠️ **实际应用**
> 
> system类型在实际业务中很少见，主要出现在系统级查询中

### 2.2 const - 常量级别最优访问


**什么是const类型**：
const是我们最希望看到的访问类型，表示通过主键或唯一索引进行等值查询，最多只会返回一条记录。

```sql
-- const类型查询示例
EXPLAIN SELECT * FROM users WHERE id = 1;
-- id是主键，所以是const访问

EXPLAIN SELECT * FROM users WHERE email = 'john@example.com';  
-- email是唯一索引，也是const访问
```

**const访问的条件**：
```
触发const访问的必要条件：
✅ 使用主键进行等值查询
✅ 使用唯一索引进行等值查询  
✅ 查询条件是常量值（不是变量）

示例对比：
WHERE id = 1        ← const访问 ✅
WHERE id = ?        ← 可能const访问（取决于参数）
WHERE id IN (1,2)   ← 不是const访问 ❌
```

**性能特点**：
- 📊 **性能等级**：⭐⭐⭐⭐⭐ 最优
- 🔍 **查找方式**：直接定位到具体行
- 📈 **扫描行数**：1行
- ⚡ **速度**：极快，通常 < 1ms

### 2.3 eq_ref - 唯一索引等值查找


**什么是eq_ref类型**：
eq_ref主要出现在表连接（JOIN）中，表示对于前一个表的每一行，在当前表中通过主键或唯一索引只能找到一行匹配。

```sql
-- eq_ref类型查询示例
EXPLAIN 
SELECT u.name, p.title 
FROM users u 
JOIN posts p ON u.id = p.user_id;

-- 如果user_id是唯一索引，posts表的访问类型就是eq_ref
```

**eq_ref vs const的区别**：
```
const：    单表查询中的唯一索引查找
eq_ref：   多表连接中的唯一索引查找

简单记忆：
const = 常量查找（单表）
eq_ref = 等值引用查找（多表）
```

**连接查询访问示例**：
```
表关系图：
users(id) ←→ posts(user_id)
    ↓            ↓
  const        eq_ref

每个user对应多个post，但每个post只属于一个user
所以通过user_id查找user时是eq_ref访问
```

**性能特点**：
- 📊 **性能等级**：⭐⭐⭐⭐⭐ 最优
- 🔍 **查找方式**：连接中的唯一匹配
- 📈 **扫描行数**：每次连接1行
- ⚡ **速度**：极快

---

## 3. 🔍 常见索引访问类型


### 3.1 ref - 非唯一索引等值查找


**什么是ref类型**：
ref是最常见的索引访问类型，表示通过非唯一索引进行等值查询，可能返回多行匹配的记录。

```sql
-- ref类型查询示例
EXPLAIN SELECT * FROM users WHERE status = 'active';
-- status字段有普通索引，不是唯一索引

EXPLAIN SELECT * FROM orders WHERE customer_id = 100;
-- customer_id有索引，但一个客户可能有多个订单
```

**ref访问的特点**：
```
ref访问条件：
✅ 使用非唯一索引进行等值查询
✅ 索引列与常量值比较
✅ 可能返回多行结果

与const的区别：
const：最多返回1行（唯一性保证）
ref：  可能返回多行（非唯一索引）
```

**实际场景理解**：
```
用户表按状态查询：
users表中status字段：
- active: 1000人    ← ref访问，返回1000行
- inactive: 500人   ← ref访问，返回500行  
- banned: 10人      ← ref访问，返回10行

虽然都是ref访问，但扫描行数差异很大！
```

**性能特点**：
- 📊 **性能等级**：⭐⭐⭐⭐ 很好
- 🔍 **查找方式**：索引等值查找
- 📈 **扫描行数**：匹配索引的所有行
- ⚡ **速度**：快，通常几毫秒

### 3.2 fulltext - 全文索引搜索


**什么是fulltext类型**：
fulltext是专门用于全文搜索的访问类型，使用FULLTEXT索引进行文本搜索。

```sql
-- 创建全文索引
ALTER TABLE articles ADD FULLTEXT(title, content);

-- fulltext类型查询
EXPLAIN SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST ('MySQL 优化');
```

**全文搜索的特点**：
```
全文索引的应用场景：
📝 文章搜索：标题和内容搜索
🛍️ 商品搜索：商品名称和描述搜索  
📰 新闻搜索：新闻标题和正文搜索
💬 评论搜索：用户评论内容搜索
```

**性能特点**：
- 📊 **性能等级**：⭐⭐⭐⭐ 很好（针对文本搜索）
- 🔍 **查找方式**：全文索引搜索
- 📈 **扫描行数**：依据相关性匹配
- ⚡ **速度**：比LIKE快很多

### 3.3 ref_or_null - 空值条件查找


**什么是ref_or_null类型**：
ref_or_null是ref访问的扩展版本，除了进行等值查询外，还会额外查找NULL值。

```sql
-- ref_or_null类型查询示例
EXPLAIN SELECT * FROM users 
WHERE status = 'active' OR status IS NULL;

-- 等价的条件也会触发
EXPLAIN SELECT * FROM users 
WHERE status <=> 'active';  -- <=> 是NULL安全的等值比较
```

**使用场景理解**：
```
实际业务场景：
用户状态查询：
- status = 'active'  ← 明确的活跃用户
- status IS NULL     ← 状态未设置的用户（可能也算活跃）

订单状态查询：
- payment_status = 'paid' OR payment_status IS NULL
  ← 已支付的订单 + 状态未知的订单（可能是老数据）
```

**性能特点**：
- 📊 **性能等级**：⭐⭐⭐⭐ 很好
- 🔍 **查找方式**：索引查找 + NULL值查找
- 📈 **扫描行数**：匹配行数 + NULL行数
- ⚡ **速度**：略慢于ref，但仍然很快

---

## 4. 🔀 特殊查询访问类型


### 4.1 index_merge - 索引合并策略


**什么是index_merge类型**：
index_merge表示MySQL使用了多个索引，然后将结果进行合并。这通常发生在OR条件或某些复杂查询中。

```sql
-- index_merge类型查询示例
EXPLAIN SELECT * FROM users 
WHERE age = 25 OR status = 'active';
-- age和status都有单独的索引

EXPLAIN SELECT * FROM products 
WHERE category_id = 1 AND price BETWEEN 100 AND 200;
-- 如果category_id和price都有索引，可能使用index_merge
```

**索引合并的类型**：

**🔹 Union合并（OR条件）**：
```
查询：WHERE age = 25 OR status = 'active'

执行过程：
步骤1：使用age索引找到age=25的记录
步骤2：使用status索引找到status='active'的记录  
步骤3：将两个结果合并（去重）
```

**🔹 Intersection合并（AND条件）**：
```
查询：WHERE category_id = 1 AND brand_id = 2

执行过程：
步骤1：使用category_id索引找到匹配记录
步骤2：使用brand_id索引找到匹配记录
步骤3：取两个结果的交集
```

**性能分析**：
```
index_merge的性能考虑：

优势：
✅ 利用了多个索引
✅ 比全表扫描快很多

劣势：  
❌ 需要合并操作，有额外开销
❌ 通常不如组合索引快

优化建议：
💡 考虑创建组合索引替代多个单列索引
```

### 4.2 unique_subquery - 唯一子查询


**什么是unique_subquery类型**：
unique_subquery出现在IN子查询中，子查询返回的是唯一值（主键或唯一索引）。

```sql
-- unique_subquery类型查询示例
EXPLAIN SELECT * FROM orders 
WHERE user_id IN (
    SELECT id FROM users WHERE status = 'vip'
);
-- 子查询返回的id是唯一的
```

**子查询优化理解**：
```
传统子查询执行：
外层查询每一行 → 执行一次子查询 → 效率低

unique_subquery优化：
MySQL知道子查询返回唯一值 → 可以进行优化 → 效率高
```

### 4.3 index_subquery - 索引子查询


**什么是index_subquery类型**：
index_subquery与unique_subquery类似，但子查询使用的是非唯一索引。

```sql
-- index_subquery类型查询示例  
EXPLAIN SELECT * FROM orders
WHERE customer_id IN (
    SELECT customer_id FROM reviews WHERE rating = 5
);
-- customer_id不是唯一的，但有索引
```

**性能特点对比**：
```
子查询访问类型性能排序：
unique_subquery  ⭐⭐⭐⭐ （唯一索引，最优）
index_subquery   ⭐⭐⭐   （非唯一索引，较好）
普通子查询       ⭐⭐     （可能全表扫描，较差）
```

---

## 5. 📊 范围和扫描访问类型


### 5.1 range - 范围扫描访问


**什么是range类型**：
range表示使用索引进行范围查询，这是一种比较常见且性能不错的访问类型。

```sql
-- range类型查询示例
EXPLAIN SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';

EXPLAIN SELECT * FROM users WHERE age > 18;

EXPLAIN SELECT * FROM products WHERE price IN (100, 200, 300);

EXPLAIN SELECT * FROM logs WHERE id > 1000;
```

**range访问的触发条件**：
```
常见的range条件：
✅ BETWEEN ... AND ...     范围查询
✅ > < >= <=              比较操作符  
✅ IN (值列表)             多个等值  
✅ LIKE '前缀%'           前缀模糊查询

不会触发range的情况：
❌ LIKE '%关键字%'        中间模糊查询
❌ != 或 <>              不等于操作
❌ NOT IN                非包含查询
```

**range性能分析**：
```
range扫描示例：
索引树结构（简化）：
    10
   /  \
  5    15
 / \   / \
1  8  12 20

查询 WHERE id BETWEEN 8 AND 15：
扫描路径：8 → 10 → 12 → 15
只扫描需要的部分，不需要全部遍历！
```

**实际应用场景**：
```
业务中的range查询：
📅 时间范围：查询某月的订单
💰 价格范围：查询某价位的商品  
👥 年龄范围：查询某年龄段的用户
📊 数值范围：查询某分数段的考试成绩
```

**性能特点**：
- 📊 **性能等级**：⭐⭐⭐ 良好
- 🔍 **查找方式**：索引范围扫描
- 📈 **扫描行数**：范围内的所有行
- ⚡ **速度**：中等，取决于范围大小

### 5.2 index - 索引全扫描


**什么是index类型**：
index表示需要扫描整个索引树，但不需要访问数据行。通常发生在查询只需要索引列的值时。

```sql
-- index类型查询示例
EXPLAIN SELECT id FROM users;  
-- 只查询主键，不需要访问数据行

EXPLAIN SELECT COUNT(*) FROM orders;
-- 统计行数，可能只扫描索引

EXPLAIN SELECT status FROM users ORDER BY status;
-- 如果status有索引，可能只扫描索引
```

**index vs ALL的区别**：
```
数据存储结构：
┌─────────────┐    ┌──────────────┐
│   索引文件   │    │   数据文件    │  
│  (较小)     │    │   (较大)     │
│ id | name   │    │ 完整行数据   │
│ 1  | John   │    │ 1|John|25|..│
│ 2  | Jane   │    │ 2|Jane|30|..│
└─────────────┘    └──────────────┘

index访问：只读索引文件 ← 更快
ALL访问：  读取数据文件 ← 更慢
```

**index访问的优势**：
```
索引扫描的优点：
✅ 索引文件比数据文件小
✅ 索引通常在内存中
✅ 避免随机I/O访问数据页

适用场景：
📊 SELECT COUNT(*)        只需要统计
🔍 SELECT 索引列          只查询索引列
📈 ORDER BY 索引列        利用索引排序
```

**性能特点**：
- 📊 **性能等级**：⭐⭐ 一般
- 🔍 **查找方式**：全索引扫描
- 📈 **扫描行数**：所有行（但只读索引）
- ⚡ **速度**：中等，比ALL快

### 5.3 ALL - 全表扫描最差情况


**什么是ALL类型**：
ALL是我们最不希望看到的访问类型，表示需要扫描整个表的所有数据行，这是性能最差的访问方式。

```sql
-- ALL类型查询示例（需要优化的查询）
EXPLAIN SELECT * FROM users WHERE UPPER(name) = 'JOHN';
-- 函数导致索引失效

EXPLAIN SELECT * FROM orders WHERE total_amount + tax > 1000;  
-- 列运算导致索引失效

EXPLAIN SELECT * FROM products WHERE description LIKE '%关键字%';
-- 中间模糊查询无法使用索引
```

**导致ALL访问的常见原因**：
```
索引失效的情况：
❌ 列上使用函数        WHERE YEAR(create_time) = 2024
❌ 列参与运算          WHERE price * 0.8 > 100  
❌ 类型不匹配          WHERE varchar_column = 123
❌ 中间模糊查询        WHERE name LIKE '%john%'
❌ 使用OR连接不同列    WHERE name='john' OR age=25 (没有合适索引)
❌ 查询条件太宽泛      WHERE status != 'active' (排除条件)
```

**ALL访问的性能影响**：
```
全表扫描的代价：
📊 数据量：100万行
💾 每行大小：1KB  
📈 总扫描：1GB数据
⏱️ 预估耗时：几秒到几十秒

对比其他访问类型：
const:    0.001秒 ← 瞬间
ref:      0.01秒  ← 很快  
range:    0.1秒   ← 还行
ALL:      10秒    ← 很慢
```

**如何避免ALL访问**：
```
优化策略：
✅ 添加合适的索引
✅ 重写查询条件  
✅ 避免函数和运算
✅ 使用覆盖索引
✅ 分解复杂查询

具体示例：
❌ WHERE YEAR(create_time) = 2024
✅ WHERE create_time >= '2024-01-01' AND create_time < '2025-01-01'
```

---

## 6. 📈 访问类型性能对比


### 6.1 性能等级排序


**type访问类型性能从优到差**：

| 排名 | 访问类型 | 性能等级 | 扫描行数 | 典型场景 |
|------|----------|----------|----------|----------|
| 🥇 | `system` | ⭐⭐⭐⭐⭐ | 1行 | 系统表查询 |
| 🥈 | `const` | ⭐⭐⭐⭐⭐ | 1行 | 主键/唯一索引等值查询 |
| 🥉 | `eq_ref` | ⭐⭐⭐⭐⭐ | 1行/连接 | JOIN中的唯一索引查询 |
| 4️⃣ | `ref` | ⭐⭐⭐⭐ | 少量行 | 非唯一索引等值查询 |
| 5️⃣ | `fulltext` | ⭐⭐⭐⭐ | 相关行 | 全文索引搜索 |
| 6️⃣ | `ref_or_null` | ⭐⭐⭐⭐ | 少量行+NULL | 索引查询包含NULL |
| 7️⃣ | `index_merge` | ⭐⭐⭐ | 中等 | 多索引合并 |
| 8️⃣ | `unique_subquery` | ⭐⭐⭐ | 中等 | 唯一值子查询 |
| 9️⃣ | `index_subquery` | ⭐⭐⭐ | 中等 | 索引子查询 |
| 🔟 | `range` | ⭐⭐⭐ | 范围行 | 范围查询 |
| 1️⃣1️⃣ | `index` | ⭐⭐ | 全部行 | 索引全扫描 |
| 1️⃣2️⃣ | `ALL` | ⭐ | 全部行 | 全表扫描 |

### 6.2 性能影响可视化


**不同访问类型的性能对比**：
```
查询10万行数据的性能对比：

const/eq_ref: [█] 0.1ms           ← 极快
ref:         [██] 1ms             ← 很快  
range:       [████] 10ms          ← 快
index:       [████████] 100ms     ← 中等
ALL:         [████████████████████] 1000ms ← 慢
```

### 6.3 实际业务中的分布


**健康系统中type分布建议**：
```
理想的type分布：
🟢 const/eq_ref/ref: 70%+     ← 大部分查询应该在这个级别
🟡 range:           20%       ← 范围查询适量
🟠 index:           5%        ← 少量索引扫描
🔴 ALL:             <5%       ← 全表扫描应该极少

如果ALL超过10%，说明系统需要优化！
```

---

## 7. 🛠️ 实战优化策略


### 7.1 针对性优化建议


**🔴 发现ALL访问时的优化步骤**：

**步骤 1️⃣：分析查询条件**
```sql
-- 问题查询
EXPLAIN SELECT * FROM orders 
WHERE YEAR(create_time) = 2024 AND customer_name LIKE '%张%';

-- 分析问题：
❌ YEAR(create_time) 使用了函数
❌ LIKE '%张%' 是中间模糊查询
❌ 导致无法使用索引
```

**步骤 2️⃣：重写查询条件**
```sql
-- 优化后的查询
EXPLAIN SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01'
  AND customer_name LIKE '张%';

-- 优化要点：
✅ 避免函数，使用范围查询
✅ 前缀模糊查询可以使用索引
✅ 考虑添加组合索引
```

**步骤 3️⃣：添加合适索引**
```sql
-- 添加组合索引
CREATE INDEX idx_orders_time_customer 
ON orders(create_time, customer_name);

-- 索引选择原则：
📊 区分度高的列放前面
📈 查询频率高的组合优先
🎯 覆盖索引能避免回表
```

### 7.2 常见优化模式


**🔹 等值查询优化**：
```sql
-- 优化前：ALL访问
SELECT * FROM users WHERE status = 'active';

-- 优化方案：
1️⃣ 添加索引：CREATE INDEX idx_status ON users(status);
2️⃣ 结果：ref访问，性能提升100倍

-- 进一步优化：组合索引
CREATE INDEX idx_status_create_time ON users(status, create_time);
-- 支持多种查询模式
```

**🔹 范围查询优化**：
```sql
-- 优化前：可能ALL访问
SELECT * FROM orders WHERE total_amount BETWEEN 100 AND 1000;

-- 优化方案：
1️⃣ 添加索引：CREATE INDEX idx_amount ON orders(total_amount);  
2️⃣ 结果：range访问

-- 注意事项：
💡 范围查询会阻断组合索引的后续列使用
💡 合理设计索引列的顺序很重要
```

**🔹 JOIN查询优化**：
```sql
-- 优化前：可能出现ALL
SELECT u.name, o.total 
FROM users u 
JOIN orders o ON u.id = o.user_id
WHERE u.status = 'active';

-- 优化方案：
1️⃣ users表：CREATE INDEX idx_status ON users(status);
2️⃣ orders表：CREATE INDEX idx_user_id ON orders(user_id);
3️⃣ 结果：users表ref访问，orders表eq_ref访问
```

### 7.3 监控和维护


**🔍 定期性能检查**：
```sql
-- 查找慢查询中的ALL访问
SELECT 
    sql_text,
    exec_count,
    avg_timer_wait/1000000000 as avg_time_seconds
FROM performance_schema.events_statements_summary_by_digest 
WHERE sql_text LIKE '%SELECT%' 
  AND avg_timer_wait > 1000000000  -- 超过1秒的查询
ORDER BY avg_timer_wait DESC;
```

**📊 建立性能基线**：
```
性能监控指标：
📈 平均查询时间      目标：<100ms
📊 慢查询比例        目标：<1%  
🎯 ALL访问比例       目标：<5%
💾 索引命中率        目标：>95%
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 type访问类型：MySQL查找数据的方式，直接影响查询性能
🔸 性能排序：const > eq_ref > ref > range > index > ALL
🔸 优化目标：尽量让查询使用const、eq_ref、ref访问类型
🔸 避免ALL：全表扫描是性能杀手，必须重点优化
🔸 索引是关键：合适的索引是获得好的访问类型的基础
```

### 8.2 关键理解要点


**🔹 访问类型的本质理解**
```
访问类型反映的是：
- MySQL如何定位数据
- 需要扫描多少行  
- 查询效率高低

理解这个本质，就能明白为什么要优化！
```

**🔹 索引与访问类型的关系**
```
索引类型 → 访问类型 → 性能表现

主键索引      → const      → 极快
唯一索引      → const      → 极快  
普通索引      → ref        → 很快
组合索引      → ref/range  → 快
无索引       → ALL        → 慢
```

**🔹 优化思路**
```
发现问题：通过EXPLAIN查看type
分析原因：为什么是这种访问类型？
制定方案：添加索引？重写查询？
验证效果：再次EXPLAIN确认优化效果
持续监控：定期检查性能变化
```

### 8.3 实际应用价值


**💼 业务场景应用**
- **电商系统**：订单查询、商品检索必须避免ALL访问
- **用户系统**：登录验证、用户信息查询要达到const级别
- **日志分析**：时间范围查询要确保使用range访问
- **报表系统**：聚合查询要合理使用索引避免全表扫描

**🔧 优化实践**
- **开发阶段**：每个查询都要EXPLAIN检查访问类型
- **测试阶段**：模拟生产数据量测试性能表现  
- **上线后**：持续监控慢查询，重点关注ALL访问
- **维护期**：定期分析查询模式，优化索引设计

**核心记忆**：
- type字段是SQL性能的晴雨表，const最优，ALL最差
- 合适的索引是获得良好访问类型的关键
- 避免函数、运算、中间模糊查询等导致索引失效
- 定期监控和优化，保持系统性能在最佳状态