---
title: 26、Performance Schema监控
---
## 📚 目录

1. [Performance Schema基础概念](#1-performance-schema基础概念)
2. [核心监控表详解](#2-核心监控表详解)
3. [sys视图高效使用](#3-sys视图高效使用)
4. [实时监控配置](#4-实时监控配置)
5. [历史数据管理](#5-历史数据管理)
6. [性能开销控制](#6-性能开销控制)
7. [监控实战案例](#7-监控实战案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 Performance Schema基础概念


### 1.1 什么是Performance Schema


**🔸 简单理解**
```
Performance Schema就像MySQL的"体检报告生成器"：
• 实时记录：数据库里发生的所有操作
• 详细分析：每条SQL的执行情况
• 性能诊断：找出慢查询和瓶颈
• 零干扰：记录过程不影响正常业务

就像汽车的行车记录仪，记录所有驾驶行为供后续分析
```

**💡 核心作用**
- **实时监控** - 捕获正在执行的SQL语句
- **历史追踪** - 保存最近的查询执行记录  
- **性能分析** - 统计查询次数、耗时、资源使用
- **问题定位** - 快速找到性能瓶颈和异常查询

### 1.2 Performance Schema vs 慢查询日志


```
对比分析：
                    Performance Schema    慢查询日志
实时性               ✅ 实时查看           ❌ 需要解析日志
查询历史             ✅ 结构化存储         ❌ 文本格式
统计分析             ✅ 自动统计          ❌ 需要工具分析
系统开销             🟡 可控制            🟢 开销较小
查询灵活性           ✅ SQL随意查询        ❌ 格式固定
```

### 1.3 启用Performance Schema


**🔧 检查当前状态**
```sql
-- 检查Performance Schema是否启用
SHOW VARIABLES LIKE 'performance_schema';

-- 查看配置状态
SELECT * FROM performance_schema.setup_actors;
SELECT * FROM performance_schema.setup_consumers;
```

**⚙️ 配置启用**
```ini
# my.cnf配置文件
[mysqld]
performance_schema = ON
performance_schema_max_table_instances = 500
performance_schema_events_statements_history_size = 20
performance_schema_events_statements_history_long_size = 1000
```

---

## 2. 📊 核心监控表详解


### 2.1 events_statements_summary_by_digest表


**🔸 表的作用**
```
这张表就像"SQL指纹档案馆"：
• 每条不同的SQL都有唯一指纹(digest)
• 记录每种SQL的执行统计信息
• 自动去除参数值，专注于SQL结构
• 提供丰富的性能指标

例如：SELECT * FROM users WHERE id = 1 和 SELECT * FROM users WHERE id = 999
会被认为是同一类SQL，共享一个digest
```

**📈 关键字段解析**
```sql
-- 查看表结构和重要字段
DESC performance_schema.events_statements_summary_by_digest;

重要字段说明：
• SCHEMA_NAME：数据库名
• DIGEST：SQL指纹（MD5哈希值）
• DIGEST_TEXT：SQL语句模板
• COUNT_STAR：执行次数
• SUM_TIMER_WAIT：总耗时（纳秒）
• AVG_TIMER_WAIT：平均耗时
• MAX_TIMER_WAIT：最大耗时
• SUM_ROWS_EXAMINED：扫描行数总计
• SUM_ROWS_SENT：返回行数总计
```

**🎯 实用查询示例**
```sql
-- 找出执行最频繁的SQL
SELECT 
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR as 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000, 2) as 平均耗时秒,
    ROUND(SUM_TIMER_WAIT/1000000000, 2) as 总耗时秒
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL
ORDER BY COUNT_STAR DESC 
LIMIT 10;

-- 找出平均耗时最长的SQL
SELECT 
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 100) as SQL语句,
    COUNT_STAR as 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000, 2) as 平均耗时秒
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;
```

### 2.2 events_statements_history表


**🔸 表的作用**
```
这张表像"最近通话记录"：
• 保存每个连接最近执行的SQL语句
• 记录详细的执行信息
• 可以看到具体的参数值
• 默认保存每个连接最近10条记录

适合排查具体问题和实时监控
```

**🔍 实用查询示例**
```sql
-- 查看当前正在执行的语句
SELECT 
    t.PROCESSLIST_ID as 连接ID,
    t.PROCESSLIST_USER as 用户,
    t.PROCESSLIST_DB as 数据库,
    LEFT(t.SQL_TEXT, 100) as SQL语句,
    t.TIMER_WAIT/1000000000 as 已执行时间秒
FROM performance_schema.events_statements_current t
WHERE t.SQL_TEXT IS NOT NULL;

-- 查看最近执行的慢查询
SELECT 
    THREAD_ID,
    LEFT(SQL_TEXT, 100) as SQL语句,
    TIMER_WAIT/1000000000 as 执行时间秒,
    ROWS_EXAMINED as 扫描行数,
    ROWS_SENT as 返回行数
FROM performance_schema.events_statements_history 
WHERE TIMER_WAIT > 1000000000  -- 超过1秒
ORDER BY TIMER_WAIT DESC;
```

### 2.3 其他重要监控表


**📋 核心表格总览**
```
表名                              作用                    适用场景
events_statements_current         当前执行语句            实时监控
events_statements_history         历史执行记录            问题排查
events_statements_summary_global  全局SQL统计             整体分析
table_io_waits_summary_by_table   表级IO统计             表访问分析
file_summary_by_instance          文件IO统计             磁盘IO分析
```

---

## 3. 🎛️ sys视图高效使用


### 3.1 statement_analysis视图


**🔸 视图作用**
```
sys.statement_analysis是对原始监控数据的"智能整理"：
• 自动计算平均值、百分比等指标
• 提供人性化的时间显示
• 按影响程度自动排序
• 过滤掉系统内部语句

就像把复杂的体检报告整理成简洁的健康建议
```

**📊 使用示例**
```sql
-- 查看执行次数最多的SQL
SELECT 
    query,
    exec_count as 执行次数,
    avg_latency as 平均延迟,
    total_latency as 总延迟,
    rows_examined_avg as 平均扫描行数
FROM sys.statement_analysis 
ORDER BY exec_count DESC 
LIMIT 10;

-- 查看平均延迟最高的SQL
SELECT 
    LEFT(query, 80) as SQL语句,
    exec_count as 执行次数,
    avg_latency as 平均延迟,
    max_latency as 最大延迟
FROM sys.statement_analysis 
ORDER BY avg_latency DESC 
LIMIT 10;
```

### 3.2 statements_with_runtimes_in_95th_percentile视图


**🔸 视图特点**
```
专门找出"性能异常"的SQL：
• 只显示运行时间在95%分位数以上的语句
• 自动过滤正常的快速查询
• 重点关注真正的性能问题
• 适合日常性能巡检

相当于只看体检报告中的"异常指标"
```

**🎯 使用示例**
```sql
-- 查看95%分位数的慢查询
SELECT 
    LEFT(query, 100) as SQL语句,
    exec_count as 执行次数,
    avg_latency as 平均延迟,
    max_latency as 最大延迟,
    rows_examined_avg as 平均扫描行数
FROM sys.statements_with_runtimes_in_95th_percentile
ORDER BY avg_latency DESC;
```

### 3.3 statements_with_full_table_scans视图


**🔸 视图价值**
```
专门识别"全表扫描"的SQL：
• 没有使用索引的查询
• 扫描行数远大于返回行数
• 通常是性能瓶颈的根源
• 需要优先优化的对象

就像找出所有"不走正门，翻墙进入"的行为
```

**⚡ 使用示例**
```sql
-- 查看全表扫描的SQL
SELECT 
    LEFT(query, 100) as SQL语句,
    exec_count as 执行次数,
    total_latency as 总延迟,
    no_index_used_count as 未使用索引次数,
    rows_examined as 总扫描行数,
    rows_sent as 总返回行数,
    ROUND(rows_examined/rows_sent, 2) as 扫描效率比
FROM sys.statements_with_full_table_scans
ORDER BY total_latency DESC;
```

---

## 4. 🚀 实时监控配置


### 4.1 启用实时监控


**🔧 配置监控消费者**
```sql
-- 启用语句监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%statements%';

-- 启用等待事件监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%events_waits%';

-- 查看当前配置
SELECT NAME, ENABLED 
FROM performance_schema.setup_consumers 
WHERE NAME LIKE '%statements%';
```

**⚙️ 配置监控对象**
```sql
-- 启用所有用户的监控
UPDATE performance_schema.setup_actors 
SET ENABLED = 'YES', HISTORY = 'YES';

-- 只监控特定用户（例如应用用户）
UPDATE performance_schema.setup_actors 
SET ENABLED = 'NO';

INSERT INTO performance_schema.setup_actors 
VALUES ('%', 'app_user', '%', 'YES', 'YES');
```

### 4.2 实时监控查询


**🔍 监控当前执行的SQL**
```sql
-- 创建实时监控视图
CREATE VIEW current_slow_queries AS
SELECT 
    p.ID as 进程ID,
    p.USER as 用户,
    p.DB as 数据库,
    p.TIME as 执行时间秒,
    LEFT(p.INFO, 100) as SQL语句,
    es.TIMER_WAIT/1000000000 as 精确执行时间,
    es.ROWS_EXAMINED as 扫描行数
FROM information_schema.PROCESSLIST p
JOIN performance_schema.events_statements_current es 
    ON p.ID = es.PROCESSLIST_ID
WHERE p.COMMAND = 'Query' 
    AND p.TIME > 1  -- 执行超过1秒
    AND p.INFO IS NOT NULL
ORDER BY p.TIME DESC;

-- 使用监控视图
SELECT * FROM current_slow_queries;
```

**📊 定期监控脚本**
```sql
-- 每分钟执行的监控查询
SELECT 
    CURRENT_TIMESTAMP as 检查时间,
    COUNT(*) as 慢查询数量,
    AVG(TIME) as 平均执行时间,
    MAX(TIME) as 最长执行时间
FROM information_schema.PROCESSLIST 
WHERE COMMAND = 'Query' AND TIME > 2;

-- 如果有异常，详细查看
SELECT * FROM current_slow_queries WHERE 执行时间秒 > 5;
```

### 4.3 自动化监控脚本


**🤖 监控脚本示例**
```bash
#!/bin/bash
# 每分钟检查慢查询

MYSQL_CMD="mysql -u monitor_user -p'password' -h localhost"

# 检查当前慢查询数量
SLOW_COUNT=$($MYSQL_CMD -se "
SELECT COUNT(*) 
FROM information_schema.PROCESSLIST 
WHERE COMMAND='Query' AND TIME > 5"
)

if [ $SLOW_COUNT -gt 0 ]; then
    echo "$(date): 发现 $SLOW_COUNT 个慢查询"
    
    # 记录详细信息
    $MYSQL_CMD -e "
    SELECT 
        ID, USER, DB, TIME, 
        LEFT(INFO, 200) as QUERY 
    FROM information_schema.PROCESSLIST 
    WHERE COMMAND='Query' AND TIME > 5
    " >> /var/log/mysql_slow_monitor.log
fi
```

---

## 5. 🗂️ 历史数据管理


### 5.1 历史数据保留策略


**🔸 数据保留机制**
```
Performance Schema的数据管理：
• 循环覆盖：达到上限后自动覆盖旧数据
• 内存存储：数据存在内存中，重启后丢失
• 容量限制：通过参数控制保留数量
• 自动清理：无需手动维护

类似行车记录仪，存储空间满了就覆盖最早的记录
```

**⚙️ 关键配置参数**
```ini
# 控制历史数据保留量的参数
performance_schema_events_statements_history_size = 10        # 每个连接保留记录数
performance_schema_events_statements_history_long_size = 1000 # 全局历史记录数
performance_schema_max_digest_length = 1024                  # SQL语句最大长度
performance_schema_max_digest_sample_age = 60                # 采样老化时间(秒)
```

### 5.2 手动清理历史数据


**🧹 清理统计数据**
```sql
-- 清空语句统计信息
CALL sys.ps_truncate_all_tables(FALSE);

-- 只清空特定表的数据
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
TRUNCATE TABLE performance_schema.events_statements_history;
TRUNCATE TABLE performance_schema.events_statements_history_long;

-- 重置统计计数器
FLUSH STATUS;
```

**📋 数据导出备份**
```sql
-- 导出重要的统计数据
SELECT 
    CURRENT_TIMESTAMP as 导出时间,
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR,
    ROUND(AVG_TIMER_WAIT/1000000000, 3) as 平均耗时秒,
    ROUND(SUM_TIMER_WAIT/1000000000, 3) as 总耗时秒,
    SUM_ROWS_EXAMINED,
    SUM_ROWS_SENT
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL
    AND COUNT_STAR > 10  -- 只导出执行超过10次的
INTO OUTFILE '/tmp/ps_statements_summary.csv'
FIELDS TERMINATED BY ',' 
LINES TERMINATED BY '\n';
```

### 5.3 历史数据分析


**📊 趋势分析查询**
```sql
-- 创建历史快照表
CREATE TABLE ps_digest_history (
    snapshot_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    schema_name VARCHAR(64),
    digest_text TEXT,
    count_star BIGINT,
    avg_timer_wait BIGINT,
    sum_timer_wait BIGINT
);

-- 定期插入快照数据（可以通过定时任务执行）
INSERT INTO ps_digest_history 
    (schema_name, digest_text, count_star, avg_timer_wait, sum_timer_wait)
SELECT 
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 500),
    COUNT_STAR,
    AVG_TIMER_WAIT,
    SUM_TIMER_WAIT
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL AND COUNT_STAR > 5;
```

---

## 6. ⚡ 性能开销控制


### 6.1 开销影响分析


**🔸 性能开销来源**
```
Performance Schema的开销主要来自：
• 事件采集：每个SQL执行都要记录
• 内存使用：存储监控数据占用内存  
• CPU消耗：计算统计信息需要CPU
• 锁竞争：访问监控表可能产生锁等待

开销大小：通常占总性能的5-15%
```

**📊 开销控制对比**
```
监控级别          CPU开销    内存开销    适用场景
完全关闭          0%         0%         生产环境(不推荐)
最小监控          2-5%       50MB       只监控慢查询
标准监控          5-10%      100MB      日常性能分析  
详细监控          10-15%     200MB      深度问题排查
```

### 6.2 精细化配置


**🎛️ 选择性启用监控**
```sql
-- 只监控特定的事件类型
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'NO';

-- 只启用SQL语句监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'statement/%';

-- 关闭文件IO监控（减少开销）
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'NO' 
WHERE NAME LIKE 'wait/io/file/%';
```

**⚙️ 消费者精确控制**
```sql
-- 最小化配置：只监控当前语句
UPDATE performance_schema.setup_consumers SET ENABLED = 'NO';
UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' 
WHERE NAME IN (
    'global_instrumentation',
    'thread_instrumentation', 
    'statements_digest',
    'events_statements_current'
);

-- 查看当前配置
SELECT NAME, ENABLED 
FROM performance_schema.setup_consumers 
ORDER BY NAME;
```

### 6.3 生产环境最佳实践


**🏭 生产环境推荐配置**
```ini
# 生产环境 my.cnf 配置
[mysqld]
performance_schema = ON

# 控制内存使用
performance_schema_max_table_instances = 200
performance_schema_max_thread_instances = 400  
performance_schema_events_statements_history_size = 5
performance_schema_events_statements_history_long_size = 500

# 限制监控范围
performance_schema_max_digest_length = 512
performance_schema_max_sql_text_length = 512
```

**🔧 运行时优化**
```sql
-- 生产环境启动后执行的优化脚本
-- 关闭不必要的监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'NO' 
WHERE NAME LIKE 'wait/io/file/%'
   OR NAME LIKE 'wait/io/socket/%'
   OR NAME LIKE 'stage/%';

-- 只保留核心监控
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME IN (
    'global_instrumentation',
    'thread_instrumentation',
    'statements_digest', 
    'events_statements_current'
);
```

---

## 7. 🛠️ 监控实战案例


### 7.1 Case 1：定位突发慢查询


**🚨 问题场景**
```
业务反馈：系统突然变慢，响应时间从100ms增加到3秒
需要快速定位：哪些SQL导致了性能下降
```

**🔍 排查步骤**
```sql
-- 步骤1：查看当前正在执行的慢查询
SELECT 
    p.ID,
    p.USER,
    p.DB,
    p.TIME as 执行时间秒,
    LEFT(p.INFO, 150) as SQL语句
FROM information_schema.PROCESSLIST p
WHERE p.COMMAND = 'Query' AND p.TIME > 2
ORDER BY p.TIME DESC;

-- 步骤2：查看最近的慢查询统计
SELECT 
    LEFT(DIGEST_TEXT, 100) as SQL模板,
    COUNT_STAR as 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000, 2) as 平均耗时秒,
    ROUND(MAX_TIMER_WAIT/1000000000, 2) as 最大耗时秒,
    FIRST_SEEN as 首次发现,
    LAST_SEEN as 最后执行
FROM performance_schema.events_statements_summary_by_digest 
WHERE LAST_SEEN > DATE_SUB(NOW(), INTERVAL 10 MINUTE)
    AND AVG_TIMER_WAIT > 1000000000  -- 平均超过1秒
ORDER BY AVG_TIMER_WAIT DESC;

-- 步骤3：查看具体的执行历史
SELECT 
    SQL_TEXT,
    TIMER_WAIT/1000000000 as 执行时间秒,
    ROWS_EXAMINED,
    ROWS_SENT,
    EVENT_NAME
FROM performance_schema.events_statements_history 
WHERE TIMER_WAIT > 2000000000  -- 超过2秒
ORDER BY TIMER_START DESC
LIMIT 20;
```

### 7.2 Case 2：分析高频查询优化


**📊 分析目标**
```
目标：找出执行最频繁的查询，评估优化价值
思路：执行次数多 × 单次耗时 = 总体影响
```

**📈 分析查询**
```sql
-- 计算查询的总体影响度
SELECT 
    SCHEMA_NAME as 数据库,
    LEFT(DIGEST_TEXT, 100) as SQL模板,
    COUNT_STAR as 执行次数,
    ROUND(AVG_TIMER_WAIT/1000000000, 3) as 平均耗时秒,
    ROUND(SUM_TIMER_WAIT/1000000000, 3) as 总耗时秒,
    ROUND(SUM_TIMER_WAIT/1000000000 * 100.0 / 
          (SELECT SUM(SUM_TIMER_WAIT) FROM performance_schema.events_statements_summary_by_digest), 2) as 占总时间百分比,
    SUM_ROWS_EXAMINED as 总扫描行数,
    ROUND(SUM_ROWS_EXAMINED/COUNT_STAR, 0) as 平均扫描行数
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;

-- 找出扫描效率最低的查询
SELECT 
    LEFT(DIGEST_TEXT, 100) as SQL模板,
    COUNT_STAR as 执行次数,
    SUM_ROWS_EXAMINED as 总扫描行数,
    SUM_ROWS_SENT as 总返回行数,
    ROUND(SUM_ROWS_EXAMINED/SUM_ROWS_SENT, 2) as 扫描效率比,
    ROUND(SUM_TIMER_WAIT/1000000000, 2) as 总耗时秒
FROM performance_schema.events_statements_summary_by_digest 
WHERE SCHEMA_NAME IS NOT NULL 
    AND SUM_ROWS_SENT > 0
    AND COUNT_STAR > 100  -- 执行次数超过100
HAVING 扫描效率比 > 10  -- 扫描行数是返回行数的10倍以上
ORDER BY 扫描效率比 DESC;
```

### 7.3 Case 3：制作监控大屏


**📺 监控大屏查询**
```sql
-- 实时性能概览
SELECT 
    '当前活跃查询' as 指标,
    COUNT(*) as 数值
FROM information_schema.PROCESSLIST 
WHERE COMMAND = 'Query'
UNION ALL
SELECT 
    '慢查询(>2秒)',
    COUNT(*)
FROM information_schema.PROCESSLIST 
WHERE COMMAND = 'Query' AND TIME > 2
UNION ALL
SELECT 
    '今日SQL总执行次数',
    SUM(COUNT_STAR)
FROM performance_schema.events_statements_summary_by_digest
UNION ALL  
SELECT 
    '平均查询响应时间(秒)',
    ROUND(AVG(AVG_TIMER_WAIT)/1000000000, 3)
FROM performance_schema.events_statements_summary_by_digest
WHERE COUNT_STAR > 0;

-- Top 5 最耗时SQL类型
SELECT 
    CONCAT('Top', @row_number := @row_number + 1) as 排名,
    LEFT(DIGEST_TEXT, 80) as SQL类型,
    ROUND(SUM_TIMER_WAIT/1000000000, 2) as 总耗时秒,
    COUNT_STAR as 执行次数
FROM performance_schema.events_statements_summary_by_digest,
     (SELECT @row_number := 0) r
WHERE SCHEMA_NAME IS NOT NULL
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 5;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


🔸 **Performance Schema本质**：MySQL的内置性能监控系统，实时记录数据库活动
🔸 **核心监控表**：`events_statements_summary_by_digest`(SQL统计)、`events_statements_history`(执行历史)
🔸 **sys视图价值**：对原始数据的智能整理，提供开箱即用的分析视图
🔸 **配置原则**：根据环境需求平衡监控详细度和性能开销
🔸 **数据特点**：内存存储、循环覆盖、重启丢失

### 8.2 关键理解要点


**🔹 监控表的选择策略**
```
实时问题排查  → events_statements_current
历史执行分析  → events_statements_history  
SQL类型统计  → events_statements_summary_by_digest
性能趋势分析  → sys.statement_analysis
全表扫描检测  → sys.statements_with_full_table_scans
```

**🔹 性能开销控制思路**
```
生产环境原则：
• 最小必要监控：只监控真正需要的事件
• 精确配置消费者：避免记录不必要的历史数据
• 控制保留数量：合理设置历史记录上限
• 定期清理重置：避免统计数据累积过多
```

**🔹 实战应用场景**
```
日常监控：定期检查慢查询统计，识别性能趋势
问题排查：快速定位当前执行的异常SQL
性能优化：分析高频查询和全表扫描，制定优化策略
容量规划：通过历史数据预测性能瓶颈
```

### 8.3 最佳实践指南


**🎯 生产环境配置建议**
- **启用级别**：标准监控（CPU开销5-10%）
- **保留策略**：每连接5条历史，全局500条历史
- **清理频率**：每周重置一次统计数据
- **监控重点**：SQL统计 + 当前执行语句

**🔧 日常运维要点**
- **监控脚本**：自动化检测慢查询和异常
- **定期分析**：每周分析高影响SQL和优化建议
- **数据导出**：重要统计数据定期备份
- **配置调优**：根据业务特点优化监控参数

**⚠️ 使用注意事项**
- Performance Schema数据重启后丢失，重要分析需要及时导出
- 监控本身有性能开销，生产环境需要精细化配置
- `DIGEST_TEXT`会去除参数值，分析时注意SQL的通用性
- 大量监控可能影响内存使用，需要监控MySQL内存状况

**💡 实用技巧汇总**
- 使用sys视图简化复杂查询
- 结合processlist实现实时监控
- 通过历史快照分析性能趋势
- 利用过滤条件减少无效数据干扰

**核心记忆**：
Performance Schema是MySQL性能监控的利器，通过合理配置能够提供强大的实时监控和历史分析能力。关键在于平衡监控详细度和系统开销，针对不同场景选择适当的监控策略。掌握核心监控表和sys视图的使用，能够快速定位性能问题并指导优化工作。