---
title: 17、慢查询性能指标分析
---
## 📚 目录

1. [慢查询性能指标概述](#1-慢查询性能指标概述)
2. [Query_time执行时间分析](#2-query_time执行时间分析)
3. [Lock_time锁等待分析](#3-lock_time锁等待分析)
4. [Rows_examined扫描效率分析](#4-rows_examined扫描效率分析)
5. [Rows_sent结果集分析](#5-rows_sent结果集分析)
6. [扫描比例计算与优化](#6-扫描比例计算与优化)
7. [系统资源关联分析](#7-系统资源关联分析)
8. [性能指标综合评估](#8-性能指标综合评估)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📊 慢查询性能指标概述


### 1.1 什么是慢查询性能指标


**🔸 核心定义**
```
慢查询性能指标：MySQL记录在慢查询日志中的关键性能数据
作用：帮助我们了解SQL执行的详细情况，找出性能瓶颈
目标：通过数据分析，精准定位和解决性能问题
```

想象一下，慢查询性能指标就像是汽车的仪表盘，告诉我们引擎转速、油耗、温度等关键信息，帮助我们判断车子是否正常运行。

### 1.2 慢查询日志格式解析


**💡 典型慢查询日志示例**
```sql
# Time: 2025-09-11T15:30:21.123456Z
# User@Host: app_user[app_user] @ [192.168.1.100]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 2.345678  Lock_time: 0.000123  Rows_sent: 1500  Rows_examined: 250000
# Bytes_sent: 125000
SET timestamp=1694443821;
SELECT * FROM orders o 
JOIN order_items oi ON o.id = oi.order_id 
WHERE o.created_at > '2025-01-01';
```

**📋 关键指标说明**
```
🔸 Query_time：SQL总执行时间
🔸 Lock_time：等待锁的时间  
🔸 Rows_sent：返回给客户端的行数
🔸 Rows_examined：MySQL扫描的行数
🔸 Bytes_sent：返回数据的字节数
🔸 Thread_id：执行线程ID
🔸 QC_hit：是否命中查询缓存
```

### 1.3 性能指标的重要性


**⚡ 为什么要分析这些指标**
```
业务影响维度：
• 响应时间慢：影响用户体验
• 资源消耗高：影响服务器性能
• 并发能力差：影响系统吞吐量

技术优化维度：
• 定位瓶颈：找出真正的问题所在
• 量化改进：用数据证明优化效果
• 预防问题：通过监控及时发现风险
```

---

## 2. ⏱️ Query_time执行时间分析


### 2.1 Query_time基本概念


**🔸 什么是Query_time**
```
定义：SQL语句从开始执行到完成的总时间
单位：秒（精确到微秒）
包含：解析、优化、执行、结果返回等所有环节
```

就像做菜的总用时，包括洗菜、切菜、炒菜、装盘的全过程时间。

### 2.2 执行时间的构成分析


**⏰ 时间构成分解**
```
Query_time = 解析时间 + 优化时间 + 执行时间 + 返回时间

详细分解：
┌─────────────────────────────────────────┐
│              Query_time                 │
├─────────┬─────────┬─────────┬───────────┤
│ 解析阶段 │ 优化阶段 │ 执行阶段 │ 返回阶段   │
│ ~1-5ms │ ~5-50ms │ 主要时间 │ ~1-10ms   │
└─────────┴─────────┴─────────┴───────────┘

执行阶段进一步分解：
• 磁盘IO时间：读取数据页
• CPU计算时间：条件判断、排序等
• 锁等待时间：等待其他事务释放锁
• 网络传输时间：返回结果集
```

### 2.3 执行时间分级评估


**📊 性能等级划分**

| 执行时间范围 | **性能等级** | **影响程度** | **处理建议** |
|-------------|-------------|-------------|-------------|
| `< 0.1秒` | 🟢 **优秀** | `无影响` | `保持现状` |
| `0.1-0.5秒` | 🟡 **良好** | `轻微影响` | `关注监控` |
| `0.5-2秒` | 🟠 **一般** | `明显影响` | `优化建议` |
| `2-5秒` | 🔴 **较差** | `严重影响` | `立即优化` |
| `> 5秒` | ⚫ **很差** | `极严重影响` | `紧急处理` |

### 2.4 执行时间异常分析


**🔍 常见异常模式**
```
波动型异常：
时间: 09:00  09:05  09:10  09:15  09:20
耗时: 0.5s   3.2s   0.6s   2.8s   0.4s
原因: 可能是锁竞争或缓存失效

递增型异常：
时间: 09:00  09:30  10:00  10:30  11:00
耗时: 0.8s   1.2s   1.8s   2.5s   3.1s
原因: 可能是数据量增长或索引碎片

突发型异常：
时间: 09:00  09:05  09:10  09:15  09:20
耗时: 0.5s   0.6s   15.2s  0.4s   0.5s
原因: 可能是临时锁等待或IO阻塞
```

**💊 诊断方法**
```sql
-- 查看最近的慢查询执行时间分布
SELECT 
    CASE 
        WHEN query_time < 0.1 THEN '< 0.1s'
        WHEN query_time < 0.5 THEN '0.1-0.5s'
        WHEN query_time < 2.0 THEN '0.5-2s'
        WHEN query_time < 5.0 THEN '2-5s'
        ELSE '> 5s'
    END AS time_range,
    COUNT(*) AS query_count,
    ROUND(AVG(query_time), 3) AS avg_time
FROM mysql.slow_log 
WHERE start_time > NOW() - INTERVAL 1 DAY
GROUP BY time_range
ORDER BY avg_time;
```

---

## 3. 🔒 Lock_time锁等待分析


### 3.1 Lock_time基本概念


**🔸 什么是Lock_time**
```
定义：SQL执行过程中等待获取锁的总时间
重要性：锁等待是影响并发性能的关键因素
测量：从请求锁到获得锁的时间差
```

可以想象成排队买票的等待时间，队伍越长，等待时间越久。

### 3.2 锁等待时间分析框架


**🔓 锁等待构成**
```
Lock_time包含的等待类型：

表级锁等待：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  Session A  │───▶│  Table Lock │◀───│  Session B  │
│   UPDATE    │    │   (MyISAM)  │    │   SELECT    │
└─────────────┘    └─────────────┘    └─────────────┘

行级锁等待：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  Session A  │───▶│  Row Lock   │◀───│  Session B  │
│   UPDATE    │    │  (InnoDB)   │    │   UPDATE    │
└─────────────┘    └─────────────┘    └─────────────┘

元数据锁等待：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  Session A  │───▶│  MDL Lock   │◀───│  Session B  │
│   DDL操作   │    │ (表结构锁)   │    │   DML操作   │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 3.3 锁等待时间评估标准


**⏳ 等待时间分级**

| Lock_time范围 | **严重程度** | **并发影响** | **处理优先级** |
|--------------|-------------|-------------|---------------|
| `< 0.01秒` | 🟢 **正常** | `无影响` | `正常监控` |
| `0.01-0.1秒` | 🟡 **轻微** | `轻微影响` | `关注趋势` |
| `0.1-1秒` | 🟠 **中等** | `明显影响` | `分析原因` |
| `1-5秒` | 🔴 **严重** | `严重影响` | `立即处理` |
| `> 5秒` | ⚫ **极严重** | `阻塞严重` | `紧急响应` |

### 3.4 锁等待问题诊断


**🔍 诊断锁等待问题**
```sql
-- 分析锁等待时间分布
SELECT 
    DATE(start_time) AS date,
    CASE 
        WHEN lock_time < 0.01 THEN '< 0.01s'
        WHEN lock_time < 0.1 THEN '0.01-0.1s'
        WHEN lock_time < 1.0 THEN '0.1-1s'
        WHEN lock_time < 5.0 THEN '1-5s'
        ELSE '> 5s'
    END AS lock_time_range,
    COUNT(*) AS count,
    ROUND(AVG(lock_time), 4) AS avg_lock_time,
    ROUND(MAX(lock_time), 4) AS max_lock_time
FROM mysql.slow_log 
WHERE start_time > NOW() - INTERVAL 7 DAY
GROUP BY date, lock_time_range
ORDER BY date DESC, avg_lock_time DESC;
```

**💡 优化策略**
```
减少锁等待的方法：

事务优化：
• 缩短事务执行时间
• 避免长时间持有锁
• 合理设计事务边界

索引优化：
• 添加合适索引减少扫描范围
• 避免全表扫描造成的锁竞争

查询优化：
• 优化查询逻辑减少锁持有时间
• 使用覆盖索引避免回表锁等待
```

---

## 4. 🔍 Rows_examined扫描效率分析


### 4.1 Rows_examined基本概念


**🔸 什么是Rows_examined**
```
定义：MySQL为执行查询而检查的行数
重要性：反映查询的扫描效率和索引使用情况
理想状态：扫描行数应该接近返回行数
```

就像在图书馆找书，`Rows_examined`是你翻过的所有书，理想情况下应该只翻你需要的那几本书。

### 4.2 扫描行数分析框架


**📊 扫描效率评估模型**
```
扫描效率 = Rows_sent / Rows_examined

效率等级划分：
┌─────────────────────────────────────────┐
│              扫描效率分析               │
├─────────────┬───────────┬───────────────┤
│ 效率比例     │ 性能等级   │ 优化建议       │
├─────────────┼───────────┼───────────────┤
│ > 50%       │ 🟢 优秀    │ 保持现状       │
│ 20% - 50%   │ 🟡 良好    │ 适度优化       │
│ 5% - 20%    │ 🟠 一般    │ 重点优化       │
│ 1% - 5%     │ 🔴 较差    │ 立即优化       │
│ < 1%        │ ⚫ 很差     │ 紧急重构       │
└─────────────┴───────────┴───────────────┘
```

### 4.3 扫描行数异常模式识别


**🚨 常见异常模式**
```
全表扫描模式：
Query: SELECT * FROM users WHERE nickname = 'John'
Rows_examined: 1,000,000  Rows_sent: 1
问题: 缺少nickname字段索引

索引失效模式：
Query: SELECT * FROM orders WHERE DATE(created_at) = '2025-01-01'
Rows_examined: 500,000   Rows_sent: 1,200
问题: 函数使用导致索引失效

JOIN表过大模式：
Query: SELECT * FROM orders o JOIN order_items oi ON o.id = oi.order_id
Rows_examined: 10,000,000  Rows_sent: 5,000
问题: 没有合适的JOIN条件索引
```

### 4.4 扫描效率优化策略


**⚡ 提升扫描效率的方法**
```
索引优化策略：

1. 单字段索引
-- 原查询：扫描100万行，返回1行
SELECT * FROM users WHERE email = 'user@example.com';

-- 优化：添加索引
CREATE INDEX idx_users_email ON users(email);
-- 结果：扫描1行，返回1行

2. 组合索引
-- 原查询：扫描50万行，返回100行
SELECT * FROM orders WHERE status = 'completed' AND created_at > '2025-01-01';

-- 优化：创建组合索引
CREATE INDEX idx_orders_status_created ON orders(status, created_at);
-- 结果：扫描100行，返回100行

3. 覆盖索引
-- 原查询：需要回表查询
SELECT id, name, email FROM users WHERE age BETWEEN 25 AND 35;

-- 优化：创建覆盖索引
CREATE INDEX idx_users_age_covering ON users(age, id, name, email);
-- 结果：无需回表，大幅减少扫描
```

**📈 效果对比示例**
```
优化前后对比：

优化前：
├─ Query_time: 2.5s
├─ Rows_examined: 1,000,000
├─ Rows_sent: 100
└─ 效率比例: 0.01% (很差)

优化后：
├─ Query_time: 0.05s
├─ Rows_examined: 100
├─ Rows_sent: 100
└─ 效率比例: 100% (优秀)
```

---

## 5. 📤 Rows_sent结果集分析


### 5.1 Rows_sent基本概念


**🔸 什么是Rows_sent**
```
定义：MySQL返回给客户端的行数
意义：反映查询结果集的大小
影响：直接影响网络传输和客户端处理时间
```

就像快递包裹的数量，包裹越多，运输时间越长，收货处理也越费时。

### 5.2 结果集大小分析


**📦 结果集分级标准**

| Rows_sent范围 | **数据规模** | **网络影响** | **优化建议** |
|--------------|-------------|-------------|-------------|
| `< 100行` | 🟢 **小结果集** | `无影响` | `正常使用` |
| `100-1000行` | 🟡 **中结果集** | `轻微影响` | `考虑分页` |
| `1000-10000行` | 🟠 **大结果集** | `明显影响` | `必须分页` |
| `10000-100000行` | 🔴 **超大结果集** | `严重影响` | `重新设计` |
| `> 100000行` | ⚫ **海量结果集** | `极严重影响` | `架构调整` |

### 5.3 结果集过大的问题分析


**⚠️ 大结果集带来的问题**
```
性能问题链条：

数据库端：
┌─────────────────┐
│  大量数据读取    │ → 消耗大量IO和CPU
├─────────────────┤
│  内存缓冲区占用  │ → 影响其他查询性能
├─────────────────┤
│  锁持有时间长    │ → 影响并发性能
└─────────────────┘

网络传输：
┌─────────────────┐
│  传输时间长      │ → 用户等待时间增加
├─────────────────┤
│  网络带宽占用    │ → 影响其他请求
├─────────────────┤
│  传输中断风险    │ → 数据完整性问题
└─────────────────┘

客户端：
┌─────────────────┐
│  内存占用大      │ → 可能导致OOM
├─────────────────┤
│  处理时间长      │ → 界面响应慢
├─────────────────┤
│  渲染性能差      │ → 用户体验差
└─────────────────┘
```

### 5.4 结果集优化策略


**📊 分页查询优化**
```sql
-- 传统分页（深分页性能差）
SELECT * FROM orders 
ORDER BY created_at DESC 
LIMIT 50000, 20;  -- 扫描50020行，返回20行

-- 游标分页（推荐方式）
SELECT * FROM orders 
WHERE id < 12345 
ORDER BY id DESC 
LIMIT 20;  -- 扫描20行，返回20行

-- 基于时间的分页
SELECT * FROM orders 
WHERE created_at < '2025-09-10 10:00:00' 
ORDER BY created_at DESC 
LIMIT 20;
```

**🎯 字段选择优化**
```sql
-- 避免SELECT *（传输大量无用数据）
SELECT * FROM products WHERE category_id = 1;

-- 只选择需要的字段
SELECT id, name, price FROM products WHERE category_id = 1;

-- 统计查询优化
-- 原：返回所有记录再计数
SELECT * FROM orders WHERE status = 'completed';

-- 优化：直接计数
SELECT COUNT(*) FROM orders WHERE status = 'completed';
```

---

## 6. 📐 扫描比例计算与优化


### 6.1 扫描比例的计算方法


**🔸 核心计算公式**
```
扫描效率比例 = (Rows_sent / Rows_examined) × 100%

扫描倍数 = Rows_examined / Rows_sent

浪费比例 = ((Rows_examined - Rows_sent) / Rows_examined) × 100%
```

### 6.2 扫描比例分析实例


**📊 实际案例分析**
```
案例1：用户查询优化前后对比

优化前：
Query: SELECT * FROM users WHERE age > 25 AND city = 'Beijing'
├─ Rows_examined: 1,000,000
├─ Rows_sent: 5,000
├─ 扫描效率: 0.5%
├─ 扫描倍数: 200倍
└─ 浪费比例: 99.5%

优化后：添加组合索引 (city, age)
├─ Rows_examined: 5,000
├─ Rows_sent: 5,000  
├─ 扫描效率: 100%
├─ 扫描倍数: 1倍
└─ 浪费比例: 0%

性能提升：
• 查询时间：从3.2秒降到0.02秒
• 扫描效率：从0.5%提升到100%
• IO减少：减少99.5%的无效扫描
```

### 6.3 扫描比例优化策略


**🎯 基于扫描比例的优化方案**
```
扫描比例 < 1%（极差）：
└─ 紧急优化措施
   ├─ 检查是否缺少索引
   ├─ 分析WHERE条件选择性
   ├─ 考虑查询重写
   └─ 评估业务逻辑合理性

扫描比例 1%-5%（较差）：
└─ 重点优化措施  
   ├─ 优化现有索引
   ├─ 添加组合索引
   ├─ 调整查询条件
   └─ 使用覆盖索引

扫描比例 5%-20%（一般）：
└─ 适度优化措施
   ├─ 微调索引结构
   ├─ 优化排序字段
   ├─ 考虑分页查询
   └─ 监控性能趋势

扫描比例 > 50%（良好）：
└─ 维护监控
   ├─ 保持现状
   ├─ 定期监控
   └─ 预防性维护
```

---

## 7. 💻 系统资源关联分析


### 7.1 CPU使用率关联分析


**🔸 CPU与慢查询的关系**
```
CPU使用率分析维度：

查询复杂度影响：
┌─────────────────────────────────────────┐
│              CPU消耗模式               │
├─────────────┬───────────┬───────────────┤
│ 查询类型     │ CPU特征   │ 优化重点       │
├─────────────┼───────────┼───────────────┤
│ 简单查询     │ 低CPU     │ IO优化为主     │
│ 复杂JOIN    │ 高CPU     │ 算法优化       │
│ 大排序操作   │ 峰值CPU   │ 内存/索引优化  │
│ 聚合计算     │ 持续高CPU │ 预计算优化     │
└─────────────┴───────────┴───────────────┘
```

**📊 CPU使用率监控指标**
```sql
-- 监控CPU密集型慢查询
SELECT 
    sql_text,
    query_time,
    rows_examined,
    rows_sent,
    -- CPU密集度指标（扫描行数/时间）
    ROUND(rows_examined / query_time) AS scan_rate_per_sec,
    -- 效率指标
    ROUND((rows_sent / rows_examined) * 100, 2) AS efficiency_percent
FROM mysql.slow_log 
WHERE query_time > 1.0
ORDER BY scan_rate_per_sec DESC
LIMIT 10;
```

### 7.2 内存使用量分析


**🧠 内存消耗分析框架**
```
内存使用场景分析：

临时表内存：
Query: SELECT DISTINCT large_column FROM big_table ORDER BY large_column
影响: 大量内存用于去重和排序
优化: 添加索引避免临时表

排序缓冲区：
Query: SELECT * FROM orders ORDER BY created_at LIMIT 1000000, 20
影响: sort_buffer_size不足时使用磁盘排序
优化: 游标分页避免大偏移量排序

连接缓冲区：
Query: SELECT * FROM t1 JOIN t2 ON t1.col = t2.col (无索引)
影响: join_buffer_size影响JOIN性能
优化: 添加JOIN字段索引
```

**💾 内存优化配置建议**
```sql
-- 查看内存相关配置
SHOW VARIABLES LIKE '%buffer%';
SHOW VARIABLES LIKE '%cache%';

-- 关键内存参数调优建议
SET GLOBAL sort_buffer_size = 2097152;        -- 2MB，排序缓冲
SET GLOBAL read_buffer_size = 131072;         -- 128KB，顺序读缓冲  
SET GLOBAL read_rnd_buffer_size = 262144;     -- 256KB，随机读缓冲
SET GLOBAL join_buffer_size = 262144;         -- 256KB，JOIN缓冲
```

### 7.3 IO操作统计分析


**💿 IO性能分析模型**
```
IO操作分类及影响：

逻辑IO（内存操作）：
┌─────────────────┐
│   Buffer Pool   │ ← 数据页缓存，命中率高则IO少
├─────────────────┤  
│   Query Cache   │ ← 查询结果缓存（MySQL 8.0已移除）
├─────────────────┤
│   索引缓存      │ ← 索引页缓存，影响索引查找效率
└─────────────────┘

物理IO（磁盘操作）：
┌─────────────────┐
│   数据页读取    │ ← 缓存未命中时的磁盘读取
├─────────────────┤
│   索引页读取    │ ← 索引扫描的磁盘读取  
├─────────────────┤
│   临时文件IO    │ ← 排序、GROUP BY等操作
├─────────────────┤
│   日志文件IO    │ ← binlog、redo log写入
└─────────────────┘
```

**📈 IO优化策略**
```
减少IO的优化方法：

索引优化：
• 合理的索引设计减少数据扫描
• 覆盖索引避免回表查询
• 索引顺序与查询条件匹配

缓存优化：
• 增加InnoDB Buffer Pool大小
• 预热关键数据到内存
• 合理设置查询缓存

查询优化：
• 避免SELECT * 减少数据传输
• 使用LIMIT限制结果集大小
• 优化JOIN顺序和条件
```

### 7.4 网络传输量评估


**🌐 网络传输分析**
```
网络传输量构成：

数据传输量 = Bytes_sent（实际传输字节数）

传输效率评估：
┌─────────────────────────────────────────┐
│             网络传输评估               │
├─────────────┬───────────┬───────────────┤
│ 每行字节数   │ 传输效率   │ 优化建议       │
├─────────────┼───────────┼───────────────┤
│ < 100字节   │ 🟢 高效    │ 保持现状       │
│ 100-500字节 │ 🟡 正常    │ 关注字段选择   │
│ 500-2KB     │ 🟠 偏大    │ 优化字段选择   │
│ 2KB-10KB    │ 🔴 过大    │ 重新设计查询   │
│ > 10KB      │ ⚫ 异常     │ 架构层面优化   │
└─────────────┴───────────┴───────────────┘
```

**🚀 网络传输优化**
```sql
-- 分析平均每行传输字节数
SELECT 
    sql_text,
    rows_sent,
    bytes_sent,
    CASE 
        WHEN rows_sent > 0 THEN ROUND(bytes_sent / rows_sent)
        ELSE 0 
    END AS bytes_per_row,
    query_time
FROM mysql.slow_log 
WHERE start_time > NOW() - INTERVAL 1 DAY
    AND rows_sent > 0
ORDER BY bytes_per_row DESC
LIMIT 20;

-- 优化建议：
-- 1. 避免传输BLOB/TEXT大字段
-- 2. 只SELECT需要的字段
-- 3. 使用分页限制结果集大小
-- 4. 考虑数据压缩传输
```

---

## 8. 📋 性能指标综合评估


### 8.1 综合评分模型


**🎯 性能评分算法**
```
综合性能得分 = 时间得分 × 30% + 效率得分 × 40% + 资源得分 × 30%

各维度得分计算：

时间得分（30%）：
├─ Query_time权重: 70%
├─ Lock_time权重: 30%
└─ 计算公式: 100 - (实际时间/期望时间) × 100

效率得分（40%）：
├─ 扫描效率权重: 60%
├─ 结果集合理性权重: 40%  
└─ 计算公式: (Rows_sent/Rows_examined) × 100

资源得分（30%）：
├─ CPU使用合理性: 40%
├─ 内存使用合理性: 30%
├─ IO效率: 30%
└─ 基于系统资源监控数据计算
```

### 8.2 性能等级判定


**🏆 综合性能等级**

| 综合得分 | **性能等级** | **状态标识** | **处理策略** |
|---------|-------------|-------------|-------------|
| `90-100分` | 🥇 **优秀** | `🟢 健康` | `维护监控` |
| `80-89分` | 🥈 **良好** | `🟡 关注` | `预防性优化` |
| `70-79分` | 🥉 **一般** | `🟠 警告` | `计划优化` |
| `60-69分` | 📉 **较差** | `🔴 告警` | `立即优化` |
| `< 60分` | ❌ **很差** | `⚫ 严重` | `紧急处理` |

### 8.3 问题优先级排序


**🔥 优化优先级矩阵**
```
                  影响范围
                ↑ 广泛    局部 ↓
严重程度  高 ┌─────────┬─────────┐
        ↑  │ P0紧急  │ P1重要  │
          ├─────────┼─────────┤
        低 │ P2一般  │ P3关注  │
          └─────────┴─────────┘

P0级别（紧急）：
• 执行时间 > 10秒 且 影响核心业务
• 扫描效率 < 1% 且 并发量大
• 锁等待 > 5秒 且 阻塞其他查询

P1级别（重要）：
• 执行时间 2-10秒 且 使用频繁
• 扫描效率 1%-5% 且 数据量大
• 锁等待 1-5秒 且 影响用户体验

P2级别（一般）：
• 执行时间 0.5-2秒
• 扫描效率 5%-20%
• 锁等待 0.1-1秒

P3级别（关注）：
• 执行时间 < 0.5秒 但有优化空间
• 扫描效率 > 20% 但可以更好
• 定期监控，预防性维护
```

---

## 9. 📚 核心要点总结


### 9.1 必须掌握的核心指标


```
🔸 Query_time：总执行时间，影响用户体验
🔸 Lock_time：锁等待时间，影响并发性能  
🔸 Rows_examined：扫描行数，反映查询效率
🔸 Rows_sent：返回行数，影响网络传输
🔸 扫描比例：核心效率指标，优化重点
🔸 系统资源：CPU、内存、IO的关联影响
```

### 9.2 关键理解要点


**🔹 性能指标的相互关系**
```
指标关联分析：
Query_time ← 受所有其他指标影响
    ├─ Lock_time ↑ → Query_time ↑
    ├─ Rows_examined ↑ → Query_time ↑  
    ├─ Rows_sent ↑ → 网络传输时间 ↑
    └─ 系统资源不足 → 所有时间 ↑

优化的连锁反应：
减少Rows_examined → 降低IO → 节省CPU → 减少Lock_time → 缩短Query_time
```

**🔹 优化的优先级原则**
```
效率优先：优先解决扫描效率低的问题
影响优先：优先解决影响面广的问题
收益优先：优先解决收益明显的问题
风险优先：优先解决风险高的问题
```

### 9.3 实践应用指南


**🎯 日常监控重点**
- **每日检查**：扫描比例 < 5%的查询
- **每周分析**：执行时间趋势变化
- **每月评估**：系统资源使用情况
- **季度优化**：综合性能提升计划

**🔧 优化实施步骤**
1. **数据收集**：分析慢查询日志和系统指标
2. **问题识别**：找出性能瓶颈和异常模式
3. **方案设计**：制定针对性优化策略
4. **效果验证**：对比优化前后的指标变化
5. **持续监控**：建立长期性能监控机制

**核心记忆**：
- 慢查询性能指标是数据库健康的体检报告
- 扫描效率是最重要的优化方向
- 系统性思考各指标间的关联关系
- 持续监控比一次性优化更重要