---
title: 7、mysqldumpslow工具使用
---
## 📚 目录

1. [mysqldumpslow工具概述](#1-mysqldumpslow工具概述)
2. [基本语法和参数详解](#2-基本语法和参数详解)
3. [排序参数选项深入理解](#3-排序参数选项深入理解)
4. [过滤和限制参数使用](#4-过滤和限制参数使用)
5. [输出结果解读方法](#5-输出结果解读方法)
6. [实际应用场景示例](#6-实际应用场景示例)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 mysqldumpslow工具概述


### 1.1 什么是mysqldumpslow


**定义**：mysqldumpslow是MySQL官方提供的慢查询日志分析工具，专门用来解析和分析慢查询日志文件。

**作用机制图示**：
```
慢查询日志文件 → mysqldumpslow工具 → 分析统计结果
     ↓                  ↓                ↓
[原始日志]         [解析分组]        [排序输出]
- 时间戳           - 相同模式         - 按指定条件
- SQL语句          - 统计汇总         - 显示TOP N
- 执行时间         - 去除参数值       - 格式化展示
```

### 1.2 为什么需要mysqldumpslow


**原始慢查询日志的问题**：
- 📄 **日志文件巨大**：生产环境慢查询日志可能有几GB大小
- 🔄 **重复记录多**：相同SQL模式的查询会重复记录
- 📝 **信息分散**：关键统计信息需要人工计算
- 👀 **可读性差**：原始格式不便于快速定位问题

**mysqldumpslow的解决方案**：
```
问题解决对比：

手工分析 vs mysqldumpslow分析
┌─────────────────┐    ┌─────────────────┐
│ 原始日志文件     │    │ 统计分析结果     │
│ =============== │    │ =============== │
│ 几万行重复SQL   │ → │ 按模式分组统计   │
│ 参数值不同      │    │ 抽象化处理      │
│ 时间分散记录    │    │ 总时间/平均时间  │
│ 无排序无统计    │    │ 按需求排序显示   │
└─────────────────┘    └─────────────────┘
```

### 1.3 工具特点和优势


**核心特点**：
- ✅ **官方工具**：MySQL自带，无需额外安装
- ✅ **自动分组**：相同SQL模式自动归类统计
- ✅ **多维排序**：支持按时间、次数、锁定时间等排序
- ✅ **灵活过滤**：支持正则表达式和条件过滤
- ✅ **格式化输出**：结果清晰易读

---

## 2. 📋 基本语法和参数详解


### 2.1 基本语法结构


**标准语法格式**：
```bash
mysqldumpslow [选项参数] 慢查询日志文件
```

**简单使用示例**：
```bash
# 最基本的用法
mysqldumpslow /var/log/mysql/slow.log

# 分析多个日志文件
mysqldumpslow /var/log/mysql/slow.log /var/log/mysql/slow.log.1
```

### 2.2 核心参数分类


**参数功能分类图**：
```
mysqldumpslow参数体系
├── 排序控制 (-s)
│   ├── t: 按总时间排序
│   ├── c: 按执行次数排序  
│   ├── l: 按锁定时间排序
│   └── at/ac/al: 按平均值排序
├── 数量控制 (-t)
│   └── 限制显示条数
├── 抽象化控制 (-a, -n)
│   ├── -a: 抽象化数字和字符串
│   └── -n: 抽象化数字
├── 过滤控制 (-g, -h, -i)
│   ├── -g: 正则表达式过滤
│   ├── -h: 主机名过滤
│   └── -i: 忽略大小写
└── 其他控制
    ├── -r: 反向排序
    ├── -l: 锁定时间统计
    └── -v: 详细模式
```

### 2.3 参数详细说明表


| 参数 | **完整形式** | **作用说明** | **使用场景** |
|------|-------------|-------------|-------------|
| `-s` | `--sort` | `指定排序方式` | `找出最耗时/最频繁的查询` |
| `-t` | `--top` | `显示前N条记录` | `只关注TOP问题查询` |
| `-a` | `--abstract` | `抽象化所有数字和字符串` | `通用SQL模式分析` |
| `-n` | `--number-abstract` | `只抽象化数字` | `保留字符串差异分析` |
| `-g` | `--grep` | `正则表达式过滤` | `特定模式查询分析` |
| `-h` | `--host` | `主机名过滤` | `特定主机问题分析` |
| `-i` | `--ignore-case` | `忽略大小写` | `大小写不敏感匹配` |
| `-r` | `--reverse` | `反向排序` | `查看最少出现的查询` |

---

## 3. 🔄 排序参数选项深入理解


### 3.1 -s排序参数详解


**排序方式对比表**：

| 排序选项 | **含义** | **适用场景** | **示例命令** |
|---------|---------|-------------|-------------|
| `t` | `总执行时间` | `找出总耗时最多的SQL` | `mysqldumpslow -s t slow.log` |
| `c` | `执行次数` | `找出执行最频繁的SQL` | `mysqldumpslow -s c slow.log` |
| `l` | `总锁定时间` | `找出锁定时间最长的SQL` | `mysqldumpslow -s l slow.log` |
| `at` | `平均执行时间` | `找出单次最耗时的SQL` | `mysqldumpslow -s at slow.log` |
| `ac` | `平均执行次数` | `一般不常用` | `mysqldumpslow -s ac slow.log` |
| `al` | `平均锁定时间` | `找出平均锁定最长的SQL` | `mysqldumpslow -s al slow.log` |

### 3.2 排序选择策略


**不同问题的排序策略**：

```
性能问题诊断流程：

问题类型判断
├── 总体性能差 → 使用 -s t (总时间排序)
│   └── 找出总耗时最多的查询类型
├── 频繁慢查询 → 使用 -s c (次数排序) 
│   └── 找出执行最频繁的慢查询
├── 单次很慢 → 使用 -s at (平均时间排序)
│   └── 找出单次执行最耗时的查询
└── 锁等待问题 → 使用 -s l (锁定时间排序)
    └── 找出造成锁等待的查询
```

### 3.3 实际排序示例对比


**相同日志不同排序结果**：
```bash
# 按总时间排序 - 关注总体影响
mysqldumpslow -s t -t 3 slow.log
# 输出：可能显示一个执行1000次，每次1秒的查询

# 按平均时间排序 - 关注单次性能
mysqldumpslow -s at -t 3 slow.log  
# 输出：可能显示一个执行1次，但花费100秒的查询

# 按执行次数排序 - 关注频率
mysqldumpslow -s c -t 3 slow.log
# 输出：显示执行次数最多的查询，即使单次时间不长
```

---

## 4. 🔧 过滤和限制参数使用


### 4.1 -t显示条数限制


**基本使用**：
```bash
# 只显示前5条最慢的查询
mysqldumpslow -s t -t 5 slow.log

# 只显示前10条最频繁的查询  
mysqldumpslow -s c -t 10 slow.log
```

**数量选择建议**：
- 🔸 **初步分析**：`-t 5` 快速了解主要问题
- 🔸 **详细分析**：`-t 20` 全面了解慢查询分布
- 🔸 **全量分析**：不使用`-t`参数，查看所有结果

### 4.2 -a和-n抽象化处理


**抽象化的含义和作用**：

> 💡 **什么是抽象化**：将SQL中的具体数值和字符串替换成占位符，让相同模式的SQL能够归类统计

**对比示例**：
```sql
-- 原始SQL（未抽象化）
SELECT * FROM users WHERE id = 1001 AND name = 'zhang';
SELECT * FROM users WHERE id = 2002 AND name = 'wang'; 
SELECT * FROM users WHERE id = 3003 AND name = 'li';

-- 使用-a参数抽象化后
SELECT * FROM users WHERE id = N AND name = 'S';

-- 使用-n参数抽象化后  
SELECT * FROM users WHERE id = N AND name = 'zhang';
SELECT * FROM users WHERE id = N AND name = 'wang';
SELECT * FROM users WHERE id = N AND name = 'li';
```

**参数使用场景**：
```bash
# -a参数：完全抽象化，适合通用模式分析
mysqldumpslow -s t -a slow.log

# -n参数：只抽象数字，适合保留字符串差异
mysqldumpslow -s t -n slow.log  

# 不使用抽象化：查看具体SQL（日志文件小时）
mysqldumpslow -s t slow.log
```

### 4.3 -g正则表达式过滤


**正则过滤的实际应用**：

```bash
# 只分析包含SELECT的查询
mysqldumpslow -g "SELECT" slow.log

# 只分析特定表的查询
mysqldumpslow -g "FROM users" slow.log

# 只分析UPDATE或DELETE操作
mysqldumpslow -g "UPDATE|DELETE" slow.log

# 只分析包含JOIN的复杂查询
mysqldumpslow -g "JOIN" slow.log

# 分析特定数据库的查询
mysqldumpslow -g "database_name\." slow.log
```

**正则表达式常用模式**：
```
业务场景正则模式：
├── 表操作过滤
│   ├── "FROM table_name" - 特定表查询
│   ├── "UPDATE.*SET" - 更新操作
│   └── "INSERT INTO" - 插入操作
├── 查询类型过滤  
│   ├── "SELECT.*COUNT" - 统计查询
│   ├── "ORDER BY" - 排序查询
│   └── "GROUP BY" - 分组查询
└── 复杂度过滤
    ├── "JOIN.*JOIN" - 多表关联
    ├── "UNION" - 联合查询
    └── "SUBQUERY|EXISTS" - 子查询
```

### 4.4 -h主机名过滤和-i大小写


**主机名过滤应用**：
```bash
# 只分析来自特定主机的慢查询
mysqldumpslow -h "192.168.1.100" slow.log

# 分析来自应用服务器的查询
mysqldumpslow -h "app-server" slow.log
```

**大小写处理**：
```bash
# 忽略大小写进行匹配（推荐）
mysqldumpslow -i -g "select|SELECT" slow.log

# 等同于
mysqldumpslow -g "(?i)select" slow.log
```

---

## 5. 📊 输出结果解读方法


### 5.1 输出格式详解


**标准输出格式示例**：
```
Count: 152  Time=2.34s (355s)  Lock=0.00s (0s)  Rows=1.0 (152), root[root]@[localhost]
  SELECT * FROM users WHERE id = N
```

### 5.2 字段含义详细解释


**输出字段解读表**：

| 字段 | **含义** | **计算方式** | **分析价值** |
|------|---------|-------------|-------------|
| `Count` | `该SQL模式执行次数` | `日志中相同模式SQL的总数` | `频率分析，找高频查询` |
| `Time` | `平均执行时间(总时间)` | `总时间/执行次数 (总时间)` | `性能影响评估` |
| `Lock` | `平均锁定时间(总锁定时间)` | `总锁定时间/执行次数 (总时间)` | `并发问题分析` |  
| `Rows` | `平均返回行数(总行数)` | `总返回行数/执行次数 (总行数)` | `数据量分析` |
| `用户@主机` | `执行用户和主机信息` | `日志记录的连接信息` | `来源追踪` |

### 5.3 关键指标分析方法


**性能影响评估**：
```
影响程度判断标准：

高影响查询特征：
├── Time指标
│   ├── 平均时间 > 5秒 → 🚨 严重问题
│   ├── 平均时间 1-5秒 → ⚠️ 需要优化  
│   └── 总时间很大 → 🔥 整体影响大
├── Count指标
│   ├── 执行次数 > 1000 → 🔄 高频查询
│   └── 次数×时间 → 总体资源消耗
└── Lock指标
    ├── 锁定时间 > 1秒 → 🔒 并发瓶颈
    └── 锁定时间占比高 → 📊 等待严重
```

### 5.4 输出结果优先级判断


**问题优先级评估流程**：
```
优先级判断决策树：

总时间 > 100秒？
├── 是 → 🔴 高优先级
│   └── 立即优化，影响系统整体性能
└── 否 → 继续判断
    │
    平均时间 > 10秒？
    ├── 是 → 🟡 中优先级  
    │   └── 单次执行很慢，用户体验差
    └── 否 → 继续判断
        │
        执行次数 > 10000？
        ├── 是 → 🟡 中优先级
        │   └── 高频查询，累计影响大
        └── 否 → 🟢 低优先级
            └── 监控即可，暂不处理
```

---

## 6. 🎯 实际应用场景示例


### 6.1 日常性能监控


**定期性能检查脚本**：
```bash
#!/bin/bash
# 每日慢查询分析脚本

echo "=== 今日TOP 5最耗时查询 ==="
mysqldumpslow -s t -t 5 /var/log/mysql/slow.log

echo "=== 今日TOP 5最频繁查询 ==="  
mysqldumpslow -s c -t 5 /var/log/mysql/slow.log

echo "=== 今日平均最慢查询 ==="
mysqldumpslow -s at -t 5 /var/log/mysql/slow.log
```

### 6.2 问题排查场景


**具体问题排查示例**：

```bash
# 场景1：系统整体变慢，找总体影响最大的查询
mysqldumpslow -s t -t 10 -a slow.log

# 场景2：某个功能响应慢，查找特定表相关查询  
mysqldumpslow -g "FROM orders" -s at slow.log

# 场景3：数据库锁等待严重，查找锁定时间长的查询
mysqldumpslow -s l -t 10 slow.log

# 场景4：特定时间段问题分析（结合日志轮转）
mysqldumpslow -s t slow.log.1 | head -20
```

### 6.3 优化效果验证


**优化前后对比分析**：
```bash
# 优化前分析
mysqldumpslow -s t -t 5 slow-before.log > before.txt

# 优化后分析  
mysqldumpslow -s t -t 5 slow-after.log > after.txt

# 对比分析
diff before.txt after.txt
```

### 6.4 复杂过滤组合使用


**高级过滤组合示例**：
```bash
# 组合1：查找特定用户的高频慢查询
mysqldumpslow -h "app-user" -s c -t 10 slow.log

# 组合2：查找包含特定关键字的平均最慢查询
mysqldumpslow -g "SELECT.*ORDER BY" -s at -t 5 -i slow.log

# 组合3：抽象化数字但保留字符串，分析模式差异
mysqldumpslow -n -s t -t 10 slow.log

# 组合4：反向排序，查看执行次数最少的查询
mysqldumpslow -s c -r -t 5 slow.log
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本用法


```
🔸 基础语法：mysqldumpslow [选项] 日志文件
🔸 核心参数：-s排序 -t数量限制 -a抽象化 -g过滤
🔸 常用组合：-s t -t 10 (找TOP 10耗时查询)
🔸 输出解读：Count次数 Time时间 Lock锁定 Rows行数
🔸 问题定位：按总时间/平均时间/执行次数不同维度分析
```

### 7.2 关键理解要点


**🔹 抽象化的作用**：
```
作用机制：
- 将具体参数值替换为占位符
- 相同SQL模式能够归类统计  
- 便于发现真正的问题SQL模式
- -a完全抽象，-n只抽象数字
```

**🔹 排序策略选择**：
```
选择依据：
- 系统整体慢 → 用-s t找总耗时大的
- 用户响应慢 → 用-s at找单次慢的  
- 负载压力大 → 用-s c找高频的
- 锁等待多 → 用-s l找锁定时间长的
```

**🔹 结果解读重点**：
```
关注指标：
- Time总时间：整体性能影响
- 平均时间：单次执行体验
- Count次数：资源消耗频率
- Lock时间：并发性能瓶颈
```

### 7.3 实际应用建议


**📊 分析流程建议**：
1. **先看总体**：`-s t -t 10` 了解主要问题
2. **再看频率**：`-s c -t 10` 找高频查询  
3. **分析单次**：`-s at -t 10` 找最慢查询
4. **检查锁定**：`-s l -t 10` 查并发问题

**🔧 实用技巧**：
- 定期运行检查脚本，建立性能基线
- 结合业务场景使用正则过滤
- 优化前后对比分析验证效果
- 关注Total Time和Average Time的平衡

**⚠️ 注意事项**：
- 日志文件过大时先用-t限制输出
- 生产环境建议使用-a参数抽象化
- 结合具体SQL执行计划进行深入分析
- 定期清理或轮转慢查询日志文件

**核心记忆**：
- mysqldumpslow是MySQL慢查询分析的首选工具
- 掌握-s排序和-t限制是基本功
- 抽象化分组是理解SQL模式的关键
- 输出结果的Time和Count指标最重要