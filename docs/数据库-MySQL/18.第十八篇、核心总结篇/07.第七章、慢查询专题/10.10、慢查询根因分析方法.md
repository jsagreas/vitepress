---
title: 10、慢查询根因分析方法
---
## 📚 目录

1. [慢查询分析概述](#1-慢查询分析概述)
2. [执行计划分析方法](#2-执行计划分析方法)
3. [索引使用情况检查](#3-索引使用情况检查)
4. [表结构设计问题诊断](#4-表结构设计问题诊断)
5. [SQL语句优化点识别](#5-SQL语句优化点识别)
6. [数据量影响分析](#6-数据量影响分析)
7. [系统资源瓶颈排查](#7-系统资源瓶颈排查)
8. [锁竞争问题分析](#8-锁竞争问题分析)
9. [综合诊断方法](#9-综合诊断方法)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔍 慢查询分析概述


### 1.1 什么是慢查询根因分析


**核心概念**：慢查询根因分析就是找出SQL语句执行慢的真正原因，好比医生给病人看病要找到病根一样。

```
慢查询就像生病的症状：
- 表面现象：查询执行时间长
- 深层原因：可能是索引问题、表设计问题、硬件问题等
- 分析目标：找到真正的原因，对症下药
```

### 1.2 分析思路框架


**🎯 系统化分析流程**

```
慢查询分析金字塔：

        性能问题
           |
    ┌──────┼──────┐
    |      |      |
   SQL   索引   表设计
    |      |      |
 ┌──┴──┐ ┌┴─┐  ┌─┴─┐
硬件 网络 锁 负载 结构 数据量
```

**🔸 分析层次**
- **第一层**：SQL语句本身的问题
- **第二层**：索引设计和使用问题  
- **第三层**：表结构设计问题
- **第四层**：系统资源和环境问题

### 1.3 分析工具准备


**💡 必备分析工具**

| 工具类型 | **具体工具** | **作用说明** |
|---------|------------|-------------|
| 🔍 **执行计划** | `EXPLAIN` | 查看SQL执行路径 |
| 📊 **性能监控** | `SHOW PROCESSLIST` | 查看当前执行状态 |
| 📈 **统计信息** | `SHOW STATUS` | 查看数据库状态 |
| 🔧 **索引分析** | `SHOW INDEX` | 查看索引使用情况 |
| ⚡ **实时监控** | `Performance Schema` | 详细性能数据 |

---

## 2. 📋 执行计划分析方法


### 2.1 EXPLAIN基础解读


**🔸 什么是执行计划**

执行计划就像GPS导航路线，告诉我们MySQL是怎么找到数据的：

```sql
-- 简单示例
EXPLAIN SELECT * FROM users WHERE age > 25;
```

**📊 执行计划关键字段**

```
+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+------+---------+------+------+-------------+
```

### 2.2 type字段详解（最重要）


**🚨 性能等级排序**（从好到坏）

```
性能指标：⭐⭐⭐⭐⭐ 最优
         ⭐⭐⭐⭐   良好  
         ⭐⭐⭐     一般
         ⭐⭐       较差
         ⭐         很差
```

| type值 | **性能等级** | **含义解释** | **优化建议** |
|--------|------------|-------------|-------------|
| `system` | ⭐⭐⭐⭐⭐ | 表只有一行数据 | 无需优化 |
| `const` | ⭐⭐⭐⭐⭐ | 主键或唯一索引查询 | 保持现状 |
| `eq_ref` | ⭐⭐⭐⭐⭐ | 连接查询中的最优情况 | 保持现状 |
| `ref` | ⭐⭐⭐⭐ | 非唯一索引查询 | 可接受 |
| `range` | ⭐⭐⭐ | 范围查询 | 考虑索引优化 |
| `index` | ⭐⭐ | 索引全扫描 | **需要优化** |
| `ALL` | ⭐ | 全表扫描 | **必须优化** |

### 2.3 rows字段分析


**💡 扫描行数判断**

```sql
-- 案例分析
EXPLAIN SELECT * FROM orders WHERE status = 'pending';

-- 如果rows显示10000，但表总共只有10000行
-- 说明：全表扫描，需要加索引

-- 如果rows显示100，表有100万行  
-- 说明：索引工作良好
```

**⚠️ 判断标准**
- `rows < 1000`：通常可接受
- `rows > 10000`：需要关注
- `rows > 100000`：必须优化

### 2.4 Extra字段警告信息


**🚨 需要重点关注的Extra值**

```
⚠️ Using filesort
含义：需要额外排序，无法使用索引排序
影响：性能较差，数据量大时很慢
解决：为ORDER BY字段建立索引

⚠️ Using temporary  
含义：需要创建临时表
影响：消耗内存，影响性能
解决：优化GROUP BY、DISTINCT等语句

✅ Using index
含义：覆盖索引，只需读取索引
影响：性能很好
建议：保持这种情况

⚠️ Using where
含义：在存储引擎层之后过滤
影响：可能性能一般
建议：检查是否可以推送到存储引擎层
```

---

## 3. 🔑 索引使用情况检查


### 3.1 索引基础概念


**🔸 索引是什么**

索引就像书的目录，帮助快速找到需要的内容：

```
没有索引的查询：
翻书找内容 → 从第1页开始逐页查找 → 可能要翻完整本书

有索引的查询：  
看目录 → 直接跳转到对应页面 → 快速找到内容
```

### 3.2 索引失效常见情况


**🚨 索引失效的典型场景**

```sql
-- ❌ 错误示例1：在索引字段使用函数
SELECT * FROM users WHERE YEAR(create_time) = 2023;

-- ✅ 正确写法：
SELECT * FROM users WHERE create_time >= '2023-01-01' 
AND create_time < '2024-01-01';

-- ❌ 错误示例2：模糊查询以%开头  
SELECT * FROM users WHERE name LIKE '%张%';

-- ✅ 正确写法：
SELECT * FROM users WHERE name LIKE '张%';

-- ❌ 错误示例3：类型不匹配
SELECT * FROM users WHERE phone = 13800138000;  -- phone是varchar类型

-- ✅ 正确写法：
SELECT * FROM users WHERE phone = '13800138000';
```

### 3.3 复合索引使用规则


**🔸 最左前缀原则**

```sql
-- 假设有复合索引：INDEX(name, age, city)

-- ✅ 能使用索引的情况：
WHERE name = '张三'                    -- 使用索引的第1列
WHERE name = '张三' AND age = 25       -- 使用索引的前2列  
WHERE name = '张三' AND age = 25 AND city = '北京'  -- 使用完整索引

-- ❌ 不能使用索引的情况：
WHERE age = 25                         -- 跳过了第1列
WHERE city = '北京'                    -- 跳过了前2列
WHERE age = 25 AND city = '北京'       -- 跳过了第1列
```

**💡 记忆口诀**：索引像楼梯，必须从第一级开始走，不能跳级。

### 3.4 索引选择性分析


**🔸 什么是索引选择性**

选择性就是数据的区分度，选择性越高，索引效果越好：

```sql
-- 检查字段的选择性
SELECT 
    COUNT(DISTINCT column_name) / COUNT(*) as selectivity
FROM table_name;

-- 选择性判断标准：
-- > 0.8  : 选择性很好，适合建索引
-- 0.3-0.8: 选择性一般，可以考虑复合索引  
-- < 0.3  : 选择性较差，建索引效果不明显
```

**💡 实际例子**

```sql
-- 性别字段选择性分析
SELECT COUNT(DISTINCT gender) / COUNT(*) FROM users;
-- 结果：0.5 (只有男/女两个值，选择性差)

-- 邮箱字段选择性分析  
SELECT COUNT(DISTINCT email) / COUNT(*) FROM users;
-- 结果：0.99 (几乎每个用户邮箱都不同，选择性很好)
```

---

## 4. 🏗️ 表结构设计问题诊断


### 4.1 表设计常见问题


**🔸 数据类型选择不当**

```sql
-- ❌ 问题示例：
CREATE TABLE bad_design (
    id VARCHAR(50),           -- 主键用VARCHAR，效率低
    status VARCHAR(255),      -- 状态字段过长
    price DOUBLE,             -- 金额用DOUBLE，精度问题
    is_deleted VARCHAR(10)    -- 布尔值用VARCHAR
);

-- ✅ 改进方案：
CREATE TABLE good_design (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,  -- 数字主键，效率高
    status TINYINT,                        -- 状态用数字枚举
    price DECIMAL(10,2),                   -- 金额用DECIMAL，精确
    is_deleted TINYINT(1) DEFAULT 0        -- 布尔值用TINYINT
);
```

**💡 数据类型选择原则**
- **主键**：优先使用数字类型（INT、BIGINT）
- **状态字段**：使用TINYINT替代VARCHAR
- **金额字段**：使用DECIMAL替代FLOAT/DOUBLE
- **时间字段**：使用DATETIME/TIMESTAMP替代VARCHAR

### 4.2 字段长度设计


**🔸 VARCHAR长度的影响**

```sql
-- 不同长度的性能影响
VARCHAR(50)    -- 占用更少内存，索引更高效
VARCHAR(255)   -- 一般用途，平衡选择  
VARCHAR(1000)  -- 占用内存多，索引效率低
TEXT           -- 不能建完整索引，只能前缀索引
```

**⚠️ 长度设计建议**
- **姓名**：VARCHAR(50) 足够
- **邮箱**：VARCHAR(100) 合适  
- **手机号**：VARCHAR(20) 或 CHAR(11)
- **地址**：VARCHAR(200) 一般够用

### 4.3 表分区设计


**🔸 何时考虑分区**

```
单表数据量判断：
📊 < 100万行     → 无需分区
📊 100万-1000万  → 可考虑分区
📊 > 1000万行    → 建议分区

分区类型选择：
🗓️ 按时间分区   → 适合日志、订单等时间相关数据
🔢 按范围分区   → 适合ID、数值范围明确的数据
📝 按列表分区   → 适合地区、部门等枚举值
```

---

## 5. ⚡ SQL语句优化点识别


### 5.1 SELECT语句优化


**🔸 避免SELECT ***

```sql
-- ❌ 问题写法：
SELECT * FROM users WHERE id = 1;

-- ✅ 优化写法：
SELECT id, name, email FROM users WHERE id = 1;

-- 💡 原因解释：
-- SELECT * 会查询所有字段，即使你只需要几个字段
-- 增加网络传输量，降低查询效率
-- 无法使用覆盖索引优化
```

### 5.2 WHERE条件优化


**🔸 条件顺序的影响**

```sql
-- 假设有复合索引：INDEX(status, create_time)

-- ✅ 好的写法：
SELECT * FROM orders 
WHERE status = 1 AND create_time > '2023-01-01';

-- ❌ 不好的写法：  
SELECT * FROM orders
WHERE create_time > '2023-01-01' AND status = 1;

-- 💡 虽然MySQL优化器会自动调整，但养成好习惯很重要
```

### 5.3 JOIN语句优化


**🔸 JOIN的性能原理**

```
小表驱动大表原理：

小表 JOIN 大表：
users(1万) JOIN orders(100万) 
→ 需要循环1万次，每次在100万中查找

大表 JOIN 小表：  
orders(100万) JOIN users(1万)
→ 需要循环100万次，每次在1万中查找

结论：小表做驱动表，性能更好
```

**💡 实际优化示例**

```sql
-- ❌ 低效写法：
SELECT o.*, u.name 
FROM orders o 
LEFT JOIN users u ON o.user_id = u.id
WHERE u.status = 1;

-- ✅ 优化写法：
SELECT o.*, u.name
FROM users u
INNER JOIN orders o ON u.id = o.user_id  
WHERE u.status = 1;

-- 说明：先过滤users表，减少JOIN的数据量
```

### 5.4 子查询vs JOIN


**🔸 性能对比分析**

```sql
-- 场景：查询有订单的用户

-- ❌ 子查询方式（通常较慢）：
SELECT * FROM users 
WHERE id IN (SELECT user_id FROM orders);

-- ✅ JOIN方式（通常更快）：
SELECT DISTINCT u.* FROM users u
INNER JOIN orders o ON u.id = o.user_id;

-- 🔧 EXISTS方式（大数据量时更优）：
SELECT * FROM users u
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);
```

---

## 6. 📊 数据量影响分析


### 6.1 数据量与性能的关系


**🔸 线性增长 vs 指数增长**

```
索引查询（对数增长）：
数据量    查询时间    
1万      1ms       
10万     2ms       
100万    3ms       
1000万   4ms       

全表扫描（线性增长）：
数据量    查询时间
1万      10ms
10万     100ms     
100万    1000ms    
1000万   10000ms   
```

### 6.2 数据量阈值判断


**📈 性能拐点识别**

| 数据量级 | **查询表现** | **优化建议** |
|---------|------------|-------------|
| **< 1万** | 🟢 几乎无差别 | 无需特殊优化 |
| **1万-10万** | 🟡 开始有差别 | 建立基础索引 |
| **10万-100万** | 🟠 差别明显 | 复合索引+分页 |
| **100万-1000万** | 🔴 必须优化 | 分区+读写分离 |
| **> 1000万** | 🚨 架构调整 | 分库分表 |

### 6.3 大数据量查询策略


**🔸 分页查询优化**

```sql
-- ❌ 传统分页（深分页性能差）：
SELECT * FROM users ORDER BY id LIMIT 100000, 20;

-- ✅ 游标分页（性能稳定）：
SELECT * FROM users WHERE id > 100000 ORDER BY id LIMIT 20;

-- 💡 原理说明：
-- LIMIT 100000, 20 需要先跳过10万条数据
-- WHERE id > 100000 直接定位，不需要跳过
```

---

## 7. 🖥️ 系统资源瓶颈排查


### 7.1 硬件资源监控


**🔸 CPU使用率分析**

```sql
-- 查看当前MySQL进程状态
SHOW PROCESSLIST;

-- 查看正在执行的查询
SELECT * FROM information_schema.PROCESSLIST 
WHERE COMMAND != 'Sleep' AND TIME > 1;
```

**💡 CPU瓶颈判断标准**
- `CPU使用率 < 70%`：正常范围
- `CPU使用率 70%-85%`：需要关注  
- `CPU使用率 > 85%`：存在瓶颈

### 7.2 内存使用分析


**🔸 Buffer Pool命中率**

```sql
-- 查看Buffer Pool状态
SHOW STATUS LIKE 'Innodb_buffer_pool%';

-- 计算命中率
-- 命中率 = (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100%
```

**⚠️ 内存指标判断**
- **命中率 > 95%**：内存配置良好
- **命中率 90%-95%**：可以适当增加内存
- **命中率 < 90%**：存在内存瓶颈

### 7.3 磁盘IO瓶颈


**🔸 IO性能指标**

```bash
# Linux系统查看IO状态
iostat -x 1

# 关键指标说明：
# %util > 80%  : IO压力大
# await > 10ms : IO响应慢  
# r/s + w/s    : IOPS使用量
```

### 7.4 网络延迟因素


**🔸 网络延迟测试**

```bash
# 测试数据库连接延迟
ping database_server_ip

# 测试MySQL连接时间
time mysql -h hostname -u username -p -e "SELECT 1"
```

**💡 网络延迟影响**
- `延迟 < 1ms`：本地网络，影响很小
- `延迟 1-10ms`：局域网，影响较小
- `延迟 > 10ms`：需要考虑连接池优化

---

## 8. 🔒 锁竞争问题分析


### 8.1 锁的基本概念


**🔸 MySQL中的锁类型**

```
锁的层次结构：

数据库级别
    ↓
表级锁
    ↓  
行级锁
    ↓
记录锁、间隙锁、临键锁
```

### 8.2 死锁问题分析


**🔸 死锁产生原理**

```
死锁场景示例：

事务A：锁定订单1 → 等待锁定订单2
事务B：锁定订单2 → 等待锁定订单1

结果：两个事务互相等待，形成死锁
```

**🔧 死锁检测命令**

```sql
-- 查看最近的死锁信息
SHOW ENGINE INNODB STATUS;

-- 查看当前锁等待情况
SELECT * FROM information_schema.INNODB_LOCKS;
SELECT * FROM information_schema.INNODB_LOCK_WAITS;
```

### 8.3 锁等待超时


**🔸 锁等待时间设置**

```sql
-- 查看锁等待超时时间
SHOW VARIABLES LIKE 'innodb_lock_wait_timeout';

-- 设置锁等待超时时间（秒）
SET innodb_lock_wait_timeout = 10;
```

### 8.4 避免锁竞争的方法


**💡 实用建议**

```sql
-- ✅ 1. 缩短事务时间
START TRANSACTION;
-- 尽快完成操作
UPDATE orders SET status = 1 WHERE id = 123;
COMMIT;

-- ✅ 2. 按相同顺序访问数据
-- 事务A和B都按ID升序操作，避免交叉锁定

-- ✅ 3. 使用合适的隔离级别
-- 读已提交级别可以减少锁竞争
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

---

## 9. 🔧 综合诊断方法


### 9.1 诊断流程图


```
慢查询发现
    ↓
执行EXPLAIN分析
    ↓
┌─────────────┬─────────────┐
|   type=ALL  |   type≠ALL  |
|   全表扫描   |   索引查询   |
└─────────────┴─────────────┘
    ↓               ↓
 检查索引设计    检查rows数量
    ↓               ↓
 添加/优化索引   ┌───────┬───────┐
    ↓          | >1万  | <1万  |
 重新测试       └───────┴───────┘
    ↓               ↓       ↓
  性能提升？     数据量分析  其他因素
    ↓               ↓       ↓
┌─────┬─────┐    分区方案  系统资源
| 是  | 否  |      ↓       ↓
└─────┴─────┘    读写分离  硬件升级
  ↓     ↓
 完成  深层分析
```

### 9.2 分析检查清单


**📋 系统化检查步骤**

```
□ 第一步：基础信息收集
  ├─ 记录慢查询SQL语句
  ├─ 记录执行时间和频率  
  └─ 收集表结构信息

□ 第二步：执行计划分析
  ├─ 运行EXPLAIN查看执行计划
  ├─ 检查type字段（重点关注ALL、index）
  ├─ 检查rows字段（关注扫描行数）
  └─ 检查Extra字段（关注filesort、temporary）

□ 第三步：索引状况检查
  ├─ 检查WHERE条件字段是否有索引
  ├─ 检查复合索引的使用情况
  ├─ 验证索引选择性
  └─ 确认索引没有失效

□ 第四步：SQL语句优化
  ├─ 避免SELECT *
  ├─ 优化WHERE条件顺序
  ├─ 检查JOIN语句效率
  └─ 考虑子查询改写

□ 第五步：系统资源检查
  ├─ 检查CPU使用率
  ├─ 检查内存Buffer Pool命中率
  ├─ 检查磁盘IO状况
  └─ 检查网络延迟

□ 第六步：数据量影响评估
  ├─ 评估当前数据量级
  ├─ 预估未来增长趋势
  ├─ 考虑分页策略
  └─ 评估分区必要性
```

### 9.3 优先级排序


**🎯 问题优先级判断**

| 优先级 | **问题类型** | **影响程度** | **解决难度** |
|-------|------------|-------------|-------------|
| **🔴 P0** | 全表扫描大表 | 严重影响性能 | 简单 |
| **🟠 P1** | 索引失效 | 明显性能下降 | 简单 |
| **🟡 P2** | 深分页查询 | 部分场景慢 | 中等 |
| **🟢 P3** | 系统资源不足 | 整体性能下降 | 复杂 |

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的分析方法


```
🔸 执行计划分析：EXPLAIN是最重要的工具，重点看type和rows
🔸 索引检查：确保WHERE条件字段有合适的索引，避免索引失效
🔸 SQL优化：避免SELECT *，优化JOIN和子查询
🔸 数据量评估：根据数据量选择合适的查询策略
🔸 系统监控：关注CPU、内存、IO等系统资源状况
```

### 10.2 分析思路要点


**🔹 从简单到复杂的分析顺序**
```
1. 先看执行计划 → 发现明显问题
2. 再查索引使用 → 解决大部分问题  
3. 然后优化SQL → 提升查询效率
4. 最后查系统资源 → 解决环境问题
```

**🔹 抓住关键指标**
```
type=ALL     → 必须优化（最高优先级）
rows>10000   → 需要关注
Extra有filesort → 考虑索引优化
CPU>85%      → 检查系统负载
```

### 10.3 实际应用指导


**💡 新手常用的分析套路**

```sql
-- 步骤1：查看执行计划
EXPLAIN SELECT * FROM table_name WHERE condition;

-- 步骤2：如果type=ALL，检查索引
SHOW INDEX FROM table_name;

-- 步骤3：如果没有索引，创建索引  
CREATE INDEX idx_column_name ON table_name(column_name);

-- 步骤4：重新测试性能
-- 对比优化前后的执行时间
```

**🔧 优化效果评估**
- **执行时间减少50%以上**：优化效果显著
- **执行时间减少20%-50%**：优化有效果
- **执行时间减少小于20%**：需要其他优化方案

**核心记忆口诀**：
- 慢查询分析有套路，执行计划最重要
- 索引使用要检查，全表扫描必须改
- SQL优化抓重点，系统资源也要看
- 数据量大分区表，综合诊断效果好