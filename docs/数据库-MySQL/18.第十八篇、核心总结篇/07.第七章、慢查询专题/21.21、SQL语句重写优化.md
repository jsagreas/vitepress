---
title: 21、SQL语句重写优化
---
## 📚 目录

1. [SQL重写优化概述](#1-SQL重写优化概述)
2. [查询条件优化技巧](#2-查询条件优化技巧)
3. [JOIN语句重写方法](#3-JOIN语句重写方法)
4. [子查询转换策略](#4-子查询转换策略)
5. [EXISTS与IN选择策略](#5-EXISTS与IN选择策略)
6. [UNION与UNION ALL优化](#6-UNION与UNION-ALL优化)
7. [临时表使用优化](#7-临时表使用优化)
8. [分页查询优化](#8-分页查询优化)
9. [聚合函数优化](#9-聚合函数优化)
10. [条件下推技术](#10-条件下推技术)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔧 SQL重写优化概述


### 1.1 什么是SQL重写优化


**简单理解**：SQL重写优化就是把慢的SQL语句改写成快的SQL语句，让数据库跑得更快。

```
原理就像走路：
慢的路线：家 → 绕远路 → 公司 (30分钟)
快的路线：家 → 直路 → 公司 (10分钟)

同样的目的地，不同的路线，时间差别很大
```

### 1.2 为什么需要重写SQL


**🎯 核心原因**：
- **性能问题**：原始SQL执行太慢，影响用户体验
- **资源浪费**：占用过多CPU和内存资源
- **并发瓶颈**：慢SQL会阻塞其他查询
- **业务影响**：页面加载慢，用户体验差

### 1.3 SQL重写的基本思路


```
优化思路图：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   慢SQL     │ →  │   分析瓶颈   │ →  │   重写SQL   │
│ 执行计划差   │    │ 找出问题点   │    │ 选择最优写法 │
└─────────────┘    └─────────────┘    └─────────────┘
        ↓                   ↓                   ↓
  10秒才返回          索引没用上          0.1秒返回
```

**🔸 优化原则**：
- **减少数据扫描量**：只读必要的数据
- **充分利用索引**：让查询走索引
- **减少临时表**：避免不必要的临时操作
- **简化计算逻辑**：减少复杂运算

---

## 2. 🎯 查询条件优化技巧


### 2.1 WHERE条件优化


**🔸 索引列优先原则**

```sql
-- ❌ 慢查询：在非索引列上查询
SELECT * FROM users WHERE age = 25 AND city = '北京';

-- ✅ 快查询：优先使用索引列
SELECT * FROM users WHERE user_id = 12345;
-- 或者为 age, city 建立复合索引
CREATE INDEX idx_age_city ON users(age, city);
```

**💡 白话解释**：就像查字典，按拼音查比按偏旁查要快得多。

### 2.2 避免索引失效的写法


**🔸 函数使用优化**

```sql
-- ❌ 错误：在索引列上使用函数
SELECT * FROM orders WHERE YEAR(create_time) = 2024;

-- ✅ 正确：使用范围查询
SELECT * FROM orders 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';
```

**🔸 类型转换优化**

```sql
-- ❌ 错误：类型不匹配导致索引失效
SELECT * FROM users WHERE user_id = '12345';  -- user_id是数字类型

-- ✅ 正确：保持类型一致
SELECT * FROM users WHERE user_id = 12345;
```

### 2.3 复合条件优化


**🔸 最左前缀原则**

```sql
-- 假设有复合索引：INDEX(name, age, city)

-- ✅ 能使用索引：遵循最左前缀
SELECT * FROM users WHERE name = '张三';
SELECT * FROM users WHERE name = '张三' AND age = 25;
SELECT * FROM users WHERE name = '张三' AND age = 25 AND city = '北京';

-- ❌ 不能使用索引：跳过了最左列
SELECT * FROM users WHERE age = 25;
SELECT * FROM users WHERE city = '北京';
```

**💡 记忆技巧**：复合索引像电话号码，必须从左边开始连续输入才能查到。

### 2.4 范围查询优化


**🔸 BETWEEN vs 多个OR**

```sql
-- ❌ 效率低：多个OR条件
SELECT * FROM products 
WHERE price = 100 OR price = 200 OR price = 300;

-- ✅ 效率高：使用IN
SELECT * FROM products 
WHERE price IN (100, 200, 300);

-- ✅ 范围查询：使用BETWEEN
SELECT * FROM products 
WHERE price BETWEEN 100 AND 500;
```

---

## 3. 🔗 JOIN语句重写方法


### 3.1 JOIN类型选择


**🔸 JOIN执行效率对比**

```
JOIN类型效率图：
INNER JOIN     ████████████ 最快
LEFT JOIN      ████████░░░░ 较快
RIGHT JOIN     ████████░░░░ 较快  
FULL JOIN      ██████░░░░░░ 较慢
CROSS JOIN     ██░░░░░░░░░░ 最慢
```

### 3.2 小表驱动大表


**🔸 基本原理**

```sql
-- 表大小：users(1万条), orders(100万条)

-- ❌ 大表驱动小表：要循环100万次
SELECT * FROM orders o 
LEFT JOIN users u ON o.user_id = u.user_id 
WHERE u.status = 'active';

-- ✅ 小表驱动大表：只循环1万次
SELECT * FROM users u 
LEFT JOIN orders o ON u.user_id = o.user_id 
WHERE u.status = 'active';
```

**💡 生活类比**：
```
错误做法：100万人排队，每人去问1万个老师问题
正确做法：1万个老师，每人去处理对应的学生问题
```

### 3.3 JOIN条件优化


**🔸 索引覆盖优化**

```sql
-- ❌ 未优化：需要回表查询
SELECT u.name, u.email, o.order_no 
FROM users u 
JOIN orders o ON u.user_id = o.user_id;

-- ✅ 优化：建立覆盖索引
-- CREATE INDEX idx_user_cover ON users(user_id, name, email);
-- CREATE INDEX idx_order_cover ON orders(user_id, order_no);
```

### 3.4 多表JOIN优化


**🔸 JOIN顺序优化**

```sql
-- 表大小：users(1万), orders(10万), products(1千)

-- ❌ 错误顺序：大表先关联
SELECT * FROM orders o
JOIN users u ON o.user_id = u.user_id
JOIN products p ON o.product_id = p.product_id;

-- ✅ 正确顺序：小表先关联，逐步过滤
SELECT * FROM products p
JOIN orders o ON p.product_id = o.product_id  
JOIN users u ON o.user_id = u.user_id;
```

---

## 4. 🔄 子查询转换策略


### 4.1 子查询 vs JOIN性能对比


**🔸 性能差异分析**

| 查询方式 | **执行效率** | **资源占用** | **适用场景** |
|---------|-------------|-------------|-------------|
| `子查询` | `较慢` | `内存占用大` | `简单逻辑，数据量小` |
| `JOIN` | `较快` | `内存占用小` | `复杂关联，数据量大` |
| `EXISTS` | `快` | `内存占用小` | `存在性判断` |

### 4.2 IN子查询转JOIN


**🔸 基本转换**

```sql
-- ❌ 子查询写法：可能很慢
SELECT * FROM users 
WHERE user_id IN (
    SELECT user_id FROM orders 
    WHERE order_date >= '2024-01-01'
);

-- ✅ JOIN写法：通常更快
SELECT DISTINCT u.* FROM users u
INNER JOIN orders o ON u.user_id = o.user_id
WHERE o.order_date >= '2024-01-01';
```

**💡 为什么JOIN更快**：
- 子查询：先查内层，再查外层，可能重复扫描
- JOIN：优化器可以选择最优的连接顺序

### 4.3 相关子查询优化


**🔸 关联子查询转换**

```sql
-- ❌ 相关子查询：每行都要执行子查询
SELECT u.name, 
       (SELECT COUNT(*) FROM orders WHERE user_id = u.user_id) as order_count
FROM users u;

-- ✅ 转换为LEFT JOIN：只扫描一次
SELECT u.name, 
       COUNT(o.order_id) as order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.name;
```

### 4.4 复杂子查询分解


**🔸 分步查询策略**

```sql
-- ❌ 复杂嵌套子查询
SELECT * FROM products 
WHERE category_id IN (
    SELECT category_id FROM categories 
    WHERE parent_id IN (
        SELECT category_id FROM categories 
        WHERE name = '电子产品'
    )
);

-- ✅ 分步查询，使用临时表
-- 步骤1：找到父类目
SET @parent_id = (SELECT category_id FROM categories WHERE name = '电子产品');

-- 步骤2：找到子类目
SELECT * FROM products p
JOIN categories c1 ON p.category_id = c1.category_id
WHERE c1.parent_id = @parent_id;
```

---

## 5. ⚖️ EXISTS与IN选择策略


### 5.1 EXISTS vs IN原理对比


**🔸 执行机制差异**

```
EXISTS执行过程：
外表每一行 → 检查内表是否存在匹配 → 找到即停止

IN执行过程：  
先执行子查询 → 得到结果集 → 外表逐行匹配结果集
```

### 5.2 选择决策树


```
选择决策流程：
┌─────────────────┐
│   子查询场景     │
└─────────┬───────┘
          │
      ┌───▼───┐    ┌─────────────┐
      │子表大？│YES │ 使用EXISTS   │
      └───┬───┘    └─────────────┘
          │NO
      ┌───▼───┐    ┌─────────────┐
      │子表小？│YES │ 使用IN      │
      └───────┘    └─────────────┘
```

### 5.3 实际应用示例


**🔸 大表场景：使用EXISTS**

```sql
-- 场景：users表10万条，orders表1000万条
-- ✅ 推荐：EXISTS，因为orders表很大
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o 
    WHERE o.user_id = u.user_id 
    AND o.status = 'completed'
);
```

**🔸 小表场景：使用IN**

```sql
-- 场景：users表10万条，vip_users表100条
-- ✅ 推荐：IN，因为vip_users表很小
SELECT * FROM users 
WHERE user_id IN (
    SELECT user_id FROM vip_users 
    WHERE level >= 'gold'
);
```

### 5.4 NOT EXISTS vs NOT IN


**🔸 NULL值处理差异**

```sql
-- ⚠️ 注意：NOT IN遇到NULL会有问题
-- 如果子查询结果包含NULL，NOT IN返回空结果

-- ❌ 可能出错：NOT IN + NULL
SELECT * FROM users 
WHERE user_id NOT IN (
    SELECT user_id FROM blacklist  -- 如果有NULL值，结果为空
);

-- ✅ 安全写法：NOT EXISTS
SELECT * FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM blacklist b 
    WHERE b.user_id = u.user_id
);
```

---

## 6. 🔀 UNION与UNION ALL优化


### 6.1 UNION vs UNION ALL差异


**🔸 执行过程对比**

```
UNION执行过程：
查询A结果 → 查询B结果 → 合并 → 去重排序 → 返回结果

UNION ALL执行过程：
查询A结果 → 查询B结果 → 直接合并 → 返回结果
```

**🔸 性能差异**

| 操作类型 | **去重** | **排序** | **性能** | **适用场景** |
|---------|---------|---------|---------|-------------|
| `UNION` | `是` | `是` | `慢` | `需要去重的场景` |
| `UNION ALL` | `否` | `否` | `快` | `确定无重复数据` |

### 6.2 优化策略


**🔸 能用UNION ALL就不用UNION**

```sql
-- ❌ 不必要的去重：浪费性能
SELECT user_id, name FROM active_users
UNION
SELECT user_id, name FROM inactive_users;

-- ✅ 无需去重：直接合并
SELECT user_id, name FROM active_users
UNION ALL
SELECT user_id, name FROM inactive_users;
```

### 6.3 复杂UNION优化


**🔸 分表查询合并**

```sql
-- 场景：按月分表的订单数据
-- ❌ 低效写法：每个子查询都是全表扫描
SELECT * FROM orders_2024_01 WHERE status = 'pending'
UNION ALL
SELECT * FROM orders_2024_02 WHERE status = 'pending'
UNION ALL  
SELECT * FROM orders_2024_03 WHERE status = 'pending';

-- ✅ 优化：确保每个子查询都有索引
-- CREATE INDEX idx_status ON orders_2024_01(status);
-- CREATE INDEX idx_status ON orders_2024_02(status);
-- CREATE INDEX idx_status ON orders_2024_03(status);
```

---

## 7. 💾 临时表使用优化


### 7.1 临时表的使用场景


**🔸 何时使用临时表**

```
适合使用临时表的场景：
┌─────────────────┐
│  复杂计算分解    │ ← 多步骤计算，中间结果复用
├─────────────────┤
│  大数据量预处理  │ ← 先过滤，再关联
├─────────────────┤
│  多次引用结果集  │ ← 避免重复计算
└─────────────────┘
```

### 7.2 临时表优化示例


**🔸 复杂查询分解**

```sql
-- ❌ 复杂的一次性查询：难以优化
SELECT u.name, 
       COUNT(o.order_id) as order_count,
       SUM(o.amount) as total_amount,
       AVG(r.rating) as avg_rating
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
LEFT JOIN reviews r ON o.order_id = r.order_id
WHERE u.register_date >= '2024-01-01'
GROUP BY u.user_id;

-- ✅ 分步优化：使用临时表
-- 步骤1：创建用户临时表
CREATE TEMPORARY TABLE tmp_users AS
SELECT user_id, name FROM users 
WHERE register_date >= '2024-01-01';

-- 步骤2：计算订单统计
CREATE TEMPORARY TABLE tmp_order_stats AS
SELECT user_id, 
       COUNT(*) as order_count,
       SUM(amount) as total_amount
FROM orders 
WHERE user_id IN (SELECT user_id FROM tmp_users)
GROUP BY user_id;

-- 步骤3：最终结果
SELECT u.name, 
       COALESCE(os.order_count, 0) as order_count,
       COALESCE(os.total_amount, 0) as total_amount
FROM tmp_users u
LEFT JOIN tmp_order_stats os ON u.user_id = os.user_id;
```

### 7.3 临时表索引优化


**🔸 为临时表建立索引**

```sql
-- 创建临时表后立即建立索引
CREATE TEMPORARY TABLE tmp_large_result AS
SELECT user_id, order_date, amount FROM orders
WHERE order_date >= '2024-01-01';

-- 重要：为临时表创建索引
CREATE INDEX idx_tmp_user ON tmp_large_result(user_id);
CREATE INDEX idx_tmp_date ON tmp_large_result(order_date);
```

---

## 8. 📄 分页查询优化


### 8.1 传统分页问题


**🔸 LIMIT OFFSET性能问题**

```sql
-- ❌ 深分页问题：OFFSET越大越慢
SELECT * FROM products 
ORDER BY product_id 
LIMIT 20 OFFSET 100000;  -- 需要扫描并跳过10万条记录
```

**💡 问题解释**：
```
LIMIT 20 OFFSET 100000 的执行过程：
1. 扫描前100020条记录
2. 跳过前100000条  
3. 返回接下来20条

就像排队取号，要取第10万号，得先数过前面所有人
```

### 8.2 游标分页优化


**🔸 基于ID的游标分页**

```sql
-- ✅ 游标分页：性能稳定
-- 第一页
SELECT * FROM products 
WHERE product_id > 0 
ORDER BY product_id 
LIMIT 20;

-- 下一页（假设上一页最后一条记录ID是220）
SELECT * FROM products 
WHERE product_id > 220 
ORDER BY product_id 
LIMIT 20;
```

### 8.3 复合排序的分页优化


**🔸 多字段排序的游标分页**

```sql
-- 场景：按价格排序，相同价格按ID排序
-- ✅ 复合游标分页
SELECT * FROM products 
WHERE (price > 100.00) 
   OR (price = 100.00 AND product_id > 1520)
ORDER BY price, product_id 
LIMIT 20;
```

### 8.4 分页总数优化


**🔸 总数统计优化**

```sql
-- ❌ 每次都统计总数：性能差
SELECT COUNT(*) FROM products WHERE category_id = 1;
SELECT * FROM products WHERE category_id = 1 LIMIT 20 OFFSET 0;

-- ✅ 缓存总数或使用估算
-- 方案1：缓存总数到Redis
-- 方案2：使用近似统计
SELECT 
    TABLE_ROWS as approximate_count 
FROM information_schema.TABLES 
WHERE TABLE_NAME = 'products';
```

---

## 9. 📊 聚合函数优化


### 9.1 聚合函数性能对比


**🔸 性能排序**

```
聚合函数性能排行：
COUNT(*)      ████████████ 最快（InnoDB优化）
COUNT(1)      ███████████░ 很快
COUNT(id)     ████████░░░░ 较快（需要检查NULL）
SUM()         ███████░░░░░ 中等
AVG()         ██████░░░░░░ 较慢（SUM/COUNT）
MIN()/MAX()   █████░░░░░░░ 慢（需要排序或索引）
```

### 9.2 COUNT优化技巧


**🔸 COUNT(*)优化**

```sql
-- ✅ 最优：使用COUNT(*)
SELECT COUNT(*) FROM orders WHERE status = 'completed';

-- ❌ 较慢：COUNT(主键)还要检查NULL
SELECT COUNT(order_id) FROM orders WHERE status = 'completed';

-- ❌ 最慢：COUNT(可空字段)
SELECT COUNT(comment) FROM orders WHERE status = 'completed';
```

### 9.3 分组聚合优化


**🔸 GROUP BY优化**

```sql
-- ❌ 未优化：GROUP BY字段没有索引
SELECT category_id, COUNT(*) 
FROM products 
GROUP BY category_id;

-- ✅ 优化：为GROUP BY字段建立索引
CREATE INDEX idx_category ON products(category_id);

-- ✅ 进一步优化：覆盖索引
CREATE INDEX idx_category_cover ON products(category_id, product_id);
```

### 9.4 聚合函数与子查询


**🔸 避免聚合函数中的子查询**

```sql
-- ❌ 聚合函数内嵌子查询：性能极差
SELECT user_id,
       SUM((SELECT price FROM products WHERE product_id = o.product_id)) as total
FROM orders o
GROUP BY user_id;

-- ✅ 优化：先JOIN再聚合
SELECT o.user_id,
       SUM(p.price) as total
FROM orders o
JOIN products p ON o.product_id = p.product_id
GROUP BY o.user_id;
```

---

## 10. ⬇️ 条件下推技术


### 10.1 什么是条件下推


**🔸 基本概念**

```
条件下推原理图：
原始查询：
┌─────────────┐
│    外层     │ ← WHERE条件在这里
│  ┌───────┐  │
│  │ 内层  │  │ ← 数据在这里
│  └───────┘  │
└─────────────┘

条件下推后：
┌─────────────┐
│    外层     │ 
│  ┌───────┐  │
│  │ 内层  │  │ ← WHERE条件推到这里
│  └───────┘  │
└─────────────┘
```

**💡 白话解释**：条件下推就是把过滤条件尽可能推到数据源附近，减少无效数据的传输和处理。

### 10.2 子查询条件下推


**🔸 基本示例**

```sql
-- ❌ 条件在外层：需要处理所有数据
SELECT * FROM (
    SELECT user_id, name, age, city FROM users
) u 
WHERE u.age > 25;

-- ✅ 条件下推：在子查询内就过滤
SELECT user_id, name, age, city 
FROM users 
WHERE age > 25;
```

### 10.3 JOIN条件下推


**🔸 WHERE条件优化**

```sql
-- ❌ 条件位置不当：先关联再过滤
SELECT u.name, o.amount 
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.status = 'active' AND o.order_date >= '2024-01-01';

-- ✅ 条件下推：先过滤再关联
SELECT u.name, o.amount 
FROM (SELECT user_id, name FROM users WHERE status = 'active') u
JOIN (SELECT user_id, amount FROM orders WHERE order_date >= '2024-01-01') o 
ON u.user_id = o.user_id;
```

### 10.4 视图查询优化


**🔸 视图条件下推**

```sql
-- 假设有视图
CREATE VIEW user_order_view AS
SELECT u.user_id, u.name, o.order_id, o.amount
FROM users u
JOIN orders o ON u.user_id = o.user_id;

-- ❌ 条件无法下推：视图先执行完整JOIN
SELECT * FROM user_order_view WHERE user_id = 12345;

-- ✅ 直接查询：条件能够下推
SELECT u.name, o.order_id, o.amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.user_id = 12345;
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的优化原则


```
🔸 核心原则：减少数据量，充分利用索引
🔸 查询条件：避免索引失效，遵循最左前缀原则  
🔸 表连接：小表驱动大表，优化JOIN顺序
🔸 子查询：优先考虑转换为JOIN
🔸 聚合查询：为GROUP BY字段建立索引
🔸 分页查询：深分页使用游标分页
🔸 条件下推：尽早过滤数据
```

### 11.2 优化决策流程


```
SQL优化决策树：
┌─────────────┐
│   慢查询    │
└──────┬──────┘
       │
   ┌───▼───┐     ┌─────────────┐
   │有索引？│ NO  │  建立索引    │
   └───┬───┘     └─────────────┘
       │YES
   ┌───▼───┐     ┌─────────────┐
   │索引生效│ NO  │  重写查询条件 │
   └───┬───┘     └─────────────┘
       │YES  
   ┌───▼───┐     ┌─────────────┐
   │数据量大│ YES │  分解查询    │
   └───┬───┘     └─────────────┘
       │NO
   ┌───▼───┐
   │ 完成   │
   └───────┘
```

### 11.3 常见优化技巧速查


**🔸 索引优化**：
- ✅ 为WHERE、ORDER BY、GROUP BY字段建立索引
- ✅ 使用复合索引时遵循最左前缀原则
- ✅ 避免在索引列上使用函数

**🔸 查询重写**：
- ✅ 子查询转换为JOIN
- ✅ EXISTS替代IN（大表场景）
- ✅ UNION ALL替代UNION（无重复数据）

**🔸 性能技巧**：
- ✅ 小表驱动大表
- ✅ 使用LIMIT限制返回数据量
- ✅ 避免SELECT *，只查询需要的字段

### 11.4 实际应用建议


**🎯 日常开发习惯**：
- **写SQL前**：先了解表结构和索引情况
- **测试阶段**：使用EXPLAIN分析执行计划
- **上线前**：在生产环境数据量下测试性能
- **上线后**：监控慢查询日志，持续优化

**核心记忆**：
- SQL优化核心是减少数据扫描量
- 索引是提升查询性能的关键
- 小表驱动大表，条件尽早过滤
- 复杂查询分解，简化执行逻辑