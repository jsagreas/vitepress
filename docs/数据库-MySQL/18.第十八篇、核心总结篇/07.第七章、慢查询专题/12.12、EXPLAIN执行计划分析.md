---
title: 12、EXPLAIN执行计划分析
---
## 📚 目录

1. [EXPLAIN基础概念](#1-EXPLAIN基础概念)
2. [EXPLAIN基本语法使用](#2-EXPLAIN基本语法使用)
3. [select_type查询类型详解](#3-select_type查询类型详解)
4. [table表名信息解读](#4-table表名信息解读)
5. [type连接类型分析](#5-type连接类型分析)
6. [possible_keys与key字段](#6-possible_keys与key字段)
7. [key_len索引长度分析](#7-key_len索引长度分析)
8. [ref索引比较列详解](#8-ref索引比较列详解)
9. [rows扫描行数估算](#9-rows扫描行数估算)
10. [Extra额外信息解读](#10-Extra额外信息解读)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔍 EXPLAIN基础概念


### 1.1 什么是EXPLAIN


**🔸 核心定义**
```
EXPLAIN：MySQL提供的查询分析工具
作用：显示MySQL如何执行SELECT语句
目的：帮助我们理解查询性能，找出慢查询原因
```

**💡 为什么需要EXPLAIN**
想象你要从北京到上海，有多种交通方式：
- 🚗 开车：灵活但耗时长
- ✈️ 飞机：快速但成本高  
- 🚄 高铁：平衡速度和成本

MySQL执行查询也是这样，面对一条SQL语句，它有多种执行方式。EXPLAIN就像是**路线规划器**，告诉我们MySQL选择了哪条"路线"来执行查询。

### 1.2 EXPLAIN能告诉我们什么


**📊 核心信息**
```
🔸 使用了哪些索引
🔸 扫描了多少行数据
🔸 表的连接顺序
🔸 查询的执行方式
🔸 可能的性能瓶颈
```

**🎯 实际应用场景**
```
场景1：查询很慢，不知道原因
→ 用EXPLAIN看是否走了索引

场景2：想验证索引是否生效
→ 用EXPLAIN确认key字段

场景3：优化复杂的多表查询
→ 用EXPLAIN分析连接顺序和方式
```

---

## 2. 📝 EXPLAIN基本语法使用


### 2.1 基础语法格式


**🔸 标准语法**
```sql
EXPLAIN SELECT * FROM users WHERE age > 25;
```

**🔸 详细格式语法**
```sql
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE age > 25;
```

### 2.2 实际操作示例


**📋 准备测试数据**
```sql
-- 创建用户表
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(50),
  age INT,
  city VARCHAR(30),
  INDEX idx_age (age),
  INDEX idx_city (city)
);

-- 插入测试数据
INSERT INTO users (name, age, city) VALUES 
('张三', 25, '北京'),
('李四', 30, '上海'),
('王五', 35, '广州');
```

**💻 基础EXPLAIN示例**
```sql
EXPLAIN SELECT * FROM users WHERE age = 25;
```

**📊 输出结果示例**
```
+----+-------------+-------+------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | users | ref  | idx_age       | idx_age | 5       | const |    1 | NULL  |
+----+-------------+-------+------+---------------+---------+---------+-------+------+-------+
```

### 2.3 EXPLAIN输出字段概览


| 字段名 | **作用说明** | **重要程度** |
|--------|-------------|-------------|
| `id` | `查询序列号` | ⭐⭐⭐ |
| `select_type` | `查询类型` | ⭐⭐⭐⭐ |
| `table` | `表名` | ⭐⭐⭐ |
| `type` | `连接类型` | ⭐⭐⭐⭐⭐ |
| `possible_keys` | `可能使用的索引` | ⭐⭐⭐ |
| `key` | `实际使用的索引` | ⭐⭐⭐⭐⭐ |
| `key_len` | `索引长度` | ⭐⭐⭐⭐ |
| `ref` | `索引比较的列` | ⭐⭐⭐ |
| `rows` | `扫描的行数` | ⭐⭐⭐⭐⭐ |
| `Extra` | `额外信息` | ⭐⭐⭐⭐ |

---

## 3. 🎯 select_type查询类型详解


### 3.1 SIMPLE - 简单查询


**🔸 概念说明**
```
定义：最简单的SELECT查询，不包含子查询或UNION
特点：最常见的查询类型
性能：通常性能最好
```

**💻 示例代码**
```sql
-- SIMPLE类型查询
EXPLAIN SELECT * FROM users WHERE age > 25;

-- 结果中select_type显示为SIMPLE
```

### 3.2 PRIMARY - 主查询


**🔸 概念说明**
```
定义：复杂查询中最外层的SELECT
出现场景：包含子查询或UNION的复杂查询
标识：标记查询的主要部分
```

**💻 示例代码**
```sql
-- PRIMARY类型查询
EXPLAIN SELECT * FROM users 
WHERE id IN (SELECT user_id FROM orders WHERE amount > 100);

-- 外层查询显示为PRIMARY
-- 子查询显示为SUBQUERY
```

### 3.3 SUBQUERY - 子查询


**🔸 概念说明**
```
定义：包含在SELECT列表中的子查询
特点：子查询独立执行
性能：可能影响查询性能
```

**💻 示例代码**
```sql
-- SUBQUERY类型
EXPLAIN SELECT name, 
  (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count
FROM users;
```

### 3.4 其他查询类型


**📋 类型汇总表**

| 类型 | **含义** | **场景** | **性能建议** |
|------|---------|---------|-------------|
| `SIMPLE` | `简单查询` | `单表查询，无子查询` | ✅ 性能最佳 |
| `PRIMARY` | `主查询` | `复杂查询的外层` | ⚠️ 关注子查询性能 |
| `SUBQUERY` | `子查询` | `SELECT中的子查询` | ⚠️ 考虑用JOIN替代 |
| `DERIVED` | `派生表` | `FROM中的子查询` | ⚠️ 可能产生临时表 |
| `UNION` | `联合查询` | `UNION操作` | ⚠️ 注意去重开销 |
| `DEPENDENT SUBQUERY` | `依赖子查询` | `关联子查询` | ❌ 性能较差，需优化 |

---

## 4. 📋 table表名信息解读


### 4.1 实际表名


**🔸 基本概念**
```
显示内容：查询涉及的实际表名
作用：标识数据来源
格式：直接显示表名
```

**💻 示例**
```sql
EXPLAIN SELECT * FROM users;
-- table字段显示：users
```

### 4.2 派生表和临时表


**🔸 派生表标识**
```
格式：<derived2>、<derived3>等
含义：表示FROM子句中的子查询结果
性能影响：可能创建临时表，影响性能
```

**💻 派生表示例**
```sql
EXPLAIN SELECT * FROM 
(SELECT * FROM users WHERE age > 25) AS young_users;

-- table字段可能显示：<derived2>
```

**🔸 临时表标识**
```
格式：<temporary>
含义：MySQL创建的临时表
出现场景：复杂查询、GROUP BY、ORDER BY等
```

### 4.3 表名解读技巧


**📝 解读规则**
```
🔸 直接表名：正常的表查询
🔸 <derivedN>：派生表，N是查询ID
🔸 <unionN,M>：UNION操作的临时表
🔸 <subqueryN>：子查询的临时表
```

---

## 5. ⚡ type连接类型分析


### 5.1 type字段重要性


**🔸 为什么type最重要**
```
type字段是判断查询性能的最重要指标
它显示了MySQL如何查找表中的行
从最好到最差的顺序：system > const > eq_ref > ref > range > index > ALL
```

**📊 性能排序图**
```
性能好 ←----------------------------------------→ 性能差
system  const  eq_ref  ref  range  index  ALL
  ↑       ↑      ↑     ↑     ↑       ↑     ↑
极快    很快    快    较快   一般    慢    很慢
```

### 5.2 各种type类型详解


#### 🟢 system - 系统表

**🔸 概念说明**
```
定义：表只有一行记录（系统表）
性能：最优性能
出现场景：MyISAM引擎的系统表
```

#### 🟢 const - 常量查询

**🔸 概念说明**
```
定义：通过主键或唯一索引查找，最多返回一行
性能：非常好
特点：查询条件是常量值
```

**💻 示例代码**
```sql
-- const类型查询
EXPLAIN SELECT * FROM users WHERE id = 1;
-- type显示为const，因为id是主键

EXPLAIN SELECT * FROM users WHERE email = 'zhang@example.com';
-- 如果email是唯一索引，type也是const
```

#### 🟢 eq_ref - 等值引用

**🔸 概念说明**
```
定义：多表连接时，通过主键或唯一索引进行连接
性能：很好
场景：JOIN查询中的最佳连接方式
```

**💻 示例代码**
```sql
-- eq_ref类型查询
EXPLAIN SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id;
-- 如果user_id是外键，可能显示eq_ref
```

#### 🟡 ref - 引用查询

**🔸 概念说明**
```
定义：通过非唯一索引查找
性能：较好
特点：可能返回多行记录
```

**💻 示例代码**
```sql
-- ref类型查询
EXPLAIN SELECT * FROM users WHERE age = 25;
-- 如果age有普通索引，type显示为ref
```

#### 🟡 range - 范围查询

**🔸 概念说明**
```
定义：使用索引进行范围查询
性能：中等
条件：使用>、<、>=、<=、BETWEEN、IN等
```

**💻 示例代码**
```sql
-- range类型查询
EXPLAIN SELECT * FROM users WHERE age BETWEEN 20 AND 30;
EXPLAIN SELECT * FROM users WHERE id IN (1,2,3);
-- type显示为range
```

#### 🟠 index - 索引扫描

**🔸 概念说明**
```
定义：扫描整个索引
性能：较差
场景：通常是因为没有WHERE条件，但需要排序
```

**💻 示例代码**
```sql
-- index类型查询
EXPLAIN SELECT id FROM users ORDER BY id;
-- 如果只查询索引列，可能是index类型
```

#### 🔴 ALL - 全表扫描

**🔸 概念说明**
```
定义：扫描整个表
性能：最差
问题：没有使用任何索引
```

**💻 示例代码**
```sql
-- ALL类型查询（需要优化）
EXPLAIN SELECT * FROM users WHERE nickname LIKE '%张%';
-- 如果nickname没有索引，type显示为ALL
```

### 5.3 type优化建议


**🎯 优化策略**

| type类型 | **优化建议** | **优先级** |
|----------|-------------|-----------|
| `ALL` | `立即添加索引` | 🔴 **紧急** |
| `index` | `考虑添加WHERE条件` | 🟠 **重要** |
| `range` | `可以接受，检查是否能优化为ref` | 🟡 **一般** |
| `ref` | `性能良好，无需优化` | 🟢 **良好** |
| `const/eq_ref` | `最佳性能` | 🟢 **完美** |

---

## 6. 🔑 possible_keys与key字段


### 6.1 possible_keys - 可能使用的索引


**🔸 概念说明**
```
定义：MySQL认为可能用到的索引列表
作用：显示查询优化器的选择范围
特点：可能为空，也可能有多个索引
```

**💻 示例分析**
```sql
-- 创建多个索引
CREATE INDEX idx_age ON users(age);
CREATE INDEX idx_city ON users(city);
CREATE INDEX idx_age_city ON users(age, city);

-- 查询可能用到多个索引
EXPLAIN SELECT * FROM users WHERE age = 25 AND city = '北京';
-- possible_keys可能显示：idx_age,idx_city,idx_age_city
```

### 6.2 key - 实际使用的索引


**🔸 概念说明**
```
定义：MySQL实际选择使用的索引
重要性：判断查询是否走索引的关键字段
值含义：NULL表示没有使用索引（需要优化）
```

**📊 key字段解读**

| key值 | **含义** | **性能评价** | **处理建议** |
|-------|---------|-------------|-------------|
| `NULL` | `没有使用索引` | 🔴 **差** | 立即添加索引 |
| `PRIMARY` | `使用主键索引` | 🟢 **优秀** | 无需处理 |
| `idx_name` | `使用普通索引` | 🟢 **良好** | 无需处理 |
| `联合索引名` | `使用复合索引` | 🟢 **很好** | 检查索引效果 |

### 6.3 索引选择分析


**🤔 为什么MySQL选择特定索引**
```
MySQL选择索引的考虑因素：
🔸 索引的选择性（重复值少的更好）
🔸 索引覆盖的查询列
🔸 索引的大小
🔸 查询条件的匹配程度
```

**💡 优化建议**
```sql
-- 如果possible_keys有多个，但key选择了不是最优的
-- 可以使用FORCE INDEX强制指定索引
SELECT * FROM users FORCE INDEX(idx_age_city) 
WHERE age = 25 AND city = '北京';
```

---

## 7. 📏 key_len索引长度分析


### 7.1 key_len基本概念


**🔸 定义说明**
```
key_len：表示索引使用的字节数
作用：判断复合索引使用了几个列
单位：字节(Bytes)
重要性：评估索引使用效率的重要指标
```

**💡 为什么key_len重要**
想象复合索引是一把"万能钥匙"，有多个"齿"：
- 🔑 使用的"齿"越多，开锁越精确
- 📏 key_len告诉我们用了几个"齿"
- 🎯 帮助判断索引是否充分利用

### 7.2 key_len计算规则


**📊 不同数据类型的字节数**

| 数据类型 | **字节数** | **示例** | **备注** |
|---------|-----------|---------|---------|
| `INT` | `4字节` | `key_len=4` | 整数类型 |
| `BIGINT` | `8字节` | `key_len=8` | 长整数 |
| `VARCHAR(50)` | `50*3+2` | `key_len=152` | UTF8编码+长度标识 |
| `CHAR(10)` | `10*3` | `key_len=30` | UTF8编码 |
| `DATE` | `3字节` | `key_len=3` | 日期类型 |
| `DATETIME` | `8字节` | `key_len=8` | 日期时间 |

**🔸 key_len计算公式**
```
基本公式：数据类型字节数 + NULL标识位 + 变长标识位

NULL标识位：
- 允许NULL：+1字节
- NOT NULL：+0字节

变长标识位：
- VARCHAR：+2字节
- CHAR：+0字节
```

### 7.3 实际计算示例


**💻 示例1：单列索引**
```sql
-- 创建索引
CREATE INDEX idx_age ON users(age);  -- age INT NOT NULL

-- 查询
EXPLAIN SELECT * FROM users WHERE age = 25;
-- key_len = 4 (INT类型4字节，NOT NULL不需要额外字节)
```

**💻 示例2：复合索引**
```sql
-- 创建复合索引
CREATE INDEX idx_age_name ON users(age, name);  
-- age: INT(4字节) + name: VARCHAR(50)(50*3+2=152字节)

-- 查询1：只使用age
EXPLAIN SELECT * FROM users WHERE age = 25;
-- key_len = 4 (只使用了age列)

-- 查询2：使用age和name
EXPLAIN SELECT * FROM users WHERE age = 25 AND name = '张三';
-- key_len = 156 (4+152，使用了两个列)
```

### 7.4 key_len优化技巧


**🎯 优化原则**
```
目标：让key_len尽可能大（在复合索引中）
原因：说明索引利用更充分
方法：调整WHERE条件，让更多索引列生效
```

**💡 实用技巧**
```sql
-- 复合索引：(age, city, name)
-- 好的查询（key_len大）
SELECT * FROM users WHERE age = 25 AND city = '北京' AND name = '张三';

-- 不好的查询（key_len小）
SELECT * FROM users WHERE city = '北京' AND name = '张三';
-- 因为没有使用最左前缀age，索引可能失效
```

---

## 8. 🔗 ref索引比较列详解


### 8.1 ref字段基本概念


**🔸 定义说明**
```
ref：显示索引的哪一列被使用了
作用：说明索引列与什么进行比较
类型：常量、列名、函数等
```

**💡 通俗理解**
ref就像是告诉我们"拿什么和索引比较"：
- 🎯 `const`：拿常量值比较
- 🔗 `表名.列名`：拿其他表的列比较
- 📊 `func`：拿函数结果比较

### 8.2 常见ref值类型


**📋 ref值含义表**

| ref值 | **含义** | **示例场景** | **性能评价** |
|-------|---------|-------------|-------------|
| `const` | `常量比较` | `WHERE age = 25` | 🟢 **很好** |
| `users.id` | `列与列比较` | `JOIN连接条件` | 🟢 **良好** |
| `func` | `函数结果比较` | `WHERE age = YEAR(NOW())` | 🟡 **一般** |
| `NULL` | `无比较对象` | `全表扫描` | 🔴 **差** |

### 8.3 实际示例分析


**💻 示例1：常量比较**
```sql
EXPLAIN SELECT * FROM users WHERE age = 25;

-- 结果分析：
-- type: ref
-- key: idx_age  
-- ref: const (说明age与常量25比较)
```

**💻 示例2：表连接**
```sql
EXPLAIN SELECT u.name, o.amount 
FROM users u 
JOIN orders o ON u.id = o.user_id;

-- 结果分析：
-- type: eq_ref
-- key: PRIMARY
-- ref: database.o.user_id (说明主键与orders.user_id比较)
```

**💻 示例3：函数比较**
```sql
EXPLAIN SELECT * FROM users WHERE age = YEAR(CURDATE()) - 1995;

-- 结果分析：
-- ref: func (说明age与函数结果比较)
-- 性能提示：函数计算可能影响性能
```

---

## 9. 📊 rows扫描行数估算


### 9.1 rows字段重要性


**🔸 核心概念**
```
rows：MySQL估算需要扫描的行数
作用：评估查询工作量的重要指标
特点：这是估算值，不是精确值
影响：rows越大，查询通常越慢
```

**💡 通俗理解**
rows就像是告诉我们"这次查询要翻多少页书"：
- 📖 rows = 10：只需要翻10页，很快
- 📚 rows = 10000：要翻1万页，比较慢
- 🏢 rows = 1000000：要翻100万页，很慢

### 9.2 rows数值分析


**📊 rows值评估标准**

| rows范围 | **性能评价** | **处理建议** | **典型场景** |
|----------|-------------|-------------|-------------|
| `1-100` | 🟢 **优秀** | 无需优化 | 主键查询、唯一索引查询 |
| `100-1000` | 🟡 **良好** | 可以接受 | 普通索引查询 |
| `1000-10000` | 🟠 **一般** | 考虑优化 | 范围查询、模糊查询 |
| `>10000` | 🔴 **较差** | 需要优化 | 全表扫描、无索引查询 |

### 9.3 影响rows的因素


**🔸 主要影响因素**
```
1. 索引使用情况
   - 有索引：rows较小
   - 无索引：rows等于表总行数

2. WHERE条件选择性
   - 条件严格：rows较小
   - 条件宽松：rows较大

3. 表数据量
   - 表越大，rows可能越大

4. 统计信息准确性
   - 统计信息过时，rows可能不准确
```

### 9.4 rows优化策略


**💻 优化示例**
```sql
-- 优化前：全表扫描
EXPLAIN SELECT * FROM users WHERE nickname LIKE '%张%';
-- rows: 100000 (假设表有10万行)

-- 优化后：添加索引
CREATE INDEX idx_nickname ON users(nickname);
EXPLAIN SELECT * FROM users WHERE nickname = '张三';
-- rows: 1 (使用索引，大幅减少扫描行数)
```

**🎯 实用优化技巧**
```
1. 添加合适的索引
2. 优化WHERE条件，提高选择性
3. 定期更新表统计信息：ANALYZE TABLE users;
4. 考虑分表分库（海量数据场景）
```

---

## 10. 📋 Extra额外信息解读


### 10.1 Extra字段重要性


**🔸 核心概念**
```
Extra：提供查询执行的额外信息
作用：发现性能问题的重要线索
内容：包含多种执行细节和优化提示
```

**💡 为什么Extra重要**
Extra就像是"体检报告"的备注栏：
- ✅ 好的Extra：说明查询健康
- ⚠️ 警告Extra：提示需要注意
- ❌ 危险Extra：说明有严重问题

### 10.2 常见Extra值详解


#### 🟢 性能良好的Extra


**Using index**
```
含义：只使用索引信息，不需要回表查询
性能：非常好
场景：覆盖索引查询
```

**💻 示例**
```sql
-- 创建覆盖索引
CREATE INDEX idx_age_name ON users(age, name);

-- 查询只涉及索引列
EXPLAIN SELECT age, name FROM users WHERE age > 25;
-- Extra: Using index (无需回表，性能很好)
```

**Using index condition**
```
含义：使用索引下推优化
性能：很好
场景：MySQL 5.6+的优化特性
```

#### 🟡 需要关注的Extra


**Using where**
```
含义：使用WHERE条件过滤
性能：一般
说明：在存储引擎层过滤数据
```

**💻 示例**
```sql
EXPLAIN SELECT * FROM users WHERE age > 25 AND city = '北京';
-- 如果只有age索引，city条件在Extra中显示Using where
```

**Using temporary**
```
含义：使用临时表
性能：较差
场景：复杂的GROUP BY、ORDER BY、DISTINCT
```

**💻 示例**
```sql
-- 可能产生临时表的查询
EXPLAIN SELECT DISTINCT city FROM users;
-- Extra可能显示：Using temporary
```

#### 🔴 需要优化的Extra


**Using filesort**
```
含义：无法使用索引排序，需要文件排序
性能：差
影响：大数据量时性能问题严重
```

**💻 问题示例**
```sql
-- 没有对应索引的排序
EXPLAIN SELECT * FROM users ORDER BY city;
-- Extra: Using filesort (需要优化)

-- 优化方案：添加索引
CREATE INDEX idx_city ON users(city);
```

**Using join buffer**
```
含义：连接时使用了缓冲区
性能：差
原因：没有合适的索引进行连接
```

### 10.3 Extra组合分析


**📊 Extra组合含义**

| Extra组合 | **性能评价** | **优化建议** |
|-----------|-------------|-------------|
| `Using index` | 🟢 **完美** | 无需优化 |
| `Using where; Using index` | 🟢 **很好** | 覆盖索引+条件过滤 |
| `Using temporary; Using filesort` | 🔴 **很差** | 立即优化排序和分组 |
| `Using join buffer (Block Nested Loop)` | 🔴 **差** | 添加连接索引 |

### 10.4 Extra优化策略


**🎯 针对性优化方案**

```sql
-- 问题1：Using filesort
-- 优化：添加排序索引
CREATE INDEX idx_sort_field ON table_name(sort_field);

-- 问题2：Using temporary  
-- 优化：优化GROUP BY字段索引
CREATE INDEX idx_group_field ON table_name(group_field);

-- 问题3：Using join buffer
-- 优化：添加连接字段索引  
CREATE INDEX idx_join_field ON table_name(join_field);
```

---

## 11. 📋 核心要点总结


### 11.1 EXPLAIN字段重要性排序


**🏆 最重要的字段（必须关注）**
```
1. type：连接类型（性能核心指标）
2. key：实际使用的索引
3. rows：扫描行数估算
4. Extra：额外执行信息
```

**⭐ 重要字段（需要了解）**
```
5. select_type：查询类型
6. key_len：索引使用长度
7. possible_keys：可能的索引选择
8. ref：索引比较对象
```

### 11.2 性能判断速查表


**🚦 快速性能评估**

| 判断维度 | **优秀** | **良好** | **一般** | **差** |
|---------|---------|---------|---------|-------|
| **type** | `const/eq_ref` | `ref` | `range` | `ALL/index` |
| **key** | `有具体索引名` | `有具体索引名` | `有索引名` | `NULL` |
| **rows** | `<100` | `100-1000` | `1000-10000` | `>10000` |
| **Extra** | `Using index` | `Using where` | `Using temporary` | `Using filesort` |

### 11.3 实用优化口诀


**📝 EXPLAIN优化记忆口诀**
```
type看连接，ALL最要命
key看索引，NULL需优化  
rows看数量，万行要小心
Extra看细节，filesort最忌讳
```

### 11.4 实际应用建议


**🎯 日常使用流程**
```
步骤1：执行EXPLAIN，查看整体执行计划
步骤2：重点检查type是否为ALL或index
步骤3：确认key字段不为NULL
步骤4：评估rows数量是否合理
步骤5：分析Extra中的性能警告
步骤6：根据问题制定优化方案
```

**💡 最佳实践建议**
- 🔍 **开发阶段**：每个复杂查询都要用EXPLAIN分析
- 🚀 **性能调优**：重点关注慢查询的EXPLAIN结果  
- 📊 **监控运维**：定期检查重要查询的执行计划变化
- 🎯 **优化目标**：让type尽可能好，rows尽可能少

**核心记忆**：
- EXPLAIN是查询优化的X光片，能透视SQL内部执行逻辑
- type字段是性能好坏的核心指标，从const到ALL性能递减
- key为NULL和Extra出现filesort是最需要优化的信号
- 理解EXPLAIN结果，就掌握了MySQL性能优化的关键技能