---
title: 19、pt-index-usage索引使用分析
---
## 📚 目录

1. [pt-index-usage工具概述](#1-pt-index-usage工具概述)
2. [索引使用分析原理](#2-索引使用分析原理)
3. [工具安装与基本使用](#3-工具安装与基本使用)
4. [索引统计收集与分析](#4-索引统计收集与分析)
5. [未使用索引识别与处理](#5-未使用索引识别与处理)
6. [索引效率评估方法](#6-索引效率评估方法)
7. [索引优化实战案例](#7-索引优化实战案例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 pt-index-usage工具概述


### 1.1 什么是pt-index-usage


**简单理解**：pt-index-usage就像是数据库的"索引体检医生"，它能告诉你哪些索引经常被用到，哪些索引从来没人用过。

```
生活类比：
就像家里的工具箱，有些工具天天用（螺丝刀、锤子）
有些工具买了就没用过（特殊规格的扳手）
pt-index-usage帮你找出数据库里"吃灰"的索引
```

**核心作用**：
- 🔸 **使用统计**：统计每个索引被使用的频率
- 🔸 **识别冗余**：找出从不使用的"僵尸索引"
- 🔸 **效率评估**：分析索引的实际效果
- 🔸 **优化建议**：提供索引清理和优化方案

### 1.2 为什么需要索引使用分析


**现实问题**：
```
常见的索引问题：
✗ 创建了很多索引，但不知道哪些有用
✗ 担心删除索引影响查询性能
✗ 索引太多导致写入性能下降
✗ 不知道新索引是否真的有效果
```

**解决价值**：
- **节省空间**：删除无用索引释放存储空间
- **提升性能**：减少索引维护开销，加快写入速度
- **精准优化**：基于实际使用情况优化索引策略

---

## 2. ⚙️ 索引使用分析原理


### 2.1 MySQL索引使用统计机制


**MySQL内部统计**：
```
MySQL内置的索引统计表：
• information_schema.STATISTICS：索引定义信息
• performance_schema.table_io_waits_summary_by_index_usage：索引使用统计
• sys.schema_unused_indexes：未使用索引视图
```

**pt-index-usage工作原理**：
```
数据收集流程：
第一步：连接MySQL服务器
第二步：查询performance_schema统计数据
第三步：分析索引使用模式
第四步：生成分析报告
```

### 2.2 索引使用判断标准


**使用频率分类**：
```
高频使用索引：
• 每天被使用数千次以上
• 主要支撑核心业务查询
• 删除会严重影响性能

中频使用索引：
• 偶尔被使用，但有明确场景
• 支撑特定功能或报表查询
• 需要结合业务评估

零使用索引：
• 统计期间从未被使用
• 可能是历史遗留或测试索引
• 优先考虑删除候选
```

### 2.3 统计数据的准确性


**统计周期考虑**：
```
短期统计（1-7天）：
✓ 能快速发现明显无用的索引
✗ 可能遗漏周期性使用的索引

长期统计（1-3个月）：
✓ 能覆盖大部分业务场景
✓ 包含周期性、季节性查询
✗ 统计时间较长

建议策略：
• 先短期快速筛选明显无用索引
• 再长期观察确认删除安全性
```

---

## 3. 🛠️ 工具安装与基本使用


### 3.1 安装pt-index-usage


**Percona Toolkit安装**：
```bash
# CentOS/RHEL
sudo yum install percona-toolkit

# Ubuntu/Debian
sudo apt-get install percona-toolkit

# 验证安装
pt-index-usage --version
```

### 3.2 基本语法和参数


**命令格式**：
```bash
pt-index-usage [选项] [数据库连接]
```

**常用参数解释**：
```bash
# 基本连接参数
--host=localhost          # MySQL服务器地址
--port=3306               # 端口号
--user=root               # 用户名
--password=your_password  # 密码

# 分析参数
--database=db_name        # 指定分析的数据库
--tables=table1,table2    # 指定分析的表
--ignore-databases=test   # 忽略的数据库

# 输出参数
--output=detailed         # 详细输出格式
--save-results           # 保存结果到文件
```

### 3.3 第一次使用示例


**简单分析命令**：
```bash
# 分析指定数据库的索引使用情况
pt-index-usage \
  --host=localhost \
  --user=root \
  --password=123456 \
  --database=ecommerce
```

**输出结果解读**：
```
# 典型输出示例
Database: ecommerce
Table: products
Index: idx_category_id
  - Uses: 15,432 times
  - Efficiency: High
  - Recommendation: Keep

Index: idx_created_date  
  - Uses: 0 times
  - Efficiency: None
  - Recommendation: Consider removing
```

---

## 4. 📊 索引统计收集与分析


### 4.1 收集索引使用统计


**启用性能统计**：
```sql
-- 确保performance_schema启用
SHOW VARIABLES LIKE 'performance_schema';

-- 启用索引统计收集
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES' 
WHERE NAME LIKE 'wait/io/table/%';

-- 启用统计表
UPDATE performance_schema.setup_consumers 
SET ENABLED = 'YES' 
WHERE NAME LIKE '%table%';
```

**手动查看索引使用情况**：
```sql
-- 查看索引使用统计
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,
    count_write,
    count_fetch,
    count_insert,
    count_update,
    count_delete
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'your_database'
ORDER BY count_read DESC;
```

### 4.2 使用pt-index-usage收集统计


**详细统计收集**：
```bash
# 收集详细的索引使用统计
pt-index-usage \
  --host=localhost \
  --user=monitor_user \
  --password=monitor_pass \
  --database=production_db \
  --output=detailed \
  --save-results > index_usage_report.txt
```

**统计数据示例**：
```
Index Usage Report
==================
Database: ecommerce
Collection Period: 7 days

Table: orders
├─ PRIMARY KEY
│  ├─ Read Operations: 45,678
│  ├─ Write Operations: 12,345
│  └─ Efficiency: Very High ★★★★★

├─ idx_customer_id
│  ├─ Read Operations: 23,456
│  ├─ Write Operations: 12,345
│  └─ Efficiency: High ★★★★☆

└─ idx_order_date_unused
   ├─ Read Operations: 0
   ├─ Write Operations: 12,345
   └─ Efficiency: None ★☆☆☆☆ (Consider removing)
```

### 4.3 统计数据的分析方法


**效率评估指标**：
```
读写比分析：
• 高读取，低写入：优秀的查询索引
• 低读取，高写入：可能的冗余索引
• 零读取，有写入：明确的无用索引

使用频率分析：
• 每日使用 > 1000次：核心索引，必须保留
• 每日使用 100-1000次：重要索引，谨慎处理  
• 每日使用 < 100次：候选删除索引
• 零使用：优先删除候选
```

---

## 5. 🔍 未使用索引识别与处理


### 5.1 识别未使用索引


**使用pt-index-usage识别**：
```bash
# 专门查找未使用的索引
pt-index-usage \
  --host=localhost \
  --user=dba_user \
  --database=target_db \
  --unused-only \
  --output=table
```

**使用MySQL sys schema**：
```sql
-- 查看未使用的索引
SELECT 
    object_schema,
    object_name,
    index_name
FROM sys.schema_unused_indexes
WHERE object_schema = 'your_database';

-- 更详细的未使用索引信息
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    t.INDEX_NAME,
    t.COLUMN_NAME,
    t.INDEX_TYPE,
    s.TABLE_ROWS
FROM information_schema.STATISTICS t
LEFT JOIN information_schema.TABLES s 
    ON t.TABLE_SCHEMA = s.TABLE_SCHEMA 
    AND t.TABLE_NAME = s.TABLE_NAME
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage p
    ON t.TABLE_SCHEMA = p.object_schema 
    AND t.TABLE_NAME = p.object_name 
    AND t.INDEX_NAME = p.index_name
WHERE t.TABLE_SCHEMA = 'ecommerce'
    AND p.index_name IS NULL
    AND t.INDEX_NAME != 'PRIMARY'
ORDER BY s.TABLE_ROWS DESC;
```

### 5.2 未使用索引的分类处理


**分类策略**：
```
立即删除类型：
✓ 测试期间创建的临时索引
✓ 重复功能的冗余索引
✓ 语法错误创建的无效索引

谨慎评估类型：
⚠️ 支撑周期性报表的索引
⚠️ 灾备或容错相关的索引  
⚠️ 新功能预留的索引

暂时保留类型：
⏳ 刚创建不久的索引（< 1个月）
⏳ 业务高峰期可能使用的索引
⏳ 不确定业务逻辑的索引
```

### 5.3 安全删除索引流程


**删除前的安全检查**：
```sql
-- 1. 查看索引定义
SHOW CREATE TABLE table_name;

-- 2. 确认索引大小和影响
SELECT 
    INDEX_NAME,
    ROUND(STAT_VALUE * $$innodb_page_size / 1024 / 1024, 2) AS 'Size_MB'
FROM information_schema.INNODB_BUFFER_STATS_BY_INDEX 
WHERE SCHEMA_NAME = 'your_db' AND TABLE_NAME = 'your_table';

-- 3. 备份索引创建语句
SELECT CONCAT(
    'CREATE INDEX ', INDEX_NAME, ' ON ', TABLE_NAME, 
    ' (', GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX), ');'
) AS backup_sql
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'your_db' 
    AND TABLE_NAME = 'your_table'
    AND INDEX_NAME = 'target_index'
GROUP BY INDEX_NAME;
```

**安全删除步骤**：
```sql
-- 步骤1：在测试环境验证
-- 删除索引并测试关键查询

-- 步骤2：业务低峰期删除
DROP INDEX idx_unused_column ON products;

-- 步骤3：监控性能变化
-- 观察几天确保没有性能问题

-- 步骤4：如有问题立即恢复
CREATE INDEX idx_unused_column ON products(unused_column);
```

---

## 6. 📈 索引效率评估方法


### 6.1 索引效率评估指标


**关键评估维度**：
```
使用频率指标：
• 读取次数 (COUNT_READ)
• 写入次数 (COUNT_WRITE)  
• 获取次数 (COUNT_FETCH)

效率比率指标：
• 读写比 = 读取次数 / 写入次数
• 命中率 = 实际使用 / 预期使用
• 成本效益 = 查询改善 / 维护成本
```

**效率评估查询**：
```sql
-- 索引效率综合评估
SELECT 
    CONCAT(object_schema, '.', object_name) AS table_name,
    index_name,
    count_read,
    count_write,
    count_fetch,
    CASE 
        WHEN count_write > 0 THEN ROUND(count_read / count_write, 2)
        ELSE count_read 
    END AS read_write_ratio,
    CASE
        WHEN count_read > 10000 THEN 'Very High'
        WHEN count_read > 1000 THEN 'High'  
        WHEN count_read > 100 THEN 'Medium'
        WHEN count_read > 0 THEN 'Low'
        ELSE 'Unused'
    END AS efficiency_level
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema NOT IN ('mysql', 'performance_schema', 'sys')
ORDER BY count_read DESC;
```

### 6.2 查询覆盖分析


**覆盖索引评估**：
```sql
-- 分析哪些查询能被索引完全覆盖
EXPLAIN FORMAT=JSON 
SELECT customer_id, order_date, total_amount 
FROM orders 
WHERE customer_id = 12345;

-- 检查Extra字段是否显示"Using index"
-- "Using index" = 覆盖索引，性能最佳
-- "Using index condition" = 部分覆盖，性能良好
-- "Using where" = 需要回表查询，性能一般
```

**覆盖索引优化示例**：
```sql
-- 原始查询和索引
SELECT customer_id, order_date, status 
FROM orders 
WHERE customer_id = 123 AND order_date > '2023-01-01';

-- 当前索引：idx_customer_id (customer_id)
-- 查询需要回表获取 order_date 和 status

-- 优化后的覆盖索引
CREATE INDEX idx_customer_orders_covering 
ON orders(customer_id, order_date, status);

-- 现在查询可以完全通过索引完成，无需回表
```

### 6.3 索引成本分析


**存储成本计算**：
```sql
-- 计算索引占用的存储空间
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * $$innodb_page_size / 1024 / 1024, 2) AS index_size_mb
FROM information_schema.INNODB_BUFFER_STATS_BY_INDEX 
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY index_size_mb DESC;
```

**维护成本评估**：
```
写入性能影响：
• 每个INSERT需要更新所有索引
• 每个UPDATE可能需要重建索引页
• 每个DELETE需要标记索引项删除

计算公式：
维护成本 = 索引数量 × 写入频率 × 索引大小
```

---

## 7. 🎯 索引优化实战案例


### 7.1 电商订单表索引优化


**场景描述**：
```
业务背景：
• 订单表 orders，500万记录
• 主要查询：按客户查订单、按时间范围查询
• 写入频繁：每分钟新增100-200订单

现状问题：
• 写入性能下降明显
• 查询速度时快时慢
• 存储空间占用过大
```

**pt-index-usage分析**：
```bash
# 分析订单表索引使用情况
pt-index-usage \
  --host=prod-mysql \
  --user=dba \
  --password=*** \
  --database=ecommerce \
  --tables=orders \
  --output=detailed
```

**分析结果**：
```
Orders Table Index Analysis
===========================

PRIMARY (order_id)
├─ Reads: 89,456/day  ★★★★★
├─ Writes: 14,400/day
└─ Status: Essential - Keep

idx_customer_id  
├─ Reads: 34,567/day  ★★★★☆
├─ Writes: 14,400/day
└─ Status: High Usage - Keep

idx_order_date
├─ Reads: 12,345/day  ★★★☆☆  
├─ Writes: 14,400/day
└─ Status: Medium Usage - Keep

idx_status_created_time
├─ Reads: 0/day       ★☆☆☆☆
├─ Writes: 14,400/day  
└─ Status: Unused - Consider Removing

idx_customer_status
├─ Reads: 145/day     ★★☆☆☆
├─ Writes: 14,400/day
└─ Status: Low Usage - Evaluate

idx_payment_method  
├─ Reads: 23/day      ★☆☆☆☆
├─ Writes: 14,400/day
└─ Status: Very Low Usage - Remove Candidate
```

### 7.2 优化实施过程


**第一阶段：删除明显无用索引**：
```sql
-- 备份删除语句
SELECT CONCAT('CREATE INDEX ', INDEX_NAME, ' ON ', TABLE_NAME, ' (', 
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX), ');'
) AS backup_sql
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'ecommerce' 
    AND TABLE_NAME = 'orders'
    AND INDEX_NAME IN ('idx_status_created_time', 'idx_payment_method');

-- 删除无用索引
DROP INDEX idx_status_created_time ON orders;
DROP INDEX idx_payment_method ON orders;
```

**第二阶段：创建覆盖索引**：
```sql
-- 分析主要查询模式
-- 查询1：SELECT * FROM orders WHERE customer_id = ? ORDER BY order_date DESC
-- 查询2：SELECT count(*) FROM orders WHERE customer_id = ? AND status = 'completed'

-- 创建组合覆盖索引
CREATE INDEX idx_customer_date_status 
ON orders(customer_id, order_date DESC, status);

-- 删除被覆盖的单列索引
DROP INDEX idx_customer_status ON orders;
```

### 7.3 优化效果对比


**性能改善对比**：
```
优化前后对比
============

写入性能：
• INSERT耗时：平均 45ms → 28ms (38%提升)
• 每分钟处理能力：150条 → 220条 (47%提升)

查询性能：
• 客户订单查询：120ms → 35ms (71%提升)  
• 状态统计查询：230ms → 85ms (63%提升)

存储空间：
• 索引总大小：2.3GB → 1.6GB (30%减少)
• 表总大小：8.5GB → 7.8GB (8%减少)

维护成本：
• 索引数量：7个 → 4个 (43%减少)
• 日志写入量：减少约25%
```

**监控验证**：
```sql
-- 持续监控新索引使用情况
SELECT 
    index_name,
    count_read,
    count_write,
    ROUND(count_read/count_write, 2) as efficiency_ratio
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'ecommerce' 
    AND object_name = 'orders'
    AND index_name = 'idx_customer_date_status';

-- 监控查询性能
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000 as avg_ms,
    MAX_TIMER_WAIT/1000000 as max_ms
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%orders%'
ORDER BY COUNT_STAR DESC;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 pt-index-usage本质：MySQL索引使用情况的"体检工具"
🔸 分析原理：基于performance_schema统计真实索引使用数据
🔸 评估维度：使用频率、读写比率、存储成本、维护开销
🔸 优化策略：删除无用索引、创建覆盖索引、合并重复索引
🔸 安全原则：先备份、后删除、要监控、能恢复
```

### 8.2 关键理解要点


**🔹 索引使用的判断标准**
```
高价值索引：
• 读取频率高，支撑核心业务
• 读写比合理，查询效果明显
• 覆盖重要查询，减少回表操作

低价值索引：
• 使用频率极低或为零
• 写入成本高，查询收益小  
• 功能重复，可被其他索引替代
```

**🔹 优化的平衡原则**
```
性能 vs 成本：
• 每个索引都有维护成本
• 索引越多写入性能越差
• 要在查询速度和写入效率间平衡

安全 vs 效率：
• 不确定的索引宁可保留观察
• 删除索引前必须充分测试
• 建立快速恢复机制
```

**🔹 分析的时间窗口**
```
短期分析（1-7天）：
• 快速发现明显问题
• 适合找出完全未使用的索引

长期分析（1-3个月）：  
• 覆盖完整业务周期
• 发现周期性、季节性使用模式
• 更准确的优化决策依据
```

### 8.3 实际应用价值


- **性能提升**：删除无用索引提高写入性能，优化有用索引提升查询速度
- **成本节约**：减少存储空间占用，降低维护开销
- **运维简化**：索引数量合理，维护工作量减少
- **决策支持**：基于数据而非猜测进行索引优化

### 8.4 最佳实践总结


**🔧 日常使用建议**
```
定期检查：
• 每月运行pt-index-usage分析
• 关注新创建索引的使用情况
• 监控索引大小和维护成本

优化流程：
• 先分析再行动，避免盲目删除
• 测试环境验证后再生产操作
• 分批处理，观察效果后继续

监控指标：
• 索引使用频率和效率
• 查询性能变化趋势  
• 写入性能和存储变化
```

**💡 核心记忆口诀**
```
索引分析三步走：收集统计看使用
无用索引要删除：备份测试再删除  
覆盖索引效果好：减少回表性能高
持续监控是关键：数据说话最可靠
```

### 8.5 常见误区避免


```
❌ 错误做法：
• 凭感觉删除索引，不看数据
• 一次性删除大量索引
• 只看使用次数，不考虑业务场景
• 删除后不监控性能变化

✅ 正确做法：  
• 基于pt-index-usage数据决策
• 分批删除，逐步验证效果
• 结合业务周期综合评估
• 建立完整的监控和回滚机制
```

**核心理解**：
- pt-index-usage是MySQL索引优化的得力助手
- 合理的索引策略需要数据支撑而非主观判断
- 索引优化是持续过程，需要定期分析和调整
- 安全第一：任何优化都要在保证业务稳定的前提下进行