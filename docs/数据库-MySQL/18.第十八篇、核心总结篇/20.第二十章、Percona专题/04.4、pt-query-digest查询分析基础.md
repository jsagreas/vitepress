---
title: 4、pt-query-digest查询分析基础
---
## 📚 目录

1. [pt-query-digest工具概述](#1-pt-query-digest工具概述)
2. [慢查询日志分析](#2-慢查询日志分析)
3. [二进制日志分析](#3-二进制日志分析)
4. [tcpdump网络抓包分析](#4-tcpdump网络抓包分析)
5. [查询指纹识别机制](#5-查询指纹识别机制)
6. [分析报告结构解读](#6-分析报告结构解读)
7. [基础命令参数详解](#7-基础命令参数详解)
8. [输入源格式支持](#8-输入源格式支持)
9. [过滤条件设置](#9-过滤条件设置)
10. [输出格式定制](#10-输出格式定制)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔍 pt-query-digest工具概述


### 1.1 什么是pt-query-digest


**🎯 简单理解**：
pt-query-digest就像是MySQL的"查询医生"，它能够分析你的数据库查询，告诉你哪些查询有问题、为什么慢、怎么优化。

```
现实类比：
就像体检报告一样
• 体检设备 → pt-query-digest工具
• 身体数据 → MySQL查询日志  
• 体检报告 → 分析结果报告
• 健康建议 → 优化建议
```

**📍 核心作用**：
- **查询分析**：找出数据库中的慢查询和问题查询
- **性能诊断**：分析查询执行时间、频率、资源消耗
- **优化指导**：提供具体的查询优化建议
- **趋势监控**：跟踪查询性能变化趋势

### 1.2 pt-query-digest的核心价值


**💡 解决的实际问题**：

```
场景1: 网站突然变慢
传统方法：猜测可能的问题，逐个排查
pt-query-digest：直接分析日志，精准定位慢查询

场景2: 数据库CPU使用率高
传统方法：查看系统监控，但不知道具体原因
pt-query-digest：找出消耗CPU最多的查询语句

场景3: 查询优化效果验证
传统方法：凭感觉判断优化是否有效
pt-query-digest：对比优化前后的具体数据
```

**⭐ 重要程度**：⭐⭐⭐⭐⭐ 核心必会

### 1.3 工具特点与优势


**🔸 主要特点**：
```
多数据源支持：
• 慢查询日志 (最常用)
• 二进制日志 (binlog)
• 通用查询日志 (general log)
• TCP网络抓包数据

智能分析：
• 自动识别相似查询
• 按照执行时间、频率等维度排序
• 生成详细的统计报告

易用性强：
• 命令行工具，使用简单
• 输出格式清晰易读
• 支持多种过滤条件
```

---

## 2. 📊 慢查询日志分析


### 2.1 慢查询日志基础理解


**🎯 什么是慢查询日志**：
慢查询日志就是MySQL的"黑匣子"，记录了所有执行时间超过指定阈值的SQL语句。

```
类比理解：
就像汽车的行车记录仪
• 记录超速行为 → 记录慢查询
• 分析事故原因 → 分析性能问题
• 改进驾驶习惯 → 优化查询语句
```

**🔧 慢查询日志配置**：
```sql
-- 查看当前慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 启用慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录
```

### 2.2 使用pt-query-digest分析慢查询


**📋 基础分析命令**：
```bash
# 最基本的分析命令
pt-query-digest /var/log/mysql/slow.log

# 分析指定时间范围的日志
pt-query-digest --since '2024-01-01 00:00:00' \
                --until '2024-01-01 23:59:59' \
                /var/log/mysql/slow.log
```

**💡 分析结果示例**：
```
# Profile
# Rank Query ID                           Response time Calls R/Call V/M   Item
# ==== ================================== ============= ===== ====== ===== ====
#    1 0x1234567890ABCDEF...               100.0    50.0%  1000   0.10  0.01 SELECT users
#    2 0x2345678901BCDEF...                60.0     30.0%   500   0.12  0.02 SELECT orders
#    3 0x3456789012CDEF...                 40.0     20.0%   200   0.20  0.05 UPDATE products

解读说明：
• Rank: 排名（按总响应时间）
• Response time: 总响应时间（秒）和占比
• Calls: 执行次数
• R/Call: 平均每次执行时间
• V/M: 时间变异系数（稳定性指标）
```

### 2.3 慢查询分析实战技巧


**🎯 重点关注指标**：

```
1. 总响应时间占比高的查询
   → 这些查询对整体性能影响最大

2. 平均执行时间长的查询  
   → 单次执行就很慢，优先优化

3. 执行频率高的查询
   → 即使单次不慢，但累积影响大

4. 时间波动大的查询
   → 性能不稳定，可能有锁等待问题
```

**💡 实用分析技巧**：
```bash
# 只分析最慢的前10个查询
pt-query-digest --limit 10 /var/log/mysql/slow.log

# 按执行次数排序（找出高频查询）
pt-query-digest --order-by Query_time:cnt /var/log/mysql/slow.log

# 只分析特定数据库的查询
pt-query-digest --filter '($event->{db} || "") eq "mydb"' /var/log/mysql/slow.log
```

---

## 3. 📄 二进制日志分析


### 3.1 二进制日志基础理解


**🎯 什么是二进制日志（binlog）**：
二进制日志记录了所有修改数据的操作（INSERT、UPDATE、DELETE），主要用于主从复制和数据恢复。

```
binlog vs 慢查询日志的区别：
┌─────────────────┬──────────────┬──────────────┐
│     对比维度     │   慢查询日志   │   二进制日志   │
├─────────────────┼──────────────┼──────────────┤
│ 🎯 记录内容     │ 慢的查询语句   │ 所有修改操作   │
│ 📊 记录条件     │ 超过时间阈值   │ 所有DML语句   │
│ 🔍 分析重点     │ 查询性能优化   │ 数据变更分析   │
│ 💾 文件大小     │ 相对较小      │ 通常很大      │
└─────────────────┴──────────────┴──────────────┘
```

**⚠️ 重要提醒**：
分析binlog主要用于：
- 分析数据修改操作的性能
- 审计数据变更情况
- 排查主从复制问题

### 3.2 binlog分析实战


**📋 基础分析命令**：
```bash
# 分析二进制日志
pt-query-digest --type binlog mysql-bin.000001

# 分析指定时间范围的binlog
pt-query-digest --type binlog \
                --since '2024-01-01 10:00:00' \
                --until '2024-01-01 11:00:00' \
                mysql-bin.000001
```

**💡 binlog分析结果特点**：
```
重点关注指标：
1. 大批量的INSERT/UPDATE/DELETE操作
2. 影响行数较多的单个操作
3. 频繁的小事务操作
4. 可能导致主从延迟的操作

典型问题发现：
• 大表的全表更新操作
• 批量数据导入的性能瓶颈
• 频繁的小事务提交
• 不合理的批量删除操作
```

**🔧 实用过滤示例**：
```bash
# 只分析UPDATE操作
pt-query-digest --type binlog \
                --filter '$event->{cmd} eq "Query" && $event->{arg} =~ /^update/i' \
                mysql-bin.000001

# 分析影响行数超过1000的操作
pt-query-digest --type binlog \
                --filter '$event->{Rows_affected} > 1000' \
                mysql-bin.000001
```

---

## 4. 🌐 tcpdump网络抓包分析


### 4.1 网络抓包分析理解


**🎯 什么时候需要网络抓包分析**：
当你无法直接访问MySQL日志文件时，或者需要分析实时的网络通信时，可以通过抓包分析。

```
使用场景类比：
就像监听电话通话内容
• 电话线路 → 网络连接
• 通话内容 → SQL语句
• 通话记录 → 抓包数据
• 分析报告 → pt-query-digest结果
```

**📍 适用场景**：
- 生产环境无法修改日志配置
- 需要分析特定应用的查询行为
- 调试连接池或ORM框架的查询
- 分析第三方应用的数据库访问

### 4.2 tcpdump抓包与分析流程


**🔧 抓包命令示例**：
```bash
# 抓取MySQL网络流量（3306端口）
tcpdump -i any -s 65535 -x -n -q -tttt \
        'port 3306 and tcp[13] & 2 != 0' > mysql.tcpdump

# 解读参数：
# -i any: 监听所有网络接口
# -s 65535: 抓取完整的数据包
# -x: 以十六进制显示数据包内容  
# -n: 不解析域名
# -q: 简化输出
# -tttt: 显示详细时间戳
```

**📊 分析抓包数据**：
```bash
# 分析tcpdump抓包文件
pt-query-digest --type tcpdump mysql.tcpdump

# 指定MySQL服务器地址（如果有多个服务器）
pt-query-digest --type tcpdump \
                --watch-server 192.168.1.100:3306 \
                mysql.tcpdump
```

### 4.3 网络抓包分析的注意事项


**⚠️ 使用限制与注意事项**：

```
性能影响：
• tcpdump会消耗一定的CPU和IO资源
• 在高并发环境下可能影响性能
• 建议在业务低峰期进行抓包

安全考虑：
• 抓包文件可能包含敏感数据
• 需要合理设置文件权限
• 及时清理不需要的抓包文件

实用建议：
• 抓包时间不宜过长（通常5-10分钟足够）
• 可以结合过滤条件减少数据量
• 优先考虑直接分析日志文件的方式
```

---

## 5. 🔑 查询指纹识别机制


### 5.1 什么是查询指纹


**🎯 查询指纹的概念**：
查询指纹就是将相似的SQL语句归类的一种技术，把具体的参数值替换成占位符，识别出查询的"模式"。

```
举例说明：
原始查询：
SELECT * FROM users WHERE id = 123 AND name = 'alice';
SELECT * FROM users WHERE id = 456 AND name = 'bob';
SELECT * FROM users WHERE id = 789 AND name = 'charlie';

查询指纹：
SELECT * FROM users WHERE id = ? AND name = ?;

作用：把这3个查询识别为同一类查询模式
```

**💡 为什么需要查询指纹**：
```
不使用指纹的问题：
• 每个不同参数的查询都被单独统计
• 无法看到查询模式的整体性能
• 分析报告变得冗长难读

使用指纹的好处：
• 将相同模式的查询聚合统计
• 更容易发现有问题的查询模式
• 分析报告更加清晰有重点
```

### 5.2 指纹生成规则


**🔧 指纹生成的核心规则**：

```
1. 数字替换为 ?
   123 → ?
   3.14 → ?

2. 字符串替换为 ?  
   'hello' → ?
   "world" → ?

3. IN列表简化
   IN (1,2,3,4,5) → IN(?+)
   
4. 空白字符标准化
   多个空格 → 单个空格
   换行符 → 空格

5. 关键字大小写标准化
   select → SELECT
   from → FROM
```

**📊 指纹示例对比**：
```
原始SQL                              查询指纹
--------------------------------------------------------------------
SELECT * FROM users WHERE id=1       SELECT * FROM users WHERE id=?
SELECT * FROM users WHERE id=999     SELECT * FROM users WHERE id=?

UPDATE users SET name='john'         UPDATE users SET name=? 
  WHERE id=123                         WHERE id=?
UPDATE users SET name='mary'         UPDATE users SET name=?
  WHERE id=456                         WHERE id=?

SELECT * FROM orders WHERE           SELECT * FROM orders WHERE 
  user_id IN (1,2,3)                   user_id IN(?+)
SELECT * FROM orders WHERE           SELECT * FROM orders WHERE
  user_id IN (5,6,7,8,9,10)            user_id IN(?+)
```

### 5.3 查询指纹的实际应用


**🎯 如何利用查询指纹优化**：

```
步骤1: 识别高频查询模式
通过指纹聚合，找出执行最频繁的查询模式

步骤2: 分析查询模式性能
评估每种查询模式的平均执行时间

步骤3: 优化代表性查询
为查询模式创建合适的索引

步骤4: 验证优化效果
对比优化前后同一指纹的性能变化
```

**💡 实战技巧**：
```bash
# 查看具体查询指纹的原始SQL示例
pt-query-digest --limit 5 --sample 2 /var/log/mysql/slow.log

# 参数说明：
# --limit 5: 只显示前5个查询模式
# --sample 2: 每个模式显示2个具体的SQL示例
```

---

## 6. 📈 分析报告结构解读


### 6.1 报告整体结构


**📋 pt-query-digest报告的组成部分**：

```
报告结构图示：
┌─────────────────────────────────────┐
│           1. Overall统计            │ ← 整体概况
├─────────────────────────────────────┤
│           2. Profile概要            │ ← Top查询列表  
├─────────────────────────────────────┤
│           3. 详细分析               │ ← 每个查询的详细信息
│   ├─ Query 1 详情                  │
│   ├─ Query 2 详情                  │  
│   └─ ...                          │
└─────────────────────────────────────┘
```

### 6.2 Overall统计部分详解


**🔍 Overall部分包含的信息**：
```
# Overall: 1.2M total, 850 unique, 125.3 QPS, 2.1x concurrency
# Time range: 2024-01-01T00:00:00 to 2024-01-01T23:59:59
# Attribute          total     min     max     avg     95%  stddev  median
# ============     ======= ======= ======= ======= ======= ======= =======
# Exec time           2.1s    1ms   500ms    25ms    45ms    15ms    20ms
# Lock time           45ms    0       5ms     1ms     2ms     1ms     1ms
# Rows sent          1.2M      0    1000     15      50      25      10
# Rows examined      5.8M      0   10000     68     200     150      50
```

**💡 关键指标解读**：
```
total: 总查询数量 1.2M = 120万次查询
unique: 不同的查询指纹数量 850个
QPS: 每秒查询数 125.3次/秒
concurrency: 平均并发度 2.1（同时执行的查询数）

Exec time: 查询执行时间统计
• total: 所有查询的总执行时间
• avg: 平均执行时间  
• 95%: 95%的查询执行时间低于此值
• median: 中位数（50%查询的执行时间）

Lock time: 锁等待时间
Rows sent: 返回给客户端的行数
Rows examined: 扫描的行数（越小越好）
```

### 6.3 Profile概要部分详解


**📊 Profile部分格式解读**：
```
# Profile
# Rank Query ID              Response time Calls R/Call V/M   Item
# ==== ==================== ============= ===== ====== ===== ========
#    1 0xABCD123456789...    150.2s  71.2%  2500  0.060  0.05 SELECT users
#    2 0xBCDE234567890...     35.8s  17.0%   800  0.045  0.12 UPDATE orders  
#    3 0xCDEF345678901...     25.0s  11.8%   200  0.125  0.03 DELETE logs

各列含义详解：
Rank: 排名（默认按Response time排序）
Query ID: 查询指纹的唯一标识（16进制）
Response time: 总响应时间和占比
Calls: 执行次数
R/Call: 平均每次执行时间（Response time / Calls）
V/M: 变异系数（Variance-to-mean ratio）表示时间波动
Item: 查询类型描述
```

**🎯 如何读懂Profile表**：
```
重点关注顺序：
1. 看Response time占比
   → 占比高的查询对性能影响最大

2. 看R/Call平均时间
   → 单次执行时间长的查询需要优化

3. 看Calls执行次数
   → 高频查询即使单次快，累积影响也大

4. 看V/M变异系数
   → 值大说明执行时间不稳定，可能有锁竞争
```

### 6.4 详细分析部分解读


**📋 单个查询的详细信息结构**：
```
# Query 1: 0.42 QPS, 0.03x concurrency, ID 0xABCD123456789... at byte 1250
# This item is included in the report because it matches --limit.
# Databases: myapp (90%), test (10%)
# Hosts: web01 (60%), web02 (40%)  
# Users: appuser (95%), admin (5%)
# Query_time distribution
#   1us
#  10us
# 100us
#   1ms  ################################################################
#  10ms  ######################
# 100ms  #######
#    1s  #
#  10s+
# Tables
#    SHOW TABLE STATUS FROM `myapp` LIKE 'users'\G
#    SHOW CREATE TABLE `myapp`.`users`\G
# EXPLAIN /*!50100 PARTITIONS*/
SELECT * FROM users WHERE email = 'user@example.com'\G
```

**💡 详细信息解读**：
```
QPS: 该查询每秒执行次数
concurrency: 该查询的平均并发度
Databases: 查询涉及的数据库分布
Hosts: 发起查询的主机分布  
Users: 执行查询的用户分布

Query_time distribution: 执行时间分布图
• 用#号的长度表示该时间段的查询数量
• 可以直观看出查询时间的分布情况

Tables: 相关表的结构信息
• 显示表状态和创建语句
• 便于分析索引和表结构问题

EXPLAIN: 查询执行计划
• 分析查询的执行路径
• 识别性能瓶颈
```

---

## 7. ⚙️ 基础命令参数详解


### 7.1 常用基础参数


**📋 最常用的命令参数**：

| 参数 | 作用 | 示例 | 说明 |
|------|------|------|------|
| `--limit` | 限制分析的查询数量 | `--limit 10` | 只分析Top 10查询 |
| `--order-by` | 指定排序方式 | `--order-by Query_time:sum` | 按总执行时间排序 |
| `--since` | 指定开始时间 | `--since '2024-01-01 00:00:00'` | 只分析指定时间之后的日志 |
| `--until` | 指定结束时间 | `--until '2024-01-01 23:59:59'` | 只分析指定时间之前的日志 |
| `--filter` | 设置过滤条件 | `--filter '$event->{db} eq "mydb"'` | 只分析特定数据库 |

### 7.2 输出控制参数


**🎯 控制输出内容的参数**：

```bash
# 控制显示内容的详细程度
--report-format=compact          # 紧凑格式
--report-format=full            # 完整格式（默认）

# 控制每个查询的示例数量
--sample 2                      # 每个查询显示2个具体示例

# 不显示表结构信息
--no-report                     # 只输出profile，不显示详细分析

# 输出到文件
--output=/path/to/report.txt    # 将结果保存到文件
```

**💡 实用组合示例**：
```bash
# 快速查看Top 5慢查询
pt-query-digest --limit 5 --report-format=compact /var/log/mysql/slow.log

# 分析昨天的慢查询并保存结果
pt-query-digest --since '2024-01-01 00:00:00' \
                --until '2024-01-01 23:59:59' \
                --output=/tmp/yesterday_slow.txt \
                /var/log/mysql/slow.log
```

### 7.3 排序和过滤参数详解


**📊 --order-by参数详解**：
```bash
# 按不同维度排序
--order-by Query_time:sum       # 按总执行时间排序（默认）
--order-by Query_time:avg       # 按平均执行时间排序
--order-by Query_time:cnt       # 按执行次数排序
--order-by Rows_examined:sum    # 按扫描行数排序
--order-by Lock_time:sum        # 按锁等待时间排序

# 多维度排序
--order-by Query_time:sum,Query_time:cnt  # 先按总时间，再按次数
```

**🔍 --filter参数高级用法**：
```bash
# 只分析特定数据库
--filter '$event->{db} eq "myapp"'

# 只分析特定用户的查询
--filter '$event->{user} eq "appuser"'

# 只分析执行时间超过5秒的查询
--filter '$event->{Query_time} > 5'

# 只分析扫描行数超过10000的查询  
--filter '$event->{Rows_examined} > 10000'

# 复合条件过滤
--filter '$event->{db} eq "myapp" && $event->{Query_time} > 1'
```

---

## 8. 📁 输入源格式支持


### 8.1 支持的输入格式类型


**📋 pt-query-digest支持的输入源**：

```
┌─────────────────────┬──────────────────┬─────────────────┐
│      输入源类型      │     使用场景      │    指定方式     │
├─────────────────────┼──────────────────┼─────────────────┤
│ 🐌 慢查询日志       │ 性能分析最常用    │ 默认，无需指定   │
│ 📄 二进制日志       │ 数据变更分析     │ --type binlog   │
│ 📝 通用查询日志     │ 所有查询分析     │ --type genlog   │
│ 🌐 tcpdump抓包     │ 网络流量分析     │ --type tcpdump  │
│ 🔄 processlist     │ 实时进程分析     │ --type processlist │
│ 📊 原始查询文件     │ 自定义分析       │ --type rawlog   │
└─────────────────────┴──────────────────┴─────────────────┘
```

### 8.2 各种输入源的使用方法


**🐌 慢查询日志分析（最常用）**：
```bash
# 基本用法（自动识别格式）
pt-query-digest /var/log/mysql/slow.log

# 明确指定类型
pt-query-digest --type slowlog /var/log/mysql/slow.log

# 分析多个慢查询日志文件
pt-query-digest /var/log/mysql/slow.log.* 
```

**📄 二进制日志分析**：
```bash
# 分析binlog文件
pt-query-digest --type binlog mysql-bin.000001

# 分析指定时间范围的binlog
pt-query-digest --type binlog \
                --since '2024-01-01 10:00:00' \
                mysql-bin.000001
```

**📝 通用查询日志分析**：
```bash
# 启用通用查询日志（临时）
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/log/mysql/general.log';

# 分析通用查询日志
pt-query-digest --type genlog /var/log/mysql/general.log
```

### 8.3 输入源选择建议


**🎯 不同场景下的最佳选择**：

```
性能优化分析：
✅ 首选：慢查询日志
• 专门记录慢查询，信息最相关
• 文件大小适中，分析效率高
• 包含详细的性能指标

审计和合规：
✅ 首选：通用查询日志
• 记录所有SQL操作
• 可以追踪数据访问情况
• 适合安全审计需求

主从复制问题：
✅ 首选：二进制日志
• 记录所有数据修改操作
• 可以分析主从延迟原因
• 排查数据一致性问题

生产环境临时分析：
✅ 首选：tcpdump抓包
• 不需要修改数据库配置
• 不产生额外日志文件
• 适合紧急问题排查
```

**⚠️ 注意事项**：
```
通用查询日志：
• 记录所有查询，文件会很大
• 对性能有一定影响
• 建议只在需要时临时启用

二进制日志：
• 主要记录DML操作（INSERT/UPDATE/DELETE）
• SELECT查询不会记录在binlog中
• 文件通常比较大

tcpdump抓包：
• 需要root权限
• 可能包含敏感数据
• 抓包时间不宜过长
```

---

## 9. 🎛️ 过滤条件设置


### 9.1 过滤器基础语法


**🎯 过滤器的作用**：
过滤器让你能够只分析满足特定条件的查询，避免被无关查询干扰，专注于真正需要关注的问题。

```
过滤器语法基础：
--filter '条件表达式'

条件表达式是Perl语法，主要操作符：
• eq: 等于（字符串比较）
• ==: 等于（数值比较）  
• !=: 不等于
• >、<、>=、<=: 大小比较
• &&: 逻辑与
• ||: 逻辑或
• =~: 正则匹配
```

### 9.2 常用过滤条件示例


**📋 按数据库过滤**：
```bash
# 只分析特定数据库
--filter '$event->{db} eq "myapp"'

# 排除特定数据库  
--filter '$event->{db} ne "information_schema"'

# 分析多个指定数据库
--filter '$event->{db} =~ /^(app1|app2|app3)$/'
```

**⏱️ 按执行时间过滤**：
```bash
# 只分析执行时间超过5秒的查询
--filter '$event->{Query_time} > 5'

# 分析执行时间在1-10秒之间的查询
--filter '$event->{Query_time} >= 1 && $event->{Query_time} <= 10'

# 排除执行时间过短的查询
--filter '$event->{Query_time} > 0.1'
```

**👤 按用户过滤**：
```bash
# 只分析特定用户的查询
--filter '$event->{user} eq "appuser"'

# 排除管理员用户的查询
--filter '$event->{user} ne "admin"'

# 分析应用用户的查询（排除系统用户）
--filter '$event->{user} !~ /^(root|admin|backup)$/'
```

**📊 按资源消耗过滤**：
```bash
# 只分析扫描行数超过10000的查询
--filter '$event->{Rows_examined} > 10000'

# 分析锁等待时间较长的查询
--filter '$event->{Lock_time} > 1'

# 分析返回结果集较大的查询
--filter '$event->{Rows_sent} > 1000'
```

### 9.3 复合过滤条件


**🔧 组合多个条件**：
```bash
# 分析特定数据库中的慢查询
--filter '$event->{db} eq "myapp" && $event->{Query_time} > 2'

# 分析高频且较慢的查询（需要结合--order-by使用）
--filter '$event->{Query_time} > 1 && $event->{Query_time} < 10'

# 排除备份用户的长时间查询
--filter '($event->{user} || "") ne "backup" && $event->{Query_time} > 0.5'

# 分析特定时间段且消耗资源多的查询
--filter '$event->{Query_time} > 2 || $event->{Rows_examined} > 50000'
```

### 9.4 过滤器实战技巧


**💡 实用过滤策略**：

```bash
# 策略1: 渐进式过滤分析
# 第一步：整体概览
pt-query-digest /var/log/mysql/slow.log

# 第二步：关注最慢的查询
pt-query-digest --filter '$event->{Query_time} > 10' /var/log/mysql/slow.log

# 第三步：分析特定应用的问题
pt-query-digest --filter '$event->{db} eq "myapp" && $event->{Query_time} > 2' /var/log/mysql/slow.log
```

**🎯 常见过滤场景**：
```bash
# 应用性能调优：只看业务数据库
--filter '$event->{db} !~ /^(information_schema|performance_schema|mysql|sys)$/'

# 索引优化分析：关注扫描行数多的查询
--filter '$event->{Rows_examined} > $event->{Rows_sent} * 10'

# 批处理任务分析：长时间运行的查询
--filter '$event->{Query_time} > 30'

# 高并发分析：短时间但高频的查询
--filter '$event->{Query_time} < 1' --order-by Query_time:cnt
```

---

## 10. 🎨 输出格式定制


### 10.1 报告格式选项


**📋 --report-format参数详解**：

```bash
# 完整格式（默认）
--report-format=full
• 包含完整的统计信息
• 显示详细的查询分析
• 包含表结构和EXPLAIN信息

# 紧凑格式
--report-format=compact  
• 简化的统计信息
• 减少详细分析内容
• 适合快速查看概况

# 仅显示profile
--report-format=profile
• 只显示查询排行榜
• 不包含详细分析
• 适合快速识别TOP查询
```

### 10.2 输出内容控制


**🎛️ 控制输出内容的参数**：

```bash
# 控制分析数量
--limit 10                    # 只分析前10个查询

# 控制样例数量  
--sample 3                    # 每个查询显示3个具体示例

# 禁用特定输出
--no-report                   # 不生成详细报告，只显示profile
--no-create-table-statements  # 不显示建表语句
--no-explain                  # 不显示EXPLAIN信息

# 简化输出
--output-format tsv           # 输出为TSV格式（制表符分隔）
```

**💡 实用组合示例**：
```bash
# 快速概览：只看排行榜
pt-query-digest --report-format=profile --limit 5 /var/log/mysql/slow.log

# 详细分析：完整信息但限制数量
pt-query-digest --limit 3 --sample 2 /var/log/mysql/slow.log

# 自动化处理：简化输出便于脚本解析
pt-query-digest --no-report --output-format tsv /var/log/mysql/slow.log
```

### 10.3 自定义输出和保存


**📁 输出到文件**：
```bash
# 保存分析结果到文件
pt-query-digest --output=/tmp/slow_analysis.txt /var/log/mysql/slow.log

# 同时显示在屏幕和保存到文件
pt-query-digest /var/log/mysql/slow.log | tee /tmp/slow_analysis.txt

# 按日期保存分析结果
REPORT_FILE="/tmp/slow_analysis_$(date +%Y%m%d).txt"
pt-query-digest --output="$REPORT_FILE" /var/log/mysql/slow.log
```

**🔧 结合其他工具处理**：
```bash
# 提取特定信息（如只要查询指纹）
pt-query-digest --no-report /var/log/mysql/slow.log | grep "Query ID"

# 统计分析结果的行数
pt-query-digest --report-format=profile /var/log/mysql/slow.log | wc -l

# 查找特定类型的查询
pt-query-digest /var/log/mysql/slow.log | grep -A 5 -B 5 "SELECT.*users"
```

### 10.4 输出格式化技巧


**🎨 美化和定制输出**：

```bash
# 生成HTML格式报告（需要额外处理）
pt-query-digest /var/log/mysql/slow.log > /tmp/report.txt
# 然后用工具转换为HTML或其他格式

# 生成CSV格式的统计数据
pt-query-digest --output-format tsv /var/log/mysql/slow.log | \
  head -20 > /tmp/top20_queries.tsv

# 提取关键统计信息
pt-query-digest /var/log/mysql/slow.log | \
  grep -E "(Overall|Profile|Query [0-9]+:)" > /tmp/summary.txt
```

**📊 定制化报告内容**：
```bash
# 只关注执行时间信息的报告
pt-query-digest --filter '$event->{Query_time} > 1' \
                --report-format=compact \
                --limit 10 \
                /var/log/mysql/slow.log

# 为不同团队生成不同的报告
# DBA团队：完整详细报告
pt-query-digest --limit 20 /var/log/mysql/slow.log > /tmp/dba_report.txt

# 开发团队：简化版本关注TOP问题
pt-query-digest --report-format=compact --limit 5 \
                /var/log/mysql/slow.log > /tmp/dev_report.txt
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 pt-query-digest本质：MySQL查询性能分析的瑞士军刀
🔸 查询指纹机制：将相似查询归类，便于统计分析
🔸 多数据源支持：慢查询日志、binlog、tcpdump等
🔸 报告结构理解：Overall统计 → Profile排行 → 详细分析
🔸 过滤器应用：精确定位需要分析的查询类型
🔸 输出定制：根据不同需求生成合适的报告格式
```

### 11.2 关键理解要点


**🔹 工具价值理解**：
```
传统排查方式：
• 凭经验猜测可能的慢查询
• 手工查看日志文件，效率低
• 难以统计和量化性能问题

pt-query-digest优势：
• 自动化分析，快速定位问题
• 统计维度丰富，提供量化数据  
• 支持多种数据源，适应不同场景
• 报告格式清晰，便于理解和分享
```

**🔹 分析思路理解**：
```
第一步：整体概览
• 查看Overall统计，了解整体性能水平
• 关注QPS、平均响应时间、并发度等指标

第二步：识别TOP问题
• 查看Profile排行，找出影响最大的查询
• 重点关注Response time占比高的查询

第三步：深入分析
• 查看具体查询的详细信息
• 分析执行计划，识别优化机会

第四步：制定优化策略
• 根据分析结果，制定索引优化策略
• 考虑查询重写或架构调整
```

### 11.3 实际应用指导


**🎯 日常使用场景**：

```
性能监控：
• 每日分析慢查询日志
• 监控关键指标变化趋势
• 建立性能基线和告警机制

问题排查：
• 性能问题出现时快速定位
• 分析特定时间段的查询性能
• 对比优化前后的效果

容量规划：
• 分析查询增长趋势
• 评估硬件资源需求
• 预测性能瓶颈出现时间
```

**💡 最佳实践建议**：

```
定期分析：
• 建立每日/每周的慢查询分析例行工作
• 设置自动化脚本定期生成报告
• 跟踪关键性能指标的变化趋势

分层分析：
• 先整体后局部，先概览后详细
• 根据业务重要性设定分析优先级
• 结合业务场景理解查询性能问题

团队协作：
• 为不同角色生成适合的报告格式
• 建立查询性能问题的沟通机制
• 定期分享分析结果和优化经验
```

### 11.4 学习检查点


```
✅ **基础掌握检查**：
- [ ] 能独立使用pt-query-digest分析慢查询日志
- [ ] 理解查询指纹的概念和作用
- [ ] 能读懂分析报告的各个部分
- [ ] 掌握基本的过滤和排序参数

✅ **进阶应用检查**：
- [ ] 能根据实际需求设置合适的过滤条件
- [ ] 能分析不同类型的输入源（binlog、tcpdump等）
- [ ] 能定制输出格式适应不同的使用场景
- [ ] 能结合EXPLAIN等其他工具深入分析

✅ **实战能力检查**：
- [ ] 能在生产环境中定位性能问题
- [ ] 能制定基于分析结果的优化策略
- [ ] 能建立日常的性能监控和分析流程
- [ ] 能为团队提供查询性能分析支持
```

**🧠 核心记忆要点**：
- pt-query-digest是查询性能分析的核心工具
- 查询指纹让相似查询聚合分析更有意义
- 分析报告结构：Overall → Profile → 详细分析
- 过滤器帮助聚焦真正需要关注的查询
- 输出定制满足不同场景和角色的需求
- 定期分析和持续监控是性能优化的基础