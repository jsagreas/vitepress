---
title: 18、半同步复制
---
## 📚 目录

1. [半同步复制基本概念](#1-半同步复制基本概念)
2. [半同步复制工作原理](#2-半同步复制工作原理)
3. [插件安装与配置](#3-插件安装与配置)
4. [核心参数设置](#4-核心参数设置)
5. [ACK确认机制详解](#5-ACK确认机制详解)
6. [性能影响与优化](#6-性能影响与优化)
7. [故障降级处理](#7-故障降级处理)
8. [监控与状态检查](#8-监控与状态检查)
9. [适用场景分析](#9-适用场景分析)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔄 半同步复制基本概念


### 1.1 什么是半同步复制


**💡 通俗理解**
半同步复制就像发送重要邮件时要求对方"收到请回复"。普通的异步复制就像发邮件后不管对方收没收到，而全同步复制就像面对面交谈必须等对方完全理解。半同步复制介于两者之间，要求至少一个从库确认收到数据。

**🔸 核心定义**
```
半同步复制（Semi-Synchronous Replication）：
- 主库在提交事务时，必须等待至少一个从库确认接收到binlog
- 不需要等待从库完全执行完成，只要确认收到即可
- 提供比异步复制更高的数据安全性
- 性能介于异步复制和全同步复制之间
```

### 1.2 三种复制模式对比


**📊 复制模式特点对比**

| 复制模式 | **数据安全性** | **性能影响** | **主库等待** | **使用场景** |
|---------|-------------|------------|------------|-------------|
| 🚀 **异步复制** | `低` | `无影响` | `不等待` | `高性能要求，可容忍少量数据丢失` |
| ⚖️ **半同步复制** | `中等` | `轻微影响` | `等待ACK确认` | `平衡性能和安全性` |
| 🔒 **全同步复制** | `高` | `较大影响` | `等待完全执行` | `金融等高安全要求场景` |

### 1.3 半同步复制的核心价值


**🎯 解决的问题**
```
异步复制的问题：
❌ 主库宕机时可能丢失未复制的数据
❌ 从库数据滞后，无法保证数据一致性
❌ 故障切换时可能出现数据不一致

半同步复制的解决方案：
✅ 确保至少一个从库接收到数据
✅ 降低主库故障时的数据丢失风险
✅ 提供更可靠的故障切换基础
✅ 性能损耗相对较小
```

---

## 2. ⚙️ 半同步复制工作原理


### 2.1 基本工作流程


**🔄 半同步复制执行流程**
```
客户端                主库                   从库
   |                   |                      |
   |--[1]执行事务------>|                      |
   |                   |--[2]写入binlog------>|
   |                   |                      |--[3]接收binlog
   |                   |<-[4]发送ACK确认------|
   |                   |--[5]提交事务-------->|
   |<--[6]返回成功------|                      |
   |                   |                      |--[7]执行事务
```

**💡 关键理解要点**
- **步骤2-4**：主库必须等待从库的ACK确认
- **步骤5**：收到确认后主库才提交事务
- **步骤7**：从库可以异步执行，不影响主库响应

### 2.2 ACK确认的含义


**📝 ACK确认机制解释**
```
ACK确认表示什么：
✅ 从库已经接收到binlog事件
✅ binlog已经写入从库的relay log
✅ 数据已经持久化到从库磁盘

ACK确认不表示什么：
❌ 从库已经执行完这个事务
❌ 从库数据已经更新完成
❌ 从库与主库数据完全一致
```

### 2.3 插件架构原理


**🏗️ 半同步复制架构图**
```
主库端架构：
┌─────────────────────────────────────┐
│               主库                   │
│  ┌─────────────┐  ┌─────────────┐   │
│  │   MySQL     │  │ rpl_semi_   │   │
│  │   Server    │  │ sync_master │   │
│  │             │  │   插件      │   │
│  └─────────────┘  └─────────────┘   │
│         │                │          │
│         │                │          │
│    ┌─────────┐      ┌─────────┐     │
│    │ binlog  │      │  ACK    │     │
│    │ events  │      │ 等待队列 │     │
│    └─────────┘      └─────────┘     │
└─────────────────────────────────────┘
              │
              ▼ 网络传输
┌─────────────────────────────────────┐
│               从库                   │
│  ┌─────────────┐  ┌─────────────┐   │
│  │   MySQL     │  │ rpl_semi_   │   │
│  │   Server    │  │ sync_slave  │   │
│  │             │  │   插件      │   │
│  └─────────────┘  └─────────────┘   │
│         │                │          │
│    ┌─────────┐      ┌─────────┐     │
│    │ relay   │      │  ACK    │     │
│    │  log    │      │ 发送机制 │     │
│    └─────────┘      └─────────┘     │
└─────────────────────────────────────┘
```

---

## 3. 🔧 插件安装与配置


### 3.1 检查插件可用性


**🔍 检查系统支持**
```sql
-- 检查MySQL版本（需要5.5+）
SELECT VERSION();

-- 检查插件目录
SHOW VARIABLES LIKE 'plugin_dir';

-- 查看可用插件
SELECT * FROM INFORMATION_SCHEMA.PLUGINS 
WHERE PLUGIN_NAME LIKE '%semi%';
```

### 3.2 主库插件安装


**📦 主库端安装配置**
```sql
-- 1. 安装主库半同步插件
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';

-- 2. 验证插件安装
SHOW PLUGINS;

-- 3. 启用半同步复制
SET GLOBAL rpl_semi_sync_master_enabled = 1;

-- 4. 设置超时时间（毫秒）
SET GLOBAL rpl_semi_sync_master_timeout = 10000;

-- 5. 检查状态
SHOW STATUS LIKE 'Rpl_semi_sync_master%';
```

**💡 配置文件持久化**
```ini
# my.cnf 主库配置
[mysqld]
# 加载插件
plugin-load = "rpl_semi_sync_master=semisync_master.so"

# 启用半同步复制
rpl_semi_sync_master_enabled = 1

# 超时设置（10秒）
rpl_semi_sync_master_timeout = 10000

# 等待从库数量
rpl_semi_sync_master_wait_for_slave_count = 1
```

### 3.3 从库插件安装


**📦 从库端安装配置**
```sql
-- 1. 安装从库半同步插件
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';

-- 2. 启用半同步复制
SET GLOBAL rpl_semi_sync_slave_enabled = 1;

-- 3. 重启IO线程使配置生效
STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;

-- 4. 检查状态
SHOW STATUS LIKE 'Rpl_semi_sync_slave%';
```

**💡 从库配置文件**
```ini
# my.cnf 从库配置
[mysqld]
# 加载插件
plugin-load = "rpl_semi_sync_slave=semisync_slave.so"

# 启用半同步复制
rpl_semi_sync_slave_enabled = 1
```

### 3.4 安装验证


**✅ 验证安装是否成功**
```sql
-- 主库验证
SHOW STATUS LIKE 'Rpl_semi_sync_master_status';
-- 结果应该显示：ON

-- 从库验证  
SHOW STATUS LIKE 'Rpl_semi_sync_slave_status';
-- 结果应该显示：ON

-- 检查半同步连接数
SHOW STATUS LIKE 'Rpl_semi_sync_master_clients';
-- 应该显示连接的半同步从库数量
```

---

## 4. 🎛️ 核心参数设置


### 4.1 主库关键参数


**⚡ rpl_semi_sync_master_timeout**
```sql
-- 超时参数详解
SET GLOBAL rpl_semi_sync_master_timeout = 10000;

含义解释：
🔸 等待从库ACK确认的最大时间（毫秒）
🔸 超时后自动降级为异步复制
🔸 默认值：10000毫秒（10秒）
🔸 取值范围：0 - 4294967295

推荐设置：
生产环境：10000-30000毫秒
测试环境：5000-10000毫秒
高延迟网络：30000-60000毫秒
```

**👥 rpl_semi_sync_master_wait_for_slave_count**
```sql
-- 等待从库数量
SET GLOBAL rpl_semi_sync_master_wait_for_slave_count = 1;

参数说明：
🔸 主库等待多少个从库确认后才提交
🔸 默认值：1（等待一个从库确认）
🔸 取值范围：1 - 65535

使用建议：
单从库环境：设置为1
多从库环境：可设置为2，提高安全性
高可用环境：根据从库数量和容错需求调整
```

**🔄 rpl_semi_sync_master_wait_point**
```sql
-- 等待点设置（MySQL 5.7+）
SET GLOBAL rpl_semi_sync_master_wait_point = 'AFTER_SYNC';

参数选项：
🔸 AFTER_SYNC：在sync binlog后等待（推荐）
🔸 AFTER_COMMIT：在commit后等待

区别说明：
AFTER_SYNC：更安全，但性能稍差
AFTER_COMMIT：性能更好，但安全性稍低
```

### 4.2 从库关键参数


**📡 从库端参数配置**
```sql
-- 启用从库半同步
SET GLOBAL rpl_semi_sync_slave_enabled = 1;

-- 检查从库配置
SHOW VARIABLES LIKE 'rpl_semi_sync_slave%';
```

### 4.3 参数调优建议


**🎯 根据业务场景调优**
```
高性能场景：
- timeout: 5000-10000ms
- wait_point: AFTER_COMMIT
- wait_for_slave_count: 1

高安全场景：
- timeout: 30000-60000ms  
- wait_point: AFTER_SYNC
- wait_for_slave_count: 2

网络不稳定：
- timeout: 60000ms+
- 增加重试机制
- 监控网络延迟
```

---

## 5. 🤝 ACK确认机制详解


### 5.1 ACK确认时序


**⏱️ 详细确认时序图**
```
时间轴    主库操作              从库操作              网络传输
  |                              |                      |
  |--事务开始                    |                      |
  |                              |                      |
  |--写入binlog                  |                      |
  |                              |                      |
  |--发送binlog事件------------->|                      |--传输binlog
  |                              |                      |
  |  等待ACK                     |--接收binlog          |
  |    ⏳                       |                      |
  |    ⏳                       |--写入relay log       |
  |    ⏳                       |                      |
  |<--ACK确认---------------------|--发送ACK            |--传输ACK
  |                              |                      |
  |--事务提交                    |                      |
  |                              |                      |
  |--返回客户端成功               |--异步执行事务         |
```

### 5.2 ACK确认条件


**✅ 什么情况下发送ACK**
```
从库发送ACK的前提条件：
1️⃣ 半同步插件已启用
2️⃣ IO线程正常运行
3️⃣ binlog事件成功接收
4️⃣ relay log成功写入磁盘
5️⃣ 没有发生IO错误

不发送ACK的情况：
❌ 从库半同步功能未启用
❌ IO线程停止或异常
❌ 网络连接中断
❌ relay log写入失败
❌ 从库存储空间不足
```

### 5.3 ACK确认失败处理


**🛠️ 确认失败的处理机制**
```
超时降级流程：
主库等待ACK → 超时判断 → 降级为异步 → 记录警告

1. 主库发送binlog到从库
2. 等待rpl_semi_sync_master_timeout时间
3. 如果超时未收到ACK：
   - 自动降级为异步复制
   - 事务正常提交
   - 记录警告日志
4. 从库恢复后自动升级回半同步
```

---

## 6. 📊 性能影响与优化


### 6.1 性能影响分析


**⚡ 性能影响因素**
```
主要性能影响：
🔸 网络延迟：主库到从库的网络RTT
🔸 等待时间：ACK确认的等待开销
🔸 从库IO：relay log写入速度
🔸 超时设置：过长影响用户体验

性能损耗量化：
网络延迟1ms：每个事务增加1ms等待
网络延迟10ms：每个事务增加10ms等待
从库IO慢：可能导致ACK延迟
```

**📈 性能测试对比**
```
测试环境：主从库同机房，1ms网络延迟

异步复制：
- TPS: 10000
- 平均响应时间: 2ms
- 数据丢失风险: 存在

半同步复制：
- TPS: 8500 (降低15%)
- 平均响应时间: 3ms (增加1ms)
- 数据丢失风险: 大幅降低
```

### 6.2 性能优化策略


**🚀 网络优化**
```sql
-- 1. 优化网络配置
-- 确保主从库网络连接稳定
-- 使用专用网络避免网络抖动
-- 考虑使用万兆网卡

-- 2. 调整MySQL网络参数
SET GLOBAL slave_net_timeout = 60;
SET GLOBAL master_retry_count = 86400;
```

**🔧 从库优化**
```sql
-- 1. 提升从库IO性能
-- 使用SSD存储
-- 调整innodb_flush_log_at_trx_commit
SET GLOBAL innodb_flush_log_at_trx_commit = 2;

-- 2. 优化relay log设置
SET GLOBAL relay_log_recovery = 1;
SET GLOBAL relay_log_info_repository = 'TABLE';
```

**⚙️ 参数调优**
```sql
-- 根据业务特点调整超时时间
-- 高频小事务：较短超时
SET GLOBAL rpl_semi_sync_master_timeout = 5000;

-- 大事务场景：较长超时
SET GLOBAL rpl_semi_sync_master_timeout = 30000;
```

### 6.3 性能监控指标


**📊 关键性能指标**
```sql
-- 1. 半同步等待时间
SHOW STATUS LIKE 'Rpl_semi_sync_master_net_avg_wait_time';

-- 2. 超时次数
SHOW STATUS LIKE 'Rpl_semi_sync_master_no_times';

-- 3. 成功次数
SHOW STATUS LIKE 'Rpl_semi_sync_master_yes_times';

-- 4. 当前状态
SHOW STATUS LIKE 'Rpl_semi_sync_master_status';
```

---

## 7. 🚨 故障降级处理


### 7.1 自动降级机制


**🔄 降级触发条件**
```
自动降级场景：
1️⃣ ACK等待超时
2️⃣ 从库连接断开
3️⃣ 从库半同步功能关闭
4️⃣ 网络异常中断
5️⃣ 从库存储故障

降级过程：
主库检测到异常 → 等待超时时间 → 自动降级为异步 → 继续提供服务
```

**📋 降级状态监控**
```sql
-- 检查是否降级
SHOW STATUS LIKE 'Rpl_semi_sync_master_status';
-- ON: 半同步模式
-- OFF: 已降级为异步模式

-- 查看降级次数
SHOW STATUS LIKE 'Rpl_semi_sync_master_no_times';

-- 查看成功次数
SHOW STATUS LIKE 'Rpl_semi_sync_master_yes_times';
```

### 7.2 手动降级操作


**🛠️ 紧急情况手动降级**
```sql
-- 1. 临时关闭半同步（不影响正在进行的事务）
SET GLOBAL rpl_semi_sync_master_enabled = 0;

-- 2. 验证降级成功
SHOW STATUS LIKE 'Rpl_semi_sync_master_status';

-- 3. 记录降级原因和时间
-- 建议在监控系统中记录此操作
```

### 7.3 恢复升级处理


**🔄 从异步恢复到半同步**
```sql
-- 1. 确认从库连接正常
SHOW SLAVE STATUS\G

-- 2. 确认从库半同步启用
-- 在从库执行：
SHOW STATUS LIKE 'Rpl_semi_sync_slave_status';

-- 3. 主库重新启用半同步
SET GLOBAL rpl_semi_sync_master_enabled = 1;

-- 4. 验证恢复成功
SHOW STATUS LIKE 'Rpl_semi_sync_master_status';
SHOW STATUS LIKE 'Rpl_semi_sync_master_clients';
```

### 7.4 故障处理最佳实践


**📝 故障处理检查清单**
```
故障处理步骤：
☑️ 1. 确认主库服务正常
☑️ 2. 检查网络连通性
☑️ 3. 验证从库状态
☑️ 4. 查看错误日志
☑️ 5. 分析降级原因
☑️ 6. 制定恢复计划
☑️ 7. 执行恢复操作
☑️ 8. 验证恢复效果
☑️ 9. 更新监控告警
☑️ 10. 记录故障总结
```

---

## 8. 📊 监控与状态检查


### 8.1 主库状态监控


**📈 主库关键状态变量**
```sql
-- 半同步状态总览
SHOW STATUS LIKE 'Rpl_semi_sync_master%';

-- 关键指标详解：
SELECT 
    VARIABLE_NAME as '指标名称',
    VARIABLE_VALUE as '当前值',
    CASE VARIABLE_NAME
        WHEN 'Rpl_semi_sync_master_status' THEN 
            CASE VARIABLE_VALUE 
                WHEN 'ON' THEN '✅ 半同步正常'
                ELSE '❌ 已降级为异步'
            END
        WHEN 'Rpl_semi_sync_master_clients' THEN 
            CONCAT('连接的半同步从库数: ', VARIABLE_VALUE)
        WHEN 'Rpl_semi_sync_master_yes_times' THEN 
            CONCAT('成功次数: ', VARIABLE_VALUE)
        WHEN 'Rpl_semi_sync_master_no_times' THEN 
            CONCAT('超时次数: ', VARIABLE_VALUE)
    END as '说明'
FROM performance_schema.global_status 
WHERE VARIABLE_NAME LIKE 'Rpl_semi_sync_master%'
AND VARIABLE_NAME IN (
    'Rpl_semi_sync_master_status',
    'Rpl_semi_sync_master_clients', 
    'Rpl_semi_sync_master_yes_times',
    'Rpl_semi_sync_master_no_times'
);
```

### 8.2 从库状态监控


**📊 从库监控指标**
```sql
-- 从库半同步状态
SHOW STATUS LIKE 'Rpl_semi_sync_slave_status';

-- 复制延迟监控
SHOW SLAVE STATUS\G
-- 重点关注：
-- Seconds_Behind_Master: 复制延迟秒数
-- Slave_IO_Running: IO线程状态
-- Slave_SQL_Running: SQL线程状态
```

### 8.3 告警设置建议


**🚨 监控告警配置**
```sql
-- 告警触发条件示例

-- 1. 半同步状态异常
IF Rpl_semi_sync_master_status = 'OFF' THEN
    ALERT('半同步复制已降级为异步模式');

-- 2. 超时次数异常增长
IF (当前Rpl_semi_sync_master_no_times - 5分钟前数值) > 10 THEN
    ALERT('半同步复制超时次数异常增长');

-- 3. 从库连接数异常
IF Rpl_semi_sync_master_clients < 期望从库数量 THEN
    ALERT('半同步从库连接数不足');

-- 4. 平均等待时间过长
IF Rpl_semi_sync_master_net_avg_wait_time > 100 THEN
    ALERT('半同步复制平均等待时间过长');
```

### 8.4 日常巡检脚本


**🔍 自动化巡检脚本**
```bash
#!/bin/bash
# 半同步复制状态巡检脚本

MYSQL_CMD="mysql -u monitor -p'password' -h localhost"

echo "=== 半同步复制状态检查 ==="
echo "检查时间: $(date)"

# 检查主库半同步状态
echo "1. 主库半同步状态:"
$MYSQL_CMD -e "SHOW STATUS LIKE 'Rpl_semi_sync_master_status';" 2>/dev/null

# 检查连接的从库数量
echo "2. 连接的半同步从库数量:"
$MYSQL_CMD -e "SHOW STATUS LIKE 'Rpl_semi_sync_master_clients';" 2>/dev/null

# 检查成功/失败统计
echo "3. 成功/超时统计:"
$MYSQL_CMD -e "
SELECT 
    SUM(CASE WHEN VARIABLE_NAME='Rpl_semi_sync_master_yes_times' THEN VARIABLE_VALUE ELSE 0 END) as '成功次数',
    SUM(CASE WHEN VARIABLE_NAME='Rpl_semi_sync_master_no_times' THEN VARIABLE_VALUE ELSE 0 END) as '超时次数'
FROM performance_schema.global_status 
WHERE VARIABLE_NAME IN ('Rpl_semi_sync_master_yes_times','Rpl_semi_sync_master_no_times');
" 2>/dev/null

echo "=== 检查完成 ==="
```

---

## 9. 🎯 适用场景分析


### 9.1 推荐使用场景


**✅ 适合半同步复制的场景**

**🏦 金融交易系统**
```
场景特点：
- 数据一致性要求高
- 可接受轻微性能损耗
- 网络环境相对稳定
- 有专业DBA团队维护

配置建议：
timeout: 10000-30000ms
wait_point: AFTER_SYNC
wait_for_slave_count: 2
```

**📊 数据分析平台**
```
场景特点：
- 重要数据不能丢失
- 查询性能要求较高
- 有多个从库承担读负载
- 故障切换需要数据一致

配置建议：
timeout: 15000ms
wait_for_slave_count: 1
定期监控复制延迟
```

**🛒 电商核心系统**
```
场景特点：
- 订单数据至关重要
- 并发量大但可控
- 多机房部署
- 需要快速故障切换

配置建议：
timeout: 5000-10000ms
针对不同机房调整超时
监控网络延迟变化
```

### 9.2 不推荐使用场景


**❌ 不适合半同步复制的场景**

**⚡ 高频交易系统**
```
原因分析：
- 对延迟极其敏感（微秒级）
- 半同步的网络等待不可接受
- 通常使用内存数据库
- 有其他数据保护机制

替代方案：
- 异步复制 + 定期数据备份
- 集群架构保证高可用
- 业务层面的数据校验
```

**🌐 互联网高并发应用**
```
原因分析：
- TPS要求极高（10万+）
- 用户体验对延迟敏感
- 数据量巨大
- 可容忍少量数据丢失

替代方案：
- 异步复制
- 多级缓存架构
- 分库分表
- 最终一致性设计
```

**🔬 实时数据采集系统**
```
原因分析：
- 写入量巨大且持续
- 对写入延迟敏感
- 数据有时效性
- 历史数据可重新采集

替代方案：
- 异步复制
- 批量写入优化
- 数据分区策略
- 定期数据校验
```

### 9.3 场景选择决策树


**🌳 选择决策流程**
```
开始评估
    │
    ▼
数据丢失是否不可接受？
    │
    ├─ 是 ──► 网络延迟是否可控(<10ms)？
    │           │
    │           ├─ 是 ──► 性能损耗是否可接受？
    │           │           │
    │           │           ├─ 是 ──► ✅ 推荐半同步复制
    │           │           └─ 否 ──► 考虑其他高可用方案
    │           │
    │           └─ 否 ──► ❌ 不推荐半同步复制
    │
    └─ 否 ──► 🚀 使用异步复制
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 半同步复制本质：介于异步和全同步之间的折中方案
🔸 ACK确认机制：从库收到binlog后发送确认，主库等待确认后提交
🔸 插件架构：基于rpl_semi_sync_master和rpl_semi_sync_slave插件
🔸 超时降级：超时后自动降级为异步复制，保证服务可用性
🔸 性能平衡：轻微性能损耗换取更高的数据安全性
```

### 10.2 关键理解要点


**🔹 半同步复制的核心价值**
```
数据安全性提升：
- 确保至少一个从库收到数据
- 大幅降低主库故障时的数据丢失风险
- 为故障切换提供更可靠的基础

性能影响可控：
- 只等待ACK确认，不等待执行完成
- 网络延迟是主要影响因素
- 可通过参数调优平衡性能和安全性
```

**🔹 ACK确认的准确含义**
```
ACK表示的是：
✅ 从库已接收到binlog事件
✅ relay log已成功写入磁盘
✅ 数据已持久化保存

ACK不表示：
❌ 从库已执行完该事务
❌ 从库数据已更新
❌ 主从数据完全一致
```

**🔹 故障处理机制**
```
自动容错：
- 超时自动降级为异步
- 从库恢复后自动升级
- 不影响主库正常服务

手动干预：
- 可手动关闭/启用半同步
- 可调整超时参数
- 可强制降级应对紧急情况
```

### 10.3 实际应用指导


**🎯 配置选择原则**
- **金融系统**：高安全性，timeout=30000ms，wait_count=2
- **电商系统**：平衡性能，timeout=10000ms，wait_count=1  
- **数据分析**：重点保护，timeout=15000ms，监控延迟
- **高并发应用**：不推荐使用，选择异步复制

**📊 监控重点**
- **状态监控**：master_status是否为ON
- **性能监控**：avg_wait_time和超时次数
- **连接监控**：clients数量是否符合预期
- **告警设置**：降级、超时、连接异常

**🛠️ 运维最佳实践**
- **参数调优**：根据网络环境和业务特点调整超时时间
- **故障预案**：制定降级和恢复的标准操作流程
- **定期巡检**：使用脚本自动检查半同步状态
- **性能基线**：建立性能基线，及时发现异常

**核心记忆要点**：
- 半同步复制是数据安全和性能的平衡方案
- ACK确认保证数据到达，但不保证执行完成  
- 超时降级机制确保服务可用性
- 适合对数据安全有要求但网络稳定的场景