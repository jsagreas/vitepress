---
title: 14、主从切换操作
---
## 📚 目录

1. [主从切换概述](#1-主从切换概述)
2. [计划性切换流程](#2-计划性切换流程)
3. [应急切换操作](#3-应急切换操作)
4. [数据一致性确认](#4-数据一致性确认)
5. [应用连接切换](#5-应用连接切换)
6. [VIP漂移配置](#6-VIP漂移配置)
7. [切换验证测试](#7-切换验证测试)
8. [回滚方案准备](#8-回滚方案准备)
9. [切换最佳实践](#9-切换最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔄 主从切换概述


### 1.1 什么是主从切换


**简单理解**：主从切换就是把原来的"从库"提升为新的"主库"，原来的主库降为从库或下线。

```
切换前：
主库（写）  →  从库（读）
   |             |
应用写入        应用读取

切换后：
原主库        新主库（写+读）
   |             |
  下线          应用全部连接
```

**切换的本质**：
- **角色互换**：主从角色发生变化
- **流量转移**：应用连接从旧主库转移到新主库
- **权限变更**：新主库获得写权限，旧主库失去写权限

### 1.2 切换场景分类


| 切换类型 | **触发原因** | **时间要求** | **准备程度** |
|---------|------------|-------------|-------------|
| 🕐 **计划性切换** | `主库维护、升级、迁移` | `可控制时间` | `充分准备` |
| 🚨 **应急切换** | `主库故障、不可用` | `立即执行` | `应急处理` |
| 🔄 **演练切换** | `定期演练、测试` | `非生产时间` | `完整流程` |

### 1.3 切换影响评估


**🔸 业务影响**
```
服务中断时间：
- 计划切换：通常1-5分钟
- 应急切换：通常5-30分钟
- 具体时间取决于准备程度和操作熟练度

数据风险：
- 可能的数据丢失（异步复制）
- 数据不一致的风险
- 事务中断的处理
```

**🔸 系统影响**
```
应用层面：
- 连接断开重连
- 事务回滚处理
- 缓存数据失效

监控告警：
- 大量连接错误
- 数据库不可用告警
- 性能指标波动
```

---

## 2. 📋 计划性切换流程


### 2.1 切换前准备工作


**🔸 环境检查**
```sql
-- 1. 检查主从复制状态
SHOW SLAVE STATUS\G

-- 关键指标检查：
-- Slave_IO_Running: Yes
-- Slave_SQL_Running: Yes  
-- Seconds_Behind_Master: 0 或很小
-- Last_Error: 空
```

**🔸 数据一致性确认**
```sql
-- 2. 确认主从数据一致
-- 在主库执行
SELECT COUNT(*) FROM important_table;
SHOW MASTER STATUS;

-- 在从库执行  
SELECT COUNT(*) FROM important_table;
-- 对比结果是否一致
```

**🔸 业务准备**
```
业务层面：
✅ 通知相关团队切换时间
✅ 确认业务低峰期执行
✅ 准备应用配置文件
✅ 确认回滚方案

技术准备：
✅ 备份当前配置
✅ 准备切换脚本
✅ 检查监控系统
✅ 准备应急联系人
```

### 2.2 详细切换步骤


**步骤1：停止应用写入**
```bash
# 方式1：修改应用配置
# 将数据库连接设为只读模式

# 方式2：在主库设置只读
mysql> SET GLOBAL read_only = ON;
mysql> SET GLOBAL super_read_only = ON;
```

**步骤2：等待主从同步完成**
```sql
-- 在主库执行，记录位置
mysql> SHOW MASTER STATUS;
+------------------+----------+
| File             | Position |
+------------------+----------+
| mysql-bin.000123 |     5678 |
+------------------+----------+

-- 在从库检查是否同步到该位置
mysql> SHOW SLAVE STATUS\G
-- 确认：
-- Master_Log_File: mysql-bin.000123
-- Read_Master_Log_Pos: 5678
-- Exec_Master_Log_Pos: 5678
```

**步骤3：停止从库复制**
```sql
-- 在从库执行
mysql> STOP SLAVE;
mysql> SHOW SLAVE STATUS\G
-- 确认：
-- Slave_IO_Running: No
-- Slave_SQL_Running: No
```

**步骤4：提升从库为主库**
```sql
-- 在新主库（原从库）执行
mysql> RESET MASTER;  -- 重置二进制日志
mysql> SET GLOBAL read_only = OFF;  -- 开启写权限
mysql> SET GLOBAL super_read_only = OFF;
```

**步骤5：修改应用连接**
```bash
# 更新应用配置文件
# 将数据库连接地址指向新主库

# 或者使用VIP漂移（推荐）
# 将VIP从旧主库漂移到新主库
```

**步骤6：验证切换结果**
```sql
-- 在新主库测试写入
mysql> INSERT INTO test_table VALUES (NOW(), 'switch_test');
mysql> SELECT * FROM test_table ORDER BY id DESC LIMIT 1;
```

### 2.3 切换时序图


```
应用           旧主库         新主库         运维人员
 |              |              |              |
 |--写入请求--->|              |              |
 |              |--复制数据--->|              |
 |              |              |<--检查同步---|
 |              |<--设置只读---|              |
 |--写入失败--->|              |              |
 |              |              |<--停止复制---|
 |              |              |<--重置主库---|
 |              |              |<--开启写入---|
 |<--更新配置--| |              |              |
 |--写入请求-------------------->|              |
 |<--写入成功---------------------|              |
```

---

## 3. 🚨 应急切换操作


### 3.1 应急场景识别


**🔸 主库故障类型**
```
硬件故障：
- 服务器宕机
- 磁盘损坏
- 网络中断

软件故障：
- MySQL进程死掉
- 系统资源耗尽
- 配置错误导致启动失败

性能问题：
- 响应时间过长
- 锁等待严重
- 连接数耗尽
```

**🔸 故障判断标准**
```sql
-- 连接测试
mysql -h主库IP -u用户名 -p

-- 如果无法连接或连接超时，可能需要切换
```

### 3.2 应急切换决策


**🔸 切换决策矩阵**

| 故障类型 | **恢复时间预估** | **数据丢失风险** | **切换建议** |
|---------|----------------|----------------|-------------|
| 🔧 **硬件故障** | `>30分钟` | `低` | `立即切换` |
| 💾 **软件故障** | `10-30分钟` | `中` | `尝试修复，超时切换` |
| ⚡ **性能问题** | `不确定` | `低` | `先优化，无效则切换` |
| 🌐 **网络问题** | `不确定` | `高` | `确认网络后决策` |

### 3.3 应急切换步骤


**步骤1：快速评估**
```bash
# 检查从库状态
mysql> SHOW SLAVE STATUS\G

# 关键评估点：
# 1. 从库是否正常运行
# 2. 复制延迟是否可接受  
# 3. 是否有复制错误
```

**步骤2：强制停止应用写入**
```bash
# 方式1：应用层面
# 紧急停止写入服务

# 方式2：网络层面
# 阻断应用到旧主库的连接
iptables -I INPUT -s 应用服务器IP -j DROP
```

**步骤3：评估数据丢失**
```sql
-- 检查从库最后接收的事务
mysql> SHOW SLAVE STATUS\G
-- 查看：Read_Master_Log_Pos

-- 如果主库还能连接，对比位置差异
-- 评估可能丢失的数据量
```

**步骤4：紧急提升从库**
```sql
-- 直接提升从库，不等待同步
mysql> STOP SLAVE;
mysql> RESET MASTER;
mysql> SET GLOBAL read_only = OFF;
```

**步骤5：紧急切换连接**
```bash
# VIP漂移（最快方式）
# 将数据库VIP指向新主库

# 或DNS切换
# 修改DNS记录指向新主库
```

### 3.4 应急切换注意事项


> ⚠️ **重要提醒**：应急切换时数据一致性可能受影响，切换后需要立即进行数据核查

**🔸 数据丢失处理**
```
可能丢失的数据：
- 主库故障前未同步到从库的事务
- 正在执行中的事务
- 缓存中未提交的数据

处理方式：
1. 记录切换时间点
2. 收集应用日志中的失败事务
3. 主库恢复后，导出故障期间的binlog
4. 人工核查和补偿数据
```

---

## 4. 🔍 数据一致性确认


### 4.1 切换前一致性检查


**🔸 实时同步状态检查**
```sql
-- 从库执行，检查复制状态
SHOW SLAVE STATUS\G

-- 重点关注：
Seconds_Behind_Master: 0          -- 延迟时间
Slave_IO_Running: Yes            -- IO线程状态  
Slave_SQL_Running: Yes           -- SQL线程状态
Last_Error:                      -- 错误信息（应为空）
```

**🔸 数据量对比验证**
```sql
-- 主要业务表数据量对比
-- 在主库执行
SELECT 
    TABLE_NAME,
    TABLE_ROWS,
    DATA_LENGTH
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = '业务库名'
ORDER BY TABLE_ROWS DESC;

-- 在从库执行相同查询，对比结果
```

**🔸 关键业务数据核查**
```sql
-- 检查最近的关键业务数据
SELECT COUNT(*) FROM orders WHERE create_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR);
SELECT MAX(id) FROM user_table;
SELECT COUNT(*) FROM transaction_log WHERE date = CURDATE();

-- 主从库执行结果应该一致
```

### 4.2 位置信息确认


**🔸 binlog位置对比**
```sql
-- 主库当前位置
SHOW MASTER STATUS;
+------------------+----------+
| File             | Position |
+------------------+----------+
| mysql-bin.000156 |    12345 |
+------------------+----------+

-- 从库已执行位置
SHOW SLAVE STATUS\G
-- 对比以下字段：
-- Master_Log_File: mysql-bin.000156    （应相同）
-- Read_Master_Log_Pos: 12345          （应相同或接近）
-- Exec_Master_Log_Pos: 12345          （应相同）
```

### 4.3 切换后一致性验证


**🔸 新主库状态确认**
```sql
-- 确认新主库可写入
SET autocommit = 0;
BEGIN;
INSERT INTO consistency_test VALUES (NOW(), 'switch_validation');
SELECT * FROM consistency_test ORDER BY id DESC LIMIT 1;
ROLLBACK;  -- 测试完回滚

-- 确认binlog正常生成
SHOW MASTER STATUS;
```

**🔸 应用功能验证**
```
读操作验证：
✅ 查询主要业务数据
✅ 检查数据完整性
✅ 验证索引是否正常

写操作验证：
✅ 插入测试数据
✅ 更新测试数据  
✅ 删除测试数据
✅ 事务操作测试
```

---

## 5. 🔌 应用连接切换


### 5.1 连接切换方式对比


| 切换方式 | **切换速度** | **复杂度** | **影响范围** | **推荐场景** |
|---------|------------|-----------|-------------|-------------|
| 🎯 **VIP漂移** | `10-30秒` | `低` | `透明切换` | `生产环境首选` |
| 🌐 **DNS切换** | `5-10分钟` | `低` | `有缓存延迟` | `非实时业务` |
| 📝 **配置文件** | `需重启应用` | `高` | `应用中断` | `计划维护时` |
| ⚡ **连接池切换** | `1-2分钟` | `中` | `部分连接中断` | `支持动态切换的应用` |

### 5.2 VIP漂移配置


**🔸 VIP漂移原理**
```
VIP（虚拟IP）漂移：
1. 应用连接的是VIP，不是真实数据库IP
2. VIP可以在不同服务器间切换
3. 切换时应用感知不到IP变化

网络结构：
应用服务器 → VIP(192.168.1.100) → 当前主库
                   ↓（切换时）
应用服务器 → VIP(192.168.1.100) → 新主库
```

**🔸 使用keepalived实现VIP**
```bash
# 在旧主库执行（停止keepalived）
systemctl stop keepalived

# 在新主库执行（启动keepalived）  
systemctl start keepalived

# 验证VIP是否切换成功
ip addr show | grep 192.168.1.100
```

**🔸 keepalived配置示例**
```bash
# /etc/keepalived/keepalived.conf
vrrp_instance VI_1 {
    state MASTER                    # 主库配置为MASTER
    interface eth0                  # 网卡接口
    virtual_router_id 51           # 路由ID
    priority 100                   # 优先级，主库高于从库
    advert_int 1                   # 检查间隔
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.1.100              # VIP地址
    }
}
```

### 5.3 应用连接池配置


**🔸 连接池切换配置**
```java
// Spring Boot数据源配置示例
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Primary
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://192.168.1.100:3306/dbname");
        config.setUsername("username");
        config.setPassword("password");
        
        // 连接池配置
        config.setMaximumPoolSize(20);
        config.setConnectionTimeout(30000);      // 30秒连接超时
        config.setIdleTimeout(600000);           // 10分钟空闲超时
        config.setMaxLifetime(1800000);          // 30分钟最大生命周期
        
        return new HikariDataSource(config);
    }
}
```

### 5.4 切换验证测试


**🔸 连接测试脚本**
```bash
#!/bin/bash
# 连接测试脚本

VIP="192.168.1.100"
USER="testuser"
PASS="testpass"
DB="testdb"

echo "开始连接测试..."
for i in {1..10}; do
    mysql -h$VIP -u$USER -p$PASS -e "SELECT NOW() as test_time, $$hostname as server;" $DB
    if [ $? -eq 0 ]; then
        echo "第${i}次连接成功"
    else
        echo "第${i}次连接失败"
    fi
    sleep 1
done
```

---

## 6. 🌐 VIP漂移配置


### 6.1 VIP漂移技术方案


**🔸 常用VIP实现方案**

| 技术方案 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|-------------|
| 🔧 **Keepalived** | `成熟稳定，配置简单` | `功能相对简单` | `中小型环境` |
| ☁️ **云平台VIP** | `高可用，管理方便` | `依赖云平台` | `云环境部署` |
| 🌐 **LVS+Keepalived** | `性能高，功能强` | `配置复杂` | `大型环境` |
| 🔄 **MHA** | `专为MySQL设计` | `学习成本高` | `MySQL专用场景` |

### 6.2 Keepalived详细配置


**🔸 主库keepalived配置**
```bash
# /etc/keepalived/keepalived.conf（主库）
global_defs {
    router_id DB_MASTER         # 标识符
}

vrrp_script chk_mysql {
    script "/etc/keepalived/check_mysql.sh"  # 健康检查脚本
    interval 2                               # 检查间隔2秒
    weight -20                               # 检查失败时优先级降低20
    fall 3                                   # 连续3次失败才判定故障
    rise 2                                   # 连续2次成功才判定恢复
}

vrrp_instance VI_1 {
    state MASTER                # 初始状态
    interface eth0              # 网络接口
    virtual_router_id 51        # 虚拟路由ID
    priority 100                # 优先级（主库设高值）
    advert_int 1                # 广播间隔1秒
    
    authentication {
        auth_type PASS
        auth_pass mysql_ha_2024    # 认证密码
    }
    
    virtual_ipaddress {
        192.168.1.100/24          # VIP地址
    }
    
    track_script {
        chk_mysql                  # 启用MySQL检查
    }
    
    notify_master "/etc/keepalived/notify.sh master"   # 切换为主时执行
    notify_backup "/etc/keepalived/notify.sh backup"   # 切换为备时执行
    notify_fault  "/etc/keepalived/notify.sh fault"    # 故障时执行
}
```

**🔸 从库keepalived配置**
```bash
# /etc/keepalived/keepalived.conf（从库）
global_defs {
    router_id DB_SLAVE          # 从库标识符
}

vrrp_script chk_mysql {
    script "/etc/keepalived/check_mysql.sh"
    interval 2
    weight -20
    fall 3
    rise 2
}

vrrp_instance VI_1 {
    state BACKUP                # 初始状态为备份
    interface eth0
    virtual_router_id 51        # 与主库相同
    priority 90                 # 优先级低于主库
    advert_int 1
    
    authentication {
        auth_type PASS
        auth_pass mysql_ha_2024    # 与主库相同
    }
    
    virtual_ipaddress {
        192.168.1.100/24          # 相同的VIP
    }
    
    track_script {
        chk_mysql
    }
    
    notify_master "/etc/keepalived/notify.sh master"
    notify_backup "/etc/keepalived/notify.sh backup"
    notify_fault  "/etc/keepalived/notify.sh fault"
}
```

### 6.3 健康检查脚本


**🔸 MySQL健康检查脚本**
```bash
#!/bin/bash
# /etc/keepalived/check_mysql.sh

MYSQL_HOST="127.0.0.1"
MYSQL_PORT="3306"
MYSQL_USER="check_user"
MYSQL_PASS="check_pass"

# 检查MySQL进程
MYSQL_PID=$(ps -ef | grep mysqld | grep -v grep | wc -l)
if [ $MYSQL_PID -eq 0 ]; then
    echo "MySQL进程不存在"
    exit 1
fi

# 检查MySQL端口
PORT_CHECK=$(netstat -tlnp | grep :${MYSQL_PORT} | wc -l)
if [ $PORT_CHECK -eq 0 ]; then
    echo "MySQL端口${MYSQL_PORT}未监听"
    exit 1
fi

# 检查MySQL连接
mysql -h${MYSQL_HOST} -P${MYSQL_PORT} -u${MYSQL_USER} -p${MYSQL_PASS} -e "SELECT 1;" > /dev/null 2>&1
if [ $? -ne 0 ]; then
    echo "MySQL连接失败"
    exit 1
fi

# 检查MySQL读写状态
READ_ONLY=$(mysql -h${MYSQL_HOST} -P${MYSQL_PORT} -u${MYSQL_USER} -p${MYSQL_PASS} -e "SELECT $$read_only;" | tail -1)
if [ "$READ_ONLY" = "1" ]; then
    echo "MySQL处于只读状态"
    exit 1
fi

echo "MySQL健康检查通过"
exit 0
```

### 6.4 切换通知脚本


**🔸 状态变化通知脚本**
```bash
#!/bin/bash
# /etc/keepalived/notify.sh

TYPE=$1
NAME="VI_1"
LOG_FILE="/var/log/keepalived_notify.log"

case $TYPE in
    master)
        echo "$(date): 成为MASTER，启用VIP" >> $LOG_FILE
        # 可以在这里添加：
        # 1. 设置MySQL为可写
        # 2. 发送告警通知
        # 3. 更新监控状态
        mysql -e "SET GLOBAL read_only = OFF;" 2>/dev/null
        ;;
    backup)
        echo "$(date): 成为BACKUP，释放VIP" >> $LOG_FILE
        # 可以在这里添加：
        # 1. 设置MySQL为只读
        # 2. 发送告警通知
        mysql -e "SET GLOBAL read_only = ON;" 2>/dev/null
        ;;
    fault)
        echo "$(date): 故障状态" >> $LOG_FILE
        ;;
esac
```

---

## 7. ✅ 切换验证测试


### 7.1 切换前验证清单


**🔸 基础环境验证**
```bash
# 1. 网络连通性测试
ping -c 3 新主库IP
telnet 新主库IP 3306

# 2. 服务状态检查
systemctl status mysql
systemctl status keepalived

# 3. 磁盘空间检查
df -h
du -sh /var/lib/mysql/
```

**🔸 数据库状态验证**
```sql
-- 4. 从库状态检查
SHOW SLAVE STATUS\G

-- 关键字段验证：
-- Slave_IO_Running: Yes
-- Slave_SQL_Running: Yes
-- Seconds_Behind_Master: 0

-- 5. 权限验证
SHOW GRANTS FOR 'app_user'@'%';

-- 6. 业务表验证
SELECT COUNT(*) FROM 核心业务表;
```

### 7.2 切换过程验证


**🔸 实时监控脚本**
```bash
#!/bin/bash
# 切换过程监控脚本

VIP="192.168.1.100"
LOG_FILE="/tmp/switch_monitor.log"

echo "开始监控切换过程..." | tee -a $LOG_FILE

while true; do
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 检查VIP可达性
    ping -c 1 -W 1 $VIP > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        VIP_STATUS="UP"
    else
        VIP_STATUS="DOWN"
    fi
    
    # 检查MySQL连接
    mysql -h$VIP -u监控用户 -p密码 -e "SELECT $$hostname;" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        MYSQL_STATUS="UP"
        HOSTNAME=$(mysql -h$VIP -u监控用户 -p密码 -e "SELECT $$hostname;" 2>/dev/null | tail -1)
    else
        MYSQL_STATUS="DOWN"
        HOSTNAME="N/A"
    fi
    
    echo "$TIMESTAMP VIP:$VIP_STATUS MySQL:$MYSQL_STATUS Host:$HOSTNAME" | tee -a $LOG_FILE
    sleep 1
done
```

### 7.3 切换后功能验证


**🔸 数据库功能验证**
```sql
-- 1. 读操作验证
SELECT 
    COUNT(*) as total_orders,
    MAX(create_time) as latest_order
FROM orders 
WHERE create_time >= DATE_SUB(NOW(), INTERVAL 1 DAY);

-- 2. 写操作验证
INSERT INTO switch_test_table (test_time, test_data) 
VALUES (NOW(), 'switch_validation_test');

-- 3. 事务验证
BEGIN;
UPDATE user_balance SET balance = balance + 100 WHERE user_id = 1;
SELECT balance FROM user_balance WHERE user_id = 1;
ROLLBACK;  -- 测试完成后回滚

-- 4. 复制验证（如果有新的从库）
SHOW MASTER STATUS;
```

**🔸 应用层验证**
```bash
# 应用连接验证脚本
#!/bin/bash

API_BASE="http://应用服务器/api"
TEST_COUNT=10

echo "开始应用功能验证..."

for i in $(seq 1 $TEST_COUNT); do
    # 测试读操作
    READ_RESULT=$(curl -s "$API_BASE/user/info?id=1" | jq '.status')
    
    # 测试写操作  
    WRITE_RESULT=$(curl -s -X POST "$API_BASE/user/update" \
        -H "Content-Type: application/json" \
        -d '{"id":1,"name":"test"}' | jq '.status')
    
    echo "第${i}次测试 - 读:$READ_RESULT 写:$WRITE_RESULT"
    sleep 1
done
```

### 7.4 性能验证测试


**🔸 数据库性能基准测试**
```bash
# 使用sysbench进行性能测试
# 读写混合测试
sysbench oltp_read_write \
    --mysql-host=192.168.1.100 \
    --mysql-port=3306 \
    --mysql-user=test_user \
    --mysql-password=test_pass \
    --mysql-db=test_db \
    --tables=10 \
    --table-size=100000 \
    --threads=16 \
    --time=60 \
    --report-interval=10 \
    run

# 关注指标：
# QPS (Queries Per Second)
# TPS (Transactions Per Second)  
# 延迟 (Latency)
```

---

## 8. 🔄 回滚方案准备


### 8.1 回滚场景分析


**🔸 需要回滚的情况**
```
技术问题：
❌ 新主库性能异常
❌ 应用连接问题
❌ 数据不一致发现
❌ 关键功能异常

业务问题：
❌ 业务流程中断
❌ 数据丢失影响业务
❌ 用户体验严重下降
❌ 监管合规问题
```

### 8.2 回滚准备工作


**🔸 回滚前置条件**
```bash
# 1. 原主库状态确认
# 确保原主库可以启动和提供服务

systemctl status mysql
mysql -e "SELECT $$hostname, NOW();"

# 2. 数据差异评估
# 评估切换期间在新主库上的数据变更

mysql> SHOW MASTER STATUS;  # 记录新主库的binlog位置

# 3. 备份当前状态
mysqldump --single-transaction --routines --triggers \
    --all-databases > /backup/before_rollback_$(date +%Y%m%d_%H%M%S).sql
```

**🔸 回滚决策时间窗口**

| 切换时长 | **回滚复杂度** | **数据风险** | **建议** |
|---------|--------------|-------------|---------|
| `< 5分钟` | `简单` | `低` | `可快速回滚` |
| `5-30分钟` | `中等` | `中` | `评估后决策` |
| `> 30分钟` | `复杂` | `高` | `优先修复当前问题` |

### 8.3 回滚执行步骤


**🔸 快速回滚流程**
```bash
# 步骤1：停止新主库写入
mysql> SET GLOBAL read_only = ON;
mysql> SET GLOBAL super_read_only = ON;

# 步骤2：评估数据差异
mysql> SHOW MASTER STATUS;
# 记录新主库的binlog位置：File和Position

# 步骤3：启动原主库
systemctl start mysql
mysql> SET GLOBAL read_only = OFF;

# 步骤4：VIP回切
# 将VIP从新主库切回原主库
systemctl stop keepalived    # 在新主库执行
systemctl start keepalived   # 在原主库执行

# 步骤5：验证回滚
mysql -h VIP地址 -e "SELECT $$hostname;"
```

**🔸 数据同步回滚**
```sql
-- 如果需要将新主库上的变更同步回原主库

-- 1. 导出新主库的增量数据
mysqldump --single-transaction \
    --where="create_time >= '切换时间点'" \
    新主库 业务表 > /tmp/incremental_data.sql

-- 2. 在原主库导入增量数据
mysql 原主库 < /tmp/incremental_data.sql

-- 3. 验证数据一致性
-- 比较关键业务表的数据量和最新记录
```

### 8.4 回滚验证测试


**🔸 回滚后验证清单**
```sql
-- 1. 基础连接验证
SELECT $$hostname, NOW(), $$read_only;

-- 2. 业务数据验证
SELECT COUNT(*) FROM orders WHERE create_time >= '切换开始时间';
SELECT COUNT(*) FROM users WHERE last_login >= '切换开始时间';

-- 3. 写入功能验证
INSERT INTO rollback_test (test_time, note) 
VALUES (NOW(), 'rollback_verification');

-- 4. 主从状态验证（如果重新建立主从）
SHOW MASTER STATUS;  -- 在回滚后的主库执行
```

### 8.5 回滚后处理


**🔸 问题分析和总结**
```
必须完成的工作：
✅ 记录回滚原因和过程
✅ 分析切换失败的根本原因
✅ 评估数据影响范围
✅ 制定预防措施

后续优化：
✅ 完善切换流程
✅ 加强验证测试
✅ 改进监控告警
✅ 提升团队技能
```

---

## 9. 🎯 切换最佳实践


### 9.1 切换前准备最佳实践


**🔸 完善的准备清单**
```
技术准备：
✅ 完整的切换脚本和回滚脚本
✅ 详细的操作手册和检查清单
✅ 监控告警配置验证
✅ 备份和恢复方案确认

团队准备：
✅ 明确角色分工和责任人
✅ 建立沟通机制和升级流程
✅ 准备应急联系方式
✅ 安排技术专家在线支持

业务准备：
✅ 选择业务低峰期执行
✅ 提前通知相关业务团队
✅ 准备业务影响说明
✅ 制定用户沟通方案
```

**🔸 演练和测试**
```bash
# 定期进行切换演练
# 建议每季度在测试环境进行一次完整演练

演练内容：
1. 完整切换流程演练
2. 应急切换场景演练  
3. 回滚流程演练
4. 团队协作演练

演练评估：
- 记录每个步骤的耗时
- 发现流程中的问题点
- 优化操作手册
- 提升团队熟练度
```

### 9.2 切换执行最佳实践


**🔸 操作标准化**
```bash
# 使用标准化脚本，避免手工操作错误

#!/bin/bash
# 主从切换标准脚本

set -e  # 遇到错误立即退出

# 配置参数
OLD_MASTER="192.168.1.10"
NEW_MASTER="192.168.1.11"  
VIP="192.168.1.100"
MYSQL_USER="admin"
MYSQL_PASS="password"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a /var/log/mysql_switch.log
}

# 错误处理函数
error_exit() {
    log "ERROR: $1"
    exit 1
}

# 执行切换
main() {
    log "开始主从切换流程"
    
    # 步骤1：检查环境
    log "步骤1：环境检查"
    check_environment || error_exit "环境检查失败"
    
    # 步骤2：数据同步确认
    log "步骤2：数据同步确认"
    check_sync_status || error_exit "数据同步检查失败"
    
    # 步骤3：执行切换
    log "步骤3：执行切换"
    perform_switch || error_exit "切换执行失败"
    
    # 步骤4：验证结果
    log "步骤4：验证结果"
    verify_switch || error_exit "切换验证失败"
    
    log "主从切换完成"
}

main "$@"
```

**🔸 实时监控和记录**
```bash
# 切换过程实时监控
#!/bin/bash

# 开启详细日志记录
exec > >(tee -a /var/log/switch_monitor.log)
exec 2>&1

# 监控关键指标
while true; do
    echo "=== $(date) ==="
    
    # VIP状态
    ping -c 1 $VIP >/dev/null 2>&1 && echo "VIP: UP" || echo "VIP: DOWN"
    
    # MySQL连接
    mysql -h$VIP -u$USER -p$PASS -e "SELECT $$hostname;" 2>/dev/null || echo "MySQL: DOWN"
    
    # 应用状态
    curl -s http://app-server/health | grep -q "OK" && echo "APP: UP" || echo "APP: DOWN"
    
    sleep 5
done
```

### 9.3 故障处理最佳实践


**🔸 常见问题处理预案**

| 问题类型 | **症状** | **处理方法** | **预防措施** |
|---------|---------|-------------|-------------|
| 🔌 **VIP漂移失败** | `VIP无法访问` | `手动配置VIP，重启keepalived` | `定期检查网络配置` |
| 💾 **数据不一致** | `主从数据差异` | `停止写入，重新同步` | `切换前充分验证` |
| ⚡ **应用连接失败** | `连接超时错误` | `重启应用，检查配置` | `使用连接池配置` |
| 🔄 **复制延迟** | `从库延迟过大` | `等待同步或强制切换` | `监控复制状态` |

**🔸 应急响应流程**
```
发现问题 → 立即评估影响 → 决策处理方案 → 执行处理 → 验证结果

处理原则：
1. 🎯 优先保证业务可用性
2. 🔍 详细记录问题现象
3. ⚡ 快速决策和执行
4. 📝 事后分析和改进
```

### 9.4 安全性最佳实践


**🔸 权限控制**
```sql
-- 创建专用切换用户
CREATE USER 'switch_user'@'%' IDENTIFIED BY '强密码';

-- 授予必要的最小权限
GRANT REPLICATION SLAVE ON *.* TO 'switch_user'@'%';
GRANT SUPER ON *.* TO 'switch_user'@'%';  -- 用于设置read_only
GRANT RELOAD ON *.* TO 'switch_user'@'%'; -- 用于RESET MASTER

-- 定期轮换密码
ALTER USER 'switch_user'@'%' IDENTIFIED BY '新密码';
```

**🔸 操作审计**
```bash
# 启用操作审计日志
# 记录所有切换相关的操作

audit_log() {
    local operation="$1"
    local result="$2"
    echo "$(date '+%Y-%m-%d %H:%M:%S') USER:$(whoami) OP:$operation RESULT:$result" \
        >> /var/log/mysql_switch_audit.log
}

# 使用示例
audit_log "STOP_SLAVE" "SUCCESS"
audit_log "RESET_MASTER" "SUCCESS"
```

### 9.5 性能优化最佳实践


**🔸 切换速度优化**
```
技术优化：
- 使用SSD存储提高IO性能
- 优化网络配置减少延迟
- 使用并行复制加快同步
- 预热新主库避免冷启动

流程优化：
- 提前准备切换脚本
- 并行执行无依赖操作
- 减少人工操作环节
- 优化验证检查流程
```

**🔸 自动化程度提升**
```bash
# 实现自动化切换脚本
# 减少人工干预，提高切换速度和准确性

自动化组件：
1. 故障检测自动化
2. 切换决策自动化  
3. 切换执行自动化
4. 验证测试自动化
5. 通知告警自动化

注意事项：
- 保留人工干预机制
- 充分测试自动化脚本
- 建立完善的日志记录
- 定期review自动化逻辑
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 主从切换本质：将从库提升为主库，实现角色互换
🔸 切换类型：计划性切换（维护）vs 应急切换（故障）
🔸 关键操作：STOP SLAVE、RESET MASTER、VIP漂移
🔸 核心目标：最小化服务中断时间，确保数据一致性
🔸 重要原则：充分准备、谨慎执行、及时验证、快速回滚
```

### 10.2 关键理解要点


**🔹 为什么需要主从切换**
```
业务连续性：
- 主库故障时快速恢复服务
- 减少业务中断时间
- 保证数据可用性

运维需求：
- 主库维护和升级
- 硬件更换和迁移
- 性能优化和调整
```

**🔹 切换过程的核心步骤**
```
数据层面：停止复制 → 确认一致性 → 重置主库
网络层面：VIP漂移 → 连接切换 → 路由更新
应用层面：连接重连 → 功能验证 → 性能确认
```

**🔹 数据一致性的重要性**
```
一致性风险：
- 异步复制可能导致数据丢失
- 切换时机选择影响数据完整性
- 应急切换时数据风险更高

保障措施：
- 切换前充分验证同步状态
- 选择合适的切换时机
- 建立数据核查和补偿机制
```

### 10.3 实际应用指导


**🔸 切换场景决策**
```
计划性切换适用：
✅ 主库维护升级
✅ 硬件更换迁移
✅ 性能优化调整
✅ 定期演练测试

应急切换适用：
✅ 主库硬件故障
✅ 软件致命错误
✅ 网络严重问题
✅ 性能无法恢复
```

**🔸 技术方案选择**
```
VIP漂移：生产环境首选，切换速度快
DNS切换：适合非实时业务，有缓存延迟
配置修改：计划维护时可用，需要重启应用
连接池：支持动态切换的应用环境
```

**🔸 风险控制要点**
```
切换前风险控制：
- 充分验证环境和数据
- 准备详细的操作手册
- 制定完善的回滚方案

切换中风险控制：
- 实时监控切换过程
- 及时发现和处理问题
- 保持团队沟通顺畅

切换后风险控制：
- 全面验证功能和性能
- 监控业务指标变化
- 及时处理用户反馈
```

### 10.4 最佳实践总结


```
准备阶段：
🎯 制定详细的切换计划和检查清单
🎯 定期进行切换演练和团队培训
🎯 建立完善的监控和告警机制
🎯 准备自动化脚本和工具

执行阶段：
🎯 严格按照标准流程执行
🎯 实时记录操作过程和结果
🎯 保持团队之间有效沟通
🎯 遇到问题及时决策和处理

验证阶段：
🎯 全面测试数据库和应用功能
🎯 监控性能指标和业务指标
🎯 收集用户反馈和问题报告
🎯 及时处理发现的问题

改进阶段：
🎯 总结切换过程的经验教训
🎯 优化切换流程和操作手册
🎯 改进自动化工具和脚本
🎯 提升团队技能和响应能力
```

**核心记忆要点**：
- **主从切换**是数据库高可用的重要技术手段
- **数据一致性**是切换过程中最重要的考量因素
- **VIP漂移**是生产环境中最常用的切换方式
- **充分准备**和**反复演练**是成功切换的关键
- **快速回滚**能力是切换风险控制的重要保障