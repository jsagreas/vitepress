---
title: 17、复制过滤配置
---
## 📚 目录

1. [复制过滤概念解析](#1-复制过滤概念解析)
2. [主库端过滤配置](#2-主库端过滤配置)
3. [从库端过滤配置](#3-从库端过滤配置)
4. [通配符过滤规则](#4-通配符过滤规则)
5. [过滤规则优先级机制](#5-过滤规则优先级机制)
6. [过滤配置最佳实践](#6-过滤配置最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 复制过滤概念解析


### 1.1 什么是复制过滤


**🔸 基本定义**
复制过滤就是在MySQL主从复制过程中，**有选择性地复制某些数据库或表**，而不是把主库的所有变更都同步到从库。

```
简单理解：
主库有100个数据库 → 通过过滤 → 从库只同步其中10个数据库

就像筛子一样，把不需要的数据"筛掉"，只让需要的数据通过
```

**🔸 为什么需要过滤**
```
业务场景举例：
1. 敏感数据隔离：财务数据不同步到测试环境
2. 减少存储压力：日志表不需要在从库保存
3. 业务分离：订单库只同步到订单分析从库
4. 测试环境简化：只同步核心业务表
```

### 1.2 过滤的工作位置


**🔧 过滤发生的两个位置**
```
主库端过滤：                  从库端过滤：
主库 → [过滤] → binlog        主库 → binlog → [过滤] → 从库

特点：减少网络传输            特点：精确控制从库内容
适用：粗粒度过滤              适用：细粒度过滤
```

**💡 位置选择建议**
```
主库端过滤：
✅ 当多个从库都不需要某些数据时
✅ 网络带宽有限的环境
❌ 不同从库需要不同数据时

从库端过滤：
✅ 不同从库需要不同的数据子集
✅ 需要灵活调整过滤规则时
✅ 主库配置不便修改时
```

### 1.3 过滤级别分类


**📊 过滤粒度对比**

| 过滤级别 | **作用范围** | **应用场景** | **配置复杂度** |
|---------|------------|-------------|---------------|
| **库级别** | `整个数据库` | `业务模块隔离` | `简单` |
| **表级别** | `具体表` | `精确数据控制` | `中等` |
| **通配符** | `模糊匹配` | `批量规则设置` | `较复杂` |

---

## 2. 🏭 主库端过滤配置


### 2.1 binlog-do-db参数详解


**🔸 参数含义**
`binlog-do-db`参数告诉MySQL：**只有指定的数据库变更才写入binlog**

```ini
# my.cnf 配置示例
[mysqld]
binlog-do-db = shop_db
binlog-do-db = user_db
binlog-do-db = order_db

# 含义：只有这3个数据库的变更会记录到binlog中
```

**⚠️ 重要理解**
```
常见误区：认为是按当前USE的数据库过滤
实际情况：按SQL语句中明确指定的数据库过滤

错误理解示例：
USE shop_db;
UPDATE user_db.users SET name='张三';  
↑ 这条SQL不会被记录，因为操作的是user_db，不是shop_db

正确理解：
USE any_db;
UPDATE shop_db.products SET price=100;
↑ 这条SQL会被记录，因为明确操作shop_db
```

### 2.2 binlog-ignore-db参数详解


**🔸 参数含义**
`binlog-ignore-db`参数告诉MySQL：**指定的数据库变更不要写入binlog**

```ini
# my.cnf 配置示例
[mysqld]
binlog-ignore-db = mysql
binlog-ignore-db = information_schema
binlog-ignore-db = performance_schema
binlog-ignore-db = test_db
binlog-ignore-db = log_db

# 含义：这些数据库的变更不会记录到binlog
```

**💡 典型使用场景**
```
系统数据库过滤：
binlog-ignore-db = mysql              # 系统表变更
binlog-ignore-db = information_schema # 元数据库
binlog-ignore-db = performance_schema # 性能监控库

业务数据库过滤：
binlog-ignore-db = temp_db            # 临时数据库
binlog-ignore-db = log_db             # 日志数据库
binlog-ignore-db = backup_db          # 备份数据库
```

### 2.3 主库端配置示例


**🔧 完整配置示例**
```ini
# /etc/mysql/my.cnf
[mysqld]
# 启用binlog
log-bin = mysql-bin
server-id = 1

# 方式1：只记录指定库（白名单模式）
binlog-do-db = shop_db
binlog-do-db = user_db
binlog-do-db = order_db

# 方式2：排除指定库（黑名单模式）
# binlog-ignore-db = mysql
# binlog-ignore-db = test_db
# binlog-ignore-db = log_db

# 注意：do-db 和 ignore-db 不要同时使用
```

**📋 配置生效验证**
```sql
-- 重启MySQL后验证配置
SHOW MASTER STATUS;

-- 查看binlog内容验证过滤效果
SHOW BINLOG EVENTS IN 'mysql-bin.000001';

-- 在过滤数据库中执行操作测试
USE shop_db;
UPDATE products SET price = price * 1.1;
-- 检查这个操作是否出现在binlog中
```

---

## 3. 🎯 从库端过滤配置


### 3.1 replicate-do-table参数


**🔸 参数含义**
`replicate-do-table`告诉从库：**只同步指定的表**

```ini
# my.cnf 配置示例
[mysqld]
replicate-do-table = shop_db.products
replicate-do-table = shop_db.categories  
replicate-do-table = user_db.users
replicate-do-table = order_db.orders

# 含义：从库只同步这4张表的变更
```

**💡 精确控制示例**
```
业务场景：电商系统数据同步
主库有tables：
- shop_db.products     ✅ 需要同步（商品信息）
- shop_db.categories   ✅ 需要同步（分类信息）
- shop_db.logs         ❌ 不需要同步（操作日志）
- shop_db.temp_data    ❌ 不需要同步（临时数据）

从库配置：
replicate-do-table = shop_db.products
replicate-do-table = shop_db.categories
```

### 3.2 replicate-ignore-table参数


**🔸 参数含义**
`replicate-ignore-table`告诉从库：**不要同步指定的表**

```ini
# my.cnf 配置示例
[mysqld]
replicate-ignore-table = shop_db.logs
replicate-ignore-table = shop_db.sessions
replicate-ignore-table = user_db.login_logs
replicate-ignore-table = system_db.debug_info

# 含义：这些表的变更不会在从库执行
```

**🎯 实际应用场景**
```
性能优化场景：
replicate-ignore-table = app_db.access_logs    # 访问日志表
replicate-ignore-table = app_db.error_logs     # 错误日志表
replicate-ignore-table = app_db.cache_data     # 缓存数据表

安全考虑场景：
replicate-ignore-table = finance_db.salary     # 薪资表
replicate-ignore-table = finance_db.accounts   # 账户表
replicate-ignore-table = admin_db.passwords    # 密码表
```

### 3.3 从库端配置示例


**🔧 完整从库配置**
```ini
# /etc/mysql/my.cnf (从库)
[mysqld]
server-id = 2
relay-log = relay-bin

# 表级别白名单（只同步指定表）
replicate-do-table = shop_db.products
replicate-do-table = shop_db.categories
replicate-do-table = user_db.users
replicate-do-table = order_db.orders

# 或者使用黑名单（排除指定表）
# replicate-ignore-table = shop_db.logs
# replicate-ignore-table = shop_db.sessions
# replicate-ignore-table = user_db.temp_data

# 注意：建议只使用一种模式，避免配置混乱
```

---

## 4. 🔍 通配符过滤规则


### 4.1 replicate-wild-do-table通配符


**🔸 基本语法**
`replicate-wild-do-table`支持使用通配符`%`和`_`来匹配表名

```ini
# 通配符含义
% : 匹配任意长度的任意字符
_ : 匹配单个任意字符

# 配置示例
[mysqld]
replicate-wild-do-table = shop_db.product_%    # 匹配 product_xxx 表
replicate-wild-do-table = user_db.user_2024%   # 匹配 user_2024xxx 表
replicate-wild-do-table = %.core_%             # 匹配所有库的 core_xxx 表
```

**💡 实际应用场景**
```
分表场景：
replicate-wild-do-table = order_db.order_2024%
# 匹配：order_202401, order_202402, order_202403...

日志表场景：
replicate-wild-do-table = log_db.%_log
# 匹配：access_log, error_log, debug_log...

业务模块场景：
replicate-wild-do-table = %.user_%
# 匹配：任意库中以user_开头的表
```

### 4.2 replicate-wild-ignore-table通配符


**🔸 排除模式的通配符**
```ini
# 配置示例
[mysqld]
replicate-wild-ignore-table = %.tmp_%          # 排除所有临时表
replicate-wild-ignore-table = %.%_log          # 排除所有日志表
replicate-wild-ignore-table = test_db.%        # 排除test_db的所有表
replicate-wild-ignore-table = %_backup.%       # 排除备份库的所有表
```

**🎯 典型使用模式**
```
临时数据排除：
replicate-wild-ignore-table = %.temp_%         # 临时表
replicate-wild-ignore-table = %.cache_%        # 缓存表  
replicate-wild-ignore-table = %.session_%      # 会话表

开发测试排除：
replicate-wild-ignore-table = dev_%.%          # 开发库
replicate-wild-ignore-table = test_%.%         # 测试库
replicate-wild-ignore-table = demo_%.%         # 演示库

历史数据排除：
replicate-wild-ignore-table = %.%_2023         # 2023年的表
replicate-wild-ignore-table = archive_db.%     # 归档库
```

### 4.3 通配符高级技巧


**🔧 组合使用示例**
```ini
# 场景：只同步2024年的核心业务表
[mysqld]
# 只同步core开头的2024年表
replicate-wild-do-table = business_db.core_%_2024

# 排除所有日志和临时表
replicate-wild-ignore-table = %.%_log
replicate-wild-ignore-table = %.tmp_%
replicate-wild-ignore-table = %.temp_%
```

**⚠️ 通配符注意事项**
```
性能考虑：
- 通配符匹配有一定开销
- 规则过多会影响复制性能
- 建议规则数量控制在20个以内

优先级问题：
- do-table > ignore-table  
- wild-do-table > wild-ignore-table
- 精确匹配 > 通配符匹配
```

---

## 5. ⚖️ 过滤规则优先级机制


### 5.1 优先级顺序图


```
过滤规则优先级（从高到低）：

1. replicate-do-table (精确表名)
        ↓
2. replicate-ignore-table (精确表名) 
        ↓
3. replicate-wild-do-table (通配符)
        ↓  
4. replicate-wild-ignore-table (通配符)
        ↓
5. 默认行为（全部同步）
```

### 5.2 优先级规则详解


**🔸 规则1：精确匹配优先于通配符**
```ini
# 配置示例
replicate-do-table = shop_db.products          # 精确匹配
replicate-wild-ignore-table = shop_db.%        # 通配符匹配

# 结果：shop_db.products 会被同步
# 原因：精确的 do-table 优先级更高
```

**🔸 规则2：do优先于ignore**
```ini
# 配置示例  
replicate-do-table = user_db.users             # do规则
replicate-ignore-table = user_db.users         # ignore规则

# 结果：user_db.users 会被同步
# 原因：do规则优先级更高
```

**🔸 规则3：表级别优先于库级别**
```ini
# 配置示例
replicate-do-db = shop_db                      # 库级别
replicate-ignore-table = shop_db.logs          # 表级别

# 结果：shop_db库同步，但shop_db.logs不同步
# 原因：表级别规则优先级更高
```

### 5.3 复杂场景分析


**🧩 多规则组合示例**
```ini
[mysqld]
# 库级别：只同步business_db
replicate-do-db = business_db

# 表级别：排除日志表
replicate-ignore-table = business_db.access_logs

# 通配符：排除所有临时表
replicate-wild-ignore-table = business_db.tmp_%

# 精确指定：强制同步特定临时表
replicate-do-table = business_db.tmp_important
```

**📊 优先级分析结果**
```
business_db.products        → 同步 (库级别do规则)
business_db.access_logs     → 不同步 (表级别ignore规则)
business_db.tmp_data        → 不同步 (通配符ignore规则)  
business_db.tmp_important   → 同步 (精确do规则，最高优先级)
other_db.anything          → 不同步 (库级别过滤)
```

### 5.4 优先级冲突解决


**⚠️ 冲突场景处理**
```
Q: 如果同时配置了 do-table 和 ignore-table 怎么办？
A: do-table 优先级更高，表会被同步

Q: 通配符规则互相冲突怎么办？  
A: wild-do-table 优先级高于 wild-ignore-table

Q: 库级别和表级别规则冲突怎么办？
A: 表级别规则优先级更高
```

**💡 最佳实践建议**
```
避免冲突的配置策略：
1. 优先使用库级别过滤（简单场景）
2. 需要精确控制时使用表级别过滤
3. 避免do和ignore规则混用
4. 通配符规则要谨慎，容易产生意外
5. 配置后务必测试验证效果
```

---

## 6. 🛠️ 过滤配置最佳实践


### 6.1 配置原则


**🎯 核心原则**
```
1. 简单优先：能用库级别就不用表级别
2. 明确优先：能用精确匹配就不用通配符
3. 白名单优先：明确需要什么，而不是排除什么
4. 测试验证：配置后必须验证效果
5. 文档记录：配置规则要有清晰文档
```

**⚠️ 常见陷阱**
```
陷阱1：USE database的误解
错误：以为按当前使用的数据库过滤
正确：按SQL中明确指定的数据库过滤

陷阱2：规则冲突
错误：同时配置do和ignore规则导致混乱
正确：选择一种模式并保持一致

陷阱3：通配符滥用  
错误：大量使用复杂通配符规则
正确：简单明确的规则，易于维护
```

### 6.2 环境配置建议


**🏭 生产环境配置**
```ini
# 生产从库 - 保守策略
[mysqld]
# 只同步核心业务库
replicate-do-db = user_db
replicate-do-db = order_db  
replicate-do-db = product_db
replicate-do-db = payment_db

# 排除系统库和日志库
replicate-ignore-db = mysql
replicate-ignore-db = information_schema
replicate-ignore-db = performance_schema
replicate-ignore-db = log_db
```

**🧪 测试环境配置**
```ini
# 测试从库 - 灵活策略
[mysqld]
# 同步主要业务表，排除敏感数据
replicate-do-table = user_db.users
replicate-do-table = order_db.orders
replicate-do-table = product_db.products

# 排除敏感和不必要的表
replicate-ignore-table = user_db.passwords
replicate-ignore-table = payment_db.accounts
replicate-wild-ignore-table = %.%_log
replicate-wild-ignore-table = %.tmp_%
```

### 6.3 监控与维护


**📊 配置效果监控**
```sql
-- 检查从库同步状态
SHOW SLAVE STATUS\G

-- 查看当前过滤规则
SHOW VARIABLES LIKE 'replicate%';

-- 检查特定表是否在同步
SELECT TABLE_SCHEMA, TABLE_NAME 
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA = 'your_db';

-- 比较主从表结构差异
CHECKSUM TABLE your_db.your_table;
```

**🔧 故障排查步骤**
```
1. 检查配置语法
   - 参数名是否正确
   - 数据库名、表名是否存在拼写错误

2. 验证优先级
   - 是否有规则冲突
   - 优先级是否符合预期

3. 测试过滤效果
   - 在主库执行测试操作
   - 检查从库是否按预期同步

4. 查看错误日志
   - 检查MySQL错误日志
   - 关注复制相关的警告信息
```

### 6.4 配置变更流程


**🔄 安全变更步骤**
```
步骤1：备份当前配置
cp /etc/mysql/my.cnf /etc/mysql/my.cnf.backup.$(date +%Y%m%d)

步骤2：在测试环境验证
# 先在测试环境测试新配置

步骤3：停止从库复制
STOP SLAVE;

步骤4：修改配置文件
# 编辑my.cnf文件

步骤5：重启MySQL服务
systemctl restart mysql

步骤6：启动复制并验证
START SLAVE;
SHOW SLAVE STATUS\G

步骤7：测试过滤效果
# 执行测试SQL验证过滤规则
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 复制过滤：有选择性地同步数据，不是全量复制
🔸 过滤位置：主库端（减少网络传输）vs 从库端（精确控制）
🔸 过滤级别：库级别（粗粒度）vs 表级别（细粒度）
🔸 参数分类：do（白名单）vs ignore（黑名单）
🔸 通配符支持：%（任意字符）和_（单个字符）匹配
🔸 优先级机制：精确 > 通配符，do > ignore，表 > 库
```

### 7.2 关键参数对比


| 参数类型 | **主库端** | **从库端** | **作用范围** | **使用场景** |
|---------|-----------|-----------|-------------|-------------|
| **库级别白名单** | `binlog-do-db` | `replicate-do-db` | `整个数据库` | `模块化同步` |
| **库级别黑名单** | `binlog-ignore-db` | `replicate-ignore-db` | `整个数据库` | `排除系统库` |
| **表级别白名单** | `无` | `replicate-do-table` | `具体表` | `精确控制` |
| **表级别黑名单** | `无` | `replicate-ignore-table` | `具体表` | `排除敏感表` |
| **通配符白名单** | `无` | `replicate-wild-do-table` | `模糊匹配` | `批量规则` |
| **通配符黑名单** | `无` | `replicate-wild-ignore-table` | `模糊匹配` | `批量排除` |

### 7.3 配置选择决策树


```
配置选择流程：

需要过滤吗？
├─ 不需要 → 默认全量复制
└─ 需要 → 继续

过滤粒度？
├─ 库级别 → 使用 do-db/ignore-db
└─ 表级别 → 继续

表数量多吗？
├─ 少量表 → 使用精确 do-table/ignore-table  
└─ 大量表 → 使用通配符 wild-do-table/wild-ignore-table

过滤策略？
├─ 明确需要什么 → 使用白名单（do）
└─ 明确排除什么 → 使用黑名单（ignore）
```

### 7.4 实际应用价值


**🎯 业务场景应用**
- **数据安全**：敏感数据不同步到测试环境
- **性能优化**：日志表和临时表不占用从库资源  
- **存储节省**：只同步必要数据，节省磁盘空间
- **网络优化**：减少主从间的数据传输量
- **业务隔离**：不同从库服务不同业务需求

**🔧 运维实践**
- **环境管理**：生产、测试、开发环境的数据隔离
- **备份策略**：备份从库只包含核心数据
- **监控报表**：报表从库只同步分析相关的表
- **容量规划**：根据过滤规则预估从库存储需求

**核心记忆要点**：
- 复制过滤像筛子，选择性同步数据
- 主库端减传输，从库端精控制
- 优先级记清楚：精确胜通配，do胜ignore
- 配置要简单，测试要充分，文档要清晰