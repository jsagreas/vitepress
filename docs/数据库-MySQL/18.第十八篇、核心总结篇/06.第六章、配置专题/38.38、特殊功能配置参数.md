---
title: 38、特殊功能配置参数
---
## 📚 目录

1. [特殊功能配置概述](#1-特殊功能配置概述)
2. [事件调度器配置](#2-事件调度器配置)
3. [权限与安全配置](#3-权限与安全配置)
4. [只读模式配置](#4-只读模式配置)
5. [主从复制配置](#5-主从复制配置)
6. [元数据存储配置](#6-元数据存储配置)
7. [配置最佳实践](#7-配置最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 特殊功能配置概述


### 1.1 什么是特殊功能配置


**通俗理解**：这些配置参数就像是MySQL的"特殊开关"，控制一些高级功能和特殊行为。

```
常规配置：控制基本功能（内存、连接数等）
特殊配置：控制高级功能（定时任务、主从复制、安全策略等）

就像汽车：
- 基本配置：发动机、座椅、空调
- 特殊配置：自动驾驶、防盗系统、定时启动
```

### 1.2 配置文件结构示意


```
my.cnf配置文件结构：
┌─────────────────────────┐
│      [mysqld]           │
├─────────────────────────┤
│  基础配置参数            │ ← 端口、数据目录等
├─────────────────────────┤
│  性能配置参数            │ ← 缓存、连接池等  
├─────────────────────────┤
│  特殊功能配置参数        │ ← 本文重点
│  - 事件调度器           │
│  - 权限控制             │
│  - 只读模式             │
│  - 主从复制             │
└─────────────────────────┘
```

### 1.3 为什么需要特殊功能配置


**实际应用场景**：
- 🕐 **定时任务**：每天凌晨自动清理过期数据
- 🔒 **安全控制**：防止误操作，保护生产数据
- 📚 **读写分离**：主库写入，从库查询
- 🔄 **数据同步**：多个数据库之间数据保持一致

---

## 2. ⏰ 事件调度器配置


### 2.1 event_scheduler 事件调度器


**什么是事件调度器**：
就像手机的定时提醒功能，可以让MySQL在指定时间自动执行特定任务。

```ini
# 启用事件调度器
event_scheduler = ON

# 可选值说明
event_scheduler = OFF     # 关闭（默认）
event_scheduler = ON      # 开启
event_scheduler = DISABLED # 禁用（无法运行时修改）
```

### 2.2 事件调度器的作用


**典型应用场景**：

```sql
-- 示例：每天凌晨2点清理30天前的日志
CREATE EVENT clean_old_logs
ON SCHEDULE EVERY 1 DAY 
STARTS '2024-01-01 02:00:00'
DO
  DELETE FROM access_logs 
  WHERE created_time < DATE_SUB(NOW(), INTERVAL 30 DAY);
```

**运行状态检查**：
```sql
-- 查看事件调度器状态
SHOW VARIABLES LIKE 'event_scheduler';

-- 查看所有事件
SHOW EVENTS;

-- 查看事件执行情况
SELECT * FROM information_schema.EVENTS;
```

### 2.3 使用建议


> 💡 **最佳实践**  
> - 开发环境：通常关闭，避免干扰测试
> - 生产环境：根据需要开启，用于自动化维护任务
> - 注意事项：事件调度器重启后自动恢复运行

---

## 3. 🔐 权限与安全配置


### 3.1 automatic_sp_privileges 自动存储过程权限


**通俗解释**：
当你创建存储过程时，是否自动给创建者执行权限。就像你写了一个程序，系统是否自动给你运行这个程序的权限。

```ini
# 自动授予存储过程权限
automatic_sp_privileges = 1   # 开启（默认）
automatic_sp_privileges = 0   # 关闭
```

**工作原理对比**：

```
开启状态 (=1)：
用户创建存储过程 → 自动获得EXECUTE和ALTER ROUTINE权限

关闭状态 (=0)：
用户创建存储过程 → 需要管理员手动授权才能执行
```

**安全考虑**：
```sql
-- 关闭后需要手动授权
GRANT EXECUTE ON PROCEDURE mydb.my_procedure TO 'user1'@'localhost';
GRANT ALTER ROUTINE ON PROCEDURE mydb.my_procedure TO 'user1'@'localhost';
```

### 3.2 log_bin_trust_function_creators 信任函数创建者


**什么是这个配置**：
控制在开启二进制日志时，普通用户是否可以创建函数。这关系到数据安全和主从复制的一致性。

```ini
# 信任函数创建者
log_bin_trust_function_creators = 0   # 不信任（默认，安全）
log_bin_trust_function_creators = 1   # 信任（方便但有风险）
```

**问题场景**：
```sql
-- 当=0时，普通用户创建函数会报错
CREATE FUNCTION my_func() RETURNS INT
READS SQL DATA
DETERMINISTIC
RETURN (SELECT COUNT(*) FROM users);

-- 错误信息：
-- This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA...
```

**解决方案对比**：

| 方案 | **设置** | **优点** | **缺点** | **适用场景** |
|------|---------|---------|---------|-------------|
| 🔒 **严格模式** | `=0` | `安全性高，符合规范` | `用户创建函数受限` | `生产环境推荐` |
| 🔓 **宽松模式** | `=1` | `用户创建函数方便` | `可能影响主从一致性` | `开发环境可用` |

---

## 4. 📖 只读模式配置


### 4.1 read_only 只读模式


**通俗理解**：
把数据库设置成"只能看不能改"的模式，就像博物馆里的展品，只允许参观不允许触摸。

```ini
# 普通只读模式
read_only = 0   # 关闭（默认）
read_only = 1   # 开启
```

**影响范围**：
```
普通用户：无法执行INSERT、UPDATE、DELETE
超级用户(SUPER权限)：仍然可以修改数据
系统表：仍然可以修改（如用户权限）
```

### 4.2 super_read_only 超级只读模式


**更严格的只读**：
连超级用户也无法修改数据，真正的"只读"状态。

```ini
# 超级只读模式  
super_read_only = 0   # 关闭（默认）
super_read_only = 1   # 开启
```

**两种只读模式对比**：

```
数据修改权限对比：
┌─────────────────┬──────────────┬──────────────┐
│   用户类型       │  read_only=1 │super_read_only=1│
├─────────────────┼──────────────┼──────────────┤
│ 普通用户         │     ❌       │      ❌      │
│ SUPER权限用户    │     ✅       │      ❌      │
│ 系统维护操作     │     ✅       │      ❌      │
└─────────────────┴──────────────┴──────────────┘
```

### 4.3 只读模式应用场景


**典型使用场景**：

```ini
# 主从复制中的从库配置
[mysqld]
read_only = 1                    # 从库只读
super_read_only = 1             # 更严格保护

# 数据迁移时的源库保护
read_only = 1                   # 防止迁移期间数据变更

# 维护期间的保护
super_read_only = 1             # 维护时完全锁定
```

**动态切换**：
```sql
-- 运行时开启只读
SET GLOBAL read_only = 1;
SET GLOBAL super_read_only = 1;

-- 检查状态
SHOW VARIABLES LIKE '%read_only%';
```

---

## 5. 🔄 主从复制配置


### 5.1 skip_slave_start 跳过从库启动


**作用说明**：
控制MySQL启动时是否自动开始主从复制。就像汽车的自动启动功能，你可以选择启动后自动开始工作，还是手动启动。

```ini
# 跳过从库自动启动
skip_slave_start = 1   # 启动时不自动开始复制
# skip_slave_start = 0   # 启动时自动开始复制（默认）
```

**应用场景**：
```
手动控制场景：
- 维护期间：避免自动同步干扰维护工作
- 故障恢复：先检查数据一致性再启动复制
- 测试环境：按需启动复制进行测试
```

### 5.2 slave_compressed_protocol 从库压缩协议


**通俗解释**：
在网络传输时压缩数据，就像发送邮件时压缩附件，可以节省网络带宽但会消耗CPU。

```ini
# 启用从库压缩协议
slave_compressed_protocol = 1   # 启用压缩
slave_compressed_protocol = 0   # 不压缩（默认）
```

**压缩效果示意**：
```
未压缩传输：
主库 ────[1MB数据]────> 从库
     └─ 原始大小传输 ─┘

压缩传输：  
主库 ──[压缩]──[300KB]──[解压]──> 从库
   └─ 节省70%带宽，增加CPU开销 ─┘
```

### 5.3 slave_exec_mode 从库执行模式


**模式说明**：
控制从库如何处理主库传来的SQL语句，特别是在出现冲突时的处理方式。

```ini
# 从库执行模式
slave_exec_mode = STRICT        # 严格模式（默认）
slave_exec_mode = IDEMPOTENT    # 幂等模式
```

**两种模式对比**：

| 模式 | **遇到重复键** | **遇到不存在的行** | **适用场景** |
|------|---------------|------------------|-------------|
| 🔒 **STRICT** | `报错停止复制` | `报错停止复制` | `标准主从复制` |
| 🔄 **IDEMPOTENT** | `忽略错误继续` | `忽略错误继续` | `多主复制、数据修复` |

### 5.4 主从复制日志配置


**log_slow_slave_statements 记录慢从库语句**：

```ini
# 记录从库慢查询
log_slow_slave_statements = 1   # 记录从库慢查询
log_slow_slave_statements = 0   # 不记录（默认）
```

**relay_log_purge 中继日志清除**：

```ini
# 自动清除中继日志
relay_log_purge = 1   # 自动清除（默认）
relay_log_purge = 0   # 不自动清除
```

**中继日志工作原理**：
```
主从复制数据流：
主库 ──[binlog]──> 从库relay log ──[执行]──> 从库数据

relay_log_purge = 1：
执行完成 → 自动删除relay log → 节省磁盘空间

relay_log_purge = 0：  
执行完成 → 保留relay log → 可用于故障分析
```

---

## 6. 💾 元数据存储配置


### 6.1 master_info_repository 主库信息仓库


**作用说明**：
控制从库在哪里存储主库的连接信息（IP地址、端口、用户名等）。

```ini
# 主库信息存储位置
master_info_repository = FILE   # 存储在文件中（旧方式）
master_info_repository = TABLE  # 存储在表中（推荐）
```

**两种存储方式对比**：

```
FILE方式：
/var/lib/mysql/master.info 文件
├── 主库IP地址
├── 主库端口
├── 复制用户名
└── 复制密码

TABLE方式：
mysql.slave_master_info 表
├── 支持事务操作
├── 更好的一致性保证
└── 便于查询和管理
```

### 6.2 relay_log_info_repository 中继日志信息仓库


**功能说明**：
控制从库在哪里存储中继日志的执行进度信息。

```ini
# 中继日志信息存储位置
relay_log_info_repository = FILE   # 存储在文件中
relay_log_info_repository = TABLE  # 存储在表中（推荐）
```

**存储内容对比**：

| 存储方式 | **文件位置/表名** | **优点** | **缺点** |
|---------|------------------|---------|---------|
| 📄 **FILE** | `relay-log.info文件` | `简单直接` | `可能不一致` |
| 📊 **TABLE** | `mysql.slave_relay_log_info表` | `事务安全，一致性好` | `稍微复杂` |

**查看存储的信息**：
```sql
-- TABLE方式查看主库信息
SELECT * FROM mysql.slave_master_info;

-- TABLE方式查看中继日志信息  
SELECT * FROM mysql.slave_relay_log_info;

-- 查看复制状态
SHOW SLAVE STATUS\G
```

---

## 7. 🛠️ 配置最佳实践


### 7.1 开发环境推荐配置


```ini
[mysqld]
# 开发环境特殊配置
event_scheduler = OFF                    # 关闭定时任务
automatic_sp_privileges = 1              # 方便开发调试
log_bin_trust_function_creators = 1      # 允许创建函数
read_only = 0                           # 允许写入
super_read_only = 0                     # 不限制超级用户
```

### 7.2 生产环境推荐配置


```ini
[mysqld]
# 生产环境特殊配置
event_scheduler = ON                     # 启用定时维护任务
automatic_sp_privileges = 0              # 严格权限控制
log_bin_trust_function_creators = 0      # 安全的函数创建
read_only = 0                           # 主库允许写入
super_read_only = 0                     # 主库不限制
```

### 7.3 从库环境推荐配置


```ini
[mysqld]
# 从库特殊配置
skip_slave_start = 0                    # 自动启动复制
slave_compressed_protocol = 1           # 启用压缩节省带宽
slave_exec_mode = STRICT                # 严格模式保证一致性
log_slow_slave_statements = 1           # 记录慢查询便于优化
relay_log_purge = 1                     # 自动清理节省空间
master_info_repository = TABLE          # 使用表存储更安全
relay_log_info_repository = TABLE       # 使用表存储更安全
read_only = 1                          # 从库只读
super_read_only = 1                    # 严格只读保护
```

### 7.4 配置检查命令


```sql
-- 检查特殊功能配置状态
SHOW VARIABLES WHERE Variable_name IN (
    'event_scheduler',
    'automatic_sp_privileges', 
    'log_bin_trust_function_creators',
    'read_only',
    'super_read_only',
    'slave_compressed_protocol',
    'slave_exec_mode',
    'master_info_repository',
    'relay_log_info_repository'
);

-- 检查主从复制状态
SHOW SLAVE STATUS\G

-- 检查事件调度器状态
SHOW PROCESSLIST;
SELECT * FROM information_schema.EVENTS;
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心配置


```
🕐 事件调度器：
• event_scheduler：控制定时任务功能开关
• 用途：自动化数据库维护任务

🔐 权限安全：  
• automatic_sp_privileges：存储过程权限自动授予
• log_bin_trust_function_creators：函数创建信任控制

📖 只读模式：
• read_only：普通只读（SUPER用户仍可写）
• super_read_only：严格只读（所有用户都只读）

🔄 主从复制：
• skip_slave_start：控制复制自动启动
• slave_exec_mode：从库执行模式（严格/宽松）
• 元数据存储：TABLE方式比FILE方式更安全
```

### 8.2 关键理解要点


**🔹 配置的层次性**：
```
基础功能 → 特殊功能 → 高级功能
连接管理 → 权限控制 → 主从复制
性能优化 → 安全保护 → 自动化运维
```

**🔹 安全性与便利性的平衡**：
```
开发环境：优先便利性，配置相对宽松
测试环境：平衡安全性和便利性  
生产环境：优先安全性，配置严格
```

**🔹 主从复制的核心要素**：
```
数据一致性：通过严格模式保证
网络优化：通过压缩协议节省带宽
故障恢复：通过TABLE存储保证元数据安全
运维便利：通过自动化减少人工干预
```

### 8.3 实际应用价值


**🎯 业务场景应用**：
- **电商系统**：从库只读分担查询压力，主库专注写入
- **数据分析**：事件调度器定时ETL处理，生成报表数据
- **安全合规**：严格权限控制，满足数据保护要求
- **运维自动化**：自动清理日志，自动备份数据

**🔧 运维实践**：
- **配置管理**：根据环境选择合适的配置组合
- **监控告警**：监控复制状态，及时发现问题
- **故障处理**：利用元数据表快速定位和修复问题
- **性能优化**：基于慢查询日志优化SQL和索引

**核心记忆**：
- 特殊配置控制高级功能，根据环境选择
- 安全性和便利性需要平衡，生产环境优先安全
- 主从复制需要多个配置协同工作才能稳定
- TABLE存储方式比FILE方式更安全可靠