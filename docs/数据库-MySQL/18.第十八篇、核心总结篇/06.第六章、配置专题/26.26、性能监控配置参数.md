---
title: 26、性能监控配置参数
---
## 📚 目录

1. [性能监控概述](#1-性能监控概述)
2. [Performance Schema核心配置](#2-performance-schema核心配置)
3. [慢查询日志配置](#3-慢查询日志配置)
4. [监控配置最佳实践](#4-监控配置最佳实践)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🔍 性能监控概述


### 1.1 什么是MySQL性能监控


**📋 基本概念**
```
MySQL性能监控就像给数据库装上"体检仪器"
作用：实时了解数据库运行状态，发现性能瓶颈
目标：让数据库跑得更快，避免卡顿和故障
```

**🎯 监控的核心价值**
- **及时发现问题**：在用户感受到慢之前就发现瓶颈
- **优化指导**：知道哪些查询慢，哪些操作频繁
- **容量规划**：了解资源使用情况，提前扩容
- **故障排查**：问题发生时能快速定位原因

### 1.2 MySQL监控体系架构


```
MySQL监控体系架构图：
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   应用程序      │    │   慢查询日志    │    │   监控工具      │
│   SQL查询       │───▶│   记录慢SQL     │───▶│   分析展示      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│Performance Schema│    │   错误日志      │    │   告警系统      │
│ 实时性能数据    │    │   系统异常      │    │   问题通知      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 2. ⚙️ Performance Schema核心配置


### 2.1 Performance Schema基础认知


**🔸 什么是Performance Schema**
```
Performance Schema = MySQL内置的性能监控引擎
作用：收集MySQL运行时的各种性能数据
特点：实时监控，数据存储在内存中，查询速度快
```

**💡 工作原理**
```
工作流程：
SQL执行 → Performance Schema收集数据 → 存储到内存表 → 管理员查询分析

就像医院的监护仪：
患者 = MySQL服务器
监护仪 = Performance Schema  
生命体征数据 = 性能监控数据
医生 = 数据库管理员
```

### 2.2 启用Performance Schema


**🔧 基础启用配置**
```ini
# my.cnf配置文件
[mysqld]
# 启用Performance Schema（MySQL 5.6+默认开启）
performance_schema = ON
```

> 💡 **新手提醒**：Performance Schema在MySQL 5.6以后默认是开启的，但某些云服务商可能会关闭它来节省资源

### 2.3 核心容量参数配置


#### 📊 表实例数配置


**🔸 performance_schema_max_table_instances**
```ini
# 控制能监控多少个表
performance_schema_max_table_instances = 12500

# 通俗理解：
# 就像监控室能同时监控多少个摄像头
# 表越多，这个数值就要设得越大
# 默认值通常够用，除非你的库表特别多
```

**💡 如何确定合适的值**
```sql
-- 查看当前表的数量
SELECT COUNT(*) as table_count 
FROM information_schema.tables 
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys');

-- 建议值 = 实际表数量 × 1.5（预留空间）
```

#### 👥 线程实例数配置


**🔸 performance_schema_max_thread_instances**
```ini
# 控制能监控多少个线程
performance_schema_max_thread_instances = 402

# 通俗理解：
# 每个数据库连接就是一个线程
# 这个参数决定了能同时监控多少个连接的性能
# 值太小会丢失监控数据，值太大会浪费内存
```

**🎯 计算合理值的方法**
```
合理值计算公式：
= max_connections（最大连接数）+ 系统线程数（约50-100）

例如：
max_connections = 300
系统预留线程 = 100  
推荐值 = 300 + 100 = 400
```

#### 🔄 阶段类数配置


**🔸 performance_schema_max_stage_classes**
```ini
# 控制能监控多少种执行阶段
performance_schema_max_stage_classes = 175

# 通俗理解：
# SQL执行有很多阶段：解析、优化、执行、返回结果等
# 这个参数控制能监控多少种不同的阶段
# 一般默认值就够用，不需要特别调整
```

### 2.4 监控对象配置


#### 🎭 参与者设置


**🔸 performance_schema_setup_actors**
```ini
# 配置监控哪些用户的操作
performance_schema_setup_actors_size = 100

# 实际配置需要在运行时设置：
```

```sql
-- 监控所有用户（默认）
UPDATE performance_schema.setup_actors 
SET ENABLED = 'YES', HISTORY = 'YES' 
WHERE HOST = '%' AND USER = '%';

-- 只监控特定用户
DELETE FROM performance_schema.setup_actors;
INSERT INTO performance_schema.setup_actors VALUES
('%', 'app_user', '%', 'YES', 'YES'),
('%', 'admin_user', '%', 'YES', 'YES');
```

> 💡 **实用建议**：生产环境建议只监控应用用户，避免监控系统用户产生过多噪音

#### 📈 消费者设置


**🔸 performance_schema_setup_consumers**
```sql
-- 启用关键的性能监控项
UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' 
WHERE NAME IN (
    'events_statements_current',     -- 当前执行的语句
    'events_statements_history',     -- 语句历史记录
    'events_waits_current',          -- 当前等待事件
    'statements_digest'              -- 语句摘要统计
);
```

**📊 消费者类型说明**
```
┌─────────────────────────────┐
│ 消费者类型                  │ 说明
├─────────────────────────────┼──────────────────────
│ global_instrumentation      │ 全局监控开关
│ thread_instrumentation      │ 线程级监控  
│ events_statements_current   │ 当前SQL语句监控
│ events_statements_history   │ SQL语句历史记录
│ events_waits_current        │ 当前等待事件监控
│ statements_digest           │ SQL摘要统计
└─────────────────────────────┘
```

#### 🎼 仪器设置


**🔸 performance_schema_setup_instruments**
```sql
-- 启用SQL语句监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME LIKE 'statement/%';

-- 启用文件IO监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME LIKE 'wait/io/file/%';

-- 启用表锁监控
UPDATE performance_schema.setup_instruments 
SET ENABLED = 'YES', TIMED = 'YES' 
WHERE NAME LIKE 'wait/lock/table/%';
```

**🔧 常用仪器分类**
```
仪器分类：
statement/*     - SQL语句执行监控
wait/io/*       - IO等待监控  
wait/lock/*     - 锁等待监控
memory/*        - 内存使用监控
stage/*         - 执行阶段监控
```

---

## 3. 📝 慢查询日志配置


### 3.1 慢查询日志基础概念


**🔸 什么是慢查询日志**
```
慢查询日志 = MySQL的"体检报告"
作用：记录执行时间超过指定阈值的SQL语句
目的：找出性能瓶颈，优化慢查询
```

**💡 慢查询的判断标准**
```
判断流程：
SQL开始执行 → 记录开始时间 → SQL执行完毕 → 计算执行时间
↓
执行时间 > long_query_time → 记录到慢查询日志
执行时间 ≤ long_query_time → 不记录
```

### 3.2 基础慢查询配置


**🔧 启用慢查询日志**
```ini
# my.cnf配置
[mysqld]
# 启用慢查询日志
slow_query_log = ON

# 慢查询日志文件位置
slow_query_log_file = /var/log/mysql/mysql-slow.log

# 慢查询时间阈值（秒）
long_query_time = 2.0

# 记录没有使用索引的查询
log_queries_not_using_indexes = ON
```

**⚡ 各参数含义解释**
```
slow_query_log：
  ON = 开启慢查询日志记录
  OFF = 关闭慢查询日志记录

long_query_time：
  单位：秒（可以是小数，如0.1表示100毫秒）
  建议值：1-5秒（根据业务要求调整）
  
log_queries_not_using_indexes：
  记录没有使用索引的查询（即使执行时间很短）
  帮助发现潜在的性能问题
```

### 3.3 高级慢查询配置


#### 🏢 管理语句日志


**🔸 log_slow_admin_statements**
```ini
# 记录管理语句的慢查询
log_slow_admin_statements = ON

# 涵盖的语句类型：
# ALTER TABLE, CREATE INDEX, DROP INDEX
# REPAIR TABLE, ANALYZE TABLE, OPTIMIZE TABLE
```

**💡 实际应用场景**
```
使用场景：
✅ 监控DDL语句性能：CREATE INDEX耗时多久
✅ 表维护操作监控：OPTIMIZE TABLE是否影响业务
✅ 数据库升级评估：ALTER TABLE语句的影响时间

注意事项：
⚠️ 管理语句通常执行时间较长，会产生较多日志
⚠️ 生产环境谨慎开启，避免日志文件过大
```

#### 🔄 从库语句日志


**🔸 log_slow_slave_statements**
```ini
# 记录从库执行的慢查询
log_slow_slave_statements = ON

# 主从复制环境中的应用：
# 监控从库同步性能
# 发现主从延迟的根本原因
```

**🏗️ 主从环境监控架构**
```
主从监控流程：
主库 ──SQL执行──▶ 二进制日志 ──复制──▶ 从库执行
  │                                      │
  ▼                                      ▼
主库慢查询日志                        从库慢查询日志
  │                                      │
  └──────────对比分析找出差异──────────────┘
```

### 3.4 慢查询优化参数


#### 📊 检查行数限制


**🔸 min_examined_row_limit**
```ini
# 最小检查行数限制
min_examined_row_limit = 100

# 含义：只记录检查行数超过指定值的慢查询
# 目的：过滤掉扫描行数很少但执行时间长的查询（通常是等待造成的）
```

**🎯 参数设置策略**
```
设置原则：
min_examined_row_limit = 0    # 记录所有慢查询（默认）
min_examined_row_limit = 100  # 只记录扫描100行以上的慢查询
min_examined_row_limit = 1000 # 只记录扫描1000行以上的慢查询

选择建议：
小型数据库：设为0或100
大型数据库：设为1000-10000
超大型数据库：设为10000以上
```

#### 🚦 索引限流配置


**🔸 log_throttle_queries_not_using_indexes**
```ini
# 限制未使用索引查询的日志记录频率
log_throttle_queries_not_using_indexes = 10

# 含义：每分钟最多记录10条未使用索引的查询
# 目的：防止日志文件被大量重复的无索引查询刷爆
```

**💡 限流机制说明**
```
限流工作原理：
时间窗口：1分钟
计数器：记录当前分钟内已记录的未使用索引查询数量
逻辑：当计数器达到设定值时，停止记录直到下一分钟

实际效果：
设置为10：每分钟最多记录10条无索引查询
设置为0：不限制记录频率
设置为-1：完全禁用无索引查询的记录
```

---

## 4. 🛠️ 监控配置最佳实践


### 4.1 生产环境配置建议


**🏭 生产环境完整配置**
```ini
# my.cnf生产环境推荐配置
[mysqld]
# === Performance Schema配置 ===
performance_schema = ON
performance_schema_max_table_instances = 15000
performance_schema_max_thread_instances = 500
performance_schema_max_stage_classes = 175

# === 慢查询日志配置 ===
slow_query_log = ON
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 1.0
log_queries_not_using_indexes = ON
log_slow_admin_statements = OFF  # 生产环境建议关闭
log_slow_slave_statements = ON   # 主从环境开启
min_examined_row_limit = 1000
log_throttle_queries_not_using_indexes = 10
```

### 4.2 监控配置检查清单


**📋 配置验证步骤**
```sql
-- 1. 检查Performance Schema状态
SHOW VARIABLES LIKE 'performance_schema';

-- 2. 检查慢查询日志配置
SHOW VARIABLES LIKE 'slow_query_log%';
SHOW VARIABLES LIKE 'long_query_time';

-- 3. 查看当前监控统计
SELECT * FROM performance_schema.global_status 
WHERE VARIABLE_NAME LIKE 'Slow_queries';

-- 4. 验证监控数据是否正常收集
SELECT COUNT(*) FROM performance_schema.events_statements_summary_by_digest;
```

### 4.3 性能影响评估


**📊 监控开销分析**
```
Performance Schema开销：
┌─────────────────┬─────────────┬─────────────┐
│ 监控项目        │ CPU开销     │ 内存开销    │
├─────────────────┼─────────────┼─────────────┤
│ 基础监控        │ 1-3%        │ 50-100MB    │
│ 详细语句监控    │ 3-5%        │ 100-200MB   │
│ 全量监控        │ 5-10%       │ 200-500MB   │
└─────────────────┴─────────────┴─────────────┘

慢查询日志开销：
- 磁盘IO：每条慢查询约0.5-2KB日志
- CPU开销：几乎可以忽略
- 存储空间：需要定期清理日志文件
```

### 4.4 监控数据分析示例


**🔍 常用性能分析查询**
```sql
-- 查看最慢的10个SQL
SELECT 
    DIGEST_TEXT,
    COUNT_STAR as exec_count,
    AVG_TIMER_WAIT/1000000000000 as avg_time_sec,
    SUM_TIMER_WAIT/1000000000000 as total_time_sec
FROM performance_schema.events_statements_summary_by_digest 
ORDER BY AVG_TIMER_WAIT DESC 
LIMIT 10;

-- 查看没有使用索引的查询
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    SUM_NO_INDEX_USED,
    SUM_NO_GOOD_INDEX_USED
FROM performance_schema.events_statements_summary_by_digest 
WHERE SUM_NO_INDEX_USED > 0 OR SUM_NO_GOOD_INDEX_USED > 0
ORDER BY COUNT_STAR DESC;
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 Performance Schema：MySQL内置的实时性能监控系统
🔸 慢查询日志：记录执行缓慢SQL语句的日志文件
🔸 监控配置：通过参数控制监控范围和精度
🔸 性能开销：监控本身也会消耗系统资源，需要平衡
```

### 5.2 关键配置参数记忆


**🧠 核心参数速记**
```
Performance Schema核心三要素：
1️⃣ performance_schema = ON （总开关）
2️⃣ max_table_instances （监控表数量）
3️⃣ max_thread_instances （监控线程数量）

慢查询日志核心三要素：
1️⃣ slow_query_log = ON （慢查询开关）
2️⃣ long_query_time = 1.0 （时间阈值）
3️⃣ log_queries_not_using_indexes = ON （索引监控）
```

### 5.3 生产环境应用指导


**🎯 配置策略选择**
```
小型应用（<1000用户）：
- 基础监控即可，重点关注慢查询
- long_query_time = 2.0
- 简化Performance Schema配置

中型应用（1000-10000用户）：
- 标准监控配置
- long_query_time = 1.0  
- 启用关键监控项

大型应用（>10000用户）：
- 精细化监控配置
- long_query_time = 0.5
- 全面监控但控制开销
```

**⚠️ 常见配置陷阱**
```
避免的错误：
❌ 监控参数设置过大，浪费内存
❌ 慢查询阈值设置过小，产生过多日志
❌ 在高并发环境开启所有监控项
❌ 忘记定期清理慢查询日志文件

正确的做法：
✅ 根据实际负载设置合理的参数值
✅ 分阶段启用监控项，观察性能影响
✅ 建立日志轮转和清理机制
✅ 定期分析监控数据，持续优化
```

**核心记忆口诀**：
- 监控配置要适度，性能开销要考虑
- 慢查询日志找瓶颈，Performance Schema看实时
- 参数设置因场景，生产环境要谨慎
- 数据分析是关键，持续优化才有效