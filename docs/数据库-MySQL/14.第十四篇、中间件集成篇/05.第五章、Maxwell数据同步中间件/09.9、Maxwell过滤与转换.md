---
title: 9、Maxwell过滤与转换
---
## 📚 目录

1. [Maxwell过滤机制概述](#1-maxwell过滤机制概述)
2. [表级过滤配置](#2-表级过滤配置)
3. [字段级过滤规则](#3-字段级过滤规则)
4. [数据转换函数](#4-数据转换函数)
5. [正则表达式过滤](#5-正则表达式过滤)
6. [黑白名单机制](#6-黑白名单机制)
7. [条件过滤配置](#7-条件过滤配置)
8. [自定义过滤器](#8-自定义过滤器)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 Maxwell过滤机制概述


### 1.1 什么是Maxwell过滤


**简单理解**：Maxwell过滤就像一个智能筛子，可以精确控制哪些数据需要同步，哪些需要忽略。

```
原始数据库变化：
┌─────────────────┐
│ 用户表更新       │ ← 需要同步
├─────────────────┤
│ 日志表插入       │ ← 不需要同步
├─────────────────┤
│ 订单表删除       │ ← 需要同步
├─────────────────┤
│ 临时表操作       │ ← 不需要同步
└─────────────────┘
         │
    Maxwell过滤
         │
         ▼
┌─────────────────┐
│ 用户表更新       │
├─────────────────┤
│ 订单表删除       │
└─────────────────┘
```

### 1.2 过滤的核心作用


**🔸 减少网络传输**
```
不过滤：100GB数据 → 全部传输 → 下游处理100GB
有过滤：100GB数据 → 只传输10GB → 下游处理10GB
节省：90%的网络带宽和处理资源
```

**🔸 提升同步效率**
- **减少延迟**：只传输需要的数据，延迟更低
- **节省资源**：减少CPU、内存、网络消耗
- **避免干扰**：过滤掉无关数据，专注核心业务

### 1.3 过滤的基本分类


```
Maxwell过滤分类：
┌─ 数据库级别 ─ 包含/排除整个数据库
├─ 表级别 ──── 包含/排除特定表
├─ 字段级别 ── 包含/排除特定字段
├─ 条件级别 ── 根据数据内容过滤
└─ 操作级别 ── 过滤INSERT/UPDATE/DELETE
```

---

## 2. 📋 表级过滤配置


### 2.1 基本表过滤语法


**包含特定表（白名单）**：
```bash
# 只同步用户相关的表
--filter='include:shop_db.users,shop_db.user_profiles'

# 使用通配符匹配
--filter='include:shop_db.user_*'
```

**排除特定表（黑名单）**：
```bash
# 排除日志和临时表
--filter='exclude:shop_db.logs,shop_db.temp_*'

# 排除所有以_bak结尾的表
--filter='exclude:*.%_bak'
```

### 2.2 配置文件方式


**config.properties示例**：
```properties
# 基本表过滤配置
filter=include:shop_db.users,shop_db.orders,shop_db.products

# 或者使用排除模式
# filter=exclude:shop_db.logs,shop_db.sessions,shop_db.temp_*

# 数据库级别过滤
# filter=include:shop_db.*
```

### 2.3 实际应用场景


**💡 电商系统过滤示例**：
```
需要同步的核心业务表：
✅ users          - 用户信息
✅ orders         - 订单数据  
✅ products       - 商品信息
✅ order_items    - 订单明细

不需要同步的表：
❌ access_logs    - 访问日志（数据量大且无业务价值）
❌ sessions       - 会话信息（临时数据）
❌ cache_*        - 缓存表（可重建）
❌ temp_*         - 临时表（无持久化需求）
```

**配置实现**：
```bash
# 启动命令中指定
bin/maxwell --user=maxwell --password=123456 \
  --host=127.0.0.1 --producer=kafka \
  --kafka.bootstrap.servers=localhost:9092 \
  --filter='include:shop_db.users,shop_db.orders,shop_db.products,shop_db.order_items'
```

---

## 3. 🔧 字段级过滤规则


### 3.1 字段过滤的基本概念


**为什么需要字段过滤**：
- **隐私保护**：过滤敏感字段如密码、身份证号
- **减少传输**：只传输必要字段，提高效率  
- **数据安全**：避免敏感信息泄露

### 3.2 字段包含配置


**只同步特定字段**：
```bash
# 用户表只同步基本信息，排除敏感字段
--filter='include:shop_db.users.id,shop_db.users.username,shop_db.users.email'
```

**配置文件方式**：
```properties
# 字段级白名单
filter=include:shop_db.users.id,shop_db.users.username,shop_db.users.email,shop_db.users.created_at
```

### 3.3 字段排除配置


**排除敏感字段**：
```bash
# 排除密码、手机号等敏感信息
--filter='exclude:shop_db.users.password,shop_db.users.phone,shop_db.users.id_card'
```

### 3.4 实际应用示例


**用户表字段过滤**：
```sql
-- 原始用户表结构
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(255),    -- 敏感字段
    email VARCHAR(100),
    phone VARCHAR(20),        -- 敏感字段
    id_card VARCHAR(18),      -- 敏感字段
    avatar_url VARCHAR(255),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**过滤配置**：
```properties
# 排除敏感字段的配置
filter=exclude:shop_db.users.password,shop_db.users.phone,shop_db.users.id_card

# 同步后只包含这些字段：
# id, username, email, avatar_url, created_at, updated_at
```

**📊 过滤效果对比**：

| 字段 | **原始数据** | **过滤后** | **说明** |
|------|-------------|-----------|----------|
| `id` | `123456` | `123456` | ✅ 保留 |
| `username` | `john_doe` | `john_doe` | ✅ 保留 |
| `password` | `$2b$10$xyz...` | `null` | ❌ 过滤 |
| `email` | `john@email.com` | `john@email.com` | ✅ 保留 |
| `phone` | `13812345678` | `null` | ❌ 过滤 |

---

## 4. 🔄 数据转换函数


### 4.1 转换函数的作用


**数据转换**就是在同步过程中对数据进行加工处理，比如：
- **格式转换**：时间格式统一
- **数据脱敏**：敏感信息处理
- **字段重命名**：适配下游系统
- **值映射**：状态码转换

### 4.2 内置转换函数


**时间格式转换**：
```javascript
// Maxwell JavaScript转换函数
function transform(row) {
    // 转换创建时间格式
    if (row.data.created_at) {
        row.data.created_at_formatted = 
            new Date(row.data.created_at * 1000).toISOString();
    }
    return row;
}
```

**数据脱敏转换**：
```javascript
function transform(row) {
    // 手机号脱敏：保留前3位和后4位
    if (row.data.phone) {
        row.data.phone_masked = 
            row.data.phone.substring(0, 3) + "****" + 
            row.data.phone.substring(7);
        delete row.data.phone; // 删除原始手机号
    }
    
    // 邮箱脱敏
    if (row.data.email) {
        let parts = row.data.email.split('@');
        row.data.email_masked = 
            parts[0].substring(0, 2) + "***@" + parts[1];
        delete row.data.email;
    }
    
    return row;
}
```

### 4.3 配置转换函数


**在配置文件中指定**：
```properties
# 指定JavaScript转换文件
javascript=/path/to/transform.js

# 或者直接在配置中写简单转换
transform_function=function(row) { row.data.sync_time = Date.now(); return row; }
```

### 4.4 转换函数实际应用


**订单状态映射**：
```javascript
function transform(row) {
    // 将数字状态码转换为可读状态
    if (row.data.status !== undefined) {
        const statusMap = {
            0: 'pending',
            1: 'paid', 
            2: 'shipped',
            3: 'delivered',
            4: 'cancelled'
        };
        
        row.data.status_name = statusMap[row.data.status] || 'unknown';
    }
    
    return row;
}
```

**数据清洗转换**：
```javascript
function transform(row) {
    // 清理和标准化数据
    if (row.data.username) {
        // 用户名转小写并去除空格
        row.data.username = row.data.username.toLowerCase().trim();
    }
    
    // 添加数据来源标识
    row.data.source_system = 'mysql_shop_db';
    row.data.sync_timestamp = new Date().toISOString();
    
    return row;
}
```

---

## 5. 🔍 正则表达式过滤


### 5.1 正则过滤的应用场景


**批量匹配表名**：
```bash
# 匹配所有以log_开头的表
--filter='exclude:*.log_.*'

# 匹配所有临时表（temp_或tmp_开头）
--filter='exclude:*.(temp_.*|tmp_.*)'

# 匹配特定日期格式的表
--filter='exclude:*.access_log_[0-9]{8}'
```

### 5.2 常用正则表达式模式


**表名匹配模式**：
```bash
# 数据库级别匹配
--filter='include:shop_.*'              # 匹配shop_开头的所有数据库

# 表名模式匹配  
--filter='exclude:*.log_[0-9]{4}_[0-9]{2}_[0-9]{2}'  # 排除日期格式日志表
--filter='include:*.(users|orders|products)_.*'       # 只包含核心业务表

# 字段名模式匹配
--filter='exclude:*.*.password'         # 排除所有表的password字段
--filter='exclude:*.*._.*'              # 排除所有下划线开头的字段
```

### 5.3 正则过滤配置示例


**排除测试和临时数据**：
```properties
# 配置文件方式
filter=exclude:.*test.*,.*tmp.*,.*temp.*,.*_bak,.*_backup
```

**只同步业务核心表**：
```properties
# 使用正则匹配核心业务表
filter=include:shop_db\.(users|user_profiles|orders|order_items|products|categories)
```

### 5.4 复杂正则过滤案例


**多条件组合过滤**：
```bash
# 复杂的过滤规则组合
--filter='include:shop_db.*' \
--filter='exclude:shop_db.(log_.*|temp_.*|cache_.*|session_.*)'
```

**时间相关表过滤**：
```bash
# 只保留最近的日志表，排除历史分区表
--filter='exclude:shop_db.access_log_20[0-1][0-9](0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])'
```

> 💡 **提示**：正则表达式要谨慎使用，建议先在测试环境验证匹配结果，避免误过滤重要数据。

---

## 6. ⚖️ 黑白名单机制


### 6.1 黑白名单的基本概念


**白名单机制**：只允许名单内的数据通过
```
白名单逻辑：
数据 → 检查是否在白名单 → 在：通过 / 不在：拒绝
```

**黑名单机制**：拒绝名单内的数据，其他都通过
```
黑名单逻辑：  
数据 → 检查是否在黑名单 → 在：拒绝 / 不在：通过
```

### 6.2 选择策略建议


**何时使用白名单**：
- ✅ **安全要求高**：只允许明确需要的数据
- ✅ **数据量大**：大部分数据不需要同步
- ✅ **核心业务表少**：明确知道需要哪些表

**何时使用黑名单**：
- ✅ **大部分数据有用**：只需要排除少量数据
- ✅ **动态表结构**：新增表默认需要同步
- ✅ **开发测试阶段**：先同步再逐步优化

### 6.3 配置示例对比


**白名单配置**：
```properties
# 严格控制，只同步核心表
filter=include:shop_db.users,shop_db.orders,shop_db.products

# 结果：只有这3张表会同步，其他表全部忽略
```

**黑名单配置**：
```properties
# 宽松控制，排除无用表
filter=exclude:shop_db.logs,shop_db.temp_data,shop_db.cache_info

# 结果：除了这3张表，其他所有表都会同步
```

### 6.4 混合使用策略


**数据库级白名单 + 表级黑名单**：
```bash
# 先选择数据库，再排除不需要的表
--filter='include:shop_db.*' \
--filter='exclude:shop_db.(logs|temp_.*|cache_.*)'
```

**表级白名单 + 字段级黑名单**：
```properties
# 选择核心表，但排除敏感字段
filter=include:shop_db.users
filter=exclude:shop_db.users.password,shop_db.users.phone
```

### 6.5 实际应用建议


**📋 推荐配置流程**：

```
第1步：确定核心业务数据
├─ 用户相关：users, user_profiles, user_addresses
├─ 订单相关：orders, order_items, payments  
├─ 商品相关：products, categories, inventory
└─ 其他业务表...

第2步：识别无用数据
├─ 日志表：access_logs, error_logs, audit_logs
├─ 缓存表：cache_*, session_*, temp_*
├─ 备份表：*_backup, *_bak, *_old
└─ 测试表：test_*, tmp_*, dev_*

第3步：选择过滤策略
├─ 如果核心表 < 总表数的50% → 使用白名单
└─ 如果无用表 < 总表数的30% → 使用黑名单
```

---

## 7. 🎛️ 条件过滤配置


### 7.1 什么是条件过滤


**条件过滤**：根据数据内容的具体值来决定是否同步，比如：
- 只同步特定状态的订单
- 只同步活跃用户的数据
- 排除软删除的记录

### 7.2 WHERE条件过滤


**基本语法**：
```bash
# 只同步状态为active的用户
--filter='include:shop_db.users where status = "active"'

# 只同步最近30天的订单
--filter='include:shop_db.orders where created_at > DATE_SUB(NOW(), INTERVAL 30 DAY)'
```

### 7.3 JavaScript条件过滤


**复杂条件判断**：
```javascript
function filter(row) {
    // 只同步已支付的订单
    if (row.table === 'orders') {
        return row.data.payment_status === 'paid';
    }
    
    // 只同步非软删除的用户
    if (row.table === 'users') {
        return row.data.deleted_at === null;
    }
    
    // 其他表都同步
    return true;
}
```

### 7.4 实际应用场景


**订单数据条件过滤**：
```javascript
function filter(row) {
    if (row.table === 'orders') {
        // 只同步这些状态的订单
        const validStatuses = ['paid', 'shipped', 'delivered'];
        return validStatuses.includes(row.data.status);
    }
    return true;
}
```

**用户数据增量过滤**：
```javascript
function filter(row) {
    if (row.table === 'users') {
        // 只同步最近更新的用户（过去24小时）
        const updateTime = new Date(row.data.updated_at);
        const now = new Date();
        const hoursDiff = (now - updateTime) / (1000 * 60 * 60);
        
        return hoursDiff <= 24;
    }
    return true;
}
```

### 7.5 配置条件过滤


**配置文件方式**：
```properties
# 指定过滤脚本
filter_javascript=/path/to/filter.js

# 或使用WHERE子句（需要Maxwell支持）
filter=include:shop_db.orders where status in ('paid','shipped','delivered')
```

> ⚠️ **注意**：条件过滤会增加处理延迟，因为需要解析每条记录的内容。建议在表级过滤无法满足需求时才使用。

---

## 8. 🛠️ 自定义过滤器


### 8.1 自定义过滤器的应用场景


**何时需要自定义过滤器**：
- **复杂业务逻辑**：内置过滤无法满足复杂需求
- **动态过滤规则**：根据配置或时间动态调整过滤逻辑
- **多维度过滤**：同时考虑表、字段、内容、时间等多个维度

### 8.2 JavaScript自定义过滤器


**基本结构**：
```javascript
// 自定义过滤器模板
function shouldInclude(row) {
    // row对象包含：database, table, type, data, old等信息
    
    // 实现自定义过滤逻辑
    // 返回true：同步这条数据
    // 返回false：忽略这条数据
}
```

**完整示例**：
```javascript
function shouldInclude(row) {
    // 1. 数据库级过滤
    if (row.database !== 'shop_db') {
        return false;
    }
    
    // 2. 表级过滤 - 排除系统表
    const systemTables = ['logs', 'sessions', 'cache_data'];
    if (systemTables.includes(row.table)) {
        return false;
    }
    
    // 3. 操作类型过滤 - 只同步增删改，不同步查询
    if (!['insert', 'update', 'delete'].includes(row.type)) {
        return false;
    }
    
    // 4. 内容过滤 - 用户表特殊处理
    if (row.table === 'users') {
        // 只同步活跃用户
        if (row.data.status !== 'active') {
            return false;
        }
        
        // 排除测试用户
        if (row.data.username && row.data.username.startsWith('test_')) {
            return false;
        }
    }
    
    // 5. 时间过滤 - 只同步最近的数据
    if (row.data.created_at) {
        const createTime = new Date(row.data.created_at);
        const daysDiff = (Date.now() - createTime.getTime()) / (1000 * 60 * 60 * 24);
        
        // 超过90天的历史数据不同步
        if (daysDiff > 90) {
            return false;
        }
    }
    
    return true; // 通过所有过滤条件
}
```

### 8.3 高级自定义过滤器


**动态配置过滤器**：
```javascript
// 从外部配置文件读取过滤规则
const filterConfig = {
    excludeTables: ['logs', 'temp_data', 'cache_info'],
    includeStatuses: ['active', 'pending', 'processing'],
    maxDataAge: 30, // 天数
    excludeTestData: true
};

function shouldInclude(row) {
    // 表名过滤
    if (filterConfig.excludeTables.includes(row.table)) {
        return false;
    }
    
    // 状态过滤
    if (row.data.status && !filterConfig.includeStatuses.includes(row.data.status)) {
        return false;
    }
    
    // 数据时效性过滤
    if (row.data.created_at) {
        const ageInDays = (Date.now() - new Date(row.data.created_at).getTime()) / (1000 * 60 * 60 * 24);
        if (ageInDays > filterConfig.maxDataAge) {
            return false;
        }
    }
    
    // 测试数据过滤
    if (filterConfig.excludeTestData) {
        if (row.data.username && row.data.username.includes('test')) {
            return false;
        }
    }
    
    return true;
}
```

### 8.4 自定义转换和过滤结合


**数据转换 + 过滤**：
```javascript
function processRow(row) {
    // 先进行数据转换
    if (row.table === 'users') {
        // 密码字段脱敏
        if (row.data.password) {
            delete row.data.password;
        }
        
        // 手机号脱敏
        if (row.data.phone) {
            row.data.phone_masked = maskPhone(row.data.phone);
            delete row.data.phone;
        }
        
        // 添加处理时间戳
        row.data.processed_at = new Date().toISOString();
    }
    
    // 再进行过滤判断
    return shouldInclude(row);
}

function maskPhone(phone) {
    if (phone && phone.length === 11) {
        return phone.substring(0, 3) + '****' + phone.substring(7);
    }
    return phone;
}
```

### 8.5 自定义过滤器部署


**配置方式**：
```properties
# Maxwell配置文件
javascript=/opt/maxwell/filters/custom_filter.js

# 或者在启动参数中指定
# --javascript=/opt/maxwell/filters/custom_filter.js
```

**监控和调试**：
```javascript
function shouldInclude(row) {
    const start = Date.now();
    
    // 执行过滤逻辑
    const result = performFiltering(row);
    
    // 记录性能指标
    const duration = Date.now() - start;
    if (duration > 10) { // 超过10ms记录日志
        console.log(`Slow filter processing: ${duration}ms for ${row.table}`);
    }
    
    return result;
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 过滤机制：通过配置规则精确控制数据同步范围
🔸 表级过滤：包含/排除特定表，支持通配符和正则
🔸 字段级过滤：控制字段级别的同步，保护敏感信息
🔸 条件过滤：根据数据内容值进行过滤判断
🔸 黑白名单：根据业务需求选择包含或排除策略
🔸 自定义过滤：JavaScript实现复杂过滤和转换逻辑
```

### 9.2 关键理解要点


**🔹 过滤策略选择**
```
数据量评估：
├─ 核心业务表 < 50% → 白名单策略
├─ 无用数据 < 30% → 黑名单策略
└─ 复杂业务逻辑 → 自定义过滤器

性能考虑：
├─ 表级过滤：性能最好，优先使用
├─ 字段级过滤：适中，保护敏感信息
├─ 条件过滤：性能影响较大，谨慎使用
└─ 自定义过滤：灵活但需要优化代码
```

**🔹 配置优先级**
```
过滤规则执行顺序：
1. 数据库级过滤
2. 表级过滤  
3. 字段级过滤
4. 条件过滤
5. 自定义过滤器
```

### 9.3 实际应用指导


**📊 推荐配置模板**：

```properties
# 基础配置 - 适合大多数场景
filter=include:shop_db.*
filter=exclude:shop_db.(logs|temp_.*|cache_.*|session_.*)

# 敏感字段过滤
filter=exclude:*.*.password,*.*.phone,*.*.id_card

# 自定义过滤器（可选）
javascript=/opt/maxwell/custom_filter.js
```

**⚠️ 常见误区避免**：
- **过度过滤**：不要为了性能而过滤掉可能需要的数据
- **忽略测试**：过滤配置要在测试环境充分验证
- **性能盲区**：复杂过滤器要注意性能影响
- **安全遗漏**：敏感字段过滤要全面考虑

### 9.4 最佳实践建议


```
设计原则：
🎯 先粗后细：先做表级过滤，再考虑字段和条件过滤
🔒 安全优先：敏感信息一定要过滤或脱敏
⚡ 性能平衡：在功能和性能之间找到平衡点
📊 监控必备：记录过滤效果和性能指标

运维策略：
📋 定期审查：过滤规则要定期检查和调整
🧪 测试验证：新规则要在测试环境验证
📈 监控告警：关注同步延迟和错误率变化
🔄 版本管理：过滤配置要进行版本控制
```

**核心记忆**：
- Maxwell过滤是数据同步的精确控制手段
- 表级过滤性能最好，条件过滤最灵活
- 黑白名单选择要基于实际数据分布
- 自定义过滤器可以实现复杂业务逻辑
- 安全和性能要平衡考虑