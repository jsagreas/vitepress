---
title: 6、查询缓存与性能优化
---
## 📚 目录

1. [查询缓存基础概念](#1-查询缓存基础概念)
2. [ProxySQL查询缓存机制](#2-ProxySQL查询缓存机制)
3. [缓存失效策略详解](#3-缓存失效策略详解)
4. [性能监控与指标分析](#4-性能监控与指标分析)
5. [连接池与内存优化](#5-连接池与内存优化)
6. [多级缓存架构设计](#6-多级缓存架构设计)
7. [性能基准测试方法](#7-性能基准测试方法)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 查询缓存基础概念


### 1.1 什么是查询缓存


**🔸 基本定义**
查询缓存就像是数据库的"记忆功能"，把之前执行过的查询结果临时存储起来。当下次有相同的查询时，直接返回缓存的结果，不用再去数据库里重新查找。

```
简单类比：
就像你问朋友"今天天气怎么样？"
朋友第一次需要看天气预报，但记住了答案
你再问同样问题时，朋友直接告诉你，不用再查
```

**🔸 工作原理**
```
用户查询 → 检查缓存 → 缓存命中？
    ↓             ↓           ↓
直接返回      ← 是的，有缓存   没有缓存
    ↑                         ↓
返回结果  ← 存入缓存 ← 查询数据库
```

### 1.2 为什么需要查询缓存


**🎯 核心价值**

**⚡ 提升响应速度**
- 从内存读取比从磁盘读取快100-1000倍
- 复杂查询结果可以瞬间返回
- 减少用户等待时间

**💾 减少数据库压力**
- 相同查询不需要重复执行
- 降低CPU和磁盘IO负载
- 提高数据库并发处理能力

**💰 节省资源成本**
- 减少服务器资源消耗
- 提高硬件利用效率
- 降低运维成本

### 1.3 缓存的基本类型


| 缓存层级 | **位置** | **速度** | **容量** | **适用场景** |
|---------|---------|---------|---------|-------------|
| 🔸 **应用层缓存** | `应用程序内存` | `极快` | `有限` | `热点数据，会话信息` |
| 🔸 **代理层缓存** | `ProxySQL内存` | `很快` | `中等` | `查询结果，路由信息` |
| 🔸 **数据库缓存** | `MySQL内存` | `快` | `较大` | `数据页，索引缓存` |

---

## 2. 🔧 ProxySQL查询缓存机制


### 2.1 ProxySQL缓存架构


**🏗️ 缓存组件结构**
```
                ProxySQL缓存系统
    ┌─────────────────────────────────────────┐
    │            Query Cache                  │
    │  ┌─────────────┐  ┌─────────────────┐   │
    │  │ 查询解析器   │  │   结果存储区     │   │
    │  └─────────────┘  └─────────────────┘   │
    │  ┌─────────────┐  ┌─────────────────┐   │
    │  │ 缓存管理器   │  │   失效控制器     │   │
    │  └─────────────┘  └─────────────────┘   │
    └─────────────────────────────────────────┘
```

**🔸 核心工作流程**
```
1. SQL请求到达 → 计算查询哈希值
2. 检查缓存表 → 是否存在相同哈希
3. 缓存命中   → 验证TTL是否过期
4. 返回结果   → 更新访问统计
5. 缓存未命中 → 转发到后端数据库
6. 存储结果   → 按策略存入缓存
```

### 2.2 Query Cache配置详解


**🔧 基础配置参数**
```sql
-- 启用查询缓存
SET mysql-query_cache_size_MB=256;

-- 设置缓存TTL（生存时间）
SET mysql-query_cache_ttl=60000;  -- 60秒

-- 配置最大缓存条目数
SET mysql-query_cache_size_MB=512;
```

**💡 参数含义解释**

**`query_cache_size_MB`**: 缓存占用的内存大小
- 设置太小：缓存命中率低，效果不明显
- 设置太大：占用过多内存，影响其他功能
- 建议值：总内存的10-20%

**`query_cache_ttl`**: 缓存结果的有效期（毫秒）
- 设置太短：缓存频繁失效，命中率低
- 设置太长：数据可能不够新鲜
- 建议值：根据数据更新频率调整

### 2.3 缓存命中策略


**🎯 缓存Key生成规则**
```sql
-- ProxySQL使用以下信息生成缓存key：
-- 1. 完整SQL语句（包括空格、大小写）
-- 2. 用户名
-- 3. 数据库名
-- 4. 字符集

-- 例如：这两个查询会产生不同的缓存key
SELECT * FROM users WHERE id=1;
select * from users where id=1;  -- 注意：大小写不同
```

**⚠️ 缓存命中注意事项**
```
完全匹配原则：
✅ SELECT * FROM users WHERE id=1;
❌ SELECT * FROM users WHERE id = 1;  -- 空格不同
❌ Select * From users Where id=1;    -- 大小写不同
❌ SELECT * FROM users WHERE id=2;    -- 参数不同
```

> **💡 实用技巧**  
> 为了提高缓存命中率，建议在应用层统一SQL格式，包括大小写、空格、参数化查询等。

---

## 3. ⏰ 缓存失效策略详解


### 3.1 基于时间的失效策略


**🕐 TTL（Time To Live）机制**

TTL就像食物的保质期，缓存结果也有"新鲜度"。超过设定时间后，缓存自动失效，确保数据不会太旧。

```sql
-- 设置不同业务的TTL
-- 用户信息：相对稳定，可以缓存较久
SET mysql-query_cache_ttl=300000;  -- 5分钟

-- 商品价格：变化频繁，缓存时间要短
SET mysql-query_cache_ttl=30000;   -- 30秒

-- 统计数据：实时性要求高
SET mysql-query_cache_ttl=10000;   -- 10秒
```

**📊 TTL设置建议**

| 数据类型 | **更新频率** | **TTL建议** | **应用场景** |
|---------|------------|------------|-------------|
| 🔸 **配置数据** | `很少变化` | `1-6小时` | `系统配置，字典表` |
| 🔸 **用户资料** | `偶尔变化` | `10-30分钟` | `用户信息，权限数据` |
| 🔸 **业务数据** | `经常变化` | `1-5分钟` | `商品信息，订单状态` |
| 🔸 **实时数据** | `持续变化` | `10-60秒` | `库存数量，在线人数` |

### 3.2 基于事件的失效策略


**🔄 主动失效机制**

当数据发生变化时，主动清除相关缓存，确保用户不会看到过期数据。

```sql
-- 监控数据变化的表
-- 当users表有更新时，清除相关查询缓存
INSERT INTO mysql_query_rules_fast_routing 
(username, schema_name, destination_hostgroup, apply) 
VALUES 
('cache_monitor', 'mydb', 0, 1);
```

**💡 失效触发场景**
```
用户信息更新 → 清除用户相关查询缓存
商品价格调整 → 清除商品展示页面缓存  
库存数量变化 → 清除商品详情页缓存
系统配置修改 → 清除配置相关缓存
```

### 3.3 缓存穿透防护策略


**🛡️ 什么是缓存穿透**

缓存穿透就像有人故意问一些根本不存在答案的问题，让你每次都要去翻书，但永远找不到，白白浪费时间。

```
正常情况：
查询用户ID=123 → 缓存中有 → 直接返回

缓存穿透：
查询用户ID=-1 → 缓存中没有 → 查数据库 → 也没有 → 下次还要查
```

**🔧 防护策略实现**

**策略1：空结果缓存**
```sql
-- 对于查询结果为空的情况，也进行短时间缓存
-- 避免相同的无效查询重复执行

-- 为空结果设置较短的TTL
SET mysql-query_cache_ttl_empty=5000;  -- 5秒
```

**策略2：布隆过滤器**
```
布隆过滤器：预先记录所有存在的ID
查询前先检查：ID存在吗？
不存在 → 直接返回空，不查数据库
存在   → 正常查询流程
```

**策略3：参数校验**
```sql
-- 在代理层添加参数合法性检查
-- 拒绝明显无效的查询参数

-- 检查ID范围
WHERE id > 0 AND id < 999999999

-- 检查必要参数
WHERE username IS NOT NULL AND username != ''
```

---

## 4. 📊 性能监控与指标分析


### 4.1 关键性能指标


**🔍 核心监控指标**

**缓存命中率**：衡量缓存效果的最重要指标
```sql
-- 查看缓存统计信息
SELECT * FROM stats_mysql_query_cache;

-- 计算命中率
-- 命中率 = 缓存命中次数 / 总查询次数 * 100%
```

**📈 指标解读**

| 指标名称 | **含义说明** | **理想值** | **优化建议** |
|---------|------------|-----------|-------------|
| 🔸 **Hit Ratio** | `缓存命中率` | `> 80%` | `调整TTL，优化SQL格式` |
| 🔸 **Memory Usage** | `内存使用率` | `60-80%` | `调整缓存大小配置` |
| 🔸 **Eviction Rate** | `缓存淘汰率` | `< 10%` | `增加内存或优化策略` |
| 🔸 **Query Time** | `平均查询时间` | `< 100ms` | `优化慢查询，增加索引` |

### 4.2 stats统计信息表分析


**📋 ProxySQL统计表详解**

```sql
-- 查看查询缓存统计
SELECT 
    count_hit,           -- 缓存命中次数
    count_miss,          -- 缓存未命中次数  
    bytes_in,            -- 缓存占用字节数
    bytes_out,           -- 返回数据字节数
    purged               -- 被清理的缓存条目数
FROM stats_mysql_query_cache;
```

**💡 统计信息实用分析**

```sql
-- 计算缓存效率
SELECT 
    ROUND(count_hit / (count_hit + count_miss) * 100, 2) AS hit_rate_percent,
    ROUND(bytes_in / (1024*1024), 2) AS cache_size_mb,
    count_hit + count_miss AS total_queries
FROM stats_mysql_query_cache;
```

**🚨 异常指标告警**
```
命中率 < 50%  → 检查TTL设置和SQL规范性
内存使用 > 90% → 考虑增加缓存空间
淘汰率 > 20%  → 缓存空间不足或热点分布不均
```

### 4.3 慢查询统计与分析


**⏱️ 慢查询监控设置**

```sql
-- 设置慢查询阈值（毫秒）
SET mysql-query_digests_slow_log_time=1000;  -- 1秒

-- 查看慢查询统计
SELECT 
    digest_text,         -- SQL语句摘要
    count_star,          -- 执行次数
    sum_time,            -- 总执行时间
    avg_time,            -- 平均执行时间
    max_time             -- 最大执行时间
FROM stats_mysql_query_digest 
WHERE sum_time > 1000000  -- 筛选总时间超过1秒的查询
ORDER BY sum_time DESC;
```

**🔧 慢查询优化策略**

```sql
-- 识别需要缓存的慢查询
-- 1. 执行频繁且耗时的SELECT语句
-- 2. 复杂的统计查询
-- 3. 多表关联查询

-- 为慢查询添加缓存规则
INSERT INTO mysql_query_rules 
(match_pattern, cache_ttl, apply) 
VALUES 
('SELECT.*FROM.*users.*JOIN.*orders.*', 60000, 1);
```

---

## 5. 🔄 连接池与内存优化


### 5.1 连接池调优策略


**🏊 连接池基本概念**

连接池就像停车场，预先准备好一定数量的数据库连接（停车位），应用需要时直接使用，用完后放回池中，避免频繁创建和销毁连接的开销。

```
传统方式：
应用请求 → 创建连接 → 执行查询 → 关闭连接 (每次都要重复)

连接池方式：
应用请求 → 从池中获取连接 → 执行查询 → 归还连接 (复用连接)
```

**🔧 关键参数配置**

```sql
-- 连接池大小设置
SET mysql-max_connections=1000;        -- 最大连接数
SET mysql-default_max_latency_ms=1000;  -- 连接超时时间

-- 后端连接池配置
INSERT INTO mysql_servers 
(hostgroup_id, hostname, port, max_connections) 
VALUES 
(0, '192.168.1.10', 3306, 100),  -- 主库连接池
(1, '192.168.1.11', 3306, 50);   -- 从库连接池
```

### 5.2 连接复用效率监控


**📊 监控连接使用情况**

```sql
-- 查看连接池状态
SELECT 
    hostgroup,           -- 主机组
    srv_host,           -- 服务器地址
    ConnUsed,           -- 正在使用的连接数
    ConnFree,           -- 空闲连接数
    ConnOK,             -- 可用连接数
    ConnERR             -- 错误连接数
FROM stats_mysql_connection_pool;
```

**💡 连接效率分析**

| 指标 | **理想状态** | **问题诊断** | **优化建议** |
|------|------------|------------|-------------|
| 🔸 **ConnUsed/ConnFree比例** | `3:7 到 7:3` | `比例失衡` | `调整连接池大小` |
| 🔸 **ConnERR数量** | `接近0` | `连接错误多` | `检查网络和数据库状态` |
| 🔸 **连接创建频率** | `低频率` | `频繁创建` | `增加连接池大小` |

**🚨 连接异常告警**
```sql
-- 监控连接异常
SELECT 
    hostgroup,
    srv_host,
    ConnERR,
    CASE 
        WHEN ConnERR > 10 THEN 'High Error Rate'
        WHEN ConnUsed/(ConnUsed+ConnFree) > 0.9 THEN 'Pool Nearly Full'
        ELSE 'Normal'
    END AS status
FROM stats_mysql_connection_pool;
```

### 5.3 内存使用优化


**💾 内存分配策略**

```sql
-- ProxySQL内存配置
SET admin-admin_credentials='admin:admin123';
SET admin-mysql_ifaces='0.0.0.0:6032';

-- 内存使用分配
-- 查询缓存：40%
SET mysql-query_cache_size_MB=512;

-- 连接池：30%  
SET mysql-max_connections=1000;

-- 其他功能：30%（日志、统计等）
```

**🔍 内存使用监控**

```sql
-- 查看内存使用情况
SELECT 
    Variable_name,
    Variable_value
FROM global_variables 
WHERE Variable_name LIKE '%memory%' 
   OR Variable_name LIKE '%cache%';
```

**⚡ 内存优化技巧**

```sql
-- 1. 定期清理过期缓存
PROXYSQL FLUSH QUERY CACHE;

-- 2. 优化缓存key设计，减少内存碎片
-- 统一SQL格式，提高缓存复用率

-- 3. 监控内存泄漏
-- 定期检查内存使用增长趋势
```

---

## 6. 🏗️ 多级缓存架构设计


### 6.1 缓存层次架构


**🎯 多级缓存设计理念**

多级缓存就像多层防护，越靠近用户的缓存速度越快但容量越小，越靠近数据库的缓存容量越大但速度稍慢。

```
用户请求处理流程：

应用层缓存 (L1) ────┐ 
    ↓ miss          │ hit
代理层缓存 (L2) ────┼──→ 返回结果
    ↓ miss          │
数据库缓存 (L3) ────┘
    ↓ miss
磁盘数据库
```

**🔧 架构组件设计**

```
┌─────────────────────────────────────────┐
│              应用层 (L1)                 │
│  ┌─────────────┐  ┌─────────────────┐   │
│  │ Redis缓存   │  │   本地内存缓存   │   │
│  │ 热点数据    │  │   会话数据      │   │
│  └─────────────┘  └─────────────────┘   │
└─────────────────────────────────────────┘
              ↓ 缓存未命中
┌─────────────────────────────────────────┐
│             ProxySQL层 (L2)              │  
│  ┌─────────────┐  ┌─────────────────┐   │
│  │ 查询缓存    │  │   路由缓存      │   │
│  │ SQL结果     │  │   元数据信息    │   │
│  └─────────────┘  └─────────────────┘   │
└─────────────────────────────────────────┘
              ↓ 缓存未命中
┌─────────────────────────────────────────┐
│              MySQL层 (L3)                │
│  ┌─────────────┐  ┌─────────────────┐   │
│  │ InnoDB缓存  │  │   查询缓存      │   │
│  │ 数据页      │  │   结果缓存      │   │
│  └─────────────┘  └─────────────────┘   │
└─────────────────────────────────────────┘
```

### 6.2 缓存一致性保障


**🔄 数据一致性挑战**

多级缓存带来性能提升的同时，也带来了数据一致性的挑战。就像多个人都有同一份文档的复印件，当原文档更新时，需要确保所有复印件也及时更新。

**🛡️ 一致性保障策略**

**策略1：TTL分层设计**
```sql
-- L1缓存：最短TTL，保证数据新鲜度
Redis TTL: 30秒

-- L2缓存：中等TTL，平衡性能和一致性  
ProxySQL TTL: 2分钟

-- L3缓存：较长TTL，减少数据库压力
MySQL Query Cache TTL: 5分钟
```

**策略2：事件驱动失效**
```sql
-- 数据更新时，逐层清理缓存
-- 1. 应用层更新数据
UPDATE users SET name='新名称' WHERE id=123;

-- 2. 清理L1缓存
DEL user:123

-- 3. 清理L2缓存  
PROXYSQL FLUSH QUERY CACHE WHERE digest='用户查询的digest';

-- 4. L3缓存自然过期或手动清理
```

### 6.3 缓存预热策略


**🔥 预热机制设计**

缓存预热就像提前烧好热水，在用户需要之前就把热点数据加载到缓存中。

```sql
-- 系统启动时预热关键数据
-- 1. 热门商品信息
SELECT * FROM products WHERE is_hot=1;

-- 2. 用户权限信息  
SELECT * FROM user_permissions WHERE user_type IN ('admin','vip');

-- 3. 系统配置信息
SELECT * FROM system_configs WHERE status='active';
```

**📊 预热效果监控**
```sql
-- 监控预热后的缓存命中率
SELECT 
    digest_text,
    count_star AS query_count,
    sum_time/count_star AS avg_time_ms
FROM stats_mysql_query_digest
WHERE first_seen > '预热开始时间'
ORDER BY count_star DESC;
```

---

## 7. 🧪 性能基准测试方法


### 7.1 测试环境准备


**🛠️ 基准测试工具**

**mysqlslap**: MySQL官方压测工具
```bash
# 基础压测命令
mysqlslap \
  --host=proxy_host \
  --port=6033 \
  --user=test_user \
  --password=test_pass \
  --concurrency=50 \     # 并发连接数
  --iterations=10 \      # 测试轮次
  --number-of-queries=1000 \  # 总查询数
  --auto-generate-sql         # 自动生成SQL
```

**sysbench**: 综合性能测试工具
```bash
# 准备测试数据
sysbench oltp_read_write \
  --mysql-host=proxy_host \
  --mysql-port=6033 \
  --mysql-user=test_user \
  --mysql-password=test_pass \
  --mysql-db=testdb \
  --tables=10 \
  --table-size=100000 \
  prepare

# 执行读写混合测试
sysbench oltp_read_write \
  --mysql-host=proxy_host \
  --mysql-port=6033 \
  --threads=100 \
  --time=300 \
  --report-interval=10 \
  run
```

### 7.2 ProxySQL性能测试指标


**📊 关键测试指标**

| 测试项目 | **测试方法** | **关注指标** | **期望值** |
|---------|------------|-------------|-----------|
| 🔸 **查询响应时间** | `简单SELECT测试` | `平均响应时间` | `< 10ms` |
| 🔸 **并发处理能力** | `多线程压测` | `QPS(每秒查询数)` | `> 10000` |
| 🔸 **缓存命中率** | `重复查询测试` | `Hit Ratio` | `> 80%` |
| 🔸 **连接池效率** | `连接创建/销毁测试` | `连接复用率` | `> 90%` |

**🔧 自定义测试脚本**
```sql
-- 测试查询缓存效果
DELIMITER $$
CREATE PROCEDURE test_cache_performance()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE start_time TIMESTAMP;
    DECLARE end_time TIMESTAMP;
    
    -- 第一轮：冷缓存测试
    SET start_time = NOW(6);
    WHILE i <= 1000 DO
        SELECT * FROM users WHERE id = (i % 100) + 1;
        SET i = i + 1;
    END WHILE;
    SET end_time = NOW(6);
    
    SELECT 'Cold Cache' as test_type, 
           TIMESTAMPDIFF(MICROSECOND, start_time, end_time) as time_microseconds;
    
    -- 第二轮：热缓存测试  
    SET i = 1;
    SET start_time = NOW(6);
    WHILE i <= 1000 DO
        SELECT * FROM users WHERE id = (i % 100) + 1;
        SET i = i + 1;
    END WHILE;
    SET end_time = NOW(6);
    
    SELECT 'Hot Cache' as test_type,
           TIMESTAMPDIFF(MICROSECOND, start_time, end_time) as time_microseconds;
END$$
DELIMITER ;
```

### 7.3 性能优化基准对比


**📈 优化前后对比测试**

```bash
# 测试脚本：对比缓存开启前后的性能
#!/bin/bash

echo "=== 关闭缓存测试 ==="
mysql -h proxy_host -P 6033 -u admin -p -e "
SET mysql-query_cache_size_MB=0;
LOAD MYSQL VARIABLES TO RUNTIME;
"

# 执行压测
sysbench oltp_read_only \
  --mysql-host=proxy_host \
  --mysql-port=6033 \
  --threads=50 \
  --time=60 \
  run > no_cache_result.txt

echo "=== 开启缓存测试 ==="  
mysql -h proxy_host -P 6033 -u admin -p -e "
SET mysql-query_cache_size_MB=256;
SET mysql-query_cache_ttl=60000;
LOAD MYSQL VARIABLES TO RUNTIME;
"

# 再次执行压测
sysbench oltp_read_only \
  --mysql-host=proxy_host \
  --mysql-port=6033 \
  --threads=50 \
  --time=60 \
  run > cache_enabled_result.txt

echo "=== 性能对比分析 ==="
echo "无缓存QPS: $(grep 'queries:' no_cache_result.txt)"
echo "有缓存QPS: $(grep 'queries:' cache_enabled_result.txt)"
```

**💡 基准测试最佳实践**
```
测试环境要求：
✅ 使用生产环境相似的硬件配置
✅ 模拟真实的数据量和查询模式  
✅ 在相同的网络环境下测试
✅ 多次测试取平均值，排除偶然因素

测试数据准备：
✅ 准备足够的测试数据（至少10万行）
✅ 模拟真实的数据分布和热点
✅ 包含各种类型的查询（简单/复杂）
✅ 考虑读写比例符合业务实际情况
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 查询缓存：临时存储查询结果，提升响应速度
🔸 缓存命中率：衡量缓存效果的关键指标，目标>80%  
🔸 TTL机制：控制缓存数据的新鲜度，需要根据业务调整
🔸 缓存失效：及时清理过期数据，保证数据一致性
🔸 多级缓存：分层设计，平衡性能和一致性
🔸 性能监控：持续跟踪指标，及时发现和解决问题
```

### 8.2 关键配置要点


**🔹 缓存配置优化**
```sql
-- 基础配置模板
SET mysql-query_cache_size_MB=256;      -- 根据内存情况调整
SET mysql-query_cache_ttl=60000;        -- 根据数据更新频率调整  
SET mysql-max_connections=1000;         -- 根据并发需求调整
```

**🔹 监控告警阈值**
```
缓存命中率 < 50%     → 需要优化缓存策略
内存使用率 > 90%     → 需要扩容或清理
连接错误率 > 5%      → 需要检查网络和配置
平均响应时间 > 100ms → 需要性能调优
```

### 8.3 实际应用指导


**📊 不同业务场景的缓存策略**

| 业务类型 | **缓存策略** | **TTL设置** | **注意事项** |
|---------|------------|------------|-------------|
| 🔸 **电商商品** | `积极缓存` | `5-30分钟` | `价格变化及时更新` |
| 🔸 **用户信息** | `适度缓存` | `10-60分钟` | `权限变更及时生效` |
| 🔸 **统计报表** | `长期缓存` | `1-24小时` | `定时刷新保证准确性` |
| 🔸 **实时数据** | `短期缓存` | `10-60秒` | `平衡实时性和性能` |

**🛠️ 运维最佳实践**
```
日常维护：
✅ 定期检查缓存命中率和性能指标
✅ 监控内存使用情况，及时调整配置
✅ 定期清理无效缓存，防止内存泄漏
✅ 备份重要配置，建立变更记录

问题排查：
✅ 缓存命中率低 → 检查SQL规范性和TTL设置
✅ 响应时间长 → 分析慢查询和连接池状态  
✅ 内存使用高 → 检查缓存大小和清理策略
✅ 连接异常 → 检查网络状态和数据库健康度
```

**核心记忆要点**：
- 缓存是性能优化的利器，但要平衡速度和一致性
- 监控指标是优化的基础，数据驱动决策
- 不同业务需要不同策略，没有万能的配置
- 持续监控和调优是缓存发挥效果的关键