---
title: 4、连接池与流量管理
---
## 📚 目录

1. [连接池基本概念](#1-连接池基本概念)
2. [连接复用机制详解](#2-连接复用机制详解)
3. [流量控制策略](#3-流量控制策略)
4. [后端服务器管理](#4-后端服务器管理)
5. [用户管理与权限控制](#5-用户管理与权限控制)
6. [连接池监控与调优](#6-连接池监控与调优)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏊 连接池基本概念


### 1.1 什么是连接池

**连接池**：就像一个"数据库连接的蓄水池"，提前创建好一些数据库连接并保存起来，需要时直接取用，用完后放回池子里继续给别人用。

```
传统方式：每次都要建立新连接
客户端 → 建立连接 → 执行SQL → 关闭连接 → 数据库

连接池方式：复用已有连接
客户端 → 从池中取连接 → 执行SQL → 归还连接 → 连接池
```

### 1.2 为什么需要连接池


**🔸 解决的核心问题**
- **频繁连接开销**：建立TCP连接、MySQL握手认证都很耗时
- **连接数限制**：MySQL默认最大连接数有限（通常151个）
- **资源浪费**：短连接会造成大量TIME_WAIT状态
- **性能瓶颈**：高并发时连接建立成为性能瓶颈

```
性能对比示例：
直接连接：建立连接(50ms) + 执行SQL(10ms) + 关闭连接(20ms) = 80ms
连接池：  取连接(1ms) + 执行SQL(10ms) + 归还连接(1ms) = 12ms
性能提升：约6.7倍！
```

### 1.3 连接池架构图


```
客户端应用                    数据库代理中间件                    MySQL后端
┌─────────┐                 ┌─────────────────────┐              ┌─────────┐
│ App1    │                 │     连接池管理       │              │ MySQL1  │
│ App2    │ ───────────────→│ ┌─────────────────┐ │ ─────────────→│ Master  │
│ App3    │   客户端连接     │ │ 前端连接池      │ │   后端连接     │         │
│ ...     │                 │ │ [C1][C2][C3]   │ │              ├─────────┤
└─────────┘                 │ └─────────────────┘ │              │ MySQL2  │
                            │ ┌─────────────────┐ │              │ Slave1  │
                            │ │ 后端连接池      │ │              │         │
                            │ │ [D1][D2][D3]   │ │              ├─────────┤
                            │ └─────────────────┘ │              │ MySQL3  │
                            └─────────────────────┘              │ Slave2  │
                                                                └─────────┘
```

---

## 2. 🔄 连接复用机制详解


### 2.1 连接多路复用原理


**Connection Multiplexing**：一个前端连接可以复用多个后端连接，实现"1对多"的连接映射。

```
连接复用示例：
前端连接1 ──┐
前端连接2 ──┼─→ 复用逻辑 ──┬─→ 后端连接A (到MySQL1)
前端连接3 ──┘              ├─→ 后端连接B (到MySQL2)  
                          └─→ 后端连接C (到MySQL3)

好处：
• 减少后端连接数量
• 提高连接利用率
• 降低数据库压力
```

### 2.2 连接复用配置


**ProxySQL配置示例**
```sql
-- 设置连接复用参数
UPDATE global_variables SET variable_value='true' 
WHERE variable_name='mysql-multiplexing';

-- 设置后端连接池大小
UPDATE global_variables SET variable_value='200' 
WHERE variable_name='mysql-max_connections';

-- 应用配置
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

**🔸 关键参数说明**
- `mysql-multiplexing`：启用连接复用（true/false）
- `mysql-max_connections`：每个后端服务器的最大连接数
- `mysql-default_max_connections`：默认连接数限制

### 2.3 连接复用策略


```
会话级复用：
┌─────────────────────────────────────┐
│ 用户会话1 → 绑定后端连接A → MySQL1   │
│ 用户会话2 → 绑定后端连接B → MySQL2   │  
│ 用户会话3 → 绑定后端连接C → MySQL1   │
└─────────────────────────────────────┘

语句级复用：
┌─────────────────────────────────────┐
│ SQL语句1 → 临时使用连接A → 归还池中   │
│ SQL语句2 → 临时使用连接B → 归还池中   │
│ SQL语句3 → 临时使用连接A → 归还池中   │
└─────────────────────────────────────┘
```

---

## 3. 🚦 流量控制策略


### 3.1 限流算法实现


**🔸 令牌桶算法**
```
原理：以固定速率往桶里放令牌，处理请求时消耗令牌
配置：mysql-default_query_timeout=3600000（毫秒）

令牌桶示意：
┌─────────────────┐
│ 令牌桶 (容量100) │  ←── 每秒放入50个令牌
│ ████████░░░░░░░ │
└─────────────────┘
       ↓
   每个请求消耗1个令牌
```

**🔸 连接数限流**
```sql
-- 配置每用户最大连接数
INSERT INTO mysql_users (username, password, max_connections) 
VALUES ('app_user', 'password123', 50);

-- 配置全局最大连接数
UPDATE global_variables SET variable_value='1000' 
WHERE variable_name='mysql-max_connections';
```

### 3.2 流量控制参数


| 参数名 | **默认值** | **说明** | **作用** |
|-------|----------|---------|---------|
| `mysql-max_connections` | `2048` | `全局最大连接数` | `控制总体并发` |
| `mysql-default_max_connections` | `1000` | `默认后端连接数` | `单机连接限制` |
| `mysql-connection_max_age_ms` | `0` | `连接最大存活时间` | `连接老化管理` |
| `mysql-ping_timeout_server` | `500` | `后端ping超时` | `健康检查超时` |

### 3.3 超时控制机制


```
超时控制层次：
┌──────────────────────────────────────┐
│ 客户端超时                            │
│ ├─ 连接超时：mysql-connect_timeout_*  │
│ ├─ 查询超时：mysql-query_timeout_*    │
│ └─ 空闲超时：mysql-wait_timeout       │
└──────────────────────────────────────┘
            ↓
┌──────────────────────────────────────┐
│ 后端超时                              │
│ ├─ 连接超时：mysql-connect_timeout_server │
│ ├─ 查询超时：mysql-query_timeout_server   │
│ └─ ping超时：mysql-ping_timeout_server    │
└──────────────────────────────────────┘
```

---

## 4. 🎛️ 后端服务器管理


### 4.1 mysql_servers配置详解


**后端服务器**：就是实际存储数据的MySQL实例，代理中间件需要知道这些服务器的地址和状态。

```sql
-- 添加后端MySQL服务器
INSERT INTO mysql_servers (hostgroup_id, hostname, port, weight, status) VALUES
(0, '192.168.1.100', 3306, 1000, 'ONLINE'),   -- 主库
(1, '192.168.1.101', 3306, 900, 'ONLINE'),    -- 从库1  
(1, '192.168.1.102', 3306, 900, 'ONLINE');    -- 从库2

-- 应用配置
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
```

**🔸 关键字段说明**
- `hostgroup_id`：服务器组ID（0=写组，1=读组）
- `hostname`：MySQL服务器IP地址
- `port`：MySQL端口号（默认3306）
- `weight`：权重值，决定负载分配比例
- `status`：服务器状态（ONLINE/OFFLINE/SHUNNED）

### 4.2 服务器状态管理


```
服务器状态转换图：
┌─────────┐  上线   ┌─────────┐  检测失败  ┌─────────┐
│ OFFLINE │ ─────→ │ ONLINE  │ ────────→ │ SHUNNED │
└─────────┘        └─────────┘           └─────────┘
     ↑                  ↑                      │
     │                  │        恢复正常        │
     │                  └──────────────────────┘
     │
     └────────── 手动下线 ──────────
```

**状态说明**：
- **ONLINE**：正常服务状态，可以接收请求
- **OFFLINE**：手动下线状态，不接收任何请求  
- **SHUNNED**：自动隔离状态，健康检查失败后自动设置

### 4.3 连接健康检查


```sql
-- 配置健康检查参数
UPDATE global_variables SET variable_value='5000' 
WHERE variable_name='mysql-ping_interval_server_msec';

UPDATE global_variables SET variable_value='3' 
WHERE variable_name='mysql-ping_max_failures';
```

**健康检查流程**：
```
每5秒执行一次检查：
┌─────────────────────────────────────┐
│ 1. 向后端发送 SELECT 1              │
│ 2. 等待响应（超时500ms）             │
│ 3. 成功 → 重置失败计数器             │
│ 4. 失败 → 失败计数器+1               │
│ 5. 连续失败3次 → 标记为SHUNNED       │
└─────────────────────────────────────┘
```

---

## 5. 👥 用户管理与权限控制


### 5.1 mysql_users配置


**用户管理**：控制哪些用户可以通过代理连接数据库，以及他们的权限和连接限制。

```sql
-- 添加代理用户
INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES
('app_read', 'read_password', 1, 1, 100),    -- 只读用户，连接读组
('app_write', 'write_password', 1, 0, 50),   -- 读写用户，连接写组
('app_admin', 'admin_password', 1, 0, 200);  -- 管理用户，高连接数

-- 应用配置
LOAD MYSQL USERS TO RUNTIME;
SAVE MYSQL USERS TO DISK;
```

### 5.2 用户属性详解


| 字段名 | **类型** | **说明** | **示例** |
|-------|---------|---------|---------|
| `username` | `varchar` | `用户名` | `'app_user'` |
| `password` | `varchar` | `密码` | `'password123'` |
| `active` | `int` | `是否激活` | `1=启用, 0=禁用` |
| `default_hostgroup` | `int` | `默认服务器组` | `0=写组, 1=读组` |
| `max_connections` | `int` | `最大连接数` | `100` |
| `default_schema` | `varchar` | `默认数据库` | `'myapp'` |

### 5.3 连接数控制


```
用户连接数控制示意：
用户A (max_connections=50)
├─ 当前连接：45个  ✅ 还可以创建5个连接
├─ 新连接请求 → 检查限制 → 允许创建
└─ 超出限制 → 拒绝连接 → 返回错误

用户B (max_connections=10) 
├─ 当前连接：10个  ❌ 已达到上限
├─ 新连接请求 → 检查限制 → 拒绝连接  
└─ 错误信息："Too many connections for user 'userB'"
```

---

## 6. 📊 连接池监控与调优


### 6.1 stats_mysql_connection_pool监控


**连接池状态监控**：通过统计表查看连接池的实时状态和性能指标。

```sql
-- 查看连接池状态
SELECT * FROM stats_mysql_connection_pool;

-- 重点关注的指标
SELECT 
    hostgroup,
    srv_host,
    srv_port,
    status,
    ConnUsed,           -- 正在使用的连接数
    ConnFree,           -- 空闲连接数
    ConnOK,             -- 正常连接数
    ConnERR,            -- 错误连接数
    MaxConnUsed,        -- 历史最大使用连接数
    Queries             -- 处理的查询数
FROM stats_mysql_connection_pool
ORDER BY hostgroup, srv_host;
```

### 6.2 关键监控指标


```
连接池健康度评估：
┌─────────────────────────────────────┐
│ 🟢 健康状态                         │
│ ├─ ConnUsed < 80% * max_connections │
│ ├─ ConnFree > 10                   │
│ ├─ ConnERR = 0                     │
│ └─ 响应时间 < 100ms                │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ 🟡 预警状态                         │
│ ├─ ConnUsed > 80% * max_connections │
│ ├─ ConnFree < 5                    │
│ ├─ ConnERR > 0                     │
│ └─ 响应时间 > 100ms                │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ 🔴 危险状态                         │
│ ├─ ConnUsed ≥ max_connections      │
│ ├─ ConnFree = 0                    │
│ ├─ ConnERR > 10                    │
│ └─ 响应时间 > 500ms                │
└─────────────────────────────────────┘
```

### 6.3 性能调优策略


**🔸 连接池大小调优**
```sql
-- 根据业务压力调整连接池大小
-- 计算公式：max_connections = 并发用户数 × 1.2 + 10

-- 高并发场景
UPDATE global_variables SET variable_value='500' 
WHERE variable_name='mysql-default_max_connections';

-- 低并发场景  
UPDATE global_variables SET variable_value='50'
WHERE variable_name='mysql-default_max_connections';
```

**🔸 连接回收策略**
```sql
-- 设置连接最大空闲时间（毫秒）
UPDATE global_variables SET variable_value='28800000' 
WHERE variable_name='mysql-wait_timeout';

-- 设置连接最大存活时间
UPDATE global_variables SET variable_value='3600000'
WHERE variable_name='mysql-connection_max_age_ms';
```

### 6.4 故障排查指南


```
常见问题排查流程：

1️⃣ 连接数耗尽
   检查：stats_mysql_connection_pool 中 ConnUsed
   解决：增加 max_connections 或优化应用连接使用

2️⃣ 连接创建失败  
   检查：ConnERR 计数和 MySQL 错误日志
   解决：检查网络、用户权限、MySQL配置

3️⃣ 响应时间慢
   检查：stats_mysql_commands 中的查询耗时
   解决：优化SQL、增加连接数、检查后端性能

4️⃣ 连接泄露
   检查：ConnUsed 持续增长不释放
   解决：检查应用是否正确关闭连接
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 连接池本质：预先创建连接的"蓄水池"，实现连接复用
🔸 复用机制：一个前端连接可以复用多个后端连接
🔸 流量控制：通过连接数限制和超时控制管理访问流量
🔸 服务器管理：配置后端MySQL实例和健康检查
🔸 用户管理：控制用户权限和连接数限制
🔸 监控调优：通过统计数据优化连接池性能
```

### 7.2 关键配置参数


**🔹 连接池核心参数**
```sql
mysql-max_connections=2048              -- 全局最大连接数
mysql-default_max_connections=1000      -- 后端默认连接数  
mysql-multiplexing=true                 -- 启用连接复用
mysql-connection_max_age_ms=3600000     -- 连接最大存活时间
mysql-wait_timeout=28800000             -- 连接空闲超时
```

**🔹 监控关键指标**
```
ConnUsed：当前使用连接数（核心指标）
ConnFree：空闲连接数（资源指标）
ConnERR：错误连接数（故障指标）
MaxConnUsed：历史峰值（容量规划）
Queries：查询处理数（吞吐量指标）
```

### 7.3 最佳实践建议


**🎯 连接池设计原则**
- **预估容量**：根据业务并发量 × 1.2 + 缓冲设置连接数
- **分层限制**：全局限制 > 用户限制 > 单机限制
- **健康检查**：启用自动健康检查，及时发现故障节点
- **监控告警**：设置连接数使用率和错误率告警

**🛠️ 调优策略**
- **连接数不足**：增加max_connections，检查连接泄露
- **响应时间慢**：优化SQL，增加后端连接，检查网络延迟
- **连接错误多**：检查MySQL配置，网络稳定性，用户权限
- **资源利用率低**：减少连接数，调整超时时间，优化复用策略

**核心记忆**：
- 连接池是数据库代理的核心功能，解决连接开销和并发限制
- 通过连接复用提高效率，通过流量控制保护后端
- 配置要平衡性能和稳定性，监控要及时发现问题
- 调优要基于实际业务场景，不能一刀切