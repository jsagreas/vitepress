---
title: 5ã€è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–
---
## ğŸ“š ç›®å½•

1. [è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–æ¦‚è¿°](#1-è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–æ¦‚è¿°)
2. [è¿æ¥æ± å¤§å°è°ƒä¼˜](#2-è¿æ¥æ± å¤§å°è°ƒä¼˜)
3. [è¿æ¥è·å–æ€§èƒ½ä¼˜åŒ–](#3-è¿æ¥è·å–æ€§èƒ½ä¼˜åŒ–)
4. [è¿æ¥éªŒè¯å¼€é”€ä¼˜åŒ–](#4-è¿æ¥éªŒè¯å¼€é”€ä¼˜åŒ–)
5. [è¿æ¥æ± é¢„çƒ­ç­–ç•¥](#5-è¿æ¥æ± é¢„çƒ­ç­–ç•¥)
6. [æ‰¹é‡æ“ä½œè¿æ¥å¤ç”¨](#6-æ‰¹é‡æ“ä½œè¿æ¥å¤ç”¨)
7. [å†…å­˜ä¸CPUç¼“å­˜ä¼˜åŒ–](#7-å†…å­˜ä¸CPUç¼“å­˜ä¼˜åŒ–)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ¯ è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–æ¦‚è¿°


### 1.1 ä»€ä¹ˆæ˜¯è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–


**ğŸ”¸ æ ¸å¿ƒå®šä¹‰**
```
è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–ï¼šé€šè¿‡è°ƒæ•´è¿æ¥æ± çš„å„é¡¹å‚æ•°å’Œç­–ç•¥ï¼Œ
æœ€å¤§åŒ–æ•°æ®åº“è¿æ¥çš„ä½¿ç”¨æ•ˆç‡ï¼Œå‡å°‘èµ„æºæµªè´¹ï¼Œ
æå‡åº”ç”¨ç¨‹åºçš„æ•´ä½“æ€§èƒ½å’Œå“åº”é€Ÿåº¦ã€‚

ç®€å•ç†è§£ï¼šå°±åƒä¼˜åŒ–åœè½¦åœºçš„ä½¿ç”¨æ•ˆç‡
- åˆç†è§„åˆ’è½¦ä½æ•°é‡ï¼ˆè¿æ¥æ± å¤§å°ï¼‰
- ä¼˜åŒ–å–è½¦è¿˜è½¦æµç¨‹ï¼ˆè¿æ¥è·å–é‡Šæ”¾ï¼‰
- å‡å°‘æ— æ•ˆå·¡æ£€ï¼ˆè¿æ¥éªŒè¯ä¼˜åŒ–ï¼‰
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦è¿æ¥æ± ä¼˜åŒ–


**ğŸš« æœªä¼˜åŒ–è¿æ¥æ± çš„é—®é¢˜**
```
æ€§èƒ½é—®é¢˜ï¼š
â€¢ è¿æ¥è·å–ç¼“æ…¢ï¼Œå“åº”æ—¶é—´é•¿
â€¢ æ•°æ®åº“è¿æ¥æ•°ä¸å¤Ÿç”¨ï¼Œå‡ºç°ç­‰å¾…
â€¢ æ— æ•ˆè¿æ¥å ç”¨èµ„æºï¼Œæµªè´¹å†…å­˜

èµ„æºé—®é¢˜ï¼š
â€¢ è¿æ¥æ± è¿‡å¤§ï¼Œå ç”¨è¿‡å¤šå†…å­˜
â€¢ è¿æ¥æ± è¿‡å°ï¼Œé¢‘ç¹åˆ›å»ºé”€æ¯è¿æ¥
â€¢ è¿æ¥éªŒè¯è¿‡äºé¢‘ç¹ï¼Œå¢åŠ ç½‘ç»œå¼€é”€
```

**âœ… ä¼˜åŒ–åçš„æ”¶ç›Š**
```
æ€§èƒ½æå‡ï¼š
â€¢ è¿æ¥è·å–æ—¶é—´ä»å‡ åmsé™ä½åˆ°1-2ms
â€¢ åº”ç”¨å“åº”æ—¶é—´æå‡20-50%
â€¢ æ•°æ®åº“å‹åŠ›é™ä½ï¼Œç¨³å®šæ€§æå‡

èµ„æºèŠ‚çº¦ï¼š
â€¢ å†…å­˜ä½¿ç”¨ä¼˜åŒ–30-40%
â€¢ ç½‘ç»œè¿æ¥æ•°å‡å°‘
â€¢ CPUä½¿ç”¨ç‡ä¼˜åŒ–
```

### 1.3 è¿æ¥æ± ä¼˜åŒ–çš„æ ¸å¿ƒæ€è·¯


**ğŸ’¡ ä¼˜åŒ–ç­–ç•¥æ¡†æ¶**
```
å››ä¸ªç»´åº¦ä¼˜åŒ–ï¼š

ğŸ”¹ æ•°é‡ä¼˜åŒ–ï¼šåˆç†è®¾ç½®è¿æ¥æ± å¤§å°
ğŸ”¹ æ—¶é—´ä¼˜åŒ–ï¼šå‡å°‘è¿æ¥è·å–å’ŒéªŒè¯æ—¶é—´
ğŸ”¹ ç©ºé—´ä¼˜åŒ–ï¼šä¼˜åŒ–å†…å­˜ä½¿ç”¨å’Œç¼“å­˜ç­–ç•¥
ğŸ”¹ ç­–ç•¥ä¼˜åŒ–ï¼šæ”¹è¿›è¿æ¥åˆ†é…å’Œå›æ”¶ç®—æ³•
```

---

## 2. âš–ï¸ è¿æ¥æ± å¤§å°è°ƒä¼˜


### 2.1 è¿æ¥æ± å¤§å°çš„æ ¸å¿ƒæ¦‚å¿µ


**ğŸ“Š å…³é”®å‚æ•°è§£é‡Š**
```
æœ€å°è¿æ¥æ•°ï¼ˆminIdleï¼‰ï¼š
å«ä¹‰ï¼šè¿æ¥æ± ä¿æŒçš„æœ€å°‘è¿æ¥æ•°
ä½œç”¨ï¼šä¿è¯åŸºç¡€æ€§èƒ½ï¼Œé¿å…å†·å¯åŠ¨
ç±»æ¯”ï¼šåœè½¦åœºæœ€å°‘ä¿ç•™çš„ç©ºé—²è½¦ä½

æœ€å¤§è¿æ¥æ•°ï¼ˆmaxTotalï¼‰ï¼š
å«ä¹‰ï¼šè¿æ¥æ± å…è®¸çš„æœ€å¤§è¿æ¥æ•°
ä½œç”¨ï¼šé™åˆ¶èµ„æºä½¿ç”¨ï¼Œé˜²æ­¢æ•°æ®åº“è¿‡è½½
ç±»æ¯”ï¼šåœè½¦åœºçš„æ€»è½¦ä½æ•°

åˆå§‹è¿æ¥æ•°ï¼ˆinitialSizeï¼‰ï¼š
å«ä¹‰ï¼šè¿æ¥æ± å¯åŠ¨æ—¶åˆ›å»ºçš„è¿æ¥æ•°
ä½œç”¨ï¼šé¢„çƒ­è¿æ¥æ± ï¼Œæä¾›åˆå§‹æ€§èƒ½
ç±»æ¯”ï¼šåœè½¦åœºå¼€ä¸šæ—¶é¢„å…ˆå‡†å¤‡çš„è½¦ä½
```

### 2.2 è¿æ¥æ± å¤§å°è®¡ç®—å…¬å¼


**ğŸ§® ç§‘å­¦è®¡ç®—æ–¹æ³•**

**åŸºç¡€è®¡ç®—å…¬å¼**ï¼š
```
æœ€ä¼˜è¿æ¥æ•° = CPUæ ¸å¿ƒæ•° Ã— 2 + ç£ç›˜æ•°é‡

åŸç†è§£é‡Šï¼š
â€¢ CPUæ ¸å¿ƒæ•° Ã— 2ï¼šä¿è¯CPUå……åˆ†åˆ©ç”¨
â€¢ + ç£ç›˜æ•°é‡ï¼šè¡¥å¿IOç­‰å¾…æ—¶é—´
â€¢ è¿™æ˜¯ä¸€ä¸ªç»éªŒå…¬å¼ï¼Œéœ€è¦æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
```

**è¯¦ç»†è®¡ç®—å…¬å¼**ï¼š
```java
// æ›´ç²¾ç¡®çš„è®¡ç®—æ–¹æ³•
public class ConnectionPoolSizer {
    
    /**
     * è®¡ç®—æœ€ä¼˜è¿æ¥æ± å¤§å°
     * @param cpuCores CPUæ ¸å¿ƒæ•°
     * @param avgResponseTime å¹³å‡å“åº”æ—¶é—´(ms)
     * @param avgRequestTime å¹³å‡è¯·æ±‚å¤„ç†æ—¶é—´(ms)
     * @param concurrentUsers å¹¶å‘ç”¨æˆ·æ•°
     * @return æ¨èçš„è¿æ¥æ± å¤§å°
     */
    public static int calculateOptimalSize(
        int cpuCores, 
        double avgResponseTime, 
        double avgRequestTime,
        int concurrentUsers) {
        
        // åŸºç¡€å…¬å¼ï¼šCPUæ ¸å¿ƒæ•° Ã— åˆ©ç”¨ç‡ç³»æ•°
        int baseSize = cpuCores * 2;
        
        // IOç­‰å¾…ç³»æ•°è°ƒæ•´
        double ioWaitFactor = avgResponseTime / avgRequestTime;
        int ioAdjustedSize = (int)(baseSize * ioWaitFactor);
        
        // å¹¶å‘ç”¨æˆ·è°ƒæ•´
        int concurrencySize = concurrentUsers / 10; // ç»éªŒå€¼
        
        // å–æœ€å¤§å€¼ä½œä¸ºæ¨èå¤§å°
        return Math.max(ioAdjustedSize, concurrencySize);
    }
}
```

### 2.3 ä¸åŒåœºæ™¯çš„è¿æ¥æ± é…ç½®


**ğŸ¯ é…ç½®ç­–ç•¥å¯¹æ¯”**

| åº”ç”¨åœºæ™¯ | **æœ€å°è¿æ¥** | **æœ€å¤§è¿æ¥** | **é…ç½®åŸåˆ™** |
|---------|-------------|-------------|-------------|
| ğŸ¢ **é«˜å¹¶å‘Webåº”ç”¨** | `20-50` | `100-200` | `é¢„ç•™å……è¶³è¿æ¥ï¼Œå¿«é€Ÿå“åº”` |
| ğŸ“Š **æ•°æ®åˆ†æç³»ç»Ÿ** | `5-10` | `30-50` | `è¿æ¥æŒç»­æ—¶é—´é•¿ï¼Œæ•°é‡é€‚ä¸­` |
| ğŸ”„ **æ‰¹å¤„ç†ä»»åŠ¡** | `2-5` | `10-20` | `å°‘é‡é•¿è¿æ¥ï¼ŒèŠ‚çº¦èµ„æº` |
| ğŸ“± **ç§»åŠ¨ç«¯API** | `10-20` | `50-100` | `ä¸­ç­‰è§„æ¨¡ï¼Œçµæ´»è°ƒæ•´` |

**å®é™…é…ç½®ç¤ºä¾‹**ï¼š
```java
// HikariCP è¿æ¥æ± é…ç½®ç¤ºä¾‹
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        
        // åŸºç¡€è¿æ¥ä¿¡æ¯
        config.setJdbcUrl("jdbc:mysql://localhost:3306/testdb");
        config.setUsername("user");
        config.setPassword("password");
        
        // è¿æ¥æ± å¤§å°é…ç½®
        config.setMinimumIdle(10);        // æœ€å°ç©ºé—²è¿æ¥
        config.setMaximumPoolSize(50);    // æœ€å¤§è¿æ¥æ•°
        config.setConnectionTimeout(30000); // è¿æ¥è¶…æ—¶30ç§’
        config.setIdleTimeout(600000);    // ç©ºé—²è¶…æ—¶10åˆ†é’Ÿ
        config.setMaxLifetime(1800000);   // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ30åˆ†é’Ÿ
        
        return new HikariDataSource(config);
    }
}
```

### 2.4 åŠ¨æ€è°ƒæ•´è¿æ¥æ± å¤§å°


**âš¡ è‡ªé€‚åº”è°ƒæ•´ç­–ç•¥**
```java
// è¿æ¥æ± åŠ¨æ€è°ƒæ•´å™¨
public class DynamicPoolSizer {
    private HikariDataSource dataSource;
    private int[] recentUsage = new int[10]; // è®°å½•æœ€è¿‘10æ¬¡ä½¿ç”¨æƒ…å†µ
    private int index = 0;
    
    /**
     * æ ¹æ®ä½¿ç”¨æƒ…å†µåŠ¨æ€è°ƒæ•´è¿æ¥æ± 
     */
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void adjustPoolSize() {
        // è®°å½•å½“å‰æ´»è·ƒè¿æ¥æ•°
        int activeConnections = dataSource.getHikariPoolMXBean().getActiveConnections();
        recentUsage[index++ % 10] = activeConnections;
        
        // è®¡ç®—å¹³å‡ä½¿ç”¨ç‡
        double avgUsage = Arrays.stream(recentUsage).average().orElse(0);
        int currentMaxSize = dataSource.getMaximumPoolSize();
        
        // ä½¿ç”¨ç‡è¶…è¿‡80%ï¼Œå¢åŠ è¿æ¥æ± 
        if (avgUsage > currentMaxSize * 0.8) {
            int newSize = Math.min(currentMaxSize + 5, 100); // æœ€å¤§ä¸è¶…è¿‡100
            dataSource.setMaximumPoolSize(newSize);
            log.info("è¿æ¥æ± æ‰©å®¹è‡³: {}", newSize);
        }
        // ä½¿ç”¨ç‡ä½äº30%ï¼Œå‡å°‘è¿æ¥æ± 
        else if (avgUsage < currentMaxSize * 0.3) {
            int newSize = Math.max(currentMaxSize - 5, 10); // æœ€å°ä¸å°‘äº10
            dataSource.setMaximumPoolSize(newSize);
            log.info("è¿æ¥æ± ç¼©å®¹è‡³: {}", newSize);
        }
    }
}
```

---

## 3. ğŸš€ è¿æ¥è·å–æ€§èƒ½ä¼˜åŒ–


### 3.1 è¿æ¥è·å–ç­‰å¾…æ—¶é—´ä¼˜åŒ–


**â° ç­‰å¾…æ—¶é—´é—®é¢˜è§£æ**
```
é—®é¢˜ç°è±¡ï¼š
åº”ç”¨ç¨‹åºè°ƒç”¨ getConnection() æ—¶éœ€è¦ç­‰å¾…å¾ˆé•¿æ—¶é—´

åŸå› åˆ†æï¼š
ğŸ”¸ è¿æ¥æ± å·²æ»¡ï¼Œéœ€è¦ç­‰å¾…å…¶ä»–çº¿ç¨‹é‡Šæ”¾è¿æ¥
ğŸ”¸ è¿æ¥åˆ›å»ºé€Ÿåº¦æ…¢ï¼Œæ— æ³•åŠæ—¶è¡¥å……è¿æ¥
ğŸ”¸ è¿æ¥éªŒè¯è€—æ—¶é•¿ï¼Œå½±å“è·å–é€Ÿåº¦
```

**ğŸ”§ ä¼˜åŒ–ç­–ç•¥**
```java
// è¿æ¥è·å–ä¼˜åŒ–é…ç½®
public void optimizeConnectionAcquisition(HikariConfig config) {
    
    // 1. å‡å°‘è¿æ¥è¶…æ—¶æ—¶é—´
    config.setConnectionTimeout(5000); // 5ç§’è¶…æ—¶ï¼Œå¿«é€Ÿå¤±è´¥
    
    // 2. å¯ç”¨è¿æ¥é¢„åˆ†é…
    config.setMinimumIdle(config.getMaximumPoolSize() / 2); // é¢„åˆ†é…ä¸€åŠè¿æ¥
    
    // 3. ä¼˜åŒ–è¿æ¥åˆ›å»ºç­–ç•¥
    config.addDataSourceProperty("prepStmtCacheSize", "250");
    config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
    config.addDataSourceProperty("useServerPrepStmts", "true");
    
    // 4. å¯ç”¨å¿«é€Ÿå¤±è´¥æœºåˆ¶
    config.setLeakDetectionThreshold(60000); // 1åˆ†é’Ÿæ£€æµ‹è¿æ¥æ³„æ¼
}
```

### 3.2 è¿æ¥è·å–ç®—æ³•ä¼˜åŒ–


**ğŸ“Š ä¸åŒè·å–ç­–ç•¥å¯¹æ¯”**

```
FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰ç­–ç•¥ï¼š
ä¼˜ç‚¹ï¼šå…¬å¹³åˆ†é…ï¼Œé¿å…è¿æ¥é¥¥é¥¿
ç¼ºç‚¹ï¼šå¯èƒ½è·å–åˆ°"å†·"è¿æ¥ï¼Œæ€§èƒ½ç•¥å·®

LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰ç­–ç•¥ï¼š
ä¼˜ç‚¹ï¼šè·å–"çƒ­"è¿æ¥ï¼Œç¼“å­˜å‘½ä¸­ç‡é«˜
ç¼ºç‚¹ï¼šå¯èƒ½å¯¼è‡´æŸäº›è¿æ¥é•¿æœŸä¸ç”¨

è´Ÿè½½å‡è¡¡ç­–ç•¥ï¼š
ä¼˜ç‚¹ï¼šè¿æ¥ä½¿ç”¨å‡åŒ€ï¼Œé¿å…çƒ­ç‚¹
ç¼ºç‚¹ï¼šå®ç°å¤æ‚ï¼Œç•¥æœ‰æ€§èƒ½å¼€é”€
```

**ğŸ’¡ è‡ªå®šä¹‰è¿æ¥é€‰æ‹©å™¨**
```java
// æ™ºèƒ½è¿æ¥é€‰æ‹©å™¨
public class IntelligentConnectionSelector {
    
    private final Map<Connection, Long> connectionUsage = new ConcurrentHashMap<>();
    private final Map<Connection, AtomicInteger> connectionHitCount = new ConcurrentHashMap<>();
    
    /**
     * æ™ºèƒ½é€‰æ‹©æœ€ä¼˜è¿æ¥
     */
    public Connection selectOptimalConnection(List<Connection> availableConnections) {
        
        // ä¼˜å…ˆé€‰æ‹©æœ€è¿‘ä½¿ç”¨è¿‡çš„è¿æ¥ï¼ˆç¼“å­˜å‘½ä¸­ç‡é«˜ï¼‰
        Connection recentConnection = availableConnections.stream()
            .max((c1, c2) -> Long.compare(
                connectionUsage.getOrDefault(c1, 0L),
                connectionUsage.getOrDefault(c2, 0L)
            ))
            .orElse(null);
        
        // å¦‚æœæœ€è¿‘ä½¿ç”¨çš„è¿æ¥å‘½ä¸­æ¬¡æ•°è¿‡é«˜ï¼Œé€‰æ‹©ä½¿ç”¨è¾ƒå°‘çš„è¿æ¥
        if (recentConnection != null) {
            int hitCount = connectionHitCount.getOrDefault(recentConnection, new AtomicInteger(0)).get();
            if (hitCount > 100) { // ä½¿ç”¨æ¬¡æ•°è¿‡å¤šï¼Œé€‰æ‹©å…¶ä»–è¿æ¥
                return availableConnections.stream()
                    .min((c1, c2) -> Integer.compare(
                        connectionHitCount.getOrDefault(c1, new AtomicInteger(0)).get(),
                        connectionHitCount.getOrDefault(c2, new AtomicInteger(0)).get()
                    ))
                    .orElse(recentConnection);
            }
        }
        
        // æ›´æ–°ä½¿ç”¨è®°å½•
        if (recentConnection != null) {
            connectionUsage.put(recentConnection, System.currentTimeMillis());
            connectionHitCount.computeIfAbsent(recentConnection, k -> new AtomicInteger(0)).incrementAndGet();
        }
        
        return recentConnection;
    }
}
```

---

## 4. âœ… è¿æ¥éªŒè¯å¼€é”€ä¼˜åŒ–


### 4.1 è¿æ¥éªŒè¯æœºåˆ¶è¯¦è§£


**ğŸ” è¿æ¥éªŒè¯çš„å¿…è¦æ€§**
```
ä¸ºä»€ä¹ˆéœ€è¦è¿æ¥éªŒè¯ï¼š
â€¢ MySQLæœåŠ¡å™¨å¯èƒ½ä¸»åŠ¨æ–­å¼€ç©ºé—²è¿æ¥
â€¢ ç½‘ç»œæ•…éšœå¯èƒ½å¯¼è‡´è¿æ¥å¤±æ•ˆ
â€¢ é˜²ç«å¢™å¯èƒ½æ¸…ç†é•¿æ—¶é—´æ— æ´»åŠ¨çš„è¿æ¥

éªŒè¯æ—¶æœºï¼š
ğŸ”¸ è·å–è¿æ¥æ—¶éªŒè¯ï¼ˆæœ€å¸¸è§ï¼‰
ğŸ”¸ å½’è¿˜è¿æ¥æ—¶éªŒè¯
ğŸ”¸ å®šæœŸåå°éªŒè¯
ğŸ”¸ ç©ºé—²æ—¶é—´è¿‡é•¿æ—¶éªŒè¯
```

### 4.2 è¿æ¥éªŒè¯æŸ¥è¯¢ä¼˜åŒ–


**âš¡ éªŒè¯æŸ¥è¯¢æ€§èƒ½å¯¹æ¯”**

| éªŒè¯æ–¹å¼ | **æŸ¥è¯¢è¯­å¥** | **å“åº”æ—¶é—´** | **æ¨èç¨‹åº¦** |
|---------|-------------|-------------|-------------|
| ğŸš« **ä¼ ç»Ÿæ–¹å¼** | `SELECT 1 FROM DUAL` | `2-5ms` | `ä¸æ¨èï¼Œæœ‰ç½‘ç»œå¼€é”€` |
| âœ… **è½»é‡éªŒè¯** | `SELECT 1` | `1-2ms` | `æ¨èï¼Œè¯­æ³•ç®€å•` |
| âš¡ **JDBCåŸç”Ÿ** | `Connection.isValid()` | `<1ms` | `æœ€æ¨èï¼Œæ— SQLå¼€é”€` |

**ğŸ”§ ä¼˜åŒ–é…ç½®ç¤ºä¾‹**
```java
// è¿æ¥éªŒè¯ä¼˜åŒ–é…ç½®
public void optimizeConnectionValidation(HikariConfig config) {
    
    // 1. ä½¿ç”¨JDBC 4.0åŸç”ŸéªŒè¯ï¼ˆæ¨èï¼‰
    config.setConnectionTestQuery(null); // ä¸ä½¿ç”¨è‡ªå®šä¹‰æŸ¥è¯¢
    // HikariCPä¼šè‡ªåŠ¨ä½¿ç”¨ Connection.isValid() æ–¹æ³•
    
    // 2. å¦‚æœå¿…é¡»ä½¿ç”¨è‡ªå®šä¹‰æŸ¥è¯¢ï¼Œé€‰æ‹©æœ€è½»é‡çš„
    // config.setConnectionTestQuery("SELECT 1");
    
    // 3. ä¼˜åŒ–éªŒè¯è¶…æ—¶æ—¶é—´
    config.setValidationTimeout(3000); // 3ç§’éªŒè¯è¶…æ—¶
    
    // 4. æ™ºèƒ½éªŒè¯ç­–ç•¥
    config.addDataSourceProperty("testOnBorrow", "false");  // è·å–æ—¶ä¸éªŒè¯
    config.addDataSourceProperty("testOnReturn", "false");  // å½’è¿˜æ—¶ä¸éªŒè¯
    config.addDataSourceProperty("testWhileIdle", "true");  // ç©ºé—²æ—¶éªŒè¯
    config.addDataSourceProperty("timeBetweenEvictionRunsMillis", "60000"); // æ¯åˆ†é’ŸéªŒè¯ä¸€æ¬¡
}
```

### 4.3 æ‰¹é‡è¿æ¥éªŒè¯ç­–ç•¥


**ğŸ“¦ æ‰¹é‡éªŒè¯ä¼˜åŒ–**
```java
// æ‰¹é‡è¿æ¥éªŒè¯å™¨
public class BatchConnectionValidator {
    
    private final ExecutorService validationExecutor = 
        Executors.newFixedThreadPool(4); // ä¸“é—¨çš„éªŒè¯çº¿ç¨‹æ± 
    
    /**
     * æ‰¹é‡éªŒè¯å¤šä¸ªè¿æ¥
     */
    public CompletableFuture<Map<Connection, Boolean>> batchValidate(
            List<Connection> connections) {
        
        // å°†è¿æ¥åˆ†ç»„æ‰¹é‡éªŒè¯
        Map<Connection, CompletableFuture<Boolean>> validationTasks = connections.stream()
            .collect(Collectors.toMap(
                conn -> conn,
                this::validateConnectionAsync
            ));
        
        // ç­‰å¾…æ‰€æœ‰éªŒè¯å®Œæˆ
        CompletableFuture<Void> allValidations = CompletableFuture.allOf(
            validationTasks.values().toArray(new CompletableFuture[0])
        );
        
        return allValidations.thenApply(v -> 
            validationTasks.entrySet().stream()
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    entry -> entry.getValue().join()
                ))
        );
    }
    
    /**
     * å¼‚æ­¥éªŒè¯å•ä¸ªè¿æ¥
     */
    private CompletableFuture<Boolean> validateConnectionAsync(Connection conn) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return conn.isValid(2); // 2ç§’è¶…æ—¶
            } catch (SQLException e) {
                return false;
            }
        }, validationExecutor);
    }
}
```

---

## 5. ğŸ”¥ è¿æ¥æ± é¢„çƒ­ç­–ç•¥


### 5.1 è¿æ¥æ± é¢„çƒ­çš„é‡è¦æ€§


**â„ï¸ å†·å¯åŠ¨é—®é¢˜**
```
å†·å¯åŠ¨ç°è±¡ï¼š
åº”ç”¨åˆšå¯åŠ¨æ—¶ï¼Œè¿æ¥æ± ä¸ºç©ºï¼Œç¬¬ä¸€æ‰¹è¯·æ±‚éœ€è¦ç­‰å¾…è¿æ¥åˆ›å»º

å½±å“ï¼š
â€¢ é¦–æ¬¡è¯·æ±‚å“åº”æ—¶é—´é•¿ï¼ˆå¯èƒ½è¶…è¿‡10ç§’ï¼‰
â€¢ ç”¨æˆ·ä½“éªŒå·®ï¼Œç³»ç»Ÿæ˜¾å¾—"å¡é¡¿"
â€¢ å¯èƒ½è§¦å‘ä¸Šæ¸¸è¶…æ—¶ï¼Œå¼•å‘çº§è”é—®é¢˜

è§£å†³æ€è·¯ï¼š
é¢„å…ˆåˆ›å»ºä¸€å®šæ•°é‡çš„è¿æ¥ï¼Œè®©è¿æ¥æ± "çƒ­èº«"
```

### 5.2 é¢„çƒ­ç­–ç•¥å®ç°


**ğŸš€ æ™ºèƒ½é¢„çƒ­å®ç°**
```java
// è¿æ¥æ± é¢„çƒ­å™¨
@Component
public class ConnectionPoolWarmer {
    
    @Autowired
    private DataSource dataSource;
    
    /**
     * åº”ç”¨å¯åŠ¨æ—¶é¢„çƒ­è¿æ¥æ± 
     */
    @EventListener(ApplicationReadyEvent.class)
    public void warmupConnectionPool() {
        
        int warmupConnections = 10; // é¢„çƒ­è¿æ¥æ•°
        List<Connection> connections = new ArrayList<>();
        
        try {
            log.info("å¼€å§‹é¢„çƒ­è¿æ¥æ± ï¼Œç›®æ ‡è¿æ¥æ•°: {}", warmupConnections);
            long startTime = System.currentTimeMillis();
            
            // è·å–è¿æ¥è¿›è¡Œé¢„çƒ­
            for (int i = 0; i < warmupConnections; i++) {
                Connection conn = dataSource.getConnection();
                
                // æ‰§è¡Œç®€å•æŸ¥è¯¢ç¡®ä¿è¿æ¥å¯ç”¨
                try (PreparedStatement stmt = conn.prepareStatement("SELECT 1")) {
                    stmt.execute();
                }
                
                connections.add(conn);
                log.debug("é¢„çƒ­è¿æ¥ {}/{}", i + 1, warmupConnections);
            }
            
            // é‡Šæ”¾æ‰€æœ‰è¿æ¥å›æ± ä¸­
            for (Connection conn : connections) {
                conn.close(); // å®é™…æ˜¯è¿”å›è¿æ¥æ± 
            }
            
            long duration = System.currentTimeMillis() - startTime;
            log.info("è¿æ¥æ± é¢„çƒ­å®Œæˆï¼Œè€—æ—¶: {}ms", duration);
            
        } catch (SQLException e) {
            log.error("è¿æ¥æ± é¢„çƒ­å¤±è´¥", e);
        }
    }
    
    /**
     * æ¸è¿›å¼é¢„çƒ­ç­–ç•¥
     */
    @Async
    public void gradualWarmup() {
        
        // ç¬¬ä¸€é˜¶æ®µï¼šåˆ›å»ºæ ¸å¿ƒè¿æ¥
        createConnections(5, "æ ¸å¿ƒè¿æ¥");
        
        // ç­‰å¾…1ç§’
        sleep(1000);
        
        // ç¬¬äºŒé˜¶æ®µï¼šåˆ›å»ºé¢å¤–è¿æ¥
        createConnections(10, "æ‰©å±•è¿æ¥");
        
        // ç­‰å¾…2ç§’
        sleep(2000);
        
        // ç¬¬ä¸‰é˜¶æ®µï¼šè¾¾åˆ°ç›®æ ‡è¿æ¥æ•°
        createConnections(15, "å®Œæ•´è¿æ¥");
    }
    
    private void createConnections(int count, String phase) {
        try {
            List<Connection> connections = new ArrayList<>();
            for (int i = 0; i < count; i++) {
                connections.add(dataSource.getConnection());
            }
            // ç«‹å³é‡Šæ”¾å›æ± ä¸­
            for (Connection conn : connections) {
                conn.close();
            }
            log.info("{} é¢„çƒ­å®Œæˆ: {} ä¸ªè¿æ¥", phase, count);
        } catch (SQLException e) {
            log.error("{} é¢„çƒ­å¤±è´¥", phase, e);
        }
    }
    
    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## 6. ğŸ“¦ æ‰¹é‡æ“ä½œè¿æ¥å¤ç”¨


### 6.1 æ‰¹é‡æ“ä½œçš„è¿æ¥å¤ç”¨åŸç†


**ğŸ”„ è¿æ¥å¤ç”¨æ¦‚å¿µ**
```
ä¼ ç»Ÿåšæ³•ï¼š
æ¯ä¸ªSQLæ“ä½œ â†’ è·å–è¿æ¥ â†’ æ‰§è¡Œ â†’ é‡Šæ”¾è¿æ¥
é—®é¢˜ï¼šé¢‘ç¹è·å–é‡Šæ”¾è¿æ¥ï¼Œå¼€é”€å¤§

ä¼˜åŒ–åšæ³•ï¼š
ä¸€æ‰¹SQLæ“ä½œ â†’ è·å–ä¸€ä¸ªè¿æ¥ â†’ æ‰§è¡Œæ‰€æœ‰æ“ä½œ â†’ é‡Šæ”¾è¿æ¥
ä¼˜åŠ¿ï¼šå‡å°‘è¿æ¥è·å–æ¬¡æ•°ï¼Œæå‡æ€§èƒ½
```

### 6.2 æ‰¹é‡æ“ä½œå®ç°


**âš¡ äº‹åŠ¡å†…æ‰¹é‡æ“ä½œ**
```java
// æ‰¹é‡æ“ä½œæœåŠ¡
@Service
public class BatchOperationService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    /**
     * æ‰¹é‡æ’å…¥æ•°æ® - è¿æ¥å¤ç”¨
     */
    @Transactional
    public void batchInsertWithConnectionReuse(List<User> users) {
        
        String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
        
        // ä½¿ç”¨ JdbcTemplate çš„æ‰¹é‡æ“ä½œï¼Œè‡ªåŠ¨å¤ç”¨è¿æ¥
        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                User user = users.get(i);
                ps.setString(1, user.getName());
                ps.setString(2, user.getEmail());
                ps.setInt(3, user.getAge());
            }
            
            @Override
            public int getBatchSize() {
                return users.size();
            }
        });
    }
    
    /**
     * æ‰‹åŠ¨è¿æ¥ç®¡ç†çš„æ‰¹é‡æ“ä½œ
     */
    public void manualBatchOperation(List<String> sqls) {
        
        Connection conn = null;
        try {
            // è·å–ä¸€ä¸ªè¿æ¥
            conn = jdbcTemplate.getDataSource().getConnection();
            conn.setAutoCommit(false); // å…³é—­è‡ªåŠ¨æäº¤
            
            try (PreparedStatement stmt = conn.prepareStatement("")) {
                // æ‰¹é‡æ‰§è¡Œå¤šä¸ªSQL
                for (String sql : sqls) {
                    stmt.addBatch(sql);
                }
                
                // æ‰¹é‡æ‰§è¡Œ
                int[] results = stmt.executeBatch();
                conn.commit(); // æäº¤äº‹åŠ¡
                
                log.info("æ‰¹é‡æ“ä½œå®Œæˆï¼Œå½±å“è¡Œæ•°: {}", Arrays.stream(results).sum());
            }
            
        } catch (SQLException e) {
            // å›æ»šäº‹åŠ¡
            if (conn != null) {
                try {
                    conn.rollback();
                } catch (SQLException rollbackEx) {
                    log.error("å›æ»šå¤±è´¥", rollbackEx);
                }
            }
            throw new RuntimeException("æ‰¹é‡æ“ä½œå¤±è´¥", e);
        } finally {
            // é‡Šæ”¾è¿æ¥
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    log.error("é‡Šæ”¾è¿æ¥å¤±è´¥", e);
                }
            }
        }
    }
}
```

### 6.3 åˆ†é¡µæ‰¹é‡å¤„ç†ç­–ç•¥


**ğŸ“„ å¤§æ•°æ®é‡åˆ†é¡µå¤„ç†**
```java
// åˆ†é¡µæ‰¹é‡å¤„ç†å™¨
public class PagedBatchProcessor {
    
    private static final int BATCH_SIZE = 1000; // æ¯æ‰¹å¤„ç†1000æ¡
    
    /**
     * åˆ†é¡µæ‰¹é‡å¤„ç†å¤§é‡æ•°æ®
     */
    public void processLargeDataset(List<Object> largeDataset) {
        
        int totalSize = largeDataset.size();
        int processedCount = 0;
        
        // åˆ†é¡µå¤„ç†
        for (int offset = 0; offset < totalSize; offset += BATCH_SIZE) {
            
            int endIndex = Math.min(offset + BATCH_SIZE, totalSize);
            List<Object> batch = largeDataset.subList(offset, endIndex);
            
            // å¤„ç†å½“å‰æ‰¹æ¬¡
            processBatch(batch);
            
            processedCount += batch.size();
            log.info("æ‰¹å¤„ç†è¿›åº¦: {}/{} ({}%)", 
                processedCount, totalSize, 
                (processedCount * 100 / totalSize));
            
            // é€‚å½“ä¼‘æ¯ï¼Œé¿å…è¿‡åº¦å ç”¨èµ„æº
            if (offset + BATCH_SIZE < totalSize) {
                sleep(10); // ä¼‘æ¯10ms
            }
        }
    }
    
    @Transactional
    private void processBatch(List<Object> batch) {
        // åœ¨åŒä¸€ä¸ªäº‹åŠ¡ä¸­å¤„ç†æ•´ä¸ªæ‰¹æ¬¡
        // è‡ªåŠ¨å¤ç”¨è¿æ¥
        for (Object item : batch) {
            // å¤„ç†å•ä¸ªé¡¹ç›®
            processItem(item);
        }
    }
}
```

---

## 7. ğŸ’¾ å†…å­˜ä¸CPUç¼“å­˜ä¼˜åŒ–


### 7.1 è¿æ¥æ± å†…å­˜ä½¿ç”¨ä¼˜åŒ–


**ğŸ§  å†…å­˜ä¼˜åŒ–ç­–ç•¥**
```
å†…å­˜å ç”¨åˆ†æï¼š
ğŸ”¸ è¿æ¥å¯¹è±¡æœ¬èº«ï¼šæ¯ä¸ªè¿æ¥çº¦å‡ KB
ğŸ”¸ Statementç¼“å­˜ï¼šå¯èƒ½å ç”¨å¤§é‡å†…å­˜
ğŸ”¸ ç»“æœé›†ç¼“å­˜ï¼šä¸´æ—¶å ç”¨å†…å­˜
ğŸ”¸ è¿æ¥æ± ç®¡ç†å¼€é”€ï¼šè¿æ¥æ± æ¡†æ¶è‡ªèº«å ç”¨

ä¼˜åŒ–æ–¹å‘ï¼š
â€¢ åˆç†è®¾ç½®è¿æ¥æ± å¤§å°
â€¢ ä¼˜åŒ–Statementç¼“å­˜é…ç½®
â€¢ åŠæ—¶é‡Šæ”¾èµ„æº
â€¢ ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ
```

**âš™ï¸ å†…å­˜ä¼˜åŒ–é…ç½®**
```java
// å†…å­˜ä¼˜åŒ–é…ç½®
public void optimizeMemoryUsage(HikariConfig config) {
    
    // 1. åˆç†è®¾ç½®è¿æ¥æ± å¤§å°ï¼ˆé¿å…è¿‡å¤§ï¼‰
    config.setMaximumPoolSize(50); // æ ¹æ®å®é™…éœ€è¦è®¾ç½®
    config.setMinimumIdle(10);     // æœ€å°è¿æ¥æ•°
    
    // 2. ä¼˜åŒ–Statementç¼“å­˜
    config.addDataSourceProperty("prepStmtCacheSize", "100");        // ç¼“å­˜100ä¸ªStatement
    config.addDataSourceProperty("prepStmtCacheSqlLimit", "1024");   // SQLé•¿åº¦é™åˆ¶1KB
    config.addDataSourceProperty("useServerPrepStmts", "true");
    
    // 3. è®¾ç½®è¿æ¥ç”Ÿå‘½å‘¨æœŸï¼ˆå®šæœŸé‡Šæ”¾é‡å»ºï¼‰
    config.setMaxLifetime(1800000); // 30åˆ†é’Ÿåé‡å»ºè¿æ¥
    config.setIdleTimeout(600000);  // 10åˆ†é’Ÿç©ºé—²è¶…æ—¶
    
    // 4. å¯ç”¨è¿æ¥æ³„æ¼æ£€æµ‹
    config.setLeakDetectionThreshold(300000); // 5åˆ†é’Ÿæ£€æµ‹æ³„æ¼
}
```

### 7.2 Statementç¼“å­˜ä¼˜åŒ–


**ğŸ“‹ Statementç¼“å­˜åŸç†**
```
ä»€ä¹ˆæ˜¯Statementç¼“å­˜ï¼š
å°†å·²ç¼–è¯‘çš„SQLè¯­å¥ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œé¿å…é‡å¤ç¼–è¯‘

ç¼“å­˜æ”¶ç›Šï¼š
â€¢ å‡å°‘SQLè§£ææ—¶é—´
â€¢ é™ä½æ•°æ®åº“CPUä½¿ç”¨
â€¢ æå‡é‡å¤æŸ¥è¯¢æ€§èƒ½

ç¼“å­˜æˆæœ¬ï¼š
â€¢ å ç”¨å®¢æˆ·ç«¯å†…å­˜
â€¢ ç¼“å­˜ç®¡ç†å¼€é”€
â€¢ ç¼“å­˜å¤±æ•ˆå¤„ç†
```

**ğŸ¯ Statementç¼“å­˜é…ç½®ç­–ç•¥**
```java
// Statementç¼“å­˜é…ç½®
public class StatementCacheConfig {
    
    /**
     * æ ¹æ®åº”ç”¨ç±»å‹é…ç½®Statementç¼“å­˜
     */
    public static void configureStatementCache(
            HikariConfig config, 
            ApplicationType appType) {
        
        switch (appType) {
            case HIGH_FREQUENCY_OLTP: // é«˜é¢‘OLTPåº”ç”¨
                config.addDataSourceProperty("prepStmtCacheSize", "500");      // å¤§ç¼“å­˜
                config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048"); // æ”¯æŒå¤æ‚SQL
                config.addDataSourceProperty("useServerPrepStmts", "true");
                break;
                
            case BATCH_PROCESSING: // æ‰¹å¤„ç†åº”ç”¨
                config.addDataSourceProperty("prepStmtCacheSize", "50");       // å°ç¼“å­˜
                config.addDataSourceProperty("prepStmtCacheSqlLimit", "4096");  // æ”¯æŒé•¿SQL
                config.addDataSourceProperty("useServerPrepStmts", "true");
                break;
                
            case REPORTING_SYSTEM: // æŠ¥è¡¨ç³»ç»Ÿ
                config.addDataSourceProperty("prepStmtCacheSize", "100");      // ä¸­ç­‰ç¼“å­˜
                config.addDataSourceProperty("prepStmtCacheSqlLimit", "8192");  // æ”¯æŒå¤æ‚æŠ¥è¡¨SQL
                config.addDataSourceProperty("useServerPrepStmts", "true");
                break;
                
            default:
                config.addDataSourceProperty("prepStmtCacheSize", "200");      // é»˜è®¤é…ç½®
                config.addDataSourceProperty("prepStmtCacheSqlLimit", "1024");
                config.addDataSourceProperty("useServerPrepStmts", "true");
        }
    }
    
    enum ApplicationType {
        HIGH_FREQUENCY_OLTP,
        BATCH_PROCESSING, 
        REPORTING_SYSTEM
    }
}
```

### 7.3 CPUç¼“å­˜ä¼˜åŒ–


**âš¡ CPUç¼“å­˜å‹å¥½çš„è¿æ¥ç®¡ç†**
```java
// CPUç¼“å­˜ä¼˜åŒ–çš„è¿æ¥æ± ç®¡ç†å™¨
public class CacheFriendlyConnectionManager {
    
    // ä½¿ç”¨çº¿ç¨‹æœ¬åœ°è¿æ¥ç¼“å­˜
    private final ThreadLocal<Connection> threadLocalConnection = new ThreadLocal<>();
    private final DataSource dataSource;
    
    public CacheFriendlyConnectionManager(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    /**
     * è·å–çº¿ç¨‹æœ¬åœ°è¿æ¥ï¼ˆCPUç¼“å­˜å‹å¥½ï¼‰
     */
    public Connection getThreadLocalConnection() throws SQLException {
        Connection conn = threadLocalConnection.get();
        
        // æ£€æŸ¥è¿æ¥æ˜¯å¦æœ‰æ•ˆ
        if (conn == null || conn.isClosed() || !conn.isValid(1)) {
            conn = dataSource.getConnection();
            threadLocalConnection.set(conn);
        }
        
        return conn;
    }
    
    /**
     * æ¸…ç†çº¿ç¨‹æœ¬åœ°è¿æ¥
     */
    public void cleanupThreadLocalConnection() {
        Connection conn = threadLocalConnection.get();
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                log.warn("å…³é—­çº¿ç¨‹æœ¬åœ°è¿æ¥å¤±è´¥", e);
            } finally {
                threadLocalConnection.remove();
            }
        }
    }
    
    /**
     * æ‰¹é‡æ“ä½œä¸­çš„è¿æ¥å¤ç”¨
     */
    @Transactional
    public void executeBatchWithConnectionReuse(List<String> sqls) throws SQLException {
        
        Connection conn = getThreadLocalConnection();
        
        try (PreparedStatement stmt = conn.prepareStatement("")) {
            for (String sql : sqls) {
                stmt.addBatch(sql);
            }
            stmt.executeBatch();
        }
        // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œå…³é—­è¿æ¥ï¼Œè®©çº¿ç¨‹æœ¬åœ°ç¼“å­˜ç®¡ç†
    }
}
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ è¿æ¥æ± å¤§å°è°ƒä¼˜ï¼šæ ¹æ®CPUæ ¸å¿ƒæ•°å’Œå¹¶å‘é‡ç§‘å­¦è®¡ç®—
ğŸ”¸ è¿æ¥è·å–ä¼˜åŒ–ï¼šå‡å°‘ç­‰å¾…æ—¶é—´ï¼Œæå‡å“åº”é€Ÿåº¦
ğŸ”¸ è¿æ¥éªŒè¯ä¼˜åŒ–ï¼šä½¿ç”¨è½»é‡çº§éªŒè¯ï¼Œå‡å°‘ç½‘ç»œå¼€é”€
ğŸ”¸ è¿æ¥æ± é¢„çƒ­ï¼šé¿å…å†·å¯åŠ¨é—®é¢˜ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
ğŸ”¸ æ‰¹é‡æ“ä½œå¤ç”¨ï¼šå‡å°‘è¿æ¥è·å–é‡Šæ”¾æ¬¡æ•°
ğŸ”¸ å†…å­˜ç¼“å­˜ä¼˜åŒ–ï¼šåˆç†é…ç½®ç¼“å­˜å¤§å°ï¼Œå¹³è¡¡æ€§èƒ½ä¸èµ„æº
```

### 8.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ è¿æ¥æ± å¤§å°ä¸æ˜¯è¶Šå¤§è¶Šå¥½**
```
åˆç†åŸåˆ™ï¼š
â€¢ è¿‡å°ï¼šé¢‘ç¹ç­‰å¾…ï¼Œæ€§èƒ½å·®
â€¢ è¿‡å¤§ï¼šæµªè´¹å†…å­˜ï¼Œæ•°æ®åº“å‹åŠ›å¤§
â€¢ åˆšå¥½ï¼šCPUåˆ©ç”¨ç‡é«˜ï¼Œèµ„æºä½¿ç”¨åˆç†

æ¨èå…¬å¼ï¼šCPUæ ¸å¿ƒæ•° Ã— 2 + ç£ç›˜æ•°é‡
```

**ğŸ”¹ é¢„çƒ­ç­–ç•¥çš„é‡è¦æ€§**
```
å†·å¯åŠ¨é—®é¢˜ï¼š
åº”ç”¨å¯åŠ¨æ—¶è¿æ¥æ± ä¸ºç©º â†’ é¦–æ‰¹è¯·æ±‚ç­‰å¾…æ—¶é—´é•¿ â†’ ç”¨æˆ·ä½“éªŒå·®

è§£å†³æ–¹æ¡ˆï¼š
åº”ç”¨å¯åŠ¨åç«‹å³åˆ›å»ºè‹¥å¹²è¿æ¥ â†’ è¿æ¥æ± "çƒ­èº«" â†’ é¦–æ‰¹è¯·æ±‚å¿«é€Ÿå“åº”
```

**ğŸ”¹ æ‰¹é‡æ“ä½œçš„æ€§èƒ½ä¼˜åŠ¿**
```
æ€§èƒ½å¯¹æ¯”ï¼š
å•æ¡æ‰§è¡Œï¼š1000æ¬¡ Ã— (è·å–è¿æ¥ + æ‰§è¡Œ + é‡Šæ”¾è¿æ¥)
æ‰¹é‡æ‰§è¡Œï¼š1æ¬¡ Ã— (è·å–è¿æ¥ + 1000æ¬¡æ‰§è¡Œ + é‡Šæ”¾è¿æ¥)

æ€§èƒ½æå‡ï¼šæ‰¹é‡æ“ä½œå¯æå‡5-10å€æ€§èƒ½
```

### 8.3 å®é™…åº”ç”¨ä»·å€¼


**ğŸ’¼ ç”Ÿäº§ç¯å¢ƒé…ç½®å»ºè®®**
```
é«˜å¹¶å‘Webåº”ç”¨ï¼š
æœ€å°è¿æ¥ï¼š20-50
æœ€å¤§è¿æ¥ï¼š100-200
éªŒè¯ç­–ç•¥ï¼šç©ºé—²æ—¶éªŒè¯
é¢„çƒ­è¿æ¥ï¼š20ä¸ª

æ•°æ®åˆ†æç³»ç»Ÿï¼š
æœ€å°è¿æ¥ï¼š5-10  
æœ€å¤§è¿æ¥ï¼š30-50
éªŒè¯ç­–ç•¥ï¼šè·å–æ—¶éªŒè¯
é¢„çƒ­è¿æ¥ï¼š10ä¸ª

æ‰¹å¤„ç†ç³»ç»Ÿï¼š
æœ€å°è¿æ¥ï¼š2-5
æœ€å¤§è¿æ¥ï¼š10-20
éªŒè¯ç­–ç•¥ï¼šåå°å®šæœŸéªŒè¯
é¢„çƒ­è¿æ¥ï¼š5ä¸ª
```

**ğŸ”§ ç›‘æ§æŒ‡æ ‡å»ºè®®**
```
å…³é”®ç›‘æ§æŒ‡æ ‡ï¼š
â€¢ æ´»è·ƒè¿æ¥æ•° vs æœ€å¤§è¿æ¥æ•°
â€¢ è¿æ¥è·å–å¹³å‡ç­‰å¾…æ—¶é—´
â€¢ è¿æ¥éªŒè¯å¤±è´¥ç‡
â€¢ è¿æ¥æ³„æ¼æ£€æµ‹æ¬¡æ•°
â€¢ è¿æ¥æ± å†…å­˜ä½¿ç”¨é‡
```

**ğŸš€ æ€§èƒ½ä¼˜åŒ–æ•ˆæœ**
```
ä¼˜åŒ–å‰ vs ä¼˜åŒ–åï¼š
è¿æ¥è·å–æ—¶é—´ï¼š50ms â†’ 2ms
åº”ç”¨å“åº”æ—¶é—´ï¼š500ms â†’ 200ms  
å†…å­˜ä½¿ç”¨ï¼šä¼˜åŒ–30-40%
æ•°æ®åº“è¿æ¥æ•°ï¼šå‡å°‘50%
ç³»ç»Ÿç¨³å®šæ€§ï¼šæ˜¾è‘—æå‡
```

**ğŸ§  è®°å¿†å£è¯€**ï¼š
```
"æ± å¤§å°ç®—CPUï¼Œé¢„çƒ­é¿å…å†·å¯åŠ¨
éªŒè¯è½»é‡é€‰åŸç”Ÿï¼Œæ‰¹é‡å¤ç”¨æ•ˆç‡é«˜
ç¼“å­˜é€‚åº¦çœå†…å­˜ï¼Œç›‘æ§æŒ‡æ ‡ä¿ç¨³å®š"
```

**æ ¸å¿ƒç†å¿µ**ï¼šè¿æ¥æ± ä¼˜åŒ–çš„æœ¬è´¨æ˜¯åœ¨æ€§èƒ½ã€èµ„æºä½¿ç”¨å’Œç¨³å®šæ€§ä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡ç‚¹ã€‚åˆç†çš„é…ç½®æ¯”è¿‡åº¦ä¼˜åŒ–æ›´é‡è¦ï¼Œç›‘æ§å’Œè°ƒä¼˜æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ã€‚