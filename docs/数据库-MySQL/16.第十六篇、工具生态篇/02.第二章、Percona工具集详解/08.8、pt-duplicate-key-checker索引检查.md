---
title: 8、pt-duplicate-key-checker索引检查
---
## 📚 目录

1. [重复索引问题概述](#1-重复索引问题概述)
2. [pt-duplicate-key-checker工具介绍](#2-pt-duplicate-key-checker工具介绍)
3. [重复索引识别与分析](#3-重复索引识别与分析)
4. [索引优化策略](#4-索引优化策略)
5. [清理计划制定与执行](#5-清理计划制定与执行)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 重复索引问题概述


### 1.1 什么是重复索引

**通俗理解**：重复索引就像给一本书做了多个相似的目录

```
比如一本技术书：
目录1：按章节排序
目录2：按章节+页码排序  
目录3：按章节+页码+标题排序

虽然都有用，但前两个其实是多余的，第3个就够了
```

**🔸 重复索引的类型**
```
完全重复：(name) 和 (name)
- 两个索引完全相同，纯粹浪费空间

前缀重复：(name) 和 (name, age)  
- 第一个被第二个"包含"了，通常可以删除

功能重复：(name, age) 和 (age, name)
- 顺序不同，但在某些查询中作用重复
```

### 1.2 重复索引带来的问题

**💰 存储空间浪费**
```
实际案例：
一个500万行的用户表
- 正常索引：占用200MB
- 重复索引：额外浪费150MB
- 总浪费：磁盘空间 + 内存缓存空间

累积效果：10个表 × 150MB = 1.5GB浪费
```

**⚡ 性能影响**
```
写操作变慢：
- 每次INSERT需要更新多个相同的索引
- 每次UPDATE需要维护重复的索引结构
- 每次DELETE需要清理多份索引数据

查询优化器困惑：
- 面对多个相似索引，选择困难
- 可能选择效率较低的索引
- 增加执行计划分析时间
```

### 1.3 重复索引产生的原因

**👨‍💻 常见产生场景**
```
开发迭代：
- 开发A创建了索引 idx_user_name
- 开发B不知情，又创建了 idx_name
- 结果：两个功能相同的索引共存

需求变更：
- 原有索引：(order_date)
- 新需求：(order_date, status)
- 忘记删除旧索引，造成前缀重复

自动生成：
- ORM框架自动创建索引
- 与手动创建的索引重复
- 缺乏统一的索引管理
```

---

## 2. 🛠️ pt-duplicate-key-checker工具介绍


### 2.1 工具基本概念

**🔸 核心定义**
```
pt-duplicate-key-checker：Percona工具包中的索引分析工具
作用：自动扫描数据库中的重复、冗余索引
特点：智能分析索引覆盖关系，提供优化建议
```

### 2.2 工具安装与基本使用

**📦 安装方式**
```bash
# CentOS/RHEL安装
yum install percona-toolkit

# Ubuntu安装  
apt-get install percona-toolkit

# 验证安装
pt-duplicate-key-checker --version
```

**🚀 基本使用语法**
```bash
# 基本检查命令
pt-duplicate-key-checker h=localhost,u=root,p=password

# 指定数据库检查
pt-duplicate-key-checker h=localhost,u=root,p=password,D=mydb

# 输出详细信息
pt-duplicate-key-checker h=localhost,u=root,p=password --verbose
```

### 2.3 重要参数详解

**🔧 关键参数说明**
```bash
连接参数：
-h host：数据库主机地址
-u user：用户名
-p password：密码  
-P port：端口号（默认3306）
-S socket：socket文件路径

分析参数：
-d database：指定分析的数据库
-t table：指定分析的表
--engines：指定存储引擎类型

输出参数：
--summary：显示汇总信息
--verbose：显示详细分析过程
--key-types：显示索引类型信息
```

---

## 3. 🔎 重复索引识别与分析


### 3.1 索引覆盖关系分析

**💡 覆盖关系的理解**
```
索引覆盖就像套娃：

基础索引：(name)           [可以处理: WHERE name = ?]
扩展索引：(name, age)      [可以处理: WHERE name = ? AND age = ?]
完整索引：(name, age, city)[可以处理: 上述所有查询 + WHERE name = ? AND age = ? AND city = ?]

结论：完整索引可以"覆盖"基础索引和扩展索引的功能
```

**🔍 实际检查示例**
```bash
# 检查特定表的重复索引
pt-duplicate-key-checker h=localhost,u=root,p=123456,D=testdb,t=users

# 典型输出解读：
# ########################################################################
# testdb.users
# ########################################################################

# idx_name is a left-prefix of idx_name_age
# Key definitions:
#   idx_name      (name)
#   idx_name_age  (name,age)
# Column types:
#   `name` varchar(50) not null
#   `age` int(11) not null
# To remove this duplicate index, execute:
# ALTER TABLE `testdb`.`users` DROP INDEX `idx_name`;
```

### 3.2 重复索引类型识别

**📊 完全重复索引**
```sql
-- 示例：两个完全相同的索引
CREATE TABLE orders (
  id int PRIMARY KEY,
  user_id int,
  order_date date,
  INDEX idx_user (user_id),
  INDEX idx_user_duplicate (user_id)  -- 完全重复
);

-- pt-duplicate-key-checker输出：
# idx_user_duplicate is a duplicate of idx_user
# 建议：DROP INDEX idx_user_duplicate
```

**🔗 前缀重复索引**
```sql
-- 示例：前缀重复关系
CREATE TABLE products (
  id int PRIMARY KEY,
  category_id int,
  brand_id int,
  name varchar(100),
  INDEX idx_category (category_id),
  INDEX idx_category_brand (category_id, brand_id)  -- 包含前缀
);

-- 分析结果：
# idx_category is a left-prefix of idx_category_brand
# 在大多数情况下，可以删除 idx_category
```

### 3.3 索引使用率分析

**📈 结合performance_schema分析**
```sql
-- 查看索引使用统计
SELECT 
  object_schema,
  object_name,
  index_name,
  count_star as total_access,
  count_read,
  count_write,
  count_fetch,
  count_insert,
  count_update,
  count_delete
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'mydb'
  AND index_name IS NOT NULL
ORDER BY count_star DESC;
```

**💰 索引ROI计算**
```
索引投资回报率评估：

成本计算：
- 存储成本：索引大小 × 存储单价
- 维护成本：写操作延迟 × 写操作频率
- 内存成本：索引缓存占用

收益计算：  
- 查询加速：减少的查询时间 × 查询频率
- 系统资源节省：减少的CPU/IO消耗

ROI = (收益 - 成本) / 成本 × 100%
```

---

## 4. ⚡ 索引优化策略


### 4.1 清理优先级制定

**🎯 风险评估矩阵**
```
           使用频率
         低    中    高
风险 高  暂缓  谨慎  不删
    中  删除  测试  保留  
    低  删除  删除  测试

风险等级判断：
- 低风险：完全重复的索引
- 中风险：前缀重复，但有特殊用途
- 高风险：可能被特定查询依赖的索引
```

**📋 清理优先级列表**
```
🟢 第1优先级（安全删除）：
- 完全重复的索引
- 从未被使用的冗余索引
- 明显的错误创建

🟡 第2优先级（测试删除）：
- 前缀重复，但使用率极低
- 功能被其他索引覆盖95%以上

🔴 第3优先级（谨慎评估）：
- 有一定使用率的重复索引
- 可能被特定业务场景依赖
```

### 4.2 智能索引建议

**🧠 合并索引策略**
```sql
-- 原始索引（低效）：
CREATE INDEX idx_date ON orders(order_date);
CREATE INDEX idx_status ON orders(status);
CREATE INDEX idx_user ON orders(user_id);

-- 优化后（高效）：
CREATE INDEX idx_user_date_status ON orders(user_id, order_date, status);
-- 可以满足多种查询组合需求

-- 查询覆盖能力：
-- WHERE user_id = ? ✓
-- WHERE user_id = ? AND order_date = ? ✓  
-- WHERE user_id = ? AND order_date = ? AND status = ? ✓
```

**🔄 索引重构建议**
```sql
-- 场景：电商订单表优化
-- 原有索引：
CREATE INDEX idx_date ON orders(order_date);
CREATE INDEX idx_user ON orders(user_id);
CREATE INDEX idx_status ON orders(status);

-- 查询分析：
-- 90%的查询：WHERE user_id = ? AND order_date >= ?
-- 5%的查询：WHERE status = ? AND order_date >= ?
-- 5%的查询：WHERE order_date >= ?

-- 优化方案：
DROP INDEX idx_date, idx_user, idx_status;
CREATE INDEX idx_user_date ON orders(user_id, order_date);
CREATE INDEX idx_status_date ON orders(status, order_date);
```

### 4.3 索引生命周期管理

**📅 定期检查机制**
```bash
#!/bin/bash
# 索引健康检查脚本

# 1. 检查重复索引
echo "=== 重复索引检查 ==="
pt-duplicate-key-checker h=localhost,u=monitor,p=password --summary

# 2. 检查未使用索引
echo "=== 未使用索引检查 ==="
mysql -e "
SELECT DISTINCT 
  object_schema,
  object_name,
  index_name
FROM performance_schema.table_io_waits_summary_by_index_usage 
WHERE index_name IS NOT NULL 
  AND count_star = 0
  AND object_schema NOT IN ('mysql','performance_schema','information_schema')
"

# 3. 生成清理建议
echo "=== 清理建议 ==="
# 输出到文件供人工审核
```

---

## 5. 🎯 清理计划制定与执行


### 5.1 风险评估与预案

**⚠️ 清理前风险评估**
```sql
-- 1. 备份当前索引结构
SELECT 
  TABLE_SCHEMA,
  TABLE_NAME,
  INDEX_NAME,
  COLUMN_NAME,
  SEQ_IN_INDEX,
  COLLATION,
  INDEX_TYPE
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'mydb'
ORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;

-- 2. 记录当前查询性能基准
-- 3. 准备回滚脚本
```

**🛡️ 安全清理流程**
```bash
# Step 1: 生成清理SQL
pt-duplicate-key-checker h=localhost,u=root,p=password,D=mydb > cleanup_plan.sql

# Step 2: 人工审核
# 仔细检查每个DROP INDEX语句

# Step 3: 测试环境验证
# 在测试环境先执行清理操作

# Step 4: 业务低峰期执行
# 选择访问量最低的时间窗口

# Step 5: 实时监控
# 监控关键查询的性能变化
```

### 5.2 清理执行监控

**📊 实时性能监控**
```sql
-- 清理前后对比查询
-- 清理前执行：
SELECT 
  sql_text,
  exec_count,
  avg_timer_wait/1000000000 as avg_exec_time_sec,
  rows_examined_avg,
  rows_sent_avg
FROM performance_schema.events_statements_summary_by_digest 
WHERE schema_name = 'mydb'
ORDER BY exec_count DESC LIMIT 20;

-- 清理后再执行相同查询进行对比
```

**🔄 回滚预案**
```sql
-- 准备回滚脚本示例
-- 如果删除了 idx_user_name，回滚命令：
ALTER TABLE users ADD INDEX idx_user_name (user_name);

-- 如果删除了组合索引，回滚命令：
ALTER TABLE orders ADD INDEX idx_user_date (user_id, order_date);
```

### 5.3 清理效果验证

**✅ 效果验证指标**
```
空间节省验证：
- 清理前表大小：SELECT table_name, data_length, index_length 
- 清理后表大小：对比计算节省的空间
- 预期：索引空间减少10-30%

性能影响验证：
- 关键查询响应时间对比
- 写操作性能提升验证  
- 整体系统负载变化

预期改善：
- 写操作性能提升5-15%
- 存储空间节省10-40%
- 查询优化器选择更准确
```

**📈 持续优化建议**
```
建立定期检查机制：
- 每月执行重复索引检查
- 每季度进行索引使用率分析
- 每半年制定索引优化计划

索引管理规范：
- 新索引创建需要审核
- 索引命名规范统一
- 定期清理无用索引

监控告警：
- 索引数量异常增长告警
- 重复索引自动发现通知
- 索引空间占用监控
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念

```
🔸 重复索引：功能相同或有包含关系的多个索引
🔸 索引覆盖：一个索引能够满足另一个索引的所有查询需求
🔸 前缀重复：短索引被长索引的前缀部分完全包含
🔸 存储浪费：重复索引造成的磁盘和内存双重浪费
🔸 性能影响：写操作变慢，查询优化器选择困难
```

### 6.2 pt-duplicate-key-checker核心功能

**🔧 工具能力**
```
索引分析：
- 自动识别完全重复索引
- 发现前缀重复关系
- 分析索引覆盖情况

优化建议：
- 生成清理SQL语句
- 提供索引合并建议
- 评估空间节省效果

安全保障：
- 详细的分析报告
- 清晰的删除建议
- 风险评估信息
```

### 6.3 索引优化最佳实践

**💡 关键原则**
```
安全第一：
- 清理前必须备份
- 测试环境先验证
- 业务低峰期执行

渐进优化：
- 先删除明显重复的
- 再处理前缀重复的
- 最后考虑功能重复的

持续管理：
- 定期检查机制
- 索引创建规范
- 性能监控告警
```

### 6.4 实际应用价值

**🎯 业务收益**
```
成本节省：
- 存储空间节省10-40%
- 内存使用优化
- 维护成本降低

性能提升：
- 写操作性能提升5-15%
- 查询优化更准确
- 系统响应速度提升

管理效率：
- 自动化索引分析
- 标准化清理流程
- 风险可控的优化
```

### 6.5 学习检查清单

```
基础理解：
- [ ] 理解重复索引的概念和危害
- [ ] 掌握pt-duplicate-key-checker的基本用法
- [ ] 学会读懂工具的分析报告

实践操作：
- [ ] 能够安全地执行索引清理
- [ ] 制定合适的优化策略
- [ ] 建立定期检查机制

高级应用：
- [ ] 结合业务场景制定索引策略
- [ ] 建立完整的索引生命周期管理
- [ ] 实现自动化的索引监控告警
```

**🧠 核心记忆**：
- pt-duplicate-key-checker是索引体检工具
- 重复索引浪费空间拖慢性能
- 清理要谨慎，测试要充分
- 定期检查，持续优化