---
title: 3ã€å“ˆå¸Œè¡¨
---
## ğŸ“š ç›®å½•

1. [ç®—æ³•æ¦‚è¿°](#1-ç®—æ³•æ¦‚è¿°)
2. [åŸºæœ¬æ€æƒ³](#2-åŸºæœ¬æ€æƒ³)
3. [ç®—æ³•åŸç†](#3-ç®—æ³•åŸç†)
4. [å®ç°æ–¹æ³•](#4-å®ç°æ–¹æ³•)
5. [ç®—æ³•åˆ†æ](#5-ç®—æ³•åˆ†æ)
6. [å…¸å‹åº”ç”¨](#6-å…¸å‹åº”ç”¨)
7. [æ€»ç»“](#7-æ€»ç»“)

---

## 1. ğŸ“– ç®—æ³•æ¦‚è¿°


### 1.1 å®šä¹‰

å“ˆå¸Œè¡¨ï¼ˆHash Tableï¼‰ï¼Œä¹Ÿç§°æ•£åˆ—è¡¨ï¼Œæ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œå®ƒä½¿ç”¨å“ˆå¸Œå‡½æ•°å°†é”®ï¼ˆkeyï¼‰æ˜ å°„åˆ°è¡¨ä¸­çš„ä½ç½®ï¼Œä»¥æ”¯æŒå¿«é€Ÿçš„æ’å…¥ã€åˆ é™¤å’ŒæŸ¥æ‰¾æ“ä½œã€‚å“ˆå¸Œè¡¨æ˜¯å®ç°å…³è”æ•°ç»„ï¼ˆå­—å…¸ï¼‰æŠ½è±¡æ•°æ®ç±»å‹çš„ä¸»è¦æ–¹å¼ã€‚

```
æ ¸å¿ƒæ€æƒ³ï¼š
é”®(Key) â†’ [å“ˆå¸Œå‡½æ•°] â†’ ç´¢å¼•(Index) â†’ å€¼(Value)

ä¾‹å­ï¼š
"apple" â†’ hash("apple") â†’ 3 â†’ "è‹¹æœ"
"banana" â†’ hash("banana") â†’ 7 â†’ "é¦™è•‰"
```


### 1.2 å†å²èƒŒæ™¯

- **èµ·æº**ï¼š1953å¹´ï¼ŒHans Peter Luhnåœ¨IBMæå‡ºæ•£åˆ—æŠ€æœ¯
- **å‘å±•**ï¼š1960å¹´ä»£ï¼Œå“ˆå¸Œè¡¨å¼€å§‹åœ¨ç¼–ç¨‹è¯­è¨€ä¸­åº”ç”¨
- **ç°ä»£åŒ–**ï¼š1980-1990å¹´ä»£ï¼Œå„ç§ä¼˜åŒ–æŠ€æœ¯æˆç†Ÿ
- **æ ‡å‡†åŒ–**ï¼šæˆä¸ºç°ä»£ç¼–ç¨‹è¯­è¨€çš„æ ‡å‡†æ•°æ®ç»“æ„

### 1.3 æ ¸å¿ƒç‰¹å¾

- **ğŸ”¹ å¿«é€Ÿè®¿é—®**ï¼šå¹³å‡O(1)æ—¶é—´å¤æ‚åº¦çš„æ“ä½œ
- **ğŸ”¹ åŠ¨æ€å¤§å°**ï¼šæ”¯æŒåŠ¨æ€æ‰©å®¹å’Œç¼©å®¹
- **ğŸ”¹ é”®å€¼å…³è”**ï¼šç»´æŠ¤é”®å€¼å¯¹çš„æ˜ å°„å…³ç³»
- **ğŸ”¹ æ— åºå­˜å‚¨**ï¼šä¸ä¿æŒæ’å…¥é¡ºåº
- **ğŸ”¹ å†…å­˜é«˜æ•ˆ**ï¼šç›¸æ¯”æ ‘ç»“æ„æœ‰æ›´å¥½çš„ç©ºé—´å±€éƒ¨æ€§

### 1.4 åŸºæœ¬æ“ä½œ

- **æ’å…¥ï¼ˆInsert/Putï¼‰**ï¼šæ·»åŠ é”®å€¼å¯¹
- **æŸ¥æ‰¾ï¼ˆSearch/Getï¼‰**ï¼šæ ¹æ®é”®è·å–å€¼
- **åˆ é™¤ï¼ˆDelete/Removeï¼‰**ï¼šç§»é™¤é”®å€¼å¯¹
- **æ›´æ–°ï¼ˆUpdateï¼‰**ï¼šä¿®æ”¹å·²å­˜åœ¨é”®çš„å€¼
- **éå†ï¼ˆIterateï¼‰**ï¼šè®¿é—®æ‰€æœ‰é”®å€¼å¯¹

### 1.5 å˜ä½“ç±»å‹

- **é™æ€å“ˆå¸Œè¡¨**ï¼šå¤§å°å›ºå®šï¼Œä¸æ”¯æŒåŠ¨æ€è°ƒæ•´
- **åŠ¨æ€å“ˆå¸Œè¡¨**ï¼šæ”¯æŒåŠ¨æ€æ‰©å®¹å’Œç¼©å®¹
- **çº¿æ€§å“ˆå¸Œ**ï¼šæ¸è¿›å¼æ‰©å®¹ï¼Œé¿å…ä¸€æ¬¡æ€§é‡å“ˆå¸Œ
- **æ‰©å±•å“ˆå¸Œ**ï¼šç›®å½•ç»“æ„æ”¯æŒçš„åŠ¨æ€å“ˆå¸Œ
- **å¸ƒè°·é¸Ÿå“ˆå¸Œ**ï¼šä¿è¯æœ€åæƒ…å†µO(1)æŸ¥æ‰¾æ—¶é—´

---

## 2. ğŸ’¡ åŸºæœ¬æ€æƒ³


### 2.1 æ ¸å¿ƒæ€æƒ³

å“ˆå¸Œè¡¨çš„æ ¸å¿ƒæ€æƒ³æ˜¯"ç›´æ¥å®šå€"ï¼š
1. **åœ°å€è®¡ç®—**ï¼šé€šè¿‡å“ˆå¸Œå‡½æ•°ç›´æ¥è®¡ç®—å­˜å‚¨ä½ç½®
2. **å¿«é€Ÿå®šä½**ï¼šé¿å…é¡ºåºæœç´¢ï¼Œå®ç°å¸¸æ•°æ—¶é—´è®¿é—®
3. **ç©ºé—´æ¢æ—¶é—´**ï¼šé¢„åˆ†é…ç©ºé—´æ¢å–æ—¶é—´æ•ˆç‡
4. **å†²çªå¤„ç†**ï¼šè®¾è®¡æœºåˆ¶å¤„ç†åœ°å€å†²çª

### 2.2 è®¾è®¡ç†å¿µ


**æ•°ç»„çš„ä¼˜åŠ¿ + çµæ´»çš„ç´¢å¼•ï¼š**
- æ•°ç»„æä¾›O(1)çš„éšæœºè®¿é—®èƒ½åŠ›
- å“ˆå¸Œå‡½æ•°æä¾›ä»ä»»æ„é”®åˆ°æ•°ç»„ç´¢å¼•çš„æ˜ å°„
- ç»“åˆä¸¤è€…ä¼˜åŠ¿å®ç°é«˜æ•ˆçš„é”®å€¼å­˜å‚¨

**ç©ºé—´ä¸æ—¶é—´çš„å¹³è¡¡ï¼š**
- ç©ºé—´åˆ©ç”¨ç‡ vs æŸ¥æ‰¾æ•ˆç‡
- è´Ÿè½½å› å­æ§åˆ¶æ€§èƒ½å’Œç©ºé—´çš„å¹³è¡¡
- åŠ¨æ€è°ƒæ•´ç»´æŒæœ€ä¼˜æ€§èƒ½

### 2.3 å“ˆå¸Œè¡¨å·¥ä½œæµç¨‹ç¤ºä¾‹

ä»¥å­¦ç”Ÿä¿¡æ¯ç®¡ç†ä¸ºä¾‹ï¼š

```
å­¦ç”Ÿæ•°æ®ï¼š
- å¼ ä¸‰(ID: 2021001) â†’ {å§“å: "å¼ ä¸‰", å¹´é¾„: 20, ä¸“ä¸š: "è®¡ç®—æœº"}
- æå››(ID: 2021002) â†’ {å§“å: "æå››", å¹´é¾„: 19, ä¸“ä¸š: "æ•°å­¦"}
- ç‹äº”(ID: 2021003) â†’ {å§“å: "ç‹äº”", å¹´é¾„: 21, ä¸“ä¸š: "ç‰©ç†"}

å“ˆå¸Œè¡¨æ“ä½œè¿‡ç¨‹ï¼š
1. åˆå§‹åŒ–ï¼šåˆ›å»ºå¤§å°ä¸º7çš„å“ˆå¸Œè¡¨

2. æ’å…¥æ“ä½œï¼š
   - put(2021001, å¼ ä¸‰ä¿¡æ¯)
     å“ˆå¸Œå€¼ï¼š2021001 % 7 = 4
     å­˜å‚¨åˆ°ä½ç½®4
   
   - put(2021002, æå››ä¿¡æ¯)
     å“ˆå¸Œå€¼ï¼š2021002 % 7 = 5
     å­˜å‚¨åˆ°ä½ç½®5
   
   - put(2021003, ç‹äº”ä¿¡æ¯)
     å“ˆå¸Œå€¼ï¼š2021003 % 7 = 6
     å­˜å‚¨åˆ°ä½ç½®6

3. æŸ¥æ‰¾æ“ä½œï¼š
   - get(2021001)
     è®¡ç®—å“ˆå¸Œå€¼ï¼š2021001 % 7 = 4
     è®¿é—®ä½ç½®4ï¼Œè¿”å›å¼ ä¸‰ä¿¡æ¯

4. è¡¨çŠ¶æ€ï¼š
   ä½ç½®0: ç©º
   ä½ç½®1: ç©º
   ä½ç½®2: ç©º
   ä½ç½®3: ç©º
   ä½ç½®4: (2021001, å¼ ä¸‰ä¿¡æ¯)
   ä½ç½®5: (2021002, æå››ä¿¡æ¯)
   ä½ç½®6: (2021003, ç‹äº”ä¿¡æ¯)

ä¼˜åŠ¿ä½“ç°ï¼š
- æŸ¥æ‰¾å­¦ç”Ÿä¿¡æ¯ï¼šO(1) vs æ•°ç»„O(n) vs äºŒåˆ†æœç´¢O(log n)
- æ’å…¥æ–°å­¦ç”Ÿï¼šO(1) vs æœ‰åºæ•°ç»„O(n)
- åˆ é™¤å­¦ç”Ÿï¼šO(1) vs æ•°ç»„O(n)
```

---

## 3. âš™ï¸ ç®—æ³•åŸç†


### 3.1 å“ˆå¸Œè¡¨ç»“æ„è®¾è®¡


#### 3.1.1 åŸºæœ¬ç»„ä»¶

```
å“ˆå¸Œè¡¨çš„æ ¸å¿ƒç»„ä»¶ï¼š

1. æ¡¶æ•°ç»„ï¼ˆBucket Arrayï¼‰ï¼š
   - å­˜å‚¨å®é™…æ•°æ®çš„å®¹å™¨
   - å¤§å°é€šå¸¸ä¸ºè´¨æ•°
   - æ”¯æŒéšæœºè®¿é—®

2. å“ˆå¸Œå‡½æ•°ï¼ˆHash Functionï¼‰ï¼š
   - é”®åˆ°ç´¢å¼•çš„æ˜ å°„å‡½æ•°
   - å†³å®šåˆ†å¸ƒå‡åŒ€æ€§
   - å½±å“ç¢°æ’æ¦‚ç‡

3. ç¢°æ’å¤„ç†æœºåˆ¶ï¼š
   - é“¾åœ°å€æ³•ï¼šæ¯ä¸ªæ¡¶ç»´æŠ¤é“¾è¡¨
   - å¼€æ”¾å®šå€æ³•ï¼šåœ¨è¡¨å†…å¯»æ‰¾ç©ºä½
   - å†å“ˆå¸Œï¼šä½¿ç”¨å¤šä¸ªå“ˆå¸Œå‡½æ•°

4. è´Ÿè½½å› å­æ§åˆ¶ï¼š
   - ç›‘æ§è¡¨çš„å¡«å……åº¦
   - è§¦å‘æ‰©å®¹/ç¼©å®¹æ“ä½œ
   - ç»´æŒæ€§èƒ½ç¨³å®šæ€§
```

#### 3.1.2 å†…å­˜å¸ƒå±€

```
é“¾åœ°å€æ³•å¸ƒå±€ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å“ˆå¸Œè¡¨æ•°ç»„                        â”‚
â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¤
â”‚  0  â”‚  1  â”‚  2  â”‚  3  â”‚  4  â”‚ ...â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚null â”‚ ptr â”‚null â”‚ ptr â”‚ ptr â”‚ ...â”‚ â†’ æŒ‡å‘é“¾è¡¨
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
              â†“           â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ èŠ‚ç‚¹1   â”‚ â”‚ èŠ‚ç‚¹2   â”‚
         â”‚ next â†’ â”‚ â”‚ next â†’ â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å¼€æ”¾å®šå€æ³•å¸ƒå±€ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å“ˆå¸Œè¡¨æ•°ç»„ï¼ˆè¿ç»­å†…å­˜ï¼‰              â”‚
â”œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¤
â”‚  0  â”‚  1  â”‚  2  â”‚  3  â”‚  4  â”‚ ...â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
â”‚entryâ”‚emptyâ”‚entryâ”‚emptyâ”‚entryâ”‚ ...â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
```

### 3.2 åŠ¨æ€æ‰©å®¹æœºåˆ¶


#### 3.2.1 æ‰©å®¹è§¦å‘æ¡ä»¶

```
å¸¸è§è§¦å‘æ¡ä»¶ï¼š
1. è´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼ï¼ˆé€šå¸¸0.75ï¼‰
2. å¹³å‡æ¢æµ‹è·ç¦»è¿‡é•¿
3. æœ€é•¿é“¾é•¿åº¦è¶…è¿‡é˜ˆå€¼
4. æ’å…¥æ“ä½œå¤±è´¥

æ‰©å®¹æ—¶æœºé€‰æ‹©ï¼š
- ç«‹å³æ‰©å®¹ï¼šæ“ä½œæ—¶æ£€æŸ¥å¹¶ç«‹å³æ‰©å®¹
- å»¶è¿Ÿæ‰©å®¹ï¼šåå°æˆ–ç©ºé—²æ—¶æ‰©å®¹
- æ¸è¿›æ‰©å®¹ï¼šåˆ†å¤šæ¬¡å®Œæˆæ‰©å®¹
```

#### 3.2.2 æ‰©å®¹è¿‡ç¨‹

```
å…¸å‹æ‰©å®¹æµç¨‹ï¼š
1. åˆ†é…æ–°çš„æ›´å¤§æ•°ç»„ï¼ˆé€šå¸¸2å€å¤§å°ï¼‰
2. éå†æ—§è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ 
3. å¯¹æ¯ä¸ªå…ƒç´ é‡æ–°è®¡ç®—å“ˆå¸Œå€¼
4. æ’å…¥åˆ°æ–°è¡¨ä¸­
5. é‡Šæ”¾æ—§è¡¨å†…å­˜
6. æ›´æ–°è¡¨å¤§å°å’Œé˜ˆå€¼

æ—¶é—´å¤æ‚åº¦åˆ†æï¼š
- å•æ¬¡æ‰©å®¹ï¼šO(n)
- æ‘Šè¿˜å¤æ‚åº¦ï¼šO(1)
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)

ä¼˜åŒ–ç­–ç•¥ï¼š
- æ¸è¿›å¼å†å“ˆå¸Œï¼šåˆ†å¤šæ¬¡å®Œæˆè¿ç§»
- é¢„åˆ†é…ç­–ç•¥ï¼šæ ¹æ®é¢„æœŸå¤§å°åˆå§‹åŒ–
- è´¨æ•°å¤§å°ï¼šå‡å°‘ç¢°æ’æ¦‚ç‡
```

### 3.3 æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯


#### 3.3.1 å“ˆå¸Œå‡½æ•°ä¼˜åŒ–

```
é«˜è´¨é‡å“ˆå¸Œå‡½æ•°ç‰¹å¾ï¼š
1. è®¡ç®—å¿«é€Ÿï¼šç®€å•çš„ç®—æœ¯è¿ç®—
2. åˆ†å¸ƒå‡åŒ€ï¼šå‡å°‘èšé›†ç°è±¡
3. é›ªå´©æ•ˆåº”ï¼šè¾“å…¥å¾®å˜å¼•èµ·è¾“å‡ºå¤§å˜
4. ç¡®å®šæ€§ï¼šç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º

å¸¸ç”¨ä¼˜åŒ–æŠ€æœ¯ï¼š
- ä¹˜æ³•å“ˆå¸Œï¼šé¿å…æ¨¡è¿ç®—çš„å‘¨æœŸæ€§
- é€šç”¨å“ˆå¸Œï¼šéšæœºé€‰æ‹©å“ˆå¸Œå‡½æ•°
- å¯†ç å­¦å“ˆå¸Œï¼šé«˜å®‰å…¨æ€§è¦æ±‚åœºæ™¯
- å±€éƒ¨æ•æ„Ÿå“ˆå¸Œï¼šç›¸ä¼¼è¾“å…¥äº§ç”Ÿç›¸ä¼¼è¾“å‡º
```

#### 3.3.2 ç¼“å­˜å‹å¥½è®¾è®¡

```
å†…å­˜è®¿é—®ä¼˜åŒ–ï¼š
1. æ•°æ®å±€éƒ¨æ€§ï¼š
   - å¼€æ”¾å®šå€æ³•åˆ©ç”¨ç©ºé—´å±€éƒ¨æ€§
   - è¿ç»­å†…å­˜è®¿é—®æé«˜ç¼“å­˜å‘½ä¸­ç‡
   - é¢„å–æœºåˆ¶å‡å°‘å†…å­˜å»¶è¿Ÿ

2. ç¼“å­˜è¡Œå¯¹é½ï¼š
   - èŠ‚ç‚¹å¤§å°å¯¹é½åˆ°ç¼“å­˜è¡Œ
   - é¿å…è·¨ç¼“å­˜è¡Œè®¿é—®
   - å‡å°‘false sharing

3. å†…å­˜æ± ï¼š
   - é¢„åˆ†é…å†…å­˜æ± å‡å°‘mallocå¼€é”€
   - å¯¹è±¡å¤ç”¨æé«˜æ€§èƒ½
   - å‡å°‘å†…å­˜ç¢ç‰‡
```

### 3.4 çº¿ç¨‹å®‰å…¨è®¾è®¡


#### 3.4.1 å¹¶å‘æ§åˆ¶ç­–ç•¥

```
è¯»å†™é”ç­–ç•¥ï¼š
- å¤šè¯»å•å†™ï¼šå…è®¸å¤šä¸ªè¯»æ“ä½œå¹¶å‘
- åˆ†æ®µé”ï¼šå°†è¡¨åˆ†ä¸ºå¤šä¸ªæ®µï¼Œæ¯æ®µç‹¬ç«‹åŠ é”
- æ— é”è®¾è®¡ï¼šä½¿ç”¨CASæ“ä½œå®ç°æ— é”å¹¶å‘

ç»†ç²’åº¦é”ï¼š
- æ¡¶çº§é”ï¼šæ¯ä¸ªæ¡¶ç‹¬ç«‹åŠ é”
- æ¡ç›®çº§é”ï¼šæ¯ä¸ªæ¡ç›®ç‹¬ç«‹åŠ é”
- è‡ªé€‚åº”é”ï¼šæ ¹æ®ç«äº‰ç¨‹åº¦è°ƒæ•´ç­–ç•¥
```

#### 3.3.2 æ— é”å“ˆå¸Œè¡¨

```
æ— é”è®¾è®¡åŸç†ï¼š
1. CASæ“ä½œï¼šåŸå­æ¯”è¾ƒå¹¶äº¤æ¢
2. å†…å­˜å±éšœï¼šä¿è¯æ“ä½œé¡ºåº
3. ABAé—®é¢˜ï¼šç‰ˆæœ¬å·æˆ–æŒ‡é’ˆæ ‡è®°
4. å¸®åŠ©æœºåˆ¶ï¼šå¤±è´¥çº¿ç¨‹å¸®åŠ©å…¶ä»–çº¿ç¨‹å®Œæˆæ“ä½œ

å®ç°æŒ‘æˆ˜ï¼š
- æ‰©å®¹æ“ä½œçš„åŸå­æ€§
- å†…å­˜å›æ”¶çš„å®‰å…¨æ€§
- ABAé—®é¢˜çš„é¿å…
- æ€§èƒ½ä¸æ­£ç¡®æ€§çš„å¹³è¡¡
```

---

## 4. ğŸ”¨ å®ç°æ–¹æ³•


### 4.1 åŸºç¡€å“ˆå¸Œè¡¨å®ç°


```java
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * å®Œæ•´çš„å“ˆå¸Œè¡¨å®ç°
 * æ”¯æŒåŠ¨æ€æ‰©å®¹ã€å¤šç§ç¢°æ’å¤„ç†ç­–ç•¥
 */
public class HashTable<K, V> implements Iterable<HashTable.Entry<K, V>> {
    
    /**
     * é”®å€¼å¯¹èŠ‚ç‚¹
     */
    public static class Entry<K, V> {
        private final K key;
        private V value;
        private Entry<K, V> next;
        private final int hashCode;
        
        public Entry(K key, V value, int hashCode) {
            this.key = key;
            this.value = value;
            this.hashCode = hashCode;
        }
        
        public K getKey() { return key; }
        public V getValue() { return value; }
        public void setValue(V value) { this.value = value; }
        
        @Override
        public String toString() {
            return key + "=" + value;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (!(obj instanceof Entry)) return false;
            Entry<?, ?> entry = (Entry<?, ?>) obj;
            return Objects.equals(key, entry.key) && Objects.equals(value, entry.value);
        }
        
        @Override
        public int hashCode() {
            return this.hashCode;
        }
    }
    
    // é»˜è®¤é…ç½®
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    private static final double DEFAULT_LOAD_FACTOR = 0.75;
    private static final int MAXIMUM_CAPACITY = 1 << 30;
    
    // æ ¸å¿ƒæ•°æ®
    private Entry<K, V>[] table;
    private int size;
    private int threshold;
    private final double loadFactor;
    private int modCount; // ç»“æ„ä¿®æ”¹æ¬¡æ•°ï¼Œç”¨äºå¿«é€Ÿå¤±è´¥
    
    /**
     * æ„é€ å‡½æ•°
     */
    @SuppressWarnings("unchecked")
    public HashTable(int initialCapacity, double loadFactor) {
        if (initialCapacity < 0) {
            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
        }
        if (initialCapacity > MAXIMUM_CAPACITY) {
            initialCapacity = MAXIMUM_CAPACITY;
        }
        if (loadFactor <= 0 || Double.isNaN(loadFactor)) {
            throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
        }
        
        this.loadFactor = loadFactor;
        this.table = new Entry[tableSizeFor(initialCapacity)];
        this.threshold = (int) (table.length * loadFactor);
        this.size = 0;
        this.modCount = 0;
    }
    
    public HashTable(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    public HashTable() {
        this(DEFAULT_INITIAL_CAPACITY);
    }
    
    /**
     * è®¡ç®—åˆé€‚çš„è¡¨å¤§å°ï¼ˆ2çš„å¹‚æ¬¡ï¼‰
     */
    private static int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
    
    /**
     * è®¡ç®—å“ˆå¸Œå€¼
     */
    private static int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    
    /**
     * è·å–è¡¨ä¸­çš„ç´¢å¼•
     */
    private int indexFor(int hash, int length) {
        return hash & (length - 1); // ç­‰ä»·äº hash % lengthï¼Œä½†æ›´å¿«
    }
    
    /**
     * æ’å…¥æˆ–æ›´æ–°é”®å€¼å¯¹
     */
    public V put(K key, V value) {
        int hash = hash(key);
        int index = indexFor(hash, table.length);
        
        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨è¯¥é”®
        for (Entry<K, V> e = table[index]; e != null; e = e.next) {
            if (e.hashCode == hash && Objects.equals(e.key, key)) {
                V oldValue = e.value;
                e.value = value;
                return oldValue;
            }
        }
        
        // æ’å…¥æ–°èŠ‚ç‚¹
        addEntry(hash, key, value, index);
        return null;
    }
    
    /**
     * æ·»åŠ æ–°æ¡ç›®
     */
    private void addEntry(int hash, K key, V value, int bucketIndex) {
        Entry<K, V> e = table[bucketIndex];
        table[bucketIndex] = new Entry<>(key, value, hash);
        table[bucketIndex].next = e;
        
        size++;
        modCount++;
        
        if (size >= threshold) {
            resize(2 * table.length);
        }
    }
    
    /**
     * è·å–å€¼
     */
    public V get(Object key) {
        int hash = hash(key);
        int index = indexFor(hash, table.length);
        
        for (Entry<K, V> e = table[index]; e != null; e = e.next) {
            if (e.hashCode == hash && Objects.equals(e.key, key)) {
                return e.value;
            }
        }
        
        return null;
    }
    
    /**
     * åˆ é™¤é”®å€¼å¯¹
     */
    public V remove(Object key) {
        int hash = hash(key);
        int index = indexFor(hash, table.length);
        Entry<K, V> prev = null;
        Entry<K, V> e = table[index];
        
        while (e != null) {
            Entry<K, V> next = e.next;
            if (e.hashCode == hash && Objects.equals(e.key, key)) {
                modCount++;
                size--;
                if (prev == null) {
                    table[index] = next;
                } else {
                    prev.next = next;
                }
                return e.value;
            }
            prev = e;
            e = next;
        }
        
        return null;
    }
    
    /**
     * æ‰©å®¹
     */
    @SuppressWarnings("unchecked")
    private void resize(int newCapacity) {
        Entry<K, V>[] oldTable = table;
        int oldCapacity = oldTable.length;
        
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }
        
        Entry<K, V>[] newTable = new Entry[newCapacity];
        transfer(newTable);
        table = newTable;
        threshold = (int) (newCapacity * loadFactor);
    }
    
    /**
     * æ•°æ®è½¬ç§»åˆ°æ–°è¡¨
     */
    private void transfer(Entry<K, V>[] newTable) {
        Entry<K, V>[] src = table;
        int newCapacity = newTable.length;
        
        for (int j = 0; j < src.length; j++) {
            Entry<K, V> e = src[j];
            if (e != null) {
                src[j] = null;
                do {
                    Entry<K, V> next = e.next;
                    int i = indexFor(e.hashCode, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                } while (e != null);
            }
        }
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦åŒ…å«é”®
     */
    public boolean containsKey(Object key) {
        return get(key) != null;
    }
    
    /**
     * æ£€æŸ¥æ˜¯å¦åŒ…å«å€¼
     */
    public boolean containsValue(Object value) {
        for (Entry<K, V> entry : table) {
            for (Entry<K, V> e = entry; e != null; e = e.next) {
                if (Objects.equals(value, e.value)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * æ¸…ç©ºå“ˆå¸Œè¡¨
     */
    public void clear() {
        modCount++;
        Arrays.fill(table, null);
        size = 0;
    }
    
    /**
     * è·å–æ‰€æœ‰é”®çš„é›†åˆ
     */
    public Set<K> keySet() {
        return new KeySet();
    }
    
    /**
     * è·å–æ‰€æœ‰å€¼çš„é›†åˆ
     */
    public Collection<V> values() {
        return new Values();
    }
    
    /**
     * è·å–æ‰€æœ‰æ¡ç›®çš„é›†åˆ
     */
    public Set<Entry<K, V>> entrySet() {
        return new EntrySet();
    }
    
    // åŸºæœ¬å±æ€§
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
    public double getLoadFactor() { return (double) size / table.length; }
    public int getCapacity() { return table.length; }
    
    /**
     * è¿­ä»£å™¨å®ç°
     */
    @Override
    public Iterator<Entry<K, V>> iterator() {
        return new EntryIterator();
    }
    
    private class EntryIterator implements Iterator<Entry<K, V>> {
        private Entry<K, V> next;        // ä¸‹ä¸€ä¸ªè¿”å›çš„æ¡ç›®
        private int expectedModCount;     // æœŸæœ›çš„ä¿®æ”¹æ¬¡æ•°
        private int index;               // å½“å‰æ¡¶ç´¢å¼•
        private Entry<K, V> current;     // å½“å‰æ¡ç›®
        
        EntryIterator() {
            expectedModCount = modCount;
            if (size > 0) {
                Entry<K, V>[] t = table;
                while (index < t.length && (next = t[index++]) == null) {
                    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªéç©ºæ¡¶
                }
            }
        }
        
        @Override
        public boolean hasNext() {
            return next != null;
        }
        
        @Override
        public Entry<K, V> next() {
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            Entry<K, V> e = next;
            if (e == null) {
                throw new NoSuchElementException();
            }
            
            if ((next = e.next) == null) {
                Entry<K, V>[] t = table;
                while (index < t.length && (next = t[index++]) == null) {
                    // æ‰¾åˆ°ä¸‹ä¸€ä¸ªéç©ºæ¡¶
                }
            }
            current = e;
            return e;
        }
        
        @Override
        public void remove() {
            if (current == null) {
                throw new IllegalStateException();
            }
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            Object k = current.key;
            current = null;
            HashTable.this.remove(k);
            expectedModCount = modCount;
        }
    }
    
    /**
     * é”®é›†åˆ
     */
    private class KeySet extends AbstractSet<K> {
        @Override
        public Iterator<K> iterator() {
            return new KeyIterator();
        }
        
        @Override
        public int size() {
            return HashTable.this.size;
        }
        
        @Override
        public boolean contains(Object o) {
            return containsKey(o);
        }
        
        @Override
        public boolean remove(Object o) {
            return HashTable.this.remove(o) != null;
        }
        
        @Override
        public void clear() {
            HashTable.this.clear();
        }
    }
    
    private class KeyIterator extends EntryIterator {
        @Override
        public K next() {
            return super.next().getKey();
        }
    }
    
    /**
     * å€¼é›†åˆ
     */
    private class Values extends AbstractCollection<V> {
        @Override
        public Iterator<V> iterator() {
            return new ValueIterator();
        }
        
        @Override
        public int size() {
            return HashTable.this.size;
        }
        
        @Override
        public boolean contains(Object o) {
            return containsValue(o);
        }
        
        @Override
        public void clear() {
            HashTable.this.clear();
        }
    }
    
    private class ValueIterator extends EntryIterator {
        @Override
        public V next() {
            return super.next().getValue();
        }
    }
    
    /**
     * æ¡ç›®é›†åˆ
     */
    private class EntrySet extends AbstractSet<Entry<K, V>> {
        @Override
        public Iterator<Entry<K, V>> iterator() {
            return new EntryIterator();
        }
        
        @Override
        public boolean contains(Object o) {
            if (!(o instanceof Entry)) return false;
            Entry<?, ?> e = (Entry<?, ?>) o;
            Entry<K, V> candidate = getEntry(e.getKey());
            return candidate != null && candidate.equals(e);
        }
        
        @Override
        public boolean remove(Object o) {
            if (!(o instanceof Entry)) return false;
            Entry<?, ?> e = (Entry<?, ?>) o;
            return HashTable.this.remove(e.getKey()) != null;
        }
        
        @Override
        public int size() {
            return HashTable.this.size;
        }
        
        @Override
        public void clear() {
            HashTable.this.clear();
        }
    }
    
    /**
     * è·å–æ¡ç›®ï¼ˆå†…éƒ¨ä½¿ç”¨ï¼‰
     */
    private Entry<K, V> getEntry(Object key) {
        int hash = hash(key);
        int index = indexFor(hash, table.length);
        
        for (Entry<K, V> e = table[index]; e != null; e = e.next) {
            if (e.hashCode == hash && Objects.equals(e.key, key)) {
                return e;
            }
        }
        return null;
    }
}
```

### 4.2 çº¿ç¨‹å®‰å…¨å“ˆå¸Œè¡¨å®ç°


```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * çº¿ç¨‹å®‰å…¨çš„å“ˆå¸Œè¡¨å®ç°
 * ä½¿ç”¨è¯»å†™é”æé«˜å¹¶å‘æ€§èƒ½
 */
public class ConcurrentHashTable<K, V> {
    
    private static class Entry<K, V> {
        volatile K key;
        volatile V value;
        volatile Entry<K, V> next;
        final int hashCode;
        
        Entry(K key, V value, int hashCode) {
            this.key = key;
            this.value = value;
            this.hashCode = hashCode;
        }
    }
    
    private final int segmentCount;
    private final Segment<K, V>[] segments;
    private final int segmentMask;
    private final int segmentShift;
    
    /**
     * åˆ†æ®µé”å®ç°
     */
    private static class Segment<K, V> extends ReentrantReadWriteLock {
        private Entry<K, V>[] table;
        private int count;
        private int threshold;
        private final double loadFactor;
        
        @SuppressWarnings("unchecked")
        Segment(int initialCapacity, double loadFactor) {
            this.loadFactor = loadFactor;
            this.table = new Entry[initialCapacity];
            this.threshold = (int) (initialCapacity * loadFactor);
        }
        
        V get(Object key, int hash) {
            readLock().lock();
            try {
                Entry<K, V>[] tab = table;
                int index = hash & (tab.length - 1);
                Entry<K, V> e = tab[index];
                
                while (e != null) {
                    if (e.hashCode == hash && Objects.equals(key, e.key)) {
                        return e.value;
                    }
                    e = e.next;
                }
                return null;
            } finally {
                readLock().unlock();
            }
        }
        
        V put(K key, int hash, V value, boolean onlyIfAbsent) {
            writeLock().lock();
            try {
                Entry<K, V>[] tab = table;
                int index = hash & (tab.length - 1);
                Entry<K, V> first = tab[index];
                
                for (Entry<K, V> e = first; e != null; e = e.next) {
                    if (e.hashCode == hash && Objects.equals(key, e.key)) {
                        V oldValue = e.value;
                        if (!onlyIfAbsent) {
                            e.value = value;
                        }
                        return oldValue;
                    }
                }
                
                // æ·»åŠ æ–°èŠ‚ç‚¹
                Entry<K, V> newEntry = new Entry<>(key, value, hash);
                newEntry.next = first;
                tab[index] = newEntry;
                
                if (++count > threshold) {
                    rehash();
                }
                
                return null;
            } finally {
                writeLock().unlock();
            }
        }
        
        V remove(Object key, int hash) {
            writeLock().lock();
            try {
                Entry<K, V>[] tab = table;
                int index = hash & (tab.length - 1);
                Entry<K, V> first = tab[index];
                
                Entry<K, V> e = first;
                while (e != null && (e.hashCode != hash || !Objects.equals(key, e.key))) {
                    e = e.next;
                }
                
                if (e != null) {
                    // é‡æ–°æ„å»ºé“¾è¡¨ï¼ˆè·³è¿‡è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼‰
                    Entry<K, V> newFirst = null;
                    for (Entry<K, V> p = first; p != e; p = p.next) {
                        Entry<K, V> newEntry = new Entry<>(p.key, p.value, p.hashCode);
                        newEntry.next = newFirst;
                        newFirst = newEntry;
                    }
                    
                    // è¿æ¥å‰©ä½™èŠ‚ç‚¹
                    if (newFirst != null) {
                        Entry<K, V> tail = newFirst;
                        while (tail.next != null) {
                            tail = tail.next;
                        }
                        tail.next = e.next;
                        tab[index] = newFirst;
                    } else {
                        tab[index] = e.next;
                    }
                    
                    count--;
                    return e.value;
                }
                
                return null;
            } finally {
                writeLock().unlock();
            }
        }
        
        @SuppressWarnings("unchecked")
        private void rehash() {
            Entry<K, V>[] oldTable = table;
            int oldCapacity = oldTable.length;
            int newCapacity = oldCapacity * 2;
            
            Entry<K, V>[] newTable = new Entry[newCapacity];
            threshold = (int) (newCapacity * loadFactor);
            
            for (int i = 0; i < oldCapacity; i++) {
                Entry<K, V> e = oldTable[i];
                while (e != null) {
                    Entry<K, V> next = e.next;
                    int index = e.hashCode & (newCapacity - 1);
                    e.next = newTable[index];
                    newTable[index] = e;
                    e = next;
                }
            }
            
            table = newTable;
        }
        
        int size() {
            readLock().lock();
            try {
                return count;
            } finally {
                readLock().unlock();
            }
        }
    }
    
    @SuppressWarnings("unchecked")
    public ConcurrentHashTable(int initialCapacity, double loadFactor, int concurrencyLevel) {
        if (loadFactor <= 0 || initialCapacity < 0 || concurrencyLevel <= 0) {
            throw new IllegalArgumentException();
        }
        
        if (concurrencyLevel > 65536) {
            concurrencyLevel = 65536;
        }
        
        // æ‰¾åˆ°å¤§äºç­‰äºconcurrencyLevelçš„æœ€å°2çš„å¹‚æ¬¡
        int sshift = 0;
        int ssize = 1;
        while (ssize < concurrencyLevel) {
            ++sshift;
            ssize <<= 1;
        }
        
        this.segmentShift = 32 - sshift;
        this.segmentMask = ssize - 1;
        this.segmentCount = ssize;
        
        this.segments = new Segment[ssize];
        int segmentCapacity = initialCapacity / ssize;
        if (segmentCapacity * ssize < initialCapacity) {
            ++segmentCapacity;
        }
        
        for (int i = 0; i < segments.length; i++) {
            segments[i] = new Segment<>(segmentCapacity, loadFactor);
        }
    }
    
    public ConcurrentHashTable() {
        this(16, 0.75, 16);
    }
    
    private static int hash(Object key) {
        int h = key.hashCode();
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }
    
    private Segment<K, V> segmentFor(int hash) {
        return segments[(hash >>> segmentShift) & segmentMask];
    }
    
    public V get(Object key) {
        int hash = hash(key);
        return segmentFor(hash).get(key, hash);
    }
    
    public V put(K key, V value) {
        int hash = hash(key);
        return segmentFor(hash).put(key, hash, value, false);
    }
    
    public V putIfAbsent(K key, V value) {
        int hash = hash(key);
        return segmentFor(hash).put(key, hash, value, true);
    }
    
    public V remove(Object key) {
        int hash = hash(key);
        return segmentFor(hash).remove(key, hash);
    }
    
    public boolean containsKey(Object key) {
        return get(key) != null;
    }
    
    public int size() {
        int sum = 0;
        for (Segment<K, V> segment : segments) {
            sum += segment.size();
        }
        return sum;
    }
    
    public boolean isEmpty() {
        return size() == 0;
    }
}
```

### 4.3 ç‰¹æ®Šç”¨é€”å“ˆå¸Œè¡¨


```java
/**
 * LRUç¼“å­˜å“ˆå¸Œè¡¨
 * ç»“åˆå“ˆå¸Œè¡¨å’ŒåŒé“¾è¡¨å®ç°
 */
public class LRUCache<K, V> {
    
    private class Node {
        K key;
        V value;
        Node prev, next;
        
        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private final int capacity;
    private final Map<K, Node> map;
    private final Node head, tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<>();
        
        // åˆ›å»ºå“¨å…µèŠ‚ç‚¹
        this.head = new Node(null, null);
        this.tail = new Node(null, null);
        head.next = tail;
        tail.prev = head;
    }
    
    public V get(K key) {
        Node node = map.get(key);
        if (node == null) {
            return null;
        }
        
        // ç§»åŠ¨åˆ°å¤´éƒ¨
        moveToHead(node);
        return node.value;
    }
    
    public void put(K key, V value) {
        Node existing = map.get(key);
        
        if (existing != null) {
            // æ›´æ–°ç°æœ‰èŠ‚ç‚¹
            existing.value = value;
            moveToHead(existing);
        } else {
            // æ·»åŠ æ–°èŠ‚ç‚¹
            Node newNode = new Node(key, value);
            
            if (map.size() >= capacity) {
                // åˆ é™¤å°¾éƒ¨èŠ‚ç‚¹
                Node last = removeTail();
                map.remove(last.key);
            }
            
            map.put(key, newNode);
            addToHead(newNode);
        }
    }
    
    private void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    private Node removeTail() {
        Node last = tail.prev;
        removeNode(last);
        return last;
    }
    
    public int size() {
        return map.size();
    }
    
    public boolean isEmpty() {
        return map.isEmpty();
    }
}

/**
 * å¸ƒéš†è¿‡æ»¤å™¨
 * åŸºäºå¤šä¸ªå“ˆå¸Œå‡½æ•°çš„æ¦‚ç‡æ•°æ®ç»“æ„
 */
public class BloomFilter<T> {
    
    private final BitSet bitSet;
    private final int bitSetSize;
    private final int numHashFunctions;
    private final int expectedElements;
    
    public BloomFilter(int expectedElements, double falsePositiveRate) {
        this.expectedElements = expectedElements;
        this.bitSetSize = optimalBitSetSize(expectedElements, falsePositiveRate);
        this.numHashFunctions = optimalNumHashFunctions(bitSetSize, expectedElements);
        this.bitSet = new BitSet(bitSetSize);
    }
    
    private static int optimalBitSetSize(int expectedElements, double falsePositiveRate) {
        return (int) (-expectedElements * Math.log(falsePositiveRate) / (Math.log(2) * Math.log(2)));
    }
    
    private static int optimalNumHashFunctions(int bitSetSize, int expectedElements) {
        return Math.max(1, (int) Math.round((double) bitSetSize / expectedElements * Math.log(2)));
    }
    
    public void add(T element) {
        int[] hashes = getHashes(element);
        for (int hash : hashes) {
            bitSet.set(Math.abs(hash) % bitSetSize);
        }
    }
    
    public boolean mightContain(T element) {
        int[] hashes = getHashes(element);
        for (int hash : hashes) {
            if (!bitSet.get(Math.abs(hash) % bitSetSize)) {
                return false;
            }
        }
        return true;
    }
    
    private int[] getHashes(T element) {
        int[] result = new int[numHashFunctions];
        int hash1 = element.hashCode();
        int hash2 = hash1 >>> 16;
        
        for (int i = 0; i < numHashFunctions; i++) {
            result[i] = hash1 + i * hash2;
        }
        
        return result;
    }
    
    public double getFalsePositiveRate() {
        int bitsSet = bitSet.cardinality();
        return Math.pow((double) bitsSet / bitSetSize, numHashFunctions);
    }
}

/**
 * ä¸€è‡´æ€§å“ˆå¸Œå®ç°
 * ç”¨äºåˆ†å¸ƒå¼ç³»ç»Ÿçš„è´Ÿè½½å‡è¡¡
 */
public class ConsistentHash<T> {
    
    private final TreeMap<Integer, T> circle = new TreeMap<>();
    private final int virtualNodes;
    
    public ConsistentHash(int virtualNodes, Collection<T> nodes) {
        this.virtualNodes = virtualNodes;
        for (T node : nodes) {
            addNode(node);
        }
    }
    
    public void addNode(T node) {
        for (int i = 0; i < virtualNodes; i++) {
            int hash = hash(node.toString() + ":" + i);
            circle.put(hash, node);
        }
    }
    
    public void removeNode(T node) {
        for (int i = 0; i < virtualNodes; i++) {
            int hash = hash(node.toString() + ":" + i);
            circle.remove(hash);
        }
    }
    
    public T getNode(String key) {
        if (circle.isEmpty()) {
            return null;
        }
        
        int hash = hash(key);
        Map.Entry<Integer, T> entry = circle.ceilingEntry(hash);
        
        if (entry == null) {
            entry = circle.firstEntry();
        }
        
        return entry.getValue();
    }
    
    private int hash(String key) {
        // ä½¿ç”¨FNVå“ˆå¸Œç®—æ³•
        final int p = 16777619;
        int hash = (int) 2166136261L;
        
        for (byte b : key.getBytes()) {
            hash = (hash ^ b) * p;
        }
        
        hash += hash << 13;
        hash ^= hash >> 7;
        hash += hash << 3;
        hash ^= hash >> 17;
        hash += hash << 5;
        
        return Math.abs(hash);
    }
    
    public void printDistribution(String[] keys) {
        Map<T, Integer> distribution = new HashMap<>();
        
        for (String key : keys) {
            T node = getNode(key);
            distribution.put(node, distribution.getOrDefault(node, 0) + 1);
        }
        
        System.out.println("=== ä¸€è‡´æ€§å“ˆå¸Œåˆ†å¸ƒ ===");
        for (Map.Entry<T, Integer> entry : distribution.entrySet()) {
            double percentage = 100.0 * entry.getValue() / keys.length;
            System.out.println(entry.getKey() + ": " + entry.getValue() + 
                             " (" + String.format("%.1f", percentage) + "%)");
        }
    }
}
```

---

## 5. ğŸ“Š ç®—æ³•åˆ†æ


### 5.1 æ€§èƒ½åˆ†æ


#### 5.1.1 æ—¶é—´å¤æ‚åº¦

```
åŸºæœ¬æ“ä½œï¼ˆç†æƒ³æƒ…å†µï¼‰ï¼š
- æ’å…¥ï¼šO(1)
- æŸ¥æ‰¾ï¼šO(1)
- åˆ é™¤ï¼šO(1)
- æ›´æ–°ï¼šO(1)

å¹³å‡æƒ…å†µï¼ˆè´Ÿè½½å› å­ Î±ï¼‰ï¼š
- é“¾åœ°å€æ³•ï¼šO(1 + Î±)
- å¼€æ”¾å®šå€æ³•ï¼šO(1/(1-Î±))

æœ€åæƒ…å†µï¼š
- æ‰€æœ‰é”®æ˜ å°„åˆ°åŒä¸€ä½ç½®ï¼šO(n)
- å¼€æ”¾å®šå€æ³•è¡¨æ»¡ï¼šO(n)

æ‰©å®¹æ“ä½œï¼š
- å•æ¬¡æ‰©å®¹ï¼šO(n)
- æ‘Šè¿˜å¤æ‚åº¦ï¼šO(1)
```

#### 5.1.2 ç©ºé—´å¤æ‚åº¦

```
å­˜å‚¨å¼€é”€ï¼š
- è¡¨ç©ºé—´ï¼šO(m)ï¼Œmä¸ºè¡¨å¤§å°
- æ•°æ®ç©ºé—´ï¼šO(n)ï¼Œnä¸ºå…ƒç´ ä¸ªæ•°
- æŒ‡é’ˆå¼€é”€ï¼šé“¾åœ°å€æ³•éœ€è¦é¢å¤–æŒ‡é’ˆ

ç©ºé—´åˆ©ç”¨ç‡ï¼š
- è´Ÿè½½å› å­ Î± = n/m
- é€šå¸¸ä¿æŒ Î± âˆˆ [0.5, 0.75]
- ç©ºé—´æ•ˆç‡ = Î±

å†…å­˜å±€éƒ¨æ€§ï¼š
- å¼€æ”¾å®šå€æ³•ï¼šè¿ç»­å†…å­˜ï¼Œç¼“å­˜å‹å¥½
- é“¾åœ°å€æ³•ï¼šåˆ†æ•£å†…å­˜ï¼Œç¼“å­˜ä¸å‹å¥½
```

### 5.2 å¹¶å‘æ€§èƒ½åˆ†æ


```
å¹¶å‘æ§åˆ¶å¼€é”€ï¼š
1. å…¨è¡¨é”ï¼š
   - è¯»å†™äº’æ–¥ï¼Œå¹¶å‘åº¦ä½
   - å®ç°ç®€å•ï¼Œä¸€è‡´æ€§å¼º

2. åˆ†æ®µé”ï¼š
   - æé«˜å¹¶å‘åº¦ï¼ˆå¹¶å‘åº¦ = æ®µæ•°ï¼‰
   - å¤æ‚åº¦å¢åŠ 

3. æ— é”è®¾è®¡ï¼š
   - æœ€é«˜å¹¶å‘æ€§èƒ½
   - å®ç°å¤æ‚ï¼ŒABAé—®é¢˜

æ€§èƒ½æµ‹è¯•æ•°æ®ï¼ˆå‚è€ƒå€¼ï¼‰ï¼š
- å•çº¿ç¨‹ï¼š100ä¸‡æ¬¡æ“ä½œ/ç§’
- å…¨è¡¨é”ï¼š10ä¸‡æ¬¡æ“ä½œ/ç§’
- åˆ†æ®µé”ï¼ˆ16æ®µï¼‰ï¼š80ä¸‡æ¬¡æ“ä½œ/ç§’
- æ— é”è®¾è®¡ï¼š150ä¸‡æ¬¡æ“ä½œ/ç§’
```

### 5.3 å†…å­˜ä½¿ç”¨åˆ†æ


```
å†…å­˜å¼€é”€è¯¦ç»†åˆ†æï¼š

å¯¹è±¡å¤´å¼€é”€ï¼š
- Javaå¯¹è±¡å¤´ï¼š8-16å­—èŠ‚
- æ•°ç»„å¤´ï¼š12-16å­—èŠ‚

æŒ‡é’ˆå¼€é”€ï¼š
- 64ä½ç³»ç»Ÿï¼š8å­—èŠ‚/æŒ‡é’ˆ
- å‹ç¼©æŒ‡é’ˆï¼š4å­—èŠ‚/æŒ‡é’ˆ

é“¾åœ°å€æ³•å¼€é”€ï¼š
- æ¯ä¸ªèŠ‚ç‚¹ï¼šå¯¹è±¡å¤´ + æ•°æ® + nextæŒ‡é’ˆ
- æ€»å¼€é”€ï¼šn Ã— (16 + æ•°æ®å¤§å° + 8)

å¼€æ”¾å®šå€æ³•å¼€é”€ï¼š
- æ•°ç»„å…ƒç´ ï¼šæ•°æ® + åˆ é™¤æ ‡è®°
- æ€»å¼€é”€ï¼šm Ã— (æ•°æ®å¤§å° + 1)

å®é™…æ¡ˆä¾‹ï¼ˆå­˜å‚¨1Mä¸ªStringé”®å€¼å¯¹ï¼‰ï¼š
- é“¾åœ°å€æ³•ï¼šçº¦200MB
- å¼€æ”¾å®šå€æ³•ï¼šçº¦150MB
- Java HashMapï¼šçº¦180MB
```

---

## 6. ğŸ¯ å…¸å‹åº”ç”¨


### 6.1 ç¼–ç¨‹è¯­è¨€å†…ç½®å®ç°

- **Java**ï¼šHashMapã€Hashtableã€ConcurrentHashMap
- **Python**ï¼šdictå†…ç½®å­—å…¸
- **C++**ï¼šunordered_mapã€unordered_set
- **JavaScript**ï¼šObjectã€Map
- **Go**ï¼šmapå†…ç½®ç±»å‹

### 6.2 æ•°æ®åº“ç³»ç»Ÿ

- **ç´¢å¼•ç»“æ„**ï¼šå“ˆå¸Œç´¢å¼•åŠ é€ŸæŸ¥è¯¢
- **ç¼“å†²æ± **ï¼šé¡µé¢ç¼“å­˜ç®¡ç†
- **è¿æ¥æ± **ï¼šæ•°æ®åº“è¿æ¥å¤ç”¨
- **æŸ¥è¯¢ä¼˜åŒ–**ï¼šè¿æ¥ç®—æ³•ä¸­çš„å“ˆå¸Œè¿æ¥

### 6.3 åˆ†å¸ƒå¼ç³»ç»Ÿ

- **ç¼“å­˜ç³»ç»Ÿ**ï¼šRedisã€Memcached
- **è´Ÿè½½å‡è¡¡**ï¼šä¸€è‡´æ€§å“ˆå¸Œåˆ†å¸ƒ
- **åˆ†å¸ƒå¼å­˜å‚¨**ï¼šæ•°æ®åˆ†ç‰‡å’Œå®šä½
- **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šæ¶ˆæ¯è·¯ç”±å’Œåˆ†å‘

### 6.4 ç®—æ³•ä¼˜åŒ–

- **å»é‡æ£€æµ‹**ï¼šå¿«é€Ÿæ£€æµ‹é‡å¤å…ƒç´ 
- **è®¡æ•°ç»Ÿè®¡**ï¼šé¢‘ç‡ç»Ÿè®¡å’Œæ’åº
- **é›†åˆè¿ç®—**ï¼šäº¤é›†ã€å¹¶é›†ã€å·®é›†è®¡ç®—
- **å›¾ç®—æ³•**ï¼šé‚»æ¥è¡¨è¡¨ç¤ºå’Œéå†

---

## 7. ğŸ“‹ æ€»ç»“


### 7.1 æ ¸å¿ƒè¦ç‚¹

1. **ğŸ”¸ è®¾è®¡å¹³è¡¡**ï¼šæ—¶é—´ã€ç©ºé—´ã€å¤æ‚åº¦çš„ç»¼åˆæƒè¡¡
2. **ğŸ”¸ åŠ¨æ€è°ƒæ•´**ï¼šè´Ÿè½½å› å­æ§åˆ¶å’Œè‡ªåŠ¨æ‰©å®¹æœºåˆ¶
3. **ğŸ”¸ å¹¶å‘å®‰å…¨**ï¼šæ ¹æ®åº”ç”¨éœ€æ±‚é€‰æ‹©åˆé€‚çš„å¹¶å‘ç­–ç•¥
4. **ğŸ”¸ å®ç°ç»†èŠ‚**ï¼šå“ˆå¸Œå‡½æ•°ã€ç¢°æ’å¤„ç†ã€å†…å­˜ç®¡ç†çš„ä¼˜åŒ–
5. **ğŸ”¸ åº”ç”¨å¹¿æ³›**ï¼šç°ä»£è®¡ç®—æœºç³»ç»Ÿçš„åŸºç¡€æ•°æ®ç»“æ„

### 7.2 è®¾è®¡å†³ç­–æŒ‡å—

- **å“ˆå¸Œå‡½æ•°é€‰æ‹©**ï¼š
  - ç®€å•å¿«é€Ÿ vs åˆ†å¸ƒå‡åŒ€
  - é€šç”¨æ€§ vs ä¸“ç”¨ä¼˜åŒ–
  - å®‰å…¨æ€§è¦æ±‚

- **ç¢°æ’å¤„ç†ç­–ç•¥**ï¼š
  - é“¾åœ°å€æ³•ï¼šå®ç°ç®€å•ï¼Œé€‚åˆé«˜è´Ÿè½½
  - å¼€æ”¾å®šå€æ³•ï¼šå†…å­˜æ•ˆç‡é«˜ï¼Œé€‚åˆç¼“å­˜æ•æ„Ÿ

- **å¹¶å‘æ§åˆ¶æ–¹å¼**ï¼š
  - è¯»å¤šå†™å°‘ï¼šè¯»å†™é”
  - é«˜å¹¶å‘ï¼šåˆ†æ®µé”æˆ–æ— é”
  - ç®€å•åœºæ™¯ï¼šå…¨è¡¨é”

### 7.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

- **å®¹é‡è§„åˆ’**ï¼šé¢„ä¼°æ•°æ®é‡ï¼Œé€‰æ‹©åˆé€‚åˆå§‹å®¹é‡
- **è´Ÿè½½ç›‘æ§**ï¼šåŠ¨æ€ç›‘æ§è´Ÿè½½å› å­ï¼ŒåŠæ—¶è°ƒæ•´
- **å†…å­˜ä¼˜åŒ–**ï¼šè€ƒè™‘å¯¹è±¡æ± ã€å†…å­˜å¯¹é½ç­‰æŠ€æœ¯
- **ç¼“å­˜å‹å¥½**ï¼šä¼˜åŒ–æ•°æ®å¸ƒå±€ï¼Œæé«˜ç¼“å­˜å‘½ä¸­ç‡

### 7.4 å®é™…åº”ç”¨è€ƒè™‘

- **æ•°æ®ç‰¹å¾**ï¼šé”®çš„åˆ†å¸ƒã€å¤§å°ã€è®¿é—®æ¨¡å¼
- **æ€§èƒ½è¦æ±‚**ï¼šå»¶è¿Ÿæ•æ„Ÿåº¦ã€ååé‡éœ€æ±‚
- **èµ„æºé™åˆ¶**ï¼šå†…å­˜é¢„ç®—ã€CPUæ€§èƒ½
- **ç»´æŠ¤æˆæœ¬**ï¼šå®ç°å¤æ‚åº¦ã€è°ƒè¯•éš¾åº¦





