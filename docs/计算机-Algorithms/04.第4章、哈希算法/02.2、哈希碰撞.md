---
title: 2ã€å“ˆå¸Œç¢°æ’
---
## ğŸ“š ç›®å½•

1. [ç®—æ³•æ¦‚è¿°](#1-ç®—æ³•æ¦‚è¿°)
2. [åŸºæœ¬æ€æƒ³](#2-åŸºæœ¬æ€æƒ³)
3. [ç®—æ³•åŸç†](#3-ç®—æ³•åŸç†)
4. [å®ç°æ–¹æ³•](#4-å®ç°æ–¹æ³•)
5. [ç®—æ³•åˆ†æ](#5-ç®—æ³•åˆ†æ)
6. [å…¸å‹åº”ç”¨](#6-å…¸å‹åº”ç”¨)
7. [æ€»ç»“](#7-æ€»ç»“)

---

## 1. ğŸ“– ç®—æ³•æ¦‚è¿°


### 1.1 å®šä¹‰

å“ˆå¸Œç¢°æ’ï¼ˆHash Collisionï¼‰æ˜¯æŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªä¸åŒçš„è¾“å…¥æ•°æ®é€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—åäº§ç”Ÿç›¸åŒå“ˆå¸Œå€¼çš„ç°è±¡ã€‚ç”±äºå“ˆå¸Œå‡½æ•°çš„è¾“å‡ºç©ºé—´æœ‰é™è€Œè¾“å…¥ç©ºé—´é€šå¸¸æ— é™æˆ–å¾ˆå¤§ï¼Œç¢°æ’æ˜¯ä¸å¯é¿å…çš„ã€‚

### 1.2 äº§ç”ŸåŸå› 

- **é¸½ç¬¼åŸç†**ï¼šè¾“å…¥ç©ºé—´å¤§äºè¾“å‡ºç©ºé—´æ—¶å¿…ç„¶å‘ç”Ÿç¢°æ’
- **å“ˆå¸Œå‡½æ•°å±€é™**ï¼šæ— æ³•åšåˆ°å®Œç¾çš„ä¸€ä¸€æ˜ å°„
- **æ•°æ®åˆ†å¸ƒ**ï¼šè¾“å…¥æ•°æ®çš„åˆ†å¸ƒç‰¹æ€§å½±å“ç¢°æ’æ¦‚ç‡
- **è¡¨å¤§å°é™åˆ¶**ï¼šå“ˆå¸Œè¡¨å¤§å°é€šå¸¸è¿œå°äºå¯èƒ½çš„é”®ç©ºé—´

### 1.3 æ ¸å¿ƒç‰¹å¾

- **ğŸ”¹ ä¸å¯é¿å…æ€§**ï¼šåœ¨æœ‰é™è¾“å‡ºç©ºé—´ä¸­å¿…ç„¶å‘ç”Ÿ
- **ğŸ”¹ æ¦‚ç‡æ€§**ï¼šå‘ç”Ÿé¢‘ç‡å–å†³äºå“ˆå¸Œå‡½æ•°è´¨é‡
- **ğŸ”¹ æ€§èƒ½å½±å“**ï¼šç›´æ¥å½±å“å“ˆå¸Œè¡¨çš„æ“ä½œæ•ˆç‡
- **ğŸ”¹ å¤„ç†å¤æ‚æ€§**ï¼šéœ€è¦é¢å¤–æœºåˆ¶æ¥è§£å†³å†²çª

### 1.4 ç¢°æ’ç±»å‹

- **å®Œå…¨ç¢°æ’**ï¼šä¸åŒé”®æ˜ å°„åˆ°å®Œå…¨ç›¸åŒçš„ä½ç½®
- **èšé›†ç¢°æ’**ï¼šå¤šä¸ªé”®æ˜ å°„åˆ°ç›¸é‚»ä½ç½®å½¢æˆèšé›†
- **å‘¨æœŸæ€§ç¢°æ’**ï¼šç‰¹å®šæ¨¡å¼çš„é”®äº§ç”Ÿè§„å¾‹æ€§ç¢°æ’
- **æ¶æ„ç¢°æ’**ï¼šæ•…æ„æ„é€ çš„è¾“å…¥å¯¼è‡´å¤§é‡ç¢°æ’

### 1.5 å½±å“å› ç´ 

- **å“ˆå¸Œå‡½æ•°è´¨é‡**ï¼šåˆ†å¸ƒå‡åŒ€æ€§å’Œéšæœºæ€§
- **è´Ÿè½½å› å­**ï¼šå­˜å‚¨å…ƒç´ æ•°é‡ä¸è¡¨å¤§å°çš„æ¯”å€¼
- **æ•°æ®ç‰¹å¾**ï¼šè¾“å…¥æ•°æ®çš„åˆ†å¸ƒå’Œæ¨¡å¼
- **è¡¨å¤§å°**ï¼šå“ˆå¸Œè¡¨çš„å®¹é‡å¤§å°

---

## 2. ğŸ’¡ åŸºæœ¬æ€æƒ³


### 2.1 æ ¸å¿ƒæ€æƒ³

å“ˆå¸Œç¢°æ’å¤„ç†çš„æ ¸å¿ƒæ€æƒ³æ˜¯"å†²çªè§£å†³"ï¼š
1. **ç¢°æ’æ£€æµ‹**ï¼šè¯†åˆ«ä½•æ—¶å‘ç”Ÿç¢°æ’
2. **å†²çªè§£å†³**ï¼šæä¾›æœºåˆ¶å¤„ç†ç¢°æ’æƒ…å†µ
3. **æ€§èƒ½ä¿æŒ**ï¼šå°½é‡ç»´æŒæ“ä½œçš„é«˜æ•ˆæ€§
4. **ç©ºé—´ç®¡ç†**ï¼šåˆç†åˆ©ç”¨å­˜å‚¨ç©ºé—´

### 2.2 ç¢°æ’å¤„ç†ç­–ç•¥åˆ†ç±»


**å¼€æ”¾å®šå€æ³•ï¼ˆOpen Addressingï¼‰ï¼š**
- æ‰€æœ‰å…ƒç´ å­˜å‚¨åœ¨å“ˆå¸Œè¡¨æœ¬èº«ä¸­
- å‘ç”Ÿç¢°æ’æ—¶å¯»æ‰¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç©ºä½ç½®
- åŒ…æ‹¬çº¿æ€§æ¢æµ‹ã€äºŒæ¬¡æ¢æµ‹ã€åŒé‡å“ˆå¸Œç­‰

**é“¾åœ°å€æ³•ï¼ˆSeparate Chainingï¼‰ï¼š**
- æ¯ä¸ªå“ˆå¸Œè¡¨ä½ç½®ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨æˆ–å…¶ä»–æ•°æ®ç»“æ„
- ç¢°æ’å…ƒç´ å­˜å‚¨åœ¨åŒä¸€ä½ç½®çš„é“¾è¡¨ä¸­
- ç®€å•æ˜“å®ç°ï¼Œå¤„ç†ç¢°æ’çµæ´»

### 2.3 ç¢°æ’å¤„ç†ç¤ºä¾‹

ä»¥ç®€å•çš„å“ˆå¸Œè¡¨ä¸ºä¾‹ï¼Œè¡¨å¤§å°ä¸º7ï¼Œä½¿ç”¨h(k) = k mod 7

```
æ’å…¥åºåˆ—ï¼š[10, 22, 31, 4, 15, 28, 17, 88, 59]

å“ˆå¸Œå€¼è®¡ç®—ï¼š
10 mod 7 = 3
22 mod 7 = 1  
31 mod 7 = 3  â† ä¸10ç¢°æ’
4  mod 7 = 4
15 mod 7 = 1  â† ä¸22ç¢°æ’
28 mod 7 = 0
17 mod 7 = 3  â† ä¸10,31ç¢°æ’
88 mod 7 = 4  â† ä¸4ç¢°æ’
59 mod 7 = 3  â† ä¸10,31,17ç¢°æ’

é“¾åœ°å€æ³•å¤„ç†ç»“æœï¼š
ä½ç½®0: [28]
ä½ç½®1: [22] -> [15]
ä½ç½®2: []
ä½ç½®3: [10] -> [31] -> [17] -> [59]
ä½ç½®4: [4] -> [88]
ä½ç½®5: []
ä½ç½®6: []

çº¿æ€§æ¢æµ‹æ³•å¤„ç†ç»“æœï¼š
ä½ç½®0: 28
ä½ç½®1: 22
ä½ç½®2: 15  â† 15åœ¨ä½ç½®1ç¢°æ’ï¼Œæ¢æµ‹åˆ°ä½ç½®2
ä½ç½®3: 10
ä½ç½®4: 4
ä½ç½®5: 31  â† 31åœ¨ä½ç½®3ç¢°æ’ï¼Œæ¢æµ‹åˆ°ä½ç½®5
ä½ç½®6: 17  â† 17åœ¨ä½ç½®3ç¢°æ’ï¼Œæ¢æµ‹åˆ°ä½ç½®6
```

---

## 3. âš™ï¸ ç®—æ³•åŸç†


### 3.1 ç¢°æ’æ¦‚ç‡åˆ†æ


#### 3.1.1 ç”Ÿæ—¥æ‚–è®º

```
åœ¨å¤§å°ä¸ºmçš„å“ˆå¸Œè¡¨ä¸­ï¼Œæ’å…¥nä¸ªéšæœºé”®ï¼š
ç¢°æ’æ¦‚ç‡ â‰ˆ 1 - e^(-nÂ²/2m)

å½“ n â‰ˆ âˆš(1.2m) æ—¶ï¼Œç¢°æ’æ¦‚ç‡çº¦ä¸º50%
å½“ n â‰ˆ âˆš(2ln2 Ã— m) â‰ˆ 1.18âˆšm æ—¶ï¼Œç¢°æ’æ¦‚ç‡çº¦ä¸º50%

ç¤ºä¾‹ï¼š
- è¡¨å¤§å° m = 365ï¼ˆå¤©æ•°ï¼‰
- å½“ n = 23 äººæ—¶ï¼Œè‡³å°‘ä¸¤äººåŒä¸€å¤©ç”Ÿæ—¥çš„æ¦‚ç‡ > 50%
- å½“ n = 50 äººæ—¶ï¼Œæ¦‚ç‡ > 97%
```

#### 3.1.2 è´Ÿè½½å› å­ä¸ç¢°æ’

```
è´Ÿè½½å› å­ Î± = n/mï¼ˆnä¸ªå…ƒç´ ï¼Œmä¸ªä½ç½®ï¼‰

ç†è®ºåˆ†æï¼š
- Î± = 0.5ï¼šå¹³å‡æ¯ä¸ªéç©ºä½ç½®æœ‰2ä¸ªå…ƒç´ 
- Î± = 0.75ï¼šå¤§çº¦1/4çš„ä½ç½®ç©ºé—²
- Î± = 1.0ï¼šå¹³å‡æ¯ä¸ªä½ç½®æœ‰1ä¸ªå…ƒç´ 
- Î± > 1.0ï¼šå¿…ç„¶æœ‰ä½ç½®åŒ…å«å¤šä¸ªå…ƒç´ 

æ€§èƒ½å½±å“ï¼š
- é“¾åœ°å€æ³•ï¼šå¹³å‡æŸ¥æ‰¾é•¿åº¦ â‰ˆ 1 + Î±/2
- çº¿æ€§æ¢æµ‹ï¼šå¹³å‡æŸ¥æ‰¾é•¿åº¦ â‰ˆ (1 + 1/(1-Î±)Â²)/2
```

### 3.2 å¼€æ”¾å®šå€æ³•


#### 3.2.1 çº¿æ€§æ¢æµ‹ï¼ˆLinear Probingï¼‰

```
æ¢æµ‹åºåˆ—ï¼šh(k), h(k)+1, h(k)+2, ..., h(k)+i (mod m)

ä¼˜ç‚¹ï¼š
- å®ç°ç®€å•
- ç¼“å­˜æ€§èƒ½å¥½ï¼ˆè¿ç»­å†…å­˜è®¿é—®ï¼‰
- ç©ºé—´åˆ©ç”¨ç‡é«˜

ç¼ºç‚¹ï¼š
- å®¹æ˜“å½¢æˆèšé›†ï¼ˆPrimary Clusteringï¼‰
- åˆ é™¤æ“ä½œå¤æ‚
- è´Ÿè½½å› å­é«˜æ—¶æ€§èƒ½æ€¥å‰§ä¸‹é™

æ•°å­¦åˆ†æï¼š
æˆåŠŸæŸ¥æ‰¾çš„æœŸæœ›æ¢æµ‹æ¬¡æ•°ï¼š(1 + 1/(1-Î±))/2
å¤±è´¥æŸ¥æ‰¾çš„æœŸæœ›æ¢æµ‹æ¬¡æ•°ï¼š(1 + 1/(1-Î±)Â²)/2
```

#### 3.2.2 äºŒæ¬¡æ¢æµ‹ï¼ˆQuadratic Probingï¼‰

```
æ¢æµ‹åºåˆ—ï¼šh(k), h(k)+1Â², h(k)+2Â², ..., h(k)+iÂ² (mod m)

ä¼˜ç‚¹ï¼š
- å‡å°‘äº†ä¸€æ¬¡èšé›†é—®é¢˜
- æ€§èƒ½æ¯”çº¿æ€§æ¢æµ‹å¥½

ç¼ºç‚¹ï¼š
- å¯èƒ½äº§ç”ŸäºŒæ¬¡èšé›†ï¼ˆSecondary Clusteringï¼‰
- ä¸èƒ½ä¿è¯éå†æ•´ä¸ªè¡¨
- è¡¨å¤§å°éœ€è¦ç‰¹æ®Šé€‰æ‹©ï¼ˆå¦‚è´¨æ•°ï¼‰

æ”¹è¿›å½¢å¼ï¼š
h(k, i) = (h(k) + câ‚i + câ‚‚iÂ²) mod m
å…¶ä¸­ câ‚, câ‚‚ ä¸ºå¸¸æ•°
```

#### 3.2.3 åŒé‡å“ˆå¸Œï¼ˆDouble Hashingï¼‰

```
æ¢æµ‹åºåˆ—ï¼š(hâ‚(k) + iÃ—hâ‚‚(k)) mod m

ä¸¤ä¸ªå“ˆå¸Œå‡½æ•°ï¼š
- hâ‚(k)ï¼šä¸»å“ˆå¸Œå‡½æ•°
- hâ‚‚(k)ï¼šè¾…åŠ©å“ˆå¸Œå‡½æ•°ï¼ˆæ­¥é•¿ï¼‰

è¦æ±‚ï¼š
- hâ‚‚(k) ä¸ m äº’è´¨
- hâ‚‚(k) â‰  0

ç¤ºä¾‹ï¼š
hâ‚(k) = k mod m
hâ‚‚(k) = 1 + (k mod (m-1))

ä¼˜ç‚¹ï¼š
- é¿å…äº†ä¸€æ¬¡å’ŒäºŒæ¬¡èšé›†
- æ¢æµ‹åºåˆ—æ›´åŠ éšæœº
- æ€§èƒ½æ¥è¿‘ç†æƒ³çš„å‡åŒ€å“ˆå¸Œ

ç¼ºç‚¹ï¼š
- è®¡ç®—å¼€é”€è¾ƒå¤§
- å®ç°å¤æ‚åº¦é«˜
```

### 3.3 é“¾åœ°å€æ³•


#### 3.3.1 åŸºæœ¬é“¾è¡¨

```
æ•°æ®ç»“æ„ï¼š
æ¯ä¸ªå“ˆå¸Œè¡¨ä½ç½®ç»´æŠ¤ä¸€ä¸ªå•é“¾è¡¨

æ“ä½œå¤æ‚åº¦ï¼š
- æ’å…¥ï¼šO(1)ï¼ˆå¤´æ’æ³•ï¼‰
- æŸ¥æ‰¾ï¼šO(é“¾é•¿) = O(1 + Î±)
- åˆ é™¤ï¼šO(é“¾é•¿) = O(1 + Î±)

ä¼˜ç‚¹ï¼š
- å®ç°ç®€å•
- åˆ é™¤æ“ä½œç®€å•
- å¯¹è´Ÿè½½å› å­ä¸æ•æ„Ÿ

ç¼ºç‚¹ï¼š
- éœ€è¦é¢å¤–æŒ‡é’ˆç©ºé—´
- ç¼“å­˜æ€§èƒ½è¾ƒå·®
- æœ€åæƒ…å†µé€€åŒ–ä¸ºé“¾è¡¨
```

#### 3.3.2 ä¼˜åŒ–å˜ä½“

```
å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼š
- å½“é“¾é•¿è¶…è¿‡é˜ˆå€¼æ—¶è½¬æ¢ä¸ºå¹³è¡¡æ ‘
- ä¿è¯æœ€åæƒ…å†µ O(log n) æ€§èƒ½
- Java 8 HashMapçš„å®ç°ç­–ç•¥

çº¢é»‘æ ‘ä¼˜åŒ–ï¼š
- é“¾é•¿ > 8 æ—¶è½¬ä¸ºçº¢é»‘æ ‘
- é“¾é•¿ < 6 æ—¶è½¬å›é“¾è¡¨
- é¿å…é¢‘ç¹è½¬æ¢çš„å¼€é”€

æœ‰åºé“¾è¡¨ï¼š
- ä¿æŒé“¾è¡¨æœ‰åº
- æŸ¥æ‰¾å¤±è´¥æ—¶å¯ä»¥æå‰ç»ˆæ­¢
- ç•¥å¾®å¢åŠ æ’å…¥å¼€é”€
```

### 3.4 å†å“ˆå¸Œï¼ˆRehashingï¼‰


#### 3.4.1 åŠ¨æ€æ‰©å®¹

```
æ‰©å®¹æ¡ä»¶ï¼š
- è´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼ï¼ˆé€šå¸¸0.75ï¼‰
- ç¢°æ’æ¬¡æ•°è¿‡å¤š
- æ€§èƒ½ä¸‹é™æ˜æ˜¾

æ‰©å®¹è¿‡ç¨‹ï¼š
1. åˆ›å»ºæ–°çš„æ›´å¤§å“ˆå¸Œè¡¨ï¼ˆé€šå¸¸æ‰©å¤§2å€ï¼‰
2. é‡æ–°è®¡ç®—æ‰€æœ‰å…ƒç´ çš„å“ˆå¸Œå€¼
3. å°†å…ƒç´ è¿ç§»åˆ°æ–°è¡¨ä¸­
4. é‡Šæ”¾æ—§è¡¨ç©ºé—´

æ—¶é—´å¤æ‚åº¦ï¼š
- å•æ¬¡æ‰©å®¹ï¼šO(n)
- æ‘Šè¿˜å¤æ‚åº¦ï¼šO(1)
```

#### 3.4.2 æ¸è¿›å¼å†å“ˆå¸Œ

```
ä¸ºé¿å…ä¸€æ¬¡æ€§æ‰©å®¹çš„é•¿æ—¶é—´åœé¡¿ï¼š

å¢é‡è¿ç§»ï¼š
- æ¯æ¬¡æ“ä½œæ—¶è¿ç§»å°‘é‡å…ƒç´ 
- ä¿æŒä¸¤ä¸ªå“ˆå¸Œè¡¨å¹¶å­˜
- æŸ¥æ‰¾æ—¶éœ€è¦æ£€æŸ¥ä¸¤ä¸ªè¡¨

ä¸€è‡´æ€§å“ˆå¸Œï¼š
- åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„åº”ç”¨
- èŠ‚ç‚¹å¢å‡æ—¶æœ€å°åŒ–æ•°æ®è¿ç§»
- è™šæ‹ŸèŠ‚ç‚¹æŠ€æœ¯å¹³è¡¡è´Ÿè½½
```

---

## 4. ğŸ”¨ å®ç°æ–¹æ³•


### 4.1 é“¾åœ°å€æ³•å®ç°


```java
import java.util.*;

/**
 * é“¾åœ°å€æ³•å“ˆå¸Œè¡¨å®ç°
 */
public class ChainingHashTable<K, V> {
    
    private static class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> next;
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Entry<K, V>[] table;
    private int size;
    private int capacity;
    private static final double LOAD_FACTOR_THRESHOLD = 0.75;
    
    @SuppressWarnings("unchecked")
    public ChainingHashTable(int initialCapacity) {
        this.capacity = nextPrime(initialCapacity);
        this.table = new Entry[capacity];
        this.size = 0;
    }
    
    public ChainingHashTable() {
        this(16);
    }
    
    /**
     * å“ˆå¸Œå‡½æ•°
     */
    private int hash(K key) {
        if (key == null) return 0;
        return Math.abs(key.hashCode()) % capacity;
    }
    
    /**
     * æ’å…¥æˆ–æ›´æ–°
     */
    public V put(K key, V value) {
        int index = hash(key);
        Entry<K, V> entry = table[index];
        
        // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨
        while (entry != null) {
            if (Objects.equals(entry.key, key)) {
                V oldValue = entry.value;
                entry.value = value;
                return oldValue;
            }
            entry = entry.next;
        }
        
        // æ’å…¥æ–°å…ƒç´ ï¼ˆå¤´æ’æ³•ï¼‰
        Entry<K, V> newEntry = new Entry<>(key, value);
        newEntry.next = table[index];
        table[index] = newEntry;
        size++;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if (loadFactor() > LOAD_FACTOR_THRESHOLD) {
            resize();
        }
        
        return null;
    }
    
    /**
     * æŸ¥æ‰¾
     */
    public V get(K key) {
        int index = hash(key);
        Entry<K, V> entry = table[index];
        
        while (entry != null) {
            if (Objects.equals(entry.key, key)) {
                return entry.value;
            }
            entry = entry.next;
        }
        
        return null;
    }
    
    /**
     * åˆ é™¤
     */
    public V remove(K key) {
        int index = hash(key);
        Entry<K, V> entry = table[index];
        Entry<K, V> prev = null;
        
        while (entry != null) {
            if (Objects.equals(entry.key, key)) {
                if (prev == null) {
                    table[index] = entry.next;
                } else {
                    prev.next = entry.next;
                }
                size--;
                return entry.value;
            }
            prev = entry;
            entry = entry.next;
        }
        
        return null;
    }
    
    /**
     * æ‰©å®¹
     */
    @SuppressWarnings("unchecked")
    private void resize() {
        Entry<K, V>[] oldTable = table;
        capacity = nextPrime(capacity * 2);
        table = new Entry[capacity];
        size = 0;
        
        // é‡æ–°æ’å…¥æ‰€æœ‰å…ƒç´ 
        for (Entry<K, V> entry : oldTable) {
            while (entry != null) {
                put(entry.key, entry.value);
                entry = entry.next;
            }
        }
    }
    
    /**
     * è·å–é“¾é•¿åº¦åˆ†å¸ƒï¼ˆç”¨äºåˆ†æç¢°æ’æƒ…å†µï¼‰
     */
    public int[] getChainLengthDistribution() {
        int maxLength = 0;
        int[] lengths = new int[capacity];
        
        for (int i = 0; i < capacity; i++) {
            int length = 0;
            Entry<K, V> entry = table[i];
            while (entry != null) {
                length++;
                entry = entry.next;
            }
            lengths[i] = length;
            maxLength = Math.max(maxLength, length);
        }
        
        // ç»Ÿè®¡å„é•¿åº¦çš„æ¡¶æ•°é‡
        int[] distribution = new int[maxLength + 1];
        for (int length : lengths) {
            distribution[length]++;
        }
        
        return distribution;
    }
    
    private double loadFactor() {
        return (double) size / capacity;
    }
    
    private int nextPrime(int n) {
        while (!isPrime(n)) {
            n++;
        }
        return n;
    }
    
    private boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
    
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
}
```

### 4.2 å¼€æ”¾å®šå€æ³•å®ç°


```java
/**
 * å¼€æ”¾å®šå€æ³•å“ˆå¸Œè¡¨å®ç°ï¼ˆçº¿æ€§æ¢æµ‹ï¼‰
 */
public class OpenAddressingHashTable<K, V> {
    
    private static class Entry<K, V> {
        K key;
        V value;
        boolean deleted; // åˆ é™¤æ ‡è®°
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
            this.deleted = false;
        }
    }
    
    private Entry<K, V>[] table;
    private int size;
    private int capacity;
    private static final double LOAD_FACTOR_THRESHOLD = 0.5;
    
    @SuppressWarnings("unchecked")
    public OpenAddressingHashTable(int initialCapacity) {
        this.capacity = nextPrime(initialCapacity);
        this.table = new Entry[capacity];
        this.size = 0;
    }
    
    public OpenAddressingHashTable() {
        this(16);
    }
    
    /**
     * ä¸»å“ˆå¸Œå‡½æ•°
     */
    private int hash1(K key) {
        if (key == null) return 0;
        return Math.abs(key.hashCode()) % capacity;
    }
    
    /**
     * çº¿æ€§æ¢æµ‹
     */
    private int linearProbe(K key, boolean forInsertion) {
        int index = hash1(key);
        int originalIndex = index;
        
        while (table[index] != null) {
            if (!table[index].deleted && Objects.equals(table[index].key, key)) {
                return index; // æ‰¾åˆ°é”®
            }
            
            if (forInsertion && table[index].deleted) {
                return index; // æ‰¾åˆ°å¯æ’å…¥ä½ç½®
            }
            
            index = (index + 1) % capacity;
            
            // é¿å…æ— é™å¾ªç¯
            if (index == originalIndex) {
                break;
            }
        }
        
        return forInsertion ? index : -1;
    }
    
    /**
     * äºŒæ¬¡æ¢æµ‹
     */
    private int quadraticProbe(K key, boolean forInsertion) {
        int index = hash1(key);
        int i = 0;
        
        while (i < capacity) {
            int probeIndex = (index + i * i) % capacity;
            
            if (table[probeIndex] == null) {
                return forInsertion ? probeIndex : -1;
            }
            
            if (!table[probeIndex].deleted && Objects.equals(table[probeIndex].key, key)) {
                return probeIndex;
            }
            
            if (forInsertion && table[probeIndex].deleted) {
                return probeIndex;
            }
            
            i++;
        }
        
        return -1;
    }
    
    /**
     * åŒé‡å“ˆå¸Œ
     */
    private int doubleHash(K key, boolean forInsertion) {
        int hash1 = hash1(key);
        int hash2 = 1 + (Math.abs(key.hashCode()) % (capacity - 1));
        int index = hash1;
        int i = 0;
        
        while (i < capacity) {
            int probeIndex = (hash1 + i * hash2) % capacity;
            
            if (table[probeIndex] == null) {
                return forInsertion ? probeIndex : -1;
            }
            
            if (!table[probeIndex].deleted && Objects.equals(table[probeIndex].key, key)) {
                return probeIndex;
            }
            
            if (forInsertion && table[probeIndex].deleted) {
                return probeIndex;
            }
            
            i++;
        }
        
        return -1;
    }
    
    /**
     * æ’å…¥æˆ–æ›´æ–°
     */
    public V put(K key, V value) {
        if (loadFactor() > LOAD_FACTOR_THRESHOLD) {
            resize();
        }
        
        int index = linearProbe(key, true);
        
        if (index == -1) {
            throw new RuntimeException("å“ˆå¸Œè¡¨å·²æ»¡");
        }
        
        if (table[index] == null || table[index].deleted) {
            table[index] = new Entry<>(key, value);
            size++;
            return null;
        } else {
            V oldValue = table[index].value;
            table[index].value = value;
            return oldValue;
        }
    }
    
    /**
     * æŸ¥æ‰¾
     */
    public V get(K key) {
        int index = linearProbe(key, false);
        if (index != -1 && !table[index].deleted) {
            return table[index].value;
        }
        return null;
    }
    
    /**
     * åˆ é™¤ï¼ˆæ‡’æƒ°åˆ é™¤ï¼‰
     */
    public V remove(K key) {
        int index = linearProbe(key, false);
        if (index != -1 && !table[index].deleted) {
            table[index].deleted = true;
            size--;
            return table[index].value;
        }
        return null;
    }
    
    /**
     * æ‰©å®¹
     */
    @SuppressWarnings("unchecked")
    private void resize() {
        Entry<K, V>[] oldTable = table;
        capacity = nextPrime(capacity * 2);
        table = new Entry[capacity];
        size = 0;
        
        for (Entry<K, V> entry : oldTable) {
            if (entry != null && !entry.deleted) {
                put(entry.key, entry.value);
            }
        }
    }
    
    /**
     * åˆ†ææ¢æµ‹è·ç¦»åˆ†å¸ƒ
     */
    public void analyzeProbeDistances() {
        int[] probeDistances = new int[capacity];
        int totalProbes = 0;
        int maxProbes = 0;
        
        for (int i = 0; i < capacity; i++) {
            if (table[i] != null && !table[i].deleted) {
                int originalIndex = hash1(table[i].key);
                int distance = (i - originalIndex + capacity) % capacity;
                probeDistances[distance]++;
                totalProbes += distance;
                maxProbes = Math.max(maxProbes, distance);
            }
        }
        
        System.out.println("=== æ¢æµ‹è·ç¦»åˆ†æ ===");
        System.out.println("å¹³å‡æ¢æµ‹è·ç¦»: " + (double) totalProbes / size);
        System.out.println("æœ€å¤§æ¢æµ‹è·ç¦»: " + maxProbes);
        System.out.println("æ¢æµ‹è·ç¦»åˆ†å¸ƒ:");
        
        for (int i = 0; i <= Math.min(10, maxProbes); i++) {
            System.out.println("è·ç¦» " + i + ": " + probeDistances[i] + " ä¸ªå…ƒç´ ");
        }
    }
    
    private double loadFactor() {
        return (double) size / capacity;
    }
    
    private int nextPrime(int n) {
        while (!isPrime(n)) {
            n++;
        }
        return n;
    }
    
    private boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
    
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
}
```

### 4.3 ç¢°æ’åˆ†æå·¥å…·


```java
public class CollisionAnalyzer {
    
    /**
     * åˆ†æå“ˆå¸Œå‡½æ•°çš„ç¢°æ’æƒ…å†µ
     */
    public static void analyzeCollisions(String[] keys, int tableSize) {
        Map<Integer, List<String>> buckets = new HashMap<>();
        int totalCollisions = 0;
        int maxCollisions = 0;
        
        // ç»Ÿè®¡æ¯ä¸ªä½ç½®çš„é”®
        for (String key : keys) {
            int hash = Math.abs(key.hashCode()) % tableSize;
            buckets.computeIfAbsent(hash, k -> new ArrayList<>()).add(key);
        }
        
        // åˆ†æç¢°æ’æƒ…å†µ
        for (Map.Entry<Integer, List<String>> entry : buckets.entrySet()) {
            int collisions = entry.getValue().size() - 1;
            if (collisions > 0) {
                totalCollisions += collisions;
                maxCollisions = Math.max(maxCollisions, collisions);
            }
        }
        
        System.out.println("=== ç¢°æ’åˆ†ææŠ¥å‘Š ===");
        System.out.println("é”®æ€»æ•°: " + keys.length);
        System.out.println("è¡¨å¤§å°: " + tableSize);
        System.out.println("è´Ÿè½½å› å­: " + String.format("%.3f", (double) keys.length / tableSize));
        System.out.println("æ€»ç¢°æ’æ•°: " + totalCollisions);
        System.out.println("æœ€å¤§æ¡¶å¤§å°: " + (maxCollisions + 1));
        System.out.println("ç¢°æ’ç‡: " + String.format("%.2f%%", 100.0 * totalCollisions / keys.length));
        
        // æ˜¾ç¤ºç¢°æ’æœ€ä¸¥é‡çš„æ¡¶
        System.out.println("\nç¢°æ’æœ€ä¸¥é‡çš„æ¡¶:");
        buckets.entrySet().stream()
               .filter(e -> e.getValue().size() > 1)
               .sorted((a, b) -> Integer.compare(b.getValue().size(), a.getValue().size()))
               .limit(5)
               .forEach(e -> {
                   System.out.println("ä½ç½® " + e.getKey() + ": " + e.getValue().size() + " ä¸ªé”® " + e.getValue());
               });
    }
    
    /**
     * ç”Ÿæ—¥æ”»å‡»æµ‹è¯•
     */
    public static void birthdayAttackTest(int tableSize) {
        Random random = new Random();
        Set<Integer> seen = new HashSet<>();
        int count = 0;
        
        while (true) {
            int hash = random.nextInt(tableSize);
            count++;
            
            if (seen.contains(hash)) {
                break;
            }
            seen.add(hash);
        }
        
        double expected = Math.sqrt(Math.PI * tableSize / 2);
        
        System.out.println("=== ç”Ÿæ—¥æ”»å‡»æµ‹è¯• ===");
        System.out.println("è¡¨å¤§å°: " + tableSize);
        System.out.println("å®é™…ç¢°æ’æ­¥æ•°: " + count);
        System.out.println("ç†è®ºæœŸæœ›æ­¥æ•°: " + String.format("%.1f", expected));
        System.out.println("è¯¯å·®: " + String.format("%.1f%%", 100.0 * Math.abs(count - expected) / expected));
    }
    
    /**
     * æ¯”è¾ƒä¸åŒå“ˆå¸Œå‡½æ•°çš„ç¢°æ’æ€§èƒ½
     */
    public static void compareHashFunctions(String[] keys) {
        int tableSize = nextPrime(keys.length * 2);
        
        System.out.println("=== å“ˆå¸Œå‡½æ•°ç¢°æ’æ¯”è¾ƒ ===");
        
        // ç®€å•å–æ¨¡
        analyzeHashFunction("ç®€å•å–æ¨¡", keys, tableSize, key -> Math.abs(key.hashCode()) % tableSize);
        
        // ä¹˜æ³•å“ˆå¸Œ
        analyzeHashFunction("ä¹˜æ³•å“ˆå¸Œ", keys, tableSize, key -> {
            double A = (Math.sqrt(5) - 1) / 2;
            double product = Math.abs(key.hashCode()) * A;
            return (int) Math.floor(tableSize * (product - Math.floor(product)));
        });
        
        // å¤šé¡¹å¼å“ˆå¸Œ
        analyzeHashFunction("å¤šé¡¹å¼å“ˆå¸Œ", keys, tableSize, key -> {
            long hash = 0;
            for (char c : key.toCharArray()) {
                hash = (hash * 31 + c) % tableSize;
            }
            return (int) hash;
        });
    }
    
    private static void analyzeHashFunction(String name, String[] keys, int tableSize, 
                                          java.util.function.Function<String, Integer> hashFunc) {
        int[] buckets = new int[tableSize];
        for (String key : keys) {
            buckets[hashFunc.apply(key)]++;
        }
        
        // è®¡ç®—æ–¹å·®
        double mean = (double) keys.length / tableSize;
        double variance = 0;
        int maxBucket = 0;
        int emptyBuckets = 0;
        
        for (int count : buckets) {
            variance += Math.pow(count - mean, 2);
            maxBucket = Math.max(maxBucket, count);
            if (count == 0) emptyBuckets++;
        }
        variance /= tableSize;
        
        System.out.println(String.format("%s: æ–¹å·®=%.2f, æœ€å¤§æ¡¶=%d, ç©ºæ¡¶=%d", 
                                        name, variance, maxBucket, emptyBuckets));
    }
    
    private static int nextPrime(int n) {
        while (!isPrime(n)) n++;
        return n;
    }
    
    private static boolean isPrime(int n) {
        if (n < 2) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
}
```

---

## 5. ğŸ“Š ç®—æ³•åˆ†æ


### 5.1 æ€§èƒ½åˆ†æå¯¹æ¯”


#### 5.1.1 æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ

```
é“¾åœ°å€æ³•ï¼š
- å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1 + Î±)
- æœ€åæŸ¥æ‰¾æ—¶é—´ï¼šO(n)
- æ’å…¥æ—¶é—´ï¼šO(1)
- åˆ é™¤æ—¶é—´ï¼šO(1 + Î±)

çº¿æ€§æ¢æµ‹ï¼š
- å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1 + Î±Â²/(2(1-Î±)))
- æœ€åæŸ¥æ‰¾æ—¶é—´ï¼šO(n)
- å¯¹è´Ÿè½½å› å­æ•æ„Ÿï¼ŒÎ± > 0.7æ—¶æ€§èƒ½æ€¥å‰§ä¸‹é™

äºŒæ¬¡æ¢æµ‹ï¼š
- å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1 + Î±Â²/2)
- æ€§èƒ½ä¼˜äºçº¿æ€§æ¢æµ‹
- ä½†ä»å­˜åœ¨äºŒæ¬¡èšé›†é—®é¢˜

åŒé‡å“ˆå¸Œï¼š
- å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1/(1-Î±))
- æ¥è¿‘ç†æƒ³éšæœºå“ˆå¸Œæ€§èƒ½
- è®¡ç®—å¼€é”€è¾ƒå¤§
```

#### 5.1.2 ç©ºé—´å¤æ‚åº¦æ¯”è¾ƒ

```
é“¾åœ°å€æ³•ï¼š
- é¢å¤–æŒ‡é’ˆå¼€é”€ï¼šæ¯ä¸ªèŠ‚ç‚¹éœ€è¦æŒ‡é’ˆ
- ç©ºé—´åˆ©ç”¨ç‡ï¼šå¯ä»¥è¶…è¿‡100%
- å†…å­˜åˆ†æ•£ï¼šèŠ‚ç‚¹åˆ†æ•£åœ¨å †ä¸­

å¼€æ”¾å®šå€æ³•ï¼š
- æ— é¢å¤–æŒ‡é’ˆå¼€é”€
- ç©ºé—´åˆ©ç”¨ç‡ï¼šæœ€å¤š100%
- å†…å­˜è¿ç»­ï¼šæ›´å¥½çš„ç¼“å­˜æ€§èƒ½
```

### 5.2 è´Ÿè½½å› å­å½±å“åˆ†æ


```
å®éªŒæ•°æ®ï¼ˆåŸºäºç†è®ºå’Œæ¨¡æ‹Ÿï¼‰ï¼š

è´Ÿè½½å› å­ Î± = 0.5ï¼š
- é“¾åœ°å€æ³•å¹³å‡æŸ¥æ‰¾ï¼š1.25æ¬¡
- çº¿æ€§æ¢æµ‹å¹³å‡æŸ¥æ‰¾ï¼š1.5æ¬¡
- äºŒæ¬¡æ¢æµ‹å¹³å‡æŸ¥æ‰¾ï¼š1.4æ¬¡

è´Ÿè½½å› å­ Î± = 0.75ï¼š
- é“¾åœ°å€æ³•å¹³å‡æŸ¥æ‰¾ï¼š1.375æ¬¡
- çº¿æ€§æ¢æµ‹å¹³å‡æŸ¥æ‰¾ï¼š2.5æ¬¡
- äºŒæ¬¡æ¢æµ‹å¹³å‡æŸ¥æ‰¾ï¼š2.0æ¬¡

è´Ÿè½½å› å­ Î± = 0.9ï¼š
- é“¾åœ°å€æ³•å¹³å‡æŸ¥æ‰¾ï¼š1.45æ¬¡
- çº¿æ€§æ¢æµ‹å¹³å‡æŸ¥æ‰¾ï¼š5.5æ¬¡
- äºŒæ¬¡æ¢æµ‹å¹³å‡æŸ¥æ‰¾ï¼š3.2æ¬¡

ç»“è®ºï¼š
- é“¾åœ°å€æ³•å¯¹è´Ÿè½½å› å­ä¸æ•æ„Ÿ
- å¼€æ”¾å®šå€æ³•åœ¨é«˜è´Ÿè½½å› å­ä¸‹æ€§èƒ½ä¸‹é™æ˜æ˜¾
- å®é™…åº”ç”¨ä¸­å»ºè®®ä¿æŒ Î± < 0.75
```

### 5.3 ç¢°æ’æ¦‚ç‡æ•°å­¦åˆ†æ


```
åœ¨ç®€å•ä¸€è‡´å“ˆå¸Œå‡è®¾ä¸‹ï¼š

å•æ¬¡ç¢°æ’æ¦‚ç‡ï¼š
P(ä¸¤ä¸ªéšæœºé”®ç¢°æ’) = 1/m

kä¸ªé”®çš„ç¢°æ’æœŸæœ›ï¼š
E[ç¢°æ’æ•°] = C(k,2) Ã— (1/m) = k(k-1)/(2m)

è‡³å°‘ä¸€æ¬¡ç¢°æ’çš„æ¦‚ç‡ï¼š
P(è‡³å°‘ä¸€æ¬¡ç¢°æ’) = 1 - (m!)/(m^k Ã— (m-k)!)

è¿‘ä¼¼å…¬å¼ï¼ˆk << mï¼‰ï¼š
P(è‡³å°‘ä¸€æ¬¡ç¢°æ’) â‰ˆ 1 - e^(-kÂ²/(2m))

ç”Ÿæ—¥æ‚–è®ºä¸´ç•Œç‚¹ï¼š
å½“ k â‰ˆ âˆš(2ln2 Ã— m) â‰ˆ 1.18âˆšm æ—¶ï¼Œç¢°æ’æ¦‚ç‡ â‰ˆ 50%
```

---

## 6. ğŸ¯ å…¸å‹åº”ç”¨


### 6.1 ç³»ç»Ÿåº”ç”¨åœºæ™¯

- **æ•°æ®åº“ç´¢å¼•**ï¼šB+æ ‘ç´¢å¼•ä¸­çš„å“ˆå¸Œæ¡¶
- **ç¼“å­˜ç³»ç»Ÿ**ï¼šRedisã€Memcachedçš„å†…å­˜ç®¡ç†
- **ç¼–è¯‘å™¨**ï¼šç¬¦å·è¡¨çš„å†²çªå¤„ç†
- **ç½‘ç»œç³»ç»Ÿ**ï¼šè·¯ç”±è¡¨å’Œè¿æ¥è¡¨

### 6.2 å®‰å…¨ç›¸å…³åº”ç”¨

- **DoSæ”»å‡»é˜²æŠ¤**ï¼šé˜²æ­¢æ¶æ„æ„é€ çš„å“ˆå¸Œç¢°æ’
- **å¯†ç å­˜å‚¨**ï¼šåŠ ç›å“ˆå¸Œé¿å…å½©è™¹è¡¨æ”»å‡»
- **æ•°å­—ç­¾å**ï¼šç¢°æ’æŠ—æ€§ä¿è¯ç­¾åå®‰å…¨
- **åŒºå—é“¾**ï¼šå·¥ä½œé‡è¯æ˜ä¸­çš„å“ˆå¸Œç¢°æ’

### 6.3 ç®—æ³•ä¼˜åŒ–åº”ç”¨

- **å­—ç¬¦ä¸²åŒ¹é…**ï¼šRabin-Karpç®—æ³•çš„ç¢°æ’å¤„ç†
- **é‡å¤æ£€æµ‹**ï¼šæ–‡æ¡£å»é‡ä¸­çš„è¯¯åˆ¤å¤„ç†
- **åˆ†å¸ƒå¼ç³»ç»Ÿ**ï¼šä¸€è‡´æ€§å“ˆå¸Œçš„è™šæ‹ŸèŠ‚ç‚¹
- **è´Ÿè½½å‡è¡¡**ï¼šå“ˆå¸Œè´Ÿè½½å‡è¡¡çš„çƒ­ç‚¹å¤„ç†

---

## 7. ğŸ“‹ æ€»ç»“


### 7.1 æ ¸å¿ƒè¦ç‚¹

1. **ğŸ”¸ ç¢°æ’ä¸å¯é¿å…**ï¼šé¸½ç¬¼åŸç†å†³å®šäº†ç¢°æ’å¿…ç„¶å‘ç”Ÿ
2. **ğŸ”¸ å¤„ç†ç­–ç•¥é‡è¦**ï¼šé“¾åœ°å€æ³• vs å¼€æ”¾å®šå€æ³•å„æœ‰ä¼˜åŠ£
3. **ğŸ”¸ è´Ÿè½½å› å­å…³é”®**ï¼šç›´æ¥å½±å“æ€§èƒ½ï¼Œéœ€è¦åŠ¨æ€æ§åˆ¶
4. **ğŸ”¸ æ¦‚ç‡åˆ†ææŒ‡å¯¼**ï¼šç”Ÿæ—¥æ‚–è®ºç­‰ç†è®ºæŒ‡å¯¼è®¾è®¡å†³ç­–
5. **ğŸ”¸ å®é™…æ€§èƒ½æµ‹è¯•**ï¼šç†è®ºåˆ†æéœ€è¦å®éªŒéªŒè¯

### 7.2 é€‰æ‹©æŒ‡å¯¼åŸåˆ™

- **é“¾åœ°å€æ³•é€‚ç”¨åœºæ™¯**ï¼š
  - è´Ÿè½½å› å­å¯èƒ½è¾ƒé«˜
  - åˆ é™¤æ“ä½œé¢‘ç¹
  - å†…å­˜ä¸æ˜¯ä¸»è¦é™åˆ¶
  - å¯¹æœ€åæƒ…å†µæ€§èƒ½è¦æ±‚ä¸ä¸¥æ ¼

- **å¼€æ”¾å®šå€æ³•é€‚ç”¨åœºæ™¯**ï¼š
  - å†…å­˜ä½¿ç”¨æ•æ„Ÿ
  - ç¼“å­˜æ€§èƒ½é‡è¦
  - è´Ÿè½½å› å­å¯æ§åˆ¶åœ¨è¾ƒä½æ°´å¹³
  - åˆ é™¤æ“ä½œè¾ƒå°‘

### 7.3 ä¼˜åŒ–å»ºè®®

- **å“ˆå¸Œå‡½æ•°é€‰æ‹©**ï¼šé€‰æ‹©åˆ†å¸ƒå‡åŒ€çš„é«˜è´¨é‡å“ˆå¸Œå‡½æ•°
- **è¡¨å¤§å°è®¾è®¡**ï¼šä½¿ç”¨è´¨æ•°ä½œä¸ºè¡¨å¤§å°ï¼Œé¿å…å‘¨æœŸæ€§æ¨¡å¼
- **åŠ¨æ€è°ƒæ•´**ï¼šç›‘æ§è´Ÿè½½å› å­ï¼Œé€‚æ—¶æ‰©å®¹æˆ–ç¼©å®¹
- **æ··åˆç­–ç•¥**ï¼šç»“åˆå¤šç§æ–¹æ³•ï¼Œå¦‚Java 8çš„HashMapå®ç°

