---
title: 4ã€å“ˆå¸Œç®—æ³•çš„åº”ç”¨
---
## ğŸ“š ç›®å½•

1. [ç®—æ³•æ¦‚è¿°](#1-ç®—æ³•æ¦‚è¿°)
2. [åŸºæœ¬æ€æƒ³](#2-åŸºæœ¬æ€æƒ³)
3. [ç®—æ³•åŸç†](#3-ç®—æ³•åŸç†)
4. [å®ç°æ–¹æ³•](#4-å®ç°æ–¹æ³•)
5. [ç®—æ³•åˆ†æ](#5-ç®—æ³•åˆ†æ)
6. [å…¸å‹åº”ç”¨](#6-å…¸å‹åº”ç”¨)
7. [æ€»ç»“](#7-æ€»ç»“)

---

## 1. ğŸ“– ç®—æ³•æ¦‚è¿°


### 1.1 å®šä¹‰

å“ˆå¸Œç®—æ³•çš„åº”ç”¨æ˜¯æŒ‡å°†å“ˆå¸ŒæŠ€æœ¯è¿ç”¨åˆ°å„ç§å®é™…é—®é¢˜ä¸­ï¼Œé€šè¿‡å“ˆå¸Œå‡½æ•°çš„å¿«é€Ÿè®¡ç®—å’Œå‡åŒ€åˆ†å¸ƒç‰¹æ€§ï¼Œè§£å†³æ•°æ®æŸ¥æ‰¾ã€å»é‡ã€æ ¡éªŒã€å®‰å…¨è®¤è¯ç­‰é—®é¢˜ã€‚å“ˆå¸Œåº”ç”¨æ¶µç›–äº†ä»åŸºç¡€æ•°æ®ç»“æ„åˆ°å¤æ‚åˆ†å¸ƒå¼ç³»ç»Ÿçš„å„ä¸ªå±‚é¢ã€‚

### 1.2 åº”ç”¨åˆ†ç±»

- **æ•°æ®ç»“æ„åº”ç”¨**ï¼šå“ˆå¸Œè¡¨ã€é›†åˆã€ç¼“å­˜ç­‰
- **ç®—æ³•ä¼˜åŒ–åº”ç”¨**ï¼šå­—ç¬¦ä¸²åŒ¹é…ã€å›¾ç®—æ³•ã€åŠ¨æ€è§„åˆ’ç­‰
- **ç³»ç»Ÿåº”ç”¨**ï¼šæ•°æ®åº“ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œåè®®ç­‰
- **å®‰å…¨åº”ç”¨**ï¼šå¯†ç å­¦ã€æ•°å­—ç­¾åã€å®Œæ•´æ€§æ ¡éªŒç­‰
- **åˆ†å¸ƒå¼åº”ç”¨**ï¼šè´Ÿè½½å‡è¡¡ã€æ•°æ®åˆ†ç‰‡ã€ä¸€è‡´æ€§å“ˆå¸Œç­‰

### 1.3 æ ¸å¿ƒç‰¹å¾

- **ğŸ”¹ å¿«é€Ÿæ£€ç´¢**ï¼šO(1)å¹³å‡æ—¶é—´å¤æ‚åº¦
- **ğŸ”¹ ç©ºé—´æ•ˆç‡**ï¼šç´§å‡‘çš„æ•°æ®è¡¨ç¤º
- **ğŸ”¹ åˆ†å¸ƒå‡åŒ€**ï¼šæ•°æ®å‡åŒ€åˆ†æ•£å­˜å‚¨
- **ğŸ”¹ ç¡®å®šæ€§**ï¼šç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º
- **ğŸ”¹ å•å‘æ€§**ï¼šéš¾ä»¥ä»å“ˆå¸Œå€¼åæ¨åŸå§‹æ•°æ®

### 1.4 åº”ç”¨ä¼˜åŠ¿

- **æ€§èƒ½æå‡**ï¼šå¤§å¹…æé«˜æŸ¥æ‰¾å’Œæ£€ç´¢é€Ÿåº¦
- **å†…å­˜èŠ‚çœ**ï¼šé«˜æ•ˆçš„ç©ºé—´åˆ©ç”¨ç‡
- **ç®€åŒ–è®¾è®¡**ï¼šç»Ÿä¸€çš„æ•°æ®è®¿é—®æ¥å£
- **æ‰©å±•æ€§å¥½**ï¼šæ”¯æŒå¤§è§„æ¨¡æ•°æ®å¤„ç†
- **å¹¶å‘å‹å¥½**ï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®

---

## 2. ğŸ’¡ åŸºæœ¬æ€æƒ³


### 2.1 æ ¸å¿ƒæ€æƒ³

å“ˆå¸Œç®—æ³•åº”ç”¨çš„æ ¸å¿ƒæ€æƒ³æ˜¯"æ˜ å°„ä¼˜åŒ–"ï¼š
1. **æ•°æ®æ˜ å°„**ï¼šå°†å¤æ‚æ•°æ®æ˜ å°„ä¸ºç®€å•æ ‡è¯†
2. **å¿«é€Ÿå®šä½**ï¼šé€šè¿‡å“ˆå¸Œå€¼å¿«é€Ÿå®šä½æ•°æ®
3. **åˆ†å¸ƒå‡è¡¡**ï¼šå®ç°æ•°æ®çš„å‡åŒ€åˆ†å¸ƒ
4. **æŠ½è±¡ç®€åŒ–**ï¼šç»Ÿä¸€ä¸åŒç±»å‹æ•°æ®çš„å¤„ç†æ–¹å¼

### 2.2 åº”ç”¨æ¨¡å¼


**æŸ¥æ‰¾åŠ é€Ÿæ¨¡å¼ï¼š**
- å°†çº¿æ€§æŸ¥æ‰¾è½¬æ¢ä¸ºå¸¸æ•°æ—¶é—´æŸ¥æ‰¾
- å…¸å‹åº”ç”¨ï¼šæ•°æ®åº“ç´¢å¼•ã€ç¼“å­˜ç³»ç»Ÿ

**å»é‡æ£€æµ‹æ¨¡å¼ï¼š**
- å¿«é€Ÿæ£€æµ‹é‡å¤æ•°æ®
- å…¸å‹åº”ç”¨ï¼šé›†åˆæ“ä½œã€é‡å¤æ–‡ä»¶æ£€æµ‹

**åˆ†å¸ƒå¼æ˜ å°„æ¨¡å¼ï¼š**
- å°†æ•°æ®å‡åŒ€åˆ†å¸ƒåˆ°å¤šä¸ªèŠ‚ç‚¹
- å…¸å‹åº”ç”¨ï¼šè´Ÿè½½å‡è¡¡ã€æ•°æ®åˆ†ç‰‡

**å®Œæ•´æ€§éªŒè¯æ¨¡å¼ï¼š**
- é€šè¿‡å“ˆå¸Œå€¼éªŒè¯æ•°æ®å®Œæ•´æ€§
- å…¸å‹åº”ç”¨ï¼šæ•°å­—ç­¾åã€æ–‡ä»¶æ ¡éªŒ

### 2.3 åº”ç”¨è®¾è®¡åŸåˆ™


```
é€‰æ‹©åˆé€‚çš„å“ˆå¸Œå‡½æ•°ï¼š
1. æ•°æ®ç‰¹å¾åˆ†æï¼šé”®çš„åˆ†å¸ƒã€å¤§å°ã€ç±»å‹
2. æ€§èƒ½è¦æ±‚ï¼šè®¡ç®—é€Ÿåº¦ã€å†…å­˜ä½¿ç”¨
3. è´¨é‡è¦æ±‚ï¼šåˆ†å¸ƒå‡åŒ€æ€§ã€ç¢°æ’ç‡
4. å®‰å…¨è¦æ±‚ï¼šæŠ—æ”»å‡»èƒ½åŠ›ã€å•å‘æ€§

è®¾è®¡ç¢°æ’å¤„ç†ç­–ç•¥ï¼š
1. é¢„æœŸè´Ÿè½½ï¼šä¼°ç®—æ•°æ®é‡å’Œå¢é•¿è¶‹åŠ¿
2. æ€§èƒ½ç›®æ ‡ï¼šæŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„æ—¶é—´è¦æ±‚
3. ç©ºé—´é™åˆ¶ï¼šå†…å­˜é¢„ç®—å’Œå­˜å‚¨æˆæœ¬
4. å¹¶å‘éœ€æ±‚ï¼šå¤šçº¿ç¨‹è®¿é—®æ¨¡å¼

ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½ï¼š
1. ç¼“å­˜ç­–ç•¥ï¼šçƒ­ç‚¹æ•°æ®çš„å¿«é€Ÿè®¿é—®
2. é¢„å¤„ç†ï¼šæå‰è®¡ç®—å¸¸ç”¨å“ˆå¸Œå€¼
3. æ‰¹é‡æ“ä½œï¼šå‡å°‘å•æ¬¡æ“ä½œå¼€é”€
4. ç›‘æ§è°ƒä¼˜ï¼šå®æ—¶æ€§èƒ½åˆ†æå’Œè°ƒæ•´
```

---

## 3. âš™ï¸ ç®—æ³•åŸç†


### 3.1 å­—ç¬¦ä¸²åŒ¹é…åº”ç”¨


#### 3.1.1 Rabin-Karpç®—æ³•

```
æ ¸å¿ƒæ€æƒ³ï¼š
ä½¿ç”¨æ»šåŠ¨å“ˆå¸ŒæŠ€æœ¯å®ç°é«˜æ•ˆçš„å­—ç¬¦ä¸²åŒ¹é…

ç®—æ³•åŸç†ï¼š
1. è®¡ç®—æ¨¡å¼ä¸²çš„å“ˆå¸Œå€¼
2. ä½¿ç”¨æ»‘åŠ¨çª—å£è®¡ç®—æ–‡æœ¬ä¸²çš„å“ˆå¸Œå€¼
3. æ¯”è¾ƒå“ˆå¸Œå€¼ï¼Œç›¸ç­‰æ—¶å†éªŒè¯å®é™…å­—ç¬¦ä¸²

æ»šåŠ¨å“ˆå¸Œå…¬å¼ï¼š
hash(s[i+1...i+m]) = (hash(s[i...i+m-1]) - s[i]*p^(m-1)) * p + s[i+m]

æ—¶é—´å¤æ‚åº¦ï¼š
- æœ€å¥½æƒ…å†µï¼šO(n + m)
- æœ€åæƒ…å†µï¼šO(nm)ï¼ˆæ‰€æœ‰ä½ç½®å“ˆå¸Œå€¼ç›¸åŒï¼‰
- å¹³å‡æƒ…å†µï¼šO(n + m)
```

#### 3.1.2 å¤šæ¨¡å¼åŒ¹é…

```
é—®é¢˜æ‰©å±•ï¼šåŒæ—¶åŒ¹é…å¤šä¸ªæ¨¡å¼ä¸²

è§£å†³æ–¹æ¡ˆï¼š
1. å“ˆå¸Œè¡¨å­˜å‚¨æ‰€æœ‰æ¨¡å¼ä¸²çš„å“ˆå¸Œå€¼
2. å¯¹æ–‡æœ¬ä¸²ä½¿ç”¨æ»‘åŠ¨çª—å£
3. æ¯ä¸ªä½ç½®çš„å“ˆå¸Œå€¼åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾

ä¼˜åŒ–æŠ€æœ¯ï¼š
- ä¸åŒé•¿åº¦æ¨¡å¼ä¸²çš„å¤„ç†
- æœ€å°å“ˆå¸Œçª—å£ä¼˜åŒ–
- å¸ƒéš†è¿‡æ»¤å™¨é¢„ç­›é€‰
```

### 3.2 æ•°æ®å»é‡åº”ç”¨


#### 3.2.1 é›†åˆæ“ä½œå®ç°

```
åŸºæœ¬é›†åˆæ“ä½œï¼š
- å¹¶é›†ï¼šA âˆª B
- äº¤é›†ï¼šA âˆ© B  
- å·®é›†ï¼šA - B
- å¯¹ç§°å·®é›†ï¼šA âŠ• B

å“ˆå¸Œå®ç°ç­–ç•¥ï¼š
1. å°†é›†åˆå…ƒç´ å­˜å‚¨åœ¨å“ˆå¸Œè¡¨ä¸­
2. åˆ©ç”¨å“ˆå¸Œè¡¨çš„å¿«é€ŸæŸ¥æ‰¾ç‰¹æ€§
3. éå†ä¸€ä¸ªé›†åˆï¼Œåœ¨å¦ä¸€ä¸ªé›†åˆä¸­æŸ¥æ‰¾

æ—¶é—´å¤æ‚åº¦ï¼šO(|A| + |B|)
ç©ºé—´å¤æ‚åº¦ï¼šO(|A| + |B|)
```

#### 3.2.2 é‡å¤æ•°æ®æ£€æµ‹

```
åº”ç”¨åœºæ™¯ï¼š
- æ–‡ä»¶å»é‡
- æ•°æ®åº“è®°å½•å»é‡
- ç½‘ç»œæ•°æ®åŒ…å»é‡
- æ–‡æ¡£ç›¸ä¼¼æ€§æ£€æµ‹

æ£€æµ‹ç­–ç•¥ï¼š
1. è®¡ç®—æ•°æ®çš„å“ˆå¸ŒæŒ‡çº¹
2. ç»´æŠ¤å·²è§è¿‡çš„å“ˆå¸Œå€¼é›†åˆ
3. æ–°æ•°æ®å“ˆå¸Œå€¼ä¸é›†åˆæ¯”è¾ƒ
4. ç›¸åŒå“ˆå¸Œå€¼è¡¨ç¤ºå¯èƒ½é‡å¤

è¯¯åˆ¤å¤„ç†ï¼š
- å“ˆå¸Œç¢°æ’å¯¼è‡´çš„å‡é˜³æ€§
- äºŒæ¬¡éªŒè¯æœºåˆ¶
- å¤šé‡å“ˆå¸Œé™ä½è¯¯åˆ¤ç‡
```

### 3.3 åˆ†å¸ƒå¼ç³»ç»Ÿåº”ç”¨


#### 3.3.1 ä¸€è‡´æ€§å“ˆå¸Œ

```
é—®é¢˜èƒŒæ™¯ï¼š
åˆ†å¸ƒå¼ç³»ç»Ÿä¸­èŠ‚ç‚¹åŠ¨æ€å¢å‡æ—¶çš„æ•°æ®é‡åˆ†å¸ƒé—®é¢˜

è§£å†³æ–¹æ¡ˆï¼š
1. å°†å“ˆå¸Œç©ºé—´è§†ä¸ºç¯å½¢ç»“æ„
2. èŠ‚ç‚¹å’Œæ•°æ®éƒ½æ˜ å°„åˆ°ç¯ä¸Š
3. æ•°æ®å­˜å‚¨åˆ°é¡ºæ—¶é’ˆæœ€è¿‘çš„èŠ‚ç‚¹
4. èŠ‚ç‚¹å˜åŒ–æ—¶åªå½±å“å±€éƒ¨æ•°æ®

è™šæ‹ŸèŠ‚ç‚¹æŠ€æœ¯ï¼š
- æ¯ä¸ªç‰©ç†èŠ‚ç‚¹æ˜ å°„å¤šä¸ªè™šæ‹ŸèŠ‚ç‚¹
- æé«˜è´Ÿè½½å‡è¡¡æ€§
- å‡å°‘æ•°æ®è¿ç§»é‡

è´Ÿè½½å‡è¡¡åˆ†æï¼š
- ç†æƒ³æƒ…å†µï¼šæ•°æ®å‡åŒ€åˆ†å¸ƒ
- å®é™…æƒ…å†µï¼šéœ€è¦è™šæ‹ŸèŠ‚ç‚¹ä¼˜åŒ–
- è¿ç§»æˆæœ¬ï¼šO(K/N)ï¼ŒKä¸ºæ•°æ®é‡ï¼ŒNä¸ºèŠ‚ç‚¹æ•°
```

#### 3.3.2 æ•°æ®åˆ†ç‰‡ç­–ç•¥

```
æ°´å¹³åˆ†ç‰‡ï¼ˆHorizontal Shardingï¼‰ï¼š
- æŒ‰å“ˆå¸Œå€¼å°†æ•°æ®åˆ†å¸ƒåˆ°ä¸åŒåˆ†ç‰‡
- ä¿è¯æŸ¥è¯¢çš„å±€éƒ¨æ€§
- æ”¯æŒå¹¶è¡Œå¤„ç†

å‚ç›´åˆ†ç‰‡ï¼ˆVertical Shardingï¼‰ï¼š
- æŒ‰æ•°æ®ç±»å‹æˆ–è®¿é—®æ¨¡å¼åˆ†ç‰‡
- å‡å°‘è·¨åˆ†ç‰‡æŸ¥è¯¢
- ä¼˜åŒ–å­˜å‚¨å’Œè®¿é—®æ€§èƒ½

åˆ†ç‰‡ç®—æ³•ï¼š
1. èŒƒå›´åˆ†ç‰‡ï¼šæŒ‰é”®å€¼èŒƒå›´åˆ†å¸ƒ
2. å“ˆå¸Œåˆ†ç‰‡ï¼šæŒ‰å“ˆå¸Œå€¼å–æ¨¡åˆ†å¸ƒ
3. ç›®å½•åˆ†ç‰‡ï¼šç»´æŠ¤åˆ†ç‰‡æ˜ å°„è¡¨
4. æ··åˆåˆ†ç‰‡ï¼šç»“åˆå¤šç§ç­–ç•¥
```

### 3.4 å®‰å…¨åº”ç”¨


#### 3.4.1 å¯†ç å­˜å‚¨

```
å®‰å…¨å­˜å‚¨è¦æ±‚ï¼š
- ä¸èƒ½æ˜æ–‡å­˜å‚¨å¯†ç 
- é˜²æ­¢å½©è™¹è¡¨æ”»å‡»
- æŠµæŠ—æš´åŠ›ç ´è§£

åŠ ç›å“ˆå¸Œï¼ˆSalted Hashï¼‰ï¼š
1. ä¸ºæ¯ä¸ªå¯†ç ç”Ÿæˆéšæœºç›å€¼
2. å°†å¯†ç ä¸ç›å€¼è¿æ¥
3. è®¡ç®—è¿æ¥åå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼
4. å­˜å‚¨ç›å€¼å’Œå“ˆå¸Œå€¼

éªŒè¯è¿‡ç¨‹ï¼š
1. è·å–å­˜å‚¨çš„ç›å€¼å’Œå“ˆå¸Œå€¼
2. å°†è¾“å…¥å¯†ç ä¸ç›å€¼è¿æ¥
3. è®¡ç®—å“ˆå¸Œå€¼å¹¶æ¯”è¾ƒ
4. ç›¸ç­‰åˆ™éªŒè¯æˆåŠŸ

å®‰å…¨å¼ºåŒ–ï¼š
- ä½¿ç”¨æ…¢å“ˆå¸Œç®—æ³•ï¼ˆbcrypt, scryptï¼‰
- å¢åŠ è®¡ç®—å¤æ‚åº¦
- å®šæœŸæ›´æ–°å“ˆå¸Œç®—æ³•
```

#### 3.4.2 æ•°å­—æŒ‡çº¹

```
åº”ç”¨åœºæ™¯ï¼š
- æ–‡ä»¶å®Œæ•´æ€§éªŒè¯
- ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ
- æ•°å­—ç‰ˆæƒä¿æŠ¤
- æ•°æ®åŒæ­¥

æŒ‡çº¹ç”Ÿæˆï¼š
1. å¯¹æ•°æ®å†…å®¹è®¡ç®—å“ˆå¸Œå€¼
2. å“ˆå¸Œå€¼ä½œä¸ºæ•°æ®çš„å”¯ä¸€æ ‡è¯†
3. å˜åŒ–æ£€æµ‹é€šè¿‡æ¯”è¾ƒæŒ‡çº¹å®ç°

å¸¸ç”¨ç®—æ³•ï¼š
- MD5ï¼šå¿«é€Ÿä½†å®‰å…¨æ€§è¾ƒä½
- SHA-1ï¼šå®‰å…¨æ€§ä¸­ç­‰
- SHA-256ï¼šé«˜å®‰å…¨æ€§
- SHA-3ï¼šæœ€æ–°æ ‡å‡†

å®Œæ•´æ€§éªŒè¯ï¼š
- å‘é€æ–¹è®¡ç®—å¹¶ä¼ è¾“å“ˆå¸Œå€¼
- æ¥æ”¶æ–¹é‡æ–°è®¡ç®—å“ˆå¸Œå€¼
- æ¯”è¾ƒä¸¤ä¸ªå“ˆå¸Œå€¼åˆ¤æ–­å®Œæ•´æ€§
```

---

## 4. ğŸ”¨ å®ç°æ–¹æ³•


### 4.1 å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•å®ç°


```java
public class StringMatchingAlgorithms {
    
    /**
     * Rabin-Karpå­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
     */
    public static class RabinKarp {
        private static final int BASE = 256;
        private static final int MOD = 101;
        
        public static List<Integer> search(String text, String pattern) {
            List<Integer> matches = new ArrayList<>();
            int n = text.length();
            int m = pattern.length();
            
            if (m > n) return matches;
            
            // è®¡ç®—æ¨¡å¼ä¸²å“ˆå¸Œå€¼
            int patternHash = hash(pattern, m);
            int textHash = hash(text, m);
            
            // é¢„è®¡ç®— BASE^(m-1) % MOD
            int h = 1;
            for (int i = 0; i < m - 1; i++) {
                h = (h * BASE) % MOD;
            }
            
            // æ»‘åŠ¨çª—å£åŒ¹é…
            for (int i = 0; i <= n - m; i++) {
                // å“ˆå¸Œå€¼åŒ¹é…ï¼Œè¿›è¡Œå­—ç¬¦ä¸²éªŒè¯
                if (patternHash == textHash) {
                    if (text.substring(i, i + m).equals(pattern)) {
                        matches.add(i);
                    }
                }
                
                // è®¡ç®—ä¸‹ä¸€ä¸ªçª—å£çš„å“ˆå¸Œå€¼
                if (i < n - m) {
                    textHash = (BASE * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
                    if (textHash < 0) {
                        textHash += MOD;
                    }
                }
            }
            
            return matches;
        }
        
        private static int hash(String str, int length) {
            int hash = 0;
            for (int i = 0; i < length; i++) {
                hash = (hash * BASE + str.charAt(i)) % MOD;
            }
            return hash;
        }
    }
    
    /**
     * å¤šæ¨¡å¼å­—ç¬¦ä¸²åŒ¹é…
     */
    public static class MultiPatternMatcher {
        private Map<Integer, Set<String>> patternsByLength;
        private Map<String, Integer> patternHashes;
        
        public MultiPatternMatcher(String[] patterns) {
            patternsByLength = new HashMap<>();
            patternHashes = new HashMap<>();
            
            for (String pattern : patterns) {
                int length = pattern.length();
                int hash = computeHash(pattern);
                
                patternsByLength.computeIfAbsent(length, k -> new HashSet<>()).add(pattern);
                patternHashes.put(pattern, hash);
            }
        }
        
        public Map<String, List<Integer>> searchAll(String text) {
            Map<String, List<Integer>> results = new HashMap<>();
            
            for (Map.Entry<Integer, Set<String>> entry : patternsByLength.entrySet()) {
                int length = entry.getKey();
                Set<String> patterns = entry.getValue();
                
                if (length > text.length()) continue;
                
                // å¯¹æ¯ä¸ªé•¿åº¦çš„æ¨¡å¼ä¸²è¿›è¡ŒåŒ¹é…
                for (int i = 0; i <= text.length() - length; i++) {
                    String substring = text.substring(i, i + length);
                    int hash = computeHash(substring);
                    
                    for (String pattern : patterns) {
                        if (patternHashes.get(pattern) == hash && pattern.equals(substring)) {
                            results.computeIfAbsent(pattern, k -> new ArrayList<>()).add(i);
                        }
                    }
                }
            }
            
            return results;
        }
        
        private int computeHash(String str) {
            int hash = 0;
            for (char c : str.toCharArray()) {
                hash = hash * 31 + c;
            }
            return hash;
        }
    }
}
```

### 4.2 æ•°æ®å»é‡å’Œé›†åˆæ“ä½œ


```java
public class DataDeduplication {
    
    /**
     * é€šç”¨å»é‡å™¨
     */
    public static class Deduplicator<T> {
        private Set<Integer> seenHashes;
        private boolean useFullComparison;
        
        public Deduplicator(boolean useFullComparison) {
            this.seenHashes = new HashSet<>();
            this.useFullComparison = useFullComparison;
        }
        
        public boolean isDuplicate(T item) {
            int hash = item.hashCode();
            
            if (!seenHashes.contains(hash)) {
                seenHashes.add(hash);
                return false;
            }
            
            // å¦‚æœå¯ç”¨å®Œæ•´æ¯”è¾ƒï¼Œå¯èƒ½éœ€è¦é¢å¤–çš„éªŒè¯é€»è¾‘
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦å­˜å‚¨åŸå§‹å¯¹è±¡è¿›è¡Œæ¯”è¾ƒ
            return true;
        }
        
        public List<T> removeDuplicates(List<T> items) {
            List<T> result = new ArrayList<>();
            Set<Integer> seen = new HashSet<>();
            
            for (T item : items) {
                int hash = item.hashCode();
                if (!seen.contains(hash)) {
                    seen.add(hash);
                    result.add(item);
                }
            }
            
            return result;
        }
        
        public void reset() {
            seenHashes.clear();
        }
        
        public int getSeenCount() {
            return seenHashes.size();
        }
    }
    
    /**
     * æ–‡ä»¶å»é‡å™¨
     */
    public static class FileDeduplicator {
        private Map<String, String> fileHashes; // å“ˆå¸Œå€¼ -> æ–‡ä»¶è·¯å¾„
        
        public FileDeduplicator() {
            this.fileHashes = new HashMap<>();
        }
        
        public List<String> findDuplicates(List<String> filePaths) {
            List<String> duplicates = new ArrayList<>();
            
            for (String path : filePaths) {
                try {
                    String hash = calculateFileHash(path);
                    
                    if (fileHashes.containsKey(hash)) {
                        duplicates.add(path);
                        System.out.println("é‡å¤æ–‡ä»¶: " + path + " (åŸæ–‡ä»¶: " + fileHashes.get(hash) + ")");
                    } else {
                        fileHashes.put(hash, path);
                    }
                } catch (Exception e) {
                    System.err.println("å¤„ç†æ–‡ä»¶å¤±è´¥: " + path + " - " + e.getMessage());
                }
            }
            
            return duplicates;
        }
        
        private String calculateFileHash(String filePath) throws Exception {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            
            try (FileInputStream fis = new FileInputStream(filePath);
                 DigestInputStream dis = new DigestInputStream(fis, md)) {
                
                byte[] buffer = new byte[8192];
                while (dis.read(buffer) != -1) {
                    // è¯»å–æ–‡ä»¶å†…å®¹åˆ°digest
                }
            }
            
            byte[] digest = md.digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : digest) {
                sb.append(String.format("%02x", b));
            }
            
            return sb.toString();
        }
        
        public void printStatistics() {
            System.out.println("æ€»å…±å¤„ç†äº† " + fileHashes.size() + " ä¸ªå”¯ä¸€æ–‡ä»¶");
        }
    }
    
    /**
     * é«˜æ•ˆé›†åˆæ“ä½œ
     */
    public static class SetOperations<T> {
        
        public Set<T> union(Set<T> set1, Set<T> set2) {
            Set<T> result = new HashSet<>(set1);
            result.addAll(set2);
            return result;
        }
        
        public Set<T> intersection(Set<T> set1, Set<T> set2) {
            Set<T> result = new HashSet<>(set1);
            result.retainAll(set2);
            return result;
        }
        
        public Set<T> difference(Set<T> set1, Set<T> set2) {
            Set<T> result = new HashSet<>(set1);
            result.removeAll(set2);
            return result;
        }
        
        public Set<T> symmetricDifference(Set<T> set1, Set<T> set2) {
            Set<T> result = new HashSet<>(set1);
            result.addAll(set2);
            
            Set<T> intersection = new HashSet<>(set1);
            intersection.retainAll(set2);
            result.removeAll(intersection);
            
            return result;
        }
        
        /**
         * æ‰¹é‡é›†åˆæ“ä½œä¼˜åŒ–
         */
        public Set<T> unionAll(List<Set<T>> sets) {
            Set<T> result = new HashSet<>();
            for (Set<T> set : sets) {
                result.addAll(set);
            }
            return result;
        }
        
        public Set<T> intersectionAll(List<Set<T>> sets) {
            if (sets.isEmpty()) return new HashSet<>();
            
            Set<T> result = new HashSet<>(sets.get(0));
            for (int i = 1; i < sets.size(); i++) {
                result.retainAll(sets.get(i));
                if (result.isEmpty()) break; // æå‰é€€å‡ºä¼˜åŒ–
            }
            
            return result;
        }
    }
}
```

### 4.3 åˆ†å¸ƒå¼å“ˆå¸Œåº”ç”¨


```java
public class DistributedHashApplications {
    
    /**
     * ä¸€è‡´æ€§å“ˆå¸Œå®ç°
     */
    public static class ConsistentHashRing<T> {
        private final TreeMap<Long, T> ring = new TreeMap<>();
        private final int virtualNodes;
        private final MessageDigest md;
        
        public ConsistentHashRing(int virtualNodes) {
            this.virtualNodes = virtualNodes;
            try {
                this.md = MessageDigest.getInstance("SHA-1");
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException("SHA-1 not available", e);
            }
        }
        
        public void addNode(T node) {
            for (int i = 0; i < virtualNodes; i++) {
                long hash = hash(node.toString() + ":" + i);
                ring.put(hash, node);
            }
        }
        
        public void removeNode(T node) {
            for (int i = 0; i < virtualNodes; i++) {
                long hash = hash(node.toString() + ":" + i);
                ring.remove(hash);
            }
        }
        
        public T getNode(String key) {
            if (ring.isEmpty()) {
                return null;
            }
            
            long hash = hash(key);
            Map.Entry<Long, T> entry = ring.ceilingEntry(hash);
            
            if (entry == null) {
                entry = ring.firstEntry();
            }
            
            return entry.getValue();
        }
        
        public Map<T, Integer> getDistribution(String[] keys) {
            Map<T, Integer> distribution = new HashMap<>();
            
            for (String key : keys) {
                T node = getNode(key);
                distribution.put(node, distribution.getOrDefault(node, 0) + 1);
            }
            
            return distribution;
        }
        
        private long hash(String key) {
            md.reset();
            md.update(key.getBytes());
            byte[] digest = md.digest();
            
            long hash = 0;
            for (int i = 0; i < 4; i++) {
                hash <<= 8;
                hash |= ((int) digest[i]) & 0xFF;
            }
            
            return hash;
        }
        
        public void printRingStatus() {
            System.out.println("=== ä¸€è‡´æ€§å“ˆå¸Œç¯çŠ¶æ€ ===");
            System.out.println("è™šæ‹ŸèŠ‚ç‚¹æ•°: " + virtualNodes);
            System.out.println("ç¯ä¸ŠèŠ‚ç‚¹æ€»æ•°: " + ring.size());
            
            Map<T, Integer> nodeCount = new HashMap<>();
            for (T node : ring.values()) {
                nodeCount.put(node, nodeCount.getOrDefault(node, 0) + 1);
            }
            
            System.out.println("ç‰©ç†èŠ‚ç‚¹åˆ†å¸ƒ:");
            for (Map.Entry<T, Integer> entry : nodeCount.entrySet()) {
                System.out.println("  " + entry.getKey() + ": " + entry.getValue() + " ä¸ªè™šæ‹ŸèŠ‚ç‚¹");
            }
        }
    }
    
    /**
     * åˆ†å¸ƒå¼ç¼“å­˜åˆ†ç‰‡
     */
    public static class DistributedCache<K, V> {
        private final List<Map<K, V>> shards;
        private final int shardCount;
        
        public DistributedCache(int shardCount) {
            this.shardCount = shardCount;
            this.shards = new ArrayList<>(shardCount);
            
            for (int i = 0; i < shardCount; i++) {
                shards.add(new ConcurrentHashMap<>());
            }
        }
        
        public void put(K key, V value) {
            int shardIndex = getShardIndex(key);
            shards.get(shardIndex).put(key, value);
        }
        
        public V get(K key) {
            int shardIndex = getShardIndex(key);
            return shards.get(shardIndex).get(key);
        }
        
        public V remove(K key) {
            int shardIndex = getShardIndex(key);
            return shards.get(shardIndex).remove(key);
        }
        
        public boolean containsKey(K key) {
            int shardIndex = getShardIndex(key);
            return shards.get(shardIndex).containsKey(key);
        }
        
        private int getShardIndex(K key) {
            return Math.abs(key.hashCode()) % shardCount;
        }
        
        public int size() {
            return shards.stream().mapToInt(Map::size).sum();
        }
        
        public void printShardDistribution() {
            System.out.println("=== åˆ†ç‰‡åˆ†å¸ƒç»Ÿè®¡ ===");
            for (int i = 0; i < shardCount; i++) {
                System.out.println("åˆ†ç‰‡ " + i + ": " + shards.get(i).size() + " ä¸ªæ¡ç›®");
            }
        }
        
        /**
         * æ‰¹é‡æ“ä½œä¼˜åŒ–
         */
        public void putAll(Map<K, V> map) {
            Map<Integer, Map<K, V>> shardedData = new HashMap<>();
            
            // æŒ‰åˆ†ç‰‡åˆ†ç»„æ•°æ®
            for (Map.Entry<K, V> entry : map.entrySet()) {
                int shardIndex = getShardIndex(entry.getKey());
                shardedData.computeIfAbsent(shardIndex, k -> new HashMap<>())
                          .put(entry.getKey(), entry.getValue());
            }
            
            // å¹¶è¡Œå†™å…¥å„åˆ†ç‰‡
            shardedData.entrySet().parallelStream().forEach(entry -> {
                int shardIndex = entry.getKey();
                Map<K, V> data = entry.getValue();
                shards.get(shardIndex).putAll(data);
            });
        }
    }
    
    /**
     * è´Ÿè½½å‡è¡¡å™¨
     */
    public static class HashBasedLoadBalancer<T> {
        private final List<T> servers;
        private final Map<T, Integer> weights;
        
        public HashBasedLoadBalancer() {
            this.servers = new ArrayList<>();
            this.weights = new HashMap<>();
        }
        
        public void addServer(T server, int weight) {
            servers.add(server);
            weights.put(server, weight);
        }
        
        public void removeServer(T server) {
            servers.remove(server);
            weights.remove(server);
        }
        
        /**
         * åŸºäºå“ˆå¸Œçš„æœåŠ¡å™¨é€‰æ‹©
         */
        public T selectServer(String key) {
            if (servers.isEmpty()) {
                return null;
            }
            
            int hash = Math.abs(key.hashCode());
            int index = hash % servers.size();
            return servers.get(index);
        }
        
        /**
         * åŠ æƒå“ˆå¸Œé€‰æ‹©
         */
        public T selectWeightedServer(String key) {
            if (servers.isEmpty()) {
                return null;
            }
            
            int totalWeight = weights.values().stream().mapToInt(Integer::intValue).sum();
            int hash = Math.abs(key.hashCode()) % totalWeight;
            
            int currentWeight = 0;
            for (T server : servers) {
                currentWeight += weights.get(server);
                if (hash < currentWeight) {
                    return server;
                }
            }
            
            return servers.get(servers.size() - 1);
        }
        
        /**
         * æµ‹è¯•è´Ÿè½½åˆ†å¸ƒ
         */
        public void testDistribution(String[] keys) {
            Map<T, Integer> distribution = new HashMap<>();
            
            for (String key : keys) {
                T server = selectWeightedServer(key);
                distribution.put(server, distribution.getOrDefault(server, 0) + 1);
            }
            
            System.out.println("=== è´Ÿè½½åˆ†å¸ƒæµ‹è¯• ===");
            for (Map.Entry<T, Integer> entry : distribution.entrySet()) {
                double percentage = 100.0 * entry.getValue() / keys.length;
                System.out.println(entry.getKey() + ": " + entry.getValue() + 
                                 " è¯·æ±‚ (" + String.format("%.1f", percentage) + "%)");
            }
        }
    }
}
```

### 4.4 å®‰å…¨åº”ç”¨å®ç°


```java
import java.security.*;
import java.security.spec.KeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

public class SecurityApplications {
    
    /**
     * å¯†ç å®‰å…¨å­˜å‚¨
     */
    public static class SecurePasswordManager {
        private static final String ALGORITHM = "PBKDF2WithHmacSHA256";
        private static final int ITERATIONS = 100000;
        private static final int KEY_LENGTH = 256;
        
        public static class PasswordData {
            private final String salt;
            private final String hash;
            
            public PasswordData(String salt, String hash) {
                this.salt = salt;
                this.hash = hash;
            }
            
            public String getSalt() { return salt; }
            public String getHash() { return hash; }
        }
        
        public static PasswordData hashPassword(String password) {
            try {
                // ç”Ÿæˆéšæœºç›å€¼
                SecureRandom random = new SecureRandom();
                byte[] salt = new byte[16];
                random.nextBytes(salt);
                
                // ç”Ÿæˆå“ˆå¸Œå€¼
                KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATIONS, KEY_LENGTH);
                SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
                byte[] hash = factory.generateSecret(spec).getEncoded();
                
                return new PasswordData(
                    bytesToHex(salt),
                    bytesToHex(hash)
                );
                
            } catch (Exception e) {
                throw new RuntimeException("å¯†ç å“ˆå¸Œå¤±è´¥", e);
            }
        }
        
        public static boolean verifyPassword(String password, PasswordData stored) {
            try {
                byte[] salt = hexToBytes(stored.getSalt());
                
                KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATIONS, KEY_LENGTH);
                SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
                byte[] hash = factory.generateSecret(spec).getEncoded();
                
                String computedHash = bytesToHex(hash);
                return computedHash.equals(stored.getHash());
                
            } catch (Exception e) {
                return false;
            }
        }
        
        private static String bytesToHex(byte[] bytes) {
            StringBuilder result = new StringBuilder();
            for (byte b : bytes) {
                result.append(String.format("%02x", b));
            }
            return result.toString();
        }
        
        private static byte[] hexToBytes(String hex) {
            int len = hex.length();
            byte[] data = new byte[len / 2];
            for (int i = 0; i < len; i += 2) {
                data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)
                                    + Character.digit(hex.charAt(i + 1), 16));
            }
            return data;
        }
    }
    
    /**
     * æ–‡ä»¶å®Œæ•´æ€§éªŒè¯
     */
    public static class FileIntegrityChecker {
        
        public static class FileChecksum {
            private final String filename;
            private final String md5;
            private final String sha1;
            private final String sha256;
            private final long fileSize;
            private final long timestamp;
            
            public FileChecksum(String filename, String md5, String sha1, String sha256, 
                              long fileSize, long timestamp) {
                this.filename = filename;
                this.md5 = md5;
                this.sha1 = sha1;
                this.sha256 = sha256;
                this.fileSize = fileSize;
                this.timestamp = timestamp;
            }
            
            // Getters
            public String getFilename() { return filename; }
            public String getMd5() { return md5; }
            public String getSha1() { return sha1; }
            public String getSha256() { return sha256; }
            public long getFileSize() { return fileSize; }
            public long getTimestamp() { return timestamp; }
            
            @Override
            public String toString() {
                return String.format("File: %s\nMD5: %s\nSHA1: %s\nSHA256: %s\nSize: %d bytes\nTime: %s",
                    filename, md5, sha1, sha256, fileSize, new java.util.Date(timestamp));
            }
        }
        
        public static FileChecksum calculateChecksum(String filePath) throws Exception {
            File file = new File(filePath);
            if (!file.exists()) {
                throw new FileNotFoundException("æ–‡ä»¶ä¸å­˜åœ¨: " + filePath);
            }
            
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            
            try (FileInputStream fis = new FileInputStream(file);
                 BufferedInputStream bis = new BufferedInputStream(fis)) {
                
                byte[] buffer = new byte[8192];
                int bytesRead;
                
                while ((bytesRead = bis.read(buffer)) != -1) {
                    md5.update(buffer, 0, bytesRead);
                    sha1.update(buffer, 0, bytesRead);
                    sha256.update(buffer, 0, bytesRead);
                }
            }
            
            return new FileChecksum(
                file.getName(),
                bytesToHex(md5.digest()),
                bytesToHex(sha1.digest()),
                bytesToHex(sha256.digest()),
                file.length(),
                file.lastModified()
            );
        }
        
        public static boolean verifyFile(String filePath, FileChecksum expected) {
            try {
                FileChecksum actual = calculateChecksum(filePath);
                
                return expected.getMd5().equals(actual.getMd5()) &&
                       expected.getSha1().equals(actual.getSha1()) &&
                       expected.getSha256().equals(actual.getSha256()) &&
                       expected.getFileSize() == actual.getFileSize();
                
            } catch (Exception e) {
                System.err.println("éªŒè¯æ–‡ä»¶å¤±è´¥: " + e.getMessage());
                return false;
            }
        }
        
        public static void batchVerify(String directory, Map<String, FileChecksum> expectedChecksums) {
            File dir = new File(directory);
            if (!dir.isDirectory()) {
                System.err.println("ä¸æ˜¯æœ‰æ•ˆç›®å½•: " + directory);
                return;
            }
            
            System.out.println("=== æ‰¹é‡æ–‡ä»¶å®Œæ•´æ€§éªŒè¯ ===");
            int totalFiles = 0;
            int validFiles = 0;
            int modifiedFiles = 0;
            int missingFiles = 0;
            
            for (Map.Entry<String, FileChecksum> entry : expectedChecksums.entrySet()) {
                String filename = entry.getKey();
                FileChecksum expected = entry.getValue();
                String filePath = directory + File.separator + filename;
                
                totalFiles++;
                
                File file = new File(filePath);
                if (!file.exists()) {
                    System.out.println("âŒ æ–‡ä»¶ç¼ºå¤±: " + filename);
                    missingFiles++;
                    continue;
                }
                
                if (verifyFile(filePath, expected)) {
                    System.out.println("âœ… æ–‡ä»¶å®Œæ•´: " + filename);
                    validFiles++;
                } else {
                    System.out.println("âš ï¸ æ–‡ä»¶å·²ä¿®æ”¹: " + filename);
                    modifiedFiles++;
                }
            }
            
            System.out.println("\n=== éªŒè¯æ€»ç»“ ===");
            System.out.println("æ€»æ–‡ä»¶æ•°: " + totalFiles);
            System.out.println("å®Œæ•´æ–‡ä»¶: " + validFiles);
            System.out.println("å·²ä¿®æ”¹æ–‡ä»¶: " + modifiedFiles);
            System.out.println("ç¼ºå¤±æ–‡ä»¶: " + missingFiles);
        }
        
        private static String bytesToHex(byte[] bytes) {
            StringBuilder result = new StringBuilder();
            for (byte b : bytes) {
                result.append(String.format("%02x", b));
            }
            return result.toString();
        }
    }
    
    /**
     * æ•°å­—ç­¾åå’ŒéªŒè¯
     */
    public static class DigitalSignature {
        
        public static class SignatureData {
            private final String data;
            private final String signature;
            private final String algorithm;
            private final long timestamp;
            
            public SignatureData(String data, String signature, String algorithm, long timestamp) {
                this.data = data;
                this.signature = signature;
                this.algorithm = algorithm;
                this.timestamp = timestamp;
            }
            
            public String getData() { return data; }
            public String getSignature() { return signature; }
            public String getAlgorithm() { return algorithm; }
            public long getTimestamp() { return timestamp; }
        }
        
        public static KeyPair generateKeyPair() throws Exception {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048);
            return keyGen.generateKeyPair();
        }
        
        public static SignatureData signData(String data, PrivateKey privateKey) throws Exception {
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(privateKey);
            signature.update(data.getBytes());
            
            byte[] digitalSignature = signature.sign();
            
            return new SignatureData(
                data,
                Base64.getEncoder().encodeToString(digitalSignature),
                "SHA256withRSA",
                System.currentTimeMillis()
            );
        }
        
        public static boolean verifySignature(SignatureData signatureData, PublicKey publicKey) {
            try {
                Signature signature = Signature.getInstance(signatureData.getAlgorithm());
                signature.initVerify(publicKey);
                signature.update(signatureData.getData().getBytes());
                
                byte[] digitalSignature = Base64.getDecoder().decode(signatureData.getSignature());
                return signature.verify(digitalSignature);
                
            } catch (Exception e) {
                System.err.println("ç­¾åéªŒè¯å¤±è´¥: " + e.getMessage());
                return false;
            }
        }
        
        /**
         * æ‰¹é‡ç­¾åéªŒè¯
         */
        public static Map<String, Boolean> batchVerify(List<SignatureData> signatures, PublicKey publicKey) {
            Map<String, Boolean> results = new HashMap<>();
            
            for (SignatureData sig : signatures) {
                boolean isValid = verifySignature(sig, publicKey);
                results.put(sig.getData(), isValid);
                
                System.out.println((isValid ? "âœ…" : "âŒ") + " " + 
                                 sig.getData().substring(0, Math.min(50, sig.getData().length())) + "...");
            }
            
            return results;
        }
    }
}
```

---

## 5. ğŸ“Š ç®—æ³•åˆ†æ


### 5.1 æ€§èƒ½åˆ†æ


#### 5.1.1 æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

```
ä¸åŒåº”ç”¨åœºæ™¯çš„æ—¶é—´å¤æ‚åº¦ï¼š

å­—ç¬¦ä¸²åŒ¹é…ï¼š
- æœ´ç´ ç®—æ³•ï¼šO(nm)
- Rabin-Karpï¼šå¹³å‡O(n+m)ï¼Œæœ€åO(nm)
- KMPç®—æ³•ï¼šO(n+m)
- å“ˆå¸Œä¼˜åŠ¿ï¼šå¹³å‡æƒ…å†µä¸‹æ˜¾è‘—æå‡

æ•°æ®å»é‡ï¼š
- æ’åºå»é‡ï¼šO(n log n)
- å“ˆå¸Œå»é‡ï¼šO(n)
- ç©ºé—´æ¢æ—¶é—´çš„å…¸å‹åº”ç”¨

é›†åˆæ“ä½œï¼š
- æ•°ç»„å®ç°ï¼šO(nÂ²)
- å“ˆå¸Œå®ç°ï¼šO(n+m)
- å¤§æ•°æ®é›†åˆä¼˜åŠ¿æ˜æ˜¾

åˆ†å¸ƒå¼æŸ¥æ‰¾ï¼š
- çº¿æ€§æŸ¥æ‰¾ï¼šO(n)
- ä¸€è‡´æ€§å“ˆå¸Œï¼šO(log n)
- è´Ÿè½½å‡è¡¡ï¼šO(1)
```

#### 5.1.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

```
å†…å­˜ä½¿ç”¨æ¨¡å¼ï¼š

å“ˆå¸Œè¡¨å­˜å‚¨ï¼š
- åŸºç¡€å¼€é”€ï¼šO(m)è¡¨ç©ºé—´
- æ•°æ®å¼€é”€ï¼šO(n)å®é™…æ•°æ®
- è´Ÿè½½å› å­å½±å“ï¼šÎ± = n/m

åˆ†å¸ƒå¼åº”ç”¨ï¼š
- ä¸€è‡´æ€§å“ˆå¸Œï¼šO(è™šæ‹ŸèŠ‚ç‚¹æ•°)
- æ•°æ®åˆ†ç‰‡ï¼šO(åˆ†ç‰‡å…ƒæ•°æ®)
- ç¼“å­˜ç³»ç»Ÿï¼šO(ç¼“å­˜å®¹é‡)

å®‰å…¨åº”ç”¨ï¼š
- å¯†ç å“ˆå¸Œï¼šO(1)æ¯ä¸ªå¯†ç 
- æ–‡ä»¶æ ¡éªŒï¼šO(ç®—æ³•æ•°)æ¯ä¸ªæ–‡ä»¶
- æ•°å­—ç­¾åï¼šO(å¯†é’¥é•¿åº¦)
```

### 5.2 å®é™…æ€§èƒ½æµ‹è¯•


```java
public class PerformanceBenchmark {
    
    public static void benchmarkStringMatching() {
        String text = generateRandomString(1000000);
        String pattern = generateRandomString(100);
        
        // Rabin-Karpæµ‹è¯•
        long start = System.nanoTime();
        List<Integer> matches = RabinKarp.search(text, pattern);
        long rabinKarpTime = System.nanoTime() - start;
        
        // æœ´ç´ ç®—æ³•æµ‹è¯•
        start = System.nanoTime();
        List<Integer> naiveMatches = naiveSearch(text, pattern);
        long naiveTime = System.nanoTime() - start;
        
        System.out.println("=== å­—ç¬¦ä¸²åŒ¹é…æ€§èƒ½æµ‹è¯• ===");
        System.out.println("æ–‡æœ¬é•¿åº¦: " + text.length());
        System.out.println("æ¨¡å¼é•¿åº¦: " + pattern.length());
        System.out.println("Rabin-Karp: " + (rabinKarpTime / 1_000_000) + " ms");
        System.out.println("æœ´ç´ ç®—æ³•: " + (naiveTime / 1_000_000) + " ms");
        System.out.println("æ€§èƒ½æå‡: " + String.format("%.1fx", (double) naiveTime / rabinKarpTime));
    }
    
    public static void benchmarkDeduplication() {
        List<String> data = generateTestData(100000);
        
        // å“ˆå¸Œå»é‡
        long start = System.nanoTime();
        Set<String> hashDedup = new HashSet<>(data);
        long hashTime = System.nanoTime() - start;
        
        // æ’åºå»é‡
        start = System.nanoTime();
        List<String> sortedData = new ArrayList<>(data);
        Collections.sort(sortedData);
        Set<String> sortDedup = new LinkedHashSet<>();
        String prev = null;
        for (String item : sortedData) {
            if (!item.equals(prev)) {
                sortDedup.add(item);
                prev = item;
            }
        }
        long sortTime = System.nanoTime() - start;
        
        System.out.println("=== å»é‡æ€§èƒ½æµ‹è¯• ===");
        System.out.println("æ•°æ®é‡: " + data.size());
        System.out.println("å“ˆå¸Œå»é‡: " + (hashTime / 1_000_000) + " ms");
        System.out.println("æ’åºå»é‡: " + (sortTime / 1_000_000) + " ms");
        System.out.println("æ€§èƒ½æå‡: " + String.format("%.1fx", (double) sortTime / hashTime));
    }
    
    private static String generateRandomString(int length) {
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) ('a' + random.nextInt(26)));
        }
        return sb.toString();
    }
    
    private static List<String> generateTestData(int size) {
        List<String> data = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < size; i++) {
            data.add("item_" + random.nextInt(size / 2)); // 50%é‡å¤ç‡
        }
        return data;
    }
}
```

---

## 6. ğŸ¯ å…¸å‹åº”ç”¨


### 6.1 æ•°æ®åº“ç³»ç»Ÿåº”ç”¨

- **ç´¢å¼•ä¼˜åŒ–**ï¼šå“ˆå¸Œç´¢å¼•æä¾›O(1)æŸ¥æ‰¾æ€§èƒ½
- **è¿æ¥ç®—æ³•**ï¼šå“ˆå¸Œè¿æ¥å¤„ç†å¤§è¡¨è¿æ¥
- **åˆ†åŒºç­–ç•¥**ï¼šæŒ‰å“ˆå¸Œå€¼åˆ†åŒºæ•°æ®
- **ç¼“å­˜ç®¡ç†**ï¼šç¼“å†²æ± çš„é¡µé¢å®šä½

### 6.2 ç½‘ç»œå’Œåˆ†å¸ƒå¼ç³»ç»Ÿ

- **CDNå†…å®¹åˆ†å‘**ï¼šä¸€è‡´æ€§å“ˆå¸Œå®ç°å†…å®¹è·¯ç”±
- **è´Ÿè½½å‡è¡¡**ï¼šä¼šè¯äº²å’Œæ€§å’Œæµé‡åˆ†å‘
- **åˆ†å¸ƒå¼å­˜å‚¨**ï¼šæ•°æ®åˆ†ç‰‡å’Œå‰¯æœ¬å®šä½
- **P2Pç½‘ç»œ**ï¼šèŠ‚ç‚¹å‘ç°å’Œèµ„æºå®šä½

### 6.3 å®‰å…¨å’Œå¯†ç å­¦

- **ç”¨æˆ·è®¤è¯**ï¼šå¯†ç å®‰å…¨å­˜å‚¨å’ŒéªŒè¯
- **æ•°æ®å®Œæ•´æ€§**ï¼šæ–‡ä»¶æ ¡éªŒå’Œä¼ è¾“éªŒè¯
- **æ•°å­—è¯ä¹¦**ï¼šPKIä½“ç³»ä¸­çš„è¯ä¹¦éªŒè¯
- **åŒºå—é“¾**ï¼šå·¥ä½œé‡è¯æ˜å’Œäº¤æ˜“éªŒè¯

### 6.4 æœç´¢å’Œæ¨èç³»ç»Ÿ

- **å€’æ’ç´¢å¼•**ï¼šæœç´¢å¼•æ“çš„æ ¸å¿ƒæ•°æ®ç»“æ„
- **ç›¸ä¼¼æ€§æ£€æµ‹**ï¼šæ–‡æ¡£å»é‡å’Œç›¸ä¼¼åº¦è®¡ç®—
- **ç‰¹å¾å“ˆå¸Œ**ï¼šæœºå™¨å­¦ä¹ ä¸­çš„ç‰¹å¾å¤„ç†
- **ç¼“å­˜ç­–ç•¥**ï¼šçƒ­ç‚¹æ•°æ®çš„å¿«é€Ÿè®¿é—®

---

## 7. ğŸ“‹ æ€»ç»“


### 7.1 æ ¸å¿ƒè¦ç‚¹

1. **ğŸ”¸ åº”ç”¨å¹¿æ³›**ï¼šä»åŸºç¡€æ•°æ®ç»“æ„åˆ°å¤æ‚åˆ†å¸ƒå¼ç³»ç»Ÿ
2. **ğŸ”¸ æ€§èƒ½ä¼˜åŠ¿**ï¼šæ˜¾è‘—æå‡æŸ¥æ‰¾ã€å»é‡ã€åˆ†å¸ƒç­‰æ“ä½œæ•ˆç‡
3. **ğŸ”¸ è®¾è®¡çµæ´»**ï¼šå¯æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„å“ˆå¸Œç­–ç•¥
4. **ğŸ”¸ æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒå¤§è§„æ¨¡æ•°æ®å’Œé«˜å¹¶å‘åœºæ™¯
5. **ğŸ”¸ å®‰å…¨é‡è¦**ï¼šåœ¨å®‰å…¨é¢†åŸŸå‘æŒ¥å…³é”®ä½œç”¨

### 7.2 åº”ç”¨é€‰æ‹©æŒ‡å—

- **æ•°æ®ç‰¹å¾åˆ†æ**ï¼š
  - æ•°æ®é‡å¤§å°å’Œå¢é•¿è¶‹åŠ¿
  - è®¿é—®æ¨¡å¼å’Œé¢‘ç‡åˆ†å¸ƒ
  - æ•°æ®ç±»å‹å’Œç»“æ„ç‰¹ç‚¹

- **æ€§èƒ½éœ€æ±‚è¯„ä¼°**ï¼š
  - å“åº”æ—¶é—´è¦æ±‚
  - ååé‡ç›®æ ‡
  - å¹¶å‘ç”¨æˆ·æ•°

- **èµ„æºçº¦æŸè€ƒè™‘**ï¼š
  - å†…å­˜é¢„ç®—é™åˆ¶
  - CPUæ€§èƒ½è¦æ±‚
  - ç½‘ç»œå¸¦å®½æˆæœ¬






