---
title: 1ã€æ—¶é—´å¤æ‚åº¦
---
## ğŸ“š ç›®å½•

1. [ä»€ä¹ˆæ˜¯æ—¶é—´å¤æ‚åº¦](#1-ä»€ä¹ˆæ˜¯æ—¶é—´å¤æ‚åº¦)
2. [ä¸ºä»€ä¹ˆéœ€è¦æ—¶é—´å¤æ‚åº¦](#2-ä¸ºä»€ä¹ˆéœ€è¦æ—¶é—´å¤æ‚åº¦)
3. [å¤§Oè¡¨ç¤ºæ³•è¯¦è§£](#3-å¤§Oè¡¨ç¤ºæ³•è¯¦è§£)
4. [å¸¸è§æ—¶é—´å¤æ‚åº¦ç±»å‹](#4-å¸¸è§æ—¶é—´å¤æ‚åº¦ç±»å‹)
5. [æ—¶é—´å¤æ‚åº¦åˆ†ææ–¹æ³•](#5-æ—¶é—´å¤æ‚åº¦åˆ†ææ–¹æ³•)
6. [é€’å½’ç®—æ³•å¤æ‚åº¦åˆ†æ](#6-é€’å½’ç®—æ³•å¤æ‚åº¦åˆ†æ)
7. [å®é™…åº”ç”¨ä¸ä¼˜åŒ–](#7-å®é™…åº”ç”¨ä¸ä¼˜åŒ–)
8. [æ€»ç»“ä¸è¿›é˜¶](#8-æ€»ç»“ä¸è¿›é˜¶)

---

## 1. ğŸ¯ ä»€ä¹ˆæ˜¯æ—¶é—´å¤æ‚åº¦


### 1.1 åŸºæœ¬æ¦‚å¿µ

æ—¶é—´å¤æ‚åº¦ï¼ˆTime Complexityï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç”¨æ¥è¡¡é‡ç®—æ³•æ‰§è¡Œæ—¶é—´éšè¾“å…¥è§„æ¨¡å¢é•¿çš„åº¦é‡æ–¹å¼ã€‚å®ƒä¸å…³æ³¨ç®—æ³•çš„å…·ä½“æ‰§è¡Œæ—¶é—´ï¼Œè€Œæ˜¯å…³æ³¨**æ—¶é—´å¢é•¿çš„è¶‹åŠ¿**ã€‚

### 1.2 ä¸ºä»€ä¹ˆä¸ç›´æ¥æµ‹é‡æ‰§è¡Œæ—¶é—´ï¼Ÿ

```
âŒ ç›´æ¥æµ‹é‡æ—¶é—´çš„é—®é¢˜ï¼š
- ç¡¬ä»¶å·®å¼‚ï¼šä¸åŒæœºå™¨æ€§èƒ½ä¸åŒ
- ç¯å¢ƒå½±å“ï¼šç³»ç»Ÿè´Ÿè½½ã€ç¼–è¯‘å™¨ä¼˜åŒ–
- æ•°æ®ä¾èµ–ï¼šç›¸åŒç®—æ³•åœ¨ä¸åŒæ•°æ®ä¸Šè¡¨ç°ä¸åŒ
- å®ç°å·®å¼‚ï¼šç¼–ç¨‹è¯­è¨€ã€ä»£ç é£æ ¼å½±å“

âœ… æ—¶é—´å¤æ‚åº¦çš„ä¼˜åŠ¿ï¼š
- ç¡¬ä»¶æ— å…³ï¼šåªå…³æ³¨å¢é•¿è¶‹åŠ¿
- å®¢è§‚è¯„ä¼°ï¼šç»Ÿä¸€çš„è¡¡é‡æ ‡å‡†
- é¢„æµ‹æ€§èƒ½ï¼šå¯ä»¥é¢„æµ‹å¤§æ•°æ®é‡ä¸‹çš„è¡¨ç°
- ç®—æ³•æ¯”è¾ƒï¼šä¸åŒç®—æ³•é—´çš„å®¢è§‚æ¯”è¾ƒ
```

### 1.3 æ—¶é—´å¤æ‚åº¦çš„æ•°å­¦æœ¬è´¨

```
è®¾ç®—æ³•å¤„ç†è§„æ¨¡ä¸º n çš„è¾“å…¥éœ€è¦ T(n) æ—¶é—´
æ—¶é—´å¤æ‚åº¦å°±æ˜¯æ‰¾åˆ°å‡½æ•° f(n)ï¼Œä½¿å¾—ï¼š
T(n) = O(f(n))

è¿™æ„å‘³ç€ï¼šå½“ n è¶³å¤Ÿå¤§æ—¶ï¼ŒT(n) çš„å¢é•¿é€Ÿåº¦ä¸è¶…è¿‡ f(n)
```

### 1.4 ä¸¾ä¾‹è¯´æ˜

```java
// ä¾‹1: ç®€å•å¾ªç¯
for (int i = 0; i < n; i++) {
    System.out.println(i);  // æ‰§è¡Œ n æ¬¡
}
// æ—¶é—´å¤æ‚åº¦: O(n)

// ä¾‹2: åµŒå¥—å¾ªç¯
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        System.out.println(i + j);  // æ‰§è¡Œ nÃ—n æ¬¡
    }
}
// æ—¶é—´å¤æ‚åº¦: O(nÂ²)

// ä¾‹3: å¸¸æ•°æ—¶é—´æ“ä½œ
int result = arr[0] + arr[1];  // æ‰§è¡Œ 1 æ¬¡
// æ—¶é—´å¤æ‚åº¦: O(1)
```

---

## 2. ğŸ¤” ä¸ºä»€ä¹ˆéœ€è¦æ—¶é—´å¤æ‚åº¦


### 2.1 è§£å†³çš„æ ¸å¿ƒé—®é¢˜

```
ğŸ”¸ ç®—æ³•é€‰æ‹©ï¼šåœ¨å¤šä¸ªè§£å†³æ–¹æ¡ˆä¸­é€‰æ‹©æœ€ä¼˜çš„
ğŸ”¸ æ€§èƒ½é¢„æµ‹ï¼šé¢„æµ‹ç®—æ³•åœ¨å¤§æ•°æ®é‡ä¸‹çš„è¡¨ç°
ğŸ”¸ èµ„æºè§„åˆ’ï¼šä¼°ç®—æ‰€éœ€çš„è®¡ç®—èµ„æº
ğŸ”¸ ç³»ç»Ÿè®¾è®¡ï¼šæŒ‡å¯¼ç³»ç»Ÿæ¶æ„å’Œä¼˜åŒ–å†³ç­–
```

### 2.2 å®é™…åº”ç”¨åœºæ™¯

```
åœºæ™¯1: æœç´¢å¼•æ“
- æ•°æ®é‡ï¼šæ•°åäº¿ä¸ªç½‘é¡µ
- è¦æ±‚ï¼šæ¯«ç§’çº§å“åº”
- å¤æ‚åº¦è¦æ±‚ï¼šO(log n) æˆ–æ›´å¥½

åœºæ™¯2: ç¤¾äº¤ç½‘ç»œ
- æ•°æ®é‡ï¼šæ•°äº¿ç”¨æˆ·å…³ç³»
- è¦æ±‚ï¼šå®æ—¶æ¨è
- å¤æ‚åº¦è¦æ±‚ï¼šå°½å¯èƒ½ä½çš„çº¿æ€§å¤æ‚åº¦

åœºæ™¯3: é‡‘èäº¤æ˜“
- æ•°æ®é‡ï¼šæµ·é‡äº¤æ˜“è®°å½•
- è¦æ±‚ï¼šå®æ—¶é£æ§
- å¤æ‚åº¦è¦æ±‚ï¼šäºšçº¿æ€§å¤æ‚åº¦
```

### 2.3 ä¸åŒå¤æ‚åº¦çš„å®é™…è¡¨ç°

```
è¾“å…¥è§„æ¨¡ n = 1,000,000 æ—¶ï¼š
O(1):        1 æ¬¡æ“ä½œ
O(log n):    ~20 æ¬¡æ“ä½œ
O(n):        1,000,000 æ¬¡æ“ä½œ
O(n log n):  ~20,000,000 æ¬¡æ“ä½œ
O(nÂ²):       1,000,000,000,000 æ¬¡æ“ä½œ (ä¸å¯æ¥å—)
O(2â¿):       æ— æ³•è®¡ç®— (ä¸å¯æ¥å—)
```

---

## 3. ğŸ“ å¤§Oè¡¨ç¤ºæ³•è¯¦è§£


### 3.1 æ•°å­¦å®šä¹‰

```
å¤§Oè¡¨ç¤ºæ³• (Big O Notation)ï¼š
å¯¹äºå‡½æ•° f(n) å’Œ g(n)ï¼Œå¦‚æœå­˜åœ¨æ­£å¸¸æ•° c å’Œ nâ‚€ï¼Œ
ä½¿å¾—å½“ n â‰¥ nâ‚€ æ—¶ï¼Œæœ‰ f(n) â‰¤ cÂ·g(n)ï¼Œ
åˆ™ç§° f(n) = O(g(n))

ç›´è§‚ç†è§£ï¼š
- g(n) æ˜¯ f(n) çš„ä¸Šç•Œ
- å½“ n è¶³å¤Ÿå¤§æ—¶ï¼Œf(n) çš„å¢é•¿ä¸ä¼šè¶…è¿‡ g(n)
- æˆ‘ä»¬åªå…³å¿ƒæœ€é«˜é˜¶é¡¹
```

### 3.2 å…¶ä»–æ¸è¿‘è®°å·

```
å¤§Î©è¡¨ç¤ºæ³• (Big Omega)ï¼šä¸‹ç•Œ
- f(n) = Î©(g(n)) è¡¨ç¤º f(n) å¢é•¿ä¸æ…¢äº g(n)

å¤§Î˜è¡¨ç¤ºæ³• (Big Theta)ï¼šç´§ç•Œ
- f(n) = Î˜(g(n)) è¡¨ç¤º f(n) ä¸ g(n) åŒé˜¶å¢é•¿
- å½“ä¸”ä»…å½“ f(n) = O(g(n)) ä¸” f(n) = Î©(g(n))

å°oè¡¨ç¤ºæ³• (Little o)ï¼šä¸¥æ ¼ä¸Šç•Œ
- f(n) = o(g(n)) è¡¨ç¤º f(n) å¢é•¿ä¸¥æ ¼æ…¢äº g(n)
```

### 3.3 å¤æ‚åº¦è®¡ç®—è§„åˆ™

```
ğŸ”¸ å¸¸æ•°å¿½ç•¥ï¼šO(5n) = O(n)
ğŸ”¸ æœ€é«˜é˜¶ä¼˜å…ˆï¼šO(nÂ² + n + 1) = O(nÂ²)
ğŸ”¸ åŠ æ³•è§„åˆ™ï¼šO(f(n)) + O(g(n)) = O(max(f(n), g(n)))
ğŸ”¸ ä¹˜æ³•è§„åˆ™ï¼šO(f(n)) Ã— O(g(n)) = O(f(n) Ã— g(n))
ğŸ”¸ å¯¹æ•°åº•æ•°å¿½ç•¥ï¼šO(logâ‚‚ n) = O(logâ‚â‚€ n) = O(log n)
```

### 3.4 è®¡ç®—ç¤ºä¾‹

```java
// ç¤ºä¾‹1: è¿ç»­è¯­å¥
int sum = 0;           // O(1)
for (int i = 0; i < n; i++) {  // O(n)
    sum += i;
}
for (int i = 0; i < n; i++) {  // O(n)
    sum *= 2;
}
// æ€»å¤æ‚åº¦: O(1) + O(n) + O(n) = O(n)

// ç¤ºä¾‹2: åµŒå¥—ç»“æ„
for (int i = 0; i < n; i++) {          // å¤–å±‚ O(n)
    for (int j = 0; j < n; j++) {      // å†…å±‚ O(n)
        if (i == j) {                   // O(1)
            System.out.println("Match");
        }
    }
}
// æ€»å¤æ‚åº¦: O(n) Ã— O(n) Ã— O(1) = O(nÂ²)

// ç¤ºä¾‹3: å¤æ‚åµŒå¥—
for (int i = 0; i < n; i++) {          // O(n)
    for (int j = i; j < n; j++) {      // O(n-i) å¹³å‡ O(n/2)
        // æ“ä½œ
    }
}
// åˆ†æ: å†…å±‚å¾ªç¯æ€»æ¬¡æ•° = n + (n-1) + ... + 1 = n(n+1)/2
// æ€»å¤æ‚åº¦: O(nÂ²)
```

---

## 4. ğŸ“Š å¸¸è§æ—¶é—´å¤æ‚åº¦ç±»å‹


### 4.1 å¸¸æ•°æ—¶é—´ O(1)

```
ç‰¹ç‚¹ï¼š
- æ‰§è¡Œæ—¶é—´ä¸è¾“å…¥è§„æ¨¡æ— å…³
- æœ€ç†æƒ³çš„æ—¶é—´å¤æ‚åº¦
- é€šå¸¸æ¶‰åŠåŸºæœ¬æ“ä½œ

å…¸å‹æ“ä½œï¼š
- æ•°ç»„æŒ‰ç´¢å¼•è®¿é—®: arr[i]
- å“ˆå¸Œè¡¨æŸ¥æ‰¾: map.get(key)
- æ ˆçš„push/popæ“ä½œ
- åŸºæœ¬ç®—æœ¯è¿ç®—
```

```java
// O(1) ç¤ºä¾‹
public class ConstantTime {
    public int getFirst(int[] arr) {
        return arr[0];  // æ— è®ºæ•°ç»„å¤šå¤§ï¼Œéƒ½æ˜¯ä¸€æ¬¡è®¿é—®
    }
    
    public void swapElements(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        // å›ºå®šçš„3æ¬¡èµ‹å€¼æ“ä½œ
    }
    
    public boolean isEmpty(List<Integer> list) {
        return list.size() == 0;  // ç°ä»£å®ç°ä¸­sizeé€šå¸¸æ˜¯O(1)
    }
}
```

### 4.2 å¯¹æ•°æ—¶é—´ O(log n)

```
ç‰¹ç‚¹ï¼š
- æ¯æ¬¡æ“ä½œéƒ½èƒ½æ’é™¤ä¸€åŠå¯èƒ½æ€§
- å¢é•¿æå…¶ç¼“æ…¢
- é€šå¸¸å‡ºç°åœ¨åˆ†æ²»ç®—æ³•ä¸­

å…¸å‹ç®—æ³•ï¼š
- äºŒåˆ†æŸ¥æ‰¾
- å¹³è¡¡äºŒå‰æœç´¢æ ‘æ“ä½œ
- å †çš„æ’å…¥å’Œåˆ é™¤
- æŸäº›æ•°å­¦è®¡ç®—
```

```java
// O(log n) ç¤ºä¾‹
public class LogarithmicTime {
    
    // äºŒåˆ†æŸ¥æ‰¾
    public int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;     // æ’é™¤å·¦åŠéƒ¨åˆ†
            } else {
                right = mid - 1;    // æ’é™¤å³åŠéƒ¨åˆ†
            }
        }
        
        return -1;
    }
    
    // å¿«é€Ÿå¹‚è¿ç®—
    public long power(long base, int exp) {
        long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result *= base;
            }
            base *= base;
            exp /= 2;  // æ¯æ¬¡å‡åŠ
        }
        return result;
    }
}
```

### 4.3 çº¿æ€§æ—¶é—´ O(n)

```
ç‰¹ç‚¹ï¼š
- æ‰§è¡Œæ—¶é—´ä¸è¾“å…¥è§„æ¨¡æˆæ­£æ¯”
- é€šå¸¸éœ€è¦éå†æ‰€æœ‰å…ƒç´ 
- è®¸å¤šé—®é¢˜çš„ç†è®ºä¸‹ç•Œ

å…¸å‹ç®—æ³•ï¼š
- æ•°ç»„éå†
- é“¾è¡¨æ“ä½œ
- ç®€å•æ’åºï¼ˆå†’æ³¡ã€é€‰æ‹©ã€æ’å…¥ï¼‰
- çº¿æ€§æœç´¢
```

```java
// O(n) ç¤ºä¾‹
public class LinearTime {
    
    // æ•°ç»„æ±‚å’Œ
    public int arraySum(int[] arr) {
        int sum = 0;
        for (int num : arr) {  // éå†æ¯ä¸ªå…ƒç´ ä¸€æ¬¡
            sum += num;
        }
        return sum;
    }
    
    // æŸ¥æ‰¾æœ€å¤§å€¼
    public int findMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }
    
    // å­—ç¬¦ä¸²åŒ¹é…ï¼ˆæœ´ç´ ç®—æ³•ï¼‰
    public int stringMatch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            if (text.substring(i, i + m).equals(pattern)) {
                return i;
            }
        }
        return -1;
    }
}
```

### 4.4 çº¿æ€§å¯¹æ•°æ—¶é—´ O(n log n)

```
ç‰¹ç‚¹ï¼š
- è®¸å¤šé«˜æ•ˆç®—æ³•çš„å¤æ‚åº¦
- é€šå¸¸å‡ºç°åœ¨åˆ†æ²»ç®—æ³•ä¸­
- æ˜¯æ¯”è¾ƒæ’åºçš„ç†è®ºä¸‹ç•Œ

å…¸å‹ç®—æ³•ï¼š
- å½’å¹¶æ’åº
- å¿«é€Ÿæ’åºï¼ˆå¹³å‡æƒ…å†µï¼‰
- å †æ’åº
- æœ€è¿‘ç‚¹å¯¹é—®é¢˜
```

```java
// O(n log n) ç¤ºä¾‹
public class LinearLogTime {
    
    // å½’å¹¶æ’åº
    public void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            
            mergeSort(arr, left, mid);      // T(n/2)
            mergeSort(arr, mid + 1, right); // T(n/2)
            merge(arr, left, mid, right);   // O(n)
        }
        // é€’æ¨å…³ç³»: T(n) = 2T(n/2) + O(n) = O(n log n)
    }
    
    private void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];
        
        for (i = left; i <= right; i++) {
            arr[i] = temp[i - left];
        }
    }
}
```

### 4.5 å¹³æ–¹æ—¶é—´ O(nÂ²)

```
ç‰¹ç‚¹ï¼š
- é€šå¸¸æ¶‰åŠåŒé‡å¾ªç¯
- å°è§„æ¨¡æ•°æ®å¯æ¥å—ï¼Œå¤§è§„æ¨¡æ•°æ®æ€§èƒ½å·®
- è®¸å¤šæœ´ç´ ç®—æ³•çš„å¤æ‚åº¦

å…¸å‹ç®—æ³•ï¼š
- å†’æ³¡æ’åº
- é€‰æ‹©æ’åº
- æ’å…¥æ’åº
- æœ´ç´ å­—ç¬¦ä¸²åŒ¹é…
```

```java
// O(nÂ²) ç¤ºä¾‹
public class QuadraticTime {
    
    // å†’æ³¡æ’åº
    public void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {        // å¤–å±‚å¾ªç¯ n-1 æ¬¡
            for (int j = 0; j < n - 1 - i; j++) { // å†…å±‚å¾ªç¯ n-1-i æ¬¡
                if (arr[j] > arr[j + 1]) {
                    // äº¤æ¢
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        // æ€»æ¯”è¾ƒæ¬¡æ•°: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(nÂ²)
    }
    
    // æŸ¥æ‰¾é‡å¤å…ƒç´ å¯¹
    public List<int[]> findDuplicates(int[] arr) {
        List<int[]> duplicates = new ArrayList<>();
        
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    duplicates.add(new int[]{i, j});
                }
            }
        }
        
        return duplicates;
    }
}
```

### 4.6 æŒ‡æ•°æ—¶é—´ O(2â¿)

```
ç‰¹ç‚¹ï¼š
- å¢é•¿æå…¶å¿«é€Ÿ
- é€šå¸¸åªèƒ½å¤„ç†å°è§„æ¨¡æ•°æ®
- å¸¸è§äºæš´åŠ›æœç´¢å’ŒæŸäº›é€’å½’ç®—æ³•

å…¸å‹ç®—æ³•ï¼š
- æ±‰è¯ºå¡”é—®é¢˜
- å­é›†ç”Ÿæˆ
- æœ´ç´ é€’å½’æ–æ³¢é‚£å¥‘
- æ—…è¡Œå•†é—®é¢˜ï¼ˆæš´åŠ›è§£æ³•ï¼‰
```

```java
// O(2â¿) ç¤ºä¾‹
public class ExponentialTime {
    
    // æœ´ç´ é€’å½’æ–æ³¢é‚£å¥‘
    public int fibonacci(int n) {
        if (n <= 1) return n;
        
        return fibonacci(n - 1) + fibonacci(n - 2);
        // æ¯æ¬¡è°ƒç”¨äº§ç”Ÿä¸¤ä¸ªå­è°ƒç”¨ï¼Œå½¢æˆäºŒå‰æ ‘
        // æ ‘çš„æ·±åº¦ä¸º nï¼ŒèŠ‚ç‚¹æ•°çº¦ä¸º 2â¿
    }
    
    // ç”Ÿæˆæ‰€æœ‰å­é›†
    public List<List<Integer>> generateSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        generateSubsetsHelper(nums, 0, new ArrayList<>(), result);
        return result;
    }
    
    private void generateSubsetsHelper(int[] nums, int index, 
                                     List<Integer> current, 
                                     List<List<Integer>> result) {
        if (index == nums.length) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        // ä¸åŒ…å«å½“å‰å…ƒç´ 
        generateSubsetsHelper(nums, index + 1, current, result);
        
        // åŒ…å«å½“å‰å…ƒç´ 
        current.add(nums[index]);
        generateSubsetsHelper(nums, index + 1, current, result);
        current.remove(current.size() - 1);
    }
}
```

---

## 5. ğŸ” æ—¶é—´å¤æ‚åº¦åˆ†ææ–¹æ³•


### 5.1 åŸºæœ¬åˆ†ææ­¥éª¤

```
æ­¥éª¤1: è¯†åˆ«åŸºæœ¬æ“ä½œ
- æ‰¾å‡ºç®—æ³•ä¸­æœ€é¢‘ç¹æ‰§è¡Œçš„æ“ä½œ
- é€šå¸¸æ˜¯æœ€å†…å±‚å¾ªç¯ä¸­çš„æ“ä½œ

æ­¥éª¤2: åˆ†æå¾ªç¯ç»“æ„
- è®¡ç®—æ¯ä¸ªå¾ªç¯çš„æ‰§è¡Œæ¬¡æ•°
- åˆ†æåµŒå¥—å¾ªç¯çš„å…³ç³»

æ­¥éª¤3: å¤„ç†é€’å½’è°ƒç”¨
- å»ºç«‹é€’æ¨å…³ç³»
- ä½¿ç”¨ä¸»å®šç†æˆ–å…¶ä»–æ–¹æ³•æ±‚è§£

æ­¥éª¤4: ç»¼åˆåˆ†æ
- è€ƒè™‘æœ€å¥½ã€å¹³å‡ã€æœ€åæƒ…å†µ
- é€‰æ‹©åˆé€‚çš„å¤æ‚åº¦è¡¨ç¤º
```

### 5.2 å¾ªç¯åˆ†ææŠ€å·§

```java
// æŠ€å·§1: ç®€å•å¾ªç¯
for (int i = 0; i < n; i++) {
    // åŸºæœ¬æ“ä½œ
}
// åˆ†æ: å¾ªç¯ n æ¬¡ï¼Œå¤æ‚åº¦ O(n)

// æŠ€å·§2: åµŒå¥—å¾ªç¯
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // åŸºæœ¬æ“ä½œ
    }
}
// åˆ†æ: å¤–å±‚ n æ¬¡ï¼Œå†…å±‚æ¯æ¬¡ n æ¬¡ï¼Œæ€»è®¡ nÂ² æ¬¡ï¼Œå¤æ‚åº¦ O(nÂ²)

// æŠ€å·§3: ä¾èµ–æ€§å¾ªç¯
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        // åŸºæœ¬æ“ä½œ
    }
}
// åˆ†æ: 
// i=0: j ä» 0 åˆ° n-1ï¼Œn æ¬¡
// i=1: j ä» 1 åˆ° n-1ï¼Œn-1 æ¬¡
// ...
// i=n-1: j ä» n-1 åˆ° n-1ï¼Œ1 æ¬¡
// æ€»è®¡: n + (n-1) + ... + 1 = n(n+1)/2 = O(nÂ²)

// æŠ€å·§4: å¯¹æ•°å¾ªç¯
for (int i = 1; i < n; i *= 2) {
    // åŸºæœ¬æ“ä½œ
}
// åˆ†æ: i çš„å€¼ä¸º 1, 2, 4, 8, ..., ç›´åˆ° >= n
// å¾ªç¯æ¬¡æ•°ä¸º logâ‚‚(n)ï¼Œå¤æ‚åº¦ O(log n)

// æŠ€å·§5: åˆ†æ²»ç»“æ„
void divide(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        divide(arr, left, mid);      // T(n/2)
        divide(arr, mid + 1, right); // T(n/2)
        // åˆå¹¶æ“ä½œ O(n)
    }
}
// é€’æ¨å…³ç³»: T(n) = 2T(n/2) + O(n)
// è§£: T(n) = O(n log n)
```

### 5.3 æœ€å¥½ã€å¹³å‡ã€æœ€åæƒ…å†µåˆ†æ

```java
// ä»¥å¿«é€Ÿæ’åºä¸ºä¾‹
public class QuickSortAnalysis {
    
    public void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    /*
    æ—¶é—´å¤æ‚åº¦åˆ†æ:
    
    æœ€å¥½æƒ…å†µ: æ¯æ¬¡åˆ’åˆ†éƒ½å‡åŒ€
    - é€’æ¨å…³ç³»: T(n) = 2T(n/2) + O(n)
    - è§£: T(n) = O(n log n)
    
    å¹³å‡æƒ…å†µ: åˆ’åˆ†ç›¸å¯¹å‡åŒ€
    - æ•°å­¦æœŸæœ›åˆ†æ: E[T(n)] = O(n log n)
    
    æœ€åæƒ…å†µ: æ¯æ¬¡åˆ’åˆ†æä¸å‡åŒ€
    - é€’æ¨å…³ç³»: T(n) = T(n-1) + O(n)
    - è§£: T(n) = O(nÂ²)
    - å‘ç”Ÿæ¡ä»¶: æ•°ç»„å·²æ’åºæˆ–é€†åº
    */
}
```

### 5.4 æ‘Šè¿˜åˆ†ææ³•

```java
// åŠ¨æ€æ•°ç»„æ‰©å®¹åˆ†æ
public class DynamicArrayAnalysis {
    private int[] arr;
    private int size;
    private int capacity;
    
    public DynamicArrayAnalysis() {
        capacity = 1;
        arr = new int[capacity];
        size = 0;
    }
    
    public void add(int value) {
        if (size == capacity) {
            resize();  // å¶å°”è§¦å‘ï¼Œä»£ä»·é«˜
        }
        arr[size++] = value;  // é€šå¸¸æƒ…å†µï¼Œä»£ä»·ä½
    }
    
    private void resize() {
        capacity *= 2;
        int[] newArr = new int[capacity];
        System.arraycopy(arr, 0, newArr, 0, size);
        arr = newArr;
    }
    
    /*
    æ‘Šè¿˜åˆ†æ:
    - å•æ¬¡addæ“ä½œ: é€šå¸¸O(1)ï¼Œå¶å°”O(n)
    - æ‘Šè¿˜ä»£ä»·: æ¯æ¬¡æ‰©å®¹åï¼Œéœ€è¦sizeæ¬¡æ™®é€šæ’å…¥æ‰ä¼šå†æ¬¡æ‰©å®¹
    - æ€»ä»£ä»·: næ¬¡æ’å…¥ + O(log n)æ¬¡æ‰©å®¹ Ã— æ¯æ¬¡O(n) = O(n)
    - æ‘Šè¿˜å¤æ‚åº¦: O(n)/n = O(1)
    */
}
```

---

## 6. ğŸŒ³ é€’å½’ç®—æ³•å¤æ‚åº¦åˆ†æ


### 6.1 é€’å½’å¤æ‚åº¦çš„åŸºæœ¬æ€è·¯

```
é€’å½’ç®—æ³•å¤æ‚åº¦åˆ†æçš„æ ¸å¿ƒ:
1. å»ºç«‹é€’æ¨å…³ç³» T(n)
2. ç¡®å®šåŸºç¡€æƒ…å†µ T(1) æˆ– T(0)
3. è§£é€’æ¨å…³ç³»

é€šç”¨å½¢å¼: T(n) = aT(n/b) + f(n)
å…¶ä¸­:
- a: å­é—®é¢˜ä¸ªæ•°
- n/b: å­é—®é¢˜è§„æ¨¡
- f(n): åˆ†è§£å’Œåˆå¹¶çš„ä»£ä»·
```

### 6.2 ä¸»å®šç†ï¼ˆMaster Theoremï¼‰

```
å¯¹äºé€’æ¨å…³ç³» T(n) = aT(n/b) + f(n)ï¼Œå…¶ä¸­ a â‰¥ 1, b > 1:

æƒ…å†µ1: å¦‚æœ f(n) = O(n^c)ï¼Œä¸” c < log_b(a)
       åˆ™ T(n) = Î˜(n^log_b(a))

æƒ…å†µ2: å¦‚æœ f(n) = Î˜(n^log_b(a))
       åˆ™ T(n) = Î˜(n^log_b(a) Ã— log n)

æƒ…å†µ3: å¦‚æœ f(n) = Î©(n^c)ï¼Œä¸” c > log_b(a)ï¼Œ
       ä¸” af(n/b) â‰¤ kf(n) å¯¹æŸä¸ªå¸¸æ•° k < 1
       åˆ™ T(n) = Î˜(f(n))
```

### 6.3 ä¸»å®šç†åº”ç”¨å®ä¾‹

```java
// å®ä¾‹1: å½’å¹¶æ’åº
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);        // T(n/2)
        mergeSort(arr, mid + 1, right);   // T(n/2)
        merge(arr, left, mid, right);     // O(n)
    }
}

/*
é€’æ¨å…³ç³»: T(n) = 2T(n/2) + O(n)
ä¸»å®šç†åˆ†æ:
- a = 2, b = 2, f(n) = O(n)
- log_b(a) = log_2(2) = 1
- f(n) = O(n^1) = Î˜(n^log_b(a))
- ç¬¦åˆæƒ…å†µ2: T(n) = Î˜(n log n)
*/

// å®ä¾‹2: äºŒåˆ†æŸ¥æ‰¾
int binarySearch(int[] arr, int target, int left, int right) {
    if (left > right) return -1;
    
    int mid = (left + right) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) 
        return binarySearch(arr, target, mid + 1, right);  // T(n/2)
    else 
        return binarySearch(arr, target, left, mid - 1);   // T(n/2)
}

/*
é€’æ¨å…³ç³»: T(n) = T(n/2) + O(1)
ä¸»å®šç†åˆ†æ:
- a = 1, b = 2, f(n) = O(1)
- log_b(a) = log_2(1) = 0
- f(n) = O(1) = Î˜(n^0) = Î˜(n^log_b(a))
- ç¬¦åˆæƒ…å†µ2: T(n) = Î˜(log n)
*/

// å®ä¾‹3: æœ´ç´ é€’å½’æ–æ³¢é‚£å¥‘
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

/*
é€’æ¨å…³ç³»: T(n) = T(n-1) + T(n-2) + O(1)
è¿™ä¸ç¬¦åˆä¸»å®šç†çš„å½¢å¼ï¼Œéœ€è¦å…¶ä»–æ–¹æ³•åˆ†æ
é€šè¿‡ç‰¹å¾æ–¹ç¨‹å¯ä»¥è¯æ˜: T(n) = O(Ï†^n)ï¼Œå…¶ä¸­ Ï† = (1+âˆš5)/2 â‰ˆ 1.618
*/
```

### 6.4 é€’å½’æ ‘åˆ†ææ³•

```java
// ä»¥å½’å¹¶æ’åºä¸ºä¾‹
/*
é€’å½’æ ‘åˆ†æ:
                    T(n)
                   /    \
               T(n/2)    T(n/2)
              /    \    /    \
          T(n/4) T(n/4) T(n/4) T(n/4)
           ...

æ¯å±‚åˆ†æ:
- ç¬¬0å±‚: 1ä¸ªèŠ‚ç‚¹ï¼Œä»£ä»· cn
- ç¬¬1å±‚: 2ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªä»£ä»· cn/2ï¼Œæ€»ä»£ä»· cn
- ç¬¬2å±‚: 4ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªä»£ä»· cn/4ï¼Œæ€»ä»£ä»· cn
- ...
- ç¬¬iå±‚: 2^iä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªä»£ä»· cn/2^iï¼Œæ€»ä»£ä»· cn

æ ‘çš„æ·±åº¦: logâ‚‚(n)
æ€»ä»£ä»·: cn Ã— logâ‚‚(n) = O(n log n)
*/

// é€’å½’æ ‘å¯è§†åŒ–ä»£ç 
public class RecursionTreeVisualizer {
    public static void visualizeMergeSort(int n, int depth) {
        if (n <= 1) return;
        
        // æ‰“å°å½“å‰å±‚çº§
        System.out.println("  ".repeat(depth) + "T(" + n + ")");
        
        // é€’å½’å­é—®é¢˜
        visualizeMergeSort(n / 2, depth + 1);
        visualizeMergeSort(n / 2, depth + 1);
    }
}
```

### 6.5 é€’å½’ä¼˜åŒ–æŠ€å·§

```java
// æŠ€å·§1: è®°å¿†åŒ–æœç´¢
public class OptimizedRecursion {
    private Map<Integer, Integer> memo = new HashMap<>();
    
    // ä¼˜åŒ–åçš„æ–æ³¢é‚£å¥‘
    public int fibonacciMemo(int n) {
        if (n <= 1) return n;
        
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        
        int result = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
        memo.put(n, result);
        return result;
    }
    // æ—¶é—´å¤æ‚åº¦ä» O(2^n) ä¼˜åŒ–åˆ° O(n)
    
    // æŠ€å·§2: å°¾é€’å½’ä¼˜åŒ–
    public int factorialTailRecursive(int n) {
        return factorialHelper(n, 1);
    }
    
    private int factorialHelper(int n, int accumulator) {
        if (n == 0) return accumulator;
        return factorialHelper(n - 1, n * accumulator);
    }
    // å°¾é€’å½’å¯ä»¥è¢«ç¼–è¯‘å™¨ä¼˜åŒ–ä¸ºå¾ªç¯
    
    // æŠ€å·§3: è¿­ä»£æ›¿ä»£é€’å½’
    public int fibonacciIterative(int n) {
        if (n <= 1) return n;
        
        int prev2 = 0, prev1 = 1;
        for (int i = 2; i <= n; i++) {
            int current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        return prev1;
    }
    // ç©ºé—´å¤æ‚åº¦ä» O(n) ä¼˜åŒ–åˆ° O(1)
}
```

---

## 7. ğŸš€ å®é™…åº”ç”¨ä¸ä¼˜åŒ–


### 7.1 æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

```java
// æ€§èƒ½åˆ†æå·¥å…·ç±»
public class PerformanceAnalyzer {
    
    public static void analyzeAlgorithm(String name, Runnable algorithm) {
        long startTime = System.nanoTime();
        algorithm.run();
        long endTime = System.nanoTime();
        
        long duration = endTime - startTime;
        System.out.println(name + " æ‰§è¡Œæ—¶é—´: " + duration + " çº³ç§’");
    }
    
    public static void compareAlgorithms() {
        int[] data = generateRandomArray(10000);
        
        // æ¯”è¾ƒä¸åŒæ’åºç®—æ³•
        analyzeAlgorithm("å†’æ³¡æ’åº", () -> bubbleSort(data.clone()));
        analyzeAlgorithm("å¿«é€Ÿæ’åº", () -> quickSort(data.clone()));
        analyzeAlgorithm("å½’å¹¶æ’åº", () -> mergeSort(data.clone()));
        
        // æ¯”è¾ƒä¸åŒæŸ¥æ‰¾ç®—æ³•
        Arrays.sort(data);
        int target = data[data.length / 2];
        
        analyzeAlgorithm("çº¿æ€§æŸ¥æ‰¾", () -> linearSearch(data, target));
        analyzeAlgorithm("äºŒåˆ†æŸ¥æ‰¾", () -> binarySearch(data, target));
    }
}
```

### 7.2 å¸¸è§ä¼˜åŒ–ç­–ç•¥

```java
public class OptimizationStrategies {
    
    // ç­–ç•¥1: é¢„å¤„ç†ä¼˜åŒ–
    public class RangeQueryOptimizer {
        private int[] prefixSum;
        
        // é¢„å¤„ç†: O(n)
        public RangeQueryOptimizer(int[] arr) {
            prefixSum = new int[arr.length + 1];
            for (int i = 0; i < arr.length; i++) {
                prefixSum[i + 1] = prefixSum[i] + arr[i];
            }
        }
        
        // æŸ¥è¯¢: O(1)
        public int rangeSum(int left, int right) {
            return prefixSum[right + 1] - prefixSum[left];
        }
        
        // ä¼˜åŒ–æ•ˆæœ: å¤šæ¬¡æŸ¥è¯¢ä» O(n) é™åˆ° O(1)
    }
    
    // ç­–ç•¥2: ç©ºé—´æ¢æ—¶é—´
    public class FibonacciOptimizer {
        private static final Map<Integer, Long> cache = new HashMap<>();
        
        static {
            cache.put(0, 0L);
            cache.put(1, 1L);
        }
        
        public long fibonacci(int n) {
            if (cache.containsKey(n)) {
                return cache.get(n);
            }
            
            long result = fibonacci(n - 1) + fibonacci(n - 2);
            cache.put(n, result);
            return result;
        }
    }
    
    // ç­–ç•¥3: ç®—æ³•é€‰æ‹©ä¼˜åŒ–
    public class AdaptiveSort {
        private static final int INSERTION_SORT_THRESHOLD = 10;
        
        public void adaptiveSort(int[] arr, int left, int right) {
            if (right - left <= INSERTION_SORT_THRESHOLD) {
                insertionSort(arr, left, right);  // å°æ•°ç»„ç”¨æ’å…¥æ’åº
            } else {
                quickSort(arr, left, right);      // å¤§æ•°ç»„ç”¨å¿«é€Ÿæ’åº
            }
        }
        
        private void insertionSort(int[] arr, int left, int right) {
            for (int i = left + 1; i <= right; i++) {
                int key = arr[i];
                int j = i - 1;
                while (j >= left && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                arr[j + 1] = key;
            }
        }
    }
    
    // ç­–ç•¥4: æ•°æ®ç»“æ„ä¼˜åŒ–
    public class OptimizedDataStructure {
        
        // ä½¿ç”¨æ›´é«˜æ•ˆçš„æ•°æ®ç»“æ„
        public List<Integer> findDuplicatesOptimized(int[] arr) {
            Set<Integer> seen = new HashSet<>();
            List<Integer> duplicates = new ArrayList<>();
            
            for (int num : arr) {
                if (seen.contains(num)) {
                    duplicates.add(num);
                } else {
                    seen.add(num);
                }
            }
            
            return duplicates;
            // ä» O(nÂ²) ä¼˜åŒ–åˆ° O(n)
        }
    }
}
```

### 7.3 å¤æ‚åº¦ä¸å®é™…æ€§èƒ½çš„å…³ç³»

```java
public class ComplexityVsPerformance {
    
    // ç†è®ºå¤æ‚åº¦ vs å®é™…æ€§èƒ½
    public static void demonstrateComplexityImpact() {
        int[] sizes = {1000, 10000, 100000};
        
        for (int size : sizes) {
            System.out.println("æ•°æ®è§„æ¨¡: " + size);
            
            // O(n) ç®—æ³•
            long start = System.nanoTime();
            linearTimeAlgorithm(size);
            long linear = System.nanoTime() - start;
            
            // O(n log n) ç®—æ³•
            start = System.nanoTime();
            nlogn_algorithm(size);
            long nlogn = System.nanoTime() - start;
            
            // O(nÂ²) ç®—æ³•
            start = System.nanoTime();
            quadraticAlgorithm(size);
            long quadratic = System.nanoTime() - start;
            
            System.out.println("O(n): " + linear + " ns");
            System.out.println("O(n log n): " + nlogn + " ns");
            System.out.println("O(nÂ²): " + quadratic + " ns");
            System.out.println("æ¯”ç‡ (nÂ²/n): " + (quadratic * 1.0 / linear));
            System.out.println("---");
        }
    }
    
    // å¸¸æ•°å› å­çš„å½±å“
    public static void demonstrateConstantFactors() {
        int[] arr = generateRandomArray(10000);
        
        // ç®—æ³•A: 2n æ“ä½œ
        long start = System.nanoTime();
        algorithmA(arr);
        long timeA = System.nanoTime() - start;
        
        // ç®—æ³•B: 100n æ“ä½œ
        start = System.nanoTime();
        algorithmB(arr);
        long timeB = System.nanoTime() - start;
        
        System.out.println("ç®—æ³•A (2n): " + timeA + " ns");
        System.out.println("ç®—æ³•B (100n): " + timeB + " ns");
        System.out.println("è™½ç„¶éƒ½æ˜¯O(n)ï¼Œä½†å®é™…æ€§èƒ½å·®å¼‚: " + (timeB * 1.0 / timeA));
    }
}
```

### 7.4 å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨

```java
// å®é™…é¡¹ç›®ç¤ºä¾‹: æœç´¢å¼•æ“
public class SearchEngine {
    
    // å€’æ’ç´¢å¼•: é¢„å¤„ç† O(n)ï¼ŒæŸ¥è¯¢ O(1)
    private Map<String, List<Document>> invertedIndex;
    
    // æ„å»ºç´¢å¼•
    public void buildIndex(List<Document> documents) {
        invertedIndex = new HashMap<>();
        
        for (Document doc : documents) {
            for (String word : doc.getWords()) {
                invertedIndex.computeIfAbsent(word, k -> new ArrayList<>()).add(doc);
            }
        }
    }
    
    // æœç´¢: O(1) æŸ¥æ‰¾ + O(ç»“æœæ•°é‡)
    public List<Document> search(String query) {
        return invertedIndex.getOrDefault(query, new ArrayList<>());
    }
    
    // å¤æ‚æŸ¥è¯¢: äº¤é›†æ“ä½œ
    public List<Document> searchMultipleWords(String[] words) {
        if (words.length == 0) return new ArrayList<>();
        
        List<Document> result = new ArrayList<>(search(words[0]));
        
        for (int i = 1; i < words.length; i++) {
            List<Document> current = search(words[i]);
            result.retainAll(current);  // æ±‚äº¤é›†
        }
        
        return result;
    }
}

// ç¼“å­˜ç³»ç»Ÿ: LRU Cache
public class LRUCache<K, V> {
    private final int capacity;
    private final Map<K, Node<K, V>> cache;
    private final Node<K, V> head;
    private final Node<K, V> tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.head = new Node<>(null, null);
        this.tail = new Node<>(null, null);
        head.next = tail;
        tail.prev = head;
    }
    
    // è·å–: O(1)
    public V get(K key) {
        Node<K, V> node = cache.get(key);
        if (node == null) return null;
        
        moveToHead(node);
        return node.value;
    }
    
    // æ”¾ç½®: O(1)
    public void put(K key, V value) {
        Node<K, V> node = cache.get(key);
        
        if (node != null) {
            node.value = value;
            moveToHead(node);
        } else {
            Node<K, V> newNode = new Node<>(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
            
            if (cache.size() > capacity) {
                Node<K, V> removed = removeTail();
                cache.remove(removed.key);
            }
        }
    }
    
    // æ‰€æœ‰æ“ä½œéƒ½æ˜¯ O(1)ï¼Œä½“ç°äº†è‰¯å¥½çš„æ—¶é—´å¤æ‚åº¦è®¾è®¡
}
```

---

## 8. ğŸ“š æ€»ç»“ä¸è¿›é˜¶


### 8.1 æ ¸å¿ƒçŸ¥è¯†ç‚¹æ€»ç»“

```
ğŸ”¸ åŸºæœ¬æ¦‚å¿µ
- æ—¶é—´å¤æ‚åº¦è¡¡é‡ç®—æ³•æ•ˆç‡çš„æ¸è¿‘è¡Œä¸º
- å¤§Oè¡¨ç¤ºæ³•æè¿°å¢é•¿çš„ä¸Šç•Œ
- å…³æ³¨æœ€åæƒ…å†µå’Œæ¸è¿‘è¡Œä¸º

ğŸ”¸ åˆ†ææ–¹æ³•
- è¯†åˆ«åŸºæœ¬æ“ä½œå’Œå¾ªç¯ç»“æ„
- å»ºç«‹é€’æ¨å…³ç³»æ±‚è§£é€’å½’å¤æ‚åº¦
- è€ƒè™‘æœ€å¥½ã€å¹³å‡ã€æœ€åæƒ…å†µ

ğŸ”¸ å¸¸è§å¤æ‚åº¦ç±»å‹
- O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(2â¿)
- å¯¹æ•°å¤æ‚åº¦é€šå¸¸æ¥è‡ªåˆ†æ²»
- çº¿æ€§å¯¹æ•°å¤æ‚åº¦æ˜¯è®¸å¤šé«˜æ•ˆç®—æ³•çš„å¤æ‚åº¦

ğŸ”¸ ä¼˜åŒ–ç­–ç•¥
- é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
- ä½¿ç”¨é¢„å¤„ç†å’Œç¼“å­˜
- è€ƒè™‘ç©ºé—´æ¢æ—¶é—´çš„æƒè¡¡
```

### 8.2 å®è·µæŒ‡å¯¼åŸåˆ™

```
è®¾è®¡é˜¶æ®µ:
1. æ˜ç¡®é—®é¢˜è§„æ¨¡å’Œæ€§èƒ½è¦æ±‚
2. åˆ†æä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦
3. è€ƒè™‘å®é™…åº”ç”¨åœºæ™¯çš„ç‰¹ç‚¹
4. è¯„ä¼°ç©ºé—´å’Œæ—¶é—´çš„æƒè¡¡

å®ç°é˜¶æ®µ:
1. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
2. é¿å…ä¸å¿…è¦çš„åµŒå¥—å¾ªç¯
3. åˆ©ç”¨é¢„å¤„ç†å‡å°‘é‡å¤è®¡ç®—
4. è€ƒè™‘ç®—æ³•çš„ç»„åˆå’Œä¼˜åŒ–

æµ‹è¯•é˜¶æ®µ:
1. æµ‹è¯•ä¸åŒè§„æ¨¡çš„æ•°æ®
2. éªŒè¯ç†è®ºåˆ†æçš„æ­£ç¡®æ€§
3. è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
4. è¿›è¡Œé’ˆå¯¹æ€§ä¼˜åŒ–
```

### 8.3 è¿›é˜¶å­¦ä¹ æ–¹å‘

```
ğŸ”¸ é«˜çº§æ•°æ®ç»“æ„
- å¹³è¡¡æ ‘: AVLæ ‘ã€çº¢é»‘æ ‘ã€Bæ ‘
- é«˜çº§å“ˆå¸Œ: å¸ƒéš†è¿‡æ»¤å™¨ã€ä¸€è‡´æ€§å“ˆå¸Œ
- å¹¶æŸ¥é›†: è·¯å¾„å‹ç¼©å’ŒæŒ‰ç§©åˆå¹¶
- çº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„: åŒºé—´æŸ¥è¯¢å’Œæ›´æ–°

ğŸ”¸ é«˜çº§ç®—æ³•åˆ†æ
- æ‘Šè¿˜åˆ†æ: èšåˆåˆ†æã€è®°è´¦æ–¹æ³•ã€åŠ¿èƒ½æ–¹æ³•
- æ¦‚ç‡ç®—æ³•: è’™ç‰¹å¡æ´›ã€æ‹‰æ–¯ç»´åŠ æ–¯ç®—æ³•
- è¿‘ä¼¼ç®—æ³•: è´ªå¿ƒè¿‘ä¼¼ã€çº¿æ€§è§„åˆ’æ¾å¼›
- å‚æ•°åŒ–å¤æ‚åº¦: å›ºå®šå‚æ•°å¯å¤„ç†æ€§

ğŸ”¸ ä¸“é—¨é¢†åŸŸ
- å­—ç¬¦ä¸²ç®—æ³•: KMPã€åç¼€æ•°ç»„ã€è‡ªåŠ¨æœº
- å›¾ç®—æ³•: æœ€çŸ­è·¯å¾„ã€æœ€å°ç”Ÿæˆæ ‘ã€ç½‘ç»œæµ
- è®¡ç®—å‡ ä½•: å‡¸åŒ…ã€æœ€è¿‘ç‚¹å¯¹ã€çº¿æ®µäº¤
- æ•°å€¼ç®—æ³•: å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ã€çŸ©é˜µä¹˜æ³•

ğŸ”¸ ç°ä»£è®¡ç®—æ¨¡å‹
- å¹¶è¡Œç®—æ³•: PRAMæ¨¡å‹ã€å·¥ä½œ-æ·±åº¦åˆ†æ
- åˆ†å¸ƒå¼ç®—æ³•: MapReduceã€ä¸€è‡´æ€§åè®®
- åœ¨çº¿ç®—æ³•: ç«äº‰æ¯”åˆ†æ
- é‡å­ç®—æ³•: é‡å­å¤æ‚åº¦ç†è®º
```

### 8.4 å¸¸è§è¯¯åŒºå’Œæ³¨æ„äº‹é¡¹

```
âŒ å¸¸è§è¯¯åŒº:
1. å¿½è§†å¸¸æ•°å› å­çš„å½±å“
2. è¿‡åˆ†å…³æ³¨æœ€åæƒ…å†µè€Œå¿½ç•¥å¹³å‡æƒ…å†µ
3. ä¸è€ƒè™‘å®é™…æ•°æ®çš„ç‰¹ç‚¹
4. æ··æ·†æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦

âœ… æ­£ç¡®åšæ³•:
1. ç»“åˆç†è®ºåˆ†æå’Œå®é™…æµ‹è¯•
2. æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„ç®—æ³•
3. è€ƒè™‘ç®—æ³•çš„ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§
4. å¹³è¡¡æ—¶é—´ã€ç©ºé—´å’Œå¼€å‘æˆæœ¬
```

