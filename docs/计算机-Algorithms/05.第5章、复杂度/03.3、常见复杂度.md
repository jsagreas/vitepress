---
title: 3、常见复杂度
---
## 📚 目录

1. [复杂度分析基础](#1-复杂度分析基础)
2. [排序算法复杂度](#2-排序算法复杂度)
3. [搜索算法复杂度](#3-搜索算法复杂度)
4. [图算法复杂度](#4-图算法复杂度)
5. [动态规划算法复杂度](#5-动态规划算法复杂度)
6. [其他常见算法复杂度](#6-其他常见算法复杂度)

---

## 1. 📊 复杂度分析基础


### 1.1 时间复杂度与空间复杂度概述

在分析算法效率时，我们主要关注两个维度：

```
时间复杂度（Time Complexity）：
- 衡量算法执行时间随输入规模增长的趋势
- 关注算法执行的基本操作次数
- 通常考虑最坏情况的性能表现

空间复杂度（Space Complexity）：
- 衡量算法所需额外存储空间随输入规模增长的趋势
- 不包括输入数据本身占用的空间
- 包括辅助数据结构、递归调用栈等
```

### 1.2 复杂度表示法

```
常见复杂度等级（从优到劣）：
🔸 O(1)        - 常数时间/空间
🔸 O(log n)    - 对数时间
🔸 O(n)        - 线性时间/空间
🔸 O(n log n)  - 线性对数时间
🔸 O(n²)       - 平方时间/空间
🔸 O(n³)       - 立方时间/空间
🔸 O(2ⁿ)       - 指数时间/空间
🔸 O(n!)       - 阶乘时间/空间
```

### 1.3 分析方法

```
时间复杂度分析步骤：
1. 确定基本操作（通常是最内层循环的操作）
2. 分析基本操作执行次数与输入规模的关系
3. 用大O记号表示增长趋势

空间复杂度分析要点：
1. 统计额外使用的存储空间
2. 考虑递归调用栈的深度
3. 分析临时数据结构的空间需求
```

---

## 2. 🔄 排序算法复杂度


### 2.1 比较排序算法


**冒泡排序（Bubble Sort）**
```
时间复杂度：
- 最好情况：O(n)    - 数组已有序，只需一次遍历
- 平均情况：O(n²)   - 需要多次交换
- 最坏情况：O(n²)   - 数组逆序，最多交换

空间复杂度：O(1)    - 只需常数个辅助变量

特点分析：
- 稳定排序：相等元素相对位置不变
- 原地排序：不需要额外存储空间
- 自适应性：对部分有序数据有优化
```

**选择排序（Selection Sort）**
```
时间复杂度：
- 最好情况：O(n²)   - 即使数组有序，仍需查找最小值
- 平均情况：O(n²)   - 每次都要遍历找最小值
- 最坏情况：O(n²)   - 同平均情况

空间复杂度：O(1)    - 只需常数个辅助变量

特点分析：
- 不稳定排序：可能改变相等元素的相对位置
- 原地排序：在原数组上进行操作
- 交换次数少：最多n-1次交换
```

**插入排序（Insertion Sort）**
```
时间复杂度：
- 最好情况：O(n)    - 数组已有序，每个元素只需一次比较
- 平均情况：O(n²)   - 平均需要移动n²/4个元素
- 最坏情况：O(n²)   - 数组逆序，每次都要移动到开头

空间复杂度：O(1)    - 只需常数个辅助变量

特点分析：
- 稳定排序：维持相等元素的相对顺序
- 原地排序：就地调整元素位置
- 自适应性强：对小规模或部分有序数据效果好
```

**快速排序（Quick Sort）**
```
时间复杂度：
- 最好情况：O(n log n) - 每次分区都能均匀划分
- 平均情况：O(n log n) - 大多数情况下表现良好
- 最坏情况：O(n²)     - 每次选择的枢轴都是最值

空间复杂度：
- 最好情况：O(log n)   - 递归调用栈深度
- 最坏情况：O(n)       - 退化为链式递归

特点分析：
- 不稳定排序：分区过程可能打乱相等元素顺序
- 原地排序：只需要递归栈空间
- 实际性能优秀：常数因子小，缓存友好
```

**归并排序（Merge Sort）**
```
时间复杂度：
- 最好情况：O(n log n) - 始终需要完整的分治过程
- 平均情况：O(n log n) - 稳定的性能表现
- 最坏情况：O(n log n) - 性能不受输入数据影响

空间复杂度：O(n)       - 需要临时数组存储合并结果

特点分析：
- 稳定排序：合并过程保持相等元素顺序
- 非原地排序：需要额外的存储空间
- 性能稳定：不受输入数据分布影响
```

**堆排序（Heap Sort）**
```
时间复杂度：
- 最好情况：O(n log n) - 建堆O(n) + n次删除O(log n)
- 平均情况：O(n log n) - 稳定的性能
- 最坏情况：O(n log n) - 同样稳定

空间复杂度：O(1)       - 原地建堆和排序

特点分析：
- 不稳定排序：堆化过程破坏相等元素顺序
- 原地排序：在原数组上构建堆
- 性能稳定：时间复杂度不依赖于输入
```

### 2.2 非比较排序算法


**计数排序（Counting Sort）**
```
时间复杂度：O(n + k)   - n是元素个数，k是数值范围
空间复杂度：O(k)       - 需要k大小的计数数组

适用条件：
- 元素都是非负整数
- 数值范围k不太大
- 当k = O(n)时，整体复杂度为O(n)

应用场景：
- 年龄排序、成绩排序等有限范围的整数排序
```

**基数排序（Radix Sort）**
```
时间复杂度：O(d × (n + k)) - d是位数，k是每位的取值范围
空间复杂度：O(n + k)       - 需要临时存储空间

特点分析：
- 稳定排序：从低位到高位逐位排序
- 适用于整数和字符串排序
- 当d是常数时，时间复杂度为O(n)
```

### 2.3 排序算法选择指南

```
小规模数据（n < 50）：
- 首选：插入排序
- 原因：常数因子小，实现简单

中等规模数据（50 ≤ n ≤ 10000）：
- 首选：快速排序（随机化）
- 备选：归并排序（稳定性要求）

大规模数据（n > 10000）：
- 首选：归并排序或堆排序
- 原因：稳定的O(n log n)性能

特殊情况：
- 部分有序：插入排序
- 稳定性要求：归并排序
- 内存受限：堆排序
- 整数且范围小：计数排序/基数排序
```

---

## 3. 🔍 搜索算法复杂度


### 3.1 线性搜索


**顺序搜索（Linear Search）**
```
时间复杂度：
- 最好情况：O(1)     - 目标在第一个位置
- 平均情况：O(n)     - 平均需要搜索n/2个元素
- 最坏情况：O(n)     - 目标在最后或不存在

空间复杂度：O(1)     - 只需要常数空间

适用场景：
- 无序数据的搜索
- 小规模数据集
- 不支持随机访问的数据结构（如链表）
```

### 3.2 二分搜索


**标准二分搜索（Binary Search）**
```
时间复杂度：
- 最好情况：O(1)     - 目标正好在中间
- 平均情况：O(log n) - 每次排除一半元素
- 最坏情况：O(log n) - 搜索到叶子节点

空间复杂度：
- 迭代版本：O(1)     - 只需要几个指针变量
- 递归版本：O(log n) - 递归调用栈深度

前提条件：
- 数据必须已排序
- 支持随机访问（如数组）

应用扩展：
- 查找插入位置
- 查找第一个/最后一个匹配元素
- 在旋转数组中搜索
```

### 3.3 哈希搜索


**哈希表搜索**
```
时间复杂度：
- 最好情况：O(1)     - 无冲突，直接命中
- 平均情况：O(1)     - 负载因子合理时
- 最坏情况：O(n)     - 所有元素都冲突

空间复杂度：O(n)     - 需要哈希表存储所有元素

性能影响因素：
- 哈希函数质量：分布是否均匀
- 负载因子：元素数量与表大小的比值
- 冲突解决策略：链表法vs开放地址法
```

### 3.4 树结构搜索


**二叉搜索树（BST）**
```
时间复杂度：
- 平衡情况：O(log n) - 树高度约为log n
- 不平衡情况：O(n)   - 退化为链表

空间复杂度：O(n)     - 存储n个节点

平衡树优化：
- AVL树：严格平衡，保证O(log n)
- 红黑树：近似平衡，实际性能好
- B树/B+树：适合外存搜索
```

**字典树（Trie）**
```
时间复杂度：O(m)     - m是键的长度，与数据量无关
空间复杂度：O(ALPHABET_SIZE × N × M) - 最坏情况

优势：
- 搜索时间与数据量无关
- 支持前缀匹配
- 删除操作简单

适用场景：
- 字符串搜索
- 自动补全功能
- IP路由表查找
```

---

## 4. 🕸️ 图算法复杂度


### 4.1 图遍历算法


**深度优先搜索（DFS）**
```
时间复杂度：
- 邻接矩阵：O(V²)    - 需要检查所有边
- 邻接表：O(V + E)   - 访问所有顶点和边

空间复杂度：
- 递归实现：O(V)     - 递归栈深度最多为V
- 迭代实现：O(V)     - 显式栈的空间

应用场景：
- 连通性检测
- 拓扑排序
- 强连通分量
```

**广度优先搜索（BFS）**
```
时间复杂度：
- 邻接矩阵：O(V²)    - 同DFS
- 邻接表：O(V + E)   - 同DFS

空间复杂度：O(V)     - 队列最多存储V个顶点

应用场景：
- 最短路径（无权图）
- 层次遍历
- 最小生成树
```

### 4.2 最短路径算法


**Dijkstra算法**
```
时间复杂度：
- 朴素实现：O(V²)           - 适用于稠密图
- 二叉堆优化：O((V+E)log V) - 适用于稀疏图
- 斐波那契堆：O(E + V log V) - 理论最优

空间复杂度：O(V)            - 距离数组和优先队列

适用条件：
- 非负权重的图
- 单源最短路径问题

局限性：
- 不能处理负权边
- 计算所有顶点的最短距离
```

**Bellman-Ford算法**
```
时间复杂度：O(VE)           - V-1轮松弛，每轮检查E条边
空间复杂度：O(V)            - 距离数组

优势：
- 可以检测负权回路
- 可以处理负权边
- 实现相对简单

缺点：
- 时间复杂度较高
- 不适合稠密图
```

**Floyd-Warshall算法**
```
时间复杂度：O(V³)           - 三重循环遍历所有顶点
空间复杂度：O(V²)           - 距离矩阵

特点：
- 解决所有顶点对的最短路径
- 可以处理负权边
- 不适合大规模图
- 动态规划思想

适用场景：
- 小规模图的所有最短路径
- 传递闭包计算
```

### 4.3 最小生成树算法


**Kruskal算法**
```
时间复杂度：O(E log E)      - 边排序的时间复杂度
空间复杂度：O(V)            - 并查集空间

算法步骤：
1. 将所有边按权重排序：O(E log E)
2. 使用并查集检测环：O(E α(V))
3. 总时间复杂度：O(E log E)

适用场景：
- 稀疏图效果好
- 需要边的信息
```

**Prim算法**
```
时间复杂度：
- 朴素实现：O(V²)           - 适用于稠密图
- 堆优化：O(E log V)        - 适用于稀疏图

空间复杂度：O(V)            - 优先队列和标记数组

特点：
- 从顶点角度构建MST
- 适合稠密图
- 可以在构建过程中获得部分结果
```

---

## 5. 💡 动态规划算法复杂度


### 5.1 经典DP问题


**斐波那契数列**
```
朴素递归：
- 时间复杂度：O(2ⁿ)        - 指数级增长
- 空间复杂度：O(n)          - 递归栈深度

记忆化搜索：
- 时间复杂度：O(n)          - 每个子问题只计算一次
- 空间复杂度：O(n)          - 缓存表 + 递归栈

迭代DP：
- 时间复杂度：O(n)          - 线性遍历
- 空间复杂度：O(1)          - 只需要两个变量

优化思路：
- 自底向上避免递归开销
- 滚动数组减少空间使用
```

**最长公共子序列（LCS）**
```
时间复杂度：O(mn)           - m和n分别是两个序列的长度
空间复杂度：O(mn)           - 二维DP表

空间优化：
- 滚动数组：O(min(m,n))     - 只保留当前行和上一行
- 打印路径：O(mn)           - 需要保存完整DP表

状态转移：
dp[i][j] = dp[i-1][j-1] + 1         (if s1[i] == s2[j])
         = max(dp[i-1][j], dp[i][j-1]) (otherwise)
```

**0-1背包问题**
```
时间复杂度：O(nW)           - n个物品，背包容量W
空间复杂度：O(nW)           - 二维DP表

空间优化：
- 一维数组：O(W)            - 逆序更新避免状态覆盖
- 滚动数组：O(2W)           - 保留两行状态

变种问题：
- 完全背包：时间O(nW)，空间可优化至O(W)
- 多重背包：时间O(nWlogC)，C是单个物品数量
```

### 5.2 区间DP


**矩阵链乘法**
```
时间复杂度：O(n³)           - 三重循环遍历所有区间和分割点
空间复杂度：O(n²)           - 二维DP表

状态定义：dp[i][j] = 矩阵i到j的最小乘法次数
状态转移：dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost(i,k,j))

特点：
- 区间长度从小到大填表
- 适用于各种区间合并问题
```

### 5.3 状态压缩DP


**旅行商问题（TSP）**
```
时间复杂度：O(n² × 2ⁿ)     - n个城市，2ⁿ个状态
空间复杂度：O(n × 2ⁿ)      - 状态压缩后的DP表

状态表示：用位掩码表示访问过的城市集合
适用规模：n ≤ 20左右

优化技巧：
- 滚动数组减少空间
- 剪枝减少计算量
```

---

## 6. 🔧 其他常见算法复杂度


### 6.1 字符串算法


**KMP算法**
```
时间复杂度：O(n + m)        - n是文本长度，m是模式长度
空间复杂度：O(m)            - next数组空间

预处理：构建next数组 O(m)
匹配：主循环 O(n)

优势：
- 避免了朴素算法的重复比较
- 时间复杂度与匹配结果无关
```

**Rabin-Karp算法**
```
时间复杂度：
- 平均情况：O(n + m)        - 哈希冲突较少
- 最坏情况：O(nm)           - 大量哈希冲突

空间复杂度：O(1)            - 只需要几个变量

特点：
- 使用滚动哈希快速比较
- 适合多模式匹配
- 容易实现和理解
```

### 6.2 数学算法


**快速幂算法**
```
时间复杂度：O(log n)        - n是指数
空间复杂度：O(1)            - 迭代实现

递归实现空间：O(log n)      - 递归栈深度

应用：
- 大数幂运算
- 模幂运算
- 矩阵快速幂
```

**欧几里得算法（求最大公约数）**
```
时间复杂度：O(log min(a,b)) - 最多递归log次
空间复杂度：O(1)            - 迭代实现

递归实现：O(log min(a,b))   - 递归栈深度

扩展欧几里得：
- 时间复杂度：O(log min(a,b))
- 可以求解线性丢番图方程
```

### 6.3 分治算法


**快速选择算法**
```
时间复杂度：
- 平均情况：O(n)            - 每次排除约一半元素
- 最坏情况：O(n²)           - 每次只排除一个元素

空间复杂度：O(1)            - 原地分区

应用：
- 寻找第k小的元素
- 中位数查找
- TopK问题
```

**分治法求最近点对**
```
时间复杂度：O(n log n)      - 分治递归 + 排序
空间复杂度：O(n)            - 递归栈 + 临时数组

算法步骤：
1. 预排序：O(n log n)
2. 分治递归：T(n) = 2T(n/2) + O(n)
3. 总复杂度：O(n log n)
```

---

## 🎯 总结


### 算法复杂度速查表

```
排序算法：
- 快速排序：平均O(n log n)，最坏O(n²)，空间O(log n)
- 归并排序：O(n log n)，空间O(n)，稳定
- 堆排序：O(n log n)，空间O(1)，不稳定
- 插入排序：最好O(n)，最坏O(n²)，空间O(1)

搜索算法：
- 二分搜索：O(log n)，需要有序数组
- 哈希搜索：平均O(1)，最坏O(n)
- BST搜索：平均O(log n)，最坏O(n)

图算法：
- DFS/BFS：O(V + E)邻接表，O(V²)邻接矩阵
- Dijkstra：O(E log V)用堆优化
- Floyd：O(V³)求所有最短路径
```

### 选择算法的指导原则

```
时间优先场景：
- 实时系统：选择时间复杂度稳定的算法
- 大数据：选择时间复杂度低的算法
- 交互系统：选择平均性能好的算法

空间受限场景：
- 嵌入式系统：优先考虑空间复杂度
- 流式处理：选择常数空间算法
- 大数据：考虑外存算法

平衡考虑：
- 根据实际数据特点选择
- 考虑常数因子的影响
- 测试验证理论分析
```
