---
title: 1、递归算法
---
## 📚 目录

1. [算法概述](#1-算法概述)
2. [基本思想](#2-基本思想)
3. [算法原理](#3-算法原理)
4. [实现方法](#4-实现方法)
5. [算法分析](#5-算法分析)
6. [典型应用](#6-典型应用)
7. [优化策略](#7-优化策略)
8. [总结](#8-总结)

---

## 1. 📖 算法概述


### 1.1 定义

递归（Recursion）是一种解决问题的方法，其中函数调用自身来解决更小的子问题。递归算法将复杂问题分解为与原问题相似但规模更小的子问题，通过解决子问题来解决原问题。

### 1.2 历史背景

- **数学基础**：源于数学归纳法的思想
- **计算机实现**：20世纪50年代开始在程序设计中应用
- **理论地位**：函数式编程和分治算法的基础
- **重要性**：许多经典算法都基于递归思想

### 1.3 核心特征

- **🔹 自我调用**：函数调用自身
- **🔹 问题分解**：将大问题分解为小问题
- **🔹 基础情况**：必须有终止条件
- **🔹 栈结构**：利用调用栈管理递归状态

### 1.4 算法分类

- 线性递归（单路递归）
- 树形递归（多路递归）
- 尾递归
- 相互递归

---

## 2. 💡 基本思想


### 2.1 核心思想

递归的基本思想可以用数学归纳法来理解：
1. **基础情况（Base Case）**：最简单的情况，可以直接解决
2. **递归情况（Recursive Case）**：将问题转化为更小的同类问题
3. **自我调用**：函数调用自身来解决子问题
4. **结果合并**：将子问题的解合并得到原问题的解

### 2.2 递归的比喻理解

**递归就像俄罗斯套娃：**
- 打开一个套娃，里面还有更小的套娃
- 继续打开，直到找到最小的那个（基础情况）
- 然后按相反顺序把套娃重新装回去

**递归就像问路：**
- 你问A："图书馆怎么走？"
- A说："我不知道，你去问B"
- B说："我不知道，你去问C"
- C说："直走200米就到了"（基础情况）
- 信息沿原路返回：C→B→A→你

### 2.3 递归过程示例

以计算阶乘为例：n! = n × (n-1)!

```
计算 factorial(4)：

第1步：factorial(4) = 4 × factorial(3)
第2步：factorial(3) = 3 × factorial(2)  
第3步：factorial(2) = 2 × factorial(1)
第4步：factorial(1) = 1 × factorial(0)
第5步：factorial(0) = 1 (基础情况)

返回过程：
factorial(0) = 1
factorial(1) = 1 × 1 = 1
factorial(2) = 2 × 1 = 2
factorial(3) = 3 × 2 = 6
factorial(4) = 4 × 6 = 24

调用栈变化：
→ factorial(4)
  → factorial(3)
    → factorial(2)
      → factorial(1)
        → factorial(0) = 1
      ← 1
    ← 2
  ← 6
← 24
```

---

## 3. ⚙️ 算法原理


### 3.1 递归的三要素


#### 3.1.1 递归定义（问题拆分）

```
将原问题转化为规模更小的同类子问题

示例：
- 阶乘：n! = n × (n-1)!
- 斐波那契：fib(n) = fib(n-1) + fib(n-2)
- 汉诺塔：移动n个盘子 = 移动(n-1)个盘子 + 移动1个盘子 + 移动(n-1)个盘子
```

#### 3.1.2 基础情况（终止条件）

```
递归的终止条件，必须能够直接求解

示例：
- 阶乘：0! = 1 或 1! = 1
- 斐波那契：fib(0) = 0, fib(1) = 1
- 汉诺塔：移动1个盘子直接移动
```

#### 3.1.3 递归调用（自我引用）

```
函数调用自身来解决子问题

要求：
- 子问题必须比原问题规模更小
- 必须向基础情况收敛
- 子问题与原问题具有相同的结构
```

### 3.2 递归的工作机制


#### 3.2.1 调用栈（Call Stack）

```
递归利用系统调用栈来管理函数调用：

栈的作用：
1. 保存每次函数调用的参数和局部变量
2. 记录函数调用的返回地址
3. 按照LIFO（后进先出）的顺序管理调用关系

栈帧内容：
- 函数参数
- 局部变量
- 返回地址
- 返回值
```

#### 3.2.2 递归执行过程

```
递归执行分为两个阶段：

1. 递推阶段（Winding）：
   - 函数不断调用自身
   - 问题规模逐渐减小
   - 调用栈不断增长

2. 回归阶段（Unwinding）：
   - 到达基础情况开始返回
   - 逐层返回计算结果
   - 调用栈逐渐减小
```

### 3.3 递归类型详解


#### 3.3.1 线性递归

```
每次递归调用中只包含一个递归调用

特点：
- 递归深度 = 问题规模
- 时间复杂度通常为 O(n)
- 空间复杂度为 O(n)（栈空间）

示例：阶乘、链表遍历、二分查找
```

#### 3.3.2 树形递归

```
每次递归调用中包含多个递归调用

特点：
- 形成递归调用树
- 时间复杂度可能为指数级
- 可能存在重复计算

示例：斐波那契数列、汉诺塔、树的遍历
```

#### 3.3.3 尾递归

```
递归调用是函数中的最后一个操作

特点：
- 可以被编译器优化为循环
- 不需要保存调用栈信息
- 空间复杂度可以优化为 O(1)

示例：尾递归阶乘、尾递归斐波那契
```

---

## 4. 🔨 实现方法


### 4.1 基础递归实现


#### 4.1.1 阶乘计算

```python
def factorial(n):
    """
    计算n的阶乘
    基础情况：0! = 1
    递归关系：n! = n × (n-1)!
    """
    # 基础情况
    if n == 0 or n == 1:
        return 1
    
    # 递归情况
    return n * factorial(n - 1)

# 使用示例
print(factorial(5))  # 输出：120

def factorial_with_trace(n, depth=0):
    """
    带跟踪信息的阶乘计算
    """
    indent = "  " * depth
    print(f"{indent}→ factorial({n})")
    
    if n == 0 or n == 1:
        print(f"{indent}← return 1")
        return 1
    
    result = n * factorial_with_trace(n - 1, depth + 1)
    print(f"{indent}← return {result}")
    return result
```

#### 4.1.2 斐波那契数列

```python
def fibonacci(n):
    """
    计算第n个斐波那契数
    基础情况：fib(0) = 0, fib(1) = 1
    递归关系：fib(n) = fib(n-1) + fib(n-2)
    """
    # 基础情况
    if n <= 1:
        return n
    
    # 递归情况
    return fibonacci(n - 1) + fibonacci(n - 2)

# 问题：存在大量重复计算
def fibonacci_with_count(n, call_count=None):
    """
    统计调用次数的斐波那契
    """
    if call_count is None:
        call_count = [0]
    
    call_count[0] += 1
    
    if n <= 1:
        return n
    
    return (fibonacci_with_count(n - 1, call_count) + 
            fibonacci_with_count(n - 2, call_count))
```

### 4.2 尾递归实现


#### 4.2.1 尾递归阶乘

```python
def factorial_tail(n, accumulator=1):
    """
    尾递归实现阶乘
    accumulator: 累积器，保存中间结果
    """
    # 基础情况
    if n <= 1:
        return accumulator
    
    # 尾递归：递归调用是最后一个操作
    return factorial_tail(n - 1, n * accumulator)

# 普通递归 vs 尾递归
def compare_recursion():
    print("普通递归：factorial(4)")
    print("4 * factorial(3)")
    print("4 * (3 * factorial(2))")
    print("4 * (3 * (2 * factorial(1)))")
    print("4 * (3 * (2 * 1))")
    print()
    
    print("尾递归：factorial_tail(4, 1)")
    print("factorial_tail(3, 4)")
    print("factorial_tail(2, 12)")
    print("factorial_tail(1, 24)")
    print("返回 24")
```

#### 4.2.2 尾递归斐波那契

```python
def fibonacci_tail(n, a=0, b=1):
    """
    尾递归实现斐波那契
    a, b: 前两个斐波那契数
    """
    if n == 0:
        return a
    if n == 1:
        return b
    
    return fibonacci_tail(n - 1, b, a + b)
```

### 4.3 树形递归实现


#### 4.3.1 二叉树遍历

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_traversal(root):
    """
    中序遍历：左 → 根 → 右
    """
    if root is None:
        return []
    
    result = []
    result.extend(inorder_traversal(root.left))    # 左子树
    result.append(root.val)                        # 根节点
    result.extend(inorder_traversal(root.right))   # 右子树
    
    return result

def preorder_traversal(root):
    """
    前序遍历：根 → 左 → 右
    """
    if root is None:
        return []
    
    result = []
    result.append(root.val)                        # 根节点
    result.extend(preorder_traversal(root.left))   # 左子树
    result.extend(preorder_traversal(root.right))  # 右子树
    
    return result

def postorder_traversal(root):
    """
    后序遍历：左 → 右 → 根
    """
    if root is None:
        return []
    
    result = []
    result.extend(postorder_traversal(root.left))  # 左子树
    result.extend(postorder_traversal(root.right)) # 右子树
    result.append(root.val)                        # 根节点
    
    return result
```

#### 4.3.2 汉诺塔问题

```python
def hanoi(n, source, target, auxiliary):
    """
    汉诺塔问题
    n: 盘子数量
    source: 源柱子
    target: 目标柱子  
    auxiliary: 辅助柱子
    """
    if n == 1:
        print(f"移动盘子从 {source} 到 {target}")
        return
    
    # 将上面n-1个盘子从源柱移到辅助柱
    hanoi(n - 1, source, auxiliary, target)
    
    # 将最大的盘子从源柱移到目标柱
    print(f"移动盘子从 {source} 到 {target}")
    
    # 将n-1个盘子从辅助柱移到目标柱
    hanoi(n - 1, auxiliary, target, source)

# 使用示例
print("汉诺塔(3盘)移动步骤：")
hanoi(3, 'A', 'C', 'B')
```

### 4.4 Java实现


```java
public class Recursion {
    // 阶乘
    public static long factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    // 斐波那契
    public static long fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // 尾递归阶乘
    public static long factorialTail(int n, long accumulator) {
        if (n <= 1) {
            return accumulator;
        }
        return factorialTail(n - 1, n * accumulator);
    }
    
    public static long factorialTail(int n) {
        return factorialTail(n, 1);
    }
    
    // 二分查找
    public static int binarySearch(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearch(arr, target, left, mid - 1);
        } else {
            return binarySearch(arr, target, mid + 1, right);
        }
    }
}
```

### 4.5 C++实现


```cpp
#include <iostream>
#include <vector>
using namespace std;

class Recursion {
public:
    // 阶乘
    static long long factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
    
    // 斐波那契
    static long long fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // 快速排序
    static void quickSort(vector<int>& arr, int left, int right) {
        if (left < right) {
            int pivot = partition(arr, left, right);
            quickSort(arr, left, pivot - 1);
            quickSort(arr, pivot + 1, right);
        }
    }
    
private:
    static int partition(vector<int>& arr, int left, int right) {
        int pivot = arr[right];
        int i = left - 1;
        
        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        
        swap(arr[i + 1], arr[right]);
        return i + 1;
    }
};
```

---

## 5. 📊 算法分析


### 5.1 时间复杂度分析


#### 5.1.1 线性递归

```
示例：阶乘 factorial(n)

递推关系：T(n) = T(n-1) + O(1)
基础情况：T(0) = O(1)

解：T(n) = O(n)

特点：
- 递归深度为n
- 每层只做常数工作
- 总时间复杂度为O(n)
```

#### 5.1.2 树形递归

```
示例：斐波那契 fibonacci(n)

递推关系：T(n) = T(n-1) + T(n-2) + O(1)
基础情况：T(0) = T(1) = O(1)

解：T(n) = O(φⁿ)，其中φ = (1+√5)/2 ≈ 1.618

特点：
- 形成二叉递归树
- 存在大量重复计算
- 时间复杂度为指数级
```

#### 5.1.3 分治递归

```
示例：归并排序 mergeSort(n)

递推关系：T(n) = 2T(n/2) + O(n)
基础情况：T(1) = O(1)

解：T(n) = O(n log n)

特点：
- 每层分解为两个子问题
- 合并需要线性时间
- 总共log n层
```

### 5.2 空间复杂度分析


#### 5.2.1 递归栈空间

```
普通递归：
- 空间复杂度 = 递归深度 × 每层栈帧大小
- 阶乘：O(n)
- 斐波那契：O(n)
- 二分查找：O(log n)

尾递归优化：
- 理论上可以优化为O(1)
- 实际上取决于编译器/解释器支持
```

#### 5.2.2 额外空间使用

```
不同算法的额外空间需求：
- 简单递归（阶乘）：O(1)
- 树遍历：O(1)（不算递归栈）
- 归并排序：O(n)（临时数组）
- 快速排序：O(1)（原地排序）
```

### 5.3 递归深度问题


```python
def test_recursion_limit():
    """
    测试递归深度限制
    """
    import sys
    
    print(f"默认递归限制: {sys.getrecursionlimit()}")
    
    try:
        factorial(1000)
    except RecursionError as e:
        print(f"递归深度超限: {e}")
    
    # 可以增加递归限制（谨慎使用）
    sys.setrecursionlimit(2000)
    try:
        result = factorial(1000)
        print(f"factorial(1000) 计算成功")
    except RecursionError:
        print("即使增加限制仍然超限")
```

---

## 6. 🎯 典型应用


### 6.1 数学计算


```python
def gcd(a, b):
    """
    欧几里得算法求最大公约数
    """
    if b == 0:
        return a
    return gcd(b, a % b)

def power(base, exp):
    """
    快速幂算法
    """
    if exp == 0:
        return 1
    if exp == 1:
        return base
    
    if exp % 2 == 0:
        half = power(base, exp // 2)
        return half * half
    else:
        return base * power(base, exp - 1)

def combination(n, r):
    """
    组合数计算 C(n,r) = C(n-1,r-1) + C(n-1,r)
    """
    if r == 0 or r == n:
        return 1
    return combination(n - 1, r - 1) + combination(n - 1, r)
```

### 6.2 数据结构操作


```python
# 链表操作
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    """递归反转链表"""
    if not head or not head.next:
        return head
    
    new_head = reverse_list(head.next)
    head.next.next = head
    head.next = None
    
    return new_head

def find_in_list(head, target):
    """递归查找链表元素"""
    if not head:
        return False
    if head.val == target:
        return True
    return find_in_list(head.next, target)

# 二叉树操作
def tree_height(root):
    """计算树的高度"""
    if not root:
        return 0
    return 1 + max(tree_height(root.left), tree_height(root.right))

def tree_sum(root):
    """计算树中所有节点值的和"""
    if not root:
        return 0
    return root.val + tree_sum(root.left) + tree_sum(root.right)
```

### 6.3 排序算法


```python
def merge_sort(arr):
    """归并排序"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    """合并两个有序数组"""
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result

def quick_sort(arr):
    """快速排序"""
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)
```

### 6.4 回溯算法


```python
def generate_parentheses(n):
    """
    生成n对括号的所有有效组合
    """
    result = []
    
    def backtrack(current, open_count, close_count):
        # 基础情况：生成了n对括号
        if len(current) == 2 * n:
            result.append(current)
            return
        
        # 可以添加左括号
        if open_count < n:
            backtrack(current + "(", open_count + 1, close_count)
        
        # 可以添加右括号
        if close_count < open_count:
            backtrack(current + ")", open_count, close_count + 1)
    
    backtrack("", 0, 0)
    return result

def n_queens(n):
    """
    N皇后问题
    """
    result = []
    board = [-1] * n  # board[i]表示第i行皇后的列位置
    
    def is_safe(row, col):
        for i in range(row):
            # 检查列冲突和对角线冲突
            if (board[i] == col or 
                board[i] - i == col - row or 
                board[i] + i == col + row):
                return False
        return True
    
    def backtrack(row):
        if row == n:
            result.append(board[:])
            return
        
        for col in range(n):
            if is_safe(row, col):
                board[row] = col
                backtrack(row + 1)
                board[row] = -1  # 回溯
    
    backtrack(0)
    return result
```

---

## 7. 🚀 优化策略


### 7.1 记忆化递归


```python
def fibonacci_memo(n, memo=None):
    """
    记忆化斐波那契
    时间复杂度从O(2^n)优化到O(n)
    """
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]
    
    if n <= 1:
        return n
    
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# 使用装饰器的记忆化
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_lru(n):
    """
    使用LRU缓存的斐波那契
    """
    if n <= 1:
        return n
    return fibonacci_lru(n - 1) + fibonacci_lru(n - 2)

def compare_fibonacci_performance():
    """
    比较不同斐波那契实现的性能
    """
    import time
    
    n = 35
    
    # 普通递归
    start = time.time()
    result1 = fibonacci(n)
    time1 = time.time() - start
    
    # 记忆化递归
    start = time.time()
    result2 = fibonacci_memo(n)
    time2 = time.time() - start
    
    print(f"普通递归: {time1:.4f}s")
    print(f"记忆化递归: {time2:.4f}s")
    print(f"性能提升: {time1/time2:.1f}倍")
```

### 7.2 迭代优化


```python
def factorial_iterative(n):
    """
    迭代版本的阶乘
    避免递归栈溢出
    """
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

def fibonacci_iterative(n):
    """
    迭代版本的斐波那契
    时间O(n)，空间O(1)
    """
    if n <= 1:
        return n
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b

def recursive_to_iterative(func):
    """
    递归转迭代的通用思路
    """
    # 1. 使用显式栈模拟递归栈
    # 2. 将递归调用转换为栈操作
    # 3. 处理返回值的合并
    pass
```

### 7.3 尾递归优化


```python
def optimize_tail_recursion(func):
    """
    手动实现尾递归优化（模拟）
    """
    def optimized(*args, **kwargs):
        while True:
            result = func(*args, **kwargs)
            if not isinstance(result, tuple):
                return result
            # 如果返回元组，表示需要继续递归
            func, args, kwargs = result
    
    return optimized

# 使用示例（概念性）
def factorial_tail_optimized(n, acc=1):
    """
    可优化的尾递归阶乘
    """
    if n <= 1:
        return acc
    # 返回下一次调用的参数，而不是直接递归
    return (factorial_tail_optimized, (n - 1, n * acc), {})
```

---

## 8. 📋 总结


### 8.1 核心要点

1. **🔸 递归三要素**：基准情况、递归情况、状态变化
2. **🔸 数学基础**：基于数学归纳法的思想
3. **🔸 调用栈**：理解递归的内存模型和栈溢出问题
4. **🔸 问题分解**：将复杂问题分解为同类子问题
5. **🔸 优化策略**：记忆化、尾递归、迭代转换

### 8.2 递归设计原则


#### 8.2.1 正确性原则


```
1. 明确基准情况
   - 必须存在且能够到达
   - 直接给出答案，不再递归

2. 确保收敛性
   - 每次递归都要向基准情况靠近
   - 问题规模必须逐渐减小

3. 保证完整性
   - 递归情况能够覆盖所有非基准的情况
   - 子问题的解能够构造原问题的解
```
