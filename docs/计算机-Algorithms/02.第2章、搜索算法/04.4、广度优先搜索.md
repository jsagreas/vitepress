---
title: 4ã€å¹¿åº¦ä¼˜å…ˆæœç´¢
---
## ğŸ“š ç›®å½•

1. [ç®—æ³•æ¦‚è¿°](#1-ç®—æ³•æ¦‚è¿°)
2. [åŸºæœ¬æ€æƒ³](#2-åŸºæœ¬æ€æƒ³)
3. [ç®—æ³•åŸç†](#3-ç®—æ³•åŸç†)
4. [å®ç°æ–¹æ³•](#4-å®ç°æ–¹æ³•)
5. [ç®—æ³•åˆ†æ](#5-ç®—æ³•åˆ†æ)
6. [å…¸å‹åº”ç”¨](#6-å…¸å‹åº”ç”¨)
7. [å¯¹æ¯”åˆ†æ](#7-å¯¹æ¯”åˆ†æ)
8. [æ€»ç»“](#8-æ€»ç»“)

---

## 1. ğŸ“– ç®—æ³•æ¦‚è¿°


### 1.1 å®šä¹‰

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBreadth-First Searchï¼Œç®€ç§°BFSï¼‰æ˜¯ä¸€ç§å›¾éå†ç®—æ³•ã€‚å®ƒä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼Œé¦–å…ˆè®¿é—®è·ç¦»èµ·å§‹èŠ‚ç‚¹æœ€è¿‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œç„¶åè®¿é—®è·ç¦»ä¸º2çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ï¼ŒæŒ‰ç…§è·ç¦»é€’å¢çš„é¡ºåºé€å±‚éå†ã€‚

### 1.2 æ ¸å¿ƒç‰¹å¾

- **ğŸ”¹ å¹¿åº¦ä¼˜å…ˆ**ï¼šä¼˜å…ˆè®¿é—®åŒä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
- **ğŸ”¹ å±‚æ¬¡éå†**ï¼šæŒ‰è·ç¦»ä»è¿‘åˆ°è¿œé€å±‚è®¿é—®
- **ğŸ”¹ é˜Ÿåˆ—ç»“æ„**ï¼šä½¿ç”¨é˜Ÿåˆ—å®ç°å…ˆè¿›å…ˆå‡º
- **ğŸ”¹ æœ€çŸ­è·¯å¾„**ï¼šä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰

### 1.3 ç®—æ³•åˆ†ç±»

- å›¾éå†ç®—æ³•
- æœ€çŸ­è·¯å¾„ç®—æ³•
- å±‚æ¬¡éå†ç®—æ³•

---

## 2. ğŸ’¡ åŸºæœ¬æ€æƒ³


### 2.1 æ ¸å¿ƒæ€æƒ³

BFSå°±åƒæ°´æ³¢æ‰©æ•£ä¸€æ ·ï¼š
1. **ä»ä¸­å¿ƒå¼€å§‹**ï¼šä»èµ·å§‹ç‚¹å¼€å§‹æ‰©æ•£
2. **åŒå¿ƒåœ†æ‰©å±•**ï¼šå…ˆè®¿é—®è·ç¦»ä¸º1çš„æ‰€æœ‰èŠ‚ç‚¹
3. **é€å±‚å‘å¤–**ï¼šå†è®¿é—®è·ç¦»ä¸º2çš„æ‰€æœ‰èŠ‚ç‚¹
4. **é‡å¤è¿‡ç¨‹**ï¼šç»§ç»­å‘å¤–æ‰©æ•£ï¼Œç›´åˆ°éå†å®Œæˆ

### 2.2 å±‚æ¬¡éå†æ¦‚å¿µ

**æ¯”å–»ç†è§£ï¼š**
- **BFSåƒæŠ•çŸ³å…¥æ°´**ï¼šæ°´æ³¢ä¸€åœˆåœˆå‘å¤–æ‰©æ•£
- **DFSåƒèµ°è¿·å®«**ï¼šé€‰ä¸€æ¡è·¯èµ°åˆ°åº•å†å›å¤´
- **BFSä¿è¯æœ€çŸ­**ï¼šæ°´æ³¢æœ€å…ˆåˆ°è¾¾çš„åœ°æ–¹è·ç¦»æœ€è¿‘

### 2.3 æœç´¢è¿‡ç¨‹ç¤ºä¾‹

```
å›¾ç»“æ„:
        A
       / \
      B   C
     / \   \
    D   E   F
   /
  G

BFSéå†è¿‡ç¨‹ï¼ˆä»Aå¼€å§‹ï¼‰ï¼š

å±‚æ¬¡0: [A]          - è·ç¦»Aä¸º0çš„èŠ‚ç‚¹
å±‚æ¬¡1: [B, C]       - è·ç¦»Aä¸º1çš„èŠ‚ç‚¹  
å±‚æ¬¡2: [D, E, F]    - è·ç¦»Aä¸º2çš„èŠ‚ç‚¹
å±‚æ¬¡3: [G]          - è·ç¦»Aä¸º3çš„èŠ‚ç‚¹

éå†é¡ºåºï¼šA â†’ B â†’ C â†’ D â†’ E â†’ F â†’ G

è¯¦ç»†æ­¥éª¤ï¼š
1. å°†AåŠ å…¥é˜Ÿåˆ—: [A]
2. å–å‡ºAï¼Œè®¿é—®Aï¼Œå°†Açš„é‚»å±…Bã€CåŠ å…¥é˜Ÿåˆ—: [B, C]
3. å–å‡ºBï¼Œè®¿é—®Bï¼Œå°†Bçš„é‚»å±…Dã€EåŠ å…¥é˜Ÿåˆ—: [C, D, E]
4. å–å‡ºCï¼Œè®¿é—®Cï¼Œå°†Cçš„é‚»å±…FåŠ å…¥é˜Ÿåˆ—: [D, E, F]
5. å–å‡ºDï¼Œè®¿é—®Dï¼Œå°†Dçš„é‚»å±…GåŠ å…¥é˜Ÿåˆ—: [E, F, G]
6. å–å‡ºEï¼Œè®¿é—®Eï¼ŒEæ— æ–°é‚»å±…: [F, G]
7. å–å‡ºFï¼Œè®¿é—®Fï¼ŒFæ— æ–°é‚»å±…: [G]
8. å–å‡ºGï¼Œè®¿é—®Gï¼ŒGæ— æ–°é‚»å±…: []
9. é˜Ÿåˆ—ä¸ºç©ºï¼Œéå†å®Œæˆ
```

---

## 3. âš™ï¸ ç®—æ³•åŸç†


### 3.1 å·¥ä½œæœºåˆ¶

1. **åˆå§‹åŒ–é˜Ÿåˆ—**ï¼šå°†èµ·å§‹èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
2. **å–å‡ºèŠ‚ç‚¹**ï¼šä»é˜Ÿåˆ—å¤´éƒ¨å–å‡ºä¸€ä¸ªèŠ‚ç‚¹
3. **è®¿é—®èŠ‚ç‚¹**ï¼šå¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œæ ‡è®°ä¸ºå·²è®¿é—®
4. **åŠ å…¥é‚»å±…**ï¼šå°†æœªè®¿é—®çš„é‚»å±…èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨
5. **é‡å¤è¿‡ç¨‹**ï¼šé‡å¤æ­¥éª¤2-4ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©º

### 3.2 å…³é”®æ¦‚å¿µ


##### 3.2.1 é˜Ÿåˆ—ï¼ˆQueueï¼‰

- **FIFOåŸç†**ï¼šå…ˆè¿›å…ˆå‡ºï¼ˆFirst In First Outï¼‰
- **ä½œç”¨**ï¼šä¿è¯æŒ‰å±‚æ¬¡é¡ºåºè®¿é—®èŠ‚ç‚¹
- **æ“ä½œ**ï¼šenqueueï¼ˆå…¥é˜Ÿï¼‰ã€dequeueï¼ˆå‡ºé˜Ÿï¼‰

##### 3.2.2 å±‚æ¬¡éå†

- **å®šä¹‰**ï¼šæŒ‰è·ç¦»èµ·å§‹èŠ‚ç‚¹çš„è¿œè¿‘åˆ†å±‚è®¿é—®
- **ä¿è¯**ï¼šåŒä¸€å±‚çš„èŠ‚ç‚¹åœ¨ä¸‹ä¸€å±‚ä¹‹å‰å…¨éƒ¨è®¿é—®å®Œ
- **ç»“æœ**ï¼šå¾—åˆ°æŒ‰è·ç¦»æ’åºçš„è®¿é—®é¡ºåº

##### 3.2.3 æœ€çŸ­è·¯å¾„æ€§è´¨

- **æ— æƒå›¾**ï¼šBFSä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼ˆè¾¹æ•°æœ€å°‘ï¼‰
- **åŸç†**ï¼šå…ˆè®¿é—®åˆ°çš„èŠ‚ç‚¹è·ç¦»ä¸€å®šæœ€çŸ­
- **åº”ç”¨**ï¼šæœ€çŸ­è·¯å¾„é—®é¢˜çš„åŸºç¡€ç®—æ³•

### 3.3 è®¿é—®æ ‡è®°æœºåˆ¶

```python
# BFSä¸­çš„è®¿é—®æ ‡è®°
visited = set()           # å·²è®¿é—®èŠ‚ç‚¹é›†åˆ
queue = [start]          # é˜Ÿåˆ—åˆå§‹åŒ–
visited.add(start)       # èµ·å§‹èŠ‚ç‚¹æ ‡è®°ä¸ºå·²è®¿é—®

# å…³é”®ï¼šèŠ‚ç‚¹åœ¨åŠ å…¥é˜Ÿåˆ—æ—¶å°±æ ‡è®°ä¸ºå·²è®¿é—®
# è€Œä¸æ˜¯åœ¨å‡ºé˜Ÿåˆ—æ—¶æ ‡è®°ï¼Œé¿å…é‡å¤åŠ å…¥é˜Ÿåˆ—
```

---

## 4. ğŸ”¨ å®ç°æ–¹æ³•


### 4.1 åŸºç¡€å®ç°ï¼ˆPythonï¼‰


```python
from collections import deque

def bfs_basic(graph, start):
    """
    BFSåŸºç¡€å®ç°
    """
    visited = set()
    queue = deque([start])
    visited.add(start)
    result = []
    
    while queue:
        # ä»é˜Ÿåˆ—å¤´éƒ¨å–å‡ºèŠ‚ç‚¹
        current = queue.popleft()
        result.append(current)
        print(f"è®¿é—®: {current}")
        
        # å°†æœªè®¿é—®çš„é‚»å±…åŠ å…¥é˜Ÿåˆ—
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result
```

### 4.2 å±‚æ¬¡éå†å®ç°


```python
def bfs_level_order(graph, start):
    """
    BFSå±‚æ¬¡éå†å®ç°
    è¿”å›æ¯ä¸€å±‚çš„èŠ‚ç‚¹
    """
    if start not in graph:
        return []
    
    visited = set([start])
    current_level = [start]
    levels = []
    
    while current_level:
        levels.append(current_level.copy())
        next_level = []
        
        for node in current_level:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    next_level.append(neighbor)
        
        current_level = next_level
    
    return levels
```

### 4.3 æœ€çŸ­è·¯å¾„å®ç°


```python
def bfs_shortest_path(graph, start, target):
    """
    ä½¿ç”¨BFSæŸ¥æ‰¾æœ€çŸ­è·¯å¾„
    """
    if start == target:
        return [start]
    
    visited = set([start])
    queue = deque([(start, [start])])  # (èŠ‚ç‚¹, è·¯å¾„)
    
    while queue:
        current, path = queue.popleft()
        
        for neighbor in graph[current]:
            if neighbor not in visited:
                new_path = path + [neighbor]
                
                if neighbor == target:
                    return new_path
                
                visited.add(neighbor)
                queue.append((neighbor, new_path))
    
    return None  # æœªæ‰¾åˆ°è·¯å¾„
```

### 4.4 è·ç¦»è®¡ç®—å®ç°


```python
def bfs_distances(graph, start):
    """
    è®¡ç®—èµ·å§‹èŠ‚ç‚¹åˆ°æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    """
    distances = {start: 0}
    visited = set([start])
    queue = deque([start])
    
    while queue:
        current = queue.popleft()
        current_distance = distances[current]
        
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
    
    return distances
```

### 4.5 Javaå®ç°


```java
import java.util.*;

public class BFS {
    // åŸºç¡€BFS
    public static List<String> bfsBasic(Map<String, List<String>> graph, String start) {
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        List<String> result = new ArrayList<>();
        
        queue.offer(start);
        visited.add(start);
        
        while (!queue.isEmpty()) {
            String current = queue.poll();
            result.add(current);
            System.out.println("è®¿é—®: " + current);
            
            for (String neighbor : graph.get(current)) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        
        return result;
    }
    
    // æœ€çŸ­è·¯å¾„BFS
    public static List<String> bfsShortestPath(Map<String, List<String>> graph, 
                                              String start, String target) {
        if (start.equals(target)) {
            return Arrays.asList(start);
        }
        
        Set<String> visited = new HashSet<>();
        Queue<List<String>> queue = new LinkedList<>();
        
        queue.offer(Arrays.asList(start));
        visited.add(start);
        
        while (!queue.isEmpty()) {
            List<String> path = queue.poll();
            String current = path.get(path.size() - 1);
            
            for (String neighbor : graph.get(current)) {
                if (!visited.contains(neighbor)) {
                    List<String> newPath = new ArrayList<>(path);
                    newPath.add(neighbor);
                    
                    if (neighbor.equals(target)) {
                        return newPath;
                    }
                    
                    visited.add(neighbor);
                    queue.offer(newPath);
                }
            }
        }
        
        return null; // æœªæ‰¾åˆ°è·¯å¾„
    }
}
```

### 4.6 C++å®ç°


```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <unordered_set>

class BFS {
public:
    // åŸºç¡€BFS
    static std::vector<char> bfsBasic(const std::unordered_map<char, std::vector<char>>& graph, 
                                     char start) {
        std::unordered_set<char> visited;
        std::queue<char> queue;
        std::vector<char> result;
        
        queue.push(start);
        visited.insert(start);
        
        while (!queue.empty()) {
            char current = queue.front();
            queue.pop();
            result.push_back(current);
            std::cout << "è®¿é—®: " << current << std::endl;
            
            if (graph.find(current) != graph.end()) {
                for (char neighbor : graph.at(current)) {
                    if (visited.find(neighbor) == visited.end()) {
                        visited.insert(neighbor);
                        queue.push(neighbor);
                    }
                }
            }
        }
        
        return result;
    }
    
    // è·ç¦»è®¡ç®—BFS
    static std::unordered_map<char, int> bfsDistances(
        const std::unordered_map<char, std::vector<char>>& graph, char start) {
        
        std::unordered_map<char, int> distances;
        std::unordered_set<char> visited;
        std::queue<char> queue;
        
        queue.push(start);
        visited.insert(start);
        distances[start] = 0;
        
        while (!queue.empty()) {
            char current = queue.front();
            queue.pop();
            int currentDistance = distances[current];
            
            if (graph.find(current) != graph.end()) {
                for (char neighbor : graph.at(current)) {
                    if (visited.find(neighbor) == visited.end()) {
                        visited.insert(neighbor);
                        distances[neighbor] = currentDistance + 1;
                        queue.push(neighbor);
                    }
                }
            }
        }
        
        return distances;
    }
};
```

---

## 5. ğŸ“Š ç®—æ³•åˆ†æ


### 5.1 æ—¶é—´å¤æ‚åº¦

- **å›¾çš„BFS**ï¼š`O(V + E)` <span style="color:#22c55e">âœ… çº¿æ€§æ—¶é—´</span>
  - Vï¼šé¡¶ç‚¹æ•°é‡ï¼ŒEï¼šè¾¹çš„æ•°é‡
  - æ¯ä¸ªé¡¶ç‚¹è®¿é—®ä¸€æ¬¡ï¼Œæ¯æ¡è¾¹æ£€æŸ¥ä¸€æ¬¡
- **æ ‘çš„BFS**ï¼š`O(n)` <span style="color:#22c55e">âœ… çº¿æ€§æ—¶é—´</span>
  - nï¼šèŠ‚ç‚¹æ•°é‡

### 5.2 ç©ºé—´å¤æ‚åº¦

- **é˜Ÿåˆ—ç©ºé—´**ï¼š`O(V)` <span style="color:#f59e0b">âš ï¸ æœ€å¤§å®½åº¦</span>
- **è®¿é—®æ ‡è®°**ï¼š`O(V)` <span style="color:#f59e0b">âš ï¸ æ ‡è®°æ•°ç»„</span>
- **æ€»ç©ºé—´å¤æ‚åº¦**ï¼š`O(V)`

### 5.3 ç©ºé—´å¤æ‚åº¦è¯¦è§£

```
ä¸ºä»€ä¹ˆBFSç©ºé—´å¤æ‚åº¦æ˜¯O(V)ï¼Ÿ

æœ€åæƒ…å†µï¼šå›¾å‘ˆç°"æ˜Ÿå½¢"ç»“æ„
        A
   /  /  \  \  \
  B  C   D  E  F

ç¬¬1å±‚ï¼šé˜Ÿåˆ—ä¸­æœ‰1ä¸ªèŠ‚ç‚¹ [A]
ç¬¬2å±‚ï¼šé˜Ÿåˆ—ä¸­æœ‰4ä¸ªèŠ‚ç‚¹ [B,C,D,E,F]

åœ¨æœ€å®½çš„ä¸€å±‚ï¼Œé˜Ÿåˆ—å¯èƒ½åŒ…å«O(V)ä¸ªèŠ‚ç‚¹
æ‰€ä»¥ç©ºé—´å¤æ‚åº¦ä¸ºO(V)
```

### 5.4 æ€§èƒ½ç‰¹ç‚¹

- **ğŸ”¸ æœ€çŸ­è·¯å¾„ä¿è¯**ï¼šåœ¨æ— æƒå›¾ä¸­ä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„
- **ğŸ”¸ å±‚æ¬¡éå†**ï¼šå¤©ç„¶æ”¯æŒæŒ‰å±‚æ¬¡è®¿é—®
- **ğŸ”¸ å†…å­˜æ¶ˆè€—å¤§**ï¼šéœ€è¦å­˜å‚¨æ•´å±‚çš„èŠ‚ç‚¹
- **ğŸ”¸ é€‚åˆå®½åº¦æœç´¢**ï¼šåœ¨å›¾è¾ƒå®½æ—¶è¡¨ç°è‰¯å¥½

---

## 6. ğŸ¯ å…¸å‹åº”ç”¨


### 6.1 æœ€çŸ­è·¯å¾„é—®é¢˜


```python
def shortest_path_length(graph, start, target):
    """
    è®¡ç®—æœ€çŸ­è·¯å¾„é•¿åº¦
    åº”ç”¨ï¼šç¤¾äº¤ç½‘ç»œä¸­çš„å…­åº¦åˆ†éš”ç†è®º
    """
    if start == target:
        return 0
    
    visited = set([start])
    queue = deque([(start, 0)])  # (èŠ‚ç‚¹, è·ç¦»)
    
    while queue:
        current, distance = queue.popleft()
        
        for neighbor in graph[current]:
            if neighbor == target:
                return distance + 1
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, distance + 1))
    
    return -1  # æœªæ‰¾åˆ°è·¯å¾„

# ç¤ºä¾‹ï¼šç¤¾äº¤ç½‘ç»œæœ€çŸ­å…³ç³»é“¾
social_network = {
    'å¼ ä¸‰': ['æå››', 'ç‹äº”'],
    'æå››': ['å¼ ä¸‰', 'èµµå…­'],
    'ç‹äº”': ['å¼ ä¸‰', 'å­™ä¸ƒ'],
    'èµµå…­': ['æå››'],
    'å­™ä¸ƒ': ['ç‹äº”', 'å‘¨å…«'],
    'å‘¨å…«': ['å­™ä¸ƒ']
}

distance = shortest_path_length(social_network, 'å¼ ä¸‰', 'å‘¨å…«')
print(f"å¼ ä¸‰åˆ°å‘¨å…«çš„æœ€çŸ­å…³ç³»é“¾é•¿åº¦: {distance}")
```

### 6.2 å±‚æ¬¡éå†åº”ç”¨


```python
def level_order_traversal(graph, start):
    """
    å±‚æ¬¡éå† - æŒ‰å±‚è¾“å‡ºèŠ‚ç‚¹
    åº”ç”¨ï¼šç»„ç»‡æ¶æ„å±‚çº§æ˜¾ç¤ºã€æ–‡ä»¶ç›®å½•å±‚çº§
    """
    levels = bfs_level_order(graph, start)
    
    for i, level in enumerate(levels):
        print(f"ç¬¬{i}å±‚: {level}")
    
    return levels

# ç¤ºä¾‹ï¼šå…¬å¸ç»„ç»‡æ¶æ„
org_structure = {
    'CEO': ['VP1', 'VP2'],
    'VP1': ['Manager1', 'Manager2'],
    'VP2': ['Manager3'],
    'Manager1': ['Employee1', 'Employee2'],
    'Manager2': ['Employee3'],
    'Manager3': ['Employee4', 'Employee5'],
    'Employee1': [], 'Employee2': [], 'Employee3': [],
    'Employee4': [], 'Employee5': []
}

print("å…¬å¸ç»„ç»‡æ¶æ„å±‚æ¬¡:")
level_order_traversal(org_structure, 'CEO')
```

### 6.3 è¿é€šæ€§æ£€æµ‹


```python
def is_connected(graph, start, target):
    """
    æ£€æµ‹ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿é€š
    åº”ç”¨ï¼šç½‘ç»œè¿é€šæ€§ã€å¯è¾¾æ€§åˆ†æ
    """
    if start == target:
        return True
    
    visited = set([start])
    queue = deque([start])
    
    while queue:
        current = queue.popleft()
        
        for neighbor in graph[current]:
            if neighbor == target:
                return True
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return False

def count_reachable_nodes(graph, start):
    """
    ç»Ÿè®¡ä»èµ·å§‹èŠ‚ç‚¹å¯è¾¾çš„æ‰€æœ‰èŠ‚ç‚¹æ•°é‡
    """
    visited = set([start])
    queue = deque([start])
    
    while queue:
        current = queue.popleft()
        
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return len(visited)
```

### 6.4 æœ€å°æ­¥æ•°é—®é¢˜


```python
def min_steps_to_transform(start_word, target_word, word_list):
    """
    å•è¯å˜æ¢æœ€å°æ­¥æ•°ï¼ˆæ¯æ¬¡åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ï¼‰
    åº”ç”¨ï¼šåŸºå› åºåˆ—å˜å¼‚ã€æ‹¼å†™æ£€æŸ¥å»ºè®®
    """
    if target_word not in word_list:
        return -1
    
    def can_transform(word1, word2):
        """æ£€æŸ¥ä¸¤ä¸ªå•è¯æ˜¯å¦åªå·®ä¸€ä¸ªå­—æ¯"""
        diff_count = 0
        for i in range(len(word1)):
            if word1[i] != word2[i]:
                diff_count += 1
                if diff_count > 1:
                    return False
        return diff_count == 1
    
    visited = set([start_word])
    queue = deque([(start_word, 0)])
    
    while queue:
        current_word, steps = queue.popleft()
        
        if current_word == target_word:
            return steps
        
        for word in word_list:
            if word not in visited and can_transform(current_word, word):
                visited.add(word)
                queue.append((word, steps + 1))
    
    return -1

# ç¤ºä¾‹ä½¿ç”¨
word_list = ["hot", "dot", "dog", "lot", "log", "cog"]
steps = min_steps_to_transform("hit", "cog", word_list)
print(f"ä» 'hit' å˜æ¢åˆ° 'cog' çš„æœ€å°æ­¥æ•°: {steps}")
```

### 6.5 äºŒç»´ç½‘æ ¼BFS


```python
def shortest_path_in_grid(grid, start, target):
    """
    äºŒç»´ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„
    åº”ç”¨ï¼šæ¸¸æˆåœ°å›¾å¯»è·¯ã€æœºå™¨äººè·¯å¾„è§„åˆ’
    """
    rows, cols = len(grid), len(grid[0])
    start_row, start_col = start
    target_row, target_col = target
    
    if grid[start_row][start_col] == 1 or grid[target_row][target_col] == 1:
        return -1  # èµ·ç‚¹æˆ–ç»ˆç‚¹è¢«é˜»æŒ¡
    
    visited = set([(start_row, start_col)])
    queue = deque([(start_row, start_col, 0)])  # (è¡Œ, åˆ—, è·ç¦»)
    
    # å››ä¸ªæ–¹å‘ï¼šä¸Šã€ä¸‹ã€å·¦ã€å³
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        row, col, distance = queue.popleft()
        
        if (row, col) == (target_row, target_col):
            return distance
        
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            if (0 <= new_row < rows and 
                0 <= new_col < cols and 
                grid[new_row][new_col] == 0 and 
                (new_row, new_col) not in visited):
                
                visited.add((new_row, new_col))
                queue.append((new_row, new_col, distance + 1))
    
    return -1  # æ— æ³•åˆ°è¾¾

# ç¤ºä¾‹ï¼šç½‘æ ¼å¯»è·¯
grid = [
    [0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0],
    [1, 1, 0, 1, 0],
    [0, 0, 0, 0, 0]
]

path_length = shortest_path_in_grid(grid, (0, 0), (4, 4))
print(f"æœ€çŸ­è·¯å¾„é•¿åº¦: {path_length}")
```

---

## 7. âš–ï¸ å¯¹æ¯”åˆ†æ


### 7.1 BFS vs DFS


| ç‰¹æ€§ | BFS | DFS |
|------|-----|-----|
| **æœç´¢ç­–ç•¥** | å¹¿åº¦ä¼˜å…ˆï¼ˆå±‚æ¬¡ï¼‰ | æ·±åº¦ä¼˜å…ˆï¼ˆçºµå‘ï¼‰ |
| **æ•°æ®ç»“æ„** | é˜Ÿåˆ—ï¼ˆFIFOï¼‰ | æ ˆï¼ˆLIFOï¼‰ |
| **ç©ºé—´å¤æ‚åº¦** | O(w) æœ€å¤§å®½åº¦ | O(h) æœ€å¤§æ·±åº¦ |
| **æœ€çŸ­è·¯å¾„** | <span style="color:#22c55e">âœ… ä¿è¯æœ€çŸ­</span> | <span style="color:#ef4444">âŒ ä¸ä¿è¯</span> |
| **å†…å­˜ä½¿ç”¨** | è¾ƒå¤šï¼ˆå­˜å‚¨æ•´å±‚ï¼‰ | è¾ƒå°‘ï¼ˆå­˜å‚¨è·¯å¾„ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | æœ€çŸ­è·¯å¾„ã€å±‚æ¬¡éå† | è·¯å¾„å­˜åœ¨æ€§ã€å›æº¯ |

### 7.2 å…·ä½“åœºæ™¯é€‰æ‹©


```python
# é€‰æ‹©BFSçš„åœºæ™¯
åœºæ™¯1: å¯»æ‰¾æœ€çŸ­è·¯å¾„
åŸå› : BFSä¿è¯æ‰¾åˆ°è¾¹æ•°æœ€å°‘çš„è·¯å¾„

åœºæ™¯2: å±‚æ¬¡éå†
åŸå› : BFSå¤©ç„¶æŒ‰å±‚è®¿é—®èŠ‚ç‚¹

åœºæ™¯3: æœ€å°æ­¥æ•°é—®é¢˜
åŸå› : BFSç¬¬ä¸€æ¬¡åˆ°è¾¾ç›®æ ‡å°±æ˜¯æœ€å°‘æ­¥æ•°

# é€‰æ‹©DFSçš„åœºæ™¯
åœºæ™¯1: åˆ¤æ–­è·¯å¾„æ˜¯å¦å­˜åœ¨
åŸå› : DFSæ‰¾åˆ°è·¯å¾„å°±åœæ­¢ï¼Œå¯èƒ½æ›´å¿«

åœºæ™¯2: æ‹“æ‰‘æ’åº
åŸå› : DFSçš„ååºéå†é€‚åˆæ‹“æ‰‘æ’åº

åœºæ™¯3: æ£€æµ‹ç¯
åŸå› : DFSçš„å›æº¯ç‰¹æ€§é€‚åˆç¯æ£€æµ‹
```

### 7.3 æ€§èƒ½å¯¹æ¯”ç¤ºä¾‹


```python
def compare_bfs_dfs_performance(graph, start, target):
    """
    æ¯”è¾ƒBFSå’ŒDFSåœ¨å¯»æ‰¾è·¯å¾„æ—¶çš„æ€§èƒ½
    """
    import time
    
    # BFSå¯»æ‰¾æœ€çŸ­è·¯å¾„
    start_time = time.time()
    bfs_path = bfs_shortest_path(graph, start, target)
    bfs_time = time.time() - start_time
    
    # DFSå¯»æ‰¾ä»»æ„è·¯å¾„
    start_time = time.time()
    dfs_path = dfs_find_path(graph, start, target)  # å‡è®¾æœ‰DFSå®ç°
    dfs_time = time.time() - start_time
    
    print(f"BFSè·¯å¾„é•¿åº¦: {len(bfs_path) if bfs_path else 0}, æ—¶é—´: {bfs_time:.6f}s")
    print(f"DFSè·¯å¾„é•¿åº¦: {len(dfs_path) if dfs_path else 0}, æ—¶é—´: {dfs_time:.6f}s")
    print(f"BFSæ‰¾åˆ°çš„æ˜¯æœ€çŸ­è·¯å¾„: {bfs_path}")
    print(f"DFSæ‰¾åˆ°çš„è·¯å¾„: {dfs_path}")
```

---

## 8. ğŸ“‹ æ€»ç»“


### 8.1 æ ¸å¿ƒè¦ç‚¹

1. **ğŸ”¸ å¹¿åº¦ä¼˜å…ˆ**ï¼šæŒ‰å±‚æ¬¡ä»è¿‘åˆ°è¿œé€å±‚è®¿é—®èŠ‚ç‚¹
2. **ğŸ”¸ é˜Ÿåˆ—é©±åŠ¨**ï¼šä½¿ç”¨é˜Ÿåˆ—å®ç°å…ˆè¿›å…ˆå‡ºçš„è®¿é—®é¡ºåº
3. **ğŸ”¸ æœ€çŸ­è·¯å¾„**ï¼šåœ¨æ— æƒå›¾ä¸­ä¿è¯æ‰¾åˆ°æœ€çŸ­è·¯å¾„
4. **ğŸ”¸ å±‚æ¬¡éå†**ï¼šå¤©ç„¶æ”¯æŒæŒ‰è·ç¦»åˆ†å±‚çš„éå†æ–¹å¼
5. **ğŸ”¸ ç©ºé—´æ¢æ—¶é—´**ï¼šç”¨æ›´å¤šå†…å­˜æ¢å–æœ€çŸ­è·¯å¾„ä¿è¯

### 8.2 å…³é”®æŠ€æœ¯ç‚¹

- **é˜Ÿåˆ—ç®¡ç†**ï¼šæ­£ç¡®ä½¿ç”¨é˜Ÿåˆ—çš„å…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œ
- **è®¿é—®æ ‡è®°**ï¼šåœ¨èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—æ—¶ç«‹å³æ ‡è®°ï¼Œé¿å…é‡å¤
- **å±‚æ¬¡æ§åˆ¶**ï¼šå¯ä»¥é€šè¿‡é˜Ÿåˆ—å¤§å°æ§åˆ¶æŒ‰å±‚è®¿é—®
- **è·ç¦»è®°å½•**ï¼šåœ¨å¯»æ‰¾æœ€çŸ­è·¯å¾„æ—¶è®°å½•è·ç¦»ä¿¡æ¯
- **è·¯å¾„é‡å»º**ï¼šé€šè¿‡çˆ¶èŠ‚ç‚¹ä¿¡æ¯é‡å»ºå®Œæ•´è·¯å¾„

### 8.3 é€‚ç”¨åœºæ™¯


**æ¨èä½¿ç”¨BFSçš„æƒ…å†µï¼š**
- âœ… å¯»æ‰¾æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰
- âœ… å±‚æ¬¡éå†éœ€æ±‚
- âœ… æœ€å°æ­¥æ•°é—®é¢˜
- âœ… è¿é€šæ€§æ£€æµ‹
- âœ… ç¤¾äº¤ç½‘ç»œåˆ†æ

**ä¸æ¨èä½¿ç”¨BFSçš„æƒ…å†µï¼š**
- âŒ åªéœ€åˆ¤æ–­è·¯å¾„å­˜åœ¨æ€§
- âŒ å›¾çš„å®½åº¦å¾ˆå¤§ï¼ˆå†…å­˜ä¸è¶³ï¼‰
- âŒ éœ€è¦æ‰€æœ‰è·¯å¾„ï¼ˆä¸åªæ˜¯æœ€çŸ­ï¼‰
- âŒ æ‹“æ‰‘æ’åºç­‰ç‰¹å®šé—®é¢˜

### 8.4 å®ç”¨å»ºè®®

- **å†…å­˜ç®¡ç†**ï¼šåœ¨å®½åº¦å¾ˆå¤§çš„å›¾ä¸­æ³¨æ„å†…å­˜ä½¿ç”¨
- **æå‰ç»ˆæ­¢**ï¼šæ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹æ—¶ç«‹å³è¿”å›
- **è·ç¦»è®°å½•**ï¼šä½¿ç”¨è·ç¦»æ•°ç»„é¿å…è·¯å¾„é‡å»ºå¼€é”€
- **åŒå‘BFS**ï¼šåœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨åŒå‘BFSä¼˜åŒ–

### 8.5 å¸¸è§åº”ç”¨æ¨¡å¼


```python
# æ¨¡å¼1ï¼šåŸºç¡€éå†
def bfs_traversal(graph, start):
    # æ ‡å‡†çš„BFSéå†æ¨¡æ¿

# æ¨¡å¼2ï¼šæœ€çŸ­è·¯å¾„
def bfs_shortest_path(graph, start, target):
    # å¸¦è·¯å¾„è®°å½•çš„BFS

# æ¨¡å¼3ï¼šå±‚æ¬¡éå†
def bfs_level_order(graph, start):
    # æŒ‰å±‚è¾“å‡ºçš„BFS

# æ¨¡å¼4ï¼šå¤šæºBFS
def multi_source_bfs(graph, sources):
    # ä»å¤šä¸ªæºç‚¹åŒæ—¶å¼€å§‹çš„BFS
```

