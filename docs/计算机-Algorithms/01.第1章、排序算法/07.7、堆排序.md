---
title: 7、堆排序
---
## 📚 目录

1. [算法概述](#1-算法概述)
2. [基本思想](#2-基本思想)
3. [算法原理](#3-算法原理)
4. [实现方法](#4-实现方法)
5. [算法分析](#5-算法分析)
6. [应用场景](#6-应用场景)
7. [对比分析](#7-对比分析)
8. [总结](#8-总结)

---

## 1. 📖 算法概述


### 1.1 定义

堆排序（Heap Sort）是一种基于堆数据结构的比较排序算法。它利用堆这种数据结构的特性，通过构建最大堆（或最小堆），然后反复提取堆顶元素并重新调整堆结构来实现排序。

### 1.2 历史背景

- **发明者**：J. W. J. Williams（1964年）
- **改进者**：Robert Floyd（提出了更高效的建堆方法）
- **意义**：第一个时间复杂度为O(n log n)的原地排序算法
- **地位**：理论上重要的排序算法，在优先队列中广泛应用

### 1.3 核心特征

- **🔹 不稳定排序**：相等元素的相对位置可能改变
- **🔹 原地排序**：只需要O(1)的额外空间
- **🔹 时间复杂度稳定**：任何情况下都是O(n log n)
- **🔹 基于堆结构**：利用完全二叉树的性质

### 1.4 算法分类

- 比较排序算法
- 原地排序算法
- 不稳定排序算法
- 选择排序的改进版

---

## 2. 💡 基本思想


### 2.1 核心思想

堆排序基于堆数据结构，包含两个主要阶段：
1. **建堆阶段**：将无序数组构建成最大堆
2. **排序阶段**：反复提取堆顶最大元素，放到数组末尾，并重新调整堆

### 2.2 为什么有效？

- **堆的性质**：最大堆的根节点总是最大元素
- **原地操作**：可以在原数组上进行操作
- **时间稳定**：无论输入如何，时间复杂度都是O(n log n)
- **简单直观**：算法逻辑清晰易懂

### 2.3 排序过程示例

以数组 [4, 10, 3, 5, 1] 为例：

```
原始数组: [4, 10, 3, 5, 1]

第一阶段：建堆
初始状态:     4
            /   \
           10    3
          /  \
         5    1

建堆后:      10        数组: [10, 5, 3, 4, 1]
           /   \
          5     3
         / \
        4   1

第二阶段：排序
第1次: 交换10和1，重新调整堆
       1               数组: [1, 5, 3, 4, 10]
      / \       ->     调整后: [5, 4, 3, 1, 10]
     5   3
    /
   4

第2次: 交换5和1，重新调整堆
       1               数组: [1, 4, 3, 5, 10]
      / \       ->     调整后: [4, 1, 3, 5, 10]
     4   3

第3次: 交换4和3，重新调整堆
       3               数组: [3, 1, 4, 5, 10]
      /         ->     调整后: [3, 1, 4, 5, 10]
     1

第4次: 交换3和1
       1               数组: [1, 3, 4, 5, 10]

最终结果: [1, 3, 4, 5, 10]
```

---

## 3. ⚙️ 算法原理


### 3.1 工作机制

1. **建堆**：将无序数组调整为最大堆
2. **交换**：将堆顶（最大元素）与堆的最后一个元素交换
3. **调整**：对交换后的堆（除去最后一个元素）重新进行堆化
4. **重复**：重复步骤2-3，直到堆的大小为1

### 3.2 关键概念


##### 3.2.1 堆（Heap）

- **定义**：完全二叉树，满足堆性质
- **最大堆性质**：父节点的值大于或等于其子节点的值
- **最小堆性质**：父节点的值小于或等于其子节点的值
- **数组表示**：对于索引i的节点，左子节点为2i+1，右子节点为2i+2，父节点为(i-1)/2

##### 3.2.2 堆化（Heapify）

- **定义**：调整数组使其满足堆性质的过程
- **向下调整**：从某个节点开始向下调整，确保子树满足堆性质
- **时间复杂度**：O(log n)

### 3.3 数组与堆的对应关系

```
数组: [10, 5, 3, 4, 1]
索引:   0  1  2  3  4

对应的堆结构:
        10 (index 0)
       /  \
      5    3 (index 1, 2)
     / \
    4   1 (index 3, 4)

节点关系：
- 节点i的左子节点：2*i + 1
- 节点i的右子节点：2*i + 2  
- 节点i的父节点：(i-1) / 2
```

---

## 4. 🔨 实现方法


### 4.1 基础实现（Python）


```python
def heap_sort(arr):
    """
    堆排序主函数
    """
    def heapify(arr, n, i):
        """
        向下调整堆，使以i为根的子树满足最大堆性质
        arr: 数组
        n: 堆的大小
        i: 当前根节点索引
        """
        largest = i      # 假设根节点最大
        left = 2 * i + 1    # 左子节点
        right = 2 * i + 2   # 右子节点
        
        # 如果左子节点存在且大于根节点
        if left < n and arr[left] > arr[largest]:
            largest = left
        
        # 如果右子节点存在且大于当前最大值
        if right < n and arr[right] > arr[largest]:
            largest = right
        
        # 如果最大值不是根节点，交换并继续调整
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)
    
    def build_max_heap(arr):
        """
        构建最大堆
        """
        n = len(arr)
        # 从最后一个非叶子节点开始，向上调整
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
    
    # 复制数组避免修改原数组
    arr_copy = arr.copy()
    n = len(arr_copy)
    
    # 第一阶段：构建最大堆
    build_max_heap(arr_copy)
    
    # 第二阶段：逐个提取最大元素
    for i in range(n - 1, 0, -1):
        # 将堆顶（最大元素）移到数组末尾
        arr_copy[0], arr_copy[i] = arr_copy[i], arr_copy[0]
        
        # 对剩余元素重新调整为最大堆
        heapify(arr_copy, i, 0)
    
    return arr_copy
```

### 4.2 迭代版本实现


```python
def heap_sort_iterative(arr):
    """
    堆排序的迭代实现（避免递归）
    """
    def heapify_iterative(arr, n, i):
        """
        迭代版本的向下调整
        """
        while True:
            largest = i
            left = 2 * i + 1
            right = 2 * i + 2
            
            # 找到最大值的索引
            if left < n and arr[left] > arr[largest]:
                largest = left
            
            if right < n and arr[right] > arr[largest]:
                largest = right
            
            # 如果最大值就是当前节点，调整完成
            if largest == i:
                break
            
            # 交换并继续向下调整
            arr[i], arr[largest] = arr[largest], arr[i]
            i = largest
    
    arr_copy = arr.copy()
    n = len(arr_copy)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify_iterative(arr_copy, n, i)
    
    # 堆排序
    for i in range(n - 1, 0, -1):
        arr_copy[0], arr_copy[i] = arr_copy[i], arr_copy[0]
        heapify_iterative(arr_copy, i, 0)
    
    return arr_copy
```

### 4.3 Java 实现


```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆
        buildMaxHeap(arr);
        
        // 逐个提取堆顶元素
        for (int i = n - 1; i > 0; i--) {
            // 将堆顶移到数组末尾
            swap(arr, 0, i);
            
            // 重新调整堆
            heapify(arr, i, 0);
        }
    }
    
    private static void buildMaxHeap(int[] arr) {
        int n = arr.length;
        // 从最后一个非叶子节点开始调整
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;    // 根节点
        int left = 2 * i + 1;   // 左子节点
        int right = 2 * i + 2;  // 右子节点
        
        // 找到最大值
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // 如果最大值不是根节点，交换并递归调整
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.4 C++ 实现


```cpp
#include <vector>
#include <algorithm>
using namespace std;

class HeapSort {
public:
    static void heapSort(vector<int>& arr) {
        int n = arr.size();
        
        // 构建最大堆
        buildMaxHeap(arr);
        
        // 堆排序
        for (int i = n - 1; i > 0; i--) {
            swap(arr[0], arr[i]);
            heapify(arr, i, 0);
        }
    }
    
private:
    static void buildMaxHeap(vector<int>& arr) {
        int n = arr.size();
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
    
    static void heapify(vector<int>& arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }
};
```

---

## 5. 📊 算法分析


### 5.1 时间复杂度


##### 5.1.1 各种情况下的复杂度

- **最佳情况**：`O(n log n)` <span style="color:#22c55e">✅ 稳定</span>
- **平均情况**：`O(n log n)` <span style="color:#22c55e">✅ 稳定</span>
- **最坏情况**：`O(n log n)` <span style="color:#22c55e">✅ 稳定</span>

##### 5.1.2 复杂度分析


**建堆阶段**：
- **单次heapify**：O(log n)
- **建堆总次数**：n/2次（从最后一个非叶子节点开始）
- **建堆总时间**：O(n)（通过数学分析可证明）

**排序阶段**：
- **交换次数**：n-1次
- **每次heapify**：O(log n)
- **排序总时间**：O(n log n)

**总时间复杂度**：O(n) + O(n log n) = O(n log n)

### 5.2 空间复杂度

- **复杂度**：`O(1)` <span style="color:#22c55e">✅ 优秀</span>
- **原因**：只使用了常数个额外变量，原地排序

### 5.3 稳定性分析

- **不稳定排序**：<span style="color:#ef4444">❌ 不稳定</span>
- **原因**：堆调整过程中可能改变相等元素的相对位置

### 5.4 性能特点

- **🔸 时间复杂度稳定**：不受输入数据分布影响
- **🔸 空间效率高**：原地排序，空间复杂度O(1)
- **🔸 不适应性**：对于部分有序的数组没有优化
- **🔸 缓存不友好**：访问模式相对随机

---

## 6. 🎯 应用场景


### 6.1 适用情况

- **🔸 内存严格受限**：需要原地排序且空间复杂度要求O(1)
- **🔸 时间要求稳定**：需要保证最坏情况性能
- **🔸 不要求稳定性**：不需要保持相等元素相对位置
- **🔸 优先队列实现**：堆是优先队列的理想实现
- **🔸 Top-K问题**：查找最大或最小的K个元素

### 6.2 不适用情况

- **🔸 稳定性要求**：需要保持相等元素相对位置
- **🔸 小规模数据**：简单排序算法可能更高效
- **🔸 缓存敏感**：对缓存性能要求高的场景

### 6.3 典型应用


```python
# 基本排序应用
def sort_array(arr):
    """基本数组排序"""
    return heap_sort(arr)

# Top-K问题
def find_k_largest(arr, k):
    """
    查找数组中最大的K个元素
    """
    import heapq
    
    # 使用最小堆，维护K个最大元素
    min_heap = []
    
    for num in arr:
        if len(min_heap) < k:
            heapq.heappush(min_heap, num)
        elif num > min_heap[0]:
            heapq.heapreplace(min_heap, num)
    
    return sorted(min_heap, reverse=True)

# 优先队列应用
class PriorityQueue:
    """基于堆的优先队列"""
    
    def __init__(self):
        self.heap = []
    
    def push(self, item, priority):
        """插入元素"""
        # 使用负数实现最大堆
        heapq.heappush(self.heap, (-priority, item))
    
    def pop(self):
        """弹出最高优先级元素"""
        if self.heap:
            priority, item = heapq.heappop(self.heap)
            return item, -priority
        return None
    
    def is_empty(self):
        """检查是否为空"""
        return len(self.heap) == 0

# 数据流中的中位数
class MedianFinder:
    """维护数据流中的中位数"""
    
    def __init__(self):
        # 最大堆存储较小的一半
        self.max_heap = []
        # 最小堆存储较大的一半  
        self.min_heap = []
    
    def add_number(self, num):
        """添加数字"""
        if not self.max_heap or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)
        else:
            heapq.heappush(self.min_heap, num)
        
        # 平衡两个堆的大小
        if len(self.max_heap) > len(self.min_heap) + 1:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, val)
        elif len(self.min_heap) > len(self.max_heap) + 1:
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, -val)
    
    def find_median(self):
        """查找中位数"""
        if len(self.max_heap) == len(self.min_heap):
            return (-self.max_heap[0] + self.min_heap[0]) / 2.0
        elif len(self.max_heap) > len(self.min_heap):
            return float(-self.max_heap[0])
        else:
            return float(self.min_heap[0])
```

---

## 7. ⚖️ 对比分析


### 7.1 与其他排序算法对比


| 算法 | 时间复杂度（平均） | 空间复杂度 | 稳定性 | 原地排序 |
|------|------------------|------------|---------|----------|
| 堆排序 | O(n log n) | O(1) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 快速排序 | O(n log n) | O(log n) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 归并排序 | O(n log n) | O(n) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#ef4444">❌ 否</span> |
| 希尔排序 | O(n^1.3) | O(1) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 插入排序 | O(n²) | O(1) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#22c55e">✅ 是</span> |

### 7.2 优缺点总结


##### 7.2.1 主要优点

- **时间复杂度稳定**：任何情况下都是O(n log n)
- **空间复杂度优秀**：原地排序，只需O(1)额外空间
- **最坏情况可控**：没有退化到O(n²)的风险
- **实现相对简单**：算法逻辑清晰
- **理论价值高**：在算法分析中具有重要地位

##### 7.2.2 主要缺点

- **不稳定**：不能保持相等元素的相对位置
- **常数因子大**：实际运行时间可能比快速排序慢
- **缓存不友好**：访问模式相对随机，缓存命中率低
- **不适应性**：对于部分有序的数组没有优化

### 7.3 选择建议


**推荐使用堆排序的情况**：
- ✅ 内存空间严格受限
- ✅ 需要保证最坏情况性能
- ✅ 不要求稳定性
- ✅ 实现优先队列
- ✅ 解决Top-K问题

**不推荐使用堆排序的情况**：
- ❌ 需要稳定排序
- ❌ 对缓存性能要求高
- ❌ 数据规模很小
- ❌ 对常数因子敏感

---

## 8. 📋 总结


### 8.1 核心要点

1. **🔸 堆数据结构**：基于完全二叉树的堆结构
2. **🔸 两阶段排序**：建堆阶段和排序阶段
3. **🔸 稳定复杂度**：时间复杂度始终为O(n log n)
4. **🔸 原地排序**：空间复杂度为O(1)
5. **🔸 理论重要性**：在算法理论中具有重要地位

### 8.2 关键技术点

- **堆的性质**：理解最大堆和最小堆的定义
- **堆化操作**：掌握向下调整的核心算法
- **建堆过程**：从最后一个非叶子节点开始调整
- **数组表示**：理解堆在数组中的存储方式
- **时间分析**：理解为什么建堆是O(n)而不是O(n log n)

### 8.3 学习重点

- **理解堆结构**：掌握堆的定义和性质
- **掌握堆化操作**：理解向下调整的具体过程
- **分析时间复杂度**：理解各阶段的时间复杂度
- **实现细节**：注意数组索引和堆节点的对应关系
- **应用扩展**：了解堆在优先队列等场景中的应用

### 8.4 实践建议

- **选择合适场景**：在内存受限且需要稳定性能时使用
- **注意实现细节**：正确处理数组索引关系
- **考虑替代方案**：在大多数情况下快速排序可能更好
- **扩展应用**：学习堆在其他算法中的应用

### 8.5 与其他算法的关系

- **选择排序的改进**：可以看作是选择排序的高效版本
- **优先队列基础**：是实现优先队列的理想数据结构
- **图算法应用**：在Dijkstra算法等中有重要应用
- **Top-K问题**：解决Top-K问题的经典方法

