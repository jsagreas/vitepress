---
title: 9、桶排序
---
## 📚 目录

1. [算法概述](#1-算法概述)
2. [基本思想](#2-基本思想)
3. [算法原理](#3-算法原理)
4. [实现方法](#4-实现方法)
5. [算法分析](#5-算法分析)
6. [应用场景](#6-应用场景)
7. [对比分析](#7-对比分析)
8. [总结](#8-总结)

---

## 1. 📖 算法概述


### 1.1 定义

桶排序（Bucket Sort）是一种分布式排序算法。它将数组分到有限数量的桶里，每个桶再个别排序（有可能使用别的排序算法或是递归地继续使用桶排序），最后将各个桶中的数据有序合并。

### 1.2 历史背景

- **理论基础**：基于分治和分布的思想
- **发展历程**：随着对排序算法研究的深入而发展
- **意义**：在数据分布均匀时可达到线性时间复杂度
- **地位**：分布排序算法的重要代表

### 1.3 核心特征

- **🔹 分布排序**：基于数据分布进行排序
- **🔹 稳定排序**：可以实现为稳定排序
- **🔹 平均线性时间**：平均时间复杂度为O(n + k)
- **🔹 分治思想**：将大问题分解为小问题

### 1.4 算法分类

- 分布排序算法
- 分治算法
- 稳定排序算法（当桶内排序稳定时）
- 外部排序算法

---

## 2. 💡 基本思想


### 2.1 核心思想

桶排序的基本思想是：
1. **数据分桶**：将数据分布到有限数量的桶中
2. **桶内排序**：对每个非空的桶进行单独排序
3. **顺序合并**：按桶的顺序将排序后的数据合并

### 2.2 为什么有效？

- **分治策略**：将大问题分解为多个小问题
- **分布优化**：利用数据的分布特性
- **并行潜力**：不同桶可以并行处理
- **局部排序**：桶内数据量小，排序效率高

### 2.3 排序过程示例

以数组 [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] 为例（数据范围[0,1)，使用10个桶）：

```
原始数组: [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]

第一步：创建桶并分配数据
桶0: []
桶1: [0.17, 0.12]
桶2: [0.26, 0.21, 0.23]  
桶3: [0.39]
桶4: []
桶5: []
桶6: [0.68]
桶7: [0.78, 0.72]
桶8: []
桶9: [0.94]

第二步：对每个桶内排序
桶0: []
桶1: [0.12, 0.17]
桶2: [0.21, 0.23, 0.26]
桶3: [0.39]
桶4: []
桶5: []
桶6: [0.68]
桶7: [0.72, 0.78]
桶8: []
桶9: [0.94]

第三步：顺序合并桶
最终结果: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]
```

---

## 3. ⚙️ 算法原理


### 3.1 工作机制

1. **确定桶数**：根据数据范围和数量确定桶的数量
2. **数据分桶**：使用映射函数将数据分配到相应的桶中
3. **桶内排序**：对每个非空桶使用其他排序算法进行排序
4. **合并结果**：按桶的顺序将排序后的数据连接起来

### 3.2 关键概念


##### 3.2.1 桶（Bucket）

- **定义**：用于存储特定范围数据的容器
- **数量**：通常与数据量n相关，如n或√n个桶
- **容量**：理想情况下每个桶包含相近数量的元素

##### 3.2.2 映射函数（Mapping Function）

- **定义**：将数据值映射到桶索引的函数
- **常用公式**：`bucket_index = floor(n * (value - min) / (max - min))`
- **重要性**：决定数据分布的均匀性

### 3.3 桶数量选择

```
桶数量的选择策略：

1. 固定桶数量：
   - bucket_count = n（数据量）
   - bucket_count = √n
   - bucket_count = 10（经验值）

2. 基于数据范围：
   - bucket_count = (max - min) / expected_range_per_bucket

3. 自适应选择：
   - 根据数据分布动态调整桶数量

理想情况：每个桶包含相近数量的元素（均匀分布）
```

---

## 4. 🔨 实现方法


### 4.1 基础实现（Python）


```python
def bucket_sort(arr):
    """
    桶排序基础实现
    """
    if not arr or len(arr) < 2:
        return arr
    
    # 找出最大值和最小值
    min_val = min(arr)
    max_val = max(arr)
    
    # 避免除零错误
    if min_val == max_val:
        return arr
    
    # 确定桶的数量
    bucket_count = len(arr)
    bucket_range = (max_val - min_val) / bucket_count
    
    # 初始化桶
    buckets = [[] for _ in range(bucket_count)]
    
    # 将数据分配到桶中
    for num in arr:
        # 计算桶索引
        if num == max_val:
            bucket_index = bucket_count - 1
        else:
            bucket_index = int((num - min_val) / bucket_range)
        buckets[bucket_index].append(num)
    
    # 对每个桶进行排序
    for bucket in buckets:
        bucket.sort()  # 使用内置排序，也可以用其他排序算法
    
    # 合并桶中的数据
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result
```

### 4.2 针对[0,1)区间的实现


```python
def bucket_sort_unit_interval(arr):
    """
    针对[0,1)区间的桶排序实现
    """
    if not arr:
        return arr
    
    n = len(arr)
    buckets = [[] for _ in range(n)]
    
    # 将数据分配到桶中
    for num in arr:
        bucket_index = int(num * n)
        # 处理边界情况
        if bucket_index == n:
            bucket_index = n - 1
        buckets[bucket_index].append(num)
    
    # 对每个桶进行排序
    for bucket in buckets:
        bucket.sort()
    
    # 合并结果
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result
```

### 4.3 使用插入排序的实现


```python
def bucket_sort_with_insertion(arr):
    """
    桶内使用插入排序的桶排序实现
    """
    def insertion_sort(bucket):
        """插入排序"""
        for i in range(1, len(bucket)):
            key = bucket[i]
            j = i - 1
            while j >= 0 and bucket[j] > key:
                bucket[j + 1] = bucket[j]
                j -= 1
            bucket[j + 1] = key
    
    if not arr or len(arr) < 2:
        return arr
    
    min_val = min(arr)
    max_val = max(arr)
    
    if min_val == max_val:
        return arr
    
    # 使用√n个桶
    import math
    bucket_count = int(math.sqrt(len(arr)))
    bucket_range = (max_val - min_val) / bucket_count
    
    buckets = [[] for _ in range(bucket_count)]
    
    # 分配数据到桶
    for num in arr:
        if num == max_val:
            bucket_index = bucket_count - 1
        else:
            bucket_index = int((num - min_val) / bucket_range)
        buckets[bucket_index].append(num)
    
    # 对每个桶进行插入排序
    for bucket in buckets:
        insertion_sort(bucket)
    
    # 合并结果
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result
```

### 4.4 Java 实现


```java
import java.util.*;

public class BucketSort {
    public static double[] bucketSort(double[] arr) {
        if (arr.length <= 1) return arr;
        
        // 找出最值
        double min = arr[0], max = arr[0];
        for (double num : arr) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        
        if (min == max) return arr;
        
        // 创建桶
        int bucketCount = arr.length;
        List<List<Double>> buckets = new ArrayList<>();
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }
        
        // 分配数据到桶
        double bucketRange = (max - min) / bucketCount;
        for (double num : arr) {
            int bucketIndex;
            if (num == max) {
                bucketIndex = bucketCount - 1;
            } else {
                bucketIndex = (int) ((num - min) / bucketRange);
            }
            buckets.get(bucketIndex).add(num);
        }
        
        // 对每个桶排序
        for (List<Double> bucket : buckets) {
            Collections.sort(bucket);
        }
        
        // 合并结果
        double[] result = new double[arr.length];
        int index = 0;
        for (List<Double> bucket : buckets) {
            for (double num : bucket) {
                result[index++] = num;
            }
        }
        
        return result;
    }
}
```

### 4.5 C++ 实现


```cpp
#include <vector>
#include <algorithm>
using namespace std;

vector<double> bucketSort(vector<double>& arr) {
    if (arr.size() <= 1) return arr;
    
    // 找出最值
    double minVal = *min_element(arr.begin(), arr.end());
    double maxVal = *max_element(arr.begin(), arr.end());
    
    if (minVal == maxVal) return arr;
    
    // 创建桶
    int bucketCount = arr.size();
    vector<vector<double>> buckets(bucketCount);
    
    // 分配数据到桶
    double bucketRange = (maxVal - minVal) / bucketCount;
    for (double num : arr) {
        int bucketIndex;
        if (num == maxVal) {
            bucketIndex = bucketCount - 1;
        } else {
            bucketIndex = (int)((num - minVal) / bucketRange);
        }
        buckets[bucketIndex].push_back(num);
    }
    
    // 对每个桶排序
    for (auto& bucket : buckets) {
        sort(bucket.begin(), bucket.end());
    }
    
    // 合并结果
    vector<double> result;
    for (const auto& bucket : buckets) {
        result.insert(result.end(), bucket.begin(), bucket.end());
    }
    
    return result;
}
```

---

## 5. 📊 算法分析


### 5.1 时间复杂度


##### 5.1.1 各阶段复杂度

- **找最值**：`O(n)` <span style="color:#22c55e">✅ 线性</span>
- **数据分桶**：`O(n)` <span style="color:#22c55e">✅ 线性</span>
- **桶内排序**：`O(k * m²)` <span style="color:#f59e0b">⚠️ 依赖分布</span>
- **合并结果**：`O(n)` <span style="color:#22c55e">✅ 线性</span>

##### 5.1.2 总时间复杂度

- **最佳情况**：`O(n + k)` <span style="color:#22c55e">✅ 线性</span>
- **平均情况**：`O(n + k)` <span style="color:#22c55e">✅ 线性</span>
- **最坏情况**：`O(n²)` <span style="color:#ef4444">❌ 平方</span>

**说明**：
- n：数据量
- k：桶的数量
- m：每个桶的平均元素数量
- 最坏情况：所有数据都分到一个桶中

### 5.2 空间复杂度

- **桶存储**：`O(n)` <span style="color:#22c55e">✅ 线性</span>
- **辅助空间**：`O(k)` <span style="color:#22c55e">✅ 线性</span>
- **总空间复杂度**：`O(n + k)`

### 5.3 稳定性分析

- **稳定排序**：<span style="color:#22c55e">✅ 可稳定</span>
- **条件**：桶内排序算法稳定，且分桶时保持相对顺序

### 5.4 性能特点

- **🔸 数据敏感**：性能高度依赖于数据分布的均匀性
- **🔸 并行友好**：不同桶可以并行处理
- **🔸 内存要求**：需要额外的桶存储空间
- **🔸 适合外部排序**：可用于大文件排序

---

## 6. 🎯 应用场景


### 6.1 适用情况

- **🔸 数据均匀分布**：数据在输入范围内均匀分布
- **🔸 浮点数排序**：特别适合[0,1)区间的浮点数
- **🔸 外部排序**：数据量大，需要分块处理
- **🔸 并行处理**：可以利用多核处理器并行排序
- **🔸 稳定性要求**：需要保持相等元素的相对位置

### 6.2 不适用情况

- **🔸 数据分布不均**：数据严重倾斜到某些区间
- **🔸 整数排序**：通常计数排序或基数排序更适合
- **🔸 内存受限**：无法提供足够的桶存储空间
- **🔸 小数据量**：数据量很小时，简单排序更高效

### 6.3 典型应用示例


```python
# 成绩排序（浮点数成绩）
def sort_grades(grades):
    """
    对浮点数成绩进行排序（假设范围0-100）
    """
    if not grades:
        return grades
    
    # 标准化到[0,1)区间
    normalized = [(grade / 100.0) for grade in grades]
    
    # 使用桶排序
    sorted_normalized = bucket_sort_unit_interval(normalized)
    
    # 转换回原始范围
    return [grade * 100.0 for grade in sorted_normalized]

# 时间戳排序
def sort_timestamps(timestamps):
    """
    对时间戳进行排序
    """
    if not timestamps:
        return timestamps
    
    min_time = min(timestamps)
    max_time = max(timestamps)
    
    # 归一化处理
    if min_time == max_time:
        return timestamps
    
    normalized = [(ts - min_time) / (max_time - min_time) for ts in timestamps]
    sorted_normalized = bucket_sort_unit_interval(normalized)
    
    # 恢复原始值
    return [norm * (max_time - min_time) + min_time for norm in sorted_normalized]

# 外部排序应用
def external_bucket_sort(large_file_path, output_path, memory_limit):
    """
    大文件的桶排序（简化示例）
    """
    import tempfile
    import os
    
    # 第一阶段：分桶写入临时文件
    bucket_files = []
    bucket_count = 10  # 根据内存限制确定
    
    # 读取数据并分桶
    temp_files = [tempfile.NamedTemporaryFile(mode='w', delete=False) 
                  for _ in range(bucket_count)]
    
    with open(large_file_path, 'r') as f:
        for line in f:
            value = float(line.strip())
            bucket_index = min(int(value * bucket_count), bucket_count - 1)
            temp_files[bucket_index].write(f"{value}\n")
    
    # 关闭临时文件
    for tf in temp_files:
        tf.close()
        bucket_files.append(tf.name)
    
    # 第二阶段：排序每个桶并合并
    with open(output_path, 'w') as output:
        for bucket_file in bucket_files:
            # 读取桶数据
            bucket_data = []
            with open(bucket_file, 'r') as bf:
                bucket_data = [float(line.strip()) for line in bf]
            
            # 排序桶数据
            bucket_data.sort()
            
            # 写入结果
            for value in bucket_data:
                output.write(f"{value}\n")
            
            # 清理临时文件
            os.unlink(bucket_file)
```

---

## 7. ⚖️ 对比分析


### 7.1 与其他排序算法对比


| 算法 | 时间复杂度（平均） | 空间复杂度 | 稳定性 | 数据要求 |
|------|------------------|------------|---------|----------|
| 桶排序 | O(n + k) | O(n + k) | <span style="color:#22c55e">✅ 可稳定</span> | <span style="color:#f59e0b">⚠️ 均匀分布</span> |
| 快速排序 | O(n log n) | O(log n) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 通用</span> |
| 归并排序 | O(n log n) | O(n) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#22c55e">✅ 通用</span> |
| 计数排序 | O(n + k) | O(n + k) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#f59e0b">⚠️ 小范围整数</span> |
| 基数排序 | O(d(n + k)) | O(n + k) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#f59e0b">⚠️ 固定位数</span> |

### 7.2 优缺点总结


##### 7.2.1 主要优点

- **平均线性时间**：在数据均匀分布时达到O(n)时间复杂度
- **稳定性可控**：可以实现为稳定排序
- **并行友好**：不同桶可以并行处理
- **适合外部排序**：可处理超大数据集
- **浮点数友好**：特别适合浮点数排序

##### 7.2.2 主要缺点

- **分布敏感**：性能高度依赖于数据分布
- **空间开销**：需要额外的桶存储空间
- **最坏情况差**：数据分布不均时性能退化
- **实现复杂**：需要选择合适的桶数量和映射函数

### 7.3 选择建议


**推荐使用桶排序的情况**：
- ✅ 数据均匀分布
- ✅ 浮点数排序
- ✅ 需要并行处理
- ✅ 外部排序需求
- ✅ 有足够内存空间

**不推荐使用桶排序的情况**：
- ❌ 数据分布严重不均
- ❌ 小数据量排序
- ❌ 内存严格受限
- ❌ 整数排序（计数排序更适合）

---

## 8. 📋 总结


### 8.1 核心要点

1. **🔸 分布排序**：基于数据分布进行排序的策略
2. **🔸 分治思想**：将大问题分解为多个小问题
3. **🔸 性能依赖**：高度依赖于数据的分布均匀性
4. **🔸 并行潜力**：天然支持并行处理
5. **🔸 实用价值**：在特定场景下提供优秀性能

### 8.2 关键技术点

- **桶数量选择**：影响算法性能的关键因素
- **映射函数设计**：决定数据分布的均匀性
- **桶内排序算法**：影响整体稳定性和性能
- **内存管理**：合理控制桶的存储开销
- **边界处理**：正确处理最大值等边界情况

### 8.3 适用原则


##### 8.3.1 何时选择桶排序

- ✅ 数据在已知范围内均匀分布
- ✅ 需要排序浮点数
- ✅ 可以利用并行处理
- ✅ 内存充足
- ✅ 需要外部排序

##### 8.3.2 何时避免桶排序

- ❌ 数据分布高度不均
- ❌ 数据量很小
- ❌ 内存受限
- ❌ 需要通用排序解决方案

### 8.4 学习价值

- **分布思想**：理解基于分布的排序策略
- **分治应用**：分治思想在排序中的具体应用
- **性能分析**：理解算法性能与数据特征的关系
- **实际应用**：了解在大数据处理中的价值

### 8.5 实践建议

- **数据分析**：排序前分析数据的分布特征
- **桶数优化**：根据数据量和分布选择合适的桶数
- **算法组合**：与其他排序算法结合使用
- **并行利用**：在多核环境下发挥并行优势

