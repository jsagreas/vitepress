---
title: 6、快速排序
---
## 📚 目录

1. [算法概述](#1-算法概述)
2. [基本思想](#2-基本思想)
3. [算法原理](#3-算法原理)
4. [实现方法](#4-实现方法)
5. [算法分析](#5-算法分析)
6. [优化策略](#6-优化策略)
7. [应用场景](#7-应用场景)
8. [对比分析](#8-对比分析)
9. [总结](#9-总结)

---

## 1. 📖 算法概述


### 1.1 定义

快速排序（Quick Sort）是一种基于分治思想的高效排序算法。它通过选择一个"基准"元素，将数组分为两部分：小于基准的元素和大于基准的元素，然后递归地对这两部分进行排序。

### 1.2 历史背景

- **发明者**：Tony Hoare（1960年）
- **意义**：平均情况下最快的通用排序算法之一
- **地位**：广泛应用于各种编程语言的标准库中

### 1.3 核心特征

- **🔹 不稳定排序**：相等元素的相对位置可能改变
- **🔹 原地排序**：通常只需要O(log n)的额外空间
- **🔹 分治算法**：采用分而治之的策略
- **🔹 平均高效**：平均时间复杂度为O(n log n)

### 1.4 算法分类

- 比较排序算法
- 原地排序算法
- 分治算法
- 不稳定排序算法

---

## 2. 💡 基本思想


### 2.1 核心思想

快速排序基于分治策略，包含三个步骤：
1. **选择基准（Pivot）**：从数组中选择一个元素作为基准
2. **分区（Partition）**：重新排列数组，使所有小于基准的元素在基准前面，所有大于基准的元素在基准后面
3. **递归排序**：递归地对基准前后的两个子数组进行快速排序

### 2.2 为什么有效？

- **分而治之**：将大问题分解为小问题
- **原地操作**：主要在原数组上进行操作，空间效率高
- **平均性能优秀**：在随机数据上表现很好
- **实现简单**：算法逻辑相对简单易懂

### 2.3 排序过程示例

以数组 [3, 6, 8, 10, 1, 2, 1] 为例，选择最后一个元素作为基准：

```
原始数组: [3, 6, 8, 10, 1, 2, 1]  pivot = 1

第一次分区:
比较过程: 3>1, 6>1, 8>1, 10>1, 1=1, 2>1, 1=1
分区结果: [1, 1, 8, 10, 6, 2, 3]
                ↑
              pivot位置

递归处理:
左子数组: [1] (已有序)
右子数组: [8, 10, 6, 2, 3]  pivot = 3

右子数组分区:
比较过程: 8>3, 10>3, 6>3, 2<3, 3=3
分区结果: [2, 10, 6, 8, 3]
                      ↑
                   pivot位置

继续递归...
最终结果: [1, 1, 2, 3, 6, 8, 10]
```

---

## 3. ⚙️ 算法原理


### 3.1 工作机制

1. **基准选择**：选择数组中的一个元素作为基准值
2. **分区操作**：将数组重新排列，使基准值处于正确位置
3. **递归处理**：对基准值左右两侧的子数组递归进行快速排序
4. **合并结果**：由于是原地排序，不需要合并操作

### 3.2 关键概念


##### 3.2.1 基准（Pivot）

- **定义**：用于分区的参考元素
- **选择策略**：第一个元素、最后一个元素、中间元素、随机元素
- **影响**：基准选择直接影响算法性能

##### 3.2.2 分区（Partition）

- **目标**：将数组分为三部分：小于基准、等于基准、大于基准
- **方法**：双指针法、Lomuto分区法、Hoare分区法
- **结果**：基准元素位于其最终排序位置

### 3.3 分区操作详解

分区是快速排序的核心操作：

```
Lomuto分区法示例:
数组: [3, 6, 8, 10, 1, 2, 1]  pivot = 1 (最后一个元素)

i = -1  (小于pivot的元素的边界)
j = 0   (当前检查的元素)

j=0: arr[0]=3 > 1, i不变, j++
j=1: arr[1]=6 > 1, i不变, j++  
j=2: arr[2]=8 > 1, i不变, j++
j=3: arr[3]=10 > 1, i不变, j++
j=4: arr[4]=1 ≤ 1, i++, swap(arr[0], arr[4])
     数组变为: [1, 6, 8, 10, 3, 2, 1]
j=5: arr[5]=2 > 1, i不变, j++

最后: swap(arr[i+1], arr[6])
     数组变为: [1, 1, 8, 10, 3, 2, 6]
     返回基准位置: i+1 = 1
```

---

## 4. 🔨 实现方法


### 4.1 基础实现（Python）


```python
def quick_sort(arr):
    """
    快速排序主函数
    """
    if len(arr) <= 1:
        return arr
    
    def quick_sort_helper(arr, low, high):
        if low < high:
            # 分区操作，获取基准位置
            pivot_index = partition(arr, low, high)
            
            # 递归排序基准左侧
            quick_sort_helper(arr, low, pivot_index - 1)
            # 递归排序基准右侧
            quick_sort_helper(arr, pivot_index + 1, high)
    
    def partition(arr, low, high):
        """
        Lomuto分区法
        """
        # 选择最后一个元素作为基准
        pivot = arr[high]
        i = low - 1  # 小于基准元素的边界
        
        for j in range(low, high):
            # 如果当前元素小于或等于基准
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
        
        # 将基准放到正确位置
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1
    
    arr_copy = arr.copy()
    quick_sort_helper(arr_copy, 0, len(arr_copy) - 1)
    return arr_copy
```

### 4.2 Hoare分区实现


```python
def quick_sort_hoare(arr):
    """
    使用Hoare分区的快速排序
    """
    def quick_sort_helper(arr, low, high):
        if low < high:
            pivot_index = hoare_partition(arr, low, high)
            quick_sort_helper(arr, low, pivot_index)
            quick_sort_helper(arr, pivot_index + 1, high)
    
    def hoare_partition(arr, low, high):
        """
        Hoare分区法
        """
        pivot = arr[low]  # 选择第一个元素作为基准
        i = low - 1
        j = high + 1
        
        while True:
            # 从左边找到第一个大于等于基准的元素
            i += 1
            while arr[i] < pivot:
                i += 1
            
            # 从右边找到第一个小于等于基准的元素
            j -= 1
            while arr[j] > pivot:
                j -= 1
            
            # 如果指针相遇，分区完成
            if i >= j:
                return j
            
            # 交换元素
            arr[i], arr[j] = arr[j], arr[i]
    
    arr_copy = arr.copy()
    quick_sort_helper(arr_copy, 0, len(arr_copy) - 1)
    return arr_copy
```

### 4.3 Java 实现


```java
public class QuickSort {
    public static void quickSort(int[] arr) {
        if (arr.length <= 1) return;
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];  // 选择最后一个元素作为基准
        int i = low - 1;        // 小于基准元素的边界
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.4 C++ 实现


```cpp
#include <vector>
using namespace std;

class QuickSort {
public:
    static void quickSort(vector<int>& arr) {
        if (arr.size() <= 1) return;
        quickSort(arr, 0, arr.size() - 1);
    }
    
private:
    static void quickSort(vector<int>& arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    static int partition(vector<int>& arr, int low, int high) {
        int pivot = arr[high];  // 选择最后一个元素作为基准
        int i = low - 1;        // 小于基准元素的边界
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        
        swap(arr[i + 1], arr[high]);
        return i + 1;
    }
};
```

---

## 5. 📊 算法分析


### 5.1 时间复杂度


##### 5.1.1 各种情况下的复杂度

- **最佳情况**：`O(n log n)` <span style="color:#22c55e">✅ 优秀</span>
- **平均情况**：`O(n log n)` <span style="color:#22c55e">✅ 优秀</span>
- **最坏情况**：`O(n²)` <span style="color:#ef4444">❌ 较差</span>

##### 5.1.2 复杂度分析


**最佳/平均情况**：
- **递归层数**：log n层（每次大约平分数组）
- **每层工作量**：O(n)（分区操作）
- **总时间复杂度**：O(n) × O(log n) = O(n log n)

**最坏情况**：
- **发生条件**：每次选择的基准都是最小或最大元素
- **递归层数**：n层（每次只减少一个元素）
- **总时间复杂度**：O(n²)

### 5.2 空间复杂度

- **平均情况**：`O(log n)` <span style="color:#22c55e">✅ 优秀</span>
- **最坏情况**：`O(n)` <span style="color:#f59e0b">⚠️ 较差</span>
- **原因**：递归调用栈的深度

### 5.3 稳定性分析

- **不稳定排序**：<span style="color:#ef4444">❌ 不稳定</span>
- **原因**：分区过程中可能改变相等元素的相对位置

### 5.4 性能特点

- **🔸 平均性能优秀**：在随机数据上表现很好
- **🔸 原地排序**：空间效率高
- **🔸 实现简单**：算法逻辑相对简单
- **🔸 缓存友好**：具有良好的局部性

---

## 6. 🚀 优化策略


### 6.1 基准选择优化


##### 6.1.1 三数取中法

```python
def median_of_three(arr, low, high):
    """
    三数取中法选择基准
    """
    mid = (low + high) // 2
    
    # 将三个数排序，中位数作为基准
    if arr[mid] < arr[low]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[high] < arr[low]:
        arr[low], arr[high] = arr[high], arr[low]
    if arr[high] < arr[mid]:
        arr[mid], arr[high] = arr[high], arr[mid]
    
    # 将中位数放到倒数第二个位置
    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]
    return arr[high - 1]
```

##### 6.1.2 随机基准

```python
import random

def random_partition(arr, low, high):
    """
    随机选择基准的分区
    """
    # 随机选择基准
    random_index = random.randint(low, high)
    arr[random_index], arr[high] = arr[high], arr[random_index]
    
    # 执行标准分区
    return partition(arr, low, high)
```

### 6.2 小数组优化

对小数组使用插入排序：
```python
def quick_sort_optimized(arr):
    """
    优化的快速排序
    """
    THRESHOLD = 10
    
    def quick_sort_helper(arr, low, high):
        if high - low + 1 <= THRESHOLD:
            insertion_sort(arr, low, high)
        elif low < high:
            pivot_index = median_partition(arr, low, high)
            quick_sort_helper(arr, low, pivot_index - 1)
            quick_sort_helper(arr, pivot_index + 1, high)
    
    def insertion_sort(arr, low, high):
        for i in range(low + 1, high + 1):
            key = arr[i]
            j = i - 1
            while j >= low and arr[j] > key:
                arr[j + 1] = arr[j]
                j -= 1
            arr[j + 1] = key
    
    arr_copy = arr.copy()
    quick_sort_helper(arr_copy, 0, len(arr_copy) - 1)
    return arr_copy
```

### 6.3 三路快排

处理大量重复元素的情况：
```python
def quick_sort_3way(arr):
    """
    三路快速排序（处理重复元素）
    """
    def quick_sort_helper(arr, low, high):
        if low >= high:
            return
        
        lt = low      # 小于基准的边界
        gt = high     # 大于基准的边界
        i = low + 1   # 当前检查位置
        pivot = arr[low]
        
        while i <= gt:
            if arr[i] < pivot:
                arr[lt], arr[i] = arr[i], arr[lt]
                lt += 1
                i += 1
            elif arr[i] > pivot:
                arr[i], arr[gt] = arr[gt], arr[i]
                gt -= 1
                # 注意：i不自增，因为交换来的元素还未检查
            else:
                i += 1
        
        # 递归处理小于和大于基准的部分
        quick_sort_helper(arr, low, lt - 1)
        quick_sort_helper(arr, gt + 1, high)
    
    arr_copy = arr.copy()
    quick_sort_helper(arr_copy, 0, len(arr_copy) - 1)
    return arr_copy
```

---

## 7. 🎯 应用场景


### 7.1 适用情况

- **🔸 一般排序需求**：大多数情况下的首选排序算法
- **🔸 内存受限**：需要原地排序的场景
- **🔸 平均性能要求高**：对平均情况性能要求高
- **🔸 系统排序**：各种编程语言的标准库实现
- **🔸 不要求稳定性**：不需要保持相等元素相对位置

### 7.2 不适用情况

- **🔸 稳定性要求**：需要保持相等元素相对位置
- **🔸 最坏情况敏感**：对最坏情况性能要求严格
- **🔸 大量重复元素**：包含很多相等元素的数组

### 7.3 典型应用


```python
# 通用数组排序
def sort_array(arr):
    """通用数组排序"""
    return quick_sort_optimized(arr)

# 查找第K大元素（QuickSelect）
def find_kth_largest(arr, k):
    """
    查找第K大元素
    """
    def quickselect(arr, low, high, k):
        if low == high:
            return arr[low]
        
        pivot_index = partition(arr, low, high)
        
        if k == pivot_index:
            return arr[k]
        elif k < pivot_index:
            return quickselect(arr, low, pivot_index - 1, k)
        else:
            return quickselect(arr, pivot_index + 1, high, k)
    
    # 第K大元素是第(n-k)小元素
    target_index = len(arr) - k
    arr_copy = arr.copy()
    return quickselect(arr_copy, 0, len(arr_copy) - 1, target_index)

# 对象排序
def sort_students(students):
    """按成绩排序学生"""
    def compare_students(s1, s2):
        return s1.score - s2.score
    
    # 使用自定义比较函数的快速排序
    return quick_sort_with_comparator(students, compare_students)
```

---

## 8. ⚖️ 对比分析


### 8.1 与其他排序算法对比


| 算法 | 时间复杂度（平均） | 空间复杂度 | 稳定性 | 原地排序 |
|------|------------------|------------|---------|----------|
| 快速排序 | O(n log n) | O(log n) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 归并排序 | O(n log n) | O(n) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#ef4444">❌ 否</span> |
| 堆排序 | O(n log n) | O(1) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 希尔排序 | O(n^1.3) | O(1) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 插入排序 | O(n²) | O(1) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#22c55e">✅ 是</span> |

### 8.2 优缺点总结


##### 8.2.1 主要优点

- **平均性能优秀**：平均时间复杂度O(n log n)
- **空间效率高**：原地排序，只需O(log n)额外空间
- **实现简单**：算法逻辑相对简单易懂
- **缓存友好**：具有良好的空间局部性
- **实用性强**：广泛应用于各种系统中

##### 8.2.2 主要缺点

- **不稳定**：不能保持相等元素的相对位置
- **最坏情况差**：最坏情况时间复杂度为O(n²)
- **基准敏感**：性能高度依赖基准选择
- **递归深度**：可能导致栈溢出

### 8.3 选择建议


**推荐使用快速排序的情况**：
- ✅ 一般排序需求
- ✅ 内存空间受限
- ✅ 不要求稳定性
- ✅ 平均性能要求高
- ✅ 数据相对随机

**不推荐使用快速排序的情况**：
- ❌ 需要稳定排序
- ❌ 对最坏情况敏感
- ❌ 数据已经有序或接近有序
- ❌ 包含大量重复元素

---

## 9. 📋 总结


### 9.1 核心要点

1. **🔸 分治思想**：选择基准，分区，递归排序
2. **🔸 平均高效**：平均时间复杂度O(n log n)
3. **🔸 原地排序**：空间效率高，适合内存受限场景
4. **🔸 不稳定性**：相等元素的相对位置可能改变
5. **🔸 实用价值**：广泛应用于各种编程语言标准库

### 9.2 关键技术点

- **分区操作**：快速排序的核心，决定算法效率
- **基准选择**：影响算法性能的关键因素
- **优化策略**：三数取中、随机基准、小数组优化等
- **变种算法**：三路快排、快速选择等

### 9.3 学习重点

- **理解分治思想**：掌握分区、递归的核心思路
- **掌握分区操作**：理解Lomuto和Hoare两种分区方法
- **分析复杂度**：理解为什么平均O(n log n)，最坏O(n²)
- **优化方法**：了解各种优化策略及其应用场景
- **实际应用**：掌握快速排序的变种和扩展应用

### 9.4 实践建议

- **选择合适的基准选择策略**：根据数据特点选择
- **考虑优化方案**：小数组优化、三路快排等
- **注意最坏情况**：避免在有序数据上使用基础版本
- **结合其他算法**：在实际应用中与其他算法结合使用

