---
title: 2、选择排序
---
# 选择排序（Selection Sort）完整笔记

### 📚 目录
1. [概述](#概述)
2. [核心思想](#核心思想)
3. [算法原理](#算法原理)
4. [实现方式](#实现方式)
5. [复杂度分析](#复杂度分析)
6. [优缺点分析](#优缺点分析)
7. [适用场景](#适用场景)
8. [变种算法](#变种算法)
9. [总结](#总结)

---

### 1. 📝 概述

**选择排序**是一种简单直观的排序算法，属于**比较类排序**算法。它的工作原理是每次从未排序的元素中选择最小（或最大）的元素，放到已排序序列的末尾。

#### 基本特征
- **算法类型**：比较排序
- **稳定性**：不稳定
- **原地排序**：是
- **时间复杂度**：O(n²)
- **空间复杂度**：O(1)

---

### 2. 💡 核心思想

选择排序的核心思想可以概括为：
> **"选择最值，依次放置"**

#### 工作流程
1. **选择阶段**：在未排序区间找到最小值
2. **交换阶段**：将最小值与未排序区间的第一个元素交换
3. **缩小区间**：已排序区间扩大1位，未排序区间缩小1位
4. **重复过程**：直到所有元素都被排序

---

### 3. 🔧 算法原理

#### 详细步骤

对于数组 `[64, 34, 25, 12, 22, 11, 90]`：

###### 第一轮排序
```
[64, 34, 25, 12, 22, 11, 90]
 ↑                   ↑
 待交换位置          最小值(11)
```
交换后：`[11, 34, 25, 12, 22, 64, 90]`

###### 第二轮排序
```
[11, 34, 25, 12, 22, 64, 90]
     ↑       ↑
     待交换位置  最小值(12)
```
交换后：`[11, 12, 25, 34, 22, 64, 90]`

###### 继续执行...
- 第三轮：`[11, 12, 22, 34, 25, 64, 90]`
- 第四轮：`[11, 12, 22, 25, 34, 64, 90]`
- 第五轮：`[11, 12, 22, 25, 34, 64, 90]`
- 第六轮：`[11, 12, 22, 25, 34, 64, 90]`

#### 算法不变式
- **已排序区间**：`[0, i)` 内的元素已按升序排列
- **未排序区间**：`[i, n)` 内包含剩余待排序元素
- **最小值保证**：已排序区间的任意元素 ≤ 未排序区间的任意元素

---

### 4. 💻 实现方式

#### Python 实现

```python
def selection_sort(arr):
    """
    选择排序算法实现
    
    Args:
        arr: 待排序的列表
    
    Returns:
        排序后的列表
    """
    n = len(arr)
    
    # 外层循环：控制已排序区间的边界
    for i in range(n):
        # 假设当前位置就是最小值的位置
        min_idx = i
        
        # 内层循环：在未排序区间找最小值
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 将找到的最小值与当前位置交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# 使用示例
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = selection_sort(numbers.copy())
print(f"原数组: {numbers}")
print(f"排序后: {sorted_numbers}")
```

#### Java 实现

```java
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            // 寻找最小元素的索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 交换元素
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
}
```

#### C++ 实现

```cpp
#include <vector>
#include <algorithm>

void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        
        // 寻找最小元素
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // 交换元素
        std::swap(arr[i], arr[minIndex]);
    }
}
```

---

### 5. 📊 复杂度分析

#### 时间复杂度

| 情况 | 时间复杂度 | 说明 |
|------|-----------|------|
| 最好情况 | O(n²) | 即使数组已排序，仍需要进行比较 |
| 平均情况 | O(n²) | 平均需要进行 n²/2 次比较 |
| 最坏情况 | O(n²) | 逆序排列时的情况 |

###### 详细分析
- **比较次数**：`(n-1) + (n-2) + ... + 1 = n(n-1)/2`
- **交换次数**：最多 `n-1` 次（每轮最多1次交换）
- **总时间复杂度**：O(n²)

#### 空间复杂度

- **额外空间**：O(1)
- **原地排序**：只需要常数级别的额外空间用于交换

---

### 6. ⚖️ 优缺点分析

#### ✅ 优点

1. **简单易懂**
   - 算法逻辑直观，容易理解和实现
   - 代码简洁，不容易出错

2. **原地排序**
   - 只需要 O(1) 的额外空间
   - 适合内存有限的环境

3. **交换次数少**
   - 每轮最多只交换一次
   - 适合交换代价昂贵的场景

4. **数据移动最少**
   - 相比其他 O(n²) 算法，数据移动次数更少

#### ❌ 缺点

1. **时间复杂度高**
   - 无论什么情况都是 O(n²)
   - 不适合处理大规模数据

2. **不稳定排序**
   - 相同元素的相对位置可能改变
   - 不适合需要保持稳定性的场景

3. **不具备自适应性**
   - 对于部分有序的数组没有性能优势
   - 无法利用数据的有序性

---

### 7. 🎯 适用场景

#### 适合使用的情况

1. **数据规模小**
   - 元素个数在几十个以内
   - 对性能要求不高的小规模排序

2. **内存严格限制**
   - 嵌入式系统或内存受限环境
   - 需要原地排序的场景

3. **交换代价高**
   - 元素交换操作代价昂贵
   - 需要最小化交换次数

4. **教学演示**
   - 算法教学中的入门排序算法
   - 帮助理解排序的基本概念

#### 不适合使用的情况

1. **大规模数据**
   - 数据量超过1000个元素
   - 对时间性能有要求的场景

2. **需要稳定排序**
   - 需要保持相同元素的相对位置
   - 多关键字排序场景

3. **实时性要求高**
   - 需要快速响应的系统
   - 对时间复杂度敏感的应用

---

### 8. ⚡ 变种算法

#### 1. 双向选择排序（鸡尾酒选择排序）

```python
def bidirectional_selection_sort(arr):
    """双向选择排序：同时找最小值和最大值"""
    n = len(arr)
    
    for i in range(n // 2):
        min_idx = i
        max_idx = i
        
        # 同时寻找最小值和最大值
        for j in range(i, n - i):
            if arr[j] < arr[min_idx]:
                min_idx = j
            if arr[j] > arr[max_idx]:
                max_idx = j
        
        # 交换最小值到前面
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        
        # 如果最大值在位置i，更新其位置
        if max_idx == i:
            max_idx = min_idx
        
        # 交换最大值到后面
        arr[n - 1 - i], arr[max_idx] = arr[max_idx], arr[n - 1 - i]
```

#### 2. 堆选择排序

```python
def heap_selection_sort(arr):
    """使用堆优化的选择排序"""
    import heapq
    
    # 建立最小堆
    heap = arr.copy()
    heapq.heapify(heap)
    
    # 依次取出最小元素
    sorted_arr = []
    while heap:
        sorted_arr.append(heapq.heappop(heap))
    
    return sorted_arr
```

#### 3. 递归选择排序

```python
def recursive_selection_sort(arr, start=0):
    """递归实现的选择排序"""
    if start >= len(arr) - 1:
        return
    
    # 找到最小元素的索引
    min_idx = start
    for i in range(start + 1, len(arr)):
        if arr[i] < arr[min_idx]:
            min_idx = i
    
    # 交换元素
    arr[start], arr[min_idx] = arr[min_idx], arr[start]
    
    # 递归处理剩余部分
    recursive_selection_sort(arr, start + 1)
```

---

### 9. 📋 总结

- 核心思想：每轮找最小，放前面
- 特征：简单，交换少，但比较多；不稳定
- 掌握要点：
  - 理解排序过程
  - 能手写出选择排序代码
  - 理解其与其他算法的对比


#### 核心要点
- **算法思想**：反复选择最小值并放到正确位置
- **时间复杂度**：O(n²)，所有情况下都相同
- **空间复杂度**：O(1)，原地排序算法
- **稳定性**：不稳定排序算法

---

