---
title: 5、归并排序
---
## 📚 目录

1. [算法概述](#1-算法概述)
2. [基本思想](#2-基本思想)
3. [算法原理](#3-算法原理)
4. [实现方法](#4-实现方法)
5. [算法分析](#5-算法分析)
6. [应用场景](#6-应用场景)
7. [对比分析](#7-对比分析)
8. [总结](#8-总结)

---

## 1. 📖 算法概述


### 1.1 定义

归并排序（Merge Sort）是一种基于分治思想的稳定排序算法。它将数组不断分解为更小的子数组，直到每个子数组只有一个元素，然后逐步合并这些子数组，最终得到完全有序的数组。

### 1.2 历史背景

- **发明者**：John von Neumann（1945年）
- **意义**：经典的分治算法，第一个稳定的O(n log n)排序算法
- **地位**：在需要稳定排序的场景中广泛应用

### 1.3 核心特征

- **🔹 稳定排序**：相等元素的相对位置保持不变
- **🔹 分治算法**：采用分而治之的策略
- **🔹 时间复杂度稳定**：任何情况下都是O(n log n)
- **🔹 空间开销**：需要O(n)的额外存储空间

### 1.4 算法分类

- 比较排序算法
- 稳定排序算法
- 分治算法
- 外部排序算法

---

## 2. 💡 基本思想


### 2.1 核心思想

归并排序基于分治策略，包含三个步骤：
1. **分解（Divide）**：将数组分成两个大小相等的子数组
2. **解决（Conquer）**：递归地对两个子数组进行排序
3. **合并（Combine）**：将两个已排序的子数组合并成一个有序数组

### 2.2 为什么有效？

- **问题简化**：将大问题分解为小问题
- **递归结构**：子问题与原问题结构相同
- **线性合并**：两个有序数组的合并是O(n)操作
- **稳定性保证**：合并过程保持元素的相对顺序

### 2.3 排序过程示例

以数组 [8, 4, 2, 1, 3, 5, 7, 6] 为例：

```
原始数组: [8, 4, 2, 1, 3, 5, 7, 6]

分解阶段:
                [8, 4, 2, 1, 3, 5, 7, 6]
                        ↓
            [8, 4, 2, 1]        [3, 5, 7, 6]
                ↓                    ↓
        [8, 4]    [2, 1]    [3, 5]    [7, 6]
          ↓        ↓          ↓        ↓
       [8] [4]  [2] [1]   [3] [5]   [7] [6]

合并阶段:
       [8] [4]  [2] [1]   [3] [5]   [7] [6]
          ↓        ↓          ↓        ↓
        [4, 8]   [1, 2]   [3, 5]   [6, 7]
            ↓               ↓
      [1, 2, 4, 8]    [3, 5, 6, 7]
            ↓
    [1, 2, 3, 4, 5, 6, 7, 8]
```

---

## 3. ⚙️ 算法原理


### 3.1 工作机制

1. **递归分解**：不断将数组对半分割，直到每个子数组只有一个元素
2. **递归合并**：从最小的子数组开始，两两合并成更大的有序数组
3. **线性合并**：合并两个有序数组的时间复杂度为O(n)
4. **逐层合并**：从叶子节点向根节点逐层合并

### 3.2 关键概念


##### 3.2.1 分治策略

- **分解**：将原问题分成若干个规模较小的相同子问题
- **解决**：递归地解决子问题
- **合并**：将子问题的解合并为原问题的解

##### 3.2.2 合并操作

- **输入**：两个已排序的数组
- **输出**：一个合并后的有序数组
- **方法**：使用双指针技术，比较两个数组的元素

### 3.3 算法不变式

- 在递归的每一层，所有子数组都是有序的
- 合并操作保持数组的有序性
- 相等元素的相对位置在合并过程中保持不变

---

## 4. 🔨 实现方法


### 4.1 基础实现（Python）


```python
def merge_sort(arr):
    """
    归并排序主函数
    """
    if len(arr) <= 1:
        return arr
    
    # 分解：找到中点，分成两半
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    # 递归排序两半
    left = merge_sort(left)
    right = merge_sort(right)
    
    # 合并两个有序数组
    return merge(left, right)

def merge(left, right):
    """
    合并两个有序数组
    """
    result = []
    i = j = 0
    
    # 比较两个数组的元素，将较小的放入结果数组
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:  # 使用<=保证稳定性
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 将剩余元素添加到结果数组
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```

### 4.2 优化实现（原地归并）


```python
def merge_sort_inplace(arr):
    """
    使用辅助数组的归并排序，减少内存分配
    """
    def merge_sort_helper(arr, temp, left, right):
        if left < right:
            mid = (left + right) // 2
            
            # 递归排序左右两半
            merge_sort_helper(arr, temp, left, mid)
            merge_sort_helper(arr, temp, mid + 1, right)
            
            # 合并两个有序部分
            merge_arrays(arr, temp, left, mid, right)
    
    def merge_arrays(arr, temp, left, mid, right):
        # 复制到临时数组
        for i in range(left, right + 1):
            temp[i] = arr[i]
        
        i = left      # 左半部分的起始位置
        j = mid + 1   # 右半部分的起始位置
        k = left      # 合并后数组的起始位置
        
        # 合并两个有序部分
        while i <= mid and j <= right:
            if temp[i] <= temp[j]:
                arr[k] = temp[i]
                i += 1
            else:
                arr[k] = temp[j]
                j += 1
            k += 1
        
        # 复制剩余元素
        while i <= mid:
            arr[k] = temp[i]
            i += 1
            k += 1
    
    temp = [0] * len(arr)
    merge_sort_helper(arr, temp, 0, len(arr) - 1)
    return arr
```

### 4.3 Java 实现


```java
public class MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr.length <= 1) return;
        
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private static void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSort(arr, temp, left, mid);
            mergeSort(arr, temp, mid + 1, right);
            merge(arr, temp, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // 复制到临时数组
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        // 合并两个有序部分
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) arr[k++] = temp[i++];
        while (j <= right) arr[k++] = temp[j++];
    }
}
```

### 4.4 C++ 实现


```cpp
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> leftArr(arr.begin() + left, arr.begin() + mid + 1);
    vector<int> rightArr(arr.begin() + mid + 1, arr.begin() + right + 1);
    
    int i = 0, j = 0, k = left;
    
    while (i < leftArr.size() && j < rightArr.size()) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }
    
    while (i < leftArr.size()) arr[k++] = leftArr[i++];
    while (j < rightArr.size()) arr[k++] = rightArr[j++];
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void mergeSort(vector<int>& arr) {
    mergeSort(arr, 0, arr.size() - 1);
}
```

---

## 5. 📊 算法分析


### 5.1 时间复杂度


##### 5.1.1 各种情况下的复杂度

- **最佳情况**：`O(n log n)` <span style="color:#22c55e">✅ 稳定</span>
- **平均情况**：`O(n log n)` <span style="color:#22c55e">✅ 稳定</span>
- **最坏情况**：`O(n log n)` <span style="color:#22c55e">✅ 稳定</span>

##### 5.1.2 复杂度分析

- **递归层数**：log n层（每次将问题规模减半）
- **每层工作量**：O(n)（合并操作）
- **总时间复杂度**：O(n) × O(log n) = O(n log n)

##### 5.1.3 递归关系式

```
T(n) = 2T(n/2) + O(n)
解得：T(n) = O(n log n)
```

### 5.2 空间复杂度

- **辅助空间**：`O(n)` <span style="color:#f59e0b">⚠️ 需要额外空间</span>
- **递归栈**：`O(log n)`
- **总空间复杂度**：`O(n)`

### 5.3 稳定性分析

- **稳定排序**：<span style="color:#22c55e">✅ 稳定</span>
- **保证方法**：合并时遇到相等元素，优先选择左数组元素

### 5.4 其他特性

- **🔸 时间可预测**：不受输入数据分布影响
- **🔸 适合外部排序**：可处理大文件
- **🔸 天然并行**：左右子数组可并行处理
- **🔸 适合链表**：不需要随机访问

---

## 6. 🎯 应用场景


### 6.1 适用情况

- **🔸 稳定性要求**：需要保持相等元素的相对顺序
- **🔸 大规模数据**：处理海量数据排序
- **🔸 外部排序**：数据量超过内存容量
- **🔸 链表排序**：天然适合链表结构
- **🔸 并行处理**：可以利用多核处理器
- **🔸 可预测性能**：需要稳定的时间复杂度

### 6.2 不适用情况

- **🔸 内存严格受限**：无法提供O(n)额外空间
- **🔸 小规模数据**：简单排序算法可能更高效
- **🔸 原地排序需求**：要求严格的原地排序

### 6.3 典型应用


```python
# 学生成绩排序（保持稳定性）
def sort_students(students):
    """按成绩排序，相同成绩保持原有顺序"""
    return merge_sort(students, key=lambda x: x.score)

# 大文件排序
def sort_large_file(input_file, output_file):
    """处理大文件的外部排序"""
    # 使用归并排序的思想进行外部排序
    pass

# 链表排序
def sort_linked_list(head):
    """链表归并排序"""
    if not head or not head.next:
        return head
    
    # 找中点，分割链表
    mid = get_middle(head)
    right = mid.next
    mid.next = None
    
    # 递归排序
    left = sort_linked_list(head)
    right = sort_linked_list(right)
    
    # 合并
    return merge_lists(left, right)
```

---

## 7. ⚖️ 对比分析


### 7.1 与其他排序算法对比


| 算法 | 时间复杂度（平均） | 空间复杂度 | 稳定性 | 原地排序 |
|------|------------------|------------|---------|----------|
| 归并排序 | O(n log n) | O(n) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#ef4444">❌ 否</span> |
| 快速排序 | O(n log n) | O(log n) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 堆排序 | O(n log n) | O(1) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 希尔排序 | O(n^1.3) | O(1) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 是</span> |
| 插入排序 | O(n²) | O(1) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#22c55e">✅ 是</span> |

### 7.2 优缺点总结


##### 7.2.1 主要优点

- **时间复杂度稳定**：任何情况下都是O(n log n)
- **稳定排序**：保持相等元素的相对位置
- **可预测性能**：不受输入数据影响
- **适合大数据**：处理大规模数据效率高
- **并行友好**：易于并行化实现

##### 7.2.2 主要缺点

- **空间开销大**：需要O(n)的额外空间
- **常数因子大**：实际运行时可能比快速排序慢
- **不是原地排序**：无法在原数组上直接排序

---

## 8. 📋 总结


### 8.1 核心要点

1. **🔸 分治思想**：将大问题分解为小问题递归解决
2. **🔸 稳定性能**：时间复杂度稳定在O(n log n)
3. **🔸 稳定排序**：保持相等元素的相对位置不变
4. **🔸 空间代价**：需要O(n)的额外存储空间
5. **🔸 实用价值**：在需要稳定排序的场景中首选

### 8.2 适用原则


##### 8.2.1 推荐使用归并排序的情况

- ✅ 需要稳定排序
- ✅ 数据量较大（>1000）
- ✅ 可以接受O(n)空间复杂度
- ✅ 需要可预测的性能
- ✅ 链表排序
- ✅ 外部排序

##### 8.2.2 不推荐使用归并排序的情况

- ❌ 内存空间严格受限
- ❌ 小规模数据排序
- ❌ 必须原地排序
- ❌ 对常数因子要求苛刻

