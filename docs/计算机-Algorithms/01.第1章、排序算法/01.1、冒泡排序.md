---
title: 1、冒泡排序
---
## 📋 目录

1. [概念定义](#1-概念定义)
2. [算法原理](#2-算法原理)
3. [执行过程](#3-执行过程)
4. [代码实现](#4-代码实现)
5. [性能分析](#5-性能分析)
6. [优化策略](#6-优化策略)
7. [实际应用](#7-实际应用)
8. [总结要点](#8-总结要点)

---

## 1. 🔥 概念定义


### 1.1 基本概念

冒泡排序（Bubble Sort）是一种简单的比较排序算法。它的工作原理是通过**重复遍历**待排序的数列，**一次比较两个元素**，如果它们的顺序错误就把它们**交换过来**。

### 1.2 命名由来

- 较小的元素会经由交换慢慢"浮"到数列的顶端
- 就如同气泡在水中上浮一样，故得名"冒泡排序"

### 1.3 算法特点

- ✅ **稳定排序**：相等元素的相对位置不会改变
- ✅ **原地排序**：只需要常数级别的额外空间
- ✅ **比较排序**：通过比较元素大小来确定顺序

---

## 2. 📋 算法原理


### 2.1 核心思想

1. **相邻比较**：比较相邻的两个元素
2. **条件交换**：如果前一个元素大于后一个元素，就交换它们
3. **重复遍历**：对整个数组重复这个过程
4. **确定位置**：每轮遍历确定一个元素的最终位置

### 2.2 工作机制

```
第1轮：将最大元素"冒泡"到数组末尾
第2轮：将第二大元素"冒泡"到倒数第二位
...
第n-1轮：完成整个数组的排序
```

### 2.3 图解示例

```
原始数组：[64, 34, 25, 12, 22, 11, 90]

第1轮遍历：
[64, 34, 25, 12, 22, 11, 90]  比较64和34，交换
[34, 64, 25, 12, 22, 11, 90]  比较64和25，交换
[34, 25, 64, 12, 22, 11, 90]  比较64和12，交换
[34, 25, 12, 64, 22, 11, 90]  比较64和22，交换
[34, 25, 12, 22, 64, 11, 90]  比较64和11，交换
[34, 25, 12, 22, 11, 64, 90]  比较64和90，不交换
结果：[34, 25, 12, 22, 11, 64, 90]  // 90确定位置

第2轮遍历：
[34, 25, 12, 22, 11, 64, 90]  // 只需要比较前6个元素
...
```

---

## 3. 📊 执行过程


### 3.1 详细步骤

1. **初始化**：从数组第一个元素开始
2. **内层循环**：相邻元素两两比较
3. **交换判断**：如果左边元素大于右边元素，进行交换
4. **外层循环**：重复上述过程n-1次
5. **提前终止**：如果某轮没有交换操作，说明已经排序完成

### 3.2 循环结构

```
外层循环：控制排序轮数（n-1轮）
内层循环：控制每轮的比较次数
```

### 3.3 边界条件

- **外层循环**：执行n-1轮（n为数组长度）
- **内层循环**：每轮比较次数递减
- **终止条件**：当某轮没有元素交换时提前结束

---

## 4. 💡 代码实现


### 4.1 基础版本

```java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    
    // 外层循环：控制排序轮数
    for (int i = 0; i < n - 1; i++) {
        // 内层循环：相邻元素比较
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

### 4.2 优化版本

```java
public static void bubbleSortOptimized(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;  // 标记是否发生交换
        
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        
        // 如果没有交换，说明已经有序
        if (!swapped) {
            break;
        }
    }
}
```

### 4.3 完整测试代码

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        
        System.out.println("原始数组：" + Arrays.toString(arr));
        bubbleSortOptimized(arr);
        System.out.println("排序后：" + Arrays.toString(arr));
    }
    
    // 优化版冒泡排序
    public static void bubbleSortOptimized(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            
            if (!swapped) break;
        }
    }
}
```

---

## 5. 📚 性能分析


### 5.1 时间复杂度

| 情况 | 时间复杂度 | 说明 |
|------|-----------|------|
| **最好情况** | O(n) | 数组已经有序，只需一轮遍历 |
| **平均情况** | O(n²) | 随机排列的数组 |
| **最坏情况** | O(n²) | 数组完全逆序 |

### 5.2 空间复杂度

- **辅助空间**：O(1)
- **原地排序**：只需要一个临时变量用于交换

### 5.3 稳定性分析

- **稳定排序**：相等元素的相对位置不会改变
- **原因**：只有当 `arr[j] > arr[j+1]` 时才交换，相等时不交换

### 5.4 性能对比

```
数据规模    基础版本耗时    优化版本耗时
1000        ~10ms          ~8ms
10000       ~800ms         ~600ms
100000      ~80s           ~60s
```

---

## 6. 🧩 优化策略


### 6.1 提前终止优化

```java
// 添加标记变量，如果某轮没有交换则提前结束
boolean swapped = false;
if (!swapped) break;
```

### 6.2 记录最后交换位置

```java
public static void bubbleSortOptimized2(int[] arr) {
    int n = arr.length;
    int lastSwapIndex = n - 1;
    
    while (lastSwapIndex > 0) {
        int newLastSwapIndex = 0;
        
        for (int j = 0; j < lastSwapIndex; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                newLastSwapIndex = j;
            }
        }
        
        lastSwapIndex = newLastSwapIndex;
    }
}
```

### 6.3 双向冒泡（鸡尾酒排序）

```java
public static void cocktailSort(int[] arr) {
    int left = 0, right = arr.length - 1;
    
    while (left < right) {
        // 从左到右冒泡
        for (int i = left; i < right; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
            }
        }
        right--;
        
        // 从右到左冒泡
        for (int i = right; i > left; i--) {
            if (arr[i] < arr[i - 1]) {
                swap(arr, i, i - 1);
            }
        }
        left++;
    }
}
```

---

## 7. 📍 实际应用


### 7.1 适用场景

- ✅ **数据量小**：n < 50时性能可接受
- ✅ **教学演示**：算法思想简单易懂
- ✅ **基本有序**：数据基本有序时效率较高
- ✅ **稳定性要求**：需要保持相等元素的相对位置

### 7.2 不适用场景

- ❌ **大数据量**：O(n²)时间复杂度太高
- ❌ **性能要求高**：有更高效的排序算法
- ❌ **内存受限**：虽然空间复杂度O(1)，但时间效率低

### 7.3 实际使用建议

```java
// 根据数据规模选择排序算法
public static void smartSort(int[] arr) {
    if (arr.length < 50) {
        bubbleSort(arr);  // 小数据量使用冒泡排序
    } else {
        Arrays.sort(arr); // 大数据量使用系统排序
    }
}
```

---

## 8. 📊 总结要点


### 8.1 核心知识点

1. **算法思想**：相邻比较，逐步确定元素位置
2. **时间复杂度**：O(n²)，最好情况O(n)
3. **空间复杂度**：O(1)，原地排序
4. **稳定性**：稳定排序算法

### 8.2 记忆口诀

```
冒泡排序很简单，
相邻比较做交换，
大的元素往后移，
一轮确定一个位。
```
