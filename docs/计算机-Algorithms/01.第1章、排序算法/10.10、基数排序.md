---
title: 10、基数排序
---
## 📚 目录

1. [算法概述](#1-算法概述)
2. [基本思想](#2-基本思想)
3. [算法原理](#3-算法原理)
4. [实现方法](#4-实现方法)
5. [算法分析](#5-算法分析)
6. [应用场景](#6-应用场景)
7. [对比分析](#7-对比分析)
8. [总结](#8-总结)

---

## 1. 📖 算法概述


### 1.1 定义

基数排序（Radix Sort）是一种非比较型的整数排序算法。它通过逐位排序来实现整体排序，即从最低位（或最高位）开始，对每一位使用稳定排序算法（通常是计数排序）进行排序，直到最高位（或最低位）完成。

### 1.2 历史背景

- **起源**：最早用于机械式排序机
- **发展**：Herman Hollerith 在1887年发明的制表机使用了类似思想
- **现代化**：随着计算机发展而完善的算法
- **地位**：线性时间排序算法的重要代表

### 1.3 核心特征

- **🔹 非比较排序**：不通过比较元素大小来排序
- **🔹 稳定排序**：相等元素的相对位置保持不变
- **🔹 线性时间**：时间复杂度为O(d(n+k))
- **🔹 逐位处理**：按位进行排序处理

### 1.4 算法分类

- 非比较排序算法
- 线性时间排序算法
- 稳定排序算法
- 分布排序算法

---

## 2. 💡 基本思想


### 2.1 核心思想

基数排序的基本思想是：
1. **位数分解**：将整数按位分解（个位、十位、百位...）
2. **逐位排序**：从最低位开始，对每一位进行稳定排序
3. **保持稳定性**：确保相等元素的相对位置不变
4. **最终有序**：所有位排序完成后，整个数组有序

### 2.2 为什么有效？

- **位权原理**：高位的权重大于低位
- **稳定性保证**：低位排序的结果被高位排序保持
- **逐步优化**：每一位的排序都使整体更有序
- **线性时间**：避免了比较操作的复杂度

### 2.3 排序过程示例

以数组 [329, 457, 657, 839, 436, 720, 355] 为例（LSD方式）：

```
原始数组: [329, 457, 657, 839, 436, 720, 355]

第一轮：按个位排序
个位数:   [  9,   7,   7,   9,   6,   0,   5]
排序后:   [720, 355, 436, 457, 657, 329, 839]

第二轮：按十位排序（保持稳定性）
十位数:   [ 2,   5,   3,   5,   5,   2,   3]
排序后:   [720, 329, 436, 355, 457, 657, 839]

第三轮：按百位排序
百位数:   [ 7,   3,   4,   3,   4,   6,   8]
排序后:   [329, 355, 436, 457, 657, 720, 839]

最终结果: [329, 355, 436, 457, 657, 720, 839]
```

---

## 3. ⚙️ 算法原理


### 3.1 工作机制

1. **确定位数**：找出最大数的位数，确定排序轮数
2. **逐位提取**：从最低位开始，提取每个数的当前位数字
3. **稳定排序**：对当前位使用稳定排序算法（通常是计数排序）
4. **重复处理**：继续处理下一位，直到最高位完成

### 3.2 关键概念


##### 3.2.1 基数（Radix）

- **定义**：数制的基，如十进制的基数是10，二进制是2
- **影响**：决定每一位可能的取值范围
- **常用基数**：10（十进制）、2（二进制）、256（字节）

##### 3.2.2 排序方向

- **LSD（Least Significant Digit）**：从最低位开始排序
- **MSD（Most Significant Digit）**：从最高位开始排序
- **选择**：LSD更常用，实现更简单

### 3.3 稳定性要求

```
为什么需要稳定排序？

示例：排序 [25, 15]
如果十位排序不稳定：
- 个位排序后：[15, 25]（按个位5排序）
- 十位排序后：[15, 25] 或 [25, 15]（都是有效的）

但正确结果应该是 [15, 25]
只有使用稳定排序，才能保证低位排序的结果不被破坏
```

---

## 4. 🔨 实现方法


### 4.1 基础实现（Python - LSD）


```python
def radix_sort(arr):
    """
    基数排序基础实现（LSD方式）
    """
    if not arr:
        return arr
    
    # 找出最大数以确定位数
    max_num = max(arr)
    
    # 获取最大数的位数
    max_digits = len(str(max_num))
    
    # 从个位开始，逐位排序
    for digit_pos in range(max_digits):
        # 使用计数排序对当前位进行排序
        arr = counting_sort_by_digit(arr, digit_pos)
    
    return arr

def counting_sort_by_digit(arr, digit_pos):
    """
    按指定位数进行计数排序
    digit_pos: 0表示个位，1表示十位，以此类推
    """
    n = len(arr)
    output = [0] * n
    count = [0] * 10  # 0-9十个数字
    
    # 统计当前位数字的频次
    for num in arr:
        digit = (num // (10 ** digit_pos)) % 10
        count[digit] += 1
    
    # 计算累积频次
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    # 从后向前构建结果数组（保证稳定性）
    for i in range(n - 1, -1, -1):
        num = arr[i]
        digit = (num // (10 ** digit_pos)) % 10
        output[count[digit] - 1] = num
        count[digit] -= 1
    
    return output
```

### 4.2 优化实现（处理负数）


```python
def radix_sort_with_negative(arr):
    """
    支持负数的基数排序
    """
    if not arr:
        return arr
    
    # 分离正数和负数
    positive = [x for x in arr if x >= 0]
    negative = [-x for x in arr if x < 0]
    
    # 分别排序
    sorted_positive = radix_sort(positive) if positive else []
    sorted_negative = radix_sort(negative) if negative else []
    
    # 负数部分需要逆序并加负号
    sorted_negative = [-x for x in reversed(sorted_negative)]
    
    # 合并结果
    return sorted_negative + sorted_positive
```

### 4.3 MSD实现


```python
def radix_sort_msd(arr):
    """
    基数排序MSD实现
    """
    if not arr:
        return arr
    
    max_num = max(arr)
    max_digits = len(str(max_num))
    
    def msd_sort(arr, digit_pos):
        if digit_pos < 0 or len(arr) <= 1:
            return arr
        
        # 按当前位分桶
        buckets = [[] for _ in range(10)]
        
        for num in arr:
            digit = (num // (10 ** digit_pos)) % 10
            buckets[digit].append(num)
        
        # 递归排序每个桶
        result = []
        for bucket in buckets:
            if bucket:
                sorted_bucket = msd_sort(bucket, digit_pos - 1)
                result.extend(sorted_bucket)
        
        return result
    
    return msd_sort(arr, max_digits - 1)
```

### 4.4 Java 实现


```java
public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr.length == 0) return;
        
        // 找出最大数
        int max = arr[0];
        for (int num : arr) {
            max = Math.max(max, num);
        }
        
        // 按每一位进行排序
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    private static void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        // 统计当前位数字的频次
        for (int num : arr) {
            count[(num / exp) % 10]++;
        }
        
        // 计算累积频次
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // 构建结果数组
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        // 复制回原数组
        System.arraycopy(output, 0, arr, 0, n);
    }
}
```

### 4.5 C++ 实现


```cpp
#include <vector>
#include <algorithm>
using namespace std;

void countingSortByDigit(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n);
    vector<int> count(10, 0);
    
    // 统计当前位数字的频次
    for (int num : arr) {
        count[(num / exp) % 10]++;
    }
    
    // 计算累积频次
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 构建结果数组
    for (int i = n - 1; i >= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }
    
    // 复制回原数组
    arr = output;
}

void radixSort(vector<int>& arr) {
    if (arr.empty()) return;
    
    // 找出最大数
    int maxNum = *max_element(arr.begin(), arr.end());
    
    // 按每一位进行排序
    for (int exp = 1; maxNum / exp > 0; exp *= 10) {
        countingSortByDigit(arr, exp);
    }
}
```

---

## 5. 📊 算法分析


### 5.1 时间复杂度


##### 5.1.1 各阶段复杂度

- **找最大值**：`O(n)` <span style="color:#22c55e">✅ 线性</span>
- **每位排序**：`O(n + k)` <span style="color:#22c55e">✅ 线性</span>
- **总排序轮数**：`d` 轮（d为最大数的位数）

##### 5.1.2 总时间复杂度

- **复杂度**：`O(d(n + k))` <span style="color:#22c55e">✅ 线性</span>
- **说明**：
  - n：数组长度
  - k：基数（通常k=10）
  - d：最大数的位数

##### 5.1.3 实际分析

- 当d为常数时，时间复杂度为O(n)
- 当d = O(log n)时，复杂度为O(n log n)
- 对于32位整数，d ≤ 10，可视为常数

### 5.2 空间复杂度

- **计数数组**：`O(k)` <span style="color:#22c55e">✅ 常数</span>
- **输出数组**：`O(n)` <span style="color:#22c55e">✅ 线性</span>
- **总空间复杂度**：`O(n + k)`

### 5.3 稳定性分析

- **稳定排序**：<span style="color:#22c55e">✅ 稳定</span>
- **保证方法**：每位排序使用稳定的计数排序

### 5.4 性能特点

- **🔸 数据类型限制**：主要适用于整数
- **🔸 位数敏感**：性能与最大数的位数相关
- **🔸 基数选择**：不同基数影响常数因子
- **🔸 缓存友好**：访问模式相对连续

---

## 6. 🎯 应用场景


### 6.1 适用情况

- **🔸 整数排序**：主要用于非负整数排序
- **🔸 固定位数**：数据位数相对固定
- **🔸 大数据量**：数据量大且位数不多
- **🔸 稳定性要求**：需要保持相等元素的相对位置
- **🔸 字符串排序**：固定长度字符串排序

### 6.2 不适用情况

- **🔸 浮点数排序**：不适合直接排序浮点数
- **🔸 位数差异大**：最大数位数远大于平均位数
- **🔸 负数处理**：需要额外处理负数
- **🔸 小数据量**：数据量很小时开销相对较大

### 6.3 典型应用示例


```python
# 学号排序
def sort_student_ids(student_ids):
    """
    对学号进行排序（假设都是8位数字）
    """
    return radix_sort(student_ids)

# 日期排序（YYYYMMDD格式）
def sort_dates(dates):
    """
    对YYYYMMDD格式的日期进行排序
    """
    # 将日期字符串转换为整数
    date_ints = [int(date) for date in dates]
    
    # 使用基数排序
    sorted_ints = radix_sort(date_ints)
    
    # 转换回字符串格式
    return [str(date).zfill(8) for date in sorted_ints]

# IP地址排序
def sort_ip_addresses(ip_addresses):
    """
    对IP地址进行排序
    """
    def ip_to_int(ip):
        """将IP地址转换为整数"""
        parts = ip.split('.')
        return (int(parts[0]) << 24) + (int(parts[1]) << 16) + \
               (int(parts[2]) << 8) + int(parts[3])
    
    def int_to_ip(ip_int):
        """将整数转换为IP地址"""
        return f"{(ip_int >> 24) & 255}.{(ip_int >> 16) & 255}." \
               f"{(ip_int >> 8) & 255}.{ip_int & 255}"
    
    # 转换为整数并排序
    ip_ints = [ip_to_int(ip) for ip in ip_addresses]
    sorted_ints = radix_sort(ip_ints)
    
    # 转换回IP地址格式
    return [int_to_ip(ip_int) for ip_int in sorted_ints]

# 字符串排序（固定长度）
def sort_fixed_strings(strings, length):
    """
    对固定长度字符串进行基数排序
    """
    if not strings:
        return strings
    
    # 从最后一个字符开始排序
    for pos in range(length - 1, -1, -1):
        # 按当前位置的字符进行稳定排序
        strings = sorted(strings, key=lambda s: ord(s[pos]) if pos < len(s) else 0)
    
    return strings

# 年龄排序（基数排序版本）
def sort_ages_radix(ages):
    """
    使用基数排序对年龄进行排序
    """
    return radix_sort(ages)
```

---

## 7. ⚖️ 对比分析


### 7.1 与其他排序算法对比


| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 数据要求 |
|------|------------|------------|---------|----------|
| 基数排序 | O(d(n + k)) | O(n + k) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#f59e0b">⚠️ 整数</span> |
| 快速排序 | O(n log n) | O(log n) | <span style="color:#ef4444">❌ 不稳定</span> | <span style="color:#22c55e">✅ 通用</span> |
| 归并排序 | O(n log n) | O(n) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#22c55e">✅ 通用</span> |
| 计数排序 | O(n + k) | O(n + k) | <span style="color:#22c55e">✅ 稳定</span> | <span style="color:#f59e0b">⚠️ 小范围整数</span> |
| 桶排序 | O(n + k) | O(n + k) | <span style="color:#22c55e">✅ 可稳定</span> | <span style="color:#f59e0b">⚠️ 均匀分布</span> |

### 7.2 优缺点总结


##### 7.2.1 主要优点

- **线性时间**：在位数固定时达到O(n)时间复杂度
- **稳定排序**：保持相等元素的相对位置
- **非比较**：不依赖于元素间的比较
- **可预测性**：性能不依赖于数据分布
- **大数据友好**：适合处理大量整数数据

##### 7.2.2 主要缺点

- **数据类型限制**：主要适用于整数类型
- **位数敏感**：位数多时性能下降
- **空间开销**：需要额外的存储空间
- **实现复杂**：相比简单排序算法实现较复杂

### 7.3 选择建议


**推荐使用基数排序的情况**：
- ✅ 大量整数排序
- ✅ 数据位数相对固定
- ✅ 需要稳定排序
- ✅ 数据范围不适合计数排序
- ✅ 性能要求高

**不推荐使用基数排序的情况**：
- ❌ 浮点数排序
- ❌ 位数差异很大
- ❌ 小数据量排序
- ❌ 内存严格受限
- ❌ 需要通用排序

---

## 8. 📋 总结


### 8.1 核心要点

1. **🔸 逐位排序**：按位进行排序的核心思想
2. **🔸 稳定性关键**：每位排序必须稳定
3. **🔸 线性时间**：在位数固定时达到线性复杂度
4. **🔸 整数专用**：主要适用于整数排序
5. **🔸 实用价值**：在特定场景下性能优秀

### 8.2 关键技术点

- **位数确定**：正确计算最大数的位数
- **位提取**：准确提取每一位的数字
- **稳定排序**：使用稳定的计数排序作为子程序
- **方向选择**：LSD vs MSD的选择
- **负数处理**：正确处理负数的方法

### 8.3 适用原则


##### 8.3.1 何时选择基数排序

- ✅ 整数数据且位数不多
- ✅ 数据量大
- ✅ 需要稳定排序
- ✅ 性能要求高
- ✅ 数据范围不适合计数排序

##### 8.3.2 何时避免基数排序

- ❌ 浮点数或复杂数据类型
- ❌ 位数很多或差异很大
- ❌ 数据量很小
- ❌ 内存受限

### 8.4 学习价值

- **非比较思想**：理解非比较排序的核心
- **位操作技巧**：掌握位提取和处理技术
- **稳定性应用**：理解稳定性在算法中的重要性
- **复杂度分析**：理解多参数复杂度分析

### 8.5 实践建议

- **数据分析**：排序前分析数据的位数特征
- **基数选择**：根据具体情况选择合适的基数
- **实现选择**：根据数据特点选择LSD或MSD
- **负数处理**：注意处理负数的特殊情况

### 8.6 扩展应用

- **字符串排序**：固定长度字符串的排序
- **多关键字排序**：按多个字段排序的应用
- **外部排序**：大文件排序中的应用
- **数据库索引**：数据库系统中的应用












