---
title: 3、主从配置和管理
---
## 📚 目录

1. [配置方式详解](#1-配置方式详解)
2. [主从关系管理](#2-主从关系管理)
3. [配置参数详解](#3-配置参数详解)
4. [多级主从架构](#4-多级主从架构)
5. [故障处理与运维](#5-故障处理与运维)
6. [核心要点总结](#6-核心要点总结)

---

## 1. ⚙️ 配置方式详解


### 1.1 什么是主从复制配置


**🤔 为什么要配置主从？**

想象一下，你开了一家餐厅，只有你一个厨师。客人多的时候，你一个人忙不过来，客人就要等很久。如果你再招几个助手厨师，你负责主要的菜，助手帮忙做一些简单的，这样效率就高多了。

```
单机Redis：
客户端请求 -> Redis服务器 -> 返回数据
                ↑
             压力集中

主从Redis：
客户端写请求 -> 主Redis -> 同步数据 -> 从Redis1
客户端读请求 -> 从Redis1                -> 从Redis2
                 ↑                      -> 从Redis3
            压力分散，提高并发处理能力
```

> 💡 **通俗理解**：主节点负责"写"，从节点负责"读"，就像老板做决策，员工执行任务。

### 1.2 replicaof命令动态配置


**⚡ 动态建立主从关系**

```bash
# 在从节点上执行（最常用方式）
redis-cli -h 192.168.1.11 -p 6379
127.0.0.1:6379> REPLICAOF 192.168.1.10 6379

# 立即生效，开始同步主节点数据
127.0.0.1:6379> INFO replication
# role:slave
# master_host:192.168.1.10
# master_port:6379
# master_link_status:up
```

**📋 动态配置的完整流程**

```bash
# 第1步：启动主节点（192.168.1.10）
redis-server --port 6379

# 第2步：启动从节点（192.168.1.11）
redis-server --port 6379

# 第3步：在从节点执行复制命令
redis-cli -h 192.168.1.11
REPLICAOF 192.168.1.10 6379

# 第4步：验证主从关系
# 在主节点查看
INFO replication
# connected_slaves:1
# slave0:ip=192.168.1.11,port=6379,state=online

# 在从节点查看  
INFO replication
# role:slave
# master_host:192.168.1.10
```

**🔄 解除主从关系**

```bash
# 在从节点执行
REPLICAOF NO ONE

# 从节点变为独立的主节点
# role变为master，不再同步数据
```

### 1.3 配置文件静态设置


**📝 配置文件方式（推荐生产环境）**

```ini
# 从节点的redis.conf文件
# ================================ 主从复制配置 ================================

# 指定主节点地址和端口
replicaof 192.168.1.10 6379

# 主节点密码（如果主节点设置了密码）
masterauth mypassword

# 从节点只读模式（默认开启）
replica-read-only yes

# 连接断开时是否继续服务过期数据
replica-serve-stale-data yes

# 主节点密码认证
# requirepass mypassword
```

**🚀 启动配置**

```bash
# 使用配置文件启动从节点
redis-server /etc/redis/redis-slave.conf

# 验证配置生效
redis-cli -p 6379 INFO replication
```

### 1.4 从节点配置参数优化


**🎯 关键配置参数**

```ini
# ================ 从节点专用配置 ================

# 主从复制基础配置
replicaof 192.168.1.10 6379
masterauth password123

# 只读模式（防止从节点被误写）
replica-read-only yes

# 复制超时时间（默认60秒）
repl-timeout 60

# 复制积压缓冲区（处理网络抖动）
repl-backlog-size 16mb
repl-backlog-ttl 3600

# 无盘复制（网络比磁盘快时使用）
repl-diskless-sync yes
repl-diskless-sync-delay 5

# 从节点优先级（用于哨兵选主）
replica-priority 100
```

### 1.5 主节点配置优化


**🎛️ 主节点性能调优**

```ini
# ================ 主节点优化配置 ================

# 复制积压缓冲区（重要！）
repl-backlog-size 64mb    # 适当增大，处理网络抖动
repl-backlog-ttl 7200     # 2小时后清理

# 无盘复制配置
repl-diskless-sync yes             # 启用无盘复制
repl-diskless-sync-delay 5         # 等待5秒收集更多从节点
repl-diskless-load disabled        # 从节点加载方式

# 客户端连接优化
tcp-keepalive 300                  # TCP保活时间
timeout 0                          # 客户端连接超时（0表示不超时）

# 内存和持久化
maxmemory 2gb                      # 最大内存限制
save 900 1                         # RDB持久化策略
appendonly yes                     # AOF持久化
```

---

## 2. 🔄 主从关系管理


### 2.1 动态添加从节点


**📈 在线扩展从节点**

```bash
# 场景：系统运行中，读压力增大，需要添加从节点

# 第1步：准备新的Redis实例
redis-server --port 6380 --dir /data/redis-slave2

# 第2步：动态建立主从关系
redis-cli -p 6380
127.0.0.1:6380> REPLICAOF 192.168.1.10 6379

# 第3步：监控同步状态
127.0.0.1:6380> INFO replication
# master_link_status:up
# master_last_io_seconds_ago:1
# master_sync_in_progress:0

# 第4步：在主节点验证
redis-cli -p 6379
127.0.0.1:6379> INFO replication
# connected_slaves:3
# slave2:ip=127.0.0.1,port=6380,state=online
```

**⚡ 批量添加从节点脚本**

```bash
#!/bin/bash
# add_slaves.sh - 批量添加从节点

MASTER_IP="192.168.1.10"
MASTER_PORT="6379"

# 添加3个从节点
for i in {1..3}; do
    SLAVE_PORT=$((6379 + i))
    echo "添加从节点：端口${SLAVE_PORT}"
    
    # 启动从节点
    redis-server --port ${SLAVE_PORT} --daemonize yes &
    sleep 2
    
    # 建立主从关系
    redis-cli -p ${SLAVE_PORT} REPLICAOF ${MASTER_IP} ${MASTER_PORT}
    
    echo "从节点${SLAVE_PORT}配置完成"
done

echo "所有从节点添加完成"
```

### 2.2 从节点角色切换


**🔄 主从角色动态切换**

```bash
# 场景1：从节点提升为主节点
# 当前：A(主) -> B(从) -> C(从)
# 目标：B(主) -> A(从), C(从)

# 在节点B上执行
redis-cli -h 192.168.1.11
127.0.0.1:6379> REPLICAOF NO ONE    # B变为独立主节点

# 在节点A上执行
redis-cli -h 192.168.1.10  
127.0.0.1:6379> REPLICAOF 192.168.1.11 6379  # A变为B的从节点

# 在节点C上执行
redis-cli -h 192.168.1.12
127.0.0.1:6379> REPLICAOF 192.168.1.11 6379  # C切换到B主节点
```

**📊 切换状态监控**

```bash
# 创建监控脚本 monitor_switch.sh
while true; do
    echo "=== $(date) ==="
    echo "节点A角色：$(redis-cli -h 192.168.1.10 INFO replication | grep role)"
    echo "节点B角色：$(redis-cli -h 192.168.1.11 INFO replication | grep role)"  
    echo "节点C角色：$(redis-cli -h 192.168.1.12 INFO replication | grep role)"
    echo "---"
    sleep 3
done
```

### 2.3 主从关系解除


**⚙️ 安全解除主从关系**

```bash
# 方法1：从节点主动解除
redis-cli -h slave-ip
REPLICAOF NO ONE

# 方法2：主节点断开特定从节点（Redis 6.0+）
redis-cli -h master-ip  
CLIENT KILL TYPE replica   # 断开所有从节点连接

# 方法3：配置文件注释
# vim redis-slave.conf
# replicaof 192.168.1.10 6379  # 注释此行
# 重启: redis-server redis-slave.conf
```

**⚠️ 解除关系注意事项**

```
解除前检查清单：
□ 确认从节点数据已完全同步
□ 确认解除后不影响读写分离
□ 准备好新的数据备份方案
□ 通知应用程序连接配置调整
```

---

## 3. 🔧 配置参数详解


### 3.1 replica-read-only 从节点只读设置


**📖 只读模式的重要性**

```ini
# 从节点只读配置（强烈推荐保持开启）
replica-read-only yes
```

**为什么要设置只读？**

想象图书馆里，图书管理员负责买书、整理书架（写操作），而读者只能借阅图书（读操作）。如果读者也能随意增删书籍，图书馆就乱套了。

```
主从数据一致性保障：

✅ 正确方式（只读开启）：
主节点：SET user:1001 "张三"
从节点：只能 GET user:1001   -> 保证数据一致

❌ 错误方式（只读关闭）：
主节点：SET user:1001 "张三" 
从节点：SET user:1001 "李四"  -> 数据不一致！
```

**🔄 只读模式验证**

```bash
# 在从节点尝试写操作
redis-cli -h slave-ip
127.0.0.1:6379> SET test "value"
(error) READONLY You can't write against a read only replica.

# 只能执行读操作
127.0.0.1:6379> GET some_key
"some_value"
```

### 3.2 replica-serve-stale-data 过期数据服务


**🕰️ 网络中断时的数据服务策略**

```ini
# 主从连接断开时是否继续提供服务
replica-serve-stale-data yes
```

**配置含义对比**：

```
replica-serve-stale-data yes（默认）：
主从断开 -> 从节点继续提供读服务 -> 可能返回过期数据
优点：保证服务可用性
缺点：数据可能不是最新的

replica-serve-stale-data no：  
主从断开 -> 从节点拒绝所有读请求 -> 返回错误
优点：保证数据新鲜度
缺点：影响服务可用性
```

**🎯 实际业务场景选择**

```bash
# 电商商品信息（对数据新鲜度要求不高）
replica-serve-stale-data yes

# 金融交易数据（必须保证数据实时性）  
replica-serve-stale-data no
```

### 3.3 repl-diskless-sync 无盘复制


**💿 传统复制 vs 无盘复制**

```
传统磁盘复制：
主节点 -> 生成RDB文件到磁盘 -> 读取文件 -> 发送给从节点
时间开销：磁盘IO + 网络传输

无盘复制：
主节点 -> 直接通过网络发送RDB数据 -> 从节点接收
时间开销：仅网络传输
```

**⚙️ 无盘复制配置**

```ini
# 启用无盘复制（网络比磁盘快时推荐）
repl-diskless-sync yes

# 无盘复制延迟（等待更多从节点一起同步）
repl-diskless-sync-delay 5

# 从节点无盘加载方式
repl-diskless-load disabled   # 关闭从节点无盘加载
# repl-diskless-load on-empty-db  # 仅空数据库时无盘加载
# repl-diskless-load swapdb      # 使用数据库交换
```

**🎯 使用场景判断**

```
选择无盘复制的条件：
✅ 网络带宽充足（>100Mbps）
✅ 磁盘IO较慢（机械硬盘）
✅ 有多个从节点需要同步

选择磁盘复制的条件：
✅ 磁盘IO很快（SSD）
✅ 网络带宽有限
✅ 从节点较少
```

### 3.4 repl-backlog-size 复制积压缓冲区


**📊 积压缓冲区的作用**

当主从连接短暂中断时，主节点会把新的写命令存在一个环形缓冲区里。从节点重连后可以增量同步，而不需要全量同步。

```
环形缓冲区工作原理：

写命令流：SET key1 value1 -> SET key2 value2 -> SET key3 value3
                ↓              ↓              ↓
积压缓冲区：[  key1  |  key2  |  key3  |      |      ]
            ↑                           ↑
         开始位置                    写入位置

从节点重连时：
1. 从节点报告最后同步位置
2. 主节点检查积压缓冲区是否还有对应数据
3. 有 -> 增量同步，无 -> 全量同步
```

**⚙️ 缓冲区大小设置**

```ini
# 积压缓冲区大小（默认1MB，建议调大）
repl-backlog-size 16mb

# 积压缓冲区超时时间（主节点无从节点时保持多久）
repl-backlog-ttl 3600

# 计算公式：
# 缓冲区大小 = 平均写速率 × 网络中断时间 × 安全系数
# 示例：100KB/s × 60s × 2 = 12MB
```

**📈 监控积压缓冲区使用情况**

```bash
# 查看积压缓冲区状态
redis-cli INFO replication | grep backlog
# repl_backlog_active:1
# repl_backlog_size:1048576  
# repl_backlog_first_byte_offset:123456
# repl_backlog_histlen:1000
```

---

## 4. 🏗️ 多级主从架构


### 4.1 多级复制拓扑结构


**🌳 树形主从架构**

```
                主节点(Master)
                   |
         ┌─────────┼─────────┐
         │         │         │
    从节点1      从节点2    从节点3
   (Slave1)    (Slave2)   (Slave3)
      |           |
  ┌───┼───┐   ┌───┼───┐
  │   │   │   │   │   │
从1-1 从1-2 从1-3 从2-1 从2-2 从2-3

优点：减少主节点负载，分散复制压力
缺点：数据延迟增加，故障影响范围大
```

**⚙️ 多级配置示例**

```bash
# 一级从节点配置（直接连主节点）
redis-cli -p 6380
REPLICAOF 192.168.1.10 6379

# 二级从节点配置（连接一级从节点）
redis-cli -p 6381  
REPLICAOF 192.168.1.11 6380

# 配置文件方式
# slave1.conf
replicaof 192.168.1.10 6379

# slave2.conf  
replicaof 192.168.1.11 6380
```

### 4.2 链式主从架构


**🔗 链式复制设计**

```
链式结构：
主节点 -> 从节点1 -> 从节点2 -> 从节点3

好处：
- 减少主节点网络压力
- 便于地理分布部署

风险：
- 单点故障影响链路
- 数据同步延迟累积
```

**🎯 链式架构最佳实践**

```bash
# 链式配置建议
# 主节点（北京）
redis-server --port 6379

# 一级从节点（上海）
replicaof beijing-master.com 6379
replica-read-only yes

# 二级从节点（深圳）  
replicaof shanghai-slave.com 6379
replica-read-only yes

# 监控链路健康
INFO replication
# 关注 master_link_status 和 master_last_io_seconds_ago
```

---

## 5. ⚙️ 故障处理与运维


### 5.1 常见故障诊断


**🚨 主从同步故障诊断**

```bash
# 检查主从连接状态
redis-cli -p 6379 INFO replication

# 关键指标说明：
# master_link_status:down     # 连接状态：up正常，down异常
# master_last_io_seconds_ago  # 最后通信时间，>30秒需注意
# master_sync_in_progress:1   # 正在全量同步中
```

**📋 故障排查清单**

```
□ 网络连通性检查
  ping master-ip
  telnet master-ip 6379

□ 密码认证检查  
  masterauth配置是否正确
  主节点requirepass是否设置

□ 防火墙检查
  主节点6379端口是否开放
  从节点能否连接主节点

□ 内存检查
  主节点内存是否充足
  从节点内存是否够用

□ 配置文件检查
  replicaof配置是否正确
  其他相关参数是否合理
```

### 5.2 性能监控与优化


**📊 关键监控指标**

```bash
# 创建监控脚本 monitor_replication.sh
#!/bin/bash
echo "Redis主从复制监控报告"
echo "======================="

# 主节点状态
echo "【主节点状态】"
redis-cli -h master-ip INFO replication | grep -E "(role|connected_slaves)"

# 从节点状态
echo "【从节点状态】"  
for slave_ip in slave1-ip slave2-ip slave3-ip; do
    echo "从节点 $slave_ip:"
    redis-cli -h $slave_ip INFO replication | grep -E "(role|master_link_status|master_last_io)"
done

# 复制延迟检查
echo "【复制延迟检查】"
redis-cli -h master-ip SET test_sync_time $(date +%s)
sleep 1
for slave_ip in slave1-ip slave2-ip slave3-ip; do
    sync_time=$(redis-cli -h $slave_ip GET test_sync_time)
    echo "从节点 $slave_ip 延迟: $(($(date +%s) - sync_time)) 秒"
done
```

### 5.3 主从切换演练


**🔄 计划性主从切换**

```bash
# 计划性维护主节点时的切换流程

# 第1步：选择一个从节点作为新主节点
NEW_MASTER="192.168.1.11"
OLD_MASTER="192.168.1.10"

# 第2步：停止应用写入老主节点
echo "停止应用写入，等待数据同步完成"

# 第3步：确认数据完全同步
redis-cli -h $NEW_MASTER LASTSAVE
redis-cli -h $OLD_MASTER LASTSAVE  # 两个时间戳应该相近

# 第4步：提升从节点为主节点
redis-cli -h $NEW_MASTER REPLICAOF NO ONE

# 第5步：其他从节点切换到新主节点
for slave in 192.168.1.12 192.168.1.13; do
    redis-cli -h $slave REPLICAOF $NEW_MASTER 6379
done

# 第6步：应用程序切换连接
echo "更新应用配置，连接新主节点"

# 第7步：老主节点变为从节点
redis-cli -h $OLD_MASTER REPLICAOF $NEW_MASTER 6379
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 主从复制：主节点处理写，从节点处理读，实现读写分离
🔸 复制方式：全量同步+增量同步，保证数据一致性
🔸 配置方法：动态命令（replicaof）和静态配置文件两种方式
🔸 关键参数：只读模式、积压缓冲区、无盘复制等重要配置
🔸 故障处理：主从切换、角色转换、关系解除的操作方法
```

### 6.2 关键理解要点


**🔹 配置方式的选择原则**
```
开发测试环境：
- 使用replicaof命令动态配置
- 快速验证，方便调试

生产环境：
- 使用配置文件静态配置  
- 重启后配置保持，稳定可靠
```

**🔹 参数配置的业务考量**
```
replica-read-only：
- 必须开启，保证数据一致性
- 防止从节点被误操作

repl-backlog-size：
- 根据写入量和网络状况调整
- 宁大勿小，避免全量同步

repl-diskless-sync：
- 网络好于磁盘时开启
- 减少磁盘IO压力
```

**🔹 多级架构的设计考虑**
```
性能权衡：
- 多级减少主节点压力
- 但增加同步延迟

可用性权衡：
- 提供更多读节点
- 但故障影响范围大

运维复杂度：
- 节点越多，管理越复杂
- 需要完善监控体系
```

### 6.3 生产环境最佳实践


**✅ 配置建议**
```bash
# 推荐的从节点配置模板
# ================== 基础主从配置 ==================
replicaof master-host 6379
masterauth your-password

# ================== 性能优化配置 ==================
replica-read-only yes                    # 强制只读
replica-serve-stale-data yes            # 网络中断时继续服务
repl-timeout 60                         # 复制超时60秒
repl-backlog-size 64mb                  # 积压缓冲区64MB
repl-backlog-ttl 3600                   # 缓冲区保持1小时

# ================== 网络优化配置 ==================
repl-diskless-sync yes                  # 启用无盘复制
repl-diskless-sync-delay 5              # 延迟5秒等待更多从节点
tcp-keepalive 300                       # TCP保活5分钟
```

**📊 监控检查项**
- **复制延迟**：master_last_io_seconds_ago < 30秒
- **连接状态**：master_link_status = up
- **同步状态**：master_sync_in_progress = 0（非同步期间）
- **缓冲区使用**：repl_backlog_histlen < repl_backlog_size * 0.8

### 6.4 故障应急预案


**🚨 主节点故障处理**
```
自动化应急流程：
1. 监控系统检测主节点宕机
2. 自动选择最优从节点（数据最新、性能最好）
3. 将选中从节点提升为主节点（REPLICAOF NO ONE）
4. 其他从节点切换到新主节点
5. 应用程序连接切换到新主节点
6. 记录故障日志，后续分析
```

**⚠️ 从节点故障处理**
```
从节点故障处理：
1. 从负载均衡中移除故障从节点
2. 故障从节点修复后重新加入
3. 检查数据同步状态
4. 确认无误后恢复读取流量
```

**核心记忆**：
- 主从配置要考虑可用性和一致性的平衡
- replicaof命令用于动态管理，配置文件用于持久化
- 关键参数要根据实际业务场景调整
- 多级架构可以分散压力但增加复杂度
- 生产环境必须有完善的监控和应急预案