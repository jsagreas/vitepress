---
title: 7、缓存三大问题方案
---
## 📚 目录

1. [缓存问题概述](#1-缓存问题概述)
2. [缓存穿透问题](#2-缓存穿透问题)
3. [缓存击穿问题](#3-缓存击穿问题)
4. [缓存雪崩问题](#4-缓存雪崩问题)
5. [综合解决方案](#5-综合解决方案)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 缓存问题概述


### 1.1 什么是缓存三大问题


**缓存的本质作用**
缓存就像餐厅的备菜台，把经常点的菜提前做好放在那里。顾客点菜时直接拿，不用现做，速度快很多。Redis缓存也是这个道理，把经常查的数据提前放在内存里。

**三大问题的本质**
当缓存这个"备菜台"出现问题时，所有请求都得去"后厨"（数据库），瞬间把后厨压垮。这就是缓存三大问题的共同特征。

```
正常情况：
用户请求 → 缓存命中 → 快速响应
         ↘ 缓存未命中 → 查数据库 → 更新缓存 → 响应

问题情况：
大量请求 → 缓存失效 → 同时查数据库 → 数据库压力山大 💥
```

### 1.2 三大问题对比


| 问题类型 | **根本原因** | **影响范围** | **危害程度** |
|---------|-------------|-------------|-------------|
| **缓存穿透** | `查询不存在的数据` | `持续性影响` | `⭐⭐⭐☆☆` |
| **缓存击穿** | `热点数据突然失效` | `瞬时高峰影响` | `⭐⭐⭐⭐☆` |
| **缓存雪崩** | `大量数据同时失效` | `系统性灾难` | `⭐⭐⭐⭐⭐` |

### 1.3 问题发生的业务场景


**电商网站示例**
```
缓存穿透：恶意用户查询不存在的商品ID
缓存击穿：爆款商品缓存到期，瞬间大量查询
缓存雪崩：双11零点，所有商品缓存同时过期
```

---

## 2. 🕳️ 缓存穿透问题


### 2.1 什么是缓存穿透


**通俗理解**
想象你是餐厅服务员，顾客总是点菜单上没有的菜。你每次都得跑后厨问厨师"有这道菜吗？"，厨师每次都说"没有"。这就是缓存穿透，查询的数据既不在缓存里，也不在数据库里。

**缓存穿透的流程**
```
恶意查询流程：
用户查询 → 缓存查不到 → 数据库查不到 → 返回空 → 下次还是要查数据库

正常查询流程：
用户查询 → 缓存查不到 → 数据库查到了 → 存入缓存 → 下次缓存命中
```

**缓存穿透示意图**
```
请求：查询商品ID=999999（不存在的商品）

第1次：Redis缓存 ❌ → MySQL数据库 ❌ → 返回null
第2次：Redis缓存 ❌ → MySQL数据库 ❌ → 返回null  
第3次：Redis缓存 ❌ → MySQL数据库 ❌ → 返回null
...

每次查询都要访问数据库，缓存完全失效！
```

### 2.2 缓存穿透的危害


**对数据库的影响**
```
正常情况：99%请求缓存命中，1%请求查询数据库
穿透攻击：100%请求查询数据库

假设场景：
• 正常QPS：10000
• 数据库能承受：100 QPS
• 穿透攻击：10000个无效查询直接打到数据库
• 结果：数据库瞬间崩溃
```

### 2.3 布隆过滤器解决方案


**布隆过滤器的作用**
布隆过滤器就像餐厅门口的菜单展示牌。顾客点菜前先看展示牌，如果展示牌上都没有，就不用进餐厅问了。

**布隆过滤器原理**
```
工作机制：
1. 系统启动时，将数据库中所有存在的ID加入布隆过滤器
2. 查询请求先经过布隆过滤器检查
3. 如果布隆过滤器说"不存在"，直接返回null
4. 如果布隆过滤器说"可能存在"，再查缓存和数据库

数据流程：
查询请求 → 布隆过滤器 → ❌不存在：直接返回
                      → ✅可能存在：继续查缓存/数据库
```

**布隆过滤器实现示例**
```java
public class ProductService {
    private BloomFilter<Long> productIdFilter;
    private RedisTemplate redisTemplate;
    
    // 系统启动时初始化
    @PostConstruct
    public void initBloomFilter() {
        // 创建布隆过滤器：预期100万商品，误判率1%
        productIdFilter = BloomFilter.create(Funnels.longFunnel(), 1000000, 0.01);
        
        // 将所有商品ID加入过滤器
        List<Long> allProductIds = productDao.getAllProductIds();
        for (Long productId : allProductIds) {
            productIdFilter.put(productId);
        }
    }
    
    public Product getProduct(Long productId) {
        // 第1步：布隆过滤器检查
        if (!productIdFilter.mightContain(productId)) {
            return null;  // 肯定不存在，直接返回
        }
        
        // 第2步：查询缓存
        String cacheKey = "product:" + productId;
        Product product = (Product) redisTemplate.opsForValue().get(cacheKey);
        
        if (product != null) {
            return product;  // 缓存命中
        }
        
        // 第3步：查询数据库
        product = productDao.getById(productId);
        if (product != null) {
            // 存入缓存
            redisTemplate.opsForValue().set(cacheKey, product, 30, TimeUnit.MINUTES);
        }
        
        return product;
    }
}
```

### 2.4 空值缓存解决方案


**空值缓存的思路**
既然数据库里确实没有这个数据，那就在缓存里记录"没有"这个结果。下次查询时，缓存直接告诉你"没有"，不用再去数据库确认。

**空值缓存实现**
```java
public Product getProductWithNullCache(Long productId) {
    String cacheKey = "product:" + productId;
    
    // 查询缓存
    String cached = redisTemplate.opsForValue().get(cacheKey);
    
    if (cached != null) {
        if ("NULL".equals(cached)) {
            return null;  // 缓存的空值
        }
        return JSON.parseObject(cached, Product.class);  // 正常数据
    }
    
    // 查询数据库
    Product product = productDao.getById(productId);
    
    if (product != null) {
        // 缓存正常数据
        redisTemplate.opsForValue().set(cacheKey, JSON.toJSONString(product), 30, TimeUnit.MINUTES);
    } else {
        // 缓存空值，设置较短过期时间
        redisTemplate.opsForValue().set(cacheKey, "NULL", 5, TimeUnit.MINUTES);
    }
    
    return product;
}
```

**两种方案对比**

| 方案 | **优点** | **缺点** | **适用场景** |
|------|---------|---------|-------------|
| **布隆过滤器** | `内存占用小，性能高` | `不支持删除，有误判` | `数据相对稳定的场景` |
| **空值缓存** | `实现简单，准确率100%` | `占用缓存空间` | `数据变化频繁的场景` |

---

## 3. 💥 缓存击穿问题


### 3.1 什么是缓存击穿


**通俗理解**  
想象热门餐厅的招牌菜，平时都是提前做好放在保温台上。突然保温台坏了，这道菜没了，但点这道菜的顾客特别多。所有顾客同时要求现做，厨房瞬间被挤爆。这就是缓存击穿。

**缓存击穿的特点**
```
影响范围：单个热点数据
发生时机：热点数据缓存过期的瞬间  
危害程度：瞬时大量请求直接查询数据库
恢复时间：第一个查询完成并更新缓存后恢复
```

**击穿发生过程**
```
正常状态：
热点商品缓存 ✅ → 1000 QPS全部命中缓存

击穿瞬间：
热点商品缓存 ❌ → 1000个查询同时打到数据库 💥

恢复后：
热点商品缓存 ✅ → 恢复正常
```

### 3.2 互斥锁解决方案


**互斥锁的思路**
就像餐厅规定"同时只能有一个服务员去后厨要菜"。其他服务员排队等待，拿到菜后大家一起分享。

**Redis分布式锁实现**
```java
public Product getProductWithMutex(Long productId) {
    String cacheKey = "product:" + productId;
    String lockKey = "lock:product:" + productId;
    
    // 查询缓存
    Product product = getFromCache(cacheKey);
    if (product != null) {
        return product;  // 缓存命中，直接返回
    }
    
    // 尝试获取互斥锁
    boolean lockAcquired = tryLock(lockKey, 10);  // 10秒超时
    
    if (lockAcquired) {
        try {
            // 获得锁，再次检查缓存（可能其他线程已更新）
            product = getFromCache(cacheKey);
            if (product != null) {
                return product;
            }
            
            // 查询数据库
            product = productDao.getById(productId);
            
            // 更新缓存
            if (product != null) {
                setCache(cacheKey, product, 30 * 60);  // 30分钟
            }
            
            return product;
        } finally {
            // 释放锁
            releaseLock(lockKey);
        }
    } else {
        // 未获得锁，等待一小段时间后重试
        Thread.sleep(50);
        return getProductWithMutex(productId);  // 递归重试
    }
}

// 尝试获取分布式锁
private boolean tryLock(String lockKey, int timeoutSeconds) {
    String lockValue = UUID.randomUUID().toString();
    Boolean result = redisTemplate.opsForValue().setIfAbsent(
        lockKey, lockValue, timeoutSeconds, TimeUnit.SECONDS);
    return Boolean.TRUE.equals(result);
}
```

**互斥锁方案的优缺点**
```
✅ 优点：
• 保证只有一个请求查询数据库
• 实现相对简单
• 不会产生脏数据

❌ 缺点：  
• 其他线程需要等待，性能略下降
• 如果锁holder挂了，需要锁超时机制
• 在高并发下仍有一定延迟
```

### 3.3 逻辑过期解决方案


**逻辑过期的创新思路**
不让Redis自动删除过期数据，而是在数据上加个"逻辑过期时间"标记。就像牛奶过期了但还在冰箱里，你看标签知道过期了，但可以先喝着，同时安排人去买新的。

**逻辑过期数据结构**
```java
// 封装带过期时间的缓存数据
public class CacheData {
    private Object data;           // 真正的数据
    private LocalDateTime expireTime;  // 逻辑过期时间
    
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expireTime);
    }
}
```

**逻辑过期实现**
```java
public Product getProductWithLogicalExpire(Long productId) {
    String cacheKey = "product:" + productId;
    
    // 查询缓存（永远不会过期）
    CacheData cacheData = getFromCache(cacheKey);
    
    if (cacheData == null) {
        // 缓存不存在，查询数据库并缓存
        return rebuildCache(productId);
    }
    
    if (!cacheData.isExpired()) {
        // 未过期，直接返回
        return (Product) cacheData.getData();
    }
    
    // 逻辑过期了，异步更新缓存
    String lockKey = "rebuild:" + productId;
    if (tryLock(lockKey, 10)) {
        // 获得锁，异步重建缓存
        CompletableFuture.supplyAsync(() -> {
            try {
                return rebuildCache(productId);
            } finally {
                releaseLock(lockKey);
            }
        });
    }
    
    // 返回过期数据（总比没有数据强）
    return (Product) cacheData.getData();
}

private Product rebuildCache(Long productId) {
    Product product = productDao.getById(productId);
    if (product != null) {
        CacheData cacheData = new CacheData();
        cacheData.setData(product);
        cacheData.setExpireTime(LocalDateTime.now().plusMinutes(30));
        
        // 存储到Redis（不设置过期时间）
        redisTemplate.opsForValue().set("product:" + productId, cacheData);
    }
    return product;
}
```

**逻辑过期vs互斥锁对比**

| 特性 | **互斥锁方案** | **逻辑过期方案** |
|------|---------------|-----------------|
| **响应时间** | `需要等待锁，略慢` | `立即返回，极快` |
| **数据一致性** | `强一致性` | `最终一致性` |
| **实现复杂度** | `简单` | `复杂` |
| **资源消耗** | `较少` | `需要线程池` |

---

## 4. ❄️ 缓存雪崩问题


### 4.1 什么是缓存雪崩


**形象比喻**
雪崩就是山上的雪突然全部滑下来。缓存雪崩就是大量缓存同时失效，所有查询都冲向数据库，就像雪崩一样势不可挡。

**雪崩发生场景**
```
典型场景1：定时任务统一设置缓存
晚上2点：批量设置商品缓存，过期时间都是12小时  
下午2点：所有缓存同时过期 → 雪崩发生

典型场景2：Redis服务器重启
Redis重启 → 所有缓存丢失 → 第一波请求全部查数据库

典型场景3：大促活动
双11零点 → 活动页面缓存过期 → 数百万用户同时刷新
```

### 4.2 过期时间错峰解决方案


**错峰策略的核心思想**
不让缓存同时过期，而是让它们错开时间过期。就像错峰上下班，避免交通拥堵。

**随机过期时间实现**
```java
public void setCacheWithRandomExpire(String key, Object value, int baseExpireSeconds) {
    // 基础过期时间 + 随机时间（0-30%的随机波动）
    int randomExpire = baseExpireSeconds + new Random().nextInt(baseExpireSeconds * 30 / 100);
    
    redisTemplate.opsForValue().set(key, value, randomExpire, TimeUnit.SECONDS);
}

// 使用示例
public void cacheProducts() {
    List<Product> products = productDao.getAllProducts();
    
    for (Product product : products) {
        String key = "product:" + product.getId();
        
        // 基础30分钟 + 0-9分钟随机时间
        setCacheWithRandomExpire(key, product, 1800);
    }
}
```

**分批过期策略**
```java
public void cacheProductsByBatch() {
    List<Product> products = productDao.getAllProducts();
    int batchSize = 1000;
    
    for (int i = 0; i < products.size(); i += batchSize) {
        List<Product> batch = products.subList(i, Math.min(i + batchSize, products.size()));
        
        // 每批设置不同的过期时间
        int expireTime = 1800 + (i / batchSize) * 60;  // 每批相差1分钟
        
        for (Product product : batch) {
            String key = "product:" + product.getId();
            redisTemplate.opsForValue().set(key, product, expireTime, TimeUnit.SECONDS);
        }
    }
}
```

### 4.3 限流和降级方案


**限流的作用**
当数据库压力过大时，限制访问频率。就像医院挂号限制每天接诊人数，避免医生累倒。

**简单限流实现**
```java
@Component  
public class RateLimiter {
    private final RedisTemplate redisTemplate;
    
    public boolean isAllowed(String key, int maxRequests, int windowSeconds) {
        String rateLimitKey = "rate_limit:" + key;
        Long currentRequests = redisTemplate.opsForValue().increment(rateLimitKey);
        
        if (currentRequests == 1) {
            // 第一次访问，设置过期时间
            redisTemplate.expire(rateLimitKey, windowSeconds, TimeUnit.SECONDS);
        }
        
        return currentRequests <= maxRequests;
    }
}

// 使用示例
@GetMapping("/product/{id}")
public Product getProduct(@PathVariable Long id) {
    // 每个用户每分钟最多查询100次
    String userKey = getCurrentUserId();
    if (!rateLimiter.isAllowed(userKey, 100, 60)) {
        throw new RuntimeException("访问频率超限，请稍后再试");
    }
    
    return productService.getProduct(id);
}
```

**服务降级策略**
```java
public Product getProductWithFallback(Long productId) {
    try {
        // 尝试正常查询
        return getProduct(productId);
    } catch (Exception e) {
        // 数据库压力大，返回默认数据
        return getDefaultProduct();
    }
}

private Product getDefaultProduct() {
    Product defaultProduct = new Product();
    defaultProduct.setName("商品暂时无法查看");
    defaultProduct.setDescription("系统繁忙，请稍后再试");
    return defaultProduct;
}
```

### 4.4 Redis高可用架构


**主从复制方案**
```
Redis主从架构：
Master节点 → 处理写操作，同步数据给Slave  
Slave节点 → 处理读操作，Master故障时可以切换

故障恢复：
Master挂了 → 自动切换到Slave → 服务继续 → 缓存数据保留
```

**Redis Cluster集群**
```
集群特点：
• 数据分片存储在多个节点
• 单个节点故障不影响整体服务  
• 自动故障转移和数据重分配
```

---

## 5. 🛠️ 综合解决方案


### 5.1 多层防护架构


**防护层次图**
```
请求流程的防护层：

用户请求
    ↓
┌─────────────────┐
│  限流层          │ ← 控制请求频率，防止突发流量
│  (Rate Limiting) │
└─────────────────┘
    ↓
┌─────────────────┐  
│  布隆过滤器      │ ← 快速过滤不存在的数据
│  (Bloom Filter) │
└─────────────────┘
    ↓
┌─────────────────┐
│  Redis缓存       │ ← 缓存热点数据，错峰过期
│  (Cache Layer)   │
└─────────────────┘  
    ↓
┌─────────────────┐
│  数据库          │ ← 最后的数据源
│  (Database)      │
└─────────────────┘
```

### 5.2 完整的缓存服务实现


```java
@Service
public class CacheService {
    
    @Autowired private RedisTemplate redisTemplate;
    @Autowired private BloomFilter bloomFilter;  
    @Autowired private RateLimiter rateLimiter;
    
    public <T> T getData(String key, Class<T> clazz, Supplier<T> dataLoader) {
        // 第1层：限流检查
        if (!rateLimiter.isAllowed("api:" + key, 1000, 60)) {
            throw new RuntimeException("请求过于频繁");
        }
        
        // 第2层：布隆过滤器检查（如果适用）
        if (bloomFilter != null && !bloomFilter.mightContain(key)) {
            return null;
        }
        
        // 第3层：缓存查询
        T cached = getFromCache(key, clazz);
        if (cached != null) {
            return cached;
        }
        
        // 第4层：互斥锁保护的数据库查询
        String lockKey = "lock:" + key;
        if (tryLock(lockKey, 5)) {
            try {
                // 再次检查缓存
                cached = getFromCache(key, clazz);
                if (cached != null) {
                    return cached;
                }
                
                // 查询数据库
                T data = dataLoader.get();
                
                // 更新缓存（随机过期时间）
                if (data != null) {
                    setCacheWithRandomExpire(key, data, 1800);
                } else {
                    // 空值缓存
                    setCacheWithRandomExpire(key, "NULL", 300);
                }
                
                return data;
            } finally {
                releaseLock(lockKey);
            }
        } else {
            // 获取锁失败，稍等重试
            Thread.sleep(100);
            return getFromCache(key, clazz);  // 可能其他线程已更新缓存
        }
    }
}
```

### 5.3 监控和告警


**关键监控指标**
```bash
# 缓存命中率
127.0.0.1:6379> info stats
keyspace_hits:8000      # 缓存命中次数
keyspace_misses:2000    # 缓存未命中次数
# 命中率 = 8000/(8000+2000) = 80%

# 连接数监控  
connected_clients:100   # 当前连接数
max_clients:10000      # 最大连接数

# 内存使用监控
used_memory:104857600   # 已使用内存
maxmemory:1073741824   # 最大内存限制
```

**告警规则设置**
```
🔴 紧急告警：
• 缓存命中率 < 50%
• Redis内存使用率 > 90%  
• 连接数 > 8000

🟡 警告提醒：
• 缓存命中率 < 80%
• Redis内存使用率 > 70%
• 连接数 > 5000
```

---

## 6. 📋 核心要点总结


### 6.1 三大问题核心特征


```
🕳️ 缓存穿透：查不存在的数据，像钻空子
💥 缓存击穿：热点数据失效，像爆破点  
❄️ 缓存雪崩：大量数据失效，像雪崩灾难
```

### 6.2 解决方案选择指南


**缓存穿透解决方案选择**
```
数据相对稳定 + 内存敏感 → 布隆过滤器
数据变化频繁 + 准确性要求高 → 空值缓存  
超高并发场景 → 布隆过滤器 + 空值缓存组合
```

**缓存击穿解决方案选择**  
```
一致性要求高 → 互斥锁方案
性能要求极高 → 逻辑过期方案
简单易实现 → 互斥锁方案
```

**缓存雪崩解决方案组合**
```
预防为主：
• 过期时间随机化（必选）
• Redis集群部署（推荐）
• 限流机制（必要）

应急处理：
• 服务降级（必选）
• 数据库连接池保护（必选）  
• 监控告警（必选）
```

### 6.3 最佳实践总结


**📊 生产环境配置建议**

```java
// 推荐的缓存配置
@Configuration
public class CacheConfig {
    
    // 缓存过期时间配置
    public static final int CACHE_EXPIRE_SECONDS = 1800;  // 30分钟基础时间
    public static final int RANDOM_EXPIRE_RANGE = 600;    // 10分钟随机范围
    public static final int NULL_CACHE_EXPIRE = 300;      // 空值缓存5分钟
    
    // 互斥锁配置
    public static final int LOCK_EXPIRE_SECONDS = 10;     // 锁10秒超时
    public static final int LOCK_WAIT_MILLIS = 50;        // 等待50毫秒重试
    
    // 限流配置
    public static final int MAX_QPS_PER_USER = 100;       // 每用户每分钟100次
    public static final int RATE_LIMIT_WINDOW = 60;       // 限流时间窗口60秒
}
```

**🔧 运维监控要点**
```
日常监控：
• 缓存命中率：目标 > 80%
• 响应时间：目标 < 100ms
• Redis内存使用：目标 < 70%
• 数据库连接数：目标 < 80%

异常处理：
• 缓存穿透：布隆过滤器拦截率
• 缓存击穿：互斥锁获取成功率  
• 缓存雪崩：数据库连接数突增告警
```

**🧠 记忆要点**
```
缓存穿透像钻空子，布隆过滤堵漏洞
缓存击穿像爆破点，互斥加锁保平安  
缓存雪崩像灾难，错峰限流是关键
三大问题要预防，监控告警不能忘
```

**核心理念**：
- 缓存问题的本质都是"大量请求同时访问数据库"
- 解决思路都是"避免或减少对数据库的直接冲击"  
- 生产环境要多层防护，不能依赖单一解决方案
- 监控和预警比事后补救更重要