---
title: 13、Session共享与计数器实战
---
## 📚 目录

1. [Session共享基础概念](#1-Session共享基础概念)
2. [登录Session管理实战](#2-登录Session管理实战)
3. [点赞计数器实现](#3-点赞计数器实现)
4. [滑动窗口限流机制](#4-滑动窗口限流机制)
5. [Session与计数器最佳实践](#5-Session与计数器最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔐 Session共享基础概念


### 1.1 什么是Session共享


**传统Session问题**：
```
单服务器架构：
用户 → 服务器A → 本地内存存储Session
问题：用户只能访问这一台服务器

多服务器架构问题：
用户 → 负载均衡器 → 服务器A（有Session）
用户 → 负载均衡器 → 服务器B（没Session）← 登录失效！
```

**Redis Session共享解决方案**：
```
多服务器 + Redis共享架构：
     用户请求
        ↓
    负载均衡器
    ↙    ↓    ↘
服务器A  服务器B  服务器C
    ↘    ↓    ↙
      Redis服务器
   （统一Session存储）
```

### 1.2 Session共享的核心价值


**解决的问题**：
- **会话一致性**：用户在任何服务器上都能保持登录状态
- **系统扩展性**：可以随时增减服务器而不影响用户体验  
- **故障恢复**：单台服务器故障不会导致用户掉线

**实际业务场景**：
```
电商网站：
- 用户在服务器A登录
- 浏览商品时负载均衡分配到服务器B
- 服务器B从Redis获取Session，用户状态正常
- 下单时分配到服务器C，仍然保持登录状态
```

---

## 2. 👤 登录Session管理实战


### 2.1 Session数据结构设计


**Session信息存储**：
```bash
# Session Key设计：session:用户ID:随机token
# 或者：session:随机sessionId

# 方案1：以用户ID为主键
HMSET session:user:1001
  session_id "abc123xyz"
  user_id 1001
  username "zhangsan"  
  login_time "2025-01-21 10:00:00"
  last_active "2025-01-21 10:30:00"
  ip_address "192.168.1.100"
  user_agent "Chrome/120.0"
  permissions "read,write,admin"

# 方案2：以SessionID为主键  
HMSET session:abc123xyz
  user_id 1001
  username "zhangsan"
  role "admin"
  login_time "2025-01-21 10:00:00"
  expire_time "2025-01-21 18:00:00"
```

### 2.2 登录Session创建流程


**登录验证与Session创建**：
```javascript
// 用户登录逻辑
async function userLogin(username, password) {
  // 1. 验证用户名密码
  const user = await validateUser(username, password);
  if (!user) {
    throw new Error('用户名或密码错误');
  }
  
  // 2. 生成唯一的SessionID
  const sessionId = generateUniqueId(); // 如: "sess_abc123xyz789"
  
  // 3. 在Redis中创建Session
  const sessionData = {
    user_id: user.id,
    username: user.username,
    role: user.role,
    login_time: new Date().toISOString(),
    last_active: new Date().toISOString(),
    ip_address: request.ip
  };
  
  // 4. 存储Session到Redis（设置过期时间）
  await redis.hmset(`session:${sessionId}`, sessionData);
  await redis.expire(`session:${sessionId}`, 7200); // 2小时过期
  
  // 5. 返回SessionID给客户端
  return sessionId;
}
```

### 2.3 Session验证与使用


**请求验证中间件**：
```javascript
// Session验证中间件
async function validateSession(request, response, next) {
  // 1. 从请求中获取SessionID
  const sessionId = request.headers['session-token'] || 
                   request.cookies['session_id'];
  
  if (!sessionId) {
    return response.status(401).json({error: '未登录'});
  }
  
  // 2. 从Redis检查Session是否存在
  const sessionExists = await redis.exists(`session:${sessionId}`);
  if (!sessionExists) {
    return response.status(401).json({error: 'Session已过期'});
  }
  
  // 3. 获取Session详细信息
  const sessionData = await redis.hgetall(`session:${sessionId}`);
  
  // 4. 更新最后活动时间
  await redis.hset(`session:${sessionId}`, 'last_active', new Date().toISOString());
  await redis.expire(`session:${sessionId}`, 7200); // 刷新过期时间
  
  // 5. 将用户信息添加到请求对象
  request.user = {
    id: sessionData.user_id,
    username: sessionData.username,
    role: sessionData.role
  };
  
  next();
}
```

### 2.4 Session销毁与登出


**安全登出处理**：
```javascript
// 用户登出逻辑
async function userLogout(sessionId) {
  // 1. 记录登出时间（可选，用于审计）
  await redis.hset(`session:${sessionId}`, 'logout_time', new Date().toISOString());
  
  // 2. 删除Session
  await redis.del(`session:${sessionId}`);
  
  // 3. 记录登出日志
  console.log(`用户Session ${sessionId} 已安全登出`);
  
  return true;
}

// 批量清理过期Session（定时任务）
async function cleanupExpiredSessions() {
  const pattern = 'session:*';
  const sessions = await redis.keys(pattern);
  
  for (const sessionKey of sessions) {
    const lastActive = await redis.hget(sessionKey, 'last_active');
    const lastTime = new Date(lastActive);
    const now = new Date();
    
    // 超过24小时未活动的Session
    if (now - lastTime > 24 * 60 * 60 * 1000) {
      await redis.del(sessionKey);
      console.log(`清理过期Session: ${sessionKey}`);
    }
  }
}
```

---

## 3. 👍 点赞计数器实现


### 3.1 点赞计数器基础概念


**点赞系统需求分析**：
- **计数功能**：统计文章、视频等的点赞总数
- **防重复**：同一用户不能重复点赞
- **高并发**：支持大量用户同时点赞
- **实时性**：点赞数实时更新显示

### 3.2 简单计数器实现


**基础点赞计数**：
```javascript
// 文章点赞功能
async function likeArticle(articleId, userId) {
  // 1. 检查用户是否已经点赞
  const likedKey = `article:${articleId}:liked_users`;
  const hasLiked = await redis.sismember(likedKey, userId);
  
  if (hasLiked) {
    return {success: false, message: '已经点赞过了'};
  }
  
  // 2. 记录用户点赞
  await redis.sadd(likedKey, userId);
  
  // 3. 增加点赞计数
  const countKey = `article:${articleId}:like_count`;
  const newCount = await redis.incr(countKey);
  
  // 4. 设置过期时间（可选）
  await redis.expire(likedKey, 86400 * 30); // 30天
  await redis.expire(countKey, 86400 * 30);
  
  return {success: true, count: newCount};
}

// 取消点赞
async function unlikeArticle(articleId, userId) {
  const likedKey = `article:${articleId}:liked_users`;
  const hasLiked = await redis.sismember(likedKey, userId);
  
  if (!hasLiked) {
    return {success: false, message: '还没有点赞'};
  }
  
  // 移除用户点赞记录
  await redis.srem(likedKey, userId);
  
  // 减少点赞计数
  const countKey = `article:${articleId}:like_count`;
  const newCount = await redis.decr(countKey);
  
  return {success: true, count: newCount};
}
```

### 3.3 Hash结构的点赞计数器


**使用Hash统一管理**：
```javascript
// 使用Hash存储文章的所有统计数据
async function initArticleStats(articleId) {
  const statsKey = `article:${articleId}:stats`;
  
  // 初始化文章统计数据
  await redis.hmset(statsKey, {
    like_count: 0,
    view_count: 0,  
    share_count: 0,
    comment_count: 0,
    created_time: new Date().toISOString()
  });
  
  // 设置过期时间
  await redis.expire(statsKey, 86400 * 365); // 1年
}

// Hash版本的点赞功能
async function likeArticleWithHash(articleId, userId) {
  const likedKey = `article:${articleId}:liked_users`;
  const statsKey = `article:${articleId}:stats`;
  
  // 检查是否已点赞
  const hasLiked = await redis.sismember(likedKey, userId);
  if (hasLiked) {
    return {success: false, message: '已经点赞过了'};
  }
  
  // 使用Redis事务保证一致性
  const multi = redis.multi();
  multi.sadd(likedKey, userId);              // 记录点赞用户
  multi.hincrby(statsKey, 'like_count', 1);  // 增加点赞数
  multi.hset(statsKey, 'last_like_time', new Date().toISOString());
  
  const results = await multi.exec();
  const newLikeCount = results[1][1]; // 获取新的点赞数
  
  return {success: true, count: newLikeCount};
}

// 获取文章完整统计信息
async function getArticleStats(articleId) {
  const statsKey = `article:${articleId}:stats`;
  const stats = await redis.hgetall(statsKey);
  
  return {
    likeCount: parseInt(stats.like_count) || 0,
    viewCount: parseInt(stats.view_count) || 0,
    shareCount: parseInt(stats.share_count) || 0,
    commentCount: parseInt(stats.comment_count) || 0
  };
}
```

### 3.4 批量点赞统计


**热门内容排行**：
```javascript
// 获取热门文章（按点赞数排序）
async function getPopularArticles(limit = 10) {
  const articles = [];
  
  // 1. 获取所有文章的统计Key
  const pattern = 'article:*:stats';
  const keys = await redis.keys(pattern);
  
  // 2. 批量获取点赞数
  for (const key of keys) {
    const likeCount = await redis.hget(key, 'like_count');
    const articleId = key.split(':')[1]; // 从key中提取文章ID
    
    articles.push({
      article_id: articleId,
      like_count: parseInt(likeCount) || 0
    });
  }
  
  // 3. 排序并返回前N个
  return articles
    .sort((a, b) => b.like_count - a.like_count)
    .slice(0, limit);
}

// 实时点赞数更新（WebSocket推送）
async function broadcastLikeUpdate(articleId) {
  const statsKey = `article:${articleId}:stats`;
  const currentCount = await redis.hget(statsKey, 'like_count');
  
  // 推送给所有在线用户
  websocket.broadcast({
    type: 'like_update',
    article_id: articleId,
    new_count: parseInt(currentCount)
  });
}
```

---

## 4. 🚦 滑动窗口限流机制


### 4.1 限流的基本概念


**为什么需要限流**：
- **防止滥用**：避免恶意用户频繁操作
- **保护系统**：防止系统被大量请求压垮
- **公平使用**：确保资源被合理分配

**滑动窗口原理**：
```
传统固定窗口问题：
时间: 0-60秒允许100次请求，61-120秒重新计算
问题：在59秒发99次，61秒发99次，实际2秒内发198次！

滑动窗口解决：
任意60秒内都不超过100次请求
     滑动窗口（60秒）
     ┌─────────────┐
时间轴: ─────────────────────→
     每秒都在检查过去60秒的请求数
```

### 4.2 滑动窗口限流实现


**基于Sorted Set的滑动窗口**：
```javascript
// 滑动窗口限流器
class SlidingWindowLimiter {
  constructor(redis, windowSize = 60, maxRequests = 100) {
    this.redis = redis;
    this.windowSize = windowSize; // 窗口大小（秒）
    this.maxRequests = maxRequests; // 最大请求数
  }
  
  // 检查是否允许请求
  async isAllowed(userId, action = 'default') {
    const key = `limiter:${userId}:${action}`;
    const now = Date.now();
    const windowStart = now - (this.windowSize * 1000);
    
    // 1. 清理过期的请求记录
    await this.redis.zremrangebyscore(key, 0, windowStart);
    
    // 2. 检查当前窗口内的请求数
    const currentRequests = await this.redis.zcard(key);
    
    if (currentRequests >= this.maxRequests) {
      return {
        allowed: false,
        remaining: 0,
        resetTime: windowStart + (this.windowSize * 1000)
      };
    }
    
    // 3. 记录本次请求
    await this.redis.zadd(key, now, `${now}-${Math.random()}`);
    
    // 4. 设置Key过期时间
    await this.redis.expire(key, this.windowSize + 1);
    
    return {
      allowed: true,
      remaining: this.maxRequests - currentRequests - 1
    };
  }
}

// 使用示例
const limiter = new SlidingWindowLimiter(redis, 60, 10); // 60秒内最多10次

// API接口中的使用
async function handleLikeRequest(articleId, userId) {
  // 检查点赞限流
  const limitResult = await limiter.isAllowed(userId, 'like');
  
  if (!limitResult.allowed) {
    return {
      success: false, 
      message: '点赞太频繁，请稍后再试',
      remaining: limitResult.remaining
    };
  }
  
  // 执行点赞逻辑
  return await likeArticle(articleId, userId);
}
```

### 4.3 多级限流策略


**不同粒度的限流控制**：
```javascript
// 多级限流配置
const limitConfigs = {
  // 全局限流：防止系统过载
  global: {windowSize: 60, maxRequests: 10000},
  
  // 用户限流：防止单用户滥用  
  user: {windowSize: 60, maxRequests: 100},
  
  // IP限流：防止恶意攻击
  ip: {windowSize: 60, maxRequests: 200},
  
  // 接口限流：不同接口不同限制
  api: {
    'like': {windowSize: 60, maxRequests: 10},      // 点赞：1分钟10次
    'comment': {windowSize: 60, maxRequests: 5},    // 评论：1分钟5次  
    'upload': {windowSize: 3600, maxRequests: 20}   // 上传：1小时20次
  }
};

// 综合限流检查
async function checkMultipleLimits(userId, userIP, action) {
  const checks = [
    limiter.isAllowed('global', 'global'),           // 全局限流
    limiter.isAllowed(userId, action),               // 用户限流
    limiter.isAllowed(`ip:${userIP}`, action),      // IP限流
  ];
  
  const results = await Promise.all(checks);
  
  // 任何一个限流触发都拒绝请求
  for (const result of results) {
    if (!result.allowed) {
      return result;
    }
  }
  
  return {allowed: true, remaining: Math.min(...results.map(r => r.remaining))};
}
```

### 4.4 高级限流场景


**动态限流调整**：
```javascript
// 根据系统负载动态调整限流参数
async function getAdaptiveLimitConfig(action) {
  // 获取系统当前负载
  const systemLoad = await getSystemLoad(); // CPU、内存、连接数等
  
  let multiplier = 1;
  if (systemLoad > 0.8) {
    multiplier = 0.5; // 高负载时减少限流阈值
  } else if (systemLoad < 0.3) {  
    multiplier = 1.5; // 低负载时放宽限流
  }
  
  const baseConfig = limitConfigs.api[action];
  return {
    windowSize: baseConfig.windowSize,
    maxRequests: Math.floor(baseConfig.maxRequests * multiplier)
  };
}

// VIP用户特殊限流
async function getVipLimitConfig(userId, action) {
  const userLevel = await redis.hget(`user:${userId}`, 'level');
  
  const vipMultiplier = {
    'normal': 1,
    'vip': 3,      // VIP用户3倍限制
    'svip': 5      // 超级VIP 5倍限制  
  };
  
  const baseConfig = limitConfigs.api[action];
  const multiplier = vipMultiplier[userLevel] || 1;
  
  return {
    windowSize: baseConfig.windowSize,
    maxRequests: baseConfig.maxRequests * multiplier
  };
}
```

---

## 5. 🎯 Session与计数器最佳实践


### 5.1 Session管理最佳实践


**Session设计原则**：

| 设计方面 | 推荐做法 | 避免问题 | 实际示例 |
|---------|---------|---------|---------|
| **Key命名** | `session:{type}:{id}` | 避免冲突和混乱 | `session:user:1001` |
| **数据存储** | 只存必要信息 | 避免Session过大 | 用户ID、角色、过期时间 |
| **过期时间** | 根据业务设置合理TTL | 内存泄漏 | 2-8小时，活跃刷新 |
| **安全性** | SessionID足够随机 | 被猜测攻击 | UUID + 时间戳 + 随机数 |

**Session数据结构建议**：
```javascript
// 推荐的Session结构
const sessionData = {
  // 核心信息（必须）
  user_id: 1001,
  username: 'zhangsan',
  role: 'user',
  
  // 时间信息（推荐）
  login_time: '2025-01-21T10:00:00Z',
  last_active: '2025-01-21T10:30:00Z',
  
  // 安全信息（可选）  
  ip_address: '192.168.1.100',
  user_agent: 'Chrome/120.0',
  
  // 业务信息（按需）
  permissions: 'read,write',
  preferences: 'theme:dark'
};

// 避免存储的信息
❌ 大对象数据
❌ 频繁变化的数据  
❌ 敏感密码信息
❌ 可以重新计算的数据
```

### 5.2 计数器设计最佳实践


**计数器类型选择**：

```bash
# 简单计数：只需要数字
INCR article:1001:view_count

# 防重复计数：需要记录操作用户
SADD article:1001:liked_users 1001    # 记录点赞用户
SCARD article:1001:liked_users        # 获取点赞数

# 统计分析：需要详细信息
HMSET article:1001:stats 
  total_views 1500
  today_views 50
  like_count 89
  avg_rating 4.5
```

**高并发计数器**：
```javascript
// 分段计数器：减少竞争
async function incrementDistributedCounter(key, increment = 1) {
  // 随机选择一个分段
  const segment = Math.floor(Math.random() * 10);
  const segmentKey = `${key}:segment:${segment}`;
  
  // 增加分段计数
  await redis.incrby(segmentKey, increment);
  
  return true;
}

// 获取分布式计数器总值
async function getDistributedCount(key) {
  const pattern = `${key}:segment:*`;
  const keys = await redis.keys(pattern);
  
  let total = 0;
  for (const segmentKey of keys) {
    const count = await redis.get(segmentKey);
    total += parseInt(count) || 0;
  }
  
  return total;
}
```

### 5.3 性能优化策略


**批量操作优化**：
```javascript
// 批量获取多个文章的点赞数
async function getBatchLikeCounts(articleIds) {
  const multi = redis.multi();
  
  // 批量添加获取命令
  articleIds.forEach(id => {
    multi.hget(`article:${id}:stats`, 'like_count');
  });
  
  const results = await multi.exec();
  
  // 组装返回结果
  const counts = {};
  articleIds.forEach((id, index) => {
    counts[id] = parseInt(results[index][1]) || 0;
  });
  
  return counts;
}

// 批量Session验证
async function validateBatchSessions(sessionIds) {
  const multi = redis.multi();
  
  sessionIds.forEach(sessionId => {
    multi.exists(`session:${sessionId}`);
  });
  
  const results = await multi.exec();
  
  return sessionIds.map((sessionId, index) => ({
    sessionId,
    valid: results[index][1] === 1
  }));
}
```

### 5.4 数据一致性保障


**Redis事务保证一致性**：
```javascript
// 原子性点赞操作
async function atomicLikeOperation(articleId, userId) {
  const likedKey = `article:${articleId}:liked_users`;
  const statsKey = `article:${articleId}:stats`;
  
  // 使用WATCH监控关键Key
  await redis.watch(likedKey, statsKey);
  
  // 检查当前状态
  const hasLiked = await redis.sismember(likedKey, userId);
  if (hasLiked) {
    await redis.unwatch();
    return {success: false, message: '已经点赞'};
  }
  
  // 执行事务
  const multi = redis.multi();
  multi.sadd(likedKey, userId);
  multi.hincrby(statsKey, 'like_count', 1);
  multi.hset(statsKey, 'last_update', new Date().toISOString());
  
  const results = await multi.exec();
  
  if (results === null) {
    // 事务被取消，重试
    return await atomicLikeOperation(articleId, userId);
  }
  
  return {success: true, count: results[1][1]};
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 Session共享：多服务器环境下统一存储用户会话状态
🔸 登录管理：Session创建、验证、刷新、销毁的完整流程
🔸 点赞计数：防重复的计数器实现，支持高并发场景
🔸 滑动窗口：基于时间窗口的限流机制，防止系统过载
🔸 数据一致性：使用Redis事务保证操作的原子性
```

### 6.2 关键应用场景


**🔹 Session共享典型应用**：
```
✅ 多服务器Web应用
✅ 微服务架构下的用户认证
✅ 负载均衡环境的会话保持
✅ 分布式系统的状态同步
```

**🔹 计数器应用场景**：
```
✅ 社交媒体：点赞、评论、转发计数
✅ 电商系统：商品浏览量、购买次数
✅ 内容平台：文章阅读数、视频播放量  
✅ 游戏系统：积分、排行榜、成就统计
```

**🔹 限流应用场景**：
```
✅ API接口保护：防止接口被恶意调用
✅ 用户行为限制：防止垃圾评论、恶意点赞
✅ 系统资源保护：控制并发访问量
✅ 业务规则实现：VIP用户更高限制
```

### 6.3 技术选择指南


| 功能需求 | 推荐方案 | Redis数据类型 | 关键操作 |
|---------|---------|-------------|----------|
| **Session存储** | Hash结构 | `Hash` | `HMSET`, `HGET`, `EXPIRE` |
| **简单计数** | 数字递增 | `String` | `INCR`, `DECR` |
| **防重复计数** | 集合+计数 | `Set + String` | `SADD`, `SISMEMBER`, `INCR` |
| **滑动窗口** | 有序集合 | `Sorted Set` | `ZADD`, `ZREMRANGEBYSCORE` |
| **批量操作** | 管道事务 | `Multi` | `MULTI`, `EXEC` |

### 6.4 实践要点


**🔧 Session管理要点**：
- **安全第一**：SessionID必须足够随机，不可预测
- **及时清理**：设置合理的过期时间，定期清理无效Session
- **信息精简**：只存储必要信息，避免Session过大
- **活跃刷新**：用户活跃时延长Session有效期

**🔧 计数器设计要点**：
- **原子操作**：使用Redis事务保证计数准确性
- **防重复机制**：结合Set记录操作用户，避免重复计数  
- **性能考虑**：高并发时使用分段计数器减少竞争
- **数据备份**：重要计数数据要有持久化备份

**🔧 限流策略要点**：
- **合理阈值**：根据系统能力和用户体验设置限流值
- **多维限流**：同时考虑用户、IP、接口等多个维度
- **优雅降级**：限流触发时给出友好提示而非直接拒绝
- **动态调整**：根据系统负载和业务需求动态调整限流参数

**核心记忆**：
- Session像身份证，多服务器环境下证明你是谁
- 计数器要防刷，集合记录数字统计不重复
- 滑动窗口限流量，保护系统不过载
- Redis事务保一致，批量操作效率高