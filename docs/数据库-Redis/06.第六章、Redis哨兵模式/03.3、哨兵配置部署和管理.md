---
title: 3、哨兵配置部署和管理
---
## 📚 目录

1. [哨兵配置文件详解](#1-哨兵配置文件详解)
2. [哨兵集群部署](#2-哨兵集群部署)
3. [动态配置管理](#3-动态配置管理)
4. [运维最佳实践](#4-运维最佳实践)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 📝 哨兵配置文件详解


### 1.1 sentinel.conf基本结构


**什么是sentinel.conf**
```
sentinel.conf是Redis哨兵的配置文件，就像是哨兵的"作业指导书"
- 告诉哨兵要监控哪台Redis主服务器
- 设定什么情况下判断主服务器故障
- 配置故障转移的各种参数
- 指定出现问题时要执行的通知脚本
```

**📋 配置文件基本结构**
```bash
# 哨兵端口配置
port 26379

# 哨兵工作目录
dir /var/lib/redis-sentinel

# 监控主节点配置
sentinel monitor mymaster 127.0.0.1 6379 2

# 故障判定时间
sentinel down-after-milliseconds mymaster 30000

# 故障转移超时时间
sentinel failover-timeout mymaster 180000

# 同步从节点限制
sentinel parallel-syncs mymaster 1
```

### 1.2 监控主节点配置详解


**核心配置：`sentinel monitor`**
```bash
sentinel monitor <master-name> <ip> <port> <quorum>
sentinel monitor mymaster 192.168.1.100 6379 2
```

**参数含义解释**：
- **master-name**：给主节点起个名字，比如"mymaster"，方便管理
- **ip/port**：主Redis服务器的地址和端口
- **quorum**：**票数阈值** - 至少需要几个哨兵同意才能判定主节点故障

```
quorum参数的实际含义：
假设有3个哨兵，quorum=2

情况1：只有1个哨兵认为主节点故障
→ 1 < 2，不满足条件，不会进行故障转移

情况2：有2个哨兵认为主节点故障  
→ 2 = 2，满足条件，开始故障转移流程

这样设计的好处：避免网络分区时的误判
```

### 1.3 故障转移参数设置


**故障判定时间：`down-after-milliseconds`**
```bash
sentinel down-after-milliseconds mymaster 30000
```
**通俗解释**：哨兵ping主节点超过30秒没响应，就认为它"主观下线"了

```
设置原则：
🔸 设置过短：网络抖动可能误判
🔸 设置过长：真正故障时恢复太慢
🔸 推荐值：15000-60000毫秒（15-60秒）
```

**故障转移超时：`failover-timeout`**
```bash
sentinel failover-timeout mymaster 180000
```
**通俗解释**：故障转移过程如果超过3分钟还没完成，就认为转移失败

**并行同步限制：`parallel-syncs`**
```bash
sentinel parallel-syncs mymaster 1
```
**通俗解释**：新主节点选出后，同时最多允许1个从节点进行数据同步

```
为什么要限制并行同步：
- 如果所有从节点同时同步，会给新主节点巨大压力
- 限制为1，确保服务稳定性
- 可以根据硬件性能适当调整（1-3个）
```

### 1.4 通知脚本配置


**故障通知脚本**
```bash
# 主节点状态变化时执行的脚本
sentinel notification-script mymaster /opt/redis/notify.sh

# 故障转移完成后执行的脚本  
sentinel client-reconfig-script mymaster /opt/redis/reconfig.sh
```

**📧 通知脚本示例**
```bash
#!/bin/bash
# /opt/redis/notify.sh

EVENT_TYPE=$1    # 事件类型
MASTER_NAME=$2   # 主节点名称
STATE_FROM=$3    # 原状态
STATE_TO=$4      # 新状态
ADDRESS=$5       # 节点地址

# 发送邮件通知
echo "Redis主节点 $MASTER_NAME 状态变化: $STATE_FROM -> $STATE_TO" | \
mail -s "Redis告警" admin@company.com

# 记录日志
echo "$(date): $EVENT_TYPE $MASTER_NAME $STATE_FROM $STATE_TO $ADDRESS" >> /var/log/redis-sentinel.log
```

**🔄 重配置脚本示例**
```bash
#!/bin/bash
# /opt/redis/reconfig.sh

MASTER_NAME=$1     # 主节点名称
ROLE=$2           # 节点角色
STATE=$3          # 状态
MASTER_IP=$4      # 新主节点IP
MASTER_PORT=$5    # 新主节点端口

# 更新应用配置文件
sed -i "s/redis.host=.*/redis.host=$MASTER_IP/" /app/config/redis.properties
sed -i "s/redis.port=.*/redis.port=$MASTER_PORT/" /app/config/redis.properties

# 重启应用服务
systemctl reload myapp
```

---

## 2. 🏗️ 哨兵集群部署


### 2.1 哨兵节点部署规划


**📊 部署架构设计**
```
推荐架构：至少3个哨兵节点（奇数个）

服务器1: 192.168.1.101  →  Sentinel1 + Redis主节点
服务器2: 192.168.1.102  →  Sentinel2 + Redis从节点
服务器3: 192.168.1.103  →  Sentinel3 + Redis从节点

为什么需要奇数个哨兵：
- 避免"脑裂"问题：网络分区时能选出明确的多数派
- 容错能力：3个哨兵可以容忍1个故障，5个可以容忍2个故障
```

**🎯 哨兵部署原则**
```
分布式部署：
✅ 哨兵分布在不同物理机器上
✅ 避免单点故障影响整个监控系统
✅ 网络分区时仍能正常工作

独立运行：
✅ 哨兵进程独立于Redis数据节点
✅ 使用独立的端口（默认26379）
✅ 独立的配置文件和日志
```

### 2.2 配置文件分发管理


**🗂️ 配置文件模板**
```bash
# /etc/redis/sentinel-template.conf

# 基础配置
port 26379
dir /var/lib/redis-sentinel
pidfile /var/run/redis-sentinel.pid
logfile /var/log/redis/sentinel.log
loglevel notice

# 监控主节点（所有哨兵配置相同）
sentinel monitor mymaster ${MASTER_IP} 6379 2
sentinel down-after-milliseconds mymaster 30000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1

# 认证配置
sentinel auth-pass mymaster ${REDIS_PASSWORD}

# 通知脚本
sentinel notification-script mymaster /opt/redis/scripts/notify.sh
sentinel client-reconfig-script mymaster /opt/redis/scripts/reconfig.sh
```

**📦 批量部署脚本**
```bash
#!/bin/bash
# deploy-sentinel.sh

SERVERS=("192.168.1.101" "192.168.1.102" "192.168.1.103")
MASTER_IP="192.168.1.101"
REDIS_PASSWORD="your_password"

for server in "${SERVERS[@]}"; do
    echo "部署哨兵到服务器: $server"
    
    # 1. 创建配置文件
    sed -e "s/\${MASTER_IP}/$MASTER_IP/g" \
        -e "s/\${REDIS_PASSWORD}/$REDIS_PASSWORD/g" \
        sentinel-template.conf > sentinel-$server.conf
    
    # 2. 上传配置文件
    scp sentinel-$server.conf root@$server:/etc/redis/sentinel.conf
    
    # 3. 创建必要目录
    ssh root@$server "mkdir -p /var/lib/redis-sentinel /var/log/redis /opt/redis/scripts"
    
    # 4. 上传脚本文件
    scp scripts/* root@$server:/opt/redis/scripts/
    
    echo "✅ 服务器 $server 部署完成"
done
```

### 2.3 哨兵服务启动流程


**🚀 启动步骤详解**
```bash
# 1. 启动Redis主从节点（确保主从复制正常）
redis-server /etc/redis/redis-master.conf    # 主节点
redis-server /etc/redis/redis-slave.conf     # 从节点

# 2. 启动哨兵节点（按顺序启动）
redis-sentinel /etc/redis/sentinel.conf

# 3. 验证哨兵状态
redis-cli -p 26379 sentinel masters          # 查看监控的主节点
redis-cli -p 26379 sentinel slaves mymaster  # 查看从节点
redis-cli -p 26379 sentinel sentinels mymaster # 查看其他哨兵
```

**📋 启动检查清单**
```
启动前检查：
☐ Redis主从复制是否正常工作
☐ 哨兵配置文件语法是否正确
☐ 网络连通性是否正常
☐ 必要的目录和权限是否创建

启动后验证：
☐ 哨兵能否发现主节点
☐ 哨兵能否发现从节点
☐ 哨兵之间能否相互发现
☐ 故障转移流程是否能正常触发
```

### 2.4 哨兵集群初始化


**🤝 哨兵自动发现机制**
```
发现过程：
1. 第一个哨兵启动 → 连接到Redis主节点
2. 通过Redis的发布订阅功能发布自己的信息
3. 其他哨兵启动后也连接主节点，订阅相同频道
4. 所有哨兵通过这个机制互相发现和通信

Redis内部的发布订阅频道：
- __sentinel__:hello  # 哨兵之间的心跳通信
```

**🔄 初始化状态流程图**
```
哨兵1启动                    哨兵2启动                    哨兵3启动
    |                          |                          |
    ↓                          ↓                          ↓
连接Redis主节点            连接Redis主节点            连接Redis主节点
    |                          |                          |
    ↓                          ↓                          ↓
发布自己的信息              发布自己的信息              发布自己的信息
    |                          |                          |
    ↓                          ↓                          ↓
       ←------------- 相互发现，建立通信 -----------→
                              |
                              ↓
                        形成哨兵集群
```

---

## 3. ⚙️ 动态配置管理


### 3.1 运行时配置修改


**什么是动态配置**
```
传统方式：修改配置文件 → 重启服务 → 配置生效
动态配置：运行时直接修改 → 立即生效 → 自动持久化

优势：
- 无需重启服务
- 配置立即生效
- 减少服务中断时间
```

**🔧 常用动态配置命令**
```bash
# 连接哨兵
redis-cli -p 26379

# 修改故障判定时间
SENTINEL SET mymaster down-after-milliseconds 60000

# 修改故障转移超时时间  
SENTINEL SET mymaster failover-timeout 300000

# 修改并行同步数量
SENTINEL SET mymaster parallel-syncs 2

# 查看当前配置
SENTINEL CONFIG GET mymaster
```

### 3.2 监控目标动态添加


**📍 添加新的监控目标**
```bash
# 动态添加新的主节点监控
SENTINEL MONITOR newmaster 192.168.1.200 6379 2

# 为新主节点设置参数
SENTINEL SET newmaster down-after-milliseconds 30000
SENTINEL SET newmaster failover-timeout 180000
SENTINEL SET newmaster parallel-syncs 1

# 如果有密码认证
SENTINEL SET newmaster auth-pass your_password
```

**🗑️ 移除监控目标**
```bash
# 停止监控某个主节点
SENTINEL REMOVE mymaster

# 注意：移除后相关的从节点监控也会自动移除
```

### 3.3 参数在线调优


**⚡ 常见调优场景**

| 场景描述 | 需要调整的参数 | 调整建议 |
|---------|---------------|----------|
| **网络延迟较高** | `down-after-milliseconds` | 增加到45000-60000 |
| **主节点性能强** | `parallel-syncs` | 增加到2-3 |
| **故障转移太慢** | `failover-timeout` | 根据实际情况减少 |
| **误报频繁** | `down-after-milliseconds` | 适当增加判定时间 |

**🎛️ 调优示例**
```bash
# 场景：网络环境不稳定，经常误报
# 解决：增加故障判定时间
SENTINEL SET mymaster down-after-milliseconds 45000

# 场景：主节点性能很好，希望加快从节点同步
# 解决：增加并行同步数量
SENTINEL SET mymaster parallel-syncs 2

# 验证修改结果
SENTINEL CONFIG GET mymaster
```

### 3.4 配置持久化保存


**💾 自动持久化机制**
```
哨兵会自动将运行时的配置修改写回配置文件
- 动态添加的监控目标会追加到配置文件
- 修改的参数会更新配置文件中对应的值
- 重启哨兵时会读取更新后的配置
```

**📂 配置文件的变化示例**
```bash
# 运行前的配置文件
sentinel monitor mymaster 192.168.1.100 6379 2
sentinel down-after-milliseconds mymaster 30000

# 动态修改后，配置文件自动更新为：
sentinel monitor mymaster 192.168.1.100 6379 2
sentinel down-after-milliseconds mymaster 45000  # 自动更新
```

---

## 4. 🛡️ 运维最佳实践


### 4.1 哨兵部署最佳实践


**🏢 生产环境部署建议**
```
硬件部署：
✅ 至少3个哨兵节点（推荐5个）
✅ 哨兵分布在不同的物理机器
✅ 避免与Redis数据节点部署在同一台机器

网络规划：
✅ 哨兵之间网络延迟要低
✅ 哨兵到Redis节点网络要稳定
✅ 配置防火墙允许哨兵端口通信
```

**⚠️ 常见部署错误**
```
❌ 错误：所有哨兵部署在同一台机器
   影响：机器故障导致整个监控系统瘫痪

❌ 错误：quorum设置为哨兵总数
   影响：任何一个哨兵故障都无法进行故障转移

❌ 错误：down-after-milliseconds设置过短
   影响：网络抖动导致频繁误报和不必要的故障转移
```

### 4.2 配置管理策略


**📋 配置版本管理**
```bash
# 使用Git管理哨兵配置
cd /etc/redis
git init
git add sentinel.conf
git commit -m "初始哨兵配置"

# 配置修改后
git add .
git commit -m "调整故障判定时间为45秒"
```

**🔄 配置同步策略**
```
方案1：集中配置管理
- 使用Ansible、Puppet等工具
- 统一下发配置文件
- 确保所有哨兵配置一致

方案2：动态配置同步
- 在一个哨兵上修改配置
- 编写脚本同步到其他哨兵
- 确保集群配置的一致性
```

### 4.3 监控和告警


**📊 关键监控指标**
```bash
# 查看哨兵状态
redis-cli -p 26379 INFO sentinel

# 重要指标：
sentinel_masters:1                    # 监控的主节点数量
sentinel_running_scripts:0            # 正在运行的脚本数
sentinel_scripts_queue_length:0       # 脚本队列长度
master0:name=mymaster,status=ok       # 主节点状态
```

**🚨 告警规则设置**
```bash
# Prometheus + Grafana监控配置示例

# 哨兵节点存活告警
up{job="redis-sentinel"} == 0

# 主节点状态异常告警
redis_sentinel_master_status != 1

# 从节点数量异常告警
redis_sentinel_slaves != expected_slaves_count
```

### 4.4 故障排查指南


**🔍 常见问题诊断**
```
问题1：哨兵无法发现主节点
排查步骤：
1️⃣ 检查网络连通性：ping 主节点IP
2️⃣ 检查Redis主节点是否启动：redis-cli ping  
3️⃣ 检查配置文件中IP地址是否正确
4️⃣ 检查防火墙是否阻止连接

问题2：故障转移不触发
排查步骤：
1️⃣ 检查quorum设置是否合理
2️⃣ 查看有多少哨兵认为主节点故障
3️⃣ 检查哨兵日志中的错误信息
4️⃣ 验证哨兵之间能否正常通信
```

**📝 故障排查命令**
```bash
# 查看哨兵日志
tail -f /var/log/redis/sentinel.log

# 检查主节点状态
redis-cli -p 26379 sentinel masters

# 检查哨兵对主节点的判断
redis-cli -p 26379 sentinel is-master-down-by-addr 192.168.1.100 6379

# 手动触发故障转移（测试用）
redis-cli -p 26379 sentinel failover mymaster
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 哨兵配置文件：sentinel.conf是哨兵的"作业指导书"
🔸 监控配置：monitor命令定义监控目标和票数阈值
🔸 故障参数：down-after-milliseconds控制故障判定敏感度  
🔸 集群部署：至少3个哨兵，分布式部署避免单点故障
🔸 动态管理：支持运行时修改配置，无需重启服务
```

### 5.2 关键理解要点


**🔹 quorum参数的作用**
```
不是简单的"过半数"概念：
- quorum=2，表示至少2个哨兵同意才能故障转移
- 与哨兵总数无关，可以设置为任意合理值
- 设置原则：既要避免误判，又要确保及时发现故障

实际应用：
3个哨兵，quorum=2：允许1个哨兵故障
5个哨兵，quorum=3：允许2个哨兵故障
```

**🔹 为什么需要通知脚本**
```
故障转移不仅仅是Redis内部的事：
- 需要通知运维人员：发送邮件、短信、钉钉消息
- 需要更新应用配置：修改应用连接的Redis地址
- 需要记录操作日志：便于后续分析和审计

自动化的重要性：
故障往往在半夜发生，人工处理不现实
通过脚本自动处理，确保业务快速恢复
```

**🔹 动态配置的价值**
```
在线运维的必要性：
- 生产环境不能随便重启服务
- 网络环境变化需要及时调整参数
- 业务增长需要调整监控策略

配置即代码：
- 动态修改的配置会自动持久化
- 重启后配置不会丢失
- 便于配置的版本管理和回滚
```

### 5.3 实际应用指导


```
部署规划原则：
🎯 哨兵数量：生产环境至少3个，大型系统推荐5个
🎯 硬件要求：哨兵对硬件要求不高，但要保证网络稳定
🎯 监控策略：重点监控哨兵自身的健康状态

配置调优建议：
⚡ down-after-milliseconds：根据网络环境调整，一般30-60秒
⚡ parallel-syncs：根据主节点性能调整，一般1-3个
⚡ failover-timeout：给故障转移留足够时间，一般3-5分钟

运维自动化：
🔧 配置管理：使用配置管理工具统一管理
🔧 监控告警：接入监控系统，及时发现问题
🔧 故障演练：定期进行故障转移演练
🔧 文档维护：记录配置变更和故障处理流程
```

### 5.4 核心记忆要点


**配置管理口诀**：
```
哨兵配置要规划，三个节点是起点
monitor监控定目标，quorum票数防误判
故障时间别太短，转移超时留余量
动态配置很方便，运行时候可修改
通知脚本要配置，故障发生快通知
```

**部署运维要点**：
- 哨兵配置是Redis高可用的基础，配置错误会影响故障转移
- 动态配置能力让运维更加灵活，但要注意配置的一致性
- 通知脚本是自动化运维的重要组成部分
- 充分的监控和告警是保障系统稳定性的关键