---
title: 4、Redis基础命令操作
---
## 📚 目录

1. [连接与认证操作](#1-连接与认证操作)
2. [基础数据操作](#2-基础数据操作)
3. [过期时间管理](#3-过期时间管理)
4. [键管理与遍历](#4-键管理与遍历)
5. [数据库操作](#5-数据库操作)
6. [键命名规范与最佳实践](#6-键命名规范与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔌 连接与认证操作


### 1.1 连接Redis服务器


**什么是redis-cli？**
`redis-cli`就是Redis的命令行客户端，可以把它理解为Redis的"聊天工具"。你通过这个工具跟Redis服务器"对话"，发送命令并接收回复。

```bash
# 本地连接（默认连接localhost:6379）
redis-cli

# 连接指定服务器和端口
redis-cli -h 192.168.1.100 -p 6379

# 连接时直接输入密码
redis-cli -a mypassword
```

**ping命令 - 测试连接**
```bash
127.0.0.1:6379> ping
PONG

# 自定义ping消息
127.0.0.1:6379> ping "hello"
"hello"
```

> 💡 **理解要点**：`ping`就像手机发短信问"在吗？"，`PONG`就是Redis回复"在的"。如果连接有问题，这个命令会报错。

### 1.2 密码认证


**为什么需要密码？**
Redis默认没有密码，任何人连上都能操作。在生产环境这很危险，就像家里不锁门一样。

**设置和使用密码**
```bash
# 设置密码（在redis.conf文件中）
requirepass mypassword

# 连接后认证
127.0.0.1:6379> auth mypassword
OK

# 认证后才能执行其他命令
127.0.0.1:6379> get test
"value"
```

> ⚠️ **安全提示**：密码要设置复杂一点，避免使用简单密码如"123456"。

### 1.3 数据库选择


**Redis的"房间"概念**
Redis默认有16个数据库（编号0-15），可以把它们想象成16个不同的房间。你可以在不同房间里存放不同类型的数据，互不干扰。

```bash
# 查看当前在哪个数据库
127.0.0.1:6379> select 0
OK

# 切换到数据库1
127.0.0.1:6379> select 1
OK
127.0.0.1:6379[1]>  # 注意提示符变化，显示当前在数据库1

# 切换回默认数据库
127.0.0.1:6379[1]> select 0
OK
127.0.0.1:6379>
```

**实际应用场景**
```
数据库0：用户会话数据
数据库1：商品缓存数据  
数据库2：临时计算结果
...

这样分开存储，逻辑清晰，避免数据混乱
```

---

## 2. 📦 基础数据操作


### 2.1 存数据 - SET命令


**SET命令的作用**
SET就像往柜子里放东西并贴标签。标签是key（键），东西是value（值）。

```bash
# 基本语法
SET key value

# 实际示例
127.0.0.1:6379> set name "张三"
OK

127.0.0.1:6379> set age 25
OK

127.0.0.1:6379> set email "zhangsan@example.com"  
OK
```

**SET命令的高级选项**
```bash
# 设置过期时间（秒）
127.0.0.1:6379> set session:user1 "login_data" ex 3600
OK

# 只有key不存在时才设置（避免覆盖）
127.0.0.1:6379> set counter 1 nx
OK

# 只有key存在时才设置（更新已有数据）
127.0.0.1:6379> set counter 2 xx  
OK
```

### 2.2 取数据 - GET命令


**GET命令的作用**
GET就像根据标签从柜子里拿东西。你告诉Redis标签名，它把对应的东西给你。

```bash
# 基本语法
GET key

# 获取之前存储的数据
127.0.0.1:6379> get name
"张三"

127.0.0.1:6379> get age
"25"

# key不存在时返回nil
127.0.0.1:6379> get nonexistent
(nil)
```

**批量获取数据**
```bash
# 一次获取多个值
127.0.0.1:6379> mget name age email
1) "张三"
2) "25"  
3) "zhangsan@example.com"
```

### 2.3 删数据 - DEL命令


**DEL命令的作用**
DEL就像把柜子里的东西连同标签一起扔掉。删除后就彻底找不到了。

```bash
# 删除单个key
127.0.0.1:6379> del name
(integer) 1  # 返回实际删除的key个数

# 删除多个key
127.0.0.1:6379> del age email
(integer) 2

# 删除不存在的key
127.0.0.1:6379> del nonexistent
(integer) 0  # 删除0个
```

### 2.4 检查存在 - EXISTS命令


**EXISTS命令的作用**
EXISTS就像问柜子里有没有某个标签的东西，有就回复1，没有就回复0。

```bash
# 检查单个key是否存在
127.0.0.1:6379> exists name
(integer) 1  # 存在

127.0.0.1:6379> exists deleted_key
(integer) 0  # 不存在

# 检查多个key
127.0.0.1:6379> exists key1 key2 key3
(integer) 2  # 返回存在的key个数
```

**实际使用场景**
```bash
# 避免覆盖重要数据
127.0.0.1:6379> exists important_config
(integer) 0
127.0.0.1:6379> set important_config "some_value"
OK
```

---

## 3. ⏰ 过期时间管理


### 3.1 设置过期时间 - EXPIRE命令


**为什么需要过期时间？**
想象Redis是一个仓库，如果东西只进不出，很快就会满了。过期时间就像给东西贴"保质期标签"，过期了自动扔掉，避免垃圾堆积。

```bash
# 设置key在60秒后过期
127.0.0.1:6379> set temp_data "临时数据"
OK
127.0.0.1:6379> expire temp_data 60
(integer) 1  # 设置成功

# 常见过期时间设置
127.0.0.1:6379> expire session:user1 3600    # 1小时
127.0.0.1:6379> expire cache:product 86400   # 1天  
127.0.0.1:6379> expire temp:calc 300         # 5分钟
```

### 3.2 查看剩余时间 - TTL命令


**TTL命令的含义**
TTL = "Time To Live"，意思是"还能活多久"。就像查看食物还有多久过期。

```bash
# 查看剩余过期时间（秒）
127.0.0.1:6379> ttl temp_data
(integer) 45  # 还有45秒过期

# 特殊返回值含义
127.0.0.1:6379> ttl permanent_key
(integer) -1  # 永不过期

127.0.0.1:6379> ttl nonexistent_key  
(integer) -2  # key不存在
```

**PTTL - 毫秒级查看**
```bash
# 查看毫秒级剩余时间
127.0.0.1:6379> pttl temp_data
(integer) 45230  # 还有45.23秒
```

### 3.3 精确过期时间 - EXPIREAT命令


**EXPIREAT的作用**
如果说EXPIRE是设置"多久后过期"，那EXPIREAT就是设置"什么时候过期"。就像给食物贴上确切的过期日期。

```bash
# 设置在指定时间戳过期
127.0.0.1:6379> set event_data "活动数据"
OK
127.0.0.1:6379> expireat event_data 1693516800  # 2023年9月1日过期
(integer) 1
```

**获取时间戳的方法**
```bash
# 在Redis中获取当前时间戳
127.0.0.1:6379> time
1) "1693430400"  # 秒级时间戳
2) "123456"      # 微秒部分
```

### 3.4 取消过期 - PERSIST命令


**PERSIST的作用**
就像撕掉食物的过期标签，让它永远不过期。

```bash
# 移除过期时间
127.0.0.1:6379> persist temp_data
(integer) 1  # 成功移除过期时间

127.0.0.1:6379> ttl temp_data  
(integer) -1  # 现在永不过期了
```

---

## 4. 🔍 键管理与遍历


### 4.1 查看键 - KEYS命令


**KEYS命令的作用**
KEYS就像在仓库里找东西，你可以用通配符模式来搜索。

```bash
# 查看所有键
127.0.0.1:6379> keys *
1) "name"
2) "age" 
3) "email"

# 按模式查找
127.0.0.1:6379> keys user:*
1) "user:1001"
2) "user:1002"
3) "user:1003"

# 更多模式示例
127.0.0.1:6379> keys session:*    # 所有session开头的键
127.0.0.1:6379> keys *:config    # 所有config结尾的键
127.0.0.1:6379> keys user:?      # user:后面只有一个字符的键
```

> ⚠️ **重要警告**：`keys *`命令在生产环境要谨慎使用！如果Redis里有几百万个键，这个命令会让Redis卡死几秒钟，影响其他用户。

### 4.2 安全遍历 - SCAN命令


**为什么需要SCAN？**
KEYS命令就像一口气搬完整个仓库找东西，会累死。SCAN命令就像分批慢慢找，每次找一部分，不会累着。

**SCAN的工作方式**
SCAN使用"游标"机制，就像看书时夹个书签，记住看到哪里了，下次从这里继续看。

```bash
# 开始扫描（游标从0开始）
127.0.0.1:6379> scan 0
1) "3"        # 下一次扫描的游标位置  
2) 1) "key1"  # 这一批找到的键
   2) "key2"
   3) "key3"

# 继续扫描（使用返回的游标3）
127.0.0.1:6379> scan 3
1) "0"        # 游标为0表示扫描完成
2) 1) "key4"
   2) "key5"
```

**SCAN的高级用法**
```bash
# 指定每次返回的数量
127.0.0.1:6379> scan 0 count 10

# 按模式扫描
127.0.0.1:6379> scan 0 match user:* count 5

# 完整的安全遍历示例
cursor = 0
do {
    result = scan cursor match "user:*" count 100
    cursor = result[0]  # 新游标位置
    keys = result[1]    # 本次找到的键
    # 处理这批键...
} while (cursor != 0)  # 游标回到0表示完成
```

> 💡 **最佳实践**：生产环境一定要用SCAN替代KEYS，避免阻塞Redis服务。

### 4.3 键的类型检查 - TYPE命令


**TYPE命令的作用**
就像看标签上写的是什么类型的东西：是字符串、列表、还是其他类型。

```bash
# 检查键的数据类型
127.0.0.1:6379> set name "张三"
OK
127.0.0.1:6379> type name
string

127.0.0.1:6379> lpush friends "李四" "王五"  
(integer) 2
127.0.0.1:6379> type friends
list

# key不存在时
127.0.0.1:6379> type nonexistent
none
```

**Redis的数据类型**
```
string  - 字符串（最常用）
list    - 列表（有序可重复）
set     - 集合（无序不重复）
zset    - 有序集合
hash    - 哈希表（对象存储）
```

### 4.4 键的重命名 - RENAME命令


**RENAME命令的作用**
就像给文件重新起名字，内容不变，只是标签变了。

```bash
# 重命名键
127.0.0.1:6379> set old_name "数据"
OK
127.0.0.1:6379> rename old_name new_name
OK
127.0.0.1:6379> get new_name
"数据"
127.0.0.1:6379> get old_name
(nil)  # 旧名字已经不存在了
```

> ⚠️ **注意**：如果目标键名已经存在，RENAME会直接覆盖！要小心使用。

---

## 5. 🗄️ 数据库操作


### 5.1 数据库信息查看


**DBSIZE - 查看当前数据库键数量**
```bash
127.0.0.1:6379> dbsize
(integer) 1523  # 当前数据库有1523个键
```

**INFO命令 - 查看Redis详细信息**
```bash
# 查看所有信息
127.0.0.1:6379> info

# 查看特定类型信息
127.0.0.1:6379> info memory     # 内存使用情况
127.0.0.1:6379> info stats      # 统计信息  
127.0.0.1:6379> info replication # 主从复制状态
```

**INFO命令重要输出解读**
```bash
# Memory 内存信息
used_memory:1048576          # 已使用内存（字节）
used_memory_human:1.00M      # 人类可读格式
maxmemory:0                  # 最大内存限制

# Stats 统计信息  
total_connections_received:1000  # 总连接数
total_commands_processed:5000    # 总命令执行数
keyspace_hits:800               # 键命中次数
keyspace_misses:200             # 键未命中次数
```

### 5.2 清空数据库


**FLUSHDB vs FLUSHALL的区别**

```
FLUSHDB：清空当前数据库（只清理一个房间）
FLUSHALL：清空所有数据库（清理整栋楼）
```

```bash
# 清空当前数据库
127.0.0.1:6379> flushdb
OK

# 清空所有数据库  
127.0.0.1:6379> flushall
OK
```

> ⚠️ **危险操作**：这两个命令会立即删除数据，且无法恢复！生产环境要特别小心。

**安全的清空方式**
```bash
# 先备份再清空
127.0.0.1:6379> save           # 立即保存数据到磁盘
127.0.0.1:6379> flushdb        # 然后清空
```

---

## 6. 📝 键命名规范与最佳实践


### 6.1 键命名规范


**为什么需要命名规范？**
就像给文件起名字，好的命名让你快速知道文件里是什么。Redis键名也一样，规范的命名让代码更易维护。

**推荐命名格式**
```bash
# 模块:业务:具体标识
user:profile:1001        # 用户模块的个人信息，用户ID 1001
order:detail:202308001   # 订单模块的详情，订单号 202308001
cache:product:list       # 缓存模块的商品列表
session:login:abc123     # 会话模块的登录信息

# 层级关系清晰
app:user:1001:profile    # 应用-用户-ID-配置
app:user:1001:settings   # 应用-用户-ID-设置
```

**命名原则**
```
1. 使用冒号(:)分隔层级
2. 避免特殊字符和空格
3. 统一使用小写字母
4. 名称要有意义，避免缩写
5. 控制长度，不要过长
```

### 6.2 批量操作技巧


**什么时候用批量操作？**
当你需要一次处理多个相关数据时，批量操作更高效。就像购物时用购物车一次结账，比一件件单独付款要快。

```bash
# 批量设置
127.0.0.1:6379> mset user:1001:name "张三" user:1001:age 25 user:1001:city "北京"
OK

# 批量获取
127.0.0.1:6379> mget user:1001:name user:1001:age user:1001:city
1) "张三"
2) "25"
3) "北京"

# 批量删除
127.0.0.1:6379> del user:1001:name user:1001:age user:1001:city
(integer) 3
```

### 6.3 SCAN命令最佳实践


**SCAN vs KEYS 对比**

| 特性 | **KEYS命令** | **SCAN命令** |
|------|-------------|-------------|
| **性能影响** | `阻塞式，大数据量时卡死` | `非阻塞，分批处理` |
| **使用场景** | `开发测试环境` | `生产环境必用` |
| **返回结果** | `一次返回所有匹配键` | `分批返回，需要循环` |
| **内存占用** | `可能消耗大量内存` | `内存占用稳定` |

**SCAN的实际使用模式**
```bash
# 安全的键遍历模式
cursor="0"
while [ "$cursor" != "0" ] || [ "$first_iteration" = "true" ]; do
    result=$(redis-cli scan $cursor match "user:*" count 1000)
    cursor=$(echo "$result" | head -n1)
    keys=$(echo "$result" | tail -n +2)
    
    # 处理这批键...
    for key in $keys; do
        echo "处理键: $key"
    done
    
    first_iteration="false"
done
```

---

## 7. 🛠️ 实际应用场景


### 7.1 Web应用会话管理


**场景描述**
用户登录后，需要记住登录状态。传统方式是在服务器内存中保存，但服务器重启就丢了。用Redis存储更可靠。

```bash
# 用户登录后创建会话
127.0.0.1:6379> set session:abc123 "user_id:1001" ex 7200  # 2小时过期
OK

# 每次请求时检查会话
127.0.0.1:6379> get session:abc123
"user_id:1001"  # 会话有效

# 用户登出时删除会话
127.0.0.1:6379> del session:abc123
(integer) 1
```

### 7.2 缓存热点数据


**场景描述**
数据库查询很慢，经常查询的数据可以放在Redis里。就像把常用的书放在书桌上，不用每次都去书柜找。

```bash
# 缓存商品信息
127.0.0.1:6379> set product:1001 '{"name":"手机","price":2999}' ex 1800  # 30分钟过期
OK

# 应用程序查询逻辑
1. 先查Redis：get product:1001
2. 如果有数据：直接返回（快）
3. 如果没有：查数据库，然后存入Redis（慢，但只有第一次慢）
```

### 7.3 计数器功能


**场景描述**
网站访问量、点赞数、库存数量等需要频繁更新的数字。

```bash
# 网站访问计数
127.0.0.1:6379> set page_views 0
OK
127.0.0.1:6379> incr page_views     # 每次访问+1
(integer) 1
127.0.0.1:6379> incr page_views
(integer) 2

# 查看当前访问量
127.0.0.1:6379> get page_views
"2"
```

### 7.4 临时数据存储


**场景描述**
验证码、临时计算结果等短期使用的数据。

```bash
# 短信验证码（5分钟过期）
127.0.0.1:6379> set sms:13800138000 "123456" ex 300
OK

# 临时计算结果（10分钟过期）
127.0.0.1:6379> set calc:task123 "result_data" ex 600
OK
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基础命令


```
🔸 连接认证：redis-cli、ping、auth、select
🔸 基础操作：set、get、del、exists  
🔸 过期管理：expire、ttl、persist、expireat
🔸 键管理：keys、scan、type、rename
🔸 数据库：dbsize、info、flushdb、flushall
```

### 8.2 关键理解要点


**🔹 Redis就像智能仓库**
```
存东西：SET命令贴标签放东西
找东西：GET命令根据标签找东西  
扔东西：DEL命令连标签一起扔掉
设保质期：EXPIRE命令防止东西过期发霉
查库存：EXISTS命令看看还有没有
```

**🔹 生产环境安全使用**
```
用SCAN不用KEYS：避免服务卡死
设置合理过期时间：防止内存爆满
规范键命名：便于管理和维护
谨慎使用FLUSH：数据删除无法恢复
```

**🔹 常用命令组合**
```
会话管理：SET + EXPIRE + GET + DEL
缓存应用：SET + EXPIRE + EXISTS + GET
数据清理：SCAN + TYPE + TTL + DEL
批量操作：MSET + MGET + DEL（多个键）
```

### 8.3 实际应用价值


**📊 应用场景总结**

| 场景 | **主要命令** | **典型用法** | **注意事项** |
|------|-------------|-------------|-------------|
| **会话存储** | `SET/GET + EXPIRE` | `用户登录状态保持` | `设置合理过期时间` |
| **数据缓存** | `SET/GET + TTL` | `数据库查询结果缓存` | `缓存更新策略` |
| **计数统计** | `INCR/DECR` | `访问量、点赞数统计` | `原子性操作` |
| **临时存储** | `SET + EXPIRE` | `验证码、临时文件` | `及时清理过期数据` |

**🔧 运维实践**
```
日常维护：
• 监控键数量：dbsize
• 检查内存使用：info memory  
• 清理测试数据：scan + del
• 备份重要数据：save/bgsave

故障排查：
• 连接问题：ping测试
• 权限问题：auth认证
• 性能问题：info stats分析
• 数据问题：type检查键类型
```

**核心记忆**：
- Redis基础命令就像操作智能仓库的基本工具
- 生产环境要用SCAN，开发测试可以用KEYS  
- 给数据设置合理的过期时间，避免内存浪费
- 规范的键命名是良好习惯，便于后期维护