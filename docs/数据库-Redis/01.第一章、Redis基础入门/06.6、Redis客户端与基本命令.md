---
title: 6、Redis客户端与基本命令
---
## 📚 目录

1. [Redis客户端概述](#1-Redis客户端概述)
2. [连接Redis服务器](#2-连接Redis服务器)
3. [键操作基本命令](#3-键操作基本命令)
4. [字符串操作命令](#4-字符串操作命令)
5. [数据库管理命令](#5-数据库管理命令)
6. [服务器管理命令](#6-服务器管理命令)
7. [命令行工具详解](#7-命令行工具详解)
8. [性能监控与调优](#8-性能监控与调优)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔌 Redis客户端概述


### 1.1 什么是Redis客户端


**📝 通俗理解**
```
Redis客户端就像是你和Redis数据库之间的"翻译官"
你说人话 → 客户端翻译成Redis命令 → Redis执行 → 返回结果 → 客户端翻译回人话

简单类比：
Redis服务器 = 一个很厉害的管家
Redis客户端 = 你和管家沟通的对讲机
你通过对讲机告诉管家做什么，管家做完告诉你结果
```

### 1.2 客户端的种类


**🔸 命令行客户端**
```
redis-cli：Redis自带的命令行工具
特点：直接敲命令，立即看结果
适合：学习、测试、简单操作
就像：直接和管家面对面说话
```

**🔸 编程语言客户端**
```
Java：Jedis、Lettuce、Redisson
Python：redis-py、aioredis
Node.js：ioredis、node-redis
PHP：Predis、PhpRedis
C#：StackExchange.Redis
Go：go-redis

特点：在程序代码中操作Redis
适合：实际项目开发
就像：写信给管家，让管家按信上的步骤做事
```

**🔸 图形界面客户端**
```
RedisDesktopManager (RDM)
Another Redis Desktop Manager
Redis Commander
RedisInsight (官方)

特点：点击按钮操作，图形化界面
适合：可视化管理和监控
就像：用遥控器控制管家
```

### 1.3 客户端协议原理


**💡 Redis通信协议 (RESP)**
```
Redis使用简单的文本协议进行通信
客户端发送：*3\r\n$3\r\nSET\r\n$4\r\nname\r\n$6\r\n张三\r\n
Redis回复：+OK\r\n

解释：
*3 = 3个参数
$3 = 第一个参数3字节，内容是SET
$4 = 第二个参数4字节，内容是name  
$6 = 第三个参数6字节，内容是张三
+OK = 成功回复
```

---

## 2. 🌐 连接Redis服务器


### 2.1 redis-cli连接方式


**🔸 本地连接（最简单）**
```bash
# 连接本地Redis（默认端口6379）
redis-cli

# 看到这个提示就表示连接成功了
127.0.0.1:6379>

# 连接本地指定端口
redis-cli -p 6380
```

**🔸 远程连接**
```bash
# 连接远程Redis服务器
redis-cli -h 192.168.1.100 -p 6379

# 连接时指定密码
redis-cli -h 192.168.1.100 -p 6379 -a your_password

# 更安全的密码输入方式（不在命令行显示密码）
redis-cli -h 192.168.1.100 -p 6379
127.0.0.1:6379> AUTH your_password
```

**🔸 指定数据库连接**
```bash
# 连接时选择数据库
redis-cli -n 2    # 连接2号数据库

# URI格式连接
redis-cli -u redis://user:password@host:port/database
redis-cli -u redis://:mypassword@127.0.0.1:6379/0
```

### 2.2 连接参数详解


| 参数 | **含义** | **示例** | **说明** |
|------|---------|---------|---------|
| `-h` | `主机地址` | `-h 192.168.1.100` | `不写默认localhost` |
| `-p` | `端口号` | `-p 6380` | `不写默认6379` |
| `-a` | `密码` | `-a mypassword` | `有密码时使用` |
| `-n` | `数据库号` | `-n 2` | `选择数据库（0-15）` |
| `-u` | `URI连接` | `-u redis://host:port` | `统一资源标识符` |
| `--raw` | `原始输出` | `--raw` | `不格式化中文字符` |
| `--csv` | `CSV格式` | `--csv` | `输出CSV格式` |
| `-r` | `重复执行` | `-r 5` | `重复执行命令5次` |
| `-i` | `执行间隔` | `-i 0.1` | `每0.1秒执行一次` |

### 2.3 连接状态检查


**🔸 测试连接是否正常**
```bash
# 最简单的测试命令
127.0.0.1:6379> PING
PONG    # 看到PONG就说明连接正常

# 带消息的PING
127.0.0.1:6379> PING "hello"
"hello"    # 返回你发送的消息

# 查看服务器信息
127.0.0.1:6379> INFO server
# 会显示Redis版本、运行时间等信息
```

**🔸 连接诊断**
```bash
# 检查延迟
127.0.0.1:6379> LATENCY LATEST
# 显示最近的延迟统计

# 查看连接信息
127.0.0.1:6379> CLIENT INFO
# 显示当前连接的详细信息
```

**🌰 生活类比**
```
PING命令就像打电话时说"喂，听得到吗？"
PONG回应就像对方回答"听得到，很清楚"
如果没有PONG，就说明连接有问题
```

---

## 3. 📝 键操作基本命令


### 3.1 键查找命令


**🔸 KEYS - 查找键名**
```bash
# 查看所有键（生产环境慎用！）
KEYS *

# 查看特定模式的键
KEYS user:*        # 查找所有以user:开头的键
KEYS *name*        # 查找包含name的键  
KEYS user:??       # 查找user:后面跟两个字符的键
KEYS user:[abc]*   # 查找user:后跟a、b或c开头的键
KEYS user:1[0-9]   # 查找user:1后跟数字的键
```

**🔸 SCAN - 渐进式遍历**
```bash
# 安全的键遍历方式
SCAN 0            # 从游标0开始扫描
SCAN 0 MATCH user:* COUNT 10    # 指定模式和数量

# 返回结果示例：
# 1) "6"           # 下次扫描的游标
# 2) 1) "user:1001"  # 找到的键
#    2) "user:1002"

# 继续扫描
SCAN 6 MATCH user:*

# 直到游标返回0，表示扫描完毕
```

**⚠️ KEYS vs SCAN 对比**
```
KEYS命令：
✅ 简单易用，一次返回所有结果
❌ 阻塞Redis，数据多时会卡住服务器
❌ 时间复杂度O(n)，n是数据库键总数

SCAN命令：
✅ 渐进式扫描，不阻塞服务器
✅ 可指定每次返回的大致数量
❌ 使用相对复杂，需要多次调用

生产环境建议：用SCAN替代KEYS
```

### 3.2 键存在性检查


**🔸 EXISTS - 检查键是否存在**
```bash
# 检查单个键
EXISTS user:1001
# 返回1表示存在，0表示不存在

# 检查多个键
EXISTS user:1001 user:1002 user:1003  
# 返回存在的键的个数（如：2表示3个键中有2个存在）

# 实际使用示例
127.0.0.1:6379> SET name "张三"
OK
127.0.0.1:6379> EXISTS name
(integer) 1

127.0.0.1:6379> EXISTS age
(integer) 0
```

**🌰 实际应用场景**
```bash
# 场景1：用户登录前检查用户是否存在
if EXISTS user:1001:
    # 用户存在，继续登录流程
else:
    # 用户不存在，显示错误

# 场景2：缓存命中检查
if EXISTS cache:article:100:
    # 缓存存在，直接返回
else:
    # 缓存不存在，从数据库查询后缓存
```

### 3.3 键删除操作


**🔸 DEL - 删除键**
```bash
# 删除单个键
DEL user:1001
# 返回删除成功的键数量

# 删除多个键
DEL user:1001 user:1002 session:abc123
# 返回实际删除的键数量

# 删除结果示例
127.0.0.1:6379> SET name "张三"
OK
127.0.0.1:6379> DEL name
(integer) 1    # 成功删除1个键

127.0.0.1:6379> DEL nonexistent
(integer) 0    # 删除0个键（键不存在）
```

**🔸 UNLINK - 异步删除**
```bash
# 异步删除大键（推荐）
UNLINK big_list big_hash big_set

# 区别说明：
# DEL：同步删除，可能阻塞Redis
# UNLINK：异步删除，立即返回，后台删除
```

**⚠️ 删除注意事项**
```
删除是永久性的，无法恢复！
建议：
1. 删除前确认键名正确
2. 重要数据删除前先备份
3. 使用UNLINK删除大键
4. 批量删除时小心通配符
```

### 3.4 键重命名操作


**🔸 RENAME - 重命名键**
```bash
# 重命名键
RENAME old_key new_key

# 示例
127.0.0.1:6379> SET name "张三"
OK
127.0.0.1:6379> RENAME name username
OK
127.0.0.1:6379> GET username
"张三"
127.0.0.1:6379> GET name
(nil)    # 原键已不存在
```

**🔸 RENAMENX - 仅当新键不存在时重命名**
```bash
# 安全重命名（不覆盖已存在的键）
RENAMENX old_key new_key
# 返回1表示重命名成功，0表示新键已存在

127.0.0.1:6379> SET name "张三"
OK  
127.0.0.1:6379> SET age 25
OK
127.0.0.1:6379> RENAMENX name age
(integer) 0    # 失败，age键已存在
```

### 3.5 键过期管理


**🔸 设置过期时间**
```bash
# 设置秒级过期时间
EXPIRE key seconds
EXPIRE user:1001 3600    # 1小时后过期

# 设置毫秒级过期时间  
PEXPIRE key milliseconds
PEXPIRE user:1001 30000  # 30秒后过期

# 设置绝对过期时间（Unix时间戳）
EXPIREAT key timestamp
EXPIREAT user:1001 1703808000  # 在指定时间点过期

# 设置绝对过期时间（毫秒时间戳）
PEXPIREAT key milliseconds-timestamp
```

**🔸 查看过期时间**
```bash
# 查看剩余存活时间（秒）
TTL key
# 返回值说明：
# 正数：剩余秒数
# -1：永不过期
# -2：键不存在或已过期

# 查看剩余存活时间（毫秒）
PTTL key

# 示例
127.0.0.1:6379> SET temp "临时数据"
OK
127.0.0.1:6379> EXPIRE temp 60
(integer) 1
127.0.0.1:6379> TTL temp
(integer) 58    # 还有58秒过期
```

**🔸 移除过期时间**
```bash
# 让键永久保存
PERSIST key
# 返回1表示成功移除过期时间，0表示键不存在或本来就是永久的

127.0.0.1:6379> SET temp "数据"
OK
127.0.0.1:6379> EXPIRE temp 3600  
(integer) 1
127.0.0.1:6379> TTL temp
(integer) 3599
127.0.0.1:6379> PERSIST temp
(integer) 1
127.0.0.1:6379> TTL temp
(integer) -1    # 现在是永久保存
```

**💡 过期时间实际应用**
```
验证码管理：
SET sms:13800138000 "123456" EX 300  # 5分钟过期

会话管理：
SET session:abc123 "user_data" EX 1800  # 30分钟过期

缓存管理：
SET cache:article:100 "content" EX 3600  # 1小时过期

临时数据：
SET temp:upload:file123 "path" EX 86400  # 24小时过期
```

### 3.6 键类型和结构


**🔸 TYPE - 查看键的数据类型**
```bash
# 查看键存储的数据类型
TYPE key

# 可能的返回值：
TYPE name     # string
TYPE users    # list  
TYPE tags     # set
TYPE scores   # zset
TYPE profile  # hash
TYPE bitmap   # string (bitmap是string的特殊用法)
TYPE streams  # stream

# 示例
127.0.0.1:6379> SET name "张三"
OK
127.0.0.1:6379> TYPE name
string
127.0.0.1:6379> LPUSH todos "学Redis" "写代码"
(integer) 2  
127.0.0.1:6379> TYPE todos
list
```

**🔸 OBJECT - 查看键的内部编码**
```bash
# 查看键的编码方式
OBJECT ENCODING key

# 查看键被引用次数
OBJECT REFCOUNT key

# 查看键的空闲时间（秒）
OBJECT IDLETIME key

# 示例
127.0.0.1:6379> SET small_num 100
OK
127.0.0.1:6379> OBJECT ENCODING small_num
"int"    # 小整数用整数编码

127.0.0.1:6379> SET long_str "很长很长的字符串..."
OK  
127.0.0.1:6379> OBJECT ENCODING long_str
"raw"    # 长字符串用原始编码
```

### 3.7 键的随机操作


**🔸 RANDOMKEY - 随机返回一个键**
```bash
# 从数据库中随机返回一个键
RANDOMKEY

127.0.0.1:6379> SET key1 "value1"
OK
127.0.0.1:6379> SET key2 "value2" 
OK
127.0.0.1:6379> RANDOMKEY
"key2"    # 随机返回的键
127.0.0.1:6379> RANDOMKEY  
"key1"    # 再次随机可能返回不同的键
```

---

## 4. 💾 字符串操作命令


### 4.1 基本字符串操作


**🔸 SET/GET - 设置和获取**
```bash
# 基本设置和获取
SET key value
GET key

# 设置选项
SET key value EX seconds      # 设置过期时间（秒）
SET key value PX milliseconds # 设置过期时间（毫秒）
SET key value NX             # 仅当键不存在时设置
SET key value XX             # 仅当键存在时设置

# 示例
127.0.0.1:6379> SET name "张三" EX 3600
OK    # 设置name，1小时后过期

127.0.0.1:6379> SET counter 100 NX
OK    # 仅当counter不存在时设置

127.0.0.1:6379> SET counter 200 XX  
OK    # 仅当counter存在时更新
```

**🔸 MSET/MGET - 批量操作**
```bash
# 批量设置
MSET key1 value1 key2 value2 key3 value3

# 批量获取
MGET key1 key2 key3

# 示例
127.0.0.1:6379> MSET name "张三" age 25 city "北京"
OK
127.0.0.1:6379> MGET name age city
1) "张三"
2) "25"  
3) "北京"
```

**🔸 GETSET - 设置新值返回旧值**
```bash
# 设置新值，返回旧值（原子操作）
GETSET key new_value

127.0.0.1:6379> SET counter 100
OK
127.0.0.1:6379> GETSET counter 200
"100"    # 返回旧值100，现在counter是200
127.0.0.1:6379> GET counter  
"200"    # 确认已更新
```

**🔸 SETNX/SETEX - 条件设置**
```bash
# 仅当键不存在时设置
SETNX key value
# 返回1表示设置成功，0表示键已存在

# 设置键值和过期时间
SETEX key seconds value

# 示例
127.0.0.1:6379> SETNX lock "locked"
(integer) 1    # 设置成功

127.0.0.1:6379> SETNX lock "locked_again"  
(integer) 0    # 设置失败，键已存在

127.0.0.1:6379> SETEX session 3600 "session_data"
OK    # 设置session，3600秒后过期
```

### 4.2 数值操作命令


**🔸 INCR/DECR - 递增递减**
```bash
# 递增1
INCR key

# 递减1  
DECR key

# 指定增减值
INCRBY key increment
DECRBY key decrement

# 浮点数增减
INCRBYFLOAT key increment

# 示例
127.0.0.1:6379> SET counter 10
OK
127.0.0.1:6379> INCR counter
(integer) 11
127.0.0.1:6379> INCRBY counter 5
(integer) 16
127.0.0.1:6379> DECR counter
(integer) 15
127.0.0.1:6379> INCRBYFLOAT counter 0.5
"15.5"
```

**💡 数值操作的应用场景**
```
计数器：网站访问量、文章点赞数
ID生成：全局唯一ID生成器
限流：基于计数的限流控制
统计：用户行为统计

注意：只能对数值字符串操作，非数值会报错
```

### 4.3 字符串范围操作


**🔸 GETRANGE - 获取子字符串**
```bash
# 获取字符串的部分内容
GETRANGE key start end

127.0.0.1:6379> SET greeting "Hello World"
OK
127.0.0.1:6379> GETRANGE greeting 0 4
"Hello"
127.0.0.1:6379> GETRANGE greeting 6 -1
"World"    # -1表示到字符串末尾
```

**🔸 SETRANGE - 替换字符串部分**
```bash
# 从指定位置开始替换字符串
SETRANGE key offset value

127.0.0.1:6379> SET greeting "Hello World"
OK
127.0.0.1:6379> SETRANGE greeting 6 "Redis"
(integer) 11    # 返回修改后的字符串长度
127.0.0.1:6379> GET greeting
"Hello Redis"
```

**🔸 STRLEN - 获取字符串长度**
```bash
# 获取字符串长度（字节数）
STRLEN key

127.0.0.1:6379> SET name "张三"
OK
127.0.0.1:6379> STRLEN name  
(integer) 6    # 中文字符UTF-8编码，每个字符3字节

127.0.0.1:6379> SET english "Hello"
OK
127.0.0.1:6379> STRLEN english
(integer) 5    # 英文字符，每个字符1字节
```

### 4.4 字符串追加操作


**🔸 APPEND - 追加字符串**
```bash
# 在字符串末尾追加内容
APPEND key value

127.0.0.1:6379> SET msg "Hello"
OK
127.0.0.1:6379> APPEND msg " World"
(integer) 11    # 返回追加后的字符串长度
127.0.0.1:6379> GET msg
"Hello World"

# 如果键不存在，APPEND等同于SET
127.0.0.1:6379> APPEND newkey "New Value"
(integer) 9
127.0.0.1:6379> GET newkey
"New Value"
```

---

## 5. 🗄️ 数据库管理命令


### 5.1 数据库切换


**🔸 SELECT - 切换数据库**
```bash
# Redis默认有16个数据库（0-15）
SELECT database_number

# 示例
127.0.0.1:6379> SELECT 1
OK
127.0.0.1:6379[1]>    # 注意提示符变化，现在在1号数据库

127.0.0.1:6379[1]> SELECT 0
OK  
127.0.0.1:6379>      # 回到0号数据库
```

**💡 数据库隔离性**
```
不同数据库的数据完全隔离
就像：一栋楼的不同房间，房间内的东西互不影响

注意：
- 生产环境建议只使用0号数据库
- 集群模式只支持0号数据库
- 不同数据库无法进行数据操作（如事务）
```

### 5.2 数据库信息查看


**🔸 DBSIZE - 查看键数量**
```bash
# 查看当前数据库的键数量
DBSIZE

127.0.0.1:6379> SET key1 "value1"
OK
127.0.0.1:6379> SET key2 "value2"  
OK
127.0.0.1:6379> DBSIZE
(integer) 2    # 当前数据库有2个键
```

**🔸 INFO keyspace - 查看所有数据库信息**
```bash
# 查看所有数据库的键统计
INFO keyspace

# 输出示例：
# keyspace
# db0:keys=100,expires=10,avg_ttl=3600
# db1:keys=50,expires=5,avg_ttl=7200
#
# 解释：
# keys=100: 数据库有100个键
# expires=10: 其中10个键设置了过期时间
# avg_ttl=3600: 平均存活时间3600秒
```

### 5.3 数据库清理


**🔸 FLUSHDB - 清空当前数据库**
```bash
# 清空当前数据库的所有键
FLUSHDB

# 异步清空（推荐，不阻塞）
FLUSHDB ASYNC

127.0.0.1:6379> DBSIZE
(integer) 100
127.0.0.1:6379> FLUSHDB
OK
127.0.0.1:6379> DBSIZE  
(integer) 0    # 当前数据库已清空
```

**🔸 FLUSHALL - 清空所有数据库**
```bash
# 清空所有数据库
FLUSHALL

# 异步清空所有数据库
FLUSHALL ASYNC

⚠️ 警告：这个命令会删除Redis中的所有数据！
生产环境使用前必须确认！
```

### 5.4 数据迁移


**🔸 MOVE - 移动键到其他数据库**
```bash
# 将键移动到指定数据库
MOVE key destination_db

127.0.0.1:6379> SET temp "临时数据"
OK
127.0.0.1:6379> MOVE temp 1
(integer) 1    # 成功移动

127.0.0.1:6379> GET temp
(nil)    # 0号数据库中已不存在

127.0.0.1:6379> SELECT 1
OK
127.0.0.1:6379[1]> GET temp
"临时数据"    # 在1号数据库中
```

---

## 6. ⚙️ 服务器管理命令


### 6.1 服务器信息查看


**🔸 INFO - 查看服务器信息**
```bash
# 查看所有信息
INFO

# 查看特定部分信息
INFO server      # 服务器基本信息
INFO memory      # 内存使用信息
INFO stats       # 统计信息
INFO replication # 主从复制信息
INFO cpu         # CPU使用信息
INFO keyspace    # 键空间信息

# 示例输出（部分）
127.0.0.1:6379> INFO server
# Server
redis_version:7.0.0
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:xyz123
redis_mode:standalone
os:Linux 5.4.0 x86_64
arch_bits:64
multiplexing_api:epoll
process_id:12345
run_id:abc123def456
tcp_port:6379
server_time_usec:1609459200123456
uptime_in_seconds:86400
uptime_in_days:1
```

**🔸 CONFIG - 配置管理**
```bash
# 查看所有配置
CONFIG GET *

# 查看特定配置
CONFIG GET maxmemory      # 最大内存限制
CONFIG GET save           # 持久化配置
CONFIG GET timeout        # 连接超时时间

# 运行时修改配置
CONFIG SET maxmemory 1gb
CONFIG SET save "900 1 300 10"    # RDB保存策略

# 重写配置文件
CONFIG REWRITE
```

### 6.2 客户端管理


**🔸 CLIENT - 客户端信息管理**
```bash
# 查看所有连接的客户端
CLIENT LIST

# 输出示例：
# id=3 addr=127.0.0.1:54327 fd=8 name= age=0 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=40928 obl=0 oll=0 omem=0 events=r cmd=client

# 字段说明：
# id: 客户端唯一标识
# addr: 客户端地址和端口
# age: 连接存活时间（秒）
# idle: 空闲时间（秒）
# db: 当前使用的数据库
# cmd: 最后执行的命令

# 杀死指定客户端连接
CLIENT KILL ip:port
CLIENT KILL 127.0.0.1:54327

# 设置客户端名称（方便管理）
CLIENT SETNAME "web-server-1"

# 获取当前客户端信息
CLIENT INFO
```

**🔸 连接数统计**
```bash
127.0.0.1:6379> INFO clients
# Clients
connected_clients:2          # 当前连接数
client_recent_max_input_buffer:2    # 最大输入缓冲区
client_recent_max_output_buffer:0   # 最大输出缓冲区
blocked_clients:0            # 被阻塞的客户端数
```

### 6.3 内存管理


**🔸 MEMORY - 内存分析**
```bash
# 查看内存使用统计
MEMORY STATS

# 查看特定键的内存使用
MEMORY USAGE key

# 示例
127.0.0.1:6379> SET large_string "很长的字符串数据..."
OK
127.0.0.1:6379> MEMORY USAGE large_string
(integer) 64    # 该键占用64字节内存

# 查看内存使用详情
127.0.0.1:6379> INFO memory
# Memory
used_memory:2097152          # 使用的内存（字节）
used_memory_human:2.00M      # 人类可读格式
used_memory_rss:8388608      # RSS内存
used_memory_rss_human:8.00M
used_memory_peak:2097152     # 内存使用峰值
used_memory_peak_human:2.00M
maxmemory:0                  # 最大内存限制（0=无限制）
maxmemory_human:0B
```

### 6.4 性能测试


**🔸 LATENCY - 延迟监控**
```bash
# 开启延迟监控
CONFIG SET latency-monitor-threshold 100

# 查看延迟历史
LATENCY HISTORY command

# 查看最新延迟
LATENCY LATEST

# 重置延迟统计
LATENCY RESET
```

**🔸 SLOWLOG - 慢查询日志**
```bash
# 查看慢查询日志
SLOWLOG GET 10    # 获取最近10条慢查询

# 慢查询日志长度
SLOWLOG LEN

# 清空慢查询日志
SLOWLOG RESET

# 配置慢查询
CONFIG SET slowlog-log-slower-than 10000    # 超过10ms记录
CONFIG SET slowlog-max-len 128              # 最多保存128条
```

---

## 7. 💻 命令行工具详解


### 7.1 redis-cli基本操作


**🔸 启动和退出**
```bash
# 启动redis-cli
redis-cli

# 退出redis-cli
127.0.0.1:6379> exit
# 或者按Ctrl+C

# 直接执行命令（不进入交互模式）
redis-cli GET user:1001
redis-cli SET user:1001 "张三"
```

### 7.2 高级用法


**🔸 批处理模式**
```bash
# 从标准输入读取命令
echo "SET name value" | redis-cli

# 从文件执行命令
redis-cli < commands.txt

# 执行单个命令后退出
redis-cli GET name
redis-cli SET counter 100

# 重复执行命令
redis-cli -r 5 INCR counter    # 执行5次INCR
redis-cli -r -1 -i 1 INFO stats  # 无限重复，间隔1秒
```

**🔸 格式化输出**
```bash
# CSV格式输出
redis-cli --csv MGET key1 key2 key3

# 原始输出（不转义）
redis-cli --raw GET chinese_text

# JSON格式输出（Redis 7.0+）
redis-cli --json GET user:profile
```

**🔸 管道模式**
```bash
# 使用管道提高性能
printf "SET key1 value1\r\nSET key2 value2\r\nGET key1\r\n" | redis-cli --pipe

# 批量导入数据示例
for i in {1..1000}; do
  echo "SET key$i value$i"
done | redis-cli --pipe
```

### 7.3 其他Redis工具


**🔸 redis-benchmark - 性能测试**
```bash
# 基本性能测试
redis-benchmark

# 自定义测试参数
redis-benchmark -h localhost -p 6379 -c 100 -n 10000
# -c 100: 100个并发连接
# -n 10000: 总共10000个请求

# 测试特定命令
redis-benchmark -t SET,GET -n 100000

# 测试特定数据大小
redis-benchmark -d 1024    # 1KB数据包大小

# 安静模式（只显示结果）
redis-benchmark -q
```

**🔸 redis-check-aof - AOF文件检查**
```bash
# 检查AOF文件完整性
redis-check-aof appendonly.aof

# 修复损坏的AOF文件
redis-check-aof --fix appendonly.aof
```

**🔸 redis-check-rdb - RDB文件检查**
```bash
# 检查RDB文件
redis-check-rdb dump.rdb
```

### 7.4 实时监控工具


**🔸 实时命令监控**
```bash
# 监控所有执行的命令
redis-cli MONITOR

# 输出示例：
# 1609459200.123456 [0 127.0.0.1:54327] "SET" "name" "value"
# 1609459201.234567 [0 127.0.0.1:54327] "GET" "name"

# 解释：
# 时间戳 [数据库号 客户端地址] "命令" "参数1" "参数2"
```

**🔸 实时统计监控**
```bash
# 实时查看Redis统计信息
redis-cli -r -1 -i 1 INFO stats | grep ops

# 实时查看内存使用
redis-cli -r -1 -i 1 INFO memory | grep used_memory_human

# 自定义监控脚本
#!/bin/bash
while true; do
  echo "=== $(date) ==="
  redis-cli INFO stats | grep instantaneous_ops_per_sec
  redis-cli INFO memory | grep used_memory_human
  sleep 5
done
```

---

## 8. 📊 性能监控与调优


### 8.1 性能指标监控


**🔸 关键性能指标**
```bash
# 查看操作统计
127.0.0.1:6379> INFO stats
# 重要指标：
# total_commands_processed: 总命令数
# instantaneous_ops_per_sec: 每秒操作数
# keyspace_hits: 命中次数
# keyspace_misses: 未命中次数
# expired_keys: 过期键数量

# 内存使用监控
127.0.0.1:6379> INFO memory
# 重要指标：
# used_memory_human: 已使用内存
# used_memory_peak_human: 内存峰值
# mem_fragmentation_ratio: 内存碎片率

# 连接统计
127.0.0.1:6379> INFO clients
# 重要指标：
# connected_clients: 当前连接数
# blocked_clients: 阻塞客户端数
```

### 8.2 慢查询分析


**🔸 慢查询配置**
```bash
# 设置慢查询阈值（微秒）
CONFIG SET slowlog-log-slower-than 10000  # 10ms

# 设置慢查询日志最大长度
CONFIG SET slowlog-max-len 128

# 查看当前配置
CONFIG GET slowlog*
```

**🔸 慢查询分析**
```bash
# 查看慢查询日志
SLOWLOG GET 10

# 输出示例：
# 1) 1) (integer) 14    # 日志ID
#    2) (integer) 1309448221    # 时间戳
#    3) (integer) 15    # 执行时间（微秒）
#    4) 1) "ping"       # 命令和参数

# 查看慢查询数量
SLOWLOG LEN

# 清空慢查询日志
SLOWLOG RESET
```

### 8.3 命令执行优化


**🔸 命令选择建议**
```bash
# 避免使用的命令（生产环境）
KEYS *          # 使用SCAN代替
FLUSHDB         # 使用FLUSHDB ASYNC
FLUSHALL        # 使用FLUSHALL ASYNC
DEL large_key   # 使用UNLINK代替

# 推荐使用的命令
SCAN 0 MATCH pattern*  # 渐进式扫描
UNLINK key            # 异步删除
EXISTS key            # 检查存在性
MEMORY USAGE key      # 内存使用分析
```

**🔸 批量操作优化**
```bash
# 批量操作提高效率
MGET key1 key2 key3   # 批量获取
MSET key1 val1 key2 val2  # 批量设置

# 使用管道
redis-cli --pipe < batch_commands.txt

# 避免循环中的单个操作
# 不好的做法：
for i in {1..1000}; do
  redis-cli SET key$i value$i
done

# 好的做法：
for i in {1..1000}; do
  echo "SET key$i value$i"
done | redis-cli --pipe
```

### 8.4 内存优化


**🔸 内存使用分析**
```bash
# 查看具体键的内存使用
MEMORY USAGE key [SAMPLES count]

# 内存使用统计
MEMORY STATS

# 内存清理
MEMORY PURGE  # 手动触发内存清理
```

**🔸 过期策略优化**
```bash
# 查看过期相关配置
CONFIG GET *expire*
CONFIG GET *eviction*

# 设置内存策略
CONFIG SET maxmemory 1gb
CONFIG SET maxmemory-policy allkeys-lru

# 过期策略说明：
# noeviction: 不删除，写满时返回错误
# allkeys-lru: 删除最近最少使用的键
# volatile-lru: 在设置了过期时间的键中删除LRU
# allkeys-random: 随机删除键
# volatile-random: 在设置了过期时间的键中随机删除
# volatile-ttl: 删除即将过期的键
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基础操作


**🔸 连接操作**
```bash
redis-cli                    # 连接本地Redis
redis-cli -h host -p port    # 连接远程Redis
PING                         # 测试连接
AUTH password                # 密码认证
```

**🔸 键管理命令**
```bash
KEYS pattern    # 查找键（开发测试用）
SCAN cursor     # 安全的键遍历
EXISTS key      # 检查键是否存在
DEL key         # 删除键
UNLINK key      # 异步删除
TYPE key        # 查看键类型
RENAME old new  # 重命名键
```

**🔸 过期管理**
```bash
EXPIRE key seconds    # 设置过期时间
PEXPIRE key ms       # 毫秒级过期时间
TTL key              # 查看剩余时间
PTTL key             # 毫秒级剩余时间
PERSIST key          # 取消过期
```

**🔸 字符串操作**
```bash
SET key value        # 设置字符串
GET key              # 获取字符串
MSET k1 v1 k2 v2    # 批量设置
MGET k1 k2 k3       # 批量获取
INCR key            # 数值递增
APPEND key value    # 追加字符串
STRLEN key          # 字符串长度
```

### 9.2 关键理解要点


**🔹 客户端的作用**
```
Redis客户端是你和Redis数据库沟通的工具
就像遥控器和电视机的关系
没有遥控器，电视机再好也没法操作
```

**🔹 命令执行机制**
```
你输入命令 → 客户端发送给Redis → Redis执行 → 返回结果 → 客户端显示
整个过程就像：你说话 → 翻译官翻译 → 外国人理解 → 外国人回答 → 翻译官翻译回来
```

**🔹 过期时间的价值**
```
自动清理机制，避免垃圾数据堆积
特别适合：验证码、会话、缓存等临时数据
就像：设定闹钟提醒自己删除不需要的文件
```

**🔹 KEYS vs SCAN的区别**
```
KEYS像是把整个仓库翻一遍找东西，会把仓库搞乱
SCAN像是一点一点慢慢找，不会影响仓库正常运作
生产环境必须用SCAN，开发测试可以用KEYS
```

### 9.3 实际应用建议


**🎯 开发环境使用**
```
学习阶段：多用redis-cli练习命令
开发阶段：用编程语言客户端集成到项目
测试阶段：使用图形化工具查看数据
生产环境：配置连接池，做好错误处理
```

**⚠️ 生产环境注意事项**
```
1. 避免使用KEYS *（会阻塞Redis）
2. 设置合理的过期时间（避免内存泄漏）
3. 使用UNLINK代替DEL删除大键
4. 监控慢查询日志和内存使用
5. 设置最大内存限制和淘汰策略
```

**💡 性能优化要点**
```
1. 使用批量操作（MGET、MSET）
2. 使用管道减少网络往返
3. 避免大键（split large objects）
4. 合理设置过期时间
5. 监控关键指标
```

### 9.4 常用命令速查表


| 命令类型 | **命令** | **作用** | **示例** |
|---------|---------|---------|---------|
| **连接** | `PING` | `测试连接` | `PING` |
| **键管理** | `EXISTS` | `检查键存在` | `EXISTS user:1001` |
| **键管理** | `DEL` | `删除键` | `DEL user:1001` |
| **键管理** | `KEYS` | `查找键` | `KEYS user:*` |
| **键管理** | `SCAN` | `安全遍历` | `SCAN 0 MATCH user:*` |
| **过期** | `EXPIRE` | `设置过期` | `EXPIRE key 60` |
| **过期** | `TTL` | `查看过期时间` | `TTL key` |
| **字符串** | `SET` | `设置值` | `SET name "张三"` |
| **字符串** | `GET` | `获取值` | `GET name` |
| **字符串** | `INCR` | `递增` | `INCR counter` |
| **数据库** | `SELECT` | `切换数据库` | `SELECT 1` |
| **数据库** | `DBSIZE` | `键数量` | `DBSIZE` |
| **服务器** | `INFO` | `服务器信息` | `INFO memory` |

### 9.5 学习建议


**🔸 循序渐进的学习路径**
```
第1步：熟练使用redis-cli连接和基本命令
第2步：理解每个命令的作用和返回值含义
第3步：掌握键的生命周期管理（创建→使用→过期→删除）
第4步：学会使用监控命令分析性能
第5步：了解生产环境的最佳实践
```

**🔸 实践建议**
```
1. 多在redis-cli中练习命令
2. 观察命令的返回值含义
3. 尝试不同的参数组合
4. 使用MONITOR观察命令执行
5. 练习批量操作提高效率
```

**🧠 记忆口诀**:
```
"连接用PING测试通，EXISTS检查键存否
DEL删除要谨慎，EXPIRE设置自动清
KEYS查找需小心，SCAN遍历更安全
TTL时间要记清，TYPE类型先确认
批量操作效率高，监控指标不能少"
```

**核心记忆**：
- Redis客户端是操作Redis的必要工具
- 基本命令要熟练，特别是键管理和过期设置  
- 生产环境要谨慎，性能监控不可少
- 批量操作效率高，命令选择要合适