---
title: 5、Redis集群扩容缩容和数据迁移
---
## 📚 目录

1. [集群扩容缩容概述](#1-集群扩容缩容概述)
2. [在线扩容流程详解](#2-在线扩容流程详解)
3. [槽位迁移机制](#3-槽位迁移机制)
4. [数据迁移实战操作](#4-数据迁移实战操作)
5. [缩容操作流程](#5-缩容操作流程)
6. [迁移过程异常处理](#6-迁移过程异常处理)
7. [性能优化策略](#7-性能优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 集群扩容缩容概述


### 1.1 什么是集群扩容缩容


**📝 通俗理解**
```
集群扩容：往现有的Redis集群里添加新的服务器节点
集群缩容：从Redis集群中移除不需要的服务器节点

生活类比：
扩容 = 餐厅生意好，增加桌子和服务员
缩容 = 生意清淡，减少桌子和服务员
目标：保证服务不中断，合理利用资源
```

### 1.2 为什么需要扩容缩容


**🔸 扩容的场景**
```
业务增长：用户量激增，数据量快速增长
性能瓶颈：现有节点CPU、内存压力大
容量不足：存储空间即将用完
高可用需求：增加冗余节点提高可靠性

实际例子：
双11期间订单量暴增 → 需要紧急扩容
新功能上线用户活跃 → 预防性扩容
```

**🔸 缩容的场景**
```
业务萎缩：用户量下降，资源闲置
成本优化：减少不必要的硬件开销
架构调整：重新规划集群规模
季节性波动：促销结束后流量回落

实际例子：
活动结束流量回落 → 释放临时扩容的节点
业务重构后数据量减少 → 合理缩减规模
```

### 1.3 集群操作的核心原理


**💡 基本原理**
```
Redis集群通过哈希槽（slot）来分配数据
总共16384个槽位，每个节点负责一部分槽位
扩容/缩容的本质就是重新分配这些槽位

槽位分配示例：
3个节点的集群：
节点A：0-5461号槽位 (5462个)
节点B：5462-10922号槽位 (5461个)  
节点C：10923-16383号槽位 (5461个)

扩容到4个节点后：
节点A：0-4095号槽位 (4096个)
节点B：4096-8191号槽位 (4096个)
节点C：8192-12287号槽位 (4096个)
节点D：12288-16383号槽位 (4096个)
```

**🔸 数据迁移流程图**
```
旧节点                     新节点
 ┌─────┐                  ┌─────┐
 │ 槽位│ ────数据迁移───▶  │ 槽位│
 │5000 │                  │5000 │
 └─────┘                  └─────┘
    │                        │
    ▼                        ▼
  更新路由                  接管服务
```

---

## 2. 🚀 在线扩容流程详解


### 2.1 扩容前准备工作


**🔸 环境检查**
```bash
# 1. 检查当前集群状态
redis-cli -c -h 192.168.1.101 -p 7001
127.0.0.1:7001> CLUSTER NODES
# 确认所有节点状态正常

# 2. 检查集群信息
127.0.0.1:7001> CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0

# 3. 检查内存使用情况
127.0.0.1:7001> INFO memory
# 确认是否真的需要扩容
```

**🔸 新节点准备**
```bash
# 1. 准备新服务器（假设IP：192.168.1.104）
# 2. 安装Redis并配置集群模式
# redis.conf关键配置：
port 7001
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000

# 3. 启动新节点
redis-server /etc/redis/redis.conf

# 4. 验证新节点启动正常
redis-cli -h 192.168.1.104 -p 7001 ping
```

### 2.2 新节点加入集群


**🔸 添加主节点**
```bash
# 使用任意现有节点将新节点加入集群
redis-cli --cluster add-node 192.168.1.104:7001 192.168.1.101:7001

# 命令格式说明：
# add-node 新节点IP:端口 集群中任意现有节点IP:端口

# 成功输出示例：
>>> Adding node 192.168.1.104:7001 to cluster 192.168.1.101:7001
>>> Performing Cluster Check (using node 192.168.1.101:7001)
M: 40b99f2c625329c1... 192.168.1.101:7001
   slots:0-5461 (5462 slots) master
M: 40b99f2c625329c2... 192.168.1.102:7001  
   slots:5462-10922 (5461 slots) master
M: 40b99f2c625329c3... 192.168.1.103:7001
   slots:10923-16383 (5461 slots) master
>>> Send CLUSTER MEET to node 192.168.1.104:7001 to make it join the cluster.
[OK] New node added correctly.
```

**🔸 验证节点加入**
```bash
# 检查新节点是否成功加入
redis-cli -c -h 192.168.1.101 -p 7001
127.0.0.1:7001> CLUSTER NODES

# 应该能看到新节点，但还没有分配槽位：
# 40b99f2c625329c4... 192.168.1.104:7001 master - 0 0 0 connected

# 新节点现在是空的，没有分配任何槽位
```

### 2.3 槽位重新分配


**🔸 制定槽位分配计划**
```
原始3节点分配：
节点A (101)：0-5461 (5462个槽位)
节点B (102)：5462-10922 (5461个槽位)  
节点C (103)：10923-16383 (5461个槽位)

扩容到4节点后的目标分配：
节点A (101)：0-4095 (4096个槽位)     # 减少1366个
节点B (102)：4096-8191 (4096个槽位)  # 减少1365个
节点C (103)：8192-12287 (4096个槽位) # 减少1365个
节点D (104)：12288-16383 (4096个槽位) # 新增4096个

迁移计划：
从节点A迁移：5095-5461槽位（367个）到节点D
从节点B迁移：8192-10922槽位（2731个）到节点D  
从节点C迁移：12288-16383槽位（4096个）到节点D
```

**🔸 执行槽位重分配**
```bash
# 使用Redis自带的重分配工具
redis-cli --cluster reshard 192.168.1.101:7001

# 交互式操作：
How many slots do you want to move (from 1 to 16384)? 4096
# 输入要迁移的槽位数量

What is the receiving node ID? 40b99f2c625329c4
# 输入目标节点ID（新节点）

Please enter all the source node IDs.
  Type 'all' to use all the master nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1: all
# 输入all表示从所有现有节点平均迁移

Do you want to proceed with the proposed reshard plan (yes/no)? yes
# 确认执行重分配计划
```

### 2.4 扩容完成验证


**🔸 验证扩容结果**
```bash
# 1. 检查集群状态
127.0.0.1:7001> CLUSTER INFO
cluster_state:ok    # 确认集群状态正常

# 2. 检查节点分配
127.0.0.1:7001> CLUSTER NODES
# 确认新节点已分配到槽位

# 3. 测试数据访问
127.0.0.1:7001> SET test:key "test_value"
OK
127.0.0.1:7001> GET test:key  
"test_value"    # 数据访问正常

# 4. 检查数据分布
redis-cli --cluster info 192.168.1.101:7001
# 查看每个节点的槽位分配和键数量
```

---

## 3. 🔄 槽位迁移机制


### 3.1 槽位迁移原理


**📝 迁移过程理解**
```
槽位迁移就像搬家：
把一个房间（槽位）的所有东西（数据）
从旧房子（源节点）搬到新房子（目标节点）
搬家过程中要保证东西不丢失，还能正常使用

技术原理：
1. 标记槽位为迁移状态
2. 逐个迁移槽位中的键
3. 更新集群路由信息
4. 完成迁移，移除旧槽位
```

### 3.2 槽位状态管理


**🔸 槽位的三种状态**
```
STABLE（稳定）：槽位正常服务，数据完整
MIGRATING（迁出）：正在把数据迁移到其他节点
IMPORTING（导入）：正在从其他节点接收数据

状态转换图：
[STABLE] ─设置迁移─▶ [MIGRATING] ─迁移完成─▶ [STABLE]
    ▲                     │
    │                     ▼
    └─────────────── [IMPORTING] ◀─设置导入─ [STABLE]
```

**🔸 设置槽位状态**
```bash
# 在源节点设置槽位为迁出状态
CLUSTER SETSLOT slot_number MIGRATING target_node_id

# 在目标节点设置槽位为导入状态  
CLUSTER SETSLOT slot_number IMPORTING source_node_id

# 示例：迁移5000号槽位
# 在源节点(192.168.1.101)执行：
127.0.0.1:7001> CLUSTER SETSLOT 5000 MIGRATING 40b99f2c625329c4
OK

# 在目标节点(192.168.1.104)执行：
127.0.0.1:7001> CLUSTER SETSLOT 5000 IMPORTING 40b99f2c625329c1  
OK
```

### 3.3 具体数据迁移过程


**🔸 获取槽位中的键**
```bash
# 获取指定槽位中的所有键
CLUSTER GETKEYSINSLOT slot_number count

# 示例：获取5000号槽位的前100个键
127.0.0.1:7001> CLUSTER GETKEYSINSLOT 5000 100
1) "user:8192"
2) "user:8256" 
3) "session:abc123"
# ... 更多键
```

**🔸 迁移具体的键**
```bash
# 迁移单个键到目标节点
MIGRATE target_ip target_port key destination_db timeout

# 示例：迁移user:8192到新节点
127.0.0.1:7001> MIGRATE 192.168.1.104 7001 user:8192 0 5000
OK

# 参数说明：
# 192.168.1.104: 目标节点IP
# 7001: 目标节点端口
# user:8192: 要迁移的键
# 0: 目标数据库号
# 5000: 超时时间（毫秒）
```

**🔸 完成槽位迁移**
```bash
# 当槽位中所有键都迁移完成后，更新槽位归属

# 在集群中所有节点执行：
CLUSTER SETSLOT slot_number NODE target_node_id

# 示例：
127.0.0.1:7001> CLUSTER SETSLOT 5000 NODE 40b99f2c625329c4
OK

# 这个命令告诉集群：5000号槽位现在归新节点管理
```

### 3.4 迁移过程中的服务可用性


**💡 服务不中断机制**
```
迁移过程中如何保证服务不中断？

1. 重定向机制：
   - 客户端访问正在迁移的槽位
   - 源节点检查键是否还在本地
   - 如果键已迁移，返回MOVED重定向
   - 客户端重新向目标节点请求

2. ASK重定向：
   - 对于正在迁移但还未完成的槽位
   - 源节点返回ASK重定向
   - 客户端临时向目标节点请求
   - 目标节点临时处理请求

迁移中的请求处理流程：
客户端 ──GET user:8192──▶ 源节点
                         │
                         ▼ (键已迁移)
                    返回MOVED 5000 新节点IP:端口
                         │
客户端 ──重新请求─────▶ 目标节点 ──返回数据──▶ 客户端
```

---

## 4. 📦 数据迁移实战操作


### 4.1 手动迁移步骤


**🔸 完整的手动迁移流程**
```bash
# 假设要迁移5000号槽位从节点A到节点D

# 步骤1：在目标节点设置导入状态
redis-cli -h 192.168.1.104 -p 7001
127.0.0.1:7001> CLUSTER SETSLOT 5000 IMPORTING 源节点ID
OK

# 步骤2：在源节点设置迁出状态  
redis-cli -h 192.168.1.101 -p 7001
127.0.0.1:7001> CLUSTER SETSLOT 5000 MIGRATING 目标节点ID
OK

# 步骤3：获取槽位中的所有键
127.0.0.1:7001> CLUSTER GETKEYSINSLOT 5000 1000
1) "user:8192"
2) "user:8256"
3) "order:12345"
# ... 继续获取直到返回空数组

# 步骤4：逐个迁移键
127.0.0.1:7001> MIGRATE 192.168.1.104 7001 user:8192 0 5000
OK
127.0.0.1:7001> MIGRATE 192.168.1.104 7001 user:8256 0 5000
OK
# ... 迁移所有键

# 步骤5：确认槽位为空
127.0.0.1:7001> CLUSTER GETKEYSINSLOT 5000 1
(empty list or set)

# 步骤6：在所有节点更新槽位归属
redis-cli -h 192.168.1.101 -p 7001 CLUSTER SETSLOT 5000 NODE 目标节点ID
redis-cli -h 192.168.1.102 -p 7001 CLUSTER SETSLOT 5000 NODE 目标节点ID  
redis-cli -h 192.168.1.103 -p 7001 CLUSTER SETSLOT 5000 NODE 目标节点ID
redis-cli -h 192.168.1.104 -p 7001 CLUSTER SETSLOT 5000 NODE 目标节点ID
```

### 4.2 自动化迁移工具


**🔸 使用redis-cli工具**
```bash
# Redis官方提供的自动化工具
redis-cli --cluster reshard 192.168.1.101:7001

# 工具会引导你完成以下步骤：

# 1. 输入要迁移的槽位数量
How many slots do you want to move (from 1 to 16384)? 4096

# 2. 输入目标节点ID  
What is the receiving node ID? 40b99f2c625329c4...

# 3. 选择源节点
Please enter all the source node IDs.
Source node #1: all    # 从所有节点平均迁移
Source node #2: done

# 4. 确认迁移计划
Moving slot 0 from 192.168.1.101:7001
Moving slot 1 from 192.168.1.101:7001
...
Do you want to proceed with the proposed reshard plan (yes/no)? yes

# 5. 工具自动执行迁移
Moving slot 0 from 192.168.1.101:7001 to 192.168.1.104:7001: ..
Moving slot 1 from 192.168.1.101:7001 to 192.168.1.104:7001: ..
```

### 4.3 数据一致性保证


**🔸 迁移中的数据一致性**
```
问题：迁移过程中数据可能发生变化怎么办？

Redis的解决方案：
1. 迁移是键级别的原子操作
2. MIGRATE命令保证键的完整迁移
3. 迁移完成前，源节点仍然处理该键的请求
4. 迁移完成后，源节点删除该键

具体过程：
时刻T1：client写入key1到源节点
时刻T2：开始迁移key1  
时刻T3：client读取key1，源节点正常返回
时刻T4：迁移完成，key1在目标节点
时刻T5：client再次读取key1，源节点返回MOVED重定向
```

**🔸 迁移失败处理**
```bash
# 如果MIGRATE命令失败，键不会被删除
127.0.0.1:7001> MIGRATE 192.168.1.104 7001 user:8192 0 5000
IOERR error or timeout writing to target instance

# 失败原因可能：
# - 网络问题
# - 目标节点宕机  
# - 超时设置太小

# 处理方法：
# 1. 检查网络连接
# 2. 确认目标节点状态
# 3. 适当增加超时时间
# 4. 重新执行MIGRATE命令
```

### 4.4 监控迁移进度


**🔸 查看迁移状态**
```bash
# 查看集群槽位分配状态
redis-cli --cluster info 192.168.1.101:7001

# 输出示例：
192.168.1.101:7001 (40b99f2c...) -> 3000 keys | 4096 slots | 0 slaves.
192.168.1.102:7001 (40b99f2c...) -> 3000 keys | 4096 slots | 0 slaves.
192.168.1.103:7001 (40b99f2c...) -> 3000 keys | 4096 slots | 0 slaves.  
192.168.1.104:7001 (40b99f2c...) -> 3000 keys | 4096 slots | 0 slaves.
[OK] All nodes agree about slots configuration.

# 检查特定槽位状态
127.0.0.1:7001> CLUSTER NODES
# 查看每个节点负责的槽位范围
```

---

## 5. 📉 缩容操作流程


### 5.1 缩容前检查


**🔸 确定缩容目标**
```bash
# 1. 确认要移除的节点
redis-cli -c -h 192.168.1.104 -p 7001
127.0.0.1:7001> CLUSTER NODES
# 假设要移除192.168.1.104这个节点

# 2. 检查节点负责的槽位
127.0.0.1:7001> CLUSTER NODES | grep 192.168.1.104
# 查看该节点管理的槽位范围

# 3. 确认集群有足够的节点
# 集群至少需要3个主节点才能正常工作
```

### 5.2 槽位数据迁出


**🔸 将数据迁移到其他节点**
```bash
# 使用reshard工具迁移槽位
redis-cli --cluster reshard 192.168.1.101:7001

# 迁移设置：
How many slots do you want to move (from 1 to 16384)? 4096
# 要迁移的槽位数（待移除节点的所有槽位）

What is the receiving node ID? 40b99f2c625329c1  
# 目标节点ID（接收槽位的节点）

Source node #1: 40b99f2c625329c4
# 源节点ID（要移除的节点）
Source node #2: done

Do you want to proceed with the proposed reshard plan (yes/no)? yes
# 确认执行
```

### 5.3 移除节点


**🔸 从集群中移除节点**
```bash
# 确认节点已经没有槽位
redis-cli -h 192.168.1.104 -p 7001
127.0.0.1:7001> CLUSTER NODES | grep myself
# 应该显示没有分配槽位

# 从集群中移除节点
redis-cli --cluster del-node 192.168.1.101:7001 要移除的节点ID

# 成功输出：
>>> Removing node 40b99f2c625329c4... from cluster 192.168.1.101:7001
>>> Sending CLUSTER FORGET messages to the cluster...
>>> SHUTDOWN the node.
```

### 5.4 缩容验证


**🔸 验证缩容结果**
```bash
# 1. 检查集群状态
127.0.0.1:7001> CLUSTER INFO
cluster_state:ok
cluster_known_nodes:3    # 节点数应该减少了

# 2. 检查节点列表
127.0.0.1:7001> CLUSTER NODES
# 应该看不到被移除的节点

# 3. 测试数据访问
127.0.0.1:7001> GET user:8192
"user_data"    # 数据仍然可以正常访问

# 4. 检查槽位重新分配
redis-cli --cluster check 192.168.1.101:7001
[OK] All nodes agree about slots configuration.
[OK] All 16384 slots covered.
```

---

## 6. 🛡️ 迁移过程异常处理


### 6.1 常见异常情况


**🔸 网络异常处理**
```bash
# 网络超时导致迁移失败
127.0.0.1:7001> MIGRATE 192.168.1.104 7001 user:8192 0 5000
IOERR error or timeout writing to target instance

# 处理方法：
# 1. 增加超时时间
127.0.0.1:7001> MIGRATE 192.168.1.104 7001 user:8192 0 10000

# 2. 检查网络连接
ping 192.168.1.104
telnet 192.168.1.104 7001

# 3. 检查目标节点状态
redis-cli -h 192.168.1.104 -p 7001 ping
```

**🔸 节点故障处理**
```bash
# 如果迁移过程中节点宕机
# 1. 检查集群状态
127.0.0.1:7001> CLUSTER NODES
# 查看哪些节点状态异常

# 2. 如果是目标节点宕机
# - 重启目标节点
# - 重新设置导入状态
# - 继续迁移过程

# 3. 如果是源节点宕机
# - 等待故障转移完成
# - 从新的主节点继续迁移
```

### 6.2 迁移回滚


**🔸 取消正在进行的迁移**
```bash
# 如果需要取消迁移，恢复槽位状态

# 在源节点取消迁出状态
127.0.0.1:7001> CLUSTER SETSLOT 5000 STABLE
OK

# 在目标节点取消导入状态
redis-cli -h 192.168.1.104 -p 7001  
127.0.0.1:7001> CLUSTER SETSLOT 5000 STABLE
OK

# 注意：已经迁移的键需要手动迁移回来
# 或者重新开始迁移过程
```

### 6.3 数据完整性验证


**🔸 迁移后数据校验**
```bash
# 1. 检查槽位键数量
redis-cli --cluster info 192.168.1.101:7001
# 对比迁移前后每个节点的键数量

# 2. 抽样验证数据  
# 随机检查一些键是否能正常访问
127.0.0.1:7001> GET user:8192
127.0.0.1:7001> GET session:abc123

# 3. 检查集群完整性
redis-cli --cluster check 192.168.1.101:7001
# 工具会检查：
# - 所有槽位都有归属
# - 没有槽位冲突
# - 主从关系正确
```

---

## 7. ⚡ 性能优化策略


### 7.1 迁移性能优化


**🔸 批量迁移优化**
```bash
# 使用pipeline批量迁移
# 不要一个一个键迁移，而是批量操作

# 获取多个键
127.0.0.1:7001> CLUSTER GETKEYSINSLOT 5000 100

# 使用脚本批量迁移
#!/bin/bash
SOURCE_NODE="192.168.1.101:7001"
TARGET_NODE="192.168.1.104:7001"  
SLOT=5000

while true; do
    # 获取槽位中的键
    KEYS=$(redis-cli -h 192.168.1.101 -p 7001 CLUSTER GETKEYSINSLOT $SLOT 100)
    
    if [ -z "$KEYS" ]; then
        echo "槽位 $SLOT 迁移完成"
        break
    fi
    
    # 批量迁移
    for key in $KEYS; do
        redis-cli -h 192.168.1.101 -p 7001 MIGRATE 192.168.1.104 7001 $key 0 5000
    done
    
    echo "已迁移一批键，继续..."
done
```

**🔸 迁移时机选择**
```
最佳迁移时机：
1. 业务低峰期（夜间、周末）
2. 服务器负载较低时
3. 网络质量较好时

避免迁移的时机：
1. 业务高峰期
2. 系统负载很高时
3. 网络不稳定时
4. 正在进行其他维护操作时
```

### 7.2 迁移速度控制


**🔸 控制迁移对业务的影响**
```bash
# 1. 调整迁移超时时间
# 较短的超时：减少阻塞时间，但可能增加重试
# 较长的超时：减少重试，但可能增加阻塞时间
MIGRATE target_ip target_port key 0 1000  # 1秒超时

# 2. 分批次迁移
# 不要一次迁移太多槽位，分多次进行
redis-cli --cluster reshard --cluster-slots 1000  # 一次迁移1000个槽位

# 3. 限流控制
# 在迁移脚本中添加延迟
#!/bin/bash
for key in $keys; do
    redis-cli MIGRATE ...
    sleep 0.01  # 每迁移一个键暂停10ms
done
```

### 7.3 监控迁移影响


**🔸 监控关键指标**
```bash
# 1. 监控延迟
redis-cli -h 192.168.1.101 -p 7001 --latency

# 2. 监控命令执行情况
redis-cli -h 192.168.1.101 -p 7001 MONITOR

# 3. 监控内存使用
redis-cli -h 192.168.1.101 -p 7001 -r -1 -i 1 INFO memory | grep used_memory_human

# 4. 监控连接数
redis-cli -h 192.168.1.101 -p 7001 -r -1 -i 1 INFO clients | grep connected_clients
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 集群扩容缩容本质**
```
扩容缩容 = 重新分配16384个哈希槽位
数据跟着槽位走，槽位分配决定数据分布
扩容：原有槽位分一部分给新节点
缩容：要移除节点的槽位分给其他节点
```

**🔸 关键命令理解**
```bash
CLUSTER SETSLOT    # 设置槽位状态（迁出/导入/归属）
MIGRATE           # 迁移具体的键到目标节点  
CLUSTER GETKEYSINSLOT  # 获取槽位中的键
CLUSTER NODES     # 查看集群节点和槽位分配
```

**🔸 迁移状态理解**
```
MIGRATING：源节点状态，正在迁出数据
IMPORTING：目标节点状态，正在接收数据
STABLE：正常状态，槽位归属明确

状态转换必须配对：源节点MIGRATING + 目标节点IMPORTING
```

### 8.2 关键理解要点


**🔹 为什么在线迁移不影响服务**
```
秘密武器：重定向机制

客户端请求流程：
1. 客户端向源节点请求数据
2. 如果键已迁移，源节点返回MOVED重定向
3. 客户端重新向目标节点请求
4. 目标节点返回数据

就像：你去老地址找朋友，门卫告诉你"他搬到新地址了"
你再去新地址就能找到朋友了
```

**🔹 数据迁移的原子性**
```
MIGRATE命令保证：
- 要么迁移成功（源删除，目标创建）
- 要么迁移失败（源保留，目标不变）
- 不会出现数据丢失或重复

就像搬家：
- 要么东西成功搬到新家（旧家清空）
- 要么搬家失败（东西还在旧家）
- 不会出现东西丢了或者两边都有的情况
```

**🔹 槽位分配的均衡性**
```
扩容目标：让每个节点负责的槽位数尽量相等
16384个槽位，n个节点，每个节点约 16384/n 个槽位

3节点：每个约5461个槽位
4节点：每个约4096个槽位  
5节点：每个约3276个槽位

自动工具会帮你算好，手动操作时要注意均衡
```

### 8.3 实际操作指导


**🎯 扩容操作流程**
```
1. 准备新节点 → 安装Redis，配置集群模式
2. 加入集群 → 使用add-node命令
3. 重分配槽位 → 使用reshard工具或手动迁移
4. 验证结果 → 检查集群状态和数据访问
```

**🎯 缩容操作流程**  
```
1. 迁移数据 → 将待移除节点的槽位迁移到其他节点
2. 移除节点 → 使用del-node命令
3. 验证结果 → 检查集群状态和数据访问
```

**⚠️ 重要注意事项**
```
1. 扩容缩容要在业务低峰期进行
2. 迁移前要备份重要数据
3. 迁移过程要监控集群状态
4. 出现异常要及时停止并分析原因
5. 主从节点要一起操作（先操作从节点）
```

**💡 最佳实践建议**
```
1. 使用官方工具（redis-cli --cluster）
2. 分批次迁移，避免一次迁移过多
3. 监控迁移过程的性能指标
4. 制定详细的回滚计划
5. 在测试环境先验证操作流程
```

### 8.4 故障排除指南


**🔸 常见问题及解决方法**

| 问题现象 | **可能原因** | **解决方法** |
|---------|------------|-------------|
| `槽位迁移卡住` | `网络延迟高` | `增加MIGRATE超时时间` |
| `节点加入失败` | `防火墙阻断` | `检查端口开放情况` |
| `数据访问异常` | `槽位状态不一致` | `执行CLUSTER SETSLOT STABLE` |
| `集群状态fail` | `节点间通信失败` | `检查集群总线端口(port+10000)` |
| `迁移后数据丢失` | `迁移过程中断` | `检查源节点是否还有数据` |

**🔸 应急处理步骤**
```bash
# 1. 立即检查集群状态
redis-cli --cluster check 集群中任意节点:端口

# 2. 如果集群状态异常，检查问题节点
127.0.0.1:7001> CLUSTER NODES
# 查看哪些节点状态为fail或pfail

# 3. 修复网络或重启异常节点

# 4. 如果槽位状态异常，手动修复
127.0.0.1:7001> CLUSTER SETSLOT 槽位号 STABLE

# 5. 重新检查集群完整性
redis-cli --cluster fix 集群中任意节点:端口
```

**🧠 操作记忆口诀**:
```
"扩容先加节点后分槽，缩容先迁数据再移除
槽位状态要配对，迁移过程多监控
网络异常增超时，数据校验保完整
集群工具最安全，手动操作需谨慎"
```

**核心记忆**：
- 扩容缩容的核心是槽位重新分配
- 在线迁移通过重定向机制保证服务不中断
- 数据迁移是键级别的原子操作
- 使用官方工具比手动操作更安全可靠
- 迁移过程要监控，异常情况要及时处理