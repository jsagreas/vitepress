---
title: 6、Redis集群客户端路由和重定向
---
## 📚 目录

1. [集群路由机制](#1-集群路由机制)
2. [重定向处理](#2-重定向处理)
3. [客户端集群支持](#3-客户端集群支持)
4. [性能优化策略](#4-性能优化策略)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🗺️ 集群路由机制


### 1.1 什么是集群路由


**💡 简单理解**：想象Redis集群是一个大型图书馆，有很多个区域（节点），每本书（数据）都有固定的存放位置。客户端就像读者，需要知道要找的书在哪个区域。

```
传统单机Redis：
客户端 → Redis服务器
         (所有数据都在这里)

Redis集群：
客户端 → 需要找对节点 → 正确的Redis节点
         |              |
         |              ├─ 节点1 (槽位0-5460)
         |              ├─ 节点2 (槽位5461-10922) 
         └──路由算法────┤ 节点3 (槽位10923-16383)
```

### 1.2 客户端路由算法


**🔍 槽位计算过程**
```
步骤1：计算key的哈希值
CRC16(key) = hash_value

步骤2：对16384取模得到槽位
slot = hash_value % 16384

步骤3：根据槽位找到对应节点
if slot in 0-5460:     → 节点1
if slot in 5461-10922: → 节点2  
if slot in 10923-16383:→ 节点3
```

**🎯 实际示例**
```bash
# 假设要存储 key="user:1001"
CRC16("user:1001") = 31665
槽位 = 31665 % 16384 = 15281
15281 在 10923-16383 范围内 → 路由到节点3

# 客户端直接连接节点3执行
SET user:1001 "张三"
```

### 1.3 智能客户端 vs 代理模式


**🤖 智能客户端模式**
```
特点：客户端自己知道每个槽位在哪个节点
优势：直接路由，性能最高，无额外网络跳转
工作流程：
┌─────────┐    直接路由    ┌─────────┐
│ 客户端  │ ────────────→ │ 节点1   │
│(知道槽位)│               │(槽0-5460)│
└─────────┘               └─────────┘
```

**🚪 代理模式**
```
特点：通过代理服务器转发请求
优势：客户端简单，无需了解集群拓扑
工作流程：
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 客户端  │ →  │ 代理    │ →  │ 节点1   │
│(不知道  │    │(路由)   │    │(槽0-5460)│
│ 槽位)   │    └─────────┘    └─────────┘
└─────────┘
```

**📊 两种模式对比**

| 特性 | 智能客户端 | 代理模式 |
|------|-----------|---------|
| **性能** | `高（直接路由）` | `中（多一跳）` |
| **复杂度** | `高（需维护拓扑）` | `低（代理处理）` |
| **网络延迟** | `低` | `高` |
| **故障处理** | `客户端处理` | `代理处理` |
| **适用场景** | `高性能应用` | `简单应用` |

---

## 2. 🔄 重定向处理


### 2.1 为什么需要重定向


**💡 场景说明**：Redis集群是动态的，槽位会因为扩容、缩容、故障恢复等原因发生迁移。

```
问题场景：
客户端认为槽位1000在节点A，但实际已经迁移到节点B
客户端 → 节点A → 返回重定向信息 → 客户端重新请求节点B
```

### 2.2 MOVED重定向


**🔄 MOVED重定向含义**：槽位已经**永久迁移**到新节点

```bash
# 客户端请求
GET user:1001

# 节点A响应（槽位已迁移）
(error) MOVED 1000 192.168.1.12:6379

# 响应解读
MOVED：重定向类型
1000：槽位号
192.168.1.12:6379：新节点地址
```

**🔧 客户端处理流程**
```
步骤1：收到MOVED响应
步骤2：更新本地槽位映射表
       slot[1000] = 192.168.1.12:6379
步骤3：重新向正确节点发送请求
步骤4：后续相同槽位的请求直接路由到新节点
```

### 2.3 ASK重定向


**🚚 ASK重定向含义**：槽位正在**迁移过程中**，临时重定向

```bash
# 客户端请求
GET user:2001  

# 节点A响应（槽位迁移中）
(error) ASK 2000 192.168.1.12:6379

# 特殊处理：需要先发送ASKING命令
ASKING
GET user:2001
```

**📋 MOVED vs ASK 区别**

| 重定向类型 | **状态** | **客户端行为** | **槽位映射** |
|-----------|---------|---------------|-------------|
| **MOVED** | `槽位已永久迁移` | `更新槽位表，后续直接路由` | `需要更新` |
| **ASK** | `槽位迁移中` | `临时重定向，先发ASKING` | `不更新` |

### 2.4 重定向处理示例


```bash
# 场景1：MOVED重定向处理
客户端 → 节点1: GET user:1001
节点1 → 客户端: (error) MOVED 1000 192.168.1.12:6379
客户端更新：slot[1000] = 192.168.1.12:6379
客户端 → 节点2: GET user:1001
节点2 → 客户端: "张三"

# 场景2：ASK重定向处理  
客户端 → 节点1: GET user:2001
节点1 → 客户端: (error) ASK 2000 192.168.1.12:6379
客户端 → 节点2: ASKING
客户端 → 节点2: GET user:2001
节点2 → 客户端: "李四"
# 注意：槽位映射表不更新，下次还是先尝试节点1
```

---

## 3. 🎛️ 客户端集群支持


### 3.1 集群感知客户端特性


**🧠 什么是集群感知**：客户端"聪明"地知道集群的结构和状态

```
普通客户端：
只知道一个Redis地址，不知道集群存在

集群感知客户端：
┌─────────────────────────────────┐
│ 客户端内部维护的信息：            │
├─────────────────────────────────┤
│ 节点列表：192.168.1.10:6379     │
│          192.168.1.11:6379     │
│          192.168.1.12:6379     │
├─────────────────────────────────┤
│ 槽位映射：slot[0-5460] → 节点1   │
│          slot[5461-10922] → 节点2│
│          slot[10923-16383] → 节点3│
├─────────────────────────────────┤
│ 节点状态：节点1-在线，节点2-在线  │
│          节点3-故障             │
└─────────────────────────────────┘
```

**⚡ 核心特性**
- **拓扑发现**：自动发现集群中的所有节点
- **槽位映射**：维护槽位到节点的映射关系
- **故障感知**：检测节点故障并更新路由信息
- **智能路由**：直接向正确节点发送请求

### 3.2 连接池管理策略


**🏊 为什么需要连接池**：集群环境下要连接多个节点，管理连接很重要

```
单机Redis连接：
应用 → 连接池 → Redis服务器
       (5-10个连接)

集群Redis连接：
应用 → 连接池管理器 → 节点1连接池 (3-5个连接)
       |            → 节点2连接池 (3-5个连接)  
       |            → 节点3连接池 (3-5个连接)
       └─智能分配─────→ 节点4连接池 (3-5个连接)
```

**🔧 连接池管理原则**
```
✅ 每个节点独立连接池：避免连接混用
✅ 按需建立连接：只对活跃节点建立连接
✅ 故障节点处理：及时关闭故障节点连接
✅ 连接数量控制：避免过多连接消耗资源
```

### 3.3 故障转移感知


**🚨 故障检测机制**
```
检测方式：
• 连接超时：无法建立TCP连接
• 响应超时：请求发出后长时间无响应
• 错误响应：节点返回错误信息
• 心跳检测：定期ping检测节点状态

故障处理流程：
发现故障 → 标记节点不可用 → 重新获取集群拓扑 → 更新路由信息
```

**🔧 故障转移示例**
```
正常情况：
GET user:1001 → 计算槽位1000 → 路由到节点1 → 返回结果

节点1故障：
GET user:1001 → 计算槽位1000 → 节点1故障 → 重新获取拓扑
             → 发现槽位1000迁移到节点4 → 路由到节点4 → 返回结果
```

### 3.4 批量操作支持


**📦 批量操作的挑战**：不同key可能分布在不同节点上

```bash
# 批量操作示例
MGET user:1001 user:2001 user:3001

# 槽位分布可能是：
user:1001 → 槽位1000 → 节点1
user:2001 → 槽位2000 → 节点2  
user:3001 → 槽位3000 → 节点3
```

**🔧 智能批量处理**
```
客户端内部处理：
1. 将key按节点分组
   节点1：[user:1001]
   节点2：[user:2001]
   节点3：[user:3001]

2. 并行发送请求
   向节点1发送：GET user:1001
   向节点2发送：GET user:2001
   向节点3发送：GET user:3001

3. 合并结果按原始顺序返回
   [user:1001的值, user:2001的值, user:3001的值]
```

---

## 4. ⚡ 性能优化策略


### 4.1 客户端路由缓存


**🧠 路由信息缓存**：避免每次都重新计算和查询

```
优化前：每次请求都计算槽位和查找节点
GET user:1001 → 计算槽位 → 查找节点 → 发送请求

优化后：缓存路由信息
GET user:1001 → 直接使用缓存的节点信息 → 发送请求
```

**📊 缓存更新策略**
```
定期更新：
• 每隔一定时间主动更新拓扑信息
• 适合节点变化不频繁的场景

被动更新：  
• 收到MOVED/ASK重定向时更新
• 节省资源，响应及时

混合策略：
• 正常情况下被动更新
• 检测到异常时主动刷新
```

### 4.2 重定向性能优化


**🚀 减少重定向开销**
```
问题：重定向增加了额外的网络往返
GET user:1001 → 节点1 → MOVED → 客户端 → 节点2 → 结果
              (第1次网络往返)         (第2次网络往返)

优化方案：
1. 准确的槽位映射：减少重定向概率
2. 重定向信息缓存：下次直接路由正确节点
3. 批量操作优化：按节点分组减少重定向
```

### 4.3 连接复用优化


**🔌 连接管理优化**
```
连接复用策略：
┌─────────────┐    保持长连接    ┌─────────────┐
│   应用线程1  │ ─────────────── │   节点1     │
├─────────────┤                 ├─────────────┤
│   应用线程2  │ ─────────────── │   节点2     │  
├─────────────┤                 ├─────────────┤
│   应用线程3  │ ─────────────── │   节点3     │
└─────────────┘                 └─────────────┘

避免频繁建立/关闭连接的开销
```

---

## 5. 🛠️ 客户端实现要点


### 5.1 集群拓扑发现


**🔍 自动发现过程**
```bash
# 客户端启动时的发现流程
1. 连接任意一个种子节点
   CONNECT 192.168.1.10:6379

2. 获取完整集群信息  
   CLUSTER NODES
   # 返回所有节点信息和槽位分布

3. 建立到各节点的连接
   CONNECT 192.168.1.10:6379  # 主节点
   CONNECT 192.168.1.11:6379  # 主节点
   CONNECT 192.168.1.12:6379  # 主节点

4. 构建槽位映射表
   slot[0-5460] → 192.168.1.10:6379
   slot[5461-10922] → 192.168.1.11:6379  
   slot[10923-16383] → 192.168.1.12:6379
```

### 5.2 请求路由实现


**🗺️ 路由决策流程**
```
┌─────────────┐
│ 应用请求    │ GET user:1001
└─────────────┘
        │
        ▼
┌─────────────┐
│ 计算槽位    │ CRC16("user:1001") % 16384 = 1000
└─────────────┘
        │
        ▼
┌─────────────┐
│ 查找节点    │ slot[1000] → 节点1
└─────────────┘
        │
        ▼
┌─────────────┐
│ 发送请求    │ 向节点1发送GET命令
└─────────────┘
        │
        ▼
┌─────────────┐
│ 处理响应    │ 正常结果 or 重定向处理
└─────────────┘
```

### 5.3 故障恢复处理


**🔄 故障恢复流程**
```bash
# 检测到节点故障
节点1连接失败 → 标记节点1不可用 → 刷新集群拓扑

# 重新获取集群信息
CLUSTER NODES
# 发现：
# - 节点1确实故障
# - 节点1的槽位已迁移到节点4  
# - 节点4成为新的主节点

# 更新路由信息
slot[0-5460]: 节点1 → 节点4
# 后续请求自动路由到节点4
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念


```
🔸 客户端路由：客户端根据槽位计算直接找到正确节点，避免无效请求
🔸 槽位计算：CRC16(key) % 16384，确定数据存储在哪个槽位
🔸 MOVED重定向：槽位已永久迁移，客户端需更新路由表
🔸 ASK重定向：槽位迁移中，临时重定向，需要ASKING命令
🔸 集群感知：客户端维护完整的集群拓扑信息
```

### 6.2 路由和重定向对比


**📊 重定向类型对比**

| 重定向类型 | **触发场景** | **处理方式** | **路由表更新** |
|-----------|------------|-------------|---------------|
| **MOVED** | `槽位已迁移完成` | `直接重新请求新节点` | `需要更新` |
| **ASK** | `槽位正在迁移` | `发送ASKING后请求` | `不更新` |

### 6.3 实际应用指导


**🎯 客户端选择建议**
```
高性能应用：
→ 选择智能客户端
→ 自己维护路由信息
→ 直接路由，延迟最低

简单应用：
→ 选择代理模式
→ 代理处理路由复杂度
→ 开发简单，维护容易

中等应用：
→ 使用成熟的客户端库
→ 如Jedis、Lettuce等
→ 兼顾性能和易用性
```

**⚡ 性能优化要点**
```
✅ 准确维护槽位映射：减少重定向次数
✅ 合理设置连接池：每个节点独立管理
✅ 及时处理故障节点：避免请求超时
✅ 批量操作分组：按节点分组并行处理
✅ 定期刷新拓扑：保持路由信息时效性
```

**🚨 常见问题及解决**
```
问题1：频繁收到重定向
→ 检查槽位映射是否及时更新
→ 检查是否正在进行节点迁移

问题2：连接池耗尽  
→ 合理设置每个节点的连接数
→ 及时关闭故障节点连接

问题3：批量操作性能差
→ 检查是否按节点正确分组
→ 避免跨节点的大批量操作

问题4：故障恢复慢
→ 缩短拓扑刷新间隔
→ 优化故障检测机制
```

**核心记忆**：
- 集群路由靠槽位，CRC16计算要记牢
- MOVED永久ASK临时，重定向处理有差异  
- 智能客户端性能好，代理模式开发简单
- 连接池管理要合理，故障转移要及时