---
title: 4、Redis集群搭建部署实战
---
## 📚 目录

1. [集群搭建流程](#1-集群搭建流程)
2. [集群管理命令](#2-集群管理命令)
3. [节点管理操作](#3-节点管理操作)
4. [集群初始化详解](#4-集群初始化详解)
5. [槽位管理实战](#5-槽位管理实战)
6. [集群运维管理](#6-集群运维管理)
7. [故障排除指南](#7-故障排除指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ 集群搭建流程


### 1.1 集群搭建整体概念


**什么是Redis集群搭建**
搭建Redis集群就像**组建一个工作团队**：
- 每个Redis实例是一个**团队成员**
- 集群配置是**团队分工规则**
- 槽位分配是**工作任务分配**
- 集群管理是**团队协调机制**

```
单机Redis：               集群Redis：
    ┌─────┐                ┌─────┐  ┌─────┐  ┌─────┐
    │Redis│                │Node1│  │Node2│  │Node3│
    │ 全部│          →     │ 1/3 │  │ 1/3 │  │ 1/3 │
    │ 数据│                │ 数据│  │ 数据│  │ 数据│
    └─────┘                └─────┘  └─────┘  └─────┘
     单点               分布式，高可用，可扩展
```

### 1.2 节点准备和配置


**🔧 第一步：准备服务器节点**
```bash
# 规划集群节点（最少3个主节点）
节点规划：
192.168.1.11:7001  # 主节点1
192.168.1.11:7002  # 主节点2  
192.168.1.11:7003  # 主节点3
192.168.1.12:7001  # 从节点1
192.168.1.12:7002  # 从节点2
192.168.1.12:7003  # 从节点3
```

**配置文件准备**
每个节点都需要独立的配置文件 `redis-7001.conf`：
```bash
# 基础配置
port 7001                          # 当前节点端口
bind 192.168.1.11                  # 绑定IP地址
daemonize yes                      # 后台运行

# 集群相关配置
cluster-enabled yes                # 开启集群模式
cluster-config-file nodes-7001.conf   # 集群配置文件名
cluster-node-timeout 5000         # 节点超时时间（毫秒）

# 数据和日志配置
dir /data/redis/7001              # 数据目录
logfile /var/log/redis-7001.log   # 日志文件

# 性能配置
maxmemory 1gb                     # 最大内存限制
maxmemory-policy allkeys-lru      # 内存淘汰策略
```

### 1.3 集群初始化命令


**⚡ 启动所有节点**
```bash
# 依次启动每个节点
redis-server /etc/redis/redis-7001.conf
redis-server /etc/redis/redis-7002.conf  
redis-server /etc/redis/redis-7003.conf
redis-server /etc/redis/redis-7004.conf
redis-server /etc/redis/redis-7005.conf
redis-server /etc/redis/redis-7006.conf

# 检查节点启动状态
ps aux | grep redis
netstat -tlnp | grep :700
```

**🚀 执行集群初始化**
```bash
# 使用redis-cli创建集群（Redis 5.0+）
redis-cli --cluster create \
192.168.1.11:7001 \
192.168.1.11:7002 \
192.168.1.11:7003 \
192.168.1.12:7001 \
192.168.1.12:7002 \
192.168.1.12:7003 \
--cluster-replicas 1

# 参数说明：
# --cluster-replicas 1：每个主节点有1个从节点
# 会自动分配：前3个作为主节点，后3个作为从节点
```

### 1.4 槽位分配执行


**📊 槽位自动分配过程**
```
Redis集群初始化时的槽位分配：

总槽位数：16384个（0-16383）
主节点数：3个

自动分配结果：
┌─────────────────────────────────────┐
│ 节点7001：槽位 0-5460    (5461个)   │
├─────────────────────────────────────┤  
│ 节点7002：槽位 5461-10922 (5462个) │
├─────────────────────────────────────┤
│ 节点7003：槽位 10923-16383 (5461个)│
└─────────────────────────────────────┘

从节点分配：
7004 → 复制 7001
7005 → 复制 7002  
7006 → 复制 7003
```

### 1.5 集群状态验证


**✅ 验证集群是否搭建成功**
```bash
# 连接任意节点检查集群状态
redis-cli -h 192.168.1.11 -p 7001

# 查看集群信息
127.0.0.1:7001> CLUSTER INFO
cluster_state:ok                    # 集群状态正常
cluster_slots_assigned:16384        # 所有槽位已分配
cluster_slots_ok:16384             # 槽位状态正常
cluster_slots_pfail:0              # 无问题槽位
cluster_slots_fail:0               # 无失败槽位
cluster_known_nodes:6              # 集群节点数
cluster_size:3                     # 主节点数
```

**查看节点详情**
```bash
# 查看所有节点信息
127.0.0.1:7001> CLUSTER NODES
07c37dfeb2... 192.168.1.11:7001@17001 myself,master - 0 0 1 connected 0-5460
1f2da3b8c9... 192.168.1.11:7002@17002 master - 0 1577460297000 2 connected 5461-10922
a8b3d4c2e1... 192.168.1.11:7003@17003 master - 0 1577460298000 3 connected 10923-16383
e9f8c7d6a5... 192.168.1.12:7001@17001 slave 07c37dfeb2... 0 1577460299000 4 connected
```

**🎯 测试集群功能**
```bash
# 测试数据分片功能
redis-cli -h 192.168.1.11 -p 7001 -c  # -c 开启集群模式

# 存储测试数据
127.0.0.1:7001> SET user:1001 "张三"
-> Redirected to slot [1719] located at 192.168.1.11:7001
OK

127.0.0.1:7001> SET user:1002 "李四"  
-> Redirected to slot [5649] located at 192.168.1.11:7002
OK

# 数据会自动路由到对应的节点
```

---

## 2. 🎛️ 集群管理命令


### 2.1 cluster meet - 节点加入集群


**📖 命令作用**
`cluster meet` 就像**介绍朋友认识**，让一个新的Redis节点加入到现有集群中。

**🔧 语法格式**
```bash
CLUSTER MEET ip port
# ip：要加入节点的IP地址
# port：要加入节点的端口号
# 返回：OK（成功）
```

**💡 使用示例**
```bash
# 假设现有集群有3个节点，现在要加入第4个节点
# 在现有集群的任意节点上执行：

redis-cli -h 192.168.1.11 -p 7001
127.0.0.1:7001> CLUSTER MEET 192.168.1.13 7001
OK

# 新节点会自动获得集群配置信息
# 但还需要手动分配槽位或设置为从节点
```

### 2.2 cluster nodes - 查看集群状态


**📊 命令作用**
`cluster nodes` 就像查看**通讯录**，显示集群中所有成员的详细信息。

**💻 输出格式解析**
```bash
127.0.0.1:7001> CLUSTER NODES

# 输出示例：
07c37dfeb2 192.168.1.11:7001@17001 myself,master - 0 0 1 connected 0-5460
1f2da3b8c9 192.168.1.11:7002@17002 master - 0 1577460297 2 connected 5461-10922
a8b3d4c2e1 192.168.1.11:7003@17003 master - 0 1577460298 3 connected 10923-16383
```

**字段含义解释**
```
07c37dfeb2                  # 节点ID（40位16进制字符）
192.168.1.11:7001@17001    # IP:端口@集群总线端口
myself,master               # 节点角色（myself表示当前节点）
-                          # 主节点ID（从节点会显示其主节点ID）
0                          # 最后ping时间
1577460297                 # 最后pong时间
1                          # 配置纪元
connected                  # 连接状态
0-5460                     # 负责的槽位范围
```

### 2.3 cluster info - 集群信息查看


**📈 集群整体状态**
```bash
127.0.0.1:7001> CLUSTER INFO

# 输出示例：
cluster_state:ok                    # 集群状态（ok/fail）
cluster_slots_assigned:16384        # 已分配槽位数
cluster_slots_ok:16384             # 正常槽位数
cluster_slots_pfail:0              # 可能故障槽位数
cluster_slots_fail:0               # 确定故障槽位数
cluster_known_nodes:6              # 已知节点总数
cluster_size:3                     # 主节点数量
cluster_current_epoch:6            # 当前配置纪元
cluster_my_epoch:1                 # 本节点纪元
cluster_stats_messages_sent:1483   # 发送消息数
cluster_stats_messages_received:1483 # 接收消息数
```

**🔍 状态字段含义**
```
cluster_state解读：
• ok：集群运行正常，所有槽位已分配
• fail：集群有问题，部分槽位无法服务

关键数字含义：
• cluster_size：决定数据分片程度
• cluster_known_nodes：应该等于实际部署的节点数
• 发送/接收消息数：反映集群通信活跃度
```

### 2.4 cluster slots - 槽位分配查看


**🗂️ 槽位分布查询**
```bash
127.0.0.1:7001> CLUSTER SLOTS

# 输出示例（简化版）：
1) 1) (integer) 0      # 槽位起始
   2) (integer) 5460   # 槽位结束
   3) 1) "192.168.1.11"   # 主节点IP
      2) (integer) 7001   # 主节点端口
      3) "07c37dfeb2..."  # 主节点ID
   4) 1) "192.168.1.12"   # 从节点IP
      2) (integer) 7001   # 从节点端口
      3) "e9f8c7d6a5..."  # 从节点ID

2) 1) (integer) 5461
   2) (integer) 10922
   3) 1) "192.168.1.11"
      2) (integer) 7002
      3) "1f2da3b8c9..."
```

**📊 槽位分布可视化**
```
槽位分布图：
┌─────────┬─────────┬─────────┐
│ 0-5460  │5461-10922│10923-16383│
│ Node1   │ Node2    │ Node3     │
│ (主)    │ (主)     │ (主)      │
└─────────┴─────────┴─────────┘
     ↓         ↓         ↓
┌─────────┬─────────┬─────────┐
│ Node4   │ Node5    │ Node6   │
│ (从)    │ (从)     │ (从)    │
└─────────┴─────────┴─────────┘
```

---

## 3. 👥 节点管理操作


### 3.1 添加新节点（主节点）


**📈 扩容场景说明**
当现有集群容量不够时，就需要添加新的主节点，就像公司业务增长需要**招聘新员工**一样。

**🔧 添加主节点步骤**
```bash
# 第1步：准备新节点配置
# 新建 redis-7007.conf
port 7007
cluster-enabled yes
cluster-config-file nodes-7007.conf
cluster-node-timeout 5000
bind 192.168.1.13
dir /data/redis/7007

# 第2步：启动新节点
redis-server /etc/redis/redis-7007.conf

# 第3步：将新节点加入集群
redis-cli --cluster add-node 192.168.1.13:7007 192.168.1.11:7001
# 192.168.1.13:7007 是新节点
# 192.168.1.11:7001 是集群中任意现有节点

# 第4步：为新节点分配槽位（重要！）
redis-cli --cluster reshard 192.168.1.11:7001
# 会启动交互式槽位迁移向导
```

### 3.2 添加新节点（从节点）


**🔄 从节点添加流程**
添加从节点就像给每个主管**配备助手**，提供数据备份和读写分离能力。

```bash
# 第1步：启动新的Redis实例
redis-server /etc/redis/redis-7008.conf

# 第2步：加入集群作为从节点
redis-cli --cluster add-node 192.168.1.13:7008 192.168.1.11:7001 --cluster-slave

# 第3步：指定要复制的主节点（可选）
redis-cli --cluster add-node 192.168.1.13:7008 192.168.1.11:7001 \
  --cluster-slave --cluster-master-id 07c37dfeb2...

# 验证从节点状态
redis-cli -h 192.168.1.13 -p 7008
127.0.0.1:7008> CLUSTER NODES
# 应该看到新从节点已经连接到指定主节点
```

### 3.3 删除节点流程


**🗑️ 节点下线步骤**
删除节点需要谨慎操作，就像**员工离职**需要先交接工作。

**删除从节点（简单）**
```bash
# 从节点删除很简单，因为它只是备份
redis-cli --cluster del-node 192.168.1.13:7008 节点ID

# 获取节点ID
redis-cli -h 192.168.1.13 -p 7008 CLUSTER NODES | grep myself
```

**删除主节点（复杂）**
```bash
# 主节点有数据和槽位，需要先迁移

# 第1步：将主节点的槽位迁移到其他主节点
redis-cli --cluster reshard 192.168.1.11:7001
# 在交互界面中：
# - 要迁移的槽位数：5461（该主节点的所有槽位）
# - 目标节点ID：其他主节点的ID
# - 源节点ID：要删除的主节点ID

# 第2步：确认槽位迁移完成
redis-cli -h 要删除的节点 -p 端口
> CLUSTER NODES
# 确认该节点的槽位显示为空

# 第3步：删除空的主节点
redis-cli --cluster del-node 节点地址 节点ID
```

### 3.4 节点角色转换


**🔄 主从角色切换**
```bash
# 场景：主节点故障，手动切换
# 在要升级为主节点的从节点上执行：

redis-cli -h 192.168.1.12 -p 7001
127.0.0.1:7001> CLUSTER FAILOVER
OK

# 强制故障转移（危险操作）
127.0.0.1:7001> CLUSTER FAILOVER FORCE

# 查看角色变化
127.0.0.1:7001> CLUSTER NODES
# 观察节点角色是否发生变化
```

---

## 4. 🚀 集群初始化详解


### 4.1 集群初始化的本质


**🔍 初始化过程解析**
集群初始化就像**成立公司**的过程：
1. **招聘员工**（启动Redis实例）
2. **建立团队**（节点相互认识）
3. **分配工作**（分配槽位）
4. **制定规则**（配置主从关系）

```
初始化前：独立的Redis实例
┌─────┐ ┌─────┐ ┌─────┐
│7001 │ │7002 │ │7003 │  ← 各自独立运行
└─────┘ └─────┘ └─────┘

初始化后：协调工作的集群  
┌─────┐ ← → ┌─────┐ ← → ┌─────┐
│7001 │     │7002 │     │7003 │  ← 相互通信协作
└─────┘ ← → └─────┘ ← → └─────┘
```

### 4.2 手动集群初始化


**🔧 手工搭建过程（理解原理）**
```bash
# 第1步：让节点相互认识（在每个节点上执行）
redis-cli -h 192.168.1.11 -p 7001
127.0.0.1:7001> CLUSTER MEET 192.168.1.11 7002
127.0.0.1:7001> CLUSTER MEET 192.168.1.11 7003

# 第2步：分配槽位给主节点
127.0.0.1:7001> CLUSTER ADDSLOTS {0..5460}      # 给节点1分配槽位0-5460
redis-cli -h 192.168.1.11 -p 7002 CLUSTER ADDSLOTS {5461..10922}  # 节点2
redis-cli -h 192.168.1.11 -p 7003 CLUSTER ADDSLOTS {10923..16383} # 节点3

# 第3步：配置主从关系
redis-cli -h 192.168.1.12 -p 7001
127.0.0.1:7001> CLUSTER REPLICATE 07c37dfeb2...  # 成为节点7001的从节点
```

### 4.3 自动化初始化优势


**⚡ 为什么推荐自动初始化**
```
手动初始化：
• 步骤繁琐，容易出错
• 槽位分配需要计算
• 主从关系容易配置错

自动初始化：
• 一条命令完成所有配置
• 自动计算最优槽位分配
• 自动配置主从关系
• 包含错误检查和验证

建议：生产环境使用自动初始化，学习阶段了解手动过程
```

---

## 5. 🎯 槽位管理实战


### 5.1 槽位迁移基础


**🚚 槽位迁移就像搬家**
```
原理说明：
就像把一个部门的工作转移给另一个部门

搬家前：
部门A负责：客户1-1000
部门B负责：客户1001-2000

搬家后：
部门A负责：客户1-800  
部门B负责：客户801-2000  （接收了A的200个客户）
```

### 5.2 槽位迁移实操


**🔧 迁移操作步骤**
```bash
# 场景：将节点7001的1000个槽位迁移给节点7002

# 第1步：启动槽位重新分片
redis-cli --cluster reshard 192.168.1.11:7001

# 交互界面操作：
How many slots do you want to move (from 1 to 16384)? 1000
# 输入要迁移的槽位数量

What is the receiving node ID? 1f2da3b8c9...
# 输入目标节点ID（节点7002的ID）

Source node #1: 07c37dfeb2...
# 输入源节点ID（节点7001的ID）
Source node #2: done
# 输入done表示源节点选择完毕

Do you want to proceed with the proposed reshard plan (yes/no)? yes
# 确认执行迁移计划
```

### 5.3 在线槽位迁移过程


**⚡ 迁移过程中的数据一致性**
```
迁移过程：
1. 标记源槽位为"迁移中"状态
2. 逐个迁移槽位中的键值对
3. 更新槽位分配表
4. 通知所有节点槽位变更

数据访问处理：
┌─────────────────────────────────────┐
│ 客户端请求 → 计算槽位 → 路由到节点   │
├─────────────────────────────────────┤
│ 如果槽位正在迁移：                  │
│ • 先查源节点                       │  
│ • 如果不存在，查目标节点            │
│ • 保证数据一致性                   │
└─────────────────────────────────────┘

优势：迁移过程中服务不中断！
```

---

## 6. 🔧 集群运维管理


### 6.1 在线扩容操作


**📈 集群扩容场景**
业务增长需要更多Redis容量，就像公司扩大需要**租更大办公室**。

**扩容操作流程**
```bash
# 场景：从3主3从扩容到4主4从

# 第1步：准备新节点
启动 192.168.1.14:7001（新主节点）
启动 192.168.1.14:7002（新从节点）

# 第2步：加入新主节点
redis-cli --cluster add-node 192.168.1.14:7001 192.168.1.11:7001

# 第3步：重新分配槽位
redis-cli --cluster reshard 192.168.1.11:7001
# 从现有3个主节点各分一些槽位给新主节点

# 第4步：添加从节点
redis-cli --cluster add-node 192.168.1.14:7002 192.168.1.11:7001 \
  --cluster-slave --cluster-master-id 新主节点ID
```

### 6.2 集群健康检查


**🩺 定期健康检查**
```bash
# 检查集群完整性
redis-cli --cluster check 192.168.1.11:7001

# 输出示例：
192.168.1.11:7001 (07c37dfeb2...) -> 2 keys | 5461 slots | 1 slaves.
192.168.1.11:7002 (1f2da3b8c9...) -> 3 keys | 5462 slots | 1 slaves.
192.168.1.11:7003 (a8b3d4c2e1...) -> 1 keys | 5461 slots | 1 slaves.
[OK] All nodes agree about slots configuration.
[OK] All 16384 slots covered.

关键指标：
• keys：节点存储的键数量
• slots：节点负责的槽位数
• slaves：从节点数量
• 槽位完整性：必须覆盖全部16384个槽位
```

### 6.3 集群故障处理


**🚨 常见故障和解决方案**
```
故障类型：

节点下线：
现象：cluster_state 显示 fail
解决：检查节点是否真的故障，重启或替换

槽位丢失：
现象：cluster_slots_fail > 0
解决：使用 CLUSTER ADDSLOTS 重新分配丢失的槽位

脑裂问题：
现象：出现多个主节点声称负责同一槽位
解决：检查网络连通性，必要时重建集群

数据不一致：
现象：主从节点数据不同步
解决：检查复制延迟，考虑手动同步
```

### 6.4 集群维护命令汇总


| 命令 | **作用** | **语法** | **使用时机** |
|------|---------|---------|-------------|
| `CLUSTER MEET` | **加入节点** | `CLUSTER MEET ip port` | `扩容时` |
| `CLUSTER FORGET` | **移除节点** | `CLUSTER FORGET node-id` | `缩容时` |
| `CLUSTER REPLICATE` | **设置主从** | `CLUSTER REPLICATE master-id` | `配置复制` |
| `CLUSTER ADDSLOTS` | **分配槽位** | `CLUSTER ADDSLOTS 1 2 3...` | `槽位管理` |
| `CLUSTER DELSLOTS` | **删除槽位** | `CLUSTER DELSLOTS 1 2 3...` | `槽位清理` |
| `CLUSTER FAILOVER` | **故障转移** | `CLUSTER FAILOVER [FORCE]` | `主从切换` |

---

## 7. 🔧 命令行工具使用


### 7.1 redis-cli集群模式


**🎯 集群连接方式**
```bash
# 普通模式连接（只连接一个节点）
redis-cli -h 192.168.1.11 -p 7001

# 集群模式连接（自动跳转）
redis-cli -c -h 192.168.1.11 -p 7001
# -c 参数开启集群模式，会自动跟随重定向
```

**💡 集群模式的区别**
```bash
# 普通模式：
127.0.0.1:7001> SET user:9999 "测试"
(error) MOVED 2518 192.168.1.11:7002
# 报错，需要手动连接到正确节点

# 集群模式：
127.0.0.1:7001> SET user:9999 "测试"
-> Redirected to slot [2518] located at 192.168.1.11:7002
OK
# 自动跳转到正确节点并执行命令
```

### 7.2 集群管理工具命令


**🛠️ redis-cli --cluster 工具集**
```bash
# 创建集群
redis-cli --cluster create node1 node2 node3 --cluster-replicas 1

# 添加节点
redis-cli --cluster add-node 新节点地址 现有节点地址

# 删除节点  
redis-cli --cluster del-node 节点地址 节点ID

# 重新分片
redis-cli --cluster reshard 集群节点地址

# 检查集群
redis-cli --cluster check 集群节点地址

# 修复集群
redis-cli --cluster fix 集群节点地址

# 重新平衡槽位
redis-cli --cluster rebalance 集群节点地址
```

### 7.3 集群信息查看工具


**📊 监控和调试命令**
```bash
# 查看集群详细信息
redis-cli --cluster info 192.168.1.11:7001

# 输出示例：
192.168.1.11:7001 (07c37dfeb...) -> 1000 keys | 5461 slots | 1 slaves.
192.168.1.11:7002 (1f2da3b8...) -> 800 keys | 5462 slots | 1 slaves.
192.168.1.11:7003 (a8b3d4c2...) -> 600 keys | 5461 slots | 1 slaves.
[OK] All nodes agree about slots configuration.
[OK] All 16384 slots covered.
3 masters, 3 slaves.

# 调用检查
redis-cli --cluster call 192.168.1.11:7001 INFO memory
# 在所有集群节点执行相同命令
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的操作流程


```
🔸 集群搭建：节点准备→配置文件→启动实例→初始化集群→验证状态
🔸 节点管理：add-node加入，del-node删除，先迁移槽位再删主节点
🔸 槽位管理：reshard重新分片，在线迁移保证服务连续性
🔸 状态监控：cluster info查看整体，cluster nodes查看详细
```

### 8.2 关键理解要点


**🔹 集群搭建的核心思想**
```
分工合作：
• 每个节点负责一部分数据（槽位）
• 通过一致性哈希算法决定数据存储位置
• 节点之间相互通信，共享集群状态

高可用性：
• 主从复制提供数据备份
• 故障检测和自动切换
• 在线扩容缩容不影响服务
```

**🔹 运维管理要点**
```
规划先行：
• 评估数据量和访问量
• 合理规划节点数量和配置
• 考虑网络拓扑和机房分布

渐进式操作：
• 先在测试环境验证操作流程
• 生产环境操作要有回滚方案
• 重要操作选择业务低峰期进行

监控告警：
• 监控集群状态和节点健康
• 设置关键指标告警
• 建立故障应急响应流程
```

### 8.3 最佳实践指南


**✅ 生产环境建议**
```
节点规划：
• 至少3个主节点（保证分片效果）
• 每个主节点至少1个从节点（保证高可用）
• 节点分布在不同物理机器上

配置优化：
• 设置合理的cluster-node-timeout
• 开启AOF持久化
• 配置合适的内存淘汰策略

运维规范：
• 定期备份集群配置
• 监控槽位分布是否均衡
• 定期检查主从同步状态
```

**⚠️ 常见问题避免**
```
配置错误：
• 确保所有节点的cluster-enabled都是yes
• 检查防火墙开放集群通信端口（原端口+10000）
• 时间同步很重要，使用NTP

操作错误：
• 删除主节点前必须先迁移槽位
• 不要在生产环境使用FLUSHALL
• 扩容时注意数据迁移的影响

网络问题：
• 集群节点间网络要稳定
• 避免频繁的网络分区
• 合理设置超时参数
```

### 8.4 快速诊断检查单


```
🔸 集群状态检查：
☐ cluster info显示cluster_state:ok
☐ 所有16384个槽位已分配
☐ cluster_known_nodes等于实际节点数

🔸 节点状态检查：
☐ cluster nodes显示所有节点connected
☐ 主从关系配置正确
☐ 没有fail或pfail状态的节点

🔸 数据分布检查：
☐ 各节点的keys数量相对均衡
☐ 没有空的主节点（无槽位分配）
☐ 主从数据同步正常
```

**核心记忆**：
- 集群搭建分四步：准备节点、启动服务、初始化集群、验证状态
- 节点管理两类型：主节点要迁移槽位，从节点直接删除
- 槽位迁移保连续：在线迁移不停服，自动处理重定向
- 管理命令要熟悉：meet加入、nodes查看、info监控