---
title: 8、List列表类型基础操作
---
## 📚 目录

1. [List列表类型概述](#1-List列表类型概述)
2. [基础插入操作](#2-基础插入操作)
3. [基础删除操作](#3-基础删除操作)
4. [基础查询操作](#4-基础查询操作)
5. [实际应用场景](#5-实际应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📋 List列表类型概述


### 1.1 什么是Redis List


**简单理解**：Redis的List就像一个**双端队列**，可以从**左边或右边**插入和取出数据。

```
想象一个排队的队伍：
┌─────┬─────┬─────┬─────┬─────┐
│ 张三 │ 李四 │ 王五 │ 赵六 │ 孙七 │
└─────┴─────┴─────┴─────┴─────┘
↑左端                        右端↑

- 可以从左边插入新人（插队到最前面）
- 可以从右边插入新人（排到最后面）
- 可以从左边让人离开（第一个人离开）
- 可以从右边让人离开（最后一个人离开）
```

### 1.2 List的核心特点


**🔸 有序性**：元素按插入顺序排列，有固定位置
**🔸 可重复**：同一个值可以出现多次
**🔸 双端操作**：支持从头部和尾部进行操作
**🔸 索引访问**：可以通过位置索引直接访问元素

### 1.3 底层实现原理


```
Redis List底层数据结构：

版本3.2之前：双向链表 + 压缩列表
┌─────┐    ┌─────┐    ┌─────┐
│ 节点1│ ←→ │ 节点2│ ←→ │ 节点3│
└─────┘    └─────┘    └─────┘

版本3.2之后：quicklist（快速列表）
- 结合了双向链表和压缩列表的优点
- 既节省内存又保证操作效率
```

---

## 2. ➡️ 基础插入操作


### 2.1 左端插入操作


#### 🔸 LPUSH - 左端插入（必存在）


```bash
# 语法：LPUSH key element [element ...]
127.0.0.1:6379> LPUSH mylist "world"
(integer) 1
127.0.0.1:6379> LPUSH mylist "hello"
(integer) 2

# 查看结果
127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"
2) "world"
```

**工作原理图解**：
```
插入过程：
第一步：LPUSH mylist "world"
┌───────┐
│ world │
└───────┘

第二步：LPUSH mylist "hello"  
┌───────┬───────┐
│ hello │ world │  ← hello插入到左端（最前面）
└───────┴───────┘
```

**📝 关键理解**：
- `LPUSH`总是把新元素插入到**最左边**（列表头部）
- 返回值是插入后列表的**总长度**
- 如果key不存在，会**自动创建**一个新列表

#### 🔸 LPUSHX - 存在才左插入


```bash
# 只有key存在时才插入
127.0.0.1:6379> LPUSHX newlist "test"
(integer) 0    # 返回0表示key不存在，未插入

127.0.0.1:6379> LPUSHX mylist "hi"
(integer) 3    # mylist存在，插入成功
```

**使用场景对比**：
```
LPUSH：不管key存不存在，都要插入（没有就创建）
LPUSHX：只有key已经存在时才插入（防止意外创建）

实际应用：
- LPUSH：适合初始化或者确定要创建列表的场景
- LPUSHX：适合只想给现有列表添加数据的场景
```

### 2.2 右端插入操作


#### 🔸 RPUSH - 右端插入


```bash
127.0.0.1:6379> RPUSH mylist "end"
(integer) 4

127.0.0.1:6379> LRANGE mylist 0 -1
1) "hi"
2) "hello" 
3) "world"
4) "end"
```

**左右插入对比图**：
```
原始列表：[hello, world]

LPUSH mylist "new"     →     [new, hello, world]
                            ↑新元素在最左边

RPUSH mylist "new"     →     [hello, world, new]  
                                           ↑新元素在最右边
```

#### 🔸 RPUSHX - 存在才右插入


```bash
# 功能与LPUSHX类似，只是插入位置在右端
127.0.0.1:6379> RPUSHX mylist "last"
(integer) 5
```

### 2.3 批量插入操作


```bash
# 一次插入多个元素
127.0.0.1:6379> LPUSH batch_list "c" "b" "a"
(integer) 3

# 查看结果（注意顺序）
127.0.0.1:6379> LRANGE batch_list 0 -1
1) "a"
2) "b" 
3) "c"
```

**📝 批量插入顺序理解**：
```
执行：LPUSH mylist "c" "b" "a"

插入过程：
1. 先插入"c"     →  [c]
2. 再插入"b"     →  [b, c]  ← b插入到左边
3. 最后插入"a"   →  [a, b, c]  ← a插入到左边

最终结果：[a, b, c]
```

---

## 3. ⬅️ 基础删除操作


### 3.1 左右端删除操作


#### 🔸 LPOP - 左端弹出


```bash
127.0.0.1:6379> LRANGE mylist 0 -1
1) "hi"
2) "hello"
3) "world" 
4) "end"
5) "last"

127.0.0.1:6379> LPOP mylist
"hi"    # 返回被删除的元素

127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"  # "hi"已经被删除
2) "world"
3) "end" 
4) "last"
```

#### 🔸 RPOP - 右端弹出


```bash
127.0.0.1:6379> RPOP mylist
"last"   # 从右端删除并返回

127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"
2) "world"
3) "end"
```

**弹出操作图解**：
```
原始列表：[hello, world, end, last]

LPOP操作：
删除 → hello ← [world, end, last]
      ↑返回被删除的元素

RPOP操作：  
[hello, world, end] → last ← 删除
                     ↑返回被删除的元素
```

### 3.2 指定元素删除


#### 🔸 LREM - 删除指定元素


```bash
# 准备测试数据
127.0.0.1:6379> LPUSH fruits "apple" "banana" "apple" "orange" "apple"

# 语法：LREM key count element
127.0.0.1:6379> LREM fruits 2 "apple"
(integer) 2    # 返回实际删除的元素个数
```

**count参数详解**：
```
LREM key count element

count > 0：从头到尾删除count个element
count < 0：从尾到头删除|count|个element  
count = 0：删除所有的element

示例理解：
原列表：[apple, orange, apple, banana, apple]

LREM fruits 2 "apple"   → 从左删除2个apple
结果：[orange, banana, apple]

LREM fruits -1 "apple"  → 从右删除1个apple  
结果：[apple, orange, apple, banana]

LREM fruits 0 "apple"   → 删除所有apple
结果：[orange, banana]
```

**实际操作演示**：
```bash
127.0.0.1:6379> LPUSH demo "a" "b" "a" "c" "a"
127.0.0.1:6379> LRANGE demo 0 -1
1) "a"
2) "c" 
3) "a"
4) "b"
5) "a"

# 从左删除2个"a"
127.0.0.1:6379> LREM demo 2 "a"
(integer) 2

127.0.0.1:6379> LRANGE demo 0 -1
1) "c"
2) "b"
3) "a"    # 还剩1个"a"
```

---

## 4. 🔍 基础查询操作


### 4.1 长度查询


#### 🔸 LLEN - 获取列表长度


```bash
127.0.0.1:6379> LLEN mylist
(integer) 3

# 空列表长度为0
127.0.0.1:6379> LLEN nonexist
(integer) 0
```

**使用场景**：
- 判断列表是否为空
- 分页查询前获取总数
- 控制列表大小限制

### 4.2 范围查询


#### 🔸 LRANGE - 范围查询


```bash
# 语法：LRANGE key start stop
127.0.0.1:6379> LRANGE mylist 0 -1    # 查询所有元素
1) "hello"
2) "world" 
3) "end"

127.0.0.1:6379> LRANGE mylist 0 1     # 查询前2个元素
1) "hello"
2) "world"

127.0.0.1:6379> LRANGE mylist -2 -1   # 查询最后2个元素
1) "world"
2) "end"
```

**索引规则详解**：
```
列表：[hello, world, end]

正向索引：  0      1      2
负向索引： -3     -2     -1

常用查询模式：
LRANGE key 0 -1    # 查询所有元素
LRANGE key 0 2     # 查询前3个元素（索引0,1,2）
LRANGE key -2 -1   # 查询最后2个元素
LRANGE key 1 1     # 查询第2个元素
```

### 4.3 指定位置查询


#### 🔸 LINDEX - 获取指定位置元素


```bash
127.0.0.1:6379> LINDEX mylist 0
"hello"    # 第一个元素

127.0.0.1:6379> LINDEX mylist -1  
"end"      # 最后一个元素

127.0.0.1:6379> LINDEX mylist 10
(nil)      # 索引超出范围返回nil
```

**📝 索引使用技巧**：
```
快速获取：
- 第一个元素：LINDEX key 0
- 最后一个元素：LINDEX key -1  
- 第二个元素：LINDEX key 1
- 倒数第二个：LINDEX key -2

注意：索引超出范围不会报错，返回nil
```

---

## 5. 🚀 实际应用场景


### 5.1 简单队列实现


**队列特点**：先进先出（FIFO - First In First Out）

```bash
# 模拟任务队列
127.0.0.1:6379> RPUSH task_queue "task1" "task2" "task3"

# 工作者从队列头部取任务（先进先出）
127.0.0.1:6379> LPOP task_queue
"task1"

127.0.0.1:6379> LPOP task_queue  
"task2"

# 新任务加入队列尾部
127.0.0.1:6379> RPUSH task_queue "task4"
```

**队列操作图解**：
```
队列工作流程：

1. 初始状态：[task1, task2, task3]
              ↑头部    ↑尾部

2. 生产者添加任务（RPUSH）：
   [task1, task2, task3, task4]
                         ↑新任务加入尾部

3. 消费者处理任务（LPOP）：
   task1 ← [task2, task3, task4]
   ↑处理最早的任务
```

**实际应用代码示例**：
```python
# Python伪代码
import redis
r = redis.Redis()

# 生产者：添加任务到队列
def add_task(task_data):
    r.rpush('task_queue', task_data)
    
# 消费者：从队列获取任务
def get_task():
    return r.lpop('task_queue')
```

### 5.2 栈结构实现


**栈特点**：后进先出（LIFO - Last In First Out）

```bash
# 模拟浏览器历史记录
127.0.0.1:6379> LPUSH history "page1.html"
127.0.0.1:6379> LPUSH history "page2.html"  
127.0.0.1:6379> LPUSH history "page3.html"

# 后退操作（弹出最后访问的页面）
127.0.0.1:6379> LPOP history
"page3.html"

127.0.0.1:6379> LPOP history
"page2.html"
```

**栈操作图解**：
```
栈工作流程：

1. 访问页面（LPUSH）：
   page1 → [page1]
   page2 → [page2, page1]  ← page2压入栈顶
   page3 → [page3, page2, page1]  ← page3压入栈顶

2. 后退操作（LPOP）：
   [page3, page2, page1] → page3  ← 弹出栈顶
   [page2, page1] → page2  ← 弹出新的栈顶
```

### 5.3 有序数据存储


```bash
# 存储用户最近的操作记录
127.0.0.1:6379> LPUSH user:1001:actions "login" 
127.0.0.1:6379> LPUSH user:1001:actions "view_product"
127.0.0.1:6379> LPUSH user:1001:actions "add_cart"

# 获取最近5次操作
127.0.0.1:6379> LRANGE user:1001:actions 0 4
1) "add_cart"      # 最新的操作
2) "view_product" 
3) "login"         # 最早的操作

# 限制记录数量（保持最新的10条）
127.0.0.1:6379> LTRIM user:1001:actions 0 9
```

**应用场景总结表**：

| 应用场景 | 入队操作 | 出队操作 | 特点 | 示例 |
|---------|---------|---------|------|------|
| **队列** | `RPUSH` | `LPOP` | 先进先出 | 任务队列、消息队列 |
| **栈** | `LPUSH` | `LPOP` | 后进先出 | 浏览历史、撤销操作 |  
| **最新记录** | `LPUSH` | 查询用`LRANGE` | 保持时间顺序 | 用户动态、操作日志 |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念


```
🔸 List本质：双端队列，支持从左右两端操作
🔸 有序性：元素按插入顺序排列，有固定位置索引  
🔸 可重复：同一个值可以出现多次
🔸 双端操作：L开头命令操作左端，R开头命令操作右端
🔸 索引访问：支持正负索引，-1表示最后一个元素
```

### 6.2 关键操作命令对比


**📊 插入操作对比**：
```
LPUSH vs RPUSH：
- LPUSH：插入到左端（头部），适合栈操作
- RPUSH：插入到右端（尾部），适合队列操作

LPUSHX vs RPUSHX：
- 只有key存在时才插入，防止意外创建空列表
- 适合给现有列表添加数据的安全操作
```

**📊 删除操作对比**：
```
LPOP vs RPOP：
- LPOP：删除并返回左端元素，O(1)时间复杂度
- RPOP：删除并返回右端元素，O(1)时间复杂度

LREM：
- 可以删除列表中间的指定元素
- 时间复杂度O(n)，需要遍历列表
```

### 6.3 应用场景选择指南


**🎯 选择原则**：
```
实现队列（先进先出）：
入队：RPUSH    出队：LPOP

实现栈（后进先出）：  
入栈：LPUSH    出栈：LPOP

存储有序数据：
新增：LPUSH    查询：LRANGE

删除特定元素：
使用：LREM
```

### 6.4 性能特点


```
时间复杂度：
- 头尾插入删除：O(1) - 非常快
- 中间插入删除：O(n) - 需要遍历
- 索引访问：O(n) - 需要从头/尾遍历到指定位置
- 长度获取：O(1) - Redis内部维护长度

内存效率：
- quicklist结构兼顾空间和时间效率
- 适合存储中等规模的有序数据
```

### 6.5 最佳实践建议


```
✅ 推荐做法：
- 多用头尾操作（LPUSH/RPUSH/LPOP/RPOP）
- 使用LRANGE进行范围查询而不是逐个LINDEX
- 合理设置列表长度上限，避免无限增长

❌ 避免的做法：  
- 频繁使用LINDEX访问中间元素
- 大量使用LREM删除中间元素
- 将List当作数组进行随机访问
```

**核心记忆**：
- List像双端队列，左右都能进出
- L开头操作左端，R开头操作右端  
- 队列用RPUSH+LPOP，栈用LPUSH+LPOP
- 头尾操作快如闪电，中间操作需谨慎