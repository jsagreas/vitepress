---
title: 18、ZSet有序集合进阶操作
---
## 📚 目录

1. [分数范围操作详解](#1-分数范围操作详解)
2. [排名范围操作](#2-排名范围操作)
3. [分数修改操作](#3-分数修改操作)
4. [集合运算操作](#4-集合运算操作)
5. [高级查询技巧](#5-高级查询技巧)
6. [进阶应用场景](#6-进阶应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📊 分数范围操作详解


### 1.1 按分数范围查询


**基本概念理解**：
> 分数范围查询就像在考试成绩单中找出"80-90分"的所有学生，Redis可以根据分数区间快速找到对应的成员。

**核心命令**：

```redis
# ZRANGEBYSCORE - 按分数范围正序查询
ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]

# ZREVRANGEBYSCORE - 按分数范围逆序查询  
ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]
```

**实际应用示例**：

```redis
# 准备测试数据：学生成绩
ZADD student_scores 85 "张三" 92 "李四" 78 "王五" 96 "赵六" 81 "钱七"

# 查询80-90分的学生（正序）
ZRANGEBYSCORE student_scores 80 90
# 返回：1) "钱七" 2) "张三"

# 查询80-90分的学生，带分数（正序）
ZRANGEBYSCORE student_scores 80 90 WITHSCORES
# 返回：1) "钱七" 2) "81" 3) "张三" 4) "85"

# 查询80-90分的学生（逆序）
ZREVRANGEBYSCORE student_scores 90 80
# 返回：1) "张三" 2) "钱七"
```

**分数区间表示方法**：

| **区间写法** | **含义** | **示例** | **说明** |
|-------------|---------|---------|---------|
| `80 90` | `80 ≤ score ≤ 90` | `闭区间，包含边界` | 最常用 |
| `(80 90` | `80 < score ≤ 90` | `左开右闭` | 不包含80 |
| `80 (90` | `80 ≤ score < 90` | `左闭右开` | 不包含90 |
| `(80 (90` | `80 < score < 90` | `开区间` | 不包含边界 |
| `-inf +inf` | `所有分数` | `无限区间` | 获取全部 |

```redis
# 区间示例
ZRANGEBYSCORE student_scores (80 90      # 大于80小于等于90
ZRANGEBYSCORE student_scores 80 (90      # 大于等于80小于90
ZRANGEBYSCORE student_scores -inf +inf   # 所有成员
ZRANGEBYSCORE student_scores 90 +inf     # 90分以上所有学生
```

### 1.2 分页查询实现


**分页查询的重要性**：
> 当数据量很大时，不能一次性返回所有结果，需要分页显示，就像翻书一样一页一页看。

```redis
# 查询80-100分的学生，每页5个，取第2页
# LIMIT offset count：跳过offset个，取count个
ZRANGEBYSCORE student_scores 80 100 LIMIT 5 5

# 实际应用：排行榜分页
# 第1页：LIMIT 0 10   (0-9名)
# 第2页：LIMIT 10 10  (10-19名)
# 第3页：LIMIT 20 10  (20-29名)
```

### 1.3 按分数范围删除


```redis
# ZREMRANGEBYSCORE - 删除指定分数范围的成员
ZREMRANGEBYSCORE key min max

# 删除60分以下的学生
ZREMRANGEBYSCORE student_scores -inf 60

# 删除90分以上的学生（太高了，重新考试）
ZREMRANGEBYSCORE student_scores 90 +inf

# 删除80-85分之间的学生
ZREMRANGEBYSCORE student_scores 80 85
```

---

## 2. 🏆 排名范围操作


### 2.1 按排名范围删除


**排名vs分数的区别**：
> 排名是位置（第几名），分数是成绩（多少分）。排名从0开始计算，0代表第1名。

```redis
# ZREMRANGEBYRANK - 按排名范围删除
ZREMRANGEBYRANK key start stop

# 准备数据
ZADD game_rank 1500 "玩家A" 1200 "玩家B" 1800 "玩家C" 1000 "玩家D"

# 删除排名最后的2名玩家（保留前2名）
ZREMRANGEBYRANK game_rank 2 -1
# start=2：从第3名开始，stop=-1：到最后一名

# 删除第1名（从0开始计算）
ZREMRANGEBYRANK game_rank 0 0

# 删除中间排名的玩家（第2-4名）
ZREMRANGEBYRANK game_rank 1 3
```

**排名范围表示方法**：

```
排名范围说明：

正数索引：0, 1, 2, 3, 4, ...  (从前往后)
负数索引：..., -4, -3, -2, -1  (从后往前)

例如5个成员的排名：
位置:  0    1    2    3    4
     第1名 第2名 第3名 第4名 第5名
     -5   -4   -3   -2   -1
```

**实际应用场景**：
```redis
# 游戏排行榜：只保留前100名
ZREMRANGEBYRANK game_rank 100 -1

# 清理最低分的10%用户
ZCARD game_rank                    # 获取总数量
# 假设返回1000，那么删除前100名（最低的100个）
ZREMRANGEBYRANK game_rank 0 99
```

---

## 3. ⬆️ 分数修改操作


### 3.1 增加成员分数


**ZINCRBY命令详解**：
> ZINCRBY就像给学生加分或扣分，可以是正数（加分）也可以是负数（扣分）。

```redis
# ZINCRBY key increment member
ZINCRBY key 增加的分数 成员名

# 准备数据
ZADD user_points 100 "用户A" 200 "用户B" 150 "用户C"

# 用户A完成任务，获得50积分
ZINCRBY user_points 50 "用户A"
# 用户A积分：100 + 50 = 150

# 用户B违规，扣除30积分  
ZINCRBY user_points -30 "用户B"
# 用户B积分：200 - 30 = 170

# 新用户D首次获得积分（自动创建）
ZINCRBY user_points 80 "用户D"
# 用户D积分：0 + 80 = 80（从0开始）
```

**返回值说明**：
```redis
# ZINCRBY返回操作后的总分数
ZINCRBY user_points 25 "用户A"
# 返回："175"（字符串格式的分数）

# 可以用于获取当前分数
ZSCORE user_points "用户A"
# 返回："175"
```

**实际应用示例**：

```redis
# 网站积分系统
# 用户登录+1分
ZINCRBY daily_points 1 "user:1001"

# 用户发帖+10分
ZINCRBY daily_points 10 "user:1001"

# 用户被举报-5分
ZINCRBY daily_points -5 "user:1001"

# 签到连续奖励
ZINCRBY consecutive_days 1 "user:1001"
```

---

## 4. 🔄 集合运算操作


### 4.1 并集运算 ZUNIONSTORE


**并集的概念**：
> 并集就像合并两个班级的成绩单，如果同一个学生在两个班都有成绩，需要决定如何合并分数。

```redis
# ZUNIONSTORE destination numkeys key1 key2... [WEIGHTS weight1 weight2...] [AGGREGATE SUM|MIN|MAX]

# 准备测试数据
ZADD class_a 90 "张三" 85 "李四" 88 "王五"
ZADD class_b 92 "张三" 87 "赵六" 90 "王五"

# 基本并集：相同成员分数相加
ZUNIONSTORE total_score 2 class_a class_b
ZRANGE total_score 0 -1 WITHSCORES
# 结果：张三182分(90+92)，王五178分(88+90)，李四85分，赵六87分
```

**权重设置**：
```redis
# 设置不同权重：class_a权重0.6，class_b权重0.4
ZUNIONSTORE weighted_score 2 class_a class_b WEIGHTS 0.6 0.4
# 张三最终得分：90*0.6 + 92*0.4 = 54 + 36.8 = 90.8
```

**聚合方式**：

| **聚合方式** | **说明** | **应用场景** |
|-------------|---------|-------------|
| `SUM`（默认） | 分数相加 | 总积分计算 |
| `MIN` | 取最小值 | 最低消费记录 |
| `MAX` | 取最大值 | 最高成绩记录 |

```redis
# 取最高分数
ZUNIONSTORE best_score 2 class_a class_b AGGREGATE MAX

# 取最低分数  
ZUNIONSTORE worst_score 2 class_a class_b AGGREGATE MIN
```

### 4.2 交集运算 ZINTERSTORE


**交集的概念**：
> 交集只保留同时出现在所有集合中的成员，就像找出"两个班都有的学生"。

```redis
# ZINTERSTORE destination numkeys key1 key2... [WEIGHTS weight1 weight2...] [AGGREGATE SUM|MIN|MAX]

# 只保留同时在两个班级的学生
ZINTERSTORE common_students 2 class_a class_b
ZRANGE common_students 0 -1 WITHSCORES
# 结果：只有张三和王五（他们在两个班都有成绩）
```

**实际应用示例**：
```redis
# 用户行为分析：找出既购买了商品又评价了的用户
ZADD buyers 100 "user1" 200 "user2" 150 "user3"
ZADD reviewers 80 "user1" 90 "user3" 70 "user4"

# 活跃用户（既买又评价）
ZINTERSTORE active_users 2 buyers reviewers
# 结果：user1, user3
```

---

## 5. 🎯 高级查询技巧


### 5.1 分页查询最佳实践


**大数据量分页问题**：
> 当数据量很大时，简单的LIMIT分页会有性能问题，需要优化策略。

```redis
# 传统分页（有性能问题）
# 获取第1000页，每页20条：LIMIT 19980 20
# 问题：需要跳过19980条记录，效率低

# 优化方案：基于分数的游标分页
# 第一次查询：获取前20条
ZREVRANGE top_users 0 19 WITHSCORES

# 记录最后一条的分数，比如是1500分
# 下一页查询：分数小于1500的前20条
ZREVRANGEBYSCORE top_users (1500 -inf LIMIT 0 20
```

**分页查询封装示例**：
```redis
# 获取排行榜指定页面
# 参数：key名称，页码，每页大小
function getRankPage(key, page, pageSize) {
    local start = (page - 1) * pageSize
    local stop = start + pageSize - 1
    return ZREVRANGE key start stop WITHSCORES
}
```

### 5.2 分数区间统计


```redis
# ZCOUNT - 统计分数区间内的成员数量
ZCOUNT key min max

# 统计80-90分的学生数量
ZCOUNT student_scores 80 90

# 统计各分数段人数
ZCOUNT student_scores 90 100     # 优秀（90-100）
ZCOUNT student_scores 80 89      # 良好（80-89）
ZCOUNT student_scores 70 79      # 中等（70-79）
ZCOUNT student_scores 60 69      # 及格（60-69）
ZCOUNT student_scores 0 59       # 不及格（0-59）
```

### 5.3 Top N查询优化


```redis
# 获取前N名，性能最优
# 推荐：直接使用ZREVRANGE
ZREVRANGE leaderboard 0 9        # 前10名

# 不推荐：使用分数查询然后排序
# ZREVRANGEBYSCORE leaderboard +inf -inf LIMIT 0 10  # 效率较低
```

**Top N查询的实际应用**：
```redis
# 热门商品Top 10
ZREVRANGE hot_products 0 9 WITHSCORES

# 活跃用户Top 50
ZREVRANGE active_users 0 49 WITHSCORES

# 最新文章Top 20
ZREVRANGE recent_articles 0 19 WITHSCORES
```

---

## 6. 🚀 进阶应用场景


### 6.1 复杂排行榜系统


**多维度排行榜**：
> 实际业务中，排行榜往往不是单一维度，比如游戏中既有等级排行，又有财富排行。

```redis
# 游戏多维度排行榜设计
# 等级排行榜
ZADD level_rank 45 "玩家A" 42 "玩家B" 47 "玩家C"

# 财富排行榜  
ZADD wealth_rank 50000 "玩家A" 48000 "玩家B" 52000 "玩家C"

# 战力排行榜（等级*100 + 财富/1000）
# 玩家A战力：45*100 + 50000/1000 = 4500 + 50 = 4550
ZADD power_rank 4550 "玩家A" 4548 "玩家B" 4752 "玩家C"

# 综合排行榜：多个维度加权平均
ZUNIONSTORE overall_rank 3 level_rank wealth_rank power_rank WEIGHTS 0.4 0.3 0.3
```

**时间衰减排行榜**：
```redis
# 热度排行榜：分数随时间衰减
# 分数 = 原始分数 * 衰减系数
# 衰减系数 = e^(-时间差/衰减常数)

# 每小时更新一次热度
function updateHotRank() {
    local now = os.time()
    local members = redis.call('ZRANGE', 'hot_articles', 0, -1, 'WITHSCORES')
    
    for i = 1, #members, 2 do
        local member = members[i]
        local score = tonumber(members[i+1])
        local newScore = score * 0.9  -- 每小时衰减10%
        redis.call('ZADD', 'hot_articles', newScore, member)
    end
}
```

### 6.2 优先级队列实现


**优先级队列的概念**：
> 优先级队列就像医院的急诊科，病情严重的病人优先处理，不是简单的先来先服务。

```redis
# 任务队列：分数越高优先级越高
ZADD task_queue 10 "普通任务1" 50 "重要任务1" 100 "紧急任务1" 30 "一般任务1"

# 获取最高优先级任务（分数最高）
ZREVRANGE task_queue 0 0
# 返回：紧急任务1

# 取出并删除最高优先级任务
function popHighestPriorityTask() {
    local task = redis.call('ZREVRANGE', 'task_queue', -1, -1)
    if #task > 0 then
        redis.call('ZREM', 'task_queue', task[1])
        return task[1]
    end
    return nil
}
```

**延时队列实现**：
```redis
# 延时任务：使用时间戳作为分数
local delayTime = os.time() + 300  -- 5分钟后执行
ZADD delay_queue delayTime "发送邮件任务"

# 检查到期任务
local now = os.time()
local tasks = redis.call('ZRANGEBYSCORE', 'delay_queue', '-inf', now)
for i, task in ipairs(tasks) do
    -- 处理到期任务
    processTask(task)
    redis.call('ZREM', 'delay_queue', task)
end
```

### 6.3 时间窗口统计


**滑动窗口统计**：
> 统计最近一段时间内的数据，时间窗口会滑动，比如"最近1小时的访问量"。

```redis
# 用户访问统计：最近1小时访问量
function recordAccess(userId) {
    local now = os.time()
    local key = 'access:' .. userId
    
    -- 记录当前访问
    redis.call('ZADD', key, now, now)
    
    -- 删除1小时前的记录
    local oneHourAgo = now - 3600
    redis.call('ZREMRANGEBYSCORE', key, '-inf', oneHourAgo)
    
    -- 设置过期时间
    redis.call('EXPIRE', key, 3600)
    
    -- 返回最近1小时访问次数
    return redis.call('ZCARD', key)
}

# 查询用户最近1小时访问量
ZCARD access:user1001

# 限流：如果1小时内访问超过100次，拒绝服务
local accessCount = recordAccess('user1001')
if accessCount > 100 then
    return "访问频率过高，请稍后再试"
end
```

**按时间分段统计**：
```redis
# 按小时统计网站访问量
function recordHourlyAccess() {
    local hour = os.date("%Y%m%d%H")  -- 2024010114 (2024年1月1日14时)
    redis.call('ZINCRBY', 'hourly_stats', 1, hour)
}

# 查询最近24小时访问统计
ZREVRANGE hourly_stats 0 23 WITHSCORES
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的进阶操作


```
🔸 分数范围查询：ZRANGEBYSCORE/ZREVRANGEBYSCORE，支持开闭区间
🔸 排名范围删除：ZREMRANGEBYRANK，按位置删除成员
🔸 分数增减：ZINCRBY，支持正负数增量
🔸 集合运算：ZUNIONSTORE/ZINTERSTORE，支持权重和聚合方式
🔸 统计查询：ZCOUNT统计区间成员数量
🔸 分页查询：LIMIT参数实现分页，大数据量需要优化
```

### 7.2 关键理解要点


**分数vs排名的区别**：
```
分数(Score)：成员的实际数值，可以相同
排名(Rank)：成员的位置序号，从0开始，不会重复

查询方式：
- 按分数查询：ZRANGEBYSCORE（根据数值范围）
- 按排名查询：ZRANGE（根据位置范围）
```

**集合运算的应用思路**：
```
并集运算：合并多个维度的数据
交集运算：找出同时满足多个条件的数据
权重设置：不同数据源的重要程度不同
聚合方式：决定相同成员分数如何计算
```

**性能优化原则**：
```
1. 大数据量分页避免大偏移量LIMIT
2. Top N查询直接用ZRANGE而不是分数查询
3. 定期清理过期数据，控制集合大小
4. 合理使用索引，避免全量扫描
```

### 7.3 实际应用价值


**业务场景映射**：
- **排行榜系统**：游戏排行、销售排行、热度排行
- **优先级队列**：任务调度、消息处理、资源分配
- **时间窗口统计**：访问量统计、限流控制、趋势分析
- **推荐系统**：根据评分推荐内容、用户画像

**系统设计考虑**：
- **数据一致性**：并发更新时的分数准确性
- **内存管理**：大集合的内存占用和清理策略
- **查询效率**：根据业务场景选择最优查询方式
- **扩展性**：数据量增长时的性能保证

### 7.4 最佳实践建议


**设计原则**：
```
1. 分数设计要有业务意义，便于理解和维护
2. 定期清理无用数据，防止内存泄漏
3. 合理设置过期时间，平衡性能和存储
4. 监控集合大小，避免单个key过大
```

**常见错误避免**：
```
❌ 频繁的全量查询：ZRANGE key 0 -1
❌ 大偏移量分页：LIMIT 10000 20
❌ 忽略内存清理：不设置过期时间
❌ 分数设计不合理：难以表达业务逻辑
```

**核心记忆**：
```
ZSet进阶操作强，分数排名要分清
范围查询按需选，分页优化性能好
集合运算合数据，权重聚合有技巧
优先队列时间窗，业务场景都能搞
内存清理要及时，监控性能不能少
```