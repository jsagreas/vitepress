---
title: 24、Redis数据类型内部编码优化
---
## 📚 目录

1. [内部编码概念理解](#1-内部编码概念理解)
2. [String内部编码](#2-String内部编码)
3. [Hash内部编码](#3-Hash内部编码)
4. [List内部编码](#4-List内部编码)
5. [Set内部编码](#5-Set内部编码)
6. [ZSet内部编码](#6-ZSet内部编码)
7. [编码优化策略](#7-编码优化策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧠 内部编码概念理解


### 1.1 什么是Redis内部编码


**通俗理解**：Redis内部编码就像不同的存储格式，同一种数据类型在不同情况下会选择最合适的存储方式。

```
类比理解：就像存储文件的不同格式
┌─────────────────────────┐
│       同一份数据         │
├─────────────────────────┤
│ 文本文件 (.txt)         │ ← 简单直接，适合小文件
│ 压缩文件 (.zip)         │ ← 节省空间，适合大文件  
│ 数据库 (.db)           │ ← 复杂查询，适合结构化数据
└─────────────────────────┘
```

### 1.2 为什么需要多种编码


**核心目的**：
- **节省内存**：选择最节省空间的存储方式
- **提升性能**：根据数据特点选择最快的访问方式
- **自动优化**：Redis自动选择，用户无需关心
- **兼容性好**：对外接口保持一致

### 1.3 编码查看方法


```bash
# 查看任意key的内部编码
OBJECT ENCODING keyname

# 示例
SET name "张三"
OBJECT ENCODING name    # 返回: "embstr"

HSET user:1001 name "张三" 
OBJECT ENCODING user:1001   # 返回: "ziplist" 或 "hashtable"
```

---

## 2. 📝 String内部编码


### 2.1 三种编码类型


**String的存储策略**：
```
数据特点                    编码选择
┌─────────────────────┐   ┌──────────────┐
│ 纯数字且在范围内      │ → │ int编码       │
├─────────────────────┤   ├──────────────┤
│ 字符串长度 ≤ 44字节   │ → │ embstr编码    │
├─────────────────────┤   ├──────────────┤
│ 字符串长度 > 44字节   │ → │ raw编码       │
└─────────────────────┘   └──────────────┘
```

### 2.2 int编码详解


**适用条件**：存储的是64位有符号整数

```bash
# int编码示例
SET count 100
OBJECT ENCODING count    # 返回: "int"

SET price 99.5
OBJECT ENCODING price    # 返回: "embstr" (不是纯整数)
```

**内存优势**：
- **直接存储**：数值直接存在指针位置，不需要额外内存
- **计算高效**：支持INCR、DECR等数值运算
- **自动转换**：运算后如果超出范围会转为raw编码

### 2.3 embstr编码详解


**适用条件**：字符串长度小于等于44字节

```bash
# embstr编码示例
SET name "张三"
OBJECT ENCODING name     # 返回: "embstr"

SET short_text "这是一段不超过44字节的文本内容"
OBJECT ENCODING short_text   # 返回: "embstr"
```

**存储结构**：
```
embstr编码内存布局：
┌─────────────┬─────────────────────┐
│ RedisObject │ SDS字符串数据        │
│ (对象头)    │ (嵌入在同一内存块中) │
└─────────────┴─────────────────────┘

raw编码内存布局：
┌─────────────┐    ┌─────────────────┐
│ RedisObject │ -> │ SDS字符串数据   │
│ (对象头)    │    │ (独立内存块)    │
└─────────────┘    └─────────────────┘
```

**优势特点**：
- **内存连续**：对象头和数据在同一内存块
- **缓存友好**：访问局部性好，CPU缓存效率高
- **只读优化**：创建后不能修改，修改时转为raw编码

### 2.4 raw编码详解


**适用条件**：字符串长度大于44字节

```bash
# raw编码示例
SET long_text "这是一段很长的文本内容，超过了44字节的限制，所以会使用raw编码进行存储，这种编码方式适合大字符串"
OBJECT ENCODING long_text    # 返回: "raw"
```

**特点分析**：
- **独立存储**：字符串数据存储在独立的内存块中
- **可修改**：支持APPEND等修改操作
- **动态扩展**：长度可以动态调整

### 2.5 编码转换机制


```bash
# 编码转换示例
SET key "short"
OBJECT ENCODING key     # "embstr"

APPEND key " very long additional content that makes it exceed 44 bytes"
OBJECT ENCODING key     # "raw" (embstr转为raw)

SET num 100
OBJECT ENCODING num     # "int"

APPEND num "abc"
OBJECT ENCODING num     # "raw" (int转为raw)
```

**转换规则**：
- **单向转换**：编码只能从简单转向复杂
- **不可逆转**：raw不会转回embstr，embstr不会转回int
- **操作触发**：修改操作可能触发编码转换

---

## 3. 🗂️ Hash内部编码


### 3.1 两种编码方式


**Hash编码选择策略**：
```
数据规模判断                 编码选择
┌─────────────────────┐    ┌─────────────────┐
│ 字段数量 < 512个     │    │                 │
│ 且                  │ -> │ ziplist编码     │
│ 每个值长度 < 64字节  │    │ (压缩列表)      │
├─────────────────────┤    ├─────────────────┤
│ 超出上述条件         │ -> │ hashtable编码   │
│                     │    │ (哈希表)        │
└─────────────────────┘    └─────────────────┘
```

### 3.2 ziplist编码详解


**存储结构**：压缩列表将字段和值连续存储

```
ziplist内部布局：
┌─────┬───────┬───────┬───────┬───────┬─────┐
│ 头部│ field1│ value1│ field2│ value2│ 尾部│
└─────┴───────┴───────┴───────┴───────┴─────┘

实际数据示例：
name -> "张三" -> age -> "25" -> email -> "zhang@qq.com"
```

**优势特点**：
- **内存紧凑**：所有数据连续存储，节省指针开销
- **缓存友好**：顺序访问，CPU缓存命中率高
- **适合小Hash**：字段不多时内存效率最高

**缺点分析**：
- **查找较慢**：需要遍历查找字段，O(N)复杂度
- **更新代价高**：插入删除可能需要移动大量数据

### 3.3 hashtable编码详解


**存储结构**：传统哈希表实现

```
hashtable结构：
┌─────────────┐
│ 哈希表数组   │
├─────────────┤
│ [0] -> NULL │
│ [1] -> Node │ -> field1:value1
│ [2] -> Node │ -> field2:value2 -> field3:value3
│ [3] -> NULL │
│ ...         │
└─────────────┘
```

**优势特点**：
- **查找高效**：平均O(1)时间复杂度
- **扩展性好**：支持大量字段存储
- **操作灵活**：插入删除操作代价较小

### 3.4 转换阈值配置


```bash
# 查看Hash编码转换配置
CONFIG GET hash-max-ziplist-entries   # 默认512
CONFIG GET hash-max-ziplist-value     # 默认64

# 调整转换阈值
CONFIG SET hash-max-ziplist-entries 1024
CONFIG SET hash-max-ziplist-value 128
```

**配置含义**：
- `hash-max-ziplist-entries`：ziplist最大字段数量
- `hash-max-ziplist-value`：ziplist中单个值的最大长度

**实际测试**：
```bash
# 创建小Hash
HMSET small:hash f1 v1 f2 v2 f3 v3
OBJECT ENCODING small:hash    # "ziplist"

# 创建大Hash  
# ... 添加超过512个字段 ...
OBJECT ENCODING big:hash      # "hashtable"
```

### 3.5 内存和性能权衡


| 编码类型 | 内存使用 | 查询性能 | 更新性能 | 适用场景 |
|----------|----------|----------|----------|----------|
| **ziplist** | 🟢 很低 | 🔴 O(N) | 🟡 中等 | 小型Hash，读多写少 |
| **hashtable** | 🔴 较高 | 🟢 O(1) | 🟢 很好 | 大型Hash，频繁更新 |

---

## 4. 📋 List内部编码


### 4.1 quicklist编码机制


**List统一编码**：Redis 3.2版本后，List只使用quicklist编码

```
quicklist结构解析：
┌─────────────────────────────────────┐
│            quicklist                │
├─────────────────────────────────────┤
│ quicklistNode1 -> quicklistNode2 -> │
│      |               |              │
│   ziplist1        ziplist2          │
└─────────────────────────────────────┘

每个节点包含一个ziplist：
quicklistNode1: [elem1, elem2, elem3, elem4]
quicklistNode2: [elem5, elem6, elem7, elem8]
```

**设计思路**：
- **双向链表**：quicklistNode之间用双向链表连接
- **ziplist节点**：每个节点内部是一个ziplist
- **兼顾优势**：结合了链表和ziplist的优点

### 4.2 压缩深度配置


```bash
# 查看List压缩配置
CONFIG GET list-compress-depth    # 默认0 (不压缩)

# 设置压缩深度
CONFIG SET list-compress-depth 1
```

**压缩深度说明**：
```
compress-depth = 0: 不压缩任何节点
compress-depth = 1: 压缩除头尾各1个节点外的所有节点
compress-depth = 2: 压缩除头尾各2个节点外的所有节点

示例(depth=1)：
[未压缩] -> [压缩] -> [压缩] -> [未压缩]
   头部       中间      中间      尾部
```

**压缩策略**：
- **头尾不压缩**：保证LPUSH/RPUSH/LPOP/RPOP操作高效
- **中间压缩**：节省内存空间
- **按需解压**：访问时自动解压缩

### 4.3 节点大小优化


```bash
# 查看节点大小配置
CONFIG GET list-max-ziplist-size    # 默认-2

# 配置说明：
# 正数：表示节点最大元素个数
# 负数：表示节点最大字节数
#   -1: 4KB
#   -2: 8KB (推荐)
#   -3: 16KB
#   -4: 32KB
#   -5: 64KB
```

**节点大小权衡**：
```
节点太小：
❌ 指针开销大
❌ 内存碎片多
✅ 插入删除快

节点太大：
✅ 指针开销小
❌ 插入删除慢
❌ 内存复制多
```

### 4.4 内存碎片控制


**quicklist优势**：
- **减少碎片**：大块连续内存分配
- **局部性好**：相邻元素物理相邻
- **平衡性能**：在内存和性能间找到平衡

**实际效果**：
```bash
# 创建大型List
LPUSH big:list element1 element2 ... element10000
OBJECT ENCODING big:list    # "quicklist"

# 内存使用分析
MEMORY USAGE big:list       # 查看实际内存占用
```

---

## 5. 🏷️ Set内部编码


### 5.1 两种编码方式


**Set编码选择条件**：
```
数据类型和规模判断           编码选择
┌─────────────────────┐    ┌─────────────────┐
│ 全部是整数元素       │    │                 │
│ 且                  │ -> │ intset编码      │
│ 元素数量 < 512个     │    │ (整数集合)      │
├─────────────────────┤    ├─────────────────┤
│ 包含非整数元素       │    │                 │
│ 或                  │ -> │ hashtable编码   │
│ 元素数量 ≥ 512个     │    │ (哈希表)        │
└─────────────────────┘    └─────────────────┘
```

### 5.2 intset编码详解


**存储结构**：紧凑的整数数组

```
intset内部结构：
┌──────────┬─────────┬─────────┬─────────┬─────────┐
│ 编码类型 │ 长度    │ 元素1   │ 元素2   │ 元素3   │
├──────────┼─────────┼─────────┼─────────┼─────────┤
│ int16_t  │ 3       │ 100     │ 200     │ 300     │
└──────────┴─────────┴─────────┴─────────┴─────────┘
```

**编码类型**：
- **INTSET_ENC_INT16**：-32768 到 32767
- **INTSET_ENC_INT32**：-2^31 到 2^31-1  
- **INTSET_ENC_INT64**：-2^63 到 2^63-1

**示例演示**：
```bash
# intset编码示例
SADD numbers 1 2 3 4 5
OBJECT ENCODING numbers    # "intset"

# 添加大整数会升级编码
SADD numbers 2147483648
OBJECT ENCODING numbers    # 仍是"intset"，但内部升级为int64

# 添加非整数会转换编码
SADD numbers "hello"
OBJECT ENCODING numbers    # "hashtable"
```

### 5.3 hashtable编码详解


**存储结构**：标准哈希表实现

```bash
# hashtable编码示例
SADD mixed_set 1 "hello" 3.14 "world"
OBJECT ENCODING mixed_set    # "hashtable"
```

**特点分析**：
- **类型灵活**：支持任意类型元素
- **操作高效**：增删查改都是O(1)平均复杂度
- **内存开销**：相比intset有额外的指针和结构开销

### 5.4 编码选择策略


```bash
# 查看Set编码配置
CONFIG GET set-max-intset-entries    # 默认512

# 调整配置
CONFIG SET set-max-intset-entries 1024
```

**性能影响分析**：

| 操作类型 | intset性能 | hashtable性能 | 说明 |
|----------|------------|---------------|------|
| **添加元素** | O(N) | O(1) | intset需要保持有序 |
| **删除元素** | O(N) | O(1) | intset需要移动元素 |
| **查找元素** | O(log N) | O(1) | intset使用二分查找 |
| **内存使用** | 很低 | 较高 | intset更紧凑 |

---

## 6. 🎯 ZSet内部编码


### 6.1 两种编码机制


**ZSet编码选择逻辑**：
```
数据规模判断                 编码选择
┌─────────────────────┐    ┌─────────────────────┐
│ 元素数量 < 128个     │    │ ziplist编码         │
│ 且                  │ -> │ (压缩列表)          │
│ 每个元素长度 < 64字节│    │                     │
├─────────────────────┤    ├─────────────────────┤
│ 超出上述条件         │ -> │ skiplist+hashtable  │
│                     │    │ (跳表+哈希表)       │
└─────────────────────┘    └─────────────────────┘
```

### 6.2 ziplist编码详解


**存储结构**：分数和元素交替存储

```
ziplist中ZSet的存储格式：
┌─────┬───────┬───────┬───────┬───────┬─────┐
│ 头部│ elem1 │score1 │ elem2 │score2 │ 尾部│
└─────┴───────┴───────┴───────┴───────┴─────┘

实际示例：
"apple" -> 85.5 -> "banana" -> 92.0 -> "orange" -> 78.3
```

**排序维护**：
- **按分数排序**：元素按score从小到大排列
- **相同分数**：按元素字典序排列
- **插入排序**：新元素插入到正确位置

```bash
# ziplist编码示例
ZADD fruits 85.5 "apple" 92.0 "banana" 78.3 "orange"
OBJECT ENCODING fruits    # "ziplist"

ZRANGE fruits 0 -1 WITHSCORES
# 1) "orange"   (78.3)
# 2) "apple"    (85.5)  
# 3) "banana"   (92.0)
```

### 6.3 skiplist+hashtable编码详解


**双重数据结构**：
```
skiplist+hashtable组合：
┌─────────────────────────────────────┐
│            ZSet对象                 │
├─────────────────────────────────────┤
│ skiplist: 按分数排序，支持范围查询   │
│    Level 3: [apple] -----------> [orange] │
│    Level 2: [apple] -> [banana] -> [orange]│
│    Level 1: [apple] -> [banana] -> [orange]│
├─────────────────────────────────────┤
│ hashtable: 元素到分数的映射         │
│    "apple" -> 85.5                 │
│    "banana" -> 92.0                │
│    "orange" -> 78.3                │
└─────────────────────────────────────┘
```

**数据结构职责**：
- **skiplist**：提供排序功能，支持范围查询
- **hashtable**：提供O(1)的分数查找

### 6.4 编码转换机制


```bash
# 查看ZSet编码配置
CONFIG GET zset-max-ziplist-entries   # 默认128
CONFIG GET zset-max-ziplist-value     # 默认64

# 触发编码转换
ZADD small:zset 1.0 "a" 2.0 "b" 3.0 "c"
OBJECT ENCODING small:zset    # "ziplist"

# 添加长字符串触发转换
ZADD small:zset 4.0 "this_is_a_very_long_string_that_exceeds_64_bytes_limit_so_it_will_trigger_encoding_conversion"
OBJECT ENCODING small:zset    # "skiplist"
```

### 6.5 查询性能优化


**不同操作的复杂度**：

| 操作类型 | ziplist性能 | skiplist性能 | 优势场景 |
|----------|-------------|--------------|----------|
| **按分数查找** | O(N) | O(log N) | 大数据集查询 |
| **范围查询** | O(N) | O(log N + M) | 范围遍历操作 |
| **按元素查找分数** | O(N) | O(1) | 频繁分数查询 |
| **内存使用** | 很低 | 较高 | 内存敏感场景 |

**实际应用建议**：
```bash
# 小规模排行榜(适合ziplist)
ZADD small:ranking 95 "user1" 87 "user2" 92 "user3"

# 大规模排行榜(需要skiplist)  
ZADD big:ranking ...   # 数千个用户分数

# 查看性能差异
ZRANGE small:ranking 0 10 WITHSCORES    # ziplist遍历
ZRANGE big:ranking 0 10 WITHSCORES      # skiplist高效查询
```

---

## 7. ⚙️ 编码优化策略


### 7.1 配置参数调优


**核心配置汇总**：
```bash
# String编码 (通常不需要调整)
# int: 自动判断
# embstr: 44字节固定阈值  
# raw: 超过44字节

# Hash编码调优
CONFIG SET hash-max-ziplist-entries 512    # ziplist最大字段数
CONFIG SET hash-max-ziplist-value 64       # ziplist最大值长度

# List编码调优
CONFIG SET list-max-ziplist-size -2        # 节点大小(推荐-2=8KB)
CONFIG SET list-compress-depth 0           # 压缩深度

# Set编码调优
CONFIG SET set-max-intset-entries 512      # intset最大元素数

# ZSet编码调优
CONFIG SET zset-max-ziplist-entries 128    # ziplist最大元素数
CONFIG SET zset-max-ziplist-value 64       # ziplist最大值长度
```

### 7.2 应用场景优化建议


**内存优先场景**：
```bash
# 提高ziplist/intset使用比例
CONFIG SET hash-max-ziplist-entries 1024
CONFIG SET hash-max-ziplist-value 128
CONFIG SET set-max-intset-entries 1024
CONFIG SET zset-max-ziplist-entries 256
```

**性能优先场景**：
```bash
# 更早转换为高效编码
CONFIG SET hash-max-ziplist-entries 256
CONFIG SET hash-max-ziplist-value 32
CONFIG SET set-max-intset-entries 256  
CONFIG SET zset-max-ziplist-entries 64
```

### 7.3 监控和调试


**编码监控方法**：
```bash
# 1. 查看具体key的编码
OBJECT ENCODING keyname

# 2. 查看key的内存使用
MEMORY USAGE keyname

# 3. 分析内存使用详情
MEMORY USAGE keyname SAMPLES 5

# 4. 批量分析编码分布
# 可以写脚本遍历keys，统计各种编码的使用情况
```

**性能测试对比**：
```bash
# 测试不同编码下的操作性能
# 可以创建相同数据的不同编码版本进行对比测试

# 小Hash测试(ziplist)
HMSET test:small f1 v1 f2 v2 ... f10 v10

# 大Hash测试(hashtable)  
HMSET test:big f1 v1 f2 v2 ... f1000 v1000

# 对比HGET性能差异
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 内部编码：Redis为每种数据类型提供多种存储格式
🔸 自动选择：根据数据特点自动选择最优编码方式
🔸 透明优化：对应用程序完全透明，接口保持一致
🔸 性能权衡：在内存使用和访问速度间找平衡
🔸 配置调优：可通过参数调整编码转换阈值
```

### 8.2 各数据类型编码要点


**🔹 String编码记忆要点**：
```
int编码：     纯整数，节省内存，支持数值运算
embstr编码：  短字符串(≤44字节)，内存连续，只读优化  
raw编码：     长字符串(>44字节)，可修改，独立存储
```

**🔹 Hash编码选择策略**：
```
ziplist：     小Hash(<512字段，<64字节值)，内存紧凑
hashtable：   大Hash，查询高效O(1)，更新灵活
```

**🔹 List编码特点**：
```
quicklist：   统一编码，结合链表和ziplist优势
压缩优化：     中间节点可压缩，头尾保持高效访问
节点大小：     可配置，平衡内存和性能
```

**🔹 Set编码区别**：
```
intset：      纯整数集合，紧凑存储，有序数组
hashtable：   混合类型，哈希存储，操作高效
```

**🔹 ZSet编码机制**：
```
ziplist：     小ZSet，按分数排序存储
skiplist+hash：大ZSet，跳表排序+哈希查找
```

### 8.3 实践优化建议


**🔧 配置优化原则**：
```
内存优先：
- 提高ziplist/intset的使用阈值
- 适合内存受限但性能要求不高的场景

性能优先：  
- 降低转换阈值，更早使用高效编码
- 适合内存充足但性能要求高的场景

平衡配置：
- 使用默认配置，适合大多数应用场景
```

**🔧 应用设计建议**：
```
数据结构设计：
- 预估数据规模，选择合适的数据类型
- 控制Hash字段数量和值长度
- 合理组织Set和ZSet的元素

性能监控：
- 定期检查key的内部编码
- 监控内存使用情况
- 测试关键操作的性能表现
```

### 8.4 常见问题解答


**❓ 编码转换对性能的影响**：
```
转换时机：编码转换发生在写操作时
转换代价：需要重新组织数据，有一定开销
影响程度：大部分情况下影响很小，转换后性能可能更好
```

**❓ 如何选择最优配置**：
```
分析数据特征：统计key的大小和访问模式
压力测试：对比不同配置下的性能表现  
监控调整：根据实际运行情况动态调整
```

**核心记忆**：
- Redis内部编码像存储格式，自动选最优方案
- 小数据用紧凑编码省内存，大数据用快速编码提性能
- 配置可调整转换阈值，根据场景优化内存和速度
- 编码转换对应用透明，性能提升用户无感知