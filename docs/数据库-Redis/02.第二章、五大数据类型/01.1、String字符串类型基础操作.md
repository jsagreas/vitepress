---
title: 1、String字符串类型基础操作
---
## 📚 目录

1. [String类型概述](#1-String类型概述)
2. [基础存取操作](#2-基础存取操作)
3. [条件设置操作](#3-条件设置操作)
4. [批量操作](#4-批量操作)
5. [基础应用场景](#5-基础应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔤 String类型概述


### 1.1 什么是Redis String


**💡 简单理解**：String是Redis最基础的数据类型，就像一个万能的"盒子"，可以存放各种文本内容。

```
想象场景：
你有一个标签箱，箱子上贴着标签(key)，里面放着纸条(value)
标签："user_name"     纸条内容："张三"
标签："user_age"      纸条内容："25"
标签："config_info"   纸条内容：'{"theme":"dark","lang":"zh"}'
```

### 1.2 String类型特点


**🔸 核心特性**
```
✅ 二进制安全：可以存储任何数据（文本、图片、序列化对象等）
✅ 最大容量：单个String最大可存储512MB数据
✅ 原子操作：所有操作都是原子性的，不会被中断
✅ 编码灵活：自动选择最优存储编码（int、embstr、raw）
```

**🎯 数据存储方式**
```
┌─────────────────────────────────────┐
│        Redis String 存储示例        │
├─────────────┬───────────────────────┤
│ Key         │ Value                 │
├─────────────┼───────────────────────┤
│ "count"     │ "100"                │
│ "username"  │ "john_doe"           │
│ "config"    │ '{"port":6379}'      │
│ "logo"      │ [binary image data]   │
└─────────────┴───────────────────────┘
```

---

## 2. 📝 基础存取操作


### 2.1 SET - 存储数据


**💡 作用**：把数据存到Redis里，就像往盒子里放纸条

```bash
# 基本语法
SET key value

# 实际示例
SET user_name "张三"
SET user_age "25" 
SET website_title "我的博客"
```

> 🔧 **实践说明**：SET操作会**覆盖**已存在的键值，就像换掉盒子里的纸条

### 2.2 GET - 读取数据


**💡 作用**：从Redis取出数据，就像从盒子里拿出纸条看内容

```bash
# 基本语法
GET key

# 实际示例
GET user_name        # 返回："张三"
GET user_age         # 返回："25"
GET not_exist_key    # 返回：(nil) - 表示不存在
```

**📋 返回值说明**
```
存在的key    → 返回对应的字符串值
不存在的key  → 返回 (nil)
错误的key    → 返回错误信息
```

### 2.3 GETSET - 原子性更新


**💡 作用**：一步操作完成"取出旧值+存入新值"，防止并发问题

```bash
# 基本语法  
GETSET key new_value

# 实际示例
SET counter "10"
GETSET counter "20"    # 返回："10"，同时设置新值为"20"
GET counter            # 返回："20"
```

**🎯 使用场景**：更新计数器、切换状态等需要知道旧值的操作

### 2.4 STRLEN - 获取长度


**💡 作用**：计算存储内容的字符长度

```bash
# 基本语法
STRLEN key

# 实际示例
SET message "Hello Redis"
STRLEN message         # 返回：11（包含空格）
STRLEN not_exist       # 返回：0（不存在返回0）
```

### 2.5 APPEND - 追加内容


**💡 作用**：在现有内容后面追加新内容，类似字符串拼接

```bash
# 基本语法
APPEND key value

# 实际示例
SET log_info "用户登录"
APPEND log_info " - 时间：2024-08-28"
GET log_info           # 返回："用户登录 - 时间：2024-08-28"
```

**📊 返回值**：返回追加后字符串的总长度

---

## 3. ⚙️ 条件设置操作


### 3.1 SETNX - 不存在才设置


**💡 作用**：只有当key不存在时才设置值，类似"占座位"操作

```bash
# 基本语法
SETNX key value

# 实际示例
SETNX user_token "abc123"    # key不存在，设置成功，返回：1
SETNX user_token "def456"    # key已存在，设置失败，返回：0
```

**🔒 典型应用**：分布式锁、防重复操作
```bash
# 模拟抢座位
SETNX seat_001 "张三"    # 张三抢到座位，返回：1
SETNX seat_001 "李四"    # 李四没抢到，返回：0
```

### 3.2 SETEX - 设置带过期时间


**💡 作用**：设置值的同时指定过期时间（秒级）

```bash
# 基本语法
SETEX key seconds value

# 实际示例
SETEX verify_code 300 "123456"    # 验证码5分钟后过期
SETEX session_id 3600 "sess_abc"  # 会话1小时后过期
```

**⏰ 时间说明**
```
300秒 = 5分钟
3600秒 = 1小时  
86400秒 = 24小时
```

### 3.3 PSETEX - 毫秒级过期时间


**💡 作用**：和SETEX一样，但过期时间精确到毫秒

```bash
# 基本语法
PSETEX key milliseconds value

# 实际示例
PSETEX temp_token 5000 "temp123"   # 5秒后过期
PSETEX quick_cache 1500 "data"     # 1.5秒后过期
```

**⚡ 使用场景**：需要精确控制短时间缓存的场景

---

## 4. 📦 批量操作


### 4.1 MSET - 批量设置


**💡 作用**：一次性设置多个键值对，提高效率

```bash
# 基本语法
MSET key1 value1 key2 value2 key3 value3 ...

# 实际示例
MSET name "张三" age "25" city "北京"
# 相当于执行：
# SET name "张三"
# SET age "25"  
# SET city "北京"
```

**⚡ 性能优势**：减少网络往返次数，比逐个SET快很多

### 4.2 MGET - 批量获取


**💡 作用**：一次性获取多个键的值

```bash
# 基本语法
MGET key1 key2 key3 ...

# 实际示例
MGET name age city
# 返回：
# 1) "张三"
# 2) "25" 
# 3) "北京"
```

**📋 返回说明**
```
存在的key    → 返回对应值
不存在的key  → 返回(nil)
返回顺序    → 与请求顺序一致
```

### 4.3 MSETNX - 批量条件设置


**💡 作用**：批量设置，但要求**所有key都不存在**才能成功

```bash
# 基本语法
MSETNX key1 value1 key2 value2 ...

# 实际示例
MSETNX user1 "张三" user2 "李四"    # 两个key都不存在时才成功
```

**⚠️ 重要特性**：原子操作 - 要么全部成功，要么全部失败
```
如果user1存在，user2不存在
→ 整个操作失败，user2也不会被设置
→ 返回：0（失败）
```

---

## 5. 🚀 基础应用场景


### 5.1 简单键值存储


**💡 场景描述**：最基本的存取操作，类似变量存储

```bash
# 用户基本信息
SET user:1001:name "张三"
SET user:1001:email "zhangsan@example.com"
SET user:1001:phone "13800138000"

# 获取信息
GET user:1001:name    # 返回："张三"
```

**🎯 适用场景**：用户资料、商品信息、系统状态等

### 5.2 配置信息缓存


**💡 场景描述**：存储系统配置，避免频繁读取数据库

```bash
# 系统配置
SET config:database_host "192.168.1.100"
SET config:max_connections "1000"  
SET config:debug_mode "true"

# 用户个人设置
MSET user:1001:theme "dark" user:1001:lang "zh-CN" user:1001:timezone "Asia/Shanghai"
```

**✅ 优势**：快速读取、减少数据库压力、配置实时生效

### 5.3 临时数据存储


**💡 场景描述**：存储验证码、临时Token等有时效性的数据

```bash
# 短信验证码（5分钟过期）
SETEX sms:13800138000 300 "123456"

# 用户登录Token（2小时过期）  
SETEX token:user1001 7200 "eyJhbGciOiJIUzI1NiIs..."

# 检查验证码
GET sms:13800138000    # 返回："123456" 或 (nil)已过期
```

**⏰ 过期自动清理**：Redis会自动删除过期的key，节省内存

### 5.4 JSON对象存储


**💡 场景描述**：将复杂对象序列化为JSON字符串存储

```bash
# 用户完整信息
SET user:1001:profile '{
  "id": 1001,
  "name": "张三", 
  "age": 25,
  "address": {
    "city": "北京",
    "district": "朝阳区"
  },
  "hobbies": ["读书", "旅游"]
}'

# 商品详情
SET product:2001 '{
  "id": 2001,
  "title": "苹果iPhone15",
  "price": 5999,
  "stock": 100,
  "specs": {"color": "黑色", "storage": "128GB"}
}'
```

**🔧 使用建议**
```
优点：存储灵活，一次获取完整对象
注意：需要应用层处理JSON序列化/反序列化
适合：读多写少的复杂对象
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的基本概念


```
🔸 String类型：Redis最基础的数据类型，可存储文本和二进制数据
🔸 原子操作：所有String操作都是原子性的，保证数据一致性
🔸 过期机制：SETEX/PSETEX可设置自动过期，节省内存
🔸 批量操作：MSET/MGET提高操作效率，减少网络开销
🔸 条件设置：SETNX实现"不存在才设置"的逻辑
```

### 6.2 操作命令分类记忆


**📊 命令分类表**

| 操作类型 | 命令 | 作用 | 返回值 |
|---------|------|------|--------|
| **基础操作** | `SET key value` | 设置值 | OK |
| | `GET key` | 获取值 | 字符串值或nil |
| | `GETSET key value` | 获取旧值并设置新值 | 旧值或nil |
| **字符串操作** | `STRLEN key` | 获取长度 | 数字 |
| | `APPEND key value` | 追加内容 | 新长度 |
| **条件设置** | `SETNX key value` | 不存在才设置 | 1成功/0失败 |
| | `SETEX key sec value` | 设置+过期时间 | OK |
| | `PSETEX key ms value` | 毫秒级过期 | OK |
| **批量操作** | `MSET k1 v1 k2 v2` | 批量设置 | OK |
| | `MGET k1 k2 k3` | 批量获取 | 值列表 |
| | `MSETNX k1 v1 k2 v2` | 批量条件设置 | 1成功/0失败 |

### 6.3 实际应用指导


**🎯 选择合适的操作**
```
简单存储          → 使用 SET/GET
需要防覆盖        → 使用 SETNX
需要自动过期      → 使用 SETEX/PSETEX
批量操作          → 使用 MSET/MGET
需要知道旧值      → 使用 GETSET
字符串拼接        → 使用 APPEND
```

**⚡ 性能优化建议**
```
✅ 批量操作优于循环单次操作
✅ 合理设置过期时间，避免内存浪费  
✅ key命名要有规律，便于管理
✅ 避免存储过大的单个String（建议<1MB）
```

**🚨 常见使用注意事项**
```
注意点1：SET会覆盖现有值，需要保留用SETNX
注意点2：MSET/MGET的key顺序要对应
注意点3：MSETNX是原子操作，部分失败则全部失败
注意点4：过期时间设置后不可延长，只能重新设置
注意点5：APPEND对不存在的key等同于SET
```

**核心记忆口诀**：
- String类型最基础，存储文本和二进制
- SET存储GET读取，SETNX防止覆盖
- 批量操作提效率，MSET MGET要成对
- 过期时间能自清，临时数据最适宜