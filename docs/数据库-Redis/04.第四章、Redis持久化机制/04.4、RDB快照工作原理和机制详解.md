---
title: 4、RDB快照工作原理和机制详解
---
## 📚 目录

1. [RDB快照基本概念](#1-RDB快照基本概念)
2. [内存快照实现原理](#2-内存快照实现原理)
3. [fork子进程机制详解](#3-fork子进程机制详解)
4. [COW写时复制原理](#4-COW写时复制原理)
5. [RDB生成完整流程](#5-RDB生成完整流程)
6. [RDB文件格式解析](#6-RDB文件格式解析)
7. [内存使用量评估](#7-内存使用量评估)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📸 RDB快照基本概念


### 1.1 什么是RDB快照


**📝 通俗理解**
```
RDB就像给Redis内存数据拍了一张"照片"
把某个时刻所有数据的状态保存到硬盘文件中
就像你给房间拍照，记录下房间里所有东西的位置

RDB = Redis DataBase的缩写
快照 = 某个时刻数据的完整副本
```

**🔸 快照的本质特征**
```
时间点一致性：记录的是某个特定时刻的数据状态
完整性：包含Redis中所有数据库的所有数据
二进制格式：保存为紧凑的二进制文件
不可修改：快照文件只读，不能直接编辑
```

### 1.2 RDB快照解决的问题


**💡 数据持久化需求**
```
问题：Redis数据存在内存中，服务器重启数据丢失
解决：定期把内存数据保存到硬盘

生活类比：
内存数据 = 黑板上写的内容（断电就没了）
RDB快照 = 用相机拍下黑板内容（永久保存）
```

**🔸 RDB的优势**
```
启动快速：加载RDB文件比重放AOF日志快得多
文件紧凑：二进制格式，文件体积小
备份方便：单个文件包含完整数据，方便备份传输
性能影响小：使用子进程生成，不阻塞主进程
```

### 1.3 RDB触发方式


**🔸 自动触发**
```bash
# 在redis.conf中配置
save 900 1      # 900秒内至少1次写操作就保存
save 300 10     # 300秒内至少10次写操作就保存  
save 60 10000   # 60秒内至少10000次写操作就保存

# 查看当前配置
127.0.0.1:6379> CONFIG GET save
1) "save"
2) "900 1 300 10 60 10000"
```

**🔸 手动触发**
```bash
# 立即生成RDB快照（阻塞）
SAVE

# 后台生成RDB快照（非阻塞，推荐）
BGSAVE

# 示例
127.0.0.1:6379> BGSAVE
Background saving started    # 后台开始保存
```

**🔸 其他触发场景**
```
服务器关闭：执行SHUTDOWN命令时
主从同步：主服务器向从服务器发送数据时
DEBUG RELOAD：重新加载Redis时
```

---

## 2. 💾 内存快照实现原理


### 2.1 快照的挑战


**🤔 核心问题**
```
Redis在运行时不断有新的读写操作
如何在数据变化的同时生成一致的快照？

生活类比：
给一个正在开会的会议室拍照
会议过程中人员在不断变化
怎么拍出某个时刻的完整照片？

解决方案：
暂停所有活动拍照 = SAVE命令（会阻塞）
复制一个会议室拍照 = BGSAVE命令（不阻塞）
```

### 2.2 SAVE vs BGSAVE


**🔸 SAVE命令机制**
```
工作方式：主进程直接执行快照操作
特点：
✅ 实现简单，数据一致性好
❌ 阻塞所有客户端请求
❌ 快照期间Redis无法处理其他命令

适用场景：
- 服务器关闭前的最后保存
- 测试环境的快速备份
- 数据量很小的情况
```

**🔸 BGSAVE命令机制**
```
工作方式：创建子进程执行快照操作
特点：
✅ 不阻塞主进程，用户请求正常处理
✅ 适合生产环境使用
❌ 实现复杂，需要fork和COW机制
❌ 短时间内内存使用量可能翻倍

适用场景：
- 生产环境的定期备份
- 数据量大的情况
- 需要保证服务可用性
```

### 2.3 快照数据一致性


**🔸 时间点一致性**
```
快照记录的是fork时刻的数据状态
fork之后的数据变化不会影响快照内容

时间轴示例：
T1: 开始执行BGSAVE，创建子进程
T2: 用户修改数据A
T3: 用户删除数据B  
T4: 快照完成

结果：快照中包含T1时刻的数据A和数据B
     T2和T3的操作不影响快照内容
```

**🔸 数据完整性保障**
```
内存映射：子进程看到的是fork时刻的完整内存映像
原子操作：fork操作本身是原子的
写时复制：确保快照过程中数据不被意外修改
```

---

## 3. 🍴 fork子进程机制详解


### 3.1 什么是fork


**📝 fork概念解释**
```
fork是Linux系统调用，用于创建进程副本
调用fork后，系统中会有两个几乎相同的进程

生活类比：
原进程 = 原版书
fork操作 = 复印机复印
子进程 = 复印出来的副本

两本书内容一样，但可以独立使用
```

### 1.2 fork的工作机制


**🔸 进程创建过程**
```
父进程执行fork() → 操作系统创建子进程 → 返回不同的PID

父进程中：fork()返回子进程的PID（>0）
子进程中：fork()返回0
出错时：fork()返回-1

Redis中的应用：
主进程：继续处理客户端请求
子进程：专门负责生成RDB快照
```

**🔸 父子进程关系图**
```
Redis主进程                     RDB子进程
     │                           │
     │──── fork() ───────────────▶│
     │                           │
     │ 继续处理客户端请求           │ 生成RDB快照
     │ SET name "张三"            │ 遍历内存数据
     │ GET user:1001             │ 写入文件
     │ INCR counter              │ 同步到磁盘
     │                           │
     │◀──── 快照完成信号 ─────────│
     │                           │
     │                           │ 子进程退出
```

### 3.3 fork的优势


**🔸 隔离性**
```
父子进程相互独立，互不影响
子进程崩溃不会影响主进程
主进程继续正常服务，子进程专心生成快照
```

**🔸 并发性**
```
真正的并发执行：
主进程 + 子进程同时运行
用户请求不受快照影响
快照生成不受用户请求影响
```

### 3.4 fork的成本


**⚠️ 资源消耗**
```
CPU成本：
- fork操作本身需要复制进程信息
- 创建新进程需要系统资源

内存成本：
- 理论上：fork后内存使用量翻倍
- 实际上：通过COW机制优化，实际增加量少很多

时间成本：
- fork速度与内存大小相关
- 内存越大，fork用时越长
```

---

## 4. 📋 COW写时复制原理


### 4.1 什么是COW


**📝 COW概念解释**
```
COW = Copy-On-Write，写时复制
是一种内存管理优化技术

核心思想：
不要一开始就复制，等到真正需要修改时再复制

生活类比：
两个人看同一本书 = 共享内存页面
其中一人要在书上做笔记 = 写操作
这时复印一份给他 = 复制内存页面
另一人继续看原书 = 继续共享未修改页面
```

### 4.2 COW工作机制


**🔸 内存共享阶段**
```
fork刚完成时的内存布局：

物理内存中的数据：
┌─────────────────────────────┐
│  Redis数据（物理内存页）     │
└─────────────────────────────┘
          ▲           ▲
          │           │
    父进程虚拟内存  子进程虚拟内存
    （只读映射）    （只读映射）

此时：两个进程共享相同的物理内存页面
内存使用量：基本没有增加
```

**🔸 写操作触发复制**
```
当主进程修改数据时的内存变化：

修改前（共享）：
父进程 ──▶ ┌──────────┐ ◀── 子进程
          │ 原始数据页 │
          └──────────┘

修改时（触发复制）：
父进程 ──▶ ┌──────────┐
          │ 新数据页  │  
          └──────────┘
                     
子进程 ──▶ ┌──────────┐
          │ 原始数据页 │
          └──────────┘

结果：父进程看到新数据，子进程看到原数据
```

### 4.3 COW的优化效果


**📊 内存使用对比**
```
没有COW（理论情况）：
Redis数据：8GB
fork后：父进程8GB + 子进程8GB = 16GB
内存翻倍！

有COW（实际情况）：
Redis数据：8GB
fork后：共享8GB + 修改的页面
实际增加：通常只有几百MB到1-2GB

优化效果：内存增加量减少80-90%
```

**💡 影响COW效果的因素**
```
写操作频率：
- 写操作越频繁，复制的页面越多
- 写操作越少，共享的页面越多

数据修改范围：
- 修改小对象：只复制包含该对象的页面
- 修改大对象：可能复制多个页面

快照生成时间：
- 快照时间越长，期间的写操作越多
- 快照时间越短，共享效果越好
```

### 4.4 COW实际效果分析


**🔸 最佳情况**
```
场景：快照期间很少有写操作
结果：大部分内存页面保持共享
内存增加：接近0

例如：夜间备份时，用户活跃度低
```

**🔸 最坏情况**
```
场景：快照期间大量写操作
结果：大部分内存页面被复制
内存增加：接近翻倍

例如：高峰期备份，写操作频繁
```

**🔸 典型情况**
```
场景：正常业务运行期间
结果：部分内存页面复制
内存增加：20-50%

建议：选择业务低峰期进行快照
```

---

## 5. 🔄 RDB生成完整流程


### 5.1 触发条件判断


**🔸 自动触发条件检查**
```bash
# Redis内部检查机制（每100ms执行一次）
定时检查：
1. 检查save配置规则
2. 统计最近写操作次数
3. 计算距离上次快照的时间
4. 判断是否满足触发条件

# 例如：save 300 10
检查逻辑：
IF (当前时间 - 上次快照时间) >= 300秒 AND 写操作次数 >= 10:
    触发BGSAVE
```

**🔸 触发流程图**
```
定时检查 ──▶ 满足save规则？ ──No──▶ 继续等待
              │
              Yes
              ▼
          正在执行快照？ ──Yes──▶ 跳过本次
              │
              No  
              ▼
           执行BGSAVE
```

### 5.2 子进程创建过程


**🔸 详细创建步骤**
```
步骤1：主进程调用fork()系统调用
      ↓
步骤2：操作系统创建子进程
      ↓  
步骤3：设置子进程的内存映射（只读）
      ↓
步骤4：子进程开始执行快照逻辑
      ↓
步骤5：主进程继续处理客户端请求
```

**🔸 进程状态变化**
```bash
# 查看Redis进程状态
ps aux | grep redis

# BGSAVE执行前：
# redis-server 进程ID: 1234

# BGSAVE执行中：
# redis-server 进程ID: 1234 (主进程)
# redis-server 进程ID: 1235 (RDB子进程)

# BGSAVE完成后：
# redis-server 进程ID: 1234 (子进程已退出)
```

### 5.3 内存数据遍历


**🔸 数据遍历策略**
```
遍历顺序：
1. 遍历所有数据库（db0, db1, ..., db15）
2. 每个数据库遍历所有键值对
3. 按照键的类型选择不同的序列化方法

遍历机制：
- 使用Redis内部的字典迭代器
- 逐个访问哈希表中的每个槽位
- 处理哈希冲突链表中的所有元素
```

**🔸 不同数据类型的处理**
```
String类型：
- 直接序列化字符串内容
- 记录编码类型（int、raw、embstr）

List类型：
- 遍历链表或quicklist结构
- 保存列表中每个元素

Hash类型：  
- 遍历哈希表
- 保存每个field-value对

Set类型：
- 遍历集合中的所有元素
- 保存元素值

Sorted Set类型：
- 遍历跳跃表结构
- 保存元素值和分数
```

### 5.4 文件写入和同步


**🔸 写入流程**
```
步骤1：创建临时文件（temp-<进程ID>.rdb）
      ↓
步骤2：写入文件头信息
      ↓
步骤3：逐个数据库写入数据
      ↓
步骤4：写入文件校验信息
      ↓
步骤5：刷新文件系统缓冲区
      ↓
步骤6：原子性重命名为正式文件名
```

**🔸 原子性保障**
```
为什么使用临时文件？
避免写入过程中Redis崩溃导致RDB文件损坏

原子重命名：
temp-1234.rdb → dump.rdb
这个重命名操作是原子的，要么成功要么失败
不会出现半成品的dump.rdb文件

生活类比：
写作业时先写草稿，完成后再抄到正式作业本上
避免写作业过程中被打断导致作业本一团糟
```

---

## 6. 🗂️ RDB文件格式解析


### 6.1 文件整体结构


**🔸 RDB文件布局**
```
┌─────────────────┐
│   文件头信息     │ ← 魔数、版本号
├─────────────────┤
│   数据库0       │ ← SELECT 0 + 键值对数据
├─────────────────┤
│   数据库1       │ ← SELECT 1 + 键值对数据  
├─────────────────┤
│   ...          │ ← 其他非空数据库
├─────────────────┤
│   辅助信息      │ ← 过期时间、LRU信息等
├─────────────────┤
│   文件尾标识    │ ← EOF标记
├─────────────────┤
│   校验和        │ ← CRC64校验码
└─────────────────┘
```

### 6.2 文件头信息


**🔸 魔数和版本**
```
前9个字节的含义：
REDIS0009

REDIS：文件类型标识（5字节）
0009：RDB格式版本号（4字节）

版本演进：
0001-0005：早期版本（已淘汰）
0006：Redis 2.6版本
0007：Redis 2.8版本
0008：Redis 3.0版本
0009：Redis 3.2+版本（当前主流）
```

### 6.3 数据库信息存储


**🔸 数据库选择器**
```
格式：FE + database_number

示例：
FE 00：表示接下来是0号数据库的数据
FE 01：表示接下来是1号数据库的数据

只有包含数据的数据库才会出现在RDB文件中
空数据库会被跳过
```

**🔸 数据库大小信息**
```
格式：FB + hash_table_size + expire_hash_table_size

含义：
hash_table_size：该数据库键值对数量
expire_hash_table_size：设置了过期时间的键数量

作用：Redis加载时预分配哈希表大小，提高性能
```

### 6.4 键值对编码方式


**🔸 键值对基本格式**
```
完整键值对格式：
[过期时间信息] + 值类型 + 键名 + 键值

过期时间（可选）：
FD + 4字节秒级时间戳    # 秒级过期时间  
FC + 8字节毫秒时间戳   # 毫秒级过期时间

值类型：
00：String类型
01：List类型  
02：Set类型
03：Sorted Set类型
04：Hash类型
```

**🔸 不同类型的编码方式**
```
String编码：
- 整数：特殊编码，节省空间
- 短字符串：长度 + 内容
- 长字符串：长度 + 压缩后内容

List编码：
- 列表长度 + 每个元素（长度 + 内容）

Hash编码：
- 哈希表长度 + 每个字段（字段名 + 字段值）

Set编码：
- 集合大小 + 每个成员

Sorted Set编码：
- 有序集合大小 + 每个元素（成员值 + 分数）
```

### 6.5 文件校验机制


**🔸 CRC64校验**
```
位置：文件末尾8字节
算法：CRC64-ISO校验算法
作用：检测文件传输或存储过程中的错误

校验过程：
1. Redis计算整个文件的CRC64值
2. 将校验值写入文件末尾
3. 加载时重新计算校验值
4. 对比校验值，不一致则报错

生活类比：
像包裹上的防拆封条
如果封条被破坏，说明包裹被动过
```

**🔸 文件完整性验证**
```bash
# 检查RDB文件完整性
redis-check-rdb /var/lib/redis/dump.rdb

# 输出示例：
# [offset 0] Checking RDB file /var/lib/redis/dump.rdb
# [offset 26] AUX FIELD redis-ver = '7.0.0'
# [offset 40] AUX FIELD redis-bits = '64'  
# [offset 52] AUX FIELD ctime = '1640995200'
# [offset 67] AUX FIELD used-mem = '2097152'
# [offset 83] Checksum OK
# RDB looks OK

# 如果文件损坏：
# Bad file format reading the append only file
# 或者校验和不匹配的错误
```

---

## 7. 📊 内存使用量评估


### 7.1 fork内存开销计算


**🔸 理论内存需求**
```
最坏情况内存使用：
当前Redis内存使用量：M
fork后理论内存：M × 2

实际内存使用公式：
实际内存 = M + (写操作修改的内存页面)
```

**🔸 内存页面大小**
```bash
# 查看系统内存页面大小
getconf PAGESIZE
# 通常为4KB（4096字节）

# Redis中的含义：
每次写操作最少触发4KB的内存复制
修改1个字节 = 复制整个4KB页面
修改同一页面内的多个数据 = 只复制一次
```

### 7.2 实际内存增长评估


**🔸 影响因素分析**
```
数据分布：
- 热点数据集中：复制页面少
- 数据分布均匀：复制页面多

写操作模式：
- 顺序写入：影响页面少
- 随机写入：影响页面多  

快照时长：
- 快照时间短：写操作少，复制少
- 快照时间长：写操作多，复制多
```

**🔸 内存增长预估公式**
```
预估增长量 = (快照时长 × 每秒写操作数 × 平均影响页面数) × 页面大小

示例计算：
快照时长：30秒
每秒写操作：1000次
平均每次写操作影响：1个页面
页面大小：4KB

预估增长 = 30 × 1000 × 1 × 4KB = 120MB
```

### 7.3 内存监控


**🔸 监控fork内存使用**
```bash
# 查看内存相关信息
127.0.0.1:6379> INFO memory
used_memory:8388608          # 当前内存使用（8MB）
used_memory_peak:16777216    # 历史峰值内存（16MB）
used_memory_rss:12582912     # 操作系统分配内存（12MB）

# 监控说明：
# used_memory: Redis逻辑使用内存
# used_memory_rss: 操作系统实际分配内存
# 差值反映了COW产生的额外内存开销
```

**🔸 fork状态监控**
```bash
# 查看最近一次fork信息
127.0.0.1:6379> INFO persistence
# latest_fork_usec:1234    # 最近fork耗时（微秒）

# 实时监控fork状态
127.0.0.1:6379> LASTSAVE
(integer) 1640995200    # 最后保存时间戳

# 检查是否正在执行BGSAVE
127.0.0.1:6379> BGSAVE  
Background saving started
127.0.0.1:6379> BGSAVE
(error) ERR Background save already in progress
```

---

## 8. ⚡ RDB性能优化策略


### 8.1 快照时机优化


**🔸 选择合适的触发时间**
```bash
# 业务低峰期配置
save 3600 1      # 1小时内有1次写入就保存
save 1800 100    # 30分钟内有100次写入就保存
save 300 10000   # 5分钟内有10000次写入就保存

# 高并发场景配置
save 7200 1      # 2小时内有1次写入就保存
save 3600 100    # 1小时内有100次写入就保存
save 1800 10000  # 30分钟内有10000次写入就保存
```

**🔸 手动控制快照时机**
```bash
# 定期手动触发（通过脚本）
#!/bin/bash
# 每天凌晨2点执行备份
# crontab: 0 2 * * * /path/to/backup.sh

redis-cli BGSAVE
if [ $? -eq 0 ]; then
    echo "$(date): 备份启动成功"
else
    echo "$(date): 备份启动失败"
fi
```

### 8.2 内存优化配置


**🔸 减少内存压力**
```bash
# 关闭自动保存（手动控制）
CONFIG SET save ""

# 设置合理的内存上限
CONFIG SET maxmemory 4gb
CONFIG SET maxmemory-policy allkeys-lru

# 优化内存分配器
# 在redis.conf中配置：
# jemalloc: 推荐，内存碎片少
# libc: 默认，内存碎片多
# tcmalloc: Google的分配器
```

### 8.3 快照文件优化


**🔸 文件压缩设置**
```bash
# 启用RDB文件压缩（默认开启）
CONFIG SET rdbcompression yes

# 压缩效果：
# 压缩前：100MB
# 压缩后：通常20-40MB
# 压缩率：60-80%

# 权衡：
# 优势：节省磁盘空间，网络传输快
# 劣势：增加CPU消耗
```

**🔸 校验优化**
```bash
# 禁用校验（提升性能，降低安全性）
CONFIG SET rdbchecksum no

# 校验开销：
# 开启：写入时计算CRC64，加载时验证
# 关闭：跳过校验，提升约10%性能

# 建议：
# 生产环境：保持开启，确保数据完整性
# 测试环境：可以关闭，提升速度
```

---

## 9. 🔧 RDB故障处理


### 9.1 常见问题诊断


**🔸 fork失败问题**
```bash
# 错误信息：
# (error) ERR Background save already in progress
# 原因：已有BGSAVE在执行

# 错误信息：  
# Can't save in background: fork: Cannot allocate memory
# 原因：系统内存不足，无法fork

# 解决方案：
1. 等待当前快照完成
2. 增加系统内存
3. 优化Redis内存使用
4. 调整Linux overcommit设置
```

**🔸 磁盘空间问题**
```bash
# 错误信息：
# Write error saving DB on disk: No space left on device

# 检查磁盘空间
df -h /var/lib/redis

# 解决方案：
1. 清理磁盘空间
2. 移动RDB文件到其他磁盘
3. 配置RDB文件路径：CONFIG SET dir /new/path
```

### 9.2 RDB文件恢复


**🔸 数据恢复流程**
```
步骤1：停止Redis服务
步骤2：将RDB文件放到Redis数据目录
步骤3：确保文件名为dump.rdb
步骤4：启动Redis服务
步骤5：Redis自动加载RDB文件

# 查看数据目录
127.0.0.1:6379> CONFIG GET dir
1) "dir"
2) "/var/lib/redis"

# 查看RDB文件名配置
127.0.0.1:6379> CONFIG GET dbfilename  
1) "dbfilename"
2) "dump.rdb"
```

**🔸 恢复验证**
```bash
# 启动后检查数据
127.0.0.1:6379> DBSIZE
(integer) 1000    # 检查键数量

127.0.0.1:6379> KEYS sample:*
# 检查样本数据是否存在

127.0.0.1:6379> INFO persistence
# 查看加载信息和最后保存时间
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


**🔸 RDB快照本质**
```
内存数据的时间点副本，保存为二进制文件
通过fork子进程实现，不阻塞主进程服务
使用COW机制优化内存使用
提供完整的数据恢复能力
```

**🔸 关键技术机制**
```
fork机制：创建子进程执行快照
COW技术：写时复制，优化内存使用
二进制格式：紧凑的存储格式
原子操作：保证文件完整性
```

### 10.2 重要理解要点


**🔹 为什么需要fork**
```
解决矛盾：快照需要数据一致性 vs 服务需要持续可用
方案：fork创建数据副本，主进程继续服务，子进程生成快照
好处：用户无感知，服务不中断
```

**🔹 COW的核心价值**
```
问题：fork理论上会让内存使用翻倍
解决：COW技术让实际内存增长很少
原理：只复制真正被修改的内存页面
效果：通常只增长20-50%内存
```

**🔹 RDB的适用场景**
```
适合：
✅ 全量备份和灾难恢复
✅ 主从同步的数据传输
✅ 冷备份和长期存档
✅ 快速重启和数据迁移

不适合：
❌ 实时数据备份（可能丢失最近写入）
❌ 高频备份需求（fork开销大）
❌ 内存非常紧张的环境
```

### 10.3 生产环境最佳实践


**🎯 配置建议**
```bash
# 推荐配置
save 3600 1          # 保底备份
save 1800 100        # 中等写入量备份
save 300 10000       # 高写入量备份

rdbcompression yes   # 启用压缩
rdbchecksum yes      # 启用校验
stop-writes-on-bgsave-error yes  # 保存失败时停止写入
```

**🔸 监控要点**
```bash
# 关键监控指标
1. fork耗时：INFO persistence中的latest_fork_usec
2. 内存使用：INFO memory中的used_memory_rss
3. 保存频率：根据业务需要调整save配置
4. 磁盘空间：确保有足够空间存储RDB文件
5. 错误日志：关注Redis日志中的错误信息
```

**⚠️ 注意事项**
```
1. 避免在高峰期执行SAVE命令
2. 确保系统有足够内存支持fork
3. 定期检查RDB文件完整性
4. 备份RDB文件到其他机器
5. 监控快照生成时间和频率
```

### 10.4 常见问题解决


| 问题现象 | **可能原因** | **解决方案** |
|---------|------------|-------------|
| `fork失败` | `内存不足` | `增加内存或优化Redis配置` |
| `快照时间长` | `数据量大或磁盘慢` | `使用SSD或减少数据量` |
| `内存暴增` | `写操作频繁` | `避开高峰期或调整save配置` |
| `文件损坏` | `磁盘故障或强制关机` | `使用备份文件恢复` |
| `加载失败` | `版本不兼容或文件格式错误` | `检查Redis版本和文件完整性` |

**🧠 记忆口诀**:
```
"RDB快照拍照片，fork子进程来执行
COW机制省内存，写时复制是关键
二进制格式很紧凑，校验机制保完整
生产环境要小心，监控优化不能停"
```

**核心记忆**：
- RDB是Redis数据的完整快照，通过fork和COW技术实现高效备份
- 理解fork机制和COW原理是掌握RDB的关键
- 生产环境需要合理配置和持续监控
- RDB适合全量备份，但可能丢失最近的数据修改