---
title: 11、Redis数据库操作命令详解
---
## 📚 目录

1. [Redis数据库基本概念](#1-Redis数据库基本概念)
2. [SELECT切换数据库](#2-SELECT切换数据库)
3. [FLUSHDB清空当前数据库](#3-FLUSHDB清空当前数据库)
4. [FLUSHALL清空所有数据库](#4-FLUSHALL清空所有数据库)
5. [DBSIZE查看键数量](#5-DBSIZE查看键数量)
6. [INFO查看服务器信息](#6-INFO查看服务器信息)
7. [数据库操作最佳实践](#7-数据库操作最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏢 Redis数据库基本概念


### 1.1 什么是Redis数据库


**🔸 通俗理解**
Redis数据库就像一栋**16层的办公楼**，每一层都是一个独立的数据库，可以存放不同的数据。

```
Redis数据库结构：
┌─────────────────┐
│    数据库15      │ ← 最高层
├─────────────────┤
│    数据库14      │
├─────────────────┤
│      ...        │
├─────────────────┤  
│    数据库1       │
├─────────────────┤
│    数据库0       │ ← 默认层（新手常用）
└─────────────────┘
```

**💡 为什么有16个数据库**
```
设计目的：
• 逻辑隔离：不同业务使用不同数据库
• 避免键冲突：相同key在不同库中不冲突
• 便于管理：测试和生产环境分离

实际情况：
• 大多数人只用数据库0（默认）
• 生产环境通常用集群模式（单库）
• 16个数据库是Redis单机版的特色
```

### 1.2 数据库编号与特点


**📊 数据库编号说明**
```
编号范围：0-15（共16个）
默认数据库：0号数据库
配置文件：redis.conf中databases参数控制数量
```

**🔸 数据库特点**
```
独立性：每个数据库的数据完全独立
共享资源：
• 所有数据库共享CPU、内存
• 共享配置参数（密码、超时等）
• 共享持久化设置

注意事项：
• 切换数据库只在当前连接生效
• 不同连接可以同时使用不同数据库
• 集群模式下只有数据库0
```

---

## 2. 🔄 SELECT切换数据库


### 2.1 SELECT命令基本用法


**🔸 命令格式**
```bash
SELECT 数据库编号
```

**💻 基本操作示例**
```bash
# 查看当前在哪个数据库
127.0.0.1:6379> SELECT 0
OK
127.0.0.1:6379[0]>          # [0]表示当前在0号数据库

# 切换到1号数据库
127.0.0.1:6379[0]> SELECT 1
OK
127.0.0.1:6379[1]>          # 提示符变成[1]

# 切换到5号数据库
127.0.0.1:6379[1]> SELECT 5
OK
127.0.0.1:6379[5]>
```

### 2.2 切换数据库的验证


**🔍 验证不同数据库的独立性**
```bash
# 在0号数据库存储数据
127.0.0.1:6379> SELECT 0
OK
127.0.0.1:6379[0]> SET name "张三"
OK
127.0.0.1:6379[0]> GET name
"张三"

# 切换到1号数据库
127.0.0.1:6379[0]> SELECT 1  
OK
127.0.0.1:6379[1]> GET name
(nil)                        # 1号库中没有这个key

# 在1号数据库存储相同key
127.0.0.1:6379[1]> SET name "李四"
OK
127.0.0.1:6379[1]> GET name
"李四"

# 切换回0号数据库验证
127.0.0.1:6379[1]> SELECT 0
OK
127.0.0.1:6379[0]> GET name
"张三"                       # 0号库的数据没有变化
```

### 2.3 SELECT使用场景


**🎯 实际应用场景**

**场景1：环境隔离**
```bash
# 开发环境使用0号库
SELECT 0
SET user:dev:1001 "开发用户数据"

# 测试环境使用1号库  
SELECT 1
SET user:test:1001 "测试用户数据"

# 生产环境使用2号库
SELECT 2
SET user:prod:1001 "生产用户数据"
```

**场景2：业务模块分离**
```bash
# 用户相关数据使用0号库
SELECT 0
SET user:1001 "用户信息"

# 商品相关数据使用1号库
SELECT 1  
SET product:2001 "商品信息"

# 订单相关数据使用2号库
SELECT 2
SET order:3001 "订单信息"
```

> **💡 实践建议**：虽然可以用多个数据库，但现代Redis使用更推荐用**不同的Redis实例**或**集群**来隔离，而不是依赖数据库编号。

---

## 3. 🧹 FLUSHDB清空当前数据库


### 3.1 FLUSHDB命令详解


**🔸 命令作用**
`FLUSHDB`命令会**删除当前数据库中的所有key**，相当于把当前这层楼的所有东西都清空。

```
FLUSHDB执行过程：
当前数据库：[key1, key2, key3, ...]
执行FLUSHDB后：[]                    # 当前库变为空
其他数据库：不受影响
```

**⚠️ 危险性警告**
```
FLUSHDB是危险命令！
• 不可恢复：删除后无法撤销
• 立即生效：没有确认步骤
• 影响范围：当前数据库的所有数据

使用前三思：
1. 确认当前在哪个数据库
2. 确认要删除的是否正确
3. 确认没有重要数据
```

### 3.2 FLUSHDB使用示例


**💻 操作演示**
```bash
# 先查看当前数据库内容
127.0.0.1:6379[0]> KEYS *
1) "user:1001"  
2) "product:2001"
3) "order:3001"

# 查看键的数量
127.0.0.1:6379[0]> DBSIZE
(integer) 3

# 清空当前数据库
127.0.0.1:6379[0]> FLUSHDB
OK

# 验证清空结果
127.0.0.1:6379[0]> KEYS *
(empty list or set)

127.0.0.1:6379[0]> DBSIZE
(integer) 0                  # 键数量变为0
```

**🔍 验证其他数据库不受影响**
```bash
# 切换到1号数据库
127.0.0.1:6379[0]> SELECT 1
OK
127.0.0.1:6379[1]> SET test "1号库的数据"
OK

# 切换回0号数据库并清空
127.0.0.1:6379[1]> SELECT 0  
OK
127.0.0.1:6379[0]> FLUSHDB
OK

# 验证1号数据库数据完好
127.0.0.1:6379[0]> SELECT 1
OK
127.0.0.1:6379[1]> GET test
"1号库的数据"                 # 1号库数据没有被清空
```

### 3.3 FLUSHDB使用场景


**🎯 合适的使用场景**
```
✅ 开发调试：清理测试数据
✅ 数据重置：重新开始某个模块的数据
✅ 缓存清理：清空缓存重新加载
✅ 测试准备：测试前的环境清理
```

**❌ 不合适的场景**
```
❌ 生产环境：绝对不要在生产环境随意使用
❌ 选择性删除：如果只想删除部分数据，用DEL
❌ 数据迁移：不是数据迁移的正确方式
```

---

## 4. 💥 FLUSHALL清空所有数据库


### 4.1 FLUSHALL命令详解


**🔸 命令作用**
`FLUSHALL`命令会**删除Redis实例中所有数据库的所有key**，相当于把整栋楼都清空。

```
FLUSHALL执行过程：
数据库0：[key1, key2] → []
数据库1：[key3, key4] → []  
数据库2：[key5, key6] → []
...
所有数据库都被清空！
```

**⚠️ 极度危险警告**
```
FLUSHALL是最危险的命令！
• 影响所有库：16个数据库全部清空
• 不可恢复：没有任何方法可以撤销
• 立即执行：没有二次确认

生产环境禁用建议：
• 通过配置文件禁用此命令
• 设置命令重命名
• 使用ACL权限控制
```

### 4.2 FLUSHALL使用示例


**💻 操作演示**
```bash
# 准备测试数据（在不同数据库）
127.0.0.1:6379> SELECT 0
OK
127.0.0.1:6379[0]> SET db0_key "数据库0的数据"
OK

127.0.0.1:6379[0]> SELECT 1
OK  
127.0.0.1:6379[1]> SET db1_key "数据库1的数据"
OK

127.0.0.1:6379[1]> SELECT 2
OK
127.0.0.1:6379[2]> SET db2_key "数据库2的数据"
OK

# 切换回0号库执行FLUSHALL
127.0.0.1:6379[2]> SELECT 0
OK
127.0.0.1:6379[0]> FLUSHALL
OK

# 验证所有数据库都被清空
127.0.0.1:6379[0]> KEYS *
(empty list or set)

127.0.0.1:6379[0]> SELECT 1
OK
127.0.0.1:6379[1]> KEYS *
(empty list or set)               # 1号库也被清空

127.0.0.1:6379[1]> SELECT 2  
OK
127.0.0.1:6379[2]> KEYS *
(empty list or set)               # 2号库也被清空
```

### 4.3 生产环境保护措施


**🛡️ 安全配置**
```bash
# redis.conf配置文件中禁用危险命令
rename-command FLUSHALL ""
rename-command FLUSHDB ""

# 或者重命名为复杂的名字
rename-command FLUSHALL "DANGEROUS_FLUSH_ALL_NEVER_USE"
```

---

## 5. 📊 DBSIZE查看键数量


### 5.1 DBSIZE命令详解


**🔸 命令作用**
`DBSIZE`命令返回**当前数据库中key的总数量**，就像数一数当前楼层有多少个房间。

```
DBSIZE特点：
• 只统计当前数据库
• 返回精确数量
• 执行速度很快（O(1)时间复杂度）
• 不会阻塞其他操作
```

### 5.2 DBSIZE使用示例


**💻 基本使用**
```bash
# 查看当前数据库键数量
127.0.0.1:6379[0]> DBSIZE
(integer) 0                  # 当前库为空

# 添加一些数据
127.0.0.1:6379[0]> SET user:1001 "张三"
OK
127.0.0.1:6379[0]> SET user:1002 "李四"
OK
127.0.0.1:6379[0]> LPUSH tasks "任务1" "任务2"
(integer) 2

# 再次查看数量
127.0.0.1:6379[0]> DBSIZE
(integer) 3                  # 3个key: user:1001, user:1002, tasks
```

**🔍 不同数据库的独立统计**
```bash
# 在0号库创建数据
127.0.0.1:6379[0]> SET key1 "value1"
127.0.0.1:6379[0]> SET key2 "value2"
127.0.0.1:6379[0]> DBSIZE
(integer) 2

# 切换到1号库
127.0.0.1:6379[0]> SELECT 1
OK
127.0.0.1:6379[1]> DBSIZE
(integer) 0                  # 1号库为空

# 在1号库创建数据
127.0.0.1:6379[1]> SET key3 "value3"
OK
127.0.0.1:6379[1]> DBSIZE  
(integer) 1                  # 1号库只有1个key
```

### 5.3 DBSIZE使用场景


**🎯 实际应用场景**

**场景1：数据量监控**
```bash
# 监控缓存数据增长情况
while true; do
    echo "当前缓存数量: $(redis-cli DBSIZE)"
    sleep 60  # 每分钟检查一次
done
```

**场景2：容量规划**
```bash
# 评估不同环境的数据规模
SELECT 0  # 生产环境
DBSIZE    # 返回：500000

SELECT 1  # 测试环境
DBSIZE    # 返回：1000

# 帮助判断是否需要扩容或优化
```

**场景3：数据清理验证**
```bash
# 清理前检查
DBSIZE                       # 返回：10000

# 执行清理操作
FLUSHDB

# 清理后确认
DBSIZE                       # 返回：0，确认清理成功
```

---

## 6. 📋 INFO查看服务器信息


### 6.1 INFO命令详解


**🔸 命令作用**
`INFO`命令是Redis的**体检报告**，提供服务器运行状态、内存使用、性能指标等详细信息。

```
INFO命令格式：
INFO                        # 显示所有信息
INFO section               # 显示指定部分信息

常用section：
• server：服务器基本信息
• memory：内存使用情况
• stats：统计信息  
• replication：主从复制信息
• cpu：CPU使用情况
```

### 6.2 INFO核心信息解读


**🖥️ 服务器基本信息**
```bash
127.0.0.1:6379> INFO server
# Server
redis_version:7.0.12        # Redis版本
os:Linux 5.4.0 x86_64      # 操作系统
process_id:1234             # 进程ID
uptime_in_seconds:86400     # 运行时间（秒）
uptime_in_days:1            # 运行时间（天）
```

**💾 内存使用情况**
```bash
127.0.0.1:6379> INFO memory
# Memory
used_memory:1048576         # 已使用内存（字节）
used_memory_human:1.00M     # 已使用内存（人类可读）
used_memory_peak:2097152    # 内存使用峰值
maxmemory:0                 # 最大内存限制（0表示无限制）
```

**📊 性能统计信息**
```bash
127.0.0.1:6379> INFO stats  
# Stats
total_connections_received:100   # 总连接数
total_commands_processed:5000    # 总命令数
instantaneous_ops_per_sec:50     # 当前每秒操作数
keyspace_hits:4500              # 命中次数
keyspace_misses:500             # 未命中次数
```

### 6.3 INFO信息的实际应用


**🎯 运维监控应用**

**监控1：内存使用率**
```bash
# 检查内存使用情况
INFO memory | grep used_memory_human
# 输出：used_memory_human:256.00M

# 如果内存使用过高，需要：
# 1. 检查是否有内存泄漏
# 2. 清理无用数据
# 3. 调整maxmemory策略
```

**监控2：缓存命中率**
```bash
# 计算缓存命中率
INFO stats | grep keyspace
keyspace_hits:9000
keyspace_misses:1000

# 命中率 = 9000/(9000+1000) = 90%
# 命中率低说明缓存策略需要优化
```

**监控3：连接数监控**
```bash
# 查看连接情况
INFO clients
connected_clients:50        # 当前连接数
client_recent_max_input_buffer:2
client_recent_max_output_buffer:0

# 连接数过多可能需要：
# 1. 检查连接池配置
# 2. 排查连接泄漏
# 3. 调整maxclients参数
```

### 6.4 INFO命令使用技巧


**🔧 实用技巧**

**技巧1：过滤特定信息**
```bash
# 只查看内存相关信息
INFO memory

# 只查看统计信息
INFO stats

# 使用grep过滤（在Linux环境）
redis-cli INFO memory | grep used_memory_human
```

**技巧2：监控脚本应用**
```bash
#!/bin/bash
# Redis监控脚本示例

# 获取内存使用
memory_usage=$(redis-cli INFO memory | grep used_memory_human | cut -d: -f2)
echo "内存使用: $memory_usage"

# 获取当前QPS
qps=$(redis-cli INFO stats | grep instantaneous_ops_per_sec | cut -d: -f2)  
echo "当前QPS: $qps"

# 获取连接数
connections=$(redis-cli INFO clients | grep connected_clients | cut -d: -f2)
echo "连接数: $connections"
```

---

## 7. 🎛️ 数据库操作最佳实践


### 7.1 数据库使用原则


**📋 使用建议**

```
✅ 推荐做法：
• 开发环境：使用不同数据库做简单隔离
• 小型项目：可以用数据库编号区分模块
• 学习测试：利用数据库隔离做实验

❌ 不推荐做法：
• 生产环境依赖数据库编号做业务隔离
• 大型项目用数据库编号替代集群
• 把数据库编号当作分库分表方案
```

### 7.2 操作安全规范


**🛡️ 安全操作流程**

**执行危险命令前的检查清单**
```
☐ 确认当前数据库编号（SELECT）
☐ 确认数据库中的key数量（DBSIZE）
☐ 确认要操作的环境（开发/测试/生产）
☐ 备份重要数据（如果有必要）
☐ 确认操作影响范围（FLUSHDB vs FLUSHALL）
```

**操作示例流程**
```bash
# 1. 确认当前位置
127.0.0.1:6379> SELECT 1
OK
127.0.0.1:6379[1]>          # 确认在1号库

# 2. 查看当前数据
127.0.0.1:6379[1]> DBSIZE
(integer) 500               # 有500个key

127.0.0.1:6379[1]> KEYS test:*
1) "test:user:001"          # 确认是测试数据
2) "test:user:002"

# 3. 执行清空操作
127.0.0.1:6379[1]> FLUSHDB
OK

# 4. 确认操作结果
127.0.0.1:6379[1]> DBSIZE
(integer) 0                 # 确认清空成功
```

### 7.3 生产环境配置建议


**🔧 安全配置**
```bash
# redis.conf安全配置
# 1. 禁用危险命令
rename-command FLUSHDB ""
rename-command FLUSHALL ""

# 2. 或者重命名为复杂名称
rename-command FLUSHDB "FLUSH_DB_DANGER_COMMAND_2024"
rename-command FLUSHALL "FLUSH_ALL_SUPER_DANGER_2024"

# 3. 设置密码保护
requirepass your_strong_password

# 4. 限制连接来源
bind 127.0.0.1 192.168.1.100
```

---

## 8. 📈 数据库操作监控与管理


### 8.1 数据库状态监控


**📊 关键监控指标**

**内存监控脚本**
```bash
#!/bin/bash
# 检查各个数据库的使用情况

for db in {0..15}; do
    size=$(redis-cli -n $db DBSIZE)
    if [ $size -gt 0 ]; then
        echo "数据库 $db: $size 个key"
    fi
done
```

**💾 各库数据分布查看**
```bash
# 查看keyspace信息
127.0.0.1:6379> INFO keyspace
# Keyspace  
db0:keys=1000,expires=100,avg_ttl=3600000
db1:keys=500,expires=50,avg_ttl=7200000
db2:keys=200,expires=0,avg_ttl=0

解读：
• db0有1000个key，100个有过期时间，平均TTL是1小时
• db1有500个key，50个有过期时间，平均TTL是2小时  
• db2有200个key，都没有过期时间
```

### 8.2 数据库维护操作


**🧹 定期维护任务**

**清理过期数据**
```bash
# 手动触发过期key清理
DEBUG SLEEP 0.1             # 让Redis有时间清理过期key

# 查看过期key清理统计
INFO stats | grep expired
expired_keys:1500           # 已清理的过期key数量
```

**空间优化**
```bash
# 查看内存碎片率
INFO memory | grep mem_fragmentation_ratio
mem_fragmentation_ratio:1.5

# 如果碎片率高于1.5，考虑：
# 1. 重启Redis实例
# 2. 启用内存碎片整理
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 数据库概念：Redis有16个独立的数据库（0-15）
🔸 SELECT命令：切换数据库，影响当前连接
🔸 FLUSHDB命令：清空当前数据库，危险操作
🔸 FLUSHALL命令：清空所有数据库，极度危险
🔸 DBSIZE命令：统计当前数据库key数量
🔸 INFO命令：查看Redis运行状态和性能指标
```

### 9.2 关键理解要点


**🔹 数据库隔离的理解**
```
物理隔离：不同数据库的数据完全独立
逻辑隔离：共享Redis实例的资源和配置
连接隔离：每个连接可以选择不同数据库

类比理解：
Redis实例 = 一栋楼
数据库 = 楼层
连接 = 访客（可以去任意楼层）
```

**🔹 命令的影响范围**
```
SELECT：只影响当前连接
FLUSHDB：只影响当前数据库
FLUSHALL：影响所有数据库
DBSIZE：只统计当前数据库
INFO：显示整个Redis实例信息
```

### 9.3 实际应用指导


**🎯 新手使用建议**
```
学习阶段：
1. 主要使用0号数据库
2. 用1号数据库做实验测试
3. 用2号数据库学习不同场景

开发阶段：
• 开发环境：数据库0
• 测试环境：数据库1  
• 预发环境：数据库2

注意事项：
• 生产环境建议使用集群而不是数据库编号
• 定期监控各数据库的使用情况
• 设置危险命令的安全策略
```

**⚠️ 常见误区**
```
❌ 以为数据库编号可以替代集群分片
❌ 在生产环境随意使用FLUSH命令
❌ 不知道SELECT只影响当前连接
❌ 用KEYS命令统计key数量（应该用DBSIZE）

✅ 正确理解：
• 数据库编号主要用于逻辑隔离
• 危险命令需要谨慎操作
• 每个连接需要单独SELECT
• DBSIZE比KEYS更高效
```

### 9.4 运维实践要点


**🔧 日常管理命令**
```bash
# 每日检查脚本
echo "Redis运行状态检查："
echo "服务器信息："
redis-cli INFO server | grep redis_version

echo "内存使用："
redis-cli INFO memory | grep used_memory_human

echo "各数据库使用情况："
redis-cli INFO keyspace
```

**核心记忆**：
- 16个数据库像楼层，SELECT切换当前层
- DBSIZE数房间，INFO看整体状况  
- FLUSH要谨慎，清空不可逆
- 监控要及时，安全第一位