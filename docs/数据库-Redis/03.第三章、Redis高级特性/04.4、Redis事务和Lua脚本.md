---
title: 4ã€Redisäº‹åŠ¡å’ŒLuaè„šæœ¬
---
## ğŸ“š ç›®å½•

1. [äº‹åŠ¡åŸºç¡€æ¦‚å¿µ](#1-äº‹åŠ¡åŸºç¡€æ¦‚å¿µ)
2. [äº‹åŠ¡æ ¸å¿ƒå‘½ä»¤](#2-äº‹åŠ¡æ ¸å¿ƒå‘½ä»¤)
3. [äº‹åŠ¡ACIDç‰¹æ€§åˆ†æ](#3-äº‹åŠ¡ACIDç‰¹æ€§åˆ†æ)
4. [é”™è¯¯å¤„ç†æœºåˆ¶](#4-é”™è¯¯å¤„ç†æœºåˆ¶)
5. [WATCHä¹è§‚é”æœºåˆ¶](#5-WATCHä¹è§‚é”æœºåˆ¶)
6. [Luaè„šæœ¬åŸå­æ“ä½œ](#6-Luaè„šæœ¬åŸå­æ“ä½œ)
7. [å®æˆ˜åº”ç”¨æ¡ˆä¾‹](#7-å®æˆ˜åº”ç”¨æ¡ˆä¾‹)
8. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#8-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ” äº‹åŠ¡åŸºç¡€æ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯Redisäº‹åŠ¡


**é€šä¿—ç†è§£**ï¼šRedisäº‹åŠ¡å°±åƒé“¶è¡Œè½¬è´¦ï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä¸ä¼šå‡ºç°é’±ä»Aè´¦æˆ·æ‰£äº†ä½†Bè´¦æˆ·æ²¡æ”¶åˆ°çš„æƒ…å†µã€‚

**åŸºæœ¬åŸç†**ï¼š
- æŠŠå¤šä¸ªRediså‘½ä»¤æ‰“åŒ…æˆä¸€ä¸ªæ•´ä½“
- è¿™äº›å‘½ä»¤è¦ä¹ˆå…¨éƒ¨æ‰§è¡Œï¼Œè¦ä¹ˆå…¨éƒ¨ä¸æ‰§è¡Œ
- æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šè¢«å…¶ä»–å®¢æˆ·ç«¯çš„å‘½ä»¤æ‰“æ–­

```
æ™®é€šæ‰§è¡Œï¼š
å‘½ä»¤1 â†’ æ‰§è¡Œ â†’ ç»“æœ1
å‘½ä»¤2 â†’ æ‰§è¡Œ â†’ ç»“æœ2  (å¯èƒ½è¢«å…¶ä»–å®¢æˆ·ç«¯æ‰“æ–­)
å‘½ä»¤3 â†’ æ‰§è¡Œ â†’ ç»“æœ3

äº‹åŠ¡æ‰§è¡Œï¼š
[å‘½ä»¤1, å‘½ä»¤2, å‘½ä»¤3] â†’ ä¸€èµ·æ‰§è¡Œ â†’ [ç»“æœ1, ç»“æœ2, ç»“æœ3]
```

### 1.2 äº‹åŠ¡çš„æ ¸å¿ƒç‰¹ç‚¹


**åŸå­æ€§**ï¼šè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥
**éš”ç¦»æ€§**ï¼šäº‹åŠ¡æ‰§è¡Œæ—¶ä¸ä¼šè¢«å…¶ä»–å‘½ä»¤æ‰“æ–­
**ä¸€è‡´æ€§**ï¼šäº‹åŠ¡å‰åæ•°æ®çŠ¶æ€ä¿æŒä¸€è‡´
**æ— å›æ»š**ï¼šRedisäº‹åŠ¡ä¸æ”¯æŒä¼ ç»Ÿæ•°æ®åº“çš„å›æ»šæœºåˆ¶

### 1.3 Redisäº‹åŠ¡ vs æ•°æ®åº“äº‹åŠ¡


| ç‰¹æ€§ | **Redisäº‹åŠ¡** | **æ•°æ®åº“äº‹åŠ¡** |
|------|-------------|--------------|
| **å›æ»šæ”¯æŒ** | âŒ ä¸æ”¯æŒè‡ªåŠ¨å›æ»š | âœ… æ”¯æŒROLLBACK |
| **éš”ç¦»çº§åˆ«** | åªæ”¯æŒä¸²è¡ŒåŒ– | æ”¯æŒå¤šç§éš”ç¦»çº§åˆ« |
| **å¤æ‚åº¦** | ç®€å•ï¼Œé€‚åˆåŸºæœ¬åœºæ™¯ | å¤æ‚ï¼ŒåŠŸèƒ½å®Œå–„ |
| **æ€§èƒ½** | é«˜æ€§èƒ½ | ç›¸å¯¹è¾ƒæ…¢ |

---

## 2. âš™ï¸ äº‹åŠ¡æ ¸å¿ƒå‘½ä»¤


### 2.1 MULTI - å¼€å§‹äº‹åŠ¡


**ä½œç”¨**ï¼šæ ‡è®°äº‹åŠ¡çš„å¼€å§‹ï¼Œåç»­å‘½ä»¤ä¼šè¿›å…¥é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œã€‚

```bash
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key1 "value1"
QUEUED
127.0.0.1:6379> SET key2 "value2"  
QUEUED
127.0.0.1:6379> INCR counter
QUEUED
```

**ç†è§£è¦ç‚¹**ï¼š
- MULTIåçš„å‘½ä»¤ä¸ä¼šç«‹å³æ‰§è¡Œ
- å‘½ä»¤ä¼šæ”¾å…¥é˜Ÿåˆ—ï¼Œæ˜¾ç¤º"QUEUED"
- æ­¤æ—¶åªæ˜¯åœ¨å‡†å¤‡ï¼Œè¿˜æ²¡æœ‰çœŸæ­£æ‰§è¡Œ

### 2.2 EXEC - æ‰§è¡Œäº‹åŠ¡


**ä½œç”¨**ï¼šæ‰§è¡Œé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰å‘½ä»¤ï¼Œè¿”å›æ‰€æœ‰å‘½ä»¤çš„ç»“æœã€‚

```bash
127.0.0.1:6379> EXEC
1) OK        # SET key1 çš„ç»“æœ
2) OK        # SET key2 çš„ç»“æœ  
3) (integer) 1  # INCR counter çš„ç»“æœ
```

**æ‰§è¡Œè¿‡ç¨‹**ï¼š
```
äº‹åŠ¡é˜Ÿåˆ—ï¼š[SET key1 value1, SET key2 value2, INCR counter]
         â†“ EXECè§¦å‘
ä¸€æ¬¡æ€§æ‰§è¡Œï¼šå…¨éƒ¨å‘½ä»¤æŒ‰é¡ºåºæ‰§è¡Œ
         â†“
è¿”å›ç»“æœï¼š[OK, OK, 1]
```

### 2.3 DISCARD - å–æ¶ˆäº‹åŠ¡


**ä½œç”¨**ï¼šæ¸…ç©ºäº‹åŠ¡é˜Ÿåˆ—ï¼Œå–æ¶ˆäº‹åŠ¡ã€‚

```bash
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key1 "value1"
QUEUED
127.0.0.1:6379> DISCARD
OK
127.0.0.1:6379> GET key1
(nil)  # key1æ²¡æœ‰è¢«è®¾ç½®ï¼Œå› ä¸ºäº‹åŠ¡è¢«å–æ¶ˆäº†
```

**ä½¿ç”¨åœºæ™¯**ï¼š
- å‘ç°å‘½ä»¤æœ‰è¯¯ï¼Œéœ€è¦é‡æ–°å¼€å§‹
- ä¸šåŠ¡é€»è¾‘åˆ¤æ–­éœ€è¦å–æ¶ˆæ“ä½œ
- å¼‚å¸¸æƒ…å†µä¸‹çš„æ¸…ç†å·¥ä½œ

### 2.4 å®Œæ•´äº‹åŠ¡ç¤ºä¾‹


```python
import redis

r = redis.Redis(host='localhost', port=6379, db=0)

def transfer_money(from_account, to_account, amount):
    """è½¬è´¦æ“ä½œç¤ºä¾‹"""
    pipe = r.pipeline()  # åˆ›å»ºç®¡é“
    
    try:
        # å¼€å§‹äº‹åŠ¡
        pipe.multi()
        
        # æ·»åŠ å‘½ä»¤åˆ°é˜Ÿåˆ—
        pipe.decrby(f"account:{from_account}", amount)  # æ‰£æ¬¾
        pipe.incrby(f"account:{to_account}", amount)    # æ”¶æ¬¾
        pipe.lpush("transfer_log", f"{from_account}->{to_account}:{amount}")  # è®°å½•æ—¥å¿—
        
        # æ‰§è¡Œäº‹åŠ¡
        results = pipe.execute()
        print(f"è½¬è´¦æˆåŠŸ: {results}")
        return True
        
    except Exception as e:
        # å‡ºé”™æ—¶å–æ¶ˆäº‹åŠ¡
        pipe.discard()
        print(f"è½¬è´¦å¤±è´¥: {e}")
        return False

# ä½¿ç”¨ç¤ºä¾‹
transfer_money("user001", "user002", 100)
```

---

## 3. ğŸ” äº‹åŠ¡ACIDç‰¹æ€§åˆ†æ


### 3.1 åŸå­æ€§ (Atomicity)


**Redisäº‹åŠ¡çš„åŸå­æ€§ç‰¹ç‚¹**ï¼š
- âœ… **æ‰§è¡ŒåŸå­æ€§**ï¼šæ‰€æœ‰å‘½ä»¤ä¸€æ¬¡æ€§æ‰§è¡Œå®Œæˆ
- âŒ **å¤±è´¥å›æ»š**ï¼šä¸æ”¯æŒéƒ¨åˆ†å¤±è´¥åçš„è‡ªåŠ¨å›æ»š

```bash
# åŸå­æ€§ç¤ºä¾‹
MULTI
DECRBY account:A 100
INCRBY account:B 100
EXEC

# ç»“æœï¼šè¦ä¹ˆAæ‰£æ¬¾Bæ”¶æ¬¾éƒ½æˆåŠŸï¼Œè¦ä¹ˆéƒ½ä¸æ‰§è¡Œ
# ä¸ä¼šå‡ºç°Aæ‰£äº†é’±Bæ²¡æ”¶åˆ°çš„æƒ…å†µ
```

**æ³¨æ„äº‹é¡¹**ï¼š
```python
# Redisäº‹åŠ¡åŸå­æ€§çš„é™åˆ¶
def understand_atomicity():
    """ç†è§£Redisäº‹åŠ¡åŸå­æ€§"""
    
    # åœºæ™¯1ï¼šè¯­æ³•é”™è¯¯ - æ•´ä¸ªäº‹åŠ¡ä¸æ‰§è¡Œ
    pipe = r.pipeline()
    pipe.multi()
    pipe.set("key1", "value1")
    pipe.invalid_command()  # è¯­æ³•é”™è¯¯
    pipe.set("key2", "value2")
    
    try:
        pipe.execute()  # æ•´ä¸ªäº‹åŠ¡å¤±è´¥ï¼Œkey1å’Œkey2éƒ½ä¸ä¼šè¢«è®¾ç½®
    except:
        print("è¯­æ³•é”™è¯¯å¯¼è‡´æ•´ä¸ªäº‹åŠ¡å¤±è´¥")
    
    # åœºæ™¯2ï¼šè¿è¡Œæ—¶é”™è¯¯ - å…¶ä»–å‘½ä»¤ç»§ç»­æ‰§è¡Œ
    pipe = r.pipeline()
    pipe.multi()
    pipe.set("key1", "value1")      # æˆåŠŸ
    pipe.incr("string_key")         # è¿è¡Œæ—¶é”™è¯¯(å¯¹å­—ç¬¦ä¸²æ‰§è¡Œæ•°å­—æ“ä½œ)
    pipe.set("key2", "value2")      # æˆåŠŸ
    
    results = pipe.execute()
    # ç»“æœï¼škey1å’Œkey2ä¼šè¢«è®¾ç½®ï¼Œåªæœ‰incrå‘½ä»¤å¤±è´¥
    print("è¿è¡Œæ—¶é”™è¯¯ä¸å½±å“å…¶ä»–å‘½ä»¤æ‰§è¡Œ")
```

### 3.2 éš”ç¦»æ€§ (Isolation)


**Redisäº‹åŠ¡éš”ç¦»ç‰¹ç‚¹**ï¼š
- äº‹åŠ¡æ‰§è¡ŒæœŸé—´ï¼Œå…¶ä»–å®¢æˆ·ç«¯çš„å‘½ä»¤æ— æ³•æ’å…¥
- ç›¸å½“äºæ•°æ®åº“çš„"ä¸²è¡ŒåŒ–"éš”ç¦»çº§åˆ«
- ä½†WATCHå‘½ä»¤æä¾›äº†ä¹è§‚é”æœºåˆ¶

```
æ—¶é—´çº¿ç¤ºä¾‹ï¼š
å®¢æˆ·ç«¯A                    å®¢æˆ·ç«¯B
MULTI                     
SET key1 value1  (é˜Ÿåˆ—)    GET key1  (ç­‰å¾…)
SET key2 value2  (é˜Ÿåˆ—)    SET key1 other (ç­‰å¾…)
EXEC  (å¼€å§‹æ‰§è¡Œ)          
  æ‰§è¡ŒSET key1 value1      
  æ‰§è¡ŒSET key2 value2      (å®¢æˆ·ç«¯Bä»åœ¨ç­‰å¾…)
  äº‹åŠ¡å®Œæˆ                GET key1  (ç°åœ¨æ‰æ‰§è¡Œ)
```

### 3.3 ä¸€è‡´æ€§ (Consistency)


**ä¸€è‡´æ€§ä¿è¯æœºåˆ¶**ï¼š
- å‘½ä»¤æ‰§è¡Œå‰åï¼Œæ•°æ®ä¿æŒé€»è¾‘ä¸€è‡´
- ä½†éœ€è¦ç¨‹åºå‘˜ç¡®ä¿ä¸šåŠ¡é€»è¾‘æ­£ç¡®

```python
def consistency_example():
    """ä¸€è‡´æ€§ç¤ºä¾‹ï¼šåº“å­˜æ‰£å‡"""
    
    def deduct_inventory(product_id, quantity):
        current_stock = int(r.get(f"stock:{product_id}") or 0)
        
        # æ£€æŸ¥åº“å­˜æ˜¯å¦è¶³å¤Ÿ
        if current_stock < quantity:
            return False, "åº“å­˜ä¸è¶³"
        
        # ä½¿ç”¨äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
        pipe = r.pipeline()
        pipe.multi()
        pipe.decrby(f"stock:{product_id}", quantity)      # æ‰£å‡åº“å­˜
        pipe.incrby(f"sold:{product_id}", quantity)       # å¢åŠ é”€é‡
        pipe.lpush(f"orders", f"{product_id}:{quantity}") # è®°å½•è®¢å•
        
        try:
            pipe.execute()
            return True, "æ‰£å‡æˆåŠŸ"
        except:
            return False, "æ‰£å‡å¤±è´¥"
    
    # ä½¿ç”¨ç¤ºä¾‹
    success, message = deduct_inventory("product001", 5)
    print(f"ç»“æœ: {message}")
```

### 3.4 æŒä¹…æ€§ (Durability)


**æŒä¹…æ€§ä¾èµ–äºRedisé…ç½®**ï¼š
- äº‹åŠ¡æˆåŠŸ â‰  æ•°æ®å·²æŒä¹…åŒ–
- å–å†³äºRedisçš„æŒä¹…åŒ–ç­–ç•¥ (RDB/AOF)

```bash
# æŒä¹…åŒ–ç›¸å…³é…ç½®
# redis.conf

# RDBé…ç½®
save 900 1      # 900ç§’å†…è‡³å°‘1æ¬¡ä¿®æ”¹æ‰ä¿å­˜
save 300 10     # 300ç§’å†…è‡³å°‘10æ¬¡ä¿®æ”¹æ‰ä¿å­˜
save 60 10000   # 60ç§’å†…è‡³å°‘10000æ¬¡ä¿®æ”¹æ‰ä¿å­˜

# AOFé…ç½®  
appendonly yes
appendfsync everysec  # æ¯ç§’åŒæ­¥ä¸€æ¬¡
```

---

## 4. âš ï¸ é”™è¯¯å¤„ç†æœºåˆ¶


### 4.1 è¯­æ³•é”™è¯¯å¤„ç†


**ç‰¹ç‚¹**ï¼šå‘½ä»¤å…¥é˜Ÿæ—¶å°±èƒ½å‘ç°çš„é”™è¯¯ï¼Œä¼šå¯¼è‡´æ•´ä¸ªäº‹åŠ¡å¤±è´¥ã€‚

```bash
# è¯­æ³•é”™è¯¯ç¤ºä¾‹
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key1 value1
QUEUED
127.0.0.1:6379> INVALID_COMMAND  # ä¸å­˜åœ¨çš„å‘½ä»¤
(error) ERR unknown command 'INVALID_COMMAND'
127.0.0.1:6379> SET key2 value2
QUEUED
127.0.0.1:6379> EXEC
(error) EXECABORT Transaction discarded because of previous errors.

# ç»“æœï¼škey1å’Œkey2éƒ½æ²¡æœ‰è¢«è®¾ç½®
127.0.0.1:6379> GET key1
(nil)
127.0.0.1:6379> GET key2  
(nil)
```

**ä»£ç å¤„ç†**ï¼š
```python
def handle_syntax_error():
    """å¤„ç†è¯­æ³•é”™è¯¯"""
    pipe = r.pipeline()
    
    try:
        pipe.multi()
        pipe.set("key1", "value1")
        # æ•…æ„åˆ¶é€ è¯­æ³•é”™è¯¯
        pipe.execute_command("INVALID_CMD")  
        pipe.set("key2", "value2")
        
        results = pipe.execute()
        
    except redis.ResponseError as e:
        if "EXECABORT" in str(e):
            print("äº‹åŠ¡è¢«ç»ˆæ­¢ï¼šå­˜åœ¨è¯­æ³•é”™è¯¯")
            # æ‰€æœ‰å‘½ä»¤éƒ½æ²¡æœ‰æ‰§è¡Œ
        else:
            print(f"å…¶ä»–é”™è¯¯: {e}")
```

### 4.2 è¿è¡Œæ—¶é”™è¯¯å¤„ç†


**ç‰¹ç‚¹**ï¼šå‘½ä»¤è¯­æ³•æ­£ç¡®ï¼Œä½†æ‰§è¡Œæ—¶å‡ºé”™ï¼Œä¸å½±å“å…¶ä»–å‘½ä»¤ã€‚

```bash
# è¿è¡Œæ—¶é”™è¯¯ç¤ºä¾‹
127.0.0.1:6379> SET string_key "hello"
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key1 value1
QUEUED
127.0.0.1:6379> INCR string_key  # å¯¹å­—ç¬¦ä¸²æ‰§è¡Œæ•°å­—æ“ä½œ
QUEUED
127.0.0.1:6379> SET key2 value2
QUEUED
127.0.0.1:6379> EXEC
1) OK                             # SET key1æˆåŠŸ
2) (error) ERR value is not an integer  # INCRå¤±è´¥
3) OK                             # SET key2æˆåŠŸ

# ç»“æœï¼škey1å’Œkey2è¢«è®¾ç½®æˆåŠŸ
127.0.0.1:6379> GET key1
"value1"
127.0.0.1:6379> GET key2
"value2"
```

**ä»£ç å¤„ç†**ï¼š
```python
def handle_runtime_error():
    """å¤„ç†è¿è¡Œæ—¶é”™è¯¯"""
    
    # å…ˆè®¾ç½®ä¸€ä¸ªå­—ç¬¦ä¸²å€¼
    r.set("string_key", "hello")
    
    pipe = r.pipeline()
    pipe.multi()
    pipe.set("key1", "value1")
    pipe.incr("string_key")  # è¿è¡Œæ—¶é”™è¯¯
    pipe.set("key2", "value2")
    
    results = pipe.execute()
    
    # æ£€æŸ¥æ¯ä¸ªå‘½ä»¤çš„ç»“æœ
    for i, result in enumerate(results):
        if isinstance(result, redis.ResponseError):
            print(f"å‘½ä»¤{i+1}æ‰§è¡Œå¤±è´¥: {result}")
        else:
            print(f"å‘½ä»¤{i+1}æ‰§è¡ŒæˆåŠŸ: {result}")
    
    # éªŒè¯ç»“æœ
    print(f"key1: {r.get('key1')}")  # åº”è¯¥æœ‰å€¼
    print(f"key2: {r.get('key2')}")  # åº”è¯¥æœ‰å€¼
```

### 4.3 äº‹åŠ¡å¤±è´¥å¤„ç†ç­–ç•¥


```python
def robust_transaction(operations):
    """å¥å£®çš„äº‹åŠ¡å¤„ç†"""
    max_retries = 3
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            pipe = r.pipeline()
            pipe.multi()
            
            # æ·»åŠ æ‰€æœ‰æ“ä½œ
            for operation in operations:
                getattr(pipe, operation['command'])(*operation['args'])
            
            # æ‰§è¡Œäº‹åŠ¡
            results = pipe.execute()
            
            # æ£€æŸ¥æ˜¯å¦æœ‰è¿è¡Œæ—¶é”™è¯¯
            has_error = any(isinstance(result, redis.ResponseError) for result in results)
            
            if has_error:
                print("äº‹åŠ¡ä¸­å­˜åœ¨è¿è¡Œæ—¶é”™è¯¯")
                # æ ¹æ®ä¸šåŠ¡éœ€æ±‚å†³å®šæ˜¯å¦é‡è¯•
                return False, results
            else:
                print("äº‹åŠ¡æ‰§è¡ŒæˆåŠŸ")
                return True, results
                
        except redis.ResponseError as e:
            if "EXECABORT" in str(e):
                print("è¯­æ³•é”™è¯¯ï¼Œæ— æ³•é‡è¯•")
                return False, None
            else:
                retry_count += 1
                print(f"ç¬¬{retry_count}æ¬¡é‡è¯•...")
                
        except Exception as e:
            retry_count += 1
            print(f"æœªçŸ¥é”™è¯¯ï¼Œç¬¬{retry_count}æ¬¡é‡è¯•: {e}")
    
    print("é‡è¯•æ¬¡æ•°è€—å°½ï¼Œäº‹åŠ¡å¤±è´¥")
    return False, None

# ä½¿ç”¨ç¤ºä¾‹
operations = [
    {'command': 'set', 'args': ['key1', 'value1']},
    {'command': 'incr', 'args': ['counter']},
    {'command': 'lpush', 'args': ['list1', 'item1']}
]

success, results = robust_transaction(operations)
```

---

## 5. ğŸ‘ï¸ WATCHä¹è§‚é”æœºåˆ¶


### 5.1 ä»€ä¹ˆæ˜¯WATCH


**é€šä¿—ç†è§£**ï¼šWATCHå°±åƒç»™æŸä¸ªkeyè£…äº†ä¸ª"ç›‘æ§å™¨"ï¼Œå¦‚æœè¿™ä¸ªkeyè¢«åˆ«äººæ”¹äº†ï¼Œæˆ‘çš„äº‹åŠ¡å°±è‡ªåŠ¨å–æ¶ˆã€‚

**ä½¿ç”¨åœºæ™¯**ï¼šé˜²æ­¢åœ¨äº‹åŠ¡æ‰§è¡Œå‰ï¼Œå…³é”®æ•°æ®è¢«å…¶ä»–å®¢æˆ·ç«¯ä¿®æ”¹ã€‚

```
åœºæ™¯ï¼šä¸¤ä¸ªç”¨æˆ·åŒæ—¶è´­ä¹°åº“å­˜ä¸º1çš„å•†å“

ç”¨æˆ·A                        ç”¨æˆ·B
GET stock:item1  (è¿”å›1)     GET stock:item1  (è¿”å›1)  
åˆ¤æ–­åº“å­˜è¶³å¤Ÿ                 åˆ¤æ–­åº“å­˜è¶³å¤Ÿ
MULTI                       MULTI
DECRBY stock:item1 1        DECRBY stock:item1 1
EXEC                        EXEC

ç»“æœï¼šåº“å­˜å˜æˆ-1 (è¶…å–äº†!)
```

### 5.2 WATCHå‘½ä»¤ä½¿ç”¨


**åŸºæœ¬è¯­æ³•**ï¼š
```bash
WATCH key1 [key2 ...]
```

**å·¥ä½œæµç¨‹**ï¼š
1. WATCHç›‘æ§key
2. å¼€å§‹äº‹åŠ¡ (MULTI)
3. æ‰§è¡Œå‘½ä»¤
4. æ‰§è¡Œäº‹åŠ¡ (EXEC)
5. å¦‚æœè¢«ç›‘æ§çš„keyåœ¨æ­¤æœŸé—´è¢«ä¿®æ”¹ï¼ŒEXECè¿”å›null

```bash
# å®¢æˆ·ç«¯A
127.0.0.1:6379> SET balance:user1 100
OK
127.0.0.1:6379> WATCH balance:user1
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> DECRBY balance:user1 50
QUEUED

# æ­¤æ—¶å®¢æˆ·ç«¯Bä¿®æ”¹äº†balance:user1
# å®¢æˆ·ç«¯B: SET balance:user1 200

127.0.0.1:6379> EXEC
(nil)  # è¿”å›nilï¼Œè¡¨ç¤ºäº‹åŠ¡è¢«å–æ¶ˆ

127.0.0.1:6379> GET balance:user1
"200"  # å€¼æ˜¯å®¢æˆ·ç«¯Bè®¾ç½®çš„ï¼Œäº‹åŠ¡æ²¡æœ‰æ‰§è¡Œ
```

### 5.3 ä¹è§‚é”å®ç°ç¤ºä¾‹


```python
def optimistic_lock_transfer(from_user, to_user, amount, max_retries=5):
    """ä½¿ç”¨ä¹è§‚é”å®ç°è½¬è´¦"""
    
    for attempt in range(max_retries):
        try:
            # ç›‘æ§ç›¸å…³çš„key
            with r.pipeline() as pipe:
                pipe.watch(f"balance:{from_user}", f"balance:{to_user}")
                
                # è·å–å½“å‰ä½™é¢
                from_balance = float(pipe.get(f"balance:{from_user}") or 0)
                to_balance = float(pipe.get(f"balance:{to_user}") or 0)
                
                # æ£€æŸ¥ä½™é¢æ˜¯å¦å……è¶³
                if from_balance < amount:
                    pipe.unwatch()  # å–æ¶ˆç›‘æ§
                    return False, "ä½™é¢ä¸è¶³"
                
                # å¼€å§‹äº‹åŠ¡
                pipe.multi()
                pipe.decrby(f"balance:{from_user}", amount)
                pipe.incrby(f"balance:{to_user}", amount)
                pipe.lpush("transfer_history", 
                          f"{from_user}->{to_user}:{amount}:{datetime.now()}")
                
                # æ‰§è¡Œäº‹åŠ¡
                results = pipe.execute()
                
                if results is None:
                    # äº‹åŠ¡è¢«å–æ¶ˆï¼Œé‡è¯•
                    print(f"ç¬¬{attempt + 1}æ¬¡å°è¯•å¤±è´¥ï¼Œæ•°æ®è¢«ä¿®æ”¹ï¼Œé‡è¯•ä¸­...")
                    continue
                else:
                    print(f"è½¬è´¦æˆåŠŸ: {from_user} -> {to_user}, é‡‘é¢: {amount}")
                    return True, "è½¬è´¦æˆåŠŸ"
                    
        except Exception as e:
            print(f"è½¬è´¦è¿‡ç¨‹å‡ºé”™: {e}")
            return False, str(e)
    
    return False, f"é‡è¯•{max_retries}æ¬¡åä»å¤±è´¥"

# ä½¿ç”¨ç¤ºä¾‹
success, message = optimistic_lock_transfer("user001", "user002", 50)
print(message)
```

### 5.4 UNWATCHå‘½ä»¤


**ä½œç”¨**ï¼šå–æ¶ˆå¯¹æ‰€æœ‰keyçš„ç›‘æ§ã€‚

```python
def conditional_operation():
    """æ¡ä»¶æ€§æ“ä½œç¤ºä¾‹"""
    
    with r.pipeline() as pipe:
        pipe.watch("config:maintenance")
        
        # æ£€æŸ¥æ˜¯å¦åœ¨ç»´æŠ¤æ¨¡å¼
        maintenance_mode = pipe.get("config:maintenance")
        
        if maintenance_mode == b'true':
            # ç»´æŠ¤æ¨¡å¼ä¸‹ï¼Œå–æ¶ˆç›‘æ§å¹¶é€€å‡º
            pipe.unwatch()
            return False, "ç³»ç»Ÿç»´æŠ¤ä¸­"
        
        # æ­£å¸¸æ¨¡å¼ä¸‹ç»§ç»­æ‰§è¡Œäº‹åŠ¡
        pipe.multi()
        pipe.incr("visit_count")
        pipe.lpush("access_log", f"user_visit:{datetime.now()}")
        
        results = pipe.execute()
        
        if results:
            return True, "æ“ä½œæˆåŠŸ"
        else:
            return False, "é…ç½®è¢«ä¿®æ”¹ï¼Œæ“ä½œå–æ¶ˆ"
```

---

## 6. ğŸ“œ Luaè„šæœ¬åŸå­æ“ä½œ


### 6.1 ä¸ºä»€ä¹ˆéœ€è¦Luaè„šæœ¬


**é—®é¢˜**ï¼šRedisäº‹åŠ¡è™½ç„¶ä¿è¯åŸå­æ€§ï¼Œä½†ä¸æ”¯æŒæ¡ä»¶åˆ¤æ–­å’Œå¤æ‚é€»è¾‘ã€‚

```bash
# äº‹åŠ¡çš„å±€é™æ€§ï¼šæ— æ³•åœ¨äº‹åŠ¡ä¸­è¿›è¡Œæ¡ä»¶åˆ¤æ–­
MULTI
GET counter
# è¿™é‡Œæ— æ³•åˆ¤æ–­counterçš„å€¼å†å†³å®šåç»­æ“ä½œ
INCR counter  
EXEC
```

**Luaè„šæœ¬çš„ä¼˜åŠ¿**ï¼š
- **åŸå­æ€§æ‰§è¡Œ**ï¼šæ•´ä¸ªè„šæœ¬ä½œä¸ºä¸€ä¸ªåŸå­æ“ä½œ
- **å‡å°‘ç½‘ç»œå¾€è¿”**ï¼šä¸€æ¬¡è°ƒç”¨å®Œæˆå¤æ‚æ“ä½œ
- **æ”¯æŒæ¡ä»¶é€»è¾‘**ï¼šå¯ä»¥ä½¿ç”¨if/elseç­‰æ§åˆ¶ç»“æ„
- **æ€§èƒ½æ›´å¥½**ï¼šè„šæœ¬åœ¨RedisæœåŠ¡å™¨ç«¯æ‰§è¡Œ

### 6.2 åŸºæœ¬Luaè„šæœ¬ç¤ºä¾‹


**ç®€å•ç¤ºä¾‹**ï¼š
```lua
-- å®‰å…¨çš„è®¡æ•°å™¨å¢åŠ è„šæœ¬
local key = KEYS[1]
local increment = tonumber(ARGV[1])
local max_value = tonumber(ARGV[2])

local current = redis.call('GET', key)
if current == false then
    current = 0
else  
    current = tonumber(current)
end

if current + increment <= max_value then
    return redis.call('INCRBY', key, increment)
else
    return -1  -- è¶…è¿‡æœ€å¤§å€¼ï¼Œæ‹’ç»æ“ä½œ
end
```

**Pythonè°ƒç”¨**ï¼š
```python
# æ³¨å†Œè„šæœ¬
safe_incr_script = """
local key = KEYS[1]
local increment = tonumber(ARGV[1])
local max_value = tonumber(ARGV[2])

local current = redis.call('GET', key)
if current == false then
    current = 0
else  
    current = tonumber(current)
end

if current + increment <= max_value then
    return redis.call('INCRBY', key, increment)
else
    return -1
end
"""

# æ‰§è¡Œè„šæœ¬
def safe_increment(key, increment, max_value):
    result = r.eval(safe_incr_script, 1, key, increment, max_value)
    
    if result == -1:
        return False, "è¶…è¿‡æœ€å¤§å€¼é™åˆ¶"
    else:
        return True, f"å½“å‰å€¼: {result}"

# ä½¿ç”¨ç¤ºä¾‹
success, message = safe_increment("counter", 5, 100)
print(message)
```

### 6.3 å¸¸ç”¨è„šæœ¬æ¨¡å¼


**åº“å­˜æ‰£å‡è„šæœ¬**ï¼š
```lua
-- åŸå­æ€§åº“å­˜æ‰£å‡
local stock_key = KEYS[1]
local sold_key = KEYS[2]
local quantity = tonumber(ARGV[1])

local current_stock = redis.call('GET', stock_key)
if current_stock == false then
    return {-1, "å•†å“ä¸å­˜åœ¨"}
end

current_stock = tonumber(current_stock)
if current_stock < quantity then
    return {-2, "åº“å­˜ä¸è¶³"}
end

redis.call('DECRBY', stock_key, quantity)
redis.call('INCRBY', sold_key, quantity)

return {current_stock - quantity, "æ‰£å‡æˆåŠŸ"}
```

**é™æµè„šæœ¬**ï¼š
```lua
-- æ»‘åŠ¨çª—å£é™æµ
local key = KEYS[1]
local window = tonumber(ARGV[1])  -- æ—¶é—´çª—å£(ç§’)
local limit = tonumber(ARGV[2])   -- é™åˆ¶æ¬¡æ•°
local current_time = tonumber(ARGV[3])

-- æ¸…ç†è¿‡æœŸæ•°æ®
redis.call('ZREMRANGEBYSCORE', key, 0, current_time - window)

-- æ£€æŸ¥å½“å‰è®¡æ•°
local current_count = redis.call('ZCARD', key)
if current_count < limit then
    -- æ·»åŠ å½“å‰è¯·æ±‚
    redis.call('ZADD', key, current_time, current_time)
    redis.call('EXPIRE', key, window)
    return 1  -- å…è®¸é€šè¿‡
else
    return 0  -- é™æµ
end
```

### 6.4 è„šæœ¬ç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ–


```python
class RedisLuaScript:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.scripts = {}
    
    def load_script(self, name, script_content):
        """åŠ è½½å¹¶ç¼“å­˜è„šæœ¬"""
        sha = self.redis.script_load(script_content)
        self.scripts[name] = sha
        return sha
    
    def execute_script(self, script_name, keys=None, args=None):
        """æ‰§è¡Œç¼“å­˜çš„è„šæœ¬"""
        if script_name not in self.scripts:
            raise ValueError(f"è„šæœ¬ {script_name} æœªåŠ è½½")
        
        sha = self.scripts[script_name]
        
        try:
            return self.redis.evalsha(sha, len(keys or []), *(keys or []), *(args or []))
        except redis.exceptions.NoScriptError:
            # è„šæœ¬ä¸å­˜åœ¨ï¼Œé‡æ–°åŠ è½½
            print(f"è„šæœ¬ {script_name} ä¸å­˜åœ¨ï¼Œé‡æ–°åŠ è½½...")
            return None

# ä½¿ç”¨ç¤ºä¾‹
script_manager = RedisLuaScript(r)

# åº“å­˜æ‰£å‡è„šæœ¬
inventory_script = """
local stock_key = KEYS[1]
local sold_key = KEYS[2] 
local quantity = tonumber(ARGV[1])

local current_stock = redis.call('GET', stock_key)
if current_stock == false then
    return {-1, "å•†å“ä¸å­˜åœ¨"}
end

current_stock = tonumber(current_stock)
if current_stock < quantity then
    return {-2, "åº“å­˜ä¸è¶³"}  
end

redis.call('DECRBY', stock_key, quantity)
redis.call('INCRBY', sold_key, quantity)
return {current_stock - quantity, "æ‰£å‡æˆåŠŸ"}
"""

# åŠ è½½è„šæœ¬
script_manager.load_script("deduct_inventory", inventory_script)

# ä½¿ç”¨è„šæœ¬
result = script_manager.execute_script(
    "deduct_inventory", 
    keys=["stock:product001", "sold:product001"],
    args=[5]
)
print(result)
```

---

## 7. ğŸ¯ å®æˆ˜åº”ç”¨æ¡ˆä¾‹


### 7.1 è´¦æˆ·è½¬è´¦ç³»ç»Ÿ


```python
class AccountTransferSystem:
    def __init__(self, redis_client):
        self.redis = redis_client
        
        # è½¬è´¦è„šæœ¬
        self.transfer_script = """
        local from_account = KEYS[1]
        local to_account = KEYS[2]
        local amount = tonumber(ARGV[1])
        local transfer_id = ARGV[2]
        
        -- æ£€æŸ¥è½¬å‡ºè´¦æˆ·ä½™é¢
        local from_balance = redis.call('GET', from_account)
        if from_balance == false then
            return {-1, "è½¬å‡ºè´¦æˆ·ä¸å­˜åœ¨"}
        end
        
        from_balance = tonumber(from_balance)
        if from_balance < amount then
            return {-2, "ä½™é¢ä¸è¶³"}
        end
        
        -- æ£€æŸ¥è½¬å…¥è´¦æˆ·æ˜¯å¦å­˜åœ¨
        local to_balance = redis.call('GET', to_account)
        if to_balance == false then
            return {-3, "è½¬å…¥è´¦æˆ·ä¸å­˜åœ¨"}
        end
        
        -- æ‰§è¡Œè½¬è´¦
        local new_from_balance = redis.call('DECRBY', from_account, amount)
        local new_to_balance = redis.call('INCRBY', to_account, amount)
        
        -- è®°å½•è½¬è´¦æ—¥å¿—
        local log_data = from_account .. ":" .. to_account .. ":" .. amount .. ":" .. transfer_id
        redis.call('LPUSH', 'transfer_logs', log_data)
        redis.call('LTRIM', 'transfer_logs', 0, 9999)  -- ä¿ç•™æœ€æ–°10000æ¡
        
        return {new_from_balance, new_to_balance, "è½¬è´¦æˆåŠŸ"}
        """
        
        self.script_sha = self.redis.script_load(self.transfer_script)
    
    def transfer(self, from_account_id, to_account_id, amount):
        """æ‰§è¡Œè½¬è´¦"""
        transfer_id = str(uuid.uuid4())
        
        try:
            result = self.redis.evalsha(
                self.script_sha, 2,
                f"account:{from_account_id}",
                f"account:{to_account_id}",
                amount, transfer_id
            )
            
            if isinstance(result, list) and len(result) >= 3:
                if isinstance(result[0], int) and result[0] >= 0:
                    return {
                        'success': True,
                        'transfer_id': transfer_id,
                        'from_balance': result[0],
                        'to_balance': result[1],
                        'message': result[2]
                    }
                else:
                    error_messages = {
                        -1: "è½¬å‡ºè´¦æˆ·ä¸å­˜åœ¨",
                        -2: "ä½™é¢ä¸è¶³", 
                        -3: "è½¬å…¥è´¦æˆ·ä¸å­˜åœ¨"
                    }
                    return {
                        'success': False,
                        'error': error_messages.get(result[0], "æœªçŸ¥é”™è¯¯")
                    }
            
        except Exception as e:
            return {
                'success': False,
                'error': f"è½¬è´¦æ‰§è¡Œå¤±è´¥: {str(e)}"
            }
    
    def get_balance(self, account_id):
        """è·å–è´¦æˆ·ä½™é¢"""
        balance = self.redis.get(f"account:{account_id}")
        return float(balance) if balance else 0.0
    
    def create_account(self, account_id, initial_balance=0):
        """åˆ›å»ºè´¦æˆ·"""
        return self.redis.set(f"account:{account_id}", initial_balance, nx=True)

# ä½¿ç”¨ç¤ºä¾‹
transfer_system = AccountTransferSystem(r)

# åˆ›å»ºæµ‹è¯•è´¦æˆ·
transfer_system.create_account("user001", 1000)
transfer_system.create_account("user002", 500)

# æ‰§è¡Œè½¬è´¦
result = transfer_system.transfer("user001", "user002", 200)
print(result)
```

### 7.2 ç§’æ€ç³»ç»Ÿå®ç°


```python
class SeckillSystem:
    def __init__(self, redis_client):
        self.redis = redis_client
        
        # ç§’æ€è„šæœ¬
        self.seckill_script = """
        local product_key = KEYS[1]
        local user_key = KEYS[2]
        local order_key = KEYS[3]
        local user_id = ARGV[1]
        local quantity = tonumber(ARGV[2])
        
        -- æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç»å‚ä¸è¿‡ç§’æ€
        local user_participated = redis.call('SISMEMBER', user_key, user_id)
        if user_participated == 1 then
            return {-1, "ç”¨æˆ·å·²å‚ä¸è¿‡ç§’æ€"}
        end
        
        -- æ£€æŸ¥åº“å­˜
        local stock = redis.call('GET', product_key)
        if stock == false or tonumber(stock) < quantity then
            return {-2, "åº“å­˜ä¸è¶³"}
        end
        
        -- æ‰£å‡åº“å­˜
        local remaining_stock = redis.call('DECRBY', product_key, quantity)
        
        -- è®°å½•ç”¨æˆ·å‚ä¸
        redis.call('SADD', user_key, user_id)
        
        -- åˆ›å»ºè®¢å•
        local order_data = user_id .. ":" .. quantity .. ":" .. os.time()
        redis.call('LPUSH', order_key, order_data)
        
        return {remaining_stock, "ç§’æ€æˆåŠŸ"}
        """
        
        self.script_sha = self.redis.script_load(self.seckill_script)
    
    def init_seckill(self, product_id, total_stock):
        """åˆå§‹åŒ–ç§’æ€æ´»åŠ¨"""
        self.redis.set(f"seckill:stock:{product_id}", total_stock)
        self.redis.delete(f"seckill:users:{product_id}")
        self.redis.delete(f"seckill:orders:{product_id}")
        
        print(f"ç§’æ€æ´»åŠ¨åˆå§‹åŒ–å®Œæˆï¼Œå•†å“{product_id}ï¼Œåº“å­˜{total_stock}")
    
    def participate_seckill(self, product_id, user_id, quantity=1):
        """å‚ä¸ç§’æ€"""
        try:
            result = self.redis.evalsha(
                self.script_sha, 3,
                f"seckill:stock:{product_id}",
                f"seckill:users:{product_id}",
                f"seckill:orders:{product_id}",
                user_id, quantity
            )
            
            if isinstance(result, list) and len(result) >= 2:
                if isinstance(result[0], int) and result[0] >= 0:
                    return {
                        'success': True,
                        'remaining_stock': result[0],
                        'message': result[1]
                    }
                else:
                    error_messages = {
                        -1: "ç”¨æˆ·å·²å‚ä¸è¿‡ç§’æ€",
                        -2: "åº“å­˜ä¸è¶³"
                    }
                    return {
                        'success': False,
                        'error': error_messages.get(result[0], "ç§’æ€å¤±è´¥")
                    }
            
        except Exception as e:
            return {
                'success': False,
                'error': f"ç§’æ€æ‰§è¡Œå¤±è´¥: {str(e)}"
            }
    
    def get_seckill_status(self, product_id):
        """è·å–ç§’æ€çŠ¶æ€"""
        stock = self.redis.get(f"seckill:stock:{product_id}")
        user_count = self.redis.scard(f"seckill:users:{product_id}")
        order_count = self.redis.llen(f"seckill:orders:{product_id}")
        
        return {
            'remaining_stock': int(stock) if stock else 0,
            'participated_users': user_count,
            'total_orders': order_count
        }

# ä½¿ç”¨ç¤ºä¾‹
seckill = SeckillSystem(r)

# åˆå§‹åŒ–ç§’æ€(å•†å“ID: phone001, åº“å­˜: 100)
seckill.init_seckill("phone001", 100)

# æ¨¡æ‹Ÿç”¨æˆ·å‚ä¸ç§’æ€
result = seckill.participate_seckill("phone001", "user123")
print(result)

# æŸ¥çœ‹ç§’æ€çŠ¶æ€
status = seckill.get_seckill_status("phone001")
print(status)
```

### 7.3 è®¢å•æ“ä½œäº‹åŠ¡å®ç°


```python
class OrderSystem:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    def create_order_with_inventory(self, user_id, product_id, quantity, price):
        """åˆ›å»ºè®¢å•å¹¶æ‰£å‡åº“å­˜çš„äº‹åŠ¡æ“ä½œ"""
        
        order_id = f"order_{uuid.uuid4().hex[:8]}"
        max_retries = 3
        
        for attempt in range(max_retries):
            try:
                with self.redis.pipeline() as pipe:
                    # ç›‘æ§åº“å­˜key
                    pipe.watch(f"inventory:{product_id}")
                    
                    # è·å–å½“å‰åº“å­˜
                    current_inventory = pipe.get(f"inventory:{product_id}")
                    if not current_inventory:
                        pipe.unwatch()
                        return {'success': False, 'error': 'å•†å“ä¸å­˜åœ¨'}
                    
                    current_inventory = int(current_inventory)
                    if current_inventory < quantity:
                        pipe.unwatch()
                        return {'success': False, 'error': 'åº“å­˜ä¸è¶³'}
                    
                    # å¼€å§‹äº‹åŠ¡
                    pipe.multi()
                    
                    # æ‰£å‡åº“å­˜
                    pipe.decrby(f"inventory:{product_id}", quantity)
                    
                    # åˆ›å»ºè®¢å•
                    order_data = {
                        'order_id': order_id,
                        'user_id': user_id,
                        'product_id': product_id,
                        'quantity': quantity,
                        'price': price,
                        'total': quantity * price,
                        'status': 'pending',
                        'created_at': datetime.now().isoformat()
                    }
                    
                    pipe.hset(f"order:{order_id}", mapping=order_data)
                    
                    # æ·»åŠ åˆ°ç”¨æˆ·è®¢å•åˆ—è¡¨
                    pipe.lpush(f"user_orders:{user_id}", order_id)
                    
                    # æ·»åŠ åˆ°å¾…å¤„ç†è®¢å•é˜Ÿåˆ—
                    pipe.lpush("pending_orders", order_id)
                    
                    # æ›´æ–°é”€é‡ç»Ÿè®¡
                    pipe.incrby(f"sales:{product_id}", quantity)
                    
                    # æ‰§è¡Œäº‹åŠ¡
                    results = pipe.execute()
                    
                    if results is None:
                        print(f"ç¬¬{attempt + 1}æ¬¡å°è¯•å¤±è´¥ï¼Œåº“å­˜è¢«ä¿®æ”¹ï¼Œé‡è¯•ä¸­...")
                        continue
                    
                    return {
                        'success': True,
                        'order_id': order_id,
                        'remaining_inventory': results[0],
                        'message': 'è®¢å•åˆ›å»ºæˆåŠŸ'
                    }
                    
            except Exception as e:
                print(f"è®¢å•åˆ›å»ºå¤±è´¥: {e}")
                if attempt == max_retries - 1:
                    return {'success': False, 'error': str(e)}
        
        return {'success': False, 'error': f'é‡è¯•{max_retries}æ¬¡åä»å¤±è´¥'}
    
    def cancel_order(self, order_id):
        """å–æ¶ˆè®¢å•å¹¶æ¢å¤åº“å­˜"""
        
        try:
            with self.redis.pipeline() as pipe:
                # è·å–è®¢å•ä¿¡æ¯
                order_info = pipe.hgetall(f"order:{order_id}")
                
                if not order_info:
                    return {'success': False, 'error': 'è®¢å•ä¸å­˜åœ¨'}
                
                order_status = order_info.get(b'status', b'').decode('utf-8')
                if order_status != 'pending':
                    return {'success': False, 'error': f'è®¢å•çŠ¶æ€ä¸º{order_status}ï¼Œæ— æ³•å–æ¶ˆ'}
                
                product_id = order_info[b'product_id'].decode('utf-8')
                quantity = int(order_info[b'quantity'])
                
                # ç›‘æ§è®¢å•çŠ¶æ€
                pipe.watch(f"order:{order_id}")
                
                pipe.multi()
                
                # æ›´æ–°è®¢å•çŠ¶æ€
                pipe.hset(f"order:{order_id}", 'status', 'cancelled')
                pipe.hset(f"order:{order_id}", 'cancelled_at', datetime.now().isoformat())
                
                # æ¢å¤åº“å­˜
                pipe.incrby(f"inventory:{product_id}", quantity)
                
                # å‡å°‘é”€é‡ç»Ÿè®¡
                pipe.decrby(f"sales:{product_id}", quantity)
                
                # ä»å¾…å¤„ç†é˜Ÿåˆ—ç§»é™¤
                pipe.lrem("pending_orders", 1, order_id)
                
                results = pipe.execute()
                
                if results is None:
                    return {'success': False, 'error': 'è®¢å•çŠ¶æ€å·²å˜æ›´'}
                
                return {'success': True, 'message': 'è®¢å•å–æ¶ˆæˆåŠŸ'}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

# ä½¿ç”¨ç¤ºä¾‹
order_system = OrderSystem(r)

# è®¾ç½®å•†å“åº“å­˜
r.set("inventory:product001", 50)

# åˆ›å»ºè®¢å•
result = order_system.create_order_with_inventory(
    user_id="user123",
    product_id="product001", 
    quantity=2,
    price=99.99
)
print(result)

# å–æ¶ˆè®¢å•
if result['success']:
    cancel_result = order_system.cancel_order(result['order_id'])
    print(cancel_result)
```

---

## 8. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 8.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ


```
ğŸ”¸ äº‹åŠ¡åŸºæœ¬å‘½ä»¤ï¼šMULTIå¼€å§‹ã€EXECæ‰§è¡Œã€DISCARDå–æ¶ˆã€WATCHç›‘æ§
ğŸ”¸ åŸå­æ€§ç‰¹ç‚¹ï¼šè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä½†ä¸æ”¯æŒè‡ªåŠ¨å›æ»š
ğŸ”¸ é”™è¯¯å¤„ç†ï¼šè¯­æ³•é”™è¯¯å¯¼è‡´æ•´ä¸ªäº‹åŠ¡å¤±è´¥ï¼Œè¿è¡Œæ—¶é”™è¯¯ä¸å½±å“å…¶ä»–å‘½ä»¤
ğŸ”¸ ä¹è§‚é”æœºåˆ¶ï¼šWATCHç›‘æ§keyå˜åŒ–ï¼Œå˜åŒ–æ—¶äº‹åŠ¡è‡ªåŠ¨å–æ¶ˆ
ğŸ”¸ Luaè„šæœ¬ä¼˜åŠ¿ï¼šåŸå­æ€§æ‰§è¡Œå¤æ‚é€»è¾‘ï¼Œå‡å°‘ç½‘ç»œå¾€è¿”
```

### 8.2 å…³é”®ç†è§£è¦ç‚¹


**Redisäº‹åŠ¡ vs æ•°æ®åº“äº‹åŠ¡**ï¼š
```
ç›¸åŒç‚¹ï¼š
- éƒ½ä¿è¯åŸå­æ€§æ‰§è¡Œ
- éƒ½æ”¯æŒä¸€è‡´æ€§ä¿è¯
- éƒ½æœ‰éš”ç¦»æ€§ç‰¹ç‚¹

ä¸åŒç‚¹ï¼š
- Redisä¸æ”¯æŒå›æ»šï¼Œæ•°æ®åº“æ”¯æŒROLLBACK
- Redisåªæœ‰ä¸²è¡ŒåŒ–éš”ç¦»çº§åˆ«
- Redisäº‹åŠ¡æ›´ç®€å•ï¼Œæ€§èƒ½æ›´é«˜
```

**ä½•æ—¶ä½¿ç”¨äº‹åŠ¡ vs Luaè„šæœ¬**ï¼š
```
ä½¿ç”¨äº‹åŠ¡çš„åœºæ™¯ï¼š
- ç®€å•çš„æ‰¹é‡æ“ä½œ
- ä¸éœ€è¦æ¡ä»¶åˆ¤æ–­çš„æ“ä½œ
- éœ€è¦WATCHä¹è§‚é”çš„åœºæ™¯

ä½¿ç”¨Luaè„šæœ¬çš„åœºæ™¯ï¼š
- éœ€è¦æ¡ä»¶åˆ¤æ–­å’Œå¤æ‚é€»è¾‘
- è¦æ±‚æ›´å¥½çš„æ€§èƒ½
- å¤æ‚çš„åŸå­æ“ä½œ
```

**WATCHçš„é€‚ç”¨åœºæ™¯**ï¼š
```
é€‚åˆï¼š
- è¯»-ä¿®æ”¹-å†™æ“ä½œ
- å¹¶å‘ä¸å¤ªæ¿€çƒˆçš„åœºæ™¯
- å¯ä»¥æ¥å—é‡è¯•çš„ä¸šåŠ¡

ä¸é€‚åˆï¼š
- é«˜å¹¶å‘ä¿®æ”¹åŒä¸€key
- ä¸èƒ½æ¥å—é‡è¯•çš„ä¸šåŠ¡
- å¤æ‚çš„æ¡ä»¶æ£€æŸ¥
```

### 8.3 å®é™…åº”ç”¨æŒ‡å¯¼


**ä¸šåŠ¡åœºæ™¯é€‰æ‹©**ï¼š
- **è´¦æˆ·è½¬è´¦**ï¼šä½¿ç”¨Luaè„šæœ¬ï¼Œé¿å…ä½™é¢æ£€æŸ¥çš„ç«æ€æ¡ä»¶
- **åº“å­˜æ‰£å‡**ï¼šä½¿ç”¨Luaè„šæœ¬ï¼ŒåŸå­æ€§æ£€æŸ¥åº“å­˜å¹¶æ‰£å‡
- **æ‰¹é‡æ›´æ–°**ï¼šä½¿ç”¨äº‹åŠ¡ï¼Œç®€å•é«˜æ•ˆ
- **æ¡ä»¶æ›´æ–°**ï¼šä½¿ç”¨WATCH+äº‹åŠ¡ï¼Œå®ç°ä¹è§‚é”

**æ€§èƒ½ä¼˜åŒ–å»ºè®®**ï¼š
- äº‹åŠ¡ä¸­çš„å‘½ä»¤æ•°é‡ä¸å®œè¿‡å¤š
- Luaè„šæœ¬è¦å°½é‡ç®€çŸ­é«˜æ•ˆ
- åˆç†ä½¿ç”¨è„šæœ¬ç¼“å­˜(EVALSHA)
- é¿å…åœ¨è„šæœ¬ä¸­ä½¿ç”¨éšæœºå‘½ä»¤

**é”™è¯¯å¤„ç†ç­–ç•¥**ï¼š
- è¯­æ³•é”™è¯¯ï¼šæ£€æŸ¥å‘½ä»¤æ­£ç¡®æ€§ï¼Œä½¿ç”¨try-catch
- è¿è¡Œæ—¶é”™è¯¯ï¼šæ£€æŸ¥æ¯ä¸ªå‘½ä»¤ç»“æœï¼Œå†³å®šæ˜¯å¦é‡è¯•
- WATCHå¤±è´¥ï¼šå®ç°é‡è¯•æœºåˆ¶ï¼Œè®¾ç½®æœ€å¤§é‡è¯•æ¬¡æ•°
- è„šæœ¬é”™è¯¯ï¼šè¯¦ç»†çš„é”™è¯¯æ—¥å¿—ï¼Œä¾¿äºè°ƒè¯•

### 8.4 å¸¸è§é—®é¢˜ä¸è§£å†³


| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| **äº‹åŠ¡æ‰§è¡Œè¿”å›nil** | WATCHçš„keyè¢«ä¿®æ”¹ | å®ç°é‡è¯•æœºåˆ¶ |
| **éƒ¨åˆ†å‘½ä»¤å¤±è´¥** | è¿è¡Œæ—¶é”™è¯¯ | æ£€æŸ¥æ¯ä¸ªç»“æœï¼Œå¤„ç†å¼‚å¸¸ |
| **æ€§èƒ½é—®é¢˜** | äº‹åŠ¡è¿‡é•¿æˆ–è„šæœ¬å¤æ‚ | æ‹†åˆ†æ“ä½œï¼Œä¼˜åŒ–è„šæœ¬ |
| **æ•°æ®ä¸ä¸€è‡´** | ç¼ºä¹é€‚å½“çš„é”æœºåˆ¶ | ä½¿ç”¨WATCHæˆ–Luaè„šæœ¬ |

**æ ¸å¿ƒè®°å¿†è¦ç‚¹**ï¼š
- äº‹åŠ¡ä¿è¯åŸå­æ‰§è¡Œä½†ä¸è‡ªåŠ¨å›æ»š
- WATCHå®ç°ä¹è§‚é”é˜²æ­¢å¹¶å‘ä¿®æ”¹
- Luaè„šæœ¬é€‚åˆå¤æ‚é€»è¾‘çš„åŸå­æ“ä½œ
- é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶å¾ˆé‡è¦