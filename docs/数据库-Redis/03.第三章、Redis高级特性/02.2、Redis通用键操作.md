---
title: 2、Redis通用键操作
---
## 📚 目录

1. [通用键操作概述](#1-通用键操作概述)
2. [过期时间管理](#2-过期时间管理)
3. [键查找操作](#3-键查找操作)
4. [键信息获取](#4-键信息获取)
5. [键重命名操作](#5-键重命名操作)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔑 通用键操作概述


### 1.1 什么是通用键操作


**简单理解**：无论你的数据是字符串、列表、哈希还是其他类型，这些命令都能用来管理键本身的属性。

```
把Redis想象成一个大仓库：
┌─────────────────────────────────┐
│  Redis 仓库                     │
├─────────────┬───────────────────┤
│ 货架标签    │ 货物内容          │
├─────────────┼───────────────────┤
│ user:1001   │ {"name": "张三"}  │ ← 哈希类型
│ task_queue  │ [task1, task2]    │ ← 列表类型
│ counter     │ 100               │ ← 字符串类型
└─────────────┴───────────────────┘

通用键操作就是管理"货架标签"的：
- 设置标签的有效期（EXPIRE）
- 查看标签还能用多久（TTL）
- 搜索特定的标签（KEYS/SCAN）
- 给标签改名（RENAME）
- 查看这个标签对应什么类型的货物（TYPE）
```

### 1.2 通用键操作的重要性


**🔸 生命周期管理**：自动清理过期数据，防止内存泄漏
**🔸 数据查找**：快速定位需要的键
**🔸 类型识别**：了解键存储的数据类型
**🔸 键管理**：重命名、检查存在性等维护操作

---

## 2. ⏰ 过期时间管理


### 2.1 EXPIRE - 设置键过期时间


**基本用法**：
```bash
# 语法：EXPIRE key seconds
127.0.0.1:6379> SET session:user123 "login_data"
127.0.0.1:6379> EXPIRE session:user123 3600
(integer) 1    # 返回1表示设置成功

# 设置失败的情况
127.0.0.1:6379> EXPIRE nonexist 100
(integer) 0    # 返回0表示键不存在
```

**过期时间理解**：
```
现在时间：14:00:00
执行：EXPIRE session:user123 3600  (3600秒 = 1小时)
过期时间：15:00:00

过期后：键会被自动删除
14:59:59 → 键还存在
15:00:00 → 键被删除，GET返回nil
```

**相关过期命令**：
```bash
# EXPIREAT - 设置具体的过期时间戳
127.0.0.1:6379> EXPIREAT mykey 1677654321
(integer) 1

# PEXPIRE - 设置毫秒级过期时间  
127.0.0.1:6379> PEXPIRE mykey 5000    # 5秒后过期
(integer) 1

# PERSIST - 移除过期时间（变为永久）
127.0.0.1:6379> PERSIST mykey
(integer) 1
```

### 2.2 TTL - 查看剩余过期时间


```bash
# TTL返回秒数，PTTL返回毫秒数
127.0.0.1:6379> TTL session:user123
(integer) 3456    # 还有3456秒过期

# 特殊返回值的含义
127.0.0.1:6379> TTL permanent_key
(integer) -1      # -1表示永久键（无过期时间）

127.0.0.1:6379> TTL nonexist_key  
(integer) -2      # -2表示键不存在
```

**TTL状态图解**：
```
键的生命周期状态：

创建键：SET mykey "value"
       TTL mykey → -1 (永久键)

设置过期：EXPIRE mykey 100  
       TTL mykey → 99, 98, 97... (倒计时)

键过期：TTL mykey → -2 (键已被删除)

移除过期：PERSIST mykey
       TTL mykey → -1 (重新变为永久键)
```

### 2.3 过期机制原理


**Redis过期删除策略**：
```
1. 惰性删除（Lazy Expiration）：
   - 访问键时检查是否过期
   - 过期则立即删除
   - 节省CPU，但可能占用内存

2. 定期删除（Active Expiration）：  
   - 后台定时扫描过期键
   - 随机抽样检查并删除
   - 平衡CPU和内存使用

实际运行：两种策略结合使用
```

---

## 3. 🔍 键查找操作


### 3.1 KEYS - 模式匹配查找


**基本用法**：
```bash
# 查看所有键
127.0.0.1:6379> KEYS *
1) "user:1001"
2) "user:1002" 
3) "session:abc123"
4) "counter"

# 模式匹配查找
127.0.0.1:6379> KEYS user:*
1) "user:1001"
2) "user:1002"

127.0.0.1:6379> KEYS session:*
1) "session:abc123"
```

**通配符模式**：
```bash
# ? 匹配单个字符
127.0.0.1:6379> KEYS user:100?
1) "user:1001"
2) "user:1002"

# * 匹配任意字符
127.0.0.1:6379> KEYS *session*
1) "session:abc123"
2) "user_session_data"

# [] 匹配括号内的任意一个字符
127.0.0.1:6379> KEYS user:100[12]
1) "user:1001" 
2) "user:1002"

# [^] 匹配不在括号内的字符
127.0.0.1:6379> KEYS user:100[^3]
1) "user:1001"
2) "user:1002"   # 不匹配user:1003
```

**⚠️ KEYS命令的风险**：
```
生产环境谨慎使用KEYS的原因：

时间复杂度：O(n) - n是数据库中键的总数
阻塞特性：单线程执行，会阻塞其他命令
性能影响：数据量大时可能导致Redis卡顿

示例：
100万个键的数据库执行 KEYS *
可能需要几百毫秒到几秒钟
这段时间内Redis无法处理其他请求
```

### 3.2 SCAN - 安全的键遍历


**基本概念**：
```
SCAN相比KEYS的优势：
- 增量迭代：每次只返回少量结果
- 非阻塞：不会长时间占用Redis  
- 可中断：可以随时停止遍历
- 生产安全：适合在线上环境使用
```

**基本用法**：
```bash
# 语法：SCAN cursor [MATCH pattern] [COUNT count]
127.0.0.1:6379> SCAN 0
1) "6"        # 下一次遍历的游标
2) 1) "user:1001"
   2) "counter" 
   3) "session:abc123"

# 继续遍历（使用返回的游标）
127.0.0.1:6379> SCAN 6  
1) "0"        # 返回0表示遍历完成
2) 1) "user:1002"
   2) "task_queue"
```

**SCAN完整遍历示例**：
```bash
# 遍历所有键的完整流程
127.0.0.1:6379> SCAN 0 COUNT 2
1) "3"
2) 1) "key1"
   2) "key2"

127.0.0.1:6379> SCAN 3 COUNT 2  
1) "5"
2) 1) "key3"
   2) "key4"

127.0.0.1:6379> SCAN 5 COUNT 2
1) "0"        # 游标为0，遍历结束
2) 1) "key5"
```

**模式匹配和计数控制**：
```bash
# 只查找user开头的键
127.0.0.1:6379> SCAN 0 MATCH user:* COUNT 10
1) "4"
2) 1) "user:1001"
   2) "user:1002"

# COUNT参数说明
COUNT 10：建议每次返回约10个键
注意：这只是建议值，实际返回数量可能不同
Redis会根据内部数据结构调整实际返回数量
```

**SCAN vs KEYS 对比表**：

| 特性 | KEYS | SCAN |
|------|------|------|
| **时间复杂度** | O(n) | O(1)每次调用 |
| **阻塞性** | 阻塞式 | 非阻塞式 |
| **结果完整性** | 一次返回全部 | 增量返回 |
| **生产环境** | ❌不推荐 | ✅推荐使用 |
| **内存占用** | 可能很高 | 固定较小 |

---

## 4. 📊 键信息获取


### 4.1 TYPE - 获取键的数据类型


```bash
# 查看不同类型键的类型
127.0.0.1:6379> SET name "张三"
127.0.0.1:6379> TYPE name
string

127.0.0.1:6379> LPUSH tasks "task1" "task2"  
127.0.0.1:6379> TYPE tasks
list

127.0.0.1:6379> HSET user:1 name "李四" age 25
127.0.0.1:6379> TYPE user:1
hash

# 键不存在时
127.0.0.1:6379> TYPE nonexist
none
```

**数据类型对应表**：
```
Redis数据类型 → TYPE命令返回值

String    → string
List      → list  
Hash      → hash
Set       → set
Zset      → zset
Stream    → stream
不存在    → none
```

**实际应用场景**：
```python
# Python伪代码：根据类型执行不同操作
def process_key(redis_client, key):
    key_type = redis_client.type(key)
    
    if key_type == 'string':
        value = redis_client.get(key)
        # 处理字符串
    elif key_type == 'list':
        values = redis_client.lrange(key, 0, -1)
        # 处理列表
    elif key_type == 'hash':
        values = redis_client.hgetall(key)  
        # 处理哈希
    else:
        print(f"未知类型: {key_type}")
```

### 4.2 EXISTS - 检查键是否存在


```bash
# 检查单个键
127.0.0.1:6379> EXISTS mykey
(integer) 1    # 1表示存在

127.0.0.1:6379> EXISTS nonexist
(integer) 0    # 0表示不存在

# 检查多个键  
127.0.0.1:6379> EXISTS key1 key2 key3
(integer) 2    # 返回存在的键的数量
```

### 4.3 其他信息获取命令


```bash
# OBJECT - 查看键的内部信息
127.0.0.1:6379> OBJECT encoding mystring
"embstr"       # 字符串的内部编码

# MEMORY USAGE - 查看键占用的内存（Redis 4.0+）
127.0.0.1:6379> MEMORY usage mykey  
(integer) 56   # 占用56字节内存

# RANDOMKEY - 随机返回一个键
127.0.0.1:6379> RANDOMKEY
"user:1001"
```

---

## 5. 🏷️ 键重命名操作


### 5.1 RENAME - 键重命名


```bash
# 基本重命名
127.0.0.1:6379> SET oldname "value"
127.0.0.1:6379> RENAME oldname newname
OK

# 验证重命名结果
127.0.0.1:6379> GET oldname
(nil)          # 原键已不存在

127.0.0.1:6379> GET newname
"value"        # 新键包含原来的值
```

**重命名行为说明**：
```
RENAME的工作机制：

1. 复制原键的值到新键
2. 删除原键  
3. 如果目标键已存在，会被覆盖

示例：
原状态：oldkey="hello", newkey="world"
执行：RENAME oldkey newkey  
结果：oldkey不存在, newkey="hello"
注意：原来newkey的值"world"丢失了！
```

### 5.2 RENAMENX - 仅在新键不存在时重命名


```bash
# 安全重命名（不覆盖已存在的键）
127.0.0.1:6379> SET key1 "value1"
127.0.0.1:6379> SET key2 "value2"

127.0.0.1:6379> RENAMENX key1 key2
(integer) 0    # 返回0表示重命名失败（key2已存在）

127.0.0.1:6379> RENAMENX key1 key3  
(integer) 1    # 返回1表示重命名成功
```

**RENAME vs RENAMENX 对比**：
```
场景：oldkey="hello", newkey="world"

RENAME oldkey newkey：
- 强制重命名，覆盖newkey
- 结果：newkey="hello"，原来的"world"丢失

RENAMENX oldkey newkey：  
- 安全重命名，不覆盖已存在键
- 结果：操作失败，两个键都保持不变
- 返回值：0（失败）或1（成功）
```

---

## 6. 🚀 实际应用场景


### 6.1 会话管理


```bash
# 用户登录创建会话
127.0.0.1:6379> HSET session:abc123 user_id 1001 login_time 1677654321
127.0.0.1:6379> EXPIRE session:abc123 7200    # 2小时后过期

# 检查会话是否还有效
127.0.0.1:6379> TTL session:abc123
(integer) 6543    # 还剩6543秒

# 用户退出时立即清除会话
127.0.0.1:6379> DEL session:abc123
```

**会话清理策略**：
```python
# Python伪代码：定期清理会话
import redis
r = redis.Redis()

def cleanup_expired_sessions():
    # 使用SCAN安全遍历所有会话键
    cursor = 0
    while True:
        cursor, keys = r.scan(cursor, match="session:*", count=100)
        
        for key in keys:
            ttl = r.ttl(key)
            if ttl == -2:  # 键已不存在
                continue
            elif ttl < 300:  # 快过期的会话
                print(f"会话 {key} 还有 {ttl} 秒过期")
        
        if cursor == 0:  # 遍历完成
            break
```

### 6.2 缓存管理


```bash
# 缓存用户信息（30分钟过期）
127.0.0.1:6379> HSET cache:user:1001 name "张三" age 25
127.0.0.1:6379> EXPIRE cache:user:1001 1800

# 检查缓存类型和剩余时间
127.0.0.1:6379> TYPE cache:user:1001
hash
127.0.0.1:6379> TTL cache:user:1001  
(integer) 1654

# 批量检查缓存键
127.0.0.1:6379> SCAN 0 MATCH cache:user:* COUNT 50
```

### 6.3 数据迁移和重构


```bash
# 旧版本键名重构
127.0.0.1:6379> KEYS userdata:*
1) "userdata:1001"
2) "userdata:1002"

# 重命名为新格式（user:id:profile）
127.0.0.1:6379> RENAME userdata:1001 user:1001:profile
127.0.0.1:6379> RENAME userdata:1002 user:1002:profile

# 验证重命名结果
127.0.0.1:6379> KEYS user:*:profile
1) "user:1001:profile" 
2) "user:1002:profile"
```

### 6.4 监控和运维


```bash
# 统计不同类型键的数量
127.0.0.1:6379> SCAN 0 MATCH user:* COUNT 1000
# 再用TYPE检查每个键的类型进行统计

# 查找占用内存最多的键
127.0.0.1:6379> MEMORY usage user:1001
(integer) 256

# 随机采样检查数据质量  
127.0.0.1:6379> RANDOMKEY
"cache:product:123"
127.0.0.1:6379> TTL cache:product:123
(integer) 3600
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 通用性：这些命令适用于所有数据类型的键
🔸 过期机制：自动删除过期键，防止内存泄漏  
🔸 安全遍历：生产环境使用SCAN代替KEYS
🔸 键管理：重命名、类型检查、存在性判断
🔸 监控运维：TTL检查、内存使用、随机采样
```

### 7.2 关键命令对比


**📊 过期时间命令**：
```
EXPIRE key seconds     # 设置秒级过期时间
EXPIREAT key timestamp # 设置具体过期时间戳  
PEXPIRE key ms         # 设置毫秒级过期时间
TTL key                # 查看剩余秒数
PTTL key               # 查看剩余毫秒数
PERSIST key            # 移除过期时间
```

**📊 键查找命令**：
```
KEYS pattern    # 模式匹配（生产环境慎用）
SCAN cursor     # 安全遍历（推荐使用）
EXISTS key      # 检查键是否存在
RANDOMKEY       # 随机获取一个键
```

**📊 键信息命令**：
```
TYPE key           # 获取键的数据类型
OBJECT encoding    # 查看键的内部编码
MEMORY usage key   # 查看键占用内存
```

### 7.3 生产环境最佳实践


```
✅ 推荐做法：
1. 合理设置过期时间，防止内存泄漏
2. 使用SCAN代替KEYS进行键遍历  
3. 用EXISTS检查键存在性，避免无效操作
4. 重命名前用RENAMENX确保不覆盖重要数据

❌ 避免的做法：
1. 生产环境使用 KEYS * 查看所有键
2. 忘记设置过期时间导致内存无限增长
3. 重命名时不考虑目标键是否已存在
4. 频繁使用RANDOMKEY做业务逻辑
```

### 7.4 常用操作模式


```
会话管理模式：
创建：HSET session:id + EXPIRE  
检查：EXISTS + TTL
清理：DEL 或让其自动过期

缓存管理模式：  
设置：SET/HSET + EXPIRE
检查：TYPE + TTL + EXISTS
清理：定期SCAN + TTL检查

数据迁移模式：
查找：SCAN 指定模式
检查：TYPE + EXISTS  
重命名：RENAMENX（安全）或RENAME（强制）
验证：再次SCAN确认结果
```

### 7.5 性能和安全注意事项


```
性能影响：
- KEYS：O(n)复杂度，数据量大时很危险
- SCAN：O(1)每次调用，安全可控
- TTL/TYPE/EXISTS：O(1)复杂度，可频繁使用

内存管理：
- 合理设置过期时间
- 定期检查TTL分布  
- 使用MEMORY usage监控大键
- 及时清理不需要的键

安全考虑：
- 生产环境禁用或重命名KEYS命令
- 使用RENAMENX避免意外覆盖
- 设置键命名规范便于管理
- 定期备份重要的永久键
```

**核心记忆**：
- 过期时间防泄漏，TTL来把时间查
- SCAN安全KEYS危险，生产一定要记牢  
- TYPE类型RENAME改名，EXISTS检查键在否
- 通用命令很重要，运维监控少不了