---
title: 2、数据过期与淘汰策略
---
## 📚 目录

1. [数据过期基础概念](#1-数据过期基础概念)
2. [过期删除机制](#2-过期删除机制)
3. [内存淘汰策略详解](#3-内存淘汰策略详解)
4. [LRU算法详解](#4-LRU算法详解)
5. [LFU算法详解](#5-LFU算法详解)
6. [策略选择与配置](#6-策略选择与配置)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🕐 数据过期基础概念


### 1.1 什么是数据过期


**通俗理解**：Redis可以给每个key设置一个"生存时间"，就像给食物贴上保质期标签。

```
现实生活类比：
牛奶 → 保质期7天 → 过期后不能喝
Redis Key → TTL 300秒 → 过期后自动删除

设置过期时间：
127.0.0.1:6379> SET session:user123 "login_data"
127.0.0.1:6379> EXPIRE session:user123 3600  # 1小时后过期
```

### 1.2 为什么需要过期机制


**核心问题**：内存是有限的，不能无限存储数据

```
实际场景需求：

🔸 会话管理：
用户登录 → 创建session → 1小时后自动过期
避免：用户不主动登出，session永久占用内存

🔸 缓存数据：
查询结果 → 缓存5分钟 → 过期后重新查询
避免：缓存数据永不更新，占用大量内存

🔸 临时数据：
验证码 → 5分钟有效期 → 过期自动清理
避免：大量过期验证码占用存储空间
```

### 1.3 过期时间设置方式


```bash
# 方式1：设置秒级过期时间
127.0.0.1:6379> EXPIRE mykey 60        # 60秒后过期
127.0.0.1:6379> PEXPIRE mykey 60000    # 60000毫秒后过期

# 方式2：设置具体过期时间点
127.0.0.1:6379> EXPIREAT mykey 1693276800   # Unix时间戳
127.0.0.1:6379> PEXPIREAT mykey 1693276800000  # 毫秒时间戳

# 方式3：创建时直接设置
127.0.0.1:6379> SET session "data" EX 3600    # 创建并设置3600秒过期
127.0.0.1:6379> SET cache "value" PX 300000   # 创建并设置300秒过期

# 查看剩余时间
127.0.0.1:6379> TTL mykey     # 返回剩余秒数
127.0.0.1:6379> PTTL mykey    # 返回剩余毫秒数
```

---

## 2. 🗑️ 过期删除机制


### 2.1 删除策略概述


**Redis采用两种删除策略的组合**：

```
删除策略对比：

定时删除：
┌─────────────┐    ┌──────────┐
│  设置定时器  │ → │ 到期立即删除 │
└─────────────┘    └──────────┘
优点：内存及时释放
缺点：消耗大量CPU资源

惰性删除：
┌─────────────┐    ┌──────────┐
│  访问时检查  │ → │ 发现过期才删除 │
└─────────────┘    └──────────┘
优点：CPU消耗少
缺点：内存可能长期占用

Redis实际策略：定时删除 + 惰性删除
```

### 2.2 惰性删除详解


**工作原理**：只有在访问key时才检查是否过期

```bash
# 演示惰性删除
127.0.0.1:6379> SET test_key "value" EX 5    # 5秒后过期
127.0.0.1:6379> GET test_key
"value"

# 等待6秒后...
127.0.0.1:6379> GET test_key
(nil)    # 这时才真正删除过期的key
```

**惰性删除机制图解**：
```
时间线：
0s    设置key，过期时间5s
1s    key存在，未过期
2s    key存在，未过期  
3s    key存在，未过期
4s    key存在，未过期
5s    key过期，但仍在内存中 ← 重点：过期不等于删除
6s    访问key时发现过期 → 立即删除并返回nil

关键理解：过期时间到了 ≠ 立即从内存删除
```

### 2.3 定时删除详解


**工作原理**：Redis定时随机抽样检查过期key

```
定时删除机制：

每秒执行10次过期检查：
1. 随机选择20个设置了过期时间的key
2. 检查这20个key是否过期，删除过期的
3. 如果过期key超过25%，立即再执行一轮检查

┌────────────────┐
│  随机选择20个key │
├────────────────┤
│   检查是否过期   │  
├────────────────┤
│ 过期率>25%？    │ ──Yes→ 再次检查
├────────────────┤
│      结束       │ ←─No──
└────────────────┘
```

**📝 为什么要随机抽样**：
```
假设Redis有100万个key，其中50万设置了过期时间：

如果每次都检查所有key：
- CPU消耗巨大，影响正常服务
- 可能导致Redis卡顿

随机抽样策略：
- 每次只检查20个key
- 统计学原理：样本能反映整体情况
- 平衡了及时性和性能
```

### 2.4 过期删除的时机


**📊 删除时机汇总**：

| 删除时机 | **触发条件** | **删除范围** | **性能影响** |
|---------|-------------|-------------|-------------|
| **访问时删除** | `GET/SET等操作访问到过期key` | `单个key` | `几乎无影响` |
| **定时删除** | `每秒10次定时检查` | `最多20个key/次` | `轻微影响` |
| **内存满时删除** | `内存不足触发淘汰策略` | `按策略批量删除` | `明显影响` |

---

## 3. 🧹 内存淘汰策略详解


### 3.1 什么时候触发内存淘汰


**触发条件**：当Redis内存使用量达到`maxmemory`限制时

```bash
# 查看内存配置
127.0.0.1:6379> CONFIG GET maxmemory
1) "maxmemory"
2) "2147483648"    # 2GB限制

# 查看当前内存使用
127.0.0.1:6379> INFO memory
used_memory:1073741824    # 已使用1GB
used_memory_human:1.00G
```

**内存不足处理流程**：
```
内存使用情况检查：
┌─────────────────┐
│ 新写入操作请求    │
├─────────────────┤
│ 检查内存使用量    │
├─────────────────┤
│ 超过maxmemory？  │ ──No→ 正常执行
├─────────────────┤      ↓
│ 执行淘汰策略     │ ←─Yes
├─────────────────┤
│ 释放足够内存     │
├─────────────────┤
│ 执行原始操作     │
└─────────────────┘
```

### 3.2 八大淘汰策略分类


**🔸 策略分类框架**：

```
Redis 8种淘汰策略：

按作用范围分类：
┌─────────────────┬─────────────────┐
│   volatile-xxx   │   allkeys-xxx   │
│ 只考虑有过期时间的key │ 考虑所有key      │
└─────────────────┴─────────────────┘

按淘汰算法分类：
┌─────────┬─────────┬─────────┬─────────┐
│   LRU   │   LFU   │ Random  │ Special │
│ 最近最少 │ 最少使用 │ 随机删除 │ 特殊策略 │
│  使用   │  频率   │        │        │
└─────────┴─────────┴─────────┴─────────┘
```

### 3.3 具体策略详解


#### 🎯 volatile策略（只针对有过期时间的key）


```bash
# 1. volatile-lru：删除最近最少使用的过期key
127.0.0.1:6379> CONFIG SET maxmemory-policy volatile-lru

# 2. volatile-lfu：删除使用频率最低的过期key  
127.0.0.1:6379> CONFIG SET maxmemory-policy volatile-lfu

# 3. volatile-random：随机删除过期key
127.0.0.1:6379> CONFIG SET maxmemory-policy volatile-random

# 4. volatile-ttl：删除TTL最小（即将过期）的key
127.0.0.1:6379> CONFIG SET maxmemory-policy volatile-ttl
```

**volatile策略场景图解**：
```
内存中的key状态：
┌──────────────┬──────────────┬──────────────┐
│   持久key     │   过期key     │   过期key    │  
│ session:abc  │ cache:user1  │ cache:user2  │
│ (无过期时间)   │ (TTL: 100s)  │ (TTL: 50s)   │
│   不会被删除   │   候选删除    │   候选删除    │
└──────────────┴──────────────┴──────────────┘

volatile策略只会从有过期时间的key中选择删除
```

#### 🌐 allkeys策略（针对所有key）


```bash
# 5. allkeys-lru：删除最近最少使用的任意key
127.0.0.1:6379> CONFIG SET maxmemory-policy allkeys-lru

# 6. allkeys-lfu：删除使用频率最低的任意key
127.0.0.1:6379> CONFIG SET maxmemory-policy allkeys-lfu  

# 7. allkeys-random：随机删除任意key
127.0.0.1:6379> CONFIG SET maxmemory-policy allkeys-random
```

#### 🚫 特殊策略


```bash
# 8. noeviction：不删除任何key，内存满时拒绝写入
127.0.0.1:6379> CONFIG SET maxmemory-policy noeviction
# 内存满时，写操作会返回错误：OOM command not allowed
```

### 3.4 策略选择指导


**📊 策略适用场景对比**：

| 策略类型 | **适用场景** | **优点** | **缺点** |
|---------|-------------|---------|---------|
| **volatile-lru** | `缓存场景，重要数据有过期时间` | `保护持久数据` | `可能内存不足` |
| **volatile-lfu** | `缓存访问有明显热点` | `保护高频数据` | `冷数据可能过早删除` |
| **volatile-ttl** | `希望优先清理即将过期的数据` | `自然过期优先` | `可能删除重要数据` |
| **allkeys-lru** | `纯缓存场景，所有数据可删除` | `充分利用内存` | `可能删除重要数据` |
| **allkeys-lfu** | `纯缓存场景，有明显热点数据` | `保护热点数据` | `新数据可能被误删` |
| **noeviction** | `数据都很重要，不允许丢失` | `数据安全` | `内存满时无法写入` |

---

## 4. 🔄 LRU算法详解


### 4.1 LRU基本概念


**LRU含义**：Least Recently Used，最近最少使用算法

**核心思想**：认为最近没有被访问的数据，将来被访问的可能性也很小

```
生活中的LRU例子：

书架整理：
┌─────┬─────┬─────┬─────┐
│ 常看 │ 偶尔看│ 很少看│ 不看了│
│ 前排 │ 前排  │ 后排  │ 后排  │
└─────┴─────┴─────┴─────┘

空间不够时，优先清理最后排（最少使用）的书
```

### 4.2 Redis LRU实现原理


**📝 传统LRU vs Redis LRU**：

```
传统LRU（教科书版本）：
- 维护一个双向链表
- 每次访问都调整链表顺序
- 精确记录每个元素的使用顺序

Redis近似LRU：
- 每个key记录最后访问时间戳
- 随机采样选择淘汰对象
- 平衡了精确度和性能
```

**Redis LRU工作流程**：
```
LRU淘汰过程：

1. 内存不足触发淘汰
   ┌─────────────────┐
   │  需要释放内存    │
   └─────────────────┘
           ↓
2. 随机采样key（默认5个）
   ┌─────┬─────┬─────┬─────┬─────┐
   │key1 │key2 │key3 │key4 │key5 │
   │上次访问│上次访问│上次访问│上次访问│上次访问│
   │ 1分钟前│ 5分钟前│ 2分钟前│ 10分钟前│ 3分钟前│
   └─────┴─────┴─────┴─────┴─────┘
           ↓
3. 选择最久没访问的删除
   ┌─────────┐
   │  删除key4 │  ← 10分钟前是最久的
   └─────────┘
```

### 4.3 LRU配置参数


```bash
# 设置LRU采样数量（默认5，范围1-10）
127.0.0.1:6379> CONFIG SET maxmemory-samples 5

# 采样数量对精确度的影响：
# samples=1：最不精确，最快
# samples=3：一般精确度
# samples=5：较好平衡（默认）
# samples=10：最精确，最慢
```

**采样数量影响示意图**：
```
采样数量与精确度：

samples=1   [随机1个] → 精确度低，速度快
samples=3   [随机3个] → 精确度中等  
samples=5   [随机5个] → 精确度较好（推荐）
samples=10  [随机10个]→ 精确度高，速度较慢

实际效果：
samples=5时，Redis LRU的效果已经非常接近真正的LRU算法
```

---

## 5. 📊 LFU算法详解


### 5.1 LFU基本概念


**LFU含义**：Least Frequently Used，最不经常使用算法

**核心思想**：认为访问次数少的数据，将来被访问的可能性也小

```
LRU vs LFU 的区别：

LRU看"时间"：最近用过吗？
┌─────────────┐
│ 昨天用了100次│ ← LRU认为：很久没用，可以删除
│ 今天没用过   │
└─────────────┘

LFU看"频率"：经常用吗？
┌─────────────┐  
│ 昨天用了100次│ ← LFU认为：使用频率高，不应删除
│ 今天没用过   │
└─────────────┘
```

### 5.2 LFU计数机制


**Redis LFU实现**：使用8位计数器记录访问频率

```
LFU计数器设计：

8位计数器 → 最大值255
问题：如果每次访问+1，很快就溢出

Redis解决方案：对数计数
┌─────────────────────────┐
│ 访问次数 → LFU计数器值    │
├─────────────────────────┤
│    1     →      1       │
│   10     →      5       │  
│  100     →     10       │
│ 1000     →     15       │
│ 10000    →     20       │
└─────────────────────────┘

优势：用8位记录很大的访问次数范围
```

### 5.3 LFU衰减机制


**时间衰减**：长时间不访问，计数器会自动减少

```bash
# LFU相关配置
127.0.0.1:6379> CONFIG GET lfu-*
1) "lfu-log-factor"
2) "10"        # 访问频率增长因子
3) "lfu-decay-time" 
4) "1"         # 衰减时间（分钟）
```

**衰减机制图解**：
```
LFU计数器变化：

热点数据：
访问频繁 → 计数器快速增长
时间：  0min   5min   10min  15min
计数器： 5  →  8   →  12  → 15

冷数据：
不再访问 → 计数器逐渐衰减  
时间：  0min   5min   10min  15min
计数器： 10 →  9   →   8  →  7

结果：真正的热点数据计数器会保持较高值
```

### 5.4 LFU vs LRU 实际效果对比


```
场景：缓存用户信息

用户访问模式：
- user:1001 → 每天访问100次（VIP用户）
- user:1002 → 昨天访问很多，今天没访问
- user:1003 → 偶尔访问一次

内存不足需要删除1个：

LRU策略：
会删除user:1001（因为可能几小时没访问）
保留user:1002（因为最近访问过）

LFU策略：  
会删除user:1003（访问频率最低）
保留user:1001（访问频率最高的VIP用户）

结论：LFU更适合有明显热点数据的场景
```

---

## 6. ⚙️ 策略选择与配置


### 6.1 策略配置方法


```bash
# 查看当前策略
127.0.0.1:6379> CONFIG GET maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"    # 默认不淘汰

# 修改策略（立即生效）
127.0.0.1:6379> CONFIG SET maxmemory-policy allkeys-lru

# 永久配置（写入redis.conf）
maxmemory 2gb
maxmemory-policy allkeys-lru
maxmemory-samples 5
```

### 6.2 业务场景策略选择


**📋 选择决策树**：
```
我的Redis主要用途是什么？

纯缓存场景（数据可以丢失）：
├─ 有明显热点数据 → allkeys-lfu  
├─ 没有明显热点 → allkeys-lru
└─ 随机访问模式 → allkeys-random

混合场景（有重要数据 + 缓存数据）：
├─ 重要数据设置为永不过期
├─ 缓存数据设置过期时间
└─ 选择 volatile-lru 或 volatile-lfu

高可用场景（数据不能丢失）：
└─ 选择 noeviction + 监控内存使用
```

### 6.3 实际配置示例


**场景1：Web应用缓存**
```bash
# 适合：缓存数据库查询结果、页面缓存
127.0.0.1:6379> CONFIG SET maxmemory 1gb
127.0.0.1:6379> CONFIG SET maxmemory-policy allkeys-lru
127.0.0.1:6379> CONFIG SET maxmemory-samples 5

理由：
- 所有缓存数据都可以删除重建
- LRU算法适合一般的访问模式
- 5个采样平衡精确度和性能
```

**场景2：会话存储 + 缓存**
```bash
# 适合：用户会话（重要）+ 临时缓存
127.0.0.1:6379> CONFIG SET maxmemory 2gb
127.0.0.1:6379> CONFIG SET maxmemory-policy volatile-lru

数据设计：
# 重要的会话数据（不设过期时间）
SET session:user123 "session_data"

# 临时缓存数据（设置过期时间）  
SET cache:product:456 "product_info" EX 3600

结果：内存不足时只删除缓存数据，保护会话数据
```

**场景3：金融系统（数据不能丢失）**
```bash
127.0.0.1:6379> CONFIG SET maxmemory 4gb
127.0.0.1:6379> CONFIG SET maxmemory-policy noeviction

# 配合监控系统：
# - 内存使用率达到80%时告警
# - 内存使用率达到90%时扩容
# - 绝不允许数据被自动删除
```

### 6.4 策略效果监控


```bash
# 查看淘汰统计信息
127.0.0.1:6379> INFO stats
# 关注这些指标：
evicted_keys:1256          # 已淘汰的key数量
expired_keys:8924          # 已过期的key数量  
keyspace_hits:15678        # 缓存命中次数
keyspace_misses:2341       # 缓存未命中次数

# 计算缓存命中率
命中率 = keyspace_hits / (keyspace_hits + keyspace_misses)
      = 15678 / (15678 + 2341) = 87%
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 数据过期：给key设置生存时间，到期自动失效
🔸 删除机制：惰性删除（访问时检查）+ 定时删除（定期抽样）
🔸 内存淘汰：内存不足时按策略删除数据释放空间
🔸 策略分类：volatile针对过期key，allkeys针对所有key
🔸 算法区别：LRU看时间，LFU看频率，Random看运气
```

### 7.2 关键理解要点


**🔹 过期 ≠ 立即删除**
```
重要认知：
设置了过期时间的key不会在到期的瞬间被删除
而是在：
1. 下次访问时检查并删除（惰性删除）
2. 定时扫描发现并删除（定时删除）

实际影响：
- 过期key可能短暂停留在内存中
- 使用INFO memory看到的内存可能包含过期key
- 这是正常现象，不是bug
```

**🔹 LRU vs LFU选择**
```
选择标准：

选择LRU当：
- 用户行为有明显的时间局部性
- 最近访问的数据更可能再次被访问
- 典型场景：网页缓存、用户session

选择LFU当：
- 数据访问有明显的热点集中性  
- 少数数据被大量访问，多数数据很少访问
- 典型场景：热门商品缓存、流行内容推荐
```

**🔹 volatile vs allkeys选择**
```
选择原则：

选择volatile策略：
- 有重要数据不能删除（不设过期时间）
- 有临时数据可以删除（设置过期时间）
- 需要精确控制哪些数据可被删除

选择allkeys策略：
- 所有数据都是缓存性质，都可以删除
- 数据丢失后可以重新加载
- 希望最大化内存利用率
```

### 7.3 最佳实践建议


**✅ 推荐做法**：

> 💡 **业务数据分离策略**
> 
> 重要数据（用户会话、订单信息）→ 不设过期时间
> 缓存数据（查询结果、页面缓存）→ 设置合理过期时间
> 淘汰策略选择：volatile-lru

> ⚠️ **内存监控告警**
> 
> 设置内存使用率告警：
> - 70%：开始关注
> - 80%：准备扩容  
> - 90%：立即扩容
> - 95%：触发告警

**❌ 避免的做法**：
```
- 不要把所有数据都设为永不过期（内存会爆满）
- 不要随意选择random策略（可能删除重要数据）
- 不要忽视内存监控（突然爆满会影响服务）
- 不要频繁修改淘汰策略（可能影响性能）
```

### 7.4 故障排查指南


**常见问题及解决方案**：

> 📊 **问题1：缓存命中率突然下降**
> 
> 可能原因：
> - 淘汰策略删除了热点数据
> - 过期时间设置过短
> 
> 解决方案：
> - 检查淘汰策略是否合适
> - 调整过期时间或内存限制
> - 监控evicted_keys指标

> ⚠️ **问题2：内存使用异常增长**
> 
> 可能原因：
> - 大量key没有设置过期时间
> - 选择了noeviction策略但内存不足
> 
> 解决方案：
> - 检查是否有大量永久key
> - 合理设置过期时间
> - 考虑调整淘汰策略

### 7.5 性能优化建议


**🎯 配置优化**：
```
根据业务特点调优：

高并发读缓存：
- maxmemory-policy: allkeys-lfu
- maxmemory-samples: 3（减少采样开销）

会话存储：  
- maxmemory-policy: volatile-lru
- 重要数据不设过期时间

混合场景：
- maxmemory-policy: volatile-lfu  
- 监控evicted_keys，及时调整
```

**核心记忆**：
- 过期机制保证数据时效性，删除时机有延迟属正常
- 淘汰策略是内存不足时的自救机制，需要根据业务选择
- LRU适合时间局部性，LFU适合访问热点集中
- volatile保护无过期key，allkeys最大化内存利用
- 监控和告警是避免内存问题的最佳实践