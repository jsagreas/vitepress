---
title: 7、Redis监控与排错
---
## 📚 目录

1. [监控命令详解](#1-监控命令详解)
2. [性能测试工具](#2-性能测试工具)
3. [常见错误排查](#3-常见错误排查)
4. [监控最佳实践](#4-监控最佳实践)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🔍 监控命令详解


### 1.1 INFO 命令 - Redis 健康体检


**🔸 什么是 INFO 命令**
```
INFO 命令就像给 Redis 做全面体检
- 查看 Redis 服务器的各项指标
- 了解内存使用、客户端连接、性能统计等
- 是排查问题的第一工具
```

**💡 基本使用方法**
```bash
# 查看所有信息
redis-cli INFO

# 查看特定分类信息
redis-cli INFO server      # 服务器信息
redis-cli INFO memory      # 内存使用情况
redis-cli INFO clients     # 客户端连接信息
redis-cli INFO stats       # 统计信息
```

### 1.2 INFO 关键信息解读


**📊 内存使用分析**
```bash
# 执行命令
redis-cli INFO memory

# 重要指标解读
used_memory:1048576                    # 已使用内存(字节)
used_memory_human:1.00M                # 已使用内存(易读格式)
used_memory_rss:2097152               # 操作系统实际分配内存
maxmemory:0                           # 最大内存限制(0表示无限制)
used_memory_peak:2097152              # 历史最大内存使用
```

> 💡 **通俗理解**  
> - `used_memory`: 你家里实际用了多少东西
> - `used_memory_rss`: 你租的房子总面积  
> - `maxmemory`: 房东允许你最多用多少空间

**🔗 客户端连接监控**
```bash
# 客户端信息
redis-cli INFO clients

# 关键指标
connected_clients:2                    # 当前连接的客户端数
client_longest_output_list:0           # 客户端输出缓冲区最大长度
client_biggest_input_buf:0             # 客户端输入缓冲区最大大小
blocked_clients:0                      # 被阻塞的客户端数量
```

**📈 性能统计信息**
```bash
# 统计信息
redis-cli INFO stats

# 重要指标
total_commands_processed:1000          # 总共处理的命令数
instantaneous_ops_per_sec:50          # 当前每秒操作数(QPS)
total_net_input_bytes:81923           # 网络输入总字节数
total_net_output_bytes:409448         # 网络输出总字节数
rejected_connections:0                # 被拒绝的连接数
```

### 1.3 MONITOR 命令 - 实时监控


**🔸 什么是 MONITOR 命令**
```
MONITOR 命令就像给 Redis 安装了监控摄像头
- 实时显示 Redis 服务器接收到的所有命令
- 可以看到每个命令的执行时间
- 调试和排错的强大工具
```

**⚠️ 使用注意事项**
```
重要警告：
- MONITOR 会影响 Redis 性能（降低约50%）
- 生产环境谨慎使用，用完立即关闭
- 适合短期调试，不适合长期监控
```

**🔧 实际使用示例**
```bash
# 启动监控
redis-cli MONITOR

# 输出示例（实时显示）
1693123456.789123 [0 127.0.0.1:52387] "SET" "user:1001" "john"
1693123456.790456 [0 127.0.0.1:52387] "GET" "user:1001"
1693123456.791789 [0 127.0.0.1:52388] "HSET" "product:100" "name" "iPhone"
```

**📋 输出格式解读**
```
格式：timestamp [database client-ip:port] "command" "arg1" "arg2"

1693123456.789123    # 时间戳（Unix时间）
[0]                  # 数据库编号（默认是0）
127.0.0.1:52387     # 客户端IP和端口
"SET"               # 执行的命令
"user:1001"         # 命令参数
"john"              # 命令参数
```

---

## 2. ⚡ 性能测试工具


### 2.1 redis-benchmark 基础使用


**🔸 什么是 redis-benchmark**
```
redis-benchmark 是 Redis 官方提供的性能测试工具
作用：
- 测试 Redis 服务器的性能极限
- 模拟大量客户端并发操作
- 评估不同配置下的性能表现
```

**💻 基本测试命令**
```bash
# 基础性能测试
redis-benchmark

# 常用测试参数
redis-benchmark -h 127.0.0.1    # 指定服务器地址
redis-benchmark -p 6379          # 指定端口
redis-benchmark -c 50            # 并发客户端数量
redis-benchmark -n 10000         # 总请求数
```

### 2.2 详细测试配置


**🎯 针对性测试**
```bash
# 测试特定命令性能
redis-benchmark -t SET,GET -n 100000 -c 50

# 测试不同数据大小
redis-benchmark -t SET -n 10000 -d 1024    # 1KB数据
redis-benchmark -t SET -n 10000 -d 4096    # 4KB数据

# 模拟真实场景
redis-benchmark -t SET,GET,LPUSH,LPOP -n 100000 -c 100 --csv
```

**📊 测试结果解读**
```bash
# 输出示例
====== SET ======
100000 requests completed in 2.05 seconds
50 parallel clients
3 bytes payload
keep alive: 1

# 关键指标解读
Requests per second: 48780.49      # QPS：每秒请求数
Time per request: 1.025 ms         # 平均响应时间
Transfer rate: 3251.02 Kbytes/sec  # 数据传输率

# 延迟分布
50.00% <= 0.863 ms     # 50%请求在0.863ms内完成
75.00% <= 1.087 ms     # 75%请求在1.087ms内完成  
99.00% <= 2.031 ms     # 99%请求在2.031ms内完成
```

### 2.3 性能基准参考


| 操作类型 | **预期QPS** | **说明** |
|---------|------------|----------|
| `SET/GET` | `80,000-150,000` | `简单键值操作，性能最高` |
| `HSET/HGET` | `60,000-120,000` | `哈希操作，稍微复杂` |
| `LPUSH/LPOP` | `70,000-130,000` | `列表操作，性能良好` |
| `SADD/SREM` | `65,000-125,000` | `集合操作，中等性能` |

> 📝 **说明**：以上数据基于普通服务器配置，实际性能因硬件而异

---

## 3. 🚨 常见错误排查


### 3.1 连接数过多问题


**🔸 问题现象**
```
错误信息：
"ERR max number of clients reached"
"Connection refused"
```

**🔍 排查步骤**
```bash
# 1. 查看当前连接数
redis-cli INFO clients
# 看 connected_clients 数值

# 2. 查看最大连接数限制  
redis-cli CONFIG GET maxclients
# 默认通常是 10000

# 3. 查看系统连接状态
netstat -an | grep 6379 | wc -l
```

**🔧 解决方案**

<details>
<summary>点击查看详细解决方法</summary>

```bash
# 方法1：调整Redis最大连接数
redis-cli CONFIG SET maxclients 20000

# 方法2：修改配置文件（永久生效）
# 编辑 redis.conf
maxclients 20000

# 方法3：优化应用程序
# 使用连接池，避免频繁创建连接
# 及时关闭不需要的连接
```

</details>

**💡 预防措施**
```
应用程序优化：
✅ 使用 Redis 连接池
✅ 设置合理的连接超时时间  
✅ 及时释放不用的连接
✅ 监控连接数变化趋势
```

### 3.2 内存不足问题


**🔸 问题现象**
```
错误信息：
"OOM (Out Of Memory)"
"Can't save in background: fork: Cannot allocate memory"
```

**📊 内存使用检查**
```bash
# 查看Redis内存使用
redis-cli INFO memory

# 重点关注指标
used_memory_human:2.5G        # 当前内存使用
maxmemory:4.0G               # 内存限制
used_memory_peak_human:3.2G  # 历史峰值
```

**🔧 解决策略**

| 解决方法 | **操作命令** | **适用场景** |
|---------|-------------|-------------|
| `增加内存限制` | `CONFIG SET maxmemory 8gb` | `服务器内存充足` |
| `启用内存淘汰` | `CONFIG SET maxmemory-policy allkeys-lru` | `可以删除部分数据` |
| `清理过期数据` | `redis-cli --scan --pattern "temp:*" \| xargs redis-cli DEL` | `存在临时数据` |
| `数据压缩` | `使用更紧凑的数据结构` | `优化应用设计` |

**内存淘汰策略选择**
```bash
# 常用淘汰策略
allkeys-lru     # 在所有键中淘汰最少使用的
volatile-lru    # 在有过期时间的键中淘汰最少使用的
allkeys-lfu     # 在所有键中淘汰使用频率最低的
volatile-ttl    # 淘汰剩余生存时间最短的键

# 设置淘汰策略
redis-cli CONFIG SET maxmemory-policy allkeys-lru
```

### 3.3 阻塞问题排查


**🔸 什么是 Redis 阻塞**
```
Redis 阻塞是指：
- Redis 服务器停止响应客户端请求
- 通常是因为执行了耗时操作
- 会导致应用程序超时和响应缓慢
```

**⏱️ 常见阻塞原因**

**大键操作**
```bash
# 检查大键
redis-cli --bigkeys

# 示例输出
[00.00%] Biggest string found so far 'user:profile:12345' with 5242880 bytes

# 问题：删除或操作大键会阻塞Redis
# 解决：使用渐进式删除
```

**慢查询检测**
```bash
# 查看慢查询日志
redis-cli SLOWLOG GET 10

# 输出示例
1) 1) (integer) 0          # 日志ID
   2) (integer) 1693123456 # 执行时间戳
   3) (integer) 12000      # 执行耗时(微秒)
   4) 1) "DEL"             # 执行的命令
      2) "large_key"       # 命令参数

# 配置慢查询阈值
redis-cli CONFIG SET slowlog-log-slower-than 10000  # 10毫秒
```

**持久化阻塞**
```bash
# 查看后台保存状态
redis-cli LASTSAVE    # 上次SAVE的时间
redis-cli INFO persistence

# 关键指标
rdb_last_save_time:1693123456     # 上次RDB保存时间
rdb_current_bgsave_time_sec:-1    # 当前保存耗时(-1表示没在保存)
aof_rewrite_in_progress:0         # 是否在进行AOF重写
```

### 3.4 排错工具和技巧


**🔧 实用排错命令**
```bash
# 1. 查看Redis进程状态
ps aux | grep redis-server

# 2. 检查网络连接
netstat -tlnp | grep 6379
ss -tlnp | grep 6379

# 3. 查看Redis日志
tail -f /var/log/redis/redis-server.log

# 4. 检查配置文件
redis-cli CONFIG GET "*"
```

**📋 问题排查清单**

- [ ] **连接问题**
  - [ ] Redis 服务是否启动
  - [ ] 端口是否开放
  - [ ] 防火墙设置是否正确
  - [ ] 网络连通性是否正常

- [ ] **性能问题**
  - [ ] 内存使用是否超标
  - [ ] 是否存在慢查询
  - [ ] 客户端连接数是否过多
  - [ ] 持久化是否影响性能

- [ ] **数据问题**
  - [ ] 键是否过期
  - [ ] 数据类型是否正确
  - [ ] 编码格式是否合适

---

## 2. 🏃‍♂️ 性能测试工具


### 2.1 redis-benchmark 详细使用


**🔸 什么是 redis-benchmark**
```
redis-benchmark 是 Redis 自带的压力测试工具
作用：
- 测试 Redis 在不同负载下的性能表现
- 帮助确定 Redis 的性能基线
- 对比不同配置的性能差异
```

### 2.2 基础测试场景


**📊 标准性能测试**
```bash
# 基础测试（默认配置）
redis-benchmark

# 自定义测试参数
redis-benchmark \
  -h 127.0.0.1 \          # Redis服务器地址
  -p 6379 \               # 端口
  -c 50 \                 # 并发客户端数
  -n 100000 \             # 总请求数
  -d 1024                 # 数据大小(字节)
```

**🎯 针对性测试**
```bash
# 只测试SET和GET操作
redis-benchmark -t SET,GET -n 100000 -c 100

# 测试不同数据大小的影响
redis-benchmark -t SET -d 10 -n 10000      # 10字节
redis-benchmark -t SET -d 1024 -n 10000    # 1KB
redis-benchmark -t SET -d 10240 -n 10000   # 10KB
```

### 2.3 高级测试功能


**📈 Pipeline 测试**
```bash
# 使用 Pipeline 提高性能
redis-benchmark -t SET,GET -n 100000 -P 16

# Pipeline 说明：
# -P 16 表示每次发送16个命令后等待响应
# 可以显著提高吞吐量
```

**🔄 持续压力测试**
```bash
# 持续测试（不限制请求数）
redis-benchmark -t GET -c 100 --csv -l

# 输出CSV格式，便于后续分析
# -l 参数表示持续运行，需要手动停止
```

### 2.4 性能测试最佳实践


**📋 测试建议**

<details>
<summary>🔧 完整测试脚本示例</summary>

```bash
#!/bin/bash
# Redis性能基准测试脚本

echo "开始Redis性能测试..."

# 基础读写测试
echo "=== 基础读写性能 ==="
redis-benchmark -t SET,GET -n 100000 -c 50 -q

# 不同数据大小测试
echo "=== 不同数据大小测试 ==="
for size in 10 100 1024 10240; do
    echo "数据大小: ${size}字节"
    redis-benchmark -t SET -d $size -n 10000 -c 50 -q
done

# Pipeline性能测试
echo "=== Pipeline性能测试 ==="
redis-benchmark -t SET,GET -n 100000 -c 50 -P 16 -q

echo "测试完成！"
```

</details>

---

## 3. 🔧 常见错误排查


### 3.1 连接数过多详解


**🔸 问题的根本原因**
```
连接数过多通常是因为：
1. 应用程序没有正确使用连接池
2. 连接泄露：创建连接后没有正确关闭
3. 客户端配置不当：超时时间过长
4. 突发流量：短时间内大量连接请求
```

**🔍 深入排查方法**
```bash
# 查看详细的客户端连接信息
redis-cli CLIENT LIST

# 输出示例
id=3 addr=127.0.0.1:52184 fd=7 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client

# 关键字段说明：
# addr: 客户端地址和端口
# age: 连接存在时间（秒）
# idle: 连接空闲时间（秒）  
# cmd: 最后执行的命令
```

**🎯 解决方案对比**

| 解决方法 | **优点** | **缺点** | **适用场景** |
|---------|----------|----------|-------------|
| `增加maxclients` | `快速解决` | `治标不治本` | `临时应急` |
| `优化应用代码` | `根本解决` | `需要代码改动` | `长期方案` |
| `使用连接池` | `资源复用` | `增加复杂度` | `生产环境` |
| `设置超时` | `自动清理` | `可能影响正常连接` | `配合使用` |

### 3.2 内存不足深入分析


**🔍 内存使用分析工具**
```bash
# 查看内存使用详情
redis-cli INFO memory | grep used_memory

# 查看大键占用
redis-cli --bigkeys

# 分析键的内存使用
redis-cli DEBUG OBJECT key_name
```

**📊 内存优化策略**

```
数据结构优化：
🔸 Hash vs String：小数据用Hash更节省内存
  - String: SET user:1001:name "john" 
  - Hash: HSET user:1001 name "john"    # 更省内存

🔸 压缩配置：
  hash-max-ziplist-entries 512
  hash-max-ziplist-value 64
  # 小hash使用压缩编码
```

### 3.3 阻塞问题的系统化排查


**⏱️ 阻塞检测流程图**
```
发现Redis响应慢
         |
    检查慢查询日志
         |
   ┌─────┴─────┐
   |           |
 有慢查询     无慢查询
   |           |
优化命令    检查持久化
   |           |
   └─────┬─────┘
         |
    检查系统资源
         |
   ┌─────┴─────┐
   |           |
CPU/IO高     内存不足
   |           |
系统调优    内存优化
```

**🔧 具体排查命令**
```bash
# 1. 检查慢查询
redis-cli SLOWLOG GET 5
redis-cli CONFIG GET slowlog-log-slower-than

# 2. 检查持久化状态  
redis-cli INFO persistence
redis-cli CONFIG GET save

# 3. 检查系统资源
top -p $(pgrep redis-server)
iostat -x 1 5

# 4. 检查网络状态
redis-cli --latency-history
```

---

## 4. 📈 监控最佳实践


### 4.1 监控指标体系


**🎯 核心监控指标**

```
性能指标：
📊 QPS (每秒查询数)           目标: >50,000
📊 响应时间                  目标: <2ms
📊 命令延迟分布               目标: 99%<10ms

资源指标：  
💾 内存使用率                目标: <80%
💾 CPU使用率                 目标: <70%
🔗 连接数                    目标: <maxclients的80%

可用性指标：
✅ 服务可用性                目标: >99.9%
🔄 持久化状态                监控: RDB/AOF是否正常
⚠️ 错误率                    目标: <0.1%
```

### 4.2 自动化监控脚本


<details>
<summary>🛠️ Redis 健康检查脚本</summary>

```bash
#!/bin/bash
# redis_health_check.sh

REDIS_HOST="127.0.0.1"
REDIS_PORT="6379"

echo "Redis健康检查 - $(date)"
echo "================================"

# 检查Redis是否运行
if ! redis-cli -h $REDIS_HOST -p $REDIS_PORT ping > /dev/null 2>&1; then
    echo "❌ Redis服务未响应"
    exit 1
fi

echo "✅ Redis服务正常响应"

# 检查内存使用
MEMORY_USED=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory | grep used_memory_human | cut -d: -f2 | tr -d '\r')
echo "📊 内存使用: $MEMORY_USED"

# 检查连接数
CLIENTS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO clients | grep connected_clients | cut -d: -f2 | tr -d '\r')
echo "🔗 当前连接数: $CLIENTS"

# 检查慢查询
SLOW_QUERIES=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT SLOWLOG LEN)
if [ $SLOW_QUERIES -gt 0 ]; then
    echo "⚠️  发现 $SLOW_QUERIES 条慢查询"
else
    echo "✅ 无慢查询"
fi

echo "================================"
```

</details>

### 4.3 告警设置建议


**🚨 告警阈值配置**
```
紧急告警：
🔥 内存使用 > 90%
🔥 连接数 > maxclients的90%  
🔥 响应时间 > 100ms
🔥 服务不可用

警告告警：
⚠️ 内存使用 > 80%
⚠️ 连接数 > maxclients的70%
⚠️ 慢查询数 > 10条/分钟
⚠️ QPS下降 > 50%
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的监控命令


```
🔸 INFO命令：全面了解Redis状态的万能工具
🔸 MONITOR命令：实时监控Redis操作，调试利器
🔸 redis-benchmark：性能测试，了解Redis极限
🔸 CLIENT LIST：查看连接详情，排查连接问题
🔸 SLOWLOG：慢查询分析，性能优化的关键
```

### 5.2 关键理解要点


**🔹 为什么需要监控Redis**
```
Redis作为内存数据库：
- 性能敏感：微小变化都可能影响应用
- 资源有限：内存和连接数都有上限
- 故障影响大：Redis故障会影响整个应用
- 预防胜于治疗：提前发现问题比事后处理重要
```

**🔹 监控的核心思路**
```
三个维度：
性能维度 → 响应是否够快
资源维度 → 内存连接是否充足  
稳定维度 → 服务是否持续可用

四个层次：
实时监控 → 发现当前问题
趋势分析 → 预测未来问题
告警机制 → 及时通知异常
自动处理 → 简单问题自动修复
```

**🔹 排错的系统方法**
```
排错步骤：
1️⃣ 现象确认：什么问题，什么时候发生
2️⃣ 信息收集：INFO、日志、系统状态
3️⃣ 原因分析：结合监控数据分析根因
4️⃣ 解决验证：实施解决方案并验证效果
5️⃣ 预防改进：制定预防措施避免再次发生
```

### 5.3 实际应用指导


**💻 日常运维建议**
```
日常监控：
📅 每日检查：内存、连接数、慢查询
📊 性能基线：定期benchmark，建立性能基准
📈 趋势分析：观察关键指标的变化趋势
🔔 告警设置：关键指标超阈值及时通知

应急处理：
🚨 服务不可用：检查进程、网络、配置
🐌 响应变慢：查看慢查询、内存使用、持久化状态
💾 内存告警：启用淘汰策略或清理数据
🔗 连接数过多：排查连接泄露，优化应用

性能优化：
⚡ 命令优化：避免大键操作，使用批量命令
🏗️ 架构优化：读写分离、分片、缓存分层
⚙️ 配置优化：持久化策略、内存淘汰策略
📊 容量规划：根据监控数据规划资源
```

### 5.4 监控工具选择


| 工具类型 | **适用场景** | **优势** | **不足** |
|---------|-------------|----------|----------|
| `INFO命令` | `基础监控` | `内置，无依赖` | `需要手动执行` |
| `redis-benchmark` | `性能测试` | `官方工具，标准` | `只能测试不能持续监控` |
| `Redis监控脚本` | `自动化监控` | `定制化强` | `需要开发维护` |
| `第三方监控` | `企业级监控` | `功能丰富，可视化好` | `需要额外成本` |

**核心记忆要点**：
- 监控Redis就像体检，INFO命令是全面检查，MONITOR是实时观察
- 性能测试要模拟真实场景，不能只看理论数值
- 排错要系统化：从现象到原因，从临时到根本
- 预防胜于治疗：建立完善的监控比事后排错更重要