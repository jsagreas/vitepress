---
title: 2、执行策略详解
---
## 📚 目录

1. [执行策略概述](#1-执行策略概述)
2. [Linear线性策略](#2-Linear线性策略)
3. [Free自由策略](#3-Free自由策略)
4. [Serial串行执行](#4-Serial串行执行)
5. [企业级部署模式](#5-企业级部署模式)
6. [故障处理与回滚](#6-故障处理与回滚)
7. [健康检查与流量控制](#7-健康检查与流量控制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 执行策略概述


### 1.1 什么是执行策略


**执行策略**就是Ansible决定如何在多台服务器上执行任务的规则。想象一下你要给100台服务器安装软件，你可以选择：
- 一台一台按顺序来（串行）
- 所有服务器同时开始（并行）
- 分成小组，每组内同时执行（批量）

> 💡 **通俗理解**
> 
> 执行策略就像工厂流水线的管理方式：
> - **传统流水线**：每道工序必须等前一道完成（linear）
> - **灵活车间**：工人可以自由安排工作进度（free）
> - **分批生产**：把大订单分成小批次处理（serial）

### 1.2 为什么需要执行策略


**核心价值**：
- ⚡ **性能控制**：避免同时操作太多服务器造成系统压力
- 🛡️ **风险管控**：分批执行可以及时发现问题并止损
- 🔄 **资源管理**：合理分配网络带宽和系统资源
- 📊 **监控友好**：便于观察执行进度和定位问题

**实际场景举例**：
```
场景1：数据库升级
- 不能同时停止所有数据库服务器
- 需要一台一台升级，确保服务不中断

场景2：应用发布  
- 可以同时发布到多台Web服务器
- 但要控制并发数量，避免网络拥堵

场景3：配置文件更新
- 配置错误影响不大，可以全部同时执行
- 提高效率，快速完成任务
```

### 1.3 策略类型概览


| 策略类型 | **执行方式** | **适用场景** | **风险等级** |
|---------|-------------|-------------|-------------|
| 🔄 **Linear** | `等待所有主机完成当前任务` | `配置管理、文件同步` | `低风险` |
| 🚀 **Free** | `各主机独立执行，不等待` | `软件安装、数据采集` | `中风险` |
| 📊 **Serial** | `分批执行，可控制批次大小` | `服务升级、滚动部署` | `低风险` |

---

## 2. 📋 Linear线性策略


### 2.1 Linear策略原理


**核心机制**：所有主机**同步执行**每个任务，等待最慢的主机完成后，才进入下一个任务。

```
执行流程图示：

主机A: [任务1] -----> [等待] -> [任务2] -----> [等待] -> [任务3]
主机B: [任务1] ---------> [等待] -> [任务2] -> [等待] -----> [任务3]  
主机C: [任务1] -> [等待] -----> [任务2] ---------> [等待] -> [任务3]

特点：木桶效应，最慢的主机决定整体进度
```

> 💡 **生活类比**
> 
> 就像学校做广播体操，所有学生必须跟着节拍一起做：
> - 第一节动作：等所有人做完才能开始第二节
> - 动作慢的同学会拖慢整个班级的进度
> - 但能保证所有人动作整齐划一

### 2.2 Linear策略配置


**基础配置**：
```yaml
# playbook中设置（默认策略，可以不写）
- hosts: webservers
  strategy: linear
  tasks:
    - name: 安装nginx
      yum:
        name: nginx
        state: present
    
    - name: 启动nginx服务
      service:
        name: nginx
        state: started
```

**全局配置**：
```ini
# ansible.cfg文件中设置
[defaults]
strategy = linear
```

### 2.3 Linear策略特点


**✅ 优势**：
- **状态一致**：所有主机执行进度完全同步
- **依赖安全**：任务间有依赖关系时很安全
- **便于调试**：容易跟踪执行状态和定位问题
- **资源可控**：不会因为某些主机执行快而占用过多资源

**❌ 劣势**：
- **效率受限**：最慢主机拖累整体进度
- **资源浪费**：快速主机需要等待慢速主机
- **扩展性差**：主机数量增加时，等待时间成倍增长

### 2.4 Linear策略适用场景


**🎯 最佳适用场景**：

①️⃣ **配置文件同步**
```yaml
- name: 同步配置文件
  copy:
    src: app.conf
    dest: /etc/app/app.conf
  notify: restart app

- name: 重启应用服务  
  service:
    name: app
    state: restarted
```
*需要确保所有服务器配置一致后再重启*

②️⃣ **数据库初始化**
```yaml
- name: 创建数据库
  mysql_db:
    name: myapp
    state: present
    
- name: 导入初始数据
  mysql_db:
    name: myapp
    state: import
    target: /tmp/init.sql
```
*必须等所有节点都创建好数据库才能导入数据*

③️⃣ **集群操作**
```yaml
- name: 停止集群服务
  service:
    name: cluster-service
    state: stopped
    
- name: 更新集群配置
  template:
    src: cluster.conf.j2
    dest: /etc/cluster.conf
    
- name: 启动集群服务
  service:
    name: cluster-service  
    state: started
```
*集群操作需要所有节点状态保持同步*

---

## 3. 🚀 Free自由策略


### 3.1 Free策略原理


**核心机制**：每台主机**独立执行**任务，不等待其他主机，各自按最快速度完成所有任务。

```
执行流程图示：

主机A: [任务1] -> [任务2] -> [任务3] ————————————> 完成
主机B: [任务1] ——————> [任务2] ————————> [任务3] -> 完成  
主机C: [任务1] -> [任务2] ——————————————> [任务3] -> 完成

特点：各主机独立运行，性能强的主机先完成
```

> 💡 **生活类比**
> 
> 就像马拉松比赛，每个选手按自己的节奏跑：
> - 跑得快的先到终点，不用等别人
> - 每个人发挥自己的最佳水平
> - 但无法保证所有人同时完成比赛

### 3.2 Free策略配置


**基础配置**：
```yaml
- hosts: webservers
  strategy: free
  tasks:
    - name: 下载软件包
      get_url:
        url: http://example.com/app.rpm
        dest: /tmp/app.rpm
    
    - name: 安装软件包
      yum:
        name: /tmp/app.rpm
        state: present
        
    - name: 启动服务
      service:
        name: app
        state: started
```

### 3.3 Free策略特点


**✅ 优势**：
- **效率最高**：充分发挥每台主机的性能
- **并行度高**：所有主机同时工作，总体时间最短
- **资源利用好**：快速主机不会空等
- **适合大规模**：主机数量多时优势明显

**❌ 劣势**：
- **状态不一致**：不同主机可能处于不同的执行阶段
- **依赖关系复杂**：任务间有依赖时可能出现问题
- **难以调试**：并发执行时问题定位困难
- **资源竞争**：可能造成网络或存储资源争抢

### 3.4 Free策略适用场景


**🎯 最佳适用场景**：

①️⃣ **软件包安装**
```yaml
- name: 安装基础软件包
  yum:
    name: 
      - vim
      - git
      - htop
      - curl
    state: present
```
*各主机独立安装，不需要等待其他主机*

②️⃣ **日志收集**
```yaml
- name: 收集系统日志
  fetch:
    src: /var/log/messages
    dest: /tmp/logs/{{ inventory_hostname }}/
    
- name: 收集应用日志  
  fetch:
    src: /var/log/app.log
    dest: /tmp/logs/{{ inventory_hostname }}/
```
*每台主机独立收集日志，互不影响*

③️⃣ **系统监控数据采集**
```yaml
- name: 采集CPU使用率
  shell: top -bn1 | grep "Cpu(s)" > /tmp/cpu.txt
  
- name: 采集内存使用情况
  shell: free -h > /tmp/memory.txt
  
- name: 采集磁盘使用情况
  shell: df -h > /tmp/disk.txt
```
*数据采集任务相互独立，可以并发执行*

---

## 4. 📊 Serial串行执行


### 4.1 Serial策略原理


**核心机制**：将主机分成**若干批次**，每批内部使用linear策略，批次间串行执行。

```
执行流程图示：

批次1（2台主机）：
主机A: [任务1] -> [等待B] -> [任务2] -> [等待B] -> [任务3]
主机B: [任务1] --------> [任务2] ---------> [任务3]

批次1完成后，开始批次2（2台主机）：
主机C: [任务1] -> [等待D] -> [任务2] -> [等待D] -> [任务3]  
主机D: [任务1] --------> [任务2] ---------> [任务3]

特点：分批控制，兼顾效率和风险控制
```

> 💡 **生活类比**
> 
> 就像餐厅分批接待客人：
> - 第一批客人点菜→上菜→用餐→离开
> - 确认第一批没问题后，再接待第二批
> - 既能控制厨房压力，又能及时发现问题

### 4.2 Serial策略配置


**数字指定批次大小**：
```yaml
- hosts: webservers
  serial: 2  # 每批2台主机
  tasks:
    - name: 停止服务
      service:
        name: nginx
        state: stopped
        
    - name: 更新配置
      copy:
        src: nginx.conf
        dest: /etc/nginx/nginx.conf
        
    - name: 启动服务
      service:
        name: nginx
        state: started
```

**百分比指定批次大小**：
```yaml
- hosts: webservers
  serial: "25%"  # 每批处理25%的主机
  tasks:
    - name: 滚动更新应用
      # 更新任务...
```

**混合模式**：
```yaml
- hosts: webservers
  serial:
    - 1      # 第一批：1台主机（金丝雀）
    - 25%    # 第二批：25%的主机
    - 100%   # 第三批：剩余所有主机
  tasks:
    - name: 部署新版本应用
      # 部署任务...
```

### 4.3 Serial策略特点


**✅ 优势**：
- **风险可控**：分批执行，问题影响范围有限
- **灵活配置**：可以精确控制批次大小和执行节奏
- **便于监控**：可以观察每批的执行结果
- **支持金丝雀**：第一批可以作为测试批次

**❌ 劣势**：
- **总体时间长**：相比free策略执行时间更长
- **资源利用率低**：部分时间只有少数主机在工作
- **配置复杂**：需要合理规划批次大小

### 4.4 Serial策略适用场景


**🎯 最佳适用场景**：

①️⃣ **Web服务滚动更新**
```yaml
- hosts: webservers
  serial: 2
  tasks:
    - name: 从负载均衡器移除
      uri:
        url: "http://lb.example.com/remove/{{ inventory_hostname }}"
        method: POST
        
    - name: 停止Web服务
      service:
        name: httpd
        state: stopped
        
    - name: 更新应用代码
      git:
        repo: https://github.com/company/webapp.git
        dest: /var/www/html
        version: v2.0
        
    - name: 启动Web服务
      service:
        name: httpd
        state: started
        
    - name: 健康检查
      uri:
        url: "http://{{ inventory_hostname }}/health"
        status_code: 200
      retries: 5
      delay: 10
      
    - name: 加入负载均衡器
      uri:
        url: "http://lb.example.com/add/{{ inventory_hostname }}"
        method: POST
```

②️⃣ **数据库集群升级**
```yaml
- hosts: mysql_cluster  
  serial: 1  # 一台一台升级
  tasks:
    - name: 停止从库同步
      mysql_replication:
        mode: stopslave
      when: mysql_role == 'slave'
      
    - name: 升级MySQL版本
      yum:
        name: mysql-server
        state: latest
        
    - name: 启动MySQL服务
      service:
        name: mysqld
        state: started
        
    - name: 恢复从库同步
      mysql_replication:
        mode: startslave
      when: mysql_role == 'slave'
```

---

## 5. 🏭 企业级部署模式


### 5.1 滚动更新模式


**什么是滚动更新**：
逐步替换旧版本应用，确保服务不中断的部署方式。

**核心原理**：
```
传统部署：停止所有服务 -> 更新 -> 启动所有服务 (服务中断)
滚动更新：分批更新，每批更新时其他服务器继续提供服务 (无中断)

负载均衡器视角：
时刻T1: 服务器[A, B, C, D] 都在提供服务
时刻T2: 更新A,B -> 服务器[C, D] 继续提供服务  
时刻T3: 更新C,D -> 服务器[A, B] 已更新完成继续服务
时刻T4: 所有服务器都更新完成
```

**滚动更新配置示例**：
```yaml
- hosts: webservers
  serial: "25%"  # 每次更新25%的服务器
  max_fail_percentage: 10  # 容忍10%的失败率
  tasks:
    - name: 检查当前版本
      shell: cat /opt/app/VERSION
      register: current_version
      
    - name: 从负载均衡移除当前服务器
      uri:
        url: "http://{{ load_balancer }}/api/remove"
        method: POST
        body_format: json
        body:
          server: "{{ inventory_hostname }}"
      delegate_to: localhost
      
    - name: 等待连接断开
      wait_for:
        port: 8080
        host: "{{ inventory_hostname }}"
        state: drained
        delay: 30
        
    - name: 备份当前版本
      archive:
        path: /opt/app
        dest: "/backup/app-{{ current_version.stdout }}-{{ ansible_date_time.epoch }}.tar.gz"
        
    - name: 部署新版本
      unarchive:
        src: "files/app-v{{ new_version }}.tar.gz"
        dest: /opt/app
        owner: app
        group: app
        
    - name: 更新版本标记
      copy:
        content: "{{ new_version }}"
        dest: /opt/app/VERSION
        
    - name: 重启应用服务
      systemd:
        name: app
        state: restarted
        daemon_reload: yes
        
    - name: 健康检查
      uri:
        url: "http://{{ inventory_hostname }}:8080/health"
        method: GET
        status_code: 200
      retries: 10
      delay: 15
      register: health_check
      
    - name: 添加到负载均衡
      uri:
        url: "http://{{ load_balancer }}/api/add"
        method: POST
        body_format: json
        body:
          server: "{{ inventory_hostname }}"
      delegate_to: localhost
      when: health_check is succeeded
```

### 5.2 蓝绿部署模式


**什么是蓝绿部署**：
维护两套完全相同的生产环境（蓝环境和绿环境），通过切换流量实现无停机部署。

```
蓝绿部署示意图：

部署前状态：
负载均衡器 -> 蓝环境(当前生产) [App v1.0]
               绿环境(待机)     [空闲]

部署中状态：  
负载均衡器 -> 蓝环境(当前生产) [App v1.0]  用户流量
               绿环境(更新中)   [App v2.0] ← 部署新版本

部署完成切换：
负载均衡器 -> 绿环境(新生产)   [App v2.0]  用户流量
               蓝环境(待机)     [App v1.0] ← 保留用于回滚
```

**蓝绿部署配置示例**：
```yaml
- hosts: green_env
  vars:
    app_version: "{{ new_version }}"
    environment_color: "green"
  tasks:
    - name: 部署到绿环境
      include_tasks: deploy_app.yml
      
    - name: 绿环境健康检查
      uri:
        url: "http://{{ inventory_hostname }}:8080/health"
        status_code: 200
      retries: 20
      delay: 10

- hosts: localhost
  tasks:
    - name: 切换流量到绿环境
      uri:
        url: "http://{{ load_balancer }}/api/switch"
        method: POST
        body_format: json
        body:
          target_env: "green"
          
    - name: 验证流量切换成功
      uri:
        url: "http://{{ public_url }}/api/version"
        return_content: yes
      register: version_check
      failed_when: version_check.content != new_version
      
    - name: 保留蓝环境用于快速回滚
      debug:
        msg: "蓝环境保留，如需回滚执行: ansible-playbook rollback-to-blue.yml"
```

### 5.3 金丝雀发布模式


**什么是金丝雀发布**：
先让少量用户使用新版本，确认无问题后逐步扩大范围，最终全量发布。

> 💡 **名称来源**
> 
> 矿工下井前会带金丝雀检测有毒气体，金丝雀比人类敏感，如果金丝雀没事，说明环境安全。
> 金丝雀发布也是这个道理：先让少数用户"试毒"，确保新版本安全。

**金丝雀发布配置示例**：
```yaml
# 第一阶段：金丝雀发布（5%流量）
- hosts: canary_servers
  serial: 1
  vars:
    traffic_percentage: 5
  tasks:
    - name: 部署金丝雀版本
      include_tasks: deploy_app.yml
      
    - name: 配置5%流量到金丝雀
      template:
        src: nginx_canary.conf.j2
        dest: /etc/nginx/conf.d/canary.conf
      notify: reload nginx
      
    - name: 监控金丝雀指标
      uri:
        url: "http://monitoring.example.com/api/metrics"
        method: POST
        body_format: json
        body:
          environment: "canary"
          version: "{{ app_version }}"
          
- hosts: localhost
  tasks:        
    - name: 等待金丝雀运行30分钟
      pause:
        minutes: 30
        prompt: "金丝雀版本运行中，监控关键指标..."
        
    - name: 检查错误率
      uri:
        url: "http://monitoring.example.com/api/error_rate"
        return_content: yes
      register: error_rate
      failed_when: error_rate.json.rate > 0.01  # 错误率超过1%则失败

# 第二阶段：扩大发布范围（25%流量）  
- hosts: webservers
  serial: "25%"
  tasks:
    - name: 扩大到25%服务器
      include_tasks: deploy_app.yml
      when: canary_success is defined and canary_success
```

---

## 6. 🛠️ 故障处理与回滚


### 6.1 故障检测机制


**健康检查配置**：
```yaml
tasks:
  - name: 应用健康检查
    uri:
      url: "http://{{ inventory_hostname }}:8080/actuator/health"
      method: GET
      status_code: 200
      timeout: 10
    register: health_result
    retries: 5
    delay: 30
    
  - name: 检查关键业务功能
    uri:
      url: "http://{{ inventory_hostname }}:8080/api/test"
      method: POST
      body_format: json
      body:
        test_case: "critical_function"
    register: business_test
    
  - name: 验证数据库连接
    shell: |
      mysql -h{{ db_host }} -u{{ db_user }} -p{{ db_password }} \
      -e "SELECT 1" {{ db_name }}
    register: db_check
    failed_when: db_check.rc != 0
```

**失败处理策略**：
```yaml
- hosts: webservers
  serial: 3
  max_fail_percentage: 20  # 允许20%的主机失败
  any_errors_fatal: false  # 不因个别主机失败而停止整个playbook
  
  tasks:
    - name: 部署应用
      include_tasks: deploy.yml
      
    - name: 健康检查
      include_tasks: health_check.yml
      
  rescue:
    - name: 回滚失败的主机
      include_tasks: rollback.yml
      when: deployment_failed is defined
      
  always:
    - name: 记录部署日志
      lineinfile:
        path: /var/log/deployment.log
        line: "{{ ansible_date_time.iso8601 }} - {{ inventory_hostname }} - {{ deployment_result | default('unknown') }}"
```

### 6.2 自动回滚机制


**检测到故障时自动回滚**：
```yaml
- name: 检查部署结果
  block:
    - name: 验证新版本功能
      uri:
        url: "http://{{ inventory_hostname }}/api/version"
        return_content: yes
      register: version_check
      
    - name: 检查错误率
      shell: |
        curl -s "http://monitoring/api/error_rate?host={{ inventory_hostname }}&minutes=5" | \
        jq '.error_rate'
      register: error_rate_check
      delegate_to: localhost
      
    - name: 判断是否需要回滚
      set_fact:
        need_rollback: true
      when: 
        - version_check.content != expected_version or 
          error_rate_check.stdout | float > 0.05
          
  rescue:
    - name: 执行回滚操作
      block:
        - name: 从负载均衡移除问题服务器
          uri:
            url: "http://{{ load_balancer }}/remove/{{ inventory_hostname }}"
            method: POST
            
        - name: 恢复备份版本
          unarchive:
            src: "{{ backup_path }}/app-previous.tar.gz"
            dest: /opt/app
            owner: app
            group: app
            
        - name: 重启服务
          systemd:
            name: app
            state: restarted
            
        - name: 验证回滚成功
          uri:
            url: "http://{{ inventory_hostname }}/health"
            status_code: 200
          retries: 5
          delay: 10
          
        - name: 重新加入负载均衡
          uri:
            url: "http://{{ load_balancer }}/add/{{ inventory_hostname }}"
            method: POST
            
      always:
        - name: 记录回滚日志
          mail:
            to: ops-team@company.com
            subject: "自动回滚通知: {{ inventory_hostname }}"
            body: |
              服务器 {{ inventory_hostname }} 部署失败，已自动回滚到上一版本。
              
              失败原因：
              - 版本验证: {{ version_check.content | default('N/A') }}
              - 错误率: {{ error_rate_check.stdout | default('N/A') }}%
              
              请检查日志并分析原因。
```

### 6.3 手动回滚流程


**快速回滚playbook**：
```yaml
# rollback.yml
---
- hosts: "{{ target_hosts | default('webservers') }}"
  serial: "{{ rollback_batch_size | default('50%') }}"
  vars:
    rollback_version: "{{ rollback_to | default('previous') }}"
    
  tasks:
    - name: 确认回滚操作
      pause:
        prompt: |
          即将回滚以下主机到版本 {{ rollback_version }}:
          {{ ansible_play_hosts | join(', ') }}
          
          确认继续？按Enter继续，Ctrl+C取消
          
    - name: 获取当前版本信息
      slurp:
        src: /opt/app/VERSION
      register: current_version
      
    - name: 检查回滚目标版本
      stat:
        path: "/backup/app-{{ rollback_version }}.tar.gz"
      register: backup_exists
      failed_when: not backup_exists.stat.exists
      
    - name: 创建回滚前快照
      archive:
        path: /opt/app
        dest: "/backup/pre-rollback-{{ ansible_date_time.epoch }}.tar.gz"
        
    - name: 从负载均衡移除
      uri:
        url: "http://{{ load_balancer }}/api/remove"
        method: POST
        body_format: json
        body:
          server: "{{ inventory_hostname }}"
          reason: "rollback operation"
      delegate_to: localhost
      
    - name: 停止应用服务
      systemd:
        name: app
        state: stopped
        
    - name: 清理当前版本
      file:
        path: /opt/app
        state: absent
        
    - name: 恢复目标版本
      unarchive:
        src: "/backup/app-{{ rollback_version }}.tar.gz"
        dest: /opt/app
        owner: app
        group: app
        
    - name: 启动应用服务
      systemd:
        name: app
        state: started
        daemon_reload: yes
        
    - name: 等待服务就绪
      wait_for:
        port: 8080
        host: "{{ inventory_hostname }}"
        delay: 10
        timeout: 300
        
    - name: 健康检查
      uri:
        url: "http://{{ inventory_hostname }}:8080/health"
        status_code: 200
      retries: 10
      delay: 5
      
    - name: 重新加入负载均衡
      uri:
        url: "http://{{ load_balancer }}/api/add"
        method: POST
        body_format: json
        body:
          server: "{{ inventory_hostname }}"
      delegate_to: localhost
      
    - name: 记录回滚日志
      lineinfile:
        path: /var/log/deployment.log
        create: yes
        line: |
          {{ ansible_date_time.iso8601 }} - ROLLBACK - {{ inventory_hostname }} - 
          FROM: {{ current_version.content | b64decode | trim }} - 
          TO: {{ rollback_version }} - 
          SUCCESS
```

**使用方式**：
```bash
# 回滚所有Web服务器到上一版本
ansible-playbook rollback.yml

# 回滚特定服务器到指定版本  
ansible-playbook rollback.yml -e "target_hosts=web01,web02" -e "rollback_to=v1.2.3"

# 小批量回滚测试
ansible-playbook rollback.yml -e "rollback_batch_size=1"
```

---

## 7. 💊 健康检查与流量控制


### 7.1 多层级健康检查


**应用层健康检查**：
```yaml
- name: 应用服务状态检查
  systemd:
    name: "{{ app_service }}"
  register: service_status
  
- name: HTTP接口健康检查
  uri:
    url: "http://{{ inventory_hostname }}:{{ app_port }}/health"
    method: GET
    status_code: 
      - 200
      - 201
    timeout: 15
    headers:
      User-Agent: "Ansible-Health-Check/1.0"
  register: http_health
  retries: 10
  delay: 5
  
- name: 深度业务功能检查
  uri:
    url: "http://{{ inventory_hostname }}:{{ app_port }}/api/deep-check"
    method: POST
    body_format: json
    body:
      check_database: true
      check_cache: true  
      check_external_api: true
    status_code: 200
    timeout: 30
  register: deep_check
```

**数据库连接检查**：
```yaml
- name: 数据库连接测试
  shell: |
    timeout 10 mysql -h{{ db_host }} -P{{ db_port }} \
    -u{{ db_user }} -p{{ db_password }} \
    -e "SELECT 1 as test, NOW() as timestamp;" {{ db_name }}
  register: db_health
  changed_when: false
  failed_when: 
    - db_health.rc != 0
    - "'test' not in db_health.stdout"
    
- name: Redis缓存检查  
  shell: |
    timeout 5 redis-cli -h {{ redis_host }} -p {{ redis_port }} \
    {% if redis_password %}-a {{ redis_password }}{% endif %} \
    ping
  register: redis_health
  changed_when: false
  failed_when: redis_health.stdout != "PONG"
```

**系统资源检查**：
```yaml
- name: CPU使用率检查
  shell: |
    top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//'
  register: cpu_usage
  failed_when: cpu_usage.stdout | float > 90
  
- name: 内存使用率检查
  shell: |
    free | grep Mem | awk '{printf "%.2f", $3/$2 * 100.0}'
  register: memory_usage  
  failed_when: memory_usage.stdout | float > 85
  
- name: 磁盘空间检查
  shell: |
    df {{ app_data_path }} | tail -1 | awk '{print $5}' | sed 's/%//'
  register: disk_usage
  failed_when: disk_usage.stdout | int > 90
```

### 7.2 智能流量控制


**负载均衡器集成**：
```yaml
- name: 负载均衡器操作模块
  vars:
    lb_api_base: "http://{{ load_balancer_host }}:8080/api/v1"
    
  tasks:
    - name: 从负载均衡移除服务器
      uri:
        url: "{{ lb_api_base }}/servers/{{ inventory_hostname }}/disable"
        method: PUT
        headers:
          Authorization: "Bearer {{ lb_api_token }}"
          Content-Type: "application/json"
        body_format: json
        body:
          reason: "maintenance"
          drain_timeout: 30
        status_code: [200, 202]
      delegate_to: localhost
      
    - name: 等待现有连接断开
      uri:
        url: "{{ lb_api_base }}/servers/{{ inventory_hostname }}/connections"
        headers:
          Authorization: "Bearer {{ lb_api_token }}"
        return_content: yes
      register: connection_check
      until: connection_check.json.active_connections == 0
      retries: 20
      delay: 15
      delegate_to: localhost
      
    - name: 验证流量已转移
      uri:
        url: "{{ lb_api_base }}/servers/{{ inventory_hostname }}/stats"
        headers:
          Authorization: "Bearer {{ lb_api_token }}"
        return_content: yes
      register: traffic_stats
      delegate_to: localhost
      failed_when: traffic_stats.json.requests_per_second > 0
```

**渐进式流量恢复**：
```yaml
- name: 渐进式加入负载均衡
  vars:
    traffic_stages: [10, 25, 50, 100]  # 流量百分比阶段
    
  tasks:
    - name: 启用服务器但限制流量
      uri:
        url: "{{ lb_api_base }}/servers/{{ inventory_hostname }}/enable"
        method: PUT
        headers:
          Authorization: "Bearer {{ lb_api_token }}"
        body_format: json
        body:
          weight: "{{ item }}"
          max_weight: 100
        status_code: 200
      loop: "{{ traffic_stages }}"
      delegate_to: localhost
      
    - name: 监控每个流量阶段
      block:
        - name: 等待流量稳定
          pause:
            seconds: 60
            
        - name: 检查错误率
          uri:
            url: "{{ monitoring_api }}/error-rate"
            method: POST
            body_format: json
            body:
              server: "{{ inventory_hostname }}"
              time_window: "5m"
            return_content: yes
          register: error_rate
          delegate_to: localhost
          
        - name: 验证响应时间
          uri:
            url: "{{ monitoring_api }}/response-time"
            method: POST  
            body_format: json
            body:
              server: "{{ inventory_hostname }}"
              time_window: "5m"
            return_content: yes
          register: response_time
          delegate_to: localhost
          
        - name: 检查指标是否正常
          fail:
            msg: |
              服务器指标异常:
              错误率: {{ error_rate.json.error_rate }}% (阈值: 1%)
              响应时间: {{ response_time.json.avg_response_time }}ms (阈值: 500ms)
          when: 
            - error_rate.json.error_rate | float > 1.0 or
              response_time.json.avg_response_time | int > 500
              
      loop: "{{ traffic_stages }}"
```

### 7.3 监控集成与告警


**Prometheus指标收集**：
```yaml
- name: 配置应用指标导出
  template:
    src: prometheus_config.yml.j2
    dest: /etc/prometheus/targets/{{ inventory_hostname }}.yml
  delegate_to: "{{ prometheus_server }}"
  notify: reload prometheus
  
- name: 设置部署监控
  uri:
    url: "{{ prometheus_pushgateway }}/metrics/job/ansible_deployment/instance/{{ inventory_hostname }}"
    method: POST
    headers:
      Content-Type: "text/plain"
    body: |
      deployment_start_timestamp {{ ansible_date_time.epoch }}
      deployment_version{version="{{ app_version }}"} 1
      deployment_strategy{strategy="{{ ansible_strategy | default('linear') }}"} 1
  delegate_to: localhost
```

**自定义监控检查**：
```yaml
- name: 自定义业务指标检查
  block:
    - name: 检查订单处理能力
      uri:
        url: "http://{{ inventory_hostname }}/metrics/orders"
        return_content: yes
      register: order_metrics
      
    - name: 检查支付接口可用性
      uri:
        url: "http://{{ inventory_hostname }}/api/payment/health"
        timeout: 10
      register: payment_health
      
    - name: 验证关键业务流程
      shell: |
        curl -X POST "http://{{ inventory_hostname }}/api/test/complete-flow" \
        -H "Content-Type: application/json" \
        -d '{"test_user_id": "ansible_test"}' \
        --max-time 30
      register: business_flow_test
      
    - name: 汇总健康状态
      set_fact:
        health_summary:
          order_processing: "{{ 'OK' if order_metrics.json.orders_per_minute > 0 else 'FAIL' }}"
          payment_service: "{{ 'OK' if payment_health.status == 200 else 'FAIL' }}"
          business_flow: "{{ 'OK' if business_flow_test.rc == 0 else 'FAIL' }}"
          overall_status: "{{ 'HEALTHY' if (order_metrics.json.orders_per_minute > 0 and payment_health.status == 200 and business_flow_test.rc == 0) else 'UNHEALTHY' }}"
          
    - name: 发送健康检查结果
      uri:
        url: "{{ webhook_url }}/deployment-health"
        method: POST
        body_format: json
        body:
          server: "{{ inventory_hostname }}"
          timestamp: "{{ ansible_date_time.iso8601 }}"
          health_summary: "{{ health_summary }}"
      delegate_to: localhost
  
  rescue:
    - name: 健康检查失败处理
      mail:
        to: "{{ ops_email }}"
        subject: "健康检查失败: {{ inventory_hostname }}"
        body: |
          服务器 {{ inventory_hostname }} 健康检查失败
          
          检查项目状态:
          - 订单处理: {{ health_summary.order_processing | default('UNKNOWN') }}
          - 支付服务: {{ health_summary.payment_service | default('UNKNOWN') }}  
          - 业务流程: {{ health_summary.business_flow | default('UNKNOWN') }}
          
          请立即检查服务状态！
      delegate_to: localhost
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 执行策略本质：控制Ansible如何在多台主机上执行任务的规则
🔸 Linear策略：所有主机同步执行，等待最慢的完成
🔸 Free策略：各主机独立执行，充分发挥并发性能  
🔸 Serial策略：分批执行，兼顾效率和风险控制
🔸 企业部署模式：滚动更新、蓝绿部署、金丝雀发布
🔸 故障处理：自动检测、智能回滚、完整日志记录
🔸 健康检查：多层级验证，确保服务质量
🔸 流量控制：渐进式恢复，降低部署风险
```

### 8.2 策略选择决策表


| 场景类型 | **推荐策略** | **批次设置** | **关键配置** |
|---------|-------------|-------------|-------------|
| 🔧 **配置管理** | `Linear` | `不适用` | `任务间依赖强` |
| 📦 **软件安装** | `Free` | `不适用` | `并发度最高` |
| 🔄 **滚动更新** | `Serial` | `25%-50%` | `health_check + 负载均衡` |
| 🚀 **蓝绿部署** | `Linear` | `按环境分组` | `流量切换机制` |
| 🐤 **金丝雀发布** | `Serial` | `[1, 25%, 100%]` | `监控指标阈值` |
| 💾 **数据库操作** | `Serial: 1` | `一台一台` | `主从复制检查` |

### 8.3 实践要点记忆


**🔹 策略选择原则**
```
安全第一：数据库、核心服务 → Serial策略
效率优先：日常运维、批量操作 → Free策略  
平衡考虑：应用部署、配置更新 → Linear策略
```

**🔹 企业级部署关键点**
```
滚动更新：无中断 + 分批执行 + 健康检查
蓝绿部署：双环境 + 流量切换 + 快速回滚
金丝雀：小范围 → 监控验证 → 逐步扩大
```

**🔹 故障处理最佳实践**
```
预防：多层健康检查 + 合理的失败阈值
检测：实时监控 + 自动告警机制
恢复：自动回滚 + 手动介入能力
记录：完整日志 + 问题分析报告
```

### 8.4 实际应用价值


- **🎯 生产环境部署**：确保服务稳定性和业务连续性
- **⚡ 运维效率提升**：自动化批量操作，减少人工干预
- **🛡️ 风险管控**：分批执行和自动回滚降低故障影响
- **📊 监控可视化**：健康检查和指标收集提供决策依据
- **🔄 持续交付**：支撑DevOps流程，实现快速迭代

**核心记忆口诀**：
- 策略选择看场景，安全效率要平衡
- 分批执行控风险，健康检查保质量  
- 故障回滚要自动，监控告警不能少
- 企业部署重实践，流量控制是关键