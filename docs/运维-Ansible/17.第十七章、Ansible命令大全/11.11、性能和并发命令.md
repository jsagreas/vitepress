---
title: 11、性能和并发命令
---
## 📚 目录

1. [并发控制基础概念](#1-并发控制基础概念)
2. [进程级并发控制](#2-进程级并发控制)
3. [异步执行控制](#3-异步执行控制)
4. [批次执行策略](#4-批次执行策略)
5. [执行策略配置](#5-执行策略配置)
6. [Facts收集优化](#6-Facts收集优化)
7. [性能优化实践](#7-性能优化实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 并发控制基础概念


### 1.1 什么是Ansible并发


> 📖 **核心概念**  
> Ansible并发是指同时对多个目标主机执行任务的能力，通过合理配置并发参数，可以显著提升任务执行效率

**🧠 生活类比**：
```
单线程执行 = 一个人逐个给朋友打电话
并发执行 = 多个客服同时给不同客户打电话
异步执行 = 发短信后不等回复，继续发下一条
```

### 1.2 并发控制的核心要素


**🎯 关键维度**：
- **进程数量**：同时运行多少个进程
- **并发主机**：同时处理多少台主机
- **执行策略**：串行还是并行执行
- **资源限制**：避免系统资源耗尽

```
Ansible控制节点
    ├── 进程1 ──> 主机A, B, C
    ├── 进程2 ──> 主机D, E, F  
    ├── 进程3 ──> 主机G, H, I
    └── 进程4 ──> 主机J, K, L
```

### 1.3 并发的优势与风险


| 优势 | 风险 | 解决方案 |
|------|------|----------|
| **⚡ 执行速度快** | `📊 资源消耗大` | 合理设置forks数量 |
| **📈 效率提升明显** | `🔄 网络压力增大` | 使用throttle限制 |
| **⏱️ 节省运维时间** | `❌ 错误排查困难` | 配置适当日志级别 |

---

## 2. 🔧 进程级并发控制


### 2.1 -f 指定并发数


**🔸 基本语法**：
```bash
ansible all -f 数量 -m 模块名
```

**💡 实际应用**：
```bash
# 默认并发：5个进程
ansible webservers -m ping

# 指定10个并发进程
ansible webservers -f 10 -m ping

# 高并发部署：20个进程同时执行
ansible all -f 20 -m yum -a "name=nginx state=present"
```

**📊 性能对比**：
```
100台服务器安装软件包：
- -f 5  (默认)：耗时 10分钟
- -f 20 (优化)：耗时 3分钟  
- -f 50 (激进)：耗时 2分钟，但可能网络拥堵
```

### 2.2 --forks 设置进程数


> 💡 **重要说明**  
> `--forks` 和 `-f` 是同一个参数的不同写法，`-f` 是简化版本

**🎯 配置建议**：
```bash
# 小规模环境（< 20台）
ansible all --forks 5 -m setup

# 中等规模环境（20-100台）
ansible all --forks 15 -m copy -a "src=/tmp/file dest=/tmp/"

# 大规模环境（> 100台）
ansible all --forks 30 -m service -a "name=nginx state=restarted"
```

**⚠️ 注意事项**：
- 🔴 **过小**：浪费资源，执行缓慢
- 🔴 **过大**：可能导致网络拥堵或控制节点资源不足
- 🟢 **合适**：通常设置为目标主机数量的 10-30%

---

## 3. ⏰ 异步执行控制


### 3.1 异步执行的原理


**🔍 技术类比**：
```
同步执行：打电话 - 必须等对方接听完成
异步执行：发邮件 - 发送后可以继续做其他事情
```

异步执行流程：
```
控制节点                     目标主机
    |                           |
    |--[启动任务]--------------->|
    |<--[返回Job ID]-------------|  
    |                           |[后台执行]
    |--[轮询状态]--------------->|
    |<--[执行进度]---------------|
    |                           |
    |--[获取结果]--------------->|
    |<--[最终结果]---------------|
```

### 3.2 --background 异步执行时间


**🔸 基本用法**：
```bash
# 异步执行，最长等待300秒
ansible webservers -B 300 -P 10 -m yum -a "name=mysql-server state=present"
```

**参数解释**：
- **`-B 300`**：后台执行最长时间（秒）
- **`-P 10`**：轮询间隔10秒检查一次状态
- **`-P 0`**：启动后立即返回，不等待结果

**🎯 典型应用场景**：
```bash
# 场景1：长时间安装软件
ansible dbservers -B 600 -P 30 -m yum -a "name=postgresql state=present"

# 场景2：启动后不等待结果
ansible all -B 3600 -P 0 -m script -a "long_running_backup.sh"

# 场景3：系统更新（可能需要重启）
ansible all -B 1800 -P 60 -m yum -a "name=* state=latest"
```

### 3.3 --poll 设置轮询间隔


**💭 理解要点**：
- **轮询间隔越短**：状态更新越及时，但网络开销越大
- **轮询间隔越长**：网络开销小，但状态感知延迟

**📋 推荐配置**：
```bash
# 快速任务：频繁检查
ansible web -B 120 -P 5 -m service -a "name=nginx state=restarted"

# 普通任务：中等间隔
ansible all -B 300 -P 15 -m copy -a "src=/tmp/large_file dest=/opt/"

# 长期任务：较长间隔
ansible db -B 1800 -P 60 -m script -a "database_migration.sh"
```

---

## 4. 🎛️ 批次执行策略


### 4.1 --serial 串行执行批次


> 📖 **概念解释**  
> serial参数控制每次处理多少台主机，实现滚动更新，避免服务全部中断

**🧠 生活类比**：
```
不使用serial：所有服务器同时重启 = 网站完全瘫痪
使用serial：分批重启 = 始终有部分服务器在线提供服务
```

**基本用法示例**：
```bash
# 每次处理2台主机
ansible webservers -m service -a "name=nginx state=restarted" --serial 2

# 按百分比处理：每次处理20%的主机
ansible all -m yum -a "name=kernel state=latest" --serial "20%"

# 混合策略：先处理1台测试，再批量处理
ansible production -m script -a "update.sh" --serial "1,25%"
```

**🎯 实际应用场景**：

**场景1：Web服务器滚动重启**
```bash
# 10台Web服务器，每次重启2台，保证服务可用性
ansible webservers -m service -a "name=apache2 state=restarted" --serial 2
```

**场景2：数据库集群升级**
```bash
# 先升级1台主节点测试，再批量升级从节点
ansible mysql_cluster -m script -a "mysql_upgrade.sh" --serial "1,3"
```

### 4.2 serial的不同配置方式


| 配置方式 | 示例 | 含义 | 适用场景 |
|---------|------|------|----------|
| **固定数量** | `--serial 3` | 每批处理3台主机 | `小规模，精确控制` |
| **百分比** | `--serial "25%"` | 每批处理25%的主机 | `大规模，比例控制` |
| **混合模式** | `--serial "1,50%"` | 先1台，后50%批处理 | `测试后批量部署` |
| **递增模式** | `--serial "1,3,5"` | 逐步增加批次大小 | `谨慎的灰度发布` |

---

## 5. 🔄 执行策略配置


### 5.1 strategy 策略插件选择


**🎯 Ansible执行策略类型**：

```
┌─────────────────────────────────┐
│          Ansible策略            │
├─────────────────────────────────┤
│  Linear策略（默认）             │
│  ├── 所有主机同步执行每个任务    │
│  └── 等最慢主机完成再进行下一步  │
├─────────────────────────────────┤
│  Free策略                       │
│  ├── 主机独立执行任务队列        │
│  └── 不等待其他主机完成          │
└─────────────────────────────────┘
```

### 5.2 linear 策略配置（默认）


**🔸 特点说明**：
- ✅ **同步执行**：所有主机同时执行相同任务
- ✅ **顺序保证**：严格按task顺序执行
- ❌ **等待最慢**：被最慢主机拖累整体进度

**playbook配置示例**：
```yaml
- hosts: webservers
  strategy: linear
  tasks:
    - name: 停止服务
      service: name=nginx state=stopped
    
    - name: 更新配置  
      template: src=nginx.conf dest=/etc/nginx/nginx.conf
    
    - name: 启动服务
      service: name=nginx state=started
```

**⏱️ 执行时序**：
```
主机A: 任务1 ──> 任务2 ──> 任务3
主机B: 任务1 ──> 任务2 ──> 任务3  
主机C: 任务1 ──> 任务2 ──> 任务3
       ↑        ↑        ↑
    所有完成  所有完成  所有完成
```

### 5.3 free 策略配置


**🔸 特点说明**：
- ✅ **独立执行**：主机按自己节奏执行
- ✅ **效率更高**：快的主机不等慢的
- ❌ **顺序难控**：不保证所有主机同步

**playbook配置示例**：
```yaml
- hosts: webservers  
  strategy: free
  tasks:
    - name: 安装软件包
      yum: name=nginx state=present
    
    - name: 启动服务
      service: name=nginx state=started
```

**⏱️ 执行时序**：
```
主机A: 任务1 ──> 任务2 ──> 任务3 ──> 完成
主机B: 任务1 ────────> 任务2 ──> 任务3 ──> 完成
主机C: 任务1 ──> 任务2 ────────────> 任务3 ──> 完成
       独立执行，互不等待
```

### 5.4 策略选择指导


| 场景类型 | 推荐策略 | 原因 |
|---------|---------|------|
| **服务部署** | `Linear` | 需要保证所有节点同步上线 |
| **配置分发** | `Linear` | 确保配置一致性 |
| **软件安装** | `Free` | 安装速度优先，不需要同步 |
| **日志收集** | `Free` | 各主机独立处理即可 |
| **滚动更新** | `Linear + Serial` | 既要同步又要分批 |

---

## 6. 📊 Facts收集优化


### 6.1 gather_facts 控制fact收集


**🧠 理解Facts收集**：
> Facts就像是给每台服务器做"体检"，收集系统信息（CPU、内存、磁盘、网络等）

**Facts收集的开销**：
```
100台服务器收集Facts：
- 开启Facts收集：额外耗时 2-3分钟
- 关闭Facts收集：节省时间，但无法使用系统变量
```

### 6.2 Facts收集控制示例


**在playbook中控制**：
```yaml
# 关闭Facts收集（提升速度）
- hosts: webservers
  gather_facts: no
  tasks:
    - name: 安装nginx（不需要系统信息）
      yum: name=nginx state=present

# 开启Facts收集（需要系统信息）  
- hosts: dbservers
  gather_facts: yes
  tasks:
    - name: 根据内存大小配置MySQL
      template: 
        src: my.cnf.j2 
        dest: /etc/mysql/my.cnf
      when: ansible_memtotal_mb > 4096
```

**命令行控制**：
```bash
# 显式关闭facts收集
ansible-playbook deploy.yml --skip-tags=always --extra-vars="gather_facts=no"

# 只收集特定facts
ansible all -m setup -a "filter=ansible_distribution*"
```

### 6.3 fact_caching 开启fact缓存


**🔍 缓存机制说明**：
```
无缓存：每次都重新收集Facts（慢）
有缓存：首次收集后缓存，后续直接使用（快）
```

**配置缓存示例**：

**ansible.cfg配置**：
```ini
[defaults]
# 开启facts缓存
fact_caching = jsonfile
fact_caching_connection = /tmp/ansible_facts_cache
fact_caching_timeout = 3600  # 缓存1小时

# 或使用redis缓存
fact_caching = redis
fact_caching_connection = localhost:6379:0
```

**🎯 缓存效果**：
```
首次执行：收集Facts + 执行任务 = 180秒
后续执行：读取缓存 + 执行任务 = 30秒
节省时间：约83%
```

---

## 7. ⚖️ 性能优化实践


### 7.1 --throttle 限制任务并发


**🔸 应用场景**：
- 🎯 **数据库操作**：避免连接数过多
- 🎯 **文件传输**：防止网络带宽耗尽  
- 🎯 **资源密集任务**：避免目标主机过载

**实际应用示例**：
```yaml
- hosts: dbservers
  tasks:
    # 限制同时只有3台服务器执行数据库备份
    - name: 数据库备份
      script: backup_database.sh
      throttle: 3
    
    # 大文件传输限制并发
    - name: 传输大文件
      copy: 
        src: /tmp/large_app.tar.gz 
        dest: /opt/
      throttle: 2
```

### 7.2 综合性能优化配置


**🚀 高性能playbook示例**：
```yaml
- hosts: production
  strategy: free              # 使用free策略提升并发
  gather_facts: no            # 关闭facts收集节省时间
  serial: "20%"              # 分批执行保证稳定性
  
  tasks:
    - name: 快速安装软件包
      yum: 
        name: "{{ packages }}"
        state: present
      throttle: 10             # 限制并发避免仓库过载
      
    - name: 重启服务（分批进行）
      service: 
        name: "{{ item }}"
        state: restarted
      loop: "{{ services }}"
      serial: 5                # 服务重启更加谨慎
```

### 7.3 性能调优检查清单


📋 **优化检查清单**：
- [ ] **合理设置forks数量**（目标主机的10-30%）
- [ ] **选择合适的执行策略**（linear vs free）
- [ ] **关闭不必要的facts收集**
- [ ] **启用facts缓存**（减少重复收集）
- [ ] **使用serial进行滚动更新**
- [ ] **用throttle限制资源密集任务**
- [ ] **优化网络连接**（SSH连接复用）

### 7.4 常见性能问题与解决


| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|----------|
| **执行缓慢** | `forks数量过小` | 增加-f参数值 |
| **网络拥堵** | `并发过高` | 使用throttle限制 |
| **内存不足** | `facts收集过多` | 关闭gather_facts |
| **服务中断** | `同时重启所有服务` | 使用serial分批执行 |
| **连接超时** | `SSH连接过多` | 开启SSH连接复用 |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心命令


```bash
🔸 基础并发控制
ansible all -f 20                    # 设置20个并发进程
ansible all --forks 15               # 同上，完整写法

🔸 异步执行控制  
ansible all -B 300 -P 10             # 异步300秒，每10秒轮询
ansible all -B 600 -P 0              # 异步执行不等待结果

🔸 批次执行控制
ansible all --serial 2               # 每次处理2台主机
ansible all --serial "25%"           # 每次处理25%主机
```

### 8.2 关键配置参数理解


**🔹 并发参数含义**：
- **`-f/--forks`**：控制进程数量，影响整体并发能力
- **`-B/--background`**：异步执行超时时间
- **`-P/--poll`**：异步轮询检查间隔
- **`--serial`**：批次执行大小，实现滚动更新
- **`--throttle`**：单任务并发限制

**🔹 策略选择原则**：
- **Linear策略**：需要同步执行，保证一致性
- **Free策略**：追求执行效率，允许异步进行
- **Facts收集**：根据是否需要系统信息决定开关

### 8.3 性能优化最佳实践


🎯 **核心优化原则**：
1. **合理并发**：forks = 目标主机数 × 0.1-0.3
2. **分批处理**：重要服务使用serial避免全部中断
3. **异步长任务**：超过1分钟的任务考虑异步执行
4. **缓存facts**：重复执行的playbook开启缓存
5. **限制资源密集任务**：使用throttle避免过载

🧠 **记忆口诀**：
```
并发要适中，异步处长任务
分批保稳定，缓存提效率  
策略选对路，限流防过载
```

### 8.4 实际应用建议


**📊 不同规模环境建议**：
- **小环境(< 20台)**：forks=5-8，可不用serial
- **中环境(20-100台)**：forks=15-25，重要操作使用serial  
- **大环境(> 100台)**：forks=30-50，必须使用serial和throttle

**⚠️ 重要提醒**：
- 性能优化要渐进式调整，避免一次性改动过大
- 生产环境变更前务必在测试环境验证
- 监控系统资源使用情况，防止过度优化导致系统不稳定