---
title: 4、playbook执行命令
---
## 📚 目录

1. [Ansible Playbook基础概念](#1-ansible-playbook基础概念)
2. [基本执行命令](#2-基本执行命令)  
3. [主机控制参数](#3-主机控制参数)
4. [任务执行控制](#4-任务执行控制)
5. [调试和验证命令](#5-调试和验证命令)
6. [高级执行选项](#6-高级执行选项)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 Ansible Playbook基础概念


### 1.1 什么是Ansible Playbook


**📖 通俗理解**：
```
如果把Ansible比作一个指挥家：
- ansible命令 = 单独指挥一个乐手
- ansible-playbook = 指挥整个交响乐团演奏完整乐章

实际含义：
Playbook就是一个"剧本"，里面写好了要在哪些服务器上
按照什么顺序执行哪些操作，就像演戏要按剧本来一样
```

**🔑 核心特点**：
- **批量操作**：同时管理多台服务器
- **顺序执行**：按照预定义的步骤依次进行
- **可重复**：同一个playbook可以多次执行
- **声明式**：只需要描述想要的结果，不用管具体怎么实现

### 1.2 Playbook文件结构


**📋 基本结构图**：
```
playbook.yml
├── 主机组定义 (hosts)
├── 变量设置 (vars)  
├── 任务列表 (tasks)
│   ├── 任务1 (task)
│   ├── 任务2 (task)
│   └── 任务3 (task)
└── 处理器 (handlers)
```

**💡 简单示例**：
```yaml
# 部署网站的playbook示例
- name: 部署Web应用
  hosts: webservers
  tasks:
    - name: 安装Nginx
      yum: name=nginx state=present
    
    - name: 启动Nginx服务  
      service: name=nginx state=started
```

---

## 2. ⚡ 基本执行命令


### 2.1 最基础的执行方式


**🚀 核心命令**：
```bash
ansible-playbook playbook.yml
```

**🔸 这个命令做了什么**：
1. **读取playbook文件**：解析YAML格式的剧本
2. **连接目标主机**：根据hosts配置连接服务器
3. **按顺序执行任务**：逐个执行tasks中定义的操作
4. **返回执行结果**：显示每个任务的成功/失败状态

**💼 实际应用场景**：
> 📱 **日常运维**：每天晚上定时执行备份脚本
> 🖥️ **应用部署**：发布新版本到生产环境
> 🏢 **批量配置**：给100台服务器统一安装软件

### 2.2 指定清单文件执行


**🔧 命令格式**：
```bash
ansible-playbook -i inventory_file playbook.yml
```

**📖 通俗解释**：
```
-i 参数就像是"花名册"，告诉ansible要管理哪些服务器

没有-i参数：使用默认的/etc/ansible/hosts文件
有-i参数：使用你指定的清单文件

就像老师点名需要花名册一样，ansible也需要知道
要对哪些服务器"点名"执行任务
```

**🎯 实用示例**：
```bash
# 使用生产环境的服务器清单
ansible-playbook -i production_hosts deploy.yml

# 使用测试环境的服务器清单  
ansible-playbook -i test_hosts deploy.yml

# 使用动态清单（从云平台获取）
ansible-playbook -i aws_ec2.yml deploy.yml
```

---

## 3. 🎯 主机控制参数


### 3.1 限制执行主机


**🔧 --limit 参数详解**：

**基本用法**：
```bash
ansible-playbook --limit "目标主机" playbook.yml
```

**💡 通俗理解**：
```
假设你的playbook原本要在100台服务器上执行，
但现在只想在其中5台上试试效果，
--limit就像是"临时缩小范围"的开关

原本：对所有webservers执行
加limit：只对指定的几台执行
```

**🎯 多种限制方式**：

| **限制方式** | **命令示例** | **含义说明** |
|------------|-------------|-------------|
| 🔸 **单台主机** | `--limit "web1"` | 只在web1服务器上执行 |
| 🔸 **多台主机** | `--limit "web1,web2,web3"` | 在三台指定服务器上执行 |
| 🔸 **主机组** | `--limit "webservers"` | 只在webservers组内执行 |
| 🔸 **通配符** | `--limit "web*"` | 所有以web开头的主机 |
| 🔸 **排除主机** | `--limit "webservers:!web3"` | webservers组除了web3 |

**📚 实际应用场景**：
```bash
# 场景1：生产环境谨慎发布，先在一台上测试
ansible-playbook --limit "prod-web-01" deploy.yml

# 场景2：某些服务器有问题，临时跳过
ansible-playbook --limit "webservers:!web-broken" update.yml

# 场景3：按地区分批部署
ansible-playbook --limit "beijing-*" deploy.yml
```

---

## 4. ⚙️ 任务执行控制


### 4.1 标签控制执行


**🏷️ --tags 标签执行**：

**📖 标签是什么**：
```
标签就像是给任务贴"便签纸"，方便分类执行

比如一个部署playbook包含：
- 下载代码 (标签：download)  
- 安装依赖 (标签：install)
- 配置服务 (标签：config)
- 启动服务 (标签：start)

有了标签，你可以只执行其中某几个步骤
```

**🔧 标签使用语法**：
```bash
# 只执行带有指定标签的任务
ansible-playbook --tags "install,config" deploy.yml

# 跳过指定标签的任务  
ansible-playbook --skip-tags "download" deploy.yml
```

**💡 playbook中定义标签**：
```yaml
tasks:
  - name: 下载应用代码
    git: repo=https://github.com/app.git dest=/opt/app
    tags: download
    
  - name: 安装Python依赖
    pip: requirements=/opt/app/requirements.txt  
    tags: install
    
  - name: 配置应用
    template: src=config.j2 dest=/opt/app/config.py
    tags: config
```

**🎯 实际应用**：

| **使用场景** | **命令示例** | **业务含义** |
|------------|-------------|-------------|
| 🔸 **只更新配置** | `--tags "config"` | 代码不变，只改配置文件 |
| 🔸 **跳过下载** | `--skip-tags "download"` | 代码已存在，不用重新下载 |
| 🔸 **只重启服务** | `--tags "restart"` | 快速重启，不做其他操作 |

### 4.2 从指定任务开始执行


**🔧 --start-at-task 参数**：

**💡 应用场景**：
```
假设playbook有10个任务，前面7个都已经成功了，
第8个任务出错了，修复后不想从头开始执行，
就可以从第8个任务继续执行
```

**📝 使用方法**：
```bash
# 从"配置Nginx"这个任务开始执行
ansible-playbook --start-at-task="配置Nginx" deploy.yml
```

**⚠️ 注意事项**：
- 任务名称必须完全匹配
- 跳过的任务可能导致依赖问题
- 适合调试和故障恢复场景

### 4.3 逐步执行模式


**🔧 --step 交互式执行**：

**📖 通俗理解**：
```
--step就像是"单步调试"，每执行一个任务前都会问你：
"要执行这个任务吗？(y/n/c)"

y = yes，执行这个任务
n = no，跳过这个任务  
c = continue，后面的任务都执行，不再询问
```

**🎯 使用场景**：
- **调试playbook**：逐个任务验证效果
- **生产环境谨慎操作**：重要任务前再次确认
- **学习ansible**：观察每个任务的具体作用

---

## 5. 🔍 调试和验证命令


### 5.1 检查模式（Dry Run）


**🔧 --check 检查模式**：

**💡 核心理解**：
```
--check就像是"演练"，只模拟执行但不真正改变系统

就像军事演习一样：
- 所有流程都走一遍
- 发现可能的问题  
- 但不会真的开火

特别适合在生产环境执行前先"预演"一遍
```

**📊 检查结果解读**：
```bash
ansible-playbook --check deploy.yml

# 输出示例：
TASK [安装Nginx] *************************
changed: [web1]  ← 这表示如果真正执行，会安装Nginx
ok: [web2]       ← 这表示web2已经安装了Nginx，不会改变

PLAY RECAP ********************************  
web1: ok=3 changed=2 unreachable=0 failed=0
web2: ok=3 changed=1 unreachable=0 failed=0
```

### 5.2 显示文件差异


**🔧 --diff 差异对比**：

**📖 作用说明**：
```
--diff会显示文件修改前后的差异，就像git diff一样

特别适合：
- 修改配置文件时，看具体改了什么
- 确认模板渲染的结果是否正确
- 追踪系统配置的变更历史
```

**🎯 实际效果展示**：
```bash
ansible-playbook --diff --check nginx.yml

# 会显示类似这样的差异：
--- before: /etc/nginx/nginx.conf
+++ after: /etc/nginx/nginx.conf  
$$ -1,4 +1,5 $$
 user nginx;
 worker_processes auto;
+client_max_body_size 50m;
 
 events {
```

### 5.3 语法检查


**🔧 --syntax-check 语法验证**：

**💡 使用时机**：
```
在执行playbook之前，先检查YAML语法是否正确

就像写代码前先检查语法错误一样，
避免因为缩进、拼写等低级错误浪费时间
```

**📝 检查示例**：
```bash
ansible-playbook --syntax-check deploy.yml

# 语法正确时输出：
playbook: deploy.yml

# 语法错误时输出：  
ERROR! Syntax Error while loading YAML.
mapping values are not allowed here
```

### 5.4 任务和标签列表


**📋 列出所有任务**：
```bash
# 查看playbook包含哪些任务
ansible-playbook --list-tasks deploy.yml

# 输出示例：
play #1 (webservers): 部署Web应用 TAGS: []
  tasks:
    安装Nginx TAGS: [install]
    配置Nginx TAGS: [config]  
    启动Nginx TAGS: [start]
```

**🏷️ 列出所有标签**：
```bash
# 查看playbook定义了哪些标签
ansible-playbook --list-tags deploy.yml

# 输出示例：  
play #1 (webservers): 部署Web应用 TAGS: []
  TASK TAGS: [config, install, start]
```

---

## 6. 🚀 高级执行选项


### 6.1 并发控制


**⚙️ 控制并发数量**：
```bash
# 限制同时执行的主机数量（默认是5）
ansible-playbook --forks 10 deploy.yml
```

**📊 性能考虑**：
```
并发数设置原则：
🔸 网络较好：可以设置较高值(10-20)
🔸 网络一般：保持默认值(5)  
🔸 资源有限：设置较小值(2-3)

过高的并发可能导致：
- 网络拥塞
- 目标主机负载过高
- 控制节点资源不足
```

### 6.2 连接和认证选项


**🔐 常用连接参数**：
```bash
# 指定SSH用户
ansible-playbook -u root deploy.yml

# 指定SSH密钥文件
ansible-playbook --private-key ~/.ssh/prod_key deploy.yml

# 提示输入sudo密码
ansible-playbook --ask-become-pass deploy.yml
```

### 6.3 变量传递


**📤 传递额外变量**：
```bash
# 通过命令行传递变量
ansible-playbook -e "app_version=2.1.0" deploy.yml

# 传递多个变量
ansible-playbook -e "app_version=2.1.0 env=production" deploy.yml

# 从文件读取变量
ansible-playbook -e "@vars.yml" deploy.yml
```

---

## 7. 💼 实际应用场景


### 7.1 日常运维场景


**🔄 场景1：应用更新部署**：
```bash
# 完整部署流程
ansible-playbook -i production deploy.yml

# 出现问题后，只更新配置
ansible-playbook -i production --tags "config" deploy.yml

# 验证部署效果，不实际执行
ansible-playbook -i production --check --diff deploy.yml
```

**🛠️ 场景2：故障排查**：
```bash
# 逐步执行，每一步都确认
ansible-playbook --step troubleshoot.yml

# 只在出问题的服务器上执行
ansible-playbook --limit "web-server-03" fix.yml

# 从失败的任务重新开始
ansible-playbook --start-at-task="重启服务" fix.yml
```

### 7.2 开发测试场景


**🧪 场景3：测试环境管理**：
```bash
# 语法检查，避免低级错误
ansible-playbook --syntax-check test-deploy.yml

# 在测试环境预演
ansible-playbook -i test_hosts --check test-deploy.yml

# 确认无误后实际执行
ansible-playbook -i test_hosts test-deploy.yml
```

### 7.3 生产环境场景


**🏭 场景4：生产环境发布**：
```bash
# 第一步：语法检查
ansible-playbook --syntax-check prod-deploy.yml

# 第二步：在生产环境预演  
ansible-playbook -i prod_hosts --check --diff prod-deploy.yml

# 第三步：分批发布，先发布一台
ansible-playbook -i prod_hosts --limit "prod-web-01" prod-deploy.yml

# 第四步：确认无问题后，发布其余服务器
ansible-playbook -i prod_hosts --limit "prod-web-*:!prod-web-01" prod-deploy.yml
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 ansible-playbook：批量自动化执行工具，像指挥交响乐团
🔸 -i 参数：指定服务器清单，告诉ansible管理哪些服务器  
🔸 --limit：临时限制执行范围，灵活控制目标主机
🔸 --tags/--skip-tags：按标签控制执行，实现精细化操作
🔸 --check：预演模式，不实际修改系统但能发现问题
🔸 --diff：显示文件差异，清楚看到具体修改内容
```

### 8.2 关键理解要点


**🔹 执行控制的核心思想**：
```
灵活性：
- 不是非要执行整个playbook
- 可以只执行需要的部分
- 可以在指定的服务器上执行

安全性：  
- 执行前可以预演检查
- 可以逐步执行确认每个步骤
- 语法检查避免低级错误

效率性：
- 标签控制避免重复执行
- 并发执行提升速度
- 从指定任务开始节省时间
```

**🔹 调试和验证的重要性**：
```
开发阶段：
- 语法检查发现YAML格式问题
- 列出任务和标签了解playbook结构

测试阶段：  
- --check模式预演发现逻辑问题
- --diff查看具体修改内容
- --step模式逐个验证任务效果

生产阶段：
- --limit先在小范围验证
- 分批执行降低风险
- 详细日志便于追踪问题
```

### 8.3 实际应用价值


**🎯 提升运维效率**：
- **批量操作**：一次管理成百上千台服务器
- **标准化**：统一的操作流程和配置
- **可重复**：相同操作可以反复执行

**🔧 降低操作风险**：
- **预演功能**：生产执行前先模拟
- **精细控制**：可以控制执行范围和步骤
- **回滚能力**：出问题可以快速恢复

**📊 便于管理维护**：
- **版本管理**：playbook可以用Git管理
- **文档化**：代码即文档，操作过程清晰可见
- **团队协作**：标准化的自动化脚本便于团队使用

**核心记忆口诀**：
- ansible-playbook管批量，-i指定服务器花名册
- --limit缩小范围，--tags精细控制不出错  
- --check预演很重要，--diff差异看得清
- 语法检查别忘了，逐步执行更安全