---
title: 10、输出和日志命令
---
## 📚 目录

1. [Ansible输出概述](#1-ansible输出概述)
2. [详细输出控制](#2-详细输出控制)
3. [输出格式控制](#3-输出格式控制)
4. [日志管理配置](#4-日志管理配置)
5. [输出回调插件](#5-输出回调插件)
6. [颜色输出控制](#6-颜色输出控制)
7. [结构化输出](#7-结构化输出)
8. [实用输出技巧](#8-实用输出技巧)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🖥️ Ansible输出概述


### 1.1 什么是Ansible输出

**简单理解**：Ansible输出就是你运行命令后在屏幕上看到的所有信息。就像你和朋友聊天时，不仅要听到对方说话内容，还要看表情、语调一样，Ansible的输出也包含了执行结果、状态信息、错误提示等多种信息。

```
Ansible输出的本质：
┌─────────────────┐
│   你的命令      │ ← ansible-playbook site.yml
├─────────────────┤
│   Ansible处理   │ ← 连接主机、执行任务
├─────────────────┤
│   输出反馈      │ ← 成功/失败/变更状态
└─────────────────┘
```

### 1.2 输出信息的类型


**🔍 主要输出类型**：
- **执行状态**：任务是否成功、失败、跳过
- **变更信息**：哪些配置被修改了
- **错误详情**：出错时的具体原因
- **调试信息**：详细的执行过程
- **统计摘要**：最终的执行统计

**💡 生活类比**：
> 就像你叫外卖时的信息反馈：
> - 订单确认 (任务开始)
> - 商家接单 (连接成功) 
> - 制作中... (执行过程)
> - 配送中... (传输数据)
> - 已送达 (任务完成)

### 1.3 为什么需要控制输出


**🎯 控制输出的意义**：
- **调试需要**：出错时需要详细信息定位问题
- **日常使用**：正常使用时不需要太多干扰信息
- **自动化集成**：脚本调用时需要结构化数据
- **日志存档**：长期保存执行记录用于审计

---

## 2. 🔍 详细输出控制


### 2.1 verbose详细输出级别


**基本概念**：verbose就是"详细"的意思，用来控制输出信息的详细程度。就像调节音响的音量一样，可以调节信息输出的"音量"。

**📊 详细级别对比表**：

| 级别 | 参数 | **信息量** | **适用场景** | **输出内容** |
|------|------|-----------|-------------|-------------|
| 🔹 **默认** | `无参数` | `基础` | `日常使用` | `任务名称 + 结果状态` |
| 🔹 **一级** | `-v` | `适中` | `轻度调试` | `+ 任务执行详情` |
| 🔹 **二级** | `-vv` | `详细` | `深度调试` | `+ 模块参数信息` |
| 🔹 **三级** | `-vvv` | `非常详细` | `网络诊断` | `+ SSH连接过程` |
| 🔹 **四级** | `-vvvv` | `极详细` | `底层调试` | `+ 所有内部调用` |

### 2.2 详细输出实战示例


**🚀 基础使用**：
```bash
# 默认输出：只看结果
ansible web -m ping
# 输出：web1 | SUCCESS => {"ping": "pong"}

# 一级详细：了解过程
ansible web -m ping -v
# 额外显示：使用的SSH用户、连接方式等

# 二级详细：查看参数
ansible web -m ping -vv  
# 额外显示：模块的详细参数、返回值结构

# 三级详细：网络诊断
ansible web -m ping -vvv
# 额外显示：SSH连接建立过程、认证详情

# 四级详细：完整调试
ansible web -m ping -vvvv
# 额外显示：Python调用栈、内部函数执行
```

### 2.3 选择合适的详细级别


**🎯 使用指南**：
```
日常操作：
ansible-playbook site.yml        # 够用了

轻度问题排查：
ansible-playbook site.yml -v     # 看看任务细节

深度问题诊断：
ansible-playbook site.yml -vv    # 检查参数配置

网络连接问题：
ansible-playbook site.yml -vvv   # 诊断SSH连接

复杂bug调试：
ansible-playbook site.yml -vvvv  # 开发者级别调试
```

**⚠️ 注意事项**：
- 详细级别越高，输出信息越多，执行速度会稍微变慢
- 四级详细输出包含敏感信息，不要在生产环境随意使用
- 调试完成后记得去掉verbose参数

---

## 3. 📋 输出格式控制


### 3.1 单行输出模式


**什么是单行输出**：默认情况下，Ansible会用多行显示任务结果，单行模式就是把结果压缩到一行显示，适合快速查看或脚本处理。

**🔧 使用方法**：
```bash
# 默认多行输出
ansible web -m command -a "uptime"
# web1 | CHANGED | rc=0 >>
#  15:30:01 up 10 days,  5:43,  2 users,  load average: 0.00, 0.01, 0.05

# 单行输出模式
ansible web -m command -a "uptime" --one-line
# web1 | CHANGED | rc=0 | (stdout) 15:30:01 up 10 days, 5:43, 2 users, load average: 0.00, 0.01, 0.05
```

**💡 应用场景**：
- 查看多台主机的相同信息时更紧凑
- 脚本处理输出结果时更方便
- 终端屏幕空间有限时节省显示行数

### 3.2 目录树输出


**什么是目录树输出**：将每台主机的输出结果保存到单独的文件中，按目录结构组织。就像给每个人建一个专门的文件夹存放他们的信息。

**🌳 使用方法**：
```bash
# 输出到目录树
ansible web -m setup --tree /tmp/facts
# 会创建：
# /tmp/facts/
# ├── web1
# ├── web2  
# └── web3

# 每个文件包含对应主机的完整输出
cat /tmp/facts/web1
# 显示web1主机的所有系统信息
```

**🎯 实用价值**：
- **批量信息收集**：同时获取多台主机信息并分别存档
- **后期分析处理**：可以用脚本逐一处理每台主机的数据
- **报告生成**：为每台主机生成独立的配置报告

---

## 4. 📝 日志管理配置


### 4.1 日志路径配置


**为什么需要日志**：就像医生要记录病历一样，Ansible执行记录对于问题排查、审计合规、操作回顾都很重要。

**🔧 配置日志路径**：

**方法1：命令行指定**
```bash
# 临时指定日志文件
ansible-playbook site.yml --log-path /var/log/ansible.log

# 不同任务使用不同日志文件  
ansible-playbook deploy.yml --log-path /var/log/deploy-$(date +%Y%m%d).log
```

**方法2：配置文件设置**
```ini
# /etc/ansible/ansible.cfg 或 项目根目录的ansible.cfg
[defaults]
log_path = /var/log/ansible.log

# 支持时间戳的日志文件名
log_path = /var/log/ansible-%(date)s.log
```

### 4.2 日志轮转和管理


**🔄 日志轮转配置**：
```bash
# 创建logrotate配置
sudo tee /etc/logrotate.d/ansible << EOF
/var/log/ansible.log {
    weekly          # 每周轮转
    missingok      # 日志文件不存在时不报错
    rotate 12      # 保留12个历史文件
    compress       # 压缩历史文件
    delaycompress  # 延迟一个周期再压缩
    notifempty     # 空文件不轮转
    create 0644 root root  # 创建新日志文件的权限
}
EOF
```

**📊 日志分析示例**：
```bash
# 查看最近的错误
grep FAILED /var/log/ansible.log | tail -10

# 统计任务执行情况
grep -c "TASK\|PLAY" /var/log/ansible.log

# 查看特定主机的操作记录
grep "web1" /var/log/ansible.log
```

### 4.3 日志最佳实践


**🎯 日志管理建议**：

```
开发环境：
✅ 使用详细日志（-vv）便于调试
✅ 日志保存在项目目录下
✅ 可以频繁清理，保留最近几次执行记录

生产环境：
✅ 使用标准详细级别（-v或默认）
✅ 日志保存在系统目录（/var/log）
✅ 配置日志轮转，长期保存
✅ 权限控制，只有管理员可读写
✅ 考虑集中日志收集（ELK、Splunk等）
```

---

## 5. 🔌 输出回调插件


### 5.1 什么是回调插件


**简单理解**：回调插件就像是Ansible的"翻译官"，把原始的执行结果翻译成不同的格式或风格显示给你。就像同样一个故事，可以用小说、漫画、电影等不同方式来讲述。

**🎨 常用回调插件类型**：
- **默认回调**：标准的文本输出格式
- **JSON回调**：结构化数据格式
- **YAML回调**：YAML格式输出
- **精简回调**：简化版输出
- **定时回调**：显示任务执行时间

### 5.2 JSON格式输出


**配置JSON输出**：
```bash
# 方法1：环境变量
export ANSIBLE_STDOUT_CALLBACK=json
ansible-playbook site.yml

# 方法2：配置文件
# ansible.cfg
[defaults]
stdout_callback = json

# 方法3：命令行（Ansible 2.5+）
ansible-playbook site.yml -e 'stdout_callback=json'
```

**JSON输出示例对比**：
```
默认输出：
PLAY [web servers] *****************************
TASK [install nginx] ***************************  
web1 | CHANGED => {"changed": true, "msg": "installed nginx"}

JSON输出：
{
    "plays": [
        {
            "play": {"name": "web servers"},
            "tasks": [
                {
                    "task": {"name": "install nginx"},
                    "hosts": {
                        "web1": {
                            "changed": true,
                            "msg": "installed nginx"
                        }
                    }
                }
            ]
        }
    ]
}
```

### 5.3 YAML格式输出  


**YAML输出配置**：
```yaml
# ansible.cfg
[defaults]
stdout_callback = yaml

# 输出效果：
---
- play: web servers
  tasks:
    - task: install nginx
      hosts:
        web1:
          changed: true
          msg: "installed nginx"
```

### 5.4 自定义回调插件


**📝 创建简单回调插件**：
```python
# callback_plugins/custom_output.py
from ansible.plugins.callback import CallbackBase

class CallbackModule(CallbackBase):
    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = 'stdout'
    CALLBACK_NAME = 'custom_output'

    def v2_runner_on_ok(self, result):
        host = result._host.get_name()
        task = result._task.get_name()
        print(f"✅ {host}: {task} - 成功")

    def v2_runner_on_failed(self, result, ignore_errors=False):
        host = result._host.get_name()
        task = result._task.get_name()
        print(f"❌ {host}: {task} - 失败")
```

---

## 6. 🎨 颜色输出控制


### 6.1 颜色输出的作用


**为什么要有颜色**：颜色输出就像交通信号灯，让你一眼就能识别任务的执行状态。绿色表示成功，红色表示错误，黄色表示有变更，这样更直观易懂。

**🚦 Ansible颜色含义**：
```
🟢 绿色 (GREEN)：任务执行成功，无变更
🟡 黄色 (YELLOW)：任务执行成功，有变更  
🔴 红色 (RED)：任务执行失败
🟣 紫色 (PURPLE)：任务被跳过
🔵 蓝色 (BLUE)：任务正在执行中
```

### 6.2 颜色输出控制


**🔧 禁用颜色输出**：
```bash
# 临时禁用颜色
ansible-playbook site.yml --no-color

# 环境变量禁用
export ANSIBLE_FORCE_COLOR=false
ansible-playbook site.yml

# 配置文件禁用
# ansible.cfg
[defaults]
force_color = false
```

**⚡ 强制颜色输出**：
```bash
# 强制启用颜色（即使输出重定向到文件）
ansible-playbook site.yml --force-color

# 环境变量强制启用
export ANSIBLE_FORCE_COLOR=true

# 配置文件强制启用
[defaults]
force_color = true
```

### 6.3 颜色输出的使用场景


**🎯 使用指南**：
```
终端直接查看：
✅ 保持默认颜色设置，便于快速识别状态

输出到文件：
✅ 使用 --no-color，避免文件中包含颜色控制字符
ansible-playbook site.yml --no-color > deploy.log

脚本处理输出：
✅ 禁用颜色，便于文本解析
ansible-playbook site.yml --no-color | grep FAILED

邮件或报告：
✅ 禁用颜色，确保在不同系统中正常显示
```

**💡 实用技巧**：
```bash
# 同时保存有颜色和无颜色的日志
ansible-playbook site.yml --force-color | tee deploy-colored.log
ansible-playbook site.yml --no-color > deploy-plain.log

# 根据输出目标自动控制颜色
if [ -t 1 ]; then
    # 输出到终端，使用颜色
    ansible-playbook site.yml
else
    # 输出重定向，禁用颜色
    ansible-playbook site.yml --no-color
fi
```

---

## 7. 📊 结构化输出


### 7.1 结构化输出的重要性


**什么是结构化输出**：就像将杂乱的文件整理到不同的文件夹中，结构化输出将Ansible的执行结果按照统一的格式组织，方便程序自动处理和人工分析。

**🔍 结构化数据的优势**：
- **程序友好**：脚本可以轻松解析和处理
- **数据完整**：保留所有执行细节
- **格式统一**：不同任务输出格式一致
- **易于集成**：可以导入到其他系统

### 7.2 JSON输出详解


**完整JSON输出示例**：
```json
{
  "plays": [
    {
      "play": {
        "id": "0242ac11-0003-443a-b8c8-d10a3c3c1234",
        "name": "Configure web servers"
      },
      "tasks": [
        {
          "task": {
            "id": "0242ac11-0003-443a-b8c8-d10a3c3c5678", 
            "name": "Install nginx"
          },
          "hosts": {
            "web1": {
              "_ansible_result_id": "0242ac11-0003-443a-b8c8-d10a3c3c9012",
              "changed": true,
              "invocation": {
                "module_args": {
                  "name": "nginx",
                  "state": "present"
                }
              },
              "msg": "nginx installed successfully"
            }
          }
        }
      ]
    }
  ]
}
```

### 7.3 处理结构化输出


**🐍 Python脚本处理示例**：
```python
#!/usr/bin/env python3
import json
import subprocess

# 执行ansible命令并获取JSON输出
result = subprocess.run([
    'ansible-playbook', 'site.yml', 
    '-e', 'stdout_callback=json'
], capture_output=True, text=True)

# 解析JSON输出
data = json.loads(result.stdout)

# 统计执行结果
stats = {'changed': 0, 'ok': 0, 'failed': 0}

for play in data['plays']:
    for task in play['tasks']:
        for host, host_result in task['hosts'].items():
            if host_result.get('changed'):
                stats['changed'] += 1
            elif host_result.get('failed'):
                stats['failed'] += 1
            else:
                stats['ok'] += 1

print(f"执行统计: 成功 {stats['ok']}, 变更 {stats['changed']}, 失败 {stats['failed']}")
```

**🔧 Shell脚本处理示例**：
```bash
#!/bin/bash

# 执行ansible并将JSON输出保存到文件
ansible-playbook site.yml -e 'stdout_callback=json' > /tmp/ansible_result.json

# 使用jq工具分析结果
# 统计变更的任务数量
changed_count=$(cat /tmp/ansible_result.json | jq '[.plays[].tasks[].hosts[] | select(.changed == true)] | length')

# 提取失败的主机列表  
failed_hosts=$(cat /tmp/ansible_result.json | jq -r '[.plays[].tasks[].hosts | to_entries[] | select(.value.failed == true) | .key] | unique[]')

echo "变更任务数: $changed_count"
echo "失败主机: $failed_hosts"
```

---

## 8. 💡 实用输出技巧


### 8.1 组合使用技巧


**🎯 常用组合命令**：
```bash
# 详细输出 + 保存日志 + 无颜色
ansible-playbook site.yml -v --no-color --log-path /var/log/deploy.log

# JSON格式 + 保存到文件 + 错误时详细输出
ansible-playbook site.yml -e 'stdout_callback=json' -v > deploy.json 2>&1

# 单行输出 + 过滤特定状态
ansible all -m ping --one-line | grep -E "(SUCCESS|FAILED)"

# 目录树输出 + 后续处理
ansible all -m setup --tree /tmp/facts
find /tmp/facts -name "web*" -exec echo "主机: {}" \; -exec head -5 {} \;
```

### 8.2 输出过滤和处理


**🔍 实时过滤输出**：
```bash
# 只显示变更的任务
ansible-playbook site.yml | grep -A2 -B2 "CHANGED"

# 只显示失败的任务  
ansible-playbook site.yml | grep -A5 -B2 "FAILED"

# 统计各种状态的数量
ansible-playbook site.yml | grep -E "(ok|changed|failed|skipped)" | sort | uniq -c
```

### 8.3 调试技巧


**🐛 常用调试组合**：

**📋 调试检查清单**：
- [ ] **连接问题**：使用`-vvv`查看SSH详情
- [ ] **权限问题**：检查`become`相关输出
- [ ] **模块参数**：使用`-vv`查看传递的参数
- [ ] **变量问题**：在playbook中添加`debug`任务
- [ ] **网络问题**：检查连接超时和DNS解析

**🔧 分步调试流程**：
```bash
# 第1步：基本连通性测试
ansible target_host -m ping -vvv

# 第2步：检查变量渲染
ansible target_host -m debug -a "var=ansible_all_ipv4_addresses" -v

# 第3步：运行简单任务测试权限
ansible target_host -m command -a "whoami" -v

# 第4步：逐步增加复杂度
ansible-playbook simple_task.yml -v
ansible-playbook complete_playbook.yml -v
```

### 8.4 生产环境最佳实践


**🏢 生产环境输出配置**：
```ini
# 生产环境 ansible.cfg
[defaults]
# 适度的详细级别，平衡信息量和性能
verbosity = 1

# 启用日志记录
log_path = /var/log/ansible.log

# 使用结构化输出便于监控系统解析
stdout_callback = json

# 禁用颜色输出，确保日志纯净
force_color = false

[callback_profile_tasks]
# 启用任务执行时间统计
task_output_limit = 20
sort_order = descending
```

**📊 监控集成示例**：
```bash
#!/bin/bash
# 生产环境部署脚本

DEPLOY_LOG="/var/log/deploy-$(date +%Y%m%d-%H%M%S).log"

# 执行部署并记录详细日志
ansible-playbook deploy.yml \
    -v \
    --no-color \
    --log-path "$DEPLOY_LOG" \
    -e 'stdout_callback=json' \
    > "$DEPLOY_LOG.json" 2>&1

# 检查执行结果
if [ $? -eq 0 ]; then
    echo "✅ 部署成功！日志已保存到: $DEPLOY_LOG"
    
    # 发送成功通知到监控系统
    curl -X POST http://monitoring.company.com/webhook \
        -H "Content-Type: application/json" \
        -d '{"status": "success", "logfile": "'$DEPLOY_LOG'"}'
else
    echo "❌ 部署失败！请检查日志: $DEPLOY_LOG"
    
    # 发送失败警报
    curl -X POST http://monitoring.company.com/alert \
        -H "Content-Type: application/json" \
        -d '{"status": "failed", "logfile": "'$DEPLOY_LOG'", "priority": "high"}'
fi
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 verbose详细输出：调节信息详细程度的关键工具
🔸 输出格式控制：单行、目录树、JSON等不同展示方式  
🔸 日志管理：长期记录和审计的基础设施
🔸 回调插件：自定义输出格式的扩展机制
🔸 颜色控制：提高可读性和适应不同使用场景
🔸 结构化输出：便于自动化处理和集成的标准格式
```

### 9.2 关键理解要点


**🔹 verbose级别选择原则**：
```
日常使用：默认输出就够了
轻度调试：-v 看看任务执行情况
深度排错：-vv 检查模块参数和返回值  
网络问题：-vvv 诊断连接过程
复杂调试：-vvvv 查看所有内部调用
```

**🔹 输出格式的应用场景**：
```
人工查看：使用默认格式，带颜色，信息简洁
脚本处理：使用JSON格式，无颜色，结构化数据
日志存档：使用无颜色格式，配合日志轮转
批量分析：使用目录树输出，分别处理每台主机
```

**🔹 生产环境考虑因素**：
```
性能影响：过高的verbose级别会影响执行速度
安全性：详细输出可能包含敏感信息
可维护性：标准化的日志格式便于后期维护
集成性：结构化输出便于与监控系统集成
```

### 9.3 实际应用价值


**🎯 日常运维场景**：
- **问题排查**：通过详细输出快速定位失败原因
- **执行监控**：通过日志记录追踪系统变更历史
- **自动化集成**：通过结构化输出与CI/CD流水线集成
- **审计合规**：通过完整日志满足安全审计要求

**🔧 开发调试场景**：
- **playbook开发**：使用详细输出验证逻辑正确性
- **模块测试**：通过结构化输出验证返回值格式
- **性能优化**：通过时间统计识别性能瓶颈
- **错误处理**：通过详细信息完善错误处理逻辑

### 9.4 最佳实践建议


**💡 输出控制策略**：
```
开发阶段：
✅ 使用 -v 或 -vv 获得足够的调试信息
✅ 启用颜色输出便于快速识别状态
✅ 临时日志文件，便于问题分析

测试阶段：  
✅ 使用结构化输出验证执行结果
✅ 保存完整日志用于回归测试
✅ 模拟生产环境的输出配置

生产阶段：
✅ 适度详细级别，平衡信息和性能
✅ 强制日志记录，确保可追溯
✅ 禁用颜色输出，确保日志纯净
✅ 集成监控系统，及时发现问题
```

**🚨 注意事项**：
- 高级别verbose输出可能包含密码等敏感信息
- 详细输出会增加网络传输量，影响大规模部署性能  
- JSON输出在包含大量数据时可能很难人工阅读
- 回调插件的兼容性需要考虑Ansible版本差异

**🎯 记忆要点**：
- **verbose控制详细度**：-v看过程，-vv看参数，-vvv看连接，-vvvv看全部
- **输出格式要匹配使用场景**：人看要清晰，机器读要结构化
- **日志管理是生产必需**：记录执行历史，支持问题排查和审计
- **颜色控制看输出目标**：终端显示用颜色，文件保存要纯净

**核心记忆口诀**：
> 详细输出分四级，场景不同选择异  
> 格式控制看用途，结构数据利处理  
> 日志管理生产需，颜色控制看终端  
> 输出回调可定制，最佳实践要牢记