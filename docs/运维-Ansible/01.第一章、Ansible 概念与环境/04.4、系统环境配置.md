---
title: 4、系统环境配置
---
## 📚 目录

1. [系统环境配置概述](#1-系统环境配置概述)
2. [支持的操作系统](#2-支持的操作系统)
3. [Python版本要求](#3-Python版本要求)
4. [网络连通性配置](#4-网络连通性配置)
5. [防火墙配置](#5-防火墙配置)
6. [SELinux设置](#6-SELinux设置)
7. [时间同步配置](#7-时间同步配置)
8. [主机名解析](#8-主机名解析)
9. [用户权限设置](#9-用户权限设置)
10. [存储空间规划](#10-存储空间规划)
11. [虚拟环境隔离](#11-虚拟环境隔离)
12. [环境配置检查清单](#12-环境配置检查清单)

---

## 1. 🌐 系统环境配置概述


### 1.1 什么是Ansible系统环境配置


**💡 核心概念**
```
Ansible系统环境配置 = 让Ansible能够正常工作的基础设置
简单理解：就像装修房子前要先检查水电气一样
```

**🎯 配置目标**
- **控制节点**：运行Ansible命令的主机（你的电脑或服务器）
- **被管节点**：被Ansible管理的目标主机（要操作的服务器们）
- **连接通道**：确保控制节点能够连接到被管节点

### 1.2 为什么需要环境配置


**🔍 实际场景理解**
```
场景：你要用Ansible管理100台服务器
问题：如果环境没配好会怎样？

× 连不上服务器（网络问题）
× 权限不够（用户权限问题）  
× 命令执行失败（Python版本不兼容）
× 时间不同步（任务执行时间混乱）

结果：Ansible根本跑不起来！
```

---

## 2. 🖥️ 支持的操作系统


### 2.1 控制节点系统要求


**✅ 支持的系统**

| 操作系统类型 | **版本要求** | **推荐程度** | **说明** |
|-------------|-------------|-------------|----------|
| **🐧 Linux发行版** | `Ubuntu 18.04+` | ⭐⭐⭐⭐⭐ | 最佳选择，社区支持好 |
| | `CentOS/RHEL 7+` | ⭐⭐⭐⭐⭐ | 企业首选，稳定可靠 |
| | `Debian 9+` | ⭐⭐⭐⭐ | 轻量稳定 |
| | `Fedora 最新版` | ⭐⭐⭐ | 新特性多，适合测试 |
| **🍎 macOS** | `10.12+` | ⭐⭐⭐⭐ | 开发环境友好 |
| **🪟 Windows** | `WSL2` | ⭐⭐⭐ | 需要WSL环境 |

**❌ 不支持的系统**
- **Windows原生**：Ansible控制节点不支持原生Windows
- **解决方案**：使用WSL2或Docker容器

### 2.2 被管节点系统要求


**🎯 几乎支持所有系统**
```
被管节点要求很宽松：
✅ 任何能运行SSH的Linux系统
✅ Windows（通过WinRM协议）
✅ 网络设备（支持SSH的交换机、路由器）
✅ 云平台API（AWS、Azure、阿里云等）
```

### 2.3 系统选择建议


**💡 实际选择指导**
```
🏢 企业环境推荐：
控制节点：CentOS 8/RHEL 8 + Python 3.8+
被管节点：统一发行版，便于管理

🏠 个人学习推荐：
控制节点：Ubuntu 20.04 LTS
被管节点：CentOS 7（免费稳定）

☁️ 云环境推荐：
使用云厂商提供的标准镜像
```

---

## 3. 🐍 Python版本要求


### 3.1 Python版本兼容性


**📋 版本要求总览**

```
控制节点Python要求：
┌─────────────────────────┐
│ Ansible版本  Python版本 │
├─────────────────────────┤
│ 2.9.x    → Python 2.7   │
│ 3.x      → Python 3.6+  │ ← 当前主流
│ 4.x+     → Python 3.8+  │ ← 推荐版本
└─────────────────────────┘

被管节点Python要求：
┌─────────────────────────┐
│ 大多数模块  Python 2.6+ │
│ 新版模块    Python 3.5+ │
│ 推荐配置    Python 3.6+ │
└─────────────────────────┘
```

### 3.2 Python版本检查与安装


**🔍 检查当前Python版本**
```bash
# 检查Python版本
python --version
python3 --version

# 检查具体路径
which python
which python3

# 查看所有已安装的Python
ls /usr/bin/python*
```

**📦 安装Python（Ubuntu示例）**
```bash
# 更新软件包列表
sudo apt update

# 安装Python 3.8
sudo apt install python3.8 python3.8-pip

# 安装开发工具
sudo apt install python3.8-dev python3.8-venv

# 设置默认Python版本（可选）
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 1
```

**📦 安装Python（CentOS示例）**
```bash
# 安装EPEL源
sudo yum install epel-release

# 安装Python 3.8
sudo yum install python38 python38-pip

# 或者使用dnf（CentOS 8+）
sudo dnf install python3.8 python3.8-pip
```

### 3.3 Python环境问题解决


**⚠️ 常见问题与解决**

| 问题描述 | **原因** | **解决方案** |
|---------|---------|-------------|
| `命令找不到python` | 未安装或路径问题 | `sudo ln -s /usr/bin/python3 /usr/bin/python` |
| `pip命令不存在` | pip未安装 | `sudo apt install python3-pip` |
| `权限拒绝` | 系统目录权限 | 使用`--user`安装或虚拟环境 |
| `版本冲突` | 多版本共存 | 使用虚拟环境隔离 |

---

## 4. 🌐 网络连通性配置


### 4.1 网络连通性基本要求


**🔗 连接原理**
```
Ansible网络连接流程：

控制节点 ─SSH─→ 被管节点1 (22端口)
          ├─→ 被管节点2 (22端口) 
          └─→ 被管节点N (22端口)

必要条件：
1. 网络可达（能ping通）
2. SSH服务运行（端口22开放）
3. SSH密钥或密码认证
4. 目标用户权限足够
```

### 4.2 网络连通性测试


**🧪 基础连通性测试**
```bash
# 1. 测试网络可达性
ping -c 3 192.168.1.100

# 2. 测试端口连通性
telnet 192.168.1.100 22
# 或者使用nc命令
nc -zv 192.168.1.100 22

# 3. 测试SSH连接
ssh user@192.168.1.100

# 4. 批量测试多台主机
for host in 192.168.1.{100..110}; do
    echo "Testing $host..."
    nc -w 3 -z $host 22 && echo "✅ $host:22 OK" || echo "❌ $host:22 FAIL"
done
```

### 4.3 SSH配置优化


**⚙️ SSH客户端配置**
```bash
# 编辑SSH配置文件
vim ~/.ssh/config

# 添加以下配置
Host ansible-*
    StrictHostKeyChecking no
    UserKnownHostsFile=/dev/null
    ConnectTimeout=10
    ServerAliveInterval=60
    ControlMaster=auto
    ControlPath=/tmp/ssh-%r@%h:%p
    ControlPersist=600

# 针对具体主机的配置
Host web-server
    HostName 192.168.1.100
    User ansible
    Port 22
    IdentityFile ~/.ssh/ansible_key
```

**🔑 SSH密钥认证配置**
```bash
# 1. 生成SSH密钥对
ssh-keygen -t rsa -b 4096 -C "ansible@company.com" -f ~/.ssh/ansible_key

# 2. 分发公钥到目标主机
ssh-copy-id -i ~/.ssh/ansible_key.pub user@192.168.1.100

# 3. 批量分发公钥脚本
#!/bin/bash
HOSTS="192.168.1.100 192.168.1.101 192.168.1.102"
for host in $HOSTS; do
    echo "Copying key to $host..."
    ssh-copy-id -i ~/.ssh/ansible_key.pub ansible@$host
done
```

---

## 5. 🔥 防火墙配置


### 5.1 防火墙对Ansible的影响


**🛡️ 防火墙工作原理**
```
防火墙规则影响Ansible连接：

控制节点 ──SSH请求──→ [防火墙规则检查] ──→ 被管节点
              ↓
         允许/拒绝决定
         
需要开放的端口：
- SSH: 22端口（Linux默认）
- 自定义SSH端口（如果修改过）
- WinRM: 5985/5986端口（Windows）
```

### 5.2 Linux防火墙配置


**🐧 UFW防火墙（Ubuntu）**
```bash
# 查看防火墙状态
sudo ufw status

# 开放SSH端口
sudo ufw allow 22/tcp
sudo ufw allow ssh

# 允许特定IP访问SSH
sudo ufw allow from 192.168.1.50 to any port 22

# 允许内网段访问
sudo ufw allow from 192.168.1.0/24 to any port 22

# 启用防火墙
sudo ufw enable
```

**🛡️ firewalld防火墙（CentOS/RHEL）**
```bash
# 查看防火墙状态
sudo firewall-cmd --state
sudo firewall-cmd --list-all

# 永久开放SSH服务
sudo firewall-cmd --permanent --add-service=ssh
sudo firewall-cmd --reload

# 开放自定义SSH端口
sudo firewall-cmd --permanent --add-port=2222/tcp
sudo firewall-cmd --reload

# 添加信任的源IP
sudo firewall-cmd --permanent --add-source=192.168.1.50
sudo firewall-cmd --reload
```

### 5.3 防火墙规划最佳实践


**📋 安全规划原则**
```
🎯 最小权限原则：
只开放必要的端口和IP

🔒 网络分段：
管理网络 → 生产网络
DMZ区域 → 内网区域

📊 访问控制矩阵：
源IP段        目标端口    用途
192.168.1.50  22         Ansible控制节点
10.0.1.0/24   22         管理网段
0.0.0.0/0     拒绝       禁止公网访问
```

---

## 6. 🛡️ SELinux设置


### 6.1 SELinux基本概念


**🔍 SELinux是什么**
```
SELinux = Security-Enhanced Linux
作用：Linux安全增强系统，提供强制访问控制

工作模式：
┌─────────────────────────────────┐
│ Enforcing  → 强制模式，阻止违规操作 │
│ Permissive → 宽容模式，记录但不阻止 │  
│ Disabled   → 禁用模式，完全关闭   │
└─────────────────────────────────┘

对Ansible的影响：
可能阻止SSH连接、文件操作、端口绑定等
```

### 6.2 SELinux状态检查与配置


**🔍 检查SELinux状态**
```bash
# 查看SELinux状态
getenforce
sestatus

# 查看详细信息
sestatus -v

# 查看SELinux日志
sudo tail -f /var/log/audit/audit.log | grep denied
```

**⚙️ SELinux模式配置**
```bash
# 临时设置为宽容模式（重启后失效）
sudo setenforce 0

# 临时设置为强制模式
sudo setenforce 1

# 永久配置SELinux模式
sudo vim /etc/selinux/config

# 修改配置文件
SELINUX=permissive  # 或者disabled
SELINUXTYPE=targeted

# 重启系统使配置生效
sudo reboot
```

### 6.3 Ansible相关SELinux策略


**🔧 SSH相关SELinux配置**
```bash
# 允许SSH使用非标准端口
sudo semanage port -a -t ssh_port_t -p tcp 2222

# 设置SSH密钥文件的SELinux上下文
restorecon -R ~/.ssh/

# 允许SSH密钥认证
setsebool -P ssh_keysign on

# 检查SSH相关的SELinux策略
getsebool -a | grep ssh
```

**📋 常见SELinux问题解决**

| 问题现象 | **可能原因** | **解决方法** |
|---------|-------------|-------------|
| SSH连接被拒绝 | 端口策略限制 | `semanage port -a -t ssh_port_t -p tcp PORT` |
| 文件访问被拒绝 | 文件上下文错误 | `restorecon -R /path/to/files` |
| Python模块加载失败 | 执行权限限制 | 设置`httpd_exec_enable`为on |

---

## 7. ⏰ 时间同步配置


### 7.1 时间同步的重要性


**🕐 为什么需要时间同步**
```
Ansible任务执行依赖准确时间：

场景1：日志分析
如果时间不同步 → 日志时间戳混乱 → 无法追踪问题

场景2：定时任务
如果时间不同步 → 定时任务执行错乱 → 业务影响

场景3：SSL证书
如果时间不同步 → 证书验证失败 → 连接中断

推荐时间差：< 1秒
可接受范围：< 30秒
```

### 7.2 时间同步服务配置


**⚙️ 使用systemd-timesyncd（Ubuntu）**
```bash
# 查看时间同步状态
timedatectl status

# 启用时间同步
sudo timedatectl set-ntp true

# 配置NTP服务器
sudo vim /etc/systemd/timesyncd.conf

# 添加配置
[Time]
NTP=ntp1.aliyun.com ntp2.aliyun.com
FallbackNTP=pool.ntp.org

# 重启时间同步服务
sudo systemctl restart systemd-timesyncd

# 强制同步
sudo timedatectl set-ntp false
sudo timedatectl set-ntp true
```

**⚙️ 使用chrony（CentOS/RHEL）**
```bash
# 安装chrony
sudo yum install chrony

# 配置chrony
sudo vim /etc/chrony.conf

# 修改NTP服务器
server ntp1.aliyun.com iburst
server ntp2.aliyun.com iburst
server pool.ntp.org iburst

# 启动chrony服务
sudo systemctl enable chronyd
sudo systemctl start chronyd

# 查看同步状态
chrony sources -v
```

### 7.3 时间同步验证


**🧪 时间同步检查脚本**
```bash
#!/bin/bash
# 批量检查主机时间同步状态

HOSTS="192.168.1.100 192.168.1.101 192.168.1.102"
CONTROL_TIME=$(date +%s)

echo "控制节点时间: $(date)"
echo "===================="

for host in $HOSTS; do
    echo "检查主机: $host"
    
    # 获取远程主机时间
    REMOTE_TIME=$(ssh ansible@$host "date +%s" 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        TIME_DIFF=$((REMOTE_TIME - CONTROL_TIME))
        echo "  时间差: ${TIME_DIFF}秒"
        
        if [ ${TIME_DIFF#-} -le 30 ]; then
            echo "  状态: ✅ 时间同步正常"
        else
            echo "  状态: ❌ 时间差异过大"
        fi
    else
        echo "  状态: ❌ 无法连接"
    fi
    echo ""
done
```

---

## 8. 🌐 主机名解析


### 8.1 主机名解析的作用


**📋 解析方式对比**

```
DNS解析 vs IP地址 vs hosts文件：

方式            优点              缺点              适用场景
┌─────────────────────────────────────────────────┐
│ IP地址        直接快速          不易记忆          小规模环境 │
│ DNS解析       统一管理          依赖DNS服务       大规模环境 │  
│ hosts文件     独立可靠          手动维护          测试环境   │
└─────────────────────────────────────────────────┘

Ansible inventory文件示例：
[webservers]
web01 ansible_host=192.168.1.100  # IP方式
web02.company.com                 # DNS方式  
web03                             # hosts文件方式
```

### 8.2 hosts文件配置


**📝 /etc/hosts文件管理**
```bash
# 编辑hosts文件
sudo vim /etc/hosts

# 添加主机解析记录
# Ansible管理的主机
192.168.1.100   web01 web01.local
192.168.1.101   web02 web02.local  
192.168.1.102   db01 db01.local
192.168.1.103   db02 db02.local

# 集群节点
192.168.1.110   k8s-master
192.168.1.111   k8s-node01
192.168.1.112   k8s-node02
```

**🛠️ 批量更新hosts文件脚本**
```bash
#!/bin/bash
# 批量更新所有主机的hosts文件

HOSTS_FILE="/tmp/ansible_hosts"
TARGET_HOSTS="192.168.1.100 192.168.1.101 192.168.1.102"

# 创建hosts内容
cat > $HOSTS_FILE << 'EOF'
# Ansible管理主机解析
192.168.1.100   web01 web01.local
192.168.1.101   web02 web02.local
192.168.1.102   db01 db01.local
EOF

# 分发到所有主机
for host in $TARGET_HOSTS; do
    echo "更新主机 $host 的hosts文件..."
    
    # 备份原hosts文件
    ssh ansible@$host "sudo cp /etc/hosts /etc/hosts.bak.$(date +%Y%m%d)"
    
    # 添加新的解析记录
    scp $HOSTS_FILE ansible@$host:/tmp/
    ssh ansible@$host "sudo cat /tmp/ansible_hosts >> /etc/hosts"
    
    echo "✅ $host hosts文件更新完成"
done

rm $HOSTS_FILE
```

### 8.3 DNS配置验证


**🧪 域名解析测试**
```bash
# 测试域名解析
nslookup web01.company.com
dig web01.company.com

# 测试反向解析
nslookup 192.168.1.100

# 批量测试主机解析
#!/bin/bash
HOSTNAMES="web01 web02 db01 db02"

for hostname in $HOSTNAMES; do
    echo "测试主机名: $hostname"
    if ping -c 1 -W 2 $hostname >/dev/null 2>&1; then
        IP=$(ping -c 1 $hostname | grep PING | awk '{print $3}' | tr -d '()')
        echo "  ✅ 解析成功: $hostname → $IP"
    else
        echo "  ❌ 解析失败: $hostname"
    fi
done
```

---

## 9. 👤 用户权限设置


### 9.1 Ansible用户权限需求


**🔐 权限需求分析**
```
Ansible执行任务需要的权限：

基础权限：
- SSH登录权限
- 执行shell命令权限
- 读取系统信息权限

管理权限：
- 安装软件包 → sudo权限
- 修改系统配置 → sudo权限  
- 重启服务 → sudo权限
- 创建用户 → sudo权限

权限级别：
普通用户 < sudo用户 < root用户
       ↑
   Ansible推荐使用
```

### 9.2 创建Ansible专用用户


**👤 用户创建与配置**
```bash
# 在所有被管节点上创建ansible用户
sudo useradd -m -s /bin/bash ansible

# 设置密码（如果需要）
sudo passwd ansible

# 将用户添加到sudo组
sudo usermod -aG sudo ansible

# 或者添加到wheel组（CentOS/RHEL）
sudo usermod -aG wheel ansible

# 设置home目录权限
sudo chmod 755 /home/ansible
sudo chown ansible:ansible /home/ansible
```

**🔧 sudo权限配置**
```bash
# 编辑sudoers文件
sudo visudo

# 方法1：添加用户sudo权限（需要密码）
ansible ALL=(ALL:ALL) ALL

# 方法2：添加用户sudo权限（无密码，推荐）
ansible ALL=(ALL) NOPASSWD: ALL

# 方法3：限制特定命令权限
ansible ALL=(ALL) NOPASSWD: /usr/bin/systemctl, /usr/bin/yum, /usr/bin/apt

# 方法4：创建专门的sudoers文件
echo "ansible ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/ansible
sudo chmod 440 /etc/sudoers.d/ansible
```

### 9.3 SSH密钥认证配置


**🔑 批量配置SSH密钥**
```bash
#!/bin/bash
# 批量配置SSH密钥认证

ANSIBLE_USER="ansible"
HOSTS_FILE="hosts.txt"  # 包含所有主机IP的文件
SSH_KEY="$HOME/.ssh/ansible_key"

# 检查密钥文件是否存在
if [ ! -f "$SSH_KEY" ]; then
    echo "生成SSH密钥对..."
    ssh-keygen -t rsa -b 4096 -C "ansible-automation" -f "$SSH_KEY" -N ""
fi

# 读取主机列表并配置密钥
while IFS= read -r host; do
    echo "配置主机: $host"
    
    # 复制公钥到目标主机
    ssh-copy-id -i "$SSH_KEY.pub" "$ANSIBLE_USER@$host"
    
    # 测试免密登录
    if ssh -i "$SSH_KEY" -o ConnectTimeout=5 "$ANSIBLE_USER@$host" "echo 'SSH连接成功'" >/dev/null 2>&1; then
        echo "  ✅ SSH密钥配置成功"
    else
        echo "  ❌ SSH密钥配置失败"
    fi
    
done < "$HOSTS_FILE"
```

### 9.4 权限验证脚本


**🧪 权限测试脚本**
```bash
#!/bin/bash
# 验证Ansible用户权限配置

HOST="$1"
USER="ansible"

if [ -z "$HOST" ]; then
    echo "使用方法: $0 <主机IP>"
    exit 1
fi

echo "验证主机 $HOST 的Ansible权限配置"
echo "================================="

# 测试SSH连接
echo -n "SSH连接测试... "
if ssh -o ConnectTimeout=5 "$USER@$HOST" "echo 'OK'" >/dev/null 2>&1; then
    echo "✅ 通过"
else
    echo "❌ 失败"
    exit 1
fi

# 测试sudo权限
echo -n "sudo权限测试... "
if ssh "$USER@$HOST" "sudo -n whoami" 2>/dev/null | grep -q "root"; then
    echo "✅ 通过"
else
    echo "❌ 失败"
fi

# 测试Python环境
echo -n "Python环境测试... "
PYTHON_VERSION=$(ssh "$USER@$HOST" "python3 --version 2>&1" | grep -oE "[0-9]+\.[0-9]+")
if [ -n "$PYTHON_VERSION" ]; then
    echo "✅ 通过 (Python $PYTHON_VERSION)"
else
    echo "❌ Python未安装"
fi

# 测试系统管理权限
echo -n "系统服务管理测试... "
if ssh "$USER@$HOST" "sudo -n systemctl status sshd" >/dev/null 2>&1; then
    echo "✅ 通过"
else
    echo "❌ 失败"
fi

echo ""
echo "权限验证完成！"
```

---

## 10. 💾 存储空间规划


### 10.1 存储空间需求分析


**📊 空间需求评估**
```
Ansible存储空间需求分析：

控制节点存储需求：
├─ Ansible安装包: 50-100 MB
├─ Python依赖包: 200-500 MB  
├─ Playbook代码: 100MB - 1GB (根据项目规模)
├─ 日志文件: 100MB - 10GB (根据活跃度)
├─ 临时文件: 100MB - 1GB
└─ 总计建议: 最少2GB，推荐10GB+

被管节点存储需求：
├─ Python环境: 100-200 MB
├─ 临时执行文件: 10-100 MB
├─ 日志文件: 10-100 MB  
└─ 总计建议: 最少500MB可用空间
```

### 10.2 目录结构规划


**📁 标准目录结构**
```bash
# 控制节点目录结构规划
/opt/ansible/                    # Ansible主目录
├── playbooks/                   # Playbook存放目录
│   ├── roles/                  # 角色目录
│   ├── inventories/            # 主机清单目录
│   └── group_vars/             # 组变量目录
├── logs/                       # 日志目录
├── backups/                    # 配置备份目录
├── scripts/                    # 脚本工具目录
└── temp/                       # 临时文件目录

# 用户家目录结构
~/.ansible/                     # Ansible用户配置
├── tmp/                       # 临时文件
├── roles/                     # Galaxy角色
└── collections/               # 集合文件
```

**🛠️ 创建目录结构脚本**
```bash
#!/bin/bash
# 创建Ansible标准目录结构

ANSIBLE_HOME="/opt/ansible"
USER_HOME="$HOME"

echo "创建Ansible目录结构..."

# 创建主目录结构
sudo mkdir -p $ANSIBLE_HOME/{playbooks,logs,backups,scripts,temp}
sudo mkdir -p $ANSIBLE_HOME/playbooks/{roles,inventories,group_vars,host_vars}

# 设置目录权限
sudo chown -R $(whoami):$(whoami) $ANSIBLE_HOME
sudo chmod -R 755 $ANSIBLE_HOME

# 创建用户目录结构
mkdir -p $USER_HOME/.ansible/{tmp,roles,collections}

# 创建日志轮转配置
sudo tee /etc/logrotate.d/ansible << 'EOF'
/opt/ansible/logs/*.log {
    daily
    missingok
    rotate 30
    compress
    notifempty
    create 644 ansible ansible
}
EOF

echo "✅ Ansible目录结构创建完成！"
```

### 10.3 存储空间监控


**📊 空间监控脚本**
```bash
#!/bin/bash
# Ansible存储空间监控脚本

ANSIBLE_HOME="/opt/ansible"
THRESHOLD=80  # 磁盘使用率阈值

echo "Ansible存储空间监控报告"
echo "======================"
echo "检查时间: $(date)"
echo ""

# 检查根分区使用率
ROOT_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
echo "根分区使用率: ${ROOT_USAGE}%"

if [ $ROOT_USAGE -gt $THRESHOLD ]; then
    echo "  ⚠️  警告：根分区使用率过高！"
else
    echo "  ✅ 根分区使用率正常"
fi

# 检查Ansible目录大小
if [ -d "$ANSIBLE_HOME" ]; then
    ANSIBLE_SIZE=$(du -sh $ANSIBLE_HOME | cut -f1)
    echo "Ansible目录大小: $ANSIBLE_SIZE"
    
    # 子目录大小统计
    echo ""
    echo "子目录大小统计:"
    du -sh $ANSIBLE_HOME/* | sort -hr
fi

# 检查大文件
echo ""
echo "大文件检查 (>100MB):"
find $ANSIBLE_HOME -type f -size +100M -exec ls -lh {} \; 2>/dev/null | head -10

# 检查日志文件大小
echo ""
echo "日志文件大小:"
find $ANSIBLE_HOME/logs -name "*.log" -exec ls -lh {} \; 2>/dev/null

# 清理建议
echo ""
echo "清理建议:"
echo "- 定期清理日志文件: find $ANSIBLE_HOME/logs -name '*.log' -mtime +30 -delete"
echo "- 清理临时文件: rm -rf $ANSIBLE_HOME/temp/*"
echo "- 清理备份文件: find $ANSIBLE_HOME/backups -mtime +90 -delete"
```

---

## 11. 🐍 虚拟环境隔离


### 11.1 为什么需要虚拟环境


**💡 虚拟环境的价值**
```
虚拟环境解决的问题：

问题1：Python版本冲突
系统Python 2.7 ← 系统依赖
Ansible需要Python 3.8+ ← 应用需求
解决：虚拟环境隔离不同版本

问题2：包依赖冲突  
项目A需要requests 2.25.1
项目B需要requests 2.28.0
解决：不同虚拟环境独立管理

问题3：系统环境污染
安装过多包 → 系统混乱
升级包导致其他程序出错
解决：虚拟环境保持系统纯净
```

### 11.2 Python虚拟环境创建


**🔧 使用venv创建虚拟环境**
```bash
# 安装python3-venv（如果未安装）
sudo apt install python3-venv  # Ubuntu
sudo yum install python3-venv  # CentOS

# 创建Ansible专用虚拟环境
python3 -m venv /opt/ansible/venv

# 激活虚拟环境
source /opt/ansible/venv/bin/activate

# 验证虚拟环境
which python
python --version

# 升级pip到最新版本
pip install --upgrade pip

# 安装Ansible
pip install ansible

# 验证安装
ansible --version
```

**🔧 使用virtualenv创建（可选）**
```bash
# 安装virtualenv
pip install virtualenv

# 创建虚拟环境
virtualenv -p python3.8 /opt/ansible/venv

# 激活虚拟环境
source /opt/ansible/venv/bin/activate

# 安装Ansible及相关包
pip install ansible ansible-lint yamllint
```

### 11.3 虚拟环境管理


**📋 虚拟环境管理脚本**
```bash
#!/bin/bash
# Ansible虚拟环境管理脚本

VENV_PATH="/opt/ansible/venv"
REQUIREMENTS_FILE="/opt/ansible/requirements.txt"

# 功能菜单
show_menu() {
    echo "Ansible虚拟环境管理"
    echo "=================="
    echo "1. 创建虚拟环境"
    echo "2. 激活虚拟环境"  
    echo "3. 安装依赖包"
    echo "4. 更新Ansible"
    echo "5. 导出依赖列表"
    echo "6. 删除虚拟环境"
    echo "0. 退出"
    echo ""
}

# 创建虚拟环境
create_venv() {
    echo "创建Ansible虚拟环境..."
    if [ -d "$VENV_PATH" ]; then
        echo "⚠️  虚拟环境已存在: $VENV_PATH"
        return
    fi
    
    python3 -m venv "$VENV_PATH"
    source "$VENV_PATH/bin/activate"
    pip install --upgrade pip
    pip install ansible ansible-lint yamllint
    echo "✅ 虚拟环境创建成功！"
}

# 安装依赖包
install_requirements() {
    if [ ! -f "$REQUIREMENTS_FILE" ]; then
        echo "创建requirements.txt文件..."
        cat > "$REQUIREMENTS_FILE" << 'EOF'
ansible>=4.0.0
ansible-lint>=5.0.0
yamllint>=1.26.0
netaddr>=0.8.0
jinja2>=3.0.0
requests>=2.25.0
EOF
    fi
    
    source "$VENV_PATH/bin/activate"
    pip install -r "$REQUIREMENTS_FILE"
    echo "✅ 依赖包安装完成！"
}

# 导出依赖列表
export_requirements() {
    source "$VENV_PATH/bin/activate"
    pip freeze > "$REQUIREMENTS_FILE"
    echo "✅ 依赖列表已导出到: $REQUIREMENTS_FILE"
}

# 主程序
main() {
    while true; do
        show_menu
        read -p "请选择操作: " choice
        
        case $choice in
            1) create_venv ;;
            2) echo "执行: source $VENV_PATH/bin/activate" ;;
            3) install_requirements ;;
            4) source "$VENV_PATH/bin/activate" && pip install --upgrade ansible ;;
            5) export_requirements ;;
            6) rm -rf "$VENV_PATH" && echo "✅ 虚拟环境已删除" ;;
            0) exit 0 ;;
            *) echo "❌ 无效选择" ;;
        esac
        echo ""
        read -p "按Enter继续..."
        clear
    done
}

main
```

### 11.4 自动激活虚拟环境


**⚙️ 自动激活配置**
```bash
# 方法1：添加到.bashrc
echo "source /opt/ansible/venv/bin/activate" >> ~/.bashrc

# 方法2：创建别名
echo "alias ansible-env='source /opt/ansible/venv/bin/activate'" >> ~/.bashrc

# 方法3：创建启动脚本
cat > /usr/local/bin/ansible-env << 'EOF'
#!/bin/bash
# Ansible环境启动脚本

VENV_PATH="/opt/ansible/venv"

if [ -f "$VENV_PATH/bin/activate" ]; then
    source "$VENV_PATH/bin/activate"
    echo "✅ Ansible虚拟环境已激活"
    echo "Python: $(which python)"
    echo "Ansible: $(ansible --version | head -1)"
else
    echo "❌ Ansible虚拟环境不存在: $VENV_PATH"
    exit 1
fi

# 如果有参数，执行命令
if [ $# -gt 0 ]; then
    exec "$@"
else
    exec bash
fi
EOF

chmod +x /usr/local/bin/ansible-env

# 使用方式
ansible-env                    # 启动环境
ansible-env ansible-playbook  # 在环境中执行命令
```

---

## 12. ✅ 环境配置检查清单


### 12.1 配置检查清单


**📋 系统环境检查表**

| 检查项目 | **要求** | **检查方法** | **状态** |
|---------|---------|-------------|---------|
| **操作系统版本** | Ubuntu 18.04+/CentOS 7+ | `cat /etc/os-release` | ⬜ |
| **Python版本** | Python 3.6+ | `python3 --version` | ⬜ |
| **网络连通性** | 能ping通所有主机 | `ping -c 3 <host>` | ⬜ |
| **SSH服务** | 22端口开放 | `nc -zv <host> 22` | ⬜ |
| **SSH密钥认证** | 免密登录 | `ssh user@host whoami` | ⬜ |
| **用户权限** | sudo无密码 | `sudo -n whoami` | ⬜ |
| **防火墙配置** | SSH端口允许 | `ufw status` | ⬜ |
| **SELinux配置** | 宽容或禁用 | `getenforce` | ⬜ |
| **时间同步** | NTP同步正常 | `timedatectl status` | ⬜ |
| **主机名解析** | 能解析主机名 | `ping hostname` | ⬜ |
| **存储空间** | 足够可用空间 | `df -h` | ⬜ |
| **虚拟环境** | Python虚拟环境 | `which python` | ⬜ |

### 12.2 自动化检查脚本


**🤖 环境检查自动化脚本**
```bash
#!/bin/bash
# Ansible环境配置自动检查脚本

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 检查结果统计
PASS_COUNT=0
FAIL_COUNT=0
WARN_COUNT=0

# 打印结果函数
print_result() {
    local status=$1
    local message=$2
    
    case $status in
        "PASS")
            echo -e "${GREEN}✅ PASS${NC} $message"
            ((PASS_COUNT++))
            ;;
        "FAIL")
            echo -e "${RED}❌ FAIL${NC} $message"
            ((FAIL_COUNT++))
            ;;
        "WARN")
            echo -e "${YELLOW}⚠️  WARN${NC} $message"
            ((WARN_COUNT++))
            ;;
    esac
}

# 检查操作系统
check_os() {
    echo "检查操作系统版本..."
    
    if [ -f /etc/os-release ]; then
        OS_NAME=$(grep "^NAME=" /etc/os-release | cut -d'"' -f2)
        OS_VERSION=$(grep "^VERSION=" /etc/os-release | cut -d'"' -f2)
        print_result "PASS" "操作系统: $OS_NAME $OS_VERSION"
    else
        print_result "FAIL" "无法获取操作系统信息"
    fi
}

# 检查Python版本
check_python() {
    echo "检查Python版本..."
    
    if command -v python3 >/dev/null 2>&1; then
        PYTHON_VERSION=$(python3 --version 2>&1 | grep -oE "[0-9]+\.[0-9]+")
        PYTHON_MAJOR=$(echo $PYTHON_VERSION | cut -d. -f1)
        PYTHON_MINOR=$(echo $PYTHON_VERSION | cut -d. -f2)
        
        if [ $PYTHON_MAJOR -eq 3 ] && [ $PYTHON_MINOR -ge 6 ]; then
            print_result "PASS" "Python版本: $(python3 --version)"
        else
            print_result "FAIL" "Python版本过低: $(python3 --version)，需要3.6+"
        fi
    else
        print_result "FAIL" "Python3未安装"
    fi
}

# 检查磁盘空间
check_disk_space() {
    echo "检查磁盘空间..."
    
    ROOT_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    ROOT_AVAIL=$(df -h / | awk 'NR==2 {print $4}')
    
    if [ $ROOT_USAGE -lt 80 ]; then
        print_result "PASS" "磁盘空间正常，可用: $ROOT_AVAIL"
    elif [ $ROOT_USAGE -lt 90 ]; then
        print_result "WARN" "磁盘空间偏紧，可用: $ROOT_AVAIL"
    else
        print_result "FAIL" "磁盘空间不足，可用: $ROOT_AVAIL"
    fi
}

# 检查网络连通性
check_network() {
    echo "检查网络连通性..."
    
    # 检查网络接口
    if ip route | grep -q default; then
        print_result "PASS" "默认路由配置正常"
    else
        print_result "FAIL" "默认路由未配置"
    fi
    
    # 检查DNS解析
    if nslookup google.com >/dev/null 2>&1; then
        print_result "PASS" "DNS解析正常"
    else
        print_result "WARN" "DNS解析可能有问题"
    fi
}

# 检查防火墙状态
check_firewall() {
    echo "检查防火墙配置..."
    
    if command -v ufw >/dev/null 2>&1; then
        UFW_STATUS=$(ufw status | grep "Status:" | awk '{print $2}')
        if [ "$UFW_STATUS" = "active" ]; then
            if ufw status | grep -q "22/tcp"; then
                print_result "PASS" "UFW防火墙已开放SSH端口"
            else
                print_result "WARN" "UFW防火墙未明确开放SSH端口"
            fi
        else
            print_result "WARN" "UFW防火墙未启用"
        fi
    elif command -v firewall-cmd >/dev/null 2>&1; then
        if systemctl is-active firewalld >/dev/null 2>&1; then
            if firewall-cmd --query-service=ssh >/dev/null 2>&1; then
                print_result "PASS" "firewalld已开放SSH服务"
            else
                print_result "WARN" "firewalld未开放SSH服务"
            fi
        else
            print_result "WARN" "firewalld服务未运行"
        fi
    else
        print_result "WARN" "未检测到防火墙管理工具"
    fi
}

# 检查SELinux状态
check_selinux() {
    echo "检查SELinux配置..."
    
    if command -v getenforce >/dev/null 2>&1; then
        SELINUX_STATUS=$(getenforce)
        if [ "$SELINUX_STATUS" = "Disabled" ] || [ "$SELINUX_STATUS" = "Permissive" ]; then
            print_result "PASS" "SELinux状态: $SELINUX_STATUS"
        else
            print_result "WARN" "SELinux状态: $SELINUX_STATUS (可能影响Ansible运行)"
        fi
    else
        print_result "PASS" "系统不支持SELinux"
    fi
}

# 检查时间同步
check_time_sync() {
    echo "检查时间同步..."
    
    if command -v timedatectl >/dev/null 2>&1; then
        if timedatectl status | grep -q "synchronized: yes"; then
            print_result "PASS" "系统时间同步正常"
        else
            print_result "WARN" "系统时间可能未同步"
        fi
    elif command -v chrony >/dev/null 2>&1; then
        if chrony sources | grep -q "\*"; then
            print_result "PASS" "Chrony时间同步正常"
        else
            print_result "WARN" "Chrony时间同步状态未知"
        fi
    else
        print_result "WARN" "未检测到时间同步服务"
    fi
}

# 主检查函数
main() {
    echo "========================================"
    echo "        Ansible环境配置检查"
    echo "========================================"
    echo "检查时间: $(date)"
    echo ""
    
    check_os
    echo ""
    
    check_python
    echo ""
    
    check_disk_space  
    echo ""
    
    check_network
    echo ""
    
    check_firewall
    echo ""
    
    check_selinux
    echo ""
    
    check_time_sync
    echo ""
    
    # 打印检查结果统计
    echo "========================================"
    echo "           检查结果统计"
    echo "========================================"
    echo -e "${GREEN}通过: $PASS_COUNT${NC}"
    echo -e "${YELLOW}警告: $WARN_COUNT${NC}"
    echo -e "${RED}失败: $FAIL_COUNT${NC}"
    echo ""
    
    if [ $FAIL_COUNT -eq 0 ]; then
        echo -e "${GREEN}✅ 环境检查通过，可以安装和使用Ansible！${NC}"
        exit 0
    else
        echo -e "${RED}❌ 环境检查发现问题，请先解决失败项再继续！${NC}"
        exit 1
    fi
}

# 执行主程序
main
```

### 12.3 问题解决快速参考


**🔧 常见问题快速解决**

```bash
# 问题1：Python版本过低
sudo apt install python3.8 python3.8-pip
sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1

# 问题2：SSH连接失败
sudo systemctl start sshd
sudo systemctl enable sshd
sudo ufw allow 22

# 问题3：用户权限不足
sudo usermod -aG sudo ansible
echo "ansible ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/ansible

# 问题4：时间不同步
sudo apt install ntp
sudo systemctl start ntp
sudo systemctl enable ntp

# 问题5：磁盘空间不足
sudo apt clean
sudo journalctl --vacuum-time=30d
find /tmp -type f -atime +7 -delete

# 问题6：防火墙阻止连接
sudo ufw allow from 192.168.1.0/24 to any port 22
sudo firewall-cmd --permanent --add-service=ssh
sudo firewall-cmd --reload
```

---

## 💡 总结要点


### 🎯 环境配置核心要点


```
🔸 系统要求：Linux控制节点，Python 3.6+，充足存储空间
🔸 网络连通：SSH连接畅通，防火墙正确配置
🔸 权限设置：专用用户，sudo权限，SSH密钥认证
🔸 时间同步：所有主机时间同步，避免任务执行混乱
🔸 环境隔离：虚拟环境隔离，避免依赖冲突
🔸 安全配置：SELinux适当配置，最小权限原则
```

### ✨ 最佳实践建议


- **标准化环境**：统一操作系统版本，统一配置标准
- **自动化检查**：定期运行环境检查脚本，及时发现问题  
- **文档记录**：详细记录环境配置，便于维护和排错
- **监控告警**：监控关键指标，异常时及时告警
- **定期维护**：定期更新系统和软件，清理临时文件

**🚀 下一步行动**：
1. 运行环境检查脚本，确认所有项目通过
2. 配置Ansible虚拟环境，安装最新版本
3. 准备主机清单文件，开始第一个Playbook测试