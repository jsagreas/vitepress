---
title: 9、错误处理配置文件
---
## 📚 目录

1. [错误处理配置概述](#1-错误处理配置概述)
2. [基础错误控制配置](#2-基础错误控制配置)
3. [条件错误处理配置](#3-条件错误处理配置)
4. [任务块错误处理](#4-任务块错误处理)
5. [重试与缓存配置](#5-重试与缓存配置)
6. [高级错误处理策略](#6-高级错误处理策略)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚨 错误处理配置概述


### 1.1 什么是Ansible错误处理


**通俗理解**：就像开车时的安全系统一样，Ansible的错误处理配置是为了让自动化任务更加稳定可靠。

```
现实场景类比：
送快递员配送包裹 → Ansible执行任务
遇到收件人不在家 → 任务执行失败
快递员的处理策略 → 错误处理配置

可能的处理方式：
✅ 放在门卫处（忽略错误继续）
✅ 改天再送（重试机制）  
✅ 联系客户改地址（救援任务）
❌ 直接返回所有包裹（任何错误致命）
```

### 1.2 为什么需要错误处理配置


**核心原因**：
- 🌐 **网络不稳定**：目标主机可能临时不可达
- 💻 **系统差异**：不同服务器环境存在差异
- ⚙️ **服务状态**：应用服务可能正在维护
- 📦 **依赖问题**：软件包可能暂时不可用

> 💡 **新手理解**：Ansible管理几十台甚至上百台服务器时，不可能每台都100%完美运行，错误处理配置就是让自动化过程更智能、更容错。

### 1.3 错误处理配置的层次结构


```
全局配置 (ansible.cfg)
    ↓
Playbook级别配置
    ↓
任务(Task)级别配置
    ↓
模块(Module)级别配置
```

---

## 2. ⚙️ 基础错误控制配置


### 2.1 error_on_undefined_vars - 未定义变量错误控制


**含义解释**：控制当遇到未定义变量时是否报错停止

```ini
# ansible.cfg
[defaults]
error_on_undefined_vars = True   # 默认值，遇到未定义变量就报错
error_on_undefined_vars = False  # 忽略未定义变量，用空字符串代替
```

**通俗理解**：
- `True`：**严格模式** - 就像做数学题，变量x没定义就不让你继续算
- `False`：**宽松模式** - 没定义的变量当作空值处理，继续执行

**实际应用场景**：
```yaml
# 当 error_on_undefined_vars = False 时
- name: 创建用户配置目录
  file:
    path: /home/{{ username | default('guest') }}/config
    state: directory
# 如果username未定义，会创建 /home/guest/config
```

> ⚠️ **新手注意**：开发环境建议设为`True`便于发现问题，生产环境可考虑`False`提高容错性。

### 2.2 any_errors_fatal - 任何错误致命控制


**含义解释**：当任意一台主机出错时，是否立即停止所有主机上的任务

```yaml
# playbook级别配置
- hosts: web_servers
  any_errors_fatal: true    # 任意主机出错就停止所有主机
  any_errors_fatal: false   # 默认值，单个主机出错不影响其他主机
```

**生活化比喻**：
```
场景：给10台服务器安装软件
any_errors_fatal = true  → "一人生病，全班停课"
any_errors_fatal = false → "生病的同学请假，其他人正常上课"
```

**配置对比表**：

| 配置值 | **错误影响范围** | **适用场景** | **优缺点** |
|---------|----------------|-------------|-----------|
| `true` | 一台出错全部停止 | 数据库集群部署 | 安全但效率低 |
| `false` | 只影响出错的主机 | Web服务器更新 | 效率高但需容错 |

### 2.3 max_fail_percentage - 最大失败百分比


**含义解释**：允许多少比例的主机失败后才停止整个任务

```yaml
- hosts: web_servers
  max_fail_percentage: 30    # 允许30%的主机失败
  serial: 5                  # 每批处理5台主机
```

**通俗计算示例**：
```
总共100台Web服务器，max_fail_percentage: 20

执行过程：
第1批(20台): 3台失败 → 失败率15% ✅ 继续
第2批(20台): 2台失败 → 总失败率10% ✅ 继续  
第3批(20台): 8台失败 → 总失败率21% ❌ 停止！
```

> 🔥 **重要性**: ⭐⭐⭐⭐⭐ - 这是大规模部署的核心安全配置！

---

## 3. 🎯 条件错误处理配置


### 3.1 ignore_errors - 忽略错误继续执行


**含义解释**：让特定任务即使失败也不影响后续任务执行

```yaml
- name: 尝试停止可能不存在的服务
  service:
    name: old_service
    state: stopped
  ignore_errors: true        # 即使服务不存在也继续执行

- name: 启动新服务  
  service:
    name: new_service
    state: started           # 上面任务失败不影响这个任务
```

**使用场景举例**：
- 🧹 **清理任务**：删除可能不存在的临时文件
- 🔄 **服务迁移**：停止旧服务（可能已停止）
- 📊 **信息收集**：获取可能不存在的系统信息

### 3.2 ignore_unreachable - 忽略不可达主机


**含义解释**：当主机网络不可达时不视为错误

```yaml
- hosts: all
  ignore_unreachable: true   # 网络不通的主机跳过，不报错
  tasks:
    - name: 更新系统包
      yum:
        name: '*'
        state: latest
```

**应用场景对比**：
```
维护场景示例：
时间：凌晨2点系统维护
目标：100台服务器更新系统

ignore_unreachable = false：
- 10台服务器在维护中无法连接
- 整个更新任务失败 ❌
- 需要白天重新执行

ignore_unreachable = true：  
- 10台维护中的服务器自动跳过
- 90台正常服务器完成更新 ✅
- 维护完成后单独处理那10台
```

### 3.3 failed_when - 自定义失败条件


**含义解释**：不依赖任务的默认成功/失败判断，自己定义什么情况算失败

```yaml
- name: 检查磁盘空间
  shell: df -h / | tail -1 | awk '{print $5}' | sed 's/%//'
  register: disk_usage
  failed_when: disk_usage.stdout | int > 80  # 磁盘使用率>80%才算失败

- name: 检查服务状态  
  command: systemctl status nginx
  register: service_status
  failed_when: "'active (running)' not in service_status.stdout"
```

**实际应用价值**：
```
默认行为 vs 自定义失败条件

默认行为：
命令返回码 ≠ 0 = 失败
命令返回码 = 0 = 成功

自定义条件：  
根据命令输出内容判断成功失败
更符合业务逻辑需求
```

### 3.4 changed_when - 自定义变更条件


**含义解释**：控制任务在什么情况下被标记为"已变更"状态

```yaml
- name: 检查配置文件是否需要重新加载
  command: nginx -t
  register: config_check
  changed_when: false          # 这个检查任务永远不标记为changed

- name: 重新加载nginx配置
  command: nginx -s reload  
  when: config_check is succeeded
  changed_when: true           # 强制标记为changed
```

**为什么需要控制changed状态**：
- 📊 **报告准确性**：避免检查类任务被误标记为变更
- 🔗 **触发器控制**：某些handler只在真正变更时才执行
- 📈 **统计意义**：让变更统计更有意义

---

## 4. 🧩 任务块错误处理


### 4.1 block/rescue/always - 任务块结构化错误处理


**含义解释**：类似编程语言的try-catch-finally结构，提供完整的错误处理流程

```yaml
- block:    # 相当于 try
    - name: 下载应用程序包
      get_url:
        url: "{{ app_download_url }}"
        dest: /tmp/app.tar.gz
        
    - name: 解压并安装
      unarchive:
        src: /tmp/app.tar.gz
        dest: /opt/
        remote_src: true

  rescue:   # 相当于 catch  
    - name: 下载失败，使用备用镜像
      get_url:
        url: "{{ backup_download_url }}"
        dest: /tmp/app.tar.gz
        
    - name: 从备用源安装
      unarchive:
        src: /tmp/app.tar.gz
        dest: /opt/
        remote_src: true

  always:   # 相当于 finally
    - name: 清理临时文件
      file:
        path: /tmp/app.tar.gz
        state: absent
```

**结构化错误处理流程图**：
```
开始执行block任务
        ↓
     任务成功？
    ┌─────┴─────┐
   是│          │否
    ↓           ↓
 执行always   执行rescue
    ↓           ↓
   结束      rescue成功？
              ┌───┴───┐
             是│      │否
              ↓       ↓
           执行always 任务失败
              ↓       ↓
             结束    结束
```

### 4.2 实际应用场景示例


**场景：Web应用部署**
```yaml
- name: Web应用安全部署
  block:
    - name: 停止应用服务
      service: name=webapp state=stopped
      
    - name: 备份当前版本
      command: cp -r /opt/webapp /opt/webapp.backup.{{ ansible_date_time.epoch }}
      
    - name: 部署新版本
      unarchive: src=webapp-v2.0.tar.gz dest=/opt/

  rescue:
    - name: 部署失败，回滚到备份版本
      command: rm -rf /opt/webapp && mv /opt/webapp.backup.{{ ansible_date_time.epoch }} /opt/webapp
      
    - name: 发送告警通知
      mail:
        to: admin@company.com
        subject: "Web应用部署失败"
        body: "服务器{{ inventory_hostname }}部署失败，已自动回滚"

  always:
    - name: 确保服务启动
      service: name=webapp state=started
      
    - name: 清理旧备份文件（保留最近3个）
      shell: ls -t /opt/webapp.backup.* | tail -n +4 | xargs rm -rf
      ignore_errors: true
```

---

## 5. 🔄 重试与缓存配置


### 5.1 retry_files_enabled - 重试文件功能


**含义解释**：当playbook执行失败时，自动生成重试文件，记录失败的主机

```ini
# ansible.cfg
[defaults]
retry_files_enabled = True     # 开启重试文件功能（默认）
retry_files_enabled = False    # 关闭重试文件功能
```

**重试文件工作原理**：
```
执行playbook: site.yml
涉及主机: web1, web2, web3, db1, db2

执行结果:
✅ web1: 成功
❌ web2: 失败  
✅ web3: 成功
❌ db1: 失败
✅ db2: 成功

自动生成: site.retry 文件
内容:
web2
db1

重新执行: ansible-playbook -l @site.retry site.yml
只针对失败的主机重新运行！
```

### 5.2 retry_files_save_path - 重试文件保存路径


```ini
[defaults]
retry_files_save_path = /var/log/ansible/retry/  # 指定重试文件保存目录
```

**目录组织建议**：
```
/var/log/ansible/retry/
├── web-deploy.retry          # Web部署失败主机
├── db-update.retry           # 数据库更新失败主机  
├── security-patch.retry      # 安全补丁失败主机
└── archive/                  # 历史重试文件归档
    ├── 2025-01/
    └── 2025-02/
```

### 5.3 fact_caching - 事实缓存配置


**含义解释**：缓存主机的系统信息，避免重复收集，提高执行效率

```ini
[defaults]
# 缓存类型
fact_caching = memory          # 内存缓存（默认）
fact_caching = jsonfile        # 文件缓存
fact_caching = redis           # Redis缓存

# 缓存超时时间（秒）
fact_caching_timeout = 86400   # 24小时

# 文件缓存目录（当使用jsonfile时）
fact_caching_connection = /var/cache/ansible/facts/
```

**缓存效果对比**：
```
无缓存模式：
每次执行playbook都要收集facts
100台主机 × 3秒收集时间 = 5分钟

有缓存模式：
第1次：收集并缓存facts (5分钟)
第2次：直接使用缓存 (10秒)
第3次：直接使用缓存 (10秒)
```

### 5.4 gather_subset - 收集信息子集


**含义解释**：控制收集哪些系统信息，减少不必要的数据收集

```yaml
- hosts: all
  gather_facts: true
  gather_subset:
    - '!all'           # 排除所有默认信息
    - network          # 只收集网络信息
    - hardware         # 只收集硬件信息
```

**可用的子集类型**：

| 子集名称 | **包含信息** | **收集耗时** | **常用场景** |
|---------|-------------|-------------|-------------|
| `network` | IP地址、网络接口 | 快 | 网络配置任务 |
| `hardware` | CPU、内存、磁盘 | 中等 | 性能监控 |
| `virtual` | 虚拟化信息 | 快 | 云环境管理 |
| `ohai` | 详细系统信息 | 慢 | 全面系统审计 |

---

## 6. 🚀 高级错误处理策略


### 6.1 force_handlers - 强制执行处理程序


**含义解释**：即使任务失败，也要执行已经被触发的handlers

```yaml
- hosts: web_servers
  force_handlers: true    # 即使任务失败也执行handlers
  
  tasks:
    - name: 更新nginx配置
      template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
      notify: reload nginx  # 触发handler
      
    - name: 可能失败的任务
      command: /some/command/that/might/fail
      
  handlers:
    - name: reload nginx
      service: name=nginx state=reloaded
      # 即使上面的任务失败，这个handler仍会执行
```

**应用价值**：
```
典型场景：配置文件更新

没有 force_handlers：
1. 更新配置文件 ✅  (触发reload handler)
2. 后续任务失败 ❌
3. reload handler被跳过 ❌
结果：配置更新了但服务没重载，可能导致服务异常

有 force_handlers：  
1. 更新配置文件 ✅  (触发reload handler)
2. 后续任务失败 ❌
3. reload handler仍执行 ✅  
结果：即使有错误，服务配置也能正确应用
```

### 6.2 组合使用多种错误处理策略


```yaml
- name: 企业级Web服务部署
  hosts: web_farm
  max_fail_percentage: 25        # 允许25%失败
  any_errors_fatal: false        # 不是任何错误致命
  ignore_unreachable: true       # 忽略网络不可达
  force_handlers: true           # 强制执行handlers
  
  tasks:
    - block:
        - name: 健康检查
          uri:
            url: "http://{{ inventory_hostname }}/health"
            method: GET
          failed_when: false     # 检查不算失败
          register: health_check
          
        - name: 部署新版本
          unarchive:
            src: "{{ app_package }}"
            dest: /opt/webapp/
          when: health_check.status == 200
          notify: restart webapp
          
        - name: 验证部署结果
          uri:
            url: "http://{{ inventory_hostname }}/health"
            method: GET
          retries: 3
          delay: 10
          
      rescue:
        - name: 回滚到上一版本
          command: /opt/scripts/rollback.sh
          ignore_errors: true
          
      always:
        - name: 记录部署日志
          lineinfile:
            path: /var/log/deployment.log
            line: "{{ ansible_date_time.iso8601 }} - {{ inventory_hostname }} - {{ ansible_failed_task.name | default('SUCCESS') }}"
```

---

## 7. 🎯 实际应用场景


### 7.1 大规模服务器维护场景


```yaml
- name: 月度安全补丁更新
  hosts: production_servers
  serial: "20%"                    # 分批执行，每批20%
  max_fail_percentage: 10          # 允许10%失败
  ignore_unreachable: true         # 忽略维护中的服务器
  
  pre_tasks:
    - name: 检查服务器负载
      shell: uptime | awk '{print $10}' | sed 's/,//'
      register: server_load
      failed_when: server_load.stdout | float > 5.0  # 负载过高暂停更新
      
  tasks:
    - block:
        - name: 更新系统包
          yum: name=* state=latest update_cache=yes
          
        - name: 重启系统（如需要）
          reboot:
          when: reboot_required is defined
          
      rescue:
        - name: 更新失败处理
          mail:
            to: ops-team@company.com
            subject: "服务器 {{ inventory_hostname }} 更新失败"
            
      always:
        - name: 记录更新状态
          lineinfile:
            path: /var/log/patch-status.log
            line: "{{ ansible_date_time.iso8601 }} - {{ inventory_hostname }} - {{ 'SUCCESS' if ansible_failed_result is not defined else 'FAILED' }}"
```

### 7.2 应用发布场景


```yaml
- name: 蓝绿部署流程
  hosts: app_servers
  any_errors_fatal: true           # 发布过程任何错误都致命
  
  vars:
    health_check_retries: 5
    
  tasks:
    - name: 蓝绿切换部署
      block:
        - name: 部署到绿色环境
          include_tasks: deploy_green.yml
          
        - name: 健康检查
          uri:
            url: "http://{{ inventory_hostname }}:8081/health"
          register: health_result
          retries: "{{ health_check_retries }}"
          delay: 30
          failed_when: health_result.status != 200
          
        - name: 切换流量到绿色环境
          replace:
            path: /etc/nginx/upstream.conf
            regexp: 'server.*:8080'
            replace: 'server {{ inventory_hostname }}:8081'
          notify: reload nginx
          
      rescue:
        - name: 发布失败回滚
          debug:
            msg: "部署失败，保持蓝色环境运行"
            
        - fail:
            msg: "发布失败，已停止发布流程"
```

### 7.3 开发环境vs生产环境配置差异


**开发环境配置**：
```ini
# 开发环境 ansible.cfg
[defaults]
error_on_undefined_vars = True    # 严格检查，便于发现问题
retry_files_enabled = True        # 启用重试文件
host_key_checking = False         # 跳过SSH密钥检查
```

**生产环境配置**：
```ini  
# 生产环境 ansible.cfg
[defaults]
error_on_undefined_vars = False   # 容错模式
retry_files_enabled = True        # 必须启用重试
host_key_checking = True          # 严格SSH检查
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心配置


```
🔸 基础控制：error_on_undefined_vars, any_errors_fatal, max_fail_percentage
🔸 条件处理：ignore_errors, failed_when, changed_when  
🔸 结构化处理：block/rescue/always 任务块
🔸 重试机制：retry_files_enabled, retry_files_save_path
🔸 性能优化：fact_caching, gather_subset
```

### 8.2 关键理解要点


**🔹 错误处理的层次性**
```
理解要点：
- 全局配置影响所有playbook
- playbook配置影响该文件中的所有任务  
- 任务级配置只影响单个任务
- 优先级：任务级 > playbook级 > 全局级
```

**🔹 容错与严格的平衡**
```
开发阶段：严格模式，快速发现问题
测试阶段：混合模式，模拟真实环境
生产阶段：容错模式，保证服务稳定
```

**🔹 性能与可靠性的权衡**
```
性能优先：
- 缓存facts，减少收集时间
- 并行执行，提高处理速度
- 忽略非关键错误

可靠性优先：  
- 严格错误检查
- 完整的救援机制
- 详细的日志记录
```

### 8.3 实际应用指导原则


**📊 配置选择矩阵**：

| 场景类型 | **any_errors_fatal** | **max_fail_percentage** | **ignore_errors** | **适用原因** |
|---------|---------------------|------------------------|------------------|-------------|
| 数据库集群 | `true` | `0` | `false` | 数据一致性要求高 |
| Web服务器 | `false` | `20-30` | 按需 | 允许部分失败 |
| 监控部署 | `false` | `50` | `true` | 非关键服务 |
| 安全更新 | `true` | `10` | `false` | 安全优先 |

**🎯 最佳实践建议**：

> ✅ **DO - 推荐做法**：
> - 根据业务重要性设定不同的容错级别
> - 使用block/rescue结构处理复杂部署逻辑
> - 启用重试文件功能，便于问题排查
> - 合理使用facts缓存提高性能

> ❌ **DON'T - 避免做法**：
> - 不要在所有地方都使用ignore_errors  
> - 不要设置过高的max_fail_percentage
> - 不要忽视failed_when的业务逻辑
> - 不要在生产环境关闭重试文件功能

### 8.4 故障排查思路


**错误处理故障排查流程**：
```
1. 查看重试文件 → 确定失败主机范围
2. 检查任务日志 → 分析具体失败原因  
3. 验证配置逻辑 → 确认错误处理是否合理
4. 测试救援机制 → 验证rescue任务有效性
5. 优化配置参数 → 根据实际情况调整
```

**常见问题与解决方案**：

| 问题现象 | **可能原因** | **解决方案** |
|---------|-------------|-------------|
| 任务莫名停止 | `any_errors_fatal=true` | 调整为false或降低阈值 |
| 救援任务不执行 | block结构错误 | 检查YAML语法和缩进 |
| 重试文件未生成 | 功能被关闭 | 启用`retry_files_enabled` |
| Handler未执行 | 任务失败导致跳过 | 使用`force_handlers=true` |

**核心记忆**：
- 错误处理如安全带，关键时刻保平安
- 容错配置需平衡，业务场景来决断  
- 结构化处理最优雅，block救援总执行
- 重试缓存提性能，生产环境必须有