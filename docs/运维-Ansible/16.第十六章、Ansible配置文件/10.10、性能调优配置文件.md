---
title: 10、性能调优配置文件
---
## 📚 目录

1. [性能调优配置概述](#1-性能调优配置概述)
2. [并行执行配置](#2-并行执行配置)
3. [执行策略配置](#3-执行策略配置)
4. [连接优化配置](#4-连接优化配置)
5. [事实收集优化](#5-事实收集优化)
6. [异步执行配置](#6-异步执行配置)
7. [性能监控与调试](#7-性能监控与调试)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 性能调优配置概述


### 1.1 什么是性能调优配置


**简单理解**：性能调优配置就像是给Ansible装上"加速器"，让它在管理多台服务器时跑得更快更稳。

```
未优化的Ansible：        优化后的Ansible：
服务器1 → 等待 → 服务器2    服务器1 ┐
                         服务器2 ├─ 同时执行
慢如蜗牛 😫                服务器3 ┘ 
                         快如闪电 ⚡
```

### 1.2 性能优化的核心思路


**🔸 并行化思维**
- **原理**：同时对多台服务器执行任务，而不是一台一台来
- **好处**：10台服务器的任务从10分钟缩短到2分钟
- **关键**：合理设置并行数量，避免网络拥堵

**🔸 策略优化思维**
- **原理**：选择最适合的执行策略
- **好处**：根据场景选择串行、并行或混合模式
- **关键**：理解不同策略的适用场景

### 1.3 配置文件位置


```
主配置文件优先级（从高到低）：
①  当前目录/ansible.cfg     ← 项目专用配置
②  ~/.ansible.cfg          ← 个人用户配置
③  /etc/ansible/ansible.cfg ← 系统全局配置

查看当前生效配置：
$ ansible --version
```

---

## 2. ⚡ 并行执行配置


### 2.1 forks - 并行进程数配置


**🔸 概念解释**
```
forks = 同时执行任务的进程数量

想象场景：
你要给100台服务器安装软件
- forks=5：  同时处理5台，需要20轮
- forks=20： 同时处理20台，需要5轮
- forks=50： 同时处理50台，需要2轮
```

**🔧 配置方法**
```ini
[defaults]
# 默认值是5，可以根据需要调整
forks = 20

# 命令行临时指定
$ ansible-playbook -f 30 playbook.yml
```

**📊 性能对比示例**

| forks值 | 100台服务器耗时 | 内存占用 | 网络负载 | **推荐场景** |
|---------|----------------|----------|----------|-------------|
| `5`     | `~20分钟`      | `低`     | `轻`     | `网络较慢或配置较低的控制机` |
| `20`    | `~5分钟`       | `中等`   | `适中`   | `日常运维推荐设置` |
| `50`    | `~2分钟`       | `高`     | `重`     | `高性能环境批量部署` |
| `100`   | `~1分钟`       | `很高`   | `很重`   | `强劲硬件+高速网络` |

**💡 选择建议**
```
新手建议：
- 小于50台服务器：forks = 10-20
- 50-200台服务器：forks = 20-30  
- 200台以上：forks = 30-50

硬件参考：
- 2核4G控制机：forks ≤ 10
- 4核8G控制机：forks ≤ 30
- 8核16G控制机：forks ≤ 50
```

### 2.2 serial - 串行执行控制


**🔸 概念解释**
```
serial = 控制每批处理多少台服务器

与forks的区别：
- forks：每批内部并行处理的数量
- serial：每批包含多少台服务器

实际效果：
100台服务器，serial=10，forks=5
┌─批次1(10台)─┐  ┌─批次2(10台)─┐
│ 5台并行处理  │→│ 5台并行处理  │→ ...
│ 等5台完成再 │  │ 等5台完成再 │
│ 处理下5台   │  │ 处理下5台   │
└─────────────┘  └─────────────┘
```

**🔧 配置方法**
```yaml
# playbook中配置
- hosts: webservers
  serial: 3        # 每批3台服务器
  tasks:
    - name: 重启服务
      service:
        name: nginx
        state: restarted

# 百分比配置
- hosts: webservers  
  serial: "30%"      # 每批处理30%的服务器
  
# 批次递增配置
- hosts: webservers
  serial:           # 先1台，再3台，然后5台
    - 1
    - 3  
    - 5
```

**🎯 应用场景**
```
✅ 适合serial的场景：
- 服务重启：避免所有服务同时停止
- 数据库升级：确保逐步验证无误  
- 负载均衡更新：保持服务可用性

❌ 不适合serial的场景：
- 配置文件更新：可以全并行
- 软件包安装：并行更高效
- 信息收集：并行速度快
```

---

## 3. 🎛️ 执行策略配置


### 3.1 strategy - 执行策略选择


**🔸 策略对比图**
```
Linear Strategy（线性策略 - 默认）：
主机A: ■■■■■■■■ (任务1→2→3→4)
主机B: ■■■■■■■■ (任务1→2→3→4)  
主机C: ■■■■■■■■ (任务1→2→3→4)
特点：所有主机同步执行每个任务

Free Strategy（自由策略）：
主机A: ■■■■■■■■ (任务1→2→3→4)
主机B:   ■■■■■■ (任务1→3→4，跳过任务2)
主机C: ■■■■■■■■ (任务1→2→3→4)
特点：主机各自按速度执行，不等待
```

### 3.2 linear_strategy - 线性策略（默认）


**🔸 工作原理**
```ini
[defaults]  
strategy = linear

# 或在playbook中指定
- hosts: all
  strategy: linear
```

**特点说明**：
- **同步执行**：所有主机必须完成任务1，才能开始任务2
- **适合场景**：需要严格顺序的部署流程
- **缺点**：慢的主机会拖慢整体进度

```
实际场景举例：
数据库集群部署
1. 所有节点先停止服务    ← 必须全部完成
2. 所有节点更新配置      ← 必须全部完成  
3. 所有节点启动服务      ← 必须全部完成
这种场景需要线性策略保证同步
```

### 3.3 free_strategy - 自由策略


**🔸 配置和特点**
```yaml
- hosts: all
  strategy: free
  tasks:
    - name: 安装软件包
      yum: name=nginx state=present
    - name: 启动服务
      service: name=nginx state=started
```

**工作方式**：
- **异步执行**：每台主机按自己的速度执行
- **不等待**：快的主机不等慢的主机
- **提高效率**：整体执行时间由最慢的主机决定

**📈 性能提升示例**
```
100台服务器安装软件包：

Linear策略：
最快主机: 2分钟完成所有任务
最慢主机: 10分钟完成所有任务  
总耗时: 10分钟（等最慢的）

Free策略：
最快主机: 2分钟完成，立即结束
最慢主机: 10分钟完成
总耗时: 仍然10分钟，但平均响应更快
```

### 3.4 mitogen_strategy - Mitogen策略


**🔸 概念解释**
Mitogen是一个第三方插件，能大幅提升Ansible性能，特别是Python模块执行效率。

**安装配置**：
```bash
# 安装mitogen
$ pip install mitogen

# 配置ansible.cfg
[defaults]
strategy_plugins = /path/to/mitogen/ansible_mitogen/plugins/strategy
strategy = mitogen_linear
```

**📊 性能对比**
```
传统执行方式：
控制机 → SSH连接 → 传输Python代码 → 目标机执行 → 返回结果
每个任务都重复这个过程

Mitogen优化后：
控制机 → 建立持久连接 → 复用Python解释器 → 快速执行
减少连接开销和代码传输
```

**性能提升数据**：
- **连接速度**：提升 3-10倍
- **模块执行**：提升 2-5倍  
- **内存占用**：降低 50%

---

## 4. 🔌 连接优化配置


### 4.1 pipelining - SSH流水线优化


**🔸 概念理解**
```
未开启pipelining：           开启pipelining：
1. SSH连接                   1. SSH连接
2. 传输模块                   2. 模块+数据一起传输  
3. 传输数据                   3. 直接执行
4. 执行                      4. 返回结果
5. 返回结果

减少了网络往返次数！
```

**🔧 配置方法**
```ini
[ssh_connection]
pipelining = True

# 注意：需要目标机器禁用sudo的requiretty
# 在目标机器/etc/sudoers中添加：
# Defaults !requiretty
```

**⚠️ 使用条件**
```
✅ 适用环境：
- SSH密钥认证已配置
- 目标系统支持
- sudo不要求tty

❌ 不适用：
- 使用密码认证
- sudo需要交互
- 旧版本系统
```

### 4.2 连接复用配置


**🔸 SSH连接复用**
```ini
[ssh_connection]
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o ControlPath=/tmp/ansible-%r@%h:%p
```

**工作原理**：
- **ControlMaster=auto**：自动建立主连接
- **ControlPersist=60s**：连接保持60秒
- **ControlPath**：连接控制文件路径

```
效果对比：
普通连接：每个任务建立新SSH连接
复用连接：多个任务共享一个SSH连接
性能提升：减少连接建立时间50-80%
```

### 4.3 连接插件优化


**🔸 可选连接插件**
```ini
[defaults]
# 默认SSH连接
transport = ssh

# 可选的连接插件
connection_plugins = /path/to/plugins/connection

# 本地连接（调试用）
transport = local

# Paramiko连接（纯Python SSH）
transport = paramiko
```

---

## 5. 📊 事实收集优化


### 5.1 gathering - 事实收集模式


**🔸 收集模式对比**
```ini
[defaults]
# 智能收集（推荐）- 只在需要时收集
gathering = smart

# 总是收集 - 每次都收集
gathering = implicit  

# 从不收集 - 完全禁用
gathering = explicit
```

**📈 性能影响**
```
100台服务器事实收集耗时：
- implicit（总是）: ~3-5分钟
- smart（智能）:    ~30秒-2分钟  
- explicit（禁用）: ~5秒

选择建议：
✅ smart：日常推荐，平衡性能和功能
✅ explicit：纯配置推送场景
❌ implicit：除非确实需要最新facts
```

### 5.2 fact_caching - 事实缓存


**🔸 缓存类型配置**
```ini
[defaults]
# 启用缓存
fact_caching = jsonfile
fact_caching_connection = /tmp/ansible_facts_cache
fact_caching_timeout = 3600

# 其他缓存后端
fact_caching = redis
fact_caching_connection = redis://localhost:6379/0

fact_caching = memcached  
fact_caching_connection = localhost:11211
```

**🔧 缓存工作流程**
```
第一次执行：
收集facts → 存储到缓存 → 执行任务
耗时：正常收集时间

后续执行（缓存有效期内）：
读取缓存facts → 直接执行任务
耗时：节省60-80%收集时间
```

### 5.3 缓存管理命令


```bash
# 查看缓存内容
$ ansible-inventory --list

# 清除特定主机缓存
$ ansible hostname -m setup -a 'filter=ansible_facts'

# 清除所有缓存（jsonfile类型）
$ rm -rf /tmp/ansible_facts_cache/*
```

---

## 6. ⏱️ 异步执行配置


### 6.1 async_timeout - 异步超时设置


**🔸 概念理解**
```
同步执行：               异步执行：
任务开始 → 等待完成 → 下个任务    任务开始 → 立即返回job_id → 继续其他工作
              ↓                           ↓
         可能卡住很久              后台运行，定期检查状态
```

**🔧 配置方法**
```yaml
# playbook中的异步任务
- name: 长时间运行的任务
  command: /path/to/long_running_script.sh
  async: 300        # 最长运行5分钟
  poll: 10          # 每10秒检查一次状态
  
# 完全异步，不等待结果  
- name: 启动后台服务
  service: name=myapp state=started
  async: 0          # 不限制时间
  poll: 0           # 不检查状态，立即继续
```

### 6.2 poll_interval - 轮询间隔


**📊 轮询策略对比**

| poll值 | **行为** | **适用场景** | **优缺点** |
|--------|----------|-------------|-----------|
| `0` | `不等待，立即继续` | `启动服务、后台任务` | `最快，但无法获取结果` |
| `5` | `每5秒检查一次` | `快速任务（<1分钟）` | `响应快，检查频繁` |
| `30` | `每30秒检查一次` | `中等任务（几分钟）` | `平衡性能和及时性` |
| `60` | `每60秒检查一次` | `长任务（>10分钟）` | `减少检查开销` |

**🎯 实际应用示例**
```yaml
- name: 数据库备份任务
  shell: mysqldump --all-databases > backup.sql
  async: 1800       # 30分钟超时
  poll: 60          # 每分钟检查一次
  
- name: 软件包更新
  yum: name=* state=latest
  async: 600        # 10分钟超时  
  poll: 30          # 每30秒检查

- name: 重启服务（不等待）
  service: name=nginx state=restarted
  async: 0
  poll: 0
```

---

## 7. 🔍 性能监控与调试


### 7.1 性能分析配置


**🔧 启用性能分析**
```ini
[defaults]
# 启用回调插件
callback_plugins = /usr/share/ansible/plugins/callback
callbacks_enabled = timer, profile_tasks

# 详细输出
verbosity = 2

# 显示任务执行时间
[callback_profile_tasks]
task_output_limit = 20
sort_order = descending
```

**📊 性能监控输出示例**
```bash
$ ansible-playbook site.yml

PLAY RECAP *************************************************
TASK [收集系统信息] ***************************** 15.32s
TASK [安装软件包] ******************************* 8.45s  
TASK [配置文件更新] ****************************** 2.13s
TASK [重启服务] ********************************* 1.05s

主机性能统计：
server1 : ok=4  changed=2  时间=18.23s
server2 : ok=4  changed=2  时间=16.87s
server3 : ok=4  changed=1  时间=12.45s
```

### 7.2 调试和优化技巧


**💡 常用调试方法**
```bash
# 详细执行信息
$ ansible-playbook -vvv playbook.yml

# 检查配置生效情况
$ ansible-config dump | grep forks
$ ansible-config dump | grep strategy

# 测试连接性能
$ time ansible all -m ping -f 50

# 分析任务执行时间
$ ANSIBLE_CALLBACK_PLUGINS=~/.ansible/plugins/callback \
  ANSIBLE_STDOUT_CALLBACK=profile_tasks \
  ansible-playbook playbook.yml
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心配置


```
🔸 并行配置：forks控制同时处理的主机数量
🔸 执行策略：linear vs free适用不同场景
🔸 连接优化：pipelining和连接复用提升网络效率
🔸 事实缓存：smart gathering + 缓存避免重复收集
🔸 异步执行：长时间任务使用async/poll机制
```

### 8.2 关键理解要点


**🔹 性能调优的平衡艺术**
```
并行度 vs 稳定性：
- 并行度高：速度快，但可能不稳定
- 并行度低：稳定，但速度慢  
- 最佳实践：根据硬件和网络条件找平衡点

缓存 vs 准确性：
- 启用缓存：快速，但可能数据不是最新
- 禁用缓存：准确，但每次都收集事实
- 最佳实践：使用smart策略
```

**🔹 不同场景的优化策略**
```
开发环境：
- forks=10, gathering=explicit
- 快速验证，不需要完整事实收集

生产部署：  
- forks=20, strategy=linear, caching=enabled
- 稳定可靠，带事实缓存

批量运维：
- forks=50, strategy=free, pipelining=true
- 追求最高效率
```

### 8.3 实际应用指导


**🎯 新手推荐配置**
```ini
[defaults]
forks = 20
gathering = smart
strategy = linear

[ssh_connection]  
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s

[callback_profile_tasks]
task_output_limit = 20
```

**⚠️ 常见错误和解决**
```
问题1：设置forks过高导致系统卡死
解决：从小值开始逐步调整，监控系统资源

问题2：pipelining启用后sudo报错
解决：目标机器sudo配置添加 Defaults !requiretty

问题3：异步任务无法获取结果
解决：设置合适的poll值，不要使用poll=0
```

**🚀 优化效果预期**
```
优化前：100台服务器批量操作需要30-60分钟
优化后：100台服务器批量操作缩短到5-15分钟
提升倍数：3-5倍性能提升是常见效果
```

**核心记忆口诀**：
- 并行设置要适中，过多过少都不行
- 策略选择看场景，同步异步有区别  
- 连接复用加流水，网络效率大提升
- 事实缓存要智能，避免重复做收集