---
title: 3、import-导入机制
---
## 📚 目录

1. [导入机制核心概念](#1-导入机制核心概念)
2. [import_tasks任务导入](#2-import_tasks任务导入)
3. [import_playbook剧本导入](#3-import_playbook剧本导入)
4. [import_role角色导入](#4-import_role角色导入)
5. [静态导入特点深度解析](#5-静态导入特点深度解析)
6. [import vs include核心区别](#6-import-vs-include核心区别)
7. [性能影响与优化策略](#7-性能影响与优化策略)
8. [变量作用域与传递机制](#8-变量作用域与传递机制)
9. [最佳实践与设计模式](#9-最佳实践与设计模式)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 导入机制核心概念


### 1.1 什么是Ansible导入机制


**核心定义**：导入机制是Ansible用来**组织和重用代码**的方式，就像搭积木一样，把小的代码块组合成大的功能模块。

> 💡 **生活类比**：想象你在做菜，导入机制就像是把常用的调料包、酱汁配方等提前准备好，做不同菜的时候直接拿来用，而不用每次都重新调配。

**三种主要导入方式对比**：

```
功能模块化组织：
┌─────────────────┐
│   主剧本文件     │
├─────────────────┤
│ import_tasks    │ ←── 导入具体任务
│ import_playbook │ ←── 导入完整剧本  
│ import_role     │ ←── 导入角色模块
└─────────────────┘
```

### 1.2 为什么需要导入机制


**解决的核心问题**：

🔸 **代码重复**：避免在多个地方写相同的任务
```yaml
# 不使用导入 - 重复代码
- name: 部署应用A
  hosts: web1
  tasks:
    - name: 安装nginx
      yum: name=nginx state=present
    - name: 启动nginx  
      service: name=nginx state=started

- name: 部署应用B  
  hosts: web2
  tasks:
    - name: 安装nginx    # 重复了！
      yum: name=nginx state=present
    - name: 启动nginx    # 重复了！
      service: name=nginx state=started
```

🔸 **管理复杂性**：把大任务拆分成小模块，便于维护
🔸 **团队协作**：不同人负责不同模块，最后组合起来
🔸 **版本控制**：每个模块独立管理和更新

### 1.3 导入机制的基本原理


**静态解析原理**：
```
Ansible执行流程：
1. 读取主剧本文件
2. 解析import语句  
3. 在执行前就把导入的内容"复制粘贴"进来
4. 形成一个完整的大剧本再执行

就像编程中的"预处理"一样！
```

---

## 2. 📋 import_tasks任务导入


### 2.1 基本语法与使用


**核心语法**：
```yaml
- import_tasks: 任务文件路径
  vars:           # 可选：传递变量
    变量名: 值
  tags:           # 可选：添加标签
    - 标签名
  when: 条件     # 可选：条件执行
```

### 2.2 实际使用示例


**场景：Web服务器部署中的任务模块化**

**主剧本文件** (`deploy_web.yml`)：
```yaml
---
- name: 部署Web服务器
  hosts: webservers
  become: yes
  
  tasks:
    # 导入系统准备任务
    - import_tasks: tasks/system_prep.yml
      tags: [system, prep]
    
    # 导入nginx安装任务  
    - import_tasks: tasks/nginx_install.yml
      vars:
        nginx_port: 8080
        nginx_user: www-data
      tags: [nginx, install]
    
    # 导入应用部署任务
    - import_tasks: tasks/app_deploy.yml
      when: deploy_app | default(true)
      tags: [app, deploy]
```

**系统准备任务** (`tasks/system_prep.yml`)：
```yaml
---
# 系统准备相关任务
- name: 更新系统包缓存
  apt:
    update_cache: yes
    cache_valid_time: 3600

- name: 安装基础依赖包
  apt:
    name:
      - curl
      - wget  
      - unzip
    state: present

- name: 创建应用用户
  user:
    name: appuser
    home: /opt/app
    shell: /bin/bash
    system: yes
```

**Nginx安装任务** (`tasks/nginx_install.yml`)：
```yaml
---
# Nginx安装配置任务
- name: 安装nginx
  apt:
    name: nginx
    state: present

- name: 配置nginx端口
  lineinfile:
    path: /etc/nginx/sites-available/default
    regexp: 'listen 80'
    line: "listen {{ nginx_port | default(80) }}"
  notify: restart nginx

- name: 设置nginx运行用户
  lineinfile:  
    path: /etc/nginx/nginx.conf
    regexp: '^user'
    line: "user {{ nginx_user | default('www-data') }};"
  notify: restart nginx
```

### 2.3 import_tasks的核心特点


**🔹 路径解析**：
- **相对路径**：相对于主剧本文件的位置
- **绝对路径**：从系统根目录开始
- **最佳实践**：使用相对路径，便于项目迁移

```yaml
# 推荐的目录结构
project/
├── deploy.yml          # 主剧本
├── tasks/             # 任务目录
│   ├── common.yml
│   ├── database.yml
│   └── webserver.yml
└── vars/              # 变量目录
    └── main.yml
```

**🔹 变量传递机制**：
```yaml
- import_tasks: tasks/database.yml
  vars:
    db_name: "{{ app_name }}_production"
    db_user: "{{ app_name }}_user"  
    db_password: "{{ vault_db_password }}"
    
# database.yml文件中可以直接使用这些变量
- name: 创建数据库
  mysql_db:
    name: "{{ db_name }}"      # 使用传递的变量
    state: present
```

---

## 3. 🎭 import_playbook剧本导入


### 3.1 剧本导入的应用场景


**典型使用场景**：把复杂的部署流程拆分成多个独立的剧本文件

```
完整部署流程：
┌──────────────────┐
│   master.yml     │ 主控剧本
├──────────────────┤
│ ├─ prepare.yml   │ 环境准备
│ ├─ database.yml  │ 数据库部署  
│ ├─ backend.yml   │ 后端服务
│ └─ frontend.yml  │ 前端部署
└──────────────────┘
```

### 3.2 实际部署示例


**主控剧本** (`master.yml`)：
```yaml
---
# 完整的应用部署流程
- import_playbook: prepare.yml        # 环境准备
- import_playbook: database.yml       # 数据库部署
- import_playbook: backend.yml        # 后端服务
- import_playbook: frontend.yml       # 前端部署
- import_playbook: monitoring.yml     # 监控配置
```

**环境准备剧本** (`prepare.yml`)：
```yaml
---
- name: 环境准备阶段
  hosts: all
  become: yes
  
  tasks:
    - name: 同步系统时间
      timezone:
        name: Asia/Shanghai
    
    - name: 配置系统限制
      pam_limits:
        domain: '*'
        limit_type: soft
        limit_item: nofile
        value: '65536'
```

**数据库部署剧本** (`database.yml`)：
```yaml
---
- name: 数据库部署阶段
  hosts: db_servers
  become: yes
  
  vars:
    mysql_root_password: "{{ vault_mysql_root_password }}"
    
  tasks:
    - name: 安装MySQL服务器
      apt:
        name: mysql-server
        state: present
        
    - name: 配置MySQL安全设置
      mysql_user:
        name: root
        password: "{{ mysql_root_password }}"
        state: present
```

### 3.3 剧本导入的优势


**🎯 模块化管理**：
- 每个剧本专注单一职责
- 可以独立测试和调试
- 便于团队分工合作

**🎯 流程控制**：
```yaml
# 可以在剧本级别添加条件
- import_playbook: database.yml
  when: setup_database | default(true)
  
- import_playbook: optional_services.yml  
  when: environment == 'production'
```

---

## 4. 🎪 import_role角色导入


### 4.1 角色导入的核心概念


**角色的本质**：角色是Ansible中**最高级别的代码组织方式**，它把任务、变量、模板、文件等都打包在一起，形成一个完整的功能模块。

> 🎭 **戏剧类比**：就像戏剧中的角色，每个角色都有自己的台词(任务)、道具(文件)、服装(模板)，角色之间协作完成整部戏(系统部署)。

### 4.2 标准角色结构


```
角色目录结构：
roles/nginx/
├── tasks/          # 任务文件
│   └── main.yml
├── handlers/       # 处理器
│   └── main.yml  
├── templates/      # 模板文件
│   └── nginx.conf.j2
├── files/         # 静态文件
│   └── index.html
├── vars/          # 变量文件
│   └── main.yml
├── defaults/      # 默认变量
│   └── main.yml
└── meta/          # 元数据
    └── main.yml
```

### 4.3 角色导入实战示例


**主剧本使用角色**：
```yaml
---
- name: 部署LAMP架构
  hosts: webservers
  become: yes
  
  roles:
    # 方式1：简单导入
    - common
    - mysql
    - php
    - nginx
    
    # 方式2：使用import_role导入(更灵活)  
    - import_role:
        name: nginx
      vars:
        nginx_port: 8080
        nginx_worker_processes: 4
      tags: [nginx, webserver]
      
    - import_role:
        name: mysql  
      vars:
        mysql_root_password: "{{ vault_mysql_password }}"
        mysql_databases:
          - name: webapp
            encoding: utf8
      when: setup_database | default(true)
```

**Nginx角色示例** (`roles/nginx/tasks/main.yml`)：
```yaml
---
# Nginx角色的主要任务
- name: 安装nginx
  package:
    name: nginx
    state: present

- name: 创建nginx配置
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    backup: yes
  notify: restart nginx

- name: 启动并启用nginx服务
  service:
    name: nginx 
    state: started
    enabled: yes

- name: 开放防火墙端口
  firewalld:
    port: "{{ nginx_port | default(80) }}/tcp"
    permanent: yes
    state: enabled
    immediate: yes
  when: ansible_os_family == "RedHat"
```

### 4.4 角色导入的高级特性


**🔸 角色依赖管理** (`roles/nginx/meta/main.yml`)：
```yaml
---
dependencies:
  - role: common          # nginx依赖common角色
    vars:
      common_packages:
        - curl
        - wget
  - role: firewall        # nginx依赖防火墙配置
    vars:
      firewall_ports:
        - 80
        - 443
```

**🔸 角色参数化** (`roles/nginx/defaults/main.yml`)：
```yaml
---
# 默认变量，可以被覆盖
nginx_port: 80
nginx_user: nginx
nginx_worker_processes: "{{ ansible_processor_vcpus }}"
nginx_worker_connections: 1024
nginx_keepalive_timeout: 65

# 默认配置
nginx_sites:
  - name: default
    port: "{{ nginx_port }}"
    root: /var/www/html
```

---

## 5. ⚡ 静态导入特点深度解析


### 5.1 什么是静态导入


**静态导入的本质**：在Ansible**解析阶段**就把导入的内容完全展开，就像把外部文件的内容直接复制粘贴到当前位置一样。

**静态vs动态对比**：
```
静态导入(import)：
┌─────────────────┐
│ 解析阶段：      │
│ main.yml       │
│ ├─ task1       │
│ ├─ import_tasks│ ──→ 展开为具体任务
│ │  └─ task2    │     
│ │  └─ task3    │     
│ └─ task4       │
└─────────────────┘

动态包含(include)：
┌─────────────────┐
│ 执行阶段：      │  
│ main.yml       │
│ ├─ task1       │
│ ├─ include_tasks│ ──→ 运行时才加载
│ └─ task4       │     
└─────────────────┘
```

### 5.2 静态导入的核心特征


**🔹 预处理特性**：
```yaml
# 主文件
- debug: msg="开始执行"
- import_tasks: subtasks.yml
- debug: msg="结束执行"

# 实际执行时等同于：
- debug: msg="开始执行"  
- debug: msg="这是子任务1"    # 来自subtasks.yml
- debug: msg="这是子任务2"    # 来自subtasks.yml
- debug: msg="结束执行"
```

**🔹 语法检查优势**：
```bash
# 静态导入可以做完整的语法检查
ansible-playbook --syntax-check main.yml
# 会检查所有导入的文件语法

# 动态包含无法完全检查
# 因为执行前不知道具体会包含哪些文件
```

**🔹 变量解析时机**：
```yaml
# 变量在解析阶段就确定了
- set_fact:
    task_file: "production_tasks.yml"

- import_tasks: "{{ task_file }}"  # 解析阶段确定文件名

# 如果task_file在运行时才有值，import会失败
# 应该用include_tasks
```

### 5.3 静态导入的限制与注意事项


**⚠️ 主要限制**：

| 限制类型 | **具体表现** | **解决方案** |
|---------|-------------|-------------|
| **变量动态性** | `无法使用运行时才确定的变量作为文件名` | `使用include_tasks代替` |
| **条件执行** | `when条件应用于所有导入的任务` | `在导入的文件内部使用when` |
| **循环限制** | `不支持loop等循环结构` | `使用include_tasks配合loop` |
| **标签继承** | `标签会应用到所有导入的任务` | `合理规划标签体系` |

**具体示例**：
```yaml
# ❌ 错误用法：运行时变量
- set_fact:
    env: "{{ ansible_hostname | regex_replace('.*-(.*)$', '\\1') }}"
- import_tasks: "tasks/{{ env }}.yml"  # 会失败

# ✅ 正确用法：预定义变量
vars:
  env: production
tasks:
  - import_tasks: "tasks/{{ env }}.yml"  # 正常工作
```

---

## 6. 🔄 import vs include核心区别


### 6.1 两种机制的根本差异


**时间差异**：这是最核心的区别
```
Import（导入）- 编译时：
时间轴：解析 ────→ 执行
       ↑
    在这里展开所有内容

Include（包含）- 运行时：
时间轴：解析 ────→ 执行
                 ↑  
              在这里动态加载
```

### 6.2 功能特性对比表


| 特性维度 | **import_*** | **include_*** |
|---------|-------------|---------------|
| **解析时机** | `编译时静态解析` | `运行时动态加载` |
| **语法检查** | `完整检查所有内容` | `只检查主文件` |
| **变量支持** | `仅支持解析时已知变量` | `支持运行时变量` |
| **循环支持** | `❌ 不支持` | `✅ 支持loop` |
| **条件执行** | `条件应用于整个导入块` | `每次包含独立判断` |
| **性能** | `解析慢，执行快` | `解析快，执行慢` |
| **调试** | `更容易追踪任务来源` | `需要动态查看包含内容` |

### 6.3 使用场景选择指南


**选择import的场景**：
```yaml
# ✅ 固定的任务序列
- import_tasks: tasks/common_setup.yml

# ✅ 预定义的配置  
vars:
  web_type: nginx
tasks:
  - import_tasks: "tasks/{{ web_type }}_setup.yml"

# ✅ 需要完整语法检查的生产环境
- import_playbook: production_deploy.yml
```

**选择include的场景**：
```yaml
# ✅ 基于条件动态选择
- include_tasks: "tasks/{{ ansible_os_family | lower }}.yml"

# ✅ 循环执行
- include_tasks: setup_vhost.yml  
  loop:
    - site1.com
    - site2.com  
  loop_control:
    loop_var: domain

# ✅ 运行时才能确定的文件
- include_tasks: "{{ item }}"
  with_fileglob:
    - "tasks/feature_*.yml"
```

### 6.4 混合使用策略


**最佳实践**：在同一个项目中合理组合两种机制

```yaml
---
- name: 智能化部署策略
  hosts: webservers
  
  tasks:
    # 使用import处理固定的基础任务
    - import_tasks: tasks/system_base.yml
      tags: [base, always]
    
    # 使用include处理动态选择
    - include_tasks: "tasks/{{ ansible_os_family | lower }}_specific.yml"
      tags: [os_specific]
    
    # 使用include处理循环场景  
    - include_tasks: tasks/setup_service.yml
      vars:
        service_name: "{{ item.name }}"
        service_port: "{{ item.port }}"
      loop:
        - { name: web, port: 80 }
        - { name: api, port: 8080 }
      tags: [services]
```

---

## 7. 🚀 性能影响与优化策略


### 7.1 性能影响分析


**解析阶段性能**：
```
Import性能特征：
┌─────────────────┐
│ 解析阶段较慢    │ ← 需要读取和解析所有文件
├─────────────────┤
│ 执行阶段较快    │ ← 任务已经完全准备好
└─────────────────┘

Include性能特征：  
┌─────────────────┐
│ 解析阶段较快    │ ← 只解析主文件
├─────────────────┤  
│ 执行阶段较慢    │ ← 需要动态加载文件
└─────────────────┘
```

**内存占用对比**：
```yaml
# Import - 内存占用示例
# 假设导入100个任务文件，每个10KB
# 解析后内存占用：100 × 10KB = 1MB（一次性加载）

# Include - 内存占用示例  
# 同样的任务，执行时逐个加载
# 内存占用：10KB × 加载频次（可能重复加载）
```

### 7.2 性能优化策略


**🔹 合理选择导入方式**：
```yaml
# 大量重复任务 - 推荐import
- import_tasks: tasks/bulk_operations.yml  # 一次解析，多次复用

# 条件性任务 - 推荐include
- include_tasks: tasks/optional_feature.yml
  when: enable_feature | default(false)  # 避免无效解析
```

**🔹 文件组织优化**：
```yaml
# ❌ 低效：过度细分文件
tasks/
├── install_package1.yml    # 只有1个任务
├── install_package2.yml    # 只有1个任务  
└── install_package3.yml    # 只有1个任务

# ✅ 高效：合理归类
tasks/
├── system_packages.yml     # 相关任务归类
├── application_setup.yml   # 功能模块归类
└── service_config.yml      # 配置任务归类
```

**🔹 缓存和预处理**：
```yaml
# 预先设置常用变量，减少重复解析
vars:
  common_packages:
    - curl
    - wget
    - unzip
  service_configs:
    - nginx
    - mysql
    - redis
    
tasks:
  - import_tasks: tasks/packages.yml    # 使用预定义变量
  - import_tasks: tasks/services.yml    # 减少解析开销
```

### 7.3 性能监控与调试


**性能分析工具**：
```bash
# 启用时间统计
export ANSIBLE_CALLBACKS_ENABLED=timer
ansible-playbook deploy.yml

# 启用性能分析
export ANSIBLE_CALLBACKS_ENABLED=profile_tasks
ansible-playbook deploy.yml -v

# 查看详细执行时间
ansible-playbook deploy.yml -vvv --diff
```

---

## 8. 🔧 变量作用域与传递机制


### 8.1 变量作用域基本原理


**作用域层次结构**：
```
变量优先级（从高到低）：
┌─────────────────────┐
│ 命令行传递变量(-e)   │ ← 最高优先级
├─────────────────────┤
│ import时传递的vars  │
├─────────────────────┤  
│ 剧本中定义的vars    │
├─────────────────────┤
│ 角色中的vars/       │
├─────────────────────┤
│ 角色中的defaults/   │ ← 最低优先级
└─────────────────────┘
```

### 8.2 变量传递实战示例


**主剧本变量传递**：
```yaml
---
- name: 变量传递示例
  hosts: webservers
  vars:
    global_app_name: "myapp"
    global_version: "2.1.0"
    
  tasks:
    - import_tasks: tasks/database.yml
      vars:
        db_name: "{{ global_app_name }}_db"      # 传递组合变量
        db_version: "{{ global_version }}"        # 传递全局变量
        db_port: 3306                            # 传递固定值
        db_backup: true                          # 传递布尔值
```

**接收变量的任务文件** (`tasks/database.yml`)：
```yaml
---
# 这些变量来自导入时的传递
- name: 创建数据库
  mysql_db:
    name: "{{ db_name }}"           # myapp_db
    state: present
    
- name: 显示数据库配置信息
  debug:
    msg: |
      数据库配置:
      - 名称: {{ db_name }}
      - 版本: {{ db_version }}  
      - 端口: {{ db_port }}
      - 备份: {{ db_backup }}
```

### 8.3 变量作用域的实际影响


**🔹 变量覆盖示例**：
```yaml
# 主剧本
vars:
  app_port: 80                    # 全局定义

tasks:
  - import_tasks: tasks/setup.yml
    vars:
      app_port: 8080              # 局部覆盖
      
  - debug: 
      msg: "全局端口: {{ app_port }}"  # 输出：80（全局变量不受影响）
```

**🔹 变量继承链**：
```yaml
# 在setup.yml中
- name: 创建配置文件
  template:
    src: app.conf.j2
    dest: /etc/app.conf
  vars:
    config_port: "{{ app_port | default(3000) }}"  # 8080（使用传递的值）
    
- debug:
    msg: "配置端口: {{ config_port }}"              # 输出：8080
```

### 8.4 变量传递的最佳实践


**🎯 变量命名规范**：
```yaml
# ✅ 推荐：使用前缀标识作用域
global_app_name: "webapp"          # 全局变量
local_db_config: "production"      # 局部变量  
role_nginx_port: 80                # 角色变量

# ✅ 推荐：使用字典组织相关变量
database:
  name: "webapp_db"
  user: "webapp_user"
  port: 3306
  
# 传递时更清晰
- import_tasks: tasks/db.yml
  vars:
    db_config: "{{ database }}"
```

**🎯 默认值处理**：
```yaml
# 在被导入的文件中设置合理的默认值
- name: 配置服务端口
  lineinfile:
    path: /etc/service.conf
    regexp: '^port='
    line: "port={{ service_port | default(8080) }}"

# 这样即使没有传递变量也能正常工作
```

---

## 9. 🎨 最佳实践与设计模式


### 9.1 代码组织设计模式


**🔸 分层架构模式**：
```
项目结构推荐：
ansible-project/
├── site.yml              # 主入口文件
├── group_vars/           # 组变量
│   ├── all.yml
│   ├── webservers.yml
│   └── databases.yml
├── host_vars/            # 主机变量
├── roles/                # 角色目录
│   ├── common/           # 通用角色
│   ├── nginx/            # Web服务器角色
│   └── mysql/            # 数据库角色
├── playbooks/            # 功能剧本
│   ├── deploy.yml
│   ├── backup.yml
│   └── rollback.yml
└── tasks/                # 共享任务
    ├── security.yml
    └── monitoring.yml
```

**🔸 环境隔离模式**：
```yaml
# 主部署文件
---
- import_playbook: "playbooks/{{ environment | default('development') }}.yml"

# 不同环境的剧本文件
# playbooks/development.yml
- name: 开发环境部署
  hosts: dev_servers
  vars:
    debug_mode: true
    log_level: debug
    
# playbooks/production.yml  
- name: 生产环境部署
  hosts: prod_servers
  vars:
    debug_mode: false
    log_level: error
```

### 9.2 任务模块化设计


**🔹 单一职责原则**：
```yaml
# ✅ 好的设计：每个文件专注一个功能
tasks/
├── system_users.yml      # 用户管理
├── system_packages.yml   # 包管理
├── system_security.yml   # 安全配置  
├── app_install.yml       # 应用安装
└── app_config.yml        # 应用配置

# ❌ 不好的设计：功能混杂
tasks/
└── everything.yml        # 把所有任务放一起
```

**🔹 参数化设计**：
```yaml
# tasks/create_user.yml - 可重用的用户创建任务
---
- name: 创建用户 {{ user_name }}
  user:
    name: "{{ user_name }}"
    group: "{{ user_group | default(user_name) }}"
    home: "{{ user_home | default('/home/' + user_name) }}"
    shell: "{{ user_shell | default('/bin/bash') }}"
    create_home: "{{ create_home | default(true) }}"

# 使用时传递不同参数
- import_tasks: tasks/create_user.yml
  vars:
    user_name: webapp
    user_group: www-data
    user_home: /opt/webapp
```

### 9.3 错误处理与容错设计


**🔹 优雅降级模式**：
```yaml
# 主要功能
- import_tasks: tasks/primary_deployment.yml
  
# 可选功能（失败不影响主流程）
- import_tasks: tasks/optional_features.yml
  ignore_errors: yes
  tags: [optional]

# 清理和验证
- import_tasks: tasks/verification.yml
  tags: [verify, always]
```

**🔹 前置条件检查**：
```yaml
# tasks/pre_checks.yml
---
- name: 检查系统要求
  assert:
    that:
      - ansible_memtotal_mb >= 2048
      - ansible_distribution in ['Ubuntu', 'CentOS']
    fail_msg: "系统不满足最低要求"

# 在主任务前导入检查
- import_tasks: tasks/pre_checks.yml
  tags: [check, always]
```

### 9.4 版本控制与文档化


**🔹 版本标记策略**：
```yaml
# meta/main.yml 中记录版本信息
---
galaxy_info:
  role_name: nginx
  version: "2.1.0"
  min_ansible_version: "2.9"
  
dependencies:
  - role: common
    version: ">=1.0.0"
```

**🔹 文档化标准**：
```yaml
# 每个导入文件都应该有清晰的文档
---
# 文件: tasks/database_setup.yml
# 功能: 配置MySQL数据库服务
# 依赖: mysql-server已安装
# 参数:
#   - db_name: 数据库名称 (必需)
#   - db_user: 数据库用户 (可选，默认同db_name)  
#   - db_password: 数据库密码 (必需)
# 示例:
#   - import_tasks: tasks/database_setup.yml
#     vars:
#       db_name: "webapp"  
#       db_password: "{{ vault_db_password }}"

- name: 创建数据库
  mysql_db:
    name: "{{ db_name }}"
    state: present
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 导入机制本质：代码模块化和重用的实现方式
🔸 三种导入方式：import_tasks(任务)、import_playbook(剧本)、import_role(角色)
🔸 静态导入特点：编译时展开，支持语法检查，变量需预先确定
🔸 import vs include：静态vs动态，编译时vs运行时的根本区别
🔸 变量作用域：理解变量传递和优先级，合理组织变量结构
```

### 10.2 实践应用指导


**🔹 选择原则**：
```
使用import_tasks的场景：
✅ 固定的任务序列
✅ 需要完整语法检查  
✅ 变量在解析时就能确定
✅ 追求执行性能

使用include_tasks的场景：
✅ 需要循环执行任务
✅ 基于运行时条件选择
✅ 变量动态确定
✅ 需要灵活的控制流程
```

**🔹 性能优化**：
- 合理归类任务文件，避免过度细分
- 预先定义常用变量，减少重复解析
- 根据使用频率选择导入方式

**🔹 代码组织**：
- 遵循单一职责原则
- 使用清晰的命名规范  
- 合理设置变量默认值
- 添加必要的文档说明

### 10.3 常见问题与解决方案


| 问题类型 | **常见表现** | **解决方法** |
|---------|-------------|-------------|
| **变量问题** | `导入文件中变量未定义` | `检查变量传递和默认值设置` |
| **路径问题** | `找不到导入文件` | `使用相对路径，检查文件位置` |
| **循环限制** | `import不支持loop` | `改用include_tasks配合循环` |
| **性能问题** | `解析或执行速度慢` | `优化文件组织，选择合适的导入方式` |

**核心记忆口诀**：
- **Import静态先展开，Include动态后加载**  
- **任务剧本角色三兄弟，模块复用各有功**
- **变量传递讲层次，作用域域要分清**
- **性能优化看场景，合理选择是关键**