---
title: 4、Kubernetes集成
---
## 📚 目录

1. [Ansible与Kubernetes集成概述](#1-Ansible与Kubernetes集成概述)
2. [k8s模块集合详解](#2-k8s模块集合详解)
3. [Pod管理操作](#3-Pod管理操作)
4. [Deployment部署管理](#4-Deployment部署管理)
5. [Service服务配置](#5-Service服务配置)
6. [ConfigMap与Secret管理](#6-ConfigMap与Secret管理)
7. [Namespace命名空间操作](#7-Namespace命名空间操作)
8. [Ingress入口配置](#8-Ingress入口配置)
9. [集群管理操作](#9-集群管理操作)
10. [应用发布最佳实践](#10-应用发布最佳实践)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🚀 Ansible与Kubernetes集成概述


### 1.1 为什么需要Ansible管理Kubernetes


**传统手工管理的痛点**：
```
手工kubectl命令：
- 重复性操作多，容易出错
- 缺乏版本控制和回滚能力
- 难以实现批量部署
- 配置管理分散，维护困难

Ansible自动化的优势：
- 声明式管理，配置即代码
- 统一的部署流程和标准
- 强大的模板化能力
- 完整的操作审计和回滚
```

### 1.2 Ansible与K8s的工作模式


**集成架构图**：
```
Ansible控制节点                K8s集群
┌─────────────────┐         ┌──────────────────┐
│  Ansible        │         │  Master Node     │
│  ├─ Playbook    │ ────────┤  ├─ API Server   │
│  ├─ Inventory   │         │  ├─ etcd         │
│  └─ k8s模块     │         │  └─ Controller   │
└─────────────────┘         └──────────────────┘
                                      │
                            ┌─────────┴─────────┐
                            │   Worker Nodes    │
                            │  ├─ kubelet       │
                            │  ├─ kube-proxy    │
                            │  └─ Container     │
                            └───────────────────┘
```

### 1.3 核心工作原理


**🔸 工作流程**：
1. **连接方式**：Ansible通过K8s API与集群通信
2. **认证机制**：使用kubeconfig文件或服务账号token
3. **资源管理**：通过YAML模板定义K8s资源
4. **状态管理**：确保集群状态与配置一致

---

## 2. 📦 k8s模块集合详解


### 2.1 Kubernetes Collection介绍


**什么是k8s Collection**：
- Ansible的kubernetes.core集合包含了管理K8s的所有模块
- 提供与kubectl命令对应的自动化功能
- 支持所有标准的K8s资源类型

### 2.2 安装和配置


**安装Collection**：
```bash
# 安装kubernetes collection
ansible-galaxy collection install kubernetes.core

# 安装Python依赖
pip install kubernetes
pip install PyYAML
```

**基础配置示例**：
```yaml
---
- name: K8s基础配置
  hosts: localhost
  connection: local
  vars:
    # K8s集群连接配置
    k8s_kubeconfig: ~/.kube/config
    k8s_namespace: default
    k8s_api_version: v1
  tasks:
    - name: 验证集群连接
      kubernetes.core.k8s_info:
        kubeconfig: "{{ k8s_kubeconfig }}"
        api_version: v1
        kind: Node
```

### 2.3 核心模块概览


| 模块名称 | **主要功能** | **使用场景** |
|---------|-------------|-------------|
| `k8s` | **通用资源管理** | `创建、更新、删除任意K8s资源` |
| `k8s_info` | **资源查询** | `获取集群资源信息和状态` |
| `k8s_scale` | **扩缩容操作** | `调整Deployment、ReplicaSet副本数` |
| `k8s_drain` | **节点维护** | `节点排水和维护操作` |
| `helm` | **Helm管理** | `通过Helm部署和管理应用` |

---

## 3. 🎯 Pod管理操作


### 3.1 Pod的基本概念


**Pod是什么**：
- K8s中**最小的部署单元**
- 包含一个或多个紧密相关的容器
- 共享网络和存储资源
- 通常不直接创建，而是通过Deployment管理

### 3.2 创建和管理Pod


**简单Pod创建**：
```yaml
- name: 创建nginx Pod
  kubernetes.core.k8s:
    name: nginx-pod
    api_version: v1
    kind: Pod
    namespace: default
    definition:
      spec:
        containers:
        - name: nginx
          image: nginx:1.20
          ports:
          - containerPort: 80
```

**带资源限制的Pod**：
```yaml
- name: 创建带资源限制的Pod
  kubernetes.core.k8s:
    name: webapp-pod
    api_version: v1
    kind: Pod
    definition:
      spec:
        containers:
        - name: webapp
          image: myapp:v1.0
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
```

### 3.3 Pod状态监控


**查询Pod信息**：
```yaml
- name: 获取Pod状态
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Pod
    namespace: default
    name: nginx-pod
  register: pod_info

- name: 显示Pod状态
  debug:
    msg: "Pod状态: {{ pod_info.resources[0].status.phase }}"
```

---

## 4. 🚢 Deployment部署管理


### 4.1 Deployment的作用


**为什么使用Deployment**：
- **副本管理**：自动维护指定数量的Pod副本
- **滚动更新**：无中断的应用版本更新
- **回滚能力**：快速回滚到历史版本
- **自愈能力**：自动替换失败的Pod

### 4.2 创建Deployment


**基础Deployment**：
```yaml
- name: 创建nginx Deployment
  kubernetes.core.k8s:
    name: nginx-deployment
    api_version: apps/v1
    kind: Deployment
    namespace: default
    definition:
      spec:
        replicas: 3
        selector:
          matchLabels:
            app: nginx
        template:
          metadata:
            labels:
              app: nginx
          spec:
            containers:
            - name: nginx
              image: nginx:1.20
              ports:
              - containerPort: 80
```

### 4.3 应用更新策略


**滚动更新配置**：
```yaml
- name: 配置滚动更新策略
  kubernetes.core.k8s:
    name: webapp-deployment
    api_version: apps/v1
    kind: Deployment
    definition:
      spec:
        replicas: 5
        strategy:
          type: RollingUpdate
          rollingUpdate:
            maxSurge: 1          # 最多超出1个Pod
            maxUnavailable: 1    # 最多不可用1个Pod
        template:
          spec:
            containers:
            - name: webapp
              image: "webapp:{{ app_version }}"
```

### 4.4 扩缩容操作


**动态调整副本数**：
```yaml
- name: 扩容到5个副本
  kubernetes.core.k8s_scale:
    api_version: apps/v1
    kind: Deployment
    name: nginx-deployment
    namespace: default
    replicas: 5
    wait: true
    wait_condition:
      type: Progressing
      status: "True"
```

---

## 5. 🌐 Service服务配置


### 5.1 Service的作用机制


**Service解决什么问题**：
- **服务发现**：为Pod提供稳定的访问入口
- **负载均衡**：在多个Pod之间分发请求
- **网络抽象**：隐藏Pod的动态IP变化

**Service类型对比**：

| 类型 | **访问范围** | **使用场景** | **IP分配** |
|------|-------------|-------------|-----------|
| `ClusterIP` | **集群内部** | `服务间通信` | `虚拟IP` |
| `NodePort` | **外部访问** | `开发测试` | `节点IP+端口` |
| `LoadBalancer` | **公网访问** | `生产环境` | `外部负载均衡器` |

### 5.2 创建不同类型的Service


**ClusterIP Service**：
```yaml
- name: 创建内部服务
  kubernetes.core.k8s:
    name: webapp-service
    api_version: v1
    kind: Service
    definition:
      spec:
        type: ClusterIP
        selector:
          app: webapp
        ports:
        - port: 80
          targetPort: 8080
```

**NodePort Service**：
```yaml
- name: 创建外部访问服务
  kubernetes.core.k8s:
    name: webapp-nodeport
    api_version: v1
    kind: Service
    definition:
      spec:
        type: NodePort
        selector:
          app: webapp
        ports:
        - port: 80
          targetPort: 8080
          nodePort: 30080
```

---

## 6. 🔐 ConfigMap与Secret管理


### 6.1 配置管理的重要性


**为什么需要ConfigMap和Secret**：
- **配置分离**：将配置从应用代码中分离出来
- **环境适配**：同一镜像适配不同环境
- **安全性**：敏感信息加密存储
- **动态更新**：无需重建镜像即可更新配置

### 6.2 ConfigMap配置管理


**从文件创建ConfigMap**：
```yaml
- name: 从配置文件创建ConfigMap
  kubernetes.core.k8s:
    name: app-config
    api_version: v1
    kind: ConfigMap
    definition:
      data:
        database.properties: |
          host=mysql.example.com
          port=3306
          database=myapp
        app.yaml: |
          server:
            port: 8080
          logging:
            level: INFO
```

**在Pod中使用ConfigMap**：
```yaml
- name: 使用ConfigMap的Pod
  kubernetes.core.k8s:
    name: webapp-pod
    api_version: v1
    kind: Pod
    definition:
      spec:
        containers:
        - name: webapp
          image: myapp:latest
          envFrom:
          - configMapRef:
              name: app-config
          volumeMounts:
          - name: config-volume
            mountPath: /etc/config
        volumes:
        - name: config-volume
          configMap:
            name: app-config
```

### 6.3 Secret密钥管理


**创建不同类型的Secret**：
```yaml
- name: 创建通用Secret
  kubernetes.core.k8s:
    name: app-secrets
    api_version: v1
    kind: Secret
    definition:
      type: Opaque
      stringData:
        username: admin
        password: "{{ vault_password }}"
        
- name: 创建Docker镜像拉取Secret
  kubernetes.core.k8s:
    name: registry-secret
    api_version: v1
    kind: Secret
    definition:
      type: kubernetes.io/dockerconfigjson
      data:
        .dockerconfigjson: "{{ docker_config | b64encode }}"
```

---

## 7. 🏷️ Namespace命名空间操作


### 7.1 Namespace的作用


**命名空间的价值**：
- **资源隔离**：不同环境或项目的资源分离
- **权限控制**：基于命名空间的访问控制
- **资源配额**：限制命名空间内的资源使用
- **名称作用域**：避免资源名称冲突

### 7.2 Namespace管理操作


**创建和配置Namespace**：
```yaml
- name: 创建开发环境命名空间
  kubernetes.core.k8s:
    name: development
    api_version: v1
    kind: Namespace
    definition:
      metadata:
        labels:
          env: development
          team: backend

- name: 设置资源配额
  kubernetes.core.k8s:
    name: dev-quota
    api_version: v1
    kind: ResourceQuota
    namespace: development
    definition:
      spec:
        hard:
          requests.cpu: "4"
          requests.memory: 8Gi
          limits.cpu: "8"
          limits.memory: 16Gi
          pods: "10"
```

### 7.3 跨Namespace部署


**多环境部署示例**：
```yaml
- name: 部署到多个环境
  kubernetes.core.k8s:
    name: webapp
    api_version: apps/v1
    kind: Deployment
    namespace: "{{ item.namespace }}"
    definition:
      spec:
        replicas: "{{ item.replicas }}"
        template:
          spec:
            containers:
            - name: webapp
              image: "webapp:{{ item.version }}"
  loop:
    - namespace: development
      replicas: 1
      version: latest
    - namespace: staging
      replicas: 2
      version: stable
    - namespace: production
      replicas: 3
      version: v1.2.0
```

---

## 8. 🌉 Ingress入口配置


### 8.1 Ingress的作用机制


**Ingress vs Service**：
```
传统Service NodePort访问：
客户端 → NodeIP:30080 → Service → Pod

通过Ingress访问：
客户端 → domain.com → Ingress → Service → Pod
```

**Ingress的优势**：
- **域名路由**：基于域名和路径的请求路由
- **SSL终止**：统一的HTTPS证书管理
- **负载均衡**：七层负载均衡能力
- **成本节约**：减少LoadBalancer类型Service数量

### 8.2 Ingress Controller部署


**安装Nginx Ingress Controller**：
```yaml
- name: 部署Nginx Ingress Controller
  kubernetes.core.k8s:
    state: present
    definition: "{{ item }}"
  loop:
    - apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: nginx-ingress-controller
        namespace: ingress-nginx
      spec:
        replicas: 2
        selector:
          matchLabels:
            app: nginx-ingress
        template:
          spec:
            containers:
            - name: nginx-ingress-controller
              image: nginx/nginx-ingress:latest
```

### 8.3 Ingress规则配置


**HTTP路由配置**：
```yaml
- name: 创建Ingress规则
  kubernetes.core.k8s:
    name: webapp-ingress
    api_version: networking.k8s.io/v1
    kind: Ingress
    namespace: default
    definition:
      spec:
        rules:
        - host: webapp.example.com
          http:
            paths:
            - path: /api
              pathType: Prefix
              backend:
                service:
                  name: api-service
                  port:
                    number: 80
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: frontend-service
                  port:
                    number: 80
```

**HTTPS和证书管理**：
```yaml
- name: 配置HTTPS Ingress
  kubernetes.core.k8s:
    name: secure-ingress
    api_version: networking.k8s.io/v1
    kind: Ingress
    definition:
      spec:
        tls:
        - hosts:
          - secure.example.com
          secretName: tls-secret
        rules:
        - host: secure.example.com
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: webapp-service
                  port:
                    number: 443
```

---

## 9. 🎛️ 集群管理操作


### 9.1 节点管理


**节点状态监控**：
```yaml
- name: 获取集群节点信息
  kubernetes.core.k8s_info:
    api_version: v1
    kind: Node
  register: nodes_info

- name: 检查节点健康状态
  debug:
    msg: |
      节点: {{ item.metadata.name }}
      状态: {{ item.status.conditions | selectattr('type', 'equalto', 'Ready') | map(attribute='status') | first }}
      资源: CPU={{ item.status.capacity.cpu }}, Memory={{ item.status.capacity.memory }}
  loop: "{{ nodes_info.resources }}"
```

**节点维护操作**：
```yaml
- name: 节点排水维护
  kubernetes.core.k8s_drain:
    name: worker-node-1
    state: drain
    delete_emptydir_data: true
    grace_period: 300
    ignore_daemonsets: true

- name: 维护完成后恢复节点
  kubernetes.core.k8s_drain:
    name: worker-node-1
    state: uncordon
```

### 9.2 集群资源监控


**资源使用统计**：
```yaml
- name: 获取集群资源使用情况
  kubernetes.core.k8s_info:
    api_version: metrics.k8s.io/v1beta1
    kind: NodeMetrics
  register: node_metrics
  ignore_errors: true

- name: 显示资源使用情况
  debug:
    msg: |
      节点: {{ item.metadata.name }}
      CPU使用: {{ item.usage.cpu }}
      内存使用: {{ item.usage.memory }}
  loop: "{{ node_metrics.resources | default([]) }}"
```

---

## 10. 📦 应用发布最佳实践


### 10.1 蓝绿部署策略


**蓝绿部署实现**：
```yaml
- name: 蓝绿部署 - 部署绿色版本
  kubernetes.core.k8s:
    name: "webapp-{{ deploy_color }}"
    api_version: apps/v1
    kind: Deployment
    definition:
      metadata:
        labels:
          version: "{{ deploy_color }}"
      spec:
        replicas: 3
        selector:
          matchLabels:
            app: webapp
            version: "{{ deploy_color }}"
        template:
          metadata:
            labels:
              app: webapp
              version: "{{ deploy_color }}"
          spec:
            containers:
            - name: webapp
              image: "webapp:{{ new_version }}"

- name: 等待新版本就绪
  kubernetes.core.k8s_info:
    api_version: apps/v1
    kind: Deployment
    name: "webapp-{{ deploy_color }}"
    wait_condition:
      type: Available
      status: "True"
    wait: true
    wait_timeout: 300

- name: 切换流量到新版本
  kubernetes.core.k8s:
    name: webapp-service
    api_version: v1
    kind: Service
    definition:
      spec:
        selector:
          app: webapp
          version: "{{ deploy_color }}"
```

### 10.2 金丝雀发布


**分阶段流量切换**：
```yaml
- name: 金丝雀发布 - 部署新版本
  kubernetes.core.k8s:
    name: webapp-canary
    api_version: apps/v1
    kind: Deployment
    definition:
      spec:
        replicas: 1  # 开始时只部署1个副本
        template:
          metadata:
            labels:
              app: webapp
              version: canary
          spec:
            containers:
            - name: webapp
              image: "webapp:{{ canary_version }}"

- name: 逐步增加金丝雀流量
  kubernetes.core.k8s_scale:
    api_version: apps/v1
    kind: Deployment
    name: webapp-canary
    replicas: "{{ canary_replicas }}"
  vars:
    canary_replicas: "{{ (total_replicas * canary_percentage / 100) | int }}"
```

### 10.3 健康检查配置


**完整的健康检查**：
```yaml
- name: 配置健康检查
  kubernetes.core.k8s:
    name: webapp-with-health
    api_version: apps/v1
    kind: Deployment
    definition:
      spec:
        template:
          spec:
            containers:
            - name: webapp
              image: webapp:latest
              livenessProbe:
                httpGet:
                  path: /health
                  port: 8080
                initialDelaySeconds: 30
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 3
              readinessProbe:
                httpGet:
                  path: /ready
                  port: 8080
                initialDelaySeconds: 5
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 2
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 k8s模块集合：Ansible管理K8s的工具包，包含所有必需模块
🔸 资源管理：通过k8s模块统一管理各种K8s资源
🔸 Pod管理：K8s最小部署单元，通常通过Deployment管理
🔸 服务发现：Service提供稳定访问入口和负载均衡
🔸 配置分离：ConfigMap和Secret实现配置与代码分离
🔸 命名空间：实现多环境和多租户资源隔离
🔸 流量入口：Ingress提供七层负载均衡和域名路由
```

### 11.2 关键理解要点


**🔹 Ansible与K8s的协作模式**
```
声明式管理：
- Ansible描述期望状态
- K8s确保实际状态与期望一致
- 自动处理资源的创建、更新、删除

模板化部署：
- 使用Jinja2模板处理配置变化
- 同一套模板适配多个环境
- 参数化控制资源规格和行为
```

**🔹 资源管理的最佳实践**
```
分层管理策略：
- 基础设施层：Namespace、RBAC、网络策略
- 平台服务层：Ingress、存储、监控组件
- 应用服务层：Deployment、Service、ConfigMap

版本控制：
- 所有K8s资源定义纳入版本控制
- 使用标签标记版本信息
- 保持部署历史可追溯
```

### 11.3 实际应用场景


**💻 典型使用场景**：
- **多环境部署**：开发、测试、生产环境的统一管理
- **微服务部署**：复杂应用的自动化部署和更新
- **CI/CD集成**：与持续集成流水线深度集成
- **灾难恢复**：快速重建和恢复应用服务
- **资源管理**：统一的配置管理和密钥管理

**🎯 最佳实践建议**：

> 💡 **提示**: 始终使用命名空间隔离不同环境，避免资源冲突

> ⚠️ **注意**: Secret信息使用Ansible Vault加密，不要明文存储

> 🔥 **重点**: 配置健康检查确保服务可用性，特别是在滚动更新时

**🔧 常见问题解决**：
- **连接问题**：检查kubeconfig文件和网络连通性
- **权限问题**：确保服务账号有足够的RBAC权限
- **资源冲突**：使用标签和命名空间进行资源管理
- **更新失败**：设置合理的超时时间和回滚策略

### 11.4 学习进阶路径


**📈 进阶学习建议**：
1. **掌握基础**：熟悉K8s基本概念和Ansible核心模块
2. **实践项目**：从简单应用开始，逐步增加复杂度
3. **自动化流程**：结合CI/CD构建完整的自动化流水线
4. **监控运维**：集成监控、日志和告警系统
5. **高级特性**：学习服务网格、Operator等高级特性

**核心记忆要点**：
- Ansible通过K8s API管理集群资源，实现基础设施即代码
- 合理使用命名空间、标签进行资源组织和管理
- 配置与代码分离，敏感信息加密存储
- 健康检查和滚动更新确保服务稳定性
- 模板化和参数化实现多环境统一管理