---
title: 1、命令执行模块
---
## 📚 目录

1. [命令执行模块概述](#1-命令执行模块概述)
2. [command模块详解](#2-command模块详解)
3. [shell模块详解](#3-shell模块详解)
4. [script模块详解](#4-script模块详解)
5. [raw模块详解](#5-raw模块详解)
6. [expect模块详解](#6-expect模块详解)
7. [模块对比与选择](#7-模块对比与选择)
8. [安全性与最佳实践](#8-安全性与最佳实践)
9. [返回值处理](#9-返回值处理)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 命令执行模块概述


### 1.1 什么是命令执行模块


**简单理解**：命令执行模块就是让Ansible在远程主机上执行各种命令的工具，就像你在远程服务器上敲键盘一样。

```
本地机器（控制端）              远程主机（被管理端）
     |                              |
 ansible命令 -----------------> 执行具体命令
     |                              |
   获取结果 <----------------- 返回执行结果
```

### 1.2 为什么需要不同的命令模块


**核心原因**：不同的命令执行环境和安全要求需要不同的处理方式

> 💡 **关键理解**：
> - **command**：最安全，但功能受限
> - **shell**：功能强大，但安全风险高
> - **script**：执行本地脚本，传输方便
> - **raw**：最底层，用于特殊情况
> - **expect**：处理交互式命令

### 1.3 默认模块说明


**重要概念**：command是Ansible的**默认模块**，这意味着：

```bash
# 这两种写法完全等价
ansible all -m command -a "ls -l"
ansible all -a "ls -l"
```

---

## 2. 🔧 command模块详解


### 2.1 command模块基本概念


**核心特点**：command模块是最安全的命令执行模块，但功能相对受限。

> 📋 **工作原理**：
> - 直接调用系统命令，不经过shell解释
> - 不支持shell特性（管道、重定向等）
> - 参数会被严格处理，防注入攻击

### 2.2 基本语法与参数


**常用参数详解**：

| 参数 | 说明 | 示例 |
|------|------|------|
| `cmd` | 要执行的命令 | `cmd: "ls -l"` |
| `chdir` | 切换工作目录 | `chdir: /tmp` |
| `creates` | 如果文件存在则跳过 | `creates: /tmp/test.txt` |
| `removes` | 如果文件不存在则跳过 | `removes: /tmp/test.txt` |

### 2.3 实际使用示例


**基础命令执行**：
```yaml
# 查看系统信息
- name: 查看系统版本
  command: cat /etc/os-release

# 检查磁盘空间
- name: 检查磁盘使用情况
  command: df -h
```

**工作目录设置**：
```yaml
- name: 在指定目录执行命令
  command: pwd
  args:
    chdir: /var/log
```

**条件执行**：
```yaml
# 文件不存在时才创建
- name: 创建文件（如果不存在）
  command: touch /tmp/myfile.txt
  args:
    creates: /tmp/myfile.txt
```

### 2.4 command模块限制


**不支持的功能**：
- ❌ 管道操作：`ls | grep test`
- ❌ 重定向：`echo "hello" > file.txt` 
- ❌ 环境变量：`$HOME/test`
- ❌ shell内置命令：`cd`、`source`

```yaml
# 错误示例 - 这些都不会工作
- command: ls | grep test        # 管道不支持
- command: echo "hello" > file   # 重定向不支持
- command: cd /tmp && ls         # 多命令不支持
```

---

## 3. 🐚 shell模块详解


### 3.1 shell模块基本概念


**核心特点**：shell模块通过系统shell（如bash）执行命令，支持所有shell特性。

> ⚠️ **安全提醒**：
> shell模块功能强大但安全风险较高，因为支持shell解释，可能存在注入攻击风险。

### 3.2 shell vs command对比


```
command模块处理过程：
用户输入 → 直接执行 → 返回结果

shell模块处理过程：
用户输入 → shell解释 → 执行命令 → 返回结果
```

### 3.3 shell模块实用示例


**管道和重定向**：
```yaml
# 使用管道过滤结果
- name: 查找特定进程
  shell: ps aux | grep nginx

# 重定向输出到文件
- name: 保存系统信息
  shell: uname -a > /tmp/system_info.txt

# 多命令组合
- name: 创建目录并进入
  shell: mkdir -p /tmp/test && cd /tmp/test && pwd
```

**环境变量使用**：
```yaml
# 使用环境变量
- name: 获取用户家目录内容
  shell: ls -la $HOME

# 设置临时环境变量
- name: 带环境变量执行
  shell: LANG=C date
  environment:
    TZ: UTC
```

**复杂逻辑处理**：
```yaml
# 条件判断
- name: 检查并启动服务
  shell: |
    if ! systemctl is-active nginx; then
        systemctl start nginx
    fi

# 循环处理
- name: 批量处理文件
  shell: |
    for file in /tmp/*.log; do
        if [ -f "$file" ]; then
            gzip "$file"
        fi
    done
```

---

## 4. 📜 script模块详解


### 4.1 script模块基本概念


**核心作用**：将本地脚本传输到远程主机并执行，非常适合复杂的批处理操作。

**工作流程**：
```
本地脚本文件 → 传输到远程 → 添加执行权限 → 执行 → 返回结果 → 清理临时文件
```

### 4.2 script模块优势


> 💡 **使用场景**：
> - 复杂的shell脚本逻辑
> - 需要在多台机器上执行相同脚本
> - 脚本包含敏感信息，不适合直接写在playbook中

### 4.3 实际使用示例


**基础脚本执行**：
```bash
# 本地脚本文件：/tmp/system_check.sh
#!/bin/bash
echo "系统检查开始..."
echo "CPU信息：$(lscpu | grep 'CPU(s):' | head -1)"
echo "内存信息：$(free -h | grep Mem)"
echo "磁盘信息：$(df -h /)"
```

```yaml
# playbook中使用
- name: 执行系统检查脚本
  script: /tmp/system_check.sh
```

**带参数的脚本**：
```bash
# 脚本文件：backup_script.sh
#!/bin/bash
SOURCE_DIR=$1
BACKUP_DIR=$2
echo "备份 $SOURCE_DIR 到 $BACKUP_DIR"
tar -czf "$BACKUP_DIR/backup_$(date +%Y%m%d).tar.gz" "$SOURCE_DIR"
```

```yaml
- name: 执行备份脚本
  script: backup_script.sh /etc /tmp/backups
```

**指定解释器**：
```yaml
# Python脚本
- name: 执行Python脚本
  script: monitor.py
  args:
    executable: python3

# 在特定目录执行
- name: 在指定目录执行脚本
  script: deploy.sh
  args:
    chdir: /opt/app
```

---

## 5. 🔩 raw模块详解


### 5.1 raw模块基本概念


**核心特点**：raw模块是最底层的命令执行模块，绕过Ansible的大部分处理机制。

> ⚡ **关键理解**：
> - 不依赖Python环境
> - 不进行参数处理和验证
> - 直接通过SSH执行命令
> - 主要用于系统初始化场景

### 5.2 使用场景


**适用情况**：
- ✅ 目标主机没有安装Python
- ✅ 系统初始化阶段
- ✅ 安装Python环境本身
- ✅ 紧急情况下的直接操作

### 5.3 实际使用示例


**系统初始化**：
```yaml
# 在新系统上安装Python
- name: 安装Python（Ubuntu）
  raw: apt-get update && apt-get install -y python3

# 在新系统上安装Python（CentOS）
- name: 安装Python（CentOS）
  raw: yum install -y python3
```

**紧急修复**：
```yaml
# 紧急重启服务
- name: 紧急重启nginx
  raw: systemctl restart nginx

# 清理磁盘空间
- name: 清理临时文件
  raw: find /tmp -type f -mtime +7 -delete
```

---

## 6. 🤖 expect模块详解


### 6.1 expect模块基本概念


**核心作用**：处理需要交互式输入的命令，自动化回答提示问题。

**工作原理**：
```
执行命令 → 等待提示 → 自动输入响应 → 继续执行 → 完成
```

> 📋 **前置条件**：
> 需要在目标主机安装`python-pexpect`或`pexpect`包

### 6.2 典型应用场景


**常见使用场景**：
- 🔐 需要密码输入的命令
- 📦 交互式安装程序
- 🔧 需要确认的系统操作
- 📱 SSH连接和登录

### 6.3 实际使用示例


**密码输入场景**：
```yaml
- name: 修改用户密码
  expect:
    command: passwd testuser
    responses:
      'New password:': 'newpassword123'
      'Retype new password:': 'newpassword123'
```

**交互式安装**：
```yaml
- name: 交互式安装软件
  expect:
    command: ./install.sh
    responses:
      'Do you agree to the license': 'yes'
      'Installation path': '/opt/software'
      'Continue': 'y'
    timeout: 300
```

**SSH连接示例**：
```yaml
- name: 自动SSH登录并执行命令
  expect:
    command: ssh user@remote-host "ls -la"
    responses:
      'password:': 'secret123'
      'Are you sure': 'yes'
```

---

## 7. ⚖️ 模块对比与选择


### 7.1 功能对比表


| 模块 | **安全性** | **功能丰富度** | **使用难度** | **适用场景** |
|------|-----------|---------------|-------------|-------------|
| `command` | 🔒🔒🔒 最高 | ⭐⭐ 基础 | 😊 简单 | `日常命令执行` |
| `shell` | 🔒🔒 中等 | ⭐⭐⭐⭐ 丰富 | 😊 简单 | `需要shell特性` |
| `script` | 🔒🔒🔒 较高 | ⭐⭐⭐ 中等 | 😐 中等 | `复杂脚本执行` |
| `raw` | 🔒 较低 | ⭐⭐⭐⭐⭐ 最强 | 😱 困难 | `系统初始化` |
| `expect` | 🔒🔒 中等 | ⭐⭐⭐ 特殊 | 😰 复杂 | `交互式命令` |

### 7.2 选择决策树


```
需要执行命令吗？
    ↓ 是
需要shell特性吗？（管道、重定向等）
    ↓ 否 → 使用 command 模块
    ↓ 是
命令复杂吗？需要多行脚本吗？
    ↓ 否 → 使用 shell 模块  
    ↓ 是
是本地脚本吗？
    ↓ 是 → 使用 script 模块
    ↓ 否
目标机器有Python吗？
    ↓ 否 → 使用 raw 模块
    ↓ 是
需要交互式输入吗？
    ↓ 是 → 使用 expect 模块
    ↓ 否 → 使用 shell 模块
```

### 7.3 实际选择建议


**🥇 首选建议**：
- 🎯 **80%场景**：使用`command`模块（安全第一）
- 🎯 **15%场景**：使用`shell`模块（需要shell特性）
- 🎯 **5%场景**：使用其他模块（特殊需求）

**❌ 避免的做法**：
```yaml
# 错误：用shell执行简单命令
- shell: ls -l

# 正确：用command执行简单命令  
- command: ls -l
```

---

## 8. 🔐 安全性与最佳实践


### 8.1 命令注入风险


**危险示例**：
```yaml
# 危险：用户输入未过滤
- shell: "echo {{ user_input }}"  # 如果user_input="hello; rm -rf /"

# 安全：使用command模块
- command: echo "{{ user_input }}"
```

### 8.2 环境变量设置


**方法一：模块级别设置**
```yaml
- name: 设置环境变量
  shell: echo $MY_VAR
  environment:
    MY_VAR: "hello world"
    PATH: "{{ ansible_env.PATH }}:/custom/path"
```

**方法二：任务级别设置**
```yaml
- name: 多个任务共享环境变量
  block:
    - shell: echo $APP_ENV
    - shell: echo $APP_VERSION
  environment:
    APP_ENV: production
    APP_VERSION: "1.0.0"
```

### 8.3 工作目录管理


**推荐做法**：
```yaml
# 方法一：使用chdir参数
- name: 在指定目录执行
  command: make install
  args:
    chdir: /usr/src/app

# 方法二：组合使用
- name: 切换目录并执行
  shell: cd /usr/src/app && make && make install
```

### 8.4 权限控制


**sudo执行**：
```yaml
- name: 需要sudo权限的命令
  command: systemctl restart nginx
  become: yes
  become_user: root

# 指定特定用户执行
- name: 以特定用户执行
  command: whoami
  become: yes
  become_user: appuser
```

---

## 9. 📊 返回值处理


### 9.1 返回值结构


**标准返回值**：
```yaml
# 返回值示例
{
    "changed": true,           # 是否发生变更
    "rc": 0,                  # 返回码（0表示成功）
    "stdout": "命令输出内容",    # 标准输出
    "stderr": "错误信息",       # 错误输出
    "start": "时间戳",         # 开始时间
    "end": "时间戳",           # 结束时间
    "delta": "执行耗时"        # 执行时长
}
```

### 9.2 返回值使用


**获取并使用返回值**：
```yaml
- name: 执行命令并获取结果
  command: uptime
  register: uptime_result

- name: 显示命令输出
  debug:
    msg: "系统运行时间：{{ uptime_result.stdout }}"

# 条件判断
- name: 检查命令是否成功
  debug:
    msg: "命令执行成功"
  when: uptime_result.rc == 0
```

**处理错误情况**：
```yaml
- name: 可能失败的命令
  command: /path/to/nonexistent/command
  register: result
  ignore_errors: yes

- name: 处理命令失败
  debug:
    msg: "命令失败：{{ result.stderr }}"
  when: result.rc != 0
```

### 9.3 输出格式化


**清理输出内容**：
```yaml
- name: 获取并清理输出
  shell: df -h | grep "/$" | awk '{print $5}'
  register: disk_usage

- name: 显示清理后的结果
  debug:
    msg: "根分区使用率：{{ disk_usage.stdout.strip() }}"
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 模块选择：command为默认和首选，shell用于复杂场景
🔸 安全原则：优先使用command，避免不必要的shell执行
🔸 功能差异：理解每个模块的适用场景和限制
🔸 返回值处理：掌握如何获取和使用命令执行结果
🔸 环境配置：学会设置工作目录和环境变量
```

### 10.2 实用记忆口诀


```
命令模块选择有门道：
简单安全选command，
复杂功能用shell，
脚本文件用script，
系统初始用raw，
交互问答expect。
```

### 10.3 最佳实践建议


**✅ 推荐做法**：
- 优先使用`command`模块
- 合理设置工作目录
- 正确处理返回值
- 注意权限控制

**❌ 避免做法**：
- 滥用`shell`模块
- 忽略错误处理
- 不验证用户输入
- 硬编码敏感信息

**🎯 学习路径**：
1. ⭐ **掌握command基础**（必须）
2. ⭐⭐ **理解shell差异**（重要）
3. ⭐⭐⭐ **学习script使用**（进阶）
4. ⭐⭐⭐⭐ **了解raw和expect**（特殊场景）

### 10.4 实际应用指导


**🎬 常见应用场景**：
- **系统监控**：使用command执行系统命令
- **日志分析**：使用shell进行复杂文本处理
- **批量部署**：使用script执行部署脚本
- **系统初始化**：使用raw安装基础环境
- **密码修改**：使用expect处理交互输入

**📚 扩展学习**：
- 深入了解Ansible变量和循环
- 学习条件判断和错误处理
- 掌握playbook的组织结构
- 理解Ansible的幂等性原理

**核心记忆**：
- 命令执行模块是Ansible的基础工具
- 安全性和功能性需要平衡考虑
- 不同场景选择合适的模块
- 返回值处理是自动化的关键