---
title: 2、IO流介绍
---
## 📚 目录

1. [IO流概述](#1-IO流概述)
2. [IO流体系结构](#2-IO流体系结构)
3. [IO核心分类与用途](#3-IO核心分类与用途)
4. [字节流详解](#4-字节流详解)
5. [字符流详解](#5-字符流详解)
6. [节点流vs处理流](#6-节点流vs处理流)
7. [常用类说明](#7-常用类说明)
8. [功能设计角度对比](#8-功能设计角度对比)
9. [常见错误与注意事项](#9-常见错误与注意事项)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌊 IO流概述


### 1.1 IO流基本概念


**🔸 核心定义**
```
Java IO（Input/Output）流：Java提供的一套用于处理数据输入与输出操作的API
主要用途：读写文件、网络通信、键盘输入、打印输出等
核心作用：用于读取或写入数据到各种数据源和目标(文件、网络、内存等)
数据特点：数据被视为有序的数据序列(流)，按顺序处理
```

### 1.2 IO流关键特性


**⚡ 重要特点**
- **顺序性**：数据按照先进先出的顺序处理
- **单向性**：输入流只能读，输出流只能写
- **统一性**：所有数据源都抽象为流的概念
- **层次性**：提供不同层次的抽象，满足不同需求

### 1.3 IO流 vs NIO对比


| 特性 | **传统IO** | **NIO** |
|------|-----------|---------|
| `数据处理方式` | `流式顺序处理` | `块处理，可前后移动` |
| `缓冲区` | `无直接缓冲区概念` | `使用Buffer作为数据容器` |
| `阻塞性` | `阻塞式IO` | `支持非阻塞式IO` |
| `选择器` | `无` | `支持Selector多路复用` |
| `易用性` | `简单直观` | `复杂但更灵活` |
| `适用场景` | `一般文件操作` | `高并发网络通信` |

### 1.4 IO流使用注意事项


> **⚠️ 重要提醒**
> - 流用完必须关闭：使用`close()`或`try-with-resources`
> - 缓冲流能提高效率，但不自动刷新
> - 字符流用于文本数据，字节流可处理任意类型数据（如图片、视频、音频）
> - 编码转换需使用`InputStreamReader`和`OutputStreamWriter`

---

## 2. 🏗️ IO流体系结构


### 2.1 完整IO流继承体系


```java
java.io
├── InputStream (字节输入流)                      // 抽象类，读取8位字节
│   ├── FileInputStream             // 从文件读取
│   ├── ByteArrayInputStream       // 从字节数组读取
│   ├── PipedInputStream           // 管道通信输入
│   ├── FilterInputStream          // 抽象装饰类
│   │   ├── BufferedInputStream    // 增加缓冲，提高读取效率
│   │   └── DataInputStream        // 读取Java基本数据类型
│   └── ObjectInputStream          // 读取对象（反序列化）

├── OutputStream (字节输出流)                    // 抽象类，写出8位字节
│   ├── FileOutputStream            // 写入文件
│   ├── ByteArrayOutputStream      // 写入到字节数组
│   ├── PipedOutputStream          // 管道通信输出
│   ├── FilterOutputStream         // 抽象装饰类
│   │   ├── BufferedOutputStream   // 增加缓冲，提高写出效率
│   │   ├── DataOutputStream       // 写Java基本数据类型
│   │   └── PrintStream            // 打印流（print/println）
│   └── ObjectOutputStream         // 写出对象（序列化）

├── Reader (字符输入流)                        // 抽象类，读取16位字符
│   ├── FileReader                 // 从文件读取（本质上是 InputStreamReader）
│   ├── CharArrayReader           // 从字符数组读取
│   ├── StringReader              // 从字符串读取
│   ├── PipedReader               // 管道通信输入
│   └── BufferedReader            // 缓冲读取 + readLine()

├── Writer (字符输出流)                        // 抽象类，写出16位字符
│   ├── FileWriter                 // 写入文件（本质上是 OutputStreamWriter）
│   ├── CharArrayWriter           // 写入到字符数组
│   ├── StringWriter              // 写入到字符串缓冲区
│   ├── PipedWriter               // 管道通信输出
│   └── BufferedWriter            // 缓冲写出 + newLine()

├── 转换流：字节 ↔ 字符
│   ├── InputStreamReader         // 字节流转字符流（编码解码）
│   └── OutputStreamWriter        // 字符流转字节流（编码解码）

└── 补充说明
    ├── PrintStream               // 标准输出流 System.out 使用的类
    ├── PrintWriter               // 支持字符打印
    ├── ObjectInputStream/ObjectOutputStream // 用于序列化与反序列化对象
    ├── DataInputStream/DataOutputStream     // 读写基本数据类型
    └── RandomAccessFile          // 支持随机读写的类（既不是流的子类）
```

### 2.2 IO流层次关系图


```
IO流四大基类层次关系：
┌─────────────────────────────────┐
│           InputStream           │ ← 字节输入流基类
│         OutputStream            │ ← 字节输出流基类  
├─────────────────────────────────┤
│            Reader               │ ← 字符输入流基类
│            Writer               │ ← 字符输出流基类
└─────────────────────────────────┘
            ↓
    所有具体流类都继承自这四个抽象基类
```

---

## 3. 🎯 IO核心分类与用途


### 3.1 Java IO流类型分类详解


```java
├── 1.1 字节流（适合所有类型文件）
│   ├── 适合处理：图像、音频、PDF、视频、压缩包等二进制数据
│   ├── 推荐组合：BufferedInputStream + FileInputStream
│   └── 主要类：
│       ├── FileInputStream / FileOutputStream       → 文件字节读写
│       ├── ByteArrayInputStream / ByteArrayOutputStream → 内存中的字节读写
│       └── ObjectInputStream / ObjectOutputStream   → 对象的序列化与反序列化
│
├── 1.2 字符流（仅适用于文本数据）
│   ├── 适合处理：.txt, .java, .xml, .html 等纯文本文件
│   ├── 推荐组合：BufferedReader + FileReader
│   └── 主要类：
│       ├── FileReader / FileWriter                  → 基础字符文件读写
│       ├── BufferedReader / BufferedWriter          → 提高性能 + readLine / newLine
│       └── InputStreamReader / OutputStreamWriter   → 字节 ↔ 字符的桥接转换流（含编码）
│
├── 1.3 节点流（直接连接底层数据源）
│   ├── 概念：直接从文件、内存数组、管道、Socket 读取或写入数据
│   └── 示例类：
│       ├── FileInputStream / FileOutputStream       → 文件
│       ├── FileReader / FileWriter                  → 文本文件
│       └── ByteArrayInputStream / ByteArrayOutputStream → 内存数组
│
└── 1.4 处理流（包装节点流增强功能）
    ├── 概念：依赖节点流，提供缓冲、转换、格式化、对象操作等功能
    ├── 模式：典型的"装饰者模式"结构，功能增强不改变原有对象
    └── 示例类：
        ├── BufferedReader / BufferedWriter           → 提高字符流效率
        ├── BufferedInputStream / BufferedOutputStream→ 提高字节流效率
        ├── InputStreamReader / OutputStreamWriter    → 编码转换桥接
        ├── ObjectInputStream / ObjectOutputStream    → 对象读写
        └── PrintWriter / PrintStream                 → 格式化输出
```

### 3.2 编码处理机制详解


```java
├── 1.1 字节流 → 字符流：InputStreamReader
│   ├── 桥接类，将 InputStream 转为 Reader
│   └── 示例：new InputStreamReader(new FileInputStream("a.txt"), "UTF-8")
│
├── 1.2 字符流 → 字节流：OutputStreamWriter
│   ├── 桥接类，将 Writer 写出的字符转为字节（按指定编码）
│   └── 示例：new OutputStreamWriter(new FileOutputStream("a.txt"), "GBK")
│
├── 1.3 编码指定方式
│   ├── 在 InputStreamReader / OutputStreamWriter 构造函数中传入编码参数
│   └── 常见编码：
│       ├── "UTF-8"       → 跨平台推荐使用，支持多语言
│       ├── "GBK"         → 适用于简体中文环境（Windows 本地）
│       └── "ISO-8859-1"  → 西欧语言，常用于旧系统
│
└── 1.4 注意事项
    ├── FileReader / FileWriter 不支持编码指定
    │   └── 默认使用操作系统编码（如 Windows 默认 GBK，Linux 默认 UTF-8）
    ├── 建议在跨平台或多语言开发中避免使用 FileReader/FileWriter
    └── 推荐始终使用 InputStreamReader / OutputStreamWriter 并明确指定编码
```

### 3.3 流分类对比总结


| 分类维度 | **分类1** | **分类2** | **特点对比** |
|---------|-----------|-----------|-------------|
| `数据单位` | `字节流` | `字符流` | `8位 vs 16位处理单元` |
| `处理对象` | `二进制数据` | `文本数据` | `通用 vs 专用` |
| `连接方式` | `节点流` | `处理流` | `直连 vs 装饰增强` |
| `方向性` | `输入流` | `输出流` | `读取 vs 写入` |

---

## 4. 📦 字节流详解


### 4.1 字节流继承体系


```java
InputStream（所有字节输入流基类）
├── FileInputStream       // 从文件读取字节数据
├── ByteArrayInputStream  // 从内存中的字节数组读取
├── BufferedInputStream   // 提高读取效率，使用缓冲区
├── ObjectInputStream     // 反序列化对象（必须实现Serializable）

OutputStream（所有字节输出流基类）
├── FileOutputStream       // 向文件写入字节数据
├── ByteArrayOutputStream  // 写入到字节数组（内存）
├── BufferedOutputStream   // 提高写出效率，使用缓冲区
├── ObjectOutputStream     // 序列化对象输出到流
```

### 4.2 字节流核心特点


**🔸 处理能力**
- 可以处理**任意类型**的文件
- 以**8位字节**为基本处理单位
- 不涉及字符编码转换

**🎯 适用场景**
- 图片、音频、视频文件复制
- 二进制数据传输
- 对象序列化操作
- 网络数据传输

### 4.3 字节流使用建议


> **💡 使用建议与注意事项**
> - 文件复制、图像处理优先选择字节流（推荐加上缓冲流提高性能）
> - `ObjectOutputStream/InputStream`用于对象的序列化/反序列化，对象需实现`Serializable`接口
> - 使用完流务必关闭，可用`try-with-resources`语法

---

## 5. 📝 字符流详解


### 5.1 字符流继承体系


```java
Reader（所有字符输入流基类）
├── FileReader             // 直接从文件读取字符
├── BufferedReader         // 使用缓冲区提高效率，可readLine()
├── InputStreamReader      // 将字节流转换为字符流（指定编码）

Writer（所有字符输出流基类）
├── FileWriter             // 直接向文件写字符
├── BufferedWriter         // 使用缓冲区提高效率
├── OutputStreamWriter     // 字符转字节流，可指定编码
```

### 5.2 字符流核心特点


**🔸 处理能力**
- 专门处理**文本数据**
- 以**16位字符**为基本处理单位
- 自动处理字符编码转换

**🎯 适用场景**
- 文本文件读写
- 配置文件处理
- 日志文件操作
- 控制台输入输出

### 5.3 字符流使用建议


> **💡 使用建议与注意事项**
> - 推荐：`BufferedReader + BufferedWriter`，搭配使用进行文本文件高效读写
> - `InputStreamReader`和`OutputStreamWriter`是桥梁类
> - 默认编码可能随系统变化，跨平台开发要显示指定编码

---

## 6. 🔗 节点流vs处理流


### 6.1 概念对比


```java
// 节点流：真正操作底层数据源

节点流（直接连接数据源）
├── FileInputStream
├── FileReader
├── FileOutputStream
├── FileWriter

// 处理流：增强功能，如缓存、转换、分行读取，典型体现 Java 的装饰器设计模式

处理流（依附于节点流，增强功能）
├── BufferedInputStream
├── BufferedReader
├── BufferedOutputStream
├── BufferedWriter
├── InputStreamReader / OutputStreamWriter
```

### 6.2 装饰者模式体现


```
装饰者模式在IO流中的应用：
┌─────────────────┐    装饰    ┌─────────────────┐
│   FileInputStream │  -----→   │ BufferedInputStream │
│  (基础文件读取)    │           │   (增加缓冲功能)    │
└─────────────────┘           └─────────────────┘
         ↓                              ↓
    基础功能                        增强功能
```

### 6.3 节点流vs处理流对比


| 特性 | **节点流** | **处理流** |
|------|-----------|-----------|
| `连接方式` | `直接连接数据源` | `包装其他流` |
| `主要作用` | `提供基础读写能力` | `增强功能性能` |
| `设计模式` | `基础组件` | `装饰者模式` |
| `使用方式` | `可独立使用` | `必须依赖节点流` |
| `典型代表` | `FileInputStream` | `BufferedInputStream` |

---

## 7. 📋 常用类说明


### 7.1 按流向和数据类型分类


```java
├── 输入流
│   ├── 字节流 InputStream（读取）
│   │   ├── FileInputStream         [节点流]   → 读取文件（适合任意类型，如图像、音频）
│   │   ├── BufferedInputStream     [处理流]   → 加缓冲提高读取性能
│   │   ├── ByteArrayInputStream    [内存流]   → 从内存中字节数组读取
│   │   └── ObjectInputStream       [处理流]   → 从文件反序列化对象
│   │
│   └── 字符流 Reader（读取）
│       ├── FileReader              [节点流]   → 读取字符文件（默认平台编码）
│       ├── BufferedReader          [处理流]   → readLine() 支持，常与 FileReader 配合
│       └── InputStreamReader       [桥接流]   → 字节 → 字符转换，支持设定编码（如 UTF-8）
│
├── 输出流
│   ├── 字节流 OutputStream（写入）
│   │   ├── FileOutputStream        [节点流]   → 写入文件（字节）
│   │   ├── BufferedOutputStream    [处理流]   → 缓存写操作，提升写入效率
│   │   ├── ByteArrayOutputStream   [内存流]   → 写入内存字节数组，可转为 byte[]
│   │   └── ObjectOutputStream      [处理流]   → 序列化对象输出
│   │
│   └── 字符流 Writer（写入）
│       ├── FileWriter              [节点流]   → 写文本文件（字符）
│       ├── BufferedWriter          [处理流]   → 加缓冲，提升字符写入效率
│       ├── OutputStreamWriter      [桥接流]   → 字符 → 字节转换，支持编码
│       └── PrintWriter             [处理流]   → 支持 println / printf 等格式化输出
```

### 7.2 常用流组合推荐


| 使用场景 | **推荐组合** | **优势** |
|---------|-------------|----------|
| `文本文件读取` | `BufferedReader + FileReader` | `高效+行读取` |
| `文本文件写入` | `BufferedWriter + FileWriter` | `高效+行写入` |
| `二进制文件操作` | `BufferedInputStream/OutputStream + FileInputStream/OutputStream` | `通用+高效` |
| `跨平台文本处理` | `BufferedReader + InputStreamReader` | `编码可控` |
| `对象持久化` | `ObjectInputStream/OutputStream` | `序列化支持` |

---

## 8. ⚖️ 功能设计角度对比


### 8.1 字节流vs字符流详细对比


| 特性 | **字节流** | **字符流** |
|------|-----------|-----------|
| `单位` | `8-bit（byte）` | `16-bit（char）` |
| `支持文件类型` | `所有类型（含图片、音频）` | `文本类文件（.txt, .java 等）` |
| `是否支持编码` | `不支持编码处理（原始字节）` | `自动或手动进行编码解码转换` |
| `缓冲区` | `需BufferedInputStream/OutputStream` | `需BufferedReader/Writer` |
| `按行读取` | `不支持` | `BufferedReader.readLine()` |
| `基类` | `InputStream/OutputStream` | `Reader/Writer` |
| `通常用途` | `文件复制、传输二进制、图像等` | `文本读取、配置文件、控制台输入输出` |
| `性能考虑` | `处理速度快，无编码转换开销` | `处理文本时更安全，有编码转换` |

### 8.2 流选择决策树


```
文件处理流选择决策：
                 开始
                  │
              文件类型？
         ┌─────────┼─────────┐
      文本文件              二进制文件
         │                    │
     需要指定编码？           直接选择
   ┌─────────┼─────────┐      字节流
  需要      不需要      │      │
   │         │        │      ▼
   ▼         ▼        ▼   FileInputStream
转换流    FileReader  │   FileOutputStream
  +         +       性能要求？    +
缓冲流     缓冲流   ┌─────┼─────┐ 缓冲流
                 高      一般
                 │        │
                 ▼        ▼
              缓冲流    直接使用
```

---

## 9. ⚠️ 常见错误与注意事项


### 9.1 资源管理原则


**🔸 资源关闭顺序**
- **后创建的资源先关闭**
- **依赖其他资源的先关闭**
- **使用try-with-resources自动管理**

**🔸 异常处理策略**
- **捕获具体异常**而非通用异常
- **提供有意义的错误信息**
- **关闭资源的异常也需处理**
- **考虑日志记录异常**

### 9.2 Java IO流使用重要原则


```java
├── 1. 始终关闭流
│   ├── 使用 try-with-resources（首选）
│   └── 或使用 finally 块中显式 close()
│
├── 2. 使用缓冲流提高性能
│   ├── BufferedReader / BufferedWriter
│   └── BufferedInputStream / BufferedOutputStream
│
├── 3. 文本处理优先使用字符流
│   └── Reader / Writer 处理编码更安全
│
├── 4. 二进制处理优先使用字节流
│   └── InputStream / OutputStream 适合图片、视频等
│
├── 5. 避免频繁创建流对象
│   └── 尤其在循环或多次调用中应复用
│
├── 6. 注意字符编码转换
│   └── 使用 InputStreamReader / OutputStreamWriter 指定编码（如 UTF-8）
│
├── 7. 处理大文件避免一次性读入
│   └── 使用分块读写 + 缓冲区
│
├── 8. 禁止混用字符流与字节流
│   └── 否则可能数据错乱或乱码
│
├── 9. 对象流必须实现 Serializable 接口
│   └── 否则序列化或反序列化失败
│
├── 10. 写数据前建议 flush()
│   └── 特别用于网络流、缓冲流
│
├── 11. 路径构建要跨平台
│   └── 使用 File.separator 或 Paths.get()
│
├── 12. 异常要显式处理
│   └── IOException 是受检异常
│
├── 13. 写文件前判断文件是否存在
│   └── File.exists() 或 createNewFile()
│
├── 14. 输出前判断是否可写
│   └── file.canWrite() 检查写权限
│
└── 15. 不要手动关闭 System.in/out/err
    └── 否则影响全局标准输入输出流
```

### 9.3 常见错误示例与解决


| 常见错误 | **错误原因** | **正确做法** |
|---------|-------------|-------------|
| `乱码问题` | `字符编码不一致` | `使用InputStreamReader指定编码` |
| `文件未关闭` | `忘记调用close()` | `使用try-with-resources` |
| `性能问题` | `未使用缓冲流` | `包装BufferedInputStream等` |
| `路径错误` | `硬编码路径分隔符` | `使用File.separator` |
| `空指针异常` | `流创建失败未检查` | `判断流是否为null` |

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 IO流四大基类：InputStream、OutputStream、Reader、Writer
🔸 字节流vs字符流：8位byte处理 vs 16位char处理
🔸 节点流vs处理流：直接数据源连接 vs 功能增强装饰
🔸 编码转换流：InputStreamReader、OutputStreamWriter
🔸 缓冲流：提高IO效率的重要手段
```

### 10.2 关键理解要点


**🔹 流的设计哲学**
```
统一抽象：
- 所有数据源都抽象为流
- 统一的读写接口
- 层次化的功能增强

装饰者模式：
- 基础流提供核心功能
- 处理流增强特定功能
- 灵活组合满足需求
```

**🔹 性能优化策略**
```
缓冲优先：
- 文件操作优先使用缓冲流
- 减少系统调用次数
- 显著提升IO性能

合理选择：
- 文本用字符流，二进制用字节流
- 根据数据特点选择合适的流
- 避免不必要的类型转换
```

**🔹 编码处理原则**
```
明确指定：
- 跨平台开发必须指定编码
- 使用UTF-8作为首选编码
- 避免依赖系统默认编码

转换流使用：
- InputStreamReader进行字节到字符转换
- OutputStreamWriter进行字符到字节转换
- 在构造时明确指定字符集
```

### 10.3 实际应用指导


**📝 流选择指南**

| 应用场景 | **推荐方案** | **核心理由** |
|---------|-------------|-------------|
| `文本文件读写` | `BufferedReader/Writer + FileReader/Writer` | `高效文本处理` |
| `二进制文件操作` | `BufferedInputStream/OutputStream + FileInputStream/OutputStream` | `通用高效` |
| `跨平台文本处理` | `转换流 + 指定编码` | `编码安全` |
| `对象持久化` | `ObjectInputStream/OutputStream` | `序列化专用` |
| `网络数据传输` | `字节流 + 缓冲` | `效率优先` |

### 10.4 最佳实践总结


**🛠️ 编程最佳实践**
```
资源管理：
✓ 优先使用try-with-resources
✓ 确保异常情况下也能正确关闭
✓ 注意关闭顺序

性能优化：
✓ 大文件操作使用缓冲流
✓ 合理设置缓冲区大小
✓ 避免频繁的小块读写

错误处理：
✓ 捕获具体的IOException
✓ 提供有意义的错误信息
✓ 记录异常日志便于调试

跨平台兼容：
✓ 使用标准路径分隔符
✓ 明确指定字符编码
✓ 测试不同操作系统
```
