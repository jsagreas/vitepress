---
title: 6ã€åå°„æ€§èƒ½ä¸ä¼˜åŒ–å»ºè®®
---
## ğŸ“š ç›®å½•

1. [åå°„çš„æ€§èƒ½å¼€é”€æœ¬è´¨](#1-åå°„çš„æ€§èƒ½å¼€é”€æœ¬è´¨)
2. [å…¸å‹åœºæ™¯ä¸‹çš„æ€§èƒ½å¯¹æ¯”](#2-å…¸å‹åœºæ™¯ä¸‹çš„æ€§èƒ½å¯¹æ¯”)
3. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#3-æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
4. [åå°„åœºæ™¯é€‚ç”¨æ€§å»ºè®®](#4-åå°„åœºæ™¯é€‚ç”¨æ€§å»ºè®®)
5. [JDKæ›¿ä»£æ–¹æ¡ˆ](#5-JDKæ›¿ä»£æ–¹æ¡ˆ)
6. [å®é™…ä¼˜åŒ–æ¡ˆä¾‹](#6-å®é™…ä¼˜åŒ–æ¡ˆä¾‹)
7. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#7-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ” åå°„çš„æ€§èƒ½å¼€é”€æœ¬è´¨


### 1.1 æ€§èƒ½å¼€é”€æ¥æºåˆ†æ


**ğŸ“Š åå°„æ€§èƒ½å¼€é”€æ„æˆè¡¨**

| å¼€é”€é¡¹ | **æè¿°** | **å½±å“ç¨‹åº¦** |
|-------|---------|-------------|
| **æ–¹æ³•æŸ¥æ‰¾æˆæœ¬** | åå°„è°ƒç”¨æ–¹æ³•æ—¶ï¼Œéœ€è¦è¿›è¡Œæ–¹æ³•ç­¾ååŒ¹é…ã€ç±»å‹æ ¡éªŒ | âš ï¸ é«˜ |
| **è®¿é—®æ£€æŸ¥æˆæœ¬** | é»˜è®¤ä¼šè¿›è¡Œæƒé™è®¿é—®æ£€æŸ¥ï¼ˆprivateã€protectedï¼‰ | âš ï¸ ä¸­ |
| **ç±»å‹è½¬æ¢æˆæœ¬** | `Object`ç±»å‹å‚æ•°çš„æ‹†ç®±/è£…ç®±ã€è½¬å‹å¼€é”€ | âš ï¸ ä¸­ |
| **è°ƒç”¨æ•ˆç‡é—®é¢˜** | `Method.invoke()`æ¯”ç›´æ¥è°ƒç”¨æ…¢10~50å€ï¼ˆJITä¼˜åŒ–å‰ï¼‰ | âš ï¸ æé«˜ |
| **å¼‚å¸¸å¤„ç†å¼€é”€** | éœ€è¦å¤„ç†å¤šç§æ£€æŸ¥å¼‚å¸¸ï¼Œå¢åŠ è°ƒç”¨æˆæœ¬ | âš ï¸ ä½ |

### 1.2 åå°„å¼€é”€è¯¦ç»†åˆ†æ


**ğŸ”§ åå°„è°ƒç”¨é“¾è·¯åˆ†æ**
```
åå°„è°ƒç”¨å®Œæ•´é“¾è·¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·ä»£ç è°ƒç”¨     â”‚ â”€â†’ â”‚  Method.invoke() â”‚ â”€â†’ â”‚  JVMå†…éƒ¨å¤„ç†     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚                        â”‚
                              â–¼                        â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  å‚æ•°ç±»å‹æ£€æŸ¥     â”‚    â”‚  æƒé™æ£€æŸ¥        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚                        â”‚
                              â–¼                        â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  è£…ç®±/æ‹†ç®±è½¬æ¢    â”‚    â”‚  nativeæ–¹æ³•è°ƒç”¨   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚                        â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  å®é™…æ–¹æ³•æ‰§è¡Œ     â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ’» æ€§èƒ½å¼€é”€ä»£ç ç¤ºä¾‹**
```java
public class ReflectionPerformanceDemo {
    
    private static final int ITERATIONS = 1_000_000;
    
    static class TestObject {
        private int value = 42;
        
        public int getValue() {
            return value;
        }
        
        public void setValue(int value) {
            this.value = value;
        }
        
        public int calculate(int a, int b) {
            return a + b + value;
        }
    }
    
    public static void main(String[] args) throws Exception {
        TestObject obj = new TestObject();
        
        // æµ‹è¯•1: ç›´æ¥è°ƒç”¨ vs åå°„è°ƒç”¨
        compareDirectVsReflection(obj);
        
        // æµ‹è¯•2: å­—æ®µè®¿é—®å¯¹æ¯”
        compareFieldAccess(obj);
        
        // æµ‹è¯•3: æ„é€ å™¨å¯¹æ¯”
        compareConstructorCreation();
    }
    
    private static void compareDirectVsReflection(TestObject obj) throws Exception {
        // é¢„çƒ­JVM
        for (int i = 0; i < 10000; i++) {
            obj.getValue();
        }
        
        Method getMethod = TestObject.class.getMethod("getValue");
        
        // ç›´æ¥è°ƒç”¨æµ‹è¯•
        long startTime = System.nanoTime();
        int sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += obj.getValue();
        }
        long directTime = System.nanoTime() - startTime;
        
        // åå°„è°ƒç”¨æµ‹è¯•
        startTime = System.nanoTime();
        sum = 0;
        for (int i = 0; i < ITERATIONS; i++) {
            sum += (Integer) getMethod.invoke(obj);
        }
        long reflectionTime = System.nanoTime() - startTime;
        
        System.out.printf("æ–¹æ³•è°ƒç”¨æ€§èƒ½å¯¹æ¯” (%dæ¬¡è°ƒç”¨):%n", ITERATIONS);
        System.out.printf("ç›´æ¥è°ƒç”¨è€—æ—¶: %d ms%n", directTime / 1_000_000);
        System.out.printf("åå°„è°ƒç”¨è€—æ—¶: %d ms%n", reflectionTime / 1_000_000);
        System.out.printf("åå°„æ¯”ç›´æ¥è°ƒç”¨æ…¢: %.1få€%n", (double) reflectionTime / directTime);
    }
    
    private static void compareFieldAccess(TestObject obj) throws Exception {
        Field valueField = TestObject.class.getDeclaredField("value");
        valueField.setAccessible(true);
        
        // ç›´æ¥è®¿é—®
        long startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            obj.setValue(i % 100);
            int val = obj.getValue();
        }
        long directTime = System.nanoTime() - startTime;
        
        // åå°„è®¿é—®
        startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            valueField.set(obj, i % 100);
            int val = (Integer) valueField.get(obj);
        }
        long reflectionTime = System.nanoTime() - startTime;
        
        System.out.printf("%nå­—æ®µè®¿é—®æ€§èƒ½å¯¹æ¯” (%dæ¬¡è®¿é—®):%n", ITERATIONS);
        System.out.printf("ç›´æ¥è®¿é—®è€—æ—¶: %d ms%n", directTime / 1_000_000);
        System.out.printf("åå°„è®¿é—®è€—æ—¶: %d ms%n", reflectionTime / 1_000_000);
        System.out.printf("åå°„æ¯”ç›´æ¥è®¿é—®æ…¢: %.1få€%n", (double) reflectionTime / directTime);
    }
    
    private static void compareConstructorCreation() throws Exception {
        Constructor<TestObject> constructor = TestObject.class.getConstructor();
        
        // ç›´æ¥åˆ›å»º
        long startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            TestObject obj = new TestObject();
        }
        long directTime = System.nanoTime() - startTime;
        
        // åå°„åˆ›å»º
        startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            TestObject obj = constructor.newInstance();
        }
        long reflectionTime = System.nanoTime() - startTime;
        
        System.out.printf("%nå¯¹è±¡åˆ›å»ºæ€§èƒ½å¯¹æ¯” (%dæ¬¡åˆ›å»º):%n", ITERATIONS);
        System.out.printf("ç›´æ¥åˆ›å»ºè€—æ—¶: %d ms%n", directTime / 1_000_000);
        System.out.printf("åå°„åˆ›å»ºè€—æ—¶: %d ms%n", reflectionTime / 1_000_000);
        System.out.printf("åå°„æ¯”ç›´æ¥åˆ›å»ºæ…¢: %.1få€%n", (double) reflectionTime / directTime);
    }
}
```

---

## 2. ğŸ“Š å…¸å‹åœºæ™¯ä¸‹çš„æ€§èƒ½å¯¹æ¯”


### 2.1 ä¸åŒæ“ä½œçš„æ€§èƒ½å·®å¼‚


**ğŸ“‹ æ€§èƒ½å¯¹æ¯”æ±‡æ€»è¡¨**

| åœºæ™¯ | **ç›´æ¥è°ƒç”¨** | **åå°„è°ƒç”¨** | **æ€§èƒ½å·®å¼‚** |
|-----|------------|-------------|-------------|
| **ç®€å•getter** | 1x (åŸºå‡†) | 10x~30x (æ…¢) | åå°„æ…¢10-30å€ |
| **æ„é€ å™¨å®ä¾‹åŒ–** | `new` (æå¿«) | `Constructor.newInstance()` | åå°„æ…¢5-10å€ |
| **æ–¹æ³•è°ƒç”¨é¢‘ç¹** | æ•ˆç‡é«˜ï¼ŒJITä¼˜åŒ– | æ¯æ¬¡éƒ½åšç±»å‹å’Œæƒé™æ ¡éªŒï¼Œæ•ˆç‡ä½ | åå°„æ…¢15-50å€ |
| **å­—æ®µè¯»å†™** | ç›´æ¥å†…å­˜è®¿é—® | é€šè¿‡Field.get/set | åå°„æ…¢8-20å€ |
| **å¤æ‚å‚æ•°æ–¹æ³•** | æ— é¢å¤–å¼€é”€ | è£…ç®±æ‹†ç®±+ç±»å‹æ£€æŸ¥ | åå°„æ…¢20-100å€ |

### 2.2 JITç¼–è¯‘å™¨å¯¹åå°„çš„å½±å“


**âš¡ JITä¼˜åŒ–å·®å¼‚åˆ†æ**
```
JITç¼–è¯‘å™¨ä¼˜åŒ–èƒ½åŠ›å¯¹æ¯”
â”œâ”€â”€ ç›´æ¥è°ƒç”¨
â”‚   â”œâ”€â”€ âœ… å¯ä»¥å†…è”ä¼˜åŒ–
â”‚   â”œâ”€â”€ âœ… å¯ä»¥æ¶ˆé™¤å†—ä½™æ£€æŸ¥
â”‚   â”œâ”€â”€ âœ… å¯ä»¥è¿›è¡Œæ–¹æ³•ç‰¹åŒ–
â”‚   â””â”€â”€ âœ… ç¼–è¯‘ä¸ºé«˜æ•ˆçš„æœºå™¨ç 
â”‚
â””â”€â”€ åå°„è°ƒç”¨
    â”œâ”€â”€ âŒ æ— æ³•å†…è”ä¼˜åŒ–ï¼ˆè°ƒç”¨ç›®æ ‡ä¸ç¡®å®šï¼‰
    â”œâ”€â”€ âŒ æ— æ³•æ¶ˆé™¤ç±»å‹æ£€æŸ¥
    â”œâ”€â”€ âŒ éœ€è¦ä¿ç•™å®Œæ•´çš„è°ƒç”¨æ ˆ
    â””â”€â”€ âŒ å¤§é‡é€šè¿‡nativeæ–¹æ³•æ‰§è¡Œ
```

---

## 3. ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


### 3.1 ç¼“å­˜åå°„å¯¹è±¡ï¼ˆæœ€é‡è¦ï¼‰


**ğŸ’¾ åå°„å¯¹è±¡ç¼“å­˜å®ç°**
```java
public class ReflectionCache {
    
    // æ–¹æ³•ç¼“å­˜
    private static final Map<String, Method> METHOD_CACHE = new ConcurrentHashMap<>();
    
    // å­—æ®µç¼“å­˜
    private static final Map<String, Field> FIELD_CACHE = new ConcurrentHashMap<>();
    
    // æ„é€ å™¨ç¼“å­˜
    private static final Map<String, Constructor<?>> CONSTRUCTOR_CACHE = new ConcurrentHashMap<>();
    
    /**
     * è·å–ç¼“å­˜çš„æ–¹æ³•
     */
    public static Method getCachedMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
        String key = buildMethodKey(clazz, methodName, paramTypes);
        return METHOD_CACHE.computeIfAbsent(key, k -> {
            try {
                Method method = clazz.getDeclaredMethod(methodName, paramTypes);
                method.setAccessible(true);
                return method;
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("æ–¹æ³•ä¸å­˜åœ¨: " + k, e);
            }
        });
    }
    
    /**
     * è·å–ç¼“å­˜çš„å­—æ®µ
     */
    public static Field getCachedField(Class<?> clazz, String fieldName) {
        String key = clazz.getName() + "#" + fieldName;
        return FIELD_CACHE.computeIfAbsent(key, k -> {
            try {
                Field field = clazz.getDeclaredField(fieldName);
                field.setAccessible(true);
                return field;
            } catch (NoSuchFieldException e) {
                throw new RuntimeException("å­—æ®µä¸å­˜åœ¨: " + k, e);
            }
        });
    }
    
    /**
     * è·å–ç¼“å­˜çš„æ„é€ å™¨
     */
    public static Constructor<?> getCachedConstructor(Class<?> clazz, Class<?>... paramTypes) {
        String key = buildConstructorKey(clazz, paramTypes);
        return CONSTRUCTOR_CACHE.computeIfAbsent(key, k -> {
            try {
                Constructor<?> constructor = clazz.getDeclaredConstructor(paramTypes);
                constructor.setAccessible(true);
                return constructor;
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("æ„é€ å™¨ä¸å­˜åœ¨: " + k, e);
            }
        });
    }
    
    private static String buildMethodKey(Class<?> clazz, String methodName, Class<?>... paramTypes) {
        StringBuilder key = new StringBuilder(clazz.getName())
            .append("#").append(methodName).append("(");
        for (int i = 0; i < paramTypes.length; i++) {
            if (i > 0) key.append(",");
            key.append(paramTypes[i].getName());
        }
        return key.append(")").toString();
    }
    
    private static String buildConstructorKey(Class<?> clazz, Class<?>... paramTypes) {
        StringBuilder key = new StringBuilder(clazz.getName()).append("(");
        for (int i = 0; i < paramTypes.length; i++) {
            if (i > 0) key.append(",");
            key.append(paramTypes[i].getName());
        }
        return key.append(")").toString();
    }
    
    /**
     * æ¸…ç©ºç¼“å­˜ï¼ˆæµ‹è¯•æˆ–å†…å­˜ç®¡ç†æ—¶ä½¿ç”¨ï¼‰
     */
    public static void clearCache() {
        METHOD_CACHE.clear();
        FIELD_CACHE.clear();
        CONSTRUCTOR_CACHE.clear();
    }
    
    /**
     * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
     */
    public static String getCacheStats() {
        return String.format("ç¼“å­˜ç»Ÿè®¡ - æ–¹æ³•: %d, å­—æ®µ: %d, æ„é€ å™¨: %d", 
            METHOD_CACHE.size(), FIELD_CACHE.size(), CONSTRUCTOR_CACHE.size());
    }
}
```

### 3.2 ä½¿ç”¨setAccessibleä¼˜åŒ–è®¿é—®æ£€æŸ¥


**ğŸ”“ è®¿é—®æƒé™ä¼˜åŒ–**
```java
public class AccessibleOptimization {
    
    /**
     * æ‰¹é‡è®¾ç½®accessibleï¼Œå‡å°‘é‡å¤æƒé™æ£€æŸ¥
     */
    public static void optimizeClassAccess(Class<?> clazz) {
        // ä¼˜åŒ–æ‰€æœ‰å­—æ®µè®¿é—®
        Field[] fields = clazz.getDeclaredFields();
        AccessibleObject.setAccessible(fields, true);
        
        // ä¼˜åŒ–æ‰€æœ‰æ–¹æ³•è®¿é—®
        Method[] methods = clazz.getDeclaredMethods();
        AccessibleObject.setAccessible(methods, true);
        
        // ä¼˜åŒ–æ‰€æœ‰æ„é€ å™¨è®¿é—®
        Constructor<?>[] constructors = clazz.getDeclaredConstructors();
        AccessibleObject.setAccessible(constructors, true);
        
        System.out.println("å·²ä¼˜åŒ–ç±»çš„è®¿é—®æƒé™: " + clazz.getName());
    }
    
    /**
     * å®‰å…¨çš„setAccessibleè°ƒç”¨ï¼ˆå¤„ç†æ¨¡å—åŒ–é™åˆ¶ï¼‰
     */
    public static boolean setAccessibleSafely(AccessibleObject object) {
        try {
            object.setAccessible(true);
            return true;
        } catch (InaccessibleObjectException e) {
            System.err.println("æ¨¡å—åŒ–é™åˆ¶ï¼Œæ— æ³•è®¾ç½®accessible: " + e.getMessage());
            return false;
        } catch (SecurityException e) {
            System.err.println("å®‰å…¨ç®¡ç†å™¨é™åˆ¶ï¼Œæ— æ³•è®¾ç½®accessible: " + e.getMessage());
            return false;
        }
    }
}
```

### 3.3 MethodHandleé«˜æ€§èƒ½æ›¿ä»£æ–¹æ¡ˆ


**âš¡ MethodHandleä½¿ç”¨ç¤ºä¾‹**
```java
import java.lang.invoke.*;

public class MethodHandleOptimization {
    
    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
    
    static class Person {
        private String name;
        private int age;
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public int getAge() { return age; }
        public void setAge(int age) { this.age = age; }
    }
    
    public static void main(String[] args) throws Throwable {
        Person person = new Person("Alice", 25);
        
        // æ€§èƒ½å¯¹æ¯”æµ‹è¯•
        comparePerformance(person);
    }
    
    private static void comparePerformance(Person person) throws Throwable {
        int iterations = 1_000_000;
        
        // 1. ç›´æ¥è°ƒç”¨
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            String name = person.getName();
            person.setAge(i % 100);
        }
        long directTime = System.nanoTime() - startTime;
        
        // 2. ä¼ ç»Ÿåå°„è°ƒç”¨
        Method getName = Person.class.getMethod("getName");
        Method setAge = Person.class.getMethod("setAge", int.class);
        
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            String name = (String) getName.invoke(person);
            setAge.invoke(person, i % 100);
        }
        long reflectionTime = System.nanoTime() - startTime;
        
        // 3. MethodHandleè°ƒç”¨
        MethodHandle getNameHandle = LOOKUP.findVirtual(Person.class, "getName", 
            MethodType.methodType(String.class));
        MethodHandle setAgeHandle = LOOKUP.findVirtual(Person.class, "setAge", 
            MethodType.methodType(void.class, int.class));
        
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            String name = (String) getNameHandle.invokeExact(person);
            setAgeHandle.invokeExact(person, i % 100);
        }
        long methodHandleTime = System.nanoTime() - startTime;
        
        // 4. å­—æ®µç›´æ¥è®¿é—®çš„MethodHandle
        MethodHandle nameFieldGetter = LOOKUP.findGetter(Person.class, "name", String.class);
        MethodHandle ageFieldSetter = LOOKUP.findSetter(Person.class, "age", int.class);
        
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            String name = (String) nameFieldGetter.invokeExact(person);
            ageFieldSetter.invokeExact(person, i % 100);
        }
        long fieldHandleTime = System.nanoTime() - startTime;
        
        // è¾“å‡ºç»“æœ
        System.out.printf("æ€§èƒ½å¯¹æ¯”ç»“æœ (%dæ¬¡æ“ä½œ):%n", iterations);
        System.out.printf("ç›´æ¥è°ƒç”¨:        %6d ms (åŸºå‡†)%n", directTime / 1_000_000);
        System.out.printf("ä¼ ç»Ÿåå°„:        %6d ms (%.1fx)%n", 
            reflectionTime / 1_000_000, (double) reflectionTime / directTime);
        System.out.printf("MethodHandle:    %6d ms (%.1fx)%n", 
            methodHandleTime / 1_000_000, (double) methodHandleTime / directTime);
        System.out.printf("å­—æ®µMethodHandle: %6d ms (%.1fx)%n", 
            fieldHandleTime / 1_000_000, (double) fieldHandleTime / directTime);
    }
}
```

### 3.4 ä»£ç ç”Ÿæˆä¼˜åŒ–æ–¹æ¡ˆ


**ğŸ”§ å­—èŠ‚ç ç”Ÿæˆç¤ºä¾‹ï¼ˆä½¿ç”¨ASMï¼‰**
```java
// æ³¨æ„ï¼šè¿™é‡Œå±•ç¤ºæ¦‚å¿µï¼Œå®é™…ä½¿ç”¨éœ€è¦æ·»åŠ ASMä¾èµ–
public class BytecodeGenerationExample {
    
    /**
     * æ¦‚å¿µæ€§ç¤ºä¾‹ï¼šç”Ÿæˆé«˜æ€§èƒ½è®¿é—®å™¨
     */
    public static class GeneratedAccessor {
        
        // è¿™äº›æ–¹æ³•å¯ä»¥é€šè¿‡ASMç­‰å·¥å…·åŠ¨æ€ç”Ÿæˆ
        public static String getPersonName(Person person) {
            return person.getName(); // ç›´æ¥è°ƒç”¨ï¼Œæ— åå°„å¼€é”€
        }
        
        public static void setPersonAge(Person person, int age) {
            person.setAge(age); // ç›´æ¥è°ƒç”¨ï¼Œæ— åå°„å¼€é”€
        }
    }
    
    /**
     * ä½¿ç”¨å·¥å…·ç±»å®ç°é«˜æ€§èƒ½åå°„æ›¿ä»£
     */
    public static class ReflectionAlternative {
        
        // ä½¿ç”¨å‡½æ•°å¼æ¥å£æ›¿ä»£åå°„è°ƒç”¨
        public static final Function<Person, String> NAME_GETTER = Person::getName;
        public static final BiConsumer<Person, Integer> AGE_SETTER = Person::setAge;
        
        public static void demonstratePerformance() {
            Person person = new Person("Test", 20);
            int iterations = 1_000_000;
            
            // ä½¿ç”¨æ–¹æ³•å¼•ç”¨ï¼ˆæ¥è¿‘ç›´æ¥è°ƒç”¨æ€§èƒ½ï¼‰
            long startTime = System.nanoTime();
            for (int i = 0; i < iterations; i++) {
                String name = NAME_GETTER.apply(person);
                AGE_SETTER.accept(person, i % 100);
            }
            long methodRefTime = System.nanoTime() - startTime;
            
            System.out.printf("æ–¹æ³•å¼•ç”¨è°ƒç”¨è€—æ—¶: %d ms%n", methodRefTime / 1_000_000);
        }
    }
}
```

### 3.5 ç¬¬ä¸‰æ–¹å·¥å…·åº“ä¼˜åŒ–


**ğŸ› ï¸ ä¼˜åŒ–å·¥å…·å¯¹æ¯”è¡¨**

| å·¥å…· | **ä¼˜åŠ¿** | **ä½¿ç”¨åœºæ™¯** |
|-----|---------|-------------|
| **Apache Commons BeanUtils** | æ“ä½œJavaBeançš„å­—æ®µä¸å±æ€§ | Beanå±æ€§æ‹·è´ã€ç±»å‹è½¬æ¢ |
| **Spring ReflectionUtils** | è‡ªåŠ¨è®¾ç½®accessibleã€å°è£…å¼‚å¸¸ | Springé¡¹ç›®ä¸­çš„åå°„æ“ä½œ |
| **cglib BeanCopier** | æ›¿ä»£`set()/get()`ï¼Œæ€§èƒ½ä¼˜äºåå°„ | é«˜æ€§èƒ½Beanæ‹·è´ |
| **MapStruct** | ç¼–è¯‘æœŸç”Ÿæˆä»£ç ï¼Œé›¶åå°„å¼€é”€ | å¯¹è±¡æ˜ å°„è½¬æ¢ |
| **Lombok** | ç¼–è¯‘æœŸç”Ÿæˆgetter/setter | å‡å°‘æ ·æ¿ä»£ç  |

**ğŸ’» å·¥å…·ä½¿ç”¨ç¤ºä¾‹**
```java
// 1. Spring ReflectionUtilsç¤ºä¾‹
public class SpringReflectionExample {
    
    public static void useSpringUtils(Object target) {
        // Springæä¾›çš„å·¥å…·ç±»ï¼Œè‡ªåŠ¨å¤„ç†å¼‚å¸¸å’Œaccessible
        Field nameField = ReflectionUtils.findField(target.getClass(), "name");
        ReflectionUtils.makeAccessible(nameField);
        
        Object value = ReflectionUtils.getField(nameField, target);
        ReflectionUtils.setField(nameField, target, "newValue");
        
        Method method = ReflectionUtils.findMethod(target.getClass(), "processData", String.class);
        ReflectionUtils.makeAccessible(method);
        ReflectionUtils.invokeMethod(method, target, "parameter");
    }
}

// 2. é«˜æ€§èƒ½Beanæ‹·è´
public class HighPerformanceBeanCopy {
    
    // cglib BeanCopierï¼ˆéœ€è¦æ·»åŠ cglibä¾èµ–ï¼‰
    private static final BeanCopier PERSON_COPIER = 
        BeanCopier.create(Person.class, PersonDTO.class, false);
    
    public static PersonDTO copyPersonOptimized(Person source) {
        PersonDTO target = new PersonDTO();
        PERSON_COPIER.copy(source, target, null);
        return target;
    }
    
    // ä½¿ç”¨MapStructï¼ˆç¼–è¯‘æœŸç”Ÿæˆï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ï¼‰
    @Mapper
    public interface PersonMapper {
        PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);
        
        PersonDTO personToDto(Person person);
        Person dtoToPerson(PersonDTO dto);
    }
}
```

---

## 4. ğŸ¯ åå°„åœºæ™¯é€‚ç”¨æ€§å»ºè®®


### 4.1 åå°„é€‚ç”¨æ€§è¯„ä¼°è¡¨


**ğŸ“‹ åœºæ™¯é€‚ç”¨æ€§æŒ‡å¯¼**

| åœºæ™¯ | **å»ºè®®ä½¿ç”¨åå°„ï¼Ÿ** | **åŸå› ** | **æ›¿ä»£æ–¹æ¡ˆ** |
|-----|------------------|---------|-------------|
| **ä¸€æ¬¡æ€§é…ç½®è¯»å–ã€æ¡†æ¶åˆå§‹åŒ–** | âœ… å¯ä»¥ | ä¸é¢‘ç¹æ‰§è¡Œï¼Œä¾¿äºæ‰©å±• | é…ç½®ç±»ã€Builderæ¨¡å¼ |
| **æ€§èƒ½æ•æ„Ÿæ ¸å¿ƒä¸šåŠ¡è°ƒç”¨** | âŒ é¿å… | æ€§èƒ½æŸè€—å¤§ï¼Œåº”æ”¹ä¸ºç›´æ¥è°ƒç”¨æˆ–ç”Ÿæˆä»£ç  | ç›´æ¥è°ƒç”¨ã€ä»£ç ç”Ÿæˆ |
| **æ‰¹é‡å±æ€§æ˜ å°„ï¼ˆBeanâ†’Mapï¼‰** | âš ï¸ æ…ç”¨ | å»ºè®®é…åˆå·¥å…·ç±»æˆ–ç¼“å­˜åå°„å…ƒä¿¡æ¯ | MapStructã€BeanCopier |
| **è·¨ç‰ˆæœ¬æ’ä»¶åŠ è½½ã€è§£è€¦ç»„ä»¶è°ƒç”¨** | âœ… åˆç†ä½¿ç”¨ | æ— æ³•é™æ€ç»‘å®šæ—¶ä½¿ç”¨åå°„æ˜¯å¯è¡Œè§£æ³• | SPIã€ä¾èµ–æ³¨å…¥ |
| **æµ‹è¯•ä»£ç ä¸­è®¿é—®ç§æœ‰æˆå‘˜** | âœ… æ¨è | æµ‹è¯•éœ€è¦éªŒè¯å†…éƒ¨çŠ¶æ€ | æµ‹è¯•ä¸“ç”¨æ–¹æ³• |
| **é«˜é¢‘å¾ªç¯ä¸­çš„å­—æ®µè®¿é—®** | âŒ ç»å¯¹é¿å… | æ€§èƒ½å½±å“å·¨å¤§ | ç¼“å­˜ç»“æœã€ç›´æ¥è®¿é—® |

### 4.2 å†³ç­–æµç¨‹å›¾


**ğŸŒ³ åå°„ä½¿ç”¨å†³ç­–æ ‘**
```
æ˜¯å¦ä½¿ç”¨åå°„å†³ç­–æµç¨‹
â”œâ”€â”€ æ˜¯å¦ä¸ºæ€§èƒ½æ•æ„Ÿçš„çƒ­ç‚¹ä»£ç ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ âŒ ä¸å»ºè®®ä½¿ç”¨åå°„
â”‚   â”‚   â””â”€â”€ æ›¿ä»£æ–¹æ¡ˆï¼šç›´æ¥è°ƒç”¨ã€ä»£ç ç”Ÿæˆã€MethodHandle
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­è¯„ä¼°
â”‚
â”œâ”€â”€ æ˜¯å¦ä¸ºä¸€æ¬¡æ€§æˆ–ä½é¢‘æ“ä½œï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ âœ… å¯ä»¥ä½¿ç”¨åå°„
â”‚   â”‚   â””â”€â”€ åœºæ™¯ï¼šé…ç½®åˆå§‹åŒ–ã€æ’ä»¶åŠ è½½
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­è¯„ä¼°
â”‚
â”œâ”€â”€ æ˜¯å¦å¯ä»¥ç¼“å­˜åå°„å¯¹è±¡ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ âš ï¸ è°¨æ…ä½¿ç”¨åå°„
â”‚   â”‚   â””â”€â”€ å»ºè®®ï¼šç¼“å­˜Method/Fieldå¯¹è±¡
â”‚   â””â”€â”€ å¦ â†’ âŒ ä¸å»ºè®®ä½¿ç”¨åå°„
â”‚
â””â”€â”€ æ˜¯å¦æœ‰å…¶ä»–æ›¿ä»£æ–¹æ¡ˆï¼Ÿ
    â”œâ”€â”€ æœ‰ â†’ ä¼˜å…ˆè€ƒè™‘æ›¿ä»£æ–¹æ¡ˆ
    â””â”€â”€ æ²¡æœ‰ â†’ âœ… å¯ä»¥ä½¿ç”¨åå°„
```

---

## 5. ğŸ”„ JDKæ›¿ä»£æ–¹æ¡ˆ


### 5.1 MethodHandleè¯¦è§£


**âš¡ MethodHandle vs ä¼ ç»Ÿåå°„å¯¹æ¯”**

| ç‰¹æ€§ | **MethodHandle** | **ä¼ ç»Ÿåå°„** |
|-----|-----------------|-------------|
| **æ€§èƒ½** | æ¥è¿‘ç›´æ¥è°ƒç”¨ | æ¯”ç›´æ¥è°ƒç”¨æ…¢10-50å€ |
| **ç±»å‹å®‰å…¨** | ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ | è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ |
| **JITä¼˜åŒ–** | æ”¯æŒå†…è”ä¼˜åŒ– | éš¾ä»¥ä¼˜åŒ– |
| **è°ƒç”¨æ–¹å¼** | `invokeExact()`, `invoke()` | `Method.invoke()` |
| **å­¦ä¹ æˆæœ¬** | è¾ƒé«˜ | è¾ƒä½ |

**ğŸ’» MethodHandleå®è·µæŒ‡å—**
```java
public class MethodHandleGuide {
    
    static class Calculator {
        public int add(int a, int b) {
            return a + b;
        }
        
        public static int multiply(int a, int b) {
            return a * b;
        }
    }
    
    public static void main(String[] args) throws Throwable {
        demonstrateMethodHandles();
    }
    
    private static void demonstrateMethodHandles() throws Throwable {
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        
        // 1. å®ä¾‹æ–¹æ³•çš„MethodHandle
        MethodHandle addHandle = lookup.findVirtual(
            Calculator.class, 
            "add", 
            MethodType.methodType(int.class, int.class, int.class)
        );
        
        Calculator calc = new Calculator();
        int result1 = (int) addHandle.invokeExact(calc, 5, 3);
        System.out.println("MethodHandleå®ä¾‹æ–¹æ³•è°ƒç”¨ç»“æœ: " + result1);
        
        // 2. é™æ€æ–¹æ³•çš„MethodHandle
        MethodHandle multiplyHandle = lookup.findStatic(
            Calculator.class,
            "multiply",
            MethodType.methodType(int.class, int.class, int.class)
        );
        
        int result2 = (int) multiplyHandle.invokeExact(4, 6);
        System.out.println("MethodHandleé™æ€æ–¹æ³•è°ƒç”¨ç»“æœ: " + result2);
        
        // 3. æ„é€ å™¨çš„MethodHandle
        MethodHandle constructorHandle = lookup.findConstructor(
            Calculator.class,
            MethodType.methodType(void.class)
        );
        
        Calculator newCalc = (Calculator) constructorHandle.invokeExact();
        System.out.println("MethodHandleæ„é€ å™¨è°ƒç”¨æˆåŠŸ");
        
        // 4. å­—æ®µè®¿é—®çš„MethodHandle
        // å‡è®¾Calculatoræœ‰ä¸€ä¸ªpublicå­—æ®µresult
        try {
            MethodHandle resultGetter = lookup.findGetter(Calculator.class, "result", int.class);
            MethodHandle resultSetter = lookup.findSetter(Calculator.class, "result", int.class);
            
            resultSetter.invokeExact(calc, 100);
            int fieldValue = (int) resultGetter.invokeExact(calc);
            System.out.println("MethodHandleå­—æ®µè®¿é—®ç»“æœ: " + fieldValue);
        } catch (NoSuchFieldException e) {
            System.out.println("Calculatorç±»æ²¡æœ‰resultå­—æ®µ");
        }
    }
}
```

### 5.2 Lambda + æ–¹æ³•å¼•ç”¨ä¼˜åŒ–


**ğŸ”§ å‡½æ•°å¼æ¥å£æ›¿ä»£åå°„**
```java
import java.util.function.*;

public class LambdaOptimization {
    
    static class Person {
        private String name;
        private int age;
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        // getters and setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public int getAge() { return age; }
        public void setAge(int age) { this.age = age; }
    }
    
    // ä½¿ç”¨å‡½æ•°å¼æ¥å£æ›¿ä»£åå°„è°ƒç”¨
    public static class PersonAccessor {
        
        // Getterå‡½æ•°
        public static final Function<Person, String> NAME_GETTER = Person::getName;
        public static final Function<Person, Integer> AGE_GETTER = Person::getAge;
        
        // Setterå‡½æ•°  
        public static final BiConsumer<Person, String> NAME_SETTER = Person::setName;
        public static final BiConsumer<Person, Integer> AGE_SETTER = Person::setAge;
        
        // æ„é€ å™¨å‡½æ•°
        public static final BiFunction<String, Integer, Person> PERSON_CONSTRUCTOR = Person::new;
    }
    
    public static void demonstrateLambdaPerformance() {
        int iterations = 1_000_000;
        
        // ä½¿ç”¨Lambdaæ–¹æ³•å¼•ç”¨
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            Person person = PersonAccessor.PERSON_CONSTRUCTOR.apply("Test" + i, i % 100);
            String name = PersonAccessor.NAME_GETTER.apply(person);
            PersonAccessor.AGE_SETTER.accept(person, i % 50);
        }
        long lambdaTime = System.nanoTime() - startTime;
        
        System.out.printf("Lambdaæ–¹æ³•å¼•ç”¨è€—æ—¶: %d ms%n", lambdaTime / 1_000_000);
        System.out.println("æ€§èƒ½æ¥è¿‘ç›´æ¥è°ƒç”¨ï¼Œè¿œä¼˜äºä¼ ç»Ÿåå°„");
    }
    
    /**
     * é€šç”¨çš„å±æ€§è®¿é—®å™¨ç”Ÿæˆå™¨
     */
    public static class PropertyAccessorGenerator {
        
        public static <T, R> Function<T, R> createGetter(Class<T> clazz, String propertyName) {
            // å®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨LambdaMetafactoryåŠ¨æ€ç”Ÿæˆ
            // è¿™é‡Œç®€åŒ–ç¤ºä¾‹
            return obj -> {
                try {
                    Method getter = clazz.getMethod("get" + capitalize(propertyName));
                    return (R) getter.invoke(obj);
                } catch (Exception e) {
                    throw new RuntimeException("Failed to get property: " + propertyName, e);
                }
            };
        }
        
        public static <T, V> BiConsumer<T, V> createSetter(Class<T> clazz, String propertyName, Class<V> valueType) {
            return (obj, value) -> {
                try {
                    Method setter = clazz.getMethod("set" + capitalize(propertyName), valueType);
                    setter.invoke(obj, value);
                } catch (Exception e) {
                    throw new RuntimeException("Failed to set property: " + propertyName, e);
                }
            };
        }
        
        private static String capitalize(String str) {
            return Character.toUpperCase(str.charAt(0)) + str.substring(1);
        }
    }
}
```

---

## 6. ğŸ”§ å®é™…ä¼˜åŒ–æ¡ˆä¾‹


### 6.1 Beanå±æ€§æ‹·è´ä¼˜åŒ–


**ğŸ’» å®Œæ•´çš„Beanæ‹·è´ä¼˜åŒ–å®ç°**
```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.*;

public class OptimizedBeanCopier {
    
    // ç¼“å­˜æ‹·è´å™¨ï¼Œé¿å…é‡å¤åˆ›å»º
    private static final Map<String, PropertyCopier> COPIER_CACHE = new ConcurrentHashMap<>();
    
    /**
     * é«˜æ€§èƒ½Beanæ‹·è´
     */
    public static <S, T> void copy(S source, T target) {
        String key = source.getClass().getName() + "->" + target.getClass().getName();
        PropertyCopier copier = COPIER_CACHE.computeIfAbsent(key, k -> 
            createCopier(source.getClass(), target.getClass()));
        
        copier.copy(source, target);
    }
    
    /**
     * åˆ›å»ºå±æ€§æ‹·è´å™¨ï¼ˆä¸€æ¬¡æ€§åå°„ï¼Œåç»­ç›´æ¥è°ƒç”¨ï¼‰
     */
    @SuppressWarnings("unchecked")
    private static <S, T> PropertyCopier createCopier(Class<S> sourceClass, Class<T> targetClass) {
        Map<String, PropertyMapping> mappings = new HashMap<>();
        
        // åˆ†ææºç±»çš„getteræ–¹æ³•
        for (Method sourceMethod : sourceClass.getMethods()) {
            if (isGetter(sourceMethod)) {
                String propertyName = getPropertyName(sourceMethod);
                
                // æŸ¥æ‰¾ç›®æ ‡ç±»å¯¹åº”çš„setteræ–¹æ³•
                try {
                    String setterName = "set" + Character.toUpperCase(propertyName.charAt(0)) + 
                        propertyName.substring(1);
                    Method targetMethod = targetClass.getMethod(setterName, sourceMethod.getReturnType());
                    
                    // åˆ›å»ºå±æ€§æ˜ å°„
                    PropertyMapping mapping = new PropertyMapping(sourceMethod, targetMethod);
                    mappings.put(propertyName, mapping);
                } catch (NoSuchMethodException e) {
                    // ç›®æ ‡ç±»æ²¡æœ‰å¯¹åº”setterï¼Œè·³è¿‡
                }
            }
        }
        
        return new PropertyCopier(mappings);
    }
    
    private static boolean isGetter(Method method) {
        return method.getName().startsWith("get") && 
               method.getParameterCount() == 0 && 
               !method.getReturnType().equals(void.class);
    }
    
    private static String getPropertyName(Method getter) {
        String methodName = getter.getName();
        return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);
    }
    
    /**
     * å±æ€§æ˜ å°„ä¿¡æ¯
     */
    private static class PropertyMapping {
        private final Method getter;
        private final Method setter;
        
        public PropertyMapping(Method getter, Method setter) {
            this.getter = getter;
            this.setter = setter;
            // é¢„å…ˆè®¾ç½®accessibleï¼Œé¿å…è¿è¡Œæ—¶æ£€æŸ¥
            this.getter.setAccessible(true);
            this.setter.setAccessible(true);
        }
        
        public void copy(Object source, Object target) throws Exception {
            Object value = getter.invoke(source);
            if (value != null) {
                setter.invoke(target, value);
            }
        }
    }
    
    /**
     * å±æ€§æ‹·è´å™¨
     */
    private static class PropertyCopier {
        private final Map<String, PropertyMapping> mappings;
        
        public PropertyCopier(Map<String, PropertyMapping> mappings) {
            this.mappings = mappings;
        }
        
        public void copy(Object source, Object target) {
            for (PropertyMapping mapping : mappings.values()) {
                try {
                    mapping.copy(source, target);
                } catch (Exception e) {
                    // è®°å½•é”™è¯¯ä½†ç»§ç»­æ‹·è´å…¶ä»–å±æ€§
                    System.err.println("å±æ€§æ‹·è´å¤±è´¥: " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * æ€§èƒ½æµ‹è¯•
     */
    public static void performanceTest() {
        Person source = new Person("Alice", 25);
        PersonDTO target = new PersonDTO();
        
        int iterations = 100_000;
        
        // é¢„çƒ­
        for (int i = 0; i < 1000; i++) {
            copy(source, new PersonDTO());
        }
        
        // æµ‹è¯•ä¼˜åŒ–åçš„æ‹·è´æ€§èƒ½
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            copy(source, new PersonDTO());
        }
        long optimizedTime = System.nanoTime() - startTime;
        
        System.out.printf("ä¼˜åŒ–åBeanæ‹·è´æ€§èƒ½ (%dæ¬¡): %d ms%n", 
            iterations, optimizedTime / 1_000_000);
    }
}
```

### 6.2 æ³¨è§£å¤„ç†ä¼˜åŒ–


**ğŸ·ï¸ é«˜æ€§èƒ½æ³¨è§£å¤„ç†å™¨**
```java
public class OptimizedAnnotationProcessor {
    
    // æ³¨è§£ä¿¡æ¯ç¼“å­˜
    private static final Map<Class<?>, ClassAnnotationInfo> CLASS_CACHE = new ConcurrentHashMap<>();
    
    /**
     * ä¼˜åŒ–çš„æ³¨è§£å¤„ç†å…¥å£
     */
    public static void processAnnotations(Object instance) {
        Class<?> clazz = instance.getClass();
        ClassAnnotationInfo info = CLASS_CACHE.computeIfAbsent(clazz, 
            OptimizedAnnotationProcessor::analyzeClass);
        
        info.process(instance);
    }
    
    /**
     * ä¸€æ¬¡æ€§åˆ†æç±»çš„æ‰€æœ‰æ³¨è§£ä¿¡æ¯
     */
    private static ClassAnnotationInfo analyzeClass(Class<?> clazz) {
        List<FieldProcessor> fieldProcessors = new ArrayList<>();
        List<MethodProcessor> methodProcessors = new ArrayList<>();
        
        // åˆ†æå­—æ®µæ³¨è§£
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Inject.class)) {
                field.setAccessible(true);
                Inject annotation = field.getAnnotation(Inject.class);
                fieldProcessors.add(new InjectFieldProcessor(field, annotation));
            }
        }
        
        // åˆ†ææ–¹æ³•æ³¨è§£
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(PostConstruct.class)) {
                method.setAccessible(true);
                methodProcessors.add(new PostConstructMethodProcessor(method));
            }
        }
        
        return new ClassAnnotationInfo(fieldProcessors, methodProcessors);
    }
    
    /**
     * ç±»æ³¨è§£ä¿¡æ¯å®¹å™¨
     */
    private static class ClassAnnotationInfo {
        private final List<FieldProcessor> fieldProcessors;
        private final List<MethodProcessor> methodProcessors;
        
        public ClassAnnotationInfo(List<FieldProcessor> fieldProcessors, 
                                  List<MethodProcessor> methodProcessors) {
            this.fieldProcessors = fieldProcessors;
            this.methodProcessors = methodProcessors;
        }
        
        public void process(Object instance) {
            // å¤„ç†å­—æ®µæ³¨å…¥
            for (FieldProcessor processor : fieldProcessors) {
                processor.process(instance);
            }
            
            // å¤„ç†æ–¹æ³•è°ƒç”¨
            for (MethodProcessor processor : methodProcessors) {
                processor.process(instance);
            }
        }
    }
    
    // å­—æ®µå¤„ç†å™¨æ¥å£
    private interface FieldProcessor {
        void process(Object instance);
    }
    
    // æ–¹æ³•å¤„ç†å™¨æ¥å£
    private interface MethodProcessor {
        void process(Object instance);
    }
    
    // æ³¨å…¥å­—æ®µå¤„ç†å™¨
    private static class InjectFieldProcessor implements FieldProcessor {
        private final Field field;
        private final Inject annotation;
        
        public InjectFieldProcessor(Field field, Inject annotation) {
            this.field = field;
            this.annotation = annotation;
        }
        
        @Override
        public void process(Object instance) {
            try {
                // æ¨¡æ‹Ÿä¾èµ–æ³¨å…¥é€»è¾‘
                Object dependency = createDependency(annotation.value());
                field.set(instance, dependency);
            } catch (Exception e) {
                System.err.println("å­—æ®µæ³¨å…¥å¤±è´¥: " + field.getName());
            }
        }
        
        private Object createDependency(String name) {
            // ç®€åŒ–çš„ä¾èµ–åˆ›å»ºé€»è¾‘
            return "Injected: " + name;
        }
    }
    
    // åˆå§‹åŒ–æ–¹æ³•å¤„ç†å™¨
    private static class PostConstructMethodProcessor implements MethodProcessor {
        private final Method method;
        
        public PostConstructMethodProcessor(Method method) {
            this.method = method;
        }
        
        @Override
        public void process(Object instance) {
            try {
                method.invoke(instance);
            } catch (Exception e) {
                System.err.println("åˆå§‹åŒ–æ–¹æ³•è°ƒç”¨å¤±è´¥: " + method.getName());
            }
        }
    }
}
```

---

## 7. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 7.1 å¿…é¡»æŒæ¡çš„ä¼˜åŒ–åŸåˆ™


```
ğŸ”¸ ç¼“å­˜ä¼˜å…ˆï¼šåå°„å¯¹è±¡ï¼ˆMethodã€Fieldã€Constructorï¼‰å¿…é¡»ç¼“å­˜
ğŸ”¸ æƒé™é¢„è®¾ï¼šæå‰è°ƒç”¨setAccessible(true)é¿å…è¿è¡Œæ—¶æƒé™æ£€æŸ¥
ğŸ”¸ é¢‘ç‡æ§åˆ¶ï¼šé¿å…åœ¨é«˜é¢‘ä»£ç è·¯å¾„ä¸­ä½¿ç”¨åå°„
ğŸ”¸ æ›¿ä»£æ–¹æ¡ˆï¼šä¼˜å…ˆè€ƒè™‘MethodHandleã€Lambdaã€ä»£ç ç”Ÿæˆç­‰é«˜æ€§èƒ½æ–¹æ¡ˆ
ğŸ”¸ å·¥å…·è¾…åŠ©ï¼šåˆç†ä½¿ç”¨ç¬¬ä¸‰æ–¹ä¼˜åŒ–å·¥å…·å’Œæ¡†æ¶
```

### 7.2 æ€§èƒ½ä¼˜åŒ–å†³ç­–æ ‘


**ğŸŒ³ ä¼˜åŒ–ç­–ç•¥é€‰æ‹©æµç¨‹**
```
åå°„æ€§èƒ½ä¼˜åŒ–å†³ç­–æµç¨‹
â”œâ”€â”€ æ˜¯å¦ä¸ºæ€§èƒ½å…³é”®è·¯å¾„ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ è€ƒè™‘å®Œå…¨é¿å…åå°„
â”‚   â”‚   â”œâ”€â”€ ä½¿ç”¨MethodHandle
â”‚   â”‚   â”œâ”€â”€ ä½¿ç”¨Lambdaæ–¹æ³•å¼•ç”¨
â”‚   â”‚   â””â”€â”€ ä½¿ç”¨ä»£ç ç”Ÿæˆ
â”‚   â””â”€â”€ å¦ â†’ ç»§ç»­ä¼˜åŒ–åå°„ä½¿ç”¨
â”‚
â”œâ”€â”€ æ˜¯å¦ä¸ºé‡å¤è°ƒç”¨ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ å¿…é¡»ç¼“å­˜åå°„å¯¹è±¡
â”‚   â”‚   â”œâ”€â”€ ç¼“å­˜Method/Field/Constructor
â”‚   â”‚   â”œâ”€â”€ é¢„è®¾setAccessible(true)
â”‚   â”‚   â””â”€â”€ ä½¿ç”¨å·¥å…·ç±»å°è£…
â”‚   â””â”€â”€ å¦ â†’ å¯ä»¥ç›´æ¥ä½¿ç”¨åå°„
â”‚
â”œâ”€â”€ æ˜¯å¦æœ‰ç¬¬ä¸‰æ–¹å·¥å…·ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ ä¼˜å…ˆä½¿ç”¨æˆç†Ÿå·¥å…·
â”‚   â”‚   â”œâ”€â”€ Spring ReflectionUtils
â”‚   â”‚   â”œâ”€â”€ Apache BeanUtils
â”‚   â”‚   â””â”€â”€ MapStructä»£ç ç”Ÿæˆ
â”‚   â””â”€â”€ å¦ â†’ è‡ªå®ç°ä¼˜åŒ–æ–¹æ¡ˆ
â”‚
â””â”€â”€ æ˜¯å¦éœ€è¦ç›‘æ§æ€§èƒ½ï¼Ÿ
    â”œâ”€â”€ æ˜¯ â†’ æ·»åŠ æ€§èƒ½ç›‘æ§
    â””â”€â”€ å¦ â†’ åº”ç”¨åŸºç¡€ä¼˜åŒ–ç­–ç•¥
```

### 7.3 æœ€ä½³å®è·µæ¸…å•


**âœ… åå°„æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•**

| ä¼˜åŒ–é¡¹ | **æ˜¯å¦å®Œæˆ** | **ä¼˜åŒ–æªæ–½** |
|-------|-------------|-------------|
| **åå°„å¯¹è±¡ç¼“å­˜** | â˜ | ä½¿ç”¨ConcurrentHashMapç¼“å­˜Methodã€Fieldã€Constructor |
| **è®¿é—®æƒé™ä¼˜åŒ–** | â˜ | é¢„å…ˆè°ƒç”¨setAccessible(true) |
| **é¢‘ç‡æ§åˆ¶** | â˜ | é¿å…åœ¨å¾ªç¯å’Œçƒ­ç‚¹ä»£ç ä¸­ä½¿ç”¨åå°„ |
| **å¼‚å¸¸å¤„ç†** | â˜ | ç»Ÿä¸€å¼‚å¸¸å¤„ç†ï¼Œé¿å…try-catchå¼€é”€ |
| **å·¥å…·ç±»ä½¿ç”¨** | â˜ | ä½¿ç”¨Spring ReflectionUtilsç­‰æˆç†Ÿå·¥å…· |
| **æ€§èƒ½ç›‘æ§** | â˜ | æ·»åŠ åå°„è°ƒç”¨æ€§èƒ½ç›‘æ§ |
| **æ›¿ä»£æ–¹æ¡ˆè¯„ä¼°** | â˜ | è¯„ä¼°MethodHandleã€Lambdaç­‰æ›¿ä»£æ–¹æ¡ˆ |

### 7.4 å‘å±•è¶‹åŠ¿ä¸å»ºè®®


**ğŸš€ åå°„æŠ€æœ¯å‘å±•æ–¹å‘**
```
åå°„æ€§èƒ½ä¼˜åŒ–å‘å±•è¶‹åŠ¿
â”œâ”€â”€ 1. JVMå±‚é¢ä¼˜åŒ–
â”‚   â”œâ”€â”€ HotSpotæŒç»­ä¼˜åŒ–åå°„æ€§èƒ½
â”‚   â”œâ”€â”€ GraalVM Native Imageçš„AOTç¼–è¯‘
â”‚   â””â”€â”€ Project Loomå¯¹åå°„çš„å½±å“
â”‚
â”œâ”€â”€ 2. è¯­è¨€ç‰¹æ€§å¢å¼º
â”‚   â”œâ”€â”€ Recordç±»ç®€åŒ–åå°„æ“ä½œ
â”‚   â”œâ”€â”€ Pattern Matchingå‡å°‘åå°„éœ€æ±‚
â”‚   â””â”€â”€ æ›´å¥½çš„æ–¹æ³•å¼•ç”¨æ”¯æŒ
â”‚
â”œâ”€â”€ 3. å·¥å…·ç”Ÿæ€å®Œå–„
â”‚   â”œâ”€â”€ ç¼–è¯‘æœŸä»£ç ç”Ÿæˆå·¥å…·æˆç†Ÿ
â”‚   â”œâ”€â”€ IDEå¯¹åå°„æ€§èƒ½çš„é™æ€åˆ†æ
â”‚   â””â”€â”€ ç›‘æ§å·¥å…·å¯¹åå°„çš„ä¸“é¡¹æ”¯æŒ
â”‚
â””â”€â”€ 4. æ›¿ä»£æŠ€æœ¯æ¨å¹¿
    â”œâ”€â”€ MethodHandleä½¿ç”¨æ›´å¹¿æ³›
    â”œâ”€â”€ å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼æ™®åŠ
    â””â”€â”€ å­—èŠ‚ç æ“ä½œå·¥å…·é—¨æ§›é™ä½
```

**æ ¸å¿ƒè®°å¿†**ï¼š
- **ç¼“å­˜æ˜¯ç‹é“**ï¼šåå°„å¯¹è±¡å¿…é¡»ç¼“å­˜ï¼Œè¿™æ˜¯æœ€é‡è¦çš„ä¼˜åŒ–
- **æƒé™è¦é¢„è®¾**ï¼šsetAccessible(true)æ˜¾è‘—æå‡æ€§èƒ½
- **é¢‘ç‡è¦æ§åˆ¶**ï¼šçƒ­ç‚¹ä»£ç é¿å…åå°„ï¼Œä¸€æ¬¡æ€§æ“ä½œå¯ä»¥ä½¿ç”¨
- **å·¥å…·è¦å–„ç”¨**ï¼šæˆç†Ÿå·¥å…·æ¯”è‡ªå·±å®ç°æ€§èƒ½æ›´å¥½
- **æ›¿ä»£è¦è€ƒè™‘**ï¼šMethodHandleå’ŒLambdaæ˜¯ç°ä»£åŒ–çš„é€‰æ‹©