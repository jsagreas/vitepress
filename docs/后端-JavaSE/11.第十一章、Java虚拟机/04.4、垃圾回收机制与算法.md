---
title: 4ã€åƒåœ¾å›æ”¶æœºåˆ¶ä¸ç®—æ³•
---
## ğŸ“š ç›®å½•

1. [åƒåœ¾æ”¶é›†åŸºç¡€ç†è®º](#1-åƒåœ¾æ”¶é›†åŸºç¡€ç†è®º)
2. [åƒåœ¾æ”¶é›†ç®—æ³•](#2-åƒåœ¾æ”¶é›†ç®—æ³•)
3. [åƒåœ¾æ”¶é›†å™¨è¯¦è§£](#3-åƒåœ¾æ”¶é›†å™¨è¯¦è§£)

---

## 1. ğŸ—‘ï¸ åƒåœ¾æ”¶é›†åŸºç¡€ç†è®º


### 1.1 åƒåœ¾æ”¶é›†çš„å¿…è¦æ€§å’Œç›®æ ‡


**ğŸ¯ åƒåœ¾æ”¶é›†çš„å¿…è¦æ€§**
```
ä¸ºä»€ä¹ˆéœ€è¦åƒåœ¾å›æ”¶ï¼š
âŒ æ‰‹åŠ¨å†…å­˜ç®¡ç†é—®é¢˜ï¼š
   â€¢ å†…å­˜æ³„æ¼ï¼šç”³è¯·çš„å†…å­˜å¿˜è®°é‡Šæ”¾
   â€¢ é‡æŒ‡é’ˆï¼šä½¿ç”¨å·²é‡Šæ”¾çš„å†…å­˜åœ°å€
   â€¢ é‡å¤é‡Šæ”¾ï¼šåŒä¸€å†…å­˜è¢«é‡Šæ”¾å¤šæ¬¡
   â€¢ ç¼–ç¨‹å¤æ‚ï¼šç¨‹åºå‘˜éœ€è¦è·Ÿè¸ªæ‰€æœ‰å†…å­˜åˆ†é…

âœ… è‡ªåŠ¨åƒåœ¾å›æ”¶ä¼˜åŠ¿ï¼š
   â€¢ å‡å°‘å†…å­˜æ³„æ¼é£é™©
   â€¢ æé«˜ç¼–ç¨‹æ•ˆç‡
   â€¢ é™ä½ç¨‹åºå´©æºƒæ¦‚ç‡
   â€¢ ä¸“ä¸šä¼˜åŒ–çš„å›æ”¶ç­–ç•¥
```

**ğŸ¯ åƒåœ¾æ”¶é›†çš„ç›®æ ‡**
```
ä¸»è¦ç›®æ ‡ï¼š
ğŸ”¸ æ­£ç¡®æ€§ï¼šä¸å›æ”¶å­˜æ´»å¯¹è±¡ï¼ŒåŠæ—¶å›æ”¶æ­»äº¡å¯¹è±¡
ğŸ”¸ é«˜æ•ˆæ€§ï¼šå°½å¯èƒ½å¿«çš„å®Œæˆåƒåœ¾å›æ”¶å·¥ä½œ
ğŸ”¸ ä½å»¶è¿Ÿï¼šæœ€å°åŒ–åº”ç”¨ç¨‹åºåœé¡¿æ—¶é—´
ğŸ”¸ é«˜ååï¼šæœ€å¤§åŒ–åº”ç”¨ç¨‹åºè¿è¡Œæ—¶é—´å æ¯”

ç›®æ ‡å†²çªï¼š
â€¢ ä½å»¶è¿Ÿ vs é«˜ååï¼šé±¼å’Œç†ŠæŒä¸å¯å…¼å¾—
â€¢ å†…å­˜åˆ©ç”¨ç‡ vs å›æ”¶æ•ˆç‡ï¼šéœ€è¦æƒè¡¡
â€¢ ç®€å•æ€§ vs æ€§èƒ½ï¼šå¤æ‚ç®—æ³•å¸¦æ¥æ€§èƒ½æå‡
```

**ğŸ’¡ åƒåœ¾å›æ”¶çš„åŸºæœ¬æµç¨‹**
```
æ ‡å‡†GCæµç¨‹ï¼š
1. æš‚åœåº”ç”¨ç¨‹åº (Stop The World)
2. æ ‡è®°å­˜æ´»å¯¹è±¡
3. å›æ”¶æ­»äº¡å¯¹è±¡
4. æ•´ç†å†…å­˜ç©ºé—´ï¼ˆå¯é€‰ï¼‰
5. æ¢å¤åº”ç”¨ç¨‹åºè¿è¡Œ

æ—¶é—´åˆ†é…ç¤ºä¾‹ï¼š
åº”ç”¨è¿è¡Œ â”€â”€â”€â”€â”¤STWâ”œâ”€â”€â”€â”€ åº”ç”¨è¿è¡Œ â”€â”€â”€â”€â”¤STWâ”œâ”€â”€â”€â”€ åº”ç”¨è¿è¡Œ
          æ ‡è®°+å›æ”¶              æ ‡è®°+å›æ”¶
```

### 1.2 å¯¹è±¡å­˜æ´»åˆ¤æ–­ï¼šå¼•ç”¨è®¡æ•°ç®—æ³• vs å¯è¾¾æ€§åˆ†æç®—æ³•


**ğŸ”¢ å¼•ç”¨è®¡æ•°ç®—æ³• (Reference Counting)**

**åŸºæœ¬åŸç†**
```
å¼•ç”¨è®¡æ•°ç®—æ³•å·¥ä½œæœºåˆ¶ï¼š
â€¢ ä¸ºæ¯ä¸ªå¯¹è±¡ç»´æŠ¤ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨
â€¢ æœ‰å¼•ç”¨æŒ‡å‘å¯¹è±¡æ—¶ï¼Œè®¡æ•°å™¨+1
â€¢ å¼•ç”¨å¤±æ•ˆæ—¶ï¼Œè®¡æ•°å™¨-1
â€¢ è®¡æ•°å™¨ä¸º0æ—¶ï¼Œå¯¹è±¡å¯è¢«å›æ”¶
```

**ğŸ’» å¼•ç”¨è®¡æ•°ç¤ºä¾‹**
```java
public class ReferenceCountingExample {
    public static void main(String[] args) {
        Object obj1 = new Object();    // obj1å¼•ç”¨è®¡æ•° = 1
        Object obj2 = obj1;           // obj1å¼•ç”¨è®¡æ•° = 2
        obj1 = null;                  // obj1å¼•ç”¨è®¡æ•° = 1
        obj2 = null;                  // obj1å¼•ç”¨è®¡æ•° = 0ï¼Œå¯è¢«å›æ”¶
    }
}

// å¼•ç”¨è®¡æ•°çš„è‡´å‘½é—®é¢˜ï¼šå¾ªç¯å¼•ç”¨
class Node {
    Node next;
    
    public static void createCircle() {
        Node node1 = new Node();     // node1å¼•ç”¨è®¡æ•° = 1
        Node node2 = new Node();     // node2å¼•ç”¨è®¡æ•° = 1
        
        node1.next = node2;          // node2å¼•ç”¨è®¡æ•° = 2
        node2.next = node1;          // node1å¼•ç”¨è®¡æ•° = 2
        
        node1 = null;                // node1å¼•ç”¨è®¡æ•° = 1
        node2 = null;                // node2å¼•ç”¨è®¡æ•° = 1
        
        // é—®é¢˜ï¼šä¸¤ä¸ªå¯¹è±¡ç›¸äº’å¼•ç”¨ï¼Œå¼•ç”¨è®¡æ•°æ°¸è¿œä¸ä¸º0
        // ä½†å®é™…ä¸Šå¤–éƒ¨å·²æ— æ³•è®¿é—®ï¼Œåº”è¯¥è¢«å›æ”¶
    }
}
```

**ğŸ“Š å¼•ç”¨è®¡æ•°ç®—æ³•åˆ†æ**

| æ–¹é¢ | **ä¼˜ç‚¹** | **ç¼ºç‚¹** |
|------|---------|---------|
| âš¡ **æ€§èƒ½** | `å®æ—¶å›æ”¶ï¼Œæ— éœ€STW` | `é¢‘ç¹æ›´æ–°è®¡æ•°å™¨å¼€é”€å¤§` |
| ğŸ§® **å®ç°** | `ç®—æ³•ç®€å•ï¼Œæ˜“äºç†è§£` | `éœ€è¦é¢å¤–å­˜å‚¨è®¡æ•°å™¨` |
| ğŸ”„ **å›æ”¶** | `å¯¹è±¡æ­»äº¡ç«‹å³å›æ”¶` | `æ— æ³•å¤„ç†å¾ªç¯å¼•ç”¨` |
| ğŸ“Š **å†…å­˜** | `å›æ”¶åŠæ—¶ï¼Œå†…å­˜åˆ©ç”¨ç‡é«˜` | `è®¡æ•°å™¨å ç”¨é¢å¤–ç©ºé—´` |

**ğŸ” å¯è¾¾æ€§åˆ†æç®—æ³• (Reachability Analysis)**

**åŸºæœ¬åŸç†**
```
å¯è¾¾æ€§åˆ†æç®—æ³•å·¥ä½œæœºåˆ¶ï¼š
â€¢ ä»GC Rootså¯¹è±¡å¼€å§‹å‘ä¸‹æœç´¢
â€¢ æœç´¢è·¯å¾„ç§°ä¸ºå¼•ç”¨é“¾(Reference Chain)
â€¢ å½“å¯¹è±¡åˆ°GC Rootsæ²¡æœ‰å¼•ç”¨é“¾æ—¶ï¼Œå¯¹è±¡ä¸å¯è¾¾
â€¢ ä¸å¯è¾¾å¯¹è±¡å¯è¢«å›æ”¶
```

**ğŸŒ³ å¯è¾¾æ€§åˆ†æç¤ºä¾‹**
```
GC Rootså¼•ç”¨å…³ç³»å›¾ï¼š

    GC Root1 â”€â”€â”€â”€â”€â”€â†’ ObjectA â”€â”€â”€â”€â”€â”€â†’ ObjectB
        â”‚               â”‚
        â””â”€â†’ ObjectC     â””â”€â†’ ObjectD â”€â”€â†’ ObjectE
                             â”‚
    GC Root2 â”€â”€â”€â”€â”€â”€â†’ ObjectFâ”€â”˜
    
    ObjectG â†â”€â”€â†’ ObjectH  (ç›¸äº’å¼•ç”¨ï¼Œä½†ä»GC Rootsä¸å¯è¾¾)

åˆ†æç»“æœï¼š
âœ… å¯è¾¾å¯¹è±¡ï¼šObjectA, ObjectB, ObjectC, ObjectD, ObjectE, ObjectF
âŒ ä¸å¯è¾¾å¯¹è±¡ï¼šObjectG, ObjectH (å°†è¢«å›æ”¶)
```

**ğŸ’» å¯è¾¾æ€§åˆ†æä»£ç ç¤ºä¾‹**
```java
public class ReachabilityExample {
    private static Object staticObj;      // é™æ€å˜é‡ï¼ŒGC Root
    private Object instanceObj;           // å®ä¾‹å˜é‡
    
    public static void main(String[] args) {
        ReachabilityExample example = new ReachabilityExample();
        
        // å»ºç«‹å¼•ç”¨å…³ç³»
        staticObj = new Object();         // ä»é™æ€å˜é‡å¯è¾¾
        example.instanceObj = new Object(); // ä»å±€éƒ¨å˜é‡å¯è¾¾
        
        Object localObj = new Object();   // å±€éƒ¨å˜é‡ï¼ŒGC Root
        Object tempObj = new Object();    // ä¸´æ—¶å¯¹è±¡
        
        tempObj = null;                   // æ–­å¼€å¼•ç”¨ï¼ŒtempObjä¸å¯è¾¾
        example = null;                   // æ–­å¼€å¼•ç”¨ï¼ŒinstanceObjä¹Ÿä¸å¯è¾¾
        
        // GCæ—¶ï¼š
        // staticObjæŒ‡å‘çš„å¯¹è±¡ â†’ å¯è¾¾ï¼Œä¸å›æ”¶
        // localObj â†’ å¯è¾¾ï¼Œä¸å›æ”¶  
        // instanceObj â†’ ä¸å¯è¾¾ï¼Œå›æ”¶
        // tempObj â†’ ä¸å¯è¾¾ï¼Œå›æ”¶
    }
}
```

### 1.3 GC Rootsï¼šå“ªäº›å¯¹è±¡å¯ä»¥ä½œä¸ºGC Roots


**ğŸŒ± GC Rootsçš„å®šä¹‰**
```
GC Rootsï¼šåƒåœ¾æ”¶é›†çš„èµ·å§‹ç‚¹ï¼Œä»è¿™äº›å¯¹è±¡å¼€å§‹æ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
ç‰¹ç‚¹ï¼šGC Rootsæœ¬èº«ä¸ä¼šè¢«å›æ”¶
ä½œç”¨ï¼šä½œä¸ºå¯è¾¾æ€§åˆ†æçš„æ ¹èŠ‚ç‚¹
```

**ğŸ“‹ GC Rootså¯¹è±¡ç±»å‹è¯¦è§£**

| GC Rootsç±»å‹ | **å…·ä½“å†…å®¹** | **ç”Ÿå‘½å‘¨æœŸ** | **ç¤ºä¾‹** |
|-------------|-------------|-------------|---------|
| ğŸ  **è™šæ‹Ÿæœºæ ˆå¼•ç”¨** | `å±€éƒ¨å˜é‡è¡¨ä¸­çš„å¯¹è±¡å¼•ç”¨` | `æ–¹æ³•æ‰§è¡ŒæœŸé—´` | `æ–¹æ³•å‚æ•°ã€å±€éƒ¨å˜é‡` |
| ğŸ›ï¸ **æ–¹æ³•åŒºé™æ€å±æ€§** | `é™æ€å˜é‡å¼•ç”¨çš„å¯¹è±¡` | `ç±»åŠ è½½æœŸé—´` | `static Object obj` |
| ğŸ“š **æ–¹æ³•åŒºå¸¸é‡** | `å¸¸é‡æ± ä¸­çš„å¯¹è±¡å¼•ç”¨` | `å¸¸é‡å®šä¹‰æœŸé—´` | `static final Object` |
| ğŸŒ‰ **æœ¬åœ°æ–¹æ³•æ ˆå¼•ç”¨** | `JNIå¼•ç”¨çš„å¯¹è±¡` | `nativeæ–¹æ³•æ‰§è¡ŒæœŸé—´` | `JNI Global References` |
| ğŸ”’ **åŒæ­¥é”** | `è¢«synchronizedé”å®šçš„å¯¹è±¡` | `åŒæ­¥å—æ‰§è¡ŒæœŸé—´` | `monitoré”å¯¹è±¡` |
| ğŸ§µ **çº¿ç¨‹å¯¹è±¡** | `æ´»è·ƒçº¿ç¨‹å¯¹è±¡` | `çº¿ç¨‹è¿è¡ŒæœŸé—´` | `Threadå®ä¾‹` |
| âš™ï¸ **JVMå†…éƒ¨å¼•ç”¨** | `ç³»ç»Ÿç±»åŠ è½½å™¨ç­‰` | `JVMè¿è¡ŒæœŸé—´` | `SystemClassLoader` |

**ğŸ’» GC Rootsç¤ºä¾‹ä»£ç **
```java
public class GCRootsExample {
    // 1. æ–¹æ³•åŒºé™æ€å±æ€§ - GC Root
    private static Object staticVariable = new Object();
    
    // 2. æ–¹æ³•åŒºå¸¸é‡ - GC Root  
    private static final Object CONSTANT = new Object();
    
    private Object instanceVariable = new Object();  // éGC Root
    
    public void method() {
        // 3. è™šæ‹Ÿæœºæ ˆå¼•ç”¨ - GC Root
        Object localVariable = new Object();
        Object parameter = instanceVariable;
        
        // 4. åŒæ­¥é” - GC Root
        synchronized (this) {  // thiså¯¹è±¡æˆä¸ºGC Root
            // åŒæ­¥å—ä»£ç 
        }
        
        // 5. æ´»è·ƒçº¿ç¨‹ - GC Root
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(1000);  // çº¿ç¨‹æ´»è·ƒæœŸé—´ï¼Œthreadæ˜¯GC Root
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        thread.start();
        
        // æ–¹æ³•ç»“æŸæ—¶ï¼ŒlocalVariableå’Œparameterä¸å†æ˜¯GC Root
    }
    
    // 6. æœ¬åœ°æ–¹æ³•æ ˆå¼•ç”¨ - GC Root
    public native void nativeMethod();  // JNIå¼•ç”¨çš„å¯¹è±¡
}
```

**ğŸ” GC RootsæŸ¥æ‰¾å·¥å…·**
```bash
# ä½¿ç”¨jmapæŸ¥çœ‹GC Roots
jmap -dump:format=b,file=heap.hprof <pid>

# ä½¿ç”¨MAT (Memory Analyzer Tool) åˆ†æ
# 1. æ‰“å¼€heap.hprofæ–‡ä»¶
# 2. é€‰æ‹© "GC Roots" è§†å›¾
# 3. æŸ¥çœ‹å„ç§ç±»å‹çš„GC Roots

# ä½¿ç”¨jcmdæŸ¥çœ‹GC Roots
jcmd <pid> GC.run_finalization
jcmd <pid> VM.classloader_stats
```

### 1.4 å¼•ç”¨ç±»å‹ï¼šå¼ºå¼•ç”¨ã€è½¯å¼•ç”¨ã€å¼±å¼•ç”¨ã€è™šå¼•ç”¨


**ğŸ”— Javaå¼•ç”¨ç±»å‹å±‚æ¬¡ç»“æ„**
```
å¼•ç”¨å¼ºåº¦ï¼šå¼ºå¼•ç”¨ > è½¯å¼•ç”¨ > å¼±å¼•ç”¨ > è™šå¼•ç”¨
å›æ”¶æ—¶æœºï¼šè™šå¼•ç”¨ > å¼±å¼•ç”¨ > è½¯å¼•ç”¨ > å¼ºå¼•ç”¨

Referenceç±»å±‚æ¬¡ï¼š
        java.lang.ref.Reference
                 â”œâ”€â”€ SoftReference (è½¯å¼•ç”¨)
                 â”œâ”€â”€ WeakReference (å¼±å¼•ç”¨)  
                 â””â”€â”€ PhantomReference (è™šå¼•ç”¨)
```

**ğŸ’ª å¼ºå¼•ç”¨ (Strong Reference)**
```java
// å¼ºå¼•ç”¨ï¼šæœ€å¸¸è§çš„å¼•ç”¨ç±»å‹
public class StrongReferenceExample {
    public static void main(String[] args) {
        Object obj = new Object();    // å¼ºå¼•ç”¨
        
        // ç‰¹ç‚¹ï¼š
        // âœ… åªè¦å¼ºå¼•ç”¨å­˜åœ¨ï¼Œå¯¹è±¡æ°¸è¿œä¸ä¼šè¢«å›æ”¶
        // âœ… å®å¯æŠ›å‡ºOutOfMemoryErrorä¹Ÿä¸å›æ”¶
        // âœ… é€šè¿‡èµ‹å€¼nullæ¥é‡Šæ”¾å¼•ç”¨
        
        obj = null;  // é‡Šæ”¾å¼ºå¼•ç”¨ï¼Œå¯¹è±¡å¯è¢«å›æ”¶
        System.gc(); // å»ºè®®åƒåœ¾å›æ”¶
    }
}

// å¼ºå¼•ç”¨å¯¼è‡´çš„å†…å­˜æ³„æ¼ç¤ºä¾‹
class MemoryLeakExample {
    private static List<Object> list = new ArrayList<>();
    
    public static void createLeak() {
        for (int i = 0; i < 100000; i++) {
            Object obj = new Object();
            list.add(obj);  // å¼ºå¼•ç”¨ä¿å­˜åœ¨é›†åˆä¸­
            // å³ä½¿ä¸å†ä½¿ç”¨objï¼Œä½†listæŒæœ‰å¼ºå¼•ç”¨ï¼Œæ— æ³•å›æ”¶
        }
    }
}
```

**ğŸŒ™ è½¯å¼•ç”¨ (Soft Reference)**
```java
import java.lang.ref.SoftReference;

public class SoftReferenceExample {
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»ºè½¯å¼•ç”¨
        Object obj = new Object();
        SoftReference<Object> softRef = new SoftReference<>(obj);
        obj = null;  // ç§»é™¤å¼ºå¼•ç”¨
        
        // ç‰¹ç‚¹ï¼š
        // âœ… å†…å­˜å……è¶³æ—¶ä¸ä¼šè¢«å›æ”¶
        // âœ… å†…å­˜ä¸è¶³æ—¶ä¼šè¢«å›æ”¶
        // âœ… é€‚ç”¨äºå†…å­˜æ•æ„Ÿçš„ç¼“å­˜
        
        System.out.println("è½¯å¼•ç”¨å¯¹è±¡: " + softRef.get());  // å¯èƒ½ä¸ºnull
        
        // å†…å­˜ä¸è¶³æ—¶ï¼Œè½¯å¼•ç”¨ä¼šè¢«å›æ”¶
        try {
            byte[] bigArray = new byte[1024 * 1024 * 100];  // åˆ†é…å¤§å†…å­˜
        } catch (OutOfMemoryError e) {
            System.out.println("å†…å­˜ä¸è¶³åè½¯å¼•ç”¨: " + softRef.get());  // å¯èƒ½ä¸ºnull
        }
    }
}

// è½¯å¼•ç”¨ç¼“å­˜ç¤ºä¾‹
class SoftCache<K, V> {
    private Map<K, SoftReference<V>> cache = new HashMap<>();
    
    public V get(K key) {
        SoftReference<V> softRef = cache.get(key);
        if (softRef != null) {
            V value = softRef.get();
            if (value != null) {
                return value;  // ç¼“å­˜å‘½ä¸­
            } else {
                cache.remove(key);  // è½¯å¼•ç”¨å·²è¢«å›æ”¶ï¼Œæ¸…ç†ç¼“å­˜
            }
        }
        return null;
    }
    
    public void put(K key, V value) {
        cache.put(key, new SoftReference<>(value));
    }
}
```

**ğŸƒ å¼±å¼•ç”¨ (Weak Reference)**
```java
import java.lang.ref.WeakReference;

public class WeakReferenceExample {
    public static void main(String[] args) {
        Object obj = new Object();
        WeakReference<Object> weakRef = new WeakReference<>(obj);
        obj = null;  // ç§»é™¤å¼ºå¼•ç”¨
        
        // ç‰¹ç‚¹ï¼š
        // âœ… ä¸‹æ¬¡GCæ—¶ä¸€å®šä¼šè¢«å›æ”¶
        // âœ… ä¸å½±å“å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ
        // âœ… é€‚ç”¨äºé¿å…å¾ªç¯å¼•ç”¨
        
        System.out.println("GCå‰: " + weakRef.get());  // æœ‰å€¼
        System.gc();  // å¼ºåˆ¶GC
        System.out.println("GCå: " + weakRef.get());  // null
    }
}

// WeakHashMapç¤ºä¾‹ï¼šè§£å†³å†…å­˜æ³„æ¼
class WeakMapExample {
    public static void main(String[] args) {
        Map<Object, String> map = new WeakHashMap<>();
        
        Object key1 = new Object();
        Object key2 = new Object();
        
        map.put(key1, "value1");
        map.put(key2, "value2");
        
        System.out.println("size: " + map.size());  // 2
        
        key1 = null;  // ç§»é™¤å¼ºå¼•ç”¨
        System.gc();  // GCåï¼Œkey1å¯¹åº”çš„entryä¼šè¢«è‡ªåŠ¨ç§»é™¤
        
        System.out.println("GCåsize: " + map.size());  // 1
    }
}
```

**ğŸ‘» è™šå¼•ç”¨ (Phantom Reference)**
```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

public class PhantomReferenceExample {
    public static void main(String[] args) throws InterruptedException {
        Object obj = new Object();
        ReferenceQueue<Object> queue = new ReferenceQueue<>();
        PhantomReference<Object> phantomRef = new PhantomReference<>(obj, queue);
        
        // ç‰¹ç‚¹ï¼š
        // âœ… get()æ–¹æ³•æ°¸è¿œè¿”å›null
        // âœ… å¿…é¡»ä¸ReferenceQueueè”åˆä½¿ç”¨
        // âœ… ç”¨äºå¯¹è±¡å›æ”¶å‰çš„æ¸…ç†å·¥ä½œ
        
        System.out.println("è™šå¼•ç”¨get(): " + phantomRef.get());  // æ°¸è¿œä¸ºnull
        
        obj = null;  // ç§»é™¤å¼ºå¼•ç”¨
        System.gc(); // è§¦å‘GC
        
        // æ£€æŸ¥å¼•ç”¨é˜Ÿåˆ—
        if (queue.poll() != null) {
            System.out.println("å¯¹è±¡å·²è¢«å›æ”¶ï¼Œæ‰§è¡Œæ¸…ç†å·¥ä½œ");
        }
    }
}

// è™šå¼•ç”¨å®é™…åº”ç”¨ï¼šNIO DirectByteBufferæ¸…ç†
class DirectBufferCleaner {
    private static ReferenceQueue<Object> queue = new ReferenceQueue<>();
    
    static class CleanerReference extends PhantomReference<Object> {
        private Runnable cleanupTask;
        
        public CleanerReference(Object obj, Runnable cleanup) {
            super(obj, queue);
            this.cleanupTask = cleanup;
        }
        
        public void cleanup() {
            cleanupTask.run();
        }
    }
    
    // åå°çº¿ç¨‹ç›‘æ§å¼•ç”¨é˜Ÿåˆ—
    static {
        Thread cleanerThread = new Thread(() -> {
            while (true) {
                try {
                    CleanerReference ref = (CleanerReference) queue.remove();
                    ref.cleanup();  // æ‰§è¡Œæ¸…ç†ä»»åŠ¡
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        cleanerThread.setDaemon(true);
        cleanerThread.start();
    }
}
```

### 1.5 åˆ†ä»£æ”¶é›†ç†è®ºï¼šå¼±åˆ†ä»£å‡è¯´ã€å¼ºåˆ†ä»£å‡è¯´ã€è·¨ä»£å¼•ç”¨å‡è¯´


**ğŸ“Š åˆ†ä»£æ”¶é›†çš„ä¸‰å¤§å‡è¯´**

**å‡è¯´1ï¼šå¼±åˆ†ä»£å‡è¯´ (Weak Generational Hypothesis)**
```
æ ¸å¿ƒè§‚ç‚¹ï¼šç»å¤§å¤šæ•°å¯¹è±¡éƒ½æ˜¯æœç”Ÿå¤•ç­çš„
ç»Ÿè®¡è¯æ®ï¼š98%çš„å¯¹è±¡åœ¨åˆ›å»ºåå¾ˆå¿«å°±æ­»äº¡
å®é™…ä½“ç°ï¼š
â€¢ å±€éƒ¨å˜é‡ï¼šæ–¹æ³•ç»“æŸå³æ­»äº¡
â€¢ ä¸´æ—¶å¯¹è±¡ï¼šStringBuilderã€è¿­ä»£å™¨ç­‰
â€¢ ç¼“å­˜å¯¹è±¡ï¼šçŸ­æœŸä½¿ç”¨åå³åºŸå¼ƒ

è®¾è®¡å½±å“ï¼š
â€¢ æ–°ç”Ÿä»£ä½¿ç”¨å¤åˆ¶ç®—æ³•ï¼ˆå›æ”¶æ•ˆç‡é«˜ï¼‰
â€¢ æ–°ç”Ÿä»£GCé¢‘ç‡é«˜ï¼ˆå¤§éƒ¨åˆ†å¯¹è±¡å¿«é€Ÿæ­»äº¡ï¼‰
â€¢ EdenåŒºè®¾è®¡è¾ƒå¤§ï¼ˆæ‰¿æ¥å¤§é‡æ–°å¯¹è±¡ï¼‰
```

**å‡è¯´2ï¼šå¼ºåˆ†ä»£å‡è¯´ (Strong Generational Hypothesis)**
```
æ ¸å¿ƒè§‚ç‚¹ï¼šç†¬è¿‡è¶Šå¤šæ¬¡åƒåœ¾æ”¶é›†çš„å¯¹è±¡å°±è¶Šéš¾ä»¥æ­»äº¡
ç»Ÿè®¡è¯æ®ï¼šå­˜æ´»æ—¶é—´ä¸æ­»äº¡æ¦‚ç‡æˆåæ¯”
å®é™…ä½“ç°ï¼š
â€¢ ç¼“å­˜å¯¹è±¡ï¼šä¸€æ—¦å»ºç«‹ï¼Œé•¿æœŸä½¿ç”¨
â€¢ å•ä¾‹å¯¹è±¡ï¼šåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…å­˜æ´»
â€¢ è¿æ¥æ± ï¼šé•¿æœŸå¤ç”¨çš„èµ„æº

è®¾è®¡å½±å“ï¼š
â€¢ è€å¹´ä»£ä½¿ç”¨æ ‡è®°-æ¸…é™¤/æ•´ç†ç®—æ³•ï¼ˆç©ºé—´åˆ©ç”¨ç‡é«˜ï¼‰
â€¢ è€å¹´ä»£GCé¢‘ç‡ä½ï¼ˆå¯¹è±¡å­˜æ´»ç‡é«˜ï¼‰
â€¢ æ™‹å‡æœºåˆ¶ï¼šå¤šæ¬¡GCå­˜æ´»çš„å¯¹è±¡è¿›å…¥è€å¹´ä»£
```

**å‡è¯´3ï¼šè·¨ä»£å¼•ç”¨å‡è¯´ (Intergenerational Reference Hypothesis)**
```
æ ¸å¿ƒè§‚ç‚¹ï¼šè·¨ä»£å¼•ç”¨ç›¸å¯¹äºåŒä»£å¼•ç”¨æ¥è¯´ä»…å æå°‘æ•°
ç»Ÿè®¡è¯æ®ï¼šè€å¹´ä»£å¼•ç”¨æ–°ç”Ÿä»£å¯¹è±¡ < 5%
å®é™…ä½“ç°ï¼š
â€¢ æ–°å¯¹è±¡é€šå¸¸ç”±æ–°å¯¹è±¡å¼•ç”¨
â€¢ è€å¯¹è±¡ä¸»è¦å¼•ç”¨è€å¯¹è±¡
â€¢ è·¨ä»£å¼•ç”¨å¤šä¸ºä¸´æ—¶æ€§çš„

è®¾è®¡å½±å“ï¼š
â€¢ è®°å¿†é›†ï¼ˆRemembered Setï¼‰ï¼šè®°å½•è·¨ä»£å¼•ç”¨
â€¢ å¡è¡¨ï¼ˆCard Tableï¼‰ï¼šæ ‡è®°è·¨ä»£å¼•ç”¨çš„å†…å­˜åŒºåŸŸ
â€¢ æ–°ç”Ÿä»£GCæ—¶åªéœ€æ‰«æå°‘é‡è€å¹´ä»£åŒºåŸŸ
```

**ğŸ’» åˆ†ä»£å‡è¯´éªŒè¯ç¤ºä¾‹**
```java
public class GenerationalHypothesisExample {
    // å¼ºåˆ†ä»£å‡è¯´ï¼šé•¿æœŸå­˜æ´»å¯¹è±¡
    private static List<String> longLivedCache = new ArrayList<>();
    
    public static void main(String[] args) {
        // éªŒè¯å¼±åˆ†ä»£å‡è¯´
        demonstrateWeakGeneration();
        
        // éªŒè¯å¼ºåˆ†ä»£å‡è¯´  
        demonstrateStrongGeneration();
        
        // éªŒè¯è·¨ä»£å¼•ç”¨å‡è¯´
        demonstrateCrossGeneration();
    }
    
    // å¼±åˆ†ä»£å‡è¯´ï¼šå¤§é‡çŸ­å‘½å¯¹è±¡
    static void demonstrateWeakGeneration() {
        for (int i = 0; i < 100000; i++) {
            // è¿™äº›å¯¹è±¡å¾ˆå¿«æ­»äº¡ï¼Œä½“ç°å¼±åˆ†ä»£å‡è¯´
            String temp = "temp" + i;
            StringBuilder sb = new StringBuilder();
            sb.append(temp);
            // æ–¹æ³•ç»“æŸï¼Œtempå’Œsbç«‹å³ä¸å¯è¾¾
        }
    }
    
    // å¼ºåˆ†ä»£å‡è¯´ï¼šé•¿æœŸå­˜æ´»å¯¹è±¡
    static void demonstrateStrongGeneration() {
        // è¿™äº›å¯¹è±¡é•¿æœŸå­˜æ´»ï¼Œæœ€ç»ˆè¿›å…¥è€å¹´ä»£
        for (int i = 0; i < 1000; i++) {
            longLivedCache.add("cache" + i);
        }
        // longLivedCacheä¸­çš„å¯¹è±¡é•¿æœŸå­˜æ´»
    }
    
    // è·¨ä»£å¼•ç”¨å‡è¯´ï¼šè€å¹´ä»£å¼•ç”¨æ–°ç”Ÿä»£
    static void demonstrateCrossGeneration() {
        // å‡è®¾longLivedCacheå·²åœ¨è€å¹´ä»£
        String newObject = "new" + System.currentTimeMillis();
        
        // è·¨ä»£å¼•ç”¨ï¼šè€å¹´ä»£å¯¹è±¡å¼•ç”¨æ–°ç”Ÿä»£å¯¹è±¡
        longLivedCache.add(newObject);
        
        // è¿™ç§å¼•ç”¨ç›¸å¯¹è¾ƒå°‘ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
    }
}
```

**ğŸ—ï¸ åˆ†ä»£æ”¶é›†è®¾è®¡å®ç°**
```
åŸºäºå‡è¯´çš„åˆ†ä»£è®¾è®¡ï¼š

æ–°ç”Ÿä»£ (Young Generation)ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            EdenåŒº               â”‚  â† æ–°å¯¹è±¡åˆ†é…åŒº
â”‚      (å¼±åˆ†ä»£å‡è¯´ä½“ç°)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚   Survivor0   â”‚   Survivor1     â”‚  â† å­˜æ´»å¯¹è±¡æš‚å­˜åŒº
â”‚      (å¹´é¾„åˆ†å±‚)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ æ™‹å‡ (å¼ºåˆ†ä»£å‡è¯´)
              â†“
è€å¹´ä»£ (Old Generation)ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          é•¿æœŸå­˜æ´»å¯¹è±¡            â”‚
â”‚       (å¼ºåˆ†ä»£å‡è¯´ä½“ç°)          â”‚
â”‚                                 â”‚
â”‚    Remembered Set               â”‚  â† è·¨ä»£å¼•ç”¨è®°å½•
â”‚    (è·¨ä»£å¼•ç”¨å‡è¯´ä¼˜åŒ–)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è®¾è®¡ä¼˜åŠ¿ï¼š
âœ… æ–°ç”Ÿä»£é¢‘ç¹GCï¼Œå¿«é€Ÿå›æ”¶çŸ­å‘½å¯¹è±¡
âœ… è€å¹´ä»£å°‘é‡GCï¼Œç»´æŠ¤é•¿å‘½å¯¹è±¡
âœ… è®°å¿†é›†ä¼˜åŒ–ï¼Œé¿å…å…¨å †æ‰«æ
âœ… åˆ†ä»£å‚æ•°å¯è°ƒï¼Œé€‚åº”ä¸åŒåº”ç”¨ç‰¹ç‚¹
```

---

## 2. âš™ï¸ åƒåœ¾æ”¶é›†ç®—æ³•


### 2.1 æ ‡è®°-æ¸…é™¤ç®—æ³•ï¼ˆMark-Sweepï¼‰ï¼šåŸç†ã€ä¼˜ç¼ºç‚¹


**ğŸ” æ ‡è®°-æ¸…é™¤ç®—æ³•åŸºæœ¬åŸç†**
```
æ ‡è®°-æ¸…é™¤ç®—æ³• (Mark-Sweep Algorithm)ï¼š
â€¢ é˜¶æ®µ1ï¼šæ ‡è®° (Mark) - æ ‡è®°æ‰€æœ‰éœ€è¦å›æ”¶çš„å¯¹è±¡
â€¢ é˜¶æ®µ2ï¼šæ¸…é™¤ (Sweep) - ç»Ÿä¸€å›æ”¶æ‰€æœ‰è¢«æ ‡è®°çš„å¯¹è±¡

å·¥ä½œæµç¨‹ï¼š
1. ä»GC Rootså¼€å§‹ï¼Œæ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
2. éå†æ•´ä¸ªå †ï¼Œå›æ”¶æœªè¢«æ ‡è®°çš„å¯¹è±¡
3. æ¸…é™¤æ ‡è®°ä¿¡æ¯ï¼Œä¸ºä¸‹æ¬¡GCåšå‡†å¤‡
```

**ğŸ¯ æ ‡è®°-æ¸…é™¤æ‰§è¡Œè¿‡ç¨‹**
```
æ‰§è¡Œå‰å†…å­˜çŠ¶æ€ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ E â”‚ F â”‚ G â”‚ H â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  â†‘       â†‘       â†‘           â†‘
 GC Rootå¼•ç”¨    GC Rootå¼•ç”¨

æ ‡è®°é˜¶æ®µï¼ˆæ ‡è®°å¯è¾¾å¯¹è±¡ï¼‰ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A*â”‚ B â”‚ C*â”‚ D â”‚ E*â”‚ F â”‚ G â”‚ H*â”‚  (* = å¯è¾¾å¯¹è±¡)
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

æ¸…é™¤é˜¶æ®µï¼ˆå›æ”¶æœªæ ‡è®°å¯¹è±¡ï¼‰ï¼š
â”Œâ”€â”€â”€â”¬   â”¬â”€â”€â”€â”¬   â”¬â”€â”€â”€â”¬   â”¬   â”¬â”€â”€â”€â”
â”‚ A â”‚   â”‚ C â”‚   â”‚ E â”‚   â”‚   â”‚ H â”‚  (ç©ºç™½ = å·²å›æ”¶)
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

é—®é¢˜ï¼šäº§ç”Ÿå†…å­˜ç¢ç‰‡ï¼Œç©ºé—²ç©ºé—´ä¸è¿ç»­
```

**ğŸ’» æ ‡è®°-æ¸…é™¤ç®—æ³•ä¼ªä»£ç **
```java
// æ ‡è®°-æ¸…é™¤ç®—æ³•å®ç°åŸç†
public class MarkSweepGC {
    
    // é˜¶æ®µ1ï¼šæ ‡è®°å¯è¾¾å¯¹è±¡
    public void mark() {
        Set<Object> markedObjects = new HashSet<>();
        Queue<Object> workQueue = new LinkedList<>();
        
        // 1. ä»GC Rootså¼€å§‹
        for (Object gcRoot : getGCRoots()) {
            workQueue.offer(gcRoot);
            markedObjects.add(gcRoot);
        }
        
        // 2. æ·±åº¦éå†æ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
        while (!workQueue.isEmpty()) {
            Object current = workQueue.poll();
            for (Object reference : getReferences(current)) {
                if (!markedObjects.contains(reference)) {
                    markedObjects.add(reference);
                    workQueue.offer(reference);
                }
            }
        }
    }
    
    // é˜¶æ®µ2ï¼šæ¸…é™¤æœªæ ‡è®°å¯¹è±¡
    public void sweep() {
        for (Object obj : getAllObjects()) {
            if (!isMarked(obj)) {
                // å›æ”¶å¯¹è±¡ï¼Œé‡Šæ”¾å†…å­˜
                deallocate(obj);
            } else {
                // æ¸…é™¤æ ‡è®°ï¼Œä¸ºä¸‹æ¬¡GCå‡†å¤‡
                clearMark(obj);
            }
        }
    }
    
    // å®Œæ•´çš„æ ‡è®°-æ¸…é™¤è¿‡ç¨‹
    public void markSweepGC() {
        stopTheWorld();    // æš‚åœåº”ç”¨ç¨‹åº
        mark();           // æ ‡è®°é˜¶æ®µ
        sweep();          // æ¸…é™¤é˜¶æ®µ
        resumeWorld();    // æ¢å¤åº”ç”¨ç¨‹åº
    }
}
```

**ğŸ“Š æ ‡è®°-æ¸…é™¤ç®—æ³•åˆ†æ**

| æ–¹é¢ | **ä¼˜ç‚¹** | **ç¼ºç‚¹** |
|------|---------|---------|
| ğŸ¯ **ç®—æ³•å¤æ‚åº¦** | `æ€è·¯ç®€å•ï¼Œå®¹æ˜“ç†è§£` | `éœ€è¦éå†æ•´ä¸ªå †ä¸¤æ¬¡` |
| ğŸ’¾ **å†…å­˜åˆ©ç”¨** | `ä¸éœ€è¦é¢å¤–ç©ºé—´` | `äº§ç”Ÿå¤§é‡å†…å­˜ç¢ç‰‡` |
| âš¡ **æ‰§è¡Œæ•ˆç‡** | `æ ‡è®°é€Ÿåº¦å¿«` | `æ¸…é™¤é˜¶æ®µæ•ˆç‡ä½` |
| ğŸ”„ **é€‚ç”¨åœºæ™¯** | `é€‚åˆè€å¹´ä»£` | `ä¸é€‚åˆå¯¹è±¡åˆ†é…é¢‘ç¹çš„åœºæ™¯` |

### 2.2 æ ‡è®°-å¤åˆ¶ç®—æ³•ï¼ˆMark-Copyï¼‰ï¼šåŸç†ã€é€‚ç”¨åœºæ™¯


**ğŸ“‹ æ ‡è®°-å¤åˆ¶ç®—æ³•åŸºæœ¬åŸç†**
```
æ ‡è®°-å¤åˆ¶ç®—æ³• (Mark-Copy Algorithm)ï¼š
â€¢ å°†å†…å­˜åˆ†ä¸ºä¸¤ä¸ªç›¸ç­‰çš„åŒºåŸŸï¼šFromåŒºå’ŒToåŒº
â€¢ åªä½¿ç”¨å…¶ä¸­ä¸€ä¸ªåŒºåŸŸåˆ†é…å¯¹è±¡
â€¢ GCæ—¶å°†FromåŒºå­˜æ´»å¯¹è±¡å¤åˆ¶åˆ°ToåŒº
â€¢ å¤åˆ¶å®Œæˆåäº¤æ¢FromåŒºå’ŒToåŒºè§’è‰²

è®¾è®¡ç†å¿µï¼š
â€¢ åŸºäºå¼±åˆ†ä»£å‡è¯´ï¼šå¤§éƒ¨åˆ†å¯¹è±¡éƒ½ä¼šæ­»äº¡
â€¢ åªå¤„ç†å­˜æ´»å¯¹è±¡ï¼Œå¿½ç•¥æ­»äº¡å¯¹è±¡
â€¢ å¤åˆ¶è¿‡ç¨‹ä¸­è‡ªç„¶å®Œæˆå†…å­˜æ•´ç†
```

**ğŸ”„ æ ‡è®°-å¤åˆ¶æ‰§è¡Œè¿‡ç¨‹**
```
åˆå§‹çŠ¶æ€ï¼ˆFromåŒºä½¿ç”¨ï¼ŒToåŒºç©ºé—²ï¼‰ï¼š
FromåŒºï¼šâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
       â”‚ A â”‚ B â”‚ C â”‚ D â”‚ E â”‚ F â”‚ G â”‚ H â”‚
       â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
         â†‘       â†‘       â†‘           â†‘
       å­˜æ´»     æ­»äº¡    å­˜æ´»         å­˜æ´»

ToåŒºï¼š  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
       â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚  (ç©ºé—²)
       â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

å¤åˆ¶å­˜æ´»å¯¹è±¡åˆ°ToåŒºï¼š
FromåŒºï¼šâ”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
       â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚  (æ¸…ç©º)
       â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

ToåŒºï¼š  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
       â”‚ A â”‚ C â”‚ E â”‚ H â”‚   â”‚   â”‚   â”‚   â”‚  (ç´§å‡‘æ’åˆ—)
       â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

è§’è‰²äº¤æ¢ï¼šToåŒºå˜ä¸ºæ–°çš„FromåŒºï¼Œç»§ç»­åˆ†é…å¯¹è±¡
```

**ğŸ’» æ ‡è®°-å¤åˆ¶ç®—æ³•å®ç°**
```java
public class MarkCopyGC {
    private MemorySpace fromSpace;
    private MemorySpace toSpace;
    
    // æ ‡è®°-å¤åˆ¶ä¸»æµç¨‹
    public void markCopyGC() {
        stopTheWorld();
        
        // 1. æ¸…ç©ºToåŒº
        toSpace.clear();
        
        // 2. ä»GC Rootså¼€å§‹å¤åˆ¶å­˜æ´»å¯¹è±¡
        for (Object gcRoot : getGCRoots()) {
            copyObject(gcRoot);
        }
        
        // 3. äº¤æ¢FromåŒºå’ŒToåŒº
        MemorySpace temp = fromSpace;
        fromSpace = toSpace;
        toSpace = temp;
        
        resumeWorld();
    }
    
    // å¤åˆ¶å¯¹è±¡åŠå…¶å¼•ç”¨
    private Object copyObject(Object original) {
        if (original == null || original.isForwarded()) {
            return original.getForwardingPointer();
        }
        
        // 1. åœ¨ToåŒºåˆ†é…æ–°ç©ºé—´
        Object copy = toSpace.allocate(original.getSize());
        
        // 2. å¤åˆ¶å¯¹è±¡å†…å®¹
        copy.copyFrom(original);
        
        // 3. è®¾ç½®è½¬å‘æŒ‡é’ˆ
        original.setForwardingPointer(copy);
        
        // 4. é€’å½’å¤åˆ¶å¼•ç”¨çš„å¯¹è±¡
        for (Object reference : original.getReferences()) {
            Object copiedRef = copyObject(reference);
            copy.updateReference(reference, copiedRef);
        }
        
        return copy;
    }
}

// æ–°ç”Ÿä»£ä¸­çš„åº”ç”¨ç¤ºä¾‹
class YoungGenerationGC {
    private EdenSpace eden;
    private SurvivorSpace survivor0;
    private SurvivorSpace survivor1;
    
    public void minorGC() {
        // Eden + Survivor0 â†’ Survivor1
        copyLiveObjects(eden, survivor1);
        copyLiveObjects(survivor0, survivor1);
        
        // æ¸…ç©ºEdenå’ŒSurvivor0
        eden.clear();
        survivor0.clear();
        
        // äº¤æ¢SurvivoråŒº
        SurvivorSpace temp = survivor0;
        survivor0 = survivor1;
        survivor1 = temp;
    }
}
```

**ğŸ“Š æ ‡è®°-å¤åˆ¶ç®—æ³•ç‰¹ç‚¹åˆ†æ**

| æ–¹é¢ | **ä¼˜åŠ¿** | **åŠ£åŠ¿** |
|------|---------|---------|
| ğŸš€ **æ‰§è¡Œæ•ˆç‡** | `åªéå†å­˜æ´»å¯¹è±¡ï¼Œæ•ˆç‡é«˜` | `å¤åˆ¶è¿‡ç¨‹æœ‰é¢å¤–å¼€é”€` |
| ğŸ’¾ **å†…å­˜æ•´ç†** | `è‡ªåŠ¨å‹ç¼©ï¼Œæ— å†…å­˜ç¢ç‰‡` | `æµªè´¹50%å†…å­˜ç©ºé—´` |
| ğŸ¯ **é€‚ç”¨å¯¹è±¡** | `å­˜æ´»ç‡ä½çš„åœºæ™¯ï¼ˆæ–°ç”Ÿä»£ï¼‰` | `å­˜æ´»ç‡é«˜æ—¶å¤åˆ¶å¼€é”€å¤§` |
| ğŸ”§ **å®ç°å¤æ‚åº¦** | `ç®—æ³•ç®€å•ï¼Œå®ç°å®¹æ˜“` | `éœ€è¦ç»´æŠ¤å¯¹è±¡è½¬å‘æŒ‡é’ˆ` |

**ğŸ¯ é€‚ç”¨åœºæ™¯åˆ†æ**
```java
// æ–°ç”Ÿä»£GCï¼šå­˜æ´»ç‡ä½ï¼Œé€‚åˆå¤åˆ¶ç®—æ³•
public class YoungGenExample {
    public static void main(String[] args) {
        // åˆ›å»ºå¤§é‡ä¸´æ—¶å¯¹è±¡
        for (int i = 0; i < 100000; i++) {
            String temp = "temp" + i;        // å¤§éƒ¨åˆ†å¯¹è±¡ä¼šæ­»äº¡
            StringBuilder sb = new StringBuilder();
            sb.append(temp);
            // åªæœ‰å°‘é‡å¯¹è±¡(å¦‚i)ä¼šå­˜æ´»åˆ°GC
        }
        
        // Minor GCæ—¶ï¼š
        // å­˜æ´»ç‡çº¦5-10%ï¼Œå¤åˆ¶ç®—æ³•æ•ˆç‡é«˜
        // å¤åˆ¶å°‘é‡å­˜æ´»å¯¹è±¡åˆ°SurvivoråŒº
    }
}

// è€å¹´ä»£ï¼šå­˜æ´»ç‡é«˜ï¼Œä¸é€‚åˆå¤åˆ¶ç®—æ³•
class OldGenExample {
    private static List<String> cache = new ArrayList<>();
    
    static {
        // è€å¹´ä»£å¯¹è±¡å¤§éƒ¨åˆ†é•¿æœŸå­˜æ´»
        for (int i = 0; i < 10000; i++) {
            cache.add("cached" + i);  // å­˜æ´»ç‡90%+
        }
    }
    
    // å¦‚æœç”¨å¤åˆ¶ç®—æ³•ï¼š
    // éœ€è¦å¤åˆ¶90%+å¯¹è±¡ï¼Œæ•ˆç‡å¾ˆä½
    // æ›´é€‚åˆæ ‡è®°-æ¸…é™¤æˆ–æ ‡è®°-æ•´ç†ç®—æ³•
}
```

### 2.3 æ ‡è®°-æ•´ç†ç®—æ³•ï¼ˆMark-Compactï¼‰ï¼šåŸç†ã€ä¸æ ‡è®°-æ¸…é™¤çš„åŒºåˆ«


**ğŸ”§ æ ‡è®°-æ•´ç†ç®—æ³•åŸºæœ¬åŸç†**
```
æ ‡è®°-æ•´ç†ç®—æ³• (Mark-Compact Algorithm)ï¼š
â€¢ é˜¶æ®µ1ï¼šæ ‡è®° (Mark) - æ ‡è®°æ‰€æœ‰å­˜æ´»å¯¹è±¡
â€¢ é˜¶æ®µ2ï¼šæ•´ç† (Compact) - å°†å­˜æ´»å¯¹è±¡å‘å†…å­˜ä¸€ç«¯ç§»åŠ¨
â€¢ é˜¶æ®µ3ï¼šæ¸…ç† (Clean) - æ¸…é™¤è¾¹ç•Œå¤–çš„æ‰€æœ‰å†…å­˜

è®¾è®¡ç›®æ ‡ï¼š
â€¢ è§£å†³æ ‡è®°-æ¸…é™¤çš„å†…å­˜ç¢ç‰‡é—®é¢˜
â€¢ é¿å…æ ‡è®°-å¤åˆ¶çš„ç©ºé—´æµªè´¹é—®é¢˜
â€¢ é€‚åˆå­˜æ´»ç‡è¾ƒé«˜çš„è€å¹´ä»£
```

**ğŸ¯ æ ‡è®°-æ•´ç†æ‰§è¡Œè¿‡ç¨‹**
```
æ‰§è¡Œå‰å†…å­˜çŠ¶æ€ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ E â”‚ F â”‚ G â”‚ H â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  â†‘   Ã—   â†‘   Ã—   â†‘   Ã—   Ã—   â†‘
 å­˜æ´» æ­»äº¡ å­˜æ´» æ­»äº¡ å­˜æ´» æ­»äº¡ æ­»äº¡ å­˜æ´»

æ ‡è®°é˜¶æ®µï¼ˆæ ‡è®°å­˜æ´»å¯¹è±¡ï¼‰ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A*â”‚ B â”‚ C*â”‚ D â”‚ E*â”‚ F â”‚ G â”‚ H*â”‚  (* = å­˜æ´»å¯¹è±¡)
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

æ•´ç†é˜¶æ®µï¼ˆç§»åŠ¨å­˜æ´»å¯¹è±¡ï¼‰ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ C â”‚ E â”‚ H â”‚   â”‚   â”‚   â”‚   â”‚  (å­˜æ´»å¯¹è±¡ç´§å‡‘æ’åˆ—)
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
                  â†‘
                æ¸…ç†è¾¹ç•Œ

æ¸…ç†é˜¶æ®µï¼ˆæ¸…é™¤è¾¹ç•Œå¤–å†…å­˜ï¼‰ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ C â”‚ E â”‚ H â”‚  å¯ç”¨å†…å­˜è¿ç»­ä¸”ç´§å‡‘
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
```

**ğŸ’» æ ‡è®°-æ•´ç†ç®—æ³•å®ç°**
```java
public class MarkCompactGC {
    
    // æ ‡è®°-æ•´ç†ä¸»æµç¨‹
    public void markCompactGC() {
        stopTheWorld();
        
        Set<Object> liveObjects = mark();      // æ ‡è®°é˜¶æ®µ
        compact(liveObjects);                  // æ•´ç†é˜¶æ®µ
        
        resumeWorld();
    }
    
    // é˜¶æ®µ1ï¼šæ ‡è®°å­˜æ´»å¯¹è±¡
    private Set<Object> mark() {
        Set<Object> marked = new HashSet<>();
        Queue<Object> queue = new LinkedList<>();
        
        // ä»GC Rootså¼€å§‹æ ‡è®°
        for (Object root : getGCRoots()) {
            queue.offer(root);
            marked.add(root);
        }
        
        // æ·±åº¦ä¼˜å…ˆéå†
        while (!queue.isEmpty()) {
            Object obj = queue.poll();
            for (Object ref : obj.getReferences()) {
                if (!marked.contains(ref)) {
                    marked.add(ref);
                    queue.offer(ref);
                }
            }
        }
        
        return marked;
    }
    
    // é˜¶æ®µ2ï¼šæ•´ç†å†…å­˜
    private void compact(Set<Object> liveObjects) {
        // æ–¹æ³•1ï¼šä¸¤æ¬¡éå†ç®—æ³•
        twoPassCompact(liveObjects);
        
        // æ–¹æ³•2ï¼šLisp2ç®—æ³•ï¼ˆæ›´å¤æ‚ä½†æ›´é«˜æ•ˆï¼‰
        // lisp2Compact(liveObjects);
    }
    
    // ä¸¤æ¬¡éå†å‹ç¼©ç®—æ³•
    private void twoPassCompact(Set<Object> liveObjects) {
        Address compactPointer = heapStart;
        
        // ç¬¬ä¸€æ¬¡éå†ï¼šè®¡ç®—æ–°åœ°å€ï¼Œè®¾ç½®è½¬å‘æŒ‡é’ˆ
        for (Object obj : liveObjects) {
            obj.setForwardingAddress(compactPointer);
            compactPointer = compactPointer.add(obj.getSize());
        }
        
        // ç¬¬äºŒæ¬¡éå†ï¼šæ›´æ–°å¼•ç”¨ï¼Œç§»åŠ¨å¯¹è±¡
        for (Object obj : liveObjects) {
            // æ›´æ–°å¯¹è±¡å†…çš„å¼•ç”¨
            obj.updateReferences();
            
            // ç§»åŠ¨å¯¹è±¡åˆ°æ–°ä½ç½®
            Address newAddr = obj.getForwardingAddress();
            Memory.copy(obj.getAddress(), newAddr, obj.getSize());
        }
        
        // æ›´æ–°å †æŒ‡é’ˆ
        heapPointer = compactPointer;
    }
}
```

**ğŸ“Š ä¸‰ç§ç®—æ³•å¯¹æ¯”åˆ†æ**

| ç®—æ³• | **æ—¶é—´å¤æ‚åº¦** | **ç©ºé—´åˆ©ç”¨ç‡** | **å†…å­˜ç¢ç‰‡** | **é€‚ç”¨åœºæ™¯** |
|------|---------------|---------------|-------------|-------------|
| ğŸ” **æ ‡è®°-æ¸…é™¤** | `O(n)` | `100%` | `æœ‰ç¢ç‰‡` | `å†…å­˜å……è¶³ï¼Œå­˜æ´»ç‡ä¸å®š` |
| ğŸ“‹ **æ ‡è®°-å¤åˆ¶** | `O(å­˜æ´»å¯¹è±¡æ•°)` | `50%` | `æ— ç¢ç‰‡` | `å­˜æ´»ç‡ä½ï¼ˆæ–°ç”Ÿä»£ï¼‰` |
| ğŸ”§ **æ ‡è®°-æ•´ç†** | `O(n)` | `100%` | `æ— ç¢ç‰‡` | `å­˜æ´»ç‡é«˜ï¼ˆè€å¹´ä»£ï¼‰` |

**ğŸ’¡ ç®—æ³•é€‰æ‹©ç­–ç•¥**
```java
// æ–°ç”Ÿä»£ï¼šé€‰æ‹©æ ‡è®°-å¤åˆ¶
class YoungGenStrategy {
    // ç‰¹ç‚¹ï¼šå­˜æ´»ç‡5-10%ï¼Œå¯¹è±¡æœç”Ÿå¤•ç­
    public void minorGC() {
        // ä½¿ç”¨æ ‡è®°-å¤åˆ¶ç®—æ³•
        // ä¼˜åŠ¿ï¼šåªå¤åˆ¶å°‘é‡å­˜æ´»å¯¹è±¡ï¼Œæ•ˆç‡é«˜
        // åŠ£åŠ¿ï¼š50%ç©ºé—´æµªè´¹å¯æ¥å—ï¼ˆæ–°ç”Ÿä»£ç©ºé—´å°ï¼‰
        markCopyGC();
    }
}

// è€å¹´ä»£ï¼šé€‰æ‹©æ ‡è®°-æ¸…é™¤æˆ–æ ‡è®°-æ•´ç†
class OldGenStrategy {
    private int fragmentationRatio = 0;
    
    public void majorGC() {
        if (fragmentationRatio > 30) {
            // ç¢ç‰‡è¿‡å¤šæ—¶ä½¿ç”¨æ ‡è®°-æ•´ç†
            markCompactGC();
            fragmentationRatio = 0;
        } else {
            // æ­£å¸¸æƒ…å†µä½¿ç”¨æ ‡è®°-æ¸…é™¤ï¼ˆæ›´å¿«ï¼‰
            markSweepGC();
            fragmentationRatio += 10;
        }
    }
}

// ç‰¹æ®Šåœºæ™¯ï¼šå®æ—¶ç³»ç»Ÿ
class RealtimeStrategy {
    public void realtimeGC() {
        // è¦æ±‚ï¼šä½å»¶è¿Ÿï¼Œå¯é¢„æµ‹çš„æš‚åœæ—¶é—´
        // é€‰æ‹©ï¼šå¢é‡å¼æ ‡è®°-æ¸…é™¤ + å¹¶å‘æ ‡è®°
        // é¿å…ï¼šæ ‡è®°-æ•´ç†ï¼ˆç§»åŠ¨å¯¹è±¡è€—æ—¶é•¿ï¼‰
        incrementalMarkSweep();
    }
}
```

### 2.4 åˆ†ä»£æ”¶é›†ç®—æ³•ï¼šæ–°ç”Ÿä»£ã€è€å¹´ä»£çš„ä¸åŒç­–ç•¥


**ğŸ—ï¸ åˆ†ä»£æ”¶é›†æ€»ä½“è®¾è®¡**
```
åˆ†ä»£æ”¶é›†ç®—æ³• (Generational Collection)ï¼š
â€¢ æ ¹æ®å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç‰¹ç‚¹ï¼Œé‡‡ç”¨ä¸åŒçš„å›æ”¶ç­–ç•¥
â€¢ æ–°ç”Ÿä»£ï¼šå¯¹è±¡æœç”Ÿå¤•ç­ï¼Œä½¿ç”¨å¤åˆ¶ç®—æ³•
â€¢ è€å¹´ä»£ï¼šå¯¹è±¡é•¿æœŸå­˜æ´»ï¼Œä½¿ç”¨æ ‡è®°-æ¸…é™¤/æ•´ç†ç®—æ³•
â€¢ è·¨ä»£ä¼˜åŒ–ï¼šå‡å°‘å…¨å †æ‰«æï¼Œæé«˜æ•ˆç‡
```

**ğŸ“Š åˆ†ä»£æ”¶é›†ç­–ç•¥å¯¹æ¯”**

| åˆ†ä»£ | **å¯¹è±¡ç‰¹ç‚¹** | **GCç®—æ³•** | **GCé¢‘ç‡** | **ä¼˜åŒ–é‡ç‚¹** |
|------|-------------|-----------|-----------|-------------|
| ğŸŒ± **æ–°ç”Ÿä»£** | `æœç”Ÿå¤•ç­ï¼Œå­˜æ´»ç‡ä½` | `æ ‡è®°-å¤åˆ¶` | `é¢‘ç¹` | `å¿«é€Ÿå›æ”¶ï¼Œä½å»¶è¿Ÿ` |
| ğŸ›ï¸ **è€å¹´ä»£** | `é•¿æœŸå­˜æ´»ï¼Œå­˜æ´»ç‡é«˜` | `æ ‡è®°-æ¸…é™¤/æ•´ç†` | `è¾ƒå°‘` | `ç©ºé—´æ•ˆç‡ï¼Œå‡å°‘ç¢ç‰‡` |
| ğŸ’¾ **æ°¸ä¹…ä»£/å…ƒç©ºé—´** | `ç±»å…ƒæ•°æ®ï¼Œæå°‘å›æ”¶` | `æ ‡è®°-æ¸…é™¤` | `å¾ˆå°‘` | `ç©ºé—´ç®¡ç†ï¼Œé¿å…OOM` |

**ğŸ’» åˆ†ä»£æ”¶é›†å®ç°ç¤ºä¾‹**
```java
public class GenerationalGC {
    private YoungGeneration youngGen;
    private OldGeneration oldGen;
    private MetaspaceGeneration metaspace;
    
    // åˆ†ä»£GCä¸»å…¥å£
    public void performGC(GCCause cause) {
        switch (cause) {
            case ALLOCATION_FAILURE:
                minorGC();              // æ–°ç”Ÿä»£GC
                break;
            case PROMOTION_FAILED:
                majorGC();              // è€å¹´ä»£GC
                break;
            case HEAP_INSPECTION:
                fullGC();               // å…¨å †GC
                break;
        }
    }
    
    // æ–°ç”Ÿä»£GCï¼ˆMinor GCï¼‰
    private void minorGC() {
        // 1. EdenåŒºæ»¡æ—¶è§¦å‘
        if (youngGen.eden.isFull()) {
            
            // 2. ä½¿ç”¨å¤åˆ¶ç®—æ³•
            List<Object> survivors = new ArrayList<>();
            
            // ä»GC Roots + è€å¹´ä»£å¼•ç”¨å¼€å§‹æ ‡è®°
            Set<Object> reachable = markReachableFromRoots();
            reachable.addAll(markReachableFromOldGen());
            
            // å¤åˆ¶å­˜æ´»å¯¹è±¡åˆ°SurvivoråŒº
            for (Object obj : youngGen.eden.getAllObjects()) {
                if (reachable.contains(obj)) {
                    survivors.add(obj);
                    obj.incrementAge();  // å¢åŠ å¹´é¾„
                }
            }
            
            // å¹´é¾„è¾¾åˆ°é˜ˆå€¼çš„å¯¹è±¡æ™‹å‡åˆ°è€å¹´ä»£
            for (Object survivor : survivors) {
                if (survivor.getAge() >= promotionThreshold) {
                    oldGen.promote(survivor);
                } else {
                    youngGen.survivor.add(survivor);
                }
            }
            
            // æ¸…ç©ºEdenåŒº
            youngGen.eden.clear();
        }
    }
    
    // è€å¹´ä»£GCï¼ˆMajor GCï¼‰
    private void majorGC() {
        // ä½¿ç”¨æ ‡è®°-æ¸…é™¤æˆ–æ ‡è®°-æ•´ç†ç®—æ³•
        if (oldGen.getFragmentation() > fragmentationThreshold) {
            markCompactOldGen();    // ç¢ç‰‡å¤šæ—¶æ•´ç†
        } else {
            markSweepOldGen();      // æ­£å¸¸æƒ…å†µæ¸…é™¤
        }
    }
    
    // å…¨å †GCï¼ˆFull GCï¼‰
    private void fullGC() {
        // å›æ”¶æ•´ä¸ªå † + å…ƒç©ºé—´
        minorGC();              // å…ˆå›æ”¶æ–°ç”Ÿä»£
        majorGC();              // å†å›æ”¶è€å¹´ä»£
        metaspace.gc();         // æœ€åå›æ”¶å…ƒç©ºé—´
    }
}
```

**ğŸ”„ å¯¹è±¡æ™‹å‡æµç¨‹**
```
å¯¹è±¡ç”Ÿå‘½å‘¨æœŸæµç¨‹ï¼š

æ–°å¯¹è±¡åˆ›å»º
     â†“
  EdenåŒºåˆ†é…
     â†“
  EdenåŒºæ»¡ â†’ Minor GC
     â†“
  å­˜æ´»å¯¹è±¡ â†’ SurvivoråŒº (å¹´é¾„+1)
     â†“
  å†æ¬¡GC â†’ SurvivoråŒº (å¹´é¾„+1)
     â†“
  å¹´é¾„è¾¾åˆ°é˜ˆå€¼ â†’ æ™‹å‡åˆ°è€å¹´ä»£
     â†“
  è€å¹´ä»£æ»¡ â†’ Major GC
     â†“
  å¯¹è±¡å›æ”¶æˆ–ç»§ç»­å­˜æ´»

ç‰¹æ®Šæƒ…å†µï¼š
â€¢ å¤§å¯¹è±¡ï¼šç›´æ¥åˆ†é…åˆ°è€å¹´ä»£
â€¢ SurvivoråŒºä¸å¤Ÿï¼šç›´æ¥æ™‹å‡åˆ°è€å¹´ä»£
â€¢ åŠ¨æ€å¹´é¾„åˆ¤å®šï¼šSurvivoråŒºä¸­ç›¸åŒå¹´é¾„å¯¹è±¡å¤§å°è¶…è¿‡ä¸€åŠæ—¶æå‰æ™‹å‡
```

**ğŸ’¡ åˆ†ä»£GCä¼˜åŒ–æŠ€æœ¯**
```java
// 1. è®°å¿†é›†ï¼ˆRemembered Setï¼‰ä¼˜åŒ–
class RememberedSet {
    // è®°å½•è€å¹´ä»£åˆ°æ–°ç”Ÿä»£çš„å¼•ç”¨
    private Set<OldGenObject> crossGenReferences;
    
    public void recordCrossGenRef(OldGenObject oldObj, YoungGenObject youngObj) {
        crossGenReferences.add(oldObj);
        // Minor GCæ—¶åªéœ€æ‰«æè¿™äº›è€å¹´ä»£å¯¹è±¡ï¼Œè€Œä¸æ˜¯å…¨éƒ¨
    }
}

// 2. å¡è¡¨ï¼ˆCard Tableï¼‰ä¼˜åŒ–
class CardTable {
    private byte[] cardTable;  // æ¯å¼ å¡512å­—èŠ‚
    private static final byte DIRTY_CARD = 1;
    
    public void markDirty(Address addr) {
        int cardIndex = addr.toCardIndex();
        cardTable[cardIndex] = DIRTY_CARD;  // æ ‡è®°è·¨ä»£å¼•ç”¨
    }
    
    public void scanDirtyCards() {
        // Minor GCæ—¶åªæ‰«æè„å¡å¯¹åº”çš„å†…å­˜åŒºåŸŸ
        for (int i = 0; i < cardTable.length; i++) {
            if (cardTable[i] == DIRTY_CARD) {
                scanCard(i);
                cardTable[i] = 0;  // æ¸…é™¤è„æ ‡è®°
            }
        }
    }
}

// 3. åˆ†ä»£GCå‚æ•°è°ƒä¼˜
class GenerationalTuning {
    // æ–°ç”Ÿä»£å¤§å°ï¼šå½±å“Minor GCé¢‘ç‡
    // -Xmn512m æˆ– -XX:NewRatio=2
    
    // æ™‹å‡é˜ˆå€¼ï¼šå½±å“å¯¹è±¡ä½•æ—¶è¿›å…¥è€å¹´ä»£
    // -XX:MaxTenuringThreshold=15
    
    // SurvivoråŒºæ¯”ä¾‹ï¼šå½±å“å¯¹è±¡æ™‹å‡
    // -XX:SurvivorRatio=8 (Eden:S0:S1 = 8:1:1)
    
    // å¤§å¯¹è±¡é˜ˆå€¼ï¼šå½±å“ç›´æ¥æ™‹å‡
    // -XX:PretenureSizeThreshold=1048576 (1MB)
}
```

### 2.5 ç®—æ³•çš„æ€§èƒ½å¯¹æ¯”å’Œé€‰æ‹©ä¾æ®


**ğŸ“Š åƒåœ¾æ”¶é›†ç®—æ³•ç»¼åˆæ€§èƒ½å¯¹æ¯”**

| æ€§èƒ½æŒ‡æ ‡ | **æ ‡è®°-æ¸…é™¤** | **æ ‡è®°-å¤åˆ¶** | **æ ‡è®°-æ•´ç†** | **åˆ†ä»£æ”¶é›†** |
|---------|--------------|--------------|--------------|-------------|
| âš¡ **ååé‡** | `ä¸­ç­‰` | `é«˜ï¼ˆæ–°ç”Ÿä»£ï¼‰` | `ä¸­ç­‰` | `é«˜` |
| â±ï¸ **å»¶è¿Ÿ** | `ä¸­ç­‰` | `ä½` | `é«˜` | `æ–°ç”Ÿä»£ä½ï¼Œè€å¹´ä»£ä¸­ç­‰` |
| ğŸ’¾ **å†…å­˜åˆ©ç”¨ç‡** | `100%` | `50%` | `100%` | `ç»¼åˆ95%+` |
| ğŸ”§ **å®ç°å¤æ‚åº¦** | `ç®€å•` | `ç®€å•` | `å¤æ‚` | `å¤æ‚` |
| ğŸ¯ **é€‚ç”¨å­˜æ´»ç‡** | `ä»»æ„` | `ä½ï¼ˆ<10%ï¼‰` | `é«˜ï¼ˆ>50%ï¼‰` | `åˆ†ä»£é€‚é…` |
| ğŸ—‘ï¸ **å†…å­˜ç¢ç‰‡** | `æœ‰` | `æ— ` | `æ— ` | `æ–°ç”Ÿä»£æ— ï¼Œè€å¹´ä»£å°‘` |

**ğŸ¯ ç®—æ³•é€‰æ‹©å†³ç­–æ ‘**
```
é€‰æ‹©åƒåœ¾æ”¶é›†ç®—æ³•ï¼š

å­˜æ´»ç‡å¦‚ä½•ï¼Ÿ
â”œâ”€ ä½ï¼ˆ<20%ï¼‰
â”‚   â”œâ”€ ç©ºé—´å……è¶³ï¼Ÿ
â”‚   â”‚   â”œâ”€ YES â†’ æ ‡è®°-å¤åˆ¶ç®—æ³•
â”‚   â”‚   â””â”€ NO  â†’ æ ‡è®°-æ¸…é™¤ç®—æ³•
â”‚   â””â”€ å†…å­˜ç¢ç‰‡æ•æ„Ÿï¼Ÿ
â”‚       â”œâ”€ YES â†’ æ ‡è®°-æ•´ç†ç®—æ³•
â”‚       â””â”€ NO  â†’ æ ‡è®°-æ¸…é™¤ç®—æ³•
â”œâ”€ é«˜ï¼ˆ>50%ï¼‰
â”‚   â”œâ”€ å¯¹å»¶è¿Ÿè¦æ±‚ï¼Ÿ
â”‚   â”‚   â”œâ”€ ä½å»¶è¿Ÿ â†’ æ ‡è®°-æ¸…é™¤ç®—æ³•
â”‚   â”‚   â””â”€ å¯æ¥å— â†’ æ ‡è®°-æ•´ç†ç®—æ³•
â”‚   â””â”€ å†…å­˜ç¢ç‰‡é—®é¢˜ï¼Ÿ
â”‚       â”œâ”€ ä¸¥é‡ â†’ æ ‡è®°-æ•´ç†ç®—æ³•
â”‚       â””â”€ è½»å¾® â†’ æ ‡è®°-æ¸…é™¤ç®—æ³•
â””â”€ ä¸ç¡®å®š â†’ åˆ†ä»£æ”¶é›†ç®—æ³•
```

**ğŸ’» å®é™…åº”ç”¨åœºæ™¯é€‰æ‹©**
```java
// åœºæ™¯1ï¼šWebæœåŠ¡å™¨
class WebServerGCChoice {
    // ç‰¹ç‚¹ï¼šå¤§é‡çŸ­æœŸå¯¹è±¡ï¼ˆè¯·æ±‚å¤„ç†ï¼‰ï¼Œå°‘é‡é•¿æœŸå¯¹è±¡ï¼ˆè¿æ¥æ± ï¼‰
    // é€‰æ‹©ï¼šåˆ†ä»£æ”¶é›†
    // æ–°ç”Ÿä»£ï¼šå¤åˆ¶ç®—æ³•ï¼Œå¿«é€Ÿå›æ”¶è¯·æ±‚å¯¹è±¡
    // è€å¹´ä»£ï¼šæ ‡è®°-æ¸…é™¤ï¼Œç»´æŠ¤é•¿æœŸå¯¹è±¡
    
    void configureGC() {
        // -XX:+UseG1GC                    // G1æ”¶é›†å™¨
        // -XX:MaxGCPauseMillis=200        // æœ€å¤§æš‚åœæ—¶é—´200ms
        // -XX:NewRatio=2                  // æ–°ç”Ÿä»£:è€å¹´ä»£ = 1:2
    }
}

// åœºæ™¯2ï¼šæ‰¹å¤„ç†ç³»ç»Ÿ
class BatchProcessingGCChoice {
    // ç‰¹ç‚¹ï¼šå¤§é‡ä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡ï¼Œæ³¨é‡ååé‡
    // é€‰æ‹©ï¼šParallel GC
    // ç®—æ³•ï¼šæ–°ç”Ÿä»£å¤åˆ¶ + è€å¹´ä»£æ ‡è®°-æ•´ç†
    
    void configureGC() {
        // -XX:+UseParallelGC              // Parallelæ”¶é›†å™¨
        // -XX:GCTimeRatio=99              // GCæ—¶é—´å æ¯”1%
        // -XX:+UseAdaptiveSizePolicy      // è‡ªé€‚åº”å¤§å°è°ƒæ•´
    }
}

// åœºæ™¯3ï¼šå®æ—¶äº¤æ˜“ç³»ç»Ÿ
class RealtimeTradingGCChoice {
    // ç‰¹ç‚¹ï¼šæä½å»¶è¿Ÿè¦æ±‚ï¼Œå¯é¢„æµ‹çš„GCæš‚åœ
    // é€‰æ‹©ï¼šZGCæˆ–Shenandoah
    // ç®—æ³•ï¼šå¹¶å‘æ ‡è®° + å¹¶å‘æ•´ç†
    
    void configureGC() {
        // -XX:+UseZGC                     // ZGCæ”¶é›†å™¨
        // -XX:+UnlockExperimentalVMOptions
        // -Xmx32g                         // å¤§å †å†…å­˜
    }
}

// åœºæ™¯4ï¼šå†…å­˜å—é™ç¯å¢ƒ
class MemoryConstrainedGCChoice {
    // ç‰¹ç‚¹ï¼šå†…å­˜è¾ƒå°ï¼Œæ³¨é‡å†…å­˜åˆ©ç”¨ç‡
    // é€‰æ‹©ï¼šSerial GC + æ ‡è®°-æ•´ç†
    // ä¼˜åŠ¿ï¼šå†…å­˜å¼€é”€å°ï¼Œæ— å†…å­˜ç¢ç‰‡
    
    void configureGC() {
        // -XX:+UseSerialGC                // Serialæ”¶é›†å™¨
        // -XX:+UseCompressedOops          // å‹ç¼©æŒ‡é’ˆ
        // -Xmx512m                        // å°å †å†…å­˜
    }
}
```

**ğŸ“ˆ æ€§èƒ½æµ‹è¯•å¯¹æ¯”ç¤ºä¾‹**
```java
public class GCPerformanceTest {
    private static final int OBJECTS_COUNT = 1000000;
    
    public static void main(String[] args) {
        testThroughput();
        testLatency();
        testMemoryUtilization();
    }
    
    // ååé‡æµ‹è¯•
    static void testThroughput() {
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < 10; i++) {
            List<Object> objects = new ArrayList<>();
            for (int j = 0; j < OBJECTS_COUNT; j++) {
                objects.add(new Object());
            }
            objects.clear();  // è§¦å‘GC
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("æ€»è€—æ—¶: " + (endTime - startTime) + "ms");
    }
    
    // å»¶è¿Ÿæµ‹è¯•
    static void testLatency() {
        List<Long> gcTimes = new ArrayList<>();
        
        // ç›‘æ§GCæ—¶é—´
        for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) {
            gcTimes.add(gc.getCollectionTime());
        }
        
        // åˆ†ææœ€å¤§æš‚åœæ—¶é—´ã€å¹³å‡æš‚åœæ—¶é—´ç­‰
    }
    
    // å†…å­˜åˆ©ç”¨ç‡æµ‹è¯•
    static void testMemoryUtilization() {
        MemoryMXBean memory = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memory.getHeapMemoryUsage();
        
        long used = heapUsage.getUsed();
        long committed = heapUsage.getCommitted();
        double utilization = (double) used / committed * 100;
        
        System.out.println("å†…å­˜åˆ©ç”¨ç‡: " + utilization + "%");
    }
}
```

---

## 3. ğŸ”§ åƒåœ¾æ”¶é›†å™¨è¯¦è§£


### 3.1 ç»å…¸æ”¶é›†å™¨ï¼šSerialã€ParNewã€Parallel Scavenge


**âš™ï¸ åƒåœ¾æ”¶é›†å™¨åˆ†ç±»æ¦‚è§ˆ**
```
åƒåœ¾æ”¶é›†å™¨å‘å±•å†ç¨‹ï¼š

ç¬¬ä¸€ä»£ï¼šå•çº¿ç¨‹æ”¶é›†å™¨
â”œâ”€ Serial GC (æ–°ç”Ÿä»£)
â””â”€ Serial Old GC (è€å¹´ä»£)

ç¬¬äºŒä»£ï¼šå¹¶è¡Œæ”¶é›†å™¨  
â”œâ”€ ParNew GC (æ–°ç”Ÿä»£)
â”œâ”€ Parallel Scavenge GC (æ–°ç”Ÿä»£)
â””â”€ Parallel Old GC (è€å¹´ä»£)

ç¬¬ä¸‰ä»£ï¼šå¹¶å‘æ”¶é›†å™¨
â”œâ”€ CMS GC (è€å¹´ä»£)
â””â”€ G1 GC (å…¨å †)

ç¬¬å››ä»£ï¼šä½å»¶è¿Ÿæ”¶é›†å™¨
â”œâ”€ ZGC (å…¨å †)
â”œâ”€ Shenandoah GC (å…¨å †)
â””â”€ Epsilon GC (æ— æ“ä½œ)
```

**ğŸ”¸ Serialæ”¶é›†å™¨ï¼šå•çº¿ç¨‹çš„å¼€åˆ›è€…**

**åŸºæœ¬ç‰¹ç‚¹**
```
Serialæ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ å•çº¿ç¨‹ï¼šåªä½¿ç”¨ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œåƒåœ¾æ”¶é›†
â€¢ Stop-The-Worldï¼šGCæœŸé—´æš‚åœæ‰€æœ‰åº”ç”¨çº¿ç¨‹
â€¢ ç®—æ³•ï¼šæ–°ç”Ÿä»£ä½¿ç”¨å¤åˆ¶ç®—æ³•ï¼Œè€å¹´ä»£ä½¿ç”¨æ ‡è®°-æ•´ç†ç®—æ³•
â€¢ é€‚ç”¨ï¼šå®¢æˆ·ç«¯æ¨¡å¼ï¼Œå°å†…å­˜åº”ç”¨ï¼ˆå‡ åMBåˆ°å‡ ç™¾MBï¼‰
```

**ğŸ’» Serialæ”¶é›†å™¨å·¥ä½œæµç¨‹**
```java
// Serial GCå·¥ä½œç¤ºä¾‹
public class SerialGCExample {
    public static void main(String[] args) {
        // JVMå‚æ•°ï¼š-XX:+UseSerialGC -Xms32m -Xmx32m
        
        for (int i = 0; i < 1000; i++) {
            // åˆ›å»ºå¯¹è±¡ï¼Œå¡«æ»¡EdenåŒº
            Object[] objects = new Object[1000];
            
            if (i % 100 == 0) {
                // æ¯100æ¬¡è¿­ä»£è§¦å‘GC
                System.gc();
                System.out.println("ç¬¬" + i + "æ¬¡GC");
            }
        }
    }
}

// Serial GCæ‰§è¡Œæµç¨‹ï¼š
// 1. EdenåŒºåˆ†é…å¯¹è±¡
// 2. EdenåŒºæ»¡ â†’ è§¦å‘Minor GC
// 3. STWæš‚åœæ‰€æœ‰çº¿ç¨‹
// 4. å•çº¿ç¨‹å¤åˆ¶å­˜æ´»å¯¹è±¡åˆ°Survivor
// 5. æ¸…ç©ºEdenåŒº
// 6. æ¢å¤åº”ç”¨çº¿ç¨‹æ‰§è¡Œ
```

**ğŸ“Š Serialæ”¶é›†å™¨æ—¶é—´çº¿**
```
Serial GCæ‰§è¡Œæ—¶é—´çº¿ï¼š

åº”ç”¨çº¿ç¨‹: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
GCçº¿ç¨‹:   -------- â–ˆâ–ˆâ–ˆâ–ˆ -------- â–ˆâ–ˆâ–ˆâ–ˆ -------- â–ˆâ–ˆâ–ˆâ–ˆ ----
æ—¶é—´:     0        10   12       22   24       34   36
          
è¯´æ˜ï¼š
â–ˆâ–ˆâ–ˆâ–ˆ = çº¿ç¨‹è¿è¡Œ
---- = çº¿ç¨‹æš‚åœ
åº”ç”¨çº¿ç¨‹åœ¨GCæœŸé—´å®Œå…¨æš‚åœï¼ˆSTWï¼‰
```

**ğŸ”¹ ParNewæ”¶é›†å™¨ï¼šå¤šçº¿ç¨‹çš„Serial**

**åŸºæœ¬ç‰¹ç‚¹**
```
ParNewæ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ å¤šçº¿ç¨‹ï¼šSerialçš„å¤šçº¿ç¨‹ç‰ˆæœ¬
â€¢ ç®—æ³•ï¼šä¸Serialå®Œå…¨ç›¸åŒï¼ˆå¤åˆ¶ç®—æ³•ï¼‰
â€¢ å¹¶è¡Œåº¦ï¼šé»˜è®¤ä¸CPUæ ¸å¿ƒæ•°ç›¸åŒ
â€¢ é€‚ç”¨ï¼šæœåŠ¡å™¨ç¯å¢ƒï¼Œä¸CMSæ­é…ä½¿ç”¨
```



**ğŸ’» ParNewæ”¶é›†å™¨ç¤ºä¾‹**


```java
// ParNew GCé…ç½®ç¤ºä¾‹
public class ParNewGCExample {
    public static void main(String[] args) {
        // JVMå‚æ•°ï¼š-XX:+UseParNewGC -XX:+UseConcMarkSweepGC
        //          -XX:ParallelGCThreads=4
        
        // å¤šçº¿ç¨‹å¹¶è¡Œå›æ”¶æ–°ç”Ÿä»£
        List<Object> objects = new ArrayList<>();
        
        for (int i = 0; i < 100000; i++) {
            objects.add(new Object());
            
            if (i % 10000 == 0) {
                objects.clear();  // è§¦å‘Minor GC
                // ParNewä½¿ç”¨4ä¸ªçº¿ç¨‹å¹¶è¡Œå›æ”¶
            }
        }
    }
}

// ParNewå¤šçº¿ç¨‹å·¥ä½œåŸç†
class ParNewWorker extends Thread {
    private HeapRegion region;
    private GCRoots roots;
    
    @Override
    public void run() {
        // æ¯ä¸ªGCçº¿ç¨‹è´Ÿè´£ä¸€éƒ¨åˆ†å †åŒºåŸŸ
        copyLiveObjects(region, roots);
    }
}
```

**ğŸ“Š ParNewæ‰§è¡Œæ—¶é—´çº¿**
```
4æ ¸CPUä¸Šçš„ParNew GCï¼š

åº”ç”¨çº¿ç¨‹1: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
åº”ç”¨çº¿ç¨‹2: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  
åº”ç”¨çº¿ç¨‹3: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
åº”ç”¨çº¿ç¨‹4: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

GCçº¿ç¨‹1:   -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ --------
GCçº¿ç¨‹2:   -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ --------
GCçº¿ç¨‹3:   -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ --------
GCçº¿ç¨‹4:   -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ -------- â–ˆâ–ˆ --------

è¯´æ˜ï¼šGCæ—¶é—´æ¯”SerialçŸ­ï¼Œä½†ä»éœ€STWæš‚åœæ‰€æœ‰åº”ç”¨çº¿ç¨‹
```

**ğŸ”º Parallel Scavengeæ”¶é›†å™¨ï¼šååé‡ä¼˜å…ˆ**

**åŸºæœ¬ç‰¹ç‚¹**
```
Parallel Scavengeæ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ å…³æ³¨ç‚¹ï¼šååé‡ä¼˜å…ˆï¼ˆThroughput Firstï¼‰
â€¢ ç®—æ³•ï¼šå¤åˆ¶ç®—æ³•ï¼ˆæ–°ç”Ÿä»£ï¼‰
â€¢ è‡ªé€‚åº”ï¼šè‡ªåŠ¨è°ƒæ•´å †å¤§å°ã€æ™‹å‡é˜ˆå€¼ç­‰å‚æ•°
â€¢ ç›®æ ‡ï¼šè¾¾åˆ°å¯æ§çš„ååé‡å’Œæš‚åœæ—¶é—´
```

**ğŸ¯ ååé‡å®šä¹‰**
```
ååé‡ = è¿è¡Œç”¨æˆ·ä»£ç æ—¶é—´ / (è¿è¡Œç”¨æˆ·ä»£ç æ—¶é—´ + åƒåœ¾æ”¶é›†æ—¶é—´)

ç¤ºä¾‹è®¡ç®—ï¼š
â€¢ åº”ç”¨è¿è¡Œ100åˆ†é’Ÿ
â€¢ GCæ€»è€—æ—¶2åˆ†é’Ÿ
â€¢ ååé‡ = 100 / (100 + 2) = 98.04%

Parallel Scavengeç›®æ ‡ï¼š
â€¢ é«˜ååé‡ï¼šé€‚åˆåå°è®¡ç®—ä»»åŠ¡
â€¢ å¯æ§æš‚åœï¼šé€šè¿‡å‚æ•°æ§åˆ¶GCæ—¶é—´
```

**ğŸ’» Parallel Scavengeé…ç½®ç¤ºä¾‹**
```java
// Parallel Scavenge GCé…ç½®
public class ParallelScavengeExample {
    public static void main(String[] args) {
        // JVMå‚æ•°é…ç½®ï¼š
        // -XX:+UseParallelGC              // ä½¿ç”¨Parallelæ”¶é›†å™¨
        // -XX:MaxGCPauseMillis=200        // æœ€å¤§æš‚åœæ—¶é—´200ms
        // -XX:GCTimeRatio=19              // GCæ—¶é—´å æ¯”5% (1/(1+19))
        // -XX:+UseAdaptiveSizePolicy      // è‡ªé€‚åº”å¤§å°è°ƒæ•´
        
        // æ‰¹å¤„ç†ä»»åŠ¡ç¤ºä¾‹
        for (int batch = 0; batch < 10; batch++) {
            processBatch(batch);
        }
    }
    
    static void processBatch(int batchId) {
        List<DataObject> dataList = new ArrayList<>();
        
        // æ¨¡æ‹Ÿæ‰¹å¤„ç†ï¼šå¤§é‡å¯¹è±¡åˆ›å»ºå’Œå¤„ç†
        for (int i = 0; i < 50000; i++) {
            DataObject data = new DataObject("batch" + batchId + "_" + i);
            dataList.add(data);
            
            // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
            data.process();
        }
        
        // æ‰¹å¤„ç†å®Œæˆï¼Œå¯¹è±¡å¯è¢«å›æ”¶
        dataList.clear();
        System.out.println("Batch " + batchId + " completed");
    }
}

class DataObject {
    private String id;
    private byte[] data = new byte[1024];  // 1KBæ•°æ®
    
    public DataObject(String id) {
        this.id = id;
    }
    
    public void process() {
        // æ¨¡æ‹Ÿæ•°æ®å¤„ç†é€»è¾‘
        for (int i = 0; i < data.length; i++) {
            data[i] = (byte) (i % 256);
        }
    }
}
```

**ğŸ“Š ä¸‰ç§æ–°ç”Ÿä»£æ”¶é›†å™¨å¯¹æ¯”**

| æ”¶é›†å™¨ | **çº¿ç¨‹æ•°** | **å…³æ³¨ç‚¹** | **é€‚ç”¨åœºæ™¯** | **STWæ—¶é—´** |
|-------|-----------|-----------|-------------|------------|
| ğŸ”¸ **Serial** | `1` | `å†…å­˜å ç”¨å°` | `å®¢æˆ·ç«¯åº”ç”¨` | `è¾ƒé•¿` |
| ğŸ”¹ **ParNew** | `å¤šçº¿ç¨‹` | `ä¸CMSé…åˆ` | `æœåŠ¡å™¨åº”ç”¨` | `ä¸­ç­‰` |
| ğŸ”º **Parallel Scavenge** | `å¤šçº¿ç¨‹` | `é«˜ååé‡` | `åå°è®¡ç®—` | `å¯æ§` |

### 3.2 è€å¹´ä»£æ”¶é›†å™¨ï¼šSerial Oldã€Parallel Oldã€CMS


**ğŸ”¸ Serial Oldæ”¶é›†å™¨ï¼šç»å…¸çš„è€å¹´ä»£æ”¶é›†å™¨**

**åŸºæœ¬ç‰¹ç‚¹**
```
Serial Oldæ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ å•çº¿ç¨‹ï¼šè€å¹´ä»£çš„å•çº¿ç¨‹æ”¶é›†å™¨
â€¢ ç®—æ³•ï¼šæ ‡è®°-æ•´ç†ç®—æ³•
â€¢ ç”¨é€”ï¼šå®¢æˆ·ç«¯æ¨¡å¼ æˆ– CMSçš„åå¤‡é¢„æ¡ˆ
â€¢ åœºæ™¯ï¼šå†…å­˜è¾ƒå°çš„åº”ç”¨ï¼Œæˆ–CMSå¤±è´¥æ—¶çš„å¤‡ç”¨æ–¹æ¡ˆ
```

**ğŸ’» Serial Oldå·¥ä½œç¤ºä¾‹**
```java
// Serial Old GCåœºæ™¯
public class SerialOldExample {
    private static List<String> longLivedObjects = new ArrayList<>();
    
    public static void main(String[] args) {
        // JVMå‚æ•°ï¼š-XX:+UseSerialGC -Xms64m -Xmx64m
        
        // åˆ›å»ºé•¿æœŸå­˜æ´»çš„å¯¹è±¡ï¼Œè¿›å…¥è€å¹´ä»£
        for (int i = 0; i < 10000; i++) {
            String longLived = "persistent_" + i;
            longLivedObjects.add(longLived);
            
            // åŒæ—¶åˆ›å»ºå¤§é‡ä¸´æ—¶å¯¹è±¡
            for (int j = 0; j < 100; j++) {
                String temp = "temp_" + i + "_" + j;
                // tempå¯¹è±¡å¿«é€Ÿæ­»äº¡
            }
            
            if (i % 1000 == 0) {
                // å®šæœŸè§¦å‘Full GC
                System.gc();
                System.out.println("å®Œæˆ" + i + "ä¸ªé•¿æœŸå¯¹è±¡çš„åˆ›å»º");
            }
        }
    }
}

// Serial Oldæ‰§è¡Œè¿‡ç¨‹ï¼š
// 1. è€å¹´ä»£ç©ºé—´ä¸è¶³è§¦å‘Full GC
// 2. STWæš‚åœæ‰€æœ‰çº¿ç¨‹
// 3. å•çº¿ç¨‹æ ‡è®°æ‰€æœ‰å­˜æ´»å¯¹è±¡
// 4. å•çº¿ç¨‹æ•´ç†å†…å­˜ï¼Œç§»åŠ¨å­˜æ´»å¯¹è±¡
// 5. æ¸…ç†æœªä½¿ç”¨çš„å†…å­˜ç©ºé—´
// 6. æ¢å¤åº”ç”¨çº¿ç¨‹æ‰§è¡Œ
```

**ğŸ”º Parallel Oldæ”¶é›†å™¨ï¼šå¤šçº¿ç¨‹çš„è€å¹´ä»£æ”¶é›†å™¨**

**åŸºæœ¬ç‰¹ç‚¹**
```
Parallel Oldæ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ å¤šçº¿ç¨‹ï¼šParallel Scavengeçš„è€å¹´ä»£ç‰ˆæœ¬
â€¢ ç®—æ³•ï¼šæ ‡è®°-æ•´ç†ç®—æ³•çš„å¤šçº¿ç¨‹å®ç°
â€¢ ç»„åˆï¼šä¸Parallel Scavengeç»„æˆå®Œæ•´çš„å¹¶è¡Œæ”¶é›†æ–¹æ¡ˆ
â€¢ ç›®æ ‡ï¼šåœ¨è€å¹´ä»£ä¹Ÿå®ç°é«˜ååé‡
```

**ğŸ’» Parallel Oldå·¥ä½œåŸç†**
```java
// Parallel Oldå¤šçº¿ç¨‹æ ‡è®°-æ•´ç†
public class ParallelOldGC {
    private int threadCount;
    private HeapRegion[] regions;
    
    // å¹¶è¡Œæ ‡è®°é˜¶æ®µ
    public void parallelMark() {
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    // æ¯ä¸ªçº¿ç¨‹è´Ÿè´£æ ‡è®°ä¸€éƒ¨åˆ†åŒºåŸŸ
                    markRegion(regions[threadId]);
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        // ç­‰å¾…æ‰€æœ‰æ ‡è®°çº¿ç¨‹å®Œæˆ
        latch.await();
    }
    
    // å¹¶è¡Œæ•´ç†é˜¶æ®µ
    public void parallelCompact() {
        // è®¡ç®—æ‰€æœ‰å­˜æ´»å¯¹è±¡çš„æ–°åœ°å€
        calculateNewAddresses();
        
        // å¹¶è¡Œæ›´æ–°å¼•ç”¨
        CountDownLatch updateLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    updateReferences(regions[threadId]);
                } finally {
                    updateLatch.countDown();
                }
            }).start();
        }
        updateLatch.await();
        
        // å¹¶è¡Œç§»åŠ¨å¯¹è±¡
        CountDownLatch moveLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    moveObjects(regions[threadId]);
                } finally {
                    moveLatch.countDown();
                }
            }).start();
        }
        moveLatch.await();
    }
}
```

**ğŸŒ€ CMSæ”¶é›†å™¨ï¼šå¹¶å‘æ ‡è®°æ¸…é™¤**

**åŸºæœ¬ç‰¹ç‚¹**
```
CMS (Concurrent Mark Sweep) æ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ å¹¶å‘ï¼šå¤§éƒ¨åˆ†æ—¶é—´ä¸åº”ç”¨çº¿ç¨‹å¹¶å‘æ‰§è¡Œ
â€¢ ç®—æ³•ï¼šæ ‡è®°-æ¸…é™¤ç®—æ³•
â€¢ ç›®æ ‡ï¼šé™ä½åœé¡¿æ—¶é—´ï¼ˆä½å»¶è¿Ÿï¼‰
â€¢ é—®é¢˜ï¼šå†…å­˜ç¢ç‰‡ã€å¹¶å‘å¼€é”€ã€æµ®åŠ¨åƒåœ¾
```

**ğŸ”„ CMSæ‰§è¡Œè¿‡ç¨‹è¯¦è§£**
```
CMS GCå››ä¸ªé˜¶æ®µï¼š

1. åˆå§‹æ ‡è®° (Initial Mark) - STW
   â€¢ ä»…æ ‡è®°GC Rootsç›´æ¥å…³è”çš„å¯¹è±¡
   â€¢ æ—¶é—´å¾ˆçŸ­

2. å¹¶å‘æ ‡è®° (Concurrent Mark) - å¹¶å‘
   â€¢ ä¸åº”ç”¨çº¿ç¨‹å¹¶å‘æ‰§è¡Œ
   â€¢ æ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
   â€¢ æ—¶é—´æœ€é•¿ï¼Œä½†ä¸æš‚åœåº”ç”¨

3. é‡æ–°æ ‡è®° (Remark) - STW  
   â€¢ ä¿®æ­£å¹¶å‘æ ‡è®°æœŸé—´çš„å˜åŠ¨
   â€¢ ä½¿ç”¨å¢é‡æ›´æ–°ç®—æ³•
   â€¢ æ—¶é—´è¾ƒçŸ­

4. å¹¶å‘æ¸…é™¤ (Concurrent Sweep) - å¹¶å‘
   â€¢ ä¸åº”ç”¨çº¿ç¨‹å¹¶å‘æ‰§è¡Œ
   â€¢ æ¸…é™¤æœªæ ‡è®°çš„å¯¹è±¡
   â€¢ ä¸å‹ç¼©å†…å­˜
```

**ğŸ’» CMSæ”¶é›†å™¨ç¤ºä¾‹**
```java
public class CMSExample {
    private static List<Object> cache = new ArrayList<>();
    
    public static void main(String[] args) throws InterruptedException {
        // JVMå‚æ•°ï¼š-XX:+UseConcMarkSweepGC -XX:+UseParNewGC
        //          -XX:CMSInitiatingOccupancyFraction=70
        //          -XX:+UseCMSInitiatingOccupancyOnly
        
        // æ¨¡æ‹ŸWebåº”ç”¨ï¼šæŒç»­çš„è¯·æ±‚å¤„ç†
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(4);
        
        // å®šæœŸæ·»åŠ ç¼“å­˜å¯¹è±¡ï¼ˆè€å¹´ä»£ï¼‰
        executor.scheduleAtFixedRate(() -> {
            for (int i = 0; i < 100; i++) {
                cache.add("cache_" + System.currentTimeMillis() + "_" + i);
            }
        }, 0, 100, TimeUnit.MILLISECONDS);
        
        // æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†ï¼ˆæ–°ç”Ÿä»£å¯¹è±¡ï¼‰
        executor.scheduleAtFixedRate(() -> {
            processRequest();
        }, 0, 10, TimeUnit.MILLISECONDS);
        
        // è¿è¡Œ10ç§’
        Thread.sleep(10000);
        executor.shutdown();
    }
    
    static void processRequest() {
        // åˆ›å»ºå¤§é‡ä¸´æ—¶å¯¹è±¡ï¼ˆæ¨¡æ‹Ÿè¯·æ±‚å¤„ç†ï¼‰
        List<String> tempObjects = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            tempObjects.add("request_object_" + i);
        }
        // æ–¹æ³•ç»“æŸï¼ŒtempObjectså˜ä¸ºåƒåœ¾
    }
}
```

**ğŸ“Š CMSæ—¶é—´çº¿åˆ†æ**
```
CMS GCæ‰§è¡Œæ—¶é—´çº¿ï¼š

åº”ç”¨çº¿ç¨‹: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
CMSçº¿ç¨‹:  ---- â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ --
é˜¶æ®µ:     åˆå§‹   å¹¶å‘æ ‡è®°            é‡æ–°  å¹¶å‘æ¸…é™¤
         æ ‡è®°                      æ ‡è®°

è¯´æ˜ï¼š
â–ˆ = å¹¶å‘æ‰§è¡Œï¼ˆåº”ç”¨çº¿ç¨‹å’ŒGCçº¿ç¨‹åŒæ—¶è¿è¡Œï¼‰
- = STWæš‚åœ
CMSå¤§éƒ¨åˆ†æ—¶é—´ä¸åº”ç”¨å¹¶å‘ï¼Œåªæœ‰ä¸¤ä¸ªçŸ­æš‚çš„STW
```

**âš ï¸ CMSæ”¶é›†å™¨çš„é—®é¢˜**
```java
// 1. å†…å­˜ç¢ç‰‡é—®é¢˜
class CMSFragmentationProblem {
    public static void main(String[] args) {
        // CMSä½¿ç”¨æ ‡è®°-æ¸…é™¤ï¼Œä¸æ•´ç†å†…å­˜
        // é•¿æœŸè¿è¡Œåäº§ç”Ÿå¤§é‡å†…å­˜ç¢ç‰‡
        
        List<Object> objects = new ArrayList<>();
        
        // åˆ›å»ºä¸åŒå¤§å°çš„å¯¹è±¡
        for (int i = 0; i < 10000; i++) {
            if (i % 3 == 0) {
                objects.add(new byte[1024]);      // 1KBå¯¹è±¡
            } else if (i % 3 == 1) {
                objects.add(new byte[2048]);      // 2KBå¯¹è±¡  
            } else {
                objects.add(new byte[4096]);      // 4KBå¯¹è±¡
            }
            
            // éšæœºåˆ é™¤ä¸€äº›å¯¹è±¡ï¼Œäº§ç”Ÿç¢ç‰‡
            if (i % 10 == 0 && !objects.isEmpty()) {
                objects.remove(0);
            }
        }
        
        // å°è¯•åˆ†é…å¤§å¯¹è±¡ï¼Œå¯èƒ½å› ç¢ç‰‡å¤±è´¥
        try {
            byte[] bigObject = new byte[1024 * 1024];  // 1MB
        } catch (OutOfMemoryError e) {
            System.out.println("å†…å­˜ç¢ç‰‡å¯¼è‡´å¤§å¯¹è±¡åˆ†é…å¤±è´¥");
        }
    }
}

// 2. æµ®åŠ¨åƒåœ¾é—®é¢˜
class CMSFloatingGarbageProblem {
    // å¹¶å‘æ ‡è®°æœŸé—´ï¼Œåº”ç”¨çº¿ç¨‹ç»§ç»­äº§ç”Ÿåƒåœ¾
    // è¿™äº›"æµ®åŠ¨åƒåœ¾"åªèƒ½ç­‰ä¸‹æ¬¡GCå›æ”¶
    private static Object floatingGarbage;
    
    public static void main(String[] args) {
        // åœ¨CMSå¹¶å‘æ ‡è®°æœŸé—´
        new Thread(() -> {
            // åº”ç”¨çº¿ç¨‹ç»§ç»­è¿è¡Œ
            Object temp = new Object();
            floatingGarbage = temp;    // åˆ›å»ºå¼•ç”¨
            
            // CMSæ ‡è®°è¿‡ç¨‹ä¸­ï¼Œtempè¢«æ ‡è®°ä¸ºå­˜æ´»
            
            floatingGarbage = null;    // åˆ é™¤å¼•ç”¨
            
            // ä½†tempå·²è¢«æ ‡è®°ä¸ºå­˜æ´»ï¼Œæœ¬æ¬¡GCä¸ä¼šå›æ”¶
            // æˆä¸º"æµ®åŠ¨åƒåœ¾"ï¼Œéœ€ç­‰å¾…ä¸‹æ¬¡GC
        }).start();
    }
}
```

### 3.3 æ–°ä¸€ä»£æ”¶é›†å™¨ï¼šG1ã€ZGCã€Shenandoah


**ğŸ¯ G1æ”¶é›†å™¨ï¼šé¢å‘æœåŠ¡ç«¯çš„ä½å»¶è¿Ÿæ”¶é›†å™¨**

**G1åŸºæœ¬ç‰¹ç‚¹**
```
G1 (Garbage First) æ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ åˆ†åŒºåŸŸï¼šå°†å †åˆ†ä¸ºå¤šä¸ªå¤§å°ç›¸ç­‰çš„Region
â€¢ å¯é¢„æµ‹ï¼šå¯è®¾ç½®æœŸæœ›çš„æš‚åœæ—¶é—´ç›®æ ‡
â€¢ å¹¶å‘ï¼šæ ‡è®°é˜¶æ®µä¸åº”ç”¨å¹¶å‘æ‰§è¡Œ
â€¢ å¢é‡ï¼šå¯ä»¥åªå›æ”¶éƒ¨åˆ†Region
â€¢ æ•´ç†ï¼šè§£å†³CMSçš„å†…å­˜ç¢ç‰‡é—®é¢˜
```

**ğŸ—ºï¸ G1å †å†…å­˜å¸ƒå±€**
```
G1å †å†…å­˜åˆ†åŒºå¸ƒå±€ï¼š

â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  E  â”‚  E  â”‚  S  â”‚  O  â”‚  O  â”‚  H  â”‚  E  â”‚  S  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚  O  â”‚  H  â”‚  E  â”‚  E  â”‚     â”‚  O  â”‚  S  â”‚  E  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚  E  â”‚  O  â”‚  O  â”‚  H  â”‚  E  â”‚     â”‚  E  â”‚  O  â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

å›¾ä¾‹ï¼š
E = EdenåŒºåŸŸ      S = SurvivoråŒºåŸŸ
O = OldåŒºåŸŸ       H = HumongousåŒºåŸŸï¼ˆå¤§å¯¹è±¡ï¼‰
ç©ºç™½ = æœªä½¿ç”¨åŒºåŸŸ

ç‰¹ç‚¹ï¼š
â€¢ æ¯ä¸ªRegioné»˜è®¤1MB-32MB
â€¢ åŠ¨æ€åˆ†é…åŒºåŸŸè§’è‰²
â€¢ å¤§å¯¹è±¡è·¨å¤šä¸ªRegionå­˜å‚¨
```

**ğŸ’» G1æ”¶é›†å™¨å·¥ä½œç¤ºä¾‹**
```java
public class G1GCExample {
    private static List<Object> survivedObjects = new ArrayList<>();
    
    public static void main(String[] args) throws InterruptedException {
        // JVMå‚æ•°ï¼š-XX:+UseG1GC 
        //          -XX:MaxGCPauseMillis=100
        //          -XX:G1HeapRegionSize=16m
        
        // æ¨¡æ‹Ÿä¸åŒç±»å‹çš„å¯¹è±¡åˆ†é…
        simulateEdenAllocation();
        simulateOldGeneration();
        simulateHumongousObjects();
        
        // è§¦å‘Mixed GC
        System.gc();
    }
    
    // EdenåŒºåŸŸåˆ†é…
    static void simulateEdenAllocation() {
        for (int i = 0; i < 10000; i++) {
            Object obj = new Object();
            if (i % 100 == 0) {
                survivedObjects.add(obj);  // éƒ¨åˆ†å¯¹è±¡å­˜æ´»
            }
            // å…¶ä»–å¯¹è±¡å¿«é€Ÿæ­»äº¡ï¼Œè§¦å‘Young GC
        }
    }
    
    // è€å¹´ä»£å¯¹è±¡
    static void simulateOldGeneration() {
        for (int i = 0; i < 1000; i++) {
            String longLived = "persistent_" + i;
            survivedObjects.add(longLived);
        }
    }
    
    // å¤§å¯¹è±¡åˆ†é…
    static void simulateHumongousObjects() {
        // å¤§äºRegionä¸€åŠçš„å¯¹è±¡ç›´æ¥åˆ†é…åˆ°HumongousåŒºåŸŸ
        byte[] bigArray1 = new byte[8 * 1024 * 1024];   // 8MB
        byte[] bigArray2 = new byte[16 * 1024 * 1024];  // 16MB
        
        survivedObjects.add(bigArray1);
        survivedObjects.add(bigArray2);
    }
}
```

**ğŸ”„ G1æ”¶é›†è¿‡ç¨‹**
```
G1 GCæ‰§è¡Œè¿‡ç¨‹ï¼š

1. Young GCï¼ˆæ–°ç”Ÿä»£æ”¶é›†ï¼‰ï¼š
   â€¢ æš‚åœåº”ç”¨çº¿ç¨‹
   â€¢ å›æ”¶æ‰€æœ‰Edenå’ŒSurvivoråŒºåŸŸ
   â€¢ å­˜æ´»å¯¹è±¡å¤åˆ¶åˆ°å…¶ä»–åŒºåŸŸæˆ–æ™‹å‡åˆ°OldåŒºåŸŸ
   â€¢ æš‚åœæ—¶é—´å¯æ§

2. Concurrent Cycleï¼ˆå¹¶å‘å‘¨æœŸï¼‰ï¼š
   a) Initial Mark - STW
      â€¢ æ ‡è®°GC Rootsç›´æ¥å¼•ç”¨çš„å¯¹è±¡
      
   b) Root Region Scan - å¹¶å‘
      â€¢ æ‰«æSurvivoråŒºåŸŸä¸­å¯¹è€å¹´ä»£çš„å¼•ç”¨
      
   c) Concurrent Mark - å¹¶å‘
      â€¢ æ ‡è®°æ•´ä¸ªå †ä¸­çš„å­˜æ´»å¯¹è±¡
      
   d) Remark - STW
      â€¢ å®Œæˆæ ‡è®°ï¼Œå¤„ç†å‰©ä½™çš„SATBç¼“å†²åŒº
      
   e) Cleanup - STW
      â€¢ æ¸…ç†å®Œå…¨ç©ºé—²çš„åŒºåŸŸ
      
3. Mixed GCï¼ˆæ··åˆæ”¶é›†ï¼‰ï¼š
   â€¢ å›æ”¶æ–°ç”Ÿä»£ + éƒ¨åˆ†è€å¹´ä»£åŒºåŸŸ
   â€¢ é€‰æ‹©å›æ”¶ä»·å€¼æœ€é«˜çš„åŒºåŸŸï¼ˆGarbage Firstï¼‰
```

**âš¡ ZGCæ”¶é›†å™¨ï¼šè¶…ä½å»¶è¿Ÿæ”¶é›†å™¨**

**ZGCåŸºæœ¬ç‰¹ç‚¹**
```
ZGC (Z Garbage Collector) ç‰¹ç‚¹ï¼š
â€¢ è¶…ä½å»¶è¿Ÿï¼šæš‚åœæ—¶é—´å°äº10ms
â€¢ å¤§å †æ”¯æŒï¼šæ”¯æŒ8MB-16TBçš„å †
â€¢ å¹¶å‘ï¼šå‡ ä¹æ‰€æœ‰å·¥ä½œéƒ½ä¸åº”ç”¨å¹¶å‘è¿›è¡Œ
â€¢ ç€è‰²æŒ‡é’ˆï¼šä½¿ç”¨64ä½æŒ‡é’ˆå­˜å‚¨é¢å¤–ä¿¡æ¯
â€¢ åˆ†åŒºç®¡ç†ï¼šåŠ¨æ€åˆ†åŒºå¤§å°ï¼ˆ2MBã€32MBã€512MBï¼‰
```

**ğŸ¨ ZGCç€è‰²æŒ‡é’ˆæŠ€æœ¯**
```
ZGCç€è‰²æŒ‡é’ˆï¼ˆ64ä½å¹³å°ï¼‰ï¼š

  63    62    61    60    59-18     17-0
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Finalâ”‚Remapâ”‚Mark1â”‚Mark0â”‚ Unused  â”‚ Offset  â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä½åŸŸå«ä¹‰ï¼š
â€¢ Finalï¼šå¯¹è±¡æ˜¯å¦å·²å®Œæˆé‡åˆ†é…
â€¢ Remapï¼šå¯¹è±¡æ˜¯å¦éœ€è¦é‡æ–°æ˜ å°„
â€¢ Mark1/Mark0ï¼šç”¨äºå¹¶å‘æ ‡è®°çš„åŒç¼“å†²
â€¢ Offsetï¼šå¯¹è±¡åœ¨å†…å­˜ä¸­çš„å®é™…åç§»é‡

ä¼˜åŠ¿ï¼š
â€¢ æ— éœ€éå†å¯¹è±¡å›¾æ›´æ–°å¼•ç”¨
â€¢ å¹¶å‘é‡åˆ†é…ä¸å½±å“åº”ç”¨çº¿ç¨‹
â€¢ æ”¯æŒè¶…å¤§å †å†…å­˜
```

**ğŸ’» ZGCä½¿ç”¨ç¤ºä¾‹**
```java
public class ZGCExample {
    public static void main(String[] args) {
        // JVMå‚æ•°ï¼š-XX:+UnlockExperimentalVMOptions -XX:+UseZGC
        //          -Xmx8g
        
        // ZGCé€‚åˆå¤§å †ã€ä½å»¶è¿Ÿåœºæ™¯
        Map<String, Object> bigCache = new HashMap<>();
        
        // åˆ›å»ºå¤§é‡å¯¹è±¡ï¼Œæ¨¡æ‹Ÿå¤§å †åº”ç”¨
        for (int i = 0; i < 1000000; i++) {
            String key = "key_" + i;
            Object value = createComplexObject(i);
            bigCache.put(key, value);
            
            // ZGCåœ¨åå°å¹¶å‘å·¥ä½œï¼Œåº”ç”¨å‡ ä¹æ— æ„ŸçŸ¥
            if (i % 100000 == 0) {
                System.out.println("å·²å¤„ç† " + i + " ä¸ªå¯¹è±¡");
                // å³ä½¿æ­¤æ—¶å‘ç”ŸGCï¼Œæš‚åœæ—¶é—´ä¹Ÿå°äº10ms
            }
        }
        
        // æ¸…ç†éƒ¨åˆ†ç¼“å­˜ï¼Œè§¦å‘GC
        Iterator<Map.Entry<String, Object>> iterator = bigCache.entrySet().iterator();
        int removed = 0;
        while (iterator.hasNext() && removed < 500000) {
            iterator.next();
            iterator.remove();
            removed++;
        }
        
        System.out.println("ç¼“å­˜æ¸…ç†å®Œæˆï¼ŒZGCå¹¶å‘å›æ”¶å†…å­˜");
    }
    
    static Object createComplexObject(int id) {
        return new ComplexObject(id, "data_" + id, new byte[1024]);
    }
}

class ComplexObject {
    private int id;
    private String name;
    private byte[] data;
    
    public ComplexObject(int id, String name, byte[] data) {
        this.id = id;
        this.name = name;
        this.data = data;
    }
}
```

**ğŸŒŠ Shenandoahæ”¶é›†å™¨ï¼šä½å»¶è¿Ÿå¹¶å‘æ”¶é›†å™¨**

**ShenandoahåŸºæœ¬ç‰¹ç‚¹**
```
Shenandoahæ”¶é›†å™¨ç‰¹ç‚¹ï¼š
â€¢ ä½å»¶è¿Ÿï¼šæš‚åœæ—¶é—´ä¸å †å¤§å°æ— å…³
â€¢ å¹¶å‘ï¼šå¹¶å‘æ ‡è®°ã€å¹¶å‘å›æ”¶ã€å¹¶å‘é‡åˆ†é…
â€¢ BrooksæŒ‡é’ˆï¼šé—´æ¥æŒ‡é’ˆæŠ€æœ¯å®ç°å¹¶å‘ç§»åŠ¨
â€¢ é€‚ç”¨ï¼šå¯¹å»¶è¿Ÿæ•æ„Ÿçš„åº”ç”¨
```

**ğŸ”— BrooksæŒ‡é’ˆæŠ€æœ¯**
```
Shenandoah BrooksæŒ‡é’ˆåŸç†ï¼š

æ­£å¸¸å¯¹è±¡å¸ƒå±€ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Object    â”‚ â† ç›´æ¥å¼•ç”¨
â”‚   Header    â”‚
â”‚   Fields    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BrooksæŒ‡é’ˆå¸ƒå±€ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Brooks Ptr  â”‚ â”€â”€â†’ â”‚   Object    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚   Header    â”‚
â”‚   Object    â”‚     â”‚   Fields    â”‚
â”‚   Header    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚   Fields    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ä¼˜åŠ¿ï¼š
â€¢ å¯¹è±¡ç§»åŠ¨æ—¶åªéœ€æ›´æ–°BrooksæŒ‡é’ˆ
â€¢ åº”ç”¨çº¿ç¨‹é€šè¿‡BrooksæŒ‡é’ˆè®¿é—®å¯¹è±¡
â€¢ å®ç°çœŸæ­£çš„å¹¶å‘ç§»åŠ¨
```

### 3.4 æ”¶é›†å™¨çš„ç»„åˆæ­é…å’Œé€‚ç”¨åœºæ™¯


**ğŸ“Š åƒåœ¾æ”¶é›†å™¨ç»„åˆçŸ©é˜µ**

| æ–°ç”Ÿä»£æ”¶é›†å™¨ | **è€å¹´ä»£æ”¶é›†å™¨** | **é€‚ç”¨åœºæ™¯** | **ç‰¹ç‚¹** |
|-------------|-----------------|-------------|---------|
| ğŸ”¸ **Serial** | `Serial Old` | `å®¢æˆ·ç«¯åº”ç”¨` | `å•çº¿ç¨‹ï¼Œå†…å­˜å°` |
| ğŸ”¹ **ParNew** | `CMS` | `ä½å»¶è¿ŸæœåŠ¡å™¨` | `å¹¶å‘æ”¶é›†ï¼Œå“åº”ä¼˜å…ˆ` |
| ğŸ”¹ **ParNew** | `Serial Old` | `CMSå¤±è´¥åå¤‡` | `æ··åˆæ¨¡å¼` |
| ğŸ”º **Parallel Scavenge** | `Parallel Old` | `ååé‡ä¼˜å…ˆ` | `é«˜ååé‡ï¼Œæ‰¹å¤„ç†` |
| ğŸ¯ **G1** | `G1` | `å¤§å †ä½å»¶è¿Ÿ` | `å¯é¢„æµ‹æš‚åœ` |
| âš¡ **ZGC** | `ZGC` | `è¶…å¤§å †è¶…ä½å»¶è¿Ÿ` | `æš‚åœæ—¶é—´<10ms` |
| ğŸŒŠ **Shenandoah** | `Shenandoah` | `å¤§å †ä½å»¶è¿Ÿ` | `å¹¶å‘ç§»åŠ¨` |

**ğŸ¯ åº”ç”¨åœºæ™¯é€‰æ‹©æŒ‡å—**
```java
// åœºæ™¯1ï¼šæ¡Œé¢åº”ç”¨ç¨‹åº
class DesktopApplication {
    // ç‰¹ç‚¹ï¼šç”¨æˆ·äº¤äº’ï¼Œå†…å­˜è¾ƒå°ï¼ˆ<100MBï¼‰
    // é€‰æ‹©ï¼šSerial GC
    // é…ç½®ï¼š-XX:+UseSerialGC -Xmx64m
    
    public static void main(String[] args) {
        // GUIåº”ç”¨ï¼Œå¶å‘çš„GCæš‚åœå¯æ¥å—
        SwingUtilities.invokeLater(() -> {
            // UIé€»è¾‘
        });
    }
}

// åœºæ™¯2ï¼šWebæœåŠ¡å™¨
class WebServerApplication {
    // ç‰¹ç‚¹ï¼šé«˜å¹¶å‘ï¼Œå“åº”æ—¶é—´æ•æ„Ÿ
    // é€‰æ‹©ï¼šG1 GC æˆ– ParNew + CMS
    // é…ç½®ï¼š-XX:+UseG1GC -XX:MaxGCPauseMillis=100
    
    @RestController
    public class ApiController {
        @GetMapping("/api/data")
        public ResponseEntity<Data> getData() {
            // éœ€è¦å¿«é€Ÿå“åº”ï¼ŒGCæš‚åœè¦çŸ­
            return ResponseEntity.ok(dataService.getData());
        }
    }
}

// åœºæ™¯3ï¼šå¤§æ•°æ®æ‰¹å¤„ç†
class BigDataBatchProcessing {
    // ç‰¹ç‚¹ï¼šå¤§å†…å­˜ï¼Œååé‡ä¼˜å…ˆ
    // é€‰æ‹©ï¼šParallel GC
    // é…ç½®ï¼š-XX:+UseParallelGC -XX:GCTimeRatio=99 -Xmx32g
    
    public static void main(String[] args) {
        // æ‰¹å¤„ç†ä»»åŠ¡ï¼Œå¯ä»¥å®¹å¿è¾ƒé•¿çš„GCæš‚åœ
        processLargeDataset();
    }
    
    static void processLargeDataset() {
        List<Record> records = loadMillionsOfRecords();
        
        // é•¿æ—¶é—´è¿è¡Œçš„è®¡ç®—ä»»åŠ¡
        records.parallelStream()
               .map(r -> complexCalculation(r))
               .collect(Collectors.toList());
    }
}

// åœºæ™¯4ï¼šå®æ—¶äº¤æ˜“ç³»ç»Ÿ
class HighFrequencyTradingSystem {
    // ç‰¹ç‚¹ï¼šæä½å»¶è¿Ÿè¦æ±‚ï¼ˆå¾®ç§’çº§ï¼‰
    // é€‰æ‹©ï¼šZGC æˆ– Shenandoah
    // é…ç½®ï¼š-XX:+UseZGC -Xmx16g
    
    public void processTrade(TradeOrder order) {
        // äº¤æ˜“å¤„ç†ä¸èƒ½è¢«GCä¸­æ–­
        // éœ€è¦ç¡®å®šæ€§çš„ä½å»¶è¿Ÿ
        executeTradeImmediately(order);
    }
}

// åœºæ™¯5ï¼šå†…å­˜ç¼“å­˜æœåŠ¡
class MemoryCacheService {
    // ç‰¹ç‚¹ï¼šè¶…å¤§å †å†…å­˜ï¼ˆTBçº§ï¼‰
    // é€‰æ‹©ï¼šZGC
    // é…ç½®ï¼š-XX:+UseZGC -Xmx1t
    
    private static Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public Object get(String key) {
        // å¤§ç¼“å­˜æœåŠ¡ï¼Œéœ€è¦æ”¯æŒTBçº§å†…å­˜
        return cache.get(key);
    }
}
```

### 3.5 Minor GCã€Major GCã€Full GCçš„åŒºåˆ«å’Œè§¦å‘æ¡ä»¶


**ğŸ” GCç±»å‹å®šä¹‰**
```
Minor GCï¼š
â€¢ å®šä¹‰ï¼šä»…å›æ”¶æ–°ç”Ÿä»£çš„åƒåœ¾æ”¶é›†
â€¢ è§¦å‘ï¼šEdenåŒºæ»¡æ—¶
â€¢ ç‰¹ç‚¹ï¼šé¢‘ç¹å‘ç”Ÿï¼Œé€Ÿåº¦è¾ƒå¿«

Major GCï¼š
â€¢ å®šä¹‰ï¼šå›æ”¶è€å¹´ä»£çš„åƒåœ¾æ”¶é›†
â€¢ è§¦å‘ï¼šè€å¹´ä»£ç©ºé—´ä¸è¶³
â€¢ ç‰¹ç‚¹ï¼šè¾ƒå°‘å‘ç”Ÿï¼Œé€Ÿåº¦è¾ƒæ…¢

Full GCï¼š
â€¢ å®šä¹‰ï¼šå›æ”¶æ•´ä¸ªå †ï¼ˆæ–°ç”Ÿä»£+è€å¹´ä»£ï¼‰çš„åƒåœ¾æ”¶é›†
â€¢ è§¦å‘ï¼šå¤šç§æƒ…å†µ
â€¢ ç‰¹ç‚¹ï¼šæœ€æ…¢ï¼Œå½±å“æœ€å¤§
```

**âš¡ Minor GCè§¦å‘æ¡ä»¶è¯¦è§£**
```java
public class MinorGCTrigger {
    public static void main(String[] args) {
        // Minor GCè§¦å‘æ¡ä»¶ï¼šEdenåŒºç©ºé—´ä¸è¶³
        
        List<Object> objects = new ArrayList<>();
        
        // ä¸æ–­åˆ›å»ºå¯¹è±¡ï¼Œå¡«æ»¡EdenåŒº
        for (int i = 0; i < 100000; i++) {
            Object obj = new Object();
            
            // å½“EdenåŒºæ»¡æ—¶ï¼Œè§¦å‘Minor GC
            // GCè¿‡ç¨‹ï¼š
            // 1. STWæš‚åœåº”ç”¨çº¿ç¨‹
            // 2. æ‰«æGC Roots + è€å¹´ä»£å¼•ç”¨
            // 3. å¤åˆ¶å­˜æ´»å¯¹è±¡åˆ°SurvivoråŒº
            // 4. æ¸…ç©ºEdenåŒº
            // 5. å¯¹è±¡å¹´é¾„å¢é•¿ï¼Œè¾¾åˆ°é˜ˆå€¼æ™‹å‡åˆ°è€å¹´ä»£
            
            if (i % 10 == 0) {
                objects.add(obj);  // è®©éƒ¨åˆ†å¯¹è±¡å­˜æ´»
            }
        }
        
        System.out.println("Minor GCå®Œæˆ");
    }
}
```

**ğŸ›ï¸ Major GCè§¦å‘æ¡ä»¶è¯¦è§£**
```java
public class MajorGCTrigger {
    private static List<byte[]> oldGenObjects = new ArrayList<>();
    
    public static void main(String[] args) {
        // Major GCè§¦å‘æ¡ä»¶ï¼š
        
        // 1. è€å¹´ä»£ç©ºé—´ä¸è¶³
        try {
            while (true) {
                // åˆ›å»ºå¤§å¯¹è±¡ï¼Œç›´æ¥è¿›å…¥è€å¹´ä»£
                byte[] bigObject = new byte[1024 * 1024];  // 1MB
                oldGenObjects.add(bigObject);
                
                // è€å¹´ä»£æ»¡æ—¶è§¦å‘Major GC
            }
        } catch (OutOfMemoryError e) {
            System.out.println("è€å¹´ä»£ç©ºé—´ä¸è¶³ï¼Œè§¦å‘Major GC");
        }
        
        // 2. æ™‹å‡å¤±è´¥ï¼ˆPromotion Failedï¼‰
        // æ–°ç”Ÿä»£GCæ—¶ï¼Œå­˜æ´»å¯¹è±¡æ— æ³•æ”¾å…¥è€å¹´ä»£
        
        // 3. CMS GCçš„è§¦å‘æ¡ä»¶
        // -XX:CMSInitiatingOccupancyFraction=70
        // è€å¹´ä»£ä½¿ç”¨ç‡è¾¾åˆ°70%æ—¶æå‰è§¦å‘
    }
}
```

**ğŸ’¥ Full GCè§¦å‘æ¡ä»¶è¯¦è§£**
```java
public class FullGCTrigger {
    public static void main(String[] args) {
        // Full GCè§¦å‘æ¡ä»¶ï¼š
        
        // 1. è°ƒç”¨System.gc()
        System.gc();  // å»ºè®®JVMæ‰§è¡ŒFull GC
        
        // 2. è€å¹´ä»£ç©ºé—´ä¸è¶³
        simulateOldGenFull();
        
        // 3. å…ƒç©ºé—´ä¸è¶³ï¼ˆJava 8+ï¼‰
        simulateMetaspaceFull();
        
        // 4. åˆ†é…æ‹…ä¿å¤±è´¥
        simulatePromotionFailed();
        
        // 5. CMS GCå¤±è´¥ï¼Œé€€åŒ–ä¸ºSerial Old
        // Concurrent Mode Failure
    }
    
    static void simulateOldGenFull() {
        List<byte[]> objects = new ArrayList<>();
        try {
            while (true) {
                objects.add(new byte[1024 * 1024]);  // 1MBå¯¹è±¡
            }
        } catch (OutOfMemoryError e) {
            System.out.println("è€å¹´ä»£æ»¡ï¼Œè§¦å‘Full GC");
        }
    }
    
    static void simulateMetaspaceFull() {
        // åŠ¨æ€åŠ è½½å¤§é‡ç±»ï¼Œå¡«æ»¡å…ƒç©ºé—´
        for (int i = 0; i < 100000; i++) {
            try {
                generateClass("DynamicClass" + i);
            } catch (OutOfMemoryError e) {
                System.out.println("å…ƒç©ºé—´æ»¡ï¼Œè§¦å‘Full GC");
                break;
            }
        }
    }
    
    static void simulatePromotionFailed() {
        // åˆ›å»ºå¤§é‡ä¸­ç­‰ç”Ÿå‘½å‘¨æœŸå¯¹è±¡
        // å¯¼è‡´è€å¹´ä»£ç¢ç‰‡ï¼Œæ— æ³•å®¹çº³æ™‹å‡å¯¹è±¡
        List<Object> objects = new ArrayList<>();
        
        for (int i = 0; i < 10000; i++) {
            // åˆ›å»ºä¸åŒå¤§å°çš„å¯¹è±¡ï¼Œäº§ç”Ÿç¢ç‰‡
            int size = (i % 3 + 1) * 1024;  // 1KB, 2KB, 3KB
            objects.add(new byte[size]);
            
            if (i % 2 == 0) {
                objects.remove(0);  // éšæœºåˆ é™¤ï¼Œäº§ç”Ÿç¢ç‰‡
            }
        }
        
        // å°è¯•åˆ†é…å¤§å¯¹è±¡ï¼Œå¯èƒ½å› ç¢ç‰‡å¯¼è‡´æ‹…ä¿å¤±è´¥
        try {
            byte[] bigObject = new byte[10 * 1024 * 1024];  // 10MB
        } catch (OutOfMemoryError e) {
            System.out.println("åˆ†é…æ‹…ä¿å¤±è´¥ï¼Œè§¦å‘Full GC");
        }
    }
}
```

### 3.6 æ”¶é›†å™¨çš„æ€§èƒ½æŒ‡æ ‡ï¼šååé‡ã€å»¶è¿Ÿã€å†…å­˜å ç”¨


**ğŸ“Š æ€§èƒ½æŒ‡æ ‡å®šä¹‰**
```
ååé‡ (Throughput)ï¼š
â€¢ å®šä¹‰ï¼šè¿è¡Œç”¨æˆ·ä»£ç æ—¶é—´ / æ€»è¿è¡Œæ—¶é—´
â€¢ è®¡ç®—ï¼š(æ€»æ—¶é—´ - GCæ—¶é—´) / æ€»æ—¶é—´
â€¢ ç›®æ ‡ï¼šæœ€å¤§åŒ–åº”ç”¨æ‰§è¡Œæ—¶é—´

å»¶è¿Ÿ (Latency)ï¼š
â€¢ å®šä¹‰ï¼šGCé€ æˆçš„åº”ç”¨æš‚åœæ—¶é—´
â€¢ æŒ‡æ ‡ï¼šæœ€å¤§æš‚åœæ—¶é—´ã€å¹³å‡æš‚åœæ—¶é—´ã€99.9%åˆ†ä½æ•°
â€¢ ç›®æ ‡ï¼šæœ€å°åŒ–ç”¨æˆ·æ„ŸçŸ¥çš„åœé¡¿

å†…å­˜å ç”¨ (Memory Footprint)ï¼š
â€¢ å®šä¹‰ï¼šGCç®—æ³•æœ¬èº«æ¶ˆè€—çš„é¢å¤–å†…å­˜
â€¢ åŒ…æ‹¬ï¼šGCçº¿ç¨‹æ ˆã€æ ‡è®°ä½å›¾ã€è®°å¿†é›†ç­‰
â€¢ ç›®æ ‡ï¼šæœ€å°åŒ–å†…å­˜å¼€é”€
```

**ğŸ’» æ€§èƒ½æµ‹è¯•ç¤ºä¾‹**
```java
import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.ManagementFactory;

public class GCPerformanceMetrics {
    
    public static void main(String[] args) throws InterruptedException {
        // å¼€å§‹æ€§èƒ½æµ‹è¯•
        long startTime = System.currentTimeMillis();
        long startGCTime = getGCTime();
        
        // æ‰§è¡Œå·¥ä½œè´Ÿè½½
        performWorkload();
        
        // ç»“æŸæ€§èƒ½æµ‹è¯•
        long endTime = System.currentTimeMillis();
        long endGCTime = getGCTime();
        
        // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
        calculateMetrics(startTime, endTime, startGCTime, endGCTime);
    }
    
    static void performWorkload() throws InterruptedException {
        // æ¨¡æ‹Ÿå®é™…åº”ç”¨è´Ÿè½½
        for (int i = 0; i < 1000; i++) {
            // åˆ›å»ºå¯¹è±¡ï¼Œæ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
            List<String> data = new ArrayList<>();
            for (int j = 0; j < 10000; j++) {
                data.add("data_" + i + "_" + j);
            }
            
            // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            Thread.sleep(10);
            
            // æ¸…ç†æ•°æ®ï¼Œè§¦å‘GC
            if (i % 100 == 0) {
                data.clear();
                System.gc();
            }
        }
    }
    
    static long getGCTime() {
        long totalGCTime = 0;
        for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) {
            totalGCTime += gc.getCollectionTime();
        }
        return totalGCTime;
    }
    
    static void calculateMetrics(long startTime, long endTime, 
                                long startGCTime, long endGCTime) {
        long totalTime = endTime - startTime;
        long totalGCTime = endGCTime - startGCTime;
        long applicationTime = totalTime - totalGCTime;
        
        // è®¡ç®—ååé‡
        double throughput = (double) applicationTime / totalTime * 100;
        
        // è®¡ç®—GCå¼€é”€
        double gcOverhead = (double) totalGCTime / totalTime * 100;
        
        System.out.println("=== GCæ€§èƒ½æŒ‡æ ‡ ===");
        System.out.println("æ€»è¿è¡Œæ—¶é—´: " + totalTime + "ms");
        System.out.println("GCæ€»æ—¶é—´: " + totalGCTime + "ms");
        System.out.println("åº”ç”¨è¿è¡Œæ—¶é—´: " + applicationTime + "ms");
        System.out.println("ååé‡: " + String.format("%.2f", throughput) + "%");
        System.out.println("GCå¼€é”€: " + String.format("%.2f", gcOverhead) + "%");
        
        // æ‰“å°è¯¦ç»†GCä¿¡æ¯
        printDetailedGCInfo();
    }
    
    static void printDetailedGCInfo() {
        for (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) {
            System.out.println("\n--- " + gc.getName() + " ---");
            System.out.println("æ”¶é›†æ¬¡æ•°: " + gc.getCollectionCount());
            System.out.println("æ”¶é›†æ—¶é—´: " + gc.getCollectionTime() + "ms");
            
            if (gc.getCollectionCount() > 0) {
                double avgTime = (double) gc.getCollectionTime() / gc.getCollectionCount();
                System.out.println("å¹³å‡æš‚åœæ—¶é—´: " + String.format("%.2f", avgTime) + "ms");
            }
        }
    }
}
```

**ğŸ“Š ä¸åŒæ”¶é›†å™¨æ€§èƒ½å¯¹æ¯”**

| æ”¶é›†å™¨ | **ååé‡** | **å»¶è¿Ÿ** | **å†…å­˜å ç”¨** | **é€‚ç”¨å †å¤§å°** |
|-------|-----------|---------|-------------|---------------|
| ğŸ”¸ **Serial** | `é«˜` | `é«˜ï¼ˆSTWé•¿ï¼‰` | `æä½` | `<100MB` |
| ğŸ”¹ **ParNew** | `ä¸­é«˜` | `ä¸­ï¼ˆSTWä¸­ç­‰ï¼‰` | `ä½` | `<8GB` |
| ğŸ”º **Parallel** | `æé«˜` | `é«˜ï¼ˆSTWé•¿ï¼‰` | `ä½` | `<8GB` |
| ğŸŒ€ **CMS** | `ä¸­` | `ä½ï¼ˆå¹¶å‘ï¼‰` | `ä¸­` | `<32GB` |
| ğŸ¯ **G1** | `é«˜` | `ä½ï¼ˆå¯æ§ï¼‰` | `ä¸­é«˜` | `>4GB` |
| âš¡ **ZGC** | `é«˜` | `æä½ï¼ˆ<10msï¼‰` | `é«˜` | `>8GB` |
| ğŸŒŠ **Shenandoah** | `é«˜` | `æä½ï¼ˆ<10msï¼‰` | `é«˜` | `>8GB` |

**ğŸ¯ æ€§èƒ½è°ƒä¼˜å»ºè®®**
```java
// ååé‡ä¼˜å…ˆåœºæ™¯
class ThroughputOptimization {
    // ç›®æ ‡ï¼šæœ€å¤§åŒ–åº”ç”¨è¿è¡Œæ—¶é—´å æ¯”
    // é€‰æ‹©ï¼šParallel GC
    // å‚æ•°ï¼š
    // -XX:+UseParallelGC
    // -XX:GCTimeRatio=99           // GCæ—¶é—´å æ¯”1%
    // -XX:+UseAdaptiveSizePolicy   // è‡ªé€‚åº”è°ƒæ•´
    
    void optimizeForThroughput() {
        // æ‰¹å¤„ç†ä»»åŠ¡ï¼Œå¯ä»¥å®¹å¿é•¿æ—¶é—´GCæš‚åœ
        // ä½†è¦æ±‚æ•´ä½“å¤„ç†é€Ÿåº¦å¿«
    }
}

// å»¶è¿Ÿä¼˜å…ˆåœºæ™¯  
class LatencyOptimization {
    // ç›®æ ‡ï¼šæœ€å°åŒ–GCæš‚åœæ—¶é—´
    // é€‰æ‹©ï¼šG1 GC æˆ– ZGC
    // å‚æ•°ï¼š
    // -XX:+UseG1GC
    // -XX:MaxGCPauseMillis=50      // æœ€å¤§æš‚åœ50ms
    // -XX:G1MixedGCCountTarget=8   // æ··åˆGCæ¬¡æ•°
    
    void optimizeForLatency() {
        // åœ¨çº¿æœåŠ¡ï¼Œç”¨æˆ·ä½“éªŒæ•æ„Ÿ
        // è¦æ±‚å¿«é€Ÿå“åº”ï¼Œä½å»¶è¿Ÿ
    }
}

// å†…å­˜ä¼˜å…ˆåœºæ™¯
class MemoryOptimization {
    // ç›®æ ‡ï¼šæœ€å°åŒ–å†…å­˜å ç”¨
    // é€‰æ‹©ï¼šSerial GC
    // å‚æ•°ï¼š
    // -XX:+UseSerialGC
    // -XX:+UseCompressedOops       // å‹ç¼©æŒ‡é’ˆ
    // -XX:-UseBiasedLocking        // ç¦ç”¨åå‘é”
    
    void optimizeForMemory() {
        // å†…å­˜å—é™ç¯å¢ƒï¼Œå¦‚åµŒå…¥å¼è®¾å¤‡
        // è¦æ±‚æœ€å°çš„å†…å­˜å¼€é”€
    }
}
```

---

**æ ¸å¿ƒè®°å¿†è¦ç‚¹**ï¼š
- åƒåœ¾æ”¶é›†åŸºäºå¯è¾¾æ€§åˆ†æå’Œåˆ†ä»£å‡è¯´ï¼Œé€šè¿‡GC Rootsæ ‡è®°å­˜æ´»å¯¹è±¡
- ä¸‰å¤§åŸºç¡€ç®—æ³•ï¼šæ ‡è®°-æ¸…é™¤ï¼ˆæœ‰ç¢ç‰‡ï¼‰ã€æ ‡è®°-å¤åˆ¶ï¼ˆæµªè´¹ç©ºé—´ï¼‰ã€æ ‡è®°-æ•´ç†ï¼ˆè€—æ—¶é•¿ï¼‰
- åˆ†ä»£æ”¶é›†ç»“åˆç®—æ³•ä¼˜åŠ¿ï¼šæ–°ç”Ÿä»£å¤åˆ¶ç®—æ³•ï¼Œè€å¹´ä»£æ ‡è®°-æ¸…é™¤/æ•´ç†ç®—æ³•
- æ”¶é›†å™¨æ¼”è¿›ï¼šSerialâ†’ParNewâ†’Parallelâ†’CMSâ†’G1â†’ZGCï¼Œè¿½æ±‚ä½å»¶è¿Ÿå’Œé«˜åå
- æ€§èƒ½è°ƒä¼˜éœ€æƒè¡¡ååé‡ã€å»¶è¿Ÿã€å†…å­˜å ç”¨ä¸‰ä¸ªæŒ‡æ ‡ï¼Œæ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©