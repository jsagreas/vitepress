---
title: 1、JVM基础架构与运行机制
---
## 📚 目录

1. [JVM概述与定义](#1-JVM概述与定义)
2. [Java程序执行流程](#2-Java程序执行流程)
3. [JVM整体架构组件](#3-JVM整体架构组件)

---

## 1. 🎯 JVM概述与定义


### 1.1 JVM的定义与作用


**🔸 核心定义**
```
JVM（Java Virtual Machine）：Java虚拟机
本质：一个运行Java字节码的虚拟计算机
作用：在操作系统和Java程序之间提供抽象层
目标：实现"一次编译，到处运行"的跨平台特性
```

**💡 JVM的本质理解**
JVM实际上是一个**软件实现的计算机**，它具备了真实计算机的基本特征：
- **指令集**：字节码指令集
- **内存管理**：堆、栈、方法区等内存区域
- **执行引擎**：解释器和JIT编译器
- **垃圾回收器**：自动内存管理机制

### 1.2 JDK vs JRE vs JVM的区别和关系


**🏗️ 三者关系结构图**
```
┌─────────────────────────────────────────┐
│                  JDK                    │
│  ┌───────────────────────────────────┐  │
│  │              JRE                  │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │           JVM               │  │  │
│  │  │  • 类加载器                  │  │  │
│  │  │  • 执行引擎                  │  │  │
│  │  │  • 内存管理                  │  │  │
│  │  │  • 垃圾回收                  │  │  │
│  │  └─────────────────────────────┘  │  │
│  │  • Java核心类库                   │  │
│  │  • Java API                      │  │
│  └───────────────────────────────────┘  │
│  • 编译器(javac)                        │
│  • 调试工具(jdb)                        │
│  • 文档生成(javadoc)                    │
└─────────────────────────────────────────┘
```

**📊 详细对比表**

| 组件 | **全称** | **主要内容** | **主要用户** | **核心功能** |
|------|---------|-------------|-------------|-------------|
| 🔧 **JDK** | `Java Development Kit` | `JRE + 开发工具` | `Java开发者` | `编译、调试、打包Java程序` |
| ⚡ **JRE** | `Java Runtime Environment` | `JVM + 核心类库` | `Java程序用户` | `运行Java程序` |
| 🎯 **JVM** | `Java Virtual Machine` | `字节码执行引擎` | `系统底层` | `执行Java字节码` |

**🔍 生活类比理解**
```
JDK = 汽车制造厂 (包含设计工具、生产线、成品车)
JRE = 成品汽车 (包含发动机、底盘、轮胎等运行部件)
JVM = 汽车发动机 (核心动力源，负责具体运转)

关系：制造厂 ⊃ 汽车 ⊃ 发动机
```

### 1.3 JVM规范与实现


**📋 JVM规范 vs JVM实现**
```
JVM规范：
• 定义：Oracle发布的《Java虚拟机规范》
• 内容：字节码格式、指令集、内存模型等标准
• 作用：确保不同JVM实现的兼容性
• 版本：跟随Java版本更新（Java 8、11、17等）

JVM实现：
• 定义：按照规范开发的具体JVM产品
• 特点：可以有不同的优化策略和性能特点
• 厂商：Oracle、IBM、Azul、Eclipse等
```

**🏢 主流JVM实现对比**

| JVM实现 | **厂商** | **特点** | **适用场景** | **市场份额** |
|---------|---------|---------|-------------|-------------|
| 🔥 **HotSpot** | `Oracle` | `最主流，JIT优化强` | `通用场景，生产环境` | `~70%` |
| ⚡ **OpenJ9** | `Eclipse/IBM` | `启动快，内存占用小` | `云原生，容器化` | `~15%` |
| 🚀 **GraalVM** | `Oracle` | `多语言支持，AOT编译` | `微服务，性能极致场景` | `~5%` |
| 🎯 **Azul Zing** | `Azul Systems` | `低延迟，大内存优化` | `金融交易，实时系统` | `~3%` |

### 1.4 跨平台原理：一次编译，到处运行


**🌍 跨平台实现机制**
```
传统C/C++程序：
源码 → 编译器 → 机器码 → 特定平台执行
问题：不同平台需要重新编译

Java程序：
源码 → javac → 字节码 → JVM → 机器码
优势：字节码在任何JVM上都能运行
```

**⚙️ 跨平台实现步骤详解**

```java
// 1. Java源码 (HelloWorld.java)
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// 2. 编译为字节码 (HelloWorld.class)
javac HelloWorld.java

// 3. 字节码内容示例 (javap -c HelloWorld)
public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2    // Field java/lang/System.out
       3: ldc           #3    // String Hello, World!
       5: invokevirtual #4    // Method java/io/PrintStream.println
       8: return

// 4. 不同平台执行
java HelloWorld  // Windows/Linux/macOS都能运行
```

**📈 平台适配流程图**
```
Java源码(跨平台)
        ↓
    javac编译
        ↓
   字节码文件(跨平台)
        ↓
┌───────┬───────┬───────┐
│Windows│ Linux │ macOS │
│  JVM  │  JVM  │  JVM  │
└───┬───┴───┬───┴───┬───┘
    ↓       ↓       ↓
  Windows  Linux   macOS
  机器码   机器码   机器码
```

### 1.5 JVM在Java生态中的地位


**🌟 生态系统中的核心作用**
```
🔸 语言支持层面：
• 不仅支持Java，还支持Kotlin、Scala、Groovy等
• 提供统一的字节码执行环境
• 实现多语言互操作

🔸 性能优化层面：
• JIT即时编译优化热点代码
• 垃圾回收自动内存管理
• 多线程并发执行支持

🔸 企业应用层面：
• Spring、Hibernate等框架的运行基础
• 微服务架构的底层支撑
• 大数据处理（Hadoop、Spark）的执行环境
```

**💼 JVM在不同场景中的应用**

| 应用场景 | **JVM作用** | **典型框架/工具** | **性能要求** |
|---------|------------|-----------------|-------------|
| 🌐 **Web应用** | `Servlet容器运行环境` | `Tomcat、Spring Boot` | `高并发、低延迟` |
| 📊 **大数据** | `分布式计算执行引擎` | `Hadoop、Spark、Kafka` | `高吞吐量` |
| 🏢 **企业应用** | `业务逻辑执行平台` | `Spring、Hibernate` | `稳定性、可靠性` |
| 📱 **Android** | `移动应用运行环境` | `ART（基于JVM思想）` | `内存优化、启动速度` |

---

## 2. 🔄 Java程序执行流程


### 2.1 从源码到字节码的编译过程


**🔧 编译过程总览**
```
Java源文件(.java) → javac编译器 → 字节码文件(.class) → JVM执行
```

**📝 详细编译步骤**

**步骤1：词法分析（Lexical Analysis）**
```java
// 源码示例
int x = 10;

// 词法分析结果
Token[0]: KEYWORD(int)
Token[1]: IDENTIFIER(x)  
Token[2]: OPERATOR(=)
Token[3]: LITERAL(10)
Token[4]: SEMICOLON(;)
```

**步骤2：语法分析（Syntax Analysis）**
```
生成抽象语法树(AST)：
    VariableDeclaration
    ├── Type: int
    ├── Name: x
    └── Initializer: 10
```

**步骤3：语义分析（Semantic Analysis）**
```java
// 类型检查
int x = "hello";  // ❌ 编译错误：类型不匹配
int y = 10;       // ✅ 类型匹配

// 变量作用域检查
{
    int a = 5;
}
System.out.println(a);  // ❌ 编译错误：变量超出作用域
```

**步骤4：字节码生成（Bytecode Generation）**
```java
// Java源码
public int add(int a, int b) {
    return a + b;
}

// 生成的字节码
public int add(int, int);
  Code:
     0: iload_1        // 加载第一个参数到操作数栈
     1: iload_2        // 加载第二个参数到操作数栈
     2: iadd           // 执行整数加法
     3: ireturn        // 返回结果
```

### 2.2 字节码的特点和结构


**🎯 字节码核心特征**
```
🔸 平台无关性：
• 不依赖特定的硬件架构
• 不依赖特定的操作系统
• 在任何JVM上都能执行

🔸 紧凑性：
• 比源码更紧凑
• 去除了注释和空白字符
• 指令高度优化

🔸 安全性：
• 类型信息完整保留
• 便于JVM进行安全检查
• 防止缓冲区溢出等安全问题
```

**📋 字节码指令分类**

| 指令类型 | **功能** | **示例指令** | **用途说明** |
|---------|---------|-------------|-------------|
| 🔢 **加载存储** | `在局部变量表和操作数栈间传输` | `iload、istore、aload` | `变量读写操作` |
| ➕ **运算指令** | `对操作数栈的值进行运算` | `iadd、isub、imul` | `算术逻辑运算` |
| 🔄 **类型转换** | `数据类型之间的转换` | `i2l、d2f、checkcast` | `类型安全转换` |
| 🎯 **对象操作** | `创建和访问对象` | `new、getfield、putfield` | `面向对象操作` |
| 🌊 **控制转移** | `改变程序执行流程` | `if_icmplt、goto、return` | `条件判断和跳转` |

### 2.3 JVM加载和执行字节码的过程


**⚡ 字节码执行流程**
```
.class文件 → 类加载器 → 方法区 → 执行引擎 → 操作系统
```

**🔄 详细执行步骤**

**步骤1：类加载（Class Loading）**
```java
// 触发类加载的时机
MyClass obj = new MyClass();  // new关键字
MyClass.staticMethod();       // 调用静态方法
Class.forName("MyClass");     // 反射加载

// 类加载过程
加载 → 验证 → 准备 → 解析 → 初始化
```

**步骤2：字节码验证（Bytecode Verification）**
```
验证内容：
✅ 文件格式验证：魔数、版本号检查
✅ 元数据验证：继承关系、接口实现检查  
✅ 字节码验证：数据流分析、控制流分析
✅ 符号引用验证：权限检查、存在性检查
```

**步骤3：执行引擎处理（Execution Engine）**
```
执行方式：
🔸 解释执行：逐条解释字节码指令
🔸 JIT编译：将热点代码编译为机器码
🔸 混合模式：解释+编译的协作执行
```

### 2.4 Class文件结构概览


**📦 Class文件整体结构**
```
ClassFile {
    u4              magic;              // 魔数：0xCAFEBABE
    u2              minor_version;      // 次版本号
    u2              major_version;      // 主版本号  
    u2              constant_pool_count; // 常量池计数
    cp_info         constant_pool[];    // 常量池
    u2              access_flags;       // 访问标志
    u2              this_class;         // 类索引
    u2              super_class;        // 父类索引
    u2              interfaces_count;   // 接口计数
    u2              interfaces[];       // 接口索引集合
    u2              fields_count;       // 字段计数
    field_info      fields[];           // 字段表
    u2              methods_count;      // 方法计数
    method_info     methods[];          // 方法表
    u2              attributes_count;   // 属性计数
    attribute_info  attributes[];       // 属性表
}
```

**🔍 关键组成部分详解**

**魔数与版本信息**
```bash
# 查看Class文件魔数
hexdump -C HelloWorld.class | head -1
00000000  ca fe ba be 00 00 00 34  00 1d 0a 00 06 00 0f 09

解释：
ca fe ba be = 魔数（0xCAFEBABE）
00 00 = 次版本号（0）
00 34 = 主版本号（52，对应Java 8）
```

**常量池（Constant Pool）**
```java
// Java源码
public class Example {
    private String name = "Hello";
    public void sayHello() {
        System.out.println(name);
    }
}

// 常量池内容示例
#1 = Utf8               Example
#2 = Class              #1           // Example
#3 = Utf8               java/lang/Object  
#4 = Class              #3           // java/lang/Object
#5 = Utf8               name
#6 = Utf8               Ljava/lang/String;
#7 = Utf8               Hello
#8 = String             #7           // "Hello"
```

**方法表（Method Table）**
```java
// 方法信息结构
method_info {
    u2              access_flags;     // 访问标志(public/private等)
    u2              name_index;       // 方法名索引
    u2              descriptor_index; // 方法描述符索引
    u2              attributes_count; // 属性计数
    attribute_info  attributes[];     // 属性表(Code、Exception等)
}
```

### 2.5 javac编译器的工作原理


**🔧 javac编译器架构**
```
源文件输入 → 前端处理 → 中端优化 → 后端生成 → 字节码输出
```

**📊 编译器工作阶段**

| 阶段 | **主要工作** | **输入** | **输出** | **关键技术** |
|------|-------------|---------|---------|-------------|
| 🔍 **词法分析** | `将源码分解为Token` | `Java源码` | `Token流` | `状态机、正则表达式` |
| 🌳 **语法分析** | `构建抽象语法树` | `Token流` | `AST` | `递归下降、LR分析` |
| ✅ **语义分析** | `类型检查、作用域分析` | `AST` | `标注AST` | `符号表、类型推导` |
| 🎯 **代码生成** | `生成字节码指令` | `标注AST` | `字节码` | `指令选择、寄存器分配` |

**💡 编译优化示例**
```java
// 源码
public class OptimizationExample {
    public int calculate() {
        int a = 10;
        int b = 20;
        int c = a + b;  // 编译时可优化为 int c = 30;
        return c;
    }
}

// javac编译时优化
public int calculate();
  Code:
     0: bipush        30     // 直接使用优化后的常量
     2: ireturn
```

**🔧 使用javac编译器**
```bash
# 基本编译
javac HelloWorld.java

# 指定类路径编译
javac -cp /path/to/libs/*.jar MyClass.java

# 指定输出目录
javac -d ./build src/com/example/*.java

# 显示详细编译信息
javac -verbose HelloWorld.java

# 生成调试信息
javac -g HelloWorld.java
```

---

## 3. 🏗️ JVM整体架构组件


### 3.1 JVM架构的总体结构图


**🏛️ JVM完整架构图**
```
┌─────────────────────────────────────────────────────────────┐
│                        Java程序                             │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│                   类加载器子系统                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────────┐ │
│  │Bootstrap    │ │Extension    │ │Application              │ │
│  │ClassLoader  │ │ClassLoader  │ │ClassLoader              │ │
│  └─────────────┘ └─────────────┘ └─────────────────────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│                  运行时数据区                                │
│ ┌─────────────────┐              ┌─────────────────────────┐ │
│ │   线程共享区     │              │      线程私有区         │ │
│ │ ┌─────────────┐ │              │ ┌─────────────────────┐ │ │
│ │ │   方法区     │ │              │ │    虚拟机栈         │ │ │
│ │ │(元空间)     │ │              │ │                     │ │ │
│ │ └─────────────┘ │              │ └─────────────────────┘ │ │
│ │ ┌─────────────┐ │              │ ┌─────────────────────┐ │ │
│ │ │    堆内存    │ │              │ │   本地方法栈        │ │ │
│ │ │             │ │              │ │                     │ │ │
│ │ └─────────────┘ │              │ └─────────────────────┘ │ │
│ └─────────────────┘              │ ┌─────────────────────┐ │ │
│                                  │ │   程序计数器        │ │ │
│                                  │ │                     │ │ │
│                                  │ └─────────────────────┘ │ │
│                                  └─────────────────────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│                    执行引擎                                  │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────────────────┐ │
│ │  解释器      │ │ JIT编译器   │ │     垃圾收集器          │ │
│ │(Interpreter) │ │(JIT Compiler)│ │  (Garbage Collector)   │ │
│ └─────────────┘ └─────────────┘ └─────────────────────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│              本地方法接口 (JNI)                              │
└─────────────────────┬───────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────────┐
│                本地方法库                                    │
│        (Native Method Libraries)                           │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 类加载器子系统（Class Loader Subsystem）


**🔄 类加载器的层次结构**
```
                Bootstrap ClassLoader
                        ↑
                Extension ClassLoader  
                        ↑
              Application ClassLoader
                        ↑
                Custom ClassLoader
```

**📋 类加载器详细对比**

| 类加载器 | **加载内容** | **实现方式** | **父加载器** | **路径** |
|---------|-------------|-------------|-------------|---------|
| 🚀 **Bootstrap** | `JVM核心类库` | `C++实现` | `无` | `$JAVA_HOME/jre/lib` |
| 🔧 **Extension** | `扩展类库` | `Java实现` | `Bootstrap` | `$JAVA_HOME/jre/lib/ext` |
| 📱 **Application** | `应用程序类` | `Java实现` | `Extension` | `ClassPath指定路径` |
| 🎯 **Custom** | `用户自定义` | `Java实现` | `Application` | `用户指定路径` |

**🔍 双亲委派模型工作流程**
```java
// 类加载请求流程
1. Application ClassLoader 收到加载请求
   ↓
2. 委派给 Extension ClassLoader
   ↓  
3. 委派给 Bootstrap ClassLoader
   ↓
4. Bootstrap 尝试加载，如果找不到返回 null
   ↓
5. Extension 尝试加载，如果找不到返回 null
   ↓
6. Application 自己加载，找到则返回 Class 对象

// 代码示例
ClassLoader loader = MyClass.class.getClassLoader();
System.out.println("MyClass的类加载器: " + loader);
System.out.println("父加载器: " + loader.getParent());
System.out.println("祖父加载器: " + loader.getParent().getParent());

// 输出结果
MyClass的类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2
父加载器: sun.misc.Launcher$ExtClassLoader@1b6d3586
祖父加载器: null  // Bootstrap ClassLoader由C++实现，Java中为null
```

### 3.3 运行时数据区（Runtime Data Area）


**🧠 内存区域概览**
运行时数据区是JVM在运行期间管理的内存区域，分为线程共享和线程私有两大类。

**📊 内存区域分类表**

| 内存区域 | **共享性** | **主要存储** | **生命周期** | **异常类型** |
|---------|-----------|-------------|-------------|-------------|
| 🌐 **堆内存** | `线程共享` | `对象实例、数组` | `JVM启动到关闭` | `OutOfMemoryError` |
| 📚 **方法区** | `线程共享` | `类信息、常量池、静态变量` | `JVM启动到关闭` | `OutOfMemoryError` |
| 📝 **虚拟机栈** | `线程私有` | `局部变量、方法调用` | `线程创建到销毁` | `StackOverflowError` |
| 🔢 **程序计数器** | `线程私有` | `当前执行指令地址` | `线程创建到销毁` | `无异常` |
| 🌉 **本地方法栈** | `线程私有` | `Native方法调用` | `线程创建到销毁` | `StackOverflowError` |

**🔍 内存区域详细分析**

**堆内存（Heap Memory）**
```
堆内存结构：
┌─────────────────────────────────────────┐
│                 堆内存                   │
│ ┌─────────────────┐ ┌─────────────────┐ │
│ │     年轻代       │ │     老年代       │ │
│ │ ┌─────┬───────┐ │ │                 │ │
│ │ │Eden │Survivor│ │ │   Old Generation│ │
│ │ │     │ S0│S1 │ │ │                 │ │
│ │ └─────┴───────┘ │ │                 │ │
│ └─────────────────┘ └─────────────────┘ │
└─────────────────────────────────────────┘

特点：
• 所有线程共享
• 存储对象实例和数组
• 垃圾收集的主要区域
• JVM启动时创建
```

**方法区（Method Area）**
```java
// 方法区存储内容示例
public class Student {
    private static int count = 0;           // 静态变量 → 方法区
    private final String SCHOOL = "清华";    // 字符串常量 → 字符串常量池
    
    public void study() {                   // 方法信息 → 方法区
        System.out.println("studying...");
    }
}

// 方法区包含：
✅ 类的元数据信息（类名、父类、接口等）
✅ 方法的字节码指令
✅ 静态变量
✅ 运行时常量池
✅ 字符串常量池（Java 7+移到堆中）
```

**虚拟机栈（JVM Stack）**
```
栈帧结构：
┌─────────────────────────┐
│        栈帧 N           │ ← 当前方法
├─────────────────────────┤
│    动态链接             │
├─────────────────────────┤
│    方法返回地址         │
├─────────────────────────┤
│    操作数栈             │
├─────────────────────────┤
│    局部变量表           │
└─────────────────────────┘
│        栈帧 N-1         │ ← 调用方法
├─────────────────────────┤
│        ...              │
└─────────────────────────┘

特点：
• 每个线程有独立的虚拟机栈
• 存储方法调用的局部变量和部分结果
• 方法调用时压栈，返回时出栈
• 栈大小可通过-Xss参数设置
```

### 3.4 执行引擎（Execution Engine）


**⚡ 执行引擎组成部分**

**解释器（Interpreter）**
```
工作方式：
Java字节码 → 解释器 → 机器指令 → 执行

特点：
✅ 启动快：无需编译时间，立即执行
✅ 内存占用小：不需要存储编译后的机器码
❌ 执行慢：每次都需要解释字节码
❌ 重复解释：相同代码重复执行时仍需解释
```

**JIT编译器（Just-In-Time Compiler）**
```
工作方式：
热点字节码 → JIT编译器 → 机器码 → 缓存 → 直接执行

热点代码识别：
• 方法调用计数器：统计方法被调用次数
• 回边计数器：统计循环执行次数
• 阈值触发：超过阈值时触发JIT编译

JIT编译器类型：
🔸 C1编译器（Client Compiler）：
  - 编译速度快，优化程度较低
  - 适合客户端应用
  
🔸 C2编译器（Server Compiler）：
  - 编译速度慢，优化程度较高
  - 适合服务器端应用
```

**🔄 分层编译（Tiered Compilation）**
```
编译层级：
Level 0: 解释执行
Level 1: C1编译，无性能监控
Level 2: C1编译，有限的性能监控  
Level 3: C1编译，完整的性能监控
Level 4: C2编译，激进优化

执行流程：
解释执行 → C1编译 → 性能监控 → C2编译
    ↑___________________|
    
优势：
• 启动速度快（解释执行）
• 峰值性能高（C2优化）
• 适应性强（动态优化）
```

### 3.5 本地方法接口（Native Method Interface）


**🌉 JNI工作机制**
```
Java应用程序
      ↓
  JNI接口层
      ↓  
   JVM实现
      ↓
  本地方法库
      ↓
   操作系统
```

**💡 JNI使用场景**
```java
// 典型的Native方法声明
public class FileOperation {
    // 声明native方法
    public native int createFile(String filename);
    public native void deleteFile(String filename);
    
    // 加载本地库
    static {
        System.loadLibrary("fileops"); // 加载libfileops.so
    }
}

使用场景：
🔸 性能关键代码：密集计算、图像处理
🔸 硬件访问：直接操作硬件设备
🔸 遗留系统集成：调用C/C++代码库
🔸 平台特定功能：操作系统特有API
```

### 3.6 各组件之间的协作关系


**🤝 组件协作流程**
```
程序启动阶段：
1. 类加载器加载主类 → 方法区
2. 创建主线程 → 分配虚拟机栈、程序计数器
3. 执行main方法 → 在栈中创建栈帧

程序运行阶段：
1. 执行引擎读取字节码 ← 程序计数器指示位置
2. 操作数栈处理指令 ← 虚拟机栈提供工作空间  
3. 创建对象实例 → 存储到堆内存
4. 调用本地方法 → 通过JNI接口

程序结束阶段：
1. 主线程结束 → 释放栈空间
2. 垃圾收集器清理 → 回收堆内存
3. JVM关闭 → 释放所有资源
```

**📊 性能影响关系**

| 组件 | **性能影响** | **优化方向** | **相关参数** |
|------|-------------|-------------|-------------|
| 🔄 **类加载器** | `启动速度` | `减少类加载时间` | `-XX:+TieredCompilation` |
| 🧠 **堆内存** | `GC频率` | `合理设置堆大小` | `-Xms -Xmx -Xmn` |
| 📚 **方法区** | `元数据存储` | `避免类加载过多` | `-XX:MetaspaceSize` |
| ⚡ **执行引擎** | `运行速度` | `JIT编译优化` | `-XX:CompileThreshold` |
| 🌉 **JNI接口** | `调用开销` | `减少JNI调用` | `无特殊参数` |

---

**核心记忆要点**：
- JVM是Java跨平台的核心，提供统一的字节码执行环境
- 类加载器负责将字节码加载到内存，双亲委派保证安全性
- 运行时数据区分为线程共享和私有，各有不同的存储职责
- 执行引擎通过解释器和JIT编译器协作，平衡启动速度和执行性能
- 各组件紧密协作，共同构成完整的Java程序执行环境