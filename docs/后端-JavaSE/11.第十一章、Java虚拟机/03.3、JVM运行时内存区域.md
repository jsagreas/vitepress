---
title: 3、JVM运行时内存区域
---
## 📚 目录

1. [内存区域总览与分类](#1-内存区域总览与分类)
2. [线程私有区域详解](#2-线程私有区域详解)
3. [线程共享区域详解](#3-线程共享区域详解)

---

## 1. 🧠 内存区域总览与分类


### 1.1 JVM内存区域的整体划分


**🏗️ JVM运行时数据区总体架构**
```
┌─────────────────────────────────────────────────────────────┐
│                      JVM运行时数据区                         │
│                                                             │
│  ┌─────────────────────┐    ┌─────────────────────────────┐ │
│  │    线程共享区域      │    │       线程私有区域          │ │
│  │                     │    │                             │ │
│  │ ┌─────────────────┐ │    │ ┌─────────────────────────┐ │ │
│  │ │     堆内存       │ │    │ │      程序计数器         │ │ │
│  │ │    (Heap)       │ │    │ │   (PC Register)        │ │ │
│  │ │                 │ │    │ └─────────────────────────┘ │ │
│  │ │  ┌───────────┐  │ │    │                             │ │
│  │ │  │ 新生代     │  │ │    │ ┌─────────────────────────┐ │ │
│  │ │  │Young Gen  │  │ │    │ │     Java虚拟机栈        │ │ │
│  │ │  └───────────┘  │ │    │ │    (JVM Stack)         │ │ │
│  │ │  ┌───────────┐  │ │    │ │                         │ │ │
│  │ │  │ 老年代     │  │ │    │ │ ┌─────┐ ┌─────┐ ┌─────┐ │ │ │
│  │ │  │Old Gen    │  │ │    │ │ │栈帧1│ │栈帧2│ │栈帧N│ │ │ │
│  │ │  └───────────┘  │ │    │ │ └─────┘ └─────┘ └─────┘ │ │ │
│  │ └─────────────────┘ │    │ └─────────────────────────┘ │ │
│  │                     │    │                             │ │
│  │ ┌─────────────────┐ │    │ ┌─────────────────────────┐ │ │
│  │ │    方法区        │ │    │ │     本地方法栈          │ │ │
│  │ │ (Method Area)   │ │    │ │ (Native Method Stack)  │ │ │
│  │ │                 │ │    │ └─────────────────────────┘ │ │
│  │ │ Java8+: 元空间  │ │    │                             │ │
│  │ │ (Metaspace)     │ │    │                             │ │
│  │ └─────────────────┘ │    │                             │ │
│  └─────────────────────┘    └─────────────────────────────┘ │
│                                                             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   直接内存                               │ │
│  │                (Direct Memory)                          │ │
│  │              不属于JVM规范定义                           │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 线程共享区域 vs 线程私有区域


**📊 内存区域分类对比表**

| 分类 | **内存区域** | **存储内容** | **生命周期** | **线程安全** | **异常类型** |
|------|-------------|-------------|-------------|-------------|-------------|
| 🌐 **线程共享** | `堆内存` | `对象实例、数组` | `JVM启动-关闭` | `需要同步` | `OutOfMemoryError` |
| 🌐 **线程共享** | `方法区` | `类信息、常量、静态变量` | `JVM启动-关闭` | `需要同步` | `OutOfMemoryError` |
| 👤 **线程私有** | `程序计数器` | `当前执行指令地址` | `线程创建-销毁` | `天然安全` | `无异常` |
| 👤 **线程私有** | `虚拟机栈` | `局部变量、方法调用` | `线程创建-销毁` | `天然安全` | `StackOverflowError` |
| 👤 **线程私有** | `本地方法栈` | `Native方法调用` | `线程创建-销毁` | `天然安全` | `StackOverflowError` |

**💡 线程共享与私有的意义**
```java
// 线程共享区域示例
public class SharedExample {
    private static int sharedCount = 0;    // 方法区（所有线程共享）
    private String name;                   // 堆内存（所有线程共享）
    
    public void increment() {
        sharedCount++;                     // 多线程访问需要同步
        String localName = "temp";         // 虚拟机栈（线程私有，无需同步）
    }
}

// 多线程并发问题
public class ConcurrentTest {
    public static void main(String[] args) {
        SharedExample obj = new SharedExample();  // 堆内存对象
        
        // 多个线程同时访问共享数据
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                obj.increment();  // 可能产生线程安全问题
            }).start();
        }
    }
}
```

### 1.3 内存区域与程序执行的关系


**🔄 程序执行时的内存使用流程**
```
程序执行阶段           内存区域使用
     ↓                    ↓
1. 类加载              → 方法区（存储类信息）
2. 创建对象            → 堆内存（存储实例）
3. 方法调用            → 虚拟机栈（栈帧）
4. 局部变量操作        → 虚拟机栈（局部变量表）
5. 指令执行            → 程序计数器（PC指针）
6. Native方法调用      → 本地方法栈
7. NIO操作             → 直接内存
```

**💻 内存使用示例**
```java
public class MemoryUsageExample {
    private static final String CONSTANT = "Hello";  // 方法区
    private String instanceField;                    // 对象头信息→堆内存
    
    public void methodCall(int param) {              // 栈帧→虚拟机栈
        int localVar = param + 10;                   // 局部变量→局部变量表
        String localStr = "World";                   // 字符串→堆内存
        instanceField = localStr;                    // 对象引用→堆内存
        
        // 每行代码的执行地址→程序计数器
        System.out.println(localVar);
    }
    
    public native void nativeMethod();               // 本地方法栈
}

// 内存分配流程：
// 1. 类加载时：CONSTANT、methodCall方法信息 → 方法区
// 2. new对象时：MemoryUsageExample实例 → 堆内存  
// 3. 调用方法时：methodCall栈帧 → 虚拟机栈
// 4. 执行指令时：指令地址 → 程序计数器
```

### 1.4 Java 8 前后内存结构的变化


**🔄 Java 8 内存结构重大变化**

**Java 7 及之前的内存结构**
```
┌─────────────────────────────────┐
│            堆内存                │
│  ┌─────────────────────────────┐ │
│  │          新生代              │ │
│  └─────────────────────────────┘ │
│  ┌─────────────────────────────┐ │
│  │          老年代              │ │
│  └─────────────────────────────┘ │
│  ┌─────────────────────────────┐ │
│  │         永久代               │ │  ← Java 8中被移除
│  │      (PermGen)              │ │
│  │   • 类元数据                 │ │
│  │   • 字符串常量池             │ │
│  │   • 静态变量                 │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
```

**Java 8+ 的内存结构**
```
┌─────────────────────────────────┐
│            堆内存                │
│  ┌─────────────────────────────┐ │
│  │          新生代              │ │
│  └─────────────────────────────┘ │
│  ┌─────────────────────────────┐ │
│  │          老年代              │ │
│  │   • 字符串常量池（迁移过来）  │ │  ← 从永久代迁移
│  │   • 静态变量（迁移过来）      │ │  ← 从永久代迁移
│  └─────────────────────────────┘ │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│           元空间                 │  ← 新增，使用本地内存
│        (Metaspace)              │
│   • 类元数据                     │
│   • 方法字节码                   │
│   • 常量池（非字符串）            │
└─────────────────────────────────┘
```

**📋 变化对比详表**

| 项目 | **Java 7-** | **Java 8+** | **变化原因** |
|------|-------------|-------------|-------------|
| 🏠 **类元数据** | `永久代` | `元空间(本地内存)` | `避免永久代OOM` |
| 📝 **字符串常量池** | `永久代` | `堆内存` | `便于GC回收` |
| 📊 **静态变量** | `永久代` | `堆内存` | `统一内存管理` |
| 💾 **内存管理** | `JVM堆内存` | `操作系统本地内存` | `动态扩展能力` |
| ⚠️ **OOM风险** | `PermGen space` | `Metaspace (更少)` | `提高稳定性` |

**💡 Java 8 变化的优势**
```java
// Java 7 及之前的问题
// -XX:PermSize=64m -XX:MaxPermSize=128m
// 永久代大小固定，容易OutOfMemoryError: PermGen space

// Java 8+ 的改进
// -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=unlimited
// 元空间使用本地内存，可以动态扩展

public class MetaspaceExample {
    public static void main(String[] args) {
        // Java 8+ 中类元数据存储在元空间
        Class<?> clazz = String.class;
        
        // 字符串常量池在堆内存中，可以被GC回收
        String str1 = "Hello";
        String str2 = new String("World").intern();
        
        // 静态变量存储在堆内存中
        System.out.println("元空间存储类元数据");
        System.out.println("堆内存存储字符串常量池和静态变量");
    }
}
```

### 1.5 内存区域的生命周期


**⏱️ 各内存区域生命周期对比**

```
JVM启动 ────────────────────────────────── JVM关闭
   │                                        │
   ├── 堆内存创建 ──────────────────────── 堆内存销毁
   ├── 方法区创建 ──────────────────────── 方法区销毁
   │                                        │
   │    线程1创建 ──── 线程1销毁            │
   │       ├── PC Register                  │
   │       ├── JVM Stack                    │
   │       └── Native Method Stack          │
   │                                        │
   │    线程2创建 ──── 线程2销毁            │
   │       ├── PC Register                  │
   │       ├── JVM Stack                    │
   │       └── Native Method Stack          │
   │                                        │
   └── 直接内存分配 ─── 直接内存释放 ───────┘
```

**🔄 生命周期管理示例**
```java
public class LifecycleExample {
    private static int classVar = 100;        // 方法区，JVM级别生命周期
    
    public static void main(String[] args) {
        // 主线程私有区域创建
        int localVar = 10;                     // 虚拟机栈，方法级别生命周期
        
        // 堆对象创建
        Object obj = new Object();             // 堆内存，GC管理生命周期
        
        // 启动新线程
        Thread thread = new Thread(() -> {
            int threadLocal = 20;              // 新线程的虚拟机栈
            System.out.println(threadLocal);
        });
        thread.start();
        // 线程结束时，该线程的私有区域被销毁
        
        // 方法结束时，localVar从栈中移除
    }
    // JVM关闭时，所有内存区域被销毁
}
```

---

## 2. 👤 线程私有区域详解


### 2.1 程序计数器（PC Register）：作用、特点、异常情况


**🎯 程序计数器的核心概念**
```
程序计数器（PC Register）：
• 作用：记录当前线程正在执行的字节码指令地址
• 本质：一个较小的内存空间，可以看作当前线程执行位置的指示器
• 范围：如果执行Java方法，记录字节码指令地址；如果执行Native方法，为空
```

**📊 程序计数器特点分析**

| 特点 | **详细说明** | **原因/意义** |
|------|-------------|-------------|
| 🔒 **线程私有** | `每个线程都有独立的PC Register` | `保证线程切换后能恢复到正确位置` |
| 📏 **空间最小** | `占用内存空间最小的区域` | `只需存储一个地址值` |
| 🚫 **无异常** | `唯一不会出现OutOfMemoryError的区域` | `空间固定且极小` |
| ⚡ **高频更新** | `每执行一条指令就更新一次` | `跟踪程序执行进度` |

**💻 程序计数器工作示例**
```java
public class PCRegisterExample {
    public static void main(String[] args) {
        int a = 10;        // PC指向: istore_1
        int b = 20;        // PC指向: istore_2  
        int c = a + b;     // PC指向: iadd
        System.out.println(c);  // PC指向: invokevirtual
    }
}

// 对应的字节码指令（javap -c）
public static void main(java.lang.String[]);
  Code:
     0: bipush        10    ← PC = 0
     2: istore_1           ← PC = 2
     3: bipush        20    ← PC = 3  
     5: istore_2           ← PC = 5
     6: iload_1            ← PC = 6
     7: iload_2            ← PC = 7
     8: iadd               ← PC = 8
     9: istore_3           ← PC = 9
    10: getstatic     #2   ← PC = 10
    13: iload_3           ← PC = 13
    14: invokevirtual #3   ← PC = 14
    17: return            ← PC = 17
```

**🔄 多线程环境下的PC Register**
```java
public class MultiThreadPCExample {
    private static int sharedVar = 0;
    
    public static void main(String[] args) {
        // 主线程PC Register：记录main方法的执行位置
        
        Thread thread1 = new Thread(() -> {
            // 线程1有独立的PC Register
            for (int i = 0; i < 1000; i++) {
                sharedVar++;  // PC记录循环中的指令位置
            }
        });
        
        Thread thread2 = new Thread(() -> {
            // 线程2有独立的PC Register  
            for (int i = 0; i < 1000; i++) {
                sharedVar++;  // PC记录循环中的指令位置
            }
        });
        
        thread1.start();
        thread2.start();
        
        // 每个线程的PC Register独立维护
        // 线程切换时保存和恢复PC值
    }
}
```

### 2.2 Java虚拟机栈（JVM Stack）：栈帧结构、局部变量表、操作数栈


**🏗️ 虚拟机栈的整体结构**
```
Java虚拟机栈 (每个线程一个)
┌─────────────────────────────┐
│        当前栈帧 (栈顶)       │ ← 当前正在执行的方法
├─────────────────────────────┤
│      调用者栈帧             │
├─────────────────────────────┤
│      调用者的调用者栈帧      │
├─────────────────────────────┤
│         ...                │
├─────────────────────────────┤
│      main方法栈帧 (栈底)    │
└─────────────────────────────┘
```

**📋 栈帧内部结构详解**
```
栈帧 (Stack Frame)
┌─────────────────────────────┐
│        动态链接              │ ← 指向运行时常量池的方法引用
├─────────────────────────────┤
│       方法返回地址           │ ← 方法执行完后的返回位置
├─────────────────────────────┤
│       附加信息              │ ← 调试信息等
├─────────────────────────────┤
│       操作数栈              │ ← 计算过程中的临时数据
│  ┌─────┬─────┬─────────────┐ │
│  │ top │     │             │ │
│  ├─────┼─────┼─────────────┤ │
│  │     │     │             │ │
│  └─────┴─────┴─────────────┘ │
├─────────────────────────────┤
│       局部变量表             │ ← 方法参数和局部变量
│  ┌─────┬─────┬─────────────┐ │
│  │ 0   │ 1   │ 2    ...    │ │ ← slot索引
│  ├─────┼─────┼─────────────┤ │
│  │this │param│localVar     │ │ ← 存储内容
│  └─────┴─────┴─────────────┘ │
└─────────────────────────────┘
```

**🗃️ 局部变量表详解**
```java
public class LocalVariableExample {
    private int instanceVar = 100;
    
    public int calculate(int param1, long param2) {
        // 局部变量表的slot分配：
        // slot 0: this引用 (实例方法隐含参数)
        // slot 1: param1 (int类型，占1个slot)  
        // slot 2-3: param2 (long类型，占2个slot)
        // slot 4: localVar (int类型，占1个slot)
        
        int localVar = param1 + 10;
        double localDouble = 3.14;  // slot 5-6 (double占2个slot)
        
        return localVar + (int)param2;
    }
    
    public static void staticMethod() {
        // 静态方法的局部变量表：
        // slot 0: 没有this引用，直接从参数开始
    }
}

// 查看局部变量表 (javap -verbose)
LocalVariableTable:
  Start  Length  Slot  Name   Signature
      0      15     0  this   Lcom/example/LocalVariableExample;
      0      15     1 param1  I
      0      15     2 param2  J
      8       7     4 localVar I
     12       3     5 localDouble D
```

**🔢 操作数栈详解**
```java
public class OperandStackExample {
    public int addNumbers(int a, int b) {
        return a + b;  // 操作数栈的使用过程
    }
}

// 字节码分析操作数栈变化
public int addNumbers(int, int);
  Code:
     0: iload_1      // 将局部变量表slot1(a)压入操作数栈
                     // 栈状态: [a]
     1: iload_2      // 将局部变量表slot2(b)压入操作数栈  
                     // 栈状态: [a, b] (b在栈顶)
     2: iadd         // 弹出栈顶两个元素相加，结果压入栈
                     // 栈状态: [a+b]
     3: ireturn      // 弹出栈顶元素作为返回值
                     // 栈状态: []

// 操作数栈变化过程：
// 初始: []
// iload_1后: [10]        (假设a=10)
// iload_2后: [10, 20]    (假设b=20)  
// iadd后: [30]           (10+20的结果)
// ireturn后: []          (30作为返回值)
```

### 2.3 本地方法栈（Native Method Stack）：与虚拟机栈的区别


**🌉 本地方法栈的作用**
```
本地方法栈 (Native Method Stack)：
• 作用：为JVM调用的本地方法(Native Method)服务
• 本质：支持native方法执行的栈结构
• 实现：不同JVM实现方式不同，HotSpot直接将其合并到虚拟机栈中
```

**📊 虚拟机栈 vs 本地方法栈对比**

| 对比项 | **Java虚拟机栈** | **本地方法栈** |
|-------|-----------------|---------------|
| 🎯 **服务对象** | `Java方法调用` | `Native方法调用` |
| 📝 **存储内容** | `Java方法的栈帧` | `Native方法的调用信息` |
| 🔧 **实现方式** | `JVM规范明确定义` | `实现灵活，可以使用C栈` |
| ⚠️ **异常类型** | `StackOverflowError、OOM` | `StackOverflowError、OOM` |
| 🏗️ **HotSpot实现** | `独立实现` | `合并到虚拟机栈中` |

**💻 本地方法调用示例**
```java
public class NativeMethodExample {
    // 声明本地方法
    public native void nativeMethod();
    public native int nativeCalculate(int x, int y);
    
    // 加载本地库
    static {
        System.loadLibrary("nativelib");  // 加载libnativelib.so
    }
    
    public void javaMethod() {
        // Java方法 → Java虚拟机栈
        int result = 10 + 20;
        
        // 调用本地方法 → 本地方法栈
        nativeMethod();
        
        // 本地方法返回后，继续使用Java虚拟机栈
        System.out.println("Java method continues");
    }
}

// 调用流程：
// 1. javaMethod() → Java虚拟机栈创建栈帧
// 2. nativeMethod() → 本地方法栈处理native调用
// 3. native方法执行完毕 → 返回Java虚拟机栈
// 4. 继续执行Java代码
```

**🔍 常见的本地方法**
```java
// JDK中的本地方法示例
public class CommonNativeMethods {
    public static void main(String[] args) {
        // Object类的本地方法
        Object obj = new Object();
        obj.hashCode();          // native方法
        obj.clone();             // native方法
        
        // System类的本地方法  
        System.currentTimeMillis();  // native方法
        System.arraycopy(src, 0, dest, 0, length);  // native方法
        
        // Thread类的本地方法
        Thread.currentThread().getName();  // 内部调用native方法
        Thread.sleep(1000);                 // native方法
        
        // 文件操作的本地方法
        new java.io.File("test.txt").exists();  // 最终调用native方法
    }
}
```

### 2.4 栈相关异常：StackOverflowError、OutOfMemoryError


**⚠️ 栈异常类型分析**

**异常1：StackOverflowError**
```java
// 产生原因：线程请求的栈深度大于虚拟机允许的深度
public class StackOverflowExample {
    private int stackDepth = 0;
    
    public void recursiveMethod() {
        stackDepth++;
        recursiveMethod();  // 无限递归调用
    }
    
    public static void main(String[] args) {
        StackOverflowExample example = new StackOverflowExample();
        try {
            example.recursiveMethod();
        } catch (StackOverflowError e) {
            System.out.println("栈深度: " + example.stackDepth);
            // 典型输出: 栈深度: 15000-20000 (取决于-Xss设置)
        }
    }
}

// JVM参数调优：
// -Xss128k   (设置较小栈空间，更容易出现StackOverflowError)
// -Xss1m     (设置较大栈空间，增加最大栈深度)
```

**异常2：OutOfMemoryError (栈空间)**
```java
// 产生原因：虚拟机在扩展栈时无法申请到足够的内存空间
public class StackOOMExample {
    private void dontStop() {
        while (true) {
            // 每个线程都有独立的虚拟机栈
        }
    }
    
    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(() -> dontStop());
            thread.start();
            // 不断创建线程，每个线程都分配栈空间
            // 最终导致无法创建新的线程栈 → OutOfMemoryError
        }
    }
    
    public static void main(String[] args) {
        StackOOMExample example = new StackOOMExample();
        example.stackLeakByThread();
    }
}

// 错误信息: java.lang.OutOfMemoryError: unable to create new native thread
```

**📊 栈异常对比表**

| 异常类型 | **触发条件** | **常见原因** | **解决方案** |
|---------|-------------|-------------|-------------|
| 🔴 **StackOverflowError** | `栈深度超过限制` | `无限递归、深度调用` | `检查递归逻辑、增加-Xss` |
| 🔴 **OutOfMemoryError** | `无法分配栈内存` | `线程过多、栈空间不足` | `减少线程数、优化-Xss` |

### 2.5 栈帧的创建、销毁过程


**🔄 栈帧生命周期**
```
方法调用开始 → 栈帧创建 → 入栈 → 方法执行 → 栈帧销毁 → 出栈 → 方法调用结束
```

**💻 栈帧创建销毁示例**
```java
public class StackFrameLifecycle {
    public static void main(String[] args) {        // 栈帧1: main方法
        System.out.println("main开始");
        methodA();                                   // 调用methodA
        System.out.println("main结束");
    }  // main栈帧销毁
    
    public static void methodA() {                   // 栈帧2: methodA
        System.out.println("methodA开始"); 
        int localVar = 100;                          // 局部变量存储在局部变量表
        methodB(localVar);                           // 调用methodB
        System.out.println("methodA结束");
    }  // methodA栈帧销毁
    
    public static void methodB(int param) {          // 栈帧3: methodB
        System.out.println("methodB: " + param);
        int result = param * 2;                      // 操作数栈计算
        System.out.println("result: " + result);
    }  // methodB栈帧销毁
}

// 栈帧变化过程：
// 1. JVM启动，main栈帧创建并入栈
// 2. 调用methodA，methodA栈帧创建并入栈  
// 3. 调用methodB，methodB栈帧创建并入栈
// 4. methodB执行完毕，methodB栈帧出栈并销毁
// 5. methodA继续执行，methodA栈帧出栈并销毁
// 6. main继续执行，main栈帧出栈并销毁
```

**🎯 栈帧详细创建过程**
```java
public int calculate(int a, int b) {
    int sum = a + b;
    int product = a * b;
    return sum + product;
}

// 栈帧创建时的内存分配：
// 1. 局部变量表分配 (编译时确定大小)
//    slot 0: this (实例方法)
//    slot 1: a
//    slot 2: b  
//    slot 3: sum
//    slot 4: product
//
// 2. 操作数栈分配 (编译时确定最大深度)
//    最大深度: 2 (iadd指令需要2个操作数)
//
// 3. 动态链接信息
//    指向常量池中的方法引用
//
// 4. 返回地址信息
//    记录调用者的下一条指令地址
```

---

## 3. 🌐 线程共享区域详解


### 3.1 堆内存（Heap）：新生代、老年代、Eden、Survivor区


**🏗️ 堆内存整体结构**
```
                        Java堆内存 (Heap)
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  ┌─────────────────────────┐  ┌─────────────────────────┐   │
│  │        新生代            │  │        老年代            │   │
│  │    (Young Generation)   │  │    (Old Generation)     │   │
│  │                         │  │                         │   │
│  │  ┌────────┬─────────┐   │  │                         │   │
│  │  │ Eden   │Survivor │   │  │     长期存活对象         │   │
│  │  │  区    │   区    │   │  │     大对象              │   │
│  │  │        │ S0│ S1 │   │  │     晋升的对象           │   │
│  │  │        │   │    │   │  │                         │   │
│  │  └────────┴─────────┘   │  └─────────────────────────┘   │
│  └─────────────────────────┘                              │
│                                                             │
│  默认比例: 新生代:老年代 = 1:2                               │
│  Eden:Survivor0:Survivor1 = 8:1:1                         │
└─────────────────────────────────────────────────────────────┘
```

**📊 堆内存区域详细对比**

| 区域 | **大小比例** | **存储对象** | **GC频率** | **GC算法** |
|------|-------------|-------------|-----------|-----------|
| 🌱 **Eden区** | `80% 新生代` | `新创建的对象` | `非常频繁` | `复制算法` |
| 🔄 **Survivor0** | `10% 新生代` | `第一次GC存活对象` | `频繁` | `复制算法` |
| 🔄 **Survivor1** | `10% 新生代` | `轮换存储存活对象` | `频繁` | `复制算法` |
| 🏛️ **老年代** | `66% 堆内存` | `长期存活、大对象` | `较少` | `标记-清除/整理` |

**💻 对象分配流程示例**
```java
public class HeapAllocationExample {
    public static void main(String[] args) {
        // 1. 新对象首先在Eden区分配
        Object obj1 = new Object();          // Eden区
        String str1 = new String("Hello");   // Eden区
        
        // 2. Eden区满时触发Minor GC
        for (int i = 0; i < 100000; i++) {
            Object temp = new Object();      // 大量对象填满Eden
        }
        // 此时触发Minor GC：
        // - 存活对象 → Survivor0
        // - 死亡对象 → 被回收
        
        // 3. 再次分配
        Object obj2 = new Object();          // 新的Eden区
        
        // 4. 大对象可能直接进入老年代
        byte[] bigArray = new byte[1024 * 1024 * 10];  // 10MB大对象
        // 如果超过-XX:PretenureSizeThreshold，直接进入老年代
        
        // 5. 长期存活对象晋升到老年代
        // 对象在Survivor区经历多次GC后 → 老年代
    }
}
```

**🔄 Minor GC的对象移动过程**
```
GC前的状态：
Eden区: [obj1, obj2, obj3, obj4, ...]  (满了)
S0区:   [oldObj1, oldObj2]            (上次GC的存活对象)  
S1区:   []                            (空的)
老年代: [veryOldObj1, veryOldObj2]

Minor GC执行：
1. 标记Eden区和S0区的存活对象
2. 将存活对象复制到S1区
3. 清空Eden区和S0区
4. 年龄达到阈值的对象晋升到老年代

GC后的状态：
Eden区: []                            (清空)
S0区:   []                            (清空)
S1区:   [obj2, obj4, oldObj1]        (存活对象)
老年代: [veryOldObj1, veryOldObj2, oldObj2]  (晋升对象)
```

### 3.2 方法区（Method Area）：永久代 vs 元空间（Metaspace）


**📚 方法区的核心职责**
```
方法区 (Method Area) 存储内容：
✅ 类的元数据信息 (类名、父类、接口、访问标志等)
✅ 方法的字节码指令
✅ 字段信息 (名称、类型、访问标志等)  
✅ 运行时常量池
✅ 静态变量 (Java 8+移到堆中)
✅ 即时编译后的代码缓存
```

**🔄 永久代到元空间的演进**

**Java 7及之前：永久代 (PermGen)**
```
永久代特点：
┌─────────────────────────────────┐
│           永久代                │
│        (PermGen Space)         │
│  ┌─────────────────────────────┐ │
│  │      类元数据               │ │
│  │   • Class信息              │ │  
│  │   • Method字节码           │ │
│  │   • Field信息              │ │
│  └─────────────────────────────┘ │
│  ┌─────────────────────────────┐ │
│  │    字符串常量池              │ │
│  │   • "Hello World"          │ │
│  │   • intern()字符串         │ │
│  └─────────────────────────────┘ │
│  ┌─────────────────────────────┐ │
│  │     静态变量                │ │
│  │   • static int count       │ │
│  │   • static final String    │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘

问题：
❌ 大小固定，容易OutOfMemoryError
❌ 难以调优，PermSize参数设置困难
❌ GC效率低，Full GC才回收
```

**Java 8+：元空间 (Metaspace)**
```
元空间特点：
┌─────────────────────────────────┐
│          元空间                  │
│        (Metaspace)              │
│     使用本地内存(Native Memory)   │
│  ┌─────────────────────────────┐ │
│  │      类元数据               │ │
│  │   • Class信息              │ │
│  │   • Method字节码           │ │  
│  │   • Field信息              │ │
│  │   • 运行时常量池            │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│            堆内存                │
│  ┌─────────────────────────────┐ │
│  │    字符串常量池              │ │ ← 迁移过来
│  │   • "Hello World"          │ │
│  │   • intern()字符串         │ │
│  └─────────────────────────────┘ │
│  ┌─────────────────────────────┐ │
│  │     静态变量                │ │ ← 迁移过来  
│  │   • static int count       │ │
│  │   • static final String    │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘

优势：
✅ 动态扩展，不易OutOfMemoryError
✅ 更好的GC策略
✅ 与操作系统内存管理集成
```

**💻 元空间使用示例**
```java
// 验证元空间和堆内存的分配
public class MetaspaceExample {
    private static String staticStr = "Static String";  // 堆内存
    private static final String CONSTANT = "Constant";  // 堆内存
    
    public void method() {
        // 方法字节码存储在元空间
        String localStr = "Local";                       // 堆内存
        String internStr = new String("Intern").intern(); // 堆内存
    }
    
    public static void main(String[] args) {
        // 类元数据存储在元空间
        Class<?> clazz = MetaspaceExample.class;
        
        // 验证字符串常量池在堆中
        String str1 = "Hello";
        String str2 = "Hello";
        System.out.println(str1 == str2);  // true，共享常量池
        
        // JVM参数设置元空间
        // -XX:MetaspaceSize=64m       初始元空间大小
        // -XX:MaxMetaspaceSize=256m   最大元空间大小
        // -XX:+UseCompressedOops      压缩普通对象指针
    }
}
```

### 3.3 直接内存（Direct Memory）：堆外内存、NIO的使用


**🎯 直接内存的概念**
```
直接内存 (Direct Memory)：
• 定义：不属于JVM规范定义的内存区域
• 位置：操作系统的本地内存，JVM堆外内存
• 管理：不受JVM堆大小限制，但受本机总内存限制
• 用途：NIO操作、避免Java堆和Native堆之间的数据复制
```

**📊 堆内存 vs 直接内存对比**

| 对比项 | **堆内存** | **直接内存** |
|-------|-----------|-------------|
| 🏠 **内存位置** | `JVM堆内` | `操作系统本地内存` |
| 🔧 **分配方式** | `new关键字` | `ByteBuffer.allocateDirect()` |
| 🗑️ **GC管理** | `自动回收` | `需要手动释放或Full GC触发` |
| ⚡ **访问速度** | `较快` | `非常快（无需拷贝）` |
| 💾 **大小限制** | `-Xmx参数限制` | `本机物理内存限制` |
| 🔄 **数据拷贝** | `需要拷贝到native内存` | `直接操作，无需拷贝` |

**💻 直接内存使用示例**
```java
import java.nio.ByteBuffer;

public class DirectMemoryExample {
    public static void main(String[] args) {
        // 1. 堆内存分配（传统方式）
        ByteBuffer heapBuffer = ByteBuffer.allocate(1024);
        System.out.println("堆内存Buffer: " + heapBuffer.isDirect());  // false
        
        // 2. 直接内存分配
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        System.out.println("直接内存Buffer: " + directBuffer.isDirect());  // true
        
        // 3. 性能对比示例
        long startTime, endTime;
        byte[] data = new byte[1024];
        
        // 堆内存写入测试
        startTime = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            heapBuffer.clear();
            heapBuffer.put(data);
        }
        endTime = System.nanoTime();
        System.out.println("堆内存耗时: " + (endTime - startTime) + "ns");
        
        // 直接内存写入测试
        startTime = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            directBuffer.clear();
            directBuffer.put(data);
        }
        endTime = System.nanoTime();
        System.out.println("直接内存耗时: " + (endTime - startTime) + "ns");
        
        // 4. 手动释放直接内存（JDK 9+）
        // ((DirectBuffer) directBuffer).cleaner().clean();
    }
}
```

**🔄 NIO中直接内存的优势**
```java
// 传统IO vs NIO的内存使用对比
public class NIODirectMemoryAdvantage {
    
    // 传统IO：多次内存拷贝
    public void traditionIO() throws IOException {
        FileInputStream fis = new FileInputStream("file.txt");
        byte[] buffer = new byte[1024];
        
        // 数据流向：
        // 磁盘 → 内核缓冲区 → JVM堆内存 → 内核缓冲区 → 网络
        //       拷贝1次      拷贝2次      拷贝3次
        
        fis.read(buffer);  // 磁盘到堆内存
        // 发送数据需要再次拷贝到内核缓冲区
    }
    
    // NIO：减少内存拷贝
    public void nioDirectMemory() throws IOException {
        FileChannel fileChannel = FileChannel.open(Paths.get("file.txt"));
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        
        // 数据流向：
        // 磁盘 → 内核缓冲区 → 直接内存 → 网络
        //       拷贝1次      无需拷贝（直接DMA传输）
        
        fileChannel.read(directBuffer);  // 磁盘到直接内存
        // 发送时可以直接DMA传输，无需额外拷贝
    }
}
```

### 3.4 TLAB（线程本地分配缓冲）机制


**🎯 TLAB的核心概念**
```
TLAB (Thread Local Allocation Buffer)：
• 定义：为每个线程在Eden区预分配的私有内存区域
• 目的：避免多线程在堆内存分配时的同步开销
• 大小：默认占Eden区的1%，可以通过JVM参数调整
• 生命周期：线程结束时回收
```

**🔄 TLAB工作机制**
```
线程对象分配流程：

1. 尝试在当前线程的TLAB中分配
   ↓
2. TLAB空间足够？
   ├─ YES → 在TLAB中分配（无锁，快速）
   └─ NO → 3
   ↓
3. TLAB剩余空间能否容纳当前对象？
   ├─ YES → 申请新的TLAB
   └─ NO → 4  
   ↓
4. 在Eden区共享空间分配（需要同步）
```

**💻 TLAB使用示例**
```java
public class TLABExample {
    public static void main(String[] args) throws InterruptedException {
        // 创建多个线程并发分配对象
        Thread[] threads = new Thread[10];
        
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                // 每个线程都有自己的TLAB
                for (int j = 0; j < 100000; j++) {
                    // 小对象优先在TLAB中分配，无需同步
                    Object obj = new Object();
                    String str = new String("test" + j);
                    
                    // TLAB分配过程：
                    // 1. 检查当前线程的TLAB是否有足够空间
                    // 2. 有空间：直接分配（快速路径）
                    // 3. 无空间：申请新TLAB或回退到Eden共享区
                }
            });
        }
        
        // 启动所有线程
        for (Thread thread : threads) {
            thread.start();
        }
        
        // 等待所有线程完成
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("多线程对象分配完成");
    }
}

// JVM参数配置TLAB：
// -XX:+UseTLAB                启用TLAB（默认开启）
// -XX:TLABSize=64k           设置TLAB大小
// -XX:TLABWasteTargetPercent=1  设置TLAB占Eden区的百分比
// -XX:+PrintTLAB             打印TLAB信息
```

### 3.5 各区域的内存溢出场景和原因


**⚠️ 内存溢出类型总览**

**溢出类型1：Java heap space**
```java
// 堆内存溢出示例
public class HeapOOMExample {
    static class OOMObject {
        // 每个对象大约占用64字节
    }
    
    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        
        while (true) {
            // 不断创建对象，且保持引用
            list.add(new OOMObject());
            // 最终导致：java.lang.OutOfMemoryError: Java heap space
        }
    }
}

// 解决方案：
// 1. 增加堆内存：-Xmx2g
// 2. 检查内存泄漏：使用MAT分析heap dump
// 3. 优化代码：及时释放不需要的对象引用
```

**溢出类型2：Metaspace**
```java
// 元空间溢出示例（Java 8+）
public class MetaspaceOOMExample {
    public static void main(String[] args) {
        while (true) {
            // 动态生成类，每个类都会在元空间占用内存
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(Object.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                public Object intercept(Object obj, Method method, 
                                      Object[] args, MethodProxy proxy) {
                    return proxy.invokeSuper(obj, args);
                }
            });
            enhancer.create();
            // 最终导致：java.lang.OutOfMemoryError: Metaspace
        }
    }
}

// 解决方案：
// 1. 增加元空间：-XX:MaxMetaspaceSize=512m
// 2. 避免类加载器泄漏
// 3. 合理使用动态代理和字节码生成
```

**溢出类型3：Direct buffer memory**
```java
// 直接内存溢出示例
public class DirectMemoryOOMExample {
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) {
        List<ByteBuffer> list = new ArrayList<>();
        
        while (true) {
            // 不断分配直接内存
            ByteBuffer buffer = ByteBuffer.allocateDirect(_1MB);
            list.add(buffer);
            // 最终导致：java.lang.OutOfMemoryError: Direct buffer memory
        }
    }
}

// 解决方案：
// 1. 增加直接内存：-XX:MaxDirectMemorySize=1g
// 2. 及时释放DirectByteBuffer
// 3. 监控直接内存使用情况
```

**📊 内存溢出问题诊断表**

| 溢出类型 | **典型错误信息** | **主要原因** | **排查工具** |
|---------|-----------------|-------------|-------------|
| 🔴 **Heap OOM** | `Java heap space` | `内存泄漏、对象过多` | `jmap、MAT、jstat` |
| 🔴 **Metaspace OOM** | `Metaspace` | `类加载过多、类加载器泄漏` | `jstat -gc、jcmd` |
| 🔴 **Direct Memory OOM** | `Direct buffer memory` | `DirectByteBuffer未释放` | `JProfiler、NMT` |
| 🔴 **Stack OOM** | `unable to create native thread` | `线程过多、栈空间不足` | `jstack、系统监控` |

**🔧 内存溢出预防策略**
```java
// 1. 合理的JVM参数设置
// -Xms2g -Xmx2g                    堆内存设置
// -XX:MetaspaceSize=256m           元空间设置  
// -XX:MaxDirectMemorySize=1g       直接内存设置
// -Xss256k                         栈大小设置

// 2. 内存使用最佳实践
public class MemoryBestPractice {
    public void preventOOM() {
        // ✅ 及时释放大对象引用
        List<Object> list = new ArrayList<>();
        // ... 使用list
        list.clear();  // 清空引用
        list = null;   // 释放list本身
        
        // ✅ 使用对象池避免频繁创建
        // ObjectPool<ExpensiveObject> pool = new ObjectPool<>();
        
        // ✅ 监控内存使用情况
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        long used = heapUsage.getUsed();
        long max = heapUsage.getMax();
        
        if (used > max * 0.8) {
            System.gc();  // 建议垃圾回收
        }
    }
}
```

---

**核心记忆要点**：
- JVM内存分为线程共享（堆、方法区）和线程私有（栈、PC、本地方法栈）区域
- 堆内存分为新生代（Eden+Survivor）和老年代，对象根据年龄分代管理
- Java 8+用元空间替代永久代，字符串常量池迁移到堆中
- 直接内存位于JVM外，NIO操作可避免数据拷贝提升性能
- 各种OOM需要针对性分析和解决，合理设置JVM参数很重要