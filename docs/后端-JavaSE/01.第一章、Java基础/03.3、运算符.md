---
title: 3、运算符
---
## 📚 目录

1. [算术运算符](#1-算术运算符arithmetic)
2. [关系运算符](#2-关系运算符relational)
3. [逻辑运算符](#3-逻辑运算符logical)
4. [位运算符](#4-位运算符bitwise)
5. [赋值运算符](#5-赋值运算符assignment)
6. [自增自减运算符](#6-自增自减运算符incrementdecrement)
7. [三元运算符](#7-三元运算符ternary)
8. [实例运算符](#8-实例运算符instanceof)
9. [运算符优先级](#9-运算符优先级)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🔢 算术运算符（Arithmetic）


### 1.1 基本算术运算


**🔸 运算符概览**

| 运算符 | 作用 | 示例 | 结果 | 说明 |
|--------|------|------|------|------|
| `+` | 加法 | `5 + 3` | `8` | 数值相加 |
| `-` | 减法 | `10 - 4` | `6` | 数值相减 |
| `*` | 乘法 | `6 * 3` | `18` | 数值相乘 |
| `/` | 除法 | `10 / 2` | `5` | **整数除法截取整数部分** |
| `%` | 取模 | `10 % 3` | `1` | 返回除法的余数 |

### 1.2 除法运算特殊性


```
整数除法 vs 浮点除法：

整数除法：10 / 3 = 3     (舍弃小数部分)
浮点除法：10.0 / 3 = 3.333...

关键理解：
• 两个整数相除 → 结果为整数
• 至少一个浮点数 → 结果为浮点数
```

### 1.3 代码示例


```java
public class ArithmeticDemo {
    public static void main(String[] args) {
        int a = 10, b = 3;
        System.out.println("加法: " + (a + b)); // 输出: 13
        System.out.println("减法: " + (a - b)); // 输出: 7
        System.out.println("乘法: " + (a * b)); // 输出: 30
        System.out.println("整数除法: " + (a / b)); // 输出: 3
        System.out.println("浮点除法: " + (10.0 / 3)); // 输出: 3.333...
        System.out.println("取模: " + (a % b)); // 输出: 1
    }
}
```

---

## 2. ⚖️ 关系运算符（Relational）


### 2.1 比较运算符


**🔸 运算符概览**

| 运算符 | 作用 | 示例 | 结果 | 返回类型 |
|--------|------|------|------|----------|
| `==` | 等于 | `5 == 5` | `true` | `boolean` |
| `!=` | 不等于 | `10 != 4` | `true` | `boolean` |
| `>` | 大于 | `6 > 3` | `true` | `boolean` |
| `<` | 小于 | `2 < 5` | `true` | `boolean` |
| `>=` | 大于等于 | `7 >= 7` | `true` | `boolean` |
| `<=` | 小于等于 | `4 <= 6` | `true` | `boolean` |

### 2.2 注意事项


```
重要提醒：
✅ 关系运算符结果始终为 boolean 类型
✅ 常用于条件判断语句中（if、while等）
⚠️  对象比较需要使用 equals() 方法
⚠️  浮点数比较需要考虑精度问题
```

### 2.3 代码示例


```java
public class RelationalDemo {
    public static void main(String[] args) {
        int a = 10, b = 20;
        System.out.println(a == b);  // false
        System.out.println(a != b);  // true
        System.out.println(a > b);   // false
        System.out.println(a < b);   // true
        System.out.println(a >= 10); // true
        System.out.println(b <= 15); // false
    }
}
```

---

## 3. 🔗 逻辑运算符（Logical）


### 3.1 布尔逻辑运算


**🔸 运算符概览**

| 运算符 | 作用 | 示例 | 结果 | 特性 |
|--------|------|------|------|------|
| `&&` | 逻辑AND（并且） | `(true && false)` | `false` | **短路运算** |
| `\|\|` | 逻辑OR（或） | `(true \|\| false)` | `true` | **短路运算** |
| `!` | 逻辑NOT（非） | `!(true)` | `false` | 一元运算符 |

### 3.2 短路运算机制


```
短路运算原理：

AND运算 (&&)：
true && ?   → 继续计算右侧
false && ?  → 直接返回false，不计算右侧

OR运算 (||)：
true || ?   → 直接返回true，不计算右侧  
false || ?  → 继续计算右侧

应用场景：
if (obj != null && obj.method()) { ... }
// 先检查非空，避免空指针异常
```

### 3.3 逻辑运算真值表


```
AND (&&) 真值表：
A     | B     | A && B
------|-------|-------
true  | true  | true
true  | false | false
false | true  | false
false | false | false

OR (||) 真值表：
A     | B     | A || B
------|-------|-------
true  | true  | true
true  | false | true
false | true  | true
false | false | false

NOT (!) 真值表：
A     | !A
------|----
true  | false
false | true
```

### 3.4 代码示例


```java
public class LogicalDemo {
    public static void main(String[] args) {
        boolean a = true, b = false;
        System.out.println(a && b);  // false
        System.out.println(a || b);  // true
        System.out.println(!a);      // false
    }
}
```

---

## 4. 🎯 位运算符（Bitwise）


### 4.1 位操作运算符


**🔸 运算符概览**

| 运算符 | 作用 | 示例 | 结果 | 二进制演示 |
|--------|------|------|------|------------|
| `&` | 按位AND | `5 & 3` | `1` | `0101 & 0011 → 0001` |
| `\|` | 按位OR | `5 \| 3` | `7` | `0101 \| 0011 → 0111` |
| `^` | 按位XOR（异或） | `5 ^ 3` | `6` | `0101 ^ 0011 → 0110` |
| `~` | 按位取反 | `~5` | `-6` | 取反所有位 |
| `<<` | 左移 | `5 << 2` | `20` | `0101 → 10100` |
| `>>` | 右移（带符号） | `5 >> 1` | `2` | `0101 → 0010` |
| `>>>` | 右移（无符号） | `-5 >>> 1` | `2147483645` | 高位补零 |

### 4.2 位运算详解


**🔸 基本位运算规则**

```
按位AND (&)：两位都为1时结果为1
0 & 0 = 0    1 & 0 = 0
0 & 1 = 0    1 & 1 = 1

按位OR (|)：至少一位为1时结果为1
0 | 0 = 0    1 | 0 = 1
0 | 1 = 1    1 | 1 = 1

按位XOR (^)：两位不同时结果为1
0 ^ 0 = 0    1 ^ 0 = 1
0 ^ 1 = 1    1 ^ 1 = 0
```

**🔸 移位运算规则**

```
左移 (<<)：向左移动n位，右侧补0
相当于：数值 × 2^n

右移 (>>)：向右移动n位，左侧补符号位
正数补0，负数补1

无符号右移 (>>>)：向右移动n位，左侧始终补0
```

### 4.3 位运算应用场景


```
实际应用：
• 权限控制：使用位掩码表示多个权限
• 性能优化：位运算比除法模运算更快
• 数据压缩：多个布尔值存储在一个整数中
• 加密算法：XOR运算用于简单加密

示例：权限控制
READ = 1    (001)
WRITE = 2   (010)  
EXEC = 4    (100)

用户权限：READ | WRITE = 3 (011)
检查权限：(permission & READ) != 0
```

### 4.4 代码示例


```java
public class BitwiseDemo {
    public static void main(String[] args) {
        int a = 5, b = 3;
        System.out.println("AND: " + (a & b));  // 1
        System.out.println("OR: " + (a | b));   // 7
        System.out.println("XOR: " + (a ^ b));  // 6
        System.out.println("取反: " + (~a));    // -6
        System.out.println("左移: " + (a << 1)); // 10
        System.out.println("右移: " + (a >> 1)); // 2
    }
}
```

---

## 5. 📝 赋值运算符（Assignment）


### 5.1 赋值运算符概览


**🔸 基本赋值与复合赋值**

| 运算符 | 作用 | 示例 | 等价形式 |
|--------|------|------|----------|
| `=` | 赋值 | `x = 10` | - |
| `+=` | 加后赋值 | `x += 5` | `x = x + 5` |
| `-=` | 减后赋值 | `x -= 3` | `x = x - 3` |
| `*=` | 乘后赋值 | `x *= 2` | `x = x * 2` |
| `/=` | 除后赋值 | `x /= 4` | `x = x / 4` |
| `%=` | 取模后赋值 | `x %= 2` | `x = x % 2` |

**🔸 位运算赋值**

| 运算符 | 作用 | 示例 | 等价形式 |
|--------|------|------|----------|
| `&=` | 按位与后赋值 | `x &= 3` | `x = x & 3` |
| `\|=` | 按位或后赋值 | `x \|= 2` | `x = x \| 2` |
| `^=` | 按位异或后赋值 | `x ^= 1` | `x = x ^ 1` |
| `<<=` | 左移后赋值 | `x <<= 2` | `x = x << 2` |
| `>>=` | 右移后赋值 | `x >>= 1` | `x = x >> 1` |
| `>>>=` | 无符号右移后赋值 | `x >>>= 1` | `x = x >>> 1` |

### 5.2 赋值运算特点


```
关键特性：
✅ 赋值运算符具有返回值（被赋的值）
✅ 支持连续赋值：a = b = c = 10
✅ 复合赋值运算符更简洁高效
⚠️  赋值运算符结合性为从右到左
```

### 5.3 代码示例


```java
public class AssignmentDemo {
    public static void main(String[] args) {
        int x = 10;
        x += 5;  // x = 15
        x *= 2;  // x = 30
        x >>= 1; // x = 15
        System.out.println("最终 x 值: " + x); // 输出 15
    }
}
```

---

## 6. 🔄 自增自减运算符（Increment/Decrement）


### 6.1 自增自减概览


**🔸 运算符类型**

| 运算符 | 作用 | 示例 | 执行顺序 |
|--------|------|------|----------|
| `x++` | 后置自增 | `int y = x++` | 先返回`x`，再`x = x + 1` |
| `x--` | 后置自减 | `int y = x--` | 先返回`x`，再`x = x - 1` |
| `++x` | 前置自增 | `int y = ++x` | 先`x = x + 1`，再返回`x` |
| `--x` | 前置自减 | `int y = --x` | 先`x = x - 1`，再返回`x` |

### 6.2 前置与后置区别


```
执行机制对比：

前置自增 (++x)：
1. 先执行 x = x + 1
2. 再返回新的 x 值
3. 表达式值为新值

后置自增 (x++)：
1. 先记录 x 的当前值
2. 执行 x = x + 1  
3. 返回记录的旧值
4. 表达式值为旧值

记忆技巧：
前置：符号在前，先运算
后置：符号在后，后运算
```

### 6.3 使用场景分析


```
单独使用时（无区别）：
x++;     // 等价于
++x;     // x = x + 1

赋值表达式中（有区别）：
int a = 5;
int b = a++;  // b = 5, a = 6
int c = ++a;  // c = 7, a = 7

循环中的常见用法：
for (int i = 0; i < 10; i++) { }    // 后置更常见
for (int i = 0; i < 10; ++i) { }    // 前置效率稍高
```

### 6.4 代码示例


```java
public class IncrementDemo {
    public static void main(String[] args) {
        int x = 5;
        System.out.println(x++);  // 输出 5（先返回 x，再 +1）
        System.out.println(x);    // 输出 6（x 已加 1）

        int y = 5;
        System.out.println(++y);  // 输出 6（先加 1，再返回）
    }
}
```

---

## 7. ❓ 三元运算符（Ternary）


### 7.1 条件运算符


**🔸 基本语法**

| 语法结构 | 说明 |
|----------|------|
| `条件 ? 表达式1 : 表达式2` | 如果条件为`true`，返回表达式1，否则返回表达式2 |

```java
变量 = (条件) ? 表达式1 : 表达式2;
```

### 7.2 三元运算符特点


```
核心特性：
✅ 是Java中唯一的三元运算符
✅ 可以替代简单的if-else语句
✅ 表达式1和表达式2的类型要兼容
✅ 整个表达式有返回值

使用场景：
• 简单的条件赋值
• 方法参数中的条件选择
• 避免重复代码

注意事项：
⚠️  不宜嵌套使用（影响可读性）
⚠️  两个表达式类型必须兼容
⚠️  复杂逻辑建议使用if-else
```

### 7.3 应用示例


```
常见用法：

1. 求最值：
int max = (a > b) ? a : b;

2. 奇偶判断：
String type = (n % 2 == 0) ? "偶数" : "奇数";

3. 空值处理：
String result = (str != null) ? str : "默认值";

4. 嵌套使用（不推荐）：
int result = (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
```

### 7.4 代码示例


```java
public class TernaryDemo {
    public static void main(String[] args) {
        int a = 10, b = 20;
        int max = (a > b) ? a : b;  // 判断最大值
        System.out.println("最大值: " + max); // 输出 20

        String result = (a % 2 == 0) ? "偶数" : "奇数";
        System.out.println("a 的类型: " + result); // 输出 偶数
    }
}
```

---

## 8. 🏷️ 实例运算符（Instanceof）


### 8.1 类型检查运算符


**🔸 基本语法**

| 语法结构 | 说明 | 返回类型 |
|----------|------|----------|
| `对象 instanceof 类型` | 检查对象是否为指定类型的实例 | `boolean` |

### 8.2 instanceof运算规则


```
判断规则：
✅ 对象是该类的实例 → true
✅ 对象是该类子类的实例 → true  
✅ 对象实现了该接口 → true
❌ 对象为null → false
❌ 类型不匹配 → false

继承关系中的instanceof：
        Animal
          ↑
         Dog
         
Dog dog = new Dog();
dog instanceof Dog     → true
dog instanceof Animal  → true
dog instanceof Object  → true
```

### 8.3 使用场景


```
主要应用：
• 类型转换前的安全检查
• 多态中的类型判断
• 接口实现的验证
• 避免ClassCastException

安全转换模式：
if (obj instanceof String) {
    String str = (String) obj;
    // 安全使用str
}
```

### 8.4 代码示例


```java
class Animal {}
class Dog extends Animal {}

public class InstanceofDemo {
    public static void main(String[] args) {
        Animal a = new Dog();
        System.out.println(a instanceof Dog);   // true
        System.out.println(a instanceof Animal); // true
        System.out.println(a instanceof String); // false
    }
}
```

---

## 9. 🎯 运算符优先级


### 9.1 优先级完整表


**🔸 从高到低排列**

| 优先级 | 运算符类型 | 运算符 | 结合方向 |
|-------|-----------|------|---------|
| 1 | 后缀 | `expr++`, `expr--` | 从左到右 |
| 2 | 一元 | `++expr`, `--expr`, `+`, `-`, `!`, `~` | 从右到左 |
| 3 | 乘性 | `*`, `/`, `%` | 从左到右 |
| 4 | 加性 | `+`, `-` | 从左到右 |
| 5 | 移位 | `<<`, `>>`, `>>>` | 从左到右 |
| 6 | 关系 | `<`, `<=`, `>`, `>=` | 从左到右 |
| 7 | 实例 | `instanceof` | 从左到右 |
| 8 | 相等 | `==`, `!=` | 从左到右 |
| 9 | 按位与 | `&` | 从左到右 |
| 10 | 按位异或 | `^` | 从左到右 |
| 11 | 按位或 | `\|` | 从左到右 |
| 12 | 逻辑与 | `&&` | 从左到右 |
| 13 | 逻辑或 | `\|\|` | 从左到右 |
| 14 | 条件 | `?:` | 从右到左 |
| 15 | 赋值 | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `\|=`, `<<=`, `>>=`, `>>>=` | 从右到左 |

### 9.2 结合方向说明


```
结合方向定义：

从左到右（Left-to-Right）：
a + b + c  →  (a + b) + c
优先级相同时，先计算左侧运算

从右到左（Right-to-Left）：
a = b = c  →  a = (b = c)  
赋值运算从右向左依次执行
```

### 9.3 优先级记忆技巧


```
记忆口诀：
"一单乘加移关等，位与异或位或逻，条件赋值优先低"

分类记忆：
🔸 算术运算：*, /, % 高于 +, -
🔸 比较运算：关系运算 高于 相等运算
🔸 逻辑运算：&& 高于 ||
🔸 赋值运算：优先级最低
🔸 括号运算：优先级最高

实践建议：
✅ 复杂表达式使用括号明确优先级
✅ 提高代码可读性和维护性
✅ 避免依赖复杂的优先级记忆
```

### 9.4 优先级实例


```java
// 表达式：2 + 3 * 4 > 10 && 15 / 3 == 5
// 计算过程：
// 1. 3 * 4 = 12       (乘法优先)
// 2. 2 + 12 = 14      (加法)  
// 3. 15 / 3 = 5       (除法优先)
// 4. 14 > 10 = true   (关系运算)
// 5. 5 == 5 = true    (相等运算)
// 6. true && true = true (逻辑与)

// 建议使用括号：
((2 + (3 * 4)) > 10) && ((15 / 3) == 5)
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 算术运算：+, -, *, /, % 基础数学运算
🔸 关系运算：==, !=, >, <, >=, <= 比较运算，返回boolean
🔸 逻辑运算：&&, ||, ! 布尔逻辑，支持短路运算
🔸 位运算：&, |, ^, ~, <<, >>, >>> 二进制位操作
🔸 赋值运算：=, +=, -=, *=, /=, %= 等复合赋值
🔸 自增自减：++, -- 前置后置的区别
🔸 三元运算：?: 简化的条件表达式
🔸 instanceof：类型检查，避免转换异常
```

### 10.2 关键理解要点


**🔹 整数除法的特殊性**
```
重点理解：
• 整数 / 整数 = 整数（舍弃小数）
• 至少一个浮点数 → 浮点结果
• 取模运算 % 获取余数
```

**🔹 短路运算的重要性**
```
实际应用价值：
• && 运算：false && ? → 直接false
• || 运算：true || ? → 直接true  
• 避免空指针异常：obj != null && obj.method()
• 提高程序执行效率
```

**🔹 前置与后置自增的区别**
```
核心差异：
• 前置++x：先运算，后返回
• 后置x++：先返回，后运算
• 单独使用无区别，表达式中有差异
```

**🔹 位运算的实用性**
```
高效应用：
• 权限控制：位掩码技术
• 性能优化：位运算比除法快
• 数据压缩：多个布尔值打包
• 加密算法：XOR运算应用
```

### 10.3 实际编程应用


**🎯 运算符选择指导**
```
场景选择：
• 简单条件：使用三元运算符 ?:
• 复杂逻辑：使用if-else语句
• 类型检查：instanceof + 强制转换
• 性能要求：考虑位运算优化
• 安全编程：利用短路运算避免异常
```

**🔧 代码优化技巧**
```
最佳实践：
✅ 使用复合赋值运算符（简洁高效）
✅ 合理利用短路运算（安全性）
✅ 复杂表达式加括号（可读性）
✅ 避免过度依赖运算符优先级
✅ instanceof检查后再强制转换
```

**⚠️ 常见陷阱避免**
```
注意事项：
• 浮点数相等比较精度问题
• 自增运算符在表达式中的使用
• 位运算符与逻辑运算符的混淆
• 赋值运算符 = 与相等运算符 == 的误用
• 运算符优先级导致的逻辑错误
```

**核心记忆**：
- 算术关系逻辑位，赋值自增三元实例
- 优先级别要牢记，括号明确最保险
- 短路运算很重要，前后自增要分清
- 位运算高效用，类型检查保安全