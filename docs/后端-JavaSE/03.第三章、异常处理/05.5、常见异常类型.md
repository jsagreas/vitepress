---
title: 5、常见异常类型
---
## 📚 目录

1. [运行时异常](#1-运行时异常)
2. [编译时异常](#2-编译时异常)
3. [错误类型](#3-错误类型)
4. [异常类层次结构](#4-异常类层次结构)
5. [异常处理最佳实践](#5-异常处理最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔥 运行时异常（Unchecked Exception）


### 1.1 运行时异常特征


**🔸 核心特点**
```
继承关系：继承自 RuntimeException
编译检查：编译器不强制处理
产生原因：多为逻辑错误或程序员失误
处理方式：可选择捕获，也可不处理
运行结果：未捕获时程序崩溃
```

### 1.2 常见运行时异常详解


#### 💥 NullPointerException（空指针异常）


**🔸 异常说明**：访问 null 对象的属性或方法

```java
// 典型场景1：未初始化对象
String str = null;
System.out.println(str.length());  // 抛出 NullPointerException

// 典型场景2：方法返回null
public String getName() {
    return null;  // 可能返回null
}
String name = getName();
System.out.println(name.toUpperCase());  // 潜在NPE

// 典型场景3：数组元素为null
String[] arr = new String[3];  // 默认都是null
System.out.println(arr[0].length());  // NPE
```

**⚡ 预防措施**
```java
// 防护性编程
if (str != null) {
    System.out.println(str.length());
}

// 使用Optional（Java 8+）
Optional<String> optional = Optional.ofNullable(getName());
optional.ifPresent(s -> System.out.println(s.length()));
```

#### 📊 ArrayIndexOutOfBoundsException（数组越界）


**🔸 异常说明**：访问数组中不存在的索引

```java
// 典型越界场景
int[] arr = {1, 2, 3};
System.out.println(arr[3]);    // 越界，索引应为 0~2
System.out.println(arr[-1]);   // 负索引越界

// 字符串越界
String str = "Hello";
char c = str.charAt(10);       // 字符串长度只有5
```

**⚡ 安全访问**
```java
// 边界检查
if (index >= 0 && index < arr.length) {
    System.out.println(arr[index]);
}

// 使用增强for循环
for (int value : arr) {
    System.out.println(value);  // 避免索引操作
}
```

#### 🔢 NumberFormatException（数字格式异常）


**🔸 异常说明**：字符串转数字失败

```java
// 格式错误的字符串
String s1 = "abc";
int num1 = Integer.parseInt(s1);  // 抛出 NumberFormatException

String s2 = "12.5";
int num2 = Integer.parseInt(s2);  // 包含小数点

String s3 = "";
int num3 = Integer.parseInt(s3);  // 空字符串
```

**⚡ 安全转换**
```java
// 预检查
public static boolean isNumeric(String str) {
    return str.matches("-?\\d+");
}

// 使用异常处理
try {
    int num = Integer.parseInt(str);
    return num;
} catch (NumberFormatException e) {
    return 0;  // 默认值
}
```

#### 🔄 ClassCastException（类型转换异常）


**🔸 异常说明**：强制类型转换失败

```java
// 错误的强制转换
Object obj = "Hello";
Integer num = (Integer) obj;  // 抛出 ClassCastException

// 集合中的类型转换
List list = new ArrayList();
list.add("String");
list.add(123);
String str = (String) list.get(1);  // 第二个元素是Integer
```

**⚡ 安全转换**
```java
// 使用instanceof检查
if (obj instanceof Integer) {
    Integer num = (Integer) obj;
}

// 使用泛型避免类型错误
List<String> list = new ArrayList<String>();
```

#### ⚠️ IllegalArgumentException（非法参数异常）


**🔸 异常说明**：方法接收到非法参数

```java
// 参数超出有效范围
Thread t = new Thread();
t.setPriority(100);  // 优先级必须在 1~10 之间

// 字符串方法的非法参数
String str = "Hello";
String sub = str.substring(-1, 3);  // 起始索引不能为负
```

### 1.3 运行时异常对比表


| 异常类型 | **触发条件** | **常见场景** | **预防方法** |
|---------|------------|-------------|-------------|
| 🔸 **NullPointerException** | `对象为null时调用方法` | `未初始化对象、方法返回null` | `null检查、Optional` |
| 🔸 **ArrayIndexOutOfBoundsException** | `数组索引超出范围` | `循环边界错误、动态索引` | `边界检查、增强for循环` |
| 🔸 **NumberFormatException** | `字符串无法转为数字` | `用户输入、配置解析` | `格式预检查、异常捕获` |
| 🔸 **ClassCastException** | `类型强转失败` | `Object转具体类型` | `instanceof检查、泛型` |
| 🔸 **IllegalArgumentException** | `方法参数不合法` | `参数验证失败` | `参数校验、文档说明` |

---

## 2. 📋 编译时异常（Checked Exception）


### 2.1 编译时异常特征


**🔸 核心特点**
```
继承关系：继承自 Exception（但不是RuntimeException）
编译检查：编译器强制处理（try-catch 或 throws）
产生原因：多为外部资源/环境相关错误
处理方式：必须显式处理
设计理念：可预期的异常情况
```

### 2.2 常见编译时异常详解


#### 📁 IOException（IO异常）


**🔸 异常说明**：文件或输入输出流操作出错

```java
// 文件读取异常 - 必须处理
try {
    FileReader fr = new FileReader("nonexistent.txt");  
    // 编译器强制要求处理IOException
} catch (IOException e) {
    System.out.println("文件读取失败：" + e.getMessage());
}

// 网络IO异常
try {
    URL url = new URL("http://example.com");
    BufferedReader reader = new BufferedReader(
        new InputStreamReader(url.openStream())
    );
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 🔍 FileNotFoundException（文件未找到）


**🔸 异常说明**：尝试访问不存在的文件

```java
// 文件不存在的处理
try {
    FileInputStream fis = new FileInputStream("abc.txt");
} catch (FileNotFoundException e) {
    System.out.println("文件不存在：" + e.getMessage());
    // 可以创建默认文件或提示用户
}

// 更完整的文件处理
File file = new File("data.txt");
if (file.exists()) {
    try {
        FileReader fr = new FileReader(file);
        // 处理文件内容
    } catch (IOException e) {
        e.printStackTrace();
    }
} else {
    System.out.println("文件不存在，创建默认文件");
}
```

#### 🗄️ SQLException（数据库异常）


**🔸 异常说明**：数据库访问、SQL语法错误

```java
// 数据库连接异常
try {
    Connection conn = DriverManager.getConnection(
        "jdbc:mysql://localhost:3306/test", 
        "user", 
        "password"
    );
} catch (SQLException e) {
    System.out.println("数据库连接失败：" + e.getMessage());
}

// SQL执行异常
try {
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM users");
} catch (SQLException e) {
    System.out.println("SQL执行错误：" + e.getMessage());
}
```

#### 📅 ParseException（解析异常）


**🔸 异常说明**：日期格式解析失败

```java
// 日期解析异常
try {
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    Date date = sdf.parse("2025/01/01");  // 格式不符
} catch (ParseException e) {
    System.out.println("日期格式错误：" + e.getMessage());
}

// 更安全的日期处理（Java 8+）
try {
    LocalDate date = LocalDate.parse("2025-01-01");
} catch (DateTimeParseException e) {
    System.out.println("日期解析失败：" + e.getMessage());
}
```

#### 🧵 InterruptedException（线程中断异常）


**🔸 异常说明**：线程在等待或睡眠状态被中断

```java
// 线程睡眠必须处理中断异常
try {
    Thread.sleep(1000);  // 必须 try-catch InterruptedException
} catch (InterruptedException e) {
    System.out.println("线程被中断");
    Thread.currentThread().interrupt();  // 重新设置中断状态
}

// 等待其他线程完成
try {
    Thread t = new Thread(() -> {
        // 执行耗时任务
    });
    t.start();
    t.join();  // 等待线程结束，可能被中断
} catch (InterruptedException e) {
    e.printStackTrace();
}
```

### 2.3 编译时异常处理策略


```
处理方式选择：

1. try-catch 处理：
   ✅ 能够合理处理异常
   ✅ 异常不应该向上传播
   ✅ 有默认处理逻辑

2. throws 声明：
   ✅ 当前方法无法处理
   ✅ 调用者更适合处理
   ✅ 中间层方法透传

3. 混合处理：
   ✅ 记录日志后重新抛出
   ✅ 转换为运行时异常
   ✅ 包装为业务异常
```

---

## 3. ❌ 错误类型（Error）


### 3.1 错误特征


**🔸 Error核心特点**
```
继承关系：继承自 Error
严重程度：严重错误，不能或不应被捕获
产生原因：通常与系统、虚拟机有关
处理建议：程序应该终止，而不是试图恢复
设计理念：表示系统级的严重问题
```

### 3.2 常见错误类型


#### 💾 OutOfMemoryError（内存溢出）


**🔸 错误说明**：堆内存耗尽

```java
// 堆内存溢出示例
public class MemoryTest {
    public static void main(String[] args) {
        // 试图分配过大数组
        int[] arr = new int[Integer.MAX_VALUE];  // OOM
        
        // 无限创建对象
        List<String> list = new ArrayList<>();
        while (true) {
            list.add("Memory Leak " + System.currentTimeMillis());
        }
    }
}
```

**🔧 内存溢出类型**
```
堆内存溢出：java.lang.OutOfMemoryError: Java heap space
方法区溢出：java.lang.OutOfMemoryError: Metaspace  
直接内存溢出：java.lang.OutOfMemoryError: Direct buffer memory
```

#### 📚 StackOverflowError（栈溢出）


**🔸 错误说明**：方法递归过深，栈空间耗尽

```java
// 无限递归导致栈溢出
public class StackTest {
    public void recurse() {
        recurse();  // 无限递归，无出口条件
    }
    
    public static void main(String[] args) {
        new StackTest().recurse();  // StackOverflowError
    }
}

// 相互递归也会导致栈溢出
public void methodA() {
    methodB();
}

public void methodB() {
    methodA();  // 相互调用
}
```

### 3.3 Error vs Exception 对比


| 特征 | **Error** | **Exception** |
|------|----------|--------------|
| 🔸 **严重程度** | `系统级严重错误` | `程序级可处理异常` |
| 🔸 **是否可捕获** | `不建议捕获` | `可以也应该捕获` |
| 🔸 **产生原因** | `虚拟机、系统问题` | `程序逻辑、外部资源` |
| 🔸 **处理策略** | `程序终止` | `异常处理、程序继续` |
| 🔸 **典型代表** | `OOM、StackOverflow` | `IOException、NPE` |

---

## 4. 🌳 异常类层次结构


### 4.1 完整异常体系图


```
                    Throwable (所有异常的根类)
                   /                    \
               Error                   Exception
          (系统级错误)                (程序级异常)
           /        \                  /           \
    OutOfMemory  StackOverflow   RuntimeException  其他Exception
    Error        Error          (运行时异常)       (编译时异常)
                                /     |     \           |
                           NPE   AIOOBE  CCE      IOException
                                               SQLException
                                               ParseException
```

### 4.2 异常继承关系详解


**🔸 Throwable（根类）**
```java
// Throwable是所有异常和错误的超类
public class Throwable {
    private String message;           // 异常消息
    private Throwable cause;         // 异常原因
    private StackTraceElement[] stackTrace;  // 堆栈跟踪
    
    // 核心方法
    public String getMessage()       // 获取异常消息
    public void printStackTrace()    // 打印堆栈跟踪
    public Throwable getCause()     // 获取异常原因
}
```

**🔸 分类规则**
```
Error分支：
├── VirtualMachineError (虚拟机错误)
│   ├── OutOfMemoryError
│   └── StackOverflowError
├── LinkageError (链接错误)
└── AWTError (图形界面错误)

Exception分支：
├── RuntimeException (运行时异常)
│   ├── NullPointerException
│   ├── ArrayIndexOutOfBoundsException  
│   ├── ClassCastException
│   ├── NumberFormatException
│   └── IllegalArgumentException
└── 编译时异常
    ├── IOException
    │   └── FileNotFoundException
    ├── SQLException
    ├── ParseException
    └── InterruptedException
```

### 4.3 异常分类记忆口诀


```
🎯 分类记忆：
Throwable根上分两支，Error错误Exception异
Error严重不要抓，系统崩溃程序炸
Exception分两类，运行编译要分开
RuntimeException编译过，运行出错才爆发
其他Exception编译管，不处理就不让过
```

---

## 5. 💡 异常处理最佳实践


### 5.1 异常处理原则


**🔸 核心原则**
```
1. 早发现：尽早检测异常条件
2. 早处理：在合适的层级处理异常
3. 不忽略：不要吞掉异常
4. 有意义：提供有用的错误信息
5. 日志记录：记录异常便于调试
```

### 5.2 最佳实践示例


```java
// ✅ 良好的异常处理
public User getUserById(Long id) {
    if (id == null || id <= 0) {
        throw new IllegalArgumentException("用户ID不能为空或负数");
    }
    
    try {
        return userRepository.findById(id);
    } catch (DataAccessException e) {
        logger.error("查询用户失败，ID: {}", id, e);
        throw new ServiceException("用户查询失败", e);
    }
}

// ❌ 错误的异常处理
public User getUserById(Long id) {
    try {
        return userRepository.findById(id);
    } catch (Exception e) {
        // 错误1：捕获过于宽泛
        // 错误2：吞掉异常，不处理
        return null;  // 错误3：返回null而不是抛出异常
    }
}
```

### 5.3 异常处理模式


**🔸 异常转换模式**
```java
// 将底层异常转换为业务异常
public void saveUser(User user) {
    try {
        userRepository.save(user);
    } catch (SQLException e) {
        if (e.getErrorCode() == 1062) {  // MySQL重复键错误
            throw new UserAlreadyExistsException("用户已存在");
        }
        throw new DataAccessException("数据保存失败", e);
    }
}
```

**🔸 资源清理模式**
```java
// try-with-resources 自动资源管理
public String readFile(String filename) throws IOException {
    try (BufferedReader reader = Files.newBufferedReader(Paths.get(filename))) {
        return reader.lines()
                    .collect(Collectors.joining("\n"));
    }  // 自动关闭资源
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 异常分类：Error、运行时异常、编译时异常三大类
🔸 处理要求：编译时异常必须处理，运行时异常可选处理
🔸 继承关系：Throwable → Error/Exception → 具体异常类
🔸 处理方式：try-catch捕获、throws声明、finally清理
🔸 最佳实践：合理分层处理、提供有意义信息、记录日志
```

### 6.2 关键理解要点


**🔹 为什么要区分编译时和运行时异常**
```
设计哲学：
- 编译时异常：可预期的外部环境问题，强制处理
- 运行时异常：程序逻辑错误，应该修复代码而非捕获
- Error：系统级严重问题，程序无法恢复

实际效果：
- 提高代码健壮性
- 明确异常处理责任
- 避免异常被忽略
```

**🔹 异常处理的性能考虑**
```
性能影响：
- 异常创建成本高（堆栈跟踪）
- 不要用异常控制正常流程
- 频繁异常会影响性能

优化策略：
- 预检查避免异常
- 合理的异常粒度
- 避免在循环中处理异常
```

### 6.3 实际应用指导


**🔹 异常处理层次**
```
表示层（Controller）：
- 捕获并转换为用户友好信息
- 记录用户操作日志
- 返回统一的错误响应

业务层（Service）：
- 处理业务逻辑异常
- 事务回滚处理
- 转换为业务异常

数据层（DAO）：
- 处理数据访问异常
- 连接池异常处理
- SQL异常转换
```

**🔹 异常设计建议**
```
自定义异常：
- 继承合适的异常基类
- 提供有意义的异常信息
- 包含错误码便于处理

异常文档：
- 在方法注释中说明可能的异常
- 提供异常处理示例
- 说明异常的业务含义
```

**核心记忆口诀**：
```
异常三大类，Error别理睬
编译时必处理，运行时可不理
NPE最常见，空指针要检验
数组别越界，类型转换要小心
IO文件SQLException，编译不过关
记录日志很重要，异常处理有技巧
```