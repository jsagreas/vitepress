---
title: 4、自定义异常类
---
## 📚 目录

1. [自定义编译时异常](#1-自定义编译时异常)
2. [自定义运行时异常](#2-自定义运行时异常)
3. [带错误码的自定义异常](#3-带错误码的自定义异常)
4. [异常链构造](#4-异常链构造)
5. [自定义异常标准](#5-自定义异常标准)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 自定义编译时异常


### 1.1 编译时异常特点


**🔸 核心定义**
```
编译时异常（Checked Exception）：
- 继承自 Exception 类
- 编译器强制处理（throws 或 try-catch）
- 必须显式声明或捕获
- 用于可预期的异常情况
```

**💡 异常继承体系**
```
                     Throwable
                    /         \
            Exception           Error
           /         \             \
   IOException    RuntimeException  OutOfMemoryError
   SQLException   (运行时异常)        StackOverflowError
   (编译时异常)
```

### 1.2 自定义编译时异常实现


**🔧 基础实现**
```java
// 自定义异常类
public class AgeTooSmallException extends Exception {
    public AgeTooSmallException(String message) {
        super(message);
    }
}

// 业务使用
public class UserService {
    public void register(int age) throws AgeTooSmallException {
        if (age < 18) {
            throw new AgeTooSmallException("未满 18 岁禁止注册！");
        }
        System.out.println("注册成功");
    }

    public static void main(String[] args) {
        try {
            new UserService().register(16);
        } catch (AgeTooSmallException e) {
            System.out.println("捕获异常：" + e.getMessage());
        }
    }
}
```

**⚡ 使用场景分析**
```
适用场景：
✅ 用户输入验证（年龄、邮箱格式等）
✅ 业务规则校验（库存不足、权限检查等）
✅ 外部依赖调用（文件读取、网络请求等）
✅ 配置参数校验

强制处理的好处：
• 提高代码健壮性
• 强制开发者考虑异常情况
• 明确异常处理责任
```

---

## 2. ⚡ 自定义运行时异常


### 2.1 运行时异常特点


**🔸 核心定义**
```
运行时异常（Unchecked Exception）：
- 继承自 RuntimeException 类
- 编译器不强制处理
- 可选择性捕获处理
- 用于编程错误或逻辑错误
```

### 2.2 自定义运行时异常实现


**🔧 基础实现**
```java
public class InvalidUsernameException extends RuntimeException {
    public InvalidUsernameException(String message) {
        super(message);
    }
}

// 业务使用
public class LoginService {
    public void login(String username) {
        if (username == null || username.isEmpty()) {
            throw new InvalidUsernameException("用户名不能为空！");
        }
        System.out.println("登录成功");
    }

    public static void main(String[] args) {
        new LoginService().login("");  // 运行时抛异常，不强制捕获
    }
}
```

### 2.3 编译时异常 vs 运行时异常对比


| **特性** | **编译时异常** | **运行时异常** |
|---------|-------------|-------------|
| **继承关系** | `extends Exception` | `extends RuntimeException` |
| **编译器检查** | `强制处理` | `可选处理` |
| **处理方式** | `throws 或 try-catch` | `可选 try-catch` |
| **使用场景** | `可预期的异常` | `编程错误` |
| **示例** | `IOException, SQLException` | `NullPointerException, IllegalArgumentException` |

**🎯 选择指导原则**
```
选择编译时异常：
• 调用者能够合理恢复的异常
• 业务流程中的正常分支
• 外部依赖的可能失败

选择运行时异常：
• 编程错误导致的异常
• 调用者难以恢复的异常
• 违反API契约的调用
```

---

## 3. 🏷️ 带错误码的自定义异常


### 3.1 错误码异常的优势


**🔸 为什么需要错误码**
```
业务价值：
• 便于前端展示具体错误信息
• 支持国际化错误消息
• 便于系统监控和统计
• 提供统一的错误处理规范
```

### 3.2 带错误码异常实现


**🔧 标准实现**
```java
public class BusinessException extends RuntimeException {
    private int code;

    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }

    public int getCode() {
        return code;
    }
    
    @Override
    public String toString() {
        return "BusinessException{code=" + code + ", message='" + getMessage() + "'}";
    }
}

// 错误码常量定义
public class ErrorCode {
    public static final int INVALID_PARAM = 4001;
    public static final int UNAUTHORIZED = 4003;
    public static final int RESOURCE_NOT_FOUND = 4004;
    public static final int INTERNAL_ERROR = 5001;
}

// 业务使用
public class OrderService {
    public void submitOrder(String product) {
        if (product == null) {
            throw new BusinessException(ErrorCode.INVALID_PARAM, "商品不能为空");
        }
        if (product.isEmpty()) {
            throw new BusinessException(ErrorCode.INVALID_PARAM, "商品名称不能为空");
        }
        System.out.println("订单提交成功");
    }

    public static void main(String[] args) {
        try {
            new OrderService().submitOrder(null);
        } catch (BusinessException e) {
            System.out.println("错误码：" + e.getCode());
            System.out.println("错误信息：" + e.getMessage());
        }
    }
}
```

**📊 错误码设计规范**
```
错误码分类设计：
┌─────────────────────────────────────┐
│          错误码规范                  │
├─────────────────────────────────────┤
│ 1xxx: 信息提示                       │
│ 2xxx: 成功响应                       │
│ 4xxx: 客户端错误                     │
│   ├─ 4001: 参数错误                 │
│   ├─ 4003: 权限不足                 │
│   └─ 4004: 资源不存在               │
│ 5xxx: 服务器错误                     │
│   ├─ 5001: 内部错误                 │
│   └─ 5002: 外部服务异常             │
└─────────────────────────────────────┘
```

---

## 4. 🔗 异常链构造


### 4.1 异常链的作用


**🔸 核心概念**
```
异常链（Exception Chaining）：
- 保留原始异常信息
- 提供完整的异常调用栈
- 便于问题排查和调试
- 避免异常信息丢失
```

### 4.2 异常链实现


**🔧 标准实现**
```java
public class FileProcessingException extends Exception {
    public FileProcessingException(String message, Throwable cause) {
        super(message, cause);  // 包装原始异常
    }
    
    public FileProcessingException(String message) {
        super(message);
    }
}

// 业务使用
import java.nio.file.*;
import java.io.IOException;

public class FileService {
    public void readFile(String path) throws FileProcessingException {
        try {
            Files.readAllLines(Path.of(path));
            System.out.println("文件读取成功");
        } catch (IOException e) {
            // 包装原始异常，保留异常链
            throw new FileProcessingException("读取文件失败：" + path, e);
        }
    }

    public static void main(String[] args) {
        try {
            new FileService().readFile("/nonexistent/file.txt");
        } catch (FileProcessingException e) {
            System.out.println("业务异常：" + e.getMessage());
            System.out.println("原始异常：" + e.getCause().getClass().getSimpleName());
            e.printStackTrace(); // 打印完整异常链
        }
    }
}
```

**📋 异常链传播示例**
```
异常传播路径：
┌─────────────────────────────────────┐
│           调用链                     │
├─────────────────────────────────────┤
│ main()                              │
│   └─ readFile()                     │
│       └─ Files.readAllLines()       │
│           └─ IOException (原始)      │
│       └─ FileProcessingException     │
│           └─ cause: IOException      │
│   └─ catch FileProcessingException   │
└─────────────────────────────────────┘
```

---

## 5. 📋 自定义异常标准


### 5.1 标准构造器模式


**🔧 完整构造器实现**
```java
public class MyCustomException extends Exception {

    // 无参构造器
    public MyCustomException() {
        super();
    }

    // 消息构造器
    public MyCustomException(String message) {
        super(message);
    }

    // 原因构造器
    public MyCustomException(Throwable cause) {
        super(cause);
    }

    // 消息+原因构造器
    public MyCustomException(String message, Throwable cause) {
        super(message, cause);
    }
    
    // 完整构造器（Java 7+）
    public MyCustomException(String message, Throwable cause, 
                            boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

### 5.2 构造器使用场景


| **使用场景** | **推荐构造器** | **示例** |
|-------------|---------------|---------|
| **自己抛出异常 + 提示信息** | `MyCustomException(String message)` | `throw new MyCustomException("用户不存在")` |
| **捕获底层异常 + 封装** | `MyCustomException(String message, Throwable cause)` | `new MyCustomException("处理失败", ioException)` |
| **纯转发异常** | `MyCustomException(Throwable cause)` | `new MyCustomException(sqlException)` |
| **默认异常** | `MyCustomException()` | `throw new MyCustomException()` |

### 5.3 自定义异常最佳实践


**✅ 设计原则**
```java
// 1. 异常类命名规范
public class UserNotFoundException extends RuntimeException {
    // 类名应该以 Exception 结尾，见名知意
}

// 2. 提供详细的异常信息
public class ValidationException extends RuntimeException {
    private final String field;
    private final Object value;
    
    public ValidationException(String field, Object value, String message) {
        super(String.format("字段 '%s' 的值 '%s' 验证失败：%s", field, value, message));
        this.field = field;
        this.value = value;
    }
    
    public String getField() { return field; }
    public Object getValue() { return value; }
}

// 3. 异常分层设计
public abstract class BaseBusinessException extends RuntimeException {
    protected final int code;
    
    public BaseBusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
    
    public int getCode() { return code; }
}

public class UserBusinessException extends BaseBusinessException {
    public UserBusinessException(String message) {
        super(4001, message);
    }
}

public class OrderBusinessException extends BaseBusinessException {
    public OrderBusinessException(String message) {
        super(4002, message);
    }
}
```

**🎯 异常处理策略**
```
异常处理决策树：
                    发生异常
                       │
                是否可以恢复？
               ╱             ╲
            是                否
            │                │
      记录日志并恢复      是否是编程错误？
            │            ╱           ╲
         正常流程        是             否
                        │             │
                  RuntimeException  Exception
                        │             │
                   修复代码        强制处理
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 异常分类：编译时异常 vs 运行时异常的选择原则
🔸 错误码设计：统一的错误码规范和分类体系
🔸 异常链：保留原始异常信息，便于问题排查
🔸 标准构造器：提供完整的构造器选项
🔸 最佳实践：命名规范、信息详细、分层设计
```

### 6.2 关键理解要点


**🔹 异常类型选择策略**
```
选择编译时异常的情况：
• 调用者可以合理处理和恢复
• 业务流程的正常分支情况
• 外部依赖可能出现的问题

选择运行时异常的情况：
• 编程错误或逻辑错误
• 调用者难以恢复的情况
• API使用方式错误
```

**🔹 异常信息设计原则**
```
优秀的异常信息应该包含：
• 发生什么问题（What）
• 在哪里发生（Where）
• 为什么发生（Why）
• 如何解决（How - 可选）

示例：
❌ "操作失败"
✅ "用户ID=123的订单创建失败：库存不足，当前库存=5，需要数量=10"
```

**🔹 异常处理的层次设计**
```
异常处理分层：
┌─────────────────────────────────────┐
│        表现层 (Controller)           │ ← 统一异常处理，返回错误码
├─────────────────────────────────────┤
│        业务层 (Service)              │ ← 业务异常抛出和转换
├─────────────────────────────────────┤
│        数据层 (DAO)                  │ ← 数据访问异常包装
└─────────────────────────────────────┘
```

### 6.3 实际应用价值


**🎯 工程实践**
- **Web开发**：统一的异常响应格式和错误码体系
- **微服务**：服务间异常传播和错误码标准化
- **SDK开发**：清晰的异常分类和详细的错误信息
- **系统监控**：基于异常类型和错误码的告警机制

**🔧 性能考虑**
- **异常创建成本**：避免在热点代码中频繁抛出异常
- **堆栈信息**：生产环境可考虑禁用堆栈信息提升性能
- **异常缓存**：对于固定异常可考虑使用单例模式

**核心记忆**：
- 自定义异常分编译时和运行时两大类
- 错误码让异常处理更规范更友好
- 异常链保留完整信息便于调试排查
- 标准构造器提供灵活的异常创建方式
- 优秀异常设计让系统更健壮更易维护