---
title: 3、抛出异常
---
## 📚 目录

1. [throw与throws区别对比](#1-throw与throws区别对比)
2. [throw关键字详解](#2-throw关键字详解)
3. [throws关键字详解](#3-throws关键字详解)
4. [throw与throws配合使用](#4-throw与throws配合使用)
5. [异常抛出最佳实践](#5-异常抛出最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 throw与throws区别对比


### 1.1 核心差异表


| 项目          | throw        | throws               |
|--------------|-----------------------------|--------------------------------------|
| **定义形式**  | 语句                   | 方法签名的一部分              |
| **用于位置**  | 方法体内部               | 方法头部（定义方法时）           |
| **后接内容**  | 异常对象（`new Exception(...)`） | 异常类型（类名，例如 `IOException`） |
| **数量限制**  | 每次只能抛一个异常      | 可声明多个异常类型              |
| **是否必须处理** | 编译时异常：需要 `throws` | 编译器强制检查 `checked` 异常    |

### 1.2 语法结构对比


```
throw语法格式：
┌─────────────────────────────────┐
│ throw new ExceptionType(message); │
└─────────────────────────────────┘
           ↑              ↑
       关键字         异常对象实例

throws语法格式：
┌─────────────────────────────────────────────────┐
│ public void method() throws ExceptionType1, ... │
└─────────────────────────────────────────────────┘
                        ↑              ↑
                   关键字         异常类型列表
```

---

## 2. 🎯 throw关键字详解


### 2.1 throw基本概念


**🔸 核心定义**
```
throw：主动抛出异常对象的关键字
作用：在程序执行过程中手动触发异常
位置：方法体内部的任何位置
目的：处理业务逻辑中的异常情况
```

### 2.2 throw语法与使用


**📝 基本语法**
```java
// throw：显式抛出异常对象
public void validateAge(int age) {
    if (age < 18) {
        throw new IllegalArgumentException("年龄不能小于18岁");  // 👈 实际抛出
    }
}
// 注意：必须是 Throwable 或其子类的对象，常用：throw new XXXException("信息")
```

**⚡ 常见使用场景**
```java
// 1. 参数校验
public void setScore(int score) {
    if (score < 0 || score > 100) {
        throw new IllegalArgumentException("分数必须在0-100之间");
    }
    this.score = score;
}

// 2. 业务逻辑校验
public void withdraw(double amount) {
    if (amount > balance) {
        throw new IllegalStateException("余额不足，无法提取");
    }
    balance -= amount;
}

// 3. 条件不满足
public void divide(int a, int b) {
    if (b == 0) {
        throw new ArithmeticException("除数不能为零");
    }
    return a / b;
}
```

### 2.3 throw的执行机制


**🔄 执行流程**
```
程序执行流程：
┌─────────────┐
│  正常执行    │
├─────────────┤
│  遇到throw   │ ← 异常抛出点
├─────────────┤
│  中断执行    │
├─────────────┤
│  寻找处理器   │
├─────────────┤
│ try-catch处理│ ← 异常处理
│ 或向上传播   │
└─────────────┘
```

**💡 重要特性**
```java
public void demonstrateThrow() {
    System.out.println("执行前");
    throw new RuntimeException("手动抛出异常");
    System.out.println("这行代码永远不会执行"); // 编译错误：Unreachable code
}

// 关键点：
// 1. throw语句后的代码不可达
// 2. 异常对象必须是Throwable的子类
// 3. 抛出后立即中断当前方法执行
```

---

## 3. 📋 throws关键字详解


### 3.1 throws基本概念


**🔸 核心定义**
```
throws：声明方法可能抛出异常的关键字
作用：告诉调用者这个方法可能会抛出哪些异常
位置：方法签名的一部分
目的：异常传播和编译时检查
```

> **用于方法签名处，声明该方法有可能会抛出异常，调用者必须处理（仅针对 checked 异常）**

### 3.2 throws语法与使用


**📝 基本语法**
```java
// throws：在方法签名中声明可能抛出的受检异常
public void readFile(String path) throws IOException {  // 👈 声明会抛 IOException
    FileReader reader = new FileReader(path);
}
// 用于编译时异常（checked）的声明，告诉调用者需要处理这个异常
```

**⚡ 多异常声明**
```java
// 声明多个异常类型
public void complexOperation() throws IOException, SQLException, ClassNotFoundException {
    // 可能抛出多种异常的操作
    FileReader file = new FileReader("data.txt");     // IOException
    Connection conn = getConnection();                // SQLException  
    Class.forName("com.mysql.Driver");               // ClassNotFoundException
}

// 使用父类异常简化声明
public void simplifiedOperation() throws Exception {
    // Exception是所有异常的父类，可以捕获所有checked异常
    complexOperation();
}
```

### 3.3 throws的作用机制


**🔍 编译时检查**
```java
// 编译器强制处理机制
public void readFile() throws IOException {
    // 这个方法声明可能抛出IOException
}

public void caller() {
    // 调用者必须处理异常，否则编译错误
    try {
        readFile();  // 必须用try-catch包围
    } catch (IOException e) {
        e.printStackTrace();
    }
    
    // 或者继续向上抛出
    // readFile(); // 编译错误：Unhandled exception
}
```

**📊 异常传播链**
```
异常传播示意图：
方法A() throws Exception
    ↓ 调用
方法B() throws Exception  
    ↓ 调用
方法C() throws Exception
    ↓ 实际抛出
throw new Exception()

传播路径：C → B → A → 调用者
每一层都可以选择：处理 or 继续抛出
```

---

## 4. 🤝 throw与throws配合使用


### 4.1 配合使用场景


**🔸 基本配合模式**
```java
public void test() throws Exception {
    throw new Exception("测试异常");  // 👈 实际抛出
}
```

### 4.2 完整示例分析


**💻 实际应用案例**
```java
// 银行账户操作示例
public class BankAccount {
    private double balance;
    
    // 取款方法：throws声明 + throw抛出
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount <= 0) {
            throw new IllegalArgumentException("取款金额必须大于0");
        }
        
        if (amount > balance) {
            // throw抛出自定义异常，throws在方法签名中声明
            throw new InsufficientFundsException("余额不足，当前余额：" + balance);
        }
        
        balance -= amount;
        System.out.println("取款成功，余额：" + balance);
    }
}

// 自定义异常类
class InsufficientFundsException extends Exception {
    public InsufficientFundsException(String message) {
        super(message);
    }
}
```

**🔄 调用链示例**
```java
public class BankService {
    // 业务层：继续向上抛出
    public void processWithdrawal(String accountId, double amount) 
            throws InsufficientFundsException {
        BankAccount account = findAccount(accountId);
        account.withdraw(amount);  // 可能抛出异常
    }
    
    // 控制层：最终处理异常
    public void handleWithdrawal(String accountId, double amount) {
        try {
            processWithdrawal(accountId, amount);
            System.out.println("操作成功");
        } catch (InsufficientFundsException e) {
            System.err.println("操作失败：" + e.getMessage());
        }
    }
}
```

### 4.3 throw与throws关系图


```
方法内部逻辑：
┌─────────────────────────────────────┐
│ public void method() throws XxxException {  │ ← throws声明
│                                     │
│   if (condition) {                  │
│     throw new XxxException();       │ ← throw抛出
│   }                                 │
│                                     │
│ }                                   │
└─────────────────────────────────────┘

执行关系：
throw（实际行为） → throws（对外声明） → 调用者（必须处理）
```

---

## 5. 🎯 异常抛出最佳实践


### 5.1 使用原则


**✅ 最佳实践**
```java
// 1. 抛出具体异常类型，避免泛泛的Exception
public void parseNumber(String str) throws NumberFormatException {
    if (str == null || str.trim().isEmpty()) {
        throw new NumberFormatException("输入字符串不能为空");
    }
    Integer.parseInt(str);
}

// 2. 提供有意义的异常信息
public void openFile(String filename) throws FileNotFoundException {
    File file = new File(filename);
    if (!file.exists()) {
        throw new FileNotFoundException("文件不存在：" + filename + 
            "，请检查路径是否正确");
    }
}

// 3. 在适当的层级处理异常
public class UserService {
    public User createUser(String email) throws InvalidEmailException {
        if (!isValidEmail(email)) {
            throw new InvalidEmailException("邮箱格式不正确：" + email);
        }
        return new User(email);
    }
}
```

### 5.2 异常类型选择


**📋 常用异常类型**

| 异常类型 | 使用场景 | 示例 |
|---------|---------|------|
| `IllegalArgumentException` | 参数不合法 | `throw new IllegalArgumentException("年龄不能为负数")` |
| `IllegalStateException` | 对象状态不正确 | `throw new IllegalStateException("连接已关闭")` |
| `UnsupportedOperationException` | 不支持的操作 | `throw new UnsupportedOperationException("只读列表")` |
| `NullPointerException` | 空指针异常 | `throw new NullPointerException("参数不能为null")` |

### 5.3 异常处理策略


**🔧 处理策略选择**
```java
// 策略1：立即处理
public void strategy1() {
    try {
        riskyOperation();
    } catch (Exception e) {
        logger.error("操作失败", e);
        // 立即处理，不向上传播
    }
}

// 策略2：包装后重新抛出
public void strategy2() throws BusinessException {
    try {
        riskyOperation();
    } catch (SQLException e) {
        throw new BusinessException("数据库操作失败", e);
    }
}

// 策略3：直接向上传播
public void strategy3() throws SQLException {
    riskyOperation(); // 不处理，直接向上抛出
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 throw vs throws：语句 vs 声明，抛出 vs 告知
🔸 使用位置：方法体内 vs 方法签名
🔸 后接内容：异常对象 vs 异常类型
🔸 编译检查：checked异常必须声明和处理
🔸 配合使用：throw实际抛出，throws对外声明
```

### 6.2 关键理解要点


**🔹 throw的本质**
```
作用机制：
- 创建异常对象并抛出
- 立即中断当前方法执行
- 开始异常传播流程
- 寻找匹配的异常处理器
```

**🔹 throws的价值**
```
编译时保证：
- 强制调用者处理异常
- 提高代码的健壮性
- 明确方法的异常契约
- 便于异常追踪和调试
```

**🔹 两者协作关系**
```
协作模式：
throw + throws = 完整的异常抛出机制
内部抛出 + 外部声明 = 异常传播链条
实际行为 + 编译检查 = 程序安全保障
```

### 6.3 实际应用指导


**🎯 使用场景判断**
- **参数校验**：使用 `throw new IllegalArgumentException()`
- **状态检查**：使用 `throw new IllegalStateException()`
- **业务逻辑**：使用自定义异常 + `throws`声明
- **资源操作**：使用 `throws IOException`等检查异常

**⚠️ 注意事项**
- `throw`后的代码不可达，会编译错误
- `throws`只对检查异常强制要求处理
- 异常信息要具体明确，便于调试
- 选择合适的异常类型，避免过于泛泛

**核心记忆**：
- **throw**：我要抛出异常对象（动作）
- **throws**：我可能抛出异常类型（声明）  
- **配合使用**：内部throw，外部throws，调用者处理
- **最佳实践**：具体异常、明确信息、合适层级