---
title: 9、内部类
---
## 📚 目录

1. [成员内部类](#1-成员内部类)
2. [静态内部类](#2-静态内部类)
3. [局部内部类](#3-局部内部类)
4. [匿名内部类](#4-匿名内部类)
5. [内部类类型对比](#5-内部类类型对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 👥 成员内部类


### 1.1 成员内部类基本概念


**🔸 核心定义**
```
成员内部类（Member Inner Class）：定义在另一个类的内部的类
位置：定义在外部类的非静态部分（即成员位置）
别名：非静态内部类
特点：可以访问外部类的所有成员，包括私有成员
```

### 1.2 成员内部类基本语法


```java
class Outer {
    private String outerField = "外部类字段";

    class Inner {
        public void display() {
            System.out.println(outerField);  // 可以访问外部类的私有成员
        }
    }
}
```

### 1.3 成员内部类特性详解


| **特性** | **说明** |
|---------|----------|
| **访问权限** | 成员内部类可以访问外部类的所有成员（包括私有成员） |
| **实例化** | 成员内部类的对象必须通过外部类的对象来创建 |
| **生命周期** | 内部类的生命周期与外部类的生命周期相关 |
| **可访问外部类的实例变量和方法** | 成员内部类可以直接访问外部类的实例字段和方法 |

### 1.4 成员内部类实例化


```java
// 成员内部类的实例化需要外部类的对象作为前提
class Outer {
    private String outerField = "外部类字段";

    class Inner {
        public void display() {
            System.out.println(outerField);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();            // 创建外部类对象
        Outer.Inner inner = outer.new Inner(); // 创建内部类对象
        inner.display();                      // 调用内部类方法
    }
}
```

### 1.5 成员内部类访问外部类成员


```java
// 成员内部类可以访问外部类的私有成员字段和方法
class Outer {
    private String outerField = "外部类字段";

    class Inner {
        public void display() {
            System.out.println(outerField);  // 访问外部类私有成员
        }
    }
}
```

### 1.6 成员内部类应用场景


| **实际应用场景** | **示例** | **作用** |
|----------------|----------|----------|
| **UI 事件监听处理** | `button.addActionListener(new MyListener());` | 方便处理用户交互事件 |
| **集合类中的迭代器实现** | `Iterator<String> it = list.iterator();` | 遍历集合，避免暴露内部结构 |
| **多线程中的任务封装** | `Runnable task = new MyTask();` | 封装任务逻辑，提高代码可读性 |
| **设计模式实现** | `Observer observer = new MyObserver();` | 用于观察者模式等结构化代码设计 |

---

## 2. ⚡ 静态内部类


### 2.1 静态内部类基本概念


**🔸 核心定义**
```
静态内部类（Static Inner Class）：使用static关键字修饰的内部类
特点：成员无法访问外部类的实例变量，只能访问外部类的静态成员
优势：不需要外部类实例即可创建，内存效率更高
```

### 2.2 静态内部类基本语法


```java
public class OuterClass {
   static int staticField = 10;
   int instanceField = 20;
    // 静态内部类声明
    static class StaticInnerClass {
        // 静态内部类成员和方法
    }
}

// 创建静态内部类对象的方式：通过外部类的类名来创建静态内部类实例
OuterClass.StaticInnerClass innerObj = new OuterClass.StaticInnerClass();
System.out.println("静态内部类访问外部类的静态成员: " + staticField);  // 可以访问静态成员
// System.out.println(instanceField);  // 编译错误，无法访问实例成员
```

### 2.3 静态内部类特性详解


| **特性** | **说明** |
|---------|----------|
| **静态修饰** | 静态内部类是使用 `static` 关键字修饰的，与外部类的实例无关 |
| **访问外部类成员** | 只能访问外部类的静态成员，不能访问实例成员 |
| **实例化方式** | 静态内部类可以通过外部类的类名来实例化，而不需要外部类的实例 |
| **内存分配** | 静态内部类的内存分配与外部类实例无关，它是独立的 |

### 2.4 静态内部类内存模型


```
内存分配对比：
┌─────────────────────────────────┐
│        方法区 (Method Area)      │
│  ┌─────────────────────────────┐ │
│  │    OuterClass.class         │ │
│  │  ┌─────────────────────────┐│ │
│  │  │  StaticInnerClass.class ││ │ ← 静态内部类
│  │  └─────────────────────────┘│ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘

堆内存 (Heap)
┌─────────────────────────────────┐
│  StaticInnerClass实例           │ ← 独立存在，不依赖外部类实例
└─────────────────────────────────┘
```

### 2.5 静态内部类实际应用


```java
// 单例模式的实现
public class Singleton {
    private Singleton() {}
    
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

// 作为常量类的封装
class Outer {
    static class Constants {
        static final String GREETING = "Hello, world!";
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(Outer.Constants.GREETING);  // 访问静态内部类中的常量
    }
}
```

---

## 3. 📍 局部内部类


### 3.1 局部内部类基本概念


**🔸 核心定义**
```
局部内部类（Local Inner Class）：在方法内部定义的类
作用域：只有在该方法被调用时，局部内部类才会被创建
特点：只能在定义它的方法、构造器或代码块内使用
```

### 3.2 局部内部类基本语法


```java
class Outer {
    void outerMethod() {
        class Inner {
            void display() {
                System.out.println("局部内部类");
            }
        }
        // 创建局部内部类对象
        Inner inner = new Inner();
        inner.display();
    }
}
```

### 3.3 局部内部类创建与使用


```java
// 在方法内部定义局部内部类
// 局部内部类通常在外部类的某个方法内定义，并且只能在该方法内使用。
class Outer {
    void outerMethod() {
        // 定义局部内部类
        class Inner {
            void display() {
                System.out.println("我是局部内部类！");
            }
        }

        // 创建局部内部类对象并调用方法
        Inner inner = new Inner();
        inner.display();
    }
}

// 注意：Inner 类只能在 outerMethod 方法中使用，超出该方法外部，Inner 类不可见。
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.outerMethod();  // 输出：我是局部内部类！
    }
}
```

### 3.4 访问外部方法的局部变量


```java
// 访问外部方法的局部变量
class Outer {
    void outerMethod() {
        // 注意：如果在方法内修改了 num 变量的值，编译器会提示错误，要求将变量声明为 final。
        final int num = 10;  // 局部变量必须是 final 或 effectively final
        class Inner {
            void display() {
                System.out.println("局部变量 num 的值: " + num);
            }
        }

        // 创建局部内部类对象
        Inner inner = new Inner();
        inner.display();  // 输出：局部变量 num 的值: 10
    }
}
```

### 3.5 局部内部类特性详解


| **特性** | **说明** |
|---------|----------|
| **作用范围** | 局部内部类只能在其定义的方法、构造器或代码块内访问 |
| **生命周期** | 局部内部类的实例与其所在方法或代码块的调用周期相同 |
| **访问权限** | 可以访问所在方法中的`final`或`effectively final`的局部变量和参数 |
| **无法被外部类访问** | 作用域仅限于方法内部，无法在方法外部直接访问 |
| **实例化方式** | 只能在局部类所在的代码块内创建该类的对象 |

### 3.6 局部内部类实际应用


```java
// 实现方法特定的监听器或回调：
public void processButton(final String buttonName) {
    class ButtonHandler implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println(buttonName + " was clicked");
        }
    }
    
    JButton button = new JButton(buttonName);
    button.addActionListener(new ButtonHandler());
}
```

---

## 4. 🎭 匿名内部类


### 4.1 匿名内部类基本概念


**🔸 核心定义**
```
匿名内部类（Anonymous Inner Class）：没有显式名称的内部类
特点：在创建对象的同时定义类的实现
用途：一次性使用，没有显式的类名，必须继承一个父类或实现一个接口
语法：在new表达式中直接定义类的实现
```

### 4.2 实现接口的匿名内部类


```java
// 实现接口的匿名内部类
Interface objectName = new Interface() {
    // 实现接口方法和添加新成员
};

// 使用匿名内部类实现接口
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("匿名内部类实现Runnable接口");
    }
};


// 背后的展开形式（相当于）：
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("匿名内部类实现Runnable接口");
    }
}
// 创建对象
Runnable r = new MyRunnable();
```

### 4.3 继承类的匿名内部类


```java
// 继承类的匿名内部类
BaseClass objectName = new BaseClass() {
    // 重写方法和添加新成员
};

// 使用匿名内部类继承类
Thread t = new Thread() {
    @Override
    public void run() {
        System.out.println("匿名内部类继承Thread类");
    }
};


// 背后的展开形式（相当于）：
class AnonymousThread extends Thread {
    @Override
    public void run() {
        System.out.println("匿名内部类继承Thread类");
    }
}
// 然后：
Thread t = new AnonymousThread();
```

### 4.4 匿名内部类与Lambda表达式的关系


**🔸 对比分析**
- **Java 8后**：单方法接口（函数式接口）可以用Lambda表达式替代匿名内部类
- **匿名内部类优势**：功能更强大，可以实现多个方法，添加额外字段
- **Lambda表达式优势**：更简洁，适合简单的单方法接口实现

```java
// 匿名内部类
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("匿名内部类");
    }
};

// Lambda表达式
Runnable r2 = () -> System.out.println("Lambda表达式");
```

### 4.5 匿名内部类使用场景


```
匿名内部类典型应用：
┌─────────────────────────────────┐
│  事件监听器 (Event Listeners)   │ ← GUI编程
├─────────────────────────────────┤
│  线程任务 (Thread Tasks)        │ ← 多线程编程
├─────────────────────────────────┤
│  回调函数 (Callback Functions)  │ ← 异步编程
├─────────────────────────────────┤
│  比较器 (Comparators)           │ ← 集合排序
└─────────────────────────────────┘
```

---

## 5. ⚖️ 内部类类型对比


### 5.1 四种内部类对比表


| **内部类类型** | **定义位置** | **访问外部类成员** | **实例化方式** | **使用场景** |
|-------------|------------|-----------------|--------------|------------|
| **成员内部类** | 外部类成员位置 | 可访问所有成员 | `outer.new Inner()` | 需要访问外部类实例的场景 |
| **静态内部类** | 外部类成员位置 | 只能访问静态成员 | `new Outer.Inner()` | 工具类、单例模式 |
| **局部内部类** | 方法/代码块内 | 可访问外部类成员和final局部变量 | 只能在定义的方法内创建 | 方法内临时使用 |
| **匿名内部类** | 使用时定义 | 取决于定义位置 | `new Interface(){...}` | 一次性使用，事件监听 |

### 5.2 内部类层次结构图


```
外部类 (Outer Class)
├── 成员内部类 (Member Inner Class)
│   ├── 实例字段
│   ├── 实例方法
│   └── 可访问外部类所有成员
├── 静态内部类 (Static Inner Class)
│   ├── 静态字段/方法
│   ├── 实例字段/方法
│   └── 只能访问外部类静态成员
├── 方法 (Method)
│   ├── 局部内部类 (Local Inner Class)
│   │   └── 只能访问final/effectively final变量
│   └── 匿名内部类 (Anonymous Inner Class)
│       └── 继承类或实现接口
└── 代码块 (Code Block)
    └── 局部内部类/匿名内部类
```

### 5.3 内部类选择指南


| **使用场景** | **推荐类型** | **理由** |
|-------------|------------|----------|
| **需要访问外部类实例变量** | 成员内部类 | 可以直接访问外部类所有成员 |
| **不需要访问外部类实例** | 静态内部类 | 性能更好，内存占用少 |
| **方法内临时使用** | 局部内部类 | 作用域限制，封装性好 |
| **一次性实现接口** | 匿名内部类 | 代码简洁，无需额外类名 |
| **简单函数式接口** | Lambda表达式 | 语法最简洁 |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 内部类本质：定义在类内部的类，可以访问外部类的成员
🔸 四种类型：成员内部类、静态内部类、局部内部类、匿名内部类
🔸 访问权限：不同类型对外部类成员的访问权限不同
🔸 实例化方式：各类型的创建方式和语法规则
🔸 应用场景：根据需求选择合适的内部类类型
```

### 6.2 关键理解要点


**🔹 成员内部类 vs 静态内部类**
```
成员内部类：
• 需要外部类实例才能创建
• 可以访问外部类所有成员
• 内存开销较大

静态内部类：
• 独立于外部类实例
• 只能访问外部类静态成员
• 内存效率更高，推荐使用
```

**🔹 局部内部类的变量访问**
```
final/effectively final限制：
• JDK 8之前：必须显式声明final
• JDK 8之后：编译器自动判断effectively final
• 原因：局部变量在栈中，方法结束就销毁
• 内部类对象可能存活更久，需要值拷贝
```

**🔹 匿名内部类 vs Lambda表达式**
```
匿名内部类适用：
• 需要实现多个方法
• 需要添加字段或初始化块
• 需要继承具体类

Lambda表达式适用：
• 函数式接口（只有一个抽象方法）
• 代码简洁性要求高
• 函数式编程风格
```

### 6.3 最佳实践建议


**🔧 编码规范**
- 优先使用静态内部类，除非必须访问外部类实例
- 匿名内部类不要过于复杂，超过几行建议使用具名类
- 局部内部类仅在方法内部逻辑复杂时使用
- Lambda表达式适用于简单的函数式接口

**⚡ 性能考虑**
- 静态内部类性能最优，不持有外部类引用
- 成员内部类会隐式持有外部类引用，可能导致内存泄漏
- 避免在循环中创建匿名内部类
- 合理使用final变量，减少捕获变量的开销

**🛡️ 安全注意**
- 注意成员内部类对外部类的强引用可能导致内存泄漏
- 局部内部类访问的局部变量必须是final或effectively final
- 匿名内部类中的this指向匿名类实例，不是外部类
- 避免在内部类中进行复杂的异常处理

### 6.4 内部类与设计模式


| **设计模式** | **内部类类型** | **应用说明** |
|-------------|-------------|------------|
| **单例模式** | 静态内部类 | 延迟加载，线程安全 |
| **迭代器模式** | 成员内部类 | 访问外部类集合元素 |
| **观察者模式** | 匿名内部类 | 事件监听器实现 |
| **策略模式** | 匿名内部类 | 算法动态选择 |
| **模板方法模式** | 匿名内部类 | 重写模板方法 |

**核心记忆口诀**：
- 内部类型有四种，成员静态局部匿名
- 成员访问无限制，静态只能访静态
- 局部final要记牢，匿名一次就丢掉
- 选择类型看需求，性能封装要平衡