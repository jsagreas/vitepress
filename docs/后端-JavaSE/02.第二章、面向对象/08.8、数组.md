---
title: 8、数组
---
## 📚 目录

1. [数组基本概念](#1-数组基本概念)
2. [数组的声明与创建](#2-数组的声明与创建)
3. [数组元素访问](#3-数组元素访问)
4. [数组的常见操作](#4-数组的常见操作)
5. [数组的拷贝与排序](#5-数组的拷贝与排序)
6. [数组默认值](#6-数组默认值)
7. [数组常见问题与易错点](#7-数组常见问题与易错点)
8. [数组与内存分析](#8-数组与内存分析)
9. [数组应用场景](#9-数组应用场景)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 数组基本概念


### 1.1 数组的本质特征


**🔸 核心定义**
```
数组（Array）：存储同类型多个元素的引用数据类型
特点：内存连续存储，长度固定，索引从0开始
用途：批量处理同类型数据，提高程序效率
```

### 1.2 数组概念详解


| **数组概念** | **说明** |
|-------------|----------|
| **数据类型** | 数组是一种引用数据类型，用于存储同类型多个元素 |
| **内存存储特点** | 数组中的元素在内存中是连续存储的，提高访问效率 |
| **数组长度** | 创建后长度不可变，需合理规划大小 |
| **一维数组** | 线性存储结构，元素排成一条直线，通过索引访问 |
| **二维数组** | 由多个一维数组组成，即 "数组的数组"，每个元素是一个数组引用 |
| **索引规则** | 索引从 `0` 开始，最大索引为 `length - 1` |

### 1.3 数组结构示意图


```
一维数组内存结构：
┌─────────────────────────────────┐
│  索引:  0    1    2    3    4   │
│  元素: [10] [20] [30] [40] [50] │
│  地址: 100  104  108  112  116  │
└─────────────────────────────────┘

二维数组内存结构：
         arr[0] → [1, 2, 3]
         arr[1] → [4, 5, 6]  
         arr[2] → [7, 8, 9]
            ↑
        引用数组
```

---

## 2. 📝 数组的声明与创建


### 2.1 一维数组的声明与创建


**🔸 声明一维数组**
```java
// 声明方式
数据类型[] 数组名;  
int[] arr;
String[] names;
```

**🔸 创建一维数组**
```java
// 创建数组（分配内存空间）
数组名 = new 数据类型[长度];
arr = new int[5];  // 创建长度为5的整型数组

数据类型[] 数组名 = new 数据类型[长度];
names = new String[3]; // 创建长度为3的字符串数组

// 声明 + 创建（常用写法）
int[] arr = new int[5];
```

**🔸 一维数组初始化**
```java
// 静态初始化（声明、创建和赋值一步完成）
int[] arr = {1, 2, 3, 4, 5};
String[] names = {"Tom", "Jerry", "Spike"};

// 动态初始化（只指定长度，稍后赋值）
double[] prices = new double[4];
prices[0] = 9.9;
```

### 2.2 二维数组的声明与创建


**🔸 声明二维数组**
```java
// 声明方式
数据类型[][] 数组名;   数据类型[] 数组名[];
int[][] arr;
String[][] names;
```

**🔸 创建二维数组**
```java
// 创建二维数组（分配空间）
数组名 = new 数据类型[行数][列数];
数组名 = new 数据类型[行数][];  // 仅指定行数，每行列数可以不同
数据类型[][] 数组名 = new 数据类型[行数][列数]; // 声明并创建
arr = new int[3][4]; // 3行4列的整型数组

// 声明 + 创建（常用）
int[][] arr = new int[3][4];
```

**🔸 二维数组初始化**
```java
// 静态初始化二维数组（直接赋值）
int[][] arr = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 不规则二维数组(每行列数不同)
int[][] jaggedArray = {
    {1, 2},
    {3, 4, 5},
    {6}
};

// 动态初始化（先定行，再定列）
int[][] arr = new int[3][];
arr[0] = new int[2];
arr[1] = new int[3];
arr[2] = new int[1];
// 说明：每一行可以有不同的列数（不规则二维数组）
```

---

## 3. 🔍 数组元素访问


### 3.1 一维数组访问


```java
// 访问和修改元素
int first = arr[0];
arr[2] = 10;  // 修改下标为2的元素
// 注意：访问越界（如 arr[5]）会抛出 ArrayIndexOutOfBoundsException 异常
```

### 3.2 二维数组访问


```java
// 二维数组通过【行索引】【列索引】访问元素
arr[1][2] = 10;  // 访问第2行第3列
int x = arr[0][1]; // 获取第1行第2列的值

// 获取第i行(返回一维数组)
int[] row = array[i];

// 获取行数
int rows = array.length;

// 获取特定行的列数
int cols = array[0].length; // 第一行的列数
```

### 3.3 数组搜索示例


```java
// 数组的搜索
int[] numbers = {1, 2, 3, 4, 5};
int index = Arrays.binarySearch(numbers, 3);
System.out.println("Index of 3: " + index); // 输出 2
```

---

## 4. 🛠️ 数组的常见操作


### 4.1 数组操作总览


| **操作** | **示例** | **说明** |
|---------|----------|----------|
| **遍历数组 (for)** | `for(int i=0;i<arr.length;i++) {}` | 经典 for 循环 |
| **遍历数组 (foreach)** | `for(int num : arr) {}` | 增强 for 循环，简洁 |
| **获取数组长度** | `arr.length` | `.length` 是属性，不是方法 |
| **数组赋值** | `arr[1] = 100;` | 指定索引赋值 |
| **数组拷贝** | `Arrays.copyOf(arr, arr.length)` | 深拷贝生成新数组 |
| **数组排序** | `Arrays.sort(arr)` | 排序（升序） |

### 4.2 数组遍历详解


**🔸 一维数组遍历**
```java
// 使用for循环
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}

// 使用foreach循环（增强for循环）
for (int value : array) {
    System.out.println(value);
}
```

**🔸 二维数组遍历**
```java
// 使用嵌套 for 循环遍历二维数组
for (int i = 0; i < arr.length; i++) {          // 遍历行
    for (int j = 0; j < arr[i].length; j++) {    // 遍历列
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}

// 使用增强 for 循环遍历
for (int[] row : arr) {
    for (int elem : row) {
        System.out.print(elem + " ");
    }
    System.out.println();
}
```

---

## 5. 📋 数组的拷贝与排序


### 5.1 数组扩容


> **重要概念**：Java中数组长度固定，需要扩容时通常：
> - 创建更大的新数组
> - 复制原数组元素到新数组  
> - 使用新数组替代旧数组

```java
int[] oldArray = {1, 2, 3};
int[] newArray = new int[oldArray.length * 2];
System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);
// 或使用
newArray = Arrays.copyOf(oldArray, oldArray.length * 2);
```

### 5.2 数组拷贝


**🔸 二维数组拷贝**
```java
int[][] source = {{1, 2}, {3, 4}};
int[][] target = new int[source.length][];

// 浅拷贝（仅复制引用）
for (int i = 0; i < source.length; i++) {
    target[i] = source[i];
}

// 深拷贝（复制整个数组）
for (int i = 0; i < source.length; i++) {
    target[i] = Arrays.copyOf(source[i], source[i].length);
}
```

### 5.3 数组排序


```java
// 一维数组排序
int[] scores = {85, 92, 78, 90};
Arrays.sort(scores);  // 升序排序
System.out.println(Arrays.toString(scores));  // 输出：[78, 85, 90, 92]

// 对每一行进行排序
for (int[] row : array) {
    Arrays.sort(row);
}

// 根据行的某个特征排序整个二维数组
Arrays.sort(array, Comparator.comparingInt(row -> row[0])); // 按每行第一个元素排序
```

---

## 6. 🔢 数组默认值


### 6.1 数组默认值总览


| **数据类型** | **默认值** | **说明** |
|-------------|------------|----------|
| **整型** | `0` | `byte`, `short`, `int`, `long` |
| **浮点型** | `0.0` | `float`, `double` |
| **字符型** | `'\u0000'` | 空字符 |
| **布尔型** | `false` | `boolean` |
| **引用类型** | `null` | 如 `String`、对象 |

### 6.2 默认值示意图


```
数组初始化后的默认值：
┌─────────────────────────────────┐
│ int[]    →  [0, 0, 0, 0, 0]     │
│ double[] →  [0.0, 0.0, 0.0]     │
│ boolean[] → [false, false]      │
│ String[] →  [null, null, null]  │
└─────────────────────────────────┘
```

---

## 7. ⚠️ 数组常见问题与易错点


### 7.1 一维数组易错点


| **知识点** | **说明** |
|-----------|----------|
| **数组长度固定** | 一旦创建，数组的长度不可更改，除非新建更大的数组进行替换 |
| **索引范围限制** | 索引必须在 `[0, length-1]` 范围内，否则会抛出 `ArrayIndexOutOfBoundsException` |
| **存储位置** | 数组对象存储在 **堆内存** 中，即使是基本数据类型数组 |
| **数组名的作用** | 数组变量存储的是数组对象的 **首地址**（引用），而不是数组的内容本身 |
| **length 属性** | `length` 是数组的属性，不是方法，使用时 **不能加括号 ()** |
| **默认值** | 初始化数组时未赋值的元素会有默认值：数值型为 `0`，布尔型为 `false`，引用类型为 `null` |

### 7.2 二维数组易错点


| **情况** | **问题描述** | **注意点** |
|---------|-------------|-----------|
| **未初始化子数组** | 直接访问未初始化的子数组会抛出 `NullPointerException` | 需要先分配内存 `arr[i] = new int[n];` |
| **索引访问顺序** | 访问时必须先指定行，再指定列，如 `arr[i][j]` | 不能反向访问，保证索引范围合法 |
| **不规则数组** | 不同的行可以有不同长度，如 `new int[3][]` | 遍历时需根据 `arr[i].length` 判断长度 |
| **遍历时越界问题** | 行长不一致时，`arr[i][j]` 可能超出范围 | 在循环中避免 `j >= arr[i].length` |

### 7.3 常见异常处理


```
常见数组异常：
┌─────────────────────────────────────┐
│ ArrayIndexOutOfBoundsException      │ ← 数组越界
│ NullPointerException               │ ← 空指针异常
│ NegativeArraySizeException         │ ← 负数组长度
└─────────────────────────────────────┘
```

---

## 8. 💾 数组与内存分析


### 8.1 数组内存分配过程


| **阶段** | **内容** |
|---------|----------|
| **声明数组变量** | 变量在栈区分配 |
| **创建数组对象** | 数组对象在堆区分配内存 |
| **元素赋值** | 元素在堆内存中按顺序存储 |
| **数组变量存的是引用** | 数组变量存的是堆中数组对象的地址（引用） |

### 8.2 内存结构图


```
栈内存 (Stack)              堆内存 (Heap)
┌─────────────┐            ┌─────────────────────┐
│  数组变量    │  ────────→ │  数组对象            │
│  arr        │            │  [10][20][30][40]   │
│  (引用地址)  │            │  连续内存空间        │
└─────────────┘            └─────────────────────┘

二维数组内存结构：
栈内存                     堆内存
┌─────────┐               ┌─────────────────────┐
│  arr    │ ────────────→ │ 引用数组 [ref1][ref2] │
└─────────┘               └─────────┬───────────┘
                                   │
                          ┌─────────▼──────┐ ┌─────────┐
                          │ [1][2][3]      │ │ [4][5]  │
                          │ 子数组1        │ │ 子数组2  │
                          └────────────────┘ └─────────┘
```

> **重要提示**：Java中的二维数组在内存中不一定是连续存储的，每一行可能存储在内存的不同位置

---

## 9. 🎨 数组应用场景


### 9.1 常见应用场景总览


| **应用场景** | **示例** | **作用** |
|-------------|----------|----------|
| **批量存储数据** | `int[] scores = {90, 85, 78};` | 存储大量同类数据，如成绩、价格 |
| **批量数据处理** | `Arrays.sort(arr);` | 便捷地排序、查找、过滤数据 |
| **方法参数/返回值** | `public int sum(int[] arr)` | 传递数组引用，提高代码复用性 |
| **循环处理数据** | `for(int num : arr) {}` | 遍历数据，高效执行批量操作 |
| **大量元素统计** | `arr.length` | 计算元素总数，用于分析统计 |
| **临时缓存** | `cache[i] = result;` | 存储临时计算结果，减少重复计算 |

### 9.2 实际应用示例


**🔸 成绩管理系统**
```java
// 存储学生成绩
int[] scores = {85, 92, 78, 90, 88};

// 计算平均分
int sum = 0;
for (int score : scores) {
    sum += score;
}
double average = (double) sum / scores.length;
```

**🔸 矩阵运算**
```java
// 二维数组表示矩阵
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 矩阵转置
int[][] transpose = new int[3][3];
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        transpose[j][i] = matrix[i][j];
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 数组本质：引用数据类型，存储同类型多个元素，内存连续分布
🔸 长度特性：创建后长度固定，不可改变，通过length属性获取
🔸 索引规则：从0开始，最大索引为length-1，越界会抛异常
🔸 二维数组：数组的数组，每一行可以有不同长度
🔸 内存模型：数组对象在堆内存，数组变量在栈内存存储引用
```

### 10.2 关键理解要点


**🔹 数组 vs 其他数据结构**
```
数组优势：
• 访问速度快：O(1)时间复杂度
• 内存效率高：连续存储，减少内存碎片
• 索引直接：可直接通过下标访问

数组劣势：
• 长度固定：不能动态调整大小
• 插入删除慢：需要移动大量元素
• 类型限制：只能存储同一类型数据
```

**🔹 一维数组 vs 二维数组**
```
一维数组：
• 线性结构：元素排成一条直线
• 适用场景：简单列表、队列、栈

二维数组：
• 矩阵结构：行列组织数据
• 适用场景：表格、矩阵运算、游戏地图
```

**🔹 数组初始化方式选择**
```
静态初始化：
• 适用：已知具体元素值
• 语法：int[] arr = {1, 2, 3};

动态初始化：
• 适用：只知道数组长度，稍后赋值
• 语法：int[] arr = new int[5];
```

### 10.3 最佳实践建议


**🔧 编码规范**
- 数组命名使用复数形式或具有描述性的名称
- 遍历数组优先使用增强for循环（foreach）
- 访问数组前检查索引范围，避免越界
- 二维数组遍历时注意每行长度可能不同

**⚡ 性能考虑**
- 频繁扩容操作考虑使用ArrayList等动态数组
- 大数组拷贝优先使用System.arraycopy()
- 避免在循环中重复计算数组长度
- 合理估算数组初始大小，减少内存浪费

**🛡️ 安全注意**
- 始终检查数组索引边界，防止越界异常
- 访问二维数组前确保子数组已初始化
- 数组作为方法参数时注意引用传递特性
- 使用Arrays.equals()比较数组内容，而非==

**核心记忆口诀**：
- 数组引用存堆栈，长度固定索引访
- 一维线性二维表，遍历排序很方便  
- 越界空指要小心，初始默认记心间
- 批量处理好帮手，内存连续效率高