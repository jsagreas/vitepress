---
title: 8、并发工具类
---
## 📚 目录

1. [并发工具类概述](#1-并发工具类概述)
2. [主要并发工具类体系](#2-主要并发工具类体系)
3. [核心工具类详解](#3-核心工具类详解)
4. [原子变量类](#4-原子变量类)
5. [ThreadLocal类](#5-ThreadLocal类)
6. [线程安全集合类](#6-线程安全集合类)
7. [阻塞队列体系](#7-阻塞队列体系)
8. [使用注意事项与典型区别](#8-使用注意事项与典型区别)
9. [实战场景推荐](#9-实战场景推荐)

---

## 1. 🌟 并发工具类概述


### 1.1 基本介绍


```java
Java并发工具类
├── 📦 1.1 所属包
│   ├── java.util.concurrent
│   └── java.util.concurrent.atomic
└── 🎯 1.2 设计目的
    ├── 提供更高效、更易用、更安全的线程协作与同步机制
    └── 优势（相比传统的synchronized/wait/notify）
        ├── 更强的可控性
        ├── 更好的可扩展性
        └── 更高的性能
```

### 1.2 并发工具类的价值


**💡 相比传统同步机制的优势**
```
传统同步机制的局限性
├── 🔒 synchronized
│   ├── 不可中断
│   ├── 不支持超时
│   └── 无法实现公平锁
├── 🔄 wait/notify
│   ├── 只能在同步块中使用
│   ├── 容易出现虚假唤醒
│   └── 不够灵活精确
└── ⚠️ 性能问题
    ├── 内核态切换开销大
    └── 竞争激烈时性能下降

并发工具类的改进
├── ⚡ 更高性能
│   ├── 基于CAS的无锁实现
│   └── 减少上下文切换
├── 🎛️ 更强控制力
│   ├── 支持超时、中断
│   └── 公平性策略选择
└── 🔧 更易使用
    ├── 场景化设计
    └── API更加友好
```

---

## 2. 🏗️ 主要并发工具类体系


### 2.1 完整工具类结构图


```java
java.util.concurrent
├── 🔐 Lock / ReentrantLock / ReadWriteLock    # 锁机制，提供比synchronized更灵活的锁操作
│   ├── Lock    # 锁接口，定义获取和释放锁的基本操作
│   ├── ReentrantLock   # 可重入锁，支持公平/非公平锁策略和可中断获取锁
│   └── ReadWriteLock   # 读写锁，允许多个读操作并发执行，写操作独占
│
├── ⏰ CountDownLatch   # 倒计时门闩，允许一个或多个线程等待直到计数器归零
│
├── 🚧 CyclicBarrier   # 循环栅栏，让一组线程互相等待，直到全部到达某个公共屏障点
│
├── 🎫 Semaphore   # 信号量，控制同时访问特定资源的线程数量
│
├── 🔄 Exchanger   # 交换器，允许两个线程在某个点交换对象                                 
│
├── 🎭 Phaser   # 多阶段同步器，支持更复杂的多阶段并行任务同步
│
├── 📦 BlockingQueue   # 阻塞队列，支持生产者-消费者模式
│   ├── ArrayBlockingQueue    # 基于数组的有界阻塞队列
│   ├── LinkedBlockingQueue    # 基于链表的可选有界阻塞队列
│   ├── PriorityBlockingQueue    # 支持优先级排序的无界阻塞队列
│   ├── DelayQueue   # 延迟元素队列，元素只有到期后才能被取出
│   ├── SynchronousQueue    # 无缓冲的阻塞队列，每个插入操作必须等待对应的移除操作
│   └── LinkedTransferQueue     # 链表结构的无界阻塞队列，支持transfer操作
│
├── 📊 ConcurrentHashMap / CopyOnWriteArrayList    # 线程安全的集合类
│   ├── ConcurrentHashMap    # 高并发的HashMap实现，分段锁设计
│   ├── CopyOnWriteArrayList    # 写时复制的ArrayList实现，适用于读多写少场景
│   └── ConcurrentSkipListMap    # 基于跳表的ConcurrentMap实现，有序映射
│
└── 🎯 Future / Callable / Executor     # 任务执行与管理框架
    ├── Callable   # 带返回值的任务接口，可抛出异常
    ├── Future     # 表示异步计算结果的接口，提供检查是否完成、等待和获取结果等操作
    ├── CompletableFuture     # 增强的Future，支持组合和链式操作的异步编程
    └── Executor框架      # 线程池相关
        ├── Executor      # 执行提交任务的基本接口
        ├── ExecutorService    # 扩展的任务执行服务，支持管理生命周期
        └── ScheduledExecutorService    # 支持延迟和周期任务调度的执行服务
```

### 2.2 工具类分类总览


```
按功能分类的并发工具
├── 🔐 同步控制类
│   ├── ReentrantLock - 可重入锁
│   ├── ReadWriteLock - 读写分离锁
│   ├── CountDownLatch - 倒计时门闩
│   ├── CyclicBarrier - 循环栅栏
│   ├── Semaphore - 信号量
│   └── Phaser - 多阶段同步器
├── 🔄 数据交换类
│   └── Exchanger - 线程间数据交换
├── ⚛️ 原子操作类
│   ├── AtomicInteger - 原子整数
│   ├── AtomicLong - 原子长整数
│   └── AtomicReference - 原子引用
├── 🧵 线程隔离类
│   └── ThreadLocal - 线程局部变量
├── 📦 并发集合类
│   ├── ConcurrentHashMap - 并发哈希表
│   ├── CopyOnWriteArrayList - 写时复制列表
│   └── BlockingQueue系列 - 阻塞队列
└── 🎯 任务执行类
    └── Executor框架 - 线程池体系
```

---

## 3. 🔧 核心工具类详解


### 3.1 🔐 ReentrantLock（可重入锁）


**🔸 概念说明**
```
ReentrantLock（可重入锁）：一种显式的、可重入的独占锁，属于 java.util.concurrent.locks
功能对比：类似 synchronized，但提供了更强的灵活性和控制能力
核心特性：支持尝试加锁、超时、可中断、公平性控制
```

**🏗️ 构造方法与基本使用**
```java
ReentrantLock lock = new ReentrantLock();              // 非公平锁
ReentrantLock lock = new ReentrantLock(true);          // 公平锁

// 标准使用模式：
lock.lock();
try {
    // 临界区代码
} finally {
    lock.unlock();  // 必须在finally中释放锁
}
```

**📋 常用方法详解**

| **方法** | **说明** | **使用场景** |
|---------|---------|-------------|
| **`lock()`** | 获取锁，不可中断（可能阻塞） | 标准加锁操作 |
| **`lockInterruptibly()`** | 可响应中断的获取锁方式 | 需要响应中断的场景 |
| **`tryLock()`** | 尝试加锁，获取失败立即返回 false | 避免阻塞的场景 |
| **`tryLock(timeout, unit)`** | 尝试在指定时间内获取锁 | 有超时要求的场景 |
| **`unlock()`** | 释放锁（必须在 `finally` 中调用） | 确保锁被释放 |

**💻 使用示例**
```java
public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;
    
    public void increment() {
        lock.lock();
        try {
            count++;
            System.out.println("Count: " + count);
        } finally {
            lock.unlock();
        }
    }
    
    public boolean tryIncrement() {
        if (lock.tryLock()) {
            try {
                count++;
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false;
    }
}
```

**✅ 典型应用场景**
- 精准控制临界区，处理竞争资源
- 替代 synchronized，实现中断响应、限时加锁、可重入控制
- 需要公平锁的场景

### 3.2 📖 ReadWriteLock（读写锁）


**🔸 概念说明**
```
ReadWriteLock（读写锁接口）：常用实现为 ReentrantReadWriteLock
核心特性：读线程共享，写线程互斥
性能优势：读多写少场景下极大提高并发性能
```

**🔄 读写规则**
```
读写锁规则
├── 📖 读-读：可以并发执行
├── ✍️ 写-写：互斥，不能并发
├── 📖✍️ 读-写：互斥，不能并发
└── ✍️📖 写-读：互斥，不能并发
```

**💻 使用方式**
```java
public class ReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private String data = "初始数据";
    
    // 读操作
    public String readData() {
        readLock.lock();
        try {
            // 多个线程可以同时读
            System.out.println("读取数据: " + data);
            return data;
        } finally {
            readLock.unlock();
        }
    }
    
    // 写操作
    public void writeData(String newData) {
        writeLock.lock();
        try {
            // 写操作是排他的
            this.data = newData;
            System.out.println("写入数据: " + newData);
        } finally {
            writeLock.unlock();
        }
    }
}
```

**✅ 应用场景**
- 缓存数据的并发读取与刷新
- 配置文件、热点数据等读多写少场景
- 数据字典、元数据管理

### 3.3 ⏰ CountDownLatch（倒计时门闩）


**🔸 概念说明**
```
CountDownLatch（倒计时门闩）：用于让一个或多个线程等待其他线程完成某些操作
核心特性：一次性使用，不能复用
工作原理：内部通过一个计数器实现，每 countDown() 一次减1，到0自动唤醒 await() 阻塞线程
```

**🏗️ 构造与基本方法**
```java
CountDownLatch latch = new CountDownLatch(3);  // 设置初始计数为3
```

| **方法名** | **说明** |
|-----------|---------|
| **`countDown()`** | 每调用一次，计数器减 1 |
| **`await()`** | 阻塞当前线程直到计数器归零 |
| **`await(timeout, unit)`** | 带超时的等待 |
| **`getCount()`** | 获取当前计数值 |

**💻 使用示例**
```java
public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);
        
        // 创建3个工作线程
        for (int i = 1; i <= 3; i++) {
            int taskId = i;
            new Thread(() -> {
                try {
                    Thread.sleep(1000 * taskId);  // 模拟不同的工作时间
                    System.out.println("任务" + taskId + "完成");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();  // 完成后计数减1
                }
            }).start();
        }
        
        // 主线程等待所有任务完成
        System.out.println("等待所有任务完成...");
        latch.await();
        System.out.println("所有任务已完成，开始汇总");
    }
}
```

**✅ 应用场景**
- 主线程等待所有子线程执行完再汇总结果
- 模拟并发请求统一起跑
- 多个子任务完成后合并结果

### 3.4 🚧 CyclicBarrier（循环栅栏）


**🔸 概念说明**
```
CyclicBarrier（回环栅栏）：多线程之间相互等待，直到都到达某个点后统一执行
核心特性：可复用，适合多阶段任务
附加功能：构造时可指定一个 "统一执行动作"
```

**🏗️ 构造方法**
```java
CyclicBarrier barrier = new CyclicBarrier(3);

// 或指定到达后的动作：
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("所有线程就绪，统一执行！");
});
```

**📋 常用方法**
- **`await()`**：等待其它线程到达屏障点
- **`await(timeout, unit)`**：带超时的等待
- **`getNumberWaiting()`**：获取当前等待的线程数
- **`reset()`**：重置屏障到初始状态

**💻 使用示例**
```java
public class CyclicBarrierExample {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3, () -> {
            System.out.println(">>> 所有线程都到达了屏障点，开始下一阶段！");
        });
        
        for (int i = 1; i <= 3; i++) {
            int workerId = i;
            new Thread(() -> {
                try {
                    // 第一阶段工作
                    Thread.sleep(1000 * workerId);
                    System.out.println("工作线程" + workerId + "完成第一阶段");
                    barrier.await();  // 等待其他线程
                    
                    // 第二阶段工作
                    Thread.sleep(500);
                    System.out.println("工作线程" + workerId + "完成第二阶段");
                    barrier.await();  // 再次等待
                    
                    System.out.println("工作线程" + workerId + "全部完成");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

**✅ 应用场景**
- 分阶段同步处理流程
- 并行任务协同执行后再汇总，如并行计算汇总结果
- 多人游戏中的关卡同步

### 3.5 🎫 Semaphore（信号量）


**🔸 概念说明**
```
Semaphore（信号量）：控制同时访问某资源的线程数（限流控制）
工作原理：线程获取"许可"后才能访问资源，用完要"释放许可"
应用价值：用于限制并发线程数量，类似控制访问令牌
```

**🏗️ 构造与使用**
```java
Semaphore semaphore = new Semaphore(3);  // 允许最多3个线程同时访问
```

**📋 常用方法**

| **方法名** | **说明** |
|-----------|---------|
| **`acquire()`** | 获取一个许可（无则阻塞） |
| **`release()`** | 释放一个许可 |
| **`tryAcquire()`** | 尝试获取许可，不阻塞 |
| **`availablePermits()`** | 查看剩余许可数量 |
| **`acquire(int permits)`** | 获取多个许可 |

**💻 使用示例**
```java
public class SemaphoreExample {
    private static final Semaphore semaphore = new Semaphore(3);  // 最多3个线程
    
    public static void main(String[] args) {
        for (int i = 1; i <= 6; i++) {
            int workerId = i;
            new Thread(() -> {
                try {
                    semaphore.acquire();  // 获取许可
                    System.out.println("线程" + workerId + "获得许可，开始工作");
                    Thread.sleep(2000);   // 模拟工作
                    System.out.println("线程" + workerId + "工作完成");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    semaphore.release();  // 释放许可
                    System.out.println("线程" + workerId + "释放许可");
                }
            }).start();
        }
    }
}
```

**✅ 应用场景**
- 控制数据库连接数、网络限流、接口调用并发数限制
- 资源池管理（如连接池、对象池）
- 限制同时下载的任务数

### 3.6 🔄 Exchanger（交换器）


**🔸 概念说明**
```
Exchanger（交换器）：用于两个线程之间的数据交换
工作原理：调用 exchange() 的线程将阻塞，直到另一个线程也调用 exchange()
特点：只适用于两个线程，数据交换是双向的
```

**💻 使用示例**
```java
public class ExchangerExample {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();
        
        // 生产者线程
        new Thread(() -> {
            try {
                String data = "生产者数据";
                System.out.println("生产者准备数据: " + data);
                String response = exchanger.exchange(data);
                System.out.println("生产者收到: " + response);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // 消费者线程
        new Thread(() -> {
            try {
                Thread.sleep(1000);  // 模拟处理时间
                String data = "消费者数据";
                System.out.println("消费者准备数据: " + data);
                String response = exchanger.exchange(data);
                System.out.println("消费者收到: " + response);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

**✅ 应用场景**
- 生产者消费者间批量数据交换
- 双线程对账、同步计算阶段数据交换
- 配对线程间的数据传递

### 3.7 🎭 Phaser（多阶段同步器）


**🔸 概念说明**
```
Phaser（多阶段协作控制器）：多阶段任务控制工具，支持动态线程注册/注销
功能扩展：可替代 CountDownLatch 和 CyclicBarrier
核心优势：支持参与线程数量变化的复杂任务
```

**📋 常用方法**

| **方法名** | **说明** |
|-----------|---------|
| **`arrive()`** | 当前阶段到达，非阻塞 |
| **`arriveAndAwaitAdvance()`** | 到达并阻塞，等待所有线程 |
| **`register()`** | 动态注册一个参与者 |
| **`arriveAndDeregister()`** | 到达并注销 |

**💻 使用示例**
```java
public class PhaserExample {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(3);  // 初始3个参与者
        
        for (int i = 1; i <= 3; i++) {
            int taskId = i;
            new Thread(() -> {
                // 第一阶段
                System.out.println("任务" + taskId + "完成第一阶段");
                phaser.arriveAndAwaitAdvance();  // 等待所有线程完成第一阶段
                
                // 第二阶段
                System.out.println("任务" + taskId + "完成第二阶段");
                phaser.arriveAndAwaitAdvance();  // 等待所有线程完成第二阶段
                
                // 第三阶段
                System.out.println("任务" + taskId + "完成第三阶段");
                phaser.arriveAndDeregister();  // 完成并退出
            }).start();
        }
    }
}
```

**✅ 应用场景**
- 多阶段并发任务（如多人闯关游戏、数据同步处理）
- 支持参与线程数量变化的复杂任务
- 可重复使用的多阶段屏障

---

## 4. ⚛️ 原子变量类


### 4.1 原子变量类概览


| **类名** | **用途说明** | **适用场景** |
|---------|-------------|-------------|
| **`AtomicInteger`** | 原子整型操作，线程安全替代 `int` | 计数器、累加器 |
| **`AtomicLong`** | 原子长整型操作 | 大数值计数、ID生成 |
| **`AtomicBoolean`** | 原子布尔操作 | 状态标志、开关控制 |
| **`AtomicReference<T>`** | 原子引用操作（对象） | 对象引用的原子更新 |

### 4.2 核心特性


**⚡ 技术特性**
```
原子变量类特性
├── 🔬 底层技术：基于 CAS（Compare-And-Swap）无锁机制
├── 🚀 性能优势：性能远高于同步锁
├── 🛡️ 线程安全：无需额外同步措施
└── 🎯 适用场景：高并发环境下的简单数据操作
```

**💻 使用示例**
```java
public class AtomicExample {
    private AtomicInteger counter = new AtomicInteger(0);
    private AtomicBoolean flag = new AtomicBoolean(false);
    private AtomicReference<String> reference = new AtomicReference<>("初始值");
    
    public void increment() {
        int newValue = counter.incrementAndGet();  // 原子递增
        System.out.println("计数器值: " + newValue);
    }
    
    public boolean toggle() {
        return flag.compareAndSet(false, true);  // 原子比较并设置
    }
    
    public void updateReference(String newValue) {
        String oldValue = reference.getAndSet(newValue);  // 原子获取并设置
        System.out.println("旧值: " + oldValue + ", 新值: " + newValue);
    }
}
```

---

## 5. 🧵 ThreadLocal类


### 5.1 基本概念


**🔸 ThreadLocal定义**
```
ThreadLocal：java.lang包提供的一个线程局部变量类
核心特性：每个线程在 ThreadLocal 实例中存储的是独立副本，彼此互不干扰
主要用途：线程隔离数据，解决共享变量带来的线程安全问题
```

### 5.2 工作原理深度解析


**🔬 原理机制**
```
为什么能实现隔离：
├── 🔑 共享访问：虽然所有线程访问的是同一个 ThreadLocal 对象
├── 🏠 独立存储：但每个 Thread 对象内部都有自己独立的 ThreadLocalMap 实例
├── 📦 真实存储：ThreadLocalMap 是真正存储值的地方，它作为线程的成员变量，是线程私有的
└── 🎯 键值对应：同一个 ThreadLocal 作为 key，但在不同线程的 Map 中对应不同的 value

数据访问流程：
当调用 threadLocal.get() 时，实际上是：
├── 1️⃣ 先获取当前线程 Thread.currentThread()
├── 2️⃣ 然后访问该线程的 ThreadLocalMap
├── 3️⃣ 用当前 ThreadLocal 对象作为 key 查找对应的 value
└── 4️⃣ 由于 ThreadLocalMap 是线程私有的，所以不同线程操作不会互相干扰
```

**🏠 类似"房间隔离"的比喻**
```
ThreadLocal 工作原理比喻
├── 🔑 ThreadLocal → 一把钥匙（统一的访问入口）
├── 🏠 Thread → 每个线程有自己的私人房间（ThreadLocalMap）
├── 📦 同一把钥匙 → 在不同的房间打开不同的保险箱
└── 💎 获取不同的物品 → 每个线程获取自己独有的数据
```

### 5.3 源码机制简化理解


**💻 ThreadLocal核心源码逻辑**
```java
public void set(T value) {
    // 关键点1: 获取当前线程
    Thread t = Thread.currentThread();
    
    // 关键点2: 获取当前线程的ThreadLocalMap
    ThreadLocalMap map = t.threadLocals;
    
    if (map != null) {
        // 关键点3: 使用this(当前ThreadLocal实例)作为key，存储新值
        map.set(this, value);
    } else {
        // 关键点4: 如果当前线程还没有ThreadLocalMap，则创建一个
        t.threadLocals = new ThreadLocalMap(this, value);
    }
}

public T get() {
    // 关键点1: 获取当前线程的ThreadLocalMap
    ThreadLocalMap map = Thread.currentThread().threadLocals;
    
    if (map != null) {
        // 关键点2: 使用this(当前ThreadLocal实例)作为key
        Entry e = map.getEntry(this);
        if (e != null)
            return (T)e.value;
    }
    return setInitialValue();
}
```

**🔍 核心理解**
```
ThreadLocal原理
├── 📋 内部结构
│   ├── Thread类                      # 每个线程都有一个ThreadLocalMap引用
│   ├── ThreadLocalMap                # 真正存储数据的地方(线程私有)
│   └── Entry                         # ThreadLocalMap中的节点，弱引用指向ThreadLocal
└── 🔄 数据存取过程
    ├── set(T value)                  # 将值存储到当前线程的ThreadLocalMap中
    ├── get()                         # 从当前线程的ThreadLocalMap中检索值
    └── remove()                      # 移除当前线程的ThreadLocalMap中的值

角色分工：
├── ThreadLocal → 跳板（钥匙/索引）
├── Thread → 持有私有 Map（仓库）
├── ThreadLocalMap → 真正存放数据的地方
├── key → ThreadLocal 实例（同一个）
└── value → 当前线程自己要使用的数据（互不干扰）
```

### 5.4 主要API


| **方法** | **说明** |
|---------|---------|
| **`get()`** | 获取当前线程的局部变量 |
| **`set(T value)`** | 设置当前线程的局部变量 |
| **`remove()`** | 删除当前线程中绑定的变量，防止内存泄漏 |
| **`withInitial(Supplier<T>)`** | 初始化时提供初始值（Java 8 新增） |

**💻 基本使用示例**
```java
// 创建ThreadLocal对象
ThreadLocal<Integer> threadLocalValue = new ThreadLocal<>();

// 设置值
threadLocalValue.set(42);

// 获取值
Integer value = threadLocalValue.get();

// 移除值
threadLocalValue.remove();

// 使用初始值(Java 8)
ThreadLocal<String> threadLocal = ThreadLocal.withInitial(() -> "初始值");
```

### 5.5 使用场景


| **场景** | **用途说明** |
|---------|-------------|
| **👤 用户信息上下文（如登录用户ID）** | 每个线程单独处理请求用户 |
| **🗄️ 数据库连接（如 JDBC）** | 每个线程使用自己连接，避免连接共享 |
| **📝 日志链路追踪（如 MDC）** | 线程隔离日志 traceId |
| **🏊 线程池中的变量隔离** | 避免共享变量引发混乱 |

### 5.6 内存泄漏风险与解决


**⚠️ 内存泄漏风险**
```
├── 📝 原因
│   ├── ThreadLocalMap持有ThreadLocal的弱引用
│   ├── ThreadLocalMap持有Value的强引用
│   └── 线程长生命周期(如线程池)导致Value无法释放
└── ✅ 解决方法
    ├── 手动调用remove()              # 使用完ThreadLocal后主动清理
    ├── 使用try-finally               # 确保清理代码总是被执行
    └── 考虑使用TransmittableThreadLocal # 支持值在线程池中传递
```

**💻 完整使用示例**
```java
public class ThreadLocalExample {
    // 创建ThreadLocal变量
    private static final ThreadLocal<String> userContext = new ThreadLocal<>();
    
    public static void main(String[] args) {
        // 线程1设置用户并处理
        Thread thread1 = new Thread(() -> {
            try {
                userContext.set("User-A");
                System.out.println("Thread 1: " + userContext.get());
                processUserData();
            } finally {
                userContext.remove();  // 防止内存泄漏
            }
        });
        
        // 线程2设置用户并处理
        Thread thread2 = new Thread(() -> {
            try {
                userContext.set("User-B");
                System.out.println("Thread 2: " + userContext.get());
                processUserData();
            } finally {
                userContext.remove();  // 防止内存泄漏
            }
        });
        
        thread1.start();
        thread2.start();
    }
    
    private static void processUserData() {
        System.out.println("Processing data for: " + userContext.get());
    }
}
```

### 5.7 最佳实践


```
ThreadLocal 最佳实践
├── ✅ 始终在finally块中调用remove()     # 防止内存泄漏
├── ✅ 使用static final修饰ThreadLocal对象 # 避免创建过多实例
├── ✅ 尽量使用initialValue()初始化      # 提供默认值，避免NPE
├── ✅ 考虑是否真的需要ThreadLocal       # 有时局部变量或参数传递可能更合适
└── ⚠️ 注意事项
    ├── 必须调用 remove() 清理变量（避免内存泄漏）
    ├── 不要将 ThreadLocal 定义为局部变量
    ├── 每个 ThreadLocal 实例只与当前线程数据相关
    └── 与 synchronized / volatile 不冲突，是线程隔离，不是同步机制
```

---

## 6. 📊 线程安全集合类


### 6.1 主要线程安全集合


| **类名** | **特性** | **适用场景** |
|---------|---------|-------------|
| **`ConcurrentHashMap`** | 分段锁/JDK8后为桶+红黑树，支持高并发读写 | 高并发Map操作 |
| **`CopyOnWriteArrayList`** | 写时复制，适用于读多写少场景 | 读多写少的列表 |
| **`ConcurrentLinkedQueue`** | 非阻塞队列 | 高性能队列操作 |
| **`ConcurrentSkipListMap`** | 基于跳表的有序映射 | 需要排序的并发Map |
| **`ConcurrentSkipListSet`** | 基于跳表的有序集合 | 需要排序的并发Set |

### 6.2 集合选择指南


```
线程安全集合选择策略
├── 📊 Map类型
│   ├── 高并发读写 → ConcurrentHashMap
│   ├── 需要排序 → ConcurrentSkipListMap
│   └── 读多写少 → Collections.unmodifiableMap + 重建策略
├── 📋 List类型
│   ├── 读多写少 → CopyOnWriteArrayList
│   ├── 生产消费 → BlockingQueue系列
│   └── 高并发读写 → 使用锁 + ArrayList
├── 📦 Queue类型
│   ├── 非阻塞 → ConcurrentLinkedQueue
│   ├── 阻塞队列 → BlockingQueue系列
│   └── 延迟队列 → DelayQueue
└── 🎯 Set类型
    ├── 无序集合 → ConcurrentHashMap.newKeySet()
    ├── 有序集合 → ConcurrentSkipListSet
    └── 读多写少 → CopyOnWriteArraySet
```

---

## 7. 📦 阻塞队列体系


### 7.1 阻塞队列分类


| **类名** | **特点** | **容量** | **适用场景** |
|---------|---------|---------|-------------|
| **`ArrayBlockingQueue`** | 有界数组队列 | 固定容量 | 生产消费速度相近 |
| **`LinkedBlockingQueue`** | 链表队列（默认无界） | 可配置 | 生产速度不稳定 |
| **`PriorityBlockingQueue`** | 支持任务优先级 | 无界 | 有优先级要求 |
| **`SynchronousQueue`** | 无容量，生产者直接交给消费者 | 0 | 实时交换 |
| **`DelayQueue`** | 延迟队列 | 无界 | 定时任务 |
| **`LinkedTransferQueue`** | 支持transfer操作 | 无界 | 高性能传输 |

### 7.2 阻塞队列选择指南


```
阻塞队列选择策略
├── 🎯 根据容量需求
│   ├── 固定容量控制 → ArrayBlockingQueue
│   ├── 可扩展容量 → LinkedBlockingQueue
│   └── 无缓冲直传 → SynchronousQueue
├── 🎨 根据功能需求
│   ├── 优先级处理 → PriorityBlockingQueue
│   ├── 延迟处理 → DelayQueue
│   └── 高性能传输 → LinkedTransferQueue
└── 📊 根据性能需求
    ├── 内存敏感 → ArrayBlockingQueue
    ├── 吞吐量优先 → LinkedBlockingQueue
    └── 低延迟 → SynchronousQueue
```

---

## 8. ⚠️ 使用注意事项与典型区别


### 8.1 各工具类使用注意事项


```java
ReentrantLock
├── ✅ 使用后必须调用 unlock()（建议放在 finally 中）
├── ✅ 支持可重入（同一线程可重复加锁）
├── ✅ 默认是非公平锁（可通过构造参数设置为公平）
├── ✅ tryLock() 可避免死锁风险（适合应对抢锁场景）
├── ✅ 可中断锁（lockInterruptibly()）对响应中断有用
└── ⚠️ 如果未及时释放锁，容易导致其他线程永久阻塞

ReadWriteLock
├── ✅ 读锁可共享、写锁独占
├── ⚠️ 写锁获取时会阻塞所有读线程
├── ✅ 写优先：防止读饥饿（默认）
├── ❌ 不支持锁升级（读锁→写锁），否则死锁
├── ✅ 支持锁降级（写锁→读锁，必须按顺序）
└── 🎯 适合读多写少的业务场景（如缓存）

CountDownLatch
├── ⚠️ 只能使用一次，不能重置（非复用）
├── ⚠️ countDown() 必须被调用够次数，否则 await() 阻塞永久
├── ✅ 适合主线程等待多个子线程完成任务
├── ✅ 可与线程池配合使用（如模拟并发）
└── ❌ 不可动态增减计数器

CyclicBarrier
├── ✅ 可重用：每次 all parties 到达后重置计数
├── ⚠️ 所有线程都必须调用 await() 才能继续执行
├── ✅ 构造函数可附带 barrierAction 回调
├── ⚠️ 线程未到达时被中断，会抛 BrokenBarrierException
└── ❌ 不适合线程数不固定或动态变化的场景

Semaphore
├── ✅ 控制并发访问数（类似令牌桶）
├── ⚠️ acquire() 和 release() 必须成对使用
├── ⚠️ 不释放许可会导致其他线程阻塞
├── ✅ 可用于实现限流/并发访问控制
└── ✅ permit 数量可动态设定，但不可中途改变

Exchanger
├── ⚠️ 仅适用于两个线程之间交换数据
├── ⚠️ exchange() 会阻塞，直到另一线程也调用 exchange()
├── ⚠️ 若配对失败会造成永久阻塞（可配合超时方法）
├── ✅ 数据交换是双向的：threadA <=> threadB
└── 🎯 常用于对账、数据交换、批量处理场景

Phaser
├── ✅ 可替代 CountDownLatch 和 CyclicBarrier
├── ✅ 支持多阶段同步（如多轮游戏回合）
├── ✅ 支持动态注册/注销线程（register/deregister）
├── ✅ arriveAndAwaitAdvance() 表示阶段到达+等待
├── ✅ arrive() 仅到达不等待，适合非阻塞模式
└── 🎯 适合线程数不定、分阶段任务执行的复杂并发场景
```

### 8.2 工具类特性对比


| **工具类** | **是否可复用** | **是否支持阶段** | **是否支持线程变化** | **用途概述** |
|-----------|---------------|----------------|------------------|-------------|
| **🔐 `ReentrantLock`** | ✅ | ❌ | ❌ | 可重入独占锁 |
| **📖 `ReadWriteLock`** | ✅ | ❌ | ❌ | 读写分离控制 |
| **⏰ `CountDownLatch`** | ❌ | ❌ | ❌ | 等待多个线程完成 |
| **🚧 `CyclicBarrier`** | ✅ | ✅ | ❌ | 所有线程就绪后继续 |
| **🎫 `Semaphore`** | ✅ | ❌ | ❌ | 控制并发访问资源数量 |
| **🔄 `Exchanger`** | ✅（双线程） | ❌ | ❌ | 线程间数据交换 |
| **🎭 `Phaser`** | ✅ | ✅ | ✅ | 多阶段 + 动态线程同步 |

### 8.3 性能对比分析


```
并发工具类性能特征
├── 🏆 高性能类
│   ├── AtomicXxx - 基于CAS，无锁高性能
│   ├── ConcurrentHashMap - 分段锁，读写分离
│   └── ConcurrentLinkedQueue - 无锁队列
├── ⚖️ 平衡性能类
│   ├── ReentrantLock - 显式锁，性能好于synchronized
│   ├── ReadWriteLock - 读多写少场景性能优
│   └── ThreadLocal - 线程隔离，无同步开销
└── 🐌 协调功能类
    ├── CountDownLatch - 主要用于协调，性能次要
    ├── CyclicBarrier - 线程同步工具，性能次要
    └── Phaser - 功能强大但相对复杂
```

---

## 9. 🎯 实战场景推荐


### 9.1 场景化工具选择


| **场景描述** | **推荐工具类** | **选择理由** |
|-------------|---------------|-------------|
| **🎯 主线程等待所有子任务完成** | `CountDownLatch` | 一次性等待，使用简单 |
| **🚀 多线程协同起步** | `CyclicBarrier` | 所有线程就绪后统一开始 |
| **🎫 控制并发访问资源** | `Semaphore` | 令牌机制，限流控制 |
| **🔄 两个线程交换数据** | `Exchanger` | 专为双线程数据交换设计 |
| **🎭 分阶段任务执行** | `Phaser` | 支持多阶段，动态参与者 |
| **📊 高并发安全数据结构** | `ConcurrentHashMap` | 高性能并发访问 |
| **⚛️ 无锁整型操作** | `AtomicInteger` | CAS机制，性能优异 |
| **🧵 线程隔离数据** | `ThreadLocal` | 避免同步，线程独立 |
| **📖 读多写少场景** | `ReadWriteLock` | 读并发，写互斥 |
| **📦 生产者消费者模式** | `BlockingQueue` | 天然支持生产消费模式 |

### 9.2 复杂场景组合使用


**💻 综合应用示例：任务处理系统**
```java
public class TaskProcessingSystem {
    // 控制同时处理的任务数
    private final Semaphore processingPermits = new Semaphore(10);
    
    // 任务队列
    private final BlockingQueue<Task> taskQueue = new ArrayBlockingQueue<>(1000);
    
    // 统计信息
    private final AtomicInteger processedCount = new AtomicInteger(0);
    private final AtomicInteger errorCount = new AtomicInteger(0);
    
    // 线程上下文
    private final ThreadLocal<String> currentTaskId = new ThreadLocal<>();
    
    // 阶段同步器
    private final Phaser phaser = new Phaser(1);  // 主线程注册
    
    public void processTask(Task task) {
        try {
            processingPermits.acquire();  // 获取处理许可
            currentTaskId.set(task.getId());  // 设置当前任务ID
            
            phaser.register();  // 注册到当前阶段
            
            // 处理任务
            doProcessTask(task);
            
            processedCount.incrementAndGet();  // 成功计数
        } catch (Exception e) {
            errorCount.incrementAndGet();  // 错误计数
        } finally {
            currentTaskId.remove();  // 清理线程变量
            processingPermits.release();  // 释放许可
            phaser.arriveAndDeregister();  // 完成并注销
        }
    }
    
    public void waitForCompletion() {
        phaser.arriveAndAwaitAdvance();  // 等待所有任务完成
        System.out.println("处理完成 - 成功: " + processedCount.get() + 
                          ", 失败: " + errorCount.get());
    }
}
```

### 9.3 选择决策树


```
并发工具选择决策树
├── 📊 需要同步多个线程？
│   ├── 是 → 继续判断
│   └── 否 → 考虑ThreadLocal（线程隔离）或原子类（简单共享状态）
├── 🔄 是否需要复用？
│   ├── 需要复用 → CyclicBarrier 或 Phaser
│   └── 一次性使用 → CountDownLatch
├── 🎭 是否有多个阶段？
│   ├── 多阶段 → Phaser
│   └── 单阶段 → CyclicBarrier 或 CountDownLatch
├── 🎫 是否需要限制并发数？
│   ├── 需要限制 → Semaphore
│   └── 不需要限制 → 其他同步工具
├── 🔄 是否需要数据交换？
│   ├── 两线程交换 → Exchanger
│   ├── 多线程队列 → BlockingQueue
│   └── 无需交换 → 其他工具
└── 🔐 是否需要精细的锁控制？
    ├── 需要 → ReentrantLock 或 ReadWriteLock
    └── 不需要 → 使用同步工具或原子类
```

> 🎯 **总结**：Java并发工具类提供了丰富的同步和协调机制，选择合适的工具类需要考虑具体的业务场景、性能要求和复杂度。掌握这些工具类的特性和适用场景，能够显著提高并发程序的质量和性能。