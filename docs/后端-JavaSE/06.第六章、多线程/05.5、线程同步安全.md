---
title: 5、线程同步安全
---
## 📚 目录

1. [基本概念](#1-基本概念)
2. [线程同步的常用方式](#2-线程同步的常用方式)
3. [线程同步的注意事项](#3-线程同步的注意事项)
4. [同步方式对比分析](#4-同步方式对比分析)
5. [线程安全代码示例](#5-线程安全代码示例)
6. [线程安全最佳实践](#6-线程安全最佳实践)

---

## 1. 🔒 基本概念


### 1.1 核心概念解释


**🔸 线程同步**
```
定义：多个线程在共享资源上有序访问，避免数据冲突
目标：确保多线程环境下数据的一致性和完整性
本质：协调线程执行顺序，避免竞态条件
```

**🔸 线程安全**
```
定义：在多线程环境下，程序的执行结果是正确的，且行为与单线程一致
标准：无论线程如何调度，程序都能产生预期结果
关键：共享资源的访问必须是同步的
```

**🔸 本质问题**
- **数据竞争**：多线程同时访问共享数据导致的不确定结果
- **原子性破坏**：复合操作被线程切换打断
- **可见性缺失**：线程间数据修改不可见
- **指令重排序**：编译器优化导致的执行顺序变化

### 1.2 为何需要线程同步


| **问题类型** | **具体说明** | **影响后果** |
|------------|------------|------------|
| **🔄 多线程并发访问共享变量** | 会出现数据竞争、覆盖、读取不一致 | 数据错误、逻辑异常 |
| **⚛️ 原子性问题** | 复合操作如 `++i` 实际是多条指令，线程切换易出错 | 计数器结果错误 |
| **👁️ 可见性问题** | 一个线程修改变量，其他线程可能不可见（缓存问题） | 状态不同步、死循环 |
| **🔀 指令重排序** | 编译器/JVM 为优化可能重排执行顺序，产生意外结果 | 单例模式双重检查锁失效 |

### 1.3 需要同步的场景判断


**✅ 需要同步的情况**：
- 多线程**共享可变状态**（变量、对象等）
- 存在**写操作**（读-读不需要同步）
- 操作**非原子性**（非一步完成的操作）

**❌ 不需要同步的情况**：
- 线程私有变量（局部变量、ThreadLocal）
- 不可变对象（final、String等）
- 纯读操作且数据不变

---

## 2. ⚙️ 线程同步的常用方式


### 2.1 synchronized（最基础）


**🔐 基本语法**
```java
// 方法级同步
public synchronized void method() { /*同步代码*/ }

// 代码块同步
synchronized(lock对象) { /*同步代码*/ }
```

**📊 synchronized 特性结构**
```
synchronized 特点
├── 🔒 互斥性
│   └── 同一时刻只能有一个线程执行同步代码（保证原子性）
├── 🔄 可重入性
│   └── 同一个线程可以多次获得同一个锁（不会死锁）
└── 🔓 自动释放锁
    └── 执行完同步代码块或方法后自动释放（无需手动 unlock）
```

**🎯 锁对象规则**
```
synchronized 锁对象规则
├── 🏠 实例方法（非 static）
│   └── 锁对象为当前实例对象 this
│       └── 不同实例不互斥
├── 🏢 静态方法（static）
│   └── 锁对象为当前类的 Class 对象（ClassName.class）
│       └── 所有线程共享该类级锁
└── 🎯 同步代码块
    └── 锁定指定的对象引用（任何 Object 均可）
        ├── synchronized(this)   → 当前实例锁
        ├── synchronized(ClassName.class) → 类锁
        └── synchronized(自定义对象) → 锁粒度更细，更灵活
```

| **形式** | **作用范围** | **锁对象** |
|---------|------------|-----------|
| 实例方法 `synchronized` | 锁当前对象 | `this` |
| 静态方法 `synchronized` | 锁类的 Class 对象 | `ClassName.class` |
| 同步代码块 | 锁指定对象（灵活控制） | 任意Object |

### 2.2 Lock 接口（显式锁）


**🔧 基本用法**
```java
Lock lock = new ReentrantLock();
lock.lock();
try { 
    /* 临界区代码 */ 
} finally { 
    lock.unlock(); 
}
```

**⭐ Lock 接口特性**

| **特性** | **描述** | **优势** |
|---------|---------|---------|
| **🔧 显式加锁/释放** | 更灵活（但更易出错） | 精确控制锁的生命周期 |
| **🎯 支持尝试加锁** | `tryLock()` | 避免无限期等待 |
| **⏰ 支持可中断加锁** | `lockInterruptibly()` | 响应中断请求 |
| **⚖️ 支持公平锁** | `new ReentrantLock(true)` | 按申请顺序获得锁 |
| **📖 支持读写分离** | `ReentrantReadWriteLock` | 提高并发读性能 |

### 2.3 volatile（可见性保障）


**⚡ 基本语法**
```java
volatile boolean flag = true;
```

**🎯 volatile 作用**

| **作用** | **描述** | **适用场景** |
|---------|---------|-------------|
| **👁️ 保证变量修改对其他线程立即可见** | 不保证原子性 | 状态标志 |
| **🚫 禁止指令重排序** | 确保执行顺序 | 双重检查锁等场景 |

> ⚠️ **重要提醒**：volatile **不保证原子性**，不能用于复合操作如 `i++`

### 2.4 原子类（Atomic）


**🔬 基本用法**
```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet();
```

**⚛️ 原子类特性**

| **特性** | **说明** | **底层原理** |
|---------|---------|-------------|
| **CAS（Compare And Swap）底层原理** | 非阻塞线程安全 | 硬件级别的原子操作 |
| **常用类** | `AtomicInteger`、`AtomicLong`、`AtomicBoolean` | 包装基本类型 |
| **高性能** | 无锁设计 | 避免线程阻塞开销 |

### 2.5 并发容器


**📦 常用并发容器**

| **类型** | **示例类** | **特点** |
|---------|-----------|---------|
| **🔄 阻塞队列** | `ArrayBlockingQueue`、`LinkedBlockingQueue` | 线程安全的队列操作 |
| **📊 并发集合** | `ConcurrentHashMap`、`CopyOnWriteArrayList` | 高并发访问优化 |
| **🚦 信号类** | `Semaphore`、`CountDownLatch`、`CyclicBarrier` | 线程协调工具 |

---

## 3. ⚠️ 线程同步的注意事项


### 3.1 关键注意点


| **注意项** | **说明** | **后果** |
|-----------|---------|---------|
| **💀 避免死锁** | 多线程互相等待对方持有的锁 | 程序假死、无法继续执行 |
| **🚫 不要在锁内调用外部方法** | 外部方法不可控，易发生阻塞或异常 | 长时间占用锁、性能下降 |
| **📏 最小化同步范围** | 保证安全前提下提升性能 | 减少锁竞争、提高并发度 |
| **⚡ 避免空锁或过度细粒度锁** | 会导致频繁上下文切换，性能反而下降 | CPU资源浪费 |
| **🎯 区分共享资源与线程私有变量** | 私有变量不需要同步 | 避免不必要的同步开销 |

### 3.2 死锁预防策略


```
死锁预防四大策略
├── 🔄 破坏循环等待条件
│   └── 固定锁的获取顺序
├── ⏰ 使用超时机制
│   └── tryLock(timeout) 避免无限等待
├── 🎯 减少锁的嵌套
│   └── 简化锁的使用层次
└── 🔍 死锁检测与恢复
    └── 监控工具检测死锁状态
```

---

## 4. 📊 同步方式对比分析


### 4.1 功能特性对比


| **特性** | **synchronized** | **Lock** | **volatile** | **Atomic** |
|---------|-----------------|----------|-------------|-----------|
| **⚛️ 原子性** | ✅ | ✅ | ❌ | ✅ |
| **👁️ 可见性** | ✅ | ✅ | ✅ | ✅ |
| **🔄 可重入** | ✅ | ✅ | ❌ | ✅（单变量） |
| **⏸️ 可中断** | ❌ | ✅ | ❌ | ❌ |
| **⚖️ 公平性控制** | ❌ | ✅ | ❌ | ❌ |
| **💻 编程复杂度** | 低 | 中 | 低 | 低 |

### 4.2 详细对比分析


```
线程同步方式对比
├── 🔒 synchronized（内置锁）
│   ├── ✅ 保证原子性与可见性（阻塞机制）
│   ├── ❌ 不可中断，不可尝试加锁，不支持公平性
│   ├── ✅ 编写简单，语法糖式使用（推荐初学者）
│   └── ✅ 适用于临界区、简单同步场景
│
├── 🔧 Lock（ReentrantLock）
│   ├── ✅ 保证原子性与可见性（显式阻塞机制）
│   ├── ✅ 支持中断（lockInterruptibly）
│   ├── ✅ 支持尝试加锁（tryLock()）
│   ├── ✅ 支持公平锁（构造时设为 true）
│   ├── ⚠️ 使用复杂（需手动 lock/unlock）
│   └── ✅ 适用于复杂同步控制、高并发场景
│
├── ⚡ volatile（可见性关键字）
│   ├── ❌ 不保证原子性（如 i++ 非线程安全）
│   ├── ✅ 保证可见性（修改立即对其他线程可见）
│   ├── ❌ 不阻塞、不支持加锁、不可中断
│   ├── ✅ 写法简单，但易误用
│   └── ✅ 适用于状态标志、线程通信（如停止标志）
│
└── ⚛️ Atomic 原子类（如 AtomicInteger）
    ├── ✅ 保证原子性（基于 CAS 无锁机制）
    ├── ✅ 保证可见性（内部基于 volatile）
    ├── ❌ 不阻塞、不支持中断/公平控制
    ├── ✅ 高性能，非阻塞，适用于高并发
    ├── ⚠️ 仅适用于单变量操作
    └── ✅ 适用于高频累加器、计数器、标志位
```

> 💡 **记忆口诀**：synchronized 简单安全、Lock 灵活强大、volatile 轻量可见、Atomic 高效单值

---

## 5. 💻 线程安全代码示例


### 5.1 synchronized 用法示例


**🏠 实例方法 synchronized —— 锁当前对象 (this)**
```java
public class InstanceSyncDemo {
    public synchronized void run() {
        System.out.println(Thread.currentThread().getName() + " 执行实例方法");
    }

    public static void main(String[] args) {
        InstanceSyncDemo obj = new InstanceSyncDemo();

        new Thread(() -> obj.run(), "线程A").start();
        new Thread(() -> obj.run(), "线程B").start();
    }
}
// 两个线程操作同一个 obj，因此会互斥（同步）
```

**🏢 静态方法 synchronized —— 锁 Class 对象 (ClassName.class)**
```java
public class StaticSyncDemo {
    public static synchronized void run() {
        System.out.println(Thread.currentThread().getName() + " 执行静态方法");
    }

    public static void main(String[] args) {
        new Thread(() -> StaticSyncDemo.run(), "线程A").start();
        new Thread(() -> StaticSyncDemo.run(), "线程B").start();
    }
}
// 所有线程共享类锁：StaticSyncDemo.class，因此也会互斥
```

**🎯 同步代码块 synchronized —— 锁任意指定对象**
```java
public class BlockSyncDemo {
    private final Object lock = new Object();

    public void run() {
        synchronized (lock) {
            System.out.println(Thread.currentThread().getName() + " 执行同步块");
        }
    }

    public static void main(String[] args) {
        BlockSyncDemo obj = new BlockSyncDemo();

        new Thread(() -> obj.run(), "线程A").start();
        new Thread(() -> obj.run(), "线程B").start();
    }
}
// 两线程都锁定同一个 lock 对象，形成互斥
// 可将 lock 换成 this、任意对象、类锁等，实现更灵活的控制
```

### 5.2 Lock 接口线程安全示例


```java
public class LockDemo {
    private int count = 0;
    private final Lock lock = new ReentrantLock(); // 显式锁

    public void increment() {
        lock.lock(); // 显式加锁
        try {
            count++; // 临界区，线程安全
        } finally {
            lock.unlock(); // 确保释放锁（避免死锁）
        }
    }

    public static void main(String[] args) throws InterruptedException {
        LockDemo demo = new LockDemo();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) demo.increment();
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) demo.increment();
        });

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("最终计数值: " + demo.count); // 预期结果：2000
    }
}
```

**🔧 Lock 使用特性说明**

| **特性** | **描述** |
|---------|---------|
| `lock.lock()` | 显式加锁（必须自己释放） |
| `try-finally` | 推荐结构，确保即使异常也能解锁 |
| `lock.unlock()` | 释放锁，必须和 lock 成对出现 |
| `ReentrantLock` | 可重入、可中断、支持公平锁等 |

### 5.3 volatile 代码示例


**✅ volatile 保证可见性（正确示范）**
```java
public class VolatileFlagDemo {
    private static volatile boolean running = true; // 保证可见性

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            while (running) {
                // 如果没有 volatile，主线程改了 running = false，这里可能一直看不到
            }
            System.out.println("线程感知到 running=false，退出");
        });

        t.start();
        Thread.sleep(1000);
        running = false; // 主线程修改变量
    }
}
// 若去掉 volatile，JVM 可能会将 running 缓存在寄存器中，
// 导致线程无法感知主线程的修改，产生死循环
```

**⚠️ volatile 无法保证原子性（错误示范）**
```java
public class VolatileCounterDemo {
    private static volatile int count = 0;

    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) count++;
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("最终计数值: " + count); // ⚠️ 结果 < 2000，不安全
    }
}
// count++ 是复合操作（读 → 改 → 写），volatile 只保证每步可见性，
// 但不能阻止线程抢占交叉执行，因此不是线程安全的
```

**🎯 volatile 使用场景判断**

| **使用场景** | **是否适合 volatile** | **说明** |
|------------|-------------------|---------|
| 标志位（如停止线程） | ✅ 非常适合 | 简单的状态切换 |
| 单次赋值、不涉及复合操作 | ✅ 合适 | 确保可见性即可 |
| 计数器、累加器等需原子性 | ❌ 不可单独使用 | 需要配合其他同步机制 |
| 需要互斥执行 | ❌ 应配合 synchronized 或 Lock | volatile 不提供互斥 |

### 5.4 原子类（Atomic）保证线程安全


**🔄 传统方式 vs 原子类对比**
```java
// 传统方式（需要同步）
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++; // 多线程时会被竞争
    }

    public synchronized int getCount() {
        return count;
    }
}

// 使用 AtomicInteger 优化
private AtomicInteger count = new AtomicInteger(0);

public void increment() {
    count.incrementAndGet(); // 原子操作，无需加锁
}
```

**⚛️ AtomicInteger 完整示例**
```java
public class AtomicDemo {
    private static AtomicInteger count = new AtomicInteger(0); // 线程安全原子变量

    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                count.incrementAndGet(); // 原子加1，线程安全
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("最终计数值: " + count.get()); // 正确输出 2000
    }
}
```

**📋 AtomicInteger 常用方法说明**

| **方法名** | **含义说明** |
|-----------|-------------|
| `incrementAndGet()` | 先加 1 再返回结果 |
| `getAndIncrement()` | 先返回旧值再加 1 |
| `get()` | 获取当前值 |
| `set(int value)` | 设置新值 |
| `compareAndSet(expect, update)` | CAS操作，期望值匹配则更新 |

---

## 6. 🏆 线程安全最佳实践


### 6.1 同步机制选择策略


```
选择合适的同步机制
├── 🔰 简单场景
│   ├── synchronized：临界区加锁，保证互斥与可见性
│   └── volatile：仅用于状态标志或线程通信（轻量，非原子）
├── 🎯 高级需求
│   └── Lock 接口实现类（如 ReentrantLock、ReadWriteLock）
│       ├── 支持可中断、可超时、公平锁
│       └── 更灵活控制同步逻辑
├── ⚡ 无锁方案
│   ├── 原子类（AtomicInteger、AtomicReference 等）—— 基于 CAS
│   └── 并发集合（ConcurrentHashMap、CopyOnWriteArrayList）
├── 🧵 单例/初始化相关
│   ├── ThreadLocal：线程隔离副本（避免共享）
│   └── DCL + volatile：双重检查锁实现懒加载单例，线程安全
```

### 6.2 性能优化策略


```
减少锁的粒度（提升并发性能）
├── 📏 缩小同步范围
│   └── 只在关键代码段加锁，避免整个方法同步
├── 🔀 分解锁（分段锁）
│   └── 为不同资源使用不同锁，提高并行度
├── 🚫 避免锁嵌套
│   └── 嵌套锁越多，死锁风险越高，应优化结构
├── 📖 使用读写锁
│   ├── ReentrantReadWriteLock
│   ├── 多线程同时读：并发执行
│   └── 写操作互斥：保证一致性
```

### 6.3 常见并发问题规避


```
避免常见并发问题
├── 💀 死锁预防
│   ├── 固定获取锁的顺序（避免循环等待）
│   ├── 尝试使用超时锁（如 tryLock(timeout)）
│   └── 检测与恢复策略（如设置死锁检测器）
├── 🔄 活锁解决
│   └── 引入随机等待或退避机制（如 Thread.yield() + sleep）
├── ⚡ 性能考虑
│   ├── 避免长时间持有锁（阻塞其他线程）
│   ├── 合理设置线程池线程数（避免频繁切换）
│   └── 避免过度同步（滥用 synchronized 会影响并发性能）
```

### 6.4 应用场景快速选择


| **场景** | **推荐方案** | **理由** |
|---------|-------------|---------|
| **🔒 简单互斥同步** | `synchronized` | 语法简单，自动释放锁 |
| **🚩 线程通信/标志位** | `volatile` | 轻量级，保证可见性 |
| **🔢 多线程安全计数器** | `AtomicInteger` | 高性能，无锁设计 |
| **🎛️ 复杂并发流程控制** | `Lock` / `ReentrantLock` | 功能丰富，控制灵活 |
| **📚 高读低写场景** | `ReadWriteLock` | 读并发，写互斥 |
| **🧵 线程隔离数据** | `ThreadLocal` | 避免共享，无需同步 |

### 6.5 核心原则总结


> 🎯 **线程安全核心原则**：
> - **能不共享就不共享**（ThreadLocal、不可变对象）
> - **必须共享则要同步**（选择合适的同步机制）
> - **同步范围要最小**（减少锁竞争）
> - **避免复杂锁嵌套**（预防死锁）
> - **性能与安全平衡**（根据场景选择最优方案）