---
title: 7、线程池
---
## 📚 目录

1. [线程池概述](#1-线程池概述)
2. [线程池接口体系](#2-线程池接口体系)
3. [Executors创建线程池](#3-Executors创建线程池)
4. [ThreadPoolExecutor详解](#4-ThreadPoolExecutor详解)
5. [线程池工作流程](#5-线程池工作流程)
6. [任务队列与拒绝策略](#6-任务队列与拒绝策略)
7. [拒绝策略详解](#7-拒绝策略详解)
8. [ThreadPoolExecutor常用方法](#8-ThreadPoolExecutor常用方法)
9. [自定义线程工厂](#9-自定义线程工厂)
10. [核心参数调优策略](#10-核心参数调优策略)
11. [线程池异常处理机制](#11-线程池异常处理机制)
12. [线程池监控与调优](#12-线程池监控与调优)
13. [常见误区与最佳实践](#13-常见误区与最佳实践)

---

## 1. 🏊 线程池概述


### 1.1 基本概念


**🔸 线程池定义**
```
线程池：一种线程使用模式，预先创建并维护一组线程，通过复用已有线程来减少线程创建和销毁的开销
核心思想：线程池管理着一组工作线程，等待并执行提交的任务
实现基础：Java中主要通过java.util.concurrent.ThreadPoolExecutor类实现
```

### 1.2 线程池优势分析


| **优势点** | **具体说明** | **带来的价值** |
|-----------|-------------|---------------|
| **💰 降低资源消耗** | 重复利用线程，无需频繁创建销毁 | 减少系统开销，提高性能 |
| **⚡ 提高响应速度** | 任务提交后可立即执行 | 避免线程创建等待时间 |
| **🎛️ 便于统一管理线程** | 可配置线程数、队列、拒绝策略等 | 统一控制，便于监控调优 |
| **🛡️ 防止过多线程导致资源耗尽** | 限制最大并发线程数量 | 系统稳定性保障 |

### 1.3 线程池解决的核心问题


```
传统线程使用问题
├── 📈 线程创建销毁开销大
│   ├── 每次new Thread()都需要系统调用
│   └── 线程销毁需要回收资源
├── 🔄 线程数量难以控制
│   ├── 无限制创建可能导致OOM
│   └── 线程过多导致上下文切换频繁
├── 📊 缺乏统一管理机制
│   ├── 无法统计线程使用情况
│   └── 难以实现负载均衡
└── 🎯 任务与线程耦合度高
    ├── 一个任务对应一个线程
    └── 资源利用率低

线程池解决方案
├── ♻️ 线程复用机制
│   └── 线程执行完任务后不销毁，继续等待新任务
├── 🎛️ 线程数量控制
│   ├── 核心线程数：保持存活的最小线程数
│   └── 最大线程数：系统能创建的线程上限
├── 📋 任务队列缓冲
│   └── 当线程忙碌时，新任务进入队列等待
└── 🔧 灵活的配置策略
    ├── 拒绝策略：队列满时的处理方式
    └── 线程工厂：自定义线程创建方式
```

---

## 2. 🏗️ 线程池接口体系


### 2.1 接口继承关系


```
Java 线程池接口体系结构（java.util.concurrent）
├── 📋 Executor（顶层接口）
│   └── 描述：定义任务执行的基础接口，核心方法是 execute(Runnable)
│
├── 🔧 ExecutorService（扩展接口，线程池核心功能接口）
│   ├── 描述：继承 Executor，增加生命周期控制和任务提交能力
│   ├── submit()：支持提交 Runnable 或 Callable 任务并返回 Future
│   ├── shutdown() / shutdownNow()：线程池关闭管理
│   └── invokeAll() / invokeAny()：批量任务提交支持
│
│   ├── ⏰ ScheduledExecutorService（定时任务线程池接口）
│   │   └── 描述：在 ExecutorService 基础上，添加定时与周期性任务调度功能
│   │
│   └── 🎨 AbstractExecutorService（抽象实现类）
│       └── 描述：提供 ExecutorService 接口的基础实现
```

### 2.2 主要实现类


```
实现类体系
├── 🎯 ThreadPoolExecutor（ExecutorService 的默认核心实现类）
│   ├── 描述：Java 最常用、可自定义参数的线程池实现类
│   ├── 核心参数：
│   │   ├── corePoolSize：核心线程数
│   │   ├── maximumPoolSize：最大线程数
│   │   ├── keepAliveTime：非核心线程空闲销毁时间
│   │   ├── workQueue：任务队列（如 LinkedBlockingQueue）
│   │   ├── threadFactory：线程工厂（定制线程名称等）
│   │   └── handler：拒绝策略（如 AbortPolicy）
│   │
│   └── ⏰ ScheduledThreadPoolExecutor（ScheduledExecutorService 的默认实现）
│       └── 描述：支持周期性和延迟任务调度的线程池实现类（基于 DelayQueue）
│
├── 🍴 ForkJoinPool（实现 ExecutorService，支持任务分解和窃取）
│   ├── 描述：适合大量小任务并行递归计算（如分治算法）
│   └── Java 8 默认用于 parallelStream() 的线程池实现
│
└── 🛠️ Executors（工具类，提供线程池工厂方法）
    ├── newFixedThreadPool(n)：固定线程数线程池（任务队列无界）
    ├── newCachedThreadPool()：弹性线程池（线程可回收，任务队列为同步队列）
    ├── newSingleThreadExecutor()：单线程池（顺序执行任务）
    ├── newScheduledThreadPool(n)：定时任务线程池（周期性任务）
    └── newWorkStealingPool()：基于 ForkJoinPool 的工作窃取线程池（适合多核）
```

### 2.3 相关接口与类


```
相关支持类
├── 🔮 Future<V>：表示异步计算结果
├── 📞 Callable<V>：可返回结果的任务
├── 🚫 RejectedExecutionHandler：任务拒绝策略接口
└── 🏭 ThreadFactory：线程创建工厂接口
```

---

## 3. 🛠️ Executors创建线程池


### 3.1 Executors工具类方法概览


| **工具方法** | **特点与用途** | **风险等级** |
|-------------|---------------|-------------|
| **🔢 `newFixedThreadPool(n)`** | 固定数量线程池，任务多时进入队列，控制并发数量 | ⚠️ 中风险 |
| **🔄 `newCachedThreadPool()`** | 可自动扩容，线程空闲60秒回收，适合短期大量并发任务 | ❌ 高风险OOM |
| **1️⃣ `newSingleThreadExecutor()`** | 单线程池，任务按顺序串行执行，适合顺序性要求的场景 | ✅ 低风险 |
| **⏰ `newScheduledThreadPool(n)`** | 支持定时/周期任务执行的线程池，可并发执行多个定时任务 | ✅ 低风险 |
| **⏰ `newSingleThreadScheduledExecutor()`** | 单线程调度线程池，定时任务串行执行 | ✅ 低风险 |

### 3.2 各种线程池详细分析


```
线程池创建方式（Executors 工具类）
├── 1️⃣ newFixedThreadPool(int n)
│   ├── 特点：
│   │   ├─ 固定线程数 n
│   │   ├─ 任务多时进入有界队列（默认无界 LinkedBlockingQueue）
│   ├── 使用场景：
│   │   └─ 稳定并发任务处理（如固定数量的后台线程）
│   ├── 风险：
│   │   └─ 队列默认无界，任务积压可能导致 OOM
│   └── 注意事项：
│       └─ 建议自定义 ThreadPoolExecutor 设置有界队列
│
├── 2️⃣ newCachedThreadPool()
│   ├── 特点：
│   │   ├─ 线程可复用，空闲60秒回收
│   │   └─ 无界线程池 + SynchronousQueue（不缓存任务）
│   ├── 使用场景：
│   │   └─ 突发大量短任务，如轻量 HTTP 请求处理
│   ├── 风险：
│   │   └─ 没有上限，任务多会无限创建线程 → OOM
│   └── 注意事项：
│       └─ 不建议用于生产，线程数不可控
│
├── 3️⃣ newSingleThreadExecutor()
│   ├── 特点：
│   │   └─ 单线程串行处理任务（FIFO顺序执行）
│   ├── 使用场景：
│   │   └─ 任务必须严格按顺序执行，如日志写入、流水线任务
│   ├── 风险：
│   │   └─ 线程死掉后无法恢复，任务卡死
│   └── 注意事项：
│       └─ 可结合 try-catch 和监控避免单线程崩溃
│
├── 4️⃣ newScheduledThreadPool(int n)
│   ├── 特点：
│   │   └─ 多线程支持延迟执行、周期性执行任务
│   ├── 使用场景：
│   │   └─ 定时调度、周期性任务（如日志采集、心跳检测）
│   ├── 风险：
│   │   └─ 线程池大小不足时任务会延迟堆积
│   └── 注意事项：
│       └─ 注意设置合适的核心线程数以避免调度延迟
│
└── 5️⃣ newSingleThreadScheduledExecutor()
    ├── 特点：
    │   └─ 单线程定时任务，任务顺序执行
    ├── 使用场景：
    │   └─ 严格按顺序的定时任务（如数据归档、单通道定投）
    ├── 风险：
    │   └─ 单线程故障会导致所有定时任务中断
    └── 注意事项：
        └─ 同样需确保任务健壮，防止线程崩溃
```

### 3.3 线程池对比总结


| **创建方法** | **并发能力** | **排队机制** | **是否推荐生产用** | **风险说明** |
|-------------|-------------|-------------|------------------|-------------|
| **`FixedThreadPool(n)`** | 中 | 默认无界队列 | ✅（需设置有界） | 队列堆积 OOM |
| **`CachedThreadPool()`** | 高 | 无队列 | ❌ 不推荐 | 无限创建线程导致 OOM |
| **`SingleThreadExecutor()`** | 1 | 串行队列 | ✅（串行场景） | 死锁/线程崩溃风险 |
| **`ScheduledThreadPool(n)`** | 中~高 | 定时任务调度表 | ✅（调度任务） | 核心线程不足会阻塞 |
| **`SingleThreadScheduledExecutor()`** | 1 | 定时串行队列 | ✅（顺序定时任务） | 同上，线程挂掉中断所有 |

### 3.4 Executors使用示例代码


**🔢 1. newFixedThreadPool(int n) —— 固定数量线程池**
```java
public class FixedPoolDemo {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(2); // 创建固定大小为2的线程池

        for (int i = 1; i <= 4; i++) {
            int taskId = i;
            pool.execute(() -> System.out.println("Fixed执行任务 " + taskId));
        }

        pool.shutdown(); // 关闭线程池
    }
}
```

**🔄 2. newCachedThreadPool() —— 可扩展线程池（适合短任务）**
```java
public class CachedPoolDemo {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newCachedThreadPool(); // 自动扩容线程池

        for (int i = 1; i <= 4; i++) {
            int taskId = i;
            pool.execute(() -> System.out.println("Cached执行任务 " + taskId));
        }

        pool.shutdown();
    }
}
```

**1️⃣ 3. newSingleThreadExecutor() —— 单线程池（顺序执行）**
```java
public class SinglePoolDemo {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newSingleThreadExecutor(); // 单线程池

        for (int i = 1; i <= 4; i++) {
            int taskId = i;
            pool.execute(() -> System.out.println("Single执行任务 " + taskId));
        }

        pool.shutdown();
    }
}
```

**⏰ 4. newScheduledThreadPool(int n) —— 定时/周期任务线程池**
```java
public class ScheduledPoolDemo {
    public static void main(String[] args) {
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(2); // 支持延迟执行的线程池

        // 延迟2秒后执行
        pool.schedule(() -> System.out.println("Scheduled延迟任务执行"), 2, TimeUnit.SECONDS);

        pool.shutdown();
    }
}
```

**⏰ 5. newSingleThreadScheduledExecutor() —— 单线程调度执行器（定时串行）**
```java
public class SingleScheduledDemo {
    public static void main(String[] args) {
        ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor(); // 单线程调度池

        // 每1秒执行一次，首次延迟0秒
        pool.scheduleAtFixedRate(() -> System.out.println("Single定时任务：" + System.currentTimeMillis()),
                0, 1, TimeUnit.SECONDS);

        // 自动停止示例：5秒后关闭线程池
        Executors.newScheduledThreadPool(1).schedule(() -> pool.shutdown(), 5, TimeUnit.SECONDS);
    }
}
```

---

## 4. 🎯 ThreadPoolExecutor详解


### 4.1 ThreadPoolExecutor概述


```
ThreadPoolExecutor（java.util.concurrent）
├── 📋 基本定义
│   ├── 是 Java 提供的线程池核心实现类
│   ├── 位于 java.util.concurrent 包中
│   └── 实现了 ExecutorService 接口
│
├── 🎯 主要作用
│   ├── 管理线程的创建与复用，避免频繁创建销毁线程
│   ├── 维护一个工作线程池（Worker threads）
│   ├── 从任务队列中取出任务，分配线程执行
│   ├── 支持灵活的线程池参数配置
│   ├── 支持任务执行前/执行后钩子方法（可自定义扩展行为）
│   └── 提供线程池的生命周期管理（如关闭、回收等）
│
├── ✨ 功能特点
│   ├── 提供 execute()、submit()、invokeAll() 等多种任务提交方式
│   ├── 支持 Runnable 和 Callable 类型任务
│   ├── 支持任务队列（BlockingQueue）配置，决定排队策略
│   ├── 支持线程池策略调整（核心线程数、最大线程数等）
│   ├── 支持拒绝策略（当队列满或线程数已达上限时）
│   ├── 可设置线程工厂（ThreadFactory）来自定义线程创建逻辑
│   └── 具备强大的扩展性和可监控性（如钩子函数 beforeExecute/afterExecute）
│
└── 🎨 使用场景
    ├── 高并发任务处理（Web服务器、并发任务调度等）
    ├── 后台异步任务处理
    ├── 限流或节流控制（配合线程数控制）
    └── 分布式或多模块系统的任务执行统一调度
```

### 4.2 构造方法详解


**🏗️ 完整构造器**
```java
ThreadPoolExecutor(int corePoolSize,
                   int maximumPoolSize,
                   long keepAliveTime,
                   TimeUnit unit,
                   BlockingQueue<Runnable> workQueue,
                   ThreadFactory threadFactory,
                   RejectedExecutionHandler handler);
```

**📋 参数详细说明**

| **参数名** | **类型** | **说明** |
|-----------|---------|----------|
| **`corePoolSize`** | `int` | 核心线程数，线程池中的最小线程数（即使空闲也会存在） |
| **`maximumPoolSize`** | `int` | 最大线程数，线程池能容纳的最大线程数 |
| **`keepAliveTime`** | `long` | 非核心线程空闲时存活的最长时间，超过此时间会被回收 |
| **`unit`** | `TimeUnit` | `keepAliveTime` 的时间单位（秒、毫秒等） |
| **`workQueue`** | `BlockingQueue<Runnable>` | 用于存放等待执行的任务的队列 |
| **`threadFactory`** | `ThreadFactory` | 线程工厂，用于创建新线程 |
| **`handler`** | `RejectedExecutionHandler` | 任务拒绝策略，当任务提交失败时的处理方式 |

---

## 5. 🔄 线程池工作流程


### 5.1 线程池执行流程


```
ThreadPoolExecutor 工作流程
├── 1️⃣ 提交任务
│   ├── 调用 execute(Runnable) 方法（无返回值）
│   └── 调用 submit(Callable or Runnable) 方法（返回 Future，可获取结果）
│
├── 2️⃣ 核心线程处理阶段
│   ├── 当前线程数 < corePoolSize
│   └── 创建新的核心线程处理该任务
│
├── 3️⃣ 队列处理阶段
│   ├── 当前线程数 ≥ corePoolSize
│   └── 任务被加入工作队列 workQueue（等待空闲线程来处理）
│
├── 4️⃣ 线程池扩容阶段
│   ├── 工作队列已满（队列容量达到上限）
│   ├── 当前线程数 < maximumPoolSize
│   └── 创建新的非核心线程来处理任务（临时线程）
│
└── 5️⃣ 拒绝策略阶段
    ├── 当前线程数 = maximumPoolSize 且队列已满
    └── 执行拒绝策略 handler
        ├── AbortPolicy（默认，抛出异常）
        ├── CallerRunsPolicy（由调用者线程执行该任务）
        ├── DiscardPolicy（直接丢弃任务）
        └── DiscardOldestPolicy（丢弃队列中最早的任务，尝试重新提交）
```

### 5.2 线程池状态转换


| **状态** | **含义** | **接受新任务** | **处理队列任务** |
|---------|---------|---------------|-----------------|
| **🟢 `RUNNING`** | 线程池可以接收新任务并处理任务 | ✅ 是 | ✅ 是 |
| **🟡 `SHUTDOWN`** | 线程池不再接收新任务，但会继续执行已提交任务 | ❌ 否 | ✅ 是 |
| **🔴 `STOP`** | 线程池不接收新任务，也不执行队列中的任务，所有任务会被中断 | ❌ 否 | ❌ 否 |
| **🟠 `TIDYING`** | 所有任务已结束，正在清理线程池资源 | ❌ 否 | ❌ 否 |
| **⚫ `TERMINATED`** | 线程池已完全终止，`terminated()` 方法已调用 | ❌ 否 | ❌ 否 |

### 5.3 工作流程图解


```
【任务提交】→【线程池状态检查】
  ↓
线程池运行中? → 否 → 【拒绝任务】
  ↓ 是
【线程分配策略】(优先级从高到低)
  ↓
1. 活动线程 < 核心线程数? → 是 → 【创建核心线程执行】
  ↓ 否
2. 任务队列未满? → 是 → 【任务入队】→【空闲线程获取执行】
  ↓ 否
3. 活动线程 < 最大线程数? → 是 → 【创建临时线程执行】
  ↓ 否
4. 【执行拒绝策略】
   - AbortPolicy: 抛异常
   - CallerRunsPolicy: 调用者线程执行
   - DiscardPolicy: 丢弃新任务
   - DiscardOldestPolicy: 丢弃最旧任务

【任务执行完成后】→【线程状态更新】
  ↓
核心线程? → 是 → 【继续等待新任务】
  ↓ 否
超过保活时间无任务? → 是 → 【线程终止】
  ↓ 否
【继续等待新任务】
```

---

## 6. 📦 任务队列与拒绝策略


### 6.1 常用任务队列


**🔢 ArrayBlockingQueue（数组有界队列）**
```java
new ArrayBlockingQueue<Runnable>(capacity)

ArrayBlockingQueue
├── 特性
│   ├── 有界，固定长度，基于数组实现
│   ├── FIFO（先进先出）
│   └── 插入/移除性能高，线程安全
├── 适用场景
│   ├── 控制任务量、防止 OOM（内存溢出）
│   └── 适合任务执行较慢，线程池必须保护系统资源的场景
└── 使用建议
   ├── 最常与 ThreadPoolExecutor 配合使用
   └── 配合合理的 corePoolSize、maximumPoolSize 可控压力
```

**🔗 LinkedBlockingQueue（链表无界队列）**
```java
new LinkedBlockingQueue<Runnable>()

LinkedBlockingQueue
├── 特性
│   ├── 无界（默认 Integer.MAX_VALUE），也可指定容量
│   ├── FIFO 队列，基于链表实现
│   └── 插入和移除操作互不阻塞，提高吞吐率
├── 适用场景
│   ├── 任务提交频繁但执行较快
│   └── 容忍排队但线程数受限的场景
└── 注意事项
   ├── 可能导致任务堆积，占满内存
   └── 使用 Executors.newFixedThreadPool() 时默认使用该队列
```

**⚡ SynchronousQueue（同步队列）**
```java
new SynchronousQueue<Runnable>()

SynchronousQueue
├── 特性
│   ├── 不存储任务，提交任务时必须直接被线程接收
│   ├── 每个插入操作都要等一个线程来取出（否则阻塞）
│   └── 高吞吐、低延迟，适合任务特别轻量且并发极高
├── 适用场景
│   ├── 任务执行时间短、响应实时性高
│   └── 线程池规模需动态扩展
└── 注意事项
   └── 配合 maximumPoolSize 必须足够大，否则容易触发拒绝策略
```

**🎯 PriorityBlockingQueue（优先级阻塞队列）**
```java
new PriorityBlockingQueue<Runnable>()

PriorityBlockingQueue
├── 特性
│   ├── 支持按任务优先级排序（必须实现 Comparable）
│   ├── 非 FIFO，优先级高的任务先执行
│   └── 无界，线程安全，可能堆积任务
├── 适用场景
│   ├── 有明确优先级要求的异步任务系统
│   └── 比如订单处理、调度系统、限流控制等
└── 注意事项
   ├── 若所有任务优先级一样，则近似 FIFO
   └── 内存不可控，建议配合任务限速机制使用
```

**⏰ DelayQueue（延时队列）**
```java
new DelayQueue<Delayed>()

DelayQueue
├── 特性
│   ├── 所有任务都要实现 Delayed 接口
│   └── 只有到期后才允许取出任务执行（按时间顺序）
├── 适用场景
│   └── 适用于定时任务调度、延时重试、过期清理
└── 注意事项
   ├── 不适合高并发常规线程池使用
   └── 更多用于调度系统或自定义调度线程池
```

### 6.2 队列对比总结


| **队列类型** | **是否有界** | **是否排序** | **典型用途** | **注意事项** |
|-------------|-------------|-------------|-------------|-------------|
| **`ArrayBlockingQueue`** | ✅ 是 | FIFO | 控制任务数量，防止 OOM | 队列满可能触发拒绝策略 |
| **`LinkedBlockingQueue`** | ❌ 否 | FIFO | 通用任务排队，吞吐高 | 默认无界，可能任务堆积 |
| **`SynchronousQueue`** | ✅（0） | 无 | 轻任务高并发实时处理 | 无法缓存，线程必须及时响应 |
| **`PriorityBlockingQueue`** | ❌ 否 | ✅ 支持 | 按优先级调度任务 | 必须实现 Comparable，注意内存溢出 |
| **`DelayQueue`** | ❌ 否 | ✅ 按到期时间 | 延时任务、定时任务 | 需实现 Delayed，不适合常规线程池使用 |

### 6.3 实战推荐搭配


| **使用需求** | **推荐队列类型** |
|-------------|-----------------|
| **控制资源 / 任务多且慢** | `ArrayBlockingQueue` |
| **普通异步任务（不特别重）** | `LinkedBlockingQueue` |
| **短小任务 / 高频请求** | `SynchronousQueue` |
| **任务优先级差异大** | `PriorityBlockingQueue` |
| **延迟执行任务** | `DelayQueue` |

> 💡 **选择建议**：生产环境推荐使用 `ArrayBlockingQueue` 有界队列，避免内存溢出风险。


## 7. 🚫 拒绝策略详解


### 7.1 拒绝策略触发条件


**⚠️ 触发条件**
```
拒绝策略触发时机：当线程池同时满足以下两个条件时
├── 📊 当前线程数已达到 maximumPoolSize
└── 📦 工作队列已满，无法容纳更多任务

此时由 RejectedExecutionHandler 决定如何处理这个"新任务"
```

### 7.2 四种内置拒绝策略


**🚨 AbortPolicy（默认策略）**
```java
new ThreadPoolExecutor.AbortPolicy()

✅ 行为：直接抛出 RejectedExecutionException 异常，阻止程序继续执行
✅ 特点：是默认策略，对系统是最安全的策略，会立刻暴露线程池资源不足问题
⚠️ 使用建议：用于对服务稳定性要求高的场景（必须处理所有任务，不允许任务丢失）

示例代码：
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1, 0L, TimeUnit.MILLISECONDS,
    new ArrayBlockingQueue<>(1),
    new ThreadPoolExecutor.AbortPolicy()
);
```

**🔄 CallerRunsPolicy**
```java
new ThreadPoolExecutor.CallerRunsPolicy()

✅ 行为：由调用线程（提交任务的线程）自己执行该任务，不抛异常，也不交由线程池处理
✅ 特点：可以缓解线程池压力，起到"削峰填谷"的作用，让提交任务的速度慢下来
⚠️ 使用建议：适用于异步任务中不允许丢失任务，但可以接受延迟的情况

优势：任务不会丢失，提供了一种优雅的降级机制
```

**🗑️ DiscardPolicy**
```java
new ThreadPoolExecutor.DiscardPolicy()

✅ 行为：直接丢弃新提交的任务，无异常、无提示
✅ 特点：非常"安静"，但可能造成任务悄无声息地丢失
⚠️ 使用建议：适合可以容忍任务丢失的日志、统计、采样类系统

注意：不推荐用于对任务可靠性有要求的业务
```

**🔄 DiscardOldestPolicy**
```java
new ThreadPoolExecutor.DiscardOldestPolicy()

✅ 行为：丢弃队列中最早的任务（头部任务），然后尝试重新提交当前任务
✅ 特点：保留最新任务，但牺牲旧任务，适合高优先级新任务覆盖旧任务的场景
⚠️ 使用建议：适合实时性要求高，最新任务更重要的系统，例如 UI 刷新、行情推送

工作流程：队列满时 → 移除队列头部任务 → 尝试加入新任务
```

### 7.3 拒绝策略对比总结


| **策略** | **行为** | **是否抛异常** | **是否丢任务** | **使用场景建议** |
|---------|---------|---------------|---------------|-----------------|
| **🚨 `AbortPolicy`** | 抛异常 | ✅ 是 | ❌ 否 | 默认策略，适合不能容忍任务丢失的系统 |
| **🔄 `CallerRunsPolicy`** | 由调用线程执行 | ❌ 否 | ❌ 否 | 控制流速，适合可延迟但不能丢失的任务 |
| **🗑️ `DiscardPolicy`** | 直接丢弃新任务，无任何提示 | ❌ 否 | ✅ 是 | 日志、监控、采样等低价值任务 |
| **🔄 `DiscardOldestPolicy`** | 丢掉队列中最旧任务，再尝试提交 | ❌ 否 | ✅ 是 | 实时系统、最新数据优先场景 |

### 7.4 自定义拒绝策略


```java
// 自定义拒绝策略示例：记录日志 + 告警
public class CustomRejectedHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 记录拒绝日志
        System.err.println("任务被拒绝: " + r.toString());
        System.err.println("线程池状态: 活跃线程=" + executor.getActiveCount() + 
                          ", 队列大小=" + executor.getQueue().size());
        
        // 可以在这里添加告警机制
        // alertService.sendAlert("线程池任务被拒绝");
        
        // 可选：尝试其他处理方式
        // 1. 记录到失败队列中
        // 2. 发送到消息队列
        // 3. 写入数据库待后续处理
    }
}

// 使用自定义拒绝策略
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new CustomRejectedHandler()
);
```

---

## 8. 🛠️ ThreadPoolExecutor常用方法


### 8.1 任务提交与执行方法


```
ThreadPoolExecutor 常用方法详解
├── 🎯 一、任务提交与执行
│   ├── execute(Runnable task)
│   │   └── 执行任务但不返回结果，适合不关心返回值的任务（fire-and-forget）
│   │
│   ├── submit(Runnable/Callable task)
│   │   ├── 返回 Future 对象，可通过 get() 获取执行结果或判断状态
│   │   └── 支持 Callable（有返回值）与 Runnable（返回 null）类型
│   │
│   ├── invokeAll(Collection<Callable>)
│   │   └── 批量提交多个 Callable 任务，阻塞直到所有任务执行完，返回 Future 列表
│   │
│   └── invokeAny(Collection<Callable>)
│       └── 同时提交多个任务，谁先完成就返回谁的结果，其余任务自动取消（高效）
```

**💻 任务提交方法代码示例**

```java
// ✅ 1. execute(Runnable task)
public class ExecuteExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // 提交任务但不关心返回值
        executor.execute(() -> System.out.println("执行 execute() 任务"));

        executor.shutdown();
    }
}

// ✅ 2. submit(Runnable/Callable task)
public class SubmitExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // 提交任务并获取 Future，可拿到结果
        Future<String> future = executor.submit(() -> "执行 submit()");

        System.out.println("任务结果：" + future.get());

        executor.shutdown();
    }
}

// ✅ 3. invokeAll(Collection<Callable>)
public class InvokeAllExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        List<Callable<String>> tasks = Arrays.asList(
            () -> "任务1", () -> "任务2", () -> "任务3"
        );

        // 提交所有任务，并阻塞直到全部完成
        List<Future<String>> results = executor.invokeAll(tasks);

        for (Future<String> result : results) {
            System.out.println(result.get());
        }

        executor.shutdown();
    }
}

// ✅ 4. invokeAny(Collection<Callable>)
public class InvokeAnyExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        List<Callable<String>> tasks = Arrays.asList(
            () -> "最快完成的任务",
            () -> { Thread.sleep(1000); return "慢任务"; }
        );

        // 返回最先完成的任务结果
        String result = executor.invokeAny(tasks);
        System.out.println("最先完成的任务结果：" + result);

        executor.shutdown();
    }
}
```

### 8.2 线程池关闭与状态控制


```
├── 🔐 二、线程池关闭与状态控制
│   ├── shutdown()
│   │   ├── 平缓关闭线程池：不再接受新任务
│   │   └── 等待已提交任务执行完成
│   │
│   ├── shutdownNow()
│   │   ├── 立即关闭线程池：尝试中断正在执行的线程
│   │   └── 返回尚未开始执行的任务列表
│   │
│   ├── isShutdown()
│   │   └── 判断是否已调用 shutdown()/shutdownNow()
│   │
│   └── isTerminated()
│       └── 判断线程池是否彻底关闭（所有任务已完成 + 所有线程退出）
```

**🔐 关闭方法代码示例**

```java
// ✅ 5. shutdown()
public class ShutdownExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.submit(() -> System.out.println("执行任务"));

        // 平缓关闭：已提交的任务继续执行，不再接受新任务
        executor.shutdown();
    }
}

// ✅ 6. shutdownNow()
public class ShutdownNowExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.submit(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                System.out.println("任务被中断");
            }
        });

        // 强制关闭线程池，试图中断正在执行的任务
        List<Runnable> unfinishedTasks = executor.shutdownNow();
        System.out.println("未完成的任务数: " + unfinishedTasks.size());
    }
}

// ✅ 7. isShutdown() & ✅ 8. isTerminated()
public class StatusExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        executor.submit(() -> System.out.println("任务执行中"));
        executor.shutdown();

        System.out.println("是否已 shutdown: " + executor.isShutdown());
        System.out.println("是否已 terminated: " + executor.isTerminated());
    }
}
```

### 8.3 线程池等待与核心线程管理


```
├── ⏰ 三、线程池等待控制
│   └── awaitTermination(long timeout, TimeUnit unit)
│       ├── 在 shutdown 后调用
│       ├── 最多等待指定时间让线程池关闭
│       └── 返回 true 表示已完全关闭，false 表示超时未关闭
│
├── 🔧 四、核心线程管理
│   ├── prestartCoreThread()
│   │   └── 启动一个核心线程（空闲时保持存活，任务到来立即处理）
│   │
│   └── prestartAllCoreThreads()
│       └── 启动所有核心线程，适合高并发初始化阶段预热线程
```

**⏰ 等待与核心线程管理示例**

```java
// ✅ 9. awaitTermination(timeout, unit)
public class AwaitTerminationExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        executor.submit(() -> {
            try { Thread.sleep(1000); } catch (InterruptedException e) {}
        });

        executor.shutdown();

        // 最长等 2 秒等线程池任务结束
        if (executor.awaitTermination(2, TimeUnit.SECONDS)) {
            System.out.println("线程池已关闭");
        } else {
            System.out.println("等待超时");
        }
    }
}

// ✅ 10. prestartCoreThread()
public class PrestartCoreThreadExample {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>()
        );

        // 提前启动一个核心线程
        boolean started = executor.prestartCoreThread();
        System.out.println("核心线程启动成功: " + started);

        executor.shutdown();
    }
}

// ✅ 11. prestartAllCoreThreads()
public class PrestartAllCoreThreadsExample {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>()
        );

        // 启动所有核心线程，适用于预热线程池
        int startedThreads = executor.prestartAllCoreThreads();
        System.out.println("启动的核心线程数: " + startedThreads);

        executor.shutdown();
    }
}
```

### 8.4 线程池参数动态设置与监控


```
├── 🎛️ 五、线程池参数动态设置
│   ├── setCorePoolSize(int coreSize)
│   │   └── 动态修改核心线程数（可在线调整系统吞吐能力）
│   │
│   └── setMaximumPoolSize(int maxSize)
│       └── 动态设置线程池最大线程数（含核心 + 非核心线程）
│
├── 📊 六、线程状态监控方法
│   ├── getPoolSize()
│   │   └── 获取当前线程池中线程的总数量（包括核心和非核心）
│   │
│   ├── getActiveCount()
│   │   └── 获取当前正在执行任务的线程数（活跃线程）
│   │
│   ├── getTaskCount()
│   │   └── 获取线程池接收的总任务数（包括已完成、正在执行、等待中）
│   │
│   └── getCompletedTaskCount()
│       └── 获取线程池中已完成的任务总数
```

**🎛️ 动态设置与监控示例**

```java
// ✅ 12. setCorePoolSize(int) & ✅ 13. setMaximumPoolSize(int)
public class SetSizeExample {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>()
        );

        // 动态调整线程池参数
        executor.setCorePoolSize(3);
        executor.setMaximumPoolSize(5);

        System.out.println("新的核心线程数: " + executor.getCorePoolSize());
        System.out.println("新的最大线程数: " + executor.getMaximumPoolSize());

        executor.shutdown();
    }
}

// ✅ 14~17. getPoolSize() / getActiveCount() / getTaskCount() / getCompletedTaskCount()
public class MonitoringExample {
    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>()
        );

        // 提交一些任务
        for (int i = 0; i < 5; i++) {
            executor.submit(() -> {
                try { Thread.sleep(1000); } catch (InterruptedException e) {}
            });
        }

        // 查询线程池状态信息
        System.out.println("当前线程数: " + executor.getPoolSize());
        System.out.println("活跃线程数: " + executor.getActiveCount());
        System.out.println("任务总数: " + executor.getTaskCount());
        System.out.println("已完成任务数: " + executor.getCompletedTaskCount());
        System.out.println("队列中等待任务数: " + executor.getQueue().size());

        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);
        
        System.out.println("关闭后已完成任务数: " + executor.getCompletedTaskCount());
    }
}
```

---

## 9. 🏭 自定义线程工厂


### 9.1 ThreadFactory基本概念


```java
/**
 * ThreadFactory 基本概念
 * - ThreadFactory 是 Java 提供的一个接口，位于 java.util.concurrent 包中
 * - 用于自定义创建线程的方式，替代默认线程创建方式
 * - 功能：实现对线程属性的定制，便于线程监控、问题诊断和线程资源管理
 */
```

### 9.2 自定义线程工厂实现


```java
/**
 * 自定义线程工厂实现
 * - 优势：便于线程监控、问题诊断和线程资源管理
 */
public class CustomThreadFactory implements ThreadFactory {
    private final String namePrefix;                    // 线程名称前缀
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final ThreadGroup group;                    // 线程组
    private final int priority;                         // 线程优先级
    private final boolean daemon;                       // 是否为守护线程

    /**
     * 构造自定义线程工厂
     * 
     * @param namePrefix 线程名称前缀，用于标识业务
     * @param priority 线程优先级(1-10)
     * @param daemon 是否设置为守护线程
     */
    public CustomThreadFactory(String namePrefix, int priority, boolean daemon) {
        this.namePrefix = namePrefix;
        this.priority = priority;
        this.daemon = daemon;
        
        // 获取当前线程的线程组
        SecurityManager s = System.getSecurityManager();
        this.group = (s != null) ? s.getThreadGroup() : 
                                 Thread.currentThread().getThreadGroup();
    }
    
    /**
     * 创建新线程
     * 
     * @param r 线程要执行的任务
     * @return 定制化的新线程
     */
    @Override
    public Thread newThread(Runnable r) {
        // 创建线程并指定线程名称
        Thread thread = new Thread(group, r, 
                namePrefix + "-thread-" + threadNumber.getAndIncrement(), 
                0);
        
        // 设置线程优先级
        if (priority > 0) {
            thread.setPriority(priority);
        }
        
        // 设置是否为守护线程
        thread.setDaemon(daemon);
        
        // 设置异常处理器
        thread.setUncaughtExceptionHandler((t, e) -> {
            System.err.println("线程" + t.getName() + "发生异常: " + e.getMessage());
            e.printStackTrace();
        });
        
        return thread;
    }
}
```

### 9.3 线程工厂使用示例


```java
// 基础版本的自定义线程工厂
public class SimpleThreadFactory implements ThreadFactory {
    private int count = 0;
    private String namePrefix;

    public SimpleThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + "-thread-" + count++);
        t.setDaemon(false); // 设置为用户线程
        t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}

// 使用示例
public class ThreadFactoryExample {
    public static void main(String[] args) {
        // 创建自定义线程工厂 
        ThreadFactory factory = new CustomThreadFactory(
            "order-service",       // 业务名称前缀
            Thread.NORM_PRIORITY,  // 普通优先级
            false                  // 非守护线程
        );

        // 使用自定义线程工厂创建线程池
        ExecutorService pool = new ThreadPoolExecutor(
            5,
            10,
            60,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(),
            factory  // 使用自定义线程工厂
        );

        // 提交任务
        for (int i = 0; i < 3; i++) {
            int taskId = i;
            pool.submit(() -> {
                System.out.println("任务" + taskId + " 由线程 " + 
                                 Thread.currentThread().getName() + " 执行");
            });
        }

        pool.shutdown();
    }
}
```

### 9.4 线程工厂参数说明


| **参数** | **类型** | **说明** |
|---------|---------|----------|
| **namePrefix** | String | 线程名称前缀，用于标识线程池来源，便于日志与问题定位 |
| **count / threadId** | AtomicInteger 或 int | 自增线程编号，确保线程名称唯一 |
| **daemon** | boolean | 是否设置为守护线程，默认 false，设为 true 会在主线程结束后强制结束 |
| **priority** | int | 线程优先级（1~10），默认 Thread.NORM_PRIORITY（5） |
| **threadGroup** | ThreadGroup | 所属线程组，可用于线程隔离和统一管理 |

### 9.5 线程工厂的价值


**💡 使用自定义线程工厂的好处**
```
自定义线程工厂的价值
├── 🏷️ 线程命名规范
│   ├── 便于日志分析和问题定位
│   └── 可以区分不同业务模块的线程
├── 🛡️ 异常处理统一
│   ├── 设置统一的异常处理器
│   └── 避免线程异常被静默吞掉
├── 📊 线程属性定制
│   ├── 设置线程优先级
│   ├── 设置守护线程属性
│   └── 设置线程组便于管理
└── 🔍 监控与统计
    ├── 统计创建的线程数量
    ├── 监控线程创建速度
    └── 便于集成监控系统
```

---

## 10. 🎛️ 核心参数调优策略


### 10.1 线程池参数调优总览


```java
线程池参数调优
├── 🎯 核心参数配置
│   ├── corePoolSize (核心线程数)
│   │   ├── CPU密集型任务: 配置为CPU核心数(N)或N+1
│   │   ├── IO密集型任务: 配置为2N或2N+1
│   │   ├── 混合型任务: 根据IO阻塞时间占比适当增加
│   │   └── 动态调整: 低峰期较少，高峰期较多
│   │
│   ├── maximumPoolSize (最大线程数)
│   │   ├── 考虑因素
│   │   │   ├── 系统内存大小
│   │   │   ├── 任务执行时间
│   │   │   ├── 任务优先级
│   │   │   └── 线程切换开销
│   │   │
│   │   ├── 短期突发任务: 可设置较大值
│   │   ├── 长期稳定任务: 接近核心线程数
│   │   └── 警戒线: 避免超过系统最大线程数(通常几百)
│   │
│   ├── keepAliveTime (空闲线程存活时间)
│   │   ├── 短任务场景: 较短时间(如30秒)
│   │   ├── 任务频率变化大: 中等时间(如60秒)
│   │   ├── 任务突发性强: 较长时间(如120秒)
│   │   └── 特殊情况: 允许核心线程超时(allowCoreThreadTimeOut)
│   │
│   └── workQueue (工作队列)
│       ├── ArrayBlockingQueue: 有界队列，适合任务量可预知场景
│       ├── LinkedBlockingQueue: 无界队列，防止任务拒绝但需注意OOM
│       ├── SynchronousQueue: 不存储任务，适合快速处理场景
│       ├── PriorityBlockingQueue: 优先级队列，适合任务优先级不同场景
│       └── DelayQueue: 延迟队列，适合定时任务场景
```

### 10.2 不同场景的配置建议


```
├── 🚫 拒绝策略选择
│   ├── AbortPolicy: 抛出异常，适合快速失败场景
│   ├── CallerRunsPolicy: 调用者执行，适合负载均衡场景
│   ├── DiscardPolicy: 丢弃新任务，适合允许丢失部分任务场景
│   ├── DiscardOldestPolicy: 丢弃最旧任务，适合实时性要求高场景
│   └── 自定义拒绝策略: 实现RejectedExecutionHandler接口
│
└── 🎨 常见使用场景配置
    ├── 🌐 Web服务器
    │   ├── corePoolSize: 2N+1 (N为CPU核心数)
    │   ├── maximumPoolSize: 2N+1到4N之间
    │   ├── keepAliveTime: 60秒
    │   └── 队列: 有界ArrayBlockingQueue(1000-5000)
    │
    ├── 🧮 计算密集型应用
    │   ├── corePoolSize: N或N+1
    │   ├── maximumPoolSize: N+1
    │   ├── keepAliveTime: 30秒
    │   └── 队列: 较小的有界队列
    │
    ├── 💾 IO密集型应用
    │   ├── corePoolSize: 2N至5N
    │   ├── maximumPoolSize: 5N至10N
    │   ├── keepAliveTime: 60至120秒
    │   └── 队列: 较大的有界队列或无界队列
    │
    ├── ⏰ 定时任务系统
    │   ├── corePoolSize: N至2N
    │   ├── maximumPoolSize: 2N至4N
    │   ├── keepAliveTime: 300秒
    │   └── 队列: DelayQueue或PriorityBlockingQueue
    │
    └── 📊 批处理系统
        ├── corePoolSize: N+1
        ├── maximumPoolSize: 2N或更多
        ├── keepAliveTime: 120秒
        └── 队列: 根据批处理量设置合适大小的有界队列
```

### 10.3 核心参数调优建议表


| **参数** | **调优建议** |
|---------|-------------|
| **`corePoolSize`** | 设置为：<br>**CPU 密集型**：`N`（CPU 核数）<br>**I/O 密集型**：`2N+1` 或更高 |
| **`maximumPoolSize`** | 通常为 `corePoolSize * 2` 或根据业务/内存合理上限 |
| **`keepAliveTime`** | 设置非核心线程空闲多久后回收，节省资源（通常 30~60 秒） |
| **`workQueue`** | 推荐使用 `ArrayBlockingQueue` 有界队列控制并发压力 |
| **`threadFactory`** | 建议自定义线程命名，便于排查问题（如业务模块 + 编号） |
| **`handler`** | 推荐使用 `CallerRunsPolicy` 或自定义策略来保证任务不丢失 |

### 10.4 参数调优实践示例


```java
// CPU密集型任务线程池配置
public class CpuIntensiveThreadPool {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    
    public static ThreadPoolExecutor createCpuIntensivePool() {
        return new ThreadPoolExecutor(
            CPU_COUNT,                                    // 核心线程数 = CPU核数
            CPU_COUNT + 1,                               // 最大线程数
            30L, TimeUnit.SECONDS,                       // 空闲线程存活30秒
            new ArrayBlockingQueue<>(100),               // 有界队列
            new CustomThreadFactory("cpu-intensive"),     // 自定义线程工厂
            new ThreadPoolExecutor.CallerRunsPolicy()    // 调用者执行策略
        );
    }
}

// IO密集型任务线程池配置
public class IoIntensiveThreadPool {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    
    public static ThreadPoolExecutor createIoIntensivePool() {
        return new ThreadPoolExecutor(
            CPU_COUNT * 2,                               // 核心线程数 = CPU核数 * 2
            CPU_COUNT * 4,                               // 最大线程数
            60L, TimeUnit.SECONDS,                       // 空闲线程存活60秒
            new ArrayBlockingQueue<>(1000),              // 较大的有界队列
            new CustomThreadFactory("io-intensive"),      // 自定义线程工厂
            new ThreadPoolExecutor.CallerRunsPolicy()    // 调用者执行策略
        );
    }
}

// 混合型任务线程池配置
public class MixedTaskThreadPool {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    
    public static ThreadPoolExecutor createMixedPool() {
        return new ThreadPoolExecutor(
            CPU_COUNT + 1,                               // 核心线程数
            CPU_COUNT * 2 + 1,                          // 最大线程数
            60L, TimeUnit.SECONDS,                       // 空闲线程存活60秒
            new ArrayBlockingQueue<>(500),               // 中等大小有界队列
            new CustomThreadFactory("mixed-task"),       // 自定义线程工厂
            new ThreadPoolExecutor.CallerRunsPolicy()    // 调用者执行策略
        );
    }
}
```

---

## 11. ⚠️ 线程池异常处理机制


### 11.1 异常处理路径分析


```
任务提交方式：      execute()               submit()
                      │                        │
                ┌────▼────┐            ┌──────▼───────┐
                │ 异常直接抛出 │            │ 异常封装在 Future │
                └────┬────┘            └──────┬────────┘
                     │                         │
       ┌────────────▼────────────┐   ┌────────▼────────┐
       │ 默认会被吞掉无提示（❌） │   │ 通过 future.get() 捕获（✅） │
       └────────────┬────────────┘   └─────────────────┘
                    │
          ┌────────▼─────────┐
          │ afterExecute() 中捕获 │
          └──────────────────┘

其他补救手段：使用 ThreadFactory 设置 UncaughtExceptionHandler（仅对 execute 有效）

      ┌───────────────┬───────────────────┐
      │               │                   │
 execute()       submit()           钩子机制处理（增强方式）
   │               │                         │
   ▼               ▼                         ▼
异常直接抛出   异常封装在 Future       afterExecute() / UncaughtExceptionHandler
   │               │                         │
被吞掉（❌）     future.get() 捕获（✅）   可捕获处理（✅）
```

### 11.2 推荐异常处理组合


| **使用方式** | **推荐组合** |
|-------------|-------------|
| **使用 `execute()`** | 1. 重写 `afterExecute()` 方法<br>2. 自定义 `ThreadFactory` 设置异常处理器 |
| **使用 `submit()`** | 1. 使用 `future.get()` 处理异常<br>2. 捕获 `ExecutionException.getCause()` |

### 11.3 异常处理代码示例


**✅ 方式一：submit() + future.get() 捕获异常（推荐方式）**
```java
public class SubmitExceptionExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(1);

        // 使用 submit 提交任务，异常被包装在 Future 中
        Future<?> future = executor.submit(() -> {
            throw new RuntimeException("submit 内部异常");
        });

        try {
            future.get(); // 调用 get() 会抛出 ExecutionException
        } catch (ExecutionException e) {
            System.out.println("捕获 submit 异常：" + e.getCause().getMessage());
        } catch (InterruptedException ignored) {}

        executor.shutdown();
    }
}
```

**✅ 方式二：重写 afterExecute() 捕获异常（适用于 execute 和 submit）**
```java
public class AfterExecuteExample {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 0, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>()
        ) {
            // 重写 afterExecute 处理执行异常
            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                super.afterExecute(r, t);

                if (t != null) {
                    System.out.println("afterExecute 捕获异常：" + t.getMessage());
                }

                if (r instanceof Future<?>) {
                    try {
                        ((Future<?>) r).get(); // 提取 submit 中的异常
                    } catch (Exception e) {
                        System.out.println("afterExecute 中 Future 异常：" + e.getCause().getMessage());
                    }
                }
            }
        };

        // 无论是 execute 还是 submit 都可通过 afterExecute 捕获
        executor.submit(() -> { throw new RuntimeException("任务异常"); });

        executor.shutdown();
    }
}
```

**✅ 方式三：使用 UncaughtExceptionHandler（仅对 execute() 有效）**
```java
public class UncaughtHandlerExample {
    public static void main(String[] args) {
        // 自定义线程工厂设置异常处理器
        ThreadFactory factory = runnable -> {
            Thread t = new Thread(runnable);
            t.setUncaughtExceptionHandler((thread, ex) -> {
                System.out.println("捕获线程异常：" + ex.getMessage());
            });
            return t;
        };

        ExecutorService executor = new ThreadPoolExecutor(
            1, 1, 0, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(),
            factory
        );

        // 使用 execute 提交，抛出异常但被线程处理器捕获
        executor.execute(() -> {
            throw new RuntimeException("execute 异常");
        });

        executor.shutdown();
    }
}
```

---

## 12. 📊 线程池监控与调优


### 12.1 线程池运行时监控指标


| **方法** | **含义** | **监控价值** |
|---------|---------|-------------|
| **`getPoolSize()`** | 当前线程池中线程总数（包括空闲+活动） | 监控线程池规模变化 |
| **`getActiveCount()`** | 当前正在执行任务的线程数（活跃线程） | 监控系统繁忙程度 |
| **`getQueue().size()`** | 当前等待执行的任务数 | 监控任务积压情况 |
| **`getCompletedTaskCount()`** | 执行完成的任务总数 | 统计处理能力 |
| **`getTaskCount()`** | 提交给线程池的任务总数 | 统计总负载 |
| **`isShutdown()`** | 是否已调用 `shutdown()` | 监控线程池状态 |
| **`isTerminated()`** | 所有任务执行完毕且线程池已关闭 | 确认完全关闭 |

### 12.2 线程池监控实现


```java
public class ThreadPoolMonitor {
    private final ThreadPoolExecutor executor;
    private final ScheduledExecutorService monitorExecutor;
    
    public ThreadPoolMonitor(ThreadPoolExecutor executor) {
        this.executor = executor;
        this.monitorExecutor = Executors.newScheduledThreadPool(1);
    }
    
    /**
     * 启动定期监控
     */
    public void startMonitoring() {
        monitorExecutor.scheduleAtFixedRate(() -> {
            printThreadPoolStatus();
        }, 0, 5, TimeUnit.SECONDS);
    }
    
    /**
     * 打印线程池状态
     */
    private void printThreadPoolStatus() {
        System.out.println("=== 线程池监控信息 ===");
        System.out.println("核心线程数: " + executor.getCorePoolSize());
        System.out.println("最大线程数: " + executor.getMaximumPoolSize());
        System.out.println("当前线程数: " + executor.getPoolSize());
        System.out.println("活跃线程数: " + executor.getActiveCount());
        System.out.println("队列任务数: " + executor.getQueue().size());
        System.out.println("已完成任务: " + executor.getCompletedTaskCount());
        System.out.println("总任务数: " + executor.getTaskCount());
        System.out.println("拒绝任务数: " + getRejectedTaskCount());
        System.out.println("================================");
    }
    
    // 自定义拒绝策略来统计拒绝任务数
    private static class MonitorRejectedHandler implements RejectedExecutionHandler {
        private final AtomicLong rejectedCount = new AtomicLong(0);
        
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            rejectedCount.incrementAndGet();
            // 执行默认拒绝策略或自定义处理
            new ThreadPoolExecutor.CallerRunsPolicy().rejectedExecution(r, executor);
        }
        
        public long getRejectedCount() {
            return rejectedCount.get();
        }
    }
}
```

### 12.3 调优建议总结


**🔧 调优策略**

| **关注点** | **调优建议** |
|-----------|-------------|
| **📦 队列长度** | 有界队列防止内存爆炸，推荐 `ArrayBlockingQueue` |
| **🚫 拒绝策略** | 不建议用默认 `AbortPolicy`，推荐 `CallerRunsPolicy` 或自定义记录异常 |
| **🧵 核心/最大线程数** | CPU 密集/IO 密集分开设计，不盲目追求线程数高 |
| **🏷️ 命名/日志** | 自定义 `ThreadFactory` 添加线程命名 & 异常处理器 |
| **📊 实时监控** | `getActiveCount()` + `getQueue().size()` 结合日志采集 |

**⚠️ 常见调优陷阱**

| **错误配置** | **后果** |
|-------------|---------|
| **无界队列 + 小线程数** | 所有任务进队列，线程永远不扩展，性能瓶颈 |
| **大线程数 + 大队列** | 线程调度成本高、频繁上下文切换、可能内存溢出 |
| **不设拒绝策略或默认策略** | 抛异常不易捕获，任务丢失或系统直接 crash |
| **不监控运行状态** | 线程死锁、阻塞、拒绝任务可能长期未察觉 |

---

## 13. ⛔ 常见误区与最佳实践


### 13.1 典型误区与正确做法


```java
线程池常见配置误区与正确做法
├── ① 使用 Executors 创建线程池
│   ├── ❌ 问题：默认使用无界队列或无限线程
│   ├── ⚠️ 后果：可能造成内存溢出（OOM）
│   └── ✅ 建议：显式使用 ThreadPoolExecutor 构造器，手动设置核心参数
│
├── ② 忽视任务异常处理
│   ├── ❌ 问题：使用 execute() 提交任务异常被吞，不报错
│   ├── ⚠️ 后果：业务逻辑失败却毫无察觉
│   └── ✅ 建议：
│       ├── 对 execute 使用 afterExecute() 捕获异常
│       └── 对 submit 使用 future.get() 获取 ExecutionException
│
├── ③ 不设置拒绝策略
│   ├── ❌ 问题：默认 AbortPolicy 抛出 RejectedExecutionException
│   ├── ⚠️ 后果：线程池满时系统直接中断，造成业务异常
│   └── ✅ 建议：
│       ├── 使用 CallerRunsPolicy 降级处理
│       └── 或实现自定义 RejectedExecutionHandler 做日志记录、告警
│
├── ④ 队列和线程数配比不合理
│   ├── ❌ 问题：
│       ├── 队列过大 → 线程不扩容，任务堆积
│       └── 线程数过多 → 上下文切换频繁
│   ├── ⚠️ 后果：吞吐下降或响应变慢
│   └── ✅ 建议：根据压测结果动态调整参数，合理搭配
│
├── ⑤ 忽略线程命名与日志
│   ├── ❌ 问题：默认线程名无意义
│   ├── ⚠️ 后果：异常难定位，难以快速诊断问题线程
│   └── ✅ 建议：自定义 ThreadFactory 设置线程名和日志前缀
│
├── ⑥ 固定线程数处理可变流量
│   ├── ❌ 问题：线程池配置死板，缺乏弹性
│   ├── ⚠️ 后果：
│       ├── 高峰期：线程数不够，响应慢或任务被拒绝
│       └── 低谷期：资源浪费
│   └── ✅ 建议：结合限流器 + 动态线程池 + 调度中心实现弹性伸缩
│
└── ⑦ 关闭线程池只调用 shutdown()
    ├── ❌ 问题：未等待任务真正完成
    ├── ⚠️ 后果：正在处理中的任务被强行终止
    └── ✅ 建议：
        ├── shutdown() 后，调用 awaitTermination() 等待执行完毕
        └── 或使用 CountDownLatch 等方式主动阻塞主线程
```

### 13.2 必须遵循的注意事项


| **问题/事项** | **说明** |
|-------------|----------|
| **🔗 `corePoolSize` 与 `maximumPoolSize` 的关系** | `corePoolSize` 保证线程池最小线程数，`maximumPoolSize` 用于最大扩容 |
| **🚫 线程池拒绝策略要考虑实际场景** | 如高并发任务场景下选择 `CallerRunsPolicy`，确保任务不会丢失 |
| **⚡ 避免过度扩容线程池** | 过大的 `maximumPoolSize` 会导致大量线程争夺资源 |
| **🗑️ 线程池内存泄漏** | 使用完线程池后，调用 `shutdown()` 释放资源，避免内存泄漏 |

### 13.3 最佳实践组合建议


| **场景** | **配置建议** |
|---------|-------------|
| **🌐 高并发请求处理** | 核心线程适中 + 有界队列 + 拒绝策略为 CallerRunsPolicy |
| **⏰ 定时或周期任务** | 使用 `ScheduledThreadPoolExecutor` 替代 Timer |
| **💾 阻塞任务多 / IO 密集型服务** | 增加核心线程数，使用 `LinkedBlockingQueue(容量)` |
| **🛍️ 短时间爆发式请求（秒杀类）** | `SynchronousQueue` + 最大线程数放大 |
| **🛡️ 需降级限流保护业务** | 自定义 `RejectedExecutionHandler` 实现降级或报警 |

### 13.4 完整的生产级线程池示例


```java
/**
 * 生产级线程池配置示例
 */
public class ProductionThreadPoolExample {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    
    public static ThreadPoolExecutor createProductionPool(String poolName) {
        // 自定义线程工厂
        ThreadFactory threadFactory = new ThreadFactory() {
            private final AtomicInteger threadNumber = new AtomicInteger(1);
            
            @Override
            public Thread newThread(Runnable r) {
                Thread t = new Thread(r, poolName + "-thread-" + threadNumber.getAndIncrement());
                t.setDaemon(false);
                t.setPriority(Thread.NORM_PRIORITY);
                
                // 设置异常处理器
                t.setUncaughtExceptionHandler((thread, ex) -> {
                    System.err.println("Thread " + thread.getName() + " threw exception: " + ex);
                    ex.printStackTrace();
                });
                
                return t;
            }
        };
        
        // 自定义拒绝策略
        RejectedExecutionHandler handler = new RejectedExecutionHandler() {
            private final AtomicLong rejectedCount = new AtomicLong(0);
            
            @Override
            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                long count = rejectedCount.incrementAndGet();
                System.err.println("Task rejected, count: " + count + ", pool: " + poolName);
                
                // 尝试加入队列，如果还是失败则由调用者执行
                if (!executor.getQueue().offer(r)) {
                    new ThreadPoolExecutor.CallerRunsPolicy().rejectedExecution(r, executor);
                }
            }
        };
        
        // 创建线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            CPU_COUNT * 2,                               // 核心线程数
            CPU_COUNT * 4,                               // 最大线程数
            60L, TimeUnit.SECONDS,                       // 空闲线程存活时间
            new ArrayBlockingQueue<>(1000),              // 有界队列
            threadFactory,                               // 自定义线程工厂
            handler                                      // 自定义拒绝策略
        ) {
            // 重写钩子方法
            @Override
            protected void beforeExecute(Thread t, Runnable r) {
                super.beforeExecute(t, r);
                // 可以在这里添加监控逻辑
            }
            
            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                super.afterExecute(r, t);
                
                // 处理异常
                if (t != null) {
                    System.err.println("Task execution failed: " + t);
                }
                
                // 处理 Future 中的异常
                if (r instanceof Future<?>) {
                    try {
                        ((Future<?>) r).get();
                    } catch (Exception e) {
                        System.err.println("Task execution failed: " + e.getCause());
                    }
                }
            }
            
            @Override
            protected void terminated() {
                super.terminated();
                System.out.println("ThreadPool " + poolName + " has been terminated");
            }
        };
        
        // 允许核心线程超时（可选）
        executor.allowCoreThreadTimeOut(true);
        
        return executor;
    }
    
    // 优雅关闭线程池
    public static void gracefulShutdown(ExecutorService executor, int timeoutSeconds) {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(timeoutSeconds, TimeUnit.SECONDS)) {
                System.err.println("线程池在指定时间内未能关闭，强制关闭");
                executor.shutdownNow();
                
                if (!executor.awaitTermination(timeoutSeconds, TimeUnit.SECONDS)) {
                    System.err.println("线程池强制关闭失败");
                }
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

> 🎯 **总结**：生产环境中使用线程池时，务必要考虑异常处理、监控、优雅关闭等各个方面，确保系统的稳定性和可观测性。推荐使用显式的 `ThreadPoolExecutor` 构造器而非 `Executors` 工具类，以获得更好的控制和安全性。



