---
title: 9、锁的分类
---
## 📚 目录


1. [锁的相关概念](#1-锁的相关概念)
2. [互斥锁](#2-互斥锁)
3. [自旋锁](#3-自旋锁)
4. [读写锁](#4-读写锁)
5. [阻塞锁与非阻塞锁](#5-阻塞锁与非阻塞锁)
6. [可重入锁](#6-可重入锁)
7. [公平锁与非公平锁](#7-公平锁与非公平锁)
8. [轻量级锁与重量级锁](#8-轻量级锁与重量级锁)
9. [悲观锁与乐观锁](#9-悲观锁与乐观锁)
10. [分段锁](#10-分段锁)
11. [死锁与死锁避免](#11-死锁与死锁避免)
12. [显式锁与隐式锁](#12-显式锁与隐式锁)
13. [嵌套锁](#13-嵌套锁)
14. [共享锁与独占锁](#14-共享锁与独占锁)
15. [CAS、AQS与ABA问题](#15-cas-aqs与aba问题)
16. [偏向锁](#16-偏向锁)
17. [离散锁](#17-离散锁)
18. [锁升级与锁降级](#18-锁升级与锁降级)
19. [分布式锁](#19-分布式锁)
20. [锁的相关问题](#20-锁的相关问题)

---

## 1. 🔐 锁的相关概念



### 1.1 什么是锁



**🔸 基本定义**
```
锁（Lock）：一种同步机制，用于控制多个线程对共享资源的访问
目的：确保在任意时刻，只有特定数量的线程能够访问共享资源
本质：通过互斥、同步等手段防止并发访问导致的数据不一致问题
```

### 1.2 为什么需要锁



**⚠️ 并发问题示例**
```
无锁情况下的竞态条件：
线程A: count = 100 → 读取 → +1 → 写回101
线程B: count = 100 → 读取 → +1 → 写回101
预期结果：102
实际结果：101（数据丢失）

问题根源：
• 非原子操作被中断
• 多线程同时访问共享数据
• 缺乏同步控制机制
```

### 1.3 锁的基本分类



**📊 按功能特性分类**
```
互斥性维度：
├── 互斥锁（Mutex Lock）
│   └── 同时只允许一个线程访问
└── 共享锁（Shared Lock）
    └── 允许多个线程同时访问（如读锁）

阻塞性维度：
├── 阻塞锁（Blocking Lock）
│   └── 获取失败时线程挂起等待
└── 非阻塞锁（Non-blocking Lock）
    └── 获取失败时立即返回或重试

公平性维度：
├── 公平锁（Fair Lock）
│   └── 按申请顺序获取锁
└── 非公平锁（Unfair Lock）
    └── 抢占式获取锁
```

### 1.4 锁的核心特性



| 特性 | **说明** | **示例** |
|------|----------|----------|
| 🔒 **原子性** | `确保操作不可分割` | `count++操作要么全部完成，要么全部不执行` |
| 🔄 **可见性** | `一个线程的修改对其他线程可见` | `volatile关键字保证变量修改的可见性` |
| ⚡ **有序性** | `防止指令重排序影响程序逻辑` | `synchronized保证临界区内的有序执行` |
| 🔁 **可重入性** | `同一线程可多次获取同一锁` | `ReentrantLock支持重入，避免死锁` |

### 1.5 Java中锁的实现机制



**🏗️ 底层支持**
```
硬件层面：
• CAS（Compare-And-Swap）指令
• 内存屏障（Memory Barrier）
• 原子指令集支持

JVM层面：
• 对象头中的Mark Word
• Monitor监视器机制
• AQS（AbstractQueuedSynchronizer）框架

语言层面：
• synchronized关键字
• volatile关键字  
• Lock接口及其实现类
```

---

## 2. 🔒 互斥锁



### 2.1 核心概念



**🔸 基本定义**
```
互斥锁（Mutex Lock）：
• 一种同步机制，确保同一时间只有一个线程访问共享资源
• 具有排他性，获得锁的线程独占资源
• 其他线程必须等待锁释放才能访问
```

**💡 工作机制**
```
加锁流程：
线程请求锁 → 检查锁状态 → 获取成功/失败处理

释放流程：
持锁线程完成操作 → 释放锁 → 唤醒等待线程

同步 vs 异步：
• 同步：多线程通过互斥机制串行访问共享资源
• 异步：多线程独立执行，不做访问控制，易引发竞态问题
```

### 2.2 核心特点



```
互斥锁的四大特性：
├── 🔐 排他性：同一时间只允许一个线程持有锁
├── ⏸️ 阻塞性：未获得锁的线程处于等待或阻塞状态  
├── 🔄 可重入性：同一线程可多次获得同一锁，不会死锁
└── 🎯 原子性：保证临界区操作的完整性
```

### 2.3 Java实现方式



#### 🔧 synchronized关键字（内置锁）



```java
// ✅ 1. 同步代码块
public class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            count++;  // 临界区
        }
    }
    
    public int getCount() {
        return count;
    }
}
// 说明：lock是同步监视器对象，保证同时只有一个线程能进入代码块

// ✅ 2. 同步实例方法（锁当前对象this）
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
// 说明：synchronized修饰方法，等同于synchronized(this)

// ✅ 3. 同步静态方法（锁Class对象）
public class Counter {
    private static int count = 0;

    public static synchronized void increment() {
        count++;
    }

    public static synchronized int getCount() {
        return count;
    }
}
// 说明：锁的是Counter.class，对所有线程是共享的
```

#### 🔧 Lock接口（显式锁）



```java
// ✅ 示例：使用ReentrantLock
public class Counter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock();  // 显式加锁
        try {
            count++;
        } finally {
            lock.unlock();  // 必须手动释放锁
        }
    }

    public int getCount() {
        return count;
    }
}
// 说明：可手动控制锁的加锁和释放（常用于复杂同步逻辑）
// ReentrantLock支持：可重入、公平锁、尝试锁、可中断锁等
```

---

## 3. 🌀 自旋锁



### 3.1 核心概念



**🔸 基本定义**
```
自旋锁（Spin Lock）：
• 获取锁失败时，线程通过自旋（循环尝试）不断检查锁是否释放
• 线程在请求锁失败后不会阻塞，而是"原地打转"尝试获取锁
• 采用忙等待机制（Busy-Waiting），线程不会释放CPU
```

### 3.2 核心特点



```
自旋锁特性分析：
├── ⚡ 忙等待机制：线程在自旋期间不会释放CPU
├── 🚫 不进行阻塞：线程不会进入阻塞状态，避免上下文切换
├── 🎯 适用场景：锁持有时间短，线程数量不多，CPU资源充足
└── ⚖️ 性能权衡：避免上下文切换开销，但可能浪费CPU资源
```

### 3.3 与互斥锁的区别



| 特性 | **互斥锁** | **自旋锁** |
|------|------------|------------|
| 🔄 **获取失败处理** | `线程被挂起（阻塞）` | `线程忙等待并持续尝试` |
| 💻 **CPU占用** | `不占用CPU资源` | `持续占用CPU资源` |
| ⚡ **上下文切换** | `涉及上下文切换开销` | `避免上下文切换` |
| 🎯 **适用场景** | `锁持有时间较长` | `锁持有时间极短` |

### 3.4 Java中的自旋锁实现



#### 🔧 JVM层面的自适应自旋



```
自适应自旋优化：
├── 🎯 核心概念：JDK 1.6后引入，用于优化synchronized锁性能
├── 📈 动态调整：根据竞争情况动态调整自旋次数
│   ├── 自旋成功 → 增加自旋次数
│   └── 自旋失败 → 减少自旋次数并进入阻塞
├── ⚙️ JVM参数控制：
│   ├── -XX:+UseSpinning：启用自旋锁（JDK 1.7+默认开启）
│   ├── -XX:PreBlockSpin：控制默认自旋次数
│   └── -XX:UseCountedLoop：优化自旋操作
└── 💡 优化效果：减少线程上下文切换，提升锁效率
```

#### 🔧 CAS实现自定义自旋锁



```
CAS自旋锁实现原理：
├── 🔍 基本原理：利用CPU原子指令Compare-And-Swap
├── 🔄 循环尝试：线程未获取锁时不断使用CAS重试
├── 📊 核心逻辑：
│   ├── 获取锁：compareAndSet(null, currentThread)
│   │   ├── 成功 → 当前线程抢到锁
│   │   └── 失败 → 继续自旋重试
│   └── 释放锁：将AtomicReference设置为null
├── ⚠️ 注意事项：
│   ├── 忙等待占用CPU，适合短时间锁场景
│   ├── 可能导致ABA问题
│   └── 无法自动中断或阻塞
└── 🎯 应用场景：内存队列、对象池、高性能组件
```

### 3.5 适用场景与注意事项



**🎯 适用场景**
```
理想使用条件：
✅ 锁竞争激烈但持锁时间极短
✅ 高性能计算场景（如并行算法）
✅ 非阻塞数据结构实现
✅ 多核处理器环境
```

**⚠️ 注意事项**
```
风险与限制：
❌ 长时间自旋导致CPU空转浪费
❌ 不适用于长时间阻塞操作（如I/O）
❌ 可能造成优先级反转问题
💡 建议：设置最大自旋次数或超时时间
```

---

## 4. 📖 读写锁



### 4.1 核心概念



**🔸 基本定义**
```
读写锁（Read-Write Lock）：
• 一种特殊的锁机制，将锁分为读锁和写锁
• 读锁：共享锁，允许多个线程同时读取
• 写锁：独占锁，只允许一个线程写入
• 读写互斥：读锁与写锁不能同时存在
```

### 4.2 读锁特性



| 特性 | **说明** |
|------|----------|
| 🤝 **共享性** | `多个线程可同时持有读锁` |
| 🔒 **与写锁互斥** | `有写锁时不能获取读锁` |
| 🔄 **可重入** | `同一线程可多次获取读锁` |
| ⚡ **高并发** | `适合读多写少场景，提升性能` |

### 4.3 写锁特性



| 特性 | **说明** |
|------|----------|
| 🔐 **独占性** | `同时只允许一个线程持有写锁` |
| 🔄 **可重入** | `基于ReentrantReadWriteLock支持重入` |
| 🚫 **互斥性** | `与所有读锁、写锁完全互斥` |
| 🎯 **一致性保障** | `确保写操作的原子性和数据一致性` |

### 4.4 读写锁兼容性矩阵



| 当前持有锁 | **可获取读锁** | **可获取写锁** |
|-----------|----------------|----------------|
| 🔓 **无锁** | ✅ | ✅ |
| 📖 **读锁** | ✅（共享） | ❌ |
| ✏️ **写锁** | ❌ | ✅（重入） |

### 4.5 使用示例



#### 🔧 写锁使用方式



```java
// 写锁的获取与释放
ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
Lock writeLock = lock.writeLock();

writeLock.lock();        // 获取写锁（阻塞）
try {
    // 修改共享资源
} finally {
    writeLock.unlock();  // 释放写锁
}

// 尝试获取（非阻塞）
if (writeLock.tryLock()) {
    try {
        // 获取成功，执行写操作
    } finally {
        writeLock.unlock();
    }
}
```

#### 🔧 读锁使用方式



```java
// 基本使用
ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
Lock readLock = lock.readLock();

readLock.lock();  // 获取读锁
try {
    // 读取共享数据
} finally {
    readLock.unlock();  // 释放读锁
}

// 尝试获取（非阻塞）
if (readLock.tryLock()) {
    try {
        // 执行读操作
    } finally {
        readLock.unlock();
    }
}
```

### 4.6 底层实现原理



**🏗️ AQS实现机制**
```
ReentrantReadWriteLock基于AQS实现：
├── 📊 状态表示：32位int state
│   ├── 高16位：读锁持有线程数（Read Count）
│   └── 低16位：写锁重入次数（Write Hold Count）
├── 🔐 写锁获取过程：
│   ├── 判断是否存在读锁（高16位 != 0）
│   ├── 判断是否已有其他线程持有写锁
│   ├── 判断是否为当前线程重入
│   └── 通过CAS操作修改state低16位
├── 📖 读锁获取过程：
│   ├── 判断是否有线程持有写锁
│   ├── 判断是否存在写线程等待
│   ├── 执行CAS增加读锁计数（state高16位）
│   └── 更新ThreadLocal中的HoldCounter
└── 🔄 释放过程：
    ├── 写锁：确认持有者，计数减1，完全释放时唤醒等待线程
    └── 读锁：更新HoldCounter，CAS更新state，读锁总数为0时唤醒写线程
```

### 4.7 注意事项



**⚠️ 使用要点**
```
读锁注意事项：
├── 🚫 读写互斥：若某线程持有写锁，其他线程不能获取读锁
├── 🔧 功能限制：读锁不支持条件变量（await/signal）
├── ⚠️ 避免死锁：禁止在持有读锁时尝试获取写锁
├── 🔄 重入控制：读锁支持可重入，但需谨慎使用
└── 📋 正确释放：所有锁操作应使用try-finally确保unlock()调用

写锁注意事项：
├── 🔒 锁顺序：不要在持有写锁时获取读锁
├── ⏰ 阻塞特性：写锁获取失败时线程将阻塞
├── 📋 释放规范：使用try-finally保证unlock()执行
└── ⚡ 性能影响：写操作期间所有读操作被阻塞，应尽量简短
```

---

## 5. 🔄 阻塞锁与非阻塞锁



### 5.1 核心概念对比



**🔸 基本定义**
```
阻塞锁（Blocking Lock）：
• 当锁被占用时，线程会挂起（阻塞），等待锁释放
• 唤醒由JVM/操作系统调度完成
• 获取失败主动让出CPU，不占用CPU资源

非阻塞锁（Non-blocking Lock）：
• 线程获取锁失败时不会被阻塞，而是不断尝试
• 属于乐观并发策略的一种实现
• 线程始终处于运行态，可能进行多次自旋尝试
```

### 5.2 工作机制对比



```
阻塞锁工作流程：
竞争失败 → 进入等待队列 → RUNNABLE→BLOCKED/WAITING → 
系统上下文切换 → 锁释放 → 唤醒等待线程重新竞争

非阻塞锁工作流程：
使用原子类/Unsafe → CAS尝试更新状态 → 
成功获取锁 OR 失败自旋/退出 → 无阻塞无挂起
```

### 5.3 特性对比分析



| 特性 | **阻塞锁** | **非阻塞锁** |
|------|------------|--------------|
| 🔄 **失败处理** | `挂起线程（阻塞等待）` | `重试（自旋或直接失败返回）` |
| 💻 **CPU占用** | `不占用CPU` | `占用CPU（频繁CAS尝试）` |
| ⚡ **上下文切换** | `高（涉及线程调度）` | `低（避免线程挂起）` |
| 🎯 **适用场景** | `锁持有时间长，竞争激烈` | `锁持有时间短，高性能要求` |
| 📊 **性能开销** | `高（线程调度开销）` | `低（避免线程挂起）` |

### 5.4 Java实现方式



#### 🔧 阻塞锁实现



```java
// synchronized（内置锁）- 获取锁失败时直接阻塞等待
synchronized (obj) {
    // 临界区，obj为锁对象
}

// ReentrantLock（显式锁）- 默认阻塞锁
Lock lock = new ReentrantLock();
lock.lock(); // 阻塞直到获得锁
try {
    // 临界区
} finally {
    lock.unlock();
}

// ReentrantReadWriteLock - 写锁是阻塞锁
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.writeLock().lock(); // 阻塞直到获得写锁
```

#### 🔧 非阻塞锁实现



| 机制/工具类 | **类型** | **是否非阻塞** | **实现说明** |
|-------------|----------|----------------|--------------|
| `CAS` | 原语 | ✅ | Compare-And-Swap，核心 |
| `AtomicXXX` | 原子类 | ✅ | 原子操作类，如AtomicInteger |
| `Lock.tryLock()` | 显式锁接口 | ✅（条件式） | 立即尝试加锁，失败返回false |
| `StampedLock.tryOptimisticRead()` | 乐观读锁 | ✅ | 非阻塞读场景 |
| `ConcurrentHashMap` | 容器类 | ✅ | 内部使用非阻塞算法实现并发控制 |

### 5.5 三种锁机制综合对比



```
锁机制全面对比：阻塞锁 vs 自旋锁 vs 非阻塞锁
├── 🔄 是否阻塞线程：
│   ├── 阻塞锁：是，失败线程会挂起
│   ├── 自旋锁：否，失败线程持续自旋等待
│   └── 非阻塞锁：否，失败线程直接重试或退出
├── 💻 CPU占用情况：
│   ├── 阻塞锁：不占用CPU，线程挂起
│   ├── 自旋锁：占用CPU，自旋忙等
│   └── 非阻塞锁：占用CPU，频繁CAS尝试
├── 🎯 适用场景：
│   ├── 阻塞锁：锁竞争激烈，锁持有时间较长
│   ├── 自旋锁：多核CPU、线程切换代价大，锁持有时间极短
│   └── 非阻塞锁：高性能并发程序，锁冲突概率低
├── 🔧 Java典型实现：
│   ├── 阻塞锁：synchronized、ReentrantLock
│   ├── 自旋锁：ReentrantLock（部分实现）、JUC内部自旋
│   └── 非阻塞锁：AtomicInteger、StampedLock、Unsafe
└── ⚡ 并发性能：
    ├── 阻塞锁：中等（依赖线程切换频率）
    ├── 自旋锁：高（适合快锁）
    └── 非阻塞锁：非常高（高并发高吞吐场景）
```

### 5.6 重要概念辨析



> **⚠️ 注意：自旋锁 ≠ 非阻塞锁**

```
自旋锁 vs 非阻塞锁关键区别：
├── 🔍 核心机制：
│   ├── 自旋锁：自旋等待，不放弃CPU，持续判断锁状态
│   └── 非阻塞锁：基于CAS机制尝试获取锁
├── 🚫 阻塞特性：
│   ├── 自旋锁：不阻塞线程，但线程处于忙等待状态
│   └── 非阻塞锁：完全不阻塞，失败后立即返回或控制重试
├── ⚙️ CAS依赖：
│   ├── 自旋锁：❌ 不一定依赖CAS，可仅基于布尔标志位
│   └── 非阻塞锁：✅ 以CAS为核心机制
├── 🎮 线程控制：
│   ├── 自旋锁：❌ 不具备自我控制能力，直到成功才停止
│   └── 非阻塞锁：✅ 线程主动控制成功/失败处理逻辑
└── 💭 并发哲学：
    ├── 自旋锁：乐观假设很快就能拿到锁（不断等）
    └── 非阻塞锁：乐观尝试+失败即退（不浪费时间）
```

---

## 6. 🔄 可重入锁



### 6.1 核心概念



**🔸 基本定义**
```
可重入锁（Reentrant Lock）：
• 一种允许同一线程重复获得同一把锁的同步机制
• 同一线程在外层方法获得锁后，可在内层方法再次获取，不会死锁
• 又称递归锁（Recursive Lock）
```

### 6.2 核心特性



```
可重入锁特性分析：
├── 🔄 可重入性：同一线程可以进入它已经持有的锁所控制的临界区
├── 🔐 线程独占：其他线程仍需等待锁被释放
├── 🏗️ 支持嵌套：避免线程因重复请求同一把锁而自我阻塞
└── 📊 计数机制：内部维护重入计数器，管理锁的获取和释放
```

### 6.3 重入计数机制



**⚙️ 工作原理**
```
加锁流程：
每次成功进入临界区 → 锁的计数器 +1

解锁流程：
每次 unlock() → 计数器 -1

释放条件：
计数器为 0 时 → 锁才真正释放
```

### 6.4 可重入性的意义



| 优势 | **描述** |
|------|----------|
| 🚫 **避免死锁** | `支持嵌套调用的同步结构，防止自己阻塞自己` |
| 🎯 **细粒度加锁** | `在复杂结构中，方法之间可自由调用，避免锁冲突` |
| 📝 **提升代码清晰度** | `方法解耦，锁逻辑独立，易于维护` |
| 🔧 **简化同步逻辑** | `无需担心一个线程再次调用同步方法时死锁` |

### 6.5 Java实现方式



#### 🔧 synchronized（隐式可重入）



```java
// Java内置的synchronized就是可重入的
// 同一个线程可以多次进入被synchronized修饰的方法或代码块
public synchronized void outer() {
    inner(); // 仍然是synchronized，不会死锁
}

public synchronized void inner() {
    // 这里同一线程再次进入锁
}
```

#### 🔧 ReentrantLock（显式可重入）



```java
// java.util.concurrent.locks.ReentrantLock通过计数器跟踪重入次数
Lock lock = new ReentrantLock();

lock.lock();
try {
    lock.lock();  // 可以再次加锁（可重入）
    try {
        // 临界区
    } finally {
        lock.unlock();
    }
} finally {
    lock.unlock();
}
```

### 6.6 与其他锁的比较



**🔍 可重入锁 vs 不可重入锁**

| 特性 | **可重入锁** | **不可重入锁** |
|------|-------------|---------------|
| 🔄 **重复获取** | `同一线程可多次获取同一把锁` | `同一线程重复加锁将陷入死锁` |
| 📊 **计数机制** | `内部通过计数器跟踪加锁次数` | `不记录持锁线程信息与计数` |
| 🔧 **实现复杂度** | `相对复杂，需维护线程标识` | `简单，但使用受限` |
| 🎯 **Java默认** | `Java默认采用可重入设计` | `需要特殊实现` |

**🔍 可重入锁 vs 自旋锁**

```
实现层面对比：
├── 可重入锁：
│   ├── 失败线程会被阻塞并由操作系统调度
│   └── 更适用于锁持有时间较长的场景
├── 自旋锁：
│   ├── 失败线程持续循环尝试获取锁（忙等待）
│   └── 更适用于短时间临界区、锁竞争不激烈的场景
└── 混合实现：
    └── ReentrantLock内部可能在阻塞前短暂自旋以优化性能
```

**🔍 可重入锁 vs 读写锁**

```
功能特性对比：
├── 可重入互斥锁（ReentrantLock）：
│   └── 任一时刻只允许一个线程访问共享资源（读/写均互斥）
├── 可重入读写锁（ReentrantReadWriteLock）：
│   ├── 支持多个线程同时读
│   └── 写线程独占（读写、写写互斥）
└── 选择策略：
    ├── 读操作频繁 → 优先使用读写锁
    ├── 写操作频繁 → 使用互斥锁更简单
    └── 临界区操作复杂度也影响锁选择
```

---

## 7. ⚖️ 公平锁与非公平锁



### 7.1 核心概念



**🔸 基本定义**
```
公平锁（Fair Lock）：
• 线程按照请求锁的先后顺序获取锁（先来先得）
• 遵循FIFO队列原则，避免线程"饥饿"

非公平锁（Non-Fair Lock）：
• 线程可直接尝试抢占锁，不考虑请求顺序  
• 获取锁效率更高，但可能导致线程"饿死"
```

### 7.2 工作原理对比



```
工作机制差异：
├── 🎯 公平锁：
│   ├── 每次加锁时检查CLH队列前是否有其他线程排队
│   └── 若有等待线程，当前线程加入队列尾部排队
├── ⚡ 非公平锁：
│   ├── 尝试立即抢占锁（使用CAS操作）
│   └── 抢不到时再加入队列，稍有"机会主义"特性
└── 🏗️ 队列机制：
    └── 基于AQS（AbstractQueuedSynchronizer）框架的CLH队列
```

### 7.3 Java实现方式



#### 🔧 synchronized（始终非公平）



```
synchronized特性：
├── 🎲 实现方式：JVM层面实现的内置锁
├── 🔄 锁获取行为：
│   ├── 线程释放锁后，JVM不保证按请求顺序唤醒等待线程
│   └── 后来线程可能直接抢占锁，导致先请求的线程继续等待
└── ⚠️ 限制：
    ├── 非公平、性能好
    └── 无法设置为公平锁，不能显式控制队列顺序
```

#### 🔧 ReentrantLock（支持公平与非公平）



```java
// 构造方式控制公平性
ReentrantLock fairLock = new ReentrantLock(true);      // 公平锁
ReentrantLock unfairLock = new ReentrantLock();        // 默认非公平锁
ReentrantLock unfairLock2 = new ReentrantLock(false);  // 显式非公平锁
```

**⚙️ 底层实现差异**

```java
// 1. 非公平锁获取流程：
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState(); // 获取锁状态
    if (c == 0) {
        // 直接CAS尝试获取锁（不检查队列）
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 当前线程是重入
    else if (current == getExclusiveOwnerThread()) {
        setState(c + acquires);
        return true;
    }
    return false;
}

// 2. 公平锁获取流程：
final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 公平锁检查是否有前置线程在等待队列
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        setState(c + acquires);
        return true;
    }
    return false;
}
```

### 7.4 性能与特性对比



| 比较维度 | **公平锁** | **非公平锁** |
|----------|------------|--------------|
| 🔄 **获取顺序** | `严格按请求顺序` | `允许后来的线程插队抢锁` |
| ⚡ **性能** | `相对较低（维护队列开销大）` | `较高（减少上下文切换）` |
| 🔧 **实现复杂度** | `高，需要检查队列状态` | `低，直接尝试获取锁` |
| 🚫 **是否防止饥饿** | `✅ 是` | `❌ 否（可能有线程长时间得不到锁）` |
| 🎯 **应用场景** | `强调公平性、安全性要求高的业务` | `高性能要求、吞吐量优先的业务` |

### 7.5 使用场景分析



**✅ 适合使用公平锁的场景**
```
理想应用环境：
• 高安全性系统（如金融交易）
• 对响应时间要求严格，强调顺序执行
• 需要避免线程饥饿
• 线程任务优先级相同，要求公平调度
```

**✅ 适合使用非公平锁的场景**
```
优势发挥场景：
• 高并发、高吞吐量系统（如数据库连接池、Web请求）
• 对锁竞争响应速度要求高
• 能容忍线程间调度不均
• 临界区小、持锁时间短，减少上下文切换成本
```

### 7.6 注意事项



**⚠️ 重要提醒**
```
使用要点：
├── 1️⃣ 非公平锁 ≠ 完全不公平
│   ├── 多数实现仍维护等待队列（如AQS）
│   └── 插队只是"尝试"，不保证每次成功
├── 2️⃣ 公平性不是免费的
│   ├── 每次加锁前需检查等待队列，调度开销更大
│   └── 吞吐量通常低于非公平锁，可能产生"过度排队"现象
└── 3️⃣ 公平锁可能导致性能抖动
    ├── 多线程频繁竞争下，系统调度负担加重
    └── 维护公平性带来的阻塞等待，可能引起TPS波动或响应延迟
```

---

## 8. ⚖️ 轻量级锁与重量级锁



### 8.1 核心概念



**🔸 基本定义**
```
轻量级锁（Lightweight Lock）：
• JVM在JDK 1.6为优化synchronized而引入的锁机制
• 目标：减少无竞争时的同步性能开销
• 特点：无锁竞争时高效，无需阻塞挂起

重量级锁（Heavyweight Lock）：
• synchronized在发生锁竞争时的底层实现形式，基于Monitor
• 特点：性能开销大，但在高并发激烈竞争下更稳定
```

### 8.2 锁状态升级流程



**🔄 JVM锁优化机制**
```
锁状态演化过程（JDK 1.6+）：
无锁 → 偏向锁（Biased Lock）→ 轻量级锁 → 重量级锁

升级特性：
• 单向升级，不可降级
• 根据竞争情况自动转换
• 优化目标：在不同场景下获得最佳性能
```

### 8.3 锁状态对比分析



| 锁状态 | **是否竞争** | **优化方向** | **效率** | **原子性** | **会否阻塞** |
|--------|-------------|-------------|----------|------------|-------------|
| 🎯 **偏向锁** | `无` | `单线程复用优化` | `高` | `否` | `否` |
| ⚡ **轻量级锁** | `无/轻微` | `多线程交替执行优化` | `高` | `是` | `否` |
| 🔒 **重量级锁** | `有` | `多线程竞争激烈` | `低` | `是` | `是` |

### 8.4 性能对比分析



| 比较项目 | **轻量级锁** | **重量级锁** |
|----------|-------------|-------------|
| 🚫 **是否阻塞线程** | `否` | `是` |
| 🏎️ **是否适合高并发** | `否（适合低竞争）` | `是` |
| 💰 **开销** | `小（CAS + MarkWord操作）` | `大（线程调度 + 上下文切换）` |
| ⏱️ **锁的获取时间** | `快` | `慢` |
| 💾 **内存消耗** | `少` | `多（涉及线程控制结构）` |

### 8.5 适用场景分析



| 场景 | **推荐锁类型** |
|------|---------------|
| 🔓 **无锁竞争，单线程执行** | `偏向锁` |
| 🔄 **少量线程交替访问资源** | `轻量级锁` |
| 🏁 **多线程同时竞争资源** | `重量级锁（Monitor）` |

### 8.6 锁升级机制详解



**⚙️ 升级触发条件**
```
偏向锁 → 轻量级锁：
• 出现多线程竞争时
• 偏向锁被其他线程访问

轻量级锁 → 重量级锁：
• CAS自旋失败次数超过阈值
• 检测到激烈竞争时自动膨胀
• 目标：避免无效自旋浪费CPU
```

---

## 9. 😊 悲观锁与乐观锁



### 9.1 核心思想对比



**🔸 基本理念**
```
悲观锁（Pessimistic Lock）：
• 认为资源竞争是常态，先上锁再操作
• 加锁（排他锁），防止其他线程访问
• 串行化访问，阻塞其他线程

乐观锁（Optimistic Lock）：
• 认为冲突是偶发，先操作再校验
• 不加锁，依赖版本控制/CAS判断是否冲突
• 非阻塞方式，冲突时重试
```

### 9.2 实现机制对比



| 特性 | **悲观锁** | **乐观锁** |
|------|------------|------------|
| 🔐 **锁的策略** | `加锁，排他访问` | `不加锁，依赖版本控制/CAS` |
| 🔄 **并发控制方式** | `串行化访问，阻塞其他线程` | `非阻塞方式，冲突时重试` |
| ⚡ **性能** | `开销大，线程阻塞上下文切换` | `性能高，无锁操作，适合读多写少` |
| 🚫 **失败机制** | `获取不到锁 → 阻塞` | `提交校验失败 → 重试` |

### 9.3 Java实现方式



#### 🔧 悲观锁实现



```java
// synchronized - Java原生关键字，基于Monitor实现的阻塞式锁
synchronized (object) {
    // 临界区代码
}

// ReentrantLock - 显式加锁方式，可设置为公平锁
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 临界区代码
} finally {
    lock.unlock();
}

// 数据库悲观锁（扩展了解）
// 通过 SELECT ... FOR UPDATE 等语法锁定数据库记录
```

#### 🔧 乐观锁实现



```java
// 1. CAS（Compare-And-Swap）
AtomicInteger counter = new AtomicInteger(0);
int updated = counter.incrementAndGet(); // 基于CAS实现

// 手写CAS模拟：
while (true) {
    int current = counter.get();
    int next = current + 1;
    if (counter.compareAndSet(current, next)) {
        break;
    }
}

// 2. 版本号机制
public class OptimisticLockExample {
    private int version;
    private int value;
    
    public synchronized boolean update(int expectedVersion, int newValue) {
        // 检查版本是否匹配
        if (version == expectedVersion) {
            // 更新数据并递增版本
            value = newValue;
            version++;
            return true;
        }
        return false; // 版本不匹配，更新失败
    }
}
```

### 9.4 应用类型分类



| 应用类型 | **Java支持类** |
|----------|----------------|
| 🔒 **悲观锁** | `synchronized`, `ReentrantLock` |
| ⚡ **乐观锁（CAS）** | `AtomicInteger`, `AtomicReference` |
| 📝 **乐观锁（版本号）** | `手动实现版本字段、JPA @Version注解` |

### 9.5 适用场景对比



| 场景 | **建议使用** | **理由** |
|------|-------------|----------|
| 🔄 **多线程频繁写操作** | `悲观锁` | `冲突频繁，需要保证强一致性` |
| 📖 **高并发读，偶尔写** | `乐观锁` | `写冲突概率低，避免加锁带来的性能损耗` |
| 💾 **数据库并发写** | `乐观锁 + 版本号` | `不阻塞事务，提高吞吐量` |
| 💰 **高安全/资金交易系统** | `悲观锁` | `绝对不能出现数据不一致` |

### 9.6 总结对比



```
悲观锁 vs 乐观锁 深度对比：
├── 💡 性能：乐观锁更高（无阻塞），悲观锁更稳定
├── 🔄 冲突处理：乐观锁靠重试，悲观锁靠阻塞排队
├── 🔧 实现复杂度：乐观锁高（需版本/CAS），悲观锁低
├── 🛡️ 数据一致性保障：悲观锁更强
└── 🎯 场景适配性：
    ├── 乐观锁适用于大多数读取操作场景
    └── 悲观锁适用于敏感数据的更新保障
```

---

## 10. 🧩 分段锁



### 10.1 核心概念



**🔸 基本定义**
```
分段锁（Segment Lock）：
• 一种将大锁拆分为多个小锁（段）的并发控制机制
• 每段资源使用独立锁，允许多个线程并发访问不同段
• 属于"锁粒度优化"策略，增强系统并发性
```

### 10.2 设计原理



**⚙️ 工作机制**
```
分段策略：
├── 🗂️ 数据划分：将共享数据结构划分为多个Segment（段）
├── 🔐 独立加锁：每个Segment维护一把独立的锁
├── 🎯 降低粒度：避免多个线程争抢同一个大锁
└── 🚀 并发提升：多线程可并发访问不同段，竞争更少
```

### 10.3 设计优势



| 优势 | **说明** |
|------|----------|
| 🔽 **降低锁竞争** | `避免多个线程争抢同一个大锁，多线程可并发访问不同段` |
| 📈 **提高并发度** | `多段独立加锁，提升并发访问能力` |
| 🎯 **提升吞吐量** | `减少线程等待时间，提高整体性能表现` |
| 📖 **适合读多写少** | `特别适合频繁读取的典型场景` |

### 10.4 典型实现：ConcurrentHashMap



#### 🔧 JDK 1.7实现方式



```java
// 分段结构（旧版本）
JDK 1.7的ConcurrentHashMap内部采用16段Segment锁结构：
├── 🏗️ 结构设计：
│   ├── Segment<K,V>[] segments; // 数组大小为2的幂，默认16段
│   ├── 每个Segment继承自ReentrantLock，管理一部分桶（hash槽）
│   └── 键的哈希值会定位到某个段，线程只锁这个段即可
├── 🔄 线程操作流程：
│   ├── Thread A操作key1 → 定位Segment[3] → 加锁Segment[3]
│   ├── Thread B操作key2 → 定位Segment[12] → 加锁Segment[12]
│   └── A与B可并发执行
└── 📊 并发控制：
    ├── 每段负责部分数据
    ├── 最大并发度 ≈ 段数（例如16段，最大并发写可达16）
    └── 段内使用ReentrantLock控制串行写入
```

#### 🔧 JDK 1.8演进



```
JDK 1.8后的改进：
├── 🗂️ 结构变化：移除了Segment分段结构
├── 🆕 新实现：使用数组 + 链表/红黑树 + synchronized + CAS
├── 🎯 优化思想：虽然没有显式分段锁类，但仍体现"分散竞争点"的思想
└── 📈 性能提升：更细粒度的并发控制，更高的性能表现
```

### 10.5 与其他锁机制对比



| 类型 | **粒度** | **是否支持并发** | **应用示例** |
|------|----------|-----------------|--------------|
| 🔒 **全局锁（大锁）** | `粗（一个对象一把锁）` | `❌ 串行` | `Hashtable, synchronized Map` |
| 🧩 **分段锁** | `中（按段划分）` | `✅ 可并发` | `ConcurrentHashMap (JDK7)` |
| 🔧 **细粒度锁** | `精（每个key加锁）` | `✅ 最细致` | `ConcurrentHashMap (JDK8+)` |

### 10.6 适用场景与注意事项



**✅ 适合使用分段锁的场景**
```
理想应用环境：
• 高并发访问共享数据结构（如Map、缓存容器）
• 多线程写操作频繁，需减少锁冲突
• 键值访问分布较均匀、热点不集中的系统
```

**❌ 不适合的场景**
```
限制条件：
• 键值高度集中，容易命中同一段（锁竞争集中）
• 线程数远大于段数，竞争严重，性能提升有限
• 不适合整体原子访问需求的资源
```

### 10.7 设计注意事项



**⚠️ 重要考虑**
```
优化要点：
├── 1️⃣ 段数不是越多越好
│   ├── 锁粒度虽细，但内存开销增加
│   ├── 段数过多无助于CPU性能利用
│   └── 最佳段数 ≈ 并发线程数的2~4倍
├── 2️⃣ 哈希分段需均匀
│   ├── 键的哈希算法需保证键值分布均匀
│   └── 避免部分段成为热点，造成锁倾斜失效
└── 3️⃣ 仅适用于可分割资源
    ├── 如map桶数组、分区缓存、内存块等结构
    └── 不适合整体原子访问需求的资源（例如单一队列）
```

### 10.8 总结要点



**📋 核心要点**
```
分段锁精华总结：
├── 💡 概念：将资源分段，每段维护独立锁，提升并发处理能力
├── 🔧 实现：每段一个ReentrantLock（如ConcurrentHashMap in JDK7）
├── 🚀 优势：并发度高，减少冲突，提高系统吞吐量
├── ⚠️ 限制：哈希分布需均匀，适合多写线程环境
└── 🚫 误区：
    ├── 过度分段导致内存浪费
    └── 锁越细 ≠ 性能越好，需综合评估线程数与资源结构
```

---


## 11. ⚠️ 死锁与死锁避免



### 11.1 核心概念



**🔸 基本定义**
```
死锁（Deadlock）：
• 多个线程互相等待对方持有的锁，导致永久阻塞
• 所有线程都无法继续执行，形成"资源环路"
• 属于并发程序中的一种严重错误

典型现象：
• 程序卡住，无异常抛出
• CPU使用率正常或偏低，但线程无进展
• 使用jstack工具可查看BLOCKED或WAITING状态
```

### 11.2 死锁产生的四个必要条件



**📊 同时满足才会发生死锁**

| 条件 | **描述** |
|------|----------|
| 🔒 **互斥条件** | `资源一次只能被一个线程使用（独占性资源）` |
| 🤝 **请求与保持条件** | `线程持有已有资源的同时继续申请新资源` |
| 🚫 **不可剥夺条件** | `已获得的资源不能被强制剥夺，只能由线程主动释放` |
| 🔄 **循环等待条件** | `存在一个资源循环等待链，多个线程之间相互等待` |

### 11.3 死锁示例



```java
public class DeadlockDemo {
    private static final Object lockA = new Object();
    private static final Object lockB = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (lockA) {
                System.out.println("线程1获得 lockA，等待 lockB...");
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}
                synchronized (lockB) {
                    System.out.println("线程1获得 lockB");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lockB) {
                System.out.println("线程2获得 lockB，等待 lockA...");
                try { Thread.sleep(100); } catch (InterruptedException ignored) {}
                synchronized (lockA) {
                    System.out.println("线程2获得 lockA");
                }
            }
        });

        t1.start();
        t2.start();
    }
}

// 运行说明：
// 线程1先获取lockA，再试图获取lockB
// 线程2先获取lockB，再试图获取lockA  
// 两个线程互相等待对方释放锁，导致死锁
```

### 11.4 诊断工具



```
死锁检测工具：
├── 📊 jstack：分析线程堆栈，定位锁依赖与BLOCKED状态
├── 🖥️ jconsole、VisualVM：图形化监控线程状态和资源锁定
├── 🔧 arthas：运行时分析JVM死锁（Thread command）
└── 💡 验证方法：
    ├── jps → 找到对应Java程序的PID
    └── jstack <pid> → 查看死锁信息
```

### 11.5 死锁避免策略



#### 🔧 1. 避免循环等待 - 固定锁顺序



```java
// 确保所有线程按相同顺序获取资源，打破"循环等待"条件
void doSomething() {
    // 线程都以id从小到大的顺序加锁，避免交叉依赖
    Object first = lockA.hashCode() < lockB.hashCode() ? lockA : lockB;
    Object second = lockA.hashCode() < lockB.hashCode() ? lockB : lockA;

    synchronized (first) {
        synchronized (second) {
            // 处理逻辑
        }
    }
}
```

#### 🔧 2. 使用tryLock设置超时



```java
// 使用ReentrantLock.tryLock(timeout)避免永久阻塞
Lock lockA = new ReentrantLock();
Lock lockB = new ReentrantLock();

boolean gotA = lockA.tryLock(1, TimeUnit.SECONDS);
boolean gotB = lockB.tryLock(1, TimeUnit.SECONDS);

if (gotA && gotB) {
    try {
        // 处理共享资源
    } finally {
        lockB.unlock();
        lockA.unlock();
    }
} else {
    // 获取失败，释放已有锁并重试
    if (gotA) lockA.unlock();
    if (gotB) lockB.unlock();
}
```

#### 🔧 3. 缩小锁粒度和持有时间



```java
// ❌ 错误做法：
synchronized (obj) {
    Thread.sleep(1000); // 占用锁时间过长
}

// ✅ 正确做法：
Object result;
synchronized (obj) {
    result = getData(); // 尽快取出数据，释放锁
}
// 后续处理放在锁外
process(result);
```

### 11.6 死锁避免策略选择



| 场景 | **推荐策略** |
|------|-------------|
| 🔄 **多线程获取多个资源** | `固定加锁顺序` |
| ⚡ **响应性强、不可长时间阻塞** | `tryLock() + 超时重试` |
| 🏎️ **高并发下共享缓存或数据结构** | `使用Concurrent系列容器` |
| 🛡️ **高可靠系统** | `死锁检测 + 告警 + 线程中断` |
| 🎯 **多线程控制访问速率** | `信号量（Semaphore）` |

### 11.7 相关概念对比



| 概念 | **描述** | **是否阻塞** | **是否可进展** |
|------|----------|-------------|---------------|
| 💀 **死锁** | `多线程互相等待资源，永久卡住` | `是` | `否` |
| 🔄 **活锁** | `线程相互让步，程序在运行却无进展` | `否` | `否` |
| 😴 **饥饿** | `某线程长期得不到调度（被高优先级线程长期压制）` | `否` | `否` |

### 11.8 死锁检测与预防



```
死锁检测技术体系：
├── 🔍 JVM自带检测：
│   ├── jstack命令：输出线程堆栈，分析死锁
│   ├── JVisualVM：图形界面查看死锁线程、锁持有情况
│   └── JMC（Java Mission Control）：高级性能分析
├── ⏰ 基于超时检测：
│   ├── 设置线程任务的最大执行时间
│   ├── 守护线程定期检查关键线程运行状态
│   └── 超时未返回视为潜在死锁，触发报警
├── 🔧 设计层面预防：
│   ├── 合理设计锁策略：降低锁粒度，避免锁嵌套
│   ├── 锁顺序一致：所有线程按统一顺序获取多个资源
│   ├── 代码审查 + 设计约束：团队明确资源获取顺序约定
│   └── 压力测试 + ChaosMonkey：高并发环境检测潜在场景
└── 💡 生产建议：
    ├── 定期使用jstack、ThreadMXBean进行死锁扫描
    ├── 配合可视化工具或监控平台自动报警
    └── 坚持"统一加锁顺序 + 限时加锁 + 降低锁粒度"三项基本法
```

---

## 12. 🔧 显式锁与隐式锁



### 12.1 核心概念



**🔸 基本分类**
```
锁实现方式分类：
├── 🔐 隐式锁（Implicit Lock）：
│   ├── 通过synchronized实现
│   ├── JVM自动加锁/释放锁
│   └── 开发者无需操作锁对象
└── ⚙️ 显式锁（Explicit Lock）：
    ├── 程序员手动创建锁对象（如ReentrantLock）
    ├── 手动加锁/解锁（lock()/unlock()）
    └── 位于java.util.concurrent.locks包中
```

### 12.2 隐式锁（synchronized）



**🔒 synchronized特性分析**

```
synchronized锁对象规则：
├── 🏠 实例方法：锁当前对象（this）
├── 🏢 静态方法：锁Class对象
└── 🎯 代码块：锁指定对象

核心特性：
├── ✅ 可重入性：同一线程可重复加锁
├── ⚡ 非公平性：不保证先进先出
├── 🔄 自动释放：执行完同步代码或抛出异常时自动释放
└── 🛡️ 安全性高：出错率低，使用简单
```

**⚙️ JVM优化机制（JDK 6+）**

```
synchronized性能优化：
├── 🎯 偏向锁：无竞争优化，单线程场景高效
├── ⚡ 轻量级锁：低竞争时避免重量锁开销
├── 🔒 重量级锁：高竞争时使用互斥量
├── 🗑️ 锁消除：编译器优化去除无用锁
└── 📏 锁粗化：合并连续加锁，减少调用次数
```

### 12.3 显式锁（Lock接口）



**🔧 Lock接口主要方法**

| 方法 | **功能描述** |
|------|-------------|
| 🔒 **lock()** | `获取锁（阻塞）` |
| 🔍 **tryLock()** | `尝试获取锁，立即返回结果` |
| ⏰ **tryLock(timeout)** | `指定时间内尝试获取锁` |
| 💥 **lockInterruptibly()** | `可中断方式获取锁` |
| 🔓 **unlock()** | `释放锁` |
| 📋 **newCondition()** | `生成条件变量支持await/signal` |

**🎯 主要实现类**

```
Lock接口实现类：
├── 🔄 ReentrantLock（重入锁）：
│   ├── 可重入、支持公平与非公平策略
│   ├── 支持中断、超时
│   └── 显式加锁，必须手动释放
├── 📖 ReentrantReadWriteLock：
│   ├── 读锁：共享，可多个线程同时获取
│   ├── 写锁：独占，只允许一个线程
│   └── 适合读多写少场景，提升并发读性能
└── 📊 StampedLock（JDK 8+）：
    ├── 支持三种模式：写锁、悲观读、乐观读
    ├── 适合高并发下的非阻塞读
    └── 不可重入，使用复杂但性能高
```

### 12.4 语法对比



| 类型 | **实现方式** | **示例** |
|------|-------------|----------|
| 🔒 **隐式锁** | `synchronized关键字` | `synchronized(obj) { ... }` |
| ⚙️ **显式锁** | `Lock接口实现类` | `lock.lock(); try { ... } finally { lock.unlock(); }` |

### 12.5 显式锁高级特性



#### 🔧 1. 可中断锁（lockInterruptibly）



```
特点与应用：
├── 💡 特点：
│   ├── 允许在等待获取锁期间响应线程中断
│   └── 与lock()区别：可被打断，不会永久阻塞
└── 🎯 应用场景：
    └── 对响应性要求高的并发任务，如远程调用、I/O操作
```

#### 🔧 2. 尝试加锁（tryLock）



```
两种使用方式：
├── 🚀 tryLock()：
│   └── 尝试立即获取锁，获取失败立即返回false
└── ⏰ tryLock(long time, TimeUnit unit)：
    └── 在给定时间内不断尝试获取锁，支持超时退出

应用场景：
└── 高并发环境中用于避免死锁风险，结合重试机制使用
```

#### 🔧 3. 公平锁支持



```java
// 构造方式控制公平性
ReentrantLock fairLock = new ReentrantLock(true);     // 公平锁
ReentrantLock unfairLock = new ReentrantLock();       // 非公平锁（默认）

// 公平性说明：
// 公平锁：线程按请求顺序获取锁（排队），避免"插队"或线程饥饿
// 非公平锁：性能更高，允许后来线程直接尝试获取锁
```

#### 🔧 4. 条件变量（Condition）



```java
// 创建和使用条件变量
Condition condition = lock.newCondition();

// 主要方法：
// await()：当前线程等待，释放锁
// signal()：唤醒一个等待线程  
// signalAll()：唤醒所有等待线程

// 特点：支持多个条件对象，比Object.wait/notify更灵活
// 应用：比如队列满了/空了通知生产者/消费者
```

### 12.6 显式锁 vs 隐式锁对比



| 特性 | **显式锁** | **隐式锁** |
|------|------------|------------|
| 🔧 **使用灵活性** | `支持中断、超时、非阻塞、公平策略、条件变量` | `使用简单、语法清晰，适合简单同步场景` |
| ⚡ **性能比较** | `JDK 6前性能优于synchronized` | `JDK 6后性能相近，JVM已优化synchronized` |
| 🎯 **使用场景** | `需公平性、超时、中断、读写分离时使用` | `简单同步场景建议使用` |
| 🛡️ **安全性** | `必须手动unlock()，否则易导致死锁` | `自动释放，代码安全性更高` |

### 12.7 选择建议



**💡 使用指导原则**
```
锁选择策略：
├── 🔒 优先选择synchronized：
│   ├── 日常开发中简单同步场景
│   ├── 语法简洁，自动释放，安全性高
│   └── JDK 6后性能已得到大幅优化
├── ⚙️ 选择显式锁的场景：
│   ├── 需要公平锁特性
│   ├── 需要中断或超时控制
│   ├── 需要读写锁分离
│   ├── 需要条件变量支持
│   └── 复杂的并发控制逻辑
└── ⚠️ 显式锁使用要点：
    └── 必须配合try-finally保证unlock()调用
```

---

## 13. 🔗 嵌套锁



### 13.1 核心概念



**🔸 基本定义**
```
嵌套锁（Nested Lock）：
• 当一个线程持有一把锁的同时，在锁未释放前又尝试获取另一把锁
• 形成"锁中锁"的多层结构（外→内→更内）
• 与可重入锁的关系：Java的synchronized和ReentrantLock支持可重入性
• 锁层级结构：嵌套锁天然形成锁的"层级"，需管理好顺序避免死锁
```

### 13.2 典型实现示例



#### 🔧 synchronized嵌套示例



```java
public class NestedLockExample {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void method() {
        synchronized (lockA) {
            System.out.println("持有锁A");
            synchronized (lockB) {
                System.out.println("持有锁B");
                // 嵌套临界区
            }
        }
    }
}
// 说明：一个线程先获取lockA，再进入lockB
// 如果其他线程也以不同顺序加锁，就可能发生死锁
```

#### 🔧 ReentrantLock嵌套示例



```java
// 可嵌套调用lock()，但unlock()必须匹配调用次数
lock.lock();
try {
    lock.lock();  // 嵌套加锁
    try {
        // 嵌套加锁逻辑
    } finally {
        lock.unlock();
    }
} finally {
    lock.unlock();
}
```

### 13.3 嵌套锁的风险与问题



**⚠️ 主要风险**
```
嵌套锁风险分析：
├── 💀 死锁风险（最常见）：
│   ├── 两个线程持有锁A和锁B，嵌套请求顺序不一致
│   └── 解决方案：统一加锁顺序、使用tryLock
├── 🐌 性能问题：
│   ├── 锁嵌套过深导致线程调度复杂
│   ├── 上下文切换增多
│   └── 建议：缩小锁粒度、避免锁中执行阻塞操作
└── 🔓 解锁不规范：
    ├── 特别在ReentrantLock中
    └── 嵌套加锁必须按层级完全释放
```

### 13.4 嵌套锁最佳实践



**✅ 推荐做法**
```
嵌套锁优化策略：
├── 🚫 尽量避免：避免嵌套获取多个锁，特别是在共享资源多时
├── 📏 统一顺序：若必须嵌套加锁
│   ├── 明确加锁顺序，所有线程保持一致  
│   └── 可使用对象哈希排序、ID比较等方法统一顺序
├── ⏰ 超时机制：使用tryLock + 超时 + 回退机制避免死锁
└── 🔄 规范释放：保证unlock成对调用，推荐使用try-finally包裹每一层锁
```

### 13.5 嵌套锁实现方式



```java
// 1. 使用隐式锁synchronized
synchronized (obj1) {
    synchronized (obj2) {
        // 嵌套操作
    }
}

// 2. 使用显式锁ReentrantLock
lock1.lock();
try {
    lock2.lock();
    try {
        // 嵌套处理
    } finally {
        lock2.unlock();
    }
} finally {
    lock1.unlock();
}
```

### 13.6 概念对比辨析



| 特性 | **嵌套锁** | **可重入锁** |
|------|------------|-------------|
| 🔒 **锁的对象** | `多个不同的锁` | `同一个锁（多次获取）` |
| 📝 **示例** | `synchronized(lockA) → lockB` | `synchronized(this) → this` |
| ✅ **是否自动支持** | `支持但需注意顺序` | `支持（ReentrantLock、synchronized）` |
| ⚠️ **主要风险** | `死锁` | `死锁较少，但仍需释放次数一致` |

**🔍 相关概念对比**
```
概念关系梳理：
├── 🔗 嵌套锁 vs 可重入锁：
│   └── 嵌套锁是结构层次；可重入锁是同一线程重复持有同一把锁的能力
├── 💀 嵌套锁 vs 死锁：
│   └── 嵌套锁本身不等于死锁，但嵌套结构不合理容易造成死锁
└── 📋 嵌套锁 vs 资源锁定顺序：
    └── 嵌套锁需要开发者自行维持资源访问顺序，防止冲突
```

---

## 14. 🤝 共享锁与独占锁



### 14.1 核心概念



**🔸 基本定义**
```
独占锁（Exclusive Lock）：
• 同一时刻仅允许一个线程持有该锁
• 别名：写锁、排他锁
• 行为特征：写操作使用，防止并发修改导致数据不一致

共享锁（Shared Lock）：
• 同一时刻允许多个线程同时持有锁（前提是无写线程持有）
• 别名：读锁
• 行为特征：读操作使用，允许并发读取但不允许修改
```

### 14.2 Java具体实现



#### 🔧 ReentrantReadWriteLock（读写锁）



```
ReentrantReadWriteLock特性：
├── 📦 来源：java.util.concurrent.locks包
├── 🔧 使用方式：
│   ├── ReadLock readLock = lock.readLock();   // 共享锁
│   └── WriteLock writeLock = lock.writeLock(); // 独占锁
└── 📊 特性说明：
    ├── 多线程读：共享不互斥
    ├── 写线程独占：写时禁止读写
    └── 写优先/读优先可配置
```

#### 🔧 StampedLock（JDK 8+）



```
StampedLock高级特性：
├── 🎯 三种模式：
│   ├── 乐观读锁：先不加锁，读取后校验数据一致性
│   ├── 悲观读锁：传统共享读锁
│   └── 写锁：独占写锁
├── ⚡ 性能优势：相较于ReentrantReadWriteLock性能更高
├── ⚠️ 使用限制：不支持重入，使用复杂度高
└── 🎯 适用场景：读多写少场景中极具性能优势
```

### 14.3 锁兼容性矩阵



| 锁类型 | **是否互斥** | **可否并发** | **适用操作** |
|--------|-------------|-------------|-------------|
| 📖 **读-读（共享）** | `❌ 不互斥` | `✅ 可并发` | `多线程读取` |
| 🔄 **读-写** | `✅ 互斥` | `❌ 不可并发` | `防止写时读错` |
| ✏️ **写-写** | `✅ 互斥` | `❌ 不可并发` | `写冲突` |

### 14.4 特性对比分析



| 比较维度 | **独占锁（写锁）** | **共享锁（读锁）** |
|----------|------------------|------------------|
| 🔢 **是否可多个线程持有** | `否` | `是（前提是没有写线程）` |
| 🎯 **适合操作类型** | `修改资源（写）` | `只读资源` |
| 🚫 **是否互斥** | `是（读写互斥、写写互斥）` | `仅与写互斥，读读不互斥` |
| 🚀 **并发能力** | `低` | `高（适合读密集型系统）` |
| 🔧 **Java实现类** | `ReentrantReadWriteLock.WriteLock` | `ReentrantReadWriteLock.ReadLock` |

### 14.5 工作机制



**⚙️ 内部实现逻辑**
```
共享锁（读锁）机制：
├── ✅ 多线程同时读：允许
├── 🚫 有写锁在时：全部读线程阻塞
└── 📊 内部使用计数器追踪并发持有者

独占锁（写锁）机制：
├── 🔒 写线程持有时：其他读/写全部阻塞
└── 🎯 一次只允许一个线程进入临界区
```

### 14.6 使用示例



```java
// ReentrantReadWriteLock使用示例
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock readLock = rwLock.readLock();     // 共享锁
Lock writeLock = rwLock.writeLock();   // 独占锁

// 读操作
public void readData() {
    readLock.lock();
    try {
        // 多线程并发读取
    } finally {
        readLock.unlock();
    }
}

// 写操作
public void writeData() {
    writeLock.lock();
    try {
        // 写操作需独占
    } finally {
        writeLock.unlock();
    }
}
```

### 14.7 应用场景



| 场景 | **推荐锁类型** | **理由** |
|------|---------------|----------|
| 📖 **缓存查询** | `共享锁` | `多线程并发读取无需互斥` |
| 🔄 **缓存更新** | `独占锁` | `保证写操作原子性` |
| ⚖️ **配置读取（频繁读偶尔写）** | `读写锁` | `写独占 + 读共享平衡效率与一致性` |
| 💰 **日志写入、银行转账** | `独占锁` | `操作具有原子性要求` |

### 14.8 注意事项



**⚠️ 重要提醒**
```
使用要点：
├── 1️⃣ 读写锁不能防止"读脏数据"：
│   ├── 只要写锁没释放，读线程不能进
│   └── 但如果绕过锁读，仍然可能读到不一致数据
├── 2️⃣ 锁降级规则：
│   ├── 写锁可以降级为读锁（先获取读再释放写）
│   └── 但必须按正确顺序操作
└── 3️⃣ 锁升级限制：
    ├── ❌ 读锁不可升级为写锁（会死锁）
    └── 原因：多个读锁持有者无法协调升级
```

```java
// ✅ 正确的锁降级示例
writeLock.lock();
try {
    // 更新完数据
    readLock.lock();  // 锁降级
} finally {
    writeLock.unlock();
}
// 继续读操作...
readLock.unlock();

// ❌ 错误的锁升级（会死锁）
readLock.lock();
try {
    writeLock.lock(); // ❌ 升级行为会死锁
    // ...
} finally {
    readLock.unlock();
}
```

---



## 15. 🔄 CAS、AQS与ABA问题



### 15.1 目录导航


- [CAS（Compare And Swap）](#cas-compare-and-swap)
- [AQS（AbstractQueuedSynchronizer）](#aqs-abstractqueuedsynchronizer)
- [ABA问题](#aba问题)

---

# CAS（Compare And Swap）



### 15.2 CAS核心概念



**🔸 基本定义**
```
CAS（Compare And Swap）：
• 一种无锁的原子操作机制，用于实现并发安全
• 在更新变量前先比较当前值是否为预期值，若相等则更新
• 属于乐观锁（假设冲突少，冲突时再重试）
```

**⚙️ 三个核心参数**
```
CAS操作的三要素：
├── V：当前内存中的值（Value）
├── E：期望值（Expected）
└── N：准备写入的新值（New）

基本语义：
if (V == E) then V = N; else retry or fail
```

### 15.3 CAS实现原理



**🏗️ 底层依赖原语**
```
CAS底层实现机制：
├── 💻 CPU层面：
│   ├── CAS操作由处理器指令级别保证原子性
│   ├── 常见指令：x86架构中的CMPXCHG（Compare and Exchange）
│   └── 在一条CPU指令内完成"比较 + 替换"，不可被打断
├── ☕ Java层面：
│   ├── JVM中的CAS通过sun.misc.Unsafe类提供原子操作
│   ├── 常用方法：
│   │   ├── compareAndSwapInt(Object o, long offset, int expected, int newValue)
│   │   └── compareAndSwapObject(...) / compareAndSwapLong(...)
│   └── 这些方法最终通过native方法调用平台底层CPU原语
└── 🔄 无锁机制：
    ├── CAS操作失败不会阻塞线程，而是自旋重试
    └── 高并发下可能出现ABA问题或CPU空转
```

### 15.4 CAS特性分析



| 特性 | **优点** | **缺点** |
|------|----------|----------|
| 🚀 **性能** | `无需加锁，避免线程阻塞，高并发环境下表现优越` | `自旋重试开销高（在竞争激烈时浪费CPU）` |
| ⚡ **原子性** | `原子性由底层硬件（CPU指令）保障` | `只能对单个变量操作（多个变量需加锁或借助原子引用）` |
| 🎯 **乐观策略** | `假设冲突少，无阻塞机制` | `ABA问题：值变回去了但其实已被修改过` |

### 15.5 Java中CAS的应用



#### 🔧 Atomic包应用



```java
// 典型应用：尝试将counter的值从0修改为1
AtomicInteger counter = new AtomicInteger(0);
counter.compareAndSet(0, 1); // CAS操作

// 等价逻辑（伪代码）：
if (counter.get() == 0) {
    counter.set(1);
}
// 但上面的逻辑在多线程下不是线程安全的，而compareAndSet(0, 1)是原子性的
```

#### 🔧 CAS使用示例



```java
public class CASDemo {
    private static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) {
        // 模拟并发更新
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                int oldValue, newValue;
                do {
                    oldValue = count.get();
                    newValue = oldValue + 1;
                } while (!count.compareAndSet(oldValue, newValue));
                System.out.println(Thread.currentThread().getName() + " 修改成功：" + newValue);
            }).start();
        }
    }
}
```

### 15.6 CAS应用场景



```
CAS典型应用场景：
├── 🔢 高效的并发计数器：
│   └── 如AtomicInteger、AtomicLong替代synchronized加计数
├── 🏗️ 构建无锁数据结构：
│   └── 如无锁栈、无锁队列、无锁链表（LinkedQueue）
├── 🌀 实现自旋锁：
│   └── 利用CAS + 自旋实现无阻塞互斥控制
├── 😊 乐观锁机制的基础：
│   └── 提前假设不会冲突，操作完成后再校验
└── 🧩 JUC并发包的底层核心：
    └── AQS、线程池、原子类等核心类都使用CAS保证原子性
```

### 15.7 CAS缺陷与解决方案



**⚠️ 主要缺陷**
```
CAS缺陷分析：
├── 🔄 ABA问题：
│   ├── 问题：某线程读取到值A → 其他线程将其改为B → 又改回A
│   ├── 影响：当前线程CAS时发现值还是A，误以为没有被改动
│   └── 解决：使用AtomicStampedReference或AtomicMarkableReference
├── 💻 自旋开销高：
│   ├── 问题：高并发下CAS操作频繁失败，导致线程不断自旋重试
│   ├── 影响：CPU空转严重，可能形成"活锁"
│   └── 解决：限制重试次数、引入退避策略
└── 🎯 只能操作一个变量：
    ├── 问题：CAS操作一次只能保证一个内存位置的原子性
    ├── 影响：无法原子性地更新两个或多个字段
    └── 解决：使用AtomicReference封装多个变量
```

### 15.8 CAS性能优化策略



| 缓解方案 | **原理** | **适用说明** |
|----------|----------|-------------|
| ✅ **限制自旋次数** | `设置最大重试次数，避免无限循环` | `可结合for循环+break` |
| ✅ **指数退避（Backoff）** | `每次失败后等待一段随机时间再重试` | `模拟网络退避机制，减少碰撞` |
| ✅ **降低竞争粒度** | `将共享变量拆成多个（分段锁思想）` | `类似LongAdder、ConcurrentHashMap` |
| ✅ **结合锁机制** | `高冲突场景退回synchronized保护` | `比如低并发用CAS，高并发切换为锁` |
| ✅ **使用高阶并发工具类** | `如LongAdder、Striped等` | `内部封装了竞争控制机制` |

### 15.9 CAS与其他同步机制对比



| 对比项 | **CAS** | **synchronized** | **ReentrantLock** |
|--------|---------|-----------------|------------------|
| 🔒 **锁机制** | `无锁` | `显式加锁` | `显式加锁` |
| 🚫 **是否阻塞** | `否，自旋重试` | `是，阻塞线程` | `是，可配置公平性` |
| ⚡ **性能** | `高（低冲突场景）` | `中` | `高（可中断、超时等功能）` |
| 🛡️ **原子性保证方式** | `CPU原子指令` | `JVM内置锁机制` | `AQS + CAS实现` |

---

# AQS（AbstractQueuedSynchronizer）



### 15.10 AQS核心概念



**🔸 基本定义**
```
AQS（AbstractQueuedSynchronizer）：
• Java并发包中的抽象基类，位于java.util.concurrent.locks包
• 为构建锁和同步器提供通用框架
• 基于"模板方法模式"：AQS提供通用框架，子类实现具体逻辑
```

**🏗️ 设计理念**
```
AQS核心思想：
├── 📊 同步状态管理（state）：
│   └── AQS使用一个int类型变量state表示同步状态（如锁是否已被占用）
├── 🔄 FIFO同步队列（CLH队列）：
│   ├── 被阻塞的线程构成一个双向链表等待队列
│   ├── 只有队首线程才有资格竞争锁
│   └── 保证线程获取顺序公平（可支持非公平模式）
└── 📋 条件队列（Condition）：
    ├── 每个Condition对象关联一个等待队列（不是共享同步队列）
    └── 支持await()/signal()的线程间通信机制
```

### 15.11 AQS核心组成



**📊 核心字段**

| 字段 | **说明** |
|------|----------|
| `volatile int state` | `表示同步状态（比如锁是否被占用）` |
| `Node head`、`Node tail` | `同步队列的头尾指针，组成一个CLH队列` |
| `Thread exclusiveOwnerThread` | `独占锁拥有者线程（在ReentrantLock中）` |

> state是一个整数，表示资源占用状态，子类通过getState()、setState()、compareAndSetState()控制状态变化

### 15.12 AQS工作模式



**🎯 两种基本模式**

| 维度 | **独占模式（Exclusive）** | **共享模式（Shared）** |
|------|-------------------------|----------------------|
| 🔢 **同时访问线程数** | `仅一个` | `可多个` |
| 📝 **示例类** | `ReentrantLock, FutureTask` | `CountDownLatch, Semaphore, ReadLock` |
| 🔧 **AQS方法** | `tryAcquire / tryRelease` | `tryAcquireShared / tryReleaseShared` |
| 🎯 **使用场景** | `互斥锁、任务控制` | `并发限流、资源信号、读并发` |

### 15.13 AQS工作流程



**⚙️ 独占模式工作流程**
```
Thread.acquire()
   |
tryAcquire()  → 成功 → 直接执行
   ↓
失败 → 入队（尾部） → park() 阻塞
   ↓
其他线程 release() → unpark() → 重试 acquire()
```

**🔧 核心模板方法（需子类实现）**
```
AQS提供的核心方法：
├── 🔐 独占模式（Exclusive）：
│   ├── tryAcquire(int arg)
│   ├── tryRelease(int arg)
│   └── isHeldExclusively()
└── 🤝 共享模式（Shared）：
    ├── tryAcquireShared(int arg)
    └── tryReleaseShared(int arg)
```

### 15.14 基于AQS的同步器实现



| 类名 | **说明** |
|------|----------|
| `ReentrantLock` | `可重入独占锁（非公平/公平）` |
| `CountDownLatch` | `倒计时器，计数为0前阻塞` |
| `Semaphore` | `控制资源许可数（共享）` |
| `ReentrantReadWriteLock` | `读写锁，读共享，写独占` |
| `FutureTask` | `支持结果的任务执行控制` |
| `ConditionObject` | `AQS内部条件队列实现Condition接口` |

### 15.15 AQS优缺点分析



**✅ 主要优点**
```
AQS优势分析：
├── 🔧 模板方法设计：
│   └── 提供可复用的加锁/解锁框架，子类只需实现核心方法
├── ⚡ 高效的状态 + 队列机制：
│   ├── 利用CAS操作维护state同步状态
│   └── 使用CLH双向队列管理线程排队，避免忙等
├── 🎯 支持多种同步模型：
│   ├── 支持独占模式（如ReentrantLock）
│   └── 支持共享模式（如Semaphore、CountDownLatch）
└── 🏗️ 并发工具类基础组件：
    └── AQS是Java并发工具包的核心基石
```

**❌ 主要限制**
```
AQS局限性：
├── 📚 原理复杂，学习成本高：
│   └── 队列结构、CAS、信号机制等实现细节对初学者不友好
├── 📊 状态字段设计受限：
│   ├── 内部state仅为一个int类型
│   └── 多状态控制需手动位运算或状态管理逻辑，增加代码复杂度
└── 🎯 专为同步器设计，非通用队列：
    └── 不适合作为普通阻塞队列使用，仅服务于并发控制器
```

### 15.16 AQS性能优化建议



**🚀 优化策略**
```
AQS使用与优化建议：
├── 🔧 优先使用JUC提供的成熟同步器：
│   └── 如ReentrantLock、CountDownLatch、Semaphore、ReadWriteLock
├── ⚙️ 自定义同步器注意要点：
│   ├── 精简tryAcquire/tryRelease实现逻辑（避免阻塞操作）
│   └── 合理控制同步状态值（state）的原子更新策略
├── 🎯 模式选择要根据场景：
│   ├── 独占模式：适用于写锁、强一致场景
│   └── 共享模式：适用于信号量、读锁、允许并发访问场景
└── 📊 减少上下文切换：
    └── 加锁操作尽量控制在短时间内完成，减少线程频繁切换
```

---

# ABA问题



### 15.17 ABA问题核心概念



**🔸 基本定义**
```
ABA问题：
• 在并发环境中，某变量从A → B → A，被其他线程多次修改后又恢复原值
• 恢复后的值仍为A，CAS操作检测时只比较值，不检测"是否被动过"
• 线程误判为"未被修改"，从而继续执行，可能导致错误

名称来源：A → B → A的变化路径，看似"没变"，实则"被动过"
```

### 15.18 ABA问题形成原因



**⚙️ 产生机制**
```
ABA问题形成原因：
├── 🔍 CAS机制的局限：
│   ├── CAS只检查值是否为预期值（E == V），不记录修改历史
│   └── 无法判断变量是否经历过"中间状态"
├── 🔄 多线程交错：
│   ├── 线程T1读取值A → 被挂起
│   ├── 线程T2将A改为B，再改回A
│   └── T1恢复后继续执行，CAS检查发现A == A → 错误通过
└── 📝 无版本保护机制：
    └── Java中的普通原子类如AtomicInteger不自带版本或标记位
```

### 15.19 ABA问题典型场景



**🎯 常见应用场景**
```
ABA问题出现场景：
├── 💻 基于CAS的无锁操作：
│   ├── 并发环境 + CAS操作
│   ├── CAS只检查当前值是否等于期望值（V == E）
│   └── 当值A被修改为B又改回A，CAS仍判断为成功
├── 🔗 链表/栈/队列等结构的并发操作：
│   ├── Lock-Free栈（Treiber Stack）
│   ├── 并发链表的头/尾节点变更
│   └── 并发队列（如基于链表的队列）
├── 📊 使用原子类（AtomicXXX）：
│   ├── AtomicInteger、AtomicReference等
│   └── 内部采用Unsafe + CAS实现，默认只检查数值/引用值本身
└── 🎯 对象引用更新：
    └── 引用被线程A修改，线程B在不知情的情况下使用旧引用继续操作
```

### 15.20 ABA问题典型示例



```java
// ABA问题演示（伪代码）
AtomicInteger atomicInt = new AtomicInteger(100);

Thread A:
int expected = atomicInt.get(); // 读取值 100
// ...此时挂起...

Thread B:
atomicInt.compareAndSet(100, 200); // 改为 200
atomicInt.compareAndSet(200, 100); // 又改回 100

Thread A 恢复：
atomicInt.compareAndSet(expected, 300); // 判断成功，实际已被改过

// 问题：虽然值是100，但它已经被修改过了，Thread A并不知道！
```

### 15.21 ABA问题的危害



**⚠️ 主要危害**
```
ABA问题危害分析：
├── 💥 并发逻辑错误：
│   └── 错误判断"值未变化"，导致执行错误逻辑路径
├── 📊 数据不一致：
│   ├── 状态判断失效 → 多线程并发写入/更新出错
│   └── 如重复消费消息、重复释放资源
├── 🔗 数据结构完整性破坏：
│   ├── 链表/队列的指针错乱，next/prev丢失连接
│   └── 节点先被移除再被还原，可能造成链路中断或节点丢失
├── 🔄 死锁或活锁：
│   └── 锁释放逻辑依赖于状态判断，若判断错误可能陷入死循环
└── 🛡️ 安全漏洞：
    └── 系统行为在高并发下不再可控，出现难以复现的异常bug
```

### 15.22 ABA问题解决方案



#### 🔧 方案1：使用AtomicStampedReference



```java
// 使用版本号机制
AtomicStampedReference<Integer> ref = new AtomicStampedReference<>(100, 1);

// 获取值和版本号
int[] stampHolder = new int[1];
int value = ref.get(stampHolder);
int stamp = stampHolder[0];

// 进行CAS操作
ref.compareAndSet(value, 200, stamp, stamp + 1);

// ✅ 即便值是100，只要stamp不是旧的，也无法更新，从而识别出"伪未修改"
```

#### 🔧 方案2：使用AtomicMarkableReference



```java
// 使用布尔标记机制
AtomicMarkableReference<Integer> ref = new AtomicMarkableReference<>(100, false);

boolean[] markHolder = new boolean[1];
int value = ref.get(markHolder);
boolean mark = markHolder[0];

ref.compareAndSet(value, 200, mark, true);
```

#### 🔧 方案3：使用分段并发工具类



```java
// 避免单点冲突，绕开ABA风险
// 不是直接防止，而是避免频繁写同一个变量
LongAdder adder = new LongAdder();
adder.increment(); // 内部使用分段策略，减少竞争
```

### 15.23 ABA问题防护对比



| 类别 | **是否能防ABA** | **说明** |
|------|---------------|----------|
| `AtomicInteger` | ❌ | `只能比较数值，无法判断中途变化` |
| `AtomicStampedReference` | ✅ | `值 + 版本号` |
| `AtomicMarkableReference` | ✅ | `值 + boolean标记` |
| `自定义带版本控制的CAS` | ✅ | `手动维护版本号字段` |

### 15.24 CAS、AQS、ABA关系总结



**🔗 三者关联关系**

| 关联 | **说明** |
|------|----------|
| 🔄 **CAS原理** | `引发ABA问题的基础操作机制` |
| 🏗️ **AQS使用CAS** | `维护同步状态state，若不加版本保护可能产生ABA问题` |
| ⚛️ **AtomicXXX** | `基于Unsafe的CAS实现，容易出现ABA` |
| 🔧 **Unsafe** | `提供原子方法如compareAndSwapInt()，但不自带防护机制` |

**💡 实践建议**
```
综合使用指导：
├── 🔄 CAS适用场景：
│   ├── 优先用于"无锁场景"：计数、标志、引用替换
│   ├── 需关注ABA问题、空转CPU等风险
│   └── 在实际工程中结合Atomic类或AQS等上层封装使用
├── 🏗️ AQS框架特点：
│   ├── CAS是构建高性能并发框架的核心原语
│   ├── AQS基于CAS实现状态管理，是Java并发包的基石
│   └── 提供了完整的线程调度和同步机制
└── ⚠️ ABA问题防护：
    ├── 在核心并发场景使用版本控制、不可变对象
    ├── 优先使用AtomicStampedReference等带版本机制的工具
    └── 设计数据结构时尽量使用不可变对象或带唯一标识的节点
```


## 16. 🎯 偏向锁



### 16.1 核心概念



**🔸 基本定义**
```
偏向锁（Biased Lock）：
• 一种优化"无竞争线程获取锁"的锁机制，旨在消除同一线程反复获取同一锁对象的开销
• 不会再使用synchronized关键字的重量级加锁操作，也不涉及CAS、自旋、阻塞等常规"加锁流程"
• 通过对象头（Mark Word）中的偏向标志 + 线程ID来"伪装"自己已经加锁
• 是一种"逻辑上加锁，物理上不争用"的锁机制
```

**🎯 设计目标**
```
偏向锁的核心思想：
├── 🔒 锁偏向机制：
│   ├── 对象头中记录持有锁的线程ID（Mark Word区域）
│   ├── 同一个线程再次进入同步块时，不再执行CAS操作
│   └── 只需判断是否为"我上次加过的锁"，是则直接进入临界区
├── ⚡ 性能优化：
│   ├── 在没有线程竞争的前提下，避免使用重量级锁或自旋锁
│   └── 减少线程获取锁时的CAS、同步操作等开销
└── 🎯 适用场景：
    └── 同一个线程重复进入同步块，例如单线程场景或线程不切换的任务执行过程
```

### 16.2 偏向锁特性分析



**📊 与其他锁状态对比**
```
偏向锁在锁演化中的位置：
├── 偏向锁：无竞争，偏向某线程，最快
├── 轻量级锁：有潜在竞争，自旋尝试获取
└── 重量级锁：存在阻塞和唤醒，最慢

核心特点：
├── ✅ 只能偏向一个线程（非多线程共享）
├── ✅ 无需CAS比较，无需锁膨胀
├── ⚠️ 会在有竞争时升级为轻量级锁或重量级锁
└── 🎯 适合频繁进入同步块的单线程环境
```

### 16.3 偏向锁实现原理



**🏗️ 对象头结构（Mark Word）**
```
偏向锁实现机制：
├── 📊 包含信息：
│   ├── 锁标志位（2bit）
│   ├── 是否偏向标志（1bit）
│   ├── 线程ID
│   └── 时间戳等其他信息
├── 🔧 加锁逻辑：
│   ├── 第一次加锁：对象处于可偏向状态 → 写入当前线程ID → 获得偏向锁
│   ├── 后续加锁：判断线程ID是否一致 → 一致则直接加锁成功（无竞争）
│   └── 解锁：偏向锁不执行真正的释放操作，提升性能
└── ⚙️ 偏向锁通过将线程ID写入Mark Word来表示"偏向某个线程"
```

**🔄 偏向锁获取过程**
```
获取流程详解：
├── 1️⃣ 检查对象Mark Word是否为：
│   └── 可偏向状态（锁标志位01，偏向标志位为1）
├── 2️⃣ 如果Mark Word中线程ID == 当前线程：
│   └── 已获得锁，直接返回
├── 3️⃣ 如果线程ID不一致或为空：
│   └── 通过CAS尝试将线程ID更新为当前线程ID
│       ├── CAS成功：获取偏向锁成功
│       └── CAS失败：存在竞争 → 撤销偏向 → 升级为轻量级锁
└── 4️⃣ 撤销条件：
    ├── 其他线程尝试竞争该锁
    ├── 调用了对象的hashCode()
    ├── 调用了System.identityHashCode()
    └── JVM执行了批量重偏向或批量撤销
```

### 16.4 锁状态演化



**📈 JVM锁优化策略**

| 锁状态 | **说明** |
|--------|----------|
| 🔓 **无锁** | `对象未被任何线程加锁` |
| 🎯 **偏向锁（Biased）** | `偏向某个线程，后续无需加锁检查` |
| ⚡ **轻量级锁** | `存在多个线程尝试加锁，但无竞争（使用CAS）` |
| 🔒 **重量级锁** | `存在真实竞争，线程阻塞` |

### 16.5 偏向锁的配置与控制



**⚙️ JVM参数控制**

| 参数 | **说明** |
|------|----------|
| `-XX:+UseBiasedLocking` | `开启偏向锁（默认）` |
| `-XX:-UseBiasedLocking` | `禁用偏向锁` |
| `-XX:BiasedLockingStartupDelay=0` | `立即启用偏向锁，无延迟` |

**🔧 开启与关闭特性**
```
偏向锁控制机制：
├── 📋 默认开启（JDK 1.6+）
├── ⏰ 延迟开启（启动后几秒生效，JVM优化warm-up）
├── 🚫 关闭参数：-XX:-UseBiasedLocking
└── ⚡ 立即开启：-XX:BiasedLockingStartupDelay=0
```

### 16.6 偏向锁的撤销与升级



**🔄 撤销与升级机制**
```
偏向锁生命周期管理：
├── 🚫 撤销条件：
│   ├── 偏向线程退出或对象进入被另一个线程竞争
│   └── JVM触发安全点（safepoint）进行批量重偏向或撤销
├── ⬆️ 升级过程：
│   ├── 偏向锁 → 轻量级锁（当发现其他线程也要加锁）
│   └── 轻量级锁 → 重量级锁（竞争激烈，自旋失败）
└── 📊 批量重偏向/撤销：
    ├── JVM监测到类对象下多个实例都撤销偏向锁
    └── 会统一对该类禁用偏向锁优化
```

**⚙️ 撤销过程详解**
```
撤销流程：
├── 🔍 遍历偏向线程栈寻找锁记录
├── ⏳ 若找到锁记录，需等到"安全点"才能撤销
└── 🔄 撤销后处理：
    ├── 若无竞争 → 回到无锁状态
    └── 若有竞争 → 升级为轻量级锁
```

### 16.7 偏向锁性能特性



**✅ 主要优点**
```
偏向锁优势：
├── ⚡ 减少无竞争场景下的同步开销
├── 🚀 大幅提高单线程访问同步块的性能
└── 🎯 实现了锁的"懒获取"策略（Lazy Acquisition）
```

**❌ 主要缺点**
```
偏向锁劣势：
├── 💰 存在竞争时，偏向锁撤销成本高（需要暂停并等待安全点）
├── 🔄 锁竞争激烈时可能带来性能负担
└── 🎯 优化效果主要体现在线程独占访问的场景
```

### 16.8 适用场景分析



**✅ 适合的场景**
```
理想应用环境：
• 单线程反复访问同步块（如栈封闭数据）
• 多线程交替访问但无锁竞争（无线程抢占锁）
• 某个线程反复加锁某对象，比如线程池内任务执行
• 对象频繁被同一线程加锁使用
```

**❌ 不适合的场景**
```
不建议使用：
• 锁竞争激烈（频繁线程切换）
• 多线程访问共享资源
• 会导致大量偏向锁撤销，反而拖慢性能
建议：高并发场景使用-XX:-UseBiasedLocking禁用偏向锁
```

### 16.9 偏向锁 vs 其他锁对比



| 特性 | **偏向锁** | **轻量级锁** | **重量级锁** |
|------|------------|-------------|-------------|
| 🚫 **是否阻塞** | `否` | `否` | `是` |
| ⚙️ **是否使用CAS** | `否` | `是` | `否` |
| 🔄 **线程切换** | `否` | `否` | `是` |
| 🎯 **适用场景** | `无竞争` | `轻度竞争` | `高竞争` |
| 💰 **撤销/升级代价** | `有（STW）` | `无` | `高` |

### 16.10 高频问题总结



| 问题 | **简要回答** |
|------|-------------|
| **什么是偏向锁？** | `一种优化无竞争线程加锁的机制，将锁偏向于一个线程，避免同步开销` |
| **偏向锁怎么实现的？** | `把线程ID写入对象头，判断线程是否一致` |
| **偏向锁适合什么场景？** | `单线程多次加锁、无竞争` |
| **偏向锁会自动升级吗？** | `会，在出现竞争时撤销并升级为轻量级锁或重量级锁` |
| **偏向锁有哪些弊端？** | `撤销成本高，撤销过程是STW，会影响吞吐量` |

---

## 17. 🧩 离散锁



### 17.1 核心概念



**🔸 基本定义**
```
离散锁（Segmented Lock / Discrete Lock）：
• 将整体资源划分为多个段，每个段使用独立锁控制的并发优化技术
• 核心思想：减小锁的粒度，提升并发度，避免"全局大锁"导致的性能瓶颈
• 通俗理解：把一把大锁拆成多把小锁，按需加锁，各用各的，互不干扰
```

### 17.2 离散锁特点



**🌟 核心特性**
```
离散锁特性分析：
├── 🎯 精细化控制：每段资源独立加锁，避免全局锁冲突
├── 🚀 支持并行访问：多个线程可并发操作不同段的资源
├── 🔧 锁定对象而非代码块：更加灵活，可精确控制访问粒度
└── 📊 支持共享/排他多种访问级别
```

### 17.3 离散锁与传统锁对比



| 对比项 | **传统全局锁** | **离散锁（分段锁）** |
|--------|---------------|-------------------|
| 🔒 **粒度** | `一把锁控制所有资源` | `多把锁分段控制部分资源` |
| 🚀 **并发性能** | `竞争激烈、阻塞严重` | `冲突减少、吞吐量提升` |
| 💾 **内存占用** | `低` | `高（多把锁对象）` |
| 🔧 **实现复杂度** | `简单` | `中等（需要管理多个段和索引策略）` |

### 17.4 典型应用场景



**🎯 适用场景**
```
离散锁应用领域：
├── 📊 HashMap并发优化（如ConcurrentHashMap）
├── 🗂️ 数据分片访问（如缓存、配置中心、路由表）
└── 📈 高频读写但互相独立的数据结构
```

### 17.5 Java中的典型实现



**🔧 ConcurrentHashMap（JDK 1.7）实现**
```java
// ConcurrentHashMap早期实现采用Segment分段锁机制
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
Segment<K,V>[] segments = (Segment<K,V>[]) new Segment[DEFAULT_CONCURRENCY_LEVEL];

// 内部维护一个Segment[]数组，每个Segment是一个继承了ReentrantLock的哈希桶
// 插入或访问某个键值对时，仅锁定其所在的Segment
// 并发性能远超Hashtable
```

**⚠️ 实现演进**
> 注意：JDK 1.8起不再使用Segment数组，而是使用CAS + synchronized + Node链表/红黑树优化

### 17.6 典型实现方式



**🏗️ 实现策略**
```
离散锁实现方式：
├── ☕ Java中常见用法：
│   └── Segment[] segments = new Segment[N]; 每段维护独立锁
├── 🧩 框架支持：
│   └── ConcurrentHashMap的分段锁机制（JDK8之前）
└── 🆕 现代实现替代方案：
    └── 使用CAS + Node分离设计替代传统分段锁（JDK8之后）
```

### 17.7 注意事项与限制



**⚠️ 常见缺点与注意事项**
```
离散锁使用要点：
├── 🚫 不适用场景限制：
│   └── ❌ 不适合资源量很小或写入极频繁的场景
│       └── 拆分段锁反而增加资源消耗和管理复杂度
├── 🔍 分段算法设计：
│   └── ❌ 需合理设计哈希/映射算法
│       └── 避免哈希碰撞集中，形成"热点段" → 降低并发度
├── 💀 多key操作风险：
│   └── ❌ 多个key操作涉及多个锁时，需统一加锁顺序
│       └── 否则可能引发死锁（如两个线程加锁顺序相反）
└── 🔧 管理与维护复杂度：
    └── ❌ 锁资源的生命周期、异常释放、内存管理更复杂
        └── 容易因unlock()遗漏等引发资源泄露或死锁
```

### 17.8 常见问题总结



| 问题 | **简要回答** |
|------|-------------|
| **什么是离散锁？** | `一种将锁粒度细化为多个独立段的锁机制` |
| **Java中哪里用到离散锁？** | `JDK 1.7的ConcurrentHashMap使用了Segment` |
| **离散锁的优点？** | `降低锁竞争，提高并发吞吐量` |
| **分段锁怎么实现？** | `使用ReentrantLock[]，根据key分配锁索引` |
| **如何防止死锁？** | `保证多锁获取时顺序一致` |

---

## 18. 📈 锁升级与锁降级



### 18.1 目录导航


- [锁升级](#锁升级)
- [锁降级](#锁降级)

---

# 锁升级



### 18.2 锁升级基本概念



**🔸 基本定义**
```
锁升级：
• 锁升级是指Java对象锁在运行时根据竞争情况由轻量级状态向重量级状态逐步演化的过程
• 目的：提高性能、降低开销，根据线程竞争的实际情况动态调整锁的实现方式
• 特点：自动进行，无需用户干预；不可逆，一旦升级无法降级
```

**🔄 锁状态演化顺序**
```
JVM中的对象锁生命周期：
无锁（No Lock）
  ↓
偏向锁（Biased Lock）
  ↓
轻量级锁（Lightweight Lock）
  ↓
重量级锁（Heavyweight Lock）
```

### 18.3 锁状态详解



**📊 锁状态特性对比**

| 锁状态 | **特点** | **适用场景** |
|--------|----------|-------------|
| 🔓 **无锁** | `对象未被加锁` | `线程未访问共享资源` |
| 🎯 **偏向锁** | `偏向某一线程，下一次无竞争快速执行` | `单线程反复加锁场景` |
| ⚡ **轻量级锁** | `使用CAS自旋获取锁，不阻塞线程` | `少量线程低冲突` |
| 🔒 **重量级锁** | `使用Monitor机制，线程会阻塞` | `多线程竞争严重` |

### 18.4 锁升级触发条件与过程



**🔄 升级机制详解**
```
锁升级触发条件与过程（JVM内部机制）：
├── 1️⃣ 偏向锁 ➡ 轻量级锁：
│   ├── 🎯 触发条件：
│   │   └── 有其他线程尝试获取已偏向的锁对象（非偏向线程参与竞争）
│   ├── ⚙️ 升级过程：
│   │   ├── JVM撤销对象的偏向状态
│   │   ├── 清除Mark Word中的偏向线程ID
│   │   └── 将锁状态切换为轻量级锁（CAS + 自旋方式尝试加锁）
│   └── 🎯 特点：
│       └── 尽量避免线程阻塞，提高单线程无争抢场景性能
├── 2️⃣ 轻量级锁 ➡ 重量级锁：
│   ├── 🎯 触发条件：
│   │   ├── 多个线程同时竞争锁对象，CAS多次失败
│   │   └── 自旋等待超过阈值（避免CPU长时间空转）
│   ├── ⚙️ 升级过程：
│   │   ├── JVM将锁标志升级为重量级
│   │   ├── 将锁对象关联到Monitor（操作系统级别）
│   │   └── 未获取到锁的线程进入Monitor的等待队列，挂起等待唤醒
│   └── 🎯 特点：
│       └── 存在线程挂起/唤醒机制，性能最差但保证互斥
└── 3️⃣ 小结：锁的升级路径（低开销 ➜ 高保障）：
    ├── 偏向锁：无竞争，线程ID绑定（性能最佳）
    ├── ➡ 轻量级锁：自旋竞争（低延迟，适中开销）
    └── ➡ 重量级锁：阻塞挂起（高开销，高互斥）
```

### 18.5 JVM锁优化机制



**🏗️ 完整的JVM锁优化体系**
```
JVM层次锁演化与优化：
├── 🎯 偏向锁（Biased Lock）：
│   ├── 目的：消除无竞争情况下的同步原语
│   ├── 原理：首次获取锁时将线程ID写入对象头（Mark Word）
│   ├── 场景：只有一个线程反复进入同步块
│   ├── 获取流程：判断Mark Word中的线程ID是否等于当前线程
│   ├── 撤销条件：其他线程尝试获取锁时触发撤销并升级
│   └── JVM参数：-XX:+UseBiasedLocking（默认开启）
├── ⚡ 轻量级锁（Lightweight Lock）：
│   ├── 目的：避免重量级锁带来的系统调用开销
│   ├── 原理：线程在栈中创建Lock Record，通过CAS替换对象头中的Mark Word
│   ├── 场景：多个线程交替进入同步块，低冲突情况
│   ├── 获取流程：使用CAS将Lock Record与对象头进行交换
│   ├── 释放流程：通过CAS恢复Mark Word到原状态
│   └── 升级条件：CAS失败或自旋失败时进入重量级锁
├── 🔒 重量级锁（Heavyweight Lock）：
│   ├── 原理：操作系统级别的互斥量（Monitor）
│   ├── 场景：高并发竞争，线程长时间持有锁
│   ├── 获取流程：未获取锁的线程阻塞挂起，等待唤醒
│   └── Monitor结构：_owner、_WaitSet（等待队列）、_EntryList（竞争队列）等
├── 🌀 自旋锁与自适应自旋：
│   ├── 目的：避免线程阻塞，减少上下文切换开销
│   ├── 原理：在短时间内反复尝试获取锁，不立即挂起线程
│   ├── 自适应机制：根据之前锁持有时间动态决定是否自旋及时长
│   └── JVM参数：-XX:+UseSpinning（启用自旋锁）
└── 🔧 锁粗化与锁消除：
    ├── 锁粗化（Lock Coarsening）：
    │   ├── 场景：多次连续的小粒度加锁/解锁操作
    │   └── 优化：将多个锁操作合并为一个大块锁
    ├── 锁消除（Lock Elimination）：
    │   ├── 场景：对象未逃逸，仅限线程内访问
    │   └── 优化：JIT编译阶段判断锁对象无竞争风险，直接移除加锁
    └── JVM参数：-XX:+EliminateLocks（默认开启锁消除）
```

### 18.6 锁升级相关JVM参数



| 参数 | **说明** |
|------|----------|
| `-XX:+UseBiasedLocking` | `开启偏向锁（默认开启）` |
| `-XX:-UseBiasedLocking` | `禁用偏向锁（跳过偏向直接轻量级锁）` |
| `-XX:BiasedLockingStartupDelay=0` | `启动时立即启用偏向锁` |

### 18.7 锁升级机制总结



**📋 关键要点**
```
锁升级机制总结：
├── 1️⃣ 什么是锁升级？
│   ├── 指JVM为提升多线程安全与响应效率
│   └── 根据线程竞争情况自动将锁逐步升级为更强的同步状态
├── 2️⃣ 锁升级路径（JVM自动进行）：
│   ├── 无锁（No Lock）
│   ├── 偏向锁（Biased Lock）
│   ├── 轻量级锁（Lightweight Lock）
│   └── 重量级锁（Heavyweight Lock）
├── 3️⃣ 锁升级触发条件：
│   ├── 偏向锁 ➝ 轻量级锁：有其他线程竞争，偏向失效
│   └── 轻量级锁 ➝ 重量级锁：多线程CAS自旋失败或自旋超过系统设置的上限阈值
├── 4️⃣ 锁升级特性总结：
│   ├── ✅ 自动进行，无需用户干预
│   ├── ✅ 根据冲突强度动态判断
│   └── ❌ 不可逆！升级一旦发生（如到重量级锁），JVM不会再将其降级
└── 5️⃣ 实战建议：
    ├── JVM锁升级对性能有正向优化，但一旦升级，锁代价上升
    ├── 应尽量避免频繁竞争导致进入重量级锁状态
    └── 可通过合理对象隔离、锁粒度控制、并发设计避免不必要的升级
```

---

# 锁降级



### 18.8 锁降级基本概念



**🔸 基本定义**
```
锁降级：
• 将一个强级别的锁主动转换为弱级别的锁
• 实现方式：在持有写锁（独占锁）的同时，获取读锁（共享锁），然后释放写锁的过程
• 目的：在修改完共享资源后，继续以读锁的方式监控或操作资源，避免写锁释放后出现数据不一致或竞争问题
• 控制方式：应用层手动控制（非JVM自动行为）
```

**🔍 对比锁升级**
```
锁升级 vs 锁降级：
├── 🔼 锁升级：
│   ├── 被动进行，自动触发，不可逆
│   └── JVM内部机制，基于竞争情况自动调整
└── 🔽 锁降级：
    ├── 主动进行，可控编程操作
    └── 应用层手动控制，需要程序员编程实现
```

### 18.9 为什么需要锁降级



**🎯 锁降级的价值**
```
锁降级的必要性：
├── ✅ 提高并发性能：释放独占写锁后，多个读线程可并发访问
├── ✅ 减少锁竞争：降低阻塞等待和上下文切换成本
├── ✅ 避免写饥饿：写线程先完成写操作再变为只读监控
└── ✅ 适应业务流程：如缓存更新后仍需监控其状态变化（读）
```

### 18.10 锁降级适用场景



| 场景 | **描述** |
|------|----------|
| 🗂️ **缓存预热** | `线程获取写锁进行缓存更新，完成后持有读锁，防止其他线程修改` |
| 🔍 **双重检测** | `第一次检查为null时获取写锁构建对象，然后降级为读锁` |
| ⚙️ **配置动态更新** | `写线程更新配置，更新后以读锁保持对配置状态的只读访问` |

### 18.11 实现锁降级的工具类



**🔧 ReentrantReadWriteLock**
```java
// 位于包：java.util.concurrent.locks
// 提供可重入的读锁与写锁控制
// 支持读写锁嵌套（写锁可获取读锁，但读锁不能升级为写锁！）
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock readLock = rwLock.readLock();
Lock writeLock = rwLock.writeLock();
```

### 18.12 锁降级的正确步骤



**📋 关键操作顺序**
```
锁降级正确步骤（顺序非常关键）：
1️⃣ 线程先持有写锁
2️⃣ 在释放写锁之前，先获取读锁
3️⃣ 获取读锁成功后再释放写锁
```

**💻 示例代码**
```java
// 锁降级示例
ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
Lock readLock = lock.readLock();
Lock writeLock = lock.writeLock();

writeLock.lock();
try {
    // 写操作：更新缓存或配置
    readLock.lock(); // 先获取读锁
} finally {
    writeLock.unlock(); // 再释放写锁
}

try {
    // 继续以只读方式访问资源
} finally {
    readLock.unlock();
}
```

### 18.13 锁降级与锁升级对比



| 项目 | **锁升级（× 不支持）** | **锁降级（✓ 支持）** |
|------|---------------------|------------------|
| 🔄 **定义** | `读锁 → 写锁` | `写锁 → 读锁` |
| 🚫 **线程是否阻塞** | `是，读锁不能升级为写锁` | `否，可重入获取` |
| ✅ **是否支持** | `❌ 不允许` | `✅ 支持` |
| ⚠️ **风险** | `死锁` | `无明显风险` |
| 🎯 **用途** | `理论上存在但不推荐` | `实际常用于缓存等场景` |

### 18.14 典型使用场景示例



**💾 缓存初始化优化**
```java
Object getCache(String key) {
    readLock.lock();
    try {
        if (cache.get(key) != null) {
            return cache.get(key);
        }
    } finally {
        readLock.unlock();
    }

    writeLock.lock();
    try {
        if (cache.get(key) == null) {
            cache.put(key, loadFromDb(key)); // 初始化缓存
        }
        readLock.lock(); // 降级为读锁
    } finally {
        writeLock.unlock();
    }

    try {
        return cache.get(key); // 只读访问
    } finally {
        readLock.unlock();
    }
}
```

### 18.15 注意事项与陷阱



| 注意点 | **描述** |
|--------|----------|
| ❌ **不支持读锁升级为写锁** | `若读锁中尝试写锁会死锁（除非释放所有读锁）` |
| ✅ **必须先获取读锁再释放写锁** | `否则会有空档期，其他线程可能抢先写入` |
| ✅ **锁降级是手动行为** | `并非JVM自动完成，需开发者控制锁顺序` |
| ✅ **适合读多写少场景** | `配合缓存、配置管理效果最佳` |

**⚠️ 死锁风险示例**
```java
// 读锁不能升级为写锁举例
Thread A 获取读锁
Thread B 获取读锁
Thread A 尝试升级到写锁 (必须等待所有读锁释放，包括 Thread B 的读锁)
Thread B 尝试升级到写锁 (必须等待所有读锁释放，包括 Thread A 的读锁)

// 结果：A 等 B 释放读锁，B 等 A 释放读锁 —— 典型的死锁情况
```

### 18.16 常见问题总结



| 问题 | **简要答案** |
|------|-------------|
| **什么是锁降级？** | `在持有写锁的同时获取读锁，然后释放写锁的过程` |
| **Java中如何实现锁降级？** | `使用ReentrantReadWriteLock，先持写锁 → 获取读锁 → 释放写锁` |
| **为什么不能锁升级？** | `因为读锁是共享的，其他线程可能也在读，升级为写锁会造成死锁` |
| **锁降级的典型场景？** | `缓存更新、双检锁、配置刷新` |
| **锁降级是否自动完成？** | `否，必须手动控制加锁和释放顺序` |


---

## 19. 🌐 分布式锁



### 19.1 核心概念



**🔸 基本定义**
```
分布式锁（Distributed Lock）：
• 在分布式系统中控制多个进程/节点对共享资源访问的互斥机制
• 目标：确保多服务、多实例环境下，同一时刻只有一个客户端能持有锁
• 与本地锁的区别：
  ├── 本地锁（如synchronized、ReentrantLock）仅在单JVM内有效
  └── 分布式锁跨进程、跨主机，需依赖外部组件（如Redis、ZooKeeper）
```

### 19.2 核心特性



**🌟 分布式锁必备特性**
```
分布式锁核心特性：
├── 🔐 互斥性：保证同一时间只有一个客户端持有锁
├── 🔄 可重入性：同一个客户端可多次获取同一把锁
├── ⏰ 锁超时/自动释放：防止持锁客户端崩溃导致锁永远不释放（死锁）
├── 🛡️ 高可用性：锁服务应具备容错、主备切换能力，避免单点故障
└── ⚡ 高性能：加锁、解锁操作应具备低延迟、支持高并发
```

**📊 特性对比表**

| 特性 | **说明** |
|------|----------|
| 🔒 **互斥性** | `同一时间，只有一个客户端能获得锁` |
| 🔄 **可重入性** | `同一个客户端可以重复加锁不死锁（可选）` |
| 🛡️ **高可用性** | `系统异常时自动恢复锁控制能力` |
| ⏰ **防死锁机制** | `设置过期时间，避免锁无限持有` |
| ⚖️ **公平性（可选）** | `请求顺序决定锁顺序，例如ZooKeeper` |

### 19.3 典型使用场景



**🎯 应用场景分析**
```
分布式锁典型使用场景：
├── 📊 分布式数据一致性控制：
│   └── 避免多个服务同时修改同一份数据
├── 🕐 分布式任务调度互斥执行：
│   └── 保证一个任务在任一时刻只被一个节点调度
├── ⚡ 秒杀/限流控制：
│   └── 控制并发下的库存扣减、请求处理顺序
└── 🔄 分布式事务协调：
    └── 保证多节点参与的一致性事务按顺序执行
```

### 19.4 常用实现方式



#### 🔧 1. 基于Redis（高性能，易实现）



**⚙️ 实现机制**
```java
// Redis分布式锁基本实现
✅ 实现方式：
SET key value NX EX 30：原子加锁命令（NX：不存在才设，EX：设置过期时间）
释放锁时校验value，防止误删别人的锁

✅ 工具类/中间件：
Redisson：功能全面的Redis客户端，提供可重入锁、公平锁、读写锁等
Spring Data Redis + Lua脚本实现分布式锁

✅ 样例代码：
RLock lock = redissonClient.getLock("myLock");
lock.lock();  // 阻塞获取锁
try {
    // 临界区代码
} finally {
    lock.unlock();
}
```

#### 🔧 2. 基于ZooKeeper（强一致性，有序节点）



**⚙️ 实现原理**
```
ZooKeeper分布式锁机制：
├── 🔍 实现原理：
│   ├── 创建临时顺序节点/lock/lock-00001
│   ├── 所有客户端监听前一个节点是否删除（watcher机制）
│   └── 最小编号节点获得锁
├── 🌟 特点：
│   ├── 拥有天然顺序、公平性
│   ├── 节点宕机锁自动释放（临时节点）
│   └── 实现复杂度高，性能不如Redis
```

#### 🔧 3. 基于数据库（MySQL）



**⚙️ 实现方式**
```
数据库分布式锁：
├── 💾 实现方式：
│   ├── 利用唯一索引插入一行数据：加锁
│   ├── 删除该行数据：解锁
│   └── 或使用SELECT FOR UPDATE行级锁
├── 📊 优缺点：
│   ├── 实现简单，容易理解
│   ├── 性能差，不推荐高并发使用
│   └── 依赖数据库可用性
```

### 19.5 实现方案对比



| 实现方案 | **一致性** | **性能** | **实现复杂度** | **适用场景** |
|----------|------------|----------|---------------|-------------|
| 🔴 **Redis** | `中等（需Lua）` | `✅✅✅` | `简单` | `高性能、低延迟` |
| 🟢 **Redisson** | `✅（封装好）` | `✅✅` | `简单` | `Java中推荐` |
| 🟡 **ZooKeeper** | `✅✅✅` | `中等` | `中等` | `公平性强、一致性要求高` |
| 🔵 **MySQL** | `❌` | `❌` | `简单` | `测试/临时使用，不推荐` |

### 19.6 Redis分布式锁详细实现



**💻 基础实现示例**
```java
// 简单Redis分布式锁实现
public class RedisDistributedLock {
    private final Jedis jedis;
    private final String lockKey;
    private final String lockValue;
    private final int expireTime;
    
    public boolean tryLock() {
        String result = jedis.set(lockKey, lockValue, "NX", "EX", expireTime);
        return "OK".equals(result);
    }
    
    public void unlock() {
        // 使用Lua脚本确保原子性：只有持有锁的客户端才能释放
        String luaScript = 
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";
        jedis.eval(luaScript, Collections.singletonList(lockKey), 
                  Collections.singletonList(lockValue));
    }
}
```

**⚠️ Redis分布式锁注意事项**
```
Redis分布式锁要点：
├── 🔍 防止误删：使用UUID作为value，解锁时校验
├── ⏰ 设置过期时间：防止客户端崩溃导致死锁
├── 📝 原子操作：使用Lua脚本保证加锁和解锁的原子性
├── 🔄 可重入支持：Redisson等客户端提供可重入实现
└── 🌐 集群模式：考虑RedLock算法或Redis Cluster的一致性
```

### 19.7 ZooKeeper分布式锁实现



**🔧 实现流程**
```
ZooKeeper分布式锁实现步骤：
├── 1️⃣ 创建锁节点：
│   └── 在/locks路径下创建临时顺序节点，如/locks/lock-0000001
├── 2️⃣ 判断是否获得锁：
│   ├── 获取/locks下所有子节点
│   ├── 判断自己的节点是否是序号最小的
│   └── 是最小 → 获得锁；否则 → 监听前一个节点
├── 3️⃣ 监听机制：
│   ├── 监听比自己序号小的最大节点
│   └── 该节点删除时，重新判断是否能获得锁
├── 4️⃣ 释放锁：
│   └── 删除自己创建的临时节点
└── 5️⃣ 异常处理：
    └── 客户端断开连接时，临时节点自动删除
```

### 19.8 分布式锁常见问题



**❌ 常见问题与解决方案**
```
分布式锁常见问题：
├── 🔒 锁超时问题：
│   ├── 问题：业务执行时间超过锁过期时间
│   ├── 影响：锁自动释放，可能导致并发问题
│   └── 解决：使用看门狗机制自动续期（如Redisson）
├── 💀 误删锁问题：
│   ├── 问题：A持有的锁过期，B获得锁，A执行完删除了B的锁
│   ├── 影响：破坏互斥性
│   └── 解决：删除前校验锁的持有者标识
├── 🔄 不可重入问题：
│   ├── 问题：同一线程多次获取锁失败
│   ├── 影响：导致死锁
│   └── 解决：实现可重入机制，记录持有次数
└── 🌐 集群脑裂问题：
    ├── 问题：Redis主从切换时可能同时存在多个锁持有者
    ├── 影响：破坏互斥性
    └── 解决：使用RedLock算法或等待主从同步完成
```

### 19.9 RedLock算法



**🔐 RedLock简介**
```
RedLock算法：
├── 🎯 目的：在Redis集群环境下提供更强的一致性保证
├── 📊 基本思想：
│   ├── 向多个独立的Redis实例申请锁
│   ├── 只有在大多数实例成功获得锁时才认为加锁成功
│   └── 释放锁时向所有实例发送释放请求
├── ⚙️ 实现要点：
│   ├── 至少需要3个Redis实例
│   ├── 超过半数实例成功才算成功
│   ├── 考虑时钟偏移和网络延迟
│   └── 设置合理的超时时间
└── 🔧 适用场景：
    └── 对一致性要求极高的分布式系统
```

### 19.10 最佳实践建议



**💡 分布式锁使用建议**
```
分布式锁最佳实践：
├── 🎯 选择合适的实现：
│   ├── 高性能场景：优选Redis + Redisson
│   ├── 强一致性场景：考虑ZooKeeper
│   └── 简单场景：数据库锁（谨慎使用）
├── ⚡ 性能优化：
│   ├── 设置合理的锁过期时间
│   ├── 尽量缩短临界区执行时间
│   ├── 使用异步释放锁机制
│   └── 考虑锁的粒度设计
├── 🛡️ 可靠性保障：
│   ├── 实现重试机制和降级策略
│   ├── 监控锁的使用情况和性能指标
│   ├── 建立锁泄漏检测和清理机制
│   └── 测试各种异常场景
└── 📊 监控与运维：
    ├── 监控锁的获取成功率和耗时
    ├── 设置锁超时和异常告警
    ├── 定期清理僵尸锁
    └── 建立锁使用的最佳实践文档
```

### 19.11 常见问题总结



| 问题 | **简要答案** |
|------|-------------|
| **什么是分布式锁？** | `在分布式系统中控制并发访问共享资源的互斥机制` |
| **如何实现Redis分布式锁？** | `使用SET key value NX EX加锁 + Lua脚本解锁` |
| **如何防止Redis锁误删？** | `设置UUID作为value，解锁时校验` |
| **ZooKeeper实现分布式锁原理？** | `临时顺序节点 + 监听前驱节点` |
| **RedLock是什么？** | `Redis官方提出的跨实例一致性加锁算法` |

---





## 20. 🔧 锁的相关问题



### 📚 本节目录


- [锁粒度](#锁粒度)
- [尝试锁](#尝试锁)
- [锁超时](#锁超时)
- [锁中断](#锁中断)
- [锁膨胀](#锁膨胀)
- [锁定等待](#锁定等待)
- [锁竞争](#锁竞争)
- [饥饿](#饥饿)
- [可中断锁](#可中断锁)
- [优先级反转](#优先级反转)
- [锁优化](#锁优化)




---

# 锁粒度



### 🔸 核心概念



**💡 基本定义**
```
锁粒度（Lock Granularity）：
• 指锁定资源的范围大小，也称为加锁操作的"精细程度"
• 是并发性能与安全性之间的取舍权衡手段
• 影响系统的并发能力和复杂度
```

**⚖️ 粒度分类**
```
锁粒度划分：
├── 🔒 粗粒度锁（Coarse-grained Lock）
│   ├── 锁定范围大：整个对象、方法或类
│   ├── 优点：实现简单，死锁风险较低
│   └── 缺点：并发能力弱，容易导致性能瓶颈
└── 🔧 细粒度锁（Fine-grained Lock）
    ├── 锁定范围小：某字段、代码段或资源片段
    ├── 优点：并发能力强，资源争抢少，吞吐量高
    └── 缺点：实现复杂，锁管理难，死锁概率较高
```

### 🎯 影响因素分析



| 影响因素 | **考虑要点** | **选择建议** |
|----------|-------------|-------------|
| 📊 **资源访问频率** | `高频访问资源更适合细粒度锁` | `频繁访问 → 细粒度优化` |
| ⏱️ **资源访问持续时间** | `操作耗时长需考虑锁粒度价值` | `耗时长 → 评估细化收益` |
| 🏁 **线程竞争程度** | `高竞争场景更应细化锁控制` | `高竞争 → 细粒度分散冲突` |
| 💻 **系统资源承载能力** | `CPU/内存负载影响锁方案适配` | `资源充足 → 支持复杂锁策略` |
| 🧩 **可接受的代码复杂性** | `是否能容忍细粒度带来的复杂度` | `复杂度可控 → 优化空间大` |

### 📊 锁粒度分类与示例



| 粒度类型 | **示例代码** | **说明** |
|----------|-------------|----------|
| 🔒 **粗粒度锁** | `synchronized(this)` | `锁住整个对象` |
| ⚖️ **中等粒度锁** | `synchronized(list)` | `锁定某个成员变量` |
| 🔧 **细粒度锁** | `synchronized(block)` | `仅锁住部分关键语句块` |
| 🧩 **分段锁** | `多个ReentrantLock[] + 哈希映射` | `离散锁实现` |

### 🏗️ 按数据结构划分



| 锁类型 | **粒度** | **场景** |
|--------|----------|----------|
| 📦 **Hashtable** | `粗粒度（整表锁）` | `全部操作加锁` |
| 🔄 **Collections.synchronizedMap** | `中粒度` | `方法级同步` |
| 🧩 **ConcurrentHashMap (JDK 1.7)** | `分段锁粒度` | `Segment锁控制` |
| ⚡ **ConcurrentHashMap (JDK 1.8)** | `链表/红黑树级别` | `Node锁定节点或桶` |

### 💻 Java中典型锁粒度控制场景



```java
// 1. synchronized 粒度控制
// 粗粒度
public synchronized void updateAll() { 
    // 锁住整个方法
}

// 细粒度
public void updatePartial() {
    synchronized (partialList) {
        // 仅锁定关键资源
    }
}

// 2. ReentrantLock 粒度控制
Lock lock = new ReentrantLock();

// 细粒度显式控制
if (conditionA) {
    lock.lock();
    try {
        // only lock here
    } finally {
        lock.unlock();
    }
}

// 3. 分段锁（离散锁）控制粒度
int index = hash(key) % segmentCount;
locks[index].lock();
// 仅锁定该段资源
```

### ⚖️ 权衡原则



| 粗粒度锁（大锁） | **细粒度锁（小锁）** |
|-----------------|-------------------|
| `编码简单，维护方便` | `编码复杂，易出错` |
| `冲突大，吞吐量低` | `冲突小，并发能力强` |
| `死锁可能性小` | `死锁可能性高（多个细锁嵌套）` |
| `整体一致性强` | `需要注意原子性和完整性保障` |

### 🎯 实际开发建议



**📋 优化策略**
```
锁粒度优化原则：
├── 1️⃣ 优先考虑粗粒度锁：确保正确性和可维护性
├── 2️⃣ 性能瓶颈时细化：在性能瓶颈明显时逐步优化为细粒度锁
├── 3️⃣ 工具验证效果：配合可视化锁分析、线程分析器验证调整效果
└── 4️⃣ 规范降低风险：引入锁顺序规范与锁分层设计，降低死锁风险
```

---

# 尝试锁



### 🔸 核心概念



**💡 基本定义**
```
尝试锁（Try Lock）：
• 一种非阻塞的加锁方式，线程尝试获取锁，如果锁已被占用则立即返回失败
• 接口：java.util.concurrent.locks.Lock.tryLock()
• 核心特性：非阻塞性、响应性好、可选超时时间版本
```

### ⚡ 与传统锁的区别



```
传统锁 vs 尝试锁对比：
├── 🔒 传统锁（synchronized 或 lock.lock()）
│   └── 获取失败会阻塞线程，等待锁释放
└── ⚡ 尝试锁（tryLock()）
    └── 获取失败立即返回false，不阻塞线程
```

### 🚀 尝试锁的优势



| 优势 | **描述** |
|------|----------|
| 🚫 **避免长时间阻塞** | `提高线程利用率，避免线程长期等待` |
| 🔓 **预防死锁** | `可结合锁顺序、限时重试策略避免死锁` |
| 🎯 **灵活控制** | `实现灵活的并发控制逻辑（如锁竞争失败直接跳过）` |
| ⚡ **提升响应性** | `适用于高并发快速失败场景` |

### 🔧 相关接口与方法



```java
// 所属接口
public interface Lock {
    // 立即尝试获取锁，成功返回true，失败返回false
    boolean tryLock();
    // 尝试在指定时间内获取锁，期间可被中断
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
}

// 1. 无参tryLock（非阻塞）
ReentrantLock lock = new ReentrantLock();
if (lock.tryLock()) {
    try {
        // 加锁成功，执行临界区
    } finally {
        lock.unlock();
    }
} else {
    // 获取锁失败，执行降级逻辑
}

// 2. 有参tryLock（限时等待）
if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {
    try {
        // 成功获取锁
    } finally {
        lock.unlock();
    }
} else {
    // 超时未获取锁
}
```

### 🔒 死锁避免示例



```java
// 如何使用tryLock避免死锁（双锁示例）
boolean gotLockA = false;
boolean gotLockB = false;

try {
    gotLockA = lockA.tryLock();
    gotLockB = lockB.tryLock();

    if (gotLockA && gotLockB) {
        // 成功获取两把锁，执行操作
    } else {
        // 获取失败，避免死锁
    }
} finally {
    if (gotLockA) lockA.unlock();
    if (gotLockB) lockB.unlock();
}
```

### ⚠️ 局限性分析



```
尝试锁的限制：
├── 🔧 需要手动处理失败逻辑：如分支判断、回退机制
├── 🔄 可能需要重试机制：增加代码复杂度
├── 🚫 不适合必须获取锁的场景：关键业务流程
└── ⚠️ 使用不当风险：可能降低程序健壮性（忽略失败处理）
```

### 🎯 典型应用场景



| 场景 | **描述** |
|------|----------|
| ⚡ **高并发快速失败** | `fail-fast设计模式` |
| 🎮 **非核心流程控制** | `如缓存更新等可选操作` |
| 🔗 **多锁组合获取** | `预防死锁的锁顺序控制` |
| 🚀 **响应延迟敏感服务** | `系统核心服务对响应时间要求高` |

### 📊 与阻塞锁对比



| 对比项 | **tryLock()** | **lock()（阻塞锁）** |
|--------|---------------|---------------------|
| 🚫 **是否阻塞** | `❌ 不阻塞` | `✅ 会阻塞直到获取` |
| ⏰ **是否支持超时** | `✅ 有重载支持超时等待` | `❌ 不支持` |
| 💀 **死锁风险** | `低` | `高（如无获取顺序控制）` |
| 🧩 **实现复杂度** | `稍高` | `简单` |
| 🔄 **是否可中断** | `有参版本支持中断` | `lockInterruptibly()支持中断` |

---

# 锁超时



### 🔸 核心概念



**💡 基本定义**
```
锁超时：
• 指线程在获取锁资源时，在设定的时间内尝试获取锁
• 如果超时仍未成功，则放弃获取
• 避免线程无限期阻塞，提高系统可用性和稳定性
```

### 🕐 三种超时控制策略



```
Java中的超时控制策略：
├── 1️⃣ 阻塞式超时（Blocking Timeout）
│   ├── 定义：当前线程在指定时间内阻塞等待资源或事件
│   ├── 特点：简洁，适合不频繁轮询场景，节省CPU但有上下文切换开销
│   ├── 示例：Lock.tryLock(timeout, unit)、BlockingQueue.poll(timeout, unit)
│   └── 注意：超时前不可做其他操作，可响应中断
├── 2️⃣ 轮询式超时（Polling Timeout）
│   ├── 定义：当前线程周期性检查资源是否可用，直到超时或成功
│   ├── 特点：主动控制，CPU占用高，易实现超时逻辑
│   ├── 示例：while循环 + 条件判断 + sleep间隔轮询
│   └── 注意：粒度控制影响性能与响应性，不适合高精度等待
└── 3️⃣ 响应式超时（Reactive Timeout）
    ├── 定义：注册监听器/回调/信号响应，事件到达或超时后自动触发
    ├── 特点：非阻塞、无需主动轮询，适合响应式编程
    ├── 示例：CompletableFuture.orTimeout()、Netty、RxJava
    └── 注意：编码复杂度高，回调处理不当易造成资源泄露
```

### 📊 三种策略对比



| 特性 | **阻塞式超时** | **轮询式超时** | **响应式超时** |
|------|---------------|---------------|---------------|
| 🚫 **是否阻塞** | `是` | `否（配合sleep）` | `否` |
| 💻 **CPU占用** | `低` | `高` | `低` |
| 🔄 **可中断性** | `支持` | `可设计支持` | `通常支持` |
| 🧩 **编码复杂度** | `中` | `低` | `高` |
| 🎯 **典型场景** | `Lock/Queue等` | `自定义等待逻辑` | `异步任务、事件回调` |

### 🔧 支持锁超时的实现类



| 实现类 | **是否支持超时锁** | **说明** |
|--------|-------------------|----------|
| ✅ **ReentrantLock** | `✅` | `显式锁，支持可中断与超时` |
| ✅ **ReadWriteLock的WriteLock** | `✅` | `ReentrantReadWriteLock的写锁支持` |
| ✅ **StampedLock** | `✅` | `支持超时获取写锁、读锁` |
| ❌ **synchronized** | `❌` | `不支持超时（必须阻塞）` |

### 💻 使用方式示例



```java
ReentrantLock lock = new ReentrantLock();

try {
    if (lock.tryLock(2, TimeUnit.SECONDS)) {
        try {
            // 获取锁成功
        } finally {
            lock.unlock();
        }
    } else {
        // 超时未获取锁，执行其他逻辑
    }
} catch (InterruptedException e) {
    // 响应中断
}
// 适合任务超时控制、服务降级、避免死锁等场景
```

### ⚙️ 相关接口参数



| 参数 | **描述** |
|------|----------|
| `timeout` | `最长尝试等待时间` |
| `unit` | `时间单位（如TimeUnit.SECONDS）` |
| `返回值` | `true：获取成功，false：超时放弃` |

### 🎯 典型应用场景



| 场景 | **说明** |
|------|----------|
| 🚫 **避免死锁** | `多线程交叉加锁时，设置超时退出防止互等` |
| 📉 **高并发服务降级** | `若资源被占用，则快速失败或进入备用逻辑` |
| 🎮 **分布式任务控制** | `获取锁失败则不执行任务，防止重复执行` |
| ⏱️ **限时操作保护** | `读取或写入资源时控制响应时限，防止长时间卡死` |

--


# 锁中断



### 🔸 核心概念



**💡 基本定义**
```
锁中断（Lock Interruptibly）：
• 线程在等待锁时，允许被中断提前退出等待
• 核心作用：提升系统响应性，避免无限阻塞
• 支持情况：仅限于显式锁（Lock接口），synchronized不支持
```

### 🧵 线程中断基础



```
线程中断机制：
├── 🎯 中断机制：线程之间通信的一种机制
├── 🔧 三个核心方法：
│   ├── interrupt()：发出中断信号
│   ├── isInterrupted()：判断中断标志，不清除
│   └── Thread.interrupted()：判断中断标志，并清除
└── 🎭 与锁超时的区别：
    ├── 锁中断：主动响应外部中断信号
    ├── 锁超时：被动等待一段时间，未获锁则退出
    └── 共同点：都可避免长时间阻塞，提高健壮性
```

### 🔒 支持中断的锁实现



| 锁实现类 | **是否支持lockInterruptibly()** | **说明** |
|----------|-------------------------------|----------|
| ✅ **ReentrantLock** | `✅ 支持` | `显式锁，核心实现之一` |
| ✅ **ReentrantReadWriteLock的WriteLock/ReadLock** | `✅ 支持` | `支持中断加锁方式` |
| ❌ **synchronized** | `❌ 不支持` | `内置锁，不能被中断` |

### 💻 使用方式示例



```java
ReentrantLock lock = new ReentrantLock();

try {
    lock.lockInterruptibly(); // 阻塞但可中断
    try {
        // 执行临界区代码
    } finally {
        lock.unlock();
    }
} catch (InterruptedException e) {
    // 中断发生，响应退出
    System.out.println("获取锁被中断");
}
```

### 📊 与lock()的区别



| 方法 | **是否可中断** | **是否阻塞直到成功** |
|------|---------------|-------------------|
| `lock()` | `❌` | `✅` |
| `lockInterruptibly()` | `✅` | `✅` |
| `tryLock()` | `❌` | `❌` |
| `tryLock(timeout)` | `✅` | `✅，带时间限制` |

### ⚙️ 底层实现原理（AQS）



```
lockInterruptibly()实现机制：
├── 🔄 调用路径：lockInterruptibly() → AQS.acquireInterruptibly(int arg)
├── 1️⃣ 尝试获取锁（tryAcquire）
│   └── 成功则返回，失败则进入等待队列
├── 2️⃣ 加入AQS队列
│   └── 节点以可中断模式入队（Node.EXCLUSIVE）
├── 3️⃣ 循环等待获取锁
│   ├── 每次挂起前检查中断状态
│   └── 若线程被中断：移除节点 → 抛出InterruptedException
└── 4️⃣ 成功获取锁后返回
```

### 🎯 典型应用场景



| 场景 | **描述** |
|------|----------|
| 🚫 **防止死锁** | `两个线程相互等待可通过中断退出竞争` |
| 🎮 **响应式任务线程** | `任务在等待锁期间可被取消或打断` |
| 📉 **服务降级处理** | `在超时或用户取消时主动中断锁获取流程` |
| 🧵 **线程池中可控任务** | `线程池管理任务中断时，可以通过中断打断锁等待状态` |

### ⚠️ 注意事项与陷阱



| 注意点 | **描述** |
|--------|----------|
| ✅ **必须在try-finally中释放锁** | `防止中断后锁未释放，导致死锁` |
| ✅ **中断响应需调用lockInterruptibly()才能生效** | `lock()不会响应中断` |
| ❌ **不支持对synchronized代码块中断** | `内置锁不具备此能力` |
| ✅ **可配合Thread.interrupt()打断加锁线程** | `由外部控制线程中断` |

---

# 锁膨胀



### 🔸 核心概念



**💡 基本定义**
```
锁膨胀（Lock Inflation）：
• 当偏向锁或轻量级锁在多线程竞争下失效，自动升级为重量级锁的过程
• 本质：JVM为保证线程安全，在锁优化失败后的一种回退策略
• 膨胀结果：锁状态转为重量级，线程阻塞，交由操作系统调度
```

### 🔄 锁状态演化流程



```
JVM锁优化机制（HotSpot对象锁）：
无锁（No Lock）
    ↓
偏向锁（Biased Lock）
    ↓
轻量级锁（Lightweight Lock）
    ↓
重量级锁（重量锁/Monitor Lock） ← 【锁膨胀】

特性：
• 单向升级，不可降级
• 根据竞争情况自动转换
• 优化目标：在不同场景下获得最佳性能
```

### 📊 锁状态对比分析



| 锁状态 | **是否竞争** | **优化方向** | **效率** | **原子性** | **会否阻塞** |
|--------|-------------|-------------|----------|------------|-------------|
| 🎯 **偏向锁** | `无` | `单线程复用优化` | `高` | `否` | `否` |
| ⚡ **轻量级锁** | `无/轻微` | `多线程交替执行优化` | `高` | `是` | `否` |
| 🔒 **重量级锁** | `有` | `多线程竞争激烈` | `低` | `是` | `是` |

### 🚨 锁膨胀触发条件



| 触发场景 | **描述** |
|----------|----------|
| 🔄 **多个线程同时争抢同一对象锁** | `轻量级锁CAS自旋失败` |
| ⏰ **自旋超过指定次数或时间阈值** | `默认最多10次` |
| 🎯 **偏向锁被撤销升级** | `偏向锁撤销后直接进入轻量级或重量级` |
| 🏁 **使用synchronized在高并发场景中** | `JVM无法保证低成本同步` |

### ⚙️ 膨胀过程与机制



```
Java对象锁状态演化流程：
├── 🎯 初始状态：偏向锁
│   ├── 特点：对象偏向于第一个访问它的线程，加锁无需CAS
│   └── 当另一个线程尝试竞争该锁时：
├── 1️⃣ 偏向锁被撤销
│   ├── JVM会撤销对象的偏向标志
│   └── 检查当前线程能否继续优化获取锁
├── 2️⃣ 若CAS成功（无竞争）→ 升级为轻量级锁
│   ├── 使用Lock Record + CAS尝试获取锁
│   └── 自旋等待，不阻塞线程
└── 3️⃣ 若CAS自旋失败（高并发竞争）→ 锁膨胀
    ├── JVM将锁状态升级为重量级锁（Monitor）
    ├── 对象头中的Mark Word指向Monitor对象
    └── 线程阻塞，进入等待队列，等待唤醒获取锁
```

### 📉 膨胀后对性能的影响



| 影响 | **描述** |
|------|----------|
| 💻 **CPU开销增加** | `线程阻塞/唤醒涉及操作系统上下文切换` |
| 📊 **吞吐量下降** | `锁膨胀导致线程等待时间变长` |
| 👁️ **可见性更差** | `阻塞线程的数据可能无法及时同步到主存` |
| 🔍 **调试复杂度提升** | `分析竞争瓶颈更困难` |

### ⚙️ JVM参数调优



| 参数 | **作用** |
|------|----------|
| `-XX:+UseBiasedLocking` | `启用偏向锁（默认开启）` |
| `-XX:-UseBiasedLocking` | `关闭偏向锁，直接轻量级锁` |
| `-XX:BiasedLockingStartupDelay=0` | `启动即启用偏向锁` |
| `-XX:+PrintGCApplicationStoppedTime` | `观察STW时间是否与锁竞争相关` |

### 🛠️ 避免锁膨胀的优化建议



| 优化策略 | **说明** |
|----------|----------|
| 🎯 **避免大范围加锁** | `精细化锁粒度，减少共享锁冲突` |
| 🔀 **减少热点锁对象共享** | `对象隔离（如使用ThreadLocal）` |
| 🚀 **使用高性能并发类** | `如ConcurrentHashMap替代Hashtable` |
| ⚙️ **适当关闭偏向锁** | `避免不必要的偏向锁撤销开销` |
| ⚡ **使用CAS替代锁** | `对于计数器等简单共享资源使用AtomicXXX` |

---

# 锁定等待



### 🔸 核心概念



**💡 基本定义**
```
锁等待（Lock Waiting）：
• 线程尝试获取锁资源但未成功，进入等待的过程
• 又称：锁阻塞（Lock Blocking）、锁竞争（Lock Contention）
• 表现形式：线程状态BLOCKED（等待Monitor锁）
```

### 🎯 锁等待的目的



```
在多线程环境下有序地获取共享资源访问权，防止资源冲突
```

### 📊 锁等待的分类



| 类型 | **描述** |
|------|----------|
| 🔒 **阻塞式等待** | `使用synchronized/ReentrantLock，线程阻塞` |
| 🌀 **自旋等待** | `使用CAS+循环尝试，不挂起线程（如轻量级锁）` |
| 🎫 **信号量等待** | `使用Semaphore控制并发访问许可数` |
| 🔔 **条件等待** | `使用Condition.await()等待某条件触发后继续执行` |

### 🚨 锁等待的产生场景



| 场景 | **描述** |
|------|----------|
| 🔒 **synchronized同步代码块** | `多线程同时进入同步方法或块时产生竞争` |
| 🔧 **ReentrantLock** | `若线程使用lock()获取失败将进入等待` |
| ✏️ **写锁竞争（如ReadWriteLock）** | `一个线程持有写锁，其他读或写线程需等待` |
| ⚡ **CAS重试失败** | `虽非阻塞锁，但也体现为逻辑级别的"等待"` |
| 🔔 **synchronized + wait()** | `等待notify唤醒时也会进入锁池等待Monitor` |

### 📱 锁等待的表现形式



```
锁等待的多种表现：
├── 1️⃣ 线程运行状态表现
│   ├── BLOCKED：等待进入synchronized代码块或对象Monitor
│   ├── WAITING：等待被其他线程通过notify()/signal()唤醒
│   └── TIMED_WAITING：有时间限制的等待（如LockSupport.parkNanos()）
├── 2️⃣ jstack栈信息表现
│   ├── waiting to lock：当前线程正在尝试获取锁对象，但该对象被其他线程持有
│   ├── parking to wait for：当前线程调用LockSupport.park()/Condition.await()等挂起操作
│   └── waiting on <object>：调用Object.wait()后进入的状态
├── 3️⃣ 可视化工具中的表现
│   ├── jconsole/VisualVM/JFR：线程状态显示为BLOCKED、WAITING、TIMED_WAITING
│   ├── 线程面板中出现大量红色（阻塞）线程
│   └── 堆栈信息中反映竞争锁资源的线程数量
└── 4️⃣ Arthas工具中的表现
    ├── thread -b命令：列出所有处于阻塞状态的线程及其锁等待情况
    └── thread <id>命令：查看具体线程栈与锁占用信息
```

### 🔍 锁等待的检测方式



```
锁等待检测方法：
├── 1️⃣ 使用jstack（命令行工具）
│   ├── 查看线程栈状态：关键词waiting to lock/parking to wait for
│   ├── 检查锁依赖链（死锁排查）：若多个线程相互持有对方等待的锁，可能形成死锁
│   └── 示例命令：jstack <pid>
├── 2️⃣ 使用jconsole/VisualVM（图形化工具）
│   ├── 连接目标Java进程
│   ├── 打开"线程"面板，观察线程状态：状态为BLOCKED的线程表示正在等待锁
│   └── 支持线程历史追踪与堆栈查看
└── 3️⃣ 使用Arthas（动态诊断工具，推荐）
    ├── 命令：thread -b：显示当前被阻塞（Blocked）状态的线程
    ├── 优点：实时诊断，无需重启应用；可附加运行中的进程；支持线程ID、堆栈、锁持有者追踪
    └── 示例：thread -b | grep Lock
```

### 🛠️ 锁等待的优化手段



| 优化方法 | **说明** |
|----------|----------|
| 🎯 **减小锁粒度** | `降低锁定范围，只锁住必要的代码区域` |
| 🔀 **减少共享资源** | `拆分资源，减少多个线程争抢同一对象` |
| ⚡ **使用非阻塞锁** | `使用tryLock()或CAS替代传统阻塞锁` |
| 📖 **使用读写锁** | `读多写少场景可减少互斥冲突` |
| ⚖️ **避免线程饥饿** | `使用公平锁策略（如new ReentrantLock(true)）` |

### 💻 典型代码示例



```java
public class LockWaitDemo {
    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        Runnable task = () -> {
            synchronized (LOCK) {
                System.out.println(Thread.currentThread().getName() + " 获取锁");
                try {
                    Thread.sleep(5000); // 模拟长时间持有锁
                } catch (InterruptedException e) {}
            }
        };

        new Thread(task, "Thread-1").start();
        new Thread(task, "Thread-2").start(); // 会阻塞等待LOCK
    }
}
```



# 锁竞争



### 🔸 核心概念



**💡 基本定义**
```
锁竞争（Lock Contention）：
• 多个线程同时尝试获取同一把锁，只有一个线程可获得，其它线程需等待
• 本质：对临界区（Critical Section）的访问权争夺
• 常见场景：synchronized同步方法/代码块、ReentrantLock等显式锁
```

### 📊 竞争程度分类



```
锁竞争程度划分：
├── 🔓 无竞争：仅一个线程访问共享资源，无需等待
├── 🟡 轻度竞争：少量线程偶尔竞争，锁等待时间短
├── 🟠 中度竞争：多线程频繁访问临界区，偶尔阻塞
└── 🔴 激烈竞争：大量线程同时争锁，线程频繁阻塞/唤醒，自旋失败率高
```

### 💥 锁竞争对性能的影响



| 影响类型 | **描述** |
|----------|----------|
| 🔄 **上下文切换开销** | `阻塞/唤醒线程需要用户态与内核态切换` |
| 💾 **CPU缓存一致性问题** | `共享数据修改导致CPU缓存频繁失效（MESI协议成本）` |
| ⏰ **线程阻塞与调度延迟** | `线程不能及时执行，影响响应性` |
| 📉 **吞吐量下降** | `同步阻塞时间增加，单位时间完成任务减少` |

### 🎯 锁竞争的表现形式



| 表现方式 | **描述** |
|----------|----------|
| 🚫 **线程阻塞（BLOCKED）** | `某线程尝试获取锁但未成功，被阻塞等待` |
| 🔥 **CPU飙高** | `线程频繁自旋、CAS失败重试导致CPU利用率上升` |
| 📉 **吞吐量下降** | `线程等待造成资源无法充分利用` |
| 🐌 **响应变慢** | `用户请求受锁延迟拖累` |

### 🚨 产生竞争的典型场景



| 场景 | **描述** |
|------|----------|
| 🔒 **多线程并发访问同一synchronized方法或块** | `JVM Monitor互斥锁竞争` |
| 🔧 **多线程抢占ReentrantLock** | `AQS内部队列排队` |
| 📖 **读写不分离的大量读写操作** | `资源争抢加剧` |
| 🔥 **单个对象频繁共享（锁热点）** | `所有线程争抢同一个锁对象` |
| 💾 **高并发写缓存、操作集合等** | `锁操作成为瓶颈` |

### 🔍 锁竞争的监测方法



```
锁竞争监测工具：
├── 1️⃣ JDK自带工具
│   ├── jstack：查看线程状态（RUNNABLE、BLOCKED、WAITING）
│   │   └── 分析是否有waiting to lock/locked锁信息
│   ├── jcmd：jcmd <pid> Thread.print
│   │   └── 更全面的线程与锁依赖信息输出
│   └── JFR（Java Flight Recorder）
│       ├── 支持记录Lock Contentions、线程等待事件
│       └── 可用JMC（Java Mission Control）图形化分析
├── 2️⃣ 性能分析工具（可视化支持）
│   ├── JProfiler：支持线程锁争用可视化分析，热点方法+锁占用时间图
│   ├── YourKit：可视化锁图谱，展示阻塞线程与锁持有线程之间的依赖关系
│   └── Async-Profiler：低开销原生采样工具，支持输出锁竞争火焰图
├── 3️⃣ 操作系统级工具
│   ├── top：查看线程CPU占用、识别卡死或忙等异常线程
│   ├── vmstat：观察上下文切换（cs）、阻塞进程（b）等指标
│   └── mpstat：查看CPU利用率与中断情况，识别热点线程切换开销
└── 4️⃣ 实战建议
    ├── 多工具组合使用，结合线程状态+锁分析定位瓶颈
    ├── 可设定JVM参数：-XX:+PrintGCApplicationStoppedTime查看STW时间
    ├── 使用JFR长时间运行采样更易发现间歇性争用
    └── 关注synchronized热点和长时间持锁的线程
```

### 🛠️ 常见的锁竞争优化策略



| 策略 | **说明** |
|------|----------|
| 🎯 **减少锁范围** | `将锁粒度缩小，只锁定必要代码段` |
| 🔀 **拆分锁对象** | `拆分资源，避免多个线程竞争同一把锁` |
| 📦 **使用并发容器** | `使用ConcurrentHashMap、CopyOnWriteArrayList替代同步集合` |
| 📖 **使用读写锁分离** | `ReadWriteLock：读共享，写独占，读多写少场景优先` |
| ⚡ **乐观并发控制** | `使用CAS/原子类代替锁，如AtomicInteger` |
| 🧵 **控制线程数量** | `限制并发线程数，减少锁冲突概率` |

---

# 饥饿



### 🔸 核心概念



**💡 基本定义**
```
线程饥饿（Thread Starvation）：
• 一个或多个线程在竞争锁或资源时，线程因无法获得所需资源而无法进行工作的现象
• 本质：由于不公平的资源分配或线程调度机制，某些线程长期得不到执行
• 场景示例：锁竞争中永远获取不到锁、CPU线程池中优先级过低被排到后面
```

### 🆚 与相似概念的区别



| 概念 | **描述** | **是否阻塞** | **是否可进展** |
|------|----------|-------------|---------------|
| 💀 **死锁** | `多线程互相等待资源，永久卡住` | `是` | `否` |
| 🔄 **活锁** | `线程相互让步，程序在运行却无进展` | `否` | `否` |
| 😴 **饥饿** | `某线程长期得不到调度（被高优先级线程长期压制）` | `否` | `否` |

### 🚨 饥饿的常见原因



```
造成线程饥饿的原因：
├── 1️⃣ 不公平锁
│   ├── 如ReentrantLock默认是非公平模式
│   ├── 新来的线程可能插队获取锁
│   └── 等待队列中的线程可能一直被跳过，导致饥饿
├── 2️⃣ 线程优先级设置不合理
│   ├── 高优先级线程频繁占用CPU
│   ├── 低优先级线程得不到时间片
│   └── 在旧版本JVM或老旧操作系统中更为明显
├── 3️⃣ 死循环或耗时任务长期持有锁
│   ├── 某线程获取锁后进入死循环或执行非常耗时的操作
│   └── 导致其他线程长时间无法获取锁
├── 4️⃣ 线程池配置不合理
│   ├── 核心线程数过小
│   ├── 队列容量过大
│   └── 某些任务一直被排在队列末端，长时间不执行或永远排不上
└── 5️⃣ 资源分配饱和
    ├── 如数据库连接池、IO通道等资源被占满
    ├── 没有足够的可用资源供后续线程使用
    └── 其他线程长期阻塞等待资源释放
```

### 💥 饥饿的危害



| 危害 | **描述** |
|------|----------|
| ⏰ **响应延迟** | `关键线程（如事件处理线程）迟迟得不到执行` |
| 📉 **吞吐量下降** | `系统部分线程长时间空转或阻塞` |
| ⚖️ **系统不公平性** | `特定线程或任务被长期忽略，逻辑混乱或失败` |
| 🚫 **功能不可用** | `可导致功能不可用或错过时间窗口（如秒杀、异步响应）` |

### 🛡️ 如何防止线程饥饿



| 策略 | **描述** |
|------|----------|
| ⚖️ **使用公平锁** | `如new ReentrantLock(true)，保证排队顺序` |
| 🎯 **控制任务优先级** | `避免人为设置线程优先级导致不公` |
| ⏱️ **限制锁持有时间** | `减少长时间占锁逻辑，使用tryLock + timeout` |
| 🧵 **合理配置线程池** | `控制线程池核心线程数、队列大小、防止任务饿死` |
| ✂️ **拆分大任务** | `拆解为小块逻辑，避免单线程独占资源太久` |
| 🔔 **使用条件变量或通知机制** | `如Condition、notifyAll()减少不必要的等待` |

### 💻 典型代码示例



```java
import java.util.concurrent.locks.ReentrantLock;

public class StarvationDemo {
    static ReentrantLock lock = new ReentrantLock(); // 默认非公平锁

    public static void main(String[] args) {
        // 创建一个"霸占锁"的线程，频繁加锁释放
        new Thread(() -> {
            while (true) {
                lock.lock();
                try {
                    // 模拟短时间占用锁
                    Thread.sleep(50);
                } catch (InterruptedException e) {} 
                finally {
                    lock.unlock();
                }
            }
        }, "Aggressive-Thread").start();

        // 创建多个"饿死"的线程
        for (int i = 1; i <= 3; i++) {
            final int id = i;
            new Thread(() -> {
                while (true) {
                    lock.lock();
                    try {
                        System.out.println("Thread-" + id + " 获得锁");
                        break; // 成功获取锁后退出
                    } finally {
                        lock.unlock();
                    }
                }
            }, "Starved-Thread-" + id).start();
        }
    }
}

/* 说明：
Aggressive-Thread 不断获取和释放锁，占用CPU；
Starved-Thread-1/2/3 很难抢到锁，可能一直被饿着；
可通过设置 ReentrantLock(true) 改为公平锁以缓解饥饿。
*/
```

---

# 可中断锁



### 🔸 核心概念



**💡 基本定义**
```
可中断锁（Interruptible Lock）：
• 一种在锁竞争过程中可以被中断的锁机制
• 目的：提升系统响应性，防止资源争抢中线程"卡死"
• 应用意义：适合需要响应取消、限时执行或防死锁的场景
```

### 🆚 与不可中断锁的区别



```
可中断锁 vs 不可中断锁：
├── ✅ 可中断锁：
│   └── 响应Thread.interrupt()，抛出InterruptedException
├── ❌ 不可中断锁：
│   └── 忽略中断信号，一直阻塞直到获取锁或发生其他异常
└── 比较示例：
    ├── 可中断：lockInterruptibly()
    └── 不可中断：synchronized、lock()
```

### 🔧 Java中的实现



```
可中断锁实现：
├── 接口来源：java.util.concurrent.locks.Lock
├── 核心方法：void lockInterruptibly() throws InterruptedException
├── 常用实现类：
│   ├── ReentrantLock
│   └── ReentrantReadWriteLock的写锁/读锁
└── 使用注意：必须捕获InterruptedException，并妥善处理清理逻辑
```

### 💻 使用方式示例



```java
ReentrantLock lock = new ReentrantLock();

Thread t = new Thread(() -> {
    try {
        lock.lockInterruptibly(); // 可被中断的加锁方式
        try {
            // 临界区
        } finally {
            lock.unlock();
        }
    } catch (InterruptedException e) {
        System.out.println(Thread.currentThread().getName() + " 被中断，放弃获取锁");
    }
});

// 外部中断线程
t.start();
Thread.sleep(1000);
t.interrupt(); // 中断等待锁的线程
```

### 🎯 典型应用场景



| 场景 | **描述** |
|------|----------|
| 🚫 **死锁恢复** | `检测到死锁风险时，中断某个线程释放资源` |
| 🎮 **用户主动取消** | `线程等待锁时用户手动取消任务` |
| 🚀 **响应式服务** | `不等待锁太久，避免系统响应卡顿` |
| 📉 **异常恢复控制** | `获取锁失败直接跳出流程，进入降级处理逻辑` |

---

# 优先级反转



### 🔸 核心概念



**💡 基本定义**
```
优先级反转（Priority Inversion）：
• 指低优先级线程持有资源锁
• 高优先级线程等待该锁却被中优先级线程"间接阻塞"
• 结果是高优先级线程无法及时执行，优先级调度被"反转"
```

### 📊 优先级反转示例场景



```
初始条件：
• 线程L（低优先级）
• 线程M（中优先级）  
• 线程H（高优先级）
• 共享资源R被互斥锁保护

执行序列：
1. 线程L获取资源R的锁
2. 线程H变为可运行状态，抢占CPU（由于优先级高于L）
3. 线程H尝试获取资源R的锁，但被阻塞（因为锁被线程L持有）
4. 线程M变为可运行状态，抢占CPU（由于优先级高于L）
5. 线程M执行，而线程L无法继续执行释放锁
6. 线程H持续等待线程L释放锁，但线程L无法获得CPU

结果：高优先级线程H被低优先级线程L间接阻塞，同时中优先级线程M可以执行
```

### 🔄 优先级反转的分类



```
优先级反转类型：
├── 🔴 无界优先级反转（Unbounded）
│   └── 中优线程无限延迟低优线程释放锁，导致高优线程长时间无法执行
└── 🟡 有界优先级反转（Bounded）
    └── 中优线程干扰有限，最终高优线程可继续运行（但仍存在延迟）
```

### 🎯 出现场景



| 场景 | **描述** |
|------|----------|
| 🖥️ **实时系统** | `如操作系统内核、飞控、嵌入式` |
| ☕ **Java中使用线程优先级** | `Thread.setPriority()` |
| 🧵 **多线程资源竞争** | `多级优先级任务协作` |

### 💥 危害



| 危害 | **描述** |
|------|----------|
| ⏰ **系统响应延迟增加** | `高优先级任务被延迟执行` |
| 📉 **实时性、可预测性下降** | `系统调度不符合预期` |
| 🚨 **严重逻辑问题或安全隐患** | `关键高优先级任务被阻塞` |

### 🛠️ 解决方案



```
优先级反转解决方案：
├── 🔼 优先级继承协议（Priority Inheritance）
│   └── 低优线程临时提升为高优级别，避免阻塞高优线程
├── 🏠 优先级天花板协议（Priority Ceiling）
│   └── 锁关联最大优先级，防止中优线程插队
└── ⚖️ 在Java中使用公平锁
    └── ReentrantLock(true)可缓解部分场景
```

---

# 锁优化



### 🔸 核心概念



**💡 基本定义**
```
锁优化（Lock Optimization）：
• 通过优化锁的使用方式、范围、结构和底层机制
• 减少线程阻塞、锁竞争与上下文切换开销
• 本质目标：提升并发程序整体性能
```

### 🎯 优化目标



```
锁优化的四大目标：
├── 📈 提高系统吞吐量
├── ⏰ 降低响应延迟
├── 💻 提升CPU利用率
└── 🧵 增强线程并发度
```

### 🏗️ JVM内置的锁优化技术



```
JVM自动锁优化：
├── 1️⃣ 锁消除（Lock Elision）
│   ├── 定义：JIT编译期间通过逃逸分析判断锁是否必要
│   ├── 条件：对象未逃逸出当前线程，锁不会发生争用
│   └── 效果：移除无实际意义的同步操作，提升执行效率
├── 2️⃣ 锁粗化（Lock Coarsening）
│   ├── 定义：将多个临近的加锁/解锁操作合并为一个大锁
│   ├── 场景：例如循环内多次对同一对象加解锁
│   └── 目的：避免频繁的锁释放与申请带来的开销
├── 3️⃣ 偏向锁（Biased Locking）
│   ├── 定义：优化单线程反复加锁的场景，偏向第一个访问线程
│   ├── 特点：加锁过程无需CAS，效率极高
│   ├── 条件：无其他线程参与竞争
│   └── 状态：在竞争出现后撤销并升级为轻量级锁
├── 4️⃣ 轻量级锁（Lightweight Locking）
│   ├── 定义：使用CAS+自旋实现的用户态锁
│   ├── 特点：适合低并发情况下的快速同步，占用资源少，避免线程阻塞
│   └── 升级：若竞争激烈则升级为重量级锁（锁膨胀）
└── 5️⃣ 自适应自旋（Adaptive Spinning）
    ├── 定义：在获取不到锁时，线程不会立即阻塞，而是先短时间自旋等待
    ├── 特点：自旋次数根据历史运行状况动态调整
    ├── 优点：避免线程上下文切换带来的性能损耗
    └── 适用场景：锁预计在短时间内可被释放
```

### 🚀 锁优化的核心方向



| 类型 | **说明** |
|------|----------|
| 🏗️ **结构优化** | `减少锁竞争的根本方式（如锁粒度、分段锁）` |
| 🔄 **状态优化** | `JVM内部锁状态（偏向锁、轻量级锁、重量级锁）` |
| 📋 **策略优化** | `公平锁、非公平锁、自旋、重入机制等` |
| ⚡ **替代优化** | `用无锁、CAS、并发集合等替代传统锁` |

### 🛠️ 结构级锁优化



```java
// 1. 减小锁粒度（锁精细化）
// 仅锁定临界区最小代码
// 避免方法级synchronized，使用语句块代替
synchronized (lock) {
   // 仅锁定共享资源操作
}

// 2. 分段锁（Segment Lock）
// 将资源分段，每段一个独立锁，减少线程冲突
// 应用于ConcurrentHashMap(JDK 1.7)、分段缓存

// 3. 锁分离（读写锁）
// 使用ReadWriteLock区分读操作（共享）与写操作（独占）
// 适用于读多写少场景
ReadWriteLock rwLock = new ReentrantReadWriteLock();

rwLock.readLock().lock();
try {
    if (cacheHit()) return data;
} finally {
    rwLock.readLock().unlock();
}

rwLock.writeLock().lock();
try {
    // 更新缓存
} finally {
    rwLock.writeLock().unlock();
}
```

### 📊 替代机制优化



```java
// 1. 使用原子类（CAS）
// AtomicInteger, AtomicReference等支持无锁并发操作
AtomicInteger counter = new AtomicInteger();
counter.incrementAndGet(); // 避免传统锁开销

// 2. 使用并发集合
// ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue等

// 3. 使用线程隔离机制
// ThreadLocal保证线程私有数据，避免共享资源争抢
ThreadLocal<String> threadLocal = new ThreadLocal<>();
```

### ⚙️ 锁优化相关JVM参数



| 参数 | **作用** |
|------|----------|
| `-XX:+UseBiasedLocking` | `启用偏向锁（默认开启）` |
| `-XX:-UseBiasedLocking` | `关闭偏向锁` |
| `-XX:BiasedLockingStartupDelay=0` | `启动后立即启用偏向锁` |

### ⚠️ 注意事项与最佳实践



| 项目 | **建议** |
|------|----------|
| ✅ **锁操作必须finally中释放** | `防止死锁与锁泄露` |
| ❌ **避免锁范围过大** | `影响并发性能` |
| ✅ **避免锁嵌套** | `降低死锁概率` |
| ✅ **多线程共享对象需明确加锁** | `避免数据竞争和可见性问题` |

### 📋 锁选择决策指南



```
锁选择策略：
├── 📖 读多写少场景：
│   └── 优先选择ReadWriteLock
├── ⚡ 高性能要求：
│   ├── 无竞争/轻竞争 → CAS、原子类
│   └── 有竞争 → 非公平锁
├── 🛡️ 强一致性要求：
│   ├── 简单场景 → synchronized
│   └── 复杂场景 → ReentrantLock
├── 🎯 公平性要求：
│   └── ReentrantLock(true)
└── 🧩 高并发场景：
    ├── 可分段 → 分段锁策略
    └── 不可分段 → 减小锁粒度
```




