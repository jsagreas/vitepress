---
title: 6、线程通信
---
## 📚 目录

1. [线程通信概述](#1-线程通信概述)
2. [线程通信的典型场景](#2-线程通信的典型场景)
3. [线程通信的常用机制](#3-线程通信的常用机制)
4. [通信机制对比分析](#4-通信机制对比分析)
5. [经典通信模式实现](#5-经典通信模式实现)
6. [常见错误与注意事项](#6-常见错误与注意事项)
7. [扩展通信工具类](#7-扩展通信工具类)

---

## 1. 🔄 线程通信概述


### 1.1 基本概念


**🔸 线程通信定义**
```
线程通信：多个线程之间通过某种方式交换信息、协调执行顺序，以实现协同工作
核心目标：解决多线程"彼此不知对方状态"的问题
应用价值：使线程能有序协作，如生产者-消费者模型
```

**💡 为什么需要线程通信**
```
线程通信解决的问题
├── 🎯 执行顺序控制
│   └── 确保线程按特定顺序执行任务
├── 📊 状态信息共享  
│   └── 线程间传递数据和状态变化
├── 🔄 资源协调访问
│   └── 多线程安全访问共享资源
└── ⏰ 条件等待机制
    └── 线程等待特定条件满足后继续执行
```

### 1.2 线程通信的本质


```
通信机制的本质
┌─────────────────┐    通信    ┌─────────────────┐
│   线程 A        │ ────────→  │   线程 B        │
│ • 状态变化      │            │ • 感知变化      │
│ • 发送信号      │ ←──────    │ • 响应处理      │
│ • 等待条件      │    反馈    │ • 更新状态      │
└─────────────────┘            └─────────────────┘
```

---

## 2. 🎭 线程通信的典型场景


### 2.1 三大典型场景


**🔗 顺序执行场景**
```
场景描述：线程 A → B → C，依次执行
实际应用：数据处理流水线、任务分步执行
关键需求：确保前一个线程完成后，下一个线程才开始
```

**⏰ 条件等待唤醒场景**
```
场景描述：线程等待某条件成立，直到被其他线程通知
实际应用：生产者-消费者模型、任务调度系统
关键需求：线程间的状态同步和事件通知
```

**📦 资源协调场景**
```
场景描述：多个线程读写共享队列时协调冲突
实际应用：线程池任务队列、缓存系统
关键需求：避免资源竞争，保证数据一致性
```

### 2.2 场景分类图解


```
线程通信场景分类
├── 📋 数据传递型
│   ├── 生产者-消费者模式
│   ├── 管道通信
│   └── 共享内存访问
├── 🚦 同步控制型
│   ├── 线程执行顺序控制
│   ├── 阶段性等待（屏障）
│   └── 资源访问互斥
└── 📡 事件通知型
    ├── 状态变化通知
    ├── 任务完成信号
    └── 异常处理通知
```

---

## 3. ⚙️ 线程通信的常用机制


### 3.1 wait() / notify() / notifyAll()（Object类方法）


**🔸 基本特性**
- **依赖关系**：只能在 `synchronized` 块中使用
- **锁释放**：调用 `wait()` 会释放锁，线程进入"等待队列"
- **唤醒机制**：`notify()` 唤醒一个等待线程，`notifyAll()` 唤醒所有等待线程

**💻 基础用法示例**
```java
public class WaitNotifyDemo {
    private static final Object lock = new Object();

    public static void main(String[] args) {
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("线程A等待中...");
                    lock.wait(); // 当前线程进入等待，释放锁
                    System.out.println("线程A被唤醒！");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        Thread notifyingThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("线程B发出通知...");
                lock.notify(); // 唤醒一个在 lock 上等待的线程
            }
        });

        waitingThread.start();

        try { Thread.sleep(1000); } catch (InterruptedException ignored) {}
        notifyingThread.start();
    }
}
```

**⚠️ wait/notify 使用注意事项**

| **注意点** | **说明** | **后果** |
|-----------|---------|---------|
| **🔒 必须配合 synchronized 使用** | 否则抛出 `IllegalMonitorStateException` | 程序运行时异常 |
| **🛡️ wait() 需处理 InterruptedException** | 中断异常必须捕获处理 | 线程可能意外终止 |
| **⏰ notify() 不会立即释放锁** | 需退出同步块后目标线程才真正恢复 | 可能导致时序问题 |

### 3.2 Condition（与 Lock 配套）


**🔸 Condition 优势**
- **功能更强大**：提供更灵活的等待/通知机制
- **多条件队列**：可创建多个条件队列，精准控制线程唤醒
- **替代方案**：替代 `wait()/notify()` 的高级方案

**💻 Condition 使用示例**
```java
public class ConditionDemo {
    private static final Lock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();

    public static void main(String[] args) {
        Thread waitingThread = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("线程A等待中...");
                condition.await();  // 等待被唤醒
                System.out.println("线程A被唤醒！");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                lock.unlock();
            }
        });

        Thread signalingThread = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("线程B发出通知...");
                condition.signal();  // 唤醒一个等待线程
            } finally {
                lock.unlock();
            }
        });

        waitingThread.start();

        try { Thread.sleep(1000); } catch (InterruptedException ignored) {}
        signalingThread.start();
    }
}

// 输出结果：
// 线程A等待中...
// 线程B发出通知...
// 线程A被唤醒！
```

**⚠️ Condition 使用注意事项**

| **注意点** | **说明** |
|-----------|---------|
| **🔐 必须使用 lock.lock()/unlock() 包裹** | 确保线程安全访问 |
| **🎯 可以使用多个 Condition 实现"分组等待唤醒"** | 提供更精确的控制 |
| **✅ 推荐用于复杂同步场景** | 比 wait/notify 更安全灵活 |

### 3.3 Thread.join()（线程执行顺序控制）


**🔸 join() 方法特性**
- **用途**：主线程等待子线程执行完成
- **同步依赖**：实现线程间的执行顺序控制
- **应用场景**：适用于"主线程等待子线程结果"的场景

**💡 join() 工作原理**
```
线程执行顺序控制
主线程                     子线程
   |                        |
   |--[start子线程]---------> |
   |                        |--[执行任务]
   |--[调用join()]           |
   |--[等待...]             |--[任务完成]
   |<-[子线程结束]------------ |
   |--[继续执行]             |
```

---

## 4. 📊 通信机制对比分析


### 4.1 功能特性对比


| **特性** | **wait/notify** | **Condition** | **Thread.join()** |
|---------|----------------|---------------|------------------|
| **🏠 所属类** | Object | Lock | Thread |
| **🔒 是否依赖内置锁** | ✅ 是 | ❌ 使用显式锁 | ❌ 无需额外锁 |
| **🎯 可否多个条件队列** | ❌ 否 | ✅ 支持多个 | ❌ 单一等待 |
| **📋 推荐使用场景** | 简单线程协作 | 多条件并发协调 | 顺序执行控制 |
| **⚠️ 是否易误操作** | ⚠️ 是（隐式锁） | ✅ 更安全、灵活 | ✅ 使用简单 |

### 4.2 选择策略指南


```
线程通信机制选择策略
├── 🔰 简单协作场景
│   ├── wait/notify：基础等待通知
│   └── join()：等待线程完成
├── 🎯 复杂协调场景
│   ├── Condition：多条件精确控制
│   └── 并发工具类：专门场景优化
├── 📊 性能敏感场景
│   ├── volatile + 自旋：轻量级通信
│   └── 无锁数据结构：高性能方案
└── 🔄 特殊需求场景
    ├── BlockingQueue：生产消费模式
    └── CountDownLatch：批量同步
```

---

## 5. 🎨 经典通信模式实现


### 5.1 生产者-消费者模型


**💻 wait/notify 实现版本**
```java
// 生产者-消费者基础模式
synchronized (queue) {
    while (queue.isEmpty()) {
        queue.wait(); // 等待非空
    }
    // 取出并处理数据
    Object data = queue.remove();
    queue.notify(); // 通知可能的生产者线程
}
```

### 5.2 顺序打印模式（A→B→C循环打印）


**🔄 循环顺序执行实现**
```java
public class ABCPrint {
    private static final Object lock = new Object();
    private static int state = 0; // 0:A, 1:B, 2:C

    public static void main(String[] args) {
        Runnable printTask = (label, targetState) -> () -> {
            for (int i = 0; i < 5; i++) {
                synchronized (lock) {
                    while (state % 3 != targetState) {
                        try { 
                            lock.wait(); 
                        } catch (InterruptedException ignored) {}
                    }
                    System.out.print(label);
                    state++;
                    lock.notifyAll(); // 唤醒其他线程
                }
            }
        };

        new Thread(printTask.apply("A", 0)).start();
        new Thread(printTask.apply("B", 1)).start();
        new Thread(printTask.apply("C", 2)).start();
    }
}
```

### 5.3 线程状态轮询+中断模式


**🛑 wait + notify + 标志位退出**
```java
public class WaitInterruptFlagDemo {
    private static final Object lock = new Object();
    private static volatile boolean stopFlag = false;

    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            synchronized (lock) {
                while (!stopFlag) {
                    try {
                        System.out.println("线程B进入等待状态...");
                        lock.wait(); // 等待条件或被唤醒
                        System.out.println("线程B被唤醒，检查退出标志");
                    } catch (InterruptedException e) {
                        System.out.println("线程B被中断唤醒，检查退出标志");
                        // 中断也可能是退出信号，继续判断 stopFlag
                    }
                }
                System.out.println("线程B检测到标志位为 true，退出任务");
            }
        });

        worker.start();

        Thread.sleep(2000); // 主线程延迟2秒后发信号
        synchronized (lock) {
            stopFlag = true; // 设置标志位
            lock.notify();   // 唤醒等待线程
        }
    }
}

// 输出示例：
// 线程B进入等待状态...
// 线程B被唤醒，检查退出标志
// 线程B检测到标志位为 true，退出任务
```

**🔧 Condition + 标志位退出模式**
```java
public class ConditionInterruptFlagDemo {
    private static final Lock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();
    private static volatile boolean stopFlag = false;

    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            lock.lock();
            try {
                while (!stopFlag) {
                    try {
                        System.out.println("线程B进入等待状态...");
                        condition.await(); // 阻塞等待
                        System.out.println("线程B被唤醒，检查退出标志");
                    } catch (InterruptedException e) {
                        System.out.println("线程B被中断唤醒，检查退出标志");
                        Thread.currentThread().interrupt(); // 恢复中断状态（可选）
                        break; // 也可不 break，而是继续 while 判断 stopFlag
                    }
                }
                System.out.println("线程B检测到退出标志，结束任务");
            } finally {
                lock.unlock();
            }
        });

        worker.start();

        Thread.sleep(2000); // 模拟延迟
        lock.lock();
        try {
            stopFlag = true;     // 设置退出标志
            condition.signal();  // 唤醒等待线程
        } finally {
            lock.unlock();
        }
    }
}
```

---

## 6. ⚠️ 常见错误与注意事项


### 6.1 典型错误场景


| **错误场景** | **具体原因** | **解决方案** |
|-------------|-------------|-------------|
| **🚫 未在 synchronized 中使用 `wait()`** | 会抛出 `IllegalMonitorStateException` 异常 | 确保在同步块内调用 |
| **🔄 条件判断用 `if` 而非 `while`** | 可能出现虚假唤醒，导致程序逻辑错误 | 始终使用 `while` 循环检查条件 |
| **💀 使用 `notify()` 导致线程"假死"** | 唤醒了不该被唤醒的线程，线程再次等待陷入僵局 | 考虑使用 `notifyAll()` 或 Condition |
| **🔒 忘记释放锁 / 死锁** | 多线程使用共享资源时，未合理释放锁或嵌套锁死 | 使用 try-finally 确保锁释放 |

### 6.2 最佳实践建议


**✅ 正确的条件等待模式**
```java
// ✅ 正确：使用 while 循环
synchronized (lock) {
    while (!condition) {
        lock.wait();
    }
    // 执行业务逻辑
}

// ❌ 错误：使用 if 判断
synchronized (lock) {
    if (!condition) {
        lock.wait(); // 虚假唤醒时可能跳过条件检查
    }
    // 可能在条件未满足时执行
}
```

**🔒 锁使用安全模式**
```java
// ✅ 推荐：try-finally 确保锁释放
lock.lock();
try {
    // 业务逻辑
    condition.await();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
} finally {
    lock.unlock(); // 确保锁被释放
}
```

---

## 7. 🧰 扩展通信工具类


### 7.1 高级同步工具概览


| **工具类** | **功能说明** | **使用场景** |
|-----------|-------------|-------------|
| **🔢 `CountDownLatch`** | 等待多个线程完成后再继续执行（一次性） | 等待所有子任务完成 |
| **🚧 `CyclicBarrier`** | 多线程等待彼此达到某个阶段后再统一前进 | 分阶段并行计算 |
| **🎫 `Semaphore`** | 控制并发线程数（资源许可） | 限制资源访问数量 |
| **📦 `BlockingQueue`** | 支持线程安全的阻塞读写队列 | 生产者-消费者模式 |
| **🔄 `Exchanger`** | 两线程之间安全交换数据 | 线程间数据交换 |

### 7.2 工具类选择策略


```
同步工具类应用场景
├── 📊 计数等待场景
│   ├── CountDownLatch：一次性倒计时
│   └── Semaphore：资源许可控制
├── 🚦 屏障同步场景
│   ├── CyclicBarrier：可重复使用屏障
│   └── Phaser：更复杂的阶段同步
├── 📦 队列通信场景
│   ├── BlockingQueue：阻塞队列通信
│   ├── SynchronousQueue：直接传递
│   └── DelayQueue：延时队列
└── 🔄 数据交换场景
    ├── Exchanger：双线程数据交换
    └── CompletableFuture：异步结果传递
```

### 7.3 性能对比与选择


**⚡ 性能特性对比**

| **机制** | **性能等级** | **适用规模** | **复杂度** |
|---------|-------------|-------------|-----------|
| **wait/notify** | ⭐⭐⭐ | 小规模 | 低 |
| **Condition** | ⭐⭐⭐⭐ | 中等规模 | 中 |
| **BlockingQueue** | ⭐⭐⭐⭐⭐ | 大规模 | 低 |
| **Atomic + volatile** | ⭐⭐⭐⭐⭐ | 高性能 | 中 |

> 💡 **选择建议**：
> - **学习阶段**：优先掌握 wait/notify 和 Condition
> - **生产环境**：优先使用 BlockingQueue 等高级工具
> - **性能关键**：考虑无锁方案如 Atomic 操作
> - **复杂同步**：使用 CountDownLatch 等专门工具