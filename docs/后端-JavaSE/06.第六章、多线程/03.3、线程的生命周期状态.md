---
title: 3、线程的生命周期状态
---
## 📚 目录

1. [线程六大状态概述](#1-线程六大状态概述)
2. [状态转换机制](#2-状态转换机制)
3. [BLOCKED状态详解](#3-BLOCKED状态详解)
4. [WAITING状态详解](#4-WAITING状态详解)
5. [TIMED_WAITING状态详解](#5-TIMED_WAITING状态详解)
6. [状态转换方法汇总](#6-状态转换方法汇总)
7. [线程状态监控调试](#7-线程状态监控调试)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 线程六大状态概述


### 1.1 状态枚举总览


| 状态 | **描述** | **触发条件** |
|------|---------|------------|
| **NEW** | `新建，线程对象被创建，但尚未调用 start() 启动` | `Thread t = new Thread()` |
| **RUNNABLE** | `可运行，调用了 start() 后，处于就绪队列，等待 CPU 分配` | `t.start()` |
| **BLOCKED** | `阻塞，尝试获取同步锁失败，等待锁释放` | `进入synchronized但未获取锁` |
| **WAITING** | `无限期等待，需由其他线程显式唤醒，如 wait()、join()` | `wait()、join()、park()` |
| **TIMED_WAITING** | `有限等待状态，如 sleep()、wait(timeout)、join(timeout)` | `sleep(ms)、wait(ms)` |
| **TERMINATED** | `终止状态，线程执行完毕或出现异常退出` | `run()完成或异常` |

### 1.2 线程状态层次结构


```java
Java 线程六大状态（Thread.State）详解树形结构

├── 1. NEW（新建）
│   ├── 定义：线程对象被创建，但尚未启动
│   ├── 示例：Thread t = new Thread();
│   ├── 转换条件：调用 t.start() 进入 RUNNABLE
│   ├── 是否释放锁：无锁
│   ├── 唤醒方式：无（只能手动调用 start()）
│   └── 注意事项：
│       ├── start() 只能调用一次
│       └── 若多次调用，抛出 IllegalThreadStateException

├── 2. RUNNABLE（可运行）
│   ├── 定义：线程已启动，正在等待 CPU 调度或正在执行
│   ├── 转换来源：NEW → start() 后进入
│   ├── 转换目标：
│   │   ├── BLOCKED：尝试获取 synchronized 锁失败
│   │   ├── WAITING：调用 wait()、join()
│   │   ├── TIMED_WAITING：sleep(ms)、wait(ms)
│   │   └── TERMINATED：run() 执行完或抛出异常
│   ├── 是否释放锁：视具体行为而定（如进入 wait 会释放）
│   └── 注意事项：
│       ├── "就绪" + "运行中" 在 Java 中统一为 RUNNABLE
│       └── CPU 调度控制由 JVM 和操作系统决定

├── 3. BLOCKED（阻塞）
│   ├── 定义：线程等待获取 synchronized 锁
│   ├── 触发方法：进入 synchronized 块/方法但未获得锁
│   ├── 是否释放锁：没有锁可释放（正在等待锁）
│   ├── 唤醒方式：获取锁后自动变为 RUNNABLE
│   └── 注意事项：
│       ├── 不可通过 notify() 唤醒
│       └── 与 wait() 区分：wait() 是等待线程动作，BLOCKED 是等待锁资源

├── 4. WAITING（无限等待）
│   ├── 定义：线程无限期等待被唤醒
│   ├── 典型方法：
│   │   ├── Object.wait()
│   │   ├── Thread.join()
│   │   └── LockSupport.park()
│   ├── 是否释放锁：
│   │   ├── wait() 会释放锁
│   │   └── join() 不释放锁（非同步方法）
│   ├── 唤醒方式：
│   │   ├── Object.notify() / notifyAll()
│   │   ├── 被等待的线程执行完毕（join）
│   │   └── LockSupport.unpark()
│   └── 注意事项：
│       ├── wait() 必须在 synchronized 块中使用
│       ├── 否则抛 IllegalMonitorStateException
│       └── 若未被唤醒，线程可能永久挂起（死等）

├── 5. TIMED_WAITING（超时等待）
│   ├── 定义：线程等待特定时间后自动唤醒
│   ├── 常见方法：
│   │   ├── Thread.sleep(ms)
│   │   ├── Object.wait(ms)
│   │   ├── Thread.join(ms)
│   │   ├── LockSupport.parkNanos()
│   │   └── LockSupport.parkUntil()
│   ├── 是否释放锁：
│   │   ├── wait(ms) 会释放锁
│   │   ├── sleep() 不释放锁
│   │   └── join(ms) 不释放锁
│   ├── 唤醒方式：
│   │   ├── 时间到后自动进入 RUNNABLE
│   │   └── 某些情况可被 notify() 提前唤醒
│   └── 注意事项：
│       └── sleep 不会释放锁，注意避免死锁风险

├── 6. TERMINATED（终止）
│   ├── 定义：线程生命周期结束，不再运行
│   ├── 进入方式：
│   │   ├── run() 执行完成
│   │   └── 执行中抛出未捕获异常
│   ├── 是否释放锁：终止后自动释放已持有锁
│   ├── 判断方法：Thread.isAlive() → false
│   └── 注意事项：
│       ├── 终止后不能调用 start()，否则抛异常
│       └── 无法被唤醒、恢复，只能销毁并重新创建线程
```

---

## 2. 🔀 状态转换机制


### 2.1 状态转换路径图解


```
NEW → RUNNABLE         ：start()
RUNNABLE → BLOCKED     ：进入同步锁但未获取（synchronized）
RUNNABLE → WAITING     ：wait() / join() 等待其他线程显式唤醒
RUNNABLE → TIMED_WAITING：sleep(ms)、wait(ms)、join(ms)
BLOCKED/WAITING/TIMED_WAITING → RUNNABLE：获取锁/被唤醒/时间到
RUNNABLE → TERMINATED  ：run()执行完或异常终止


┌────────┐        start()       ┌─────────────┐
│  NEW   ├────────────────────▶│  RUNNABLE   │
└────────┘                     └─────┬───────┘
                                     │
                                     ▼
                              ┌──────────────┐
                        wait()│  WAITING     │◀─────┐
                              └────┬─────────┘      │
                                   │                │
                        notify() / join 完         │
                                   ▼                │
                              ┌──────────────┐      │
                      wait(ms)│ TIMED_WAITING│─────▶┐
                              └────┬─────────┘      │
                                   │   sleep()/     │
                                   │   join(ms)/    │
                                   │   wait(ms)     │
                                   ▼                │
                              ┌──────────────┐      │
                         sync│   BLOCKED     │◀─────┘
                              └────┬─────────┘
                                   │
                                 lock
                                   ▼
                              ┌──────────────┐
                              │  RUNNABLE    │
                              └────┬─────────┘
                                   │
                                   ▼
                              ┌──────────────┐
                              │ TERMINATED   │
                              └──────────────┘
```

### 2.2 状态转移触发条件


| 当前状态 | **转换目标状态** | **触发方法或条件** | **说明** |
|---------|----------------|------------------|---------|
| **NEW** | `RUNNABLE` | `start()` | `启动线程` |
| **RUNNABLE** | `BLOCKED` | `进入 synchronized 但未获取锁` | `等待锁，排他资源竞争` |
| **RUNNABLE** | `WAITING` | `wait() / join() / park()` | `无限期等待其他线程操作` |
| **RUNNABLE** | `TIMED_WAITING` | `sleep(ms) / wait(ms) / join(ms)` | `限时等待` |
| **BLOCKED** | `RUNNABLE` | `获取到锁` | `获得锁后可继续运行` |
| **WAITING** | `RUNNABLE` | `被 notify() / notifyAll() / join 完成` | `被唤醒` |
| **TIMED_WAITING** | `RUNNABLE` | `超时时间到 / 被 notify() 唤醒` | `时间到或被唤醒` |
| **RUNNABLE** | `TERMINATED` | `run() 执行完成或抛出异常` | `线程自然死亡或异常终止` |

### 2.3 基础状态转移代码示例


```java
// ① NEW → RUNNABLE （调用 start()）
Thread t = new Thread(() -> System.out.println("线程运行"));
System.out.println(t.getState()); // NEW
t.start();
System.out.println(t.getState()); // RUNNABLE（可能是 RUNNABLE 或 TERMINATED，取决于打印时机）

// ② RUNNABLE → BLOCKED （尝试获取被占用的 synchronized 锁）
Object lock = new Object();

Thread t1 = new Thread(() -> {
    synchronized (lock) {
        try { Thread.sleep(3000); } catch (InterruptedException ignored) {}
    }
});

Thread t2 = new Thread(() -> {
    synchronized (lock) {
        System.out.println("t2 获得锁");
    }
});

t1.start();
Thread.sleep(100); // 确保 t1 先获得锁
t2.start();

Thread.sleep(100); // 再观察 t2 状态
System.out.println(t2.getState()); // BLOCKED

// ③ RUNNABLE → WAITING（wait() / join() / LockSupport.park()）
// 示例：使用 join()（线程A 等待线程B 完成）
Thread t = new Thread(() -> {
    try { Thread.sleep(2000); } catch (InterruptedException ignored) {}
});

Thread waiter = new Thread(() -> {
    try {
        t.join(); // 等待线程t完成，进入 WAITING 状态
    } catch (InterruptedException ignored) {}
});

t.start();
waiter.start();

Thread.sleep(100); // 等待状态生效
System.out.println(waiter.getState()); // WAITING

// ④ RUNNABLE → TIMED_WAITING（sleep、wait(ms)、join(ms)）
// 示例：使用 sleep()（进入 TIMED_WAITING）
Thread t = new Thread(() -> {
    try { Thread.sleep(2000); } catch (InterruptedException ignored) {}
});

t.start();
Thread.sleep(100); // 等待进入 sleep 中
System.out.println(t.getState()); // TIMED_WAITING

// ⑤ BLOCKED / WAITING / TIMED_WAITING → RUNNABLE（锁释放、notify、时间到）
// 示例：wait() 被 notify 唤醒
Object lock = new Object();

Thread t = new Thread(() -> {
    synchronized (lock) {
        try {
            lock.wait(); // 进入 WAITING
        } catch (InterruptedException ignored) {}
    }
});

t.start();
Thread.sleep(100); // 让线程进入 WAITING

synchronized (lock) {
    lock.notify(); // 唤醒 t，状态从 WAITING → RUNNABLE
}

Thread.sleep(100); // 等待恢复执行
System.out.println(t.getState()); // RUNNABLE 或 TERMINATED

// ⑥ RUNNABLE → TERMINATED（线程执行完毕或抛出异常）
Thread t = new Thread(() -> System.out.println("执行完就终止"));
t.start();
t.join(); // 等待线程执行结束
System.out.println(t.getState()); // TERMINATED
```

---

## 3. 🚫 BLOCKED状态详解


### 3.1 BLOCKED状态机制


**🔸 核心概念**
```
定义（是什么）：
指线程尝试进入某个同步代码块/方法，但锁对象已被其他线程持有，
于是进入"等待锁"状态，等待获取监视器锁。
本质上是：锁竞争失败，挂起等待进入 critical section（临界区）
```

### 3.2 BLOCKED状态图解


```
阻塞（BLOCKED）状态图解：线程争抢锁失败时的行为：

主线程:    |-----持有锁，执行任务中------|------------------------释放锁----------------->
               ↑                                                    ↓
线程A:         |-------------------BLOCKED 等待获取锁----------------→ 获得锁后继续执行 →

说明：
主线程先进入 synchronized(lock) 块，成功获取锁
线程A 随后尝试 synchronized(lock)，由于锁被主线程持有，进入 BLOCKED
主线程退出同步块（即释放锁）后，线程A 自动恢复为 RUNNABLE 并获取锁执行
```

### 3.3 BLOCKED状态代码示例


```java
public class BlockedExample {
    // 定义一个共享的锁对象，两个线程会竞争这个锁
    private static final Object lock = new Object();

    public static void main(String[] args) {
        // 创建一个任务：尝试获取锁并执行同步代码块
        Runnable task = () -> {
            synchronized (lock) { // 竞争进入 synchronized 块（需要获取 lock 对象的锁）
                System.out.println(Thread.currentThread().getName() + " 获得锁，执行中...");
                try {
                    Thread.sleep(5000); // 模拟线程长时间占用锁（5 秒）
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt(); // 设置中断标志（建议的中断处理方式）
                }
            } // 同步块结束，自动释放锁
        };

        // 创建两个线程，执行相同的任务
        Thread t1 = new Thread(task, "线程-A");
        Thread t2 = new Thread(task, "线程-B");

        // 启动线程A，它会首先获得锁并执行
        t1.start();

        // 稍作延迟，确保线程A先抢到锁
        try {
            Thread.sleep(100); // 等待100ms，给线程A先执行的机会
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 启动线程B，它会因为线程A还未释放锁而进入 BLOCKED 状态
        t2.start();

        // 创建一个监控线程，持续查看线程B的状态
        new Thread(() -> {
            while (true) {
                // 输出线程B当前的状态
                System.out.println(t2.getName() + " 状态: " + t2.getState());
                try {
                    Thread.sleep(500); // 每隔 0.5 秒刷新一次状态
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start(); // 启动监控线程
    }
}

// 输出示例：
// 线程-A 获得锁，执行中...
// 线程-B 状态: BLOCKED
// 线程-B 状态: BLOCKED
// 线程-B 状态: BLOCKED
// ...（约5秒后）
// 线程-B 获得锁，执行中...
```

### 3.4 BLOCKED状态特点总结


**⚠️ 关键特征**
```
与其他状态的区别：
• 不同于 WAITING：BLOCKED 是等待锁资源，WAITING 是等待线程动作
• 无法通过 wait() / notify() 控制状态转移
• 只能通过锁的释放自动恢复为 RUNNABLE

调试识别：
• 编程方式：System.out.println(thread.getState()); // BLOCKED 
• jstack 分析：显示 "waiting to lock" 信息
```

---

## 4. ⏳ WAITING状态详解


### 4.1 WAITING状态机制


**🔸 核心概念**
```
WAITING状态是线程主动调用wait()释放锁并无限期等待通知的状态
只有其他线程调用notify()/notifyAll()才能唤醒WAITING状态的线程
被唤醒的线程必须重新竞争获取锁才能继续执行
```

### 4.2 WAITING状态图解


```
线程A:     |--执行中--|---持有锁，调用wait()释放锁---|--------WAITING 无限等待 notify()--------→
                       ↓                                        ↑
线程B:                 |----获取到锁----|--执行任务--|--调用notify()--|--释放锁--|--继续执行--→
                                                                ↓
线程A:                                                          |--重新获取锁--|--继续执行--→
```

### 4.3 WAITING状态代码示例


```java
public class WaitingExample {
    private static final Object lock = new Object(); // 共享锁对象

    public static void main(String[] args) throws InterruptedException {
        // 线程A：进入 WAITING 状态
        Thread threadA = new Thread(() -> {
            synchronized (lock) {
                System.out.println("线程A 获取锁，调用 wait() 进入 WAITING 状态...");
                try {
                    lock.wait(); // 无限期等待，释放锁，状态变为 WAITING
                    System.out.println("线程A 被唤醒，继续执行");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        // 线程B：2秒后唤醒线程A
        Thread threadB = new Thread(() -> {
            try {
                Thread.sleep(2000); // 等待主线程先进入 wait
                synchronized (lock) {
                    System.out.println("线程B 获取锁，调用 notify() 唤醒线程A");
                    lock.notify(); // 唤醒正在 WAITING 的线程A
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        threadA.start(); // 启动线程A
        Thread.sleep(100); // 确保A先获得锁并 wait
        threadB.start();   // 启动线程B，准备唤醒A
        
        // 监控线程A的状态变化
        Thread.sleep(500);
        System.out.println("线程A 当前状态: " + threadA.getState()); // WAITING
    }
}

// 运行输出示意：
// 线程A 获取锁，调用 wait() 进入 WAITING 状态...
// 线程A 当前状态: WAITING
// 线程B 获取锁，调用 notify() 唤醒线程A
// 线程A 被唤醒，继续执行
```

### 4.4 WAITING状态要点


**💡 重点说明**
```
关键机制：
• wait() 会释放锁，并将线程置为 WAITING 状态
• notify() 会唤醒其中一个 WAITING 状态的线程（如果存在）
• 被唤醒后，线程还需要重新获得锁才能继续执行
• 必须在 synchronized(lock) 内使用 wait() 和 notify()，否则抛 IllegalMonitorStateException

常见用法：
• Object.wait() - 无限期等待
• Thread.join() - 等待另一个线程结束
• LockSupport.park() - 阻塞当前线程
```

---

## 5. ⏰ TIMED_WAITING状态详解


### 5.1 TIMED_WAITING状态机制


**🔸 核心概念**
```
sleep()让线程休眠指定时间但不释放锁，wait()会释放锁并等待
TIMED_WAITING有时间限制，到期或被notify()都会结束等待状态
wait()后被唤醒的线程必须重新获取锁才能继续执行
```

### 5.2 TIMED_WAITING状态图解


```
Thread.sleep(1000) 场景：
线程A: |--执行中--|--sleep(1000)--|--TIMED_WAITING(期间不释放锁)--|--时间到，继续执行--->


Object.wait(1000) 场景：
线程A: |--持有锁--|--wait(1000)→释放锁--|--TIMED_WAITING--|--被唤醒或时间到--|
                                      ↓                                         ↑
线程B:         |--获取锁--|--执行任务--|--notify()（可选）--|--释放锁--|
                                                        ↓
线程A:                                     |--重获锁--|--继续执行--->  
```

### 5.3 sleep() vs wait() 对比


| 对比点 | **Thread.sleep()** | **Object.wait()** |
|-------|-------------------|------------------|
| **是否释放锁** | `❌ 不释放锁` | `✅ 会释放锁` |
| **是否进入 TIMED_WAITING** | `✅ 是` | `✅ 是` |
| **唤醒方式** | `⏰ 时间到自动唤醒` | `⏰ 时间到 or 🔔 被 notify() 唤醒` |
| **唤醒后是否立即执行** | `是，但需等待线程调度` | `是，但必须先重新获得锁` |
| **必须在同步块中调用？** | `❌ 否` | `✅ 是，必须在 synchronized 内` |

### 5.4 TIMED_WAITING状态代码示例


```java
public class TimedWaitingExample {
    private static final Object lock = new Object(); // 共享锁对象

    public static void main(String[] args) throws InterruptedException {
        // 示例 1：sleep() - 不释放锁，固定时间后自动恢复
        Thread sleepThread = new Thread(() -> {
            System.out.println("sleepThread 进入 sleep(2000)，状态为 TIMED_WAITING");
            try {
                Thread.sleep(2000); // 线程进入 TIMED_WAITING，休眠 2 秒
                System.out.println("sleepThread 醒来，继续执行");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 示例 2：wait(timeout) - 释放锁，超时或被 notify 唤醒
        Thread waitThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("waitThread 进入 wait(2000)，状态为 TIMED_WAITING");
                try {
                    lock.wait(2000); // 进入 TIMED_WAITING，释放锁，等待2秒
                    System.out.println("waitThread 醒来（超时或被唤醒），继续执行");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        sleepThread.start(); // 启动 sleep 示例线程
        waitThread.start();  // 启动 wait 示例线程
        
        // 监控状态
        Thread.sleep(100);
        System.out.println("sleepThread 状态: " + sleepThread.getState()); // TIMED_WAITING
        System.out.println("waitThread 状态: " + waitThread.getState());   // TIMED_WAITING
    }
}

// 输出示意：
// sleepThread 进入 sleep(2000)，状态为 TIMED_WAITING
// waitThread 进入 wait(2000)，状态为 TIMED_WAITING
// sleepThread 状态: TIMED_WAITING
// waitThread 状态: TIMED_WAITING
// sleepThread 醒来，继续执行
// waitThread 醒来（超时或被唤醒），继续执行
```

---

## 6. 📊 状态转换方法汇总


### 6.1 方法与状态转换对照表


| 方法 | **作用** | **状态变化** | **备注** |
|------|---------|-------------|---------|
| **start()** | `启动线程` | `NEW → RUNNABLE` | `不可多次调用` |
| **run()** | `执行任务` | `不改变状态` | `被 start() 调用才并发` |
| **sleep(ms)** | `休眠` | `RUNNABLE → TIMED_WAITING` | `不释放锁` |
| **wait()** | `等待` | `RUNNABLE → WAITING` | `释放锁，需同步块` |
| **wait(ms)** | `等待` | `RUNNABLE → TIMED_WAITING` | `自动唤醒或被通知` |
| **notify() / notifyAll()** | `唤醒` | `WAITING → RUNNABLE` | `必须在同步块中调用` |
| **join()** | `等待另一个线程结束` | `RUNNABLE → WAITING` | `当前线程等待目标线程` |
| **join(ms)** | `限时等待另一个线程` | `RUNNABLE → TIMED_WAITING` | `超时或目标线程结束` |
| **interrupt()** | `中断线程` | `影响阻塞或等待状态` | `设置中断标志位` |

### 6.2 方法释放锁情况对照表


| 方法 | **转换到状态** | **是否释放锁** | **唤醒方式** |
|------|-------------|-------------|------------|
| **sleep(ms)** | `TIMED_WAITING` | `❌不释放` | `时间到自动唤醒` |
| **wait()** | `WAITING` | `✅释放` | `notify() 唤醒` |
| **wait(ms)** | `TIMED_WAITING` | `✅释放` | `notify() / 时间到` |
| **join()** | `WAITING` | `❌不释放` | `被 join 的线程结束` |
| **join(ms)** | `TIMED_WAITING` | `❌不释放` | `被 join 的线程结束或时间到` |
| **synchronized** | `BLOCKED` | `❌不释放` | `等待获取锁` |

---

## 7. 🔍 线程状态监控调试


### 7.1 监控方式对比


| 监控方式 | **工具/方法名** | **功能简介** | **使用场景** |
|---------|---------------|-------------|------------|
| **编程监控** | `Thread.getState()` | `获取当前线程状态` | `打印线程状态变化日志` |
|  | `Thread.isAlive()` | `是否存活（非 TERMINATED）` | `检查线程是否已结束` |
|  | `Thread.isInterrupted()` | `检查中断标志位` | `判断线程是否响应过中断` |
| **命令行工具** | `jps` | `查看 Java 进程 PID` | `配合 jstack 使用` |
|  | `jstack <pid>` | `打印线程栈和状态` | `死锁、阻塞、线程卡死分析` |
| **图形工具（轻量）** | `jconsole` | `图形化展示线程状态` | `轻度调试，适合初学者` |
| **图形工具（专业）** | `VisualVM` | `支持线程 dump、热点分析、堆分析` | `深度调试、性能问题分析` |
| **线程Dump分析** | `jstack + grep` | `grep "BLOCKED" / "WAITING"过滤分析` | `快速查看死锁或线程分布` |

### 7.2 监控调试体系


```java
Java 线程状态调试与监控
├── 1. 程序内监控（编程方式）
│   ├── 1.1 Thread.getState()
│   │   └── 获取线程当前状态（返回 Thread.State 枚举）
│   ├── 1.2 Thread.isAlive()
│   │   └── 判断线程是否终止（TERMINATED）
│   ├── 1.3 Thread.isInterrupted()
│   │   └── 判断线程是否被中断（中断标志位）
│   └── 1.4 示例建议
│       └── 定时打印状态变化（监控线程执行流）

├── 2. JDK 工具监控
│   ├── 2.1 jps（Java Process Status）
│   │   └── 查看当前运行的 Java 进程 PID
│   ├── 2.2 jstack <pid>
│   │   ├── 查看线程栈信息（含线程状态）
│   │   ├── 常用于死锁、阻塞排查
│   │   └── 可配合 grep "BLOCKED|WAITING" 过滤
│   ├── 2.3 jconsole（图形界面）
│   │   ├── 实时查看线程数、内存、GC 等
│   │   └── 可单独查看各线程状态变化
│   └── 2.4 VisualVM（高级图形工具）
│       ├── 可安装插件：VisualGC、Thread Sampler
│       ├── 支持堆快照、线程Dump、热点分析
│       └── 实时监控线程状态分布图

├── 3. 应用场景（结合状态）
│   ├── 3.1 线程卡死：TERMINATED 未触发 → 死循环？
│   ├── 3.2 死锁分析：多个线程 BLOCKED 且互相持锁
│   ├── 3.3 阻塞队列满：线程进入 WAITING
│   ├── 3.4 join 超时：线程 TIMED_WAITING 未唤醒
│   └── 3.5 中断失效：线程未检查 interrupt 状态

├── 4. 面试延伸点
│   ├── 如何监控线程状态？
│   ├── 死锁怎么定位？
│   ├── WAITING 和 BLOCKED 怎么区分？
│   └── jstack 结果如何分析？
```

### 7.3 jstack输出样例


```java
// jstack 输出中线程状态样例说明

"Thread-0" #11 prio=5 os_prio=0 tid=0x000001 ...
   java.lang.Thread.State: WAITING
        at java.lang.Object.wait(Native Method)
        at com.example.SyncTest.run(SyncTest.java:10)

"Thread-1" #12 prio=5 ...
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.example.SyncTest.run(SyncTest.java:5)

// 说明：
// WAITING：在执行 wait()，等别人唤醒
// BLOCKED：想获取锁，锁被别人持有
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心知识


```
🔸 六大状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED
🔸 核心转换：start()启动、synchronized争锁、wait/notify通信、时间控制
🔸 锁释放规则：wait()释放锁，sleep()不释放锁，join()不释放锁
🔸 状态区别：BLOCKED等锁，WAITING等通知，TIMED_WAITING有时限
🔸 监控调试：getState()编程监控，jstack工具分析，状态变化追踪
```

### 8.2 关键理解要点


**🔹 BLOCKED vs WAITING 的本质区别**
```
BLOCKED状态：
• 等待的是锁资源
• 不能通过notify()唤醒
• 锁释放后自动恢复

WAITING状态：
• 等待的是其他线程的通知
• 可以通过notify()唤醒
• 主动调用wait()进入
```

**🔹 为什么sleep()不释放锁**
```
设计考虑：
• sleep()是Thread类的静态方法，与具体对象无关
• 其目的是让当前线程休眠，不涉及锁的协调
• wait()是Object方法，设计用于线程间协作，需要释放锁让其他线程工作
```

**🔹 状态转换的不可逆性**
```
重要规则：
• NEW状态只能通过start()转换到RUNNABLE
• TERMINATED状态不能转换到其他状态
• 不能直接从BLOCKED转到WAITING，需要先获得锁
```

### 8.3 实际应用指导


- **多线程编程**：理解状态有助于设计合理的线程同步机制
- **性能调优**：通过状态监控识别线程阻塞和等待问题
- **问题诊断**：利用jstack等工具分析线程死锁和卡顿
- **代码设计**：合理使用wait/notify、sleep、join等方法

**核心记忆**：
- 六状态生命周期，NEW开始TERMINATED终
- BLOCKED等锁WAITING等人，TIMED有时限可中断
- wait释放锁sleep不放，join等线程notify唤
- 状态监控很重要，jstack工具来帮忙