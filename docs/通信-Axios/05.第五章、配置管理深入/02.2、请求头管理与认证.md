---
title: 2、请求头管理与认证
---
## 📚 目录

1. [什么是请求头](#1-什么是请求头)
2. [常见请求头详解](#2-常见请求头详解)
3. [Authorization认证头](#3-authorization认证头)
4. [Content-Type内容类型](#4-content-type内容类型)
5. [自定义请求头管理](#5-自定义请求头管理)
6. [动态请求头设置](#6-动态请求头设置)
7. [请求头优先级规则](#7-请求头优先级规则)
8. [Token认证实战](#8-token认证实战)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🤔 什么是请求头


### 1.1 通俗理解请求头


想象你要寄快递📦，你需要在包裹上贴上各种标签：

```
快递包裹标签：
┌─────────────────────┐
│ 收件人：张三         │  ← 告诉服务器这是给谁的
│ 内容物：书籍         │  ← 告诉服务器里面装的啥
│ 重量：2kg           │  ← 告诉服务器有多重
│ 快递类型：加急       │  ← 告诉服务器怎么处理
└─────────────────────┘

HTTP请求头：
┌─────────────────────────┐
│ Authorization: Bearer... │  ← 身份证明
│ Content-Type: json      │  ← 数据格式
│ Accept: application/json │  ← 想要什么格式
│ User-Agent: Chrome      │  ← 浏览器信息
└─────────────────────────┘
```

**💡 核心理解**：请求头就是**给服务器的说明书**，告诉服务器：
- 🆔 **我是谁**（身份认证）
- 📄 **我发的是什么**（数据格式）
- 🎯 **我想要什么**（期望响应）
- 🔧 **怎么处理**（处理方式）

### 1.2 请求头的作用


```javascript
// 没有请求头 - 就像寄匿名包裹
axios.get('/api/data')

// 有请求头 - 完整的信息标签
axios.get('/api/data', {
  headers: {
    'Authorization': 'Bearer token123',  // 身份证
    'Accept': 'application/json'         // 想要JSON格式
  }
})
```

---

## 2. 📋 常见请求头详解


### 2.1 核心请求头说明


| 请求头名称 | **通俗解释** | **实际作用** | **使用场景** |
|-----------|-------------|-------------|-------------|
| `Authorization` | 🔑 **身份证** | `证明你是谁，有权限访问` | `登录后的所有请求` |
| `Content-Type` | 📄 **包裹标签** | `告诉服务器数据是什么格式` | `发送数据时必须` |
| `Accept` | 🎯 **购物清单** | `告诉服务器想要什么格式` | `指定返回格式` |
| `User-Agent` | 📱 **设备名片** | `告诉服务器你用什么浏览器` | `统计和兼容性` |

### 2.2 生活化理解


```
去餐厅点餐的对话：

你："我是VIP会员"              → Authorization（身份认证）
你："我要点一份炒饭"            → Content-Type（发送的内容）
你："请给我中文菜单"            → Accept-Language（语言偏好）
你："我用支付宝付款"            → Payment-Method（支付方式）

服务员根据这些信息：
- 确认你的会员身份 ✅
- 理解你要什么 ✅  
- 用你熟悉的语言服务 ✅
- 准备对应的支付方式 ✅
```

### 2.3 基础使用示例


```javascript
// 🔧 设置常用请求头
const commonHeaders = {
  'Accept': 'application/json',           // 我要JSON格式
  'Content-Type': 'application/json',     // 我发的是JSON
  'User-Agent': 'MyApp/1.0'              // 我的应用信息
}

axios.get('/api/users', { 
  headers: commonHeaders 
})
```

---

## 3. 🔐 Authorization认证头


### 3.1 什么是Authorization头


**通俗理解**：就像进入小区需要门禁卡🏠

```
现实生活：
小区门禁 → 刷卡进入 → 证明你是业主

Web请求：
API接口 → 发送Token → 证明你有权限
```

### 3.2 常见认证方式


#### 🎫 Bearer Token（最常用）


```javascript
// 💡 Bearer = 持有者，意思是"持有这个token的人"
const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'

axios.get('/api/profile', {
  headers: {
    'Authorization': `Bearer ${token}`  // Bearer + 空格 + token
  }
})
```

**为什么叫Bearer？**
- **Bearer** = 持票人、持有者
- 就像电影票🎬，**谁拿着票谁就能进**
- 不管你是谁，有token就有权限

#### 🔑 Basic认证（用户名密码）


```javascript
// 💡 Basic认证 = 用户名:密码 经过base64编码
const username = 'admin'
const password = '123456'
const encoded = btoa(`${username}:${password}`)  // 编码

axios.get('/api/data', {
  headers: {
    'Authorization': `Basic ${encoded}`
  }
})
```

### 3.3 认证头设置方式


```javascript
// 🎯 方式一：单次请求
axios.get('/api/data', {
  headers: { 'Authorization': 'Bearer token123' }
})

// 🎯 方式二：全局设置（推荐）
axios.defaults.headers.common['Authorization'] = 'Bearer token123'

// 🎯 方式三：实例设置
const apiClient = axios.create({
  headers: { 'Authorization': 'Bearer token123' }
})
```

---

## 4. 📄 Content-Type内容类型


### 4.1 Content-Type的通俗理解


**生活比喻**：就像包裹上的**"内容物标签"**📦

```
快递包裹：
┌────────────────┐
│ 内容物：易碎品  │ → 快递员小心处理
│ 内容物：文件    │ → 快递员正常处理  
│ 内容物：食品    │ → 快递员保温处理
└────────────────┘

HTTP请求：
Content-Type: application/json     → 服务器按JSON解析
Content-Type: text/plain          → 服务器按文本处理
Content-Type: multipart/form-data  → 服务器按文件上传处理
```

### 4.2 常见Content-Type类型


| 类型 | **通俗说明** | **什么时候用** | **数据格式** |
|------|-------------|---------------|-------------|
| `application/json` | 📄 **JSON数据** | `发送对象、数组时` | `{"name": "张三"}` |
| `application/x-www-form-urlencoded` | 📝 **表单数据** | `普通表单提交` | `name=张三&age=25` |
| `multipart/form-data` | 📁 **文件上传** | `上传图片、文件时` | `二进制 + 表单混合` |
| `text/plain` | 📃 **纯文本** | `发送简单文本` | `Hello World` |

### 4.3 实际使用示例


```javascript
// 🎯 发送JSON数据（最常用）
axios.post('/api/users', 
  { name: '张三', age: 25 },  // 数据会自动转为JSON
  {
    headers: { 'Content-Type': 'application/json' }
  }
)

// 🎯 发送表单数据
const formData = new URLSearchParams()
formData.append('name', '张三')
formData.append('age', '25')

axios.post('/api/users', formData, {
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
})

// 🎯 上传文件
const fileData = new FormData()
fileData.append('avatar', file)  // file是用户选择的文件

axios.post('/api/upload', fileData, {
  headers: { 'Content-Type': 'multipart/form-data' }
})
```

**💡 小贴士**：axios会**自动设置**Content-Type，但了解原理很重要！

---

## 5. 🛠️ 自定义请求头管理


### 5.1 为什么需要自定义请求头


**生活场景**：你去银行办业务🏦

```
标准业务：
- 带身份证（Authorization）
- 填标准表格（Content-Type）

特殊业务：
- 带工作证明（X-Work-Proof）
- 带收入证明（X-Income-Proof）
- 带特殊申请表（X-Special-Form）
```

**Web场景**：
```javascript
// 标准请求头
{
  'Authorization': 'Bearer token',
  'Content-Type': 'application/json'
}

// 自定义请求头（业务需要）
{
  'X-API-Version': 'v2.0',        // API版本
  'X-Request-ID': 'req_123',      // 请求追踪ID
  'X-Client-Type': 'mobile'       // 客户端类型
}
```

### 5.2 自定义请求头的命名规范


```javascript
// ✅ 推荐命名（遵循规范）
{
  'X-API-Key': 'your-api-key',      // X- 开头表示自定义
  'X-Request-ID': 'uuid-123',       // 用连字符分隔
  'X-Client-Version': '1.2.3'       // 语义化命名
}

// ❌ 不推荐命名
{
  'myheader': 'value',              // 太简单
  'CUSTOM_HEADER': 'value',         // 全大写不规范
  'x_api_key': 'value'             // 下划线不推荐
}
```

### 5.3 自定义请求头使用示例


```javascript
// 🎯 单个请求添加自定义头
axios.get('/api/data', {
  headers: {
    'X-API-Version': '2.0',
    'X-Request-Source': 'mobile-app',
    'X-User-Role': 'admin'
  }
})

// 🎯 批量设置自定义头
const customHeaders = {
  'X-API-Key': process.env.API_KEY,
  'X-Client-Type': 'web',
  'X-Timestamp': Date.now().toString()
}

const apiClient = axios.create({
  headers: customHeaders
})
```

---

## 6. ⚡ 动态请求头设置


### 6.1 什么是动态请求头


**通俗理解**：就像**智能门禁卡**🎫，会根据情况变化

```
普通门禁卡：
- 固定信息，不会变

智能门禁卡：
- 上午显示"工作模式"
- 下午显示"会议模式"  
- 周末显示"休闲模式"

动态请求头：
- 登录前：无Authorization
- 登录后：有Authorization + Token
- 不同页面：不同的追踪ID
```

### 6.2 动态设置的常见场景


#### 🔄 根据登录状态动态设置


```javascript
// 💡 智能设置：有token就带上，没有就不带
function getAuthHeaders() {
  const token = localStorage.getItem('token')
  
  if (token) {
    return { 'Authorization': `Bearer ${token}` }
  }
  return {}  // 没登录就不设置认证头
}

// 使用动态头
axios.get('/api/profile', {
  headers: {
    ...getAuthHeaders(),  // 动态添加认证头
    'Accept': 'application/json'
  }
})
```

#### 📱 根据设备类型动态设置


```javascript
// 💡 检测设备类型，设置对应的头部
function getDeviceHeaders() {
  const isMobile = /Mobile|Android|iPhone/i.test(navigator.userAgent)
  
  return {
    'X-Client-Type': isMobile ? 'mobile' : 'desktop',
    'X-Screen-Size': `${window.innerWidth}x${window.innerHeight}`
  }
}

axios.get('/api/content', {
  headers: {
    ...getDeviceHeaders(),  // 动态设备信息
    'Accept': 'application/json'
  }
})
```

### 6.3 拦截器中的动态设置


```javascript
// 🚀 最强大的方式：请求拦截器动态设置
axios.interceptors.request.use(config => {
  // 动态添加时间戳
  config.headers['X-Timestamp'] = Date.now()
  
  // 动态添加请求ID（用于追踪）
  config.headers['X-Request-ID'] = generateRequestId()
  
  // 动态添加用户信息
  const user = getCurrentUser()
  if (user) {
    config.headers['X-User-ID'] = user.id
    config.headers['X-User-Role'] = user.role
  }
  
  return config
})

function generateRequestId() {
  return 'req_' + Math.random().toString(36).substr(2, 9)
}
```

---

## 7. 🏆 请求头优先级规则


### 7.1 优先级理解


**生活比喻**：公司制度的优先级📋

```
公司规则优先级：
1. 临时通知（最高优先级）    ← 具体请求的headers
2. 部门制度（中等优先级）    ← 实例的默认headers  
3. 公司制度（基础优先级）    ← 全局的defaults.headers

如果有冲突，临时通知 > 部门制度 > 公司制度
```

### 7.2 axios中的优先级顺序


```javascript
// 🎯 优先级：请求级 > 实例级 > 全局级

// 1. 全局设置（最低优先级）
axios.defaults.headers.common['Authorization'] = 'Bearer global-token'

// 2. 实例设置（中等优先级）
const apiClient = axios.create({
  headers: { 'Authorization': 'Bearer instance-token' }
})

// 3. 请求设置（最高优先级）
apiClient.get('/api/data', {
  headers: { 'Authorization': 'Bearer request-token' }
})

// 🔍 最终结果：使用 'Bearer request-token'
```

### 7.3 优先级实战示例


```javascript
// 🧪 测试优先级的完整示例
axios.defaults.headers.common['X-Version'] = '1.0'      // 全局
axios.defaults.headers.common['X-Client'] = 'web'       // 全局

const api = axios.create({
  headers: {
    'X-Version': '2.0',     // 覆盖全局的X-Version
    'X-Source': 'api'       // 新增字段
  }
})

api.get('/test', {
  headers: {
    'X-Version': '3.0',     // 覆盖实例的X-Version
    'X-Request': 'special'  // 新增字段
  }
})

// 🎯 最终请求头：
// X-Version: '3.0'     ← 请求级覆盖
// X-Client: 'web'      ← 全局级保留
// X-Source: 'api'      ← 实例级保留  
// X-Request: 'special' ← 请求级新增
```

**💡 记忆口诀**：**近的优先，远的补充**
- 近的设置（请求级）优先级高
- 远的设置（全局级）作为补充

---

## 8. 🎯 Token认证实战


### 8.1 完整的Token认证流程


```
用户认证流程图：

用户登录
    ↓
输入账号密码
    ↓
发送到后端验证
    ↓
后端返回Token
    ↓
前端保存Token
    ↓
后续请求都带上Token
    ↓
Token过期？
├─ 是 → 刷新Token或重新登录
└─ 否 → 继续使用
```

### 8.2 Token管理的最佳实践


```javascript
// 🛡️ Token管理器
class TokenManager {
  constructor() {
    this.tokenKey = 'auth_token'
    this.refreshKey = 'refresh_token'
  }
  
  // 保存Token
  saveToken(token, refreshToken) {
    localStorage.setItem(this.tokenKey, token)
    if (refreshToken) {
      localStorage.setItem(this.refreshKey, refreshToken)
    }
  }
  
  // 获取Token
  getToken() {
    return localStorage.getItem(this.tokenKey)
  }
  
  // 清除Token
  clearToken() {
    localStorage.removeItem(this.tokenKey)
    localStorage.removeItem(this.refreshKey)
  }
  
  // 检查Token是否存在
  hasToken() {
    return !!this.getToken()
  }
}

const tokenManager = new TokenManager()
```

### 8.3 自动Token注入


```javascript
// 🚀 设置请求拦截器，自动注入Token
axios.interceptors.request.use(
  config => {
    const token = tokenManager.getToken()
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    return config
  },
  error => Promise.reject(error)
)

// 🔄 设置响应拦截器，处理Token过期
axios.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 401) {
      // Token过期，清除并跳转登录
      tokenManager.clearToken()
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)
```

### 8.4 实际使用示例


```javascript
// 🎯 登录获取Token
async function login(username, password) {
  try {
    const response = await axios.post('/api/login', {
      username,
      password
    })
    
    const { token, refreshToken } = response.data
    
    // 保存Token
    tokenManager.saveToken(token, refreshToken)
    
    console.log('登录成功！')
    return true
  } catch (error) {
    console.error('登录失败:', error.message)
    return false
  }
}

// 🎯 使用Token访问受保护的API
async function getUserProfile() {
  try {
    // 不需要手动设置Authorization，拦截器会自动添加
    const response = await axios.get('/api/profile')
    return response.data
  } catch (error) {
    console.error('获取用户信息失败:', error.message)
    throw error
  }
}

// 🎯 退出登录
function logout() {
  tokenManager.clearToken()
  window.location.href = '/login'
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 请求头本质：给服务器的说明书，告诉服务器如何处理请求
🔸 Authorization：身份认证头，证明你有权限访问
🔸 Content-Type：内容类型头，告诉服务器你发送的数据格式
🔸 动态设置：根据实际情况智能设置请求头
🔸 优先级规则：请求级 > 实例级 > 全局级
🔸 Token认证：现代Web应用的标准认证方式
```

### 9.2 关键理解要点


**🔹 请求头的生活化理解**
```
请求头 = 快递标签
- Authorization = 身份证（证明身份）
- Content-Type = 内容物标签（说明格式）
- Accept = 购物清单（想要什么）
- 自定义头 = 特殊说明（业务需求）
```

**🔹 Token认证的核心流程**
```
登录 → 获取Token → 保存Token → 自动注入 → 过期处理
```

**🔹 动态设置的价值**
```
静态设置：一成不变，不够灵活
动态设置：智能适应，用户体验更好
```

### 9.3 实际应用价值


- **🔐 身份认证**：通过Authorization头实现用户身份验证
- **📄 数据格式**：通过Content-Type确保数据正确传输
- **🎯 个性化**：通过自定义头实现业务个性化需求
- **🚀 自动化**：通过拦截器实现头部自动管理
- **🛡️ 安全性**：通过Token机制保护API安全

### 9.4 最佳实践总结


```
✅ 推荐做法：
- 使用拦截器自动管理Token
- 遵循请求头命名规范（X-开头）
- 根据业务需求动态设置头部
- 设置合理的优先级策略

❌ 避免做法：
- 在每个请求中重复设置相同头部
- 使用不规范的自定义头部名称
- 忽略Token过期处理
- 在URL中传递敏感信息
```

**核心记忆**：
- 请求头是给服务器的说明书📋
- Authorization是你的身份证🆔
- Content-Type是包裹标签📦
- 动态设置让应用更智能🧠
- Token认证是现代标准🔐