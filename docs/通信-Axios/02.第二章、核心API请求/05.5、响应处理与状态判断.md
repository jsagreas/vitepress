---
title: 5、响应处理与状态判断
---
## 📚 目录

1. [响应对象结构详解](#1-响应对象结构详解)
2. [获取真正的数据](#2-获取真正的数据)
3. [状态码判断与处理](#3-状态码判断与处理)
4. [链式调用处理](#4-链式调用处理)
5. [数据显示到页面](#5-数据显示到页面)
6. [错误处理机制](#6-错误处理机制)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📦 响应对象结构详解


### 1.1 什么是响应对象

**通俗理解**：当你用axios发送请求后，服务器会返回一个"包裹"，这个包裹就是响应对象(response)，里面装着你要的数据和一些额外信息。

```javascript
// 发送请求后得到的response对象结构
axios.get('https://api.example.com/users')
  .then(response => {
    console.log(response); // 这就是完整的响应对象
  });

// response对象包含以下主要属性：
{
  data: {...},           // 🎯 真正的数据（最重要）
  status: 200,           // 🔢 HTTP状态码
  statusText: 'OK',      // 📝 状态描述
  headers: {...},        // 📋 响应头信息
  config: {...},         // ⚙️ 请求配置信息
  request: {...}         // 📡 请求对象信息
}
```

### 1.2 响应对象各部分详解


**🎯 data - 核心数据**
```javascript
// 这是你真正需要的数据
response.data  // 用户信息、商品列表等业务数据

// 示例：获取用户列表
axios.get('/api/users').then(response => {
  const userList = response.data;  // 这里是用户数组
  console.log(userList);
});
```

**🔢 status - 状态码**
```javascript
// HTTP状态码，告诉你请求结果
response.status

// 常见状态码含义：
200 → 成功
404 → 找不到
500 → 服务器错误
```

**📋 headers - 响应头**
```javascript
// 服务器返回的额外信息
response.headers

// 常见的响应头：
{
  'content-type': 'application/json',  // 数据类型
  'content-length': '1234',            // 数据大小
  'date': 'Mon, 21 Jan 2025...'        // 响应时间
}
```

---

## 2. 🎯 获取真正的数据


### 2.1 为什么要用response.data


> 💡 **核心理解**：axios返回的response是一个"包装盒"，你要的数据在里面的data属性中

```javascript
// ❌ 错误做法 - 直接使用response
axios.get('/api/users').then(response => {
  console.log(response);  // 打印出来是整个对象，不是你要的数据
});

// ✅ 正确做法 - 使用response.data
axios.get('/api/users').then(response => {
  const users = response.data;  // 这才是用户数据
  console.log(users);
});
```

### 2.2 实际案例演示


```javascript
// 假设服务器返回的JSON数据：
// { "users": [{"name": "张三", "age": 25}, {"name": "李四", "age": 30}] }

axios.get('/api/users').then(response => {
  // response.data 就是上面的JSON对象
  const data = response.data;
  const userList = data.users;  // 获取用户数组
  
  console.log(userList);  // [{"name": "张三", "age": 25}, ...]
});

// 也可以直接解构获取
axios.get('/api/users').then(response => {
  const { users } = response.data;  // 直接解构出users数组
  console.log(users);
});
```

### 2.3 不同数据类型的处理


```javascript
// 1. JSON对象数据
axios.get('/api/user/1').then(response => {
  const user = response.data;  // { name: '张三', age: 25 }
});

// 2. 数组数据
axios.get('/api/users').then(response => {
  const users = response.data;  // [user1, user2, user3...]
});

// 3. 简单字符串或数字
axios.get('/api/count').then(response => {
  const count = response.data;  // 100
});
```

---

## 3. 🔍 状态码判断与处理


### 3.1 HTTP状态码基础知识


**什么是状态码**：服务器用数字告诉你请求的结果

```
📊 常见状态码分类：
┌─────────────────────────────────────┐
│ 2xx 成功类                          │
│ 200 → 请求成功                      │
│ 201 → 创建成功                      │
├─────────────────────────────────────┤
│ 4xx 客户端错误类                    │
│ 400 → 请求参数错误                  │
│ 401 → 未授权                        │
│ 404 → 找不到资源                    │
├─────────────────────────────────────┤
│ 5xx 服务器错误类                    │
│ 500 → 服务器内部错误                │
│ 502 → 网关错误                      │
└─────────────────────────────────────┘
```

### 3.2 状态码判断实践


```javascript
// 基础状态码判断
axios.get('/api/users').then(response => {
  if (response.status === 200) {
    console.log('请求成功！');
    const users = response.data;
    // 处理用户数据
  }
});

// 更完整的状态码处理
axios.get('/api/users').then(response => {
  switch (response.status) {
    case 200:
      console.log('获取成功');
      break;
    case 201:
      console.log('创建成功');
      break;
    default:
      console.log('其他成功状态:', response.status);
  }
});
```

### 3.3 业务状态vs HTTP状态


> ⚠️ **重要区别**：HTTP状态码 ≠ 业务状态码

```javascript
// HTTP状态码：200（请求成功到达服务器）
// 业务状态码：可能是失败的

axios.get('/api/login').then(response => {
  // HTTP状态：200 （请求成功）
  console.log(response.status);  // 200
  
  // 但业务可能失败
  const result = response.data;
  /*
  result 可能是：
  {
    code: 0,      // 业务状态码：0=成功，1=失败
    message: "登录失败，密码错误",
    data: null
  }
  */
  
  if (result.code === 0) {
    console.log('登录成功');
  } else {
    console.log('登录失败:', result.message);
  }
});
```

---

## 4. 🔗 链式调用处理


### 4.1 then/catch/finally基础


**通俗理解**：
- **then** → 成功时执行（相当于"如果成功了就..."）
- **catch** → 失败时执行（相当于"如果出错了就..."）
- **finally** → 无论成功失败都执行（相当于"不管怎样都要..."）

```javascript
axios.get('/api/users')
  .then(response => {
    // 成功时执行
    console.log('请求成功');
    return response.data;
  })
  .catch(error => {
    // 失败时执行
    console.log('请求失败');
  })
  .finally(() => {
    // 无论成功失败都执行
    console.log('请求结束');
  });
```

### 4.2 实际应用场景


```javascript
// 实际项目中的完整处理
function getUserList() {
  // 显示加载状态
  showLoading();
  
  axios.get('/api/users')
    .then(response => {
      // 处理成功响应
      const users = response.data;
      displayUsers(users);  // 显示用户列表
      showMessage('加载成功');
    })
    .catch(error => {
      // 处理错误
      showMessage('加载失败，请重试');
    })
    .finally(() => {
      // 隐藏加载状态
      hideLoading();
    });
}
```

### 4.3 链式调用的数据传递


```javascript
axios.get('/api/users')
  .then(response => {
    // 第一步：获取数据
    const users = response.data;
    console.log('获取到用户:', users.length);
    return users;  // 传递给下一个then
  })
  .then(users => {
    // 第二步：处理数据
    const activeUsers = users.filter(user => user.active);
    console.log('活跃用户:', activeUsers.length);
    return activeUsers;
  })
  .then(activeUsers => {
    // 第三步：显示数据
    displayUsers(activeUsers);
  })
  .catch(error => {
    console.log('任何一步出错都会到这里');
  });
```

---

## 5. 🖥️ 数据显示到页面


### 5.1 基础HTML结构


```html
<!-- HTML页面结构 -->
<div id="user-list">
  <!-- 用户列表将显示在这里 -->
</div>
<div id="loading" style="display:none;">加载中...</div>
<div id="error" style="display:none;">加载失败</div>
```

### 5.2 将数据渲染到页面


```javascript
// 获取用户数据并显示
function loadUsers() {
  // 显示加载状态
  document.getElementById('loading').style.display = 'block';
  
  axios.get('/api/users')
    .then(response => {
      const users = response.data;
      displayUsers(users);
    })
    .catch(error => {
      showError('加载用户失败');
    })
    .finally(() => {
      // 隐藏加载状态
      document.getElementById('loading').style.display = 'none';
    });
}

// 显示用户列表
function displayUsers(users) {
  const container = document.getElementById('user-list');
  
  // 清空容器
  container.innerHTML = '';
  
  // 遍历用户数据
  users.forEach(user => {
    const userDiv = document.createElement('div');
    userDiv.innerHTML = `
      <h3>${user.name}</h3>
      <p>年龄: ${user.age}</p>
      <p>邮箱: ${user.email}</p>
    `;
    container.appendChild(userDiv);
  });
}
```

### 5.3 JSON数据的实际使用


```javascript
// 假设API返回的JSON格式：
/*
{
  "code": 0,
  "message": "success",
  "data": {
    "users": [
      { "id": 1, "name": "张三", "age": 25 },
      { "id": 2, "name": "李四", "age": 30 }
    ],
    "total": 2
  }
}
*/

axios.get('/api/users').then(response => {
  const result = response.data;  // 整个JSON对象
  
  if (result.code === 0) {
    // 业务成功
    const users = result.data.users;  // 获取用户数组
    const total = result.data.total;   // 获取总数
    
    console.log(`共找到 ${total} 个用户`);
    displayUsers(users);
  } else {
    // 业务失败
    console.log('业务错误:', result.message);
  }
});
```

---

## 6. 🚨 错误处理机制


### 6.1 错误的类型


**错误分为三种情况**：
1. **网络错误** → 网络断了，服务器连不上
2. **HTTP错误** → 能连上服务器，但服务器返回错误状态码
3. **业务错误** → HTTP成功，但业务逻辑失败

```
错误处理流程：
┌─────────────────┐
│ 发送请求        │
├─────────────────┤
│ 网络是否正常？   │ → ❌ 网络错误
├─────────────────┤
│ HTTP状态码？     │ → ❌ HTTP错误 (4xx,5xx)
├─────────────────┤
│ 业务状态码？     │ → ❌ 业务错误
├─────────────────┤
│ ✅ 处理成功数据  │
└─────────────────┘
```

### 6.2 错误对象结构


```javascript
axios.get('/api/users').catch(error => {
  console.log('完整错误对象:', error);
  
  if (error.response) {
    // 🔴 服务器响应了，但状态码不是2xx
    console.log('响应数据:', error.response.data);
    console.log('状态码:', error.response.status);
    console.log('响应头:', error.response.headers);
  } else if (error.request) {
    // 🔴 请求发送了，但没有收到响应（网络问题）
    console.log('网络错误，无响应');
  } else {
    // 🔴 设置请求时出错
    console.log('请求配置错误:', error.message);
  }
});
```

### 6.3 实用的错误处理


```javascript
// 统一错误处理函数
function handleError(error) {
  if (error.response) {
    // HTTP错误
    const status = error.response.status;
    switch (status) {
      case 400:
        showMessage('请求参数错误');
        break;
      case 401:
        showMessage('未登录，请先登录');
        // 跳转到登录页
        break;
      case 404:
        showMessage('请求的资源不存在');
        break;
      case 500:
        showMessage('服务器错误，请稍后重试');
        break;
      default:
        showMessage(`请求失败 (${status})`);
    }
  } else if (error.request) {
    // 网络错误
    showMessage('网络连接失败，请检查网络');
  } else {
    // 其他错误
    showMessage('请求发送失败');
  }
}

// 使用统一错误处理
axios.get('/api/users')
  .then(response => {
    const users = response.data;
    displayUsers(users);
  })
  .catch(handleError);  // 使用统一错误处理
```

### 6.4 响应数据的错误处理


```javascript
// 完整的响应处理，包含业务错误
axios.get('/api/users')
  .then(response => {
    // HTTP请求成功
    const result = response.data;
    
    // 检查业务状态
    if (result.code === 0) {
      // 业务成功
      const users = result.data;
      displayUsers(users);
      showMessage('加载成功');
    } else {
      // 业务失败
      showMessage(result.message || '业务处理失败');
    }
  })
  .catch(error => {
    // HTTP请求失败
    handleError(error);
  });
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 响应对象：axios返回的"包装盒"，包含data、status等信息
🔸 response.data：真正需要的业务数据，最重要的属性
🔸 状态码：HTTP状态码判断请求结果，业务状态码判断业务结果
🔸 链式调用：then处理成功，catch处理失败，finally总是执行
🔸 错误类型：网络错误、HTTP错误、业务错误要分别处理
```

### 7.2 关键理解要点


**🔹 数据获取的正确姿势**
```javascript
// ✅ 正确：使用response.data获取真正的数据
const data = response.data;

// ❌ 错误：直接使用response
const data = response;  // 这是整个响应对象，不是你要的数据
```

**🔹 状态判断的层次**
```
第一层：HTTP状态码 (200, 404, 500...)
第二层：业务状态码 (通常在response.data.code中)
两层都要检查才算完整的错误处理
```

**🔹 错误处理的全面性**
```javascript
// 完整的错误处理应该包含：
1. 网络错误处理 (error.request)
2. HTTP错误处理 (error.response.status)  
3. 业务错误处理 (response.data.code)
```

### 7.3 实际应用要点


**📝 响应处理最佳实践**
- 始终使用`response.data`获取真正的数据
- HTTP成功不等于业务成功，要双重检查
- 使用`finally`处理清理工作（如隐藏loading）
- 统一封装错误处理函数，避免重复代码

**⚠️ 常见错误避免**
- 不要直接使用`response`当作数据
- 不要忽略业务状态码的检查
- 不要忘记处理网络错误的情况
- 不要在每个请求中重复写相同的错误处理逻辑

**🎯 核心记忆**
- response是包装盒，data是真正的货物
- HTTP状态看连接，业务状态看逻辑
- then成功catch失败，finally总执行
- 错误分三类，处理要全面