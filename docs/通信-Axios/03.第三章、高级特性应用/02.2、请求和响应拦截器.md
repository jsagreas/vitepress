---
title: 2、请求和响应拦截器
---
## 📚 目录

1. [拦截器是什么](#1-拦截器是什么)
2. [请求拦截器详解](#2-请求拦截器详解)
3. [响应拦截器详解](#3-响应拦截器详解)
4. [拦截器管理](#4-拦截器管理)
5. [实战应用场景](#5-实战应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 拦截器是什么


### 1.1 通俗理解拦截器

**拦截器就像是门卫**，在请求发出前和响应回来后进行统一处理。

```
你发请求 → 请求拦截器(门卫检查) → 服务器
你收响应 ← 响应拦截器(门卫处理) ← 服务器

就像：
你出门 → 门卫检查证件、登记 → 外面
你回家 ← 门卫确认身份、开门 ← 外面
```

### 1.2 拦截器解决的问题

**没有拦截器的痛苦**：
- 每个请求都要手动添加Token
- 每个请求都要手动显示Loading
- 每个响应都要手动判断登录状态
- 错误处理代码到处复制粘贴

**有了拦截器的好处**：
- ✅ **统一处理** - 写一次，全局生效
- ✅ **自动化** - 不用每次都记得加Token
- ✅ **维护简单** - 修改一处，全部更新

### 1.3 拦截器工作流程图


```
请求流程：
发起请求 → 请求拦截器1 → 请求拦截器2 → 发送到服务器
         ↑                                    ↓
    业务代码                              服务器响应
         ↑                                    ↓
接收响应 ← 响应拦截器1 ← 响应拦截器2 ← 收到服务器响应

执行顺序：
请求拦截器：后注册的先执行
响应拦截器：先注册的先执行
```

---

## 2. 🚀 请求拦截器详解


### 2.1 请求拦截器基本概念

**请求拦截器是做什么的？**
就是在你的请求发出去之前，自动帮你做一些处理，比如：
- 自动加上用户Token
- 显示Loading加载状态
- 统一设置请求头
- 添加时间戳防止缓存

### 2.2 基础使用方法


```javascript
// 添加请求拦截器
axios.interceptors.request.use(
  function (config) {
    // 在发送请求之前做些什么
    console.log('请求即将发出:', config);
    return config;
  },
  function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  }
);
```

### 2.3 实用功能实现


#### 🔐 自动添加Token


```javascript
// 每个请求自动带上用户Token
axios.interceptors.request.use(config => {
  // 从本地存储获取token
  const token = localStorage.getItem('userToken');
  
  if (token) {
    // 自动添加到请求头
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  return config;
});

// 现在所有请求都会自动带上Token，不用每次手动添加了！
axios.get('/api/user/info'); // 自动带Token
axios.post('/api/orders', data); // 自动带Token
```

#### ⏰ 添加时间戳防缓存


```javascript
axios.interceptors.request.use(config => {
  // GET请求添加时间戳，防止浏览器缓存
  if (config.method === 'get') {
    config.params = {
      ...config.params,
      _t: Date.now() // 添加时间戳
    };
  }
  
  return config;
});

// 原本: /api/users
// 实际发送: /api/users?_t=1691234567890
```

#### 🔄 全局Loading控制


```javascript
// 假设你有一个loading状态管理
let requestCount = 0;

axios.interceptors.request.use(config => {
  // 请求开始，显示loading
  requestCount++;
  if (requestCount === 1) {
    showLoading(); // 显示加载状态
  }
  
  return config;
});

// 响应拦截器中隐藏loading
axios.interceptors.response.use(
  response => {
    requestCount--;
    if (requestCount === 0) {
      hideLoading(); // 隐藏加载状态
    }
    return response;
  },
  error => {
    requestCount--;
    if (requestCount === 0) {
      hideLoading();
    }
    return Promise.reject(error);
  }
);
```

### 2.4 请求参数统一处理


```javascript
axios.interceptors.request.use(config => {
  // 统一设置请求头
  config.headers['Content-Type'] = 'application/json';
  config.headers['Accept'] = 'application/json';
  
  // POST请求数据预处理
  if (config.method === 'post' && config.data) {
    // 移除空值参数
    const cleanData = {};
    Object.keys(config.data).forEach(key => {
      if (config.data[key] !== '' && config.data[key] !== null) {
        cleanData[key] = config.data[key];
      }
    });
    config.data = cleanData;
  }
  
  return config;
});
```

---

## 3. 📥 响应拦截器详解


### 3.1 响应拦截器基本概念

**响应拦截器是做什么的？**
就是在服务器响应回来后，数据给到你的业务代码之前，自动帮你处理一些通用逻辑：
- 统一判断登录是否过期
- 统一处理错误信息
- 统一处理数据格式
- 自动跳转登录页

### 3.2 基础使用方法


```javascript
// 添加响应拦截器
axios.interceptors.response.use(
  function (response) {
    // 对响应数据做点什么
    console.log('收到响应:', response);
    return response;
  },
  function (error) {
    // 对响应错误做点什么
    console.error('响应错误:', error);
    return Promise.reject(error);
  }
);
```

### 3.3 实用功能实现


#### 🔐 自动处理登录过期


```javascript
axios.interceptors.response.use(
  response => {
    // 成功响应的处理
    const { code, message } = response.data;
    
    // 检查业务状态码
    if (code === 401) {
      // 登录过期，清除本地token
      localStorage.removeItem('userToken');
      // 跳转到登录页
      window.location.href = '/login';
      // 提示用户
      alert('登录已过期，请重新登录');
      return Promise.reject(new Error('登录过期'));
    }
    
    return response;
  },
  error => {
    // HTTP状态码错误处理
    if (error.response?.status === 401) {
      // 未授权，跳转登录
      localStorage.removeItem('userToken');
      window.location.href = '/login';
    }
    
    return Promise.reject(error);
  }
);
```

#### 📊 统一数据格式处理


```javascript
axios.interceptors.response.use(response => {
  const { code, data, message } = response.data;
  
  // 统一判断业务状态
  if (code === 200) {
    // 成功：直接返回数据部分
    return data;
  } else {
    // 失败：抛出错误，业务代码会进入catch
    throw new Error(message || '请求失败');
  }
});

// 使用效果对比：
// 没有拦截器：
axios.get('/api/users').then(res => {
  if (res.data.code === 200) {
    console.log(res.data.data); // 需要层层取值
  }
});

// 有拦截器：
axios.get('/api/users').then(data => {
  console.log(data); // 直接是用户数据
});
```

#### ⚠️ 统一错误处理和提示


```javascript
axios.interceptors.response.use(
  response => response,
  error => {
    let errorMessage = '请求失败';
    
    if (error.response) {
      // 服务器返回错误状态码
      const { status, data } = error.response;
      
      switch (status) {
        case 400:
          errorMessage = data.message || '请求参数错误';
          break;
        case 401:
          errorMessage = '未授权，请登录';
          // 跳转登录
          window.location.href = '/login';
          break;
        case 403:
          errorMessage = '权限不足';
          break;
        case 404:
          errorMessage = '请求的资源不存在';
          break;
        case 500:
          errorMessage = '服务器内部错误';
          break;
        default:
          errorMessage = data.message || `请求失败(${status})`;
      }
    } else if (error.request) {
      // 网络错误
      errorMessage = '网络连接失败，请检查网络';
    }
    
    // 全局错误提示（可以用UI库的提示组件）
    alert(errorMessage); // 实际项目中用更好看的提示
    
    return Promise.reject(error);
  }
);
```

---

## 4. 🔧 拦截器管理


### 4.1 移除拦截器


```javascript
// 添加拦截器时会返回一个ID
const requestInterceptor = axios.interceptors.request.use(config => {
  return config;
});

const responseInterceptor = axios.interceptors.response.use(response => {
  return response;
});

// 移除拦截器
axios.interceptors.request.eject(requestInterceptor);
axios.interceptors.response.eject(responseInterceptor);
```

### 4.2 多个拦截器的执行顺序


```javascript
// 请求拦截器：后注册的先执行（栈的概念）
axios.interceptors.request.use(config => {
  console.log('请求拦截器1'); // 第二个执行
  return config;
});

axios.interceptors.request.use(config => {
  console.log('请求拦截器2'); // 第一个执行
  return config;
});

// 响应拦截器：先注册的先执行（队列的概念）
axios.interceptors.response.use(response => {
  console.log('响应拦截器1'); // 第一个执行
  return response;
});

axios.interceptors.response.use(response => {
  console.log('响应拦截器2'); // 第二个执行
  return response;
});
```

---

## 5. 🎯 实战应用场景


### 5.1 完整的项目拦截器配置


```javascript
// api.js - 项目中的axios配置文件
import axios from 'axios';

// 创建axios实例
const api = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000
});

// 请求拦截器
api.interceptors.request.use(
  config => {
    // 1. 自动添加Token
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    // 2. 添加时间戳防缓存
    if (config.method === 'get') {
      config.params = { ...config.params, _t: Date.now() };
    }
    
    // 3. 显示loading
    showLoading();
    
    return config;
  },
  error => {
    hideLoading();
    return Promise.reject(error);
  }
);

// 响应拦截器
api.interceptors.response.use(
  response => {
    hideLoading();
    
    const { code, data, message } = response.data;
    
    // 业务状态码判断
    if (code === 200) {
      return data; // 直接返回数据
    } else if (code === 401) {
      // 登录过期
      localStorage.removeItem('token');
      window.location.href = '/login';
      throw new Error('登录已过期');
    } else {
      throw new Error(message || '请求失败');
    }
  },
  error => {
    hideLoading();
    
    // 网络错误处理
    let message = '请求失败';
    if (error.response) {
      message = error.response.data?.message || `HTTP ${error.response.status}`;
    } else {
      message = '网络连接失败';
    }
    
    // 全局错误提示
    showError(message);
    
    return Promise.reject(error);
  }
);

export default api;
```

### 5.2 在Vue项目中的使用


```javascript
// main.js
import api from './utils/api.js';

// 挂载到Vue原型，方便在组件中使用
Vue.prototype.$api = api;

// 组件中使用
export default {
  methods: {
    async fetchUserInfo() {
      try {
        // 不需要手动处理token、loading、错误等
        const userInfo = await this.$api.get('/user/info');
        this.userInfo = userInfo;
      } catch (error) {
        // 错误已经在拦截器中统一处理了
        console.log('获取用户信息失败');
      }
    }
  }
}
```

### 5.3 拦截器的实际效果对比


| 功能 | **没有拦截器** | **有拦截器** |
|------|-------------|------------|
| **添加Token** | `每个请求手动添加` | `自动添加，一次配置` |
| **Loading状态** | `每个请求手动控制` | `自动显示/隐藏` |
| **错误处理** | `每个地方都要写` | `统一处理，代码简洁` |
| **登录过期** | `到处判断跳转` | `自动检测跳转` |
| **数据格式** | `层层取值res.data.data` | `直接获取data` |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 拦截器本质：请求前和响应后的统一处理器
🔸 请求拦截器：发请求前自动执行，用于添加token、参数处理
🔸 响应拦截器：收到响应后自动执行，用于错误处理、数据格式化
🔸 执行顺序：请求拦截器后进先出，响应拦截器先进先出
🔸 实用价值：代码复用、统一管理、提升开发效率
```

### 6.2 关键理解要点


**🔹 拦截器解决了什么问题**
```
没有拦截器：
- 重复代码多：每个请求都要写相同逻辑
- 维护困难：修改一个功能要改很多地方
- 容易遗漏：忘记加token、忘记处理错误

有了拦截器：
- 写一次用处处：统一配置全局生效
- 维护简单：修改一处全部更新
- 自动化：不会遗漏任何处理
```

**🔹 什么时候用拦截器**
```
适合用拦截器的场景：
✅ 所有请求都需要的处理（如添加token）
✅ 通用的错误处理逻辑
✅ 统一的数据格式转换
✅ 全局的loading控制

不适合用拦截器：
❌ 只有个别请求需要的特殊处理
❌ 复杂的业务逻辑判断
❌ 与具体页面强相关的处理
```

**🔹 拦截器的最佳实践**
```
请求拦截器常用功能：
- 自动添加用户Token
- 统一设置请求头
- 添加时间戳防缓存
- 显示全局loading

响应拦截器常用功能：
- 统一错误处理和提示
- 自动处理登录过期
- 统一数据格式处理
- 隐藏全局loading
```

### 6.3 实际应用价值


**🎯 开发效率提升**
- **减少重复代码**：不用每个请求都写相同逻辑
- **统一管理**：所有HTTP相关处理集中配置
- **自动化处理**：token、loading、错误处理全自动

**🔧 代码质量提升**
- **一致性**：所有请求的处理方式统一
- **可维护性**：修改HTTP处理逻辑只需改一处
- **可靠性**：不会遗漏token添加或错误处理

**💡 用户体验提升**
- **自动loading**：用户清楚知道请求状态
- **友好错误提示**：统一的错误信息展示
- **无感知token**：登录后所有请求自动带token

**核心记忆**：
- 拦截器是HTTP请求的"门卫"和"管家"  
- 请求拦截器负责"出门前检查"，响应拦截器负责"回来后处理"
- 一次配置，全局生效，让重复的事情自动化
- 提升开发效率，改善用户体验，是现代前端项目的必备配置