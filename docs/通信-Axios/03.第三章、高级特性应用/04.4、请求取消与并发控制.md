---
title: 4、请求取消与并发控制
---
## 📚 目录

1. [请求取消的必要性](#1-请求取消的必要性)
2. [现代方式：AbortController](#2-现代方式abortcontroller)
3. [传统方式：CancelToken](#3-传统方式canceltoken)
4. [取消请求的错误处理](#4-取消请求的错误处理)
5. [实际应用场景](#5-实际应用场景)
6. [并发请求处理](#6-并发请求处理)
7. [请求队列管理](#7-请求队列管理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚨 请求取消的必要性


### 1.1 为什么需要取消请求


**问题场景**：想象你在使用搜索功能时，快速输入了几个字符...

```
用户体验问题：
输入: "vue" → 发送请求A
输入: "vuex" → 发送请求B  
输入: "vuex教程" → 发送请求C

如果不取消前面的请求：
- 请求A返回"vue"的结果 ❌ 
- 请求B返回"vuex"的结果 ❌
- 请求C返回"vuex教程"的结果 ✅ 正确

结果：页面显示错误的搜索结果！
```

**核心问题**：
- 📡 **网络浪费**：无用的请求占用带宽
- 🎯 **结果错乱**：后发的请求可能先返回
- 💸 **资源浪费**：服务器处理无意义的请求
- 🐛 **内存泄漏**：组件卸载后请求仍在进行

### 1.2 什么时候需要取消请求


```
常见场景总结：

🔍 搜索场景：
用户快速输入 → 取消上一次搜索

🚀 页面跳转：
离开页面时 → 取消所有未完成请求

🔄 重复点击：
防止用户重复提交表单

💀 组件销毁：
React/Vue组件卸载时取消请求

⏱️ 超时控制：
请求时间过长主动取消
```

---

## 2. 🆕 现代方式：AbortController


### 2.1 AbortController 是什么


**简单理解**：AbortController 就像遥控器的"停止"按钮，可以随时停止正在进行的请求。

```javascript
// 创建一个"遥控器"
const controller = new AbortController();

// 按下"停止"按钮
controller.abort();
```

### 2.2 基本使用方法


**🔸 基础用法**
```javascript
// 1. 创建控制器
const controller = new AbortController();

// 2. 发送请求时传入信号
axios.get('/api/data', {
  signal: controller.signal  // 就像给请求装上"遥控接收器"
})
.then(response => {
  console.log('请求成功:', response.data);
})
.catch(error => {
  if (error.name === 'AbortError') {
    console.log('请求被取消了');
  } else {
    console.log('其他错误:', error.message);
  }
});

// 3. 需要时取消请求
setTimeout(() => {
  controller.abort(); // 3秒后取消请求
}, 3000);
```

### 2.3 搜索框取消示例


**完整的搜索取消实现**：
```javascript
class SearchManager {
  constructor() {
    this.currentController = null; // 保存当前请求的"遥控器"
  }
  
  async search(keyword) {
    // 如果有正在进行的请求，先取消它
    if (this.currentController) {
      this.currentController.abort();
      console.log('取消了上一次搜索');
    }
    
    // 创建新的控制器
    this.currentController = new AbortController();
    
    try {
      const response = await axios.get('/api/search', {
        params: { q: keyword },
        signal: this.currentController.signal
      });
      
      console.log('搜索结果:', response.data);
      this.currentController = null; // 请求完成，清空控制器
      
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('搜索被取消');
      } else {
        console.error('搜索失败:', error.message);
      }
    }
  }
}

// 使用示例
const searchManager = new SearchManager();

// 模拟用户快速输入
searchManager.search('vue');     // 第1次搜索
searchManager.search('vuex');    // 第2次搜索，会取消第1次
searchManager.search('vuex教程'); // 第3次搜索，会取消第2次
```

### 2.4 Vue组件中的实际应用


```javascript
// Vue 3 组合式API示例
import { ref, onUnmounted } from 'vue';
import axios from 'axios';

export default {
  setup() {
    const searchResults = ref([]);
    const loading = ref(false);
    let searchController = null;
    
    // 搜索函数
    const handleSearch = async (keyword) => {
      // 取消上一次搜索
      if (searchController) {
        searchController.abort();
      }
      
      // 创建新的控制器
      searchController = new AbortController();
      loading.value = true;
      
      try {
        const response = await axios.get('/api/search', {
          params: { q: keyword },
          signal: searchController.signal
        });
        
        searchResults.value = response.data;
        
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('搜索失败:', error.message);
        }
      } finally {
        loading.value = false;
        searchController = null;
      }
    };
    
    // 组件销毁时取消请求
    onUnmounted(() => {
      if (searchController) {
        searchController.abort();
      }
    });
    
    return {
      searchResults,
      loading,
      handleSearch
    };
  }
};
```

---

## 3. 🗂️ 传统方式：CancelToken


### 3.1 CancelToken 是什么


> ⚠️ **注意**：CancelToken 在 Axios v0.22+ 中已被废弃，推荐使用 AbortController

**理解**：CancelToken 是 Axios 早期提供的取消请求方案，功能类似 AbortController。

### 3.2 基本使用方法


**🔸 方式一：使用 CancelToken.source()**
```javascript
// 创建取消令牌
const source = axios.CancelToken.source();

// 发送请求
axios.get('/api/data', {
  cancelToken: source.token  // 传入取消令牌
})
.then(response => {
  console.log('请求成功:', response.data);
})
.catch(error => {
  if (axios.isCancel(error)) {
    console.log('请求被取消:', error.message);
  } else {
    console.log('其他错误:', error.message);
  }
});

// 取消请求
source.cancel('用户取消了操作');
```

**🔸 方式二：使用构造函数**
```javascript
let cancelFunction;

axios.get('/api/data', {
  cancelToken: new axios.CancelToken(function(cancel) {
    cancelFunction = cancel; // 保存取消函数
  })
})
.then(response => {
  console.log('请求成功:', response.data);
})
.catch(error => {
  if (axios.isCancel(error)) {
    console.log('请求被取消:', error.message);
  }
});

// 取消请求
cancelFunction('不需要这个请求了');
```

### 3.3 新旧方式对比


| 特性 | AbortController | CancelToken |
|------|----------------|-------------|
| **标准** | `W3C标准，现代浏览器原生支持` | `Axios专有方案` |
| **状态** | `✅ 推荐使用` | `❌ 已废弃` |
| **兼容性** | `现代浏览器` | `所有版本Axios` |
| **学习成本** | `更通用，其他库也支持` | `只适用于Axios` |

---

## 4. 🛠️ 取消请求的错误处理


### 4.1 识别取消错误


**判断请求是否被取消**：
```javascript
// AbortController 方式
try {
  const response = await axios.get('/api/data', {
    signal: controller.signal
  });
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('✅ 这是取消操作，不是真正的错误');
  } else {
    console.error('❌ 这是真正的网络错误');
  }
}

// CancelToken 方式 (旧版)
try {
  const response = await axios.get('/api/data', {
    cancelToken: source.token
  });
} catch (error) {
  if (axios.isCancel(error)) {
    console.log('✅ 请求被取消');
  } else {
    console.error('❌ 网络错误');
  }
}
```

### 4.2 统一错误处理


```javascript
// 封装统一的错误处理函数
function handleRequestError(error, operation = '请求') {
  if (error.name === 'AbortError') {
    console.log(`${operation}被用户取消`);
    return { type: 'cancel' };
  }
  
  if (error.response) {
    console.error(`${operation}失败:`, error.response.status);
    return { type: 'http', status: error.response.status };
  }
  
  if (error.request) {
    console.error(`${operation}超时或网络问题`);
    return { type: 'network' };
  }
  
  console.error(`${operation}配置错误:`, error.message);
  return { type: 'config', message: error.message };
}

// 使用示例
try {
  const response = await axios.get('/api/users');
} catch (error) {
  const errorInfo = handleRequestError(error, '获取用户列表');
  
  if (errorInfo.type !== 'cancel') {
    // 只有非取消错误才需要提示用户
    showErrorMessage('获取数据失败，请重试');
  }
}
```

---

## 5. 🎯 实际应用场景


### 5.1 搜索框防抖 + 取消


**完整的搜索框实现**：
```javascript
class SmartSearch {
  constructor(searchFn, delay = 300) {
    this.searchFn = searchFn;
    this.delay = delay;
    this.timer = null;
    this.controller = null;
  }
  
  // 防抖 + 取消的智能搜索
  search(keyword) {
    // 清除之前的定时器
    if (this.timer) {
      clearTimeout(this.timer);
    }
    
    // 取消正在进行的请求
    if (this.controller) {
      this.controller.abort();
    }
    
    // 设置新的定时器
    this.timer = setTimeout(async () => {
      if (!keyword.trim()) return;
      
      this.controller = new AbortController();
      
      try {
        await this.searchFn(keyword, this.controller.signal);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('搜索出错:', error.message);
        }
      }
    }, this.delay);
  }
  
  // 清理资源
  destroy() {
    if (this.timer) clearTimeout(this.timer);
    if (this.controller) this.controller.abort();
  }
}

// 使用示例
const smartSearch = new SmartSearch(async (keyword, signal) => {
  const response = await axios.get('/api/search', {
    params: { q: keyword },
    signal
  });
  
  updateSearchResults(response.data);
}, 500);

// 绑定输入框
document.getElementById('search-input').addEventListener('input', (e) => {
  smartSearch.search(e.target.value);
});
```

### 5.2 页面跳转取消请求


```javascript
// 路由守卫中取消请求
class RequestManager {
  constructor() {
    this.pendingRequests = new Set(); // 保存所有进行中的请求
  }
  
  // 创建可取消的请求
  createRequest(config) {
    const controller = new AbortController();
    const requestPromise = axios({
      ...config,
      signal: controller.signal
    });
    
    // 添加到待处理列表
    this.pendingRequests.add(controller);
    
    // 请求完成后移除
    requestPromise.finally(() => {
      this.pendingRequests.delete(controller);
    });
    
    return requestPromise;
  }
  
  // 取消所有请求
  cancelAllRequests() {
    console.log(`取消 ${this.pendingRequests.size} 个待处理请求`);
    
    this.pendingRequests.forEach(controller => {
      controller.abort();
    });
    
    this.pendingRequests.clear();
  }
}

// 全局实例
const requestManager = new RequestManager();

// Vue Router 使用示例
router.beforeEach((to, from, next) => {
  // 页面跳转时取消所有请求
  requestManager.cancelAllRequests();
  next();
});

// 使用示例
async function loadUserData() {
  try {
    const response = await requestManager.createRequest({
      method: 'get',
      url: '/api/user/profile'
    });
    
    console.log('用户数据:', response.data);
  } catch (error) {
    if (error.name !== 'AbortError') {
      console.error('加载失败:', error.message);
    }
  }
}
```

### 5.3 防止重复提交


```javascript
// 防重复提交的表单处理
class FormSubmitter {
  constructor() {
    this.submitting = false;
    this.controller = null;
  }
  
  async submit(formData) {
    // 如果正在提交，取消上一次提交
    if (this.submitting) {
      console.log('检测到重复提交，取消上一次请求');
      if (this.controller) {
        this.controller.abort();
      }
    }
    
    this.submitting = true;
    this.controller = new AbortController();
    
    try {
      const response = await axios.post('/api/submit', formData, {
        signal: this.controller.signal
      });
      
      console.log('提交成功:', response.data);
      return response.data;
      
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('提交被取消');
      } else {
        console.error('提交失败:', error.message);
        throw error;
      }
    } finally {
      this.submitting = false;
      this.controller = null;
    }
  }
}

// 使用示例
const formSubmitter = new FormSubmitter();

document.getElementById('submit-btn').addEventListener('click', async () => {
  const formData = new FormData(document.getElementById('my-form'));
  
  try {
    await formSubmitter.submit(formData);
    showSuccessMessage('提交成功！');
  } catch (error) {
    showErrorMessage('提交失败，请重试');
  }
});
```

---

## 6. 🔄 并发请求处理


### 6.1 什么是并发请求


**理解并发请求**：同时发送多个请求，而不是一个接一个地发送。

```
串行请求 (慢):
请求A → 等待 → 请求B → 等待 → 请求C
总时间: 3秒 + 2秒 + 1秒 = 6秒

并发请求 (快):
请求A ↘
请求B → 同时发送 → 等待最慢的
请求C ↗
总时间: max(3秒, 2秒, 1秒) = 3秒
```

### 6.2 使用 Promise.all() 处理并发


**🔸 基础并发请求**
```javascript
// 同时获取用户信息、订单列表、通知消息
async function loadDashboardData() {
  try {
    console.log('开始加载面板数据...');
    
    // 同时发送3个请求
    const [userResponse, ordersResponse, notificationsResponse] = await Promise.all([
      axios.get('/api/user/profile'),
      axios.get('/api/orders'),
      axios.get('/api/notifications')
    ]);
    
    console.log('所有数据加载完成');
    
    return {
      user: userResponse.data,
      orders: ordersResponse.data,
      notifications: notificationsResponse.data
    };
    
  } catch (error) {
    console.error('加载数据失败:', error.message);
    throw error;
  }
}

// 使用示例
loadDashboardData()
  .then(data => {
    updateUserInfo(data.user);
    updateOrdersList(data.orders);
    updateNotifications(data.notifications);
  })
  .catch(error => {
    showErrorMessage('数据加载失败');
  });
```

### 6.3 带取消功能的并发请求


```javascript
// 可取消的并发请求管理器
class ConcurrentRequestManager {
  constructor() {
    this.controllers = [];
  }
  
  // 执行多个并发请求
  async executeAll(requestConfigs) {
    // 为每个请求创建控制器
    this.controllers = requestConfigs.map(() => new AbortController());
    
    try {
      // 创建带取消功能的请求
      const requests = requestConfigs.map((config, index) => 
        axios({
          ...config,
          signal: this.controllers[index].signal
        })
      );
      
      // 等待所有请求完成
      const responses = await Promise.all(requests);
      
      console.log('所有并发请求完成');
      return responses.map(response => response.data);
      
    } catch (error) {
      // 如果有一个请求失败，取消其他所有请求
      this.cancelAll();
      
      if (error.name === 'AbortError') {
        console.log('并发请求被取消');
      } else {
        console.error('并发请求失败:', error.message);
      }
      
      throw error;
    }
  }
  
  // 取消所有请求
  cancelAll() {
    this.controllers.forEach(controller => {
      controller.abort();
    });
    this.controllers = [];
  }
}

// 使用示例
const concurrentManager = new ConcurrentRequestManager();

async function loadPageData() {
  const requestConfigs = [
    { method: 'get', url: '/api/user' },
    { method: 'get', url: '/api/posts' },
    { method: 'get', url: '/api/comments' }
  ];
  
  try {
    const [userData, postsData, commentsData] = await concurrentManager.executeAll(requestConfigs);
    
    return { userData, postsData, commentsData };
    
  } catch (error) {
    console.error('页面数据加载失败');
    return null;
  }
}

// 页面离开时取消请求
window.addEventListener('beforeunload', () => {
  concurrentManager.cancelAll();
});
```

### 6.4 批量文件上传示例


```javascript
// 批量上传文件管理器
class BatchUploader {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent; // 最大并发数
    this.queue = [];         // 待上传队列
    this.uploading = [];     // 正在上传的文件
    this.completed = [];     // 已完成的文件
    this.controllers = new Map(); // 每个文件的控制器
  }
  
  // 添加文件到上传队列
  addFiles(files) {
    const fileItems = Array.from(files).map(file => ({
      id: Date.now() + Math.random(),
      file,
      status: 'pending', // pending, uploading, completed, error, cancelled
      progress: 0
    }));
    
    this.queue.push(...fileItems);
    this.processQueue();
  }
  
  // 处理上传队列
  async processQueue() {
    while (this.queue.length > 0 && this.uploading.length < this.maxConcurrent) {
      const fileItem = this.queue.shift();
      this.uploadFile(fileItem);
    }
  }
  
  // 上传单个文件
  async uploadFile(fileItem) {
    const controller = new AbortController();
    this.controllers.set(fileItem.id, controller);
    
    fileItem.status = 'uploading';
    this.uploading.push(fileItem);
    
    try {
      const formData = new FormData();
      formData.append('file', fileItem.file);
      
      const response = await axios.post('/api/upload', formData, {
        signal: controller.signal,
        onUploadProgress: (progressEvent) => {
          fileItem.progress = Math.round(
            (progressEvent.loaded * 100) / progressEvent.total
          );
          this.updateProgress(fileItem);
        }
      });
      
      fileItem.status = 'completed';
      fileItem.response = response.data;
      this.completed.push(fileItem);
      
      console.log(`文件 ${fileItem.file.name} 上传成功`);
      
    } catch (error) {
      if (error.name === 'AbortError') {
        fileItem.status = 'cancelled';
        console.log(`文件 ${fileItem.file.name} 上传被取消`);
      } else {
        fileItem.status = 'error';
        fileItem.error = error.message;
        console.error(`文件 ${fileItem.file.name} 上传失败:`, error.message);
      }
    } finally {
      // 从上传中列表移除
      this.uploading = this.uploading.filter(item => item.id !== fileItem.id);
      this.controllers.delete(fileItem.id);
      
      // 继续处理队列
      this.processQueue();
    }
  }
  
  // 取消指定文件上传
  cancelUpload(fileId) {
    const controller = this.controllers.get(fileId);
    if (controller) {
      controller.abort();
    }
  }
  
  // 取消所有上传
  cancelAll() {
    this.controllers.forEach(controller => {
      controller.abort();
    });
    this.queue = [];
  }
  
  // 更新进度回调
  updateProgress(fileItem) {
    console.log(`${fileItem.file.name}: ${fileItem.progress}%`);
  }
}

// 使用示例
const uploader = new BatchUploader(2); // 最多同时上传2个文件

document.getElementById('file-input').addEventListener('change', (e) => {
  uploader.addFiles(e.target.files);
});

// 取消所有上传
document.getElementById('cancel-all').addEventListener('click', () => {
  uploader.cancelAll();
});
```

---

## 7. 📋 请求队列管理


### 7.1 限制并发数量


**为什么需要限制并发**：
- 🌐 **浏览器限制**：同域名最多6个并发连接
- 🖥️ **服务器压力**：避免瞬间大量请求
- 💾 **内存管理**：控制客户端内存使用

```javascript
// 并发请求队列管理器
class RequestQueue {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.queue = [];           // 等待队列
    this.running = [];         // 正在执行的请求
    this.completed = [];       // 已完成的请求
  }
  
  // 添加请求到队列
  add(requestConfig) {
    return new Promise((resolve, reject) => {
      const requestItem = {
        id: Date.now() + Math.random(),
        config: requestConfig,
        resolve,
        reject,
        controller: new AbortController()
      };
      
      this.queue.push(requestItem);
      this.process();
    });
  }
  
  // 处理队列
  async process() {
    // 如果达到最大并发数，等待
    if (this.running.length >= this.maxConcurrent) {
      return;
    }
    
    // 如果队列为空，结束
    if (this.queue.length === 0) {
      return;
    }
    
    // 取出一个请求执行
    const requestItem = this.queue.shift();
    this.running.push(requestItem);
    
    try {
      console.log(`开始执行请求 ${requestItem.id}, 当前并发: ${this.running.length}`);
      
      const response = await axios({
        ...requestItem.config,
        signal: requestItem.controller.signal
      });
      
      requestItem.resolve(response);
      this.completed.push(requestItem);
      
    } catch (error) {
      requestItem.reject(error);
    } finally {
      // 从运行队列中移除
      this.running = this.running.filter(item => item.id !== requestItem.id);
      
      console.log(`请求 ${requestItem.id} 完成, 剩余并发: ${this.running.length}`);
      
      // 继续处理下一个请求
      setTimeout(() => this.process(), 0);
    }
  }
  
  // 取消所有请求
  cancelAll() {
    // 取消正在运行的请求
    this.running.forEach(item => {
      item.controller.abort();
      item.reject(new Error('Request cancelled'));
    });
    
    // 取消队列中的请求
    this.queue.forEach(item => {
      item.reject(new Error('Request cancelled'));
    });
    
    this.running = [];
    this.queue = [];
  }
  
  // 获取状态信息
  getStatus() {
    return {
      waiting: this.queue.length,
      running: this.running.length,
      completed: this.completed.length
    };
  }
}

// 使用示例
const requestQueue = new RequestQueue(2); // 最多2个并发

// 批量添加请求
async function batchLoadData() {
  const urls = [
    '/api/users',
    '/api/posts',
    '/api/comments',
    '/api/categories',
    '/api/tags'
  ];
  
  try {
    console.log('开始批量加载数据...');
    
    // 将所有请求添加到队列
    const promises = urls.map(url => 
      requestQueue.add({ method: 'get', url })
    );
    
    // 等待所有请求完成
    const responses = await Promise.all(promises);
    
    console.log('所有数据加载完成');
    return responses.map(response => response.data);
    
  } catch (error) {
    console.error('批量加载失败:', error.message);
    return null;
  }
}

// 监控队列状态
setInterval(() => {
  const status = requestQueue.getStatus();
  console.log('队列状态:', status);
}, 1000);
```

### 7.2 优先级队列


```javascript
// 带优先级的请求队列
class PriorityRequestQueue extends RequestQueue {
  constructor(maxConcurrent = 3) {
    super(maxConcurrent);
    this.priorityQueue = {
      high: [],    // 高优先级
      normal: [],  // 普通优先级
      low: []      // 低优先级
    };
  }
  
  // 添加带优先级的请求
  add(requestConfig, priority = 'normal') {
    return new Promise((resolve, reject) => {
      const requestItem = {
        id: Date.now() + Math.random(),
        config: requestConfig,
        priority,
        resolve,
        reject,
        controller: new AbortController()
      };
      
      this.priorityQueue[priority].push(requestItem);
      this.process();
    });
  }
  
  // 按优先级获取下一个请求
  getNextRequest() {
    // 优先处理高优先级
    if (this.priorityQueue.high.length > 0) {
      return this.priorityQueue.high.shift();
    }
    
    // 然后处理普通优先级
    if (this.priorityQueue.normal.length > 0) {
      return this.priorityQueue.normal.shift();
    }
    
    // 最后处理低优先级
    if (this.priorityQueue.low.length > 0) {
      return this.priorityQueue.low.shift();
    }
    
    return null;
  }
  
  // 重写处理方法
  async process() {
    if (this.running.length >= this.maxConcurrent) {
      return;
    }
    
    const requestItem = this.getNextRequest();
    if (!requestItem) {
      return;
    }
    
    this.running.push(requestItem);
    
    try {
      console.log(`执行 ${requestItem.priority} 优先级请求: ${requestItem.id}`);
      
      const response = await axios({
        ...requestItem.config,
        signal: requestItem.controller.signal
      });
      
      requestItem.resolve(response);
      
    } catch (error) {
      requestItem.reject(error);
    } finally {
      this.running = this.running.filter(item => item.id !== requestItem.id);
      setTimeout(() => this.process(), 0);
    }
  }
}

// 使用示例
const priorityQueue = new PriorityRequestQueue(2);

// 添加不同优先级的请求
priorityQueue.add({ method: 'get', url: '/api/critical-data' }, 'high');
priorityQueue.add({ method: 'get', url: '/api/user-profile' }, 'normal');
priorityQueue.add({ method: 'get', url: '/api/analytics' }, 'low');
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 请求取消：解决网络浪费和结果错乱的重要手段
🔸 AbortController：现代标准的请求取消方案
🔸 CancelToken：已废弃的传统方案，了解即可
🔸 错误处理：区分取消错误和真实错误
🔸 并发控制：同时处理多个请求，提升效率
🔸 队列管理：控制并发数量，防止系统过载
```

### 8.2 关键理解要点


**🔹 什么时候需要取消请求**
```
必须取消的场景：
✅ 搜索框快速输入 → 取消上一次搜索
✅ 页面跳转离开 → 取消所有未完成请求
✅ 组件卸载销毁 → 防止内存泄漏
✅ 重复提交表单 → 防止重复操作

可选取消的场景：
⚠️ 请求超时 → 根据业务需求
⚠️ 用户取消操作 → 提升用户体验
```

**🔹 AbortController vs CancelToken**
```
推荐使用 AbortController：
✅ 现代浏览器原生支持
✅ W3C标准，通用性更好
✅ 其他库（fetch等）也支持
✅ 语法更简洁直观

避免使用 CancelToken：
❌ 已废弃，未来可能移除
❌ 只能用于Axios
❌ 语法相对复杂
```

**🔹 并发 vs 串行**
```
使用并发的时机：
✅ 请求之间相互独立
✅ 需要提升加载速度
✅ 服务器能承受并发压力

使用串行的时机：
✅ 请求之间有依赖关系
✅ 需要严格控制执行顺序
✅ 服务器性能有限
```

### 8.3 实际应用指导


**🎯 搜索场景最佳实践**
```javascript
// 搜索组件标准模板
class SearchComponent {
  constructor() {
    this.controller = null;
    this.debounceTimer = null;
  }
  
  search(keyword) {
    // 清除防抖定时器
    clearTimeout(this.debounceTimer);
    
    // 取消上一次请求
    if (this.controller) {
      this.controller.abort();
    }
    
    // 设置新的防抖
    this.debounceTimer = setTimeout(() => {
      this.performSearch(keyword);
    }, 300);
  }
  
  async performSearch(keyword) {
    this.controller = new AbortController();
    
    try {
      const response = await axios.get('/api/search', {
        params: { q: keyword },
        signal: this.controller.signal
      });
      
      this.updateResults(response.data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        this.showError('搜索失败');
      }
    }
  }
}
```

**🔄 组件生命周期管理**
```javascript
// Vue组件中的标准做法
export default {
  data() {
    return {
      requestControllers: []
    };
  },
  
  methods: {
    async fetchData() {
      const controller = new AbortController();
      this.requestControllers.push(controller);
      
      try {
        const response = await axios.get('/api/data', {
          signal: controller.signal
        });
        
        this.data = response.data;
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('获取数据失败');
        }
      }
    }
  },
  
  beforeUnmount() {
    // 组件销毁时取消所有请求
    this.requestControllers.forEach(controller => {
      controller.abort();
    });
  }
};
```

### 8.4 性能优化建议


```
🔸 合理设置并发数量
- 浏览器同域名限制：6个
- 推荐并发数：2-4个
- 根据服务器性能调整

🔸 使用请求队列管理
- 避免瞬间大量请求
- 提供优先级控制
- 支持取消和重试

🔸 错误处理策略
- 区分取消错误和网络错误
- 只对真实错误进行提示
- 提供重试机制

🔸 内存管理
- 组件销毁时清理控制器
- 避免保存大量响应数据
- 定期清理已完成的请求记录
```

**核心记忆口诀**：
- 请求取消很重要，避免浪费和错乱
- AbortController是标准，简单易用功能全  
- 搜索防抖要取消，页面跳转也要管
- 并发处理提效率，队列控制防过载