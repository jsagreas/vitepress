---
title: 2、性能优化策略
---
## 📚 目录

1. [性能优化核心思路](#1-性能优化核心思路)
2. [请求去重机制](#2-请求去重机制)
3. [防抖和节流应用](#3-防抖和节流应用)
4. [并发请求控制](#4-并发请求控制)
5. [缓存策略设计](#5-缓存策略设计)
6. [Loading状态管理](#6-Loading状态管理)
7. [请求队列管理](#7-请求队列管理)
8. [性能监控基础](#8-性能监控基础)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 性能优化核心思路


### 1.1 什么是Axios性能优化


**通俗理解**：就像**优化交通流量**一样，让网络请求跑得更快、更稳定

```
没优化的情况：         优化后的情况：
用户疯狂点按钮           用户点击有控制
→ 发送大量相同请求       → 避免重复请求
→ 服务器压力大           → 请求有序进行
→ 页面卡顿               → 页面响应流畅
```

### 1.2 优化的核心目标


**🎯 主要目标**：
- **减少无效请求**：不发送重复的、无意义的请求
- **提升用户体验**：页面响应更快，加载更流畅  
- **降低服务器压力**：合理控制请求频率和数量
- **节省网络资源**：避免浪费带宽和流量

### 1.3 常见性能问题


```
❌ 常见问题场景：

1. 用户快速点击按钮 → 发送多个相同请求
2. 页面频繁调用接口 → 服务器压力过大
3. 没有缓存机制 → 重复请求相同数据
4. 请求没有优先级 → 重要请求被阻塞
5. 缺少加载提示 → 用户体验差
```

---

## 2. 🔄 请求去重机制


### 2.1 什么是请求去重


**通俗解释**：就像**避免重复点餐**一样，如果同样的菜已经在做了，就不要再点一遍

```
场景举例：
用户快速点击"提交订单"按钮3次
→ 没有去重：发送3个订单请求 ❌
→ 有去重：只发送1个订单请求 ✅
```

### 2.2 请求去重的实现


**🔧 基础实现思路**：
```javascript
// 用一个Map存储正在进行的请求
const pendingRequests = new Map()

// 生成请求的唯一标识
function generateRequestKey(config) {
  const { method, url, params, data } = config
  return `${method}-${url}-${JSON.stringify(params)}-${JSON.stringify(data)}`
}
```

**💡 完整实现**：
```javascript
class RequestDeduplication {
  constructor() {
    this.pendingMap = new Map()
  }
  
  // 添加请求到待处理列表
  addPending(config) {
    const key = this.generateKey(config)
    
    // 如果已经有相同请求在进行，取消新请求
    if (this.pendingMap.has(key)) {
      throw new Error('重复请求，已取消')
    }
    
    // 记录新请求
    this.pendingMap.set(key, true)
  }
  
  // 请求完成后移除记录
  removePending(config) {
    const key = this.generateKey(config)
    this.pendingMap.delete(key)
  }
  
  generateKey(config) {
    return `${config.method}-${config.url}-${JSON.stringify(config.data || {})}`
  }
}

// 使用示例
const deduplication = new RequestDeduplication()

// 请求拦截器
axios.interceptors.request.use(config => {
  deduplication.addPending(config)
  return config
})

// 响应拦截器
axios.interceptors.response.use(
  response => {
    deduplication.removePending(response.config)
    return response
  },
  error => {
    deduplication.removePending(error.config)
    return Promise.reject(error)
  }
)
```

### 2.3 实际应用场景


> 💡 **提示**：去重特别适用于提交表单、点击按钮等操作

```javascript
// 订单提交按钮的处理
async function submitOrder() {
  try {
    const result = await axios.post('/api/order', orderData)
    console.log('订单提交成功')
  } catch (error) {
    if (error.message === '重复请求，已取消') {
      console.log('请不要重复提交')
    }
  }
}
```

---

## 3. ⏰ 防抖和节流应用


### 3.1 防抖和节流的区别


**通俗比喻**：
- **防抖**：像**电梯等人**，有人来就重新计时，等没人来了才关门
- **节流**：像**地铁发车**，不管有多少人，每3分钟发一班车

```
防抖示意图：
用户输入: a-b-c---d-e-f--------
触发请求:                    ✓  (只在最后触发)

节流示意图：  
用户输入: a-b-c-d-e-f-g-h-i-j
触发请求: ✓     ✓     ✓      (固定间隔触发)
```

### 3.2 防抖的实现


**🔸 基础防抖函数**：
```javascript
function debounce(func, delay) {
  let timer = null
  
  return function(...args) {
    // 清除之前的定时器
    clearTimeout(timer)
    
    // 设置新的定时器
    timer = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}
```

**🔸 搜索框防抖应用**：
```javascript
// 搜索接口
async function searchAPI(keyword) {
  const response = await axios.get('/api/search', {
    params: { q: keyword }
  })
  return response.data
}

// 防抖包装
const debouncedSearch = debounce(searchAPI, 500)

// 在输入框中使用
document.getElementById('searchInput').addEventListener('input', (e) => {
  const keyword = e.target.value
  if (keyword) {
    debouncedSearch(keyword)
  }
})
```

### 3.3 节流的实现


**🔸 基础节流函数**：
```javascript
function throttle(func, delay) {
  let lastTime = 0
  
  return function(...args) {
    const now = Date.now()
    
    // 如果距离上次执行超过delay时间，就执行
    if (now - lastTime >= delay) {
      lastTime = now
      func.apply(this, args)
    }
  }
}
```

**🔸 滚动加载节流应用**：
```javascript
// 加载更多数据
async function loadMoreData() {
  const response = await axios.get('/api/data', {
    params: { page: currentPage }
  })
  // 处理数据...
}

// 节流包装
const throttledLoadMore = throttle(loadMoreData, 1000)

// 滚动监听
window.addEventListener('scroll', () => {
  // 判断是否滚动到底部
  if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
    throttledLoadMore()
  }
})
```

---

## 4. 🚦 并发请求控制


### 4.1 什么是并发请求控制


**通俗理解**：就像**控制车道数量**，同时只允许一定数量的车通过，避免交通堵塞

```
无控制的情况：        有控制的情况：
🚗🚗🚗🚗🚗🚗          🚗🚗     (等待队列)
🚗🚗🚗🚗🚗🚗          🚗🚗🚗🚗🚗🚗
→ 全部堵塞             → 有序通行
```

### 4.2 并发控制的实现


**💡 核心思路**：
1. **设置最大并发数**（比如同时最多3个请求）
2. **维护请求队列**（超出的请求排队等待）
3. **请求完成后处理下一个**（释放位置给队列中的请求）

```javascript
class ConcurrencyController {
  constructor(maxConcurrency = 3) {
    this.maxConcurrency = maxConcurrency  // 最大并发数
    this.currentCount = 0                 // 当前进行中的请求数
    this.queue = []                      // 等待队列
  }
  
  async request(requestFn) {
    return new Promise((resolve, reject) => {
      // 把请求函数包装后加入队列
      this.queue.push({
        requestFn,
        resolve,
        reject
      })
      
      // 尝试执行队列中的请求
      this.processQueue()
    })
  }
  
  async processQueue() {
    // 如果达到最大并发数，或队列为空，就不处理
    if (this.currentCount >= this.maxConcurrency || this.queue.length === 0) {
      return
    }
    
    // 从队列中取出一个请求
    const { requestFn, resolve, reject } = this.queue.shift()
    this.currentCount++
    
    try {
      const result = await requestFn()
      resolve(result)
    } catch (error) {
      reject(error)
    } finally {
      // 请求完成，减少计数，处理下一个
      this.currentCount--
      this.processQueue()
    }
  }
}
```

**🔸 使用示例**：
```javascript
const controller = new ConcurrencyController(2) // 最多同时2个请求

// 模拟多个接口请求
const requests = [
  () => axios.get('/api/user/1'),
  () => axios.get('/api/user/2'),
  () => axios.get('/api/user/3'),
  () => axios.get('/api/user/4'),
  () => axios.get('/api/user/5')
]

// 使用并发控制
requests.forEach(async (request, index) => {
  try {
    const result = await controller.request(request)
    console.log(`请求${index + 1}完成:`, result.data)
  } catch (error) {
    console.error(`请求${index + 1}失败:`, error)
  }
})
```

---

## 5. 💾 缓存策略设计


### 5.1 什么是缓存策略


**通俗比喻**：就像**把常用的东西放在手边**，需要时直接拿，不用每次都去远处取

```
没有缓存：                 有缓存：
每次都从服务器获取         先查本地缓存
用户信息 → 服务器         用户信息 → 本地缓存 ✓
商品列表 → 服务器         商品列表 → 本地缓存 ✓
→ 速度慢，服务器压力大      → 速度快，减少请求
```

### 5.2 简单内存缓存实现


```javascript
class SimpleCache {
  constructor(expireTime = 5 * 60 * 1000) { // 默认5分钟过期
    this.cache = new Map()
    this.expireTime = expireTime
  }
  
  // 生成缓存key
  generateKey(config) {
    return `${config.method}-${config.url}-${JSON.stringify(config.params || {})}`
  }
  
  // 设置缓存
  set(key, data) {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    })
  }
  
  // 获取缓存
  get(key) {
    const cached = this.cache.get(key)
    
    if (!cached) return null
    
    // 检查是否过期
    if (Date.now() - cached.timestamp > this.expireTime) {
      this.cache.delete(key)
      return null
    }
    
    return cached.data
  }
  
  // 清除缓存
  clear() {
    this.cache.clear()
  }
}
```

**🔸 与Axios集成**：
```javascript
const cache = new SimpleCache()

// 请求拦截器：检查缓存
axios.interceptors.request.use(config => {
  // 只缓存GET请求
  if (config.method === 'get') {
    const key = cache.generateKey(config)
    const cached = cache.get(key)
    
    if (cached) {
      // 返回缓存数据
      return Promise.resolve({ data: cached, fromCache: true })
    }
  }
  
  return config
})

// 响应拦截器：保存缓存
axios.interceptors.response.use(response => {
  // 只缓存GET请求的成功响应
  if (response.config.method === 'get' && !response.fromCache) {
    const key = cache.generateKey(response.config)
    cache.set(key, response.data)
  }
  
  return response
})
```

### 5.3 缓存策略的选择


| 数据类型 | **缓存时间** | **说明** |
|---------|-------------|---------|
| 🏢 **基础配置** | `30分钟` | `系统配置、字典数据等变化少的数据` |
| 👤 **用户信息** | `10分钟` | `当前用户的基本信息` |
| 📋 **列表数据** | `5分钟` | `商品列表、文章列表等` |
| 📊 **统计数据** | `1分钟` | `实时性要求高的数据` |

---

## 6. ⏳ Loading状态管理


### 6.1 什么是Loading状态管理


**通俗理解**：就像**给用户一个进度提示**，让用户知道"我正在处理，请稍等"

```
没有Loading状态：           有Loading状态：
用户点击按钮               用户点击按钮
→ 页面没反应               → 显示"加载中..."
→ 用户不知道发生什么         → 用户知道正在处理
→ 可能重复点击              → 按钮变为不可点击
```

### 6.2 全局Loading管理


```javascript
class LoadingManager {
  constructor() {
    this.loadingCount = 0  // 记录正在进行的请求数量
    this.isLoading = false
  }
  
  // 开始Loading
  startLoading() {
    this.loadingCount++
    if (!this.isLoading) {
      this.isLoading = true
      this.showLoading()
    }
  }
  
  // 结束Loading
  endLoading() {
    this.loadingCount--
    if (this.loadingCount <= 0) {
      this.loadingCount = 0
      this.isLoading = false
      this.hideLoading()
    }
  }
  
  // 显示Loading效果
  showLoading() {
    console.log('显示Loading...')
    // 在实际项目中，这里会操作DOM或调用UI框架的Loading组件
  }
  
  // 隐藏Loading效果  
  hideLoading() {
    console.log('隐藏Loading...')
    // 隐藏Loading效果
  }
}

const loadingManager = new LoadingManager()

// 请求拦截器：开始Loading
axios.interceptors.request.use(config => {
  loadingManager.startLoading()
  return config
})

// 响应拦截器：结束Loading
axios.interceptors.response.use(
  response => {
    loadingManager.endLoading()
    return response
  },
  error => {
    loadingManager.endLoading()
    return Promise.reject(error)
  }
)
```

### 6.3 特定请求的Loading控制


```javascript
// 为特定的按钮或区域显示Loading
async function submitForm(buttonElement) {
  // 设置按钮为Loading状态
  buttonElement.disabled = true
  buttonElement.textContent = '提交中...'
  
  try {
    await axios.post('/api/form', formData)
    alert('提交成功！')
  } catch (error) {
    alert('提交失败，请重试')
  } finally {
    // 恢复按钮状态
    buttonElement.disabled = false
    buttonElement.textContent = '提交'
  }
}
```

---

## 7. 📋 请求队列管理


### 7.1 什么是请求队列


**通俗比喻**：就像**银行排队叫号**，按顺序处理，重要的可以插队

```
普通队列：               优先队列：
请求A → 请求B → 请求C     紧急请求 → 请求A → 请求B
按顺序处理               重要的先处理
```

### 7.2 简单队列实现


```javascript
class RequestQueue {
  constructor() {
    this.queue = []
    this.isProcessing = false
  }
  
  // 添加请求到队列
  add(requestFn, priority = 0) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        requestFn,
        priority,
        resolve,
        reject
      })
      
      // 按优先级排序（数字越大优先级越高）
      this.queue.sort((a, b) => b.priority - a.priority)
      
      // 开始处理队列
      this.process()
    })
  }
  
  // 处理队列
  async process() {
    if (this.isProcessing || this.queue.length === 0) {
      return
    }
    
    this.isProcessing = true
    
    while (this.queue.length > 0) {
      const { requestFn, resolve, reject } = this.queue.shift()
      
      try {
        const result = await requestFn()
        resolve(result)
      } catch (error) {
        reject(error)
      }
    }
    
    this.isProcessing = false
  }
}
```

**🔸 使用示例**：
```javascript
const queue = new RequestQueue()

// 普通请求
queue.add(() => axios.get('/api/data'), 1)

// 高优先级请求（会插队）
queue.add(() => axios.get('/api/urgent'), 5)

// 低优先级请求
queue.add(() => axios.get('/api/background'), 0)
```

---

## 8. 📊 性能监控基础


### 8.1 什么是性能监控


**通俗理解**：就像**体检报告**，定期检查系统的健康状况

```
监控内容：
- 请求响应时间  → 知道哪个接口慢
- 请求成功率    → 知道哪个接口容易出错  
- 请求数量统计  → 知道系统负载情况
- 错误类型分析  → 知道常见问题
```

### 8.2 简单监控实现


```javascript
class PerformanceMonitor {
  constructor() {
    this.stats = {
      totalRequests: 0,      // 总请求数
      successRequests: 0,    // 成功请求数
      failedRequests: 0,     // 失败请求数
      totalTime: 0,          // 总耗时
      slowRequests: []       // 慢请求记录
    }
  }
  
  // 记录请求开始
  startRequest(config) {
    config.startTime = Date.now()
    this.stats.totalRequests++
  }
  
  // 记录请求成功
  recordSuccess(config) {
    const duration = Date.now() - config.startTime
    this.stats.successRequests++
    this.stats.totalTime += duration
    
    // 记录慢请求（超过2秒）
    if (duration > 2000) {
      this.stats.slowRequests.push({
        url: config.url,
        method: config.method,
        duration
      })
    }
  }
  
  // 记录请求失败
  recordFailure(config) {
    this.stats.failedRequests++
  }
  
  // 获取统计报告
  getReport() {
    const avgTime = this.stats.totalTime / this.stats.successRequests
    const successRate = (this.stats.successRequests / this.stats.totalRequests * 100).toFixed(2)
    
    return {
      总请求数: this.stats.totalRequests,
      成功率: `${successRate}%`,
      平均响应时间: `${avgTime.toFixed(0)}ms`,
      慢请求数量: this.stats.slowRequests.length
    }
  }
}

const monitor = new PerformanceMonitor()

// 集成到axios
axios.interceptors.request.use(config => {
  monitor.startRequest(config)
  return config
})

axios.interceptors.response.use(
  response => {
    monitor.recordSuccess(response.config)
    return response
  },
  error => {
    monitor.recordFailure(error.config)
    return Promise.reject(error)
  }
)

// 定期输出报告
setInterval(() => {
  console.log('性能报告:', monitor.getReport())
}, 30000) // 每30秒输出一次
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的优化策略


```
🔸 请求去重：避免重复请求，特别是表单提交
🔸 防抖节流：控制请求频率，提升用户体验  
🔸 并发控制：限制同时进行的请求数量
🔸 缓存机制：减少不必要的网络请求
🔸 Loading管理：给用户明确的操作反馈
```

### 9.2 优化策略选择指南


| 场景 | **推荐策略** | **说明** |
|------|-------------|---------|
| 🔘 **按钮点击** | `请求去重 + Loading` | `防止重复提交，显示处理状态` |
| 🔍 **搜索输入** | `防抖 + 缓存` | `减少无效请求，缓存搜索结果` |
| 📄 **滚动加载** | `节流 + 并发控制` | `控制加载频率，限制并发数` |
| 📊 **数据展示** | `缓存 + 监控` | `缓存常用数据，监控性能` |

### 9.3 实际应用建议


> 💡 **新手提示**：优化要**循序渐进**，先解决最明显的问题

**🔹 优化优先级**：
1. **先加Loading状态** - 立即提升用户体验
2. **再加请求去重** - 解决重复提交问题  
3. **然后加缓存** - 减少不必要的请求
4. **最后加监控** - 持续改进性能

**🔹 常见误区**：
- ❌ 过度优化：为了优化而优化，增加复杂度
- ❌ 忽视场景：所有请求都用同样的策略
- ❌ 缓存过期：缓存时间设置不合理

**🔹 最佳实践**：
- ✅ 根据业务场景选择合适的优化策略
- ✅ 监控实际效果，数据驱动优化决策
- ✅ 保持代码简洁，优化不应该让代码变得复杂

**核心记忆**：
- 性能优化的本质是**提升用户体验**
- 要根据**实际场景**选择合适的策略
- **先解决最明显的问题**，再逐步完善
- **监控数据**比主观感受更可靠