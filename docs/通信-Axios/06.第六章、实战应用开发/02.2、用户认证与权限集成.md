---
title: 2、用户认证与权限集成
---
## 📚 目录

1. [用户认证基础概念](#1-用户认证基础概念)
2. [Token存储与管理](#2-Token存储与管理)
3. [请求拦截器自动添加Token](#3-请求拦截器自动添加Token)
4. [响应拦截器处理Token过期](#4-响应拦截器处理Token过期)
5. [完整的登录登出流程](#5-完整的登录登出流程)
6. [路由权限控制集成](#6-路由权限控制集成)
7. [实战项目应用总结](#7-实战项目应用总结)

---

## 1. 🔐 用户认证基础概念


### 1.1 什么是用户认证


**简单理解**：就像进入办公楼需要刷门禁卡一样，网站也需要验证你的身份

```
现实生活的认证：              网站的认证：
用户 → 刷门禁卡 → 进入楼层    用户 → 输入账号密码 → 获得Token → 访问页面
```

> **💡 核心概念**：Token就像是一张"临时通行证"，证明你已经登录过了，可以访问需要权限的页面和功能。

### 1.2 认证流程的本质


**🔄 用户认证的完整过程**：

```
第一步：登录验证
用户名 + 密码 → 服务器验证 → 返回Token

第二步：Token使用  
每次请求 → 携带Token → 服务器验证 → 返回数据

第三步：过期处理
Token过期 → 自动跳转登录页 → 重新获取Token
```

**为什么要用Token而不是每次都输密码？**
- 🔒 **安全性**：避免密码在网络中频繁传输
- ⚡ **效率**：Token验证比密码验证更快
- 🕐 **有效期**：可以设置过期时间，增强安全性
- 📱 **多端使用**：一个Token可以在多个设备使用

---

## 2. 💾 Token存储与管理


### 2.1 Token存储位置对比


**🤔 Token应该存放在哪里？**

| **存储方式** | **安全性** | **持久性** | **使用场景** |
|-------------|-----------|-----------|-------------|
| `localStorage` | 🟡 中等 | ✅ 永久保存 | 记住登录状态 |
| `sessionStorage` | 🟡 中等 | ❌ 关闭浏览器就没了 | 单次会话 |
| `内存变量` | 🟢 相对安全 | ❌ 刷新页面就没了 | 高安全要求 |

**💡 实际选择建议**：
- **一般项目**：用localStorage，用户体验好
- **高安全项目**：用sessionStorage，更安全
- **银行类应用**：用内存变量，最安全

### 2.2 Token管理的核心代码


```javascript
// 创建一个专门管理Token的工具
const TokenManager = {
  // 保存Token到本地
  setToken(token) {
    localStorage.setItem('userToken', token);
  },
  
  // 从本地获取Token
  getToken() {
    return localStorage.getItem('userToken');
  },
  
  // 删除Token
  removeToken() {
    localStorage.removeItem('userToken');
  },
  
  // 检查是否已登录
  isLoggedIn() {
    return this.getToken() !== null;
  }
};
```

> **🎯 核心思路**：把Token的存取删查都封装成方法，哪里需要就调用哪里，代码更整洁。

---

## 3. ⚙️ 请求拦截器自动添加Token


### 3.1 为什么需要请求拦截器


**问题场景**：每次发请求都要手动加Token太麻烦了
```javascript
// 😵 麻烦的写法：每个请求都要写一遍
axios.get('/api/profile', {
  headers: { Authorization: `Bearer ${token}` }
});

axios.post('/api/data', data, {
  headers: { Authorization: `Bearer ${token}` }
});
```

**解决方案**：用拦截器自动添加
```javascript
// 😊 智能的写法：一次配置，自动添加
axios.interceptors.request.use(config => {
  const token = TokenManager.getToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

### 3.2 请求拦截器的工作原理


```
请求拦截器工作流程：

你发起请求 → 拦截器检查Token → 自动添加到请求头 → 发送给服务器
    ↓              ↓                ↓              ↓
axios.get()    有Token吗？      加上Authorization    服务器收到完整请求
```

**🔧 完整的请求拦截器配置**：

```javascript
// 配置请求拦截器
axios.interceptors.request.use(
  config => {
    // 获取保存的Token
    const token = TokenManager.getToken();
    
    // 如果有Token，就加到请求头里
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);
```

> **💡 理解要点**：拦截器就像是一个"智能助手"，每次发请求前都帮你检查是否需要加Token，不用你手动操作。

---

## 4. 🛡️ 响应拦截器处理Token过期


### 4.1 Token过期的常见表现


**服务器告诉你Token过期的方式**：
- 返回401状态码（未授权）
- 返回特定的错误信息
- 直接拒绝请求

```javascript
// 典型的Token过期响应
{
  status: 401,
  data: {
    code: 'TOKEN_EXPIRED',
    message: 'Token已过期，请重新登录'
  }
}
```

### 4.2 响应拦截器处理过期Token


**🔄 自动处理Token过期的流程**：

```
服务器返回401 → 响应拦截器检测到 → 清除过期Token → 跳转到登录页
```

**核心代码实现**：

```javascript
// 配置响应拦截器
axios.interceptors.response.use(
  response => {
    // 请求成功，直接返回数据
    return response;
  },
  error => {
    // 检查是否是Token过期
    if (error.response && error.response.status === 401) {
      // 清除过期的Token
      TokenManager.removeToken();
      
      // 提示用户
      alert('登录已过期，请重新登录');
      
      // 跳转到登录页
      window.location.href = '/login';
    }
    
    return Promise.reject(error);
  }
);
```

### 4.3 Token刷新机制


**🔄 更智能的处理方式**：自动刷新Token

```javascript
// 高级版本：尝试刷新Token
axios.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 401) {
      try {
        // 尝试刷新Token
        const newToken = await refreshToken();
        TokenManager.setToken(newToken);
        
        // 重新发送原来的请求
        return axios.request(error.config);
      } catch (refreshError) {
        // 刷新失败，跳转登录
        TokenManager.removeToken();
        window.location.href = '/login';
      }
    }
    return Promise.reject(error);
  }
);

// 刷新Token的函数
async function refreshToken() {
  const response = await axios.post('/api/refresh-token');
  return response.data.token;
}
```

---

## 5. 🚪 完整的登录登出流程


### 5.1 登录流程实现


**📝 用户登录的完整过程**：

```javascript
// 登录函数
async function login(username, password) {
  try {
    // 1. 发送登录请求
    const response = await axios.post('/api/login', {
      username,
      password
    });
    
    // 2. 获取返回的Token
    const token = response.data.token;
    
    // 3. 保存Token到本地
    TokenManager.setToken(token);
    
    // 4. 跳转到主页
    window.location.href = '/dashboard';
    
  } catch (error) {
    alert('登录失败：' + error.response.data.message);
  }
}
```

### 5.2 登录状态检查


**🔍 页面加载时检查登录状态**：

```javascript
// 检查登录状态
function checkLoginStatus() {
  if (TokenManager.isLoggedIn()) {
    // 已登录，显示用户信息
    showUserInfo();
  } else {
    // 未登录，跳转登录页
    window.location.href = '/login';
  }
}

// 页面加载时执行检查
window.onload = checkLoginStatus;
```

### 5.3 登出流程实现


**🚪 用户登出的处理**：

```javascript
// 登出函数
function logout() {
  // 1. 清除本地保存的Token
  TokenManager.removeToken();
  
  // 2. 可选：通知服务器用户登出
  axios.post('/api/logout').catch(() => {
    // 即使通知失败也不影响本地登出
  });
  
  // 3. 跳转到登录页
  window.location.href = '/login';
}
```

---

## 6. 🛣️ 路由权限控制集成


### 6.1 前端路由拦截


**🚧 保护需要登录的页面**：

```javascript
// 路由守卫函数
function routeGuard(to, from, next) {
  // 检查要访问的页面是否需要登录
  if (to.meta.requiresAuth) {
    if (TokenManager.isLoggedIn()) {
      // 已登录，允许访问
      next();
    } else {
      // 未登录，跳转到登录页
      next('/login');
    }
  } else {
    // 不需要登录的页面，直接访问
    next();
  }
}

// Vue Router 示例
const router = new VueRouter({
  routes: [
    {
      path: '/dashboard',
      component: Dashboard,
      meta: { requiresAuth: true } // 标记需要登录
    },
    {
      path: '/login',
      component: Login,
      meta: { requiresAuth: false }
    }
  ]
});

router.beforeEach(routeGuard);
```

### 6.2 权限级别控制


**👥 不同用户看到不同内容**：

```javascript
// 权限检查工具
const PermissionManager = {
  // 检查用户权限
  hasPermission(permission) {
    const userInfo = this.getUserInfo();
    return userInfo.permissions.includes(permission);
  },
  
  // 从Token中获取用户信息
  getUserInfo() {
    const token = TokenManager.getToken();
    if (!token) return null;
    
    // 解析Token获取用户信息（简化版本）
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload;
  }
};

// 在组件中使用
function showAdminPanel() {
  if (PermissionManager.hasPermission('admin')) {
    document.getElementById('admin-panel').style.display = 'block';
  }
}
```

---

## 7. 🎯 实战项目应用总结


### 7.1 完整的认证系统代码


**🏗️ 把所有功能整合到一起**：

```javascript
// auth.js - 认证系统完整代码
class AuthSystem {
  constructor() {
    this.setupAxiosInterceptors();
  }
  
  // 设置Axios拦截器
  setupAxiosInterceptors() {
    // 请求拦截器：自动添加Token
    axios.interceptors.request.use(config => {
      const token = this.getToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    // 响应拦截器：处理Token过期
    axios.interceptors.response.use(
      response => response,
      error => {
        if (error.response?.status === 401) {
          this.handleTokenExpired();
        }
        return Promise.reject(error);
      }
    );
  }
  
  // 登录
  async login(username, password) {
    const response = await axios.post('/api/login', {
      username, password
    });
    
    this.setToken(response.data.token);
    return response.data;
  }
  
  // 登出
  logout() {
    this.removeToken();
    window.location.href = '/login';
  }
  
  // Token管理
  setToken(token) {
    localStorage.setItem('token', token);
  }
  
  getToken() {
    return localStorage.getItem('token');
  }
  
  removeToken() {
    localStorage.removeItem('token');
  }
  
  // 检查登录状态
  isLoggedIn() {
    return this.getToken() !== null;
  }
  
  // 处理Token过期
  handleTokenExpired() {
    this.removeToken();
    alert('登录已过期，请重新登录');
    window.location.href = '/login';
  }
}

// 创建全局认证实例
const auth = new AuthSystem();
```

### 7.2 实际使用场景


**📱 在实际项目中的应用**：

```javascript
// 页面初始化
window.onload = function() {
  if (auth.isLoggedIn()) {
    loadUserDashboard();
  } else {
    showLoginForm();
  }
};

// 登录表单提交
document.getElementById('login-form').onsubmit = async function(e) {
  e.preventDefault();
  
  const username = document.getElementById('username').value;
  const password = document.getElementById('password').value;
  
  try {
    await auth.login(username, password);
    window.location.href = '/dashboard';
  } catch (error) {
    alert('登录失败');
  }
};

// 发起需要权限的请求
async function getUserProfile() {
  try {
    const response = await axios.get('/api/profile');
    displayUserInfo(response.data);
  } catch (error) {
    console.log('获取用户信息失败');
  }
}
```

### 7.3 核心要点回顾


**🎯 认证系统的关键理解**：

```
1️⃣ Token存储：就像保存门禁卡，下次直接刷卡进入
2️⃣ 请求拦截：每次出门自动带上门禁卡  
3️⃣ 响应拦截：门禁卡过期时自动处理
4️⃣ 路由保护：没有门禁卡不能进特定楼层
5️⃣ 登出清理：离开时交还门禁卡
```

| **功能** | **作用** | **核心代码** |
|---------|---------|-------------|
| **Token存储** | 记住登录状态 | `localStorage.setItem('token', token)` |
| **自动添加Token** | 免重复操作 | `config.headers.Authorization = 'Bearer ' + token` |
| **过期处理** | 自动跳转登录 | `if (status === 401) window.location.href = '/login'` |
| **登录检查** | 保护页面访问 | `if (!auth.isLoggedIn()) redirect('/login')` |

### 7.4 新手常见问题


**❓ 常见疑问解答**：

> **Q: Token存在localStorage安全吗？**
> A: 对于一般网站够用了，重要应用可以用更安全的方式

> **Q: 为什么要用拦截器？**  
> A: 避免每个请求都手动加Token，代码更简洁

> **Q: Token过期了怎么办？**
> A: 拦截器会自动检测并跳转到登录页

> **Q: 刷新页面会丢失登录状态吗？**
> A: 不会，Token存在localStorage里，刷新页面还在

**🏆 最佳实践建议**：
- ✅ 用类或对象封装认证功能，代码更整洁
- ✅ 设置合理的Token过期时间
- ✅ 重要操作前二次验证身份
- ✅ 定期清理无效的Token

**核心记忆**：
```
Token像门禁卡，登录后保存好
拦截器是助手，自动加token很重要  
过期自动跳转，用户体验不能少
权限分级管理，安全访问有保障
```