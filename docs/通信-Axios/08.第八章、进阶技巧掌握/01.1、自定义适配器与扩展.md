---
title: 1、自定义适配器与扩展
---
## 📚 目录

1. [适配器基础概念](#1-适配器基础概念)
2. [适配器工作原理](#2-适配器工作原理)
3. [自定义适配器实现](#3-自定义适配器实现)
4. [不同环境适配](#4-不同环境适配)
5. [适配器配置与使用](#5-适配器配置与使用)
6. [第三方适配器集成](#6-第三方适配器集成)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 适配器基础概念


### 1.1 什么是适配器


**通俗理解**：适配器就像万能转换插头

```
现实例子：
美国插头 → 转换器 → 中国插座
三角插头 → 转换器 → 圆孔插座

axios中：
你的请求代码 → 适配器 → 不同平台的HTTP实现
```

> 💡 **核心概念**：适配器是axios用来发送HTTP请求的底层"引擎"，它让axios能在不同环境下工作

**为什么需要适配器**：
- 🌐 **浏览器环境**：使用`XMLHttpRequest`
- 🖥️ **Node.js环境**：使用`http`模块  
- 📱 **小程序环境**：使用`wx.request`
- 📲 **React Native**：使用原生网络模块

### 1.2 适配器的作用


```
┌─────────────────┐    ┌─────────────┐    ┌─────────────────┐
│   你的代码      │───→│  axios适配器 │───→│  平台HTTP实现    │
│ axios.get(url)  │    │   (转换层)   │    │  XHR/http/wx    │
└─────────────────┘    └─────────────┘    └─────────────────┘
```

**适配器的职责**：
- ✅ **统一接口**：让你用同一套代码在不同平台工作
- ✅ **协议转换**：把axios配置转换成平台对应的请求
- ✅ **响应处理**：把平台响应转换成axios标准格式
- ✅ **错误处理**：统一不同平台的错误格式

---

## 2. ⚙️ 适配器工作原理


### 2.1 适配器执行流程


```
请求发送流程：
┌────────────┐
│ 用户调用   │ axios.get('/api/user')
│ axios API  │
└─────┬──────┘
      │
┌─────▼──────┐
│ axios核心  │ 处理配置、拦截器等
│ 处理逻辑   │
└─────┬──────┘
      │
┌─────▼──────┐
│ 选择适配器 │ 根据环境自动选择或手动指定
└─────┬──────┘
      │
┌─────▼──────┐
│ 适配器执行 │ 发送实际HTTP请求
│ 具体请求   │
└─────┬──────┘
      │
┌─────▼──────┐
│ 响应处理   │ 转换为axios标准响应格式
│ 返回结果   │
└────────────┘
```

### 2.2 适配器接口规范


**适配器就是一个函数**，接收配置返回Promise：

```javascript
// 适配器的基本结构
function myAdapter(config) {
  return new Promise((resolve, reject) => {
    // 1. 根据config发送请求
    // 2. 处理响应
    // 3. 返回标准格式
  });
}
```

> 📖 **概念解释**：config是axios的请求配置对象，包含url、method、data等信息

### 2.3 axios内置适配器


**axios自带两个适配器**：

```javascript
// 浏览器环境 - 使用XMLHttpRequest
function xhrAdapter(config) {
  const xhr = new XMLHttpRequest();
  // 具体实现...
}

// Node.js环境 - 使用http模块
function httpAdapter(config) {
  const http = require('http');
  // 具体实现...
}
```

**自动选择机制**：
```javascript
// axios内部的选择逻辑
function getDefaultAdapter() {
  if (typeof XMLHttpRequest !== 'undefined') {
    return xhrAdapter; // 浏览器环境
  } else if (typeof process !== 'undefined') {
    return httpAdapter; // Node.js环境
  }
}
```

---

## 3. 🛠️ 自定义适配器实现


### 3.1 基础适配器结构


```javascript
// 最简单的自定义适配器
function simpleAdapter(config) {
  return new Promise((resolve, reject) => {
    // 模拟请求
    setTimeout(() => {
      if (config.url.includes('error')) {
        reject(new Error('请求失败'));
      } else {
        resolve({
          status: 200,
          statusText: 'OK',
          data: { message: '请求成功' },
          headers: {},
          config: config
        });
      }
    }, 1000);
  });
}
```

> 💡 **关键点**：适配器必须返回包含`status`、`data`、`headers`、`config`的响应对象

### 3.2 完整的自定义适配器


```javascript
// 带错误处理的完整适配器
function customAdapter(config) {
  return new Promise((resolve, reject) => {
    // 1. 验证配置
    if (!config.url) {
      reject(new Error('缺少请求URL'));
      return;
    }

    // 2. 构建请求
    const request = new XMLHttpRequest();
    
    // 3. 设置请求
    request.open(config.method.toUpperCase(), config.url);
    
    // 4. 设置请求头
    Object.keys(config.headers || {}).forEach(key => {
      request.setRequestHeader(key, config.headers[key]);
    });

    // 5. 处理响应
    request.onload = function() {
      const response = {
        status: request.status,
        statusText: request.statusText,
        data: JSON.parse(request.responseText || '{}'),
        headers: parseHeaders(request.getAllResponseHeaders()),
        config: config
      };
      
      if (request.status >= 200 && request.status < 300) {
        resolve(response);
      } else {
        reject(new Error(`请求失败: ${request.status}`));
      }
    };

    // 6. 错误处理
    request.onerror = () => reject(new Error('网络错误'));
    
    // 7. 发送请求
    request.send(config.data);
  });
}

// 辅助函数：解析响应头
function parseHeaders(headerStr) {
  const headers = {};
  headerStr.split('\r\n').forEach(line => {
    const [key, value] = line.split(': ');
    if (key) headers[key] = value;
  });
  return headers;
}
```

### 3.3 适配器增强功能


```javascript
// 带缓存功能的适配器
function cachingAdapter(config) {
  const cache = new Map();
  const cacheKey = `${config.method}-${config.url}`;
  
  return new Promise((resolve, reject) => {
    // 检查缓存
    if (config.method === 'GET' && cache.has(cacheKey)) {
      console.log('📦 从缓存返回数据');
      resolve(cache.get(cacheKey));
      return;
    }

    // 使用默认适配器
    const defaultAdapter = axios.defaults.adapter;
    defaultAdapter(config)
      .then(response => {
        // 缓存GET请求结果
        if (config.method === 'GET') {
          cache.set(cacheKey, response);
        }
        resolve(response);
      })
      .catch(reject);
  });
}
```

---

## 4. 🌍 不同环境适配


### 4.1 Node.js环境适配


**为什么需要Node.js适配器**：
- 🚫 Node.js没有`XMLHttpRequest`
- ✅ 使用Node.js的`http`和`https`模块

```javascript
// Node.js适配器示例
function nodeAdapter(config) {
  const http = require('http');
  const https = require('https');
  const url = require('url');
  
  return new Promise((resolve, reject) => {
    const parsed = url.parse(config.url);
    const isHttps = parsed.protocol === 'https:';
    const lib = isHttps ? https : http;
    
    const options = {
      hostname: parsed.hostname,
      port: parsed.port,
      path: parsed.path,
      method: config.method.toUpperCase(),
      headers: config.headers
    };

    const req = lib.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        resolve({
          status: res.statusCode,
          statusText: res.statusMessage,
          data: JSON.parse(data),
          headers: res.headers,
          config: config
        });
      });
    });

    req.on('error', reject);
    req.write(config.data || '');
    req.end();
  });
}
```

### 4.2 小程序环境适配


**小程序的特殊性**：
- 🚫 没有`XMLHttpRequest`
- ✅ 使用`wx.request`、`uni.request`等

```javascript
// 微信小程序适配器
function wxAdapter(config) {
  return new Promise((resolve, reject) => {
    wx.request({
      url: config.url,
      method: config.method.toUpperCase(),
      data: config.data,
      header: config.headers,
      
      success: (res) => {
        resolve({
          status: res.statusCode,
          statusText: 'OK',
          data: res.data,
          headers: res.header,
          config: config
        });
      },
      
      fail: (error) => {
        reject(new Error(error.errMsg || '请求失败'));
      }
    });
  });
}
```

### 4.3 React Native适配


```javascript
// React Native适配器
function reactNativeAdapter(config) {
  return new Promise((resolve, reject) => {
    const options = {
      method: config.method.toUpperCase(),
      headers: config.headers,
    };
    
    if (config.data) {
      options.body = JSON.stringify(config.data);
    }

    fetch(config.url, options)
      .then(response => {
        return response.json().then(data => ({
          status: response.status,
          statusText: response.statusText,
          data: data,
          headers: response.headers,
          config: config
        }));
      })
      .then(resolve)
      .catch(reject);
  });
}
```

### 4.4 通用适配器


```javascript
// 自动检测环境的通用适配器
function universalAdapter(config) {
  // 检测环境
  if (typeof wx !== 'undefined' && wx.request) {
    return wxAdapter(config);           // 微信小程序
  } else if (typeof uni !== 'undefined') {
    return uniAdapter(config);          // uni-app
  } else if (typeof fetch !== 'undefined') {
    return fetchAdapter(config);        // 现代浏览器/RN
  } else if (typeof XMLHttpRequest !== 'undefined') {
    return xhrAdapter(config);          // 老浏览器
  } else {
    return nodeAdapter(config);         // Node.js
  }
}
```

---

## 5. 🔧 适配器配置与使用


### 5.1 全局配置适配器


```javascript
// 方式1：全局设置
axios.defaults.adapter = customAdapter;

// 方式2：创建实例时设置
const instance = axios.create({
  adapter: customAdapter
});

// 方式3：单次请求设置
axios.get('/api/user', {
  adapter: customAdapter
});
```

### 5.2 条件性适配器选择


```javascript
// 根据条件选择适配器
function selectAdapter(config) {
  if (config.cache === true) {
    return cachingAdapter(config);      // 需要缓存
  } else if (config.mock === true) {
    return mockAdapter(config);         // 模拟数据
  } else {
    return axios.defaults.adapter(config); // 默认适配器
  }
}

// 使用
axios.defaults.adapter = selectAdapter;
```

### 5.3 适配器链


```javascript
// 组合多个适配器
function createAdapterChain(...adapters) {
  return function(config) {
    let index = 0;
    
    function next() {
      if (index >= adapters.length) {
        return Promise.reject(new Error('所有适配器都失败了'));
      }
      
      const adapter = adapters[index++];
      return adapter(config).catch(() => next());
    }
    
    return next();
  };
}

// 使用：依次尝试不同适配器
const chainAdapter = createAdapterChain(
  customAdapter,    // 首先尝试自定义适配器
  mockAdapter,      // 失败后尝试模拟适配器
  axios.defaults.adapter // 最后使用默认适配器
);
```

---

## 6. 🔌 第三方适配器集成


### 6.1 流行的第三方适配器


```javascript
// 1. axios-cache-adapter - 缓存适配器
import { setupCache } from 'axios-cache-adapter';

const cache = setupCache({
  maxAge: 15 * 60 * 1000 // 15分钟缓存
});

const api = axios.create({
  adapter: cache.adapter
});
```

```javascript
// 2. axios-retry - 重试适配器
import axiosRetry from 'axios-retry';

axiosRetry(axios, {
  retries: 3,
  retryDelay: (retryCount) => {
    return retryCount * 1000; // 递增延迟
  }
});
```

### 6.2 适配器包装器


```javascript
// 创建适配器包装器
function wrapAdapter(adapter, wrapper) {
  return function(config) {
    return wrapper(() => adapter(config), config);
  };
}

// 日志包装器
function logWrapper(adapterFn, config) {
  console.log(`🚀 发送请求: ${config.method} ${config.url}`);
  
  return adapterFn().then(response => {
    console.log(`✅ 请求成功: ${response.status}`);
    return response;
  }).catch(error => {
    console.log(`❌ 请求失败: ${error.message}`);
    throw error;
  });
}

// 使用
const loggedAdapter = wrapAdapter(axios.defaults.adapter, logWrapper);
```

### 6.3 适配器测试


```javascript
// 测试适配器
function testAdapter() {
  const testConfig = {
    url: 'https://api.example.com/test',
    method: 'get',
    headers: { 'Content-Type': 'application/json' }
  };

  return customAdapter(testConfig)
    .then(response => {
      console.log('✅ 适配器测试通过', response);
      return true;
    })
    .catch(error => {
      console.error('❌ 适配器测试失败', error);
      return false;
    });
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 适配器本质：axios发送HTTP请求的底层"引擎"
🔸 统一接口：让同一套代码在不同平台工作  
🔸 协议转换：把axios配置转换成平台对应的请求
🔸 响应标准：必须返回包含status、data、headers、config的对象
🔸 环境适配：浏览器、Node.js、小程序等不同环境的处理
```

### 7.2 关键理解要点


**🔹 适配器的作用机制**
```
你的代码 → axios核心 → 适配器 → 平台HTTP实现
         统一API    转换层   具体实现

关键：适配器是"翻译官"，把统一的axios语言
     翻译成不同平台能理解的"方言"
```

**🔹 自定义适配器的应用场景**
```
✅ 平台兼容：支持新的运行环境
✅ 功能增强：添加缓存、重试、日志等
✅ 协议扩展：支持非HTTP协议  
✅ 测试模拟：模拟网络请求进行测试
✅ 性能优化：请求合并、预加载等
```

**🔹 适配器选择策略**
```
开发阶段：使用mock适配器模拟数据
测试阶段：使用测试适配器验证逻辑
生产环境：使用高性能适配器优化体验
特殊平台：使用平台特定适配器兼容
```

### 7.3 实际应用指导


> 🚀 **最佳实践**：
> - **渐进增强**：先用默认适配器，有需求再定制
> - **环境检测**：自动识别运行环境选择合适适配器
> - **错误处理**：适配器内部做好异常处理和降级
> - **性能考量**：避免过度包装影响请求性能

**📊 适配器选择参考**：

| 场景 | **推荐适配器** | **原因** |
|------|---------------|----------|
| 🌐 **多平台应用** | `通用适配器` | `自动环境检测` |
| 📱 **小程序开发** | `wx/uni适配器` | `平台API兼容` |
| 🖥️ **Node.js服务** | `http适配器` | `原生模块支持` |
| 🧪 **单元测试** | `mock适配器` | `可控的模拟数据` |
| ⚡ **性能优化** | `缓存适配器` | `减少重复请求` |

### 7.4 学习进度检查


- [ ] **理解适配器概念**：知道适配器是什么，解决什么问题
- [ ] **掌握工作原理**：了解适配器在axios中的执行流程  
- [ ] **能写简单适配器**：实现基础的自定义适配器
- [ ] **熟悉环境适配**：知道不同平台的适配方式
- [ ] **会配置和使用**：能正确配置和切换适配器
- [ ] **了解第三方库**：知道常用的适配器库和工具

**核心记忆**：
- 适配器是axios的"万能转换器"，让统一代码适应不同平台
- 适配器就是接收config返回Promise的函数，要返回标准响应格式
- 根据实际需求选择或定制适配器，避免过度复杂化
- 优秀的适配器要考虑兼容性、性能和错误处理