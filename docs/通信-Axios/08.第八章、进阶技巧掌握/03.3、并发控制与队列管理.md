---
title: 3、并发控制与队列管理
---
## 📚 目录

1. [并发控制基本概念](#1-并发控制基本概念)
2. [请求队列管理机制](#2-请求队列管理机制)
3. [限制并发数量实现](#3-限制并发数量实现)
4. [依赖请求处理模式](#4-依赖请求处理模式)
5. [批量请求优化策略](#5-批量请求优化策略)
6. [请求优先级管理](#6-请求优先级管理)
7. [资源竞争处理方案](#7-资源竞争处理方案)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 并发控制基本概念


### 1.1 什么是并发控制


**📋 通俗解释**：
```
生活类比：银行排队取钱
- 没有控制：所有人同时冲向柜台，场面混乱
- 有序控制：排队等候，一次只有几个人办理业务

网络请求的并发控制同理：
- 控制同时发送的请求数量
- 避免服务器被"挤爆"
- 保证用户体验的流畅性
```

**🔸 核心概念**：
- **并发**：同时进行多个请求
- **控制**：限制同时执行的数量
- **队列**：排队等待执行的请求
- **调度**：决定哪个请求先执行

### 1.2 为什么需要并发控制


**🚫 没有控制的问题**：
```
问题场景：用户上传100张图片
如果同时发送100个请求：
❌ 浏览器连接数限制（通常6-8个）
❌ 服务器压力过大，可能崩溃
❌ 网络拥堵，响应变慢
❌ 用户界面卡顿
```

**✅ 控制后的好处**：
```
智能控制：同时只发送5个请求
✅ 服务器压力可控
✅ 网络带宽合理利用
✅ 用户界面保持响应
✅ 总体完成时间可能更短
```

### 1.3 并发控制的应用场景


| **场景** | **说明** | **推荐并发数** |
|---------|----------|---------------|
| 🖼️ **图片上传** | `大量文件上传到服务器` | `3-5个` |
| 📊 **数据导入** | `批量数据提交到后端` | `2-3个` |
| 🔍 **搜索请求** | `用户快速输入触发多次搜索` | `1个` |
| 📱 **页面加载** | `多个接口同时获取数据` | `6-8个` |

---

## 2. 🏗️ 请求队列管理机制


### 2.1 队列的基本原理


**💡 队列就像排队买票**：
```
队列工作流程：
┌─────────┐    ┌──────────┐    ┌─────────┐
│ 等待队列 │ -> │ 执行中队列 │ -> │ 完成队列 │
└─────────┘    └──────────┘    └─────────┘
     ↑              ↑              ↑
   新请求         正在发送        已完成

队列特点：
- 先进先出（FIFO）
- 有最大容量限制
- 支持优先级插队
```

### 2.2 简单队列实现


```javascript
class RequestQueue {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent; // 最大并发数
    this.running = [];      // 正在执行的请求
    this.waiting = [];      // 等待执行的请求
  }

  // 添加请求到队列
  add(requestFn) {
    return new Promise((resolve, reject) => {
      // 包装请求函数
      const task = {
        fn: requestFn,
        resolve,
        reject
      };
      
      this.waiting.push(task);
      this.process(); // 尝试执行
    });
  }

  // 处理队列
  async process() {
    // 如果正在执行的数量已达上限，等待
    if (this.running.length >= this.maxConcurrent) {
      return;
    }

    // 如果没有等待的任务，直接返回
    if (this.waiting.length === 0) {
      return;
    }

    // 取出等待队列的第一个任务
    const task = this.waiting.shift();
    this.running.push(task);

    try {
      // 执行请求
      const result = await task.fn();
      task.resolve(result);
    } catch (error) {
      task.reject(error);
    } finally {
      // 从执行队列中移除
      const index = this.running.indexOf(task);
      this.running.splice(index, 1);
      
      // 继续处理下一个
      this.process();
    }
  }
}
```

### 2.3 队列使用示例


```javascript
// 创建队列管理器
const queue = new RequestQueue(3); // 最多同时3个请求

// 模拟上传多个文件
const uploadFiles = async (files) => {
  const uploadPromises = files.map(file => {
    // 将每个上传操作加入队列
    return queue.add(() => {
      console.log(`开始上传: ${file.name}`);
      return axios.post('/upload', file);
    });
  });

  // 等待所有上传完成
  try {
    const results = await Promise.all(uploadPromises);
    console.log('所有文件上传完成');
    return results;
  } catch (error) {
    console.error('上传失败:', error);
  }
};

// 使用
const files = [
  { name: 'photo1.jpg' },
  { name: 'photo2.jpg' },
  { name: 'photo3.jpg' },
  { name: 'photo4.jpg' },
  { name: 'photo5.jpg' }
];

uploadFiles(files);
```

---

## 3. ⚡ 限制并发数量实现


### 3.1 axios并发控制工具


**🔧 使用p-limit库**（推荐方式）：
```javascript
import pLimit from 'p-limit';

// 创建限制器，最多同时执行3个
const limit = pLimit(3);

// 包装axios请求
const limitedRequest = (url, data) => {
  return limit(() => axios.post(url, data));
};

// 批量请求
const batchRequests = async () => {
  const requests = [
    limitedRequest('/api/data1', { id: 1 }),
    limitedRequest('/api/data2', { id: 2 }),
    limitedRequest('/api/data3', { id: 3 }),
    limitedRequest('/api/data4', { id: 4 }),
    limitedRequest('/api/data5', { id: 5 })
  ];

  const results = await Promise.all(requests);
  return results;
};
```

### 3.2 手动实现并发控制


```javascript
class ConcurrencyManager {
  constructor(limit = 3) {
    this.limit = limit;           // 并发限制
    this.running = 0;            // 当前运行数
    this.queue = [];             // 等待队列
  }

  async execute(requestFn) {
    return new Promise((resolve, reject) => {
      // 加入队列
      this.queue.push({
        fn: requestFn,
        resolve,
        reject
      });
      
      this.tryNext();
    });
  }

  async tryNext() {
    // 检查是否可以执行下一个
    if (this.running >= this.limit || this.queue.length === 0) {
      return;
    }

    this.running++;
    const { fn, resolve, reject } = this.queue.shift();

    try {
      const result = await fn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.tryNext(); // 递归处理下一个
    }
  }
}

// 使用示例
const manager = new ConcurrencyManager(2);

const fetchUserData = async (userId) => {
  return manager.execute(() => {
    console.log(`正在获取用户${userId}的数据...`);
    return axios.get(`/api/user/${userId}`);
  });
};

// 批量获取用户数据
const userIds = [1, 2, 3, 4, 5, 6, 7, 8];
const promises = userIds.map(id => fetchUserData(id));
Promise.all(promises).then(results => {
  console.log('所有用户数据获取完成');
});
```

### 3.3 并发数量的选择策略


**🎯 如何选择合适的并发数**：

| **场景类型** | **建议并发数** | **原因说明** |
|-------------|---------------|--------------|
| 📱 **移动端** | `2-3个` | `网络条件限制，避免卡顿` |
| 💻 **桌面端** | `4-6个` | `网络条件较好，可适当增加` |
| 🖼️ **文件上传** | `2-3个` | `占用带宽大，避免超时` |
| 📊 **数据查询** | `5-8个` | `数据量小，可适当并发` |
| 🔍 **搜索建议** | `1个` | `避免过时请求干扰` |

---

## 4. 🔄 依赖请求处理模式


### 4.1 什么是依赖请求


**💡 通俗解释**：
```
生活场景：网上购物流程
1. 先登录账户      -> 获取用户token
2. 查看商品详情    -> 需要用户身份确认权限
3. 添加到购物车    -> 需要商品ID和用户ID
4. 结算支付       -> 需要购物车信息

这就是依赖关系：后面的步骤依赖前面的结果
```

**🔸 依赖请求特点**：
- **顺序执行**：必须等前一个完成
- **数据传递**：前一个的结果是后一个的输入
- **错误中断**：前一个失败，后续无法进行

### 4.2 处理依赖请求的方法


**方式1：async/await顺序处理**
```javascript
const processOrderFlow = async (productId) => {
  try {
    // 步骤1：用户登录
    console.log('1. 正在登录...');
    const loginResult = await axios.post('/api/login', {
      username: 'user123',
      password: 'password'
    });
    const token = loginResult.data.token;

    // 步骤2：获取商品详情（需要token）
    console.log('2. 正在获取商品详情...');
    const productResult = await axios.get(`/api/product/${productId}`, {
      headers: { Authorization: `Bearer ${token}` }
    });
    const product = productResult.data;

    // 步骤3：添加到购物车（需要token和商品信息）
    console.log('3. 正在添加到购物车...');
    const cartResult = await axios.post('/api/cart', {
      productId: product.id,
      quantity: 1
    }, {
      headers: { Authorization: `Bearer ${token}` }
    });

    // 步骤4：创建订单
    console.log('4. 正在创建订单...');
    const orderResult = await axios.post('/api/order', {
      cartId: cartResult.data.cartId
    }, {
      headers: { Authorization: `Bearer ${token}` }
    });

    console.log('订单创建成功:', orderResult.data);
    return orderResult.data;

  } catch (error) {
    console.error('流程执行失败:', error.message);
    throw error;
  }
};
```

**方式2：管道模式处理**
```javascript
class RequestPipeline {
  constructor() {
    this.steps = [];
  }

  // 添加处理步骤
  addStep(name, requestFn) {
    this.steps.push({ name, fn: requestFn });
    return this; // 支持链式调用
  }

  // 执行管道
  async execute(initialData = {}) {
    let currentData = initialData;

    for (const step of this.steps) {
      try {
        console.log(`执行步骤: ${step.name}`);
        const result = await step.fn(currentData);
        
        // 将结果合并到数据中，供下一步使用
        currentData = { ...currentData, ...result };
        
      } catch (error) {
        console.error(`步骤 ${step.name} 执行失败:`, error.message);
        throw error;
      }
    }

    return currentData;
  }
}

// 使用管道处理依赖请求
const createOrderPipeline = () => {
  return new RequestPipeline()
    .addStep('登录', async (data) => {
      const response = await axios.post('/api/login', data.credentials);
      return { token: response.data.token };
    })
    .addStep('获取商品', async (data) => {
      const response = await axios.get(`/api/product/${data.productId}`, {
        headers: { Authorization: `Bearer ${data.token}` }
      });
      return { product: response.data };
    })
    .addStep('添加购物车', async (data) => {
      const response = await axios.post('/api/cart', {
        productId: data.product.id,
        quantity: data.quantity
      }, {
        headers: { Authorization: `Bearer ${data.token}` }
      });
      return { cartId: response.data.cartId };
    })
    .addStep('创建订单', async (data) => {
      const response = await axios.post('/api/order', {
        cartId: data.cartId
      }, {
        headers: { Authorization: `Bearer ${data.token}` }
      });
      return { order: response.data };
    });
};

// 执行订单流程
const executeOrder = async () => {
  const pipeline = createOrderPipeline();
  
  const result = await pipeline.execute({
    credentials: { username: 'user123', password: 'password' },
    productId: 'prod-001',
    quantity: 2
  });

  console.log('订单创建完成:', result.order);
};
```

---

## 5. 📦 批量请求优化策略


### 5.1 什么是批量请求优化


**💡 通俗理解**：
```
普通做法：一个一个买东西
- 买苹果    -> 排队、付款
- 买香蕉    -> 再次排队、付款  
- 买橙子    -> 再次排队、付款

优化做法：一次性购买
- 把所有东西放进购物车
- 一次结算付款
- 效率提升，节省时间
```

### 5.2 批量处理的实现方式


**方式1：请求合并**
```javascript
class RequestBatcher {
  constructor(batchSize = 10, delay = 100) {
    this.batchSize = batchSize;   // 批次大小
    this.delay = delay;           // 延迟时间(ms)
    this.pending = [];            // 待处理请求
    this.timer = null;            // 定时器
  }

  // 添加请求到批次
  add(url, data) {
    return new Promise((resolve, reject) => {
      this.pending.push({
        url,
        data,
        resolve,
        reject
      });

      // 如果达到批次大小，立即执行
      if (this.pending.length >= this.batchSize) {
        this.flush();
      } else {
        // 否则设置延迟执行
        this.scheduleFlush();
      }
    });
  }

  // 设置延迟执行
  scheduleFlush() {
    if (this.timer) return;

    this.timer = setTimeout(() => {
      this.flush();
    }, this.delay);
  }

  // 执行批次请求
  async flush() {
    if (this.pending.length === 0) return;

    // 清除定时器
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }

    // 取出当前批次
    const batch = this.pending.splice(0);
    
    try {
      // 构造批量请求数据
      const batchData = batch.map(item => ({
        url: item.url,
        data: item.data
      }));

      // 发送批量请求
      const response = await axios.post('/api/batch', {
        requests: batchData
      });

      // 分发结果给对应的Promise
      response.data.results.forEach((result, index) => {
        if (result.success) {
          batch[index].resolve(result.data);
        } else {
          batch[index].reject(new Error(result.error));
        }
      });

    } catch (error) {
      // 如果批量请求失败，拒绝所有Promise
      batch.forEach(item => item.reject(error));
    }
  }
}

// 使用批量处理器
const batcher = new RequestBatcher(5, 200);

// 模拟多个请求
const sendMultipleRequests = async () => {
  const promises = [];
  
  for (let i = 1; i <= 12; i++) {
    promises.push(
      batcher.add('/api/user', { id: i })
    );
  }

  try {
    const results = await Promise.all(promises);
    console.log('所有请求完成:', results);
  } catch (error) {
    console.error('批量请求失败:', error);
  }
};
```

**方式2：数据分片处理**
```javascript
// 分片处理大量数据
const chunkProcessor = {
  // 将数组分割成指定大小的块
  chunk(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  },

  // 批量处理数据
  async processBatch(dataArray, chunkSize = 50) {
    const chunks = this.chunk(dataArray, chunkSize);
    const results = [];

    for (let i = 0; i < chunks.length; i++) {
      console.log(`处理第 ${i + 1} 批，共 ${chunks.length} 批`);
      
      try {
        const chunkResult = await axios.post('/api/batch-process', {
          data: chunks[i],
          batchNumber: i + 1
        });
        
        results.push(chunkResult.data);
        
        // 可选：批次间添加延迟，避免服务器压力过大
        if (i < chunks.length - 1) {
          await this.delay(500); // 延迟500ms
        }
        
      } catch (error) {
        console.error(`第 ${i + 1} 批处理失败:`, error);
        throw error;
      }
    }

    return results.flat(); // 展平结果数组
  },

  // 延迟函数
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
};

// 使用示例
const processLargeDataset = async () => {
  const largeData = Array.from({ length: 1000 }, (_, i) => ({
    id: i + 1,
    name: `item_${i + 1}`,
    value: Math.random() * 100
  }));

  console.log(`开始处理 ${largeData.length} 条数据`);
  
  try {
    const results = await chunkProcessor.processBatch(largeData, 50);
    console.log('数据处理完成，结果数量:', results.length);
  } catch (error) {
    console.error('数据处理失败:', error);
  }
};
```

---

## 6. 🎯 请求优先级管理


### 6.1 优先级的概念


**💡 生活中的优先级**：
```
医院急诊科的排队规则：
🔴 紧急患者：生命危险，立即处理
🟡 普通患者：按顺序排队等候
🟢 体检患者：可以稍后安排

网络请求的优先级同理：
🔴 高优先级：用户关键操作（登录、支付）
🟡 中优先级：页面数据加载
🟢 低优先级：统计数据、日志上报
```

### 6.2 优先级队列实现


```javascript
class PriorityRequestQueue {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.running = [];
    
    // 按优先级分组的队列
    this.queues = {
      high: [],     // 高优先级
      medium: [],   // 中优先级  
      low: []       // 低优先级
    };
  }

  // 添加请求（带优先级）
  add(requestFn, priority = 'medium') {
    return new Promise((resolve, reject) => {
      const task = {
        fn: requestFn,
        resolve,
        reject,
        priority,
        timestamp: Date.now() // 用于同优先级排序
      };

      this.queues[priority].push(task);
      this.process();
    });
  }

  // 获取下一个要执行的任务
  getNextTask() {
    // 优先级顺序：high -> medium -> low
    const priorities = ['high', 'medium', 'low'];
    
    for (const priority of priorities) {
      if (this.queues[priority].length > 0) {
        return this.queues[priority].shift();
      }
    }
    
    return null;
  }

  // 处理队列
  async process() {
    if (this.running.length >= this.maxConcurrent) {
      return;
    }

    const task = this.getNextTask();
    if (!task) return;

    this.running.push(task);

    try {
      console.log(`执行${task.priority}优先级请求`);
      const result = await task.fn();
      task.resolve(result);
    } catch (error) {
      task.reject(error);
    } finally {
      const index = this.running.indexOf(task);
      this.running.splice(index, 1);
      this.process(); // 继续处理下一个
    }
  }
}

// 使用示例
const priorityQueue = new PriorityRequestQueue(2);

// 模拟不同优先级的请求
const simulateRequests = async () => {
  // 低优先级：日志上报
  priorityQueue.add(() => {
    console.log('上报用户行为日志');
    return axios.post('/api/log', { action: 'page_view' });
  }, 'low');

  // 高优先级：用户登录
  priorityQueue.add(() => {
    console.log('用户登录请求');
    return axios.post('/api/login', { username: 'user' });
  }, 'high');

  // 中优先级：加载商品列表
  priorityQueue.add(() => {
    console.log('加载商品列表');
    return axios.get('/api/products');
  }, 'medium');

  // 高优先级：支付请求
  priorityQueue.add(() => {
    console.log('处理支付请求');
    return axios.post('/api/payment', { amount: 100 });
  }, 'high');
};

// 执行顺序将是：登录 -> 支付 -> 商品列表 -> 日志上报
simulateRequests();
```

### 6.3 智能优先级调整


```javascript
class SmartPriorityQueue extends PriorityRequestQueue {
  constructor(maxConcurrent = 3) {
    super(maxConcurrent);
    this.retryCount = new Map(); // 重试计数
  }

  // 智能优先级调整
  adjustPriority(task) {
    const age = Date.now() - task.timestamp;
    const retries = this.retryCount.get(task) || 0;

    // 请求等待时间过长，提升优先级
    if (age > 10000 && task.priority === 'low') { // 10秒
      task.priority = 'medium';
      console.log('长等待请求优先级提升: low -> medium');
    }

    // 重试次数过多，降低优先级
    if (retries > 2 && task.priority === 'high') {
      task.priority = 'medium';
      console.log('多次重试请求优先级降低: high -> medium');
    }

    return task;
  }

  // 重写process方法，加入智能调整
  async process() {
    if (this.running.length >= this.maxConcurrent) {
      return;
    }

    // 对所有队列中的任务进行优先级调整
    ['high', 'medium', 'low'].forEach(priority => {
      this.queues[priority] = this.queues[priority].map(task => 
        this.adjustPriority(task)
      );
    });

    // 重新按优先级排序
    this.rebalanceQueues();

    const task = this.getNextTask();
    if (!task) return;

    this.running.push(task);

    try {
      const result = await task.fn();
      task.resolve(result);
      this.retryCount.delete(task); // 成功后清除重试计数
    } catch (error) {
      // 增加重试计数
      const count = this.retryCount.get(task) || 0;
      this.retryCount.set(task, count + 1);
      
      task.reject(error);
    } finally {
      const index = this.running.indexOf(task);
      this.running.splice(index, 1);
      this.process();
    }
  }

  // 重新平衡队列
  rebalanceQueues() {
    const allTasks = [
      ...this.queues.high,
      ...this.queues.medium,
      ...this.queues.low
    ];

    // 清空原队列
    this.queues = { high: [], medium: [], low: [] };

    // 重新分配
    allTasks.forEach(task => {
      this.queues[task.priority].push(task);
    });
  }
}
```

---

## 7. ⚔️ 资源竞争处理方案


### 7.1 什么是资源竞争


**💡 生活场景理解**：
```
抢购热门商品的场景：
- 1000个人同时抢100件商品
- 每个人都在疯狂点击"立即购买"
- 可能导致系统崩溃或数据错误

网络请求的资源竞争：
- 多个请求同时修改同一份数据
- 可能导致数据不一致
- 需要合理的竞争处理机制
```

### 7.2 防抖处理（防止重复提交）


```javascript
class DebounceRequestManager {
  constructor() {
    this.pendingRequests = new Map(); // 存储进行中的请求
  }

  // 生成请求的唯一标识
  getRequestKey(url, data, method = 'get') {
    return `${method.toUpperCase()}_${url}_${JSON.stringify(data || {})}`;
  }

  // 防抖请求（相同请求只执行一次）
  async debounceRequest(url, options = {}) {
    const { data, method = 'get', ...axiosOptions } = options;
    const requestKey = this.getRequestKey(url, data, method);

    // 如果相同请求正在进行中，返回同一个Promise
    if (this.pendingRequests.has(requestKey)) {
      console.log('检测到重复请求，返回进行中的请求结果');
      return this.pendingRequests.get(requestKey);
    }

    // 创建新的请求Promise
    const requestPromise = this.executeRequest(url, { data, method, ...axiosOptions });
    
    // 存储到进行中的请求
    this.pendingRequests.set(requestKey, requestPromise);

    try {
      const result = await requestPromise;
      return result;
    } finally {
      // 请求完成后从进行中列表移除
      this.pendingRequests.delete(requestKey);
    }
  }

  // 执行实际请求
  async executeRequest(url, options) {
    const { data, method, ...axiosOptions } = options;
    
    switch (method.toLowerCase()) {
      case 'post':
        return axios.post(url, data, axiosOptions);
      case 'put':
        return axios.put(url, data, axiosOptions);
      case 'delete':
        return axios.delete(url, axiosOptions);
      default:
        return axios.get(url, { params: data, ...axiosOptions });
    }
  }
}

// 使用防抖管理器
const debounceManager = new DebounceRequestManager();

// 模拟用户快速点击提交按钮
const handleSubmit = async (formData) => {
  try {
    // 即使用户疯狂点击，相同的请求只会发送一次
    const result = await debounceManager.debounceRequest('/api/submit', {
      method: 'post',
      data: formData
    });
    
    console.log('提交成功:', result.data);
  } catch (error) {
    console.error('提交失败:', error);
  }
};

// 模拟快速点击
document.getElementById('submit-btn')?.addEventListener('click', () => {
  handleSubmit({ name: '用户名', email: 'user@example.com' });
});
```

### 7.3 请求锁机制


```javascript
class RequestLockManager {
  constructor() {
    this.locks = new Map(); // 存储锁状态
  }

  // 获取锁
  async acquireLock(lockKey, timeout = 30000) {
    return new Promise((resolve, reject) => {
      // 如果锁不存在，直接获取
      if (!this.locks.has(lockKey)) {
        this.locks.set(lockKey, {
          acquired: true,
          waitingQueue: []
        });
        resolve();
        return;
      }

      // 锁已存在，加入等待队列
      const lock = this.locks.get(lockKey);
      const timeoutId = setTimeout(() => {
        // 从等待队列中移除
        const index = lock.waitingQueue.findIndex(item => item.resolve === resolve);
        if (index !== -1) {
          lock.waitingQueue.splice(index, 1);
        }
        reject(new Error(`获取锁超时: ${lockKey}`));
      }, timeout);

      lock.waitingQueue.push({
        resolve: () => {
          clearTimeout(timeoutId);
          resolve();
        },
        reject
      });
    });
  }

  // 释放锁
  releaseLock(lockKey) {
    const lock = this.locks.get(lockKey);
    if (!lock) return;

    // 如果有等待的请求，将锁交给下一个
    if (lock.waitingQueue.length > 0) {
      const next = lock.waitingQueue.shift();
      next.resolve();
    } else {
      // 没有等待的请求，删除锁
      this.locks.delete(lockKey);
    }
  }

  // 使用锁执行操作
  async withLock(lockKey, operation) {
    await this.acquireLock(lockKey);
    
    try {
      return await operation();
    } finally {
      this.releaseLock(lockKey);
    }
  }
}

// 使用锁管理器
const lockManager = new RequestLockManager();

// 模拟并发更新用户资料
const updateUserProfile = async (userId, profileData) => {
  const lockKey = `user_update_${userId}`;
  
  return lockManager.withLock(lockKey, async () => {
    console.log(`开始更新用户 ${userId} 的资料`);
    
    // 先获取当前用户数据
    const currentUser = await axios.get(`/api/user/${userId}`);
    
    // 合并新数据
    const updatedData = {
      ...currentUser.data,
      ...profileData,
      lastModified: new Date().toISOString()
    };
    
    // 更新用户数据
    const result = await axios.put(`/api/user/${userId}`, updatedData);
    
    console.log(`用户 ${userId} 资料更新完成`);
    return result;
  });
};

// 模拟并发更新（只有一个会执行，其他会等待）
Promise.all([
  updateUserProfile(123, { name: '新名字1' }),
  updateUserProfile(123, { email: 'new@email.com' }),
  updateUserProfile(123, { phone: '1234567890' })
]).then(() => {
  console.log('所有更新操作完成');
});
```

### 7.4 乐观锁处理


```javascript
class OptimisticLockManager {
  // 带版本控制的更新
  async updateWithVersion(url, data, maxRetries = 3) {
    let retries = 0;
    
    while (retries < maxRetries) {
      try {
        // 先获取当前数据和版本号
        const currentData = await axios.get(url);
        const currentVersion = currentData.data.version;
        
        // 准备更新数据（包含版本号）
        const updateData = {
          ...data,
          version: currentVersion
        };
        
        // 尝试更新
        const result = await axios.put(url, updateData);
        
        console.log('乐观锁更新成功');
        return result;
        
      } catch (error) {
        if (error.response?.status === 409) { // 版本冲突
          retries++;
          console.log(`版本冲突，进行第 ${retries} 次重试`);
          
          if (retries >= maxRetries) {
            throw new Error('超过最大重试次数，更新失败');
          }
          
          // 等待一段时间后重试
          await this.delay(Math.random() * 1000); // 随机延迟避免冲突
        } else {
          throw error;
        }
      }
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 使用乐观锁
const optimisticLock = new OptimisticLockManager();

const updateProductStock = async (productId, stockChange) => {
  try {
    await optimisticLock.updateWithVersion(`/api/product/${productId}`, {
      stockChange: stockChange
    });
    
    console.log('库存更新成功');
  } catch (error) {
    console.error('库存更新失败:', error.message);
  }
};
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 并发控制：合理限制同时执行的请求数量，避免系统过载
🔸 队列管理：按顺序处理请求，支持优先级和依赖关系
🔸 批量优化：将多个小请求合并为少数大请求，提升效率
🔸 资源竞争：处理多个请求访问同一资源的冲突问题
🔸 优先级管理：重要请求优先执行，提升用户体验
```

### 8.2 关键理解要点


**🔹 并发控制的本质**
```
不是越多越好：
- 适度并发：提升效率
- 过度并发：适得其反

选择标准：
- 网络条件：移动端2-3个，桌面端4-6个
- 请求类型：文件上传2-3个，数据查询5-8个
- 服务器能力：根据后端性能调整
```

**🔹 队列的应用价值**
```
解决的问题：
- 请求太多，服务器压力大
- 用户操作过快，响应不过来
- 网络不稳定，需要重试机制

带来的好处：
- 系统稳定性提升
- 用户体验更流畅
- 资源利用更合理
```

**🔹 批量处理的智慧**
```
什么时候用：
✅ 大量相似操作（文件上传、数据导入）
✅ 网络延迟较高的场景
✅ 服务器支持批量接口

什么时候不用：
❌ 实时性要求极高
❌ 数据相关性很强
❌ 错误处理复杂
```

### 8.3 实际应用指导


**🎯 常见应用场景**
- **文件上传**：并发控制 + 队列管理
- **数据导入**：批量处理 + 分片上传
- **页面加载**：优先级管理 + 依赖处理
- **用户操作**：防抖处理 + 锁机制

**🔧 选择策略**
```
场景分析：
1. 请求量级：小量用简单方案，大量用复杂方案
2. 实时性要求：高实时性避免批量，低实时性可批量
3. 错误容忍度：高容忍度用乐观锁，低容忍度用悲观锁
4. 系统复杂度：简单系统用基础方案，复杂系统用高级方案
```

**💡 最佳实践建议**
```
🔹 从简单开始：先实现基本功能，再逐步优化
🔹 监控指标：关注成功率、响应时间、错误率
🔹 用户体验：始终以用户感受为优化目标
🔹 渐进增强：根据实际需求选择合适的复杂度
```

### 8.4 记忆要点


**🧠 核心记忆**：
- **并发控制**：像银行排队，有序不混乱
- **队列管理**：像流水线作业，按步骤执行
- **批量处理**：像批发购买，效率更高
- **资源竞争**：像抢购商品，需要规则约束
- **优先级管理**：像急诊科排队，轻重缓急有序

**实用口诀**：
```
并发有度不贪多，队列有序不慌乱
批量合并提效率，竞争处理保数据
优先分级用户先，合理控制系统稳
```