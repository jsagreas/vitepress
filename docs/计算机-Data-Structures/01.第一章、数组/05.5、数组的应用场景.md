---
title: 5ã€æ•°ç»„çš„åº”ç”¨åœºæ™¯
---
## ğŸ“š ç›®å½•

1. [æ•°ç»„åº”ç”¨æ¦‚è¿°](#1-æ•°ç»„åº”ç”¨æ¦‚è¿°)
2. [ç®—æ³•å®ç°åº”ç”¨](#2-ç®—æ³•å®ç°åº”ç”¨)
3. [æ•°æ®ç»“æ„åŸºç¡€](#3-æ•°æ®ç»“æ„åŸºç¡€)
4. [å®é™…ä¸šåŠ¡åœºæ™¯](#4-å®é™…ä¸šåŠ¡åœºæ™¯)

---

## 1. ğŸ¯ æ•°ç»„åº”ç”¨æ¦‚è¿°


### 1.1 æ ¸å¿ƒåº”ç”¨é¢†åŸŸ

```
æ•°ç»„çš„ä¸»è¦åº”ç”¨åœºæ™¯ï¼š

ğŸ”¸ ç®—æ³•å®ç°ï¼šæ’åºã€æŸ¥æ‰¾ã€åŠ¨æ€è§„åˆ’
ğŸ”¸ æ•°æ®ç»“æ„ï¼šæ ˆã€é˜Ÿåˆ—ã€å †çš„åº•å±‚å®ç°
ğŸ”¸ ç³»ç»Ÿç¼–ç¨‹ï¼šç¼“å†²åŒºã€å†…å­˜ç®¡ç†
ğŸ”¸ ä¸šåŠ¡åº”ç”¨ï¼šæ•°æ®å¤„ç†ã€æŠ¥è¡¨ç»Ÿè®¡

é€‰æ‹©æ•°ç»„çš„å…³é”®å› ç´ ï¼š
âœ… éœ€è¦é«˜æ•ˆçš„éšæœºè®¿é—®
âœ… æ•°æ®ç±»å‹ç›¸åŒä¸”æœ‰åº
âœ… å†…å­˜ä½¿ç”¨è¦æ±‚ç´§å‡‘
âœ… é¢‘ç¹çš„éå†æ“ä½œ
```

### 1.2 æ•°ç»„ vs å…¶ä»–æ•°æ®ç»“æ„

```
ä½¿ç”¨åœºæ™¯å¯¹æ¯”ï¼š

æ•°ç»„é€‚ç”¨ï¼š
- ç´¢å¼•è®¿é—®ï¼šarr[i] 
- æ•°å­¦è®¡ç®—ï¼šçŸ©é˜µè¿ç®—
- ç¼“å­˜å‹å¥½ï¼šé¡ºåºéå†

é“¾è¡¨é€‚ç”¨ï¼š
- é¢‘ç¹æ’å…¥åˆ é™¤
- å¤§å°åŠ¨æ€å˜åŒ–

å“ˆå¸Œè¡¨é€‚ç”¨ï¼š
- é”®å€¼å¯¹å­˜å‚¨
- å¿«é€ŸæŸ¥æ‰¾

æ ‘ç»“æ„é€‚ç”¨ï¼š
- å±‚æ¬¡å…³ç³»
- èŒƒå›´æŸ¥è¯¢
```

---

## 2. ğŸ”¢ ç®—æ³•å®ç°åº”ç”¨


### 2.1 æ’åºç®—æ³•

```java
// å¿«é€Ÿæ’åº - åˆ†æ²»æ€æƒ³
public void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}

private int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return i + 1;
}

// è®¡æ•°æ’åº - çº¿æ€§æ—¶é—´æ’åº
public void countingSort(int[] arr, int maxValue) {
    int[] count = new int[maxValue + 1];
    
    // ç»Ÿè®¡é¢‘æ¬¡
    for (int num : arr) {
        count[num]++;
    }
    
    // é‡æ„æ•°ç»„
    int index = 0;
    for (int i = 0; i <= maxValue; i++) {
        while (count[i]-- > 0) {
            arr[index++] = i;
        }
    }
}
```

### 2.2 æŸ¥æ‰¾ç®—æ³•

```java
// äºŒåˆ†æŸ¥æ‰¾
public int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// æ»‘åŠ¨çª—å£æœ€å¤§å€¼
public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    int[] result = new int[n - k + 1];
    Deque<Integer> deque = new ArrayDeque<>();
    
    for (int i = 0; i < n; i++) {
        // ç§»é™¤çª—å£å¤–å…ƒç´ 
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }
        
        // ç»´æŠ¤å•è°ƒé˜Ÿåˆ—
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }
        
        deque.offerLast(i);
        
        if (i >= k - 1) {
            result[i - k + 1] = nums[deque.peekFirst()];
        }
    }
    
    return result;
}
```

### 2.3 åŠ¨æ€è§„åˆ’

```java
// æœ€å¤§å­æ•°ç»„å’Œ
public int maxSubArray(int[] nums) {
    int maxSoFar = nums[0];
    int maxEndingHere = nums[0];
    
    for (int i = 1; i < nums.length; i++) {
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
}

// ç¡¬å¸å…‘æ¢
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```

---

## 3. ğŸ—ï¸ æ•°æ®ç»“æ„åŸºç¡€


### 3.1 æ ˆçš„å®ç°

```java
public class ArrayStack<T> {
    private Object[] array;
    private int top;
    private int capacity;
    
    public ArrayStack(int capacity) {
        this.capacity = capacity;
        this.array = new Object[capacity];
        this.top = -1;
    }
    
    public void push(T item) {
        if (top >= capacity - 1) {
            throw new StackOverflowError("Stack is full");
        }
        array[++top] = item;
    }
    
    @SuppressWarnings("unchecked")
    public T pop() {
        if (top < 0) {
            throw new EmptyStackException();
        }
        T item = (T) array[top];
        array[top--] = null;
        return item;
    }
    
    public boolean isEmpty() { return top < 0; }
}
```

### 3.2 é˜Ÿåˆ—çš„å®ç°

```java
public class ArrayQueue<T> {
    private Object[] array;
    private int front, rear, size, capacity;
    
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        this.array = new Object[capacity];
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }
    
    public void enqueue(T item) {
        if (size >= capacity) {
            throw new IllegalStateException("Queue is full");
        }
        array[rear] = item;
        rear = (rear + 1) % capacity;
        size++;
    }
    
    @SuppressWarnings("unchecked")
    public T dequeue() {
        if (size == 0) {
            throw new NoSuchElementException("Queue is empty");
        }
        T item = (T) array[front];
        array[front] = null;
        front = (front + 1) % capacity;
        size--;
        return item;
    }
}
```

### 3.3 ç¼“å†²åŒºåº”ç”¨

```java
// ç¯å½¢ç¼“å†²åŒº
public class CircularBuffer {
    private byte[] buffer;
    private int head, tail, size, capacity;
    
    public CircularBuffer(int capacity) {
        this.capacity = capacity;
        this.buffer = new byte[capacity];
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    
    public boolean write(byte[] data) {
        if (data.length > capacity - size) {
            return false;
        }
        
        for (byte b : data) {
            buffer[tail] = b;
            tail = (tail + 1) % capacity;
            size++;
        }
        
        return true;
    }
    
    public byte[] read(int length) {
        int actualLength = Math.min(length, size);
        byte[] result = new byte[actualLength];
        
        for (int i = 0; i < actualLength; i++) {
            result[i] = buffer[head];
            head = (head + 1) % capacity;
            size--;
        }
        
        return result;
    }
}
```

---

## 4. ğŸ’¼ å®é™…ä¸šåŠ¡åœºæ™¯


### 4.1 æ•°æ®å¤„ç†ä¸åˆ†æ

```java
// é”€å”®æ•°æ®ç»Ÿè®¡
public class SalesAnalyzer {
    
    // è®¡ç®—æœˆåº¦é”€å”®é¢
    public double[] calculateMonthlySales(double[][] salesData) {
        double[] monthlySales = new double[salesData.length];
        
        for (int month = 0; month < salesData.length; month++) {
            for (int product = 0; product < salesData[month].length; product++) {
                monthlySales[month] += salesData[month][product];
            }
        }
        
        return monthlySales;
    }
    
    // æ‰¾å‡ºæœ€ä½³é”€å”®è¡¨ç°
    public int[] findBestPerformance(double[][] salesData) {
        double maxSales = 0;
        int bestMonth = 0, bestProduct = 0;
        
        for (int month = 0; month < salesData.length; month++) {
            for (int product = 0; product < salesData[month].length; product++) {
                if (salesData[month][product] > maxSales) {
                    maxSales = salesData[month][product];
                    bestMonth = month;
                    bestProduct = product;
                }
            }
        }
        
        return new int[]{bestMonth, bestProduct};
    }
}
```

### 4.2 å›¾åƒå¤„ç†åŸºç¡€

```java
// ç®€å•å›¾åƒå¤„ç†
public class ImageProcessor {
    
    // å›¾åƒæ¨¡ç³Š
    public int[][] blur(int[][] image, int kernelSize) {
        int height = image.length;
        int width = image[0].length;
        int[][] result = new int[height][width];
        int half = kernelSize / 2;
        
        for (int y = half; y < height - half; y++) {
            for (int x = half; x < width - half; x++) {
                int sum = 0, count = 0;
                
                for (int ky = -half; ky <= half; ky++) {
                    for (int kx = -half; kx <= half; kx++) {
                        sum += image[y + ky][x + kx];
                        count++;
                    }
                }
                
                result[y][x] = sum / count;
            }
        }
        
        return result;
    }
}
```

### 4.3 æ¸¸æˆå¼€å‘åŸºç¡€

```java
// æ¸¸æˆåœ°å›¾
public class GameMap {
    private int[][] tiles;
    private int width, height;
    
    public static final int EMPTY = 0;
    public static final int WALL = 1;
    public static final int PLAYER = 2;
    
    public GameMap(int width, int height) {
        this.width = width;
        this.height = height;
        this.tiles = new int[height][width];
    }
    
    // æ£€æŸ¥ä½ç½®æ˜¯å¦å¯é€šè¡Œ
    public boolean isWalkable(int x, int y) {
        return x >= 0 && x < width && y >= 0 && y < height && 
               tiles[y][x] != WALL;
    }
    
    // è·å–ç›¸é‚»ä½ç½®
    public List<int[]> getNeighbors(int x, int y) {
        List<int[]> neighbors = new ArrayList<>();
        int[] dx = {0, 1, 0, -1};
        int[] dy = {-1, 0, 1, 0};
        
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (isWalkable(nx, ny)) {
                neighbors.add(new int[]{nx, ny});
            }
        }
        
        return neighbors;
    }
}
```

### 4.4 ç¼“å­˜ç³»ç»Ÿ

```java
// LRUç¼“å­˜
public class LRUCache<K, V> {
    private final int capacity;
    private final Map<K, Node<K, V>> cache;
    private final Node<K, V> head, tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.head = new Node<>(null, null);
        this.tail = new Node<>(null, null);
        head.next = tail;
        tail.prev = head;
    }
    
    public V get(K key) {
        Node<K, V> node = cache.get(key);
        if (node == null) return null;
        
        moveToHead(node);
        return node.value;
    }
    
    public void put(K key, V value) {
        Node<K, V> node = cache.get(key);
        
        if (node != null) {
            node.value = value;
            moveToHead(node);
        } else {
            Node<K, V> newNode = new Node<>(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
            
            if (cache.size() > capacity) {
                Node<K, V> removed = removeTail();
                cache.remove(removed.key);
            }
        }
    }
    
    private void moveToHead(Node<K, V> node) {
        removeNode(node);
        addToHead(node);
    }
    
    private void addToHead(Node<K, V> node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node<K, V> node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private Node<K, V> removeTail() {
        Node<K, V> lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }
    
    private static class Node<K, V> {
        K key;
        V value;
        Node<K, V> prev, next;
        
        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

### 4.5 åº”ç”¨é€‰æ‹©æ€»ç»“

```
æ•°ç»„åº”ç”¨çš„æ ¸å¿ƒåœºæ™¯ï¼š

ç®—æ³•å®ç°ï¼š
âœ… æ’åºç®—æ³•ï¼ˆå¿«æ’ã€è®¡æ•°æ’åºç­‰ï¼‰
âœ… æŸ¥æ‰¾ç®—æ³•ï¼ˆäºŒåˆ†æŸ¥æ‰¾ã€æ»‘åŠ¨çª—å£ï¼‰
âœ… åŠ¨æ€è§„åˆ’ï¼ˆçŠ¶æ€æ•°ç»„ï¼‰

æ•°æ®ç»“æ„ï¼š
âœ… æ ˆã€é˜Ÿåˆ—çš„åº•å±‚å®ç°
âœ… ç¼“å†²åŒºå’Œå†…å­˜ç®¡ç†
âœ… å“ˆå¸Œè¡¨çš„æ¡¶æ•°ç»„

ä¸šåŠ¡åº”ç”¨ï¼š
âœ… æ•°æ®ç»Ÿè®¡å’Œåˆ†æ
âœ… å›¾åƒå’Œæ¸¸æˆæ•°æ®
âœ… ç¼“å­˜ç³»ç»Ÿå®ç°

é€‰æ‹©åŸåˆ™ï¼š
- é¢‘ç¹éšæœºè®¿é—® â†’ æ•°ç»„
- é¡ºåºå¤„ç†æ•°æ® â†’ æ•°ç»„
- å†…å­˜ä½¿ç”¨æ•æ„Ÿ â†’ æ•°ç»„
- é¢‘ç¹æ’å…¥åˆ é™¤ â†’ é“¾è¡¨
- é”®å€¼æŸ¥æ‰¾ â†’ å“ˆå¸Œè¡¨
```