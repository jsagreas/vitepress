---
title: 1、数组基础概念
---
## 📚 目录

1. [什么是数组](#1-什么是数组)
2. [数组的核心特点](#2-数组的核心特点)
3. [数组的内存布局](#3-数组的内存布局)
4. [数组的类型分类](#4-数组的类型分类)
5. [数组与其他数据结构的区别](#5-数组与其他数据结构的区别)
6. [数组的优缺点分析](#6-数组的优缺点分析)

---

## 1. 🎯 什么是数组


### 1.1 基本定义

数组（Array）是由**相同类型**的元素组成的**有序集合**，这些元素在内存中**连续存储**，可以通过**索引**进行访问。

### 1.2 数学角度理解

```
数组可以看作是一个映射函数：
f: [0, n-1] → ElementType
其中：
- 定义域：[0, n-1] 表示有效的索引范围
- 值域：ElementType 表示数组元素的类型
- n：数组的长度
```

### 1.3 直观理解

```
数组就像一排编号的储物柜：
┌─────┬─────┬─────┬─────┬─────┐
│  5  │  2  │  8  │  1  │  9  │
├─────┼─────┼─────┼─────┼─────┤
│ [0] │ [1] │ [2] │ [3] │ [4] │
└─────┴─────┴─────┴─────┴─────┘

特点：
- 每个柜子都有固定编号（索引）
- 柜子按顺序排列（有序性）
- 柜子大小相同（元素类型相同）
- 可以直接根据编号找到柜子（随机访问）
```

---

## 2. 🔑 数组的核心特点


### 2.1 同质性（Homogeneous）

```
✅ 正确的数组：
int[] numbers = {1, 2, 3, 4, 5};  // 所有元素都是int类型

❌ 错误的概念：
// 数组不能存储不同类型的数据
{1, "hello", 3.14, true}  // 这不是标准数组
```

### 2.2 有序性（Ordered）

```
数组中的元素有固定的位置关系：
- 每个元素都有确定的索引位置
- 索引从0开始，依次递增
- 元素的逻辑顺序与物理存储顺序一致

示例：
arr[0] 是第1个元素
arr[1] 是第2个元素
arr[n-1] 是第n个元素
```

### 2.3 随机访问性（Random Access）

```
通过索引可以在O(1)时间内访问任意元素：

访问公式：
元素地址 = 数组首地址 + 索引 × 元素大小

示例：
int[] arr = new int[5];
// 假设数组首地址为1000，int占4字节
// arr[0] 地址：1000 + 0×4 = 1000
// arr[2] 地址：1000 + 2×4 = 1008
```

### 2.4 固定大小（Fixed Size）

```
传统数组的大小在创建时确定，运行时不可改变：

Java示例：
int[] arr = new int[10];  // 大小固定为10
// arr.length 始终为10，无法修改

C++示例：
int arr[5];  // 编译时确定大小为5
```

---

## 3. 💾 数组的内存布局


### 3.1 连续存储原理

```
数组元素在内存中连续存放：

内存视图：
地址:  1000  1004  1008  1012  1016
数据:   [5]   [2]   [8]   [1]   [9]
索引:   [0]   [1]   [2]   [3]   [4]

特点：
- 相邻元素的内存地址相差一个元素的大小
- 无内存碎片，空间利用率高
- 支持缓存友好的顺序访问
```

### 3.2 地址计算公式

```
基本公式：
element_address = base_address + index × element_size

其中：
- base_address：数组起始地址
- index：元素索引
- element_size：单个元素占用的字节数

不同类型的元素大小（Java）：
- byte：1字节
- int：4字节
- long：8字节
- double：8字节
- 引用类型：4字节（32位）或8字节（64位）
```

### 3.3 内存对齐考虑

```
实际存储中可能存在内存对齐：

结构体数组示例：
struct Student {
    char name[16];  // 16字节
    int age;        // 4字节
    double score;   // 8字节
}; // 实际大小可能是32字节（考虑对齐）

影响：
- 提高CPU访问效率
- 可能浪费少量内存空间
- 地址计算需要考虑对齐后的大小
```

---

## 4. 📊 数组的类型分类


### 4.1 按维度分类

```
一维数组：
int[] arr = {1, 2, 3, 4, 5};
线性结构，类似一条线上的点

二维数组：
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
矩形结构，类似表格

多维数组：
int[][][] cube = new int[3][4][5];
高维结构，在实际应用中较少使用
```

### 4.2 按大小分类

```
静态数组（Fixed Array）：
- 编译时确定大小
- 栈上分配（通常）
- 大小不可变

动态数组（Dynamic Array）：
- 运行时确定大小
- 堆上分配
- 可以扩容（如ArrayList）

示例对比：
// 静态数组
int staticArr[100];  // C/C++

// 动态数组
int* dynamicArr = new int[size];  // C++
ArrayList<Integer> list = new ArrayList<>();  // Java
```

### 4.3 按存储方式分类

```
密集数组（Dense Array）：
- 所有位置都存储有效数据
- 空间利用率高
- 适合数据密度高的场景

稀疏数组（Sparse Array）：
- 大部分位置为空或默认值
- 需要特殊存储方式优化空间
- 适合数据稀疏的场景

示例：
// 密集数组
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 稀疏数组（大部分为0）
[0, 0, 5, 0, 0, 0, 0, 3, 0, 0]
```

---

## 5. 🔄 数组与其他数据结构的区别


### 5.1 数组 vs 链表

```
数组：
✅ 随机访问：O(1)
✅ 空间连续，缓存友好
❌ 插入删除：O(n)
❌ 大小固定

链表：
✅ 插入删除：O(1)
✅ 大小灵活
❌ 顺序访问：O(n)
❌ 空间不连续，缓存不友好
```

### 5.2 数组 vs 动态数组

```
静态数组：
✅ 内存开销小
✅ 访问速度快
❌ 大小固定
❌ 扩容困难

动态数组：
✅ 大小可变
✅ 自动扩容
❌ 额外内存开销
❌ 扩容时性能损失
```

### 5.3 数组 vs 哈希表

```
数组：
✅ 有序存储
✅ 空间效率高
✅ 支持范围操作
❌ 查找特定值：O(n)

哈希表：
✅ 查找特定值：O(1)
✅ 插入删除快
❌ 无序存储
❌ 空间开销大
```

---

## 6. ⚖️ 数组的优缺点分析


### 6.1 主要优点

```
🔸 访问效率高：
- O(1)时间复杂度的随机访问
- 通过索引直接计算地址

🔸 内存效率高：
- 连续存储，无额外指针开销
- 良好的空间局部性，缓存友好

🔸 实现简单：
- 概念直观，易于理解
- 硬件和编译器支持良好

🔸 支持多种操作：
- 排序、查找、遍历
- 数学运算（向量、矩阵）
```

### 6.2 主要缺点

```
🔸 大小固定：
- 静态分配，运行时不可调整
- 可能造成空间浪费或不足

🔸 插入删除低效：
- 需要移动大量元素
- 时间复杂度为O(n)

🔸 内存要求高：
- 需要连续的内存空间
- 大数组可能分配失败

🔸 类型限制：
- 只能存储相同类型的数据
- 缺乏灵活性
```

### 6.3 适用场景分析

```
✅ 适合使用数组的场景：
- 频繁的随机访问操作
- 数据大小相对固定
- 需要高效的遍历操作
- 数学计算（矩阵运算等）
- 实现其他数据结构的底层存储

❌ 不适合使用数组的场景：
- 频繁的插入删除操作
- 数据大小变化很大
- 需要存储不同类型的数据
- 内存空间非常有限
```

### 6.4 性能特征总结

```
时间复杂度：
- 访问：O(1)
- 查找：O(n)
- 插入：O(n)
- 删除：O(n)
- 遍历：O(n)

空间复杂度：
- 存储：O(n)
- 额外空间：O(1)

实际性能考虑：
- CPU缓存友好
- 内存访问模式规律
- 编译器优化效果好
```