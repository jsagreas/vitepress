---
title: 2、图的遍历算法
---
## 📚 目录

1. [图遍历的基本概念](#1-图遍历的基本概念)
2. [深度优先搜索(DFS)](#2-深度优先搜索dfs)
3. [广度优先搜索(BFS)](#3-广度优先搜索bfs)
4. [两种遍历算法对比](#4-两种遍历算法对比)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🚀 图遍历的基本概念


### 1.1 什么是图遍历

**定义**：按照某种策略访问图中每个顶点，且每个顶点只访问一次的过程

**图遍历的必要性**：
```
与树遍历的区别：
树：           图：
   A              A ——— B
  / \             |   / |
 B   C            |  /  |
/ \              | /   |
D  E             C ——— D

树：天然层次，不会重复访问
图：可能有环，需要标记已访问
```

### 1.2 图遍历的核心问题

```
问题1：如何避免重复访问？
解决：使用visited数组标记已访问顶点

问题2：从哪个顶点开始？
解决：可以从任意顶点开始，通常从顶点0开始

问题3：选择下一个访问顶点的策略？
解决：DFS用栈(递归)，BFS用队列
```

### 1.3 遍历的通用框架

```java
// 图遍历通用模板
void traverse(Graph graph, int start) {
    boolean[] visited = new boolean[graph.getVertexCount()];
    
    // 选择具体策略：DFS or BFS
    traverseFrom(graph, start, visited);
    
    // 处理非连通图：遍历所有未访问顶点
    for (int i = 0; i < graph.getVertexCount(); i++) {
        if (!visited[i]) {
            traverseFrom(graph, i, visited);
        }
    }
}
```

---

## 2. 🔍 深度优先搜索(DFS)


### 2.1 DFS基本思想

**策略**：沿着路径尽可能深入，直到无路可走再回退

**核心特点**：
- 使用栈结构（递归调用栈）
- 后进先出(LIFO)的访问顺序
- 优先访问最近发现的未访问邻接顶点

```
DFS遍历过程演示：
图：    A ——— B
       |   \ |
       |    \|
       C ——— D

遍历顺序：A → B → D → C
访问路径：A深入到B，B深入到D，D无未访问邻接点回退，最后访问C
```

### 2.2 DFS递归实现

```java
class GraphDFS {
    private boolean[] visited;
    private List<List<Integer>> adjList;
    
    // DFS遍历主函数
    public void dfs(int start) {
        visited = new boolean[adjList.size()];
        dfsRecursive(start);
        
        // 处理非连通图
        for (int i = 0; i < adjList.size(); i++) {
            if (!visited[i]) {
                dfsRecursive(i);
            }
        }
    }
    
    // DFS递归核心
    private void dfsRecursive(int v) {
        visited[v] = true;           // 标记当前顶点已访问
        System.out.print(v + " ");   // 处理当前顶点
        
        // 递归访问所有未访问的邻接顶点
        for (int neighbor : adjList.get(v)) {
            if (!visited[neighbor]) {
                dfsRecursive(neighbor);
            }
        }
    }
}
```

### 2.3 DFS迭代实现

```java
public void dfsIterative(int start) {
    boolean[] visited = new boolean[adjList.size()];
    Stack<Integer> stack = new Stack<>();
    
    stack.push(start);
    
    while (!stack.isEmpty()) {
        int v = stack.pop();
        
        if (!visited[v]) {
            visited[v] = true;
            System.out.print(v + " ");
            
            // 将所有未访问邻接点压入栈
            // 注意：为保持与递归相同顺序，需逆序添加
            List<Integer> neighbors = adjList.get(v);
            for (int i = neighbors.size() - 1; i >= 0; i--) {
                int neighbor = neighbors.get(i);
                if (!visited[neighbor]) {
                    stack.push(neighbor);
                }
            }
        }
    }
}
```

### 2.4 DFS的详细执行过程

```
示例图：    0 ——— 1
           |   \ |
           |    \|
           3 ——— 2

邻接表：
0: [1, 3]
1: [0, 2]  
2: [1, 3]
3: [0, 2]

DFS(0) 执行过程：
1. 访问0，标记visited[0]=true，输出0
2. 访问0的邻接点1，递归DFS(1)
3. 访问1，标记visited[1]=true，输出1  
4. 访问1的邻接点2，递归DFS(2)
5. 访问2，标记visited[2]=true，输出2
6. 访问2的邻接点3，递归DFS(3)
7. 访问3，标记visited[3]=true，输出3
8. 3的邻接点都已访问，返回
9. 所有递归结束

输出序列：0 1 2 3
```

### 2.5 DFS的应用场景

```
🔸 连通性检测：判断图是否连通
🔸 路径查找：判断两点间是否存在路径
🔸 环检测：检测图中是否存在环
🔸 拓扑排序：有向无环图的线性排序
🔸 强连通分量：Tarjan算法和Kosaraju算法
```

---

## 3. 🌊 广度优先搜索(BFS)


### 3.1 BFS基本思想

**策略**：逐层访问，先访问距离起始点近的顶点，再访问距离远的顶点

**核心特点**：
- 使用队列结构
- 先进先出(FIFO)的访问顺序
- 按距离递增顺序访问顶点

```
BFS遍历过程演示：
图：    A ——— B
       |   \ |
       |    \|
       C ——— D

遍历顺序：A → B → C → D
访问路径：
第0层：A
第1层：B, C (距离A为1的顶点)
第2层：D (距离A为2的顶点)
```

### 3.2 BFS实现

```java
class GraphBFS {
    private List<List<Integer>> adjList;
    
    public void bfs(int start) {
        boolean[] visited = new boolean[adjList.size()];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[start] = true;    // 标记起始点
        queue.offer(start);       // 起始点入队
        
        while (!queue.isEmpty()) {
            int v = queue.poll();  // 出队一个顶点
            System.out.print(v + " ");
            
            // 将所有未访问的邻接点入队
            for (int neighbor : adjList.get(v)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;  // 入队时就标记
                    queue.offer(neighbor);
                }
            }
        }
    }
    
    // 处理非连通图的完整BFS
    public void bfsComplete() {
        boolean[] visited = new boolean[adjList.size()];
        
        for (int i = 0; i < adjList.size(); i++) {
            if (!visited[i]) {
                bfsFromVertex(i, visited);
            }
        }
    }
    
    private void bfsFromVertex(int start, boolean[] visited) {
        Queue<Integer> queue = new LinkedList<>();
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int v = queue.poll();
            System.out.print(v + " ");
            
            for (int neighbor : adjList.get(v)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
    }
}
```

### 3.3 BFS的详细执行过程

```
示例图：    0 ——— 1
           |   \ |
           |    \|
           3 ——— 2

BFS(0) 执行过程：
初始：queue=[0], visited=[T,F,F,F]

步骤1：出队0，输出0
      将0的邻接点1,3入队
      queue=[1,3], visited=[T,T,F,T]

步骤2：出队1，输出1  
      将1的未访问邻接点2入队
      queue=[3,2], visited=[T,T,T,T]

步骤3：出队3，输出3
      3的邻接点都已访问
      queue=[2], visited=[T,T,T,T]

步骤4：出队2，输出2
      2的邻接点都已访问  
      queue=[], visited=[T,T,T,T]

输出序列：0 1 3 2
```

### 3.4 BFS求最短路径

```java
// BFS求无权图最短路径
public int[] shortestPath(int start) {
    int n = adjList.size();
    int[] distance = new int[n];
    int[] parent = new int[n];
    boolean[] visited = new boolean[n];
    
    Arrays.fill(distance, -1);  // -1表示不可达
    Arrays.fill(parent, -1);
    
    Queue<Integer> queue = new LinkedList<>();
    distance[start] = 0;
    visited[start] = true;
    queue.offer(start);
    
    while (!queue.isEmpty()) {
        int v = queue.poll();
        
        for (int neighbor : adjList.get(v)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                distance[neighbor] = distance[v] + 1;  // 距离+1
                parent[neighbor] = v;                  // 记录父节点
                queue.offer(neighbor);
            }
        }
    }
    
    return distance;
}

// 重构从start到target的最短路径
public List<Integer> getPath(int start, int target, int[] parent) {
    List<Integer> path = new ArrayList<>();
    for (int v = target; v != -1; v = parent[v]) {
        path.add(v);
    }
    Collections.reverse(path);
    return path;
}
```

### 3.5 BFS的应用场景

```
🔸 最短路径：无权图中的最短路径
🔸 层序遍历：按层次访问图中顶点
🔸 连通性检测：判断两点间是否连通
🔸 网络爬虫：网页的广度优先爬取
🔸 社交网络：计算社交距离(六度分隔理论)
```

---

## 4. ⚖️ 两种遍历算法对比


### 4.1 核心差异对比

```
特性        | DFS              | BFS
-----------|------------------|------------------
数据结构   | 栈(递归调用栈)    | 队列
访问策略   | 深度优先         | 广度优先  
空间复杂度  | O(h) h为最大深度  | O(w) w为最大宽度
路径特性   | 不一定是最短路径   | 保证最短路径(无权图)
适合场景   | 路径搜索、环检测   | 最短路径、层次遍历
```

### 4.2 时间复杂度分析

```
邻接表表示：
- DFS时间复杂度：O(V + E)
- BFS时间复杂度：O(V + E)

邻接矩阵表示：  
- DFS时间复杂度：O(V²)
- BFS时间复杂度：O(V²)

分析：每个顶点访问一次O(V)，每条边检查一次O(E)
```

### 4.3 空间复杂度分析

```
DFS空间复杂度：
- 递归栈深度：O(h)，h为图的最大深度
- 最坏情况：链状图，空间复杂度O(V)
- 最好情况：星状图，空间复杂度O(1)

BFS空间复杂度：
- 队列最大长度：O(w)，w为图的最大宽度  
- 最坏情况：完全图的某一层，空间复杂度O(V)
- 最好情况：链状图，空间复杂度O(1)
```

### 4.4 应用场景选择

```
选择DFS的情况：
✓ 需要遍历所有路径
✓ 检测图中的环
✓ 拓扑排序
✓ 强连通分量
✓ 回溯算法

选择BFS的情况：  
✓ 求最短路径
✓ 层次遍历
✓ 连通性检测
✓ 网络爬虫
✓ 社交网络分析
```

### 4.5 具体示例对比

```
图：    A ——— B ——— E
       |       |
       C ——— D ———

DFS可能的访问顺序：A → B → E → D → C
特点：深入到底再回退，路径可能较长

BFS访问顺序：A → B → C → E → D  
特点：逐层扩展，保证最短距离

从A到D的路径：
DFS找到：A → B → E → D (长度3)
BFS找到：A → C → D (长度2，最短)
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念

```
🔸 图遍历本质：系统访问所有顶点，避免重复访问
🔸 DFS策略：深度优先，用栈实现，适合路径搜索
🔸 BFS策略：广度优先，用队列实现，保证最短路径
🔸 复杂度分析：时间O(V+E)，空间取决于图的形状
🔸 应用选择：根据问题需求选择合适的遍历策略
```

### 5.2 关键理解要点


**🔹 为什么需要visited数组**：
```
图可能有环 → 可能重复访问顶点 → 可能无限循环
visited数组确保每个顶点只访问一次
```

**🔹 DFS和BFS的本质区别**：
```
DFS：沿着一条路走到黑，走不通再换路
BFS：同时向四面八方扩展，层层推进
数据结构决定访问顺序：栈vs队列
```

**🔹 最短路径的含义**：
```
BFS保证的是边数最少的路径，不是权重最小
仅适用于无权图或等权图
加权图需要Dijkstra等专门算法
```

### 5.3 实现要点


**通用注意事项**：
- 初始化visited数组
- 处理非连通图（多个连通分量）
- 选择合适的数据结构（栈/队列）

**DFS实现要点**：
- 递归实现简洁，迭代实现需注意栈操作
- 注意递归深度，避免栈溢出
- 可以轻松实现路径记录

**BFS实现要点**：
- 入队时就标记visited，避免重复入队
- 可以天然计算最短距离
- 需要额外空间存储每层的顶点

**核心记忆**：
- 图遍历避重复，visited数组是关键
- DFS用栈深度优先，BFS用队列广度优先
- DFS适合搜索路径，BFS保证最短距离
- 复杂度都是线性，空间取决于图形状