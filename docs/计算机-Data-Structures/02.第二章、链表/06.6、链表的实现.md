---
title: 6ã€é“¾è¡¨çš„å®ç°
---
## ğŸ“š ç›®å½•

1. [é“¾è¡¨å®ç°æ¦‚è¿°](#1-é“¾è¡¨å®ç°æ¦‚è¿°)
2. [å•å‘é“¾è¡¨å®ç°](#2-å•å‘é“¾è¡¨å®ç°)
3. [åŒå‘é“¾è¡¨å®ç°](#3-åŒå‘é“¾è¡¨å®ç°)
4. [å¾ªç¯é“¾è¡¨å®ç°](#4-å¾ªç¯é“¾è¡¨å®ç°)
5. [é“¾è¡¨å®ç°ä¼˜åŒ–](#5-é“¾è¡¨å®ç°ä¼˜åŒ–)
6. [å®ç°è¦ç‚¹æ€»ç»“](#6-å®ç°è¦ç‚¹æ€»ç»“)

---

## 1. ğŸ¯ é“¾è¡¨å®ç°æ¦‚è¿°


### 1.1 å®ç°çš„æ ¸å¿ƒè¦ç´ 

```
é“¾è¡¨å®ç°çš„å…³é”®ç»„ä»¶ï¼š

ğŸ”¸ èŠ‚ç‚¹å®šä¹‰ï¼šæ•°æ®åŸŸ + æŒ‡é’ˆåŸŸ
ğŸ”¸ é“¾è¡¨ç±»ï¼šå¤´æŒ‡é’ˆ + åŸºæœ¬æ“ä½œ
ğŸ”¸ å†…å­˜ç®¡ç†ï¼šèŠ‚ç‚¹çš„åˆ›å»ºå’Œé”€æ¯
ğŸ”¸ è¾¹ç•Œå¤„ç†ï¼šç©ºé“¾è¡¨ã€å•èŠ‚ç‚¹ç­‰ç‰¹æ®Šæƒ…å†µ
ğŸ”¸ å¼‚å¸¸å¤„ç†ï¼šè¶Šç•Œã€ç©ºæŒ‡é’ˆç­‰é”™è¯¯

å®ç°è€ƒè™‘å› ç´ ï¼š
- ç±»å‹å®‰å…¨ï¼šæ³›å‹æ”¯æŒ
- å†…å­˜æ•ˆç‡ï¼šå‡å°‘é¢å¤–å¼€é”€
- æ“ä½œå®Œæ•´æ€§ï¼šCRUDæ“ä½œé½å…¨
- ä»£ç å¥å£®æ€§ï¼šå¼‚å¸¸å’Œè¾¹ç•Œå¤„ç†
```

### 1.2 è®¾è®¡åŸåˆ™

```
é“¾è¡¨å®ç°çš„è®¾è®¡åŸåˆ™ï¼š

å°è£…æ€§ï¼š
- éšè—å†…éƒ¨èŠ‚ç‚¹ç»“æ„
- æä¾›å…¬å…±æ¥å£æ“ä½œ
- ä¿æŠ¤æ•°æ®å®Œæ•´æ€§

ä¸€è‡´æ€§ï¼š
- æ“ä½œå‘½åè§„èŒƒç»Ÿä¸€
- è¿”å›å€¼ç±»å‹ä¸€è‡´
- å¼‚å¸¸å¤„ç†ç»Ÿä¸€

é«˜æ•ˆæ€§ï¼š
- å……åˆ†åˆ©ç”¨é“¾è¡¨ä¼˜åŠ¿
- é¿å…ä¸å¿…è¦çš„éå†
- åˆç†çš„æ—¶é—´ç©ºé—´å¤æ‚åº¦

å¯æ‰©å±•æ€§ï¼š
- æ”¯æŒæ³›å‹
- æ˜“äºç»§æ‰¿å’Œæ‰©å±•
- æ¨¡å—åŒ–è®¾è®¡
```

---

## 2. ğŸ“ å•å‘é“¾è¡¨å®ç°


### 2.1 èŠ‚ç‚¹ç±»å®šä¹‰

```java
// å•å‘é“¾è¡¨èŠ‚ç‚¹
public class ListNode<T> {
    T data;
    ListNode<T> next;
    
    public ListNode(T data) {
        this.data = data;
        this.next = null;
    }
    
    public ListNode(T data, ListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}
```

### 2.2 å®Œæ•´çš„å•å‘é“¾è¡¨å®ç°

```java
public class SinglyLinkedList<T> implements Iterable<T> {
    private ListNode<T> head;
    private int size;
    
    public SinglyLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    // åŸºæœ¬ä¿¡æ¯
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
    
    // æ·»åŠ æ“ä½œ
    public void addFirst(T data) {
        head = new ListNode<>(data, head);
        size++;
    }
    
    public void addLast(T data) {
        if (head == null) {
            addFirst(data);
            return;
        }
        
        ListNode<T> current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = new ListNode<>(data);
        size++;
    }
    
    public void add(int index, T data) {
        checkIndexForAdd(index);
        
        if (index == 0) {
            addFirst(data);
            return;
        }
        
        ListNode<T> prev = getNode(index - 1);
        prev.next = new ListNode<>(data, prev.next);
        size++;
    }
    
    // åˆ é™¤æ“ä½œ
    public T removeFirst() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        T data = head.data;
        head = head.next;
        size--;
        return data;
    }
    
    public T removeLast() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        if (head.next == null) {
            return removeFirst();
        }
        
        ListNode<T> prev = head;
        while (prev.next.next != null) {
            prev = prev.next;
        }
        
        T data = prev.next.data;
        prev.next = null;
        size--;
        return data;
    }
    
    public T remove(int index) {
        checkIndex(index);
        
        if (index == 0) {
            return removeFirst();
        }
        
        ListNode<T> prev = getNode(index - 1);
        T data = prev.next.data;
        prev.next = prev.next.next;
        size--;
        return data;
    }
    
    public boolean remove(T data) {
        if (head == null) return false;
        
        if (Objects.equals(head.data, data)) {
            removeFirst();
            return true;
        }
        
        ListNode<T> current = head;
        while (current.next != null) {
            if (Objects.equals(current.next.data, data)) {
                current.next = current.next.next;
                size--;
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    // è®¿é—®æ“ä½œ
    public T get(int index) {
        return getNode(index).data;
    }
    
    public void set(int index, T data) {
        getNode(index).data = data;
    }
    
    public T getFirst() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        return head.data;
    }
    
    public T getLast() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        ListNode<T> current = head;
        while (current.next != null) {
            current = current.next;
        }
        return current.data;
    }
    
    // æŸ¥æ‰¾æ“ä½œ
    public int indexOf(T data) {
        ListNode<T> current = head;
        int index = 0;
        
        while (current != null) {
            if (Objects.equals(current.data, data)) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1;
    }
    
    public boolean contains(T data) {
        return indexOf(data) != -1;
    }
    
    // è¾…åŠ©æ–¹æ³•
    private ListNode<T> getNode(int index) {
        checkIndex(index);
        
        ListNode<T> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current;
    }
    
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(
                "Index: " + index + ", Size: " + size);
        }
    }
    
    private void checkIndexForAdd(int index) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException(
                "Index: " + index + ", Size: " + size);
        }
    }
    
    // æ¸…ç©ºé“¾è¡¨
    public void clear() {
        head = null;
        size = 0;
    }
    
    // è½¬æ¢ä¸ºæ•°ç»„
    @SuppressWarnings("unchecked")
    public T[] toArray(T[] array) {
        if (array.length < size) {
            array = (T[]) Array.newInstance(
                array.getClass().getComponentType(), size);
        }
        
        ListNode<T> current = head;
        int index = 0;
        while (current != null) {
            array[index++] = current.data;
            current = current.next;
        }
        
        if (array.length > size) {
            array[size] = null;
        }
        
        return array;
    }
    
    // è¿­ä»£å™¨æ”¯æŒ
    @Override
    public Iterator<T> iterator() {
        return new LinkedListIterator();
    }
    
    private class LinkedListIterator implements Iterator<T> {
        private ListNode<T> current = head;
        
        @Override
        public boolean hasNext() {
            return current != null;
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            T data = current.data;
            current = current.next;
            return data;
        }
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("[");
        ListNode<T> current = head;
        
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(", ");
            }
            current = current.next;
        }
        
        sb.append("]");
        return sb.toString();
    }
}
```

---

## 3. ğŸ”„ åŒå‘é“¾è¡¨å®ç°


### 3.1 åŒå‘é“¾è¡¨èŠ‚ç‚¹

```java
// åŒå‘é“¾è¡¨èŠ‚ç‚¹
public class DoublyListNode<T> {
    T data;
    DoublyListNode<T> prev;
    DoublyListNode<T> next;
    
    public DoublyListNode(T data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}
```

### 3.2 åŒå‘é“¾è¡¨å®ç°

```java
public class DoublyLinkedList<T> implements Iterable<T> {
    private DoublyListNode<T> head;
    private DoublyListNode<T> tail;
    private int size;
    
    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    // åŸºæœ¬ä¿¡æ¯
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
    
    // æ·»åŠ æ“ä½œ
    public void addFirst(T data) {
        DoublyListNode<T> newNode = new DoublyListNode<>(data);
        
        if (head == null) {
            head = tail = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
        size++;
    }
    
    public void addLast(T data) {
        DoublyListNode<T> newNode = new DoublyListNode<>(data);
        
        if (tail == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size++;
    }
    
    public void add(int index, T data) {
        checkIndexForAdd(index);
        
        if (index == 0) {
            addFirst(data);
        } else if (index == size) {
            addLast(data);
        } else {
            DoublyListNode<T> current = getNode(index);
            DoublyListNode<T> newNode = new DoublyListNode<>(data);
            
            newNode.prev = current.prev;
            newNode.next = current;
            current.prev.next = newNode;
            current.prev = newNode;
            size++;
        }
    }
    
    // åˆ é™¤æ“ä½œ
    public T removeFirst() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        T data = head.data;
        head = head.next;
        
        if (head == null) {
            tail = null;
        } else {
            head.prev = null;
        }
        
        size--;
        return data;
    }
    
    public T removeLast() {
        if (tail == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        T data = tail.data;
        tail = tail.prev;
        
        if (tail == null) {
            head = null;
        } else {
            tail.next = null;
        }
        
        size--;
        return data;
    }
    
    public T remove(int index) {
        checkIndex(index);
        
        if (index == 0) {
            return removeFirst();
        } else if (index == size - 1) {
            return removeLast();
        } else {
            DoublyListNode<T> current = getNode(index);
            return removeNode(current);
        }
    }
    
    // åˆ é™¤æŒ‡å®šèŠ‚ç‚¹ï¼ˆåŒå‘é“¾è¡¨çš„ä¼˜åŠ¿ï¼‰
    public T removeNode(DoublyListNode<T> node) {
        if (node == null) {
            throw new IllegalArgumentException("Node cannot be null");
        }
        
        T data = node.data;
        
        if (node.prev != null) {
            node.prev.next = node.next;
        } else {
            head = node.next;
        }
        
        if (node.next != null) {
            node.next.prev = node.prev;
        } else {
            tail = node.prev;
        }
        
        size--;
        return data;
    }
    
    // è®¿é—®æ“ä½œï¼ˆä¼˜åŒ–ï¼šä»è¾ƒè¿‘çš„ä¸€ç«¯å¼€å§‹ï¼‰
    public T get(int index) {
        return getNode(index).data;
    }
    
    public void set(int index, T data) {
        getNode(index).data = data;
    }
    
    // ä¼˜åŒ–çš„èŠ‚ç‚¹è·å–ï¼ˆåŒå‘éå†ï¼‰
    private DoublyListNode<T> getNode(int index) {
        checkIndex(index);
        
        if (index < size / 2) {
            // ä»å¤´éƒ¨å¼€å§‹
            DoublyListNode<T> current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
            return current;
        } else {
            // ä»å°¾éƒ¨å¼€å§‹
            DoublyListNode<T> current = tail;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
            return current;
        }
    }
    
    // åå‘éå†
    public Iterator<T> descendingIterator() {
        return new DescendingIterator();
    }
    
    private class DescendingIterator implements Iterator<T> {
        private DoublyListNode<T> current = tail;
        
        @Override
        public boolean hasNext() {
            return current != null;
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            T data = current.data;
            current = current.prev;
            return data;
        }
    }
    
    // æ­£å‘è¿­ä»£å™¨
    @Override
    public Iterator<T> iterator() {
        return new ForwardIterator();
    }
    
    private class ForwardIterator implements Iterator<T> {
        private DoublyListNode<T> current = head;
        
        @Override
        public boolean hasNext() {
            return current != null;
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            T data = current.data;
            current = current.next;
            return data;
        }
    }
    
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(
                "Index: " + index + ", Size: " + size);
        }
    }
    
    private void checkIndexForAdd(int index) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException(
                "Index: " + index + ", Size: " + size);
        }
    }
}
```

---

## 4. ğŸ” å¾ªç¯é“¾è¡¨å®ç°


### 4.1 å•å‘å¾ªç¯é“¾è¡¨

```java
public class CircularLinkedList<T> implements Iterable<T> {
    private ListNode<T> tail;  // æŒ‡å‘å°¾èŠ‚ç‚¹ï¼Œæ–¹ä¾¿æ“ä½œ
    private int size;
    
    public CircularLinkedList() {
        this.tail = null;
        this.size = 0;
    }
    
    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
    
    // æ·»åŠ åˆ°å¤´éƒ¨
    public void addFirst(T data) {
        ListNode<T> newNode = new ListNode<>(data);
        
        if (tail == null) {
            tail = newNode;
            newNode.next = newNode;  // æŒ‡å‘è‡ªå·±
        } else {
            newNode.next = tail.next;  // æ–°èŠ‚ç‚¹æŒ‡å‘åŸå¤´èŠ‚ç‚¹
            tail.next = newNode;       // å°¾èŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
        }
        size++;
    }
    
    // æ·»åŠ åˆ°å°¾éƒ¨
    public void addLast(T data) {
        addFirst(data);
        tail = tail.next;  // ç§»åŠ¨å°¾æŒ‡é’ˆ
    }
    
    // åˆ é™¤å¤´èŠ‚ç‚¹
    public T removeFirst() {
        if (tail == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        ListNode<T> head = tail.next;
        T data = head.data;
        
        if (size == 1) {
            tail = null;
        } else {
            tail.next = head.next;
        }
        
        size--;
        return data;
    }
    
    // è·å–å¤´èŠ‚ç‚¹æ•°æ®
    public T getFirst() {
        if (tail == null) {
            throw new NoSuchElementException("List is empty");
        }
        return tail.next.data;
    }
    
    // è·å–å°¾èŠ‚ç‚¹æ•°æ®
    public T getLast() {
        if (tail == null) {
            throw new NoSuchElementException("List is empty");
        }
        return tail.data;
    }
    
    // æŒ‰å€¼åˆ é™¤
    public boolean remove(T data) {
        if (tail == null) return false;
        
        ListNode<T> current = tail.next;  // å¤´èŠ‚ç‚¹
        ListNode<T> prev = tail;
        
        do {
            if (Objects.equals(current.data, data)) {
                if (size == 1) {
                    tail = null;
                } else {
                    prev.next = current.next;
                    if (current == tail) {
                        tail = prev;
                    }
                }
                size--;
                return true;
            }
            prev = current;
            current = current.next;
        } while (current != tail.next);
        
        return false;
    }
    
    // å¾ªç¯é“¾è¡¨çš„éå†
    @Override
    public Iterator<T> iterator() {
        return new CircularIterator();
    }
    
    private class CircularIterator implements Iterator<T> {
        private ListNode<T> current = tail != null ? tail.next : null;
        private int count = 0;
        
        @Override
        public boolean hasNext() {
            return count < size;
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            
            T data = current.data;
            current = current.next;
            count++;
            return data;
        }
    }
    
    // æ—‹è½¬é“¾è¡¨ï¼ˆå°†å¤´éƒ¨ç§»åŠ¨nä¸ªä½ç½®ï¼‰
    public void rotate(int n) {
        if (tail == null || size <= 1) return;
        
        n = n % size;  // å¤„ç†nå¤§äºsizeçš„æƒ…å†µ
        if (n == 0) return;
        
        for (int i = 0; i < n; i++) {
            tail = tail.next;
        }
    }
}
```

### 4.2 åŒå‘å¾ªç¯é“¾è¡¨

```java
public class DoublyCircularLinkedList<T> {
    private DoublyListNode<T> head;
    private int size;
    
    public DoublyCircularLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    public void addLast(T data) {
        DoublyListNode<T> newNode = new DoublyListNode<>(data);
        
        if (head == null) {
            head = newNode;
            newNode.next = newNode.prev = newNode;
        } else {
            DoublyListNode<T> tail = head.prev;
            
            newNode.next = head;
            newNode.prev = tail;
            tail.next = newNode;
            head.prev = newNode;
        }
        size++;
    }
    
    public void addFirst(T data) {
        addLast(data);
        head = head.prev;  // ç§»åŠ¨å¤´æŒ‡é’ˆ
    }
    
    public T removeFirst() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        T data = head.data;
        
        if (size == 1) {
            head = null;
        } else {
            DoublyListNode<T> tail = head.prev;
            DoublyListNode<T> newHead = head.next;
            
            tail.next = newHead;
            newHead.prev = tail;
            head = newHead;
        }
        
        size--;
        return data;
    }
    
    public T removeLast() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        if (size == 1) {
            return removeFirst();
        }
        
        DoublyListNode<T> tail = head.prev;
        T data = tail.data;
        
        DoublyListNode<T> newTail = tail.prev;
        newTail.next = head;
        head.prev = newTail;
        
        size--;
        return data;
    }
}
```

---

## 5. ğŸš€ é“¾è¡¨å®ç°ä¼˜åŒ–


### 5.1 å“¨å…µèŠ‚ç‚¹ä¼˜åŒ–

```java
// å¸¦å“¨å…µèŠ‚ç‚¹çš„é“¾è¡¨å®ç°
public class SentinelLinkedList<T> {
    private final ListNode<T> sentinel;  // å“¨å…µèŠ‚ç‚¹
    private int size;
    
    public SentinelLinkedList() {
        this.sentinel = new ListNode<>(null);  // å“¨å…µä¸å­˜å‚¨å®é™…æ•°æ®
        this.size = 0;
    }
    
    // ç®€åŒ–çš„æ’å…¥æ“ä½œï¼ˆæ— éœ€ç‰¹æ®Šå¤„ç†ç©ºé“¾è¡¨ï¼‰
    public void add(int index, T data) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException();
        }
        
        ListNode<T> prev = sentinel;
        for (int i = 0; i < index; i++) {
            prev = prev.next;
        }
        
        ListNode<T> newNode = new ListNode<>(data);
        newNode.next = prev.next;
        prev.next = newNode;
        size++;
    }
    
    // ç®€åŒ–çš„åˆ é™¤æ“ä½œ
    public T remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        
        ListNode<T> prev = sentinel;
        for (int i = 0; i < index; i++) {
            prev = prev.next;
        }
        
        T data = prev.next.data;
        prev.next = prev.next.next;
        size--;
        return data;
    }
    
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        
        ListNode<T> current = sentinel.next;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.data;
    }
}
```

### 5.2 å†…å­˜æ± ä¼˜åŒ–

```java
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
public class PooledLinkedList<T> {
    private static final int POOL_SIZE = 100;
    private static final Stack<ListNode<?>> nodePool = new Stack<>();
    
    static {
        // é¢„åˆ†é…èŠ‚ç‚¹
        for (int i = 0; i < POOL_SIZE; i++) {
            nodePool.push(new ListNode<>(null));
        }
    }
    
    @SuppressWarnings("unchecked")
    private ListNode<T> allocateNode(T data) {
        if (!nodePool.isEmpty()) {
            ListNode<T> node = (ListNode<T>) nodePool.pop();
            node.data = data;
            node.next = null;
            return node;
        }
        return new ListNode<>(data);
    }
    
    private void deallocateNode(ListNode<T> node) {
        if (nodePool.size() < POOL_SIZE) {
            node.data = null;
            node.next = null;
            nodePool.push(node);
        }
    }
    
    // åœ¨å®é™…çš„add/removeæ–¹æ³•ä¸­ä½¿ç”¨å¯¹è±¡æ± 
    // ...
}
```

### 5.3 å°¾æŒ‡é’ˆä¼˜åŒ–

```java
// ç»´æŠ¤å°¾æŒ‡é’ˆæé«˜å°¾éƒ¨æ“ä½œæ•ˆç‡
public class OptimizedLinkedList<T> {
    private ListNode<T> head;
    private ListNode<T> tail;
    private int size;
    
    public OptimizedLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    // O(1) å°¾éƒ¨æ·»åŠ 
    public void addLast(T data) {
        ListNode<T> newNode = new ListNode<>(data);
        
        if (head == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            tail = newNode;
        }
        size++;
    }
    
    // O(1) è·å–å°¾éƒ¨å…ƒç´ 
    public T getLast() {
        if (tail == null) {
            throw new NoSuchElementException("List is empty");
        }
        return tail.data;
    }
    
    // å…¶ä»–æ“ä½œéœ€è¦ç»´æŠ¤å°¾æŒ‡é’ˆçš„ä¸€è‡´æ€§
    public T removeFirst() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        
        T data = head.data;
        head = head.next;
        
        if (head == null) {
            tail = null;  // é“¾è¡¨å˜ç©ºæ—¶æ›´æ–°å°¾æŒ‡é’ˆ
        }
        
        size--;
        return data;
    }
}
```

---

## 6. ğŸ“‹ å®ç°è¦ç‚¹æ€»ç»“


### 6.1 å®ç°æ£€æŸ¥æ¸…å•

```
é“¾è¡¨å®ç°çš„å®Œæ•´æ€§æ£€æŸ¥ï¼š

åŸºæœ¬åŠŸèƒ½ï¼š
âœ… èŠ‚ç‚¹å®šä¹‰æ­£ç¡®
âœ… æ·»åŠ æ“ä½œï¼ˆå¤´éƒ¨ã€å°¾éƒ¨ã€æŒ‡å®šä½ç½®ï¼‰
âœ… åˆ é™¤æ“ä½œï¼ˆå¤´éƒ¨ã€å°¾éƒ¨ã€æŒ‡å®šä½ç½®ã€æŒ‰å€¼ï¼‰
âœ… è®¿é—®æ“ä½œï¼ˆè·å–ã€è®¾ç½®ã€æŸ¥æ‰¾ï¼‰
âœ… åŸºæœ¬ä¿¡æ¯ï¼ˆå¤§å°ã€æ˜¯å¦ä¸ºç©ºï¼‰

è¾¹ç•Œå¤„ç†ï¼š
âœ… ç©ºé“¾è¡¨æ“ä½œ
âœ… å•èŠ‚ç‚¹é“¾è¡¨æ“ä½œ
âœ… ç´¢å¼•è¶Šç•Œæ£€æŸ¥
âœ… ç©ºæŒ‡é’ˆå¤„ç†

æ€§èƒ½ä¼˜åŒ–ï¼š
âœ… æ—¶é—´å¤æ‚åº¦åˆç†
âœ… é¿å…ä¸å¿…è¦çš„éå†
âœ… å†…å­˜ä½¿ç”¨æ•ˆç‡
âœ… é€‚å½“çš„ä¼˜åŒ–ç­–ç•¥

ä»£ç è´¨é‡ï¼š
âœ… æ³›å‹æ”¯æŒ
âœ… å¼‚å¸¸å¤„ç†
âœ… è¿­ä»£å™¨æ”¯æŒ
âœ… æ–‡æ¡£å’Œæ³¨é‡Š
```

### 6.2 å¸¸è§å®ç°é™·é˜±

```java
// é™·é˜±1ï¼šå¿˜è®°æ›´æ–°size
public void addFirst(T data) {
    head = new ListNode<>(data, head);
    // å¿˜è®° size++; ä¼šå¯¼è‡´sizeä¸å‡†ç¡®
}

// é™·é˜±2ï¼šç©ºæŒ‡é’ˆæ£€æŸ¥ä¸è¶³
public T removeFirst() {
    // åº”è¯¥å…ˆæ£€æŸ¥ head != null
    T data = head.data;  // å¯èƒ½ç©ºæŒ‡é’ˆå¼‚å¸¸
    head = head.next;
    return data;
}

// é™·é˜±3ï¼šåŒå‘é“¾è¡¨æŒ‡é’ˆç»´æŠ¤ä¸å®Œæ•´
public void removeNode(DoublyListNode<T> node) {
    node.prev.next = node.next;
    // å¿˜è®° node.next.prev = node.prev;
}

// é™·é˜±4ï¼šå¾ªç¯é“¾è¡¨çš„æ— é™å¾ªç¯
public void traverse() {
    ListNode<T> current = head;
    while (current != null) {  // å¾ªç¯é“¾è¡¨ä¸­æ°¸è¿œä¸ä¸ºnull
        current = current.next;
    }
}
```
