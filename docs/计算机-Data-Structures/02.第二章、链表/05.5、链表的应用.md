---
title: 5ã€é“¾è¡¨çš„åº”ç”¨
---
## ğŸ“š ç›®å½•

1. [é“¾è¡¨åº”ç”¨æ¦‚è¿°](#1-é“¾è¡¨åº”ç”¨æ¦‚è¿°)
2. [æ•°æ®ç»“æ„å®ç°](#2-æ•°æ®ç»“æ„å®ç°)
3. [ç³»ç»Ÿç¼–ç¨‹åº”ç”¨](#3-ç³»ç»Ÿç¼–ç¨‹åº”ç”¨)
4. [ç®—æ³•é—®é¢˜è§£å†³](#4-ç®—æ³•é—®é¢˜è§£å†³)
5. [å®é™…é¡¹ç›®åº”ç”¨](#5-å®é™…é¡¹ç›®åº”ç”¨)

---

## 1. ğŸ¯ é“¾è¡¨åº”ç”¨æ¦‚è¿°


### 1.1 é“¾è¡¨çš„æ ¸å¿ƒåº”ç”¨åœºæ™¯

```
é“¾è¡¨çš„ä¸»è¦åº”ç”¨é¢†åŸŸï¼š

ğŸ”¸ æ•°æ®ç»“æ„å®ç°ï¼šæ ˆã€é˜Ÿåˆ—ã€å“ˆå¸Œè¡¨
ğŸ”¸ ç³»ç»Ÿç¼–ç¨‹ï¼šå†…å­˜ç®¡ç†ã€è¿›ç¨‹è°ƒåº¦
ğŸ”¸ ç®—æ³•é—®é¢˜ï¼šLRUç¼“å­˜ã€å›¾çš„é‚»æ¥è¡¨
ğŸ”¸ å®é™…é¡¹ç›®ï¼šæ’¤é”€åŠŸèƒ½ã€éŸ³ä¹æ’­æ”¾åˆ—è¡¨

é€‰æ‹©é“¾è¡¨çš„å…³é”®å› ç´ ï¼š
âœ… é¢‘ç¹çš„æ’å…¥åˆ é™¤æ“ä½œ
âœ… åŠ¨æ€æ•°æ®å¤§å°
âœ… ä¸éœ€è¦éšæœºè®¿é—®
âœ… å†…å­˜ä½¿ç”¨çµæ´»æ€§
```

### 1.2 åº”ç”¨é€‰æ‹©å†³ç­–

```
ä½•æ—¶ä½¿ç”¨é“¾è¡¨ï¼š

æ•°æ®ç‰¹å¾ï¼š
- æ•°æ®é‡ç»å¸¸å˜åŒ–
- æ’å…¥åˆ é™¤é¢‘ç¹
- é¡ºåºè®¿é—®ä¸ºä¸»

æ€§èƒ½è¦æ±‚ï¼š
- å¯¹éšæœºè®¿é—®è¦æ±‚ä¸é«˜
- å†…å­˜ä½¿ç”¨éœ€è¦çµæ´»
- å¯ä»¥æ¥å—é¢å¤–çš„æŒ‡é’ˆå¼€é”€

å®ç°å¤æ‚åº¦ï¼š
- éœ€è¦ç›¸å¯¹ç®€å•çš„å®ç°
- é€’å½’ç®—æ³•çš„å¤©ç„¶è½½ä½“
- åŠ¨æ€æ•°æ®ç»“æ„çš„åŸºç¡€
```

---

## 2. ğŸ—ï¸ æ•°æ®ç»“æ„å®ç°


### 2.1 æ ˆçš„å®ç°

```java
// é“¾è¡¨å®ç°æ ˆ
public class LinkedStack<T> {
    private Node<T> top;
    private int size;
    
    private static class Node<T> {
        T data;
        Node<T> next;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    // å…¥æ ˆ - O(1)
    public void push(T item) {
        Node<T> newNode = new Node<>(item);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    // å‡ºæ ˆ - O(1)
    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        
        T data = top.data;
        top = top.next;
        size--;
        return data;
    }
    
    // æŸ¥çœ‹æ ˆé¡¶ - O(1)
    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return top.data;
    }
    
    public boolean isEmpty() {
        return top == null;
    }
    
    public int size() {
        return size;
    }
}
```

### 2.2 é˜Ÿåˆ—çš„å®ç°

```java
// é“¾è¡¨å®ç°é˜Ÿåˆ—
public class LinkedQueue<T> {
    private Node<T> front;  // é˜Ÿå¤´
    private Node<T> rear;   // é˜Ÿå°¾
    private int size;
    
    private static class Node<T> {
        T data;
        Node<T> next;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    // å…¥é˜Ÿ - O(1)
    public void enqueue(T item) {
        Node<T> newNode = new Node<>(item);
        
        if (rear == null) {
            front = rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        size++;
    }
    
    // å‡ºé˜Ÿ - O(1)
    public T dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        
        T data = front.data;
        front = front.next;
        
        if (front == null) {
            rear = null;  // é˜Ÿåˆ—å˜ç©º
        }
        
        size--;
        return data;
    }
    
    public T peek() {
        if (isEmpty()) {
            throw new NoSuchElementException();
        }
        return front.data;
    }
    
    public boolean isEmpty() {
        return front == null;
    }
}
```

### 2.3 å“ˆå¸Œè¡¨çš„é“¾å¼è§£å†³å†²çª

```java
// å“ˆå¸Œè¡¨çš„é“¾åœ°å€æ³•
public class HashTableWithChaining<K, V> {
    private static final int DEFAULT_CAPACITY = 16;
    private LinkedList<Entry<K, V>>[] buckets;
    private int size;
    
    private static class Entry<K, V> {
        K key;
        V value;
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    @SuppressWarnings("unchecked")
    public HashTableWithChaining() {
        buckets = new LinkedList[DEFAULT_CAPACITY];
        for (int i = 0; i < DEFAULT_CAPACITY; i++) {
            buckets[i] = new LinkedList<>();
        }
    }
    
    // æ’å…¥é”®å€¼å¯¹ - å¹³å‡O(1)
    public void put(K key, V value) {
        int bucketIndex = hash(key);
        LinkedList<Entry<K, V>> bucket = buckets[bucketIndex];
        
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                entry.value = value;  // æ›´æ–°å€¼
                return;
            }
        }
        
        // æ·»åŠ æ–°æ¡ç›®
        bucket.add(new Entry<>(key, value));
        size++;
    }
    
    // è·å–å€¼ - å¹³å‡O(1)
    public V get(K key) {
        int bucketIndex = hash(key);
        LinkedList<Entry<K, V>> bucket = buckets[bucketIndex];
        
        for (Entry<K, V> entry : bucket) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
        }
        
        return null;  // æœªæ‰¾åˆ°
    }
    
    private int hash(K key) {
        return Math.abs(key.hashCode()) % buckets.length;
    }
}
```

---

## 3. ğŸ’» ç³»ç»Ÿç¼–ç¨‹åº”ç”¨


### 3.1 å†…å­˜ç®¡ç†

```java
// ç®€åŒ–çš„å†…å­˜åˆ†é…å™¨
public class SimpleMemoryAllocator {
    private FreeBlock freeList;  // ç©ºé—²å—é“¾è¡¨
    
    private static class FreeBlock {
        long address;
        int size;
        FreeBlock next;
        
        FreeBlock(long address, int size) {
            this.address = address;
            this.size = size;
        }
    }
    
    // åˆ†é…å†…å­˜
    public long allocate(int requestedSize) {
        FreeBlock prev = null;
        FreeBlock current = freeList;
        
        // å¯»æ‰¾åˆé€‚çš„ç©ºé—²å—
        while (current != null) {
            if (current.size >= requestedSize) {
                long allocatedAddress = current.address;
                
                if (current.size == requestedSize) {
                    // æ­£å¥½åŒ¹é…ï¼Œç§»é™¤æ•´ä¸ªå—
                    if (prev == null) {
                        freeList = current.next;
                    } else {
                        prev.next = current.next;
                    }
                } else {
                    // åˆ†å‰²å—
                    current.address += requestedSize;
                    current.size -= requestedSize;
                }
                
                return allocatedAddress;
            }
            
            prev = current;
            current = current.next;
        }
        
        return -1;  // åˆ†é…å¤±è´¥
    }
    
    // é‡Šæ”¾å†…å­˜
    public void deallocate(long address, int size) {
        FreeBlock newBlock = new FreeBlock(address, size);
        
        // æ’å…¥åˆ°ç©ºé—²é“¾è¡¨ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…éœ€è¦åˆå¹¶ç›¸é‚»å—ï¼‰
        newBlock.next = freeList;
        freeList = newBlock;
    }
}
```

### 3.2 è¿›ç¨‹è°ƒåº¦

```java
// ç®€åŒ–çš„è¿›ç¨‹è°ƒåº¦å™¨
public class ProcessScheduler {
    private ProcessNode readyQueue;  // å°±ç»ªé˜Ÿåˆ—
    private ProcessNode current;     // å½“å‰è¿›ç¨‹
    
    private static class ProcessNode {
        int processId;
        int priority;
        int timeSlice;
        ProcessNode next;
        
        ProcessNode(int id, int priority, int timeSlice) {
            this.processId = id;
            this.priority = priority;
            this.timeSlice = timeSlice;
        }
    }
    
    // æ·»åŠ è¿›ç¨‹åˆ°å°±ç»ªé˜Ÿåˆ—
    public void addProcess(int processId, int priority, int timeSlice) {
        ProcessNode newProcess = new ProcessNode(processId, priority, timeSlice);
        
        if (readyQueue == null || priority > readyQueue.priority) {
            // é«˜ä¼˜å…ˆçº§ï¼Œæ’å…¥é˜Ÿå¤´
            newProcess.next = readyQueue;
            readyQueue = newProcess;
        } else {
            // æŒ‰ä¼˜å…ˆçº§æ’å…¥
            ProcessNode current = readyQueue;
            while (current.next != null && 
                   current.next.priority >= priority) {
                current = current.next;
            }
            newProcess.next = current.next;
            current.next = newProcess;
        }
    }
    
    // è°ƒåº¦ä¸‹ä¸€ä¸ªè¿›ç¨‹
    public ProcessNode schedule() {
        if (readyQueue == null) {
            return null;
        }
        
        ProcessNode next = readyQueue;
        readyQueue = readyQueue.next;
        current = next;
        
        return next;
    }
    
    // æ—¶é—´ç‰‡è€—å°½ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
    public void timeSliceExpired() {
        if (current != null) {
            addProcess(current.processId, current.priority - 1, 
                      current.timeSlice);  // é™ä½ä¼˜å…ˆçº§
        }
    }
}
```

---

## 4. ğŸ”§ ç®—æ³•é—®é¢˜è§£å†³


### 4.1 LRUç¼“å­˜å®ç°

```java
// LRUç¼“å­˜ - å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨
public class LRUCache {
    private final int capacity;
    private final Map<Integer, Node> cache;
    private final Node head;
    private final Node tail;
    
    private static class Node {
        int key, value;
        Node prev, next;
        
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        
        // å“¨å…µèŠ‚ç‚¹
        this.head = new Node(0, 0);
        this.tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    // è·å–å€¼ - O(1)
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        
        // ç§»åŠ¨åˆ°å¤´éƒ¨ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
        moveToHead(node);
        return node.value;
    }
    
    // è®¾ç½®å€¼ - O(1)
    public void put(int key, int value) {
        Node node = cache.get(key);
        
        if (node != null) {
            // æ›´æ–°ç°æœ‰èŠ‚ç‚¹
            node.value = value;
            moveToHead(node);
        } else {
            // æ·»åŠ æ–°èŠ‚ç‚¹
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
            
            // æ£€æŸ¥å®¹é‡
            if (cache.size() > capacity) {
                Node removed = removeTail();
                cache.remove(removed.key);
            }
        }
    }
    
    private void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    private Node removeTail() {
        Node lastNode = tail.prev;
        removeNode(lastNode);
        return lastNode;
    }
}
```

### 4.2 å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º

```java
// å›¾çš„é‚»æ¥è¡¨å®ç°
public class Graph {
    private final int vertices;
    private final LinkedList<Edge>[] adjacencyList;
    
    private static class Edge {
        int destination;
        int weight;
        
        Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }
    }
    
    @SuppressWarnings("unchecked")
    public Graph(int vertices) {
        this.vertices = vertices;
        this.adjacencyList = new LinkedList[vertices];
        
        for (int i = 0; i < vertices; i++) {
            adjacencyList[i] = new LinkedList<>();
        }
    }
    
    // æ·»åŠ è¾¹
    public void addEdge(int source, int destination, int weight) {
        adjacencyList[source].add(new Edge(destination, weight));
        // æ— å‘å›¾éœ€è¦æ·»åŠ åå‘è¾¹
        // adjacencyList[destination].add(new Edge(source, weight));
    }
    
    // æ·±åº¦ä¼˜å…ˆæœç´¢
    public void dfs(int startVertex) {
        boolean[] visited = new boolean[vertices];
        dfsHelper(startVertex, visited);
    }
    
    private void dfsHelper(int vertex, boolean[] visited) {
        visited[vertex] = true;
        System.out.print(vertex + " ");
        
        // éå†é‚»æ¥é¡¶ç‚¹
        for (Edge edge : adjacencyList[vertex]) {
            if (!visited[edge.destination]) {
                dfsHelper(edge.destination, visited);
            }
        }
    }
    
    // å¹¿åº¦ä¼˜å…ˆæœç´¢
    public void bfs(int startVertex) {
        boolean[] visited = new boolean[vertices];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[startVertex] = true;
        queue.offer(startVertex);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            System.out.print(vertex + " ");
            
            for (Edge edge : adjacencyList[vertex]) {
                if (!visited[edge.destination]) {
                    visited[edge.destination] = true;
                    queue.offer(edge.destination);
                }
            }
        }
    }
}
```

### 4.3 å¤šé¡¹å¼è¿ç®—

```java
// å¤šé¡¹å¼çš„é“¾è¡¨è¡¨ç¤º
public class Polynomial {
    private TermNode head;
    
    private static class TermNode {
        int coefficient;  // ç³»æ•°
        int exponent;     // æŒ‡æ•°
        TermNode next;
        
        TermNode(int coefficient, int exponent) {
            this.coefficient = coefficient;
            this.exponent = exponent;
        }
    }
    
    // æ·»åŠ é¡¹ï¼ˆæŒ‰æŒ‡æ•°é™åºï¼‰
    public void addTerm(int coefficient, int exponent) {
        if (coefficient == 0) return;
        
        TermNode newTerm = new TermNode(coefficient, exponent);
        
        if (head == null || exponent > head.exponent) {
            newTerm.next = head;
            head = newTerm;
            return;
        }
        
        TermNode current = head;
        while (current.next != null && 
               current.next.exponent > exponent) {
            current = current.next;
        }
        
        if (current.next != null && 
            current.next.exponent == exponent) {
            // åˆå¹¶åŒç±»é¡¹
            current.next.coefficient += coefficient;
            if (current.next.coefficient == 0) {
                current.next = current.next.next;
            }
        } else {
            newTerm.next = current.next;
            current.next = newTerm;
        }
    }
    
    // å¤šé¡¹å¼ç›¸åŠ 
    public Polynomial add(Polynomial other) {
        Polynomial result = new Polynomial();
        TermNode p1 = this.head;
        TermNode p2 = other.head;
        
        while (p1 != null && p2 != null) {
            if (p1.exponent > p2.exponent) {
                result.addTerm(p1.coefficient, p1.exponent);
                p1 = p1.next;
            } else if (p1.exponent < p2.exponent) {
                result.addTerm(p2.coefficient, p2.exponent);
                p2 = p2.next;
            } else {
                int sum = p1.coefficient + p2.coefficient;
                if (sum != 0) {
                    result.addTerm(sum, p1.exponent);
                }
                p1 = p1.next;
                p2 = p2.next;
            }
        }
        
        // æ·»åŠ å‰©ä½™é¡¹
        while (p1 != null) {
            result.addTerm(p1.coefficient, p1.exponent);
            p1 = p1.next;
        }
        
        while (p2 != null) {
            result.addTerm(p2.coefficient, p2.exponent);
            p2 = p2.next;
        }
        
        return result;
    }
}
```

---

## 5. ğŸ¯ å®é™…é¡¹ç›®åº”ç”¨


### 5.1 æ’¤é”€åŠŸèƒ½å®ç°

```java
// æ–‡æ¡£ç¼–è¾‘å™¨çš„æ’¤é”€åŠŸèƒ½
public class DocumentEditor {
    private CommandNode undoStack;
    private CommandNode redoStack;
    
    private static class CommandNode {
        Command command;
        CommandNode next;
        
        CommandNode(Command command) {
            this.command = command;
        }
    }
    
    private interface Command {
        void execute();
        void undo();
    }
    
    // æ‰§è¡Œå‘½ä»¤
    public void executeCommand(Command command) {
        command.execute();
        
        // æ·»åŠ åˆ°æ’¤é”€æ ˆ
        CommandNode node = new CommandNode(command);
        node.next = undoStack;
        undoStack = node;
        
        // æ¸…ç©ºé‡åšæ ˆ
        redoStack = null;
    }
    
    // æ’¤é”€æ“ä½œ
    public void undo() {
        if (undoStack == null) {
            return;
        }
        
        Command command = undoStack.command;
        undoStack = undoStack.next;
        
        command.undo();
        
        // æ·»åŠ åˆ°é‡åšæ ˆ
        CommandNode node = new CommandNode(command);
        node.next = redoStack;
        redoStack = node;
    }
    
    // é‡åšæ“ä½œ
    public void redo() {
        if (redoStack == null) {
            return;
        }
        
        Command command = redoStack.command;
        redoStack = redoStack.next;
        
        command.execute();
        
        // æ·»åŠ åˆ°æ’¤é”€æ ˆ
        CommandNode node = new CommandNode(command);
        node.next = undoStack;
        undoStack = node;
    }
}
```

### 5.2 éŸ³ä¹æ’­æ”¾å™¨

```java
// éŸ³ä¹æ’­æ”¾å™¨çš„æ’­æ”¾åˆ—è¡¨
public class Playlist {
    private SongNode head;
    private SongNode current;
    private boolean isLooping;
    
    private static class SongNode {
        String title;
        String artist;
        int duration;
        SongNode next;
        SongNode prev;  // åŒå‘é“¾è¡¨æ”¯æŒå‰ä¸€é¦–
        
        SongNode(String title, String artist, int duration) {
            this.title = title;
            this.artist = artist;
            this.duration = duration;
        }
    }
    
    // æ·»åŠ æ­Œæ›²
    public void addSong(String title, String artist, int duration) {
        SongNode newSong = new SongNode(title, artist, duration);
        
        if (head == null) {
            head = newSong;
            if (isLooping) {
                newSong.next = newSong;
                newSong.prev = newSong;
            }
        } else {
            SongNode tail = head.prev != null ? head.prev : findTail();
            
            if (isLooping) {
                // å¾ªç¯æ’­æ”¾åˆ—è¡¨
                newSong.next = head;
                newSong.prev = tail;
                tail.next = newSong;
                head.prev = newSong;
            } else {
                tail.next = newSong;
                newSong.prev = tail;
            }
        }
    }
    
    // æ’­æ”¾ä¸‹ä¸€é¦–
    public SongNode playNext() {
        if (current == null) {
            current = head;
        } else {
            current = current.next;
        }
        return current;
    }
    
    // æ’­æ”¾ä¸Šä¸€é¦–
    public SongNode playPrevious() {
        if (current == null) {
            current = head;
        } else {
            current = current.prev;
        }
        return current;
    }
    
    // éšæœºæ’­æ”¾
    public SongNode shuffle() {
        if (head == null) return null;
        
        // ç®€å•çš„éšæœºé€‰æ‹©
        Random random = new Random();
        int count = getPlaylistSize();
        int target = random.nextInt(count);
        
        SongNode song = head;
        for (int i = 0; i < target; i++) {
            song = song.next;
        }
        
        current = song;
        return current;
    }
    
    private SongNode findTail() {
        SongNode tail = head;
        while (tail.next != null) {
            tail = tail.next;
        }
        return tail;
    }
    
    private int getPlaylistSize() {
        int count = 0;
        SongNode node = head;
        while (node != null) {
            count++;
            node = node.next;
            if (isLooping && node == head) break;
        }
        return count;
    }
}
```

### 5.3 æµè§ˆå™¨å†å²è®°å½•

```java
// æµè§ˆå™¨å†å²è®°å½•ç®¡ç†
public class BrowserHistory {
    private HistoryNode current;
    private int maxSize;
    private int size;
    
    private static class HistoryNode {
        String url;
        String title;
        long timestamp;
        HistoryNode prev;
        HistoryNode next;
        
        HistoryNode(String url, String title) {
            this.url = url;
            this.title = title;
            this.timestamp = System.currentTimeMillis();
        }
    }
    
    public BrowserHistory(String homepage, int maxSize) {
        this.current = new HistoryNode(homepage, "Homepage");
        this.maxSize = maxSize;
        this.size = 1;
    }
    
    // è®¿é—®æ–°é¡µé¢
    public void visit(String url, String title) {
        HistoryNode newPage = new HistoryNode(url, title);
        
        if (current != null) {
            // æ¸…é™¤å½“å‰é¡µé¢ä¹‹åçš„å†å²
            current.next = null;
            
            newPage.prev = current;
            current.next = newPage;
        }
        
        current = newPage;
        size++;
        
        // é™åˆ¶å†å²è®°å½•å¤§å°
        if (size > maxSize) {
            removeOldest();
        }
    }
    
    // åé€€
    public String back() {
        if (current != null && current.prev != null) {
            current = current.prev;
            return current.url;
        }
        return null;
    }
    
    // å‰è¿›
    public String forward() {
        if (current != null && current.next != null) {
            current = current.next;
            return current.url;
        }
        return null;
    }
    
    // è·å–å†å²è®°å½•åˆ—è¡¨
    public List<String> getHistory() {
        List<String> history = new ArrayList<>();
        HistoryNode node = getHead();
        
        while (node != null) {
            history.add(node.url);
            node = node.next;
        }
        
        return history;
    }
    
    private HistoryNode getHead() {
        HistoryNode head = current;
        while (head != null && head.prev != null) {
            head = head.prev;
        }
        return head;
    }
    
    private void removeOldest() {
        HistoryNode head = getHead();
        if (head != null && head.next != null) {
            head.next.prev = null;
            size--;
        }
    }
}
```

### 5.4 åº”ç”¨åœºæ™¯æ€»ç»“

```java
/*
é“¾è¡¨åº”ç”¨åœºæ™¯æ€»ç»“ï¼š

æ•°æ®ç»“æ„å®ç°ï¼š
âœ… æ ˆå’Œé˜Ÿåˆ—çš„åŠ¨æ€å®ç°
âœ… å“ˆå¸Œè¡¨çš„å†²çªè§£å†³
âœ… å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
âœ… æ ‘çš„å­èŠ‚ç‚¹é“¾æ¥

ç³»ç»Ÿç¼–ç¨‹ï¼š
âœ… å†…å­˜ç®¡ç†çš„ç©ºé—²å—é“¾è¡¨
âœ… è¿›ç¨‹è°ƒåº¦çš„å°±ç»ªé˜Ÿåˆ—
âœ… è®¾å¤‡é©±åŠ¨çš„è¯·æ±‚é˜Ÿåˆ—
âœ… æ–‡ä»¶ç³»ç»Ÿçš„ç›®å½•ç»“æ„

ç®—æ³•é—®é¢˜ï¼š
âœ… LRUç¼“å­˜çš„é«˜æ•ˆå®ç°
âœ… å¤šé¡¹å¼çš„ç¨€ç–è¡¨ç¤º
âœ… å¤§æ•´æ•°çš„è¿ç®—
âœ… å›¾ç®—æ³•çš„åŸºç¡€ç»“æ„

å®é™…é¡¹ç›®ï¼š
âœ… æ’¤é”€é‡åšåŠŸèƒ½
âœ… æ’­æ”¾åˆ—è¡¨ç®¡ç†
âœ… æµè§ˆå™¨å†å²è®°å½•
âœ… æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿ

é€‰æ‹©åŸåˆ™ï¼š
1. åŠ¨æ€æ•°æ®å¤§å°éœ€æ±‚
2. é¢‘ç¹çš„æ’å…¥åˆ é™¤æ“ä½œ
3. ä¸éœ€è¦éšæœºè®¿é—®
4. éœ€è¦ä¿æŒæ’å…¥é¡ºåº
5. å†…å­˜ä½¿ç”¨çš„çµæ´»æ€§

å®æ–½å»ºè®®ï¼š
1. æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©é“¾è¡¨ç±»å‹
2. è€ƒè™‘æ€§èƒ½è¦æ±‚å’Œå†…å­˜é™åˆ¶
3. è¯„ä¼°ç»´æŠ¤å¤æ‚åº¦
4. å¿…è¦æ—¶ç»“åˆå…¶ä»–æ•°æ®ç»“æ„
5. æ³¨æ„å¹¶å‘å®‰å…¨é—®é¢˜
*/
```