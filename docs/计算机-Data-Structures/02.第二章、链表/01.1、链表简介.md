---
title: 1、链表简介
---
## 📚 目录

1. [链表基本概念](#1-链表基本概念)
2. [链表的核心特点](#2-链表的核心特点)
3. [链表与数组的对比](#3-链表与数组的对比)
4. [链表的基本结构](#4-链表的基本结构)
5. [链表的优缺点分析](#5-链表的优缺点分析)

---

## 1. 🎯 链表基本概念


### 1.1 什么是链表

```
链表（Linked List）是一种线性数据结构：
- 由一系列节点（Node）组成
- 每个节点包含数据和指向下一个节点的指针
- 节点在内存中不连续存储
- 通过指针链接形成逻辑上的线性序列

基本组成：
- 节点（Node）：数据 + 指针
- 头节点（Head）：链表的起始节点
- 尾节点（Tail）：指针为null的节点
```

### 1.2 链表的逻辑结构

```
单链表示意图：
Head → [data|next] → [data|next] → [data|null]
       Node1        Node2        Node3

内存分布（非连续）：
地址:  1000   1500   800
数据:  [A|→]  [B|→]  [C|null]
       ↓      ↓      ↑
       1500   800    尾节点
```

### 1.3 节点的基本结构

```java
// 链表节点的定义
public class ListNode {
    int val;           // 数据域
    ListNode next;     // 指针域
    
    // 构造函数
    public ListNode(int val) {
        this.val = val;
        this.next = null;
    }
    
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

### 1.4 链表的基本概念

```
重要概念：

节点（Node）：
- 数据域：存储实际数据
- 指针域：存储下一个节点的地址

头指针（Head）：
- 指向链表第一个节点
- 链表的入口点

空链表：
- Head指针为null
- 不包含任何节点

链表长度：
- 链表中节点的个数
- 需要遍历计算得出
```

---

## 2. 🔑 链表的核心特点


### 2.1 动态性

```
链表的动态特性：

内存动态分配：
✅ 运行时动态创建节点
✅ 大小可以动态增长和缩减
✅ 不需要预先声明大小
✅ 内存使用更加灵活

vs 数组的静态性：
❌ 编译时确定大小
❌ 大小固定不可变
❌ 可能浪费或不足
```

### 2.2 非连续存储

```
内存存储特点：

链表存储：
- 节点在内存中随机分布
- 通过指针建立逻辑连接
- 物理地址不连续

数组存储：
- 元素在内存中连续存储
- 通过索引直接访问
- 物理地址连续

影响：
✅ 链表：灵活的内存分配
❌ 链表：缓存性能较差
✅ 数组：缓存友好
❌ 数组：内存分配限制
```

### 2.3 顺序访问

```
访问方式特点：

链表访问：
- 只能从头节点开始
- 逐个节点向后遍历
- 无法直接跳转到任意位置
- 访问第n个元素需要O(n)时间

数组访问：
- 可以直接通过索引访问
- arr[i]直接定位到第i个元素
- 访问任意元素都是O(1)时间
```

### 2.4 指针依赖

```
链表的指针特性：

指针的作用：
- 连接各个节点
- 维持逻辑顺序
- 支持动态操作

指针的开销：
- 额外的内存空间
- 每个节点多存储一个指针
- 64位系统中指针占8字节

指针的风险：
- 空指针异常
- 内存泄漏
- 悬挂指针
```

---

## 3. ⚖️ 链表与数组的对比


### 3.1 核心差异对比表

```
特性对比：

特性        | 链表        | 数组
----------- |------------ |-----------
内存分配     | 动态        | 静态
存储方式     | 非连续      | 连续
访问方式     | 顺序访问    | 随机访问
插入删除     | O(1)*      | O(n)
随机访问     | O(n)       | O(1)
内存开销     | 高(指针)    | 低
缓存性能     | 差          | 好
大小限制     | 灵活        | 固定

注：*链表的O(1)插入删除是指已知节点位置的情况
```

### 3.2 时间复杂度对比

```java
// 操作复杂度示例
public class ComplexityComparison {
    
    // 链表操作复杂度
    /*
    访问元素：O(n) - 需要遍历到目标位置
    查找元素：O(n) - 需要逐个比较
    插入元素：O(1) - 已知位置时
    删除元素：O(1) - 已知位置时
    */
    
    // 数组操作复杂度
    /*
    访问元素：O(1) - 直接索引访问
    查找元素：O(n) - 线性搜索，O(log n) - 二分搜索
    插入元素：O(n) - 需要移动元素
    删除元素：O(n) - 需要移动元素
    */
}
```

### 3.3 适用场景分析

```
链表适用场景：
✅ 频繁的插入删除操作
✅ 数据量大小不确定
✅ 不需要随机访问
✅ 内存使用需要灵活控制

数组适用场景：
✅ 频繁的随机访问
✅ 数据量相对固定
✅ 对缓存性能要求高
✅ 需要数学运算(如矩阵)

实际选择依据：
- 操作模式：插删多用链表，访问多用数组
- 性能要求：时间敏感用数组，空间敏感看情况
- 数据特征：动态用链表，静态用数组
```

---

## 4. 🏗️ 链表的基本结构


### 4.1 简单链表实现

```java
// 基础链表类
public class SimpleLinkedList {
    private ListNode head;  // 头指针
    private int size;       // 链表长度
    
    public SimpleLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    // 获取链表长度
    public int size() {
        return size;
    }
    
    // 判断链表是否为空
    public boolean isEmpty() {
        return head == null;
    }
    
    // 在头部插入节点
    public void addFirst(int val) {
        ListNode newNode = new ListNode(val);
        newNode.next = head;
        head = newNode;
        size++;
    }
    
    // 获取第一个节点的值
    public int getFirst() {
        if (head == null) {
            throw new NoSuchElementException("List is empty");
        }
        return head.val;
    }
}
```

### 4.2 节点操作示例

```java
// 基本节点操作
public class NodeOperations {
    
    // 创建链表: 1 -> 2 -> 3
    public ListNode createSampleList() {
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        
        node1.next = node2;
        node2.next = node3;
        
        return node1;  // 返回头节点
    }
    
    // 遍历链表
    public void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val);
            if (current.next != null) {
                System.out.print(" -> ");
            }
            current = current.next;
        }
        System.out.println(" -> null");
    }
    
    // 计算链表长度
    public int getLength(ListNode head) {
        int length = 0;
        ListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }
        return length;
    }
}
```

### 4.3 内存模型理解

```java
// 内存分配示例
public class MemoryModel {
    
    /*
    链表内存模型：
    
    栈内存：
    head → 地址1000
    
    堆内存：
    地址1000: [val:1, next:地址2000]  ← node1
    地址2000: [val:2, next:地址3000]  ← node2  
    地址3000: [val:3, next:null]     ← node3
    
    特点：
    1. 节点分散在堆内存中
    2. 通过next指针连接
    3. 最后一个节点next为null
    4. head指针指向第一个节点
    */
    
    public void demonstrateMemoryLayout() {
        // 创建节点时，JVM在堆中分配内存
        ListNode node1 = new ListNode(1);  // 在堆中分配
        ListNode node2 = new ListNode(2);  // 在堆中分配
        ListNode node3 = new ListNode(3);  // 在堆中分配
        
        // 建立连接，实际是存储内存地址
        node1.next = node2;  // node1的next域存储node2的地址
        node2.next = node3;  // node2的next域存储node3的地址
        node3.next = null;   // node3的next域为null
    }
}
```

---

## 5. 📊 链表的优缺点分析


### 5.1 主要优点

```
链表的核心优势：

🔸 动态内存管理：
- 运行时动态分配和释放内存
- 不需要预先确定数据结构大小
- 避免内存浪费或不足的问题

🔸 高效的插入删除：
- 在已知位置插入/删除：O(1)
- 不需要移动其他元素
- 特别适合频繁的增删操作

🔸 内存利用灵活：
- 按需分配，用多少分配多少
- 支持不规则的内存使用模式
- 可以有效利用碎片化内存

🔸 实现简单：
- 基本操作实现相对简单
- 递归算法的天然载体
- 便于理解和教学
```

### 5.2 主要缺点

```
链表的主要劣势：

🔸 无法随机访问：
- 访问第n个元素需要O(n)时间
- 不支持二分查找等高效算法
- 无法利用数组的索引优势

🔸 额外内存开销：
- 每个节点需要存储指针
- 内存开销比数组大
- 指针占用空间（4字节或8字节）

🔸 缓存性能差：
- 节点在内存中分散存储
- CPU缓存命中率低
- 不利于现代处理器优化

🔸 指针操作复杂：
- 容易出现空指针异常
- 内存泄漏风险
- 调试相对困难
```

### 5.3 性能特征总结

```java
// 链表性能特征示例
public class PerformanceCharacteristics {
    
    /*
    时间复杂度总结：
    - 访问：O(n)  - 需要遍历到目标位置
    - 搜索：O(n)  - 线性搜索
    - 插入：O(1)  - 已知位置时
    - 删除：O(1)  - 已知位置时
    - 遍历：O(n)  - 访问所有元素
    
    空间复杂度：
    - 存储：O(n)  - n个节点
    - 额外：O(1)  - 常数个指针变量
    
    实际性能考虑：
    - 小数据量：链表开销相对较大
    - 大数据量：动态性优势明显
    - 频繁增删：链表性能优势突出
    - 频繁访问：数组性能明显更好
    */
    
    // 性能测试示例
    public void performanceTest() {
        // 这里只是说明性代码，不做具体实现
        System.out.println("链表适合：频繁插入删除的场景");
        System.out.println("数组适合：频繁随机访问的场景");
    }
}
```

### 5.4 选择指导原则

```
何时选择链表：

✅ 推荐使用链表：
- 数据量大小不确定或经常变化
- 频繁在中间位置插入或删除
- 内存使用需要灵活控制
- 实现栈、队列等其他数据结构
- 不需要频繁的随机访问

❌ 不推荐使用链表：
- 需要频繁的随机访问
- 需要进行排序或二分查找
- 对内存使用效率要求极高
- 数据量很小且相对固定
- 需要高性能的数值计算

决策流程：
1. 分析主要操作类型（增删 vs 访问）
2. 评估数据量的变化特征
3. 考虑性能要求和限制
4. 权衡开发和维护成本
```

### 5.5 实际应用考量

```
实际开发中的考虑因素：

语言支持：
- Java：ArrayList vs LinkedList
- C++：vector vs list
- Python：list（实际是动态数组）

框架选择：
- 大多数情况下：使用现成的集合类
- 特殊需求：自定义实现链表
- 算法竞赛：手动实现链表

性能权衡：
- 现代CPU：缓存友好性越来越重要
- 内存：链表的额外开销需要考虑
- 并发：链表的并发控制更复杂

总结：
链表是重要的数据结构概念，但在实际开发中
要根据具体场景选择最合适的数据结构。
```