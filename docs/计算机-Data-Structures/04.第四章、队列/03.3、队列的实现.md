---
title: 3、队列的实现
---
## 📚 目录

1. [队列实现方式概述](#1-队列实现方式概述)
2. [顺序队列实现](#2-顺序队列实现)
3. [循环队列实现](#3-循环队列实现)
4. [链式队列实现](#4-链式队列实现)
5. [实现方式对比](#5-实现方式对比)

---

## 1. 🎯 队列实现方式概述


### 1.1 主要实现方式

```
队列的三种核心实现：

1. 顺序队列（数组实现）
   - 使用固定大小的数组
   - 维护front和rear指针
   - 存在"假溢出"问题

2. 循环队列（数组实现）
   - 解决顺序队列的假溢出问题
   - 数组空间循环使用
   - 最常用的数组实现方式

3. 链式队列（链表实现）
   - 使用链表存储元素
   - 动态分配内存
   - 没有容量限制
```

### 1.2 选择标准

```
实现方式的选择依据：

固定容量 + 高性能 → 循环队列
动态容量 + 灵活性 → 链式队列
简单理解 + 学习用 → 顺序队列

关键考虑因素：
- 内存使用效率
- 操作性能要求
- 容量是否固定
- 实现复杂度
```

---

## 2. 📊 顺序队列实现


### 2.1 基本数据结构

```java
public class ArrayQueue<T> {
    private Object[] array;
    private int front;      // 队头指针
    private int rear;       // 队尾指针（指向下一个插入位置）
    private int capacity;
    
    public ArrayQueue(int capacity) {
        this.array = new Object[capacity];
        this.front = 0;
        this.rear = 0;
        this.capacity = capacity;
    }
}
```

### 2.2 核心操作实现

```java
// 入队操作
public void enqueue(T element) {
    if (rear >= capacity) {
        throw new IllegalStateException("队列已满");
    }
    array[rear++] = element;
}

// 出队操作
@SuppressWarnings("unchecked")
public T dequeue() {
    if (front >= rear) {
        throw new IllegalStateException("队列为空");
    }
    T element = (T) array[front];
    array[front++] = null;  // 清除引用
    return element;
}

// 状态查询
public boolean isEmpty() {
    return front >= rear;
}

public boolean isFull() {
    return rear >= capacity;
}
```

### 2.3 顺序队列的问题

```
"假溢出"问题：

初始状态：[_, _, _, _]  front=0, rear=0
入队A,B：  [A, B, _, _]  front=0, rear=2
出队A：    [_, B, _, _]  front=1, rear=2
出队B：    [_, _, _, _]  front=2, rear=2
入队C,D：  [_, _, C, D]  front=2, rear=4

问题：front前面的空间无法重复使用
解决：使用循环队列
```

---

## 3. 🔄 循环队列实现


### 3.1 循环队列原理

```
循环队列的关键思想：
- 将数组看作环形结构
- 指针到达数组末尾时回到开头
- 使用取模运算实现循环

指针更新公式：
next_pos = (current_pos + 1) % capacity

循环示意图：
┌─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │  3  │
└─────┴─────┴─────┴─────┘
   ↑                   │
   └───────────────────┘
```

### 3.2 循环队列实现

```java
public class CircularQueue<T> {
    private Object[] array;
    private int front;      // 队头指针
    private int rear;       // 队尾指针
    private int size;       // 当前元素个数
    private int capacity;
    
    public CircularQueue(int capacity) {
        this.array = new Object[capacity];
        this.front = 0;
        this.rear = 0;
        this.size = 0;
        this.capacity = capacity;
    }
    
    // 入队操作
    public void enqueue(T element) {
        if (size >= capacity) {
            throw new IllegalStateException("队列已满");
        }
        array[rear] = element;
        rear = (rear + 1) % capacity;  // 循环更新
        size++;
    }
    
    // 出队操作
    @SuppressWarnings("unchecked")
    public T dequeue() {
        if (size == 0) {
            throw new IllegalStateException("队列为空");
        }
        T element = (T) array[front];
        array[front] = null;
        front = (front + 1) % capacity;  // 循环更新
        size--;
        return element;
    }
    
    // 状态查询
    public boolean isEmpty() { return size == 0; }
    public boolean isFull() { return size == capacity; }
    public int size() { return size; }
}
```

### 3.3 循环队列的关键点

```
实现要点：

1. 使用size变量：
   - 明确区分空队列和满队列
   - 简化判空和判满逻辑

2. 取模运算：
   - rear = (rear + 1) % capacity
   - front = (front + 1) % capacity
   - 确保指针在有效范围内

3. 避免浪费空间：
   - 不使用"留一个空位"的方法
   - 通过size变量精确控制状态
```

---

## 4. 🔗 链式队列实现


### 4.1 链式队列结构

```java
// 节点定义
class Node<T> {
    T data;
    Node<T> next;
    
    Node(T data) {
        this.data = data;
        this.next = null;
    }
}

// 链式队列
public class LinkedQueue<T> {
    private Node<T> front;  // 队头节点
    private Node<T> rear;   // 队尾节点
    private int size;
    
    public LinkedQueue() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
}
```

### 4.2 链式队列操作

```java
// 入队操作
public void enqueue(T element) {
    Node<T> newNode = new Node<>(element);
    
    if (rear == null) {
        // 空队列情况
        front = rear = newNode;
    } else {
        // 一般情况
        rear.next = newNode;
        rear = newNode;
    }
    size++;
}

// 出队操作
public T dequeue() {
    if (front == null) {
        throw new IllegalStateException("队列为空");
    }
    
    T element = front.data;
    front = front.next;
    
    // 队列变空时，rear也要置空
    if (front == null) {
        rear = null;
    }
    size--;
    return element;
}

// 查看队头
public T front() {
    if (front == null) {
        throw new IllegalStateException("队列为空");
    }
    return front.data;
}

// 状态查询
public boolean isEmpty() { return front == null; }
public int size() { return size; }
```

### 4.3 链式队列特点

```
链式队列的优势：
✅ 动态容量，无大小限制
✅ 内存按需分配
✅ 不会出现"假溢出"

链式队列的劣势：
❌ 额外的指针存储开销
❌ 内存分配频繁
❌ 缓存性能较差

关键注意点：
- 空队列时front和rear都为null
- 队列变空时要同时更新front和rear
- 入队时要特别处理空队列情况
```

---

## 5. ⚖️ 实现方式对比


### 5.1 性能对比

```
三种实现的性能比较：

实现方式    | 时间复杂度 | 空间复杂度 | 内存效率 | 缓存性能
----------|----------|----------|---------|--------
顺序队列   | O(1)     | O(n)     | 低      | 好
循环队列   | O(1)     | O(n)     | 高      | 好
链式队列   | O(1)     | O(n)     | 中      | 差

说明：
- 所有操作都是O(1)时间复杂度
- 循环队列空间利用率最高
- 数组实现缓存性能更好
```

### 5.2 适用场景

```
选择建议：

循环队列适用于：
✅ 容量相对固定的场景
✅ 性能要求较高的应用
✅ 内存使用需要精确控制
✅ 系统底层实现

链式队列适用于：
✅ 容量变化很大的场景
✅ 无法预估最大容量
✅ 对内存分配不敏感
✅ 需要动态扩展的应用

实际工程选择：
- Java的ArrayDeque：基于循环数组
- Java的LinkedList：基于双向链表
- C++的std::queue：通常基于deque
```

### 5.3 实现复杂度对比

```
实现难度评估：

顺序队列：⭐⭐
- 最简单，容易理解
- 有假溢出问题
- 适合学习使用

循环队列：⭐⭐⭐
- 中等复杂度
- 需要理解取模运算
- 工程中最常用

链式队列：⭐⭐⭐⭐
- 相对复杂
- 需要处理指针操作
- 边界情况较多

推荐学习顺序：
顺序队列 → 循环队列 → 链式队列
```

### 5.4 内存布局对比

```
内存使用分析：

循环队列内存布局：
┌─────┬─────┬─────┬─────┐ + 几个整型变量
│ 元素1│ 元素2│ 元素3│ 元素4│
└─────┴─────┴─────┴─────┘
连续内存，缓存友好

链式队列内存布局：
┌─────┬──┐    ┌─────┬──┐    ┌─────┬──┐
│ 元素1│指针│->│ 元素2│指针│->│ 元素3│空│
└─────┴──┘    └─────┴──┘    └─────┴──┘
分散内存，指针开销

空间开销计算：
- 循环队列：n个元素 + 常数个变量
- 链式队列：n个元素 + n个指针 + 头尾指针
```

---

## 💡 核心要点总结


```
队列实现的关键要点：

必须掌握的实现：
1. 循环队列：工程中最常用，性能最优
2. 链式队列：理解指针操作，处理动态场景
3. 顺序队列：理解基本原理，认识假溢出问题

核心技术点：
- 循环队列的取模运算
- 链式队列的指针维护
- 空队列和满队列的判断
- 内存管理和引用清理

性能关键：
- 所有基本操作都应该是O(1)
- 循环队列空间效率最高
- 数组实现缓存性能更好
- 选择实现要考虑具体应用场景

实际应用：
- 高性能场景优选循环队列
- 动态容量需求选择链式队列
- 学习理解从顺序队列开始
```