---
title: 2、队列的基本操作
---
## 📚 目录

1. [队列核心操作概述](#1-队列核心操作概述)
2. [入队操作详解](#2-入队操作详解)
3. [出队操作详解](#3-出队操作详解)
4. [辅助操作实现](#4-辅助操作实现)
5. [操作复杂度分析](#5-操作复杂度分析)

---

## 1. 🎯 队列核心操作概述


### 1.1 必须掌握的基本操作

```
队列的五大核心操作：

1. enqueue(element) - 入队
   - 在队尾插入新元素
   - 队列长度增加1

2. dequeue() - 出队
   - 从队头删除并返回元素
   - 队列长度减少1

3. front() / peek() - 查看队头
   - 返回队头元素但不删除
   - 队列状态不变

4. isEmpty() - 判空
   - 检查队列是否为空
   - 防止空队列出队

5. size() - 获取长度
   - 返回当前元素个数
   - 队列状态查询
```

### 1.2 队列操作的抽象接口

```java
// 队列操作的标准接口
public interface Queue<T> {
    // 核心操作
    void enqueue(T element);    // 入队
    T dequeue();               // 出队
    T front();                 // 查看队头
    
    // 状态查询
    boolean isEmpty();         // 判空
    int size();               // 获取长度
}
```

### 1.3 操作前置条件

```
操作的前置条件和异常处理：

入队操作：
- 前置条件：队列未满（如果有容量限制）
- 异常情况：队列满时抛出异常或返回false

出队操作：
- 前置条件：队列非空
- 异常情况：空队列时抛出异常或返回null

查看队头：
- 前置条件：队列非空
- 异常情况：空队列时抛出异常或返回null
```

---

## 2. ➡️ 入队操作详解


### 2.1 入队操作原理

```
入队（enqueue）操作流程：

步骤1：检查队列状态
- 判断队列是否已满
- 如果满了，处理溢出情况

步骤2：插入新元素
- 在队尾位置插入元素
- 更新队尾指针

步骤3：更新队列状态
- 元素个数加1
- 必要时更新相关指针

操作示意图：
插入前：[A, B, C]        队尾↑
插入后：[A, B, C, D]        队尾↑
```

### 2.2 入队操作实现

```java
// 入队操作的核心实现
public class ArrayQueue<T> {
    private Object[] array;
    private int front;  // 队头指针
    private int rear;   // 队尾指针
    private int size;   // 当前元素个数
    private int capacity;
    
    public void enqueue(T element) {
        // 检查队列是否已满
        if (size >= capacity) {
            throw new IllegalStateException("队列已满");
        }
        
        // 在队尾插入元素
        array[rear] = element;
        rear = (rear + 1) % capacity;  // 循环队列处理
        size++;
    }
}
```

### 2.3 入队异常处理

```java
// 入队的不同处理策略
public boolean offer(T element) {
    // 策略1：返回boolean表示是否成功
    if (size >= capacity) {
        return false;  // 入队失败
    }
    enqueue(element);
    return true;      // 入队成功
}

public void enqueue(T element) {
    // 策略2：抛出异常
    if (size >= capacity) {
        throw new IllegalStateException("Queue is full");
    }
    // 执行入队操作...
}
```

---

## 3. ⬅️ 出队操作详解


### 3.1 出队操作原理

```
出队（dequeue）操作流程：

步骤1：检查队列状态
- 判断队列是否为空
- 如果空了，处理下溢情况

步骤2：获取队头元素
- 保存队头元素用于返回
- 清除队头位置的引用

步骤3：更新队列状态
- 更新队头指针
- 元素个数减1

操作示意图：
删除前：[A, B, C, D]  队头↑
删除后：[B, C, D]        队头↑  (返回A)
```

### 3.2 出队操作实现

```java
@SuppressWarnings("unchecked")
public T dequeue() {
    // 检查队列是否为空
    if (isEmpty()) {
        throw new IllegalStateException("队列为空");
    }
    
    // 获取队头元素
    T element = (T) array[front];
    array[front] = null;  // 清除引用，帮助GC
    
    // 更新队头指针和大小
    front = (front + 1) % capacity;  // 循环队列处理
    size--;
    
    return element;
}
```

### 3.3 出队异常处理

```java
// 出队的不同处理策略
public T poll() {
    // 策略1：返回null表示队列为空
    if (isEmpty()) {
        return null;
    }
    return dequeue();
}

public T dequeue() {
    // 策略2：抛出异常
    if (isEmpty()) {
        throw new NoSuchElementException("Queue is empty");
    }
    // 执行出队操作...
}
```

---

## 4. 🔍 辅助操作实现


### 4.1 查看队头操作

```java
// 查看队头元素（不删除）
@SuppressWarnings("unchecked")
public T front() {
    if (isEmpty()) {
        throw new IllegalStateException("队列为空");
    }
    return (T) array[front];
}

// 安全版本
public T peek() {
    return isEmpty() ? null : (T) array[front];
}
```

### 4.2 状态查询操作

```java
// 判断队列是否为空
public boolean isEmpty() {
    return size == 0;
}

// 判断队列是否已满
public boolean isFull() {
    return size == capacity;
}

// 获取队列长度
public int size() {
    return size;
}

// 获取剩余容量
public int remainingCapacity() {
    return capacity - size;
}
```

### 4.3 清空操作

```java
// 清空队列
public void clear() {
    // 清除所有元素引用
    for (int i = 0; i < capacity; i++) {
        array[i] = null;
    }
    
    // 重置指针和计数器
    front = 0;
    rear = 0;
    size = 0;
}
```

---

## 5. 📊 操作复杂度分析


### 5.1 时间复杂度总结

```
队列基本操作的时间复杂度：

操作类型        | 时间复杂度 | 说明
-------------- |----------|------------------
enqueue入队     | O(1)     | 直接在队尾插入
dequeue出队     | O(1)     | 直接从队头删除
front查看队头   | O(1)     | 直接访问队头元素
isEmpty判空     | O(1)     | 检查size变量
size获取长度    | O(1)     | 返回size变量
clear清空       | O(n)     | 需要清除所有引用

核心特点：
- 所有主要操作都是O(1)常数时间
- 不需要移动其他元素
- 性能稳定，不受队列大小影响
```

### 5.2 空间复杂度分析

```
队列的空间开销：

基本存储空间：
- 元素存储：O(n)，n为队列容量
- 指针存储：O(1)，front、rear、size等

额外空间开销：
- 循环队列：可能有1个位置的浪费
- 链式队列：每个节点额外的指针开销
- 动态扩容：临时的双倍空间开销

空间利用率：
- 数组实现：接近100%
- 链表实现：由于指针开销，约50-70%
```

### 5.3 不同实现的性能对比

```
数组队列 vs 链表队列：

性能维度      | 数组队列   | 链表队列
-------------|----------|----------
时间复杂度    | O(1)     | O(1)
空间开销      | 低       | 高
缓存性能      | 好       | 差
内存分配      | 一次性    | 频繁分配
容量限制      | 固定     | 动态
随机访问      | 支持     | 不支持

选择建议：
- 性能优先：选择数组实现
- 动态大小：选择链表实现
- 内存受限：选择数组实现
```

### 5.4 操作效率的关键因素

```
影响队列操作效率的因素：

1. 实现方式
   - 数组：连续内存，缓存友好
   - 链表：离散内存，指针跳转

2. 容量管理
   - 固定容量：避免动态分配开销
   - 动态扩容：可能引起O(n)的扩容操作

3. 内存管理
   - 及时清除引用：帮助垃圾回收
   - 避免内存泄漏：正确管理对象生命周期

优化要点：
- 合理设置初始容量
- 及时清理无用引用
- 选择合适的实现方式
```

---

## 💡 核心要点总结


```
队列操作的关键要点：

必须掌握的操作：
1. enqueue：队尾入队，O(1)时间
2. dequeue：队头出队，O(1)时间
3. front：查看队头，不删除元素
4. isEmpty：防止空队列操作
5. size：获取当前元素个数

操作注意事项：
- 入队前检查是否队满
- 出队前检查是否队空
- 正确处理循环队列的指针更新
- 及时清除引用避免内存泄漏

性能特征：
- 所有基本操作都是O(1)
- 空间复杂度为O(n)
- 数组实现性能最优
- 适合频繁的入队出队操作
```