---
title: 4、队列的类型
---
## 📚 目录

1. [队列类型概述](#1-队列类型概述)
2. [普通队列与循环队列](#2-普通队列与循环队列)
3. [双端队列详解](#3-双端队列详解)
4. [优先队列详解](#4-优先队列详解)
5. [队列类型选择](#5-队列类型选择)

---

## 1. 🎯 队列类型概述


### 1.1 主要队列类型

```
必须掌握的四种队列类型：

1. 普通队列（Simple Queue）
   - 标准的FIFO队列
   - 只能队尾入队，队头出队
   - 最基础的队列形式

2. 循环队列（Circular Queue）
   - 解决空间浪费问题的队列
   - 数组空间循环使用
   - 实际应用中最常见

3. 双端队列（Deque）
   - 两端都可以入队和出队
   - 比普通队列更灵活
   - 可以实现栈和队列的功能

4. 优先队列（Priority Queue）
   - 按元素优先级出队
   - 不遵循FIFO原则
   - 通常用堆实现
```

### 1.2 队列类型的层次关系

```
队列类型层次：

基础队列
├── 普通队列 (FIFO)
├── 循环队列 (空间优化的FIFO)
└── 变种队列
    ├── 双端队列 (两端操作)
    └── 优先队列 (按优先级)

选择原则：
- 标准FIFO需求 → 普通/循环队列
- 需要两端操作 → 双端队列  
- 需要按优先级 → 优先队列
```

---

## 2. 🔄 普通队列与循环队列


### 2.1 普通队列特征

```
普通队列（线性队列）：

基本特点：
- 严格遵循FIFO原则
- 队头固定出队，队尾固定入队
- 实现简单，容易理解

存在问题：
- 数组实现存在假溢出
- 空间利用率低
- 需要额外的空间整理

适用场景：
- 算法学习和理解
- 简单的缓冲需求
- 对性能要求不高的场合
```

### 2.2 循环队列特征

```java
// 循环队列的核心特点
public class CircularQueue<T> {
    private Object[] array;
    private int front, rear, size, capacity;
    
    // 关键：使用取模运算实现循环
    public void enqueue(T element) {
        if (size >= capacity) throw new IllegalStateException("队列已满");
        array[rear] = element;
        rear = (rear + 1) % capacity;  // 循环更新
        size++;
    }
    
    public T dequeue() {
        if (size == 0) throw new IllegalStateException("队列为空");
        T element = (T) array[front];
        array[front] = null;
        front = (front + 1) % capacity;  // 循环更新
        size--;
        return element;
    }
}
```

### 2.3 普通队列 vs 循环队列

```
对比分析：

特性        | 普通队列   | 循环队列
----------- |----------|----------
空间利用率   | 低       | 高
实现复杂度   | 简单     | 中等
假溢出问题   | 存在     | 解决
工程应用     | 少       | 广泛

性能对比：
- 时间复杂度：都是O(1)
- 空间复杂度：都是O(n)
- 空间利用率：循环队列接近100%，普通队列可能很低

结论：实际应用中应该选择循环队列
```

---

## 3. 🔀 双端队列详解


### 3.1 双端队列概念

```
双端队列（Double-ended Queue, Deque）：

基本特点：
- 两端都可以进行插入和删除操作
- 结合了栈和队列的特性
- 提供了更大的操作灵活性

四种基本操作：
- addFirst()  : 头部插入
- addLast()   : 尾部插入  
- removeFirst(): 头部删除
- removeLast() : 尾部删除

操作示意：
    addFirst    addLast
        ↓          ↓
    ←─[元素1][元素2][元素3]─→
        ↑          ↑
   removeFirst  removeLast
```

### 3.2 双端队列实现

```java
// 基于循环数组的双端队列
public class ArrayDeque<T> {
    private Object[] array;
    private int head, tail, size;
    private int capacity;
    
    // 头部插入
    public void addFirst(T element) {
        if (size >= capacity) throw new IllegalStateException("队列已满");
        head = (head - 1 + capacity) % capacity;  // 向前移动
        array[head] = element;
        size++;
    }
    
    // 尾部插入
    public void addLast(T element) {
        if (size >= capacity) throw new IllegalStateException("队列已满");
        array[tail] = element;
        tail = (tail + 1) % capacity;  // 向后移动
        size++;
    }
    
    // 头部删除
    @SuppressWarnings("unchecked")
    public T removeFirst() {
        if (size == 0) throw new IllegalStateException("队列为空");
        T element = (T) array[head];
        array[head] = null;
        head = (head + 1) % capacity;
        size--;
        return element;
    }
    
    // 尾部删除
    @SuppressWarnings("unchecked")
    public T removeLast() {
        if (size == 0) throw new IllegalStateException("队列为空");
        tail = (tail - 1 + capacity) % capacity;
        T element = (T) array[tail];
        array[tail] = null;
        size--;
        return element;
    }
}
```

### 3.3 双端队列的应用

```
双端队列的典型应用：

1. 实现栈：
   - push() → addFirst()
   - pop()  → removeFirst()

2. 实现队列：
   - enqueue() → addLast()
   - dequeue() → removeFirst()

3. 滑动窗口问题：
   - 维护窗口最大值/最小值
   - 头部删除过期元素
   - 尾部添加新元素

4. 缓存LRU实现：
   - 头部表示最近使用
   - 尾部表示最久未使用
```

---

## 4. 🏆 优先队列详解


### 4.1 优先队列概念

```
优先队列（Priority Queue）：

基本特点：
- 元素按优先级顺序出队，不是FIFO
- 高优先级元素优先出队
- 入队位置由优先级决定

与普通队列的区别：
普通队列：[A, B, C] → 出队顺序：A, B, C
优先队列：[A(3), B(1), C(2)] → 出队顺序：A, C, B
（数字表示优先级，数字越大优先级越高）

实现方式：
- 数组实现：O(n)插入，O(1)删除
- 堆实现：O(log n)插入，O(log n)删除 ✅推荐
```

### 4.2 基于堆的优先队列实现

```java
// 最大堆实现的优先队列
public class PriorityQueue<T extends Comparable<T>> {
    private Object[] heap;
    private int size;
    private int capacity;
    
    public PriorityQueue(int capacity) {
        this.heap = new Object[capacity];
        this.size = 0;
        this.capacity = capacity;
    }
    
    // 入队（向上调整）
    @SuppressWarnings("unchecked")
    public void enqueue(T element) {
        if (size >= capacity) throw new IllegalStateException("队列已满");
        
        heap[size] = element;
        int current = size;
        size++;
        
        // 向上调整维护堆性质
        while (current > 0) {
            int parent = (current - 1) / 2;
            if (((T)heap[current]).compareTo((T)heap[parent]) <= 0) break;
            
            // 交换
            Object temp = heap[current];
            heap[current] = heap[parent];
            heap[parent] = temp;
            current = parent;
        }
    }
    
    // 出队（向下调整）
    @SuppressWarnings("unchecked")
    public T dequeue() {
        if (size == 0) throw new IllegalStateException("队列为空");
        
        T result = (T) heap[0];
        heap[0] = heap[--size];  // 移动最后一个元素到根
        heap[size] = null;
        
        // 向下调整维护堆性质
        heapify(0);
        return result;
    }
    
    @SuppressWarnings("unchecked")
    private void heapify(int index) {
        int largest = index;
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        
        if (left < size && ((T)heap[left]).compareTo((T)heap[largest]) > 0) {
            largest = left;
        }
        if (right < size && ((T)heap[right]).compareTo((T)heap[largest]) > 0) {
            largest = right;
        }
        
        if (largest != index) {
            Object temp = heap[index];
            heap[index] = heap[largest];
            heap[largest] = temp;
            heapify(largest);
        }
    }
}
```

### 4.3 优先队列的应用场景

```
优先队列的典型应用：

1. 任务调度系统：
   - 高优先级任务优先执行
   - 操作系统进程调度

2. 算法中的应用：
   - Dijkstra最短路径算法
   - Huffman编码
   - A*搜索算法

3. 事件驱动模拟：
   - 按时间顺序处理事件
   - 游戏引擎事件系统

4. 数据处理：
   - Top K问题
   - 合并K个有序链表
```

---

## 5. 🎯 队列类型选择


### 5.1 选择决策树

```
队列类型选择指南：

需要标准FIFO吗？
├─ 是 → 需要优化空间利用率吗？
│      ├─ 是 → 循环队列
│      └─ 否 → 普通队列
└─ 否 → 需要按优先级处理吗？
       ├─ 是 → 优先队列
       └─ 否 → 需要两端操作吗？
              ├─ 是 → 双端队列
              └─ 否 → 重新评估需求
```

### 5.2 性能特征对比

```
四种队列类型的性能对比：

队列类型    | 入队复杂度 | 出队复杂度 | 空间复杂度 | 适用场景
----------|----------|----------|----------|----------
普通队列   | O(1)     | O(1)     | O(n)     | 学习理解
循环队列   | O(1)     | O(1)     | O(n)     | 通用缓冲
双端队列   | O(1)     | O(1)     | O(n)     | 灵活操作
优先队列   | O(log n) | O(log n) | O(n)     | 优先级处理

总结：
- 标准应用选择循环队列
- 复杂需求选择双端队列
- 优先级需求选择优先队列
```

### 5.3 实际应用建议

```
工程实践中的选择：

1. 系统缓冲区：循环队列
   - 高性能，空间效率高
   - 固定容量，适合底层实现

2. 用户界面组件：双端队列
   - 支持撤销/重做功能
   - 灵活的数据操作需求

3. 任务调度器：优先队列
   - 按重要性执行任务
   - 实时系统的需求

4. 通用数据结构：
   - Java：ArrayDeque（双端队列）
   - Python：collections.deque
   - C++：std::queue, std::priority_queue

实际选择考虑因素：
- 性能要求：循环队列最优
- 功能需求：双端队列最灵活
- 业务逻辑：优先队列最符合优先级需求
```

---

## 💡 核心要点总结


```
队列类型的关键要点：

必须掌握的队列类型：
1. 循环队列：工程中最常用，解决空间浪费
2. 双端队列：功能最强大，支持两端操作
3. 优先队列：按优先级处理，基于堆实现
4. 普通队列：理解FIFO基本原理

核心技术要点：
- 循环队列的取模运算
- 双端队列的双向指针维护
- 优先队列的堆操作（上滤、下滤）
- 不同队列的适用场景判断

性能关键：
- 普通操作尽量保持O(1)
- 优先队列的O(log n)是可接受的
- 选择合适类型避免功能浪费
- 考虑内存使用和缓存性能

实际应用：
- 缓冲区优选循环队列
- 复杂操作选择双端队列
- 优先级场景选择优先队列
- 学习从普通队列开始理解
```