---
title: 1、跳表
---
## 📚 目录

1. [跳表的基本概念](#1-跳表的基本概念)
2. [跳表的结构与层次](#2-跳表的结构与层次)
3. [跳表的核心操作](#3-跳表的核心操作)
4. [跳表的性能分析](#4-跳表的性能分析)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 📊 跳表的基本概念


### 1.1 什么是跳表

**定义**：跳表(Skip List)是一种基于概率的数据结构，通过多层链表实现有序数据的快速查找。

**发明背景**：
- 1990年由William Pugh提出
- 用于替代平衡树的简单方案
- 随机化算法的经典应用

```
跳表的核心思想：
如果我们能跳过一些节点，是否能加快查找速度？

普通链表查找：
1 → 2 → 3 → 4 → 5 → 6 → 7 → 8
查找8需要遍历8个节点

理想的跳表：
Level 2: 1 ————————————————→ 8
Level 1: 1 ———→ 4 ———————————→ 8  
Level 0: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8

查找8：Level 2直接跳到，只需1次比较
```

### 1.2 跳表与其他数据结构对比

```
数据结构对比：

有序数组：
优点：查找O(log n)，支持二分搜索
缺点：插入删除O(n)，需要移动元素

平衡树(AVL/红黑树)：
优点：查找插入删除都是O(log n)
缺点：实现复杂，旋转操作难懂

普通链表：
优点：插入删除O(1)
缺点：查找O(n)，无法跳跃

跳表：
优点：实现简单，性能接近平衡树
缺点：空间开销较大，基于概率
```

### 1.3 跳表的核心思想

**多层索引**：构建多个层次的"快速通道"

```
跳表构建思想：

原始链表：
1 → 2 → 3 → 4 → 5 → 6 → 7 → 8

第一层索引(每2个节点提取1个)：
1 ———→ 3 ———→ 5 ———→ 7
原链表：1 → 2 → 3 → 4 → 5 → 6 → 7 → 8

第二层索引(每4个节点提取1个)：
1 ———————————→ 5
1 ———→ 3 ———→ 5 ———→ 7
1 → 2 → 3 → 4 → 5 → 6 → 7 → 8

查找6的过程：
1. 从第二层开始：1 → 5，5 < 6，但下一个节点超出范围
2. 从5向下到第一层：5 → 7，7 > 6，回退
3. 从5向下到第零层：5 → 6，找到目标

实现了O(log n)的查找效率！
```

---

## 2. 🏗️ 跳表的结构与层次


### 2.1 节点结构设计

```java
class SkipListNode {
    int val;                    // 节点值
    SkipListNode[] forward;     // 前向指针数组，每层一个指针
    
    public SkipListNode(int val, int level) {
        this.val = val;
        this.forward = new SkipListNode[level + 1];
    }
}

// 节点示例
节点值为5，层数为3的节点：
val = 5
forward[0] → 指向第0层下一个节点
forward[1] → 指向第1层下一个节点  
forward[2] → 指向第2层下一个节点
forward[3] → 指向第3层下一个节点
```

### 2.2 跳表整体结构

```java
class SkipList {
    private static final int MAX_LEVEL = 16;    // 最大层数
    private static final double PROBABILITY = 0.5;  // 晋升概率
    
    private SkipListNode head;      // 头节点
    private int currentLevel;       // 当前最高层数
    private Random random;          // 随机数生成器
    
    public SkipList() {
        head = new SkipListNode(Integer.MIN_VALUE, MAX_LEVEL);
        currentLevel = 0;
        random = new Random();
    }
}
```

### 2.3 层数的随机决定

**核心机制**：每个节点的层数通过抛硬币随机决定

```java
// 随机生成节点层数
private int randomLevel() {
    int level = 0;
    while (random.nextDouble() < PROBABILITY && level < MAX_LEVEL) {
        level++;
    }
    return level;
}

// 概率分析
P(节点出现在第0层) = 1 (所有节点都在第0层)
P(节点出现在第1层) = 0.5
P(节点出现在第2层) = 0.25  
P(节点出现在第3层) = 0.125
...
P(节点出现在第k层) = (0.5)^k

期望：
- 第0层：n个节点
- 第1层：n/2个节点
- 第2层：n/4个节点
- 第k层：n/(2^k)个节点
```

### 2.4 跳表的可视化表示

```
完整跳表示例(存储1,3,5,7,9)：

Level 3: head ——————————————————————————→ NULL
Level 2: head ————————→ 5 ——————————————→ NULL
Level 1: head ———→ 3 ——→ 5 ———→ 7 ————→ NULL
Level 0: head → 1 → 3 → 5 → 7 → 9 → NULL

各节点的层数：
head: Level 3 (虚拟头节点，最高层)
1: Level 0 (只在最底层)
3: Level 1 (在第0层和第1层)
5: Level 2 (在第0、1、2层)
7: Level 1 (在第0层和第1层)
9: Level 0 (只在最底层)

forward指针示例：
head.forward[0] → 1
head.forward[1] → 3
head.forward[2] → 5
head.forward[3] → NULL

节点5的forward数组：
5.forward[0] → 7 (第0层下一个)
5.forward[1] → 7 (第1层下一个)
5.forward[2] → NULL (第2层下一个)
```

---

## 3. 🔍 跳表的核心操作


### 3.1 查找操作

**基本思路**：从最高层开始，向右查找直到找到目标或超出范围，然后向下一层

```java
public boolean search(int target) {
    SkipListNode current = head;
    
    // 从最高层开始向下查找
    for (int level = currentLevel; level >= 0; level--) {
        // 在当前层向右查找
        while (current.forward[level] != null && 
               current.forward[level].val < target) {
            current = current.forward[level];
        }
    }
    
    // 检查第0层的下一个节点是否为目标
    current = current.forward[0];
    return current != null && current.val == target;
}

// 查找过程示例
跳表：head → 1 → 3 → 5 → 7 → 9
查找目标：7

Level 2: head ————→ 5 ——————→ NULL
Level 1: head ——→ 3 → 5 ——→ 7 → NULL
Level 0: head → 1 → 3 → 5 → 7 → 9 → NULL

查找步骤：
1. Level 2: head → 5，5 < 7，继续
2. Level 2: 5 → NULL，超出范围，下降到Level 1
3. Level 1: 5 → 7，7 = 7，找到！

比较次数：3次 (普通链表需要4次)
```

### 3.2 插入操作

**核心步骤**：
1. 查找插入位置
2. 随机决定新节点层数
3. 更新各层的指针连接

```java
public void insert(int val) {
    SkipListNode[] update = new SkipListNode[MAX_LEVEL + 1];
    SkipListNode current = head;
    
    // 步骤1：找到每一层的插入位置
    for (int level = currentLevel; level >= 0; level--) {
        while (current.forward[level] != null && 
               current.forward[level].val < val) {
            current = current.forward[level];
        }
        update[level] = current;  // 记录每层的前驱节点
    }
    
    // 步骤2：随机决定新节点层数
    int newLevel = randomLevel();
    
    // 如果新层数超过当前最高层，更新头节点指针
    if (newLevel > currentLevel) {
        for (int level = currentLevel + 1; level <= newLevel; level++) {
            update[level] = head;
        }
        currentLevel = newLevel;
    }
    
    // 步骤3：创建新节点并更新指针
    SkipListNode newNode = new SkipListNode(val, newLevel);
    for (int level = 0; level <= newLevel; level++) {
        newNode.forward[level] = update[level].forward[level];
        update[level].forward[level] = newNode;
    }
}

// 插入过程示例
原跳表：head → 1 → 3 → 7 → 9
插入值：5，随机层数：2

查找过程：
Level 2: head ——————→ NULL (update[2] = head)
Level 1: head ———→ 3 ———→ 7 (update[1] = 3)
Level 0: head → 1 → 3 → 7 → 9 (update[0] = 3)

插入后：
Level 2: head ————→ 5 ——————→ NULL
Level 1: head ———→ 3 → 5 ———→ 7 → NULL
Level 0: head → 1 → 3 → 5 → 7 → 9 → NULL
```

### 3.3 删除操作

**核心步骤**：
1. 查找目标节点
2. 更新各层指针跳过目标节点
3. 调整跳表最高层数

```java
public void delete(int val) {
    SkipListNode[] update = new SkipListNode[MAX_LEVEL + 1];
    SkipListNode current = head;
    
    // 步骤1：找到每一层的前驱节点
    for (int level = currentLevel; level >= 0; level--) {
        while (current.forward[level] != null && 
               current.forward[level].val < val) {
            current = current.forward[level];
        }
        update[level] = current;
    }
    
    current = current.forward[0];
    
    // 步骤2：如果找到目标节点，执行删除
    if (current != null && current.val == val) {
        // 更新各层指针
        for (int level = 0; level <= currentLevel; level++) {
            if (update[level].forward[level] != current) {
                break;  // 该层没有此节点
            }
            update[level].forward[level] = current.forward[level];
        }
        
        // 步骤3：调整最高层数
        while (currentLevel > 0 && head.forward[currentLevel] == null) {
            currentLevel--;
        }
    }
}

// 删除过程示例
原跳表：
Level 2: head ————→ 5 ——————→ NULL
Level 1: head ———→ 3 → 5 ———→ 7 → NULL
Level 0: head → 1 → 3 → 5 → 7 → 9 → NULL

删除值：5

删除后：
Level 1: head ———→ 3 ———————→ 7 → NULL  (Level 2被删除)
Level 0: head → 1 → 3 → 7 → 9 → NULL

currentLevel从2降为1
```

---

## 4. 📈 跳表的性能分析


### 4.1 时间复杂度分析

**查找复杂度**：O(log n)期望值

```
分析过程：
设跳表有n个节点，最高层为k

层数分析：
P(节点在第i层) = (1/2)^i
期望第i层节点数 = n × (1/2)^i
最高层k满足：n × (1/2)^k ≈ 1
解得：k ≈ log₂ n

查找路径分析：
最坏情况：每层都要遍历到最右端
每层期望遍历节点数：2 (由概率分析得出)
总的期望比较次数：2 × log₂ n = O(log n)

插入/删除复杂度：
查找位置：O(log n)
更新指针：O(log n) (最多log n层)
总复杂度：O(log n)
```

### 4.2 空间复杂度分析

```
空间分析：
每个节点期望层数：
E[层数] = Σ(i × P(层数=i)) = Σ(i × (1/2)^i) = 2

指针总数：
n个节点 × 平均2层 = 2n个指针

额外空间：
相比普通链表，额外使用n个指针
空间复杂度：O(n)

空间开销对比：
普通链表：n个指针
跳表：2n个指针
红黑树：3n个指针(val + left + right + color)
```

### 4.3 与其他数据结构对比

```
性能对比表：

操作      | 跳表     | 平衡树    | 哈希表   | 有序数组
---------|----------|-----------|----------|----------
查找     | O(log n) | O(log n)  | O(1)*   | O(log n)
插入     | O(log n) | O(log n)  | O(1)*   | O(n)
删除     | O(log n) | O(log n)  | O(1)*   | O(n)
有序遍历 | O(n)     | O(n)      | O(n log n)| O(n)
空间     | O(n)     | O(n)      | O(n)     | O(n)
实现难度 | 简单     | 复杂      | 中等     | 简单

*哈希表期望复杂度，最坏O(n)

跳表的优势：
✅ 实现简单，易于理解
✅ 支持有序操作
✅ 性能稳定，期望O(log n)
✅ 支持范围查询
✅ 并发友好

跳表的劣势：
❌ 空间开销较大
❌ 基于概率，性能不绝对保证
❌ 缓存性能不如数组
```

### 4.4 实际应用场景

```
Redis中的应用：
- 有序集合(Sorted Set)的底层实现
- 结合哈希表实现O(1)的score查找
- 支持范围查询：ZRANGE, ZRANGEBYSCORE

数据库中的应用：
- MemSQL使用跳表作为内存索引
- 部分NoSQL数据库的索引结构
- 适合读多写少的场景

并发编程中的应用：
- Java的ConcurrentSkipListMap
- 无锁并发数据结构
- 比平衡树更容易实现并发

跳表适合的场景：
✅ 需要有序数据结构
✅ 查找、插入、删除操作平衡
✅ 需要范围查询
✅ 实现简单性重要
✅ 并发访问需求
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念

```
🔸 跳表本质：多层链表构成的有序数据结构
🔸 核心思想：通过跳跃查找实现O(log n)复杂度
🔸 随机化：节点层数由概率决定，避免最坏情况
🔸 操作模式：查找路径决定插入删除位置
🔸 性能特点：期望O(log n)，实现简单
```

### 5.2 关键理解要点


**🔹 为什么跳表能达到O(log n)**：
```
关键在于多层索引：
- 每层节点数期望减半
- 层数期望为O(log n)
- 每层查找期望常数时间
- 总时间复杂度O(log n)

与二分查找的相似性：
二分查找：每次排除一半元素
跳表：每层跳过约一半节点
```

**🔹 随机化的重要性**：
```
为什么不用固定规则：
- 固定规则容易被特定输入破坏
- 随机化保证期望性能
- 避免数据模式导致的退化

概率p=0.5的选择：
- 平衡空间和时间开销
- 理论分析和实践都最优
- 实现简单
```

**🔹 跳表vs平衡树的选择**：
```
选择跳表的情况：
- 实现简单性重要
- 需要并发访问
- 代码可读性要求高
- 性能要求不是极致

选择平衡树的情况：
- 最坏情况性能保证
- 空间使用要求严格
- 对缓存性能敏感
- 已有成熟实现
```

### 5.3 实现要点

```
设计考虑：
- 最大层数：通常16层足够
- 概率选择：0.5是最优选择
- 头节点：简化边界处理
- 随机数生成：影响性能

优化技巧：
- 预分配节点减少内存分配
- 批量操作提高效率
- 缓存查找路径
- 使用位运算优化随机数

常见错误：
- 忘记更新currentLevel
- 指针更新顺序错误
- 边界条件处理不当
- 随机数生成器选择不当
```

### 5.4 应用指导

```
适用场景：
✅ 需要有序数据结构
✅ 查找插入删除并重
✅ 支持范围查询
✅ 实现简单性重要
✅ 并发友好需求

不适用场景：
❌ 极致性能要求
❌ 内存使用严格限制
❌ 数据量很小
❌ 只读数据

工程实践：
- 根据数据规模调整最大层数
- 监控实际层数分布
- 考虑内存分配策略
- 测试并发安全性
```

### 5.5 学习要点

```
理解顺序：
1. 掌握多层链表的基本思想
2. 理解随机化层数的原理
3. 熟练掌握查找操作
4. 掌握插入删除的指针操作
5. 分析时间空间复杂度

实践建议：
- 手工模拟小规模操作
- 画图理解指针连接关系
- 实现完整的跳表类
- 与其他数据结构对比测试
- 阅读Redis等实际应用源码

重点关注：
- 随机化算法的精妙之处
- 概率分析的方法
- 简单实现高效性能的设计哲学
- 在工程中的实际应用价值
```
