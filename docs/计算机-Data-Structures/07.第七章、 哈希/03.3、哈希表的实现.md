---
title: 3ã€å“ˆå¸Œè¡¨çš„å®ç°
---
## ğŸ“š ç›®å½•

1. [å†²çªå¤„ç†æ–¹æ³•æ¦‚è¿°](#1-å†²çªå¤„ç†æ–¹æ³•æ¦‚è¿°)
2. [å¼€æ”¾å¯»å€æ³•](#2-å¼€æ”¾å¯»å€æ³•)
3. [é“¾åœ°å€æ³•](#3-é“¾åœ°å€æ³•)
4. [åŠ¨æ€æ‰©å®¹æœºåˆ¶](#4-åŠ¨æ€æ‰©å®¹æœºåˆ¶)
5. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#5-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ”„ å†²çªå¤„ç†æ–¹æ³•æ¦‚è¿°


### 1.1 å†²çªå¤„ç†çš„å¿…è¦æ€§

**æ ¹æœ¬åŸå› **ï¼šé”®çš„ç©ºé—´è¿œå¤§äºå“ˆå¸Œè¡¨ç©ºé—´ï¼Œå†²çªä¸å¯é¿å…

```
å†²çªç¤ºä¾‹ï¼š
å“ˆå¸Œå‡½æ•°ï¼šh(key) = key % 7
è¾“å…¥ï¼š10, 17, 24

è®¡ç®—ç»“æœï¼š
h(10) = 10 % 7 = 3
h(17) = 17 % 7 = 3  â† å†²çªï¼
h(24) = 24 % 7 = 3  â† å†²çªï¼

é—®é¢˜ï¼šä¸‰ä¸ªä¸åŒçš„é”®éƒ½è¦å­˜å‚¨åœ¨ä½ç½®3
```

### 1.2 å†²çªå¤„ç†ç­–ç•¥åˆ†ç±»

```
ä¸»è¦æ–¹æ³•ï¼š

1. å¼€æ”¾å¯»å€æ³•(Open Addressing)ï¼š
   æ‰€æœ‰å…ƒç´ å­˜å‚¨åœ¨å“ˆå¸Œè¡¨å†…
   å†²çªæ—¶å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºä½ç½®
   
2. é“¾åœ°å€æ³•(Separate Chaining)ï¼š
   å“ˆå¸Œè¡¨æ¯ä¸ªä½ç½®å­˜å‚¨ä¸€ä¸ªé“¾è¡¨
   å†²çªå…ƒç´ é“¾æ¥åœ¨åŒä¸€ä½ç½®

é€‰æ‹©ä¾æ®ï¼š
- è´Ÿè½½å› å­å¤§å°
- å†…å­˜ä½¿ç”¨æ¨¡å¼
- ç¼“å­˜å‹å¥½æ€§
- å®ç°å¤æ‚åº¦
```

### 1.3 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

```
è¯„ä»·ç»´åº¦     | å¼€æ”¾å¯»å€æ³•    | é“¾åœ°å€æ³•
------------|--------------|-------------
ç©ºé—´æ•ˆç‡    | é«˜(æ— é¢å¤–æŒ‡é’ˆ) | ä½(éœ€è¦æŒ‡é’ˆ)
ç¼“å­˜æ€§èƒ½    | å¥½(è¿ç»­è®¿é—®)   | å·®(è·³è·ƒè®¿é—®)
è´Ÿè½½å› å­    | Î± < 1        | Î±å¯ä»¥>1
åˆ é™¤æ“ä½œ    | å¤æ‚(æ‡’åˆ é™¤)   | ç®€å•(ç›´æ¥åˆ é™¤)
å®ç°éš¾åº¦    | ä¸­ç­‰         | ç®€å•
```

---

## 2. ğŸ” å¼€æ”¾å¯»å€æ³•


### 2.1 å¼€æ”¾å¯»å€æ³•åŸºæœ¬æ€æƒ³

**æ ¸å¿ƒåŸç†**ï¼šå½“å‘ç”Ÿå†²çªæ—¶ï¼ŒæŒ‰æŸç§è§„åˆ™å¯»æ‰¾ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®

**é€šç”¨å…¬å¼**ï¼šh_i(key) = (h(key) + d_i) % m
- h(key)ï¼šåŸºç¡€å“ˆå¸Œå‡½æ•°
- d_iï¼šç¬¬iæ¬¡æ¢æµ‹çš„åç§»é‡
- mï¼šå“ˆå¸Œè¡¨å¤§å°

```
æ¢æµ‹åºåˆ—ç¤ºä¾‹ï¼š
åŸºç¡€ä½ç½®ï¼šh(key) = 3
å‘ç”Ÿå†²çªï¼Œç»§ç»­æ¢æµ‹ï¼š
ç¬¬1æ¬¡ï¼š(3 + d_1) % m
ç¬¬2æ¬¡ï¼š(3 + d_2) % m
ç¬¬3æ¬¡ï¼š(3 + d_3) % m
...ç›´åˆ°æ‰¾åˆ°ç©ºä½ç½®æˆ–è¡¨æ»¡
```

### 2.2 çº¿æ€§æ¢æµ‹(Linear Probing)

**æ¢æµ‹å…¬å¼**ï¼šd_i = i
**æ¢æµ‹åºåˆ—**ï¼šh(key), h(key)+1, h(key)+2, ...

```java
class LinearProbingHashTable {
    private String[] keys;
    private String[] values;
    private boolean[] deleted;  // æ‡’åˆ é™¤æ ‡è®°
    private int size;
    private int capacity;
    
    public LinearProbingHashTable(int capacity) {
        this.capacity = capacity;
        keys = new String[capacity];
        values = new String[capacity];
        deleted = new boolean[capacity];
        size = 0;
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    // æ’å…¥æ“ä½œ
    public void put(String key, String value) {
        int index = hash(key);
        
        // çº¿æ€§æ¢æµ‹å¯»æ‰¾ä½ç½®
        while (keys[index] != null && !deleted[index]) {
            if (keys[index].equals(key)) {
                values[index] = value;  // æ›´æ–°å·²å­˜åœ¨çš„é”®
                return;
            }
            index = (index + 1) % capacity;  // æ¢æµ‹ä¸‹ä¸€ä½ç½®
        }
        
        keys[index] = key;
        values[index] = value;
        deleted[index] = false;
        size++;
    }
    
    // æŸ¥æ‰¾æ“ä½œ
    public String get(String key) {
        int index = hash(key);
        
        while (keys[index] != null) {
            if (!deleted[index] && keys[index].equals(key)) {
                return values[index];
            }
            index = (index + 1) % capacity;
        }
        return null;  // æœªæ‰¾åˆ°
    }
}
```

**çº¿æ€§æ¢æµ‹çš„ç‰¹ç‚¹**ï¼š
```
ä¼˜ç‚¹ï¼š
âœ… å®ç°ç®€å•
âœ… ç¼“å­˜å‹å¥½ï¼ˆè¿ç»­è®¿é—®ï¼‰
âœ… å†…å­˜åˆ©ç”¨ç‡é«˜

ç¼ºç‚¹ï¼š
âŒ èšé›†ç°è±¡ä¸¥é‡
âŒ æ€§èƒ½éšè´Ÿè½½å› å­å¿«é€Ÿä¸‹é™
âŒ åˆ é™¤æ“ä½œå¤æ‚
```

### 2.3 äºŒæ¬¡æ¢æµ‹(Quadratic Probing)

**æ¢æµ‹å…¬å¼**ï¼šd_i = iÂ²
**æ¢æµ‹åºåˆ—**ï¼šh(key), h(key)+1Â², h(key)+2Â², h(key)+3Â², ...

```java
public void quadraticPut(String key, String value) {
    int index = hash(key);
    int i = 0;
    
    while (keys[index] != null && !deleted[index]) {
        if (keys[index].equals(key)) {
            values[index] = value;
            return;
        }
        i++;
        index = (hash(key) + i * i) % capacity;  // äºŒæ¬¡æ¢æµ‹
    }
    
    keys[index] = key;
    values[index] = value;
    deleted[index] = false;
    size++;
}
```

**äºŒæ¬¡æ¢æµ‹çš„æ”¹è¿›**ï¼š
```
è§£å†³äº†çº¿æ€§æ¢æµ‹çš„èšé›†é—®é¢˜ï¼š
çº¿æ€§ï¼šå†²çªå…ƒç´ è¿ç»­æ’åˆ—
äºŒæ¬¡ï¼šå†²çªå…ƒç´ åˆ†æ•£åˆ†å¸ƒ

æ–°é—®é¢˜ï¼šäºŒæ¬¡èšé›†
ç›¸åŒå“ˆå¸Œå€¼çš„é”®æœ‰ç›¸åŒæ¢æµ‹åºåˆ—

è¡¨å¤§å°è¦æ±‚ï¼š
éœ€è¦é€‰æ‹©è´¨æ•°ï¼Œä¸”Î± â‰¤ 0.5 æ‰èƒ½ä¿è¯æ‰¾åˆ°ç©ºä½
```

### 2.4 åŒé‡å“ˆå¸Œ(Double Hashing)

**æ¢æµ‹å…¬å¼**ï¼šd_i = i Ã— hâ‚‚(key)
**æ¢æµ‹åºåˆ—**ï¼šhâ‚(key), hâ‚(key)+hâ‚‚(key), hâ‚(key)+2Ã—hâ‚‚(key), ...

```java
private int hash1(String key) {
    return Math.abs(key.hashCode()) % capacity;
}

private int hash2(String key) {
    // ç¬¬äºŒä¸ªå“ˆå¸Œå‡½æ•°ï¼Œç»“æœä¸èƒ½ä¸º0
    return 7 - (Math.abs(key.hashCode()) % 7);
}

public void doublePut(String key, String value) {
    int index = hash1(key);
    int step = hash2(key);
    
    while (keys[index] != null && !deleted[index]) {
        if (keys[index].equals(key)) {
            values[index] = value;
            return;
        }
        index = (index + step) % capacity;  // åŒé‡å“ˆå¸Œæ¢æµ‹
    }
    
    keys[index] = key;
    values[index] = value;
    deleted[index] = false;
    size++;
}
```

**åŒé‡å“ˆå¸Œçš„ä¼˜åŠ¿**ï¼š
```
âœ… é¿å…èšé›†ç°è±¡
âœ… ä¸åŒé”®æœ‰ä¸åŒæ¢æµ‹åºåˆ—
âœ… æ€§èƒ½æ¥è¿‘ç†æƒ³éšæœºæ¢æµ‹

è®¾è®¡è¦æ±‚ï¼š
ğŸ”¸ hâ‚‚(key) â‰  0
ğŸ”¸ hâ‚‚(key) ä¸ m äº’è´¨
ğŸ”¸ å¸¸ç”¨å½¢å¼ï¼šhâ‚‚(key) = R - (key % R)ï¼ŒR < m ä¸”ä¸ºè´¨æ•°
```

### 2.5 å¼€æ”¾å¯»å€æ³•çš„åˆ é™¤é—®é¢˜

**é—®é¢˜**ï¼šç›´æ¥åˆ é™¤ä¼šç ´åæ¢æµ‹åºåˆ—

```
åˆ é™¤é—®é¢˜ç¤ºä¾‹ï¼š
è¡¨å¤§å°m=7ï¼Œå­˜å‚¨é”®ï¼š10, 17, 24
h(10) = h(17) = h(24) = 3

å­˜å‚¨è¿‡ç¨‹ï¼š
ä½ç½®0: []
ä½ç½®1: []  
ä½ç½®2: []
ä½ç½®3: [10]
ä½ç½®4: [17]  â† 10å†²çªï¼Œå­˜åˆ°4
ä½ç½®5: [24]  â† 17å†²çªï¼Œå­˜åˆ°5
ä½ç½®6: []

æŸ¥æ‰¾24ï¼šä»ä½ç½®3å¼€å§‹ â†’ ä½ç½®4 â†’ ä½ç½®5æ‰¾åˆ°

å¦‚æœç›´æ¥åˆ é™¤17ï¼š
ä½ç½®4: []  â† ç›´æ¥åˆ é™¤

å†æŸ¥æ‰¾24ï¼šä»ä½ç½®3å¼€å§‹ â†’ ä½ç½®4ä¸ºç©º â†’ é”™è¯¯è®¤ä¸º24ä¸å­˜åœ¨ï¼
```

**è§£å†³æ–¹æ¡ˆï¼šæ‡’åˆ é™¤(Lazy Deletion)**
```java
// æ‡’åˆ é™¤æ ‡è®°
private boolean[] deleted;

public void delete(String key) {
    int index = findIndex(key);
    if (index != -1) {
        deleted[index] = true;  // æ ‡è®°åˆ é™¤ï¼Œä¸å®é™…åˆ é™¤
        size--;
    }
}

// æŸ¥æ‰¾æ—¶è¦æ£€æŸ¥åˆ é™¤æ ‡è®°
public String get(String key) {
    int index = hash(key);
    
    while (keys[index] != null) {
        if (!deleted[index] && keys[index].equals(key)) {
            return values[index];
        }
        index = (index + 1) % capacity;
    }
    return null;
}
```

---

## 3. ğŸ”— é“¾åœ°å€æ³•


### 3.1 é“¾åœ°å€æ³•åŸºæœ¬æ€æƒ³

**æ ¸å¿ƒåŸç†**ï¼šå“ˆå¸Œè¡¨æ¯ä¸ªä½ç½®ç»´æŠ¤ä¸€ä¸ªé“¾è¡¨ï¼Œå†²çªå…ƒç´ é“¾æ¥åœ¨åŒä¸€ä½ç½®

```
é“¾åœ°å€æ³•ç¤ºä¾‹ï¼š
å“ˆå¸Œå‡½æ•°ï¼šh(key) = key % 7
è¾“å…¥ï¼š10, 17, 24, 5

å­˜å‚¨ç»“æœï¼š
ä½ç½®0: []
ä½ç½®1: []
ä½ç½®2: []
ä½ç½®3: [10] â†’ [17] â†’ [24]  â† æ‰€æœ‰å†²çªå…ƒç´ é“¾æ¥
ä½ç½®4: []
ä½ç½®5: [5]
ä½ç½®6: []

æŸ¥æ‰¾17ï¼šè®¡ç®—h(17)=3ï¼Œåœ¨ä½ç½®3çš„é“¾è¡¨ä¸­é¡ºåºæŸ¥æ‰¾
```

### 3.2 åŸºæœ¬é“¾è¡¨å®ç°

```java
class ChainedHashTable {
    private class Node {
        String key;
        String value;
        Node next;
        
        Node(String key, String value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Node[] table;
    private int size;
    private int capacity;
    
    public ChainedHashTable(int capacity) {
        this.capacity = capacity;
        table = new Node[capacity];
        size = 0;
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    // æ’å…¥æ“ä½œ
    public void put(String key, String value) {
        int index = hash(key);
        Node head = table[index];
        
        // æ£€æŸ¥é”®æ˜¯å¦å·²å­˜åœ¨
        Node current = head;
        while (current != null) {
            if (current.key.equals(key)) {
                current.value = value;  // æ›´æ–°å€¼
                return;
            }
            current = current.next;
        }
        
        // æ’å…¥æ–°èŠ‚ç‚¹åˆ°é“¾è¡¨å¤´éƒ¨
        Node newNode = new Node(key, value);
        newNode.next = head;
        table[index] = newNode;
        size++;
    }
    
    // æŸ¥æ‰¾æ“ä½œ
    public String get(String key) {
        int index = hash(key);
        Node current = table[index];
        
        while (current != null) {
            if (current.key.equals(key)) {
                return current.value;
            }
            current = current.next;
        }
        return null;
    }
    
    // åˆ é™¤æ“ä½œ
    public void remove(String key) {
        int index = hash(key);
        Node head = table[index];
        
        if (head == null) return;
        
        // åˆ é™¤å¤´èŠ‚ç‚¹
        if (head.key.equals(key)) {
            table[index] = head.next;
            size--;
            return;
        }
        
        // åˆ é™¤ä¸­é—´èŠ‚ç‚¹
        Node current = head;
        while (current.next != null) {
            if (current.next.key.equals(key)) {
                current.next = current.next.next;
                size--;
                return;
            }
            current = current.next;
        }
    }
}
```

### 3.3 é“¾è¡¨ä¼˜åŒ–ï¼šçº¢é»‘æ ‘

**Java 8 HashMapä¼˜åŒ–**ï¼šå½“é“¾è¡¨é•¿åº¦è¶…è¿‡8æ—¶ï¼Œè½¬æ¢ä¸ºçº¢é»‘æ ‘

```java
private static final int TREEIFY_THRESHOLD = 8;
private static final int UNTREEIFY_THRESHOLD = 6;

// ç®€åŒ–çš„æ ‘åŒ–é€»è¾‘
public void put(String key, String value) {
    int index = hash(key);
    Node head = table[index];
    
    // æ’å…¥é€»è¾‘...
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ ‘åŒ–
    if (getChainLength(index) > TREEIFY_THRESHOLD) {
        treeifyBin(index);  // è½¬æ¢ä¸ºçº¢é»‘æ ‘
    }
}

private void treeifyBin(int index) {
    Node head = table[index];
    if (head == null) return;
    
    // å°†é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘
    // å®é™…å®ç°è¾ƒå¤æ‚ï¼Œè¿™é‡Œçœç•¥è¯¦ç»†ä»£ç 
    TreeNode treeHead = convertToTree(head);
    table[index] = treeHead;
}

// æ ‘èŠ‚ç‚¹å®šä¹‰
static class TreeNode extends Node {
    TreeNode parent;
    TreeNode left;
    TreeNode right;
    boolean red;
    
    // çº¢é»‘æ ‘ç›¸å…³æ–¹æ³•...
}
```

**æ ‘åŒ–çš„ä¼˜åŠ¿**ï¼š
```
é“¾è¡¨æŸ¥æ‰¾ï¼šO(n)ï¼Œæœ€åæƒ…å†µä¸‹nä¸ªå…ƒç´ éƒ½åœ¨ä¸€ä¸ªä½ç½®
çº¢é»‘æ ‘æŸ¥æ‰¾ï¼šO(log n)ï¼Œå³ä½¿å†²çªä¸¥é‡ä¹Ÿèƒ½ä¿æŒè¾ƒå¥½æ€§èƒ½

æ ‘åŒ–æ¡ä»¶ï¼š
1. é“¾è¡¨é•¿åº¦ > 8
2. å“ˆå¸Œè¡¨å®¹é‡ â‰¥ 64ï¼ˆå¦åˆ™ä¼˜å…ˆæ‰©å®¹ï¼‰

é€€åŒ–æ¡ä»¶ï¼š
çº¢é»‘æ ‘èŠ‚ç‚¹æ•° â‰¤ 6æ—¶é€€åŒ–å›é“¾è¡¨
```

---

## 4. ğŸ“ˆ åŠ¨æ€æ‰©å®¹æœºåˆ¶


### 4.1 æ‰©å®¹çš„å¿…è¦æ€§

**è´Ÿè½½å› å­å½±å“**ï¼šÎ± = n/mï¼Œéšç€å…ƒç´ å¢åŠ ï¼Œå†²çªç‡æ€¥å‰§ä¸Šå‡

```
è´Ÿè½½å› å­ä¸æ€§èƒ½å…³ç³»ï¼š
Î± = 0.5ï¼šå†²çªè¾ƒå°‘ï¼Œæ€§èƒ½è‰¯å¥½
Î± = 0.75ï¼šå¹³è¡¡ç‚¹ï¼Œå¤šæ•°å®ç°çš„é»˜è®¤é˜ˆå€¼
Î± = 1.0ï¼šå¼€æ”¾å¯»å€æ³•æ€§èƒ½æ€¥å‰§ä¸‹é™
Î± > 1.0ï¼šåªæœ‰é“¾åœ°å€æ³•èƒ½å¤„ç†

æ‰©å®¹æ—¶æœºï¼š
é€šå¸¸åœ¨ Î± â‰¥ 0.75 æ—¶è§¦å‘æ‰©å®¹
```

### 4.2 æ‰©å®¹è¿‡ç¨‹è¯¦è§£

```java
public class ResizableHashTable {
    private static final double LOAD_FACTOR_THRESHOLD = 0.75;
    private Node[] table;
    private int size;
    private int capacity;
    
    private void resizeIfNeeded() {
        double loadFactor = (double) size / capacity;
        if (loadFactor >= LOAD_FACTOR_THRESHOLD) {
            resize();
        }
    }
    
    private void resize() {
        Node[] oldTable = table;
        int oldCapacity = capacity;
        
        // æ‰©å®¹ï¼šé€šå¸¸æ‰©å¤§ä¸ºåŸæ¥çš„2å€
        capacity = oldCapacity * 2;
        table = new Node[capacity];
        size = 0;  // é‡æ–°è®¡ç®—size
        
        // é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
        for (int i = 0; i < oldCapacity; i++) {
            Node current = oldTable[i];
            while (current != null) {
                Node next = current.next;  // ä¿å­˜nextå¼•ç”¨
                
                // é‡æ–°è®¡ç®—å“ˆå¸Œå€¼å¹¶æ’å…¥
                int newIndex = hash(current.key);
                current.next = table[newIndex];
                table[newIndex] = current;
                size++;
                
                current = next;
            }
        }
    }
    
    public void put(String key, String value) {
        // æ’å…¥é€»è¾‘...
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        resizeIfNeeded();
    }
}
```

### 4.3 æ‰©å®¹çš„æ€§èƒ½åˆ†æ

```
æ‰©å®¹æˆæœ¬ï¼š
å•æ¬¡æ‰©å®¹ï¼šO(n) - éœ€è¦é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
æ‰©å®¹é¢‘ç‡ï¼šå½“è´Ÿè½½å› å­è¾¾åˆ°é˜ˆå€¼æ—¶

å‡æ‘Šåˆ†æï¼š
è®¾æ¯æ¬¡æ‰©å®¹åå®¹é‡ç¿»å€
ç¬¬iæ¬¡æ‰©å®¹å¤„ç†2^iä¸ªå…ƒç´ 
æ€»æ“ä½œæ•°ï¼š1 + 2 + 4 + 8 + ... + n = 2n - 1
å¹³å‡æ¯ä¸ªå…ƒç´ çš„æ‰©å®¹æˆæœ¬ï¼š(2n-1)/n â‰ˆ 2 = O(1)

ç»“è®ºï¼šè™½ç„¶å•æ¬¡æ‰©å®¹ä»£ä»·é«˜ï¼Œä½†å‡æ‘Šæˆæœ¬ä¸ºå¸¸æ•°
```

### 4.4 æ¸è¿›å¼æ‰©å®¹

**é—®é¢˜**ï¼šå¤§è¡¨æ‰©å®¹æ—¶é—´è¿‡é•¿ï¼Œå½±å“ç”¨æˆ·ä½“éªŒ

**è§£å†³æ–¹æ¡ˆ**ï¼šåˆ†æ‰¹è¿›è¡Œæ‰©å®¹æ“ä½œ
```java
public class IncrementalResizeHashTable {
    private Node[] oldTable;
    private Node[] newTable;
    private int resizeIndex;  // å½“å‰é‡æ–°å“ˆå¸Œçš„ä½ç½®
    private boolean isResizing;
    
    private void incrementalResize() {
        if (!isResizing) {
            // å¼€å§‹æ‰©å®¹
            oldTable = table;
            newTable = new Node[capacity * 2];
            resizeIndex = 0;
            isResizing = true;
        }
        
        // æ¯æ¬¡æ“ä½œæ—¶è¿ç§»å°‘é‡å…ƒç´ 
        int batchSize = Math.min(10, oldTable.length - resizeIndex);
        for (int i = 0; i < batchSize; i++) {
            if (resizeIndex < oldTable.length) {
                migrateSlot(resizeIndex);
                resizeIndex++;
            }
        }
        
        // å®Œæˆæ‰©å®¹
        if (resizeIndex >= oldTable.length) {
            table = newTable;
            capacity *= 2;
            isResizing = false;
            oldTable = null;
            newTable = null;
        }
    }
    
    private void migrateSlot(int index) {
        Node current = oldTable[index];
        while (current != null) {
            Node next = current.next;
            // ç§»åŠ¨åˆ°æ–°è¡¨...
            current = next;
        }
    }
}
```

---

## 5. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 5.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ

```
ğŸ”¸ å†²çªå¤„ç†æœ¬è´¨ï¼šè§£å†³å¤šå¯¹ä¸€æ˜ å°„é—®é¢˜
ğŸ”¸ å¼€æ”¾å¯»å€æ³•ï¼šè¡¨å†…å¯»å€ï¼Œçº¿æ€§ã€äºŒæ¬¡ã€åŒé‡å“ˆå¸Œ
ğŸ”¸ é“¾åœ°å€æ³•ï¼šé“¾å¼å­˜å‚¨ï¼Œç®€å•æœ‰æ•ˆï¼Œå¯ä¼˜åŒ–ä¸ºæ ‘
ğŸ”¸ åŠ¨æ€æ‰©å®¹ï¼šç»´æŒè´Ÿè½½å› å­ï¼Œä¿è¯æ€§èƒ½ç¨³å®š
ğŸ”¸ åˆ é™¤é—®é¢˜ï¼šå¼€æ”¾å¯»å€ç”¨æ‡’åˆ é™¤ï¼Œé“¾åœ°å€ç›´æ¥åˆ é™¤
```

### 5.2 å…³é”®ç†è§£è¦ç‚¹


**ğŸ”¹ ä¸ºä»€ä¹ˆå¼€æ”¾å¯»å€æ³•æ€§èƒ½ä¸‹é™å¿«**ï¼š
```
éšç€è´Ÿè½½å› å­å¢åŠ ï¼Œæ¢æµ‹åºåˆ—å˜é•¿
æœ€åæƒ…å†µä¸‹å¯èƒ½éœ€è¦éå†æ•´ä¸ªè¡¨
ç¼“å­˜å‹å¥½ä½†èšé›†ç°è±¡ä¸¥é‡
```

**ğŸ”¹ é“¾åœ°å€æ³•ä¸ºä»€ä¹ˆå¯ä»¥è¶…è½½**ï¼š
```
Î± > 1 è¡¨ç¤ºå¹³å‡æ¯ä¸ªä½ç½®å­˜å‚¨å¤šä¸ªå…ƒç´ 
é“¾è¡¨å¯ä»¥æ— é™æ‰©å±•ï¼Œä¸åƒæ•°ç»„æœ‰å›ºå®šå¤§å°
æ€§èƒ½ä¸‹é™æ˜¯æ¸è¿›çš„ï¼Œä¸æ˜¯çªå˜çš„
```

**ğŸ”¹ Java HashMapçš„è®¾è®¡æ™ºæ…§**ï¼š
```
é“¾è¡¨ + çº¢é»‘æ ‘ï¼šå¹³è¡¡ç®€å•æ€§å’Œæœ€åæƒ…å†µæ€§èƒ½
è´Ÿè½½å› å­0.75ï¼šæ—¶é—´ç©ºé—´çš„æœ€ä½³å¹³è¡¡ç‚¹
2å€æ‰©å®¹ï¼šç®€å•é«˜æ•ˆï¼Œä¾¿äºä½è¿ç®—ä¼˜åŒ–
```

### 5.3 å®ç°é€‰æ‹©æŒ‡å—

```
å¼€æ”¾å¯»å€æ³•é€‚ç”¨åœºæ™¯ï¼š
âœ… è´Ÿè½½å› å­è¾ƒä½(Î± < 0.7)
âœ… å†…å­˜è®¿é—®æ¨¡å¼é‡è¦
âœ… åˆ é™¤æ“ä½œè¾ƒå°‘
âœ… å…ƒç´ å¤§å°è¾ƒå°

é“¾åœ°å€æ³•é€‚ç”¨åœºæ™¯ï¼š
âœ… è´Ÿè½½å› å­å¯èƒ½è¾ƒé«˜
âœ… åˆ é™¤æ“ä½œé¢‘ç¹
âœ… å®ç°ç®€å•æ€§é‡è¦
âœ… æœ€åæƒ…å†µæ€§èƒ½è¦æ±‚ä¸¥æ ¼

æ··åˆæ–¹æ¡ˆï¼š
ç°ä»£å®ç°å¾€å¾€ç»“åˆä¸¤è€…ä¼˜åŠ¿
å¦‚Java HashMapçš„é“¾è¡¨+çº¢é»‘æ ‘
```

### 5.4 æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

```
è®¾è®¡ä¼˜åŒ–ï¼š
- é€‰æ‹©å¥½çš„å“ˆå¸Œå‡½æ•°
- åˆç†è®¾ç½®è´Ÿè½½å› å­é˜ˆå€¼
- åŠæ—¶è§¦å‘æ‰©å®¹æ“ä½œ
- è€ƒè™‘ç¼“å­˜å‹å¥½æ€§

å®ç°ä¼˜åŒ–ï¼š
- ä½¿ç”¨ä½è¿ç®—ä»£æ›¿å–æ¨¡
- é¢„åˆ†é…åˆé€‚å¤§å°
- å‡å°‘å¯¹è±¡åˆ›å»º
- åˆ©ç”¨CPUç¼“å­˜å±€éƒ¨æ€§

ç›‘æ§æŒ‡æ ‡ï¼š
- å¹³å‡æ¢æµ‹/é“¾è¡¨é•¿åº¦
- æœ€å¤§æ¢æµ‹/é“¾è¡¨é•¿åº¦
- è´Ÿè½½å› å­å˜åŒ–
- æ‰©å®¹é¢‘ç‡å’Œè€—æ—¶
```

**æ ¸å¿ƒè®°å¿†**ï¼š
- å†²çªå¤„ç†æœ‰ä¸¤è·¯ï¼Œå¼€æ”¾å¯»å€è¡¨å†…æ‰¾
- é“¾åœ°å€æ³•æœ€ç®€å•ï¼Œå†²çªå…ƒç´ é“¾èµ·æ¥
- è´Ÿè½½å› å­æ˜¯å…³é”®ï¼Œè¶…é˜ˆå€¼å°±æ‰©å®¹
- åˆ é™¤æ‡’æ ‡è®°ï¼Œæ€§èƒ½è¦æƒè¡¡