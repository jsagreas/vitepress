---
title: 2、哈希函数
---
## 📚 目录

1. [哈希函数的基本概念](#1-哈希函数的基本概念)
2. [常用哈希函数方法](#2-常用哈希函数方法)
3. [字符串哈希函数](#3-字符串哈希函数)
4. [哈希函数的评价标准](#4-哈希函数的评价标准)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🔧 哈希函数的基本概念


### 1.1 什么是哈希函数

**定义**：哈希函数是将任意长度的输入(键)映射为固定长度输出(哈希值)的函数。

**数学表示**：h: U → {0, 1, 2, ..., m-1}
- U：键的全域(Universe of keys)
- m：哈希表的大小
- h(key)：哈希函数，返回0到m-1之间的整数

```
哈希函数的作用：
输入域(无限大) → 哈希函数 → 输出域(有限)

例子：
"张三"     → h("张三") → 3
"李四"     → h("李四") → 7  
"王五"     → h("王五") → 2
123456    → h(123456) → 5

任意输入 → [0, m-1] 范围内的整数
```

### 1.2 哈希函数的基本要求

```
🔸 确定性：相同输入必须产生相同输出
   h("张三") 永远等于 3

🔸 高效性：计算速度快，时间复杂度O(1)
   不能用复杂的数学运算

🔸 均匀性：输出值在范围内均匀分布
   避免大量冲突

🔸 雪崩效应：输入微小变化导致输出大幅变化
   h("张三") = 3, h("张四") = 15 (理想情况)
```

### 1.3 哈希函数的设计挑战

```
设计难点：
1. 输入域通常远大于输出域
   例：字符串有无限种可能，但哈希表大小有限
   
2. 冲突不可避免
   鸽笼原理：|U| > m 必然存在冲突
   
3. 数据分布可能不均匀
   实际输入可能有规律性，导致聚集

4. 计算效率要求
   哈希函数本身不能成为性能瓶颈
```

---

## 2. 🔢 常用哈希函数方法


### 2.1 除法哈希(Division Method)

**方法**：h(key) = key % m

**适用对象**：整数类型的键

```java
// 除法哈希实现
public int divisionHash(int key, int tableSize) {
    return Math.abs(key) % tableSize;
}

// 示例
int m = 13;  // 表大小选择质数
h(10) = 10 % 13 = 10
h(22) = 22 % 13 = 9  
h(31) = 31 % 13 = 5
h(44) = 44 % 13 = 5  // 冲突
```

**表大小选择原则**：
```
✅ 选择质数：避免与数据规律产生共振
✅ 避免2的幂：如m=2^k会忽略高位信息
✅ 远离2的幂：选择距离2的幂较远的质数

好的选择：m = 13, 17, 19, 23, 29...
差的选择：m = 8, 16, 32, 64... (2的幂)
```

### 2.2 乘法哈希(Multiplication Method)

**方法**：h(key) = ⌊m × (key × A - ⌊key × A⌋)⌋
其中A是0 < A < 1的常数

**核心思想**：提取key×A的小数部分，再乘以m

```java
// 乘法哈希实现
public int multiplicationHash(int key, int tableSize) {
    double A = 0.6180339887;  // (√5 - 1) / 2，黄金比例
    double temp = key * A;
    temp = temp - Math.floor(temp);  // 提取小数部分
    return (int) Math.floor(tableSize * temp);
}

// 示例计算
A = 0.618, m = 1000, key = 123
123 × 0.618 = 75.954
小数部分 = 0.954
h(123) = ⌊1000 × 0.954⌋ = 954
```

**优点**：
- 对表大小m不敏感，可以选择2的幂
- Knuth建议A ≈ (√5 - 1)/2 ≈ 0.618

### 2.3 平方取中法(Mid-Square Method)

**方法**：将键平方后取中间几位作为哈希值

```
示例：键 = 1234，表大小 = 1000

步骤：
1. 计算平方：1234² = 1,522,756
2. 转为字符串："1522756" 
3. 取中间3位："227"
4. 转回整数：227

h(1234) = 227

适用场景：键的位数比较固定
缺点：需要选择合适的中间位数
```

### 2.4 折叠法(Folding Method)

**方法**：将键分成几段，然后相加

```
示例：电话号码 13812345678

移位折叠：
138 + 123 + 456 + 78 = 795
h(13812345678) = 795 % m

边界折叠：
138 + 321 + 654 + 87 = 1200  // 奇数段反转
h(13812345678) = 1200 % m

适用场景：键比较长的情况
```

---

## 3. 🔤 字符串哈希函数


### 3.1 简单相加法

**方法**：将字符串中每个字符的ASCII值相加

```java
public int simpleStringHash(String str, int tableSize) {
    int hash = 0;
    for (int i = 0; i < str.length(); i++) {
        hash += str.charAt(i);
    }
    return hash % tableSize;
}

// 示例
String s = "abc";
hash = 'a' + 'b' + 'c' = 97 + 98 + 99 = 294
h("abc") = 294 % m

缺点：容易产生冲突
"abc" 和 "bca" 哈希值相同
```

### 3.2 位置加权法

**方法**：考虑字符位置，给每个位置不同的权重

```java
public int positionWeightedHash(String str, int tableSize) {
    int hash = 0;
    for (int i = 0; i < str.length(); i++) {
        hash += str.charAt(i) * (i + 1);  // 位置权重
    }
    return hash % tableSize;
}

// 示例
"abc" = 'a'×1 + 'b'×2 + 'c'×3 = 97 + 196 + 297 = 590
"bca" = 'b'×1 + 'c'×2 + 'a'×3 = 98 + 198 + 291 = 587

解决了字符顺序问题，但权重增长太慢
```

### 3.3 多项式哈希(Polynomial Hashing)

**方法**：使用进制的思想，每个字符作为一位

```java
public int polynomialHash(String str, int tableSize) {
    int hash = 0;
    int base = 31;  // 选择质数作为基数
    int power = 1;
    
    for (int i = 0; i < str.length(); i++) {
        hash += str.charAt(i) * power;
        power *= base;
    }
    return Math.abs(hash) % tableSize;
}

// 数学表示
h(s) = s[0] + s[1]×31 + s[2]×31² + ... + s[n-1]×31^(n-1)

// 示例
"abc" = 'a' + 'b'×31 + 'c'×31²
      = 97 + 98×31 + 99×961
      = 97 + 3038 + 95139 = 98274
```

**基数选择原则**：
- 选择质数，常用31、37、41
- 31的优势：31 = 2⁵ - 1，可以优化为位运算

### 3.4 Java String hashCode实现

```java
// Java标准库的String哈希实现
public int hashCode() {
    int h = 0;
    for (int i = 0; i < length(); i++) {
        h = 31 * h + charAt(i);
    }
    return h;
}

// 等价的数学表示
h = s[0]×31^(n-1) + s[1]×31^(n-2) + ... + s[n-1]×31^0

// 示例计算
"abc".hashCode():
h = 0
h = 31 × 0 + 'a' = 97
h = 31 × 97 + 'b' = 3007 + 98 = 3105  
h = 31 × 3105 + 'c' = 96255 + 99 = 96354

优点：分布均匀，计算高效，工业级应用
```

### 3.5 滚动哈希(Rolling Hash)

**用途**：在字符串匹配中快速计算子串哈希值

```java
// Rabin-Karp算法中的滚动哈希
public class RollingHash {
    private int base = 31;
    private int mod = 1000000007;
    
    // 计算字符串s[left...right]的哈希值
    public int computeHash(String s, int left, int right) {
        long hash = 0;
        long power = 1;
        for (int i = left; i <= right; i++) {
            hash = (hash + (s.charAt(i) * power)) % mod;
            power = (power * base) % mod;
        }
        return (int) hash;
    }
    
    // 从oldHash滚动到newHash  
    // 移除最左字符，添加最右字符
    public int rollHash(int oldHash, char removeChar, 
                       char addChar, int windowSize) {
        // 实现滚动更新逻辑
        long newHash = oldHash;
        newHash = (newHash - removeChar + mod) % mod;
        newHash = (newHash * base + addChar) % mod;
        return (int) newHash;
    }
}
```

---

## 4. ⚖️ 哈希函数的评价标准


### 4.1 均匀分布性

**定义**：哈希值在输出范围内均匀分布，每个位置被选中的概率相等

```
理想情况：
输入n个键，哈希表大小m
每个位置期望包含 n/m 个键

测试方法：
1. 选择大量测试数据
2. 计算哈希值分布
3. 使用χ²检验判断均匀性

均匀性差的例子：
h(key) = key % 10
如果输入的key都是偶数，那么奇数位置永远为空
```

### 4.2 雪崩效应

**定义**：输入的微小变化导致输出的大幅变化

```
好的雪崩效应：
h("hello") = 123456
h("hallo") = 789012  // 只改变一个字符，哈希值完全不同

差的雪崩效应：
h("123") = 6    // 1+2+3
h("124") = 7    // 1+2+4，只差1

测试方法：
1. 改变输入的1位
2. 观察输出变化的位数  
3. 好的函数应该有约50%的位发生变化
```

### 4.3 计算效率

**要求**：哈希函数计算要快，不能成为性能瓶颈

```
效率考虑：
✅ 避免复杂数学运算：开方、三角函数等
✅ 多用位运算：移位、异或等
✅ 减少分支判断：影响CPU流水线
✅ 利用现代CPU特性：并行计算

效率对比：
简单相加法：O(n) 很快
多项式哈希：O(n) 较快  
MD5/SHA1：O(n) 较慢，但安全性高
```

### 4.4 冲突率分析

```
理论分析工具：

生日悖论：
在随机哈希函数假设下，当存储√m个元素时
冲突概率约为50%

负载因子影响：
α = n/m
α = 0.5: 冲突概率较低
α = 0.75: 平衡点
α > 1.0: 冲突频繁

实际测试指标：
- 平均冲突次数
- 最大冲突链长度  
- 空间利用率
```

### 4.5 哈希函数选择指南

```
数据类型导向选择：

整数键：
- 小范围：除法哈希 + 质数表大小
- 大范围：乘法哈希
- 有规律：避免简单取模

字符串键：
- 短字符串：多项式哈希
- 长字符串：分段折叠 + 多项式
- 实时计算：滚动哈希

应用场景导向：
- 通用哈希表：Java String.hashCode()风格
- 密码学应用：SHA系列
- 快速查找：简单但均匀的函数
- 分布式系统：一致性哈希
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念

```
🔸 哈希函数本质：将无限输入域映射到有限输出域
🔸 基本要求：确定性、高效性、均匀性、雪崩效应
🔸 常用方法：除法、乘法、多项式是主要技术
🔸 字符串哈希：多项式哈希是最重要的方法
🔸 评价标准：均匀分布、雪崩效应、计算效率
```

### 5.2 关键理解要点


**🔹 为什么除法哈希要选质数**：
```
质数能够减少与数据规律的"共振"
例如：数据都是偶数，表大小也是偶数 → 奇数位置永远空
质数大小能够打破这种规律性
```

**🔹 多项式哈希为什么有效**：
```
类似进制转换，充分利用字符位置信息
不同位置的字符有不同的权重
基数选择质数保证分布均匀性
```

**🔹 Java String hashCode的巧妙之处**：
```
31 = 2⁵ - 1，可以优化为 (h << 5) - h
既保证了分布均匀，又提高了计算效率
经过大量实践验证的工业级实现
```

### 5.3 实际应用指导

```
设计哈希函数的步骤：
1. 分析数据特征：类型、分布、规律
2. 选择基本方法：除法、乘法、多项式
3. 调整参数：表大小、基数、权重
4. 测试验证：均匀性、冲突率、效率
5. 优化改进：根据实际表现调整

常见错误：
❌ 表大小选择2的幂（除法哈希）
❌ 基数选择偶数（多项式哈希）
❌ 忽略数据分布特点
❌ 过度优化牺牲均匀性
```



**核心记忆**：
- 哈希函数是映射，无限到有限要均匀
- 除法选质数，乘法选黄金比例点
- 字符串用多项式，基数三十一最常见  
- 均匀分布是关键，雪崩效应保安全