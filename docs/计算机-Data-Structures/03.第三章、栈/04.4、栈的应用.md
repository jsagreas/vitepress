---
title: 4ã€æ ˆçš„åº”ç”¨
---
## ğŸ“š ç›®å½•

1. [æ ˆåº”ç”¨æ¦‚è¿°](#1-æ ˆåº”ç”¨æ¦‚è¿°)
2. [è¡¨è¾¾å¼å¤„ç†](#2-è¡¨è¾¾å¼å¤„ç†)
3. [å‡½æ•°è°ƒç”¨ç®¡ç†](#3-å‡½æ•°è°ƒç”¨ç®¡ç†)
4. [è¯­æ³•åˆ†æ](#4-è¯­æ³•åˆ†æ)
5. [ç®—æ³•å®ç°](#5-ç®—æ³•å®ç°)
6. [ç³»ç»Ÿåº”ç”¨](#6-ç³»ç»Ÿåº”ç”¨)

---

## 1. ğŸ¯ æ ˆåº”ç”¨æ¦‚è¿°


### 1.1 æ ˆçš„æ ¸å¿ƒåº”ç”¨é¢†åŸŸ

```
æ ˆçš„ä¸»è¦åº”ç”¨åœºæ™¯ï¼š

ğŸ”¸ è¡¨è¾¾å¼å¤„ç†ï¼š
- ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€
- è¡¨è¾¾å¼æ±‚å€¼
- æ‹¬å·åŒ¹é…æ£€æŸ¥

ğŸ”¸ ç¨‹åºæ‰§è¡Œï¼š
- å‡½æ•°è°ƒç”¨æ ˆ
- é€’å½’å®ç°
- å±€éƒ¨å˜é‡ç®¡ç†

ğŸ”¸ è¯­æ³•åˆ†æï¼š
- ç¼–è¯‘å™¨è¯æ³•åˆ†æ
- æ‹¬å·å¹³è¡¡æ£€æŸ¥
- è¯­æ³•æ ‘æ„å»º

ğŸ”¸ ç®—æ³•å®ç°ï¼š
- æ·±åº¦ä¼˜å…ˆæœç´¢
- å›æº¯ç®—æ³•
- é€’å½’è½¬è¿­ä»£
```

### 1.2 æ ˆåº”ç”¨çš„å…±åŒç‰¹ç‚¹

```
æ ˆåº”ç”¨çš„æ ¸å¿ƒç‰¹å¾ï¼š

LIFOç‰¹æ€§åŒ¹é…ï¼š
- åå¤„ç†çš„æ•°æ®å…ˆå®Œæˆ
- åµŒå¥—ç»“æ„çš„å¤„ç†
- ä¸´æ—¶æ•°æ®çš„å­˜å‚¨

çŠ¶æ€ä¿å­˜ï¼š
- ä¿å­˜ä¸­é—´çŠ¶æ€
- å›æº¯åˆ°ä¹‹å‰çŠ¶æ€
- æ’¤é”€æ“ä½œæ”¯æŒ

ç®€åŒ–å¤æ‚é—®é¢˜ï¼š
- å°†å¤æ‚é—®é¢˜åˆ†è§£
- é€æ­¥å¤„ç†å­é—®é¢˜
- ç»„åˆå­é—®é¢˜ç»“æœ
```

---

## 2. ğŸ“ è¡¨è¾¾å¼å¤„ç†


### 2.1 æ‹¬å·åŒ¹é…æ£€æŸ¥

```java
// æ‹¬å·åŒ¹é…æ£€æŸ¥
public class BracketMatching {
    
    public boolean isValidBrackets(String s) {
        Stack<Character> stack = new Stack<>();
        
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else if (c == ')' || c == ']' || c == '}') {
                if (stack.isEmpty()) {
                    return false;
                }
                
                char top = stack.pop();
                if (!isMatchingPair(top, c)) {
                    return false;
                }
            }
        }
        
        return stack.isEmpty();
    }
    
    private boolean isMatchingPair(char open, char close) {
        return (open == '(' && close == ')') ||
               (open == '[' && close == ']') ||
               (open == '{' && close == '}');
    }
}
```

### 2.2 ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€

```java
// ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€è¡¨è¾¾å¼
public class InfixToPostfix {
    
    public String convert(String infix) {
        StringBuilder postfix = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        
        for (char c : infix.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                postfix.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop(); // å¼¹å‡º'('
            } else if (isOperator(c)) {
                while (!stack.isEmpty() && 
                       precedence(stack.peek()) >= precedence(c)) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }
        
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }
        
        return postfix.toString();
    }
    
    private boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }
    
    private int precedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                return 0;
        }
    }
}
```

### 2.3 åç¼€è¡¨è¾¾å¼æ±‚å€¼

```java
// åç¼€è¡¨è¾¾å¼æ±‚å€¼
public class PostfixEvaluation {
    
    public int evaluate(String postfix) {
        Stack<Integer> stack = new Stack<>();
        
        for (char c : postfix.toCharArray()) {
            if (Character.isDigit(c)) {
                stack.push(c - '0');
            } else if (isOperator(c)) {
                int operand2 = stack.pop();
                int operand1 = stack.pop();
                int result = calculate(operand1, operand2, c);
                stack.push(result);
            }
        }
        
        return stack.pop();
    }
    
    private int calculate(int a, int b, char op) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
            default: throw new IllegalArgumentException("Invalid operator");
        }
    }
    
    private boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }
}
```

---

## 3. ğŸ“ å‡½æ•°è°ƒç”¨ç®¡ç†


### 3.1 å‡½æ•°è°ƒç”¨æ ˆåŸç†

```java
// å‡½æ•°è°ƒç”¨æ ˆçš„æ¨¡æ‹Ÿ
public class FunctionCallStack {
    
    // è°ƒç”¨æ ˆå¸§
    static class StackFrame {
        String functionName;
        Map<String, Object> localVariables;
        String returnAddress;
        
        StackFrame(String name) {
            this.functionName = name;
            this.localVariables = new HashMap<>();
        }
    }
    
    private Stack<StackFrame> callStack = new Stack<>();
    
    // å‡½æ•°è°ƒç”¨
    public void callFunction(String functionName) {
        StackFrame frame = new StackFrame(functionName);
        callStack.push(frame);
        System.out.println("è°ƒç”¨å‡½æ•°: " + functionName);
    }
    
    // å‡½æ•°è¿”å›
    public void returnFromFunction() {
        if (!callStack.isEmpty()) {
            StackFrame frame = callStack.pop();
            System.out.println("è¿”å›å‡½æ•°: " + frame.functionName);
        }
    }
    
    // è·å–å½“å‰å‡½æ•°
    public String getCurrentFunction() {
        return callStack.isEmpty() ? null : callStack.peek().functionName;
    }
    
    // è®¾ç½®å±€éƒ¨å˜é‡
    public void setLocalVariable(String name, Object value) {
        if (!callStack.isEmpty()) {
            callStack.peek().localVariables.put(name, value);
        }
    }
}
```

### 3.2 é€’å½’è½¬è¿­ä»£

```java
// é€’å½’è½¬è¿­ä»£çš„æ ˆå®ç°
public class RecursionToIteration {
    
    // é€’å½’ç‰ˆæœ¬çš„é˜¶ä¹˜
    public int factorialRecursive(int n) {
        if (n <= 1) return 1;
        return n * factorialRecursive(n - 1);
    }
    
    // è¿­ä»£ç‰ˆæœ¬çš„é˜¶ä¹˜ï¼ˆä½¿ç”¨æ ˆï¼‰
    public int factorialIterative(int n) {
        if (n <= 1) return 1;
        
        Stack<Integer> stack = new Stack<>();
        
        // å°†é€’å½’è°ƒç”¨è½¬æ¢ä¸ºæ ˆæ“ä½œ
        for (int i = n; i > 1; i--) {
            stack.push(i);
        }
        
        int result = 1;
        while (!stack.isEmpty()) {
            result *= stack.pop();
        }
        
        return result;
    }
    
    // é€’å½’ç‰ˆæœ¬çš„æ–æ³¢é‚£å¥‘
    public int fibonacciRecursive(int n) {
        if (n <= 1) return n;
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
    }
    
    // è¿­ä»£ç‰ˆæœ¬çš„æ–æ³¢é‚£å¥‘ï¼ˆä½¿ç”¨æ ˆï¼‰
    public int fibonacciIterative(int n) {
        if (n <= 1) return n;
        
        Stack<Integer> stack = new Stack<>();
        stack.push(n);
        
        int result = 0;
        while (!stack.isEmpty()) {
            int current = stack.pop();
            
            if (current <= 1) {
                result += current;
            } else {
                stack.push(current - 1);
                stack.push(current - 2);
            }
        }
        
        return result;
    }
}
```

---

## 4. ğŸ“ è¯­æ³•åˆ†æ


### 4.1 ç®€å•è®¡ç®—å™¨

```java
// ç®€å•è®¡ç®—å™¨å®ç°
public class SimpleCalculator {
    
    public int calculate(String s) {
        Stack<Integer> stack = new Stack<>();
        int num = 0;
        char operator = '+';
        
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            
            if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            }
            
            if (c == '+' || c == '-' || c == '*' || c == '/' || i == s.length() - 1) {
                switch (operator) {
                    case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop() * num);
                        break;
                    case '/':
                        stack.push(stack.pop() / num);
                        break;
                }
                operator = c;
                num = 0;
            }
        }
        
        int result = 0;
        while (!stack.isEmpty()) {
            result += stack.pop();
        }
        
        return result;
    }
}
```

### 4.2 HTMLæ ‡ç­¾åŒ¹é…

```java
// HTMLæ ‡ç­¾åŒ¹é…æ£€æŸ¥
public class HTMLTagValidator {
    
    public boolean isValidHTML(String html) {
        Stack<String> stack = new Stack<>();
        int i = 0;
        
        while (i < html.length()) {
            if (html.charAt(i) == '<') {
                int j = i + 1;
                while (j < html.length() && html.charAt(j) != '>') {
                    j++;
                }
                
                if (j < html.length()) {
                    String tag = html.substring(i + 1, j);
                    
                    if (tag.startsWith("/")) {
                        // ç»“æŸæ ‡ç­¾
                        String tagName = tag.substring(1);
                        if (stack.isEmpty() || !stack.pop().equals(tagName)) {
                            return false;
                        }
                    } else {
                        // å¼€å§‹æ ‡ç­¾
                        stack.push(tag);
                    }
                }
                i = j + 1;
            } else {
                i++;
            }
        }
        
        return stack.isEmpty();
    }
}
```

---

## 5. ğŸ”§ ç®—æ³•å®ç°


### 5.1 æ·±åº¦ä¼˜å…ˆæœç´¢

```java
// æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰
public class DFSWithStack {
    
    // å›¾çš„DFSéå†
    public void dfs(int[][] graph, int start) {
        boolean[] visited = new boolean[graph.length];
        Stack<Integer> stack = new Stack<>();
        
        stack.push(start);
        
        while (!stack.isEmpty()) {
            int vertex = stack.pop();
            
            if (!visited[vertex]) {
                visited[vertex] = true;
                System.out.print(vertex + " ");
                
                // å°†é‚»æ¥ç‚¹åŠ å…¥æ ˆ
                for (int i = graph[vertex].length - 1; i >= 0; i--) {
                    if (graph[vertex][i] == 1 && !visited[i]) {
                        stack.push(i);
                    }
                }
            }
        }
    }
    
    // äºŒå‰æ ‘DFSéå†
    public void dfsTree(TreeNode root) {
        if (root == null) return;
        
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            System.out.print(node.val + " ");
            
            // å³å­æ ‘å…ˆå…¥æ ˆï¼ˆåè®¿é—®ï¼‰
            if (node.right != null) {
                stack.push(node.right);
            }
            
            // å·¦å­æ ‘åå…¥æ ˆï¼ˆå…ˆè®¿é—®ï¼‰
            if (node.left != null) {
                stack.push(node.left);
            }
        }
    }
}
```

### 5.2 å›æº¯ç®—æ³•

```java
// å›æº¯ç®—æ³•å®ç°
public class BacktrackingWithStack {
    
    // Nçš‡åé—®é¢˜
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        
        backtrack(n, 0, stack, result);
        return result;
    }
    
    private void backtrack(int n, int row, Stack<Integer> stack, 
                          List<List<String>> result) {
        if (row == n) {
            result.add(buildBoard(stack, n));
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isValid(stack, row, col)) {
                stack.push(col);
                backtrack(n, row + 1, stack, result);
                stack.pop();  // å›æº¯
            }
        }
    }
    
    private boolean isValid(Stack<Integer> stack, int row, int col) {
        for (int i = 0; i < stack.size(); i++) {
            int prevCol = stack.get(i);
            // æ£€æŸ¥åˆ—å†²çªå’Œå¯¹è§’çº¿å†²çª
            if (prevCol == col || 
                Math.abs(prevCol - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;
    }
    
    private List<String> buildBoard(Stack<Integer> stack, int n) {
        List<String> board = new ArrayList<>();
        for (int col : stack) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < n; i++) {
                sb.append(i == col ? 'Q' : '.');
            }
            board.add(sb.toString());
        }
        return board;
    }
}
```

### 5.3 è¿·å®«æ±‚è§£

```java
// è¿·å®«æ±‚è§£
public class MazeSolver {
    
    static class Position {
        int row, col;
        
        Position(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }
    
    public boolean solveMaze(int[][] maze) {
        int rows = maze.length;
        int cols = maze[0].length;
        boolean[][] visited = new boolean[rows][cols];
        Stack<Position> stack = new Stack<>();
        
        stack.push(new Position(0, 0));
        
        while (!stack.isEmpty()) {
            Position current = stack.pop();
            int r = current.row;
            int c = current.col;
            
            // åˆ°è¾¾ç»ˆç‚¹
            if (r == rows - 1 && c == cols - 1) {
                return true;
            }
            
            if (r < 0 || r >= rows || c < 0 || c >= cols || 
                visited[r][c] || maze[r][c] == 1) {
                continue;
            }
            
            visited[r][c] = true;
            
            // æ·»åŠ å››ä¸ªæ–¹å‘çš„é‚»å±…
            stack.push(new Position(r + 1, c));
            stack.push(new Position(r - 1, c));
            stack.push(new Position(r, c + 1));
            stack.push(new Position(r, c - 1));
        }
        
        return false;
    }
}
```

---

## 6. ğŸ–¥ï¸ ç³»ç»Ÿåº”ç”¨


### 6.1 æ’¤é”€åŠŸèƒ½å®ç°

```java
// æ’¤é”€åŠŸèƒ½å®ç°
public class UndoRedoSystem {
    
    interface Command {
        void execute();
        void undo();
    }
    
    private Stack<Command> undoStack = new Stack<>();
    private Stack<Command> redoStack = new Stack<>();
    
    public void executeCommand(Command command) {
        command.execute();
        undoStack.push(command);
        redoStack.clear();  // æ¸…ç©ºé‡åšæ ˆ
    }
    
    public void undo() {
        if (!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
        }
    }
    
    public void redo() {
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.execute();
            undoStack.push(command);
        }
    }
    
    // ç¤ºä¾‹å‘½ä»¤ï¼šæ–‡æœ¬æ’å…¥
    static class InsertCommand implements Command {
        private StringBuilder text;
        private int position;
        private String insertedText;
        
        public InsertCommand(StringBuilder text, int position, String insertedText) {
            this.text = text;
            this.position = position;
            this.insertedText = insertedText;
        }
        
        @Override
        public void execute() {
            text.insert(position, insertedText);
        }
        
        @Override
        public void undo() {
            text.delete(position, position + insertedText.length());
        }
    }
}
```

### 6.2 æµè§ˆå™¨å†å²è®°å½•

```java
// æµè§ˆå™¨å†å²è®°å½•
public class BrowserHistory {
    
    private Stack<String> history = new Stack<>();
    private Stack<String> forwardStack = new Stack<>();
    private String currentPage;
    
    public BrowserHistory(String homepage) {
        this.currentPage = homepage;
    }
    
    public void visit(String url) {
        if (currentPage != null) {
            history.push(currentPage);
        }
        currentPage = url;
        forwardStack.clear();  // æ¸…ç©ºå‰è¿›å†å²
    }
    
    public String back() {
        if (!history.isEmpty()) {
            forwardStack.push(currentPage);
            currentPage = history.pop();
        }
        return currentPage;
    }
    
    public String forward() {
        if (!forwardStack.isEmpty()) {
            history.push(currentPage);
            currentPage = forwardStack.pop();
        }
        return currentPage;
    }
    
    public String getCurrentPage() {
        return currentPage;
    }
}
```

### 6.3 åº”ç”¨åœºæ™¯æ€»ç»“

```java
/*
æ ˆåº”ç”¨åœºæ™¯æ€»ç»“ï¼š

è¡¨è¾¾å¼å¤„ç†ï¼š
âœ… æ‹¬å·åŒ¹é…æ£€æŸ¥
âœ… ä¸­ç¼€è½¬åç¼€è¡¨è¾¾å¼
âœ… è¡¨è¾¾å¼æ±‚å€¼
âœ… è¯­æ³•åˆ†æ

ç¨‹åºæ‰§è¡Œï¼š
âœ… å‡½æ•°è°ƒç”¨æ ˆ
âœ… é€’å½’å®ç°
âœ… å¼‚å¸¸å¤„ç†
âœ… å±€éƒ¨å˜é‡ç®¡ç†

ç®—æ³•å®ç°ï¼š
âœ… æ·±åº¦ä¼˜å…ˆæœç´¢
âœ… å›æº¯ç®—æ³•
âœ… è¿·å®«æ±‚è§£
âœ… æ ‘çš„éå†

ç³»ç»ŸåŠŸèƒ½ï¼š
âœ… æ’¤é”€/é‡åšåŠŸèƒ½
âœ… æµè§ˆå™¨å†å²è®°å½•
âœ… å†…å­˜ç®¡ç†
âœ… ç¼–è¯‘å™¨å®ç°

æ ¸å¿ƒç‰¹ç‚¹ï¼š
1. æ‰€æœ‰åº”ç”¨éƒ½åˆ©ç”¨äº†æ ˆçš„LIFOç‰¹æ€§
2. ç”¨äºå¤„ç†åµŒå¥—ç»“æ„å’Œé€’å½’é—®é¢˜
3. æä¾›äº†ç®€å•çš„çŠ¶æ€ç®¡ç†æœºåˆ¶
4. æ˜¯è®¸å¤šå¤æ‚ç®—æ³•çš„åŸºç¡€å·¥å…·

é€‰æ‹©åŸåˆ™ï¼š
- éœ€è¦åè¿›å…ˆå‡ºçš„æ•°æ®å¤„ç†
- éœ€è¦ä¿å­˜å’Œæ¢å¤çŠ¶æ€
- å¤„ç†åµŒå¥—æˆ–é€’å½’ç»“æ„
- éœ€è¦ç®€å•çš„æ’¤é”€æœºåˆ¶
*/
```