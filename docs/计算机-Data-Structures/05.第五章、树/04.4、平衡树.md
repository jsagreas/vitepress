---
title: 4、平衡树
---
## 📚 目录

1. [平衡树概念与必要性](#1-平衡树概念与必要性)
2. [平衡的含义与度量](#2-平衡的含义与度量)
3. [AVL树详解](#3-AVL树详解)
4. [红黑树详解](#4-红黑树详解)
5. [两种平衡树对比](#5-两种平衡树对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🚨 平衡树概念与必要性


### 1.1 BST退化问题

**问题场景**：当我们按顺序插入数据时
```
插入序列：1, 2, 3, 4, 5
普通BST结果：
1               理想BST应该是：
 \                   3
  2                 / \
   \               2   4
    3             /     \
     \           1       5
      4
       \
        5

退化成链表！        平衡的树！
查找5需要5步        查找5只需要3步
```

### 1.2 性能对比分析

```
数据结构     |  查找  |  插入  |  删除  |  最坏情况
------------|--------|--------|--------|----------
有序数组     | O(log n)| O(n)  | O(n)   | 插入删除慢
链表        | O(n)   | O(1)   | O(n)   | 查找慢  
普通BST     | O(log n)| O(log n)| O(log n)| 可能退化O(n)
平衡BST     | O(log n)| O(log n)| O(log n)| 始终保持
```

### 1.3 平衡树的定义

**平衡树**：通过特定规则和操作，保证树的高度始终控制在O(log n)的BST
- **自平衡性**：插入删除后自动调整结构
- **高度保证**：最坏情况下仍保持较低高度
- **操作复杂度**：所有基本操作都是O(log n)

---

## 2. ⚖️ 平衡的含义与度量


### 2.1 什么是"平衡"

```
不平衡的树：           平衡的树：
     1                    4
      \                  / \
       2                2   6
        \              / \ / \
         3            1  3 5  7
          \
           4          高度差大      高度差小
           
深度变化大，效率低      深度稳定，效率高
```

### 2.2 平衡度量标准

**高度平衡**：
- **定义**：任意节点的左右子树高度差的绝对值≤1
- **代表**：AVL树采用此标准
- **特点**：最严格的平衡标准

**颜色平衡**：
- **定义**：通过节点颜色约束控制树的结构
- **代表**：红黑树采用此标准  
- **特点**：相对宽松但仍有效的平衡

### 2.3 平衡因子概念

```java
// AVL树中的平衡因子
class AVLNode {
    int val;
    int height;        // 节点高度
    AVLNode left, right;
}

// 平衡因子 = 右子树高度 - 左子树高度
// 合法值：-1, 0, 1
int getBalance(AVLNode node) {
    if (node == null) return 0;
    return getHeight(node.right) - getHeight(node.left);
}

int getHeight(AVLNode node) {
    return node == null ? 0 : node.height;
}
```

---

## 3. 🌳 AVL树详解


### 3.1 AVL树的概念

**定义**：任意节点的左右子树高度差不超过1的BST
**命名**：以苏联数学家Adelson-Velsky和Landis命名
**平衡条件**：|左子树高度 - 右子树高度| ≤ 1

### 3.2 AVL树失衡的四种情况

```
失衡类型及对应的旋转：

1. LL型失衡（左左）：
   在左子树的左子树插入导致失衡
   解决：右旋转
   
      y                x
     / \              / \
    x   T3   →       T1  y  
   / \                  / \
  T1  T2               T2  T3

2. RR型失衡（右右）：
   在右子树的右子树插入导致失衡
   解决：左旋转
   
   x                    y
  / \                  / \
 T1  y        →       x   T3
    / \              / \
   T2  T3           T1  T2

3. LR型失衡（左右）：
   在左子树的右子树插入导致失衡
   解决：先左旋再右旋
   
     z                z               y
    / \              / \             / \
   x   T4    →      y   T4   →      x   z
  / \              / \             / \ / \
 T1  y            x   T3          T1 T2 T3 T4
    / \          / \
   T2  T3       T1  T2

4. RL型失衡（右左）：
   在右子树的左子树插入导致失衡
   解决：先右旋再左旋
```

### 3.3 AVL旋转操作详解

```java
// 右旋转（处理LL型失衡）
private AVLNode rightRotate(AVLNode y) {
    AVLNode x = y.left;      // x成为新根
    AVLNode T2 = x.right;    // 保存x的右子树
    
    // 执行旋转
    x.right = y;             // y成为x的右子树
    y.left = T2;             // T2成为y的左子树
    
    // 更新高度（先更新y，再更新x）
    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
    
    return x;                // 返回新根
}

// 左旋转（处理RR型失衡）
private AVLNode leftRotate(AVLNode x) {
    AVLNode y = x.right;     // y成为新根
    AVLNode T2 = y.left;     // 保存y的左子树
    
    // 执行旋转
    y.left = x;              // x成为y的左子树
    x.right = T2;            // T2成为x的右子树
    
    // 更新高度
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    
    return y;                // 返回新根
}
```

### 3.4 AVL插入过程详解

```java
public AVLNode insert(AVLNode node, int val) {
    // 步骤1：正常BST插入
    if (node == null) 
        return new AVLNode(val);
    
    if (val < node.val)
        node.left = insert(node.left, val);
    else if (val > node.val)
        node.right = insert(node.right, val);
    else  
        return node; // 相等值不插入
    
    // 步骤2：更新当前节点高度
    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
    
    // 步骤3：获取平衡因子
    int balance = getBalance(node);
    
    // 步骤4：如果失衡，进行相应旋转
    // LL情况
    if (balance < -1 && val < node.left.val)
        return rightRotate(node);
    
    // RR情况  
    if (balance > 1 && val > node.right.val)
        return leftRotate(node);
    
    // LR情况
    if (balance < -1 && val > node.left.val) {
        node.left = leftRotate(node.left);
        return rightRotate(node);
    }
    
    // RL情况
    if (balance > 1 && val < node.right.val) {
        node.right = rightRotate(node.right);
        return leftRotate(node);
    }
    
    return node; // 返回未改变的节点
}
```

---

## 4. 🔴 红黑树详解


### 4.1 红黑树的概念与性质

**定义**：通过给节点着色（红/黑）并遵循特定规则来保持平衡的BST

**红黑树的五条性质**：
```
1. 节点颜色：每个节点要么是红色，要么是黑色
2. 根节点：根节点必须是黑色
3. 叶子节点：所有叶子节点（NIL节点）都是黑色
4. 红色约束：红色节点的两个子节点都必须是黑色（不能有连续的红色节点）
5. 黑高一致：从任一节点到其每个叶子的所有路径都包含相同数量的黑色节点
```

### 4.2 红黑树性质的含义解析

```
性质解析：

性质4：红色约束
    R           这是不允许的！
   / \          红色节点不能有红色子节点
  R   B         
  
    R           这是允许的
   / \          红色节点可以有黑色子节点
  B   B

性质5：黑高一致  
       B(4)         从根到任何叶子的路径：
      /   \         路径1：B(4)→R(2)→B(1)→NIL 黑色节点数=3
    R(2)  B(6)      路径2：B(4)→R(2)→B(3)→NIL 黑色节点数=3  
   /  \   /  \      路径3：B(4)→B(6)→R(5)→NIL 黑色节点数=3
 B(1) B(3)R(5)B(7)  所有路径黑色节点数相同！
```

### 4.3 红黑树节点结构

```java
enum Color { RED, BLACK }

class RBNode {
    int val;
    Color color;
    RBNode left, right, parent;
    
    public RBNode(int val) {
        this.val = val;
        this.color = Color.RED;  // 新节点默认红色
    }
}

class RedBlackTree {
    private RBNode NIL;          // 哨兵节点，代表所有叶子
    private RBNode root;
    
    public RedBlackTree() {
        NIL = new RBNode(0);
        NIL.color = Color.BLACK;  // NIL节点是黑色
        root = NIL;
    }
}
```

### 4.4 红黑树插入修复详解

```java
private void insertFixup(RBNode z) {
    // z是新插入的红色节点
    while (z.parent.color == Color.RED) {  // 违反性质4时需要修复
        
        if (z.parent == z.parent.parent.left) {  // 父节点是左子树
            RBNode uncle = z.parent.parent.right;   // 叔叔节点
            
            // 情况1：叔叔是红色
            if (uncle.color == Color.RED) {
                z.parent.color = Color.BLACK;         // 父变黑
                uncle.color = Color.BLACK;            // 叔叔变黑  
                z.parent.parent.color = Color.RED;    // 祖父变红
                z = z.parent.parent;                  // 继续向上检查
            } else {
                // 情况2：叔叔是黑色，z是右子节点
                if (z == z.parent.right) {
                    z = z.parent;
                    leftRotate(z);                    // 左旋转化为情况3
                }
                // 情况3：叔叔是黑色，z是左子节点  
                z.parent.color = Color.BLACK;         // 父变黑
                z.parent.parent.color = Color.RED;    // 祖父变红
                rightRotate(z.parent.parent);         // 右旋
            }
        } else {
            // 对称情况：父节点是右子树（逻辑相同，左右对称）
        }
    }
    root.color = Color.BLACK;  // 确保根节点是黑色
}
```

---

## 5. ⚖️ 两种平衡树对比


### 5.1 平衡标准对比

```
AVL树 vs 红黑树：

平衡严格程度：
AVL树：严格平衡，高度差≤1
     4              任意节点左右子树高度差不超过1
   /   \            树更"匀称"，高度最小
  2     6           
 / \   / \
1   3 5   7

红黑树：相对平衡，最长路径≤2×最短路径  
     4(B)           通过颜色规则保证相对平衡
   /     \          树可能稍微"倾斜"，但仍然平衡
 2(R)    6(R)       
 / \     / \
1(B)3(B)5(B)7(B)
```

### 5.2 性能特征对比

```
特性        | AVL树      | 红黑树     | 说明
-----------|------------|------------|------------------
查找性能   | 更快       | 稍慢       | AVL更矮，查找路径短
插入性能   | 较慢       | 更快       | AVL需要更多旋转
删除性能   | 较慢       | 更快       | 同插入
旋转次数   | 较多       | 较少       | AVL维护更严格
内存开销   | 高度字段   | 颜色字段   | 红黑树开销更小
```

### 5.3 适用场景

**AVL树适合**：
- 查找操作远多于插入删除
- 对查找性能要求极高的场景
- 数据相对静态的应用

**红黑树适合**：
- 插入删除操作频繁
- 需要综合平衡各种操作性能
- 实际工程应用（如标准库）

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念

```
🔸 平衡的本质：控制树高度在O(log n)，避免退化
🔸 AVL严格平衡：高度差≤1，旋转操作多，查找最优
🔸 红黑树相对平衡：颜色约束，旋转少，综合性能好
🔸 旋转操作：重新平衡的核心机制，保持BST性质不变
🔸 应用选择：根据操作模式选择合适的平衡树类型
```

### 6.2 关键理解要点


**🔹 为什么需要平衡**
```
数据有序插入 → BST退化链表 → 查找O(n) → 性能严重下降
平衡树通过旋转 → 保持树形结构 → 查找O(log n) → 性能稳定
```

**🔹 旋转操作的本质**
```
旋转 = 改变父子关系，但保持中序遍历结果不变
目的：降低树高度，提高访问效率
代价：需要额外的维护操作
```

**🔹 两种平衡策略**
```
AVL：追求绝对平衡，以旋转换性能
红黑：追求相对平衡，以简单换效率
```

### 6.3 实际应用价值

- **系统库**：Java TreeMap、C++ map都用红黑树
- **数据库**：B+树是平衡树思想的扩展
- **操作系统**：进程调度、内存管理用红黑树
- **算法竞赛**：平衡树是高级数据结构基础


**核心记忆**：
- 平衡防退化，保证对数复杂度
- AVL严格红黑松，各有优势需权衡
- 旋转是核心，保形变高效
- 工程多用红黑树，综合性能更优秀