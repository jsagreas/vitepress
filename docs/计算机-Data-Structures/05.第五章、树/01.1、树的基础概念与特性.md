---
title: 1、树的基础概念与特性
---
## 📚 目录

1. [树的概念与定义](#1-树的概念与定义)
2. [树的基本术语](#2-树的基本术语)
3. [树的重要性质](#3-树的重要性质)
4. [树的表示方法](#4-树的表示方法)
5. [树的基本分类](#5-树的基本分类)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🌳 树的概念与定义


### 1.1 什么是树

**直观理解**：树是一种模拟现实世界中树状层次关系的数据结构

```
现实中的组织架构：           数据结构中的树：
      CEO                        A
     /   \                     /   \
   CTO    CFO                 B     C  
  /  \     |                 /     / \
 研发 测试 财务              D     E   F

特点：层次分明，上下级关系清晰，没有回路
```

### 1.2 树的数学定义

**树（Tree）**：由n（n≥0）个节点组成的有限集合，当n>0时满足：
- **唯一根节点**：有且仅有一个没有前驱的节点
- **子树性质**：除根节点外的其余节点可分为m个不相交的子集，每个子集本身也是一棵树

```
递归定义的体现：
        A              整棵树
       / \
      B   C           A是根，B和C各自为根的子树
     /   / \
    D   E   F

子树1: B-D    子树2: C-E-F
每个子树仍然是树！
```

### 1.3 树的基本特征

**树的本质特征**：
- **分层结构**：节点按层次组织
- **连通无环**：任意两节点间有且仅有一条路径
- **递归性质**：子树仍然是树
- **有序性**：同一层的子树间可能有顺序关系

### 1.4 树vs其他数据结构

```
线性结构（链表）：
A → B → C → D
关系：一对一，前驱后继关系

树形结构：
    A
   /|\
  B C D
关系：一对多，父子关系

图结构：
A - B
|   |
C - D
关系：多对多，任意连接关系

网状结构：
A ←→ B
↕ ×  ↕
C ←→ D
关系：复杂多对多，可能有环
```

---

## 2. 📝 树的基本术语


### 2.1 节点关系术语

```
示例树结构：
         A          ← 根节点(Root)
       /   \
      B     C       ← A的子节点(Children)，互为兄弟(Siblings)  
     / \   / \
    D   E F   G     ← 叶子节点(Leaves)

节点B：父节点是A，子节点是D和E
节点D：祖先是A和B，D和E是兄弟节点
```

**核心术语详解**：

**根节点（Root）**：
- 定义：没有父节点的节点
- 特点：树中有且仅有一个根节点
- 示例：上图中的A

**叶子节点（Leaf/Terminal Node）**：
- 定义：没有子节点的节点
- 特点：度为0的节点
- 示例：上图中的D、E、F、G

**内部节点（Internal Node）**：
- 定义：既不是根也不是叶子的节点
- 特点：度大于0且不是根
- 示例：上图中的B、C

**父节点（Parent）**：
- 定义：某节点的直接上级节点
- 示例：A是B、C的父节点

**子节点（Child）**：
- 定义：某节点的直接下级节点
- 示例：B、C是A的子节点

**兄弟节点（Siblings）**：
- 定义：具有相同父节点的节点
- 示例：B和C是兄弟，D和E是兄弟

### 2.2 路径与层次术语

```
路径示例：
         A(层次1)
       /   \
      B     C(层次2)
     / \   / \
    D   E F   G(层次3)

从A到E的路径：A → B → E
路径长度：2（经过2条边）
```

**路径（Path）**：
- 定义：从节点A到节点B所经过的节点序列
- 特点：树中任意两节点间有且仅有一条路径

**路径长度**：
- 定义：路径上边的数量
- 计算：节点数 - 1

**祖先（Ancestor）**：
- 定义：从根到某节点路径上的所有节点
- 示例：E的祖先有A、B

**后代（Descendant）**：
- 定义：某节点为根的子树中的所有节点
- 示例：A的后代有B、C、D、E、F、G

### 2.3 度量术语详解

```
度量示例：
         A(深度0,高度3,度2)
       /   \
      B     C(深度1,高度2,度2)
     / \   / \
    D   E F   G(深度2,高度0,度0)
```

**深度（Depth）**：
- 定义：从根节点到该节点的路径长度
- 计算：根节点深度为0，向下递增
- 示例：B的深度为1，D的深度为2

**高度（Height）**：
- 定义：从该节点到最远叶子节点的路径长度
- 计算：叶子节点高度为0，向上递增
- 示例：D的高度为0，B的高度为1，A的高度为3

**层次（Level）**：
- 定义：节点的深度+1（有些定义从1开始）
- 约定：根节点为第1层或第0层

**度（Degree）**：
- 节点的度：该节点的子节点个数
- 树的度：所有节点中度的最大值
- 示例：A的度为2，B的度为2，树的度为2

---

## 3. ⚖️ 树的重要性质


### 3.1 基本数量关系

**性质1：节点数与边数的关系**
```
定理：n个节点的树有n-1条边

证明思路：
- 除根节点外，每个节点都有唯一的父节点
- 每个父子关系对应一条边
- 因此边数 = 节点数 - 1

示例验证：
         A
       /   \      节点数：7
      B     C     边数：6
     / \   / \    验证：7-1=6 ✓
    D   E F   G
```

**性质2：路径的唯一性**
```
定理：树中任意两个节点间有且仅有一条路径

证明：
- 连通性：树是连通图，任意两点间必有路径
- 唯一性：若有两条不同路径，则形成环，与树定义矛盾

应用：此性质是树搜索算法的基础
```

### 3.2 层次结构性质

**性质3：第i层的最大节点数**
```
定理：度为m的树，第i层最多有m^(i-1)个节点（i≥1）

二叉树情况(m=2)：
第1层：2^0 = 1个节点
第2层：2^1 = 2个节点  
第3层：2^2 = 4个节点
第4层：2^3 = 8个节点

验证示例：
     A        第1层：1个(≤1) ✓
    / \       第2层：2个(≤2) ✓
   B   C      第3层：4个(≤4) ✓
  /|  |\
 D E  F G
```

**性质4：高度与节点数的关系**
```
定理：具有n个节点的m叉树的最小高度为⌈log_m(n(m-1)+1)⌉-1

二叉树情况：
最小高度 ≈ ⌊log₂n⌋
最大高度 = n-1（退化为链表）

实际意义：
- 平衡树：高度接近log₂n，操作效率O(log n)
- 退化树：高度接近n，操作效率O(n)
```

### 3.3 度与叶子节点的关系

**性质5：叶子节点数与度的关系**
```
二叉树中：度为0的节点数 = 度为2的节点数 + 1

一般证明：
设n₀, n₁, n₂分别为度为0,1,2的节点数
节点总数：n = n₀ + n₁ + n₂
边数关系：n-1 = 0×n₀ + 1×n₁ + 2×n₂ = n₁ + 2×n₂

代入得：n₀ + n₁ + n₂ - 1 = n₁ + 2×n₂
化简：n₀ = n₂ + 1

实例验证：
         A
       /   \     n₀ = 4 (D,E,F,G)
      B     C    n₂ = 3 (A,B,C)  
     / \   / \   验证：4 = 3+1 ✓
    D   E F   G
```

---

## 4. 💾 树的表示方法


### 4.1 孩子表示法

```java
// 每个节点存储指向所有子节点的指针
class TreeNode {
    int data;
    List<TreeNode> children;  // 子节点列表
    
    public TreeNode(int data) {
        this.data = data;
        this.children = new ArrayList<>();
    }
}

// 适用场景：子节点数量不固定的树
// 优点：灵活，能表示任意树结构
// 缺点：查找父节点困难
```

### 4.2 父节点表示法

```java
// 用数组存储每个节点的父节点
class TreeByParent {
    int[] parent;  // parent[i]表示节点i的父节点
    int[] data;    // 节点数据
    
    // 示例：
    //      0
    //     / \
    //    1   2
    //   /   / \
    //  3   4   5
    // 
    // parent = [-1, 0, 0, 1, 2, 2]
    // data   = [A,  B, C, D, E, F]
}

// 适用场景：需要频繁查找父节点的情况
// 优点：查找父节点O(1)，空间效率高
// 缺点：查找子节点需要遍历整个数组
```

### 4.3 孩子兄弟表示法

```java
// 第一个孩子+兄弟链表表示法
class TreeNode {
    int data;
    TreeNode firstChild;   // 指向第一个子节点
    TreeNode nextSibling;  // 指向下一个兄弟节点
}

/*
原树：         转换后：
    A              A
   /|\            /
  B C D          B
 /| |           / \
E F G          E   C
              /   / \
             F   G   D

每个节点只需要两个指针！
*/

// 优点：统一表示，节省空间
// 缺点：访问特定子节点需要遍历
```

### 4.4 表示方法的选择

```
选择标准：

频繁访问子节点：
→ 选择孩子表示法
→ 直接访问所有子节点

频繁访问父节点：
→ 选择父节点表示法
→ 快速向上查找

节省存储空间：
→ 选择孩子兄弟表示法
→ 统一的二叉树结构

一般情况：
→ 孩子表示法最常用
→ 直观且灵活
```

---

## 5. 🏷️ 树的基本分类


### 5.1 按度数分类

```
二叉树：每个节点最多2个子节点
    A
   / \
  B   C

三叉树：每个节点最多3个子节点  
    A
   /|\
  B C D

m叉树：每个节点最多m个子节点
    A
   /||\
  B C D E
```

### 5.2 按结构特点分类

**有序树 vs 无序树**：
```
有序树：子节点的顺序有意义
  A        A
 / \  ≠  / \     这是两棵不同的树
B   C    C   B

无序树：子节点的顺序无关紧要
  A        A
 / \  =  / \     这是同一棵树
B   C    C   B
```

**满树 vs 完全树**：
```
满二叉树：所有层都填满
      A
    /   \
   B     C
  / \   / \
 D   E F   G

完全二叉树：除最后一层外都填满，最后一层靠左
      A
    /   \
   B     C
  / \   /
 D   E F
```

### 5.3 按平衡性分类

**平衡树 vs 非平衡树**：
```
平衡树：高度差控制在一定范围内
    4
   / \
  2   6
 / \ / \
1  3 5  7

非平衡树：可能严重倾斜
1
 \
  2
   \
    3
     \
      4
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念

```
🔸 树的本质：递归定义的分层结构，连通无环
🔸 基本术语：根、叶、父子、兄弟、深度、高度、度
🔸 核心性质：n个节点n-1条边，路径唯一性
🔸 数量关系：叶子数与度的关系，层次与节点数关系
🔸 表示方法：孩子表示法、父节点表示法、孩子兄弟表示法
🔸 基本分类：按度数、结构特点、平衡性分类
```

### 6.2 关键理解要点


**🔹 树的递归本质**
```
理解要点：
- 树 = 根节点 + 若干子树
- 每个子树本身也是完整的树
- 递归是理解和操作树的基本思维方式
```

**🔹 深度与高度的区别**
```
记忆方法：
- 深度：向下数，根节点深度0
- 高度：向上数，叶子节点高度0
- 树的高度 = 根节点高度 = 最大深度
```

**🔹 度的含义和作用**
```
实际意义：
- 节点的度：决定了分支因子
- 树的度：决定了树的形状特征
- 影响算法的时间复杂度分析
```

### 6.3 实际应用场景

- **文件系统**：目录树结构
- **组织架构**：公司部门层级
- **数据库索引**：B树、B+树
- **编译器**：语法分析树
- **人工智能**：博弈树、决策树
- **网络协议**：路由表、DNS解析



**核心记忆口诀**：
- 树连通无环分层次，递归定义是本质
- 根叶父子兄弟明，深度高度要分清
- 节点边数差一个，路径唯一不会错
- 表示方法三大类，按需选择最合适