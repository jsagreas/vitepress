---
title: 7、字典树
---
## 📚 目录

1. [字典树的概念与动机](#1-字典树的概念与动机)
2. [字典树的定义与性质](#2-字典树的定义与性质)
3. [字典树的核心操作](#3-字典树的核心操作)
4. [字典树的性能分析](#4-字典树的性能分析)
5. [字典树的应用场景](#5-字典树的应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📖 字典树的概念与动机


### 1.1 字符串处理的现实需求

**传统字符串处理的问题**：
```
场景：搜索引擎的自动补全功能
需求：用户输入"prog"，系统需要快速找到所有以"prog"开头的词汇

传统方法（数组存储）：
词汇表：["program", "programming", "progress", "project", "problem"]
查找过程：
1. 遍历每个词汇
2. 检查是否以"prog"开头
3. 时间复杂度：O(n×m)，n为词汇数，m为平均长度

问题分析：
• 效率低：每次都要完整比较
• 浪费：重复比较相同前缀
• 扩展性差：词汇增多时性能急剧下降
```

### 1.2 字典树的设计思想

**核心理念：共享公共前缀**
```
观察：许多字符串有共同前缀
思路：将公共前缀合并存储，避免重复

传统存储：                    字典树存储：
"cat"   c-a-t                     root
"car"   c-a-r               →      |
"card"  c-a-r-d                   c
"care"  c-a-r-e                   |
"careful" c-a-r-e-f-u-l          a
                                  |
重复存储了很多"c-a"             r ← t
                             / | \
                            d  e  (end)
                           /   |\
                      (end)   f (end)
                             /
                            u
                           /
                          l
                         /
                    (end)

节省空间，提高效率！
```

### 1.3 字典树的直观理解

**像一本真正的字典**：
```
字典的查找过程：
1. 先看第一个字母 - 定位到相应页面
2. 再看第二个字母 - 进一步缩小范围  
3. 逐字符匹配，直到找到目标

字典树的查找过程：
1. 从根节点开始
2. 根据当前字符走向对应子节点
3. 逐层向下，直到找到目标或失败

两者本质相同：都是按字符顺序逐步定位
```

### 1.4 字典树vs其他数据结构

```
字符串存储方案对比：

数组存储：
• 查找：O(n×m)，n为词汇数，m为平均长度
• 插入：O(n×m)，需要检查重复
• 前缀查找：O(n×m)，需要遍历所有词汇
• 空间：O(n×m)

哈希表存储：
• 查找：O(1)，但只能精确匹配
• 插入：O(1)
• 前缀查找：O(n×m)，无法优化
• 空间：O(n×m)

字典树存储：
• 查找：O(m)，m为目标字符串长度
• 插入：O(m)
• 前缀查找：O(m)，与词汇数量无关！
• 空间：O(总字符数)，共享公共前缀

字典树在前缀相关操作上有绝对优势
```

---

## 2. 🌳 字典树的定义与性质


### 2.1 字典树的严格定义

**字典树（Trie Tree/前缀树）**的定义：
- **根节点**：不包含字符，作为所有字符串的起始点
- **边的标记**：每条边都标记一个字符
- **路径表示**：从根到任意节点的路径代表一个字符串前缀
- **字符串结束标记**：某些节点标记为"字符串结束"，表示完整字符串
- **字符集约束**：每个节点的子节点对应的字符互不相同

### 2.2 字典树的节点结构

```java
class TrieNode {
    // 核心数据结构
    TrieNode[] children;    // 子节点数组，对应不同字符
    boolean isEndOfWord;    // 标记是否为某个字符串的结尾
    
    // 构造函数（假设只处理小写字母）
    public TrieNode() {
        children = new TrieNode[26];  // a-z共26个字母
        isEndOfWord = false;
    }
}

class Trie {
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();  // 根节点不存储字符
    }
}
```

### 2.3 字典树的结构图解

```
插入字符串["cat", "car", "card", "care", "careful"]后的字典树：

                 root
                  |
                  c
                  |
                  a
                  |
                  r ← t*
                 /|\
                d e (这里car结束，标记*)
               /  |\
              *   f *
                 /
                u
               /
              l
             /
            *

图解说明：
• 每个节点代表一个字符
• *表示某个字符串在此结束
• 从root到任意*的路径都是一个完整字符串
• 公共前缀"ca"被共享，只存储一次

路径示例：
root → c → a → t → * 表示"cat"
root → c → a → r → * 表示"car"  
root → c → a → r → d → * 表示"card"
root → c → a → r → e → * 表示"care"
root → c → a → r → e → f → u → l → * 表示"careful"
```

### 2.4 字典树的重要性质

**性质1：前缀共享**
```
所有具有相同前缀的字符串在树中共享相同的路径
好处：
• 节省存储空间
• 提高查找效率
• 支持高效的前缀匹配
```

**性质2：路径唯一性**
```
每个字符串对应树中唯一的路径
保证：
• 不会有重复存储
• 查找结果确定
• 插入操作无歧义
```

**性质3：深度等于字符串长度**
```
任意字符串在树中的深度等于该字符串的长度
意义：
• 查找时间与字符串长度成正比
• 与字典中词汇数量无关
• 时间复杂度可预测
```

**性质4：叶子节点的特殊性**
```
并非所有叶子节点都是字符串结束点
并非所有字符串结束点都是叶子节点

示例：
"car"和"card"中，"car"的结束点不是叶子节点
只有通过isEndOfWord标记才能区分
```

---

## 3. 🔧 字典树的核心操作


### 3.1 插入操作

```java
public void insert(String word) {
    TrieNode current = root;
    
    // 逐字符处理
    for (char c : word.toCharArray()) {
        int index = c - 'a';  // 将字符转换为数组索引
        
        // 如果对应字符的子节点不存在，创建新节点
        if (current.children[index] == null) {
            current.children[index] = new TrieNode();
        }
        
        // 移动到子节点
        current = current.children[index];
    }
    
    // 标记字符串结束
    current.isEndOfWord = true;
}
```

**插入过程的详细图解**：
```
插入字符串"cat"的过程：

初始状态：
root (children都为null)

步骤1：处理字符'c'
root.children[2] = new TrieNode()  // 'c' - 'a' = 2
root
 |
 c

步骤2：处理字符'a'  
current = root.children[2]
current.children[0] = new TrieNode()  // 'a' - 'a' = 0
root
 |
 c
 |
 a

步骤3：处理字符't'
current = current.children[0]
current.children[19] = new TrieNode()  // 't' - 'a' = 19
root
 |
 c
 |
 a
 |
 t

步骤4：标记字符串结束
current = current.children[19]
current.isEndOfWord = true
root
 |
 c
 |
 a
 |
 t*  (* 表示字符串结束)

插入完成！
```

### 3.2 查找操作

```java
public boolean search(String word) {
    TrieNode current = root;
    
    // 逐字符查找
    for (char c : word.toCharArray()) {
        int index = c - 'a';
        
        // 如果路径不存在，查找失败
        if (current.children[index] == null) {
            return false;
        }
        
        // 移动到子节点
        current = current.children[index];
    }
    
    // 检查是否为完整字符串的结尾
    return current.isEndOfWord;
}
```

**查找过程的详细分析**：
```
在包含["cat", "car", "card"]的字典树中查找"car"：

字典树结构：
        root
         |
         c
         |
         a
         |
         r*
        /
       d*

查找"car"的过程：
1. 从root开始，查找'c' → 找到，移动到c节点
2. 从c节点，查找'a' → 找到，移动到a节点  
3. 从a节点，查找'r' → 找到，移动到r节点
4. 检查r节点的isEndOfWord → true

结果：找到"car"

查找"care"的过程：
1. 从root开始，查找'c' → 找到，移动到c节点
2. 从c节点，查找'a' → 找到，移动到a节点
3. 从a节点，查找'r' → 找到，移动到r节点
4. 从r节点，查找'e' → 没有找到e子节点

结果：没有找到"care"
```

### 3.3 前缀查找操作

```java
public boolean startsWith(String prefix) {
    TrieNode current = root;
    
    // 逐字符查找前缀路径
    for (char c : prefix.toCharArray()) {
        int index = c - 'a';
        
        // 如果路径不存在，前缀不存在
        if (current.children[index] == null) {
            return false;
        }
        
        // 移动到子节点
        current = current.children[index];
    }
    
    // 能走完前缀路径就表示前缀存在
    return true;
}

// 获取所有以指定前缀开头的字符串
public List<String> getWordsWithPrefix(String prefix) {
    List<String> result = new ArrayList<>();
    TrieNode prefixNode = findPrefixNode(prefix);
    
    if (prefixNode != null) {
        dfs(prefixNode, prefix, result);
    }
    
    return result;
}

private void dfs(TrieNode node, String currentWord, List<String> result) {
    if (node.isEndOfWord) {
        result.add(currentWord);
    }
    
    for (int i = 0; i < 26; i++) {
        if (node.children[i] != null) {
            char nextChar = (char)('a' + i);
            dfs(node.children[i], currentWord + nextChar, result);
        }
    }
}
```

### 3.4 删除操作

```java
public void delete(String word) {
    delete(root, word, 0);
}

private boolean delete(TrieNode node, String word, int index) {
    if (index == word.length()) {
        // 到达字符串末尾
        if (!node.isEndOfWord) {
            return false;  // 字符串不存在
        }
        
        node.isEndOfWord = false;
        
        // 如果节点没有子节点，可以删除
        return !hasChildren(node);
    }
    
    char c = word.charAt(index);
    TrieNode child = node.children[c - 'a'];
    
    if (child == null) {
        return false;  // 字符串不存在
    }
    
    boolean shouldDeleteChild = delete(child, word, index + 1);
    
    if (shouldDeleteChild) {
        node.children[c - 'a'] = null;
        // 如果当前节点不是字符串结尾且没有其他子节点，可以删除
        return !node.isEndOfWord && !hasChildren(node);
    }
    
    return false;
}

private boolean hasChildren(TrieNode node) {
    for (TrieNode child : node.children) {
        if (child != null) {
            return true;
        }
    }
    return false;
}
```

---

## 4. 📊 字典树的性能分析


### 4.1 时间复杂度分析

```
操作类型     | 时间复杂度 | 说明
------------|------------|------------------
插入        | O(m)       | m为字符串长度
查找        | O(m)       | m为字符串长度  
前缀查找    | O(m)       | m为前缀长度
删除        | O(m)       | m为字符串长度
遍历所有词汇 | O(n×m)     | n为词汇数，m为平均长度

关键特点：
• 时间复杂度与字符串长度成正比
• 与字典中词汇数量无关
• 前缀操作效率极高
```

### 4.2 空间复杂度分析

```
空间复杂度分析：

最坏情况：
• 所有字符串都没有公共前缀
• 空间复杂度：O(字符集大小 × 所有字符串长度之和)
• 例：26个字母，总长度1000，最坏需要26000个指针空间

最好情况：
• 所有字符串都有很长的公共前缀
• 空间复杂度：接近O(最长字符串长度 × 字符集大小)

实际情况：
• 通常在最好和最坏情况之间
• 公共前缀越多，空间节省越显著
• 对于自然语言词汇，通常有较好的空间效率
```

### 4.3 与其他数据结构的性能对比

```
场景：10万个英文单词的字典

数据结构    | 查找时间 | 前缀查找 | 空间占用 | 插入时间
----------|----------|----------|----------|----------
数组       | O(n)     | O(n×m)   | 最小     | O(n)
哈希表     | O(1)     | O(n×m)   | 中等     | O(1)
BST        | O(log n) | O(n×m)   | 中等     | O(log n)
字典树     | O(m)     | O(m)     | 较大     | O(m)

字典树的优势：
• 前缀查找无与伦比的效率
• 查找时间稳定，不受词汇数量影响
• 天然支持字典序遍历

字典树的劣势：
• 空间占用相对较大
• 不适合完全随机的字符串集合
```

### 4.4 实际性能优化

```
空间优化技巧：

1. 压缩字典树（Compressed Trie）：
   合并只有一个子节点的路径
   root-a-b-c-d → root-"abcd"
   
2. 双数组字典树：
   使用两个数组代替指针结构
   节省指针空间，提高缓存命中率
   
3. 动态字符集：
   使用HashMap代替固定大小数组
   适合字符集较大或稀疏的情况

时间优化技巧：

1. 缓存热点前缀：
   将频繁查询的前缀结果缓存
   
2. 批量操作：
   一次性插入多个字符串，减少重复路径查找
   
3. 延迟删除：
   标记删除而非立即删除，减少结构调整
```

---

## 5. 🎯 字典树的应用场景


### 5.1 搜索引擎自动补全

```
应用场景：
用户输入"prog"，系统需要快速提示：
• "program"
• "programming"  
• "progress"
• "project"

实现方案：
1. 将所有查询词汇插入字典树
2. 用户输入前缀时，找到前缀对应的节点
3. 从该节点开始深度优先搜索
4. 收集所有标记为结束的路径

代码示例：
public List<String> autoComplete(String prefix) {
    List<String> suggestions = new ArrayList<>();
    TrieNode prefixNode = findPrefixNode(prefix);
    
    if (prefixNode != null) {
        dfs(prefixNode, prefix, suggestions);
    }
    
    return suggestions;
}

优势：
• 响应时间：O(前缀长度)
• 与词汇数量无关
• 支持实时补全
```

### 5.2 拼写检查与纠错

```
应用场景：
检查用户输入的单词是否正确，如果错误提供修正建议

实现方案：
1. 将标准词典插入字典树
2. 查找用户输入的单词
3. 如果不存在，寻找相似的单词

相似单词查找算法：
• 插入字符：在每个位置尝试插入26个字母
• 删除字符：删除每个位置的字符
• 替换字符：替换每个位置的字符

public List<String> spellCheck(String word) {
    if (search(word)) {
        return Arrays.asList(word);  // 拼写正确
    }
    
    List<String> suggestions = new ArrayList<>();
    
    // 尝试各种修正
    for (int i = 0; i <= word.length(); i++) {
        // 插入字符
        for (char c = 'a'; c <= 'z'; c++) {
            String candidate = word.substring(0, i) + c + word.substring(i);
            if (search(candidate)) {
                suggestions.add(candidate);
            }
        }
        
        if (i < word.length()) {
            // 删除字符
            String candidate = word.substring(0, i) + word.substring(i + 1);
            if (search(candidate)) {
                suggestions.add(candidate);
            }
            
            // 替换字符
            for (char c = 'a'; c <= 'z'; c++) {
                String candidate = word.substring(0, i) + c + word.substring(i + 1);
                if (search(candidate)) {
                    suggestions.add(candidate);
                }
            }
        }
    }
    
    return suggestions;
}
```

### 5.3 IP地址路由表

```
应用场景：
网络路由器需要根据IP地址前缀快速查找下一跳路由

IP地址的二进制表示：
192.168.1.1 → 11000000.10101000.00000001.00000001

字典树实现：
• 每个节点有两个子节点（0和1）
• 路径表示IP地址的二进制前缀
• 节点存储对应的路由信息

class IPTrieNode {
    IPTrieNode[] children = new IPTrieNode[2];  // 0和1
    String nextHop;  // 下一跳路由信息
    boolean isRoute; // 是否为路由条目
}

优势：
• 最长前缀匹配：O(32)时间复杂度
• 支持CIDR（无类别域间路由）
• 动态路由更新效率高
```

### 5.4 文本挖掘与模式匹配

```
应用场景：
在大量文本中查找特定模式或关键词

多模式匹配（AC自动机的基础）：
字典树 + 失败函数 = AC自动机

实现：
1. 将所有模式串插入字典树
2. 构建失败函数
3. 一次扫描文本，匹配所有模式

应用领域：
• 病毒特征码检测
• 垃圾邮件过滤
• 敏感词过滤
• 生物信息学中的DNA序列匹配
```

### 5.5 数据压缩

```
应用场景：
利用字符串的公共前缀特性进行数据压缩

压缩原理：
• 相同前缀只存储一次
• 使用路径编码表示字符串
• 适合处理有大量重复前缀的数据

实际应用：
• 词典压缩
• URL压缩
• 日志文件压缩
• 数据库索引压缩

压缩效果：
对于自然语言词典，压缩率可达30-50%
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念

```
🔸 设计思想：共享公共前缀，避免重复存储
🔸 基本结构：根节点+边标记字符+结束标记
🔸 核心性质：路径表示字符串，深度等于长度
🔸 基本操作：插入、查找、前缀匹配、删除
🔸 性能特点：时间复杂度O(m)，与字符串长度相关
🔸 应用场景：自动补全、拼写检查、模式匹配
```

### 6.2 关键理解要点


**🔹 字典树的本质**
```
字典树 = 有限状态自动机 + 前缀压缩
每个节点代表一个状态
每条边代表一个字符转移
路径代表字符串的前缀
```

**🔹 时间复杂度的优势**
```
传统方法：O(n×m)，n为词汇数，m为平均长度
字典树：O(m)，只与目标字符串长度相关
核心优势：查找时间与词汇数量无关
```

**🔹 空间换时间的权衡**
```
优势：极大提升前缀相关操作的效率
代价：需要额外的指针空间
适用：有大量公共前缀的字符串集合
不适用：完全随机的字符串集合
```

**🔹 与其他树结构的区别**
```
BST：基于大小关系的二分查找
堆：基于优先级的完全二叉树
字典树：基于字符序列的多叉树
每种树都针对特定问题优化
```

### 6.3 实际应用价值

- **搜索引擎**：自动补全、拼写纠错
- **网络系统**：IP路由、域名解析
- **文本处理**：模式匹配、敏感词过滤
- **数据压缩**：前缀压缩、词典编码
- **生物信息学**：基因序列匹配
- **编译器**：关键字识别、符号表

---

**核心记忆法则**：
- 前缀共享是核心，避免重复存储
- 路径表示字符串，深度等于长度
- 时间复杂度优秀，与词汇数无关
- 自动补全显神通，文本处理离不开