---
title: 5、堆与优先队列
---
## 📚 目录

1. [堆的概念与定义](#1-堆的概念与定义)
2. [堆的性质与特征](#2-堆的性质与特征)
3. [堆的基本操作](#3-堆的基本操作)
4. [优先队列的概念](#4-优先队列的概念)
5. [堆排序原理](#5-堆排序原理)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🏔️ 堆的概念与定义


### 1.1 什么是堆

**堆（Heap）**：一种特殊的**完全二叉树**，具有特定的**父子节点大小关系**

```
堆的直观理解：
像一座山峰 - 父节点总是比子节点"高"（大顶堆）
或者像一个漏斗 - 父节点总是比子节点"低"（小顶堆）

大顶堆示例：                小顶堆示例：
     100                        1
    /   \                     /   \
   19    36                 4     3
  / \   / \                / \   / \
 17  3 25  1              9  10 14  7
/ \                      / \
2  7                    15  20

父节点 ≥ 子节点            父节点 ≤ 子节点
```

### 1.2 堆的严格定义

**堆必须满足两个条件**：
1. **结构性质**：必须是完全二叉树
2. **堆性质（堆序性）**：
   - **大顶堆（Max Heap）**：父节点值 ≥ 子节点值
   - **小顶堆（Min Heap）**：父节点值 ≤ 子节点值

### 1.3 堆vs其他树结构

```
数据结构对比：

完全二叉树：
    8               只要求结构完整
   / \              对节点值无特殊要求
  4   9
 / \
1   3

BST：
    8               要求左小右大
   / \              但不要求是完全二叉树  
  4   10
 / \    \
1   6   12

堆：
    10              要求父大子小（大顶堆）
   / \              且必须是完全二叉树
  8   9
 / \
4   7
```

### 1.4 为什么用完全二叉树

```
选择完全二叉树的原因：

1. 空间效率：可以用数组紧凑存储，无空间浪费
2. 访问效率：父子关系可通过下标直接计算
3. 操作简单：插入和删除位置固定
4. 缓存友好：数组连续存储，访问局部性好

不完全二叉树的问题：
     10
    /  \
   8    9
  /      \
 4        7

数组表示：[10, 8, 9, 4, _, _, 7]
浪费空间，且破坏了下标关系
```

---

## 2. 📏 堆的性质与特征


### 2.1 堆的基本性质

**性质1：完全二叉树的结构性质**
```
• 除最后一层外，所有层都完全填满
• 最后一层从左到右连续填充
• 高度为⌊log₂n⌋

示例（n=10）：
      1
    /   \
   2     3
  / \   / \
 4   5 6   7
/ \ /
8 9 10

高度 = ⌊log₂10⌋ = 3
```

**性质2：堆序性质**
```
大顶堆：对于任意节点i
• parent[i] ≥ node[i]
• parent[i] ≥ left_child[i]  
• parent[i] ≥ right_child[i]

小顶堆：对于任意节点i
• parent[i] ≤ node[i]
• parent[i] ≤ left_child[i]
• parent[i] ≤ right_child[i]
```

### 2.2 数组表示的下标关系

**核心公式（下标从0开始）**：
```java
对于下标为i的节点：
• 父节点下标：(i-1)/2
• 左子节点下标：2*i+1  
• 右子节点下标：2*i+2

示例验证：
数组：[10, 8, 9, 4, 7, 5, 6, 1, 3]
      10
    /    \
   8      9    
  / \    / \
 4   7  5   6
/ \
1  3

节点8（下标1）：
• 父节点：(1-1)/2 = 0 → 10 ✓
• 左子节点：2*1+1 = 3 → 4 ✓  
• 右子节点：2*1+2 = 4 → 7 ✓
```

### 2.3 堆的重要特征

**特征1：根节点包含极值**
```
大顶堆：根节点是最大值
小顶堆：根节点是最小值

这是堆最重要的特征，使得找极值的时间复杂度为O(1)
```

**特征2：部分有序性**
```
堆不是完全有序的：
     10        虽然10是最大的，但8和9的大小关系不确定
    /  \       同层节点之间没有大小关系约束
   8    9      只保证父子关系的有序性
  / \  / \
 4  7 5  6

这与BST的全序性不同！
```

**特征3：动态性**
```
堆支持动态插入和删除：
• 插入：添加到末尾，然后上浮调整
• 删除：移除根节点，末尾元素补充，然后下沉调整
• 调整过程：时间复杂度O(log n)
```

---

## 3. 🔧 堆的基本操作


### 3.1 堆的存储结构

```java
class MaxHeap {
    private int[] heap;
    private int size;      // 当前堆中元素个数
    private int capacity;  // 堆的最大容量
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.heap = new int[capacity];
        this.size = 0;
    }
    
    // 基本的下标关系方法
    private int parent(int i) { return (i - 1) / 2; }
    private int leftChild(int i) { return 2 * i + 1; }
    private int rightChild(int i) { return 2 * i + 2; }
    
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
```

### 3.2 上浮操作（HeapifyUp）

**概念**：新插入的元素可能违反堆性质，需要向上调整
```java
private void heapifyUp(int index) {
    // 当前节点比父节点大时，需要交换并继续向上
    while (index > 0 && heap[index] > heap[parent(index)]) {
        swap(index, parent(index));
        index = parent(index);
    }
}

/*
上浮过程图解（插入15）：
步骤1：插入到末尾
     10
    /  \
   8    9
  / \  / \
 4  7 5   6
/
15  ← 新插入

步骤2：15 > 4，交换
     10
    /  \
   8    9
  / \  / \
15  7 5  6
/
4

步骤3：15 > 8，交换
     10
    /  \
  15    9
  / \  / \
 8  7 5   6
/
4

步骤4：15 > 10，交换
     15
    /  \
  10    9
  / \  / \
 8  7 5   6
/
4

完成：堆性质恢复
*/
```

### 3.3 下沉操作（HeapifyDown）

**概念**：删除根节点后，用最后一个元素替换，可能违反堆性质，需要向下调整
```java
private void heapifyDown(int index) {
    while (leftChild(index) < size) {
        // 找到子节点中的较大者
        int largerChild = leftChild(index);
        if (rightChild(index) < size && 
            heap[rightChild(index)] > heap[leftChild(index)]) {
            largerChild = rightChild(index);
        }
        
        // 如果当前节点已经比子节点大，停止下沉
        if (heap[index] >= heap[largerChild]) {
            break;
        }
        
        // 否则交换并继续下沉
        swap(index, largerChild);
        index = largerChild;
    }
}

/*
下沉过程图解（删除根节点15）：
步骤1：删除15，用4替换
      4     ← 4替换15
    /  \
  10    9
  / \  / \
 8  7 5   6

步骤2：4 < 10，交换
     10
    /  \
   4    9
  / \  / \
 8  7 5   6

步骤3：4 < 8，交换
     10
    /  \
   8    9
  / \  / \
 4  7 5   6

完成：堆性质恢复
*/
```

### 3.4 插入操作

```java
public void insert(int val) {
    if (size >= capacity) {
        throw new RuntimeException("Heap is full");
    }
    
    // 1. 插入到堆的末尾
    heap[size] = val;
    
    // 2. 向上调整恢复堆性质
    heapifyUp(size);
    
    // 3. 增加堆大小
    size++;
}
```

### 3.5 删除最大值操作

```java
public int extractMax() {
    if (size == 0) {
        throw new RuntimeException("Heap is empty");
    }
    
    // 1. 保存最大值（根节点）
    int max = heap[0];
    
    // 2. 用最后一个元素替换根节点
    heap[0] = heap[size - 1];
    size--;
    
    // 3. 向下调整恢复堆性质
    if (size > 0) {
        heapifyDown(0);
    }
    
    return max;
}
```

### 3.6 构建堆操作

```java
public void buildHeap(int[] arr) {
    size = arr.length;
    heap = Arrays.copyOf(arr, capacity);
    
    // 从最后一个非叶子节点开始，自下而上进行heapify
    for (int i = parent(size - 1); i >= 0; i--) {
        heapifyDown(i);
    }
}

/*
为什么从最后一个非叶子节点开始？
因为叶子节点本身就满足堆性质（没有子节点）
只需要调整有子节点的节点

时间复杂度：O(n)而不是O(n log n)
*/
```

---

## 4. 🎯 优先队列的概念


### 4.1 什么是优先队列

**优先队列（Priority Queue）**：不是先进先出，而是**优先级高的先出**的队列

```
普通队列（FIFO）：
进入顺序：A(3) → B(1) → C(5) → D(2)
出队顺序：A → B → C → D

优先队列（按数值大小优先）：
进入顺序：A(3) → B(1) → C(5) → D(2)
出队顺序：C(5) → A(3) → D(2) → B(1)

高优先级的元素总是先出队！
```

### 4.2 优先队列的抽象接口

```java
interface PriorityQueue<T> {
    void insert(T item);        // 插入元素
    T extractMax();             // 取出并删除最高优先级元素
    T peekMax();               // 查看最高优先级元素但不删除
    boolean isEmpty();         // 判断是否为空
    int size();               // 获取元素个数
}
```

### 4.3 优先队列的实现方式对比

```
实现方式      | 插入时间 | 删除最值时间 | 查找最值时间
-------------|----------|-------------|-------------
无序数组      | O(1)     | O(n)        | O(n)
有序数组      | O(n)     | O(1)        | O(1)  
无序链表      | O(1)     | O(n)        | O(n)
有序链表      | O(n)     | O(1)        | O(1)
BST          | O(log n) | O(log n)    | O(log n)
堆           | O(log n) | O(log n)    | O(1)

堆是实现优先队列最优的数据结构！
```

### 4.4 堆实现优先队列

```java
class PriorityQueueImpl {
    private MaxHeap heap;
    
    public PriorityQueueImpl(int capacity) {
        heap = new MaxHeap(capacity);
    }
    
    public void enqueue(int priority) {
        heap.insert(priority);
    }
    
    public int dequeue() {
        return heap.extractMax();
    }
    
    public int peek() {
        return heap.peek();
    }
    
    public boolean isEmpty() {
        return heap.isEmpty();
    }
}
```

### 4.5 优先队列的应用场景

```
实际应用：

1. 操作系统进程调度：
   高优先级进程先执行

2. 网络数据包处理：
   重要数据包优先转发

3. 图算法（Dijkstra、Prim）：
   选择权重最小的边或顶点

4. 任务调度系统：
   紧急任务优先处理

5. 医院急诊系统：
   病情严重的患者优先治疗
```

---

## 5. 📊 堆排序原理


### 5.1 堆排序的基本思想

**核心思想**：利用堆的性质进行排序
1. **构建堆**：将数组调整成堆结构
2. **反复取根**：不断取出堆顶元素（最值），放到已排序区域
3. **维护堆**：每次取出后重新调整剩余元素的堆性质

### 5.2 堆排序过程详解

```java
public void heapSort(int[] arr) {
    int n = arr.length;
    
    // 步骤1：构建最大堆（自下而上）
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 步骤2：一个个取出元素
    for (int i = n - 1; i > 0; i--) {
        // 将当前最大值（arr[0]）移到末尾
        swap(arr, 0, i);
        
        // 对剩余元素重新调整堆
        heapify(arr, i, 0);
    }
}

private void heapify(int[] arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, n, largest);
    }
}
```

### 5.3 堆排序过程图解

```
初始数组：[4, 10, 3, 5, 1]

步骤1：构建最大堆
      10
     /  \
    5    3
   / \
  4   1

步骤2：排序过程
第1轮：取出10，放到末尾
未排序区：[1,5,3,4] | 已排序区：[10]
调整后：  [5,4,3,1] | [10]

第2轮：取出5，放到末尾  
未排序区：[1,4,3] | 已排序区：[5,10]
调整后：  [4,1,3] | [5,10]

第3轮：取出4，放到末尾
未排序区：[3,1] | 已排序区：[4,5,10]
调整后：  [3,1] | [4,5,10]

第4轮：取出3，放到末尾
未排序区：[1] | 已排序区：[3,4,5,10]

最终结果：[1,3,4,5,10]
```

### 5.4 堆排序的性能分析

```
时间复杂度：
• 构建堆：O(n)
• n-1次取出和调整：O(n log n)
• 总体：O(n log n)

空间复杂度：O(1)（原地排序）

特点：
• 最好、最坏、平均时间复杂度都是O(n log n)
• 不稳定排序（相同元素的相对位置可能改变）
• 原地排序，空间效率高
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念

```
🔸 堆的定义：完全二叉树+堆序性质
🔸 堆的性质：父子大小关系，数组存储的下标关系
🔸 基本操作：插入（上浮）、删除（下沉）、构建堆
🔸 优先队列：堆是实现优先队列的最优数据结构
🔸 堆排序：利用堆性质的O(n log n)排序算法
🔸 应用场景：调度系统、图算法、Top-K问题
```

### 6.2 关键理解要点


**🔹 堆的本质**
```
堆 = 完全二叉树的结构 + 父子大小关系的约束
结构保证效率，关系保证功能
```

**🔹 堆vs BST的区别**
```
堆：部分有序，只保证父子关系，根是极值
BST：全序，保证左小右大，中序遍历有序
用途不同：堆用于优先队列，BST用于查找
```

**🔹 上浮下沉的本质**
```
上浮：新元素可能太"优秀"，需要往上爬
下沉：替换元素可能不够"格"，需要往下沉
都是为了恢复被破坏的堆性质
```

**🔹 数组存储的优势**
```
紧凑存储：无空间浪费
快速定位：下标直接计算父子关系
缓存友好：连续内存访问
操作简单：尾部插入删除
```

### 6.3 实际应用价值

- **操作系统**：进程调度、内存管理
- **图算法**：Dijkstra最短路径、Prim最小生成树
- **数据处理**：Top-K问题、数据流中位数
- **任务调度**：优先级任务队列
- **游戏开发**：A*寻路算法

### 6.4 学习要点

1. **理解完全二叉树的价值**：为什么选择这种结构
2. **掌握数组存储技巧**：下标关系的计算和应用
3. **熟练调整操作**：上浮下沉是堆操作的核心
4. **理解优先队列抽象**：堆只是实现方式之一
5. **练习实际应用**：通过编程解决Top-K等问题

### 6.5 常见应用问题

```
经典问题：
• 数组中的第K大元素
• 合并K个有序链表  
• 数据流中的中位数
• 前K个高频元素
• 丑数问题
• 会议室安排问题
```

---

**核心记忆法则**：
- 完全二叉加大小关系，数组存储效率佳
- 根节点必是极值，上浮下沉调整法
- 优先队列最佳选择，调度算法离不开
- 堆排序稳定对数级，Top-K问题显神通