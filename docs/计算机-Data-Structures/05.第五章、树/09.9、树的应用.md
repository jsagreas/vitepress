---
title: 9、树的应用
---
## 📚 目录

1. [二叉搜索树(BST)](#1-二叉搜索树bst)
2. [平衡二叉树(AVL)](#2-平衡二叉树avl)
3. [堆与优先队列](#3-堆与优先队列)
4. [哈夫曼树](#4-哈夫曼树)
5. [并查集](#5-并查集)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 二叉搜索树(BST)


### 1.1 BST的定义与性质

**二叉搜索树(Binary Search Tree)**：满足以下性质的二叉树
- 左子树上所有节点的值 < 根节点的值
- 右子树上所有节点的值 > 根节点的值
- 左右子树也分别是二叉搜索树

```
BST示例：
         8
       /   \
      3     10
     / \      \
    1   6      14
       / \    /
      4   7  13

特点验证：
- 左子树{1,3,4,6,7} < 8 < 右子树{10,13,14} ✓
- 每个子树都满足BST性质 ✓
```

### 1.2 BST的基本操作

**查找操作**：
```java
TreeNode search(TreeNode root, int key) {
    if (root == null || root.val == key) {
        return root;
    }
    
    if (key < root.val) {
        return search(root.left, key);   // 在左子树中查找
    } else {
        return search(root.right, key);  // 在右子树中查找
    }
}

// 时间复杂度：O(h) - h为树的高度
// 最好情况：O(log n)，最坏情况：O(n)
```

**插入操作**：
```java
TreeNode insert(TreeNode root, int key) {
    if (root == null) {
        return new TreeNode(key);
    }
    
    if (key < root.val) {
        root.left = insert(root.left, key);
    } else if (key > root.val) {
        root.right = insert(root.right, key);
    }
    
    return root;
}
```

**删除操作**：
```java
TreeNode delete(TreeNode root, int key) {
    if (root == null) return null;
    
    if (key < root.val) {
        root.left = delete(root.left, key);
    } else if (key > root.val) {
        root.right = delete(root.right, key);
    } else {
        // 找到要删除的节点
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        
        // 有两个子节点：找右子树的最小节点替代
        TreeNode minNode = findMin(root.right);
        root.val = minNode.val;
        root.right = delete(root.right, minNode.val);
    }
    
    return root;
}
```

### 1.3 BST的核心优势

**为什么使用BST**：
- **有序性**：中序遍历得到有序序列
- **查找效率**：平均O(log n)的查找时间
- **动态维护**：支持插入、删除操作

```
BST vs 数组 vs 链表：
                查找    插入    删除
有序数组         O(log n) O(n)    O(n)
有序链表         O(n)     O(n)    O(n)
BST(平衡)       O(log n) O(log n) O(log n)
```

### 1.4 BST的问题与解决

**退化问题**：
```
最坏情况 - 退化为链表：
1
 \
  2
   \
    3
     \
      4

此时所有操作都是O(n)
```

**解决方案**：使用平衡二叉树(AVL、红黑树等)

---

## 2. ⚖️ 平衡二叉树(AVL)


### 2.1 AVL树的定义

**AVL树**：任意节点的左右子树高度差不超过1的二叉搜索树

```
平衡因子(Balance Factor) = 左子树高度 - 右子树高度
AVL树要求：|BF| ≤ 1

平衡的AVL树：
         4(BF=0)
       /   \
      2(BF=0) 6(BF=1)
     / \     /
    1   3   5

不平衡的例子：
         4(BF=1)    
       /   \
      2(BF=2) 6       ← 违反AVL性质
     /       /
    1       5
   /
  0
```

### 2.2 AVL树的旋转操作

**四种旋转类型**：

**右旋(RR旋转)**：
```
不平衡情况：        右旋后：
    3                 2
   /                 / \
  2          →      1   3
 /
1

代码实现：
TreeNode rightRotate(TreeNode y) {
    TreeNode x = y.left;
    TreeNode T2 = x.right;
    
    x.right = y;
    y.left = T2;
    
    return x;  // 新的根节点
}
```

**左旋(LL旋转)**：
```
不平衡情况：        左旋后：
  1                   2
   \                 / \
    2        →      1   3
     \
      3
```

**左右旋(LR旋转)**：
```
不平衡情况：        先左旋：         再右旋：
    3                 3                2
   /                 /                / \
  1         →       2        →      1   3
   \               /
    2             1
```

**右左旋(RL旋转)**：
```
不平衡情况：        先右旋：         再左旋：
  1                 1                  2
   \                 \                / \
    3        →        2      →      1   3
   /                   \
  2                     3
```

### 2.3 AVL树的插入操作

```java
TreeNode insert(TreeNode root, int key) {
    // 1. 正常BST插入
    if (root == null) return new TreeNode(key);
    
    if (key < root.val) {
        root.left = insert(root.left, key);
    } else if (key > root.val) {
        root.right = insert(root.right, key);
    }
    
    // 2. 更新高度
    updateHeight(root);
    
    // 3. 检查平衡因子
    int balance = getBalance(root);
    
    // 4. 根据不平衡类型进行旋转
    if (balance > 1 && key < root.left.val) {
        return rightRotate(root);           // LL情况
    }
    if (balance < -1 && key > root.right.val) {
        return leftRotate(root);            // RR情况
    }
    if (balance > 1 && key > root.left.val) {
        root.left = leftRotate(root.left);  // LR情况
        return rightRotate(root);
    }
    if (balance < -1 && key < root.right.val) {
        root.right = rightRotate(root.right); // RL情况
        return leftRotate(root);
    }
    
    return root;
}
```

### 2.4 AVL树的优势

**核心优势**：
- **保证平衡**：高度始终保持O(log n)
- **稳定性能**：所有操作都是O(log n)
- **自动调整**：插入删除后自动保持平衡

**应用场景**：
- 需要频繁查找的场景
- 对性能要求严格的系统
- 数据库索引结构

---

## 3. 🏔️ 堆与优先队列


### 3.1 堆的定义与性质

**堆(Heap)**：满足堆性质的完全二叉树

**最大堆性质**：父节点的值 ≥ 子节点的值
**最小堆性质**：父节点的值 ≤ 子节点的值

```
最大堆示例：
         10
       /    \
      9      8
     / \    / \
    7   6  5   4
   /
  3

特点：
- 根节点是最大值
- 完全二叉树结构
- 父节点 ≥ 子节点
```

### 3.2 堆的数组表示

**数组实现**：利用完全二叉树的性质用数组存储

```
堆的数组表示：
数组：[10, 9, 8, 7, 6, 5, 4, 3]
索引： 0  1  2  3  4  5  6  7

父子关系：
- 父节点索引：(i-1)/2
- 左子节点索引：2*i+1  
- 右子节点索引：2*i+2

示例：
节点9(索引1)：
- 父节点：(1-1)/2 = 0 → 节点10
- 左子节点：2*1+1 = 3 → 节点7
- 右子节点：2*1+2 = 4 → 节点6
```

### 3.3 堆的基本操作

**插入操作(向上调整)**：
```java
void insert(int value) {
    heap.add(value);              // 添加到末尾
    int index = heap.size() - 1;
    
    // 向上调整
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (heap.get(index) <= heap.get(parent)) break;
        
        swap(index, parent);
        index = parent;
    }
}
```

**删除最大值(向下调整)**：
```java
int extractMax() {
    if (heap.isEmpty()) return -1;
    
    int max = heap.get(0);
    int last = heap.remove(heap.size() - 1);
    
    if (!heap.isEmpty()) {
        heap.set(0, last);
        heapifyDown(0);  // 向下调整
    }
    
    return max;
}

void heapifyDown(int index) {
    int largest = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    
    if (left < heap.size() && heap.get(left) > heap.get(largest)) {
        largest = left;
    }
    if (right < heap.size() && heap.get(right) > heap.get(largest)) {
        largest = right;
    }
    
    if (largest != index) {
        swap(index, largest);
        heapifyDown(largest);
    }
}
```

### 3.4 堆的应用

**优先队列**：
- 任务调度系统
- Dijkstra算法
- A*搜索算法

**堆排序**：
```java
void heapSort(int[] arr) {
    // 1. 建堆
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        heapify(arr, arr.length, i);
    }
    
    // 2. 逐个取出最大元素
    for (int i = arr.length - 1; i > 0; i--) {
        swap(arr, 0, i);
        heapify(arr, i, 0);
    }
}
```

**TopK问题**：
- 找最大的K个元素：使用最小堆
- 找最小的K个元素：使用最大堆

---

## 4. 🌿 哈夫曼树


### 4.1 哈夫曼树的概念

**哈夫曼树(Huffman Tree)**：给定n个权值作为n个叶子节点，构造的带权路径长度最小的二叉树

**关键概念**：
- **权值**：节点的重要程度或频率
- **路径长度**：从根节点到某节点的路径上的边数
- **带权路径长度**：节点权值 × 路径长度
- **树的带权路径长度(WPL)**：所有叶子节点的带权路径长度之和

```
示例：
字符频率：A(5), B(9), C(12), D(13), E(16), F(45)

哈夫曼树：
              100
            /      \
          55         45(F)
        /    \
      25      30
     /  \    /  \
   A(5) 20  C(12) 18
        / \       / \
      B(9) 11   D(13) E(16)

WPL = 5×3 + 9×3 + 12×2 + 13×2 + 16×2 + 45×1 = 224
```

### 4.2 哈夫曼树的构造算法

**构造步骤**：
1. 将所有节点放入优先队列（按权值升序）
2. 每次取出两个权值最小的节点
3. 合并为一个新节点，权值为两者之和
4. 将新节点放回队列
5. 重复直到只剩一个节点

```java
TreeNode buildHuffmanTree(int[] weights) {
    PriorityQueue<TreeNode> pq = new PriorityQueue<>(
        (a, b) -> a.weight - b.weight
    );
    
    // 初始化叶子节点
    for (int weight : weights) {
        pq.offer(new TreeNode(weight));
    }
    
    // 构造哈夫曼树
    while (pq.size() > 1) {
        TreeNode left = pq.poll();
        TreeNode right = pq.poll();
        
        TreeNode parent = new TreeNode(left.weight + right.weight);
        parent.left = left;
        parent.right = right;
        
        pq.offer(parent);
    }
    
    return pq.poll();
}
```

### 4.3 哈夫曼编码

**编码规则**：
- 左子树编码为0，右子树编码为1
- 从根节点到叶子节点的路径就是字符编码

```
基于上面哈夫曼树的编码：
A: 000
B: 001  
C: 01
D: 100
E: 101
F: 11

编码特点：
- 频率高的字符编码短
- 任何字符的编码都不是另一个的前缀（前缀码）
```

### 4.4 哈夫曼编码的应用

**数据压缩**：
- 文件压缩软件
- 图像压缩(JPEG)
- 视频压缩

**优势**：
- 压缩率高
- 无损压缩
- 解码唯一性

---

## 5. 🔗 并查集


### 5.1 并查集的概念

**并查集(Union-Find)**：用于处理动态连通性问题的数据结构

**主要操作**：
- **Find**：查找元素属于哪个集合
- **Union**：合并两个集合

```
应用场景：
- 判断图中两点是否连通
- 检测图中是否有环
- 社交网络中的朋友关系
- 网络连接问题

示例：
初始：{1} {2} {3} {4} {5}
Union(1,2)：{1,2} {3} {4} {5}
Union(3,4)：{1,2} {3,4} {5}
Union(1,3)：{1,2,3,4} {5}
```

### 5.2 并查集的实现

**基本实现**：
```java
class UnionFind {
    private int[] parent;
    private int[] rank;  // 树的高度
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;  // 每个元素的父节点是自己
            rank[i] = 0;
        }
    }
    
    // 查找根节点（带路径压缩）
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // 路径压缩
        }
        return parent[x];
    }
    
    // 合并两个集合（按秩合并）
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
    
    // 判断是否在同一集合
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### 5.3 并查集的优化

**路径压缩**：
```
查找过程中将路径上的所有节点直接指向根节点

优化前：           优化后：
    1                 1
   /               / | \
  2               2  3  4
 /               
3               
|
4

效果：后续查找操作更快
```

**按秩合并**：
```
合并时将矮的树合并到高的树下面

避免：        推荐：
  1             3
 /             / \
2             1   4
|            /
3           2
|
4
```

### 5.4 并查集的应用

**检测无向图中的环**：
```java
boolean hasCycle(int[][] edges, int n) {
    UnionFind uf = new UnionFind(n);
    
    for (int[] edge : edges) {
        int u = edge[0], v = edge[1];
        if (uf.connected(u, v)) {
            return true;  // 发现环
        }
        uf.union(u, v);
    }
    
    return false;
}
```

**岛屿数量问题**：
```java
int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;
    
    int m = grid.length, n = grid[0].length;
    UnionFind uf = new UnionFind(m * n);
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                // 与相邻的陆地合并
                if (i > 0 && grid[i-1][j] == '1') {
                    uf.union(i*n + j, (i-1)*n + j);
                }
                if (j > 0 && grid[i][j-1] == '1') {
                    uf.union(i*n + j, i*n + j-1);
                }
            }
        }
    }
    
    // 统计连通分量数
    Set<Integer> islands = new HashSet<>();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                islands.add(uf.find(i*n + j));
            }
        }
    }
    
    return islands.size();
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的应用

```
🔸 二叉搜索树(BST)：
   - 核心：左小右大的性质
   - 应用：查找、排序、范围查询
   - 问题：可能退化为链表

🔸 平衡二叉树(AVL)：
   - 核心：高度平衡，|BF| ≤ 1
   - 应用：需要稳定O(log n)性能的场景
   - 关键：四种旋转操作

🔸 堆(Heap)：
   - 核心：完全二叉树+堆性质
   - 应用：优先队列、TopK问题、堆排序
   - 特点：数组实现，O(log n)插入删除

🔸 哈夫曼树：
   - 核心：带权路径长度最小
   - 应用：数据压缩、编码
   - 算法：贪心策略构造

🔸 并查集：
   - 核心：动态连通性
   - 应用：检测环、连通分量
   - 优化：路径压缩+按秩合并
```

### 6.2 应用选择指南

```
查找需求：
- 静态数据 → 有序数组+二分查找
- 动态数据 → BST或AVL树
- 需要稳定性能 → AVL树或红黑树

优先级需求：
- 动态维护最值 → 堆
- TopK问题 → 小根堆或大根堆
- 任务调度 → 优先队列(堆实现)

编码压缩：
- 文本压缩 → 哈夫曼编码
- 需要最优前缀码 → 哈夫曼树

连通性问题：
- 动态连通性 → 并查集
- 检测环 → 并查集或DFS
- 最小生成树 → 并查集+Kruskal
```

### 6.3 关键理解要点

**🔹 性能对比**
```
数据结构    查找      插入      删除      空间
数组        O(n)      O(n)      O(n)      O(n)
有序数组    O(log n)  O(n)      O(n)      O(n)
BST(平衡)   O(log n)  O(log n)  O(log n)  O(n)
BST(退化)   O(n)      O(n)      O(n)      O(n)
堆          O(n)      O(log n)  O(log n)  O(n)
```

**🔹 应用场景记忆**
```
BST → 需要有序性和动态操作
AVL → 需要严格的性能保证
堆 → 需要快速访问极值
哈夫曼树 → 需要最优编码
并查集 → 需要处理连通性
```

**记忆口诀**：
- 查找排序用搜索，平衡树来保性能
- 优先队列堆来做，最值操作最拿手  
- 编码压缩哈夫曼，权值越大路径短
- 连通合并并查集，路径压缩效率高