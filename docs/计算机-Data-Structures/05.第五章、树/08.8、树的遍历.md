---
title: 8、树的遍历
---
## 📚 目录

1. [遍历的基本概念](#1-遍历的基本概念)
2. [深度优先遍历(DFS)](#2-深度优先遍历dfs)
3. [广度优先遍历(BFS)](#3-广度优先遍历bfs)
4. [遍历应用与选择](#4-遍历应用与选择)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🔍 遍历的基本概念


### 1.1 什么是树的遍历

**遍历(Traversal)**：按照某种规则访问树中每个节点一次且仅一次的过程

```
示例树：
         A
       /   \
      B     C
     / \   / \
    D   E F   G

遍历目标：按不同顺序访问所有节点 A,B,C,D,E,F,G
```

### 1.2 遍历的分类

**按访问策略分类**：
- **深度优先遍历(DFS)**：沿着树的深度遍历，尽可能深入分支
- **广度优先遍历(BFS)**：按层次逐层遍历，先访问同层节点

```
深度优先思想：     广度优先思想：
往深处走          按层次走
    A                 A      (第1层)
   / \               / \     
  B   C             B   C    (第2层)
 /   /             /   /
D   F             D   F      (第3层)

访问顺序：        访问顺序：
A→B→D→C→F        A→B→C→D→F
```

### 1.3 遍历的核心意义

**为什么需要遍历**：
- **数据处理**：对树中每个节点进行操作
- **查找搜索**：在树中查找特定节点
- **结构分析**：分析树的结构特征
- **算法基础**：许多树算法都基于遍历

---

## 2. 🏃 深度优先遍历(DFS)


### 2.1 DFS的基本思想

**核心理念**：沿着路径尽可能深入，直到无法继续，然后回溯

```
DFS访问过程：
         A
       /   \
      B     C
     / \   / \
    D   E F   G

步骤演示：
1. 从A开始
2. 访问B(A的左子树)
3. 访问D(B的左子树)  
4. D无子节点，回溯到B
5. 访问E(B的右子树)
6. 回溯到A
7. 访问C(A的右子树)
8. 继续访问F,G...
```

### 2.2 前序遍历(PreOrder)

**访问顺序**：根节点 → 左子树 → 右子树

```
访问规则：
1. 访问根节点
2. 前序遍历左子树  
3. 前序遍历右子树

示例：
         A
       /   \
      B     C
     / \   / \
    D   E F   G

访问过程：
A → B → D → E → C → F → G

递归实现：
```java
void preOrder(TreeNode root) {
    if (root == null) return;
    
    visit(root);           // 访问根节点
    preOrder(root.left);   // 遍历左子树
    preOrder(root.right);  // 遍历右子树
}
```

**前序遍历特点**：
- 根节点总是最先访问
- 适用于树的复制、前缀表达式求值
- 能够在遍历过程中获得树的结构信息

### 2.3 中序遍历(InOrder)

**访问顺序**：左子树 → 根节点 → 右子树

```
访问规则：
1. 中序遍历左子树
2. 访问根节点
3. 中序遍历右子树

示例：
         A
       /   \
      B     C
     / \   / \
    D   E F   G

访问过程：
D → B → E → A → F → C → G

递归实现：
```java
void inOrder(TreeNode root) {
    if (root == null) return;
    
    inOrder(root.left);    // 遍历左子树
    visit(root);           // 访问根节点
    inOrder(root.right);   // 遍历右子树
}
```

**中序遍历特点**：
- 对于二叉搜索树，中序遍历得到有序序列
- 适用于表达式求值、排序输出
- 在二叉搜索树中应用最广泛

### 2.4 后序遍历(PostOrder)

**访问顺序**：左子树 → 右子树 → 根节点

```
访问规则：
1. 后序遍历左子树
2. 后序遍历右子树  
3. 访问根节点

示例：
         A
       /   \
      B     C
     / \   / \
    D   E F   G

访问过程：
D → E → B → F → G → C → A

递归实现：
```java
void postOrder(TreeNode root) {
    if (root == null) return;
    
    postOrder(root.left);  // 遍历左子树
    postOrder(root.right); // 遍历右子树
    visit(root);           // 访问根节点
}
```

**后序遍历特点**：
- 根节点总是最后访问
- 适用于计算目录大小、删除节点、后缀表达式
- 子节点的处理总是在父节点之前

### 2.5 DFS的栈实现

**非递归实现思想**：用栈模拟递归过程

```java
// 前序遍历的栈实现
void preOrderStack(TreeNode root) {
    if (root == null) return;
    
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        visit(node);           // 访问节点
        
        // 先压右子树，再压左子树（栈是后进先出）
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
}
```

**栈实现的优势**：
- 避免递归调用栈溢出
- 更好地控制遍历过程
- 便于实现遍历的中断和恢复

---

## 3. 🌊 广度优先遍历(BFS)


### 3.1 BFS的基本思想

**核心理念**：按层次逐层遍历，先访问完当前层的所有节点，再访问下一层

```
BFS访问过程：
         A          第1层
       /   \
      B     C       第2层
     / \   / \
    D   E F   G     第3层

访问顺序：
第1层：A
第2层：B → C  
第3层：D → E → F → G

最终序列：A → B → C → D → E → F → G
```

### 3.2 层次遍历的实现

**队列实现**：使用队列的先进先出特性实现层次遍历

```java
void levelOrder(TreeNode root) {
    if (root == null) return;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        visit(node);           // 访问节点
        
        // 先入队左子树，再入队右子树
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }
}
```

### 3.3 按层分组遍历

**需求**：有时需要知道每层的节点分组

```java
List<List<Integer>> levelOrderGrouped(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();  // 当前层的节点数
        List<Integer> currentLevel = new ArrayList<>();
        
        // 处理当前层的所有节点
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(currentLevel);
    }
    
    return result;
}
```

**输出示例**：
```
输入树：
         3
       /   \
      9     20
           /  \
          15   7

输出：
[
  [3],
  [9, 20],
  [15, 7]
]
```

### 3.4 BFS的特点与应用

**BFS特点**：
- 保证按层次顺序访问
- 第一次访问到的节点距离根节点最近
- 空间复杂度与树的宽度相关

**典型应用**：
- **最短路径**：在无权图中找最短路径
- **层次打印**：按层打印树的结构
- **完全性检查**：检查是否为完全二叉树

---

## 4. 🎯 遍历应用与选择


### 4.1 遍历方式的选择

```
应用场景选择指南：

前序遍历：
- 树的复制和序列化
- 前缀表达式求值
- 目录遍历（先处理目录再处理文件）

中序遍历：
- 二叉搜索树的有序输出
- 表达式树的中缀表达式输出
- 需要按顺序处理节点的场景

后序遍历：
- 计算目录/文件大小
- 删除树节点（先删子节点）
- 后缀表达式求值

层次遍历：
- 按层打印树结构
- 寻找最短路径
- 树的宽度优先搜索
```

### 4.2 时间复杂度分析

**所有遍历方式的复杂度**：
- **时间复杂度**：O(n) - 每个节点访问一次
- **空间复杂度**：
  - 递归实现：O(h) - h为树的高度，递归栈深度
  - 迭代实现：O(w) - w为树的最大宽度

```
复杂度对比：
          时间复杂度  空间复杂度(递归)  空间复杂度(迭代)
前序遍历      O(n)        O(h)          O(h)
中序遍历      O(n)        O(h)          O(h)  
后序遍历      O(n)        O(h)          O(h)
层次遍历      O(n)        -             O(w)

其中：h = 树的高度，w = 树的最大宽度
```

### 4.3 实际应用示例

**文件系统遍历**：
```java
// 前序遍历：先打印目录名，再遍历子目录
void printDirectory(Directory dir) {
    System.out.println(dir.name);        // 先打印目录
    for (Directory subDir : dir.children) {
        printDirectory(subDir);           // 再遍历子目录
    }
}

// 后序遍历：先计算子目录大小，再计算当前目录
long calculateSize(Directory dir) {
    long size = dir.fileSize;
    for (Directory subDir : dir.children) {
        size += calculateSize(subDir);    // 先计算子目录大小
    }
    return size;                          // 最后返回当前目录大小
}
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的遍历方法

```
🔸 深度优先遍历(DFS)：
   - 前序：根→左→右（树的复制、序列化）
   - 中序：左→根→右（BST有序输出）
   - 后序：左→右→根（计算大小、删除节点）

🔸 广度优先遍历(BFS)：
   - 层次遍历：逐层访问（最短路径、层次打印）
   - 使用队列实现
```

### 5.2 核心理解要点


**🔹 递归与迭代的选择**
```
递归实现：
- 代码简洁，易于理解
- 可能栈溢出（深度过大）
- 适合大多数情况

迭代实现：
- 避免栈溢出
- 更好的空间控制
- 适合深度很大的树
```

**🔹 遍历顺序的记忆**
```
记忆要点：
- 前序：根在前面，先访问根
- 中序：根在中间，左根右顺序
- 后序：根在后面，最后访问根
- 层次：按层访问，用队列实现
```

**🔹 应用场景的理解**
```
关键原则：
- 需要先处理根节点 → 前序遍历
- 需要有序处理(BST) → 中序遍历  
- 需要先处理子节点 → 后序遍历
- 需要按层处理 → 层次遍历
```
