---
title: 2、ResultSet高级特性
---
## 📚 目录

1. [ResultSet基础回顾](#1-ResultSet基础回顾)
2. [可滚动结果集详解](#2-可滚动结果集详解)
3. [可更新结果集实战](#3-可更新结果集实战)
4. [结果集类型深入理解](#4-结果集类型深入理解)
5. [并发级别控制机制](#5-并发级别控制机制)
6. [敏感性设置与实际应用](#6-敏感性设置与实际应用)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔄 ResultSet基础回顾


### 1.1 什么是ResultSet


**简单理解**：ResultSet就像是数据库查询结果的"容器"，你可以把它想象成Excel表格。

```
数据库表：users
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
| 1  | 张三   | 25  |
| 2  | 李四   | 30  |
| 3  | 王五   | 28  |
+----+--------+-----+

ResultSet就是这个表格的Java版本
你可以通过它读取每一行、每一列的数据
```

### 1.2 普通ResultSet的限制


**🔸 默认ResultSet的"痛点"**
- **只能向前**：像看书一样，只能从第1页往后翻，不能往前翻
- **只能读取**：像只读文件，只能看不能改
- **一次性**：读过的数据就过去了，不能回头再看

```java
// 普通ResultSet的使用方式
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
while(rs.next()) {  // 只能向前移动
    String name = rs.getString("name");  // 只能读取，不能修改
    System.out.println(name);
}
// 循环结束后，不能再回到第一行重新读取
```

---

## 2. 📜 可滚动结果集详解


### 2.1 可滚动结果集是什么


**通俗解释**：可滚动结果集就是给普通的ResultSet装上了"时光倒流"的能力。

> 💡 **形象比喻**：
> 
> - **普通ResultSet**：像看电影，只能从头看到尾，不能倒退
> - **可滚动ResultSet**：像看DVD，可以快进、快退、跳转到任意位置

### 2.2 创建可滚动结果集


**🔧 创建方法**：

```java
// 创建可滚动的Statement
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,  // 结果集类型：可滚动
    ResultSet.CONCUR_READ_ONLY         // 并发级别：只读
);

ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```

**参数含义解释**：
- `TYPE_SCROLL_INSENSITIVE`：可以理解为"可滚动但不敏感"
- `CONCUR_READ_ONLY`：只能读取，不能修改

### 2.3 滚动操作详解


**📍 位置移动方法**

| 方法 | **作用** | **通俗理解** |
|------|---------|-------------|
| `next()` | `向前移动一行` | `翻到下一页` |
| `previous()` | `向后移动一行` | `翻到上一页` |
| `first()` | `移动到第一行` | `回到第1页` |
| `last()` | `移动到最后一行` | `跳到最后一页` |
| `absolute(n)` | `移动到第n行` | `直接跳到第n页` |
| `relative(n)` | `相对移动n行` | `从当前位置跳n页` |

**🎯 实际应用示例**：

```java
// 创建可滚动结果集
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_READ_ONLY
);
ResultSet rs = stmt.executeQuery("SELECT id, name, age FROM users");

// 跳到最后一行，查看总共有多少条记录
if(rs.last()) {
    int totalRows = rs.getRow();  // 获取当前行号，即总行数
    System.out.println("总共有 " + totalRows + " 条记录");
}

// 回到第一行开始遍历
rs.first();
do {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    System.out.println("ID: " + id + ", 姓名: " + name);
} while(rs.next());

// 倒序查看数据
rs.last();  // 先到最后一行
do {
    String name = rs.getString("name");
    System.out.println("倒序: " + name);
} while(rs.previous());  // 向前移动
```

### 2.4 位置判断方法


**🎯 判断当前位置**

```java
// 检查当前位置
if(rs.isFirst()) {
    System.out.println("当前在第一行");
}

if(rs.isLast()) {
    System.out.println("当前在最后一行");
}

if(rs.isBeforeFirst()) {
    System.out.println("在第一行之前");
}

if(rs.isAfterLast()) {
    System.out.println("在最后一行之后");
}

// 获取当前行号
int currentRow = rs.getRow();
System.out.println("当前是第 " + currentRow + " 行");
```

---

## 3. ✏️ 可更新结果集实战


### 3.1 什么是可更新结果集


**简单理解**：可更新结果集就是给ResultSet装上了"编辑器"功能，不仅能读还能改。

> 📝 **实际场景**：
> 
> 想象你在用Excel查看员工信息，发现张三的年龄写错了。
> - 普通ResultSet：只能看到错误，要另外写SQL去改
> - 可更新ResultSet：直接在"表格"里改，然后保存

### 3.2 创建可更新结果集


```java
// 创建可更新的Statement
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,  // 可滚动
    ResultSet.CONCUR_UPDATABLE        // 可更新（重点在这里）
);

ResultSet rs = stmt.executeQuery("SELECT id, name, age FROM users");
```

**⚠️ 重要提醒**：
- `CONCUR_UPDATABLE`：这个参数是关键，表示结果集可以更新
- 不是所有查询都能创建可更新结果集，有一些限制条件

### 3.3 更新现有数据


**🔧 更新步骤**：
1. **定位**到要修改的行
2. **调用**updateXxx方法修改数据
3. **提交**修改到数据库

```java
// 查找要修改的记录
while(rs.next()) {
    String name = rs.getString("name");
    if("张三".equals(name)) {
        // 修改年龄
        rs.updateInt("age", 26);        // 在内存中修改
        rs.updateString("name", "张三丰"); // 修改姓名
        
        rs.updateRow();                 // 提交到数据库（重要！）
        System.out.println("数据已更新");
        break;
    }
}
```

**💡 理解要点**：
- `updateXxx()`：只是在内存中改，像在Word里打字
- `updateRow()`：真正保存到数据库，像按Ctrl+S保存文件

### 3.4 插入新数据


**🔧 插入步骤**：
1. **移动**到插入行位置
2. **设置**各个字段的值
3. **提交**插入操作

```java
// 移动到插入行（特殊位置）
rs.moveToInsertRow();

// 设置新数据的各个字段
rs.updateInt("id", 4);
rs.updateString("name", "赵六");
rs.updateInt("age", 32);

// 执行插入
rs.insertRow();

// 回到正常位置
rs.moveToCurrentRow();

System.out.println("新数据插入成功");
```

**🎯 插入行理解**：
- `moveToInsertRow()`：移动到一个"虚拟行"，专门用于插入新数据
- 就像Excel最后的空白行，你在这里填写新数据
- `moveToCurrentRow()`：回到你移动前的位置

### 3.5 删除数据


```java
// 找到要删除的记录
while(rs.next()) {
    String name = rs.getString("name");
    if("李四".equals(name)) {
        rs.deleteRow();  // 直接删除当前行
        System.out.println("记录已删除");
        break;
    }
}
```

---

## 4. 🏷️ 结果集类型深入理解


### 4.1 三种结果集类型对比


```
ResultSet类型解释：

TYPE_FORWARD_ONLY（向前类型）
   [1] → [2] → [3] → [4] → [5]
   只能这样走，不能回头

TYPE_SCROLL_INSENSITIVE（可滚动不敏感）
   [1] ↔ [2] ↔ [3] ↔ [4] ↔ [5]
   可以前后移动，但看不到别人的修改

TYPE_SCROLL_SENSITIVE（可滚动敏感）
   [1] ↔ [2] ↔ [3] ↔ [4] ↔ [5]
   可以前后移动，能看到别人的修改
```

**📊 详细对比表**

| 类型 | **滚动能力** | **敏感性** | **性能** | **适用场景** |
|------|-------------|----------|---------|-------------|
| `TYPE_FORWARD_ONLY` | `❌ 只能向前` | `N/A` | `🔥 最快` | `一次性遍历大量数据` |
| `TYPE_SCROLL_INSENSITIVE` | `✅ 可滚动` | `❌ 不感知外部变化` | `⚡ 中等` | `需要多次访问固定数据` |
| `TYPE_SCROLL_SENSITIVE` | `✅ 可滚动` | `✅ 感知外部变化` | `🐌 较慢` | `需要实时同步数据` |

### 4.2 敏感性实际演示


**🔍 不敏感结果集示例**：

```java
// 程序A：创建不敏感结果集
Statement stmt1 = conn1.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,  // 注意：不敏感
    ResultSet.CONCUR_READ_ONLY
);
ResultSet rs1 = stmt1.executeQuery("SELECT * FROM users WHERE id = 1");

if(rs1.next()) {
    String originalName = rs1.getString("name");
    System.out.println("程序A看到的姓名: " + originalName);  // 输出：张三
}

// 这时另一个程序B修改了数据库中id=1的姓名为"张三丰"

// 程序A重新查看相同数据
rs1.first();  // 回到第一行
String nameAfterUpdate = rs1.getString("name");
System.out.println("修改后程序A看到的姓名: " + nameAfterUpdate);  // 仍然输出：张三
```

**🔍 敏感结果集示例**：

```java
// 程序A：创建敏感结果集
Statement stmt2 = conn1.createStatement(
    ResultSet.TYPE_SCROLL_SENSITIVE,    // 注意：敏感
    ResultSet.CONCUR_READ_ONLY
);
ResultSet rs2 = stmt2.executeQuery("SELECT * FROM users WHERE id = 1");

if(rs2.next()) {
    String originalName = rs2.getString("name");
    System.out.println("程序A看到的姓名: " + originalName);  // 输出：张三
}

// 这时另一个程序B修改了数据库中id=1的姓名为"张三丰"

// 程序A重新查看相同数据
rs2.first();  // 回到第一行
String nameAfterUpdate = rs2.getString("name");
System.out.println("修改后程序A看到的姓名: " + nameAfterUpdate);  // 输出：张三丰
```

---

## 5. 🔐 并发级别控制机制


### 5.1 并发级别的含义


**通俗理解**：并发级别就是告诉数据库"我要用这个ResultSet做什么"。

> 🏪 **商店比喻**：
> 
> - `CONCUR_READ_ONLY`：我只是来逛逛看看，不买东西
> - `CONCUR_UPDATABLE`：我可能要买东西，请准备好收银台

### 5.2 两种并发级别详解


**📋 CONCUR_READ_ONLY（只读级别）**

```java
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_READ_ONLY         // 只读模式
);

ResultSet rs = stmt.executeQuery("SELECT * FROM users");

// 只能读取数据
while(rs.next()) {
    System.out.println(rs.getString("name"));  // ✅ 可以
}

// 不能修改数据
// rs.updateString("name", "新名字");  // ❌ 会报错
// rs.updateRow();                    // ❌ 会报错
```

**特点说明**：
- ✅ **性能好**：数据库知道你不会修改，优化策略更激进
- ✅ **资源少**：占用更少的数据库锁和内存
- ❌ **功能限**：不能修改、插入、删除

**📝 CONCUR_UPDATABLE（可更新级别）**

```java
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_UPDATABLE        // 可更新模式
);

ResultSet rs = stmt.executeQuery("SELECT * FROM users");

// 既能读取也能修改
while(rs.next()) {
    String name = rs.getString("name");  // ✅ 可以读取
    if("张三".equals(name)) {
        rs.updateInt("age", 26);         // ✅ 可以修改
        rs.updateRow();                  // ✅ 可以提交
    }
}
```

**特点说明**：
- ✅ **功能全**：读写删改都支持
- ❌ **性能稍差**：需要维护更多信息
- ❌ **资源多**：需要更多数据库锁

### 5.3 选择建议


**🎯 选择原则**

| 使用场景 | **推荐级别** | **理由** |
|---------|-------------|----------|
| `数据查询展示` | `CONCUR_READ_ONLY` | `性能最优，资源占用少` |
| `数据分析统计` | `CONCUR_READ_ONLY` | `不需要修改功能` |
| `数据编辑界面` | `CONCUR_UPDATABLE` | `需要直接修改数据` |
| `批量数据处理` | `CONCUR_UPDATABLE` | `需要批量更新` |

---

## 6. 🔍 敏感性设置与实际应用


### 6.1 敏感性的实际意义


**现实场景理解**：

```
场景：银行账户查询系统

敏感情况：
用户A在ATM查询余额：10000元
同时用户A的朋友给他转账：+5000元
用户A刷新查询：应该看到15000元

不敏感情况：
用户A在ATM查询余额：10000元
同时用户A的朋友给他转账：+5000元
用户A刷新查询：仍然看到10000元（旧数据）
```

### 6.2 敏感性测试代码


```java
public class ResultSetSensitivityDemo {
    
    public void testInsensitive() throws SQLException {
        // 连接1：创建不敏感结果集
        Connection conn1 = DriverManager.getConnection(url, user, password);
        Statement stmt1 = conn1.createStatement(
            ResultSet.TYPE_SCROLL_INSENSITIVE,  // 不敏感
            ResultSet.CONCUR_READ_ONLY
        );
        ResultSet rs1 = stmt1.executeQuery("SELECT id, name, age FROM users WHERE id = 1");
        
        if(rs1.next()) {
            System.out.println("修改前: " + rs1.getString("name"));
        }
        
        // 连接2：修改数据
        Connection conn2 = DriverManager.getConnection(url, user, password);
        Statement stmt2 = conn2.createStatement();
        stmt2.executeUpdate("UPDATE users SET name = '张三丰' WHERE id = 1");
        
        // 连接1：再次查看（不敏感结果集看不到变化）
        rs1.first();
        System.out.println("修改后: " + rs1.getString("name"));  // 仍然是原来的值
        
        conn1.close();
        conn2.close();
    }
}
```

### 6.3 实际应用选择


**🎯 敏感性选择指南**

**选择不敏感（INSENSITIVE）的情况**：
- ✅ **报表生成**：数据快照，不需要实时更新
- ✅ **数据导出**：固定时间点的数据
- ✅ **历史查询**：查看特定时间的历史数据

**选择敏感（SENSITIVE）的情况**：
- ✅ **实时监控**：股票价格、在线用户数等
- ✅ **协同编辑**：多人同时编辑同一数据
- ✅ **实时同步**：需要看到其他用户的最新修改

**⚠️ 实际注意事项**：
- 很多数据库驱动并不完全支持敏感结果集
- MySQL的JDBC驱动默认会忽略敏感性设置
- 如果需要实时数据，建议重新查询而不是依赖敏感结果集

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 可滚动结果集：给ResultSet装上"时光机"，可以前进后退
🔸 可更新结果集：给ResultSet装上"编辑器"，可以直接修改数据
🔸 结果集类型：决定滚动能力和敏感性
🔸 并发级别：决定是否可以修改数据
🔸 敏感性：决定是否能感知其他程序的数据修改
```

### 7.2 关键理解要点


**🔹 创建高级ResultSet的步骤**
```java
// 1. 设置Statement参数
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,  // 结果集类型
    ResultSet.CONCUR_UPDATABLE        // 并发级别
);

// 2. 执行查询
ResultSet rs = stmt.executeQuery("SELECT * FROM table");

// 3. 使用高级功能
rs.last();           // 滚动功能
rs.updateRow();      // 更新功能
```

**🔹 参数组合的意义**
```
常用组合：
- 只读+可滚动：适合数据浏览、报表展示
- 可更新+可滚动：适合数据编辑、在线修改
- 默认组合：适合一次性数据处理
```

**🔹 使用场景判断**
```
需要来回查看数据 → 使用可滚动结果集
需要直接修改数据 → 使用可更新结果集  
需要实时数据同步 → 考虑敏感结果集（但要测试支持度）
只是一次性处理 → 使用普通结果集（性能最好）
```

### 7.3 实际开发指导


**💡 最佳实践建议**

1. **性能优先原则**
   - 默认使用普通ResultSet（TYPE_FORWARD_ONLY + CONCUR_READ_ONLY）
   - 只在确实需要时才使用高级特性

2. **功能需求匹配**
   - 数据展示 → 可滚动只读
   - 数据编辑 → 可滚动可更新
   - 批量处理 → 普通结果集

3. **数据库兼容性**
   - 测试你的数据库驱动对高级特性的支持程度
   - 有些功能可能不被完全支持

4. **资源管理**
   - 高级ResultSet占用更多资源
   - 及时关闭连接和结果集

**🔧 常见问题解决**

```java
// 问题1：创建可更新结果集失败
// 原因：查询不满足可更新条件（如包含JOIN、GROUP BY等）
// 解决：简化查询，确保针对单个表

// 问题2：updateRow()不生效
// 原因：忘记调用updateRow()方法
// 解决：修改字段后必须调用updateRow()

// 问题3：滚动功能不工作
// 原因：使用了默认的TYPE_FORWARD_ONLY
// 解决：创建Statement时指定滚动类型
```

### 7.4 学习记忆要点


**核心记忆口诀**：
- 普通结果集像单行道，高级结果集像双行道
- 只读级别省资源，可更新级别功能全  
- 不敏感看快照，敏感看实时
- 功能越强性能越差，按需选择最重要

**参数速记**：
- `TYPE_SCROLL_xxx`：控制滚动能力
- `CONCUR_xxx`：控制修改能力
- `SENSITIVE`：能感知外部变化
- `INSENSITIVE`：不感知外部变化