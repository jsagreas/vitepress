---
title: 1、JDBC事务基础
---
## 📚 目录

1. [事务基本概念](#1-事务基本概念)
2. [事务ACID特性详解](#2-事务acid特性详解)
3. [JDBC事务控制机制](#3-jdbc事务控制机制)
4. [自动提交与手动提交](#4-自动提交与手动提交)
5. [事务边界管理](#5-事务边界管理)
6. [事务实战案例](#6-事务实战案例)
7. [事务异常处理](#7-事务异常处理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 💡 事务基本概念


### 1.1 什么是事务


**事务**就像现实生活中的"一整套操作"，要么**全部完成**，要么**全部取消**。

> 💡 **生活化理解**  
> 想象你在银行转账：先从你账户扣钱，再往对方账户加钱。这两步必须都成功，如果第二步失败了，第一步也要撤销，不能让你的钱消失了！

```
银行转账的完整过程：
┌─────────────────────────────┐
│  开始事务                    │
├─────────────────────────────┤
│  1. 检查余额是否足够         │
│  2. 从A账户扣除100元         │  
│  3. 向B账户增加100元         │
│  4. 记录转账日志             │
├─────────────────────────────┤
│  全部成功 → 提交事务         │
│  任何失败 → 回滚事务         │
└─────────────────────────────┘
```

### 1.2 为什么需要事务


在数据库操作中，我们经常需要执行**多个相关的操作**：

**没有事务的问题**：
- ❌ 操作执行到一半程序崩溃
- ❌ 数据更新不完整，出现数据不一致
- ❌ 多个用户同时操作造成冲突

**有了事务的好处**：
- ✅ 保证数据的**完整性**和**一致性**
- ✅ 即使出错也能**回到原始状态**
- ✅ 多个操作**要么全成功，要么全失败**

---

## 2. 🔍 事务ACID特性详解


事务必须满足**ACID四大特性**，这是数据库事务的基本要求：

### 2.1 原子性（Atomicity）


**含义**：事务是一个**不可分割的整体**，要么全部执行，要么全部不执行。

```
购物下单的原子性：
┌──────────────────┐
│  减少商品库存     │ ←─┐
│  创建订单记录     │   │ 这些操作必须
│  扣减用户余额     │   │ 作为一个整体
│  发送订单通知     │ ←─┘
└──────────────────┘

如果任何一步失败，所有操作都要撤销！
```

### 2.2 一致性（Consistency）


**含义**：事务执行前后，数据库必须保持**业务规则的一致性**。

| 执行前状态 | 执行操作 | 执行后状态 |
|-----------|----------|-----------|
| A账户：1000元<br>B账户：500元 | A转给B：300元 | A账户：700元<br>B账户：800元 |
| **总金额：1500元** | → | **总金额：1500元** ✅ |

> 💡 **一致性理解**  
> 无论怎么转账，银行系统的总金额不能变，这就是一致性！

### 2.3 隔离性（Isolation）


**含义**：多个事务**同时执行时不能互相干扰**，就像每个事务都在独立运行。

```
事务隔离示例：
用户A正在转账 ←─────┐  ┌─────→ 用户B正在查余额
                   │  │
               数据库隔离
                   │  │
互不影响！ ←──────────┘  └──────→ 看到的都是正确数据
```

### 2.4 持久性（Durability）


**含义**：事务一旦**提交成功**，数据的改变就是**永久的**，即使系统故障也不会丢失。

```
持久性保证：
事务提交 → 数据写入磁盘 → 永久保存
     ↓
即使停电、重启，数据也不会丢失！
```

---

## 3. ⚙️ JDBC事务控制机制


### 3.1 JDBC事务控制的核心方法


在JDBC中，我们通过**Connection对象**来控制事务：

| 方法名称 | 作用说明 | 参数说明 |
|---------|----------|----------|
| `setAutoCommit(boolean)` | **设置自动提交模式** | `false`=手动控制 |
| `commit()` | **提交事务** | 让所有操作生效 |
| `rollback()` | **回滚事务** | 撤销所有操作 |
| `setSavepoint(String)` | 设置保存点 | 部分回滚使用 |

### 3.2 事务控制的基本流程


```
JDBC事务控制标准流程：

1. 获取连接 ────────→ Connection conn = getConnection()
                    │
2. 关闭自动提交 ─────→ conn.setAutoCommit(false)
                    │
3. 执行SQL操作 ─────→ 执行多个增删改操作
                    │
4. 判断结果 ────────→ 全部成功？
                    │
          ┌─────────┴─────────┐
          │                   │
       是 ↓                否 ↓
    提交事务                回滚事务
  conn.commit()         conn.rollback()
          │                   │
          └─────────┬─────────┘
                    │
5. 恢复自动提交 ─────→ conn.setAutoCommit(true)
                    │
6. 关闭连接 ────────→ conn.close()
```

---

## 4. 🔄 自动提交与手动提交


### 4.1 自动提交模式（默认）


JDBC连接**默认是自动提交**的，每执行一条SQL语句就立即提交：

```java
// 默认情况下，自动提交=true
Connection conn = DriverManager.getConnection(url, user, password);
// 此时 conn.getAutoCommit() 返回 true

PreparedStatement pst = conn.prepareStatement("UPDATE account SET balance = balance - 100 WHERE id = 1");
pst.executeUpdate(); // 这条SQL执行后立即提交，无法撤销！
```

**自动提交的特点**：
- ✅ **简单方便**：不需要手动控制
- ❌ **无法撤销**：每条SQL立即生效
- ❌ **不适合多步骤操作**：无法保证原子性

### 4.2 手动提交模式


关闭自动提交后，我们可以**手动控制何时提交**：

```java
Connection conn = DriverManager.getConnection(url, user, password);
conn.setAutoCommit(false); // 关闭自动提交
// 此时 conn.getAutoCommit() 返回 false

// 执行多个操作
PreparedStatement pst1 = conn.prepareStatement("UPDATE account SET balance = balance - 100 WHERE id = 1");
PreparedStatement pst2 = conn.prepareStatement("UPDATE account SET balance = balance + 100 WHERE id = 2");

pst1.executeUpdate(); // 暂时保存在内存中，未提交
pst2.executeUpdate(); // 暂时保存在内存中，未提交

// 手动提交，让所有操作一起生效
conn.commit();
```

**手动提交的特点**：
- ✅ **精确控制**：决定何时让操作生效
- ✅ **支持回滚**：出错时可以撤销
- ✅ **保证原子性**：多个操作要么全成功，要么全失败

---

## 5. 📏 事务边界管理


### 5.1 什么是事务边界


**事务边界**就是事务的**开始点和结束点**，明确定义哪些操作属于同一个事务。

```
事务边界示意图：

    开始边界
      ↓
┌─────────────────────────┐
│  setAutoCommit(false)   │ ← 事务开始
├─────────────────────────┤
│  SQL操作1                │
│  SQL操作2                │ ← 事务内容
│  SQL操作3                │
├─────────────────────────┤
│  commit() 或 rollback() │ ← 事务结束
└─────────────────────────┘
      ↑
    结束边界
```

### 5.2 正确的边界管理


> ⚠️ **重要提醒**  
> 每个连接同一时间只能有一个活跃事务，新事务会自动提交上一个事务！

**正确的管理方式**：

```java
public void transferMoney(int fromAccount, int toAccount, double amount) {
    Connection conn = null;
    try {
        // 1. 事务开始边界
        conn = getConnection();
        conn.setAutoCommit(false); // 明确标记事务开始
        
        // 2. 事务内容
        updateBalance(conn, fromAccount, -amount); // 扣钱
        updateBalance(conn, toAccount, amount);    // 加钱
        
        // 3. 事务结束边界 - 成功提交
        conn.commit();
        
    } catch (Exception e) {
        // 4. 事务结束边界 - 失败回滚
        if (conn != null) {
            try {
                conn.rollback();
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }
    } finally {
        // 5. 清理资源
        if (conn != null) {
            try {
                conn.setAutoCommit(true); // 恢复默认设置
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 5.3 边界管理的常见错误


❌ **错误1：忘记关闭自动提交**
```java
// 错误示例 - 忘记setAutoCommit(false)
Connection conn = getConnection();
// 没有关闭自动提交，每条SQL都立即生效！
updateBalance(conn, 1, -100); // 立即生效，无法撤销
updateBalance(conn, 2, 100);  // 如果这里出错，上面的操作已无法回滚
```

❌ **错误2：忘记提交或回滚**
```java
// 错误示例 - 忘记commit
Connection conn = getConnection();
conn.setAutoCommit(false);
updateBalance(conn, 1, -100);
updateBalance(conn, 2, 100);
// 忘记commit()，数据改变不会保存！
conn.close(); // 连接关闭时会自动回滚
```

---

## 6. 🏦 事务实战案例


让我们通过一个完整的**银行转账案例**来理解事务的实际应用：

### 6.1 需求分析


**业务需求**：用户A向用户B转账200元
**必要操作**：
1. 检查A账户余额是否足够
2. 从A账户扣除200元
3. 向B账户增加200元
4. 记录转账日志

### 6.2 数据表设计


```sql
-- 账户表
CREATE TABLE account (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10,2)
);

-- 转账记录表  
CREATE TABLE transfer_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    from_account INT,
    to_account INT,
    amount DECIMAL(10,2),
    transfer_time DATETIME
);
```

### 6.3 完整的事务实现


```java
public class BankService {
    
    /**
     * 转账方法 - 使用事务保证数据一致性
     */
    public boolean transferMoney(int fromAccountId, int toAccountId, double amount) {
        Connection conn = null;
        try {
            // 1. 获取连接并开启事务
            conn = DatabaseUtil.getConnection();
            conn.setAutoCommit(false);
            
            // 2. 检查余额是否足够
            if (!hasEnoughBalance(conn, fromAccountId, amount)) {
                throw new RuntimeException("余额不足");
            }
            
            // 3. 执行转账操作
            updateBalance(conn, fromAccountId, -amount); // 扣钱
            updateBalance(conn, toAccountId, amount);    // 加钱
            
            // 4. 记录转账日志
            insertTransferLog(conn, fromAccountId, toAccountId, amount);
            
            // 5. 提交事务
            conn.commit();
            System.out.println("转账成功！");
            return true;
            
        } catch (Exception e) {
            // 6. 出错时回滚事务
            System.err.println("转账失败：" + e.getMessage());
            if (conn != null) {
                try {
                    conn.rollback();
                    System.out.println("事务已回滚");
                } catch (SQLException rollbackEx) {
                    rollbackEx.printStackTrace();
                }
            }
            return false;
            
        } finally {
            // 7. 清理资源
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // 恢复自动提交
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    /**
     * 检查账户余额
     */
    private boolean hasEnoughBalance(Connection conn, int accountId, double amount) 
            throws SQLException {
        String sql = "SELECT balance FROM account WHERE id = ?";
        try (PreparedStatement pst = conn.prepareStatement(sql)) {
            pst.setInt(1, accountId);
            ResultSet rs = pst.executeQuery();
            if (rs.next()) {
                return rs.getDouble("balance") >= amount;
            }
            return false;
        }
    }
    
    /**
     * 更新账户余额
     */
    private void updateBalance(Connection conn, int accountId, double amount) 
            throws SQLException {
        String sql = "UPDATE account SET balance = balance + ? WHERE id = ?";
        try (PreparedStatement pst = conn.prepareStatement(sql)) {
            pst.setDouble(1, amount);
            pst.setInt(2, accountId);
            int rows = pst.executeUpdate();
            if (rows == 0) {
                throw new RuntimeException("账户不存在：" + accountId);
            }
        }
    }
    
    /**
     * 记录转账日志
     */
    private void insertTransferLog(Connection conn, int fromAccount, int toAccount, double amount) 
            throws SQLException {
        String sql = "INSERT INTO transfer_log (from_account, to_account, amount, transfer_time) VALUES (?, ?, ?, NOW())";
        try (PreparedStatement pst = conn.prepareStatement(sql)) {
            pst.setInt(1, fromAccount);
            pst.setInt(2, toAccount);
            pst.setDouble(1, amount);
            pst.executeUpdate();
        }
    }
}
```

### 6.4 测试转账功能


```java
public class TransferTest {
    public static void main(String[] args) {
        BankService bankService = new BankService();
        
        // 测试正常转账
        System.out.println("=== 测试正常转账 ===");
        boolean result1 = bankService.transferMoney(1, 2, 200.0);
        System.out.println("转账结果：" + (result1 ? "成功" : "失败"));
        
        // 测试余额不足的情况
        System.out.println("\n=== 测试余额不足 ===");
        boolean result2 = bankService.transferMoney(1, 2, 10000.0);
        System.out.println("转账结果：" + (result2 ? "成功" : "失败"));
    }
}
```

---

## 7. ⚠️ 事务异常处理


### 7.1 异常处理的重要性


在事务操作中，**异常处理**决定了数据的安全性：

```
异常处理的影响：

正确处理异常 ────→ 数据安全，状态一致
     ↓
错误处理异常 ────→ 数据损坏，状态混乱
```

### 7.2 异常处理最佳实践


**核心原则**：`try-catch-finally` + **确保回滚**

```java
public void safeTransaction() {
    Connection conn = null;
    try {
        // 开启事务
        conn = getConnection();
        conn.setAutoCommit(false);
        
        // 执行业务操作
        doBusinessOperation1(conn);
        doBusinessOperation2(conn);
        doBusinessOperation3(conn);
        
        // 提交事务
        conn.commit();
        
    } catch (SQLException e) {
        // SQL异常处理
        System.err.println("数据库操作异常：" + e.getMessage());
        rollbackSafely(conn);
        
    } catch (BusinessException e) {
        // 业务异常处理  
        System.err.println("业务逻辑异常：" + e.getMessage());
        rollbackSafely(conn);
        
    } catch (Exception e) {
        // 其他异常处理
        System.err.println("未知异常：" + e.getMessage());
        rollbackSafely(conn);
        
    } finally {
        // 资源清理
        closeConnection(conn);
    }
}

/**
 * 安全回滚方法
 */
private void rollbackSafely(Connection conn) {
    if (conn != null) {
        try {
            conn.rollback();
            System.out.println("事务已安全回滚");
        } catch (SQLException e) {
            System.err.println("回滚失败：" + e.getMessage());
            // 记录日志或其他处理
        }
    }
}

/**
 * 安全关闭连接
 */
private void closeConnection(Connection conn) {
    if (conn != null) {
        try {
            conn.setAutoCommit(true); // 恢复默认设置
            conn.close();
        } catch (SQLException e) {
            System.err.println("关闭连接失败：" + e.getMessage());
        }
    }
}
```

### 7.3 常见异常情况及处理


| 异常类型 | 产生原因 | 处理方式 |
|---------|----------|----------|
| **SQLException** | SQL语法错误、约束违反 | 回滚事务，记录错误日志 |
| **业务异常** | 余额不足、权限不够 | 回滚事务，返回错误信息 |
| **网络异常** | 数据库连接中断 | 重试或回滚，通知用户 |
| **系统异常** | 内存不足、IO错误 | 回滚事务，系统告警 |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 事务定义：一组要么全成功、要么全失败的数据库操作
🔸 ACID特性：原子性、一致性、隔离性、持久性
🔸 事务控制：setAutoCommit(false)、commit()、rollback()
🔸 边界管理：明确事务的开始和结束点
🔸 异常处理：确保出错时能安全回滚
```

### 8.2 关键理解要点


**🔹 自动提交 vs 手动提交**
```
自动提交（默认）：
- 每条SQL立即生效
- 适合单个操作
- 无法保证多操作的原子性

手动提交：
- 多个操作一起提交
- 支持回滚机制
- 适合业务事务处理
```

**🔹 事务边界的重要性**
```
正确的边界管理：
开始 → setAutoCommit(false)
内容 → 执行多个相关操作  
结束 → commit() 或 rollback()
清理 → setAutoCommit(true) + close()
```

**🔹 异常处理的必要性**
```
没有异常处理 → 数据可能不一致
正确异常处理 → 保证数据安全性
```

### 8.3 实际应用价值


**🎯 适用场景**
- ✅ **银行转账**：多个账户操作必须同时成功
- ✅ **订单处理**：扣库存、创建订单、支付等操作
- ✅ **用户注册**：创建用户、发送邮件、初始化数据
- ✅ **数据导入**：批量插入数据，失败时全部撤销

**🔧 开发实践**
- **事务范围最小化**：只包含必要的操作
- **异常处理完善**：确保任何情况下都能安全回滚
- **资源管理严格**：及时关闭连接，恢复自动提交
- **业务逻辑清晰**：明确哪些操作需要事务保护

**💡 学习建议**
- **从简单案例开始**：理解事务的基本概念
- **动手实践**：编写完整的事务处理代码
- **测试异常情况**：验证回滚机制是否正常
- **关注性能影响**：事务会影响数据库性能

**核心记忆**：
- 事务保证数据安全，ACID四特性要牢记
- 手动控制更灵活，异常处理不能忘
- 边界管理要清晰，资源清理要及时
- 银行转账是典型，一套模板解万题