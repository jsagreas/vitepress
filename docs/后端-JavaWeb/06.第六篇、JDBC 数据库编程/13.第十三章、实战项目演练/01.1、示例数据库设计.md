---
title: 1、示例数据库设计
---
## 📚 目录

1. [为什么需要数据库设计](#1-为什么需要数据库设计)
2. [项目需求分析](#2-项目需求分析)
3. [用户表设计](#3-用户表设计)
4. [商品表设计](#4-商品表设计)
5. [订单表设计](#5-订单表设计)
6. [表关系设计](#6-表关系设计)
7. [索引策略](#7-索引策略)
8. [数据库创建实战](#8-数据库创建实战)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🤔 为什么需要数据库设计


### 1.1 数据库设计的重要性


想象一下，你要开一家网店，你需要记录：
- 顾客信息（姓名、地址、电话）
- 商品信息（名称、价格、库存）
- 订单信息（谁买了什么、什么时候买的）

如果没有好的设计，就像把这些信息胡乱堆在一个大箱子里，想找点东西比登天还难！

```
❌ 坏的设计（所有信息放一张表）：
订单ID | 用户名 | 用户电话 | 商品名 | 商品价格 | 订单时间
1001   | 张三   | 138xxx   | iPhone | 5999    | 2024-01-01
1002   | 张三   | 138xxx   | 华为   | 3999    | 2024-01-02

问题：用户信息重复，浪费空间，修改麻烦
```

**🎯 好的数据库设计带来的好处：**
- **节省存储空间** - 避免重复数据
- **提高查询速度** - 合理的索引和结构
- **便于维护** - 修改一处数据，其他地方自动同步
- **保证数据一致性** - 避免数据冲突

### 1.2 设计原则简介


**📏 数据库设计的三个基本原则：**

🔸 **避免冗余**：同样的信息不要重复存储
🔸 **保证完整性**：数据要准确、一致
🔸 **便于扩展**：设计要考虑到未来的需求变化

---

## 2. 📋 项目需求分析


### 2.1 项目背景


我们要设计一个**简单的网上商城系统**，需要支持以下功能：

💼 **核心功能需求：**
- 用户注册和登录
- 浏览商品信息
- 添加商品到购物车
- 提交订单
- 查看订单历史

### 2.2 数据分析


🔍 **需要存储的数据类型：**

| **数据类型** | **主要信息** | **举例** |
|------------|------------|---------|
| 👤 **用户数据** | 用户名、密码、联系方式 | "张三, 138xxxx, zhang@qq.com" |
| 📦 **商品数据** | 商品名、价格、库存、描述 | "iPhone15, 5999元, 100台" |
| 🛒 **订单数据** | 用户、商品、数量、时间 | "张三买了2台iPhone，2024-01-01" |

### 2.3 表结构初步规划


```
需要设计的核心表：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   用户表     │    │   商品表     │    │   订单表     │
│   (users)   │    │ (products)  │    │  (orders)   │
├─────────────┤    ├─────────────┤    ├─────────────┤
│ 用户ID      │    │ 商品ID      │    │ 订单ID      │
│ 用户名      │    │ 商品名      │    │ 用户ID      │
│ 密码        │    │ 价格        │    │ 商品ID      │
│ 邮箱        │    │ 库存        │    │ 数量        │
└─────────────┘    └─────────────┘    └─────────────┘
```

---

## 3. 👤 用户表设计


### 3.1 用户表需求分析


用户表是系统的基础，需要存储用户的基本信息。

**🔍 用户表需要包含哪些信息？**
- 用户的唯一标识（用户ID）
- 登录凭证（用户名、密码）
- 联系信息（邮箱、电话）
- 基本信息（姓名、注册时间）

### 3.2 用户表结构设计


```sql
-- 用户表(users)设计
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,  -- 用户ID(主键，自动递增)
    username VARCHAR(50) NOT NULL UNIQUE,    -- 用户名(不能为空，唯一)
    password VARCHAR(100) NOT NULL,          -- 密码(加密后存储)
    email VARCHAR(100) NOT NULL UNIQUE,      -- 邮箱(不能为空，唯一)
    phone VARCHAR(20),                       -- 电话号码(可以为空)
    real_name VARCHAR(50),                   -- 真实姓名
    created_time DATETIME DEFAULT NOW(),     -- 注册时间(默认当前时间)
    status TINYINT DEFAULT 1                 -- 账户状态(1=正常 0=禁用)
);
```

**📋 字段说明详解：**

| **字段名** | **数据类型** | **说明** | **为什么这样设计** |
|-----------|-------------|----------|--------------------|
| `user_id` | `INT` | 用户唯一标识 | 主键，其他表通过这个ID引用用户 |
| `username` | `VARCHAR(50)` | 登录用户名 | 限制长度防止过长，设置唯一避免重复 |
| `password` | `VARCHAR(100)` | 加密后的密码 | 长度足够存储加密后的密码 |
| `email` | `VARCHAR(100)` | 用户邮箱 | 可用于找回密码，设置唯一 |
| `phone` | `VARCHAR(20)` | 手机号 | 用字符串类型，因为可能有+86等前缀 |

### 3.3 用户表设计考虑


**🔐 安全性考虑：**
- 密码字段长度要够，因为要存储加密后的密码
- 敏感信息不要明文存储
- 用户名和邮箱设置唯一约束，防止重复注册

**⚡ 性能考虑：**
- `user_id`作为主键，查询速度最快
- 经常用来登录的`username`和`email`建议加索引

### 3.4 示例数据


```sql
-- 插入示例用户数据
INSERT INTO users (username, password, email, phone, real_name) VALUES
('zhangsan', 'encrypted_password_123', 'zhang@qq.com', '13800138001', '张三'),
('lisi', 'encrypted_password_456', 'li@163.com', '13800138002', '李四'),
('wangwu', 'encrypted_password_789', 'wang@gmail.com', '13800138003', '王五');
```

---

## 4. 📦 商品表设计


### 4.1 商品表需求分析


商品表存储网店中所有的商品信息，是电商系统的核心。

**📋 商品表需要包含什么信息？**
- 商品的唯一标识
- 商品基本信息（名称、描述、价格）
- 库存管理（库存数量、销量）
- 商品状态（是否上架）

### 4.2 商品表结构设计


```sql
-- 商品表(products)设计
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,  -- 商品ID(主键)
    product_name VARCHAR(200) NOT NULL,         -- 商品名称
    product_desc TEXT,                          -- 商品描述(可以很长)
    price DECIMAL(10, 2) NOT NULL,              -- 价格(精确到分)
    stock_quantity INT NOT NULL DEFAULT 0,      -- 库存数量
    sales_count INT DEFAULT 0,                  -- 销售数量
    category_id INT,                            -- 商品分类ID
    product_image VARCHAR(255),                 -- 商品图片路径
    status TINYINT DEFAULT 1,                   -- 商品状态(1=上架 0=下架)
    created_time DATETIME DEFAULT NOW(),        -- 添加时间
    updated_time DATETIME DEFAULT NOW()         -- 更新时间
);
```

**💰 价格字段为什么用DECIMAL？**

很多初学者会问：价格为什么不用`DOUBLE`或`FLOAT`？

```
❌ 错误的设计：
price FLOAT  -- 浮点数会有精度问题

例如：19.99 可能被存储为 19.989999...

✅ 正确的设计：
price DECIMAL(10, 2)  -- 总共10位数，小数点后2位
-- 可以精确存储 99999999.99 这样的价格
```

**DECIMAL(10, 2)的含义：**
- 10：总位数（包括小数点前后）
- 2：小数点后的位数
- 示例：99999999.99（8位整数 + 2位小数）

### 4.3 商品表关键设计


**📊 库存管理设计：**
```sql
stock_quantity INT NOT NULL DEFAULT 0,  -- 当前库存
sales_count INT DEFAULT 0               -- 已售出数量
```

这样设计的好处：
- 可以快速查看库存是否充足
- 可以统计销量排行
- 库存不足时可以及时提醒

**🏷️ 商品分类设计：**
```sql
category_id INT  -- 商品分类ID，关联分类表
```
虽然这里没有详细设计分类表，但预留了分类功能的扩展。

### 4.4 示例数据


```sql
-- 插入示例商品数据
INSERT INTO products (product_name, product_desc, price, stock_quantity, category_id) VALUES
('iPhone 15', '苹果最新款手机，性能强劲', 5999.00, 100, 1),
('华为 Mate 60', '华为旗舰手机，拍照专业', 3999.00, 150, 1),
('小米笔记本', '性价比超高的笔记本电脑', 2999.00, 80, 2);
```

---

## 5. 🛒 订单表设计


### 5.1 订单表的复杂性


订单表是最复杂的，因为它需要连接用户和商品。

**🤔 订单包含什么信息？**
- 谁下的订单？（关联用户表）
- 买了什么？（关联商品表）
- 买了多少？（数量）
- 什么时候买的？（订单时间）
- 订单状态如何？（待付款、已发货等）

### 5.2 订单表结构设计


```sql
-- 订单主表(orders)
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,      -- 订单ID
    user_id INT NOT NULL,                         -- 用户ID(外键)
    order_no VARCHAR(50) NOT NULL UNIQUE,         -- 订单号(便于查询)
    total_amount DECIMAL(10, 2) NOT NULL,         -- 订单总金额
    order_status TINYINT DEFAULT 1,               -- 订单状态
    order_time DATETIME DEFAULT NOW(),            -- 下单时间
    payment_time DATETIME,                        -- 支付时间
    shipping_address TEXT,                        -- 收货地址
    FOREIGN KEY (user_id) REFERENCES users(user_id)  -- 外键约束
);

-- 订单详情表(order_items)
CREATE TABLE order_items (
    item_id INT PRIMARY KEY AUTO_INCREMENT,       -- 订单项ID
    order_id INT NOT NULL,                        -- 订单ID(外键)
    product_id INT NOT NULL,                      -- 商品ID(外键)
    quantity INT NOT NULL,                        -- 购买数量
    unit_price DECIMAL(10, 2) NOT NULL,           -- 单价(下单时的价格)
    total_price DECIMAL(10, 2) NOT NULL,          -- 小计(数量×单价)
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

### 5.3 为什么要分两张表？


**🤔 为什么订单要分成两张表？**

假设张三买了3样商品，如果只用一张表：

```
❌ 单表设计的问题：
订单ID | 用户ID | 商品ID | 数量 | 订单总金额 | 下单时间
1001   | 1      | 101   | 2    | 1500      | 2024-01-01
1001   | 1      | 102   | 1    | 1500      | 2024-01-01  
1001   | 1      | 103   | 3    | 1500      | 2024-01-01

问题：订单信息重复了3次！
```

```
✅ 分表设计的优势：
订单主表(orders)：
订单ID | 用户ID | 订单总金额 | 下单时间
1001   | 1      | 1500      | 2024-01-01

订单详情表(order_items)：
订单ID | 商品ID | 数量 | 单价
1001   | 101   | 2    | 299
1001   | 102   | 1    | 399  
1001   | 103   | 3    | 267

优势：避免重复，结构清晰！
```

### 5.4 订单状态管理


```sql
-- 订单状态说明
order_status TINYINT DEFAULT 1
-- 1: 待付款
-- 2: 已付款，待发货  
-- 3: 已发货，待收货
-- 4: 已完成
-- 5: 已取消
```

**💡 为什么用数字而不是文字？**
- 数字占用空间小
- 查询速度快
- 便于程序处理

### 5.5 示例数据


```sql
-- 插入订单主表数据
INSERT INTO orders (user_id, order_no, total_amount, shipping_address) VALUES
(1, 'ORD2024010101', 5999.00, '北京市朝阳区xxx街道xxx号');

-- 插入订单详情数据
INSERT INTO order_items (order_id, product_id, quantity, unit_price, total_price) VALUES
(1, 1, 1, 5999.00, 5999.00);
```

---

## 6. 🔗 表关系设计


### 6.1 外键关系详解


**🔗 表之间的关系就像现实生活中的关系：**
- 一个用户可以有多个订单 （一对多）
- 一个订单可以包含多个商品 （一对多）
- 一个商品可以被多个订单购买 （多对多，通过订单详情表实现）

### 6.2 关系图示


```
用户表(users)         订单主表(orders)      订单详情表(order_items)    商品表(products)
┌─────────────┐      ┌─────────────┐      ┌─────────────────┐       ┌─────────────┐
│ user_id(PK) │─────→│ user_id(FK) │      │ order_id(FK)    │←──────│ product_id  │
│ username    │      │ order_id(PK)│─────→│ product_id(FK)  │──────→│ (PK)        │
│ email       │      │ order_no    │      │ quantity        │       │ price       │
│ ...         │      │ total_amount│      │ unit_price      │       │ stock       │
└─────────────┘      └─────────────┘      └─────────────────┘       └─────────────┘

PK = Primary Key (主键)
FK = Foreign Key (外键)
```

### 6.3 外键约束的作用


**🛡️ 外键约束保证数据完整性：**

```sql
-- 添加外键约束
ALTER TABLE orders 
ADD FOREIGN KEY (user_id) REFERENCES users(user_id);

-- 这样做的好处：
-- 1. 不能删除有订单的用户
-- 2. 不能插入不存在用户的订单
-- 3. 保证数据一致性
```

**示例说明：**
```sql
-- ❌ 这条语句会失败，因为用户ID=999不存在
INSERT INTO orders (user_id, order_no, total_amount) VALUES
(999, 'ORD2024010199', 100.00);

-- ✅ 这条语句会成功，因为用户ID=1存在
INSERT INTO orders (user_id, order_no, total_amount) VALUES
(1, 'ORD2024010101', 100.00);
```

---

## 7. 📈 索引策略


### 7.1 什么是索引？


**🔍 索引就像书的目录：**
- 没有目录的书：要找内容只能一页页翻
- 有目录的书：直接翻到对应页码

数据库索引同样道理：
- 没有索引：查询时要扫描整张表
- 有索引：快速定位到具体行

### 7.2 主键索引（自动创建）


```sql
-- 主键会自动创建索引
user_id INT PRIMARY KEY AUTO_INCREMENT  -- 自动有索引
product_id INT PRIMARY KEY              -- 自动有索引
order_id INT PRIMARY KEY               -- 自动有索引
```

### 7.3 唯一索引


```sql
-- 为经常查询的唯一字段创建索引
CREATE UNIQUE INDEX idx_username ON users(username);
CREATE UNIQUE INDEX idx_email ON users(email);
CREATE UNIQUE INDEX idx_order_no ON orders(order_no);
```

**💡 为什么要给用户名和邮箱加索引？**
用户登录时经常用这些字段查询：
```sql
-- 这些查询会很快，因为有索引
SELECT * FROM users WHERE username = 'zhangsan';
SELECT * FROM users WHERE email = 'zhang@qq.com';
```

### 7.4 普通索引


```sql
-- 为经常查询的字段创建索引
CREATE INDEX idx_user_id ON orders(user_id);      -- 查询某用户的所有订单
CREATE INDEX idx_product_id ON order_items(product_id); -- 查询某商品的销量
CREATE INDEX idx_order_time ON orders(order_time); -- 按时间查询订单
```

### 7.5 索引使用建议


**✅ 应该创建索引的情况：**
- 经常出现在WHERE子句中的字段
- 经常用于JOIN连接的字段
- 经常需要排序的字段

**❌ 不适合创建索引的情况：**
- 很少查询的字段
- 经常变动的字段
- 数据重复度很高的字段（如性别字段）

**📊 索引的权衡：**
| **优点** | **缺点** |
|---------|---------|
| 🚀 查询速度快 | 💾 占用额外存储空间 |
| 🎯 定位精确 | 🐌 插入/更新/删除变慢 |

---

## 8. 🛠️ 数据库创建实战


### 8.1 完整建表SQL


```sql
-- 创建数据库
CREATE DATABASE IF NOT EXISTS shop_db CHARACTER SET utf8mb4;
USE shop_db;

-- 1. 创建用户表
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    password VARCHAR(100) NOT NULL COMMENT '密码',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱',
    phone VARCHAR(20) COMMENT '手机号',
    real_name VARCHAR(50) COMMENT '真实姓名',
    created_time DATETIME DEFAULT NOW() COMMENT '注册时间',
    status TINYINT DEFAULT 1 COMMENT '状态:1正常0禁用'
) COMMENT '用户表';

-- 2. 创建商品表
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '商品ID',
    product_name VARCHAR(200) NOT NULL COMMENT '商品名称',
    product_desc TEXT COMMENT '商品描述',
    price DECIMAL(10, 2) NOT NULL COMMENT '价格',
    stock_quantity INT NOT NULL DEFAULT 0 COMMENT '库存数量',
    sales_count INT DEFAULT 0 COMMENT '销量',
    category_id INT COMMENT '分类ID',
    product_image VARCHAR(255) COMMENT '商品图片',
    status TINYINT DEFAULT 1 COMMENT '状态:1上架0下架',
    created_time DATETIME DEFAULT NOW() COMMENT '创建时间',
    updated_time DATETIME DEFAULT NOW() ON UPDATE NOW() COMMENT '更新时间'
) COMMENT '商品表';

-- 3. 创建订单主表
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '订单ID',
    user_id INT NOT NULL COMMENT '用户ID',
    order_no VARCHAR(50) NOT NULL UNIQUE COMMENT '订单号',
    total_amount DECIMAL(10, 2) NOT NULL COMMENT '总金额',
    order_status TINYINT DEFAULT 1 COMMENT '订单状态',
    order_time DATETIME DEFAULT NOW() COMMENT '下单时间',
    payment_time DATETIME COMMENT '支付时间',
    shipping_address TEXT COMMENT '收货地址',
    FOREIGN KEY (user_id) REFERENCES users(user_id)
) COMMENT '订单表';

-- 4. 创建订单详情表
CREATE TABLE order_items (
    item_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '订单项ID',
    order_id INT NOT NULL COMMENT '订单ID',
    product_id INT NOT NULL COMMENT '商品ID',
    quantity INT NOT NULL COMMENT '数量',
    unit_price DECIMAL(10, 2) NOT NULL COMMENT '单价',
    total_price DECIMAL(10, 2) NOT NULL COMMENT '小计',
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
) COMMENT '订单详情表';
```

### 8.2 创建索引


```sql
-- 创建必要的索引
-- 用户表索引
CREATE UNIQUE INDEX idx_username ON users(username);
CREATE UNIQUE INDEX idx_email ON users(email);

-- 订单表索引  
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_order_time ON orders(order_time);
CREATE UNIQUE INDEX idx_order_no ON orders(order_no);

-- 订单详情表索引
CREATE INDEX idx_order_id ON order_items(order_id);
CREATE INDEX idx_product_id ON order_items(product_id);

-- 商品表索引
CREATE INDEX idx_category_id ON products(category_id);
CREATE INDEX idx_status ON products(status);
```

### 8.3 插入测试数据


```sql
-- 插入用户测试数据
INSERT INTO users (username, password, email, phone, real_name) VALUES
('admin', 'admin123', 'admin@shop.com', '13800000001', '管理员'),
('zhangsan', 'zhang123', 'zhang@qq.com', '13800000002', '张三'),
('lisi', 'li123456', 'lisi@163.com', '13800000003', '李四');

-- 插入商品测试数据
INSERT INTO products (product_name, product_desc, price, stock_quantity, category_id) VALUES
('iPhone 15 Pro', '苹果最新旗舰手机', 7999.00, 50, 1),
('华为 Mate 60', '华为最新手机', 4999.00, 80, 1),
('MacBook Air', '苹果笔记本电脑', 8999.00, 30, 2),
('Dell XPS 13', '戴尔超极本', 6999.00, 25, 2);

-- 插入订单测试数据
INSERT INTO orders (user_id, order_no, total_amount, shipping_address) VALUES
(2, 'ORD20240101001', 7999.00, '北京市朝阳区中关村大街1号'),
(3, 'ORD20240101002', 13998.00, '上海市浦东新区陆家嘴金融区');

-- 插入订单详情测试数据
INSERT INTO order_items (order_id, product_id, quantity, unit_price, total_price) VALUES
(1, 1, 1, 7999.00, 7999.00),
(2, 2, 1, 4999.00, 4999.00),
(2, 3, 1, 8999.00, 8999.00);
```

### 8.4 测试查询


```sql
-- 测试常用查询
-- 1. 查询用户信息
SELECT user_id, username, email, real_name, created_time FROM users;

-- 2. 查询商品信息
SELECT product_id, product_name, price, stock_quantity FROM products WHERE status = 1;

-- 3. 查询用户订单(连表查询)
SELECT 
    o.order_no,
    u.username,
    o.total_amount,
    o.order_time
FROM orders o
JOIN users u ON o.user_id = u.user_id;

-- 4. 查询订单详情(多表连查)
SELECT 
    o.order_no,
    p.product_name,
    oi.quantity,
    oi.unit_price,
    oi.total_price
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id  
JOIN products p ON oi.product_id = p.product_id
WHERE o.order_id = 1;
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的设计原则


```
🎯 数据库设计核心原则：
🔸 避免数据冗余：相同信息不重复存储
🔸 保证数据完整性：使用外键约束关联表
🔸 合理使用数据类型：价格用DECIMAL，时间用DATETIME
🔸 设计要考虑扩展：预留必要的字段和表结构
```

### 9.2 表设计要点回顾


**👤 用户表设计重点：**
- 使用`AUTO_INCREMENT`主键
- 用户名和邮箱设置`UNIQUE`约束
- 密码字段长度足够存储加密后内容
- 预留状态字段便于账户管理

**📦 商品表设计重点：**  
- 价格使用`DECIMAL(10,2)`精确存储
- 库存和销量字段便于库存管理
- 预留分类ID便于扩展
- 状态字段控制商品上下架

**🛒 订单表设计重点：**
- 分为订单主表和订单详情表
- 使用外键保证数据一致性
- 订单号便于业务查询
- 预留各种时间字段便于状态跟踪

### 9.3 索引策略要点


**📈 索引创建原则：**
- 主键自动有索引，不用手动创建
- 经常查询的字段创建索引
- 外键字段建议创建索引
- 唯一约束字段自动创建唯一索引

### 9.4 实际项目应用建议


**💡 开发实践建议：**

```
🔸 表名和字段名使用英文，见名知意
🔸 合理使用COMMENT注释，便于维护  
🔸 数据类型选择要考虑业务需求和性能
🔸 外键约束在开发阶段可以先不加，测试通过后再添加
🔸 索引不是越多越好，要根据查询需求合理创建
```

**🎯 常见错误避免：**
- ❌ 所有字段都设为`VARCHAR(255)`
- ❌ 价格字段使用`FLOAT`类型
- ❌ 不使用外键约束导致数据不一致
- ❌ 不考虑索引导致查询慢
- ❌ 表结构设计不考虑扩展性

**核心记忆口诀：**
- 设计数据库先分析，用户商品订单要分离
- 主键外键别忘记，约束索引提性能
- 数据类型选准确，DECIMAL价格不会错
- 扩展维护要考虑，注释文档不能少