---
title: 2、连接异常处理策略
---
## 📚 目录

1. [连接异常的基本概念](#1-连接异常的基本概念)
2. [连接超时异常详解](#2-连接超时异常详解)
3. [网络中断处理机制](#3-网络中断处理机制)
4. [数据库宕机应对策略](#4-数据库宕机应对策略)
5. [重连机制设计与实现](#5-重连机制设计与实现)
6. [故障转移策略详解](#6-故障转移策略详解)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🚨 连接异常的基本概念


### 1.1 什么是连接异常


💭 **想象一下**：你在给朋友打电话，可能遇到的问题有哪些？
- 📞 拨号拨不通（连接超时）
- 📶 信号不好断线了（网络中断）
- 📴 对方手机关机（服务器宕机）

**在JDBC中也是一样的道理**：

🏷️ **连接异常** = 程序和数据库之间的"通话"出现了问题

```java
// 这就像打电话一样，可能出现各种问题
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", 
    "username", 
    "password"
);
```

### 1.2 常见的连接异常类型


| **异常类型** | **通俗理解** | **技术原因** | **影响程度** |
|-------------|-------------|-------------|-------------|
| 🕐 **连接超时** | 电话一直在拨但没人接 | 数据库响应太慢 | ⭐⭐⭐ |
| 📡 **网络中断** | 通话中突然断线 | 网络连接断开 | ⭐⭐⭐⭐ |
| 💥 **数据库宕机** | 对方手机彻底关机 | 数据库服务停止 | ⭐⭐⭐⭐⭐ |
| 🔐 **认证失败** | 密码错了进不去 | 用户名密码错误 | ⭐⭐ |

### 1.3 异常处理的重要性


🤔 **为什么要处理连接异常**？

**不处理异常的后果**：
```
用户点击登录 → 程序崩溃 → 白屏页面 → 用户困惑离开
```

**正确处理异常的效果**：
```
用户点击登录 → 网络异常 → 友好提示 → 自动重试 → 用户继续使用
```

✅ **好处**：
- 🛡️ **程序稳定**：不会因为网络问题就崩溃
- 😊 **用户体验**：给用户明确的错误提示
- 🔄 **自动恢复**：可以自动重试连接
- 📊 **问题定位**：记录日志便于排查问题

---

## 2. ⏰ 连接超时异常详解


### 2.1 什么是连接超时


🌰 **生活例子**：你去银行排队办业务，等了30分钟还没轮到你，你可能就放弃了。

**在JDBC中**：程序尝试连接数据库，等待一定时间后如果还没连上，就放弃连接。

```java
// 设置连接超时时间（单位：秒）
String url = "jdbc:mysql://localhost:3306/mydb?connectTimeout=30000";
// 这里的30000表示30秒，超过30秒就放弃连接
```

### 2.2 连接超时的常见原因


📋 **主要原因分析**：

**网络方面的原因**：
- 🌐 网络延迟高（比如跨地区连接）
- 📡 网络带宽不足
- 🔥 防火墙阻挡连接

**数据库方面的原因**：
- 💾 数据库负载过高
- 🔒 连接池已满，没有空闲连接
- ⚙️ 数据库配置的超时时间太短

**应用程序方面的原因**：
- 📝 连接字符串配置错误
- 🏗️ 连接池配置不合理

### 2.3 超时异常的处理策略


🔧 **基础处理方案**：

```java
public class ConnectionTimeoutHandler {
    private static final int MAX_RETRY_TIMES = 3;
    private static final int RETRY_DELAY = 2000; // 2秒
    
    public Connection getConnectionWithRetry() {
        SQLException lastException = null;
        
        for (int i = 0; i < MAX_RETRY_TIMES; i++) {
            try {
                // 尝试连接数据库
                return DriverManager.getConnection(
                    "jdbc:mysql://localhost:3306/mydb?connectTimeout=10000",
                    "username", "password"
                );
                
            } catch (SQLException e) {
                lastException = e;
                System.out.println("连接失败，第" + (i+1) + "次重试...");
                
                // 等待一段时间再重试
                try {
                    Thread.sleep(RETRY_DELAY);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
        
        // 所有重试都失败了
        throw new RuntimeException("连接数据库失败，已重试" + MAX_RETRY_TIMES + "次", lastException);
    }
}
```

💡 **这段代码的工作流程**：
1. 📞 尝试连接数据库
2. ⏰ 如果超时，等待2秒
3. 🔄 再次尝试，最多重试3次
4. 🚨 如果还是失败，抛出异常并记录详细信息

### 2.4 超时时间的合理设置


🎯 **如何设置合适的超时时间**？

| **应用场景** | **建议超时时间** | **理由** |
|-------------|----------------|---------|
| 🖥️ **本地开发** | 5-10秒 | 本地网络快，不需要太长 |
| 🌐 **内网应用** | 15-30秒 | 内网相对稳定，适中即可 |
| ☁️ **云环境** | 30-60秒 | 网络延迟可能较高 |
| 📱 **移动应用** | 10-20秒 | 用户等待耐心有限 |

**配置示例**：
```java
// 方法1：在URL中设置
String url = "jdbc:mysql://localhost:3306/mydb?" +
             "connectTimeout=30000&" +          // 连接超时30秒
             "socketTimeout=60000";             // 读取超时60秒

// 方法2：通过Properties设置
Properties props = new Properties();
props.setProperty("user", "username");
props.setProperty("password", "password");
props.setProperty("connectTimeout", "30000");
props.setProperty("socketTimeout", "60000");
Connection conn = DriverManager.getConnection(url, props);
```

---

## 3. 📡 网络中断处理机制


### 3.1 网络中断的表现形式


🔍 **网络中断是怎么发生的**？

**突然中断**：
```
正在执行SQL查询 → 网线被拔掉 → 连接立即断开
```

**缓慢中断**：
```
网络变得很慢 → 数据传输超时 → 连接逐渐失效
```

**间歇性中断**：
```
网络时好时坏 → 有时能连上有时不能 → 连接不稳定
```

### 3.2 检测网络中断的方法


🔧 **如何知道网络断了**？

**方法1：连接有效性检查**

```java
public boolean isConnectionValid(Connection conn) {
    try {
        // 检查连接是否有效（等待5秒）
        return conn != null && conn.isValid(5);
    } catch (SQLException e) {
        return false;
    }
}
```

**方法2：执行简单查询测试**

```java
public boolean testConnection(Connection conn) {
    try {
        PreparedStatement ps = conn.prepareStatement("SELECT 1");
        ResultSet rs = ps.executeQuery();
        return rs.next();
    } catch (SQLException e) {
        System.out.println("连接测试失败：" + e.getMessage());
        return false;
    }
}
```

**方法3：设置心跳检测**

```
数据库连接 ← 每隔30秒 ← "你还在吗？"（心跳包）
数据库连接 → 每隔30秒 → "我还在！"（响应）
```

### 3.3 网络中断的恢复策略


🔄 **网络断了之后怎么办**？

**立即重连策略**：
```java
public class NetworkInterruptionHandler {
    
    public void handleNetworkFailure(SQLException e) {
        if (isNetworkRelated(e)) {
            System.out.println("检测到网络问题，尝试重新连接...");
            
            // 关闭旧连接
            closeQuietly(connection);
            
            // 立即尝试重新连接
            connection = createNewConnection();
        }
    }
    
    private boolean isNetworkRelated(SQLException e) {
        String message = e.getMessage().toLowerCase();
        return message.contains("connection") || 
               message.contains("timeout") || 
               message.contains("network");
    }
}
```

**延迟重连策略**：
```java
public Connection reconnectWithBackoff() {
    int[] delays = {1000, 2000, 5000, 10000}; // 递增延迟
    
    for (int delay : delays) {
        try {
            Thread.sleep(delay);
            Connection conn = createConnection();
            System.out.println("重连成功！");
            return conn;
        } catch (Exception e) {
            System.out.println("重连失败，" + (delay/1000) + "秒后再试...");
        }
    }
    
    throw new RuntimeException("网络恢复失败，请检查网络连接");
}
```

### 3.4 网络中断的预防措施


🛡️ **如何减少网络中断的影响**？

**连接池配置优化**：
```java
// 使用连接池的好处
HikariConfig config = new HikariConfig();
config.setMaximumPoolSize(20);           // 最大连接数
config.setConnectionTimeout(30000);      // 连接超时30秒
config.setIdleTimeout(600000);           // 空闲超时10分钟  
config.setMaxLifetime(1800000);          // 连接最大生命周期30分钟
config.setConnectionTestQuery("SELECT 1"); // 连接测试查询
```

💡 **连接池就像公交车站**：
- 🚌 **连接池** = 公交车站，随时有车可以坐
- 🚗 **单个连接** = 私家车，坏了就没法用了
- 🔄 **连接回收** = 车到终点站，回去继续运营

---

## 4. 💥 数据库宕机应对策略


### 4.1 数据库宕机的识别


🚨 **数据库宕机是什么意思**？

**简单理解**：数据库服务器彻底"罢工"了，就像商店关门一样，暂时不营业。

**技术表现**：
```
应用程序：你好，我想查询数据
数据库：......（没有任何回应）
应用程序：连接被拒绝
```

**常见的宕机异常信息**：
```java
// 这些异常信息表明数据库可能宕机了
SQLException: Connection refused
SQLException: No route to host  
SQLException: Connection timed out
SQLException: Can't connect to MySQL server
```

### 4.2 宕机检测机制


🔍 **如何快速发现数据库宕机**？

**健康检查机制**：
```java
public class DatabaseHealthChecker {
    private volatile boolean isDatabaseAlive = true;
    
    // 每分钟检查一次数据库状态
    @Scheduled(fixedRate = 60000)
    public void checkDatabaseHealth() {
        try {
            Connection conn = dataSource.getConnection();
            PreparedStatement ps = conn.prepareStatement("SELECT 1");
            ps.executeQuery();
            
            // 如果执行成功，说明数据库正常
            if (!isDatabaseAlive) {
                System.out.println("✅ 数据库已恢复正常！");
                isDatabaseAlive = true;
            }
            
        } catch (SQLException e) {
            if (isDatabaseAlive) {
                System.out.println("❌ 检测到数据库异常：" + e.getMessage());
                isDatabaseAlive = false;
            }
        }
    }
    
    public boolean isDatabaseAvailable() {
        return isDatabaseAlive;
    }
}
```

### 4.3 宕机期间的应对措施


🛡️ **数据库宕机了怎么办**？

**策略1：缓存降级**
```java
public User getUserById(int userId) {
    // 先检查数据库是否可用
    if (!healthChecker.isDatabaseAvailable()) {
        // 数据库不可用，尝试从缓存获取
        User cachedUser = cache.get("user_" + userId);
        if (cachedUser != null) {
            System.out.println("数据库不可用，返回缓存数据");
            return cachedUser;
        } else {
            throw new ServiceException("服务暂时不可用，请稍后重试");
        }
    }
    
    // 数据库可用，正常查询
    return userDao.findById(userId);
}
```

**策略2：只读模式**
```java
public class ReadOnlyModeHandler {
    private boolean isReadOnlyMode = false;
    
    public void enableReadOnlyMode() {
        isReadOnlyMode = true;
        System.out.println("⚠️ 系统进入只读模式");
    }
    
    public void saveUser(User user) {
        if (isReadOnlyMode) {
            throw new ServiceException("系统维护中，暂时无法保存数据");
        }
        // 正常保存逻辑
        userDao.save(user);
    }
}
```

**策略3：友好错误提示**
```java
public class UserFriendlyErrorHandler {
    
    public String handleDatabaseError(SQLException e) {
        if (isDatabaseDownError(e)) {
            return "🔧 系统正在维护中，预计10分钟后恢复，请稍后重试";
        } else if (isConnectionTimeoutError(e)) {
            return "⏰ 网络连接超时，请检查网络后重试";
        } else {
            return "😅 出了点小问题，我们正在努力修复中";
        }
    }
}
```

### 4.4 宕机恢复检测


🔄 **数据库恢复了怎么知道**？

**自动恢复检测**：
```java
public class DatabaseRecoveryDetector {
    
    public void waitForDatabaseRecovery() {
        System.out.println("⏳ 等待数据库恢复中...");
        
        while (true) {
            try {
                // 尝试连接数据库
                Connection testConn = createConnection();
                testConn.close();
                
                System.out.println("🎉 数据库已恢复！重新启动服务...");
                restartServices();
                break;
                
            } catch (SQLException e) {
                System.out.println("💤 数据库仍未恢复，30秒后再试...");
                try {
                    Thread.sleep(30000); // 等待30秒
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
    
    private void restartServices() {
        // 重新启动相关服务
        // 清空错误缓存
        // 发送恢复通知
    }
}
```

---

## 5. 🔄 重连机制设计与实现


### 5.1 重连机制的基本思路


💭 **重连机制就像什么**？

🏥 **医生看病的例子**：
- 第1次：敲门没人应答，等1分钟再敲
- 第2次：还是没应答，等2分钟再敲  
- 第3次：等5分钟再敲
- 如果还不行，就认为今天看不了病了

**在数据库连接中也是同样道理**：
```
第1次连接失败 → 等1秒 → 第2次尝试
第2次连接失败 → 等2秒 → 第3次尝试  
第3次连接失败 → 等5秒 → 第4次尝试
全部失败 → 放弃连接，报告错误
```

### 5.2 重连策略的类型


📊 **常用的重连策略对比**：

| **策略类型** | **等待时间** | **适用场景** | **优缺点** |
|-------------|-------------|-------------|-----------|
| 🔢 **固定间隔** | 每次都等3秒 | 网络稳定的环境 | 简单但可能浪费时间 |
| 📈 **递增延迟** | 1秒→2秒→4秒→8秒 | 网络不稳定的环境 | 平衡效率和成功率 |
| 🎲 **随机延迟** | 随机1-5秒 | 多个应用同时重连 | 避免同时重连冲突 |
| 🎯 **智能延迟** | 根据错误类型调整 | 复杂的生产环境 | 效果最好但实现复杂 |

### 5.3 递增延迟重连实现


🔧 **推荐的重连实现方案**：

```java
public class SmartReconnector {
    private static final int[] RETRY_DELAYS = {1000, 2000, 5000, 10000, 30000}; // 毫秒
    private static final int MAX_RETRIES = RETRY_DELAYS.length;
    
    public Connection reconnectWithBackoff(String url, String username, String password) {
        SQLException lastException = null;
        
        for (int attempt = 0; attempt < MAX_RETRIES; attempt++) {
            try {
                System.out.printf("🔄 第%d次连接尝试...\n", attempt + 1);
                
                Connection conn = DriverManager.getConnection(url, username, password);
                System.out.println("✅ 连接成功！");
                return conn;
                
            } catch (SQLException e) {
                lastException = e;
                int delay = RETRY_DELAYS[attempt];
                
                System.out.printf("❌ 连接失败：%s\n", e.getMessage());
                System.out.printf("⏰ %d秒后重试...\n", delay/1000);
                
                if (attempt < MAX_RETRIES - 1) { // 最后一次不需要等待
                    try {
                        Thread.sleep(delay);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("重连被中断", ie);
                    }
                }
            }
        }
        
        throw new RuntimeException("重连失败，已尝试" + MAX_RETRIES + "次", lastException);
    }
}
```

💡 **这个重连机制的特点**：
- ⏰ **递增延迟**：等待时间逐渐增加，给网络恢复更多时间
- 🎯 **有限重试**：避免无限重试浪费资源
- 📝 **详细日志**：方便排查问题
- 🛡️ **中断支持**：可以随时停止重连

### 5.4 智能重连策略


🧠 **更聪明的重连方式**：

```java
public class IntelligentReconnector {
    
    public Connection smartReconnect(SQLException originalError, String url, String user, String pass) {
        // 根据错误类型决定重连策略
        ReconnectStrategy strategy = analyzeError(originalError);
        
        return executeReconnectStrategy(strategy, url, user, pass);
    }
    
    private ReconnectStrategy analyzeError(SQLException e) {
        String errorMsg = e.getMessage().toLowerCase();
        
        if (errorMsg.contains("connection refused")) {
            // 数据库完全不可用，延迟较长时间重试
            return new ReconnectStrategy(new int[]{5000, 15000, 30000}, "数据库服务不可用");
            
        } else if (errorMsg.contains("timeout")) {
            // 超时问题，可能是网络慢，快速重试
            return new ReconnectStrategy(new int[]{1000, 3000, 5000}, "连接超时");
            
        } else if (errorMsg.contains("too many connections")) {
            // 连接数过多，等待其他连接释放
            return new ReconnectStrategy(new int[]{2000, 5000, 10000}, "连接数过多");
            
        } else {
            // 未知错误，使用默认策略
            return new ReconnectStrategy(new int[]{2000, 4000, 8000}, "未知连接错误");
        }
    }
}

class ReconnectStrategy {
    private final int[] delays;
    private final String description;
    
    public ReconnectStrategy(int[] delays, String description) {
        this.delays = delays;
        this.description = description;
    }
    
    // getter方法省略...
}
```

### 5.5 重连机制的最佳实践


✅ **重连机制使用建议**：

**DO（应该做的）**：
- ✅ 设置最大重试次数，避免无限重试
- ✅ 使用递增延迟，给系统恢复时间
- ✅ 记录重连日志，便于问题排查
- ✅ 在重试前释放之前的连接资源
- ✅ 考虑业务场景，有些操作不适合重试

**DON'T（不应该做的）**：
- ❌ 不设置重试上限
- ❌ 重试间隔太短，给系统造成压力
- ❌ 所有异常都重试（有些错误重试也没用）
- ❌ 不记录重试过程，问题难以排查
- ❌ 在事务中盲目重试，可能导致数据不一致

---

## 6. 🔀 故障转移策略详解


### 6.1 什么是故障转移


🏥 **故障转移就像医院的转诊**：

**主治医生不在** → **转到副主任医生** → **如果副主任也不在** → **转到其他科室医生**

**在数据库中**：
```
主数据库不可用 → 切换到备用数据库 → 如果备用也不行 → 切换到第三个数据库
```

🔍 **故障转移的核心思想**：
- 🎯 **高可用性**：确保服务不中断
- ⚡ **快速切换**：故障发生时快速响应
- 🔄 **自动化**：不需要人工干预
- 💾 **数据一致性**：切换后数据要保持一致

### 6.2 故障转移的架构模式


📊 **常见的故障转移架构**：

**主从架构（Master-Slave）**：
```
应用程序
    ↓
🟢 主数据库 (Master)    ←→ 🔄 数据同步 ←→    🔵 从数据库 (Slave)
    ↓ 故障                                        ↑
    ❌                                            ✅ 切换到这里
```

**双主架构（Master-Master）**：
```
应用程序
    ↓
🟢 数据库A    ←→ 🔄 双向同步 ←→    🟢 数据库B
```

**集群架构（Cluster）**：
```
应用程序
    ↓
🎯 负载均衡器
    ↓
🟢 数据库1    🟢 数据库2    🟢 数据库3
```

### 6.3 故障转移的实现方式


🔧 **方式一：应用层故障转移**

```java
public class ApplicationFailover {
    private List<DataSource> dataSources;
    private int currentIndex = 0;
    
    public ApplicationFailover() {
        dataSources = Arrays.asList(
            createDataSource("jdbc:mysql://db1:3306/mydb"),  // 主数据库
            createDataSource("jdbc:mysql://db2:3306/mydb"),  // 备用数据库1  
            createDataSource("jdbc:mysql://db3:3306/mydb")   // 备用数据库2
        );
    }
    
    public Connection getConnection() throws SQLException {
        // 尝试从当前数据源获取连接
        for (int attempts = 0; attempts < dataSources.size(); attempts++) {
            DataSource currentDS = dataSources.get(currentIndex);
            
            try {
                Connection conn = currentDS.getConnection();
                // 测试连接是否有效
                if (conn.isValid(5)) {
                    System.out.println("✅ 使用数据库" + (currentIndex + 1));
                    return conn;
                }
            } catch (SQLException e) {
                System.out.println("❌ 数据库" + (currentIndex + 1) + "不可用：" + e.getMessage());
                // 切换到下一个数据源
                switchToNextDataSource();
            }
        }
        
        throw new SQLException("所有数据库都不可用");
    }
    
    private void switchToNextDataSource() {
        currentIndex = (currentIndex + 1) % dataSources.size();
        System.out.println("🔄 切换到数据库" + (currentIndex + 1));
    }
}
```

**方式二：读写分离的故障转移**

```java
public class ReadWriteSplitFailover {
    private DataSource masterDataSource;    // 主库（写）
    private List<DataSource> slaveDataSources; // 从库（读）
    private int currentSlaveIndex = 0;
    
    // 获取写连接（主库）
    public Connection getWriteConnection() throws SQLException {
        try {
            return masterDataSource.getConnection();
        } catch (SQLException e) {
            System.out.println("❌ 主库不可用，写操作暂停");
            throw new SQLException("写操作暂时不可用", e);
        }
    }
    
    // 获取读连接（从库）
    public Connection getReadConnection() throws SQLException {
        // 先尝试从库
        for (int i = 0; i < slaveDataSources.size(); i++) {
            try {
                DataSource slaveDS = slaveDataSources.get(currentSlaveIndex);
                Connection conn = slaveDS.getConnection();
                
                if (conn.isValid(3)) {
                    return conn;
                }
            } catch (SQLException e) {
                System.out.println("从库" + (currentSlaveIndex + 1) + "不可用，尝试下一个");
                currentSlaveIndex = (currentSlaveIndex + 1) % slaveDataSources.size();
            }
        }
        
        // 所有从库都不可用，尝试主库
        System.out.println("⚠️ 所有从库不可用，使用主库进行读操作");
        return masterDataSource.getConnection();
    }
}
```

### 6.4 故障检测与切换


🔍 **如何检测故障并自动切换**：

```java
public class AutoFailoverManager {
    private volatile int currentDataSourceIndex = 0;
    private List<DataSource> dataSources;
    private ScheduledExecutorService healthChecker;
    
    public AutoFailoverManager(List<DataSource> dataSources) {
        this.dataSources = dataSources;
        startHealthCheck();
    }
    
    // 启动健康检查
    private void startHealthCheck() {
        healthChecker = Executors.newScheduledThreadPool(1);
        
        // 每30秒检查一次所有数据源的健康状态
        healthChecker.scheduleAtFixedRate(() -> {
            checkAllDataSourcesHealth();
        }, 0, 30, TimeUnit.SECONDS);
    }
    
    private void checkAllDataSourcesHealth() {
        for (int i = 0; i < dataSources.size(); i++) {
            boolean isHealthy = testDataSourceHealth(dataSources.get(i));
            
            if (i == currentDataSourceIndex && !isHealthy) {
                // 当前数据源不健康，需要切换
                System.out.println("🚨 当前数据源故障，开始切换...");
                switchToHealthyDataSource();
            }
        }
    }
    
    private boolean testDataSourceHealth(DataSource ds) {
        try (Connection conn = ds.getConnection()) {
            return conn.isValid(5);
        } catch (Exception e) {
            return false;
        }
    }
    
    private void switchToHealthyDataSource() {
        for (int i = 0; i < dataSources.size(); i++) {
            int nextIndex = (currentDataSourceIndex + i + 1) % dataSources.size();
            
            if (testDataSourceHealth(dataSources.get(nextIndex))) {
                currentDataSourceIndex = nextIndex;
                System.out.println("✅ 已切换到数据源" + (nextIndex + 1));
                return;
            }
        }
        
        System.out.println("❌ 没有可用的数据源");
    }
}
```

### 6.5 故障转移的注意事项


⚠️ **故障转移时需要注意的问题**：

**数据一致性问题**：
```java
// 问题场景：写入主库后，立即从从库读取
public void problematicScenario() {
    // 1. 写入主库
    masterDB.execute("INSERT INTO users VALUES (1, 'Alice')");
    
    // 2. 立即从从库读取（数据可能还没同步过来）
    User user = slaveDB.query("SELECT * FROM users WHERE id = 1");
    // user 可能为 null，因为数据还没有同步到从库
}

// 解决方案：强制读主库或延迟读取
public void betterApproach() {
    // 写入后的读取操作使用主库
    masterDB.execute("INSERT INTO users VALUES (1, 'Alice')");
    
    // 从主库读取，确保数据一致性
    User user = masterDB.query("SELECT * FROM users WHERE id = 1");
}
```

**事务处理问题**：
```java
public void handleTransactionFailover() {
    Connection conn = null;
    try {
        conn = getConnection();
        conn.setAutoCommit(false);
        
        // 执行业务操作
        executeBusinessLogic(conn);
        
        conn.commit();
        
    } catch (SQLException e) {
        if (conn != null) {
            try {
                conn.rollback(); // 发生故障时回滚事务
            } catch (SQLException rollbackEx) {
                // 记录回滚失败的日志
            }
        }
        
        // 不要在事务中间进行故障转移！
        // 这可能导致数据不一致
        throw new RuntimeException("事务执行失败", e);
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


🎯 **连接异常处理的核心原则**：
- 🔍 **及早检测**：快速发现连接问题
- 🔄 **合理重试**：不盲目重试，不轻易放弃
- 🛡️ **优雅降级**：数据库不可用时提供备选方案
- 📝 **详细日志**：记录异常信息便于排查
- 😊 **用户体验**：给用户友好的错误提示

### 7.2 异常处理策略选择指南


| **场景** | **推荐策略** | **重试次数** | **重试间隔** |
|---------|-------------|-------------|-------------|
| 🖥️ **开发环境** | 简单重试 | 2-3次 | 固定1-2秒 |
| 🏢 **内网生产** | 智能重试 | 3-5次 | 递增延迟 |
| ☁️ **云环境** | 故障转移 | 5-10次 | 递增+随机 |
| 📱 **移动应用** | 快速失败 | 2-3次 | 短间隔 |

### 7.3 最佳实践建议


✅ **推荐做法**：
- **连接池配置**：合理设置连接池参数
- **超时设置**：根据网络环境设置合适的超时时间  
- **健康检查**：定期检查连接有效性
- **监控报警**：及时发现和处理异常
- **故障演练**：定期测试故障转移机制

❌ **避免的做法**：
- **无限重试**：可能造成系统雪崩
- **忽略异常**：隐藏问题导致更大故障
- **同步切换**：阻塞用户请求
- **数据不一致**：切换时不考虑事务状态

### 7.4 故障场景应对手册


🚨 **常见故障及应对方案**：

**网络波动**：
```
现象：间歇性连接超时
处理：启用重试机制，设置合理超时时间
代码：使用连接池的自动重连功能
```

**数据库重启**：
```
现象：连接被拒绝，之后恢复正常
处理：检测到故障后等待恢复，自动重连
代码：实现健康检查和自动重连逻辑
```

**网络中断**：
```
现象：所有连接断开，长时间无法连接
处理：启用缓存降级，提供只读服务
代码：实现缓存机制和降级逻辑
```

**数据库宕机**：
```
现象：数据库完全不可用
处理：故障转移到备用数据库
代码：实现多数据源切换机制
```

🔑 **核心记忆要点**：
- **连接异常**：像打电话一样，可能遇到各种问题
- **重试机制**：要有耐心，但不能无限等待
- **故障转移**：准备备用方案，确保服务不中断
- **用户体验**：技术问题不应该影响用户使用
- **监控日志**：问题发生时能快速定位和解决

💡 **一句话总结**：
数据库连接异常处理就是让程序在遇到网络问题时，既能自动恢复，又能给用户友好的体验，确保系统稳定可靠运行。