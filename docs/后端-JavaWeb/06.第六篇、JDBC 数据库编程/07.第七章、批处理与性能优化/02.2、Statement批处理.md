---
title: 2、Statement批处理
---
## 📚 目录

1. [什么是批处理](#1-什么是批处理)
2. [Statement批处理基础](#2-Statement批处理基础)
3. [批处理的执行方式](#3-批处理的执行方式)
4. [批处理异常处理](#4-批处理异常处理)
5. [性能对比与优化](#5-性能对比与优化)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 什么是批处理


### 1.1 批处理的基本概念


**📖 简单理解**：
批处理就像是"打包发货"，不是一个一个地发送SQL语句到数据库，而是把多个SQL语句打包在一起，一次性发送执行。

```
传统方式（一个一个执行）：
执行SQL1 → 等待结果 → 执行SQL2 → 等待结果 → 执行SQL3 → 等待结果

批处理方式（打包执行）：
打包(SQL1 + SQL2 + SQL3) → 一次性发送 → 批量返回结果
```

**🎯 核心定义**：
- **批处理（Batch Processing）**：将多个SQL语句收集起来，作为一个批次提交给数据库执行
- **目的**：减少网络通信次数，提高执行效率
- **适用场景**：需要执行大量相似的SQL操作时

### 1.2 为什么需要批处理


**🤔 问题场景**：
假设你要向数据库插入1000条学生记录，传统方式需要：
- 发送1000次INSERT语句
- 每次都要等待数据库响应
- 网络传输开销巨大

**💡 批处理的优势**：

| 对比项 | **传统方式** | **批处理方式** |
|--------|-------------|---------------|
| 🌐 **网络通信** | 1000次往返 | 1次往返 |
| ⏱️ **执行时间** | 长（每次等待） | 短（批量处理） |
| 🔄 **事务控制** | 分散处理 | 统一管理 |
| 📊 **性能提升** | 基准 | 10-50倍提升 |

**🎯 实际意义**：
```
举个生活例子：
传统方式 = 你去超市买东西，每买一样就排队结账一次
批处理方式 = 你把所有东西装进购物车，最后一次性结账

显然批处理更高效！
```

---

## 2. 🔧 Statement批处理基础


### 2.1 Statement批处理的核心方法


**📋 核心API方法**：

```java
// 核心方法解析
Statement statement = connection.createStatement();

// 1. 添加SQL到批次中
statement.addBatch(String sql);

// 2. 执行整个批次
int[] results = statement.executeBatch();

// 3. 清空批次（可选）
statement.clearBatch();
```

**🔍 方法详解**：
- **`addBatch(String sql)`**：把SQL语句添加到"购物车"里，暂时不执行
- **`executeBatch()`**：一次性"结账"，执行所有SQL语句
- **`clearBatch()`**：清空"购物车"，重新开始

### 2.2 基础批处理示例


**💻 简单插入示例**：
```java
public class StatementBatchDemo {
    public static void batchInsertStudents() {
        Connection conn = null;
        Statement stmt = null;
        
        try {
            // 获取连接
            conn = DatabaseUtil.getConnection();
            stmt = conn.createStatement();
            
            // 🔸 添加多条SQL到批次中
            stmt.addBatch("INSERT INTO student VALUES(1, '张三', 20)");
            stmt.addBatch("INSERT INTO student VALUES(2, '李四', 21)");
            stmt.addBatch("INSERT INTO student VALUES(3, '王五', 22)");
            
            // 🔸 一次性执行所有SQL
            int[] results = stmt.executeBatch();
            
            // 🔸 处理执行结果
            System.out.println("批处理完成，影响行数：");
            for(int i = 0; i < results.length; i++) {
                System.out.println("SQL" + (i+1) + ": " + results[i] + "行");
            }
            
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            DatabaseUtil.close(conn, stmt, null);
        }
    }
}
```

**🎓 代码理解**：
1. **添加阶段**：像往购物车里放商品一样，把SQL语句一个个加进去
2. **执行阶段**：调用`executeBatch()`就像点击"立即购买"
3. **结果处理**：返回数组告诉你每个SQL影响了多少行数据

---

## 3. ⚙️ 批处理的执行方式


### 3.1 动态批处理示例


**🔄 循环添加批处理**：
```java
public class DynamicBatchExample {
    public static void batchInsertFromArray() {
        // 模拟要插入的学生数据
        String[][] students = {
            {"张三", "20"}, {"李四", "21"}, {"王五", "22"},
            {"赵六", "23"}, {"孙七", "24"}
        };
        
        Connection conn = null;
        Statement stmt = null;
        
        try {
            conn = DatabaseUtil.getConnection();
            stmt = conn.createStatement();
            
            // 🔸 动态添加SQL到批次
            for(int i = 0; i < students.length; i++) {
                String sql = "INSERT INTO student(name, age) VALUES('" 
                           + students[i][0] + "', " + students[i][1] + ")";
                stmt.addBatch(sql);
                
                System.out.println("添加到批次：" + sql);
            }
            
            // 🔸 执行批处理
            int[] results = stmt.executeBatch();
            
            System.out.println("批处理执行完成，共处理 " + results.length + " 条SQL");
            
        } catch (SQLException e) {
            System.out.println("批处理执行失败：" + e.getMessage());
        } finally {
            DatabaseUtil.close(conn, stmt, null);
        }
    }
}
```

### 3.2 分批处理策略


**🎯 大数据量处理**：
当数据量很大时（比如10万条），不能一次性全部添加到批次中，需要分批处理：

```java
public class LargeBatchExample {
    private static final int BATCH_SIZE = 1000; // 每批处理1000条
    
    public static void largeBatchInsert(List<Student> studentList) {
        Connection conn = null;
        Statement stmt = null;
        
        try {
            conn = DatabaseUtil.getConnection();
            stmt = conn.createStatement();
            
            int count = 0;
            int totalProcessed = 0;
            
            for(Student student : studentList) {
                // 添加SQL到当前批次
                String sql = "INSERT INTO student VALUES(" + student.getId() 
                           + ", '" + student.getName() + "', " + student.getAge() + ")";
                stmt.addBatch(sql);
                count++;
                
                // 🔸 达到批次大小或处理完所有数据时执行
                if(count == BATCH_SIZE || totalProcessed + count == studentList.size()) {
                    int[] results = stmt.executeBatch();
                    totalProcessed += count;
                    
                    System.out.println("执行批次，处理了 " + count + " 条数据");
                    System.out.println("累计处理：" + totalProcessed + "/" + studentList.size());
                    
                    // 重置计数器和批次
                    count = 0;
                    stmt.clearBatch();
                }
            }
            
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            DatabaseUtil.close(conn, stmt, null);
        }
    }
}
```

**🧠 分批处理的关键点**：
- **批次大小**：通常设置为500-2000，太小效果不明显，太大可能内存不足
- **及时执行**：达到批次大小就执行一次，不要等到最后
- **清理批次**：执行后用`clearBatch()`清空，为下一批做准备

---

## 4. 🛡️ 批处理异常处理


### 4.1 批处理异常类型


**⚠️ 常见异常情况**：

```
批处理执行时可能遇到的问题：
1. 🚫 某个SQL语法错误
2. 🚫 违反数据库约束（如主键重复）
3. 🚫 网络连接中断
4. 🚫 数据库锁定或超时
```

**📊 异常处理策略**：

| 异常类型 | **影响范围** | **处理方式** |
|----------|-------------|--------------|
| `SQLException` | 整个批次失败 | 回滚事务，重新处理 |
| `BatchUpdateException` | 部分SQL失败 | 分析失败原因，处理成功部分 |

### 4.2 完整异常处理示例


```java
public class BatchExceptionHandling {
    public static void safeBatchInsert() {
        Connection conn = null;
        Statement stmt = null;
        
        try {
            conn = DatabaseUtil.getConnection();
            conn.setAutoCommit(false); // 🔸 关闭自动提交，手动控制事务
            
            stmt = conn.createStatement();
            
            // 添加一些SQL，其中故意包含错误的SQL
            stmt.addBatch("INSERT INTO student VALUES(1, '张三', 20)");
            stmt.addBatch("INSERT INTO student VALUES(2, '李四', 21)");
            stmt.addBatch("INSERT INTO student VALUES(1, '重复ID', 25)"); // 这个会失败
            stmt.addBatch("INSERT INTO student VALUES(3, '王五', 22)");
            
            // 执行批处理
            int[] results = stmt.executeBatch();
            
            // 如果到这里说明全部成功
            conn.commit();
            System.out.println("批处理全部成功！");
            
        } catch (BatchUpdateException bue) {
            // 🔸 批处理部分失败的情况
            System.out.println("批处理部分失败：" + bue.getMessage());
            
            // 获取成功执行的结果
            int[] successCounts = bue.getUpdateCounts();
            System.out.println("成功执行的SQL数量：" + successCounts.length);
            
            for(int i = 0; i < successCounts.length; i++) {
                if(successCounts[i] >= 0) {
                    System.out.println("SQL" + (i+1) + " 成功，影响 " + successCounts[i] + " 行");
                } else {
                    System.out.println("SQL" + (i+1) + " 失败");
                }
            }
            
            try {
                conn.rollback(); // 回滚事务
                System.out.println("事务已回滚");
            } catch (SQLException e) {
                e.printStackTrace();
            }
            
        } catch (SQLException se) {
            // 🔸 其他SQL异常
            System.out.println("SQL异常：" + se.getMessage());
            try {
                conn.rollback();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            
        } finally {
            try {
                if(conn != null) conn.setAutoCommit(true); // 恢复自动提交
            } catch (SQLException e) {
                e.printStackTrace();
            }
            DatabaseUtil.close(conn, stmt, null);
        }
    }
}
```

**🎓 异常处理要点**：
- **事务控制**：批处理通常配合事务使用，要么全成功，要么全回滚
- **分类处理**：区分`BatchUpdateException`和普通`SQLException`
- **资源清理**：无论成功失败，都要正确关闭资源

---

## 5. 🚀 性能对比与优化


### 5.1 性能测试对比


**📊 性能测试示例**：
```java
public class PerformanceComparison {
    
    // 传统方式：逐条执行
    public static long traditionalInsert(int recordCount) {
        long startTime = System.currentTimeMillis();
        
        Connection conn = null;
        Statement stmt = null;
        
        try {
            conn = DatabaseUtil.getConnection();
            stmt = conn.createStatement();
            
            for(int i = 1; i <= recordCount; i++) {
                String sql = "INSERT INTO test_table VALUES(" + i + ", 'name" + i + "', " + (20 + i % 10) + ")";
                stmt.executeUpdate(sql); // 🔸 每次都执行一条SQL
            }
            
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            DatabaseUtil.close(conn, stmt, null);
        }
        
        long endTime = System.currentTimeMillis();
        return endTime - startTime;
    }
    
    // 批处理方式：批量执行
    public static long batchInsert(int recordCount) {
        long startTime = System.currentTimeMillis();
        
        Connection conn = null;
        Statement stmt = null;
        
        try {
            conn = DatabaseUtil.getConnection();
            stmt = conn.createStatement();
            
            for(int i = 1; i <= recordCount; i++) {
                String sql = "INSERT INTO test_table VALUES(" + i + ", 'name" + i + "', " + (20 + i % 10) + ")";
                stmt.addBatch(sql); // 🔸 先添加到批次
            }
            
            stmt.executeBatch(); // 🔸 一次性执行所有SQL
            
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            DatabaseUtil.close(conn, stmt, null);
        }
        
        long endTime = System.currentTimeMillis();
        return endTime - startTime;
    }
    
    // 性能测试主方法
    public static void performanceTest() {
        int[] testSizes = {100, 500, 1000, 5000};
        
        System.out.println("性能对比测试开始...\n");
        
        for(int size : testSizes) {
            System.out.println("测试 " + size + " 条记录：");
            
            // 清空测试表
            clearTestTable();
            
            // 测试传统方式
            long traditionalTime = traditionalInsert(size);
            
            // 清空测试表  
            clearTestTable();
            
            // 测试批处理方式
            long batchTime = batchInsert(size);
            
            // 计算性能提升
            double improvement = (double)traditionalTime / batchTime;
            
            System.out.println("  传统方式：" + traditionalTime + "ms");
            System.out.println("  批处理方式：" + batchTime + "ms");
            System.out.println("  性能提升：" + String.format("%.1f", improvement) + "倍\n");
        }
    }
}
```

### 5.2 性能优化策略


**⚡ 优化技巧总结**：

```
🎯 批处理性能优化策略：

1. 合理的批次大小
   ├── 太小（<100）：优化效果不明显
   ├── 合适（500-2000）：最佳性能区间
   └── 太大（>5000）：可能内存不足

2. 配合事务使用
   ├── 关闭自动提交：conn.setAutoCommit(false)
   ├── 批量提交：conn.commit()
   └── 异常回滚：conn.rollback()

3. 选择合适的Statement类型
   ├── Statement：静态SQL批处理
   ├── PreparedStatement：参数化SQL批处理（更推荐）
   └── CallableStatement：存储过程批处理

4. 数据库优化配置
   ├── 适当的缓冲区大小
   ├── 关闭不必要的日志
   └── 优化索引策略
```

**📈 实际测试结果参考**：

| 记录数量 | **传统方式** | **批处理方式** | **性能提升** |
|----------|-------------|---------------|--------------|
| 100条 | 156ms | 23ms | **6.8倍** |
| 500条 | 782ms | 45ms | **17.4倍** |
| 1000条 | 1,564ms | 78ms | **20.1倍** |
| 5000条 | 7,832ms | 234ms | **33.5倍** |

**💡 性能优化小贴士**：
- **数据量越大，批处理优势越明显**
- **网络延迟越高，批处理效果越好**  
- **配合PreparedStatement使用效果更佳**

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 批处理本质：将多个SQL打包一次性执行，减少网络通信
🔸 核心方法：addBatch()添加、executeBatch()执行、clearBatch()清空
🔸 适用场景：大量相似SQL操作，如批量插入、更新、删除
🔸 性能优势：10-50倍性能提升，数据量越大效果越明显
🔸 异常处理：配合事务使用，处理BatchUpdateException
```

### 6.2 关键理解要点


**🔹 批处理vs传统方式**：
```
传统方式 = 一个快递一个快递地发
批处理方式 = 打包成一个大快递一起发

优势对比：
• 网络通信：从N次减少到1次
• 执行效率：数据库可以做批量优化
• 事务控制：统一管理，一致性更好
• 资源利用：减少连接和语句对象的创建开销
```

**🔹 什么时候使用批处理**：
```
✅ 适合使用：
• 批量插入数据（如导入Excel）
• 批量更新记录（如批量修改价格）
• 批量删除数据（如清理过期数据）
• 数据迁移和同步

❌ 不适合使用：
• 单条SQL执行
• 需要立即获取执行结果的情况
• SQL语句差异很大的情况
• 实时性要求很高的操作
```

**🔹 批处理最佳实践**：
```
1. 选择合适的批次大小（500-2000条）
2. 配合事务使用，保证数据一致性
3. 做好异常处理，区分不同类型的异常
4. 对于大数据量，采用分批处理策略
5. 优先使用PreparedStatement批处理
```

### 6.3 实际应用价值


**💼 实际应用场景**：
- **数据导入**：Excel文件导入到数据库
- **日志记录**：批量写入系统日志  
- **数据同步**：系统间数据批量同步
- **报表生成**：批量插入统计数据
- **数据清理**：批量删除过期数据

**🎯 学习目标检查**：

✅ **基础理解**：
- [ ] 能解释什么是批处理及其优势
- [ ] 掌握addBatch、executeBatch的使用
- [ ] 理解批处理与传统方式的区别

✅ **实践应用**：
- [ ] 能编写简单的批处理插入代码
- [ ] 能处理批处理中的异常情况
- [ ] 能选择合适的批次大小

✅ **进阶优化**：
- [ ] 能分析批处理的性能表现
- [ ] 能结合事务控制优化批处理
- [ ] 能根据业务场景选择批处理策略

**🧠 核心记忆**：
- 批处理就是"打包发货"，多个SQL一起执行
- 核心三步骤：addBatch添加 → executeBatch执行 → 处理结果
- 性能提升显著，特别适合大量数据操作
- 配合事务使用效果更好，异常处理很重要
- 选择合适批次大小，分批处理大数据量