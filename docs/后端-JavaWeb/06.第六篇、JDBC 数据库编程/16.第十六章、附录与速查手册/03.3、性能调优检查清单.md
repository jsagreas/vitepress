---
title: 3、性能调优检查清单
---
## 📚 目录

1. [性能调优基础理念](#1-性能调优基础理念)
2. [连接池配置检查](#2-连接池配置检查)
3. [SQL性能检查](#3-SQL性能检查)
4. [索引使用检查](#4-索引使用检查)
5. [事务边界检查](#5-事务边界检查)
6. [资源释放检查](#6-资源释放检查)
7. [系统监控检查](#7-系统监控检查)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 性能调优基础理念


### 1.1 什么是性能调优


**简单理解**：性能调优就像给汽车做保养一样，让你的Java程序跑得更快更稳定。

```
生活中的例子：
汽车保养 → 换机油、检查轮胎、清理积碳
程序调优 → 优化数据库连接、减少查询时间、释放资源
```

**核心目标**：
- **响应更快**：用户操作后能迅速看到结果
- **资源省**：少占用内存和CPU
- **稳定性好**：长时间运行不出问题
- **并发能力强**：多个用户同时使用不卡顿

### 1.2 性能问题常见表现


**用户感受到的问题**：
```
网页打开慢 → 可能是SQL查询慢
系统卡顿   → 可能是连接池配置不当
偶尔报错   → 可能是资源没有正确释放
高峰期崩溃 → 可能是事务处理有问题
```

### 1.3 调优检查的重要性


> ⚠️ **关键认知**：性能问题往往是积少成多的，小问题不解决就会变成大故障

**为什么要做检查清单**：
- **预防胜于治疗**：提前发现问题比事后补救容易得多
- **系统化排查**：不遗漏任何可能的问题点
- **标准化流程**：团队成员都能按统一标准检查

---

## 2. 🔗 连接池配置检查


### 2.1 连接池是什么


**生活化理解**：连接池就像停车场，数据库连接就像车位。

```
没有连接池的情况：
用户访问 → 新建数据库连接 → 使用 → 关闭连接
就像每次去商店都要重新修路一样，很浪费

有连接池的情况：
用户访问 → 从池中借用连接 → 使用 → 归还到池中
就像停车场一样，车位可以重复使用
```

### 2.2 连接池配置检查清单


**🔸 基础配置检查**

| 配置项 | **建议值** | **检查标准** | **常见问题** |
|--------|------------|------------|------------|
| `初始连接数` | `5-10` | `不能为0，不宜过大` | `初始值太大浪费资源` |
| `最大连接数` | `100-200` | `根据服务器性能调整` | `太小导致等待，太大压垮数据库` |
| `最小空闲连接` | `5` | `保证基础可用连接` | `为0会导致突发访问慢` |
| `连接超时时间` | `30秒` | `不宜过短或过长` | `太短频繁重连，太长占用资源` |

**🔧 配置示例检查**

```java
// ✅ 良好的连接池配置
HikariConfig config = new HikariConfig();
config.setInitialSize(10);           // 启动时创建10个连接
config.setMaximumPoolSize(100);      // 最多100个连接
config.setMinimumIdle(10);           // 至少保持10个空闲连接
config.setConnectionTimeout(30000);   // 30秒连接超时
config.setIdleTimeout(300000);       // 5分钟空闲超时
config.setMaxLifetime(1800000);      // 30分钟最大生存时间

// ❌ 有问题的配置
HikariConfig badConfig = new HikariConfig();
badConfig.setMaximumPoolSize(1000);  // 太大！会压垮数据库
badConfig.setConnectionTimeout(1000); // 太短！容易超时
```

### 2.3 连接池健康状态检查


**📊 监控指标检查**

```
定期检查这些数字：
活跃连接数   ← 正在使用的连接
空闲连接数   ← 可用的连接
等待连接数   ← 排队等待的请求
连接创建速度 ← 每分钟新建连接数
```

**🔍 问题判断标准**

```
🔴 严重问题：
- 等待连接数 > 10
- 连接创建速度 > 每分钟50次
- 活跃连接数 = 最大连接数（满载）

🟡 需要关注：
- 空闲连接数 = 0
- 连接超时频繁发生
- 连接池重启频率高

✅ 健康状态：
- 有足够空闲连接
- 等待时间很短
- 连接复用率高
```

---

## 3. 📊 SQL性能检查


### 3.1 什么是SQL性能问题


**通俗解释**：SQL性能问题就像在图书馆找书，方法不对就会很慢。

```
好比找书的方式：
❌ 一本本翻找 → 全表扫描（很慢）
✅ 查目录索引 → 使用索引（很快）
❌ 同时借100本书 → 查询数据太多（很慢）
✅ 只借需要的书 → 只查需要的字段（很快）
```

### 3.2 慢SQL识别检查


**🎯 慢SQL识别标准**

| SQL类型 | **响应时间标准** | **检查重点** |
|---------|-----------------|------------|
| `简单查询` | `< 100ms` | `是否使用了索引` |
| `复杂查询` | `< 500ms` | `JOIN是否合理` |
| `统计查询` | `< 2s` | `是否可以优化算法` |
| `批量操作` | `< 5s` | `是否分批处理` |

**🔍 慢SQL检查方法**

```sql
-- 1. 检查SQL执行计划
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 2. 查看慢查询日志（MySQL）
SHOW VARIABLES LIKE 'slow_query_log';
SHOW VARIABLES LIKE 'long_query_time';

-- 3. 监控正在执行的查询
SHOW PROCESSLIST;
```

### 3.3 SQL编写规范检查


**✅ 推荐的SQL写法**

```java
// 🎯 只查询需要的字段，不用 SELECT *
String goodSql = "SELECT id, name, email FROM users WHERE status = ?";

// 🎯 使用参数化查询，防止SQL注入
PreparedStatement ps = conn.prepareStatement(goodSql);
ps.setString(1, "active");

// 🎯 适当使用LIMIT限制结果数量
String limitSql = "SELECT * FROM orders ORDER BY create_time DESC LIMIT 20";
```

**❌ 需要避免的SQL写法**

```java
// ❌ 不要使用 SELECT *
String badSql1 = "SELECT * FROM users";  // 浪费网络带宽

// ❌ 不要在WHERE子句中使用函数
String badSql2 = "SELECT * FROM orders WHERE YEAR(create_time) = 2024";
// 应该改为：WHERE create_time >= '2024-01-01'

// ❌ 不要使用字符串拼接SQL
String badSql3 = "SELECT * FROM users WHERE name = '" + userName + "'";
// 有SQL注入风险
```

### 3.4 批量操作优化检查


**🚀 批量操作最佳实践**

```java
// ✅ 使用批处理而不是循环执行
public void insertUsers(List<User> users) {
    String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
    try (PreparedStatement ps = conn.prepareStatement(sql)) {
        
        // 分批处理，避免一次性处理太多数据
        int batchSize = 1000;
        int count = 0;
        
        for (User user : users) {
            ps.setString(1, user.getName());
            ps.setString(2, user.getEmail());
            ps.addBatch();
            
            if (++count % batchSize == 0) {
                ps.executeBatch();  // 每1000条执行一次
                ps.clearBatch();
            }
        }
        
        // 处理剩余的数据
        if (count % batchSize != 0) {
            ps.executeBatch();
        }
    }
}
```

---

## 4. 🗂️ 索引使用检查


### 4.1 索引是什么


**生活化解释**：索引就像书的目录，帮助快速找到内容。

```
没有索引：
查找 "张三" → 从第一页开始一页页翻 → 很慢

有索引：
查找 "张三" → 查目录得知在第50页 → 直接翻到第50页 → 很快
```

### 4.2 索引使用情况检查


**🔍 检查哪些查询需要索引**

```java
// 这些情况通常需要创建索引：

// 1. WHERE条件经常使用的字段
SELECT * FROM users WHERE email = ?        // email字段需要索引
SELECT * FROM orders WHERE user_id = ?     // user_id字段需要索引

// 2. JOIN连接条件的字段
SELECT * FROM orders o 
JOIN users u ON o.user_id = u.id          // user_id和id都需要索引

// 3. ORDER BY排序的字段
SELECT * FROM articles ORDER BY create_time DESC  // create_time需要索引
```

**📊 索引效果检查**

| 检查项目 | **检查方法** | **期望结果** |
|----------|-------------|-------------|
| `索引命中率` | `EXPLAIN查看执行计划` | `type显示ref或const` |
| `扫描行数` | `查看rows字段` | `扫描行数接近返回行数` |
| `索引选择` | `查看key字段` | `使用了合适的索引` |

### 4.3 索引创建检查清单


**🎯 索引创建原则**

```sql
-- ✅ 在经常查询的字段上创建索引
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_order_user_id ON orders(user_id);
CREATE INDEX idx_article_create_time ON articles(create_time);

-- ✅ 复合索引的顺序很重要
CREATE INDEX idx_user_status_type ON users(status, type);
-- 这个索引可以支持：
-- WHERE status = ? 
-- WHERE status = ? AND type = ?
-- 但不能很好支持：WHERE type = ?
```

**⚠️ 索引使用注意事项**

```
索引不是越多越好：
✅ 加快查询速度
❌ 占用额外存储空间  
❌ 降低插入、更新、删除速度

建议：
- 一张表的索引数量不超过5个
- 经常查询的字段才创建索引
- 定期检查未使用的索引并删除
```

---

## 5. ⚡ 事务边界检查


### 5.1 什么是事务边界


**通俗理解**：事务边界就像银行转账的开始和结束。

```
转账过程：
开始事务 → 从A账户扣钱 → 向B账户加钱 → 提交事务

如果中间出错：
开始事务 → 从A账户扣钱 → 【网络中断】 → 回滚事务
结果：A账户的钱回来了，保证了数据一致性
```

### 5.2 事务边界设置检查


**🎯 合理的事务边界**

```java
// ✅ 正确的事务边界设置
public void transferMoney(String fromAccount, String toAccount, double amount) {
    Connection conn = null;
    try {
        conn = dataSource.getConnection();
        conn.setAutoCommit(false);  // 开始事务
        
        // 业务操作1：扣款
        deductMoney(conn, fromAccount, amount);
        
        // 业务操作2：加款
        addMoney(conn, toAccount, amount);
        
        conn.commit();  // 提交事务
        
    } catch (SQLException e) {
        if (conn != null) {
            try {
                conn.rollback();  // 回滚事务
            } catch (SQLException ex) {
                logger.error("回滚失败", ex);
            }
        }
        throw new RuntimeException("转账失败", e);
    } finally {
        if (conn != null) {
            try {
                conn.setAutoCommit(true);  // 恢复自动提交
                conn.close();
            } catch (SQLException e) {
                logger.error("关闭连接失败", e);
            }
        }
    }
}
```

### 5.3 事务大小检查


**📏 事务大小控制原则**

| 事务类型 | **建议操作数量** | **超时时间** | **检查要点** |
|---------|-----------------|-------------|-------------|
| `简单事务` | `< 10条SQL` | `< 5秒` | `快进快出` |
| `批量事务` | `< 1000条记录` | `< 30秒` | `分批处理` |
| `复杂事务` | `视业务而定` | `< 60秒` | `避免长时间锁定` |

**⚠️ 事务过大的问题**

```
事务太大的问题：
🔴 锁定时间长 → 其他操作被阻塞
🔴 内存占用多 → 可能导致内存溢出  
🔴 回滚时间长 → 影响系统响应
🔴 日志量大 → 影响数据库性能

解决方案：
✅ 分批处理大量数据
✅ 避免在事务中进行耗时操作
✅ 设置合理的事务超时时间
```

### 5.4 事务隔离级别检查


**🔒 隔离级别选择指南**

```java
// 根据业务需求选择合适的隔离级别

// 读未提交（READ_UNCOMMITTED）- 很少使用
conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);

// 读已提交（READ_COMMITTED）- 常用，避免脏读
conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);

// 可重复读（REPEATABLE_READ）- MySQL默认
conn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);

// 串行化（SERIALIZABLE）- 性能最低，很少使用
conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
```

**选择建议**：
- **一般业务**：使用 `READ_COMMITTED`
- **金融业务**：使用 `REPEATABLE_READ` 
- **高并发场景**：使用 `READ_COMMITTED` + 业务层面控制

---

## 6. 🧹 资源释放检查


### 6.1 为什么要检查资源释放


**生活化理解**：资源释放就像用完水龙头要关闭，否则会浪费水。

```
程序中的"水龙头"：
数据库连接 → 不关闭会占用数据库资源
文件句柄   → 不关闭会导致文件锁定
内存对象   → 不释放会导致内存泄漏
```

### 6.2 JDBC资源释放检查清单


**📋 必须检查的资源类型**

| 资源类型 | **释放方法** | **释放顺序** | **常见问题** |
|---------|-------------|-------------|-------------|
| `ResultSet` | `rs.close()` | `最先释放` | `忘记释放导致游标泄漏` |
| `Statement` | `stmt.close()` | `其次释放` | `忘记释放导致语句缓存满` |
| `Connection` | `conn.close()` | `最后释放` | `忘记释放导致连接耗尽` |

**✅ 正确的资源释放模式**

```java
// 推荐使用 try-with-resources 自动释放资源
public List<User> getUsers() {
    String sql = "SELECT id, name, email FROM users";
    List<User> users = new ArrayList<>();
    
    // 所有资源都会自动释放
    try (Connection conn = dataSource.getConnection();
         PreparedStatement ps = conn.prepareStatement(sql);
         ResultSet rs = ps.executeQuery()) {
        
        while (rs.next()) {
            User user = new User();
            user.setId(rs.getLong("id"));
            user.setName(rs.getString("name"));
            user.setEmail(rs.getString("email"));
            users.add(user);
        }
        
    } catch (SQLException e) {
        logger.error("查询用户失败", e);
        throw new RuntimeException("查询失败", e);
    }
    
    return users;
}
```

### 6.3 资源泄漏检测


**🔍 如何检测资源泄漏**

```java
// 1. 监控连接池状态
public void checkConnectionPoolHealth() {
    HikariDataSource dataSource = (HikariDataSource) this.dataSource;
    
    System.out.println("活跃连接数: " + dataSource.getHikariPoolMXBean().getActiveConnections());
    System.out.println("空闲连接数: " + dataSource.getHikariPoolMXBean().getIdleConnections());
    System.out.println("等待连接数: " + dataSource.getHikariPoolMXBean().getThreadsAwaitingConnection());
    
    // 如果活跃连接数一直增长不下降，可能存在连接泄漏
}

// 2. 使用监控工具
// - JProfiler：查看对象数量变化
// - VisualVM：监控内存使用情况  
// - 应用性能监控（APM）工具
```

**⚠️ 资源泄漏的表现**

```
系统表现：
🔴 连接池连接数逐渐减少
🔴 应用响应越来越慢
🔴 最终出现 "获取连接超时" 错误
🔴 服务器内存使用量不断增长

排查方法：
1. 检查是否所有Connection都正确关闭
2. 检查是否所有Statement都正确关闭  
3. 检查是否所有ResultSet都正确关闭
4. 检查异常处理中是否也正确释放了资源
```

---

## 7. 📈 系统监控检查


### 7.1 监控的重要性


**为什么需要监控**：监控就像汽车的仪表盘，告诉你系统运行状况。

```
汽车仪表盘显示：
速度、油量、温度、转速...

系统监控显示：
响应时间、错误率、资源使用率、并发数...
```

### 7.2 关键监控指标


**🎯 数据库相关监控指标**

| 监控类型 | **关键指标** | **正常范围** | **告警阈值** |
|---------|-------------|-------------|-------------|
| `连接池` | `活跃连接数/最大连接数` | `< 70%` | `> 80%` |
| `查询性能` | `平均响应时间` | `< 200ms` | `> 500ms` |
| `错误率` | `SQL异常次数/总请求数` | `< 0.1%` | `> 1%` |
| `并发性` | `每秒查询数(QPS)` | `视业务而定` | `超出预期20%` |

### 7.3 监控实现方式


**📊 简单的监控实现**

```java
// 自定义监控统计
public class DatabaseMonitor {
    private static final AtomicLong totalQueries = new AtomicLong(0);
    private static final AtomicLong totalErrors = new AtomicLong(0);
    private static final AtomicLong totalTime = new AtomicLong(0);
    
    public static void recordQuery(long executeTime, boolean hasError) {
        totalQueries.incrementAndGet();
        totalTime.addAndGet(executeTime);
        
        if (hasError) {
            totalErrors.incrementAndGet();
        }
    }
    
    public static void printStatistics() {
        long queries = totalQueries.get();
        long errors = totalErrors.get();
        long avgTime = queries > 0 ? totalTime.get() / queries : 0;
        
        System.out.printf("总查询数: %d, 错误数: %d, 错误率: %.2f%%, 平均耗时: %dms%n",
            queries, errors, (errors * 100.0 / queries), avgTime);
    }
}
```

### 7.4 监控工具推荐


**🛠️ 常用监控工具**

```
开源工具：
✅ Micrometer + Prometheus + Grafana
✅ Spring Boot Actuator
✅ Druid监控

商业工具：
✅ New Relic
✅ AppDynamics  
✅ 阿里云ARMS

数据库自带工具：
✅ MySQL Performance Schema
✅ PostgreSQL pg_stat_statements
```

---

## 8. 📋 核心要点总结


### 8.1 性能调优检查要点


**🔸 连接池配置核心**
```
记住这几个关键数字：
- 初始连接数：10个左右
- 最大连接数：100-200个  
- 连接超时：30秒
- 空闲超时：5分钟
```

**🔸 SQL性能核心**
```
SQL优化三要素：
1. 只查需要的字段，避免SELECT *
2. WHERE条件使用索引字段
3. 大量数据要分页或分批处理
```

**🔸 事务管理核心**
```
事务边界原则：
- 事务要小，操作要快
- 异常时必须回滚
- 资源使用完必须释放
```

### 8.2 检查清单速查表


**⚡ 日常检查项目（✓表示正常）**

```
连接池健康检查：
□ 活跃连接数 < 最大连接数的80%
□ 等待连接数 < 10
□ 连接获取时间 < 1秒
□ 连接池重启频率正常

SQL性能检查：
□ 慢SQL数量 < 总查询的5% 
□ 平均查询时间 < 200ms
□ 使用了合适的索引
□ 没有全表扫描的查询

资源管理检查：
□ 所有Connection都正确关闭
□ 所有Statement都正确关闭
□ 所有ResultSet都正确关闭
□ 异常处理中也正确释放资源

事务管理检查：
□ 事务边界设置合理
□ 事务大小控制适当
□ 异常时能正确回滚
□ 事务隔离级别合适
```

### 8.3 问题处理优先级


**🚨 紧急问题（立即处理）**
- 连接池耗尽
- 大量慢SQL
- 严重资源泄漏
- 事务死锁

**🟡 重要问题（今日处理）**  
- 连接获取缓慢
- 偶发的SQL超时
- 轻微的资源泄漏
- 事务边界不当

**🟢 优化建议（计划处理）**
- 索引优化建议
- 配置参数调优
- 监控指标完善
- 代码规范改进

### 8.4 实际应用建议


**🎯 新手开发者建议**
1. **先保证功能正确**：让程序能跑起来
2. **再关注性能**：使用这份检查清单排查
3. **逐步优化**：一次解决一类问题
4. **持续监控**：建立长期的监控机制

**🔧 团队开发建议**
- 制定统一的编码规范
- 定期进行性能检查  
- 建立代码审查机制
- 共享性能优化经验

**核心记忆**：
- 性能调优不是一次性工作，需要持续关注
- 预防问题比解决问题更重要
- 用数据说话，不要凭感觉优化
- 小步快跑，逐步改进比大刀阔斧更安全