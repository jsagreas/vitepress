---
title: 3、依赖排除与管理
---
## 📚 目录

1. [依赖排除基础概念](#1-依赖排除基础概念)
2. [exclusions排除依赖详解](#2-exclusions排除依赖详解)
3. [可选依赖optional机制](#3-可选依赖optional机制)
4. [dependencyManagement统一管理](#4-dependencymanagement统一管理)
5. [版本统一管理策略](#5-版本统一管理策略)
6. [父子项目版本继承](#6-父子项目版本继承)
7. [依赖范围继承规则](#7-依赖范围继承规则)
8. [实战应用与最佳实践](#8-实战应用与最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 依赖排除基础概念


### 1.1 什么是依赖排除


**简单理解**：就像你买一个套餐，但不想要其中某个菜品一样

```
现实场景类比：
你点了一份"程序员套餐"，里面包含：
✅ 咖啡（你要）
✅ 键盘（你要）
❌ 鼠标（你不要，因为你有更好的）

Maven依赖也是这样：
✅ Spring框架（你要）
✅ 日志功能（你要）
❌ 自带的日志实现（你不要，你有更好的）
```

### 1.2 为什么需要依赖排除


**常见问题场景**：
- **版本冲突**：同一个jar包有多个不同版本
- **功能重复**：多个jar包提供相同功能
- **不需要的依赖**：第三方库带来了你不需要的东西
- **安全问题**：某些传递依赖有安全漏洞

### 1.3 依赖传递问题示意图


```
你的项目
    ↓ 直接依赖
Spring-web (5.3.0)
    ↓ 传递依赖
Spring-core (5.2.0)  ← 版本较旧
    ↓ 
其他依赖...

同时你还直接引入了：
Spring-core (5.3.0)  ← 版本较新

结果：版本冲突！项目可能出现奇怪问题
```

---

## 2. 🚫 exclusions排除依赖详解


### 2.1 exclusions的基本语法


**核心思想**：告诉Maven"这个依赖我要，但它带来的某些东西我不要"

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.3.0</version>
    <exclusions>
        <exclusion>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

**语法解释**：
- `<exclusions>` - 排除声明的容器
- `<exclusion>` - 具体要排除的依赖
- 只需要 `groupId` 和 `artifactId`，不需要版本号

### 2.2 常见排除场景


#### 🔸 场景1：排除冲突的日志实现


```xml
<!-- 排除Spring自带的日志，使用我们选择的logback -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.0</version>
    <exclusions>
        <exclusion>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

**为什么这样做**：
- Spring默认用`commons-logging`
- 现在更流行用`slf4j + logback`
- 同时存在会产生冲突

#### 🔸 场景2：排除不需要的传递依赖


```xml
<!-- 只要Jackson的核心功能，不要额外模块 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.0</version>
    <exclusions>
        <exclusion>
            <groupId>com.fasterxml.jackson.module</groupId>
            <artifactId>*</artifactId> <!-- * 表示排除所有 -->
        </exclusion>
    </exclusions>
</dependency>
```

### 2.3 批量排除技巧


```xml
<!-- 一次排除多个不需要的依赖 -->
<dependency>
    <groupId>org.apache.hadoop</groupId>
    <artifactId>hadoop-client</artifactId>
    <version>3.2.0</version>
    <exclusions>
        <!-- 排除slf4j相关，我们用自己的 -->
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>*</artifactId>
        </exclusion>
        <!-- 排除log4j相关 -->
        <exclusion>
            <groupId>log4j</groupId>
            <artifactId>*</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

---

## 3. ❓ 可选依赖optional机制


### 3.1 什么是可选依赖


**通俗解释**：像是"推荐配菜"，可有可无的依赖

```
餐厅点餐类比：
主菜：牛排（必须要的）
配菜：薯条（可选，optional=true）

如果你点了牛排套餐：
- 牛排一定会上
- 薯条看你需不需要，不会自动上

Maven中：
- 核心功能一定会引入
- 可选功能需要你主动声明才引入
```

### 3.2 optional标签的使用


```xml
<!-- 在提供者项目的pom.xml中声明 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
    <optional>true</optional> <!-- 标记为可选 -->
</dependency>
```

**效果说明**：
- 当前项目可以正常使用MySQL连接器
- 但其他项目依赖当前项目时，不会自动获得MySQL连接器
- 其他项目如果需要，必须自己声明

### 3.3 可选依赖的应用场景


#### 🔸 场景：数据库驱动的可选依赖


```xml
<!-- 在dao层项目中 -->
<dependencies>
    <!-- 必须的依赖 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.3.0</version>
    </dependency>
    
    <!-- 可选的数据库驱动 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.28</version>
        <optional>true</optional>
    </dependency>
    
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <version>42.3.0</version>
        <optional>true</optional>
    </dependency>
</dependencies>
```

**好处**：
- dao层不强制绑定特定数据库
- 使用者可以自由选择数据库驱动
- 避免了不必要的依赖冗余

---

## 4. 🏗️ dependencyManagement统一管理


### 4.1 什么是dependencyManagement


**形象理解**：像是"商品目录"，定义了有哪些商品和价格，但不自动购买

```
现实场景类比：
公司统一采购目录：
📋 办公用品目录（只是目录，不是实际采购）
- 笔记本电脑：联想 ThinkPad X1，¥8000
- 鼠标：罗技 MX Master，¥500
- 键盘：Cherry MX，¥800

各部门采购时：
- 只需要说"我要笔记本电脑"
- 自动按照目录价格和型号采购
- 保证全公司用的都是统一标准
```

### 4.2 dependencyManagement基本语法


```xml
<project>
    <dependencyManagement>
        <dependencies>
            <!-- 只是声明版本，不会实际引入 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>5.3.0</version>
            </dependency>
            
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>8.0.28</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
    
    <dependencies>
        <!-- 实际使用时不需要写版本号 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <!-- 版本号会自动使用上面定义的 5.3.0 -->
        </dependency>
    </dependencies>
</project>
```

### 4.3 与直接依赖的区别


| 特性 | **dependencies** | **dependencyManagement** |
|------|-----------------|---------------------------|
| **是否引入** | `立即引入到项目中` | `只声明，不引入` |
| **版本控制** | `必须指定版本` | `统一管理版本` |
| **作用范围** | `当前项目` | `当前项目及子项目` |
| **使用场景** | `实际需要的依赖` | `版本统一管理` |

### 4.4 实际应用示例


#### 🔸 父项目的dependencyManagement


```xml
<!-- 父项目 pom.xml -->
<project>
    <groupId>com.example</groupId>
    <artifactId>parent-project</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>
    
    <dependencyManagement>
        <dependencies>
            <!-- Spring框架版本统一管理 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>5.3.0</version>
            </dependency>
            
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-web</artifactId>
                <version>5.3.0</version>
            </dependency>
            
            <!-- 数据库相关 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>8.0.28</version>
            </dependency>
            
            <!-- 工具类 -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.12.0</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

#### 🔸 子项目的简化依赖声明


```xml
<!-- 子项目 pom.xml -->
<project>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>parent-project</artifactId>
        <version>1.0.0</version>
    </parent>
    
    <artifactId>web-module</artifactId>
    
    <dependencies>
        <!-- 不需要写版本号，自动使用父项目定义的版本 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
    </dependencies>
</project>
```

---

## 5. 📊 版本统一管理策略


### 5.1 版本管理的重要性


**为什么需要统一管理版本**：

```
问题场景：
项目A：使用 Spring 5.2.0
项目B：使用 Spring 5.3.0
项目C：使用 Spring 5.1.0

结果：
❌ 版本不一致，可能出现兼容性问题
❌ 维护困难，升级版本要改多个地方
❌ 团队协作混乱，每个人用的版本不同
```

### 5.2 属性变量管理版本


```xml
<project>
    <properties>
        <!-- 定义版本变量 -->
        <spring.version>5.3.0</spring.version>
        <mysql.version>8.0.28</mysql.version>
        <junit.version>5.8.0</junit.version>
        <slf4j.version>1.7.32</slf4j.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- 使用变量引用版本 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>${spring.version}</version>
            </dependency>
            
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-web</artifactId>
                <version>${spring.version}</version>
            </dependency>
            
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>${mysql.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

**好处**：
- ✅ 版本集中管理，一处修改处处生效
- ✅ 清晰明了，一眼看出使用了哪些版本
- ✅ 升级方便，改一个地方就够了

### 5.3 BOM（Bill of Materials）管理


**什么是BOM**：就像产品说明书，告诉你这个产品包含哪些组件和版本

```xml
<!-- 使用Spring Boot的BOM -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.7.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 之后使用Spring相关依赖就不需要写版本了 -->
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <!-- 版本由Spring Boot BOM管理 -->
    </dependency>
</dependencies>
```

---

## 6. 👨‍👦 父子项目版本继承


### 6.1 项目结构层次图


```
父项目 (parent-project)
├── pom.xml (打包类型：pom)
├── 子项目1 (web-module)
│   └── pom.xml
├── 子项目2 (service-module) 
│   └── pom.xml
└── 子项目3 (dao-module)
    └── pom.xml

继承关系：
父项目 → 子项目1
父项目 → 子项目2  
父项目 → 子项目3
```

### 6.2 父项目配置


```xml
<!-- 父项目 pom.xml -->
<project>
    <groupId>com.example</groupId>
    <artifactId>parent-project</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging> <!-- 重要：必须是pom -->
    
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <spring.version>5.3.0</spring.version>
    </properties>
    
    <!-- 子模块列表 -->
    <modules>
        <module>web-module</module>
        <module>service-module</module>
        <module>dao-module</module>
    </modules>
    
    <dependencyManagement>
        <dependencies>
            <!-- 版本统一管理 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>${spring.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

### 6.3 子项目配置


```xml
<!-- 子项目 pom.xml -->
<project>
    <!-- 声明父项目 -->
    <parent>
        <groupId>com.example</groupId>
        <artifactId>parent-project</artifactId>
        <version>1.0.0</version>
    </parent>
    
    <artifactId>web-module</artifactId>
    <!-- groupId和version自动继承父项目 -->
    
    <dependencies>
        <!-- 版本号自动继承 -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
    </dependencies>
</project>
```

### 6.4 继承的内容


**子项目会继承父项目的**：
- ✅ `groupId` - 组织ID
- ✅ `version` - 版本号  
- ✅ `properties` - 属性变量
- ✅ `dependencyManagement` - 依赖管理
- ✅ `pluginManagement` - 插件管理
- ✅ 构建配置

**子项目不会继承的**：
- ❌ `dependencies` - 具体依赖（这个需要子项目自己声明）
- ❌ `modules` - 模块列表

---

## 7. 📋 依赖范围继承规则


### 7.1 依赖范围回顾


| 范围 | **编译** | **测试** | **运行** | **打包** | **说明** |
|------|---------|---------|---------|---------|----------|
| `compile` | ✅ | ✅ | ✅ | ✅ | `默认范围，全过程可用` |
| `provided` | ✅ | ✅ | ❌ | ❌ | `编译和测试时用，运行时由容器提供` |
| `runtime` | ❌ | ✅ | ✅ | ✅ | `运行时需要，编译时不需要` |
| `test` | ❌ | ✅ | ❌ | ❌ | `只在测试时使用` |

### 7.2 范围继承矩阵


**当A依赖B，B依赖C时，A对C的依赖范围是什么**：

```
依赖传递范围矩阵：

        C的范围
      ↓   com  pro  run  test
A→B  com   com   -   run    -
范   pro   pro   -   pro    -
围   run   run   -   run    -
→    test  test  -   test   -

说明：
- com: compile
- pro: provided  
- run: runtime
- test: test
- "-" 表示不传递
```

### 7.3 实际应用示例


```xml
<!-- 项目A的依赖 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.3.0</version>
    <scope>compile</scope>
</dependency>

<!-- spring-web又依赖spring-context -->
<!-- 如果spring-context在spring-web中是compile范围 -->
<!-- 那么项目A也会以compile范围获得spring-context -->
```

### 7.4 范围继承的最佳实践


```xml
<!-- 在dependencyManagement中指定范围 -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
            <scope>provided</scope> <!-- Tomcat会提供 -->
        </dependency>
        
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope> <!-- 只在测试时需要 -->
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

## 8. 🛠️ 实战应用与最佳实践


### 8.1 常见问题解决方案


#### 🔸 问题1：日志框架冲突


**现象**：项目启动时出现日志相关错误

**解决方案**：
```xml
<!-- 统一排除所有commons-logging -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.0</version>
    <exclusions>
        <exclusion>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!-- 引入slf4j桥接包 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jcl-over-slf4j</artifactId>
    <version>1.7.32</version>
</dependency>
```

#### 🔸 问题2：版本冲突导致方法不存在


**现象**：`NoSuchMethodError` 或 `NoClassDefFoundError`

**解决方案**：
```xml
<!-- 使用Maven依赖分析插件 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>3.2.0</version>
    <configuration>
        <verbose>true</verbose>
    </configuration>
</plugin>
```

**命令行检查**：
```bash
# 查看依赖树
mvn dependency:tree

# 查看依赖冲突
mvn dependency:tree -Dverbose
```

### 8.2 项目结构最佳实践


```
企业级项目推荐结构：

parent-project (父项目)
├── pom.xml (版本管理中心)
├── common-module (公共模块)
├── api-module (接口定义)
├── service-module (业务逻辑)
├── web-module (Web层)
└── dao-module (数据访问层)

每个模块职责明确：
✅ 父项目：只管理版本和公共配置
✅ 公共模块：工具类和公共依赖
✅ API模块：接口定义，其他模块依赖
✅ 业务模块：具体业务实现
✅ Web模块：控制器和Web相关配置
✅ DAO模块：数据访问相关
```

### 8.3 版本管理最佳实践


```xml
<!-- 推荐的父项目pom.xml结构 -->
<project>
    <properties>
        <!-- Java版本 -->
        <java.version>11</java.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        
        <!-- 框架版本 -->
        <spring.version>5.3.0</spring.version>
        <mybatis.version>3.5.9</mybatis.version>
        
        <!-- 工具版本 -->
        <commons-lang3.version>3.12.0</commons-lang3.version>
        <jackson.version>2.13.0</jackson.version>
        
        <!-- 测试版本 -->
        <junit.version>5.8.0</junit.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
            <!-- Spring BOM，简化Spring相关依赖管理 -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-framework-bom</artifactId>
                <version>${spring.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 依赖排除：使用exclusions标签排除不需要的传递依赖
🔸 可选依赖：使用optional标记依赖为可选，不强制传递
🔸 dependencyManagement：统一管理版本，不实际引入依赖
🔸 版本继承：子项目继承父项目的版本管理配置
🔸 依赖范围：理解不同scope的传递规则
```

### 9.2 关键理解要点


**🔹 依赖排除的本质**：
```
核心思想：精确控制项目的依赖
- 要什么：明确声明需要的依赖
- 不要什么：明确排除不需要的依赖
- 为什么：避免版本冲突和功能冲突
```

**🔹 版本管理的价值**：
```
统一管理的好处：
✅ 版本一致性：整个项目使用统一版本
✅ 维护简单：升级只需要改一个地方  
✅ 避免冲突：减少版本不一致导致的问题
✅ 团队协作：确保团队成员使用相同版本
```

**🔹 项目结构的重要性**：
```
良好的项目结构：
- 职责分离：每个模块功能明确
- 依赖清晰：模块间依赖关系简单
- 易于维护：修改影响范围可控
- 便于测试：可以独立测试每个模块
```

### 9.3 实际应用价值


**日常开发中的作用**：
- **解决冲突**：当依赖版本冲突时，知道如何排除和选择
- **项目管理**：多模块项目的依赖管理更加规范
- **团队协作**：统一的依赖管理标准，减少环境问题
- **维护升级**：框架版本升级时，影响范围可控

**企业项目中的价值**：
- **标准化**：建立企业级的依赖管理规范
- **风险控制**：避免依赖冲突导致的生产问题
- **效率提升**：减少因为环境不一致导致的调试时间
- **质量保证**：统一的版本管理有助于代码质量

**核心记忆口诀**：
```
依赖管理有妙招，排除冲突是关键
版本统一很重要，父子继承要理清
可选依赖灵活用，BOM管理更轻松
项目结构要清晰，团队协作效率高
```