---
title: 3、Web项目构建部署
---
## 📚 目录

1. [WAR包构建详解](#1-WAR包构建详解)
2. [静态资源处理策略](#2-静态资源处理策略)
3. [配置文件打包管理](#3-配置文件打包管理)
4. [Tomcat部署实战](#4-Tomcat部署实战)
5. [容器部署方案](#5-容器部署方案)
6. [环境配置分离](#6-环境配置分离)
7. [生产部署流程](#7-生产部署流程)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 📦 WAR包构建详解


### 1.1 什么是WAR包

🎯 **简单理解**：WAR包就像一个"打包好的网站"

```
生活中的类比：
搬家时把所有东西装进搬家箱 → WAR包把网站所有文件打包
到了新地方直接拆箱使用 → 服务器直接部署WAR包

WAR包的作用：
- 把整个Web项目打包成一个文件
- 方便在不同服务器之间传输
- 服务器可以直接运行这个包
```

**🔸 WAR包的内部结构**
```
mywebapp.war (解压后的目录结构)
├── WEB-INF/                    ← 核心配置目录
│   ├── web.xml                ← Web应用配置文件
│   ├── classes/               ← 编译好的Java类
│   │   └── com/example/       
│   └── lib/                   ← 项目依赖的JAR包
│       ├── mysql-connector.jar
│       └── gson.jar
├── index.html                 ← 网站首页
├── css/                       ← 样式文件
│   └── style.css
├── js/                        ← JavaScript文件
│   └── app.js
└── images/                    ← 图片资源
    └── logo.png
```

### 1.2 Maven WAR包构建配置

**🔧 配置Maven项目打包方式**

```xml
<!-- pom.xml 基础配置 -->
<project>
    <groupId>com.example</groupId>
    <artifactId>my-web-app</artifactId>
    <version>1.0.0</version>
    <packaging>war</packaging>  <!-- 指定打包类型为WAR -->
    
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    
    <dependencies>
        <!-- Servlet API -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
            <scope>provided</scope>  <!-- 运行时由Tomcat提供 -->
        </dependency>
        
        <!-- JSP API -->
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.2</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>
```

**🛠️ WAR包构建插件配置**
```xml
<build>
    <finalName>mywebapp</finalName>  <!-- WAR包最终名称 -->
    
    <plugins>
        <!-- Maven WAR Plugin -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.3.1</version>
            <configuration>
                <!-- 跳过web.xml检查（Spring Boot等场景） -->
                <failOnMissingWebXml>false</failOnMissingWebXml>
                
                <!-- 指定Web资源目录 -->
                <webResources>
                    <resource>
                        <directory>src/main/webapp</directory>
                    </resource>
                </webResources>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### 1.3 WAR包构建实践

**📋 构建步骤详解**

```bash
# 1. 清理之前的构建结果
mvn clean
# 删除target目录，确保构建环境干净

# 2. 编译项目代码
mvn compile
# 编译src/main/java下的Java代码到target/classes

# 3. 运行测试（可选）
mvn test
# 运行src/test/java下的测试代码

# 4. 打包成WAR
mvn package
# 在target目录生成WAR文件

# 5. 一键构建（推荐）
mvn clean package -DskipTests
# 清理+编译+打包，跳过测试加快速度
```

**💡 构建过程详细说明**
```
Maven构建过程：
第1步：validate  → 验证项目结构
第2步：compile   → 编译源代码
第3步：test      → 运行单元测试
第4步：package   → 打包成WAR文件
第5步：verify    → 验证包的完整性
第6步：install   → 安装到本地仓库

常用构建命令：
mvn clean package          → 标准构建
mvn clean package -U       → 强制更新依赖
mvn clean package -Dmaven.test.skip=true  → 跳过测试
```

---

## 2. 🎨 静态资源处理策略


### 2.1 静态资源的概念和分类

**📂 什么是静态资源**

```
静态资源就是"不会变化的文件"：

网页静态资源分类：
🔸 HTML文件：网页结构文件
🔸 CSS文件：样式表文件  
🔸 JavaScript文件：前端脚本
🔸 图片文件：jpg、png、gif、svg等
🔸 字体文件：ttf、woff、woff2等
🔸 视频/音频：mp4、mp3等多媒体文件

为什么要特别处理静态资源？
- 这些文件不需要服务器动态生成
- 可以通过缓存提高访问速度
- 可以使用CDN加速分发
```

### 2.2 Maven项目中的静态资源组织

**🗂️ 标准的资源目录结构**

```
src/main/webapp/              ← Web资源根目录
├── index.html               ← 首页文件
├── WEB-INF/                 ← 受保护的配置目录
│   └── web.xml              
├── static/                  ← 静态资源目录（推荐）
│   ├── css/                 
│   │   ├── bootstrap.min.css
│   │   └── app.css          
│   ├── js/                  
│   │   ├── jquery.min.js    
│   │   └── app.js           
│   ├── images/              
│   │   ├── logo.png         
│   │   └── banner.jpg       
│   └── fonts/               
│       └── arial.ttf        
└── uploads/                 ← 用户上传文件目录
    └── avatar/              
```

**💡 静态资源访问路径规则**
```
URL路径映射关系：

文件位置：src/main/webapp/static/css/app.css
访问URL：http://localhost:8080/mywebapp/static/css/app.css

文件位置：src/main/webapp/images/logo.png  
访问URL：http://localhost:8080/mywebapp/images/logo.png

关键理解：
- webapp目录对应网站根路径
- 用户可以直接通过URL访问这些文件
- WEB-INF目录下的文件用户无法直接访问（安全保护）
```

### 2.3 静态资源打包配置

**⚙️ Maven WAR插件的资源处理**

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>3.3.1</version>
    <configuration>
        <webResources>
            <!-- 包含额外的静态资源 -->
            <resource>
                <directory>src/main/resources/static</directory>
                <targetPath>static</targetPath>
                <!-- 把resources/static下的文件复制到WAR的static目录 -->
            </resource>
            
            <!-- 排除不需要的文件 -->
            <resource>
                <directory>src/main/webapp</directory>
                <excludes>
                    <exclude>**/*.psd</exclude>     <!-- 排除PS设计文件 -->
                    <exclude>**/*.sketch</exclude>  <!-- 排除设计稿 -->
                    <exclude>**/node_modules/**</exclude> <!-- 排除Node模块 -->
                </excludes>
            </resource>
        </webResources>
    </configuration>
</plugin>
```

### 2.4 静态资源优化策略

**🚀 提升静态资源加载性能**

**资源压缩配置**
```xml
<!-- 使用minify插件压缩CSS/JS -->
<plugin>
    <groupId>com.samaxes.maven</groupId>
    <artifactId>minify-maven-plugin</artifactId>
    <version>1.7.6</version>
    <executions>
        <execution>
            <goals>
                <goal>minify</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <webappSourceDir>${project.basedir}/src/main/webapp</webappSourceDir>
        <webappTargetDir>${project.build.directory}/${project.build.finalName}</webappTargetDir>
        
        <!-- CSS压缩配置 -->
        <cssSourceDir>static/css</cssSourceDir>
        <cssTargetDir>static/css</cssTargetDir>
        <cssSourceFiles>
            <cssSourceFile>app.css</cssSourceFile>
        </cssSourceFiles>
        <cssFinalFile>app.min.css</cssFinalFile>
        
        <!-- JS压缩配置 -->
        <jsSourceDir>static/js</jsSourceDir>
        <jsTargetDir>static/js</jsTargetDir>
        <jsSourceFiles>
            <jsSourceFile>app.js</jsSourceFile>
        </jsSourceFiles>
        <jsFinalFile>app.min.js</jsFinalFile>
    </configuration>
</plugin>
```

**📊 资源加载优化技巧**

| 优化方式 | **实现方法** | **效果** | **适用场景** |
|---------|-------------|---------|-------------|
| 🔸 **文件压缩** | `Gzip压缩` | `减少70%体积` | `所有文本资源` |
| 🔸 **文件合并** | `合并CSS/JS` | `减少HTTP请求` | `多个小文件` |
| 🔸 **图片优化** | `WebP格式` | `减少30%体积` | `图片密集应用` |
| 🔸 **缓存设置** | `HTTP缓存头` | `避免重复下载` | `不经常变化的资源` |

---

## 3. ⚙️ 配置文件打包管理


### 3.1 配置文件的分类和作用

**📄 JavaWeb项目中的配置文件**

```
配置文件分类及用途：

🔸 Web应用配置
   web.xml → Servlet、Filter、监听器配置

🔸 Spring框架配置  
   applicationContext.xml → Bean定义、依赖注入
   spring-mvc.xml → MVC组件配置

🔸 数据库连接配置
   database.properties → 数据库连接参数
   mybatis-config.xml → MyBatis配置

🔸 日志配置
   log4j.properties → 日志级别、输出方式
   logback.xml → Logback日志配置

🔸 应用自定义配置
   app.properties → 业务参数配置
```

### 3.2 配置文件的标准位置

**📍 Maven项目配置文件目录规范**

```
src/main/resources/           ← 配置文件标准位置
├── META-INF/
├── spring/                   ← Spring配置文件目录
│   ├── applicationContext.xml
│   └── spring-mvc.xml
├── mybatis/                  ← MyBatis配置目录
│   ├── mybatis-config.xml
│   └── mapper/
│       └── UserMapper.xml
├── config/                   ← 自定义配置目录
│   ├── database.properties
│   └── app.properties
├── log4j.properties          ← 日志配置
└── static/                   ← 静态资源（可选位置）

src/main/webapp/WEB-INF/      ← Web配置文件位置
├── web.xml                   ← Web应用描述符
├── classes/                  ← 编译后的类文件
└── lib/                      ← 依赖JAR包
```

### 3.3 配置文件打包规则

**🔧 Maven资源处理机制**

```xml
<!-- Maven Resources Plugin配置 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-resources-plugin</artifactId>
    <version>3.3.0</version>
    <configuration>
        <encoding>UTF-8</encoding>
        
        <!-- 资源过滤配置 -->
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>  <!-- 启用属性替换 -->
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
            </resource>
            
            <resource>
                <directory>src/main/resources</directory>
                <filtering>false</filtering> <!-- 二进制文件不过滤 -->
                <excludes>
                    <exclude>**/*.properties</exclude>
                    <exclude>**/*.xml</exclude>
                </excludes>
            </resource>
        </resources>
    </configuration>
</plugin>
```

**💡 配置文件处理详解**
```
资源处理过程：

第1步：Maven读取src/main/resources下的所有文件
第2步：如果启用了filtering，会替换${}占位符
第3步：将处理后的文件复制到target/classes目录  
第4步：打包时，target/classes下的文件会放入WAR包的WEB-INF/classes目录

示例占位符替换：
database.properties内容：
db.url=jdbc:mysql://localhost:3306/${db.name}

pom.xml中定义：
<properties>
    <db.name>testdb</db.name>
</properties>

最终生成的文件内容：
db.url=jdbc:mysql://localhost:3306/testdb
```

### 3.4 多环境配置管理

**🌍 Profile配置实现环境分离**

```xml
<!-- pom.xml中的Profile配置 -->
<profiles>
    <!-- 开发环境 -->
    <profile>
        <id>dev</id>
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
        <properties>
            <db.url>jdbc:mysql://localhost:3306/devdb</db.url>
            <db.username>devuser</db.username>
            <db.password>devpass</db.password>
            <log.level>DEBUG</log.level>
        </properties>
    </profile>
    
    <!-- 测试环境 -->
    <profile>
        <id>test</id>
        <properties>
            <db.url>jdbc:mysql://testserver:3306/testdb</db.url>
            <db.username>testuser</db.username>
            <db.password>testpass</db.password>
            <log.level>INFO</log.level>
        </properties>
    </profile>
    
    <!-- 生产环境 -->
    <profile>
        <id>prod</id>
        <properties>
            <db.url>jdbc:mysql://prodserver:3306/proddb</db.url>
            <db.username>produser</db.username>
            <db.password>prodpass</db.password>
            <log.level>WARN</log.level>
        </properties>
    </profile>
</profiles>
```

**🚀 使用Profile构建不同环境的包**
```bash
# 构建开发环境WAR包
mvn clean package -Pdev

# 构建测试环境WAR包  
mvn clean package -Ptest

# 构建生产环境WAR包
mvn clean package -Pprod

# 同时激活多个Profile
mvn clean package -Ptest,mysql
```

---

## 4. 🚀 Tomcat部署实战


### 4.1 Tomcat部署方式概览

**🎯 三种主要部署方式**

```
Tomcat部署方式对比：

🔸 WAR包自动部署（推荐新手）
   - 复制WAR包到webapps目录
   - Tomcat自动解压并部署
   - 简单易用，适合开发测试

🔸 目录部署
   - 直接放置解压后的项目目录
   - 适合开发调试
   - 可以实时修改文件

🔸 Context配置部署
   - 通过server.xml或context.xml配置
   - 可以自定义部署路径
   - 适合复杂部署需求
```

### 4.2 WAR包自动部署详解

**📦 最常用的部署方式**

```bash
# 部署步骤详解

# 1. 停止Tomcat服务
./shutdown.sh  # Linux/Mac
shutdown.bat   # Windows

# 2. 清理旧的部署文件（如果存在）
rm -rf $TOMCAT_HOME/webapps/mywebapp*
# 删除旧的WAR包和解压目录

# 3. 复制新的WAR包
cp mywebapp.war $TOMCAT_HOME/webapps/
# WAR包名决定了访问路径

# 4. 启动Tomcat
./startup.sh   # Linux/Mac  
startup.bat    # Windows

# 5. 检查部署状态
tail -f $TOMCAT_HOME/logs/catalina.out
# 查看启动日志，确认部署成功
```

**💡 部署路径规则说明**
```
WAR包名与访问路径的关系：

WAR包名：mywebapp.war  
访问路径：http://localhost:8080/mywebapp/

WAR包名：ROOT.war      
访问路径：http://localhost:8080/
（ROOT.war会部署为根应用）

WAR包名：api-v1.war    
访问路径：http://localhost:8080/api-v1/

特殊情况：
如果WAR包名包含特殊字符，Tomcat会进行编码处理
```

### 4.3 Tomcat配置优化

**⚙️ 提升Tomcat运行性能**

**JVM参数优化**
```bash
# 设置Tomcat启动参数（在catalina.sh或setenv.sh中）
export JAVA_OPTS="$JAVA_OPTS \
    -server \                          # 使用服务器模式
    -Xms1024m \                        # 最小堆内存
    -Xmx2048m \                        # 最大堆内存
    -XX:MetaspaceSize=256m \           # Metaspace初始大小
    -XX:MaxMetaspaceSize=512m \        # Metaspace最大大小
    -XX:+UseG1GC \                     # 使用G1垃圾收集器
    -Djava.awt.headless=true \         # 无GUI模式
    -Dfile.encoding=UTF-8"             # 文件编码
```

**Tomcat连接器配置**
```xml
<!-- server.xml中的Connector配置 -->
<Connector port="8080" 
           protocol="HTTP/1.1"
           connectionTimeout="20000"     <!-- 连接超时时间 -->
           maxThreads="200"             <!-- 最大线程数 -->
           minSpareThreads="10"         <!-- 最小空闲线程 -->
           maxSpareThreads="50"         <!-- 最大空闲线程 -->
           acceptCount="100"            <!-- 请求队列长度 -->
           redirectPort="8443"
           compression="on"             <!-- 启用Gzip压缩 -->
           compressionMinSize="2048"    <!-- 压缩阈值 -->
           noCompressionUserAgents="gozilla, traviata" 
           compressableMimeType="text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json"/>
```

### 4.4 部署问题排查

**🔍 常见部署问题及解决方案**

**问题排查清单**
```
部署失败常见原因：

✅ 检查项目                    ❌ 常见问题
□ WAR包是否完整               → 构建失败，WAR包损坏
□ Tomcat版本是否兼容          → JDK版本不匹配  
□ 端口是否被占用              → 8080端口冲突
□ 内存是否足够                → OutOfMemoryError
□ 权限是否正确                → 文件访问权限问题
□ 数据库连接是否正常          → 数据源配置错误
□ 依赖JAR包是否冲突           → ClassNotFoundException
```

**日志分析技巧**
```bash
# 实时查看Tomcat启动日志
tail -f $TOMCAT_HOME/logs/catalina.out

# 查看特定应用的日志
tail -f $TOMCAT_HOME/logs/localhost.2024-01-11.log

# 搜索错误信息
grep -i "error\|exception" $TOMCAT_HOME/logs/catalina.out

# 查看端口占用情况
netstat -an | grep 8080
lsof -i :8080
```

---

## 5. 🐳 容器部署方案


### 5.1 Docker容器化部署概念

**🎯 为什么要用Docker部署JavaWeb项目**

```
传统部署 vs Docker部署：

传统部署的问题：
- 环境不一致："在我机器上能跑"
- 依赖复杂：需要手动安装JDK、Tomcat
- 扩展困难：增加服务器需要重新配置环境
- 版本管理：多版本共存困难

Docker部署的优势：
- 环境一致性：开发、测试、生产环境完全一致
- 快速部署：一键启动，秒级扩容
- 资源隔离：应用之间互不影响
- 易于管理：统一的管理方式
```

### 5.2 Dockerfile编写实战

**🔧 为JavaWeb项目创建Docker镜像**

```dockerfile
# Dockerfile 完整示例
FROM openjdk:8-jdk-alpine

# 维护者信息
LABEL maintainer="developer@example.com"
LABEL description="My Java Web Application"

# 设置工作目录
WORKDIR /app

# 安装Tomcat
ENV TOMCAT_VERSION 9.0.71
RUN wget https://archive.apache.org/dist/tomcat/tomcat-9/v${TOMCAT_VERSION}/bin/apache-tomcat-${TOMCAT_VERSION}.tar.gz \
    && tar -xzf apache-tomcat-${TOMCAT_VERSION}.tar.gz \
    && mv apache-tomcat-${TOMCAT_VERSION} tomcat \
    && rm apache-tomcat-${TOMCAT_VERSION}.tar.gz

# 设置环境变量
ENV CATALINA_HOME /app/tomcat
ENV PATH $CATALINA_HOME/bin:$PATH

# 复制WAR包到Tomcat
COPY target/mywebapp.war $CATALINA_HOME/webapps/

# 复制自定义配置文件
COPY docker/server.xml $CATALINA_HOME/conf/
COPY docker/context.xml $CATALINA_HOME/conf/

# 创建日志目录并设置权限
RUN mkdir -p /app/logs \
    && chmod +x $CATALINA_HOME/bin/*.sh

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:8080/mywebapp/health || exit 1

# 启动命令
CMD ["catalina.sh", "run"]
```

**🚀 多阶段构建优化**
```dockerfile
# 多阶段构建：减小镜像体积
# 第一阶段：构建应用
FROM maven:3.8-openjdk-8 AS builder

WORKDIR /build
COPY pom.xml .
COPY src ./src

# 下载依赖并构建
RUN mvn clean package -DskipTests

# 第二阶段：运行环境
FROM tomcat:9.0-jdk8-alpine

# 删除Tomcat默认应用
RUN rm -rf /usr/local/tomcat/webapps/*

# 从构建阶段复制WAR包
COPY --from=builder /build/target/mywebapp.war /usr/local/tomcat/webapps/ROOT.war

# 复制配置文件
COPY docker/server.xml /usr/local/tomcat/conf/

EXPOSE 8080
CMD ["catalina.sh", "run"]
```

### 5.3 Docker Compose编排

**🎼 多服务协同部署**

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Web应用服务
  webapp:
    build: .
    container_name: mywebapp
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_NAME=webapp_db
      - DB_USER=webuser
      - DB_PASSWORD=webpass
    depends_on:
      - mysql
      - redis
    volumes:
      - ./logs:/app/logs
      - ./uploads:/app/uploads
    networks:
      - webapp-network
    restart: unless-stopped

  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: webapp-mysql
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: webapp_db
      MYSQL_USER: webuser
      MYSQL_PASSWORD: webpass
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - webapp-network
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: webapp-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - webapp-network
    restart: unless-stopped

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: webapp-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - webapp
    networks:
      - webapp-network
    restart: unless-stopped

volumes:
  mysql-data:
  redis-data:

networks:
  webapp-network:
    driver: bridge
```

**💡 Docker Compose常用命令**
```bash
# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看服务日志
docker-compose logs webapp
docker-compose logs -f mysql  # 实时查看

# 重启服务
docker-compose restart webapp

# 更新服务（重新构建镜像）
docker-compose up --build webapp

# 停止并删除所有容器
docker-compose down

# 停止并删除容器、网络、卷
docker-compose down -v
```

---

## 6. 🔧 环境配置分离


### 6.1 为什么需要环境配置分离

**🎯 多环境管理的重要性**

```
环境配置分离的核心价值：

🔸 避免配置混乱
   开发环境：连接本地数据库，debug日志
   测试环境：连接测试数据库，info日志  
   生产环境：连接生产数据库，error日志

🔸 提高安全性
   生产环境的数据库密码不应该出现在代码中
   不同环境的API密钥应该分开管理

🔸 便于维护
   修改某个环境配置不影响其他环境
   新增环境只需添加对应配置文件
```

### 6.2 Spring Profile实现环境分离

**🌱 Spring框架的环境管理机制**

**配置文件命名规则**
```
src/main/resources/
├── application.properties              ← 公共配置
├── application-dev.properties         ← 开发环境配置
├── application-test.properties        ← 测试环境配置  
├── application-prod.properties        ← 生产环境配置
└── application-local.properties       ← 本地开发配置
```

**环境配置示例**
```properties
# application.properties（公共配置）
app.name=MyWebApp
app.version=1.0.0
server.servlet.context-path=/mywebapp

# logging
logging.pattern.console=%d{HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# application-dev.properties（开发环境）
# 数据库配置
spring.datasource.url=jdbc:mysql://localhost:3306/webapp_dev
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 日志级别
logging.level.root=DEBUG
logging.level.com.example.myapp=DEBUG
logging.file.name=logs/webapp-dev.log

# 其他配置
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

# application-prod.properties（生产环境）
# 数据库配置（使用环境变量）
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 连接池配置
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5

# 日志级别
logging.level.root=WARN
logging.level.com.example.myapp=INFO
logging.file.name=/var/log/webapp/webapp.log

# 安全配置
spring.jpa.show-sql=false
spring.jpa.hibernate.ddl-auto=none
```

### 6.3 外部化配置管理

**📋 生产环境配置外部化**

**使用环境变量**
```bash
# 生产环境启动脚本 startup.sh
#!/bin/bash

# 设置环境变量
export SPRING_PROFILES_ACTIVE=prod
export DB_URL="jdbc:mysql://prod-db-server:3306/webapp_prod"
export DB_USERNAME="webapp_user"
export DB_PASSWORD="your_secure_password"
export REDIS_HOST="prod-redis-server"
export REDIS_PORT="6379"

# JVM参数
export JAVA_OPTS="-server -Xms1024m -Xmx2048m -Dspring.profiles.active=prod"

# 启动Tomcat
$CATALINA_HOME/bin/catalina.sh run
```

**配置中心方案**
```java
// 使用Apollo配置中心示例
@Component
public class ConfigService {
    
    @ApolloConfig
    private Config config;
    
    @ApolloConfigChangeListener
    public void onChange(ConfigChangeEvent changeEvent) {
        // 配置变更时的处理逻辑
        for (String key : changeEvent.changedKeys()) {
            ConfigChange change = changeEvent.getChange(key);
            System.out.printf("配置变更: %s, 旧值: %s, 新值: %s%n", 
                key, change.getOldValue(), change.getNewValue());
        }
    }
    
    public String getDatabaseUrl() {
        return config.getProperty("database.url", "default_url");
    }
}
```

### 6.4 Docker环境变量配置

**🐳 容器化环境的配置管理**

```dockerfile
# Dockerfile中设置默认环境变量
ENV SPRING_PROFILES_ACTIVE=prod
ENV DB_HOST=localhost
ENV DB_PORT=3306
ENV DB_NAME=webapp_db

# 支持运行时覆盖
ENTRYPOINT ["java", "-jar", "-Dspring.profiles.active=${SPRING_PROFILES_ACTIVE}", "app.jar"]
```

```yaml
# docker-compose.yml环境配置
version: '3.8'
services:
  webapp:
    build: .
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_NAME=webapp_db
      - DB_USERNAME=webapp_user
      - DB_PASSWORD=webapp_pass
    env_file:
      - .env.prod  # 从文件加载环境变量
```

---

## 7. 🚀 生产部署流程


### 7.1 生产部署前准备清单

**📋 部署前必检项目**

```
部署准备检查清单：

🔸 代码质量检查
□ 代码review通过
□ 单元测试覆盖率达标  
□ 集成测试通过
□ 静态代码分析通过
□ 安全漏洞扫描通过

🔸 环境准备检查
□ 生产环境配置确认
□ 数据库连接测试
□ 缓存服务可用性
□ 外部API接口测试
□ 服务器资源充足

🔸 部署包准备
□ WAR包构建成功
□ 配置文件正确替换
□ 静态资源完整
□ 版本号标记清晰
□ 部署脚本测试通过

🔸 回滚预案准备
□ 当前版本备份
□ 数据库备份完成
□ 回滚脚本准备
□ 回滚测试通过
```

### 7.2 零停机部署策略

**⚡ 蓝绿部署实现**

```bash
#!/bin/bash
# 蓝绿部署脚本 blue-green-deploy.sh

BLUE_PORT=8080
GREEN_PORT=8081
NGINX_UPSTREAM_FILE="/etc/nginx/conf.d/upstream.conf"
NEW_WAR_FILE="mywebapp-new.war"

# 检查当前活跃环境
check_active_env() {
    if curl -f http://localhost:$BLUE_PORT/health >/dev/null 2>&1; then
        echo "当前活跃环境: BLUE (端口 $BLUE_PORT)"
        ACTIVE_PORT=$BLUE_PORT
        STANDBY_PORT=$GREEN_PORT
        ACTIVE_ENV="BLUE"
        STANDBY_ENV="GREEN"
    else
        echo "当前活跃环境: GREEN (端口 $GREEN_PORT)"  
        ACTIVE_PORT=$GREEN_PORT
        STANDBY_PORT=$BLUE_PORT
        ACTIVE_ENV="GREEN"
        STANDBY_ENV="BLUE"
    fi
}

# 部署到备用环境
deploy_to_standby() {
    echo "正在部署到 $STANDBY_ENV 环境 (端口 $STANDBY_PORT)..."
    
    # 停止备用环境的Tomcat
    pkill -f "tomcat.*$STANDBY_PORT" || true
    
    # 部署新版本
    cp $NEW_WAR_FILE /opt/tomcat-$STANDBY_ENV/webapps/ROOT.war
    
    # 启动备用环境
    CATALINA_BASE=/opt/tomcat-$STANDBY_ENV \
    CATALINA_HOME=/opt/tomcat \
    /opt/tomcat/bin/startup.sh
    
    # 等待服务启动
    echo "等待 $STANDBY_ENV 环境启动..."
    for i in {1..30}; do
        if curl -f http://localhost:$STANDBY_PORT/health >/dev/null 2>&1; then
            echo "$STANDBY_ENV 环境启动成功！"
            return 0
        fi
        sleep 2
    done
    
    echo "错误：$STANDBY_ENV 环境启动失败！"
    return 1
}

# 切换流量
switch_traffic() {
    echo "将流量切换到 $STANDBY_ENV 环境..."
    
    # 更新Nginx upstream配置
    cat > $NGINX_UPSTREAM_FILE << EOF
upstream webapp {
    server localhost:$STANDBY_PORT;
}
EOF
    
    # 重新加载Nginx配置
    nginx -s reload
    
    echo "流量已切换到 $STANDBY_ENV 环境 (端口 $STANDBY_PORT)"
}

# 健康检查
health_check() {
    echo "执行健康检查..."
    
    # 检查HTTP响应
    if ! curl -f http://localhost/health >/dev/null 2>&1; then
        echo "健康检查失败！开始回滚..."
        rollback
        return 1
    fi
    
    # 检查数据库连接
    if ! curl -f http://localhost/api/db-health >/dev/null 2>&1; then
        echo "数据库连接检查失败！开始回滚..."
        rollback
        return 1
    fi
    
    echo "健康检查通过！"
    return 0
}

# 回滚操作
rollback() {
    echo "正在回滚到 $ACTIVE_ENV 环境..."
    
    # 恢复原来的upstream配置
    cat > $NGINX_UPSTREAM_FILE << EOF
upstream webapp {
    server localhost:$ACTIVE_PORT;
}
EOF
    
    nginx -s reload
    echo "回滚完成！"
}

# 清理旧环境
cleanup() {
    echo "清理原 $ACTIVE_ENV 环境..."
    pkill -f "tomcat.*$ACTIVE_PORT" || true
    echo "清理完成！"
}

# 主部署流程
main() {
    echo "开始蓝绿部署流程..."
    
    check_active_env
    
    if deploy_to_standby && health_check; then
        switch_traffic
        sleep 10  # 等待流量完全切换
        
        if health_check; then
            cleanup
            echo "✅ 部署成功完成！"
        else
            rollback
            echo "❌ 部署失败，已回滚！"
            exit 1
        fi
    else
        echo "❌ 部署到备用环境失败！"
        exit 1
    fi
}

main "$@"
```

### 7.3 滚动更新部署

**🔄 渐进式更新策略**

```bash
#!/bin/bash
# 滚动更新部署脚本 rolling-update.sh

SERVERS=(
    "web01.example.com"
    "web02.example.com" 
    "web03.example.com"
)
NEW_WAR="mywebapp-v2.0.war"
HEALTH_CHECK_URL="/health"

# 更新单个服务器
update_server() {
    local server=$1
    echo "正在更新服务器: $server"
    
    # 从负载均衡器移除
    echo "从负载均衡器移除 $server"
    curl -X POST "http://lb.example.com/api/servers/$server/disable"
    
    # 等待现有连接结束
    echo "等待现有连接结束..."
    sleep 30
    
    # 停止应用
    echo "停止 $server 上的应用"
    ssh $server "sudo systemctl stop tomcat"
    
    # 备份当前版本
    echo "备份当前版本"
    ssh $server "sudo cp /opt/tomcat/webapps/ROOT.war /backup/ROOT.war.backup.$(date +%Y%m%d%H%M)"
    
    # 部署新版本
    echo "部署新版本到 $server"
    scp $NEW_WAR $server:/tmp/
    ssh $server "sudo mv /tmp/$NEW_WAR /opt/tomcat/webapps/ROOT.war"
    
    # 启动应用
    echo "启动 $server 上的应用"
    ssh $server "sudo systemctl start tomcat"
    
    # 健康检查
    echo "执行健康检查..."
    for i in {1..20}; do
        if curl -f "http://$server:8080$HEALTH_CHECK_URL" >/dev/null 2>&1; then
            echo "✅ $server 健康检查通过"
            
            # 重新加入负载均衡器
            echo "将 $server 重新加入负载均衡器"
            curl -X POST "http://lb.example.com/api/servers/$server/enable"
            return 0
        fi
        echo "等待应用启动... ($i/20)"
        sleep 10
    done
    
    # 健康检查失败，回滚
    echo "❌ $server 健康检查失败，开始回滚"
    ssh $server "sudo systemctl stop tomcat"
    ssh $server "sudo mv /backup/ROOT.war.backup.$(date +%Y%m%d%H%M) /opt/tomcat/webapps/ROOT.war"
    ssh $server "sudo systemctl start tomcat"
    
    # 等待回滚完成后重新加入
    sleep 20
    curl -X POST "http://lb.example.com/api/servers/$server/enable"
    return 1
}

# 主更新流程
main() {
    echo "开始滚动更新部署..."
    
    local failed_servers=()
    
    for server in "${SERVERS[@]}"; do
        if ! update_server $server; then
            failed_servers+=($server)
        fi
        
        # 服务器间更新间隔
        echo "等待5分钟后更新下一台服务器..."
        sleep 300
    done
    
    # 报告结果
    if [ ${#failed_servers[@]} -eq 0 ]; then
        echo "✅ 所有服务器更新成功！"
    else
        echo "❌ 以下服务器更新失败: ${failed_servers[*]}"
        echo "请手动检查这些服务器的状态"
        exit 1
    fi
}

main "$@"
```

### 7.4 部署监控与告警

**📊 部署过程监控**

```bash
#!/bin/bash
# 部署监控脚本 deployment-monitor.sh

WEBHOOK_URL="https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
EMAIL_LIST="ops@example.com,dev@example.com"
APP_NAME="MyWebApp"

# 发送Slack通知
send_slack_notification() {
    local message=$1
    local color=$2
    
    curl -X POST -H 'Content-type: application/json' \
        --data "{
            \"attachments\": [{
                \"color\": \"$color\",
                \"title\": \"$APP_NAME 部署通知\",
                \"text\": \"$message\",
                \"ts\": $(date +%s)
            }]
        }" $WEBHOOK_URL
}

# 发送邮件通知
send_email_notification() {
    local subject=$1
    local message=$2
    
    echo "$message" | mail -s "$subject" $EMAIL_LIST
}

# 部署开始通知
notify_deployment_start() {
    local version=$1
    local message="🚀 开始部署 $APP_NAME v$version"
    
    send_slack_notification "$message" "warning"
    send_email_notification "$APP_NAME 部署开始" "$message"
}

# 部署成功通知
notify_deployment_success() {
    local version=$1
    local duration=$2
    local message="✅ $APP_NAME v$version 部署成功完成！耗时: ${duration}秒"
    
    send_slack_notification "$message" "good"
    send_email_notification "$APP_NAME 部署成功" "$message"
}

# 部署失败通知
notify_deployment_failure() {
    local version=$1
    local error=$2
    local message="❌ $APP_NAME v$version 部署失败！错误: $error"
    
    send_slack_notification "$message" "danger"
    send_email_notification "$APP_NAME 部署失败 - 需要立即处理" "$message"
}

# 部署性能监控
monitor_deployment_performance() {
    local start_time=$1
    local end_time=$2
    local version=$3
    
    local duration=$((end_time - start_time))
    
    # 记录部署指标
    echo "$(date '+%Y-%m-%d %H:%M:%S'),$version,$duration,success" >> /var/log/deployment-metrics.csv
    
    # 如果部署时间过长，发送警告
    if [ $duration -gt 600 ]; then
        local warning="⚠️ $APP_NAME v$version 部署时间过长: ${duration}秒"
        send_slack_notification "$warning" "warning"
    fi
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 WAR包构建：Maven项目打包的标准方式，包含所有Web资源
🔸 静态资源处理：CSS、JS、图片等文件的组织和优化策略
🔸 配置文件管理：多环境配置分离和外部化配置方案
🔸 Tomcat部署：WAR包部署、配置优化和问题排查
🔸 容器化部署：Docker镜像构建和容器编排
🔸 环境分离：开发、测试、生产环境的差异化管理
🔸 生产部署：零停机部署和监控告警机制
```

### 8.2 关键理解要点


**🔹 WAR包的本质和价值**
```
本质理解：
- WAR包是Web项目的标准打包格式
- 包含了运行Web应用所需的所有文件
- 提供了跨平台的部署标准

实际价值：
- 简化部署流程：一个文件包含一切
- 环境一致性：相同WAR包在不同环境表现一致
- 版本管理：便于版本控制和回滚
```

**🔹 静态资源优化的重要性**
```
性能影响：
- 静态资源通常占网页内容的70-80%
- 优化静态资源可显著提升用户体验
- 合理的缓存策略减少服务器压力

优化策略：
- 文件压缩：减少传输体积
- 合并文件：减少HTTP请求数
- CDN分发：就近访问提升速度
- 缓存设置：避免重复下载
```

**🔹 多环境配置的管理策略**
```
分离原则：
- 配置与代码分离：敏感信息不入代码
- 环境配置隔离：避免相互影响
- 外部化管理：便于运维调整

实现方式：
- Profile机制：Spring等框架的标准做法
- 环境变量：容器化环境的主流方式
- 配置中心：大型项目的企业级方案
```

### 8.3 实际应用价值


**🎯 企业开发场景应用**
- **电商平台**：大促期间的快速部署和扩容能力
- **金融系统**：严格的部署流程和零停机要求
- **内容平台**：静态资源CDN分发和缓存优化
- **企业应用**：多环境管理和配置安全性

**🔧 运维实践建议**
- **自动化部署**：减少人工操作，提高部署效率
- **监控告警**：及时发现部署问题，快速响应
- **回滚预案**：确保部署失败时能快速恢复
- **文档规范**：建立标准化的部署操作手册

**📈 技术发展趋势**
- **云原生部署**：Kubernetes等容器编排平台
- **微服务架构**：服务拆分和独立部署
- **DevOps文化**：开发运维一体化协作
- **GitOps实践**：基于Git的自动化部署流程

**核心记忆口诀**：
- WAR包打包项目全，静态资源要优化
- 配置分离环境分，Tomcat部署要规范
- 容器化部署更灵活，环境分离保安全
- 生产部署要谨慎，监控告警不可少