---
title: 4、现代架构发展趋势
---
## 📚 目录

1. [SpringBoot框架简化开发](#1-SpringBoot框架简化开发)
2. [微服务架构设计模式](#2-微服务架构设计模式)
3. [RESTful API设计规范](#3-RESTful-API设计规范)
4. [前后端分离开发模式](#4-前后端分离开发模式)
5. [响应式编程范式](#5-响应式编程范式)
6. [云原生应用开发](#6-云原生应用开发)
7. [现代架构选择指南](#7-现代架构选择指南)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 SpringBoot框架简化开发


### 1.1 SpringBoot是什么

**简单理解**：SpringBoot就像是给Spring框架配了个"自动驾驶系统"

> 💡 **通俗类比**  
> 传统Spring开发就像手动挡汽车：需要自己配置很多东西，踩离合、换挡、调节各种参数
> SpringBoot就像自动挡汽车：大部分配置都自动完成，你只需要专注开车（写业务代码）

**核心理念**：
```
约定大于配置（Convention over Configuration）
开箱即用（Out of the box）
微服务友好（Microservice Ready）
```

### 1.2 SpringBoot解决了什么问题


**传统Spring开发的痛点**：
```
配置地狱：
┌─────────────────────┐
│  applicationContext.xml  │ ← 配置Bean
├─────────────────────┤
│  web.xml            │ ← 配置Servlet
├─────────────────────┤  
│  spring-mvc.xml     │ ← 配置MVC
├─────────────────────┤
│  数据库配置文件        │ ← 配置数据源
└─────────────────────┘

问题：配置文件多、复杂、容易出错
```

**SpringBoot的解决方案**：
```
自动配置 + 简化配置：

传统方式：写50行XML配置数据源
SpringBoot：在application.yml写3行就够了

spring:
  datasource:
    url: jdbc:mysql://localhost/mydb
```

### 1.3 SpringBoot核心特性


**🔸 自动配置（Auto Configuration）**
```
智能猜测：SpringBoot会根据你的项目依赖自动配置
举个例子：
- 如果项目里有mysql-connector-java依赖 
- SpringBoot就自动配置MySQL数据源
- 如果有spring-boot-starter-web依赖
- 就自动配置Tomcat服务器和SpringMVC
```

**🔸 起步依赖（Starter Dependencies）**
```
传统方式：需要手动管理N个jar包的版本兼容性
SpringBoot方式：一个starter解决一套功能

spring-boot-starter-web包含：
├── spring-webmvc（MVC框架）
├── spring-boot-starter-tomcat（内嵌服务器）  
├── spring-boot-starter-json（JSON处理）
└── 其他相关依赖（版本都测试兼容）
```

### 1.4 SpringBoot简单入门示例


```java
// 这就是一个完整的Web应用！
@SpringBootApplication  // 一个注解搞定配置
public class MyWebApp {
    public static void main(String[] args) {
        SpringApplication.run(MyWebApp.class, args);
    }
}

@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello() {
        return "Hello SpringBoot!";
    }
}
```

> 🎯 **新手理解要点**  
> 上面这几行代码就能启动一个Web服务器，访问 http://localhost:8080/hello 就能看到结果！
> 不需要配置Tomcat，不需要写web.xml，SpringBoot全自动处理了

---

## 2. 🏗️ 微服务架构设计模式


### 2.1 什么是微服务架构


**通俗理解**：把一个大型应用拆分成多个小的、独立的服务

> 🎭 **生活类比**  
> **单体架构**就像一个大商场，所有功能都在一栋楼里：
> - 餐饮、购物、娱乐、停车都在一起
> - 某个区域装修，整个商场都受影响
> 
> **微服务架构**就像商业街，每个店铺独立经营：
> - 餐厅、服装店、电影院各自独立
> - 某家店装修不影响其他店营业

### 2.2 架构演进过程


**🔄 架构演进历程**：
```
阶段1：单体应用（Monolith）
┌─────────────────────────┐
│        一个大应用         │
│  ┌─────┬─────┬─────┐    │
│  │用户  │订单  │支付  │    │
│  │管理  │管理  │管理  │    │  
│  └─────┴─────┴─────┘    │
└─────────────────────────┘
特点：部署简单，但维护困难

↓ 演进

阶段2：微服务架构（Microservices）
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 用户服务  │  │ 订单服务  │  │ 支付服务  │
│         │  │         │  │         │
└─────────┘  └─────────┘  └─────────┘
     ↓            ↓            ↓
   独立部署      独立部署      独立部署
特点：灵活扩展，但复杂度增加
```

### 2.3 微服务的核心原则


**📋 微服务设计原则**：

| 原则 | **解释** | **实际例子** |
|------|---------|-------------|
| 🎯 **单一职责** | 每个服务只做一件事 | 用户服务只管用户信息，不管订单 |
| 🔧 **独立部署** | 服务可以独立上线 | 更新支付功能不影响用户登录 |
| 📡 **通过接口通信** | 服务间用HTTP/消息队列通信 | 订单服务调用支付服务的API |
| 💾 **数据独立** | 每个服务有自己的数据库 | 用户数据库和订单数据库分开 |

### 2.4 微服务的优缺点对比


**✅ 微服务的优势**：
```
开发效率：多团队并行开发，不相互阻塞
技术选择：每个服务可以用不同技术栈
容错性：某个服务挂了不影响其他服务
扩展性：只需要扩展压力大的服务
```

**❌ 微服务的挑战**：
```
复杂度：需要处理网络调用、数据一致性等问题
运维成本：需要管理多个服务的部署和监控
调试困难：问题可能跨多个服务，排查复杂
网络开销：服务间调用有网络延迟
```

### 2.5 微服务适用场景


> ⚠️ **选择建议**  
> **适合微服务的场景**：
> - 团队规模较大（10人以上）
> - 业务复杂，功能模块较多
> - 需要快速迭代和部署
> - 不同模块有不同的性能要求
> 
> **不建议用微服务的场景**：
> - 小团队（5人以下）
> - 业务简单，功能不多
> - 团队缺乏微服务经验
> - 对性能要求不高的内部系统

---

## 3. 🌐 RESTful API设计规范


### 3.1 什么是RESTful API


**REST**全称：**RE**presentational **S**tate **T**ransfer（表述性状态转移）

> 📖 **通俗解释**  
> REST就是一套设计Web API的规则，让API变得简洁、统一、易懂
> 就像交通规则一样，大家都遵守同样的规则，开车就不会乱

**RESTful的核心思想**：
```
资源导向：把数据看作资源（Resource）
统一接口：用HTTP方法表示操作
状态无关：每次请求都是独立的
```

### 3.2 RESTful设计原则详解


**🔸 资源（Resource）概念**
```
传统API设计：                RESTful设计：
/getUserById?id=123     →   GET /users/123
/createUser             →   POST /users  
/updateUser             →   PUT /users/123
/deleteUser             →   DELETE /users/123

核心思路：URL描述资源，HTTP方法描述操作
```

**🔸 HTTP方法的语义**

| 方法 | **作用** | **例子** | **说明** |
|------|---------|---------|----------|
| **GET** | 获取资源 | `GET /users/123` | 获取ID为123的用户信息 |
| **POST** | 创建资源 | `POST /users` | 创建新用户 |
| **PUT** | 更新资源 | `PUT /users/123` | 完整更新用户123的信息 |
| **DELETE** | 删除资源 | `DELETE /users/123` | 删除用户123 |
| **PATCH** | 部分更新 | `PATCH /users/123` | 只更新用户123的部分字段 |

### 3.3 RESTful URL设计规范


**📏 URL设计最佳实践**：

```
✅ 好的设计：
GET /users              - 获取用户列表
GET /users/123          - 获取特定用户
GET /users/123/orders   - 获取用户123的订单列表
POST /users/123/orders  - 为用户123创建订单

❌ 不好的设计：
GET /getUsers           - 动词应该用HTTP方法表示
GET /user               - 资源名用复数形式  
GET /users/getUserOrders - URL太冗长
```

**🔸 嵌套资源的处理**：
```
一级资源：/users
二级资源：/users/{userId}/orders
三级资源：/users/{userId}/orders/{orderId}/items

建议：嵌套不要超过3层，太深不好理解
```

### 3.4 HTTP状态码的使用


**📊 常用状态码及含义**：

```
成功响应（2xx）：
200 OK          - 请求成功
201 Created     - 创建成功
204 No Content  - 删除成功，无返回内容

客户端错误（4xx）：  
400 Bad Request - 请求参数错误
401 Unauthorized - 未认证
403 Forbidden   - 无权限
404 Not Found   - 资源不存在

服务器错误（5xx）：
500 Internal Server Error - 服务器内部错误
503 Service Unavailable   - 服务不可用
```

### 3.5 RESTful API响应格式


**🔧 统一的响应格式**：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 123,
    "name": "张三",
    "email": "zhangsan@example.com"
  },
  "timestamp": "2024-09-24T14:30:00Z"
}
```

> 💡 **设计建议**  
> 无论成功还是失败，都保持相同的响应结构，这样前端处理起来更方便

---

## 4. 🎨 前后端分离开发模式


### 4.1 什么是前后端分离


**传统模式 vs 分离模式对比**：

```
传统模式（前后端耦合）：
浏览器 → 后端服务器 → 返回完整HTML页面
         ↓
    ┌─────────────┐
    │   服务器     │
    │ ┌─────────┐ │
    │ │  业务   │ │  
    │ │  逻辑   │ │
    │ └─────────┘ │
    │ ┌─────────┐ │
    │ │ 页面    │ │
    │ │ 渲染    │ │  
    │ └─────────┘ │
    └─────────────┘

分离模式：
前端应用 ← HTTP API ← 后端服务器（只返回JSON数据）
   ↓                      ↓
负责页面展示            负责业务逻辑
```

### 4.2 前后端分离的优势


**🎯 开发效率提升**：
```
并行开发：前后端团队可以同时开发，不互相等待
职责清晰：前端专注用户体验，后端专注业务逻辑
技术选择：前端可以用React/Vue，后端可以用Java/Python
```

**⚡ 性能和体验优化**：
```
首页加载快：首次加载后，后续只请求数据，不重新加载页面
缓存友好：静态资源可以用CDN缓存
移动适配：同一套API可以支持网页、APP、小程序
```

### 4.3 前后端分离架构图


```
┌─────────────────┐    ┌─────────────────┐
│     前端应用      │    │     后端应用      │
│                 │    │                 │
│  ┌───────────┐  │    │  ┌───────────┐  │
│  │  Vue.js   │  │    │  │SpringBoot │  │
│  │  React    │  │ ←──┤ │  Flask    │  │
│  │  Angular  │  │HTTP│  │  Django   │  │
│  └───────────┘  │API │  └───────────┘  │
│                 │    │       ↓         │
│                 │    │  ┌───────────┐  │
│                 │    │  │  数据库    │  │
│                 │    │  └───────────┘  │
└─────────────────┘    └─────────────────┘

前端：负责页面展示、用户交互、数据展现
后端：负责业务逻辑、数据处理、权限控制
```

### 4.4 前后端协作方式


**📋 开发流程**：
```
步骤1：接口设计
前后端一起设计API接口文档，确定数据格式

步骤2：Mock开发  
前端用假数据开发页面，后端开发真实接口

步骤3：接口联调
前端对接真实后端接口，测试数据交互

步骤4：集成测试
整体测试前后端配合是否正常
```

**🔧 协作工具**：
```
接口文档：Swagger、Postman、YAPI
版本控制：Git分支管理
沟通协作：飞书、钉钉、Slack
```

### 4.5 前后端分离的注意事项


> ⚠️ **安全考虑**  
> - **跨域问题**：需要配置CORS允许前端域名访问
> - **身份认证**：通常用JWT Token进行身份验证
> - **接口安全**：重要接口需要权限验证和参数校验

> 💭 **开发挑战**  
> - **调试复杂**：问题可能在前端、后端或网络层
> - **SEO问题**：单页应用对搜索引擎不友好（需要SSR解决）
> - **首屏加载**：需要优化JavaScript打包大小

---

## 5. ⚡ 响应式编程范式


### 5.1 什么是响应式编程


**传统编程 vs 响应式编程**：

> 🌊 **形象比喻**  
> **传统编程**像"水桶取水"：程序主动去获取数据，一次拿一桶
> **响应式编程**像"水管流水"：数据像水流一样持续流过，程序响应处理

**核心概念**：
```
数据流（Data Stream）：数据像流水一样连续流动
事件驱动（Event-Driven）：有事件发生时才执行代码
异步非阻塞（Async Non-blocking）：不等待结果，继续执行其他任务
```

### 5.2 响应式编程的应用场景


**🔸 实时数据处理**：
```
场景举例：
股票价格监控 → 价格变化时自动更新界面
聊天应用 → 有新消息时立即显示
系统监控 → CPU使用率变化时实时预警

传统方式：每秒查询一次数据库，浪费资源
响应式方式：数据变化时主动推送，高效节能
```

**🔸 高并发处理**：
```
传统模式：每个请求占用一个线程，高并发时线程耗尽
┌─────┐    ┌─────┐    ┌─────┐
│请求1 │ → │线程1│    │请求N │ → 线程耗尽！
├─────┤    ├─────┤    ├─────┤
│请求2 │ → │线程2│    │等待... │
└─────┘    └─────┘    └─────┘

响应式模式：少量线程处理大量请求，资源利用率高
┌─────┐    ┌─────┐    ┌─────┐
│请求1 │ ┐  │     │    │请求N │ ← 同样处理
├─────┤ ├→ │线程池│ ←─ ├─────┤
│请求2 │ ┘  │     │    │请求M │ ← 高效处理
└─────┘    └─────┘    └─────┘
```

### 5.3 响应式编程的核心概念


**📊 关键组件**：

```
Publisher（发布者）：产生数据的源头
Subscriber（订阅者）：消费数据的终点  
Processor（处理器）：中间处理环节
Subscription（订阅关系）：控制流量和生命周期

数据流动过程：
Publisher → [Processor] → Subscriber
   ↓           ↓           ↓
 生产数据    转换数据    消费数据
```

### 5.4 Java中的响应式编程


**🔧 常用框架**：
```java
// Project Reactor 示例（SpringBoot默认支持）
@RestController
public class ReactiveController {
    
    @GetMapping("/users")
    public Flux<User> getUsers() {
        // Flux代表多个数据的流
        return userService.findAllUsers()
                .filter(user -> user.isActive())  // 过滤激活用户
                .map(User::toDTO);                // 转换为DTO
    }
    
    @GetMapping("/user/{id}")  
    public Mono<User> getUser(@PathVariable String id) {
        // Mono代表单个数据的流
        return userService.findById(id);
    }
}
```

> 💡 **新手理解**  
> - **Flux**：想象成一个水管，里面流过多个数据
> - **Mono**：想象成一个杯子，里面只有一个数据
> - **filter/map**：就像水管上的过滤器和转换器

### 5.5 响应式编程的优缺点


**✅ 优势**：
```
资源利用率高：少量线程处理大量请求
响应速度快：异步处理，不阻塞等待
扩展性好：天然支持背压（backpressure）控制
```

**❌ 挑战**：
```
学习曲线陡：思维方式需要转变
调试困难：异步流程不好跟踪
错误处理复杂：异常在流中传播复杂
```

---

## 6. ☁️ 云原生应用开发


### 6.1 什么是云原生


**云原生（Cloud Native）**：专门为云环境设计和构建的应用程序

> 🌤️ **通俗理解**  
> 就像专门为水里游泳设计的鱼，云原生应用专门为云环境设计
> 能充分利用云的弹性、可扩展性和高可用性

**云原生的核心特征**：
```
容器化（Containerized）：应用打包在容器中运行
微服务化（Microservices）：服务拆分、独立部署
动态编排（Dynamic Orchestration）：自动管理容器生命周期
```

### 6.2 云原生技术栈


**🏗️ 云原生全景图**：
```
┌─────────────────────────────────────┐
│             应用层                   │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐│
│  │ 用户服务 │ │ 订单服务 │ │ 支付服务 ││
│  └─────────┘ └─────────┘ └─────────┘│
└─────────────┬───────────────────────┘
              │
┌─────────────▼───────────────────────┐
│           编排层 (Kubernetes)        │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐│
│  │ 容器A   │ │ 容器B   │ │ 容器C   ││
│  └─────────┘ └─────────┘ └─────────┘│
└─────────────┬───────────────────────┘
              │
┌─────────────▼───────────────────────┐
│           基础设施层                 │
│     ┌─────┐  ┌─────┐  ┌─────┐      │
│     │服务器│  │网络 │  │存储 │      │
│     └─────┘  └─────┘  └─────┘      │
└─────────────────────────────────────┘
```

### 6.3 Docker容器技术


**🐳 容器 vs 虚拟机对比**：
```
虚拟机模式：
┌─────────────────┐  ┌─────────────────┐
│   应用程序A      │  │   应用程序B      │
├─────────────────┤  ├─────────────────┤
│   客户操作系统    │  │   客户操作系统    │
├─────────────────┤  ├─────────────────┤
│   虚拟机监控程序  │  │   虚拟机监控程序  │
└─────────────────┘  └─────────────────┘
┌─────────────────────────────────────┐
│          主机操作系统               │
└─────────────────────────────────────┘

容器模式：
┌─────────┐  ┌─────────┐  ┌─────────┐
│  应用A   │  │  应用B   │  │  应用C   │
├─────────┤  ├─────────┤  ├─────────┤
│容器运行时│  │容器运行时│  │容器运行时│
└─────────┴──┴─────────┴──┴─────────┘
┌─────────────────────────────────────┐
│          主机操作系统               │
└─────────────────────────────────────┘

优势：启动快、资源占用少、部署简单
```

**📦 Docker基本概念**：
```
镜像（Image）：应用程序的"安装包"，包含代码和运行环境
容器（Container）：镜像运行后的实例，就像"正在运行的程序"
仓库（Registry）：存放镜像的地方，就像"应用商店"

简单类比：
镜像 = 游戏安装包
容器 = 正在运行的游戏
仓库 = Steam游戏平台
```

### 6.4 Kubernetes容器编排


**🎼 什么是容器编排**：
```
问题：如果有100个容器，手动管理会疯掉
┌────┐ ┌────┐ ┌────┐     ┌────┐
│容器1│ │容器2│ │容器3│ ... │容器N│
└────┘ └────┘ └────┘     └────┘
   ↓      ↓      ↓         ↓
手动启动？手动监控？手动扩容？

解决：Kubernetes自动化管理
┌─────────────────────────┐
│      Kubernetes         │ ← 自动管理所有容器
│  ┌────┬────┬────┬────┐  │   - 自动启动/停止
│  │容器1│容器2│容器3│...│  │   - 健康检查
│  └────┴────┴────┴────┘  │   - 自动扩缩容
└─────────────────────────┘   - 负载均衡
```

### 6.5 云原生开发实践


**🛠️ 开发流程改变**：
```
传统开发流程：
开发 → 测试 → 打包 → 部署到服务器 → 运维监控

云原生开发流程：  
开发 → 测试 → 构建镜像 → 推送到仓库 → K8s自动部署 → 自动监控

关键变化：
1. 代码写完后打包成Docker镜像
2. 用YAML文件描述部署方式
3. 一个命令就能部署到任何云平台
```

**☁️ 云平台选择**：
```
公有云：阿里云、腾讯云、AWS、Azure
私有云：自建Kubernetes集群
混合云：部分用公有云，部分用私有云

选择依据：
- 数据敏感性（金融用私有云）
- 成本考虑（小公司用公有云）  
- 技术能力（运维能力强可以自建）
```

---

## 7. 🎯 现代架构选择指南


### 7.1 架构选择决策树


**🌳 技术选型决策流程**：
```
开始项目
    ↓
团队规模和经验如何？
    ├─ 小团队(≤5人) → SpringBoot单体应用
    └─ 大团队(>10人) → 考虑微服务架构
                ↓
        业务复杂度如何？
            ├─ 简单业务 → SpringBoot + RESTful API
            └─ 复杂业务 → 微服务 + 云原生架构
                    ↓
            是否需要高并发？
                ├─ 高并发需求 → 响应式编程 + 容器化
                └─ 普通并发 → 传统MVC + 数据库优化
```

### 7.2 不同规模项目的架构建议


**📊 项目规模 vs 技术选择**：

| 项目类型 | **团队规模** | **推荐架构** | **核心技术** | **部署方式** |
|---------|-------------|-------------|-------------|-------------|
| 🏠 **个人项目** | 1-2人 | 单体应用 | SpringBoot + MySQL | 单服务器部署 |
| 🏢 **小型企业** | 3-8人 | 单体应用 | SpringBoot + Redis + MySQL | Docker容器化 |
| 🏭 **中型企业** | 10-30人 | 微服务架构 | SpringCloud + 分库分表 | Kubernetes编排 |
| 🏙️ **大型互联网** | 50+人 | 云原生微服务 | 响应式 + 消息队列 + 容器云 | 多云部署 |

### 7.3 技术栈组合建议


**🔧 经典技术栈组合**：

```
入门级组合（学习推荐）：
前端：HTML + CSS + JavaScript
后端：SpringBoot + MyBatis + MySQL  
部署：Tomcat + Linux服务器

进阶级组合（企业应用）：
前端：Vue.js/React + Element UI
后端：SpringBoot + SpringCloud + Redis + MySQL
部署：Docker + Nginx + 云服务器

高级组合（大厂标配）：
前端：React/Vue + TypeScript + 微前端
后端：SpringBoot + 微服务 + 消息队列 + 分布式数据库
部署：Kubernetes + 监控系统 + CI/CD
```

### 7.4 学习路径建议


**📚 渐进式学习路径**：

```
第一阶段：基础掌握（2-3个月）
├─ JavaWeb基础（Servlet + JSP）
├─ Spring框架核心
├─ SpringMVC + MyBatis
└─ MySQL数据库操作

第二阶段：进阶技能（3-4个月）  
├─ SpringBoot快速开发
├─ RESTful API设计
├─ 前后端分离实践
└─ Redis缓存应用

第三阶段：高级架构（6个月以上）
├─ 微服务架构设计
├─ Docker容器化
├─ 分布式系统理论
└─ 云原生开发实践
```

> 💡 **学习建议**  
> 不要试图一次性掌握所有技术，按阶段循序渐进学习
> 每个阶段都要有实际项目练手，理论结合实践

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 SpringBoot：简化Spring开发，约定大于配置，开箱即用
🔸 微服务：大应用拆分成小服务，独立开发部署，提高灵活性  
🔸 RESTful API：统一的接口设计规范，资源导向，HTTP方法语义化
🔸 前后端分离：前端负责展示，后端负责业务，并行开发提高效率
🔸 响应式编程：数据流驱动，异步非阻塞，提高并发处理能力
🔸 云原生：容器化微服务，自动化编排，充分利用云计算优势
```

### 8.2 关键理解要点


**🔹 架构演进的驱动力**
```
业务复杂性增加 → 需要更灵活的架构
团队规模扩大 → 需要并行开发能力  
用户量增长 → 需要更高的性能和可用性
技术发展 → 新工具降低复杂度，提高效率
```

**🔹 技术选择的平衡**
```
简单 vs 功能：简单架构易维护，复杂架构功能强大
性能 vs 成本：高性能架构成本高，需要权衡
稳定 vs 创新：成熟技术稳定，新技术有风险
学习成本 vs 开发效率：新技术学习成本高，但长期效率更高
```

### 8.3 实际应用指导


**🎯 项目启动时的技术选择**：
```
Step 1：评估项目规模和复杂度
Step 2：考虑团队技术水平和人员规模
Step 3：确定性能和可用性要求
Step 4：考虑预算和时间限制
Step 5：制定技术栈和架构方案
```

**🔧 架构演进策略**：
```
起步阶段：选择熟悉的技术，快速验证业务
成长阶段：识别性能瓶颈，局部优化升级
成熟阶段：考虑架构重构，引入新技术
扩展阶段：云原生转型，自动化运维
```

### 8.4 学习和实践建议


**📚 技能发展路线**：
```
Java基础 → SpringBoot → 微服务 → 云原生
同时关注：
- 前端技术：了解前后端如何协作
- 数据库技术：掌握数据存储和查询优化  
- 运维知识：理解部署和监控
- 架构思维：学会分析和设计系统
```

**🛠️ 实践项目建议**：
```
个人博客系统：练习SpringBoot + 前后端分离
电商项目：练习微服务拆分和分布式事务
实时聊天系统：练习响应式编程和WebSocket
容器化部署：练习Docker和Kubernetes
```

**核心记忆**：
- 现代架构发展趋势是简化开发、提高效率、支持高并发、易于扩展
- SpringBoot让Java Web开发变得简单，微服务让大型应用更灵活
- RESTful API是前后端分离的桥梁，响应式编程是高并发的解决方案
- 云原生是未来趋势，但技术选择要结合实际情况，循序渐进学习