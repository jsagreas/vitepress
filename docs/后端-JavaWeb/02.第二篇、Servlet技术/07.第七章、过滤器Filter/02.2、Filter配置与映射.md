---
title: 2、Filter配置与映射
---
## 📚 目录

1. [Filter配置方式概述](#1-filter配置方式概述)
2. [web.xml传统配置方式](#2-webxml传统配置方式)
3. [@WebFilter注解配置](#3-webfilter注解配置)
4. [URL匹配模式详解](#4-url匹配模式详解)
5. [分发类型与请求处理](#5-分发类型与请求处理)
6. [过滤器执行顺序控制](#6-过滤器执行顺序控制)
7. [初始化参数设置](#7-初始化参数设置)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 Filter配置方式概述


### 1.1 什么是Filter配置


**简单理解**：就像给家里装门禁系统，你需要告诉系统在哪些门口设置检查点，什么样的人可以通过，这就是Filter的配置工作。

```
现实生活中的门禁：                Filter在Web中：
┌─────────────┐                 ┌─────────────┐
│   小区门口   │ ←检查访客        │  登录页面    │ ←检查用户
├─────────────┤                 ├─────────────┤
│   楼栋门口   │ ←检查业主        │  管理页面    │ ←检查权限
├─────────────┤                 ├─────────────┤
│   单元门口   │ ←检查钥匙        │  资源文件    │ ←检查访问
└─────────────┘                 └─────────────┘
```

### 1.2 配置方式对比


**两种主要配置方式**：

| 配置方式 | **适用场景** | **优点** | **缺点** |
|---------|-------------|---------|---------|
| **web.xml** | `传统项目、集中管理` | `配置集中、易维护` | `配置繁琐、需重启` |
| **@WebFilter** | `现代项目、快速开发` | `配置简单、就近管理` | `分散配置、难统览` |

---

## 2. 📝 web.xml传统配置方式


### 2.1 基本配置结构


**配置模板**：
```xml
<!-- 第一步：声明过滤器 -->
<filter>
    <filter-name>过滤器名称</filter-name>
    <filter-class>过滤器完整类名</filter-class>
    <!-- 可选：初始化参数 -->
    <init-param>
        <param-name>参数名</param-name>
        <param-value>参数值</param-value>
    </init-param>
</filter>

<!-- 第二步：配置过滤器映射 -->
<filter-mapping>
    <filter-name>过滤器名称</filter-name>
    <url-pattern>URL匹配模式</url-pattern>
    <!-- 可选：指定分发类型 -->
    <dispatcher>REQUEST</dispatcher>
</filter-mapping>
```

### 2.2 实际配置示例


**登录检查过滤器配置**：
```xml
<!-- 登录验证过滤器 -->
<filter>
    <filter-name>LoginCheckFilter</filter-name>
    <filter-class>com.example.filter.LoginCheckFilter</filter-class>
    <init-param>
        <param-name>excludeUrls</param-name>
        <param-value>/login,/register,/css/*,/js/*</param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>LoginCheckFilter</filter-name>
    <url-pattern>/admin/*</url-pattern>
    <dispatcher>REQUEST</dispatcher>
</filter-mapping>
```

**字符编码过滤器配置**：
```xml
<!-- 字符编码过滤器 -->
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>com.example.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

### 2.3 web.xml配置要点


> **💡 重要提醒**：web.xml中过滤器的**声明顺序**就是执行顺序！

**配置注意事项**：
- `<filter-name>` 必须在声明和映射中保持一致
- `<filter-class>` 必须是完整的类路径
- 过滤器声明必须在所有`<filter-mapping>`之前
- 同一个过滤器可以有多个`<filter-mapping>`

---

## 3. 🔧 @WebFilter注解配置


### 3.1 注解配置基础


**@WebFilter注解**：这是Servlet 3.0引入的新特性，让配置变得更简单直观。

```java
@WebFilter(
    filterName = "过滤器名称",     // 过滤器名称（可选）
    urlPatterns = {"URL模式"},    // URL匹配模式
    dispatcherTypes = {分发类型}, // 分发类型（可选）
    initParams = {初始化参数}     // 初始化参数（可选）
)
public class MyFilter implements Filter {
    // 过滤器实现
}
```

### 3.2 常用注解配置示例


**登录检查过滤器**：
```java
@WebFilter(
    filterName = "LoginCheckFilter",
    urlPatterns = {"/admin/*", "/user/*"},
    initParams = {
        @WebInitParam(name = "excludeUrls", value = "/login,/register")
    }
)
public class LoginCheckFilter implements Filter {
    private String excludeUrls;
    
    @Override
    public void init(FilterConfig config) {
        excludeUrls = config.getInitParameter("excludeUrls");
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        // 登录检查逻辑
    }
}
```

**字符编码过滤器**：
```java
@WebFilter(
    urlPatterns = {"/*"},
    initParams = {
        @WebInitParam(name = "encoding", value = "UTF-8")
    }
)
public class CharacterEncodingFilter implements Filter {
    private String encoding;
    
    @Override
    public void init(FilterConfig config) {
        encoding = config.getInitParameter("encoding");
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding(encoding);
        response.setCharacterEncoding(encoding);
        chain.doFilter(request, response);
    }
}
```

### 3.3 注解配置优势


**为什么推荐使用注解**：
- **就近原则**：配置和代码在一起，便于维护
- **类型安全**：编译时检查，减少配置错误
- **开发效率**：不需要在web.xml中反复切换
- **现代化**：符合当前Java开发趋势

---

## 4. 🎯 URL匹配模式详解


### 4.1 匹配模式类型


**四种主要匹配模式**：

```
精确匹配：   /login          只匹配 /login
路径匹配：   /admin/*        匹配 /admin/ 下所有路径
扩展匹配：   *.jsp          匹配所有 .jsp 文件
全匹配：     /*             匹配所有请求
```

### 4.2 匹配模式详细说明


**精确匹配示例**：
```java
@WebFilter(urlPatterns = {"/login"})
// 只会拦截：http://localhost:8080/myapp/login
// 不会拦截：http://localhost:8080/myapp/login.html
//          http://localhost:8080/myapp/login/
```

**路径匹配示例**：
```java
@WebFilter(urlPatterns = {"/admin/*"})
// 会拦截：http://localhost:8080/myapp/admin/
//        http://localhost:8080/myapp/admin/user
//        http://localhost:8080/myapp/admin/user/list
// 不会拦截：http://localhost:8080/myapp/admin（注意没有/）
```

**扩展匹配示例**：
```java
@WebFilter(urlPatterns = {"*.jsp", "*.html"})
// 会拦截：http://localhost:8080/myapp/index.jsp
//        http://localhost:8080/myapp/user/list.html
// 不会拦截：http://localhost:8080/myapp/api/user
```

### 4.3 匹配优先级规则


> **⚠️ 重要**：当多个模式都能匹配同一个URL时，按以下优先级处理：

```
优先级从高到低：
1. 精确匹配      /login
2. 路径匹配      /admin/*
3. 扩展匹配      *.jsp
4. 默认匹配      /*
```

**匹配示例分析**：
```
URL: /admin/user.jsp

可能的匹配模式：
- /admin/user.jsp  (精确匹配) ← 最高优先级
- /admin/*        (路径匹配) ← 次优先级  
- *.jsp           (扩展匹配) ← 第三优先级
- /*              (默认匹配) ← 最低优先级

实际执行：只有优先级最高的过滤器会执行
```

---

## 5. 🚦 分发类型与请求处理


### 5.1 什么是分发类型


**通俗解释**：分发类型就是指请求是怎么来的，是用户直接访问，还是服务器内部转发过来的。

```
用户请求流程：
浏览器 → Servlet容器 → 过滤器 → Servlet

内部转发流程：  
Servlet A → 请求转发 → Servlet B
                ↑
            这里可能经过过滤器
```

### 5.2 四种分发类型


**DispatcherType枚举值**：

| 分发类型 | **含义** | **使用场景** |
|---------|---------|-------------|
| **REQUEST** | `用户直接请求` | `最常用，处理正常的HTTP请求` |
| **FORWARD** | `请求转发` | `处理RequestDispatcher.forward()` |
| **INCLUDE** | `请求包含` | `处理RequestDispatcher.include()` |
| **ERROR** | `错误页面` | `处理错误页面跳转` |

### 5.3 分发类型配置示例


**web.xml配置**：
```xml
<filter-mapping>
    <filter-name>LogFilter</filter-name>
    <url-pattern>/*</url-pattern>
    <!-- 指定多种分发类型 -->
    <dispatcher>REQUEST</dispatcher>
    <dispatcher>FORWARD</dispatcher>
    <dispatcher>ERROR</dispatcher>
</filter-mapping>
```

**注解配置**：
```java
@WebFilter(
    urlPatterns = {"/*"},
    dispatcherTypes = {
        DispatcherType.REQUEST,
        DispatcherType.FORWARD,
        DispatcherType.ERROR
    }
)
public class LogFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        System.out.println("请求类型：" + request.getDispatcherType());
        chain.doFilter(request, response);
    }
}
```

### 5.4 实际应用场景


**权限检查过滤器**：
```java
// 只检查用户直接访问，不检查内部转发
@WebFilter(
    urlPatterns = {"/admin/*"},
    dispatcherTypes = {DispatcherType.REQUEST}
)
public class AuthFilter implements Filter {
    // 权限检查逻辑
}
```

**日志记录过滤器**：
```java
// 记录所有类型的请求
@WebFilter(
    urlPatterns = {"/*"},
    dispatcherTypes = {
        DispatcherType.REQUEST,
        DispatcherType.FORWARD,
        DispatcherType.INCLUDE,
        DispatcherType.ERROR
    }
)
public class LoggingFilter implements Filter {
    // 日志记录逻辑
}
```

---

## 6. 📋 过滤器执行顺序控制


### 6.1 执行顺序的重要性


**为什么顺序很重要**：过滤器就像流水线，顺序错了整个处理就乱了。

```
正确的顺序示例：
请求 → 字符编码过滤器 → 登录检查过滤器 → 权限验证过滤器 → Servlet

错误的顺序示例：
请求 → 登录检查过滤器 → 字符编码过滤器 → Servlet
       ↑ 这时可能中文参数还没正确解码
```

### 6.2 web.xml中的顺序控制


**web.xml顺序规则**：
> **💡 关键点**：在web.xml中，过滤器按照`<filter>`声明的顺序执行，**不是**按照`<filter-mapping>`的顺序。

```xml
<!-- 执行顺序：1、2、3 -->
<filter>
    <filter-name>Filter1</filter-name><!-- 第1个执行 -->
    <filter-class>com.example.Filter1</filter-class>
</filter>
<filter>
    <filter-name>Filter2</filter-name><!-- 第2个执行 -->
    <filter-class>com.example.Filter2</filter-class>
</filter>
<filter>
    <filter-name>Filter3</filter-name><!-- 第3个执行 -->
    <filter-class>com.example.Filter3</filter-class>
</filter>

<!-- mapping的顺序不影响执行顺序 -->
<filter-mapping>
    <filter-name>Filter3</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>Filter1</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>Filter2</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

### 6.3 注解配置的顺序控制


**注解顺序的限制**：
> **⚠️ 注意**：使用`@WebFilter`注解时，过滤器的执行顺序是**不确定的**！容器会按照自己的规则来排序。

**解决方案**：
1. **混合配置**：在web.xml中只配置顺序，注解中配置其他参数
2. **使用FilterRegistrationBean**（Spring环境）
3. **手动注册过滤器**

**混合配置示例**：
```java
// 注解中不指定urlPatterns，在web.xml中配置映射
@WebFilter(filterName = "CharacterEncodingFilter")
public class CharacterEncodingFilter implements Filter {
    // 过滤器实现
}
```

```xml
<!-- web.xml中按顺序配置映射 -->
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>LoginCheckFilter</filter-name>
    <url-pattern>/admin/*</url-pattern>
</filter-mapping>
```

### 6.4 执行顺序最佳实践


**推荐的过滤器顺序**：
```
1. 字符编码过滤器        ← 最先处理编码
2. 跨域处理过滤器        ← 处理CORS
3. 日志记录过滤器        ← 记录请求信息
4. 登录检查过滤器        ← 验证用户身份
5. 权限验证过滤器        ← 检查访问权限
6. 业务相关过滤器        ← 具体业务逻辑
```

---

## 7. ⚙️ 初始化参数设置


### 7.1 什么是初始化参数


**简单理解**：初始化参数就像是给过滤器传递的配置信息，告诉它应该怎么工作。

```
现实类比：
空调遥控器的初始设置：
- 默认温度：26度
- 默认模式：制冷
- 默认风速：自动

过滤器的初始参数：
- 字符编码：UTF-8  
- 排除路径：/login,/register
- 超时时间：30分钟
```

### 7.2 web.xml中设置初始化参数


**基本语法**：
```xml
<filter>
    <filter-name>MyFilter</filter-name>
    <filter-class>com.example.MyFilter</filter-class>
    
    <!-- 初始化参数 -->
    <init-param>
        <param-name>参数名1</param-name>
        <param-value>参数值1</param-value>
    </init-param>
    <init-param>
        <param-name>参数名2</param-name>
        <param-value>参数值2</param-value>
    </init-param>
</filter>
```

**实际示例**：
```xml
<filter>
    <filter-name>LoginCheckFilter</filter-name>
    <filter-class>com.example.filter.LoginCheckFilter</filter-class>
    
    <!-- 排除不需要登录检查的URL -->
    <init-param>
        <param-name>excludeUrls</param-name>
        <param-value>/login,/register,/css/*,/js/*,/images/*</param-value>
    </init-param>
    
    <!-- 登录页面URL -->
    <init-param>
        <param-name>loginUrl</param-name>
        <param-value>/login</param-value>
    </init-param>
    
    <!-- 会话超时时间（分钟） -->
    <init-param>
        <param-name>sessionTimeout</param-name>
        <param-value>30</param-value>
    </init-param>
</filter>
```

### 7.3 注解中设置初始化参数


**@WebInitParam注解**：
```java
@WebFilter(
    filterName = "LoginCheckFilter",
    urlPatterns = {"/admin/*"},
    initParams = {
        @WebInitParam(name = "excludeUrls", 
                     value = "/login,/register,/css/*"),
        @WebInitParam(name = "loginUrl", 
                     value = "/login"),
        @WebInitParam(name = "sessionTimeout", 
                     value = "30")
    }
)
public class LoginCheckFilter implements Filter {
    // 过滤器实现
}
```

### 7.4 在过滤器中使用初始化参数


**获取和使用参数**：
```java
public class LoginCheckFilter implements Filter {
    private String excludeUrls;
    private String loginUrl;
    private int sessionTimeout;
    private List<String> excludeList;
    
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 获取初始化参数
        excludeUrls = filterConfig.getInitParameter("excludeUrls");
        loginUrl = filterConfig.getInitParameter("loginUrl");
        String timeout = filterConfig.getInitParameter("sessionTimeout");
        
        // 参数处理和验证
        if (excludeUrls != null) {
            excludeList = Arrays.asList(excludeUrls.split(","));
        }
        
        if (timeout != null) {
            try {
                sessionTimeout = Integer.parseInt(timeout);
            } catch (NumberFormatException e) {
                sessionTimeout = 30; // 默认值
            }
        }
        
        System.out.println("过滤器初始化完成：");
        System.out.println("排除URL：" + excludeUrls);
        System.out.println("登录URL：" + loginUrl);
        System.out.println("超时时间：" + sessionTimeout + "分钟");
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        String requestURI = req.getRequestURI();
        
        // 检查是否在排除列表中
        if (isExcludedUrl(requestURI)) {
            chain.doFilter(request, response);
            return;
        }
        
        // 登录检查逻辑
        // ...
    }
    
    private boolean isExcludedUrl(String requestURI) {
        if (excludeList == null) return false;
        
        return excludeList.stream()
                .anyMatch(pattern -> {
                    if (pattern.endsWith("/*")) {
                        String prefix = pattern.substring(0, pattern.length() - 2);
                        return requestURI.startsWith(prefix);
                    }
                    return requestURI.equals(pattern);
                });
    }
}
```

### 7.5 初始化参数最佳实践


**参数设计建议**：

> **💡 提示**：合理的参数设计让过滤器更灵活、更易维护。

- **使用有意义的参数名**：`excludeUrls`比`urls`更清晰
- **提供默认值**：避免参数为空时的异常
- **参数验证**：检查参数格式和范围的有效性
- **文档化**：在代码中注释参数的作用和格式

**配置文件化**：
```java
// 可以从配置文件读取复杂配置
@WebFilter(
    urlPatterns = {"/*"},
    initParams = {
        @WebInitParam(name = "configFile", 
                     value = "/WEB-INF/filter-config.properties")
    }
)
public class ConfigurableFilter implements Filter {
    @Override
    public void init(FilterConfig config) throws ServletException {
        String configFile = config.getInitParameter("configFile");
        // 从配置文件加载详细配置
        loadConfiguration(configFile);
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 配置方式选择**：
- `web.xml`：适合需要严格控制执行顺序的项目
- `@WebFilter`：适合快速开发和现代化项目
- `混合配置`：结合两者优势，推荐使用

**🔸 URL匹配规则**：
- `精确匹配` > `路径匹配` > `扩展匹配` > `默认匹配`
- 理解匹配优先级，避免配置冲突

**🔸 分发类型控制**：
- `REQUEST`：处理用户直接请求（最常用）
- `FORWARD`：处理请求转发
- `ERROR`：处理错误页面
- 根据实际需要选择分发类型

### 8.2 关键理解要点


**🔹 执行顺序的控制**：
```
web.xml方式：按<filter>声明顺序执行，可控
注解方式：顺序不确定，需要其他方案
混合方式：注解+web.xml，既灵活又可控
```

**🔹 初始化参数的价值**：
```
作用：让过滤器更灵活，避免硬编码
获取：通过FilterConfig.getInitParameter()
验证：必须进行参数有效性检查
默认：提供合理的默认值
```

### 8.3 实际应用建议


**📝 配置策略**：
- **小项目**：全部使用`@WebFilter`注解，开发效率高
- **大项目**：使用`web.xml`集中管理，便于维护
- **团队协作**：建议统一配置方式，避免混乱

**🛠 开发建议**：
- 先设计好过滤器的执行顺序
- 为过滤器提供必要的初始化参数
- 充分测试各种URL匹配情况
- 关注分发类型对功能的影响

**⚠️ 常见陷阱**：
- 注解配置时执行顺序不可控
- URL匹配模式冲突导致过滤器不生效
- 忘记配置合适的分发类型
- 初始化参数没有进行有效性验证

### 8.4 学习路径建议


**🎯 学习步骤**：
1. **基础配置**：掌握web.xml和注解两种配置方式
2. **URL匹配**：理解各种匹配模式和优先级规则
3. **顺序控制**：学会控制过滤器的执行顺序
4. **参数配置**：合理使用初始化参数提高灵活性
5. **综合应用**：结合实际项目需求选择最佳配置方案

**🔧 实践建议**：
- 创建几个简单的过滤器测试各种配置
- 尝试不同的URL匹配模式
- 观察过滤器的执行顺序
- 使用初始化参数实现可配置的过滤器

**核心记忆**：
- 配置灵活选择，顺序控制关键
- URL匹配有优先级，分发类型要明确  
- 初始参数增灵活，验证默认不可少
- 理论实践相结合，项目应用见真章