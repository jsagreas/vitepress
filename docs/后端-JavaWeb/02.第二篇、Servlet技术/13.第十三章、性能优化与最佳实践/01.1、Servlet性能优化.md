---
title: 1、Servlet性能优化
---
## 📚 目录

1. [性能优化概述](#1-性能优化概述)
2. [数据库连接池优化](#2-数据库连接池优化)
3. [缓存机制应用](#3-缓存机制应用)
4. [响应压缩处理](#4-响应压缩处理)
5. [静态资源优化](#5-静态资源优化)
6. [并发性能调优](#6-并发性能调优)
7. [内存使用优化](#7-内存使用优化)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 性能优化概述


### 1.1 什么是Servlet性能优化


> 💡 **简单理解**：就像给汽车做保养一样，让你的网站跑得更快、更稳定

**性能优化的本质**：
- **速度更快**：用户访问网页响应时间更短
- **承载更多**：同样的服务器能处理更多用户请求
- **资源节约**：更少的内存和CPU占用
- **用户体验**：页面加载流畅，不卡顿

### 1.2 为什么需要性能优化


```
实际场景对比：

未优化的网站：
用户访问 → 等待3-5秒 → 页面才显示
高峰期：网站卡顿甚至崩溃
服务器：CPU100%，内存爆满

优化后的网站：
用户访问 → 1秒内显示页面
高峰期：依然流畅运行
服务器：资源使用合理，性能稳定
```

### 1.3 性能优化的主要方向


```
🔸 数据库层面：连接池、查询优化
🔸 缓存层面：减少重复计算和查询
🔸 网络层面：压缩传输、静态资源优化
🔸 应用层面：并发处理、内存管理
🔸 代码层面：算法优化、资源释放
```

---

## 2. 🏊‍♂️ 数据库连接池优化


### 2.1 什么是数据库连接池


> 🏊‍♂️ **生活类比**：就像游泳池一样，大家共用，用完就还回去

**传统方式的问题**：
```
每次用数据库都要：
1. 建立连接（耗时）
2. 执行SQL
3. 关闭连接（耗时）

就像每次游泳都要重新挖个池子，用完就填埋
```

**连接池的好处**：
```
提前准备好连接放在池子里：
1. 需要时直接取（快）
2. 执行SQL
3. 用完放回池子（循环利用）

就像公共游泳池，随用随取
```

### 2.2 连接池配置实战


**常用连接池：HikariCP配置**

```java
// 简单配置示例
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
config.setUsername("root");
config.setPassword("password");

// 核心优化参数
config.setMaximumPoolSize(20);        // 最大连接数
config.setMinimumIdle(5);            // 最小空闲连接数
config.setConnectionTimeout(30000);  // 连接超时时间(30秒)
config.setMaxLifetime(1800000);      // 连接最大生命周期(30分钟)

HikariDataSource dataSource = new HikariDataSource(config);
```

**参数优化对照表**：

| 参数 | **建议值** | **说明** | **影响** |
|------|----------|----------|----------|
| `maximumPoolSize` | `10-50` | 最大连接数 | 太小→等待；太大→资源浪费 |
| `minimumIdle` | `5-10` | 最小空闲连接 | 保证基础性能 |
| `connectionTimeout` | `30秒` | 获取连接超时 | 避免长时间等待 |
| `maxLifetime` | `30分钟` | 连接最大存活时间 | 避免连接过期问题 |

### 2.3 连接池使用最佳实践


**✅ 正确的使用方式**：
```java
public class UserDao {
    private DataSource dataSource;
    
    public User findById(int id) {
        // 标准的try-with-resources写法
        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {
            
            ps.setInt(1, id);
            ResultSet rs = ps.executeQuery();
            
            if (rs.next()) {
                return new User(rs.getInt("id"), rs.getString("name"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

> ⚠️ **关键点**：使用 `try-with-resources` 语法，自动关闭资源

**❌ 错误的做法**：
- 忘记关闭连接（连接泄漏）
- 长时间占用连接不释放
- 在事务外长期持有连接

---

## 3. 🗄️ 缓存机制应用


### 3.1 缓存是什么


> 📚 **生活类比**：就像把常用的书放在书桌上，用的时候不用跑图书馆

**缓存的作用**：
```
没有缓存：
用户请求 → 查询数据库 → 计算处理 → 返回结果
每次都要重复这个过程

有了缓存：
第一次：用户请求 → 查询数据库 → 存入缓存 → 返回结果
以后：用户请求 → 直接从缓存取 → 返回结果（超快！）
```

### 3.2 常用缓存类型


**🔸 内存缓存（应用内）**
```java
// 简单的内存缓存实现
public class SimpleCache {
    private Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(String key) {
        return cache.get(key);
    }
}
```

**🔸 Redis缓存（分布式）**
```java
// Redis缓存示例
public class UserService {
    private RedisTemplate redisTemplate;
    private UserDao userDao;
    
    public User getUserById(int id) {
        String key = "user:" + id;
        
        // 先查缓存
        User user = (User) redisTemplate.opsForValue().get(key);
        if (user != null) {
            return user; // 缓存命中，直接返回
        }
        
        // 缓存没有，查数据库
        user = userDao.findById(id);
        if (user != null) {
            // 存入缓存，设置过期时间30分钟
            redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
        }
        
        return user;
    }
}
```

### 3.3 缓存应用场景


**💡 适合缓存的数据**：
- **热门数据**：经常被访问的用户信息、商品详情
- **计算结果**：复杂统计数据、排行榜
- **配置信息**：系统设置、字典数据
- **会话数据**：用户登录状态、购物车

**⚠️ 不适合缓存的数据**：
- **实时性要求高**：库存数量、账户余额
- **个人隐私**：密码、身份证号
- **临时数据**：验证码、一次性token

### 3.4 缓存更新策略


```
🔸 定时过期：设置TTL，到期自动失效
🔸 主动更新：数据变化时主动删除缓存
🔸 懒加载：用的时候检查是否过期，过期就重新加载
```

---

## 4. 🗜️ 响应压缩处理


### 4.1 什么是响应压缩


> 📦 **生活类比**：就像快递打包，把大箱子压缩成小包裹，传输更快

**压缩的好处**：
```
原始响应：100KB的HTML页面
压缩后：20KB（压缩率80%）
传输时间：从2秒缩短到0.4秒
```

### 4.2 Gzip压缩配置


**在web.xml中配置过滤器**：
```xml
<filter>
    <filter-name>GzipFilter</filter-name>
    <filter-class>com.example.filter.GzipFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>GzipFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

**简单的Gzip过滤器实现**：
```java
public class GzipFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        
        // 检查客户端是否支持gzip
        String encoding = req.getHeader("Accept-Encoding");
        if (encoding != null && encoding.contains("gzip")) {
            // 使用Gzip压缩响应
            resp.setHeader("Content-Encoding", "gzip");
            GzipResponseWrapper wrapper = new GzipResponseWrapper(resp);
            chain.doFilter(request, wrapper);
            wrapper.finish();
        } else {
            // 正常处理
            chain.doFilter(request, response);
        }
    }
}
```

### 4.3 什么内容需要压缩


**✅ 适合压缩**：
- **文本内容**：HTML、CSS、JavaScript
- **JSON数据**：API响应数据
- **XML文件**：配置文件、数据交换

**❌ 不需要压缩**：
- **图片文件**：JPG、PNG已经压缩过了
- **视频文件**：MP4、AVI等本身就是压缩格式
- **小文件**：压缩反而增加开销

---

## 5. 🎨 静态资源优化


### 5.1 什么是静态资源


> 🖼️ **简单理解**：网页中不会变化的文件，比如图片、CSS、JS文件

**静态资源包括**：
```
🔸 样式文件：.css文件
🔸 脚本文件：.js文件  
🔸 图片文件：.jpg、.png、.gif
🔸 字体文件：.ttf、.woff
🔸 其他媒体：.pdf、.mp4等
```

### 5.2 静态资源优化策略


**🔸 浏览器缓存设置**：
```java
@WebServlet("/static/*")
public class StaticResourceServlet extends HttpServlet {
    
    @Override
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) throws IOException {
        
        String requestURI = request.getRequestURI();
        
        // 设置缓存头，缓存7天
        if (requestURI.endsWith(".css") || requestURI.endsWith(".js")) {
            response.setHeader("Cache-Control", "max-age=604800"); // 7天
        } else if (requestURI.endsWith(".jpg") || requestURI.endsWith(".png")) {
            response.setHeader("Cache-Control", "max-age=2592000"); // 30天
        }
        
        // 读取文件并输出
        // ... 文件读取逻辑
    }
}
```

**🔸 CDN加速**：
```
传统方式：
用户 → 你的服务器 → 返回静态文件

CDN方式：
用户 → 就近的CDN节点 → 返回静态文件（更快！）
```

### 5.3 文件合并与压缩


**CSS/JS文件合并**：
```
优化前：
<link rel="stylesheet" href="style1.css">
<link rel="stylesheet" href="style2.css">
<link rel="stylesheet" href="style3.css">
↓ 3个HTTP请求

优化后：
<link rel="stylesheet" href="all.min.css">
↓ 1个HTTP请求
```

**文件压缩效果对比**：

| 文件类型 | **原始大小** | **压缩后** | **压缩率** |
|---------|------------|-----------|----------|
| JavaScript | 100KB | 35KB | 65% |
| CSS | 50KB | 18KB | 64% |
| HTML | 30KB | 12KB | 60% |

---

## 6. 🚀 并发性能调优


### 6.1 什么是并发性能


> 🏪 **生活类比**：就像超市收银台，一个收银员和十个收银员的服务能力完全不同

**并发的重要性**：
```
单线程处理：
请求1 → 处理3秒 → 请求2 → 处理3秒 → 请求3...
100个请求需要5分钟

多线程处理：
请求1、2、3...同时处理 → 3秒完成
100个请求只需要几十秒
```

### 6.2 Servlet并发机制


**Servlet容器的线程模型**：
```
Tomcat线程池默认配置：
┌─────────────────────┐
│ 核心线程：10个       │
│ 最大线程：200个      │  
│ 队列长度：100个      │
│ 超时时间：60秒       │
└─────────────────────┘
```

**线程池配置优化**：
```xml
<!-- server.xml中的Connector配置 -->
<Connector port="8080" 
           minProcessors="10"     
           maxProcessors="200"    
           acceptCount="100"      
           connectionTimeout="60000"
           protocol="HTTP/1.1" />
```

### 6.3 并发编程注意事项


**✅ 线程安全的做法**：
```java
@WebServlet("/counter")
public class CounterServlet extends HttpServlet {
    // ❌ 错误：实例变量在多线程间共享，不安全
    // private int count = 0;
    
    // ✅ 正确：使用AtomicInteger保证线程安全
    private AtomicInteger count = new AtomicInteger(0);
    
    @Override
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) throws IOException {
        
        // 线程安全的计数操作
        int currentCount = count.incrementAndGet();
        
        response.getWriter().write("访问次数：" + currentCount);
    }
}
```

**🔸 线程安全的几种方式**：
- **无状态设计**：不使用实例变量
- **本地变量**：每个线程独有的栈空间
- **同步机制**：synchronized关键字
- **并发工具**：AtomicInteger、ConcurrentHashMap等

---

## 7. 🧠 内存使用优化


### 7.1 什么是内存优化


> 🏠 **生活类比**：就像整理房间，及时扔掉不用的东西，保持空间整洁

**内存问题的表现**：
```
内存泄漏：
程序运行越久，内存占用越多
最终：OutOfMemoryError错误

内存溢出：
处理大量数据时，一次性占用过多内存
结果：程序崩溃
```

### 7.2 常见内存问题


**🔸 集合类使用不当**：
```java
// ❌ 错误做法：无限制添加数据
public class BadCacheServlet extends HttpServlet {
    private Map<String, Object> cache = new HashMap<>();
    
    @Override
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) {
        String key = request.getParameter("key");
        cache.put(key, "some large data"); // 内存会越来越多
    }
}
```

```java
// ✅ 正确做法：使用LRU缓存限制大小
public class GoodCacheServlet extends HttpServlet {
    private Map<String, Object> cache = new LinkedHashMap<String, Object>(100, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry eldest) {
            return size() > 100; // 限制最大100个元素
        }
    };
}
```

### 7.3 内存优化最佳实践


**🔸 及时释放资源**：
```java
public class FileUploadServlet extends HttpServlet {
    
    @Override
    protected void doPost(HttpServletRequest request, 
                         HttpServletResponse response) throws IOException {
        
        // 使用try-with-resources自动关闭资源
        try (InputStream inputStream = request.getInputStream();
             FileOutputStream outputStream = new FileOutputStream("upload.txt")) {
            
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
            
        } // 这里会自动关闭流，释放内存
    }
}
```

**🔸 避免创建大对象**：
```java
// ❌ 错误：创建大字符串对象
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 100000; i++) {
    sb.append("data" + i); // 频繁扩容，内存浪费
}

// ✅ 正确：预估容量大小
StringBuilder sb = new StringBuilder(500000); // 预分配足够空间
```

### 7.4 内存监控指标


**关键监控指标**：

| 指标 | **正常范围** | **警告值** | **说明** |
|------|------------|----------|----------|
| 堆内存使用率 | < 70% | > 80% | 过高会影响GC性能 |
| GC频率 | < 10次/分钟 | > 30次/分钟 | 频繁GC影响响应时间 |
| 响应时间 | < 200ms | > 1000ms | 用户体验指标 |

---

## 8. 📋 核心要点总结


### 8.1 性能优化核心原则


```
🎯 优化目标：
• 响应更快：用户访问速度提升
• 承载更多：支持更多并发用户
• 资源节约：CPU、内存使用合理
• 稳定运行：减少崩溃和错误
```

### 8.2 六大优化方向总结


**🏊‍♂️ 数据库连接池**：
- **核心思想**：复用连接，避免频繁建立/关闭
- **关键配置**：最大连接数、超时时间、生命周期
- **使用要点**：try-with-resources，及时释放

**🗄️ 缓存机制**：
- **核心思想**：空间换时间，减少重复计算
- **适用场景**：热门数据、计算结果、配置信息
- **更新策略**：定时过期、主动更新、懒加载

**🗜️ 响应压缩**：
- **核心思想**：压缩传输内容，节省带宽
- **适用内容**：HTML、CSS、JS、JSON
- **实现方式**：Gzip过滤器、服务器配置

**🎨 静态资源优化**：
- **核心思想**：缓存静态文件，减少服务器请求
- **优化方法**：浏览器缓存、CDN加速、文件合并
- **缓存策略**：根据文件类型设置不同过期时间

**🚀 并发性能调优**：
- **核心思想**：提高并发处理能力
- **线程安全**：避免共享状态，使用并发工具
- **配置调优**：合理设置线程池参数

**🧠 内存使用优化**：
- **核心思想**：合理使用内存，避免泄漏
- **关键做法**：及时释放资源、限制集合大小、避免大对象
- **监控指标**：堆内存使用率、GC频率、响应时间

### 8.3 最佳实践清单


**✅ 必须做的**：
- [ ] 配置数据库连接池
- [ ] 对热门数据使用缓存
- [ ] 开启Gzip压缩
- [ ] 设置静态资源缓存
- [ ] 使用try-with-resources释放资源
- [ ] 避免在Servlet中使用实例变量

**⚠️ 需要注意的**：
- [ ] 缓存要设置过期时间
- [ ] 集合类要限制大小
- [ ] 定期监控内存使用情况
- [ ] 压测验证优化效果

### 8.4 性能优化效果评估


**🔍 性能测试对比**：
```
优化前：
• 响应时间：3-5秒
• 并发用户：100人就卡顿
• 内存使用：持续增长
• 数据库连接：频繁建立/关闭

优化后：
• 响应时间：0.5-1秒
• 并发用户：支持500+人同时访问
• 内存使用：稳定在合理范围
• 数据库连接：复用连接池
```

**💡 核心记忆口诀**：
```
数据库连接要复用，缓存机制把速度提
响应压缩传输快，静态资源要缓存
并发安全要注意，内存使用需优化
监控指标常关注，性能提升有保证
```

### 8.5 学习进度检查


**🎯 学习目标达成情况**：
- [ ] 理解性能优化的重要性和基本思路
- [ ] 掌握数据库连接池的配置和使用
- [ ] 了解缓存机制的应用场景和实现方式
- [ ] 学会响应压缩和静态资源优化
- [ ] 掌握并发编程的线程安全要点
- [ ] 了解内存优化的最佳实践

**🔥 面试重点**：
- 数据库连接池的作用和配置参数
- 缓存的使用场景和更新策略
- Servlet的线程安全问题
- 常见的内存泄漏场景和解决方案

**🚀 下一步学习**：
学会了性能优化基础后，可以继续学习：
- 分布式缓存（Redis集群）
- 数据库读写分离
- 负载均衡和集群部署
- APM性能监控工具