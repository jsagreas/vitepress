---
title: 3、Servlet映射规则
---
## 📚 目录

1. [映射规则基本概念](#1-映射规则基本概念)
2. [精确匹配机制](#2-精确匹配机制)
3. [路径匹配规则](#3-路径匹配规则)
4. [扩展名匹配方式](#4-扩展名匹配方式)
5. [默认Servlet处理](#5-默认Servlet处理)
6. [匹配优先级策略](#6-匹配优先级策略)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 映射规则基本概念


### 1.1 什么是Servlet映射


**🔸 生活化理解**
想象你去一个大商场，每个店铺都有一个门牌号。当你说"我要去1001号店"时，商场管理系统就知道把你引导到哪里。Servlet映射就是这样的"门牌号系统"。

```
商场类比：
用户请求 = 顾客寻找店铺
URL路径 = 店铺门牌号  
Servlet = 具体的店铺
映射规则 = 门牌号分配规则
```

**🔸 技术定义**
Servlet映射是告诉Web服务器："当用户访问某个特定网址时，应该调用哪个Servlet来处理"的规则系统。

### 1.2 映射配置方式


**📋 配置文件方式(web.xml)**
```xml
<!-- 第一步：声明Servlet -->
<servlet>
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>com.example.HelloServlet</servlet-class>
</servlet>

<!-- 第二步：配置映射关系 -->
<servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/hello</url-pattern>
</servlet-mapping>
```

**📋 注解方式**
```java
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    // Servlet实现代码
}
```

> 💡 **理解要点**  
> 就像给你的房子设置门牌号一样，映射就是给Servlet设置"网络门牌号"，让浏览器能找到它。

### 1.3 映射的作用机制


```
请求处理流程：
浏览器请求 → Web服务器 → 查找映射规则 → 找到对应Servlet → 执行处理逻辑 → 返回响应

例如：
用户输入: http://localhost:8080/myapp/hello
服务器分析: /myapp/hello
匹配规则: /hello → HelloServlet
执行结果: HelloServlet.doGet()方法被调用
```

---

## 2. 🎯 精确匹配机制


### 2.1 精确匹配基本概念


**🔸 什么是精确匹配**
就像你家的门牌号"建设路123号"，必须完全一致才能找到，一个字都不能差。

**🔸 配置示例**
```java
@WebServlet("/user/login")
public class LoginServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, 
                         HttpServletResponse response) {
        // 处理用户登录逻辑
    }
}
```

### 2.2 精确匹配特点


**✅ 匹配成功的情况**
```
配置的映射: /user/login
✅ http://localhost:8080/app/user/login     (完全匹配)
✅ http://localhost:8080/app/user/login?id=1 (参数不影响)
```

**❌ 匹配失败的情况**
```
配置的映射: /user/login
❌ http://localhost:8080/app/user         (路径不完整)
❌ http://localhost:8080/app/user/login/  (多了斜杠)
❌ http://localhost:8080/app/user/Login   (大小写不同)
❌ http://localhost:8080/app/user/login/extra (路径过长)
```

### 2.3 实际应用场景


**🎯 适用情况**
- **专门功能页面**: 登录、注册、支付等
- **API接口**: 需要精确路径的RESTful接口
- **管理页面**: 后台管理的特定功能

```java
// 实际开发示例
@WebServlet("/admin/dashboard")    // 管理员仪表板
@WebServlet("/api/user/profile")   // 用户资料API
@WebServlet("/pay/callback")       // 支付回调
```

---

## 3. 🛤️ 路径匹配规则


### 3.1 路径匹配基本概念


**🔸 生活化理解**
路径匹配就像说"建设路123号到200号之间的所有房子"，用`*`号表示"这一片区域"。

**🔸 通配符规则**
- 必须以`/`开头
- 必须以`/*`结尾
- `*`只能出现在最后

### 3.2 路径匹配配置


**📋 基础配置**
```java
@WebServlet("/user/*")
public class UserServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) {
        
        String pathInfo = request.getPathInfo();
        System.out.println("额外路径信息: " + pathInfo);
        
        // 根据不同路径执行不同逻辑
        if ("/profile".equals(pathInfo)) {
            // 显示用户资料
        } else if ("/settings".equals(pathInfo)) {
            // 用户设置页面
        }
    }
}
```

**✅ 匹配成功示例**
```
配置映射: /user/*

✅ /user/profile        → pathInfo = "/profile"
✅ /user/settings       → pathInfo = "/settings"  
✅ /user/profile/edit   → pathInfo = "/profile/edit"
✅ /user/               → pathInfo = "/"
✅ /user                → pathInfo = null
```

### 3.3 获取路径信息的方法


```java
@WebServlet("/api/*")
public class ApiServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) {
        
        // 获取完整请求URI
        String requestURI = request.getRequestURI();
        
        // 获取Servlet路径部分  
        String servletPath = request.getServletPath();
        
        // 获取额外路径信息
        String pathInfo = request.getPathInfo();
        
        System.out.println("完整URI: " + requestURI);      // /myapp/api/user/123
        System.out.println("Servlet路径: " + servletPath); // /api
        System.out.println("路径信息: " + pathInfo);        // /user/123
    }
}
```

### 3.4 实际应用场景


**🎯 典型用途**
```java
// 用户相关的所有操作
@WebServlet("/user/*")    // /user/login, /user/register, /user/profile

// 产品管理的所有页面
@WebServlet("/product/*") // /product/list, /product/add, /product/edit

// 文件下载服务
@WebServlet("/download/*") // /download/images/logo.png
```

---

## 4. 📄 扩展名匹配方式


### 4.1 扩展名匹配概念


**🔸 生活化理解**
就像文件类型一样，`.txt`是文本文件，`.jpg`是图片文件。扩展名匹配就是说"所有`.do`结尾的请求都交给我处理"。

**🔸 基本规则**
- 必须以`*.`开头
- 不能包含路径分隔符`/`
- 只看文件扩展名，不看路径

### 4.2 扩展名匹配配置


**📋 基础配置**
```java
@WebServlet("*.do")
public class ActionServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) {
        
        String servletPath = request.getServletPath();
        System.out.println("请求路径: " + servletPath);
        
        // 根据不同的.do文件执行不同操作
        if (servletPath.equals("/login.do")) {
            // 处理登录
        } else if (servletPath.equals("/register.do")) {
            // 处理注册  
        }
    }
}
```

**✅ 匹配成功示例**
```
配置映射: *.do

✅ /login.do           → 处理登录请求
✅ /user/register.do   → 处理注册请求
✅ /admin/delete.do    → 处理删除请求
✅ /a/b/c/action.do    → 无论多深的路径都匹配
```

### 4.3 常见扩展名用途


| **扩展名** | **用途说明** | **应用场景** |
|----------|------------|-------------|
| `*.do` | **传统Action处理** | `Struts框架，业务操作` |
| `*.action` | **动作请求** | `Web框架，用户操作` |  
| `*.jsp` | **JSP页面请求** | `动态页面处理` |
| `*.html` | **静态页面请求** | `伪静态URL，SEO优化` |

### 4.4 实际开发示例


```java
// 处理所有Ajax请求
@WebServlet("*.ajax")
public class AjaxServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, 
                         HttpServletResponse response) {
        
        String action = request.getParameter("action");
        
        if ("getUserInfo".equals(action)) {
            // 返回用户信息JSON
        } else if ("saveData".equals(action)) {
            // 保存数据并返回结果
        }
        
        // 设置JSON响应格式
        response.setContentType("application/json;charset=UTF-8");
    }
}
```

---

## 5. 🏠 默认Servlet处理


### 5.1 默认Servlet概念


**🔸 生活化理解**
默认Servlet就像小区的"万能管家"，当其他专门的服务处理不了的事情时，都交给管家来处理。

**🔸 技术定义**
当请求URL无法匹配任何具体的Servlet映射时，系统会将请求交给默认Servlet处理，通常用于处理静态资源。

### 5.2 默认Servlet配置


**📋 配置方式**
```java
@WebServlet("/")  // 注意：这里是 "/" 不是 "/*"
public class DefaultServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, 
                        HttpServletResponse response) {
        
        String requestURI = request.getRequestURI();
        
        // 处理静态资源请求
        if (requestURI.endsWith(".css")) {
            // 处理CSS文件
            response.setContentType("text/css");
        } else if (requestURI.endsWith(".js")) {
            // 处理JavaScript文件  
            response.setContentType("application/javascript");
        } else if (requestURI.endsWith(".jpg") || requestURI.endsWith(".png")) {
            // 处理图片文件
            response.setContentType("image/jpeg");
        }
    }
}
```

### 5.3 默认Servlet工作机制


```
请求处理优先级：
1. 首先查找精确匹配
2. 然后查找路径匹配  
3. 接着查找扩展名匹配
4. 最后交给默认Servlet

示例说明：
请求: /images/logo.png
查找: 没有 /images/logo.png 的精确匹配
查找: 没有 /images/* 的路径匹配
查找: 没有 *.png 的扩展名匹配  
结果: 交给默认Servlet(/)处理
```

### 5.4 web.xml中的默认Servlet


> ⚠️ **重要说明**  
> Tomcat已经内置了默认Servlet来处理静态资源，一般不需要自己重写，除非有特殊需求。

```xml
<!-- Tomcat内置的默认Servlet配置 -->
<servlet>
    <servlet-name>default</servlet-name>
    <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

---

## 6. 🏆 匹配优先级策略


### 6.1 优先级规则概述


**🔸 记忆口诀**
"精确第一，路径第二，扩展名第三，默认垫底"

**🔸 具体优先级顺序**
1. **精确匹配** - 完全相同的路径
2. **最长路径匹配** - 匹配字符最多的路径模式  
3. **扩展名匹配** - 基于文件扩展名
4. **默认Servlet** - 兜底处理机制

### 6.2 优先级实例分析


**📋 配置示例**
```java
@WebServlet("/user/login")     // 精确匹配
@WebServlet("/user/*")         // 路径匹配
@WebServlet("*.do")            // 扩展名匹配  
@WebServlet("/")               // 默认Servlet
```

**🎯 匹配测试**
```
请求URL: /user/login
匹配结果: 精确匹配 /user/login ✅ (优先级最高)

请求URL: /user/profile  
匹配结果: 路径匹配 /user/* ✅ (精确匹配不到，选路径匹配)

请求URL: /admin/save.do
匹配结果: 扩展名匹配 *.do ✅ (前两种都匹配不到)

请求URL: /static/image.png
匹配结果: 默认Servlet / ✅ (其他都匹配不到)
```

### 6.3 路径匹配的长度优先规则


```java
@WebServlet("/user/*")         // 路径长度: /user
@WebServlet("/user/admin/*")   // 路径长度: /user/admin (更长)
```

**测试结果:**
```
请求: /user/admin/dashboard
匹配: /user/admin/* ✅ (更长的路径优先)

请求: /user/profile  
匹配: /user/* ✅ (只有这个能匹配)
```

### 6.4 优先级判断表格


| **请求URL** | **可能匹配的模式** | **实际选择** | **原因** |
|------------|-----------------|-------------|---------|
| `/login` | `精确:/login` `路径:/*` | **精确匹配** | `优先级最高` |
| `/user/info` | `路径:/user/*` `路径:/*` | **/user/*** | `更长路径优先` |
| `/save.do` | `扩展:*.do` `默认:/` | **扩展名匹配** | `扩展名优于默认` |
| `/static/css/style.css` | `默认:/` | **默认Servlet** | `唯一匹配` |

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 精确匹配：完全一致的路径，如 /user/login
🔸 路径匹配：使用 /* 通配符，如 /user/*  
🔸 扩展名匹配：基于文件后缀，如 *.do
🔸 默认Servlet：兜底处理机制，配置为 /
🔸 匹配优先级：精确 > 路径(长优先) > 扩展名 > 默认
```

### 7.2 关键理解要点


**🔹 映射规则的本质**
```
映射规则就是告诉服务器"什么样的请求应该交给哪个Servlet处理"
类似于邮递员根据地址把信件送到正确的邮箱
```

**🔹 通配符使用要点**
```
路径匹配：/path/* (只能在最后)
扩展名匹配：*.ext (只能在开头)  
不能混用：/*.do 是错误的写法 ❌
```

**🔹 实际开发建议**
```
RESTful API → 使用精确匹配
模块化功能 → 使用路径匹配  
文件处理 → 使用扩展名匹配
静态资源 → 依靠默认Servlet
```

### 7.3 常见问题与解决


**❓ 问题1: 为什么我的Servlet匹配不到？**
```
检查清单:
✅ URL路径是否完全正确(大小写敏感)
✅ 是否有拼写错误
✅ 注解或web.xml配置是否正确
✅ 是否被优先级更高的规则覆盖
```

**❓ 问题2: 静态资源访问不到怎么办？**
```
原因分析:
- 可能被自定义的 /* 路径匹配拦截
- 默认Servlet被覆盖

解决方案:
- 避免使用 /* 进行路径匹配
- 或者在自定义Servlet中处理静态资源请求
```

### 7.4 最佳实践建议


**🎯 映射规则设计原则**
- **功能明确**: 每个映射规则职责清晰
- **避免冲突**: 合理规划避免规则重叠  
- **便于维护**: 使用有意义的URL模式
- **SEO友好**: 设计用户和搜索引擎友好的URL

**💡 实际开发技巧**
```java
// ✅ 推荐：功能模块化
@WebServlet("/user/*")    // 用户相关功能
@WebServlet("/product/*") // 产品相关功能  
@WebServlet("/admin/*")   // 管理功能

// ❌ 避免：过度宽泛
@WebServlet("/*")  // 会拦截所有请求，包括静态资源
```

**核心记忆**：
- 映射规则是Servlet的"网络门牌号"
- 优先级决定了请求的最终去向  
- 合理设计映射规则是Web应用的基础
- 实际开发中要考虑维护性和扩展性