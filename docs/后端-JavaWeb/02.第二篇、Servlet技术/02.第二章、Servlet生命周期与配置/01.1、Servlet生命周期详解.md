---
title: 1、Servlet生命周期详解
---
## 📚 目录

1. [Servlet生命周期概述](#1-servlet生命周期概述)
2. [init()初始化阶段](#2-init初始化阶段)
3. [service()服务阶段](#3-service服务阶段)
4. [destroy()销毁阶段](#4-destroy销毁阶段)
5. [Servlet容器管理机制](#5-servlet容器管理机制)
6. [单例模式特性详解](#6-单例模式特性详解)
7. [实例化时机控制](#7-实例化时机控制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 Servlet生命周期概述


### 1.1 什么是Servlet生命周期


**通俗理解**：就像人有出生、成长、工作、死亡的过程一样，Servlet也有自己的"一生"。

```
人的一生：    出生 → 成长 → 工作 → 死亡
Servlet：    创建 → 初始化 → 服务 → 销毁
```

**🔸 核心概念**
- **生命周期**：Servlet从创建到销毁的完整过程
- **容器管理**：这个过程完全由Web容器（如Tomcat）控制
- **开发者职责**：我们只需要实现特定的方法，容器会在合适的时机调用

### 1.2 生命周期三大阶段


```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  初始化阶段  │───→│  服务阶段   │───→│  销毁阶段   │
│   init()   │    │ service()  │    │ destroy() │
│  只执行一次  │    │  重复执行   │    │  只执行一次  │
└─────────────┘    └─────────────┘    └─────────────┘
      ↑                   ↑                   ↑
   服务器启动           处理请求            服务器关闭
```

**💡 关键理解**
- **初始化**：Servlet刚"出生"，需要做准备工作
- **服务**：Servlet的"工作期"，处理用户请求
- **销毁**：Servlet要"退休"了，做收尾工作

---

## 2. 🚀 init()初始化阶段


### 2.1 init()方法的作用


**通俗解释**：就像新员工入职前的培训，Servlet在开始工作前也需要"培训"。

**🔸 什么时候调用**
- 第一次访问Servlet时
- 服务器启动时（如果配置了启动时加载）
- **重要**：整个生命周期只执行**一次**

```java
public void init(ServletConfig config) throws ServletException {
    // 这里写初始化代码
    // 比如：连接数据库、读取配置文件、初始化资源等
}
```

### 2.2 初始化的典型用途


**📋 常见初始化任务**
```
🔸 数据库连接池初始化
🔸 读取配置文件
🔸 初始化缓存
🔸 加载静态数据
🔸 设置日志配置
```

**实际示例**：
```java
public class UserServlet extends HttpServlet {
    private DataSource dataSource;
    
    @Override
    public void init() throws ServletException {
        // 初始化数据源 - 只在第一次访问时执行
        dataSource = createDataSource();
        System.out.println("UserServlet初始化完成");
    }
}
```

### 2.3 init()方法的两个版本


**🔸 带参数版本**
```java
public void init(ServletConfig config) throws ServletException {
    super.init(config); // 必须调用父类方法
    // 可以通过config获取初始化参数
    String dbUrl = config.getInitParameter("dbUrl");
}
```

**🔸 无参数版本（推荐）**
```java
public void init() throws ServletException {
    // 更简洁，通常使用这个版本
    // 初始化代码写在这里
}
```

> 💡 **新手提示**：通常使用无参数的`init()`方法就够了，它更简洁易用。

---

## 3. ⚙️ service()服务阶段


### 3.1 service()方法的核心作用


**通俗理解**：这是Servlet的"主要工作"，就像服务员为每个客户提供服务一样。

**🔸 工作特点**
- **重复执行**：每次用户访问都会调用
- **多线程环境**：多个用户同时访问，会并发执行
- **处理请求**：接收用户请求，返回响应

```
用户请求流程：
浏览器发送请求 → Tomcat接收 → 调用service()方法 → 处理业务逻辑 → 返回响应
```

### 3.2 service()方法的执行机制


**📊 执行过程图解**
```
第1个用户请求 ────→ service()方法执行 ────→ 返回响应
第2个用户请求 ────→ service()方法执行 ────→ 返回响应
第3个用户请求 ────→ service()方法执行 ────→ 返回响应
       ↓                    ↓                  ↓
    并发处理              同一个Servlet实例      多线程执行
```

### 3.3 HttpServlet中的方法分派


**🔸 方法分派机制**
```java
// HttpServlet的service()方法会自动分派到具体方法
GET请求    → doGet()方法
POST请求   → doPost()方法
PUT请求    → doPut()方法
DELETE请求 → doDelete()方法
```

**实际开发示例**：
```java
public class StudentServlet extends HttpServlet {
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        // 处理GET请求 - 通常用于查询数据
        // 比如：显示学生列表
    }
    
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
        // 处理POST请求 - 通常用于提交数据
        // 比如：添加新学生
    }
}
```

> 🤔 **思考题**：为什么不直接重写`service()`方法，而是重写`doGet()`、`doPost()`？
> 
> **答案**：因为HttpServlet已经帮我们做了请求类型的判断和分派，我们只需要实现具体的业务逻辑即可。

---

## 4. 💀 destroy()销毁阶段


### 4.1 destroy()方法的作用


**通俗理解**：就像员工离职前要做交接工作一样，Servlet在"退休"前也要做收尾工作。

**🔸 什么时候调用**
- 服务器正常关闭时
- Web应用卸载时
- Servlet长时间未使用被容器回收时
- **重要**：整个生命周期只执行**一次**

### 4.2 销毁阶段的典型任务


**📋 常见清理工作**
```
🔸 关闭数据库连接
🔸 关闭文件流
🔸 保存重要数据
🔸 释放系统资源
🔸 清理缓存
```

**实际示例**：
```java
public class DataServlet extends HttpServlet {
    private Connection connection;
    
    @Override
    public void init() {
        // 初始化时建立连接
        connection = getConnection();
    }
    
    @Override
    public void destroy() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close(); // 关闭数据库连接
                System.out.println("数据库连接已关闭");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

> ⚠️ **注意事项**：destroy()方法中不要写太耗时的操作，因为容器等待的时间是有限的。

---

## 5. 🏗️ Servlet容器管理机制


### 5.1 什么是容器管理


**通俗解释**：就像公司的人事部门管理员工一样，Servlet容器（如Tomcat）管理所有的Servlet。

```
容器管理职责：
┌─────────────────────────────────────────────────┐
│ 👥 Servlet容器 (Tomcat)                        │
├─────────────────────────────────────────────────┤
│ ✅ 负责创建Servlet实例                           │
│ ✅ 负责调用生命周期方法                         │
│ ✅ 负责管理Servlet的线程安全                    │
│ ✅ 负责处理HTTP请求和响应                       │
│ ✅ 负责URL映射和路由                            │
└─────────────────────────────────────────────────┘
```

### 5.2 容器管理的详细机制


**🔸 创建时机**
1. **懒加载（默认）**：第一次访问时创建
2. **预加载**：服务器启动时创建

**🔸 管理方式**
```
请求处理流程：
用户请求 → 容器检查Servlet是否存在
           ↓
         不存在：创建实例 → 调用init()
           ↓
         存在：直接调用service()
           ↓
         返回响应给用户
```

### 5.3 容器的智能管理


**📊 容器管理特性对比**

| 管理特性 | **传统对象** | **Servlet对象** |
|---------|-------------|----------------|
| **创建方式** | `new 对象()` | `容器自动创建` |
| **生命周期** | `开发者控制` | `容器自动管理` |
| **线程安全** | `自己处理` | `容器协调` |
| **资源管理** | `手动释放` | `容器自动清理` |

---

## 6. 🎯 单例模式特性详解


### 6.1 什么是Servlet的单例特性


**通俗理解**：一个Servlet类在整个Web应用中只有一个实例，就像公司只有一个总经理一样。

```
传统对象创建：
UserServlet s1 = new UserServlet(); // 实例1
UserServlet s2 = new UserServlet(); // 实例2
UserServlet s3 = new UserServlet(); // 实例3

Servlet容器管理：
UserServlet唯一实例 ─────┐
                      │
        ┌─────────────┼─────────────┐
        ↓             ↓             ↓
      请求1          请求2          请求3
     (线程1)       (线程2)       (线程3)
```

### 6.2 单例模式的优缺点分析


**✅ 优点**
```
🔸 节省内存：只创建一个实例
🔸 提高性能：避免重复创建对象的开销
🔸 共享资源：可以共享实例变量
🔸 统一管理：容器统一管理生命周期
```

**⚠️ 潜在问题**
```
🔸 线程安全：多个线程同时访问同一个实例
🔸 状态共享：实例变量会被所有请求共享
🔸 内存泄露：长期持有大对象的引用
```

### 6.3 线程安全问题及解决方案


**🚨 危险的写法**
```java
public class CounterServlet extends HttpServlet {
    private int count = 0; // 实例变量 - 危险！
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        count++; // 多线程不安全
        resp.getWriter().println("访问次数：" + count);
    }
}
```

**✅ 安全的写法**
```java
public class SafeCounterServlet extends HttpServlet {
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        int count = getCountFromDatabase(); // 局部变量 - 安全
        count++;
        saveCountToDatabase(count);
        resp.getWriter().println("访问次数：" + count);
    }
}
```

> 💡 **新手要点**：避免使用实例变量存储请求相关的数据，使用局部变量或从外部存储（如数据库、Session）获取数据。

---

## 7. ⏰ 实例化时机控制


### 7.1 两种实例化时机


**🔸 懒加载（默认方式）**
```
服务器启动 → 用户首次访问 → 创建Servlet实例 → 调用init()
```

**🔸 预加载（启动时加载）**
```
服务器启动 → 立即创建Servlet实例 → 调用init()
```

### 7.2 配置实例化时机


**📝 web.xml配置方式**
```xml
<servlet>
    <servlet-name>InitServlet</servlet-name>
    <servlet-class>com.example.InitServlet</servlet-class>
    <load-on-startup>1</load-on-startup> <!-- 启动时加载 -->
</servlet>
```

**📝 注解配置方式**
```java
@WebServlet(
    urlPatterns = "/init",
    loadOnStartup = 1  // 启动时加载
)
public class InitServlet extends HttpServlet {
    // Servlet代码
}
```

### 7.3 load-on-startup参数详解


**🔢 参数值含义**
```
负数或不配置：懒加载（默认）
0或正整数：预加载，数字越小优先级越高

示例：
loadOnStartup = 1  // 第一个加载
loadOnStartup = 2  // 第二个加载
loadOnStartup = 5  // 第五个加载
```

**⚖️ 选择建议**

| 场景 | **推荐方式** | **原因** |
|------|-------------|----------|
| **普通业务Servlet** | `懒加载` | `节省启动时间和内存` |
| **初始化耗时的Servlet** | `预加载` | `避免首次访问延迟` |
| **系统核心服务** | `预加载` | `确保服务可用性` |
| **工具类Servlet** | `懒加载` | `按需使用即可` |

---

## 8. 📋 核心要点总结


### 8.1 生命周期三阶段记忆要点


```
🧠 记忆口诀
init一次做准备，service重复来服务
destroy最后做清理，容器管理很省心
```

**🔸 关键理解**
- **init()**：生命周期开始，只执行一次，做初始化工作
- **service()**：生命周期主体，重复执行，处理用户请求
- **destroy()**：生命周期结束，只执行一次，做清理工作

### 8.2 容器管理机制要点


```
📊 管理职责分工
┌─────────────────┬─────────────────┐
│   容器负责       │   开发者负责     │
├─────────────────┼─────────────────┤
│ 创建Servlet实例  │ 实现业务逻辑     │
│ 管理生命周期     │ 处理请求响应     │
│ 处理多线程       │ 确保线程安全     │
│ URL路由映射      │ 配置映射关系     │
└─────────────────┴─────────────────┘
```

### 8.3 单例模式安全编程


**✅ 最佳实践**
```
🔸 避免使用实例变量存储请求数据
🔸 使用局部变量处理请求相关信息
🔸 共享资源（如数据源）可用实例变量
🔸 注意线程安全，必要时使用同步机制
```

**❌ 常见错误**
```
🔸 用实例变量存储用户输入
🔸 在实例变量中缓存请求相关数据
🔸 不考虑多线程并发问题
🔸 在destroy()中执行耗时操作
```

### 8.4 实际开发应用价值


**🎯 业务开发指导**
- **数据库连接**：在init()中初始化连接池，destroy()中关闭
- **配置管理**：启动时读取配置文件，运行时使用配置
- **缓存管理**：初始化缓存，定期更新，关闭时保存
- **性能优化**：合理使用预加载，避免首次访问延迟

**🔧 调试技巧**
- **生命周期日志**：在三个方法中添加日志，观察执行时机
- **线程安全测试**：使用JMeter等工具进行并发测试
- **资源监控**：监控内存使用，检查是否有资源泄露

**核心记忆**：
- Servlet生命周期由容器完全管理，开发者实现业务逻辑
- 单例模式提高性能，但要注意线程安全问题
- init和destroy只执行一次，service重复执行
- 合理配置实例化时机，平衡启动速度和响应性能