---
title: 3、结果集处理
---
## 📚 目录

1. [什么是结果集处理](#1-什么是结果集处理)
2. [ResultSet遍历显示](#2-ResultSet遍历显示)
3. [数据类型转换](#3-数据类型转换)
4. [分页查询实现](#4-分页查询实现)
5. [数据封装到JavaBean](#5-数据封装到JavaBean)
6. [异常处理最佳实践](#6-异常处理最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 什么是结果集处理


### 1.1 结果集的概念


**💡 通俗理解**
> 想象你去图书馆查资料，管理员给你一摞符合条件的书。**ResultSet就是这摞书**，你需要一本一本地翻阅（遍历），从每本书中提取需要的信息（获取数据）。

**🔸 专业定义**
ResultSet是Java数据库操作中用来**存储查询结果的对象**，它就像一个**可以移动的表格指针**，帮我们逐行读取数据库查询的结果。

**📊 结果集的特点**
```
数据库表：        ResultSet：
┌─────┬─────┐     ┌─────┬─────┐
│ id  │name │ →  │指针 │当前行│
├─────┼─────┤     ├─────┼─────┤
│ 1   │张三 │     │  ↓  │ 1,张三│
│ 2   │李四 │     │     │ 2,李四│
│ 3   │王五 │     │     │ 3,王五│
└─────┴─────┘     └─────┴─────┘

特点：一次只能看一行，需要移动指针查看其他行
```

### 1.2 为什么需要结果集处理


**🤔 问题场景**
```
用户搜索：查找所有年龄大于25岁的用户
数据库返回：可能有几十、几百条记录
问题：如何把这些数据显示在网页上？
解决：就需要结果集处理！
```

**🎯 处理目标**
- **遍历数据**：把所有查询结果都看一遍
- **提取信息**：从每条记录中获取需要的字段
- **格式转换**：把数据库的数据转换成网页能显示的格式
- **异常处理**：处理可能出现的各种错误

---

## 2. 🔍 ResultSet遍历显示


### 2.1 基本遍历方法


**📝 核心概念**
ResultSet就像一个**只能向前移动的书签**，你需要用`next()`方法一页页地翻。

```java
// 🎯 基本遍历模板
while(resultSet.next()) {
    // 读取当前行的数据
    String name = resultSet.getString("name");
    int age = resultSet.getInt("age");
    
    // 显示或处理数据
    out.println("姓名：" + name + "，年龄：" + age);
}
```

### 2.2 在JSP中显示数据


**🌟 完整示例：显示用户列表**

```jsp
<%
// 1️⃣ 建立数据库连接（省略连接代码）
String sql = "SELECT id, name, age, email FROM users";
PreparedStatement pstmt = conn.prepareStatement(sql);
ResultSet rs = pstmt.executeQuery();
%>

<table border="1">
    <tr>
        <th>ID</th><th>姓名</th><th>年龄</th><th>邮箱</th>
    </tr>
    <%
    // 2️⃣ 遍历结果集，生成表格行
    while(rs.next()) {
        int id = rs.getInt("id");
        String name = rs.getString("name");
        int age = rs.getInt("age"); 
        String email = rs.getString("email");
    %>
    <tr>
        <td><%= id %></td>
        <td><%= name %></td>
        <td><%= age %></td>
        <td><%= email %></td>
    </tr>
    <% } %>
</table>
```

**💡 生活化理解**
```
这就像：
📋 老师点名册 → 数据库表
👨‍🏫 老师念名字 → ResultSet.next()
📝 记录出席情况 → 在网页上显示

每次调用next()，就像老师念下一个学生的名字
```

### 2.3 不同的显示方式


**📱 列表显示方式**
```jsp
<ul>
<%
while(rs.next()) {
    String name = rs.getString("name");
    int age = rs.getInt("age");
%>
    <li><%= name %>（<%= age %>岁）</li>
<% } %>
</ul>
```

**🎯 关键要点**
- `while(rs.next())`是固定写法，记住就行
- 每次`next()`会移动到下一行，返回`true`表示还有数据
- 字段名要和数据库表的列名一致

---

## 3. 🔄 数据类型转换


### 3.1 数据库类型与Java类型对应


**📊 常用类型对应表**

| 数据库类型 | Java获取方法 | 说明 | 示例 |
|-----------|-------------|------|------|
| `INT` | `getInt()` | 整数 | `rs.getInt("age")` |
| `VARCHAR` | `getString()` | 字符串 | `rs.getString("name")` |
| `DOUBLE` | `getDouble()` | 小数 | `rs.getDouble("price")` |
| `DATE` | `getDate()` | 日期 | `rs.getDate("birthday")` |
| `BOOLEAN` | `getBoolean()` | 布尔值 | `rs.getBoolean("is_active")` |

### 3.2 类型转换实例


**🎯 实际应用示例**

```java
<%
// 假设数据库有商品表：products(id, name, price, create_date, is_active)
while(rs.next()) {
    // 🔸 基本类型转换
    int productId = rs.getInt("id");                    // 整数
    String productName = rs.getString("name");           // 字符串
    double price = rs.getDouble("price");               // 价格(小数)
    Date createDate = rs.getDate("create_date");        // 日期
    boolean isActive = rs.getBoolean("is_active");      // 是否启用
    
    // 🔸 格式化显示
    DecimalFormat df = new DecimalFormat("#.##");       // 格式化价格
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // 格式化日期
%>
    <p>
        商品：<%= productName %> | 
        价格：￥<%= df.format(price) %> | 
        上架时间：<%= sdf.format(createDate) %> | 
        状态：<%= isActive ? "启用" : "停用" %>
    </p>
<% } %>
```

### 3.3 空值处理


**⚠️ 空值问题**
数据库中的`NULL`值需要特别处理，否则可能出错。

```java
<%
while(rs.next()) {
    String email = rs.getString("email");
    
    // ❌ 直接使用可能出错
    // out.println("邮箱长度：" + email.length());
    
    // ✅ 正确的处理方式
    if(email != null) {
        out.println("邮箱：" + email);
    } else {
        out.println("邮箱：未填写");
    }
    
    // 🎯 更简洁的写法
    String displayEmail = (email != null) ? email : "未填写";
    out.println("邮箱：" + displayEmail);
}
%>
```

**💡 记忆技巧**
> 数据库的NULL就像空盒子，你不能直接使用盒子里的东西，要先检查盒子里是否有东西。

---

## 4. 📄 分页查询实现


### 4.1 为什么需要分页


**🤔 问题场景**
```
没有分页：
数据库有10000条用户记录 → 一次性显示10000行 → 网页卡死！

有分页：
第1页显示1-20条 → 用户点击下一页 → 显示21-40条
```

**💡 分页的好处**
- **提升性能**：一次只查询少量数据
- **改善体验**：页面加载更快
- **节省流量**：减少数据传输

### 4.2 分页原理


**📊 分页计算公式**
```
总记录数：totalRecords = 1000条
每页显示：pageSize = 20条  
当前页码：currentPage = 3

计算：
总页数 = Math.ceil(totalRecords / pageSize) = 50页
跳过记录数 = (currentPage - 1) × pageSize = 40条
查询语句：LIMIT 40, 20  (跳过40条，取20条)
```

**🎯 数据库分页语句**
```sql
-- MySQL分页语句
SELECT * FROM users 
ORDER BY id 
LIMIT 起始位置, 每页数量;

-- 例子：获取第3页数据（每页20条）
SELECT * FROM users 
ORDER BY id 
LIMIT 40, 20;
```

### 4.3 JSP分页完整实现


```jsp
<%
// 🔸 获取分页参数
String pageStr = request.getParameter("page");
int currentPage = (pageStr != null) ? Integer.parseInt(pageStr) : 1;
int pageSize = 10;  // 每页显示10条

// 🔸 计算分页信息
int startIndex = (currentPage - 1) * pageSize;

// 🔸 查询总记录数
String countSql = "SELECT COUNT(*) FROM users";
PreparedStatement countStmt = conn.prepareStatement(countSql);
ResultSet countRs = countStmt.executeQuery();
countRs.next();
int totalRecords = countRs.getInt(1);
int totalPages = (int)Math.ceil((double)totalRecords / pageSize);

// 🔸 查询当前页数据
String dataSql = "SELECT id, name, age FROM users LIMIT ?, ?";
PreparedStatement dataStmt = conn.prepareStatement(dataSql);
dataStmt.setInt(1, startIndex);
dataStmt.setInt(2, pageSize);
ResultSet dataRs = dataStmt.executeQuery();
%>

<!-- 显示数据 -->
<table border="1">
    <tr><th>ID</th><th>姓名</th><th>年龄</th></tr>
    <%
    while(dataRs.next()) {
        int id = dataRs.getInt("id");
        String name = dataRs.getString("name");
        int age = dataRs.getInt("age");
    %>
    <tr>
        <td><%= id %></td>
        <td><%= name %></td>
        <td><%= age %></td>
    </tr>
    <% } %>
</table>

<!-- 🔸 分页导航 -->
<div>
    <p>共<%= totalRecords %>条记录，第<%= currentPage %>/<%= totalPages %>页</p>
    
    <!-- 上一页 -->
    <% if(currentPage > 1) { %>
        <a href="?page=<%= currentPage-1 %>">上一页</a>
    <% } %>
    
    <!-- 页码链接 -->
    <% for(int i = 1; i <= totalPages; i++) { %>
        <% if(i == currentPage) { %>
            <strong><%= i %></strong>
        <% } else { %>
            <a href="?page=<%= i %>"><%= i %></a>
        <% } %>
    <% } %>
    
    <!-- 下一页 -->
    <% if(currentPage < totalPages) { %>
        <a href="?page=<%= currentPage+1 %>">下一页</a>
    <% } %>
</div>
```

**💡 分页流程图**
```
用户请求第3页
       ↓
计算跳过记录数 (2×10=20)
       ↓  
查询数据库 LIMIT 20,10
       ↓
获取第21-30条记录
       ↓
显示在网页上
```

---

## 5. 📦 数据封装到JavaBean


### 5.1 什么是JavaBean


**💡 通俗理解**
> JavaBean就像一个**标准的收纳盒**，专门用来装数据。比如用户信息收纳盒、商品信息收纳盒等。每个盒子都有标准的取放数据的方法。

**🔸 JavaBean的特点**
- **私有属性**：数据隐藏在盒子里，外面看不到
- **公共方法**：提供标准的存取方法（getter/setter）
- **无参构造器**：可以创建空盒子
- **便于管理**：数据和操作封装在一起

### 5.2 创建用户JavaBean


**📝 User.java - 用户信息收纳盒**
```java
public class User {
    // 🔸 私有属性（数据藏在盒子里）
    private int id;
    private String name;
    private int age;
    private String email;
    private Date createTime;
    
    // 🔸 无参构造器（创建空盒子）
    public User() {}
    
    // 🔸 全参构造器（创建装满数据的盒子）
    public User(int id, String name, int age, String email, Date createTime) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.email = email;
        this.createTime = createTime;
    }
    
    // 🔸 getter方法（从盒子里取数据）
    public int getId() { return id; }
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
    public Date getCreateTime() { return createTime; }
    
    // 🔸 setter方法（往盒子里放数据）
    public void setId(int id) { this.id = id; }
    public void setName(String name) { this.name = name; }
    public void setAge(int age) { this.age = age; }
    public void setEmail(String email) { this.email = email; }
    public void setCreateTime(Date createTime) { this.createTime = createTime; }
}
```

### 5.3 ResultSet数据装入JavaBean


**🎯 数据装盒过程**

```jsp
<%
// 🔸 准备一个装用户的盒子（List）
List<User> userList = new ArrayList<>();

String sql = "SELECT id, name, age, email, create_time FROM users";
PreparedStatement pstmt = conn.prepareStatement(sql);
ResultSet rs = pstmt.executeQuery();

// 🔸 遍历结果集，把每条记录装成一个User对象
while(rs.next()) {
    // 创建一个新的用户盒子
    User user = new User();
    
    // 从ResultSet取出数据，装进用户盒子
    user.setId(rs.getInt("id"));
    user.setName(rs.getString("name"));
    user.setAge(rs.getInt("age"));
    user.setEmail(rs.getString("email"));
    user.setCreateTime(rs.getDate("create_time"));
    
    // 把装好的用户盒子放进用户列表
    userList.add(user);
}

// 🔸 现在我们有了一个装满User对象的列表
request.setAttribute("userList", userList);
%>
```

### 5.4 在JSP中使用JavaBean


**🌟 显示封装好的数据**

```jsp
<!-- 🔸 使用EL表达式显示JavaBean数据 -->
<table border="1">
    <tr><th>ID</th><th>姓名</th><th>年龄</th><th>邮箱</th><th>注册时间</th></tr>
    
    <!-- 🔸 使用JSTL循环显示用户列表 -->
    <c:forEach var="user" items="${userList}">
        <tr>
            <td>${user.id}</td>
            <td>${user.name}</td>
            <td>${user.age}</td>
            <td>${user.email}</td>
            <td><fmt:formatDate value="${user.createTime}" pattern="yyyy-MM-dd"/></td>
        </tr>
    </c:forEach>
</table>

<!-- 🔸 或者使用传统JSP脚本 -->
<% 
List<User> users = (List<User>)request.getAttribute("userList");
for(User user : users) {
%>
    <p>
        用户：<%= user.getName() %>（<%= user.getAge() %>岁）
        联系方式：<%= user.getEmail() %>
    </p>
<% } %>
```

**💡 JavaBean的优势**
```
不用JavaBean：
ResultSet → 直接取值 → 显示（数据散乱）

使用JavaBean：
ResultSet → 装进User对象 → 整齐的用户列表（数据有序）

就像：散装的衣服 vs 整理好的衣柜
```

---

## 6. ⚠️ 异常处理最佳实践


### 6.1 数据库操作常见异常


**🚨 可能出现的问题**
- **连接异常**：数据库服务器连不上
- **SQL异常**：SQL语句写错了  
- **数据异常**：数据类型不匹配
- **空指针异常**：ResultSet为空时操作

### 6.2 完整的异常处理模式


```jsp
<%
Connection conn = null;
PreparedStatement pstmt = null; 
ResultSet rs = null;
List<User> userList = new ArrayList<>();

try {
    // 🔸 建立数据库连接
    conn = DriverManager.getConnection(
        "jdbc:mysql://localhost:3306/mydb", "root", "password");
    
    // 🔸 准备和执行查询
    String sql = "SELECT id, name, age, email FROM users";
    pstmt = conn.prepareStatement(sql);
    rs = pstmt.executeQuery();
    
    // 🔸 处理结果集
    while(rs.next()) {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        user.setAge(rs.getInt("age"));
        
        // 🔸 处理可能为空的字段
        String email = rs.getString("email");
        user.setEmail(email != null ? email : "未设置邮箱");
        
        userList.add(user);
    }
    
    request.setAttribute("userList", userList);
    request.setAttribute("message", "数据加载成功");
    
} catch (SQLException e) {
    // 🔸 数据库操作异常
    request.setAttribute("error", "数据库操作失败：" + e.getMessage());
    e.printStackTrace();
    
} catch (Exception e) {
    // 🔸 其他异常
    request.setAttribute("error", "系统异常：" + e.getMessage());
    e.printStackTrace();
    
} finally {
    // 🔸 确保资源释放（重要！）
    try {
        if(rs != null) rs.close();
        if(pstmt != null) pstmt.close();
        if(conn != null) conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
%>

<!-- 🔸 显示错误信息 -->
<% if(request.getAttribute("error") != null) { %>
    <div style="color:red; background:#ffe6e6; padding:10px; border:1px solid #ff9999;">
        ❌ <%= request.getAttribute("error") %>
    </div>
<% } %>

<!-- 🔸 显示成功信息 -->
<% if(request.getAttribute("message") != null) { %>
    <div style="color:green; background:#e6ffe6; padding:10px; border:1px solid #99ff99;">
        ✅ <%= request.getAttribute("message") %>
    </div>
<% } %>
```

### 6.3 用户友好的错误提示


**🎯 错误信息分层处理**

```jsp
<%
// 🔸 定义错误处理方法
public String getFriendlyErrorMessage(SQLException e) {
    String errorCode = e.getSQLState();
    switch(errorCode) {
        case "08001": return "无法连接到数据库，请检查网络";
        case "42S02": return "数据表不存在，请联系管理员";
        case "23000": return "数据冲突，该记录已存在";
        default: return "系统繁忙，请稍后重试";
    }
}

try {
    // ... 数据库操作代码 ...
    
} catch (SQLException e) {
    // 🔸 记录详细错误到日志
    System.err.println("数据库错误详情：" + e.getMessage());
    
    // 🔸 给用户显示友好提示
    String friendlyMessage = getFriendlyErrorMessage(e);
    request.setAttribute("userError", friendlyMessage);
}
%>

<!-- 用户看到的错误提示 -->
<% if(request.getAttribute("userError") != null) { %>
    <div class="error-box">
        <h4>😔 操作失败</h4>
        <p><%= request.getAttribute("userError") %></p>
        <button onclick="history.back()">返回重试</button>
    </div>
<% } %>
```

**💡 异常处理原则**
```
对开发者：显示详细错误信息，便于调试
对用户：显示友好提示，不暴露技术细节

就像：
医生看病历（详细） vs 告诉患者病情（通俗）
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 ResultSet遍历：使用while(rs.next())循环读取每一行数据
🔸 数据类型转换：getString()、getInt()、getDate()等方法对应不同数据类型
🔸 分页查询：通过LIMIT实现分页，提升性能和用户体验
🔸 JavaBean封装：将散乱的数据组织成结构化的对象
🔸 异常处理：确保程序稳定运行，资源正确释放
```

### 7.2 实际开发要点


**🎯 性能优化**
- **分页查询**：避免一次加载大量数据
- **连接池**：复用数据库连接，提升效率
- **索引优化**：在常查询字段上建立索引

**🔧 代码规范**
- **资源释放**：finally块中关闭连接
- **异常处理**：分层处理，用户友好
- **数据封装**：使用JavaBean组织数据

**💡 学习进阶路线**
```
基础 ⭐
掌握ResultSet基本遍历和数据获取

进阶 ⭐⭐
实现分页查询和JavaBean封装

高级 ⭐⭐⭐
连接池、缓存、性能优化
```

### 7.3 记忆要点


**🎯 核心代码模式**
```java
// 万能模式：try-catch-finally
try {
    // 连接数据库
    // 执行查询
    // 处理结果集
} catch (Exception e) {
    // 错误处理
} finally {
    // 释放资源
}
```

**📝 结果集处理步骤**
```
1. 执行SQL查询 → 得到ResultSet
2. while(rs.next()) → 遍历每一行
3. rs.getXXX() → 获取字段值
4. 处理/显示数据 → 封装或直接使用
5. 关闭资源 → 避免内存泄漏
```

**💡 最佳实践口诀**
> 连接要关闭，异常要处理  
> 分页提性能，封装更整洁  
> 用户要友好，开发要严谨