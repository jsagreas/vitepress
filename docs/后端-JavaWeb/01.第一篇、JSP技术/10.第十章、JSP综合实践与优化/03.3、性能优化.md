---
title: 3、性能优化
---
## 📚 目录

1. [JSP性能优化概述](#1-JSP性能优化概述)
2. [减少脚本片段使用](#2-减少脚本片段使用)
3. [静态包含vs动态包含选择](#3-静态包含vs动态包含选择)
4. [缓存策略应用](#4-缓存策略应用)
5. [资源压缩与合并](#5-资源压缩与合并)
6. [数据库连接优化](#6-数据库连接优化)
7. [综合优化实践](#7-综合优化实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 JSP性能优化概述


### 1.1 为什么需要性能优化


> 💡 **生活类比**  
> JSP性能优化就像装修房子，刚开始能住，但要住得舒服、高效，就需要不断改进布局和设施

**性能问题的常见表现：**
- 🐌 页面加载缓慢，用户等待时间长
- 🔥 服务器CPU占用率过高
- 💾 内存使用量不断增长
- 📊 数据库查询响应慢

**优化的核心目标：**
```
🎯 用户体验提升：页面响应更快
🎯 服务器资源节省：CPU、内存使用更合理  
🎯 并发能力增强：同时处理更多用户请求
🎯 系统稳定性：减少崩溃和异常
```

### 1.2 JSP性能优化的基本思路


**优化金字塔模型：**
```
           🏆 用户体验
          ↗️           ↖️
    🔧 前端优化     🗄️ 后端优化
   ↗️        ↖️   ↗️        ↖️
静态资源    页面渲染  数据库    服务器
优化        优化     优化      配置
```

---

## 2. ✂️ 减少脚本片段使用


### 2.1 脚本片段的性能问题


> 📖 **核心概念**  
> **脚本片段**（Scriptlet）是JSP页面中用 `<% %>` 包围的Java代码，虽然灵活但会影响性能

**为什么脚本片段影响性能？**

```
问题1：代码混乱 ❌
JSP页面变成：HTML + Java代码大杂烩
阅读困难，维护成本高

问题2：编译效率低 ❌  
每次修改脚本片段，整个JSP都需要重新编译
开发和部署都变慢

问题3：缓存困难 ❌
包含大量动态脚本的页面难以缓存
无法享受缓存带来的性能提升
```

### 2.2 脚本片段的替代方案


**🔄 优化对比实例**

❌ **传统脚本片段写法：**
```jsp
<%-- 性能较差的写法 --%>
<html>
<body>
    <% 
    String userName = (String)request.getAttribute("userName");
    if(userName != null && !userName.isEmpty()) {
    %>
        <h1>欢迎您，<%= userName %></h1>
        <% 
        List<String> hobbies = (List<String>)request.getAttribute("hobbies");
        for(String hobby : hobbies) {
        %>
            <p>爱好：<%= hobby %></p>
        <% } %>
    <% } %>
</body>
</html>
```

✅ **使用EL表达式和JSTL优化：**
```jsp
<%-- 性能更好的写法 --%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<html>
<body>
    <c:if test="${not empty userName}">
        <h1>欢迎您，${userName}</h1>
        <c:forEach items="${hobbies}" var="hobby">
            <p>爱好：${hobby}</p>
        </c:forEach>
    </c:if>
</body>
</html>
```

**📊 性能提升对比：**

| 优化项目 | 脚本片段方式 | EL+JSTL方式 | **性能提升** |
|---------|-------------|-------------|-------------|
| 🕒 编译时间 | `较慢` | `更快` | **提升30-50%** |
| 👁️ 代码可读性 | `混乱` | `清晰` | **大幅提升** |
| 🔧 维护难度 | `困难` | `简单` | **显著降低** |
| 💨 缓存友好性 | `差` | `好` | **明显改善** |

### 2.3 实用优化技巧


**🎯 替换策略**

1️⃣ **条件判断替换**
```jsp
<!-- 旧方式 -->
<% if(user.getAge() >= 18) { %>
    <p>成年用户</p>
<% } %>

<!-- 新方式 -->
<c:if test="${user.age >= 18}">
    <p>成年用户</p>
</c:if>
```

2️⃣ **循环遍历替换**  
```jsp
<!-- 旧方式 -->
<% for(Product product : products) { %>
    <div><%= product.getName() %></div>
<% } %>

<!-- 新方式 -->
<c:forEach items="${products}" var="product">
    <div>${product.name}</div>
</c:forEach>
```

3️⃣ **数据格式化替换**
```jsp
<!-- 旧方式 -->
<%= new SimpleDateFormat("yyyy-MM-dd").format(date) %>

<!-- 新方式 -->
<fmt:formatDate value="${date}" pattern="yyyy-MM-dd"/>
```

> 🧠 **记忆口诀**：脚本片段要少用，EL表达式更轻松

---

## 3. 📄 静态包含vs动态包含选择


### 3.1 包含方式的本质区别


> 💡 **生活类比**  
> - **静态包含**像复制粘贴，把内容直接合并到一个文档里
> - **动态包含**像引用链接，需要时再去获取内容

**📊 两种包含方式对比表：**

| 特征 | **静态包含**<br/>`<%@ include %>` | **动态包含**<br/>`<jsp:include>` |
|------|----------------------------------|----------------------------------|
| ⏱️ **编译时机** | `编译时合并` | `运行时调用` |
| 🔄 **灵活性** | `固定内容` | `可传递参数` |
| 🚀 **性能** | `更快` | `相对较慢` |
| 🔧 **内存占用** | `较少` | `较多` |
| 📝 **适用场景** | `通用页头页尾` | `动态内容模块` |

### 3.2 静态包含的性能优势


**🔥 静态包含工作原理：**
```
编译阶段：
main.jsp + header.jsp + footer.jsp → 合并成一个Servlet类

运行阶段：
用户请求 → 直接执行合并后的Servlet → 返回结果

优势：只有一次方法调用，执行效率高
```

**实例演示：**
```jsp
<%-- main.jsp 使用静态包含 --%>
<!DOCTYPE html>
<html>
<%@ include file="common/header.jsp" %>
<body>
    <div class="main-content">
        <h2>主要内容</h2>
        <p>这是页面的主体内容</p>
    </div>
    <%@ include file="common/footer.jsp" %>
</body>
</html>
```

### 3.3 动态包含的使用场景


**🎯 什么时候选择动态包含？**

✅ **需要传递参数的情况：**
```jsp
<%-- 动态包含商品列表，传递分类参数 --%>
<jsp:include page="productList.jsp">
    <jsp:param name="category" value="electronics"/>
    <jsp:param name="pageSize" value="10"/>
</jsp:include>
```

✅ **根据条件包含不同页面：**
```jsp
<c:choose>
    <c:when test="${user.vip}">
        <jsp:include page="vipContent.jsp"/>
    </c:when>
    <c:otherwise>
        <jsp:include page="normalContent.jsp"/>
    </c:otherwise>
</c:choose>
```

### 3.4 包含方式选择指南


**🎯 选择决策树：**
```
包含的内容是否需要传递参数？
├── 否 → 内容是否经常变化？
│   ├── 否 → ✅ 使用静态包含（最佳性能）
│   └── 是 → 🤔 考虑动态包含或缓存策略
└── 是 → ✅ 使用动态包含（功能需要）
```

> 💡 **最佳实践建议**：
> - 通用的页头、页尾 → 静态包含
> - 导航菜单、版权信息 → 静态包含  
> - 需要传参的组件 → 动态包含
> - 个性化内容模块 → 动态包含

---

## 4. 💾 缓存策略应用


### 4.1 JSP缓存的重要性


> 📖 **核心概念**  
> **缓存**就像把常用的东西放在触手可及的地方，下次需要时不用重新制作，直接拿来用

**缓存能解决什么问题？**
```
🐌 问题：每次请求都要重新生成页面
⚡ 解决：把生成好的页面保存起来，直接返回

🔥 问题：数据库查询太频繁
💾 解决：把查询结果缓存在内存中

⏳ 问题：复杂计算耗时太长  
🚀 解决：把计算结果缓存起来重复使用
```

### 4.2 JSP页面级缓存


**🎯 HTTP缓存头设置**

```jsp
<%-- 设置页面缓存策略 --%>
<%
    // 设置缓存时间为1小时
    response.setDateHeader("Expires", System.currentTimeMillis() + 3600 * 1000);
    // 设置Cache-Control
    response.setHeader("Cache-Control", "public, max-age=3600");
    // 设置ETag用于缓存验证
    response.setHeader("ETag", "\"page-version-1.0\"");
%>
```

**📊 缓存类型选择指南：**

| 页面类型 | 缓存策略 | 缓存时间 | **说明** |
|---------|---------|---------|---------|
| 🏠 **首页** | `强缓存` | `30分钟` | `内容更新不频繁` |
| 📰 **新闻列表** | `协商缓存` | `5分钟` | `需要及时更新` |
| 👤 **用户资料** | `私有缓存` | `10分钟` | `个人专属内容` |
| 🛒 **购物车** | `无缓存` | `0分钟` | `实时性要求高` |

### 4.3 数据级缓存实现


**🔧 使用应用范围缓存数据**

```jsp
<%-- 缓存商品分类数据示例 --%>
<%
    // 检查应用缓存中是否有数据
    List<Category> categories = (List<Category>)application.getAttribute("categories");
    
    if(categories == null) {
        // 缓存中没有，从数据库获取
        CategoryService service = new CategoryService();
        categories = service.getAllCategories();
        
        // 存入应用缓存，所有用户共享
        application.setAttribute("categories", categories);
        
        // 设置缓存更新时间标记
        application.setAttribute("categories_update_time", System.currentTimeMillis());
    }
%>

<%-- 显示缓存的分类数据 --%>
<c:forEach items="${applicationScope.categories}" var="category">
    <a href="products.jsp?categoryId=${category.id}">${category.name}</a>
</c:forEach>
```

**⏰ 缓存过期处理**

```jsp
<%-- 带过期时间的缓存示例 --%>
<%
    final long CACHE_EXPIRE_TIME = 30 * 60 * 1000; // 30分钟过期
    
    Long lastUpdateTime = (Long)application.getAttribute("data_update_time");
    List<Product> hotProducts = (List<Product>)application.getAttribute("hot_products");
    
    // 检查缓存是否过期
    if(lastUpdateTime == null || 
       System.currentTimeMillis() - lastUpdateTime > CACHE_EXPIRE_TIME ||
       hotProducts == null) {
        
        // 重新获取数据
        ProductService service = new ProductService();
        hotProducts = service.getHotProducts();
        
        // 更新缓存
        application.setAttribute("hot_products", hotProducts);
        application.setAttribute("data_update_time", System.currentTimeMillis());
    }
%>
```

### 4.4 缓存最佳实践


**🎯 缓存策略选择**

1️⃣ **静态数据缓存**（配置信息、分类数据）
- 📍 存储位置：Application范围  
- ⏰ 过期策略：长时间缓存 + 手动刷新

2️⃣ **用户相关缓存**（购物车、收藏）
- 📍 存储位置：Session范围
- ⏰ 过期策略：会话结束自动清除

3️⃣ **页面片段缓存**（导航菜单、侧边栏）
- 📍 存储位置：Request范围  
- ⏰ 过期策略：请求结束清除

> ⚠️ **缓存使用注意事项**：
> - 💾 监控内存使用，避免缓存过多数据
> - 🔄 设计合理的缓存更新机制
> - 🎯 不要缓存频繁变化的数据
> - 🔒 注意缓存数据的线程安全性

---

## 5. 🗜️ 资源压缩与合并


### 5.1 为什么需要资源优化


> 💡 **生活类比**  
> 网页资源优化就像整理行李箱，把零散的小物件打包压缩，既节省空间又便于携带

**资源优化解决的问题：**
```
🚛 传输问题：网络带宽有限，大文件传输慢
📦 请求问题：每个资源都需要HTTP请求，请求多了就慢
💾 存储问题：服务器存储空间和带宽都要花钱
```

### 5.2 CSS和JavaScript压缩


**🔧 压缩前后对比**

❌ **压缩前的CSS文件：**
```css
/* styles.css - 原始文件 */
.header {
    background-color: #ffffff;
    padding: 20px;
    margin: 0 auto;
    border: 1px solid #cccccc;
}

.navigation {
    list-style: none;
    display: flex;
    justify-content: space-between;
}
```

✅ **压缩后的CSS文件：**
```css
/* styles.min.css - 压缩版本 */
.header{background-color:#fff;padding:20px;margin:0 auto;border:1px solid #ccc}.navigation{list-style:none;display:flex;justify-content:space-between}
```

**📊 压缩效果统计：**

| 文件类型 | 原始大小 | 压缩后大小 | **压缩率** |
|---------|---------|-----------|-----------|
| 📄 CSS文件 | `150KB` | `95KB` | **37%减少** |
| 🔧 JavaScript | `280KB` | `170KB` | **39%减少** |
| 🖼️ 图片文件 | `500KB` | `200KB` | **60%减少** |

### 5.3 资源合并策略


**🔗 文件合并的好处**

```
合并前：多个HTTP请求
浏览器 ──[请求1]──> header.css
       ──[请求2]──> navigation.css  
       ──[请求3]──> content.css
       ──[请求4]──> footer.css

合并后：单个HTTP请求
浏览器 ──[请求1]──> all-styles.css
```

**实际应用示例：**

❌ **合并前（多个引用）：**
```jsp
<head>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/navigation.css">
    <link rel="stylesheet" href="css/content.css">
    <link rel="stylesheet" href="css/footer.css">
</head>
```

✅ **合并后（单个引用）：**
```jsp
<head>
    <link rel="stylesheet" href="css/main.min.css">
</head>
```

### 5.4 JSP中的资源优化实践


**🎯 动态资源引用**

```jsp
<%-- 根据环境选择压缩或开发版本 --%>
<%
    String environment = application.getInitParameter("environment");
    String cssFile = "development".equals(environment) ? 
                    "css/main.css" : "css/main.min.css";
    String jsFile = "development".equals(environment) ? 
                   "js/main.js" : "js/main.min.js";
%>

<head>
    <link rel="stylesheet" href="<%=cssFile%>">
    <script src="<%=jsFile%>"></script>
</head>
```

**⚡ 资源版本控制**

```jsp
<%-- 使用版本号防止缓存问题 --%>
<%
    String version = application.getInitParameter("app.version");
%>

<link rel="stylesheet" href="css/main.min.css?v=<%=version%>">
<script src="js/main.min.js?v=<%=version%>"></script>
```

### 5.5 图片资源优化


**🖼️ 图片优化策略**

```jsp
<%-- 响应式图片，根据屏幕尺寸加载不同大小 --%>
<picture>
    <source media="(max-width: 768px)" srcset="images/banner-mobile.webp">
    <source media="(max-width: 1200px)" srcset="images/banner-tablet.webp">
    <img src="images/banner-desktop.webp" alt="网站横幅" loading="lazy">
</picture>
```

**📊 图片格式选择指南：**

| 图片类型 | **推荐格式** | **原因** | **使用场景** |
|---------|-------------|---------|-------------|
| 📸 照片 | `WebP/JPEG` | `压缩率高，质量好` | `商品图片、banner` |
| 🎨 图标 | `SVG` | `矢量图，无损缩放` | `logo、按钮图标` |  
| 🎯 简单图形 | `PNG` | `支持透明背景` | `装饰性图案` |

> 🧠 **优化记忆口诀**：压缩合并减请求，版本控制防缓存

---

## 6. 🗄️ 数据库连接优化


### 6.1 数据库性能问题的根源


> 💡 **生活类比**  
> 数据库连接优化就像优化餐厅服务，不是每个客人来了都要重新培训服务员，而是提前准备好训练有素的服务团队

**常见的数据库性能问题：**
```
🐌 连接创建慢：每次都要建立新连接
🔥 连接数过多：同时打开太多数据库连接  
💔 连接泄露：用完连接没有关闭
⏰ 查询效率低：SQL语句执行时间长
```

### 6.2 数据库连接池的重要性


**🏊‍♂️ 连接池工作原理：**

```
传统方式（每次新建连接）：
用户请求 → 创建连接 → 执行SQL → 关闭连接
                ↑ 耗时操作

连接池方式（复用连接）：
用户请求 → 从池中获取连接 → 执行SQL → 归还连接到池
           ↑ 快速操作
```

**连接池配置示例：**

```xml
<!-- 在web.xml中配置数据源 -->
<resource-ref>
    <res-ref-name>jdbc/MyDatabase</res-ref-name>
    <res-type>javax.sql.DataSource</res-type>
    <res-auth>Container</res-auth>
</resource-ref>
```

```jsp
<%-- JSP中使用连接池 --%>
<%@ page import="javax.sql.DataSource" %>
<%@ page import="javax.naming.Context" %>
<%@ page import="javax.naming.InitialContext" %>

<%
    DataSource dataSource = null;
    Connection connection = null;
    try {
        // 获取数据源
        Context context = new InitialContext();
        dataSource = (DataSource) context.lookup("java:comp/env/jdbc/MyDatabase");
        
        // 从连接池获取连接
        connection = dataSource.getConnection();
        
        // 执行数据库操作
        // ...
        
    } finally {
        // 重要：归还连接到池中
        if(connection != null) {
            connection.close(); // 这里实际是归还连接，不是真正关闭
        }
    }
%>
```

### 6.3 SQL语句优化技巧


**🚀 查询优化实例**

❌ **低效的查询方式：**
```jsp
<%-- 在循环中执行数据库查询，性能很差 --%>
<c:forEach items="${userIds}" var="userId">
    <%
        // 每次循环都查询数据库，效率极低
        String sql = "SELECT * FROM users WHERE id = ?";
        PreparedStatement pstmt = connection.prepareStatement(sql);
        pstmt.setInt(1, Integer.parseInt(pageContext.findAttribute("userId").toString()));
        ResultSet rs = pstmt.executeQuery();
        // ... 处理结果
    %>
</c:forEach>
```

✅ **高效的查询方式：**
```jsp
<%
    // 一次查询获取所有需要的数据
    StringBuilder userIdList = new StringBuilder();
    for(int i = 0; i < userIds.size(); i++) {
        if(i > 0) userIdList.append(",");
        userIdList.append(userIds.get(i));
    }
    
    String sql = "SELECT * FROM users WHERE id IN (" + userIdList.toString() + ")";
    PreparedStatement pstmt = connection.prepareStatement(sql);
    ResultSet rs = pstmt.executeQuery();
    
    // 将结果存储到Map中，便于页面使用
    Map<Integer, User> userMap = new HashMap<>();
    while(rs.next()) {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        userMap.put(user.getId(), user);
    }
    request.setAttribute("userMap", userMap);
%>
```

### 6.4 分页查询优化


**📄 高效分页实现**

```jsp
<%-- 分页查询的最佳实践 --%>
<%
    int pageSize = 10; // 每页显示数量
    int currentPage = Integer.parseInt(request.getParameter("page"));
    int offset = (currentPage - 1) * pageSize;
    
    // 使用LIMIT进行分页，只获取需要显示的数据
    String sql = "SELECT * FROM products WHERE category_id = ? " +
                "ORDER BY create_time DESC LIMIT ? OFFSET ?";
    
    PreparedStatement pstmt = connection.prepareStatement(sql);
    pstmt.setInt(1, categoryId);
    pstmt.setInt(2, pageSize);
    pstmt.setInt(3, offset);
    
    ResultSet rs = pstmt.executeQuery();
    
    // 同时获取总记录数（用于计算总页数）
    String countSql = "SELECT COUNT(*) FROM products WHERE category_id = ?";
    PreparedStatement countPstmt = connection.prepareStatement(countSql);
    countPstmt.setInt(1, categoryId);
    ResultSet countRs = countPstmt.executeQuery();
    
    int totalRecords = 0;
    if(countRs.next()) {
        totalRecords = countRs.getInt(1);
    }
    int totalPages = (int)Math.ceil((double)totalRecords / pageSize);
    
    request.setAttribute("totalPages", totalPages);
    request.setAttribute("currentPage", currentPage);
%>
```

### 6.5 数据库优化最佳实践


**🎯 优化检查清单**

✅ **连接管理**
- 使用连接池，避免频繁创建连接
- 确保连接使用后及时归还
- 合理设置连接池大小

✅ **查询优化**  
- 避免在循环中执行数据库查询
- 使用批量查询替代单条查询
- 为经常查询的字段添加索引

✅ **数据传输**
- 只查询需要的字段，避免SELECT *
- 使用分页限制数据量
- 考虑使用缓存减少数据库访问

> 📊 **性能提升效果**：
> - 连接池使用：响应时间减少 **60-80%**
> - 批量查询：数据库访问次数减少 **90%以上**
> - 合理分页：内存使用减少 **70-85%**

---

## 7. 🛠️ 综合优化实践


### 7.1 性能优化实施流程


**🔄 优化实施的步骤**

```
第一步：性能测试 → 发现问题
         ↓
第二步：问题分析 → 找到瓶颈
         ↓  
第三步：制定方案 → 选择策略
         ↓
第四步：实施优化 → 代码改进
         ↓
第五步：效果验证 → 对比测试
```

### 7.2 综合优化案例


**🎯 实际项目优化案例**

**优化前的问题页面：**
```jsp
<%-- 性能问题较多的商品列表页面 --%>
<%@ page language="java" contentType="text/html; charset=UTF-8" %>
<html>
<head>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/product.css">
    <script src="js/jquery.js"></script>
    <script src="js/common.js"></script>
</head>
<body>
    <%-- 使用脚本片段获取数据 --%>
    <% 
    Connection conn = DriverManager.getConnection(
        "jdbc:mysql://localhost:3306/shop", "root", "password");
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM products");
    %>
    
    <div class="product-list">
        <% while(rs.next()) { %>
            <div class="product-item">
                <img src="<%= rs.getString("image_url") %>" alt="商品图片">
                <h3><%= rs.getString("name") %></h3>
                <p>价格：<%= rs.getDouble("price") %>元</p>
                
                <%-- 在循环中查询分类信息，效率极低 --%>
                <% 
                Statement catStmt = conn.createStatement();
                ResultSet catRs = catStmt.executeQuery(
                    "SELECT name FROM categories WHERE id=" + rs.getInt("category_id"));
                if(catRs.next()) {
                %>
                    <p>分类：<%= catRs.getString("name") %></p>
                <% } %>
            </div>
        <% } %>
    </div>
</body>
</html>
```

**优化后的高效页面：**
```jsp
<%-- 经过全面优化的商品列表页面 --%>
<%@ page language="java" contentType="text/html; charset=UTF-8" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>

<%-- 设置页面缓存 --%>
<%
    response.setHeader("Cache-Control", "public, max-age=1800"); // 30分钟缓存
%>

<html>
<head>
    <%-- 资源合并和压缩 --%>
    <link rel="stylesheet" href="css/main.min.css?v=1.2">
    <script src="js/main.min.js?v=1.2" defer></script>
</head>
<body>
    <%-- 使用Servlet预处理数据，JSP只负责展示 --%>
    <div class="product-list">
        <c:forEach items="${productList}" var="product" varStatus="status">
            <div class="product-item">
                <%-- 图片懒加载优化 --%>
                <img data-src="${product.imageUrl}" 
                     alt="${product.name}" 
                     loading="lazy"
                     class="lazy-image">
                
                <h3>${product.name}</h3>
                <p>价格：<fmt:formatNumber value="${product.price}" pattern="#,##0.00"/>元</p>
                <p>分类：${product.categoryName}</p>
            </div>
            
            <%-- 每10个商品插入一个广告位 --%>
            <c:if test="${status.count % 10 == 0 && status.count < fn:length(productList)}">
                <div class="ad-banner">
                    <%@ include file="common/ad-banner.jsp" %>
                </div>
            </c:if>
        </c:forEach>
    </div>
    
    <%-- 分页导航 --%>
    <div class="pagination">
        <c:if test="${currentPage > 1}">
            <a href="?page=${currentPage - 1}">上一页</a>
        </c:if>
        
        <c:forEach begin="1" end="${totalPages}" var="pageNum">
            <c:choose>
                <c:when test="${pageNum == currentPage}">
                    <span class="current">${pageNum}</span>
                </c:when>
                <c:otherwise>
                    <a href="?page=${pageNum}">${pageNum}</a>
                </c:otherwise>
            </c:choose>
        </c:forEach>
        
        <c:if test="${currentPage < totalPages}">
            <a href="?page=${currentPage + 1}">下一页</a>
        </c:if>
    </div>
</body>
</html>
```

### 7.3 优化效果对比


**📊 优化前后性能对比**

| 性能指标 | **优化前** | **优化后** | **提升幅度** |
|---------|-----------|-----------|-------------|
| 🕒 页面加载时间 | `8.5秒` | `2.1秒` | **⚡ 75%减少** |
| 🌐 HTTP请求数 | `23个` | `6个` | **📉 74%减少** |
| 📦 页面大小 | `1.2MB` | `320KB` | **🗜️ 73%减少** |
| 🗄️ 数据库查询 | `156次` | `3次` | **⚡ 98%减少** |
| 💾 服务器内存 | `85MB` | `28MB` | **📊 67%减少** |

### 7.4 性能监控与维护


**📈 建立性能监控体系**

```jsp
<%-- 性能监控代码示例 --%>
<%
    long startTime = System.currentTimeMillis();
    // ... 页面处理逻辑
    long endTime = System.currentTimeMillis();
    long processingTime = endTime - startTime;
    
    // 记录性能数据
    if(processingTime > 1000) { // 超过1秒记录慢查询
        Logger logger = LoggerFactory.getLogger("performance");
        logger.warn("页面处理时间过长: {}ms, URL: {}", 
                   processingTime, request.getRequestURL());
    }
    
    // 在开发环境显示性能信息
    if("development".equals(application.getInitParameter("environment"))) {
%>
    <!-- 性能调试信息 -->
    <div style="position:fixed;top:0;right:0;background:rgba(0,0,0,0.8);color:white;padding:5px;">
        页面生成时间: <%= processingTime %>ms
    </div>
<%  } %>
```

> 🎯 **持续优化建议**：
> - 📊 定期监控页面性能指标
> - 🔍 分析用户访问行为数据  
> - 🚀 根据业务变化调整优化策略
> - 📱 关注移动端性能表现

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的优化要点


```
🔸 脚本片段优化：用EL表达式和JSTL替代Java代码
🔸 包含方式选择：静态包含用于固定内容，动态包含用于参数传递
🔸 缓存策略应用：合理使用页面缓存和数据缓存
🔸 资源优化：压缩合并CSS/JS，优化图片格式
🔸 数据库优化：使用连接池，避免循环查询，实现高效分页
```

### 8.2 性能优化的核心思路


**🔹 优化的基本原则**
```
减少请求次数：合并资源文件，使用缓存
减少传输数据：压缩文件，只获取必要数据  
提高处理效率：优化数据库查询，减少重复计算
合理使用缓存：平衡性能提升和资源消耗
```

**🔹 优化的实施步骤**
```
第一步：测量 → 找出性能瓶颈
第二步：分析 → 确定优化重点
第三步：实施 → 应用优化技术
第四步：验证 → 对比优化效果
第五步：监控 → 持续跟踪性能
```

### 8.3 实际应用价值


**💼 业务价值体现**
- **用户体验提升**：页面加载更快，操作更流畅
- **服务器成本节省**：减少硬件资源需求
- **系统稳定性增强**：减少崩溃和异常情况
- **业务竞争力提升**：快速响应提高用户满意度

**🛠️ 技术能力提升**
- **性能调优思维**：学会系统性分析和解决性能问题
- **资源优化技能**：掌握前端资源优化的各种技巧
- **数据库优化**：理解数据库性能优化的基本方法
- **缓存策略设计**：学会合理使用各种缓存技术

> 🧠 **核心记忆口诀**：
> 脚本少用EL替，静态动态选择清
> 缓存合理提性能，资源压缩减传输  
> 数据库优化连接池，监控维护不能停

**🎯 学习建议**：
- 💡 从小项目开始实践，逐步积累经验
- 📊 学会使用性能分析工具
- 🔍 关注新的优化技术和最佳实践
- 🤝 与团队分享优化心得和经验