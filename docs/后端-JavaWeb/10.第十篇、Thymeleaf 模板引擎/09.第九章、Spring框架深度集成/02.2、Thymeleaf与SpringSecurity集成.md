---
title: 2、Thymeleaf与SpringSecurity集成
---
## 📚 目录

1. [Spring Security集成概述](#1-Spring-Security集成概述)
2. [权限控制标签sec:authorize](#2-权限控制标签secauthorize)
3. [角色与权限判断](#3-角色与权限判断)
4. [登录状态与用户信息](#4-登录状态与用户信息)
5. [CSRF令牌处理](#5-CSRF令牌处理)
6. [安全标签库完整应用](#6-安全标签库完整应用)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 Spring Security集成概述


### 1.1 什么是Spring Security集成


**核心理解**：Thymeleaf的Spring Security集成就是让你在网页模板里直接判断"这个用户有没有权限看这个内容"

```
现实场景类比：
公司系统登录后：
- 普通员工：只能看到自己的工资条
- 部门经理：可以看到部门所有员工工资
- 财务总监：可以看到全公司数据

Thymeleaf + Spring Security 就是实现这种"按权限显示内容"的工具
```

**🔸 为什么需要集成**
```
问题场景：
没有集成前 → 所有用户看到相同的页面内容
               后端虽然控制了接口权限，但前端还是会显示没权限的按钮
               用户点击后才发现"无权限"，体验很差

集成后 → 根据用户权限动态显示内容
        没权限的按钮直接不显示
        用户看到的都是自己能操作的内容
```

### 1.2 环境准备


**📦 添加依赖**
```xml
<!-- Thymeleaf Spring Security 集成包 -->
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity6</artifactId>
</dependency>
```

> 💡 **版本说明**：
> - Spring Security 5.x 使用 `thymeleaf-extras-springsecurity5`
> - Spring Security 6.x 使用 `thymeleaf-extras-springsecurity6`
> - 版本号要和你的Spring Security版本匹配

**🔧 命名空间声明**
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <title>安全页面</title>
</head>
<body>
    <!-- 这里可以使用 sec: 开头的安全标签 -->
</body>
</html>
```

> 📌 **记住要点**：
> - `xmlns:th` → Thymeleaf的基础功能
> - `xmlns:sec` → Spring Security的安全控制功能

---

## 2. ⚡ 权限控制标签sec:authorize


### 2.1 基本用法理解


**🎯 核心概念**：`sec:authorize` 就像一个"权限门卫"，只有符合条件的用户才能看到标签内的内容

```html
<!-- 基础语法结构 -->
<div sec:authorize="条件表达式">
    只有满足条件的用户才能看到这里的内容
</div>
```

**💡 工作原理图示**
```
用户访问页面
    ↓
sec:authorize 检查权限
    ↓
    ├─ 有权限 → 显示标签内容
    └─ 无权限 → 标签内容被移除（HTML中都不会有）
```

### 2.2 常用权限判断方式


**🔸 方式一：判断是否登录**
```html
<!-- 只有登录用户才能看到 -->
<div sec:authorize="isAuthenticated()">
    <p>欢迎回来，已登录用户！</p>
    <a href="/profile">个人中心</a>
</div>

<!-- 只有未登录用户才能看到 -->
<div sec:authorize="isAnonymous()">
    <a href="/login">请先登录</a>
    <a href="/register">注册账号</a>
</div>
```

**🔸 方式二：判断是否有某个角色**
```html
<!-- 只有管理员角色才能看到 -->
<div sec:authorize="hasRole('ADMIN')">
    <a href="/admin/dashboard">管理后台</a>
</div>

<!-- 有任意一个角色就能看到 -->
<div sec:authorize="hasAnyRole('ADMIN', 'MANAGER')">
    <a href="/reports">查看报表</a>
</div>
```

> ⚠️ **注意**：角色名称不需要加 `ROLE_` 前缀，Spring Security会自动添加

**🔸 方式三：判断是否有某个权限**
```html
<!-- 只有具有"编辑"权限的用户才能看到 -->
<div sec:authorize="hasAuthority('EDIT_POST')">
    <button>编辑文章</button>
</div>

<!-- 有任意一个权限就能看到 -->
<div sec:authorize="hasAnyAuthority('EDIT_POST', 'DELETE_POST')">
    <button>内容管理</button>
</div>
```

### 2.3 实战示例：导航菜单权限控制


```html
<nav>
    <ul>
        <!-- 所有人都能看到首页 -->
        <li><a href="/">首页</a></li>
        
        <!-- 只有登录用户能看到 -->
        <li sec:authorize="isAuthenticated()">
            <a href="/dashboard">工作台</a>
        </li>
        
        <!-- 只有经理及以上角色能看到 -->
        <li sec:authorize="hasAnyRole('MANAGER', 'ADMIN')">
            <a href="/team">团队管理</a>
        </li>
        
        <!-- 只有管理员能看到 -->
        <li sec:authorize="hasRole('ADMIN')">
            <a href="/settings">系统设置</a>
        </li>
        
        <!-- 未登录用户看到登录按钮 -->
        <li sec:authorize="isAnonymous()">
            <a href="/login">登录</a>
        </li>
        
        <!-- 已登录用户看到退出按钮 -->
        <li sec:authorize="isAuthenticated()">
            <a href="/logout">退出</a>
        </li>
    </ul>
</nav>
```

---

## 3. 👥 角色与权限判断


### 3.1 角色判断详解


**🔑 角色的本质理解**

```
角色就像"岗位职称"：
- ADMIN（管理员）→ 公司老板，什么都能做
- MANAGER（经理）→ 部门领导，管理本部门
- USER（普通用户）→ 普通员工，只能做基本操作
```

**📊 角色判断方法对比**

| 判断方法 | 说明 | 使用场景 | 示例 |
|---------|------|---------|------|
| `hasRole('角色')` | 判断是否有指定角色 | 需要特定角色才能访问 | `hasRole('ADMIN')` |
| `hasAnyRole('角色1', '角色2')` | 判断是否有任意一个角色 | 多个角色都可访问 | `hasAnyRole('ADMIN', 'MANAGER')` |
| `hasAllRoles('角色1', '角色2')` | 判断是否同时拥有所有角色 | 需要多个角色同时具备 | `hasAllRoles('USER', 'VIP')` |

**💡 实战示例：按钮权限控制**
```html
<!-- 删除按钮：只有管理员能看到 -->
<button sec:authorize="hasRole('ADMIN')" 
        class="btn-danger">
    删除用户
</button>

<!-- 审核按钮：经理和管理员都能看到 -->
<button sec:authorize="hasAnyRole('MANAGER', 'ADMIN')" 
        class="btn-warning">
    审核申请
</button>

<!-- 提交按钮：所有登录用户都能看到 -->
<button sec:authorize="isAuthenticated()" 
        class="btn-primary">
    提交表单
</button>
```

### 3.2 权限判断详解


**🔑 权限的本质理解**

```
权限就像"具体操作许可"：
- READ_POST（读文章）→ 可以查看文章内容
- EDIT_POST（改文章）→ 可以修改文章
- DELETE_POST（删文章）→ 可以删除文章

权限比角色更细粒度：
一个角色可以包含多个权限
比如 MANAGER角色 = READ_POST + EDIT_POST
```

**📊 权限判断方法对比**

| 判断方法 | 说明 | 使用场景 | 示例 |
|---------|------|---------|------|
| `hasAuthority('权限')` | 判断是否有指定权限 | 需要特定权限才能操作 | `hasAuthority('DELETE_POST')` |
| `hasAnyAuthority('权限1', '权限2')` | 判断是否有任意一个权限 | 多个权限都可操作 | `hasAnyAuthority('EDIT', 'DELETE')` |

**💡 实战示例：文章操作权限**
```html
<div class="article-actions">
    <!-- 编辑按钮：有编辑权限才显示 -->
    <a sec:authorize="hasAuthority('EDIT_POST')" 
       th:href="@{/post/edit/{id}(id=${post.id})}"
       class="btn-edit">
        编辑
    </a>
    
    <!-- 删除按钮：有删除权限才显示 -->
    <a sec:authorize="hasAuthority('DELETE_POST')" 
       th:href="@{/post/delete/{id}(id=${post.id})}"
       class="btn-delete">
        删除
    </a>
    
    <!-- 发布按钮：有编辑或发布权限都能看到 -->
    <button sec:authorize="hasAnyAuthority('EDIT_POST', 'PUBLISH_POST')"
            class="btn-publish">
        发布
    </button>
</div>
```

### 3.3 组合条件判断


**🔸 使用逻辑运算符**
```html
<!-- AND条件：同时满足多个条件 -->
<div sec:authorize="isAuthenticated() and hasRole('ADMIN')">
    只有登录的管理员才能看到
</div>

<!-- OR条件：满足任意一个条件 -->
<div sec:authorize="hasRole('ADMIN') or hasRole('MANAGER')">
    管理员或经理都能看到
</div>

<!-- NOT条件：取反 -->
<div sec:authorize="!hasRole('GUEST')">
    游客看不到这个内容
</div>

<!-- 复杂组合 -->
<div sec:authorize="isAuthenticated() and (hasRole('ADMIN') or hasAuthority('SPECIAL_ACCESS'))">
    需要登录，并且是管理员或有特殊权限
</div>
```

---

## 4. 👤 登录状态与用户信息


### 4.1 登录状态检查


**🔸 基础状态判断**
```html
<!-- 方式1：使用 isAuthenticated() -->
<div sec:authorize="isAuthenticated()">
    <p>您已登录</p>
</div>

<!-- 方式2：使用 isAnonymous() -->
<div sec:authorize="isAnonymous()">
    <p>您还未登录</p>
</div>

<!-- 方式3：使用 isFullyAuthenticated() -->
<div sec:authorize="isFullyAuthenticated()">
    <p>您已完全认证（非记住我登录）</p>
</div>

<!-- 方式4：使用 isRememberMe() -->
<div sec:authorize="isRememberMe()">
    <p>您是通过"记住我"登录的</p>
</div>
```

> 💡 **状态说明**：
> - `isAuthenticated()` → 已登录（包括记住我）
> - `isAnonymous()` → 未登录
> - `isFullyAuthenticated()` → 完整登录（不包括记住我）
> - `isRememberMe()` → 记住我登录

**📊 登录状态判断流程**
```
用户访问
    ↓
检查登录状态
    ↓
    ├─ 未登录 → isAnonymous() = true
    ├─ 记住我登录 → isRememberMe() = true, isAuthenticated() = true
    └─ 完整登录 → isFullyAuthenticated() = true, isAuthenticated() = true
```

### 4.2 获取当前用户信息


**🔸 使用 authentication 对象**
```html
<!-- 获取用户名 -->
<p>欢迎，<span sec:authentication="name">用户名</span></p>

<!-- 获取用户详细信息 -->
<div sec:authorize="isAuthenticated()">
    <p>用户名：<span sec:authentication="principal.username"></span></p>
    <p>邮箱：<span sec:authentication="principal.email"></span></p>
    <p>角色：<span sec:authentication="authorities"></span></p>
</div>
```

**🔸 常用属性说明**

| 属性 | 说明 | 示例值 |
|-----|------|--------|
| `name` | 用户名（简写） | `zhangsan` |
| `principal` | 用户主体对象 | `UserDetails对象` |
| `principal.username` | 用户名（完整路径） | `zhangsan` |
| `authorities` | 用户权限列表 | `[ROLE_USER, ROLE_ADMIN]` |
| `credentials` | 凭证信息 | 通常为空（出于安全考虑） |
| `details` | 认证详情 | IP地址、session等信息 |

**💡 实战示例：用户信息面板**
```html
<div class="user-panel" sec:authorize="isAuthenticated()">
    <!-- 用户头像和名称 -->
    <div class="user-info">
        <img th:src="@{/avatar/{name}(name=${#authentication.principal.username})}" 
             alt="头像">
        <h3 sec:authentication="principal.username">用户名</h3>
    </div>
    
    <!-- 用户角色标签 -->
    <div class="user-roles">
        <span class="badge" 
              th:each="role : ${#authentication.authorities}"
              th:text="${role.authority}">
            角色
        </span>
    </div>
    
    <!-- 个性化欢迎语 -->
    <p>
        欢迎回来，
        <span sec:authentication="principal.nickname"></span>！
        上次登录时间：
        <span sec:authentication="details.lastLoginTime"></span>
    </p>
</div>
```

### 4.3 条件显示不同内容


**🔸 根据登录状态显示不同界面**
```html
<!-- 导航栏：登录前后显示不同 -->
<nav>
    <!-- 未登录时显示 -->
    <div sec:authorize="isAnonymous()">
        <a href="/login">登录</a>
        <a href="/register">注册</a>
    </div>
    
    <!-- 已登录时显示 -->
    <div sec:authorize="isAuthenticated()">
        <span>您好，<span sec:authentication="name"></span></span>
        <a href="/profile">个人中心</a>
        <a href="/logout">退出</a>
    </div>
</nav>
```

**🔸 根据角色显示不同欢迎信息**
```html
<div class="welcome-message">
    <!-- 管理员看到的欢迎语 -->
    <h2 sec:authorize="hasRole('ADMIN')">
        管理员面板 - 
        <span sec:authentication="principal.username"></span>
    </h2>
    
    <!-- 经理看到的欢迎语 -->
    <h2 sec:authorize="hasRole('MANAGER')">
        部门管理 - 
        <span sec:authentication="principal.department"></span>部门
    </h2>
    
    <!-- 普通用户看到的欢迎语 -->
    <h2 sec:authorize="hasRole('USER') and !hasRole('MANAGER')">
        个人工作台 - 
        <span sec:authentication="principal.username"></span>
    </h2>
</div>
```

---

## 5. 🛡️ CSRF令牌处理


### 5.1 什么是CSRF攻击


**🔸 CSRF攻击原理（通俗理解）**

```
真实场景类比：
你登录了网上银行（银行网站记住了你的登录状态）
    ↓
你访问了一个恶意网站
    ↓
恶意网站偷偷向银行网站发送"转账"请求
    ↓
因为你还在登录状态，银行以为是你本人操作
    ↓
钱被转走了！

这就是CSRF攻击：跨站请求伪造
```

**🔸 CSRF令牌防御原理**
```
防御流程：
用户访问表单页面
    ↓
服务器生成随机CSRF令牌
    ↓
令牌同时保存在：
    ├─ 服务器Session中
    └─ 表单隐藏字段中
    ↓
用户提交表单时
    ↓
服务器对比两个令牌
    ↓
    ├─ 一致 → 允许操作
    └─ 不一致 → 拒绝操作（可能是攻击）
```

### 5.2 Thymeleaf中的CSRF令牌


**🔸 自动处理（推荐方式）**
```html
<!-- 使用 th:action 会自动添加CSRF令牌 -->
<form th:action="@{/user/save}" method="post">
    <input type="text" name="username">
    <input type="password" name="password">
    <button type="submit">提交</button>
    <!-- Thymeleaf会自动添加隐藏的CSRF令牌字段 -->
</form>
```

**生成的HTML（实际效果）**
```html
<form action="/user/save" method="post">
    <input type="text" name="username">
    <input type="password" name="password">
    <!-- 自动生成的CSRF令牌 -->
    <input type="hidden" 
           name="_csrf" 
           value="4c3e4d8a-9f2b-4e3a-8d5f-1a2b3c4d5e6f">
    <button type="submit">提交</button>
</form>
```

**🔸 手动获取令牌**
```html
<!-- 获取令牌名称 -->
<input type="hidden" 
       th:name="${_csrf.parameterName}" 
       th:value="${_csrf.token}">

<!-- 或者使用固定名称（默认就是_csrf） -->
<input type="hidden" 
       name="_csrf" 
       th:value="${_csrf.token}">
```

### 5.3 AJAX请求中的CSRF令牌


**🔸 在请求头中发送令牌（推荐）**
```html
<script>
// 从页面获取CSRF令牌
const csrfToken = /*[[${_csrf.token}]]*/ '';
const csrfHeader = /*[[${_csrf.headerName}]]*/ '';

// AJAX请求时添加到请求头
fetch('/api/user/save', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        [csrfHeader]: csrfToken  // 添加CSRF令牌
    },
    body: JSON.stringify({
        username: 'zhangsan',
        email: 'zhangsan@example.com'
    })
});
</script>
```

**🔸 在元数据中存储令牌**
```html
<head>
    <!-- 在meta标签中存储CSRF信息 -->
    <meta name="_csrf" th:content="${_csrf.token}">
    <meta name="_csrf_header" th:content="${_csrf.headerName}">
</head>

<script>
// 从meta标签读取CSRF信息
const token = document.querySelector('meta[name="_csrf"]').content;
const header = document.querySelector('meta[name="_csrf_header"]').content;

// 使用jQuery发送AJAX请求
$.ajax({
    url: '/api/data',
    type: 'POST',
    beforeSend: function(xhr) {
        xhr.setRequestHeader(header, token);
    },
    data: JSON.stringify({...}),
    success: function(result) {
        console.log('成功');
    }
});
</script>
```

### 5.4 常见场景处理


**🔸 场景1：文件上传表单**
```html
<form th:action="@{/upload}" 
      method="post" 
      enctype="multipart/form-data">
    <input type="file" name="file">
    <button type="submit">上传</button>
    <!-- CSRF令牌自动添加，无需手动处理 -->
</form>
```

**🔸 场景2：删除按钮（单独提交）**
```html
<form th:action="@{/user/delete/{id}(id=${user.id})}" 
      method="post" 
      style="display:inline;">
    <input type="hidden" name="_method" value="delete">
    <button type="submit" class="btn-danger">删除</button>
    <!-- CSRF令牌自动添加 -->
</form>
```

**🔸 场景3：禁用CSRF（特殊接口）**
```java
// 后端配置：某些接口不需要CSRF验证
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http.csrf(csrf -> csrf
            .ignoringRequestMatchers("/api/public/**")  // 公开API不需要CSRF
        );
        return http.build();
    }
}
```

> ⚠️ **安全提醒**：
> - 所有修改数据的操作（POST/PUT/DELETE）都应该有CSRF保护
> - 使用 `th:action` 会自动处理CSRF，无需手动添加
> - AJAX请求需要手动在请求头中添加CSRF令牌
> - 不要禁用CSRF，除非你完全理解风险

---

## 6. 📚 安全标签库完整应用


### 6.1 常用安全标签总览


**📊 标签功能分类表**

| 标签类型 | 标签/属性 | 作用 | 示例 |
|---------|----------|------|------|
| **权限控制** | `sec:authorize` | 根据权限显示/隐藏内容 | `sec:authorize="hasRole('ADMIN')"` |
| **用户信息** | `sec:authentication` | 获取当前用户信息 | `sec:authentication="name"` |
| **CSRF保护** | `${_csrf}` | 获取CSRF令牌 | `th:value="${_csrf.token}"` |

**🔸 权限控制标签详解**
```html
<!-- 1. 基于角色控制 -->
<div sec:authorize="hasRole('ADMIN')">管理员专区</div>
<div sec:authorize="hasAnyRole('ADMIN', 'MANAGER')">管理区域</div>

<!-- 2. 基于权限控制 -->
<div sec:authorize="hasAuthority('WRITE')">可写入</div>
<div sec:authorize="hasAnyAuthority('READ', 'WRITE')">可读写</div>

<!-- 3. 基于登录状态 -->
<div sec:authorize="isAuthenticated()">已登录内容</div>
<div sec:authorize="isAnonymous()">未登录内容</div>
<div sec:authorize="isFullyAuthenticated()">完整认证内容</div>
<div sec:authorize="isRememberMe()">记住我登录内容</div>

<!-- 4. 组合条件 -->
<div sec:authorize="isAuthenticated() and hasRole('VIP')">
    VIP会员专享
</div>
```

### 6.2 综合实战案例


**🎯 案例：完整的后台管理页面**

```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <title>后台管理系统</title>
    <!-- CSRF令牌存储在meta标签 -->
    <meta name="_csrf" th:content="${_csrf.token}">
    <meta name="_csrf_header" th:content="${_csrf.headerName}">
</head>
<body>

<!-- 1. 顶部导航栏 -->
<header>
    <nav>
        <!-- 未登录用户看到 -->
        <div sec:authorize="isAnonymous()">
            <a href="/login">登录</a>
            <a href="/register">注册</a>
        </div>
        
        <!-- 已登录用户看到 -->
        <div sec:authorize="isAuthenticated()">
            <span>您好，<span sec:authentication="principal.username"></span></span>
            
            <!-- 只有管理员看到 -->
            <a sec:authorize="hasRole('ADMIN')" href="/admin">系统管理</a>
            
            <!-- 经理和管理员都能看到 -->
            <a sec:authorize="hasAnyRole('MANAGER', 'ADMIN')" href="/reports">
                数据报表
            </a>
            
            <a href="/logout">退出登录</a>
        </div>
    </nav>
</header>

<!-- 2. 侧边栏菜单 -->
<aside sec:authorize="isAuthenticated()">
    <ul>
        <li><a href="/dashboard">工作台</a></li>
        
        <!-- 有查看用户权限才显示 -->
        <li sec:authorize="hasAuthority('USER_VIEW')">
            <a href="/users">用户管理</a>
        </li>
        
        <!-- 有文章编辑权限才显示 -->
        <li sec:authorize="hasAuthority('POST_EDIT')">
            <a href="/posts">内容管理</a>
        </li>
        
        <!-- 只有管理员才能看到 -->
        <li sec:authorize="hasRole('ADMIN')">
            <a href="/settings">系统设置</a>
        </li>
    </ul>
</aside>

<!-- 3. 主内容区 - 用户列表 -->
<main sec:authorize="hasAuthority('USER_VIEW')">
    <h2>用户列表</h2>
    
    <!-- 添加按钮：需要创建权限 -->
    <button sec:authorize="hasAuthority('USER_CREATE')" 
            onclick="showAddUserForm()">
        添加用户
    </button>
    
    <table>
        <thead>
            <tr>
                <th>ID</th>
                <th>用户名</th>
                <th>邮箱</th>
                <th>角色</th>
                <th sec:authorize="hasAnyAuthority('USER_EDIT', 'USER_DELETE')">
                    操作
                </th>
            </tr>
        </thead>
        <tbody>
            <tr th:each="user : ${users}">
                <td th:text="${user.id}">1</td>
                <td th:text="${user.username}">zhangsan</td>
                <td th:text="${user.email}">zhangsan@example.com</td>
                <td th:text="${user.role}">USER</td>
                <td>
                    <!-- 编辑按钮：需要编辑权限 -->
                    <a sec:authorize="hasAuthority('USER_EDIT')"
                       th:href="@{/user/edit/{id}(id=${user.id})}">
                        编辑
                    </a>
                    
                    <!-- 删除按钮：需要删除权限 -->
                    <form sec:authorize="hasAuthority('USER_DELETE')"
                          th:action="@{/user/delete/{id}(id=${user.id})}"
                          method="post"
                          style="display:inline;">
                        <button type="submit" 
                                onclick="return confirm('确定删除吗？')">
                            删除
                        </button>
                    </form>
                </td>
            </tr>
        </tbody>
    </table>
</main>

<!-- 4. 用户编辑表单 -->
<div id="editUserForm" 
     sec:authorize="hasAuthority('USER_EDIT')"
     style="display:none;">
    <h3>编辑用户</h3>
    <form th:action="@{/user/update}" method="post">
        <input type="hidden" name="id" th:value="${user.id}">
        
        <label>用户名：
            <input type="text" name="username" th:value="${user.username}">
        </label>
        
        <label>邮箱：
            <input type="email" name="email" th:value="${user.email}">
        </label>
        
        <!-- 只有管理员能修改角色 -->
        <div sec:authorize="hasRole('ADMIN')">
            <label>角色：
                <select name="role">
                    <option value="USER">普通用户</option>
                    <option value="MANAGER">经理</option>
                    <option value="ADMIN">管理员</option>
                </select>
            </label>
        </div>
        
        <button type="submit">保存</button>
        <!-- CSRF令牌会自动添加 -->
    </form>
</div>

<!-- 5. AJAX请求示例 -->
<script th:inline="javascript">
    // 获取CSRF令牌
    const token = /*[[${_csrf.token}]]*/ '';
    const header = /*[[${_csrf.headerName}]]*/ '';
    
    // 发送AJAX请求
    function updateUserStatus(userId, status) {
        fetch(`/api/user/${userId}/status`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                [header]: token  // 添加CSRF令牌
            },
            body: JSON.stringify({ status: status })
        })
        .then(response => response.json())
        .then(data => {
            alert('状态更新成功');
            location.reload();
        })
        .catch(error => {
            alert('更新失败：' + error);
        });
    }
</script>

</body>
</html>
```

### 6.3 最佳实践建议


**✅ 推荐做法**
```
1. 前后端双重验证：
   - 前端用 sec:authorize 控制显示
   - 后端用 @PreAuthorize 控制接口
   
2. 使用细粒度权限：
   - 不要只用角色，要用具体权限
   - 例如：USER_CREATE, USER_EDIT, USER_DELETE
   
3. CSRF保护：
   - 表单用 th:action 自动处理
   - AJAX请求手动添加令牌
   
4. 安全日志：
   - 记录权限检查失败的情况
   - 监控异常访问行为
```

**❌ 避免做法**
```
1. 只在前端控制权限：
   - 前端隐藏按钮不等于安全
   - 必须后端也验证权限
   
2. 硬编码角色名：
   - 不要写死 'ROLE_ADMIN'
   - 使用配置文件或枚举管理
   
3. 忽略CSRF保护：
   - 不要禁用CSRF
   - 特殊接口要有其他安全措施
   
4. 过度授权：
   - 遵循最小权限原则
   - 用户只能访问必要的功能
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Spring Security集成本质：
   在页面模板中根据用户权限动态控制内容显示

🔸 sec:authorize核心用法：
   - 判断登录状态：isAuthenticated() / isAnonymous()
   - 判断角色：hasRole('ADMIN')
   - 判断权限：hasAuthority('EDIT')
   - 组合条件：使用 and / or / not

🔸 用户信息获取：
   - sec:authentication="name" → 用户名
   - sec:authentication="principal.xxx" → 用户详细信息
   - sec:authentication="authorities" → 权限列表

🔸 CSRF保护：
   - 表单使用 th:action 自动添加令牌
   - AJAX请求手动添加到请求头
   - 从 ${_csrf} 对象获取令牌信息
```

### 7.2 关键知识点总结


**🔹 角色 vs 权限的区别**
```
角色（Role）：
- 代表用户身份/职位
- 粗粒度的访问控制
- 例如：ADMIN、MANAGER、USER

权限（Authority）：
- 代表具体操作许可
- 细粒度的访问控制  
- 例如：READ_POST、EDIT_POST、DELETE_POST

关系：一个角色包含多个权限
```

**🔹 登录状态的几种形式**
```
isAuthenticated() → 已登录（包括记住我）
    ├─ isFullyAuthenticated() → 完整登录
    └─ isRememberMe() → 记住我登录

isAnonymous() → 未登录
```

**🔹 CSRF攻击防御要点**
```
攻击原理：利用用户登录状态，伪造请求
防御机制：验证CSRF令牌（服务器生成的随机值）
实现方式：
  - 表单：th:action 自动添加
  - AJAX：手动在请求头添加
```

### 7.3 实际应用指南


**📌 开发步骤**
```
1. 添加依赖：thymeleaf-extras-springsecurity6
2. 声明命名空间：xmlns:sec="..."
3. 配置权限：定义角色和权限
4. 页面控制：使用 sec:authorize
5. 获取信息：使用 sec:authentication
6. CSRF保护：确保令牌正确传递
```

**📌 常见使用场景**

| 场景 | 解决方案 | 示例代码 |
|-----|---------|---------|
| 导航菜单权限 | `sec:authorize` 控制菜单项 | `sec:authorize="hasRole('ADMIN')"` |
| 按钮权限控制 | 根据权限显示操作按钮 | `sec:authorize="hasAuthority('DELETE')"` |
| 用户信息展示 | 获取当前登录用户信息 | `sec:authentication="name"` |
| 表单CSRF保护 | 使用 `th:action` | `th:action="@{/save}"` |
| AJAX CSRF保护 | 请求头添加令牌 | `headers: {[header]: token}` |

**📌 安全检查清单**
```
□ 前端有权限控制（sec:authorize）
□ 后端有权限验证（@PreAuthorize）
□ 所有表单有CSRF保护
□ AJAX请求正确传递CSRF令牌
□ 敏感操作需要完整认证（isFullyAuthenticated）
□ 遵循最小权限原则
□ 定期审计权限配置
```

> 💡 **核心记忆口诀**：
> - 权限控制用 authorize，角色权限要分清
> - 用户信息 authentication，登录状态要判明  
> - CSRF保护别忘记，表单AJAX都要行
> - 前后端双重验证，安全防护才完整

**🎯 学习建议**
```
1. 先掌握基础：
   ├─ sec:authorize 的基本用法
   ├─ 角色和权限的概念
   └─ CSRF的基本原理

2. 再深入应用：
   ├─ 复杂权限组合
   ├─ 用户信息获取
   └─ AJAX中的CSRF处理

3. 最后综合实践：
   ├─ 完整的后台管理系统
   ├─ 结合Spring Security配置
   └─ 生产环境的安全策略
```