---
title: 3、HTTPS部署与SSL配置
---
## 📚 目录

1. [HTTPS基础概念](#1-HTTPS基础概念)
2. [SSL证书申请与管理](#2-SSL证书申请与管理)
3. [密钥库(Keystore)操作详解](#3-密钥库Keystore操作详解)
4. [Tomcat SSL配置实战](#4-Tomcat-SSL配置实战)
5. [证书链配置与验证](#5-证书链配置与验证)
6. [HTTP自动跳转HTTPS](#6-HTTP自动跳转HTTPS)
7. [SSL性能优化策略](#7-SSL性能优化策略)
8. [常见问题排查](#8-常见问题排查)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔒 HTTPS基础概念


### 1.1 什么是HTTPS


**🎯 通俗理解**：
HTTPS就是给HTTP穿上了一件"防护衣"，让数据在网络上传输时不会被人偷看或篡改。

```
简单类比：
HTTP = 明信片寄信 → 任何人都能看到内容
HTTPS = 密封信封寄信 → 只有收信人能看到内容

实际含义：
HTTP + SSL/TLS加密 = HTTPS
超文本传输安全协议
```

**🔑 核心作用**：
- **数据加密**：防止信息泄露，就像给数据加了一把锁
- **身份验证**：确认网站真实性，防止钓鱼网站
- **数据完整性**：确保数据传输过程中不被篡改

### 1.2 HTTPS工作原理


**💡 工作流程**：
```
第一步：握手阶段
客户端 → 服务器：我想要安全连接
服务器 → 客户端：这是我的SSL证书(包含公钥)
客户端：验证证书是否可信

第二步：密钥交换
客户端：用服务器公钥加密一个随机密钥发送
服务器：用私钥解密得到密钥

第三步：安全通信
双方使用协商好的密钥进行加密通信
```

**🔐 加密机制**：
- **非对称加密**：握手时使用，安全但慢
- **对称加密**：数据传输时使用，快速但需要共享密钥
- **结合使用**：先用非对称加密交换对称密钥，再用对称加密传输数据

### 1.3 SSL与TLS的关系


**📖 发展历程**：
```
SSL 1.0 → 未公开发布(存在安全问题)
SSL 2.0 → 1995年，有安全漏洞
SSL 3.0 → 1996年，较为安全
TLS 1.0 → 1999年，SSL 3.0的升级版
TLS 1.1 → 2006年
TLS 1.2 → 2008年，目前广泛使用
TLS 1.3 → 2018年，最新版本
```

**🔄 实际关系**：
虽然我们常说"SSL证书"，但现在实际使用的都是TLS协议。就像我们说"打的"，但现在很多都是网约车一样，只是习惯性称呼。

---

## 2. 📜 SSL证书申请与管理


### 2.1 证书分类详解


**📊 按验证级别分类**：

| 证书类型 | **验证内容** | **适用场景** | **价格** | **申请时间** |
|----------|-------------|-------------|----------|-------------|
| 🟢 **DV证书** | `域名所有权` | 个人网站、博客 | 免费-低价 | 几分钟-几小时 |
| 🟡 **OV证书** | `域名+企业信息` | 企业官网 | 中等价格 | 1-3个工作日 |
| 🔴 **EV证书** | `严格企业验证` | 银行、电商 | 高价 | 7-15个工作日 |

**💰 按是否收费分类**：
```
免费证书：
✅ Let's Encrypt：90天有效期，自动续期
✅ 阿里云免费证书：1年有效期
✅ 腾讯云免费证书：1年有效期

付费证书：
💼 Symantec、DigiCert等商业CA
💼 提供更长有效期和更全面服务
💼 适合企业级应用
```

### 2.2 Let's Encrypt免费证书申请


**🚀 使用Certbot工具**：

```bash
# 安装certbot
sudo apt update
sudo apt install certbot

# 申请证书(手动DNS验证方式)
sudo certbot certonly --manual --preferred-challenges dns -d example.com

# 申请通配符证书
sudo certbot certonly --manual --preferred-challenges dns -d "*.example.com" -d example.com
```

**📋 申请步骤详解**：
```
Step 1: 运行certbot命令
Step 2: 输入邮箱地址(用于证书过期通知)
Step 3: 同意服务条款
Step 4: 按提示添加DNS TXT记录
Step 5: 等待DNS解析生效(通常5-10分钟)
Step 6: 验证通过，证书生成完成
```

**📍 证书文件位置**：
```bash
# 证书文件默认保存在：
/etc/letsencrypt/live/example.com/

包含文件：
cert.pem        # 网站证书
chain.pem       # 中间证书
fullchain.pem   # 完整证书链(cert.pem + chain.pem)
privkey.pem     # 私钥文件
```

### 2.3 商业证书申请流程


**🏢 企业证书申请步骤**：
```
准备工作：
• 确定域名列表
• 准备企业营业执照
• 准备域名所有权证明

申请流程：
1️⃣ 选择证书类型和CA机构
2️⃣ 生成CSR(证书签名请求)
3️⃣ 提交申请材料
4️⃣ 完成域名验证
5️⃣ 完成企业信息验证(OV/EV证书)
6️⃣ CA签发证书
```

**📝 生成CSR示例**：
```bash
# 使用OpenSSL生成私钥和CSR
openssl genrsa -out example.com.key 2048

openssl req -new -key example.com.key -out example.com.csr \
    -subj "/C=CN/ST=Beijing/L=Beijing/O=Example Inc/OU=IT Department/CN=example.com"

# 查看CSR内容
openssl req -text -noout -verify -in example.com.csr
```

---

## 3. 🔐 密钥库(Keystore)操作详解


### 3.1 什么是Keystore


**🎯 通俗解释**：
Keystore就像一个数字保险箱，专门用来存放SSL证书和私钥。Java程序(如Tomcat)需要从这个"保险箱"中取出证书来建立HTTPS连接。

**📦 Keystore的作用**：
- **安全存储**：把证书和私钥打包存储
- **密码保护**：设置密码防止未授权访问  
- **统一管理**：一个文件管理多个证书
- **Java兼容**：Java应用服务器可以直接使用

### 3.2 将PEM证书转换为JKS格式


**🔄 为什么需要转换**：
```
Let's Encrypt等CA签发的是PEM格式证书
Tomcat需要的是JKS(Java KeyStore)格式
需要进行格式转换才能使用
```

**💻 转换操作步骤**：

```bash
# 第一步：将PEM证书转换为PKCS12格式
openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem \
    -out example.com.p12 -name tomcat \
    -passout pass:your_password

# 第二步：将PKCS12转换为JKS格式
keytool -importkeystore -deststorepass your_password \
    -destkeypass your_password -destkeystore example.com.jks \
    -srckeystore example.com.p12 -srcstoretype PKCS12 \
    -srcstorepass your_password -alias tomcat
```

**⚙️ 参数说明**：
- `-in fullchain.pem`：完整证书链文件
- `-inkey privkey.pem`：私钥文件
- `-name tomcat`：证书别名(alias)
- `-passout pass:密码`：设置密钥库密码

### 3.3 Keystore管理常用命令


**🔍 查看证书信息**：
```bash
# 查看keystore中的证书列表
keytool -list -keystore example.com.jks

# 查看具体证书详情
keytool -list -v -keystore example.com.jks -alias tomcat

# 验证证书有效期
keytool -list -v -keystore example.com.jks | grep "Valid from"
```

**🔧 证书管理操作**：
```bash
# 删除证书
keytool -delete -alias tomcat -keystore example.com.jks

# 修改keystore密码
keytool -storepasswd -keystore example.com.jks

# 修改证书别名密码  
keytool -keypasswd -alias tomcat -keystore example.com.jks

# 导出证书(用于备份)
keytool -export -alias tomcat -keystore example.com.jks -file example.com.crt
```

---

## 4. ⚙️ Tomcat SSL配置实战


### 4.1 Tomcat版本差异


**📋 不同版本配置区别**：

| Tomcat版本 | **配置方式** | **推荐程度** | **说明** |
|------------|-------------|-------------|----------|
| **7.x及以下** | `HTTP/1.1 Connector` | ⭐⭐ | 旧版配置方式 |
| **8.5+** | `HTTP/1.1 NIO2` | ⭐⭐⭐⭐ | 推荐配置 |
| **9.0+** | `HTTP/1.1 NIO2` | ⭐⭐⭐⭐⭐ | 最新特性 |

### 4.2 server.xml SSL配置详解


**🔧 基础SSL配置**：

```xml
<!-- Tomcat 8.5+ 推荐配置 -->
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
           maxThreads="150" SSLEnabled="true">
    <UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" />
    <SSLHostConfig>
        <Certificate certificateKeystoreFile="conf/example.com.jks"
                     certificateKeystorePassword="your_password"
                     type="RSA" />
    </SSLHostConfig>
</Connector>
```

**🎯 参数详细解释**：
- `port="8443"`：HTTPS默认端口(可自定义)
- `protocol`：指定使用NIO2协议(性能更好)
- `maxThreads="150"`：最大线程数(根据服务器性能调整)
- `certificateKeystoreFile`：JKS文件路径(相对于CATALINA_HOME)
- `certificateKeystorePassword`：密钥库密码

**🔒 增强安全配置**：

```xml
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
           maxThreads="150" SSLEnabled="true"
           scheme="https" secure="true" clientAuth="false" 
           sslProtocol="TLS" compression="on">
    
    <UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" />
    
    <SSLHostConfig protocols="TLSv1.2,TLSv1.3"
                   ciphers="TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-RSA-AES256-GCM-SHA384"
                   honorCipherOrder="true">
        
        <Certificate certificateKeystoreFile="conf/example.com.jks"
                     certificateKeystorePassword="your_password"
                     certificateKeyAlias="tomcat"
                     type="RSA" />
    </SSLHostConfig>
</Connector>
```

**⚡ 参数优化说明**：
- `clientAuth="false"`：不要求客户端证书(一般网站设为false)
- `protocols="TLSv1.2,TLSv1.3"`：只允许安全的TLS版本
- `ciphers`：指定加密套件(提高安全性)
- `compression="on"`：启用压缩(节省带宽)

### 4.3 多域名SSL配置


**🌐 支持多个域名的配置**：

```xml
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
           maxThreads="150" SSLEnabled="true">
           
    <!-- 主域名配置 -->
    <SSLHostConfig hostName="example.com">
        <Certificate certificateKeystoreFile="conf/example.com.jks"
                     certificateKeystorePassword="password1"
                     type="RSA" />
    </SSLHostConfig>
    
    <!-- 子域名配置 -->
    <SSLHostConfig hostName="api.example.com">
        <Certificate certificateKeystoreFile="conf/api.example.com.jks"
                     certificateKeystorePassword="password2"
                     type="RSA" />
    </SSLHostConfig>
    
    <!-- 默认配置(当请求的域名没有匹配时使用) -->
    <SSLHostConfig hostName="_default_">
        <Certificate certificateKeystoreFile="conf/default.jks"
                     certificateKeystorePassword="password_default"
                     type="RSA" />
    </SSLHostConfig>
</Connector>
```

---

## 5. 🔗 证书链配置与验证


### 5.1 什么是证书链


**🎯 证书链的概念**：
证书链就像一个信任传递链条，从你的网站证书一直追溯到根证书颁发机构。

```
证书信任链示例：
根证书(Root CA) ← 浏览器内置信任
    ↓
中间证书(Intermediate CA) ← 由根CA签发
    ↓  
网站证书(End Entity) ← 由中间CA签发
    ↓
你的网站 ← 使用网站证书
```

**💡 为什么需要证书链**：
- **信任传递**：浏览器通过链条验证证书可信度
- **安全隔离**：根证书离线保存，中间证书负责日常签发
- **灵活管理**：可以吊销中间证书而不影响根证书

### 5.2 证书链验证方法


**🔍 使用OpenSSL验证证书链**：

```bash
# 验证证书链完整性
openssl verify -CAfile chain.pem cert.pem

# 查看证书链详情
openssl x509 -in fullchain.pem -text -noout

# 检查证书与私钥是否匹配
openssl x509 -noout -modulus -in cert.pem | openssl md5
openssl rsa -noout -modulus -in privkey.pem | openssl md5
# 两个MD5值应该相同
```

**🌐 在线验证工具**：
```
SSL Labs测试：https://www.ssllabs.com/ssltest/
• 全面的SSL配置分析
• 给出安全评级(A+、A、B、C、F)
• 检测已知漏洞和配置问题

其他在线工具：
• SSL Checker：检查证书安装是否正确
• Certificate Decoder：解析证书详细信息
```

### 5.3 常见证书链问题


**❌ 证书链不完整**：
```
问题现象：
• 某些浏览器显示证书错误
• 移动端访问出现安全警告
• API调用SSL验证失败

解决方法：
确保使用完整证书链(fullchain.pem)
而不是单独的网站证书(cert.pem)
```

**🔧 修复证书链**：
```bash
# 下载中间证书
wget https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem

# 合并证书链
cat cert.pem intermediate.pem > fullchain.pem

# 重新生成keystore
openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem \
    -out example.com.p12 -name tomcat
```

---

## 6. 🔄 HTTP自动跳转HTTPS


### 6.1 为什么需要HTTP重定向


**🎯 重定向的必要性**：
- **用户习惯**：很多用户直接输入网址不加https://
- **搜索引擎**：可能仍有http://链接指向你的网站
- **安全保障**：强制使用加密连接
- **SEO友好**：避免重复内容问题

### 6.2 Tomcat配置HTTP重定向


**⚙️ 方法一：修改server.xml**：

```xml
<!-- HTTP连接器配置 -->
<Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" />

<!-- HTTPS连接器配置 -->  
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
           maxThreads="150" SSLEnabled="true">
    <!-- SSL配置... -->
</Connector>
```

**📝 方法二：在web.xml中配置**：

```xml
<!-- 在web.xml的</web-app>标签前添加 -->
<security-constraint>
    <web-resource-collection>
        <web-resource-name>securedapp</web-resource-name>
        <url-pattern>/*</url-pattern>
    </web-resource-collection>
    <user-data-constraint>
        <transport-guarantee>CONFIDENTIAL</transport-guarantee>
    </user-data-constraint>
</security-constraint>
```

**🎯 配置说明**：
- `redirectPort="8443"`：HTTP请求自动跳转到HTTPS端口
- `<url-pattern>/*</url-pattern>`：对所有URL生效
- `CONFIDENTIAL`：要求使用SSL连接

### 6.3 应用级别重定向


**🔧 使用Filter实现重定向**：

```java
@WebFilter("/*")
public class HttpsRedirectFilter implements Filter {
    
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        
        // 检查是否为HTTPS请求
        if (!req.isSecure()) {
            String httpsURL = "https://" + req.getServerName() 
                            + ":" + getHttpsPort() 
                            + req.getRequestURI();
            if (req.getQueryString() != null) {
                httpsURL += "?" + req.getQueryString();
            }
            
            // 永久重定向到HTTPS
            resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
            resp.setHeader("Location", httpsURL);
            return;
        }
        
        chain.doFilter(request, response);
    }
    
    private int getHttpsPort() {
        // 从配置文件获取HTTPS端口，默认443
        return Integer.parseInt(
            System.getProperty("https.port", "443"));
    }
}
```

---

## 7. ⚡ SSL性能优化策略


### 7.1 SSL性能影响分析


**📊 性能开销来源**：
```
SSL握手过程：
• CPU密集型计算(加密解密)
• 增加1-2次网络往返
• 证书验证过程

数据传输过程：  
• 每个数据包都需要加密
• 增加少量CPU开销
• 数据包略微增大
```

**⏱️ 性能影响量化**：
- **握手延迟**：增加50-200ms
- **CPU开销**：增加10-15%
- **带宽开销**：增加2-5%
- **内存使用**：每个连接增加几KB

### 7.2 SSL优化配置


**🚀 Tomcat SSL优化配置**：

```xml
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
           maxThreads="200" 
           acceptCount="100"
           enableLookups="false"
           maxKeepAliveRequests="100"
           keepAliveTimeout="30000"
           SSLEnabled="true"
           compression="on"
           compressionMinSize="1024">
           
    <SSLHostConfig protocols="TLSv1.2,TLSv1.3"
                   sessionCacheSize="10000"
                   sessionTimeout="86400">
        <Certificate certificateKeystoreFile="conf/example.com.jks"
                     certificateKeystorePassword="your_password" />
    </SSLHostConfig>
</Connector>
```

**⚡ 优化参数说明**：
- `maxThreads="200"`：增加线程数处理更多并发
- `acceptCount="100"`：请求队列大小
- `enableLookups="false"`：禁用DNS查找(提升性能)
- `sessionCacheSize="10000"`：SSL会话缓存数量
- `sessionTimeout="86400"`：会话缓存时间(24小时)
- `compression="on"`：启用压缩减少数据传输

### 7.3 JVM SSL优化


**🔧 JVM启动参数优化**：

```bash
# Tomcat启动脚本中添加JVM参数
export CATALINA_OPTS="$CATALINA_OPTS \
    -Djava.security.egd=file:/dev/urandom \
    -Djavax.net.ssl.sessionCacheSize=20000 \
    -Djavax.net.ssl.sessionCacheTimeout=300 \
    -XX:+UseG1GC \
    -Xms2g -Xmx4g"
```

**🎯 参数解释**：
- `-Djava.security.egd=file:/dev/urandom`：使用更快的随机数生成器
- `-Djavax.net.ssl.sessionCacheSize=20000`：SSL会话缓存大小
- `-Djavax.net.ssl.sessionCacheTimeout=300`：会话缓存超时时间
- `-XX:+UseG1GC`：使用G1垃圾回收器(适合大内存)

### 7.4 HTTP/2启用


**🚀 启用HTTP/2协议**：

HTTP/2在HTTPS环境下能显著提升性能：
- **多路复用**：一个连接处理多个请求
- **头部压缩**：减少重复头部信息
- **服务器推送**：主动推送资源

```xml
<!-- Tomcat 8.5+支持HTTP/2 -->
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
           SSLEnabled="true">
    <!-- 启用HTTP/2 -->
    <UpgradeProtocol className="org.apache.coyote.http2.Http2Protocol" />
    
    <SSLHostConfig>
        <Certificate certificateKeystoreFile="conf/example.com.jks"
                     certificateKeystorePassword="your_password" />
    </SSLHostConfig>
</Connector>
```

---

## 8. 🔧 常见问题排查


### 8.1 SSL证书问题排查


**❌ 问题：证书不受信任**
```
现象：浏览器显示"连接不安全"
排查步骤：
1. 检查证书是否过期
   keytool -list -v -keystore example.com.jks
2. 验证证书链完整性  
   openssl verify -CAfile chain.pem cert.pem
3. 确认域名匹配
   检查证书CN和SAN字段是否包含访问域名
```

**❌ 问题：Tomcat启动失败**
```
常见错误信息：
"java.security.UnrecoverableKeyException"
• 密码错误：检查keystore密码和key密码
• 证书格式问题：确认使用正确的JKS格式

"java.security.KeyStoreException"  
• 文件路径错误：确认keystore文件路径正确
• 文件权限问题：确认Tomcat有读取权限
```

### 8.2 性能问题排查


**🐌 HTTPS访问很慢**
```
排查思路：
1. 检查SSL握手时间
   curl -w "@curl-format.txt" -o /dev/null -s https://example.com
   
2. 分析SSL配置
   • 检查是否启用会话复用
   • 确认使用高效的加密套件
   
3. 服务器资源检查
   • CPU使用率是否过高
   • 内存是否充足
   • 网络带宽是否充足
```

**📊 curl性能测试格式文件**：
```bash
# 创建curl-format.txt文件
cat > curl-format.txt << EOF
     time_namelookup:  %{time_namelookup}s\n
        time_connect:  %{time_connect}s\n
     time_appconnect:  %{time_appconnect}s\n
    time_pretransfer:  %{time_pretransfer}s\n
       time_redirect:  %{time_redirect}s\n
  time_starttransfer:  %{time_starttransfer}s\n
                     ----------\n
          time_total:  %{time_total}s\n
EOF
```

### 8.3 兼容性问题


**📱 移动端兼容性**
```
问题：某些旧版本手机无法访问
解决：
1. 添加兼容的加密套件
2. 支持较老的TLS版本(但要评估安全风险)
3. 检查证书链完整性

配置示例：
<SSLHostConfig protocols="TLSv1.1,TLSv1.2,TLSv1.3"
           ciphers="HIGH:!aNULL:!MD5:!3DES"
           honorCipherOrder="true">
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 HTTPS = HTTP + SSL/TLS加密，保障数据传输安全
🔸 SSL证书分为DV、OV、EV三类，免费证书适合个人项目
🔸 Keystore是Java应用存储证书的"保险箱"
🔸 证书链保证信任传递，必须配置完整证书链
🔸 HTTP重定向HTTPS是生产环境的安全要求
```

### 9.2 关键操作步骤


**🔹 SSL部署标准流程**
```
证书准备：
Step 1: 申请SSL证书(Let's Encrypt或商业CA)
Step 2: 转换证书格式(PEM → JKS)
Step 3: 配置Tomcat server.xml
Step 4: 设置HTTP重定向HTTPS
Step 5: 测试验证和性能优化
```

**🔹 问题排查思路**
```
遇到问题时的检查顺序：
1. 证书有效性(过期时间、域名匹配)
2. 文件权限和路径
3. 密码配置正确性
4. 证书链完整性
5. 网络和防火墙设置
```

### 9.3 生产环境最佳实践


**💼 安全配置建议**：
- **只使用TLS 1.2和1.3**：禁用不安全的旧版本协议
- **选择安全加密套件**：避免已知漏洞的加密算法
- **启用HTTP/2**：提升性能和用户体验
- **定期更新证书**：设置自动续期避免过期

**🔧 运维管理要点**：
- **监控证书过期时间**：提前30天更新证书
- **备份私钥和证书**：确保证书文件安全存储
- **性能监控**：关注SSL握手时间和服务器资源使用
- **日志审计**：记录SSL相关的访问和错误日志

**🎯 实用记忆要点**：
- 免费证书首选Let's Encrypt，90天自动续期
- PEM格式需要转换为JKS才能在Tomcat中使用  
- fullchain.pem包含完整证书链，比cert.pem更完整
- redirectPort设置实现HTTP到HTTPS的自动跳转
- SSL会话缓存和HTTP/2是性能优化的关键点

**核心记忆口诀**：
- 证书申请转格式，Keystore保险箱存储
- Server配置SSL连接，HTTP重定向HTTPS
- 证书链完整很重要，性能优化不能少
- 监控更新保安全，HTTPS部署就不难