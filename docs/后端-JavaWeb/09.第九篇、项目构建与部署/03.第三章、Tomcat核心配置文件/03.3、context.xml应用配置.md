---
title: 3、context.xml应用配置
---
## 📚 目录

1. [什么是context.xml配置文件](#1-什么是contextxml配置文件)
2. [Context元素核心配置](#2-context元素核心配置)
3. [数据源配置详解](#3-数据源配置详解)
4. [资源引用JNDI配置](#4-资源引用jndi配置)
5. [环境变量配置管理](#5-环境变量配置管理)
6. [监听器配置应用](#6-监听器配置应用)
7. [安全域配置实战](#7-安全域配置实战)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌟 什么是context.xml配置文件


### 1.1 基本概念理解


**什么是context.xml？**
简单来说，context.xml就像是你Web应用的"个人身份证"和"配置说明书"。

> 💡 **通俗理解**：如果把Web应用比作一个商店，context.xml就是这个商店的营业执照和经营规则说明书，里面记录了商店如何运营、需要什么资源、有什么特殊要求等。

```
Web应用结构：
MyWebApp/
├── WEB-INF/
│   ├── web.xml          ← 应用的基本配置（菜单）
│   ├── classes/         ← Java类文件（厨师和服务员）
│   └── lib/            ← 第三方库（工具和设备）
├── META-INF/
│   └── context.xml     ← 应用上下文配置（营业执照）
└── index.jsp           ← 网页文件（商品展示）
```

### 1.2 context.xml的作用


**核心作用**：
- 🎯 **应用级配置**：定义单个Web应用的特殊配置
- 🔗 **资源管理**：配置数据库连接池、JNDI资源等
- 🛡️ **安全设置**：配置安全域、用户认证等
- 🔧 **运行环境**：设置环境变量、系统参数等

**实际应用场景**：
```
场景1：电商网站
- 需要配置数据库连接池（存储商品信息）
- 需要配置缓存资源（提高访问速度）
- 需要配置安全域（保护用户信息）

场景2：企业管理系统  
- 需要配置多个数据源（不同部门数据库）
- 需要配置LDAP认证（员工登录验证）
- 需要配置邮件服务器（发送通知）
```

### 1.3 配置文件的位置


**三种配置位置**：

```
位置优先级：应用级 > 服务器级 > 全局级

1. 应用级配置（优先级最高）
   📁 MyWebApp/META-INF/context.xml
   ├── 只影响当前应用
   └── 最常用的配置方式

2. 服务器级配置
   📁 CATALINA_HOME/conf/Catalina/localhost/MyWebApp.xml
   ├── 独立于应用WAR包
   └── 便于运维管理

3. 全局级配置（优先级最低）
   📁 CATALINA_HOME/conf/context.xml
   ├── 影响所有应用
   └── 通用配置设置
```

---

## 2. ⚙️ Context元素核心配置


### 2.1 Context元素基本语法


**基础结构**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<Context path="/myapp" 
         docBase="myapp" 
         reloadable="true">
    
    <!-- 在这里配置各种资源和设置 -->
    
</Context>
```

**核心属性含义**：

| 属性 | **含义** | **通俗解释** | **示例值** |
|------|----------|-------------|-----------|
| `path` | 应用访问路径 | 网站的"门牌号" | `/myapp` |
| `docBase` | 应用文件位置 | 网站文件存放的"地址" | `myapp` 或 `/var/www/myapp` |
| `reloadable` | 是否自动重新加载 | 文件改变后是否"自动刷新" | `true`/`false` |

### 2.2 常用Context属性详解


**开发环境配置**：
```xml
<Context path="/myshop" 
         docBase="myshop"
         reloadable="true"
         debug="1">
    
    <!-- 开发时便于调试 -->
    
</Context>
```

**生产环境配置**：
```xml
<Context path="/myshop" 
         docBase="/app/myshop"
         reloadable="false"
         debug="0"
         crossContext="false">
    
    <!-- 生产环境注重性能和安全 -->
    
</Context>
```

### 2.3 路径配置详解


**路径配置的三种方式**：

```
方式1：相对路径配置
docBase="myapp"
├── 相对于webapps目录
└── 完整路径：CATALINA_HOME/webapps/myapp

方式2：绝对路径配置  
docBase="/var/www/myapp"
├── 使用完整的系统路径
└── 应用可以放在任意位置

方式3：WAR包配置
docBase="myapp.war"
├── 直接指向WAR文件
└── Tomcat自动解压部署
```

---

## 3. 💾 数据源配置详解


### 3.1 什么是数据源？


> 💡 **通俗理解**：数据源就像是一个"水龙头管理系统"。想象一下，你的Web应用需要用水（数据），传统方式是每次需要水都要挖井（创建数据库连接），而数据源就是预先建好的水库和管道系统，用水时直接拧开水龙头就行。

**数据源的优势**：
- ⚡ **性能提升**：连接复用，避免重复创建
- 🔒 **连接管理**：自动管理连接的创建和回收
- 📊 **资源控制**：限制最大连接数，防止资源耗尽
- 🛡️ **异常处理**：自动处理连接异常和重连

### 3.2 MySQL数据源配置


**基础MySQL数据源**：
```xml
<Context>
    <!-- MySQL数据库连接池配置 -->
    <Resource name="jdbc/MyDB"
              auth="Container"
              type="javax.sql.DataSource"
              driverClassName="com.mysql.cj.jdbc.Driver"
              url="jdbc:mysql://localhost:3306/myshop?useSSL=false&amp;serverTimezone=UTC"
              username="dbuser"
              password="dbpass"
              maxTotal="20"
              maxIdle="10"
              maxWaitMillis="10000"/>
</Context>
```

**配置参数详细说明**：

```
连接配置参数：
┌─────────────────────────────────┐
│ name: "jdbc/MyDB"              │ ← JNDI名称（类似变量名）
│ type: "javax.sql.DataSource"   │ ← 资源类型（说明这是数据源）
│ driverClassName: MySQL驱动     │ ← 数据库驱动（告诉Java用哪个驱动）
│ url: 数据库地址               │ ← 数据库位置和连接参数
│ username/password: 账号密码    │ ← 登录凭证
└─────────────────────────────────┘

连接池参数：
┌─────────────────────────────────┐
│ maxTotal: 20                   │ ← 最大连接数（水龙头总数）
│ maxIdle: 10                    │ ← 最大空闲连接数（备用水龙头）
│ maxWaitMillis: 10000           │ ← 获取连接最大等待时间
│ initialSize: 5                 │ ← 初始连接数（预备的水龙头）
└─────────────────────────────────┘
```

### 3.3 多数据源配置


**配置多个数据库连接**：
```xml
<Context>
    <!-- 主数据库：商品信息 -->
    <Resource name="jdbc/ProductDB"
              auth="Container" 
              type="javax.sql.DataSource"
              driverClassName="com.mysql.cj.jdbc.Driver"
              url="jdbc:mysql://192.168.1.100:3306/products"
              username="product_user"
              password="prod_pass"
              maxTotal="15"
              maxIdle="8"/>
    
    <!-- 用户数据库：用户信息 -->
    <Resource name="jdbc/UserDB"
              auth="Container"
              type="javax.sql.DataSource" 
              driverClassName="com.mysql.cj.jdbc.Driver"
              url="jdbc:mysql://192.168.1.101:3306/users"
              username="user_admin"
              password="user_pass"
              maxTotal="10"
              maxIdle="5"/>
</Context>
```

### 3.4 数据源使用示例


**在Java代码中使用数据源**：
```java
// 通过JNDI获取数据源
Context ctx = new InitialContext();
DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/MyDB");

// 获取数据库连接
Connection conn = ds.getConnection();

// 使用连接执行SQL
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM products");
ResultSet rs = stmt.executeQuery();

// 记住：用完一定要关闭连接，归还给连接池
rs.close();
stmt.close();
conn.close(); // 这里实际是归还给连接池，不是真正关闭
```

---

## 4. 🔗 资源引用JNDI配置


### 4.1 什么是JNDI？


> 💡 **通俗理解**：JNDI就像是一个"资源电话簿"。想象你要找一个朋友，你不需要记住他的具体地址，只要记住他的名字，然后查电话簿就能找到他。JNDI就是这样一个"电话簿"，你的应用不需要知道资源的具体位置，只要知道资源的名字就能找到它。

**JNDI全称**：Java Naming and Directory Interface（Java命名和目录接口）

**JNDI的作用**：
- 📋 **统一命名**：给各种资源起一个统一的名字
- 🔍 **资源查找**：通过名字快速找到需要的资源
- 🔄 **解耦合**：应用代码不依赖具体的资源配置
- 🌐 **跨平台**：不同服务器都支持JNDI标准

### 4.2 JNDI资源类型


**常见资源类型**：

```
数据源类型：
├── javax.sql.DataSource        ← 数据库连接池
├── javax.sql.XADataSource      ← 支持事务的数据源
└── javax.sql.ConnectionPoolDS  ← 连接池数据源

其他资源类型：
├── javax.mail.Session          ← 邮件会话
├── javax.jms.ConnectionFactory ← 消息队列连接工厂
├── java.net.URL                ← URL资源
└── java.lang.String            ← 字符串资源（配置参数）
```

### 4.3 邮件资源配置


**配置邮件发送服务**：
```xml
<Context>
    <!-- 邮件服务配置 -->
    <Resource name="mail/Session"
              auth="Container"
              type="javax.mail.Session"
              mail.smtp.host="smtp.gmail.com"
              mail.smtp.port="587"
              mail.smtp.auth="true"
              mail.smtp.starttls.enable="true"
              mail.smtp.user="myapp@gmail.com"
              password="mypassword"/>
</Context>
```

**在Java中使用邮件资源**：
```java
// 获取邮件会话
Context ctx = new InitialContext();
Session mailSession = (Session) ctx.lookup("java:comp/env/mail/Session");

// 创建邮件
Message msg = new MimeMessage(mailSession);
msg.setFrom(new InternetAddress("myapp@gmail.com"));
msg.setRecipient(Message.RecipientType.TO, 
                new InternetAddress("user@example.com"));
msg.setSubject("欢迎注册");
msg.setText("感谢您注册我们的网站！");

// 发送邮件
Transport.send(msg);
```

### 4.4 自定义字符串资源


**配置应用参数**：
```xml
<Context>
    <!-- 应用配置参数 -->
    <Environment name="app/version"
                 type="java.lang.String"
                 value="1.2.0"/>
    
    <Environment name="app/maxUploadSize" 
                 type="java.lang.Integer"
                 value="10485760"/>  <!-- 10MB -->
    
    <Environment name="app/debugMode"
                 type="java.lang.Boolean" 
                 value="false"/>
</Context>
```

---

## 5. 🌍 环境变量配置管理


### 5.1 环境变量的作用


> 💡 **通俗理解**：环境变量就像是应用的"设置面板"。不同的环境（开发、测试、生产）需要不同的设置，比如数据库地址、日志级别等。通过环境变量，你可以让同一个应用在不同环境中使用不同的配置。

**环境变量的优势**：
- 🔄 **灵活切换**：同一应用适应不同环境
- 🛡️ **安全性**：敏感信息不写死在代码中
- 🎛️ **易于管理**：集中管理所有配置参数
- 🚀 **快速部署**：修改配置不需要重新编译

### 5.2 Environment元素配置


**基本语法**：
```xml
<Context>
    <!-- 字符串类型环境变量 -->
    <Environment name="app/databaseUrl"
                 type="java.lang.String"
                 value="jdbc:mysql://localhost:3306/mydb"/>
    
    <!-- 数字类型环境变量 -->  
    <Environment name="app/sessionTimeout"
                 type="java.lang.Integer"
                 value="1800"/>
    
    <!-- 布尔类型环境变量 -->
    <Environment name="app/enableSSL"
                 type="java.lang.Boolean"
                 value="true"/>
</Context>
```

### 5.3 不同环境的配置策略


**开发环境配置**：
```xml
<!-- 开发环境：context.xml -->
<Context>
    <Environment name="app/profile" 
                 type="java.lang.String" 
                 value="development"/>
    
    <Environment name="app/logLevel"
                 type="java.lang.String"
                 value="DEBUG"/>
    
    <Environment name="app/cacheEnabled"
                 type="java.lang.Boolean" 
                 value="false"/>
    
    <!-- 开发数据库 -->
    <Resource name="jdbc/MyDB"
              url="jdbc:mysql://localhost:3306/myapp_dev"
              username="dev_user"
              password="dev_pass"/>
</Context>
```

**生产环境配置**：
```xml
<!-- 生产环境：context.xml -->
<Context>
    <Environment name="app/profile"
                 type="java.lang.String"
                 value="production"/>
    
    <Environment name="app/logLevel" 
                 type="java.lang.String"
                 value="WARN"/>
    
    <Environment name="app/cacheEnabled"
                 type="java.lang.Boolean"
                 value="true"/>
    
    <!-- 生产数据库 -->
    <Resource name="jdbc/MyDB"
              url="jdbc:mysql://prod-server:3306/myapp_prod"
              username="prod_user" 
              password="prod_secure_pass"/>
</Context>
```

### 5.4 在Java代码中读取环境变量


**读取环境变量的方法**：
```java
public class ConfigManager {
    
    // 读取字符串环境变量
    public static String getDatabaseUrl() {
        try {
            Context ctx = new InitialContext();
            return (String) ctx.lookup("java:comp/env/app/databaseUrl");
        } catch (NamingException e) {
            return "jdbc:mysql://localhost:3306/defaultdb"; // 默认值
        }
    }
    
    // 读取数字环境变量
    public static int getSessionTimeout() {
        try {
            Context ctx = new InitialContext();
            return (Integer) ctx.lookup("java:comp/env/app/sessionTimeout");
        } catch (NamingException e) {
            return 1800; // 默认30分钟
        }
    }
    
    // 读取布尔环境变量
    public static boolean isCacheEnabled() {
        try {
            Context ctx = new InitialContext();
            return (Boolean) ctx.lookup("java:comp/env/app/cacheEnabled");
        } catch (NamingException e) {
            return true; // 默认启用缓存
        }
    }
}
```

---

## 6. 👂 监听器配置应用


### 6.1 什么是监听器？


> 💡 **通俗理解**：监听器就像是一个"值班员"或"门卫"，它会一直"守候"在那里，当特定的事件发生时（比如有人进门、有人离开），它就会立即做出反应，执行相应的操作。

**监听器的作用**：
- 🚀 **启动初始化**：应用启动时执行初始化操作
- 🛑 **关闭清理**：应用关闭时清理资源
- 📊 **状态监控**：监控应用运行状态
- 🔧 **自动维护**：定期执行维护任务

### 6.2 应用生命周期监听器


**监听器配置示例**：
```xml
<Context>
    <!-- 应用生命周期监听器 -->
    <Listener className="com.myapp.listener.AppLifecycleListener"/>
    
    <!-- 内存泄漏检测监听器 -->
    <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener"/>
    
    <!-- 线程本地清理监听器 -->
    <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener"/>
</Context>
```

**自定义生命周期监听器**：
```java
public class AppLifecycleListener implements LifecycleListener {
    
    @Override
    public void lifecycleEvent(LifecycleEvent event) {
        
        // 应用启动时
        if (Lifecycle.START_EVENT.equals(event.getType())) {
            System.out.println("应用正在启动，执行初始化...");
            // 初始化缓存
            initializeCache();
            // 启动定时任务
            startScheduledTasks();
        }
        
        // 应用停止时
        if (Lifecycle.STOP_EVENT.equals(event.getType())) {
            System.out.println("应用正在停止，清理资源...");
            // 清理缓存
            clearCache();
            // 关闭定时任务
            shutdownScheduledTasks();
        }
    }
    
    private void initializeCache() {
        // 初始化缓存逻辑
    }
    
    private void clearCache() {
        // 清理缓存逻辑
    }
}
```

### 6.3 实际应用场景


**场景1：数据库连接池初始化**
```
应用启动监听器：
├── 检查数据库连接是否正常
├── 初始化连接池
├── 执行数据库升级脚本
└── 预热常用查询

应用停止监听器：
├── 关闭所有数据库连接
├── 清理连接池资源
└── 记录关闭日志
```

**场景2：定时任务管理**
```java
public class TaskSchedulerListener implements LifecycleListener {
    private ScheduledExecutorService scheduler;
    
    @Override
    public void lifecycleEvent(LifecycleEvent event) {
        if (Lifecycle.START_EVENT.equals(event.getType())) {
            // 启动定时任务
            scheduler = Executors.newScheduledThreadPool(5);
            
            // 每小时清理临时文件
            scheduler.scheduleAtFixedRate(new CleanupTask(), 
                                        0, 1, TimeUnit.HOURS);
            
            // 每天凌晨备份数据
            scheduler.scheduleAtFixedRate(new BackupTask(), 
                                        0, 24, TimeUnit.HOURS);
        }
        
        if (Lifecycle.STOP_EVENT.equals(event.getType())) {
            // 关闭定时任务
            if (scheduler != null) {
                scheduler.shutdown();
            }
        }
    }
}
```

---

## 7. 🛡️ 安全域配置实战


### 7.1 什么是安全域？


> 💡 **通俗理解**：安全域就像是一个"身份认证和权限管理系统"。想象一个公司大楼，不是谁都能随便进入，需要刷门禁卡，而且不同的人有不同的权限（有的只能进办公区，有的能进机房）。安全域就是这样一套"门禁系统"。

**安全域的功能**：
- 🔐 **身份认证**：验证用户是否是合法用户
- 👥 **权限管理**：控制用户能访问哪些资源
- 🔒 **访问控制**：保护敏感页面和功能
- 📝 **审计日志**：记录用户的访问行为

### 7.2 基于数据库的用户认证


**安全域配置**：
```xml
<Context>
    <!-- 数据库用户认证安全域 -->
    <Realm className="org.apache.catalina.realm.DataSourceRealm"
           dataSourceName="jdbc/MyDB"
           userTable="users"
           userNameCol="username" 
           userCredCol="password"
           userRoleTable="user_roles"
           roleNameCol="role_name"/>
    
    <!-- 数据源配置 -->
    <Resource name="jdbc/MyDB"
              auth="Container"
              type="javax.sql.DataSource"
              url="jdbc:mysql://localhost:3306/userdb"
              username="dbuser"
              password="dbpass"/>
</Context>
```

**用户表结构示例**：
```sql
-- 用户表
CREATE TABLE users (
    username VARCHAR(50) PRIMARY KEY,
    password VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    active BOOLEAN DEFAULT TRUE
);

-- 角色表
CREATE TABLE user_roles (
    username VARCHAR(50),
    role_name VARCHAR(50),
    PRIMARY KEY (username, role_name),
    FOREIGN KEY (username) REFERENCES users(username)
);

-- 示例数据
INSERT INTO users VALUES ('admin', 'admin123', 'admin@myapp.com', true);
INSERT INTO users VALUES ('user1', 'pass123', 'user1@myapp.com', true);

INSERT INTO user_roles VALUES ('admin', 'admin');
INSERT INTO user_roles VALUES ('admin', 'user');
INSERT INTO user_roles VALUES ('user1', 'user');
```

### 7.3 基于内存的简单认证


**内存安全域配置**：
```xml
<Context>
    <!-- 内存用户认证（适用于小型应用或测试） -->
    <Realm className="org.apache.catalina.realm.MemoryRealm"
           pathname="conf/tomcat-users.xml"/>
</Context>
```

**tomcat-users.xml配置**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<tomcat-users>
    <!-- 定义角色 -->
    <role rolename="admin"/>
    <role rolename="manager"/> 
    <role rolename="user"/>
    
    <!-- 定义用户和角色关系 -->
    <user username="admin" 
          password="admin123" 
          roles="admin,manager,user"/>
    
    <user username="manager" 
          password="manager123" 
          roles="manager,user"/>
    
    <user username="guest" 
          password="guest123" 
          roles="user"/>
</tomcat-users>
```

### 7.4 web.xml中的权限控制


**在web.xml中配置访问控制**：
```xml
<web-app>
    <!-- 安全约束 -->
    <security-constraint>
        <web-resource-collection>
            <web-resource-name>Admin Pages</web-resource-name>
            <url-pattern>/admin/*</url-pattern>
            <http-method>GET</http-method>
            <http-method>POST</http-method>
        </web-resource-collection>
        
        <auth-constraint>
            <role-name>admin</role-name>
        </auth-constraint>
    </security-constraint>
    
    <!-- 登录配置 -->
    <login-config>
        <auth-method>FORM</auth-method>
        <form-login-config>
            <form-login-page>/login.jsp</form-login-page>
            <form-error-page>/login-error.jsp</form-error-page>
        </form-login-config>
    </login-config>
    
    <!-- 安全角色声明 -->
    <security-role>
        <role-name>admin</role-name>
    </security-role>
    <security-role>
        <role-name>user</role-name>
    </security-role>
</web-app>
```

### 7.5 登录页面示例


**login.jsp登录页面**：
```jsp
<%@ page contentType="text/html;charset=UTF-8" %>
<html>
<head>
    <title>用户登录</title>
</head>
<body>
    <h2>请登录</h2>
    
    <!-- 注意：action必须是j_security_check -->
    <form method="POST" action="j_security_check">
        <table>
            <tr>
                <td>用户名：</td>
                <td><input type="text" name="j_username" required></td>
            </tr>
            <tr>
                <td>密码：</td>
                <td><input type="password" name="j_password" required></td>
            </tr>
            <tr>
                <td colspan="2">
                    <input type="submit" value="登录">
                </td>
            </tr>
        </table>
    </form>
</body>
</html>
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 context.xml本质：Web应用的个人配置文件，定义应用级的特殊设置
🔸 Context元素：应用上下文的根配置，包含路径、重载等基本属性
🔸 数据源配置：连接池管理，提供高效的数据库访问能力
🔸 JNDI资源：统一的资源命名和查找机制，实现配置与代码分离
🔸 环境变量：灵活的配置管理，支持不同环境的配置切换
🔸 监听器配置：应用生命周期管理，自动化的初始化和清理
🔸 安全域配置：用户认证和权限管理，保护应用安全
```

### 8.2 关键理解要点


**🔹 配置文件的作用层次**
```
理解要点：
- context.xml是应用级配置，优先级高于服务器全局配置
- 合理使用不同位置的context.xml文件
- 开发和生产环境使用不同的配置策略
```

**🔹 JNDI资源的优势**
```
核心价值：
- 配置与代码分离：修改配置不需要重新编译代码
- 资源复用：多个应用可以共享同一个资源
- 统一管理：所有资源配置集中在一个地方
```

**🔹 数据源连接池的重要性**
```
性能关键：
- 连接复用：避免频繁创建和销毁连接
- 资源控制：限制连接数，防止数据库过载
- 异常恢复：自动处理连接异常和重连
```

### 8.3 实际应用最佳实践


**💡 配置组织建议**
- **分环境配置**：开发、测试、生产使用不同的context.xml
- **敏感信息保护**：密码等敏感信息使用环境变量或外部文件
- **资源命名规范**：使用清晰的JNDI命名约定
- **连接池调优**：根据应用负载调整连接池参数

**🔧 常见配置模板**
```xml
<!-- 典型的生产环境配置模板 -->
<Context path="/myapp" 
         docBase="/app/myapp"
         reloadable="false"
         debug="0">
    
    <!-- 数据库连接池 -->
    <Resource name="jdbc/MyDB" 
              type="javax.sql.DataSource"
              url="jdbc:mysql://db-server:3306/myapp"
              maxTotal="20" 
              maxIdle="10"/>
    
    <!-- 应用参数 -->
    <Environment name="app/profile" 
                 value="production"/>
    
    <!-- 生命周期监听器 -->
    <Listener className="com.myapp.listener.AppLifecycleListener"/>
    
    <!-- 安全域 -->
    <Realm className="org.apache.catalina.realm.DataSourceRealm"
           dataSourceName="jdbc/MyDB"/>
           
</Context>
```

### 8.4 故障排查指南


**🔍 常见问题及解决方案**

| 问题类型 | **表现症状** | **可能原因** | **解决方法** |
|---------|-------------|-------------|-------------|
| **数据源连接失败** | `数据库连接异常` | `配置错误或数据库不可达` | `检查URL、用户名、密码和网络` |
| **JNDI查找失败** | `NameNotFoundException` | `资源名称不匹配` | `检查JNDI名称和lookup路径` |
| **权限认证问题** | `403 Forbidden错误` | `安全域配置错误` | `检查用户角色和权限配置` |
| **应用无法启动** | `Context启动失败` | `配置文件语法错误` | `检查XML语法和标签完整性` |

**⚠️ 安全注意事项**
- **生产环境**：关闭debug模式和reloadable属性
- **密码保护**：避免在配置文件中明文存储密码
- **权限最小化**：用户只分配必需的最小权限
- **定期审计**：定期检查用户权限和访问日志

**核心记忆**：
- context.xml是应用的身份证和配置手册
- JNDI让资源管理变得简单统一
- 数据源连接池是性能优化的关键
- 安全域保护应用免受未授权访问
- 监听器实现应用的自动化管理