---
title: 1、常见问题排查诊断
---
## 📚 目录

1. [任务执行问题排查](#1-任务执行问题排查)
2. [任务丢失与重复执行](#2-任务丢失与重复执行)
3. [超时与性能问题](#3-超时与性能问题)
4. [连接与通信问题](#4-连接与通信问题)
5. [资源与稳定性问题](#5-资源与稳定性问题)
6. [执行器注册问题](#6-执行器注册问题)
7. [问题排查工具箱](#7-问题排查工具箱)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚫 任务执行问题排查


### 1.1 任务不执行的常见原因


**什么是任务不执行？**
简单说就是你在调度中心配置了定时任务，时间到了但任务就是不跑。这是最常见也最让人头疼的问题。

**🔍 排查思路图**
```
任务不执行
    |
    ├─→ 调度中心问题?
    |      ├─ 任务状态是"运行中"吗？
    |      ├─ Cron表达式写对了吗？
    |      └─ 调度日志有记录吗？
    |
    ├─→ 执行器问题?
    |      ├─ 执行器在线吗？
    |      ├─ JobHandler注册成功吗？
    |      └─ 业务代码有异常吗？
    |
    └─→ 网络问题?
           ├─ 调度中心能访问执行器吗？
           └─ 防火墙/端口开放吗？
```

### 1.2 详细排查步骤


**步骤1：检查任务基本配置**

首先要确认任务配置本身没问题，这是最基础的检查：

| 检查项 | 如何检查 | 正常状态 |
|--------|---------|---------|
| **任务状态** | 调度中心任务列表查看 | 显示"运行中"🟢 |
| **Cron表达式** | 点击"下次执行时间"预览 | 时间符合预期 |
| **执行器选择** | 查看任务配置中的执行器 | 已选择且在线 |
| **路由策略** | 查看选择的路由模式 | 通常用"第一个"或"轮询" |

**步骤2：查看调度日志**

调度日志是问题诊断的第一手资料，能告诉你任务触发了没有：

```
登录XXL-JOB控制台
  → 点击"调度日志"
  → 筛选你的任务
  → 查看日志状态

日志状态含义：
✅ 成功：任务正常执行完成
❌ 失败：执行过程中出错
⏸️  运行中：任务还在执行
📭 无记录：任务根本没触发
```

**步骤3：检查执行器注册状态**

执行器必须成功注册到调度中心，否则任务发不出去：

```java
// 在调度中心查看执行器列表
调度中心 → 执行器管理 → 查看你的执行器

正常情况应该看到：
┌─────────────────────────────────┐
│ 执行器名称：xxl-job-executor    │
│ 注册方式：自动注册              │
│ 在线机器：192.168.1.100:9999   │
│ 状态：●在线                     │
└─────────────────────────────────┘

如果显示"离线"，说明执行器没注册上
```

### 1.3 典型问题与解决方案


**问题1：任务状态是"停止"**

这个最简单，就是任务被手动停止了：

```
解决办法：
1. 找到任务所在行
2. 点击"启动"按钮
3. 确认状态变为"运行中"
4. 观察下次调度时间
```

**问题2：Cron表达式写错了**

Cron表达式语法错误会导致任务永远不触发：

```
常见错误示例：

❌ 错误写法：0 0 12 * * ?
   含义：每天12点（但少了星期字段）
   
✅ 正确写法：0 0 12 * * ?
   含义：每天中午12点整

验证方法：
1. 在线Cron表达式生成器验证
2. 或在任务配置页点击"下次执行时间"
3. 如果显示"表达式错误"就要修改
```

**问题3：执行器选择错误**

任务配置时选择了错误的执行器：

```
场景说明：
你的订单服务执行器叫 "order-executor"
但任务配置时选择了 "user-executor"

结果：
订单任务发给了用户服务
用户服务里根本没有这个JobHandler
任务当然执行不了

解决办法：
1. 编辑任务配置
2. 选择正确的执行器
3. 确认执行器在线
4. 保存并重新触发
```

**问题4：JobHandler未注册**

代码写了但忘记加注解，这个问题特别常见：

```java
// ❌ 错误写法：没有加@XxlJob注解
public void myTask() {
    System.out.println("任务执行");
}

// ✅ 正确写法：必须加@XxlJob注解
@XxlJob("myTaskHandler")
public void myTask() {
    System.out.println("任务执行");
}

检查方法：
1. 查看执行器启动日志
2. 搜索 "xxl-job registry jobhandler"
3. 应该能看到你的handler名称
4. 如果没看到就是注解没加
```

---

## 2. 🔄 任务丢失与重复执行


### 2.1 任务丢失问题分析


**什么叫任务丢失？**
简单说就是该执行的任务没执行，就像快递丢了一样。比如每分钟执行一次的任务，12点01分的那次莫名其妙没跑。

**任务丢失的主要场景**

```
场景1：调度中心重启
时间线：
12:00:00 - 任务正常调度
12:00:30 - 调度中心重启（用了30秒）
12:01:00 - 这一分钟的任务丢了！

原因：重启期间无法触发调度

场景2：执行器全部下线
时间线：
12:00:00 - 所有执行器都在
12:00:30 - 所有执行器都挂了
12:01:00 - 任务无处可发，丢失！

原因：没有可用的执行器接收任务

场景3：调度过期策略
时间线：
12:00:00 - 任务应该执行
12:00:00 - 但所有执行器都忙着
12:00:10 - 超过了"过期时间"
结果：任务被标记为过期，忽略执行

原因：调度过期策略配置不当
```

### 2.2 任务重复执行问题


**什么是重复执行？**
就是同一个任务被执行了多次，本来只该跑一次，结果跑了两次甚至更多。

**重复执行的典型原因**

| 原因类型 | 场景描述 | 表现形式 |
|---------|---------|---------|
| **阻塞策略配置不当** | 任务执行时间超过调度周期 | 同一任务多个实例同时运行 |
| **手动重试操作** | 任务失败后在控制台手动重试 | 已成功的任务又被执行 |
| **路由策略问题** | 使用"广播"模式但只想单机执行 | 所有执行器都执行了一遍 |
| **时钟回拨** | 服务器时间被往前调整 | 已执行的任务又被触发 |

**阻塞策略详解**

这个概念很重要，直接决定了任务重复执行的行为：

```
假设：任务每分钟执行一次，但执行需要90秒

时间线演示：
12:00:00 → 第1次任务开始（预计12:01:30完成）
12:01:00 → 第2次调度来了，发现第1次还没完成
         ↓
根据阻塞策略做不同处理：

策略1：单机串行（推荐）
12:01:00 - 第2次任务等待
12:01:30 - 第1次任务完成
12:01:30 - 第2次任务开始执行
结果：✅ 不会重复，有序执行

策略2：丢弃后续调度
12:01:00 - 第2次任务直接丢弃
12:01:30 - 第1次任务完成
结果：⚠️  第2次任务丢失了

策略3：覆盖之前调度
12:01:00 - 停止第1次任务
12:01:00 - 启动第2次任务
结果：❌ 第1次任务被打断
```

### 2.3 防止丢失和重复的最佳实践


**防止任务丢失的方案**

```java
// 方案1：启用调度过期策略
在任务配置中设置：
调度过期策略：忽略
↓
修改为：
调度过期策略：立即执行一次

含义：
即使错过了调度时间
只要发现了就补执行一次

// 方案2：使用任务补偿机制
@XxlJob("orderTaskHandler")
public void orderTask() {
    // 1. 记录本次执行时间
    String executeTime = XxlJobHelper.getJobParam();
    
    // 2. 查询是否有遗漏的任务
    List<Order> missedOrders = checkMissedOrders(executeTime);
    
    // 3. 补偿执行遗漏的任务
    if (!missedOrders.isEmpty()) {
        processMissedOrders(missedOrders);
    }
    
    // 4. 执行当前任务
    processCurrentOrders();
}
```

**防止重复执行的方案**

```java
// 方案1：使用分布式锁
@XxlJob("paymentTaskHandler")
public void paymentTask() {
    String lockKey = "payment_task_lock";
    
    // 尝试获取锁（5秒超时）
    boolean locked = redisLock.tryLock(lockKey, 5, TimeUnit.SECONDS);
    
    if (!locked) {
        XxlJobHelper.log("任务正在执行中，跳过本次调度");
        return;
    }
    
    try {
        // 执行任务逻辑
        processPayment();
    } finally {
        // 释放锁
        redisLock.unlock(lockKey);
    }
}

// 方案2：设置合理的阻塞策略
推荐配置：
- 快速任务（<1秒）：单机串行
- 长时间任务（>调度周期）：丢弃后续调度
- 关键任务：单机串行 + 分布式锁双重保险

// 方案3：幂等性设计
@XxlJob("orderProcessHandler")
public void orderProcess() {
    // 1. 查询待处理订单
    List<Order> orders = getOrders();
    
    for (Order order : orders) {
        // 2. 检查订单状态（防重复）
        if (order.isProcessed()) {
            continue; // 已处理的跳过
        }
        
        // 3. 处理订单
        processOrder(order);
        
        // 4. 标记为已处理
        markAsProcessed(order.getId());
    }
}
```

---

## 3. ⏱️ 超时与性能问题


### 3.1 执行超时问题


**什么是执行超时？**
就像外卖送餐，超过了承诺时间还没送到。XXL-JOB中的任务超时是指任务执行时间超过了预设的超时时间。

**超时的三种表现**

```
表现1：任务被强制终止
现象：任务执行到一半突然停止
日志：看到 "job execute timeout" 
原因：超过了任务配置的超时时间

表现2：任务成功但有超时警告
现象：任务执行完了但标记为失败
日志：执行成功但超时
原因：执行时间>超时配置，但任务已完成

表现3：执行器无响应
现象：任务一直显示"运行中"
日志：长时间无日志输出
原因：执行器卡住了，调度中心等不到响应
```

### 3.2 超时排查与解决


**第一步：定位超时原因**

```java
// 在任务代码中加入详细日志
@XxlJob("dataProcessHandler")
public void dataProcess() {
    long startTime = System.currentTimeMillis();
    XxlJobHelper.log("任务开始执行");
    
    try {
        // 步骤1：查询数据
        long step1Start = System.currentTimeMillis();
        List<Data> dataList = queryData();
        XxlJobHelper.log("查询数据耗时：" + 
            (System.currentTimeMillis() - step1Start) + "ms");
        
        // 步骤2：处理数据  
        long step2Start = System.currentTimeMillis();
        processData(dataList);
        XxlJobHelper.log("处理数据耗时：" + 
            (System.currentTimeMillis() - step2Start) + "ms");
        
        // 步骤3：保存结果
        long step3Start = System.currentTimeMillis();
        saveResult();
        XxlJobHelper.log("保存结果耗时：" + 
            (System.currentTimeMillis() - step3Start) + "ms");
        
    } finally {
        XxlJobHelper.log("任务总耗时：" + 
            (System.currentTimeMillis() - startTime) + "ms");
    }
}
```

**第二步：针对性优化**

| 耗时环节 | 优化方案 | 效果 |
|---------|---------|------|
| **数据库查询慢** | 添加索引、优化SQL、分页查询 | 查询从5秒降到0.5秒 |
| **数据处理慢** | 批量处理、并行计算、算法优化 | 处理从10秒降到2秒 |
| **外部接口慢** | 异步调用、超时控制、缓存结果 | 调用从3秒降到0.3秒 |
| **单批数据量大** | 分批处理、分片执行 | 单次从1000条降到100条 |

**第三步：调整超时配置**

```
任务配置调整：

如果任务确实需要较长时间：
1. 进入任务配置
2. 找到"任务超时时间"
3. 从默认0（不超时）改为合理值
   - 快速任务：60秒
   - 一般任务：300秒（5分钟）
   - 慢任务：600秒（10分钟）

⚠️  注意：
- 不要设置太大，避免任务卡死无法发现
- 要预留20%以上的余量
- 定期review超时配置是否合理
```

### 3.3 性能优化实战


**优化案例1：大数据量处理**

```java
// ❌ 优化前：一次加载全部数据
@XxlJob("userDataHandler")
public void processUserData() {
    // 一次查10万用户，内存爆了！
    List<User> users = userMapper.selectAll();
    for (User user : users) {
        processUser(user);
    }
}

// ✅ 优化后：分页处理
@XxlJob("userDataHandler")
public void processUserData() {
    int pageSize = 1000; // 每次处理1000条
    int pageNum = 1;
    
    while (true) {
        // 分页查询
        List<User> users = userMapper.selectByPage(pageNum, pageSize);
        if (users.isEmpty()) {
            break; // 没数据了，结束
        }
        
        // 处理本页数据
        for (User user : users) {
            processUser(user);
        }
        
        XxlJobHelper.log("已处理第" + pageNum + "页，共" + users.size() + "条");
        pageNum++;
    }
}
```

**优化案例2：使用分片执行**

```java
// 场景：100万订单需要处理，单机太慢
@XxlJob("orderProcessHandler")
public void processOrders() {
    // 获取分片参数
    int shardIndex = XxlJobHelper.getShardIndex(); // 当前分片序号
    int shardTotal = XxlJobHelper.getShardTotal(); // 总分片数
    
    XxlJobHelper.log("当前分片：" + shardIndex + "/" + shardTotal);
    
    // 根据分片处理不同的数据
    // 比如：订单ID % 分片总数 = 分片序号
    List<Order> orders = orderMapper.selectBySharding(shardIndex, shardTotal);
    
    for (Order order : orders) {
        processOrder(order);
    }
    
    XxlJobHelper.log("分片" + shardIndex + "处理完成，共" + orders.size() + "条");
}

/*
工作原理：
假设配置了3个执行器，使用"分片广播"路由
执行器1：处理 ID % 3 = 0 的订单（33万）
执行器2：处理 ID % 3 = 1 的订单（33万）  
执行器3：处理 ID % 3 = 2 的订单（34万）

结果：3台机器并行，速度提升3倍！
*/
```

---

## 4. 🔌 连接与通信问题


### 4.1 数据库连接问题


**典型错误现象**

```
错误日志示例：
com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: 
Too many connections

翻译过来就是：数据库连接太多了，新连接建不上了
```

**原因分析图**

```
数据库连接问题
    |
    ├─→ 连接池配置太小
    |      ├─ 并发任务多，连接不够用
    |      └─ 默认配置只有10个连接
    |
    ├─→ 连接泄露
    |      ├─ 用完连接没归还
    |      └─ 异常处理不当
    |
    └─→ 数据库连接数限制
           ├─ MySQL默认151个连接
           └─ 超过限制就报错
```

**解决方案**

```yaml
# 优化连接池配置（application.yml）
spring:
  datasource:
    # 基础配置
    url: jdbc:mysql://localhost:3306/xxl_job
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
    
    # Hikari连接池配置（推荐）
    hikari:
      # 核心参数
      minimum-idle: 10          # 最小空闲连接数
      maximum-pool-size: 50     # 最大连接数（根据任务并发调整）
      connection-timeout: 30000 # 获取连接超时时间30秒
      
      # 保活检测
      max-lifetime: 1800000     # 连接最大存活时间30分钟
      idle-timeout: 600000      # 空闲连接超时时间10分钟
      
      # 连接测试
      connection-test-query: SELECT 1
```

```java
// 防止连接泄露的代码规范
@XxlJob("dataUpdateHandler")
public void updateData() {
    Connection conn = null;
    PreparedStatement pstmt = null;
    
    try {
        conn = dataSource.getConnection();
        pstmt = conn.prepareStatement("UPDATE ...");
        pstmt.executeUpdate();
    } catch (Exception e) {
        XxlJobHelper.log("执行失败：" + e.getMessage());
    } finally {
        // ⚠️  关键：必须在finally中关闭资源
        if (pstmt != null) {
            try { pstmt.close(); } catch (Exception e) {}
        }
        if (conn != null) {
            try { conn.close(); } catch (Exception e) {}
        }
    }
}
```

### 4.2 网络通信异常


**调度中心访问执行器失败**

这是最常见的网络问题，表现为调度日志显示"请求执行器失败"：

```
错误场景分析：

场景1：端口不通
调度中心：我要访问 192.168.1.100:9999
执行器：9999端口没开，或者被防火墙挡了
结果：❌ 连接超时

检查命令：
# 在调度中心服务器上执行
telnet 192.168.1.100 9999
# 如果连不上，说明网络不通

场景2：IP地址错误  
执行器注册的IP：192.168.1.100（内网IP）
调度中心访问：从外网访问内网IP
结果：❌ 路由不可达

解决：配置正确的IP
xxl:
  job:
    executor:
      ip: 公网IP或同网段IP

场景3：Docker容器网络问题
执行器在Docker容器内
注册的IP是容器内部IP（如172.17.0.2）
调度中心访问不到容器IP
结果：❌ 网络隔离

解决：使用宿主机IP
-e PARAMS="--xxl.job.executor.ip=宿主机IP"
```

**执行器注册失败**

```
错误日志：
xxl-job registry fail, registryParam:RegistryParam{...}

原因排查：

原因1：调度中心地址配置错误
# 检查配置
xxl:
  job:
    admin:
      addresses: http://localhost:8080/xxl-job-admin
                 ↑
                 这个地址执行器能访问到吗？

验证方法：
curl http://localhost:8080/xxl-job-admin
# 如果访问不到就要改地址

原因2：AccessToken不一致
调度中心配置：xxl.job.accessToken=abc123
执行器配置：xxl.job.accessToken=xyz789
          ↑
          不一致，认证失败！

解决：确保Token一致

原因3：网络防火墙限制
执行器 → 调度中心的请求被拦截

检查方法：
ping 调度中心IP
telnet 调度中心IP 端口
```

### 4.3 超时配置优化


**调度中心超时配置**

```properties
# xxl-job-admin配置文件
# 调度中心调用执行器的超时时间
xxl.job.triggerpool.fast.max=200        # 快速线程池最大线程数
xxl.job.triggerpool.slow.max=100        # 慢速线程池最大线程数

# 建议根据实际情况调整：
# - 任务执行快（<5秒）：增加fast线程池
# - 任务执行慢（>30秒）：增加slow线程池
# - 防止线程池满导致任务调度失败
```

**执行器超时配置**

```yaml
# 执行器端配置
xxl:
  job:
    executor:
      logretentiondays: 30    # 日志保留天数
      
# 任务级别超时配置（在调度中心配置）
任务配置 → 执行超时时间：60秒
含义：任务执行超过60秒会被标记为超时

注意事项：
1. 超时时间要大于任务实际执行时间
2. 预留20%以上的缓冲时间
3. 超时后任务会继续执行，只是标记为失败
```

---

## 5. 💾 资源与稳定性问题


### 5.1 内存溢出处理


**OOM的典型场景**

```
场景1：执行器处理大数据量
任务代码：
List<Data> dataList = queryAll(); // 查询100万条数据
                     ↑
                     一次性加载到内存，爆了！

错误日志：
java.lang.OutOfMemoryError: Java heap space

场景2：调度中心日志暴增
每分钟执行的任务 × 每个任务的日志 = 海量日志
日志全在内存里 → 内存不够 → OOM

错误日志：
java.lang.OutOfMemoryError: GC overhead limit exceeded
```

**内存问题排查工具**

```bash
# 1. 查看JVM内存使用情况
jmap -heap <进程ID>

输出示例：
Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 2147483648 (2048MB)
   
Heap Usage:
   PS Young Generation
   Eden Space:
      capacity = 536870912 (512.0MB)
      used     = 512000000 (488.3MB)  ← 快满了！
      
# 2. 导出内存快照分析
jmap -dump:format=b,file=heap.dump <进程ID>

# 3. 使用MAT工具分析heap.dump文件
#    找出占用内存最多的对象
```

**内存优化方案**

```java
// 方案1：分批处理数据
@XxlJob("bigDataHandler")
public void processBigData() {
    int batchSize = 500;  // 每批500条
    long lastId = 0;
    
    while (true) {
        // 每次只查询500条
        List<Data> batch = dataMapper.selectByIdGreaterThan(lastId, batchSize);
        if (batch.isEmpty()) break;
        
        // 处理本批数据
        processBatch(batch);
        
        // 更新lastId
        lastId = batch.get(batch.size() - 1).getId();
        
        // 手动触发GC（可选）
        System.gc();
    }
}

// 方案2：使用流式查询
@XxlJob("streamDataHandler")
public void streamProcess() {
    dataMapper.streamSelect(resultContext -> {
        Data data = resultContext.getResultObject();
        processData(data);  // 逐条处理，不占内存
    });
}
```

**JVM参数调优**

```bash
# 执行器启动参数
java -jar xxl-job-executor.jar \
  -Xms2g \              # 初始堆内存2G
  -Xmx2g \              # 最大堆内存2G（建议与Xms相同）
  -XX:MetaspaceSize=256m \     # 元空间初始大小
  -XX:MaxMetaspaceSize=512m \  # 元空间最大值
  -XX:+HeapDumpOnOutOfMemoryError \      # OOM时自动dump
  -XX:HeapDumpPath=/logs/heapdump.hprof  # dump文件位置

# 调度中心启动参数（处理更多调度任务）
java -jar xxl-job-admin.jar \
  -Xms4g \              # 初始堆内存4G
  -Xmx4g \              # 最大堆内存4G
  -XX:+UseG1GC \        # 使用G1垃圾回收器（推荐）
  -XX:MaxGCPauseMillis=200  # 最大GC停顿时间200ms
```

### 5.2 日志管理


**日志膨胀问题**

```
问题表现：
- 磁盘空间不足
- 日志查询很慢
- 数据库表过大

原因分析：
高频任务（每10秒一次）× 保留时间（30天）= 海量日志
每天8640次 × 30天 = 259200条日志记录
```

**日志清理策略**

```yaml
# 方案1：调整日志保留时间
xxl:
  job:
    executor:
      logretentiondays: 7  # 从30天改为7天
      
# 方案2：配置日志清理任务
在调度中心创建清理任务：

任务名称：日志清理任务
Cron表达式：0 0 3 * * ?  # 每天凌晨3点
JobHandler：logCleanHandler

```

```java
// 自定义日志清理逻辑
@XxlJob("logCleanHandler")
public void cleanLogs() {
    // 只保留7天内的日志
    Date sevenDaysAgo = DateUtils.addDays(new Date(), -7);
    
    // 删除旧日志
    int count = xxlJobLogMapper.deleteByDateBefore(sevenDaysAgo);
    
    XxlJobHelper.log("清理完成，删除了" + count + "条日志");
}
```

**日志分级存储**

```
策略设计：

重要任务（支付、订单）：
- 保留30天
- 详细日志
- 独立存储

一般任务（统计、同步）：
- 保留7天  
- 简要日志
- 共享存储

调试任务：
- 保留1天
- 详细日志
- 可快速清理
```

---

## 6. 📡 执行器注册问题


### 6.1 注册失败的常见原因


**自动注册原理**

```
执行器启动流程：
    |
    ├─ 1. 读取配置文件
    |     ├─ 调度中心地址
    |     ├─ 执行器AppName
    |     └─ 执行器端口
    |
    ├─ 2. 启动内嵌Server（Netty）
    |     └─ 监听9999端口（默认）
    |
    ├─ 3. 向调度中心注册
    |     ├─ 发送注册请求
    |     ├─ 携带IP、端口、AppName
    |     └─ 每30秒心跳一次
    |
    └─ 4. 调度中心响应
          ├─ 注册成功 → 显示在线
          └─ 注册失败 → 显示离线
```

**问题1：配置错误导致注册失败**

```yaml
# ❌ 错误配置示例
xxl:
  job:
    admin:
      addresses: http://127.0.0.1:8080/xxl-job-admin
                 ↑
                 问题：127.0.0.1只在本机有效
                      如果执行器在其他服务器上，访问不到！
    
    executor:
      appname: xxl-job-executor
               ↑
               问题：调度中心有没有这个执行器？
                    名字是否完全一致？
      
      port: 9999
            ↑
            问题：端口被占用了吗？
                 防火墙开放了吗？

# ✅ 正确配置示例
xxl:
  job:
    admin:
      addresses: http://192.168.1.10:8080/xxl-job-admin
                 ↑
                 使用真实IP，确保执行器能访问
    
    executor:
      appname: order-executor
               ↑
               与调度中心配置的执行器名称一致
      
      ip: 192.168.1.20  # 明确指定IP（推荐）
      port: 9999
      
      address:  # 自动注册地址（可选）
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
```

**问题2：网络不通**

```bash
# 检查步骤1：执行器能否访问调度中心
curl http://192.168.1.10:8080/xxl-job-admin

成功：返回登录页面HTML
失败：连接超时或拒绝

# 检查步骤2：调度中心能否访问执行器
telnet 192.168.1.20 9999

成功：Connected to 192.168.1.20
失败：Connection refused

# 检查步骤3：防火墙规则
# CentOS 7
firewall-cmd --list-ports
# 如果9999端口不在列表中，添加：
firewall-cmd --zone=public --add-port=9999/tcp --permanent
firewall-cmd --reload

# Ubuntu
ufw status
# 开放端口：
ufw allow 9999/tcp
```

### 6.2 手动注册配置


当自动注册有问题时，可以使用手动注册：

```yaml
# 手动注册配置
xxl:
  job:
    admin:
      addresses: http://192.168.1.10:8080/xxl-job-admin
    
    executor:
      appname: order-executor
      address: 192.168.1.20:9999  # 明确指定地址
      ip:  # 留空，使用address
      port: 9999
```

**手动注册步骤**

```
1. 登录调度中心
   → http://192.168.1.10:8080/xxl-job-admin
   
2. 进入执行器管理
   → 找到对应的执行器
   
3. 查看注册方式
   → 如果是"自动注册"但显示离线
   → 改为"手动录入"
   
4. 配置执行器地址
   → 在线机器地址：192.168.1.20:9999
   → 点击保存
   
5. 验证
   → 执行器列表应显示"在线"
   → 点击"注册节点"查看详情
```

### 6.3 注册问题排查清单


| 检查项 | 检查方法 | 正常标准 |
|--------|---------|---------|
| **配置文件** | 查看application.yml | admin.addresses可访问 |
| **执行器名称** | 对比调度中心配置 | 完全一致 |
| **端口占用** | `netstat -tuln | grep 9999` | 端口被Java进程占用 |
| **网络连通** | ping + telnet测试 | 双向连通 |
| **防火墙** | 检查防火墙规则 | 端口已开放 |
| **启动日志** | 查看执行器启动日志 | 无ERROR信息 |
| **AccessToken** | 对比两端配置 | 一致或都为空 |

---

## 7. 🔧 问题排查工具箱


### 7.1 日志查看技巧


**调度中心日志**

```bash
# 调度中心日志位置
/data/applogs/xxl-job/xxl-job-admin.log

# 实时查看日志
tail -f xxl-job-admin.log

# 过滤特定任务的日志
grep "任务名称" xxl-job-admin.log

# 查看错误日志
grep "ERROR" xxl-job-admin.log | tail -100

# 查看调度触发记录
grep "schedule trigger" xxl-job-admin.log
```

**执行器日志**

```bash
# 执行器日志位置
/data/applogs/xxl-job/jobhandler/

# 查看某个任务的日志（按日期）
cat /data/applogs/xxl-job/jobhandler/2025-01-28/12345.log

# 任务执行日志结构
┌─────────────────────────────────┐
│ 任务ID：12345                   │
│ 执行器：order-executor          │
│ 执行时间：2025-01-28 10:00:00   │
│ 执行参数：{...}                 │
│ ─────────────────────────────── │
│ [业务日志]                      │
│ 开始处理订单...                 │
│ 处理完成，共100条               │
│ ─────────────────────────────── │
│ 执行结果：SUCCESS               │
│ 执行耗时：2500ms                │
└─────────────────────────────────┘
```

### 7.2 数据库排查


**关键表说明**

```sql
-- 1. 任务配置表
SELECT * FROM xxl_job_info WHERE job_desc LIKE '%订单%';

-- 关键字段：
-- trigger_status: 0停止，1启动
-- trigger_last_time: 上次调度时间
-- trigger_next_time: 下次调度时间

-- 2. 调度日志表
SELECT * FROM xxl_job_log 
WHERE job_id = 1 
ORDER BY trigger_time DESC 
LIMIT 10;

-- 关键字段：
-- trigger_code: 200成功，500失败
-- handle_code: 200执行成功，500执行失败
-- handle_msg: 执行结果信息

-- 3. 执行器注册表
SELECT * FROM xxl_job_registry;

-- 关键字段：
-- registry_key: 执行器AppName
-- registry_value: 执行器地址
-- update_time: 最后心跳时间（超过90秒视为离线）
```

**常用排查SQL**

```sql
-- 查询失败的任务
SELECT 
    i.job_desc AS 任务名称,
    l.trigger_time AS 触发时间,
    l.handle_msg AS 失败原因
FROM xxl_job_log l
JOIN xxl_job_info i ON l.job_id = i.id
WHERE l.handle_code = 500
ORDER BY l.trigger_time DESC
LIMIT 20;

-- 查询执行超时的任务
SELECT 
    job_desc,
    TIMESTAMPDIFF(SECOND, trigger_time, handle_time) AS 执行时长秒
FROM xxl_job_log l
JOIN xxl_job_info i ON l.job_id = i.id
WHERE TIMESTAMPDIFF(SECOND, trigger_time, handle_time) > 60
ORDER BY trigger_time DESC;

-- 查询离线的执行器
SELECT 
    registry_key AS 执行器名称,
    registry_value AS 地址,
    update_time AS 最后心跳,
    TIMESTAMPDIFF(SECOND, update_time, NOW()) AS 离线时长秒
FROM xxl_job_registry
WHERE TIMESTAMPDIFF(SECOND, update_time, NOW()) > 90;
```

### 7.3 监控告警设置


**告警指标**

```
指标1：任务失败率
计算：最近1小时失败次数 / 总执行次数
阈值：> 10%
动作：发送钉钉/邮件告警

指标2：执行器离线
检测：心跳超过2分钟
阈值：任一执行器离线
动作：立即告警

指标3：任务阻塞
检测：运行中状态超过阈值
阈值：> 执行超时时间 × 1.5
动作：告警并分析

指标4：调度延迟
计算：实际执行时间 - 计划执行时间
阈值：> 60秒
动作：记录日志，延迟超过5分钟告警
```

**简易监控实现**

```java
@Component
public class JobMonitor {
    
    @Scheduled(cron = "0 */5 * * * ?") // 每5分钟检查一次
    public void checkJobHealth() {
        // 1. 检查任务失败率
        List<JobFailureInfo> failures = checkFailureRate();
        if (!failures.isEmpty()) {
            sendAlert("任务失败率过高", failures);
        }
        
        // 2. 检查执行器在线状态
        List<String> offlineExecutors = checkExecutorOnline();
        if (!offlineExecutors.isEmpty()) {
            sendAlert("执行器离线", offlineExecutors);
        }
        
        // 3. 检查任务阻塞情况
        List<JobBlockInfo> blocks = checkJobBlocking();
        if (!blocks.isEmpty()) {
            sendAlert("任务执行阻塞", blocks);
        }
    }
    
    private void sendAlert(String title, Object content) {
        // 发送钉钉告警
        dingTalkService.sendMessage(title, JSON.toJSONString(content));
        
        // 发送邮件告警
        emailService.sendAlert(title, content);
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 问题排查万能公式


```
遇到XXL-JOB问题时的排查顺序：

第1步：看日志（80%问题能定位）
   ├─ 调度中心日志：任务触发了吗？
   ├─ 执行器日志：任务执行了吗？
   └─ 业务日志：执行过程有异常吗？

第2步：查配置（15%问题在这里）
   ├─ Cron表达式对不对？
   ├─ 执行器名称一致吗？
   └─ 网络能连通吗？

第3步：看数据库（5%深层问题）
   ├─ 任务状态正常吗？
   ├─ 调度记录有吗？
   └─ 执行器注册了吗？
```

### 8.2 快速问题定位表


| 问题现象 | 第一步检查 | 第二步检查 | 解决方向 |
|---------|-----------|-----------|---------|
| 任务不执行 | 任务状态是否"运行中" | Cron表达式是否正确 | 启动任务/修改表达式 |
| 执行器离线 | 网络是否连通 | 端口是否开放 | 修复网络/开放端口 |
| 任务失败 | 查看执行日志 | 检查业务代码 | 修复业务逻辑 |
| 执行超时 | 查看执行时长 | 优化任务逻辑 | 分批处理/增加超时时间 |
| 内存溢出 | dump分析 | 检查数据量 | 分批处理/调整JVM |
| 重复执行 | 检查阻塞策略 | 查看路由策略 | 调整策略/加分布式锁 |

### 8.3 预防性措施


**代码层面**

```java
// 1. 完善的异常处理
@XxlJob("robustTaskHandler")
public void robustTask() {
    try {
        // 业务逻辑
        doSomething();
        
        // 主动记录成功日志
        XxlJobHelper.handleSuccess("处理成功");
        
    } catch (Exception e) {
        // 记录详细错误信息
        XxlJobHelper.log("执行失败：" + e.getMessage());
        XxlJobHelper.handleFail(e.getMessage());
    }
}

// 2. 合理的超时控制
@XxlJob("timeoutTaskHandler")
public void taskWithTimeout() {
    long startTime = System.currentTimeMillis();
    long timeout = 60000; // 60秒超时
    
    while (hasMoreData()) {
        // 检查超时
        if (System.currentTimeMillis() - startTime > timeout) {
            XxlJobHelper.log("任务超时，已处理部分数据");
            break;
        }
        processData();
    }
}

// 3. 幂等性保证
@XxlJob("idempotentTaskHandler")  
public void idempotentTask() {
    String taskId = generateTaskId(); // 生成唯一任务ID
    
    // 检查是否已执行
    if (isTaskExecuted(taskId)) {
        XxlJobHelper.log("任务已执行，跳过");
        return;
    }
    
    try {
        // 执行业务
        doTask();
        
        // 标记已执行
        markTaskAsExecuted(taskId);
    } catch (Exception e) {
        // 失败则清除标记，允许重试
        removeTaskMark(taskId);
        throw e;
    }
}
```

**配置层面**

```yaml
# 推荐配置模板
xxl:
  job:
    admin:
      addresses: http://具体IP:8080/xxl-job-admin
    
    accessToken: 设置强密码Token
    
    executor:
      appname: 有意义的执行器名称
      ip: 明确指定IP（避免自动获取错误）
      port: 9999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 7  # 不要太长，避免日志暴增

# JVM参数推荐
-Xms2g -Xmx2g
-XX:+UseG1GC
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/logs/dump
```

**运维层面**

```
1. 监控告警
   ✅ 配置任务失败告警
   ✅ 配置执行器离线告警
   ✅ 配置执行超时告警

2. 定期巡检
   ✅ 每周检查失败任务
   ✅ 每月清理无用任务
   ✅ 每季度优化慢任务

3. 文档记录
   ✅ 记录每个任务的用途
   ✅ 记录配置变更历史
   ✅ 记录问题解决方案
```

**核心记忆口诀**
```
问题排查看日志，
配置网络要仔细。
超时优化分批量，
幂等防重加锁具。
监控告警不能少，
定期巡检保稳固。
```