---
title: 6、多环境配置管理
---
## 📚 目录

1. [为什么需要多环境配置](#1-为什么需要多环境配置)
2. [环境类型详解](#2-环境类型详解)
3. [配置隔离策略](#3-配置隔离策略)
4. [Spring Profile环境管理](#4-Spring-Profile环境管理)
5. [XXL-JOB多环境实战](#5-XXL-JOB多环境实战)
6. [环境切换最佳实践](#6-环境切换最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 为什么需要多环境配置


### 1.1 实际开发场景


**问题场景**：
想象你在开发一个电商系统的定时任务，比如"每天凌晨清理过期订单"。如果开发、测试、生产都用同一套配置，会出现什么问题？

```
❌ 糟糕的情况：
开发时：连接生产数据库 → 误删了真实用户订单！
测试时：调度时间是凌晨 → 白天测试要等到半夜？
上线时：还用着测试数据库 → 生产任务根本跑不起来！
```

**为什么需要分环境**：

| 问题 | 原因 | 多环境解决方案 |
|------|------|---------------|
| **数据安全** | `开发测试可能误操作生产数据` | 不同环境连接不同数据库 |
| **调试效率** | `生产定时凌晨跑，开发调试要等很久` | 开发环境可以随时触发执行 |
| **配置差异** | `不同环境的服务器地址、参数都不同` | 各环境独立配置互不影响 |
| **问题隔离** | `测试问题影响生产，生产问题影响开发` | 环境隔离，各自独立运行 |

### 1.2 多环境的本质理解


**简单理解**：
```
就像你有三套房子：
- 开发环境(dev)：自己家，随便折腾，弄坏了重装
- 测试环境(test)：朋友家，小心点用，验证没问题
- 生产环境(prod)：客户家，绝对不能出错

每套房子的钥匙(配置)、家具(数据)都是独立的
```

**核心目标**：
```
🎯 互不干扰：开发调试不影响生产
🎯 安全可控：配置分离降低风险
🎯 灵活切换：根据场景快速切换环境
🎯 便于管理：统一管理不同环境配置
```

---

## 2. 🏢 环境类型详解


### 2.1 开发环境（Development）


**用途和特点**：
```
🔸 谁在用：开发人员日常编码调试
🔸 数据特点：测试数据，可以随意修改删除
🔸 性能要求：不高，重点是方便调试
🔸 稳定性：可以频繁重启，出错不影响他人
```

**典型配置特点**：
```yaml
# 开发环境特征
xxl.job:
  admin.addresses: http://localhost:8080/xxl-job-admin  # 本地调度中心
  executor:
    appname: xxl-job-executor-dev                       # 开发专用执行器名称
    port: 9999                                          # 本地端口
    
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/dev_db            # 本地开发库
```

**使用场景举例**：
- 写新功能时的代码测试
- 调试定时任务的执行逻辑
- 查看任务执行日志排查问题

### 2.2 测试环境（Test/QA）


**用途和特点**：
```
🔸 谁在用：测试人员验证功能，开发人员联调
🔸 数据特点：模拟生产的测试数据，相对稳定
🔸 性能要求：接近生产，用于性能测试
🔸 稳定性：较高，频繁变更需要通知
```

**典型配置特点**：
```yaml
# 测试环境特征
xxl.job:
  admin.addresses: http://test-xxljob.company.com/xxl-job-admin  # 测试调度中心
  executor:
    appname: xxl-job-executor-test                               # 测试执行器
    port: 9998
    
spring:
  datasource:
    url: jdbc:mysql://test-mysql.company.com:3306/test_db       # 测试数据库
```

**使用场景举例**：
- 功能测试：验证定时任务逻辑正确性
- 集成测试：多个系统联调定时任务
- 压力测试：验证任务在高并发下表现

### 2.3 预生产环境（Pre-Production/Staging）


**用途和特点**：
```
🔸 谁在用：上线前的最后验证
🔸 数据特点：完全模拟生产数据（脱敏后）
🔸 性能要求：与生产完全一致
🔸 稳定性：高度稳定，变更需审批
```

**为什么需要预生产**：
```
真实案例：
某电商定时任务在测试环境运行良好，
上生产后因为数据量大100倍导致超时失败。

预生产环境就是为了提前发现这类问题：
✓ 真实数据量级
✓ 真实网络环境
✓ 真实服务器配置
```

**典型配置特点**：
```yaml
# 预生产环境特征（与生产几乎一致）
xxl.job:
  admin.addresses: http://uat-xxljob.company.com/xxl-job-admin
  executor:
    appname: xxl-job-executor-uat
    port: 9997
```

### 2.4 生产环境（Production）


**用途和特点**：
```
🔸 谁在用：真实用户使用的正式环境
🔸 数据特点：真实业务数据，绝不能出错
🔸 性能要求：最高，需要保证稳定高效
🔸 稳定性：极高，任何变更都要经过严格审批
```

**生产环境的特殊要求**：
```
安全性：
✓ 配置信息加密存储
✓ 数据库密码定期更换
✓ 访问权限严格控制

稳定性：
✓ 灰度发布（先部分机器）
✓ 实时监控告警
✓ 快速回滚机制

高可用：
✓ 多节点部署
✓ 负载均衡
✓ 故障自动切换
```

### 2.5 环境对比总结


**环境金字塔**：
```
            🔺 生产环境(Prod)
           [严格管控，绝对稳定]
                    ▲
                    |
          🔺 预生产环境(UAT)
         [模拟生产，上线验证]
                    ▲
                    |
            🔺 测试环境(Test)
           [功能测试，集成验证]
                    ▲
                    |
          🔺 开发环境(Dev)
         [日常开发，快速迭代]
```

| 环境 | **变更频率** | **数据重要性** | **稳定性要求** | **访问权限** |
|------|------------|--------------|--------------|------------|
| **开发** | `极高，随时变更` | `低，测试数据` | `低，可以出错` | `开发人员` |
| **测试** | `高，版本迭代` | `中，模拟数据` | `中，相对稳定` | `开发+测试` |
| **预生产** | `低，上线前验证` | `高，脱敏真实数据` | `高，接近生产` | `开发+测试+运维` |
| **生产** | `极低，严格审批` | `极高，真实业务` | `极高，不能出错` | `运维+少数核心` |

---

## 3. 🔐 配置隔离策略


### 3.1 什么是配置隔离


**通俗理解**：
```
配置隔离就像给不同环境配不同的"身份证"

开发环境的"身份证"：
- 姓名(应用名)：xxl-job-dev
- 住址(数据库)：localhost:3306
- 电话(端口)：9999

生产环境的"身份证"：
- 姓名(应用名)：xxl-job-prod
- 住址(数据库)：prod-db.company.com:3306
- 电话(端口)：9997

两个环境互不干扰，各用各的"身份"
```

**核心原则**：
```
🔸 物理隔离：不同环境使用不同的服务器、数据库
🔸 逻辑隔离：同一服务器上通过配置区分环境
🔸 数据隔离：不同环境的数据完全独立
🔸 网络隔离：生产网络与开发测试网络分开
```

### 3.2 配置项分类管理


**哪些配置需要区分环境**：

**必须区分的配置**：
```yaml
# 这些配置在不同环境肯定不同
xxl.job.admin.addresses:     # 调度中心地址
  - dev:  http://localhost:8080/xxl-job-admin
  - test: http://test-xxljob.company.com
  - prod: http://prod-xxljob.company.com

spring.datasource.url:        # 数据库连接
  - dev:  jdbc:mysql://localhost:3306/dev_db
  - test: jdbc:mysql://test-db:3306/test_db
  - prod: jdbc:mysql://prod-db:3306/prod_db

xxl.job.executor.port:        # 执行器端口
  - dev:  9999
  - test: 9998
  - prod: 9997
```

**可能需要区分的配置**：
```yaml
# 这些配置在不同环境可能有差异
xxl.job.executor.logretentiondays:  # 日志保留天数
  - dev:  3      # 开发环境磁盘小，只保留3天
  - test: 7      # 测试环境保留1周
  - prod: 30     # 生产环境保留1个月

logging.level:                      # 日志级别
  - dev:  DEBUG  # 开发环境详细日志便于调试
  - test: INFO   # 测试环境一般日志
  - prod: WARN   # 生产环境只记录警告和错误
```

**不需要区分的配置**：
```yaml
# 这些配置所有环境都一样
xxl.job.executor.logpath: /data/applogs/xxl-job  # 日志路径标准
spring.application.name: order-executor          # 应用名称固定
```

### 3.3 配置敏感信息处理


**敏感信息识别**：
```
什么是敏感信息？
✓ 数据库密码
✓ Redis密码
✓ 第三方API密钥
✓ 调度中心的AccessToken
✓ 加密密钥
```

**配置加密方案**：

**方案一：Jasypt加密（推荐）**
```yaml
# 密码不再明文存储
spring:
  datasource:
    password: ENC(MJx7K9Zv8aR2pQ5nB3hL1wG6fY4tE0sC)  # 加密后的密码
```

配置步骤说明：
```
步骤1：添加Jasypt依赖
步骤2：配置加密密钥（通过环境变量传入）
步骤3：使用工具加密敏感信息
步骤4：配置文件中使用ENC()包裹密文
```

**方案二：配置中心（适合大型项目）**
```
使用场景：
- 多个应用共享配置
- 配置需要动态更新
- 配置需要版本管理

常用工具：
✓ Apollo（携程开源）
✓ Nacos（阿里开源）
✓ Spring Cloud Config
```

配置中心优势：
```
集中管理：   所有环境配置统一管理
权限控制：   不同环境不同人员权限
动态更新：   配置修改无需重启应用
版本回滚：   配置出错可快速回滚
审计日志：   记录谁改了什么配置
```

---

## 4. ⚙️ Spring Profile环境管理


### 4.1 Profile机制原理


**什么是Profile**：
```
Profile是Spring提供的环境管理机制

简单理解：
就像你的手机有多个情景模式：
- 工作模式：静音、只接重要电话
- 休息模式：勿扰、屏蔽工作消息
- 运动模式：开启计步、关闭流量

Spring Profile也是类似，不同环境激活不同配置
```

**Profile的核心价值**：
- 一套代码适配多个环境
- 根据启动参数自动选择配置
- 便于团队协作和部署

### 4.2 配置文件命名规范


**标准命名格式**：
```
application.yml              → 公共配置（所有环境通用）
application-dev.yml          → 开发环境专用配置
application-test.yml         → 测试环境专用配置
application-uat.yml          → 预生产环境专用配置
application-prod.yml         → 生产环境专用配置
```

**配置文件结构示例**：
```
src/main/resources/
├── application.yml           # 主配置文件
├── application-dev.yml       # 开发环境配置
├── application-test.yml      # 测试环境配置
├── application-uat.yml       # 预生产配置
└── application-prod.yml      # 生产环境配置
```

### 4.3 主配置文件设置


**application.yml（公共配置）**：
```yaml
# 所有环境都需要的配置
spring:
  application:
    name: xxl-job-executor

# 指定激活哪个环境（开发时默认dev）
spring:
  profiles:
    active: dev

# 公共的XXL-JOB配置
xxl:
  job:
    executor:
      logpath: /data/applogs/xxl-job
      logretentiondays: 30
```

**配置加载优先级**：
```
加载顺序（后加载的会覆盖先加载的）：

1. application.yml        # 首先加载公共配置
2. application-{profile}.yml  # 然后加载环境特定配置
3. 环境变量/命令行参数      # 最后加载外部配置（优先级最高）

示例：
application.yml中:        port: 8080
application-dev.yml中:    port: 9999
最终开发环境使用:          port: 9999 ✓
```

### 4.4 各环境配置文件


**application-dev.yml（开发环境）**：
```yaml
# 开发环境专用配置
xxl:
  job:
    admin:
      addresses: http://localhost:8080/xxl-job-admin
    executor:
      appname: xxl-job-executor-dev
      port: 9999
      ip: 127.0.0.1

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/dev_db?useUnicode=true&characterEncoding=UTF-8
    username: root
    password: 123456

# 开发环境使用DEBUG日志
logging:
  level:
    root: INFO
    com.yourcompany: DEBUG
```

**application-prod.yml（生产环境）**：
```yaml
# 生产环境专用配置
xxl:
  job:
    admin:
      addresses: http://prod-xxljob-01.company.com,http://prod-xxljob-02.company.com  # 高可用集群
    accessToken: your-secure-token-here  # 生产环境启用token验证
    executor:
      appname: xxl-job-executor-prod
      port: 9997
      ip:  # 为空则自动获取，适合多网卡服务器

spring:
  datasource:
    url: jdbc:mysql://prod-db.company.com:3306/prod_db?useUnicode=true&characterEncoding=UTF-8
    username: prod_user
    password: ENC(aMx8K0Zw9bS3qR6oC4iM2xH7gZ5uF1vD)  # 加密后的密码

# 生产环境只记录WARN及以上级别日志
logging:
  level:
    root: WARN
    com.yourcompany: INFO
```

### 4.5 Profile激活方式


**方式一：配置文件指定（适合开发）**
```yaml
# application.yml中指定
spring:
  profiles:
    active: dev  # 默认激活开发环境
```

**方式二：命令行参数（适合运维）**
```bash
# 启动时指定环境
java -jar xxl-job-executor.jar --spring.profiles.active=prod

# 或者使用-D参数
java -Dspring.profiles.active=prod -jar xxl-job-executor.jar
```

**方式三：环境变量（适合容器化）**
```bash
# Linux环境变量
export SPRING_PROFILES_ACTIVE=prod
java -jar xxl-job-executor.jar

# Docker容器启动
docker run -e SPRING_PROFILES_ACTIVE=prod your-image
```

**方式四：IDE配置（适合本地调试）**
```
IDEA配置步骤：
1. 打开Run/Debug Configurations
2. 找到Environment variables
3. 添加：SPRING_PROFILES_ACTIVE=dev
4. 点击Apply保存
```

---

## 5. 🚀 XXL-JOB多环境实战


### 5.1 完整配置示例


**项目结构**：
```
xxl-job-executor/
├── src/main/resources/
│   ├── application.yml           # 主配置
│   ├── application-dev.yml       # 开发配置
│   ├── application-test.yml      # 测试配置
│   └── application-prod.yml      # 生产配置
└── pom.xml
```

**主配置文件（application.yml）**：
```yaml
# =================== 公共配置 ===================
spring:
  application:
    name: order-task-executor

# =================== XXL-JOB通用配置 ===================
xxl:
  job:
    executor:
      # 日志路径（所有环境统一）
      logpath: /data/applogs/xxl-job/jobhandler
      # 日志保留天数
      logretentiondays: 30
```

**开发环境配置（application-dev.yml）**：
```yaml
# =================== 开发环境 ===================
xxl:
  job:
    admin:
      addresses: http://localhost:8080/xxl-job-admin
    executor:
      appname: order-task-executor-dev
      port: 9999
      ip: 127.0.0.1

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/order_dev?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver

# 开发环境启用详细日志
logging:
  level:
    com.xxl.job: DEBUG
    com.yourcompany.task: DEBUG
```

**生产环境配置（application-prod.yml）**：
```yaml
# =================== 生产环境 ===================
xxl:
  job:
    admin:
      # 调度中心集群地址
      addresses: http://xxljob-01.prod.com/xxl-job-admin,http://xxljob-02.prod.com/xxl-job-admin
    # 启用访问令牌
    accessToken: ${XXL_JOB_ACCESS_TOKEN}  # 从环境变量读取
    executor:
      appname: order-task-executor-prod
      port: 9997
      # IP自动获取
      ip: 
      # 日志路径
      logpath: /data/applogs/xxl-job/jobhandler
      # 日志保留天数（生产环境保留更久）
      logretentiondays: 60

spring:
  datasource:
    url: jdbc:mysql://prod-db.company.com:3306/order_prod?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: ${DB_USERNAME}  # 从环境变量读取
    password: ${DB_PASSWORD}  # 从环境变量读取
    driver-class-name: com.mysql.cj.jdbc.Driver
    # 连接池配置
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

# 生产环境日志配置
logging:
  level:
    root: WARN
    com.xxl.job: INFO
    com.yourcompany.task: INFO
  file:
    name: /data/logs/executor.log
    max-size: 100MB
    max-history: 30
```

### 5.2 执行器代码配置


**XxlJobConfig.java（配置类）**：
```java
@Configuration
public class XxlJobConfig {
    
    // 从配置文件读取值
    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;
    
    @Value("${xxl.job.accessToken:}")  // 默认为空
    private String accessToken;
    
    @Value("${xxl.job.executor.appname}")
    private String appname;
    
    @Value("${xxl.job.executor.port}")
    private int port;
    
    @Value("${xxl.job.executor.logpath}")
    private String logPath;
    
    @Value("${xxl.job.executor.logretentiondays}")
    private int logRetentionDays;
    
    @Bean
    public XxlJobSpringExecutor xxlJobExecutor() {
        XxlJobSpringExecutor executor = new XxlJobSpringExecutor();
        
        // 设置调度中心地址
        executor.setAdminAddresses(adminAddresses);
        // 设置访问令牌（生产环境必需）
        executor.setAccessToken(accessToken);
        // 设置执行器AppName
        executor.setAppname(appname);
        // 设置执行器端口
        executor.setPort(port);
        // 设置日志路径
        executor.setLogPath(logPath);
        // 设置日志保留天数
        executor.setLogRetentionDays(logRetentionDays);
        
        return executor;
    }
}
```

### 5.3 任务处理器示例


**OrderTaskHandler.java**：
```java
@Component
public class OrderTaskHandler {
    
    @Value("${spring.profiles.active}")
    private String env;  // 获取当前环境
    
    /**
     * 清理过期订单任务
     * 不同环境有不同的清理策略
     */
    @XxlJob("cleanExpiredOrders")
    public void cleanExpiredOrders() {
        XxlJobHelper.log("当前环境: {}", env);
        
        // 根据环境执行不同逻辑
        if ("dev".equals(env)) {
            // 开发环境：清理1天前的测试订单
            XxlJobHelper.log("开发环境：清理1天前订单");
            // 执行清理逻辑...
        } else if ("prod".equals(env)) {
            // 生产环境：清理30天前的订单
            XxlJobHelper.log("生产环境：清理30天前订单");
            // 执行清理逻辑...
        }
    }
}
```

---

## 6. 🔄 环境切换最佳实践


### 6.1 本地开发环境切换


**IDEA开发工具配置**：
```
步骤1：Edit Configurations
步骤2：选择Spring Boot应用
步骤3：在Environment variables中添加：
       SPRING_PROFILES_ACTIVE=dev

快速切换方法：
- 创建多个运行配置（dev、test各一个）
- 需要切换时选择对应配置启动即可
```

**Maven多环境构建**：
```xml
<!-- pom.xml中配置多环境 -->
<profiles>
    <profile>
        <id>dev</id>
        <properties>
            <spring.profiles.active>dev</spring.profiles.active>
        </properties>
        <activation>
            <activeByDefault>true</activeByDefault>  <!-- 默认激活 -->
        </activation>
    </profile>
    
    <profile>
        <id>test</id>
        <properties>
            <spring.profiles.active>test</spring.profiles.active>
        </properties>
    </profile>
    
    <profile>
        <id>prod</id>
        <properties>
            <spring.profiles.active>prod</spring.profiles.active>
        </properties>
    </profile>
</profiles>
```

构建命令：
```bash
# 构建开发环境包
mvn clean package -P dev

# 构建生产环境包
mvn clean package -P prod
```

### 6.2 测试环境部署


**部署脚本示例（deploy-test.sh）**：
```bash
#!/bin/bash

APP_NAME="xxl-job-executor"
ENV="test"
JAR_FILE="${APP_NAME}.jar"

# 停止旧进程
echo "停止旧进程..."
PID=$(ps -ef | grep ${JAR_FILE} | grep -v grep | awk '{print $2}')
if [ -n "$PID" ]; then
    kill -9 $PID
    echo "已停止进程: $PID"
fi

# 启动新进程（指定test环境）
echo "启动测试环境应用..."
nohup java -jar \
  -Dspring.profiles.active=${ENV} \
  -Xms512m -Xmx1g \
  ${JAR_FILE} > ${APP_NAME}.log 2>&1 &

echo "应用已启动，环境: ${ENV}"
```

### 6.3 生产环境部署


**生产部署检查清单**：
```
部署前检查：
☑️ 确认使用正确的配置文件（prod）
☑️ 验证数据库连接配置正确
☑️ 确认调度中心地址正确
☑️ 检查accessToken配置正确
☑️ 确认日志路径有写权限
☑️ 检查端口没有被占用

敏感信息处理：
☑️ 数据库密码不能明文
☑️ accessToken从环境变量读取
☑️ 配置文件权限设置为600（仅所有者可读写）
```

**生产部署脚本（deploy-prod.sh）**：
```bash
#!/bin/bash

APP_NAME="xxl-job-executor"
JAR_FILE="${APP_NAME}.jar"

# 从环境变量读取敏感配置
export SPRING_PROFILES_ACTIVE=prod
export DB_USERNAME=$(cat /secure/db_user.txt)
export DB_PASSWORD=$(cat /secure/db_pass.txt)
export XXL_JOB_ACCESS_TOKEN=$(cat /secure/xxl_token.txt)

# 灰度发布：先启动一台机器
echo "灰度发布第一台机器..."
ssh prod-server-01 "cd /app && ./start.sh"

# 等待健康检查
sleep 30
if curl -f http://prod-server-01:9997/health; then
    echo "第一台机器启动成功，继续部署其他机器"
    # 部署其他机器...
else
    echo "第一台机器启动失败，停止部署"
    exit 1
fi
```

### 6.4 容器化部署


**Dockerfile多环境支持**：
```dockerfile
FROM openjdk:11-jre-slim

# 接收构建参数
ARG PROFILE=prod
ENV SPRING_PROFILES_ACTIVE=${PROFILE}

WORKDIR /app
COPY target/xxl-job-executor.jar app.jar

# 启动命令
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Docker Compose不同环境配置**：
```yaml
# docker-compose.yml
version: '3.8'
services:
  executor-dev:
    image: xxl-job-executor:latest
    environment:
      - SPRING_PROFILES_ACTIVE=dev
    ports:
      - "9999:9999"
  
  executor-prod:
    image: xxl-job-executor:latest
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_USERNAME=${PROD_DB_USER}
      - DB_PASSWORD=${PROD_DB_PASS}
    ports:
      - "9997:9997"
```

### 6.5 环境切换注意事项


**常见问题及解决方案**：

| 问题 | 原因 | 解决方案 |
|------|------|---------|
| **配置未生效** | `Profile未正确激活` | 检查启动日志中的active profile |
| **连接调度中心失败** | `地址配置错误` | 确认当前环境的admin地址正确 |
| **任务重复执行** | `多环境执行器名称相同` | 每个环境使用不同的appname |
| **日志路径无权限** | `目录不存在或无写权限` | 提前创建目录并赋予权限 |

**切换环境自检步骤**：
```
步骤1：确认Profile激活
查看启动日志：The following profiles are active: prod

步骤2：验证配置加载
检查关键配置是否符合预期环境

步骤3：连通性测试
执行一次简单任务验证调度中心连接

步骤4：功能验证
执行完整业务流程确保功能正常
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 多环境必要性：数据安全、调试效率、配置差异、问题隔离
🔸 环境类型：dev开发、test测试、uat预生产、prod生产
🔸 配置隔离：物理隔离、逻辑隔离、数据隔离、网络隔离
🔸 Profile机制：Spring的环境管理核心，一套代码多环境运行
🔸 敏感信息：密码加密、环境变量、配置中心管理
```

### 7.2 关键理解要点


**🔹 环境配置的本质**
```
不同环境就像不同的"工作场景"：
- 开发环境：自己的实验室，随便折腾
- 测试环境：共享的测试间，谨慎操作
- 生产环境：客户的正式场所，绝对不能出错

通过配置隔离，让一套代码在不同场景下表现不同
```

**🔹 配置文件优先级**
```
记忆要点：
外部配置 > 环境配置 > 公共配置

application.yml                → 所有环境的基础
application-{profile}.yml      → 特定环境覆盖基础配置
环境变量/命令行参数             → 最高优先级，覆盖所有
```

**🔹 Profile激活方式选择**
```
开发阶段：在application.yml中指定active: dev
测试部署：通过启动脚本指定 --spring.profiles.active=test
生产部署：通过环境变量 export SPRING_PROFILES_ACTIVE=prod
容器部署：Dockerfile中通过ENV或docker-compose传入
```

### 7.3 实际应用指导


**新项目环境规划**：
```
步骤1：确定需要哪些环境（一般：dev、test、prod）
步骤2：设计配置文件结构（公共配置+环境配置）
步骤3：整理各环境差异配置（数据库、服务地址等）
步骤4：处理敏感信息（加密或配置中心）
步骤5：编写部署脚本（自动化环境切换）
```

**配置管理最佳实践**：
```
✅ 公共配置放主文件，减少重复
✅ 环境配置只写差异，便于对比
✅ 敏感信息绝不提交代码库
✅ 生产配置单独审核，严格管控
✅ 配置变更记录日志，便于追溯
```

**常见错误避免**：
```
❌ 所有环境用同一个数据库 → 开发误删生产数据
❌ 配置文件提交明文密码 → 泄露敏感信息
❌ 执行器名称各环境相同 → 任务串台执行
❌ 生产环境用DEBUG日志 → 性能下降磁盘爆满
❌ 环境切换不清理缓存 → 旧配置残留导致异常
```

### 7.4 问题排查技巧


**如何确认当前环境**：
```java
// 方法1：查看启动日志
The following profiles are active: prod

// 方法2：代码中获取
@Value("${spring.profiles.active}")
private String env;

// 方法3：执行器名称判断
查看调度中心的执行器列表，appname包含环境标识
```

**配置不生效排查**：
```
检查清单：
1. Profile是否正确激活？
2. 配置文件命名是否正确？（application-{profile}.yml）
3. 配置项是否被外部参数覆盖？
4. 是否需要重启应用？（大部分配置需要重启）
5. 配置文件编码是否正确？（UTF-8）
```

**核心记忆口诀**：
```
多环境配置要分清，开发测试与生产
Profile机制是核心，一套代码多场景
敏感信息要加密，环境变量来传递
切换环境先确认，日志验证最关键
```