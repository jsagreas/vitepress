---
title: 1、负载均衡组件集成
---
## 📚 目录

1. [什么是负载均衡](#1-什么是负载均衡)
2. [Ribbon负载均衡器](#2-Ribbon负载均衡器)
3. [Spring Cloud LoadBalancer](#3-Spring-Cloud-LoadBalancer)
4. [负载均衡算法详解](#4-负载均衡算法详解)
5. [健康检查与重试机制](#5-健康检查与重试机制)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 什么是负载均衡


### 1.1 生活中的负载均衡


**想象一个场景**：
```
银行排队办业务：
窗口1: 👤👤👤👤👤 (5个人排队)
窗口2: 👤👤 (2个人排队)
窗口3: 👤👤👤 (3个人排队)

❌ 不合理：新客户都去窗口1排队
✅ 合理：引导新客户去窗口2（人最少）
```

这就是负载均衡的核心思想：**把请求合理分配到多个服务器，避免某一台太忙，其他的闲着**。

### 1.2 微服务中为什么需要负载均衡


**问题场景**：
```
用户请求 → 订单服务
            ↓
         有3台服务器：
         订单服务A (192.168.1.10:8080)
         订单服务B (192.168.1.11:8080)  
         订单服务C (192.168.1.12:8080)

🤔 问题：请求该发给谁？
```

**负载均衡器的作用**：
- **分散压力**：避免一台服务器被压垮
- **提高可用性**：一台挂了，其他的还能用
- **充分利用资源**：让每台服务器都发挥作用

### 1.3 负载均衡的两种类型


**服务端负载均衡 vs 客户端负载均衡**

```
┌─ 服务端负载均衡 ──────────────┐
│                              │
│ 客户端 → Nginx/F5 → 多个服务  │
│          (负载均衡器)         │
│                              │
│ 特点：集中式管理              │
│ 例子：Nginx反向代理           │
└──────────────────────────────┘

┌─ 客户端负载均衡 ──────────────┐
│                              │
│ 客户端(自带负载均衡) → 多个服务│
│        ↓                     │
│    从注册中心获取服务列表      │
│    自己选择调用哪个            │
│                              │
│ 特点：去中心化                │
│ 例子：Ribbon、LoadBalancer    │
└──────────────────────────────┘
```

**微服务常用客户端负载均衡**，因为：
- 每个服务自己决定调用谁
- 不需要额外的负载均衡设备
- 配合服务注册中心使用非常方便

---

## 2. 🎨 Ribbon负载均衡器


### 2.1 Ribbon是什么


**Ribbon**：Netflix开源的客户端负载均衡工具，现在处于**维护模式**（不再新增功能，但还在用）。

**核心功能**：
```
1. 从Eureka/Nacos获取服务列表
2. 根据算法选择一个服务实例
3. 发起HTTP调用
4. 失败后可以重试其他实例
```

### 2.2 Ribbon快速上手


**第一步：添加依赖**

```xml
<!-- 注意：如果用了spring-cloud-starter-netflix-eureka-client -->
<!-- 已经包含了Ribbon，不需要单独引入 -->

<!-- 单独使用Ribbon的依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

**第二步：配置RestTemplate**

```java
@Configuration
public class LoadBalancerConfig {
    
    // @LoadBalanced 是关键！加了这个注解，RestTemplate就有负载均衡能力了
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

**第三步：使用服务名调用**

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public String getProductInfo(Long productId) {
        // 注意：这里用的是服务名 product-service，不是IP地址！
        // Ribbon会自动从注册中心获取product-service的实例列表
        // 然后选择一个实例发起调用
        String url = "http://product-service/api/product/" + productId;
        return restTemplate.getForObject(url, String.class);
    }
}
```

### 2.3 Ribbon工作流程


```
调用流程图解：

1️⃣ 发起调用
   restTemplate.getForObject("http://product-service/api/product/1")
   
2️⃣ Ribbon拦截请求
   识别到服务名：product-service
   
3️⃣ 从注册中心获取实例列表
   [
     {host: "192.168.1.10", port: 8080},
     {host: "192.168.1.11", port: 8080},
     {host: "192.168.1.12", port: 8080}
   ]
   
4️⃣ 执行负载均衡算法
   根据算法(如轮询)选择一个实例
   
5️⃣ 替换URL并发起调用
   http://192.168.1.10:8080/api/product/1
```

### 2.4 Ribbon配置方式


**方式一：全局配置（所有服务生效）**

```yaml
# application.yml
ribbon:
  # 连接超时时间(毫秒)
  ConnectTimeout: 3000
  # 读取超时时间(毫秒)
  ReadTimeout: 3000
  # 是否对所有操作都重试
  OkToRetryOnAllOperations: false
  # 切换实例的重试次数
  MaxAutoRetriesNextServer: 1
  # 对当前实例的重试次数
  MaxAutoRetries: 1
```

**方式二：针对特定服务配置**

```yaml
# 只对product-service服务生效
product-service:
  ribbon:
    # 负载均衡算法(后面会讲)
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
    # 连接超时
    ConnectTimeout: 5000
    # 读取超时
    ReadTimeout: 5000
```

---

## 3. 🚀 Spring Cloud LoadBalancer


### 3.1 为什么要用LoadBalancer


**Ribbon的问题**：
- Netflix已经不维护了（进入维护模式）
- Spring官方推荐用LoadBalancer替代
- 功能更现代化，与Spring生态集成更好

**LoadBalancer的优势**：
```
✅ Spring官方维护，长期支持
✅ 更轻量级，只保留核心功能
✅ 响应式编程支持(WebFlux)
✅ 更容易自定义扩展
```

### 3.2 LoadBalancer快速上手


**第一步：添加依赖**

```xml
<!-- 排除Ribbon依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!-- 引入LoadBalancer -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

**第二步：配置RestTemplate（和Ribbon一样）**

```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

**第三步：使用方式完全相同**

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public String getProductInfo(Long productId) {
        // 用法和Ribbon完全一样！
        String url = "http://product-service/api/product/" + productId;
        return restTemplate.getForObject(url, String.class);
    }
}
```

### 3.3 LoadBalancer配置


**配置负载均衡算法**

```yaml
spring:
  cloud:
    loadbalancer:
      # 配置为轮询算法
      ribbon:
        enabled: false
      # 健康检查配置
      health-check:
        initial-delay: 0
```

**自定义负载均衡策略**

```java
@Configuration
public class CustomLoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        
        // 使用随机算法
        return new RandomLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

---

## 4. ⚙️ 负载均衡算法详解


### 4.1 常用负载均衡算法对比


| 算法名称 | 原理 | 适用场景 | 优缺点 |
|---------|------|---------|--------|
| **轮询(RoundRobin)** | 依次分配请求 | 服务器性能相近 | ✅简单公平 ❌不考虑实际负载 |
| **随机(Random)** | 随机选择服务器 | 大量请求时 | ✅实现简单 ❌单次可能不均衡 |
| **权重(Weighted)** | 按权重比例分配 | 服务器性能不同 | ✅灵活 ❌配置复杂 |
| **最少连接** | 选连接数最少的 | 长连接场景 | ✅考虑实际负载 ❌需要统计连接数 |
| **响应时间** | 选响应最快的 | 对延迟敏感 | ✅性能最优 ❌计算开销大 |

### 4.2 轮询算法实现


**原理图解**：
```
服务器列表: [A, B, C]
请求顺序:
请求1 → A  (索引0)
请求2 → B  (索引1)
请求3 → C  (索引2)
请求4 → A  (索引0，循环)
请求5 → B  (索引1)
...
```

**Ribbon轮询配置**

```yaml
product-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
```

**LoadBalancer轮询配置（默认就是）**

```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> roundRobinLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        
        return new RoundRobinLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

### 4.3 随机算法实现


**原理图解**：
```
服务器列表: [A, B, C]
请求顺序:
请求1 → B  (随机到索引1)
请求2 → A  (随机到索引0)
请求3 → C  (随机到索引2)
请求4 → B  (随机到索引1)
请求5 → A  (随机到索引0)
...

大量请求后，每个服务器接收的请求数会趋于均衡
```

**Ribbon随机配置**

```yaml
product-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```

**LoadBalancer随机配置**

```java
@Configuration
public class RandomLoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        
        return new RandomLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

### 4.4 权重算法实现


**什么是权重？**

```
想象三台服务器：
服务器A: 8核16G内存  → 权重5 (性能好，多分配请求)
服务器B: 4核8G内存   → 权重3 (性能中等)
服务器C: 2核4G内存   → 权重2 (性能差，少分配请求)

分配比例: A:B:C = 5:3:2
10个请求中，A会接收5个，B接收3个，C接收2个
```

**Ribbon权重配置**

```yaml
product-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule
```

**Nacos权重配置示例**

```yaml
spring:
  cloud:
    nacos:
      discovery:
        # 当前实例的权重(0-1之间，默认1)
        weight: 0.8
```

**自定义权重策略**

```java
@Component
public class NacosWeightedRule extends AbstractLoadBalancerRule {
    
    @Autowired
    private NacosDiscoveryProperties nacosDiscoveryProperties;
    
    @Override
    public Server choose(Object key) {
        // 1. 获取服务实例列表
        List<Server> servers = getLoadBalancer().getReachableServers();
        
        // 2. 根据权重选择
        return chooseByWeight(servers);
    }
    
    private Server chooseByWeight(List<Server> servers) {
        // 简化实现：这里只是示意
        // 实际需要根据Nacos返回的权重信息计算
        double totalWeight = servers.stream()
            .mapToDouble(s -> getWeight(s))
            .sum();
            
        // 生成随机数并选择
        double random = Math.random() * totalWeight;
        // ... 选择逻辑
        return servers.get(0); // 简化返回
    }
}
```

### 4.5 算法选择建议


```
🎯 选择指南：

场景1: 服务器性能相同
推荐：轮询(RoundRobin)
理由：最简单，分配最均衡

场景2: 服务器性能不同
推荐：权重(Weighted)
理由：可以让性能好的多干活

场景3: 对延迟非常敏感
推荐：响应时间(ResponseTime)
理由：自动选择最快的服务器

场景4: 简单场景，不想配置
推荐：随机(Random)
理由：实现简单，效果也不错
```

---

## 5. 🏥 健康检查与重试机制


### 5.1 为什么需要健康检查


**问题场景**：
```
有3台服务器：
A: ✅ 正常运行
B: ❌ 宕机了(但还在服务列表中)
C: ✅ 正常运行

如果负载均衡选中了B：
用户请求 → B服务器 → ❌ 调用失败 → 用户体验差
```

**健康检查的作用**：
- **定期检测**：每隔一段时间检查服务是否健康
- **自动剔除**：发现不健康的服务，从列表中移除
- **自动恢复**：服务恢复后，重新加入列表

### 5.2 Ribbon健康检查配置


**配置方式**

```yaml
ribbon:
  # 开启健康检查
  NFLoadBalancerPingClassName: com.netflix.loadbalancer.PingUrl
  # 检查间隔(秒)
  NFLoadBalancerPingInterval: 30
  # 检查超时(毫秒)
  ReadTimeout: 3000
```

**自定义健康检查**

```java
public class CustomHealthCheck extends AbstractLoadBalancerPing {
    
    @Override
    public boolean isAlive(Server server) {
        // 自定义健康检查逻辑
        try {
            String url = "http://" + server.getHost() + ":" + server.getPort() + "/actuator/health";
            RestTemplate restTemplate = new RestTemplate();
            String result = restTemplate.getForObject(url, String.class);
            return "UP".equals(result);
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 5.3 重试机制配置


**什么是重试？**

```
场景：调用服务失败了怎么办？

不重试：
用户请求 → A服务器(超时) → ❌ 直接返回失败

重试：
用户请求 → A服务器(超时) 
         → 换B服务器重试 → ✅ 成功
         
这就是重试机制！
```

**Ribbon重试配置**

```yaml
ribbon:
  # 是否所有操作都重试(GET之外的操作慎重！)
  OkToRetryOnAllOperations: false
  # 同一个实例重试次数
  MaxAutoRetries: 1
  # 切换实例重试次数
  MaxAutoRetriesNextServer: 2
  # 连接超时
  ConnectTimeout: 3000
  # 读取超时
  ReadTimeout: 3000
```

**重试流程图解**

```
┌─ 重试流程 ────────────────────────┐
│                                   │
│ 1. 请求发送到服务A                 │
│    ↓                              │
│ 2. 服务A超时/失败                  │
│    ↓                              │
│ 3. 检查是否需要重试                │
│    ├─ 不重试 → 返回失败            │
│    └─ 重试 → 继续                 │
│         ↓                         │
│ 4. 选择下一个服务B                 │
│    ↓                              │
│ 5. 请求发送到服务B                 │
│    ├─ 成功 → 返回结果              │
│    └─ 失败 → 继续重试或返回失败     │
│                                   │
└───────────────────────────────────┘
```

**Spring Retry配置**

```xml
<!-- 添加依赖 -->
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
```

```yaml
spring:
  cloud:
    loadbalancer:
      retry:
        enabled: true
        # 同一实例重试次数
        max-retries-on-same-service-instance: 1
        # 切换实例重试次数
        max-retries-on-next-service-instance: 2
```

### 5.4 重试注意事项


**⚠️ 重要提醒**

```
🔴 危险操作不要重试：

❌ 创建订单 (可能重复创建)
❌ 扣款操作 (可能重复扣款)
❌ 发送短信 (可能重复发送)

✅ 安全操作可以重试：

✅ 查询订单 (幂等操作)
✅ 获取商品信息 (只读操作)
✅ 健康检查 (无副作用)
```

**幂等性保证**

```java
@Service
public class OrderService {
    
    // ❌ 不安全的写法
    public void createOrder(Order order) {
        // 如果重试，可能创建多个订单！
        orderRepository.save(order);
    }
    
    // ✅ 安全的写法
    public void createOrder(Order order) {
        // 先检查是否已存在
        if (orderRepository.existsByOrderNo(order.getOrderNo())) {
            return; // 已存在，直接返回
        }
        orderRepository.save(order);
    }
}
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 负载均衡本质：把请求分散到多个服务器，避免单点压力过大
🔸 客户端负载均衡：服务调用方自己决定调用哪个实例
🔸 Ribbon vs LoadBalancer：Ribbon是老工具(维护模式)，LoadBalancer是新选择
🔸 负载均衡算法：轮询、随机、权重，根据场景选择
🔸 健康检查：定期检测服务状态，自动剔除不健康实例
🔸 重试机制：调用失败后自动换实例重试，提高成功率
```

### 6.2 关键理解要点


**负载均衡的价值**
```
没有负载均衡：
用户请求 → 总是调用同一台服务器 → 容易过载

有负载均衡：
用户请求 → 自动分配到多台服务器 → 压力分散 → 系统更稳定
```

**算法选择原则**
```
性能相近 → 轮询(最简单)
性能不同 → 权重(按能力分配)
要求极致 → 响应时间(选最快的)
随便用用 → 随机(也够用)
```

**重试的两面性**
```
✅ 好处：提高成功率，用户体验更好
❌ 风险：可能重复执行，必须保证幂等性
```

### 6.3 实际应用建议


**配置模板（推荐）**

```yaml
# 全局配置
spring:
  cloud:
    # 使用LoadBalancer(新版本推荐)
    loadbalancer:
      ribbon:
        enabled: false
      retry:
        enabled: true

# 针对特定服务的配置
user-service:
  ribbon:
    # 轮询算法
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    # 超时设置
    ConnectTimeout: 3000
    ReadTimeout: 3000
    # 重试配置(只对GET重试)
    OkToRetryOnAllOperations: false
    MaxAutoRetries: 1
    MaxAutoRetriesNextServer: 1
```

### 6.4 学习路径


```
学习进度：
✅ 理解负载均衡概念
✅ 掌握Ribbon/LoadBalancer使用
✅ 了解常用算法
✅ 配置健康检查和重试
▢ 实战：在项目中应用
▢ 进阶：自定义负载均衡策略
```

### 6.5 常见问题答疑


**Q1: Ribbon和LoadBalancer选哪个？**
```
A: 新项目用LoadBalancer，老项目可以继续用Ribbon
原因：LoadBalancer是Spring官方推荐，会长期维护
```

**Q2: 负载均衡算法怎么选？**
```
A: 
- 不确定 → 用默认的轮询
- 服务器性能差异大 → 用权重
- 对延迟敏感 → 用响应时间
```

**Q3: 重试会不会导致重复请求？**
```
A: 会！所以：
- GET请求可以放心重试
- POST/PUT/DELETE要确保接口幂等性
```

**Q4: 健康检查失败了怎么办？**
```
A: 
1. 实例自动从列表移除
2. 不会再接收请求
3. 恢复后会自动加回来
```

**核心记忆口诀**：
- 负载均衡分压力，客户端来做主力
- 算法选择看场景，轮询随机最常见
- 健康检查保质量，重试机制要谨慎
- Ribbon虽老还能用，LoadBalancer更推荐