---
title: 17、命令行基础操作
---
## 📚 目录

1. [命令行客户端入门](#1-命令行客户端入门)
2. [create创建节点](#2-create创建节点)
3. [get读取数据](#3-get读取数据)
4. [set更新数据](#4-set更新数据)
5. [delete删除节点](#5-delete删除节点)
6. [ls查看子节点](#6-ls查看子节点)
7. [stat查看状态](#7-stat查看状态)
8. [实战场景演练](#8-实战场景演练)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 命令行客户端入门


### 1.1 什么是Zookeeper命令行客户端


**通俗理解**：就像我们使用命令行操作MySQL数据库一样，Zookeeper也提供了命令行工具让我们直接和Zookeeper服务器"对话"。

```
类比理解：
MySQL客户端 → 操作数据库
ZK客户端   → 操作分布式协调数据

都是通过命令行交互，发送指令，获取结果
```

### 1.2 启动命令行客户端


**连接本地Zookeeper**：
```bash
# 方式1：连接本地默认端口(2181)
zkCli.sh

# 方式2：指定服务器地址
zkCli.sh -server localhost:2181

# 方式3：连接远程服务器
zkCli.sh -server 192.168.1.100:2181
```

**启动成功标志**：
```
看到这个提示就说明连接成功了：
[zk: localhost:2181(CONNECTED) 0]
         ↑                ↑
      服务器地址        连接状态
```

### 1.3 命令行界面认识


```
交互界面解读：
[zk: localhost:2181(CONNECTED) 0] 
 ↑        ↑            ↑         ↑
提示符  服务器      连接状态    命令序号

输入 help 可以看到所有支持的命令
输入 quit 可以退出客户端
```

---

## 2. 📝 create创建节点


### 2.1 create命令基本用法


**核心理解**：create就是在Zookeeper的"目录树"上创建一个新的节点，可以理解为在文件系统中创建文件或文件夹。

**基础语法**：
```bash
create [选项] 路径 数据
```

### 2.2 创建持久节点


**① 创建最简单的节点**：
```bash
# 创建一个持久节点，存储数据"hello"
[zk: localhost:2181(CONNECTED) 0] create /mynode "hello"
Created /mynode

解释：
/mynode  → 节点路径（类似文件路径）
"hello"  → 存储的数据内容
```

**② 创建多层级节点**：
```bash
# 先创建父节点
[zk: localhost:2181(CONNECTED) 1] create /app "应用根目录"
Created /app

# 再创建子节点
[zk: localhost:2181(CONNECTED) 2] create /app/config "配置信息"
Created /app/config

# 创建孙节点
[zk: localhost:2181(CONNECTED) 3] create /app/config/db "database=mysql"
Created /app/config/db

目录结构：
/
└── app (应用根目录)
    └── config (配置信息)
        └── db (database=mysql)
```

### 2.3 创建临时节点


**什么是临时节点**？
```
持久节点 → 永久保存，除非手动删除
临时节点 → 客户端断开连接就自动删除

实际用途：
- 服务注册（服务下线自动删除）
- 分布式锁（客户端异常自动释放）
- 会话管理（用户登出自动清理）
```

**创建临时节点**：
```bash
# 使用 -e 参数创建临时节点
[zk: localhost:2181(CONNECTED) 4] create -e /temp-node "临时数据"
Created /temp-node

# 临时节点特点：
# 1. 客户端断开连接后自动删除
# 2. 临时节点不能有子节点
# 3. 用于标识客户端的在线状态
```

**验证临时节点**：
```bash
# 查看节点
[zk: localhost:2181(CONNECTED) 5] ls /
[app, mynode, temp-node, zookeeper]

# 退出客户端
[zk: localhost:2181(CONNECTED) 6] quit

# 重新连接后查看
[zk: localhost:2181(CONNECTED) 0] ls /
[app, mynode, zookeeper]  # temp-node已经消失了！
```

### 2.4 创建顺序节点


**什么是顺序节点**？
```
普通节点 → /mynode
顺序节点 → /mynode0000000001

ZK会自动在节点名后面加上递增的序号

用途：
- 分布式队列（按序号处理）
- 公平锁（按创建顺序获取锁）
- 任务调度（顺序执行任务）
```

**创建顺序节点**：
```bash
# 使用 -s 参数创建顺序节点
[zk: localhost:2181(CONNECTED) 0] create -s /task- "任务1"
Created /task-0000000000

[zk: localhost:2181(CONNECTED) 1] create -s /task- "任务2"
Created /task-0000000001

[zk: localhost:2181(CONNECTED) 2] create -s /task- "任务3"
Created /task-0000000002

# 自动编号：0000000000, 0000000001, 0000000002...
# 10位数字，递增不重复
```

**组合使用**：
```bash
# -e -s 组合：创建临时顺序节点
[zk: localhost:2181(CONNECTED) 3] create -e -s /lock- "锁请求"
Created /lock-0000000003

实际应用：
分布式锁排队机制
- 每个客户端创建临时顺序节点
- 序号最小的获得锁
- 释放锁后自动删除节点
- 下一个序号自动获得锁
```

### 2.5 create常见错误处理


**❌ 错误1：父节点不存在**
```bash
[zk: localhost:2181(CONNECTED) 0] create /a/b/c "data"
Node does not exist: /a/b

解决：先创建父节点
[zk: localhost:2181(CONNECTED) 1] create /a "父节点"
[zk: localhost:2181(CONNECTED) 2] create /a/b "子节点"
[zk: localhost:2181(CONNECTED) 3] create /a/b/c "孙节点"
```

**❌ 错误2：节点已存在**
```bash
[zk: localhost:2181(CONNECTED) 0] create /mynode "data1"
Created /mynode

[zk: localhost:2181(CONNECTED) 1] create /mynode "data2"
Node already exists: /mynode

解决：先删除或使用set更新
```

**❌ 错误3：临时节点不能有子节点**
```bash
[zk: localhost:2181(CONNECTED) 0] create -e /temp "临时"
[zk: localhost:2181(CONNECTED) 1] create /temp/child "子节点"
Ephemerals cannot have children: /temp

临时节点特性：
✓ 可以独立存在
✗ 不能包含子节点
✓ 连接断开自动删除
```

---

## 3. 📖 get读取数据


### 3.1 get命令基本用法


**核心理解**：get命令用来查看节点存储的数据内容和详细信息，就像查看文件内容一样。

**基础语法**：
```bash
get [-s] [-w] 路径
```

### 3.2 读取节点数据


**① 基础读取**：
```bash
# 读取节点数据
[zk: localhost:2181(CONNECTED) 0] get /mynode
hello

# 简单明了，返回存储的数据内容
```

**② 查看详细信息**：
```bash
# 使用 -s 参数查看完整状态信息
[zk: localhost:2181(CONNECTED) 1] get -s /mynode
hello                          ← 数据内容
cZxid = 0x100000002           ← 创建时的事务ID
ctime = Mon Jan 15 10:00:00 CST 2025  ← 创建时间
mZxid = 0x100000002           ← 最后修改的事务ID
mtime = Mon Jan 15 10:00:00 CST 2025  ← 最后修改时间
pZxid = 0x100000002           ← 子节点最后修改的事务ID
cversion = 0                   ← 子节点版本号
dataVersion = 0                ← 数据版本号
aclVersion = 0                 ← 权限版本号
ephemeralOwner = 0x0          ← 临时节点所有者会话ID(0表示持久节点)
dataLength = 5                 ← 数据长度(字节)
numChildren = 0                ← 子节点个数
```

**状态信息解读**：
```
📊 关键字段含义：

dataVersion → 数据修改次数
  - 初始为0
  - 每次set修改后+1
  - 用于乐观锁控制

cversion → 子节点变化次数
  - 增加/删除子节点时+1
  - 不包括子节点的数据修改

numChildren → 子节点个数
  - 直接子节点数量
  - 不包括孙节点

ephemeralOwner → 节点类型标识
  - 0x0 = 持久节点
  - 非0 = 临时节点的会话ID
```

### 3.3 监听节点变化


**什么是Watch监听**？
```
监听机制(Watch)：
- 对节点设置"监听器"
- 节点数据变化时收到通知
- 一次性触发，触发后自动失效

应用场景：
- 配置中心（配置变更通知）
- 服务发现（服务上下线通知）
- 分布式锁（锁释放通知）
```

**设置Watch监听**：
```bash
# 使用 -w 参数设置监听
[zk: localhost:2181(CONNECTED) 0] get -w /mynode
hello

# 此时在另一个客户端修改数据
[zk: localhost:2181(CONNECTED) 0] set /mynode "world"

# 第一个客户端会收到通知：
WATCHER::
WatchedEvent state:SyncConnected type:NodeDataChanged path:/mynode
         ↑                           ↑                    ↑
      连接状态                    事件类型              节点路径

事件类型说明：
NodeDataChanged    → 数据内容变化
NodeChildrenChanged → 子节点变化
NodeDeleted        → 节点被删除
```

**Watch特性演示**：
```bash
# 第一次监听
[zk: localhost:2181(CONNECTED) 0] get -w /mynode
hello

# 第一次修改 - 收到通知
[zk: localhost:2181(CONNECTED) 1] set /mynode "data1"
WATCHER:: WatchedEvent ... NodeDataChanged ... ✓

# 第二次修改 - 不会收到通知（监听已失效）
[zk: localhost:2181(CONNECTED) 2] set /mynode "data2"
(没有通知) ✗

# 需要重新设置监听
[zk: localhost:2181(CONNECTED) 3] get -w /mynode
data2
```

### 3.4 读取不同类型节点


**① 读取空数据节点**：
```bash
[zk: localhost:2181(CONNECTED) 0] create /empty ""
[zk: localhost:2181(CONNECTED) 1] get /empty
(空白输出)

用途：
- 仅用作目录结构
- 标识存在性
- 临时节点做服务注册
```

**② 读取包含特殊字符的数据**：
```bash
# JSON格式数据
[zk: localhost:2181(CONNECTED) 0] create /config '{"db":"mysql","port":3306}'
[zk: localhost:2181(CONNECTED) 1] get /config
{"db":"mysql","port":3306}

# 多行数据
[zk: localhost:2181(CONNECTED) 2] create /readme "第一行\n第二行\n第三行"
[zk: localhost:2181(CONNECTED) 3] get /readme
第一行
第二行
第三行
```

**③ 读取二进制数据**：
```bash
# ZK可以存储任意字节数据
# 但命令行显示可能乱码

实际应用：
- 序列化对象
- 加密数据
- 压缩数据
建议：通过程序API操作，而非命令行
```

---

## 4. ✏️ set更新数据


### 4.1 set命令基本用法


**核心理解**：set命令用来修改节点的数据内容，类似于文件内容的修改。

**基础语法**：
```bash
set [-v 版本号] 路径 数据
```

### 4.2 基础更新操作


**① 简单更新**：
```bash
# 创建节点
[zk: localhost:2181(CONNECTED) 0] create /counter "0"
Created /counter

# 更新数据
[zk: localhost:2181(CONNECTED) 1] set /counter "1"
[zk: localhost:2181(CONNECTED) 2] set /counter "2"
[zk: localhost:2181(CONNECTED) 3] set /counter "3"

# 查看当前值
[zk: localhost:2181(CONNECTED) 4] get /counter
3
```

**② 更新不同类型数据**：
```bash
# 更新配置信息
[zk: localhost:2181(CONNECTED) 0] set /config "timeout=30"

# 更新JSON数据
[zk: localhost:2181(CONNECTED) 1] set /app-config '{"version":"1.0.1"}'

# 清空数据（设为空字符串）
[zk: localhost:2181(CONNECTED) 2] set /temp ""
```

### 4.3 版本控制机制


**什么是版本号**？
```
Zookeeper的乐观锁机制：
- 每个节点有dataVersion版本号
- 初始版本为0
- 每次修改后版本号+1

类比Git的版本控制：
Git: commit → 版本号递增
ZK:  set   → dataVersion递增
```

**版本号查看**：
```bash
[zk: localhost:2181(CONNECTED) 0] get -s /counter
3
...
dataVersion = 3    ← 当前版本号
...

修改历史：
版本0 → 创建时的"0"
版本1 → 更新为"1"
版本2 → 更新为"2"  
版本3 → 更新为"3"（当前）
```

**基于版本号的安全更新**：
```bash
# 场景：多个客户端同时修改同一节点

# 客户端A读取数据（版本3）
[zk: A(CONNECTED) 0] get -s /counter
3
dataVersion = 3

# 客户端B也读取数据（版本3）
[zk: B(CONNECTED) 0] get -s /counter
3
dataVersion = 3

# 客户端A基于版本3更新（成功）
[zk: A(CONNECTED) 1] set -v 3 /counter "10"
✓ 成功，版本变为4

# 客户端B也基于版本3更新（失败）
[zk: B(CONNECTED) 1] set -v 3 /counter "20"
✗ version No is not valid : /counter
  （版本号已经是4了，不再是3）

这就是乐观锁：
- 基于版本号判断是否被修改过
- 避免脏数据覆盖
- 类似数据库的CAS操作
```

**不带版本号的风险**：
```bash
# 不指定版本号：总是成功，可能覆盖别人的修改

客户端A: set /counter "10"  ✓ 成功
客户端B: set /counter "20"  ✓ 成功（A的修改丢失！）

建议：
- 并发场景：使用 -v 指定版本号
- 单一操作：可以省略版本号
```

### 4.4 set操作实战案例


**案例1：配置热更新**
```bash
# 应用启动时读取配置
[zk: localhost:2181(CONNECTED) 0] get -w /app/timeout
30

# 运维人员更新配置
[zk: localhost:2181(CONNECTED) 0] set /app/timeout "60"

# 应用收到变更通知
WATCHER:: NodeDataChanged /app/timeout
# 应用重新加载配置，无需重启

实现流程：
① 应用启动时get -w读取配置
② 运维人员set修改配置
③ 应用收到watch通知
④ 应用重新get读取新配置
⑤ 应用使用新配置，无缝切换
```

**案例2：分布式计数器**
```bash
# 初始化计数器
[zk: localhost:2181(CONNECTED) 0] create /visit-count "0"

# 原子递增（带版本控制）
while true; do
  # 读取当前值和版本
  value=$(get -s /visit-count | head -1)
  version=$(get -s /visit-count | grep dataVersion | cut -d'=' -f2)
  
  # 计算新值
  new_value=$((value + 1))
  
  # 尝试更新（失败则重试）
  set -v $version /visit-count "$new_value" && break
done

保证：
- 并发安全
- 不会丢失计数
- 自动重试
```

---

## 5. 🗑️ delete删除节点


### 5.1 delete命令基本用法


**核心理解**：delete命令用来删除节点，但有一些限制条件需要注意。

**基础语法**：
```bash
delete [-v 版本号] 路径
deleteall 路径   # 递归删除（包括子节点）
```

### 5.2 基础删除操作


**① 删除叶子节点**：
```bash
# 创建节点
[zk: localhost:2181(CONNECTED) 0] create /test "测试数据"

# 删除节点
[zk: localhost:2181(CONNECTED) 1] delete /test

# 验证删除
[zk: localhost:2181(CONNECTED) 2] get /test
Node does not exist: /test  ✓ 删除成功
```

**② 删除临时节点**：
```bash
# 创建临时节点
[zk: localhost:2181(CONNECTED) 0] create -e /temp-data "临时"

# 手动删除
[zk: localhost:2181(CONNECTED) 1] delete /temp-data

# 或者断开连接自动删除
[zk: localhost:2181(CONNECTED) 2] quit
# 重新连接后节点已消失
```

### 5.3 删除限制与错误处理


**❌ 限制1：不能删除有子节点的节点**
```bash
# 创建父子节点
[zk: localhost:2181(CONNECTED) 0] create /parent "父"
[zk: localhost:2181(CONNECTED) 1] create /parent/child "子"

# 尝试删除父节点
[zk: localhost:2181(CONNECTED) 2] delete /parent
Node not empty: /parent  ✗ 失败

解决方案：
方案1：先删除子节点
[zk: localhost:2181(CONNECTED) 3] delete /parent/child
[zk: localhost:2181(CONNECTED) 4] delete /parent  ✓

方案2：使用递归删除
[zk: localhost:2181(CONNECTED) 3] deleteall /parent  ✓
```

**❌ 限制2：节点不存在**
```bash
[zk: localhost:2181(CONNECTED) 0] delete /notexist
Node does not exist: /notexist

实际应用：
- 删除前先判断是否存在
- 或者忽略此错误
```

### 5.4 带版本号的安全删除


**版本控制删除**：
```bash
# 场景：防止误删除被修改过的节点

# 客户端A读取节点（版本2）
[zk: A(CONNECTED) 0] get -s /data
hello
dataVersion = 2

# 客户端B修改了节点（版本变为3）
[zk: B(CONNECTED) 0] set /data "world"

# 客户端A尝试基于版本2删除（失败）
[zk: A(CONNECTED) 1] delete -v 2 /data
version No is not valid : /data
✗ 版本号已变，删除失败，避免误删

安全机制：
- 类似CAS操作
- 确保删除的是"预期"的节点
- 避免ABA问题
```

### 5.5 递归删除详解


**deleteall命令**：
```bash
# 创建多层级结构
[zk: localhost:2181(CONNECTED) 0] create /app "应用"
[zk: localhost:2181(CONNECTED) 1] create /app/config "配置"
[zk: localhost:2181(CONNECTED) 2] create /app/config/db "数据库"
[zk: localhost:2181(CONNECTED) 3] create /app/logs "日志"

结构：
/app
├── config
│   └── db
└── logs

# 一次性删除所有
[zk: localhost:2181(CONNECTED) 4] deleteall /app
✓ /app 及其所有子孙节点全部删除

等价于：
delete /app/config/db
delete /app/config
delete /app/logs
delete /app
```

**deleteall使用场景**：
```bash
场景1：清理测试数据
deleteall /test-env

场景2：服务下线清理
deleteall /services/order-service

场景3：配置回滚
deleteall /config/v2
# 然后重新创建

⚠️ 注意：
- 无法撤销，谨慎使用
- 建议先备份重要数据
- 生产环境要有操作审批
```

---

## 6. 📁 ls查看子节点


### 6.1 ls命令基本用法


**核心理解**：ls命令用来查看节点的子节点列表，类似Linux的ls命令查看目录内容。

**基础语法**：
```bash
ls [-s] [-w] [-R] 路径
```

### 6.2 基础查看操作


**① 查看直接子节点**：
```bash
# 查看根节点下的子节点
[zk: localhost:2181(CONNECTED) 0] ls /
[app, mynode, zookeeper]

# 查看指定节点的子节点
[zk: localhost:2181(CONNECTED) 1] ls /app
[config, logs, services]

# 查看空节点（无子节点）
[zk: localhost:2181(CONNECTED) 2] ls /mynode
[]
```

**② 查看详细状态信息**：
```bash
# 使用 -s 参数
[zk: localhost:2181(CONNECTED) 0] ls -s /app
[config, logs, services]    ← 子节点列表
cZxid = 0x100000003
ctime = Mon Jan 15 10:00:00 CST 2025
...
numChildren = 3              ← 子节点数量

同时显示：
- 子节点列表
- 节点状态信息
```

### 6.3 监听子节点变化


**设置子节点监听**：
```bash
# 使用 -w 参数
[zk: localhost:2181(CONNECTED) 0] ls -w /services
[order-service, user-service]

# 在另一个客户端添加服务
[zk: localhost:2181(CONNECTED) 0] create /services/payment-service "支付服务"

# 第一个客户端收到通知
WATCHER::
WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/services
                                       ↑
                                 子节点变化事件

应用场景：
服务发现：
- 监听 /services 节点
- 新服务注册时收到通知
- 自动发现新服务
- 动态更新服务列表
```

**子节点监听特性**：
```bash
# 监听的是子节点的增删，不包括：
✓ 子节点增加 → 触发通知
✓ 子节点删除 → 触发通知
✗ 子节点数据修改 → 不触发通知
✗ 孙节点变化 → 不触发通知

示例验证：
[zk: localhost:2181(CONNECTED) 0] ls -w /app
[config]

# 修改子节点数据 - 不触发
[zk: localhost:2181(CONNECTED) 1] set /app/config "new-data"
(无通知)

# 添加子节点 - 触发
[zk: localhost:2181(CONNECTED) 2] create /app/logs "日志"
WATCHER:: NodeChildrenChanged ✓
```

### 6.4 递归查看子节点


**递归列出所有后代节点**：
```bash
# 使用 -R 参数（注意大写）
[zk: localhost:2181(CONNECTED) 0] ls -R /app
/app
/app/config
/app/config/db
/app/config/redis
/app/logs
/app/logs/access
/app/logs/error

树形展示：
/app
├── config
│   ├── db
│   └── redis
└── logs
    ├── access
    └── error

用途：
- 查看完整目录结构
- 快速了解节点组织
- 检查节点层级关系
```

**递归查看的性能考虑**：
```bash
⚠️ 注意事项：
- 子节点多时输出量大
- 会递归查询所有层级
- 建议：先查看层级，再决定是否递归

# 推荐做法：
[zk: localhost:2181(CONNECTED) 0] ls /        # 先看第一层
[zk: localhost:2181(CONNECTED) 1] ls /app     # 再看第二层
[zk: localhost:2181(CONNECTED) 2] ls -R /app  # 确认后递归
```

### 6.5 ls实战应用


**案例1：服务发现**
```bash
# 服务注册目录
[zk: localhost:2181(CONNECTED) 0] ls -w /services
[order-service-001, user-service-001]

# 监听服务变化
# 当新服务注册时：
[zk: localhost:2181(CONNECTED) 0] create -e /services/payment-service-001 "..."
# 所有监听者收到通知，更新服务列表

实现流程：
① 服务启动时创建临时节点 /services/服务名-实例ID
② 客户端 ls -w /services 监听服务列表
③ 服务上线/下线触发通知
④ 客户端更新本地服务列表
⑤ 重新设置监听，持续监控
```

**案例2：配置管理**
```bash
# 查看配置结构
[zk: localhost:2181(CONNECTED) 0] ls -R /config
/config
/config/database
/config/database/master
/config/database/slave
/config/cache
/config/cache/redis
/config/mq

# 层次化配置管理：
- 按模块分类
- 按环境隔离
- 便于权限控制
```

---

## 7. 📊 stat查看状态


### 7.1 stat命令基本用法


**核心理解**：stat命令专门用来查看节点的详细状态信息，不包含数据内容。

**基础语法**：
```bash
stat [-w] 路径
```

### 7.2 状态信息详解


**完整状态信息**：
```bash
[zk: localhost:2181(CONNECTED) 0] stat /mynode
cZxid = 0x100000002
ctime = Mon Jan 15 10:00:00 CST 2025
mZxid = 0x100000005
mtime = Mon Jan 15 10:15:30 CST 2025
pZxid = 0x100000002
cversion = 0
dataVersion = 3
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 10
numChildren = 0
```

**字段含义完整解释**：
```
📌 事务ID相关（Zxid = Zookeeper Transaction ID）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
cZxid         创建节点时的事务ID
              - 节点创建那一刻的全局唯一ID
              - 单调递增，永不重复

mZxid         最后一次修改数据的事务ID
              - 每次set操作都会更新
              - 可以判断数据是否被修改

pZxid         最后一次修改子节点的事务ID
              - 增加/删除子节点时更新
              - 修改子节点数据不影响此值

📌 时间戳相关
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ctime         创建时间
              - 节点创建的时间戳
              - 永不改变

mtime         最后修改时间
              - 最后一次set操作的时间
              - 可以判断数据新鲜度

📌 版本号相关
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
dataVersion   数据版本号
              - 初始为0
              - 每次set后+1
              - 用于乐观锁控制

cversion      子节点版本号
              - 初始为0  
              - 增加/删除子节点后+1
              - 子节点数据修改不影响

aclVersion    权限版本号
              - 初始为0
              - 修改ACL权限后+1
              - 一般很少使用

📌 其他信息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ephemeralOwner 临时节点所有者会话ID
              - 0x0 = 持久节点
              - 非0 = 创建该临时节点的会话ID

dataLength    数据长度（字节）
              - 存储数据的字节数
              - 默认最大1MB

numChildren   直接子节点个数
              - 不包括孙节点
              - 实时统计
```

### 7.3 stat vs get区别


**命令对比**：
```bash
# get：数据 + 状态
[zk: localhost:2181(CONNECTED) 0] get -s /mynode
hello world        ← 数据内容
cZxid = 0x100000002
...

# stat：仅状态
[zk: localhost:2181(CONNECTED) 1] stat /mynode
cZxid = 0x100000002  ← 只有状态信息
...

使用场景：
get -s  → 需要数据和状态
stat    → 只需要状态信息（效率更高）
        → 数据量大时，stat更快
```

### 7.4 stat监听状态变化


**监听节点状态**：
```bash
# 设置监听
[zk: localhost:2181(CONNECTED) 0] stat -w /mynode
cZxid = 0x100000002
dataVersion = 0
...

# 修改数据（触发监听）
[zk: localhost:2181(CONNECTED) 0] set /mynode "new-data"

# 收到通知
WATCHER::
WatchedEvent state:SyncConnected type:NodeDataChanged path:/mynode

监听特点：
- 一次性触发
- 数据变化、删除都会触发
- 子节点变化不触发
```

### 7.5 stat实战应用


**案例1：版本冲突检测**
```bash
# 读取当前版本
[zk: localhost:2181(CONNECTED) 0] stat /counter
dataVersion = 5

# 基于版本更新
[zk: localhost:2181(CONNECTED) 1] set -v 5 /counter "new-value"

# 如果版本号不匹配
version No is not valid : /counter
# 说明数据被其他客户端修改了

应用：
- 分布式锁
- 配置管理
- 计数器
```

**案例2：数据新鲜度判断**
```bash
# 检查数据更新时间
[zk: localhost:2181(CONNECTED) 0] stat /cache-data
mtime = Mon Jan 15 09:00:00 CST 2025

# 当前时间：10:00
# mtime是1小时前
# 判断缓存过期，需要刷新

实现缓存过期策略：
① 写入时记录mtime
② 读取时检查mtime
③ 超过TTL则刷新
④ 否则使用缓存数据
```

**案例3：节点类型识别**
```bash
# 检查是否为临时节点
[zk: localhost:2181(CONNECTED) 0] stat /node
ephemeralOwner = 0x0     → 持久节点

[zk: localhost:2181(CONNECTED) 1] stat /temp
ephemeralOwner = 0x10000abc123  → 临时节点

应用：
- 服务注册表（临时节点）
- 配置存储（持久节点）
- 根据类型决定处理逻辑
```

---

## 8. 🎯 实战场景演练


### 8.1 场景1：配置中心实现


**需求**：实现应用配置的动态更新

```bash
# ① 初始化配置结构
[zk: localhost:2181(CONNECTED) 0] create /config "配置根目录"
[zk: localhost:2181(CONNECTED) 1] create /config/app "应用配置"
[zk: localhost:2181(CONNECTED) 2] create /config/app/db-url "jdbc:mysql://localhost:3306/test"
[zk: localhost:2181(CONNECTED) 3] create /config/app/timeout "30"

# ② 应用启动时读取配置并监听
[zk: localhost:2181(CONNECTED) 4] get -w /config/app/timeout
30

# ③ 运维人员更新配置
[zk: localhost:2181(CONNECTED) 5] set /config/app/timeout "60"

# ④ 应用收到通知，重新加载
WATCHER:: NodeDataChanged /config/app/timeout
[zk: localhost:2181(CONNECTED) 6] get -w /config/app/timeout
60

完整流程：
┌─────────┐    get -w    ┌──────────┐
│  应用   │─────────────→│ Zookeeper│
│         │←─────────────│          │
└─────────┘   返回配置    └──────────┘
     ↓                           ↓
  使用配置                  运维set更新
     ↓                           ↓
  收到通知 ←─────────────────  触发watch
     ↓
  重新读取
     ↓
  应用新配置
```

### 8.2 场景2：服务注册与发现


**需求**：微服务自动注册和发现

```bash
# ① 创建服务注册根目录
[zk: localhost:2181(CONNECTED) 0] create /services "服务注册中心"

# ② 服务A启动，注册自己（临时顺序节点）
[zk: localhost:2181(CONNECTED) 1] create -e -s /services/order-service- "192.168.1.10:8080"
Created /services/order-service-0000000001

# ③ 服务B启动，注册自己
[zk: localhost:2181(CONNECTED) 2] create -e -s /services/order-service- "192.168.1.11:8080"
Created /services/order-service-0000000002

# ④ 客户端发现服务列表并监听
[zk: localhost:2181(CONNECTED) 3] ls -w /services
[order-service-0000000001, order-service-0000000002]

# ⑤ 获取服务详细信息
[zk: localhost:2181(CONNECTED) 4] get /services/order-service-0000000001
192.168.1.10:8080

# ⑥ 服务A下线（连接断开，临时节点自动删除）
# quit

# ⑦ 客户端收到通知，更新服务列表
WATCHER:: NodeChildrenChanged /services
[zk: localhost:2181(CONNECTED) 5] ls -w /services
[order-service-0000000002]  # 服务A已消失

服务发现流程：
┌──────┐ create -e -s  ┌──────────┐
│服务实例│──────────────→│Zookeeper │
└──────┘               └──────────┘
                              ↓
                        /services/
                        ├─ svc-001 (实例1)
                        └─ svc-002 (实例2)
                              ↓
┌──────┐    ls -w       ┌──────────┐
│客户端 │←──────────────│Zookeeper │
└──────┘   获取服务列表  └──────────┘
```

### 8.3 场景3：分布式锁


**需求**：多个进程竞争同一资源

```bash
# ① 创建锁根目录
[zk: localhost:2181(CONNECTED) 0] create /locks "锁目录"

# ② 客户端A尝试获取锁（创建临时顺序节点）
[zk: A(CONNECTED) 0] create -e -s /locks/lock- "clientA"
Created /locks/lock-0000000001

# ③ 客户端B尝试获取锁
[zk: B(CONNECTED) 0] create -e -s /locks/lock- "clientB"
Created /locks/lock-0000000002

# ④ 检查是否获得锁（序号最小的获得锁）
[zk: A(CONNECTED) 1] ls /locks
[lock-0000000001, lock-0000000002]
# 客户端A：我的序号最小，获得锁 ✓

[zk: B(CONNECTED) 1] ls /locks
[lock-0000000001, lock-0000000002]
# 客户端B：序号不是最小，等待 ✗

# ⑤ 客户端B监听前一个节点
[zk: B(CONNECTED) 2] stat -w /locks/lock-0000000001

# ⑥ 客户端A释放锁（删除节点）
[zk: A(CONNECTED) 2] delete /locks/lock-0000000001

# ⑦ 客户端B收到通知，检查并获得锁
WATCHER:: NodeDeleted /locks/lock-0000000001
[zk: B(CONNECTED) 3] ls /locks
[lock-0000000002]  # 现在我是最小的，获得锁 ✓

分布式锁流程：
客户端       操作                     Zookeeper
  │                                      │
  │─── create -e -s /locks/lock- ───────→│
  │←──── 返回 lock-0000000001 ────────────│
  │                                      │
  │─── ls /locks ────────────────────────→│
  │←──── 返回所有节点 ─────────────────────│
  │                                      │
  ├─ 判断：序号最小？                      │
  │    是 → 获得锁                        │
  │    否 → 监听前一个节点 ─────────────────→│
  │                                      │
  │← 前一个节点删除通知 ─────────────────────│
  │                                      │
  ├─ 重新判断序号                          │
  └─ 获得锁                                │
```

### 8.4 场景4：主节点选举


**需求**：集群中选举一个Leader

```bash
# ① 创建选举目录
[zk: localhost:2181(CONNECTED) 0] create /election "选举目录"

# ② 节点1参与选举
[zk: node1(CONNECTED) 0] create -e -s /election/node- "node1-info"
Created /election/node-0000000001

# ③ 节点2参与选举
[zk: node2(CONNECTED) 0] create -e -s /election/node- "node2-info"
Created /election/node-0000000002

# ④ 节点3参与选举
[zk: node3(CONNECTED) 0] create -e -s /election/node- "node3-info"
Created /election/node-0000000003

# ⑤ 各节点检查自己是否为Leader
[zk: node1(CONNECTED) 1] ls /election
[node-0000000001, node-0000000002, node-0000000003]
# node1：我是最小的，我是Leader ✓

[zk: node2(CONNECTED) 1] ls /election
# node2：我不是最小的，我是Follower
# 监听 node-0000000001

[zk: node3(CONNECTED) 1] ls /election
# node3：我不是最小的，我是Follower
# 监听 node-0000000002

# ⑥ Leader宕机（node1断开连接）
# quit

# ⑦ node2收到通知，成为新Leader
WATCHER:: NodeDeleted /election/node-0000000001
[zk: node2(CONNECTED) 2] ls /election
[node-0000000002, node-0000000003]
# node2：现在我是最小的，我是新Leader ✓

Leader选举流程：
初始状态：
/election
├── node-0000000001 (Leader) ← node1
├── node-0000000002 (Follower) ← node2 (监听node1)
└── node-0000000003 (Follower) ← node3 (监听node2)

node1宕机后：
/election
├── node-0000000002 (Leader) ← node2 (晋升)
└── node-0000000003 (Follower) ← node3 (监听node2)
```

---

## 9. 📋 核心要点总结


### 9.1 命令速查表


| 命令 | 作用 | 常用参数 | 典型用法 |
|------|------|----------|----------|
| **create** | 创建节点 | `-e` 临时<br>`-s` 顺序 | `create -e -s /lock- "data"` |
| **get** | 读取数据 | `-s` 状态<br>`-w` 监听 | `get -s -w /config` |
| **set** | 更新数据 | `-v` 版本号 | `set -v 3 /counter "10"` |
| **delete** | 删除节点 | `-v` 版本号 | `delete -v 2 /temp` |
| **deleteall** | 递归删除 | 无 | `deleteall /app` |
| **ls** | 查看子节点 | `-s` 状态<br>`-w` 监听<br>`-R` 递归 | `ls -w /services` |
| **stat** | 查看状态 | `-w` 监听 | `stat -w /mynode` |

### 9.2 节点类型特性


```
节点类型矩阵：

┌──────────┬──────────┬──────────────┬────────────────┐
│ 节点类型  │ 创建方式  │ 生命周期      │ 典型应用        │
├──────────┼──────────┼──────────────┼────────────────┤
│ 持久节点  │ create   │ 永久保存      │ 配置存储        │
│          │          │ 手动删除      │ 目录结构        │
├──────────┼──────────┼──────────────┼────────────────┤
│ 临时节点  │ create -e│ 会话结束自动  │ 服务注册        │
│          │          │ 删除          │ 会话管理        │
├──────────┼──────────┼──────────────┼────────────────┤
│ 持久顺序  │ create -s│ 永久保存      │ 分布式队列      │
│          │          │ 自动编号      │ 顺序处理        │
├──────────┼──────────┼──────────────┼────────────────┤
│临时顺序   │create-e-s│ 会话结束删除  │ 分布式锁        │
│          │          │ 自动编号      │ Leader选举     │
└──────────┴──────────┴──────────────┴────────────────┘
```

### 9.3 Watch监听机制


```
监听类型与触发事件：

命令          监听内容           触发事件
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
get -w      节点数据变化       NodeDataChanged
                              NodeDeleted

ls -w       子节点增删         NodeChildrenChanged

stat -w     节点状态变化       NodeDataChanged
                              NodeDeleted

⚠️ 监听特性：
✓ 一次性触发（触发后失效）
✓ 需要重新设置监听
✓ 事件顺序保证
✗ 可能丢失中间状态
```

### 9.4 版本控制使用


```
版本号应用场景：

场景              是否使用版本号        原因
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
单一修改操作      不需要               无并发冲突
并发修改          需要 -v              防止覆盖
删除保护          需要 -v              防止误删
分布式锁          需要检查版本          确保原子性
计数器            需要版本控制          保证准确性

版本控制流程：
① 读取数据 + 版本号
② 本地处理
③ 基于版本号更新
④ 失败则重试
```

### 9.5 最佳实践建议


**🎯 命令使用建议**

```
① 节点命名规范：
✓ 使用有意义的名称：/services/order-service
✓ 层级清晰：/app/env/module/config
✓ 避免特殊字符：不用空格、中文等
✗ 避免过深层级：不超过5层

② 数据存储规范：
✓ 配置：JSON格式便于解析
✓ 服务信息：IP:Port格式
✓ 小数据量：ZK不适合大数据
✗ 避免存储：超过1MB的数据

③ 监听使用规范：
✓ 及时重新设置监听
✓ 处理监听失败情况
✓ 避免监听风暴
✗ 不要频繁设置/取消监听

④ 删除操作规范：
✓ 删除前先检查子节点
✓ 重要数据删除前备份
✓ 使用版本号保护
✗ 生产环境谨慎使用deleteall
```

**⚠️ 常见错误避免**

```
错误1：忘记重新设置Watch
问题：监听触发一次后失效
解决：收到通知后立即重新设置

错误2：不使用版本号导致覆盖
问题：并发修改时数据丢失
解决：使用 -v 参数进行版本控制

错误3：临时节点做持久化存储
问题：客户端断开数据丢失
解决：配置等持久数据用持久节点

错误4：直接删除有子节点的节点
问题：删除失败
解决：先删子节点或用deleteall

错误5：频繁创建删除节点
问题：性能下降，序号消耗快
解决：复用节点，使用set更新
```

**🔧 调试技巧**

```bash
# 技巧1：查看完整节点树
ls -R /

# 技巧2：监控节点变化
stat -w /target
get -w /target  
ls -w /target

# 技巧3：快速清理测试数据
deleteall /test

# 技巧4：检查节点类型
stat /node | grep ephemeralOwner
# 0x0 = 持久节点
# 非0 = 临时节点

# 技巧5：查看历史版本号
get -s /node | grep dataVersion
```

**💡 核心记忆口诀**

```
命令行操作记心间：
create建节点，临时加-e，顺序加-s
get读数据，状态-s看，监听-w盯
set改数据，版本-v控，安全有保障
delete删节点，子节点先删，递归用deleteall
ls看子节点，递归-R用，监听-w设
stat查状态，详细信息全，监听-w配

节点类型要分清：
持久永久存，临时会话删
顺序自动编，组合灵活用

版本控制要记牢：
并发用版本，冲突可避免
乐观锁机制，CAS来实现

监听机制要理解：
一次性触发，用完要重设
事件分三类，数据子节点状态
```

---

**🎓 学习建议**

1. **动手实践**：每个命令都亲自试一遍
2. **对比理解**：对照示例理解输出结果
3. **场景演练**：模拟实际业务场景操作
4. **错误体验**：故意制造错误，理解限制
5. **组合使用**：多个命令配合完成复杂任务

**📚 进阶方向**

- Java/Python客户端API使用
- 监听器高级应用
- ACL权限控制
- 集群管理命令
- 性能调优技巧