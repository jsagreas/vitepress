---
title: 13、集群模式部署
---
## 📚 目录

1. [集群模式基础概念](#1-集群模式基础概念)
2. [集群规划与准备](#2-集群规划与准备)
3. [配置文件详解](#3-配置文件详解)
4. [集群启动与验证](#4-集群启动与验证)
5. [Leader选举机制](#5-Leader选举机制)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🌐 集群模式基础概念


### 1.1 为什么需要集群模式


**单机模式的问题**
```
想象一下，如果你的公司只有一个财务人员：
• 这个人请假了，整个公司财务就瘫痪了
• 这个人工作量大了，处理速度就变慢
• 这个人离职了，所有数据可能丢失

Zookeeper单机模式也是同样的问题：
• 服务器宕机 → 整个系统不可用
• 请求量大 → 性能下降
• 数据丢失 → 无法恢复
```

**集群模式的优势**
- **高可用性**：一台服务器挂了，其他服务器继续工作
- **负载均衡**：多台服务器分担请求压力
- **数据安全**：数据在多台机器上都有备份

> **💡 核心理解**：集群就是把多台服务器组成一个"团队"，大家互相配合，一起完成工作，而不是一个人单打独斗。

### 1.2 集群的基本概念


**集群角色划分**
```
Zookeeper集群中有三种角色：

Leader（领导者）
   ↓
   • 负责处理写请求（修改数据）
   • 负责协调其他节点
   • 类似团队的项目经理

Follower（追随者）
   ↓
   • 处理读请求（查询数据）
   • 参与Leader选举投票
   • 类似团队的普通成员

Observer（观察者）
   ↓
   • 只处理读请求
   • 不参与投票
   • 类似实习生，帮忙干活但没决策权
```

**工作流程示意**
```
客户端请求流程：

读请求：                写请求：
客户端                  客户端
  ↓                      ↓
Follower              Follower
  ↓                      ↓
返回数据              转发给Leader
                         ↓
                      Leader处理
                         ↓
                      同步到Follower
                         ↓
                      返回客户端
```

---

## 2. 📋 集群规划与准备


### 2.1 节点数量规划


**节点数量的选择原则**

| 节点数量 | 容错能力 | 适用场景 | 说明 |
|---------|---------|---------|------|
| **3台** | 允许1台宕机 | 小型项目、开发环境 | 最小的生产集群配置 |
| **5台** | 允许2台宕机 | 中型项目、生产环境 | 推荐的生产环境配置 |
| **7台** | 允许3台宕机 | 大型项目、核心系统 | 高可用要求场景 |

> **⚠️ 重要原则**：节点数量必须是**奇数**（3、5、7...），原因后面选举机制会详细讲解。

**为什么是奇数？**
```
简单理解：投票需要"过半数"才能通过

3台集群：需要2票通过（2 > 3/2）
- 挂1台：剩2台，还能选出Leader ✅
- 挂2台：剩1台，无法过半，集群失效 ❌

4台集群：需要3票通过（3 > 4/2）
- 挂1台：剩3台，还能选出Leader ✅
- 挂2台：剩2台，无法过半，集群失效 ❌

对比发现：3台和4台容错能力一样，但4台浪费了一台机器！
所以用奇数更经济实惠。
```

### 2.2 硬件与网络规划


**服务器配置建议**
```
开发/测试环境：
• CPU：2核
• 内存：2GB
• 磁盘：20GB

生产环境：
• CPU：4核以上
• 内存：8GB以上
• 磁盘：100GB以上（SSD更佳）
```

**网络规划**
```
示例：3台服务器集群

服务器1：192.168.1.101
服务器2：192.168.1.102  
服务器3：192.168.1.103

要求：
✅ 服务器之间网络互通
✅ 防火墙开放相关端口
✅ 时钟尽量同步
```

### 2.3 端口配置说明


**Zookeeper使用的端口**

| 端口 | 名称 | 作用 | 说明 |
|------|------|------|------|
| **2181** | 客户端端口 | 客户端连接Zookeeper | 对外提供服务的端口 |
| **2888** | Leader通信端口 | Follower连接Leader | 集群内部数据同步 |
| **3888** | 选举端口 | Leader选举通信 | 选举Leader时使用 |

> **💡 记忆技巧**：2181是对外的，2888和3888是集群内部用的，数字递增。

**端口配置示意**
```
服务器之间的通信：

节点1 (192.168.1.101)
  ↕ 2888端口（数据同步）
节点2 (192.168.1.102)
  ↕ 3888端口（选举通信）
节点3 (192.168.1.103)

客户端连接：
客户端 → 2181端口 → 任意节点
```

---

## 3. ⚙️ 配置文件详解


### 3.1 myid文件配置


**myid是什么？**
```
myid就是每个节点的"身份证号"

比如你们班有3个同学都叫"张伟"：
• 张伟1号：学号001
• 张伟2号：学号002  
• 张伟3号：学号003

Zookeeper集群中，每台服务器也需要一个唯一的编号，
这个编号就写在myid文件里。
```

**myid文件位置与内容**
```bash
# myid文件位置（在dataDir目录下）
/data/zookeeper/myid

# 每台服务器的myid内容不同：
服务器1的myid文件内容：1
服务器2的myid文件内容：2
服务器3的myid文件内容：3
```

**创建myid文件步骤**
```bash
# 1. 创建数据目录（如果不存在）
mkdir -p /data/zookeeper

# 2. 在服务器1上创建myid
echo "1" > /data/zookeeper/myid

# 3. 在服务器2上创建myid
echo "2" > /data/zookeeper/myid

# 4. 在服务器3上创建myid
echo "3" > /data/zookeeper/myid

# 5. 验证myid内容
cat /data/zookeeper/myid
```

> **⚠️ 注意事项**：
> - myid文件中只能有一个数字
> - 数字必须和配置文件中的server.X的X对应
> - 不同服务器的myid必须不同

### 3.2 zoo.cfg配置文件详解


**配置文件位置**
```
通常在：/opt/zookeeper/conf/zoo.cfg
或者：/etc/zookeeper/zoo.cfg
```

**完整配置文件示例**
```properties
# ==================== 基础配置 ====================
# 心跳时间间隔（毫秒）
tickTime=2000

# 初始化连接时最多容忍多少个心跳时间间隔
# follower连接leader的超时时间 = initLimit × tickTime = 10 × 2000 = 20秒
initLimit=10

# leader和follower之间同步的超时时间
# syncLimit × tickTime = 5 × 2000 = 10秒
syncLimit=5

# ==================== 数据目录 ====================
# 数据存储目录（存放myid和数据快照）
dataDir=/data/zookeeper

# 日志目录（建议和dataDir分开，放在不同磁盘）
dataLogDir=/data/zookeeper/logs

# ==================== 端口配置 ====================
# 客户端连接端口
clientPort=2181

# ==================== 集群配置 ====================
# server.服务器ID=IP地址:Leader通信端口:选举端口
server.1=192.168.1.101:2888:3888
server.2=192.168.1.102:2888:3888
server.3=192.168.1.103:2888:3888

# ==================== 其他配置 ====================
# 最大客户端连接数（0表示无限制）
maxClientCnxns=60

# 自动清理快照和日志文件（保留最近3个）
autopurge.snapRetainCount=3
autopurge.purgeInterval=1
```

**核心参数详解**

**tickTime（心跳间隔）**
```
tickTime=2000

通俗理解：
就像你和朋友约定每2秒互相确认一次"还在吗？"
Zookeeper集群中的节点就是通过这个间隔来相互确认对方是否存活。

• 单位：毫秒
• 作用：集群心跳的基本时间单位
• 建议值：2000（2秒）
```

**initLimit（初始化超时）**
```
initLimit=10

通俗理解：
新员工入职，给他10个"时间单位"来完成培训和同步工作资料。
Follower连接Leader时，允许用 10 × tickTime = 20秒 来同步数据。

• 作用：Follower启动时连接Leader的超时倍数
• 计算：initLimit × tickTime = 实际超时时间
• 场景：数据量大时可以适当调大
```

**syncLimit（同步超时）**
```
syncLimit=5

通俗理解：
日常工作中，如果5个"时间单位"内还没同步完成，就认为出问题了。
Leader和Follower之间同步数据，最多允许 5 × tickTime = 10秒。

• 作用：运行时同步的超时倍数
• 计算：syncLimit × tickTime = 实际超时时间
• 场景：网络不稳定时可以适当调大
```

**server.X配置格式**
```
server.X=IP地址:端口1:端口2

详细说明：
server.1=192.168.1.101:2888:3888
   ↑      ↑            ↑    ↑
   |      |            |    └─ 选举端口（3888）
   |      |            └────── Leader通信端口（2888）
   |      └─────────────────── 服务器IP地址
   └────────────────────────── 服务器编号（对应myid）

记忆要点：
• server后的数字必须和myid文件内容一致
• 每台服务器都要配置所有节点信息（包括自己）
• 三台服务器的zoo.cfg中集群配置部分完全相同
```

### 3.3 配置同步


**三台服务器配置对比**

```
服务器1 (192.168.1.101)
├── zoo.cfg（三台服务器这个文件完全相同）
└── myid内容：1

服务器2 (192.168.1.102)
├── zoo.cfg（三台服务器这个文件完全相同）
└── myid内容：2

服务器3 (192.168.1.103)
├── zoo.cfg（三台服务器这个文件完全相同）
└── myid内容：3
```

> **💡 关键理解**：
> - `zoo.cfg`文件在所有服务器上**完全一样**
> - `myid`文件在每台服务器上**必须不同**
> - 这样每台服务器就知道"我是谁"以及"集群里还有谁"

---

## 4. 🚀 集群启动与验证


### 4.1 节点启动顺序


**启动顺序重要吗？**
```
理论上：可以任意顺序启动
实际中：建议按编号顺序启动（1 → 2 → 3）

原因：
• 方便观察启动日志
• 容易排查问题
• 符合逻辑习惯
```

**启动命令**
```bash
# 在每台服务器上执行
/opt/zookeeper/bin/zkServer.sh start

# 查看启动状态
/opt/zookeeper/bin/zkServer.sh status
```

**启动过程分析**
```
第1台启动时：
[Server 1] 启动 → 尝试连接其他节点 → 连接失败 → 等待
（因为其他节点还没启动，属于正常现象）

第2台启动时：
[Server 2] 启动 → 连接到Server 1 → 开始选举 → 选出Leader
（2台已经过半，可以选出Leader了）

第3台启动时：
[Server 3] 启动 → 连接到集群 → 作为Follower加入
（集群已经稳定运行）
```

### 4.2 集群状态验证


**查看节点状态**
```bash
# 在每台服务器上执行
zkServer.sh status

# 可能的输出结果：
Mode: leader      # 表示这是Leader节点
Mode: follower    # 表示这是Follower节点
```

**状态验证示例**
```
服务器1（192.168.1.101）
$ zkServer.sh status
Mode: follower

服务器2（192.168.1.102）
$ zkServer.sh status
Mode: leader

服务器3（192.168.1.103）
$ zkServer.sh status
Mode: follower

✅ 验证通过：1个Leader + 2个Follower
```

**连接测试**
```bash
# 使用客户端连接任意节点
zkCli.sh -server 192.168.1.101:2181

# 或者连接整个集群（会自动选择可用节点）
zkCli.sh -server 192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181

# 连接成功后，执行简单命令测试
ls /
create /test "hello"
get /test
```

### 4.3 集群验证方法


**方法一：查看日志**
```bash
# 查看zookeeper日志
tail -f /opt/zookeeper/logs/zookeeper.out

# 正常日志关键信息：
✅ LEADING - LEADER ELECTION TOOK
✅ FOLLOWING - LEADER ELECTION TOOK
✅ Established session
```

**方法二：四字命令**
```bash
# stat命令：查看节点状态
echo stat | nc 192.168.1.101 2181

# ruok命令：检查节点是否正常（返回imok表示正常）
echo ruok | nc 192.168.1.101 2181

# conf命令：查看配置信息
echo conf | nc 192.168.1.101 2181
```

**方法三：模拟故障**
```bash
# 停止Leader节点，观察是否重新选举
zkServer.sh stop  # 在Leader节点执行

# 在其他节点查看状态
zkServer.sh status

# 预期结果：剩余节点会重新选出一个Leader
```

---

## 5. 🗳️ Leader选举机制


### 5.1 选举基本原理


**什么是Leader选举？**
```
就像班级选班长：
• 需要过半同学同意才能当选
• 谁的条件好（数据新、编号大）谁优先
• 选出来后，其他人要听班长的

Zookeeper选举也是类似：
• 需要超过半数节点投票
• 数据越新越有优势
• 选出Leader后，其他节点变成Follower
```

**选举触发时机**
- **集群启动时**：所有节点都是Follower，需要选出Leader
- **Leader宕机时**：需要重新选举新的Leader
- **Leader失联时**：网络分区导致联系不上

### 5.2 选举过程详解


**选举状态说明**
```
LOOKING（寻找状态）
   ↓
   • 节点正在寻找Leader
   • 还在投票阶段

FOLLOWING（跟随状态）
   ↓
   • 已经选出Leader
   • 自己是Follower

LEADING（领导状态）
   ↓
   • 自己被选为Leader
   • 负责协调整个集群
```

**选举流程图示**
```
3台服务器启动选举过程：

初始状态：
Server1: LOOKING  Server2: LOOKING  Server3: LOOKING
   ↓                 ↓                 ↓

第一轮投票（每个服务器先投自己）：
Server1投票: (1, 0)   Server2投票: (2, 0)   Server3投票: (3, 0)
      ↓                    ↓                    ↓
   (myid, zxid)        (myid, zxid)        (myid, zxid)

第二轮投票（收到其他人的票后，选择更优的）：
• Server1收到2和3的票 → 发现3的myid最大 → 改投3
• Server2收到1和3的票 → 发现3的myid最大 → 改投3
• Server3收到1和2的票 → 大家都投自己 → 保持投3

最终结果：
Server1: FOLLOWING  Server2: FOLLOWING  Server3: LEADING
        ↘              ↓              ↙
                   Server3当选Leader
```

**投票规则**
```
每个节点的投票信息：(myid, zxid)
                    ↑      ↑
                    |      └─ 事务ID（数据版本号，越大越新）
                    └──────── 服务器编号

比较规则：
1️⃣ 先比较zxid：谁的数据越新（zxid越大），谁优先
2️⃣ 如果zxid相同：比较myid，编号越大越优先

例子：
投票A: (1, 100)  vs  投票B: (3, 100)
→ zxid相同，比较myid → B获胜（3 > 1）

投票A: (1, 100)  vs  投票B: (3, 80)
→ 先比zxid → A获胜（100 > 80）
```

### 5.3 选举机制核心要点


**过半机制（Quorum）**
```
3台集群：需要 ⌈3/2⌉ + 1 = 2票 才能当选
5台集群：需要 ⌈5/2⌉ + 1 = 3票 才能当选
7台集群：需要 ⌈7/2⌉ + 1 = 4票 才能当选

这就是为什么要用奇数节点：
4台集群也需要3票，和3台容错能力一样
6台集群也需要4票，和5台容错能力一样
```

**选举时间**
```
正常情况：选举非常快（毫秒级）
• 网络好 + 数据一致 → 通常1-2秒完成

异常情况：选举时间较长
• 网络延迟大 → 可能需要5-10秒
• 数据差异大 → 需要多轮投票
```

> **💡 记忆要点**：
> - 选举需要**过半**投票
> - **数据新**的优先（zxid大）
> - 数据一样时**编号大**的优先（myid大）
> - 节点数量要是**奇数**

### 5.4 选举异常场景


**场景1：Leader宕机**
```
初始状态：
Server1: FOLLOWING
Server2: LEADING   ← 宕机！
Server3: FOLLOWING

重新选举：
Server1: LOOKING   Server3: LOOKING
   ↓                    ↓
比较投票 → Server3的myid更大 → Server3当选

最终状态：
Server1: FOLLOWING
Server3: LEADING   ← 新Leader
```

**场景2：脑裂问题**
```
什么是脑裂？
网络故障导致集群分成两部分，每部分都以为自己是正常的

5台集群分裂：
分区1: Server1, Server2  (2台)
分区2: Server3, Server4, Server5  (3台)

结果：
• 分区1：无法过半（2 < 3），停止服务 ✅
• 分区2：可以过半（3 ≥ 3），选出Leader，继续服务 ✅

这就是为什么要"过半机制"：避免出现两个Leader
```

---

## 6. 📋 核心要点总结


### 6.1 集群部署关键步骤


```
📋 **部署检查清单**
- [ ] 确定节点数量（3台/5台/7台，必须奇数）
- [ ] 规划IP地址和端口（2181/2888/3888）
- [ ] 在每台服务器上创建myid文件（内容不同）
- [ ] 配置zoo.cfg文件（所有服务器内容相同）
- [ ] 确保网络互通，开放相关端口
- [ ] 按顺序启动所有节点
- [ ] 验证集群状态（1个Leader + N个Follower）
```

### 6.2 配置要点记忆


**myid配置**
```
🔑 关键记忆：
• 位置：dataDir目录下
• 内容：只有一个数字
• 规则：每台服务器不同，对应server.X的X
```

**zoo.cfg配置**
```
🔑 关键记忆：
• tickTime：心跳间隔基础单位（2000毫秒）
• initLimit：初始化超时倍数（10倍tickTime）
• syncLimit：同步超时倍数（5倍tickTime）
• server.X：X是myid，后面跟IP和两个端口
```

**端口配置**
```
🔑 关键记忆：
• 2181：客户端端口（对外服务）
• 2888：Leader通信端口（内部数据同步）
• 3888：选举端口（选举通信）
```

### 6.3 选举机制记忆


**投票规则**
```
🔑 关键记忆：
1. 先比zxid（数据版本）→ 越大越优先
2. zxid相同比myid（服务器编号）→ 越大越优先
3. 需要过半投票才能当选
4. 节点数必须是奇数
```

**常见问题快速参考**

| 问题 | 原因 | 解决方法 |
|------|------|---------|
| 启动报错找不到myid | myid文件不存在 | 在dataDir目录创建myid文件 |
| 集群无法选出Leader | 启动节点数少于半数 | 至少启动过半节点 |
| 节点状态显示standalone | 配置文件缺少集群配置 | 添加server.X配置 |
| 端口连接失败 | 防火墙阻止或端口被占用 | 开放端口或更换端口 |

### 6.4 实用运维命令


```bash
# 启动服务
zkServer.sh start

# 查看状态
zkServer.sh status

# 停止服务
zkServer.sh stop

# 重启服务
zkServer.sh restart

# 查看日志
tail -f $ZK_HOME/logs/zookeeper.out

# 连接集群
zkCli.sh -server ip1:2181,ip2:2181,ip3:2181

# 四字命令检查
echo stat | nc localhost 2181  # 查看状态
echo ruok | nc localhost 2181  # 健康检查
echo conf | nc localhost 2181  # 查看配置
```

**核心记忆口诀**：
```
🎵 集群部署要记牢：
• 奇数节点不能少
• myid各不同，zoo.cfg要相同
• 先比数据再比号，过半投票当领导
• 2181客户连，2888同步用，3888选举通
```