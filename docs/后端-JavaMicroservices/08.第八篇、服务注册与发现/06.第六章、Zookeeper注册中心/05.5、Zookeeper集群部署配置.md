---
title: 5、Zookeeper集群部署配置
---
## 📚 目录

1. [Zookeeper部署模式概述](#1-Zookeeper部署模式概述)
2. [单机模式配置详解](#2-单机模式配置详解)
3. [集群模式配置实战](#3-集群模式配置实战)
4. [myid文件配置说明](#4-myid文件配置说明)
5. [zoo.cfg核心参数详解](#5-zoo-cfg核心参数详解)
6. [JVM参数调优指南](#6-JVM参数调优指南)
7. [监控配置实践](#7-监控配置实践)
8. [日志配置管理](#8-日志配置管理)
9. [安全配置加固](#9-安全配置加固)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 Zookeeper部署模式概述


### 1.1 什么是Zookeeper部署模式


**通俗理解**：就像开店一样，你可以开一家小店（单机模式），也可以开连锁店（集群模式）

```
单机模式：               集群模式：
   [ZK]                [ZK1] ←→ [ZK2] ←→ [ZK3]
    ↓                    ↓        ↓        ↓
  应用                  应用      应用      应用
  
单机：简单但不稳定      集群：复杂但更可靠
```

### 1.2 部署模式对比


**三种部署模式的区别**：

| 模式类型 | **适用场景** | **可靠性** | **复杂度** | **成本** |
|---------|------------|-----------|-----------|---------|
| 🔸 **单机模式** | `开发测试环境` | `低` | `简单` | `低` |
| 🔸 **伪集群模式** | `学习验证` | `中` | `中等` | `低` |
| 🔸 **真集群模式** | `生产环境` | `高` | `较高` | `中高` |

**💡 新手理解**：
- **单机**：就像你自己一个人干活，简单但容易出问题
- **伪集群**：在一台电脑上模拟多个服务，适合练手
- **真集群**：多台服务器协同工作，一个挂了其他顶上

### 1.3 集群节点数量选择


**为什么要奇数个节点？**

```
核心原理：过半机制（Majority）

3台集群：需要2台正常 = 允许1台故障  ✓
4台集群：需要3台正常 = 允许1台故障  ✗ (浪费资源)

5台集群：需要3台正常 = 允许2台故障  ✓
6台集群：需要4台正常 = 允许2台故障  ✗ (浪费资源)

结论：奇数台性价比最高！
```

**🎯 推荐配置**：
- **3节点集群**：允许1台故障，最常用的配置
- **5节点集群**：允许2台故障，高可用场景
- **7节点集群**：允许3台故障，金融级别场景

---

## 2. 📝 单机模式配置详解


### 2.1 单机模式是什么


**简单理解**：就是在一台服务器上运行一个Zookeeper实例，就像你开了一家单店

**适用场景**：
- ✅ 本地开发调试
- ✅ 功能测试验证
- ✅ 学习Zookeeper基础
- ❌ 不适合生产环境（单点故障）

### 2.2 单机模式配置步骤


**第一步：创建配置文件**

```bash
# 进入Zookeeper配置目录
cd /opt/zookeeper/conf

# 复制配置模板
cp zoo_sample.cfg zoo.cfg

# 编辑配置文件
vim zoo.cfg
```

**第二步：基础配置参数**

```properties
# 基础时间单位（毫秒），其他时间参数都是这个的倍数
# 就像定一个"节拍"，其他配置跟着这个节奏走
tickTime=2000

# 数据存储目录，存放快照文件和事务日志
# 类似于数据库的数据目录
dataDir=/data/zookeeper/data

# 客户端连接端口
# 应用程序通过这个端口连接Zookeeper
clientPort=2181

# 单个客户端的最大连接数，0表示不限制
# 防止某个客户端占用太多连接
maxClientCnxns=60
```

**💡 参数含义解释**：

- **tickTime**：心跳间隔时间
  ```
  想象成：每隔2秒喊一声"我还活着"
  影响：session超时判断的基准
  ```

- **dataDir**：数据目录
  ```
  作用：存储所有数据快照和事务日志
  注意：要有足够磁盘空间，定期清理
  ```

- **clientPort**：服务端口
  ```
  默认：2181端口
  作用：客户端连接入口
  修改：可以改成其他端口，但要通知所有客户端
  ```

### 2.3 启动单机Zookeeper


```bash
# 启动服务
/opt/zookeeper/bin/zkServer.sh start

# 查看状态
/opt/zookeeper/bin/zkServer.sh status

# 输出示例
Mode: standalone  ← 表示单机模式
```

**🔍 验证是否启动成功**：

```bash
# 方法1：查看进程
jps | grep QuorumPeerMain

# 方法2：查看端口
netstat -nltp | grep 2181

# 方法3：客户端连接测试
/opt/zookeeper/bin/zkCli.sh -server localhost:2181
```

---

## 3. 🏗️ 集群模式配置实战


### 3.1 集群模式核心概念


**集群角色理解**：

```
Leader（领导者）：          Follower（跟随者）：
   老板                      员工
   ↓                         ↓
- 处理写请求               - 处理读请求
- 协调其他节点             - 转发写请求给Leader
- 主导选举                 - 参与投票

Observer（观察者）：
   实习生
   ↓
- 只处理读请求
- 不参与投票
- 提升读性能
```

**💡 工作流程**：
```
客户端写请求 → Follower → 转发给Leader → Leader协调 → 
全部Follower确认 → 提交成功 → 通知客户端
```

### 3.2 三节点集群配置实战


**服务器规划**：

| 服务器 | **IP地址** | **角色** | **端口配置** |
|-------|-----------|---------|------------|
| server1 | `192.168.1.101` | `节点1` | `2181/2888/3888` |
| server2 | `192.168.1.102` | `节点2` | `2181/2888/3888` |
| server3 | `192.168.1.103` | `节点3` | `2181/2888/3888` |

**端口说明**：
- **2181**：客户端连接端口
- **2888**：Follower与Leader通信端口（数据同步）
- **3888**：Leader选举通信端口

**配置文件 zoo.cfg（所有节点相同）**：

```properties
# ========== 基础参数 ==========
# 心跳间隔：2秒
tickTime=2000

# 初始化连接时间：10个心跳 = 20秒
# Leader启动后，Follower要在这个时间内完成连接
initLimit=10

# 同步时间：5个心跳 = 10秒  
# Follower与Leader同步数据的超时时间
syncLimit=5

# ========== 存储配置 ==========
# 数据目录
dataDir=/data/zookeeper/data

# 事务日志目录（建议独立磁盘）
dataLogDir=/data/zookeeper/logs

# ========== 网络配置 ==========
# 客户端端口
clientPort=2181

# 最大客户端连接数
maxClientCnxns=60

# ========== 集群配置 ==========
# 格式：server.id=host:port1:port2
# id：服务器编号（与myid文件对应）
# host：服务器地址
# port1：数据同步端口
# port2：选举通信端口

server.1=192.168.1.101:2888:3888
server.2=192.168.1.102:2888:3888
server.3=192.168.1.103:2888:3888
```

**🔸 参数详解**：

**initLimit（初始化时限）**：
```
含义：集群启动时，Follower连接Leader的超时时间
计算：10 × tickTime = 10 × 2000ms = 20秒
场景：网络慢或数据量大时，可以调大这个值
```

**syncLimit（同步时限）**：
```
含义：运行过程中，Follower与Leader同步的超时时间
计算：5 × tickTime = 5 × 2000ms = 10秒
场景：网络延迟大时，建议调大
```

### 3.3 集群部署步骤


**步骤① 创建数据目录（每个节点）**：

```bash
# 创建数据和日志目录
mkdir -p /data/zookeeper/data
mkdir -p /data/zookeeper/logs

# 设置权限
chown -R zookeeper:zookeeper /data/zookeeper
```

**步骤② 配置zoo.cfg（每个节点）**：

```bash
# 编辑配置文件
vim /opt/zookeeper/conf/zoo.cfg

# 将上面的配置内容复制进去
# 所有节点的zoo.cfg配置完全相同！
```

**步骤③ 配置myid文件（每个节点不同）**：

```bash
# 节点1（192.168.1.101）
echo "1" > /data/zookeeper/data/myid

# 节点2（192.168.1.102）
echo "2" > /data/zookeeper/data/myid

# 节点3（192.168.1.103）
echo "3" > /data/zookeeper/data/myid
```

**步骤④ 启动集群（每个节点）**：

```bash
# 启动服务
/opt/zookeeper/bin/zkServer.sh start

# 查看状态
/opt/zookeeper/bin/zkServer.sh status
```

**步骤⑤ 验证集群状态**：

```bash
# 节点1查看
zkServer.sh status
# 输出：Mode: follower

# 节点2查看  
zkServer.sh status
# 输出：Mode: leader

# 节点3查看
zkServer.sh status
# 输出：Mode: follower
```

**✅ 集群部署验证**：

```bash
# 连接到任意节点
zkCli.sh -server 192.168.1.101:2181

# 创建测试节点
create /test "hello zk cluster"

# 在另一个节点查看
zkCli.sh -server 192.168.1.102:2181
get /test
# 输出：hello zk cluster ✓ 说明数据已同步
```

---

## 4. 📄 myid文件配置说明


### 4.1 myid文件的作用


**简单理解**：就像给每个Zookeeper节点发一个工号牌

```
myid文件 = 节点的身份证号码

server.1 ←→ myid文件内容是"1"
server.2 ←→ myid文件内容是"2"  
server.3 ←→ myid文件内容是"3"

作用：让节点知道"我是谁"
```

### 4.2 myid配置规则


**🔸 配置要求**：

| 要求项 | **说明** | **示例** |
|-------|---------|---------|
| 位置 | `dataDir目录下` | `/data/zookeeper/data/myid` |
| 内容 | `纯数字，与server.id对应` | `1` 或 `2` 或 `3` |
| 范围 | `1-255之间的整数` | 不能是0或负数 |
| 格式 | `只有一行，纯数字` | 不要有空格或换行 |

**正确示例**：

```bash
# 方式1：使用echo命令
echo "1" > /data/zookeeper/data/myid

# 方式2：使用vim编辑
vim /data/zookeeper/data/myid
# 输入数字1，保存退出

# 验证内容
cat /data/zookeeper/data/myid
# 输出：1
```

**❌ 错误示例**：

```bash
# 错误1：多行内容
echo -e "1\n2" > myid  # ✗ 只能一行

# 错误2：包含空格
echo "1 " > myid  # ✗ 不能有空格

# 错误3：非数字内容  
echo "node1" > myid  # ✗ 必须是纯数字

# 错误4：超出范围
echo "256" > myid  # ✗ 必须在1-255之间
```

### 4.3 myid与集群配置对应关系


```
zoo.cfg配置：                myid文件内容：
server.1=192.168.1.101:2888:3888  →  节点101的myid = 1
server.2=192.168.1.102:2888:3888  →  节点102的myid = 2
server.3=192.168.1.103:2888:3888  →  节点103的myid = 3

对应关系：
myid的数字 必须等于 server.后面的数字
```

**🔍 常见错误排查**：

```
错误现象：节点启动后无法加入集群

可能原因：
1. myid文件不存在
   → 检查：ls /data/zookeeper/data/myid
   
2. myid内容与配置不匹配  
   → 检查：cat /data/zookeeper/data/myid
   → 对比：zoo.cfg中的server.id配置
   
3. myid文件权限问题
   → 检查：ls -l /data/zookeeper/data/myid
   → 修复：chmod 644 /data/zookeeper/data/myid
```

---

## 5. ⚙️ zoo.cfg核心参数详解


### 5.1 时间相关参数


**tickTime - 心跳基准时间**：

```properties
tickTime=2000

含义：Zookeeper的基本时间单位（毫秒）
作用：
  - session超时检测的基础
  - 其他时间参数的计算单位
  
实际影响：
  tickTime=2000 → 其他时间都是它的倍数
  - initLimit=10 → 实际 = 10×2000ms = 20秒
  - syncLimit=5  → 实际 = 5×2000ms = 10秒
```

**💡 调优建议**：
- **默认2000ms**：适合大多数场景
- **网络好可调小**：1000ms，提高响应速度
- **网络差要调大**：3000-5000ms，减少误判

**initLimit - 初始化时限**：

```properties
initLimit=10

含义：Follower连接并同步Leader的超时倍数
实际时间 = initLimit × tickTime

场景示例：
  集群启动时：
  1. Follower启动，连接Leader
  2. Leader发送所有数据给Follower  
  3. 必须在20秒内完成（10×2000ms）
  
什么时候需要调大：
  - 数据量特别大（几个GB）
  - 网络带宽小
  - 机器性能差
```

**syncLimit - 同步时限**：

```properties
syncLimit=5

含义：运行时同步的超时倍数
实际时间 = syncLimit × tickTime = 10秒

场景示例：
  正常运行时：
  1. Leader收到写请求
  2. 转发给所有Follower
  3. Follower在10秒内必须响应
  
什么时候需要调大：
  - 网络延迟大
  - 写操作频繁
  - 数据量大
```

### 5.2 存储相关参数


**dataDir - 数据目录**：

```properties
dataDir=/data/zookeeper/data

作用：存储数据快照文件
内容：
  - snapshot.*  # 数据快照
  - myid        # 服务器ID

注意事项：
  ✓ 要有足够磁盘空间（至少10GB）
  ✓ 使用SSD可提升性能
  ✓ 定期清理旧快照
```

**dataLogDir - 事务日志目录**：

```properties
dataLogDir=/data/zookeeper/logs

作用：存储事务日志（重要！）
建议：
  - 与dataDir分开
  - 使用独立的磁盘（避免IO竞争）
  - SSD性能更佳

原理：
  写操作 → 先写日志 → 再写内存 → 最后生成快照
  日志是保证数据不丢失的关键
```

**⚠️ 重要提示**：
```
事务日志目录性能影响最大！
建议配置：
1. 使用独立磁盘
2. 优先使用SSD
3. RAID10配置更佳

性能对比：
HDD：      写延迟 10-20ms
SSD：      写延迟 1-2ms
NVMe SSD： 写延迲 <1ms
```

### 5.3 网络相关参数


**clientPort - 客户端端口**：

```properties
clientPort=2181

作用：客户端连接端口
默认：2181
修改：可以改，但要通知所有客户端

连接方式：
  zkCli.sh -server localhost:2181
  或
  zkCli.sh -server 192.168.1.101:2181
```

**maxClientCnxns - 最大连接数**：

```properties
maxClientCnxns=60

含义：单个客户端IP的最大并发连接数
作用：防止某个客户端占用太多连接

设置建议：
  - 开发环境：60（默认）
  - 生产环境：根据实际调整
  - 0表示不限制（不推荐）
```

**autopurge - 自动清理参数**：

```properties
# 保留快照数量
autopurge.snapRetainCount=3

# 清理间隔（小时）
autopurge.purgeInterval=24

作用：
  - 每24小时清理一次旧快照
  - 只保留最新的3个快照
  - 避免磁盘占满
```

### 5.4 集群相关参数


**server.id配置格式**：

```properties
server.1=192.168.1.101:2888:3888

格式：server.id=host:port1:port2

参数说明：
  id     → 服务器编号（1-255）
  host   → IP地址或主机名
  port1  → 数据同步端口（默认2888）
  port2  → 选举通信端口（默认3888）
```

**完整配置示例**：

```properties
# ========== 时间参数 ==========
tickTime=2000
initLimit=10
syncLimit=5

# ========== 存储参数 ==========  
dataDir=/data/zookeeper/data
dataLogDir=/data/zookeeper/logs

# ========== 网络参数 ==========
clientPort=2181
maxClientCnxns=60

# ========== 集群参数 ==========
server.1=192.168.1.101:2888:3888
server.2=192.168.1.102:2888:3888
server.3=192.168.1.103:2888:3888

# ========== 清理参数 ==========
autopurge.snapRetainCount=3
autopurge.purgeInterval=24

# ========== 高级参数 ==========
# 4字命令支持（stat、cons等）
4lw.commands.whitelist=*

# 启用管理服务器
admin.enableServer=true
admin.serverPort=8080
```

---

## 6. 🚀 JVM参数调优指南


### 6.1 为什么要调优JVM


**简单理解**：Zookeeper是Java程序，JVM就是它的运行环境

```
JVM调优的目标：
1. 减少GC停顿 → 提高响应速度
2. 避免OOM    → 保证稳定运行
3. 优化内存   → 合理利用资源
```

### 6.2 基础JVM参数配置


**配置文件位置**：

```bash
# 编辑启动脚本
vim /opt/zookeeper/bin/zkServer.sh

# 或者创建环境变量文件
vim /opt/zookeeper/conf/java.env
```

**基础配置模板**：

```bash
# ========== 内存配置 ==========
# 堆内存：根据机器配置调整
HEAP="-Xms4G -Xmx4G"

# 新生代：堆内存的1/3到1/2
YOUNG_GEN="-Xmn1G"

# ========== GC配置 ==========
# 使用G1垃圾收集器（推荐）
GC="-XX:+UseG1GC"

# GC日志
GC_LOG="-Xloggc:/data/zookeeper/logs/zk-gc.log"
GC_LOG="$GC_LOG -XX:+PrintGCDetails"
GC_LOG="$GC_LOG -XX:+PrintGCDateStamps"

# ========== 其他参数 ==========
# 禁用偏向锁（避免STW）
OTHER="-XX:-UseBiasedLocking"

# OOM时生成dump文件
OTHER="$OTHER -XX:+HeapDumpOnOutOfMemoryError"
OTHER="$OTHER -XX:HeapDumpPath=/data/zookeeper/logs"

# 汇总
export JVMFLAGS="$HEAP $YOUNG_GEN $GC $GC_LOG $OTHER"
```

**💡 参数说明**：

**内存参数**：
```
-Xms4G：初始堆内存4GB
-Xmx4G：最大堆内存4GB

为什么设置相同：
  - 避免运行时动态扩容
  - 减少GC次数
  - 提高性能稳定性

如何确定大小：
  - 小规模：2-4GB
  - 中等规模：4-8GB
  - 大规模：8-16GB
  - 不要超过物理内存的50%
```

**垃圾回收器选择**：
```
G1GC（推荐）：
  优点：
    - 停顿时间可预测
    - 适合大内存
    - 自动调节
    
  适用：
    - 内存>4GB的场景
    - 对延迟敏感的应用

CMS（备选）：
  优点：
    - 并发标记，停顿少
    - 适合中等内存
    
  缺点：
    - 碎片化问题
    - Full GC时间长
```

### 6.3 不同规模的推荐配置


**小规模集群（<100个客户端）**：

```bash
# 内存配置
-Xms2G -Xmx2G -Xmn512M

# GC配置  
-XX:+UseG1GC
-XX:MaxGCPauseMillis=50

# 完整示例
JVMFLAGS="-Xms2G -Xmx2G -Xmn512M -XX:+UseG1GC -XX:MaxGCPauseMillis=50"
```

**中等规模（100-1000个客户端）**：

```bash
# 内存配置
-Xms4G -Xmx4G -Xmn1G

# GC配置
-XX:+UseG1GC  
-XX:MaxGCPauseMillis=100
-XX:G1ReservePercent=10

# 完整示例
JVMFLAGS="-Xms4G -Xmx4G -Xmn1G -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:G1ReservePercent=10"
```

**大规模集群（>1000个客户端）**：

```bash
# 内存配置
-Xms8G -Xmx8G -Xmn2G

# GC配置
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200  
-XX:InitiatingHeapOccupancyPercent=45

# 完整示例
JVMFLAGS="-Xms8G -Xmx8G -Xmn2G -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:InitiatingHeapOccupancyPercent=45"
```

### 6.4 GC日志分析


**查看GC日志**：

```bash
# 实时查看
tail -f /data/zookeeper/logs/zk-gc.log

# 关键指标
2025-09-23T10:30:15.123+0800: [GC pause (G1 Evacuation Pause) (young) 
  512M->128M(4096M), 0.0234567 secs]

解读：
  - GC类型：年轻代GC
  - 内存变化：512MB → 128MB
  - 总内存：4096MB
  - 耗时：23.4ms ✓ 正常（<100ms）
```

**⚠️ 需要关注的指标**：

| 指标 | **正常范围** | **需优化** | **处理方式** |
|-----|-----------|----------|------------|
| Young GC耗时 | `<50ms` | `>100ms` | `增大新生代` |
| Full GC频率 | `几小时一次` | `每小时多次` | `增大堆内存` |
| GC后内存 | `<70%` | `>85%` | `检查内存泄漏` |

---

## 7. 📊 监控配置实践


### 7.1 监控的重要性


**为什么要监控？**

```
就像体检一样，提前发现问题：

没有监控：              有监控：
服务挂了才知道     →    提前预警，及时处理
不知道哪里慢       →    定位性能瓶颈  
数据丢失才发现     →    实时检测异常
```

### 7.2 四字命令监控


**什么是四字命令**：Zookeeper提供的简单监控命令

**常用四字命令**：

```bash
# stat - 查看服务器状态
echo stat | nc localhost 2181

输出：
Zookeeper version: 3.8.0
Clients:
 /192.168.1.100:52341[0](queued=0,recved=1,sent=0)
Latency min/avg/max: 0/1/10
Received: 1234
Sent: 1235
Connections: 5
Outstanding: 0
Mode: follower  ← 当前角色

# cons - 查看连接信息
echo cons | nc localhost 2181

# mntr - 查看监控指标
echo mntr | nc localhost 2181

输出：
zk_packets_received=12345
zk_packets_sent=12346
zk_num_alive_connections=5
zk_outstanding_requests=0
```

**开启四字命令**：

```properties
# 在zoo.cfg中添加
4lw.commands.whitelist=*

# 或指定命令
4lw.commands.whitelist=stat,cons,mntr
```

### 7.3 JMX监控配置


**启用JMX**：

```bash
# 编辑zkServer.sh，添加JMX参数
JMX_PORT=9999
JMX_OPTS="-Dcom.sun.management.jmxremote"
JMX_OPTS="$JMX_OPTS -Dcom.sun.management.jmxremote.port=$JMX_PORT"
JMX_OPTS="$JMX_OPTS -Dcom.sun.management.jmxremote.authenticate=false"
JMX_OPTS="$JMX_OPTS -Dcom.sun.management.jmxremote.ssl=false"

export JVMFLAGS="$JVMFLAGS $JMX_OPTS"
```

**使用JConsole连接**：

```bash
# 启动JConsole
jconsole 192.168.1.101:9999

# 或使用VisualVM
jvisualvm
```

**关键JMX指标**：

| 指标名称 | **含义** | **正常值** | **告警阈值** |
|---------|---------|-----------|------------|
| `OutstandingRequests` | `待处理请求数` | `<10` | `>100` |
| `AvgRequestLatency` | `平均请求延迟` | `<10ms` | `>100ms` |
| `NumAliveConnections` | `活跃连接数` | `根据业务` | `突然下降` |
| `PacketsReceived` | `接收包数量` | `持续增长` | `不增长` |

### 7.4 Prometheus监控集成


**安装JMX Exporter**：

```bash
# 下载JMX Exporter
wget https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.17.0/jmx_prometheus_javaagent-0.17.0.jar

# 创建配置文件
vim /opt/zookeeper/conf/jmx_exporter.yml
```

**JMX Exporter配置**：

```yaml
lowercaseOutputName: true
lowercaseOutputLabelNames: true

rules:
  - pattern: "org.apache.ZooKeeperService<name0=(.+)><>(\\w+)"
    name: "zk_$2"
    labels:
      server: "$1"
```

**启动配置**：

```bash
# 在zkServer.sh中添加
JAVAAGENT="-javaagent:/opt/zookeeper/conf/jmx_prometheus_javaagent-0.17.0.jar=7070:/opt/zookeeper/conf/jmx_exporter.yml"

export JVMFLAGS="$JVMFLAGS $JAVAAGENT"
```

**Prometheus抓取配置**：

```yaml
scrape_configs:
  - job_name: 'zookeeper'
    static_configs:
      - targets: 
        - '192.168.1.101:7070'
        - '192.168.1.102:7070'  
        - '192.168.1.103:7070'
```

---

## 8. 📝 日志配置管理


### 8.1 Zookeeper日志类型


**日志分类**：

```
1. 操作日志（zookeeper.out）
   ├─ 启动信息
   ├─ 运行状态
   └─ 错误信息

2. 事务日志（log.*）
   ├─ 所有写操作
   ├─ 数据变更记录
   └─ 用于故障恢复

3. 快照文件（snapshot.*）
   ├─ 数据快照
   ├─ 定期生成
   └─ 用于快速恢复

4. GC日志（zk-gc.log）
   ├─ GC事件
   ├─ 内存使用
   └─ 性能分析
```

### 8.2 日志配置文件


**log4j.properties配置**：

```properties
# ========== 根日志配置 ==========
zookeeper.root.logger=INFO, ROLLINGFILE
zookeeper.console.threshold=INFO

# ========== 日志输出器 ==========
# 滚动文件输出
log4j.appender.ROLLINGFILE=org.apache.log4j.RollingFileAppender
log4j.appender.ROLLINGFILE.File=/data/zookeeper/logs/zookeeper.log

# 单个文件大小：100MB
log4j.appender.ROLLINGFILE.MaxFileSize=100MB

# 保留文件数：20个
log4j.appender.ROLLINGFILE.MaxBackupIndex=20

# 日志格式
log4j.appender.ROLLINGFILE.layout=org.apache.log4j.PatternLayout
log4j.appender.ROLLINGFILE.layout.ConversionPattern=%d{ISO8601} [myid:%X{myid}] - %-5p [%t:%C{1}@%L] - %m%n

# ========== 特定模块日志 ==========
# 减少Netty日志
log4j.logger.org.apache.zookeeper.server.NIOServerCnxn=WARN

# 客户端会话日志
log4j.logger.org.apache.zookeeper.server.ZooKeeperServer=INFO
```

**💡 日志级别说明**：

| 级别 | **使用场景** | **日志量** | **性能影响** |
|-----|-----------|----------|------------|
| `DEBUG` | `开发调试` | `非常大` | `严重` |
| `INFO` | `生产环境` | `中等` | `较小` |
| `WARN` | `只看警告` | `较小` | `很小` |
| `ERROR` | `只看错误` | `很小` | `极小` |

### 8.3 日志清理策略


**手动清理**：

```bash
# 清理7天前的日志
find /data/zookeeper/logs -name "zookeeper.log.*" -mtime +7 -delete

# 清理旧快照（保留最新5个）
cd /data/zookeeper/data
ls -t snapshot.* | tail -n +6 | xargs rm -f

# 清理旧事务日志
ls -t log.* | tail -n +6 | xargs rm -f
```

**自动清理配置**：

```properties
# zoo.cfg中配置
autopurge.snapRetainCount=5
autopurge.purgeInterval=24

含义：
  - 每24小时清理一次
  - 保留最新5个快照
  - 自动清理对应的事务日志
```

**定时任务清理**：

```bash
# 创建清理脚本
vim /opt/zookeeper/bin/cleanup.sh

#!/bin/bash
LOG_DIR="/data/zookeeper/logs"
DATA_DIR="/data/zookeeper/data"

# 清理7天前的操作日志
find $LOG_DIR -name "*.log.*" -mtime +7 -delete

# 清理GC日志
find $LOG_DIR -name "zk-gc.log.*" -mtime +7 -delete

# 添加定时任务
crontab -e
# 每天凌晨3点执行
0 3 * * * /opt/zookeeper/bin/cleanup.sh
```

---

## 9. 🔒 安全配置加固


### 9.1 为什么要安全加固


**安全风险**：

```
默认配置的风险：
1. 无认证访问 → 任何人都能连接
2. 明文传输   → 数据可被窃听
3. 无权限控制 → 所有人都能操作
4. 端口暴露   → 容易被攻击
```

### 9.2 ACL访问控制


**ACL基本概念**：

```
ACL = Access Control List（访问控制列表）

就像给房间设置门禁：
- 谁能进（认证）
- 能干啥（权限）
```

**ACL权限类型**：

| 权限 | **符号** | **说明** |
|-----|---------|---------|
| CREATE | `c` | `创建子节点` |
| DELETE | `d` | `删除子节点` |
| READ | `r` | `读取节点数据` |
| WRITE | `w` | `写入节点数据` |
| ADMIN | `a` | `设置节点ACL` |

**配置ACL示例**：

```bash
# 创建带ACL的节点
create /secure-node "sensitive data" digest:user1:password1:cdrwa

# 查看ACL
getAcl /secure-node

# 设置ACL
setAcl /secure-node digest:user1:hashed_password:cdrwa
```

### 9.3 SASL认证配置


**启用SASL认证**：

**步骤1：创建JAAS配置文件**

```bash
vim /opt/zookeeper/conf/jaas.conf

Server {
  org.apache.zookeeper.server.auth.DigestLoginModule required
  user_admin="admin_password"
  user_app="app_password";
};

Client {
  org.apache.zookeeper.server.auth.DigestLoginModule required
  username="admin"
  password="admin_password";
};
```

**步骤2：配置启动参数**

```bash
# 在zkServer.sh中添加
JAAS_CONF="-Djava.security.auth.login.config=/opt/zookeeper/conf/jaas.conf"
export JVMFLAGS="$JVMFLAGS $JAAS_CONF"
```

**步骤3：客户端连接**

```bash
# 使用认证连接
zkCli.sh -server localhost:2181

# 添加认证
addauth digest admin:admin_password

# 现在可以操作受保护的节点了
```

### 9.4 SSL/TLS加密传输


**启用SSL配置**：

```properties
# zoo.cfg中添加
secureClientPort=2281
ssl.keyStore.location=/opt/zookeeper/conf/keystore.jks
ssl.keyStore.password=your_password
ssl.trustStore.location=/opt/zookeeper/conf/truststore.jks
ssl.trustStore.password=your_password
```

**生成证书**：

```bash
# 生成keystore
keytool -genkeypair -keyalg RSA -keysize 2048 \
  -keystore /opt/zookeeper/conf/keystore.jks \
  -alias zookeeper -dname "CN=localhost" \
  -storepass your_password -keypass your_password

# 导出证书
keytool -exportcert -keystore keystore.jks \
  -alias zookeeper -file zookeeper.cer

# 导入truststore
keytool -importcert -keystore truststore.jks \
  -alias zookeeper -file zookeeper.cer
```

### 9.5 网络安全配置


**防火墙规则**：

```bash
# 只允许特定IP访问
iptables -A INPUT -p tcp --dport 2181 -s 192.168.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 2181 -j DROP

# 集群内部通信端口
iptables -A INPUT -p tcp --dport 2888 -s 192.168.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 3888 -s 192.168.1.0/24 -j ACCEPT
```

**禁用四字命令（可选）**：

```properties
# 关闭四字命令（生产环境建议）
4lw.commands.whitelist=

# 或只开启安全命令
4lw.commands.whitelist=stat,ruok
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心知识


```
🔸 部署模式选择：
   - 开发测试：单机模式
   - 生产环境：3/5节点集群
   - 节点数：必须是奇数

🔸 配置文件理解：
   - zoo.cfg：核心配置
   - myid：节点标识
   - log4j.properties：日志配置

🔸 关键参数：
   - tickTime：基准时间
   - initLimit/syncLimit：超时控制
   - dataDir/dataLogDir：存储路径

🔸 JVM调优：
   - 堆内存：2-8GB
   - 使用G1GC
   - 开启GC日志

🔸 监控维护：
   - 四字命令监控
   - JMX指标采集
   - 定期日志清理

🔸 安全加固：
   - ACL权限控制
   - SASL认证
   - SSL加密传输
```

### 10.2 部署检查清单


**部署前检查**：
```
□ 服务器时间同步（NTP）
□ 网络互通测试
□ 端口开放确认（2181/2888/3888）
□ 磁盘空间充足（>50GB）
□ JDK版本正确（>= 1.8）
```

**部署中检查**：
```
□ zoo.cfg配置一致
□ myid文件内容正确
□ 数据目录权限正确
□ 日志目录可写
□ JVM参数合理
```

**部署后验证**：
```
□ 集群状态正常（zkServer.sh status）
□ Leader选举成功
□ 数据同步正常
□ 客户端可连接
□ 监控指标正常
```

### 10.3 常见问题处理


**问题1：节点启动失败**
```
检查步骤：
1. 查看日志：tail -f zookeeper.out
2. 检查端口：netstat -nltp | grep java
3. 验证myid：cat /data/zookeeper/data/myid
4. 检查配置：vim zoo.cfg
```

**问题2：无法选举Leader**
```
可能原因：
- 时间不同步 → ntpdate同步时间
- 网络不通   → ping测试
- 配置不一致 → 对比zoo.cfg
- myid重复   → 检查所有节点myid
```

**问题3：性能问题**
```
排查方向：
- GC频繁     → 查看GC日志，调整堆内存
- 磁盘慢     → iostat检查，使用SSD
- 网络延迟   → 调大syncLimit
- 连接数多   → 增加maxClientCnxns
```

### 10.4 最佳实践建议


```
✅ 部署建议：
   - 使用独立服务器部署Zookeeper
   - dataLogDir使用独立磁盘
   - 优先使用SSD存储
   - 配置自动清理策略

✅ 运维建议：
   - 定期备份数据目录
   - 监控磁盘使用率
   - 关注GC日志
   - 设置告警阈值

✅ 安全建议：
   - 启用ACL权限控制
   - 使用SASL认证
   - 限制网络访问
   - 定期更新版本

✅ 性能优化：
   - 合理设置JVM参数
   - 使用G1GC收集器
   - 配置合适的超时时间
   - 监控并调优慢查询
```

**核心记忆口诀**：
```
集群节点必奇数，配置文件要统一
myid标识不能错，数据日志要分离
JVM调优很重要，监控日志不可少
安全加固记心中，稳定运行才长久
```