---
title: 3、Zookeeper核心概念原理
---
## 📚 目录


1. [ZNode节点概念](#1-ZNode节点概念)
2. [节点类型详解](#2-节点类型详解)
3. [Watcher监听机制](#3-Watcher监听机制)
4. [ZAB一致性协议](#4-ZAB一致性协议)
5. [ACL权限控制](#5-ACL权限控制)
6. [会话Session管理](#6-会话Session管理)
7. [核心要点总结](#7-核心要点总结)

---

# 1. 🌳 ZNode节点概念



## 1.1 什么是ZNode



**通俗理解**：ZNode就像文件系统中的文件和目录，但它更智能

```
把Zookeeper想象成一个特殊的文件系统：
- 普通文件系统：只能存储文件
- Zookeeper：既能存储数据，还能监控变化

例如：
/services                    ← 这是一个ZNode（类似目录）
  /user-service             ← 子ZNode
    /instance-1            ← 存储服务实例信息
    /instance-2
  /order-service
    /instance-1
```

**核心特点**：
- 📁 **树形结构**：和文件系统类似，用`/`分隔路径
- 💾 **能存数据**：每个节点都能存储少量数据（一般不超过1MB）
- 👀 **可被监听**：节点变化时可以通知客户端
- 🔄 **有生命周期**：节点可以是临时的或持久的

## 1.2 ZNode的数据结构



```
每个ZNode包含以下信息：

┌─────────────────────────────┐
│  ZNode                      │
├─────────────────────────────┤
│  data: 存储的实际数据        │
│  children: 子节点列表        │
│  stat: 节点状态信息          │
│    - version: 数据版本号     │
│    - cversion: 子节点版本    │
│    - aversion: ACL版本       │
│    - ctime: 创建时间         │
│    - mtime: 修改时间         │
│    - dataLength: 数据长度    │
│    - numChildren: 子节点数   │
└─────────────────────────────┘
```

**实际应用示例**：
```java
// 服务注册时创建ZNode
String servicePath = "/services/user-service/instance-1";
String serviceData = "192.168.1.100:8080"; // IP和端口信息

// 创建节点存储服务地址
zookeeper.create(servicePath, serviceData.getBytes(), 
                 ZooDefs.Ids.OPEN_ACL_UNSAFE, 
                 CreateMode.EPHEMERAL);
```

---

# 2. 📂 节点类型详解



## 2.1 持久节点（Persistent）



**通俗理解**：持久节点就像硬盘上的文件，断电也不会丢失

**特点**：
- ✅ **永久存在**：创建后一直保留，除非手动删除
- ✅ **数据持久化**：重启Zookeeper后依然存在
- ✅ **适用场景**：存储配置信息、服务列表等长期数据

**应用场景**：
```
配置管理示例：
/config
  /database
    /mysql-config  → 存储MySQL配置（持久节点）
    /redis-config  → 存储Redis配置（持久节点）
  /application
    /timeout      → 存储超时配置
    /retry-times  → 存储重试次数
```

**代码示例**：
```java
// 创建持久节点存储配置
String configPath = "/config/database/mysql-config";
String configData = "{\"host\":\"localhost\",\"port\":3306}";

zookeeper.create(configPath, configData.getBytes(),
                 ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.PERSISTENT);  // 持久节点
```

## 2.2 临时节点（Ephemeral）



**通俗理解**：临时节点像便利贴，写完贴上，人走就自动消失

**特点**：
- ⏳ **生命周期短**：客户端断开连接后自动删除
- 🔗 **绑定会话**：与创建它的客户端会话绑定
- 🚫 **不能有子节点**：临时节点不允许创建子节点
- ✅ **适用场景**：服务注册、分布式锁、集群成员管理

**工作原理图**：
```
客户端A连接                    客户端A断开
    ↓                              ↓
创建临时节点                   临时节点自动删除
/services/user-service    →    节点消失
```

**微服务注册示例**：
```java
// 服务启动时注册临时节点
public void registerService(String serviceName, String address) {
    String path = "/services/" + serviceName + "/" + address;
    
    // 创建临时节点
    zookeeper.create(path, address.getBytes(),
                     ZooDefs.Ids.OPEN_ACL_UNSAFE,
                     CreateMode.EPHEMERAL);  // 临时节点
    
    // 服务下线时，临时节点自动删除，其他服务能感知到
}
```

**为什么用临时节点做服务注册？**
```
传统方式的问题：
服务挂了 → 注册信息还在 → 其他服务调用失败 → 需要手动清理

使用临时节点：
服务挂了 → 连接断开 → 临时节点自动删除 → 其他服务自动感知
```

## 2.3 持久顺序节点（Persistent Sequential）



**通俗理解**：像排队取号机，每个号码自动递增且永久保存

**特点**：
- 🔢 **自动编号**：Zookeeper自动在节点名后加序号
- ✅ **永久保存**：序号递增且不会重复
- 📊 **有序性**：创建顺序可追溯

**应用示例**：
```
分布式队列实现：
/queue
  /task-0000000001  → 第一个任务
  /task-0000000002  → 第二个任务
  /task-0000000003  → 第三个任务
  
Zookeeper自动保证序号递增且唯一
```

```java
// 创建任务队列
String taskPath = "/queue/task-";
String taskData = "{\"taskId\":\"123\",\"type\":\"email\"}";

// 创建持久顺序节点，Zookeeper自动加序号
String createdPath = zookeeper.create(taskPath, 
                                      taskData.getBytes(),
                                      ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                      CreateMode.PERSISTENT_SEQUENTIAL);

// 返回：/queue/task-0000000001
```

## 2.4 临时顺序节点（Ephemeral Sequential）



**通俗理解**：临时排队号，用完就作废

**特点**：
- 🔢 **自动编号** + ⏳ **会话绑定**
- ✅ **适用场景**：分布式锁、选举算法

**分布式锁实现原理**：
```
步骤1：多个客户端竞争锁
客户端A创建：/lock/lock-0000000001
客户端B创建：/lock/lock-0000000002
客户端C创建：/lock/lock-0000000003

步骤2：序号最小的获得锁
0000000001 最小 → 客户端A获得锁

步骤3：其他客户端等待
客户端B监听 0000000001
客户端C监听 0000000002

步骤4：释放锁
客户端A完成任务删除节点
→ 客户端B获得锁
→ 客户端C继续等待
```

**代码示例**：
```java
// 获取分布式锁
public void acquireLock() throws Exception {
    // 1. 创建临时顺序节点
    String lockPath = zookeeper.create("/lock/lock-",
                                       null,
                                       ZooDefs.Ids.OPEN_ACL_UNSAFE,
                                       CreateMode.EPHEMERAL_SEQUENTIAL);
    
    // 2. 获取所有子节点
    List<String> children = zookeeper.getChildren("/lock", false);
    Collections.sort(children);
    
    // 3. 判断是否是最小节点
    if (lockPath.endsWith(children.get(0))) {
        // 获得锁
        System.out.println("获得锁");
    } else {
        // 等待前一个节点删除
        watchPreviousNode(lockPath, children);
    }
}
```

## 2.5 节点类型对比



| 节点类型 | **生命周期** | **编号** | **子节点** | **典型应用** |
|---------|------------|----------|-----------|-------------|
| **持久节点** | 永久存在 | 无 | ✅ 允许 | 配置管理、服务目录 |
| **临时节点** | 会话结束删除 | 无 | ❌ 不允许 | 服务注册、心跳检测 |
| **持久顺序节点** | 永久存在 | ✅ 自动编号 | ✅ 允许 | 分布式队列、任务编排 |
| **临时顺序节点** | 会话结束删除 | ✅ 自动编号 | ❌ 不允许 | 分布式锁、Leader选举 |

---

# 3. 👀 Watcher监听机制



## 3.1 什么是Watcher



**通俗理解**：Watcher就像订阅通知，节点有变化时自动提醒你

```
现实类比：
- 订阅微信公众号 → 有新文章就推送通知
- 设置Watcher → 节点变化就收到通知

微服务应用：
服务消费者 → 监听服务提供者节点
提供者下线 → 节点删除 → 消费者收到通知 → 更新服务列表
```

## 3.2 Watcher工作原理



**核心机制**：
- 📢 **一次性触发**：Watcher触发后就失效，需要重新设置
- ⚡ **异步通知**：不阻塞主流程
- 🎯 **事件类型**：节点创建、删除、数据变更、子节点变化

**工作流程图**：
```
客户端                          Zookeeper服务器
  |                                  |
  |-- [1] 设置Watcher监听 ---------->|
  |    getData("/services", true)    |
  |                                  |
  |<-- [2] 返回数据 ------------------|
  |                                  |
  |                                  | [3] 节点数据变化
  |                                  |
  |<-- [4] 发送变化通知 --------------|
  |    Event: NodeDataChanged        |
  |                                  |
  |-- [5] 重新设置Watcher ----------->|  ← 一次性触发！
```

## 3.3 Watcher事件类型



**常见事件类型**：

| 事件类型 | **触发条件** | **应用场景** |
|---------|------------|-------------|
| `NodeCreated` | 节点被创建 | 新服务注册通知 |
| `NodeDeleted` | 节点被删除 | 服务下线通知 |
| `NodeDataChanged` | 节点数据改变 | 配置更新通知 |
| `NodeChildrenChanged` | 子节点变化 | 服务列表变化 |

## 3.4 实际应用示例



**服务发现场景**：
```java
// 服务消费者监听服务提供者
public class ServiceDiscovery {
    
    // 监听服务列表变化
    public void watchServiceList(String serviceName) throws Exception {
        String path = "/services/" + serviceName;
        
        // 设置Watcher监听子节点变化
        List<String> children = zookeeper.getChildren(path, event -> {
            // 收到变化通知
            if (event.getType() == Watcher.Event.EventType.NodeChildrenChanged) {
                System.out.println("服务列表发生变化！");
                
                // 重新获取服务列表并设置监听
                try {
                    watchServiceList(serviceName);  // 重新监听
                    updateServiceList(serviceName); // 更新本地缓存
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
        
        // 使用获取的服务列表
        System.out.println("当前服务实例：" + children);
    }
}
```

**配置动态更新场景**：
```java
// 监听配置变化
public void watchConfig(String configPath) throws Exception {
    
    // 获取配置数据并设置监听
    byte[] data = zookeeper.getData(configPath, event -> {
        // 配置变化通知
        if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {
            System.out.println("配置已更新！");
            
            try {
                watchConfig(configPath);     // 重新监听
                reloadConfig(configPath);    // 重新加载配置
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }, null);
    
    // 解析配置
    String config = new String(data);
    System.out.println("当前配置：" + config);
}
```

## 3.5 Watcher注意事项



> **⚠️ 重要提醒：一次性触发特性**
> 
> Watcher是一次性的！触发后需要重新设置监听

```
错误做法：
设置一次Watcher → 触发通知 → 不再重新设置 → 后续变化收不到通知

正确做法：
设置Watcher → 触发通知 → 处理事件 → 立即重新设置Watcher
```

> **💡 性能优化建议**
> 
> - 避免频繁设置大量Watcher
> - 合理使用批量监听
> - 考虑使用本地缓存减少监听压力

---

# 4. 🔄 ZAB一致性协议



## 4.1 为什么需要ZAB协议



**问题背景**：Zookeeper是集群部署的，如何保证数据一致？

```
现实问题类比：
三个人同时编辑同一份文档
- 人A改了标题
- 人B改了内容  
- 人C改了格式
如何保证最终大家看到的是一致的？

Zookeeper的解决方案：
使用ZAB协议保证所有节点数据一致
```

## 4.2 ZAB协议核心概念



**ZAB（Zookeeper Atomic Broadcast）**：Zookeeper原子广播协议

**核心思想**：
- 👑 **Leader-Follower模式**：一个Leader，多个Follower
- 📝 **事务有序性**：所有写操作转发给Leader统一处理
- ✅ **过半确认机制**：超过半数节点确认才算成功

**集群角色**：
```
Zookeeper集群角色划分：

┌─────────────────────────────────────┐
│  Leader（领导者）                    │
│  - 处理所有写请求                    │
│  - 协调事务提交                      │
│  - 只有一个Leader                    │
└─────────────────────────────────────┘
              ↓ 同步数据
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  Follower1   │  │  Follower2   │  │  Follower3   │
│  - 处理读请求│  │  - 处理读请求│  │  - 处理读请求│
│  - 转发写请求│  │  - 转发写请求│  │  - 转发写请求│
│  - 参与投票  │  │  - 参与投票  │  │  - 参与投票  │
└──────────────┘  └──────────────┘  └──────────────┘
```

## 4.3 ZAB协议工作流程



**写请求处理流程**：
```
步骤1：客户端发起写请求
客户端 → Follower2：创建节点/services/user-service

步骤2：转发给Leader
Follower2 → Leader：转发写请求

步骤3：Leader广播提案
Leader → 所有Follower：Proposal（提案）

步骤4：Follower投票确认
Follower1 → Leader：ACK（确认）
Follower2 → Leader：ACK（确认）
Follower3 → Leader：ACK（确认）

步骤5：Leader提交事务
Leader检测到过半确认（3/5）→ 发送Commit命令

步骤6：所有节点提交
所有Follower执行事务 → 数据同步完成
```

**图示说明**：
```
客户端                 Follower2              Leader              其他Follower
  |                       |                     |                      |
  |--[1]写请求------------>|                     |                      |
  |   create /node        |                     |                      |
  |                       |                     |                      |
  |                       |--[2]转发请求-------->|                      |
  |                       |                     |                      |
  |                       |                     |--[3]发送提案--------->|
  |                       |<-[4]提案确认---------|<--[4]提案确认--------|
  |                       |                     |                      |
  |                       |                     | [5]检测过半确认       |
  |                       |                     |                      |
  |                       |<-[6]提交命令---------|--[6]提交命令-------->|
  |                       |                     |                      |
  |<--[7]返回成功----------|                     |                      |
```

## 4.4 Leader选举过程



**什么时候选举Leader？**
- ⚡ 集群启动时
- ❌ Leader宕机时
- 🔄 Leader失去过半Follower连接时

**选举规则**（简化版）：
```
比较标准（按优先级）：
1. epoch（选举轮次）更大的胜出
2. zxid（事务ID）更大的胜出  
3. myid（服务器ID）更大的胜出

示例：
Server1: epoch=2, zxid=100, myid=1
Server2: epoch=2, zxid=105, myid=2
Server3: epoch=2, zxid=105, myid=3

选举结果：Server3当选（zxid相同看myid）
```

## 4.5 ZAB协议保证



**一致性保证**：
- ✅ **顺序一致性**：客户端更新顺序与应用顺序一致
- ✅ **原子性**：更新要么成功要么失败，不会部分成功
- ✅ **单一视图**：客户端看到的数据视图一致
- ✅ **可靠性**：更新一旦成功，除非被覆盖，否则持久保存
- ✅ **实时性**：保证客户端在一定时间内获得最新数据

---

# 5. 🔒 ACL权限控制



## 5.1 什么是ACL



**通俗理解**：ACL就像门禁系统，控制谁能访问哪些节点

```
现实类比：
公司门禁卡：
- 普通员工：只能进办公区
- 技术人员：能进办公区+机房
- 管理员：所有区域

Zookeeper ACL：
- 不同客户端有不同权限
- 精细控制节点访问
```

## 5.2 ACL组成部分



**ACL由三部分组成**：

```
ACL = Scheme(权限模式) + ID(用户) + Permission(权限)

示例：
digest:user:password:cdrwa
  ↑       ↑        ↑
模式    用户    权限列表
```

**权限模式（Scheme）**：

| 模式 | **说明** | **应用场景** |
|------|---------|-------------|
| `world` | 所有人都能访问 | 公开数据 |
| `auth` | 已认证用户访问 | 需要登录的场景 |
| `digest` | 用户名密码验证 | 常用权限控制 |
| `ip` | IP地址控制 | 限制特定IP访问 |

**权限类型（Permission）**：

| 权限 | **简写** | **说明** |
|------|---------|---------|
| CREATE | c | 创建子节点 |
| DELETE | d | 删除子节点 |
| READ | r | 读取节点数据 |
| WRITE | w | 写入节点数据 |
| ADMIN | a | 设置节点ACL |

## 5.3 ACL实际应用



**场景1：公开配置（所有人可读）**
```java
// 创建公开可读的配置节点
String configPath = "/config/public/app-name";
String configData = "MyApplication";

List<ACL> acls = ZooDefs.Ids.OPEN_ACL_UNSAFE;  // world:anyone:cdrwa

zookeeper.create(configPath, configData.getBytes(), 
                 acls, CreateMode.PERSISTENT);
```

**场景2：管理员专用节点**
```java
// 创建需要密码认证的节点
String adminPath = "/admin/sensitive-config";
String adminData = "secret-value";

// 添加认证信息
zookeeper.addAuthInfo("digest", "admin:admin123".getBytes());

// 设置digest权限
List<ACL> acls = new ArrayList<>();
ACL acl = new ACL(ZooDefs.Perms.ALL,  // 所有权限
                  new Id("digest", 
                         DigestAuthenticationProvider.generateDigest("admin:admin123")));
acls.add(acl);

zookeeper.create(adminPath, adminData.getBytes(), 
                 acls, CreateMode.PERSISTENT);
```

**场景3：IP限制访问**
```java
// 只允许特定IP访问
List<ACL> acls = new ArrayList<>();
ACL acl = new ACL(ZooDefs.Perms.ALL,
                  new Id("ip", "192.168.1.100"));  // 只允许这个IP
acls.add(acl);

zookeeper.create("/secure-node", data, acls, CreateMode.PERSISTENT);
```

## 5.4 ACL使用建议



> **🔐 安全实践**
> 
> - 生产环境避免使用`OPEN_ACL_UNSAFE`
> - 敏感配置使用`digest`模式加密
> - 定期轮换密码
> - 使用IP白名单限制访问

> **⚠️ 常见错误**
> 
> ```
> 错误：没有添加认证就访问受保护节点
> 结果：KeeperException.NoAuthException
> 
> 解决：先调用addAuthInfo()添加认证
> ```

---

# 6. 🔗 会话Session管理



## 6.1 什么是Session



**通俗理解**：Session就像你和Zookeeper的通话连接

```
现实类比：
打电话给客服：
- 接通 = 建立Session
- 通话中 = Session活跃  
- 挂断 = Session关闭
- 超时未说话 = Session超时

Zookeeper Session：
客户端连接Zk → 创建Session → 保持心跳 → 超时断开
```

## 6.2 Session生命周期



**Session状态转换**：
```
CONNECTING（连接中）
    ↓
CONNECTED（已连接）
    ↓
CLOSED（已关闭）
    ↓
NOT_CONNECTED（未连接）
```

**Session超时机制**：
```
客户端                              Zookeeper
  |                                    |
  |-- [1] 创建连接（sessionTimeout）--->|
  |                                    |
  |<-- [2] 返回sessionId ---------------|
  |                                    |
  |-- [3] 发送心跳（ping）------------->|
  |<-- [4] 心跳响应（pong）--------------|
  |                                    |
  |    ... 定期心跳 ...                |
  |                                    |
  |    ❌ 网络中断，停止心跳             |
  |                                    |
  |                                    | [5] 超时检测
  |                                    | sessionTimeout到期
  |                                    | 
  |                                    | [6] 删除临时节点
  |                                    | 触发Watcher通知
```

## 6.3 Session参数配置



**核心参数**：

| 参数 | **说明** | **默认值** | **建议值** |
|------|---------|-----------|-----------|
| `sessionTimeout` | 会话超时时间 | 40秒 | 根据业务调整 |
| `tickTime` | 心跳间隔 | 2秒 | 通常不修改 |
| `minSessionTimeout` | 最小超时 | 2×tickTime | 服务端配置 |
| `maxSessionTimeout` | 最大超时 | 20×tickTime | 服务端配置 |

**配置示例**：
```java
// 创建Zookeeper客户端时设置Session参数
ZooKeeper zk = new ZooKeeper(
    "localhost:2181",           // 服务器地址
    30000,                      // sessionTimeout：30秒
    new Watcher() {
        @Override
        public void process(WatchedEvent event) {
            if (event.getState() == Event.KeeperState.Expired) {
                System.out.println("Session过期！");
                // 重新创建连接
                reconnect();
            }
        }
    }
);
```

## 6.4 Session异常处理



**常见Session异常**：

**1. Session超时（SessionExpired）**
```java
// 处理Session过期
public void handleSessionExpired() {
    System.out.println("Session已过期，重新连接...");
    
    // 关闭旧连接
    if (zookeeper != null) {
        zookeeper.close();
    }
    
    // 创建新连接（新的sessionId）
    zookeeper = new ZooKeeper(connectString, sessionTimeout, watcher);
    
    // 重新注册临时节点
    reregisterEphemeralNodes();
    
    // 重新设置Watcher
    resetWatchers();
}
```

**2. 连接丢失（ConnectionLoss）**
```java
// 处理连接丢失（Session还有效，只是暂时断开）
public void handleConnectionLoss() {
    System.out.println("连接丢失，等待重连...");
    
    // Zookeeper客户端会自动重连
    // 无需手动处理，Session在超时前会自动恢复
}
```

**3. Session移动（SessionMoved）**
```
场景：客户端使用旧sessionId连接到新服务器

原因：
- Zookeeper集群节点变化
- 客户端连接切换到其他服务器
- 旧sessionId不再有效

处理：重新建立连接
```

## 6.5 Session最佳实践



> **💡 实践建议**
> 
> **1. 合理设置超时时间**
> ```
> 网络稳定：sessionTimeout = 15-30秒
> 网络不稳定：sessionTimeout = 30-60秒
> 
> 原则：
> - 太短：频繁超时重连
> - 太长：故障检测不及时
> ```

> **2. 监听Session事件**
> ```java
> // 监听Session状态变化
> if (event.getState() == Event.KeeperState.Expired) {
>     // Session过期，重新创建
> } else if (event.getState() == Event.KeeperState.Disconnected) {
>     // 连接断开，等待自动重连
> } else if (event.getState() == Event.KeeperState.SyncConnected) {
>     // 连接成功
> }
> ```

> **3. 临时节点重建机制**
> ```
> Session过期后：
> 1. 旧的临时节点全部被删除
> 2. 需要重新创建临时节点
> 3. 需要重新设置Watcher监听
> ```

---

# 7. 📋 核心要点总结



## 7.1 知识要点回顾



**ZNode节点**：
- 📁 树形结构的数据存储单元
- 💾 每个节点可存储少量数据（<1MB）
- 🔄 支持监听机制，变化时通知客户端

**节点类型**：
- **持久节点**：永久存在，用于配置管理
- **临时节点**：会话结束自动删除，用于服务注册
- **顺序节点**：自动编号，用于分布式锁和队列

**Watcher机制**：
- 👀 一次性触发，需要重新设置
- ⚡ 异步通知，不阻塞主流程
- 🎯 监听节点创建、删除、数据变化、子节点变化

**ZAB协议**：
- 👑 Leader-Follower架构
- ✅ 过半确认机制保证一致性
- 🔄 自动选举Leader

**ACL权限**：
- 🔐 控制节点访问权限
- 🎯 支持多种认证模式（world/auth/digest/ip）
- ✅ 细粒度权限控制（cdrwa）

**Session会话**：
- 🔗 客户端与Zookeeper的连接
- ⏱️ 超时机制保证节点实时性
- 🔄 支持自动重连和故障恢复

## 7.2 实际应用场景



**服务注册与发现**：
```
服务提供者：创建临时节点注册服务
服务消费者：监听节点变化获取服务列表
服务下线：临时节点自动删除，消费者感知
```

**配置管理**：
```
配置中心：持久节点存储配置
应用服务：监听配置节点变化
配置更新：Watcher通知应用重新加载
```

**分布式锁**：
```
获取锁：创建临时顺序节点
判断：序号最小的获得锁
等待：监听前一个节点删除
释放：删除自己的节点
```

**Master选举**：
```
候选者：创建临时顺序节点
选举：最小序号成为Master
切换：Master宕机，次小序号顶上
```

## 7.3 关键记忆点



**节点类型选择**：
```
持久 → 配置、目录
临时 → 注册、心跳
顺序 → 锁、队列、选举
```

**Watcher特性**：
```
一次性 → 触发后重新设置
异步性 → 不阻塞主流程
事件性 → 只通知变化，不返回数据
```

**ZAB保证**：
```
写请求 → 转发Leader → 提案投票 → 过半提交
一致性 → Leader协调 → 数据同步 → 顺序保证
```

**Session管理**：
```
创建连接 → 定期心跳 → 超时检测 → 临时节点删除
Session过期 → 重建连接 → 重建节点 → 重设监听
```

---

**🎯 学习建议**：
1. 先理解ZNode和节点类型，这是基础
2. 重点掌握Watcher机制，这是核心功能
3. 理解ZAB协议保证一致性的原理
4. 实践中总结Session管理经验
5. 结合实际场景加深理解