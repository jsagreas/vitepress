---
title: 5、Eureka运行机制与原理
---
## 📚 目录

1. [服务注册流程](#1-服务注册流程)
2. [服务发现流程](#2-服务发现流程)
3. [心跳续约机制](#3-心跳续约机制)
4. [服务注册表同步](#4-服务注册表同步)
5. [自我保护模式](#5-自我保护模式)
6. [网络分区处理](#6-网络分区处理)
7. [服务剔除策略](#7-服务剔除策略)
8. [缓存更新机制](#8-缓存更新机制)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 服务注册流程


### 1.1 什么是服务注册


**通俗理解**：服务注册就像新员工入职报到一样。

```
现实场景类比：
新员工入职 → 填写个人信息 → 人事部登记 → 分配工位和工号

微服务注册 → 发送服务信息 → Eureka登记 → 获得服务ID和位置
```

**核心概念**：
- **服务提供者**：提供具体功能的微服务（比如订单服务、用户服务）
- **注册中心**：Eureka Server，负责管理所有服务的"花名册"
- **注册信息**：服务名称、IP地址、端口号、健康状态等

### 1.2 注册流程步骤详解


```
完整注册流程：
                                    
服务启动                             Eureka Server
   |                                     |
   |--[1] 读取配置信息----------------->  |
   |    (服务名、端口等)                   |
   |                                     |
   |--[2] 发送注册请求----------------->  |
   |    POST /eureka/apps/{appName}     |
   |                                     |
   |                                  [3] 验证信息
   |                                     |
   |                                  [4] 存入注册表
   |                                     |
   |<--[5] 返回注册成功------------------|
   |    响应状态码: 204                   |
   |                                     |
   |--[6] 开始定时心跳----------------->  |
   |    (默认30秒一次)                    |
```

**🔸 步骤1：读取配置**
服务启动时，首先读取配置文件中的信息：

```yaml
# application.yml 配置示例
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # Eureka地址
  instance:
    instance-id: order-service-8080  # 实例标识
    prefer-ip-address: true          # 使用IP地址注册
    
spring:
  application:
    name: order-service  # 服务名称
```

**🔸 步骤2：发送注册请求**
服务将自己的信息打包发送给Eureka：

| 注册信息字段 | 含义说明 | 示例值 |
|------------|---------|--------|
| `appName` | 服务名称 | `order-service` |
| `ipAddr` | IP地址 | `192.168.1.100` |
| `port` | 端口号 | `8080` |
| `status` | 服务状态 | `UP`（运行中） |
| `homePageUrl` | 主页地址 | `http://192.168.1.100:8080/` |
| `healthCheckUrl` | 健康检查地址 | `http://192.168.1.100:8080/actuator/health` |

**🔸 步骤3-4：Eureka处理注册**
```
Eureka Server内部处理：
┌────────────────────────────┐
│  1. 接收注册请求            │
│  2. 验证服务信息格式         │
│  3. 检查是否已存在同名服务    │
│  4. 保存到服务注册表         │
│  5. 触发注册表同步（集群模式）│
└────────────────────────────┘
```

**🔸 步骤5-6：确认注册并启动心跳**
- 注册成功后返回 `204 No Content` 状态码
- 服务开始每30秒发送一次心跳，告诉Eureka："我还活着"

### 1.3 注册失败的处理


**常见失败原因**：

```
❌ 情况1：网络不通
原因：服务无法连接到Eureka Server
表现：启动时抛出连接异常
解决：检查Eureka地址配置、网络连通性

❌ 情况2：配置错误
原因：服务名为空或格式不正确
表现：注册被拒绝，返回400错误
解决：检查配置文件中的spring.application.name

❌ 情况3：端口冲突
原因：配置的端口已被占用
表现：服务启动失败
解决：修改端口配置或释放端口
```

**重试机制**：
- Eureka客户端会自动重试注册
- 默认重试间隔：30秒
- 可通过配置调整重试策略

---

## 2. 🔍 服务发现流程


### 2.1 什么是服务发现


**通俗理解**：服务发现就像查电话簿找人。

```
查电话簿：知道名字 → 翻电话簿 → 找到电话号码 → 打电话联系

服务发现：知道服务名 → 查询Eureka → 获取IP和端口 → 发起调用
```

### 2.2 发现流程详解


```
服务调用方                          Eureka Server
    |                                    |
    |--[1] 请求服务列表----------------->|
    |    GET /eureka/apps                |
    |                                    |
    |                                 [2] 读取注册表
    |                                    |
    |<--[3] 返回服务列表-----------------|
    |    {order-service: [...]}         |
    |                                    |
 [4] 本地缓存服务列表                     |
    |                                    |
 [5] 从列表中选择一个实例                 |
    |                                    |
 [6] 发起HTTP调用                        |
    |                                    |
```

**🔸 两种发现方式**：

| 方式 | 工作原理 | 优缺点 | 适用场景 |
|-----|---------|--------|---------|
| **主动拉取** | 客户端定期向Eureka请求服务列表 | ✅ 数据及时<br>❌ 请求频繁 | 服务变化快 |
| **本地缓存** | 客户端缓存服务列表到本地 | ✅ 响应快速<br>❌ 可能过期 | 服务稳定 |

**🔸 实际使用示例**：

```java
// 方式1：使用RestTemplate（自动集成Eureka）
@Autowired
private RestTemplate restTemplate;

public Order getOrder(Long id) {
    // 直接使用服务名调用，Eureka会自动解析
    String url = "http://order-service/api/orders/" + id;
    return restTemplate.getForObject(url, Order.class);
}

// 方式2：使用OpenFeign（声明式调用）
@FeignClient(name = "order-service")
public interface OrderClient {
    @GetMapping("/api/orders/{id}")
    Order getOrderById(@PathVariable Long id);
}
```

**背后发生了什么**：
1. 看到 `order-service` 这个服务名
2. 从本地缓存查找该服务的所有实例
3. 通过负载均衡算法选择一个实例
4. 将服务名替换为实际的 `IP:端口`
5. 发起真实的HTTP请求

### 2.3 服务实例选择策略


```
假设order-service有3个实例：
┌─────────────────────────┐
│ 实例1: 192.168.1.10:8080│
│ 实例2: 192.168.1.11:8080│  ← 如何选择？
│ 实例3: 192.168.1.12:8080│
└─────────────────────────┘
```

**常见负载均衡策略**：

- **轮询**：1→2→3→1→2→3（依次调用）
- **随机**：随机选择一个实例
- **最少连接**：选择当前连接数最少的实例
- **响应时间**：优先选择响应快的实例

> 💡 **默认策略**：Ribbon默认使用轮询策略

---

## 3. 💓 心跳续约机制


### 3.1 为什么需要心跳


**通俗理解**：心跳就像点名报到。

```
学校点名：老师每节课点名 → 学生答"到" → 确认学生在教室

服务心跳：Eureka定期检查 → 服务发心跳 → 确认服务还活着
```

**心跳的作用**：
- ✅ **健康检查**：确认服务是否正常运行
- ✅ **自动剔除**：长时间无心跳的服务会被移除
- ✅ **状态更新**：及时发现服务异常

### 3.2 心跳机制详解


```
服务实例                            Eureka Server
    |                                    |
    |===[每30秒发送心跳]================>|
    |    PUT /eureka/apps/{app}/{id}     |
    |    lastDirtyTimestamp: 当前时间     |
    |                                    |
    |                                [1] 更新最后心跳时间
    |                                    |
    |<--[2] 返回200 OK--------------------|
    |                                    |
    |    (如果90秒未收到心跳)              |
    |                                [3] 标记为DOWN
    |                                    |
    |    (如果持续无心跳)                  |
    |                                [4] 从注册表删除
```

**🔸 关键时间参数**：

| 参数 | 默认值 | 含义说明 |
|-----|-------|---------|
| **心跳间隔** | 30秒 | 服务多久发送一次心跳 |
| **续约期限** | 90秒 | Eureka多久没收到心跳就认为服务挂了 |
| **剔除间隔** | 60秒 | Eureka多久检查一次过期服务 |

**🔸 配置调整**：

```yaml
eureka:
  instance:
    lease-renewal-interval-in-seconds: 30    # 心跳间隔
    lease-expiration-duration-in-seconds: 90 # 续约期限
```

> ⚠️ **注意**：不建议将心跳间隔设置太短，会增加网络开销

### 3.3 心跳失败的处理


**场景1：网络抖动**
```
情况：短暂的网络波动导致心跳丢失
Eureka：不会立即剔除，等待90秒续约期
服务：继续发送心跳，一旦网络恢复就正常
```

**场景2：服务假死**
```
情况：服务进程还在，但已无法处理请求
表现：心跳正常，但实际调用失败
解决：结合健康检查端点综合判断
```

**场景3：服务崩溃**
```
情况：服务进程直接挂掉
表现：心跳停止
Eureka：90秒后标记DOWN，60秒后从注册表移除
```

---

## 4. 🔄 服务注册表同步


### 4.1 为什么需要同步


**单机问题**：
```
单个Eureka Server：
  ┌─────────┐
  │ Eureka  │ ← 如果这台机器挂了，所有服务都找不到彼此了
  └─────────┘
```

**集群解决方案**：
```
Eureka集群：
  ┌─────────┐     ┌─────────┐     ┌─────────┐
  │ Eureka1 │────→│ Eureka2 │────→│ Eureka3 │
  └─────────┘     └─────────┘     └─────────┘
       ↑                                ↓
       └────────────────────────────────┘
       
  任何一台挂了，其他的继续工作
```

### 4.2 同步机制详解


```
服务注册到Eureka1的过程：

服务A                  Eureka1               Eureka2               Eureka3
  |                      |                     |                     |
  |--[注册请求]--------->|                     |                     |
  |                      |                     |                     |
  |                   [1]保存到本地             |                     |
  |                      |                     |                     |
  |                      |--[同步]------------>|                     |
  |                      |                     |                     |
  |                      |--[同步]----------------------------->|
  |                      |                     |                     |
  |<--[注册成功]---------|                  [2]保存            [2]保存
  |                      |                     |                     |
```

**🔸 同步策略**：

**方式1：对等复制（Peer Replication）**
- 每个Eureka节点既是服务端，也是客户端
- 收到注册后，向其他所有节点同步
- 确保每个节点数据一致

**方式2：批量同步**
- 不是每次变更都立即同步
- 收集一段时间的变更，批量发送
- 减少网络开销，提高效率

**🔸 配置集群**：

```yaml
# Eureka1的配置
eureka:
  client:
    service-url:
      defaultZone: http://eureka2:8762/eureka/,http://eureka3:8763/eureka/

# Eureka2的配置
eureka:
  client:
    service-url:
      defaultZone: http://eureka1:8761/eureka/,http://eureka3:8763/eureka/
```

### 4.3 同步冲突处理


**场景：同一服务同时注册到不同节点**
```
时刻T1：服务A注册到Eureka1，状态=UP
时刻T2：服务A注册到Eureka2，状态=DOWN

Eureka1和Eureka2同步后，以谁的为准？
```

**解决方案：版本号机制**
- 每次修改，版本号+1
- 同步时比较版本号，保留版本高的
- 确保最新状态被保留

---

## 5. 🛡️ 自我保护模式


### 5.1 什么是自我保护


**通俗理解**：自我保护就像"宁可错杀，不可放过"的反向版本。

```
传统思路：心跳丢失 → 服务挂了 → 立即剔除

自我保护：大量心跳丢失 → 可能是网络问题 → 暂停剔除，保留服务
```

**为什么需要自我保护**：

```
场景：机房网络抖动
           
Eureka Server                    服务实例（都正常运行）
     |                           A  B  C  D  E
     |                           |  |  |  |  |
  [网络抖动]                      ×  ×  ×  ×  × (心跳全部丢失)
     |
  [没有自我保护]
     |
  → 把A、B、C、D、E全部剔除      (错误！服务其实都是好的)
  → 所有服务调用失败
  → 系统雪崩
```

### 5.2 触发条件


**计算公式**：
```
期望心跳数 = 注册服务数 × 2 × 0.85

举例：
- 有10个服务注册
- 每个服务每30秒发一次心跳，即每分钟2次
- 期望心跳数 = 10 × 2 × 0.85 = 17次/分钟

如果一分钟内收到的心跳 < 17次 → 触发自我保护
```

**触发后的表现**：
```
✅ 保留所有服务实例信息，不剔除
✅ 新服务仍可以注册
✅ 心跳仍会被接收
❌ 不再剔除过期服务
❌ Eureka界面显示红色警告
```

### 5.3 自我保护的利弊


| 优点 ✅ | 缺点 ❌ |
|--------|--------|
| 避免网络波动导致的误杀 | 保留了可能已失效的服务 |
| 提高系统可用性 | 调用失效服务会失败 |
| 适合大规模集群 | 需要客户端容错处理 |

**🔸 配置选择**：

```yaml
# 生产环境：建议开启
eureka:
  server:
    enable-self-preservation: true  # 开启自我保护

# 开发环境：可以关闭（快速发现问题）
eureka:
  server:
    enable-self-preservation: false  # 关闭自我保护
    eviction-interval-timer-in-ms: 5000  # 5秒清理一次
```

> 💡 **最佳实践**：生产环境开启自我保护 + 客户端重试机制

---

## 6. 🌐 网络分区处理


### 6.1 什么是网络分区


**通俗理解**：网络分区就像山体滑坡把村子分成了两半。

```
正常情况：
  Eureka1 ←→ Eureka2 ←→ Eureka3
     ↑         ↑         ↑
  服务A      服务B      服务C

网络分区：
  Eureka1 ←→ Eureka2    ✗    Eureka3
     ↑         ↑                ↑
  服务A      服务B            服务C
  
  Eureka3被隔离，但仍在运行
```

### 6.2 分区的影响


**场景分析**：
```
分区前：
- 服务A注册到Eureka1
- Eureka1同步到Eureka2、Eureka3
- 所有节点数据一致

分区后：
- 服务A更新信息到Eureka1
- Eureka1无法同步到Eureka3
- Eureka3的数据变旧了
```

**实际影响**：

| 影响方面 | 具体表现 |
|---------|---------|
| **数据一致性** | 分区两侧数据不一致 |
| **服务发现** | 可能获取到过期的服务信息 |
| **调用失败** | 调用已下线但未同步的服务 |

### 6.3 分区的处理策略


**策略1：AP模式（可用性优先）**
```
原则：宁可数据不一致，也要保证服务可用

Eureka的做法：
✅ 分区两侧继续独立工作
✅ 接受注册、发现请求
❌ 允许数据短暂不一致
✅ 分区恢复后自动同步
```

**策略2：客户端容错**
```java
// 重试配置
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}

// 使用Ribbon重试
ribbon:
  MaxAutoRetries: 1              # 同一实例重试次数
  MaxAutoRetriesNextServer: 2    # 换实例重试次数
  ReadTimeout: 3000              # 超时时间
```

**策略3：多数据中心部署**
```
跨地域部署：
           
北京机房          上海机房          深圳机房
Eureka1          Eureka2          Eureka3
   ↑                ↑                ↑
服务A              服务B            服务C

任何一个机房网络故障，其他机房继续服务
```

---

## 7. 🗑️ 服务剔除策略


### 7.1 什么是服务剔除


**通俗理解**：剔除就像清理过期食品。

```
超市管理：
定期检查 → 发现过期商品 → 下架处理

Eureka管理：
定期检查 → 发现失效服务 → 从注册表删除
```

### 7.2 剔除流程详解


```
Eureka Server定时任务（默认60秒执行一次）：

  [启动剔除任务]
       |
       ↓
  [遍历所有服务实例]
       |
       ↓
  [检查最后心跳时间]
       |
       ↓
  当前时间 - 最后心跳时间 > 90秒？
       |
       ├→ 是 → [标记为过期]
       |          |
       |          ↓
       |      [从注册表删除]
       |          |
       |          ↓
       |      [通知其他节点]
       |
       └→ 否 → [保留该实例]
```

**🔸 剔除条件判断**：

```java
// Eureka判断逻辑（简化版）
boolean shouldEvict(Instance instance) {
    long lastHeartbeat = instance.getLastHeartbeatTime();
    long now = System.currentTimeMillis();
    long duration = now - lastHeartbeat;
    
    // 90秒未心跳 且 未开启自我保护
    return duration > 90000 && !selfPreservationEnabled;
}
```

### 7.3 剔除策略配置


**默认策略**：
```yaml
eureka:
  server:
    eviction-interval-timer-in-ms: 60000  # 60秒检查一次
    
  instance:
    lease-expiration-duration-in-seconds: 90  # 90秒未心跳算过期
```

**自定义策略示例**：
```yaml
# 快速剔除（开发环境）
eureka:
  server:
    eviction-interval-timer-in-ms: 5000  # 5秒检查一次
    enable-self-preservation: false      # 关闭自我保护
    
  instance:
    lease-expiration-duration-in-seconds: 10  # 10秒未心跳算过期
```

**剔除的影响**：

```
服务被剔除后：
  
客户端                     Eureka Server
    |                           |
    |--[获取服务列表]--------->  |
    |                           |
    |<--[不包含被剔除的服务]-----|
    |                           |
    |--[调用该服务]--> ❌ 失败    |
          (找不到该服务)
```

> ⚠️ **注意**：客户端有缓存，剔除后需等待缓存更新才生效

---

## 8. 💾 缓存更新机制


### 8.1 为什么需要缓存


**性能问题**：
```
没有缓存：
服务调用 → 每次都查询Eureka → 网络开销大 → 响应慢

有缓存：
服务调用 → 查询本地缓存 → 直接获取 → 响应快
```

**Eureka的三级缓存架构**：

```
                    Eureka Server
                         |
        ┌────────────────┼────────────────┐
        |                |                |
    只读缓存        读写缓存          注册表
  (ResponseCache)  (ReadWriteCache)  (Registry)
        |                |                |
      每30秒           实时更新          实时更新
      从读写拉取          ↑                ↑
        |                |                |
        |            服务注册/心跳      服务下线
        ↓                |                |
    客户端获取           |                |
    服务列表             └────────┬───────┘
                                  |
                              后台任务
```

### 8.2 三级缓存详解


**🔸 第一层：注册表（Registry）**
- **存储内容**：所有服务的完整信息
- **更新时机**：服务注册、心跳、下线时实时更新
- **作用**：真实数据源，保证数据准确性

**🔸 第二层：读写缓存（ReadWriteCache）**
- **存储内容**：服务列表的序列化数据
- **更新时机**：
  - 注册表变化时主动更新
  - 180秒后自动过期
- **作用**：减少序列化开销

**🔸 第三层：只读缓存（ResponseCache）**
- **存储内容**：可直接返回给客户端的响应
- **更新时机**：每30秒从读写缓存同步
- **作用**：减少并发读取压力

### 8.3 缓存更新流程


**场景1：服务新注册**
```
时间轴：
T1: 服务注册 → 注册表立即更新
T2: 读写缓存立即更新
T3: 等待最多30秒 → 只读缓存更新
T4: 客户端获取到新服务信息

最大延迟：30秒
```

**场景2：服务下线**
```
时间轴：
T1: 服务下线 → 注册表立即删除
T2: 读写缓存立即失效
T3: 等待最多30秒 → 只读缓存更新
T4: 客户端发现服务已下线

最大延迟：30秒
```

**🔸 配置调整**：

```yaml
eureka:
  server:
    # 只读缓存更新间隔
    response-cache-update-interval-ms: 30000
    
    # 读写缓存过期时间
    response-cache-auto-expiration-in-seconds: 180
    
    # 是否使用只读缓存（关闭可减少延迟）
    use-read-only-response-cache: true
```

### 8.4 客户端缓存


**客户端也有缓存**：
```
客户端本地：
    |
    |--[每30秒拉取一次]-----→ Eureka Server
    |                            |
    |←--[返回服务列表]------------|
    |                            |
    |--[更新本地缓存]
    |
    |--[应用使用缓存数据]
```

**配置客户端缓存**：
```yaml
eureka:
  client:
    # 拉取服务列表间隔
    registry-fetch-interval-seconds: 30
    
    # 是否拉取服务列表
    fetch-registry: true
```

**数据最终一致性**：
```
服务下线 → 最多30秒Eureka缓存更新 → 最多30秒客户端拉取

最坏情况：60秒后才感知到服务变化
```

> 💡 **优化建议**：开发环境可缩短缓存时间，生产环境保持默认避免频繁更新

---

## 9. 📋 核心要点总结


### 9.1 关键流程回顾


**🔸 服务注册三步走**
```
1️⃣ 读取配置 → 准备服务信息
2️⃣ 发送注册请求 → Eureka保存到注册表
3️⃣ 开始心跳 → 维持注册状态
```

**🔸 服务发现流程**
```
1️⃣ 查询Eureka获取服务列表
2️⃣ 缓存到本地
3️⃣ 负载均衡选择实例
4️⃣ 发起调用
```

**🔸 心跳续约机制**
```
正常：每30秒心跳 → Eureka记录时间
异常：90秒无心跳 → 标记过期 → 60秒后剔除
保护：大量心跳丢失 → 触发自我保护 → 暂停剔除
```

### 9.2 核心参数速查表


| 参数 | 默认值 | 说明 | 调优建议 |
|-----|-------|------|---------|
| **心跳间隔** | 30秒 | 服务发送心跳频率 | 生产环境保持默认 |
| **续约期限** | 90秒 | 无心跳算失效 | 不建议低于60秒 |
| **剔除间隔** | 60秒 | 检查过期服务频率 | 开发环境可改为5秒 |
| **缓存更新** | 30秒 | 只读缓存同步 | 可改为10秒提高实时性 |
| **客户端拉取** | 30秒 | 获取服务列表频率 | 可改为10秒 |

### 9.3 常见问题处理


**❓ 问题1：服务注册了但调用失败**
```
排查步骤：
1. 检查Eureka界面是否显示该服务（UP状态）
2. 检查客户端缓存是否更新（等30秒或重启）
3. 检查IP和端口是否正确
4. 检查服务健康检查接口
```

**❓ 问题2：服务下线了但还在被调用**
```
原因：缓存延迟（最多60秒）
临时解决：重启调用方服务
根本解决：配合熔断降级（Hystrix）
```

**❓ 问题3：自我保护模式一直开启**
```
原因：心跳丢失率超过15%
检查：
1. 网络是否正常
2. 服务是否频繁重启
3. 心跳配置是否合理
```

### 9.4 最佳实践建议


**✨ 生产环境配置**
```yaml
eureka:
  server:
    enable-self-preservation: true          # 开启自我保护
    eviction-interval-timer-in-ms: 60000   # 60秒剔除
    
  instance:
    lease-renewal-interval-in-seconds: 30   # 30秒心跳
    lease-expiration-duration-in-seconds: 90 # 90秒过期
    prefer-ip-address: true                 # 使用IP注册
    
  client:
    registry-fetch-interval-seconds: 30     # 30秒拉取
```

**✨ 高可用部署**
```
1. 部署至少3个Eureka节点
2. 跨机房部署（容灾）
3. 配置健康检查
4. 监控注册表大小和心跳成功率
```

**🎯 核心记忆口诀**
```
注册发现两大流程，心跳续约保持连接
三级缓存提升性能，自我保护避免误杀
集群同步保证可用，剔除策略清理失效
配置合理最为关键，监控告警不可或缺
```