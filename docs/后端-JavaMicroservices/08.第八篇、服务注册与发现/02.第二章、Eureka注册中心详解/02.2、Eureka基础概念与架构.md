---
title: 2、Eureka基础概念与架构
---
## 📚 目录

1. [Eureka核心组件](#1-Eureka核心组件)
2. [服务注册表机制](#2-服务注册表机制)
3. [心跳续约与健康检查](#3-心跳续约与健康检查)
4. [自我保护模式](#4-自我保护模式)
5. [服务剔除机制](#5-服务剔除机制)
6. [区域感知功能](#6-区域感知功能)
7. [实例状态管理](#7-实例状态管理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏢 Eureka核心组件


### 1.1 什么是Eureka


**通俗理解**：想象一个大型购物中心的"服务台"

```
传统找人方式：          有了Eureka：
挨个店铺问      →      直接问服务台
效率低，麻烦            快速找到目标

微服务场景：
服务A想调用服务B  →  先问Eureka：服务B在哪？
                    →  Eureka告诉地址
                    →  直接通信
```

**核心定义**：
- Eureka是Netflix开发的服务注册与发现框架
- 解决微服务环境下"服务在哪里"的问题
- 让服务之间能够自动找到彼此

### 1.2 Eureka Server（注册中心）


**角色定位**：相当于"通讯录管理员"

```
核心职责：
📝 记录所有服务的地址信息
📞 提供服务查询功能
💓 监控服务健康状态
🔄 同步集群间的服务信息
```

**工作原理**：
```
            Eureka Server（注册中心）
                    |
    +---------------+---------------+
    |               |               |
服务提供者      服务消费者        其他Eureka节点
    |               |               |
  注册服务        查询服务        数据同步
```

**关键特性**：
- **集中管理**：所有服务信息存储在这里
- **高可用**：支持多个注册中心互相备份
- **自动更新**：服务上下线会实时反映

### 1.3 Eureka Client（客户端）


**角色定位**：服务的"通讯录使用者"

**两种身份**：

`[服务提供者]`（Provider）
```
职责：
✅ 启动时向Eureka注册自己
✅ 定期发送心跳保持在线
✅ 下线时注销注册信息

实际例子：
订单服务启动 → 告诉Eureka：
"我是订单服务，地址是192.168.1.100:8081，我提供下单功能"
```

`[服务消费者]`（Consumer）
```
职责：
✅ 从Eureka获取服务列表
✅ 本地缓存服务信息
✅ 定期刷新服务列表

实际例子：
用户服务需要调用订单服务 → 问Eureka：
"订单服务在哪？" → 得到地址列表 → 选一个调用
```

**基础配置示例**：
```yaml
# 最简单的Eureka客户端配置
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # 注册中心地址
  instance:
    prefer-ip-address: true  # 使用IP而不是主机名
```

---

## 2. 📋 服务注册表机制


### 2.1 什么是服务注册表（Registry）


**通俗理解**：就像一本"服务通讯录"

```
通讯录结构：
服务名称          IP地址              端口    状态
-----------------------------------------------
订单服务    →    192.168.1.100     8081    ✅在线
用户服务    →    192.168.1.101     8082    ✅在线
支付服务    →    192.168.1.102     8083    ❌离线
```

**核心概念**：
- **注册表**：存储所有服务实例信息的数据结构
- **服务实例**：一个运行中的服务副本
- **服务元数据**：描述服务的详细信息（IP、端口、健康状态等）

### 2.2 服务注册流程


**Step by Step过程**：

```
第1步：服务启动
订单服务启动 → 读取配置文件 → 准备注册信息

第2步：向Eureka发送注册请求
POST http://eureka-server:8761/eureka/apps/ORDER-SERVICE
{
  "instance": {
    "hostName": "192.168.1.100",
    "port": 8081,
    "appName": "ORDER-SERVICE"
  }
}

第3步：Eureka保存信息
Eureka Server → 更新注册表 → 记录服务信息

第4步：返回确认
Eureka → 订单服务："注册成功！"
```

**注册信息包含什么**：

| 信息类型 | **内容说明** | **示例** |
|---------|------------|---------|
| 🏷️ **服务名称** | `应用的标识名` | `ORDER-SERVICE` |
| 🌐 **IP地址** | `服务所在机器IP` | `192.168.1.100` |
| 🔌 **端口号** | `服务监听端口` | `8081` |
| 💓 **健康状态** | `服务是否正常` | `UP/DOWN` |
| 📍 **元数据** | `自定义扩展信息` | `版本号、区域` |

### 2.3 服务发现流程


**Step by Step过程**：

```
场景：用户服务要调用订单服务

第1步：查询Eureka
用户服务 → Eureka："订单服务在哪？"

第2步：返回服务列表
Eureka → 用户服务：
[
  {"host": "192.168.1.100", "port": 8081},
  {"host": "192.168.1.101", "port": 8081}  ← 可能有多个实例
]

第3步：本地缓存
用户服务 → 保存到本地缓存（30秒刷新一次）

第4步：负载均衡选择
用户服务 → 从列表中选一个 → 发起调用
```

**缓存机制说明**：
```
为什么要本地缓存？
✅ 提高性能：不用每次都问Eureka
✅ 容错能力：Eureka挂了也能用缓存
✅ 减轻压力：降低注册中心负载

⚠️ 注意：缓存会有延迟
服务下线 → 最多30秒后才能感知到
```

---

## 3. 💓 心跳续约与健康检查


### 3.1 什么是心跳机制


**生活类比**：就像考勤打卡

```
员工每天打卡      →     服务每30秒发心跳
证明自己在岗            证明自己还活着

超过3天不打卡    →     超过90秒没心跳
认为已离职              认为服务挂了
```

**工作原理**：
```
时间轴：
0s     30s    60s    90s    120s
|------|------|------|------|
 心跳1  心跳2  心跳3  心跳4  心跳5
          ↑
    每30秒发送一次心跳
```

### 3.2 心跳续约详细流程


**续约过程**：

```
[订单服务]每30秒执行：
1. 发送心跳请求
   PUT http://eureka:8761/eureka/apps/ORDER-SERVICE/instance-001

2. [Eureka Server]收到心跳
   ✅ 更新最后心跳时间
   ✅ 重置过期倒计时
   ✅ 返回确认

3. 续约成功
   订单服务继续保持在注册表中
```

**关键配置**：
```yaml
eureka:
  instance:
    lease-renewal-interval-in-seconds: 30  # 心跳间隔（默认30秒）
    lease-expiration-duration-in-seconds: 90  # 过期时间（默认90秒）
```

**时间参数理解**：
- **30秒**：服务主动汇报"我还活着"
- **90秒**：如果90秒没收到心跳，Eureka认为服务挂了
- **为什么是90秒**：给3次心跳的机会（30×3=90），避免误判

### 3.3 服务健康检查


**检查机制**：

`[基础检查]` - Eureka自带
```
判断依据：
✅ 心跳是否正常
✅ 网络是否连通

问题：只能判断服务是否"活着"，不能判断是否"健康"
```

`[增强检查]` - 整合Spring Boot Actuator
```
深度检查：
✅ 数据库连接是否正常
✅ Redis缓存是否可用
✅ 磁盘空间是否充足
✅ 内存使用是否正常
```

**健康检查配置**：
```yaml
eureka:
  client:
    healthcheck:
      enabled: true  # 启用健康检查

# Spring Boot健康检查端点
management:
  endpoints:
    web:
      exposure:
        include: health
```

---

## 4. 🛡️ 自我保护模式


### 4.1 什么是自我保护模式


**通俗理解**：Eureka的"容错机制"

```
正常情况：
服务挂了 → 没心跳 → Eureka删除服务 ✅

网络故障情况：
服务没挂 → 但网络断了 → 没心跳 → Eureka该删除吗？❓

自我保护：
如果大量服务同时没心跳 → 可能是网络问题 → 不删除！
```

**设计初衷**：
- 宁可保留错误的注册信息
- 也不能因为网络抖动删除正常服务
- CAP理论中选择了可用性（A）

### 4.2 触发条件详解


**触发公式**：
```
每分钟心跳数 < 总实例数 × 2 × 0.85
              ↓
        期望心跳数的85%

实际例子：
有10个服务实例
期望心跳数 = 10 × 2(每分钟2次) = 20次/分钟
触发阈值 = 20 × 0.85 = 17次/分钟
如果实际心跳 < 17次/分钟 → 进入自我保护
```

**触发场景**：
```
场景1：网络分区
机房A ←--X--→ 机房B
Eureka在A，服务在B
B的服务正常，但网络断了

场景2：服务大规模重启
10个服务同时重启
短时间内都没心跳

场景3：Eureka自身问题
CPU飙高，处理不过来
```

### 4.3 保护模式的影响


**正面影响**：
```
✅ 避免误删：网络问题时不会删除正常服务
✅ 提高可用性：保证服务列表的稳定性
✅ 自动恢复：网络恢复后自动退出保护模式
```

**负面影响**：
```
❌ 服务列表不准确：已下线的服务可能还在列表中
❌ 调用可能失败：客户端可能调用到已挂掉的实例
❌ 影响负载均衡：无法及时剔除问题节点
```

**配置说明**：
```yaml
eureka:
  server:
    enable-self-preservation: true  # 是否启用（生产环境建议开启）
    renewal-percent-threshold: 0.85  # 触发阈值（默认0.85）
```

**最佳实践建议**：

| 环境 | **建议配置** | **理由** |
|------|------------|---------|
| 🏠 **本地开发** | `关闭保护模式` | `方便测试服务上下线` |
| 🧪 **测试环境** | `关闭保护模式` | `及时发现问题` |
| 🏭 **生产环境** | `开启保护模式` | `保证高可用性` |

---

## 5. 🗑️ 服务剔除机制


### 5.1 剔除机制概述


**什么是服务剔除**：

```
问题：服务挂了但没主动注销，怎么办？
答案：Eureka定时检查，超时未续约就剔除

类比：
图书馆借书 → 到期不还 → 自动标记逾期 → 禁止借阅
服务注册  → 超时不续约 → 标记过期     → 从列表删除
```

### 5.2 剔除流程详解


**定时任务执行**：

```
时间轴示例：
0s          60s         120s        180s
|-----------|-----------|-----------|
   第1次检查    第2次检查    第3次检查
        ↓           ↓           ↓
   扫描所有实例  查找过期服务  批量删除

检查逻辑：
IF (当前时间 - 最后心跳时间) > 90秒
   THEN 标记为过期
   
批量删除：
每次最多删除15%的实例（避免误删）
```

**详细步骤**：

```
步骤1️⃣：启动定时任务（默认60秒一次）
Eureka Server → 扫描注册表

步骤2️⃣：检查每个实例
FOR 每个服务实例:
  计算存活时间 = 当前时间 - 最后心跳时间
  IF 存活时间 > 90秒:
    加入待删除列表

步骤3️⃣：批量剔除
删除实例数量 = MIN(待删除数, 总数×15%)
从注册表中移除这些实例

步骤4️⃣：通知客户端
客户端下次拉取服务列表时，发现服务已被移除
```

### 5.3 剔除策略配置


**核心参数**：
```yaml
eureka:
  server:
    eviction-interval-timer-in-ms: 60000  # 剔除任务间隔（毫秒）
    
  instance:
    lease-expiration-duration-in-seconds: 90  # 过期时间阈值
```

**参数调优建议**：

```
快速剔除配置（适合测试环境）：
✅ 心跳间隔：10秒
✅ 过期时间：30秒
✅ 剔除间隔：30秒
→ 服务下线30秒内被剔除

稳定剔除配置（适合生产环境）：
✅ 心跳间隔：30秒
✅ 过期时间：90秒
✅ 剔除间隔：60秒
→ 给予足够的容错时间
```

### 5.4 客户端感知延迟


**完整时间链路**：

```
服务下线 → 客户端感知的最长时间：

服务挂掉(0s)
    ↓
等待剔除检查(最长60s)
    ↓
Eureka执行剔除(0s)
    ↓
客户端缓存刷新(最长30s)
    ↓
客户端感知到(共90s)

⚠️ 最坏情况：90秒延迟
   最好情况：30秒延迟
```

**如何减少延迟**：
```
方案1：缩短检查间隔
eviction-interval-timer-in-ms: 30000  # 30秒检查一次

方案2：缩短客户端缓存
registry-fetch-interval-seconds: 10  # 10秒刷新一次

方案3：启用健康检查
配合Ribbon重试机制，快速切换到健康实例
```

---

## 6. 🌍 区域感知功能


### 6.1 什么是区域（Zone）


**业务场景**：

```
公司架构：
北京机房 ←----网络延迟大----→ 上海机房
   |                            |
订单服务                      订单服务
用户服务                      用户服务

问题：
北京的用户服务调用上海的订单服务 → 延迟高
解决：
北京的用户服务优先调用北京的订单服务 → 延迟低
```

**核心概念**：
- **Zone（区域）**：逻辑上的服务分组，可以是机房、机架、区域
- **Region（地域）**：更大的划分，包含多个Zone
- **就近访问**：优先调用同Zone的服务实例

### 6.2 区域配置实战


**服务端配置**：
```yaml
# 北京机房的Eureka
eureka:
  client:
    region: cn-north  # 地域
    availability-zones:
      cn-north: zone-beijing,zone-tianjin  # 该地域包含的区域
    service-url:
      zone-beijing: http://eureka-bj:8761/eureka/
      zone-tianjin: http://eureka-tj:8762/eureka/
```

**客户端配置**：
```yaml
# 订单服务部署在北京机房
eureka:
  instance:
    metadata-map:
      zone: zone-beijing  # 标识自己属于北京区域
  client:
    region: cn-north
    prefer-same-zone-eureka: true  # 优先使用同区域Eureka
```

### 6.3 调用策略


**优先级规则**：

```
用户服务（北京）调用订单服务：

第1优先级：同Zone实例
zone-beijing的订单服务
    ↓
如果有可用实例 → 使用 ✅
如果没有     → 降级到第2优先级

第2优先级：同Region其他Zone
zone-tianjin的订单服务
    ↓
如果有可用实例 → 使用 ✅
如果没有     → 降级到第3优先级

第3优先级：其他Region
zone-shanghai的订单服务
    ↓
使用任意可用实例
```

**实际效果**：
```
优化前：
请求响应时间 = 100ms（跨机房）

优化后：
请求响应时间 = 10ms（同机房）
性能提升 = 90%
```

---

## 7. 📊 实例状态管理


### 7.1 实例状态类型


**状态定义**：

| 状态 | **含义** | **触发条件** | **是否可调用** |
|------|---------|------------|--------------|
| 🟢 **UP** | `正常运行` | `心跳正常，健康检查通过` | ✅ 可调用 |
| 🔴 **DOWN** | `已下线` | `心跳停止或健康检查失败` | ❌ 不可调用 |
| 🟡 **STARTING** | `启动中` | `服务刚启动，还未就绪` | ❌ 不可调用 |
| 🟠 **OUT_OF_SERVICE** | `停止服务` | `手动下线，不接受请求` | ❌ 不可调用 |
| ⚪ **UNKNOWN** | `未知` | `无法获取状态信息` | ❌ 不可调用 |

### 7.2 状态转换流程


**完整生命周期**：

```
STARTING（启动中）
    ↓
  服务启动完成
    ↓
UP（正常运行）
    ↓
  健康检查失败 / 手动下线
    ↓
DOWN / OUT_OF_SERVICE（不可用）
    ↓
  从注册表移除
    ↓
已注销
```

**状态转换示例**：
```
场景1：正常启动
订单服务启动 
→ STARTING 
→ 注册到Eureka 
→ UP 
→ 可以被调用

场景2：服务异常
订单服务运行中
→ UP
→ 数据库连接失败
→ 健康检查失败
→ DOWN
→ 不再被调用

场景3：优雅下线
订单服务准备升级
→ UP
→ 手动设置OUT_OF_SERVICE
→ 等待请求处理完
→ 关闭服务
→ 从Eureka注销
```

### 7.3 手动状态管理


**REST API操作**：

```bash
# 1. 修改实例状态为OUT_OF_SERVICE（停止服务）
PUT http://eureka:8761/eureka/apps/ORDER-SERVICE/192.168.1.100:8081/status?value=OUT_OF_SERVICE

# 2. 恢复实例状态为UP
PUT http://eureka:8761/eureka/apps/ORDER-SERVICE/192.168.1.100:8081/status?value=UP

# 3. 删除实例状态覆盖（恢复自动状态管理）
DELETE http://eureka:8761/eureka/apps/ORDER-SERVICE/192.168.1.100:8081/status
```

**应用场景**：
```
发布部署：
步骤1：设置OUT_OF_SERVICE → 停止接收新请求
步骤2：等待当前请求处理完
步骤3：重启服务
步骤4：自动恢复UP状态

故障隔离：
发现某个实例频繁报错
→ 手动设置OUT_OF_SERVICE
→ 排查问题
→ 修复后恢复UP
```

---

## 8. 📋 核心要点总结


### 8.1 架构全景图


```
                    [Eureka Server集群]
                    /        |         \
            注册中心1    注册中心2    注册中心3
                   \        |         /
                        互相同步
                            |
        +-------------------+-------------------+
        |                   |                   |
   [服务提供者]         [服务提供者]        [服务消费者]
   订单服务(2个实例)    用户服务(3个实例)    API网关
        |                   |                   |
      注册服务             注册服务            查询服务
      发送心跳             发送心跳            调用服务
```

### 8.2 关键知识点速记


**🔸 核心组件记忆**
```
Eureka Server = 服务通讯录管理员
Eureka Client = 通讯录使用者
Registry      = 服务通讯录本身
```

**🔸 重要时间参数**
```
30秒  → 心跳发送间隔
90秒  → 服务过期时间（3次心跳）
60秒  → 剔除任务执行间隔
30秒  → 客户端缓存刷新间隔
```

**🔸 自我保护机制**
```
触发条件：心跳数 < 期望值×85%
保护策略：不剔除任何服务
退出条件：心跳恢复正常
生产环境：建议开启
```

**🔸 服务调用延迟**
```
最坏情况：服务下线90秒后才被感知
组成部分：剔除间隔(60s) + 缓存刷新(30s)
优化方向：缩短检查间隔 + 健康检查 + 重试机制
```

### 8.3 常见问题与解决方案


**❓ 服务下线了但还能被调用？**
```
原因：客户端缓存延迟 + 剔除检查延迟
解决：
✅ 缩短缓存刷新间隔
✅ 配置Ribbon重试机制
✅ 使用健康检查快速熔断
```

**❓ 自我保护模式频繁触发？**
```
原因：网络不稳定或实例数量波动
解决：
✅ 检查网络质量
✅ 调整保护阈值（降低到0.7）
✅ 测试环境可关闭保护模式
```

**❓ 区域感知不生效？**
```
原因：配置不完整或元数据缺失
解决：
✅ 确认metadata-map.zone正确配置
✅ 检查prefer-same-zone-eureka启用
✅ 验证Ribbon的NFLoadBalancerRuleClassName
```

### 8.4 最佳实践建议


**🎯 配置建议**

| 场景 | **配置策略** |
|------|------------|
| **本地开发** | `关闭自我保护，快速剔除，单实例Eureka` |
| **测试环境** | `关闭自我保护，缩短检查间隔，观察日志` |
| **生产环境** | `开启自我保护，Eureka集群（≥3个），合理超时设置` |

**🎯 监控要点**
```
✅ 注册实例数量变化
✅ 心跳成功率
✅ 自我保护模式触发频率
✅ 服务剔除次数统计
✅ 客户端获取列表延迟
```

**核心记忆口诀**：
```
Eureka好比通讯录，服务注册心中有
三十秒钟发心跳，九十秒后才剔除
自我保护防误删，区域感知就近调
状态管理要清楚，集群部署保高可
```