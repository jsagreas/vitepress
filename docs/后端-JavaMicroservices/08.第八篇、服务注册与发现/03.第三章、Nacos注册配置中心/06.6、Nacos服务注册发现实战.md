---
title: 6、Nacos服务注册发现实战
---
## 📚 目录

1. [Spring Cloud Alibaba集成概述](#1-Spring-Cloud-Alibaba集成概述)
2. [Maven依赖配置](#2-Maven依赖配置)
3. [服务注册配置实战](#3-服务注册配置实战)
4. [服务发现与调用](#4-服务发现与调用)
5. [临时实例vs持久实例](#5-临时实例vs持久实例)
6. [健康检查机制](#6-健康检查机制)
7. [实例权重与负载均衡](#7-实例权重与负载均衡)
8. [服务分组管理](#8-服务分组管理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚀 Spring Cloud Alibaba集成概述


### 1.1 什么是Spring Cloud Alibaba


**通俗理解**：想象你在搭建一个大型网站，有用户服务、订单服务、支付服务等很多小系统。Spring Cloud Alibaba就像一个"万能工具箱"，帮你把这些小系统连接起来，让它们能互相找到对方、互相通信。

```
传统单体应用：                微服务架构：
┌─────────────┐              ┌────────┐  ┌────────┐
│             │              │用户服务│  │订单服务│
│   所有功能   │    变成   →  ├────────┤  ├────────┤
│  都在一起    │              │支付服务│  │库存服务│
│             │              └────────┘  └────────┘
└─────────────┘                    ↓
                              需要服务注册中心
                              让服务互相找到对方
```

**核心作用**：
- 🔍 **服务发现**：帮助服务A找到服务B的地址
- 📡 **配置管理**：统一管理所有服务的配置
- 🔄 **负载均衡**：请求分配到多个服务实例
- 🛡️ **服务保护**：防止服务调用出问题

### 1.2 为什么选择Nacos


**实际场景对比**：

| 需求场景 | 传统做法 | 使用Nacos |
|---------|---------|----------|
| **找到其他服务** | `硬编码IP地址` | `自动发现服务位置` |
| **服务地址变更** | `修改代码重新发布` | `自动感知更新` |
| **配置修改** | `每个服务单独改` | `统一管理动态更新` |
| **服务挂了** | `手动切换备用服务` | `自动剔除故障实例` |

**Nacos优势**：
- ✅ **易于使用**：几行配置就能完成集成
- ✅ **功能强大**：服务注册+配置管理一体化
- ✅ **性能优秀**：支持百万级服务实例
- ✅ **国产适配**：更符合国内开发习惯

---

## 2. 📦 Maven依赖配置


### 2.1 依赖管理版本说明


**版本选择原则**：就像买手机要看型号配置一样，微服务框架也要选对版本搭配。

```
Spring Boot版本 ←→ Spring Cloud版本 ←→ Spring Cloud Alibaba版本
     2.6.x              2021.x                  2021.x
     2.7.x              2021.x                  2021.x
     3.0.x              2022.x                  2022.x

记住：三个版本要匹配，否则会出问题！
```

### 2.2 父工程依赖配置


**什么是父工程**：想象一个大家庭，父母管理所有孩子的零花钱标准。父工程就是管理所有子项目（微服务）的依赖版本。

```xml
<!-- 父工程pom.xml - 统一管理版本 -->
<properties>
    <spring-boot.version>2.7.14</spring-boot.version>
    <spring-cloud.version>2021.0.8</spring-cloud.version>
    <spring-cloud-alibaba.version>2021.0.5.0</spring-cloud-alibaba.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!-- Spring Cloud依赖管理 -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- Spring Cloud Alibaba依赖管理 -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>${spring-cloud-alibaba.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

> 💡 **新手提示**：`<dependencyManagement>`只是声明版本，不会真正引入依赖，就像定价格但不买东西。

### 2.3 子服务依赖配置


**实际使用**：每个微服务都要引入Nacos的依赖才能使用服务注册功能。

```xml
<!-- 子服务pom.xml - 实际引入依赖 -->
<dependencies>
    <!-- Nacos服务注册发现 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        <!-- 不需要写version，父工程已经管理 -->
    </dependency>
    
    <!-- Spring Boot Web（提供HTTP接口） -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

**依赖说明**：
- `nacos-discovery`：核心依赖，提供服务注册和发现能力
- `starter-web`：提供HTTP服务能力，让服务能对外提供接口

---

## 3. ⚙️ 服务注册配置实战


### 3.1 配置文件详解


**什么是服务注册**：就像新生入学要去教务处登记信息一样，每个微服务启动时要向Nacos"报到"，告诉Nacos自己叫什么名字、住在哪里。

```yaml
# application.yml配置文件
spring:
  application:
    name: user-service  # 服务名称，相当于你的姓名
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848  # Nacos服务器地址
        namespace: dev  # 命名空间，开发/测试/生产环境隔离
        group: DEFAULT_GROUP  # 服务分组

server:
  port: 8081  # 服务端口号
```

**配置项含义**：

| 配置项 | 说明 | 类比理解 |
|-------|------|---------|
| `application.name` | 服务名称 | 你的名字 |
| `server-addr` | Nacos地址 | 学校教务处地址 |
| `namespace` | 命名空间 | 不同年级（隔离环境） |
| `group` | 服务分组 | 不同班级（业务分组） |
| `port` | 服务端口 | 你的座位号 |

### 3.2 启动类配置


**开启服务注册**：只需要一个注解，就能让你的服务自动注册到Nacos。

```java
@SpringBootApplication
@EnableDiscoveryClient  // 开启服务注册发现功能
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
```

> 💡 **工作原理**：启动后，Spring会自动读取配置，向Nacos发送注册请求，告诉Nacos："我是user-service，我在8081端口提供服务"。

### 3.3 注册成功验证


**如何确认注册成功**：

```
步骤1：启动服务 → 看到日志
[Nacos] nacos registry, user-service 192.168.1.100:8081 register finished

步骤2：打开Nacos控制台
浏览器访问：http://localhost:8848/nacos
用户名/密码：nacos/nacos

步骤3：查看服务列表
服务管理 → 服务列表 → 看到user-service ✓
```

**常见问题排查**：

| 问题现象 | 可能原因 | 解决方法 |
|---------|---------|---------|
| 服务列表看不到 | Nacos未启动 | 先启动Nacos服务器 |
| 注册失败 | 地址配置错误 | 检查server-addr配置 |
| 端口冲突 | 端口被占用 | 修改server.port配置 |

---

## 4. 🔍 服务发现与调用


### 4.1 服务发现的本质


**通俗理解**：你要打电话给朋友，但不知道他电话号码。服务发现就像114查号台，告诉你朋友的电话。

```
调用流程：
订单服务想调用用户服务
    ↓
问Nacos："用户服务在哪？"
    ↓
Nacos回答："在192.168.1.100:8081"
    ↓
订单服务向该地址发送HTTP请求
    ↓
用户服务返回数据
```

### 4.2 使用RestTemplate调用


**方式一：RestTemplate + LoadBalanced**

```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced  // 开启负载均衡（自动从Nacos获取服务地址）
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public String createOrder(Long userId) {
        // 直接用服务名称调用，不需要写IP地址
        String url = "http://user-service/user/" + userId;
        User user = restTemplate.getForObject(url, User.class);
        
        // 处理订单逻辑...
        return "订单创建成功";
    }
}
```

> ⚠️ **关键点**：使用服务名`user-service`而不是IP地址，这样服务地址变化时不需要改代码。

### 4.3 使用OpenFeign调用


**方式二：声明式调用（更简单）**

```java
// 1. 定义Feign接口
@FeignClient(value = "user-service")  // 指定要调用的服务名
public interface UserClient {
    
    @GetMapping("/user/{id}")  // 接口路径
    User getUserById(@PathVariable Long id);
}
```

```java
// 2. 在服务中使用
@Service
public class OrderService {
    
    @Autowired
    private UserClient userClient;
    
    public String createOrder(Long userId) {
        // 像调用本地方法一样调用远程服务
        User user = userClient.getUserById(userId);
        
        // 处理订单逻辑...
        return "订单创建成功";
    }
}
```

**对比两种方式**：

| 特性 | RestTemplate | OpenFeign |
|-----|-------------|-----------|
| **使用难度** | 需要手写URL | 声明式，更简单 |
| **代码可读性** | 一般 | 更好，像调用本地方法 |
| **功能丰富度** | 基础功能 | 支持超时、重试等高级功能 |
| **推荐场景** | 简单调用 | 复杂业务，推荐使用 |

---

## 5. 🔄 临时实例vs持久实例


### 5.1 两种实例模式详解


**通俗类比**：
- **临时实例**：像租客，合同到期就离开，房东主动检查是否还在
- **持久实例**：像业主，主动告诉物业自己在不在，物业只记录

```
临时实例：                    持久实例：
服务启动 → 注册到Nacos        服务启动 → 注册到Nacos
         ↓                            ↓
Nacos主动检查健康              服务主动上报健康状态
         ↓                            ↓
服务挂了 → 自动剔除            服务挂了 → 标记不健康
         ↓                            ↓
服务恢复 → 重新注册            服务恢复 → 恢复健康状态
```

### 5.2 临时实例配置


**默认就是临时实例**，Nacos会主动检查服务是否存活。

```yaml
spring:
  cloud:
    nacos:
      discovery:
        ephemeral: true  # true=临时实例（默认）
        heart-beat-interval: 5000  # 心跳间隔5秒
        heart-beat-timeout: 15000  # 15秒无心跳认为不健康
        ip-delete-timeout: 30000   # 30秒无心跳删除实例
```

**工作机制**：
1. 服务每5秒向Nacos发送心跳："我还活着"
2. Nacos超过15秒没收到心跳，标记为不健康
3. Nacos超过30秒没收到心跳，直接删除实例

> 💡 **适用场景**：云环境、容器化部署，服务可能随时扩缩容

### 5.3 持久实例配置


**改为持久实例**：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        ephemeral: false  # false=持久实例
```

**工作机制**：
1. 服务主动向Nacos上报健康状态
2. 服务挂了，Nacos只标记不健康，不删除
3. 服务恢复后，重新标记为健康

> 💡 **适用场景**：传统部署，服务实例相对固定

### 5.4 选择建议


**如何选择实例类型**：

| 场景 | 选择 | 原因 |
|-----|------|------|
| **Kubernetes部署** | 临时实例 | Pod可能随时创建销毁 |
| **传统虚拟机部署** | 持久实例 | 服务实例相对固定 |
| **开发测试环境** | 临时实例 | 频繁启停服务 |
| **生产环境** | 看情况 | 容器化用临时，传统用持久 |

---

## 6. 🏥 健康检查机制


### 6.1 健康检查的重要性


**为什么需要健康检查**：想象你叫外卖，如果商家已经打烊，平台还推荐给你，就会浪费时间。健康检查就是确保推荐给你的服务都是正常营业的。

```
没有健康检查：                有健康检查：
用户请求 → 服务A(已挂)        用户请求 → 自动绕过故障服务
   ↓                              ↓
调用失败 ✗                    调用成功的服务 ✓
   ↓                              ↓
用户体验差                    用户无感知
```

### 6.2 健康检查配置


**Spring Boot Actuator健康检查**：

```xml
<!-- 添加健康检查依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yaml
# 配置健康检查端点
management:
  endpoints:
    web:
      exposure:
        include: health  # 暴露健康检查接口
  endpoint:
    health:
      show-details: always  # 显示详细健康信息
```

**访问健康检查**：
```
浏览器访问：http://localhost:8081/actuator/health

返回结果：
{
  "status": "UP",  // UP=健康，DOWN=不健康
  "components": {
    "diskSpace": {"status": "UP"},
    "ping": {"status": "UP"}
  }
}
```

### 6.3 自定义健康检查


**场景**：除了默认检查，你可能还想检查数据库、Redis等是否正常。

```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try {
            // 检查数据库连接
            Connection conn = dataSource.getConnection();
            conn.close();
            return Health.up()
                .withDetail("database", "MySQL连接正常")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("database", "MySQL连接失败")
                .build();
        }
    }
}
```

**检查机制说明**：

| 检查项 | 说明 | 不健康时的处理 |
|-------|------|-------------|
| **磁盘空间** | 检查磁盘剩余空间 | 低于阈值标记DOWN |
| **数据库连接** | 检查能否连接数据库 | 连接失败标记DOWN |
| **自定义检查** | 你自己定义的检查逻辑 | 根据逻辑返回状态 |

> ⚠️ **重要**：Nacos会定期访问`/actuator/health`，如果返回DOWN，就认为服务不健康。

---

## 7. ⚖️ 实例权重与负载均衡


### 7.1 什么是实例权重


**生活类比**：公司聚餐，5个人抢着买单。老板说："按工资比例分摊"，这就是权重的概念。服务调用也一样，性能好的服务器多承担点请求。

```
场景：user-service有3个实例
实例A：8核16G服务器，权重=10
实例B：4核8G服务器，权重=5  
实例C：2核4G服务器，权重=1

100个请求分配：
实例A：约62个请求（10/16 ≈ 62%）
实例B：约31个请求（5/16 ≈ 31%）
实例C：约7个请求（1/16 ≈ 7%）
```

### 7.2 权重配置方式


**方式一：配置文件设置**

```yaml
spring:
  cloud:
    nacos:
      discovery:
        weight: 10  # 权重值，范围0-100，默认1
```

**方式二：Nacos控制台动态修改**

```
步骤操作：
1. 打开Nacos控制台
2. 服务管理 → 服务列表 → 点击user-service
3. 找到实例列表
4. 点击"编辑"按钮
5. 修改权重值
6. 保存 → 立即生效（无需重启服务）
```

### 7.3 权重应用场景


**实际使用案例**：

| 场景 | 权重设置 | 说明 |
|-----|---------|------|
| **灰度发布** | 新版本权重=1，旧版本权重=9 | 10%流量到新版本测试 |
| **服务器差异** | 高配权重=10，低配权重=5 | 按性能分配请求 |
| **服务下线** | 权重设为0 | 不接收新请求，等现有请求处理完 |
| **流量调整** | 动态调整权重比例 | 实时控制流量分配 |

**灰度发布示例**：

```
步骤1：部署新版本v2，权重=1
  v1(权重9) → 90%流量
  v2(权重1) → 10%流量

步骤2：观察v2运行情况
  - 监控日志、错误率
  - 用户反馈

步骤3：逐步提升v2权重
  v1(权重5) → 50%流量
  v2(权重5) → 50%流量

步骤4：完全切换到v2
  v1(权重0) → 0%流量（准备下线）
  v2(权重10) → 100%流量
```

### 7.4 负载均衡策略


**Ribbon负载均衡配置**（Spring Cloud默认使用）：

```yaml
user-service:  # 服务名
  ribbon:
    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule
    # 使用Nacos权重策略
```

**常用负载均衡策略**：

| 策略 | 说明 | 适用场景 |
|-----|------|---------|
| **NacosRule** | 基于Nacos权重 | 需要控制流量分配 |
| **RandomRule** | 随机选择 | 简单场景 |
| **RoundRobinRule** | 轮询选择 | 实例性能相同 |
| **WeightedResponseTimeRule** | 响应时间加权 | 自动优化性能 |

---

## 8. 📂 服务分组管理


### 8.1 分组的作用


**为什么需要分组**：想象一个大公司，不同部门（研发、销售、财务）在同一栋楼，但各干各的事。服务分组就是把服务按业务或环境分类管理。

```
不分组的混乱：                使用分组管理：
所有服务混在一起              ┌─────────────┐
user-service                │  电商业务组   │
order-service               │ user-service  │
payment-service      →      │ order-service │
logistics-service           └─────────────┘
warehouse-service           ┌─────────────┐
...                         │  物流业务组   │
                           │logistics-...  │
                           └─────────────┘
```

### 8.2 分组配置方式


**配置文件设置分组**：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        group: ECOMMERCE_GROUP  # 电商业务组
        # 或者
        group: LOGISTICS_GROUP  # 物流业务组
```

**分组的层次结构**：

```
命名空间（环境隔离）
  └── 分组（业务隔离）
       └── 服务
            └── 实例

示例：
namespace: production（生产环境）
  └── group: ECOMMERCE_GROUP（电商业务）
       └── user-service（用户服务）
            ├── 192.168.1.100:8081
            └── 192.168.1.101:8081
```

### 8.3 跨分组调用


**默认只能调用同组服务**：

```java
// 默认调用同组服务
@FeignClient(value = "user-service")  
// 只能调用ECOMMERCE_GROUP中的user-service
```

**调用不同组的服务**：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        group: ORDER_GROUP  # 当前服务在ORDER_GROUP
        
# 调用其他分组的服务
user-service:
  ribbon:
    nacos:
      group: USER_GROUP  # 指定要调用USER_GROUP的user-service
```

### 8.4 分组使用场景


**实际应用案例**：

| 分组方式 | 示例 | 说明 |
|---------|------|------|
| **按业务分组** | ECOMMERCE, LOGISTICS | 不同业务线独立管理 |
| **按团队分组** | TEAM_A, TEAM_B | 不同团队开发的服务 |
| **按版本分组** | V1, V2 | 多版本并存 |
| **按地域分组** | CN_NORTH, CN_SOUTH | 就近调用优化 |

**复杂场景示例**：

```
某大型电商平台：

命名空间：production（生产环境）
├── 分组：ECOMMERCE_CORE（核心电商）
│   ├── user-service
│   ├── order-service
│   └── payment-service
│
├── 分组：ECOMMERCE_MARKETING（营销系统）
│   ├── coupon-service
│   └── promotion-service
│
└── 分组：LOGISTICS（物流系统）
    ├── warehouse-service
    └── delivery-service

优势：
- 业务隔离：营销活动不影响核心交易
- 独立发布：物流系统升级不影响电商
- 权限管理：不同团队管理各自分组
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 服务注册：服务启动时向Nacos"报到"，告知自己的位置
🔸 服务发现：通过服务名找到服务实例的地址
🔸 健康检查：确保只调用健康的服务实例
🔸 实例权重：控制流量分配，实现灰度发布
🔸 服务分组：业务隔离，不同分组服务独立管理
```

### 9.2 关键配置清单


**最小化配置**（快速上手）：

```yaml
spring:
  application:
    name: user-service  # 服务名
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848  # Nacos地址

server:
  port: 8081  # 服务端口
```

**生产环境配置**（完整版）：

```yaml
spring:
  application:
    name: user-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: production  # 环境隔离
        group: ECOMMERCE_GROUP  # 业务分组
        weight: 10  # 实例权重
        ephemeral: true  # 临时实例
        
management:
  endpoints:
    web:
      exposure:
        include: health  # 健康检查

server:
  port: 8081
```

### 9.3 实战技巧总结


**开发调试技巧**：

1. **查看注册状态**：启动服务后立即访问Nacos控制台确认
2. **测试服务调用**：使用Postman或浏览器测试接口
3. **观察健康检查**：访问`/actuator/health`查看健康状态
4. **动态调整权重**：控制台修改权重测试流量分配

**常见问题速查**：

| 问题 | 检查项 | 解决方法 |
|-----|--------|---------|
| **服务注册失败** | Nacos是否启动 | 启动Nacos服务器 |
| | 配置地址是否正确 | 检查server-addr |
| **无法调用服务** | 服务名是否正确 | 检查@FeignClient配置 |
| | 是否同一分组 | 检查group配置 |
| **负载不均衡** | 权重是否设置 | 检查weight配置 |
| | 负载策略是否正确 | 检查ribbon配置 |

### 9.4 记忆要点


**核心流程记忆**：

```
服务注册 → 配置Nacos地址 → 启动自动注册
服务发现 → 用服务名调用 → 自动获取地址
健康检查 → 配置actuator → Nacos自动检测
权重调整 → 控制台修改 → 实时生效
分组管理 → 设置group → 业务隔离
```

**最佳实践**：
- ✅ 开发环境使用临时实例，方便调试
- ✅ 生产环境使用持久实例，保证稳定性  
- ✅ 合理设置权重，实现灰度发布
- ✅ 按业务分组，便于管理维护
- ✅ 配置健康检查，及时发现故障

> 💡 **学习建议**：先掌握基本的注册和发现，再逐步学习健康检查、权重、分组等高级特性。每个知识点都动手实践一遍，印象会更深刻！