---
title: 4、Nacos核心概念模型
---
## 📚 目录

1. [Nacos核心概念总览](#1-Nacos核心概念总览)
2. [服务Service概念](#2-服务Service概念)
3. [实例Instance管理](#3-实例Instance管理)
4. [集群Cluster划分](#4-集群Cluster划分)
5. [命名空间Namespace](#5-命名空间Namespace)
6. [分组Group管理](#6-分组Group管理)
7. [权重Weight配置](#7-权重Weight配置)
8. [元数据Metadata](#8-元数据Metadata)
9. [健康检查机制](#9-健康检查机制)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 Nacos核心概念总览


### 1.1 什么是Nacos的核心概念模型


**通俗理解**：想象你在管理一个大型购物中心，Nacos的核心概念就像这个购物中心的组织架构。

```
购物中心类比：
- 命名空间Namespace = 不同的楼层（1楼、2楼、3楼）
- 分组Group = 每层的区域划分（餐饮区、服装区）
- 服务Service = 具体的店铺品牌（星巴克、麦当劳）
- 实例Instance = 同品牌的不同门店（东门店、西门店）
- 集群Cluster = 连锁店的区域划分（北京区、上海区）
```

### 1.2 概念层级关系图


```
命名空间Namespace (最外层 - 环境隔离)
    │
    ├── 分组Group (业务隔离)
    │     │
    │     ├── 服务Service (应用标识)
    │     │     │
    │     │     ├── 集群Cluster (区域划分)
    │     │     │     │
    │     │     │     ├── 实例Instance-1 (具体节点)
    │     │     │     ├── 实例Instance-2
    │     │     │     └── 实例Instance-3
    │     │     │
    │     │     └── 集群Cluster-2
    │     │           └── ...
    │     └── ...
    └── ...
```

### 1.3 核心概念关系表


| 概念 | 作用范围 | 主要用途 | 生活类比 |
|------|---------|---------|---------|
| **Namespace** | 全局 | 环境隔离 | 大楼的不同楼层 |
| **Group** | 命名空间内 | 业务分类 | 楼层内的功能区 |
| **Service** | 分组内 | 服务标识 | 具体品牌商家 |
| **Cluster** | 服务内 | 区域划分 | 品牌的区域门店 |
| **Instance** | 集群内 | 具体节点 | 单个门店地址 |

---

## 2. 🏢 服务Service概念


### 2.1 服务的本质含义


**什么是服务？**

服务（Service）就是一个**提供特定功能的应用程序**。在微服务架构中，我们把一个大系统拆分成很多小服务，每个小服务负责一个具体的业务功能。

```
电商系统拆分示例：
┌─────────────────────────────────────┐
│         电商系统（单体应用）          │
│  用户、订单、商品、支付全在一起        │
└─────────────────────────────────────┘
                  ↓ 拆分
┌──────────┐  ┌──────────┐  ┌──────────┐
│用户服务  │  │订单服务  │  │商品服务  │
│User      │  │Order     │  │Product   │
│Service   │  │Service   │  │Service   │
└──────────┘  └──────────┘  └──────────┘

每个都是一个独立的Service
```

### 2.2 服务的命名规范


**服务名称的组成**：通常采用 `应用名-服务功能` 的格式

```java
// 推荐的服务命名方式
✅ user-service         // 用户服务
✅ order-service        // 订单服务  
✅ product-service      // 商品服务
✅ payment-service      // 支付服务

// 不推荐的命名
❌ service1            // 名称不清晰
❌ myApp              // 功能不明确
❌ test               // 没有业务含义
```

### 2.3 服务注册示例


```java
// Spring Boot中注册服务到Nacos
@SpringBootApplication
@EnableDiscoveryClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
```

```yaml
# application.yml - 服务配置
spring:
  application:
    name: user-service        # 这就是Service名称
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: dev          # 指定命名空间
        group: DEFAULT_GROUP    # 指定分组
```

---

## 3. 💻 实例Instance管理


### 3.1 实例的概念理解


**什么是实例？**

实例（Instance）就是**服务的一个具体运行副本**，可以简单理解为：一个服务程序运行在一台机器上，就是一个实例。

```
同一个服务的多个实例：
用户服务(user-service)
    ├── 实例1: 192.168.1.10:8080  ← 第一台服务器
    ├── 实例2: 192.168.1.11:8080  ← 第二台服务器  
    └── 实例3: 192.168.1.12:8080  ← 第三台服务器

就像麦当劳有很多门店，每个门店就是一个实例
```

### 3.2 实例的核心属性


| 属性 | 说明 | 示例值 | 作用 |
|-----|------|--------|------|
| **IP地址** | 实例的网络地址 | `192.168.1.10` | 定位服务器 |
| **端口号** | 服务监听端口 | `8080` | 访问服务 |
| **健康状态** | 是否可用 | `健康/不健康` | 流量控制 |
| **权重** | 负载均衡权重 | `1.0` | 流量分配 |
| **元数据** | 自定义信息 | `version=1.0` | 扩展信息 |

### 3.3 实例注册流程


```
服务启动流程：
┌─────────────┐
│ 1. 启动服务  │
│   user-service│
└──────┬──────┘
       ↓
┌─────────────────┐
│ 2. 读取配置信息  │
│   IP: 本机IP     │
│   Port: 8080    │
└──────┬──────────┘
       ↓
┌─────────────────────┐
│ 3. 向Nacos注册实例   │
│   Service: user-service│
│   Instance: 192.168.1.10:8080│
└──────┬──────────────┘
       ↓
┌─────────────────┐
│ 4. Nacos记录实例 │
│   开始心跳检测   │
└─────────────────┘
```

### 3.4 实例的临时与持久化


**两种实例类型**：

```
临时实例（Temporary Instance）- 默认类型
特点：服务停止后自动从注册中心删除
场景：大部分微服务应用
检测：通过心跳检测健康状态

持久化实例（Persistent Instance）
特点：服务停止后仍保留在注册中心
场景：需要保留历史记录的服务
检测：Nacos主动探测健康状态
```

```yaml
# 配置实例类型
spring:
  cloud:
    nacos:
      discovery:
        ephemeral: true   # true=临时实例，false=持久化实例
```

---

## 4. 🌐 集群Cluster划分


### 4.1 集群的作用


**为什么需要集群划分？**

集群（Cluster）是对**同一个服务的实例进行分组**，通常按照**地理位置、机房、区域**等进行划分。

```
实际场景理解：
你的用户服务部署在多个城市：
用户服务(user-service)
    ├── 北京集群(BJ)
    │   ├── 实例1: 北京机房-服务器1
    │   └── 实例2: 北京机房-服务器2
    │
    ├── 上海集群(SH)
    │   ├── 实例3: 上海机房-服务器1
    │   └── 实例4: 上海机房-服务器2
    │
    └── 广州集群(GZ)
        └── 实例5: 广州机房-服务器1

好处：北京的请求优先访问北京的服务，减少延迟
```

### 4.2 集群配置方式


```yaml
# application.yml - 指定集群名称
spring:
  cloud:
    nacos:
      discovery:
        cluster-name: BJ    # 当前实例所属集群
```

```java
// 也可以通过代码设置
@Configuration
public class NacosConfig {
    @Value("${spring.cloud.nacos.discovery.cluster-name:DEFAULT}")
    private String clusterName;
    
    // clusterName会在服务注册时使用
}
```

### 4.3 同集群优先调用


**调用策略**：

```
① 优先同集群
订单服务(BJ集群) → 优先调用 → 用户服务(BJ集群)

② 集群故障降级  
订单服务(BJ集群) → BJ集群全部故障 → 用户服务(SH集群)

③ 跨集群调用
订单服务(BJ集群) → 手动指定 → 用户服务(GZ集群)
```

**配置示例**：

```yaml
# Ribbon负载均衡配置
user-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule
    # NacosRule会优先选择同集群实例
```

---

## 5. 🏗️ 命名空间Namespace


### 5.1 命名空间的本质


**什么是命名空间？**

命名空间（Namespace）是Nacos中**最大的隔离单位**，用于**环境隔离**。

```
通俗理解：命名空间就像一栋大楼的不同楼层

┌─────────────────────────┐
│  开发环境(dev)           │ ← 第1层：开发人员用
├─────────────────────────┤
│  测试环境(test)          │ ← 第2层：测试人员用
├─────────────────────────┤
│  生产环境(prod)          │ ← 第3层：正式环境
└─────────────────────────┘

每层互不干扰，配置完全独立
```

### 5.2 为什么需要命名空间


**解决的问题**：

```
问题场景：
开发环境的user-service连接的是测试数据库
生产环境的user-service连接的是生产数据库

如果不隔离：
❌ 开发环境可能调用到生产环境的服务
❌ 配置相互覆盖
❌ 数据污染

使用命名空间隔离：
✅ dev环境的服务只能看到dev环境的其他服务
✅ prod环境的服务只能看到prod环境的其他服务
✅ 配置互不干扰
```

### 5.3 命名空间的创建与使用


**① 在Nacos控制台创建命名空间**：

```
步骤：
1. 登录Nacos控制台 http://localhost:8848/nacos
2. 点击左侧菜单"命名空间"
3. 点击"新建命名空间"
4. 填写信息：
   - 命名空间ID: dev
   - 命名空间名: 开发环境
5. 保存
```

**② 应用中配置命名空间**：

```yaml
# 开发环境配置 application-dev.yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: dev    # 使用dev命名空间的ID

# 生产环境配置 application-prod.yml  
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: prod   # 使用prod命名空间的ID
```

### 5.4 命名空间隔离效果


```
实际效果：
┌─── dev命名空间 ────┐     ┌─── prod命名空间 ────┐
│ user-service       │     │ user-service         │
│ order-service      │     │ order-service        │
│ product-service    │     │ product-service      │
└───────────────────┘     └─────────────────────┘
      ↑                            ↑
   只能互相访问              只能互相访问
      ↓                            ↓
   看不到prod环境           看不到dev环境
```

---

## 6. 📁 分组Group管理


### 6.1 分组的概念


**什么是分组？**

分组（Group）是在**命名空间内部**进行的**业务逻辑划分**，可以理解为对服务的二级分类。

```
通俗理解：分组就像楼层内的功能区域

开发环境(dev命名空间)
    ├── 电商业务组(SHOP_GROUP)
    │   ├── user-service
    │   ├── order-service
    │   └── product-service
    │
    ├── 支付业务组(PAYMENT_GROUP)
    │   ├── payment-service
    │   └── wallet-service
    │
    └── 后台管理组(ADMIN_GROUP)
        ├── admin-service
        └── log-service
```

### 6.2 分组的应用场景


**使用场景**：

① **业务隔离**
```
同一个环境下，不同业务线使用不同分组
- 核心业务组：处理核心交易
- 营销业务组：处理促销活动
- 数据业务组：数据分析服务
```

② **灰度发布**
```
同一个服务，新旧版本使用不同分组
- STABLE_GROUP：稳定版本
- BETA_GROUP：灰度测试版本
```

③ **多租户场景**
```
SaaS系统中，不同租户使用不同分组
- TENANT_A_GROUP：租户A的服务
- TENANT_B_GROUP：租户B的服务
```

### 6.3 分组配置方式


```yaml
# application.yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: dev
        group: SHOP_GROUP    # 指定分组
```

```java
// 服务调用时指定分组
@FeignClient(name = "user-service")
public interface UserClient {
    // 默认调用同分组的服务
}

// 如果需要跨分组调用，需要特殊配置
```

### 6.4 分组的隔离级别


```
隔离级别对比：
┌────────────────────────────────┐
│  命名空间隔离(Namespace)        │
│  └── 强隔离：完全看不到          │
├────────────────────────────────┤
│  分组隔离(Group)                │
│  └── 弱隔离：可以跨组访问(需配置) │
└────────────────────────────────┘
```

---

## 7. ⚖️ 权重Weight配置


### 7.1 权重的作用


**什么是权重？**

权重（Weight）用于控制**实例接收请求的比例**，权重越高，接收的请求越多。

```
场景理解：
3台服务器配置不同：
┌─────────────────────┐
│ 服务器A (高配)       │
│ CPU: 16核 内存: 32G  │
│ 权重: 3              │ ← 处理60%的请求
├─────────────────────┤
│ 服务器B (中配)       │
│ CPU: 8核 内存: 16G   │
│ 权重: 2              │ ← 处理30%的请求
├─────────────────────┤
│ 服务器C (低配)       │
│ CPU: 4核 内存: 8G    │
│ 权重: 1              │ ← 处理10%的请求
└─────────────────────┘
```

### 7.2 权重的配置方式


**① 配置文件方式**：

```yaml
# application.yml
spring:
  cloud:
    nacos:
      discovery:
        weight: 3    # 设置当前实例权重，默认为1
```

**② 控制台动态修改**：

```
步骤：
1. 登录Nacos控制台
2. 进入"服务管理" → "服务列表"
3. 点击服务名称 → 点击"详情"
4. 找到对应实例，点击"编辑"
5. 修改权重值(0-10000)
6. 保存 → 立即生效
```

### 7.3 权重的实际应用


**场景1：灰度发布**

```
新版本灰度上线：
旧版本实例：权重 9 → 90%流量
新版本实例：权重 1 → 10%流量

观察一段时间后：
旧版本实例：权重 5 → 50%流量
新版本实例：权重 5 → 50%流量

新版本稳定后：
旧版本实例：权重 0 → 下线
新版本实例：权重 10 → 100%流量
```

**场景2：实例上下线**

```
服务实例平滑下线：
正常权重：权重 10 → 接收正常流量
准备下线：权重 5  → 减少流量
即将下线：权重 1  → 极少流量
完全下线：权重 0  → 不接收流量，但保留注册信息
```

### 7.4 权重为0的特殊情况


```
权重=0的含义：
✅ 实例仍然在注册中心
✅ 健康检查仍然执行
✅ 不会接收任何请求流量
❌ 但不会被自动删除

应用场景：
- 临时下线维护
- 问题排查
- 性能测试准备
```

---

## 8. 📝 元数据Metadata


### 8.1 元数据的概念


**什么是元数据？**

元数据（Metadata）就是**描述服务实例的额外信息**，可以理解为给服务实例贴的"标签"。

```
生活类比：
服务实例 = 一本书
元数据 = 书的属性标签
    - version: "1.0.0"    (版本号)
    - author: "张三"       (作者)
    - region: "华北"       (区域)
    - env: "dev"          (环境)
```

### 8.2 元数据的配置


```yaml
# application.yml
spring:
  cloud:
    nacos:
      discovery:
        metadata:
          version: 1.0.0          # 服务版本
          region: beijing         # 所属区域
          group: core-service     # 业务分组
          author: zhangsan        # 负责人
          custom-key: custom-value # 自定义字段
```

```java
// 代码方式添加元数据
@Configuration
public class NacosMetadataConfig {
    
    @Bean
    public NacosDiscoveryProperties nacosProperties() {
        NacosDiscoveryProperties properties = new NacosDiscoveryProperties();
        
        Map<String, String> metadata = new HashMap<>();
        metadata.put("version", "1.0.0");
        metadata.put("region", "beijing");
        
        properties.setMetadata(metadata);
        return properties;
    }
}
```

### 8.3 元数据的应用场景


**场景1：版本路由**

```
根据版本号路由请求：
用户请求 → 检查元数据version
    ├── version=1.0 → 路由到旧版服务
    └── version=2.0 → 路由到新版服务
```

**场景2：区域就近访问**

```java
// 自定义负载均衡规则，优先访问同区域服务
public class RegionNacosRule extends AbstractLoadBalancerRule {
    
    @Override
    public Server choose(Object key) {
        // 获取当前服务的region元数据
        String currentRegion = getCurrentRegion();
        
        // 筛选同区域的服务实例
        List<Server> sameRegionServers = servers.stream()
            .filter(s -> currentRegion.equals(getServerRegion(s)))
            .collect(Collectors.toList());
            
        // 优先返回同区域实例
        return sameRegionServers.isEmpty() ? 
            getRandomServer() : 
            sameRegionServers.get(random.nextInt(sameRegionServers.size()));
    }
}
```

**场景3：灰度发布标识**

```
元数据标记灰度实例：
实例A：metadata.gray = "false"  ← 正式版本
实例B：metadata.gray = "true"   ← 灰度版本

请求处理：
普通用户 → 访问 gray=false 的实例
灰度用户 → 访问 gray=true 的实例
```

### 8.4 获取元数据信息


```java
@Service
public class MetadataService {
    
    @Autowired
    private NacosDiscoveryProperties nacosDiscoveryProperties;
    
    // 获取当前服务的元数据
    public Map<String, String> getCurrentMetadata() {
        return nacosDiscoveryProperties.getMetadata();
    }
    
    // 获取其他服务实例的元数据
    @Autowired
    private NamingService namingService;
    
    public Map<String, String> getServiceMetadata(String serviceName) 
        throws NacosException {
        
        List<Instance> instances = namingService.getAllInstances(serviceName);
        if (!instances.isEmpty()) {
            return instances.get(0).getMetadata();
        }
        return Collections.emptyMap();
    }
}
```

---

## 9. ❤️ 健康检查机制


### 9.1 为什么需要健康检查


**健康检查的目的**：

确保只把请求发送给**健康可用**的服务实例，避免访问已经故障的服务。

```
没有健康检查的问题：
请求 → 已宕机的服务 → 超时/失败 → 用户体验差

有健康检查：
请求 → 只发给健康服务 → 快速响应 → 用户体验好

┌────────┐   健康检查   ┌──────────┐
│ Nacos  │ ←─────────→ │ 实例A    │ ✅ 健康
│        │              └──────────┘
│        │              ┌──────────┐
│        │ ←─────────→ │ 实例B    │ ❌ 不健康(剔除)
│        │              └──────────┘
│        │              ┌──────────┐
│        │ ←─────────→ │ 实例C    │ ✅ 健康
└────────┘              └──────────┘
```

### 9.2 两种健康检查模式


#### 模式1：客户端心跳（临时实例）


**工作原理**：服务实例每隔一段时间主动向Nacos发送心跳

```
心跳机制流程：
实例启动 → 注册到Nacos → 开始发送心跳

时间线：
t0: ❤️ 心跳正常
t1: ❤️ 心跳正常  
t2: ❤️ 心跳正常
t3: ❌ 超过15秒未收到心跳 → 标记不健康
t4: ❌ 超过30秒未收到心跳 → 从列表删除
```

**配置方式**：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        heart-beat-interval: 5000      # 心跳间隔5秒
        heart-beat-timeout: 15000      # 15秒未心跳标记不健康
        ip-delete-timeout: 30000       # 30秒未心跳删除实例
```

#### 模式2：服务端探测（持久化实例）


**工作原理**：Nacos主动向服务实例发送探测请求

```
探测机制流程：
实例注册 → Nacos定时探测

┌────────┐   探测请求   ┌──────────┐
│ Nacos  │ ─────────→  │ 实例     │
│        │              │          │
│        │ ←───────────│          │
│        │   响应OK     │          │
└────────┘              └──────────┘
           探测成功 → 标记健康

┌────────┐   探测请求   ┌──────────┐
│ Nacos  │ ─────────→  │ 实例     │
│        │              │ (宕机)   │
│        │ ✗ 无响应     │          │
└────────┘              └──────────┘
           探测失败 → 标记不健康
```

### 9.3 健康检查的核心参数


| 参数 | 默认值 | 说明 | 影响 |
|-----|-------|------|-----|
| **心跳间隔** | 5秒 | 发送心跳的时间间隔 | 间隔越短，检测越及时 |
| **健康阈值** | 15秒 | 多久未心跳标记不健康 | 阈值越小，容错性越低 |
| **删除阈值** | 30秒 | 多久未心跳删除实例 | 阈值越大，恢复机会越多 |
| **保护阈值** | 0.85 | 健康实例占比阈值 | 低于阈值触发保护 |

### 9.4 健康保护阈值


**什么是保护阈值？**

当健康实例占比**低于阈值**时，Nacos会进入**保护模式**，即使实例不健康也不会删除。

```
保护阈值场景：
总实例数：10个
健康实例：7个
保护阈值：0.85 (85%)

当前健康率：7/10 = 70% < 85%
触发保护模式：
❌ 不再删除不健康实例
❌ 所有实例(包括不健康)都可能被访问
⚠️ 目的：防止雪崩，宁可有损服务也不全部拒绝
```

**配置保护阈值**：

```yaml
spring:
  cloud:
    nacos:
      discovery:
        naming-load-cache-at-start: true
        # Nacos服务端配置(在控制台设置)
        # 保护阈值: 0.85
```

### 9.5 自定义健康检查


```java
// 实现自定义健康检查逻辑
@Component
public class CustomHealthChecker implements HealthIndicator {
    
    @Override
    public Health health() {
        // 自定义检查逻辑
        boolean databaseOk = checkDatabase();
        boolean redisOk = checkRedis();
        
        if (databaseOk && redisOk) {
            return Health.up()
                .withDetail("database", "ok")
                .withDetail("redis", "ok")
                .build();
        }
        
        return Health.down()
            .withDetail("database", databaseOk ? "ok" : "error")
            .withDetail("redis", redisOk ? "ok" : "error")
            .build();
    }
    
    private boolean checkDatabase() {
        // 检查数据库连接
        return true;
    }
    
    private boolean checkRedis() {
        // 检查Redis连接
        return true;
    }
}
```

---

## 10. 📋 核心要点总结


### 10.1 概念关系总结


```
从大到小的层级关系：
Namespace(命名空间) 
    → Group(分组) 
        → Service(服务) 
            → Cluster(集群) 
                → Instance(实例)

每个层级的用途：
├─ Namespace: 环境隔离(dev/test/prod)
├─ Group: 业务分类(电商/支付/后台)
├─ Service: 应用标识(user-service)
├─ Cluster: 区域划分(北京/上海)
└─ Instance: 具体节点(IP:Port)
```

### 10.2 关键配置速查


```yaml
# 完整配置示例
spring:
  application:
    name: user-service              # 服务名
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 # Nacos地址
        namespace: dev               # 命名空间
        group: SHOP_GROUP           # 分组
        cluster-name: BJ            # 集群
        weight: 1                   # 权重
        ephemeral: true             # 临时实例
        metadata:                   # 元数据
          version: 1.0.0
          region: beijing
```

### 10.3 实际应用建议


**① 环境隔离**
- ✅ 开发/测试/生产必须使用不同Namespace
- ✅ 防止配置混乱和误操作

**② 业务划分**
- ✅ 相关服务放在同一个Group
- ✅ 便于管理和监控

**③ 就近访问**
- ✅ 使用Cluster实现同机房优先访问
- ✅ 降低网络延迟

**④ 灰度发布**
- ✅ 利用权重控制流量比例
- ✅ 利用元数据标记灰度版本

**⑤ 健康检查**
- ✅ 设置合理的心跳间隔
- ✅ 配置适当的保护阈值

### 10.4 记忆口诀


```
命名空间分环境，分组管理更清晰
服务就是一应用，实例节点来运行
集群划分靠地域，权重控制流量比
元数据贴好标签，健康检查保可用
```

**核心要记住**：
- 🔹 Namespace = 环境隔离墙
- 🔹 Group = 业务分类器  
- 🔹 Service = 应用标识符
- 🔹 Cluster = 区域划分器
- 🔹 Instance = 具体执行者
- 🔹 Weight = 流量控制器
- 🔹 Metadata = 信息标签库
- 🔹 Health = 可用性守护者