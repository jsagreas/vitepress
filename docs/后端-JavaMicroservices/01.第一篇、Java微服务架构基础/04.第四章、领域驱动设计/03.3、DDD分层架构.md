---
title: 3、DDD分层架构
---
## 📚 目录

1. [什么是DDD分层架构](#1-什么是ddd分层架构)
2. [四层架构详解](#2-四层架构详解)
3. [仓储模式（Repository）](#3-仓储模式repository)
4. [领域服务与应用服务](#4-领域服务与应用服务)
5. [实际应用示例](#5-实际应用示例)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🏗️ 什么是DDD分层架构


### 1.1 DDD基本概念


**🔸 什么是DDD**
```
DDD = Domain-Driven Design（领域驱动设计）
简单理解：以业务领域为核心来设计软件系统的方法论
就像盖房子要先搞清楚房子的用途，再决定如何设计
```

**💡 为什么需要分层**
```
传统问题：
代码混乱 → 业务逻辑散落各处
难以维护 → 修改一个功能影响多个地方
难以测试 → 数据库、业务逻辑耦合紧密

DDD解决方案：
把不同职责的代码放在不同层次
每一层只关心自己的事情
层与层之间有明确的边界
```

### 1.2 分层架构的本质


**🎯 核心思想**：**关注点分离**
- **用户接口层**：处理用户交互（网页、API）
- **应用层**：编排业务流程（像指挥官）
- **领域层**：核心业务逻辑（真正的业务规则）
- **基础设施层**：技术实现（数据库、消息队列）

```
生活中的例子：餐厅运作
┌─────────────────┐
│    服务员       │ ← 用户接口层（接待客人）
├─────────────────┤
│    店长        │ ← 应用层（协调各部门）
├─────────────────┤
│    厨师        │ ← 领域层（核心业务：做菜）
├─────────────────┤
│ 厨房设备/食材   │ ← 基础设施层（工具支撑）
└─────────────────┘
```

---

## 2. 📋 四层架构详解


### 2.1 架构全景图


```
DDD分层架构示意图：

┌─────────────────────────────────────┐
│        用户接口层（UI Layer）         │
│  Controller、REST API、Web界面       │
│          ↓ 调用                     │
├─────────────────────────────────────┤
│        应用层（Application）         │
│    ApplicationService、工作流编排     │
│          ↓ 调用                     │
├─────────────────────────────────────┤
│         领域层（Domain）             │
│  Entity、ValueObject、DomainService  │
│          ↓ 依赖                     │
├─────────────────────────────────────┤
│      基础设施层（Infrastructure）     │
│   Repository实现、数据库、外部服务    │
└─────────────────────────────────────┘
```

### 2.2 用户接口层（UI Layer）


**🔸 职责说明**
```
主要工作：
✅ 接收用户请求（HTTP请求、页面操作）
✅ 参数校验和格式转换
✅ 调用应用层服务
✅ 返回响应结果

不应该做：
❌ 包含业务逻辑
❌ 直接操作数据库
❌ 复杂的数据处理
```

**💻 简单示例**
```java
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserApplicationService userAppService;
    
    @PostMapping("/register")
    public ResponseEntity<String> registerUser(@RequestBody UserDTO userDTO) {
        // 只负责接收请求和调用应用服务
        userAppService.registerUser(userDTO);
        return ResponseEntity.ok("注册成功");
    }
}
```

### 2.3 应用层（Application Layer）


**🔸 核心作用**
```
应用层就像一个"项目经理"：
✅ 协调各个领域对象完成业务流程
✅ 事务管理（保证数据一致性）
✅ 权限检查
✅ 调用外部服务

特点：
🔹 薄薄一层：不包含业务规则
🔹 编排者：组织领域对象协作
🔹 无状态：不保存业务状态
```

**🎯 应用服务特点**
```
Application Service的职责：
1️⃣ 接收来自用户接口层的请求
2️⃣ 验证权限和前置条件
3️⃣ 调用领域对象执行业务逻辑
4️⃣ 协调多个聚合根的操作
5️⃣ 提交或回滚事务
```

### 2.4 领域层（Domain Layer）


**🔸 业务核心**
```
领域层是整个系统的"大脑"：
✅ 包含核心业务逻辑和规则
✅ 领域实体（Entity）
✅ 值对象（Value Object）
✅ 领域服务（Domain Service）
✅ 聚合根（Aggregate Root）

重要原则：
🔹 独立于技术实现
🔹 专注业务规则
🔹 高内聚、低耦合
```

**💎 领域层组件**

| 组件类型 | **作用说明** | **举例** |
|---------|-------------|---------|
| 🏷️ **实体（Entity）** | `有唯一标识的业务对象` | `用户、订单、商品` |
| 💰 **值对象（Value Object）** | `描述性质的对象，无标识` | `金额、地址、姓名` |
| 🔧 **领域服务（Domain Service）** | `跨实体的业务逻辑` | `转账服务、库存分配` |
| 📦 **聚合根（Aggregate Root）** | `管理一组相关对象` | `订单管理其订单项` |

### 2.5 基础设施层（Infrastructure Layer）


**🔸 技术支撑**
```
基础设施层提供"工具和材料"：
✅ 数据库访问实现
✅ 外部服务调用
✅ 消息队列操作
✅ 文件存储
✅ 缓存服务

特点：
🔹 具体技术实现
🔹 可替换性强
🔹 服务于上层业务
```

---

## 3. 🗃️ 仓储模式（Repository）


### 3.1 仓储模式概念


**🔸 什么是Repository**
```
Repository = 仓库模式
简单理解：把数据库当作一个"仓库"，Repository是"仓库管理员"

作用：
✅ 封装数据访问逻辑
✅ 提供面向对象的数据操作接口
✅ 让领域层不依赖具体的数据库技术
```

**💡 生活中的类比**
```
就像图书馆：
📚 图书馆 = 数据库
👨‍💼 图书管理员 = Repository
📖 借书、还书 = CRUD操作

你不需要知道书具体放在哪个书架的哪层
只需要告诉管理员书名，他帮你找到
```

### 3.2 Repository接口设计


**🔧 接口定义（在领域层）**
```java
// 领域层定义接口
public interface UserRepository {
    
    // 根据ID查找用户
    User findById(UserId userId);
    
    // 根据邮箱查找用户
    User findByEmail(String email);
    
    // 保存用户
    void save(User user);
    
    // 删除用户
    void delete(UserId userId);
    
    // 检查邮箱是否已存在
    boolean existsByEmail(String email);
}
```

**⚙️ 实现类（在基础设施层）**
```java
// 基础设施层实现接口
@Repository
public class JpaUserRepository implements UserRepository {
    
    @Autowired
    private UserJpaRepository jpaRepository;
    
    @Override
    public User findById(UserId userId) {
        Optional<UserEntity> entity = jpaRepository.findById(userId.getValue());
        return entity.map(this::toDomain).orElse(null);
    }
    
    @Override
    public void save(User user) {
        UserEntity entity = toEntity(user);
        jpaRepository.save(entity);
    }
    
    // 实体转换方法...
}
```

### 3.3 Repository的优势


**🎯 为什么使用Repository**

| 优势 | **说明** | **好处** |
|------|---------|---------|
| 🔄 **技术无关** | `领域层不依赖具体数据库` | `可以随时换数据库` |
| 🧪 **易于测试** | `可以创建内存版本用于测试` | `单元测试更简单` |
| 📦 **封装复杂性** | `隐藏数据访问的复杂逻辑` | `业务代码更清晰` |
| 🔧 **统一接口** | `标准化的数据操作方法` | `代码更规范` |

---

## 4. ⚡ 领域服务与应用服务


### 4.1 两种服务的区别


**🔸 核心区别**
```
领域服务（Domain Service）：
🎯 包含业务规则和逻辑
🎯 解决跨实体的业务问题
🎯 属于领域层
🎯 例：转账业务逻辑

应用服务（Application Service）：
📋 编排和协调工作流程
📋 不包含业务规则
📋 属于应用层
📋 例：用户注册流程编排
```

**💡 比喻说明**
```
建房子的例子：

领域服务 = 建筑工程师
- 知道如何设计房屋结构
- 懂得建筑规范和技术要求
- 专业的建筑知识

应用服务 = 项目经理
- 协调各个工种的工作
- 安排施工顺序和进度
- 不需要懂具体的建筑技术
```

### 4.2 领域服务（Domain Service）


**🔧 使用场景**
```
什么时候需要领域服务：
1️⃣ 业务逻辑不属于任何单一实体
2️⃣ 需要协调多个实体的操作
3️⃣ 复杂的业务规则计算
4️⃣ 跨聚合的业务操作
```

**📝 代码示例**
```java
@Service
public class TransferDomainService {
    
    // 转账业务逻辑
    public void transfer(Account fromAccount, Account toAccount, Money amount) {
        
        // 业务规则检查
        if (!fromAccount.canWithdraw(amount)) {
            throw new InsufficientBalanceException("余额不足");
        }
        
        if (amount.isNegativeOrZero()) {
            throw new InvalidAmountException("转账金额必须大于0");
        }
        
        // 执行转账
        fromAccount.withdraw(amount);
        toAccount.deposit(amount);
        
        // 记录转账记录
        TransferRecord record = new TransferRecord(fromAccount.getId(), 
            toAccount.getId(), amount, LocalDateTime.now());
    }
}
```

### 4.3 应用服务（Application Service）


**🔧 主要职责**
```
应用服务的工作内容：
1️⃣ 接收用户请求
2️⃣ 参数验证和转换
3️⃣ 权限检查
4️⃣ 调用领域对象和领域服务
5️⃣ 事务管理
6️⃣ 返回结果
```

**📝 代码示例**
```java
@Service
@Transactional
public class UserApplicationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    // 用户注册流程编排
    public void registerUser(RegisterUserCommand command) {
        
        // 1. 验证邮箱是否已存在
        if (userRepository.existsByEmail(command.getEmail())) {
            throw new EmailAlreadyExistsException("邮箱已被注册");
        }
        
        // 2. 创建用户实体
        User user = new User(
            command.getUsername(),
            command.getEmail(),
            command.getPassword()
        );
        
        // 3. 保存用户
        userRepository.save(user);
        
        // 4. 发送欢迎邮件
        emailService.sendWelcomeEmail(user.getEmail());
        
        // 注意：这里没有复杂的业务逻辑，只是流程编排
    }
}
```

### 4.4 服务协作图


```
用户注册流程示意：

用户界面层                应用层                    领域层                基础设施层
    │                      │                        │                      │
    │──注册请求────────────→│                        │                      │
    │                      │                        │                      │
    │                      │──检查邮箱重复─────────→│                      │
    │                      │←─检查结果──────────────│                      │
    │                      │                        │                      │
    │                      │──创建用户实体─────────→│                      │
    │                      │←─用户对象──────────────│                      │
    │                      │                        │                      │
    │                      │──保存用户──────────────┼─────────────────────→│
    │                      │←─保存完成──────────────┼──────────────────────│
    │                      │                        │                      │
    │                      │──发送邮件──────────────┼─────────────────────→│
    │                      │                        │                      │
    │←─注册成功─────────────│                        │                      │
```

---

## 5. 🎯 实际应用示例


### 5.1 电商订单系统分层


**🛒 业务场景：创建订单**

```
分层职责分配：

用户接口层：OrderController
├── 接收下单请求
├── 参数验证
└── 调用应用服务

应用层：OrderApplicationService  
├── 库存检查
├── 价格计算协调
├── 订单创建流程
└── 支付调用

领域层：Order、OrderItem、Product
├── 订单业务规则
├── 价格计算逻辑
└── 库存扣减规则

基础设施层：OrderRepository、PaymentService
├── 数据库操作
├── 外部支付接口
└── 消息发送
```

### 5.2 完整示例代码结构


**🏗️ 项目结构**
```
src/
├── main/java/com/example/
│   ├── interfaces/          # 用户接口层
│   │   └── OrderController.java
│   ├── application/         # 应用层
│   │   └── OrderApplicationService.java
│   ├── domain/             # 领域层
│   │   ├── entity/
│   │   │   ├── Order.java
│   │   │   └── Product.java
│   │   ├── service/
│   │   │   └── PricingDomainService.java
│   │   └── repository/
│   │       └── OrderRepository.java
│   └── infrastructure/     # 基础设施层
│       ├── repository/
│       │   └── JpaOrderRepository.java
│       └── external/
│           └── PaymentServiceImpl.java
```

### 5.3 层间调用关系


**📊 依赖关系表**

| 层次 | **可以调用** | **不能调用** | **原因** |
|------|-------------|-------------|----------|
| 🖥️ **用户接口层** | `应用层` | `领域层、基础设施层` | `保持单一职责` |
| 📋 **应用层** | `领域层、基础设施层` | `用户接口层` | `避免循环依赖` |
| 💎 **领域层** | `无` | `其他所有层` | `保持纯净性` |
| 🔧 **基础设施层** | `领域层` | `应用层、用户接口层` | `提供底层支撑` |

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 DDD分层架构：四层结构，职责分明
🔸 用户接口层：负责用户交互，不含业务逻辑
🔸 应用层：流程编排，事务管理，薄薄一层
🔸 领域层：核心业务逻辑，系统的大脑
🔸 基础设施层：技术实现，可替换的工具
🔸 Repository模式：数据访问的抽象，技术无关
🔸 领域服务：跨实体的业务逻辑
🔸 应用服务：业务流程的编排者
```

### 6.2 关键理解要点


**🔹 分层的核心目的**
```
关注点分离：
- 每层专注自己的职责
- 降低系统复杂度
- 提高代码可维护性
- 便于单元测试

技术无关性：
- 业务逻辑独立于技术实现
- 可以灵活更换底层技术
- 核心业务规则稳定不变
```

**🔹 Repository的价值**
```
抽象数据访问：
- 领域层不知道数据存在哪里
- 可以是数据库、文件、内存
- 测试时可以用假的实现
- 业务代码更加纯净
```

**🔹 两种服务的区别**
```
领域服务：
🎯 包含业务知识
🎯 解决业务问题
🎯 例：计算折扣、验证规则

应用服务：
📋 协调工作流程
📋 不包含业务逻辑
📋 例：注册流程、下单流程
```

### 6.3 实际应用指导


**💡 设计原则**
- **依赖倒置**：高层模块不依赖低层模块
- **单一职责**：每层只做自己该做的事
- **开闭原则**：对扩展开放，对修改封闭
- **接口隔离**：使用抽象接口而非具体实现

**🔧 实践建议**
- **从领域层开始设计**：先理清业务逻辑
- **保持领域层纯净**：不引入技术框架
- **应用服务要薄**：只做流程编排
- **Repository接口放在领域层**：实现放在基础设施层

**⚠️ 常见误区**
- ❌ 在Controller中写业务逻辑
- ❌ 领域对象直接依赖数据库
- ❌ 应用服务包含复杂业务规则
- ❌ 基础设施层调用应用层

**核心记忆**：
- DDD分层像建房子，每层有各自的作用
- Repository是数据仓库管理员，领域层定接口
- 领域服务管业务规则，应用服务管工作流程
- 分层的目的是关注点分离，让代码更清晰好维护