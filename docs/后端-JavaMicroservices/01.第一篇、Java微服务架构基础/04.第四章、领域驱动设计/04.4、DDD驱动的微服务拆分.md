---
title: 4、DDD驱动的微服务拆分
---
## 📚 目录

1. [DDD与微服务的天然契合](#1-DDD与微服务的天然契合)
2. [服务边界识别策略](#2-服务边界识别策略)
3. [聚合根映射到微服务](#3-聚合根映射到微服务)
4. [跨上下文通信设计](#4-跨上下文通信设计)
5. [领域事件驱动架构](#5-领域事件驱动架构)
6. [上下文映射策略](#6-上下文映射策略)
7. [团队协作边界划分](#7-团队协作边界划分)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 DDD与微服务的天然契合


### 1.1 为什么DDD和微服务是天生一对


**简单来说**，DDD（领域驱动设计）就像是给业务建模的方法，而微服务就像是实现这个模型的技术手段。它们配合起来就像**"业务专家画图纸，开发团队按图施工"**。

```
传统单体应用的问题：
┌─────────────────────────────────────┐
│        一个大系统                    │
│  用户管理+订单+库存+支付+物流        │
│  所有功能混在一起，改一处动全身       │
└─────────────────────────────────────┘

DDD+微服务的解决方案：
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 用户服务 │  │ 订单服务 │  │ 库存服务 │
│         │  │         │  │         │
└─────────┘  └─────────┘  └─────────┘
各自独立，职责清晰，互不干扰
```

### 1.2 DDD的核心思想回顾


**领域驱动设计**本质就是**"让代码结构反映业务结构"**：

- **🏢 限界上下文**：就像公司的各个部门，每个部门有自己的职责范围
- **📦 聚合**：就像部门内的小组，相关的业务逻辑打包在一起
- **👑 聚合根**：就像小组长，负责管理整个小组的对外接口
- **🎭 实体和值对象**：就像员工和工作资料，有些重要需要身份标识，有些只看内容

### 1.3 微服务拆分的痛点


**没有DDD指导的微服务拆分**常常会出现这些问题：

```
❌ 常见错误拆分方式：

按技术层拆分：
- 数据库服务
- 业务逻辑服务  
- 界面服务
→ 结果：一个业务改动需要改3个服务

按数据表拆分：
- 用户表服务
- 订单表服务
- 商品表服务
→ 结果：业务逻辑散落各处，维护困难

✅ DDD指导的正确拆分：
按业务能力（限界上下文）拆分：
- 用户管理上下文 → 用户服务
- 订单处理上下文 → 订单服务
- 库存管理上下文 → 库存服务
```

---

## 2. 🔍 服务边界识别策略


### 2.1 通过事件风暴识别边界


**事件风暴**就像是把所有相关人员聚在一起"头脑风暴"，找出业务中的关键事件。

**操作步骤**：
1. **🎪 召集人员**：业务专家、产品经理、开发人员一起参与
2. **📝 列出领域事件**：用过去时描述发生的业务事件
3. **🎯 识别命令**：什么操作触发了这些事件
4. **👥 找出角色**：谁执行这些命令
5. **📋 划分聚合**：相关的命令和事件归为一组

```
电商系统事件风暴示例：

用户注册上下文：
事件：用户已注册、邮箱已验证、密码已重置
命令：注册用户、验证邮箱、重置密码
角色：访客、已注册用户

订单处理上下文：  
事件：订单已创建、订单已支付、订单已发货
命令：创建订单、支付订单、发货订单
角色：买家、卖家、物流人员

库存管理上下文：
事件：库存已扣减、库存已补充、库存已预留
命令：扣减库存、补充库存、预留库存
角色：仓库管理员、采购员
```

### 2.2 识别限界上下文边界


**限界上下文**就像是**"业务的势力范围"**，在这个范围内，大家对同一个词的理解是一致的。

**边界识别原则**：

| 识别标准 | 说明 | 示例 |
|---------|------|------|
| **📚 通用语言一致性** | 同一概念在上下文内含义统一 | "用户"在用户管理中指注册用户，在订单中指买家 |
| **🔄 业务流程完整性** | 一个完整的业务流程应在同一上下文 | 从下单到支付的完整流程 |
| **👥 团队职责边界** | 不同团队负责不同的业务领域 | 用户团队、订单团队、支付团队 |
| **📊 数据一致性要求** | 强一致性需求的数据归为一组 | 订单金额和订单项必须强一致 |

### 2.3 上下文边界划分实例


**电商平台的上下文划分**：

```
┌─────────────────────────────────────────────────────────┐
│                    电商平台                              │
├─────────────┬─────────────┬─────────────┬─────────────┤
│  用户管理    │   商品目录   │   订单处理   │   支付处理   │
│  上下文     │   上下文     │   上下文     │   上下文     │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ • 用户注册   │ • 商品信息   │ • 购物车     │ • 支付订单   │
│ • 用户认证   │ • 价格管理   │ • 下单       │ • 退款       │
│ • 权限管理   │ • 库存查询   │ • 订单状态   │ • 对账       │
│ • 用户画像   │ • 分类管理   │ • 物流跟踪   │ • 风控       │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

**判断是否需要拆分的经验法则**：

```
🤔 需要拆分的信号：
- 团队经常因为代码冲突而等待
- 同一个概念在不同地方有不同含义
- 修改一个功能需要改动多个地方
- 不同功能的发布周期差异很大

✅ 边界合理的标志：
- 团队可以独立开发和部署
- 概念含义在上下文内清晰一致
- 对外接口稳定，内部实现可独立演化
- 失败影响范围可控
```

---

## 3. 📦 聚合根映射到微服务


### 3.1 聚合根的本质理解


**聚合根**就像是**"对外的代言人"**，外部世界只能通过它来访问聚合内的其他对象。

**聚合根的特征**：
- **🎯 唯一标识**：有全局唯一的ID
- **🚪 统一入口**：外部只能通过聚合根访问聚合内容
- **🛡️ 业务不变性**：保证聚合内的业务规则不被破坏
- **📊 事务边界**：一个事务只能操作一个聚合根

### 3.2 聚合识别的实践方法


**步骤1：从业务不变性开始**

```java
// 订单聚合示例
public class Order {  // 聚合根
    private OrderId id;                    // 唯一标识
    private List<OrderItem> items;         // 聚合内实体
    private OrderStatus status;            // 值对象
    private Money totalAmount;             // 值对象
    
    // 业务不变性：订单总金额必须等于所有订单项金额之和
    public void addItem(ProductId productId, Quantity quantity, Money price) {
        OrderItem item = new OrderItem(productId, quantity, price);
        this.items.add(item);
        this.totalAmount = calculateTotalAmount(); // 保证不变性
    }
    
    // 只有聚合根可以改变聚合状态
    public void confirmOrder() {
        if (this.items.isEmpty()) {
            throw new IllegalStateException("空订单不能确认");
        }
        this.status = OrderStatus.CONFIRMED;
    }
}
```

**步骤2：识别聚合边界**

```
订单聚合边界分析：

✅ 应该在同一个聚合内：
- Order（订单） + OrderItem（订单项）
  → 强业务关联，订单项不能脱离订单存在
  → 总金额计算需要强一致性

❌ 不应该在同一个聚合内：
- Order（订单） + Product（商品）
  → 订单引用商品，但不拥有商品
  → 商品有独立的生命周期
  → 只需要商品ID引用即可
```

### 3.3 聚合到微服务的映射策略


**映射原则**：**一个聚合根对应一个微服务的核心实体**

```
聚合根映射示例：

用户聚合根 → 用户微服务
├── User（用户）
├── UserProfile（用户资料）
└── UserPreference（用户偏好）

订单聚合根 → 订单微服务  
├── Order（订单）
├── OrderItem（订单项）
└── DeliveryInfo（配送信息）

商品聚合根 → 商品微服务
├── Product（商品）
├── ProductCategory（商品分类）
└── PriceStrategy（价格策略）
```

**服务粒度的把握**：

| 粒度 | 特征 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| **粗粒度** | 多个聚合在一个服务 | 部署简单，性能好 | 团队耦合，扩展困难 | 小团队，业务简单 |
| **细粒度** | 一个聚合一个服务 | 团队独立，扩展灵活 | 复杂度高，网络开销 | 大团队，业务复杂 |
| **中等粒度** | 相关聚合组成服务 | 平衡复杂度和灵活性 | 需要仔细设计边界 | **推荐方式** |

---

## 4. 🌐 跨上下文通信设计


### 4.1 通信模式选择


**同步通信 vs 异步通信**的选择就像**"打电话 vs 发短信"**：

```
同步通信（如HTTP调用）：
客户端 ──[请求]──> 服务端
       <──[响应]──

特点：立即得到结果，但会等待
适用：查询操作，需要立即反馈的场景

异步通信（如消息队列）：
发送方 ──[消息]──> 队列 ──[消息]──> 接收方

特点：不用等待，但结果延迟
适用：批量处理，不需要立即反馈的场景
```

### 4.2 API设计原则


**RESTful API设计**遵循"资源"的思想：

```java
// 好的API设计示例
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    // 获取用户的订单列表 - 查询操作
    @GetMapping
    public List<OrderDTO> getUserOrders(@RequestParam String userId) {
        return orderService.findOrdersByUserId(userId);
    }
    
    // 创建新订单 - 命令操作
    @PostMapping
    public OrderDTO createOrder(@RequestBody CreateOrderRequest request) {
        return orderService.createOrder(request);
    }
    
    // 更新订单状态 - 命令操作
    @PutMapping("/{orderId}/status")
    public void updateOrderStatus(@PathVariable String orderId, 
                                 @RequestBody UpdateStatusRequest request) {
        orderService.updateOrderStatus(orderId, request.getStatus());
    }
}
```

**API版本管理策略**：

```
版本演进示例：

v1: /api/v1/users
- 基础用户信息

v2: /api/v2/users  
- 增加用户偏好设置
- 保持v1兼容性

v3: /api/v3/users
- 重构用户模型
- 废弃v1，保持v2一段时间
```

### 4.3 服务间依赖管理


**依赖方向设计**：

```
正确的依赖方向：
┌─────────┐    ┌─────────┐    ┌─────────┐
│  订单   │───>│  用户   │    │  支付   │
│  服务   │    │  服务   │<───│  服务   │
└─────────┘    └─────────┘    └─────────┘
     │              ^              │
     │              │              │
     └──────────────┼──────────────┘
                    │
             核心业务服务，被其他服务依赖

错误的循环依赖：
┌─────────┐    ┌─────────┐
│  服务A  │<──>│  服务B  │
└─────────┘    └─────────┘
互相依赖，难以独立部署和测试
```

**防腐层模式**：

```java
// 防腐层 - 适配外部服务的接口
@Component
public class UserServiceAdapter {
    
    @Autowired
    private ExternalUserService externalUserService;
    
    // 将外部服务的数据格式转换为内部格式
    public User getUserById(String userId) {
        ExternalUser externalUser = externalUserService.getUser(userId);
        return convertToInternalUser(externalUser);
    }
    
    private User convertToInternalUser(ExternalUser external) {
        return User.builder()
            .id(external.getUserId())
            .name(external.getFullName())
            .email(external.getEmailAddress())
            .build();
    }
}
```

---

## 5. ⚡ 领域事件驱动架构


### 5.1 什么是领域事件


**领域事件**就像是**"业务世界发生的重要事情的通知"**，比如"用户已注册"、"订单已支付"、"商品已发货"。

**事件的特点**：
- **📅 过去时态**：描述已经发生的事情
- **🎯 业务含义**：具有明确的业务意义
- **📤 发布订阅**：发布者不需要知道谁在监听
- **🔄 最终一致性**：允许数据在一段时间后达到一致

### 5.2 事件设计原则


**事件命名规范**：

```
✅ 好的事件命名：
- UserRegistered（用户已注册）
- OrderPaymentCompleted（订单支付已完成）
- ProductStockReduced（商品库存已减少）

❌ 不好的事件命名：
- UserEvent（含义不明确）
- ProcessOrder（这是命令，不是事件）
- UpdateInventory（这是操作，不是结果）
```

**事件数据设计**：

```java
// 领域事件基类
public abstract class DomainEvent {
    private final String eventId;
    private final LocalDateTime occurredOn;
    private final String aggregateId;
    
    protected DomainEvent(String aggregateId) {
        this.eventId = UUID.randomUUID().toString();
        this.occurredOn = LocalDateTime.now();
        this.aggregateId = aggregateId;
    }
}

// 具体的领域事件
public class OrderPaymentCompleted extends DomainEvent {
    private final String orderId;
    private final String userId;
    private final BigDecimal amount;
    private final String paymentMethod;
    
    public OrderPaymentCompleted(String orderId, String userId, 
                               BigDecimal amount, String paymentMethod) {
        super(orderId);
        this.orderId = orderId;
        this.userId = userId;
        this.amount = amount;
        this.paymentMethod = paymentMethod;
    }
    
    // getters...
}
```

### 5.3 事件发布和订阅


**事件发布模式**：

```java
// 聚合根中发布事件
public class Order {
    private List<DomainEvent> domainEvents = new ArrayList<>();
    
    public void confirmPayment(BigDecimal amount, String paymentMethod) {
        this.status = OrderStatus.PAID;
        
        // 发布领域事件
        this.domainEvents.add(new OrderPaymentCompleted(
            this.id, this.userId, amount, paymentMethod
        ));
    }
    
    public List<DomainEvent> getAndClearDomainEvents() {
        List<DomainEvent> events = new ArrayList<>(this.domainEvents);
        this.domainEvents.clear();
        return events;
    }
}

// 应用服务中处理事件发布
@Service
public class OrderApplicationService {
    
    @Autowired
    private DomainEventPublisher eventPublisher;
    
    @Transactional
    public void confirmOrderPayment(String orderId, PaymentInfo paymentInfo) {
        Order order = orderRepository.findById(orderId);
        order.confirmPayment(paymentInfo.getAmount(), paymentInfo.getMethod());
        
        orderRepository.save(order);
        
        // 发布聚合中的事件
        order.getAndClearDomainEvents().forEach(eventPublisher::publish);
    }
}
```

**事件订阅处理**：

```java
// 事件处理器
@Component
public class OrderEventHandler {
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private NotificationService notificationService;
    
    // 处理订单支付完成事件
    @EventListener
    public void handleOrderPaymentCompleted(OrderPaymentCompleted event) {
        // 扣减库存
        inventoryService.reduceStock(event.getOrderId());
        
        // 发送通知
        notificationService.sendPaymentConfirmation(
            event.getUserId(), event.getAmount()
        );
    }
}
```

### 5.4 事件驱动的优势


**传统调用 vs 事件驱动对比**：

```
传统同步调用方式：
订单服务 ──┐
          ├─> 库存服务（扣减库存）
          ├─> 通知服务（发送邮件）
          └─> 积分服务（增加积分）

问题：任何一个服务失败，整个操作失败

事件驱动方式：
订单服务 ──> 事件：订单已支付
             │
             ├─> 库存服务（异步处理）
             ├─> 通知服务（异步处理）
             └─> 积分服务（异步处理）

优势：订单支付成功后，其他处理异步进行，互不影响
```

---

## 6. 🗺️ 上下文映射策略


### 6.1 上下文间关系类型


**上下文映射**就像是**"外交关系"**，定义不同上下文之间如何协作。

**常见映射关系**：

```
合作关系（Partnership）：
┌─────────┐ ←──协作──→ ┌─────────┐
│ 上下文A │             │ 上下文B │
└─────────┘             └─────────┘
双方平等合作，共同演进接口

客户-供应商（Customer-Supplier）：
┌─────────┐ ──需求──→ ┌─────────┐
│  客户   │ ←──服务─── │ 供应商  │
└─────────┘           └─────────┘
供应商为客户提供服务，客户影响供应商发展

遵循者（Conformist）：
┌─────────┐ ──遵循──→ ┌─────────┐
│ 遵循者  │           │ 上游    │
└─────────┘           └─────────┘
完全遵循上游系统的模型，无影响力

防腐层（Anti-Corruption Layer）：
┌─────────┐ ──适配──→ ┌─────────┐
│ 内部系统│           │ 外部系统│
└─────────┘           └─────────┘
通过适配层隔离外部系统的复杂性
```

### 6.2 实际映射策略选择


**电商系统上下文映射示例**：

```
用户上下文 ←──客户-供应商──→ 订单上下文
- 订单上下文是客户，需要用户信息
- 用户上下文是供应商，提供用户验证服务
- 用户上下文会考虑订单上下文的需求

订单上下文 ──防腐层──→ 支付上下文（第三方）
- 支付是第三方系统，无法改变其接口
- 订单上下文通过防腐层适配支付接口
- 内部支付模型与第三方支付模型隔离

商品上下文 ←──合作关系──→ 库存上下文
- 商品和库存需要紧密协作
- 共同设计商品-库存的接口模型
- 双方都有平等的话语权
```

### 6.3 接口演进策略


**向后兼容的接口设计**：

```java
// V1版本的接口
public class UserInfoV1 {
    private String userId;
    private String userName;
    private String email;
    // getters and setters
}

// V2版本 - 添加新字段，保持向后兼容
public class UserInfoV2 {
    private String userId;
    private String userName;
    private String email;
    private String phoneNumber;    // 新增字段
    private UserPreference preference; // 新增字段
    
    // 提供V1兼容的构造方法
    public static UserInfoV2 fromV1(UserInfoV1 v1) {
        UserInfoV2 v2 = new UserInfoV2();
        v2.setUserId(v1.getUserId());
        v2.setUserName(v1.getUserName());
        v2.setEmail(v1.getEmail());
        return v2;
    }
}
```

**接口废弃策略**：

```
接口演进时间线：

第1阶段：发布新版本接口 V2
- 同时保持 V1 和 V2
- 通知客户端开始迁移

第2阶段：标记 V1 为废弃
- 在 V1 接口添加 @Deprecated 注解
- 文档中说明废弃时间

第3阶段：停止 V1 支持
- 移除 V1 接口代码
- 只保留 V2 及以后版本
```

---

## 7. 👥 团队协作边界划分


### 7.1 康威定律在微服务中的应用


**康威定律**：*"设计系统的架构受制于产生这些设计的组织的沟通结构"*

**通俗解释**：**团队怎么分工，系统架构就会变成什么样子**。

```
传统组织结构 → 对应的系统架构：

前端团队 ────────────> 前端系统
后端团队 ────────────> 后端系统  
数据库团队 ──────────> 数据库系统
测试团队 ────────────> 测试系统

结果：按技术分层，业务逻辑分散

微服务团队结构 → 对应的系统架构：

用户团队 ────────────> 用户微服务
订单团队 ────────────> 订单微服务
支付团队 ────────────> 支付微服务
库存团队 ────────────> 库存微服务

结果：按业务能力组织，职责清晰
```

### 7.2 团队拓扑结构设计


**流线型团队**（推荐模式）：

```
流线型团队特征：
┌─────────────────────────────────────┐
│        订单团队（5-8人）             │
├─────────────────────────────────────┤
│ • 产品负责人（1人）                  │
│ • 全栈开发工程师（3-4人）            │
│ • 测试工程师（1人）                  │
│ • 运维工程师（1人）                  │
├─────────────────────────────────────┤
│ 负责：订单微服务从设计到运维的全流程  │
└─────────────────────────────────────┘

优势：
✅ 端到端负责，减少沟通成本
✅ 快速响应业务变化
✅ 团队有完整的技能栈
```

**团队间协作模式**：

```
协作模式分类：

紧密协作：
用户团队 ←→ 订单团队
- 接口设计需要频繁沟通
- 共同参与需求分析
- 适用于业务关联度高的服务

松散协作：
订单团队 → 通知团队
- 通过标准接口交互
- 定期同步接口变更
- 适用于通用性服务

使能协作：
平台团队 → 业务团队
- 平台团队提供基础设施
- 业务团队专注业务逻辑
- 适用于技术平台服务
```

### 7.3 团队自治和治理平衡


**团队自治权限**：

| 自治范围 | 团队权限 | 平台约束 | 示例 |
|---------|----------|----------|------|
| **技术选型** | 选择框架和库 | 符合公司技术栈 | Spring Boot, React |
| **数据存储** | 选择数据库类型 | 遵循数据治理规范 | MySQL, Redis, MongoDB |
| **部署发布** | 独立部署节奏 | 遵循CI/CD流程 | 每日发布，蓝绿部署 |
| **监控告警** | 自定义监控指标 | 使用统一监控平台 | Prometheus, Grafana |

**平台治理规范**：

```java
// 统一的服务接口规范
@RestController
@Api(tags = "订单管理")
public class OrderController {
    
    // 统一的响应格式
    @GetMapping("/{orderId}")
    public ApiResponse<OrderDTO> getOrder(@PathVariable String orderId) {
        OrderDTO order = orderService.getOrderById(orderId);
        return ApiResponse.success(order);
    }
    
    // 统一的异常处理
    @ExceptionHandler(OrderNotFoundException.class)
    public ApiResponse<Void> handleOrderNotFound(OrderNotFoundException e) {
        return ApiResponse.error("ORDER_NOT_FOUND", e.getMessage());
    }
}

// 统一的响应格式
public class ApiResponse<T> {
    private boolean success;
    private String errorCode;
    private String message;
    private T data;
    
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, null, null, data);
    }
    
    public static <T> ApiResponse<T> error(String errorCode, String message) {
        return new ApiResponse<>(false, errorCode, message, null);
    }
}
```

### 7.4 团队演进策略


**团队成长路径**：

```
阶段1：中心化团队（启动阶段）
┌─────────────────┐
│   架构师团队     │ ──设计──→ 各业务团队
└─────────────────┘
集中设计架构，指导各团队实施

阶段2：辅助模式（成长阶段）  
┌─────────────────┐
│   平台团队       │ ──支持──→ 各业务团队
└─────────────────┘
提供平台服务，业务团队专注业务

阶段3：自治模式（成熟阶段）
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 用户团队 │  │ 订单团队 │  │ 支付团队 │
└─────────┘  └─────────┘  └─────────┘
各团队完全自治，通过治理规范协调
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 DDD核心思想：让软件结构反映业务结构
🔸 服务边界识别：通过事件风暴和限界上下文划分
🔸 聚合根映射：一个聚合根对应一个微服务核心
🔸 跨上下文通信：同步查询 + 异步事件的组合模式
🔸 领域事件驱动：用事件实现最终一致性
🔸 上下文映射：定义服务间的协作关系
🔸 团队边界：团队结构决定系统架构
```

### 8.2 实践要点速查


**🔹 服务拆分检查清单**
```
✅ 每个服务有明确的业务边界
✅ 服务间通过标准接口通信
✅ 一个团队能够独立维护
✅ 数据库不跨服务共享
✅ 失败影响范围可控
✅ 可以独立部署和扩展
```

**🔹 领域事件设计原则**
```
✅ 事件名称用过去时态
✅ 包含必要的业务数据
✅ 事件是不可变的
✅ 发布者不依赖订阅者
✅ 支持事件重放和幂等处理
```

**🔹 团队协作最佳实践**
```
✅ 明确团队的服务边界
✅ 建立标准的接口规范
✅ 定期进行跨团队沟通
✅ 建立统一的技术平台
✅ 平衡自治和治理
```

### 8.3 常见问题和解决方案


**❓ 服务拆分过细怎么办？**
```
现象：服务数量过多，部署复杂，性能下降
解决：
1. 合并高度相关的服务
2. 识别共享的数据访问模式
3. 考虑使用单体优先策略
```

**❓ 数据一致性如何保证？**
```
解决方案：
1. 强一致性：在同一个聚合内
2. 最终一致性：通过领域事件
3. Saga模式：处理跨服务事务
4. 补偿机制：处理失败场景
```

**❓ 服务间调用太复杂？**
```
解决方案：
1. 减少同步调用，增加异步事件
2. 使用API网关统一入口
3. 实施服务网格管理通信
4. 建立服务依赖图谱
```

### 8.4 学习进阶建议


**🎯 下一步学习重点**：
- **事件溯源**：Event Sourcing模式深入理解
- **CQRS模式**：命令查询责任分离
- **Saga模式**：分布式事务处理
- **服务网格**：Istio等基础设施
- **API网关**：统一的服务入口管理

**💡 实践建议**：
- 从小项目开始练习DDD建模
- 逐步重构现有单体应用
- 建立团队的DDD共同语言
- 持续优化服务边界设计

**核心记忆口诀**：
- DDD建模找边界，聚合根里藏服务
- 事件驱动解耦合，最终一致不用急
- 团队架构相对应，康威定律要牢记
- 自治治理两平衡，演进路径步步移