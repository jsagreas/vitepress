---
title: 8、电商系统拆分示例
---
## 📚 目录

1. [电商系统拆分概述](#1-电商系统拆分概述)
2. [用户服务设计](#2-用户服务设计)
3. [商品服务边界](#3-商品服务边界)
4. [订单服务拆分](#4-订单服务拆分)
5. [支付服务独立](#5-支付服务独立)
6. [库存服务职责](#6-库存服务职责)
7. [服务间协作模式](#7-服务间协作模式)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛒 电商系统拆分概述


### 1.1 传统单体架构的问题


想象你开了一家网店，刚开始所有功能都写在一个大程序里：

```
传统单体电商系统结构：
┌─────────────────────────────────────┐
│          电商单体应用               │
│  ┌─────────┬─────────┬─────────┐   │
│  │用户管理 │商品管理 │订单管理 │   │
│  ├─────────┼─────────┼─────────┤   │
│  │支付处理 │库存管理 │物流跟踪 │   │
│  └─────────┴─────────┴─────────┘   │
└─────────────────────────────────────┘
```

**单体架构的痛点**：
- 🔴 **部署困难**：改一个小功能，整个系统都要重新部署
- 🔴 **扩展受限**：用户量大时，整个系统都要扩容，浪费资源
- 🔴 **技术固化**：所有功能必须用同一种技术栈
- 🔴 **故障影响大**：一个模块出问题，整个网站都崩了

### 1.2 微服务拆分的目标


> 💡 **拆分思路**：把一个大系统拆成多个小系统，每个小系统只负责一块业务

**拆分后的电商架构**：
```
微服务电商系统架构：
        用户请求
           │
    ┌─────────────┐
    │  API网关    │ ← 统一入口
    └─────────────┘
           │
    ┌──────┼──────┐
    │      │      │
┌───▼──┐ ┌─▼──┐ ┌─▼──┐
│用户  │ │商品│ │订单│
│服务  │ │服务│ │服务│
└───┬──┘ └─┬──┘ └─┬──┘
    │      │      │
┌───▼──┐ ┌─▼──┐ ┌─▼──┐
│支付  │ │库存│ │物流│
│服务  │ │服务│ │服务│
└──────┘ └────┘ └────┘
```

**拆分的好处**：
- ✅ **独立部署**：每个服务可以单独更新
- ✅ **按需扩展**：哪个服务压力大就扩展哪个
- ✅ **技术多样**：不同服务可以用不同技术
- ✅ **故障隔离**：一个服务挂了不影响其他服务

---

## 2. 👥 用户服务设计


### 2.1 用户服务的核心职责


用户服务就像是网站的"身份证管理中心"，专门负责用户相关的所有事情。

**🔑 核心功能**：
```
用户服务功能边界：
┌─────────────────────────────┐
│         用户服务             │
├─────────────────────────────┤
│ 🔐 用户注册/登录            │
│ 👤 个人信息管理             │
│ 🏠 收货地址管理             │
│ 🔒 密码修改/找回            │
│ 📱 手机/邮箱验证            │
│ 🎭 用户角色权限             │
└─────────────────────────────┘
```

### 2.2 用户服务数据模型


**简化的用户表设计**：
```java
// 用户基本信息
class User {
    private Long userId;        // 用户ID
    private String username;    // 用户名
    private String password;    // 密码(加密)
    private String email;       // 邮箱
    private String phone;       // 手机号
    private String nickname;    // 昵称
    private Date createTime;    // 注册时间
}

// 用户地址信息
class UserAddress {
    private Long addressId;     // 地址ID
    private Long userId;        // 用户ID
    private String province;    // 省份
    private String city;        // 城市
    private String district;    // 区县
    private String detail;      // 详细地址
    private Boolean isDefault;  // 是否默认地址
}
```

### 2.3 用户服务的边界原则


> 📌 **重要原则**：用户服务只管"这个人是谁"，不管"这个人买了什么"

**✅ 用户服务应该做的**：
- 验证用户身份（登录认证）
- 管理用户基本信息
- 提供用户查询接口

**❌ 用户服务不应该做的**：
- 不存储订单信息
- 不处理支付逻辑
- 不管理商品收藏（这个可以单独拆成服务）

**API 接口示例**：
```java
@RestController
public class UserController {
    
    // 用户注册
    @PostMapping("/users/register")
    public Result register(@RequestBody RegisterRequest request) {
        // 注册逻辑
    }
    
    // 用户登录
    @PostMapping("/users/login") 
    public Result login(@RequestBody LoginRequest request) {
        // 登录逻辑，返回token
    }
    
    // 获取用户信息
    @GetMapping("/users/{userId}")
    public Result getUserInfo(@PathVariable Long userId) {
        // 返回用户基本信息
    }
}
```

---

## 3. 📦 商品服务边界


### 3.1 商品服务的职责范围


商品服务就像是"商品目录管理员"，专门负责商品的基本信息。

**🏪 核心功能**：
```
商品服务功能边界：
┌─────────────────────────────┐
│         商品服务             │
├─────────────────────────────┤
│ 📋 商品基本信息管理         │
│ 🏷️ 商品分类管理            │
│ 🖼️ 商品图片管理            │
│ 🔍 商品搜索查询             │
│ ⭐ 商品评分统计             │
│ 🏪 商家信息管理             │
└─────────────────────────────┘
```

### 3.2 商品数据模型设计


**商品信息的核心表**：
```java
// 商品基本信息
class Product {
    private Long productId;      // 商品ID
    private String productName;  // 商品名称
    private String description;  // 商品描述
    private BigDecimal price;    // 商品价格
    private Long categoryId;     // 分类ID
    private Long sellerId;       // 商家ID
    private String brand;        // 品牌
    private ProductStatus status; // 商品状态(上架/下架)
}

// 商品分类
class Category {
    private Long categoryId;     // 分类ID
    private String categoryName; // 分类名称
    private Long parentId;       // 父分类ID
    private Integer level;       // 分类级别
}
```

### 3.3 商品服务的边界判断


> 🎯 **判断原则**：如果一个功能是"描述商品本身"的，就放在商品服务

**边界示例分析**：

| 功能 | 是否属于商品服务 | 原因 |
|------|----------------|------|
| `商品名称、价格、描述` | ✅ 是 | `商品的基本属性` |
| `商品库存数量` | ❌ 否 | `属于库存服务，涉及扣减逻辑` |
| `商品销量统计` | ✅ 是 | `商品的展示属性` |
| `用户购买记录` | ❌ 否 | `属于订单服务` |
| `商品评价内容` | 🤔 可选 | `可以单独拆成评价服务` |

**商品服务API示例**：
```java
@RestController
public class ProductController {
    
    // 获取商品详情
    @GetMapping("/products/{productId}")
    public Result getProduct(@PathVariable Long productId) {
        // 返回商品基本信息
    }
    
    // 商品搜索
    @GetMapping("/products/search")
    public Result searchProducts(@RequestParam String keyword) {
        // 商品搜索逻辑
    }
    
    // 获取分类下的商品
    @GetMapping("/categories/{categoryId}/products")
    public Result getProductsByCategory(@PathVariable Long categoryId) {
        // 返回分类商品列表
    }
}
```

---

## 4. 📋 订单服务拆分


### 4.1 订单服务的核心使命


订单服务就像是"交易记录员"，专门记录和管理用户的购买行为。

**📝 核心职责**：
```
订单服务功能边界：
┌─────────────────────────────┐
│         订单服务             │
├─────────────────────────────┤
│ 🛒 购物车管理               │
│ 📋 订单创建/修改            │
│ 📊 订单状态流转             │
│ 🔍 订单查询/统计            │
│ ❌ 订单取消处理             │
│ 🚚 发货/收货管理            │
└─────────────────────────────┘
```

### 4.2 订单状态流转设计


订单有自己的"生命周期"，就像快递包裹一样：

```
订单状态流转图：
待支付 ──支付──> 待发货 ──发货──> 待收货 ──确认收货──> 已完成
  │                                                      ▲
  │                                                      │
  └──────────────────取消订单──────────────────────────────┘
                      │
                   已取消
```

**订单数据模型**：
```java
// 订单主表
class Order {
    private Long orderId;           // 订单ID
    private Long userId;            // 用户ID
    private BigDecimal totalAmount; // 订单总金额
    private OrderStatus status;     // 订单状态
    private Date createTime;        // 创建时间
    private String shippingAddress; // 收货地址
}

// 订单详情表
class OrderItem {
    private Long itemId;       // 明细ID
    private Long orderId;      // 订单ID
    private Long productId;    // 商品ID
    private Integer quantity;  // 购买数量
    private BigDecimal price;  // 商品单价
}

// 订单状态枚举
enum OrderStatus {
    PENDING_PAYMENT,    // 待支付
    PENDING_SHIPMENT,   // 待发货
    SHIPPED,           // 已发货
    DELIVERED,         // 已送达
    COMPLETED,         // 已完成
    CANCELLED          // 已取消
}
```

### 4.3 订单服务的关键业务逻辑


**创建订单的流程**：
```
订单创建流程：
用户下单
    │
    ├─> 1. 验证商品信息 (调用商品服务)
    │
    ├─> 2. 检查库存充足 (调用库存服务)
    │
    ├─> 3. 计算订单金额
    │
    ├─> 4. 创建订单记录
    │
    └─> 5. 返回订单号
```

> ⚠️ **注意**：订单服务不直接扣减库存，只是检查库存是否足够

**订单服务API设计**：
```java
@RestController
public class OrderController {
    
    // 创建订单
    @PostMapping("/orders")
    public Result createOrder(@RequestBody CreateOrderRequest request) {
        // 1. 验证用户身份
        // 2. 检查商品和库存
        // 3. 计算金额
        // 4. 创建订单
        return Result.success(orderId);
    }
    
    // 查询订单
    @GetMapping("/orders/{orderId}")
    public Result getOrder(@PathVariable Long orderId) {
        // 返回订单详情
    }
    
    // 取消订单
    @PostMapping("/orders/{orderId}/cancel")
    public Result cancelOrder(@PathVariable Long orderId) {
        // 订单取消逻辑
    }
}
```

---

## 5. 💳 支付服务独立


### 5.1 支付服务的独立价值


支付服务就像是"专业出纳员"，专门处理钱的问题。

**💰 为什么要独立**：
- **安全性要求高**：支付逻辑需要特殊的安全措施
- **对接第三方**：需要接入支付宝、微信等多种支付方式
- **监管要求**：支付数据需要特殊的审计和监管
- **业务复杂**：退款、分账等逻辑比较复杂

**🏦 支付服务职责**：
```
支付服务功能边界：
┌─────────────────────────────┐
│         支付服务             │
├─────────────────────────────┤
│ 💳 支付方式管理             │
│ 💰 支付订单创建             │
│ 🔄 支付状态查询             │
│ 📞 支付回调处理             │
│ 💸 退款申请处理             │
│ 📊 支付数据统计             │
└─────────────────────────────┘
```

### 5.2 支付流程设计


**支付的完整流程**：
```
支付处理流程：
用户点击支付
    │
    ├─> 1. 创建支付订单
    │
    ├─> 2. 调用第三方支付
    │       (支付宝/微信/银联)
    │
    ├─> 3. 用户在第三方完成支付
    │
    ├─> 4. 第三方回调通知结果
    │
    ├─> 5. 更新支付状态
    │
    └─> 6. 通知订单服务支付成功
```

### 5.3 支付数据模型


**支付订单设计**：
```java
// 支付订单
class PaymentOrder {
    private Long paymentId;        // 支付ID
    private Long orderId;          // 关联的业务订单ID
    private BigDecimal amount;     // 支付金额
    private PaymentMethod method;  // 支付方式
    private PaymentStatus status;  // 支付状态
    private String thirdPartyId;   // 第三方支付订单号
    private Date createTime;       // 创建时间
    private Date payTime;          // 支付时间
}

// 支付方式枚举
enum PaymentMethod {
    ALIPAY,      // 支付宝
    WECHAT_PAY,  // 微信支付
    BANK_CARD,   // 银行卡
    BALANCE      // 余额支付
}

// 支付状态
enum PaymentStatus {
    PENDING,     // 待支付
    SUCCESS,     // 支付成功
    FAILED,      // 支付失败
    REFUNDED     // 已退款
}
```

### 5.4 支付服务的关键接口


```java
@RestController
public class PaymentController {
    
    // 创建支付订单
    @PostMapping("/payments")
    public Result createPayment(@RequestBody PaymentRequest request) {
        // 创建支付订单，返回支付链接
    }
    
    // 支付回调接口
    @PostMapping("/payments/callback")
    public Result paymentCallback(@RequestBody CallbackData data) {
        // 处理第三方支付回调
        // 更新支付状态
        // 通知订单服务
    }
    
    // 查询支付状态
    @GetMapping("/payments/{paymentId}")
    public Result getPaymentStatus(@PathVariable Long paymentId) {
        // 返回支付状态
    }
}
```

> 🔒 **安全提醒**：支付回调必须验证签名，防止恶意攻击

---

## 6. 📊 库存服务职责


### 6.1 库存服务的关键作用


库存服务就像是"仓库管理员"，专门管理商品的数量。

**📦 为什么要独立库存服务**：
- **高并发需求**：秒杀时库存扣减压力巨大
- **数据一致性**：防止超卖问题
- **业务复杂性**：预扣、释放、占用等复杂逻辑
- **多渠道库存**：线上线下、多仓库统一管理

**🏭 库存服务职责**：
```
库存服务功能边界：
┌─────────────────────────────┐
│         库存服务             │
├─────────────────────────────┤
│ 📊 库存数量管理             │
│ 🔒 库存预占/释放            │
│ ⚡ 库存扣减操作             │
│ 📈 库存预警监控             │
│ 🏪 多仓库库存分配           │
│ 📋 库存变动记录             │
└─────────────────────────────┘
```

### 6.2 库存操作的核心逻辑


**库存的三种状态**：
```
库存状态管理：
总库存 = 可用库存 + 预占库存 + 已销售库存

示例：
商品A总库存: 100件
├─ 可用库存: 70件 (可以直接购买)
├─ 预占库存: 20件 (用户下单但未支付)
└─ 已销售: 10件 (已完成交易)
```

**库存扣减的安全流程**：
```
安全库存扣减流程：
1. 下单时 → 预占库存 (不是真正扣减)
   可用库存: 70 → 50
   预占库存: 20 → 40

2. 支付成功 → 确认扣减
   预占库存: 40 → 30  
   已销售: 10 → 20

3. 取消订单 → 释放预占
   预占库存: 减少
   可用库存: 增加
```

### 6.3 库存数据模型


```java
// 库存主表
class Inventory {
    private Long productId;      // 商品ID
    private Integer totalStock;  // 总库存
    private Integer availableStock; // 可用库存
    private Integer reservedStock;  // 预占库存
    private Integer soldStock;      // 已销售库存
    private Date updateTime;        // 更新时间
}

// 库存变动记录
class InventoryLog {
    private Long logId;           // 记录ID
    private Long productId;       // 商品ID
    private String operation;     // 操作类型(扣减/增加/预占/释放)
    private Integer quantity;     // 变动数量
    private String orderId;       // 关联订单号
    private Date createTime;      // 操作时间
}
```

### 6.4 库存服务的关键接口


```java
@RestController
public class InventoryController {
    
    // 检查库存
    @GetMapping("/inventory/{productId}")
    public Result checkStock(@PathVariable Long productId) {
        // 返回库存信息
    }
    
    // 预占库存 (下单时调用)
    @PostMapping("/inventory/reserve")
    public Result reserveStock(@RequestBody ReserveRequest request) {
        // 预占指定数量的库存
    }
    
    // 确认扣减 (支付成功时调用)
    @PostMapping("/inventory/deduct")
    public Result deductStock(@RequestBody DeductRequest request) {
        // 确认扣减库存
    }
    
    // 释放预占 (取消订单时调用)
    @PostMapping("/inventory/release")
    public Result releaseStock(@RequestBody ReleaseRequest request) {
        // 释放预占的库存
    }
}
```

> ⚠️ **重要**：库存操作必须保证原子性，通常使用数据库事务或分布式锁

---

## 7. 🔄 服务间协作模式


### 7.1 协作模式概览


微服务之间就像是不同部门的同事，需要相互配合完成工作。

**🤝 主要协作方式**：
```
服务协作模式：
┌─────────────────┐
│   同步调用      │ ← HTTP API 直接调用
├─────────────────┤
│   异步消息      │ ← 消息队列通信
├─────────────────┤
│   事件驱动      │ ← 发布/订阅模式
└─────────────────┘
```

### 7.2 同步调用模式


**什么是同步调用**：
就像打电话，你说一句，对方立即回答，必须等对方回答了你才能继续。

**同步调用示例**：
```
用户下单流程 (同步):
订单服务 ──API调用──> 商品服务 (查询商品信息)
    │                    │
    │<────返回商品信息────┘
    │
    ├──API调用──> 库存服务 (检查库存)
    │                │
    │<──返回库存状态──┘
    │
    └──创建订单
```

**同步调用的代码示例**：
```java
@Service
public class OrderService {
    
    @Autowired
    private ProductService productService;  // 商品服务客户端
    
    @Autowired  
    private InventoryService inventoryService; // 库存服务客户端
    
    public Order createOrder(CreateOrderRequest request) {
        // 1. 同步调用商品服务
        Product product = productService.getProduct(request.getProductId());
        if (product == null) {
            throw new BusinessException("商品不存在");
        }
        
        // 2. 同步调用库存服务
        boolean hasStock = inventoryService.checkStock(
            request.getProductId(), 
            request.getQuantity()
        );
        if (!hasStock) {
            throw new BusinessException("库存不足");
        }
        
        // 3. 创建订单
        return saveOrder(request, product);
    }
}
```

### 7.3 异步消息模式


**什么是异步消息**：
就像发短信，你发出去就不用等回复，对方什么时候处理是对方的事。

**异步消息示例**：
```
支付成功处理 (异步):
支付服务 ──发送消息──> 消息队列
                        │
                        ├──> 订单服务 (更新订单状态)
                        │
                        ├──> 库存服务 (确认扣减库存)
                        │
                        └──> 通知服务 (发送支付成功短信)
```

**异步消息的代码示例**：
```java
// 支付服务发送消息
@Service
public class PaymentService {
    
    @Autowired
    private MessageSender messageSender;
    
    public void onPaymentSuccess(PaymentOrder payment) {
        // 更新支付状态
        updatePaymentStatus(payment.getPaymentId(), SUCCESS);
        
        // 发送支付成功消息
        PaymentSuccessMessage message = new PaymentSuccessMessage();
        message.setOrderId(payment.getOrderId());
        message.setPaymentAmount(payment.getAmount());
        
        messageSender.send("payment.success", message);
    }
}

// 订单服务接收消息
@Service
public class OrderService {
    
    @MessageListener("payment.success")
    public void handlePaymentSuccess(PaymentSuccessMessage message) {
        // 更新订单状态为已支付
        updateOrderStatus(message.getOrderId(), PAID);
    }
}
```

### 7.4 具体协作场景分析


**场景1：用户下单**
```
下单协作流程：
①用户提交订单
    │
②订单服务 ─同步调用─> 用户服务 (验证用户)
    │
③订单服务 ─同步调用─> 商品服务 (获取商品信息)
    │  
④订单服务 ─同步调用─> 库存服务 (预占库存)
    │
⑤创建订单成功
```

**场景2：支付成功**
```
支付成功协作流程：
①支付完成
    │
②支付服务 ─异步消息─> 订单服务 (更新订单状态)
    │
③支付服务 ─异步消息─> 库存服务 (确认扣减)
    │
④支付服务 ─异步消息─> 通知服务 (发送通知)
```

### 7.5 协作模式的选择原则


| 场景 | 推荐模式 | 原因 |
|------|---------|------|
| `获取基础数据` | **同步调用** | `需要立即获得结果` |
| `创建订单` | **同步调用** | `需要确保操作成功` |
| `支付成功通知` | **异步消息** | `不需要立即响应` |
| `发送短信邮件` | **异步消息** | `允许延迟处理` |

> 💡 **选择建议**：需要立即知道结果的用同步，可以稍后处理的用异步

---

## 8. 📋 核心要点总结


### 8.1 电商拆分的关键原则


**🎯 拆分核心原则**：
```
微服务拆分指导思想：
┌─────────────────────────────┐
│ 🎯 单一职责：一个服务只做一件事  │
│ 🔒 数据独立：每个服务有自己的数据库 │
│ 🌐 接口清晰：服务间通过API通信   │
│ 🔄 松耦合：减少服务间的依赖关系   │
└─────────────────────────────┘
```

### 8.2 各服务的核心职责


| 服务名称 | **核心职责** | **关键数据** | **主要API** |
|---------|-------------|-------------|------------|
| `用户服务` | `管理用户身份信息` | `用户基本信息、地址` | `注册、登录、用户查询` |
| `商品服务` | `管理商品目录信息` | `商品信息、分类` | `商品查询、搜索` |
| `订单服务` | `管理交易订单信息` | `订单、订单明细` | `下单、查询、取消` |
| `支付服务` | `处理支付相关逻辑` | `支付订单、交易记录` | `创建支付、查询状态` |
| `库存服务` | `管理商品库存数量` | `库存数量、变动记录` | `检查、预占、扣减` |

### 8.3 服务协作最佳实践


**🔄 协作模式选择**：
- **实时性要求高** → 使用同步调用
- **允许延迟处理** → 使用异步消息  
- **一对多通知** → 使用事件驱动

**⚠️ 常见陷阱提醒**：
```
避免常见问题：
❌ 服务划分过细 → 增加复杂度
❌ 服务间紧耦合 → 失去独立性  
❌ 数据库共享 → 破坏服务边界
❌ 同步调用过多 → 影响性能
```

### 8.4 实施建议


**📈 渐进式拆分策略**：
```
拆分实施步骤：
第一步：识别核心业务边界
   ↓
第二步：设计服务接口
   ↓  
第三步：先拆分最独立的服务
   ↓
第四步：逐步拆分其他服务
   ↓
第五步：优化服务间协作
```

> 🎯 **成功关键**：理解业务，合理边界，逐步演进

**📚 学习建议**：
- 先理解单体架构的问题
- 掌握每个服务的职责边界
- 熟练服务间的协作模式
- 在实践中不断优化拆分

**🔍 自检清单**：
- [ ] 能清楚说出每个服务的职责
- [ ] 理解服务间的协作方式
- [ ] 知道什么时候用同步/异步
- [ ] 明白数据库拆分的重要性
- [ ] 掌握渐进式拆分的方法

**核心记忆口诀**：
- 职责单一边界清，数据独立不共享
- 同步实时异步缓，协作模式要选对
- 渐进拆分莫着急，业务理解是关键