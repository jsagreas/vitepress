---
title: 3、基于数据库的分布式锁
---
## 📚 目录

1. [分布式锁基础概念](#1-分布式锁基础概念)
2. [数据库实现分布式锁的原理](#2-数据库实现分布式锁的原理)
3. [悲观锁实现方案](#3-悲观锁实现方案)
4. [乐观锁实现方案](#4-乐观锁实现方案)
5. [唯一索引约束实现](#5-唯一索引约束实现)
6. [死锁检测与处理](#6-死锁检测与处理)
7. [性能分析与优化](#7-性能分析与优化)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 分布式锁基础概念


### 1.1 什么是分布式锁


**简单理解：** 分布式锁就像现实中的"排队取号"系统

```
现实场景对比：
银行取号排队：               分布式锁：
 ┌─────────────┐              ┌─────────────┐
 │ 取号机只能   │              │ 只有一个服务 │
 │ 一次给一个号 │      ≈       │ 能获得锁     │
 │ 其他人等待   │              │ 其他服务等待 │
 └─────────────┘              └─────────────┘
```

**🔸 核心作用：**
- **互斥访问**：同一时刻只有一个服务能执行特定操作
- **防止冲突**：避免多个服务同时修改同一资源
- **保证一致性**：确保业务逻辑的正确执行

### 1.2 为什么需要分布式锁


**问题场景：库存扣减**
```
电商系统中的问题：
服务A：查询库存 = 10
服务B：查询库存 = 10    ← 同时查询到相同库存
服务A：扣减1，库存 = 9
服务B：扣减1，库存 = 9   ← 问题：应该是8！

正确流程（使用分布式锁）：
服务A：获取锁 → 查询库存 = 10 → 扣减 = 9 → 释放锁
服务B：等待锁 → 获取锁 → 查询库存 = 9 → 扣减 = 8 → 释放锁
```

**🎯 解决的核心问题：**
- **数据不一致**：防止并发修改导致的数据错误
- **重复操作**：避免同一操作被执行多次
- **资源竞争**：协调多个服务对共享资源的访问

---

## 2. 🗄️ 数据库实现分布式锁的原理


### 2.1 基本实现思路


**核心理念：** 利用数据库的**原子性**和**唯一性**特征

```
数据库锁表设计：
┌─────────────────────────────────────────┐
│            lock_table                   │
├─────────────┬─────────────┬─────────────┤
│ lock_name   │ expire_time │ owner       │
│ (主键/唯一)  │ (过期时间)   │ (持有者)     │
├─────────────┼─────────────┼─────────────┤
│ order_lock  │ 1642662000  │ service_A   │
│ user_lock   │ 1642662100  │ service_B   │
└─────────────┴─────────────┴─────────────┘
```

**🔸 实现原理：**
- **获取锁**：向锁表插入一条记录
- **释放锁**：删除对应的记录
- **互斥保证**：依靠数据库的唯一性约束

### 2.2 三种实现方式对比


| 实现方式 | **原理** | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|---------|-------------|
| 🔒 **悲观锁** | `SELECT FOR UPDATE` | 强一致性 | 性能较低，可能死锁 | 并发量不高的场景 |
| ⚡ **乐观锁** | `版本号机制` | 性能较好 | 需要重试机制 | 读多写少的场景 |
| 🆔 **唯一索引** | `唯一约束冲突` | 实现简单 | 功能有限 | 简单的互斥场景 |

---

## 3. 🔒 悲观锁实现方案


### 3.1 悲观锁基本概念


**通俗理解：** 悲观锁就像"占座"，一旦占了就不让别人坐

```
悲观锁的思维模式：
"我假设一定会有冲突，所以先锁住再操作"

餐厅占座类比：
人A：看中座位 → 放包占座 → 去买饭 → 回来吃饭 → 离开
人B：看到有包   → 等待     → 等待   → 人A走后坐下
```

### 3.2 数据库表设计


```sql
-- 分布式锁表
CREATE TABLE distributed_lock (
    lock_name VARCHAR(100) PRIMARY KEY,    -- 锁名称（唯一标识）
    owner VARCHAR(100) NOT NULL,          -- 锁持有者标识
    expire_time BIGINT NOT NULL,          -- 过期时间戳
    create_time TIMESTAMP DEFAULT NOW(),   -- 创建时间
    update_time TIMESTAMP DEFAULT NOW()    -- 更新时间
);

-- 添加索引优化查询
CREATE INDEX idx_expire_time ON distributed_lock(expire_time);
```

### 3.3 悲观锁核心实现


**Java实现示例：**
```java
@Service
public class PessimisticDBLock {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // 获取锁（悲观锁方式）
    public boolean tryLock(String lockName, String owner, long expireTime) {
        try {
            // 开启事务，使用悲观锁
            String sql = """
                SELECT lock_name FROM distributed_lock 
                WHERE lock_name = ? FOR UPDATE
            """;
            
            List<String> result = jdbcTemplate.queryForList(sql, String.class, lockName);
            
            if (result.isEmpty()) {
                // 锁不存在，插入新锁
                insertLock(lockName, owner, expireTime);
                return true;
            } else {
                // 检查是否过期
                if (isExpired(lockName)) {
                    updateLock(lockName, owner, expireTime);
                    return true;
                }
                return false; // 锁被占用
            }
        } catch (Exception e) {
            return false;
        }
    }
}
```

**🔸 关键特点：**
- **FOR UPDATE**：对查询的行加排他锁
- **事务保护**：整个操作在事务中完成
- **立即生效**：一旦获取锁，其他线程立即被阻塞

### 3.4 行级锁应用详解


**行级锁的工作机制：**
```
数据库行级锁示意：
┌─────────────────────────────────────┐
│  事务A: SELECT ... FOR UPDATE      │ ← 获得行锁
├─────────────────────────────────────┤
│  事务B: SELECT ... FOR UPDATE      │ ← 等待行锁
│         (WAITING...)                │
├─────────────────────────────────────┤
│  事务C: SELECT ... FOR UPDATE      │ ← 排队等待
│         (WAITING...)                │
└─────────────────────────────────────┘
```

**⚡ 性能考虑：**
- **锁定粒度**：只锁定特定行，不影响其他数据
- **等待队列**：后续请求需要排队等待
- **超时机制**：避免无限等待

---

## 4. ⚡ 乐观锁实现方案


### 4.1 乐观锁基本概念


**通俗理解：** 乐观锁就像"先试试看"，发现冲突再重来

```
乐观锁的思维模式：
"我假设不会有冲突，操作时再检查"

网上抢票类比：
用户A：选座位 → 填信息 → 提交订单 → 成功
用户B：选座位 → 填信息 → 提交订单 → 座位已被占，重新选择
```

### 4.2 版本号控制机制


**数据库表设计：**
```sql
CREATE TABLE distributed_lock_optimistic (
    lock_name VARCHAR(100) PRIMARY KEY,
    owner VARCHAR(100),
    version INT NOT NULL DEFAULT 0,        -- 版本号（关键字段）
    expire_time BIGINT,
    create_time TIMESTAMP DEFAULT NOW(),
    update_time TIMESTAMP DEFAULT NOW()
);
```

### 4.3 乐观锁实现代码


```java
@Service  
public class OptimisticDBLock {
    
    // 尝试获取锁（乐观锁方式）
    public boolean tryLock(String lockName, String owner, long expireTime) {
        try {
            // 1. 先查询当前状态
            LockInfo lockInfo = queryLockInfo(lockName);
            
            if (lockInfo == null) {
                // 锁不存在，尝试插入
                return insertNewLock(lockName, owner, expireTime);
            }
            
            // 2. 检查是否过期
            if (isExpired(lockInfo)) {
                // 使用版本号更新（关键：WHERE条件包含版本号）
                String updateSql = """
                    UPDATE distributed_lock_optimistic 
                    SET owner = ?, expire_time = ?, version = version + 1
                    WHERE lock_name = ? AND version = ?
                """;
                
                int affected = jdbcTemplate.update(updateSql, 
                    owner, expireTime, lockName, lockInfo.getVersion());
                
                return affected > 0; // 更新成功表示获取锁成功
            }
            
            return false; // 锁未过期，获取失败
        } catch (Exception e) {
            return false;
        }
    }
}
```

**🔸 版本号工作流程：**
```
时间线：版本号变化过程
T1: 服务A查询 version=1
T2: 服务B查询 version=1  ← 同时查询到相同版本
T3: 服务A更新 WHERE version=1 → 成功，version变为2
T4: 服务B更新 WHERE version=1 → 失败，version已经是2了！
```

### 4.4 重试机制设计


**智能重试策略：**
```java
public boolean lockWithRetry(String lockName, String owner, long expireTime, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        if (tryLock(lockName, owner, expireTime)) {
            return true;
        }
        
        // 指数退避策略：避免重试风暴
        try {
            Thread.sleep(100 * (1 << i)); // 100ms, 200ms, 400ms...
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            break;
        }
    }
    return false;
}
```

---

## 5. 🆔 唯一索引约束实现


### 5.1 唯一索引约束原理


**最简单的实现方式：** 利用数据库唯一性约束特征

```
唯一索引约束工作原理：
┌─────────────────────────────────────┐
│        INSERT INTO lock_table       │
│        (lock_name, owner)           │
│        VALUES ('order_lock', 'A')   │ ← 第一次插入：成功
├─────────────────────────────────────┤
│        INSERT INTO lock_table       │
│        (lock_name, owner)           │  
│        VALUES ('order_lock', 'B')   │ ← 第二次插入：失败！
│        → ERROR: Duplicate key       │   (违反唯一约束)
└─────────────────────────────────────┘
```

### 5.2 简化表设计


```sql
-- 最简单的锁表设计
CREATE TABLE simple_distributed_lock (
    lock_name VARCHAR(100) PRIMARY KEY,   -- 主键保证唯一性
    owner VARCHAR(100) NOT NULL,
    expire_time BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 5.3 唯一索引实现代码


```java
@Service
public class UniqueIndexLock {
    
    // 获取锁：尝试插入记录
    public boolean tryLock(String lockName, String owner, long expireTime) {
        try {
            String insertSql = """
                INSERT INTO simple_distributed_lock 
                (lock_name, owner, expire_time) 
                VALUES (?, ?, ?)
            """;
            
            jdbcTemplate.update(insertSql, lockName, owner, expireTime);
            return true; // 插入成功 = 获取锁成功
            
        } catch (DuplicateKeyException e) {
            // 违反唯一约束 = 锁已被占用
            return tryAcquireExpiredLock(lockName, owner, expireTime);
        }
    }
    
    // 尝试获取过期的锁
    private boolean tryAcquireExpiredLock(String lockName, String owner, long expireTime) {
        String deleteSql = """
            DELETE FROM simple_distributed_lock 
            WHERE lock_name = ? AND expire_time < ?
        """;
        
        int deleted = jdbcTemplate.update(deleteSql, lockName, System.currentTimeMillis());
        
        if (deleted > 0) {
            // 删除过期锁成功，重新尝试获取
            return tryLock(lockName, owner, expireTime);
        }
        
        return false;
    }
    
    // 释放锁：删除记录
    public void releaseLock(String lockName, String owner) {
        String deleteSql = """
            DELETE FROM simple_distributed_lock 
            WHERE lock_name = ? AND owner = ?
        """;
        
        jdbcTemplate.update(deleteSql, lockName, owner);
    }
}
```

**🔸 优缺点分析：**

| 维度 | **优点** ✅ | **缺点** ❌ |
|------|------------|------------|
| **实现简单性** | 代码量少，逻辑清晰 | 功能相对有限 |
| **性能表现** | 数据库原生支持，性能较好 | 高并发下可能有瓶颈 |
| **可靠性** | 依赖数据库ACID特性 | 单点故障风险 |

---

## 6. ⚠️ 死锁检测与处理


### 6.1 死锁产生原因


**死锁场景示例：**
```
经典死锁场景：
时间 | 事务A              | 事务B
-----|-------------------|-------------------
T1   | 获取锁1           |
T2   |                   | 获取锁2  
T3   | 尝试获取锁2(等待)  |
T4   |                   | 尝试获取锁1(等待)
T5   | 等待中...         | 等待中...
     | ↑                 | ↑
     | 互相等待，形成死锁！|
```

**🔸 死锁的四个必要条件：**
- **互斥条件**：资源只能被一个进程占用
- **请求和保持**：持有资源的同时请求新资源  
- **不可剥夺**：资源不能被强制释放
- **循环等待**：形成等待环路

### 6.2 死锁检测机制


**数据库层面的死锁检测：**
```sql
-- MySQL查看死锁信息
SHOW ENGINE INNODB STATUS;

-- 查看当前锁等待情况  
SELECT * FROM information_schema.INNODB_LOCKS;
SELECT * FROM information_schema.INNODB_LOCK_WAITS;
```

**应用层面的死锁预防：**
```java
@Service
public class DeadlockAwareDBLock {
    
    // 设置锁获取超时时间
    @Transactional(timeout = 30) // 30秒超时
    public boolean tryLockWithTimeout(String lockName, String owner, long expireTime) {
        try {
            // 设置查询超时时间，避免长时间等待
            String sql = """
                SELECT lock_name FROM distributed_lock 
                WHERE lock_name = ? FOR UPDATE WAIT 10
            """;
            // WAIT 10: 最多等待10秒
            
            return acquireLock(lockName, owner, expireTime);
        } catch (SQLException e) {
            if (e.getErrorCode() == 1205) { // 死锁错误码
                logger.warn("检测到死锁，锁名称: {}", lockName);
                return false;
            }
            throw e;
        }
    }
}
```

### 6.3 死锁处理策略


**📋 处理策略对比：**

```
策略1: 超时机制
优点：简单有效，避免无限等待
缺点：可能打断正常的长事务
应用：大多数场景的标准做法

策略2: 锁顺序排序  
优点：从根本上避免死锁
缺点：需要预先定义全局顺序
应用：已知所有锁资源的场景

策略3: 立即重试
优点：快速响应，提高并发性
缺点：可能造成重试风暴
应用：竞争不激烈的场景
```

**实现示例：**
```java
// 策略1：超时重试机制
public boolean lockWithDeadlockHandling(String lockName, String owner) {
    int maxRetries = 3;
    int retryDelay = 100; // 毫秒
    
    for (int i = 0; i < maxRetries; i++) {
        try {
            return tryLockWithTimeout(lockName, owner, getExpireTime());
        } catch (DeadlockLoserDataAccessException e) {
            logger.info("检测到死锁，第{}次重试", i + 1);
            if (i < maxRetries - 1) {
                sleep(retryDelay * (i + 1)); // 递增延迟
            }
        }
    }
    return false;
}
```

---

## 7. 📊 性能分析与优化


### 7.1 性能瓶颈分析


**数据库分布式锁的性能特征：**
```
性能瓶颈分析图：
            性能影响因素
                 |
    ┌─────────────┼─────────────┐
    |             |             |
数据库连接池   索引效率    事务处理开销
    |             |             |
连接数限制    查询优化    锁等待时间
    |             |             |
网络延迟     存储I/O     并发冲突
```

### 7.2 关键性能指标


| 性能指标 | **期望值** | **影响因素** | **优化方向** |
|---------|-----------|-------------|-------------|
| 🚀 **锁获取延迟** | < 10ms | 网络+数据库查询 | 连接池优化、索引优化 |
| 🔄 **并发处理量** | > 1000 QPS | 数据库性能限制 | 读写分离、分库分表 |  
| ⏰ **锁持有时间** | < 1s | 业务逻辑复杂度 | 缩小锁范围、异步处理 |
| 💾 **资源消耗** | < 100MB | 连接池+缓存 | 连接复用、定期清理 |

### 7.3 扩展性限制


**扩展性挑战：**
```
单数据库实例的限制：
┌─────────────────────────────────┐
│      数据库服务器 (单点)          │
├─────────────────────────────────┤  
│  连接数限制: 1000              │
│  TPS限制: 5000                 │  ← 性能瓶颈
│  存储限制: 单机硬盘             │
│  可用性: 单点故障风险           │
└─────────────────────────────────┘
          ↑
    所有应用服务都依赖这个数据库
```

### 7.4 性能优化策略


**🔸 数据库层面优化：**
```sql
-- 1. 优化表结构
CREATE TABLE distributed_lock_optimized (
    lock_name VARCHAR(100) PRIMARY KEY,
    owner VARCHAR(100) NOT NULL,
    expire_time BIGINT NOT NULL,
    -- 添加分区支持（按时间分区）
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (UNIX_TIMESTAMP(created_at)) (
    PARTITION p2024 VALUES LESS THAN (UNIX_TIMESTAMP('2025-01-01')),
    PARTITION p2025 VALUES LESS THAN (UNIX_TIMESTAMP('2026-01-01'))
);

-- 2. 添加必要索引
CREATE INDEX idx_expire_owner ON distributed_lock_optimized(expire_time, owner);

-- 3. 定期清理过期锁
DELETE FROM distributed_lock_optimized 
WHERE expire_time < UNIX_TIMESTAMP(NOW() - INTERVAL 1 HOUR);
```

**🔸 应用层面优化：**
```java
@Service
public class OptimizedDBLock {
    
    // 1. 连接池优化配置
    @Bean
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setMaximumPoolSize(50);        // 适当的连接池大小
        dataSource.setConnectionTimeout(5000);    // 连接超时
        dataSource.setIdleTimeout(300000);        // 空闲超时
        dataSource.setMaxLifetime(600000);        // 连接最大生存时间
        return dataSource;
    }
    
    // 2. 批量清理过期锁
    @Scheduled(fixedRate = 60000) // 每分钟执行一次
    public void cleanupExpiredLocks() {
        String cleanupSql = """
            DELETE FROM distributed_lock 
            WHERE expire_time < ? LIMIT 1000
        """;
        
        int deleted = jdbcTemplate.update(cleanupSql, System.currentTimeMillis());
        if (deleted > 0) {
            logger.info("清理过期锁数量: {}", deleted);
        }
    }
}
```

---

## 8. 🎯 实际应用场景


### 8.1 适用场景分析


**✅ 最适合的场景：**
```
场景1: 中小型系统的资源互斥
├─ 并发量: 100-1000 QPS
├─ 业务特点: 对一致性要求高
└─ 技术栈: 已有数据库基础设施

场景2: 定时任务防重复执行  
├─ 频率: 秒级/分钟级
├─ 特点: 执行时间较短
└─ 要求: 绝对不能重复执行

场景3: 订单状态变更控制
├─ 操作: 订单支付、发货、退款
├─ 特点: 强事务一致性需求  
└─ 风险: 状态冲突会导致业务异常
```

### 8.2 不适合的场景


**❌ 不推荐的场景：**
```
场景1: 高频次的缓存更新
原因: 数据库I/O成为瓶颈
建议: 使用Redis等内存缓存

场景2: 微秒级的精确控制
原因: 网络延迟无法满足要求
建议: 使用本地锁或无锁算法

场景3: 超高并发秒杀系统
原因: 数据库连接数和TPS限制
建议: 分布式缓存+消息队列
```

### 8.3 实际项目实现示例


**电商库存扣减场景：**
```java
@Service
@Transactional
public class InventoryService {
    
    @Autowired
    private UniqueIndexLock distributedLock;
    
    public boolean deductInventory(Long productId, int quantity) {
        String lockName = "inventory_" + productId;
        String owner = getCurrentServiceId();
        long expireTime = System.currentTimeMillis() + 30000; // 30秒过期
        
        try {
            // 1. 获取分布式锁
            if (!distributedLock.tryLock(lockName, owner, expireTime)) {
                logger.warn("获取库存锁失败，商品ID: {}", productId);
                return false;
            }
            
            // 2. 查询当前库存
            Product product = productMapper.selectById(productId);
            if (product.getStock() < quantity) {
                logger.info("库存不足，商品ID: {}, 当前库存: {}, 需要: {}", 
                    productId, product.getStock(), quantity);
                return false;
            }
            
            // 3. 扣减库存
            int updated = productMapper.deductStock(productId, quantity);
            if (updated <= 0) {
                logger.error("库存扣减失败，商品ID: {}", productId);
                return false;
            }
            
            logger.info("库存扣减成功，商品ID: {}, 扣减数量: {}", productId, quantity);
            return true;
            
        } finally {
            // 4. 确保释放锁
            distributedLock.releaseLock(lockName, owner);
        }
    }
}
```

### 8.4 监控与运维


**🔸 关键监控指标：**
```java
@Component
public class LockMetrics {
    
    private final MeterRegistry meterRegistry;
    
    // 锁获取成功率
    public void recordLockSuccess(String lockName) {
        Counter.builder("distributed.lock.success")
            .tag("lock.name", lockName)
            .register(meterRegistry)
            .increment();
    }
    
    // 锁获取耗时
    public void recordLockDuration(String lockName, long duration) {
        Timer.builder("distributed.lock.duration")
            .tag("lock.name", lockName)  
            .register(meterRegistry)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    // 锁等待超时次数
    public void recordLockTimeout(String lockName) {
        Counter.builder("distributed.lock.timeout")
            .tag("lock.name", lockName)
            .register(meterRegistry)
            .increment();
    }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 分布式锁本质：利用数据库的原子性和唯一性实现互斥访问
🔸 三种实现方式：悲观锁、乐观锁、唯一索引约束各有适用场景  
🔸 版本号机制：乐观锁的核心，通过版本号检测并发冲突
🔸 死锁处理：超时机制、重试策略、锁顺序是关键防护手段
🔸 性能特征：数据库I/O是瓶颈，适合中低并发场景
```

### 9.2 关键理解要点


**🔹 实现方式选择原则：**
```
悲观锁适用：
• 并发冲突概率高
• 对数据一致性要求极高  
• 可以接受一定的性能损失

乐观锁适用：
• 并发冲突概率低
• 读多写少的场景
• 对响应时间要求较高

唯一索引适用：
• 简单的互斥需求
• 实现复杂度要求低
• 功能要求相对简单
```

**🔹 性能优化的核心思路：**
```
数据库层面：
• 合理设计索引，优化查询性能
• 定期清理过期锁，避免数据积累  
• 考虑分库分表，突破单机限制

应用层面：
• 缩小锁的粒度和持有时间
• 合理配置连接池和超时时间
• 实施有效的监控和告警机制
```

### 9.3 实际应用指导


**📋 应用决策表：**

| 业务场景 | **推荐方案** | **关键配置** | **注意事项** |
|---------|-------------|-------------|-------------|
| 🛒 **电商库存** | 悲观锁 | 超时30秒 | 锁粒度到商品级别 |  
| ⏰ **定时任务** | 唯一索引 | 过期时间=任务周期 | 任务结束及时释放 |
| 📊 **报表生成** | 乐观锁 | 重试3次 | 版本号递增机制 |
| 💰 **支付处理** | 悲观锁 | 超时10秒 | 异常必须释放锁 |

### 9.4 最佳实践总结


**🎯 核心最佳实践：**
```
1. 锁粒度设计
   • 尽可能细粒度，减少竞争范围
   • 避免大范围锁，影响系统并发性

2. 超时机制必需  
   • 设置合理的锁过期时间
   • 实现自动清理机制，防止死锁

3. 异常处理完备
   • 使用try-finally确保锁释放
   • 记录详细日志便于问题排查

4. 监控告警完善
   • 监控锁获取成功率和耗时
   • 设置合理的告警阈值

5. 性能测试充分
   • 压测验证并发性能表现
   • 评估系统容量上限
```

### 9.5 技术演进方向


**🚀 从数据库锁到其他方案：**
```
技术演进路径：
数据库分布式锁 → Redis分布式锁 → ZooKeeper协调服务 → Etcd分布式锁

选择建议：
• 起步阶段：数据库锁，成本低，易理解
• 成长阶段：Redis锁，性能提升明显  
• 成熟阶段：专业分布式协调服务
• 云原生：托管分布式锁服务
```

**核心记忆口诀：**
- 数据库锁三方案，悲观乐观加唯一
- 版本控制防冲突，超时机制避死锁
- 性能瓶颈在I/O，监控告警不可少
- 场景选择最关键，演进升级要规划