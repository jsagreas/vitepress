---
title: 2ã€åˆ†å¸ƒå¼é”è®¾è®¡åŸåˆ™
---
## ğŸ“š ç›®å½•

1. [åˆ†å¸ƒå¼é”æ ¸å¿ƒæ¦‚å¿µ](#1-åˆ†å¸ƒå¼é”æ ¸å¿ƒæ¦‚å¿µ)
2. [äº’æ–¥æ€§ä¿è¯æœºåˆ¶](#2-äº’æ–¥æ€§ä¿è¯æœºåˆ¶)
3. [å¯é‡å…¥æ€§å®ç°åŸç†](#3-å¯é‡å…¥æ€§å®ç°åŸç†)
4. [å®¹é”™æ€§è®¾è®¡ç­–ç•¥](#4-å®¹é”™æ€§è®¾è®¡ç­–ç•¥)
5. [è¶…æ—¶é‡Šæ”¾ä¸é”ç»­æœŸ](#5-è¶…æ—¶é‡Šæ”¾ä¸é”ç»­æœŸ)
6. [å…¬å¹³æ€§ä¸æ€§èƒ½å¹³è¡¡](#6-å…¬å¹³æ€§ä¸æ€§èƒ½å¹³è¡¡)
7. [ä¸€è‡´æ€§ä¿éšœæœºåˆ¶](#7-ä¸€è‡´æ€§ä¿éšœæœºåˆ¶)
8. [å¯è§‚æµ‹æ€§ä¸æ˜“ç”¨æ€§](#8-å¯è§‚æµ‹æ€§ä¸æ˜“ç”¨æ€§)
9. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#9-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

## 1. ğŸ” åˆ†å¸ƒå¼é”æ ¸å¿ƒæ¦‚å¿µ


### 1.1 ä»€ä¹ˆæ˜¯åˆ†å¸ƒå¼é”


> ğŸ“– **æ ¸å¿ƒæ¦‚å¿µ**  
> åˆ†å¸ƒå¼é”æ˜¯åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œç”¨æ¥æ§åˆ¶å¤šä¸ªèŠ‚ç‚¹å¯¹å…±äº«èµ„æºè®¿é—®çš„åŒæ­¥æœºåˆ¶ã€‚å°±åƒç°å®ä¸­çš„é—¨é”ä¸€æ ·ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª"äºº"èƒ½è¿›å…¥"æˆ¿é—´"ã€‚

**ğŸ  ç”Ÿæ´»ç±»æ¯”**ï¼š
```
å•ä½“åº”ç”¨çš„é” = æˆ¿é—´å†…çš„é”
â€¢ åªéœ€è¦ç®¡ç†åŒä¸€ä¸ªæˆ¿é—´å†…çš„äºº
â€¢ å¤§å®¶éƒ½èƒ½çœ‹åˆ°é”çš„çŠ¶æ€
â€¢ ç®€å•ç›´æ¥

åˆ†å¸ƒå¼é” = å°åŒºå¤§é—¨é”  
â€¢ éœ€è¦ç®¡ç†ä¸åŒæ¥¼æ ‹çš„ä½æˆ·
â€¢ æ¯æ ‹æ¥¼çš„äººéƒ½è¦èƒ½çœ‹åˆ°é”çŠ¶æ€
â€¢ éœ€è¦ç»Ÿä¸€çš„ç®¡ç†æœºåˆ¶
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦åˆ†å¸ƒå¼é”


**ğŸ“Š é—®é¢˜åœºæ™¯å¯¹æ¯”**ï¼š

| åœºæ™¯ | **å•ä½“åº”ç”¨** | **åˆ†å¸ƒå¼ç³»ç»Ÿ** | **é¢ä¸´æŒ‘æˆ˜** |
|------|------------|--------------|------------|
| ğŸ›’ **åº“å­˜æ‰£å‡** | `synchronizedåŒæ­¥` | `å¤šä¸ªæœåŠ¡å®ä¾‹` | `è¶…å–é—®é¢˜` |
| ğŸ’° **è®¢å•ç¼–å·** | `åŸå­æ“ä½œç”Ÿæˆ` | `åˆ†å¸ƒå¼ç”Ÿæˆ` | `ç¼–å·é‡å¤` |
| ğŸ“Š **æ•°æ®ç»Ÿè®¡** | `å†…å­˜è®¡æ•°` | `å¤šå®ä¾‹è®¡ç®—` | `ç»“æœä¸ä¸€è‡´` |
| ğŸ”„ **å®šæ—¶ä»»åŠ¡** | `å•æœºæ‰§è¡Œ` | `å¤šå®ä¾‹æ‰§è¡Œ` | `é‡å¤æ‰§è¡Œ` |

**ğŸ’¡ å®é™…æ¡ˆä¾‹**ï¼š
```
ç”µå•†ç§’æ€åœºæ™¯ï¼š
å•†å“åº“å­˜ï¼š100ä»¶
å¹¶å‘ç”¨æˆ·ï¼š10000äºº
æœåŠ¡å®ä¾‹ï¼š3ä¸ª

æ²¡æœ‰åˆ†å¸ƒå¼é”ï¼š
å®ä¾‹Aå¤„ç†3000è¯·æ±‚ â†’ æ‰£å‡åº“å­˜100 â†’ å‰©ä½™0
å®ä¾‹Bå¤„ç†3000è¯·æ±‚ â†’ æ‰£å‡åº“å­˜100 â†’ å‰©ä½™0  
å®ä¾‹Cå¤„ç†4000è¯·æ±‚ â†’ æ‰£å‡åº“å­˜100 â†’ å‰©ä½™0
å®é™…å”®å‡ºï¼š300ä»¶ï¼ï¼ˆè¶…å–200ä»¶ï¼‰

æœ‰åˆ†å¸ƒå¼é”ï¼š
åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªå®ä¾‹èƒ½æ“ä½œåº“å­˜
çœŸå®å”®å‡ºï¼š100ä»¶ âœ…
```

### 1.3 åˆ†å¸ƒå¼é”çš„æœ¬è´¨ç‰¹å¾


**ğŸ¯ æ ¸å¿ƒç‰¹å¾**ï¼š
- **ğŸ”’ å…¨å±€å”¯ä¸€æ€§**ï¼šæ•´ä¸ªåˆ†å¸ƒå¼ç³»ç»Ÿä¸­åªæœ‰ä¸€ä¸ªé”å®ä¾‹
- **â±ï¸ æ—¶æ•ˆæ€§**ï¼šé”æœ‰æœ‰æ•ˆæœŸï¼Œé˜²æ­¢æ­»é”
- **ğŸ”„ å¯è§æ€§**ï¼šæ‰€æœ‰èŠ‚ç‚¹éƒ½èƒ½çœ‹åˆ°é”çš„çŠ¶æ€å˜åŒ–
- **âš¡ é«˜å¯ç”¨æ€§**ï¼šé”æœåŠ¡æœ¬èº«ä¸èƒ½æˆä¸ºå•ç‚¹æ•…éšœ

---

## 2. ğŸ›¡ï¸ äº’æ–¥æ€§ä¿è¯æœºåˆ¶


### 2.1 äº’æ–¥æ€§çš„å«ä¹‰


> ğŸ’¡ **ç®€å•ç†è§£**  
> äº’æ–¥æ€§å°±æ˜¯"æ’ä»–æ€§"ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹èƒ½è·å–åˆ°é”ã€‚å°±åƒå•æ‰€é—¨é”ï¼Œé‡Œé¢æœ‰äººæ—¶å¤–é¢çš„äººå°±è¿›ä¸å»ã€‚

### 2.2 äº’æ–¥æ€§å®ç°æ–¹æ¡ˆ


#### ğŸ”§ åŸºäºRedisçš„äº’æ–¥å®ç°


**æ ¸å¿ƒå‘½ä»¤**ï¼š`SET key value NX EX seconds`

```java
// ğŸ¯ äº’æ–¥æ€§ä¿è¯çš„å…³é”®ä»£ç 
public boolean tryLock(String lockKey, String clientId, int expireSeconds) {
    // NX: åªæœ‰keyä¸å­˜åœ¨æ—¶æ‰è®¾ç½®æˆåŠŸ
    // EX: è®¾ç½®è¿‡æœŸæ—¶é—´
    String result = jedis.set(lockKey, clientId, "NX", "EX", expireSeconds);
    return "OK".equals(result);
}
```

**ğŸ” å·¥ä½œåŸç†å›¾ç¤º**ï¼š
```
æ—¶é—´çº¿ï¼š    å®¢æˆ·ç«¯A        Redis        å®¢æˆ·ç«¯B
   |          |            |             |
   t1      è·å–é”è¯·æ±‚   â”€â”€>  é”ä¸å­˜åœ¨    
   |          |        <â”€â”€  è®¾ç½®æˆåŠŸ      |
   t2         |            é”å­˜åœ¨       è·å–é”è¯·æ±‚
   |          |                     <â”€â”€  è®¾ç½®å¤±è´¥
   t3      é‡Šæ”¾é”è¯·æ±‚   â”€â”€>  åˆ é™¤é”      
   |          |        <â”€â”€  é‡Šæ”¾æˆåŠŸ      |
   t4         |            é”ä¸å­˜åœ¨       é‡æ–°è·å–
   |                                 <â”€â”€  è®¾ç½®æˆåŠŸ
```

#### ğŸ¢ åŸºäºæ•°æ®åº“çš„äº’æ–¥å®ç°


**è¡¨ç»“æ„è®¾è®¡**ï¼š
```sql
CREATE TABLE distributed_lock (
    id INT PRIMARY KEY AUTO_INCREMENT,
    lock_name VARCHAR(100) UNIQUE NOT NULL,  -- é”åç§°ï¼Œå”¯ä¸€çº¦æŸä¿è¯äº’æ–¥
    holder VARCHAR(100) NOT NULL,            -- æŒæœ‰è€…æ ‡è¯†
    expire_time TIMESTAMP NOT NULL,          -- è¿‡æœŸæ—¶é—´
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**ğŸ” è·å–é”é€»è¾‘**ï¼š
```java
public boolean tryLock(String lockName, String holder, int timeoutSeconds) {
    try {
        // åˆ©ç”¨å”¯ä¸€çº¦æŸä¿è¯äº’æ–¥æ€§
        String sql = """
            INSERT INTO distributed_lock (lock_name, holder, expire_time) 
            VALUES (?, ?, DATE_ADD(NOW(), INTERVAL ? SECOND))
            """;
        
        int rows = jdbcTemplate.update(sql, lockName, holder, timeoutSeconds);
        return rows > 0;  // æ’å…¥æˆåŠŸè¯´æ˜è·å–é”æˆåŠŸ
        
    } catch (DuplicateKeyException e) {
        return false;  // å”¯ä¸€çº¦æŸå†²çªï¼Œè¯´æ˜é”å·²å­˜åœ¨
    }
}
```

### 2.3 äº’æ–¥æ€§çš„éªŒè¯æµ‹è¯•


**ğŸ§ª å¹¶å‘æµ‹è¯•ç¤ºä¾‹**ï¼š
```java
// æ¨¡æ‹Ÿ10ä¸ªçº¿ç¨‹åŒæ—¶ç«äº‰é”
public void testMutualExclusion() {
    CountDownLatch latch = new CountDownLatch(10);
    AtomicInteger successCount = new AtomicInteger(0);
    
    for (int i = 0; i < 10; i++) {
        Thread thread = new Thread(() -> {
            if (distributedLock.tryLock("test-lock", Thread.currentThread().getName(), 30)) {
                successCount.incrementAndGet();
                // æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ
                Thread.sleep(100);
                distributedLock.unlock("test-lock", Thread.currentThread().getName());
            }
            latch.countDown();
        });
        thread.start();
    }
    
    latch.await();
    // éªŒè¯ï¼šåŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è·å–é”
    assertEquals(1, successCount.get());
}
```

---

## 3. ğŸ”„ å¯é‡å…¥æ€§å®ç°åŸç†


### 3.1 ä»€ä¹ˆæ˜¯å¯é‡å…¥æ€§


> ğŸ§  **è®°å¿†æŠ€å·§**  
> å¯é‡å…¥ = å¯ä»¥é‡å¤è¿›å…¥ã€‚å°±åƒä½ å®¶çš„é—¨é”ï¼Œä½ å·²ç»åœ¨å®¶é‡Œäº†ï¼Œè¿˜èƒ½å†æ¬¡"è¿›å…¥"ä½ çš„æˆ¿é—´ï¼Œä¸ä¼šè¢«è‡ªå·±é”ä½ã€‚

**ğŸ“ å®é™…åœºæ™¯**ï¼š
```java
public void methodA() {
    distributedLock.lock("business-lock");
    
    // åœ¨æŒæœ‰é”çš„æƒ…å†µä¸‹ï¼Œå†æ¬¡éœ€è¦è¿™ä¸ªé”
    methodB();  // è¿™é‡Œä¹Ÿéœ€è¦åŒæ ·çš„é”
    
    distributedLock.unlock("business-lock");
}

public void methodB() {
    distributedLock.lock("business-lock");  // ğŸ¤” ä¼šæ­»é”å—ï¼Ÿ
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    distributedLock.unlock("business-lock");
}
```

### 3.2 å¯é‡å…¥æ€§å®ç°æœºåˆ¶


#### ğŸ’¾ è®¡æ•°å™¨æ–¹æ¡ˆ


**ğŸ¯ æ ¸å¿ƒæ€æƒ³**ï¼šè®°å½•åŒä¸€ä¸ªå®¢æˆ·ç«¯è·å–é”çš„æ¬¡æ•°

```java
// Redisä¸­çš„æ•°æ®ç»“æ„
// key: "lock:business"
// value: "clientId:threadId:count"
// ä¾‹å¦‚: "server1:thread-123:2"

public boolean reentrantLock(String lockKey, String clientId) {
    String lockValue = jedis.get(lockKey);
    
    if (lockValue == null) {
        // é”ä¸å­˜åœ¨ï¼Œç›´æ¥è·å–
        jedis.setex(lockKey, 30, clientId + ":1");
        return true;
    }
    
    String[] parts = lockValue.split(":");
    String existingClientId = parts[0];
    int count = Integer.parseInt(parts[1]);
    
    if (existingClientId.equals(clientId)) {
        // æ˜¯åŒä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œé‡å…¥æ¬¡æ•°+1
        jedis.setex(lockKey, 30, clientId + ":" + (count + 1));
        return true;
    }
    
    return false;  // å…¶ä»–å®¢æˆ·ç«¯æŒæœ‰é”
}
```

#### ğŸ“Š å¯é‡å…¥è¿‡ç¨‹å›¾ç¤º


```
å®¢æˆ·ç«¯Açš„æ‰§è¡Œæµç¨‹ï¼š

methodA()è°ƒç”¨lock()
    |
    Redis: "business-lock" â†’ "clientA:1"  âœ…è·å–æˆåŠŸ
    |
    methodA()è°ƒç”¨methodB()
        |
        methodB()è°ƒç”¨lock()
        |
        Redis: "business-lock" â†’ "clientA:2"  âœ…é‡å…¥æˆåŠŸ
        |
        methodB()æ‰§è¡Œä¸šåŠ¡é€»è¾‘
        |
        methodB()è°ƒç”¨unlock()
        |
        Redis: "business-lock" â†’ "clientA:1"  è®¡æ•°å‡1
    |
    methodA()è°ƒç”¨unlock()
    |
    Redis: "business-lock" â†’ åˆ é™¤  å®Œå…¨é‡Šæ”¾
```

### 3.3 çº¿ç¨‹çº§å¯é‡å…¥å®ç°


**ğŸ” æ›´ç²¾ç»†çš„å®ç°**ï¼š
```java
public class ReentrantDistributedLock {
    // æœ¬åœ°è®°å½•å½“å‰çº¿ç¨‹çš„é‡å…¥æ¬¡æ•°
    private ThreadLocal<Integer> reentrantCount = new ThreadLocal<>();
    
    public boolean lock(String lockKey) {
        String clientId = getClientId();
        Integer currentCount = reentrantCount.get();
        
        if (currentCount != null && currentCount > 0) {
            // å·²ç»æŒæœ‰é”ï¼Œç›´æ¥é‡å…¥
            reentrantCount.set(currentCount + 1);
            return true;
        }
        
        // å°è¯•è·å–åˆ†å¸ƒå¼é”
        boolean acquired = tryAcquireLock(lockKey, clientId);
        if (acquired) {
            reentrantCount.set(1);
        }
        
        return acquired;
    }
    
    public void unlock(String lockKey) {
        Integer currentCount = reentrantCount.get();
        if (currentCount == null || currentCount <= 0) {
            throw new IllegalStateException("å½“å‰çº¿ç¨‹æ²¡æœ‰æŒæœ‰é”");
        }
        
        if (currentCount == 1) {
            // å®Œå…¨é‡Šæ”¾é”
            releaseLock(lockKey);
            reentrantCount.remove();
        } else {
            // å‡å°‘é‡å…¥è®¡æ•°
            reentrantCount.set(currentCount - 1);
        }
    }
}
```

---

## 4. ğŸ› ï¸ å®¹é”™æ€§è®¾è®¡ç­–ç•¥


### 4.1 å®¹é”™æ€§çš„é‡è¦æ€§


> âš ï¸ **é‡è¦æé†’**  
> åˆ†å¸ƒå¼ç¯å¢ƒä¸­ï¼Œç½‘ç»œåˆ†åŒºã€æœåŠ¡å®•æœºã€æ¶ˆæ¯ä¸¢å¤±éƒ½æ˜¯å¸¸æ€ã€‚åˆ†å¸ƒå¼é”å¿…é¡»èƒ½å¤Ÿä¼˜é›…åœ°å¤„ç†è¿™äº›å¼‚å¸¸æƒ…å†µã€‚

**ğŸš¨ å¸¸è§æ•…éšœåœºæ™¯**ï¼š

| æ•…éšœç±»å‹ | **å…·ä½“è¡¨ç°** | **åæœ** | **å®¹é”™ç­–ç•¥** |
|---------|------------|---------|------------|
| ğŸŒ **ç½‘ç»œåˆ†åŒº** | `å®¢æˆ·ç«¯ä¸é”æœåŠ¡å¤±è”` | `é”çŠ¶æ€ä¸åŒæ­¥` | `è¶…æ—¶è‡ªåŠ¨é‡Šæ”¾` |
| ğŸ’¥ **æœåŠ¡å®•æœº** | `æŒæœ‰é”çš„æœåŠ¡çªç„¶ä¸‹çº¿` | `é”æ°¸è¿œä¸é‡Šæ”¾` | `å¿ƒè·³æ£€æµ‹+å¼ºåˆ¶é‡Šæ”¾` |
| âš¡ **è¿›ç¨‹å¼‚å¸¸** | `ä¸šåŠ¡ä»£ç å´©æºƒæœªé‡Šæ”¾é”` | `æ­»é”çŠ¶æ€` | `é”è‡ªåŠ¨è¿‡æœŸ` |
| ğŸ“¡ **æ¶ˆæ¯ä¸¢å¤±** | `é‡Šæ”¾é”çš„è¯·æ±‚ä¸¢å¤±` | `é”æ³„éœ²` | `å¹‚ç­‰æ€§è®¾è®¡` |

### 4.2 è¶…æ—¶æœºåˆ¶è®¾è®¡


#### â° é”çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†


**ğŸ¯ è®¾è®¡åŸåˆ™**ï¼šå®å¯è¯¯è§£é”ï¼Œä¹Ÿä¸è¦æ­»é”

```java
public class FaultTolerantLock {
    private static final int DEFAULT_LOCK_TIMEOUT = 30;  // é»˜è®¤30ç§’è¶…æ—¶
    private static final int RENEWAL_INTERVAL = 10;      // æ¯10ç§’ç»­æœŸä¸€æ¬¡
    
    public boolean tryLock(String lockKey, String clientId) {
        // è®¾ç½®é”å¹¶æŒ‡å®šè¿‡æœŸæ—¶é—´
        boolean acquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, clientId, Duration.ofSeconds(DEFAULT_LOCK_TIMEOUT));
        
        if (acquired) {
            // å¯åŠ¨é”ç»­æœŸä»»åŠ¡
            startRenewalTask(lockKey, clientId);
        }
        
        return acquired;
    }
}
```

#### ğŸ”„ è‡ªåŠ¨ç»­æœŸæœºåˆ¶


**ğŸ’¡ çœ‹é—¨ç‹—æ¨¡å¼**ï¼š
```java
private void startRenewalTask(String lockKey, String clientId) {
    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
    
    executor.scheduleAtFixedRate(() -> {
        try {
            // æ£€æŸ¥é”æ˜¯å¦è¿˜æ˜¯è‡ªå·±æŒæœ‰
            String currentOwner = redisTemplate.opsForValue().get(lockKey);
            if (clientId.equals(currentOwner)) {
                // ç»­æœŸé”çš„ç”Ÿå‘½å‘¨æœŸ
                redisTemplate.expire(lockKey, Duration.ofSeconds(DEFAULT_LOCK_TIMEOUT));
                log.info("é”ç»­æœŸæˆåŠŸ: {}", lockKey);
            } else {
                // é”å·²ç»ä¸æ˜¯è‡ªå·±çš„äº†ï¼Œåœæ­¢ç»­æœŸ
                executor.shutdown();
            }
        } catch (Exception e) {
            log.error("é”ç»­æœŸå¤±è´¥: {}", lockKey, e);
            // ç»­æœŸå¤±è´¥ï¼Œä¸ºäº†å®‰å…¨åœæ­¢ç»­æœŸ
            executor.shutdown();
        }
    }, RENEWAL_INTERVAL, RENEWAL_INTERVAL, TimeUnit.SECONDS);
}
```

### 4.3 å¼‚å¸¸æ¢å¤æœºåˆ¶


#### ğŸ¥ å¥åº·æ£€æŸ¥ä¸å¼ºåˆ¶é‡Šæ”¾


```java
public class LockHealthChecker {
    
    @Scheduled(fixedDelay = 60000)  // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void checkStuckLocks() {
        Set<String> allLocks = getAllLockKeys();
        
        for (String lockKey : allLocks) {
            String lockValue = redisTemplate.opsForValue().get(lockKey);
            if (lockValue != null) {
                String[] parts = lockValue.split(":");
                String clientId = parts[0];
                long lockTime = Long.parseLong(parts[1]);
                
                // æ£€æŸ¥é”æ˜¯å¦å·²ç»è¶…è¿‡æœ€å¤§æŒæœ‰æ—¶é—´ï¼ˆæ¯”å¦‚5åˆ†é’Ÿï¼‰
                if (System.currentTimeMillis() - lockTime > 300000) {
                    // æ£€æŸ¥æŒæœ‰é”çš„æœåŠ¡æ˜¯å¦è¿˜æ´»ç€
                    if (!isClientAlive(clientId)) {
                        // å¼ºåˆ¶é‡Šæ”¾åƒµå°¸é”
                        redisTemplate.delete(lockKey);
                        log.warn("å¼ºåˆ¶é‡Šæ”¾åƒµå°¸é”: {} (å®¢æˆ·ç«¯: {})", lockKey, clientId);
                    }
                }
            }
        }
    }
    
    private boolean isClientAlive(String clientId) {
        // æ£€æŸ¥å®¢æˆ·ç«¯å¿ƒè·³æˆ–æœåŠ¡æ³¨å†ŒçŠ¶æ€
        return serviceRegistry.isServiceAlive(clientId);
    }
}
```

### 4.4 ä¼˜é›…é™çº§ç­–ç•¥


**ğŸ“‰ é™çº§å¤„ç†æµç¨‹**ï¼š

```
æ­£å¸¸æµç¨‹ï¼šè·å–é” â†’ æ‰§è¡Œä¸šåŠ¡ â†’ é‡Šæ”¾é”

é™çº§æµç¨‹ï¼ˆé”æœåŠ¡ä¸å¯ç”¨ï¼‰ï¼š
    â†“
æ£€æŸ¥ä¸šåŠ¡é‡è¦æ€§
    â†“
ğŸ”´ æ ¸å¿ƒä¸šåŠ¡ï¼šç­‰å¾…é”æœåŠ¡æ¢å¤ æˆ– åˆ‡æ¢åˆ°å…¶ä»–é”å®ç°
ğŸŸ¡ é‡è¦ä¸šåŠ¡ï¼šå¢åŠ é‡è¯•æ¬¡æ•°ï¼Œè®°å½•å‘Šè­¦
ğŸŸ¢ ä¸€èˆ¬ä¸šåŠ¡ï¼šç›´æ¥è·³è¿‡é”æœºåˆ¶ï¼Œè®°å½•æ—¥å¿—
```

```java
public boolean executeWithLock(String lockKey, Runnable business, LockLevel level) {
    try {
        if (distributedLock.tryLock(lockKey, 5, TimeUnit.SECONDS)) {
            business.run();
            return true;
        }
    } catch (LockServiceException e) {
        // é”æœåŠ¡å¼‚å¸¸ï¼Œæ ¹æ®ä¸šåŠ¡çº§åˆ«é™çº§å¤„ç†
        switch (level) {
            case CRITICAL:
                // æ ¸å¿ƒä¸šåŠ¡ï¼šåˆ‡æ¢åˆ°æ•°æ®åº“é”
                return executeWithDatabaseLock(lockKey, business);
            case IMPORTANT:
                // é‡è¦ä¸šåŠ¡ï¼šè®°å½•å‘Šè­¦ï¼Œç¨åé‡è¯•
                alertService.sendAlert("åˆ†å¸ƒå¼é”æœåŠ¡å¼‚å¸¸", e);
                return false;
            case NORMAL:
                // ä¸€èˆ¬ä¸šåŠ¡ï¼šè®°å½•æ—¥å¿—ï¼Œç›´æ¥æ‰§è¡Œ
                log.warn("é”æœåŠ¡ä¸å¯ç”¨ï¼Œç›´æ¥æ‰§è¡Œä¸šåŠ¡: {}", lockKey);
                business.run();
                return true;
        }
    }
    return false;
}
```

---

## 5. â±ï¸ è¶…æ—¶é‡Šæ”¾ä¸é”ç»­æœŸ


### 5.1 è¶…æ—¶é‡Šæ”¾çš„å¿…è¦æ€§


> ğŸ¯ **æ ¸å¿ƒç›®æ ‡**  
> é˜²æ­¢æ­»é”ï¼Œç¡®ä¿å³ä½¿æŒæœ‰é”çš„è¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼Œé”ä¹Ÿèƒ½åœ¨åˆç†æ—¶é—´å†…è¢«é‡Šæ”¾ï¼Œä¸ä¼šæ°¸è¿œé˜»å¡å…¶ä»–è¿›ç¨‹ã€‚

**ğŸ• æ—¶é—´è®¾ç½®ç­–ç•¥**ï¼š

```
ä¸šåŠ¡æ‰§è¡Œæ—¶é—´è¯„ä¼°ï¼š
    â†“
å¿«é€Ÿæ“ä½œï¼ˆ<1ç§’ï¼‰  â†’ é”è¶…æ—¶æ—¶é—´ï¼š10-30ç§’
æ™®é€šæ“ä½œï¼ˆ1-10ç§’ï¼‰ â†’ é”è¶…æ—¶æ—¶é—´ï¼š30-60ç§’  
æ…¢é€Ÿæ“ä½œï¼ˆ>10ç§’ï¼‰  â†’ é”è¶…æ—¶æ—¶é—´ï¼š2-5åˆ†é’Ÿ + è‡ªåŠ¨ç»­æœŸ
```

### 5.2 æ™ºèƒ½ç»­æœŸç­–ç•¥


#### ğŸ¤– è‡ªé€‚åº”ç»­æœŸç®—æ³•


```java
public class SmartLockRenewal {
    private final Map<String, LockInfo> activeLocks = new ConcurrentHashMap<>();
    
    public void startSmartRenewal(String lockKey, String clientId, Runnable business) {
        LockInfo lockInfo = new LockInfo(lockKey, clientId, System.currentTimeMillis());
        activeLocks.put(lockKey, lockInfo);
        
        // åœ¨å•ç‹¬çº¿ç¨‹ä¸­æ‰§è¡Œä¸šåŠ¡
        CompletableFuture.runAsync(() -> {
            try {
                business.run();
            } finally {
                activeLocks.remove(lockKey);  // ä¸šåŠ¡å®Œæˆï¼Œåœæ­¢ç»­æœŸ
            }
        });
        
        // å¯åŠ¨ç»­æœŸä»»åŠ¡
        startRenewalTask(lockKey, clientId);
    }
    
    private void startRenewalTask(String lockKey, String clientId) {
        ScheduledExecutorService executor = renewalExecutors.get(lockKey);
        if (executor == null) {
            executor = Executors.newSingleThreadScheduledExecutor();
            renewalExecutors.put(lockKey, executor);
        }
        
        executor.scheduleWithFixedDelay(() -> {
            LockInfo lockInfo = activeLocks.get(lockKey);
            if (lockInfo == null) {
                // ä¸šåŠ¡å·²å®Œæˆï¼Œå…³é—­ç»­æœŸ
                executor.shutdown();
                renewalExecutors.remove(lockKey);
                return;
            }
            
            // æ ¹æ®é”æŒæœ‰æ—¶é—´åŠ¨æ€è°ƒæ•´ç»­æœŸç­–ç•¥
            long holdTime = System.currentTimeMillis() - lockInfo.getStartTime();
            int renewalTime = calculateRenewalTime(holdTime);
            
            boolean renewed = renewLock(lockKey, clientId, renewalTime);
            if (!renewed) {
                log.warn("é”ç»­æœŸå¤±è´¥ï¼Œå¯èƒ½å·²è¢«å…¶ä»–å®¢æˆ·ç«¯è·å–: {}", lockKey);
                executor.shutdown();
            }
            
        }, 10, 10, TimeUnit.SECONDS);
    }
    
    private int calculateRenewalTime(long holdTime) {
        if (holdTime < 30000) return 30;      // 30ç§’å†…ï¼šç»­æœŸ30ç§’
        if (holdTime < 300000) return 60;     // 5åˆ†é’Ÿå†…ï¼šç»­æœŸ60ç§’  
        return 120;                           // è¶…è¿‡5åˆ†é’Ÿï¼šç»­æœŸ2åˆ†é’Ÿï¼ˆå¯èƒ½æ˜¯é•¿ä»»åŠ¡ï¼‰
    }
}
```

### 5.3 ç»­æœŸå¤±è´¥å¤„ç†


**ğŸš¨ ç»­æœŸå¤±è´¥çš„åŸå› åˆ†æ**ï¼š

| å¤±è´¥åŸå›  | **æ£€æµ‹æ–¹æ³•** | **å¤„ç†ç­–ç•¥** | **ä¸šåŠ¡å½±å“** |
|---------|------------|------------|------------|
| ğŸ”’ **é”å·²è¢«æŠ¢å ** | `æ£€æŸ¥é”çš„æŒæœ‰è€…` | `ç«‹å³åœæ­¢ä¸šåŠ¡æ‰§è¡Œ` | `æ•°æ®ä¸€è‡´æ€§ä¿æŠ¤` |
| ğŸŒ **ç½‘ç»œå¼‚å¸¸** | `è¿æ¥è¶…æ—¶å¼‚å¸¸` | `é‡è¯•3æ¬¡ååœæ­¢` | `å¯èƒ½çŸ­æš‚ä¸­æ–­` |
| ğŸ’¥ **Rediså®•æœº** | `è¿æ¥æ‹’ç»å¼‚å¸¸` | `åˆ‡æ¢å¤‡ç”¨æ–¹æ¡ˆ` | `ä¸šåŠ¡é™çº§å¤„ç†` |
| âš¡ **å®¢æˆ·ç«¯å¼‚å¸¸** | `æœ¬åœ°æ£€æµ‹` | `ä¼˜é›…å…³é—­èµ„æº` | `é¿å…èµ„æºæ³„éœ²` |

```java
public class LockRenewalHandler {
    
    public boolean handleRenewalFailure(String lockKey, Exception e, Runnable stopBusiness) {
        if (e instanceof RedisConnectionException) {
            // Redisè¿æ¥å¼‚å¸¸ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜
            return retryRenewal(lockKey, 3);
            
        } else if (e instanceof LockNotOwnedException) {
            // é”å·²ç»ä¸å±äºå½“å‰å®¢æˆ·ç«¯
            log.error("æ£€æµ‹åˆ°é”è¢«æŠ¢å ï¼Œç«‹å³åœæ­¢ä¸šåŠ¡æ‰§è¡Œ: {}", lockKey);
            stopBusiness.run();  // ç«‹å³åœæ­¢ä¸šåŠ¡
            return false;
            
        } else {
            // å…¶ä»–æœªçŸ¥å¼‚å¸¸
            log.error("é”ç»­æœŸé‡åˆ°æœªçŸ¥å¼‚å¸¸: {}", lockKey, e);
            // ä¸ºäº†å®‰å…¨èµ·è§ï¼Œåœæ­¢ä¸šåŠ¡æ‰§è¡Œ
            stopBusiness.run();
            return false;
        }
    }
    
    private boolean retryRenewal(String lockKey, int maxRetries) {
        for (int i = 0; i < maxRetries; i++) {
            try {
                Thread.sleep(1000 * (i + 1));  // é€’å¢å»¶è¿Ÿ
                return renewLock(lockKey);
            } catch (Exception e) {
                log.warn("é”ç»­æœŸé‡è¯•å¤±è´¥ ({}/{}): {}", i + 1, maxRetries, lockKey);
            }
        }
        return false;
    }
}
```

### 5.4 ä¸šåŠ¡æ„ŸçŸ¥çš„ç»­æœŸæœºåˆ¶


**ğŸ’¡ æ™ºèƒ½æ„ŸçŸ¥ä¸šåŠ¡è¿›åº¦**ï¼š

```java
// ä¸šåŠ¡è¿›åº¦æ„ŸçŸ¥æ¥å£
public interface ProgressAware {
    int getProgressPercent();      // è¿”å›0-100çš„è¿›åº¦
    long getEstimatedRemainTime(); // é¢„ä¼°å‰©ä½™æ—¶é—´(æ¯«ç§’)
}

public class ProgressAwareRenewal {
    
    public void executWithProgressAwareLock(String lockKey, ProgressAware business) {
        String clientId = getClientId();
        
        if (tryLock(lockKey, clientId)) {
            CompletableFuture<Void> businessFuture = CompletableFuture.runAsync(() -> {
                business.run();
            });
            
            // æ ¹æ®ä¸šåŠ¡è¿›åº¦æ™ºèƒ½ç»­æœŸ
            while (!businessFuture.isDone()) {
                int progress = business.getProgressPercent();
                long remainTime = business.getEstimatedRemainTime();
                
                // æ ¹æ®å‰©ä½™æ—¶é—´å†³å®šç»­æœŸæ—¶é•¿
                int renewalDuration = calculateOptimalRenewal(remainTime);
                renewLock(lockKey, clientId, renewalDuration);
                
                // æ ¹æ®è¿›åº¦è°ƒæ•´æ£€æŸ¥é—´éš”
                int checkInterval = progress > 80 ? 5 : 10;  // å¿«å®Œæˆæ—¶æ›´é¢‘ç¹æ£€æŸ¥
                Thread.sleep(checkInterval * 1000);
            }
            
            unlock(lockKey, clientId);
        }
    }
    
    private int calculateOptimalRenewal(long remainTime) {
        if (remainTime <= 30000) return 30;    // å‰©ä½™30ç§’å†…ï¼Œç»­æœŸ30ç§’
        if (remainTime <= 300000) return 60;   // å‰©ä½™5åˆ†é’Ÿå†…ï¼Œç»­æœŸ1åˆ†é’Ÿ
        return Math.min(120, (int) (remainTime / 1000 / 2));  // ç»­æœŸå‰©ä½™æ—¶é—´çš„ä¸€åŠï¼Œæœ€å¤š2åˆ†é’Ÿ
    }
}
```

---

## 6. âš–ï¸ å…¬å¹³æ€§ä¸æ€§èƒ½å¹³è¡¡


### 6.1 å…¬å¹³æ€§çš„å«ä¹‰


> ğŸ’¡ **ç®€å•ç†è§£**  
> å…¬å¹³é”å°±åƒæ’é˜Ÿä¹°ç¥¨ï¼Œå…ˆæ¥çš„äººå…ˆä¹°ç¥¨ã€‚éå…¬å¹³é”å°±åƒæŠ¢ç¥¨ï¼Œè°æ‰‹å¿«è°å…ˆä¹°åˆ°ï¼Œä¸ç®¡æ¥çš„é¡ºåºã€‚

**ğŸ¯ å…¬å¹³æ€§å¯¹æ¯”**ï¼š

```
å…¬å¹³é”åœºæ™¯ï¼š
å®¢æˆ·ç«¯è¯·æ±‚é¡ºåºï¼šA â†’ B â†’ C â†’ D
è·å–é”é¡ºåºï¼š  A â†’ B â†’ C â†’ D  âœ…æŒ‰é¡ºåºæ‰§è¡Œ

éå…¬å¹³é”åœºæ™¯ï¼š  
å®¢æˆ·ç«¯è¯·æ±‚é¡ºåºï¼šA â†’ B â†’ C â†’ D
è·å–é”é¡ºåºï¼š  A â†’ D â†’ B â†’ C  ğŸ¤·éšæœºæ‰§è¡Œï¼ˆDå¯èƒ½ç½‘ç»œæ›´å¿«ï¼‰
```

### 6.2 å…¬å¹³é”å®ç°æœºåˆ¶


#### ğŸ“ åŸºäºé˜Ÿåˆ—çš„å…¬å¹³å®ç°


```java
public class FairDistributedLock {
    private static final String QUEUE_KEY_PREFIX = "fair_queue:";
    private static final String LOCK_KEY_PREFIX = "fair_lock:";
    
    public boolean tryFairLock(String lockName, String clientId, long timeoutMs) {
        String queueKey = QUEUE_KEY_PREFIX + lockName;
        String lockKey = LOCK_KEY_PREFIX + lockName;
        
        // 1. åŠ å…¥æ’é˜Ÿé˜Ÿåˆ—
        long queuePosition = redisTemplate.opsForList().rightPush(queueKey, clientId);
        
        try {
            long startTime = System.currentTimeMillis();
            
            while (System.currentTimeMillis() - startTime < timeoutMs) {
                // 2. æ£€æŸ¥æ˜¯å¦è½®åˆ°è‡ªå·±
                String firstInQueue = redisTemplate.opsForList().index(queueKey, 0);
                
                if (clientId.equals(firstInQueue)) {
                    // 3. è½®åˆ°è‡ªå·±ï¼Œå°è¯•è·å–é”
                    Boolean lockAcquired = redisTemplate.opsForValue()
                        .setIfAbsent(lockKey, clientId, Duration.ofSeconds(30));
                    
                    if (lockAcquired) {
                        // 4. è·å–æˆåŠŸï¼Œä»é˜Ÿåˆ—ä¸­ç§»é™¤è‡ªå·±
                        redisTemplate.opsForList().leftPop(queueKey);
                        return true;
                    }
                }
                
                // 5. è¿˜æ²¡è½®åˆ°ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´
                Thread.sleep(100);
            }
            
            return false;
            
        } finally {
            // è·å–å¤±è´¥æˆ–è¶…æ—¶ï¼Œä»é˜Ÿåˆ—ä¸­ç§»é™¤è‡ªå·±
            redisTemplate.opsForList().remove(queueKey, 1, clientId);
        }
    }
}
```

#### ğŸ”„ æ’é˜ŸçŠ¶æ€å¯è§†åŒ–


```
Redisä¸­çš„é˜Ÿåˆ—çŠ¶æ€æ¼”ç¤ºï¼š

åˆå§‹çŠ¶æ€ï¼š
fair_queue:order_lock = []
fair_lock:order_lock = null

å®¢æˆ·ç«¯Aè¯·æ±‚ï¼š
fair_queue:order_lock = [A]
fair_lock:order_lock = A (Aè·å–æˆåŠŸ)

å®¢æˆ·ç«¯Bè¯·æ±‚ï¼š
fair_queue:order_lock = [B]  
fair_lock:order_lock = A (Bç­‰å¾…)

å®¢æˆ·ç«¯Cè¯·æ±‚ï¼š
fair_queue:order_lock = [B, C]
fair_lock:order_lock = A (Cæ’åœ¨Båé¢)

å®¢æˆ·ç«¯Aé‡Šæ”¾ï¼š
fair_queue:order_lock = [C]
fair_lock:order_lock = B (Bè·å–æˆåŠŸï¼Œä»é˜Ÿåˆ—å¤´éƒ¨ç§»é™¤)
```

### 6.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥


#### âš¡ å‡å°‘Redisç½‘ç»œè°ƒç”¨


**ğŸ¯ æ‰¹é‡æ“ä½œä¼˜åŒ–**ï¼š
```java
public class OptimizedFairLock {
    
    // ä½¿ç”¨Luaè„šæœ¬å®ç°åŸå­æ“ä½œ
    private static final String FAIR_LOCK_SCRIPT = """
        local queueKey = KEYS[1]
        local lockKey = KEYS[2] 
        local clientId = ARGV[1]
        local expireTime = ARGV[2]
        
        -- æ£€æŸ¥é˜Ÿåˆ—ä¸­çš„ä½ç½®
        local queueList = redis.call('LRANGE', queueKey, 0, -1)
        local position = -1
        for i, v in ipairs(queueList) do
            if v == clientId then
                position = i - 1  -- Redisåˆ—è¡¨ç´¢å¼•ä»0å¼€å§‹
                break
            end
        end
        
        -- å¦‚æœä¸åœ¨é˜Ÿåˆ—ä¸­ï¼ŒåŠ å…¥é˜Ÿåˆ—
        if position == -1 then
            redis.call('RPUSH', queueKey, clientId)
            return {false, -1}  -- åˆšåŠ å…¥é˜Ÿåˆ—ï¼Œè¿”å›å¤±è´¥
        end
        
        -- å¦‚æœæ˜¯é˜Ÿåˆ—ç¬¬ä¸€ä¸ªï¼Œå°è¯•è·å–é”
        if position == 0 then
            local locked = redis.call('SET', lockKey, clientId, 'NX', 'EX', expireTime)
            if locked then
                redis.call('LPOP', queueKey)  -- ä»é˜Ÿåˆ—ä¸­ç§»é™¤
                return {true, 0}
            end
        end
        
        return {false, position}  -- è¿”å›å½“å‰æ’é˜Ÿä½ç½®
        """;
    
    public LockResult tryFairLock(String lockName, String clientId) {
        List<Object> result = redisTemplate.execute(
            fairLockScript,
            Arrays.asList(QUEUE_KEY_PREFIX + lockName, LOCK_KEY_PREFIX + lockName),
            clientId, "30"
        );
        
        boolean acquired = (Boolean) result.get(0);
        int queuePosition = (Integer) result.get(1);
        
        return new LockResult(acquired, queuePosition);
    }
}
```

### 6.4 å…¬å¹³æ€§ä¸æ€§èƒ½çš„æƒè¡¡


**ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”åˆ†æ**ï¼š

| ç‰¹æ€§ | **éå…¬å¹³é”** | **å…¬å¹³é”** | **æ··åˆæ–¹æ¡ˆ** |
|------|-------------|-----------|-------------|
| âš¡ **æ€§èƒ½** | `æé«˜ï¼ˆç›´æ¥æŠ¢é”ï¼‰` | `è¾ƒä½ï¼ˆéœ€è¦æ’é˜Ÿï¼‰` | `ä¸­ç­‰ï¼ˆå¿«æ…¢åˆ†ç¦»ï¼‰` |
| âš–ï¸ **å…¬å¹³æ€§** | `æ— ä¿éšœ` | `ä¸¥æ ¼å…¬å¹³` | `ç›¸å¯¹å…¬å¹³` |
| ğŸ”„ **ååé‡** | `æœ€é«˜` | `è¾ƒä½` | `é«˜` |
| ğŸ¤ **é¥¥é¥¿ç°è±¡** | `å¯èƒ½å‘ç”Ÿ` | `ä¸ä¼šå‘ç”Ÿ` | `å¾ˆå°‘å‘ç”Ÿ` |
| ğŸ› ï¸ **å®ç°å¤æ‚åº¦** | `ç®€å•` | `å¤æ‚` | `ä¸­ç­‰` |

**ğŸ¯ æ¨èä½¿ç”¨åœºæ™¯**ï¼š

```
éå…¬å¹³é”é€‚ç”¨åœºæ™¯ï¼š
âœ… é«˜å¹¶å‘ã€å¯¹æ€§èƒ½è¦æ±‚æé«˜çš„åœºæ™¯
âœ… ä¸šåŠ¡é€»è¾‘ç®€å•ï¼Œæ‰§è¡Œæ—¶é—´å¾ˆçŸ­
âœ… å¯ä»¥å®¹å¿éƒ¨åˆ†è¯·æ±‚è¢«"é¥¿æ­»"
ä¾‹å¦‚ï¼šç¼“å­˜æ›´æ–°ã€è®¡æ•°å™¨æ“ä½œ

å…¬å¹³é”é€‚ç”¨åœºæ™¯ï¼š
âœ… ä¸šåŠ¡è¦æ±‚ä¸¥æ ¼æŒ‰é¡ºåºå¤„ç†
âœ… é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡
âœ… ä¸èƒ½å®¹å¿è¯·æ±‚è¢«é•¿æœŸé˜»å¡
ä¾‹å¦‚ï¼šè®¢å•å¤„ç†ã€æ–‡ä»¶ä¸Šä¼ 

æ··åˆæ–¹æ¡ˆï¼š
âœ… å¤§éƒ¨åˆ†åœºæ™¯çš„æœ€ä½³é€‰æ‹©
âœ… åœ¨æ€§èƒ½å’Œå…¬å¹³æ€§ä¹‹é—´æ‰¾å¹³è¡¡
```

### 6.5 æ™ºèƒ½å…¬å¹³æ€§ç­–ç•¥


```java
public class AdaptiveFairLock {
    private final LoadMonitor loadMonitor;
    
    public boolean tryLock(String lockName, String clientId, LockMode mode) {
        // æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€é€‰æ‹©é”æ¨¡å¼
        if (mode == LockMode.AUTO) {
            double systemLoad = loadMonitor.getCurrentLoad();
            if (systemLoad > 0.8) {
                // é«˜è´Ÿè½½æ—¶ä½¿ç”¨éå…¬å¹³é”ï¼Œæé«˜ååé‡
                return tryUnfairLock(lockName, clientId);
            } else {
                // ä½è´Ÿè½½æ—¶ä½¿ç”¨å…¬å¹³é”ï¼Œä¿è¯å…¬å¹³æ€§
                return tryFairLock(lockName, clientId);
            }
        }
        
        return mode == LockMode.FAIR ? 
            tryFairLock(lockName, clientId) : 
            tryUnfairLock(lockName, clientId);
    }
}
```

---

## 7. ğŸ”— ä¸€è‡´æ€§ä¿éšœæœºåˆ¶


### 7.1 ä¸€è‡´æ€§çš„é‡è¦æ€§


> âš ï¸ **æ ¸å¿ƒç†å¿µ**  
> åˆ†å¸ƒå¼é”çš„ä¸€è‡´æ€§æ˜¯æŒ‡ï¼šæ‰€æœ‰èŠ‚ç‚¹å¯¹é”çŠ¶æ€çš„è®¤çŸ¥å¿…é¡»ä¿æŒä¸€è‡´ï¼Œä¸èƒ½å‡ºç°"æœ‰çš„èŠ‚ç‚¹è®¤ä¸ºé”è¢«æŒæœ‰ï¼Œæœ‰çš„èŠ‚ç‚¹è®¤ä¸ºé”æ˜¯ç©ºé—²çš„"è¿™ç§æƒ…å†µã€‚

**ğŸš¨ ä¸€è‡´æ€§é—®é¢˜çš„å…¸å‹åœºæ™¯**ï¼š

```
æ—¶é—´çº¿é—®é¢˜ç¤ºä¾‹ï¼š

t1: å®¢æˆ·ç«¯Aè·å–é”æˆåŠŸ
t2: ç½‘ç»œåˆ†åŒºå‘ç”Ÿï¼ŒAä¸Redisä¸»èŠ‚ç‚¹å¤±è”  
t3: Redisä¸»èŠ‚ç‚¹å®•æœºï¼Œä»èŠ‚ç‚¹å‡çº§ä¸ºä¸»èŠ‚ç‚¹
t4: å®¢æˆ·ç«¯Bä»æ–°ä¸»èŠ‚ç‚¹æˆåŠŸè·å–åŒä¸€æŠŠé”
t5: ç½‘ç»œæ¢å¤ï¼ŒAå’ŒBåŒæ—¶è®¤ä¸ºè‡ªå·±æŒæœ‰é”ï¼

ç»“æœï¼šğŸ’¥ ä¸¤ä¸ªå®¢æˆ·ç«¯åŒæ—¶æ“ä½œå…±äº«èµ„æºï¼
```

### 7.2 å¼ºä¸€è‡´æ€§å®ç°æ–¹æ¡ˆ


#### ğŸ›ï¸ åŸºäºRaftåè®®çš„å®ç°


**ğŸ¯ æ ¸å¿ƒæ€æƒ³**ï¼šåªæœ‰å¤§å¤šæ•°èŠ‚ç‚¹ç¡®è®¤ï¼Œé”æ“ä½œæ‰ç®—æˆåŠŸ

```java
public class ConsistentDistributedLock {
    private List<RedisClient> redisNodes;  // Redisé›†ç¾¤èŠ‚ç‚¹
    
    public boolean tryLockWithConsistency(String lockKey, String clientId) {
        int successCount = 0;
        int totalNodes = redisNodes.size();
        int requiredNodes = totalNodes / 2 + 1;  // éœ€è¦å¤§å¤šæ•°èŠ‚ç‚¹ç¡®è®¤
        
        List<CompletableFuture<Boolean>> futures = new ArrayList<>();
        
        // å¹¶è¡Œå‘æ‰€æœ‰èŠ‚ç‚¹è¯·æ±‚é”
        for (RedisClient node : redisNodes) {
            CompletableFuture<Boolean> future = CompletableFuture.supplyAsync(() -> {
                try {
                    return node.setIfAbsent(lockKey, clientId, 30, TimeUnit.SECONDS);
                } catch (Exception e) {
                    log.warn("èŠ‚ç‚¹é”è·å–å¤±è´¥: {}", node.getAddress(), e);
                    return false;
                }
            });
            futures.add(future);
        }
        
        // ç­‰å¾…ç»“æœå¹¶ç»Ÿè®¡æˆåŠŸæ•°é‡
        for (CompletableFuture<Boolean> future : futures) {
            try {
                if (future.get(1, TimeUnit.SECONDS)) {  // 1ç§’è¶…æ—¶
                    successCount++;
                }
            } catch (Exception e) {
                // è¶…æ—¶æˆ–å¼‚å¸¸å½“ä½œå¤±è´¥å¤„ç†
            }
        }
        
        boolean lockAcquired = successCount >= requiredNodes;
        
        if (!lockAcquired) {
            // è·å–é”å¤±è´¥ï¼Œé‡Šæ”¾å·²ç»è·å–çš„é”
            releaseLockFromAllNodes(lockKey, clientId);
        }
        
        return lockAcquired;
    }
}
```

#### ğŸ”„ ä¸¤é˜¶æ®µæäº¤å®ç°


```java
public class TwoPhaseCommitLock {
    
    public boolean tryLockWithTwoPhase(String lockKey, String clientId) {
        String transactionId = UUID.randomUUID().toString();
        
        // é˜¶æ®µ1ï¼šå‡†å¤‡é˜¶æ®µ - è¯¢é—®æ‰€æœ‰èŠ‚ç‚¹æ˜¯å¦å¯ä»¥è·å–é”
        boolean canLock = preparePhase(lockKey, clientId, transactionId);
        
        if (canLock) {
            // é˜¶æ®µ2ï¼šæäº¤é˜¶æ®µ - é€šçŸ¥æ‰€æœ‰èŠ‚ç‚¹ç¡®è®¤è·å–é”
            return commitPhase(lockKey, clientId, transactionId);
        } else {
            // å‡†å¤‡å¤±è´¥ï¼Œé€šçŸ¥æ‰€æœ‰èŠ‚ç‚¹å›æ»š
            abortPhase(lockKey, clientId, transactionId);
            return false;
        }
    }
    
    private boolean preparePhase(String lockKey, String clientId, String transactionId) {
        int successCount = 0;
        
        for (RedisClient node : redisNodes) {
            // ä½¿ç”¨ç‰¹æ®Šçš„å‡†å¤‡é”ï¼Œè¡¨ç¤º"é¢„å¤‡è·å–"çŠ¶æ€
            String prepareKey = "prepare:" + lockKey;
            String prepareValue = clientId + ":" + transactionId;
            
            boolean prepared = node.setIfAbsent(prepareKey, prepareValue, 60, TimeUnit.SECONDS);
            if (prepared) {
                successCount++;
            }
        }
        
        return successCount >= (redisNodes.size() / 2 + 1);
    }
    
    private boolean commitPhase(String lockKey, String clientId, String transactionId) {
        // Luaè„šæœ¬ç¡®ä¿åŸå­æ€§ï¼šæ£€æŸ¥prepareé”å¹¶è½¬æ¢ä¸ºæ­£å¼é”
        String commitScript = """
            local prepareKey = 'prepare:' .. KEYS[1]
            local lockKey = KEYS[1]
            local expectedValue = ARGV[1] .. ':' .. ARGV[2]
            
            local prepareValue = redis.call('GET', prepareKey)
            if prepareValue == expectedValue then
                redis.call('DEL', prepareKey)
                redis.call('SET', lockKey, ARGV[1], 'EX', 30)
                return 1
            else
                return 0
            end
            """;
        
        int commitCount = 0;
        for (RedisClient node : redisNodes) {
            Object result = node.eval(commitScript, 
                Arrays.asList(lockKey), 
                Arrays.asList(clientId, transactionId));
            if ("1".equals(result.toString())) {
                commitCount++;
            }
        }
        
        return commitCount >= (redisNodes.size() / 2 + 1);
    }
}
```

### 7.3 æœ€ç»ˆä¸€è‡´æ€§æ–¹æ¡ˆ


#### ğŸ• å¼‚æ­¥åŒæ­¥ç­–ç•¥


å¯¹äºæ€§èƒ½è¦æ±‚è¾ƒé«˜çš„åœºæ™¯ï¼Œå¯ä»¥é‡‡ç”¨æœ€ç»ˆä¸€è‡´æ€§ï¼š

```java
public class EventuallyConsistentLock {
    private EventBus eventBus;  // äº‹ä»¶æ€»çº¿
    
    public boolean tryLock(String lockKey, String clientId) {
        // 1. å…ˆä»ä¸»èŠ‚ç‚¹è·å–é”
        boolean lockAcquired = masterNode.setIfAbsent(lockKey, clientId, 30, TimeUnit.SECONDS);
        
        if (lockAcquired) {
            // 2. å¼‚æ­¥åŒæ­¥åˆ°ä»èŠ‚ç‚¹
            LockEvent event = new LockEvent(lockKey, clientId, LockEvent.Type.ACQUIRE);
            eventBus.post(event);
            
            return true;
        }
        
        return false;
    }
    
    @EventHandler
    public void handleLockEvent(LockEvent event) {
        // å¼‚æ­¥å¤„ç†é”äº‹ä»¶ï¼ŒåŒæ­¥åˆ°æ‰€æœ‰ä»èŠ‚ç‚¹
        CompletableFuture.runAsync(() -> {
            for (RedisClient slaveNode : slaveNodes) {
                try {
                    syncLockToSlave(slaveNode, event);
                } catch (Exception e) {
                    // åŒæ­¥å¤±è´¥ï¼Œè®°å½•åˆ°è¡¥å¿é˜Ÿåˆ—
                    compensationQueue.offer(new CompensationTask(slaveNode, event));
                }
            }
        });
    }
    
    // è¡¥å¿æœºåˆ¶ï¼šå®šæœŸå¤„ç†åŒæ­¥å¤±è´¥çš„æ“ä½œ
    @Scheduled(fixedDelay = 5000)
    public void processCompensationQueue() {
        CompensationTask task;
        while ((task = compensationQueue.poll()) != null) {
            try {
                syncLockToSlave(task.getNode(), task.getEvent());
                log.info("è¡¥å¿åŒæ­¥æˆåŠŸ: {}", task);
            } catch (Exception e) {
                // é‡è¯•å¤±è´¥ï¼Œå¯èƒ½éœ€è¦äººå·¥ä»‹å…¥
                log.error("è¡¥å¿åŒæ­¥å¤±è´¥: {}", task, e);
                compensationQueue.offer(task);  // é‡æ–°å…¥é˜Ÿï¼Œé™åˆ¶é‡è¯•æ¬¡æ•°
                break;
            }
        }
    }
}
```

### 7.4 ä¸€è‡´æ€§æ£€æµ‹ä¸ä¿®å¤


```java
public class ConsistencyChecker {
    
    @Scheduled(fixedRate = 30000)  // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void checkLockConsistency() {
        Set<String> allLockKeys = getAllActiveLockKeys();
        
        for (String lockKey : allLockKeys) {
            Map<String, String> nodeStates = new HashMap<>();
            
            // æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹çš„é”çŠ¶æ€
            for (RedisClient node : redisNodes) {
                try {
                    String lockValue = node.get(lockKey);
                    nodeStates.put(node.getAddress(), lockValue);
                } catch (Exception e) {
                    nodeStates.put(node.getAddress(), "ERROR:" + e.getMessage());
                }
            }
            
            // æ£€æŸ¥ä¸€è‡´æ€§
            if (!isConsistent(nodeStates)) {
                log.warn("æ£€æµ‹åˆ°é”çŠ¶æ€ä¸ä¸€è‡´: {} -> {}", lockKey, nodeStates);
                repairInconsistency(lockKey, nodeStates);
            }
        }
    }
    
    private void repairInconsistency(String lockKey, Map<String, String> nodeStates) {
        // ç®€å•çš„ä¿®å¤ç­–ç•¥ï¼šä»¥å¤§å¤šæ•°èŠ‚ç‚¹çš„çŠ¶æ€ä¸ºå‡†
        Map<String, Integer> stateCount = new HashMap<>();
        
        for (String state : nodeStates.values()) {
            if (!state.startsWith("ERROR:")) {
                stateCount.merge(state, 1, Integer::sum);
            }
        }
        
        // æ‰¾å‡ºå¤§å¤šæ•°èŠ‚ç‚¹çš„çŠ¶æ€
        String majorityState = stateCount.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);
        
        if (majorityState != null) {
            // å°†å°‘æ•°èŠ‚ç‚¹çš„çŠ¶æ€ä¿®æ­£ä¸ºå¤§å¤šæ•°çŠ¶æ€
            for (RedisClient node : redisNodes) {
                String currentState = nodeStates.get(node.getAddress());
                if (!majorityState.equals(currentState) && !currentState.startsWith("ERROR:")) {
                    repairNodeState(node, lockKey, majorityState);
                }
            }
        }
    }
}
```

---

## 8. ğŸ“Š å¯è§‚æµ‹æ€§ä¸æ˜“ç”¨æ€§


### 8.1 å¯è§‚æµ‹æ€§çš„é‡è¦æ€§


> ğŸ’¡ **ç›‘æ§ç†å¿µ**  
> å¥½çš„åˆ†å¸ƒå¼é”ä¸ä»…è¦åŠŸèƒ½å¼ºå¤§ï¼Œè¿˜è¦"å¯è§å¯æ§"ã€‚ç®¡ç†å‘˜éœ€è¦æ¸…æ¥šåœ°çœ‹åˆ°é”çš„ä½¿ç”¨æƒ…å†µï¼Œå¼€å‘äººå‘˜éœ€è¦æ–¹ä¾¿åœ°ä½¿ç”¨å’Œè°ƒè¯•ã€‚

**ğŸ¯ ç›‘æ§ç»´åº¦**ï¼š

```
è¿è¡Œæ—¶ç›‘æ§ï¼š
â”œâ”€â”€ ğŸ”’ é”çŠ¶æ€ç›‘æ§ï¼šå½“å‰æŒæœ‰ã€ç­‰å¾…é˜Ÿåˆ—ã€æˆåŠŸç‡
â”œâ”€â”€ â±ï¸ æ€§èƒ½ç›‘æ§ï¼šè·å–è€—æ—¶ã€æŒæœ‰æ—¶é•¿ã€é‡Šæ”¾è€—æ—¶  
â”œâ”€â”€ ğŸš¨ å¼‚å¸¸ç›‘æ§ï¼šè¶…æ—¶ã€æ­»é”ã€è·å–å¤±è´¥
â””â”€â”€ ğŸ“Š ä¸šåŠ¡ç›‘æ§ï¼šå„ä¸šåŠ¡çº¿é”ä½¿ç”¨ç»Ÿè®¡

èµ„æºç›‘æ§ï¼š
â”œâ”€â”€ ğŸ’¾ å­˜å‚¨ä½¿ç”¨ï¼šRediså†…å­˜ã€è¿æ¥æ•°
â”œâ”€â”€ ğŸŒ ç½‘ç»œçŠ¶æ€ï¼šå»¶è¿Ÿã€ä¸¢åŒ…ã€è¿æ¥è´¨é‡
â””â”€â”€ âš¡ ç³»ç»Ÿè´Ÿè½½ï¼šCPUã€å†…å­˜ä½¿ç”¨ç‡
```

### 8.2 ç›‘æ§æŒ‡æ ‡è®¾è®¡


#### ğŸ“ˆ æ ¸å¿ƒæŒ‡æ ‡ä½“ç³»


```java
public class LockMetrics {
    private final MeterRegistry meterRegistry;
    private final Map<String, LockStats> lockStatsMap = new ConcurrentHashMap<>();
    
    public void recordLockAcquisition(String lockKey, boolean success, long duration) {
        // è®°å½•è·å–é”çš„æˆåŠŸç‡å’Œè€—æ—¶
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("lock.acquisition.time")
            .tag("lock_key", lockKey)
            .tag("success", String.valueOf(success))
            .register(meterRegistry));
        
        // æ›´æ–°é”ç»Ÿè®¡
        LockStats stats = lockStatsMap.computeIfAbsent(lockKey, k -> new LockStats());
        stats.incrementAttempts();
        if (success) {
            stats.incrementSuccesses();
        }
        
        // å®æ—¶æŒ‡æ ‡
        Gauge.builder("lock.queue.size")
            .tag("lock_key", lockKey)
            .register(meterRegistry, this, metrics -> getCurrentQueueSize(lockKey));
            
        Counter.builder("lock.attempts.total")
            .tag("lock_key", lockKey)
            .tag("result", success ? "success" : "failed")
            .register(meterRegistry)
            .increment();
    }
    
    public void recordLockHolding(String lockKey, long holdTimeMs) {
        // è®°å½•é”æŒæœ‰æ—¶é—´åˆ†å¸ƒ
        Timer.builder("lock.holding.time")
            .tag("lock_key", lockKey)
            .register(meterRegistry)
            .record(holdTimeMs, TimeUnit.MILLISECONDS);
        
        // æ£€æŸ¥æ˜¯å¦æŒæœ‰æ—¶é—´è¿‡é•¿ï¼ˆå¯èƒ½çš„é—®é¢˜æŒ‡æ ‡ï¼‰
        if (holdTimeMs > 60000) {  // è¶…è¿‡1åˆ†é’Ÿ
            Counter.builder("lock.long.holding.count")
                .tag("lock_key", lockKey)
                .register(meterRegistry)
                .increment();
        }
    }
}
```

#### ğŸ“Š ç›‘æ§é¢æ¿å±•ç¤º


```java
@RestController
@RequestMapping("/lock/monitor")
public class LockMonitorController {
    
    @GetMapping("/dashboard")
    public LockDashboard getDashboard() {
        return LockDashboard.builder()
            .activeLocks(getActiveLocks())
            .queueInfo(getQueueInfo())
            .performanceMetrics(getPerformanceMetrics())
            .healthStatus(getHealthStatus())
            .build();
    }
    
    @GetMapping("/locks/{lockKey}/details")
    public LockDetails getLockDetails(@PathVariable String lockKey) {
        return LockDetails.builder()
            .lockKey(lockKey)
            .currentHolder(getCurrentHolder(lockKey))
            .holdingSince(getHoldingStartTime(lockKey))
            .queuedClients(getQueuedClients(lockKey))
            .recentHistory(getRecentHistory(lockKey))
            .build();
    }
    
    private List<ActiveLockInfo> getActiveLocks() {
        return lockManager.getAllActiveLocks().stream()
            .map(lock -> ActiveLockInfo.builder()
                .lockKey(lock.getKey())
                .holder(lock.getHolder())
                .holdingTime(System.currentTimeMillis() - lock.getStartTime())
                .queueSize(lock.getQueueSize())
                .build())
            .collect(Collectors.toList());
    }
}
```

### 8.3 æ˜“ç”¨æ€§è®¾è®¡


#### ğŸ¯ æ³¨è§£å¼ä½¿ç”¨


```java
@Component
public class OrderService {
    
    // ç®€å•çš„é”æ³¨è§£
    @DistributedLock(key = "order:${orderId}", timeout = 30)
    public void processOrder(String orderId) {
        // ä¸šåŠ¡é€»è¾‘è‡ªåŠ¨è¢«é”ä¿æŠ¤
        Order order = orderRepository.findById(orderId);
        order.setStatus(OrderStatus.PROCESSING);
        orderRepository.save(order);
    }
    
    // æ”¯æŒSpELè¡¨è¾¾å¼çš„å¤æ‚key
    @DistributedLock(
        key = "user:${user.id}:action:${action}", 
        timeout = 60,
        fair = true,  // ä½¿ç”¨å…¬å¹³é”
        retries = 3   // é‡è¯•3æ¬¡
    )
    public void userAction(User user, String action) {
        // å¤æ‚çš„ä¸šåŠ¡é€»è¾‘
    }
    
    // è‡ªå®šä¹‰å¤±è´¥å¤„ç†
    @DistributedLock(
        key = "payment:${paymentId}",
        onLockFail = "handleLockFailed"  // æŒ‡å®šå¤±è´¥å¤„ç†æ–¹æ³•
    )
    public PaymentResult processPayment(String paymentId) {
        return paymentProcessor.process(paymentId);
    }
    
    public PaymentResult handleLockFailed(String paymentId) {
        return PaymentResult.busy("ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•");
    }
}
```

#### ğŸ› ï¸ æ³¨è§£å¤„ç†å™¨å®ç°


```java
@Aspect
@Component
public class DistributedLockAspect {
    
    @Around("@annotation(distributedLock)")
    public Object handleDistributedLock(ProceedingJoinPoint joinPoint, 
                                       DistributedLock distributedLock) throws Throwable {
        
        String lockKey = parseLockKey(distributedLock.key(), joinPoint);
        String clientId = getClientId();
        
        LockConfiguration config = LockConfiguration.builder()
            .key(lockKey)
            .timeout(distributedLock.timeout())
            .fair(distributedLock.fair())
            .retries(distributedLock.retries())
            .build();
        
        LockManager lockManager = getLockManager(distributedLock.type());
        
        try {
            if (lockManager.tryLock(config, clientId)) {
                // è®°å½•ç›‘æ§æŒ‡æ ‡
                lockMetrics.recordLockAcquisition(lockKey, true, 0);
                
                long startTime = System.currentTimeMillis();
                try {
                    return joinPoint.proceed();
                } finally {
                    long holdTime = System.currentTimeMillis() - startTime;
                    lockMetrics.recordLockHolding(lockKey, holdTime);
                }
            } else {
                // è·å–é”å¤±è´¥
                lockMetrics.recordLockAcquisition(lockKey, false, 0);
                return handleLockFailure(distributedLock, joinPoint);
            }
        } finally {
            lockManager.unlock(lockKey, clientId);
        }
    }
    
    private Object handleLockFailure(DistributedLock annotation, 
                                   ProceedingJoinPoint joinPoint) throws Throwable {
        String failureHandler = annotation.onLockFail();
        
        if (!failureHandler.isEmpty()) {
            // è°ƒç”¨è‡ªå®šä¹‰å¤±è´¥å¤„ç†æ–¹æ³•
            Method method = findFailureHandlerMethod(joinPoint.getTarget().getClass(), failureHandler);
            return method.invoke(joinPoint.getTarget(), joinPoint.getArgs());
        } else {
            // é»˜è®¤æŠ›å‡ºå¼‚å¸¸
            throw new LockAcquisitionException("æ— æ³•è·å–åˆ†å¸ƒå¼é”: " + 
                parseLockKey(annotation.key(), joinPoint));
        }
    }
}
```

### 8.4 å¼€å‘è°ƒè¯•æ”¯æŒ


#### ğŸ” è°ƒè¯•ä¿¡æ¯æ”¶é›†


```java
public class LockDebugger {
    
    public LockDiagnostic diagnoseLock(String lockKey) {
        LockDiagnostic diagnostic = new LockDiagnostic();
        
        // åŸºæœ¬ä¿¡æ¯
        diagnostic.setLockKey(lockKey);
        diagnostic.setCurrentHolder(getCurrentHolder(lockKey));
        diagnostic.setLockExists(lockExists(lockKey));
        
        // æ—¶é—´ä¿¡æ¯
        diagnostic.setHoldingSince(getHoldingStartTime(lockKey));
        diagnostic.setExpireTime(getExpireTime(lockKey));
        diagnostic.setRemainingTtl(getRemainingTtl(lockKey));
        
        // é˜Ÿåˆ—ä¿¡æ¯
        diagnostic.setQueuedClients(getQueuedClients(lockKey));
        diagnostic.setEstimatedWaitTime(calculateEstimatedWaitTime(lockKey));
        
        // å†å²ä¿¡æ¯
        diagnostic.setRecentHistory(getRecentLockHistory(lockKey, 10));
        
        // å¥åº·æ£€æŸ¥
        diagnostic.setHealthIssues(checkLockHealth(lockKey));
        
        return diagnostic;
    }
    
    public List<String> checkLockHealth(String lockKey) {
        List<String> issues = new ArrayList<>();
        
        long holdingTime = getHoldingTime(lockKey);
        if (holdingTime > 300000) {  // è¶…è¿‡5åˆ†é’Ÿ
            issues.add("é”æŒæœ‰æ—¶é—´è¿‡é•¿: " + (holdingTime / 1000) + "ç§’");
        }
        
        int queueSize = getQueueSize(lockKey);
        if (queueSize > 100) {
            issues.add("ç­‰å¾…é˜Ÿåˆ—è¿‡é•¿: " + queueSize + "ä¸ªå®¢æˆ·ç«¯");
        }
        
        String holder = getCurrentHolder(lockKey);
        if (holder != null && !isClientAlive(holder)) {
            issues.add("æŒæœ‰é”çš„å®¢æˆ·ç«¯å¯èƒ½å·²ä¸‹çº¿: " + holder);
        }
        
        return issues;
    }
}
```

#### ğŸ® ç®¡ç†å‘½ä»¤æ¥å£


```java
@RestController
@RequestMapping("/lock/admin")
public class LockAdminController {
    
    // å¼ºåˆ¶é‡Šæ”¾é”ï¼ˆç´§æ€¥æƒ…å†µä½¿ç”¨ï¼‰
    @PostMapping("/locks/{lockKey}/force-release")
    public ResponseEntity<String> forceReleaseLock(@PathVariable String lockKey,
                                                 @RequestParam String reason) {
        log.warn("ç®¡ç†å‘˜å¼ºåˆ¶é‡Šæ”¾é”: {} (åŸå› : {})", lockKey, reason);
        
        String previousHolder = lockManager.getCurrentHolder(lockKey);
        boolean released = lockManager.forceRelease(lockKey);
        
        if (released) {
            // è®°å½•æ“ä½œæ—¥å¿—
            auditLogger.logForcedRelease(lockKey, previousHolder, reason);
            return ResponseEntity.ok("é”é‡Šæ”¾æˆåŠŸ");
        } else {
            return ResponseEntity.badRequest().body("é”é‡Šæ”¾å¤±è´¥");
        }
    }
    
    // æŸ¥çœ‹é”çš„ç­‰å¾…é˜Ÿåˆ—
    @GetMapping("/locks/{lockKey}/queue")
    public List<QueuedClient> getLockQueue(@PathVariable String lockKey) {
        return lockManager.getQueuedClients(lockKey);
    }
    
    // è®¾ç½®é”çš„æœ€å¤§ç­‰å¾…æ—¶é—´
    @PutMapping("/locks/{lockKey}/max-wait-time")
    public ResponseEntity<String> setMaxWaitTime(@PathVariable String lockKey,
                                               @RequestParam int seconds) {
        lockManager.setMaxWaitTime(lockKey, seconds);
        return ResponseEntity.ok("è®¾ç½®æˆåŠŸ");
    }
}
```

---

## 9. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“


### 9.1 è®¾è®¡åŸåˆ™ç²¾å


> ğŸ§  **è®°å¿†å£è¯€**  
> äº’æ–¥å¯é‡å…¥ï¼Œå®¹é”™èƒ½ç»­æœŸ  
> å…¬å¹³æŠ—å‹åŠ›ï¼Œä¸€è‡´å¯è§‚æµ‹  
> æ˜“ç”¨åˆå®‰å…¨ï¼Œç›‘æ§å…¨è¦†ç›–

**ğŸ¯ ä¹å¤§è®¾è®¡åŸåˆ™æ€»ç»“**ï¼š

| åŸåˆ™ | **æ ¸å¿ƒè¦æ±‚** | **å®ç°å…³é”®** | **å¸¸è§é™·é˜±** |
|------|------------|------------|------------|
| ğŸ”’ **äº’æ–¥æ€§** | `åŒæ—¶åªæœ‰ä¸€ä¸ªæŒæœ‰è€…` | `åŸå­æ€§æ“ä½œ` | `ç«æ€æ¡ä»¶` |
| ğŸ”„ **å¯é‡å…¥æ€§** | `åŒä¸€å®¢æˆ·ç«¯å¯é‡å¤è·å–` | `è®¡æ•°å™¨æœºåˆ¶` | `æ­»é”é£é™©` |
| ğŸ› ï¸ **å®¹é”™æ€§** | `æœåŠ¡æ•…éšœæ—¶ä¼˜é›…å¤„ç†` | `è¶…æ—¶+é‡è¯•` | `æ— é™ç­‰å¾…` |
| â±ï¸ **è¶…æ—¶é‡Šæ”¾** | `é˜²æ­¢æ­»é”` | `TTL+ç»­æœŸ` | `è¯¯é‡Šæ”¾` |
| âš–ï¸ **å…¬å¹³æ€§** | `é¿å…é¥¥é¥¿ç°è±¡` | `é˜Ÿåˆ—æœºåˆ¶` | `æ€§èƒ½ä¸‹é™` |
| ğŸ”— **ä¸€è‡´æ€§** | `æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€åŒæ­¥` | `å¤šæ•°æ´¾å…±è¯†` | `è„‘è£‚é—®é¢˜` |
| ğŸ“Š **å¯è§‚æµ‹æ€§** | `çŠ¶æ€é€æ˜å¯ç›‘æ§` | `æŒ‡æ ‡æ”¶é›†` | `ç›‘æ§ç›²ç‚¹` |
| ğŸ¯ **æ˜“ç”¨æ€§** | `å¼€å‘ä½¿ç”¨ç®€å•` | `æ³¨è§£+å·¥å…·` | `è¿‡åº¦å°è£…` |
| âš¡ **æ€§èƒ½** | `é«˜å¹¶å‘ä½å»¶è¿Ÿ` | `ç®—æ³•ä¼˜åŒ–` | `åŠŸèƒ½ç‰ºç‰²` |

### 9.2 æŠ€æœ¯é€‰å‹æŒ‡å—


**ğŸ” é€‰æ‹©å†³ç­–æ ‘**ï¼š

```
ä¸šåŠ¡åœºæ™¯åˆ†æ
    â†“
é«˜å¹¶å‘åœºæ™¯ï¼Ÿ
â”œâ”€â”€ æ˜¯ â†’ ä¼˜å…ˆè€ƒè™‘æ€§èƒ½
â”‚   â”œâ”€â”€ Rediså•æœº â†’ æ€§èƒ½æœ€ä½³
â”‚   â””â”€â”€ Redisé›†ç¾¤ â†’ é«˜å¯ç”¨+æ€§èƒ½
â””â”€â”€ å¦ â†’ ä¼˜å…ˆè€ƒè™‘ä¸€è‡´æ€§
    â”œâ”€â”€ æ•°æ®åº“é” â†’ å¼ºä¸€è‡´æ€§
    â””â”€â”€ Zookeeper â†’ CPä¿è¯

ç‰¹æ®Šéœ€æ±‚åˆ†æ
    â†“
éœ€è¦å…¬å¹³æ€§ï¼Ÿ â†’ é˜Ÿåˆ—å®ç° + æ€§èƒ½æƒè¡¡
éœ€è¦å¯é‡å…¥ï¼Ÿ â†’ è®¡æ•°å™¨ + çº¿ç¨‹æ£€æŸ¥
éœ€è¦é•¿æ—¶é—´æŒæœ‰ï¼Ÿ â†’ è‡ªåŠ¨ç»­æœŸæœºåˆ¶
éœ€è¦è·¨æ•°æ®ä¸­å¿ƒï¼Ÿ â†’ ä¸€è‡´æ€§ç®—æ³•
```

### 9.3 æœ€ä½³å®è·µå»ºè®®


**âœ… æ¨èåšæ³•**ï¼š

```java
// 1. ä½¿ç”¨åˆç†çš„é”ç²’åº¦
âŒ é”™è¯¯ï¼šlockManager.lock("global_lock");
âœ… æ­£ç¡®ï¼šlockManager.lock("order:" + orderId);

// 2. è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
âŒ é”™è¯¯ï¼šlockManager.lock(key, Integer.MAX_VALUE);
âœ… æ­£ç¡®ï¼šlockManager.lock(key, 30, TimeUnit.SECONDS);

// 3. æ€»æ˜¯åœ¨finallyä¸­é‡Šæ”¾é”
âŒ é”™è¯¯ï¼š
lock();
doSomething();
unlock();

âœ… æ­£ç¡®ï¼š
try {
    lock();
    doSomething();
} finally {
    unlock();
}

// 4. ä½¿ç”¨å”¯ä¸€çš„å®¢æˆ·ç«¯æ ‡è¯†
âŒ é”™è¯¯ï¼šlockManager.lock(key, "client");
âœ… æ­£ç¡®ï¼šlockManager.lock(key, "server1:thread-" + Thread.currentThread().getId());

// 5. é¿å…åœ¨é”å†…æ‰§è¡Œè€—æ—¶æ“ä½œ
âŒ é”™è¯¯ï¼š
lock();
Thread.sleep(60000);  // é•¿æ—¶é—´é˜»å¡
unlock();

âœ… æ­£ç¡®ï¼š
lock();
quickOperation();     // å¿«é€Ÿæ“ä½œ
unlock();
```

**âš ï¸ å¸¸è§é™·é˜±æé†’**ï¼š

```java
é™·é˜±1ï¼šé”ç²’åº¦è¿‡ç²—
é—®é¢˜ï¼šæ‰€æœ‰è®¢å•éƒ½ç”¨åŒä¸€æŠŠé” â†’ ä¸²è¡Œæ‰§è¡Œï¼Œæ€§èƒ½æå·®
è§£å†³ï¼šæŒ‰è®¢å•IDæˆ–ç”¨æˆ·IDåˆ†é”

é™·é˜±2ï¼šå¿˜è®°å¤„ç†é”è·å–å¤±è´¥
é—®é¢˜ï¼štryLock()è¿”å›falseåç»§ç»­æ‰§è¡Œ â†’ å¹¶å‘å®‰å…¨é—®é¢˜
è§£å†³ï¼šå¿…é¡»æ£€æŸ¥è¿”å›å€¼å¹¶æ­£ç¡®å¤„ç†

é™·é˜±3ï¼šé”ç»­æœŸå¤±è´¥æœªå¤„ç†
é—®é¢˜ï¼šç»­æœŸå¤±è´¥ä½†ä¸šåŠ¡ç»§ç»­æ‰§è¡Œ â†’ æ•°æ®ä¸ä¸€è‡´
è§£å†³ï¼šç»­æœŸå¤±è´¥ç«‹å³åœæ­¢ä¸šåŠ¡é€»è¾‘

é™·é˜±4ï¼šæµ‹è¯•ç¯å¢ƒä¸ç”Ÿäº§ç¯å¢ƒä¸ä¸€è‡´
é—®é¢˜ï¼šæµ‹è¯•ç”¨å•æœºï¼Œç”Ÿäº§ç”¨é›†ç¾¤ â†’ ä¸Šçº¿åå‡ºç°é—®é¢˜
è§£å†³ï¼šæµ‹è¯•ç¯å¢ƒå°½é‡æ¨¡æ‹Ÿç”Ÿäº§ç¯å¢ƒ
```

### 9.4 æ€§èƒ½è°ƒä¼˜å»ºè®®


**âš¡ ä¼˜åŒ–ç­–ç•¥**ï¼š

| ä¼˜åŒ–ç»´åº¦ | **å…·ä½“æ–¹æ³•** | **é¢„æœŸæ•ˆæœ** | **æ³¨æ„äº‹é¡¹** |
|---------|------------|------------|------------|
| ğŸš€ **ç½‘ç»œä¼˜åŒ–** | `è¿æ¥æ± +æ‰¹é‡æ“ä½œ` | `å‡å°‘50%ç½‘ç»œå¼€é”€` | `æ³¨æ„è¿æ¥æ•°é™åˆ¶` |
| ğŸ’¾ **å­˜å‚¨ä¼˜åŒ–** | `Luaè„šæœ¬åˆå¹¶æ“ä½œ` | `åŸå­æ€§+æ€§èƒ½æå‡` | `è„šæœ¬å¤æ‚åº¦æ§åˆ¶` |
| ğŸ”„ **ç®—æ³•ä¼˜åŒ–** | `æ™ºèƒ½é€€é¿ç­–ç•¥` | `å‡å°‘æ— æ•ˆé‡è¯•` | `å¹³è¡¡ç­‰å¾…æ—¶é—´` |
| ğŸ“Š **ç›‘æ§ä¼˜åŒ–** | `å¼‚æ­¥æŒ‡æ ‡æ”¶é›†` | `é™ä½ä¸šåŠ¡å½±å“` | `æ•°æ®å‡†ç¡®æ€§` |

### 9.5 æ•…éšœæ’æŸ¥æ‰‹å†Œ


**ğŸ” é—®é¢˜æ’æŸ¥æµç¨‹**ï¼š

```
æ­¥éª¤1ï¼šç°è±¡ç¡®è®¤
â”œâ”€â”€ è·å–é”å¤±è´¥ï¼Ÿ â†’ æ£€æŸ¥é”çŠ¶æ€å’Œé˜Ÿåˆ—
â”œâ”€â”€ æ€§èƒ½ä¸‹é™ï¼Ÿ   â†’ åˆ†æç›‘æ§æŒ‡æ ‡  
â”œâ”€â”€ æ•°æ®ä¸ä¸€è‡´ï¼Ÿ â†’ æ£€æŸ¥é”çš„ä¸€è‡´æ€§
â””â”€â”€ æœåŠ¡å¼‚å¸¸ï¼Ÿ   â†’ æŸ¥çœ‹é”™è¯¯æ—¥å¿—

æ­¥éª¤2ï¼šæ ¹å› å®šä½
â”œâ”€â”€ ç½‘ç»œé—®é¢˜ â†’ pingæµ‹è¯•ã€è¿æ¥æ£€æŸ¥
â”œâ”€â”€ å­˜å‚¨é—®é¢˜ â†’ RedisçŠ¶æ€ã€å†…å­˜ä½¿ç”¨
â”œâ”€â”€ é€»è¾‘é—®é¢˜ â†’ ä»£ç å®¡æŸ¥ã€æ—¶åºåˆ†æ
â””â”€â”€ é…ç½®é—®é¢˜ â†’ å‚æ•°æ£€æŸ¥ã€ç¯å¢ƒå¯¹æ¯”

æ­¥éª¤3ï¼šè§£å†³æ–¹æ¡ˆ
â”œâ”€â”€ ç´§æ€¥å¤„ç† â†’ å¼ºåˆ¶é‡Šæ”¾ã€æœåŠ¡é‡å¯
â”œâ”€â”€ ä¸´æ—¶æ–¹æ¡ˆ â†’ é™çº§ç­–ç•¥ã€å¤‡ç”¨æ–¹æ¡ˆ
â””â”€â”€ æ ¹æœ¬è§£å†³ â†’ ä»£ç ä¿®å¤ã€æ¶æ„è°ƒæ•´
```

### 9.6 æœªæ¥å‘å±•è¶‹åŠ¿


**ğŸ”® æŠ€æœ¯æ¼”è¿›æ–¹å‘**ï¼š

- **ğŸ¤– AIæ™ºèƒ½åŒ–**ï¼šæœºå™¨å­¦ä¹ ä¼˜åŒ–é”å‚æ•°å’Œç­–ç•¥
- **â˜ï¸ äº‘åŸç”ŸåŒ–**ï¼šKubernetesç¯å¢ƒä¸‹çš„é”æœåŠ¡
- **ğŸŒ è¾¹ç¼˜è®¡ç®—**ï¼šå¤šåœ°åŸŸåˆ†å¸ƒå¼é”åè°ƒ
- **âš¡ ç¡¬ä»¶åŠ é€Ÿ**ï¼šFPGAã€GPUåŠ é€Ÿé”ç®—æ³•
- **ğŸ“± ç§»åŠ¨ä¼˜åŒ–**ï¼šç§»åŠ¨ç«¯åˆ†å¸ƒå¼é”è§£å†³æ–¹æ¡ˆ

**ğŸ’¡ å­¦ä¹ å»ºè®®**ï¼š

```
åŸºç¡€é˜¶æ®µï¼š
âœ… ç†è§£åˆ†å¸ƒå¼ç³»ç»ŸåŸºæœ¬æ¦‚å¿µ
âœ… æŒæ¡RedisåŸºæœ¬æ“ä½œå’ŒLuaè„šæœ¬
âœ… ç†Ÿæ‚‰Javaå¹¶å‘ç¼–ç¨‹

è¿›é˜¶é˜¶æ®µï¼š
âœ… æ·±å…¥å­¦ä¹ ä¸€è‡´æ€§ç®—æ³•ï¼ˆRaftã€Paxosï¼‰
âœ… å®è·µä¸åŒåœºæ™¯çš„é”å®ç°
âœ… æŒæ¡æ€§èƒ½è°ƒä¼˜æŠ€å·§

é«˜çº§é˜¶æ®µï¼š
âœ… è®¾è®¡å¤§è§„æ¨¡åˆ†å¸ƒå¼é”ç³»ç»Ÿ
âœ… ç ”ç©¶æ–°å…´æŠ€æœ¯åœ¨é”ä¸­çš„åº”ç”¨
âœ… å‚ä¸å¼€æºé¡¹ç›®è´¡çŒ®ä»£ç 
```

**ğŸ¯ æ ¸å¿ƒè®°ä½è¦ç‚¹**ï¼š

> **åˆ†å¸ƒå¼é”çš„æœ¬è´¨**æ˜¯åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹ä¿è¯èµ„æºè®¿é—®çš„**äº’æ–¥æ€§**å’Œ**ä¸€è‡´æ€§**
>
> **è®¾è®¡åŸåˆ™**è¦åœ¨**æ€§èƒ½**ã€**ä¸€è‡´æ€§**ã€**å¯ç”¨æ€§**ä¹‹é—´æ‰¾åˆ°å¹³è¡¡
>
> **å®ç°æ–¹æ¡ˆ**æ²¡æœ‰é“¶å¼¹ï¼Œè¦æ ¹æ®å…·ä½“ä¸šåŠ¡åœºæ™¯é€‰æ‹©åˆé€‚çš„æŠ€æœ¯
>
> **ç›‘æ§è¿ç»´**æ˜¯ä¿éšœåˆ†å¸ƒå¼é”ç¨³å®šè¿è¡Œçš„é‡è¦åŸºç¡€
>
> **æŒç»­å­¦ä¹ **æ–°æŠ€æœ¯ï¼Œä½†è¦ç†è§£å…¶èƒŒåçš„åŸç†å’Œé€‚ç”¨åœºæ™¯

---

**ğŸ”š æ€»ç»“**

åˆ†å¸ƒå¼é”ä½œä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„é‡è¦ç»„ä»¶ï¼Œå…¶è®¾è®¡éœ€è¦ç»¼åˆè€ƒè™‘å¤šä¸ªç»´åº¦ã€‚é€šè¿‡ç†è§£è¿™ä¹å¤§è®¾è®¡åŸåˆ™ï¼Œå¼€å‘è€…å¯ä»¥è®¾è®¡å‡ºæ—¢é«˜æ•ˆåˆå¯é çš„åˆ†å¸ƒå¼é”ç³»ç»Ÿã€‚è®°ä½ï¼š**æ²¡æœ‰å®Œç¾çš„æ–¹æ¡ˆï¼Œåªæœ‰æœ€é€‚åˆçš„é€‰æ‹©**ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¦æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹ã€æ€§èƒ½è¦æ±‚ã€ä¸€è‡´æ€§éœ€æ±‚ç­‰å› ç´ ï¼Œé€‰æ‹©å’Œå®šåˆ¶æœ€åˆé€‚çš„åˆ†å¸ƒå¼é”å®ç°æ–¹æ¡ˆã€‚