---
title: 1、缓存读写模式详解
---
## 📚 目录

1. [缓存读写模式概述](#1-缓存读写模式概述)
2. [Cache-Aside旁路缓存模式](#2-cache-aside旁路缓存模式)
3. [Read-Through直读模式](#3-read-through直读模式)
4. [Write-Through直写模式](#4-write-through直写模式)
5. [Write-Behind回写模式](#5-write-behind回写模式)
6. [双写一致性问题与解决方案](#6-双写一致性问题与解决方案)
7. [延迟双删策略](#7-延迟双删策略)
8. [异步更新机制](#8-异步更新机制)
9. [模式选择原则](#9-模式选择原则)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 缓存读写模式概述


### 1.1 什么是缓存读写模式


**通俗理解**：就像我们在家里放个小冰箱存常用食物，不用每次都跑超市一样，缓存读写模式就是决定这个"小冰箱"怎么和"大超市"（数据库）配合工作的规则。

```
生活中的例子：
家里小冰箱 = 缓存（Redis）
大型超市   = 数据库（MySQL）
你        = 应用程序

不同的"购物策略" = 不同的缓存模式
```

**核心目的**：
- 🚀 **提升速度**：从缓存读数据比数据库快很多
- 💰 **降低成本**：减少数据库访问，节省资源
- ⚡ **提高并发**：缓存能承受更高的并发访问

### 1.2 四大经典模式对比


```
┌─────────────────┬──────────────┬──────────────┬──────────────┐
│   读写模式      │   读操作     │   写操作     │   适用场景   │
├─────────────────┼──────────────┼──────────────┼──────────────┤
│ Cache-Aside     │ 应用负责     │ 应用负责     │ 最常用模式   │
│ (旁路缓存)      │              │              │              │
├─────────────────┼──────────────┼──────────────┼──────────────┤
│ Read-Through    │ 缓存负责     │ 应用负责     │ 读多写少     │
│ (直读模式)      │              │              │              │
├─────────────────┼──────────────┼──────────────┼──────────────┤
│ Write-Through   │ 缓存负责     │ 缓存负责     │ 数据一致性高 │
│ (直写模式)      │              │              │              │
├─────────────────┼──────────────┼──────────────┼──────────────┤
│ Write-Behind    │ 缓存负责     │ 缓存负责     │ 写多读少     │
│ (回写模式)      │              │              │              │
└─────────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 2. 🛒 Cache-Aside旁路缓存模式


### 2.1 模式原理解析


**通俗比喻**：这就像你自己管理家里的小冰箱，什么时候去超市买，什么时候从冰箱拿，都是你自己决定。

```
应用程序的工作流程：
         应用程序
           |
    ┌──────┴──────┐
    │             │
    ▼             ▼
  缓存           数据库
 (Redis)       (MySQL)

"我来决定什么时候用缓存，什么时候用数据库"
```

### 2.2 读操作流程


**步骤详解**：
1. **先查缓存**：应用先去Redis找数据
2. **缓存命中**：找到了直接返回，速度飞快
3. **缓存未命中**：没找到就去MySQL查
4. **回填缓存**：从数据库查到后，放到Redis里备用

```java
// 实际的Java代码示例
public User getUserById(Long userId) {
    // 步骤1: 先查Redis缓存
    String cacheKey = "user:" + userId;
    User user = redisTemplate.opsForValue().get(cacheKey);
    
    if (user != null) {
        // 步骤2: 缓存命中，直接返回
        return user;
    }
    
    // 步骤3: 缓存未命中，查数据库
    user = userMapper.selectById(userId);
    
    if (user != null) {
        // 步骤4: 回填缓存，设置30分钟过期
        redisTemplate.opsForValue().set(cacheKey, user, 30, TimeUnit.MINUTES);
    }
    
    return user;
}
```

### 2.3 写操作流程


**更新数据的两步走**：
1. **先更新数据库**：确保数据安全地保存到MySQL
2. **后删除缓存**：让Redis中的旧数据失效

> 💡 **为什么删除而不是更新缓存？**  
> 就像冰箱里的牛奶过期了，与其换新的，不如直接扔掉，下次需要时再买新鲜的。这样避免了多余的工作。

```java
public void updateUser(User user) {
    // 步骤1: 先更新数据库
    userMapper.updateById(user);
    
    // 步骤2: 删除缓存
    String cacheKey = "user:" + user.getId();
    redisTemplate.delete(cacheKey);
}
```

### 2.4 Cache-Aside的优缺点


**✅ 优点**：
- **简单易懂**：逻辑清晰，新人容易理解
- **灵活控制**：应用可以精确控制缓存策略
- **容错性好**：缓存挂了，应用依然能工作

**❌ 缺点**：
- **代码复杂**：每个地方都要写缓存逻辑
- **一致性问题**：更新数据库和删缓存之间可能出现不一致

---

## 3. 📖 Read-Through直读模式


### 3.1 模式原理解析


**通俗比喻**：这就像你有个贴心的管家，你说要什么，管家帮你去冰箱找，没有的话管家去超市买回来给你。

```
Read-Through工作流程：
    应用程序 ──── "我要用户数据" ────→ 缓存系统
                                      |
                            ┌─────────┴─────────┐
                            │  缓存管理器负责   │
                            │  - 先查缓存       │
                            │  - 没有就查DB     │
                            │  - 自动更新缓存   │
                            └───────────────────┘
```

### 2.2 实现原理


**关键特点**：
- **透明操作**：应用不需要知道数据来自缓存还是数据库
- **自动管理**：缓存系统负责数据的加载和更新
- **统一接口**：应用只需要调用一个接口

```java
// Spring Cache注解实现Read-Through
@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#userId")
    public User getUserById(Long userId) {
        // 这里的逻辑只有在缓存miss时才执行
        // Spring自动管理缓存的读取和存储
        return userMapper.selectById(userId);
    }
}
```

### 3.3 与Cache-Aside的区别


**主要差异**：

| 对比维度 | **Cache-Aside** | **Read-Through** |
|---------|----------------|------------------|
| 💻 **代码复杂度** | `手动编写缓存逻辑` | `框架自动处理` |
| 🎯 **职责分工** | `应用管理缓存` | `缓存系统管理` |
| 🔧 **灵活性** | `高度可控` | `配置化管理` |
| 📚 **学习成本** | `需要理解缓存原理` | `学会使用注解即可` |

---

## 4. ✏️ Write-Through直写模式


### 4.1 模式原理解析


**通俗比喻**：这就像有个特别负责的管家，每次你要存东西，管家都会同时放到冰箱和记录到账本上，确保两边数据完全一致。

```
Write-Through工作机制：
    应用 ──── "更新用户信息" ────→ 缓存系统
                                    |
                        ┌───────────┴───────────┐
                        │   缓存系统同时操作    │
                        │   ↓                   │
                        │   更新缓存 & 更新DB   │
                        │   (两个操作都成功)     │
                        └───────────────────────┘
```

### 4.2 核心特点


**关键特性**：
- **同步写入**：缓存和数据库同时更新
- **强一致性**：保证缓存和数据库数据完全一致
- **写操作较慢**：因为要等两个操作都完成

```java
// Write-Through模式示例
@CachePut(value = "users", key = "#user.id")
public User updateUser(User user) {
    // 先更新数据库
    userMapper.updateById(user);
    // Spring自动更新缓存
    return user;  // 返回值会被存入缓存
}
```

### 4.3 适用场景


**最适合的情况**：
- 🎯 **数据一致性要求高**：比如金融系统的账户余额
- 📊 **读写比例均衡**：不是纯粹的读多写少
- ⚡ **可以接受写性能下降**：为了一致性牺牲一些写速度

---

## 5. ⏰ Write-Behind回写模式


### 5.1 模式原理解析


**通俗比喻**：这就像你有个懒一点但很聪明的管家，你要存东西时，管家先放到冰箱，然后说"我等会儿再去超市更新账本"，让你不用等待。

```
Write-Behind异步流程：
    应用 ──── "更新数据" ────→ 缓存
                              |
                              ▼
                        ┌─────────────┐
                        │  立即返回   │ ← 用户不用等待
                        └─────────────┘
                              |
                        ┌─────▼─────┐
                        │  后台任务  │
                        │  异步写DB  │
                        └───────────┘
```

### 5.2 实现机制


**工作原理**：
- **先写缓存**：数据立即写入Redis，应用得到快速响应
- **异步写库**：后台任务定时或按条件将缓存数据写入数据库
- **批量优化**：可以将多个写操作合并，提高数据库效率

```java
// Write-Behind模式的简化实现思路
@Service
public class WriteBehinchService {
    
    private final Queue<WriteTask> writeQueue = new LinkedBlockingQueue<>();
    
    public void updateUser(User user) {
        // 1. 立即更新缓存
        String cacheKey = "user:" + user.getId();
        redisTemplate.opsForValue().set(cacheKey, user);
        
        // 2. 加入写队列（异步处理）
        writeQueue.offer(new WriteTask(user));
        
        // 3. 立即返回，不等待数据库写入
    }
    
    // 后台任务定时处理写队列
    @Scheduled(fixedDelay = 1000)
    public void flushToDatabase() {
        WriteTask task;
        while ((task = writeQueue.poll()) != null) {
            userMapper.updateById(task.getUser());
        }
    }
}
```

### 5.3 优缺点分析


**✅ 优点**：
- **写性能极高**：用户感受到的写操作非常快
- **批量优化**：可以合并多个数据库操作
- **减少数据库压力**：异步写入，平滑数据库负载

**❌ 缺点**：
- **数据丢失风险**：缓存挂掉可能丢失未写入数据库的数据
- **实现复杂**：需要处理异步任务、失败重试等
- **最终一致性**：数据库和缓存可能暂时不一致

---

## 6. ⚠️ 双写一致性问题与解决方案


### 6.1 什么是双写一致性问题


**通俗解释**：就像你要同时更新家里的冰箱和超市的库存记录，如果操作过程中出了岔子，两边的数据就不一样了。

```
双写一致性问题场景：

时刻1: 缓存中用户年龄=25，数据库中用户年龄=25 ✅一致
时刻2: 更新用户年龄为26
       - 数据库更新成功：年龄=26
       - 缓存删除失败：年龄=25（旧数据）
时刻3: 缓存中用户年龄=25，数据库中用户年龄=26 ❌不一致
```

### 6.2 常见的一致性问题场景


**场景一：删除缓存失败**
```
┌─ 线程A: 更新用户信息 ─┐
│  1. 更新数据库 ✅      │
│  2. 删除缓存 ❌       │ ← Redis挂了
└────────────────────────┘
结果：数据库是新数据，缓存是旧数据
```

**场景二：并发读写问题**
```
时间线：
T1: 线程A开始更新数据
T2: 线程A删除缓存
T3: 线程B读取，缓存miss，从DB读到旧数据
T4: 线程B将旧数据写入缓存
T5: 线程A更新数据库完成

结果：数据库是新数据，缓存被写入了旧数据
```

### 6.3 解决方案对比


| 方案类型 | **实现难度** | **一致性保证** | **性能影响** | **推荐场景** |
|---------|-------------|---------------|-------------|-------------|
| 🔄 **重试机制** | `简单` | `最终一致` | `很小` | `一般业务` |
| ⏰ **延迟双删** | `中等` | `较强一致` | `小` | `读多写少` |
| 📨 **消息队列** | `复杂` | `最终一致` | `中等` | `高并发场景` |
| 🔄 **Canal同步** | `复杂` | `强一致` | `小` | `企业级应用` |

---

## 7. 🔄 延迟双删策略


### 7.1 策略原理


**通俗解释**：就像打扫房间，第一遍可能没扫干净，所以过一会儿再扫一遍，确保真的干净了。

```
延迟双删执行流程：
  更新操作开始
       |
   删除缓存 (第一次删除)
       |
   更新数据库
       |
   等待一段时间 (比如500ms)
       |
   再次删除缓存 (第二次删除)
       |
   操作完成
```

### 7.2 核心思想


**为什么要等待一段时间？**

假设有个并发读取刚好在第一次删除缓存后进来：
1. **第一次删除缓存**：清空了旧数据
2. **并发读取**：发现缓存没有，去数据库读（这时可能读到旧数据）
3. **并发读取写缓存**：将旧数据写入缓存
4. **等待时间过后**：第二次删除，清掉这个"误入"的旧数据

### 7.3 实现代码


```java
@Service
public class DelayedDoubleDeleteService {
    
    @Async
    public void updateUserWithDelayedDelete(User user) {
        String cacheKey = "user:" + user.getId();
        
        try {
            // 第一次删除缓存
            redisTemplate.delete(cacheKey);
            
            // 更新数据库
            userMapper.updateById(user);
            
            // 延迟执行第二次删除
            CompletableFuture.runAsync(() -> {
                try {
                    // 等待500ms，让可能的并发读取完成
                    Thread.sleep(500);
                    // 第二次删除缓存
                    redisTemplate.delete(cacheKey);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
            
        } catch (Exception e) {
            // 异常处理和日志记录
            log.error("延迟双删失败", e);
        }
    }
}
```

### 7.4 延迟时间如何确定


**时间设置原则**：

> 🎯 **延迟时间 = 读操作的平均耗时 + 写缓存的耗时 + 一点buffer**

```
计算示例：
- 数据库查询平均耗时：100ms
- Redis写入平均耗时：10ms  
- 安全buffer：100ms
- 推荐延迟时间：210ms → 取整为300ms
```

---

## 8. 🔄 异步更新机制


### 8.1 基于消息队列的异步更新


**核心思想**：把缓存更新的任务发送给消息队列，让专门的消费者来处理，这样主业务不会被阻塞。

```
异步更新架构图：
    应用服务
        |
    更新数据库
        |
    发送MQ消息 ──→ RabbitMQ ──→ 缓存更新服务
        |                          |
    立即返回                   异步删除缓存
```

### 8.2 实现示例


```java
// 生产者：发送缓存更新消息
@Service
public class UserService {
    
    public void updateUser(User user) {
        // 1. 更新数据库
        userMapper.updateById(user);
        
        // 2. 发送异步删除缓存消息
        CacheDeleteMessage message = new CacheDeleteMessage();
        message.setCacheKey("user:" + user.getId());
        message.setRetryCount(0);
        
        rabbitTemplate.convertAndSend("cache.delete.exchange", 
                                    "cache.delete.key", 
                                    message);
    }
}

// 消费者：处理缓存删除
@RabbitListener(queues = "cache.delete.queue")
public class CacheDeleteConsumer {
    
    public void handleCacheDelete(CacheDeleteMessage message) {
        try {
            // 删除缓存
            redisTemplate.delete(message.getCacheKey());
            log.info("异步删除缓存成功: {}", message.getCacheKey());
            
        } catch (Exception e) {
            // 失败重试机制
            if (message.getRetryCount() < 3) {
                message.setRetryCount(message.getRetryCount() + 1);
                // 重新发送到队列
                rabbitTemplate.convertAndSend("cache.delete.retry.exchange", 
                                            "cache.delete.retry.key", 
                                            message);
            }
        }
    }
}
```

### 8.3 基于Canal的数据同步


**Canal原理**：监听MySQL的binlog（二进制日志），当数据库发生变化时，自动同步到缓存。

```
Canal同步流程：
    MySQL数据库
        |
    产生binlog日志
        |
    Canal监听 ──→ 解析变更数据 ──→ 发送到MQ ──→ 更新Redis
```

**优势**：
- **业务无感知**：应用代码不需要关心缓存同步
- **实时性好**：几乎实时同步数据变化
- **可靠性高**：基于数据库日志，不会丢失数据

---

## 9. 🎯 模式选择原则


### 9.1 业务场景分析


**如何选择合适的缓存模式？**

```
决策树：
业务是否要求强一致性？
├─ 是 ──→ Write-Through模式
└─ 否 ──→ 读写比例如何？
           ├─ 读多写少 ──→ Cache-Aside + 延迟双删
           ├─ 写多读少 ──→ Write-Behind模式  
           └─ 读写平衡 ──→ Read-Through + 异步更新
```

### 9.2 详细场景推荐


**🛒 电商商品信息**（读多写少）
- **推荐模式**：Cache-Aside + 延迟双删
- **原因**：商品信息读取频繁，更新相对较少，可以容忍短暂的不一致

**💰 用户账户余额**（强一致性要求）
- **推荐模式**：Write-Through
- **原因**：金钱相关数据不能有任何不一致，宁可牺牲性能

**📊 用户行为统计**（写多读少）
- **推荐模式**：Write-Behind
- **原因**：大量的用户行为数据写入，对实时一致性要求不高

**📰 新闻文章内容**（读写平衡）
- **推荐模式**：Read-Through + 异步更新
- **原因**：既有大量读取，也有频繁的内容更新

### 9.3 选择评估维度


| 评估维度 | **Cache-Aside** | **Read-Through** | **Write-Through** | **Write-Behind** |
|---------|----------------|------------------|-------------------|------------------|
| 🏃 **读性能** | `很好` | `很好` | `好` | `很好` |
| ✏️ **写性能** | `好` | `好` | `一般` | `很好` |
| 🎯 **一致性** | `最终一致` | `最终一致` | `强一致` | `最终一致` |
| 🔧 **复杂度** | `中等` | `简单` | `简单` | `复杂` |
| 💰 **运维成本** | `低` | `低` | `低` | `高` |

---

## 10. 📋 核心要点总结


### 10.1 四大模式快速记忆


```
🔸 Cache-Aside（旁路缓存）：
   应用自己管理缓存，最常用，需要写代码逻辑

🔸 Read-Through（直读模式）：
   缓存帮你管理读取，用注解就行，适合读多场景

🔸 Write-Through（直写模式）：  
   缓存帮你管理写入，数据强一致，写性能略差

🔸 Write-Behind（回写模式）：
   写缓存后异步写数据库，写性能好，但实现复杂
```

### 10.2 一致性问题解决方案


**📌 核心策略**：
- **延迟双删**：简单有效，适合大部分场景
- **异步队列**：高并发场景，解耦业务逻辑  
- **Canal同步**：企业级方案，业务无感知
- **重试机制**：保底方案，确保最终一致性

### 10.3 实际应用建议


**🎯 新手建议**：
1. **从Cache-Aside开始**：最容易理解，掌握基本原理
2. **加上延迟双删**：解决常见的一致性问题
3. **逐步优化**：根据业务需要选择更高级的模式

**⚡ 性能优化要点**：
- **设置合理的过期时间**：避免缓存雪崩
- **监控缓存命中率**：低于80%需要优化
- **预热关键数据**：系统启动时提前加载热点数据

**🔧 运维监控指标**：
- 缓存命中率、平均响应时间
- 数据库访问量变化
- 缓存更新失败次数
- 数据一致性检查结果

### 10.4 记忆口诀


> 💭 **旁路自己管，直读缓存帮**  
> **直写强一致，回写性能棒**  
> **双删解问题，异步保性能**  
> **选择看场景，监控不能忘**

**核心理解**：
- 缓存模式的选择没有绝对的对错，只有适不适合
- 一致性和性能往往是需要平衡的两个方面  
- 从简单开始，根据业务发展逐步优化
- 监控和测试比理论更重要，要在实践中验证效果