---
title: 1、Redis数据结构深入
---
## 📚 目录

1. [Redis数据结构概览](#1-Redis数据结构概览)
2. [String字符串类型详解](#2-String字符串类型详解)
3. [Hash哈希结构应用](#3-Hash哈希结构应用)
4. [List列表的灵活运用](#4-List列表的灵活运用)
5. [Set集合的独特特性](#5-Set集合的独特特性)
6. [Zset有序集合进阶](#6-Zset有序集合进阶)
7. [数据类型选择策略](#7-数据类型选择策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🗃️ Redis数据结构概览


### 1.1 什么是Redis数据结构


**通俗理解**：Redis就像一个超级智能的存储柜，不同的柜子用来存放不同类型的东西。

```
传统数据库 vs Redis：

传统数据库：        Redis：
只能存表格           可以存5种"柜子"
  ┌─────┐             ┌─────┐ ┌─────┐ ┌─────┐
  │表格 │             │字符串│ │列表 │ │集合 │
  └─────┘             └─────┘ └─────┘ └─────┘
                      ┌─────┐ ┌─────┐
                      │哈希 │ │排序 │
                      └─────┘ └─────┘
```

### 1.2 Redis五大数据类型速览


| 数据类型 | **通俗比喻** | **适用场景** | **时间复杂度** |
|---------|-------------|-------------|---------------|
| **String** | `记事本` | 缓存、计数器、分布式锁 | O(1) |
| **Hash** | `文件夹` | 用户信息、购物车、配置 | O(1) |
| **List** | `排队队列` | 消息队列、时间轴、栈 | O(1) |
| **Set** | `标签袋` | 去重、关注关系、抽奖 | O(1) |
| **Zset** | `排行榜` | 排行榜、延时队列、范围查询 | O(log N) |

---

## 2. 📝 String字符串类型详解


### 2.1 String的本质理解


**核心概念**：String不仅仅存储文字，还能存储数字、JSON、二进制数据。

> 💡 **新手提示**：虽然叫"字符串"，但Redis的String可以存储任何数据，最大512MB！

**String的三种用法**：
```
1. 存文本：    key: "用户姓名"  → value: "张三"
2. 存数字：    key: "访问次数"  → value: 100
3. 存对象：    key: "用户信息"  → value: "{'name':'张三','age':25}"
```

### 2.2 String核心操作详解


#### 🔧 基础操作


```bash
# 设置和获取 - 最基本的操作
SET username "张三"        # 存储用户名
GET username              # 获取用户名 → "张三"

# 批量操作 - 一次处理多个键值
MSET name "李四" age "25" city "北京"    # 同时设置多个
MGET name age city                      # 同时获取多个
```

#### 📊 数值操作


```bash
# 计数器场景 - 网站访问量统计
SET page_views 0          # 初始化访问量
INCR page_views          # 每次访问+1，返回1
INCR page_views          # 再次+1，返回2
INCRBY page_views 10     # 一次增加10，返回12

# 实际应用：商品库存扣减
SET product_stock 100    # 商品库存100件
DECRBY product_stock 3   # 卖出3件，还剩97件
```

### 2.3 String的应用场景


#### 🎯 场景1：分布式锁


**业务需求**：防止多个服务同时处理同一订单

```bash
# 获取锁
SET order:12345:lock "server-001" NX EX 30
# 解释：对订单12345加锁，锁持有者是server-001，30秒后自动释放

# 业务处理完成后释放锁
DEL order:12345:lock
```

> 🔥 **重点理解**：NX表示"不存在才设置"，EX表示"设置过期时间"

#### 🎯 场景2：用户会话存储


```bash
# 用户登录后存储会话信息
SET session:abc123 "user_id:1001|login_time:2025-01-01" EX 7200
# 会话信息保存2小时

# 验证用户是否登录
GET session:abc123    # 如果返回null说明会话过期
```

#### 🎯 场景3：缓存热点数据


```bash
# 缓存用户基本信息（JSON格式）
SET user:1001 '{"name":"张三","email":"zhangsan@email.com"}' EX 3600

# 应用先查缓存，没有再查数据库
GET user:1001
```

---

## 3. 📂 Hash哈希结构应用


### 3.1 Hash结构的直观理解


**通俗比喻**：Hash就像一个**带标签的文件夹**，里面可以放很多有名字的文件。

```
普通String存储：               Hash存储：
key: user:1001               key: user:1001
value: "张三,25,北京"          ├─ name: "张三"
                             ├─ age: "25"
                             └─ city: "北京"

问题：要改年龄需要重写整个值      优势：只需要改age字段
```

### 3.2 Hash核心操作


#### 🔧 基础字段操作


```bash
# 设置用户信息的各个字段
HSET user:1001 name "张三"
HSET user:1001 age "25"
HSET user:1001 email "zhangsan@email.com"

# 或者一次设置多个字段
HMSET user:1001 name "张三" age "25" email "zhangsan@email.com"

# 获取单个字段
HGET user:1001 name       # 返回 "张三"

# 获取所有字段
HGETALL user:1001         # 返回所有字段和值
```

#### 📈 数值字段操作


```bash
# 用户积分系统
HSET user:1001 points 100        # 设置积分
HINCRBY user:1001 points 50      # 积分增加50，现在是150
HINCRBY user:1001 login_count 1  # 登录次数+1
```

### 3.3 Hash的典型应用


#### 🛒 购物车系统


```bash
# 购物车结构：cart:用户ID
# 字段：商品ID，值：商品数量

# 用户1001的购物车
HSET cart:1001 product:101 2    # 商品101，数量2
HSET cart:1001 product:102 1    # 商品102，数量1

# 修改商品数量
HINCRBY cart:1001 product:101 1  # 商品101数量+1，变成3

# 删除商品
HDEL cart:1001 product:102      # 删除商品102

# 查看整个购物车
HGETALL cart:1001
```

#### ⚙️ 系统配置管理


```bash
# 应用配置
HMSET app:config 
  database_host "192.168.1.100" 
  database_port "3306"
  cache_timeout "3600"
  max_connections "200"

# 动态获取配置
HGET app:config database_host    # 获取数据库地址
```

### 3.4 Hash vs String 选择原则


| 使用场景 | **推荐类型** | **原因** |
|---------|-------------|---------|
| 简单键值对 | String | 操作简单，性能最高 |
| 对象属性多 | Hash | 节省内存，操作灵活 |
| 需要原子操作 | Hash | 单个字段的修改是原子的 |
| 数据结构复杂 | String(JSON) | 支持嵌套结构 |

---

## 4. 📋 List列表的灵活运用


### 4.1 List的核心特性


**通俗理解**：List就像一个**可以从两端进出的队列**，保持插入顺序。

```
List的队列特性：
头部 ←── [元素1] [元素2] [元素3] [元素4] ←── 尾部
     ↑                               ↑
   LPUSH                          RPUSH
   LPOP                           RPOP
```

> 🔥 **关键特点**：
> - 有序：元素按插入顺序排列
> - 可重复：允许相同元素存在多个
> - 双端操作：可以从头部或尾部操作

### 4.2 List基础操作


#### 📥 入队出队操作


```bash
# 从左边（头部）操作
LPUSH notifications "新消息1"     # 从头部插入
LPUSH notifications "新消息2"     # 结果：[新消息2, 新消息1]
LPOP notifications               # 从头部取出"新消息2"

# 从右边（尾部）操作
RPUSH task_queue "任务A"         # 从尾部插入
RPUSH task_queue "任务B"         # 结果：[任务A, 任务B]
RPOP task_queue                  # 从尾部取出"任务B"
```

#### 🔍 查看和范围操作


```bash
# 查看列表内容
LRANGE messages 0 -1    # 查看所有元素（0到-1表示全部）
LRANGE messages 0 4     # 查看前5个元素
LLEN messages           # 查看列表长度

# 按索引获取
LINDEX messages 0       # 获取第一个元素
LINDEX messages -1      # 获取最后一个元素
```

### 4.3 List的实际应用场景


#### 🔔 消息队列系统


```bash
# 生产者发送消息
LPUSH message_queue "订单支付成功:order_123"
LPUSH message_queue "用户注册:user_456"

# 消费者处理消息（FIFO - 先进先出）
RPOP message_queue      # 取出最早的消息处理
```

> 💡 **队列模式选择**：
> - **FIFO队列**：LPUSH + RPOP（先进先出）
> - **栈模式**：LPUSH + LPOP（后进先出）

#### 📱 用户动态时间轴


```bash
# 用户发布动态
LPUSH timeline:user1001 "发布了一条新动态"
LPUSH timeline:user1001 "点赞了朋友的照片"  
LPUSH timeline:user1001 "更新了个人资料"

# 获取最新10条动态
LRANGE timeline:user1001 0 9

# 动态总数
LLEN timeline:user1001
```

#### 🎯 最近访问记录


```bash
# 记录用户最近访问的页面（保持最新5条）
LPUSH recent_pages:user1001 "/product/123"
LPUSH recent_pages:user1001 "/category/electronics"
LTRIM recent_pages:user1001 0 4    # 只保留最新5条记录
```

---

## 5. 🏷️ Set集合的独特特性


### 5.1 Set的本质理解


**核心概念**：Set就像一个**标签袋**，里面装的标签都是独一无二的。

```
List vs Set 对比：

List（可重复）：       Set（自动去重）：
[苹果, 香蕉, 苹果]     {苹果, 香蕉}  ← 自动去掉重复的苹果
```

> 🔥 **Set的特点**：
> - **唯一性**：元素不能重复
> - **无序性**：不保证元素顺序
> - **快速查找**：判断元素是否存在速度很快

### 5.2 Set基础操作


#### 🏷️ 基本集合操作


```bash
# 添加元素
SADD user_tags:1001 "技术控"    # 添加用户标签
SADD user_tags:1001 "爱学习"
SADD user_tags:1001 "技术控"    # 重复添加，实际不会重复存储

# 查看集合
SMEMBERS user_tags:1001         # 查看所有标签：{"技术控", "爱学习"}
SCARD user_tags:1001           # 标签数量：2

# 检查和删除
SISMEMBER user_tags:1001 "技术控"   # 检查是否有这个标签：1（存在）
SREM user_tags:1001 "技术控"        # 删除标签
```

#### 🔀 集合运算操作


```bash
# 用户A关注的人
SADD following:userA "user1" "user2" "user3"

# 用户B关注的人
SADD following:userB "user2" "user3" "user4"

# 集合运算
SINTER following:userA following:userB    # 交集：{"user2", "user3"}
SUNION following:userA following:userB    # 并集：{"user1","user2","user3","user4"}
SDIFF following:userA following:userB     # 差集：{"user1"}
```

### 5.3 Set的实际应用


#### 🎲 抽奖系统


```bash
# 参与抽奖的用户
SADD lottery:2025 "user1001" "user1002" "user1003"

# 随机抽取1个中奖者
SRANDMEMBER lottery:2025 1    # 随机获取（不删除）
SPOP lottery:2025            # 随机获取并删除（避免重复中奖）

# 查看参与人数
SCARD lottery:2025
```

#### 👥 用户关注关系


```bash
# 张三关注的人
SADD following:zhangsan "lisi" "wangwu" "zhaoliu"

# 李四的粉丝
SADD followers:lisi "zhangsan" "wangwu"

# 互相关注的人（张三关注的人中，谁也关注了张三）
SINTER following:zhangsan followers:zhangsan
```

#### 🔍 标签系统和推荐


```bash
# 文章标签
SADD article:101:tags "Java" "微服务" "Redis"
SADD article:102:tags "Python" "机器学习"

# 用户兴趣标签
SADD user:1001:interests "Java" "微服务" "Docker"

# 推荐算法：找到用户感兴趣的文章
SINTER article:101:tags user:1001:interests   # 结果：{"Java", "微服务"}
```

---

## 6. 🏆 Zset有序集合进阶


### 6.1 Zset的核心概念


**通俗理解**：Zset就像一个**智能排行榜**，每个元素都有一个分数，按分数自动排序。

```
普通Set vs Zset：

Set（无序）：           Zset（有序）：
{张三, 李四, 王五}      张三: 95分  ← 第1名
                      李四: 87分  ← 第2名  
                      王五: 82分  ← 第3名
```

> 🔥 **Zset特点**：
> - **有序**：按score分数排序
> - **唯一**：元素不重复（但分数可以相同）
> - **双索引**：可以按元素查找，也可以按排名查找

### 6.2 Zset核心操作


#### 🏅 基础排序操作


```bash
# 添加成员和分数
ZADD game_rank 1500 "张三"     # 张三1500分
ZADD game_rank 1200 "李四"     # 李四1200分  
ZADD game_rank 1800 "王五"     # 王五1800分

# 查看排名（从低到高）
ZRANGE game_rank 0 -1 WITHSCORES
# 结果：李四 1200, 张三 1500, 王五 1800

# 查看排名（从高到低）
ZREVRANGE game_rank 0 -1 WITHSCORES  
# 结果：王五 1800, 张三 1500, 李四 1200
```

#### 📊 分数和排名查询


```bash
# 查看用户分数
ZSCORE game_rank "张三"          # 返回1500

# 查看用户排名
ZREVRANK game_rank "张三"        # 返回1（第2名，从0开始计数）

# 分数范围查询
ZRANGEBYSCORE game_rank 1000 1600  # 查看1000-1600分的用户
```

#### ⚡ 分数修改操作


```bash
# 增加分数
ZINCRBY game_rank 100 "张三"     # 张三分数+100，变成1600

# 删除成员
ZREM game_rank "李四"           # 李四退出排行榜

# 获取排行榜人数
ZCARD game_rank
```

### 6.3 Zset的实际应用


#### 🎯 游戏排行榜


```bash
# 实时更新玩家分数
ZINCRBY player_rank 50 "player:1001"    # 玩家1001得了50分
ZINCRBY player_rank 30 "player:1002"    # 玩家1002得了30分

# 获取前10名
ZREVRANGE player_rank 0 9 WITHSCORES

# 获取某玩家的排名和分数
ZREVRANK player_rank "player:1001"      # 排名
ZSCORE player_rank "player:1001"        # 分数
```

#### ⏰ 延时任务队列


```bash
# 添加延时任务（时间戳作为分数）
ZADD delay_queue 1640995200 "task1"     # 2022-01-01执行的任务
ZADD delay_queue 1641081600 "task2"     # 2022-01-02执行的任务

# 获取到期的任务
current_time=1640995300
ZRANGEBYSCORE delay_queue 0 $current_time   # 获取需要执行的任务
ZREMRANGEBYSCORE delay_queue 0 $current_time # 删除已处理的任务
```

#### 📈 热门文章排序


```bash
# 文章热度分数 = 点赞数*2 + 评论数*3 + 浏览数*0.1
ZADD hot_articles 520 "article:101"    # 文章101热度520分
ZADD hot_articles 380 "article:102"    # 文章102热度380分

# 更新文章热度（新增一个点赞，+2分）
ZINCRBY hot_articles 2 "article:101"

# 获取热门文章TOP 10
ZREVRANGE hot_articles 0 9
```

---

## 7. 🎯 数据类型选择策略


### 7.1 选择决策树


```
选择Redis数据类型的思考流程：

存储的是什么？
├─ 简单值（数字、字符串）
│  └─ String 字符串类型
│
├─ 对象的多个属性  
│  └─ Hash 哈希类型
│
├─ 有序列表（时间轴、队列）
│  └─ List 列表类型
│
├─ 无序集合（标签、去重）
│  └─ Set 集合类型
│
└─ 需要排序的集合（排行榜）
   └─ Zset 有序集合类型
```

### 7.2 内存占用优化策略


#### 📊 内存效率对比


| 场景 | **String方案** | **Hash方案** | **推荐** |
|------|---------------|-------------|----------|
| 用户信息(少于100字段) | `user:1001 → JSON字符串` | `user:1001 → Hash结构` | **Hash** |
| 简单计数器 | `page_views → 数字` | `counters → {page_views: 数字}` | **String** |
| 配置信息 | `config → JSON字符串` | `config → Hash结构` | **Hash** |

#### 💡 内存优化技巧


```bash
# ❌ 内存浪费的方式
SET user:1001:name "张三"
SET user:1001:age "25"  
SET user:1001:email "zhangsan@email.com"
# 问题：每个key都有额外的内存开销

# ✅ 内存友好的方式
HMSET user:1001 name "张三" age "25" email "zhangsan@email.com"
# 优势：一个key，多个字段，内存使用更高效
```

### 7.3 业务场景匹配指南


#### 🔧 缓存场景


```bash
# 简单缓存：String
SET cache:user:1001 '{"name":"张三","age":25}' EX 3600

# 复杂对象：Hash
HMSET user:1001 name "张三" age 25 last_login "2025-01-01"
EXPIRE user:1001 3600
```

#### 📝 计数场景


```bash
# 全局计数：String
INCR total_visits           # 网站总访问量

# 分类计数：Hash
HINCRBY page_views "/" 1    # 首页访问+1
HINCRBY page_views "/about" 1  # 关于页面访问+1
```

#### 🎲 抽奖和去重


```bash
# 去重：Set
SADD unique_visitors:2025-01-01 "user1001"   # 今日独立访客

# 带权重的抽奖：Zset
ZADD lottery_pool 10 "一等奖"     # 一等奖概率权重10
ZADD lottery_pool 100 "二等奖"    # 二等奖概率权重100
```

### 7.4 性能考虑因素


#### ⚡ 时间复杂度对比


| 操作类型 | **String** | **Hash** | **List** | **Set** | **Zset** |
|---------|-----------|----------|----------|---------|----------|
| 单个元素操作 | O(1) | O(1) | O(1)* | O(1) | O(log N) |
| 范围查询 | N/A | O(N) | O(S+N) | N/A | O(log N + M) |
| 集合运算 | N/A | N/A | N/A | O(N) | O(N+M) |

> 📝 **注释**：
> - List的O(1)仅限头尾操作，按索引访问是O(N)
> - Zset的查询虽然是O(log N)，但在大多数场景下性能优秀
> - N表示集合大小，M表示结果集大小，S表示起始位置

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 String：最基础的类型，适合简单键值对和计数
🔸 Hash：对象存储的最佳选择，内存效率高
🔸 List：有序可重复，适合队列和时间轴场景  
🔸 Set：无序不重复，适合标签和去重场景
🔸 Zset：有序不重复，排行榜的完美选择
```

### 8.2 数据类型选择口诀


> 🧠 **记忆口诀**：
> - **简单存储用String，对象属性选Hash**
> - **队列时间轴用List，去重标签靠Set**  
> - **排行榜单选Zset，性能内存都要看**

### 8.3 性能优化要点


**🔹 内存优化原则**：
```
1. 优先使用Hash存储对象（字段少于100个）
2. 避免大Key，单个key不要超过10KB
3. 合理设置过期时间，及时清理无用数据
4. 使用pipeline批量操作提高效率
```

**🔹 选择策略总结**：
```
业务特点                    推荐类型
├─ 简单值存储              → String
├─ 对象多属性              → Hash  
├─ 需要保持插入顺序        → List
├─ 需要去重不需要排序      → Set
└─ 需要去重且需要排序      → Zset
```

### 8.4 实际应用建议


**🎯 新手学习路径**：
1. **先掌握String**：理解Redis基本概念
2. **再学Hash**：掌握对象存储最佳实践
3. **然后List和Set**：理解集合操作的差异
4. **最后Zset**：掌握排序和范围查询

**🔧 实际开发建议**：
- 根据业务需求选择数据类型，不要为了使用而使用
- 注意内存使用效率，定期清理过期数据
- 合理设计key的命名规范，便于管理和监控
- 重要数据要考虑持久化策略

**核心理解**：
- Redis数据结构不是为了展示技巧，而是为了解决实际问题
- 选择合适的数据结构比优化算法更重要
- 理解业务场景比记住命令更有价值