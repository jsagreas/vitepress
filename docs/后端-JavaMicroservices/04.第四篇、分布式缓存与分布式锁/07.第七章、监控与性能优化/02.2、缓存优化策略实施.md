---
title: 2ã€ç¼“å­˜ä¼˜åŒ–ç­–ç•¥å®æ–½
---
## ğŸ“š ç›®å½•


1. [ç¼“å­˜ä¼˜åŒ–åŸºç¡€æ¦‚å¿µ](#1-ç¼“å­˜ä¼˜åŒ–åŸºç¡€æ¦‚å¿µ)
2. [æ•°æ®å‹ç¼©æŠ€æœ¯](#2-æ•°æ®å‹ç¼©æŠ€æœ¯)
3. [æ‰¹é‡æ“ä½œä¼˜åŒ–](#3-æ‰¹é‡æ“ä½œä¼˜åŒ–)
4. [è¿æ¥æ± è°ƒä¼˜](#4-è¿æ¥æ± è°ƒä¼˜)
5. [åºåˆ—åŒ–æ–¹æ¡ˆé€‰æ‹©](#5-åºåˆ—åŒ–æ–¹æ¡ˆé€‰æ‹©)
6. [åˆ†ç‰‡ç­–ç•¥è®¾è®¡](#6-åˆ†ç‰‡ç­–ç•¥è®¾è®¡)
7. [é¢„åŠ è½½æœºåˆ¶](#7-é¢„åŠ è½½æœºåˆ¶)
8. [å®¹é‡è§„åˆ’æ–¹æ³•](#8-å®¹é‡è§„åˆ’æ–¹æ³•)
9. [æˆæœ¬æ§åˆ¶æªæ–½](#9-æˆæœ¬æ§åˆ¶æªæ–½)
10. [çƒ­ç‚¹æ•°æ®å¤„ç†](#10-çƒ­ç‚¹æ•°æ®å¤„ç†)
11. [å†·æ•°æ®æ¸…ç†](#11-å†·æ•°æ®æ¸…ç†)
12. [æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#12-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)

---

# ğŸ¯ **å­¦ä¹ å¯¼èˆª**


**å‰ç½®çŸ¥è¯†**ï¼šRedisåŸºç¡€ã€Spring Bootã€Javaé›†åˆæ¡†æ¶ â†’ **å½“å‰å†…å®¹**ï¼šç¼“å­˜ä¼˜åŒ–ç­–ç•¥ â†’ **åç»­å­¦ä¹ **ï¼šç¼“å­˜æ¶æ„è®¾è®¡æ¨¡å¼

â±ï¸ **é¢„è®¡å­¦ä¹ æ—¶é—´**ï¼šæœ¬ç« 60åˆ†é’Ÿ | å®è·µç»ƒä¹ 45åˆ†é’Ÿ

ğŸ·ï¸ **çŸ¥è¯†æ ‡ç­¾**ï¼š`#æ€§èƒ½ä¼˜åŒ–` `#åˆ†å¸ƒå¼ç¼“å­˜` `#å¾®æœåŠ¡æ¶æ„` `#ç”Ÿäº§å®è·µ`

---

## 1. ğŸš€ ç¼“å­˜ä¼˜åŒ–åŸºç¡€æ¦‚å¿µ



### 1.1 ä»€ä¹ˆæ˜¯ç¼“å­˜ä¼˜åŒ–



**ğŸ’¡ é€šä¿—ç†è§£**
ç¼“å­˜ä¼˜åŒ–å°±åƒæ•´ç†ä½ çš„ä¹¦æ¡Œï¼š
- **æ²¡ä¼˜åŒ–å‰**ï¼šä¹¦æœ¬éšæ„å †æ”¾ï¼Œæ‰¾ä¹¦å¾ˆæ…¢ï¼Œæ¡Œå­å¾ˆä¹±
- **ä¼˜åŒ–å**ï¼šå¸¸ç”¨ä¹¦æ”¾æ‰‹è¾¹ï¼Œåˆ†ç±»æ‘†æ”¾ï¼Œæ‰¾ä¹¦åˆå¿«åˆæ–¹ä¾¿

**ğŸ”¸ æ ¸å¿ƒå®šä¹‰**
```
ç¼“å­˜ä¼˜åŒ–ï¼šé€šè¿‡æ”¹è¿›ç¼“å­˜çš„å­˜å‚¨ã€è®¿é—®ã€ç®¡ç†æ–¹å¼
ç›®æ ‡ï¼šæå‡æ€§èƒ½ã€é™ä½æˆæœ¬ã€å¢å¼ºç¨³å®šæ€§
æœ¬è´¨ï¼šè®©"ä¸´æ—¶å­˜å‚¨"å‘æŒ¥æœ€å¤§ä»·å€¼
```

### 1.2 ç¼“å­˜ä¼˜åŒ–çš„é‡è¦æ€§



**ğŸ“Š æ€§èƒ½å½±å“å¯¹æ¯”**
| **ä¼˜åŒ–é¡¹ç›®** | **ä¼˜åŒ–å‰** | **ä¼˜åŒ–å** | **æå‡å¹…åº¦** |
|-------------|------------|------------|-------------|
| **å“åº”æ—¶é—´** | 200ms | 50ms | â­â­â­â­ |
| **å¹¶å‘å¤„ç†** | 1000 QPS | 5000 QPS | â­â­â­â­â­ |
| **å†…å­˜ä½¿ç”¨** | 2GB | 800MB | â­â­â­ |
| **ç½‘ç»œå¸¦å®½** | 100MB/s | 30MB/s | â­â­â­â­ |

### 1.3 ä¼˜åŒ–ç­–ç•¥åˆ†ç±»



**ğŸ¯ ä¼˜åŒ–ç»´åº¦**
```
ğŸ”¸ å­˜å‚¨ç»´åº¦ï¼šæ•°æ®æ€ä¹ˆå­˜æ›´èŠ‚çœç©ºé—´
ğŸ”¸ ä¼ è¾“ç»´åº¦ï¼šæ•°æ®æ€ä¹ˆä¼ æ›´å¿«é€Ÿ
ğŸ”¸ è®¿é—®ç»´åº¦ï¼šæ•°æ®æ€ä¹ˆå–æ›´é«˜æ•ˆ
ğŸ”¸ ç®¡ç†ç»´åº¦ï¼šæ•°æ®æ€ä¹ˆç®¡æ›´æ™ºèƒ½
```

---

## 2. ğŸ—œï¸ æ•°æ®å‹ç¼©æŠ€æœ¯



### 2.1 ä¸ºä»€ä¹ˆéœ€è¦å‹ç¼©



**ğŸ’¡ ç”Ÿæ´»ç±»æ¯”**
å‹ç¼©å°±åƒæ”¶çº³è¢‹ï¼š
- **åŸå§‹è¡£æœ**ï¼šè“¬æ¾å åœ°æ–¹ï¼Œè¡£æŸœè£…ä¸ä¸‹
- **å‹ç¼©è¢‹è£…**ï¼šä½“ç§¯å‡å°‘70%ï¼Œè¡£æŸœè£…å¾—ä¸‹æ›´å¤š

**ğŸ“ˆ å‹ç¼©æ”¶ç›Šåˆ†æ**
```
å†…å­˜èŠ‚çœï¼šå‡å°‘50-80%å­˜å‚¨ç©ºé—´
ç½‘ç»œä¼˜åŒ–ï¼šå‡å°‘70%ä¼ è¾“æ—¶é—´
æˆæœ¬é™ä½ï¼šå‡å°‘æœåŠ¡å™¨èµ„æºæŠ•å…¥
```

### 2.2 å¸¸ç”¨å‹ç¼©ç®—æ³•å¯¹æ¯”



| **å‹ç¼©ç®—æ³•** | **å‹ç¼©ç‡** | **å‹ç¼©é€Ÿåº¦** | **è§£å‹é€Ÿåº¦** | **é€‚ç”¨åœºæ™¯** |
|-------------|-----------|-------------|-------------|-------------|
| **Gzip** | â­â­â­ | â­â­â­ | â­â­â­â­ | æ–‡æœ¬æ•°æ® |
| **LZ4** | â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | å®æ—¶å‹ç¼© |
| **Snappy** | â­â­ | â­â­â­â­ | â­â­â­â­â­ | å¤§æ•°æ®å¤„ç† |
| **ZSTD** | â­â­â­â­ | â­â­â­ | â­â­â­â­ | å¹³è¡¡å‹é€‰æ‹© |

### 2.3 Javaå‹ç¼©å®ç°



**ğŸ”§ åŸºç¡€å‹ç¼©å·¥å…·ç±»**
```java
@Component
public class CompressionUtils {
    
    // ä½¿ç”¨Gzipå‹ç¼©å­—ç¬¦ä¸²
    public byte[] compress(String data) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             GZIPOutputStream gzos = new GZIPOutputStream(baos)) {
            gzos.write(data.getBytes(StandardCharsets.UTF_8));
            gzos.finish();
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("å‹ç¼©å¤±è´¥", e);
        }
    }
    
    // è§£å‹ç¼©
    public String decompress(byte[] compressed) {
        try (ByteArrayInputStream bais = new ByteArrayInputStream(compressed);
             GZIPInputStream gzis = new GZIPInputStream(bais)) {
            return new String(gzis.readAllBytes(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("è§£å‹å¤±è´¥", e);
        }
    }
}
```

### 2.4 Rediså‹ç¼©åº”ç”¨



**âš¡ æ™ºèƒ½å‹ç¼©ç¼“å­˜**
```java
@Service
public class CompressedCacheService {
    
    @Autowired
    private RedisTemplate<String, byte[]> redisTemplate;
    
    @Autowired
    private CompressionUtils compressionUtils;
    
    // å­˜å‚¨æ—¶è‡ªåŠ¨å‹ç¼©
    public void setCompressed(String key, String value, Duration ttl) {
        byte[] compressed = compressionUtils.compress(value);
        redisTemplate.opsForValue().set(key, compressed, ttl);
        
        // è®°å½•å‹ç¼©æ•ˆæœ
        double ratio = (double) compressed.length / value.getBytes().length;
        log.info("å‹ç¼©æ¯”: {:.2f}, èŠ‚çœ: {:.1f}%", ratio, (1-ratio)*100);
    }
    
    // è·å–æ—¶è‡ªåŠ¨è§£å‹
    public String getCompressed(String key) {
        byte[] compressed = redisTemplate.opsForValue().get(key);
        return compressed != null ? compressionUtils.decompress(compressed) : null;
    }
}
```

**ğŸ¯ ä½¿ç”¨å»ºè®®**
```
é€‚åˆå‹ç¼©çš„æ•°æ®ï¼š
âœ… JSONå­—ç¬¦ä¸²ï¼ˆå‹ç¼©ç‡é«˜ï¼‰
âœ… HTMLå†…å®¹ï¼ˆé‡å¤å­—ç¬¦å¤šï¼‰
âœ… æ—¥å¿—æ–‡æœ¬ï¼ˆæ¨¡å¼ç›¸ä¼¼ï¼‰

ä¸é€‚åˆå‹ç¼©çš„æ•°æ®ï¼š
âŒ å·²å‹ç¼©çš„å›¾ç‰‡/è§†é¢‘
âŒ åŠ å¯†åçš„æ•°æ®
âŒ å¾ˆå°çš„æ•°æ®ï¼ˆ<100å­—èŠ‚ï¼‰
```

---

## 3. ğŸ“¦ æ‰¹é‡æ“ä½œä¼˜åŒ–



### 3.1 æ‰¹é‡æ“ä½œçš„ä»·å€¼



**ğŸ’¡ å¿«é€’ç±»æ¯”**
- **å•æ¬¡æ“ä½œ**ï¼šæ¯ä¸ªåŒ…è£¹å•ç‹¬é€ï¼Œè·‘100è¶Ÿ
- **æ‰¹é‡æ“ä½œ**ï¼šè£…æ»¡è½¦ä¸€æ¬¡é€ï¼Œåªè·‘1è¶Ÿ

**ğŸ“Š æ€§èƒ½å¯¹æ¯”**
```
å•æ¬¡æ“ä½œï¼š1000æ¬¡ Ã— 1ms = 1000ms
æ‰¹é‡æ“ä½œï¼š1æ¬¡ Ã— 50ms = 50ms
æ€§èƒ½æå‡ï¼š20å€ï¼
```

### 3.2 Redis Pipelineæ‰¹é‡ä¼˜åŒ–



**ğŸš€ Pipelineæ“ä½œå®ç°**
```java
@Service
public class BatchCacheService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    // æ‰¹é‡è®¾ç½®ç¼“å­˜
    public void batchSet(Map<String, String> keyValues, Duration ttl) {
        redisTemplate.executePipelined(new RedisCallback<Object>() {
            @Override
            public Object doInRedis(RedisConnection connection) {
                keyValues.forEach((key, value) -> {
                    connection.setEx(key.getBytes(), ttl.getSeconds(), 
                                   value.getBytes());
                });
                return null; // Pipelineä¸éœ€è¦è¿”å›å€¼
            }
        });
    }
    
    // æ‰¹é‡è·å–ç¼“å­˜
    public Map<String, String> batchGet(List<String> keys) {
        List<Object> results = redisTemplate.executePipelined(
            (RedisCallback<Object>) connection -> {
                keys.forEach(key -> connection.get(key.getBytes()));
                return null;
            }
        );
        
        Map<String, String> resultMap = new HashMap<>();
        for (int i = 0; i < keys.size(); i++) {
            if (results.get(i) != null) {
                resultMap.put(keys.get(i), (String) results.get(i));
            }
        }
        return resultMap;
    }
}
```

### 3.3 æ‰¹é‡æ“ä½œæœ€ä½³å®è·µ



**ğŸ“‹ æ‰¹æ¬¡å¤§å°é€‰æ‹©**
```
æ¨èæ‰¹æ¬¡å¤§å°ï¼š
ğŸ”¸ æ™®é€šæ“ä½œï¼š100-500æ¡/æ‰¹æ¬¡
ğŸ”¸ å¤§æ•°æ®æ“ä½œï¼š50-100æ¡/æ‰¹æ¬¡
ğŸ”¸ ç½‘ç»œè¾ƒæ…¢ï¼š20-50æ¡/æ‰¹æ¬¡
```

**âš ï¸ å¸¸è§é™·é˜±**
> **âŒ é”™è¯¯åšæ³•**ï¼šä¸€æ¬¡æ€§æ‰¹é‡å¤„ç†10ä¸‡æ¡æ•°æ®
> 
> **âœ… æ­£ç¡®åšæ³•**ï¼šåˆ†æ‰¹å¤„ç†ï¼Œæ¯æ‰¹500æ¡
> 
> **åŸå› **ï¼šé¿å…é˜»å¡Rediså¤ªé•¿æ—¶é—´ï¼Œå½±å“å…¶ä»–è¯·æ±‚

---

## 4. ğŸŠ è¿æ¥æ± è°ƒä¼˜



### 4.1 è¿æ¥æ± çš„ä½œç”¨



**ğŸ’¡ é¤å…ç±»æ¯”**
è¿æ¥æ± å°±åƒé¤å…çš„æœåŠ¡å‘˜ï¼š
- **æ²¡æœ‰æœåŠ¡å‘˜**ï¼šå®¢äººè¦è‡ªå·±å»å¨æˆ¿æ‹¿èœï¼Œå¾ˆæ…¢å¾ˆä¹±
- **æœåŠ¡å‘˜å¤ªå°‘**ï¼šå®¢äººæ’é•¿é˜Ÿç­‰æœåŠ¡
- **æœåŠ¡å‘˜åˆé€‚**ï¼šå¿«é€ŸæœåŠ¡ï¼Œå®¢äººæ»¡æ„
- **æœåŠ¡å‘˜å¤ªå¤š**ï¼šæˆæœ¬é«˜ï¼ŒæœåŠ¡å‘˜é—²ç€

### 4.2 è¿æ¥æ± å…³é”®å‚æ•°



| **å‚æ•°** | **å«ä¹‰** | **æ¨èå€¼** | **è°ƒä¼˜å»ºè®®** |
|---------|---------|-----------|-------------|
| **maxTotal** | æœ€å¤§è¿æ¥æ•° | 200 | æ ¹æ®å¹¶å‘é‡è°ƒæ•´ |
| **maxIdle** | æœ€å¤§ç©ºé—²è¿æ¥ | 50 | maxTotalçš„20-30% |
| **minIdle** | æœ€å°ç©ºé—²è¿æ¥ | 10 | ä¿è¯åŸºç¡€è¿æ¥ |
| **maxWaitMillis** | è·å–è¿æ¥è¶…æ—¶ | 3000ms | ä¸šåŠ¡èƒ½æ¥å—çš„ç­‰å¾…æ—¶é—´ |

### 4.3 è¿æ¥æ± é…ç½®ä¼˜åŒ–



**âš™ï¸ Redisè¿æ¥æ± é…ç½®**
```java
@Configuration
public class RedisPoolConfig {
    
    @Bean
    public JedisConnectionFactory jedisConnectionFactory() {
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        
        // è¿æ¥æ•°é…ç½®
        poolConfig.setMaxTotal(200);        // æœ€å¤§è¿æ¥æ•°
        poolConfig.setMaxIdle(50);          // æœ€å¤§ç©ºé—²è¿æ¥
        poolConfig.setMinIdle(10);          // æœ€å°ç©ºé—²è¿æ¥
        
        // è¶…æ—¶é…ç½®
        poolConfig.setMaxWaitMillis(3000);  // è·å–è¿æ¥è¶…æ—¶
        
        // è¿æ¥æ£€æŸ¥
        poolConfig.setTestOnBorrow(true);   // å€Ÿç”¨æ—¶æ£€æŸ¥
        poolConfig.setTestWhileIdle(true);  // ç©ºé—²æ—¶æ£€æŸ¥
        
        return new JedisConnectionFactory(poolConfig);
    }
}
```

### 4.4 è¿æ¥æ± ç›‘æ§



**ğŸ“Š è¿æ¥æ± å¥åº·æ£€æŸ¥**
```java
@Component
public class ConnectionPoolMonitor {
    
    @Autowired
    private JedisConnectionFactory connectionFactory;
    
    @Scheduled(fixedRate = 30000) // 30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void monitorPool() {
        JedisPoolConfig config = connectionFactory.getPoolConfig();
        
        int active = config.getNumActive();    // æ´»è·ƒè¿æ¥
        int idle = config.getNumIdle();        // ç©ºé—²è¿æ¥
        int waiting = config.getNumWaiters();  // ç­‰å¾…è¿æ¥çš„çº¿ç¨‹
        
        log.info("è¿æ¥æ± çŠ¶æ€ - æ´»è·ƒ:{}, ç©ºé—²:{}, ç­‰å¾…:{}", active, idle, waiting);
        
        // å‘Šè­¦æ£€æŸ¥
        if (waiting > 10) {
            log.warn("è¿æ¥æ± å‹åŠ›è¿‡å¤§ï¼Œç­‰å¾…çº¿ç¨‹è¿‡å¤š: {}", waiting);
        }
    }
}
```

---

## 5. ğŸ”„ åºåˆ—åŒ–æ–¹æ¡ˆé€‰æ‹©



### 5.1 åºåˆ—åŒ–çš„ä½œç”¨



**ğŸ’¡ é‚®å¯„åŒ…è£¹ç±»æ¯”**
- **åºåˆ—åŒ–**ï¼šæŠŠå¤æ‚ç‰©å“è£…ç®±æ‰“åŒ…ï¼Œæ–¹ä¾¿é‚®å¯„
- **ååºåˆ—åŒ–**ï¼šæ”¶åˆ°åŒ…è£¹åæ‹†ç®±ï¼Œæ¢å¤åŸç‰©å“

**ğŸ”¸ åœ¨ç¼“å­˜ä¸­çš„æ„ä¹‰**
Javaå¯¹è±¡ â†’ å­—èŠ‚æµ â†’ å­˜å…¥Redis â†’ å­—èŠ‚æµ â†’ Javaå¯¹è±¡

### 5.2 åºåˆ—åŒ–æ–¹æ¡ˆå¯¹æ¯”



| **åºåˆ—åŒ–æ–¹å¼** | **é€Ÿåº¦** | **ä½“ç§¯** | **å¯è¯»æ€§** | **å…¼å®¹æ€§** | **æ¨èåœºæ™¯** |
|--------------|---------|---------|-----------|-----------|-------------|
| **JDKé»˜è®¤** | â­â­ | â­ | âŒ | â­â­â­ | ç®€å•å†…éƒ¨ç³»ç»Ÿ |
| **JSON** | â­â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | è·¨è¯­è¨€ç³»ç»Ÿ |
| **Protobuf** | â­â­â­â­ | â­â­â­â­â­ | â­â­ | â­â­â­â­ | é«˜æ€§èƒ½ç³»ç»Ÿ |
| **Kryo** | â­â­â­â­â­ | â­â­â­â­ | âŒ | â­â­ | Javaé«˜æ€§èƒ½åœºæ™¯ |

### 5.3 JSONåºåˆ—åŒ–å®ç°



**ğŸ”§ Jacksonåºåˆ—åŒ–é…ç½®**
```java
@Configuration
public class JsonCacheConfig {
    
    @Bean
    public RedisTemplate<String, Object> jsonRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(jedisConnectionFactory());
        
        // JSONåºåˆ—åŒ–é…ç½®
        Jackson2JsonRedisSerializer<Object> serializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.configure(JsonGenerator.Feature.IGNORE_UNKNOWN, true);
        serializer.setObjectMapper(mapper);
        
        // è®¾ç½®åºåˆ—åŒ–å™¨
        template.setDefaultSerializer(serializer);
        template.setKeySerializer(new StringRedisSerializer());
        
        return template;
    }
}
```

### 5.4 è‡ªå®šä¹‰é«˜æ•ˆåºåˆ—åŒ–



**âš¡ Kryoé«˜æ€§èƒ½åºåˆ—åŒ–**
```java
@Component
public class KryoSerializer {
    
    private final ThreadLocal<Kryo> kryoThreadLocal = ThreadLocal.withInitial(() -> {
        Kryo kryo = new Kryo();
        kryo.setReferences(false); // å…³é—­å¾ªç¯å¼•ç”¨æ£€æŸ¥ï¼Œæå‡æ€§èƒ½
        kryo.setRegistrationRequired(false); // å…è®¸æœªæ³¨å†Œç±»
        return kryo;
    });
    
    public byte[] serialize(Object obj) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             Output output = new Output(baos)) {
            kryoThreadLocal.get().writeObject(output, obj);
            return baos.toByteArray();
        }
    }
    
    public <T> T deserialize(byte[] bytes, Class<T> clazz) {
        try (Input input = new Input(bytes)) {
            return kryoThreadLocal.get().readObject(input, clazz);
        }
    }
}
```

---

## 6. ğŸ—‚ï¸ åˆ†ç‰‡ç­–ç•¥è®¾è®¡



### 6.1 ä»€ä¹ˆæ˜¯åˆ†ç‰‡ç­–ç•¥



**ğŸ’¡ å›¾ä¹¦é¦†ç±»æ¯”**
- **å•ä¸ªä¹¦æ¶**ï¼šæ‰€æœ‰ä¹¦æ”¾ä¸€èµ·ï¼Œæ‰¾ä¹¦æ…¢ï¼Œå®¹é‡æœ‰é™
- **å¤šä¸ªä¹¦æ¶**ï¼šæŒ‰ç±»åˆ«åˆ†å¼€æ”¾ï¼Œæ‰¾ä¹¦å¿«ï¼Œå¯ä»¥æ‰©å®¹

**ğŸ”¸ ç¼“å­˜åˆ†ç‰‡çš„æ„ä¹‰**
```
è´Ÿè½½åˆ†æ•£ï¼šé¿å…å•ç‚¹å‹åŠ›è¿‡å¤§
å®¹é‡æ‰©å±•ï¼šçªç ´å•æœºå­˜å‚¨é™åˆ¶
æ•…éšœéš”ç¦»ï¼šä¸€ä¸ªåˆ†ç‰‡é—®é¢˜ä¸å½±å“å…¨éƒ¨
```

### 6.2 åˆ†ç‰‡ç®—æ³•é€‰æ‹©



**ğŸ“Š å¸¸ç”¨åˆ†ç‰‡ç®—æ³•**
| **ç®—æ³•** | **å‡åŒ€æ€§** | **æ‰©å®¹å‹å¥½** | **å®ç°å¤æ‚åº¦** | **é€‚ç”¨åœºæ™¯** |
|---------|-----------|-------------|---------------|-------------|
| **å–æ¨¡åˆ†ç‰‡** | â­â­â­ | â­ | â­ | å›ºå®šèŠ‚ç‚¹æ•° |
| **ä¸€è‡´æ€§å“ˆå¸Œ** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­ | åŠ¨æ€æ‰©ç¼©å®¹ |
| **èŒƒå›´åˆ†ç‰‡** | â­â­ | â­â­â­ | â­â­ | æœ‰åºæ•°æ® |

### 6.3 ä¸€è‡´æ€§å“ˆå¸Œå®ç°



**ğŸ”„ åˆ†ç‰‡è·¯ç”±å™¨**
```java
@Component
public class ConsistentHashRouter {
    
    private final SortedMap<Integer, String> circle = new TreeMap<>();
    private final int virtualNodes = 150; // è™šæ‹ŸèŠ‚ç‚¹æ•°
    
    public void addNode(String node) {
        for (int i = 0; i < virtualNodes; i++) {
            String virtualNode = node + "#" + i;
            int hash = hash(virtualNode);
            circle.put(hash, node);
        }
    }
    
    public String getNode(String key) {
        if (circle.isEmpty()) {
            return null;
        }
        
        int hash = hash(key);
        
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºè¯¥hashå€¼çš„èŠ‚ç‚¹
        SortedMap<Integer, String> tailMap = circle.tailMap(hash);
        int nodeHash = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey();
        
        return circle.get(nodeHash);
    }
    
    private int hash(String key) {
        return key.hashCode();
    }
}
```

### 6.4 åˆ†ç‰‡ç¼“å­˜æœåŠ¡



**ğŸ¯ æ™ºèƒ½åˆ†ç‰‡ç¼“å­˜**
```java
@Service
public class ShardedCacheService {
    
    private final Map<String, RedisTemplate> shards = new HashMap<>();
    
    @Autowired
    private ConsistentHashRouter router;
    
    public void set(String key, Object value, Duration ttl) {
        String shard = router.getNode(key);
        RedisTemplate template = shards.get(shard);
        template.opsForValue().set(key, value, ttl);
    }
    
    public Object get(String key) {
        String shard = router.getNode(key);
        RedisTemplate template = shards.get(shard);
        return template.opsForValue().get(key);
    }
}
```

---

## 7. ğŸš€ é¢„åŠ è½½æœºåˆ¶



### 7.1 é¢„åŠ è½½çš„ä»·å€¼



**ğŸ’¡ è¶…å¸‚ç±»æ¯”**
- **è¢«åŠ¨è¡¥è´§**ï¼šè´§ç‰©å–å®Œæ‰è¿›è´§ï¼Œå®¢äººç­‰å¾…
- **ä¸»åŠ¨é¢„è®¢**ï¼šé¢„æµ‹éœ€æ±‚æå‰è¿›è´§ï¼Œå®¢äººéšæ—¶ä¹°åˆ°

**ğŸ“ˆ é¢„åŠ è½½æ•ˆæœ**
```
ç¼“å­˜å‘½ä¸­ç‡ï¼šä»60% â†’ 95%
å¹³å‡å“åº”æ—¶é—´ï¼šä»200ms â†’ 20ms
æ•°æ®åº“å‹åŠ›ï¼šå‡å°‘80%
```

### 7.2 é¢„åŠ è½½è§¦å‘ç­–ç•¥



**ğŸ¯ é¢„åŠ è½½æ—¶æœº**
```
ğŸ”¸ ç³»ç»Ÿå¯åŠ¨æ—¶ï¼šåŠ è½½æ ¸å¿ƒåŸºç¡€æ•°æ®
ğŸ”¸ å®šæ—¶ä»»åŠ¡ï¼šå‘¨æœŸæ€§åˆ·æ–°çƒ­ç‚¹æ•°æ®
ğŸ”¸ ä¸šåŠ¡è§¦å‘ï¼šç”¨æˆ·æ“ä½œå‰é¢„å…ˆå‡†å¤‡
ğŸ”¸ æ™ºèƒ½é¢„æµ‹ï¼šåŸºäºå†å²æ¨¡å¼æå‰åŠ è½½
```

### 7.3 å¯åŠ¨æ—¶é¢„åŠ è½½



**âš¡ ç³»ç»Ÿå¯åŠ¨é¢„çƒ­**
```java
@Component
public class CacheWarmupService implements ApplicationListener<ContextRefreshedEvent> {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private CacheService cacheService;
    
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        log.info("å¼€å§‹ç¼“å­˜é¢„çƒ­...");
        
        // é¢„åŠ è½½çƒ­ç‚¹ç”¨æˆ·æ•°æ®
        warmupHotUsers();
        
        // é¢„åŠ è½½ç³»ç»Ÿé…ç½®
        warmupSystemConfig();
        
        log.info("ç¼“å­˜é¢„çƒ­å®Œæˆ");
    }
    
    private void warmupHotUsers() {
        List<Long> hotUserIds = userService.getHotUserIds(); // è·å–çƒ­ç‚¹ç”¨æˆ·ID
        
        hotUserIds.parallelStream().forEach(userId -> {
            try {
                UserInfo user = userService.getUserById(userId);
                cacheService.set("user:" + userId, user, Duration.ofHours(1));
            } catch (Exception e) {
                log.warn("é¢„åŠ è½½ç”¨æˆ·{}å¤±è´¥", userId, e);
            }
        });
    }
}
```

### 7.4 æ™ºèƒ½é¢„åŠ è½½



**ğŸ§  åŸºäºè®¿é—®æ¨¡å¼çš„é¢„æµ‹**
```java
@Service
public class SmartPreloadService {
    
    private final Map<String, AtomicInteger> accessCount = new ConcurrentHashMap<>();
    private final Map<String, LocalDateTime> lastAccess = new ConcurrentHashMap<>();
    
    public void recordAccess(String key) {
        accessCount.computeIfAbsent(key, k -> new AtomicInteger(0)).incrementAndGet();
        lastAccess.put(key, LocalDateTime.now());
    }
    
    @Scheduled(fixedRate = 300000) // 5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void smartPreload() {
        List<String> candidateKeys = findCandidateKeys();
        
        candidateKeys.forEach(key -> {
            if (!cacheService.exists(key)) {
                try {
                    Object data = loadDataFromDB(key);
                    cacheService.set(key, data, Duration.ofMinutes(30));
                    log.info("æ™ºèƒ½é¢„åŠ è½½: {}", key);
                } catch (Exception e) {
                    log.warn("é¢„åŠ è½½å¤±è´¥: {}", key, e);
                }
            }
        });
    }
    
    private List<String> findCandidateKeys() {
        return accessCount.entrySet().stream()
            .filter(entry -> entry.getValue().get() > 10) // è®¿é—®è¶…è¿‡10æ¬¡
            .map(Map.Entry::getKey)
            .limit(100) // é™åˆ¶é¢„åŠ è½½æ•°é‡
            .collect(Collectors.toList());
    }
}
```

---

## 8. ğŸ“ å®¹é‡è§„åˆ’æ–¹æ³•



### 8.1 å®¹é‡è§„åˆ’çš„é‡è¦æ€§



**ğŸ’¡ åœè½¦åœºç±»æ¯”**
- **è§„åˆ’ä¸è¶³**ï¼šè½¦ä½ä¸å¤Ÿï¼Œç”¨æˆ·ä½“éªŒå·®
- **è§„åˆ’è¿‡åº¦**ï¼šæµªè´¹èµ„æºï¼Œæˆæœ¬è¿‡é«˜
- **æ°åˆ°å¥½å¤„**ï¼šæ»¡è¶³éœ€æ±‚ï¼Œæˆæœ¬åˆç†

### 8.2 å®¹é‡è¯„ä¼°æ–¹æ³•



**ğŸ“Š è¯„ä¼°ç»´åº¦**
```
ğŸ”¸ æ•°æ®æ€»é‡ï¼šéœ€è¦ç¼“å­˜å¤šå°‘æ•°æ®
ğŸ”¸ è®¿é—®é¢‘ç‡ï¼šæ¯ç§’å¤šå°‘æ¬¡è®¿é—®
ğŸ”¸ æ•°æ®å¤§å°ï¼šå•æ¡è®°å½•å¹³å‡å¤§å°
ğŸ”¸ è¿‡æœŸç­–ç•¥ï¼šæ•°æ®ä¿å­˜å¤šé•¿æ—¶é—´
ğŸ”¸ å¢é•¿è¶‹åŠ¿ï¼šä¸šåŠ¡å¢é•¿é€Ÿåº¦é¢„æµ‹
```

### 8.3 å®¹é‡è®¡ç®—å…¬å¼



**ğŸ§® å†…å­˜éœ€æ±‚è®¡ç®—**
```java
@Component
public class CapacityCalculator {
    
    // è®¡ç®—æ‰€éœ€å†…å­˜å®¹é‡
    public long calculateMemoryRequirement(CapacityParams params) {
        long totalDataSize = params.getRecordCount() * params.getAvgRecordSize();
        long redisOverhead = (long) (totalDataSize * 0.2); // Rediså¼€é”€çº¦20%
        long bufferSize = (long) (totalDataSize * 0.3);    // 30%ç¼“å†²
        
        return totalDataSize + redisOverhead + bufferSize;
    }
    
    // è®¡ç®—QPSå®¹é‡
    public int calculateQPSCapacity(int expectedQPS, double safetyFactor) {
        return (int) (expectedQPS * safetyFactor); // å®‰å…¨ç³»æ•°é€šå¸¸1.5-2.0
    }
}

// å®¹é‡å‚æ•°
@Data
public class CapacityParams {
    private long recordCount;     // è®°å½•æ•°é‡
    private int avgRecordSize;    // å¹³å‡è®°å½•å¤§å°(å­—èŠ‚)
    private int expectedQPS;      // é¢„æœŸQPS
    private double growthRate;    // å¢é•¿ç‡
}
```

### 8.4 åŠ¨æ€æ‰©å®¹ç­–ç•¥



**ğŸ“ˆ è‡ªåŠ¨æ‰©å®¹æœºåˆ¶**
```java
@Component
public class AutoScalingService {
    
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ£€æŸ¥
    public void checkAndScale() {
        MemoryUsage memoryUsage = getMemoryUsage();
        
        if (memoryUsage.getUsagePercent() > 80) {
            log.warn("å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {}%", memoryUsage.getUsagePercent());
            triggerScaleOut();
        }
        
        if (getCurrentQPS() > getMaxQPS() * 0.8) {
            log.warn("QPSæ¥è¿‘ä¸Šé™ï¼Œå‡†å¤‡æ‰©å®¹");
            triggerScaleOut();
        }
    }
    
    private void triggerScaleOut() {
        // è§¦å‘æ‰©å®¹é€»è¾‘ï¼ˆæ·»åŠ æ–°èŠ‚ç‚¹ã€é‡æ–°åˆ†ç‰‡ç­‰ï¼‰
        log.info("è§¦å‘è‡ªåŠ¨æ‰©å®¹...");
    }
}
```

---

## 9. ğŸ’° æˆæœ¬æ§åˆ¶æªæ–½



### 9.1 æˆæœ¬æ„æˆåˆ†æ



**ğŸ’¸ ä¸»è¦æˆæœ¬æ¥æº**
```
ğŸ”¸ æœåŠ¡å™¨æˆæœ¬ï¼šCPUã€å†…å­˜ã€å­˜å‚¨è´¹ç”¨
ğŸ”¸ ç½‘ç»œæˆæœ¬ï¼šå¸¦å®½ã€æµé‡è´¹ç”¨  
ğŸ”¸ ç»´æŠ¤æˆæœ¬ï¼šäººå·¥è¿ç»´æŠ•å…¥
ğŸ”¸ ç”µåŠ›æˆæœ¬ï¼šæœºæˆ¿è€—ç”µè´¹ç”¨
```

### 9.2 æˆæœ¬ä¼˜åŒ–ç­–ç•¥



**ğŸ“Š ä¼˜åŒ–æªæ–½å¯¹æ¯”**
| **ä¼˜åŒ–æªæ–½** | **æˆæœ¬èŠ‚çœ** | **å®æ–½éš¾åº¦** | **é£é™©ç­‰çº§** |
|-------------|-------------|-------------|-------------|
| **æ•°æ®å‹ç¼©** | 30-50% | â­â­ | â­ |
| **TTLä¼˜åŒ–** | 20-40% | â­ | â­ |
| **å†·çƒ­åˆ†ç¦»** | 40-60% | â­â­â­ | â­â­ |
| **èµ„æºè°ƒåº¦** | 15-25% | â­â­â­â­ | â­â­â­ |

### 9.3 æ™ºèƒ½TTLç®¡ç†



**â° åŠ¨æ€è¿‡æœŸæ—¶é—´**
```java
@Service
public class SmartTTLService {
    
    // æ ¹æ®è®¿é—®é¢‘ç‡åŠ¨æ€è°ƒæ•´TTL
    public Duration calculateTTL(String key, Object value) {
        int accessCount = getAccessCount(key);
        int dataSize = calculateSize(value);
        
        // é«˜é¢‘è®¿é—® = é•¿TTL
        if (accessCount > 100) {
            return Duration.ofHours(2);
        } else if (accessCount > 10) {
            return Duration.ofMinutes(30);
        } else {
            return Duration.ofMinutes(5);
        }
    }
    
    // æ ¹æ®æ•°æ®ä»·å€¼è°ƒæ•´TTL
    public Duration calculateBusinessTTL(String dataType, Object value) {
        switch (dataType) {
            case "user_profile":
                return Duration.ofHours(1);   // ç”¨æˆ·èµ„æ–™ç¼“å­˜1å°æ—¶
            case "hot_product":
                return Duration.ofMinutes(10); // çƒ­é—¨å•†å“ç¼“å­˜10åˆ†é’Ÿ
            case "config_data":
                return Duration.ofHours(24);  // é…ç½®æ•°æ®ç¼“å­˜24å°æ—¶
            default:
                return Duration.ofMinutes(15);
        }
    }
}
```

### 9.4 æˆæœ¬ç›‘æ§ä»ªè¡¨æ¿



**ğŸ“Š æˆæœ¬é€æ˜åŒ–**
```java
@Component
public class CostMonitor {
    
    @Scheduled(fixedRate = 3600000) // æ¯å°æ—¶ç»Ÿè®¡
    public void generateCostReport() {
        CostReport report = CostReport.builder()
            .memoryUsageCost(calculateMemoryCost())
            .networkTrafficCost(calculateNetworkCost())
            .operationCost(calculateOperationCost())
            .timestamp(LocalDateTime.now())
            .build();
            
        log.info("æˆæœ¬æŠ¥å‘Š: å†…å­˜{}å…ƒ, ç½‘ç»œ{}å…ƒ, æ“ä½œ{}å…ƒ", 
                report.getMemoryUsageCost(), 
                report.getNetworkTrafficCost(), 
                report.getOperationCost());
    }
    
    private double calculateMemoryCost() {
        long memoryUsageGB = getMemoryUsageGB();
        return memoryUsageGB * 0.1; // å‡è®¾æ¯GBæ¯å°æ—¶0.1å…ƒ
    }
}
```

---

## 10. ğŸ”¥ çƒ­ç‚¹æ•°æ®å¤„ç†



### 10.1 çƒ­ç‚¹é—®é¢˜çš„æŒ‘æˆ˜



**ğŸ’¡ å•†åœºç±»æ¯”**
- **çƒ­é—¨å•†å“**ï¼šæ‰€æœ‰äººéƒ½æƒ³ä¹°ï¼Œåº—å‘˜å¿™ä¸è¿‡æ¥
- **å†·é—¨å•†å“**ï¼šæ— äººé—®æ´¥ï¼Œåº“å­˜ç§¯å‹

**âš ï¸ çƒ­ç‚¹æ•°æ®é—®é¢˜**
```
ç¼“å­˜é›ªå´©ï¼šçƒ­ç‚¹æ•°æ®åŒæ—¶å¤±æ•ˆï¼Œæ•°æ®åº“å‹åŠ›æ¿€å¢
ç¼“å­˜å‡»ç©¿ï¼šå•ä¸ªçƒ­ç‚¹æ•°æ®å¤±æ•ˆï¼Œç¬é—´å¤§é‡è¯·æ±‚ç©¿é€
ç¼“å­˜ç©¿é€ï¼šè¯·æ±‚ä¸å­˜åœ¨çš„æ•°æ®ï¼Œç¼“å­˜æ— æ³•æ‹¦æˆª
```

### 10.2 çƒ­ç‚¹è¯†åˆ«æœºåˆ¶



**ğŸ” å®æ—¶çƒ­ç‚¹ç›‘æ§**
```java
@Component
public class HotDataDetector {
    
    private final Map<String, AtomicLong> accessCounter = new ConcurrentHashMap<>();
    private final Set<String> hotKeys = ConcurrentHashMap.newKeySet();
    
    public void recordAccess(String key) {
        long currentCount = accessCounter.computeIfAbsent(key, 
            k -> new AtomicLong(0)).incrementAndGet();
        
        // 1åˆ†é’Ÿå†…è®¿é—®è¶…è¿‡100æ¬¡è®¤ä¸ºæ˜¯çƒ­ç‚¹
        if (currentCount > 100 && !hotKeys.contains(key)) {
            hotKeys.add(key);
            log.info("å‘ç°çƒ­ç‚¹æ•°æ®: {}, è®¿é—®æ¬¡æ•°: {}", key, currentCount);
            handleHotKey(key);
        }
    }
    
    private void handleHotKey(String key) {
        // å»¶é•¿çƒ­ç‚¹æ•°æ®çš„TTL
        cacheService.expire(key, Duration.ofHours(1));
        
        // é¢„çƒ­åˆ°å¤šä¸ªç¼“å­˜å±‚
        preloadToMultiLevel(key);
    }
    
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿé‡ç½®è®¡æ•°å™¨
    public void resetCounters() {
        accessCounter.clear();
        hotKeys.clear();
    }
}
```

### 10.3 çƒ­ç‚¹æ•°æ®ä¿æŠ¤



**ğŸ›¡ï¸ å¤šçº§ç¼“å­˜é˜²æŠ¤**
```java
@Service
public class HotDataProtectionService {
    
    @Autowired
    private CacheService l1Cache; // æœ¬åœ°ç¼“å­˜
    
    @Autowired  
    private CacheService l2Cache; // åˆ†å¸ƒå¼ç¼“å­˜
    
    public Object getWithProtection(String key) {
        // L1 æœ¬åœ°ç¼“å­˜
        Object value = l1Cache.get(key);
        if (value != null) {
            return value;
        }
        
        // L2 åˆ†å¸ƒå¼ç¼“å­˜
        value = l2Cache.get(key);
        if (value != null) {
            l1Cache.set(key, value, Duration.ofMinutes(5)); // çŸ­æœŸæœ¬åœ°ç¼“å­˜
            return value;
        }
        
        // æ•°æ®åº“æŸ¥è¯¢ï¼ˆåŠ é”é˜²æ­¢å¹¶å‘ç©¿é€ï¼‰
        return getWithLock(key);
    }
    
    private Object getWithLock(String key) {
        String lockKey = "lock:" + key;
        
        try {
            if (distributedLock.tryLock(lockKey, Duration.ofSeconds(3))) {
                Object value = loadFromDatabase(key);
                if (value != null) {
                    l2Cache.set(key, value, Duration.ofHours(1));
                    l1Cache.set(key, value, Duration.ofMinutes(5));
                }
                return value;
            } else {
                // è·å–é”å¤±è´¥ï¼Œè¿”å›é»˜è®¤å€¼æˆ–é‡è¯•
                return getDefaultValue(key);
            }
        } finally {
            distributedLock.unlock(lockKey);
        }
    }
}
```

---

## 11. â„ï¸ å†·æ•°æ®æ¸…ç†



### 11.1 å†·æ•°æ®çš„å½±å“



**ğŸ’¡ ä»“åº“ç±»æ¯”**
- **çƒ­é—¨è´§ç‰©**ï¼šæ”¾åœ¨å‰å°ï¼Œæ–¹ä¾¿å–ç”¨
- **å†·é—¨è´§ç‰©**ï¼šå ç”¨ä»“åº“ç©ºé—´ï¼Œå½±å“æ•ˆç‡

**ğŸ“‰ å†·æ•°æ®é—®é¢˜**
```
å†…å­˜æµªè´¹ï¼šå ç”¨å®è´µçš„ç¼“å­˜ç©ºé—´
æ€§èƒ½å½±å“ï¼šå¢åŠ æŸ¥æ‰¾æ—¶é—´
æˆæœ¬ä¸Šå‡ï¼šæ— æ•ˆæ•°æ®äº§ç”Ÿè´¹ç”¨
```

### 11.2 å†·æ•°æ®è¯†åˆ«



**ğŸ” è®¿é—®æ¨¡å¼åˆ†æ**
```java
@Component
public class ColdDataAnalyzer {
    
    private final Map<String, AccessPattern> accessPatterns = new ConcurrentHashMap<>();
    
    public void recordAccess(String key) {
        AccessPattern pattern = accessPatterns.computeIfAbsent(key, 
            k -> new AccessPattern());
        pattern.recordAccess();
    }
    
    @Scheduled(fixedRate = 3600000) // æ¯å°æ—¶åˆ†æä¸€æ¬¡
    public void analyzeColdData() {
        List<String> coldKeys = accessPatterns.entrySet().stream()
            .filter(entry -> entry.getValue().isCold())
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
            
        log.info("å‘ç°{}ä¸ªå†·æ•°æ®å¾…æ¸…ç†", coldKeys.size());
        cleanupColdData(coldKeys);
    }
    
    @Data
    public static class AccessPattern {
        private long lastAccessTime = System.currentTimeMillis();
        private int accessCount = 0;
        private long createTime = System.currentTimeMillis();
        
        public void recordAccess() {
            this.lastAccessTime = System.currentTimeMillis();
            this.accessCount++;
        }
        
        public boolean isCold() {
            long now = System.currentTimeMillis();
            long noAccessTime = now - lastAccessTime;
            
            // 1å°æ—¶æœªè®¿é—®ä¸”è®¿é—®æ¬¡æ•°å°‘äº5æ¬¡è®¤ä¸ºæ˜¯å†·æ•°æ®
            return noAccessTime > 3600000 && accessCount < 5;
        }
    }
}
```

### 11.3 æ™ºèƒ½æ¸…ç†ç­–ç•¥



**ğŸ§¹ åˆ†çº§æ¸…ç†æœºåˆ¶**
```java
@Service
public class SmartCleanupService {
    
    public void cleanupColdData(List<String> coldKeys) {
        coldKeys.forEach(key -> {
            CleanupDecision decision = makeCleanupDecision(key);
            
            switch (decision.getAction()) {
                case DELETE:
                    cacheService.delete(key);
                    log.info("åˆ é™¤å†·æ•°æ®: {}", key);
                    break;
                    
                case COMPRESS:
                    compressData(key);
                    log.info("å‹ç¼©å†·æ•°æ®: {}", key);
                    break;
                    
                case MIGRATE:
                    migrateToSlowStorage(key);
                    log.info("è¿ç§»å†·æ•°æ®: {}", key);
                    break;
                    
                case KEEP:
                    // æš‚æ—¶ä¿ç•™ï¼Œç¼©çŸ­TTL
                    cacheService.expire(key, Duration.ofMinutes(10));
                    break;
            }
        });
    }
    
    private CleanupDecision makeCleanupDecision(String key) {
        // æ ¹æ®æ•°æ®ç±»å‹ã€ä¸šåŠ¡ä»·å€¼ã€å­˜å‚¨æˆæœ¬ç­‰å› ç´ å†³å®šæ¸…ç†ç­–ç•¥
        if (isBusinessCritical(key)) {
            return CleanupDecision.KEEP;
        } else if (isLargeData(key)) {
            return CleanupDecision.COMPRESS;
        } else {
            return CleanupDecision.DELETE;
        }
    }
    
    enum CleanupAction { DELETE, COMPRESS, MIGRATE, KEEP }
    
    @Data
    @AllArgsConstructor
    public static class CleanupDecision {
        private CleanupAction action;
        private String reason;
        
        public static CleanupDecision KEEP = new CleanupDecision(CleanupAction.KEEP, "ä¸šåŠ¡å…³é”®æ•°æ®");
        public static CleanupDecision DELETE = new CleanupDecision(CleanupAction.DELETE, "å†·æ•°æ®åˆ é™¤");
        public static CleanupDecision COMPRESS = new CleanupDecision(CleanupAction.COMPRESS, "å¤§æ•°æ®å‹ç¼©");
    }
}
```

---

## 12. ğŸ“‹ æ ¸å¿ƒè¦ç‚¹æ€»ç»“



### 12.1 å¿…é¡»æŒæ¡çš„æ ¸å¿ƒæ¦‚å¿µ



```
ğŸ”¸ ç¼“å­˜ä¼˜åŒ–æœ¬è´¨ï¼šè®©"ä¸´æ—¶å­˜å‚¨"å‘æŒ¥æœ€å¤§ä»·å€¼
ğŸ”¸ æ•°æ®å‹ç¼©ï¼šç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œå‡å°‘70%ä¼ è¾“æˆæœ¬
ğŸ”¸ æ‰¹é‡æ“ä½œï¼šå‡å°‘ç½‘ç»œå¾€è¿”ï¼Œæ€§èƒ½æå‡20å€
ğŸ”¸ è¿æ¥æ± è°ƒä¼˜ï¼šåˆé€‚çš„è¿æ¥æ•°ï¼Œé¿å…èµ„æºæµªè´¹
ğŸ”¸ åºåˆ—åŒ–é€‰æ‹©ï¼šJSONé€šç”¨ï¼ŒKryoé«˜æ€§èƒ½ï¼ŒæŒ‰éœ€é€‰æ‹©
ğŸ”¸ åˆ†ç‰‡ç­–ç•¥ï¼šåˆ†æ•£è´Ÿè½½ï¼Œä¸€è‡´æ€§å“ˆå¸Œæ”¯æŒæ‰©å®¹
ğŸ”¸ é¢„åŠ è½½æœºåˆ¶ï¼šä¸»åŠ¨ç¼“å­˜çƒ­ç‚¹æ•°æ®ï¼Œæå‡å‘½ä¸­ç‡
ğŸ”¸ å®¹é‡è§„åˆ’ï¼šé¢„æµ‹éœ€æ±‚ï¼Œé¿å…èµ„æºä¸è¶³æˆ–æµªè´¹
ğŸ”¸ æˆæœ¬æ§åˆ¶ï¼šTTLä¼˜åŒ–ã€å†·çƒ­åˆ†ç¦»ï¼Œé™ä½è¿è¥æˆæœ¬
ğŸ”¸ çƒ­ç‚¹å¤„ç†ï¼šå¤šçº§ç¼“å­˜ã€åˆ†å¸ƒå¼é”ï¼Œé˜²æ­¢ç¼“å­˜å‡»ç©¿
ğŸ”¸ å†·æ•°æ®æ¸…ç†ï¼šæ™ºèƒ½è¯†åˆ«ï¼Œåˆ†çº§å¤„ç†ï¼Œé‡Šæ”¾ç©ºé—´
```

### 12.2 å…³é”®ç†è§£è¦ç‚¹



**ğŸ”¹ ä¼˜åŒ–çš„æœ¬è´¨æ˜¯å¹³è¡¡**
```
æ€§èƒ½ vs æˆæœ¬ï¼šé«˜æ€§èƒ½æ„å‘³ç€æ›´å¤šèµ„æºæŠ•å…¥
å¤æ‚åº¦ vs æ”¶ç›Šï¼šå¤æ‚æ–¹æ¡ˆè¦æœ‰æ˜¾è‘—æ•ˆæœ
å®æ—¶æ€§ vs ä¸€è‡´æ€§ï¼šç¼“å­˜ä¼˜åŒ–è¦æƒè¡¡æ•°æ®æ–°é²œåº¦
```

**ğŸ”¹ ä¼˜åŒ–è¦æœ‰æ•°æ®æ”¯æ’‘**
```
ç›‘æ§å…ˆè¡Œï¼šæ²¡æœ‰ç›‘æ§æ•°æ®ä¸è¦ç›²ç›®ä¼˜åŒ–
é€æ­¥ä¼˜åŒ–ï¼šä¸€æ¬¡æ”¹ä¸€ä¸ªåœ°æ–¹ï¼Œä¾¿äºå®šä½é—®é¢˜  
æ•ˆæœéªŒè¯ï¼šä¼˜åŒ–åè¦éªŒè¯æ˜¯å¦è¾¾åˆ°é¢„æœŸ
```

### 12.3 å®é™…åº”ç”¨ä»·å€¼



**ğŸ¯ ä¸šåŠ¡åœºæ™¯åº”ç”¨**
- **ç”µå•†ç³»ç»Ÿ**ï¼šå•†å“ç¼“å­˜å‹ç¼©ï¼Œçƒ­ç‚¹æ•°æ®å¤šçº§é˜²æŠ¤
- **ç¤¾äº¤å¹³å°**ï¼šç”¨æˆ·ä¿¡æ¯é¢„åŠ è½½ï¼Œå†·æ•°æ®æ™ºèƒ½æ¸…ç†
- **é‡‘èç³»ç»Ÿ**ï¼šäº¤æ˜“æ•°æ®åˆ†ç‰‡ï¼Œè¿æ¥æ± ç²¾ç¡®è°ƒä¼˜
- **å†…å®¹å¹³å°**ï¼šæ–‡ç« å†…å®¹å‹ç¼©ï¼Œè®¿é—®æ¨¡å¼åˆ†æ

### 12.4 ä¼˜åŒ–å®æ–½è·¯å¾„



**ğŸ“ˆ åˆ†é˜¶æ®µä¼˜åŒ–ç­–ç•¥**
```
ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ä¼˜åŒ–
- å¯ç”¨æ•°æ®å‹ç¼©
- è°ƒæ•´è¿æ¥æ± å‚æ•°
- å®ç°æ‰¹é‡æ“ä½œ

ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½ä¼˜åŒ–  
- å®æ–½é¢„åŠ è½½æœºåˆ¶
- é…ç½®åˆ†ç‰‡ç­–ç•¥
- ä¼˜åŒ–åºåˆ—åŒ–æ–¹æ¡ˆ

ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§ä¼˜åŒ–
- çƒ­ç‚¹æ•°æ®è¯†åˆ«
- å†·æ•°æ®æ™ºèƒ½æ¸…ç†  
- æˆæœ¬è‡ªåŠ¨æ§åˆ¶
```

### 12.5 å¸¸è§é—®é¢˜è§£å†³



**âŒ ä¼˜åŒ–é™·é˜±**
> **è¿‡åº¦ä¼˜åŒ–**ï¼šä¸ºäº†1%æ€§èƒ½æå‡å¼•å…¥å¤æ‚æ–¹æ¡ˆ
> 
> **å±€éƒ¨ä¼˜åŒ–**ï¼šåªä¼˜åŒ–æŸä¸ªç‚¹ï¼Œå¿½ç•¥æ•´ä½“æ€§èƒ½
> 
> **æ— æ•ˆä¼˜åŒ–**ï¼šä¼˜åŒ–éç“¶é¢ˆç‚¹ï¼Œæµªè´¹æ—¶é—´

**âœ… æ­£ç¡®åšæ³•**
> **æ‰¾å‡†ç“¶é¢ˆ**ï¼šå…ˆåˆ†æå“ªé‡Œæ˜¯æ€§èƒ½ç“¶é¢ˆ
> 
> **å¾ªåºæ¸è¿›**ï¼šä»ç®€å•ä¼˜åŒ–å¼€å§‹ï¼Œé€æ­¥æ·±å…¥
> 
> **æ•ˆæœé‡åŒ–**ï¼šç”¨æ•°æ®è¯æ˜ä¼˜åŒ–æ•ˆæœ

### 12.6 å­¦ä¹ æ£€æŸ¥æ¸…å•



**ğŸ“ çŸ¥è¯†æŒæ¡åº¦æ£€æŸ¥**
- [ ] èƒ½é€‰æ‹©åˆé€‚çš„å‹ç¼©ç®—æ³•
- [ ] ä¼šå®ç°Redisæ‰¹é‡æ“ä½œ
- [ ] ç†è§£è¿æ¥æ± å‚æ•°å«ä¹‰
- [ ] èƒ½å¯¹æ¯”ä¸åŒåºåˆ—åŒ–æ–¹æ¡ˆ
- [ ] æŒæ¡ä¸€è‡´æ€§å“ˆå¸ŒåŸç†
- [ ] ä¼šè®¾è®¡é¢„åŠ è½½ç­–ç•¥
- [ ] èƒ½è¿›è¡Œå®¹é‡è§„åˆ’è®¡ç®—
- [ ] ç†è§£æˆæœ¬æ§åˆ¶æ‰‹æ®µ
- [ ] ä¼šè¯†åˆ«å’Œå¤„ç†çƒ­ç‚¹æ•°æ®
- [ ] èƒ½è®¾è®¡å†·æ•°æ®æ¸…ç†æ–¹æ¡ˆ

**ğŸ”‘ æ ¸å¿ƒè®°å¿†å£è¯€**
> å‹ç¼©æ‰¹é‡è¿æ¥æ± ï¼Œåºåˆ—åˆ†ç‰‡é¢„åŠ è½½  
> å®¹é‡æˆæœ¬çƒ­ç‚¹å†·ï¼Œç›‘æ§ä¼˜åŒ–æ­¥æ­¥é«˜

**ğŸ’¡ è¿›é˜¶å­¦ä¹ æ–¹å‘**
- å­¦ä¹ ç¼“å­˜è®¾è®¡æ¨¡å¼ï¼ˆCache-Asideã€Write-Throughç­‰ï¼‰
- ç ”ç©¶åˆ†å¸ƒå¼ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜
- äº†è§£ç¼“å­˜åœ¨å¾®æœåŠ¡æ¶æ„ä¸­çš„æœ€ä½³å®è·µ