---
title: 4、服务发现集成
---
## 📚 目录

1. [服务发现基础概念](#1-服务发现基础概念)
2. [Eureka注册中心集成](#2-Eureka注册中心集成)
3. [Nacos服务发现集成](#3-Nacos服务发现集成)
4. [Consul服务发现集成](#4-Consul服务发现集成)
5. [自动路由生成机制](#5-自动路由生成机制)
6. [服务实例负载均衡](#6-服务实例负载均衡)
7. [健康检查机制](#7-健康检查机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 服务发现基础概念


### 1.1 什么是服务发现


**通俗理解**：想象你要寄快递，以前需要记住收件人的详细地址，现在只需要告诉快递员"寄给张三"，快递系统会自动查找张三的最新地址。服务发现就是微服务世界里的"地址簿"。

```
传统方式（硬编码IP）：
网关 → 直接访问 192.168.1.100:8081（订单服务）
问题：IP变了，代码要改；服务器坏了，系统崩溃

服务发现方式：
网关 → 查询"order-service"在哪 → 注册中心返回健康的IP → 访问服务
优势：IP可以随便换，服务器坏了自动切换
```

**🔸 核心价值**
- **动态感知**：服务上线下线自动感知，不需要人工配置
- **自动路由**：网关自动知道去哪找服务，不用写死IP地址
- **负载均衡**：多个服务实例自动分配流量
- **故障隔离**：坏掉的服务自动剔除，不影响正常访问

### 1.2 服务发现的工作流程


**📋 完整流程图示**
```
第1步：服务启动注册
┌──────────────┐
│ 订单服务启动  │
│ IP: 10.0.1.5 │
└──────┬───────┘
       │ 注册自己
       ↓
┌──────────────────┐
│   注册中心       │
│ order-service:   │
│ - 10.0.1.5:8081 │
│ - 10.0.1.6:8081 │
└──────────────────┘

第2步：网关发现服务
┌──────────┐
│ API网关  │
└────┬─────┘
     │ 查询order-service在哪？
     ↓
┌──────────────────┐
│   注册中心       │
│ 返回可用实例列表  │
└──────┬───────────┘
       │
       ↓
   [10.0.1.5:8081, 10.0.1.6:8081]

第3步：负载均衡访问
┌──────────┐                    ┌──────────────┐
│ API网关  │ ───第1次请求───→   │ 10.0.1.5:8081│
└──────────┘                    └──────────────┘
     │
     └──────第2次请求───→   ┌──────────────┐
                            │ 10.0.1.6:8081│
                            └──────────────┘
```

**💡 关键理解**
- **服务注册**：服务启动时告诉注册中心"我上线了，地址是XXX"
- **服务发现**：网关需要访问服务时问注册中心"XXX服务在哪？"
- **健康检查**：注册中心定期检查服务是否还活着
- **自动摘除**：服务挂了自动从列表中移除

---

## 2. 🔷 Eureka注册中心集成


### 2.1 Eureka是什么


**通俗比喻**：Eureka就像小区的门卫，所有住户（服务）搬进来要登记，外卖员（网关）来送餐时问门卫"XX住户在几号楼"，门卫查登记表告诉他。

**🔸 Eureka特点**
- **AP模型**：保证可用性，允许短暂数据不一致
- **自我保护**：网络抖动时不会立即剔除服务
- **多级缓存**：客户端有缓存，速度快
- **心跳机制**：每30秒发一次心跳确认存活

### 2.2 Eureka集成配置


**📦 第1步：添加依赖**
```xml
<!-- 网关添加Eureka客户端依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

**⚙️ 第2步：配置文件**
```yaml
spring:
  application:
    name: api-gateway  # 网关自己的名字
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true  # 开启服务发现路由
          lower-case-service-id: true  # 服务名小写匹配

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # 注册中心地址
    fetch-registry: true  # 拉取服务列表
    register-with-eureka: true  # 自己也注册进去
  instance:
    prefer-ip-address: true  # 使用IP而不是主机名
    instance-id: ${spring.application.name}:${server.port}
```

**🔑 配置说明**

| 配置项 | 作用 | 新手建议 |
|-------|------|---------|
| `enabled: true` | 启用服务发现路由 | 必须开启 |
| `lower-case-service-id` | 服务名转小写 | 建议true，避免大小写问题 |
| `defaultZone` | 注册中心地址 | 改成实际的Eureka地址 |
| `prefer-ip-address` | 用IP注册 | 建议true，避免DNS问题 |

### 2.3 自动路由规则


**🎯 Eureka自动生成的路由规则**
```
假设Eureka中有服务：
- order-service（订单服务）
- user-service（用户服务）
- product-service（产品服务）

自动生成的访问路径：
http://网关地址/order-service/**   → 转发到订单服务
http://网关地址/user-service/**    → 转发到用户服务
http://网关地址/product-service/** → 转发到产品服务

实际例子：
请求：http://localhost:8080/order-service/api/orders/123
转发：http://10.0.1.5:8081/api/orders/123
     (自动找到order-service的实例)
```

**⚠️ 注意事项**
> **新手常见误区**：以为配置完就能用了，但忘记启动Eureka Server！
> 
> 正确步骤：
> 1️⃣ 先启动Eureka Server（注册中心）
> 2️⃣ 再启动微服务（会自动注册）
> 3️⃣ 最后启动网关（会拉取服务列表）

### 2.4 手动配置路由（推荐）


虽然可以自动路由，但实际项目中更推荐手动配置，更灵活：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-route
          uri: lb://order-service  # lb代表LoadBalancer负载均衡
          predicates:
            - Path=/api/orders/**
          filters:
            - StripPrefix=1  # 去掉/api前缀
```

**💡 工作原理**
```
1. 请求进来：GET http://网关/api/orders/123
2. 匹配规则：Path=/api/orders/** 匹配成功
3. 查询Eureka：lb://order-service 是什么？
4. 获取实例：[10.0.1.5:8081, 10.0.1.6:8081]
5. 负载均衡：选择 10.0.1.5:8081
6. 转发请求：GET http://10.0.1.5:8081/orders/123
   (StripPrefix=1 去掉了/api)
```

---

## 3. 🟦 Nacos服务发现集成


### 3.1 Nacos是什么


**通俗比喻**：如果Eureka是传统的纸质登记本，Nacos就是智能化的物业管理系统，不仅能登记住户，还能管理配置、发通知、分组管理。

**🔸 Nacos优势**
- **配置管理**：不仅做服务发现，还能统一管理配置
- **命名空间**：可以按环境隔离（开发/测试/生产）
- **权重配置**：可以给服务实例设置权重
- **更好的UI**：界面更现代化，操作更友好

**对比一览**

| 特性 | Eureka | Nacos | 新手建议 |
|-----|--------|-------|---------|
| 配置管理 | ❌ | ✅ | Nacos更全能 |
| 环境隔离 | ❌ | ✅ | Nacos更方便 |
| 学习成本 | ⭐⭐ | ⭐⭐⭐ | Eureka更简单 |
| 社区支持 | 🟡停止更新 | 🟢活跃 | Nacos是趋势 |

### 3.2 Nacos集成配置


**📦 第1步：添加依赖**
```xml
<!-- 使用Nacos服务发现 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

**⚙️ 第2步：配置文件**
```yaml
spring:
  application:
    name: api-gateway
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848  # Nacos服务器地址
        namespace: dev  # 命名空间（环境隔离）
        group: DEFAULT_GROUP  # 分组
        username: nacos  # 如果开启了认证
        password: nacos
    gateway:
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
```

**🔑 配置说明**

**命名空间（Namespace）**
```
作用：环境隔离，不同环境的服务互不干扰

实际场景：
开发环境(dev)：    localhost:8848?namespace=dev
测试环境(test)：   localhost:8848?namespace=test  
生产环境(prod)：   localhost:8848?namespace=prod

好处：
- 开发环境调试不影响测试
- 测试环境验证不影响生产
- 一套Nacos服务多环境共用
```

**分组（Group）**
```
作用：业务隔离，同一环境下的业务分类

实际场景：
DEFAULT_GROUP：   默认分组
ORDER_GROUP：     订单相关服务
USER_GROUP：      用户相关服务
PAYMENT_GROUP：   支付相关服务

好处：
- 相同业务的服务分组管理
- 方便批量操作和监控
- 降低服务发现的范围
```

### 3.3 Nacos路由配置


**🎯 基础路由**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-nacos
          uri: lb://order-service  # lb前缀表示从Nacos获取
          predicates:
            - Path=/order/**
```

**🎯 高级路由（带命名空间和分组）**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-prod
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          metadata:
            nacos:
              namespace: prod  # 指定从生产环境获取
              group: ORDER_GROUP  # 指定从订单分组获取
```

**💡 工作流程**
```
用户请求
   ↓
http://网关/api/orders/123
   ↓
匹配路由规则 Path=/api/orders/**
   ↓
查询Nacos：在prod命名空间的ORDER_GROUP中找order-service
   ↓
Nacos返回：[
  {ip: "10.0.1.5", port: 8081, weight: 2},
  {ip: "10.0.1.6", port: 8081, weight: 1}
]
   ↓
按权重负载均衡（2:1比例）
   ↓
转发请求到选中的实例
```

### 3.4 Nacos控制台操作


**📊 服务列表查看**
```
访问：http://localhost:8848/nacos
登录：nacos/nacos

服务列表界面：
┌─────────────────────────────────────────┐
│ 命名空间：dev        分组：DEFAULT_GROUP │
├─────────────────────────────────────────┤
│ 服务名          实例数   健康实例   操作  │
│ order-service    2        2        详情  │
│ user-service     3        3        详情  │
│ api-gateway      1        1        详情  │
└─────────────────────────────────────────┘

点击详情可以看到：
- 每个实例的IP和端口
- 健康状态（UP/DOWN）
- 权重值
- 元数据信息
```

---

## 4. 🟨 Consul服务发现集成


### 4.1 Consul是什么


**通俗比喻**：Consul像一个功能强大的社区管理系统，不仅记录住户信息，还能健康检查、分布式锁、KV存储，是个全能选手。

**🔸 Consul特点**
- **多数据中心**：天然支持跨机房部署
- **强一致性**：使用Raft协议保证数据一致
- **健康检查丰富**：支持HTTP、TCP、脚本等多种检查方式
- **开箱即用**：单个二进制文件，安装简单

**🆚 三者对比**

| 对比项 | Eureka | Nacos | Consul |
|-------|--------|-------|--------|
| **一致性** | AP（可用性优先） | AP/CP可选 | CP（一致性优先） |
| **健康检查** | 心跳 | 心跳+HTTP | 心跳+HTTP+TCP+脚本 |
| **多数据中心** | ❌ | ❌ | ✅ |
| **配置管理** | ❌ | ✅ | ✅(KV存储) |
| **界面** | 简单 | 现代化 | 现代化 |
| **学习曲线** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |

### 4.2 Consul集成配置


**📦 第1步：安装Consul**
```bash
# 下载Consul（以Windows为例）
# 访问：https://www.consul.io/downloads
# 下载后解压，运行：

consul agent -dev
# -dev表示开发模式，生产环境需要更多配置
```

**📦 第2步：添加依赖**
```xml
<!-- Spring Cloud Consul -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
```

**⚙️ 第3步：配置文件**
```yaml
spring:
  application:
    name: api-gateway
  cloud:
    consul:
      host: localhost
      port: 8500  # Consul默认端口
      discovery:
        service-name: ${spring.application.name}
        health-check-path: /actuator/health  # 健康检查路径
        health-check-interval: 10s  # 检查间隔
        instance-id: ${spring.application.name}:${server.port}
        prefer-ip-address: true
    gateway:
      discovery:
        locator:
          enabled: true
```

**🔑 健康检查配置详解**

| 配置项 | 作用 | 推荐值 | 说明 |
|-------|------|--------|------|
| `health-check-path` | 检查的URL路径 | `/actuator/health` | 需要actuator依赖 |
| `health-check-interval` | 检查间隔 | `10s` | 太短影响性能，太长不及时 |
| `health-check-timeout` | 超时时间 | `3s` | 超时视为不健康 |
| `health-check-critical-timeout` | 临界超时 | `30s` | 超过后自动注销服务 |

### 4.3 Consul路由配置


**🎯 基础路由**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-consul
          uri: lb://order-service  # 从Consul获取
          predicates:
            - Path=/orders/**
```

**🎯 带健康检查的路由**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: payment-consul
          uri: lb://payment-service
          predicates:
            - Path=/payment/**
          filters:
            - name: CircuitBreaker
              args:
                name: paymentBreaker
                fallbackUri: forward:/fallback/payment
```

**💡 Consul工作流程**
```
服务注册阶段：
订单服务启动
   ↓
向Consul注册：POST http://localhost:8500/v1/agent/service/register
   {
     "Name": "order-service",
     "Address": "10.0.1.5",
     "Port": 8081,
     "Check": {
       "HTTP": "http://10.0.1.5:8081/actuator/health",
       "Interval": "10s"
     }
   }
   ↓
Consul每10秒检查一次健康状态
   ↓
健康：标记为passing
不健康：标记为critical，30秒后注销

网关查询阶段：
请求到达网关
   ↓
查询Consul：GET http://localhost:8500/v1/health/service/order-service?passing=true
   ↓
只返回健康的实例
   ↓
负载均衡选择实例
   ↓
转发请求
```

### 4.4 Consul UI操作


**📊 控制台查看**
```
访问：http://localhost:8500/ui

服务视图：
┌────────────────────────────────────────┐
│ Services                               │
├────────────────────────────────────────┤
│ ✅ order-service        (2 instances)  │
│    ├─ 10.0.1.5:8081   passing         │
│    └─ 10.0.1.6:8081   passing         │
│                                        │
│ ⚠️  payment-service     (2 instances)  │
│    ├─ 10.0.2.5:8082   passing         │
│    └─ 10.0.2.6:8082   critical ⚠️      │
│                                        │
│ ✅ api-gateway         (1 instance)    │
│    └─ 10.0.0.1:8080   passing         │
└────────────────────────────────────────┘

可以看到：
- 每个服务的实例数量
- 健康状态（passing/critical）
- 实例的IP和端口
- 健康检查的详细信息
```

---

## 5. 🔄 自动路由生成机制


### 5.1 自动路由原理


**通俗理解**：就像手机的"自动拨号"功能，你只要说出名字，系统自动帮你找到电话号码并拨出去。

**🔸 工作机制**
```
启用自动路由配置：
spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true  # 开启自动路由
          lower-case-service-id: true

自动生成规则：
注册中心有服务：order-service, user-service, payment-service

自动生成路由：
http://网关/order-service/**   → order-service
http://网关/user-service/**    → user-service
http://网关/payment-service/** → payment-service

访问示例：
GET http://localhost:8080/order-service/api/orders/1
         ↓
自动转发到：http://订单服务实例IP:端口/api/orders/1
```

### 5.2 路径重写规则


**默认规则的问题**
```
问题：服务名会保留在路径中

原始请求：GET /order-service/api/orders/1
转发请求：GET /order-service/api/orders/1
         （路径完全一样）

实际服务接口：GET /api/orders/1
             （不需要/order-service前缀）

结果：404 Not Found ❌
```

**解决方案：路径重写**
```yaml
spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
          filters:
            - StripPrefix=1  # 去掉第一段路径
```

**💡 重写效果**
```
请求：GET /order-service/api/orders/1
     ↓
StripPrefix=1去掉第一段
     ↓
转发：GET /api/orders/1 ✅
```

### 5.3 自动路由 vs 手动路由


**对比分析**

| 方式 | 优点 | 缺点 | 适用场景 |
|-----|------|------|---------|
| **自动路由** | 配置简单<br>服务上线自动可用 | 不够灵活<br>路径固定 | 内部服务<br>统一规范的API |
| **手动路由** | 高度灵活<br>可以自定义规则 | 配置繁琐<br>需要维护 | 对外API<br>复杂路由规则 |

**🎯 最佳实践（混合使用）**
```yaml
spring:
  cloud:
    gateway:
      # 关闭全局自动路由
      discovery:
        locator:
          enabled: false
      
      # 手动配置需要暴露的路由
      routes:
        # 对外API：精细控制
        - id: public-order-api
          uri: lb://order-service
          predicates:
            - Path=/api/v1/orders/**
          filters:
            - StripPrefix=2  # 去掉/api/v1
            - name: RequestRateLimiter  # 限流
              args:
                redis-rate-limiter.replenishRate: 10
        
        # 内部API：简单转发
        - id: internal-order
          uri: lb://order-service
          predicates:
            - Path=/internal/order/**
          filters:
            - StripPrefix=1
```

---

## 6. ⚖️ 服务实例负载均衡


### 6.1 负载均衡基础


**通俗比喻**：就像超市有多个收银台，客户自动分流到不同收银台结账，避免都挤在一个窗口。

**🔸 为什么需要负载均衡**
```
单实例问题：
┌──────┐
│ 网关 │──→ ┌────────────┐
└──────┘    │ 订单服务   │ ← 压力大，容易崩溃
            │ 10.0.1.5   │
            └────────────┘

多实例+负载均衡：
┌──────┐    ┌────────────┐
│ 网关 │──→ │ 订单服务-1 │ ← 分担压力
└──────┘    │ 10.0.1.5   │
      │     └────────────┘
      │
      └───→ ┌────────────┐
            │ 订单服务-2 │ ← 分担压力
            │ 10.0.1.6   │
            └────────────┘
```

### 6.2 负载均衡算法


**🔹 轮询（Round Robin）- 最简单**
```
原理：按顺序依次分配请求

实例列表：[A, B, C]
第1次请求 → A
第2次请求 → B
第3次请求 → C
第4次请求 → A （循环）

特点：
✅ 简单公平
❌ 不考虑服务器性能差异

适用：实例性能相近的场景
```

**🔹 随机（Random）- 随机分配**
```
原理：随机选择一个实例

实例列表：[A, B, C]
第1次请求 → B （随机）
第2次请求 → A （随机）
第3次请求 → B （随机）

特点：
✅ 实现简单
✅ 请求量大时趋于均衡
❌ 请求量小时可能不均

适用：高并发场景
```

**🔹 加权轮询（Weighted Round Robin）- 按性能分配**
```
原理：根据权重比例分配请求

实例配置：
A: weight=3 (高性能服务器)
B: weight=2 (中性能服务器)
C: weight=1 (低性能服务器)

分配效果（6次请求）：
请求1 → A
请求2 → A
请求3 → A
请求4 → B
请求5 → B
请求6 → C

比例：A:B:C = 3:2:1

适用：服务器性能有差异的场景
```

**🔹 最小连接（Least Connections）- 智能分配**
```
原理：选择当前连接数最少的实例

当前状态：
A: 5个连接
B: 3个连接 ← 选择B
C: 8个连接

新请求到来：选择B（连接数最少）

特点：
✅ 动态平衡负载
✅ 适合长连接场景
❌ 需要维护连接状态

适用：WebSocket、数据库连接等
```

### 6.3 配置负载均衡策略


**🔧 全局配置（推荐）**
```yaml
spring:
  cloud:
    loadbalancer:
      ribbon:
        enabled: false  # 禁用旧的Ribbon
      configurations: default
      
# 配置默认策略
order-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    # 可选值：
    # RoundRobinRule: 轮询
    # RandomRule: 随机
    # WeightedResponseTimeRule: 响应时间加权
    # BestAvailableRule: 最小并发
```

**🔧 使用Spring Cloud LoadBalancer（新）**
```yaml
spring:
  cloud:
    loadbalancer:
      cache:
        enabled: true  # 启用缓存
        ttl: 35  # 缓存时间（秒）
```

**🔧 代码自定义策略**
```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> customLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory factory) {
        
        String name = environment.getProperty(
            LoadBalancerClientFactory.PROPERTY_NAME
        );
        
        // 使用轮询策略
        return new RoundRobinLoadBalancer(
            factory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

### 6.4 Nacos权重负载均衡


**🎯 Nacos特有功能：权重配置**
```yaml
spring:
  cloud:
    nacos:
      discovery:
        weight: 2  # 当前实例的权重
```

**💡 实际应用场景**
```
新版本灰度发布：
旧版本实例：weight=9 （90%流量）
新版本实例：weight=1 （10%流量）

观察一段时间后：
旧版本实例：weight=5 （50%流量）
新版本实例：weight=5 （50%流量）

完全切换后：
旧版本实例：weight=0 （0%流量，准备下线）
新版本实例：weight=10（100%流量）
```

**🔧 Nacos控制台动态调整**
```
在Nacos UI中可以实时调整权重：
1. 进入服务详情页
2. 找到具体实例
3. 点击"编辑"
4. 修改权重值（0-10000）
5. 保存即可生效（无需重启）

实时生效，非常方便！
```

---

## 7. 💚 健康检查机制


### 7.1 为什么需要健康检查


**通俗比喻**：就像公司每天的考勤打卡，迟到或请假的员工不会被分配任务，确保任务都交给能干活的人。

**❌ 没有健康检查的问题**
```
场景：订单服务的一个实例挂了

网关不知道：
请求1 → 实例A（正常）✅
请求2 → 实例B（已挂）❌ 报错！
请求3 → 实例A（正常）✅
请求4 → 实例B（已挂）❌ 又报错！

结果：50%的请求失败，用户体验极差
```

**✅ 有健康检查**
```
场景：订单服务的实例B挂了

健康检查发现：
检查实例A → 200 OK ✅ 标记健康
检查实例B → 超时 ❌ 标记不健康

网关只选健康实例：
请求1 → 实例A（正常）✅
请求2 → 实例A（正常）✅
请求3 → 实例A（正常）✅

结果：0%失败率，自动绕过故障实例
```

### 7.2 健康检查类型


**🔹 心跳检查（Heartbeat）**
```
原理：服务定期发送"我还活着"的信号

实现：
服务每30秒发送心跳 → 注册中心
┌────────┐  心跳  ┌────────────┐
│ 服务   │ ────→ │ 注册中心   │
└────────┘       └────────────┘
   30秒           记录最后心跳时间

90秒没收到心跳：标记为不健康

优点：
✅ 简单高效
✅ 注册中心压力小

缺点：
❌ 只能检测网络，不能检测业务
❌ 可能服务卡死但心跳还在发
```

**🔹 HTTP健康检查（推荐）**
```
原理：定期HTTP请求检查接口

注册中心主动检查：
每10秒：GET http://服务IP:端口/actuator/health

服务返回：
{
  "status": "UP",
  "components": {
    "db": {"status": "UP"},
    "redis": {"status": "UP"}
  }
}

优点：
✅ 可以检测业务健康状态
✅ 可以检测依赖（数据库、Redis等）

缺点：
❌ 注册中心压力较大
❌ 需要服务提供检查接口
```

**🔹 TCP端口检查**
```
原理：检查服务端口是否可连接

每10秒：telnet 服务IP 端口
端口通：健康 ✅
端口不通：不健康 ❌

优点：
✅ 最基础的存活检查
✅ 无需服务配合

缺点：
❌ 端口通不代表服务正常
❌ 无法检测业务逻辑
```

### 7.3 配置健康检查


**🔧 Eureka健康检查**
```yaml
eureka:
  instance:
    lease-renewal-interval-in-seconds: 30  # 心跳间隔
    lease-expiration-duration-in-seconds: 90  # 90秒没心跳就剔除
  client:
    healthcheck:
      enabled: true  # 启用健康检查

# 需要添加actuator依赖
management:
  endpoints:
    web:
      exposure:
        include: health  # 暴露健康检查端点
  endpoint:
    health:
      show-details: always  # 显示详细信息
```

**🔧 Nacos健康检查**
```yaml
spring:
  cloud:
    nacos:
      discovery:
        heart-beat-interval: 5000  # 心跳间隔5秒
        heart-beat-timeout: 15000  # 15秒超时
        ip-delete-timeout: 30000   # 30秒后删除
        
        # HTTP健康检查配置
        metadata:
          preserved.heart.beat.interval: 5000
          preserved.heart.beat.timeout: 15000
          preserved.ip.delete.timeout: 30000
```

**🔧 Consul健康检查（最灵活）**
```yaml
spring:
  cloud:
    consul:
      discovery:
        # HTTP检查
        health-check-path: /actuator/health
        health-check-interval: 10s
        health-check-timeout: 3s
        health-check-critical-timeout: 30s
        
        # TCP检查（可选）
        health-check-tcp: true
        
        # 脚本检查（高级）
        health-check-script: /usr/local/bin/check.sh
```

### 7.4 自定义健康检查


**💡 场景：检查数据库连接**
```java
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try {
            // 尝试获取数据库连接
            Connection conn = dataSource.getConnection();
            conn.close();
            
            return Health.up()
                .withDetail("database", "MySQL")
                .withDetail("status", "连接正常")
                .build();
                
        } catch (Exception e) {
            return Health.down()
                .withDetail("database", "MySQL")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

**健康检查返回值**
```json
GET /actuator/health

响应（健康）：
{
  "status": "UP",
  "components": {
    "database": {
      "status": "UP",
      "details": {
        "database": "MySQL",
        "status": "连接正常"
      }
    }
  }
}

响应（不健康）：
{
  "status": "DOWN",
  "components": {
    "database": {
      "status": "DOWN",
      "details": {
        "database": "MySQL",
        "error": "Connection timeout"
      }
    }
  }
}
```

**🔸 健康检查级联**
```
网关的健康状态取决于：
├─ 自身状态（UP）
├─ 数据库连接（UP）
├─ Redis连接（UP）
└─ 注册中心连接（UP）

任何一个DOWN：
整体状态 → DOWN
注册中心标记为不健康
网关实例不再接收流量
```

### 7.5 健康检查监控


**📊 监控指标**
```
Nacos控制台显示：
┌──────────────────────────────────┐
│ 服务：order-service              │
├──────────────────────────────────┤
│ 实例           健康状态   最后心跳 │
│ 10.0.1.5:8081  ✅健康    2秒前   │
│ 10.0.1.6:8081  ⚠️不健康  65秒前  │
│ 10.0.1.7:8081  ✅健康    1秒前   │
└──────────────────────────────────┘

健康实例：2个
不健康实例：1个
总实例数：3个
```

**⚠️ 告警配置**
```yaml
# 配合监控系统（如Prometheus）
management:
  metrics:
    export:
      prometheus:
        enabled: true

# 当健康实例数 < 总实例数的50%时告警
# 自动发送邮件/钉钉/企业微信通知
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


**🔸 服务发现三剑客对比**

| 特性 | Eureka | Nacos | Consul | 新手建议 |
|-----|--------|-------|--------|---------|
| **难度** | ⭐⭐ 简单 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐ 较难 | Eureka入门 |
| **功能** | 服务发现 | 服务发现+配置 | 全能型 | Nacos实用 |
| **维护** | 停止更新 | 活跃 | 活跃 | 选新不选旧 |
| **适用** | 简单项目 | 中小项目 | 大型项目 | 按需选择 |

**🔸 关键理解要点**

```
1️⃣ 服务注册：
服务启动 → 告诉注册中心"我来了"
就像新员工入职登记

2️⃣ 服务发现：
网关需要时 → 问注册中心"服务在哪"
就像查找通讯录

3️⃣ 健康检查：
注册中心定期 → 检查服务是否健康
就像定期体检

4️⃣ 负载均衡：
多个实例时 → 分配流量到不同实例
就像排队分流
```

### 8.2 配置要点速查


**🚀 快速配置清单**

**Eureka配置**
```yaml
✅ 依赖：spring-cloud-starter-netflix-eureka-client
✅ 核心配置：
  eureka.client.service-url.defaultZone
  spring.cloud.gateway.discovery.locator.enabled
```

**Nacos配置**
```yaml
✅ 依赖：spring-cloud-starter-alibaba-nacos-discovery
✅ 核心配置：
  spring.cloud.nacos.discovery.server-addr
  spring.cloud.nacos.discovery.namespace
  spring.cloud.nacos.discovery.group
```

**Consul配置**
```yaml
✅ 依赖：spring-cloud-starter-consul-discovery
✅ 核心配置：
  spring.cloud.consul.host
  spring.cloud.consul.discovery.health-check-path
  spring.cloud.consul.discovery.health-check-interval
```

### 8.3 常见问题速查


**❓ 问题1：服务注册成功但网关找不到**
```
排查步骤：
1️⃣ 检查网关配置：enabled: true 是否开启
2️⃣ 检查服务名大小写：建议全小写
3️⃣ 检查命名空间/分组：是否一致
4️⃣ 查看注册中心：服务是否真的注册上
```

**❓ 问题2：负载均衡不生效，总是访问同一个实例**
```
排查步骤：
1️⃣ 检查是否多个实例：注册中心查看实例数
2️⃣ 检查uri配置：必须是 lb://服务名
3️⃣ 检查负载均衡策略：是否配置正确
4️⃣ 检查实例权重：Nacos权重是否都为0
```

**❓ 问题3：健康检查一直失败**
```
排查步骤：
1️⃣ 检查健康检查路径：/actuator/health是否可访问
2️⃣ 检查actuator依赖：是否添加spring-boot-starter-actuator
3️⃣ 检查端点暴露：management.endpoints.web.exposure.include
4️⃣ 检查防火墙：健康检查端口是否开放
```

### 8.4 最佳实践建议


**🎯 新手建议路线**
```
学习路线：
第1周：Eureka基础
  ├─ 搭建Eureka Server
  ├─ 服务注册与发现
  └─ 简单的网关路由

第2周：Nacos进阶  
  ├─ Nacos安装部署
  ├─ 命名空间和分组
  └─ 配置管理（额外收获）

第3周：实战优化
  ├─ 负载均衡策略
  ├─ 健康检查配置
  └─ 生产环境优化
```

**🏢 生产环境建议**
```
配置规范：
✅ 关闭自动路由，改用手动配置（更可控）
✅ 配置健康检查，及时发现故障
✅ 设置合理的超时时间（心跳30s，过期90s）
✅ 多机房部署，配置多数据中心
✅ 监控告警，及时发现问题

安全建议：
⚠️ 注册中心开启认证
⚠️ 使用HTTPS传输
⚠️ 限制网关访问注册中心的权限
⚠️ 定期备份注册中心数据
```

### 8.5 学习建议


**📚 知识巩固**
- [ ] 能说出三种注册中心的区别
- [ ] 能独立搭建Eureka环境
- [ ] 能配置服务发现路由
- [ ] 理解lb://前缀的作用
- [ ] 能配置健康检查
- [ ] 了解至少2种负载均衡算法

**💻 动手实践**
```
1. 搭建Eureka Server
2. 创建2个微服务注册到Eureka
3. 配置网关，实现服务发现路由
4. 配置负载均衡，验证效果
5. 配置健康检查，模拟服务故障
6. 切换到Nacos，重复上述步骤
```

**🔥 核心记忆**
> 💡 **记忆口诀**
> 
> *"服务发现像通讯录，注册登记要清楚；*  
> *Eureka简单适合学，Nacos全能更实用；*  
> *lb前缀别忘加，负载均衡自动发；*  
> *健康检查要配好，故障服务自动跳。"*

---

**恭喜你！🎉** 完成了服务发现集成的学习，你已经掌握了微服务网关的核心能力之一。现在你可以让网关自动发现服务，智能分配流量，就像一个聪明的交通指挥官！