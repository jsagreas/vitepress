---
title: 3、路由断言Predicates
---
## 📚 目录

1. [什么是路由断言](#1-什么是路由断言)
2. [Path路径断言匹配](#2-path路径断言匹配)
3. [Host主机名断言](#3-host主机名断言)
4. [Method请求方法断言](#4-method请求方法断言)
5. [Header请求头断言](#5-header请求头断言)
6. [Cookie参数断言](#6-cookie参数断言)
7. [Query查询参数断言](#7-query查询参数断言)
8. [RemoteAddr远程地址断言](#8-remoteaddr远程地址断言)
9. [Weight权重断言](#9-weight权重断言)
10. [自定义断言实现](#10-自定义断言实现)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 什么是路由断言


### 1.1 断言的本质含义


> **通俗理解**：路由断言就像是网关的"门卫规则"，用来判断一个请求是否符合条件，决定这个请求能不能通过。

**生活中的类比**：
```
就像进入商场的安检门：
- 检查是否携带危险物品 → 断言规则
- 符合条件就放行 → 断言通过，执行路由
- 不符合就拦截 → 断言失败，拒绝请求

API网关的断言也是同样的道理！
```

### 1.2 断言的工作机制


**核心流程**：
```
客户端发送请求
    ↓
网关接收请求
    ↓
【执行断言判断】← 这是我们要学的重点
    ↓
符合条件？
  ├─ 是 → 转发到目标服务
  └─ 否 → 返回404或其他错误
```

### 1.3 为什么需要断言


**实际应用价值**：
- 🎯 **精准路由**：根据不同条件，把请求分发到不同的服务
- 🔐 **访问控制**：限制某些请求只能从特定来源访问
- ⚖️ **负载均衡**：通过权重分配流量到不同服务实例
- 🔄 **灰度发布**：让部分用户访问新版本，其他用户访问旧版本

---

## 2. 🛤️ Path路径断言匹配


### 2.1 什么是Path断言


**核心概念**：根据请求的URL路径来判断是否匹配路由规则。

**通俗解释**：
```
就像快递分拣：
- 地址写"北京市"的 → 送到北京分拣中心
- 地址写"上海市"的 → 送到上海分拣中心

API网关也是这样：
- 路径是/user/** 的 → 转发到用户服务
- 路径是/order/** 的 → 转发到订单服务
```

### 2.2 路径匹配规则


**支持的匹配模式**：

| 模式 | 含义 | 示例 | 实际匹配 |
|------|------|------|----------|
| **精确匹配** | 路径完全一致 | `/user/info` | 只匹配 `/user/info` |
| **前缀匹配** | 路径前缀符合 | `/user/**` | `/user/list`、`/user/add` 都匹配 |
| **路径变量** | 动态参数匹配 | `/user/{id}` | `/user/123`、`/user/456` |
| **多段匹配** | 多层路径 | `/api/**/detail` | `/api/user/detail`、`/api/order/user/detail` |

### 2.3 配置示例


**YAML配置方式**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-route
          uri: lb://user-service
          predicates:
            - Path=/user/**  # 所有/user开头的请求都转发到用户服务
```

**Java代码配置**：
```java
@Bean
public RouteLocator userRoutes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("user-route", r -> r
            .path("/user/**")  // 路径断言
            .uri("lb://user-service")
        )
        .build();
}
```

### 2.4 实际应用场景


**场景1：微服务按模块分发**
```
用户相关请求：   /user/**     → user-service
订单相关请求：   /order/**    → order-service
商品相关请求：   /product/**  → product-service
```

**场景2：API版本控制**
```
旧版本API：  /api/v1/**  → old-service
新版本API：  /api/v2/**  → new-service
```

---

## 3. 🌐 Host主机名断言


### 3.1 Host断言的作用


**核心概念**：根据请求的域名(Host)来判断路由规则。

**通俗理解**：
```
就像多个网站共用一个服务器：
- 访问 www.taobao.com → 跳转到淘宝页面
- 访问 www.tmall.com  → 跳转到天猫页面

同一个网关，不同域名访问不同的服务！
```

### 3.2 匹配规则说明


**支持的配置格式**：

| 格式 | 说明 | 示例 | 匹配结果 |
|------|------|------|----------|
| **精确域名** | 完整域名匹配 | `www.example.com` | 只匹配该域名 |
| **通配符** | 支持*匹配 | `*.example.com` | 匹配所有子域名 |
| **多域名** | 逗号分隔 | `{sub1,sub2}.example.com` | 匹配sub1和sub2 |
| **端口匹配** | 包含端口号 | `www.example.com:8080` | 匹配指定端口 |

### 3.3 配置方式


```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: host-route
          uri: lb://service-a
          predicates:
            - Host=**.example.com  # 所有example.com的子域名
```

### 3.4 实际应用场景


**场景：多租户系统**
```
租户A访问：  tenant-a.saas.com  → 路由到租户A的服务实例
租户B访问：  tenant-b.saas.com  → 路由到租户B的服务实例
管理后台：   admin.saas.com     → 路由到管理服务
```

**场景：环境隔离**
```
开发环境：  dev.api.com   → 开发环境服务
测试环境：  test.api.com  → 测试环境服务
生产环境：  www.api.com   → 生产环境服务
```

---

## 4. 🔧 Method请求方法断言


### 4.1 Method断言含义


**核心概念**：根据HTTP请求方法(GET/POST/PUT/DELETE等)来匹配路由。

**通俗解释**：
```
HTTP方法就像对数据的操作类型：
- GET    → 查询数据（就像"看"）
- POST   → 新增数据（就像"写"）
- PUT    → 修改数据（就像"改"）
- DELETE → 删除数据（就像"删"）

网关可以根据这些操作类型，分发到不同的服务！
```

### 4.2 常用HTTP方法


| 方法 | 含义 | 常见用途 | 是否幂等 |
|------|------|----------|----------|
| **GET** | 获取资源 | 查询数据、获取列表 | ✅ 是 |
| **POST** | 创建资源 | 新增数据、提交表单 | ❌ 否 |
| **PUT** | 更新资源 | 修改数据（全量更新） | ✅ 是 |
| **DELETE** | 删除资源 | 删除数据 | ✅ 是 |
| **PATCH** | 部分更新 | 修改部分字段 | ❌ 否 |

> 💡 **幂等性含义**：多次执行同一个操作，结果都一样，就叫幂等。比如删除同一条数据多次，结果都是数据被删除。

### 4.3 配置示例


```yaml
spring:
  cloud:
    gateway:
      routes:
        # 只处理GET请求
        - id: query-route
          uri: lb://query-service
          predicates:
            - Method=GET
            
        # 只处理POST请求
        - id: add-route
          uri: lb://write-service
          predicates:
            - Method=POST
```

### 4.4 实际应用场景


**场景：读写分离**
```
读操作(GET)     → 查询服务集群（只读数据库）
写操作(POST/PUT/DELETE) → 写入服务集群（主数据库）
```

**场景：安全控制**
```
GET请求  → 不需要认证，直接放行
POST请求 → 需要登录认证后才能访问
```

---

## 5. 📋 Header请求头断言


### 5.1 Header断言的用途


**核心概念**：根据HTTP请求头的内容来判断是否匹配路由。

**什么是请求头**：
```
HTTP请求头就像快递包裹上的标签信息：
- 发件人信息 → User-Agent（浏览器信息）
- 包裹类型   → Content-Type（内容类型）
- 授权凭证   → Authorization（认证信息）

网关可以读取这些"标签"，决定如何处理请求！
```

### 5.2 常见请求头说明


| 请求头 | 含义 | 示例值 | 用途 |
|--------|------|--------|------|
| **User-Agent** | 客户端类型 | `Mozilla/5.0...` | 识别浏览器/APP |
| **Authorization** | 认证信息 | `Bearer token123` | 身份验证 |
| **Content-Type** | 内容类型 | `application/json` | 数据格式 |
| **X-Request-Id** | 请求标识 | `abc-123-def` | 链路追踪 |
| **API-Version** | API版本 | `v1`/`v2` | 版本控制 |

### 5.3 配置方式


**基础配置**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: header-route
          uri: lb://service-a
          predicates:
            # 必须包含X-Request-Id请求头
            - Header=X-Request-Id, \d+  # \d+表示纯数字
```

**正则表达式匹配**：
```yaml
predicates:
  # 匹配特定版本的API
  - Header=API-Version, v[1-2]  # 匹配v1或v2
  
  # 匹配JWT Token格式
  - Header=Authorization, Bearer.*
```

### 5.4 实际应用场景


**场景1：移动端和PC端分流**
```
User-Agent包含"Mobile" → 移动端服务
User-Agent包含"PC"     → PC端服务
```

**场景2：灰度发布（金丝雀发布）**
```
请求头包含 X-Gray=true → 新版本服务
其他请求              → 旧版本服务
```

**场景3：API版本路由**
```
API-Version: v1  → 旧版API服务
API-Version: v2  → 新版API服务
```

---

## 6. 🍪 Cookie参数断言


### 6.1 Cookie断言说明


**核心概念**：根据Cookie中的键值对来判断路由匹配。

**Cookie是什么**：
```
Cookie就像你在网站的"会员卡"：
- 第一次访问网站 → 网站给你发一张"卡"（设置Cookie）
- 以后每次访问   → 你带着这张"卡"（浏览器自动发送Cookie）
- 网站识别你     → 根据"卡"上的信息识别你是谁

常见用途：
- 保存登录状态（记住你是谁）
- 保存购物车信息
- 记录用户偏好设置
```

### 6.2 Cookie断言配置


**基本格式**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: cookie-route
          uri: lb://service-a
          predicates:
            # Cookie名称=值的正则表达式
            - Cookie=sessionId, [a-z0-9]+
```

**实际配置示例**：
```yaml
predicates:
  # 判断是否是VIP用户
  - Cookie=userLevel, vip
  
  # 判断语言偏好
  - Cookie=language, (zh|en)  # 中文或英文
  
  # 判断是否已登录
  - Cookie=isLogin, true
```

### 6.3 应用场景


**场景1：用户分级服务**
```
VIP用户（Cookie: level=vip）     → 高性能服务器
普通用户（Cookie: level=normal） → 普通服务器
```

**场景2：A/B测试**
```
实验组（Cookie: experiment=A） → 新功能版本
对照组（Cookie: experiment=B） → 旧版本
```

**场景3：多语言路由**
```
中文用户（Cookie: lang=zh） → 中文服务
英文用户（Cookie: lang=en） → 英文服务
```

---

## 7. 🔍 Query查询参数断言


### 7.1 Query断言概念


**核心概念**：根据URL中的查询参数来匹配路由。

**查询参数是什么**：
```
URL结构示例：
https://api.com/search?keyword=手机&price=5000

查询参数就是"?"后面的内容：
- keyword=手机  → 第一个参数
- price=5000   → 第二个参数（用&连接）

通俗理解：
就像在餐厅点餐时的"备注要求"
- 不要香菜 → 查询参数
- 少放辣   → 查询参数
```

### 7.2 配置方式


**基本格式**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: query-route
          uri: lb://service-a
          predicates:
            # 参数名, 参数值正则表达式（可选）
            - Query=token  # 只要有token参数就匹配
```

**带值匹配**：
```yaml
predicates:
  # 必须有source参数且值为mobile
  - Query=source, mobile
  
  # version参数值必须是数字
  - Query=version, \d+
  
  # debug参数值必须是true或false
  - Query=debug, (true|false)
```

### 7.3 实际应用


**场景1：来源渠道分流**
```
URL: /api/data?source=app     → APP专用服务
URL: /api/data?source=web     → Web专用服务
URL: /api/data?source=miniapp → 小程序服务
```

**场景2：调试模式**
```
URL: /api/data?debug=true  → 开启详细日志的服务
URL: /api/data（无debug）   → 正常服务
```

**场景3：版本选择**
```
URL: /api/data?v=1  → API v1版本
URL: /api/data?v=2  → API v2版本
```

---

## 8. 🌍 RemoteAddr远程地址断言


### 8.1 RemoteAddr断言作用


**核心概念**：根据客户端的IP地址来判断路由匹配。

**通俗解释**：
```
IP地址就像你家的门牌号：
- 北京市朝阳区xxx号 → IP: 192.168.1.100
- 上海市浦东区xxx号 → IP: 192.168.2.100

网关可以根据"门牌号"（IP地址），决定如何处理请求：
- 内网IP → 允许访问管理功能
- 外网IP → 只能访问公开功能
```

### 8.2 IP地址格式说明


**支持的配置格式**：

| 格式 | 说明 | 示例 | 匹配范围 |
|------|------|------|----------|
| **单个IP** | 精确匹配 | `192.168.1.1` | 只匹配这个IP |
| **CIDR格式** | 网段匹配 | `192.168.1.0/24` | 192.168.1.0~255 |
| **多IP** | 逗号分隔 | `192.168.1.1, 192.168.1.2` | 匹配多个IP |

> 💡 **CIDR是什么**：`/24`表示前24位是网络地址，后8位是主机地址。`192.168.1.0/24`表示192.168.1.0到192.168.1.255这256个IP。

### 8.3 配置示例


```yaml
spring:
  cloud:
    gateway:
      routes:
        # 内网访问路由
        - id: internal-route
          uri: lb://admin-service
          predicates:
            - RemoteAddr=192.168.1.0/24  # 内网网段
            
        # 白名单IP访问
        - id: whitelist-route
          uri: lb://vip-service
          predicates:
            - RemoteAddr=10.0.0.1, 10.0.0.2, 10.0.0.3
```

### 8.4 实际应用场景


**场景1：内外网隔离**
```
内网IP（192.168.0.0/16） → 访问管理后台、内部API
外网IP                   → 只能访问公开API
```

**场景2：地域分流**
```
国内IP    → 国内服务器（速度快）
海外IP    → 海外服务器（符合当地法规）
```

**场景3：安全防护**
```
黑名单IP   → 直接拒绝访问
白名单IP   → 允许访问敏感功能
其他IP     → 正常访问公开功能
```

---

## 9. ⚖️ Weight权重断言


### 9.1 Weight断言的意义


**核心概念**：根据设置的权重比例，将流量按比例分配到不同的服务。

**生活中的类比**：
```
就像分蛋糕：
- A组分70%的蛋糕
- B组分30%的蛋糕

流量分配也是一样：
- 70%的请求 → 旧版本服务
- 30%的请求 → 新版本服务
```

### 9.2 权重配置格式


**基本语法**：`Weight=组名, 权重值`

```yaml
spring:
  cloud:
    gateway:
      routes:
        # 旧版本服务 - 70%流量
        - id: service-v1
          uri: lb://service-v1
          predicates:
            - Weight=version-group, 70
            
        # 新版本服务 - 30%流量  
        - id: service-v2
          uri: lb://service-v2
          predicates:
            - Weight=version-group, 30
```

> ⚠️ **注意**：同一组的权重会按比例计算，上面的配置实际是70:30的比例

### 9.3 权重计算规则


**计算方式**：
```
假设配置：
路由A：Weight=group1, 7
路由B：Weight=group1, 3

实际流量分配：
路由A：7/(7+3) = 70%
路由B：3/(7+3) = 30%

每10个请求：
- 7个请求 → 路由A
- 3个请求 → 路由B
```

### 9.4 实际应用场景


**场景1：灰度发布（金丝雀发布）**
```
初期：新版本5%，旧版本95%  → 观察新版本表现
中期：新版本30%，旧版本70% → 逐步扩大范围
后期：新版本100%           → 全面上线
```

**场景2：AB测试**
```
A方案：50%流量 → 测试方案A的效果
B方案：50%流量 → 测试方案B的效果
根据数据选择更优方案
```

**场景3：服务降级**
```
正常情况：  主服务100%
异常情况：  主服务0%，备用服务100%
恢复阶段：  逐步增加主服务权重
```

---

## 10. 🛠️ 自定义断言实现


### 10.1 为什么需要自定义断言


**实际需求场景**：
```
内置断言覆盖不了的情况：
- 根据请求时间段路由（工作日/周末）
- 根据用户等级路由（普通/VIP/SVIP）
- 根据业务规则路由（促销活动期间）
- 复杂的组合判断逻辑
```

### 10.2 自定义断言的实现步骤


**实现流程图**：
```
第1步：创建配置类
   ↓
第2步：创建断言工厂类
   ↓
第3步：实现断言逻辑
   ↓
第4步：配置使用
```

### 10.3 代码实现示例


**步骤1：定义配置类**
```java
// 配置类：定义断言需要的参数
public class TimeRangeConfig {
    private String startTime;  // 开始时间
    private String endTime;    // 结束时间
    
    // getter和setter省略...
}
```

**步骤2：创建断言工厂**
```java
@Component
public class TimeRangeRoutePredicateFactory 
    extends AbstractRoutePredicateFactory<TimeRangeConfig> {
    
    public TimeRangeRoutePredicateFactory() {
        super(TimeRangeConfig.class);
    }
    
    @Override
    public Predicate<ServerWebExchange> apply(TimeRangeConfig config) {
        return exchange -> {
            // 获取当前时间
            LocalTime now = LocalTime.now();
            LocalTime start = LocalTime.parse(config.getStartTime());
            LocalTime end = LocalTime.parse(config.getEndTime());
            
            // 判断当前时间是否在范围内
            return now.isAfter(start) && now.isBefore(end);
        };
    }
}
```

**步骤3：YAML配置使用**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: time-route
          uri: lb://day-service
          predicates:
            # 使用自定义断言（去掉RoutePredicateFactory后缀）
            - TimeRange=09:00, 18:00  # 工作时间路由
```

### 10.4 实际应用案例


**案例1：工作时间路由**
```java
// 工作日白天 → 正式服务器（高性能）
// 夜间/周末  → 值班服务器（低成本）
```

**案例2：用户等级路由**
```java
// VIP用户   → 专属服务器（低延迟）
// 普通用户  → 共享服务器（标准服务）
```

**案例3：地域限流**
```java
// 某地区访问量过大 → 限制访问
// 其他地区正常    → 正常路由
```

### 10.5 自定义断言最佳实践


**开发建议** ⭐⭐⭐：
- ✅ 命名规范：必须以`RoutePredicateFactory`结尾
- ✅ 继承基类：继承`AbstractRoutePredicateFactory`
- ✅ 性能考虑：断言逻辑要简单高效，避免耗时操作
- ✅ 异常处理：做好异常处理，防止断言失败影响整体服务

**常见错误** ⚠️：
- ❌ 断言逻辑太复杂，影响网关性能
- ❌ 没有处理null值，导致空指针异常
- ❌ 命名不规范，Spring无法识别
- ❌ 配置参数类型不匹配

---

## 11. 📋 核心要点总结


### 11.1 各断言类型对比


| 断言类型 | 主要用途 | 典型场景 | 重要程度 |
|---------|---------|---------|---------|
| **Path** | 路径匹配 | 按模块分发请求 | ⭐⭐⭐ 必会 |
| **Host** | 域名匹配 | 多租户、环境隔离 | ⭐⭐ 常用 |
| **Method** | 请求方法 | 读写分离、安全控制 | ⭐⭐⭐ 必会 |
| **Header** | 请求头匹配 | 版本控制、灰度发布 | ⭐⭐⭐ 必会 |
| **Cookie** | Cookie匹配 | 用户分级、A/B测试 | ⭐⭐ 常用 |
| **Query** | 参数匹配 | 渠道分流、调试模式 | ⭐⭐ 常用 |
| **RemoteAddr** | IP匹配 | 安全控制、地域分流 | ⭐⭐ 常用 |
| **Weight** | 权重分配 | 灰度发布、负载均衡 | ⭐⭐⭐ 必会 |
| **自定义** | 特殊需求 | 业务定制逻辑 | ⭐ 了解 |

### 11.2 断言组合使用


**多个断言的逻辑关系**：
```yaml
predicates:
  - Path=/api/**
  - Method=GET
  - Header=Authorization
  
# 这些断言是"与"的关系（AND）
# 意思是：必须同时满足所有条件才匹配
```

**组合应用示例**：
```yaml
# 场景：VIP用户的移动端API访问
predicates:
  - Path=/api/vip/**           # 路径必须是VIP接口
  - Header=User-Agent, .*Mobile.*  # 必须是移动端
  - Cookie=level, vip          # 必须是VIP用户
  - Method=GET                 # 只允许查询操作
```

### 11.3 实际使用建议


**选择断言的思路** 🤔：

**第1步：明确需求**
```
要解决什么问题？
- 按模块分发     → 用Path
- 按用户类型分发 → 用Cookie或Header
- 按来源渠道分发 → 用Query或Header
- 流量控制       → 用Weight
```

**第2步：考虑性能**
```
断言的执行顺序：
- 简单断言放前面（Path、Method）
- 复杂断言放后面（自定义断言）
- 早失败早返回，提高效率
```

**第3步：保证可维护性**
```
- 配置要清晰，加注释说明
- 避免过于复杂的组合
- 定期review和优化规则
```

### 11.4 常见问题解答


**Q1：断言都不匹配会怎样？**
```
A：返回404 Not Found错误
建议：配置一个默认路由兜底
```

**Q2：多个路由都匹配怎么办？**
```
A：按配置顺序，匹配第一个
建议：把更具体的规则放前面
```

**Q3：断言失败会有日志吗？**
```
A：需要开启DEBUG日志：
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
```

### 11.5 学习检查清单


**基础掌握** ✅：
- [ ] 理解断言的作用和工作原理
- [ ] 掌握Path、Method、Header三大核心断言
- [ ] 能独立配置基本的路由规则
- [ ] 理解断言组合的逻辑关系

**进阶应用** ✅：
- [ ] 掌握Weight权重断言实现灰度发布
- [ ] 理解Cookie和Query断言的应用场景
- [ ] 能根据业务需求选择合适的断言
- [ ] 了解自定义断言的实现方式

**实战能力** ✅：
- [ ] 能设计完整的路由规则方案
- [ ] 能解决路由冲突和优先级问题
- [ ] 能进行性能优化和故障排查
- [ ] 能应对复杂的业务路由需求

---

**核心记忆口诀** 🎯：
```
路由断言像门卫，判断请求能不能过
Path路径最常用，Method方法要记牢
Header头部很灵活，Cookie参数也重要
Weight权重做灰度，自定义满足特殊需求
```