---
title: 3、调试技巧工具
---
## 📚 目录

1. [日志分析方法](#1-日志分析方法)
2. [调试模式配置](#2-调试模式配置)
3. [网络抓包分析](#3-网络抓包分析)
4. [JVM性能分析](#4-jvm性能分析)
5. [火焰图分析](#5-火焰图分析)
6. [压力测试工具](#6-压力测试工具)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 📋 日志分析方法


### 1.1 日志的本质理解


> 💡 **什么是日志？**  
> 日志就像是程序的"行车记录仪"，记录了程序运行过程中发生的所有重要事件。通过看日志，我们能知道程序在什么时候做了什么事，有没有出错。

**日志的作用：**
- ✅ **问题定位**：出错时能快速找到原因
- ✅ **行为追踪**：了解请求的完整处理流程
- ✅ **性能监控**：发现哪些操作耗时长
- ✅ **安全审计**：记录谁在什么时候做了什么

### 1.2 日志级别详解


```
日志级别从低到高：
TRACE → DEBUG → INFO → WARN → ERROR

理解方式：
├─ TRACE：最详细的追踪信息（开发调试用）
├─ DEBUG：调试信息（开发环境用）
├─ INFO：普通信息（生产环境默认级别）
├─ WARN：警告信息（可能有问题但不影响运行）
└─ ERROR：错误信息（必须关注的问题）
```

**如何选择日志级别？**

| 级别 | **使用场景** | **示例** | **生产环境** |
|------|------------|---------|-------------|
| `ERROR` | 业务处理失败、系统异常 | `订单创建失败`、`数据库连接断开` | ✅ 必须开启 |
| `WARN` | 潜在问题、降级处理 | `缓存未命中`、`使用降级方案` | ✅ 建议开启 |
| `INFO` | 关键业务节点 | `用户登录成功`、`订单已创建` | ✅ 默认开启 |
| `DEBUG` | 详细调试信息 | `参数值`、`中间结果` | ❌ 关闭 |
| `TRACE` | 最详细追踪 | `方法进入退出` | ❌ 关闭 |

### 1.3 网关日志配置实战


**Spring Cloud Gateway配置示例：**

```yaml
# application.yml

logging:
  level:
#    # 网关核心日志
    org.springframework.cloud.gateway: INFO
#    # 路由匹配日志（调试时开启）
    org.springframework.cloud.gateway.handler.RoutePredicateHandlerMapping: DEBUG
#    # 过滤器执行日志
    org.springframework.cloud.gateway.handler.FilteringWebHandler: DEBUG
  
#  # 日志输出格式
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  
#  # 日志文件配置
  file:
    name: logs/gateway.log
    max-size: 100MB
    max-history: 30
```

**Logback配置文件（logback-spring.xml）：**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/gateway.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/gateway-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%X{traceId}] %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 根日志配置 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

### 1.4 日志分析技巧


**技巧1：追踪请求链路**

> 🔍 **问题**：一个请求经过网关、多个微服务，如何追踪完整链路？  
> **解决**：使用TraceId（追踪ID）贯穿整个请求

```
用户请求 → 网关 → 用户服务 → 订单服务
  ↓          ↓        ↓          ↓
[traceId: abc123] 贯穿所有日志
```

**添加TraceId过滤器：**

```java
@Component
public class TraceIdFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 生成或获取TraceId
        String traceId = exchange.getRequest().getHeaders()
            .getFirst("X-Trace-Id");
        
        if (traceId == null) {
            traceId = UUID.randomUUID().toString();
        }
        
        // 添加到请求头，传递给下游服务
        ServerHttpRequest request = exchange.getRequest().mutate()
            .header("X-Trace-Id", traceId)
            .build();
        
        // 记录请求日志
        log.info("[{}] Request: {} {}", traceId, 
            request.getMethod(), request.getURI());
        
        return chain.filter(exchange.mutate().request(request).build());
    }
    
    @Override
    public int getOrder() {
        return -100; // 优先级最高
    }
}
```

**技巧2：快速定位错误**

```bash
# 查看最近的错误日志

tail -f gateway.log | grep ERROR

# 查找特定TraceId的所有日志

grep "abc123" gateway.log

# 统计错误类型分布

grep ERROR gateway.log | awk '{print $NF}' | sort | uniq -c
```

**技巧3：性能问题分析**

```
分析思路：
1. 找出慢请求日志
2. 查看每个环节耗时
3. 定位性能瓶颈

示例日志：
[abc123] Request: GET /api/orders
[abc123] Route matched: order-service (5ms)
[abc123] Auth filter: 50ms
[abc123] Rate limit: 2ms
[abc123] Forward to service: 300ms  ← 这里耗时最长！
[abc123] Response: 200 OK (Total: 357ms)
```

---

## 2. 🔧 调试模式配置


### 2.1 什么是调试模式


> 💡 **调试模式**就像给程序装了"透视眼镜"，让我们能看到程序内部的运行细节，方便找问题。

**调试模式 vs 普通模式：**

```
普通模式：                调试模式：
程序跑得飞快              可以暂停查看
看不到内部细节            能看到变量值
出错只能猜                能一步步跟踪
```

### 2.2 IDEA远程调试网关


**第一步：网关启动时开启调试端口**

```bash
# 添加JVM参数启动网关

java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 \
     -jar gateway.jar
```

**参数说明：**
- `transport=dt_socket`：使用Socket方式通信
- `server=y`：网关作为调试服务端
- `suspend=n`：启动时不暂停（改成y会等待调试器连接）
- `address=5005`：调试端口号

**第二步：IDEA配置远程调试**

```
IDEA操作步骤：
1. Run → Edit Configurations
2. 点击 + 号 → Remote JVM Debug
3. 配置：
   - Name: Gateway Debug
   - Host: localhost (或服务器IP)
   - Port: 5005
4. 点击 Debug 按钮启动调试
```

**第三步：设置断点调试**

```java
@Component
public class AuthFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = exchange.getRequest().getHeaders().getFirst("Authorization");
        
        // 在这里打断点 ← 点击行号左侧
        if (token == null) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        return chain.filter(exchange);
    }
}
```

**调试技巧：**

| 功能 | **快捷键** | **作用** |
|------|-----------|---------|
| 继续执行 | `F9` | 运行到下一个断点 |
| 单步执行 | `F8` | 执行下一行代码 |
| 步入方法 | `F7` | 进入方法内部 |
| 查看变量 | `鼠标悬停` | 查看变量当前值 |
| 执行表达式 | `Alt+F8` | 临时执行代码 |

### 2.3 开启Gateway详细日志


**方式1：配置文件开启**

```yaml
# application.yml

logging:
  level:
    reactor.netty: DEBUG  # 查看网络通信细节
    org.springframework.cloud.gateway: TRACE  # 网关所有细节
    
spring:
  cloud:
    gateway:
#      # 开启路由定义日志
      routes[0]:
        id: test-route
        uri: http://localhost:8080
        predicates:
          - Path=/api/**
        metadata:
#          # 打印路由详情
          response-timeout: 3000
```

**方式2：Actuator监控端点**

```yaml
# 开启网关监控端点

management:
  endpoints:
    web:
      exposure:
        include: gateway  # 暴露网关端点
  endpoint:
    gateway:
      enabled: true
```

**查看网关信息：**

```bash
# 查看所有路由

curl http://localhost:8080/actuator/gateway/routes

# 查看路由详情

curl http://localhost:8080/actuator/gateway/routes/test-route

# 刷新路由缓存

curl -X POST http://localhost:8080/actuator/gateway/refresh
```

---

## 3. 🌐 网络抓包分析


### 3.1 为什么需要抓包


> 💡 **网络抓包**就像是"监听电话"，能看到网关和后端服务之间到底传输了什么数据。

**常见场景：**
- ❓ 请求发出去了吗？
- ❓ 请求参数对不对？
- ❓ 响应内容是什么？
- ❓ 是哪一步出了问题？

### 3.2 Wireshark抓包实战


**抓包流程图：**

```
用户 → 网关 → 后端服务
  ↓      ↓        ↓
[Wireshark 监听所有网络通信]
```

**第一步：启动Wireshark**

```
操作步骤：
1. 打开Wireshark
2. 选择网卡（通常是以太网或WiFi）
3. 点击"开始捕获"按钮
```

**第二步：设置过滤条件**

```
常用过滤器：

# 只看HTTP请求

http

# 只看特定端口

tcp.port == 8080

# 只看特定IP

ip.addr == 192.168.1.100

# 组合条件

http and tcp.port == 8080
```

**第三步：分析请求响应**

```
抓包结果示例：

请求包：
GET /api/user/1 HTTP/1.1
Host: localhost:8080
Authorization: Bearer xxx
X-Trace-Id: abc123

响应包：
HTTP/1.1 200 OK
Content-Type: application/json
{"id":1,"name":"张三"}
```

**关键信息检查点：**
- ✅ 请求方法和路径是否正确
- ✅ 请求头是否完整（特别是认证信息）
- ✅ 请求体数据是否正确
- ✅ 响应状态码
- ✅ 响应时间

### 3.3 Postman抓包调试


**Postman自带抓包功能：**

```
开启步骤：
1. 打开Postman
2. 左下角 Console 按钮
3. 发送请求
4. 查看详细日志
```

**日志显示内容：**

```
→ Request Headers:
  GET http://localhost:8080/api/user/1
  Authorization: Bearer token123
  X-Custom-Header: value

→ Request Body: (none)

← Response Headers:
  HTTP/1.1 200 OK
  Content-Type: application/json
  X-Response-Time: 45ms

← Response Body:
  {"id":1,"name":"张三"}

⏱ Timeline:
  DNS Lookup: 2ms
  TCP Handshake: 3ms
  Request Sent: 1ms
  Waiting: 40ms
  Content Download: 2ms
  Total: 48ms
```

### 3.4 Charles代理抓包


> 🔍 **Charles**就像是"中间人"，帮你拦截和查看所有HTTP请求。

**配置步骤：**

```
1. 安装Charles
2. 配置系统代理（自动）
3. 信任Charles证书（HTTPS抓包必需）
4. 开始抓包
```

**查看网关请求：**

```
Charles显示：

┌─ 请求树 ─────────────────┐
│ ▼ localhost:8080         │
│   ▼ /api/user/1          │
│     • Overview（概览）    │
│     • Request（请求）     │
│     • Response（响应）    │
│     • Summary（总结）     │
└──────────────────────────┘

可以看到：
• 完整的请求响应
• 耗时分布
• 请求头/响应头
• Cookie变化
```

---

## 4. 🔥 JVM性能分析


### 4.1 JVM性能问题表现


> ⚠️ **性能问题症状：**
> - 响应变慢
> - CPU占用高
> - 内存不断增长
> - 频繁Full GC

**问题诊断思路：**

```
问题表现 → 指标分析 → 找到原因 → 解决问题
    ↓
CPU高？内存高？GC频繁？
```

### 4.2 JConsole基础监控


**启动JConsole：**

```bash
# 方式1：直接启动

jconsole

# 方式2：连接远程JVM

jconsole <hostname>:9999
```

**JConsole监控面板：**

```
┌─ 概览 ────────────────────────┐
│ • 堆内存使用：1.2GB / 2GB     │
│ • 线程数：45                  │
│ • 类加载：8000个              │
│ • CPU使用：35%                │
└───────────────────────────────┘

┌─ 内存监控 ────────────────────┐
│  Eden  ████░░░░  60%          │
│  Old   ████████  80%  ← 注意  │
│  Metaspace ████  40%          │
└───────────────────────────────┘
```

**关键指标解读：**

| 指标 | **正常值** | **异常值** | **可能原因** |
|------|-----------|-----------|-------------|
| 堆内存 | < 80% | > 90% | 内存泄漏 |
| Old区 | < 70% | > 85% | 对象晋升过多 |
| GC次数 | 偶尔触发 | 频繁触发 | 内存不足 |
| 线程数 | 稳定 | 持续增长 | 线程泄漏 |

### 4.3 VisualVM深度分析


**VisualVM功能：**

```
功能模块：
├─ 监控：实时查看CPU、内存、线程
├─ 线程：查看线程状态、死锁检测
├─ 采样器：分析方法调用耗时
└─ 堆转储：分析内存占用详情
```

**实战案例：定位内存泄漏**

```
步骤：
1. VisualVM连接网关进程
2. 触发内存泄漏操作
3. 生成堆转储（Heap Dump）
4. 分析对象占用

结果示例：
┌─ 对象统计 ─────────────────┐
│ Class               Count  │
│ HashMap             50000  │← 异常多
│ ArrayList           30000  │
│ String              25000  │
└────────────────────────────┘

定位到：
某个缓存Map无限增长，没有清理机制
```

### 4.4 Arthas在线诊断


> 🎯 **Arthas**是阿里开源的Java诊断工具，可以在不停机的情况下诊断问题。

**启动Arthas：**

```bash
# 下载启动

wget https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar

# 选择网关进程

[1] 12345 gateway.jar
选择：1
```

**常用诊断命令：**

```bash
# 查看JVM信息

dashboard

# 查看最耗CPU的线程

thread -n 3

# 反编译查看代码

jad com.example.gateway.filter.AuthFilter

# 查看方法调用耗时

trace com.example.gateway.filter.AuthFilter filter

# 监控方法调用

watch com.example.gateway.filter.AuthFilter filter "{params,returnObj}"
```

**实时监控示例：**

```
dashboard显示：
┌─ 线程信息 ──────────────────────────┐
│ ID  NAME              CPU%  TIME    │
│ 1   main              0.5%  0.5s    │
│ 15  http-nio-8080-20  35%   15.2s   │← CPU高
└─────────────────────────────────────┘

查看该线程在干什么：
thread 15

结果：
正在执行：AuthFilter.validateToken()
卡在：网络请求等待响应
```

---

## 5. 🔥 火焰图分析


### 5.1 什么是火焰图


> 💡 **火焰图**就像是程序的"热力图"，颜色越热（越宽）的地方，表示该方法执行时间越长。

**火焰图结构：**

```
宽度 = 执行时间占比
高度 = 调用栈深度

      ┌────────────────────────┐  ← 最顶层（业务代码）
      │  AuthFilter.filter()   │
      ├────────────┬───────────┤
      │ validate() │ forward() │  ← 中间层（逻辑调用）
      ├─────┬──────┼─────┬─────┤
      │ JWT │ HTTP │ I/O │ ... │  ← 底层（框架代码）
      └─────┴──────┴─────┴─────┘

越宽 = 越耗时  ← 重点关注
```

### 5.2 生成火焰图


**方式1：使用async-profiler**

```bash
# 下载工具

wget https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-x64.tar.gz
tar -xzf async-profiler-2.9-linux-x64.tar.gz

# 开始采样（30秒）

./profiler.sh -d 30 -f flamegraph.html <PID>

# 在浏览器打开 flamegraph.html

```

**方式2：使用Arthas**

```bash
# Arthas内置火焰图

profiler start

# 运行一段时间后停止

profiler stop --format html
```

### 5.3 火焰图分析实战


**案例：网关响应慢分析**

```
火焰图显示：

                ┌─────────────────────────────┐
                │  GatewayFilter.filter()     │  100%
                └─────────────────────────────┘
                         ↓
      ┌──────────────────────────────────────┐
      │         AuthFilter.filter()          │  60%  ← 占比最大
      └──────────────────────────────────────┘
               ↓                ↓
    ┌──────────────┐    ┌─────────────┐
    │ validateJWT  │    │ redisQuery  │  40%  ← 重点优化
    └──────────────┘    └─────────────┘
          20%

分析结论：
• AuthFilter耗时60%
• 其中Redis查询占40%
• JWT验证占20%

优化方案：
✅ 添加JWT本地缓存
✅ 使用Redis管道批量查询
✅ 考虑异步验证
```

**常见性能问题定位：**

| 火焰图表现 | **问题类型** | **解决方案** |
|-----------|------------|-------------|
| 某个方法特别宽 | 单点性能瓶颈 | 优化该方法逻辑 |
| 调用栈特别深 | 递归或循环过多 | 优化算法 |
| I/O方法很宽 | 网络/磁盘慢 | 使用缓存、异步 |
| GC相关很宽 | 内存分配过多 | 对象复用、减少创建 |

---

## 6. ⚡ 压力测试工具


### 6.1 为什么需要压力测试


> 💡 **压力测试**就像是给网关"体检"，看它在高并发下能不能撑住。

**测试目的：**
- ✅ 找出系统最大承载能力
- ✅ 发现性能瓶颈
- ✅ 验证扩容效果
- ✅ 优化配置参数

### 6.2 JMeter压力测试


**JMeter测试流程：**

```
创建测试计划：
1. 添加线程组（模拟用户）
2. 添加HTTP请求
3. 添加监听器（查看结果）
4. 运行测试
```

**配置示例：**

```
线程组配置：
┌─────────────────────────────┐
│ 线程数：1000              │← 并发用户数
│ Ramp-Up时间：10秒         │← 启动时长
│ 循环次数：10              │← 每个用户执行次数
└─────────────────────────────┘

HTTP请求：
┌─────────────────────────────┐
│ 服务器：localhost           │
│ 端口：8080                 │
│ 路径：/api/user/1          │
│ 方法：GET                  │
└─────────────────────────────┘
```

**查看测试结果：**

```
聚合报告：
┌──────────────────────────────────────────┐
│ Label    | Samples | Avg | Min | Max     │
│ /api/user| 10000   | 50  | 10  | 500     │
│          |         | ms  | ms  | ms      │
├──────────────────────────────────────────┤
│ 吞吐量：200 req/s                         │
│ 错误率：0.5%                              │
│ 90%响应时间：80ms                         │
└──────────────────────────────────────────┘

分析：
• 平均响应50ms（较好）
• 最大响应500ms（偶尔慢）
• 吞吐量200/s（看业务需求）
```

### 6.3 Gatling压力测试


**Gatling优势：**
- 🚀 性能更好（基于Akka）
- 📊 报告更美观
- 💻 支持Scala/Java编写

**测试脚本：**

```java
public class GatewaySimulation extends Simulation {
    
    // 定义HTTP协议
    HttpProtocolBuilder httpProtocol = http
        .baseUrl("http://localhost:8080")
        .acceptHeader("application/json");
    
    // 定义场景
    ScenarioBuilder scn = scenario("Gateway Test")
        .exec(
            http("Get User")
                .get("/api/user/1")
                .check(status().is(200))
        );
    
    // 定义负载
    {
        setUp(
            // 10秒内启动100个用户
            scn.injectOpen(rampUsers(100).during(10))
        ).protocols(httpProtocol);
    }
}
```

**测试报告：**

```
Gatling自动生成HTML报告：

┌─ 全局统计 ─────────────────────┐
│ 总请求数：10000               │
│ 成功：9950 (99.5%)            │
│ 失败：50 (0.5%)               │
└────────────────────────────────┘

┌─ 响应时间分布 ─────────────────┐
│  <100ms  ████████████  80%    │
│  100-200 ████          15%    │
│  200-500 ██            4%     │
│  >500ms  ░             1%     │
└────────────────────────────────┘
```

### 6.4 wrk轻量级压测


> 🎯 **wrk**是命令行压测工具，简单快速。

**基本用法：**

```bash
# 12个线程，400个连接，持续30秒

wrk -t12 -c400 -d30s http://localhost:8080/api/user/1

# 使用Lua脚本自定义请求

wrk -t12 -c400 -d30s -s script.lua http://localhost:8080
```

**Lua脚本示例：**

```lua
-- script.lua
wrk.method = "POST"
wrk.body   = '{"username":"test","password":"123456"}'
wrk.headers["Content-Type"] = "application/json"

-- 动态生成请求
request = function()
    local path = "/api/user/" .. math.random(1, 1000)
    return wrk.format("GET", path)
end
```

**测试结果：**

```
Running 30s test @ http://localhost:8080/api/user/1
  12 threads and 400 connections
  
  Thread Stats   Avg      Stdev     Max   
    Latency     45.32ms   12.15ms   200.00ms
    Req/Sec     723.45    125.32    1.2k
    
  259864 requests in 30.01s, 51.97MB read
  Socket errors: connect 0, read 0, write 0, timeout 0
  
Requests/sec:   8660.21    ← 每秒处理8660个请求
Transfer/sec:      1.73MB
```

**性能基准对比：**

| 工具 | **适用场景** | **优点** | **缺点** |
|------|------------|---------|---------|
| JMeter | 功能测试、复杂场景 | 界面友好、功能丰富 | 性能开销大 |
| Gatling | 高并发测试 | 性能好、报告美观 | 学习成本高 |
| wrk | 快速压测 | 轻量、性能极好 | 功能简单 |

---

## 7. 📋 核心要点总结


### 7.1 故障排查思路


```
故障排查步骤：
1️⃣ 查看日志 → 定位错误位置
2️⃣ 远程调试 → 单步跟踪代码
3️⃣ 网络抓包 → 检查请求响应
4️⃣ JVM分析 → 找性能瓶颈
5️⃣ 火焰图 → 定位慢方法
6️⃣ 压力测试 → 验证优化效果
```

### 7.2 工具选择指南


**快速定位问题：**

| 问题类型 | **首选工具** | **使用场景** |
|---------|------------|-------------|
| 功能错误 | 日志 + 远程调试 | 逻辑问题、参数错误 |
| 网络问题 | Wireshark/Charles | 请求失败、超时 |
| 性能慢 | JVM工具 + 火焰图 | CPU高、内存高 |
| 压力测试 | JMeter/Gatling | 评估承载能力 |

### 7.3 最佳实践


> ✅ **调试技巧要点：**

**日志实践：**
- 使用TraceId追踪完整请求链路
- 生产环境只开INFO级别日志
- 关键业务节点必须记录日志
- 定期清理过期日志文件

**调试实践：**
- 生产环境禁止开启远程调试
- 使用条件断点减少干扰
- 调试完及时关闭调试端口

**性能实践：**
- 定期执行压力测试
- 建立性能基线指标
- 使用火焰图定位瓶颈
- 优化后对比效果

**监控实践：**
- 配置告警阈值
- 24小时监控关键指标
- 保留历史监控数据
- 定期分析趋势图

### 7.4 常见问题速查


**Q1：网关响应慢怎么排查？**

```
排查步骤：
1. 查看日志耗时分布
2. 使用火焰图找慢方法
3. 检查数据库/缓存是否慢
4. 查看JVM GC情况
5. 压测验证优化效果
```

**Q2：网关内存泄漏怎么办？**

```
诊断步骤：
1. JConsole查看内存趋势
2. VisualVM生成堆转储
3. 分析对象占用排名
4. 定位泄漏代码位置
5. 修复后验证
```

**Q3：如何评估网关性能？**

```
评估指标：
• QPS：每秒请求数
• RT：平均响应时间
• P99：99%请求响应时间
• 错误率：< 0.1%
• CPU使用率：< 70%
• 内存使用率：< 80%
```

---

**🔑 记忆口诀：**
```
日志追踪找错误，调试模式看细节
抓包分析查通信，JVM诊断找瓶颈
火焰图上看热点，压测验证保性能
```