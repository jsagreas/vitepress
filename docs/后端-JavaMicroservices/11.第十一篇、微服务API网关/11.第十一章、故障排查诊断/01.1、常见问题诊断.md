---
title: 1、常见问题诊断
---
## 📚 目录

1. [路由不生效排查](#1-路由不生效排查)
2. [404错误排查](#2-404错误排查)
3. [502错误排查](#3-502错误排查)
4. [超时问题排查](#4-超时问题排查)
5. [内存溢出分析](#5-内存溢出分析)
6. [连接数过多问题](#6-连接数过多问题)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 路由不生效排查


### 1.1 什么是路由不生效


**🔸 问题表现**

当你访问网关地址时，发现请求没有被转发到目标服务，或者转发到了错误的服务，这就是路由不生效的典型现象。

```
预期效果：
http://gateway:8080/user/info  →  转发到用户服务
http://gateway:8080/order/list →  转发到订单服务

实际情况：
访问后报错或转发错误 ❌
```

**💡 通俗理解**

想象网关是个交通枢纽站，路由规则就像指路牌。路由不生效就好比：
- **指路牌丢了**：配置没生效，系统找不到规则
- **指路牌写错了**：路径匹配规则有误
- **指路牌指向错误**：目标服务地址配置错误

### 1.2 排查步骤


**📋 第一步：检查配置是否生效**

```yaml
# application.yml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/user/**
```

| 检查项 | 检查方法 | 常见问题 |
|--------|----------|----------|
| **配置文件位置** | 确认文件在 `src/main/resources` | 文件路径错误 |
| **YAML格式** | 检查缩进（用空格不用Tab） | 缩进错误导致解析失败 |
| **配置优先级** | 查看是否有其他配置覆盖 | bootstrap.yml优先级更高 |

**📋 第二步：验证路由注册情况**

访问网关的actuator端点查看路由：
```
GET http://gateway:8080/actuator/gateway/routes
```

**期望结果示例：**
```json
[
  {
    "route_id": "user-service",
    "uri": "lb://user-service",
    "predicates": [
      "Path=/user/**, match trailing slash: true"
    ]
  }
]
```

> 💡 **提示**：如果这里看不到路由，说明配置确实没生效

**📋 第三步：检查路径匹配规则**

```
常见路径匹配问题：

❌ 错误写法：
predicates:
  - Path=/user/*    # 只匹配一级路径

✅ 正确写法：
predicates:
  - Path=/user/**   # 匹配所有子路径
```

**路径匹配测试表：**

| 配置规则 | 能匹配的路径 | 不能匹配的路径 |
|----------|--------------|----------------|
| `/user/*` | `/user/info` | `/user/info/detail` |
| `/user/**` | `/user/info`<br>`/user/info/detail` | `/order/info` |
| `/api-*/info` | `/api-v1/info`<br>`/api-v2/info` | `/api/info` |

### 1.3 服务发现问题排查


**🔸 检查服务是否注册成功**

```
排查流程图：

访问网关 → 路由配置正确 → 但转发失败
                              ↓
                    检查目标服务是否在线
                              ↓
                    查看注册中心（Nacos/Eureka）
```

**检查命令：**
```bash
# 查看Nacos注册的服务
curl http://nacos-server:8848/nacos/v1/ns/instance/list?serviceName=user-service

# 查看网关日志
tail -f logs/gateway.log | grep "user-service"
```

**常见服务发现问题：**

| 问题现象 | 原因分析 | 解决方法 |
|----------|----------|----------|
| 服务名不存在 | 服务未启动或注册失败 | 启动服务并检查注册配置 |
| 服务实例为空 | 服务已下线 | 重启服务实例 |
| 负载均衡失败 | Ribbon配置问题 | 检查负载均衡策略 |

### 1.4 动态路由不生效


**🔸 配置中心动态刷新问题**

如果你使用Nacos配置中心动态管理路由：

```yaml
# Nacos中的路由配置 gateway-routes.yml
spring:
  cloud:
    gateway:
      routes:
        - id: dynamic-route
          uri: lb://new-service
          predicates:
            - Path=/new/**
```

**刷新配置方法：**

方法一：手动刷新
```bash
curl -X POST http://gateway:8080/actuator/refresh
```

方法二：自动刷新配置
```java
@RefreshScope  // 添加此注解使配置自动刷新
@Component
public class DynamicRouteConfig {
    // 路由配置逻辑
}
```

> ⚠️ **注意**：动态路由需要引入配置刷新依赖

---

## 2. ❌ 404错误排查


### 2.1 404错误的本质


**🔸 什么是404错误**

404错误表示"找不到资源"，在网关场景中通常有两种情况：
- **网关层404**：网关没有匹配到任何路由规则
- **服务层404**：路由成功，但目标服务没有对应接口

```
错误流程示意：

客户端请求：/api/user/info
    ↓
网关路由匹配 → ❌ 没有匹配规则 → 返回404（网关层）
    ↓
路由匹配成功 → 转发到user-service
    ↓
服务处理 → ❌ 没有/api/user/info接口 → 返回404（服务层）
```

### 2.2 区分404来源


**📋 判断方法**

| 判断依据 | 网关层404 | 服务层404 |
|----------|-----------|-----------|
| **响应Header** | `Server: Gateway` | `Server: Tomcat/Jetty` |
| **日志位置** | 网关日志有记录 | 服务日志有记录 |
| **错误信息** | "No matching route" | "No handler found" |

**查看日志示例：**
```bash
# 网关层404日志
[Gateway] No route matched for path: /api/unknown

# 服务层404日志  
[user-service] No mapping for GET /api/user/unknownApi
```

### 2.3 网关层404排查


**🔍 检查清单**

**① 路径大小写问题**
```yaml
# 配置的路由
- Path=/User/**

# 实际请求
GET /user/info  ❌ 大小写不匹配
GET /User/info  ✅ 正确
```

**② 路径前缀问题**
```yaml
# 场景1：需要去掉前缀
routes:
  - id: user-route
    uri: lb://user-service
    predicates:
      - Path=/api/user/**
    filters:
      - StripPrefix=1  # 去掉/api，转发/user/**到服务

# 场景2：不去前缀
routes:
  - id: user-route
    uri: lb://user-service
    predicates:
      - Path=/user/**  # 直接转发/user/**
```

**路径转换对照表：**

| 原始请求 | 路由配置 | 转发到服务的路径 |
|----------|----------|------------------|
| `/api/user/info` | `StripPrefix=1` | `/user/info` |
| `/api/user/info` | `StripPrefix=2` | `/info` |
| `/user/info` | 无StripPrefix | `/user/info` |

### 2.4 服务层404排查


**🔧 Controller接口检查**

```java
// 检查服务的Controller定义
@RestController
@RequestMapping("/user")  // 服务内部路径
public class UserController {
    
    @GetMapping("/info")  // 完整路径：/user/info
    public User getUserInfo() {
        return userService.getInfo();
    }
}
```

**路径匹配验证：**
```
网关配置：
- Path=/user/**
- StripPrefix=0

请求路径：/user/info
转发路径：/user/info
服务路径：@RequestMapping("/user") + @GetMapping("/info")
         = /user/info ✅ 匹配成功
```

> 💡 **关键理解**：网关转发后的路径必须和服务Controller定义的路径完全一致

---

## 3. 🔴 502错误排查


### 3.1 502错误含义


**🔸 什么是502错误**

502 Bad Gateway表示网关作为代理，从上游服务器收到了无效响应。简单说就是：**网关能找到服务，但服务出问题了**。

```
请求流程：

客户端 → 网关(正常) → 服务(异常) → 网关收到错误 → 返回502
```

**常见场景：**
- 服务启动中，还未完全就绪
- 服务崩溃或宕机
- 服务响应超时
- 服务返回了非法的HTTP响应

### 3.2 服务健康检查


**📋 快速诊断步骤**

**① 检查服务是否存活**
```bash
# 方法1：直接访问服务
curl http://user-service:8080/actuator/health

# 方法2：查看进程
ps aux | grep user-service

# 方法3：查看注册中心
# Nacos控制台查看服务实例状态
```

**健康状态对照表：**

| 状态 | 说明 | 处理方法 |
|------|------|----------|
| **UP** | 服务正常 | 继续排查其他原因 |
| **DOWN** | 服务异常 | 查看服务日志，重启服务 |
| **UNKNOWN** | 无法判断 | 检查健康检查接口配置 |
| **OUT_OF_SERVICE** | 临时下线 | 等待服务恢复或手动上线 |

### 3.3 服务启动问题


**🔸 服务启动中导致502**

```
问题场景：
服务重启过程中，网关转发请求过来
→ 服务正在加载，无法处理请求
→ 返回错误或无响应
→ 网关判定为502
```

**解决方案：**

方法一：优雅上线（推荐）
```java
// 延迟服务注册，等应用启动完成
@SpringBootApplication
public class UserServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(UserServiceApplication.class);
        // 延迟注册，等应用完全启动
        app.setRegisterShutdownHook(false);
        app.run(args);
    }
}
```

方法二：健康检查延迟
```yaml
# application.yml
management:
  health:
    defaults:
      enabled: true
  endpoint:
    health:
      show-details: always
      
# Nacos配置
spring:
  cloud:
    nacos:
      discovery:
        heart-beat-interval: 5000  # 心跳间隔
        heart-beat-timeout: 15000  # 心跳超时
```

### 3.4 连接拒绝问题


**🔧 网络连接问题排查**

```bash
# 测试网关到服务的网络连通性
telnet user-service 8080

# 或使用curl测试
curl -v http://user-service:8080
```

**常见网络问题：**

| 错误信息 | 原因 | 解决方法 |
|----------|------|----------|
| Connection refused | 服务未启动或端口错误 | 检查服务状态和端口配置 |
| Connection timeout | 网络不通或防火墙拦截 | 检查网络配置和防火墙规则 |
| No route to host | 服务器不可达 | 检查服务器状态和网络路由 |

---

## 4. ⏱️ 超时问题排查


### 4.1 超时问题的表现


**🔸 超时错误特征**

```
典型错误信息：
- "Read timed out"
- "Connection timed out"  
- "Gateway Timeout (504)"
- "I/O error on GET request"
```

**超时发生位置：**
```
客户端 --[超时1]--> 网关 --[超时2]--> 服务 --[超时3]--> 数据库
                      ↑                  ↑
                  网关层超时          服务层超时
```

### 4.2 超时配置层次


**📊 三层超时配置**

**第一层：网关全局超时**
```yaml
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 3000  # 连接超时（毫秒）
        response-timeout: 10s   # 响应超时
```

**第二层：路由级超时**
```yaml
routes:
  - id: slow-service
    uri: lb://slow-service
    predicates:
      - Path=/slow/**
    metadata:
      response-timeout: 30000  # 此路由单独设置30秒超时
      connect-timeout: 5000
```

**第三层：Ribbon超时**
```yaml
# 针对特定服务的超时配置
user-service:
  ribbon:
    ConnectTimeout: 3000      # 连接超时
    ReadTimeout: 10000        # 读取超时
    MaxAutoRetries: 0         # 同一服务重试次数
    MaxAutoRetriesNextServer: 1  # 切换服务重试次数
```

**超时配置优先级：**
```
路由级metadata > Ribbon配置 > 网关全局配置
```

### 4.3 排查超时原因


**🔍 定位超时环节**

```bash
# 1. 查看网关日志，找到超时请求
grep "timed out" gateway.log

# 2. 查看具体耗时
grep "elapsed=" gateway.log | sort -t= -k2 -n

# 3. 分析慢请求
# 日志示例：
# Request to user-service elapsed=12340ms [TIMEOUT]
```

**慢请求分析表：**

| 耗时范围 | 可能原因 | 排查方向 |
|----------|----------|----------|
| 50-200ms | 正常范围 | 无需处理 |
| 200-1000ms | 服务处理慢 | 检查服务性能 |
| 1-3秒 | 数据库查询慢 | 优化SQL或加缓存 |
| 3秒以上 | 存在阻塞或死锁 | 检查线程状态和资源 |

### 4.4 优化方案


**⚡ 常见优化策略**

**策略一：合理设置超时时间**
```yaml
# 根据服务特点区分超时配置
spring:
  cloud:
    gateway:
      routes:
        # 快速查询接口：短超时
        - id: query-service
          uri: lb://query-service
          metadata:
            response-timeout: 5000
            
        # 报表导出接口：长超时
        - id: export-service  
          uri: lb://export-service
          metadata:
            response-timeout: 60000
```

**策略二：启用重试机制**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/user/**
          filters:
            - name: Retry
              args:
                retries: 2  # 重试2次
                statuses: BAD_GATEWAY,GATEWAY_TIMEOUT
                methods: GET  # 只对GET重试
                backoff:
                  firstBackoff: 100ms
                  maxBackoff: 500ms
```

> ⚠️ **重试注意事项**：只对幂等接口启用重试，避免重复提交

---

## 5. 💾 内存溢出分析


### 5.1 内存溢出表现


**🔸 OOM错误识别**

```
典型错误日志：
java.lang.OutOfMemoryError: Java heap space
java.lang.OutOfMemoryError: GC overhead limit exceeded
java.lang.OutOfMemoryError: Metaspace
```

**内存溢出的影响：**
```
网关JVM内存耗尽
    ↓
无法处理新请求
    ↓
频繁Full GC
    ↓
响应变慢甚至服务崩溃
```

### 5.2 内存问题诊断


**📊 内存使用监控**

```bash
# 查看JVM内存使用情况
jmap -heap <gateway-pid>

# 生成堆内存快照
jmap -dump:format=b,file=heap.hprof <gateway-pid>

# 查看最占内存的对象
jmap -histo:live <gateway-pid> | head -20
```

**内存占用分析表：**

| 对象类型 | 可能原因 | 排查重点 |
|----------|----------|----------|
| `char[]`或`String` | 请求/响应数据堆积 | 检查是否有大量日志或缓存 |
| `Thread` | 线程泄漏 | 检查线程池配置 |
| `HashMap` | 缓存数据过多 | 检查本地缓存策略 |
| 自定义对象 | 业务对象未释放 | 检查过滤器和拦截器 |

### 5.3 常见内存泄漏场景


**🔸 场景一：请求体缓存问题**

网关默认会缓存请求体用于重试，如果请求体很大会占用大量内存：

```yaml
# 优化方案：限制缓存大小
spring:
  cloud:
    gateway:
      httpclient:
        pool:
          max-connections: 500
        # 限制请求体大小
        max-in-memory-size: 1MB  # 超过1MB不缓存
```

**🔸 场景二：日志过多**

```java
// ❌ 错误做法：打印完整请求/响应体
log.info("Request body: {}", requestBody);  // 大量数据

// ✅ 正确做法：只打印关键信息
log.info("Request: {} {}", method, uri);
```

**🔸 场景三：过滤器内存泄漏**

```java
// 自定义过滤器注意释放资源
@Component
public class CustomFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 使用后要清理
        DataBuffer dataBuffer = exchange.getRequest().getBody();
        
        return chain.filter(exchange).doFinally(signalType -> {
            // 确保释放内存
            DataBufferUtils.release(dataBuffer);
        });
    }
}
```

### 5.4 内存优化建议


**⚡ JVM参数优化**

```bash
# 启动参数示例
java -jar gateway.jar \
  -Xms2g -Xmx2g \              # 堆内存2G
  -XX:MetaspaceSize=256m \     # 元空间256M
  -XX:MaxMetaspaceSize=512m \  # 元空间最大512M
  -XX:+UseG1GC \               # 使用G1垃圾回收器
  -XX:MaxGCPauseMillis=200 \   # GC停顿时间目标
  -XX:+HeapDumpOnOutOfMemoryError \  # OOM时生成dump
  -XX:HeapDumpPath=/logs/heapdump.hprof
```

**配置建议表：**

| 网关规模 | 堆内存 | 元空间 | GC策略 |
|----------|--------|--------|--------|
| 小型（<1000 QPS） | 1-2G | 256M | G1GC |
| 中型（1000-5000 QPS） | 2-4G | 512M | G1GC |
| 大型（>5000 QPS） | 4-8G | 512M-1G | G1GC或ZGC |

---

## 6. 🔌 连接数过多问题


### 6.1 连接数问题表现


**🔸 典型症状**

```
错误日志示例：
- "Too many open files"
- "Cannot assign requested address"
- "Connection pool exhausted"
- "No available connections"
```

**问题影响流程：**
```
高并发请求 → 连接数快速增长 → 达到上限
                                  ↓
                    新请求无法建立连接 → 503错误
```

### 6.2 连接池配置


**📊 网关连接池设置**

```yaml
spring:
  cloud:
    gateway:
      httpclient:
        pool:
          type: ELASTIC  # 弹性连接池
          max-connections: 1000  # 最大连接数
          max-idle-time: 30s     # 空闲连接保持时间
          max-life-time: 60s     # 连接最大生存时间
          acquire-timeout: 45s   # 获取连接超时
```

**连接池类型对比：**

| 类型 | 特点 | 适用场景 |
|------|------|----------|
| **ELASTIC** | 动态伸缩，按需创建 | 流量波动大的场景 |
| **FIXED** | 固定大小，预先创建 | 流量稳定的场景 |
| **DISABLED** | 每次创建新连接 | 测试环境或低并发 |

### 6.3 系统层面优化


**🔧 操作系统限制调整**

```bash
# 1. 查看当前限制
ulimit -n  # 查看文件描述符限制

# 2. 临时调整（重启失效）
ulimit -n 65535

# 3. 永久调整
# 编辑 /etc/security/limits.conf
* soft nofile 65535
* hard nofile 65535

# 4. 修改系统参数
# 编辑 /etc/sysctl.conf
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 0

# 使生效
sysctl -p
```

### 6.4 连接数监控


**📈 监控指标**

```bash
# 查看网关连接数
netstat -an | grep :8080 | wc -l

# 查看TIME_WAIT状态连接
netstat -an | grep TIME_WAIT | wc -l

# 查看ESTABLISHED连接
netstat -an | grep ESTABLISHED | wc -l
```

**健康标准：**

| 指标 | 正常范围 | 警告阈值 | 危险阈值 |
|------|----------|----------|----------|
| 总连接数 | < 最大值60% | 60-80% | > 80% |
| TIME_WAIT连接 | < 1000 | 1000-5000 | > 5000 |
| 连接获取等待 | < 100ms | 100-500ms | > 500ms |

**优化建议：**

```yaml
# 1. 调整连接复用策略
spring:
  cloud:
    gateway:
      httpclient:
        pool:
          max-idle-time: 20s  # 减少空闲时间，加快释放

# 2. 启用连接压缩
server:
  compression:
    enabled: true
    mime-types: application/json,text/html
    
# 3. 合理设置超时
spring:
  cloud:
    gateway:
      httpclient:
        response-timeout: 10s  # 避免长时间占用连接
```

---

## 7. 📋 核心要点总结


### 7.1 故障诊断要点记忆


**🔸 问题分类与处理优先级**

```
路由问题（最常见）：
  → 先查配置是否生效
  → 再查路径匹配规则
  → 最后查服务注册状态

连接问题（最紧急）：
  → 先查服务是否存活
  → 再查网络是否通畅
  → 最后查连接池配置

性能问题（最复杂）：
  → 先查超时设置
  → 再查内存使用
  → 最后查线程和连接
```

### 7.2 快速诊断清单


| 问题类型 | 关键检查点 | 常用命令 |
|----------|------------|----------|
| **404** | 路由配置、路径匹配 | `curl actuator/gateway/routes` |
| **502** | 服务健康、网络连通 | `curl http://service/health` |
| **504** | 超时配置、服务性能 | `grep timeout gateway.log` |
| **OOM** | 内存配置、对象泄漏 | `jmap -heap <pid>` |
| **连接数** | 连接池、系统限制 | `netstat -an \| wc -l` |

### 7.3 预防性措施


**✅ 最佳实践建议**

```
配置管理：
- 使用配置中心统一管理
- 区分环境配置（dev/test/prod）
- 定期审查和优化配置

监控告警：
- 配置关键指标监控
- 设置合理告警阈值
- 建立快速响应机制

压力测试：
- 上线前进行压测
- 模拟各种异常场景
- 验证容错能力

日志规范：
- 统一日志格式
- 保留关键请求ID
- 设置合理日志级别
```

### 7.4 故障处理流程


```
发现问题
    ↓
查看监控面板 → 确定问题范围
    ↓
查看日志 → 定位具体错误
    ↓
快速止损 → 重启/限流/降级
    ↓
深入分析 → 找出根本原因
    ↓
优化配置 → 预防再次发生
```

**核心记忆口诀：**
- 路由404看配置，502服务要检查
- 超时问题查三层，内存溢出找泄漏
- 连接过多调池子，日志监控不能少
- 问题定位要系统，预防优化是关键