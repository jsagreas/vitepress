---
title: 1、限流理论基础
---
## 📚 目录

1. [限流理论基础](#1-限流理论基础)
2. [限流保护作用](#2-限流保护作用)
3. [系统容量评估](#3-系统容量评估)
4. [流量削峰填谷](#4-流量削峰填谷)
5. [防止系统雪崩](#5-防止系统雪崩)
6. [QPS与TPS核心概念](#6-QPS与TPS核心概念)
7. [限流与熔断的区别](#7-限流与熔断的区别)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 限流理论基础


### 1.1 什么是限流


**通俗理解**：限流就像景区的"限流措施"

```
现实场景类比：
🏞️ 景区限流：每小时只允许1000人进入
   ↓
   目的：防止人太多导致拥挤、安全隐患
   
💻 系统限流：每秒只处理1000个请求
   ↓
   目的：防止请求太多导致系统崩溃
```

**核心定义**：
- 限流是一种**流量控制手段**
- 通过限制单位时间内的请求数量
- 保护系统不被过载压垮
- 确保服务稳定可用

### 1.2 为什么需要限流


**三大核心原因**：

> 💡 **原因1：系统处理能力有限**
> 
> 任何系统都有处理上限，就像餐厅的座位数有限，超过容量就无法接待

> ⚠️ **原因2：突发流量冲击**
> 
> 促销活动、热点事件会带来瞬时大流量，不加控制会直接击垮系统

> 🔒 **原因3：恶意攻击防护**
> 
> DDoS攻击会发送海量请求，限流是第一道防线

### 1.3 限流的本质


**核心思想**：**以退为进，保核心**

```
限流策略本质：
┌─────────────────────────────────┐
│ 牺牲部分用户体验（排队、拒绝）   │
│            ↓                    │
│ 换取整体系统稳定（不崩溃）       │
└─────────────────────────────────┘

类比：
急诊室分诊制度
├─ 轻症患者等待 ← 牺牲体验
└─ 重症患者优先 ← 保证核心
```

**关键理解**：
- 限流不是"拒绝服务"，而是**"控制服务节奏"**
- 目标是**让系统活着**，而不是全部服务
- 就像堤坝泄洪，控制水流避免溃坝

---

## 2. 🛡️ 限流保护作用


### 2.1 保护系统稳定性


**核心保护机制**：

```
无限流场景：
客户端                API网关               后端服务
  │                     │                     │
  ├─ 10000 req/s ──────>│                     │
  │                     ├─ 10000 req/s ──────>│
  │                     │                     ├─ 💥系统崩溃
  │                     │                     │   (只能处理1000/s)

有限流场景：
客户端                API网关               后端服务
  │                     │                     │
  ├─ 10000 req/s ──────>│ 🚦限流控制          │
  │                     ├─ 1000 req/s ───────>│ ✅稳定运行
  │                     ├─ 9000 req/s 拒绝    │
```

**四层保护作用**：

| 保护层面 | 作用说明 | 具体体现 |
|---------|---------|---------|
| 🔹 **服务器层** | 保护CPU、内存不被耗尽 | 控制线程数、连接数 |
| 🔹 **应用层** | 防止业务逻辑过载 | 限制并发处理数量 |
| 🔹 **数据库层** | 避免数据库连接打满 | 控制数据库查询频率 |
| 🔹 **网络层** | 防止带宽被占满 | 限制传输速率 |

### 2.2 保护用户体验


**限流的正面价值**：

> 📖 **核心观点**：限流虽然会让部分用户等待，但保证了所有用户都能获得服务

```
对比分析：

❌ 不限流的后果：
所有用户 → 系统崩溃 → 全部用户无法访问 → 体验极差

✅ 限流的效果：
10000用户 → 1000用户立即服务 → 9000用户排队/拒绝
          → 至少1000用户有正常体验
          → 9000用户收到明确反馈（稍后重试）
```

**实际案例**：
- 12306抢票：排队机制 ← 典型的限流保护
- 电商秒杀：分批放号 ← 削峰填谷
- 银行转账：单日限额 ← 安全限流

### 2.3 保护成本投入


**经济价值分析**：

```
场景对比：

方案1：不限流，通过硬件扩容应对峰值
├─ 按峰值流量配置服务器（10000 req/s）
├─ 成本：💰💰💰💰💰（很高）
└─ 利用率：平时只有10%（浪费90%）

方案2：限流，按常态流量配置
├─ 按平均流量配置服务器（1000 req/s）
├─ 成本：💰（合理）
└─ 利用率：80%以上（资源充分利用）
```

> 🚀 **最佳实践**：限流 + 弹性扩容
> 
> 平时保持合理配置，峰值时限流保护 + 自动扩容应对

---

## 3. 📊 系统容量评估


### 3.1 什么是系统容量


**通俗解释**：
- 系统容量就是**系统的"饭量"**
- 表示系统**一次能吃下多少请求**
- 超过这个量，系统就"消化不良"

**专业定义**：
```
系统容量 = 在保证服务质量前提下
          系统能够处理的最大请求量
          
关键指标：
├─ 吞吐量：单位时间处理请求数
├─ 响应时间：每个请求处理耗时
├─ 并发数：同时处理请求数量
└─ 成功率：请求成功处理比例
```

### 3.2 容量评估方法


**三步评估法**：

**步骤1：压力测试**
```
压测工具：JMeter、Gatling、wrk

测试方法：
├─ 起点：100 req/s
├─ 递增：每30秒增加100 req/s
└─ 终点：找到临界点（响应时间突增/错误率上升）

示例结果：
100 req/s → 响应100ms ✅
500 req/s → 响应120ms ✅
1000 req/s → 响应150ms ✅
1500 req/s → 响应500ms ⚠️  ← 临界点
2000 req/s → 响应2000ms ❌
```

**步骤2：确定安全阈值**
```
容量计算公式：
安全阈值 = 临界值 × 安全系数

示例：
临界值：1500 req/s
安全系数：0.7（预留30%缓冲）
安全阈值 = 1500 × 0.7 = 1050 req/s
```

**步骤3：分级限流策略**
```
限流策略设计：

┌─ 正常流量：1050 req/s以内 ─────────┐
│  策略：全部通过，正常处理           │
├─ 警戒流量：1050-1300 req/s ────────┤
│  策略：优先级队列，VIP优先          │
├─ 超载流量：1300-1500 req/s ────────┤
│  策略：部分拒绝，返回稍后重试       │
└─ 危险流量：> 1500 req/s ───────────┘
   策略：快速拒绝，保护系统
```

### 3.3 容量规划要点


**核心原则**：

> ⚠️ **原则1：留有余地**
> 
> 不要按100%容量规划，要预留30-50%缓冲空间

> 📈 **原则2：动态调整**
> 
> 根据业务增长定期重新评估，容量不是一成不变的

> 🎯 **原则3：分层限流**
> 
> 不同服务、不同接口设置不同限流值

**容量评估表格示例**：

| 服务/接口 | 压测容量 | 安全阈值 | 限流配置 | 备注 |
|----------|---------|---------|---------|------|
| 用户登录 | 2000/s | 1400/s | 1500/s | 核心接口，略高配置 |
| 商品查询 | 5000/s | 3500/s | 4000/s | 高频接口 |
| 订单提交 | 800/s | 560/s | 600/s | 重业务，低配置 |
| 评论发布 | 1000/s | 700/s | 800/s | 一般业务 |

---

## 4. 🌊 流量削峰填谷


### 4.1 什么是削峰填谷


**形象比喻**：

```
原始流量波动图：
流量
 ↑
 │     ╱╲                    ← 峰值（系统扛不住）
 │    ╱  ╲
 │   ╱    ╲
 │  ╱      ╲_______________  ← 系统容量线
 │_╱________________________
 └─────────────────────────→ 时间

削峰填谷后：
流量
 ↑   ___________________     ← 削掉的峰值（排队/拒绝）
 │  ╱                   ╲
 │ ╱___________________  ╲__ ← 填平后的流量（稳定）
 │__________________________ ← 系统容量线
 └─────────────────────────→ 时间
```

**核心含义**：
- **削峰**：把突发的高峰流量"削"下来
- **填谷**：把削下来的流量"填"到低谷时段
- **目的**：让流量变得平滑，系统处理更稳定

### 4.2 削峰填谷的实现方式


**三大核心手段**：

**手段1：消息队列**
```
工作原理：

客户端请求流程：
请求 → API网关 → 消息队列 → 后端服务
         ↓          ↓          ↓
      瞬时接收   暂存缓冲   按能力消费

具体过程：
秒杀场景下：
├─ 0秒：10000个下单请求涌入
├─ 1秒：全部写入消息队列（快速响应用户）
├─ 2-12秒：后端每秒处理1000个（平稳消费）
└─ 结果：峰值10000→平滑1000，时长拉长10倍
```

**手段2：限流排队**
```
排队机制：

┌─ 用户1 ─┐
│ 用户2 ─┤                队列（FIFO）
│ 用户3 ─┤      →     ┌─────────────┐
│  ...  ─┤            │ 1 → 2 → 3..│ → 按序处理
└─ 用户N ─┘            └─────────────┘

特点：
├─ 先到先服务（公平）
├─ 控制进入速度（削峰）
└─ 避免拒绝服务（体验好）
```

**手段3：分批处理**
```
场景：大促秒杀活动

不削峰：
00:00:00 - 10000人抢100件商品 → 系统崩溃

削峰方案：
├─ 第1批：00:00:00 开放20件（2000人抢）
├─ 第2批：00:00:30 开放20件（2000人抢）
├─ 第3批：00:01:00 开放20件（2000人抢）
├─ 第4批：00:01:30 开放20件（2000人抢）
└─ 第5批：00:02:00 开放20件（2000人抢）

效果：
原峰值：10000 req/s → 削峰后：2000 req/s
```

### 4.3 削峰填谷的业务价值


**实际收益**：

| 维度 | 削峰前 | 削峰后 | 提升效果 |
|-----|-------|-------|---------|
| 💰 **服务器成本** | 按峰值配置 | 按平均配置 | 节省60-80% |
| ⚡ **系统稳定性** | 峰值易崩溃 | 平稳运行 | 可用性99%→99.9% |
| 😊 **用户体验** | 全部失败 | 部分排队 | 成功率0%→70% |
| 🔧 **运维难度** | 峰值扩容难 | 容量稳定 | 降低50% |

> 🚀 **典型案例**：
> 
> **12306春运抢票**
> - 削峰前：瞬时百万级并发，系统崩溃
> - 削峰后：排队机制 + 分批放票 + 消息队列
> - 效果：系统稳定，虽然要等但至少能买到票

---

## 5. ⚠️ 防止系统雪崩


### 5.1 什么是系统雪崩


**通俗理解**：雪崩就是"连锁反应式崩溃"

```
雪崩过程演示：

服务A → 服务B → 服务C → 数据库
  ✅      ✅      ✅       ✅

第1步：服务C响应变慢
服务A → 服务B → 服务C → 数据库
  ✅      ✅      🐌       ✅

第2步：服务B被拖慢（等待C响应）
服务A → 服务B → 服务C → 数据库
  ✅      🐌      🐌       ✅

第3步：服务A也被拖慢
服务A → 服务B → 服务C → 数据库
  🐌      🐌      🐌       ✅

第4步：全链路崩溃
服务A → 服务B → 服务C → 数据库
  💥      💥      💥       ✅
```

**雪崩三阶段**：

> 📖 **阶段1：局部故障**
> 
> 某个服务节点出现问题（慢查询、网络抖动等）

> 📖 **阶段2：故障传播**
> 
> 上游服务因等待下游响应而阻塞，资源耗尽

> 📖 **阶段3：全面崩溃**
> 
> 整个调用链路所有服务相继崩溃

### 5.2 限流如何防止雪崩


**核心机制**：**快速失败，阻断传播**

```
限流防雪崩流程：

正常调用链：
服务A → 服务B → 服务C
 └─ 限流：1000/s

服务C出现慢查询：
服务A → 服务B → 服务C（变慢）
                   ↓
         API网关检测到响应超时
                   ↓
         🚦 触发限流保护
                   ↓
         快速拒绝超量请求
                   ↓
         ✅ 阻止雪崩蔓延
```

**三重保护机制**：

**保护1：入口限流**
```
作用：在网关层拦截过载请求

客户端               网关               服务集群
  │                  │                    │
  ├─ 请求 ─────────> │                    │
  │                  ├─ 判断：超过限流值？ │
  │                  │   ├─ 是 → 拒绝     │
  │                  │   └─ 否 → 放行 ──> │
```

**保护2：服务限流**
```
作用：每个服务自我保护

服务A                服务B               服务C
  │                   │                   │
  ├─ 调用 ──────────> │                   │
  │                   ├─ 自身限流判断     │
  │                   │   ├─ 超载 → 快速返回错误
  │                   │   └─ 正常 → 继续 ─> │
```

**保护3：依赖隔离**
```
作用：故障隔离，互不影响

调用方使用线程池隔离：
┌─ 线程池A（调用服务B）─┐
├─ 线程池B（调用服务C）─┤
└─ 线程池C（调用服务D）─┘

服务C挂了：
├─ 线程池B被占满（最多10个线程）
├─ 不影响线程池A和C
└─ 其他服务正常运行
```

### 5.3 雪崩防护最佳实践


**防护策略组合**：

```
多层防护体系：

第1层：限流（API网关）
      ↓ 控制入口流量
      
第2层：熔断（服务调用）
      ↓ 快速失败，阻断传播
      
第3层：降级（业务逻辑）
      ↓ 关闭非核心功能
      
第4层：限流（服务自身）
      ↓ 自我保护
      
第5层：超时控制
      ↓ 避免长时间等待
```

> 💡 **核心思想**：
> 
> **宁可丢车保帅，也不全军覆没**
> - 牺牲部分功能，保证核心服务
> - 快速失败，避免资源耗尽
> - 多层防护，层层拦截

---

## 6. 📈 QPS与TPS核心概念


### 6.1 QPS是什么


**QPS（Queries Per Second）**：每秒查询数

**通俗解释**：
```
QPS就像"收银台的服务速度"

场景：超市收银
├─ 1分钟结账30个顾客
├─ QPS = 30 ÷ 60 = 0.5次/秒
└─ 含义：收银员每秒能服务0.5个顾客

系统场景：
├─ 1秒钟处理1000个HTTP请求
├─ QPS = 1000
└─ 含义：系统每秒能处理1000次查询
```

**QPS计算公式**：
```
QPS = 总请求数 ÷ 总时间（秒）

实例：
10分钟内收到60000个请求
QPS = 60000 ÷ 600 = 100

含义：平均每秒处理100个请求
```

### 6.2 TPS是什么


**TPS（Transactions Per Second）**：每秒事务数

**TPS vs QPS的区别**：

```
核心差异：
├─ QPS：关注"请求次数"
└─ TPS：关注"业务完成度"

举例说明：
下单业务（1个事务）：
  ├─ 请求1：检查库存    ← QPS计数
  ├─ 请求2：创建订单    ← QPS计数
  ├─ 请求3：扣减库存    ← QPS计数
  ├─ 请求4：发起支付    ← QPS计数
  └─ 完成1笔交易       ← TPS计数

结果：
QPS = 4（4个请求）
TPS = 1（1笔交易）
```

**TPS更关注业务价值**：

| 指标 | 含义 | 应用场景 | 示例 |
|-----|------|---------|------|
| **QPS** | 系统处理请求能力 | 技术性能评估 | "服务器QPS=5000" |
| **TPS** | 业务处理能力 | 业务价值评估 | "支付系统TPS=1000" |

### 6.3 QPS/TPS在限流中的应用


**限流阈值设置**：

```
场景1：API接口限流（用QPS）
├─ 商品列表接口：QPS=2000
├─ 用户信息接口：QPS=1000
└─ 搜索接口：QPS=500

场景2：业务限流（用TPS）
├─ 下单业务：TPS=500（每秒最多500笔订单）
├─ 支付业务：TPS=200（每秒最多200笔支付）
└─ 退款业务：TPS=100（每秒最多100笔退款）
```

**性能测试关注点**：

> 🔧 **技术团队关注QPS**
> - 系统能抗多大压力
> - 需要多少服务器
> - 如何优化性能

> 💼 **业务团队关注TPS**
> - 能支撑多少订单量
> - 能服务多少用户
> - 业务增长是否够用

**压测指标示例**：

```
电商系统压测报告：

技术指标（QPS）：
├─ 首页：QPS=10000 ✅
├─ 商品详情：QPS=8000 ✅
└─ 下单接口：QPS=3000 ✅

业务指标（TPS）：
├─ 下单成功：TPS=800 ✅
├─ 支付成功：TPS=600 ✅
└─ 完整购物流程：TPS=500 ✅
```

### 6.4 如何提升QPS/TPS


**优化方向**：

```
提升QPS的方法：
┌─ 1. 代码优化 ────────────┐
│  ├─ 减少数据库查询次数   │
│  ├─ 使用缓存             │
│  └─ 异步处理             │
├─ 2. 架构优化 ────────────┤
│  ├─ 负载均衡             │
│  ├─ 服务拆分             │
│  └─ CDN加速              │
├─ 3. 硬件扩容 ────────────┤
│  ├─ 增加服务器           │
│  ├─ 升级配置             │
│  └─ 使用SSD硬盘          │
└───────────────────────────┘

提升TPS的方法：
┌─ 1. 业务优化 ────────────┐
│  ├─ 简化业务流程         │
│  ├─ 减少事务步骤         │
│  └─ 异步化非核心操作     │
├─ 2. 数据库优化 ──────────┤
│  ├─ 索引优化             │
│  ├─ 事务拆分             │
│  └─ 读写分离             │
└───────────────────────────┘
```

---

## 7. 🔄 限流与熔断的区别


### 7.1 核心概念对比


**形象比喻**：

```
限流 = 门卫（控制进入人数）
熔断 = 保险丝（故障时切断电路）

酒吧场景：
┌────────────────────────────┐
│  门卫（限流）               │
│  ├─ 酒吧容量200人          │
│  ├─ 门口排队控制           │
│  └─ 超过200人禁止进入      │
│                            │
│  保险丝（熔断）             │
│  ├─ 发现电路异常           │
│  ├─ 立即切断电源           │
│  └─ 防止火灾蔓延           │
└────────────────────────────┘
```

**定义对比**：

| 特性 | 限流（Rate Limit） | 熔断（Circuit Breaker） |
|-----|-------------------|------------------------|
| 🎯 **目的** | 控制流量速率 | 快速失败，防止雪崩 |
| ⏰ **触发时机** | 流量超过阈值 | 错误率超过阈值 |
| 🔧 **作用对象** | 限制请求数量 | 切断服务调用 |
| 📊 **判断依据** | 流量大小 | 错误率/响应时间 |
| 🚦 **处理方式** | 拒绝/排队 | 快速返回错误 |

### 7.2 工作原理差异


**限流工作流程**：

```
请求流程：
客户端 → 限流器 → 服务
         ↓
    判断逻辑：
    ├─ 当前QPS < 阈值？
    │  └─ 是 → 放行
    └─ 当前QPS ≥ 阈值？
       └─ 是 → 拒绝/排队

示例：
设定：QPS=1000
第1001个请求到达：
  ↓
限流器判断：已有1000个请求
  ↓
拒绝：返回429状态码（Too Many Requests）
```

**熔断工作流程**：

```
熔断三状态：

1️⃣ 关闭状态（正常）
   ├─ 请求正常调用
   ├─ 统计错误率
   └─ 错误率<50% → 保持关闭

2️⃣ 打开状态（熔断）
   ├─ 错误率≥50% → 打开熔断
   ├─ 所有请求快速失败
   └─ 等待5秒（冷却期）

3️⃣ 半开状态（试探）
   ├─ 放行少量请求试探
   ├─ 成功 → 关闭熔断
   └─ 失败 → 重新打开
```

**图解对比**：

```
限流场景：
时间    请求量    限流器行为
0s      800      ✅ 全部通过
1s      1200     ⛔ 拒绝200个
2s      900      ✅ 全部通过
3s      1500     ⛔ 拒绝500个

熔断场景：
时间    错误率    熔断器状态    行为
0s      10%      关闭         ✅ 正常调用
1s      60%      打开         ⛔ 快速失败
2s      60%      打开         ⛔ 快速失败
3s      -        半开         🔄 试探调用
4s      5%       关闭         ✅ 恢复正常
```

### 7.3 应用场景区别


**限流适用场景**：

> 🎯 **场景1：保护系统容量**
> 
> 系统处理能力有限，需要控制并发量
> 
> 例：订单系统QPS=1000，超过则拒绝

> 🎯 **场景2：防止恶意攻击**
> 
> 同一IP频繁请求，可能是爬虫或攻击
> 
> 例：同一IP每秒最多10次请求

> 🎯 **场景3：API配额管理**
> 
> 不同用户等级有不同的调用限制
> 
> 例：免费用户100次/天，VIP用户10000次/天

**熔断适用场景**：

> ⚡ **场景1：依赖服务故障**
> 
> 下游服务挂了，快速失败避免资源耗尽
> 
> 例：支付服务异常，熔断后直接返回错误

> ⚡ **场景2：慢查询保护**
> 
> 数据库响应慢，熔断避免线程堆积
> 
> 例：查询超时>3秒，触发熔断

> ⚡ **场景3：级联故障防护**
> 
> 防止故障在微服务间传播
> 
> 例：服务C挂了，熔断B→C调用，保护服务A

### 7.4 组合使用策略


**最佳实践：限流 + 熔断 双重保护**

```
防护体系：

第1层：网关限流
├─ 作用：控制总流量
└─ 配置：QPS=5000

第2层：服务熔断
├─ 作用：快速失败
└─ 配置：错误率>50%熔断

实际流程：
客户端
  ↓
网关限流（5000 QPS）✅
  ↓
路由到服务A
  ↓
调用服务B
  ↓
熔断器检查（服务B状态）
  ├─ 正常 → 调用 ✅
  └─ 熔断 → 快速失败 ⛔
```

**场景案例对比**：

| 问题场景 | 限流方案 | 熔断方案 | 组合方案 |
|---------|---------|---------|---------|
| 🔸 流量突增 | ✅ 拒绝超量请求 | ❌ 无法处理 | ✅ 限流为主 |
| 🔸 服务故障 | ❌ 仍会调用失败 | ✅ 快速失败 | ✅ 熔断为主 |
| 🔸 慢查询 | ⚠️ 部分缓解 | ✅ 及时切断 | ✅ 熔断+限流 |
| 🔸 DDoS攻击 | ✅ 限制频率 | ❌ 无法防御 | ✅ 限流为主 |

> 💡 **核心要点**：
> 
> - **限流是预防**：未雨绸缪，防止系统过载
> - **熔断是应急**：亡羊补牢，快速止损
> - **组合使用**：多层防护，全面保障

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 限流本质：控制流量节奏，保护系统稳定
🔸 保护作用：服务器、应用、数据库、网络四层保护
🔸 容量评估：压测→确定阈值→分级策略
🔸 削峰填谷：消息队列+排队+分批，平滑流量
🔸 防止雪崩：快速失败，阻断故障传播
🔸 QPS/TPS：请求数vs事务数，技术vs业务视角
🔸 限流vs熔断：控制流量vs快速失败，预防vs应急
```

### 8.2 关键理解要点


**🔹 限流的核心思想**
```
牺牲局部 → 保全整体
控制节奏 → 稳定运行
多层防护 → 全面保障
```

**🔹 容量规划的原则**
```
留有余地：预留30-50%缓冲
动态调整：定期重新评估
分层限流：不同服务不同策略
```

**🔹 削峰填谷的价值**
```
降低成本：节省60-80%服务器
提升稳定：可用性99%→99.9%
优化体验：全部失败→部分成功
```

### 8.3 实战应用指导


**限流策略选择**：

| 业务场景 | 推荐策略 | 配置建议 |
|---------|---------|---------|
| 🔸 **核心交易** | 严格限流+熔断 | QPS=容量×0.7 |
| 🔸 **查询接口** | 宽松限流 | QPS=容量×0.8 |
| 🔸 **用户登录** | IP限流+账号限流 | 10次/分钟 |
| 🔸 **秒杀活动** | 削峰+排队 | 分批放行 |
| 🔸 **外部API** | 配额管理 | 按级别限流 |

**监控告警设置**：

```
监控指标：
├─ QPS/TPS实时值
├─ 限流拒绝率
├─ 熔断触发次数
├─ 平均响应时间
└─ 错误率

告警阈值：
├─ 限流拒绝率 > 10% → 🟡 警告
├─ 限流拒绝率 > 30% → 🔴 严重
├─ 熔断触发 → 🔴 立即处理
└─ QPS接近阈值 → 🟡 准备扩容
```

### 8.4 常见问题与解决


**问题1：限流太严，影响业务**
```
现象：大量用户无法访问
原因：阈值设置过低
解决：
├─ 重新压测评估容量
├─ 调高限流阈值
└─ 考虑弹性扩容
```

**问题2：限流太松，系统崩溃**
```
现象：限流形同虚设
原因：阈值高于实际容量
解决：
├─ 压测找到真实容量
├─ 按容量×0.7设置阈值
└─ 添加熔断保护
```

**问题3：熔断频繁触发**
```
现象：服务经常熔断
原因：依赖服务不稳定
解决：
├─ 优化下游服务性能
├─ 增加重试机制
├─ 调整熔断阈值
└─ 实施服务降级
```

**核心记忆**：
- 限流是门卫，熔断是保险丝
- 削峰填谷保稳定，多层防护防雪崩
- QPS看技术，TPS看业务
- 预防为主，应急为辅，组合使用效果佳