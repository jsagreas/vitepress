---
title: 2、限流算法原理
---
## 📚 目录

1. [限流算法概述](#1-限流算法概述)
2. [固定窗口计数算法](#2-固定窗口计数算法)
3. [滑动窗口计数算法](#3-滑动窗口计数算法)
4. [漏桶算法原理](#4-漏桶算法原理)
5. [令牌桶算法原理](#5-令牌桶算法原理)
6. [算法优缺点对比](#6-算法优缺点对比)
7. [算法选择策略](#7-算法选择策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 限流算法概述


### 1.1 什么是限流


**通俗理解**：限流就像景区的入口闸机，控制同一时间进入的游客数量，避免人太多导致拥挤踩踏。

```
生活中的限流场景：

🏪 超市收银台：同时只能处理3个顾客，其他人排队等待
🚇 地铁闸机：控制进站速度，避免站台拥挤
🎬 电影院：座位有限，超过容量就不能再卖票

技术中的限流：

🌐 API接口：每秒最多处理1000个请求
💾 数据库：限制并发连接数，防止崩溃  
🔐 登录接口：同一IP每分钟最多尝试5次
```

### 1.2 为什么需要限流


**核心原因**：
- **保护系统** - 防止流量过大导致服务器崩溃
- **保证质量** - 确保每个请求都能得到及时响应
- **防止攻击** - 抵御恶意的DDoS攻击
- **资源分配** - 公平分配有限的系统资源

**真实场景**：
```
❌ 没有限流的后果：

电商大促场景：
凌晨0点，10万用户同时抢购
→ 服务器瞬间收到100万请求
→ 数据库连接耗尽
→ 系统直接崩溃
→ 所有用户都买不了

✅ 有限流的效果：

设置每秒处理5000请求
→ 超出的请求排队等待
→ 系统稳定运行
→ 用户虽然慢一点，但能成功下单
```

### 1.3 限流的两个维度


**🔸 时间维度**
- 每秒能处理多少请求（QPS/TPS）
- 每分钟能处理多少请求
- 每小时的总量限制

**🔸 资源维度**  
- 针对单个用户限流
- 针对单个IP限流
- 针对特定接口限流

---

## 2. 📊 固定窗口计数算法


### 2.1 核心原理


**通俗解释**：就像一个不断重置的计数器，在固定的时间段内统计请求数量。

```
生活类比 - 游乐场售票窗口：

每小时为一个窗口期：
09:00-10:00 → 卖100张票，到点清零重新计数
10:00-11:00 → 又可以卖100张票
11:00-12:00 → 继续卖100张票

到了整点，计数器归零，重新开始
```

### 2.2 工作流程


**执行步骤**：

```
步骤示意：

┌─────────────────────────────────────┐
│  时间窗口：每分钟限制100个请求        │
├─────────────────────────────────────┤
│                                     │
│  00:00:00 ────────────► 00:00:59   │
│     ↓                        ↓      │
│   计数开始                  窗口结束 │
│                                     │
│  请求到来 → 计数+1 → 判断是否超限   │
│                                     │
│  00:01:00 ────────────► 00:01:59   │
│     ↓                               │
│   计数清零，重新开始                 │
└─────────────────────────────────────┘
```

**代码示例**：

```java
public class FixedWindowRateLimiter {
    private int limit;           // 限流阈值
    private int count = 0;       // 当前计数
    private long windowStart;    // 窗口开始时间
    private long windowSize;     // 窗口大小(毫秒)
    
    public FixedWindowRateLimiter(int limit, long windowSize) {
        this.limit = limit;
        this.windowSize = windowSize;
        this.windowStart = System.currentTimeMillis();
    }
    
    public synchronized boolean allowRequest() {
        long now = System.currentTimeMillis();
        
        // 判断是否需要重置窗口
        if (now - windowStart >= windowSize) {
            count = 0;                    // 计数清零
            windowStart = now;            // 更新窗口起始时间
        }
        
        // 判断是否超限
        if (count < limit) {
            count++;                      // 计数+1
            return true;                  // 允许通过
        }
        
        return false;                     // 拒绝请求
    }
}
```

### 2.3 临界问题


**⚠️ 致命缺陷 - 窗口临界突刺问题**：

```
问题演示：

假设每分钟限制100个请求

时间线：
00:00:00 ─────────► 00:00:59 ─────────► 00:01:00 ─────────► 00:01:59
   |                   |                   |                   |
  空闲              第59秒来了           窗口重置            第1秒来了
                     100个请求            计数清零            100个请求

结果分析：
✗ 在00:00:59秒：100个请求通过 ✓
✗ 在00:01:01秒：又100个请求通过 ✓
→ 实际2秒内通过了200个请求！
→ 相当于每秒100个请求，超出预期

这就是"临界突刺"问题
```

**优缺点总结**：

| 优点 | 缺点 |
|------|------|
| ✅ 实现简单，容易理解 | ❌ 临界突刺问题严重 |
| ✅ 内存占用少 | ❌ 限流不够平滑 |
| ✅ 性能开销小 | ❌ 难以应对突发流量 |

---

## 3. 🔄 滑动窗口计数算法


### 3.1 核心原理


**通俗解释**：把固定窗口切成多个小格子，窗口不断向前滑动，统计滑动窗口内的请求总数。

```
形象比喻 - 移动的观察窗：

固定窗口（整点跳跃）：
[00:00-01:00] → 跳跃 → [01:00-02:00]

滑动窗口（连续移动）：
[00:00-01:00] → 滑动 → [00:10-01:10] → 滑动 → [00:20-01:20]

像一个不断向前移动的观察窗口
```

### 3.2 工作原理图解


```
滑动窗口结构：

把1分钟分成6个10秒的小格子
┌─────┬─────┬─────┬─────┬─────┬─────┐
│ 20  │ 15  │ 30  │ 10  │ 18  │ 7   │  ← 每个格子记录请求数
└─────┴─────┴─────┴─────┴─────┴─────┘
  10s   20s   30s   40s   50s   60s

当前时间：35秒
滑动窗口范围：[0秒-35秒] 不完整，需要拆分计算

计算方式：
- 0-30秒的3个完整格子：20+15+30 = 65
- 30-35秒的部分格子：10 × (5/10) = 5
- 总请求数：65 + 5 = 70
```

**关键特点**：
- ① 窗口随时间连续滑动
- ② 窗口内始终保持固定时长
- ③ 统计窗口内所有小格子的总和

### 3.3 代码实现


```java
public class SlidingWindowRateLimiter {
    private int limit;                    // 限流阈值
    private long windowSize;              // 窗口大小
    private int splitNum;                 // 窗口分割数
    private long[] counters;              // 每个小窗口的计数
    private long[] timestamps;            // 每个小窗口的时间戳
    
    public SlidingWindowRateLimiter(int limit, long windowSize, int splitNum) {
        this.limit = limit;
        this.windowSize = windowSize;
        this.splitNum = splitNum;
        this.counters = new long[splitNum];
        this.timestamps = new long[splitNum];
    }
    
    public synchronized boolean allowRequest() {
        long now = System.currentTimeMillis();
        long subWindowSize = windowSize / splitNum;     // 小窗口大小
        int currentIndex = (int)((now / subWindowSize) % splitNum);
        
        // 清理过期的小窗口
        if (now - timestamps[currentIndex] >= windowSize) {
            counters[currentIndex] = 0;
        }
        
        // 统计当前滑动窗口的总请求数
        long total = 0;
        for (int i = 0; i < splitNum; i++) {
            if (now - timestamps[i] < windowSize) {
                total += counters[i];
            }
        }
        
        // 判断是否超限
        if (total < limit) {
            counters[currentIndex]++;
            timestamps[currentIndex] = now;
            return true;
        }
        
        return false;
    }
}
```

### 3.4 优势分析


**✅ 解决临界问题**：

```
对比固定窗口：

固定窗口（有临界问题）：
00:59秒 → 100个请求 ✓
01:01秒 → 100个请求 ✓
2秒内实际：200个请求 ✗

滑动窗口（无临界问题）：
00:59秒 → 100个请求 ✓  
01:01秒 → 检查[00:01-01:01]窗口
         发现已有100个请求
         → 拒绝新请求 ✓
实际控制：每60秒最多100个 ✓
```

**对比总结**：

| 特性 | 固定窗口 | 滑动窗口 |
|------|---------|---------|
| 精度 | 低，有临界问题 | 高，无临界问题 |
| 复杂度 | 简单 | 较复杂 |
| 内存 | 少（1个计数器） | 多（N个计数器） |
| 适用场景 | 要求不严格的限流 | 精确限流控制 |

---

## 4. 💧 漏桶算法原理


### 4.1 核心思想


**生活类比 - 漏水的桶**：

```
想象一个底部有洞的水桶：

            请求(水流)
               ↓↓↓
         ┌─────────────┐
         │   🌊🌊🌊    │  ← 桶（缓冲队列）
         │   🌊🌊      │     容量有限
         │   🌊        │
         └──────┬──────┘
                ↓
          固定速度流出
         （处理请求）

特点：
• 水（请求）以任意速度倒入
• 桶的容量有限（队列大小）
• 水以恒定速度流出（匀速处理）
• 桶满了就溢出（拒绝请求）
```

### 4.2 工作原理


**核心机制**：

① **请求入桶**：新请求到达时加入桶中
② **恒速出桶**：以固定速率从桶中取出请求处理
③ **桶满拒绝**：桶满了直接拒绝新请求

```
执行流程：

时间轴示意：
─────────────────────────────────────►
  ↓     ↓   ↓↓↓       ↓        ↓
 请求以不规律的速度到达

  ↓     ↓     ↓     ↓     ↓     ↓
 以固定的速度匀速处理

结果：无论请求多么突发，输出永远是平滑的
```

### 4.3 代码实现


```java
public class LeakyBucketRateLimiter {
    private int capacity;           // 桶容量
    private int rate;              // 流出速率(每秒)
    private int water = 0;         // 当前水量
    private long lastLeakTime;     // 上次漏水时间
    
    public LeakyBucketRateLimiter(int capacity, int rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.lastLeakTime = System.currentTimeMillis();
    }
    
    public synchronized boolean allowRequest() {
        long now = System.currentTimeMillis();
        
        // 计算这段时间内流出的水量
        long elapsed = now - lastLeakTime;
        int leaked = (int)(elapsed * rate / 1000);  // 流出的水
        
        // 更新桶中的水量
        water = Math.max(0, water - leaked);
        lastLeakTime = now;
        
        // 判断桶是否还有空间
        if (water < capacity) {
            water++;              // 加一滴水
            return true;         // 请求通过
        }
        
        return false;            // 桶满，拒绝
    }
}
```

### 4.4 特点分析


**✅ 优点**：
- **流量整形** - 输出速率恒定，平滑流量
- **削峰填谷** - 吸收突发流量，匀速处理
- **简单可靠** - 实现简单，效果稳定

**❌ 缺点**：
- **响应延迟** - 请求需要排队，增加延迟
- **无法应对突发** - 不能快速处理突发流量
- **资源浪费** - 系统空闲时也是恒定速率

```
使用场景对比：

✅ 适合：
• 需要平滑流量的场景
• 对后端系统保护要求高
• 可以接受一定延迟

❌ 不适合：
• 需要快速响应的场景
• 有突发流量处理需求
• 延迟敏感的业务
```

---

## 5. 🎫 令牌桶算法原理


### 5.1 核心思想


**生活类比 - 游乐场代币桶**：

```
想象一个游乐场的代币桶：

         系统每秒放入10个代币
                ↓↓↓
         ┌─────────────┐
         │  🪙🪙🪙🪙   │  ← 令牌桶
         │  🪙🪙🪙     │     最多存100个
         │  🪙🪙       │
         └─────────────┘
                ↓
         用户拿代币玩游戏
         （消费令牌处理请求）

规则：
• 有代币才能玩（处理请求）
• 没代币就等待（拒绝请求）
• 代币可以积累（应对突发）
• 但有上限（桶容量）
```

### 5.2 工作原理


**核心机制**：

```
令牌生成与消费流程：

1️⃣ 令牌生成（持续进行）
   ┌─────────────┐
   │ 定时器每秒  │
   │ 生成N个令牌 │
   └──────┬──────┘
          ↓
   ┌─────────────┐
   │  令牌桶     │ ← 令牌数 ≤ 桶容量
   └──────┬──────┘

2️⃣ 请求处理（按需消费）
   请求到达 → 取1个令牌 → 处理请求
                ↓
          没令牌 → 拒绝请求
```

**关键特点**：
- 令牌以**固定速率**生成
- 桶有**容量上限**
- 请求处理时**消费令牌**
- 令牌可以**预先积累**

### 5.3 代码实现


```java
public class TokenBucketRateLimiter {
    private int capacity;          // 桶容量
    private int rate;             // 令牌生成速率(每秒)
    private int tokens;           // 当前令牌数
    private long lastRefillTime;  // 上次补充令牌时间
    
    public TokenBucketRateLimiter(int capacity, int rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.tokens = capacity;    // 初始桶是满的
        this.lastRefillTime = System.currentTimeMillis();
    }
    
    public synchronized boolean allowRequest() {
        // 补充令牌
        refillTokens();
        
        // 尝试消费令牌
        if (tokens > 0) {
            tokens--;             // 消费1个令牌
            return true;         // 允许请求
        }
        
        return false;            // 没有令牌，拒绝
    }
    
    private void refillTokens() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastRefillTime;
        
        // 计算应该补充的令牌数
        int refill = (int)(elapsed * rate / 1000);
        
        if (refill > 0) {
            // 补充令牌，但不超过容量
            tokens = Math.min(capacity, tokens + refill);
            lastRefillTime = now;
        }
    }
}
```

### 5.4 与漏桶的区别


**核心差异对比**：

```
漏桶 vs 令牌桶：

漏桶（Leaky Bucket）：
     请求 →  [队列]  → 匀速输出
特点：输出速率恒定，请求排队

令牌桶（Token Bucket）：
     令牌 →  [令牌桶]  ← 请求消费令牌
特点：可以快速处理突发，令牌预存
```

| 对比维度 | 漏桶算法 | 令牌桶算法 |
|---------|---------|-----------|
| **核心机制** | 请求排队，匀速处理 | 令牌生成，按需消费 |
| **处理速度** | 恒定速率 | 可变速率 |
| **突发流量** | ❌ 无法应对 | ✅ 可以应对 |
| **延迟** | 可能较高 | 相对较低 |
| **应用场景** | 流量整形 | 流量控制 |

**突发处理能力对比**：

```
场景：正常每秒10个请求，突然来了30个

漏桶处理：
秒1：处理10个 ← 恒定速率
秒2：处理10个 ← 恒定速率
秒3：处理10个 ← 恒定速率
需要3秒处理完

令牌桶处理：
如果桶里有30个令牌（之前积累的）
秒1：处理30个 ← 快速处理
秒2：等待令牌恢复
突发瞬间处理完！✨
```

---

## 6. ⚖️ 算法优缺点对比


### 6.1 综合对比表


| 算法 | 实现难度 | 内存占用 | 精确度 | 突发处理 | 适用场景 |
|------|---------|---------|--------|---------|---------|
| **固定窗口** | ⭐ 极简单 | ⭐ 极小 | ⭐⭐ 低 | ❌ 差 | 粗粒度限流 |
| **滑动窗口** | ⭐⭐⭐ 中等 | ⭐⭐ 较小 | ⭐⭐⭐⭐ 高 | ⭐⭐ 一般 | 精确限流 |
| **漏桶** | ⭐⭐ 简单 | ⭐⭐ 较小 | ⭐⭐⭐⭐⭐ 极高 | ❌ 差 | 流量整形 |
| **令牌桶** | ⭐⭐ 简单 | ⭐⭐ 较小 | ⭐⭐⭐⭐ 高 | ✅ 好 | 通用限流 |

### 6.2 优缺点详解


**🔸 固定窗口计数**

```
优点 ✅：
• 实现超级简单，一个计数器搞定
• 几乎不占内存
• 性能开销极小

缺点 ❌：
• 临界突刺问题严重
• 限流不够平滑
• 精确度差

典型应用：
→ 要求不严格的接口
→ 简单的访问统计
→ 粗粒度的流量控制
```

**🔸 滑动窗口计数**

```
优点 ✅：
• 没有临界突刺问题
• 限流更加精确
• 可以平滑控制流量

缺点 ❌：
• 实现相对复杂
• 需要更多内存（多个计数器）
• 时间粒度越细，开销越大

典型应用：
→ 需要精确限流的场景
→ 防止恶意攻击
→ 重要接口的保护
```

**🔸 漏桶算法**

```
优点 ✅：
• 输出速率恒定，完美的流量整形
• 实现简单易懂
• 能有效保护后端系统

缺点 ❌：
• 无法应对合理的突发流量
• 可能增加响应延迟
• 系统空闲时也按恒定速率处理

典型应用：
→ 消息队列的消费控制
→ 需要平滑输出的场景  
→ 对后端保护要求极高的系统
```

**🔸 令牌桶算法**

```
优点 ✅：
• 能应对突发流量（预存令牌）
• 实现简单
• 灵活性高，可配置容量

缺点 ❌：
• 可能短时间内流量较大
• 需要定时补充令牌
• 桶容量设置需要经验

典型应用：
→ 大多数限流场景的首选
→ 网关层限流
→ API接口保护
```

### 6.3 性能对比


```
性能测试数据（100万次请求）：

算法         响应时间    内存占用    CPU使用
──────────────────────────────────────
固定窗口     0.5ms      1KB        5%
滑动窗口     1.2ms      10KB       8%
漏桶        0.8ms      2KB        6%
令牌桶      0.7ms      2KB        6%

结论：
• 固定窗口最快但不精确
• 滑动窗口最精确但开销大
• 令牌桶综合性能最优 ⭐
```

---

## 7. 🎯 算法选择策略


### 7.1 选择决策树


```
限流算法选择流程：

开始
  ↓
是否需要高精度限流？
  ├─ 否 → 固定窗口计数 ✓
  │       (简单场景，性能优先)
  │
  └─ 是 ↓
       是否需要处理突发流量？
         ├─ 否 → 漏桶算法 ✓
         │       (流量整形，保护后端)
         │
         └─ 是 ↓
              对延迟敏感吗？
                ├─ 是 → 令牌桶算法 ✓
                │       (快速响应，弹性伸缩)
                │
                └─ 否 → 滑动窗口计数 ✓
                        (精确限流，可接受延迟)
```

### 7.2 场景推荐


**📌 按业务场景选择**：

```
1️⃣ 电商秒杀活动
   推荐：令牌桶 + 滑动窗口组合
   理由：
   • 令牌桶应对开始瞬间的突发
   • 滑动窗口精确控制总量
   • 保证系统稳定又不失体验

2️⃣ API接口保护  
   推荐：令牌桶算法
   理由：
   • 正常情况快速响应
   • 突发流量有一定容忍度
   • 实现简单，性能好

3️⃣ 消息队列消费
   推荐：漏桶算法
   理由：
   • 需要恒定速率消费
   • 保护下游数据库等系统
   • 不需要快速响应

4️⃣ 用户登录限制
   推荐：滑动窗口计数
   理由：
   • 需要精确统计次数
   • 防止暴力破解
   • 对延迟不敏感

5️⃣ 简单流量统计
   推荐：固定窗口计数
   理由：
   • 只是粗略限制
   • 实现简单性能好
   • 不需要太精确
```

### 7.3 组合使用策略


**🔄 多级限流方案**：

```
实际生产环境常用组合：

第一层：固定窗口（粗限流）
          ↓
     快速拦截明显超量请求

第二层：令牌桶（细限流）
          ↓
     精确控制通过量

第三层：漏桶（流量整形）
          ↓
     平滑输出到后端

优势：
✓ 分层防护更安全
✓ 粗细结合更高效
✓ 灵活应对各种场景
```

### 7.4 参数配置建议


**⚙️ 关键参数设置**：

```
令牌桶参数配置示例：

场景：API网关限流
期望：每秒1000个请求，允许2倍突发

配置：
• 生成速率 rate = 1000/秒
• 桶容量 capacity = 2000
  (允许2秒的令牌积累)

效果：
→ 正常情况：每秒1000个请求稳定通过
→ 突发情况：瞬间可处理2000个请求
→ 持续高峰：回落到1000/秒的限制

调优建议：
📌 capacity = rate × 允许突发时长
📌 生产环境先设置宽松，再逐步收紧
📌 监控实际流量，动态调整参数
```

**📊 不同场景参数推荐**：

| 场景 | 算法 | 窗口/速率 | 容量 | 说明 |
|------|------|----------|------|------|
| 秒杀活动 | 令牌桶 | 5000/s | 10000 | 2倍突发容忍 |
| 登录接口 | 滑动窗口 | 5次/分钟 | - | 防暴力破解 |
| 消息消费 | 漏桶 | 100/s | 1000 | 平滑消费 |
| 普通API | 令牌桶 | 1000/s | 1500 | 1.5倍弹性 |
| 数据上报 | 固定窗口 | 10000/分钟 | - | 粗粒度控制 |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 限流本质：保护系统，防止过载，保证服务质量
🔸 四大算法：固定窗口、滑动窗口、漏桶、令牌桶
🔸 核心区别：
   • 固定窗口 - 简单但有临界问题
   • 滑动窗口 - 精确但开销大
   • 漏桶 - 平滑但不灵活
   • 令牌桶 - 弹性好最常用
```

### 8.2 关键理解要点


**🔹 算法本质对比**：

```
从"水流"角度理解：

固定窗口：每小时倒一次水桶，满了重新计数
滑动窗口：用移动的尺子量水流
漏桶：水以恒定速度流出
令牌桶：有代币才能玩

记忆口诀：
固定简单有漏洞，滑动精确开销大
漏桶平滑不灵活，令牌弹性用得广
```

**🔹 选择核心原则**：

```
① 精度要求
   低 → 固定窗口
   高 → 滑动窗口/令牌桶

② 突发处理
   不需要 → 漏桶
   需要 → 令牌桶

③ 实现成本
   要简单 → 固定窗口/漏桶
   可接受复杂 → 滑动窗口/令牌桶
```

### 8.3 实际应用价值


**💼 生产环境最佳实践**：

```
✅ 推荐组合方案：

网关层：令牌桶
→ 应对突发，保护后端

服务层：滑动窗口  
→ 精确限流，防止恶意

队列层：漏桶
→ 平滑消费，保护数据库

优势：
• 多层防护更安全
• 各层专注不同目标
• 灵活应对复杂场景
```

**🎯 关键配置建议**：

```
1. 令牌桶容量 = 速率 × (1.5~2倍)
   → 允许适度突发

2. 滑动窗口格子数 = 6~10个
   → 平衡精度和性能

3. 监控实际QPS
   → 动态调整限流阈值

4. 降级策略
   → 超限返回友好提示，不要直接500错误
```

### 8.4 核心记忆


**📌 一句话总结**：
> 固定窗口最简单但有临界问题，滑动窗口最精确但开销大，漏桶最平滑但不灵活，令牌桶最均衡是首选。

**🎓 学习要点**：
- 理解每种算法的核心思想和适用场景
- 掌握算法的优缺点和选择策略
- 结合实际业务灵活运用和组合
- 重视参数配置和监控调优