---
title: 2、网关核心功能
---
## 📚 目录

1. [请求路由转发](#1-请求路由转发)
2. [负载均衡调度](#2-负载均衡调度)
3. [认证授权鉴权](#3-认证授权鉴权)
4. [限流熔断降级](#4-限流熔断降级)
5. [监控日志审计](#5-监控日志审计)
6. [协议转换适配](#6-协议转换适配)
7. [跨域处理支持](#7-跨域处理支持)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚦 请求路由转发


### 1.1 什么是路由转发


> **💡 核心理解**  
> 路由转发就像**快递分拣中心**，根据包裹上的地址把快递送到不同的配送站。API网关根据请求的URL把请求转发给对应的微服务。

**🔸 基础概念**
```
用户请求：http://api.shop.com/user/login
           ↓
        API网关
           ↓
   识别路径 /user/*
           ↓
   转发到用户服务：http://user-service:8001/login
```

**路由规则的本质**：
- **路径匹配**：根据URL路径判断该找哪个服务
- **自动转发**：网关帮你把请求送到正确的服务器
- **统一入口**：外部只需要知道网关地址，不用管后面有多少个服务

### 1.2 路由配置方式


**🔹 基于路径的路由**（最常用）

```yaml
# Spring Cloud Gateway 配置示例
spring:
  cloud:
    gateway:
      routes:
        - id: user-service          # 路由名称
          uri: lb://user-service    # 目标服务（lb代表负载均衡）
          predicates:
            - Path=/user/**         # 匹配规则：/user开头的请求
        
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/order/**        # 匹配 /order 开头的请求
```

**理解要点**：
- `Path=/user/**` 表示：以`/user/`开头的所有请求都会转发到用户服务
- `lb://` 表示通过**负载均衡**方式访问服务（后面会详细讲）
- 一个网关可以配置多条路由规则

**🔹 基于请求方法的路由**

```yaml
routes:
  - id: get-orders
    uri: lb://order-query-service
    predicates:
      - Method=GET              # 只匹配GET请求
      - Path=/orders/**
  
  - id: create-order
    uri: lb://order-write-service
    predicates:
      - Method=POST             # 只匹配POST请求
      - Path=/orders/**
```

**实际应用场景**：读写分离
- **查询请求**（GET）→ 专门的查询服务（优化读性能）
- **写入请求**（POST/PUT）→ 专门的写入服务（保证数据一致性）

### 1.3 路由转发流程


```
步骤1：接收请求
用户 → http://api.shop.com/user/profile
       ↓
步骤2：匹配路由规则
网关检查配置：/user/** → 匹配到 user-service
       ↓
步骤3：重写URL路径（可选）
原始：/user/profile
重写：/profile  （去掉/user前缀）
       ↓
步骤4：转发请求
网关 → http://user-service:8001/profile
       ↓
步骤5：返回响应
用户 ← 网关 ← user-service
```

**⚠️ 常见问题**

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| **404找不到服务** | 路由规则配置错误 | 检查Path匹配是否正确 |
| **路径重复** | 多个规则匹配同一路径 | 调整规则顺序，精确匹配放前面 |
| **转发超时** | 目标服务响应慢 | 设置合理的超时时间 |

---

## 2. ⚖️ 负载均衡调度


### 2.1 为什么需要负载均衡


> **🎯 实际场景**  
> 一个服务部署了3台服务器，如何让请求**均匀分配**到这3台服务器上，避免某一台压力过大？这就是负载均衡要解决的问题。

**问题示例**：
```
假设订单服务部署了3个实例：
Server1: 192.168.1.10:8001
Server2: 192.168.1.11:8001  
Server3: 192.168.1.12:8001

如果所有请求都发到Server1：
Server1 → [■■■■■■■■■■] 100% CPU（崩溃）
Server2 → [░░░░░░░░░░]   0% CPU（空闲）
Server3 → [░░░░░░░░░░]   0% CPU（空闲）

负载均衡后：
Server1 → [■■■░░░░░░░]  33% CPU
Server2 → [■■■░░░░░░░]  33% CPU
Server3 → [■■■░░░░░░░]  33% CPU
```

### 2.2 负载均衡策略


**🔸 轮询策略（Round Robin）** - 最简单常用

```
请求分配过程：
请求1 → Server1
请求2 → Server2
请求3 → Server3
请求4 → Server1  （循环开始）
请求5 → Server2
...
```

**优点**：简单公平，每台服务器分到的请求差不多  
**缺点**：不考虑服务器性能差异

**🔸 加权轮询（Weighted Round Robin）**

```yaml
# Ribbon配置示例（Spring Cloud）
order-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule
```

**应用场景**：
```
Server1: 8核16G内存 → 权重5
Server2: 4核8G内存  → 权重3
Server3: 2核4G内存  → 权重2

分配结果（按权重比例）：
10个请求中，Server1处理5个，Server2处理3个，Server3处理2个
```

**🔸 最少连接（Least Connections）**

```
当前状态：
Server1 → 当前处理10个请求
Server2 → 当前处理15个请求
Server3 → 当前处理5个请求

新请求到来 → 分配给Server3（因为它最空闲）
```

**适用场景**：请求处理时间差异大的场景（比如有的查询快，有的查询慢）

### 2.3 实战配置


**Spring Cloud Gateway + Nacos 负载均衡**

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-service
          uri: lb://order-service    # lb:// 自动启用负载均衡
          predicates:
            - Path=/order/**

# Nacos服务发现（自动获取服务实例列表）
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
```

**工作流程**：
1. 网关从**Nacos注册中心**获取`order-service`的所有实例地址
2. 使用**轮询策略**选择一个实例
3. 转发请求到选中的实例
4. 如果某个实例下线，Nacos会自动通知网关移除该实例

---

## 3. 🔐 认证授权鉴权


### 3.1 三个概念的区别


> **🧠 记忆要点**  
> **认证**（Authentication）：你是谁？验证身份  
> **授权**（Authorization）：你能做什么？验证权限  
> **鉴权**（Permission）：检查你有没有权限做这件事

**生活类比**：
```
认证 → 刷身份证进小区（证明你是业主）
授权 → 物业给你门禁卡（赋予你进出权限）
鉴权 → 刷卡开门（检查你有没有这个权限）
```

### 3.2 常见认证方式


**🔸 Token认证（最常用）**

```
登录流程：
1. 用户登录 → 用户名+密码
2. 验证成功 → 服务器生成Token
3. 返回Token → eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
4. 客户端保存Token → 存储在localStorage或Cookie

后续请求：
请求头携带：Authorization: Bearer <token>
网关验证Token → 通过则放行，失败则返回401
```

**Token的好处**：
- ✅ 无状态：服务器不用记录谁登录了
- ✅ 可扩展：Token里可以包含用户信息
- ✅ 跨域友好：不依赖Cookie

**🔸 JWT（JSON Web Token）认证**

```java
// JWT Token结构（简化示例）
Header（头部）：
{
  "alg": "HS256",      // 加密算法
  "typ": "JWT"         // Token类型
}

Payload（负载）：
{
  "userId": 10001,     // 用户ID
  "username": "张三",   // 用户名
  "role": "admin",     // 角色
  "exp": 1705996800    // 过期时间
}

Signature（签名）：用密钥加密，防止篡改
```

**网关JWT验证逻辑**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/**
          filters:
            - JwtAuthenticationFilter  # 自定义JWT验证过滤器
```

### 3.3 权限控制（RBAC）


**🔹 基于角色的访问控制（Role-Based Access Control）**

```
角色定义：
- admin（管理员）  → 可以做任何事
- user（普通用户）  → 只能访问自己的数据
- guest（游客）    → 只能浏览公开内容

权限分配：
admin  → [查看用户, 删除用户, 修改配置]
user   → [查看自己信息, 修改自己信息]
guest  → [查看公开内容]
```

**网关权限验证**：
```java
// 伪代码示例
public boolean checkPermission(String path, String role) {
    if (path.startsWith("/admin") && !"admin".equals(role)) {
        return false;  // 非管理员不能访问管理接口
    }
    return true;
}
```

**⚠️ 注意事项**

| 场景 | 问题 | 解决方案 |
|------|------|----------|
| **Token泄露** | 被别人拿到Token可以冒充 | 设置短过期时间+刷新机制 |
| **Token过期** | 用户操作中突然要重新登录 | 实现Token自动刷新 |
| **权限变更** | 修改权限后Token还是旧的 | Token加入版本号或强制重新登录 |

---

## 4. 🛡️ 限流熔断降级


### 4.1 为什么需要这三个机制


> **📝 实际场景**  
> 电商大促时，瞬间涌入百万用户，系统扛不住怎么办？

**三个机制的关系**：

```
正常情况：
用户请求 → 网关 → 微服务 → 数据库
[正常][正常][正常][正常]

流量激增：
限流 → 控制进入的请求数量（不让系统被压垮）
      ↓
熔断 → 服务出问题时暂时停止调用（防止连锁反应）
      ↓
降级 → 返回备用方案（保证基本可用）
```

### 4.2 限流（Rate Limiting）


**🔸 固定窗口限流**（最简单）

```
规则：1秒内最多处理100个请求

时间窗口：
第1秒：处理100个请求 ✓
第2秒：处理100个请求 ✓
第3秒：来了150个请求 → 前100个通过，后50个拒绝 ✗
```

**配置示例**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/order/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10  # 每秒允许10个请求
                redis-rate-limiter.burstCapacity: 20   # 最大突发容量20
```

**🔸 令牌桶算法**（更灵活）

```
工作原理（生活类比）：
想象一个桶，每秒钟往里面放10个令牌
用户请求需要先拿到令牌才能通过

正常情况：
请求来了 → 拿走1个令牌 → 通过 ✓

流量激增：
瞬间来了100个请求 → 只有20个令牌 → 只放行20个 ✓
                                   其余80个拒绝 ✗
```

**优点**：可以应对突发流量（允许短时间超过平均速率）

### 4.3 熔断（Circuit Breaker）


**🔸 熔断状态机**

```
[关闭状态] → 正常调用服务
      ↓ (错误率超过50%)
[打开状态] → 直接返回失败，不再调用
      ↓ (等待30秒)
[半开状态] → 尝试调用，如果成功则恢复
      ↓
[关闭状态] → 恢复正常
```

**Resilience4j 配置**：
```yaml
resilience4j:
  circuitbreaker:
    instances:
      orderService:
        failureRateThreshold: 50          # 失败率超过50%时熔断
        waitDurationInOpenState: 30s      # 熔断30秒后尝试恢复
        slidingWindowSize: 10             # 基于最近10次请求判断
```

**🎯 实际效果**：
```
服务A调用服务B：
正常：A → B → 返回数据 ✓

服务B故障：
连续5次调用失败 → 熔断器打开
A直接返回错误（不再调用B）→ 避免资源浪费

30秒后：
熔断器半开 → 尝试调用B → 成功 → 恢复正常
```

### 4.4 降级（Fallback）


**🔸 降级策略**

```
优先级方案：
┌─────────────────────────────┐
│ Level 1: 核心功能（始终可用）│  ← 订单支付
├─────────────────────────────┤
│ Level 2: 重要功能（可降级）  │  ← 商品推荐
├─────────────────────────────┤
│ Level 3: 次要功能（可关闭）  │  ← 评论展示
└─────────────────────────────┘

大促时：
关闭Level 3功能，保证Level 1和Level 2正常运行
```

**代码示例**：
```java
@FeignClient(name = "product-service", fallback = ProductFallback.class)
public interface ProductClient {
    @GetMapping("/product/{id}")
    Product getProduct(@PathVariable Long id);
}

// 降级处理
@Component
public class ProductFallback implements ProductClient {
    @Override
    public Product getProduct(Long id) {
        // 返回缓存数据或默认数据
        return Product.builder()
            .id(id)
            .name("商品暂时无法加载")
            .price(0.0)
            .build();
    }
}
```

---

## 5. 📊 监控日志审计


### 5.1 为什么需要监控


> **💡 核心理解**  
> 就像汽车的仪表盘，能实时看到车速、油量、温度。网关监控让我们知道系统运行是否正常，出问题能快速定位。

**监控的三个层次**：

| 层次 | 关注指标 | 用途 |
|------|---------|------|
| **请求级** | 响应时间、状态码、流量 | 了解用户体验 |
| **服务级** | CPU、内存、调用次数 | 判断服务健康度 |
| **业务级** | 订单量、支付成功率 | 业务运营决策 |

### 5.2 关键监控指标


**🔸 性能指标**

```
QPS（每秒查询数）：
正常：1000 QPS
大促：10000 QPS  ← 需要扩容

响应时间（RT）：
P50：50ms   ← 50%的请求在50ms内完成
P95：200ms  ← 95%的请求在200ms内完成
P99：500ms  ← 99%的请求在500ms内完成

目标：P95 < 200ms（保证大部分用户体验好）
```

**🔸 错误率指标**

```
状态码分布：
2xx（成功）：95%  ✓
4xx（客户端错误）：3%
5xx（服务器错误）：2%  ✗ 需要关注

告警规则：
5xx错误率 > 5% → 立即告警
响应时间 > 1秒 → 告警
```

### 5.3 日志管理


**🔹 访问日志（Access Log）**

```json
{
  "timestamp": "2025-01-23T10:30:45",
  "clientIp": "192.168.1.100",
  "method": "GET",
  "path": "/api/order/12345",
  "statusCode": 200,
  "responseTime": 125,
  "userAgent": "Mozilla/5.0..."
}
```

**用途**：
- 统计接口访问量
- 分析用户行为
- 排查问题时回溯请求

**🔹 错误日志（Error Log）**

```json
{
  "timestamp": "2025-01-23T10:31:20",
  "level": "ERROR",
  "service": "order-service",
  "message": "数据库连接超时",
  "stackTrace": "java.sql.SQLException...",
  "requestId": "req-abc123"  // 请求追踪ID
}
```

**⚡ 快速排查技巧**：
```
通过requestId关联所有日志：
1. 用户反馈订单失败
2. 找到对应requestId
3. 搜索该ID的所有日志
4. 定位到具体错误位置
```

### 5.4 监控工具集成


**常用监控方案**：

```
Prometheus + Grafana：
网关 → 暴露metrics端点 
     ↓
Prometheus → 采集指标数据
     ↓
Grafana → 可视化展示（漂亮的图表）
```

**配置示例**：
```yaml
# Spring Boot Actuator暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
  metrics:
    export:
      prometheus:
        enabled: true
```

---

## 6. 🔄 协议转换适配


### 6.1 为什么需要协议转换


> **📝 实际场景**  
> 老系统用**SOAP/XML**协议，新系统用**RESTful/JSON**，网关可以做"翻译官"，让它们互相通信。

**协议转换的价值**：
```
前端（JSON）← 网关 → 后端A（XML）
                 ↓
             后端B（gRPC）
                 ↓
             后端C（WebSocket）

网关统一对外提供JSON接口，内部自动转换协议
```

### 6.2 常见协议转换


**🔸 HTTP → gRPC**

```
前端请求：
POST /api/user/create
Content-Type: application/json
{
  "name": "张三",
  "age": 25
}

网关转换后：
调用gRPC服务：
service UserService {
  rpc CreateUser(UserRequest) returns (UserResponse);
}

自动转换：JSON → Protobuf格式
```

**🔸 REST → SOAP**

```yaml
# Gateway配置
spring:
  cloud:
    gateway:
      routes:
        - id: legacy-service
          uri: http://old-service.com/soap
          predicates:
            - Path=/api/legacy/**
          filters:
            - RestToSoapFilter  # 自定义过滤器
```

**转换逻辑**：
```
REST请求 → 构造SOAP XML → 调用旧服务 → 解析XML响应 → 转JSON返回
```

### 6.3 数据格式转换


**🔹 XML ↔ JSON**

```java
// 输入：XML格式
<user>
  <id>1001</id>
  <name>张三</name>
</user>

// 网关转换
JSONObject json = XML.toJSONObject(xmlString);

// 输出：JSON格式
{
  "user": {
    "id": 1001,
    "name": "张三"
  }
}
```

**🔹 消息编码转换**

```
场景：对接第三方支付接口
第三方要求：GBK编码
我方系统：UTF-8编码

网关处理：
请求时：UTF-8 → GBK
响应时：GBK → UTF-8
```

---

## 7. 🌐 跨域处理支持


### 7.1 什么是跨域问题


> **🎯 生活类比**  
> 你在A小区的门禁不能刷开B小区的门，浏览器的"同源策略"就像这个门禁系统，不允许跨域访问。

**跨域场景**：
```
前端页面：http://www.shop.com (端口80)
API接口：http://api.shop.com (端口8080)

浏览器检测：域名相同，但端口不同 → 跨域 ✗
拒绝访问，报错：CORS错误
```

**同源策略规则**：
- ✅ 协议相同（http vs https）
- ✅ 域名相同（www.a.com vs www.b.com）
- ✅ 端口相同（80 vs 8080）

**任何一个不同 → 跨域 → 浏览器拦截**

### 7.2 CORS解决方案


**🔸 网关统一配置CORS**

```yaml
spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':  # 对所有路径生效
            allowedOrigins: "*"              # 允许所有域名访问
            allowedMethods:                  # 允许的HTTP方法
              - GET
              - POST
              - PUT
              - DELETE
            allowedHeaders: "*"              # 允许所有请求头
            allowCredentials: true           # 允许携带Cookie
            maxAge: 3600                     # 预检请求缓存1小时
```

**🔸 响应头详解**

```
浏览器发起预检请求（OPTIONS）：
OPTIONS /api/user/login
Origin: http://www.shop.com

网关返回CORS头：
Access-Control-Allow-Origin: http://www.shop.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 3600

浏览器检查通过 → 发起真正的请求
```

### 7.3 预检请求优化


**❓ 常见疑问：什么是预检请求？**

```
简单请求（不触发预检）：
- GET、POST、HEAD方法
- 常见Content-Type
- 无自定义请求头

复杂请求（触发预检）：
- PUT、DELETE方法
- Content-Type: application/json
- 自定义Authorization头

浏览器行为：
复杂请求前 → 先发OPTIONS请求询问是否允许 → 允许才发真请求
```

**优化方案**：
```yaml
# 设置预检缓存时间
maxAge: 86400  # 缓存24小时

效果：
第1次请求：OPTIONS + POST（2次请求）
后续请求：POST（直接请求，省略OPTIONS）
```

---

## 8. 📋 核心要点总结


### 8.1 七大核心功能关系图


```
                    API网关
                      │
        ┌─────────────┼─────────────┐
        │             │             │
    路由转发      认证鉴权      协议转换
        │             │             │
        ↓             ↓             ↓
    负载均衡      监控日志      跨域处理
        │             │             │
        └─────────────┼─────────────┘
                      │
                  限流熔断降级
```

### 8.2 功能选择指南


| 场景 | 推荐功能 | 配置优先级 |
|------|---------|-----------|
| **新系统上线** | 路由转发 + 负载均衡 | ⭐⭐⭐⭐⭐ |
| **安全要求高** | 认证授权 + 监控审计 | ⭐⭐⭐⭐⭐ |
| **高并发场景** | 限流 + 熔断 + 降级 | ⭐⭐⭐⭐⭐ |
| **前后端分离** | 跨域处理 | ⭐⭐⭐⭐ |
| **系统对接** | 协议转换 | ⭐⭐⭐ |

### 8.3 实施步骤建议


**🔹 阶段1：基础能力（第1周）**
1. 配置路由转发规则
2. 接入服务注册中心（Nacos）
3. 启用负载均衡

**🔹 阶段2：安全加固（第2周）**
1. 集成JWT认证
2. 配置权限验证
3. 添加访问日志

**🔹 阶段3：高可用（第3周）**
1. 配置限流规则
2. 启用熔断降级
3. 接入监控告警

**🔹 阶段4：优化增强（第4周）**
1. 配置CORS支持
2. 添加协议转换（如需）
3. 性能调优

### 8.4 常见问题速查


**❓ 请求转发失败？**
- 检查路由规则是否匹配
- 确认目标服务是否启动
- 查看网关日志排查

**❓ 认证一直失败？**
- 确认Token格式正确
- 检查密钥配置是否一致
- 验证Token是否过期

**❓ 跨域还是报错？**
- 确认CORS配置生效
- 检查allowedOrigins是否包含前端域名
- 验证preflight请求是否通过

**❓ 限流不生效？**
- 检查Redis连接是否正常
- 确认限流规则配置正确
- 验证requestId是否唯一

**🔑 核心记忆口诀**：
```
路由转发找对门，负载均衡分压力
认证鉴权守大门，限流熔断保稳定
监控日志明察暗访，协议转换做翻译
跨域配置开绿灯，七剑合璧护网关
```

---

**📚 学习建议**：
- **先理解概念**：知道每个功能是做什么的
- **再看配置**：理解配置项的含义
- **最后实战**：动手配置一个简单的网关
- **逐步完善**：从基础功能开始，慢慢加功能

**🎯 下一步学习**：
- 深入学习Spring Cloud Gateway原理
- 了解常见网关产品对比（Zuul、Kong、APISIX）
- 实践网关性能优化技巧