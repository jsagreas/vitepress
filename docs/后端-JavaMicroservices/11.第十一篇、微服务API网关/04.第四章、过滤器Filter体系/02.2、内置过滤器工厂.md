---
title: 2、内置过滤器工厂
---
## 📚 目录

1. [内置过滤器概述](#1-内置过滤器概述)
2. [请求/响应头操作过滤器](#2-请求响应头操作过滤器)
3. [请求参数操作过滤器](#3-请求参数操作过滤器)
4. [路径操作过滤器](#4-路径操作过滤器)
5. [请求控制过滤器](#5-请求控制过滤器)
6. [过滤器使用总结](#6-过滤器使用总结)

---

## 1. 🎯 内置过滤器概述


### 1.1 什么是内置过滤器


**通俗理解**：内置过滤器就像是Gateway给你准备好的一套"工具箱"，每个工具都有特定的功能，直接拿来用就行，不用自己造轮子。

```
类比理解：
开发微服务网关 = 装修房子
内置过滤器 = 五金工具店的现成工具
- 需要改门牌号？用"路径重写"工具
- 需要加个门铃？用"添加请求头"工具  
- 需要限制房间大小？用"请求大小限制"工具
```

### 1.2 为什么需要内置过滤器


**实际问题场景**：
- 🔸 **问题1**：前端请求需要统一添加Token认证头，每个微服务都要处理？
- 🔸 **解决**：用`AddRequestHeader`在网关统一添加

- 🔸 **问题2**：旧接口路径是`/v1/user`，新版本是`/user`，如何兼容？
- 🔸 **解决**：用`RewritePath`在网关层做路径转换

- 🔸 **问题3**：某些大文件上传需要限制大小，如何统一控制？
- 🔸 **解决**：用`RequestSize`在网关层统一限流

**核心价值**：
```
✅ 统一处理：在网关层统一处理横切关注点
✅ 简化开发：微服务专注业务逻辑，不用重复造轮子
✅ 灵活配置：通过配置文件即可实现功能，无需编码
```

### 1.3 内置过滤器分类


| 分类 | **主要功能** | **典型过滤器** | **使用频率** |
|------|------------|--------------|------------|
| 🔧 **头部操作** | `修改请求/响应头信息` | AddRequestHeader、AddResponseHeader | `⭐⭐⭐⭐⭐` |
| 📝 **参数操作** | `添加/修改请求参数` | AddRequestParameter | `⭐⭐⭐⭐` |
| 🔀 **路径操作** | `重写、添加、删除路径` | RewritePath、StripPrefix | `⭐⭐⭐⭐⭐` |
| 🚦 **流程控制** | `重定向、状态码设置` | Redirect、SetStatus | `⭐⭐⭐` |
| 🛡️ **安全限制** | `请求大小限制` | RequestSize | `⭐⭐⭐⭐` |

---

## 2. 📨 请求/响应头操作过滤器


### 2.1 AddRequestHeader - 添加请求头


**🔸 它是做什么的？**
在请求发送到下游微服务之前，自动添加指定的HTTP请求头。

**💡 实际应用场景**：
```
场景1：统一添加认证信息
网关收到请求 → 添加Token头 → 转发给微服务
好处：微服务不用关心Token从哪来，只管验证

场景2：添加请求追踪ID
网关收到请求 → 生成TraceId → 添加到请求头 → 转发
好处：方便全链路日志追踪
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/user/**
          filters:
            # 添加固定值的请求头
            - AddRequestHeader=X-Request-Source, Gateway
            # 添加动态值的请求头（支持SpEL表达式）
            - AddRequestHeader=X-Request-Time, #{T(java.time.LocalDateTime).now()}
```

**📋 参数说明**：
- `第一个参数`：请求头的名称（Key）
- `第二个参数`：请求头的值（Value），支持SpEL表达式

**🎯 实际效果**：
```
原始请求：
GET /api/user/info HTTP/1.1
Host: gateway.example.com

经过过滤器后：
GET /api/user/info HTTP/1.1
Host: user-service
X-Request-Source: Gateway         ← 新添加的请求头
X-Request-Time: 2025-09-23T10:30:00  ← 动态生成的时间
```

### 2.2 AddResponseHeader - 添加响应头


**🔸 它是做什么的？**
在网关返回响应给客户端之前，自动添加指定的HTTP响应头。

**💡 实际应用场景**：
```
场景1：添加跨域头
微服务返回数据 → 网关添加CORS头 → 返回给前端
好处：统一处理跨域，微服务不用配置

场景2：添加缓存控制头
微服务返回静态数据 → 网关添加Cache-Control → 浏览器缓存
好处：优化性能，减少重复请求
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: api-service
          uri: lb://api-service
          filters:
            # 添加跨域响应头
            - AddResponseHeader=Access-Control-Allow-Origin, *
            # 添加缓存控制
            - AddResponseHeader=Cache-Control, max-age=3600
            # 添加服务器标识
            - AddResponseHeader=X-Powered-By, Spring Cloud Gateway
```

**🎯 实际效果**：
```
微服务原始响应：
HTTP/1.1 200 OK
Content-Type: application/json

经过过滤器后：
HTTP/1.1 200 OK
Content-Type: application/json
Access-Control-Allow-Origin: *           ← 新添加
Cache-Control: max-age=3600              ← 新添加
X-Powered-By: Spring Cloud Gateway       ← 新添加
```

### 2.3 MapRequestHeader - 请求头映射


**🔸 它是做什么的？**
把一个请求头的值复制到另一个请求头中，相当于给请求头"换个名字"。

**💡 实际应用场景**：
```
场景：兼容不同微服务的请求头命名
前端发送：Authorization: Bearer xxx
老版本微服务需要：X-Auth-Token: Bearer xxx
新版本微服务需要：Authorization: Bearer xxx

解决方案：用MapRequestHeader将Authorization映射到X-Auth-Token
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: legacy-service
          uri: lb://legacy-service
          filters:
            # 将Authorization头映射到X-Auth-Token
            - MapRequestHeader=Authorization, X-Auth-Token
```

**📋 参数说明**：
- `第一个参数`：源请求头名称（从哪里复制）
- `第二个参数`：目标请求头名称（复制到哪里）

**🎯 实际效果**：
```
原始请求：
GET /api/data HTTP/1.1
Authorization: Bearer token123

经过过滤器后：
GET /api/data HTTP/1.1
Authorization: Bearer token123        ← 保留原头
X-Auth-Token: Bearer token123        ← 新增映射头
```

**⚠️ 注意事项**：
- 映射不会删除原请求头，只是复制一份
- 如果目标头已存在，会被覆盖

---

## 3. 📝 请求参数操作过滤器


### 3.1 AddRequestParameter - 添加请求参数


**🔸 它是做什么的？**
在请求的URL上自动添加查询参数（Query Parameter），就像在网址后面加上`?key=value`。

**💡 实际应用场景**：
```
场景1：自动添加客户端标识
前端请求：/api/products
网关处理后：/api/products?source=web
好处：微服务能知道请求来自哪个端

场景2：统一添加版本号
前端请求：/api/user/list
网关处理后：/api/user/list?api_version=v2
好处：方便版本控制和统计
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
          filters:
            # 添加固定参数
            - AddRequestParameter=source, gateway
            # 添加动态参数（支持SpEL表达式）
            - AddRequestParameter=timestamp, #{T(System).currentTimeMillis()}
```

**📋 参数说明**：
- `第一个参数`：参数名（Key）
- `第二个参数`：参数值（Value），支持SpEL动态表达式

**🎯 实际效果**：
```
原始请求：
GET /api/products?category=phone

经过过滤器后：
GET /api/products?category=phone&source=gateway&timestamp=1695456000000
                  ↑原有参数      ↑新添加的参数
```

**⚠️ 注意事项**：
```
✅ 只对GET请求和URL参数生效
✅ 不会修改POST请求的Body参数
❌ 如果参数已存在，会添加多个同名参数（变成数组）
```

---

## 4. 🔀 路径操作过滤器


### 4.1 RewritePath - 路径重写


**🔸 它是做什么的？**
把请求的URL路径按照规则进行替换转换，就像把门牌号改成另一个。

**💡 实际应用场景**：
```
场景1：版本号兼容
前端请求：/v1/api/users
微服务实际路径：/users
解决：用RewritePath去掉/v1/api前缀

场景2：统一路径规范
前端请求：/api/user-service/getUser
微服务路径：/user/info
解决：用正则表达式重写路径
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/v1/api/**
          filters:
            # 路径重写：去掉/v1/api前缀
            - RewritePath=/v1/api/(?<segment>.*), /$\{segment}
```

**📋 参数说明**：
- `第一个参数`：正则表达式，匹配原路径
- `第二个参数`：替换模板，`$\{segment}`引用捕获组

**🎯 实际效果示例**：

```
示例1：去掉版本号
原始请求：/v1/api/users/123
正则匹配：/v1/api/(?<segment>.*)
捕获内容：segment = users/123
重写结果：/users/123

示例2：复杂路径转换
原始请求：/api/user-service/getUser/123
正则匹配：/api/user-service/(?<action>.*)/(?<id>.*)
捕获内容：action=getUser, id=123
重写模板：/user/$\{id}/$\{action}
重写结果：/user/123/getUser
```

**🔍 正则表达式详解**：
```
常用符号说明：
(?<name>pattern)  命名捕获组，捕获内容可用${name}引用
.*               匹配任意字符（除换行符）
[^/]+            匹配除/外的字符（常用于匹配路径段）
\d+              匹配数字

实用模板：
去掉前缀：/prefix/(?<segment>.*), /${segment}
交换路径：/api/(?<service>.*)/(?<method>.*), /${method}/${service}
```

### 4.2 StripPrefix - 前缀删除


**🔸 它是做什么的？**
删除URL路径开头的若干段，比`RewritePath`更简单直接。

**💡 实际应用场景**：
```
场景：微服务不需要/api前缀
前端统一请求：/api/user/info
用户服务路径：/user/info
订单服务路径：/order/list

解决：StripPrefix=1 删除第一段/api
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/user/**
          filters:
            # 删除路径的第1段（/api）
            - StripPrefix=1
            
        - id: order-service  
          uri: lb://order-service
          predicates:
            - Path=/gateway/api/order/**
          filters:
            # 删除路径的前2段（/gateway/api）
            - StripPrefix=2
```

**📋 参数说明**：
- `数字参数`：删除路径前N段（段是以`/`分隔的）

**🎯 实际效果**：
```
路径段理解：
/api/user/info
 ↑1  ↑2   ↑3    段数从1开始数

示例1：StripPrefix=1
原始：/api/user/info
删除：第1段 /api
结果：/user/info

示例2：StripPrefix=2  
原始：/gateway/api/order/list
删除：前2段 /gateway/api
结果：/order/list
```

**⚠️ 使用建议**：
```
✅ 简单场景优先用StripPrefix（配置简单）
✅ 复杂场景用RewritePath（功能强大）
❌ 不要删除超过实际段数，会导致路径变成/
```

### 4.3 PrefixPath - 前缀添加


**🔸 它是做什么的？**
在URL路径前面统一添加前缀，与`StripPrefix`相反。

**💡 实际应用场景**：
```
场景：微服务要求统一前缀
前端请求：/user/info
微服务要求：/api/v1/user/info

解决：PrefixPath=/api/v1
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: legacy-service
          uri: http://legacy.example.com
          predicates:
            - Path=/user/**
          filters:
            # 添加前缀/api/v1
            - PrefixPath=/api/v1
```

**🎯 实际效果**：
```
原始请求：/user/info
添加前缀：/api/v1
结果路径：/api/v1/user/info
```

### 4.4 RewriteLocationResponseHeader - 响应位置重写


**🔸 它是做什么的？**
重写响应头中的`Location`字段，主要用于处理重定向场景。

**💡 实际应用场景**：
```
场景：微服务重定向地址需要转换
微服务返回：Location: http://internal-service/callback
客户端需要：Location: http://gateway.com/api/callback

问题：客户端无法访问内部服务地址
解决：重写Location头的域名和路径
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: auth-service
          uri: lb://auth-service
          filters:
            # 重写Location响应头
            # stripVersionMode: 去除版本号的模式
            # locationHeaderName: Location头的名称
            # hostValue: 要替换的主机值
            - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, ,
```

**📋 参数说明**：
```
格式：RewriteLocationResponseHeader=stripVersionMode, locationHeaderName, hostValue, protocolsRegex

参数1 - stripVersionMode（版本去除模式）：
  NEVER：不去除版本号
  AS_IN_REQUEST：根据原始请求决定
  ALWAYS：总是去除版本号

参数2 - locationHeaderName：
  要重写的响应头名称，通常是Location

参数3 - hostValue：  
  替换的主机值（可选，空表示使用请求的主机）

参数4 - protocolsRegex：
  协议正则表达式（可选）
```

**🎯 实际效果**：
```
原始响应：
HTTP/1.1 302 Found
Location: http://auth-service:8080/callback

经过过滤器后：
HTTP/1.1 302 Found  
Location: http://gateway.example.com/callback
```

---

## 5. 🚦 请求控制过滤器


### 5.1 Redirect - 重定向


**🔸 它是做什么的？**
直接在网关层进行HTTP重定向，把请求导向另一个URL，不经过微服务。

**💡 实际应用场景**：
```
场景1：HTTP强制跳转HTTPS
用户访问：http://api.example.com/login
自动跳转：https://api.example.com/login

场景2：旧域名跳转新域名  
用户访问：old.example.com
自动跳转：new.example.com

场景3：维护页面跳转
服务维护期间统一跳转到维护提示页
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        # HTTP跳转HTTPS
        - id: http-to-https
          uri: no://op
          predicates:
            - Path=/**
          filters:
            # 302临时重定向到HTTPS
            - Redirect=302, https://api.example.com
            
        # 旧路径跳转新路径
        - id: old-to-new
          uri: no://op  
          predicates:
            - Path=/old-api/**
          filters:
            # 301永久重定向
            - Redirect=301, https://api.example.com/new-api
```

**📋 参数说明**：
```
格式：Redirect=status, url

参数1 - status（HTTP状态码）：
  301：永久重定向（浏览器会缓存）
  302：临时重定向（推荐使用）
  303：使用GET方法重定向
  307：保持原请求方法重定向

参数2 - url：
  重定向的目标URL（完整URL或相对路径）
```

**🎯 状态码选择指南**：
```
301 - 永久重定向
✅ 适合：域名永久迁移、URL规范永久调整
❌ 注意：浏览器会缓存，不易修改

302 - 临时重定向  
✅ 适合：临时维护、AB测试、灵活调整
✅ 推荐：大多数场景使用302更安全

307 - 保持方法重定向
✅ 适合：需要保持POST/PUT等方法的场景
```

**⚠️ 注意事项**：
- `uri: no://op`是个占位符，表示不真正转发
- 重定向会增加一次HTTP请求
- 301重定向浏览器会缓存，慎用

### 5.2 SetStatus - 设置状态码


**🔸 它是做什么的？**
修改网关返回的HTTP状态码，用于统一响应规范或兼容场景。

**💡 实际应用场景**：
```
场景1：统一成功状态码
微服务返回：200、201、204
前端期望：统一200
解决：用SetStatus=200强制统一

场景2：自定义业务状态码
正常业务：返回200
业务异常：返回自定义状态码290
解决：SetStatus=290
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: api-service
          uri: lb://api-service
          filters:
            # 固定状态码
            - SetStatus=200
            
            # 使用HTTP状态枚举
            - SetStatus=UNAUTHORIZED  # 401
            - SetStatus=NOT_FOUND     # 404
```

**📋 参数说明**：
```
方式1：直接数字
- SetStatus=200
- SetStatus=404
- SetStatus=500

方式2：Spring HttpStatus枚举
- SetStatus=OK              # 200
- SetStatus=CREATED         # 201  
- SetStatus=UNAUTHORIZED    # 401
- SetStatus=NOT_FOUND       # 404
- SetStatus=INTERNAL_SERVER_ERROR  # 500
```

**🎯 常用状态码**：
| 状态码 | 枚举值 | 含义 | 使用场景 |
|-------|-------|------|---------|
| `200` | OK | 成功 | `统一成功响应` |
| `201` | CREATED | 已创建 | `资源创建成功` |
| `401` | UNAUTHORIZED | 未授权 | `Token失效` |
| `403` | FORBIDDEN | 禁止访问 | `权限不足` |
| `404` | NOT_FOUND | 未找到 | `资源不存在` |
| `500` | INTERNAL_SERVER_ERROR | 服务器错误 | `系统异常` |

### 5.3 RequestSize - 请求大小限制


**🔸 它是做什么的？**
限制HTTP请求体的最大大小，防止大文件上传占用资源或攻击。

**💡 实际应用场景**：
```
场景1：防止大文件攻击
限制单次请求最大10MB，防止恶意上传超大文件

场景2：不同服务不同限制
文件服务：允许100MB
普通API：限制1MB
```

**🔧 配置方式**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        # 普通API限制1MB
        - id: api-service
          uri: lb://api-service
          predicates:
            - Path=/api/**
          filters:
            - name: RequestSize
              args:
                maxSize: 1MB
                
        # 文件服务限制100MB      
        - id: file-service
          uri: lb://file-service
          predicates:
            - Path=/upload/**
          filters:
            - name: RequestSize
              args:
                maxSize: 100MB
```

**📋 大小单位说明**：
```
支持的单位（不区分大小写）：
- B  / bytes   字节
- KB / kilobytes  千字节（1KB = 1024B）
- MB / megabytes  兆字节（1MB = 1024KB）
- GB / gigabytes  吉字节（1GB = 1024MB）

写法示例：
maxSize: 1048576      # 字节数
maxSize: 1MB          # 1兆
maxSize: 10MB         # 10兆
maxSize: 500KB        # 500千字节
```

**🎯 实际效果**：
```
配置：maxSize: 5MB

请求1：Content-Length: 3MB
结果：✅ 通过，正常转发

请求2：Content-Length: 6MB  
结果：❌ 拒绝
响应：HTTP 413 Payload Too Large
```

**⚠️ 注意事项**：
```
✅ 同时检查Content-Length和实际传输大小
✅ 对所有HTTP方法生效（GET、POST、PUT等）
❌ 不会检查分块传输（Transfer-Encoding: chunked）的总大小
🔧 建议配合Nginx等反向代理做二次限制
```

**🛡️ 安全建议**：
```
推荐配置：
1. 全局默认限制（如5MB）
2. 特定服务单独配置（文件服务放宽）
3. 结合限流、熔断等防护措施
4. 记录超限请求日志，监控异常
```

---

## 6. 📋 过滤器使用总结


### 6.1 核心过滤器速查表


| 过滤器 | 主要作用 | 使用频率 | 典型场景 |
|--------|---------|---------|---------|
| **AddRequestHeader** | `添加请求头` | ⭐⭐⭐⭐⭐ | `Token认证、链路追踪` |
| **AddResponseHeader** | `添加响应头` | ⭐⭐⭐⭐ | `CORS跨域、缓存控制` |
| **AddRequestParameter** | `添加URL参数` | ⭐⭐⭐ | `版本标识、来源标记` |
| **RewritePath** | `路径正则重写` | ⭐⭐⭐⭐⭐ | `版本兼容、路径转换` |
| **StripPrefix** | `删除路径前缀` | ⭐⭐⭐⭐⭐ | `去除/api前缀` |
| **PrefixPath** | `添加路径前缀` | ⭐⭐⭐ | `统一添加版本号` |
| **Redirect** | `重定向` | ⭐⭐⭐ | `HTTP跳HTTPS、域名迁移` |
| **SetStatus** | `设置状态码` | ⭐⭐ | `统一状态码规范` |
| **RequestSize** | `限制请求大小` | ⭐⭐⭐⭐ | `防止大文件攻击` |
| **RewriteLocationResponseHeader** | `重写Location头` | ⭐⭐ | `重定向地址转换` |
| **MapRequestHeader** | `请求头映射` | ⭐⭐ | `兼容不同命名规范` |

### 6.2 实战配置模板


**🔸 标准Web应用配置**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: web-api
          uri: lb://web-service
          predicates:
            - Path=/api/**
          filters:
            # 去掉/api前缀
            - StripPrefix=1
            # 添加网关标识
            - AddRequestHeader=X-Gateway, SpringCloudGateway
            # 添加请求追踪ID
            - AddRequestHeader=X-Trace-Id, #{T(java.util.UUID).randomUUID().toString()}
            # 添加CORS头
            - AddResponseHeader=Access-Control-Allow-Origin, *
            # 限制请求5MB
            - name: RequestSize
              args:
                maxSize: 5MB
```

**🔸 文件上传服务配置**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: file-upload
          uri: lb://file-service  
          predicates:
            - Path=/upload/**
          filters:
            # 路径重写
            - RewritePath=/upload/(?<segment>.*), /file/$\{segment}
            # 放宽大小限制
            - name: RequestSize
              args:
                maxSize: 100MB
            # 添加上传来源
            - AddRequestParameter=source, gateway
```

**🔸 HTTPS强制跳转配置**：
```yaml
spring:
  cloud:
    gateway:
      routes:
        # HTTP请求重定向到HTTPS
        - id: http-redirect
          uri: no://op
          predicates:
            - Path=/**
            # 只匹配HTTP协议
            - Header=X-Forwarded-Proto, http
          filters:
            - Redirect=301, https://${spring.cloud.gateway.httpsserver}
```

### 6.3 过滤器组合策略


**🔸 过滤器执行顺序**：
```
请求流程：
客户端请求 
  ↓
全局过滤器（Global Filters）
  ↓  
路由过滤器（Route Filters）- 按配置顺序执行
  ↓
微服务
  ↓
路由过滤器（响应处理）- 逆序执行
  ↓
全局过滤器（响应处理）
  ↓
返回客户端

配置顺序 = 执行顺序！
```

**🔸 常用组合模式**：

```yaml
# 模式1：认证+路径重写+限流
filters:
  - AddRequestHeader=Authorization, Bearer ${token}  # 1. 添加认证
  - RewritePath=/api/v1/(?<path>.*), /$\{path}      # 2. 路径转换
  - name: RequestRateLimiter                         # 3. 限流
    args:
      redis-rate-limiter.replenishRate: 10
      
# 模式2：跨域+缓存+追踪      
filters:
  - AddRequestHeader=X-Trace-Id, #{T(java.util.UUID).randomUUID()}  # 追踪
  - AddResponseHeader=Access-Control-Allow-Origin, *                # 跨域
  - AddResponseHeader=Cache-Control, max-age=3600                   # 缓存
```

### 6.4 常见问题与解决


**❓ 问题1：过滤器不生效？**
```
检查清单：
☐ 路由配置的predicates是否匹配请求
☐ 过滤器配置格式是否正确（缩进、参数）
☐ 是否与全局过滤器冲突
☐ 查看Gateway日志确认过滤器是否执行
```

**❓ 问题2：RewritePath正则不匹配？**
```
调试技巧：
1. 使用在线正则工具测试表达式
2. 注意YAML中需要转义特殊字符
3. 捕获组命名要用(?<name>pattern)格式
4. 引用捕获组用$\{name}（注意转义）
```

**❓ 问题3：多个过滤器冲突？**
```
解决思路：
- 检查过滤器执行顺序
- 避免多个过滤器修改同一属性
- 使用order属性调整优先级（数字越小越先执行）

示例：
- name: AddRequestHeader
  args:
    name: X-Custom
    value: test
  order: 1  # 优先级设置
```

### 6.5 最佳实践建议


**✅ 推荐做法**：
```
1. 统一管理：把常用过滤器配置抽取为全局过滤器
2. 参数化配置：使用${配置项}引用配置，便于环境切换
3. 日志记录：关键过滤器操作记录日志
4. 异常处理：配置全局异常处理器
5. 性能监控：监控过滤器执行耗时
```

**❌ 避免陷阱**：
```
1. 不要过度使用过滤器：影响性能
2. 不要在过滤器中做复杂业务逻辑：应该在微服务中处理
3. 不要忘记处理异常情况：添加熔断降级
4. 不要滥用正则表达式：优先使用简单过滤器
```

**🎯 配置建议**：
```yaml
# 推荐的配置结构
spring:
  cloud:
    gateway:
      # 全局默认过滤器
      default-filters:
        - AddRequestHeader=X-Gateway-Version, 1.0.0
        - name: RequestSize
          args:
            maxSize: 5MB
            
      # 具体路由配置      
      routes:
        - id: service-a
          uri: lb://service-a
          predicates:
            - Path=/service-a/**
          filters:
            # 只配置特定需求的过滤器
            - StripPrefix=1
```

---

## 📌 核心知识点总结


### 必须掌握的概念

```
🔸 内置过滤器：Gateway提供的开箱即用的功能组件
🔸 过滤器分类：头部操作、参数操作、路径操作、请求控制
🔸 配置方式：YAML配置，支持SpEL表达式
🔸 执行顺序：全局过滤器 → 路由过滤器（配置顺序）
```

### 实际应用要点

```
✅ 统一处理横切关注点（认证、日志、限流）
✅ 简化微服务开发，让服务专注业务逻辑  
✅ 灵活组合使用，满足不同场景需求
✅ 注意性能影响，避免过度使用
```

### 记忆口诀

```
内置过滤好帮手，统一处理在网关
头部参数路径改，重定向和限大小
配置简单功能强，组合使用要有方
顺序重要莫忘记，日志监控保平安
```