---
title: 5、过滤器实战场景
---
## 📚 目录

1. [过滤器实战概述](#1-过滤器实战概述)
2. [统一鉴权认证](#2-统一鉴权认证)
3. [请求参数校验](#3-请求参数校验)
4. [响应数据脱敏](#4-响应数据脱敏)
5. [接口调用审计](#5-接口调用审计)
6. [性能监控统计](#6-性能监控统计)
7. [黑白名单控制](#7-黑白名单控制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 过滤器实战概述


### 1.1 什么是过滤器实战场景


**通俗理解**：就像现实中的安检门一样，过滤器在API网关中充当"守门员"角色。

```
现实类比：
机场安检流程 → API网关过滤器链
   ↓                    ↓
证件检查         →    身份认证过滤器
行李扫描         →    参数校验过滤器
违禁品检测       →    黑名单过滤器
VIP通道         →    限流降级过滤器
```

### 1.2 为什么需要过滤器


**核心价值**：
- 🛡️ **统一管理**：把通用逻辑集中处理，不用每个服务都写一遍
- ⚡ **提升效率**：在网关层就拦截非法请求，避免浪费后端资源
- 🔒 **安全保障**：统一的安全策略，降低被攻击风险
- 📊 **便于监控**：集中收集日志和指标，问题排查更方便

### 1.3 六大实战场景


| 场景 | **作用** | **类比** | **优先级** |
|------|---------|---------|-----------|
| 🔐 **鉴权认证** | `验证用户身份` | `门禁卡验证` | 🔴 最高 |
| ✅ **参数校验** | `检查请求合法性` | `表单检查` | 🟡 高 |
| 🎭 **数据脱敏** | `隐藏敏感信息` | `身份证打码` | 🟡 高 |
| 📝 **调用审计** | `记录操作日志` | `监控录像` | 🟢 中 |
| 📊 **性能监控** | `统计接口指标` | `计时器` | 🟢 中 |
| 🚫 **名单控制** | `拦截恶意请求` | `黑名单拦截` | 🔴 最高 |

---

## 2. 🔐 统一鉴权认证


### 2.1 鉴权认证是什么


**通俗解释**：就像进入小区需要刷门禁卡，访问API也需要验证"你是谁"和"你有没有权限"。

```
生活场景对比：

进小区：               访问API：
刷门禁卡    →        携带Token令牌
物业验证卡片 →        网关验证Token
验证通过放行 →        验证通过转发请求
验证失败拦截 →        验证失败返回401
```

### 2.2 认证流程实现


**认证步骤**：
1. **提取令牌**：从请求头中获取Token
2. **验证令牌**：检查Token是否有效
3. **获取身份**：解析出用户信息
4. **权限判断**：检查是否有访问权限

**流程图示**：
```
客户端请求
    ↓
[1] 过滤器提取Token
    ↓
[2] 验证Token合法性
    ↓
Token有效？
    ↓                ↓
   是               否
    ↓                ↓
解析用户信息    返回401未授权
    ↓
检查访问权限
    ↓
有权限？
    ↓                ↓
   是               否
    ↓                ↓
放行请求        返回403禁止访问
```

### 2.3 代码实现示例


**鉴权过滤器实现**：
```java
@Component
public class AuthFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 提取Token
        String token = exchange.getRequest()
            .getHeaders()
            .getFirst("Authorization");
        
        // 2. 验证Token
        if (token == null || !isValidToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        // 3. 解析用户信息并放行
        String userId = parseUserId(token);
        ServerHttpRequest request = exchange.getRequest().mutate()
            .header("User-Id", userId)
            .build();
        
        return chain.filter(exchange.mutate().request(request).build());
    }
    
    @Override
    public int getOrder() {
        return -100; // 优先级最高，最先执行
    }
}
```

**关键点说明**：
- `Authorization`：标准的Token传递方式
- `mutate()`：修改请求，将用户ID传给后端服务
- `Order = -100`：优先级高，确保第一个执行

### 2.4 常见认证方式


**JWT令牌认证**（最常用）：
```
特点：
✅ 无状态：服务器不存储Session
✅ 跨域友好：适合分布式系统
✅ 性能好：无需查询数据库

Token结构：
Header.Payload.Signature
头部  .载荷  .签名
```

**OAuth2认证**（第三方登录）：
```
适用场景：
- 微信登录
- QQ登录
- GitHub登录

优势：
✅ 安全性高
✅ 用户体验好
✅ 无需记密码
```

### 2.5 实战注意事项


> ⚠️ **安全提示**
> - Token要设置过期时间，避免被盗用
> - 敏感操作要双重验证（如支付）
> - 使用HTTPS加密传输

> 💡 **性能优化**
> - Token验证结果可以缓存
> - 使用Redis存储黑名单Token
> - 避免每次都查询数据库

---

## 3. ✅ 请求参数校验


### 3.1 参数校验的作用


**通俗理解**：就像填表单时的格式检查，确保提交的数据是合法的。

```
类比理解：

注册表单校验           API参数校验
   ↓                      ↓
手机号11位    →     参数长度限制
邮箱格式正确   →     正则表达式验证
密码强度要求   →     字段类型检查
必填项检查     →     必传参数检查
```

### 3.2 为什么要在网关校验


**提前拦截的好处**：
- ⚡ **节省资源**：非法请求不会到达后端服务
- 🛡️ **防止攻击**：SQL注入、XSS等恶意代码
- 📉 **降低负载**：减少后端服务压力

### 3.3 校验规则实现


**常见校验规则**：
```java
@Component
public class ParamValidateFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 1. 必传参数校验
        if (!hasRequiredParams(request)) {
            return returnError(exchange, "缺少必传参数");
        }
        
        // 2. 参数格式校验
        if (!isValidFormat(request)) {
            return returnError(exchange, "参数格式错误");
        }
        
        // 3. 参数长度校验
        if (!isValidLength(request)) {
            return returnError(exchange, "参数长度超限");
        }
        
        return chain.filter(exchange);
    }
}
```

### 3.4 实战校验案例


**案例1：用户注册接口**
```
校验项：
① 手机号：11位数字
② 密码：8-16位，包含字母和数字
③ 验证码：6位数字

校验逻辑：
if (phone不是11位数字) {
    返回"手机号格式错误"
}
if (password长度不符 或 不包含字母数字) {
    返回"密码强度不够"
}
if (验证码不是6位) {
    返回"验证码格式错误"
}
```

**案例2：商品查询接口**
```
校验项：
① pageSize：1-100之间
② price：正数
③ category：从预定义列表中选择

错误示例：
pageSize = 1000  → 超出限制
price = -50      → 负数非法
category = "xxx" → 不在列表中
```

### 3.5 高级校验技巧


> 💡 **正则表达式校验**
> ```java
> // 手机号校验
> String phoneRegex = "^1[3-9]\\d{9}$";
> 
> // 邮箱校验
> String emailRegex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$";
> 
> // 身份证校验
> String idCardRegex = "^\\d{17}[0-9Xx]$";
> ```

> ⚠️ **SQL注入防护**
> ```java
> // 检测SQL关键字
> String[] sqlKeywords = {"select", "drop", "delete", "update"};
> 
> for (String keyword : sqlKeywords) {
>     if (param.toLowerCase().contains(keyword)) {
>         return "参数包含非法字符";
>     }
> }
> ```

---

## 4. 🎭 响应数据脱敏


### 4.1 数据脱敏是什么


**通俗理解**：就像发朋友圈时自动给身份证打马赛克，保护隐私信息不被泄露。

```
生活中的脱敏：          API响应脱敏：
手机号：138****5678  →  mobile: "138****5678"
身份证：410***********1234 → idCard: "410***********1234"
银行卡：6222 **** **** 1234 → cardNo: "6222********1234"
```

### 4.2 为什么需要脱敏


**安全风险**：
- 📱 **个人隐私**：手机号、身份证泄露
- 💳 **金融安全**：银行卡、密码暴露
- 🔐 **商业机密**：价格、数量等敏感数据

**脱敏场景示例**：
```
场景1：用户列表查询
原始数据：
{
  "name": "张三",
  "phone": "13800138000",
  "idCard": "410123199001011234"
}

脱敏后：
{
  "name": "张三",
  "phone": "138****8000",
  "idCard": "410***********1234"
}

场景2：订单详情
原始：cardNo: "6222021234567890"
脱敏：cardNo: "6222********7890"
```

### 4.3 脱敏规则实现


**脱敏过滤器**：
```java
@Component
public class DataMaskFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            // 获取响应体
            ServerHttpResponse response = exchange.getResponse();
            DataBuffer buffer = response.bufferFactory().wrap(getResponseBody());
            
            // 脱敏处理
            String body = new String(buffer.asByteBuffer().array());
            String maskedBody = maskSensitiveData(body);
            
            // 写回响应
            response.writeWith(Mono.just(buffer));
        }));
    }
    
    // 脱敏规则
    private String maskSensitiveData(String data) {
        data = maskPhone(data);    // 手机号脱敏
        data = maskIdCard(data);   // 身份证脱敏
        data = maskBankCard(data); // 银行卡脱敏
        return data;
    }
}
```

### 4.4 常用脱敏规则


**脱敏规则表**：

| 数据类型 | **脱敏规则** | **示例** |
|---------|------------|---------|
| 📱 **手机号** | `保留前3后4` | 138****5678 |
| 🆔 **身份证** | `保留前3后4` | 410***********1234 |
| 💳 **银行卡** | `保留前4后4` | 6222********1234 |
| 📧 **邮箱** | `@前保留1位` | a***@qq.com |
| 🏠 **地址** | `保留省市` | 北京市朝阳区*** |

**脱敏工具方法**：
```java
public class MaskUtil {
    
    // 手机号脱敏
    public static String maskPhone(String phone) {
        if (phone.length() != 11) return phone;
        return phone.substring(0, 3) + "****" + phone.substring(7);
    }
    
    // 身份证脱敏
    public static String maskIdCard(String idCard) {
        if (idCard.length() != 18) return idCard;
        return idCard.substring(0, 3) + "***********" + idCard.substring(14);
    }
    
    // 银行卡脱敏
    public static String maskBankCard(String cardNo) {
        if (cardNo.length() < 8) return cardNo;
        return cardNo.substring(0, 4) + "********" + cardNo.substring(cardNo.length() - 4);
    }
}
```

### 4.5 动态脱敏策略


> 💡 **根据角色决定脱敏程度**
> ```
> 普通用户：全部脱敏
> VIP用户：部分脱敏
> 管理员：不脱敏
> 
> 示例：
> if (用户角色 == "管理员") {
>     显示完整数据
> } else if (用户角色 == "VIP") {
>     显示部分数据
> } else {
>     全部脱敏
> }
> ```

---

## 5. 📝 接口调用审计


### 5.1 什么是调用审计


**通俗理解**：就像银行流水记录每一笔交易，审计记录每一次API调用。

```
银行流水记录            API调用审计
    ↓                      ↓
谁操作        →       调用者身份
操作什么      →       接口路径
什么时间      →       调用时间
操作结果      →       响应状态
金额多少      →       数据大小
```

### 5.2 审计的价值


**核心作用**：
- 🔍 **问题排查**：快速定位哪个接口出了问题
- 📊 **数据分析**：统计接口调用频率和趋势
- 🛡️ **安全审计**：发现异常访问和攻击行为
- 📈 **业务洞察**：了解用户行为和偏好

### 5.3 审计记录内容


**必记录项**：
```
基础信息：
① 请求ID：唯一标识一次调用
② 调用时间：精确到毫秒
③ 调用者：用户ID或IP地址
④ 接口路径：/api/user/login

请求信息：
⑤ 请求方法：GET/POST/PUT/DELETE
⑥ 请求参数：参数内容（脱敏后）
⑦ 请求头：重要的Header信息

响应信息：
⑧ 响应状态：200/404/500
⑨ 响应时间：耗时多少毫秒
⑩ 响应大小：数据量大小
```

### 5.4 审计实现方式


**审计过滤器**：
```java
@Component
public class AuditFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        
        // 构建审计日志
        AuditLog log = buildAuditLog(exchange, startTime);
        
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            // 记录结束时间和响应状态
            log.setEndTime(System.currentTimeMillis());
            log.setCostTime(log.getEndTime() - startTime);
            log.setStatus(exchange.getResponse().getStatusCode().value());
            
            // 异步保存日志
            auditLogService.saveAsync(log);
        }));
    }
    
    private AuditLog buildAuditLog(ServerWebExchange exchange, long startTime) {
        ServerHttpRequest request = exchange.getRequest();
        
        return AuditLog.builder()
            .requestId(UUID.randomUUID().toString())
            .path(request.getPath().value())
            .method(request.getMethod().name())
            .userId(request.getHeaders().getFirst("User-Id"))
            .ip(request.getRemoteAddress().getHostString())
            .startTime(startTime)
            .build();
    }
}
```

### 5.5 审计日志存储


**存储方案对比**：

| 方案 | **优点** | **缺点** | **适用场景** |
|------|---------|---------|-------------|
| 📁 **文件** | `实现简单` | `查询不便` | 小型系统 |
| 🗄️ **MySQL** | `查询方便` | `写入压力大` | 中型系统 |
| 📊 **ES** | `检索强大` | `成本较高` | 大型系统 |
| 📝 **日志系统** | `专业工具` | `学习成本` | 企业级 |

> 💡 **推荐方案**
> - 实时日志：写入Kafka → 消费到ES
> - 历史归档：定期归档到对象存储
> - 热数据：ES保留7天
> - 冷数据：对象存储长期保存

---

## 6. 📊 性能监控统计


### 6.1 性能监控是什么


**通俗理解**：就像汽车仪表盘显示速度、油耗，监控显示API的响应时间、吞吐量。

```
汽车仪表盘              API性能监控
    ↓                      ↓
速度表         →       响应时间
油耗表         →       资源占用
温度表         →       错误率
里程表         →       调用次数
```

### 6.2 监控指标体系


**核心指标**：
```
性能指标：
📈 QPS：每秒请求数
⏱️ 响应时间：平均/最大/P99
💾 数据量：请求/响应大小

质量指标：
✅ 成功率：成功/失败比例
❌ 错误率：各类错误统计
⏳ 超时率：超时请求占比

资源指标：
🖥️ CPU：使用率
💽 内存：占用情况
🌐 带宽：流量统计
```

### 6.3 监控实现方式


**监控过滤器**：
```java
@Component
public class MetricsFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        Timer.Sample sample = Timer.start(meterRegistry);
        
        return chain.filter(exchange)
            .doOnSuccess(v -> {
                // 记录成功指标
                sample.stop(Timer.builder("api.requests")
                    .tag("path", path)
                    .tag("status", "success")
                    .register(meterRegistry));
            })
            .doOnError(e -> {
                // 记录失败指标
                sample.stop(Timer.builder("api.requests")
                    .tag("path", path)
                    .tag("status", "error")
                    .register(meterRegistry));
            });
    }
}
```

### 6.4 性能数据统计


**统计维度**：
```
时间维度：
- 实时：当前QPS、响应时间
- 分钟：最近1分钟平均值
- 小时：最近1小时趋势
- 天：每日统计报表

接口维度：
- 单个接口：详细性能数据
- 服务维度：整个服务统计
- 全局维度：网关整体情况

用户维度：
- 按用户统计：个人调用情况
- 按IP统计：IP访问频率
- 按地域统计：区域分布
```

### 6.5 性能告警机制


> ⚠️ **告警规则示例**
> ```
> 告警级别：
> 
> 🔴 紧急告警：
> - 错误率 > 10%
> - P99响应时间 > 3秒
> - 可用性 < 99%
> 
> 🟡 警告提醒：
> - 错误率 > 5%
> - P99响应时间 > 1秒
> - QPS突增100%
> 
> 🟢 信息通知：
> - 新接口上线
> - 流量达到阈值
> ```

**告警通知方式**：
```
即时通知：
- 短信：紧急问题
- 电话：严重故障
- 企业微信/钉钉：一般告警

定时报告：
- 日报：每日性能汇总
- 周报：周趋势分析
- 月报：月度总结
```

---

## 7. 🚫 黑白名单控制


### 7.1 黑白名单是什么


**通俗理解**：就像小区的门禁系统，白名单是业主可以进，黑名单是禁止入内的人。

```
门禁系统                黑白名单控制
    ↓                      ↓
业主名单       →       IP白名单
黑名单人员     →       IP黑名单
访客登记       →       临时授权
可疑人员拦截   →       异常IP拦截
```

### 7.2 名单类型说明


**黑名单**（拒绝访问）：
```
使用场景：
🚫 恶意攻击IP：发起DDoS攻击
🚫 爬虫IP：恶意采集数据
🚫 异常用户：频繁失败登录
🚫 违规操作：触发风控规则

拦截策略：
命中黑名单 → 直接返回403
不查后端 → 节省资源
记录日志 → 便于分析
```

**白名单**（放行访问）：
```
使用场景：
✅ 内部IP：公司办公网段
✅ 合作伙伴：第三方系统
✅ VIP用户：高级会员
✅ 管理后台：运营人员

放行策略：
命中白名单 → 跳过其他检查
优先级高 → 第一时间放行
灵活配置 → 动态调整
```

### 7.3 名单实现方式


**黑白名单过滤器**：
```java
@Component
public class IpListFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    // 白名单Key
    private static final String WHITE_LIST = "ip:white:list";
    // 黑名单Key
    private static final String BLACK_LIST = "ip:black:list";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String ip = getClientIp(exchange);
        
        // 1. 检查黑名单
        if (isInBlackList(ip)) {
            return returnForbidden(exchange, "IP已被封禁");
        }
        
        // 2. 检查白名单（可选）
        if (isWhiteListMode() && !isInWhiteList(ip)) {
            return returnForbidden(exchange, "IP未授权");
        }
        
        return chain.filter(exchange);
    }
    
    private boolean isInBlackList(String ip) {
        return redisTemplate.opsForSet().isMember(BLACK_LIST, ip);
    }
    
    private boolean isInWhiteList(String ip) {
        return redisTemplate.opsForSet().isMember(WHITE_LIST, ip);
    }
    
    @Override
    public int getOrder() {
        return -200; // 优先级很高，仅次于认证
    }
}
```

### 7.4 动态名单管理


**名单操作接口**：
```java
@RestController
@RequestMapping("/admin/iplist")
public class IpListController {
    
    // 添加黑名单
    @PostMapping("/black/add")
    public Result addBlackList(@RequestParam String ip, 
                               @RequestParam String reason) {
        redisTemplate.opsForSet().add(BLACK_LIST, ip);
        // 记录操作日志
        logOperation("添加黑名单", ip, reason);
        return Result.success();
    }
    
    // 移除黑名单
    @PostMapping("/black/remove")
    public Result removeBlackList(@RequestParam String ip) {
        redisTemplate.opsForSet().remove(BLACK_LIST, ip);
        logOperation("移除黑名单", ip, null);
        return Result.success();
    }
    
    // 批量导入
    @PostMapping("/black/import")
    public Result importBlackList(@RequestBody List<String> ipList) {
        ipList.forEach(ip -> 
            redisTemplate.opsForSet().add(BLACK_LIST, ip)
        );
        return Result.success();
    }
}
```

### 7.5 智能防护策略


**自动加入黑名单规则**：
```
触发条件示例：

① 短时间高频访问
if (1分钟内请求 > 1000次) {
    加入黑名单(时效: 1小时)
}

② 频繁登录失败
if (5分钟内登录失败 > 5次) {
    加入黑名单(时效: 30分钟)
}

③ 异常操作行为
if (访问不存在的接口 > 50次) {
    加入黑名单(时效: 24小时)
}

④ 爬虫特征识别
if (User-Agent包含爬虫关键字) {
    加入黑名单(永久)
}
```

**分级封禁策略**：

| 违规次数 | **封禁时长** | **触发条件** |
|---------|------------|-------------|
| 1次 | `30分钟` | 首次异常 |
| 2次 | `2小时` | 再次违规 |
| 3次 | `24小时` | 屡次违规 |
| 4次+ | `永久` | 恶意攻击 |

> 💡 **人工审核机制**
> ```
> 自动封禁 → 通知管理员
>         ↓
>    人工审核判断
>         ↓
> 确认无误 → 维持封禁
> 误判情况 → 解除封禁 + 加入白名单
> ```

---

## 8. 📋 核心要点总结


### 8.1 六大场景总览


```
🔐 统一鉴权认证
核心：验证"你是谁"和"有没有权限"
关键：Token验证、权限判断、优先级最高

✅ 请求参数校验  
核心：确保请求数据合法有效
关键：格式校验、长度限制、SQL注入防护

🎭 响应数据脱敏
核心：保护隐私和敏感信息
关键：手机号/身份证/银行卡脱敏

📝 接口调用审计
核心：记录每次API调用详情
关键：谁/何时/做了什么/结果如何

📊 性能监控统计
核心：实时监控接口性能指标
关键：QPS/响应时间/错误率/告警

🚫 黑白名单控制
核心：拦截恶意请求，放行合法流量
关键：IP黑名单/白名单/智能防护
```

### 8.2 过滤器执行顺序


**优先级排序**：
```
执行顺序（Order值从小到大）：

-200: 黑白名单过滤器
      ↓ (先拦截恶意IP)
-100: 鉴权认证过滤器
      ↓ (再验证身份)
-50:  参数校验过滤器
      ↓ (检查请求合法性)
0:    业务逻辑执行
      ↓ (正常处理请求)
50:   数据脱敏过滤器
      ↓ (响应数据脱敏)
100:  审计日志过滤器
      ↓ (记录调用日志)
200:  性能监控过滤器
      ↓ (统计性能指标)
```

### 8.3 实战最佳实践


> ⭐ **性能优化建议**
> - 黑名单用Redis存储，查询快
> - 参数校验规则可配置化
> - 审计日志异步写入
> - 监控指标分级上报

> ⭐ **安全加固建议**
> - 多层防护：黑名单+参数校验+鉴权
> - Token定期刷新防盗用
> - 敏感操作双重验证
> - 异常行为自动封禁

> ⭐ **可维护性建议**
> - 过滤器职责单一
> - 配置与代码分离
> - 日志记录完整
> - 监控告警及时

### 8.4 常见问题解答


**Q: 过滤器太多会影响性能吗？**
```
A: 影响很小
- 单个过滤器耗时通常<1ms
- 6个过滤器总耗时<10ms
- 相比网络传输(几十ms)可忽略
- 关键是优化单个过滤器逻辑
```

**Q: 黑名单太大怎么办？**
```
A: 分级存储
- 热数据：Redis（最近1小时）
- 温数据：本地缓存（最近1天）
- 冷数据：数据库（历史记录）
- 定期清理过期黑名单
```

**Q: 如何防止误杀正常用户？**
```
A: 多重保障
- 白名单优先级高于黑名单
- 自动封禁设置时效性
- 人工审核机制
- 提供申诉解封通道
```

### 8.5 学习路线建议


**新手学习路径**：
```
第一步：理解每个过滤器的作用
       ↓
第二步：编写最简单的过滤器
       ↓  
第三步：掌握过滤器执行顺序
       ↓
第四步：实现复杂业务场景
       ↓
第五步：性能优化和安全加固
```

**核心记忆**：
- 过滤器就是网关的"守门员"
- 六大场景各司其职，缺一不可
- 执行顺序很重要，黑名单要最先
- 性能和安全要平衡，不能顾此失彼