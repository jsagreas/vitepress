---
title: 3、自定义过滤器开发
---
## 📚 目录

1. [自定义过滤器基础概念](#1-自定义过滤器基础概念)
2. [核心接口与抽象类](#2-核心接口与抽象类)
3. [配置类Config定义](#3-配置类config定义)
4. [apply方法实现详解](#4-apply方法实现详解)
5. [过滤器命名规则](#5-过滤器命名规则)
6. [配置参数绑定机制](#6-配置参数绑定机制)
7. [链式过滤处理](#7-链式过滤处理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 自定义过滤器基础概念


### 1.1 为什么需要自定义过滤器


🌰 **生活场景类比**：
想象你在开发一个电商网站的API网关，内置的过滤器就像**通用工具箱**，能解决大部分问题。但当你需要：
- 记录用户的购买行为日志
- 对VIP用户进行特殊处理
- 统计每个商品接口的调用次数

这时候通用工具就不够用了，你需要自己"打造专属工具"——这就是**自定义过滤器**的作用。

### 1.2 什么是自定义过滤器


**🔸 核心概念**
```
自定义过滤器 = 根据业务需求定制的请求/响应处理逻辑

通俗理解：
就像给网关装上"特殊处理器"，让它能按你的要求处理请求
```

**📊 内置 vs 自定义对比**

| 对比维度 | **内置过滤器** | **自定义过滤器** |
|---------|--------------|----------------|
| 🔸 **功能范围** | `通用场景` | `业务定制` |
| 🔸 **灵活性** | `固定逻辑` | `完全可控` |
| 🔸 **开发成本** | `开箱即用` | `需要编码` |
| 🔸 **适用场景** | `基础需求` | `特殊需求` |

### 1.3 自定义过滤器的应用场景


**🚀 实际业务场景**
```
✅ 业务日志记录
   记录详细的请求信息：用户ID、请求时间、接口路径等

✅ 权限校验增强
   根据业务规则检查用户是否有权限访问特定接口

✅ 数据统计分析
   统计接口调用量、响应时间、失败率等指标

✅ 动态路由决策
   根据请求内容动态选择转发目标服务

✅ 个性化处理
   VIP用户优先处理、特殊客户端适配等
```

---

## 2. 🔧 核心接口与抽象类


### 2.1 GatewayFilterFactory接口


**🔸 接口作用说明**
```java
// 这是所有过滤器工厂的"顶级接口"
public interface GatewayFilterFactory<C> {
    // 根据配置创建过滤器实例
    GatewayFilter apply(C config);
}
```

**💡 通俗理解**
```
GatewayFilterFactory 就像一个"过滤器制造工厂"

工作流程：
1. 你给工厂提供"配置参数"（C config）
2. 工厂根据配置"生产"出一个过滤器（GatewayFilter）
3. 这个过滤器就可以去处理请求了

类比：
工厂接口 = 汽车制造厂的生产标准
配置参数 = 客户定制需求（颜色、配置等）
过滤器实例 = 生产出的汽车
```

### 2.2 AbstractGatewayFilterFactory抽象类


**🔸 抽象类的作用**

```
为什么不直接实现接口，而要继承抽象类？

抽象类提供了：
✅ 基础功能封装：已经实现了通用逻辑
✅ 配置绑定机制：自动将YAML配置映射到对象
✅ 简化开发：只需关注核心业务逻辑
```

**📋 继承关系图**
```
GatewayFilterFactory (顶级接口)
         ↑
         |
AbstractGatewayFilterFactory (抽象基类)
         ↑
         |
你的自定义过滤器 (具体实现)
```

**🔸 抽象类源码解析**

```java
// 抽象基类提供的核心能力
public abstract class AbstractGatewayFilterFactory<C> 
    implements GatewayFilterFactory<C> {
    
    // 配置类的Class对象，用于反射创建配置实例
    private final Class<C> configClass;
    
    // 构造函数：传入配置类型
    public AbstractGatewayFilterFactory(Class<C> configClass) {
        this.configClass = configClass;
    }
    
    // 核心方法：需要子类实现
    public abstract GatewayFilter apply(C config);
}
```

**💡 为什么要传配置类Class？**
```
因为Java的泛型会被擦除，运行时无法知道C的具体类型
通过传入Class对象，框架可以：
1. 创建配置对象实例
2. 将YAML配置值绑定到对象属性
3. 实现配置的自动注入
```

---

## 3. 📦 配置类Config定义


### 3.1 配置类的作用


**🔸 什么是Config配置类？**
```
Config类 = 过滤器的"设置面板"

作用：
1. 定义过滤器需要哪些参数
2. 接收YAML配置文件中的值
3. 提供给apply方法使用
```

### 3.2 配置类编写规范


**✅ 标准配置类示例**
```java
// 记录日志的过滤器配置
public class LogConfig {
    // 是否记录请求体
    private boolean logBody = false;
    
    // 是否记录请求头
    private boolean logHeaders = true;
    
    // 日志级别
    private String level = "INFO";
    
    // 必须提供getter/setter方法
    public boolean isLogBody() {
        return logBody;
    }
    
    public void setLogBody(boolean logBody) {
        this.logBody = logBody;
    }
    
    // ...其他getter/setter
}
```

**🔍 配置类要点说明**

| 要素 | **说明** | **为什么这样做** |
|------|---------|----------------|
| 🔸 **属性类型** | `基本类型、String、List等` | `便于YAML配置映射` |
| 🔸 **默认值** | `在字段声明时设置` | `配置可选，有默认行为` |
| 🔸 **getter/setter** | `必须提供` | `框架通过反射注入值` |
| 🔸 **静态内部类** | `可定义为过滤器的内部类` | `代码组织更清晰` |

### 3.3 配置类与YAML的对应


**📝 YAML配置示例**
```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          filters:
            - CustomLog=true,false,DEBUG
#            # 参数顺序对应：logBody, logHeaders, level
```

**🔄 参数绑定流程**
```
YAML配置值 → 框架解析 → 创建Config对象 → 调用setter方法 → 传给apply方法

详细步骤：
1. 框架读取：filters下的"CustomLog=true,false,DEBUG"
2. 解析参数：按逗号分割成["true","false","DEBUG"]
3. 类型转换：将字符串转为对应类型
4. 调用setter：config.setLogBody(true)等
5. 传递使用：apply(config)方法收到配置好的对象
```

---

## 4. 💻 apply方法实现详解


### 4.1 apply方法的核心作用


**🔸 方法签名理解**
```java
@Override
public GatewayFilter apply(LogConfig config) {
    // 返回一个GatewayFilter过滤器
}
```

**💡 通俗解释**
```
apply方法 = "过滤器组装车间"

输入：配置参数（config）
输出：一个能工作的过滤器（GatewayFilter）

类比：
apply方法就像组装工人
config是零件清单和要求
GatewayFilter是组装好的成品
```

### 4.2 完整过滤器实现示例


**🔧 简单日志过滤器**
```java
@Component
public class CustomLogGatewayFilterFactory 
    extends AbstractGatewayFilterFactory<CustomLogGatewayFilterFactory.LogConfig> {
    
    // 1️⃣ 构造函数：传入配置类Class
    public CustomLogGatewayFilterFactory() {
        super(LogConfig.class);
    }
    
    // 2️⃣ 核心方法：创建过滤器
    @Override
    public GatewayFilter apply(LogConfig config) {
        
        // 返回一个lambda表达式形式的过滤器
        return (exchange, chain) -> {
            
            // 前置处理：请求到达时
            if (config.isLogHeaders()) {
                System.out.println("请求头：" + exchange.getRequest().getHeaders());
            }
            
            if (config.isLogBody()) {
                System.out.println("记录请求体...");
            }
            
            // 继续执行过滤器链
            return chain.filter(exchange).then(Mono.fromRunnable(() -> {
                // 后置处理：响应返回时
                System.out.println("响应状态码：" + exchange.getResponse().getStatusCode());
            }));
        };
    }
    
    // 3️⃣ 配置类定义
    public static class LogConfig {
        private boolean logBody = false;
        private boolean logHeaders = true;
        
        // getter/setter省略...
    }
}
```

### 4.3 apply方法实现要点


**🎯 关键代码解析**

```java
// Lambda表达式的两个参数
(exchange, chain) -> {
    // exchange：当前请求的上下文对象
    //   - 包含请求信息：exchange.getRequest()
    //   - 包含响应信息：exchange.getResponse()
    
    // chain：过滤器链
    //   - 调用chain.filter()继续执行后续过滤器
    //   - 如果不调用，请求会被中断
}
```

**⚠️ 常见错误提醒**
```
❌ 错误写法：忘记调用chain.filter()
return Mono.empty(); // 请求被中断，不会转发到服务

✅ 正确写法：必须调用chain.filter()
return chain.filter(exchange); // 继续处理
```

**🔄 执行时序说明**
```
请求流程：
客户端 → 过滤器前置逻辑 → chain.filter() → 后续过滤器 → 目标服务
                                                              ↓
客户端 ← 过滤器后置逻辑 ← .then(后置处理) ← 响应返回 ← 目标服务

代码对应：
return chain.filter(exchange)           // 转发请求
    .then(Mono.fromRunnable(() -> {     // 响应返回后执行
        // 后置处理逻辑
    }));
```

---

## 5. 📝 过滤器命名规则


### 5.1 命名规则详解


**🔸 核心命名规范**
```
类名格式：XxxGatewayFilterFactory
          ↑                  ↑
       自定义名称         固定后缀

配置中使用的名称：Xxx（去掉GatewayFilterFactory后缀）
```

**💡 实例说明**

| 类名 | **配置中的名称** | **完整示例** |
|------|----------------|-------------|
| `CustomLogGatewayFilterFactory` | `CustomLog` | `- CustomLog=true,false` |
| `TokenCheckGatewayFilterFactory` | `TokenCheck` | `- TokenCheck=header` |
| `RequestTimeGatewayFilterFactory` | `RequestTime` | `- RequestTime=true` |

### 5.2 为什么这样命名？


**🔍 框架自动识别机制**
```
Spring Cloud Gateway的约定：
1. 扫描所有以"GatewayFilterFactory"结尾的类
2. 去掉后缀得到过滤器简称
3. 在YAML中匹配时使用简称
4. 自动创建过滤器实例

这种设计叫"约定优于配置"：
- 不需要额外配置映射关系
- 按命名规则自动识别
- 减少配置代码
```

### 5.3 命名最佳实践


**✅ 推荐命名**
```java
// 清晰表达功能
RequestLogGatewayFilterFactory      // 请求日志
AuthCheckGatewayFilterFactory       // 权限检查
RateLimitGatewayFilterFactory       // 限流控制
```

**❌ 不推荐命名**
```java
// 过于简单，不明确
MyFilterFactory                     // 太模糊
FilterGatewayFilterFactory          // 重复啰嗦
CustomGatewayFilterFactory          // 不表达具体功能
```

---

## 6. 🔗 配置参数绑定机制


### 6.1 参数绑定原理


**🔸 绑定流程图解**
```
YAML配置
   ↓
[解析参数值]
   ↓
[按顺序或名称匹配]
   ↓
[类型转换]
   ↓
[调用setter注入]
   ↓
Config对象创建完成
   ↓
传给apply方法使用
```

### 6.2 两种配置方式


**📋 方式一：位置参数（ShortcutType.DEFAULT）**

```java
@Override
public List<String> shortcutFieldOrder() {
    // 指定参数顺序
    return Arrays.asList("logBody", "logHeaders", "level");
}
```

**对应YAML配置**
```yaml
filters:
  - CustomLog=true,false,DEBUG
#  # 第1个参数→logBody
#  # 第2个参数→logHeaders  
#  # 第3个参数→level
```

**📋 方式二：命名参数（推荐）**

```yaml
filters:
  - name: CustomLog
    args:
      logBody: true
      logHeaders: false
      level: DEBUG
```

**🔍 两种方式对比**

| 配置方式 | **优点** | **缺点** | **适用场景** |
|---------|---------|---------|------------|
| 🔸 **位置参数** | `简洁` | `顺序固定，易错` | `参数少且固定` |
| 🔸 **命名参数** | `清晰，可扩展` | `稍显冗长` | `参数多或可选` |

### 6.3 参数类型自动转换


**🔧 支持的类型转换**
```java
// Config类中定义的类型 ← YAML中的字符串会自动转换

boolean/Boolean      ← "true"/"false"
int/Integer          ← "100"
long/Long            ← "1000"
String              ← "hello"
List<String>        ← "a,b,c"（逗号分割）
Duration            ← "10s"/"1m"（时间单位）
```

**💡 自定义类型转换**
```java
// 如果需要特殊类型，可以在Config中处理
public static class CustomConfig {
    private String timeStr;
    
    // 提供转换方法
    public Duration getTimeDuration() {
        return Duration.parse(timeStr);
    }
}
```

---

## 7. 🔄 链式过滤处理


### 7.1 什么是过滤器链


**🔸 过滤器链概念**
```
过滤器链 = 多个过滤器按顺序执行的流水线

工作原理：
请求 → 过滤器A → 过滤器B → 过滤器C → 目标服务
            ↓          ↓          ↓
         处理1      处理2      处理3
```

**🌰 生活场景类比**
```
就像安检流程：
乘客 → 身份验证 → 行李检查 → 安全扫描 → 登机口
       ↓           ↓          ↓
     检查证件    扫描行李   金属探测

每个环节都是一个"过滤器"
必须全部通过才能登机
```

### 7.2 链式调用的实现


**🔧 chain.filter()的作用**
```java
return chain.filter(exchange).then(Mono.fromRunnable(() -> {
    // 后置处理
}));

解释：
chain.filter(exchange)  → 将请求传递给下一个过滤器
.then(...)              → 等下一个过滤器处理完后执行后置逻辑
```

**📊 执行顺序示意**
```
配置顺序：
filters:
  - FilterA
  - FilterB  
  - FilterC

执行流程：
FilterA前置 → FilterB前置 → FilterC前置 → 服务处理
    ↓             ↓             ↓           ↓
FilterA后置 ← FilterB后置 ← FilterC后置 ← 响应返回

栈式结构：
进入：A → B → C
返回：C → B → A
```

### 7.3 中断过滤器链


**🚫 如何终止请求**
```java
@Override
public GatewayFilter apply(Config config) {
    return (exchange, chain) -> {
        
        // 检查条件
        if (!isValid(exchange)) {
            // 设置响应状态
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            
            // 直接返回，不调用chain.filter()
            return exchange.getResponse().setComplete();
        }
        
        // 继续执行
        return chain.filter(exchange);
    };
}
```

**⚠️ 中断场景示例**
```
✅ 常见中断场景：
- 权限验证失败
- 请求参数不合法
- 限流触发拦截
- 签名验证失败

关键点：
不调用chain.filter() → 后续过滤器不执行 → 请求被拦截
```

### 7.4 过滤器间数据传递


**📦 通过exchange传递数据**
```java
// 在FilterA中设置数据
exchange.getAttributes().put("userId", "12345");

// 在FilterB中获取数据
String userId = exchange.getAttribute("userId");

// 修改请求头传递
ServerHttpRequest request = exchange.getRequest()
    .mutate()
    .header("X-User-Id", userId)
    .build();

exchange = exchange.mutate()
    .request(request)
    .build();

return chain.filter(exchange);
```

---

## 8. 📋 核心要点总结


### 8.1 自定义过滤器开发流程


**🔸 开发步骤总览**
```
1️⃣ 创建配置类Config
   └─ 定义过滤器需要的参数

2️⃣ 继承AbstractGatewayFilterFactory
   └─ 泛型指定Config类型

3️⃣ 实现apply方法
   └─ 返回GatewayFilter处理逻辑

4️⃣ 添加@Component注解
   └─ 让Spring扫描注册

5️⃣ YAML中配置使用
   └─ 按命名规则引用
```

### 8.2 关键知识点回顾


**💡 必须掌握的核心概念**

| 知识点 | **核心理解** | **记忆要点** |
|-------|------------|------------|
| 🔸 **工厂模式** | `通过apply创建过滤器实例` | `工厂生产产品` |
| 🔸 **Config配置** | `承载YAML参数的对象` | `必须有getter/setter` |
| 🔸 **命名规则** | `XxxGatewayFilterFactory` | `去后缀即配置名` |
| 🔸 **链式调用** | `chain.filter()传递请求` | `不调用则中断` |
| 🔸 **参数绑定** | `框架自动注入配置值` | `支持位置或命名` |

### 8.3 实战开发建议


**✅ 最佳实践**
```
1. 配置类使用静态内部类，代码更内聚
2. 提供合理的默认值，减少必填配置
3. apply方法逻辑简洁，复杂逻辑抽方法
4. 异常处理完善，记录日志便于排查
5. 命名清晰表达功能，便于团队理解
```

**⚠️ 常见错误避免**
```
❌ 忘记调用chain.filter()导致请求中断
❌ Config类缺少getter/setter无法绑定参数
❌ 类名不符合命名规则导致无法识别
❌ 响应式编程中使用阻塞代码
❌ 未处理异常导致网关崩溃
```

### 8.4 进阶学习方向


**🚀 深入理解**
```
🔹 响应式编程（Reactor）
   理解Mono/Flux的使用

🔹 WebFlux框架
   掌握非阻塞IO模型

🔹 过滤器性能优化
   减少不必要的操作

🔹 全局异常处理
   统一错误响应格式

🔹 过滤器单元测试
   保证代码质量
```

**🔗 相关知识链接**
- 前置知识：[过滤器基础概念](#)
- 进阶内容：[全局过滤器开发](#)
- 实战案例：[认证鉴权过滤器](#)

---

**🎯 学习检查清单**

- [ ] 理解GatewayFilterFactory的作用
- [ ] 掌握AbstractGatewayFilterFactory的使用
- [ ] 会定义Config配置类
- [ ] 能实现apply方法创建过滤器
- [ ] 理解过滤器命名规则
- [ ] 掌握参数绑定的两种方式
- [ ] 理解过滤器链的执行流程
- [ ] 能够中断过滤器链
- [ ] 会在过滤器间传递数据

**💪 实战任务**
```
尝试自己开发一个"请求计时过滤器"：
- 记录请求开始时间
- 记录请求结束时间
- 计算并打印请求耗时
- 支持配置是否启用
```