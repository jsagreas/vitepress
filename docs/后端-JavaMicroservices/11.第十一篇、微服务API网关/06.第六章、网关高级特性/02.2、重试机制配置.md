---
title: 2、重试机制配置
---
## 📚 目录

1. [重试机制基本概念](#1-重试机制基本概念)
2. [RetryGatewayFilterFactory详解](#2-RetryGatewayFilterFactory详解)
3. [重试条件配置](#3-重试条件配置)
4. [重试次数与间隔控制](#4-重试次数与间隔控制)
5. [幂等性保证](#5-幂等性保证)
6. [重试异常处理](#6-重试异常处理)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔄 重试机制基本概念


### 1.1 什么是重试机制


**通俗理解**：重试机制就像打电话时对方没接通，你会再打一次。在网关中，当请求失败时，系统会自动帮你"重新试一次"。

```
正常情况：
客户端 → 网关 → 服务A（成功）→ 返回结果

使用重试后：
客户端 → 网关 → 服务A（失败）→ 自动重试 → 服务A（成功）→ 返回结果
                              ↓
                        （无需客户端重新发起）
```

### 1.2 为什么需要重试


**核心原因**：
- **网络抖动**：就像WiFi信号时好时坏，网络不稳定会导致偶尔失败
- **服务瞬时故障**：后端服务可能因为资源紧张，偶尔处理不过来
- **提升可用性**：通过重试，让偶尔的失败不影响用户体验

**生活场景类比**：
```
场景1：网购下单
- 第1次点击"支付"：网络超时
- 系统自动重试：支付成功
- 用户无感知，体验良好

场景2：查询订单
- 第1次请求：服务器繁忙
- 自动重试：查询成功
- 用户只觉得稍微慢一点
```

### 1.3 重试的适用场景


| 场景类型 | **是否适合重试** | **原因说明** |
|---------|----------------|-------------|
| 🟢 **查询操作** | ✅ 适合 | 多次查询不会产生副作用 |
| 🟢 **幂等操作** | ✅ 适合 | 重复执行结果一致 |
| 🔴 **支付扣款** | ❌ 不适合 | 可能重复扣款 |
| 🔴 **发送短信** | ❌ 不适合 | 可能重复发送 |
| 🟡 **订单创建** | ⚠️ 需谨慎 | 需要配合幂等性设计 |

---

## 2. 🔧 RetryGatewayFilterFactory详解


### 2.1 什么是RetryGatewayFilterFactory


**简单理解**：这是Spring Cloud Gateway提供的"重试过滤器工厂"，专门用来配置重试规则。

**工作原理**：
```
请求流程：
客户端请求 
    ↓
到达网关
    ↓
经过重试过滤器 ← 这里配置重试规则
    ↓
转发到后端服务
    ↓
如果失败 → 判断是否需要重试 → 是 → 重新发起请求
           ↓
           否 → 返回错误
```

### 2.2 基础配置示例


**YAML配置方式**（推荐新手使用）：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: retry-route
          uri: lb://order-service  # 路由到订单服务
          predicates:
            - Path=/api/orders/**
          filters:
            - name: Retry  # 使用重试过滤器
              args:
                retries: 3  # 最多重试3次
                statuses: BAD_GATEWAY  # 502错误时重试
```

**配置说明**：
- `name: Retry`：指定使用重试过滤器
- `retries: 3`：失败后最多重试3次（加上第一次，总共4次请求）
- `statuses`：指定什么情况下触发重试

### 2.3 Java代码配置方式


```java
@Configuration
public class GatewayRetryConfig {
    
    @Bean
    public RouteLocator retryRoutes(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("retry-route", r -> r
                .path("/api/orders/**")
                // 配置重试过滤器
                .filters(f -> f.retry(config -> {
                    config.setRetries(3);  // 重试次数
                    config.setStatuses(HttpStatus.BAD_GATEWAY);  // 触发条件
                }))
                .uri("lb://order-service")
            )
            .build();
    }
}
```

**适用场景**：
- 需要动态调整配置
- 需要复杂的条件判断
- 配置需要代码审查

---

## 3. 🎯 重试条件配置


### 3.1 基于HTTP状态码重试


**核心概念**：根据后端服务返回的HTTP状态码决定是否重试。

**常见状态码分类**：

```
5xx 服务器错误（适合重试）：
├── 500 Internal Server Error    服务器内部错误
├── 502 Bad Gateway              网关错误（常见于服务不可用）
├── 503 Service Unavailable      服务暂时不可用
└── 504 Gateway Timeout          网关超时

4xx 客户端错误（不适合重试）：
├── 400 Bad Request              请求参数错误
├── 401 Unauthorized             未授权
├── 403 Forbidden                禁止访问
└── 404 Not Found                资源不存在
```

**配置示例**：

```yaml
filters:
  - name: Retry
    args:
      retries: 3
      statuses:  # 可以配置多个状态码
        - BAD_GATEWAY        # 502
        - SERVICE_UNAVAILABLE # 503
        - GATEWAY_TIMEOUT    # 504
```

**为什么这样配置**：
- ✅ `5xx错误`：通常是临时性故障，重试可能成功
- ❌ `4xx错误`：是请求本身的问题，重试也不会成功

### 3.2 基于异常类型重试


**配置异常重试**：

```yaml
filters:
  - name: Retry
    args:
      retries: 3
      exceptions:  # 配置需要重试的异常
        - java.io.IOException           # IO异常（网络问题）
        - java.util.concurrent.TimeoutException  # 超时异常
```

**常见异常场景**：

| 异常类型 | **触发原因** | **是否重试** |
|---------|------------|-------------|
| `IOException` | 网络连接中断 | ✅ 建议重试 |
| `TimeoutException` | 请求超时 | ✅ 建议重试 |
| `ConnectException` | 连接失败 | ✅ 建议重试 |
| `IllegalArgumentException` | 参数错误 | ❌ 不建议重试 |

### 3.3 基于HTTP方法重试


**核心原则**：只对安全的HTTP方法进行重试。

```yaml
filters:
  - name: Retry
    args:
      retries: 3
      methods:  # 指定哪些HTTP方法可以重试
        - GET
        - HEAD
      # 不包含POST、PUT、DELETE
```

**HTTP方法安全性**：

```
安全方法（适合重试）：
GET      只读操作，不改变服务器状态
HEAD     只获取头信息，不改变状态

非安全方法（需谨慎）：
POST     创建资源，可能重复创建
PUT      更新资源，需要幂等性设计
DELETE   删除资源，可能重复删除
```

**实际应用建议**：
```
查询订单列表：GET /api/orders
→ 可以重试 ✅

创建订单：POST /api/orders
→ 需要幂等性保证才能重试 ⚠️

更新订单状态：PUT /api/orders/123
→ 如果是幂等更新可以重试 ⚠️
```

---

## 4. ⏱️ 重试次数与间隔控制


### 4.1 重试次数配置


**基础配置**：

```yaml
filters:
  - name: Retry
    args:
      retries: 3  # 重试3次
      # 实际总请求次数 = 1次初始请求 + 3次重试 = 4次
```

**次数选择建议**：

```
低重试次数（1-2次）：
适用场景：快速响应业务、非核心服务
优点：快速失败，不占用资源
缺点：成功率可能不够高

中等重试次数（3-5次）：✅ 推荐
适用场景：大部分业务场景
优点：平衡成功率和性能
缺点：需要合理设置间隔

高重试次数（5次以上）：
适用场景：核心业务、必须成功的操作
优点：成功率高
缺点：可能占用较多资源和时间
```

### 4.2 重试间隔配置


**固定间隔重试**：

```yaml
filters:
  - name: Retry
    args:
      retries: 3
      backoff:
        firstBackoff: 100ms   # 第一次重试间隔100毫秒
        maxBackoff: 500ms     # 最大间隔500毫秒
        factor: 2             # 每次间隔翻倍
        basedOnPreviousValue: true  # 基于上次间隔计算
```

**间隔计算示例**：
```
第1次请求失败 
    ↓ 等待 100ms
第1次重试失败
    ↓ 等待 200ms (100ms × 2)
第2次重试失败
    ↓ 等待 400ms (200ms × 2)
第3次重试
```

**指数退避策略**（推荐）：

```
为什么使用指数退避：
场景：后端服务因为负载高导致响应慢

固定间隔重试：
100ms后重试 → 服务还在忙 → 失败
100ms后重试 → 服务还在忙 → 失败
持续给服务施加压力 ❌

指数退避：
100ms后重试 → 失败
200ms后重试 → 给服务更多恢复时间
400ms后重试 → 服务可能已经恢复 ✅
```

### 4.3 完整配置示例


```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: smart-retry-route
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - name: Retry
              args:
                retries: 3
                statuses: 
                  - BAD_GATEWAY
                  - SERVICE_UNAVAILABLE
                methods:
                  - GET
                  - HEAD
                backoff:
                  firstBackoff: 100ms
                  maxBackoff: 1000ms
                  factor: 2
                  basedOnPreviousValue: true
```

---

## 5. 🔐 幂等性保证


### 5.1 什么是幂等性


**通俗解释**：幂等性就是"做一次和做多次的结果是一样的"。

**生活中的例子**：
```
幂等操作：
开关灯：按两次开关 = 按一次开关（灯的状态是固定的）
电梯按钮：按10次电梯按钮 = 按1次（电梯只会来一次）

非幂等操作：
ATM取钱：取10次钱 ≠ 取1次钱（余额会减少10倍）
点外卖：点10次 ≠ 点1次（会收到10份外卖）
```

### 5.2 幂等性在重试中的重要性


**问题场景**：

```
场景：用户购买商品，价格100元

无幂等性保证：
第1次请求：扣款100元，服务器响应超时
网关重试：又扣款100元，成功返回
结果：用户被扣了200元 ❌

有幂等性保证：
第1次请求：扣款100元（记录请求ID），服务器响应超时
网关重试：检测到相同请求ID，不重复扣款，返回第一次结果
结果：用户只扣了100元 ✅
```

### 5.3 幂等性实现方案


**方案一：唯一请求ID**

```
工作流程：
客户端 → 生成唯一请求ID → 发送到网关
                              ↓
                         网关在请求头中添加ID
                              ↓
                         后端服务接收请求
                              ↓
                    检查该ID是否已经处理过
                    ↓                ↓
                已处理              未处理
                    ↓                ↓
            返回之前的结果      执行业务逻辑
```

**配置示例**：

```yaml
filters:
  - name: Retry
    args:
      retries: 3
  - AddRequestHeader=X-Request-Id, ${random.uuid}  # 添加唯一ID
```

**后端服务处理**：

```java
@RestController
public class OrderController {
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    @PostMapping("/api/orders")
    public Result createOrder(@RequestHeader("X-Request-Id") String requestId,
                             @RequestBody OrderDTO order) {
        
        // 检查请求ID是否已处理
        String cacheKey = "request:" + requestId;
        Object cached = redisTemplate.opsForValue().get(cacheKey);
        
        if (cached != null) {
            // 已处理过，直接返回之前的结果
            return (Result) cached;
        }
        
        // 执行业务逻辑
        Result result = orderService.create(order);
        
        // 缓存结果（设置过期时间，避免永久存储）
        redisTemplate.opsForValue().set(cacheKey, result, 1, TimeUnit.HOURS);
        
        return result;
    }
}
```

**方案二：数据库唯一约束**

```
适用场景：创建订单、用户注册等

实现方式：
1. 在数据库表中添加唯一索引
   CREATE UNIQUE INDEX idx_request_id ON orders(request_id);

2. 业务逻辑：
   - 第1次请求：插入成功
   - 重试请求：因为唯一约束，插入失败，查询返回已有记录
```

**方案三：状态机设计**

```
订单状态流转（天然幂等）：

初始状态 → 已支付 ：第一次请求执行
已支付   → 已支付 ：重试请求，状态不变，返回成功

状态转换规则：
if (当前状态 == "初始状态") {
    更新为"已支付"
    执行扣款
} else if (当前状态 == "已支付") {
    直接返回成功（不重复扣款）
}
```

---

## 6. ⚠️ 重试异常处理


### 6.1 重试失败的异常捕获


**配置重试失败回退**：

```yaml
filters:
  - name: Retry
    args:
      retries: 3
      exceptions:
        - java.io.IOException
        - java.util.concurrent.TimeoutException
```

**Java代码异常处理**：

```java
@Configuration
public class RetryErrorHandler {
    
    @Bean
    public RouteLocator retryWithFallback(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("retry-with-fallback", r -> r
                .path("/api/orders/**")
                .filters(f -> f
                    .retry(config -> {
                        config.setRetries(3);
                        config.setStatuses(HttpStatus.BAD_GATEWAY);
                    })
                    // 所有重试失败后的降级处理
                    .circuitBreaker(cb -> cb
                        .setName("orderServiceCB")
                        .setFallbackUri("forward:/fallback/order")
                    )
                )
                .uri("lb://order-service")
            )
            .build();
    }
}
```

### 6.2 降级策略


**什么是降级**：当所有重试都失败后，返回一个"保底"的响应，而不是直接报错。

**降级场景示例**：

```
场景1：查询商品详情
正常流程：查询数据库 → 返回完整商品信息
降级流程：查询失败 → 返回商品基本信息（从缓存）

场景2：推荐商品
正常流程：个性化推荐算法 → 返回推荐列表
降级流程：算法服务不可用 → 返回热门商品列表

场景3：用户头像
正常流程：查询用户头像URL → 返回用户上传的头像
降级流程：查询失败 → 返回默认头像
```

**降级处理实现**：

```java
@RestController
@RequestMapping("/fallback")
public class FallbackController {
    
    @GetMapping("/order")
    public Result orderFallback() {
        return Result.error("订单服务暂时不可用，请稍后重试")
                     .setCode(503)
                     .setData(null);
    }
    
    @GetMapping("/product/{id}")
    public Result productFallback(@PathVariable String id) {
        // 返回缓存的商品基本信息
        Product cached = cacheService.getBasicProduct(id);
        return Result.success(cached)
                     .setMessage("当前使用缓存数据");
    }
}
```

### 6.3 异常日志记录


**记录重试过程**：

```java
@Slf4j
@Component
public class RetryLogger implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, 
                             GatewayFilterChain chain) {
        
        String requestId = exchange.getRequest().getId();
        String path = exchange.getRequest().getPath().value();
        
        return chain.filter(exchange)
            .doOnError(error -> {
                // 记录重试失败日志
                log.error("请求失败 - ID: {}, Path: {}, Error: {}", 
                         requestId, path, error.getMessage());
            })
            .doOnSuccess(v -> {
                // 记录成功日志
                log.info("请求成功 - ID: {}, Path: {}", requestId, path);
            });
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}
```

**日志输出示例**：
```
2025-09-23 10:15:30 INFO  请求开始 - ID: abc123, Path: /api/orders/123
2025-09-23 10:15:31 WARN  第1次重试 - 原因: 连接超时
2025-09-23 10:15:32 WARN  第2次重试 - 原因: 502 Bad Gateway  
2025-09-23 10:15:33 INFO  请求成功 - ID: abc123, Path: /api/orders/123
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 重试机制本质：自动重新发起失败的请求，提升系统可用性
🔸 RetryGatewayFilterFactory：Spring Cloud Gateway的重试过滤器
🔸 重试条件：基于状态码、异常类型、HTTP方法决定是否重试
🔸 重试策略：次数控制 + 指数退避，避免雪崩
🔸 幂等性：保证重试不会产生副作用的关键
🔸 降级处理：所有重试失败后的保底方案
```

### 7.2 配置最佳实践


**推荐配置模板**：

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: production-retry-route
          uri: lb://your-service
          predicates:
            - Path=/api/**
          filters:
            - name: Retry
              args:
                retries: 3                    # 重试3次
                statuses:                     # 5xx错误重试
                  - BAD_GATEWAY
                  - SERVICE_UNAVAILABLE  
                  - GATEWAY_TIMEOUT
                methods:                      # 只对安全方法重试
                  - GET
                  - HEAD
                exceptions:                   # 网络异常重试
                  - java.io.IOException
                  - java.util.concurrent.TimeoutException
                backoff:                      # 指数退避
                  firstBackoff: 100ms
                  maxBackoff: 1000ms
                  factor: 2
                  basedOnPreviousValue: true
            - AddRequestHeader=X-Request-Id, ${random.uuid}  # 幂等性保证
```

### 7.3 注意事项清单


**✅ 应该做的**：
- 只对幂等操作配置重试
- 使用指数退避避免雪崩
- 记录重试日志便于排查问题
- 配置降级策略保证用户体验
- 设置合理的超时时间

**❌ 不应该做的**：
- 对非幂等操作（如支付）随意重试
- 重试次数设置过多占用资源
- 忽略重试失败的异常处理
- 不记录日志导致问题难以排查

### 7.4 实际应用场景


**场景一：电商商品查询**
```yaml
# 配置：允许多次重试，快速响应
retries: 3
methods: [GET]
statuses: [BAD_GATEWAY, SERVICE_UNAVAILABLE]
backoff: 
  firstBackoff: 50ms
  maxBackoff: 500ms
```

**场景二：订单创建**
```yaml
# 配置：必须保证幂等性，谨慎重试
retries: 2  # 减少重试次数
methods: [POST]
# 必须配合唯一请求ID
filters:
  - AddRequestHeader=X-Request-Id, ${random.uuid}
```

**场景三：支付接口**
```yaml
# 配置：不建议在网关层重试
# 应该在业务层实现补偿机制
retries: 0  # 关闭重试
# 使用熔断器快速失败
```

### 7.5 记忆要点


**核心记忆**：
- 重试提升可用性，但必须考虑幂等性
- 5xx错误可以重试，4xx错误不要重试
- GET请求安全，POST请求需谨慎
- 指数退避避免雪崩，降级保证体验
- 日志记录是排查问题的关键

**实战口诀**：
```
查询操作放心试，
创建更新需谨慎，
幂等设计是关键，
日志降级不能少。
```