---
title: 4、环境配置管理
---
## 📚 目录

1. [环境配置基础概念](#1-环境配置基础概念)
2. [多环境配置分离](#2-多环境配置分离)
3. [配置中心集成](#3-配置中心集成)
4. [敏感信息加密](#4-敏感信息加密)
5. [配置版本控制](#5-配置版本控制)
6. [动态配置更新](#6-动态配置更新)
7. [配置变更审计](#7-配置变更审计)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 环境配置基础概念


### 1.1 什么是环境配置


**通俗理解**：就像你的手机在家里连WiFi、在公司连公司WiFi、出门用流量一样，程序在不同环境下也需要用不同的配置。

```
生活中的例子：
家里上网 → 家用WiFi密码
公司上网 → 公司WiFi密码  
出差上网 → 酒店WiFi密码

API网关也一样：
开发环境 → 连接测试数据库
测试环境 → 连接测试服务器
生产环境 → 连接正式服务器
```

**核心概念**：
- **环境（Environment）**：程序运行的不同场景，比如开发、测试、生产
- **配置（Configuration）**：程序运行需要的各种参数，比如数据库地址、端口号
- **配置管理**：让程序在不同环境下自动使用对应的配置

### 1.2 为什么需要环境配置管理


**🔸 实际问题**

想象一下这个场景：
```
开发小张写代码：
数据库地址：localhost:3306
用户名：root
密码：123456

部署到生产环境后：
数据库地址：prod-db.company.com:3306
用户名：prod_user  
密码：Xy9$mK@pL2qR

如果把开发环境的配置带到生产？
→ 连不上数据库，系统崩溃！
→ 或者更糟：连错了数据库，删了生产数据！
```

**🔸 环境配置解决的核心问题**

| 问题 | 没有环境配置 | 有环境配置管理 |
|------|------------|--------------|
| **环境切换** | 手动改代码，容易出错 | 自动识别环境，自动切换 |
| **安全性** | 密码写在代码里，泄露风险高 | 密码加密存储，安全可控 |
| **团队协作** | 每个人配置不一样，冲突不断 | 统一配置中心，协同开发 |
| **版本追溯** | 不知道谁改了配置 | 完整的修改记录，可追溯 |

### 1.3 常见的环境类型


```
开发环境（Development）
│ 用途：程序员写代码、调试
│ 特点：可以随便改，崩了也没事
└─ 数据库：本地或开发服务器

测试环境（Testing/QA）  
│ 用途：测试人员验证功能
│ 特点：接近真实环境，但不是正式数据
└─ 数据库：测试服务器

预发布环境（Staging/Pre-Production）
│ 用途：上线前最后验证
│ 特点：和生产环境完全一样的配置
└─ 数据库：预发布服务器

生产环境（Production）
│ 用途：真实用户使用
│ 特点：最重要，不能出错
└─ 数据库：正式服务器
```

---

## 2. 🔧 多环境配置分离


### 2.1 配置文件分离的基本方式


**方式一：按环境创建不同配置文件**

```
项目结构：
src/main/resources/
├── application.yml              # 公共配置
├── application-dev.yml          # 开发环境
├── application-test.yml         # 测试环境  
└── application-prod.yml         # 生产环境
```

**💡 工作原理**：
```yaml
# application.yml（公共配置）
spring:
  application:
    name: api-gateway
  
# 激活哪个环境的配置
spring:
  profiles:
    active: dev  # 使用开发环境配置
```

**🔸 各环境配置示例**

```yaml
# application-dev.yml（开发环境）
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/dev_db
    username: root
    password: 123456
    
gateway:
  routes:
    - id: user-service
      uri: http://localhost:8081
```

```yaml
# application-prod.yml（生产环境）  
server:
  port: 80

spring:
  datasource:
    url: jdbc:mysql://prod-db.company.com:3306/prod_db
    username: prod_user
    password: ${DB_PASSWORD}  # 从环境变量读取
    
gateway:
  routes:
    - id: user-service
      uri: http://user-service:8081  # 使用服务名
```

### 2.2 配置继承与覆盖


**继承机制理解**：

```
公共配置（application.yml）
        ↓
    被所有环境继承
        ↓
┌───────┴───────┬───────────┐
│               │           │
开发配置      测试配置    生产配置
(dev)        (test)      (prod)
```

**实际例子**：

```yaml
# application.yml（公共配置）
spring:
  application:
    name: api-gateway  # 所有环境都用这个名字
    
logging:
  level:
    root: INFO  # 默认日志级别

---
# application-dev.yml（开发环境覆盖）
logging:
  level:
    root: DEBUG  # 开发环境改成DEBUG，方便调试
    com.example: TRACE  # 自己的代码更详细
```

**🔸 优先级规则**

```
配置优先级（从高到低）：
1. 命令行参数
   java -jar app.jar --server.port=9090

2. 环境变量  
   export SERVER_PORT=9090

3. 特定环境配置文件
   application-prod.yml

4. 公共配置文件
   application.yml

5. 代码中的默认值
   @Value("${server.port:8080}")
```

### 2.3 实战：如何切换环境


**方式一：修改配置文件（本地开发）**

```yaml
# application.yml
spring:
  profiles:
    active: dev  # 改成test就切换到测试环境
```

**方式二：启动参数（服务器部署）**

```bash
# 开发环境启动
java -jar api-gateway.jar --spring.profiles.active=dev

# 生产环境启动  
java -jar api-gateway.jar --spring.profiles.active=prod
```

**方式三：环境变量（Docker容器）**

```bash
# Docker启动时指定
docker run -e SPRING_PROFILES_ACTIVE=prod api-gateway
```

**方式四：IDE配置（开发调试）**

```
IDEA配置：
Run → Edit Configurations → Environment Variables
添加：SPRING_PROFILES_ACTIVE=dev
```

---

## 3. 🌐 配置中心集成


### 3.1 什么是配置中心


**通俗类比**：

```
传统方式 - 像每个人自己记账：
程序A：记在A的小本本上
程序B：记在B的小本本上  
程序C：记在C的小本本上
→ 改个配置要改3次，容易漏改、改错

配置中心 - 像公司统一的公告栏：
所有程序：都看同一个公告栏
改配置：只在公告栏上改一次
→ 所有程序自动看到最新配置
```

**配置中心的核心价值**：

| 功能 | 传统配置文件 | 配置中心 |
|------|------------|---------|
| **集中管理** | 每个服务一个配置文件 | 统一管理所有配置 |
| **动态更新** | 重启才生效 | 实时生效，无需重启 |
| **版本管理** | 没有历史记录 | 完整的版本历史 |
| **权限控制** | 谁都能改 | 严格的权限管理 |
| **灰度发布** | 不支持 | 支持部分实例先用新配置 |

### 3.2 主流配置中心选择


**🔸 Spring Cloud Config（入门首选）**

```
优点：
✅ Spring官方出品，集成简单
✅ 支持Git存储，天然版本控制
✅ 学习成本低

缺点：
❌ 功能相对基础
❌ 没有可视化界面

适合场景：
→ 小型项目
→ 团队刚接触微服务
```

**🔸 Nacos（阿里开源，推荐）**

```
优点：
✅ 配置+服务发现二合一
✅ 有友好的管理界面
✅ 支持多种配置格式
✅ 动态刷新配置

缺点：
❌ 需要单独部署服务

适合场景：
→ 中大型微服务项目
→ 需要可视化管理
```

**🔸 Apollo（携程开源）**

```
优点：
✅ 功能最强大
✅ 界面最友好
✅ 权限管理完善
✅ 灰度发布支持好

缺点：
❌ 架构复杂，部署麻烦
❌ 学习成本高

适合场景：
→ 大型企业级项目
→ 对配置管理要求很高
```

### 3.3 Nacos配置中心实战


**第一步：启动Nacos服务器**

```bash
# 下载Nacos（选择最新稳定版）
wget https://github.com/alibaba/nacos/releases/download/2.2.0/nacos-server-2.2.0.zip

# 解压并启动
unzip nacos-server-2.2.0.zip
cd nacos/bin

# 单机模式启动
sh startup.sh -m standalone

# 访问控制台：http://localhost:8848/nacos
# 默认用户名密码：nacos/nacos
```

**第二步：在Nacos创建配置**

```
登录Nacos控制台：

① 点击"配置管理" → "配置列表"
② 点击"+"号创建配置
③ 填写信息：
   Data ID: api-gateway-prod.yml
   Group: DEFAULT_GROUP
   配置格式: YAML
   配置内容: （见下方）
```

**配置内容示例**：

```yaml
# 在Nacos中创建：api-gateway-prod.yml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://prod-db:3306/gateway_db
    username: gateway_user
    password: ${db.password}  # 密码可以用占位符

gateway:
  routes:
    - id: user-service
      uri: lb://user-service  # 负载均衡
      predicates:
        - Path=/api/user/**
```

**第三步：项目集成Nacos**

```xml
<!-- pom.xml添加依赖 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    <version>2022.0.0.0</version>
</dependency>
```

```yaml
# bootstrap.yml（这个文件优先级最高）
spring:
  application:
    name: api-gateway
  cloud:
    nacos:
      config:
        server-addr: localhost:8848  # Nacos服务器地址
        file-extension: yml           # 配置文件格式
        namespace: production         # 命名空间（区分环境）
        group: DEFAULT_GROUP          # 分组
        username: nacos              # Nacos登录账号
        password: nacos              # Nacos登录密码
```

**第四步：验证配置加载**

```java
@RestController
@RefreshScope  // 重要：支持动态刷新
public class ConfigTestController {
    
    @Value("${gateway.routes[0].uri}")
    private String userServiceUri;
    
    @GetMapping("/test/config")
    public String testConfig() {
        return "当前配置的用户服务地址: " + userServiceUri;
    }
}
```

### 3.4 配置的命名空间管理


**命名空间的作用**：

```
类比：就像公司的不同部门
├── 研发部（dev命名空间）
│   └── 研发人员的配置
├── 测试部（test命名空间）
│   └── 测试人员的配置  
└── 运维部（prod命名空间）
    └── 生产环境的配置

每个部门互不干扰！
```

**在Nacos中创建命名空间**：

```
① 点击"命名空间"菜单
② 点击"新建命名空间"
③ 填写：
   命名空间名：production
   描述：生产环境配置
④ 创建后会生成一个ID，配置中使用这个ID
```

**使用命名空间**：

```yaml
spring:
  cloud:
    nacos:
      config:
        namespace: 5e7f8g9h-1234-5678-90ab-cdef12345678  # 命名空间ID
```

---

## 4. 🔐 敏感信息加密


### 4.1 为什么要加密敏感信息


**安全隐患示例**：

```yaml
# ❌ 危险做法：明文写密码
spring:
  datasource:
    url: jdbc:mysql://prod-db:3306/db
    username: admin
    password: Admin@123456  # 密码明文，泄露风险！

# 这个配置文件可能：
→ 提交到Git（所有人都能看到）
→ 被日志打印出来
→ 被黑客窃取
```

**🔸 需要加密的敏感信息**

```
✅ 数据库密码
✅ Redis密码  
✅ 第三方API密钥（如支付宝、微信）
✅ 加密密钥
✅ 证书密码
✅ 邮件服务器密码
```

### 4.2 Jasypt加密方案（简单实用）


**工作原理图解**：

```
开发人员写配置：
password: ENC(加密后的密文)
        ↓
程序启动时：
Jasypt自动解密 → 得到真实密码 → 连接数据库
        ↓
黑客就算拿到配置文件也没用，因为没有解密密钥！
```

**集成步骤**：

**① 添加依赖**

```xml
<dependency>
    <groupId>com.github.ulisesbocchio</groupId>
    <artifactId>jasypt-spring-boot-starter</artifactId>
    <version>3.0.5</version>
</dependency>
```

**② 生成加密密码**

```java
// 临时运行这个程序，生成加密密码
public class PasswordEncryptor {
    public static void main(String[] args) {
        StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();
        encryptor.setPassword("my-secret-key");  // 加密密钥（妥善保管）
        
        String plainPassword = "Admin@123456";  // 原始密码
        String encrypted = encryptor.encrypt(plainPassword);
        
        System.out.println("加密后：" + encrypted);
        // 输出类似：kR9mNx8pQ3vZ7wY2bH5jL0sT...
    }
}
```

**③ 配置文件使用加密密码**

```yaml
spring:
  datasource:
    url: jdbc:mysql://prod-db:3306/db
    username: admin
    password: ENC(kR9mNx8pQ3vZ7wY2bH5jL0sT...)  # 用ENC()包裹加密密文

# 配置加密密钥
jasypt:
  encryptor:
    password: ${JASYPT_PASSWORD}  # 从环境变量读取加密密钥
```

**④ 启动时提供加密密钥**

```bash
# 方式1：环境变量
export JASYPT_PASSWORD=my-secret-key
java -jar api-gateway.jar

# 方式2：启动参数
java -jar api-gateway.jar --jasypt.encryptor.password=my-secret-key

# 方式3：Docker环境变量
docker run -e JASYPT_PASSWORD=my-secret-key api-gateway
```

### 4.3 环境变量方案（推荐生产环境）


**原理**：密码不写在配置文件，而是从系统环境变量读取

```yaml
# 配置文件中用占位符
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}  # 从环境变量读取

# 运维人员在服务器上设置环境变量
export DB_HOST=prod-db.company.com
export DB_PORT=3306
export DB_NAME=gateway_db
export DB_USERNAME=gateway_user
export DB_PASSWORD=RealPassword@2024
```

**优点**：
```
✅ 配置文件可以安全提交Git
✅ 不同服务器可以有不同的密码
✅ 符合12-Factor App最佳实践
✅ 容器化部署（Docker/K8s）天然支持
```

### 4.4 配置中心加密（企业级方案）


**Nacos配置加密示例**：

```yaml
# 在Nacos中配置，密码用占位符
spring:
  datasource:
    password: ${db.password}

# 在Nacos的"配置加密"功能中单独设置：
db.password=加密后的密码
```

**权限控制**：
```
运维负责人：可以看密码
普通开发：看不到密码，只能用
测试人员：只能看测试环境密码
```

---

## 5. 📝 配置版本控制


### 5.1 为什么需要版本控制


**真实故障案例**：

```
某天下午3点：
开发小王：修改了数据库连接池大小
配置改动：maxPoolSize: 50 → 200

结果：
→ 数据库连接数暴增
→ 数据库崩溃
→ 整个系统瘫痪

问题：
❓ 谁改的？不知道
❓ 什么时候改的？不知道  
❓ 怎么恢复？不知道
```

**版本控制解决的问题**：

| 场景 | 没有版本控制 | 有版本控制 |
|------|------------|-----------|
| **误操作** | 改错了不知道怎么恢复 | 一键回滚到之前版本 |
| **追责** | 不知道谁改的 | 清楚记录谁在何时改了什么 |
| **对比** | 不知道改了哪些地方 | 可以对比不同版本的差异 |
| **审计** | 无法追溯历史 | 完整的变更历史 |

### 5.2 Git方式版本控制（Spring Cloud Config）


**配置文件存储在Git仓库**：

```
GitHub仓库结构：
config-repo/
├── api-gateway-dev.yml     # 开发环境配置
├── api-gateway-test.yml    # 测试环境配置
└── api-gateway-prod.yml    # 生产环境配置

每次修改配置：
→ 修改yml文件
→ git commit提交
→ git push推送
→ Config Server自动拉取最新配置
```

**Config Server配置**：

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/company/config-repo  # Git仓库地址
          username: config-admin                       # Git用户名
          password: ${GIT_PASSWORD}                    # Git密码
          default-label: main                          # 默认分支
          search-paths: config                         # 配置文件路径
```

**版本管理实践**：

```bash
# 1. 创建功能分支
git checkout -b feature/update-db-pool

# 2. 修改配置
vi api-gateway-prod.yml

# 3. 提交并说明原因
git commit -m "增加数据库连接池：50→200，应对流量高峰"

# 4. 合并到主分支
git checkout main
git merge feature/update-db-pool
git push

# 5. 如果出问题，快速回滚
git revert HEAD  # 撤销最后一次提交
```

### 5.3 Nacos版本管理


**Nacos的版本功能**：

```
Nacos控制台操作：

① 点击配置文件右侧的"历史版本"
② 看到完整的修改历史：
   
   版本3（当前）| 2024-09-23 15:30 | 张三 | 增加连接池配置
   版本2        | 2024-09-22 10:00 | 李四 | 修改数据库地址
   版本1        | 2024-09-21 09:00 | 王五 | 初始配置

③ 点击任意历史版本：
   → 查看当时的配置内容
   → 一键回滚到该版本
   → 对比不同版本差异
```

**配置对比功能**：

```
选择两个版本对比：
版本3 vs 版本2

差异显示：
+ maxPoolSize: 200     # 新增
- maxPoolSize: 50      # 删除
  timeout: 30000       # 未变

一目了然知道改了什么！
```

### 5.4 版本管理最佳实践


**🔸 提交规范**

```
好的提交说明：
✅ "紧急修复：数据库连接池从200调整为100，缓解数据库压力"
✅ "性能优化：Redis缓存过期时间从1小时调整为30分钟"
✅ "新增路由：添加订单服务路由配置"

不好的提交说明：
❌ "修改配置"
❌ "update"  
❌ "fix bug"
```

**🔸 分支策略**

```
生产配置分支策略：

main分支：
→ 当前生产环境使用的配置
→ 只能通过pull request合并
→ 需要审核通过才能合并

develop分支：
→ 开发测试环境配置
→ 开发人员可以直接提交

hotfix分支：
→ 紧急修复配置问题
→ 修复后直接合并到main
```

---

## 6. ⚡ 动态配置更新


### 6.1 什么是动态配置更新


**传统方式的痛点**：

```
场景：需要调整限流阈值

传统做法：
① 修改配置文件
② 重新打包部署
③ 重启所有网关实例
   
问题：
→ 重启需要5-10分钟
→ 期间服务不可用
→ 用户无法访问
```

**动态更新的优势**：

```
有了动态更新：
① 在Nacos控制台改配置
② 点击"发布"按钮
③ 配置立即生效
   
效果：
→ 无需重启
→ 零停机时间
→ 实时生效
```

### 6.2 Spring Cloud实现动态刷新


**方式一：@RefreshScope注解（最常用）**

```java
@RestController
@RefreshScope  // 关键注解：支持配置动态刷新
public class GatewayController {
    
    @Value("${gateway.ratelimit.qps}")  // 从配置读取限流值
    private Integer rateLimitQps;
    
    @GetMapping("/info")
    public Map<String, Object> getInfo() {
        Map<String, Object> info = new HashMap<>();
        info.put("当前限流QPS", rateLimitQps);
        return info;
    }
}
```

**工作原理**：

```
① Nacos配置改变：qps: 100 → 200

② Nacos通知所有订阅的应用

③ Spring Cloud收到通知

④ 销毁@RefreshScope的Bean

⑤ 重新创建Bean，注入新值

⑥ 限流值从100变为200，不需要重启！
```

**方式二：配置类动态刷新**

```java
@Data
@Component
@ConfigurationProperties(prefix = "gateway.ratelimit")
@RefreshScope  // 配置类也要加这个注解
public class RateLimitConfig {
    private Integer qps;           // 每秒请求数
    private Integer maxBurst;      // 最大突发流量
    private Integer timeout;       // 超时时间
}

// 使用配置
@Service
public class RateLimitService {
    
    @Autowired
    private RateLimitConfig config;  // 自动注入配置
    
    public boolean checkRateLimit() {
        int currentQps = config.getQps();  // 获取最新配置
        // 限流逻辑...
    }
}
```

### 6.3 监听配置变化


**场景**：配置改变时需要执行特定逻辑

```java
@Component
public class ConfigChangeListener {
    
    @NacosConfigListener(dataId = "api-gateway-prod.yml", groupId = "DEFAULT_GROUP")
    public void onConfigChange(String newConfig) {
        System.out.println("配置发生变化！");
        System.out.println("新配置内容：" + newConfig);
        
        // 可以做一些处理：
        // 1. 记录日志
        // 2. 发送告警
        // 3. 刷新缓存
        // 4. 重新初始化某些组件
    }
}
```

**更精细的监听**：

```java
@Component
public class RateLimitConfigListener {
    
    @Autowired
    private RateLimitService rateLimitService;
    
    // 只监听限流配置的变化
    @NacosValue(value = "${gateway.ratelimit.qps}", autoRefreshed = true)
    private Integer qps;
    
    @PostConstruct
    public void init() {
        // 定时检查配置是否变化
        Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -> {
            // 配置变化后的处理逻辑
            rateLimitService.updateRateLimit(qps);
        }, 0, 5, TimeUnit.SECONDS);
    }
}
```

### 6.4 灰度发布配置


**什么是灰度发布**：

```
场景：要把限流从100调整到500

传统做法：一次性全部调整
风险：如果500太高，所有服务都挂

灰度发布：
步骤1：10%的实例先用500
步骤2：观察30分钟，没问题
步骤3：50%的实例用500
步骤4：再观察，没问题
步骤5：100%全部使用500

这样逐步放量，风险可控！
```

**Nacos灰度发布配置**：

```
① 在Nacos创建Beta配置：
   Data ID: api-gateway-prod.yml
   勾选"Beta发布"
   填写灰度IP：192.168.1.100,192.168.1.101
   
② 这两台机器会使用Beta配置，其他机器用正式配置

③ 观察Beta机器运行情况

④ 如果没问题，点击"发布"全部生效

⑤ 如果有问题，点击"停止Beta"回滚
```

**代码实现灰度逻辑**：

```java
@Component
public class GrayReleaseFilter implements GlobalFilter {
    
    @Value("${gateway.gray.enabled:false}")
    private Boolean grayEnabled;
    
    @Value("${gateway.gray.version:v1}")
    private String grayVersion;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        if (grayEnabled) {
            // 从请求头获取用户标识
            String userId = exchange.getRequest().getHeaders().getFirst("User-Id");
            
            // 根据规则决定是否使用灰度配置
            if (shouldUseGrayConfig(userId)) {
                // 路由到灰度版本服务
                exchange.getAttributes().put("version", grayVersion);
            }
        }
        return chain.filter(exchange);
    }
    
    private boolean shouldUseGrayConfig(String userId) {
        // 灰度规则：userId尾号是5的用户使用灰度版本
        return userId != null && userId.endsWith("5");
    }
}
```

---

## 7. 📊 配置变更审计


### 7.1 为什么需要审计


**真实案例**：

```
故障场景：
时间：凌晨2点
现象：大量用户无法登录
原因：有人误改了认证服务地址

调查过程（没有审计）：
→ 不知道谁改的
→ 不知道什么时候改的
→ 不知道改了什么
→ 花了2小时才找到问题

如果有审计：
→ 查看审计日志：小李在1:58分修改了auth-service配置
→ 立即定位问题
→ 5分钟恢复服务
```

**审计的核心价值**：

```
🔍 问题追溯
谁在什么时候做了什么操作？

📈 安全合规  
满足企业安全审计要求

⚠️ 风险预警
发现异常配置变更

📊 统计分析
配置变更频率、热点配置等
```

### 7.2 审计日志内容


**完整的审计记录应该包含**：

```
审计记录结构：

基本信息：
├─ 操作人：张三（zhangsan@company.com）
├─ 操作时间：2024-09-23 15:30:25
├─ 操作类型：修改配置
├─ 操作IP：192.168.1.100
└─ 操作来源：Nacos控制台

配置信息：
├─ 配置ID：api-gateway-prod.yml
├─ 配置分组：DEFAULT_GROUP
├─ 命名空间：production
└─ 环境：生产环境

变更详情：
├─ 变更前：maxPoolSize: 50
├─ 变更后：maxPoolSize: 200
├─ 变更原因：应对晚高峰流量
└─ 审批人：李四（运维负责人）

影响范围：
├─ 影响服务：api-gateway
├─ 影响实例：10个实例
└─ 生效时间：立即生效
```

### 7.3 Nacos审计功能


**开启审计日志**：

```yaml
# Nacos配置文件 application.properties
# 开启审计日志
nacos.core.auth.enabled=true

# 审计日志存储
nacos.naming.audit.enabled=true
nacos.naming.audit.path=/var/log/nacos/audit

# 日志保留天数
nacos.naming.audit.max-days=90
```

**查看审计日志**：

```
Nacos控制台 → 权限控制 → 审计日志

看到的内容：
┌─────────────────────────────────────────┐
│ 时间              | 用户   | 操作   | 详情  │
├─────────────────────────────────────────┤
│ 2024-09-23 15:30 | 张三   | 更新   | 查看  │
│ 2024-09-23 14:20 | 李四   | 删除   | 查看  │
│ 2024-09-23 10:15 | 王五   | 创建   | 查看  │
└─────────────────────────────────────────┘
```

### 7.4 自定义审计日志


**记录到数据库**：

```java
@Aspect
@Component
public class ConfigAuditAspect {
    
    @Autowired
    private ConfigAuditService auditService;
    
    @Around("@annotation(ConfigChange)")  // 拦截配置变更操作
    public Object auditConfigChange(ProceedingJoinPoint pjp) throws Throwable {
        // 操作前记录
        ConfigAuditLog log = new ConfigAuditLog();
        log.setOperator(getCurrentUser());        // 操作人
        log.setOperateTime(new Date());          // 操作时间
        log.setConfigKey(getConfigKey(pjp));     // 配置项
        log.setOldValue(getOldValue(pjp));       // 修改前的值
        
        // 执行实际操作
        Object result = pjp.proceed();
        
        // 操作后记录
        log.setNewValue(getNewValue(pjp));       // 修改后的值
        log.setOperateResult("成功");
        
        // 保存审计日志
        auditService.save(log);
        
        return result;
    }
}
```

**审计日志表结构**：

```sql
CREATE TABLE config_audit_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    operator VARCHAR(50) COMMENT '操作人',
    operate_time DATETIME COMMENT '操作时间',
    operate_type VARCHAR(20) COMMENT '操作类型：CREATE/UPDATE/DELETE',
    config_key VARCHAR(200) COMMENT '配置项',
    old_value TEXT COMMENT '修改前的值',
    new_value TEXT COMMENT '修改后的值',
    operate_ip VARCHAR(50) COMMENT '操作IP',
    operate_result VARCHAR(20) COMMENT '操作结果：成功/失败',
    change_reason VARCHAR(500) COMMENT '变更原因',
    approver VARCHAR(50) COMMENT '审批人',
    INDEX idx_operator (operator),
    INDEX idx_operate_time (operate_time)
) COMMENT='配置变更审计日志';
```

### 7.5 配置变更工作流


**企业级变更流程**：

```
配置变更申请流程：

第一步：提交变更申请
├─ 开发人员：填写变更申请单
├─ 变更内容：描述要改什么
├─ 变更原因：为什么要改
└─ 影响评估：改了会有什么影响

第二步：审批流程
├─ 技术负责人审批：技术方案是否合理
├─ 运维负责人审批：是否影响系统稳定性
└─ 如果是生产环境：需要更高级别审批

第三步：执行变更
├─ 在规定的时间窗口执行
├─ 记录详细的审计日志
└─ 监控系统运行状态

第四步：变更验证
├─ 验证配置是否生效
├─ 检查系统是否正常
└─ 如有问题立即回滚

第五步：变更总结
├─ 记录变更结果
├─ 更新文档
└─ 经验教训总结
```

**代码实现审批流程**：

```java
@Service
public class ConfigChangeWorkflowService {
    
    // 提交变更申请
    public ConfigChangeRequest submitRequest(ConfigChangeDTO dto) {
        ConfigChangeRequest request = new ConfigChangeRequest();
        request.setApplicant(dto.getApplicant());
        request.setConfigKey(dto.getConfigKey());
        request.setOldValue(getCurrentValue(dto.getConfigKey()));
        request.setNewValue(dto.getNewValue());
        request.setChangeReason(dto.getReason());
        request.setStatus("PENDING");  // 待审批
        
        // 保存申请
        return configChangeRequestRepository.save(request);
    }
    
    // 审批变更
    public void approveChange(Long requestId, String approver) {
        ConfigChangeRequest request = findRequest(requestId);
        
        // 检查审批权限
        if (!hasApprovePermission(approver, request)) {
            throw new BusinessException("无审批权限");
        }
        
        // 更新状态
        request.setApprover(approver);
        request.setApproveTime(new Date());
        request.setStatus("APPROVED");
        
        // 执行配置变更
        executeConfigChange(request);
        
        // 发送通知
        notifyApplicant(request);
    }
    
    // 执行配置变更
    private void executeConfigChange(ConfigChangeRequest request) {
        try {
            // 通过Nacos API修改配置
            nacosConfigService.publishConfig(
                request.getConfigKey(),
                request.getNewValue()
            );
            
            // 记录审计日志
            auditService.log(request);
            
        } catch (Exception e) {
            // 变更失败，记录错误
            request.setStatus("FAILED");
            request.setErrorMessage(e.getMessage());
        }
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 环境配置管理知识地图


```
环境配置管理体系
│
├── 基础配置分离
│   ├── 多环境配置文件（dev/test/prod）
│   ├── 配置继承与覆盖机制
│   └── 环境切换方法
│
├── 配置中心集成
│   ├── Spring Cloud Config（Git存储）
│   ├── Nacos（推荐，功能强大）
│   ├── Apollo（企业级）
│   └── 命名空间隔离
│
├── 安全加密
│   ├── Jasypt加密工具
│   ├── 环境变量方案
│   └── 配置中心加密
│
├── 版本控制
│   ├── Git版本管理
│   ├── Nacos历史版本
│   ├── 配置对比功能
│   └── 版本回滚机制
│
├── 动态更新
│   ├── @RefreshScope注解
│   ├── 配置监听机制
│   └── 灰度发布策略
│
└── 变更审计
    ├── 审计日志记录
    ├── 操作追溯
    ├── 变更工作流
    └── 权限控制
```

### 8.2 核心概念速记


**🔸 环境配置三要素**

```
1️⃣ 环境隔离：开发、测试、生产各用各的
2️⃣ 集中管理：统一配置中心，避免混乱
3️⃣ 安全可控：敏感信息加密，权限严格控制
```

**🔸 配置中心选择**

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| 小型项目 | Spring Cloud Config | 简单易用，Git版本控制 |
| 中大型项目 | Nacos | 功能完善，可视化管理 |
| 企业级应用 | Apollo | 功能最强，权限完善 |

**🔸 敏感信息保护三板斧**

```
① 加密存储：Jasypt加密，配置文件里看不到明文
② 环境变量：密码不写代码，从环境变量读
③ 权限控制：谁能看、谁能改，严格管理
```

**🔸 动态配置更新要点**

```
关键点：@RefreshScope注解

使用场景：
✅ 限流阈值调整
✅ 开关控制
✅ 业务参数配置

不适用场景：
❌ 数据源配置（需要重启）
❌ 端口号（需要重启）
❌ 核心框架配置（需要重启）
```

### 8.3 实战经验总结


**💡 最佳实践**

```
1. 环境分离原则
   ✅ 开发、测试、生产严格分离
   ✅ 使用不同的命名空间或配置文件
   ✅ 生产配置需要审批才能修改

2. 密码安全原则  
   ✅ 绝不在代码中写明文密码
   ✅ 生产密码定期更换
   ✅ 使用强密码策略

3. 变更管理原则
   ✅ 所有变更必须有记录
   ✅ 重要变更需要审批
   ✅ 变更前做好回滚预案
   
4. 灰度发布原则
   ✅ 重要配置变更先灰度
   ✅ 观察一段时间再全量
   ✅ 随时准备回滚
```

**⚠️ 常见坑点**

```
坑1：配置文件提交到Git
→ 解决：使用.gitignore忽略敏感配置
→ 或者：只提交配置模板，真实配置用环境变量

坑2：修改配置忘记重启
→ 解决：使用@RefreshScope支持动态刷新
→ 或者：配置监听器自动处理

坑3：配置改错了不知道怎么恢复  
→ 解决：使用配置中心的版本管理
→ 一键回滚到历史版本

坑4：多人同时改配置冲突
→ 解决：使用配置锁机制
→ 或者：通过工作流审批避免冲突

坑5：环境配置搞混
→ 解决：命名空间严格隔离
→ 不同环境用不同颜色标识
```

### 8.4 学习路径建议


**入门阶段（第1-2周）**
```
□ 理解环境配置的概念和作用
□ 掌握Spring Boot多环境配置
□ 学会使用application-{profile}.yml
□ 了解配置优先级规则
```

**进阶阶段（第3-4周）**
```
□ 搭建Nacos配置中心
□ 实现配置的集中管理
□ 掌握Jasypt加密使用
□ 学会动态刷新配置
```

**实战阶段（第5-6周）**
```
□ 实现完整的配置管理方案
□ 搭建配置审计系统
□ 设计配置变更工作流
□ 实践灰度发布策略
```

**核心记忆**：
- 环境配置要分离，开发测试生产明
- 敏感信息要加密，密码不能写代码里
- 配置中心集中管，版本控制能回滚
- 动态刷新不重启，审计日志留痕迹