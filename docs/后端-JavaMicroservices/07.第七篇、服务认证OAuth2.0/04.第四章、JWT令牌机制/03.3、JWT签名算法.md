---
title: 3、JWT签名算法
---
## 📚 目录

1. [JWT签名算法基础](#1-JWT签名算法基础)
2. [HMAC对称加密算法](#2-HMAC对称加密算法)
3. [RSA非对称加密算法](#3-RSA非对称加密算法)
4. [ECDSA椭圆曲线算法](#4-ECDSA椭圆曲线算法)
5. [签名算法选择与对比](#5-签名算法选择与对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔐 JWT签名算法基础


### 1.1 为什么需要签名


**🤔 问题场景**

想象一下，你在网上买东西：
```
用户登录后 → 服务器给你一个JWT令牌（像通行证）
你拿着令牌去访问 → 查看订单、修改地址等

问题来了：
• 黑客能不能伪造这个令牌？
• 用户能不能篡改令牌内容（比如改成VIP）？
• 服务器怎么知道令牌是真的？
```

**💡 解决方案：数字签名**

签名就像**防伪标记**：
- 服务器生成JWT时，用密钥计算一个签名
- 用户拿到JWT，里面包含数据+签名
- 服务器验证时，重新计算签名对比
- 如果有人篡改数据，签名就对不上了

### 1.2 JWT签名的结构


**📋 JWT组成部分**

```
完整的JWT长这样：
eyJhbGc... . eyJzdWI... . SflKxwRJ...
  ↑           ↑           ↑
 Header      Payload    Signature
（头部）    （载荷）    （签名）
```

**三部分详解**：

| 部分 | 内容 | 作用 |
|------|------|------|
| **Header** | `{"alg":"HS256","typ":"JWT"}` | 说明使用的签名算法 |
| **Payload** | `{"sub":"user123","exp":1234567890}` | 存放用户信息和过期时间 |
| **Signature** | `密钥+算法计算出的签名` | 防止篡改的防伪标记 |

### 1.3 签名的工作原理


**🔄 签名生成过程**

```
步骤1：准备数据
Header + Payload → base64编码 → "eyJhbGc...eyJzdWI..."

步骤2：计算签名
数据 + 密钥 → 签名算法 → Signature

步骤3：组装JWT
Header.Payload.Signature → 完整的JWT令牌
```

**✅ 签名验证过程**

```
客户端发来JWT：
Header.Payload.Signature

服务器验证：
1. 取出Header和Payload
2. 用密钥重新计算签名
3. 对比计算结果和Signature
4. 一致 ✅ → 令牌有效
   不一致 ❌ → 令牌被篡改
```

> **💡 关键理解**：签名不是加密！
> - **加密**：把内容变成别人看不懂的（保护隐私）
> - **签名**：证明内容没被改过（保证完整性）
> - JWT的Header和Payload是Base64编码，任何人都能解码看到内容
> - 但没有密钥，就无法生成正确的签名

---

## 2. 🔑 HMAC对称加密算法


### 2.1 什么是HMAC


**📖 基本概念**

HMAC全称：**H**ash-based **M**essage **A**uthentication **C**ode（基于哈希的消息认证码）

**通俗理解**：
```
就像你和朋友约定一个暗号：

你们都知道密码是："abc123"
发消息时：消息内容 + 密码 → 计算哈希值 → 签名
收消息时：拿到消息 + 用密码 → 重新计算 → 对比签名

只有知道密码的人，才能生成和验证签名
```

**🔸 对称加密的特点**

```
对称 = 加密和解密用同一个密钥

签名：服务器用密钥A生成签名
验证：服务器用密钥A验证签名
      ↑
   同一个密钥！
```

### 2.2 HS256算法详解


**🎯 HS256是什么**

`HS256` = `HMAC` + `SHA-256`
- **HMAC**：签名方式
- **SHA-256**：哈希算法（生成256位的摘要）

**💻 工作流程**

```
输入：
• 数据：Header.Payload（Base64编码后）
• 密钥：secret_key（服务器保存的密钥）

计算过程：
数据 + 密钥 → SHA-256哈希 → 256位签名

输出：
一串固定长度的签名字符串
```

**📝 代码示例（Java实现）**

```java
// 生成HS256签名的JWT
public String createJWT() {
    // 设置密钥
    String secret = "mySecretKey123";
    
    // 创建JWT
    String jwt = Jwts.builder()
        .setSubject("user123")           // 用户ID
        .setExpiration(new Date(System.currentTimeMillis() + 3600000))
        .signWith(SignatureAlgorithm.HS256, secret)  // HS256签名
        .compact();
    
    return jwt;
}

// 验证JWT
public Claims verifyJWT(String jwt) {
    String secret = "mySecretKey123";  // 同样的密钥
    
    return Jwts.parser()
        .setSigningKey(secret)           // 用相同密钥验证
        .parseClaimsJws(jwt)
        .getBody();
}
```

### 2.3 HMAC的优缺点


**✅ 优点**

| 优点 | 说明 |
|------|------|
| **速度快** | 计算简单，性能好 |
| **实现简单** | 代码少，容易理解 |
| **密钥短** | 密钥可以很短（如32字节） |

**❌ 缺点**

| 缺点 | 说明 | 影响 |
|------|------|------|
| **密钥共享** | 所有服务器都要有密钥 | 密钥泄露风险大 |
| **无法分发** | 不能给第三方验证 | 只能内部使用 |
| **密钥管理难** | 更换密钥要同步所有服务器 | 运维成本高 |

**🎯 适用场景**

```
✅ 适合：
• 单体应用或少量服务器
• 内部系统，不需要第三方验证
• 对性能要求高的场景

❌ 不适合：
• 大规模微服务架构
• 需要第三方验证的场景
• 多个不同团队协作
```

---

## 3. 🔐 RSA非对称加密算法


### 3.1 什么是RSA


**📖 非对称加密原理**

想象一个**特殊的锁**：
```
公钥 = 锁（任何人都能用它锁门）
私钥 = 钥匙（只有主人有，用来开锁）

签名过程：
服务器用私钥"锁"JWT → 生成签名

验证过程：
任何人用公钥"开锁"→ 验证签名
```

**🔸 非对称的核心**

```
两个不同的密钥：

私钥（Private Key）：
• 服务器独有，绝不能泄露
• 用来生成签名

公钥（Public Key）：
• 可以公开分享
• 只能验证签名，不能生成签名
```

### 3.2 RS256算法详解


**🎯 RS256是什么**

`RS256` = `RSA` + `SHA-256`
- **RSA**：非对称加密算法
- **SHA-256**：哈希算法

**💻 工作流程**

```
签名过程：
数据 → SHA-256哈希 → 用私钥加密 → 签名

验证过程：
签名 → 用公钥解密 → 对比哈希值 → 验证成功/失败
```

**📝 代码示例（生成密钥对）**

```java
// 1. 生成RSA密钥对
public KeyPair generateKeyPair() {
    KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
    generator.initialize(2048);  // 2048位密钥
    return generator.generateKeyPair();
}

// 2. 用私钥生成JWT
public String createJWT(PrivateKey privateKey) {
    return Jwts.builder()
        .setSubject("user123")
        .signWith(SignatureAlgorithm.RS256, privateKey)  // 私钥签名
        .compact();
}

// 3. 用公钥验证JWT
public Claims verifyJWT(String jwt, PublicKey publicKey) {
    return Jwts.parser()
        .setSigningKey(publicKey)  // 公钥验证
        .parseClaimsJws(jwt)
        .getBody();
}
```

### 3.3 RSA的密钥管理


**🔑 密钥对的使用**

```
认证服务器（Auth Server）：
• 持有私钥
• 负责生成JWT
• 私钥必须严格保密

资源服务器（Resource Server）：
• 持有公钥
• 负责验证JWT
• 公钥可以公开分享

用户/客户端：
• 只拿到JWT
• 不需要任何密钥
```

**🔄 密钥分发流程**

```
步骤1：认证服务器生成密钥对
私钥：保存在认证服务器
公钥：分发给所有需要验证JWT的服务

步骤2：用户登录
认证服务器 → 用私钥生成JWT → 返回给用户

步骤3：访问资源
用户携带JWT → 资源服务器用公钥验证 → 允许访问
```

### 3.4 RSA的优缺点


**✅ 优点**

| 优点 | 说明 | 价值 |
|------|------|------|
| **密钥分离** | 私钥只在认证服务器 | 安全性高 |
| **可分发** | 公钥可以给任何人 | 支持第三方验证 |
| **易扩展** | 新服务器只需要公钥 | 适合微服务 |

**❌ 缺点**

| 缺点 | 说明 |
|------|------|
| **速度慢** | 计算复杂，比HMAC慢10-100倍 |
| **密钥长** | 通常2048位或4096位 |
| **占用大** | 签名结果更长 |

**🎯 适用场景**

```
✅ 适合：
• 微服务架构（多个服务需要验证）
• 需要第三方验证的场景
• 对安全性要求高的系统

❌ 不适合：
• 对性能极其敏感的场景
• 简单的单体应用
```

---

## 4. 📈 ECDSA椭圆曲线算法


### 4.1 什么是ECDSA


**📖 椭圆曲线加密**

ECDSA全称：**E**lliptic **C**urve **D**igital **S**ignature **A**lgorithm（椭圆曲线数字签名算法）

**通俗理解**：
```
椭圆曲线 = 一种数学曲线

特点：
• 比RSA更高级的数学原理
• 用更短的密钥达到同样的安全强度
• 就像用"新式武器"替代"老式武器"
```

**🔸 与RSA的对比**

```
安全强度对比：

RSA 2048位 ≈ ECDSA 256位
RSA 3072位 ≈ ECDSA 384位
       ↑
   同样安全，但ECDSA密钥更短！
```

### 4.2 ES256算法详解


**🎯 ES256是什么**

`ES256` = `ECDSA` + `P-256曲线` + `SHA-256`
- **ECDSA**：椭圆曲线签名算法
- **P-256**：特定的椭圆曲线（也叫secp256r1）
- **SHA-256**：哈希算法

**💻 工作原理**

```
签名过程：
1. 数据 → SHA-256哈希
2. 用私钥在椭圆曲线上计算签名点
3. 签名点坐标 → 签名值

验证过程：
1. 签名 → 用公钥在曲线上验证
2. 对比哈希值
3. 验证成功/失败
```

**📝 代码示例**

```java
// 生成EC密钥对
public KeyPair generateECKeyPair() {
    KeyPairGenerator generator = KeyPairGenerator.getInstance("EC");
    generator.initialize(256);  // 256位密钥
    return generator.generateKeyPair();
}

// 用ES256生成JWT
public String createJWT(PrivateKey privateKey) {
    return Jwts.builder()
        .setSubject("user123")
        .signWith(SignatureAlgorithm.ES256, privateKey)  // ES256签名
        .compact();
}
```

### 4.3 ECDSA的优势


**✅ 核心优势**

| 优势 | 具体说明 |
|------|----------|
| **密钥短** | 256位就能达到RSA 2048位的安全性 |
| **签名小** | 生成的签名更短，节省带宽 |
| **速度快** | 比RSA快，接近HMAC的速度 |
| **移动友好** | 适合计算能力有限的移动设备 |

**📊 性能对比**

```
签名速度（越快越好）：
HMAC:    ████████████ (最快)
ECDSA:   ████████░░░░ (较快)
RSA:     ████░░░░░░░░ (较慢)

签名大小（越小越好）：
ECDSA:   ████░░░░░░░░ (最小)
HMAC:    ██████░░░░░░ (较小)
RSA:     ████████████ (最大)
```

### 4.4 常见的椭圆曲线


**🔢 ECDSA曲线列表**

| 算法 | 曲线 | 密钥位数 | 等效RSA位数 | 适用场景 |
|------|------|----------|-------------|----------|
| **ES256** | P-256 | 256 | 2048 | 通用场景 |
| **ES384** | P-384 | 384 | 3072 | 高安全要求 |
| **ES512** | P-521 | 521 | 15360 | 极高安全要求 |

**🎯 选择建议**

```
一般应用：ES256
• 安全性足够
• 性能最好
• 兼容性最广

政府/金融：ES384或ES512
• 更高的安全级别
• 符合合规要求
```

---

## 5. ⚖️ 签名算法选择与对比


### 5.1 三大算法对比


**📊 全面对比表**

| 特性 | **HMAC (HS256)** | **RSA (RS256)** | **ECDSA (ES256)** |
|------|------------------|-----------------|-------------------|
| **加密类型** | 对称加密 | 非对称加密 | 非对称加密 |
| **密钥长度** | 32字节 | 2048位 | 256位 |
| **签名速度** | ⚡⚡⚡ 最快 | 🐌 较慢 | ⚡⚡ 较快 |
| **验证速度** | ⚡⚡⚡ 最快 | ⚡⚡ 较快 | ⚡⚡ 较快 |
| **签名大小** | 32字节 | 256字节 | 64字节 |
| **安全强度** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **密钥管理** | ❌ 复杂 | ✅ 简单 | ✅ 简单 |
| **第三方验证** | ❌ 不支持 | ✅ 支持 | ✅ 支持 |

### 5.2 实际场景选择


**🎯 选择决策树**

```
开始选择
    |
    ├─ 单体应用？
    |   └─ 是 → HMAC (HS256)
    |          优势：速度快，实现简单
    |
    ├─ 微服务架构？
    |   └─ 是 → 需要第三方验证？
    |          |
    |          ├─ 需要 → RSA (RS256) 或 ECDSA (ES256)
    |          |         优势：密钥分离，公钥可分发
    |          |
    |          └─ 不需要 → 看性能要求
    |                     |
    |                     ├─ 性能要求高 → ECDSA (ES256)
    |                     └─ 兼容性优先 → RSA (RS256)
```

**📋 具体场景建议**

| 场景 | 推荐算法 | 原因 |
|------|----------|------|
| **内部系统** | HS256 | 速度快，密钥管理简单 |
| **开放API** | RS256/ES256 | 公钥可公开，第三方可验证 |
| **移动应用** | ES256 | 签名小，省流量，速度快 |
| **高安全系统** | ES384/ES512 | 更高的安全强度 |
| **大规模微服务** | ES256 | 性能和安全的平衡 |

### 5.3 密钥管理最佳实践


**🔐 HMAC密钥管理**

```
✅ 推荐做法：
• 使用环境变量存储密钥，不写在代码里
• 定期轮换密钥（如每月更换）
• 不同环境用不同密钥（开发/测试/生产）

❌ 避免：
• 硬编码密钥在代码中
• 多个应用共用同一个密钥
• 长期不更换密钥
```

**🔑 RSA/ECDSA密钥管理**

```
✅ 推荐做法：
私钥：
• 存储在安全的密钥管理服务（如AWS KMS）
• 使用HSM硬件安全模块
• 严格限制访问权限

公钥：
• 通过HTTPS端点公开
• 支持JWKS格式（JSON Web Key Set）
• 设置合理的缓存时间

❌ 避免：
• 私钥存储在代码仓库
• 私钥通过不安全的渠道传输
• 公钥没有版本管理
```

### 5.4 安全强度对比


**🛡️ 密钥长度与安全性**

```
对称加密（HMAC）：
• 128位 → 基本安全
• 256位 → 推荐使用
• 512位 → 高安全场景

非对称加密（RSA）：
• 1024位 → ❌ 已不安全
• 2048位 → ✅ 目前推荐
• 3072位 → ✅ 高安全
• 4096位 → ✅ 极高安全

椭圆曲线（ECDSA）：
• 256位 → ✅ 推荐（等效RSA 2048位）
• 384位 → ✅ 高安全
• 521位 → ✅ 极高安全
```

**⏱️ 算法寿命预测**

| 算法 | 当前状态 | 预计安全年限 |
|------|----------|--------------|
| **HS256** | ✅ 安全 | 10+ 年 |
| **RS256 (2048位)** | ✅ 安全 | 5-10 年 |
| **RS256 (3072位)** | ✅ 安全 | 15+ 年 |
| **ES256** | ✅ 安全 | 15+ 年 |

### 5.5 性能测试对比


**📊 实际性能数据**

```
测试环境：普通服务器，单核CPU

签名性能（每秒操作数）：
HMAC (HS256):   100,000+ ops/s  ⚡⚡⚡
ECDSA (ES256):   20,000+ ops/s  ⚡⚡
RSA (RS256):      5,000+ ops/s  ⚡

验证性能（每秒操作数）：
HMAC (HS256):   100,000+ ops/s  ⚡⚡⚡
RSA (RS256):     30,000+ ops/s  ⚡⚡
ECDSA (ES256):   15,000+ ops/s  ⚡⚡

结论：
• HMAC最快，适合高并发场景
• ECDSA是非对称算法中的性能冠军
• RSA验证快但签名慢
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


**🔸 签名的本质**
- 签名不是加密，是**防篡改**的手段
- 通过密钥和算法生成签名
- 任何数据修改都会导致签名失效

**🔸 三大算法核心**

```
HMAC（对称加密）：
✅ 一个密钥，签名和验证都用它
✅ 速度最快，实现最简单
❌ 密钥需要共享，不能给第三方

RSA（非对称加密）：
✅ 两个密钥，私钥签名，公钥验证
✅ 公钥可公开，支持第三方验证
❌ 速度慢，密钥长

ECDSA（椭圆曲线）：
✅ 非对称，密钥短，签名小
✅ 性能好，安全性高
✅ 现代应用的最佳选择
```

### 6.2 算法选择口诀


```
🎵 记忆口诀：
内部系统选HMAC，速度快来实现简
开放API用非对称，公钥分发很方便
性能安全要兼顾，椭圆曲线ECDSA选
移动应用省流量，ES256签名体积小
```

### 6.3 实践建议


**📌 初学者建议**

```
第一步：
• 学习JWT基本概念
• 理解签名的作用
• 掌握HMAC (HS256)

第二步：
• 了解公钥私钥概念
• 学习RSA (RS256)
• 理解密钥分发

第三步：
• 研究椭圆曲线原理
• 掌握ECDSA (ES256)
• 对比三种算法

第四步：
• 实际项目中应用
• 掌握密钥管理
• 了解安全最佳实践
```

**🔧 工程实践要点**

| 阶段 | 重点工作 |
|------|----------|
| **开发阶段** | 选择合适算法，实现签名和验证 |
| **测试阶段** | 测试性能，验证安全性 |
| **部署阶段** | 密钥安全存储，配置环境变量 |
| **运维阶段** | 密钥轮换，监控签名失败率 |

### 6.4 常见问题解答


**❓ 为什么不推荐HS256用于微服务？**

```
原因：
• 所有服务都需要同一个密钥
• 密钥泄露风险大（任何一个服务泄露都完了）
• 新服务上线需要同步密钥
• 第三方无法验证（只能内部用）

解决方案：
• 使用RS256或ES256
• 认证服务持有私钥
• 其他服务只需要公钥
```

**❓ RS256和ES256怎么选？**

```
选RS256的情况：
• 需要兼容老系统
• 团队更熟悉RSA
• 不在意性能差异

选ES256的情况：
• 追求最佳性能
• 移动应用场景
• 现代化架构
```

**❓ 密钥多久需要轮换？**

```
HMAC密钥：
• 建议1-3个月轮换一次
• 泄露风险高的环境要更频繁

RSA/ECDSA私钥：
• 建议6-12个月轮换一次
• 配合密钥版本管理

公钥：
• 随私钥一起更新
• 保留旧公钥一段时间（平滑过渡）
```

### 6.5 学习资源推荐


**📚 深入学习**

```
基础文档：
• RFC 7518：JSON Web Algorithms (JWA)
• RFC 7519：JSON Web Token (JWT)

推荐工具：
• jwt.io：在线解析JWT
• JJWT库：Java实现JWT的标准库
• Auth0：提供完整的认证解决方案

实践项目：
• 搭建认证服务器
• 实现多种签名算法
• 对比性能差异
```

**🔍 进阶主题**

- JWT密钥轮换机制
- JWKS（JSON Web Key Set）
- 分布式环境下的密钥管理
- JWT性能优化技巧

---

**🎯 核心记忆**：
- **HMAC快但要共享密钥**，适合内部小系统
- **RSA公钥可公开分发**，但性能较慢
- **ECDSA集众家之长**，现代应用首选
- **选算法看场景**，没有绝对的最优解
- **密钥管理是关键**，安全大于一切