---
title: 5、刷新令牌机制
---
## 📚 目录

1. [刷新令牌的本质理解](#1-刷新令牌的本质理解)
2. [访问令牌与刷新令牌的区别](#2-访问令牌与刷新令牌的区别)
3. [刷新令牌的工作流程](#3-刷新令牌的工作流程)
4. [Token生命周期管理](#4-Token生命周期管理)
5. [刷新令牌的续签策略](#5-刷新令牌的续签策略)
6. [安全考虑与最佳实践](#6-安全考虑与最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔑 刷新令牌的本质理解


### 1.1 什么是刷新令牌


**生活化理解**：
```
想象你去游乐园：
访问令牌 = 单次游玩票（玩一次就作废）
刷新令牌 = 年卡兑换凭证（可以换新的游玩票）

你不需要每次都重新排队买票（重新登录），
只需要用年卡凭证换一张新的游玩票就行。
```

**技术定义**：
- **Refresh Token（刷新令牌）**：一种特殊的令牌，专门用来获取新的访问令牌
- **本质作用**：在访问令牌过期后，无需用户重新登录就能获得新令牌
- **核心价值**：提升用户体验 + 保持安全性

> 📌 **核心理解**  
> 刷新令牌就像"免登录续期券"，让你在访问令牌过期后，不用输入密码就能继续使用系统

### 1.2 为什么需要刷新令牌


**解决的核心问题**：

| 问题场景 | **传统方案** | **使用刷新令牌** |
|---------|------------|---------------|
| 访问令牌过期 | 用户重新登录 | 自动获取新令牌 |
| 长时间使用 | 频繁登录，体验差 | 保持登录状态 |
| 安全性 | 令牌长期有效风险大 | 短期令牌+安全续签 |

**实际应用场景**：
```
📱 移动APP：
- 你打开微信，不需要每天都登录
- 后台自动用刷新令牌换取新的访问令牌
- 保持"永久登录"的体验

🌐 网页应用：
- 你在购物网站浏览商品
- 访问令牌2小时过期，刷新令牌30天有效
- 30天内都不需要重新输入密码
```

> 💡 **设计思想**  
> **访问令牌**：短命但使用频繁（像现金，方便但不能放太多）  
> **刷新令牌**：长命但使用稀少（像银行卡，安全但不常用）

---

## 2. 🆚 访问令牌与刷新令牌的区别


### 2.1 核心特性对比


| 对比维度 | **Access Token（访问令牌）** | **Refresh Token（刷新令牌）** |
|---------|---------------------------|------------------------------|
| 🎯 **主要用途** | 访问受保护的资源 | 获取新的访问令牌 |
| ⏰ **有效期** | 短期（几分钟到几小时） | 长期（几天到几个月） |
| 🔄 **使用频率** | 每次API请求都用 | 只在令牌过期时用 |
| 📍 **使用位置** | 发送给资源服务器 | 只发送给认证服务器 |
| 🔒 **安全级别** | 相对宽松（频繁传输） | 严格保护（稀少传输） |
| 💾 **存储方式** | 可存内存（移动端） | 必须安全存储 |

### 2.2 生命周期对比图示


```
访问令牌生命周期（短而频繁）：
时间轴: 0min────15min────30min────45min────60min
令牌1:  [有效期]──过期
令牌2:            [有效期]──过期
令牌3:                      [有效期]──过期
令牌4:                                [有效期]──过期

刷新令牌生命周期（长而稳定）：
时间轴: 0天──────7天──────14天─────21天─────30天
令牌:   [────────────有效期────────────────]
        ↑每次刷新都更新有效期↑
```

### 2.3 实际使用示例


**访问令牌的使用**：
```http
GET /api/user/profile HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
               ↑ 这是访问令牌，每次请求都带上
```

**刷新令牌的使用**：
```http
POST /oauth/token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&
refresh_token=tGzv3JOkF0XG5Qx2TlKWIA...
              ↑ 只在访问令牌过期时才用
```

> ⚠️ **安全提醒**  
> 访问令牌像"临时通行证"，可以随身携带  
> 刷新令牌像"身份证原件"，要妥善保管

---

## 3. 🔄 刷新令牌的工作流程


### 3.1 完整交互流程


```
客户端          认证服务器         资源服务器
  |                |                  |
  |--[1]用户登录--->|                  |
  |<-[2]返回令牌----|                  |
  |  Access Token  |                  |
  |  Refresh Token |                  |
  |                |                  |
  |--[3]访问资源------------------>    |
  |  (携带Access Token)               |
  |<-[4]返回数据-----------------------|
  |                |                  |
  ⏰ Access Token过期                  |
  |                |                  |
  |--[5]访问资源------------------>    |
  |<-[6]返回401错误--------------------|
  |  (令牌已过期)                      |
  |                |                  |
  |--[7]刷新令牌--->|                  |
  |  Refresh Token |                  |
  |<-[8]返回新令牌--|                  |
  |  新Access Token|                  |
  |  新Refresh Token(可选)            |
  |                |                  |
  |--[9]重新访问资源---------------->  |
  |  (携带新Access Token)             |
  |<-[10]返回数据----------------------|
```

### 3.2 详细步骤说明


**步骤1-2：初始登录**
```
用户首次登录时，认证服务器返回两个令牌：
{
  "access_token": "eyJhbGc...",   // 访问令牌（2小时有效）
  "refresh_token": "tGzv3JO...",  // 刷新令牌（30天有效）
  "expires_in": 7200,             // 访问令牌有效期（秒）
  "token_type": "Bearer"
}
```

**步骤3-4：正常访问**
```
客户端使用访问令牌请求资源：
GET /api/data
Authorization: Bearer eyJhbGc...

资源服务器验证通过，返回数据
```

**步骤5-6：令牌过期**
```
访问令牌过期后再次请求：
资源服务器返回：
HTTP/1.1 401 Unauthorized
{
  "error": "invalid_token",
  "error_description": "访问令牌已过期"
}
```

**步骤7-8：刷新令牌**
```
客户端向认证服务器发起刷新请求：
POST /oauth/token
grant_type=refresh_token&
refresh_token=tGzv3JO...

认证服务器验证通过，返回新令牌：
{
  "access_token": "newToken123...",    // 新的访问令牌
  "refresh_token": "newRefresh456...", // 新的刷新令牌（可选）
  "expires_in": 7200
}
```

**步骤9-10：继续访问**
```
使用新的访问令牌继续访问资源
整个过程用户无感知，不需要重新登录
```

> 💡 **关键理解**  
> 刷新令牌的使用对用户是**完全透明**的，客户端应用自动在后台完成令牌刷新

---

## 4. ⏰ Token生命周期管理


### 4.1 访问令牌生命周期


**生命周期阶段**：

```
创建 → 使用 → 即将过期 → 过期 → 失效

[创建阶段]
↓ 认证服务器生成令牌
↓ 设置过期时间戳

[使用阶段]
↓ 客户端携带令牌访问资源
↓ 资源服务器验证令牌有效性

[即将过期阶段]（提前刷新策略）
↓ 距离过期还有5分钟
↓ 客户端主动发起刷新

[过期阶段]
↓ 超过有效期
↓ 资源服务器拒绝访问

[失效阶段]
↓ 用户登出或刷新令牌过期
↓ 令牌彻底作废
```

**有效期设置建议**：

| 应用类型 | **访问令牌有效期** | **刷新令牌有效期** | **理由** |
|---------|-----------------|------------------|---------|
| 🏦 **金融类** | 15-30分钟 | 1-7天 | 高安全要求 |
| 🛒 **电商类** | 1-2小时 | 30-90天 | 平衡安全与体验 |
| 📱 **社交类** | 2-6小时 | 永久/1年 | 用户体验优先 |
| 💼 **企业应用** | 30分钟-1小时 | 8小时（工作日） | 符合办公场景 |

### 4.2 刷新令牌生命周期


**生命周期特点**：

```
创建 → 长期休眠 → 激活使用 → 更新/过期

[创建阶段]
↓ 用户登录时生成
↓ 安全存储（数据库/加密存储）

[休眠阶段]
↓ 大部分时间不使用
↓ 等待访问令牌过期

[激活使用阶段]
↓ 访问令牌过期触发
↓ 向认证服务器请求新令牌

[更新阶段]
↓ 刷新成功后
↓ 可能生成新的刷新令牌（滚动更新）

[过期/失效阶段]
↓ 超过最大有效期
↓ 用户主动登出
↓ 检测到异常行为
```

> 📌 **生命周期管理原则**  
> **访问令牌**：短命，过期即失效，无需存储  
> **刷新令牌**：长命，需要持久化存储和管理

### 4.3 实际代码示例


**令牌信息的存储结构**：
```java
// 访问令牌信息
public class AccessToken {
    private String token;           // 令牌内容
    private long expiresAt;         // 过期时间戳
    private String tokenType;       // 类型（Bearer）
    
    // 检查是否过期
    public boolean isExpired() {
        return System.currentTimeMillis() > expiresAt;
    }
    
    // 检查是否即将过期（提前5分钟）
    public boolean isExpiringSoon() {
        long fiveMinutes = 5 * 60 * 1000;
        return System.currentTimeMillis() > (expiresAt - fiveMinutes);
    }
}

// 刷新令牌信息
public class RefreshToken {
    private String token;           // 令牌内容
    private long expiresAt;         // 过期时间戳
    private String userId;          // 关联用户
    private boolean revoked;        // 是否已撤销
    
    public boolean isValid() {
        return !revoked && !isExpired();
    }
    
    public boolean isExpired() {
        return System.currentTimeMillis() > expiresAt;
    }
}
```

---

## 5. 🔄 刷新令牌的续签策略


### 5.1 主动刷新策略


**策略一：提前刷新**
```
原理：在访问令牌过期前主动刷新

时间轴：
0min────────────110min────────────120min
[─────访问令牌有效期─────]
                  ↑              ↑
                提前刷新      真正过期
                (还剩10分钟)
```

**实现代码**：
```java
public class TokenManager {
    
    // 检查并刷新令牌
    public void checkAndRefreshToken() {
        AccessToken token = getAccessToken();
        
        // 提前5分钟刷新
        if (token.isExpiringSoon()) {
            RefreshToken refreshToken = getRefreshToken();
            
            // 调用刷新接口
            TokenResponse response = authClient.refreshToken(
                refreshToken.getToken()
            );
            
            // 更新令牌
            saveAccessToken(response.getAccessToken());
            saveRefreshToken(response.getRefreshToken());
        }
    }
}
```

**优点**：
- ✅ 避免令牌过期导致请求失败
- ✅ 用户体验更流畅
- ✅ 减少错误重试

**适用场景**：
- 📱 移动APP（后台定时检查）
- 🌐 单页应用（定时器触发）

---

### 5.2 被动刷新策略


**策略二：过期后刷新**
```
原理：等到访问令牌真正过期后才刷新

流程：
请求资源 → 401错误 → 刷新令牌 → 重试请求
```

**实现代码**：
```java
public class ApiClient {
    
    // 带自动刷新的请求方法
    public Response request(String url) {
        try {
            // 尝试请求
            return doRequest(url, getAccessToken());
            
        } catch (TokenExpiredException e) {
            // 访问令牌过期，刷新令牌
            refreshAccessToken();
            
            // 用新令牌重试
            return doRequest(url, getAccessToken());
        }
    }
    
    private void refreshAccessToken() {
        RefreshToken refresh = getRefreshToken();
        TokenResponse response = authClient.refreshToken(refresh);
        saveAccessToken(response.getAccessToken());
    }
}
```

**优点**：
- ✅ 实现简单
- ✅ 按需刷新，减少请求

**缺点**：
- ❌ 用户可能感知到延迟
- ❌ 需要处理重试逻辑

---

### 5.3 滚动刷新策略


**策略三：刷新令牌也更新**
```
原理：每次刷新访问令牌时，同时获得新的刷新令牌

旧方式（固定刷新令牌）：
Refresh Token A: [──────────30天────────────]
Access Token 1:  [2h]
Access Token 2:       [2h]
Access Token 3:            [2h]

新方式（滚动刷新令牌）：
Refresh Token A: [──7天──]
Access Token 1:  [2h]     ↓生成新的刷新令牌
Refresh Token B:     [──7天──]
Access Token 2:       [2h]     ↓生成新的刷新令牌
Refresh Token C:          [──7天──]
```

**实现代码**：
```java
// 认证服务器端实现
public TokenResponse refreshToken(String refreshToken) {
    // 1. 验证刷新令牌
    RefreshToken oldRefresh = validateRefreshToken(refreshToken);
    
    // 2. 生成新的访问令牌
    AccessToken newAccess = generateAccessToken(oldRefresh.getUserId());
    
    // 3. 生成新的刷新令牌（关键步骤）
    RefreshToken newRefresh = generateRefreshToken(oldRefresh.getUserId());
    
    // 4. 撤销旧的刷新令牌
    revokeRefreshToken(oldRefresh);
    
    // 5. 返回新令牌
    return new TokenResponse(newAccess, newRefresh);
}
```

**优点**：
- ✅ 更高的安全性（旧令牌立即失效）
- ✅ 可以实现"活动用户永不过期"
- ✅ 检测到异常可立即切断

**缺点**：
- ❌ 实现复杂度高
- ❌ 需要管理令牌版本

> 🔒 **安全最佳实践**  
> **推荐使用滚动刷新策略**，每次刷新都更新刷新令牌，最大程度降低令牌泄露风险

---

### 5.4 策略选择建议


| 场景 | **推荐策略** | **理由** |
|-----|------------|---------|
| 🏦 高安全应用 | 滚动刷新 | 最大化安全性 |
| 📱 移动应用 | 主动刷新 | 提升用户体验 |
| 🌐 Web应用 | 被动刷新 | 实现简单 |
| 💼 企业内部 | 主动刷新 | 减少登录次数 |

---

## 6. 🔒 安全考虑与最佳实践


### 6.1 刷新令牌的安全风险


**主要风险**：

| 风险类型 | **具体威胁** | **影响** |
|---------|------------|---------|
| 🎣 **令牌泄露** | 刷新令牌被窃取 | 攻击者可持续获取新令牌 |
| 🔄 **重放攻击** | 旧令牌被重复使用 | 绕过安全机制 |
| 📱 **设备丢失** | 手机丢失导致令牌暴露 | 长期访问权限泄露 |
| 🌐 **中间人攻击** | 传输过程被拦截 | 令牌被窃听 |

**风险场景示例**：
```
❌ 不安全的场景：
刷新令牌存储在：
- 浏览器localStorage（容易被XSS攻击读取）
- 明文存储在移动端（容易被反编译获取）
- 通过HTTP传输（容易被中间人拦截）

✅ 安全的场景：
刷新令牌存储在：
- HttpOnly Cookie（浏览器环境）
- 加密的安全存储（移动端Keychain/Keystore）
- 仅通过HTTPS传输
```

---

### 6.2 安全存储实践


**不同环境的存储方案**：

| 环境 | **推荐方案** | **具体做法** |
|-----|------------|------------|
| 🌐 **Web浏览器** | HttpOnly Cookie | 无法被JS读取 |
| 📱 **iOS应用** | Keychain | 系统级加密存储 |
| 🤖 **Android应用** | Keystore | 硬件加密支持 |
| 💻 **桌面应用** | 系统密钥环 | 操作系统提供的安全存储 |

**代码示例**：

```java
// Web端：使用HttpOnly Cookie
@PostMapping("/oauth/token")
public ResponseEntity<?> login(@RequestBody LoginRequest req) {
    // 生成令牌
    TokenResponse tokens = authService.login(req);
    
    // 访问令牌放在响应体（前端存内存）
    // 刷新令牌放在HttpOnly Cookie（JS无法访问）
    ResponseCookie cookie = ResponseCookie
        .from("refresh_token", tokens.getRefreshToken())
        .httpOnly(true)        // 防止XSS
        .secure(true)          // 仅HTTPS传输
        .sameSite("Strict")    // 防止CSRF
        .maxAge(30 * 24 * 3600)// 30天
        .path("/oauth/token")  // 仅刷新接口可访问
        .build();
    
    return ResponseEntity.ok()
        .header(HttpHeaders.SET_COOKIE, cookie.toString())
        .body(tokens.getAccessToken());
}

// 移动端：使用安全存储
// Android示例
public class SecureTokenStorage {
    
    public void saveRefreshToken(String token) {
        // 使用Android Keystore加密存储
        EncryptedSharedPreferences prefs = 
            EncryptedSharedPreferences.create(
                "secure_tokens",
                MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC),
                context,
                EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            );
        
        prefs.edit()
            .putString("refresh_token", token)
            .apply();
    }
}
```

---

### 6.3 传输安全实践


**必须遵守的规则**：

> ⚠️ **绝对禁止**  
> ❌ 通过HTTP传输刷新令牌  
> ❌ 在URL参数中传递刷新令牌  
> ❌ 在日志中记录完整刷新令牌

**正确的传输方式**：
```http
✅ 使用HTTPS + POST请求体
POST /oauth/token HTTPS/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&
refresh_token=...

✅ 或使用HttpOnly Cookie（自动携带）
POST /oauth/token HTTPS/1.1
Host: auth.example.com
Cookie: refresh_token=...
```

---

### 6.4 令牌撤销机制


**何时需要撤销令牌**：
- 🚪 用户主动登出
- 📱 设备丢失报告
- 🔍 检测到异常活动
- ⏰ 长期未使用

**撤销实现**：
```java
public class TokenRevocationService {
    
    // 令牌黑名单（使用Redis）
    @Autowired
    private RedisTemplate<String, String> redis;
    
    // 撤销刷新令牌
    public void revokeRefreshToken(String token) {
        // 1. 标记为已撤销
        redis.opsForValue().set(
            "revoked:refresh:" + token,
            "true",
            30, TimeUnit.DAYS  // 过期时间与刷新令牌一致
        );
        
        // 2. 同时撤销该用户的所有令牌（可选）
        String userId = parseToken(token).getUserId();
        revokeAllUserTokens(userId);
    }
    
    // 验证刷新令牌时检查是否被撤销
    public boolean isRevoked(String token) {
        return redis.hasKey("revoked:refresh:" + token);
    }
    
    // 用户登出时调用
    @PostMapping("/logout")
    public void logout(@RequestHeader("Authorization") String auth) {
        String refreshToken = getRefreshTokenFromCookie();
        revokeRefreshToken(refreshToken);
    }
}
```

---

### 6.5 异常检测与防护


**检测异常行为**：

```java
public class TokenSecurityMonitor {
    
    // 检测异常刷新行为
    public void checkRefreshPattern(String userId, String ip) {
        // 1. 检测刷新频率（正常不应该频繁刷新）
        int refreshCount = getRefreshCountInLastHour(userId);
        if (refreshCount > 10) {
            alertSecurity("频繁刷新令牌", userId);
            blockUser(userId);
        }
        
        // 2. 检测IP变化（可能是令牌被盗用）
        String lastIp = getLastRefreshIp(userId);
        if (!ip.equals(lastIp) && !isInSameRegion(ip, lastIp)) {
            alertSecurity("异常IP刷新", userId);
            requireReAuthentication(userId);
        }
        
        // 3. 检测设备变化
        String device = getDeviceFingerprint();
        String lastDevice = getLastRefreshDevice(userId);
        if (!device.equals(lastDevice)) {
            alertSecurity("新设备刷新", userId);
            sendSecurityNotification(userId);
        }
    }
}
```

> 🔥 **安全最佳实践总结**  
> 1. 刷新令牌必须安全存储（HttpOnly Cookie / 系统密钥环）
> 2. 只通过HTTPS传输刷新令牌
> 3. 实现令牌撤销机制
> 4. 监控异常刷新行为
> 5. 使用滚动刷新策略（每次刷新都更新刷新令牌）

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔑 刷新令牌本质：
- 专门用来获取新访问令牌的特殊令牌
- 解决访问令牌过期后的续签问题
- 提升用户体验（无需重新登录）

🆚 两种令牌对比：
访问令牌：短命、频繁使用、发给资源服务器
刷新令牌：长命、稀少使用、只发给认证服务器

🔄 工作流程：
登录 → 获得双令牌 → 用访问令牌访问资源 → 
过期 → 用刷新令牌换新令牌 → 继续访问

⏰ 生命周期：
访问令牌：几分钟到几小时
刷新令牌：几天到几个月
```

### 7.2 三种续签策略


| 策略 | **特点** | **适用场景** |
|-----|---------|------------|
| 🔄 **主动刷新** | 提前刷新，避免过期 | 移动APP、单页应用 |
| ⏰ **被动刷新** | 过期后再刷新 | Web应用、简单场景 |
| 🎯 **滚动刷新** | 刷新令牌也更新 | 高安全应用 |

### 7.3 安全要点记忆


```
✅ 存储安全：
- Web端：HttpOnly Cookie
- 移动端：系统密钥环
- 禁止：localStorage、明文存储

✅ 传输安全：
- 必须：仅HTTPS传输
- 禁止：HTTP、URL参数、日志记录

✅ 使用安全：
- 实现：令牌撤销机制
- 监控：异常刷新行为
- 策略：滚动刷新最安全
```

### 7.4 实际应用建议


**根据应用类型选择策略**：

```
🏦 金融应用：
- 访问令牌：15-30分钟
- 刷新令牌：1-7天
- 策略：滚动刷新 + 异常监控

🛒 电商应用：
- 访问令牌：1-2小时
- 刷新令牌：30-90天  
- 策略：主动刷新 + 适度安全

📱 社交应用：
- 访问令牌：2-6小时
- 刷新令牌：永久/1年
- 策略：主动刷新 + 基础安全
```

> 💡 **核心记忆口诀**  
> 访问令牌短又快，刷新令牌长且稳  
> 主动提前防过期，被动简单等失效  
> 滚动更新最安全，令牌管理要规范  
> 存储传输都加密，异常监控不能少