---
title: 3、密码模式详解
---
## 📚 目录

1. [密码模式基本概念](#1-密码模式基本概念)
2. [密码模式工作原理](#2-密码模式工作原理)
3. [适用场景与限制](#3-适用场景与限制)
4. [安全风险分析](#4-安全风险分析)
5. [代码实现示例](#5-代码实现示例)
6. [从密码模式迁移](#6-从密码模式迁移)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 密码模式基本概念


### 1.1 什么是密码模式


**通俗理解**：密码模式就是用户把自己的账号密码直接交给应用程序，让应用程序代替自己去获取访问权限。

```
类比现实场景：
你想让朋友帮你取快递，你直接把身份证给朋友
朋友拿着你的身份证去快递站取件

密码模式就是这样：
用户把账号密码直接给客户端应用
客户端拿着账号密码去授权服务器换Token
```

**正式名称**：Resource Owner Password Credentials Grant（资源所有者密码凭证授权）

**核心特点**：
- ✅ **直接传递**：用户名和密码直接给客户端
- ✅ **无需跳转**：不需要浏览器重定向
- ⚠️ **高度信任**：客户端能看到用户密码
- ⚠️ **已废弃**：OAuth2.1正式移除此模式

### 1.2 为什么叫"密码模式"


**命名由来**：
```
Authorization Code 授权码模式 → 用"授权码"换Token
Implicit 隐式模式 → "隐式"直接返回Token
Client Credentials 客户端模式 → 用"客户端凭证"换Token
Password 密码模式 → 用"用户密码"换Token ⬅️ 就是这么直白
```

**与其他模式的本质区别**：
- 其他模式：用户只授权，不泄露密码
- 密码模式：用户把密码交给客户端 ❗

---

## 2. ⚙️ 密码模式工作原理


### 2.1 交互流程图


```
用户                客户端应用              授权服务器
 |                     |                       |
 |--①输入账号密码------>|                       |
 |  username: john     |                       |
 |  password: 123456   |                       |
 |                     |                       |
 |                     |--②发送密码请求-------->|
 |                     |  grant_type=password  |
 |                     |  username=john        |
 |                     |  password=123456      |
 |                     |  client_id=app123     |
 |                     |                       |
 |                     |                       |--③验证
 |                     |                       |  用户密码
 |                     |                       |  客户端身份
 |                     |                       |
 |                     |<--④返回Token----------|
 |                     |  access_token: xyz    |
 |                     |  refresh_token: abc   |
 |                     |                       |
 |<--⑤登录成功---------|                       |
 |  (Token已保存)      |                       |
```

### 2.2 详细步骤解析


**步骤①：用户在客户端输入凭证**
```
用户操作：在App的登录界面输入
- 用户名：john@example.com
- 密码：MySecretPass123

关键点：
• 用户直接在客户端应用输入密码
• 密码会被客户端程序获取
• 这要求用户完全信任这个应用
```

**步骤②：客户端向授权服务器请求Token**
```http
POST /oauth/token HTTP/1.1
Host: auth.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=password                    ← 指定密码模式
username=john@example.com              ← 用户名
password=MySecretPass123               ← 用户密码（明文传输需HTTPS）
client_id=mobile_app_001               ← 客户端ID
client_secret=app_secret_key           ← 客户端密钥（可选）
scope=read write                       ← 申请的权限范围
```

**关键参数说明**：
- `grant_type=password`：告诉服务器使用密码模式
- `username` & `password`：用户的登录凭证
- `client_id` & `client_secret`：客户端的身份凭证
- `scope`：申请的访问权限范围

**步骤③：授权服务器验证**
```
验证过程（服务器端）：
┌─────────────────────────────┐
│ ① 验证客户端身份             │
│   client_id + client_secret │
│   是否是合法的客户端？       │
├─────────────────────────────┤
│ ② 验证用户凭证               │
│   username + password        │
│   账号密码是否正确？         │
├─────────────────────────────┤
│ ③ 检查权限范围               │
│   scope是否被允许？          │
│   用户是否有这些权限？       │
└─────────────────────────────┘
        ↓ 全部通过
    生成Access Token
```

**步骤④：返回访问令牌**
```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "eyJhbGc...xyz",      // 访问令牌
  "token_type": "Bearer",               // Token类型
  "expires_in": 3600,                   // 有效期（秒）
  "refresh_token": "refresh_abc123",    // 刷新令牌
  "scope": "read write"                 // 实际授予的权限
}
```

**步骤⑤：客户端使用Token访问资源**
```
客户端后续请求：
┌──────────────────────────────┐
│ GET /api/user/profile        │
│ Authorization: Bearer xyz... │ ← 携带Access Token
└──────────────────────────────┘
         ↓
   资源服务器验证Token
         ↓
     返回用户数据
```

### 2.3 与授权码模式的对比


| 对比维度 | **密码模式** | **授权码模式** |
|---------|------------|--------------|
| **用户体验** | `直接登录，无跳转` | `需要跳转到授权页面` |
| **密码暴露** | `客户端能看到密码` ⚠️ | `客户端看不到密码` ✅ |
| **适用场景** | `自家App，高度可信` | `第三方应用集成` |
| **安全性** | `较低，密码泄露风险` | `高，符合OAuth精神` |
| **流程复杂度** | `简单，1次请求` | `复杂，需2次请求` |
| **推荐程度** | `已废弃，不推荐` ❌ | `标准推荐方式` ✅ |

---

## 3. 🎯 适用场景与限制


### 3.1 什么情况下可以考虑密码模式


> ⚠️ **前置说明**：密码模式已在OAuth2.1中正式移除，仅在特殊遗留场景下使用

**场景①：自家的官方客户端**
```
典型案例：
┌─────────────────────────────────┐
│ 微信官方App登录微信账号          │
│ 支付宝App登录支付宝账号          │
│ 企业内部App登录公司账号          │
└─────────────────────────────────┘

为什么可以用：
• 客户端是自己开发的，完全可信
• 用户认可这是"官方应用"
• 不涉及第三方集成
```

**场景②：遗留系统迁移（Legacy System）**
```
实际情况：
老系统：用户名+密码直接验证
新架构：需要迁移到OAuth2.0

过渡方案：
① 先用密码模式快速迁移
② 用户体验不变（仍然输入密码）
③ 逐步引导用户迁移到新的授权方式

⏰ 这只是临时方案，最终要废弃
```

**场景③：高度受信的环境**
```
企业内网场景：
┌──────────────────────────┐
│ 公司内部管理系统         │
│ 用户都是公司员工         │
│ 网络环境完全可控         │
│ 客户端经过安全审计       │
└──────────────────────────┘

但即使这样，也建议使用更安全的方式
```

### 3.2 密码模式的严格限制条件


**使用密码模式必须同时满足**：

① **可信客户端** `Trust Level: Highest`
```
✅ 第一方应用（自己公司开发）
✅ 通过安全审计的客户端
✅ 用户明确知道是"官方"应用

❌ 第三方开发的应用
❌ 未经审计的程序
❌ 不确定来源的客户端
```

② **无更好替代方案**
```
优先级排序：
1. 授权码模式 + PKCE（移动端/单页应用）
2. 客户端模式（服务间调用）
3. 设备码模式（智能设备）
4. 密码模式（万不得已） ← 最后考虑
```

③ **临时过渡使用**
```
明确的迁移计划：
┌─────────────────────────────┐
│ Phase 1: 使用密码模式        │
│ Phase 2: 通知用户即将变更    │
│ Phase 3: 上线新的授权方式    │
│ Phase 4: 废弃密码模式        │
└─────────────────────────────┘
      ↓ 时间跨度：6-12个月
```

### 3.3 明确禁止使用的场景


**❌ 绝对不能用密码模式的情况**：

```
场景类型                              风险说明
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 第三方应用集成                    第三方会获取用户密码
🚫 公共/不受信的客户端                密码可能被恶意获取
🚫 Web浏览器中的JavaScript应用        密码暴露在浏览器环境
🚫 移动App（2024年后）                有更安全的PKCE方案
🚫 跨域资源访问                       不符合OAuth2设计理念
🚫 社交登录场景                       用户不应给第三方密码
```

---

## 4. ⚠️ 安全风险分析


### 4.1 核心安全问题


**风险①：密码暴露给客户端**
```
问题本质：
用户密码 → 客户端程序 → 授权服务器
           ↑ 
      密码在这里暴露了！

可能的后果：
• 客户端被破解，密码泄露
• 恶意员工窃取密码
• 日志记录了密码信息
• 内存dump暴露密码
```

**风险②：违背OAuth2设计原则**
```
OAuth2的核心理念：
"客户端永远不应该知道用户密码"

密码模式破坏了这个原则：
┌─────────────────────────────┐
│ 用户不是在授权服务器登录     │
│ 而是在客户端应用中输入密码   │
│ 这失去了OAuth2的安全优势     │
└─────────────────────────────┘
```

**风险③：钓鱼攻击风险**
```
攻击场景：
假冒App：看起来像官方，实际是钓鱼
用户输入密码 → 直接发送给攻击者

授权码模式的防护：
用户在官方授权页输入密码
第三方App看不到密码
钓鱼攻击难度大大增加
```

### 4.2 安全风险等级评估


| 风险类型 | **严重程度** | **影响范围** | **缓解措施** |
|---------|------------|------------|------------|
| **密码泄露** | `🔴 严重` | `所有使用该密码的系统` | `强制HTTPS + 密码不落地` |
| **凭证存储** | `🟠 高` | `客户端设备被攻破` | `不存储密码，只存Token` |
| **中间人攻击** | `🟠 高` | `网络传输被拦截` | `TLS 1.2+，证书锁定` |
| **客户端篡改** | `🟡 中` | `恶意修改的客户端` | `代码混淆，完整性校验` |
| **重放攻击** | `🟡 中` | `Token被截获重放` | `Token短期有效，刷新机制` |

### 4.3 必须的安全措施


**措施①：强制HTTPS加密传输**
```
要求：
✅ TLS 1.2 或更高版本
✅ 强密码套件（禁用弱加密算法）
✅ 有效的SSL证书
✅ 证书固定（Certificate Pinning）- 移动端

配置示例（Nginx）：
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers HIGH:!aNULL:!MD5;
```

**措施②：密码处理规范**
```
客户端规范：
① 密码仅用于交换Token
② 交换后立即清除内存中的密码
③ 绝不记录密码到日志
④ 绝不存储密码到本地

代码要求：
// ❌ 错误做法
String password = getPassword();
log.info("User password: " + password);  // 密码记录到日志

// ✅ 正确做法
char[] password = getPasswordChars();
// 使用后立即清除
Arrays.fill(password, ' ');
```

**措施③：Token安全管理**
```
Token存储：
移动端：使用系统Keychain/Keystore
Web端：HttpOnly Cookie，或内存存储
后端：Redis等安全缓存，设置过期时间

Token使用：
┌─────────────────────────────┐
│ Access Token：短期有效       │
│ - 有效期：15-60分钟          │
│ - 泄露影响时间有限           │
├─────────────────────────────┤
│ Refresh Token：长期有效      │
│ - 安全存储，加密保护         │
│ - 使用时需额外验证           │
│ - 支持撤销（Revoke）         │
└─────────────────────────────┘
```

**措施④：审计与监控**
```
必须记录的事件：
• 密码模式授权请求（含客户端ID、IP）
• Token颁发记录
• 异常登录（异地、异常时间）
• 密码错误次数

告警规则：
┌──────────────────────────────┐
│ 短时间内大量密码错误          │ → 可能的暴力破解
│ 同一账号多地登录              │ → 可能的账号泄露
│ 深夜异常登录                  │ → 可疑活动
└──────────────────────────────┘
```

---

## 5. 💻 代码实现示例


### 5.1 客户端实现（Java - Spring）


```java
@Service
public class PasswordGrantAuthService {
    
    @Value("${oauth2.token-url}")
    private String tokenUrl;  // https://auth.example.com/oauth/token
    
    @Value("${oauth2.client-id}")
    private String clientId;
    
    @Value("${oauth2.client-secret}")
    private String clientSecret;
    
    private final RestTemplate restTemplate;
    
    /**
     * 使用密码模式获取Token
     * @param username 用户名
     * @param password 用户密码（char[]更安全）
     * @return Token响应
     */
    public TokenResponse login(String username, char[] password) {
        try {
            // 1. 构造请求参数
            MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
            params.add("grant_type", "password");
            params.add("username", username);
            params.add("password", new String(password));  // 仅在此处转换
            params.add("client_id", clientId);
            params.add("client_secret", clientSecret);
            params.add("scope", "read write");
            
            // 2. 设置请求头
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
            
            HttpEntity<MultiValueMap<String, String>> request = 
                new HttpEntity<>(params, headers);
            
            // 3. 发送请求
            ResponseEntity<TokenResponse> response = restTemplate.postForEntity(
                tokenUrl, request, TokenResponse.class
            );
            
            return response.getBody();
            
        } finally {
            // 4. 立即清除密码 ⚠️ 重要
            Arrays.fill(password, ' ');
        }
    }
}

// Token响应对象
@Data
public class TokenResponse {
    @JsonProperty("access_token")
    private String accessToken;
    
    @JsonProperty("token_type")
    private String tokenType;  // "Bearer"
    
    @JsonProperty("expires_in")
    private Long expiresIn;    // 3600秒
    
    @JsonProperty("refresh_token")
    private String refreshToken;
    
    private String scope;
}
```

### 5.2 服务端实现（Spring Authorization Server）


```java
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Bean
    public AuthorizationServerConfigurer authorizationServerConfigurer() {
        return new AuthorizationServerConfigurerAdapter() {
            
            @Override
            public void configure(ClientDetailsServiceConfigurer clients) 
                throws Exception {
                clients.inMemory()
                    .withClient("mobile_app_001")
                    .secret("{noop}app_secret_key")
                    .authorizedGrantTypes(
                        "password",        // 启用密码模式
                        "refresh_token"    // 启用刷新令牌
                    )
                    .scopes("read", "write")
                    .accessTokenValiditySeconds(3600)      // 1小时
                    .refreshTokenValiditySeconds(604800);  // 7天
            }
            
            @Override
            public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
                endpoints
                    .authenticationManager(authenticationManager)  // 密码验证
                    .userDetailsService(userDetailsService);       // 用户加载
            }
        };
    }
}

// 用户验证服务
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) 
        throws UsernameNotFoundException {
        
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> 
                new UsernameNotFoundException("用户不存在: " + username)
            );
        
        // 返回Spring Security的UserDetails
        return org.springframework.security.core.userdetails.User
            .withUsername(user.getUsername())
            .password(user.getPassword())  // 已加密的密码
            .authorities(user.getRoles())
            .accountExpired(false)
            .accountLocked(false)
            .credentialsExpired(false)
            .disabled(false)
            .build();
    }
}
```

### 5.3 移动端实现示例（Android/Kotlin）


```kotlin
class AuthRepository(private val api: AuthApi) {
    
    suspend fun login(username: String, password: String): Result<TokenResponse> {
        return withContext(Dispatchers.IO) {
            try {
                val response = api.getToken(
                    grantType = "password",
                    username = username,
                    password = password,
                    clientId = BuildConfig.CLIENT_ID,
                    clientSecret = BuildConfig.CLIENT_SECRET,
                    scope = "read write"
                )
                
                // 安全存储Token
                secureStorage.saveAccessToken(response.accessToken)
                secureStorage.saveRefreshToken(response.refreshToken)
                
                Result.success(response)
                
            } catch (e: Exception) {
                Result.failure(e)
            } finally {
                // 清除内存中的密码（Kotlin的String是不可变的，但仍建议）
                password.toCharArray().fill(' ')
            }
        }
    }
}

// 安全存储（使用Android Keystore）
class SecureStorage(private val context: Context) {
    
    private val sharedPreferences = EncryptedSharedPreferences.create(
        "auth_prefs",
        MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build(),
        context,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveAccessToken(token: String) {
        sharedPreferences.edit()
            .putString("access_token", token)
            .apply()
    }
}
```

---

## 6. 🔄 从密码模式迁移


### 6.1 迁移策略与时间表


**迁移路线图**：
```
阶段划分                时间跨度        主要任务
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 Phase 1: 评估        1-2周          • 统计密码模式使用情况
  现状调研                            • 分析技术可行性
                                      • 制定迁移方案

🔧 Phase 2: 准备        2-4周          • 实现新的授权方式
  技术实施                            • 灰度测试新方案
                                      • 准备回滚机制

📢 Phase 3: 通知        4-8周          • 发布迁移公告
  用户沟通                            • 应用内提示
                                      • 邮件/短信通知

🚀 Phase 4: 上线        2-4周          • 逐步切换用户
  灰度发布                            • 监控问题
                                      • 快速响应

🗑️ Phase 5: 下线        2-4周          • 关闭密码模式
  完全迁移                            • 清理相关代码
                                      • 更新文档
```

### 6.2 推荐的替代方案


**方案①：授权码模式 + PKCE（移动端/单页应用）**
```
优势：
✅ 完全符合OAuth2标准
✅ 密码不经过客户端
✅ 支持社交登录集成

迁移步骤：
① 客户端实现PKCE流程
② 用户首次登录时引导使用新方式
③ 设置过渡期（如3个月）
④ 过渡期后强制使用新方式
```

**方案②：令牌交换（Token Exchange）**
```
适用场景：
• 已有其他类型的凭证（如SSO Token）
• 需要跨系统的身份传递

实现思路：
用户的现有凭证 → 交换为OAuth2 Token
无需再次输入密码
```

**方案③：设备码模式（受限输入设备）**
```
典型案例：
• 智能电视
• 游戏机
• IoT设备

用户体验：
设备显示验证码 → 用户在手机/电脑输入
                → 设备获得授权
```

### 6.3 迁移注意事项


**兼容性处理**：
```
迁移期间的策略：
┌──────────────────────────────────┐
│ 新用户：强制使用新的授权方式      │
│ 老用户：                          │
│   - 前3个月：允许使用密码模式     │
│   - 提示：建议升级到新方式        │
│   - 3个月后：强制切换             │
└──────────────────────────────────┘
```

**数据迁移**：
```java
// 用户Token迁移
public void migrateUserTokens() {
    List<User> usersWithPasswordGrant = 
        userRepository.findByGrantType("password");
    
    for (User user : usersWithPasswordGrant) {
        // 1. 撤销旧的密码模式Token
        tokenService.revokeTokensByUser(user.getId());
        
        // 2. 标记用户需要重新授权
        user.setRequireReauth(true);
        
        // 3. 发送通知
        notificationService.send(user, 
            "您的登录方式已升级，请使用新的授权流程");
    }
}
```

**监控指标**：
```
关键监控点：
• 密码模式请求量（应逐步下降）
• 新授权方式请求量（应逐步上升）
• 用户投诉量
• 登录成功率
• 迁移完成百分比

告警阈值：
🔔 密码模式使用量超过预期10% → 分析原因
🔔 新方式登录失败率>5% → 紧急修复
🔔 用户投诉量突增 → 暂停迁移
```

---

## 7. 📋 核心要点总结


### 7.1 密码模式核心要点


```
🔸 本质理解：用户密码直接交给客户端，客户端代为换取Token
🔸 关键特征：无需浏览器跳转，流程简单，但密码暴露给客户端
🔸 适用场景：仅限自家官方客户端 + 遗留系统过渡
🔸 安全要求：强制HTTPS、密码不落地、Token短期有效
🔸 现状定位：OAuth2.1已正式废弃，不推荐新项目使用
```

### 7.2 关键理解要点


**① 为什么密码模式被废弃**
```
核心原因：
• 违背OAuth2"客户端不知道密码"的设计理念
• 密码泄露风险高，影响范围广
• 有更安全的替代方案（授权码+PKCE）
• 难以实现真正的单点登录

演进趋势：
OAuth 2.0 → 允许密码模式
OAuth 2.1 → 正式移除密码模式 ← 当前标准
```

**② 可信客户端的真正含义**
```
"可信"的判断标准：
✅ 自己公司开发维护
✅ 通过完整的安全审计
✅ 用户明确知道是官方应用
✅ 有完善的安全监控

不是"可信"：
❌ 外包团队开发的App
❌ 第三方开发者的应用
❌ 开源的客户端程序
❌ 未经审计的代码
```

**③ 遗留系统迁移的正确姿势**
```
迁移三原则：
① 明确的时间计划（6-12个月）
② 充分的用户沟通（提前通知）
③ 平滑的过渡方案（灰度发布）

错误做法：
❌ 长期依赖密码模式
❌ 没有迁移计划
❌ 突然下线密码模式
```

### 7.3 实战建议


**新项目开发**：
```
推荐方案优先级：

移动App/单页应用：
1️⃣ 授权码模式 + PKCE（首选）
2️⃣ 设备码模式（受限输入设备）
3️⃣ ❌ 不使用密码模式

后端服务调用：
1️⃣ 客户端模式（服务间调用）
2️⃣ JWT + 服务账号
3️⃣ ❌ 不使用密码模式
```

**遗留系统维护**：
```
短期策略（<6个月）：
• 加强密码模式的安全措施
• 监控异常行为
• 准备迁移方案

长期策略（6-12个月）：
• 实施完整迁移计划
• 逐步切换用户到新方式
• 最终下线密码模式
```

**安全加固清单**：
```
必须做到：
☑ 全程HTTPS，TLS 1.2+
☑ 密码不记录日志
☑ 密码使用后立即清除内存
☑ Token短期有效（<1小时）
☑ 支持Token撤销
☑ 异常登录告警
☑ 审计日志完整

建议做到：
☑ 客户端证书固定
☑ Token加密存储
☑ 设备指纹验证
☑ 风控系统接入
```

### 7.4 面试要点


**常见面试题**：

**Q1: 密码模式和授权码模式有什么区别？**
```
关键区别：
• 密码模式：密码直接给客户端，客户端换Token
• 授权码模式：用户在授权服务器登录，客户端拿授权码换Token

核心差异：
• 密码模式：客户端知道密码 ⚠️
• 授权码模式：客户端不知道密码 ✅
```

**Q2: 为什么OAuth2.1要移除密码模式？**
```
三大原因：
① 违背OAuth2的核心安全理念
② 有更安全的替代方案（PKCE）
③ 密码泄露风险难以控制
```

**Q3: 什么情况下还能使用密码模式？**
```
仅限以下场景：
• 自家官方客户端（非第三方）
• 遗留系统临时过渡（<12个月）
• 有明确的迁移计划

强调：这只是临时方案，不是长期推荐
```

---

**🎯 核心记忆口诀**：
```
密码模式直传凭证，客户端可信是前提
OAuth精神已违背，安全风险需警惕
仅限自家官方用，遗留迁移要尽快
授权码加PKCE，才是推荐新姿势
```

**📚 延伸阅读**：
- RFC 6749 - OAuth 2.0（密码模式定义）
- OAuth 2.1草案 - 移除密码模式的说明
- PKCE规范 - RFC 7636
- OAuth 2.0安全最佳实践