---
title: 1、授权码模式详解
---
## 📚 目录

1. [授权码模式是什么](#1-授权码模式是什么)
2. [核心概念解析](#2-核心概念解析)
3. [完整流程步骤](#3-完整流程步骤)
4. [安全机制详解](#4-安全机制详解)
5. [PKCE增强防护](#5-PKCE增强防护)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 授权码模式是什么


### 1.1 生活化理解


> 🏠 **类比说明**
> 
> 想象你要让外卖小哥进你的小区取餐：
> 1. 你先给物业打电话（请求授权）
> 2. 物业给你一个临时通行码（授权码）
> 3. 你把通行码给外卖小哥（传递授权）
> 4. 外卖小哥拿通行码换正式门禁卡（用code换token）
> 
> **关键**：通行码只能用一次，且有时间限制

### 1.2 官方定义


**Authorization Code（授权码模式）**：OAuth2.0中**最安全、最完整**的授权方式

```
核心特点：
✅ 最安全：Token不经过浏览器，直接服务器间传递
✅ 最常用：适合所有Web应用场景
✅ 两步验证：先拿授权码，再换访问令牌
✅ 支持刷新：可以长期保持登录状态
```

### 1.3 为什么需要授权码


**问题场景**：
```
❌ 直接传Token的问题：
用户浏览器 → 重定向 → 你的网站
URL: https://yourapp.com/callback?token=敏感的访问令牌

风险：
• Token暴露在URL中，浏览器历史记录可见
• 可能被中间人拦截
• 用户可以看到Token内容
```

**授权码解决方案**：
```
✅ 使用临时授权码：
用户浏览器 → 重定向 → 你的网站  
URL: https://yourapp.com/callback?code=临时授权码

优势：
• Code只是临时凭证，不是真正的Token
• Code只能用一次，用完即废
• 真正的Token在服务器间安全传递
```

---

## 2. 📋 核心概念解析


### 2.1 授权码 (Authorization Code)


**是什么**：一个**临时的、一次性**的凭证

```
授权码特性：
┌─────────────────────────────┐
│ 特性         说明            │
├─────────────────────────────┤
│ 有效期      很短(10分钟内)    │
│ 使用次数    只能用一次        │
│ 传输方式    通过URL传递       │
│ 安全性      可以公开传输      │
│ 作用        换取真正的Token   │
└─────────────────────────────┘

示例：
code=SplxlOBeZQQYbYS6WxSbIA
↓ (用这个换)
access_token=真正的访问令牌
```

### 2.2 重定向URI (Redirect URI)


**是什么**：授权完成后，用户**回到你网站的地址**

> 🎯 **通俗理解**
> 
> 就像你在商场办会员卡：
> - 你去服务台办理（跳转到授权服务器）
> - 办完后回到你来的店铺（重定向回你的应用）
> - Redirect URI就是"你来的店铺地址"

```
重定向过程：
你的网站                    授权服务器
   |                           |
   |--[1]跳转去授权----------->|
   |   带上redirect_uri        |
   |                           |
   |<--[2]授权完成，重定向------|
   |   redirect_uri?code=xxx   |
   |                           |
```

**安全要求**：
```
🔴 必须预先注册：
在OAuth服务商后台配置允许的redirect_uri
例如：https://yourapp.com/callback

🔴 必须完全匹配：
请求时的URI必须和注册的一模一样
https://yourapp.com/callback ✅
https://yourapp.com/other     ❌

原因：防止授权码被重定向到恶意网站
```

### 2.3 Code换Token


**核心机制**：两步走，分离风险

```
第一步：获取授权码（经过浏览器）
用户浏览器 → 授权页面 → 同意 → 返回code

第二步：用code换token（服务器直连）
你的服务器 → 授权服务器 → 验证code → 返回token

流程对比：
         浏览器可见              服务器间通信
            ↓                        ↓
    [授权码 code]           [访问令牌 access_token]
      临时、公开                  长期、私密
```

---

## 3. 🔄 完整流程步骤


### 3.1 整体流程图


```
用户(浏览器)    你的应用服务器    授权服务器(如微信/GitHub)
    |                |                    |
    |--[1]点击登录--->|                    |
    |                |                    |
    |<--[2]重定向到授权页面----------------|
    |   (带上client_id、redirect_uri)     |
    |                                     |
    |--[3]用户登录并同意授权-------------->|
    |                                     |
    |<--[4]重定向回你的应用----------------|
    |   (带上code)                        |
    |                |                    |
    |--[5]提交code--->|                    |
    |                |                    |
    |                |--[6]用code+密钥---->|
    |                |   换取token        |
    |                |                    |
    |                |<--[7]返回token-----|
    |                |                    |
    |<--[8]登录成功-|                     |
```

### 3.2 详细步骤拆解


**步骤1：用户点击登录**
```
你的网站上有个"微信登录"按钮
用户点击 → 触发授权流程
```

**步骤2：重定向到授权页面**
```
构造授权URL：
https://oauth.example.com/authorize?
  response_type=code              ← 告诉服务器：我要授权码模式
  &client_id=你的应用ID           ← 你的应用身份
  &redirect_uri=https://yourapp.com/callback  ← 授权后回到哪
  &scope=read_user,read_email     ← 申请哪些权限
  &state=随机字符串               ← 防CSRF攻击的随机值

浏览器自动跳转到这个URL
```

**步骤3：用户登录并授权**
```
用户看到授权页面：
┌────────────────────────────┐
│  【某应用】想要获取：       │
│  ✓ 你的基本信息            │
│  ✓ 你的邮箱地址            │
│                            │
│  [同意] [拒绝]             │
└────────────────────────────┘

用户点击"同意"
```

**步骤4：返回授权码**
```
授权服务器重定向回你的应用：
https://yourapp.com/callback?
  code=SplxlOBeZQQYbYS6WxSbIA    ← 授权码
  &state=之前发送的随机值         ← 验证请求来源

你的应用收到code
```

**步骤5-7：服务器换取Token**
```java
// 你的应用服务器发起请求
POST https://oauth.example.com/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code     ← 授权类型
&code=刚才收到的授权码
&redirect_uri=https://yourapp.com/callback
&client_id=你的应用ID
&client_secret=你的应用密钥        ← 只有服务器知道

// 授权服务器验证后返回
{
  "access_token": "真正的访问令牌",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "刷新令牌",
  "scope": "read_user,read_email"
}
```

**步骤8：完成登录**
```
你的应用拿到token后：
1. 保存token（通常存在session或数据库）
2. 向用户返回登录成功
3. 后续用token调用API获取用户信息
```

### 3.3 关键参数说明


| 参数 | **阶段** | **说明** | **示例** |
|------|---------|---------|---------|
| `response_type` | 请求授权 | 固定为`code` | `code` |
| `client_id` | 请求授权 | 你的应用ID | `app_12345` |
| `redirect_uri` | 请求授权/换token | 回调地址 | `https://yourapp.com/callback` |
| `scope` | 请求授权 | 申请的权限范围 | `read_user,write_post` |
| `state` | 请求授权 | 防CSRF的随机值 | `xyz123abc` |
| `code` | 回调/换token | 授权码 | `SplxlOBeZ...` |
| `client_secret` | 换token | 应用密钥 | `secret_abc123` |
| `grant_type` | 换token | 固定为`authorization_code` | `authorization_code` |

---

## 4. 🔒 安全机制详解


### 4.1 为什么授权码模式最安全


```
安全层次对比：
┌────────────────────────────────────┐
│ 隐式模式（不安全）                  │
│ Token直接在URL中 → 浏览器可见      │
└────────────────────────────────────┘
              vs
┌────────────────────────────────────┐
│ 授权码模式（安全）                  │
│ Code在URL中 → Token在服务器间传递  │
└────────────────────────────────────┘
```

**三重防护**：
```
🔸 防护1：Token不经过浏览器
• 用户只看到code，看不到真正的token
• Token在服务器间直接传递
• 即使浏览器被劫持，也拿不到token

🔸 防护2：Client Secret验证
• 换token时必须提供应用密钥
• 密钥只有你的服务器知道
• 即使code泄露，没有密钥也换不到token

🔸 防护3：Code一次性使用
• 每个code只能用一次
• 用过即废，10分钟过期
• 防止重放攻击
```

### 4.2 State参数防CSRF


**什么是CSRF攻击**：
```
攻击场景：
1. 攻击者诱导你访问恶意链接
2. 链接中包含攻击者的授权码
3. 你的应用用这个code换token
4. 结果：你登录的是攻击者的账号

例子：
https://yourapp.com/callback?code=攻击者的授权码
```

**State参数防护**：
```
正确流程：
[1] 你的应用生成随机state：state=xyz123
[2] 发起授权时带上：...&state=xyz123
[3] 保存state到session
[4] 回调时验证：收到的state == 保存的state？
[5] 匹配才继续，不匹配则拒绝

防护效果：
攻击者的code带的是他的state
你的session里存的是你的state
两者不匹配 → 拒绝 → 攻击失败
```

```java
// 生成和验证state
String state = UUID.randomUUID().toString();
session.setAttribute("oauth_state", state);

// 授权时带上
String authUrl = "...&state=" + state;

// 回调时验证
String receivedState = request.getParameter("state");
String savedState = session.getAttribute("oauth_state");
if (!receivedState.equals(savedState)) {
    throw new SecurityException("State不匹配");
}
```

### 4.3 Redirect URI白名单


**安全问题**：
```
如果不验证redirect_uri：
攻击者可以把授权码重定向到自己的网站
https://evil.com/steal?code=你的授权码
```

**防护措施**：
```
1. 预先注册redirect_uri
   在OAuth服务商后台配置：
   ✅ https://yourapp.com/callback
   
2. 请求时必须完全匹配
   https://yourapp.com/callback       ✅
   https://yourapp.com/callback/other ❌
   https://evil.com/steal             ❌

3. 换token时再次验证
   确保redirect_uri前后一致
```

---

## 5. 🛡️ PKCE增强防护


### 5.1 什么是PKCE


**PKCE（Proof Key for Code Exchange）**：代码交换的证明密钥

> 🎯 **通俗理解**
> 
> 就像取快递的验证码：
> - 你先生成一个随机密码（code_verifier）
> - 把密码的哈希值告诉快递员（code_challenge）
> - 取件时报出原始密码（提交code_verifier）
> - 快递员验证哈希值是否匹配（验证通过才给）

### 5.2 为什么需要PKCE


**移动端风险**：
```
移动App的问题：
❌ 无法像Web应用一样保护client_secret
❌ App代码可以被反编译
❌ 密钥容易泄露

PKCE解决方案：
✅ 不依赖client_secret
✅ 每次授权动态生成验证密钥
✅ 即使被拦截也无法重用
```

### 5.3 PKCE工作流程


```
步骤1：生成验证器
App生成随机字符串 code_verifier
例如：dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

步骤2：计算挑战值
code_challenge = BASE64URL(SHA256(code_verifier))
例如：E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM

步骤3：请求授权时带上挑战值
https://oauth.example.com/authorize?
  ...
  &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
  &code_challenge_method=S256    ← 使用SHA256算法

步骤4：换token时提交原始验证器
POST /token
...
code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

步骤5：服务器验证
计算SHA256(code_verifier) == 之前的code_challenge?
匹配 → 通过 → 返回token
不匹配 → 拒绝
```

### 5.4 PKCE防护效果


```
攻击场景：
攻击者拦截了授权码 code=ABC123

没有PKCE：
攻击者可以用code直接换token ❌

有了PKCE：
攻击者没有code_verifier
无法通过验证
换不到token ✅

关键：
code_verifier只在App本地生成，从不传输
即使code被拦截，没有verifier也没用
```

---

## 6. 🎬 实际应用场景


### 6.1 Web应用登录


**典型场景**：网站使用微信/GitHub登录

```
应用场景：
你开发了一个博客网站
想让用户用GitHub账号登录

实现步骤：
1. 在GitHub注册OAuth应用
   获取client_id和client_secret
   
2. 网站添加"GitHub登录"按钮
   点击跳转到GitHub授权页

3. 用户在GitHub同意授权
   返回授权码code

4. 你的服务器用code换token
   拿到access_token

5. 用token调用GitHub API
   获取用户信息，完成登录
```

### 6.2 第三方应用授权


**典型场景**：授权第三方应用访问你的数据

```
应用场景：
你用印象笔记保存了很多文章
想用某个App自动整理这些笔记

授权流程：
用户 → 印象笔记授权页
     → 同意让该App读取笔记
     → 返回授权码
App  → 用code换token
     → 用token读取笔记数据
     → 自动整理

关键：
• 用户随时可以撤销授权
• Token有权限范围限制（scope）
• 不会泄露用户密码
```

### 6.3 移动App认证


**典型场景**：手机App使用OAuth登录

```
应用场景：
一个新闻App，支持微信登录

流程（使用PKCE）：
1. App生成code_verifier
2. 计算code_challenge
3. 唤起微信授权
4. 用户在微信同意
5. 返回code到App
6. App用code+verifier换token
7. 完成登录

安全增强：
• 使用PKCE，不需要client_secret
• App内部生成verifier，不传输
• 即使被抓包也无法重放
```

### 6.4 单点登录（SSO）


**典型场景**：企业内部多个系统共用一套登录

```
应用场景：
公司有多个内部系统：
• 考勤系统
• 报销系统  
• 工单系统

统一登录流程：
1. 用户访问任一系统
2. 跳转到统一认证中心
3. 登录后返回授权码
4. 系统用code换token
5. 后续访问其他系统：
   • 已有token，直接登录
   • 无需重复输入密码

优势：
• 一次登录，到处可用
• 统一管理用户权限
• 提升用户体验
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 授权码模式：OAuth2.0最安全的授权方式
🔸 Authorization Code：临时的、一次性的授权凭证
🔸 Redirect URI：授权后返回你应用的地址
🔸 Code换Token：两步走，分离风险
🔸 PKCE增强：移动端安全防护，无需client_secret
```

### 7.2 完整流程记忆


```
🎯 六步走流程：
1️⃣ 用户点击登录
2️⃣ 跳转到授权页面（带client_id、redirect_uri）
3️⃣ 用户同意授权
4️⃣ 返回授权码code
5️⃣ 服务器用code+密钥换token
6️⃣ 用token访问API，完成登录

记忆口诀：
跳转授权拿code，服务器换token稳
```

### 7.3 安全机制理解


```
三重防护：
🔒 Token不过浏览器：服务器间传递，用户看不到
🔒 密钥验证：换token需要client_secret
🔒 一次性使用：code用完即废，防重放

State防CSRF：
随机值 → 保存 → 验证 → 拒绝攻击

Redirect URI白名单：
预注册 → 完全匹配 → 防劫持

PKCE增强：
动态密钥 → 无需固定secret → 移动端安全
```

### 7.4 适用场景判断


| 场景类型 | **是否推荐** | **原因** |
|---------|-------------|---------|
| Web应用登录 | ✅ **强烈推荐** | 最安全，支持完整流程 |
| 移动App | ✅ **推荐（+PKCE）** | PKCE增强安全性 |
| 单页应用(SPA) | ⚠️ **谨慎使用** | 建议用PKCE代替隐式模式 |
| 服务器间调用 | ❌ **不推荐** | 用客户端凭证模式更合适 |
| 纯前端应用 | ❌ **不推荐** | 无法保护client_secret |

### 7.5 实践检查清单


**✅ 实现前检查**：
- [ ] 理解授权码和token的区别
- [ ] 知道为什么需要两步（code→token）
- [ ] 清楚redirect_uri的安全要求
- [ ] 了解state参数的作用
- [ ] 移动端必须使用PKCE

**✅ 安全检查**：
- [ ] redirect_uri已预注册白名单
- [ ] 每次请求都生成新的state
- [ ] 验证回调时的state值
- [ ] code只使用一次，用后立即销毁
- [ ] Token安全存储，不暴露给前端
- [ ] 使用HTTPS传输所有请求

**✅ 调试技巧**：
- [ ] 检查授权URL参数是否正确
- [ ] 验证redirect_uri是否完全匹配
- [ ] 确认code是否过期（10分钟内）
- [ ] 查看错误响应的error字段
- [ ] 使用Postman测试换token接口

### 7.6 常见错误排查


```
❌ 错误1：invalid_redirect_uri
原因：redirect_uri不在白名单或不完全匹配
解决：检查拼写、协议(https)、路径

❌ 错误2：invalid_grant
原因：code已过期或已使用
解决：重新发起授权流程

❌ 错误3：invalid_client
原因：client_id或client_secret错误
解决：检查应用凭证是否正确

❌ 错误4：State不匹配
原因：CSRF攻击或session丢失
解决：确保state的生成和验证逻辑正确
```

**🧠 核心记忆**：
- 授权码模式 = 最安全的OAuth2.0方式
- Code是桥梁，Token是钥匙
- 两步走防泄露，State防CSRF
- PKCE让移动端更安全
- Web应用首选，理解原理最重要