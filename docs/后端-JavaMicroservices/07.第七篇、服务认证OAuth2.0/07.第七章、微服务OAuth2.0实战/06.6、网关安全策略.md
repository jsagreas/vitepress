---
title: 6、网关安全策略
---
## 📚 目录

1. [网关安全概述](#1-网关安全概述)
2. [请求过滤机制](#2-请求过滤机制)
3. [响应处理策略](#3-响应处理策略)
4. [异常处理机制](#4-异常处理机制)
5. [限流熔断保护](#5-限流熔断保护)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🛡️ 网关安全概述


### 1.1 什么是网关安全


**通俗理解**：想象一下小区的门卫室
```
普通住户进出：        微服务请求：
     ↓                    ↓
 门卫检查证件        网关检查Token
     ↓                    ↓
 确认身份有效        验证权限通过
     ↓                    ↓
  允许进入           转发到服务
```

**网关的核心作用**：
- 🚪 **统一入口**：所有请求都要经过网关这道门
- 🔍 **身份验证**：检查你是谁（认证）
- ✅ **权限检查**：看你能做什么（授权）
- 🛡️ **安全防护**：阻挡恶意请求

### 1.2 为什么需要网关安全


**场景对比**：
```
❌ 没有网关的问题：
用户 → 直接访问订单服务  （绕过认证）
用户 → 直接访问支付服务  （越权操作）
黑客 → 疯狂请求商品服务  （拖垮系统）

✅ 有网关的保护：
用户 → 网关（验证Token）→ 订单服务  ✓
用户 → 网关（检查权限）→ 支付服务  ✓
黑客 → 网关（触发限流）→ 请求被拦截 ✓
```

### 1.3 网关安全架构图


```
                    外部请求
                       ↓
         ┌─────────────────────────┐
         │      API网关             │
         │  ┌──────────────────┐   │
         │  │  1.请求过滤器     │   │ ← 验证Token
         │  └──────────────────┘   │
         │  ┌──────────────────┐   │
         │  │  2.权限检查器     │   │ ← 检查权限
         │  └──────────────────┘   │
         │  ┌──────────────────┐   │
         │  │  3.限流熔断器     │   │ ← 流量控制
         │  └──────────────────┘   │
         │  ┌──────────────────┐   │
         │  │  4.异常处理器     │   │ ← 统一异常
         │  └──────────────────┘   │
         └─────────────────────────┘
                       ↓
              内部微服务集群
         ┌─────┬─────┬─────┬─────┐
         │订单 │商品 │用户 │支付 │
         └─────┴─────┴─────┴─────┘
```

---

## 2. 🔍 请求过滤机制


### 2.1 过滤器是什么


**生活类比**：机场安检流程
```
乘客登机前的检查：
1. 检查身份证    → Token验证
2. 检查行李      → 请求参数检查
3. 安全扫描      → 恶意请求拦截
4. 放行登机      → 转发到服务
```

**技术定义**：过滤器就是在请求到达真正的服务之前，做一系列检查和处理的组件

### 2.2 Token验证过滤器


**核心流程图**：
```
请求进来
   ↓
有Token吗？ ─否→ 返回401未授权
   ↓ 是
Token过期了吗？ ─是→ 返回401需要重新登录
   ↓ 否
Token格式正确吗？ ─否→ 返回400非法Token
   ↓ 是
从Token提取用户信息
   ↓
放行请求
```

**核心代码示例**：
```java
// Token验证过滤器 - 最精简版本
public class TokenFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 1. 获取Token
        String token = exchange.getRequest()
            .getHeaders()
            .getFirst("Authorization");
        
        // 2. Token为空？直接拦截
        if (token == null) {
            return unauthorized(exchange, "未登录");
        }
        
        // 3. 验证Token
        try {
            Claims claims = Jwts.parser()
                .setSigningKey("密钥")
                .parseClaimsJws(token)
                .getBody();
            
            // 4. Token有效，继续执行
            return chain.filter(exchange);
            
        } catch (ExpiredJwtException e) {
            return unauthorized(exchange, "Token已过期");
        }
    }
}
```

### 2.3 请求参数过滤


**常见安全检查**：

| 检查项目 | **检查内容** | **防护目的** | **示例** |
|---------|------------|------------|---------|
| 🔸 SQL注入 | `参数中是否有SQL关键字` | `防止数据库被攻击` | `拦截 ' OR 1=1` |
| 🔸 XSS攻击 | `参数中是否有脚本标签` | `防止页面被植入恶意代码` | `拦截 <script>` |
| 🔸 参数长度 | `参数是否超过限制` | `防止内存溢出` | `限制单个参数<1MB` |
| 🔸 特殊字符 | `是否包含危险字符` | `防止命令注入` | `拦截 ../` |

**实际案例**：
```
❌ 危险请求：
GET /user?id=1' OR '1'='1

网关检测到SQL注入特征 → 直接拒绝

✅ 安全请求：
GET /user?id=123

正常参数 → 放行通过
```

### 2.4 请求日志记录


**为什么要记录日志**：
- 📊 **监控分析**：了解系统使用情况
- 🔍 **问题排查**：出错时可以回溯
- 🛡️ **安全审计**：发现异常访问

**记录内容示例**：
```
[2025-09-23 10:30:15] 请求信息
├─ 请求IP: 192.168.1.100
├─ 请求方法: POST
├─ 请求路径: /api/order/create
├─ 用户ID: 10086
├─ 耗时: 235ms
└─ 响应状态: 200 成功
```

---

## 3. 📤 响应处理策略


### 3.1 响应数据脱敏


**什么是脱敏**：就是把敏感信息"打马赛克"
```
原始数据（危险）：
{
  "name": "张三",
  "phone": "13812345678",
  "idCard": "110101199001011234",
  "bankCard": "6222021234567890123"
}

脱敏后（安全）：
{
  "name": "张三",
  "phone": "138****5678",      ← 手机号脱敏
  "idCard": "1101**********34", ← 身份证脱敏
  "bankCard": "6222**********23" ← 银行卡脱敏
}
```

**常见脱敏规则**：

| 数据类型 | **原始格式** | **脱敏规则** | **示例** |
|---------|------------|------------|---------|
| 📱 手机号 | `13812345678` | `保留前3后4位` | `138****5678` |
| 🆔 身份证 | `110101199001011234` | `保留前4后2位` | `1101**********34` |
| 💳 银行卡 | `6222021234567890123` | `保留前4后2位` | `6222**********23` |
| 📧 邮箱 | `zhangsan@qq.com` | `保留前2位和域名` | `zh****@qq.com` |

### 3.2 响应数据加密


**加密流程**：
```
微服务返回敏感数据
        ↓
   网关拦截响应
        ↓
  对关键字段加密
        ↓
   返回给客户端
        ↓
  客户端解密使用
```

**实际应用场景**：
- 🔐 **用户密码**：永远不返回原文
- 💰 **金额数据**：防止中间人篡改
- 📋 **订单详情**：防止数据泄露

### 3.3 统一响应格式


**为什么需要统一格式**：让前端处理更简单
```java
// ✅ 统一的响应格式
{
  "code": 200,           // 状态码
  "message": "操作成功",  // 提示信息
  "data": {             // 业务数据
    "userId": 10086,
    "userName": "张三"
  },
  "timestamp": 1695456789  // 时间戳
}

// 前端处理很方便
if (response.code === 200) {
  // 成功处理
} else {
  // 显示错误信息
  alert(response.message);
}
```

---

## 4. ⚠️ 异常处理机制


### 4.1 为什么需要统一异常处理


**场景对比**：
```
❌ 没有统一处理：
服务A返回：{"error": "用户不存在"}
服务B返回：{"msg": "查询失败", "errCode": 404}
服务C返回：null

前端懵了：每个服务返回格式都不一样！

✅ 统一异常处理：
所有异常都返回：
{
  "code": 404,
  "message": "资源不存在",
  "data": null
}

前端舒服了：格式统一，处理方便！
```

### 4.2 常见异常分类


**异常类型表**：

| 异常类型 | **HTTP状态码** | **业务含义** | **返回示例** |
|---------|--------------|------------|------------|
| 🔐 认证异常 | `401` | `Token无效或过期` | `"请重新登录"` |
| 🚫 权限异常 | `403` | `没有操作权限` | `"权限不足"` |
| ❓ 资源异常 | `404` | `找不到资源` | `"用户不存在"` |
| ⚙️ 服务异常 | `500` | `服务器内部错误` | `"系统繁忙"` |
| 🚦 限流异常 | `429` | `请求过于频繁` | `"操作太快了"` |

### 4.3 异常处理流程


```
请求执行过程
   ↓
出现异常了
   ↓
判断异常类型
   ↓
┌─────────┬─────────┬─────────┐
│ Token异常│ 权限异常 │ 业务异常 │
└─────────┴─────────┴─────────┘
   ↓          ↓          ↓
返回401    返回403    返回500
   ↓          ↓          ↓
     统一格式包装
          ↓
     返回给客户端
```

**实际代码示例**：
```java
// 全局异常处理器
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 处理Token异常
    @ExceptionHandler(TokenException.class)
    public Result handleTokenException(TokenException e) {
        return Result.error(401, "请重新登录");
    }
    
    // 处理权限异常
    @ExceptionHandler(AccessDeniedException.class)
    public Result handleAccessDenied(AccessDeniedException e) {
        return Result.error(403, "权限不足");
    }
    
    // 处理所有其他异常
    @ExceptionHandler(Exception.class)
    public Result handleException(Exception e) {
        log.error("系统异常", e);  // 记录日志
        return Result.error(500, "系统繁忙，请稍后重试");
    }
}
```

### 4.4 友好的错误提示


**用户体验对比**：
```
❌ 技术化错误（用户看不懂）：
"NullPointerException at line 234"
"Connection timeout after 30000ms"

✅ 友好提示（用户能理解）：
"您访问的内容不存在"
"网络连接超时，请检查网络"
```

---

## 5. 🚦 限流熔断保护


### 5.1 什么是限流


**生活类比**：景区限流
```
普通日子：              高峰期：
游客随意进 ✓        每小时只放1000人
不需要等待          超过数量就排队等候
                   ↓
                保护景区不被挤爆
                保证游客体验质量
```

**技术定义**：控制单位时间内的请求数量，防止系统过载

### 5.2 常见限流策略


**策略对比表**：

| 限流方式 | **工作原理** | **应用场景** | **优缺点** |
|---------|------------|------------|-----------|
| 🪣 **令牌桶** | `固定速率产生令牌，请求消耗令牌` | `允许短时突发流量` | `✓灵活 ✗实现复杂` |
| 💧 **漏桶** | `固定速率处理请求，多余的排队` | `需要平滑流量` | `✓稳定 ✗不能应对突发` |
| 🔢 **计数器** | `时间窗口内计数，超过就拒绝` | `简单场景` | `✓简单 ✗临界问题` |
| 🪟 **滑动窗口** | `精确统计时间窗口内的请求` | `精确控制` | `✓准确 ✗占内存` |

**令牌桶原理图解**：
```
        生成令牌（固定速率）
              ↓
    ┌──────────────────┐
    │   令牌桶（容量C） │
    │   🪙🪙🪙🪙🪙      │
    └──────────────────┘
              ↓
         请求来了
              ↓
    桶里有令牌吗？
      ↙        ↘
    有          没有
     ↓           ↓
   取走令牌     请求被拒绝
     ↓         (返回429)
  处理请求
```

### 5.3 限流配置示例


**不同场景的限流策略**：
```
📱 普通用户：
- 每秒最多10个请求
- 超过限制返回"操作太快了"

👑 VIP用户：
- 每秒最多100个请求
- 更高的并发能力

🤖 API接口：
- 单个IP每分钟100次
- 防止恶意调用

💳 支付接口：
- 单用户每天最多50笔
- 防止刷单
```

### 5.4 什么是熔断


**生活类比**：家里的保险丝
```
正常情况：            电流过大时：
电器正常工作 ✓      保险丝自动断开 ⚡
                    ↓
                 保护整个电路
                 避免电器烧毁
```

**技术定义**：当服务出错率超过阈值时，自动切断调用，防止故障扩散

### 5.5 熔断状态机


```
        正常状态（Closed）
     ┌──────────────────┐
     │  请求正常通过     │
     │  错误率 < 50%    │
     └──────────────────┘
              ↓ 错误率达到50%
        半开状态（Half-Open）
     ┌──────────────────┐
     │  放少量请求测试   │
     │  测试是否恢复     │
     └──────────────────┘
       ↙              ↘
    测试成功          测试失败
       ↓                ↓
    恢复正常         熔断状态（Open）
                 ┌──────────────────┐
                 │  拒绝所有请求     │
                 │  快速失败返回     │
                 └──────────────────┘
                        ↓ 等待时间到
                     回到半开状态
```

### 5.6 熔断配置实战


**配置参数说明**：
```yaml
# Sentinel 熔断配置
sentinel:
  熔断策略:
    错误比例: 50%           # 错误率超过50%触发
    最小请求数: 10          # 至少10个请求才统计
    熔断时长: 10秒          # 熔断后10秒恢复
    半开状态请求数: 5       # 半开时放5个请求测试
```

**实际效果**：
```
场景：订单服务调用库存服务

正常情况：
订单 → 库存服务 ✓ → 返回库存数量

库存服务故障（错误率60%）：
订单 → 检测到熔断 ✗ → 直接返回"库存服务暂不可用"
     （不再调用库存服务，快速失败）

10秒后自动恢复测试：
订单 → 试探性调用 → 如果成功则恢复正常
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 网关安全：统一入口的安全防护，包括认证、授权、过滤
🔸 请求过滤：在请求到达服务前进行安全检查和验证
🔸 响应处理：统一格式、数据脱敏、异常转换
🔸 异常处理：统一异常格式，友好错误提示
🔸 限流熔断：保护系统不被压垮，防止故障扩散
```

### 6.2 安全防护层次


**防护体系图**：
```
第一层：网关层
├─ Token验证（谁在访问？）
├─ 权限检查（能做什么？）
└─ 参数过滤（请求合法吗？）

第二层：限流层
├─ 流量控制（请求太多？）
├─ 熔断保护（服务挂了？）
└─ 降级处理（保底方案？）

第三层：响应层
├─ 数据脱敏（隐私保护）
├─ 异常转换（友好提示）
└─ 日志记录（追踪审计）
```

### 6.3 限流 vs 熔断的区别


| 维度 | **限流** | **熔断** |
|-----|---------|---------|
| 🎯 目的 | `控制请求数量` | `防止故障扩散` |
| ⏰ 触发条件 | `请求量超过阈值` | `错误率超过阈值` |
| 🔧 处理方式 | `拒绝多余请求` | `快速失败返回` |
| 📊 关注指标 | `QPS、并发数` | `错误率、响应时间` |
| 💡 类比 | `景区限流` | `电路保险丝` |

### 6.4 实际应用建议


**安全配置清单**：
```
✅ 必须要做的：
□ Token验证过滤器
□ 统一异常处理
□ 敏感数据脱敏
□ 请求日志记录

✅ 强烈建议做的：
□ SQL注入防护
□ XSS攻击防护  
□ 接口限流配置
□ 熔断降级策略

✅ 可选增强的：
□ IP黑白名单
□ 请求签名验证
□ 响应数据加密
□ 分布式限流
```

### 6.5 常见问题处理


**问题排查指南**：

| 问题现象 | **可能原因** | **解决方案** |
|---------|------------|------------|
| 🔴 Token验证失败 | `Token过期/格式错误` | `检查Token生成和解析逻辑` |
| 🟡 请求被限流 | `QPS超过限制` | `调整限流阈值或优化代码` |
| 🟠 服务熔断 | `下游服务故障` | `检查服务状态，等待自动恢复` |
| 🔵 响应数据异常 | `序列化失败` | `检查数据格式和脱敏配置` |

**核心记忆口诀**：
- 网关安全第一道，认证授权不能少
- 请求过滤要严格，响应处理要友好
- 限流控制防过载，熔断保护断路刀
- 异常处理要统一，日志记录追踪好