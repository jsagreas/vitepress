---
title: 4、 TokenStore存储配置
---
## 📚 目录

1. [TokenStore是什么](#1-tokenstore是什么)
2. [InMemoryTokenStore内存存储](#2-inmemorytokenstore内存存储)
3. [JdbcTokenStore数据库存储](#3-jdbctokenstore数据库存储)
4. [RedisTokenStore缓存存储](#4-redistokenstore缓存存储)
5. [JwtTokenStore无状态存储](#5-jwttokenstore无状态存储)
6. [Token存储方案对比](#6-token存储方案对比)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 TokenStore是什么


### 1.1 通俗理解TokenStore


**🤔 先想一个问题**：用户登录后拿到的Token（令牌）要存在哪里？

```
生活类比：
就像你去游乐园买了门票（Token），游乐园需要记住：
- 这张票是谁买的
- 什么时候买的
- 有效期到什么时候
- 还有多少次使用机会

TokenStore就是"存放这些门票信息的地方"！
```

**🏷️ 专业术语解释**：
- **TokenStore** = Token（令牌） + Store（存储）
- 作用：负责OAuth2令牌的**存储、查询、删除**
- 本质：管理令牌生命周期的存储组件

### 1.2 TokenStore的核心职责


**📋 TokenStore要做什么**：

```
用户登录流程中的Token管理：

1️⃣ 存储Token
   用户登录成功 → 生成Token → TokenStore保存
   
2️⃣ 验证Token  
   用户访问接口 → 提交Token → TokenStore查询验证
   
3️⃣ 刷新Token
   Token快过期 → 刷新令牌 → TokenStore更新记录
   
4️⃣ 删除Token
   用户退出登录 → TokenStore删除令牌
```

**💡 换句话说**：
TokenStore就是一个"Token仓库管理员"，负责Token的增删改查。

### 1.3 为什么需要TokenStore


**❌ 不用TokenStore会怎样**：

```
问题场景：
- 用户A登录 → 生成Token → 存在哪？
- 用户B访问接口 → 提交Token → 如何验证是否有效？
- 用户C退出登录 → 如何让Token失效？

没有TokenStore，这些问题都无法解决！
```

**✅ 使用TokenStore的好处**：

| 功能 | **说明** | **实际效果** |
|------|---------|------------|
| 🔐 **安全控制** | `集中管理所有Token` | 可以随时撤销某个用户的Token |
| 📊 **状态追踪** | `记录Token使用情况` | 知道谁在什么时候访问了系统 |
| ⏰ **过期管理** | `自动清理过期Token` | 防止无效Token占用资源 |
| 🔄 **刷新机制** | `支持Token续期` | 用户体验更好，不用频繁登录 |

---

## 2. 💾 InMemoryTokenStore内存存储


### 2.1 什么是内存存储


**🌰 举个例子**：

```
就像你记笔记：
- 记在脑子里（内存） → 快但重启就忘
- 记在本子上（硬盘） → 慢但永久保存

InMemoryTokenStore = 把Token记在程序的"脑子里"
```

**🏷️ 核心特点**：
- Token存储在**服务器内存**中
- 程序重启 → Token全部丢失
- 访问速度**极快**（直接内存读取）

### 2.2 配置InMemoryTokenStore


**📝 Spring配置代码**：

```java
@Configuration
public class TokenStoreConfig {
    
    // 创建内存Token存储
    @Bean
    public TokenStore tokenStore() {
        return new InMemoryTokenStore();
    }
}
```

**🔍 代码解读**：
- `InMemoryTokenStore()`：创建内存存储对象
- 不需要任何参数，直接new就能用
- Spring会自动注入到OAuth2配置中

### 2.3 适用场景


**✅ 什么时候用内存存储**：

| 场景 | **说明** |
|------|---------|
| 🧪 **开发测试** | `本地开发调试，快速验证功能` |
| 👤 **单机应用** | `只有一台服务器，用户量不大` |
| 📚 **学习Demo** | `学习OAuth2原理，简化配置` |

**❌ 什么时候不能用**：

```
生产环境的问题：

问题1：服务重启 → 所有用户被强制退出
问题2：多台服务器 → Token无法共享
问题3：内存有限 → 用户多了会爆内存
```

**⚠️ 重要提醒**：
- 内存存储仅适合**开发环境**
- 生产环境必须用**持久化存储**

---

## 3. 🗄️ JdbcTokenStore数据库存储


### 3.1 什么是数据库存储


**💭 思考一下**：
如果把Token存在数据库里会怎样？

```
数据库存储的特点：

优点：
- 服务重启 → Token还在（持久化）
- 多台服务器 → 共享同一个数据库
- 可以查询统计 → Token使用情况一目了然

缺点：
- 需要读写数据库 → 比内存慢
- 需要维护表结构 → 多了运维工作
```

### 3.2 数据库表结构


**📊 OAuth2需要的表**：

```sql
-- 1. 存储访问令牌
CREATE TABLE oauth_access_token (
    token_id VARCHAR(256),           -- Token的唯一标识
    token BLOB,                      -- Token序列化数据
    authentication_id VARCHAR(256),  -- 认证信息ID
    user_name VARCHAR(256),          -- 用户名
    client_id VARCHAR(256),          -- 客户端ID
    authentication BLOB,             -- 认证信息
    refresh_token VARCHAR(256)       -- 关联的刷新Token
);

-- 2. 存储刷新令牌
CREATE TABLE oauth_refresh_token (
    token_id VARCHAR(256),           -- 刷新Token的ID
    token BLOB,                      -- 刷新Token数据
    authentication BLOB              -- 认证信息
);
```

**🔑 字段含义解释**：
- `token_id`：Token的身份证号（唯一标识）
- `user_name`：哪个用户的Token
- `client_id`：哪个客户端申请的Token
- `authentication`：认证信息（权限、角色等）

### 3.3 配置JdbcTokenStore


**📝 完整配置代码**：

```java
@Configuration
public class TokenStoreConfig {
    
    @Autowired
    private DataSource dataSource;  // 数据源
    
    @Bean
    public TokenStore tokenStore() {
        return new JdbcTokenStore(dataSource);
    }
}
```

**🔍 配置说明**：
- `DataSource`：Spring数据库连接池
- `JdbcTokenStore`：自动使用这个数据源操作数据库
- Spring会自动创建上面的两张表（如果不存在）

### 3.4 适用场景


**✅ 推荐使用场景**：

| 场景 | **为什么选它** |
|------|--------------|
| 🏢 **企业应用** | `需要持久化，重启不影响用户` |
| 🔄 **集群部署** | `多台服务器共享Token状态` |
| 📈 **审计需求** | `可以查询Token使用历史` |

**⚠️ 注意事项**：
- 数据库性能要足够（高并发时压力大）
- 需要定期清理过期Token（避免表太大）
- 建议给表加索引（提升查询速度）

---

## 4. ⚡ RedisTokenStore缓存存储


### 4.1 Redis存储的优势


**🤔 为什么选Redis**：

```
对比分析：

内存存储：快但重启丢失 ❌
数据库存储：慢但持久化 ✅
Redis存储：又快又能持久化 ✅✅

Redis = 内存的速度 + 数据库的持久化
```

**🏷️ Redis特点**：
- 存储在**内存**中（像InMemory一样快）
- 支持**持久化**（像数据库一样可靠）
- 天然支持**过期时间**（自动清理过期Token）

### 4.2 配置RedisTokenStore


**📝 添加依赖**：

```xml
<!-- Spring Data Redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

**📝 Redis配置**：

```java
@Configuration
public class TokenStoreConfig {
    
    @Autowired
    private RedisConnectionFactory redisConnectionFactory;
    
    @Bean
    public TokenStore tokenStore() {
        return new RedisTokenStore(redisConnectionFactory);
    }
}
```

**🔧 application.yml配置**：

```yaml
spring:
  redis:
    host: localhost      # Redis服务器地址
    port: 6379          # Redis端口
    password: 123456    # Redis密码（如果有）
    database: 0         # 使用哪个数据库
```

### 4.3 Redis存储结构


**📊 Token在Redis中的样子**：

```
Redis Key命名规则：

access:Token值           → 存储访问令牌
auth:Token值             → 存储认证信息
refresh:Token值          → 存储刷新令牌
client_id:客户端ID       → 该客户端的所有Token
uname:用户名             → 该用户的所有Token

示例：
access:abc123           → {"user":"张三","expire":3600}
uname:zhangsan         → ["abc123","def456"]
```

### 4.4 适用场景


**✅ Redis最佳实践**：

| 场景 | **为什么选Redis** |
|------|-----------------|
| 🚀 **高并发系统** | `内存读写，性能极佳` |
| ☁️ **分布式部署** | `天然支持集群共享` |
| ⏰ **自动过期** | `Redis自带TTL，自动清理` |
| 💰 **成本优化** | `减轻数据库压力` |

**🎯 实际应用**：
```
典型架构：

用户访问 → Nginx → 
  ├─ 应用服务器1 ┐
  ├─ 应用服务器2 ├→ Redis (共享Token)
  └─ 应用服务器3 ┘
  
所有服务器共享同一个Redis，Token状态一致！
```

---

## 5. 🔐 JwtTokenStore无状态存储


### 5.1 JWT的核心理念


**💡 换个思路思考**：

```
传统方式：
Token只是一个随机字符串 → 需要查存储才知道信息
例如：Token = "abc123" → 查Redis得知是张三的Token

JWT方式：
Token本身就包含所有信息 → 不需要查存储
例如：Token = "eyJ0eXAi..." → 解密后直接看到是张三
```

**🏷️ JWT是什么**：
- **JWT** = JSON Web Token（网络令牌）
- 特点：Token**自包含**所有信息
- 本质：用加密算法保护的JSON数据

### 5.2 JWT的结构


**📦 JWT的三部分**：

```
完整的JWT Token：
eyJhbGci.eyJ1c2Vy.SflKxwRJ

Header.Payload.Signature
头部   载荷    签名

示例解析：
Header（头部）：
{
  "alg": "HS256",      // 加密算法
  "typ": "JWT"         // Token类型
}

Payload（载荷）：
{
  "user_name": "张三",  // 用户名
  "authorities": ["USER"], // 权限
  "exp": 1609459200     // 过期时间
}

Signature（签名）：
用密钥加密(Header + Payload) = 防止篡改
```

**🔍 深入理解**：
- Header：告诉你用什么算法加密的
- Payload：实际的业务数据
- Signature：保证前两部分没被改过

### 5.3 配置JwtTokenStore


**📝 JWT配置代码**：

```java
@Configuration
public class TokenStoreConfig {
    
    @Bean
    public TokenStore tokenStore() {
        return new JwtTokenStore(jwtAccessTokenConverter());
    }
    
    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("my-secret-key");  // 签名密钥
        return converter;
    }
}
```

**⚠️ 安全提醒**：
- `signingKey`是加密密钥，要保密！
- 生产环境建议用**非对称加密**（更安全）

### 5.4 JWT的优缺点


**✅ JWT的优势**：

| 优势 | **说明** | **实际好处** |
|------|---------|------------|
| 🚀 **无状态** | `不需要存储Token` | 服务器压力小，易扩展 |
| 📦 **自包含** | `Token包含所有信息` | 不需要查数据库/Redis |
| 🌐 **跨域友好** | `可以在不同系统间传递` | 适合微服务架构 |

**❌ JWT的问题**：

```
主要缺点：

1. 无法主动失效
   - Token签发后，服务器无法撤销
   - 即使用户退出，Token在过期前仍然有效
   
2. Token较大
   - 因为包含所有信息，体积比普通Token大
   - 每次请求都要传输完整Token
   
3. 无法续期
   - Token快过期时，无法简单刷新
   - 需要重新生成新Token
```

### 5.5 JWT适用场景


**🎯 什么时候用JWT**：

| 场景 | **为什么合适** |
|------|--------------|
| 🌍 **分布式系统** | `无状态，不需要共享存储` |
| 📱 **移动应用** | `Token包含信息，减少请求次数` |
| 🔗 **第三方集成** | `跨系统传递方便` |
| ⏱️ **短期Token** | `过期时间短，安全可控` |

**❌ 不适合的场景**：
- 需要**随时撤销**Token的系统
- 对**Token大小**敏感的场景
- 需要**精确控制**Token生命周期的应用

---

## 6. ⚖️ Token存储方案对比


### 6.1 综合性能对比


**📊 四种方案对比表**：

| 方案 | **速度** | **持久化** | **集群支持** | **运维成本** | **推荐场景** |
|------|---------|-----------|------------|------------|------------|
| 🧠 **InMemory** | `⭐⭐⭐⭐⭐` | `❌` | `❌` | `⭐` | 开发测试 |
| 🗄️ **JDBC** | `⭐⭐` | `✅` | `✅` | `⭐⭐⭐` | 审计要求高 |
| ⚡ **Redis** | `⭐⭐⭐⭐` | `✅` | `✅` | `⭐⭐` | 高并发生产 |
| 🔐 **JWT** | `⭐⭐⭐⭐⭐` | `不需要` | `✅` | `⭐` | 微服务/无状态 |

### 6.2 选择决策树


**🌳 如何选择存储方案**：

```
开始选择
    ↓
需要持久化？
├─ No → InMemory（开发测试）
└─ Yes → 
    ↓
    需要高性能？
    ├─ No → JDBC（审计优先）
    └─ Yes →
        ↓
        能接受无法主动失效？
        ├─ Yes → JWT（无状态）
        └─ No → Redis（最佳平衡）
```

### 6.3 生产环境建议


**🏢 企业级推荐方案**：

**方案一：Redis + JWT组合**
```
Token结构：
- AccessToken：用JWT（有效期短，如2小时）
- RefreshToken：存Redis（有效期长，如7天）

优势：
✅ AccessToken无状态，性能高
✅ RefreshToken可控，能撤销
✅ 兼顾性能和安全
```

**方案二：纯Redis方案**
```
适用场景：
- 对安全要求高
- 需要精确控制Token
- 用户量中等规模

配置优化：
- 设置合理的过期时间
- 启用Redis持久化
- 做好Redis集群
```

### 6.4 常见问题解答


**❓ 高并发下JDBC为什么慢**？

```
原因分析：
每次验证Token：
1. 建立数据库连接
2. 执行SQL查询
3. 关闭连接

高并发下：
- 数据库连接池耗尽
- SQL查询成为瓶颈
- 锁竞争导致等待

解决方案：
→ 换用Redis（内存操作，无连接开销）
```

**❓ JWT无法撤销怎么办**？

```
解决方案：

方案1：维护黑名单
- 将需要撤销的Token存入Redis
- 验证时先查黑名单
- 缺点：失去了无状态优势

方案2：短期Token + 刷新机制
- AccessToken只有15分钟
- RefreshToken存Redis
- 泄露影响时间短

方案3：版本号机制
- Token中加入版本号
- 撤销时更新用户版本号
- 旧版本Token自动失效
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的概念


**🎯 TokenStore核心理解**：

```
TokenStore = Token仓库管理员
- 职责：存储、查询、删除Token
- 目标：管理Token的完整生命周期
- 本质：不同的存储介质选择
```

**🏷️ 四种方案一句话总结**：

| 方案 | **核心特点** |
|------|------------|
| InMemory | `快但不持久，仅用于开发` |
| JDBC | `持久化但慢，适合审计场景` |
| Redis | `又快又持久，生产首选` |
| JWT | `无状态自包含，微服务推荐` |

### 7.2 实际应用建议


**💼 不同规模的选择**：

**小型项目（< 1000用户）**：
```
开发环境：InMemory
生产环境：JDBC 或 Redis都可以
```

**中型项目（1000-10000用户）**：
```
开发环境：InMemory
生产环境：Redis（必选）
```

**大型项目（> 10000用户）**：
```
开发环境：InMemory
生产环境：Redis集群 + JWT组合
```

### 7.3 关键注意事项


**⚠️ 安全提醒**：

```
1. 密钥管理
   - JWT签名密钥要保密
   - 定期更换密钥
   - 生产环境用非对称加密

2. 过期控制
   - AccessToken不超过2小时
   - RefreshToken不超过7天
   - 根据安全级别调整

3. 清理策略
   - 数据库定期清理过期Token
   - Redis设置自动过期
   - 避免存储空间膨胀
```

**🚀 性能优化**：

```
1. 合理选型
   - 高并发必选Redis/JWT
   - 不要在生产用InMemory
   
2. 集群部署
   - Redis做主从或集群
   - JDBC用读写分离
   
3. 监控告警
   - 监控Token存储的性能
   - Token生成/验证的耗时
   - 异常Token的数量
```

### 7.4 学习路径建议


**📚 循序渐进学习**：

```
第1步：理解概念
→ TokenStore是什么
→ 为什么需要它
→ 解决什么问题

第2步：动手实践
→ 从InMemory开始
→ 逐步尝试其他方案
→ 对比不同存储的效果

第3步：生产应用
→ 选择合适的方案
→ 考虑安全和性能
→ 做好监控和运维

第4步：深入优化
→ JWT组合使用
→ Redis集群部署
→ 定制化存储方案
```

**🎓 核心记忆口诀**：

```
TokenStore存Token，四种方案要记牢
InMemory开发用，快速但不能保
JDBC持久化，审计查询真可靠
Redis又快又稳，生产环境离不了
JWT无状态强，微服务架构要用到
```