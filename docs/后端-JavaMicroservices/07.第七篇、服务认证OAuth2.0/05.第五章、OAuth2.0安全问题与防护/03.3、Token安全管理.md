---
title: 3、Token安全管理
---
## 📚 目录

1. [Token安全基础概念](#1-token安全基础概念)
2. [Token生命周期管理](#2-token生命周期管理)
3. [Token安全存储策略](#3-token安全存储策略)
4. [Token传输安全保障](#4-token传输安全保障)
5. [Token定期轮换机制](#5-token定期轮换机制)
6. [Token撤销与失效机制](#6-token撤销与失效机制)
7. [最小权限原则实践](#7-最小权限原则实践)
8. [Token安全最佳实践](#8-token安全最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔐 Token安全基础概念


### 1.1 Token是什么


**🔸 通俗理解Token**
```
Token就像是你的"临时通行证"：

日常场景类比：
- 酒店房卡：入住时给你，退房时失效
- 游乐园手环：买票后戴上，当天有效
- 停车票：进场时拿，出场时缴费

OAuth2.0中的Token：
- 登录成功后服务器给你的"凭证"
- 凭这个凭证访问受保护的资源
- 有时间限制，过期就得重新获取
```

**💡 Token的两种类型**

| Token类型 | **作用** | **有效期** | **使用场景** |
|-----------|---------|-----------|-------------|
| **Access Token** | 访问令牌 | 短期(几分钟到几小时) | 直接访问API资源 |
| **Refresh Token** | 刷新令牌 | 长期(几天到几个月) | 获取新的Access Token |

### 1.2 为什么Token需要安全管理


**⚠️ Token泄露的严重后果**
```
如果Token被坏人拿到，就像：
- 别人拿到了你的酒店房卡 → 可以进你房间
- 别人拿到了你的银行卡密码 → 可以转走你的钱

实际危害：
❌ 冒充你的身份访问系统
❌ 窃取你的个人数据
❌ 执行未授权的操作
❌ 造成财产和隐私损失
```

**🛡️ Token安全管理的核心目标**
```
三大安全目标：

1. 机密性 (Confidentiality)
   → Token不被未授权的人看到

2. 完整性 (Integrity)  
   → Token内容不被篡改

3. 可用性 (Availability)
   → 合法用户能正常使用Token
```

---

## 2. ⏰ Token生命周期管理


### 2.1 Token的完整生命周期


**📊 Token从出生到死亡的过程**
```
用户登录                              Token过期
   |                                      |
   ↓                                      ↓
[生成] → [下发] → [使用] → [刷新] → [失效]
   ↑                  ↑        ↑        ↑
 服务器            客户端    换新的   被删除
```

**🔸 各阶段详解**

**阶段1：Token生成**
```
什么时候生成？
- 用户登录成功后
- 用Refresh Token换新Token时

生成什么？
- Access Token：实际使用的凭证
- Refresh Token：用来换新的Access Token
- 过期时间：这两个Token分别的有效期
```

**阶段2：Token下发**
```
怎么给用户？
✅ 通过HTTPS安全传输
✅ 在响应体中返回(不在URL里)
✅ 包含过期时间信息

返回示例：
{
  "access_token": "eyJhbGc...",
  "token_type": "Bearer",
  "expires_in": 3600,           // 1小时后过期
  "refresh_token": "tGzv3JO..."
}
```

**阶段3：Token使用**
```
客户端怎么用？
- 每次API请求都带上Token
- 放在HTTP请求头里
- 格式：Authorization: Bearer <token>

检查机制：
- 服务器每次都验证Token是否有效
- 检查是否过期
- 检查权限是否足够
```

**阶段4：Token刷新**
```
为什么要刷新？
- Access Token有效期短(安全考虑)
- 避免频繁让用户重新登录

刷新流程：
1. Access Token快过期时
2. 用Refresh Token向服务器请求
3. 服务器返回新的Access Token
4. 继续使用新Token访问资源
```

**阶段5：Token失效**
```
什么时候失效？
- 到达过期时间(自然失效)
- 用户主动登出(主动撤销)
- 检测到安全问题(强制失效)
- 密码被修改(全部失效)

失效后怎么办？
→ 需要重新登录获取新Token
```

### 2.2 合理设置Token有效期


**⏱️ 有效期设置原则**

```
Access Token有效期：
推荐：15分钟 - 1小时
- 太短：用户体验差，频繁刷新
- 太长：被盗风险大，安全性低

Refresh Token有效期：
推荐：7天 - 30天
- 平衡安全性和用户体验
- 可以设置"滑动过期"机制

实际建议：
📱 移动App：Access 30分钟，Refresh 30天
💻 Web应用：Access 1小时，Refresh 7天  
🔒 高安全系统：Access 5分钟，Refresh 24小时
```

**🎯 滑动过期机制**
```
普通过期：
- 创建时间 + 30天 = 固定失效时间
- 即使一直在用也会过期

滑动过期：  
- 每次使用都延长有效期
- 持续活跃的用户不用重新登录
- 长期不用才会过期

举例：
用户每天都用App → Refresh Token一直有效
用户30天没用App → Refresh Token过期，需要重新登录
```

---

## 3. 💾 Token安全存储策略


### 3.1 客户端存储安全


**🔸 不同环境的存储方案**

| 环境类型 | **推荐存储方式** | **安全级别** | **注意事项** |
|---------|----------------|-------------|-------------|
| **浏览器** | HttpOnly Cookie | ⭐⭐⭐⭐ | 防XSS攻击，不能用JS访问 |
| **移动App** | 系统密钥链/KeyStore | ⭐⭐⭐⭐⭐ | 操作系统级加密保护 |
| **桌面应用** | 加密的本地存储 | ⭐⭐⭐ | 需要自己实现加密 |

**浏览器存储对比**

```
❌ 不推荐：localStorage/sessionStorage
原因：
- 可以被JavaScript读取
- 容易受XSS攻击
- 明文存储不安全

示例(错误做法)：
localStorage.setItem('token', 'eyJhbGc...')  // 危险！

✅ 推荐：HttpOnly Cookie
优势：
- JavaScript无法访问
- 浏览器自动在请求中携带
- 防XSS攻击

服务器设置：
Set-Cookie: token=eyJhbGc...; HttpOnly; Secure; SameSite=Strict

解释：
- HttpOnly：禁止JS访问
- Secure：只在HTTPS下传输  
- SameSite：防止CSRF攻击
```

**📱 移动端存储最佳实践**

```
iOS系统：使用Keychain
- 系统级加密存储
- 即使App被删除也能保留
- 可以设置不同的访问策略

安卓系统：使用KeyStore
- 硬件支持的加密
- 密钥不会被导出
- 指纹/面部识别集成

基本步骤：
1. Token加密后存储
2. 每次使用前解密
3. 内存中用完立即清除
```

### 3.2 服务器端存储安全


**🗄️ 服务器存储Token的方式**

**方案1：内存存储(Redis)**
```
优点：
✅ 速度快，毫秒级响应
✅ 支持自动过期
✅ 方便撤销和管理

适用场景：
- 在线用户的Session管理
- Access Token黑名单
- 临时验证码存储

注意事项：
- 需要持久化配置(防止重启丢失)
- 做好内存容量规划
- 考虑集群同步问题
```

**方案2：数据库存储**
```
优点：
✅ 数据持久化
✅ 便于审计和追溯
✅ 复杂查询支持

表结构示例：
字段：
- user_id：用户ID
- token_hash：Token的哈希值(不存原文!)
- issued_at：颁发时间
- expires_at：过期时间
- is_revoked：是否已撤销
```

**🔐 Token存储的加密要求**

```
存储原则：

1. 不存储明文Token
   ❌ token = "eyJhbGc..."
   ✅ token_hash = SHA256(token)

2. 使用单向加密
   - 服务器只存储Token的哈希值
   - 验证时对比哈希值
   - 即使数据库泄露也安全

3. 加盐哈希
   - 给每个Token加随机盐值
   - 防止彩虹表攻击
```

---

## 4. 🔒 Token传输安全保障


### 4.1 HTTPS强制使用


**🌐 为什么必须用HTTPS**

```
HTTP的危险(明文传输)：
           客户端 ←→ 服务器
              ↑  可被窃听  ↑
           黑客能看到Token!

HTTPS的保护(加密传输)：
           客户端 ←→ 服务器  
              ↑  加密通道  ↑
           黑客看到的是乱码
```

**⚙️ 强制HTTPS配置**

```
服务器端配置：

1. 重定向HTTP到HTTPS
   if (request.protocol != 'https') {
     redirect('https://' + request.url)
   }

2. 设置HSTS头
   Strict-Transport-Security: max-age=31536000; includeSubDomains
   
   含义：
   - 浏览器强制使用HTTPS
   - 1年内都不会降级到HTTP
   - 包括所有子域名

3. 拒绝HTTP请求
   if (!request.isSecure()) {
     return 403 Forbidden
   }
```

### 4.2 Token传输位置选择


**📍 Token应该放在哪里传输**

```
❌ 错误做法：放在URL里
GET /api/user?token=eyJhbGc...

危险原因：
- URL会被记录在服务器日志
- 浏览器历史记录会保存
- 可能被引用(Referer)泄露

✅ 正确做法：放在请求头
GET /api/user
Authorization: Bearer eyJhbGc...

安全原因：
- 不会出现在日志中
- 不会被浏览器缓存
- 标准做法，支持良好
```

**🔧 请求头配置示例**

```
前端发送Token：

fetch('/api/user', {
  headers: {
    'Authorization': 'Bearer ' + accessToken,
    'Content-Type': 'application/json'
  }
})

后端验证Token：

String authHeader = request.getHeader("Authorization");
if (authHeader != null && authHeader.startsWith("Bearer ")) {
  String token = authHeader.substring(7);
  // 验证token
}
```

### 4.3 防止Token劫持


**🛡️ 常见劫持手段与防护**

```
攻击方式1：中间人攻击(MITM)
防护措施：
✅ 强制HTTPS
✅ 证书绑定(Certificate Pinning)
✅ 公钥固定

攻击方式2：XSS攻击
防护措施：
✅ 使用HttpOnly Cookie
✅ 输入验证和转义
✅ CSP(内容安全策略)

攻击方式3：CSRF攻击  
防护措施：
✅ SameSite Cookie属性
✅ CSRF Token验证
✅ 检查Origin/Referer头
```

---

## 5. 🔄 Token定期轮换机制


### 5.1 为什么要定期轮换Token


**🎯 轮换的核心价值**

```
类比理解：
- 银行卡密码：建议3-6个月换一次
- 门锁密码：定期更换防止泄露
- Token也一样：定期换新降低风险

实际好处：
1. 缩小泄露窗口期
   - 即使Token被盗，很快就失效
   
2. 降低长期风险
   - 长期使用同一Token风险累积
   
3. 符合安全规范
   - 很多安全标准要求定期轮换
```

### 5.2 轮换策略设计


**⏰ 轮换时机选择**

```
策略1：时间触发轮换
- Access Token：每15-60分钟自动过期
- Refresh Token：每次使用时可换新

策略2：事件触发轮换
- 密码修改 → 立即轮换全部Token
- 检测到异常 → 强制轮换
- 权限变更 → 换发新Token

策略3：主动刷新机制
用户操作流程：
1. App检测Token快过期
2. 自动用Refresh Token换新的
3. 用户无感知，体验流畅
```

**🔄 无感知轮换实现**

```
前端实现思路：

核心流程图：
API请求 → Token即将过期? 
            ↓是              ↓否
    先刷新Token          直接使用
            ↓                ↓
    用新Token请求  ←────┘

代码逻辑：
1. 拦截每个API请求
2. 检查Token过期时间
3. 如果快过期(比如还剩5分钟)
4. 先用Refresh Token换新的
5. 再用新Token发起原请求
6. 用户完全不知道Token被换了
```

### 5.3 Refresh Token轮换


**🔐 Refresh Token Rotation机制**

```
传统方式(不安全)：
- Refresh Token永久有效
- 被盗后可以一直用

改进方式(Token Rotation)：
- 每次使用Refresh Token都换新的
- 旧的Refresh Token立即失效
- 即使被盗，只能用一次

工作流程：
客户端请求刷新
    ↓
发送旧Refresh Token
    ↓
服务器验证
    ↓
返回新Access Token + 新Refresh Token
    ↓
旧Refresh Token立即失效
```

**📊 轮换检测机制**

```
异常检测：
如果同一个Refresh Token被使用2次：
1. 可能Token被盗了
2. 立即撤销该用户所有Token
3. 强制用户重新登录
4. 记录安全日志，发送告警

实现伪代码：
if (refreshToken.isUsed()) {
  // 这个Token之前用过了!
  revokeAllUserTokens(userId)
  logSecurityEvent("Refresh token reuse detected")
  return error("Token已失效，请重新登录")
}
```

---

## 6. 🚫 Token撤销与失效机制


### 6.1 Token撤销场景


**📋 什么时候需要撤销Token**

```
主动撤销场景：
1. 用户登出
   - 用户点击退出登录
   - 立即撤销当前Token

2. 修改密码
   - 修改密码后旧Token应该全部失效
   - 防止被盗后继续使用

3. 权限变更  
   - 用户角色改变
   - 权限升级或降级
   - 需要重新颁发Token

被动撤销场景：
1. 检测到安全风险
   - 异常登录地点
   - 可疑的访问模式
   
2. 管理员强制下线
   - 账号被冻结
   - 违规操作
   
3. Token泄露报告
   - 用户报告Token可能泄露
   - 立即撤销所有Token
```

### 6.2 撤销机制实现


**🔧 黑名单方式**

```
原理：
- 正常Token是"白名单"(默认有效)
- 撤销的Token加入"黑名单"
- 验证时检查是否在黑名单中

优点：
✅ 实现简单
✅ 撤销立即生效
✅ 支持单个Token撤销

缺点：
❌ 需要额外存储空间
❌ 黑名单会越来越大
❌ 查询性能可能下降

实现方案：
存储：使用Redis的Set结构
过期：设置与Token相同的TTL
查询：O(1)时间复杂度

伪代码：
// 撤销Token
redis.sadd("token_blacklist", tokenHash)
redis.expire("token_blacklist", tokenTTL)

// 验证Token
if (redis.sismember("token_blacklist", tokenHash)) {
  return "Token已被撤销"
}
```

**🔐 刷新令牌标记方式**

```
原理：
- 数据库记录每个Refresh Token状态
- 撤销时标记为"已撤销"
- 验证时检查数据库

优点：
✅ 精确控制
✅ 便于审计
✅ 支持复杂业务逻辑

Token表结构：
{
  id: "唯一ID",
  user_id: "用户ID", 
  token_hash: "Token哈希值",
  is_revoked: false,        // 是否撤销
  revoked_at: null,         // 撤销时间
  revoke_reason: null       // 撤销原因
}

撤销操作：
UPDATE tokens 
SET is_revoked = true,
    revoked_at = NOW(),
    revoke_reason = '用户登出'
WHERE user_id = ? AND token_hash = ?
```

### 6.3 全局撤销策略


**🌍 一键清除所有Token**

```
场景示例：
- 用户修改密码
- 账号被盗后的紧急处理
- 检测到严重安全问题

实现方式：

方式1：Token版本号
- 给每个用户维护一个版本号
- 修改密码时版本号+1  
- Token里包含版本号
- 验证时对比版本号

用户表：
{
  user_id: 123,
  token_version: 5  // 当前版本号
}

Token payload：
{
  user_id: 123,
  token_version: 5,  // Token创建时的版本号
  exp: 1234567890
}

验证逻辑：
if (token.version < user.token_version) {
  return "Token已失效，请重新登录"
}

方式2：全局撤销时间
- 记录用户最后一次"全局撤销"时间
- 该时间之前的Token全部无效

用户表：
{
  user_id: 123,
  tokens_revoked_before: "2024-01-15 10:30:00"
}

验证逻辑：
if (token.created_at < user.tokens_revoked_before) {
  return "Token已失效"
}
```

---

## 7. 🎯 最小权限原则实践


### 7.1 理解最小权限原则


**🔸 什么是最小权限原则**

```
通俗比喻：
- 给快递员：只给小区门禁卡，不给房门钥匙
- 给保洁员：只能进公共区域，不能进卧室
- Token也一样：只给需要的权限，不给多余的

核心思想：
一个Token应该：
✅ 只能做它需要做的事
✅ 只能访问它需要的资源
✅ 只在需要的时间内有效

好处：
- 即使Token泄露，损失也有限
- 减少安全风险
- 便于审计和管理
```

### 7.2 权限范围(Scope)设计


**📋 Scope的概念和使用**

```
Scope是什么？
- Token携带的权限标识
- 告诉服务器"这个Token能干什么"
- 像是Token的"权限清单"

常见Scope示例：
read:user     - 读取用户信息
write:user    - 修改用户信息
read:orders   - 查看订单
write:orders  - 创建/修改订单
admin:all     - 管理员全部权限

Token中的Scope：
{
  "user_id": 123,
  "scope": "read:user read:orders",
  "exp": 1234567890
}
```

**🔧 按需分配Scope**

```
场景1：第三方登录
用户用微信登录你的App：

请求的Scope：
- snsapi_base：只获取openid(基础授权)
- snsapi_userinfo：获取用户详细信息(需用户同意)

原则：
- 只要必需的权限
- 不要全部权限

场景2：后台管理系统
不同角色的Token：

普通用户Token：
scope: "read:own_profile read:own_orders"

客服人员Token：
scope: "read:all_orders write:order_status"

管理员Token：
scope: "admin:all"

好处：
- 客服被盗号，只影响订单，不影响用户资料
- 风险控制在最小范围
```

### 7.3 Scope验证实现


**🔍 服务端权限检查**

```
实现步骤：

1. 从Token中提取Scope
String[] scopes = token.getScope().split(" ")

2. 检查是否包含所需权限
@PreAuthorize("hasScope('read:user')")
public User getUser() {
  // 只有Token包含read:user权限才能访问
}

3. 动态权限判断
public void updateOrder(Order order) {
  if (order.userId == currentUser.id) {
    // 修改自己的订单：需要write:own_orders
    requireScope("write:own_orders")
  } else {
    // 修改别人的订单：需要admin权限
    requireScope("admin:orders")
  }
}

伪代码实现：
void requireScope(String requiredScope) {
  if (!token.scopes.contains(requiredScope)) {
    throw new InsufficientScopeException(
      "需要权限: " + requiredScope
    )
  }
}
```

**🎯 前端权限控制**

```
前端也要配合后端做权限检查：

按钮权限控制：
<button v-if="hasScope('write:orders')">
  创建订单
</button>

路由权限控制：
router.beforeEach((to, from, next) => {
  const requiredScope = to.meta.scope
  if (requiredScope && !hasScope(requiredScope)) {
    next('/403')  // 无权限访问
  } else {
    next()
  }
})

注意：
前端控制只是用户体验优化
真正的安全检查必须在后端！
```

---

## 8. 🛡️ Token安全最佳实践


### 8.1 开发阶段安全措施


**📝 代码层面的安全要求**

```
1. 永远不要记录完整Token
   ❌ 错误：logger.info("Token: " + token)
   ✅ 正确：logger.info("Token issued for user: " + userId)

2. 不在前端存储敏感Token
   ❌ 错误：localStorage.setItem('refresh_token', token)
   ✅ 正确：使用HttpOnly Cookie

3. Token传输必须加密
   ❌ 错误：http://api.com/user?token=xxx
   ✅ 正确：https://api.com/user (Token在Header中)

4. 设置合理的过期时间
   ❌ 错误：expires_in: 365 * 24 * 3600 (一年)
   ✅ 正确：expires_in: 3600 (1小时)

5. 实现Token撤销机制
   ❌ 错误：用户登出了，Token还能用
   ✅ 正确：登出立即撤销Token
```

### 8.2 运维阶段安全措施


**🔧 部署和监控要求**

```
部署清单：

✅ HTTPS配置
   - 强制重定向HTTP到HTTPS
   - 使用TLS 1.2或更高版本
   - 配置HSTS头

✅ 防火墙规则
   - 限制Token服务器的访问来源
   - 防止DDoS攻击

✅ 日志监控  
   - 记录Token颁发和验证失败
   - 监控异常的Token使用模式
   - 设置告警规则

✅ 定期审计
   - 检查长期未使用的Token
   - 清理过期但未删除的Token
   - 审查权限配置
```

**📊 监控指标设置**

```
关键监控项：

1. Token颁发速率
   - 突然增加 → 可能遭受攻击
   - 正常值：根据业务量设定

2. 验证失败率  
   - 超过阈值 → 可能有Token被盗
   - 告警阈值：如5%

3. Token使用地理位置
   - 短时间多地登录 → 可疑
   - 需要二次验证

4. 异常访问模式
   - 深夜大量API调用 → 异常
   - 访问频率超限 → 机器人

告警规则示例：
IF token_fail_rate > 10% THEN
  alert("Token验证失败率异常")
  
IF same_token_used_in_different_cities THEN  
  alert("Token异地使用，可能被盗")
```

### 8.3 用户教育与安全提示


**👥 帮助用户保护Token**

```
给用户的安全建议：

1. 不要分享登录信息
   提示："您的登录凭证仅供个人使用"

2. 定期修改密码
   提示："建议每3个月修改一次密码"

3. 异常登录提醒
   邮件："检测到您的账号在新设备登录"
   
4. 安全退出提示  
   弹窗："确定退出吗？退出后Token将立即失效"

5. 可疑活动通知
   推送："检测到异常登录，如非本人操作请立即修改密码"

安全功能提供：
- 查看登录设备列表
- 一键清除所有设备登录
- 登录历史记录
- 安全日志查询
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Token生命周期：
   从生成、下发、使用、刷新到失效的完整过程

🔸 安全存储：
   客户端用HttpOnly Cookie，服务端存哈希值

🔸 HTTPS强制：  
   Token必须在加密通道中传输，禁止HTTP

🔸 定期轮换：
   Access Token短期，Refresh Token长期但要轮换

🔸 撤销机制：
   黑名单、版本号等方式实现Token失效

🔸 最小权限：
   Token只包含必需的Scope，不给多余权限
```

### 9.2 关键安全原则


**🎯 Token安全三要素**

```
1. 保密性 (Confidentiality)
   → HTTPS传输
   → 安全存储
   → 不记录日志

2. 完整性 (Integrity)
   → 签名验证
   → 防篡改机制
   → 版本控制

3. 可用性 (Availability)  
   → 合理过期时间
   → 自动刷新机制
   → 撤销和恢复
```

**🛡️ 防护措施总结**

| 威胁类型 | **防护措施** | **优先级** |
|---------|------------|-----------|
| **Token泄露** | HTTPS + 安全存储 + 短期有效 | 🔥高 |
| **中间人攻击** | HTTPS + 证书绑定 | 🔥高 |
| **XSS攻击** | HttpOnly Cookie + CSP | 🔥高 |
| **Token滥用** | 最小权限 + 撤销机制 | ⚠️中 |
| **重放攻击** | 时间戳 + 一次性Token | ⚠️中 |

### 9.3 实践检查清单


**✅ 上线前必查项目**

```
Token配置检查：
□ Access Token有效期 ≤ 1小时
□ Refresh Token有效期合理
□ Token包含必要的安全字段
□ Scope设计遵循最小权限

传输安全检查：
□ 强制HTTPS，禁止HTTP
□ Token在请求头中传输
□ 设置了HSTS头
□ 配置了SameSite Cookie

存储安全检查：  
□ 服务端只存Token哈希值
□ 客户端使用安全存储方式
□ 敏感Token不在日志中出现
□ 过期Token自动清理

撤销机制检查：
□ 实现了黑名单或版本控制
□ 登出能立即撤销Token
□ 密码修改会撤销所有Token
□ 提供了紧急撤销功能

监控告警检查：
□ Token使用异常告警
□ 验证失败率监控  
□ 异地登录提醒
□ 安全事件日志记录
```

### 9.4 常见错误及纠正


```
❌ 常见错误1：Token永不过期
问题：安全风险极大
纠正：必须设置合理的过期时间

❌ 常见错误2：在URL中传输Token  
问题：Token泄露到日志和历史记录
纠正：使用请求头传输

❌ 常见错误3：明文存储Token
问题：数据库泄露即Token泄露
纠正：只存储Token的哈希值

❌ 常见错误4：不验证Token权限
问题：越权访问，安全漏洞
纠正：每次请求都检查Scope

❌ 常见错误5：忘记实现撤销
问题：用户登出后Token仍然有效
纠正：实现黑名单或版本控制机制
```

**🎓 新手学习路径**

```
学习顺序建议：

第1步：理解基础概念
- Token是什么
- 为什么需要Token
- Token的生命周期

第2步：掌握安全存储  
- 不同环境的存储方案
- HTTPS的重要性
- 常见安全问题

第3步：实践Token管理
- 实现Token刷新
- 配置过期时间
- 搭建验证逻辑

第4步：完善安全机制
- 实现撤销功能
- 配置最小权限
- 添加监控告警

第5步：持续优化
- 分析安全日志
- 优化用户体验
- 跟进安全标准
```

**核心记忆口诀**：
```
Token安全六字诀：
存（安全存储）
传（HTTPS传输）
换（定期轮换）
销（及时撤销）
限（最小权限）
测（监控检测）
```