---
title: 2、OAuth2.0四大角色
---
## 📚 目录

1. [OAuth2.0是什么](#1-OAuth2.0是什么)
2. [四大角色概述](#2-四大角色概述)
3. [Resource Owner资源拥有者](#3-Resource-Owner资源拥有者)
4. [Client客户端](#4-Client客户端)
5. [Authorization Server授权服务器](#5-Authorization-Server授权服务器)
6. [Resource Server资源服务器](#6-Resource-Server资源服务器)
7. [四大角色交互关系](#7-四大角色交互关系)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔐 OAuth2.0是什么


### 1.1 通俗理解OAuth2.0


想象一个生活场景：

```
你去酒店住宿：
🏨 酒店前台 = 授权服务器
🔑 房卡 = 访问令牌(Token)
🚪 房间 = 受保护的资源
👤 你 = 资源拥有者

过程：
1. 你（资源拥有者）在前台登记身份
2. 前台（授权服务器）验证你的身份后给你房卡（令牌）
3. 你用房卡打开房门（访问资源）
4. 房间门禁系统（资源服务器）验证房卡有效性

核心思想：不是直接给你房间钥匙，而是给你一张有时效的房卡！
```

### 1.2 OAuth2.0的核心作用


**OAuth2.0是一个授权框架**，解决的核心问题：

> 💡 **如何让第三方应用在不获取用户密码的情况下，访问用户的受保护资源？**

**传统方式的问题**：
```
❌ 把用户名密码直接给第三方应用
   - 密码泄露风险高
   - 无法控制访问权限
   - 无法撤销授权

✅ OAuth2.0的解决方案
   - 使用临时令牌代替密码
   - 可以限制访问范围
   - 可以随时撤销授权
```

---

## 2. 👥 四大角色概述


### 2.1 角色全景图


```
完整的OAuth2.0授权流程：

👤 Resource Owner          📱 Client
   (资源拥有者)              (客户端应用)
        |                       |
        |   1.授权请求           |
        |<---------------------|
        |   2.同意授权           |
        |--------------------->|
                                |
                                ↓
                          🏛️ Authorization Server
                             (授权服务器)
                                |
                                | 3.验证并颁发令牌
                                |
                                ↓
                          📱 Client获得Token
                                |
                                | 4.使用Token访问资源
                                ↓
                          🗄️ Resource Server
                             (资源服务器)
                                |
                                | 5.验证Token并返回数据
                                ↓
                          📱 Client获得资源
```

### 2.2 四大角色简表


| 角色 | 英文名称 | 通俗比喻 | 核心职责 |
|------|---------|---------|---------|
| 👤 **资源拥有者** | `Resource Owner` | 房主 | 决定是否授权访问自己的资源 |
| 📱 **客户端** | `Client` | 访客 | 代表用户请求访问资源 |
| 🏛️ **授权服务器** | `Authorization Server` | 门卫/前台 | 验证身份并颁发通行证 |
| 🗄️ **资源服务器** | `Resource Server` | 保险柜 | 存储资源并验证通行证 |

---

## 3. 👤 Resource Owner（资源拥有者）


### 3.1 资源拥有者是谁


**定义**：拥有受保护资源的实体，通常是**最终用户**

**通俗理解**：
```
你的微信账号里的数据 → 你是资源拥有者
你的照片、朋友圈、聊天记录 → 这些都是你的资源

举例：
- 在微信读书使用微信登录时，你就是资源拥有者
- 在美团使用支付宝支付时，你就是资源拥有者
- 在第三方应用查看你的GitHub仓库时，你就是资源拥有者
```

### 3.2 资源拥有者的核心职责


**🔸 职责1：决定是否授权**
```
场景：某个应用想访问你的微信头像和昵称

你的决策：
✅ 同意授权 → 应用可以获取你的头像和昵称
❌ 拒绝授权 → 应用无法获取任何信息
```

**🔸 职责2：控制授权范围**
```
不是所有权限都要给：

示例（微信授权）：
□ 获取你的昵称和头像          ← 可以同意
□ 获取你的手机号              ← 可以同意
□ 查看你的朋友圈              ← 可以拒绝
□ 发送消息给你的好友          ← 可以拒绝

你可以精确控制第三方应用能访问什么！
```

**🔸 职责3：撤销授权**
```
授权后反悔了？没问题！

操作路径（以微信为例）：
我 → 设置 → 隐私 → 授权管理 → 选择应用 → 删除

结果：
- 应用之前获取的Token立即失效
- 应用无法再访问你的数据
```

### 3.3 实际案例理解


**案例：使用QQ登录王者荣耀**

```
场景分析：
👤 你 = Resource Owner（资源拥有者）
🎮 王者荣耀 = Client（客户端）
🏛️ QQ登录系统 = Authorization Server（授权服务器）
🗄️ QQ用户信息系统 = Resource Server（资源服务器）

流程：
1. 你打开王者荣耀，选择"QQ登录"
2. 跳转到QQ授权页面，显示：
   "王者荣耀想获取你的QQ昵称、头像"
3. 你点击"同意"（这就是资源拥有者的授权行为）
4. QQ登录系统验证你的身份后，给王者荣耀颁发Token
5. 王者荣耀用Token获取你的昵称和头像
```

> ⚠️ **注意**：你只是授权访问昵称和头像，王者荣耀**拿不到你的QQ密码**！

---

## 4. 📱 Client（客户端）


### 4.1 客户端是什么


**定义**：代表资源拥有者去访问受保护资源的应用程序

**通俗理解**：
```
客户端就是那些需要你授权才能工作的第三方应用

常见客户端：
📱 手机APP：微信读书、美团、饿了么
💻 网页应用：石墨文档、语雀、Notion
🖥️ 桌面应用：VS Code、Postman
```

### 4.2 客户端的核心职责


**🔸 职责1：引导用户授权**
```
客户端的操作步骤：

1. 检测用户未登录
2. 弹出授权选择界面（如"使用微信登录"）
3. 跳转到授权服务器的授权页面
4. 等待用户同意或拒绝
```

**🔸 职责2：获取并保存Token**
```
授权成功后：

1. 从授权服务器接收Token
   Token示例：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   
2. 安全保存Token
   - 移动端：存储在加密的本地存储
   - 网页端：存储在HttpOnly Cookie或LocalStorage
   
3. 在每次请求时携带Token
   请求头示例：
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**🔸 职责3：使用Token访问资源**
```
客户端发起API请求：

GET /api/user/profile
Headers:
  Authorization: Bearer [Token]

资源服务器验证Token后返回数据：
{
  "nickname": "张三",
  "avatar": "https://avatar.example.com/123.jpg"
}
```

### 4.3 客户端的类型


**按保密能力分类**：

| 类型 | 特点 | 示例 | Token存储 |
|------|------|------|-----------|
| **机密客户端** | `可以安全保存密钥` | 服务端应用 | 服务器内存/数据库 |
| **公开客户端** | `无法保护密钥` | 手机APP、前端应用 | 本地存储（加密） |

**实际案例对比**：

```
🔒 机密客户端示例（后端服务）：
企业内部管理系统
- 运行在服务器上
- 可以安全保存Client Secret
- Token存储在服务器端Session

🔓 公开客户端示例（手机APP）：
美团APP
- 运行在用户手机上
- 代码可能被反编译，无法保护密钥
- 使用PKCE等增强安全措施
```

### 4.4 客户端注册信息


**客户端需要在授权服务器注册**，获取身份凭证：

```
注册信息示例：

Client ID（客户端标识）：
app_wxreading_123456
- 公开的，用于标识应用

Client Secret（客户端密钥）：
sk_live_51H9xK2eZvKYlo2C...
- 机密的，只有机密客户端才有
- 用于证明客户端身份

Redirect URI（回调地址）：
https://app.example.com/oauth/callback
- 授权成功后跳转的地址
- 必须预先注册，防止钓鱼攻击
```

---

## 5. 🏛️ Authorization Server（授权服务器）


### 5.1 授权服务器是什么


**定义**：负责验证资源拥有者身份并颁发访问令牌的服务器

**通俗理解**：
```
授权服务器就像机场的安检和登机口：

1. 验证你的身份（检查身份证）
2. 确认你有权限（检查机票）
3. 发放登机牌（颁发Token）
4. 记录登机信息（日志审计）

常见的授权服务器：
- 微信开放平台
- QQ互联
- 支付宝开放平台
- GitHub OAuth
- Google OAuth
```

### 5.2 授权服务器的核心职责


**🔸 职责1：用户身份认证**
```
验证资源拥有者的身份：

方式1：账号密码登录
用户名：zhangsan@example.com
密码：******
→ 验证成功 ✅

方式2：扫码登录
打开微信 → 扫描二维码 → 确认登录
→ 验证成功 ✅

方式3：生物识别
指纹识别 / 人脸识别
→ 验证成功 ✅
```

**🔸 职责2：授权确认**
```
向用户展示授权页面：

┌─────────────────────────────┐
│   应用想获取你的以下信息：    │
│                             │
│   ✓ 你的昵称和头像          │
│   ✓ 你的手机号              │
│                             │
│   [ 同意 ]      [ 拒绝 ]    │
└─────────────────────────────┘

用户点击"同意" → 生成授权码
用户点击"拒绝" → 返回错误信息
```

**🔸 职责3：颁发Token**
```
授权码模式的Token颁发流程：

1. 客户端用授权码exchange Token
   POST /oauth/token
   {
     "grant_type": "authorization_code",
     "code": "SplxlOBeZQQYbYS6WxSbIA",
     "client_id": "app_123",
     "client_secret": "secret_456"
   }

2. 授权服务器验证并返回Token
   {
     "access_token": "eyJhbGci...",
     "token_type": "Bearer",
     "expires_in": 3600,
     "refresh_token": "tGzv3JOkF0XG5Qx2TlKW"
   }
```

**🔸 职责4：Token管理**
```
Token生命周期管理：

生成Token：
- 加密用户身份信息
- 设置过期时间
- 绑定访问范围（scope）

验证Token：
- 检查签名是否有效
- 检查是否过期
- 检查是否被撤销

刷新Token：
- 接收Refresh Token
- 验证有效性
- 颁发新的Access Token
```

### 5.3 授权服务器的关键端点


**OAuth2.0标准端点**：

| 端点 | 路径示例 | 作用 |
|------|---------|------|
| **授权端点** | `/oauth/authorize` | 用户授权，返回授权码 |
| **令牌端点** | `/oauth/token` | 用授权码换取Token |
| **撤销端点** | `/oauth/revoke` | 撤销Token |
| **验证端点** | `/oauth/check_token` | 验证Token有效性 |

**实际请求示例**：

```
1. 授权请求（浏览器跳转）：
https://oauth.example.com/authorize?
  response_type=code&
  client_id=app_123&
  redirect_uri=https://app.com/callback&
  scope=read_profile&
  state=xyz

2. 令牌请求（后端调用）：
POST https://oauth.example.com/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=SplxlOBeZQQYbYS6WxSbIA&
client_id=app_123&
client_secret=secret_456
```

### 5.4 常见授权服务器产品


**开源实现**：
- **Spring Authorization Server**（Java）
- **Keycloak**（Java，功能强大）
- **ORY Hydra**（Go，云原生）

**云服务**：
- **Auth0**（商业，易用）
- **AWS Cognito**（AWS生态）
- **Azure AD**（微软生态）

---

## 6. 🗄️ Resource Server（资源服务器）


### 6.1 资源服务器是什么


**定义**：托管受保护资源的服务器，验证Token并提供资源访问

**通俗理解**：
```
资源服务器就像银行的保险柜管理系统：

🏦 银行保险柜 = 资源服务器
💎 保险柜里的贵重物品 = 受保护的资源
🎫 提取凭证 = Access Token
👮 保险柜管理员 = Token验证逻辑

流程：
1. 客户拿着提取凭证来取东西（携带Token）
2. 管理员验证凭证真伪（验证Token签名）
3. 检查凭证是否过期（检查Token有效期）
4. 确认凭证权限范围（检查Token的scope）
5. 提供对应的物品（返回资源数据）
```

### 6.2 资源服务器的核心职责


**🔸 职责1：Token验证**
```
每个API请求都要验证Token：

验证步骤：
1. 提取Token
   从请求头获取：Authorization: Bearer [Token]
   
2. 验证签名
   使用公钥验证JWT签名
   
3. 检查有效期
   if (token.exp < now()) {
     return 401 Unauthorized;
   }
   
4. 检查权限范围
   if (!token.scope.includes('read_profile')) {
     return 403 Forbidden;
   }
```

**🔸 职责2：权限控制**
```
根据Token的scope控制访问：

Token中的scope：read_profile, read_posts

API权限检查：
GET /api/user/profile       ✅ 允许（read_profile）
GET /api/user/posts         ✅ 允许（read_posts）
POST /api/user/posts        ❌ 拒绝（需要write_posts）
DELETE /api/user/account    ❌ 拒绝（需要delete_account）
```

**🔸 职责3：返回资源数据**
```
验证通过后返回资源：

请求：
GET /api/user/profile
Authorization: Bearer eyJhbGci...

响应：
HTTP/1.1 200 OK
Content-Type: application/json

{
  "user_id": "123456",
  "nickname": "张三",
  "avatar": "https://cdn.example.com/avatar/123.jpg",
  "email": "zhangsan@example.com"
}
```

### 6.3 资源服务器实现示例


**Spring Security实现**：

```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    
    @GetMapping("/profile")
    // 只有携带有效Token的请求才能访问
    public ResponseEntity<UserProfile> getProfile(
        @AuthenticationPrincipal OAuth2User user
    ) {
        // Token验证由Spring Security自动完成
        // 获取Token中的用户信息
        String userId = user.getAttribute("sub");
        
        // 查询并返回用户资料
        UserProfile profile = userService.getProfile(userId);
        return ResponseEntity.ok(profile);
    }
    
    @GetMapping("/posts")
    @PreAuthorize("hasAuthority('SCOPE_read_posts')")
    // 需要read_posts权限才能访问
    public ResponseEntity<List<Post>> getPosts(
        @AuthenticationPrincipal OAuth2User user
    ) {
        String userId = user.getAttribute("sub");
        List<Post> posts = postService.getUserPosts(userId);
        return ResponseEntity.ok(posts);
    }
}
```

### 6.4 授权服务器 vs 资源服务器


**两者的区别**：

```
可以是同一个服务器，也可以分离：

方案1：合并部署（小型应用）
┌────────────────────────────┐
│  同一个服务器              │
│  ┌──────────────────────┐ │
│  │  授权服务器          │ │
│  │  /oauth/authorize    │ │
│  │  /oauth/token        │ │
│  └──────────────────────┘ │
│  ┌──────────────────────┐ │
│  │  资源服务器          │ │
│  │  /api/user/*         │ │
│  │  /api/posts/*        │ │
│  └──────────────────────┘ │
└────────────────────────────┘

方案2：分离部署（大型应用）
┌─────────────────┐      ┌─────────────────┐
│  授权服务器     │      │  资源服务器A    │
│  auth.api.com   │      │  user.api.com   │
│                 │      │  /api/user/*    │
│  颁发Token      │─────→│  验证Token      │
└─────────────────┘      └─────────────────┘
                         ┌─────────────────┐
                         │  资源服务器B    │
                         │  post.api.com   │
                         │  /api/posts/*   │
                    ────→│  验证Token      │
                         └─────────────────┘
```

| 对比维度 | 授权服务器 | 资源服务器 |
|---------|-----------|-----------|
| **核心功能** | 颁发和管理Token | 验证Token并提供资源 |
| **典型端点** | `/oauth/authorize`<br>`/oauth/token` | `/api/user/profile`<br>`/api/posts` |
| **主要职责** | 用户认证<br>授权确认<br>Token生命周期管理 | Token验证<br>权限检查<br>资源访问控制 |

---

## 7. 🔄 四大角色交互关系


### 7.1 完整交互流程


**授权码模式（最常用）的完整流程**：

```
第一步：用户发起登录
👤 用户                    📱 客户端
  |                          |
  |  1. 点击"使用微信登录"    |
  |------------------------->|
  
第二步：跳转到授权页面  
📱 客户端                  🏛️ 授权服务器
  |                          |
  |  2. 重定向到授权页面      |
  |------------------------->|
  |  /oauth/authorize?       |
  |  client_id=xxx&          |
  |  scope=read_profile      |
  
第三步：用户同意授权
🏛️ 授权服务器             👤 用户
  |                          |
  |  3. 显示授权确认页面      |
  |------------------------->|
  |  "是否允许应用访问你的    |
  |   昵称和头像？"          |
  |                          |
  |  4. 用户点击"同意"        |
  |<-------------------------|

第四步：返回授权码
🏛️ 授权服务器             📱 客户端
  |                          |
  |  5. 重定向回客户端        |
  |------------------------->|
  |  /callback?code=abc123   |
  
第五步：用授权码换Token
📱 客户端                  🏛️ 授权服务器
  |                          |
  |  6. 请求Token            |
  |------------------------->|
  |  POST /oauth/token       |
  |  code=abc123             |
  |  client_secret=***       |
  |                          |
  |  7. 返回Token            |
  |<-------------------------|
  |  access_token=xyz789     |
  
第六步：访问受保护资源
📱 客户端                  🗄️ 资源服务器
  |                          |
  |  8. 请求用户信息          |
  |------------------------->|
  |  GET /api/user/profile   |
  |  Authorization: Bearer   |
  |  xyz789                  |
  |                          |
  |  9. 验证Token并返回数据   |
  |<-------------------------|
  |  {"nickname":"张三"}     |
```

### 7.2 时序图详解


**关键交互点分析**：

```
交互点1：客户端引导授权
- 客户端检测到用户未登录
- 构造授权URL跳转到授权服务器
- 携带参数：client_id, redirect_uri, scope

交互点2：授权服务器认证用户
- 检查用户是否已登录
- 未登录则显示登录页面
- 已登录则直接显示授权页面

交互点3：用户授权决策
- 用户查看应用请求的权限
- 选择同意或拒绝
- 同意则生成授权码

交互点4：授权码换Token
- 客户端后端用授权码请求Token
- 必须携带client_secret（机密客户端）
- 授权服务器验证后返回Token

交互点5：资源访问
- 客户端携带Token访问资源
- 资源服务器验证Token有效性
- 验证通过返回资源数据
```

### 7.3 角色协作要点


**🔸 信任关系**：

```
信任链条：
👤 用户信任授权服务器
   ↓
   用户通过授权服务器登录，相信它不会泄露密码

🏛️ 授权服务器信任客户端（部分信任）
   ↓
   通过client_id和client_secret验证客户端身份

📱 客户端信任授权服务器
   ↓
   相信授权服务器颁发的Token是有效的

🗄️ 资源服务器信任授权服务器
   ↓
   相信授权服务器签发的Token是可信的
```

**🔸 职责边界**：

| 角色 | 负责的事 | 不负责的事 |
|------|---------|-----------|
| **资源拥有者** | 授权决策<br>权限控制 | Token生成<br>Token验证 |
| **客户端** | 引导授权流程<br>保存Token<br>携带Token访问资源 | 验证用户身份<br>生成Token |
| **授权服务器** | 用户认证<br>生成Token<br>管理Token | 存储资源数据<br>返回业务数据 |
| **资源服务器** | 验证Token<br>返回资源 | 用户认证<br>生成Token |

---

## 8. 📋 核心要点总结


### 8.1 四大角色速记


```
记忆口诀：
👤 主人决定给不给（资源拥有者决定授权）
📱 客人代劳来索取（客户端代表用户请求）
🏛️ 门卫验明发令牌（授权服务器验证并颁发Token）
🗄️ 仓库核验再放行（资源服务器验证Token再给数据）
```

### 8.2 关键概念对照


**生活场景类比**：

| OAuth2.0角色 | 生活场景 | 实际例子 |
|-------------|---------|----------|
| 资源拥有者 | 房屋主人 | 使用微信登录的你 |
| 客户端 | 访客 | 美团APP、微信读书 |
| 授权服务器 | 小区门卫 | 微信开放平台 |
| 资源服务器 | 房间保险柜 | 微信用户信息系统 |

### 8.3 常见误区澄清


**❌ 误区1：客户端可以访问用户密码**
```
错误理解：第三方应用需要你的微信密码才能登录

正确理解：
- 客户端永远拿不到用户密码
- 只能拿到授权服务器颁发的Token
- Token是临时的、可撤销的、权限受限的
```

**❌ 误区2：授权服务器和资源服务器是同一个**
```
错误理解：它们必须是同一台服务器

正确理解：
- 可以是同一个（小型应用）
- 也可以分离（大型微服务架构）
- 关键是资源服务器要信任授权服务器的Token
```

**❌ 误区3：Token可以访问所有资源**
```
错误理解：拿到Token就能访问用户的所有数据

正确理解：
- Token包含scope（权限范围）
- 只能访问授权范围内的资源
- 超出范围会被资源服务器拒绝
```

### 8.4 实际应用检查清单


**实现OAuth2.0时的检查项**：

```
☑️ 资源拥有者侧
  - [ ] 授权页面是否清晰展示权限范围
  - [ ] 是否提供授权管理功能（查看和撤销）
  - [ ] 是否支持拒绝授权

☑️ 客户端侧
  - [ ] 是否在授权服务器正确注册
  - [ ] 是否安全保存client_secret（机密客户端）
  - [ ] Token是否安全存储
  - [ ] 是否正确处理授权失败

☑️ 授权服务器侧  
  - [ ] 用户认证是否安全
  - [ ] Token生成是否随机且不可预测
  - [ ] 是否记录审计日志
  - [ ] 是否支持Token撤销

☑️ 资源服务器侧
  - [ ] 是否验证Token签名
  - [ ] 是否检查Token过期时间
  - [ ] 是否检查Token的scope
  - [ ] 是否防范Token重放攻击
```

### 8.5 学习建议


**🎯 新手学习路径**：

1. **理解角色关系**（本文）
   - 掌握四大角色的定义和职责
   - 理解角色之间的交互流程

2. **学习授权模式**（下一步）
   - 授权码模式
   - 简化模式
   - 密码模式
   - 客户端模式

3. **实践项目**
   - 使用Spring Security OAuth2
   - 接入第三方登录（微信、GitHub）
   - 自己实现一个简单的授权服务器

> 💡 **核心理解**：OAuth2.0的本质是**用Token代替密码**，四大角色各司其职，共同保障授权流程的安全性和灵活性。