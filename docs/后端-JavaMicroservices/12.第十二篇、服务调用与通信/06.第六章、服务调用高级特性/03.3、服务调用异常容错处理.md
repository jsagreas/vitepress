---
title: 3、服务调用异常容错处理
---
## 📚 目录

1. [微服务异常处理概述](#1-微服务异常处理概述)
2. [异常分类与处理策略](#2-异常分类与处理策略)
3. [熔断机制实现](#3-熔断机制实现)
4. [服务降级策略设计](#4-服务降级策略设计)
5. [快速失败机制](#5-快速失败机制)
6. [限流保护机制](#6-限流保护机制)
7. [异常恢复策略](#7-异常恢复策略)
8. [异常监控告警](#8-异常监控告警)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 微服务异常处理概述


### 1.1 为什么微服务需要异常处理


**理解微服务的脆弱性**：

```
传统单体应用：                    微服务架构：
┌─────────────┐                  ┌────┐  ┌────┐  ┌────┐
│             │                  │服务A│──│服务B│──│服务C│
│  单体应用    │                  └────┘  └────┘  └────┘
│             │                     │       │       │
│  一损俱损    │                     ×       ×       ×
└─────────────┘                  任何一个环节出错都可能影响整体
```

> 💡 **核心理念**：微服务就像多米诺骨牌，一个服务出问题可能引发连锁反应。异常处理就是在每个骨牌下加"缓冲垫"，防止全盘崩溃。

**微服务调用的三大风险**：

🔸 **网络不可靠**
- 网络延迟、超时
- 网络抖动、丢包
- 服务器宕机

🔸 **服务不稳定**
- 服务过载、响应慢
- 代码bug、数据异常
- 依赖服务故障

🔸 **资源有限性**
- 连接池耗尽
- 内存溢出
- CPU使用率过高

### 1.2 异常处理的核心目标


**保障系统稳定性的四大目标**：

| 目标 | 说明 | 实现方式 |
|------|------|----------|
| 🛡️ **隔离故障** | 防止单个服务故障扩散 | 熔断、降级 |
| ⚡ **快速响应** | 避免用户长时间等待 | 快速失败、超时控制 |
| 📊 **保护资源** | 防止系统资源耗尽 | 限流、资源隔离 |
| 🔄 **自动恢复** | 故障后自动恢复正常 | 重试、健康检查 |

---

## 2. 📋 异常分类与处理策略


### 2.1 异常的三大类型


**理解异常分类的本质**：

```
微服务调用异常分类：

┌────────────────────────────────────┐
│ 1. 业务异常（可预期）                │
│    - 用户输入错误                    │
│    - 业务规则不满足                  │
│    - 数据不存在                      │
│    → 处理方式：返回错误信息给用户      │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 2. 系统异常（可恢复）                │
│    - 网络超时                        │
│    - 服务暂时不可用                  │
│    - 数据库连接失败                  │
│    → 处理方式：重试、熔断、降级        │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 3. 致命异常（不可恢复）              │
│    - 程序bug导致崩溃                 │
│    - 内存溢出                        │
│    - 配置严重错误                    │
│    → 处理方式：快速失败、告警、记录    │
└────────────────────────────────────┘
```

### 2.2 异常处理决策树


**如何判断使用哪种处理方式**：

```
异常发生
    |
    ├─ 是业务异常？
    │      ├─ 是 → 返回错误码，提示用户
    │      └─ 否 → 继续判断
    |
    ├─ 是否可重试？
    │      ├─ 是 → 执行重试策略
    │      │      └─ 重试失败 → 触发降级
    │      └─ 否 → 继续判断
    |
    ├─ 是否影响核心流程？
    │      ├─ 是 → 熔断保护
    │      │      └─ 返回降级响应
    │      └─ 否 → 记录日志，继续执行
    |
    └─ 是否需要告警？
           └─ 是 → 发送监控告警
```

### 2.3 常见异常处理策略对比


| 异常类型 | 处理策略 | 适用场景 | 用户体验 |
|---------|---------|---------|---------|
| **超时异常** | 快速失败 + 降级 | 调用第三方服务 | 返回默认数据 |
| **连接异常** | 重试 + 熔断 | 网络不稳定 | 短暂等待或降级 |
| **业务异常** | 直接返回 | 参数校验失败 | 提示错误信息 |
| **限流异常** | 拒绝服务 | 系统过载保护 | 提示稍后重试 |
| **未知异常** | 降级 + 告警 | 程序bug | 返回兜底数据 |

---

## 3. 🔌 熔断机制实现


### 3.1 什么是熔断机制


**用生活案例理解熔断**：

> 🏠 **家用电路的保险丝**：
> - 正常情况：电流畅通，设备正常工作
> - 电流过载：保险丝自动断开，保护整个电路
> - 问题解决：更换保险丝，恢复供电
>
> 微服务熔断也是同样道理！

**熔断器的三种状态**：

```
熔断器状态转换图：

     请求成功率正常
  ┌──────────────────┐
  │                  ↓
┌─────────┐      ┌─────────┐
│ 关闭状态 │      │ 开启状态 │
│ (CLOSED) │──×──→│ (OPEN)   │
└─────────┘      └─────────┘
      ↑               │
      │         等待时间后
      │               ↓
      │         ┌─────────┐
      └─────────│ 半开状态 │
    成功率恢复   │(HALF_OPEN)│
                └─────────┘

🟢 关闭状态：正常放行所有请求
🔴 开启状态：直接拒绝所有请求，返回降级响应
🟡 半开状态：尝试少量请求，检测是否恢复
```

### 3.2 熔断触发条件


**什么时候会触发熔断**：

🔸 **错误率阈值**
- 统计窗口内错误率 > 50%
- 示例：最近10秒内，100次请求有60次失败

🔸 **慢调用阈值**
- 响应时间 > 设定值的请求占比过高
- 示例：最近20次请求中，15次超过3秒

🔸 **异常数量阈值**
- 统计窗口内异常次数达到上限
- 示例：1分钟内发生20次异常

### 3.3 熔断器实现示例


**使用Resilience4j实现熔断**：

```java
// 1. 配置熔断器参数
CircuitBreakerConfig config = CircuitBreakerConfig.custom()
    .failureRateThreshold(50)              // 失败率50%触发熔断
    .slowCallRateThreshold(50)             // 慢调用50%触发熔断
    .slowCallDurationThreshold(Duration.ofSeconds(3))  // 3秒算慢调用
    .waitDurationInOpenState(Duration.ofSeconds(60))   // 熔断后60秒尝试恢复
    .slidingWindowSize(10)                 // 统计最近10次请求
    .build();

// 2. 创建熔断器
CircuitBreaker circuitBreaker = CircuitBreaker.of("orderService", config);

// 3. 使用熔断器保护调用
String result = circuitBreaker.executeSupplier(() -> {
    // 调用远程服务
    return orderService.getOrder(orderId);
});
```

**关键配置参数说明**：

| 参数 | 含义 | 推荐值 |
|------|------|--------|
| `failureRateThreshold` | 失败率阈值（%） | 50 |
| `slowCallRateThreshold` | 慢调用率阈值（%） | 50 |
| `slowCallDurationThreshold` | 慢调用时间 | 3秒 |
| `waitDurationInOpenState` | 熔断恢复等待时间 | 60秒 |
| `slidingWindowSize` | 滑动窗口大小 | 10-100 |

### 3.4 熔断降级配合使用


**熔断触发后返回什么**：

```java
String result = circuitBreaker.executeSupplier(() -> {
    return orderService.getOrder(orderId);
});

// 熔断开启时，自动执行降级逻辑
String fallbackResult = circuitBreaker.executeSupplier(
    () -> orderService.getOrder(orderId),
    (throwable) -> {
        // 降级响应
        return "订单服务暂时不可用，请稍后重试";
    }
);
```

> ⚠️ **注意**：熔断器只负责"断开开关"，具体返回什么内容由降级策略决定。

---

## 4. 📉 服务降级策略设计


### 4.1 什么是服务降级


**用购物网站理解降级**：

```
正常情况：                     降级情况：
用户访问商品详情               用户访问商品详情
    ↓                             ↓
调用推荐服务                   推荐服务故障
    ↓                             ↓
显示个性化推荐              显示热门商品（降级数据）

核心思想：保证核心功能，牺牲次要功能
```

> 💡 **降级的本质**：服务出问题时，返回"凑合能用"的备用数据，而不是直接报错。

### 4.2 降级的四种策略


**根据重要性选择降级方式**：

🔸 **默认值降级**
```
场景：用户积分查询失败
降级响应：返回积分 = 0
影响：用户看不到积分，但不影响购物
```

🔸 **缓存降级**
```
场景：商品详情服务超时
降级响应：返回缓存中的商品信息
影响：可能看到过时数据，但总比没有好
```

🔸 **Mock数据降级**
```
场景：推荐系统崩溃
降级响应：返回固定的热门商品列表
影响：推荐不够个性化，但功能可用
```

🔸 **功能降级**
```
场景：评论服务挂了
降级响应：暂时隐藏评论区，只显示商品信息
影响：用户体验下降，但核心功能正常
```

### 4.3 降级策略设计原则


**如何设计合理的降级方案**：

| 原则 | 说明 | 示例 |
|------|------|------|
| **保核心弃边缘** | 保证主要功能，放弃次要功能 | 保证下单，放弃推荐 |
| **快速响应** | 降级数据立即返回，不再等待 | 缓存数据 < 10ms |
| **用户无感** | 降级对用户影响最小 | 用默认头像代替个性头像 |
| **可配置** | 降级策略可动态调整 | 通过配置中心开关降级 |

### 4.4 降级实现示例


**Spring Cloud实现降级**：

```java
@Service
public class OrderService {
    
    @Autowired
    private UserServiceClient userServiceClient;
    
    // 带降级的服务调用
    @HystrixCommand(fallbackMethod = "getUserInfoFallback")
    public UserInfo getUserInfo(Long userId) {
        return userServiceClient.getUserInfo(userId);
    }
    
    // 降级方法：返回默认用户信息
    public UserInfo getUserInfoFallback(Long userId) {
        UserInfo defaultUser = new UserInfo();
        defaultUser.setId(userId);
        defaultUser.setName("用户" + userId);  // 默认昵称
        defaultUser.setAvatar("default.jpg");  // 默认头像
        return defaultUser;
    }
}
```

> 📝 **降级方法命名规范**：原方法名 + `Fallback` 后缀

---

## 5. ⚡ 快速失败机制


### 5.1 为什么需要快速失败


**对比等待和快速失败**：

```
慢失败（传统方式）：
用户请求 → 等待30秒 → 超时错误
    └─ 用户：这个网站怎么这么慢？

快速失败（推荐方式）：
用户请求 → 检测到故障 → 立即返回降级数据（0.1秒）
    └─ 用户：还能用，就是功能少了点
```

> 💡 **快速失败的价值**：宁可立即告诉用户"不行"，也不让用户傻等。

### 5.2 快速失败的三种场景


**何时应该快速失败**：

🔸 **熔断器开启时**
```
熔断器状态：OPEN
    ↓
新请求到来
    ↓
直接拒绝（不调用远程服务）
    ↓
立即返回降级响应
```

🔸 **资源耗尽时**
```
检测到：
- 线程池满了
- 连接池满了
- 内存不足

立即拒绝新请求，保护系统
```

🔸 **服务已知不可用**
```
健康检查失败
    ↓
标记服务为不可用
    ↓
快速失败，不尝试调用
```

### 5.3 快速失败的实现要点


**实现快速失败的关键**：

| 关键点 | 说明 | 实现方式 |
|--------|------|----------|
| **超时设置** | 设置合理的超时时间 | 连接超时1秒，读取超时3秒 |
| **失败检测** | 快速检测失败 | 熔断器、健康检查 |
| **立即响应** | 不等待，立即返回 | 降级方法、缓存数据 |
| **资源保护** | 防止资源耗尽 | 线程池隔离、限流 |

**超时配置示例**：

```java
// RestTemplate配置超时
RestTemplate restTemplate = new RestTemplateBuilder()
    .setConnectTimeout(Duration.ofSeconds(1))  // 连接超时1秒
    .setReadTimeout(Duration.ofSeconds(3))     // 读取超时3秒
    .build();

// Feign配置超时
feign:
  client:
    config:
      default:
        connectTimeout: 1000    # 连接超时1秒
        readTimeout: 3000       # 读取超时3秒
```

---

## 6. 🚦 限流保护机制


### 6.1 什么是限流


**用高速公路收费站理解限流**：

```
没有限流的系统：                   有限流的系统：
所有车辆一起挤进去                 按车道有序通过
    ↓                                  ↓
拥堵、事故、瘫痪                   流量可控、运行稳定

┌──────────┐                       ┌──────────┐
│ 请求洪流  │ ──×──→ 系统崩溃      │ 请求洪流  │ ──✓──→ 限流控制
└──────────┘                       └──────────┘              ↓
                                                        按优先级处理
```

> 💡 **限流的目的**：控制流量，防止系统过载，保证服务质量。

### 6.2 限流的三种算法


**常用限流算法对比**：

🔸 **固定窗口算法**
```
时间窗口：每秒最多100个请求

0秒────1秒────2秒────3秒
 ↓      ↓      ↓      ↓
100个   100个  100个  100个

缺点：边界突刺（0.9秒来100个，1.1秒又来100个）
```

🔸 **滑动窗口算法**
```
动态窗口：任意1秒内最多100个请求

0.5秒到1.5秒：计算这1秒内的请求数
1.0秒到2.0秒：计算这1秒内的请求数

优点：流量更平滑，无边界突刺问题
```

🔸 **令牌桶算法（推荐）**
```
令牌桶机制：
1. 以固定速率往桶里放令牌（如每秒100个）
2. 请求来了从桶里拿令牌
3. 拿到令牌→处理请求
4. 拿不到令牌→拒绝请求

优点：
- 允许一定程度的突发流量（桶的容量）
- 平滑限流，避免瞬时过载
```

### 6.3 限流实现示例


**使用Guava RateLimiter实现限流**：

```java
// 创建限流器：每秒允许10个请求
RateLimiter limiter = RateLimiter.create(10.0);

// 处理请求
public String handleRequest() {
    // 尝试获取令牌（等待最多1秒）
    if (limiter.tryAcquire(1, TimeUnit.SECONDS)) {
        // 获取到令牌，处理请求
        return orderService.createOrder();
    } else {
        // 未获取到令牌，拒绝请求
        return "系统繁忙，请稍后重试";
    }
}
```

**使用Sentinel实现限流**：

```java
@SentinelResource(value = "createOrder", 
                  blockHandler = "handleBlock")
public String createOrder() {
    return orderService.createOrder();
}

// 限流后的处理方法
public String handleBlock(BlockException e) {
    return "当前访问人数过多，请稍后重试";
}
```

**限流规则配置**：

```yaml
# Sentinel限流规则
spring:
  cloud:
    sentinel:
      flow:
        rules:
          - resource: createOrder
            grade: 1           # QPS模式
            count: 10          # 每秒10个请求
            strategy: 0        # 直接拒绝
```

### 6.4 多级限流策略


**系统级、服务级、接口级限流**：

```
限流层次结构：

┌─────────────────────────────┐
│ 系统级限流：QPS 10000        │  ← 整体保护
└─────────────────────────────┘
           ↓
┌─────────────────────────────┐
│ 服务级限流：订单服务 QPS 5000│  ← 服务保护
└─────────────────────────────┘
           ↓
┌─────────────────────────────┐
│ 接口级限流：                 │  ← 接口保护
│  - 创建订单：QPS 100         │
│  - 查询订单：QPS 500         │
└─────────────────────────────┘
```

| 限流级别 | 作用范围 | 限流值 | 适用场景 |
|---------|---------|--------|---------|
| **系统级** | 整个应用 | QPS 10000 | 保护服务器资源 |
| **服务级** | 单个服务 | QPS 5000 | 保护服务实例 |
| **接口级** | 具体接口 | QPS 100 | 保护重要接口 |
| **用户级** | 单个用户 | QPS 10 | 防止恶意刷单 |

---

## 7. 🔄 异常恢复策略


### 7.1 什么是异常恢复


**理解自动恢复机制**：

```
传统方式：                     自动恢复：
服务故障                       服务故障
    ↓                             ↓
人工介入                       自动检测
    ↓                             ↓
手动重启                       自动恢复
    ↓                             ↓
服务恢复                       服务恢复

自动恢复的价值：减少故障时间，降低人工成本
```

### 7.2 重试策略


**何时需要重试**：

🔸 **适合重试的场景**
- 网络抖动导致的临时失败
- 数据库死锁（立即重试可能成功）
- 第三方服务临时不可用

🔸 **不适合重试的场景**
- 业务逻辑错误（重试也不会成功）
- 参数校验失败（数据本身有问题）
- 权限不足（重试毫无意义）

**重试策略配置**：

```java
// Spring Retry实现
@Retryable(
    value = {TimeoutException.class},     // 超时异常才重试
    maxAttempts = 3,                      // 最多重试3次
    backoff = @Backoff(delay = 1000)      // 重试间隔1秒
)
public Order getOrder(Long orderId) {
    return orderService.getOrder(orderId);
}

// 重试失败后的兜底方法
@Recover
public Order recover(TimeoutException e, Long orderId) {
    // 重试3次都失败，执行降级逻辑
    return getOrderFromCache(orderId);
}
```

**重试策略对比**：

| 策略 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **固定间隔** | 每次重试间隔固定时间 | 简单 | 可能加剧系统压力 |
| **指数退避** | 重试间隔指数增长 | 给系统恢复时间 | 恢复时间可能较长 |
| **随机延迟** | 随机重试间隔 | 避免同时重试 | 不可预测 |

### 7.3 健康检查与自动恢复


**健康检查机制**：

```
定时健康检查流程：

每10秒执行一次
    ↓
调用健康检查接口
    ↓
判断服务状态
    ↓
┌─────────────────────┐
│ 健康   │  不健康      │
└─────────────────────┘
   ↓           ↓
保持可用   标记为不可用
              ↓
          移出服务列表
              ↓
          定期重新检查
              ↓
          恢复后加回
```

**健康检查实现**：

```java
@RestController
public class HealthCheckController {
    
    @GetMapping("/health")
    public HealthStatus checkHealth() {
        HealthStatus status = new HealthStatus();
        
        // 检查数据库连接
        if (!checkDatabase()) {
            status.setStatus("DOWN");
            status.addDetail("database", "unavailable");
            return status;
        }
        
        // 检查依赖服务
        if (!checkDependencies()) {
            status.setStatus("DOWN");
            status.addDetail("dependencies", "unavailable");
            return status;
        }
        
        status.setStatus("UP");
        return status;
    }
}
```

### 7.4 熔断器自动恢复


**熔断器的自愈机制**：

```
熔断器自动恢复流程：

熔断开启（OPEN）
    ↓
等待恢复时间（60秒）
    ↓
进入半开状态（HALF_OPEN）
    ↓
尝试少量请求（如10个）
    ↓
┌──────────────────────┐
│ 成功率 > 50%？        │
└──────────────────────┘
   ↓              ↓
  是             否
   ↓              ↓
关闭熔断      重新开启熔断
 (CLOSED)        (OPEN)
```

> 💡 **自动恢复的关键**：不要一次性放开所有流量，而是逐步试探恢复。

---

## 8. 📊 异常监控告警


### 8.1 监控指标体系


**需要监控的核心指标**：

🔸 **请求指标**
- QPS（每秒请求数）
- 响应时间（P50、P95、P99）
- 成功率、失败率

🔸 **异常指标**
- 异常类型分布
- 异常发生频率
- 异常影响范围

🔸 **熔断降级指标**
- 熔断器状态变化
- 降级触发次数
- 降级响应时间

🔸 **系统资源指标**
- CPU使用率
- 内存使用率
- 线程池状态

### 8.2 监控数据采集


**多维度数据收集**：

```
监控数据流转：

应用埋点                    时序数据库
    ↓                           ↑
业务日志  ─────→  日志收集器 ─────┘
    ↓                           ↑
metrics  ─────→  监控Agent  ────┘
    ↓                           ↑
链路追踪  ─────→  Tracing系统 ───┘
```

**使用Micrometer收集指标**：

```java
@Component
public class OrderMetrics {
    
    private final Counter orderCounter;
    private final Timer orderTimer;
    
    public OrderMetrics(MeterRegistry registry) {
        // 订单计数器
        this.orderCounter = Counter.builder("order.created")
            .tag("service", "order")
            .register(registry);
            
        // 订单处理时间
        this.orderTimer = Timer.builder("order.process.time")
            .register(registry);
    }
    
    public void recordOrder() {
        orderCounter.increment();  // 订单数+1
    }
    
    public void recordProcessTime(Runnable task) {
        orderTimer.record(task);   // 记录处理时间
    }
}
```

### 8.3 告警规则设计


**分级告警策略**：

| 告警级别 | 触发条件 | 通知方式 | 响应时间 |
|---------|---------|---------|---------|
| 🔴 **P0紧急** | 服务完全不可用 | 电话 + 短信 + 钉钉 | 5分钟内 |
| 🟠 **P1重要** | 错误率 > 10% | 短信 + 钉钉 | 15分钟内 |
| 🟡 **P2警告** | 响应时间 > 3秒 | 钉钉 + 邮件 | 30分钟内 |
| 🟢 **P3提示** | 资源使用 > 80% | 邮件 | 1小时内 |

**告警规则示例**：

```yaml
# Prometheus告警规则
groups:
  - name: service_alerts
    rules:
      # P0：服务不可用
      - alert: ServiceDown
        expr: up{job="order-service"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "订单服务不可用"
          
      # P1：错误率过高
      - alert: HighErrorRate
        expr: |
          sum(rate(http_requests_total{status=~"5.."}[5m])) 
          / sum(rate(http_requests_total[5m])) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "错误率超过10%"
```

### 8.4 异常追踪与定位


**分布式链路追踪**：

```
请求调用链路：

┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐
│ 网关  │ ──→ │订单服务│ ──→ │用户服务│ ──→ │库存服务│
└──────┘     └──────┘     └──────┘     └──────┘
 TraceId      TraceId      TraceId      TraceId
 Span1        Span2        Span3        Span4
   ↓            ↓            ↓            ↓
         异常发生在Span3（用户服务）
                  ↓
         快速定位问题根源
```

**使用Sleuth+Zipkin追踪**：

```yaml
# 配置链路追踪
spring:
  sleuth:
    sampler:
      probability: 1.0    # 采样率100%
  zipkin:
    base-url: http://localhost:9411
    sender:
      type: web
```

> 📝 **追踪的价值**：在复杂调用链中，快速定位是哪个环节出了问题。

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 异常处理三大目标：故障隔离、快速响应、自动恢复
🔸 熔断器三状态：关闭(CLOSED)、开启(OPEN)、半开(HALF_OPEN)
🔸 降级核心原则：保核心弃边缘、快速响应、用户无感
🔸 限流三大算法：固定窗口、滑动窗口、令牌桶
🔸 异常监控四大指标：请求、异常、熔断降级、系统资源
```

### 9.2 异常处理决策指南


**遇到异常如何处理**：

| 问题类型 | 处理方式 | 具体措施 |
|---------|---------|---------|
| **网络超时** | 熔断 + 降级 | 超时3次触发熔断，返回缓存数据 |
| **服务过载** | 限流 + 降级 | 令牌桶限流，拒绝超额请求 |
| **临时故障** | 重试 + 降级 | 重试3次，失败则降级 |
| **业务异常** | 快速失败 | 直接返回错误信息 |
| **未知异常** | 降级 + 告警 | 返回兜底数据，发送告警 |

### 9.3 配置建议速查表


**常用配置参数推荐**：

```
⏱️ 超时配置：
- 连接超时：1秒
- 读取超时：3秒
- 整体超时：5秒

🔌 熔断配置：
- 失败率阈值：50%
- 慢调用阈值：50%
- 慢调用时间：3秒
- 熔断恢复等待：60秒
- 滑动窗口：10-100次请求

🔄 重试配置：
- 最大重试次数：3次
- 重试间隔：1秒
- 适用异常：超时、网络异常

🚦 限流配置：
- 核心接口QPS：100
- 查询接口QPS：500
- 系统总QPS：10000

📊 监控告警：
- P0告警：服务不可用 > 1分钟
- P1告警：错误率 > 10% 持续5分钟
- P2告警：响应时间 > 3秒 持续10分钟
```

### 9.4 实践经验总结


**工程实践中的关键点**：

🔸 **不要过度防御**
- 不是所有接口都需要熔断降级
- 核心链路重点保护，非核心适度保护

🔸 **设置合理阈值**
- 阈值过低：误触发，影响正常业务
- 阈值过高：保护不及时，故障扩散

🔸 **注意降级数据质量**
- 降级数据要有意义（不能随便返回）
- 缓存数据要及时更新
- Mock数据要符合业务逻辑

🔸 **监控告警要闭环**
- 告警触发 → 人工处理 → 问题解决 → 复盘优化
- 建立故障知识库，避免重复踩坑

**核心记忆口诀**：
```
熔断保护防雪崩，降级兜底保可用
快速失败不等待,限流令牌控流量
重试恢复要适度，监控告警全方位
```

> 🎯 **最重要的一点**：异常处理不是银弹，合理的系统设计和容量规划才是根本！