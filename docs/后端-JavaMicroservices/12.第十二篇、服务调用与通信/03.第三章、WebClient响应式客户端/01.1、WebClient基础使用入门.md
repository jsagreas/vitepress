---
title: 1、WebClient基础使用入门
---
## 📚 目录

1. [WebClient是什么](#1-WebClient是什么)
2. [WebClient的创建方式](#2-WebClient的创建方式)
3. [响应式编程核心概念](#3-响应式编程核心概念)
4. [Mono与Flux响应类型](#4-Mono与Flux响应类型)
5. [阻塞与非阻塞调用](#5-阻塞与非阻塞调用)
6. [链式调用语法详解](#6-链式调用语法详解)
7. [retrieve与exchange的区别](#7-retrieve与exchange的区别)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 WebClient是什么


### 1.1 通俗理解WebClient


**生活类比**：
```
传统RestTemplate = 打电话
- 拨通电话后，必须等对方说完话才能挂断
- 期间你什么都不能干，只能干等着
- 一次只能打一个电话

WebClient = 发微信消息  
- 发完消息可以继续做其他事
- 对方回复后会通知你
- 可以同时给多个人发消息
```

**🔸 核心定义**
```
WebClient：Spring提供的响应式Web客户端
作用：向其他服务发送HTTP请求（GET、POST等）
特点：非阻塞、响应式、高性能

简单说：
WebClient是用来调用其他服务接口的工具，
就像你的服务要和别的服务"打电话"通信一样。
```

### 1.2 为什么需要WebClient


**🎯 实际场景**
```
订单服务调用商品服务：
订单服务 → "请告诉我商品ID=123的信息"
         ← 商品服务返回：{name:"手机", price:3999}

传统方式（RestTemplate）：
订单服务发出请求后，傻等着不能干别的 ❌

WebClient方式：
订单服务发出请求后，继续处理其他订单 ✅
商品服务回复后再处理响应
```

**优势对比**

| 特性 | **RestTemplate** | **WebClient** |
|------|-----------------|---------------|
| **工作方式** | 阻塞式（同步） | 非阻塞式（异步） |
| **性能** | 一次只能处理一个请求 | 可同时处理多个请求 |
| **资源占用** | 每个请求占用一个线程 | 少量线程处理大量请求 |
| **Spring支持** | 已过时，不再推荐 | 官方推荐 ✅ |

---

## 2. 🔧 WebClient的创建方式


### 2.1 三种创建方式对比


**方式一：最简单创建** ⭐
```java
// 直接创建，适合快速测试
WebClient client = WebClient.create();

// 使用示例
String result = client.get()
    .uri("http://localhost:8080/api/user/1")
    .retrieve()
    .bodyToMono(String.class)
    .block();
```

**方式二：指定基础URL** ⭐⭐
```java
// 设置基础地址，后续请求只需写路径
WebClient client = WebClient.create("http://localhost:8080");

// 调用时只需写路径部分
String result = client.get()
    .uri("/api/user/1")  // 自动拼接为 http://localhost:8080/api/user/1
    .retrieve()
    .bodyToMono(String.class)
    .block();
```

**方式三：Builder构建器（推荐）** ⭐⭐⭐
```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
            .baseUrl("http://localhost:8080")           // 基础URL
            .defaultHeader("User-Agent", "MyApp")       // 默认请求头
            .defaultCookie("session", "abc123")         // 默认Cookie
            .codecs(config -> config
                .defaultCodecs()
                .maxInMemorySize(16 * 1024 * 1024))    // 设置缓冲区16MB
            .build();
    }
}
```

### 2.2 配置项详解


**🔹 常用配置说明**
```
baseUrl：基础地址
- 所有请求的公共前缀
- 示例："http://api.example.com"

defaultHeader：默认请求头
- 每次请求自动添加的Header
- 常用：Authorization、Content-Type

defaultCookie：默认Cookie
- 每次请求自动携带的Cookie
- 用于会话保持

codecs：编解码器配置
- maxInMemorySize：内存缓冲区大小
- 默认256KB，处理大文件需调整

filter：请求/响应过滤器
- 可添加日志、认证等通用处理
```

**💡 实战配置示例**
```java
@Bean
public WebClient productServiceClient() {
    return WebClient.builder()
        .baseUrl("http://product-service")     // 商品服务地址
        .defaultHeader("Content-Type", "application/json")
        .filter((request, next) -> {
            // 打印请求日志
            log.info("请求: {} {}", request.method(), request.url());
            return next.exchange(request);
        })
        .build();
}
```

---

## 3. 🎯 响应式编程核心概念


### 3.1 什么是响应式编程


**🔸 生活类比**
```
传统编程 = 餐厅点餐（同步）
你点餐 → 服务员去厨房 → 你等着 → 菜来了 → 你开始吃
期间你什么都不能干，只能等 ❌

响应式编程 = 点外卖（异步）
你下单 → 继续工作 → 外卖到了通知你 → 你去取餐
期间你可以做其他事情 ✅
```

**核心特点**
```
📋 数据流驱动
- 数据像流水一样流动
- 有数据就处理，没数据就等待

📋 事件响应
- 不主动查询结果
- 等结果准备好了通知你

📋 非阻塞
- 发出请求后不等待
- 继续做其他事情
```

### 3.2 响应式编程的执行流程


**传统方式 vs 响应式方式**
```
传统方式（阻塞）：
订单服务线程                  商品服务
    |
    |--发送请求---------------→|
    |                          |处理中...
    |  (等待，啥都不干)         |
    |                          |
    |←---------返回结果---------|
    |
    |处理响应
    ↓

响应式方式（非阻塞）：
订单服务线程                  商品服务
    |
    |--发送请求---------------→|
    |                          |处理中...
    |处理其他订单A               |
    |处理其他订单B               |
    |处理其他订单C               |
    |                          |
    |←---------返回结果---------|
    |
    |处理响应（回调）
    ↓
```

### 3.3 为什么需要响应式


**🎯 性能对比**
```
场景：处理100个订单请求，每个需要调用商品服务

传统方式（RestTemplate）：
- 需要100个线程（一个请求一个线程）
- 内存消耗：100线程 × 1MB = 100MB
- 时间：串行处理，慢 ❌

响应式方式（WebClient）：
- 只需10个线程（线程复用）
- 内存消耗：10线程 × 1MB = 10MB  
- 时间：并发处理，快 ✅
```

---

## 4. 📦 Mono与Flux响应类型


### 4.1 Mono：单个结果


**🔸 概念理解**
```
Mono = 快递盒子
- 盒子里装0个或1个物品
- 就像调用接口返回一个用户信息

生活类比：
你网购了一个手机 → Mono<手机>
- 要么收到手机（1个）
- 要么没货（0个）
- 不可能收到多个手机
```

**使用场景**
```java
// 查询单个用户
Mono<User> findUserById(Long id) {
    return webClient.get()
        .uri("/api/user/{id}", id)
        .retrieve()
        .bodyToMono(User.class);
}

// 创建订单（返回一个订单）
Mono<Order> createOrder(Order order) {
    return webClient.post()
        .uri("/api/order")
        .bodyValue(order)
        .retrieve()
        .bodyToMono(Order.class);
}
```

### 4.2 Flux：多个结果


**🔸 概念理解**  
```
Flux = 传送带
- 传送带上可能有0个、1个或多个物品
- 物品一个个传过来
- 就像调用接口返回用户列表

生活类比：
你网购了一箱苹果 → Flux<苹果>
- 苹果一个个从箱子里拿出来
- 可能有10个苹果
- 也可能是空箱子（0个）
```

**使用场景**
```java
// 查询用户列表
Flux<User> findAllUsers() {
    return webClient.get()
        .uri("/api/users")
        .retrieve()
        .bodyToFlux(User.class);
}

// 查询订单列表
Flux<Order> findOrdersByUserId(Long userId) {
    return webClient.get()
        .uri("/api/orders?userId={userId}", userId)
        .retrieve()
        .bodyToFlux(Order.class);
}
```

### 4.3 Mono vs Flux 对比


**核心区别**

| 特性 | **Mono** | **Flux** |
|------|---------|----------|
| **返回数量** | 0个或1个 | 0个、1个或多个 |
| **类比** | 快递盒（单个） | 传送带（批量） |
| **使用场景** | 查单个、创建、更新、删除 | 查列表、批量处理 |
| **示例** | 查询用户详情 | 查询用户列表 |

**选择规则**
```
返回单个对象 → 用Mono
- Mono<User>      查询一个用户
- Mono<Order>     创建一个订单  
- Mono<Boolean>   删除操作结果
- Mono<Void>      无返回值操作

返回多个对象 → 用Flux
- Flux<User>      查询用户列表
- Flux<Product>   查询商品列表
- Flux<String>    返回多行日志
```

---

## 5. 🔄 阻塞与非阻塞调用


### 5.1 阻塞调用：block()


**🔸 工作原理**
```
阻塞 = 打电话
你拨通电话 → 等对方接听 → 等对方说话 → 挂断电话
期间你必须等待，不能做其他事 ❌
```

**代码示例**
```java
// 阻塞调用 - 等待结果返回
public User getUserSync(Long id) {
    User user = webClient.get()
        .uri("/api/user/{id}", id)
        .retrieve()
        .bodyToMono(User.class)
        .block();  // ← 在这里等待，直到拿到结果
    
    System.out.println("拿到用户：" + user.getName());
    return user;
}

// 执行流程
主线程: 发送请求 → 等待... → 拿到结果 → 继续执行
```

**⚠️ 使用注意**
```
适用场景：
✅ 传统Controller中需要直接返回结果
✅ 测试代码
✅ 简单脚本

不适用场景：
❌ 响应式Controller（会破坏响应式链）
❌ 高并发场景（浪费线程资源）
❌ 需要并发调用多个接口
```

### 5.2 非阻塞调用：subscribe()


**🔸 工作原理**
```
非阻塞 = 发微信
你发消息 → 继续干别的 → 收到回复通知你 → 你再处理
期间你可以做很多其他事 ✅
```

**代码示例**
```java
// 非阻塞调用 - 注册回调
public void getUserAsync(Long id) {
    webClient.get()
        .uri("/api/user/{id}", id)
        .retrieve()
        .bodyToMono(User.class)
        .subscribe(user -> {
            // 结果返回后执行这里
            System.out.println("收到用户：" + user.getName());
        });
    
    // 这行代码立即执行，不等待结果
    System.out.println("请求已发送，继续做其他事...");
}

// 执行流程
主线程: 发送请求 → 立即继续 → 做其他事 → (回调执行)
```

**💡 响应式Controller**
```java
@RestController
public class UserController {
    
    @Autowired
    private WebClient webClient;
    
    // 响应式端点 - 不需要block()
    @GetMapping("/user/{id}")
    public Mono<User> getUser(@PathVariable Long id) {
        return webClient.get()
            .uri("/api/user/{id}", id)
            .retrieve()
            .bodyToMono(User.class);
        // 直接返回Mono，Spring自动处理
    }
}
```

### 5.3 阻塞与非阻塞对比


**性能差异**
```
场景：同时调用10个接口，每个耗时1秒

阻塞方式：
接口1(1s) → 接口2(1s) → ... → 接口10(1s)
总耗时：10秒 ❌

非阻塞方式：
接口1、2、3...10 同时发起
总耗时：1秒 ✅（所有接口并发执行）
```

**选择建议**
```
🔹 使用block()的情况
- 传统SpringMVC Controller
- 需要立即获取结果的同步代码
- 简单的脚本或测试

🔹 使用subscribe()的情况  
- 响应式Controller
- 高并发场景
- 需要处理数据流
- 不关心立即返回

🔹 直接返回Mono/Flux（最佳）
- Spring WebFlux环境
- 让框架自动处理响应式流
```

---

## 6. 🔗 链式调用语法详解


### 6.1 什么是链式调用


**🔸 生活类比**
```
点外卖流程：
选餐厅 → 选菜品 → 加备注 → 选地址 → 支付
每一步都基于上一步的结果

链式调用：
webClient.get()           // 选择请求方式
    .uri("/api/user")     // 指定地址
    .header("token","xxx") // 添加请求头
    .retrieve()           // 发送请求
    .bodyToMono(User.class) // 处理响应
```

### 6.2 完整调用链路


**基本结构**
```
WebClient调用链 = 请求构建 + 发送 + 响应处理

┌─────────────┐
│ 1.创建请求   │ → get()/post()/put()/delete()
├─────────────┤
│ 2.配置请求   │ → uri()/header()/cookie()/body()
├─────────────┤
│ 3.发送请求   │ → retrieve()/exchange()
├─────────────┤
│ 4.处理响应   │ → bodyToMono()/bodyToFlux()
├─────────────┤
│ 5.获取结果   │ → block()/subscribe()
└─────────────┘
```

**详细示例**
```java
// GET请求完整链路
webClient
    .get()                              // 1. 指定GET请求
    .uri("/api/user/{id}", 123)        // 2. 设置URI，{id}会被123替换
    .header("Authorization", "Bearer token") // 3. 添加请求头
    .cookie("session", "abc")          // 4. 添加Cookie
    .retrieve()                        // 5. 发送请求
    .bodyToMono(User.class)           // 6. 响应转换为User对象
    .block();                          // 7. 阻塞获取结果

// POST请求完整链路
webClient
    .post()                            // 1. 指定POST请求
    .uri("/api/order")                // 2. 设置URI
    .contentType(MediaType.APPLICATION_JSON) // 3. 设置内容类型
    .bodyValue(order)                 // 4. 设置请求体
    .retrieve()                       // 5. 发送请求
    .bodyToMono(Order.class)         // 6. 响应转换
    .subscribe(result -> {            // 7. 非阻塞处理结果
        log.info("订单创建成功：{}", result);
    });
```

### 6.3 链式调用各环节详解


**🔹 请求方式**
```java
.get()      // GET请求，查询数据
.post()     // POST请求，创建数据
.put()      // PUT请求，更新数据
.delete()   // DELETE请求，删除数据
.patch()    // PATCH请求，部分更新
```

**🔹 URI配置**
```java
// 方式1：完整URL
.uri("http://localhost:8080/api/user/1")

// 方式2：路径+参数替换
.uri("/api/user/{id}", 123)  // {id}被替换为123

// 方式3：使用UriBuilder
.uri(uriBuilder -> uriBuilder
    .path("/api/users")
    .queryParam("page", 1)
    .queryParam("size", 10)
    .build())
// 生成：/api/users?page=1&size=10
```

**🔹 请求头和Cookie**
```java
// 添加请求头
.header("Authorization", "Bearer xxx")
.header("Content-Type", "application/json")

// 添加Cookie
.cookie("sessionId", "abc123")
.cookie("userId", "user001")

// 批量添加
.headers(headers -> {
    headers.add("Custom-Header", "value");
    headers.setBasicAuth("user", "password");
})
```

**🔹 请求体**
```java
// 方式1：直接传对象
.bodyValue(user)  // Spring自动转JSON

// 方式2：传Mono
.body(Mono.just(user), User.class)

// 方式3：传Flux（批量）
.body(Flux.just(user1, user2), User.class)
```

---

## 7. 🔍 retrieve与exchange的区别


### 7.1 retrieve：简单直接（推荐）


**🔸 核心特点**
```
retrieve = 快递员直接把包裹给你
- 只关心包裹内容（响应体）
- 不管快递单（响应头、状态码等）
- 简单、常用 ✅
```

**基本用法**
```java
// 标准使用
Mono<User> user = webClient.get()
    .uri("/api/user/1")
    .retrieve()
    .bodyToMono(User.class);

// 返回内容就是User对象
```

**错误处理**
```java
webClient.get()
    .uri("/api/user/1")
    .retrieve()
    .onStatus(HttpStatus::is4xxClientError, response -> {
        // 处理4xx错误（如404）
        return Mono.error(new RuntimeException("客户端错误"));
    })
    .onStatus(HttpStatus::is5xxServerError, response -> {
        // 处理5xx错误（如500）
        return Mono.error(new RuntimeException("服务器错误"));
    })
    .bodyToMono(User.class);
```

### 7.2 exchange：完全控制（高级）


**🔸 核心特点**
```
exchange = 快递员把包裹和快递单都给你
- 可以看响应头
- 可以看状态码
- 可以看Cookie
- 完全控制，但复杂 ⚠️
```

**基本用法**
```java
Mono<User> user = webClient.get()
    .uri("/api/user/1")
    .exchangeToMono(response -> {
        // response包含完整的响应信息
        
        // 获取状态码
        int statusCode = response.statusCode().value();
        
        // 获取响应头
        String token = response.headers()
            .asHttpHeaders()
            .getFirst("Authorization");
        
        // 根据状态码处理
        if (response.statusCode().is2xxSuccessful()) {
            return response.bodyToMono(User.class);
        } else {
            return Mono.error(new RuntimeException("请求失败"));
        }
    });
```

**高级用法：获取响应头**
```java
// 场景：登录后需要从响应头获取Token
webClient.post()
    .uri("/api/login")
    .bodyValue(loginRequest)
    .exchangeToMono(response -> {
        // 提取响应头中的Token
        String token = response.headers()
            .asHttpHeaders()
            .getFirst("Authorization");
        
        // 提取响应体
        return response.bodyToMono(User.class)
            .doOnNext(user -> {
                // 保存Token
                user.setToken(token);
            });
    });
```

### 7.3 retrieve vs exchange 对比


**核心区别**

| 特性 | **retrieve()** | **exchange()** |
|------|---------------|----------------|
| **简洁性** | 简单直接 ✅ | 复杂需要手动处理 |
| **访问响应头** | 不能直接访问 | 可以访问 ✅ |
| **访问状态码** | 通过onStatus处理 | 可以直接获取 ✅ |
| **内存管理** | 自动管理 ✅ | 需要手动释放 ⚠️ |
| **推荐场景** | 日常使用 | 需要完整响应信息 |

**选择建议**
```
🔹 优先使用retrieve()
- 只需要响应体数据
- 简单的错误处理
- 90%的业务场景

🔹 使用exchange()的情况
- 需要读取响应头（如Token）
- 需要根据状态码精确处理
- 需要读取Cookie
- 需要完全控制响应
```

**⚠️ exchange注意事项**
```java
// ❌ 错误：忘记消费响应体，导致内存泄漏
webClient.get()
    .uri("/api/user/1")
    .exchangeToMono(response -> {
        int status = response.statusCode().value();
        // 忘记调用response.bodyToMono()
        return Mono.just(status);
    });

// ✅ 正确：必须消费响应体
webClient.get()
    .uri("/api/user/1")
    .exchangeToMono(response -> {
        if (response.statusCode().is2xxSuccessful()) {
            return response.bodyToMono(User.class);
        } else {
            // 即使出错也要消费响应体
            return response.bodyToMono(Void.class)
                .then(Mono.error(new RuntimeException("请求失败")));
        }
    });
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基础概念


**🔸 WebClient本质**
```
WebClient = Spring的HTTP客户端工具
作用：向其他服务发送请求，获取响应
特点：响应式、非阻塞、高性能
替代：RestTemplate（已过时）
```

**🔸 响应式编程理解**
```
核心思想：
- 发出请求不等待
- 继续做其他事情
- 结果返回时通过回调处理

类比：
传统方式 = 打电话（等待）
响应式 = 发微信（继续工作）
```

**🔸 Mono与Flux**
```
Mono：0个或1个结果
- 查单个、创建、更新
- Mono<User>

Flux：0个、1个或多个结果
- 查列表、批量处理
- Flux<User>
```

### 8.2 实战要点


**创建WebClient**
```java
// 推荐方式：配置类中创建
@Bean
public WebClient webClient() {
    return WebClient.builder()
        .baseUrl("http://api-service")
        .defaultHeader("Content-Type", "application/json")
        .build();
}
```

**发送请求流程**
```
1. 选择方法：get()/post()/put()/delete()
2. 配置URI：uri()
3. 设置参数：header()/body()
4. 发送请求：retrieve()/exchange()
5. 处理响应：bodyToMono()/bodyToFlux()
6. 获取结果：block()/subscribe()
```

**阻塞与非阻塞选择**
```
传统Controller → 用block()
响应式Controller → 直接返回Mono/Flux
高并发场景 → 用subscribe()
```

**retrieve与exchange选择**
```
日常开发 → retrieve()（简单）
需要响应头 → exchange()（复杂）
```

### 8.3 记忆口诀


```
WebClient响应式调用，
非阻塞高效性能好。

Mono单个Flux多个，
根据返回选类型。

链式调用六步走，
方法URI配参数，
retrieve发送拿响应，
block堵塞subscribe不堵。

retrieve简单日常用，
exchange复杂全控制。
```

### 8.4 常见问题速查


**Q1：什么时候用Mono，什么时候用Flux？**
```
看返回数量：
单个对象 → Mono<T>
多个对象 → Flux<T>
```

**Q2：block()和subscribe()怎么选？**
```
传统Controller → block()（需要直接返回）
响应式环境 → subscribe()或直接返回Mono
```

**Q3：retrieve()和exchange()的区别？**
```
retrieve()：只要响应体，简单
exchange()：要全部信息，复杂
日常用retrieve()，特殊需求用exchange()
```

**Q4：如何处理错误？**
```
retrieve()方式：
.onStatus(状态判断, 错误处理)

exchange()方式：
在exchangeToMono中判断statusCode
```