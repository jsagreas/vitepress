---
title: 3、服务调用测试策略
---
## 📚 目录

1. [测试策略概述](#1-测试策略概述)
2. [单元测试编写](#2-单元测试编写)
3. [集成测试设计](#3-集成测试设计)
4. [Mock服务搭建](#4-Mock服务搭建)
5. [契约测试实现](#5-契约测试实现)
6. [性能测试方案](#6-性能测试方案)
7. [压力测试配置](#7-压力测试配置)
8. [测试数据管理](#8-测试数据管理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 测试策略概述


### 1.1 为什么要测试服务调用


**现实问题**：微服务之间互相调用，就像多个人协作工作

```
订单服务 → 调用 → 库存服务 → 调用 → 仓储服务

如果中间任何一个环节出问题：
❌ 库存服务挂了 → 订单无法创建
❌ 响应太慢 → 用户等待超时
❌ 数据格式错误 → 业务逻辑失败
```

**测试的本质**：在上线前发现并解决这些问题，保证服务间通信的可靠性

### 1.2 微服务测试金字塔


```
           /\        ← 端到端测试（少量）
          /  \         测试整个业务流程
         /────\      
        /集成测试\     ← 集成测试（适量）
       /────────\      测试服务间调用
      /  单元测试  \   ← 单元测试（大量）
     /────────────\    测试单个方法逻辑
    ──────────────── 

核心原则：
① 单元测试最多：快速、稳定、成本低
② 集成测试适量：验证服务协作
③ 端到端最少：慢、脆弱、成本高
```

### 1.3 测试类型对比


| 测试类型 | **测试范围** | **执行速度** | **稳定性** | **成本** | **适用场景** |
|---------|------------|------------|----------|---------|------------|
| 🔹 **单元测试** | `单个方法/类` | `极快(毫秒级)` | `极高` | `低` | `业务逻辑验证` |
| 🔸 **集成测试** | `多个服务交互` | `较快(秒级)` | `较高` | `中` | `接口调用验证` |
| 🔶 **性能测试** | `系统负载能力` | `慢(分钟级)` | `中` | `高` | `性能指标验证` |
| 🔷 **压力测试** | `系统极限` | `慢(分钟级)` | `低` | `高` | `稳定性验证` |

---

## 2. ✅ 单元测试编写


### 2.1 单元测试是什么


**通俗理解**：单元测试就像检查零件质量

```
生产流程：
组装汽车前 → 先检查每个零件 → 确保单个零件没问题

代码测试：
服务上线前 → 先测试每个方法 → 确保单个方法逻辑正确
```

**单元测试核心**：
- 📌 只测试**一个方法**的逻辑
- 📌 不依赖外部服务（数据库、其他服务）
- 📌 执行速度快，可以频繁运行

### 2.2 基础单元测试示例


**场景**：订单服务需要调用库存服务检查库存

```java
// 被测试的服务类
@Service
public class OrderService {
    
    @Autowired
    private InventoryClient inventoryClient;
    
    // 创建订单的方法
    public Order createOrder(Long productId, int quantity) {
        // ① 检查库存
        int stock = inventoryClient.getStock(productId);
        
        // ② 判断库存是否充足
        if (stock < quantity) {
            throw new BusinessException("库存不足");
        }
        
        // ③ 创建订单
        Order order = new Order();
        order.setProductId(productId);
        order.setQuantity(quantity);
        return order;
    }
}
```

**对应的单元测试**：

```java
@SpringBootTest
class OrderServiceTest {
    
    @Autowired
    private OrderService orderService;
    
    @MockBean  // 关键：模拟外部依赖
    private InventoryClient inventoryClient;
    
    // ① 测试正常情况：库存充足
    @Test
    void testCreateOrder_Success() {
        // 准备：假设库存有100个
        when(inventoryClient.getStock(1L))
            .thenReturn(100);
        
        // 执行：创建订单购买10个
        Order order = orderService.createOrder(1L, 10);
        
        // 验证：订单创建成功
        assertNotNull(order);
        assertEquals(1L, order.getProductId());
        assertEquals(10, order.getQuantity());
    }
    
    // ② 测试异常情况：库存不足
    @Test
    void testCreateOrder_InsufficientStock() {
        // 准备：假设库存只有5个
        when(inventoryClient.getStock(1L))
            .thenReturn(5);
        
        // 执行并验证：应该抛出异常
        assertThrows(BusinessException.class, () -> {
            orderService.createOrder(1L, 10);
        });
    }
}
```

### 2.3 单元测试的三个步骤


**记忆口诀**：准备 → 执行 → 验证

```
① 准备（Arrange）
   → 设置测试数据
   → 模拟外部依赖的返回值

② 执行（Act）
   → 调用要测试的方法
   
③ 验证（Assert）
   → 检查结果是否符合预期
   → 检查是否抛出了期望的异常
```

### 2.4 常用的测试注解


| 注解 | **作用** | **使用场景** |
|-----|---------|------------|
| `@Test` | 标记测试方法 | 每个测试用例都要加 |
| `@MockBean` | 模拟Spring Bean | 模拟外部服务调用 |
| `@BeforeEach` | 每个测试前执行 | 初始化测试数据 |
| `@AfterEach` | 每个测试后执行 | 清理测试数据 |

---

## 3. 🔗 集成测试设计


### 3.1 集成测试是什么


**通俗理解**：集成测试就像检查零件组装后能否正常工作

```
单元测试：检查单个齿轮 ✓
集成测试：检查齿轮装到一起后能否转动 ✓

订单服务 ←→ 库存服务
   ↑
   └── 集成测试验证这两个服务能否正常通信
```

### 3.2 集成测试与单元测试的区别


**核心差异**：

```
单元测试：
订单服务 → [Mock库存服务] ← 假的，模拟的
           只测试订单服务自己的逻辑

集成测试：
订单服务 → [真实库存服务] ← 真的，真正调用
           测试两个服务能否正确通信
```

### 3.3 集成测试示例


**场景**：测试订单服务真实调用库存服务

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class OrderIntegrationTest {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    // 测试真实的服务调用
    @Test
    void testCreateOrderIntegration() {
        // ① 准备：先调用库存服务设置库存
        restTemplate.postForObject(
            "http://inventory-service/api/stock/set",
            new StockRequest(1L, 100),
            Void.class
        );
        
        // ② 执行：创建订单
        Order order = orderService.createOrder(1L, 10);
        
        // ③ 验证：订单创建成功
        assertNotNull(order);
        
        // ④ 再次验证：库存已减少
        Integer stock = restTemplate.getForObject(
            "http://inventory-service/api/stock/1",
            Integer.class
        );
        assertEquals(90, stock);
    }
}
```

### 3.4 集成测试的配置要点


**环境准备**：

```yaml
# application-test.yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: test  # 使用测试命名空间
        
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

**关键点**：
- ✅ 使用独立的测试环境
- ✅ 配置真实的服务注册中心
- ✅ 测试数据要和生产数据隔离

---

## 4. 🎭 Mock服务搭建


### 4.1 什么是Mock服务


**生活类比**：Mock服务就像"替身演员"

```
拍电影时：
危险动作 → 用替身演员 → 保护真正的演员

测试时：
需要调用外部服务 → 用Mock服务 → 不依赖真实服务
```

### 4.2 为什么需要Mock


**实际问题**：

```
问题1：外部服务还没开发完
订单服务开发好了 → 但支付服务还没做好 → 怎么测试？
解决：用Mock模拟支付服务

问题2：外部服务不稳定
测试时支付服务经常挂 → 导致测试失败 → 影响开发进度
解决：用Mock替代，保证测试稳定

问题3：测试成本高
每次测试都真实扣费 → 成本太高
解决：用Mock模拟扣费成功
```

### 4.3 Mock服务实现方式


#### 方式一：使用Mockito（单元测试常用）


```java
@MockBean
private PaymentClient paymentClient;

@Test
void testPayment() {
    // 模拟支付成功
    when(paymentClient.pay(anyLong(), anyDouble()))
        .thenReturn(PaymentResult.success());
    
    // 模拟支付失败
    when(paymentClient.pay(100L, 999.0))
        .thenReturn(PaymentResult.fail("余额不足"));
}
```

#### 方式二：使用WireMock（集成测试常用）


```java
@WireMockTest(httpPort = 8080)
class MockServerTest {
    
    @Test
    void testWithMockServer() {
        // 设置Mock规则：当调用这个接口时返回什么
        stubFor(get("/api/inventory/1")
            .willReturn(okJson("{ \"stock\": 100 }")));
        
        // 测试代码会真实发起HTTP请求
        // 但请求被WireMock拦截并返回模拟数据
        int stock = inventoryClient.getStock(1L);
        assertEquals(100, stock);
    }
}
```

### 4.4 Mock服务的搭建步骤


**步骤流程**：

```
① 分析依赖
   └→ 找出需要调用的外部服务
   
② 定义Mock行为
   └→ 确定每个接口应该返回什么数据
   
③ 配置Mock规则
   └→ 使用工具（Mockito/WireMock）设置规则
   
④ 验证Mock效果
   └→ 确保Mock按预期工作
```

**实战示例**：

```java
// Mock服务配置类
@Configuration
public class MockConfig {
    
    @Bean
    @Primary  // 优先使用Mock实现
    public InventoryClient mockInventoryClient() {
        return new InventoryClient() {
            @Override
            public int getStock(Long productId) {
                // 模拟不同商品的库存
                if (productId == 1L) return 100;
                if (productId == 2L) return 50;
                return 0;
            }
            
            @Override
            public boolean reduceStock(Long productId, int quantity) {
                // 模拟减库存成功
                return true;
            }
        };
    }
}
```

---

## 5. 📋 契约测试实现


### 5.1 什么是契约测试


**通俗理解**：契约测试就像"合同验证"

```
现实中的合同：
甲方：我需要你提供XX服务
乙方：好的，我按XX格式给你
契约：双方签字，按约定执行

服务间的契约：
订单服务：我调用你的接口，需要返回库存数量
库存服务：好的，我返回 { "stock": 100 } 格式
契约测试：验证双方是否遵守约定
```

### 5.2 契约测试解决的问题


**实际场景**：

```
问题：接口变更导致调用失败

库存服务改了返回格式：
原来：{ "stock": 100 }
现在：{ "inventory": 100 }  ← 字段名变了

订单服务没及时更新 → 解析失败 → 线上故障

契约测试的作用：
✅ 提前发现接口不匹配
✅ 确保服务升级不破坏兼容性
```

### 5.3 契约测试实现（Spring Cloud Contract）


**生产者端（库存服务）**：

```groovy
// 定义契约文件：inventory-contract.groovy
Contract.make {
    description "获取商品库存"
    request {
        method GET()
        url "/api/inventory/1"
    }
    response {
        status 200
        headers {
            contentType applicationJson()
        }
        body(
            stock: 100,
            productId: 1
        )
    }
}
```

**消费者端（订单服务）**：

```java
@SpringBootTest
@AutoConfigureStubRunner(
    ids = "com.example:inventory-service:+:stubs:8080"
)
class ContractTest {
    
    @Autowired
    private InventoryClient inventoryClient;
    
    @Test
    void testInventoryContract() {
        // 调用接口
        InventoryResponse response = inventoryClient.getStock(1L);
        
        // 验证是否符合契约
        assertEquals(100, response.getStock());
        assertEquals(1L, response.getProductId());
    }
}
```

### 5.4 契约测试的工作流程


```
生产者（库存服务）                消费者（订单服务）
      |                                |
      | ① 定义契约                      |
      |    返回格式约定                 |
      |                                |
      | ② 生成Stub                     |
      |--------------------------------→|
      |                                |
      |                         ③ 使用Stub测试
      |                            验证调用是否符合契约
      |                                |
      | ④ 契约验证                      |
      |    确保实现符合约定              |
      ↓                                ↓
```

---

## 6. ⚡ 性能测试方案


### 6.1 性能测试是什么


**通俗理解**：性能测试就像"体检"

```
人的体检：
测血压、心跳、肺活量 → 了解身体指标

系统的性能测试：
测响应时间、吞吐量、CPU使用率 → 了解系统性能
```

### 6.2 核心性能指标


| 指标 | **含义** | **目标值示例** | **重要性** |
|-----|---------|------------|----------|
| **响应时间** | 从请求到返回的时间 | P95 < 100ms | ⭐⭐⭐⭐⭐ |
| **吞吐量** | 每秒处理的请求数 | TPS > 1000 | ⭐⭐⭐⭐⭐ |
| **并发数** | 同时处理的请求数 | 支持500并发 | ⭐⭐⭐⭐ |
| **错误率** | 失败请求的比例 | < 0.1% | ⭐⭐⭐⭐⭐ |

**指标解释**：

```
P95响应时间：
意思是95%的请求响应时间都在这个值以内
例如：P95=100ms，表示100个请求中，95个都在100ms内完成

TPS（每秒事务数）：
Transactions Per Second
例如：TPS=1000，表示系统每秒能处理1000个请求
```

### 6.3 性能测试工具：JMeter


**基础配置示例**：

```xml
<!-- JMeter测试计划 -->
<ThreadGroup>
  <name>订单服务性能测试</name>
  <num_threads>100</num_threads>      <!-- 100个并发用户 -->
  <ramp_time>10</ramp_time>           <!-- 10秒内启动完 -->
  <duration>300</duration>             <!-- 持续5分钟 -->
  
  <HTTPSampler>
    <domain>localhost</domain>
    <port>8080</port>
    <path>/api/orders</path>
    <method>POST</method>
  </HTTPSampler>
</ThreadGroup>
```

### 6.4 性能测试步骤


**测试流程**：

```
① 确定测试目标
   → 期望达到的性能指标
   → 例：P95 < 100ms，TPS > 500

② 准备测试环境
   → 模拟生产环境配置
   → 准备测试数据

③ 设计测试场景
   → 正常负载：模拟日常流量
   → 峰值负载：模拟高峰期流量

④ 执行测试
   → 逐步增加负载
   → 观察系统表现

⑤ 分析结果
   → 找出性能瓶颈
   → 优化改进
```

**实战示例代码**：

```java
@Test
void performanceTest() throws Exception {
    int totalRequests = 10000;
    int concurrency = 100;
    
    ExecutorService executor = Executors.newFixedThreadPool(concurrency);
    CountDownLatch latch = new CountDownLatch(totalRequests);
    
    long startTime = System.currentTimeMillis();
    
    // 模拟并发请求
    for (int i = 0; i < totalRequests; i++) {
        executor.submit(() -> {
            try {
                orderService.createOrder(1L, 1);
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await();
    long endTime = System.currentTimeMillis();
    
    // 计算性能指标
    double duration = (endTime - startTime) / 1000.0;
    double tps = totalRequests / duration;
    
    System.out.println("总耗时: " + duration + "秒");
    System.out.println("TPS: " + tps);
}
```

---

## 7. 🔥 压力测试配置


### 7.1 压力测试与性能测试的区别


**核心区别**：

```
性能测试：
目的 → 验证系统能否达到预期性能
负载 → 正常或稍高于正常的负载

压力测试：
目的 → 找到系统的极限和崩溃点
负载 → 持续增加直到系统崩溃
```

**形象比喻**：

```
性能测试：
检查汽车能否跑到120km/h

压力测试：
不断加速，看最高能跑多少
找出汽车的极限速度
```

### 7.2 压力测试的目标


**主要目标**：

```
① 找到系统极限
   → 最大能支持多少并发
   → 最大TPS是多少

② 发现资源瓶颈
   → CPU先到100%还是内存先耗尽
   → 数据库连接池会不会打满

③ 验证故障恢复
   → 压力过后能否恢复
   → 是否有资源泄漏
```

### 7.3 压力测试配置


**JMeter压力测试配置**：

```xml
<!-- 压力测试线程组 -->
<UltimateThreadGroup>
  <!-- 阶梯式加压 -->
  <schedule>
    <step>
      <threads>50</threads>       <!-- 第1阶段：50并发 -->
      <duration>60</duration>      <!-- 持续60秒 -->
    </step>
    <step>
      <threads>100</threads>      <!-- 第2阶段：100并发 -->
      <duration>60</duration>
    </step>
    <step>
      <threads>200</threads>      <!-- 第3阶段：200并发 -->
      <duration>60</duration>
    </step>
    <step>
      <threads>500</threads>      <!-- 第4阶段：500并发 -->
      <duration>60</duration>      <!-- 观察是否崩溃 -->
    </step>
  </schedule>
</UltimateThreadGroup>
```

### 7.4 压力测试监控指标


**关键监控点**：

```
系统指标：
🔸 CPU使用率      → 超过80%需要关注
🔸 内存使用率     → 超过90%需要关注  
🔸 磁盘IO        → IOPS是否达到瓶颈
🔸 网络带宽      → 是否打满

应用指标：
🔸 响应时间      → 是否急剧上升
🔸 错误率        → 是否开始出现错误
🔸 线程池状态    → 是否打满
🔸 数据库连接池  → 是否耗尽
```

**监控实现**：

```java
@Component
public class PerformanceMonitor {
    
    // 记录请求耗时
    public void recordResponseTime(long duration) {
        if (duration > 100) {  // 超过100ms
            log.warn("慢请求告警: {}ms", duration);
        }
    }
    
    // 检查系统资源
    @Scheduled(fixedRate = 5000)
    public void checkSystemMetrics() {
        OperatingSystemMXBean os = ManagementFactory.getOperatingSystemMXBean();
        double cpuUsage = os.getSystemLoadAverage();
        
        if (cpuUsage > 0.8) {
            log.error("CPU使用率过高: {}%", cpuUsage * 100);
        }
    }
}
```

---

## 8. 📊 测试数据管理


### 8.1 为什么需要管理测试数据


**实际问题**：

```
问题1：数据污染
测试产生的脏数据 → 影响后续测试 → 结果不准确

问题2：数据依赖
多个测试用同一份数据 → 一个测试改了数据 → 其他测试失败

问题3：数据准备困难
每次测试都要手动准备数据 → 效率低 → 容易出错
```

### 8.2 测试数据管理策略


**策略一：数据隔离**

```
每个测试用独立的数据：

测试A：使用ID 1001-2000 的数据
测试B：使用ID 2001-3000 的数据
测试C：使用ID 3001-4000 的数据

互不干扰 ✓
```

**策略二：数据清理**

```java
@TestConfiguration
public class TestDataConfig {
    
    @Autowired
    private OrderRepository orderRepository;
    
    // 每个测试前清理数据
    @BeforeEach
    public void cleanData() {
        orderRepository.deleteAll();
    }
    
    // 每个测试后也清理（双重保险）
    @AfterEach  
    public void cleanup() {
        orderRepository.deleteAll();
    }
}
```

**策略三：数据准备工具**

```java
@Component
public class TestDataFactory {
    
    // 创建测试用户
    public User createTestUser(String prefix) {
        User user = new User();
        user.setUsername(prefix + "_" + UUID.randomUUID());
        user.setEmail(prefix + "@test.com");
        return userRepository.save(user);
    }
    
    // 创建测试订单
    public Order createTestOrder(Long userId, Long productId) {
        Order order = new Order();
        order.setUserId(userId);
        order.setProductId(productId);
        order.setStatus("CREATED");
        return orderRepository.save(order);
    }
}
```

### 8.3 使用数据库事务回滚


**最简单的方式**：利用Spring的`@Transactional`

```java
@SpringBootTest
@Transactional  // 关键：测试结束后自动回滚
class OrderServiceTest {
    
    @Test
    void testCreateOrder() {
        // 这里的所有数据库操作
        // 测试结束后都会自动回滚
        Order order = orderService.createOrder(1L, 10);
        assertNotNull(order);
        
        // 不需要手动清理数据
    }
}
```

**原理说明**：

```
测试开始 → 开启事务
      ↓
执行测试代码 → 数据写入数据库
      ↓
测试结束 → 事务回滚 → 数据自动删除

优点：
✅ 自动清理，不用手动删除
✅ 数据隔离，互不影响
✅ 执行速度快
```

### 8.4 测试数据的版本管理


**使用Flyway/Liquibase管理测试数据**：

```sql
-- V1__init_test_data.sql
INSERT INTO product (id, name, price, stock) VALUES
(1, '测试商品A', 99.99, 100),
(2, '测试商品B', 199.99, 50),
(3, '测试商品C', 299.99, 30);

INSERT INTO user (id, username, email) VALUES
(1, 'test_user_1', 'test1@example.com'),
(2, 'test_user_2', 'test2@example.com');
```

**配置文件**：

```yaml
# application-test.yml
spring:
  flyway:
    enabled: true
    locations: classpath:db/test-data  # 测试数据目录
    clean-disabled: false  # 允许清理
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 测试金字塔：单元测试多、集成测试适量、端到端少
🔸 测试类型：单元、集成、Mock、契约、性能、压力
🔸 Mock作用：模拟外部依赖，保证测试稳定性
🔸 契约测试：确保服务间接口兼容性
🔸 性能指标：响应时间、TPS、并发数、错误率
🔸 数据管理：隔离、清理、事务回滚
```

### 9.2 测试策略选择指南


**测试类型选择**：

| 场景 | **推荐测试** | **原因** |
|-----|-----------|---------|
| 验证业务逻辑 | 单元测试 | 快速、稳定、覆盖率高 |
| 验证服务调用 | 集成测试 | 真实环境、发现集成问题 |
| 外部服务未就绪 | Mock测试 | 不依赖外部、开发效率高 |
| 服务升级兼容性 | 契约测试 | 提前发现接口变更 |
| 验证系统性能 | 性能测试 | 确保满足性能要求 |
| 找系统极限 | 压力测试 | 发现瓶颈、容量规划 |

### 9.3 实战最佳实践


**① 测试先行原则**：
```
开发新功能流程：
1. 先写测试用例（定义预期行为）
2. 再写实现代码
3. 运行测试验证
4. 重构优化（测试保证不破坏功能）
```

**② 测试独立性**：
```
✅ 每个测试可以独立运行
✅ 测试之间没有依赖关系
✅ 测试顺序可以随意调整
❌ 避免测试A依赖测试B的数据
```

**③ 合理的测试覆盖率**：
```
不是越高越好：
🔸 核心业务逻辑：90%+ 覆盖
🔸 工具类方法：80%+ 覆盖  
🔸 配置类代码：可以不测
🔸 getter/setter：可以不测
```

**④ 持续集成**：
```
代码提交 → 自动运行测试 → 测试通过才能合并

CI/CD流程：
git push → 触发Jenkins/GitLab CI
        ↓
    运行单元测试
        ↓
    运行集成测试
        ↓
    测试通过 → 自动部署
    测试失败 → 通知开发人员
```

### 9.4 常见问题及解决方案


**Q1：测试执行慢怎么办？**
```
原因分析：
❌ 单元测试用了真实数据库
❌ 测试之间没有并行执行
❌ 重复创建Spring上下文

解决方案：
✅ 单元测试用内存数据库H2
✅ 配置并行执行：@Execution(PARALLEL)
✅ 复用Spring上下文：合理组织测试类
```

**Q2：测试不稳定，时好时坏？**
```
原因分析：
❌ 依赖外部环境（网络、数据库）
❌ 测试数据有冲突
❌ 异步操作没有等待

解决方案：
✅ 使用Mock替代外部依赖
✅ 每个测试独立数据
✅ 异步操作加等待机制：await()
```

**Q3：Mock数据和真实数据不一致？**
```
原因分析：
❌ Mock数据过于简单
❌ 没有及时更新Mock规则

解决方案：
✅ 使用契约测试保证一致性
✅ Mock数据尽量接近真实场景
✅ 定期运行集成测试验证
```

### 9.5 测试文化建设


**团队规范**：
```
① 代码review包含测试代码
② 新功能必须有测试覆盖
③ Bug修复必须补充测试
④ 定期分享测试经验
⑤ 持续优化测试效率
```

**核心记忆口诀**：
```
单元快而稳，集成验交互
Mock替外部，契约保兼容
性能看指标，压力找极限
数据要隔离，回滚最简单
测试即文档，质量有保证
```