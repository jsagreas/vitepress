---
title: 2、服务发现与调用机制
---
## 📚 目录

1. [服务注册中心的作用](#1-服务注册中心的作用)
2. [Eureka注册发现机制](#2-eureka注册发现机制)
3. [Nacos服务发现配置](#3-nacos服务发现配置)
4. [Consul服务发现集成](#4-consul服务发现集成)
5. [服务地址解析过程](#5-服务地址解析过程)
6. [调用链路追踪流程](#6-调用链路追踪流程)
7. [服务健康检查机制](#7-服务健康检查机制)
8. [动态服务列表维护](#8-动态服务列表维护)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏢 服务注册中心的作用


### 1.1 什么是服务注册中心


**通俗理解**：
想象一个大型商场，服务注册中心就像商场的**导购台**。每家店铺开业时要到导购台登记（注册），顾客想找某家店时也去导购台查询（发现）。

```
传统方式（硬编码地址）：
订单服务 → http://192.168.1.100:8080/user
问题：用户服务IP变了怎么办？服务器挂了怎么办？

微服务方式（服务注册中心）：
订单服务 → 注册中心查询"user-service" → 获取可用地址 → 调用
好处：地址动态获取，服务自动发现
```

### 1.2 核心作用解析


**🔸 服务注册**
```
服务启动时的操作：
1. 用户服务启动
2. 向注册中心报告："我是user-service，地址是192.168.1.100:8080"
3. 注册中心记录：user-service → [192.168.1.100:8080]

就像新店开业要向商场管理处报备一样
```

**🔸 服务发现**
```
服务调用时的操作：
1. 订单服务需要调用用户服务
2. 问注册中心："user-service在哪里？"
3. 注册中心返回：192.168.1.100:8080
4. 订单服务发起调用

就像顾客问导购台："手机店在几楼？"
```

**🔸 健康检查**
```
注册中心定期检查：
注册中心：你还活着吗？
用户服务：我很好！（心跳响应）

如果服务不响应：
注册中心：这个服务可能挂了，从列表中移除

就像商场管理员定期巡查哪些店还在营业
```

### 1.3 主流注册中心对比


| 特性 | **Eureka** | **Nacos** | **Consul** |
|------|-----------|-----------|-----------|
| 🏢 **出品方** | Netflix | 阿里巴巴 | HashiCorp |
| 🎯 **定位** | 专注服务发现 | 服务发现+配置管理 | 服务网格解决方案 |
| 📊 **CAP理论** | AP（可用性优先） | CP+AP可选 | CP（一致性优先） |
| 🌐 **适用场景** | Spring Cloud老项目 | 国内微服务首选 | 多语言环境 |
| 💪 **优势** | 简单易用，生态成熟 | 功能全面，中文友好 | 功能强大，多平台支持 |

**🎯 选择建议**：
- **新项目**：优先选Nacos（功能全、性能好、中文文档）
- **老项目**：已用Eureka就继续用（稳定可靠）
- **多语言团队**：考虑Consul（支持Java、Go、Python等）

---

## 2. 🔄 Eureka注册发现机制


### 2.1 Eureka架构图解


```
           Eureka Server（注册中心）
                   ┃
        ┏━━━━━━━━━━╋━━━━━━━━━━┓
        ┃          ┃          ┃
    服务注册    服务发现    心跳续约
        ┃          ┃          ┃
   ┌────▼────┐ ┌──▼───┐ ┌────▼────┐
   │用户服务  │ │订单服务│ │商品服务 │
   │8001端口 │ │8002   │ │8003    │
   └─────────┘ └───────┘ └─────────┘
```

### 2.2 Eureka工作流程详解


**🔸 服务注册流程**
```
步骤1：服务启动
用户服务(8001) 启动完成

步骤2：向Eureka注册
POST http://eureka-server:8761/eureka/apps/USER-SERVICE
{
  "instance": {
    "app": "USER-SERVICE",
    "ipAddr": "192.168.1.100",
    "port": 8001,
    "status": "UP"
  }
}

步骤3：Eureka记录
注册表新增：
USER-SERVICE:
  - 192.168.1.100:8001 (状态:UP)
```

**🔸 服务发现流程**
```
步骤1：订单服务需要调用用户服务
OrderService需要：GET /user/123

步骤2：查询Eureka
GET http://eureka-server:8761/eureka/apps/USER-SERVICE

步骤3：获取服务列表
返回：[
  {
    "ipAddr": "192.168.1.100",
    "port": 8001,
    "status": "UP"
  }
]

步骤4：发起调用
订单服务 → http://192.168.1.100:8001/user/123
```

### 2.3 核心配置示例


**Eureka Server配置**（注册中心）
```yaml
server:
  port: 8761  # Eureka默认端口

eureka:
  instance:
    hostname: localhost  # 主机名
  client:
    register-with-eureka: false  # 自己不注册自己
    fetch-registry: false        # 不拉取服务列表
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

**Eureka Client配置**（微服务）
```yaml
spring:
  application:
    name: user-service  # 服务名称

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # 注册中心地址
  instance:
    prefer-ip-address: true  # 使用IP注册
    lease-renewal-interval-in-seconds: 30    # 心跳间隔30秒
    lease-expiration-duration-in-seconds: 90 # 90秒未心跳则剔除
```

**💡 配置说明**：
- `lease-renewal-interval`：多久发一次心跳（默认30秒）
- `lease-expiration-duration`：多久没心跳就认为服务挂了（默认90秒）
- `prefer-ip-address`：用IP注册而不是主机名（推荐开启）

### 2.4 Eureka自我保护机制


**🔸 什么是自我保护**
```
正常情况：
Eureka收到的心跳 > 85%预期值 → 正常运行

网络故障：
Eureka收到的心跳 < 85%预期值 → 触发自我保护
↓
Eureka认为：可能是网络问题，不是服务真的挂了
↓
不会剔除任何服务，保留所有注册信息
```

**通俗理解**：
就像老师点名，突然发现只有一半学生应答。老师会想："可能是广播坏了，不是学生真的都逃课了"，所以不会立即记缺勤。

**🔸 自我保护的利弊**

优点：
- 防止网络抖动误删服务
- 提高系统可用性

缺点：
- 可能保留已经挂掉的服务
- 调用时可能失败

**🔸 开发环境建议**
```yaml
eureka:
  server:
    enable-self-preservation: false  # 开发时关闭自我保护
    eviction-interval-timer-in-ms: 5000  # 5秒清理一次失效服务
```

---

## 3. 🚀 Nacos服务发现配置


### 3.1 为什么选择Nacos


**Nacos相比Eureka的优势**：
```
┌─ Nacos全能选手 ─────────────────┐
│ ✅ 服务发现（替代Eureka）        │
│ ✅ 配置管理（替代Config）        │
│ ✅ 服务管理界面（更友好）        │
│ ✅ 命名空间隔离（环境区分）      │
│ ✅ 更好的性能（支持更多服务）    │
└──────────────────────────────────┘
```

### 3.2 Nacos架构图解


```
              Nacos Server集群
           ┌─────────────────────┐
           │  注册中心 + 配置中心 │
           └──────────┬──────────┘
                      ┃
        ┏━━━━━━━━━━━━━╋━━━━━━━━━━━━━┓
        ┃             ┃             ┃
    服务注册       配置订阅      健康检查
        ┃             ┃             ┃
   ┌────▼────┐   ┌────▼────┐   ┌───▼────┐
   │用户服务  │   │订单服务 │   │商品服务│
   └─────────┘   └─────────┘   └────────┘
```

### 3.3 Nacos服务注册配置


**项目依赖**（Maven）
```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

**配置文件**（application.yml）
```yaml
spring:
  application:
    name: user-service  # 服务名
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848  # Nacos地址
        namespace: dev                # 命名空间（环境隔离）
        group: DEFAULT_GROUP          # 分组
        username: nacos               # 认证用户名
        password: nacos               # 认证密码
```

**💡 命名空间说明**：
```
生产环境：namespace: prod
测试环境：namespace: test
开发环境：namespace: dev

作用：不同环境的服务互相看不见，避免误调用
就像公司不同部门的通讯录是分开的
```

### 3.4 Nacos服务发现使用


**方式1：RestTemplate + @LoadBalanced**
```java
@Configuration
public class RestConfig {
    
    @Bean
    @LoadBalanced  // 开启负载均衡
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

// 使用服务名调用
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public User getUser(Long userId) {
        // 直接用服务名，不用写IP和端口
        String url = "http://user-service/user/" + userId;
        return restTemplate.getForObject(url, User.class);
    }
}
```

**方式2：OpenFeign声明式调用**
```java
// 定义Feign客户端
@FeignClient(name = "user-service")
public interface UserClient {
    
    @GetMapping("/user/{id}")
    User getUserById(@PathVariable Long id);
}

// 直接注入使用
@Service
public class OrderService {
    
    @Autowired
    private UserClient userClient;
    
    public User getUser(Long userId) {
        return userClient.getUserById(userId);  // 像调本地方法一样
    }
}
```

**🎯 选择建议**：
- **简单调用**：用RestTemplate
- **复杂项目**：用OpenFeign（推荐）

### 3.5 Nacos配置中心功能


**配置动态刷新**
```yaml
# Nacos配置中心添加配置：
# Data ID: user-service-dev.yml
user:
  max-age: 18
  welcome-msg: 欢迎使用系统
```

**代码读取配置**
```java
@RestController
@RefreshScope  // 支持动态刷新
public class UserController {
    
    @Value("${user.max-age}")
    private Integer maxAge;
    
    @Value("${user.welcome-msg}")
    private String welcomeMsg;
    
    @GetMapping("/config")
    public String getConfig() {
        return "最大年龄: " + maxAge + ", 欢迎语: " + welcomeMsg;
    }
}
```

**💡 动态刷新效果**：
在Nacos界面修改配置后，不用重启服务，配置立即生效！

---

## 4. 🔗 Consul服务发现集成


### 4.1 Consul特点概述


**Consul的独特优势**：
```
┌─ Consul特色 ─────────────────────┐
│ 🌐 多数据中心支持                │
│ 🔒 强一致性保证（CP模型）        │
│ 🏥 内置健康检查                  │
│ 🔑 分布式KV存储                  │
│ 🌍 多语言客户端（Go/Java/Python）│
└───────────────────────────────────┘
```

### 4.2 Consul架构模式


```
         Consul Server集群（Leader选举）
              ┌────────────────┐
              │  Server Leader │
              └───────┬────────┘
                      ┃
            ┏━━━━━━━━━╋━━━━━━━━━┓
            ┃         ┃         ┃
       Server-1   Server-2  Server-3
            ┃         ┃         ┃
        ────┸─────────┸─────────┸────
            ┃         ┃         ┃
       Client-1   Client-2  Client-3
       (微服务)   (微服务)   (微服务)
```

### 4.3 Consul集成配置


**项目依赖**
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
```

**配置文件**
```yaml
spring:
  application:
    name: user-service
  cloud:
    consul:
      host: localhost      # Consul地址
      port: 8500           # Consul端口
      discovery:
        service-name: ${spring.application.name}
        health-check-interval: 10s  # 健康检查间隔
        health-check-path: /actuator/health  # 健康检查路径
        prefer-ip-address: true
```

**健康检查端点**
```java
// Spring Boot Actuator提供的健康检查
// 访问 http://localhost:8001/actuator/health
// 返回：{"status":"UP"}
```

### 4.4 Consul与Eureka/Nacos对比


```
一致性模型：
Eureka:  AP模型 → 网络分区时优先可用性
Nacos:   可配置 → 支持AP和CP两种模式
Consul:  CP模型 → 网络分区时优先一致性

实际影响：
AP模型：可能读到过期数据，但服务不会中断
CP模型：保证数据一致，但可能服务暂时不可用

选择建议：
金融系统：选CP（Consul/Nacos-CP）
电商系统：选AP（Eureka/Nacos-AP）
```

---

## 5. 📡 服务地址解析过程


### 5.1 完整解析流程图


```
客户端调用                           注册中心
   ┃                                   ┃
   ┃ 1.发起调用 http://user-service/user/1
   ┃                                   ┃
   ▼                                   ┃
[负载均衡器]                           ┃
   ┃                                   ┃
   ┃ 2.查询服务                        ┃
   ┠──────────────────────────────────▶┃
   ┃      "user-service在哪里？"       ┃
   ┃                                   ┃
   ┃ 3.返回服务列表                    ┃
   ┃◀──────────────────────────────────┨
   ┃  [192.168.1.10:8001,             ┃
   ┃   192.168.1.11:8001]             ┃
   ▼                                   ┃
[选择实例]                             ┃
   ┃ 4.负载均衡算法选择                ┃
   ┃    (轮询/随机/权重)               ┃
   ▼                                   ┃
[发起HTTP调用]                         ┃
   ┃ 5.http://192.168.1.10:8001/user/1
   ┠──────────────────────────────────▶[目标服务]
   ┃                                       ┃
   ┃ 6.返回结果                            ┃
   ┃◀──────────────────────────────────────┨
```

### 5.2 地址解析核心步骤


**步骤1：服务名称识别**
```
调用：http://user-service/user/1
                ↓
识别服务名：user-service
识别路径：/user/1
```

**步骤2：注册中心查询**
```
查询请求：
GET /nacos/v1/ns/instance/list?serviceName=user-service

返回数据：
{
  "hosts": [
    {
      "ip": "192.168.1.10",
      "port": 8001,
      "healthy": true,
      "weight": 1.0
    },
    {
      "ip": "192.168.1.11", 
      "port": 8001,
      "healthy": true,
      "weight": 2.0
    }
  ]
}
```

**步骤3：实例过滤**
```
过滤规则：
1. 剔除不健康的实例 (healthy=false)
2. 检查同一集群优先
3. 检查版本标签匹配

过滤后：
可用实例：[192.168.1.10:8001, 192.168.1.11:8001]
```

**步骤4：负载均衡选择**
```
常见策略：

轮询（Round Robin）：
第1次 → 192.168.1.10:8001
第2次 → 192.168.1.11:8001
第3次 → 192.168.1.10:8001 (循环)

随机（Random）：
随机数 → 选中任意一个

加权（Weight）：
权重1.0 → 33%概率
权重2.0 → 67%概率
```

### 5.3 本地缓存机制


**缓存策略**：
```
首次调用：
客户端 → 注册中心查询 → 缓存到本地

后续调用：
客户端 → 读取本地缓存 → 直接使用

定期更新：
每30秒 → 从注册中心刷新 → 更新本地缓存

注册中心挂了：
客户端 → 使用本地缓存 → 继续服务（降级）
```

**💡 缓存的好处**：
- 减少注册中心压力（不用每次都查询）
- 提高调用速度（本地读取更快）
- 提高可用性（注册中心故障也能用）

---

## 6. 🔍 调用链路追踪流程


### 6.1 为什么需要链路追踪


**微服务调用复杂性**：
```
用户下单流程：
客户端 → 订单服务 → 用户服务 → 商品服务 → 库存服务
                  ↓           ↓
               优惠服务     积分服务

问题：
1. 整个流程耗时5秒，慢在哪里？
2. 某个环节失败了，怎么定位？
3. 调用了哪些服务，顺序是什么？

链路追踪的作用：
记录完整调用路径，分析性能瓶颈，快速定位问题
```

### 6.2 链路追踪关键概念


**🔸 Trace（调用链）**
```
一次完整的用户请求 = 一个Trace

TraceID: 550e8400-e29b-41d4-a716-446655440000
代表从用户点击到返回结果的完整链路
```

**🔸 Span（调用段）**
```
每个服务处理 = 一个Span

例如：
Span1: 订单服务处理 (耗时100ms)
Span2: 调用用户服务 (耗时50ms)  
Span3: 调用商品服务 (耗时200ms)
```

**🔸 父子关系**
```
订单服务Span
    ├── 用户服务Span（子）
    ├── 商品服务Span（子）
    └── 库存服务Span（子）
```

### 6.3 Sleuth链路追踪配置


**添加依赖**
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
```

**日志自动增强**
```
添加Sleuth前：
2024-01-15 10:30:00 INFO  处理订单请求

添加Sleuth后：
2024-01-15 10:30:00 INFO [order-service,550e8400,8a9b12cd] 处理订单请求
                         [服务名,TraceID,SpanID]

好处：
所有相关日志都有相同TraceID，方便关联查询
```

### 6.4 Zipkin可视化追踪


**Zipkin集成配置**
```yaml
spring:
  zipkin:
    base-url: http://localhost:9411  # Zipkin服务地址
  sleuth:
    sampler:
      probability: 1.0  # 采样率100%（生产环境建议0.1）
```

**Zipkin界面功能**：
```
1. 查看调用链路图
   订单服务(100ms) → 用户服务(50ms)
                   → 商品服务(200ms)
                   
2. 分析耗时分布
   总耗时350ms：
   - 订单服务自身：100ms (28%)
   - 用户服务调用：50ms (14%)
   - 商品服务调用：200ms (58%) ← 性能瓶颈！

3. 错误定位
   红色标记：商品服务调用失败
   点击查看详细错误信息
```

---

## 7. ❤️ 服务健康检查机制


### 7.1 健康检查的重要性


**为什么需要健康检查**：
```
场景1：服务假死
服务进程在运行 → 但已经无法处理请求
如果没有健康检查 → 注册中心认为服务正常
结果：请求打到假死服务 → 调用失败

场景2：依赖故障
数据库连接断开 → 服务无法正常工作
健康检查发现异常 → 注册中心摘除该实例
结果：流量转到其他正常实例
```

### 7.2 健康检查方式对比


**🔸 心跳检查（被动）**
```
服务 → 注册中心："我还活着"（每30秒）
注册中心：好的，记录下来

优点：实现简单，开销小
缺点：只知道服务进程活着，不知道功能是否正常
```

**🔸 主动探测（健康检查端点）**
```
注册中心 → 服务："/health端点，你健康吗？"（每10秒）
服务 → 检查数据库、Redis等 → 返回健康状态

优点：能真正判断服务是否可用
缺点：检查频繁，有一定开销
```

### 7.3 Spring Boot健康检查


**默认健康检查**
```java
// 引入Actuator依赖
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

// 配置健康检查端点
management:
  endpoints:
    web:
      exposure:
        include: health  # 暴露健康检查端点
  endpoint:
    health:
      show-details: always  # 显示详细信息
```

**访问健康检查**
```
GET http://localhost:8001/actuator/health

返回：
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "MySQL",
        "validationQuery": "isValid()"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 500GB,
        "free": 200GB
      }
    }
  }
}
```

### 7.4 自定义健康检查


**业务健康检查**
```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    @Override
    public Health health() {
        try {
            // 检查Redis连接
            redisTemplate.opsForValue().get("health-check");
            
            // 检查业务指标（比如队列积压）
            Long queueSize = getQueueSize();
            if (queueSize > 10000) {
                return Health.down()
                    .withDetail("queueSize", queueSize)
                    .withDetail("reason", "队列积压严重")
                    .build();
            }
            
            return Health.up()
                .withDetail("queueSize", queueSize)
                .build();
                
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

**健康检查结果**：
```
健康状态：UP → 服务可用
健康状态：DOWN → 注册中心摘除实例

实际效果：
Redis挂了 → health返回DOWN → 该实例被摘除
其他实例正常 → 流量自动转移 → 用户无感知
```

---

## 8. 🔄 动态服务列表维护


### 8.1 服务列表更新机制


**服务上线流程**：
```
时刻1：新实例启动
192.168.1.12:8001 启动 → 向Nacos注册

时刻2：注册中心更新
Nacos收到注册 → 更新服务列表
user-service: [10:8001, 11:8001, 12:8001]

时刻3：客户端感知
订单服务 → 30秒后刷新缓存 → 发现新实例
下次调用 → 可能路由到新实例
```

**服务下线流程**：
```
时刻1：实例停止
192.168.1.12:8001 执行shutdown

时刻2：主动注销
服务 → Nacos："我要下线"
Nacos → 立即从列表移除

时刻3：客户端更新
订单服务 → 收到服务列表变更通知
立即更新缓存 → 不再路由到已下线实例
```

### 8.2 服务列表缓存策略


**三级缓存架构**：
```
Level 1: 注册中心（权威数据）
Nacos Server → 最新最准确的服务列表

Level 2: 客户端本地缓存（定期更新）
订单服务本地 → 每30秒同步一次

Level 3: Ribbon本地缓存（实时选择）
负载均衡器 → 从Level 2读取，快速选择实例
```

**缓存更新时机**：
```
1. 定时刷新（默认30秒）
   客户端 → 主动拉取最新列表

2. 推送更新（部分支持）
   Nacos → 推送变更 → 客户端立即更新

3. 调用失败时（兜底）
   调用出错 → 立即刷新列表 → 重试其他实例
```

### 8.3 服务剔除与恢复


**自动剔除机制**：
```
健康检查失败：
Nacos检查 → 192.168.1.11:8001 不健康
标记状态 → healthy: false
客户端刷新 → 不会路由到该实例

心跳超时：
90秒未收到心跳 → 认为服务宕机
从注册表删除 → 彻底移除
```

**自动恢复机制**：
```
服务恢复：
192.168.1.11:8001 重新启动
向Nacos注册 → 健康检查通过
添加到服务列表 → 重新接收流量

临时下线恢复：
服务被标记不健康 → 但进程未停止
问题修复 → 健康检查通过
状态变为UP → 自动恢复服务
```

### 8.4 灰度发布与流量控制


**灰度发布场景**：
```
版本升级策略：

阶段1：10%流量新版本
user-service-v2: 1个实例 (10%权重)
user-service-v1: 9个实例 (90%权重)

阶段2：50%流量新版本
v2: 5个实例
v1: 5个实例

阶段3：100%新版本
v2: 10个实例
v1: 全部下线
```

**权重配置示例**（Nacos）
```yaml
spring:
  cloud:
    nacos:
      discovery:
        weight: 0.5  # 设置权重0.5，只接收一半流量
```

**版本路由配置**
```yaml
# 通过元数据标记版本
spring:
  cloud:
    nacos:
      discovery:
        metadata:
          version: v2  # 版本标签
          region: beijing  # 区域标签
```

---

## 9. 📋 核心要点总结


### 9.1 服务注册发现必知必会


**🎯 核心概念**
```
✅ 服务注册中心：微服务的"通讯录"，管理所有服务地址
✅ 服务注册：服务启动时主动报告自己的位置
✅ 服务发现：调用时查询目标服务的地址列表
✅ 健康检查：定期检查服务是否正常，自动剔除故障实例
✅ 负载均衡：从多个实例中选择一个进行调用
```

**🔸 三大注册中心对比**
```
Eureka：老牌稳定，AP模型，适合老项目
Nacos：功能全面，配置+注册，国内首选
Consul：多语言，CP模型，适合多技术栈
```

### 9.2 服务调用完整链路


```
完整调用流程：

1️⃣ 服务启动 → 注册到注册中心
2️⃣ 客户端调用 → 使用服务名而非IP
3️⃣ 查询注册中心 → 获取服务实例列表
4️⃣ 负载均衡选择 → 挑选一个健康实例
5️⃣ 发起HTTP调用 → 访问具体服务
6️⃣ 链路追踪记录 → 记录调用路径和耗时
7️⃣ 健康检查 → 持续监控服务状态
8️⃣ 动态更新列表 → 服务上下线自动感知
```

### 9.3 关键配置清单


**Nacos核心配置**
```yaml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848    # 注册中心地址
        namespace: dev                  # 环境隔离
        weight: 1.0                     # 负载权重
        
# 健康检查配置
management:
  endpoints:
    web:
      exposure:
        include: health
        
# 链路追踪配置        
spring:
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 0.1  # 10%采样
```

### 9.4 最佳实践建议


**📌 开发环境建议**
```
✅ 关闭Eureka自我保护（快速剔除故障实例）
✅ 缩短心跳间隔（快速发现问题）
✅ 开启详细健康检查（了解服务状态）
✅ 100%链路采样（完整追踪）
```

**📌 生产环境建议**
```
✅ 注册中心集群部署（高可用）
✅ 适当的心跳间隔（平衡性能与及时性）
✅ 低采样率追踪（10%左右，减少性能影响）
✅ 配置优雅下线（避免请求丢失）
✅ 监控服务健康状态（及时发现问题）
```

### 9.5 常见问题与解决


**❓ 服务调用失败怎么办**
```
1. 检查服务是否注册成功（查看注册中心）
2. 检查服务名是否正确（大小写敏感）
3. 检查网络是否连通（ping测试）
4. 检查健康检查是否通过（查看/health端点）
```

**❓ 服务列表不更新**
```
1. 检查缓存刷新时间（默认30秒）
2. 检查是否开启服务发现（enabled: true）
3. 尝试手动刷新（重启客户端）
```

**❓ 负载不均衡**
```
1. 检查实例权重配置
2. 检查负载均衡策略
3. 检查是否有实例被标记不健康
```

**核心记忆口诀**：
```
注册中心是通讯录，服务上线要报告
健康检查保可用，负载均衡流量调
链路追踪找问题，动态列表自动搞
```