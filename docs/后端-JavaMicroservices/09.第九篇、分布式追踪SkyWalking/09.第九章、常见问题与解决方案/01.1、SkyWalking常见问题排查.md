---
title: 1、SkyWalking常见问题排查
---
## 📚 目录

1. [Trace追踪丢失问题](#1-Trace追踪丢失问题)
2. [上下文丢失问题](#2-上下文丢失问题)
3. [UI界面卡顿问题](#3-UI界面卡顿问题)
4. [OAP性能瓶颈](#4-OAP性能瓶颈)
5. [存储压力问题](#5-存储压力问题)
6. [插件冲突问题](#6-插件冲突问题)
7. [配置错误问题](#7-配置错误问题)
8. [网络连接问题](#8-网络连接问题)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔍 Trace追踪丢失问题


### 1.1 什么是Trace丢失


> **💡 新手理解**  
> Trace丢失就像你在超市里购物，本来应该有监控记录你的整个购物过程（进门→选商品→结账→出门），但最后发现监控录像缺了一段。在SkyWalking里，就是你的请求调用链路没有被完整记录下来。

**常见表现**：
- 🔴 UI界面看不到某些服务的调用记录
- 🔴 调用链路断开，只能看到部分节点
- 🔴 某些时间段的数据完全缺失
- 🔴 Span数据不完整

### 1.2 为什么会丢失Trace


**🔸 原因分析**：

```
常见原因排查顺序：

1. Agent未正确启动
   应用服务 → Agent未生效 → 没有采集数据
   
2. 采样率设置过低
   100个请求 → 采样10% → 只记录10个 → 其余90个"丢失"
   
3. 网络传输失败
   Agent → 网络问题 → OAP → 数据传输中断
   
4. OAP处理能力不足
   大量数据 → OAP忙不过来 → 丢弃部分数据
```

**原因对照表**：

| 丢失类型 | 典型现象 | 根本原因 | 影响范围 |
|---------|---------|---------|---------|
| **全量丢失** | 完全看不到数据 | Agent未启动 | 该服务所有请求 |
| **部分丢失** | 数据时有时无 | 采样率/网络问题 | 随机请求 |
| **间歇丢失** | 某时段无数据 | OAP重启/故障 | 特定时间段 |
| **链路断裂** | 看到部分节点 | 跨线程/异步调用 | 特定调用路径 |

### 1.3 排查步骤


**🔧 第一步：确认Agent是否正常**

```bash
# 检查应用启动日志，应该看到类似输出
[skywalking-agent] SkyWalking agent initialized successfully
[skywalking-agent] Service name: order-service
[skywalking-agent] Connected to OAP server: 192.168.1.100:11800

# 如果没有这些日志，说明Agent没启动
```

> **⚠️ 新手提醒**  
> Agent就像一个"监控摄像头"，如果摄像头本身没通电，当然录不到任何东西。首先要确保Agent正常工作。

**🔧 第二步：检查采样率配置**

```properties
# agent.config 配置文件
agent.sample_n_per_3_secs=9

# 这个配置的意思：
# 每3秒钟最多采样9条Trace
# 如果你的服务QPS很高（比如每秒100个请求）
# 那么大部分请求都不会被记录，看起来就"丢失"了
```

**采样率影响示意**：
```
QPS = 100请求/秒
采样率 = 9条/3秒 = 3条/秒

实际记录率：
100个请求 → 只记录3个 → 记录率仅3%
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ████████████████████████████████  (100个请求)
  ███                                (3个被记录)
```

**🔧 第三步：检查网络连通性**

```bash
# 在应用服务器上测试到OAP的连接
telnet oap-server 11800

# 正常应该显示：Connected to oap-server
# 如果失败，说明网络不通
```

**🔧 第四步：查看OAP日志**

```bash
# 检查OAP是否有报错
tail -f oap-server/logs/skywalking-oap-server.log

# 关注这些关键词：
# - "OutOfMemoryError" → 内存不足
# - "Connection refused" → 存储连接失败
# - "Timeout" → 处理超时
```

### 1.4 解决方案


**💊 解决方案速查**：

| 问题场景 | 快速解决 | 详细说明 |
|---------|---------|---------|
| Agent未启动 | 检查JVM参数 | 确保`-javaagent`参数正确 |
| 采样率过低 | 调整采样配置 | 提高`sample_n_per_3_secs`值 |
| 网络不通 | 检查防火墙 | 开放11800端口 |
| OAP过载 | 扩容OAP | 增加OAP实例数量 |

**具体操作**：

```yaml
# 1. 调整采样率（适合生产环境）
agent.sample_n_per_3_secs=30  # 原来是9，提高到30

# 2. 或者改用其他采样策略
# 概率采样：1000表示1/1000的采样率
agent.sample_rate=1000

# 3. 特殊场景全量采样（仅用于测试）
agent.sample_n_per_3_secs=-1  # -1表示全量采样
```

> **🎯 实战建议**  
> - 开发环境：可以全量采样（-1），方便调试
> - 测试环境：中等采样（每3秒30-50条）
> - 生产环境：保守采样（每3秒10-20条），避免性能影响

---

## 2. 🔗 上下文丢失问题


### 2.1 什么是上下文丢失


> **💡 通俗解释**  
> 想象你在接力赛跑，每个人都要把接力棒传给下一个人。上下文就像这个接力棒，里面装着"这是哪个请求"的信息。如果接力棒掉了（上下文丢失），下一个人就不知道自己在跑哪场比赛了。

**表现症状**：
- 调用链断裂，看不到完整的调用路径
- TraceID丢失，无法关联前后调用
- 跨线程调用后链路中断

**上下文传递示意**：
```
正常情况（上下文完整传递）：
服务A → [TraceID:123] → 服务B → [TraceID:123] → 服务C
  ↓                       ↓                       ↓
记录Span1              记录Span2              记录Span3
         完整的调用链路，同一个TraceID

异常情况（上下文丢失）：
服务A → [TraceID:123] → 服务B → [TraceID:???] → 服务C
  ↓                       ↓                       ↓
记录Span1              记录Span2              记录Span3
         链路断裂，无法关联
```

### 2.2 什么场景会丢失上下文


**🔸 高危场景清单**：

**场景1：异步调用**
```java
// ❌ 错误示例：新线程里上下文会丢失
@GetMapping("/async")
public String asyncCall() {
    // 主线程有上下文
    new Thread(() -> {
        // 新线程里没有上下文了！
        restTemplate.getForObject("http://user-service/user", String.class);
    }).start();
    return "ok";
}
```

**场景2：线程池调用**
```java
// ❌ 错误示例：线程池复用线程，上下文会混乱
@Autowired
private ExecutorService executor;

@GetMapping("/pool")
public String poolCall() {
    executor.submit(() -> {
        // 这里的上下文可能是上一个任务的，或者根本没有
        orderService.createOrder();
    });
    return "ok";
}
```

**场景3：MQ消息消费**
```
生产者 → [发送消息到MQ] → MQ → [消费者接收]
  有上下文                     上下文断了
```

### 2.3 如何解决上下文丢失


**💊 解决方案一：使用SkyWalking提供的工具类**

```java
// ✅ 正确示例：手动传递上下文
import org.apache.skywalking.apm.toolkit.trace.RunnableWrapper;

@GetMapping("/async-fix")
public String asyncCallFix() {
    // 用RunnableWrapper包装任务，自动传递上下文
    new Thread(RunnableWrapper.of(() -> {
        // 现在有上下文了
        restTemplate.getForObject("http://user-service/user", String.class);
    })).start();
    return "ok";
}
```

**💊 解决方案二：使用@Trace注解**

```java
import org.apache.skywalking.apm.toolkit.trace.Trace;

@Service
public class OrderService {
    
    // 加上@Trace注解，SkyWalking会自动创建新的Span
    @Trace
    public void processOrder() {
        // 即使是异步调用，也能追踪
        // ...
    }
}
```

**💊 解决方案三：MQ场景的处理**

```java
// 生产者：手动传递TraceID
@Autowired
private RabbitTemplate rabbitTemplate;

public void sendMessage() {
    // 获取当前TraceID
    String traceId = TraceContext.traceId();
    
    // 放到消息头里
    MessageProperties props = new MessageProperties();
    props.setHeader("sw-trace-id", traceId);
    
    Message message = new Message("订单数据".getBytes(), props);
    rabbitTemplate.send("order-queue", message);
}

// 消费者：恢复上下文
@RabbitListener(queues = "order-queue")
public void receiveMessage(Message message) {
    // 从消息头取出TraceID
    String traceId = message.getMessageProperties()
        .getHeader("sw-trace-id");
    
    // 恢复上下文（需要自定义实现）
    // ...
}
```

> **📌 记忆要点**  
> **三种上下文传递方式**：
> 1. **Wrapper包装** - 用RunnableWrapper包装异步任务
> 2. **注解标记** - 用@Trace标记需要追踪的方法
> 3. **手动传递** - 通过消息头等方式手动传递TraceID

---

## 3. 🐌 UI界面卡顿问题


### 3.1 为什么UI会卡顿


> **💡 形象比喻**  
> SkyWalking UI就像一个超市的收银系统。如果数据量太大（顾客太多），或者后台数据库太慢（收银员动作慢），整个界面就会卡。

**卡顿原因分层**：
```
用户访问 → UI前端 → OAP后端 → 存储数据库

可能卡在哪里？
┌─────────────────────────────────────┐
│ 第1层：浏览器性能差                   │
│  → 内存不足，JS执行慢                │
├─────────────────────────────────────┤
│ 第2层：UI服务负载高                   │
│  → 并发访问多，响应慢                │
├─────────────────────────────────────┤
│ 第3层：OAP查询慢                      │
│  → 数据量大，计算复杂                │
├─────────────────────────────────────┤
│ 第4层：存储响应慢                     │
│  → ES/MySQL查询慢                    │
└─────────────────────────────────────┘
```

### 3.2 定位卡顿原因


**🔧 诊断步骤**：

**Step 1：检查浏览器性能**
```
打开浏览器开发者工具（F12）
→ Network标签
→ 看各个请求的响应时间

正常情况：<1秒
慢速情况：>3秒  ← 这就是卡顿点
```

**Step 2：检查OAP日志**
```bash
# 查看OAP日志里的查询时间
grep "query cost" oap-server/logs/skywalking-oap-server.log

# 看到类似输出：
# Query trace list cost 5234ms  ← 查询用了5秒多，很慢！
```

**Step 3：检查存储性能**
```bash
# 如果用的是ElasticSearch
curl http://es-server:9200/_cluster/health

# 关注这些指标：
# status: green（正常）/ yellow（警告）/ red（严重）
# active_shards: 活跃分片数
# number_of_pending_tasks: 等待处理的任务数
```

### 3.3 解决UI卡顿


**💊 针对性解决方案**：

| 卡顿原因 | 优化方案 | 效果 |
|---------|---------|-----|
| 数据量太大 | 缩短查询时间范围 | ⭐⭐⭐⭐⭐ |
| ES查询慢 | 增加ES节点 | ⭐⭐⭐⭐ |
| OAP计算慢 | 增加OAP实例 | ⭐⭐⭐ |
| 浏览器性能差 | 换更好的浏览器 | ⭐⭐ |

**具体优化**：

```yaml
# 1. 调整UI查询默认时间范围
# webapp/webapp.yml
server:
  port: 8080
  
# 修改默认查询范围从24小时改为1小时
query:
  default-time-range: 1h  # 原来是24h
  max-time-range: 3h      # 最大允许查询3小时
```

```yaml
# 2. 启用查询缓存
storage:
  elasticsearch:
    # 开启查询结果缓存
    resultWindowMaxSize: 10000
    metadataQueryMaxSize: 5000
    # 缓存查询结果
    queryCache: true
```

> **🎯 最佳实践**  
> **降低UI卡顿的三板斧**：
> 1. **缩小范围** - 查询时间从24小时缩到1-3小时
> 2. **加缓存** - 重复查询直接走缓存
> 3. **扩容** - ES和OAP集群扩容

---

## 4. ⚡ OAP性能瓶颈


### 4.1 OAP的工作原理


> **💡 理解OAP**  
> OAP（Observability Analysis Platform）就是SkyWalking的"大脑"，负责：
> - 接收Agent发来的数据（像快递收货站）
> - 分析处理数据（像数据处理工厂）
> - 存储到数据库（像仓库管理）
> - 响应UI查询（像客服查询系统）

**OAP工作流程**：
```
Agent们 → OAP → 存储
  ↓        ↓      ↓
发数据   处理   保存
         分析
         聚合

具体流程：
1. Agent发送 → gRPC接收（11800端口）
2. 数据解析 → Trace/Metric数据
3. 聚合计算 → 分钟级汇总
4. 持久化  → 写入ES/MySQL
5. 响应查询 → 给UI返回数据
```

### 4.2 OAP性能瓶颈表现


**🔴 典型症状**：

```
症状1：内存溢出
错误日志：java.lang.OutOfMemoryError: Java heap space
原因：处理的数据量超过内存容量

症状2：CPU使用率100%
现象：OAP进程CPU占用持续在90%以上
原因：聚合计算量太大

症状3：数据处理延迟
现象：Agent发送的数据，10分钟后才能在UI看到
原因：OAP处理队列积压

症状4：查询超时
错误：Query timeout after 30s
原因：数据库查询太慢
```

**性能监控指标**：

| 指标 | 正常值 | 告警值 | 危险值 |
|-----|--------|--------|--------|
| **内存使用率** | <70% | >80% | >90% |
| **CPU使用率** | <60% | >75% | >90% |
| **GC频率** | <1次/分钟 | >5次/分钟 | >10次/分钟 |
| **处理延迟** | <10秒 | >30秒 | >60秒 |

### 4.3 性能优化方案


**🚀 优化策略**：

**策略1：调整JVM参数**
```bash
# OAP启动脚本添加JVM参数
export JAVA_OPTS="
  -Xms4g              # 最小堆内存4G
  -Xmx4g              # 最大堆内存4G（和最小值一样，避免动态扩容）
  -XX:+UseG1GC        # 使用G1垃圾回收器
  -XX:MaxGCPauseMillis=200  # GC最大暂停时间200ms
  -XX:+HeapDumpOnOutOfMemoryError  # OOM时生成堆转储
"
```

**策略2：减少数据处理量**
```yaml
# application.yml
core:
  default:
    # 减少数据保存时间
    recordDataTTL: 3        # 原来7天，改为3天
    metricsDataTTL: 7       # 原来30天，改为7天
    
    # 减少聚合粒度
    downsampling: Hour      # 只保留小时级聚合
```

**策略3：OAP集群化**
```
单OAP架构：
  所有Agent → OAP单点 → 容易过载

集群架构：
  Agent1 → OAP-1 ↘
  Agent2 → OAP-2 → 负载均衡 → 存储
  Agent3 → OAP-3 ↗
```

```yaml
# OAP集群配置
cluster:
  standalone:
  # 改为集群模式
  nacos:
    serviceName: ${SW_SERVICE_NAME:"SkyWalking_OAP_Cluster"}
    hostPort: ${SW_CLUSTER_NACOS_HOST_PORT:localhost:8848}
    namespace: ${SW_CLUSTER_NACOS_NAMESPACE:"public"}
```

> **📊 性能提升效果**  
> - 调整JVM：性能提升 20-30%
> - 减少数据量：性能提升 30-50%
> - 集群化：性能提升 200-300%（3节点）

---

## 5. 💾 存储压力问题


### 5.1 存储压力是什么


> **💡 简单理解**  
> 就像你的手机存储空间，用着用着就满了。SkyWalking也一样，每天产生大量监控数据，存储空间会越来越紧张，查询也越来越慢。

**存储压力的表现**：
```
初期（数据量小）：
磁盘：100GB → 使用10GB → 很宽裕 ✅
查询：1秒内响应 → 很快 ✅

中期（数据量增长）：
磁盘：100GB → 使用60GB → 有点紧张 ⚠️
查询：3-5秒响应 → 开始变慢 ⚠️

后期（数据爆炸）：
磁盘：100GB → 使用95GB → 快满了 🔴
查询：>10秒或超时 → 很慢 🔴
```

### 5.2 为什么存储压力大


**🔸 数据增长速度**：

```
举例：一个中等规模的微服务系统
- 服务数量：20个
- QPS总量：10000/秒
- 采样率：10%
- 每天产生的Trace数量：
  10000 × 0.1 × 86400 = 86,400,000条

数据量估算：
每条Trace平均大小：2KB
每天数据量：86400000 × 2KB ≈ 160GB/天 😱
```

**存储空间占用排行**：

| 数据类型 | 占比 | 特点 | 重要性 |
|---------|-----|------|--------|
| **Trace数据** | 60% | 最大头，增长最快 | ⭐⭐⭐ |
| **Metric指标** | 25% | 时序数据，聚合后较小 | ⭐⭐⭐⭐ |
| **日志数据** | 10% | 可选，不开就没有 | ⭐⭐ |
| **拓扑数据** | 5% | 很小，基本可忽略 | ⭐⭐⭐⭐⭐ |

### 5.3 存储优化方案


**💊 解决方案汇总**：

**方案1：自动清理过期数据**
```yaml
# application.yml
core:
  default:
    # Trace数据保留3天
    recordDataTTL: ${SW_CORE_RECORD_DATA_TTL:3}
    
    # Metrics数据保留7天
    metricsDataTTL: ${SW_CORE_METRICS_DATA_TTL:7}
    
    # 每天凌晨2点清理
    persistentPeriod: ${SW_CORE_PERSISTENT_PERIOD:2}
```

> **⚠️ 注意**  
> TTL设置太短（比如1天），可能导致问题排查困难；设置太长（比如30天），存储压力大。**一般建议3-7天**。

**方案2：使用更高效的存储**
```
存储方案对比：

H2（默认）：
优点：无需安装，开箱即用
缺点：性能差，只适合测试
容量：<10GB

MySQL：
优点：稳定可靠，易管理
缺点：大数据量下性能一般
容量：<100GB

ElasticSearch（推荐）：
优点：查询快，扩展性好
缺点：需要运维ES集群
容量：>1TB
```

**ElasticSearch配置示例**：
```yaml
storage:
  elasticsearch:
    nameSpace: ${SW_NAMESPACE:"skywalking"}
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}
    
    # 数据分片优化
    indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:3}
    indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:1}
    
    # 批量写入优化
    bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:5000}
    bulkSize: ${SW_STORAGE_ES_BULK_SIZE:20}
```

**方案3：分层存储**
```
数据分层策略：

热数据（最近3天）：
存储：高性能SSD
查询：秒级响应
保留：全量Trace

温数据（3-7天）：
存储：普通SSD
查询：可接受延迟
保留：采样Trace（10%）

冷数据（>7天）：
存储：对象存储（OSS）
查询：不支持
保留：仅Metric聚合数据
```

> **🎯 最佳实践**  
> **存储优化三步走**：
> 1. **设置TTL** - 自动清理老数据
> 2. **换ES** - 提升查询性能
> 3. **分层存储** - 降低存储成本

---

## 6. 🔌 插件冲突问题


### 6.1 什么是插件冲突


> **💡 通俗解释**  
> SkyWalking Agent就像一个"工具箱"，里面有很多"工具"（插件）。每个插件负责监控一种技术（比如MySQL插件监控数据库，Dubbo插件监控RPC调用）。但有时候不同工具会"打架"，导致冲突。

**插件工作原理**：
```
应用代码：
public void queryUser() {
    jdbcTemplate.query("SELECT * FROM user");
}

SkyWalking插件介入：
public void queryUser() {
    // ← MySQL插件在这里插入监控代码
    jdbcTemplate.query("SELECT * FROM user");
    // ← 记录SQL执行时间、参数等
}
```

### 6.2 常见插件冲突场景


**🔴 场景1：同类插件重复加载**
```
问题描述：
同时加载了 mysql-8.x-plugin 和 mysql-5.x-plugin
导致同一个SQL被记录两次

表现：
UI上看到重复的Span，TraceID相同但Span重复
```

**🔴 场景2：插件版本不匹配**
```
问题描述：
应用使用 Spring Boot 2.7.x
但加载的是 SpringMVC 3.x-plugin

表现：
启动报错：NoSuchMethodError
或者监控数据完全不准确
```

**🔴 场景3：插件和字节码增强冲突**
```
问题描述：
应用同时使用了：
- SkyWalking Agent（字节码增强）
- 其他APM工具（如Pinpoint、也用字节码增强）

表现：
启动失败，或者行为异常
```

### 6.3 如何排查插件冲突


**🔧 排查步骤**：

**Step 1：查看已加载的插件**
```bash
# 应用启动日志会显示加载的插件
[skywalking-agent] Load plugin: apm-mysql-8.x-plugin
[skywalking-agent] Load plugin: apm-spring-webmvc-plugin
[skywalking-agent] Load plugin: apm-dubbo-plugin

# 如果看到同类插件重复，就是冲突了
[skywalking-agent] Load plugin: apm-mysql-8.x-plugin
[skywalking-agent] Load plugin: apm-mysql-5.x-plugin  ← 重复了！
```

**Step 2：检查插件版本兼容性**
```bash
# 查看Agent版本
ls skywalking-agent/

# 输出示例：
# skywalking-agent.jar
# plugins/
#   ├── apm-mysql-8.x-plugin-9.0.0.jar
#   ├── apm-spring-webmvc-plugin-9.0.0.jar

# 版本号应该一致（都是9.0.0）
```

**Step 3：启用插件调试日志**
```properties
# agent.config
logging.level=DEBUG

# 重启后会输出详细的插件加载信息
```

### 6.4 解决插件冲突


**💊 解决方案**：

**方案1：禁用冲突插件**
```bash
# 移除不需要的插件（移到optional-plugins目录）
mv plugins/apm-mysql-5.x-plugin-9.0.0.jar optional-plugins/

# 或者在配置里禁用
```

```properties
# agent.config
# 禁用指定插件（用逗号分隔）
plugin.exclude_plugins=mysql-5.x,tomcat-7.x
```

**方案2：升级插件版本**
```bash
# 下载匹配的Agent版本
wget https://downloads.apache.org/skywalking/9.0.0/apache-skywalking-java-agent-9.0.0.tgz

# 解压并替换
tar -zxvf apache-skywalking-java-agent-9.0.0.tgz
cp -r skywalking-agent/* /path/to/your/agent/
```

**方案3：使用插件选择器**
```properties
# agent.config
# 只启用需要的插件（白名单模式）
plugin.include_plugins=mysql-8.x,spring-webmvc-5.x,dubbo
```

**插件选择对照表**：

| 技术栈 | 推荐插件 | 禁用插件 |
|-------|---------|---------|
| MySQL 8.x | mysql-8.x-plugin | mysql-5.x-plugin |
| Spring Boot 2.x | spring-webmvc-5.x | spring-webmvc-3.x/4.x |
| Dubbo 3.x | dubbo-3.x-plugin | dubbo-2.x-plugin |
| Tomcat 9.x | tomcat-9.x-plugin | tomcat-7.x/8.x |

> **📌 防冲突原则**  
> 1. **保持版本一致** - Agent和插件版本要匹配
> 2. **按需加载** - 只启用需要的插件
> 3. **定期检查** - 升级时验证兼容性

---

## 7. ⚙️ 配置错误问题


### 7.1 常见配置错误


> **💡 配置的重要性**  
> 配置文件就像设备说明书，写错了设备就无法正常工作。SkyWalking有很多配置项，一个地方配错，整个系统就会出问题。

**高频配置错误TOP 5**：

**❌ 错误1：服务名配置错误**
```properties
# agent.config
# 错误示例：
agent.service_name=${SW_AGENT_NAME:}  # 空值！

# 后果：UI上看不到服务名，或者显示为"Unknown"
```

```properties
# 正确配置：
agent.service_name=${SW_AGENT_NAME:order-service}
# 或者在启动参数里指定：
java -javaagent:/path/to/agent.jar 
     -DSW_AGENT_NAME=order-service 
     -jar app.jar
```

**❌ 错误2：OAP地址配置错误**
```properties
# agent.config
# 错误示例：
collector.backend_service=${SW_AGENT_COLLECTOR_BACKEND_SERVICES:}

# 后果：Agent找不到OAP，数据发不出去
```

```properties
# 正确配置：
collector.backend_service=${SW_AGENT_COLLECTOR_BACKEND_SERVICES:192.168.1.100:11800}

# 多OAP集群配置：
collector.backend_service=192.168.1.100:11800,192.168.1.101:11800,192.168.1.102:11800
```

**❌ 错误3：采样配置不合理**
```properties
# 错误示例：
agent.sample_n_per_3_secs=0  # 不采样，啥都看不到！

# 或者：
agent.sample_n_per_3_secs=999999  # 全量采样，Agent压力巨大！
```

**❌ 错误4：日志级别配置错误**
```properties
# 错误示例：
logging.level=TRACE  # 最详细的日志，日志文件巨大

# 后果：
# - 磁盘很快被占满
# - 应用性能下降（写日志很耗资源）
```

**❌ 错误5：存储连接配置错误**
```yaml
# application.yml（OAP配置）
# 错误示例：
storage:
  elasticsearch:
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:}  # 空值

# 后果：OAP启动失败，报错找不到存储
```

### 7.2 配置验证方法


**🔧 验证清单**：

```markdown
✅ 启动前验证：

1. 【Agent配置】
   - [ ] service_name 已设置
   - [ ] collector.backend_service 已设置
   - [ ] 采样率合理（10-50之间）
   - [ ] 日志级别为INFO或WARN

2. 【OAP配置】
   - [ ] 存储地址已配置
   - [ ] 端口未被占用（11800/12800）
   - [ ] JVM内存参数合理

3. 【UI配置】
   - [ ] OAP地址已配置
   - [ ] 端口未被占用（8080）
```

**验证命令**：
```bash
# 1. 检查Agent配置文件语法
grep "service_name" agent.config
grep "collector.backend_service" agent.config

# 2. 测试OAP连接
telnet oap-server 11800

# 3. 检查端口占用
netstat -tunlp | grep 11800
netstat -tunlp | grep 12800
```

### 7.3 配置模板


**📋 标准配置模板**：

**Agent配置模板**：
```properties
# ==== 必改项 ====
agent.service_name=${SW_AGENT_NAME:your-service-name}
collector.backend_service=${SW_AGENT_COLLECTOR_BACKEND_SERVICES:oap-server:11800}

# ==== 常用项 ====
agent.sample_n_per_3_secs=${SW_AGENT_SAMPLE:30}
logging.level=${SW_LOGGING_LEVEL:INFO}
logging.file_name=${SW_LOGGING_FILE_NAME:skywalking-agent.log}
logging.max_file_size=${SW_LOGGING_MAX_FILE_SIZE:300}

# ==== 可选项 ====
# 命名空间（多环境隔离）
agent.namespace=${SW_AGENT_NAMESPACE:}
# 忽略的端点
plugin.mount.ignore_suffix=${SW_AGENT_IGNORE_SUFFIX:.jpg,.jpeg,.js,.css}
```

**OAP配置模板**：
```yaml
# application.yml
cluster:
  standalone:  # 单机模式
  # nacos:     # 集群模式（可选）

core:
  default:
    restHost: ${SW_CORE_REST_HOST:0.0.0.0}
    restPort: ${SW_CORE_REST_PORT:12800}
    gRPCHost: ${SW_CORE_GRPC_HOST:0.0.0.0}
    gRPCPort: ${SW_CORE_GRPC_PORT:11800}

storage:
  elasticsearch:
    nameSpace: ${SW_NAMESPACE:""}
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}
    protocol: ${SW_STORAGE_ES_HTTP_PROTOCOL:"http"}
```

---

## 8. 🌐 网络连接问题


### 8.1 网络连接的关键路径


> **💡 网络是桥梁**  
> SkyWalking的数据流动全靠网络。就像快递要通过公路，监控数据要通过网络从Agent传到OAP，再从OAP传到UI。任何一段路不通，整个系统就断了。

**网络拓扑图**：
```
Agent(应用服务器) → OAP(监控服务器) → UI(浏览器)
   11800端口          12800端口         8080端口
   
   gRPC通信          HTTP通信         HTTP通信
```

**三段网络检查**：
```
第一段：Agent → OAP
端口：11800
协议：gRPC
检查：telnet oap-server 11800

第二段：OAP → 存储（ES/MySQL）
端口：9200（ES）/ 3306（MySQL）
协议：HTTP / TCP
检查：telnet es-server 9200

第三段：UI → OAP
端口：12800
协议：HTTP
检查：curl http://oap-server:12800/graphql
```

### 8.2 常见网络问题


**🔴 问题1：防火墙拦截**
```bash
# 症状：
# Agent日志：Connection refused: oap-server/192.168.1.100:11800

# 原因：
# 服务器防火墙没开放11800端口

# 解决：
# CentOS 7
firewall-cmd --permanent --add-port=11800/tcp
firewall-cmd --reload

# Ubuntu
ufw allow 11800/tcp
```

**🔴 问题2：网络不可达**
```bash
# 症状：
# Agent日志：No route to host: 192.168.1.100

# 原因：
# Agent服务器和OAP服务器不在同一个网络

# 解决：
# 1. 检查网络配置
ping 192.168.1.100

# 2. 检查路由表
route -n

# 3. 如果用Docker，检查网络模式
docker network ls
docker network inspect bridge
```

**🔴 问题3：DNS解析失败**
```bash
# 症状：
# Agent日志：Unknown host: oap-server

# 原因：
# 域名解析不了

# 解决：
# 1. 配置/etc/hosts
echo "192.168.1.100 oap-server" >> /etc/hosts

# 2. 或者直接用IP
collector.backend_service=192.168.1.100:11800
```

**🔴 问题4：网络超时**
```properties
# 症状：
# Agent日志：Connect timeout after 30000ms

# 原因：
# 网络延迟太大，或OAP响应太慢

# 解决：调整超时时间
# agent.config
collector.grpc_upstream_timeout=${SW_GRPC_UPSTREAM_TIMEOUT:60}  # 改为60秒
```

### 8.3 网络问题排查工具


**🔧 排查工具箱**：

| 工具 | 用途 | 使用示例 |
|-----|------|---------|
| **ping** | 测试网络连通性 | `ping 192.168.1.100` |
| **telnet** | 测试端口连通性 | `telnet 192.168.1.100 11800` |
| **curl** | 测试HTTP接口 | `curl http://oap:12800/graphql` |
| **netstat** | 查看端口监听 | `netstat -tunlp \| grep 11800` |
| **tcpdump** | 抓包分析 | `tcpdump -i eth0 port 11800` |

**排查脚本**：
```bash
#!/bin/bash
# SkyWalking网络连通性检查脚本

OAP_HOST="192.168.1.100"
OAP_GRPC_PORT="11800"
OAP_HTTP_PORT="12800"

echo "=== SkyWalking Network Check ==="

# 1. 检查网络连通性
echo "1. Checking network connectivity..."
if ping -c 3 $OAP_HOST > /dev/null; then
    echo "✅ Network is reachable"
else
    echo "❌ Network is NOT reachable"
    exit 1
fi

# 2. 检查gRPC端口
echo "2. Checking gRPC port $OAP_GRPC_PORT..."
if timeout 3 bash -c "echo > /dev/tcp/$OAP_HOST/$OAP_GRPC_PORT"; then
    echo "✅ gRPC port is open"
else
    echo "❌ gRPC port is NOT open"
fi

# 3. 检查HTTP端口
echo "3. Checking HTTP port $OAP_HTTP_PORT..."
if curl -s http://$OAP_HOST:$OAP_HTTP_PORT/graphql > /dev/null; then
    echo "✅ HTTP port is accessible"
else
    echo "❌ HTTP port is NOT accessible"
fi

echo "=== Check Complete ==="
```

### 8.4 网络优化建议


**⚡ 优化策略**：

**策略1：部署在同一内网**
```
❌ 不推荐：
Agent(公网服务器) → 互联网 → OAP(公网服务器)
问题：延迟高，不安全

✅ 推荐：
Agent(内网服务器) → 内网 → OAP(内网服务器)
优点：延迟低，安全
```

**策略2：使用负载均衡**
```yaml
# Agent配置多个OAP地址
collector.backend_service=oap1:11800,oap2:11800,oap3:11800

# 自动负载均衡，某个OAP挂了会切换到其他
```

**策略3：调整网络参数**
```properties
# agent.config
# 增加连接池大小
collector.grpc_channel_check_interval=${SW_GRPC_CHANNEL_CHECK_INTERVAL:30}

# 批量发送，减少网络次数
buffer.channel_size=${SW_BUFFER_CHANNEL_SIZE:10}
buffer.buffer_size=${SW_BUFFER_SIZE:600}
```

> **🎯 网络优化要点**  
> 1. **内网优先** - Agent和OAP部署在同一内网
> 2. **检查防火墙** - 确保必要端口开放
> 3. **使用集群** - 多OAP提高可用性
> 4. **调整参数** - 根据网络情况优化配置

---

## 9. 📋 核心要点总结


### 9.1 问题排查优先级


```
🔥 高优先级（立即处理）：
1. Agent未启动 → 完全没数据
2. 网络不通 → 数据发不出去
3. OAP内存溢出 → 服务挂掉

⚠️ 中优先级（尽快处理）：
4. Trace丢失 → 部分数据缺失
5. UI卡顿 → 影响使用体验
6. 存储空间不足 → 即将写满

📌 低优先级（计划处理）：
7. 插件冲突 → 影响特定功能
8. 配置不优 → 性能有提升空间
```

### 9.2 快速排查流程


**🔍 黄金排查法**：
```
第1步：看日志
Agent日志 → 找关键错误
OAP日志 → 看处理异常
UI访问 → 确认能否打开

第2步：测连接
ping → 网络通不通
telnet → 端口开没开
curl → 接口能访问吗

第3步：查配置
service_name → 设了吗
collector地址 → 对不对
采样率 → 合理吗

第4步：看资源
内存 → 够不够
CPU → 高不高
磁盘 → 满没满
```

### 9.3 预防措施


**🛡️ 最佳实践清单**：

```markdown
✅ 部署前：
- [ ] 规划好存储容量（按每天数据量×保留天数）
- [ ] 配置好防火墙规则
- [ ] 准备监控OAP自身的指标
- [ ] 写好配置文档

✅ 运行中：
- [ ] 定期检查存储空间
- [ ] 监控OAP性能指标
- [ ] 备份重要配置
- [ ] 保留问题排查日志

✅ 优化时：
- [ ] 先在测试环境验证
- [ ] 逐步调整参数
- [ ] 记录优化效果
- [ ] 建立配置基线
```

### 9.4 常用命令速查


**📝 命令速查表**：

| 场景 | 命令 | 说明 |
|-----|------|------|
| 查看Agent是否启动 | `ps -ef \| grep skywalking-agent` | 检查进程 |
| 查看OAP日志 | `tail -f oap.log` | 实时日志 |
| 测试网络连通 | `telnet oap-ip 11800` | 端口测试 |
| 查看ES健康状态 | `curl es:9200/_cluster/health` | 存储检查 |
| 查看端口监听 | `netstat -tunlp \| grep 11800` | 端口占用 |

### 9.5 核心记忆口诀


> **🎯 SkyWalking排查口诀**
> 
> **日志先看错误行，  
> 网络端口测一遍，  
> 配置检查别遗漏，  
> 资源监控要跟上，  
> 问题定位有方向，  
> 优化调整需谨慎。**

**记忆要点**：
- 🔸 **8大问题** - Trace丢失、上下文丢失、UI卡顿、OAP瓶颈、存储压力、插件冲突、配置错误、网络连接
- 🔸 **3个优先级** - 高（影响功能）、中（影响体验）、低（性能优化）
- 🔸 **4步排查法** - 看日志→测连接→查配置→看资源
- 🔸 **5个预防点** - 容量规划、防火墙、监控、备份、文档

---

**总结**：SkyWalking问题排查的核心是**系统化思维**，从现象出发，沿着数据流向（Agent→网络→OAP→存储→UI）逐层排查，结合日志、配置、资源监控，快速定位问题根源。记住：**80%的问题都是配置错误和网络问题，剩下20%才是真正的技术难题**。

---

> **💪 实战建议**  
> 1. 建立问题知识库，记录每次排查过程
> 2. 制作标准化的检查清单
> 3. 定期演练故障场景
> 4. 保持与社区的交流，关注新版本的bug修复