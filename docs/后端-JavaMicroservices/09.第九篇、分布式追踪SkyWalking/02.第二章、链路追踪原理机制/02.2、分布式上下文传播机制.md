---
title: 2、分布式上下文传播机制
---
## 📚 目录

1. [什么是分布式上下文传播](#1-什么是分布式上下文传播)
2. [TraceContext核心概念](#2-TraceContext核心概念)
3. [跨线程传播机制](#3-跨线程传播机制)
4. [跨进程传播机制](#4-跨进程传播机制)
5. [HTTP场景下的传播](#5-HTTP场景下的传播)
6. [RPC场景下的传播](#6-RPC场景下的传播)
7. [异步调用的特殊处理](#7-异步调用的特殊处理)
8. [常见问题与解决方案](#8-常见问题与解决方案)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🔗 什么是分布式上下文传播


### 1.1 通俗理解：追踪信息的"接力赛"


想象你在寄快递，快递单号就像链路追踪的TraceID：

```
你下单 → 快递员取件 → 分拣中心 → 运输 → 派送 → 签收
  ↓         ↓           ↓        ↓      ↓       ↓
同一个快递单号在整个过程中不断传递，每个环节都要记录
```

**分布式上下文传播**就是让追踪信息（TraceID、SpanID等）像快递单号一样，在不同服务、不同线程、不同进程之间不断传递下去。

### 1.2 为什么需要上下文传播


**问题场景**：
```
用户请求 → 订单服务 → 库存服务 → 支付服务

如果不传播上下文：
- 订单服务有个TraceID：trace-001
- 库存服务又生成新的TraceID：trace-002  ❌ 断开了！
- 支付服务又生成新的TraceID：trace-003  ❌ 完全乱了！

结果：三个服务的日志无法关联，找不到完整调用链
```

**有了上下文传播**：
```
用户请求 → 订单服务(trace-001) → 库存服务(trace-001) → 支付服务(trace-001)
                                      ↑                      ↑
                            传递相同的TraceID，保持链路完整
```

### 1.3 核心传播内容


**TraceContext包含什么**：

| 字段 | 说明 | 举例 |
|------|------|------|
| **TraceID** | 全局唯一的追踪ID | `abc123-def456-gh789` |
| **SpanID** | 当前操作的ID | `span-001` |
| **ParentSpanID** | 父操作的ID | `span-000` |
| **采样标识** | 是否被采样 | `sampled=true` |
| **业务标签** | 自定义信息 | `userId=10086` |

---

## 2. 🎯 TraceContext核心概念


### 2.1 TraceContext是什么


**简单理解**：TraceContext就是一个"信息背包"，装着追踪需要的所有信息。

```
┌─────────────────────────────┐
│      TraceContext背包        │
├─────────────────────────────┤
│ 📋 TraceID: abc-123         │
│ 🔖 SpanID: span-001         │
│ 👆 ParentSpanID: span-000   │
│ ✅ Sampled: true            │
│ 🏷️  Tags: userId=10086      │
└─────────────────────────────┘
这个背包会跟随请求到处走
```

### 2.2 TraceContext的生命周期


```
1. 创建阶段
   ┌─────────────────┐
   │ 入口服务收到请求  │
   │ 检查是否有TraceID │
   │ 没有→创建新的     │
   │ 有→继续使用       │
   └─────────────────┘
             ↓
2. 传播阶段
   ┌─────────────────┐
   │ 调用下游服务时    │
   │ 把TraceContext   │
   │ 打包带上          │
   └─────────────────┘
             ↓
3. 销毁阶段
   ┌─────────────────┐
   │ 请求处理完毕      │
   │ 清理上下文信息    │
   └─────────────────┘
```

### 2.3 代码层面的理解


```java
// TraceContext就像一个容器类
public class TraceContext {
    private String traceId;        // 全局追踪ID
    private String spanId;         // 当前操作ID
    private String parentSpanId;   // 父操作ID
    private boolean sampled;       // 是否采样
    
    // 传播时就是把这些信息传给下一个服务
}
```

---

## 3. 🧵 跨线程传播机制


### 3.1 为什么需要跨线程传播


**问题场景**：

```java
// 主线程处理请求，TraceContext在主线程
public void handleRequest() {
    // 当前TraceID: trace-001
    
    // 开启新线程处理异步任务
    new Thread(() -> {
        // 问题：新线程拿不到主线程的TraceID！❌
        saveLog();  // 这里的日志没有TraceID
    }).start();
}
```

**通俗理解**：
- 主线程像主持人，TraceContext是话筒
- 新开线程像助手，但助手拿不到话筒
- 需要把话筒"复制"一份给助手

### 3.2 线程传播的实现方式


**方式一：手动传递**（最简单直接）

```java
public void handleRequest() {
    // 1. 保存当前线程的TraceContext
    TraceContext context = TraceContextHolder.get();
    
    // 2. 开启新线程时，手动传入
    new Thread(() -> {
        // 3. 在新线程中设置TraceContext
        TraceContextHolder.set(context);
        try {
            saveLog();  // 现在有TraceID了 ✅
        } finally {
            // 4. 用完清理
            TraceContextHolder.clear();
        }
    }).start();
}
```

**方式二：装饰器模式**（SkyWalking常用）

```java
// SkyWalking提供的工具类
public void handleRequest() {
    // 自动包装Runnable，传播TraceContext
    Runnable task = RunnableWrapper.of(() -> {
        saveLog();  // 自动有TraceID ✅
    });
    
    new Thread(task).start();
}
```

### 3.3 线程传播的原理图


```
主线程                          子线程
  │                              │
  │ TraceContext                 │
  │  ├─ TraceID: 001             │
  │  └─ SpanID: span-1           │
  │                              │
  │─────[复制上下文]────────────→│
  │                              │ TraceContext(副本)
  │                              │  ├─ TraceID: 001
  │                              │  └─ SpanID: span-1
  │                              │
  │                              │ 执行任务...
  │                              │
  │                              │ [清理上下文]
  │                              ✓
```

---

## 4. 🌐 跨进程传播机制


### 4.1 什么是跨进程传播


**通俗理解**：

```
订单服务(进程A)  →  库存服务(进程B)  →  支付服务(进程C)
     │                   │                    │
  不同的JVM         不同的JVM            不同的JVM
  不同的内存空间     不同的内存空间        不同的内存空间
```

进程之间内存隔离，TraceContext无法直接共享，需要通过**网络传输**。

### 4.2 跨进程传播的核心思路


**三步走策略**：

```
发送方（订单服务）              接收方（库存服务）
       │                              │
  1. 序列化                       3. 反序列化
  把TraceContext                  从请求中提取
  变成字符串                      恢复TraceContext
       │                              │
       └──── 2. 网络传输 ─────────────→

具体过程：
TraceContext对象 → JSON字符串 → HTTP Header → JSON字符串 → TraceContext对象
```

### 4.3 传播载体选择


**常用传播方式对比**：

| 传播方式 | 适用场景 | 优点 | 缺点 |
|---------|---------|------|------|
| **HTTP Header** | REST API调用 | 标准化，兼容性好 | 只适合HTTP协议 |
| **RPC元数据** | Dubbo/gRPC | 性能好，自动化 | 框架绑定 |
| **消息头** | 消息队列 | 异步场景适用 | 需要中间件支持 |

---

## 5. 📡 HTTP场景下的传播


### 5.1 HTTP Header传递原理


**发送端（客户端）**：

```java
// 发起HTTP请求时，把TraceContext放入Header
public void callDownstream() {
    TraceContext context = TraceContextHolder.get();
    
    HttpRequest request = new HttpRequest();
    // 把追踪信息放到Header
    request.setHeader("X-Trace-ID", context.getTraceId());
    request.setHeader("X-Span-ID", context.getSpanId());
    request.setHeader("X-Parent-Span-ID", context.getParentSpanId());
    
    httpClient.send(request);
}
```

**接收端（服务端）**：

```java
// 从HTTP请求中提取TraceContext
public void handleRequest(HttpRequest request) {
    String traceId = request.getHeader("X-Trace-ID");
    String spanId = request.getHeader("X-Span-ID");
    String parentSpanId = request.getHeader("X-Parent-Span-ID");
    
    // 恢复TraceContext
    TraceContext context = new TraceContext(traceId, spanId, parentSpanId);
    TraceContextHolder.set(context);
    
    // 处理业务...
}
```

### 5.2 HTTP传播流程图


```
订单服务                                 库存服务
   │                                         │
   │ 1. 获取TraceContext                     │
   │    TraceID: abc-123                     │
   │                                         │
   │ 2. 构建HTTP请求                         │
   │  ┌─────────────────────┐               │
   │  │ GET /api/stock      │               │
   │  │ Headers:            │               │
   │  │  X-Trace-ID: abc-123│──────────────→│ 3. 接收HTTP请求
   │  │  X-Span-ID: span-2  │               │    提取Header
   │  └─────────────────────┘               │
   │                                         │
   │                                         │ 4. 恢复TraceContext
   │                                         │    TraceID: abc-123
   │                                         │    SpanID: span-2
   │                                         │
   │                                         │ 5. 执行业务逻辑
   │                                         │    (带着完整的追踪信息)
```

### 5.3 SkyWalking的自动化方案


**好消息**：SkyWalking通过Agent自动完成这些！

```java
// 你只需要正常写代码
@RestController
public class OrderController {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @GetMapping("/order")
    public String createOrder() {
        // SkyWalking Agent自动在HTTP Header中注入TraceContext ✅
        String result = restTemplate.getForObject(
            "http://stock-service/api/stock", 
            String.class
        );
        return result;
    }
}
```

**SkyWalking做了什么**：
1. 拦截RestTemplate、HttpClient等HTTP客户端
2. 自动注入TraceContext到Header
3. 服务端自动提取Header恢复TraceContext
4. 开发者无需关心细节 🎉

---

## 6. 🔌 RPC场景下的传播


### 6.1 RPC透传是什么


**通俗理解**：

```
RPC调用就像打电话：
- HTTP传播：在电话里说"我的TraceID是abc-123"
- RPC透传：电话系统自动在通话中附带来电显示

RPC框架（如Dubbo）有专门的"隐式参数"通道，
自动携带TraceContext，不占用业务参数
```

### 6.2 Dubbo中的RPC透传


**发送端（Consumer）**：

```java
// Dubbo调用前，把TraceContext放入RpcContext
public void callService() {
    TraceContext context = TraceContextHolder.get();
    
    // Dubbo的隐式参数传递
    RpcContext.getContext()
        .setAttachment("traceId", context.getTraceId())
        .setAttachment("spanId", context.getSpanId());
    
    // 正常调用
    stockService.reduceStock(productId, quantity);
}
```

**接收端（Provider）**：

```java
// Dubbo调用时，从RpcContext提取TraceContext
public void reduceStock(String productId, int quantity) {
    // 提取隐式参数
    String traceId = RpcContext.getContext().getAttachment("traceId");
    String spanId = RpcContext.getContext().getAttachment("spanId");
    
    // 恢复TraceContext
    TraceContext context = new TraceContext(traceId, spanId);
    TraceContextHolder.set(context);
    
    // 处理业务...
}
```

### 6.3 RPC传播流程


```
订单服务(Consumer)                      库存服务(Provider)
       │                                        │
  1. 业务调用                                   │
  stockService.reduce()                         │
       │                                        │
  2. Dubbo拦截器                                │
  获取TraceContext                              │
       │                                        │
  3. 放入RpcContext                             │
  ┌──────────────────┐                         │
  │ Attachments:     │                         │
  │ traceId=abc-123  │─────[网络传输]─────────→│ 4. Provider拦截器
  │ spanId=span-2    │                         │    提取Attachments
  └──────────────────┘                         │
       │                                        │
       │                                        │ 5. 恢复TraceContext
       │                                        │    设置到ThreadLocal
       │                                        │
       │                                        │ 6. 执行业务方法
       │←──────────[返回结果]────────────────────│
```

### 6.4 与HTTP的对比


**核心区别**：

| 特性 | HTTP传播 | RPC透传 |
|-----|---------|---------|
| **传播位置** | HTTP Header | RPC隐式参数 |
| **协议依赖** | 只支持HTTP | 框架专属 |
| **性能** | 略慢（文本协议） | 快（二进制协议） |
| **透明性** | 一般 | 高（框架自动处理） |

---

## 7. ⚡ 异步调用的特殊处理


### 7.1 异步调用的挑战


**问题场景**：

```java
@Service
public class OrderService {
    
    public void createOrder() {
        // 当前线程有TraceContext
        
        // 异步执行
        CompletableFuture.runAsync(() -> {
            // 问题1: 新线程没有TraceContext ❌
            sendNotification();
        });
        
        // 使用线程池
        executorService.submit(() -> {
            // 问题2: 线程池线程复用，可能拿到旧的TraceContext ❌
            updateInventory();
        });
    }
}
```

**核心问题**：
1. 异步线程无法自动获取父线程的TraceContext
2. 线程池复用导致上下文污染
3. 异步调用链断裂

### 7.2 异步场景的传播方案


**方案一：包装异步任务**

```java
public class TraceableRunnable implements Runnable {
    private final Runnable task;
    private final TraceContext context;  // 保存父线程的上下文
    
    public TraceableRunnable(Runnable task) {
        this.task = task;
        // 创建时捕获当前线程的TraceContext
        this.context = TraceContextHolder.get();
    }
    
    @Override
    public void run() {
        // 执行前设置TraceContext
        TraceContext old = TraceContextHolder.get();
        TraceContextHolder.set(context);
        
        try {
            task.run();  // 执行实际任务
        } finally {
            // 执行后恢复或清理
            if (old != null) {
                TraceContextHolder.set(old);
            } else {
                TraceContextHolder.clear();
            }
        }
    }
}
```

**使用示例**：

```java
// 包装后提交
executorService.submit(new TraceableRunnable(() -> {
    sendNotification();  // 现在有TraceContext了 ✅
}));
```

**方案二：装饰线程池**

```java
public class TraceableExecutor implements ExecutorService {
    private final ExecutorService delegate;
    
    @Override
    public void execute(Runnable command) {
        // 自动包装所有提交的任务
        delegate.execute(new TraceableRunnable(command));
    }
    
    // 其他方法类似...
}

// 使用
ExecutorService executor = new TraceableExecutor(
    Executors.newFixedThreadPool(10)
);
```

### 7.3 异步传播流程图


```
主线程                          异步线程
  │                               │
  │ TraceContext                  │
  │  └─ TraceID: 001              │
  │                               │
  │ 提交异步任务                   │
  │  └─[捕获上下文]               │
  │                               │
  │───────[异步执行]─────────────→│
  │                               │
  │                               │ [设置上下文]
  │                               │  └─ TraceID: 001
  │                               │
  │                               │ 执行任务...
  │                               │
  │                               │ [清理上下文]
  │                               │
  ✓                               ✓
```

### 7.4 CompletableFuture的处理


```java
// 错误写法 ❌
CompletableFuture
    .supplyAsync(() -> queryData())  // 丢失TraceContext
    .thenApply(data -> process(data));

// 正确写法 ✅
TraceContext context = TraceContextHolder.get();

CompletableFuture
    .supplyAsync(() -> {
        TraceContextHolder.set(context);  // 恢复上下文
        try {
            return queryData();
        } finally {
            TraceContextHolder.clear();
        }
    })
    .thenApply(data -> {
        TraceContextHolder.set(context);  // 每个阶段都要设置
        try {
            return process(data);
        } finally {
            TraceContextHolder.clear();
        }
    });
```

---

## 8. 🔧 常见问题与解决方案


### 8.1 上下文不一致问题


**问题表现**：

```
预期: 订单服务 → 库存服务 → 支付服务 (同一个TraceID)
实际: 
  订单服务: TraceID=001
  库存服务: TraceID=002  ❌ 不一致！
  支付服务: TraceID=003  ❌ 完全乱了！
```

**原因分析**：

| 原因 | 说明 | 解决方案 |
|-----|------|---------|
| **未传播** | 调用下游时忘记传递 | 使用SkyWalking Agent自动传播 |
| **传播失败** | 网络层拦截器失效 | 检查拦截器配置和顺序 |
| **多次创建** | 每个服务都创建新的TraceID | 入口判断：有则用，无则创建 |

**解决方案代码**：

```java
// 服务入口处理
public void handleRequest(HttpRequest request) {
    String traceId = request.getHeader("X-Trace-ID");
    
    if (traceId == null || traceId.isEmpty()) {
        // 没有TraceID，说明是入口服务，创建新的
        traceId = UUID.randomUUID().toString();
    } else {
        // 有TraceID，说明是下游服务，继续使用
        // 不要创建新的！
    }
    
    TraceContext context = new TraceContext(traceId);
    TraceContextHolder.set(context);
}
```

### 8.2 传播链断裂问题


**断裂场景示意**：

```
服务A → 服务B → 服务C
 ✅       ❌       ❌
正常    断开了    收不到

原因：服务B调用服务C时，没有传播TraceContext
```

**常见断裂原因**：

1. **自定义HTTP客户端未适配**
```java
// 问题代码
HttpClient client = new MyCustomHttpClient();
client.get("http://service-c/api");  // 没有注入TraceContext ❌

// 解决：使用SkyWalking支持的客户端
RestTemplate restTemplate = new RestTemplate();  // SkyWalking自动支持 ✅
```

2. **消息队列场景**
```java
// 发送消息时
public void sendMessage() {
    TraceContext context = TraceContextHolder.get();
    
    Message msg = new Message();
    msg.setBody(data);
    // 把TraceContext放入消息头
    msg.setProperty("traceId", context.getTraceId());  ✅
    
    mqProducer.send(msg);
}

// 消费消息时
public void onMessage(Message msg) {
    String traceId = msg.getProperty("traceId");
    // 恢复TraceContext
    TraceContext context = new TraceContext(traceId);
    TraceContextHolder.set(context);  ✅
}
```

### 8.3 线程池污染问题


**问题现象**：

```
请求1: TraceID=001 → 使用线程池Thread-1
请求2: TraceID=002 → 复用线程池Thread-1

如果Thread-1没有清理，请求2可能拿到TraceID=001 ❌
```

**解决方案**：

```java
// 1. 任务执行后必须清理
public void execute() {
    try {
        // 业务逻辑
    } finally {
        TraceContextHolder.clear();  // 关键：清理ThreadLocal ✅
    }
}

// 2. 使用try-with-resources模式
public class TraceScope implements AutoCloseable {
    public TraceScope(TraceContext context) {
        TraceContextHolder.set(context);
    }
    
    @Override
    public void close() {
        TraceContextHolder.clear();
    }
}

// 使用
try (TraceScope scope = new TraceScope(context)) {
    // 业务逻辑
}  // 自动清理 ✅
```

### 8.4 问题排查清单


**快速诊断步骤**：

```
☑️ 1. 检查入口服务是否创建TraceID
   → 查看日志：第一条请求是否有TraceID

☑️ 2. 检查HTTP调用是否传播
   → 抓包看Header：是否有X-Trace-ID

☑️ 3. 检查下游服务是否接收
   → 查看下游日志：是否使用了相同TraceID

☑️ 4. 检查异步调用
   → 异步任务日志：是否有TraceID

☑️ 5. 检查清理机制
   → 请求结束后：TraceContext是否被清理
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 分布式上下文传播：让TraceID等追踪信息在服务间、线程间传递
🔸 TraceContext：装载追踪信息的"背包"，包含TraceID、SpanID等
🔸 跨线程传播：通过ThreadLocal或包装器传递上下文
🔸 跨进程传播：通过HTTP Header或RPC隐式参数传递
🔸 异步处理：需要手动捕获和恢复上下文
🔸 清理机制：防止线程池污染，必须清理ThreadLocal
```

### 9.2 传播方式对比


| 场景 | 传播方式 | 实现难度 | 自动化程度 |
|-----|---------|---------|-----------|
| **同线程** | ThreadLocal | 简单 | 高（框架自动） |
| **跨线程** | 包装Runnable | 中等 | 中（需要工具类） |
| **HTTP调用** | Header传递 | 简单 | 高（Agent自动） |
| **RPC调用** | 隐式参数 | 简单 | 高（框架自动） |
| **消息队列** | 消息头 | 中等 | 低（需手动处理） |
| **异步任务** | 捕获恢复 | 复杂 | 低（需手动包装） |

### 9.3 最佳实践建议


**推荐做法**：

```
✅ 使用SkyWalking Agent自动传播（HTTP、RPC场景）
✅ 异步任务使用包装器（TraceableRunnable）
✅ 消息队列手动传递TraceID到消息头
✅ 所有任务执行后清理ThreadLocal
✅ 线程池使用装饰器自动传播上下文
```

**避免的坑**：

```
❌ 不要在每个服务都创建新的TraceID
❌ 不要忘记清理ThreadLocal（导致污染）
❌ 不要在异步任务中直接访问TraceContext
❌ 不要使用不支持的HTTP客户端
❌ 不要在业务代码中硬编码传播逻辑
```

### 9.4 记忆要点


**传播三原则**：
1. **捕获原则**：调用前捕获当前上下文
2. **恢复原则**：执行时恢复捕获的上下文  
3. **清理原则**：执行后清理上下文防止污染

**断点排查法**：
```
入口服务 → 检查创建
  ↓
中间服务 → 检查接收
  ↓
调用下游 → 检查发送
  ↓
下游服务 → 检查接收
```

**核心记忆**：
- TraceContext像接力棒，不同服务、线程间传递
- HTTP用Header，RPC用隐式参数，异步要包装
- 用完必清理，否则线程池会污染
- SkyWalking Agent帮你自动搞定大部分场景