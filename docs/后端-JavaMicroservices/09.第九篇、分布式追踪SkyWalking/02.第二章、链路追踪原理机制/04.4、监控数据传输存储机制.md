---
title: 4、监控数据传输存储机制
---
## 📚 目录

1. [数据上报机制](#1-数据上报机制)
2. [数据传输协议](#2-数据传输协议)
3. [数据采样策略](#3-数据采样策略)
4. [存储后端选择](#4-存储后端选择)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 📡 数据上报机制


### 1.1 什么是数据上报


**通俗理解**：就像你用手机APP时，APP会把你的使用数据发送给服务器一样，微服务应用也需要把监控数据发送给 SkyWalking 服务端。

```
应用服务（Agent）           SkyWalking服务端（OAP）
     |                              |
     |--- 发送链路数据 ------------->|
     |--- 发送性能指标 ------------->|
     |--- 发送日志信息 ------------->|
     |                              |
     |<-- 接收配置更新 --------------|
```

**数据上报的本质**：
- **定期发送**：Agent 定时把收集的数据发给 OAP 服务器
- **不影响业务**：上报过程在后台进行，不阻塞业务请求
- **自动重试**：如果发送失败会自动重试

### 1.2 异步上报机制


**为什么要异步上报？**

想象一下，如果每次用户请求都要等监控数据发送完才能返回结果，那用户体验会很差。所以 SkyWalking 采用异步上报：

```
用户请求 → 业务处理 → 立即返回
                ↓
         收集监控数据（后台）
                ↓
         异步上报数据（后台）
```

**异步上报的优势**：
- ✅ **不影响性能**：业务代码执行完就返回，不等数据上报
- ✅ **提高吞吐量**：可以批量打包多个请求的数据一起发送
- ✅ **降低延迟**：用户请求响应时间不受影响

**实现原理**：
```
Agent内部机制：
1. 业务线程收集数据 → 放入内存队列
2. 后台线程从队列取数据 → 批量上报
3. 上报失败 → 重新放回队列等待重试
```

### 1.3 批量传输机制


**什么是批量传输？**

就像寄快递，与其一个包裹寄一次，不如攒几个包裹一起寄，更省钱也更高效。

**批量传输配置示例**：
```yaml
# Agent配置文件
collector:
  backend_service: 127.0.0.1:11800
  
  # 批量发送配置
  buffer_size: 3000              # 缓冲区大小（条数）
  buffer_timeout: 1000           # 最长等待时间（毫秒）
  batch_send_size: 500           # 每批发送数量
```

**批量传输的工作流程**：
```
数据收集 → 放入缓冲区
              ↓
    达到以下任一条件就发送：
    1. 缓冲区满了（3000条）
    2. 等待超时（1秒）
    3. 手动触发刷新
              ↓
         批量发送数据
```

**好处说明**：
- 📦 **减少网络请求**：1000个请求的数据可能只需要2-3次网络传输
- ⚡ **提高效率**：减少网络开销，提升传输速度
- 💾 **节省资源**：降低网络带宽和服务器处理压力

---

## 2. 🔌 数据传输协议


### 2.1 gRPC通信协议


**什么是gRPC？**

gRPC 是一种高性能的远程调用框架，可以简单理解为：**让不同电脑上的程序像调用本地函数一样相互通信**。

```
Agent端                          OAP端
  |                               |
  |-- gRPC调用：发送Span数据 ---->|
  |<- gRPC响应：确认收到 ----------|
  |                               |
  |-- gRPC调用：发送指标数据 ----->|
  |<- gRPC响应：确认收到 ----------|
```

**gRPC的优势**：
- ⚡ **速度快**：使用二进制编码，比 JSON 文本更高效
- 📦 **数据小**：传输的数据体积更小，节省带宽
- 🔄 **支持流式传输**：可以持续发送数据流
- 🌐 **跨语言**：Java、Go、Python 等都能用

**SkyWalking中的应用**：
```java
// Agent端发送数据（简化示例）
// 创建gRPC连接
TraceSegmentServiceGrpc.TraceSegmentServiceStub stub = 
    TraceSegmentServiceGrpc.newStub(channel);

// 发送追踪数据
stub.collect(segmentRequest, new StreamObserver<>() {
    @Override
    public void onNext(Commands response) {
        // 接收服务端响应
    }
    
    @Override
    public void onCompleted() {
        // 发送完成
    }
});
```

### 2.2 HTTP传输协议


**什么时候用HTTP？**

虽然 gRPC 更高效，但有些场景下 HTTP 更方便：
- 🔧 **临时测试**：快速验证功能
- 🌐 **网络限制**：某些网络环境不支持 gRPC
- 🔍 **调试排查**：HTTP 请求更容易抓包查看

**HTTP传输配置**：
```yaml
# 使用HTTP协议上报
collector:
  backend_service: http://127.0.0.1:12800
  grpc_upstream_timeout: 3000
```

**协议对比表格**：

| 特性 | **gRPC** | **HTTP** |
|------|---------|----------|
| 传输效率 | ⭐⭐⭐⭐⭐ 二进制编码 | ⭐⭐⭐ JSON文本 |
| 数据大小 | ⭐⭐⭐⭐⭐ 更小 | ⭐⭐⭐ 较大 |
| 易用性 | ⭐⭐⭐ 需要学习 | ⭐⭐⭐⭐⭐ 简单直观 |
| 调试难度 | ⭐⭐⭐ 二进制不易读 | ⭐⭐⭐⭐⭐ 文本易读 |
| 生产推荐 | ✅ **首选** | 🔧 特殊场景 |

### 2.3 消息队列传输


**为什么需要消息队列？**

想象一个场景：双11大促，瞬间海量订单涌入，如果直接发送监控数据可能会压垮 OAP 服务器。这时候消息队列就像一个"缓冲池"，先把数据存起来，OAP 慢慢消费。

```
高流量场景架构：

Agent → Kafka/RabbitMQ → OAP → 存储
         ↑                ↓
     缓冲削峰          慢慢消费
```

**消息队列的好处**：
- 📊 **削峰填谷**：应对突发大流量
- 🔄 **解耦合**：Agent 和 OAP 不直接依赖
- 💪 **高可靠**：数据不会因为 OAP 宕机而丢失

**Kafka集成配置示例**：
```yaml
# OAP配置使用Kafka接收数据
receiver-trace:
  selector: kafka
  kafka:
    bootstrap-servers: localhost:9092
    namespace: skywalking-trace
    consumer-group: skywalking-consumer
```

**使用场景判断**：
```
直接gRPC传输 ← 适用于：
  ✅ 中小规模应用
  ✅ 流量稳定可控
  ✅ 简单部署

消息队列传输 ← 适用于：
  ✅ 大规模集群
  ✅ 流量波动大
  ✅ 需要高可靠性
```

---

## 3. 📊 数据采样策略


### 3.1 为什么需要采样


**真实场景问题**：

一个电商网站每秒处理 10000 个请求，如果每个请求都记录完整链路数据：
- 📈 **数据量爆炸**：每天产生几百GB的监控数据
- 💰 **存储成本高**：需要大量磁盘空间
- ⚠️ **性能影响**：Agent 和 OAP 压力巨大

**采样的核心思想**：
> 不是所有请求都需要记录，抽样记录部分请求就能发现问题

就像医院体检抽血，不需要把全身血抽光，只需要几毫升就能检查健康状况。

### 3.2 采样率控制机制


**什么是采样率？**

采样率就是"每100个请求，记录多少个"的比例。

```
采样率 = 10%  →  每100个请求记录10个
采样率 = 1%   →  每100个请求记录1个
采样率 = 100% →  所有请求都记录（全量）
```

**配置采样率**：
```properties
# Agent配置文件
# 负采样率：每秒最多采样3000个
agent.sample_n_per_3_secs=3000

# 或者使用百分比采样
agent.sample_rate=1000  # 表示1000/10000 = 10%
```

**采样策略对比**：

| 策略类型 | **说明** | **适用场景** | **优缺点** |
|---------|---------|------------|----------|
| 🎲 **随机采样** | 随机抽取一定比例请求 | 流量均匀的应用 | 简单但可能遗漏重要请求 |
| ⏱️ **限流采样** | 每秒最多采样N个 | 高并发应用 | 保护性能，但可能丢失峰值信息 |
| 🎯 **智能采样** | 错误请求100%，正常请求按比例 | 生产环境 | 既省资源又不漏问题 |
| 📝 **全量采集** | 记录所有请求 | 测试环境、问题排查 | 数据完整但消耗大 |

### 3.3 采样率配置实践


**新手推荐配置**：
```yaml
# 开发测试环境 - 全量采集
agent.sample_n_per_3_secs=-1  # -1表示不限制

# 生产环境 - 适度采样
agent.sample_n_per_3_secs=3000  # 每3秒最多3000个

# 大流量环境 - 低采样率
agent.sample_n_per_3_secs=1000  # 每3秒最多1000个
```

**采样率设置技巧**：
```
流量评估：
1. 统计QPS（每秒请求数）
2. 计算：合适采样数 = QPS × 0.1（10%）
3. 配置：sample_n_per_3_secs = 采样数 × 3

示例：
QPS = 5000
采样数 = 5000 × 0.1 = 500
配置 = 500 × 3 = 1500
```

> ⚠️ **重要提示**：错误请求通常会被强制采样，所以不用担心因采样率低而漏掉异常

---

## 4. 💾 存储后端选择


### 4.1 存储后端概述


**什么是存储后端？**

SkyWalking 收集的监控数据最终要存到某个地方，这个"地方"就是存储后端。就像你的照片可以存到手机、电脑或云盘一样。

```
数据流向：
Agent → OAP → 存储后端（ES/MySQL/H2）
                    ↓
              UI界面查询展示
```

**SkyWalking 支持的存储类型**：

| 存储类型 | **特点** | **适用场景** |
|---------|---------|------------|
| 🗄️ **H2** | 内嵌数据库，无需安装 | 本地测试、快速体验 |
| 🐬 **MySQL** | 关系型数据库，熟悉度高 | 小规模应用 |
| 📊 **ElasticSearch** | 搜索引擎，查询快 | **生产推荐** |
| 🔥 **InfluxDB** | 时序数据库，专为监控设计 | 时序数据分析 |

### 4.2 ElasticSearch 存储（推荐）


**为什么推荐 ElasticSearch？**

- ⚡ **查询速度快**：专为搜索优化，亿级数据秒级响应
- 📈 **横向扩展**：数据量大了可以加机器
- 🔍 **强大搜索**：支持复杂条件查询
- 📊 **天然支持时序数据**：自动按时间分片存储

**配置 ElasticSearch 存储**：
```yaml
# config/application.yml
storage:
  selector: elasticsearch
  elasticsearch:
    namespace: skywalking          # 索引前缀
    cluster_nodes: localhost:9200  # ES地址
    protocol: http
    user: elastic                  # 用户名
    password: changeme             # 密码
    
    # 索引设置
    index_replicas_number: 1       # 副本数
    index_shards_number: 2         # 分片数
    
    # 数据保留策略
    day_step: 1                    # 按天建索引
    # 索引会自动按日期创建：skywalking_segment-20250923
```

**存储容量规划**：
```
估算公式：
每天数据量 ≈ QPS × 采样率 × 每条数据大小 × 86400秒

示例计算：
QPS = 1000
采样率 = 10%
每条数据 ≈ 2KB
每天数据量 = 1000 × 0.1 × 2KB × 86400 
          ≈ 17GB/天

建议配置：
- 保留7天：需要约 120GB 存储
- 保留30天：需要约 500GB 存储
```

### 4.3 MySQL 存储（小规模）


**什么时候用 MySQL？**

- 📝 团队熟悉 MySQL，运维简单
- 📊 应用规模小，QPS < 1000
- 💰 没有 ES 资源，想节省成本

**MySQL 存储配置**：
```yaml
storage:
  selector: mysql
  mysql:
    properties:
      jdbc_url: jdbc:mysql://localhost:3306/skywalking?useSSL=false
      data_source_user: root
      data_source_password: root123
    metadataQueryMaxSize: 5000
```

**MySQL vs ElasticSearch 对比**：

| 对比项 | **MySQL** | **ElasticSearch** |
|-------|-----------|------------------|
| 安装难度 | ⭐⭐⭐⭐⭐ 简单 | ⭐⭐⭐ 需要配置 |
| 查询性能 | ⭐⭐⭐ 百万级 | ⭐⭐⭐⭐⭐ 亿级 |
| 扩展性 | ⭐⭐ 垂直扩展 | ⭐⭐⭐⭐⭐ 水平扩展 |
| 数据量 | ⭐⭐⭐ < 100GB | ⭐⭐⭐⭐⭐ TB级别 |
| 推荐指数 | 🔧 测试/小规模 | ✅ **生产首选** |

### 4.4 H2 存储（仅测试）


**H2 的特点**：
- ✅ **零配置**：SkyWalking 自带，开箱即用
- ✅ **快速体验**：适合本地学习测试
- ❌ **性能有限**：数据量大会很慢
- ❌ **数据丢失风险**：重启可能丢数据

```yaml
# H2配置（默认）
storage:
  selector: h2
  h2:
    driver: org.h2.jdbcx.JdbcDataSource
    url: jdbc:h2:mem:skywalking-oap-db
    user: sa
```

> ⚠️ **警告**：H2 只能用于测试，**绝对不能用于生产环境**！

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 异步上报：后台发送，不阻塞业务
🔸 批量传输：攒够一批数据一起发，提高效率
🔸 gRPC协议：生产环境首选，高性能
🔸 数据采样：不是所有请求都记录，节省资源
🔸 存储选择：小项目MySQL，大项目ElasticSearch
```

### 5.2 关键理解要点


**🔹 数据上报的完整流程**
```
1. 业务请求 → Agent拦截收集数据
2. 数据放入内存队列（异步）
3. 后台线程批量打包数据
4. 通过gRPC发送给OAP
5. OAP存储到ES/MySQL
6. UI界面查询展示
```

**🔹 采样率设置原则**
```
开发环境：100%采样，方便调试
测试环境：50%采样，验证功能
生产环境：1-10%采样，平衡性能和可观测性
大流量环境：0.1-1%采样，保护系统
```

**🔹 存储选择决策树**
```
数据量评估：
  小于10GB/天 → MySQL
  10-100GB/天 → ElasticSearch单节点
  大于100GB/天 → ElasticSearch集群

性能要求：
  查询要求秒级响应 → ElasticSearch
  查询要求分钟级可接受 → MySQL

运维能力：
  团队不熟悉ES → MySQL
  有ES运维能力 → ElasticSearch
```

### 5.3 实际应用建议


**🎯 新手学习路径**
```
阶段1：本地测试
- 使用H2存储快速体验
- 100%采样看完整链路

阶段2：开发环境  
- 配置MySQL存储
- 使用gRPC传输
- 采样率50%

阶段3：生产环境
- 部署ElasticSearch
- 配置合理采样率(1-10%)
- 开启批量传输
```

**🔧 配置最佳实践**
```yaml
# 生产环境推荐配置
collector:
  # gRPC传输
  backend_service: oap-server:11800
  
  # 批量发送
  buffer_size: 3000
  buffer_timeout: 1000
  batch_send_size: 500

# 采样配置  
agent:
  sample_n_per_3_secs: 3000  # 根据QPS调整

# 存储配置
storage:
  selector: elasticsearch
  elasticsearch:
    cluster_nodes: es-cluster:9200
    day_step: 1
    index_replicas_number: 1
```

**核心记忆**：
- 异步批量保性能，采样存储省资源
- gRPC传输快又稳，ES存储是首选
- 测试全量看细节，生产采样要适度