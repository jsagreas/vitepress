---
title: 4、主流分布式追踪方案对比
---
## 📚 目录

1. [分布式追踪方案概览](#1-分布式追踪方案概览)
2. [SkyWalking深度解析](#2-SkyWalking深度解析)
3. [Zipkin架构剖析](#3-Zipkin架构剖析)
4. [Jaeger功能特性](#4-Jaeger功能特性)
5. [OpenTelemetry生态](#5-OpenTelemetry生态)
6. [方案对比与选型](#6-方案对比与选型)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔍 分布式追踪方案概览


### 1.1 为什么需要多种追踪方案


**问题背景**：微服务架构下的痛点
```
传统单体应用：
用户请求 → 应用服务器 → 数据库
问题定位：查日志就能找到问题

微服务架构：
用户请求 → API网关 → 订单服务 → 库存服务 → 支付服务 → 物流服务
问题定位：不知道哪个环节出了问题？

这就需要分布式追踪！
```

**核心需求**：
- 🎯 **请求追踪**：一个请求经过了哪些服务
- ⏱️ **性能分析**：每个服务耗时多少
- 🐛 **故障定位**：哪个服务出了问题
- 📊 **依赖分析**：服务之间的调用关系

### 1.2 主流方案简介


**四大主流方案**：

```
SkyWalking (国产)
├─ 特点：自动埋点，对代码无侵入
├─ 优势：中文文档友好，功能全面
└─ 适合：Java微服务项目

Zipkin (Twitter开源)
├─ 特点：老牌方案，生态成熟
├─ 优势：简单易用，集成方便
└─ 适合：快速接入场景

Jaeger (Uber开源)
├─ 特点：高性能，可扩展
├─ 优势：原生支持Kubernetes
└─ 适合：云原生架构

OpenTelemetry (标准化)
├─ 特点：统一标准，厂商中立
├─ 优势：未来趋势，兼容性强
└─ 适合：长期技术规划
```

### 1.3 核心概念统一理解


**追踪数据的三要素**：

| 概念 | 通俗解释 | 生活类比 |
|------|---------|---------|
| **Trace（追踪）** | 一次完整的请求链路 | 快递包裹的完整运输过程 |
| **Span（跨度）** | 请求链路中的一个步骤 | 包裹在某个站点的处理 |
| **Tag（标签）** | 记录的额外信息 | 包裹的重量、体积等属性 |

**示例说明**：
```
用户下单流程（一个Trace）：
└─ Span1: 订单服务处理（200ms）
   ├─ Span2: 查询用户信息（50ms）
   ├─ Span3: 检查库存（80ms）
   └─ Span4: 创建订单（70ms）

每个Span包含：
- 开始时间、结束时间
- 服务名称、方法名
- 成功/失败状态
- 自定义标签
```

---

## 2. 🚀 SkyWalking深度解析


### 2.1 SkyWalking是什么


**核心定位**：一站式应用性能监控平台

```
SkyWalking的全景视图：

            用户访问应用
                 ↓
         [自动数据采集]
        /      |      \
    追踪数据  指标数据  日志数据
        \      |      /
         [OAP分析平台]
                 ↓
         [UI可视化展示]
         /      |      \
    服务拓扑  追踪详情  性能指标
```

**最大特点**：对代码零侵入
- 不需要修改业务代码
- 通过Java Agent自动采集
- 对开发者透明

### 2.2 SkyWalking核心架构


**三大核心组件**：

```
┌──────────────────────────────────────┐
│          微服务应用集群               │
│  ┌─────┐  ┌─────┐  ┌─────┐          │
│  │服务A│  │服务B│  │服务C│          │
│  └──┬──┘  └──┬──┘  └──┬──┘          │
│     │Agent   │Agent   │Agent         │
└─────┼────────┼────────┼──────────────┘
      ↓        ↓        ↓
┌─────────────────────────────────────┐
│        OAP Server (分析平台)         │
│  ┌──────────┐  ┌──────────┐         │
│  │数据接收   │  │数据分析  │         │
│  │数据存储   │  │告警规则  │         │
│  └──────────┘  └──────────┘         │
└─────────────────┬───────────────────┘
                  ↓
┌─────────────────────────────────────┐
│           UI界面（可视化）            │
│  - 服务拓扑图                        │
│  - 追踪链路                          │
│  - 性能指标                          │
└─────────────────────────────────────┘
```

**组件说明**：

🔸 **Agent探针**
- 作用：自动采集应用数据
- 原理：字节码增强技术
- 使用：启动时添加JVM参数即可

🔸 **OAP Server**
- 作用：数据处理中心
- 功能：接收、分析、存储数据
- 支持：集群部署，高可用

🔸 **UI界面**
- 作用：可视化展示
- 功能：拓扑图、追踪、指标
- 特点：开箱即用

### 2.3 SkyWalking核心特性


**自动追踪能力**：

| 支持组件 | 追踪内容 | 使用场景 |
|---------|---------|---------|
| **HTTP调用** | Tomcat、Jetty等 | Web应用 |
| **RPC框架** | Dubbo、gRPC | 服务间调用 |
| **数据库** | MySQL、Redis | 数据访问 |
| **消息队列** | Kafka、RabbitMQ | 异步通信 |
| **微服务** | Spring Cloud | 微服务架构 |

**监控维度**：

```
🎯 服务级别：
   - 服务调用量
   - 响应时间
   - 成功率

🎯 实例级别：
   - CPU使用率
   - 内存占用
   - GC情况

🎯 接口级别：
   - 接口响应时间
   - 调用频率
   - 异常统计
```

### 2.4 SkyWalking实际应用


**快速接入步骤**：

```
步骤1：下载Agent
官网下载 skywalking-agent.zip

步骤2：配置应用
在启动命令中添加：
-javaagent:/path/to/skywalking-agent.jar
-Dskywalking.agent.service_name=order-service
-Dskywalking.collector.backend_service=127.0.0.1:11800

步骤3：启动OAP Server
./bin/oapService.sh

步骤4：访问UI
http://localhost:8080

就这么简单！
```

**优势总结**：
- ✅ 零代码侵入，接入成本低
- ✅ 功能全面，覆盖主流框架
- ✅ 中文友好，文档完善
- ✅ 性能开销小，生产可用

---

## 3. 📦 Zipkin架构剖析


### 3.1 Zipkin是什么


**核心定位**：轻量级分布式追踪系统

```
Zipkin的设计哲学：

简单 > 复杂
实用 > 花哨
快速接入 > 功能全面

适合场景：
- 快速验证追踪效果
- 小型微服务项目
- 追踪功能试点
```

### 3.2 Zipkin核心架构


**四大核心组件**：

```
应用程序                     Zipkin Server
   ↓                              ↓
[Instrumented]              ┌──────────┐
   |                        │ Collector│ ← 收集器
   ↓ 发送追踪数据             └─────┬────┘
[HTTP/Kafka]                      ↓
                            ┌──────────┐
                            │ Storage  │ ← 存储
                            └─────┬────┘
                                  ↓
                            ┌──────────┐
                            │   API    │ ← 查询接口
                            └─────┬────┘
                                  ↓
                            ┌──────────┐
                            │    UI    │ ← Web界面
                            └──────────┘
```

**组件详解**：

🔸 **Collector收集器**
- 接收应用发送的追踪数据
- 支持HTTP和Kafka两种方式
- 验证并存储数据

🔸 **Storage存储**
- 支持多种存储：MySQL、Elasticsearch、Cassandra
- 推荐生产环境用Elasticsearch
- 数据可设置保留时长

🔸 **API查询**
- 提供RESTful接口
- 查询追踪数据
- 支持按时间、服务等条件过滤

🔸 **UI界面**
- 简洁直观的Web界面
- 显示追踪链路
- 服务依赖关系图

### 3.3 Zipkin接入方式


**两种集成方式**：

**方式1：代码埋点**（需要修改代码）
```java
// 创建追踪器
Tracing tracing = Tracing.newBuilder()
    .localServiceName("order-service")
    .spanReporter(/* 发送到Zipkin */)
    .build();

// 业务代码中埋点
Span span = tracing.tracer().nextSpan().name("查询订单");
span.start();
try {
    // 业务逻辑
} finally {
    span.finish();
}
```

**方式2：Spring Cloud集成**（推荐）
```yaml
# 只需配置，无需代码修改
spring:
  zipkin:
    base-url: http://localhost:9411
  sleuth:
    sampler:
      probability: 1.0  # 采样率100%
```

### 3.4 Zipkin优缺点分析


**核心优势**：
- ✅ 架构简单，易于理解
- ✅ 部署方便，单个Jar包即可
- ✅ 社区活跃，生态成熟
- ✅ 集成简单，Spring Cloud原生支持

**存在局限**：
- ❌ 需要代码埋点（非Spring Cloud时）
- ❌ 功能相对基础，缺少指标监控
- ❌ UI功能简单，分析能力有限
- ❌ 不支持日志关联

**适用场景**：
```
推荐使用Zipkin：
- Spring Cloud微服务项目
- 快速验证追踪效果
- 团队技术栈简单

不推荐使用Zipkin：
- 需要深度性能分析
- 要求零代码侵入
- 需要全方位监控
```

---

## 4. ⚡ Jaeger功能特性


### 4.1 Jaeger是什么


**核心定位**：云原生分布式追踪平台

```
Jaeger的设计目标：

高性能 ← Uber百万级QPS实践
云原生 ← 专为Kubernetes优化
标准化 ← 兼容OpenTracing
```

**名字来源**：Jaeger（德语"猎人"），寓意追踪定位问题

### 4.2 Jaeger核心架构


**完整架构图**：

```
微服务应用
    ↓ (发送追踪数据)
┌─────────────────┐
│  Jaeger Agent   │ ← 本地代理
│  (应用同机部署)  │
└────────┬────────┘
         ↓
┌─────────────────┐
│ Jaeger Collector│ ← 收集器
│  (集中收集)      │
└────────┬────────┘
         ↓
┌─────────────────┐
│  Kafka (可选)   │ ← 消息队列缓冲
└────────┬────────┘
         ↓
┌─────────────────┐
│    Storage      │ ← 存储
│ (ES/Cassandra)  │
└────────┬────────┘
         ↓
┌─────────────────┐
│  Jaeger Query   │ ← 查询服务
└────────┬────────┘
         ↓
┌─────────────────┐
│   Jaeger UI     │ ← Web界面
└─────────────────┘
```

**架构亮点**：

🔸 **Agent本地部署**
- 与应用同机部署，减少网络延迟
- UDP传输，对应用性能影响小
- 支持采样策略

🔸 **Collector高可用**
- 支持水平扩展
- 可选Kafka缓冲，防止数据丢失
- 灵活的存储选择

🔸 **查询优化**
- 独立的查询服务
- 支持复杂条件过滤
- 高效的数据检索

### 4.3 Jaeger核心特性


**高性能设计**：

| 特性 | 说明 | 优势 |
|-----|------|------|
| **UDP传输** | Agent使用UDP发送数据 | 不阻塞应用，性能影响小 |
| **采样策略** | 灵活的采样配置 | 降低数据量，减少开销 |
| **批量处理** | 批量写入存储 | 提高吞吐量 |
| **异步处理** | 异步数据处理 | 不影响主链路 |

**云原生支持**：

```
Kubernetes集成：
├─ 支持Sidecar模式部署Agent
├─ 提供Operator自动化部署
├─ 原生支持服务发现
└─ 完整的Helm Chart

监控指标：
├─ 导出Prometheus指标
├─ 提供Grafana仪表板
└─ 支持告警规则
```

### 4.4 Jaeger实际应用


**快速接入示例**：

```java
// 1. 引入依赖（Maven）
<dependency>
    <groupId>io.jaegertracing</groupId>
    <artifactId>jaeger-client</artifactId>
</dependency>

// 2. 初始化追踪器
Configuration config = new Configuration("order-service")
    .withSampler(
        new SamplerConfiguration()
            .withType("const")
            .withParam(1)  // 100%采样
    )
    .withReporter(
        new ReporterConfiguration()
            .withSender(
                new SenderConfiguration()
                    .withAgentHost("localhost")
                    .withAgentPort(6831)
            )
    );

Tracer tracer = config.getTracer();
```

**Kubernetes部署**：
```yaml
# 使用Operator一键部署
kubectl create namespace observability
kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.42.0/jaeger-operator.yaml -n observability

# 创建Jaeger实例
apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: my-jaeger
spec:
  strategy: production
  storage:
    type: elasticsearch
```

**优势总结**：
- ✅ 性能优异，适合大规模
- ✅ 云原生，K8s完美集成
- ✅ 功能丰富，分析能力强
- ✅ 标准兼容，易于迁移

---

## 5. 🌐 OpenTelemetry生态


### 5.1 OpenTelemetry是什么


**核心定位**：可观测性数据的统一标准

```
OpenTelemetry的使命：

统一标准
    ↓
不再被厂商锁定
    ↓
自由选择后端
    ↓
降低切换成本
```

**通俗理解**：
- 就像USB接口一样，定义了统一的数据格式
- 应用只需按标准采集数据
- 数据可以发送到任何兼容的后端（SkyWalking、Jaeger等）

### 5.2 OpenTelemetry核心概念


**三大支柱**：

```
可观测性三要素：

1. Traces (追踪)
   用途：请求链路追踪
   例子：一次下单经过哪些服务

2. Metrics (指标)
   用途：数值型监控数据
   例子：QPS、响应时间、错误率

3. Logs (日志)
   用途：详细的事件记录
   例子：异常堆栈、业务日志
```

**关联关系**：
```
一个完整的故障排查过程：

1. Metrics发现问题
   "订单服务响应时间突然升高"
   
2. Traces定位环节
   "是调用库存服务变慢了"
   
3. Logs查看详情
   "库存服务出现数据库慢查询"
```

### 5.3 OpenTelemetry架构设计


**核心组件**：

```
应用程序
    ↓ (使用SDK)
┌──────────────────┐
│ OpenTelemetry    │
│      SDK         │ ← 数据采集
└────────┬─────────┘
         ↓
┌──────────────────┐
│ OpenTelemetry    │
│   Collector      │ ← 数据处理
│  ┌────────────┐  │
│  │Receiver    │  │ ← 接收
│  │Processor   │  │ ← 处理
│  │Exporter    │  │ ← 导出
│  └────────────┘  │
└────────┬─────────┘
         ↓
┌──────────────────┐
│   后端平台        │
│ Jaeger/Zipkin/   │ ← 可选任意后端
│ SkyWalking...    │
└──────────────────┘
```

**工作流程**：

🔸 **SDK层**
- 应用内集成，自动采集数据
- 支持多种语言（Java、Go、Python等）
- 提供统一的API

🔸 **Collector层**
- 独立部署的数据处理中心
- 支持数据转换、过滤、聚合
- 解耦应用和后端

🔸 **后端层**
- 自由选择存储和分析平台
- 支持多后端同时导出
- 避免厂商锁定

### 5.4 OpenTelemetry实际应用


**集成示例**：

```java
// 1. 初始化OpenTelemetry
OpenTelemetry openTelemetry = OpenTelemetrySdk.builder()
    .setTracerProvider(
        SdkTracerProvider.builder()
            .addSpanProcessor(
                BatchSpanProcessor.builder(
                    // 可以导出到Jaeger
                    JaegerGrpcSpanExporter.builder()
                        .setEndpoint("http://jaeger:14250")
                        .build()
                ).build()
            )
            .build()
    )
    .buildAndRegisterGlobal();

// 2. 获取追踪器
Tracer tracer = openTelemetry.getTracer("order-service");

// 3. 创建Span
Span span = tracer.spanBuilder("处理订单").startSpan();
try {
    // 业务逻辑
} finally {
    span.end();
}
```

**配置灵活性**：
```yaml
# Collector配置示例
receivers:
  otlp:
    protocols:
      grpc:
      http:

processors:
  batch:
  memory_limiter:

exporters:
  jaeger:
    endpoint: "jaeger:14250"
  zipkin:
    endpoint: "http://zipkin:9411/api/v2/spans"
  prometheus:
    endpoint: "0.0.0.0:8889"

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [jaeger, zipkin]  # 同时导出到多个后端
```

**核心优势**：
- ✅ 厂商中立，避免锁定
- ✅ 统一标准，简化集成
- ✅ 未来趋势，长期投资
- ✅ 灵活切换，降低风险

---

## 6. 📊 方案对比与选型


### 6.1 综合对比表


| 对比维度 | **SkyWalking** | **Zipkin** | **Jaeger** | **OpenTelemetry** |
|---------|--------------|-----------|-----------|------------------|
| **侵入性** | 🟢 零侵入（Agent） | 🟡 需要埋点 | 🟡 需要埋点 | 🟡 需要SDK |
| **功能完整度** | 🟢 全面（追踪+指标+日志） | 🟡 基础（仅追踪） | 🟢 丰富（追踪+指标） | 🟢 全面（三大支柱） |
| **性能开销** | 🟢 低（1-3%） | 🟢 低 | 🟢 极低（UDP） | 🟡 中等 |
| **部署复杂度** | 🟡 中等 | 🟢 简单 | 🟡 中等 | 🟢 灵活 |
| **云原生支持** | 🟡 支持 | 🔴 一般 | 🟢 原生 | 🟢 原生 |
| **学习曲线** | 🟢 平缓 | 🟢 平缓 | 🟡 中等 | 🟡 中等 |
| **中文文档** | 🟢 完善 | 🟡 一般 | 🟡 一般 | 🟡 一般 |
| **生态成熟度** | 🟢 成熟 | 🟢 成熟 | 🟢 成熟 | 🟡 发展中 |

### 6.2 适用场景分析


**🎯 SkyWalking适合：**
```
✅ Java微服务项目（Spring Cloud/Dubbo）
✅ 团队以Java技术栈为主
✅ 需要零代码侵入
✅ 要求中文文档支持
✅ 需要全方位监控（追踪+指标+日志）

示例项目：
- 电商平台微服务
- 金融系统服务化改造
- 传统企业数字化转型
```

**🎯 Zipkin适合：**
```
✅ Spring Cloud项目快速接入
✅ 小型微服务项目
✅ 追踪功能试点验证
✅ 团队技术能力有限
✅ 只需要基础追踪功能

示例项目：
- 创业公司MVP产品
- 传统应用微服务化初期
- 追踪概念验证项目
```

**🎯 Jaeger适合：**
```
✅ Kubernetes云原生架构
✅ 大规模高并发场景
✅ 多语言混合技术栈
✅ 需要深度性能分析
✅ DevOps成熟度高

示例项目：
- 互联网高并发平台
- 容器化微服务系统
- 多云混合架构
```

**🎯 OpenTelemetry适合：**
```
✅ 长期技术规划
✅ 避免厂商锁定
✅ 多后端灵活切换
✅ 标准化要求高
✅ 技术前瞻性布局

示例项目：
- 大型企业级平台
- SaaS多租户系统
- 开源基础设施项目
```

### 6.3 技术选型决策树


```
开始选型
    |
    ↓
是否使用Java？
    |
    ├─是→ 是否需要零侵入？
    |     |
    |     ├─是→ 选择 SkyWalking
    |     |
    |     └─否→ 是否使用Spring Cloud？
    |           |
    |           ├─是→ 选择 Zipkin
    |           |
    |           └─否→ 是否云原生架构？
    |                 |
    |                 ├─是→ 选择 Jaeger
    |                 |
    |                 └─否→ 选择 SkyWalking
    |
    └─否→ 是否K8s部署？
          |
          ├─是→ 选择 Jaeger
          |
          └─否→ 是否需要标准化？
                |
                ├─是→ 选择 OpenTelemetry
                |
                └─否→ 选择 Zipkin
```

### 6.4 实际案例参考


**案例1：电商平台选型**
```
项目背景：
- 50+微服务
- 日均千万级请求
- Spring Cloud技术栈

选择方案：SkyWalking
理由：
✓ Java项目，Agent方式零侵入
✓ 功能全面，一站式监控
✓ 中文文档，团队上手快
✓ 性能开销可接受
```

**案例2：创业公司选型**
```
项目背景：
- 10个微服务
- 快速迭代
- Spring Boot项目

选择方案：Zipkin
理由：
✓ 部署简单，一个Jar包
✓ Spring Cloud原生支持
✓ 满足基本追踪需求
✓ 学习成本低
```

**案例3：容器化平台选型**
```
项目背景：
- Kubernetes集群
- 多语言服务（Go/Java/Python）
- 云原生架构

选择方案：Jaeger
理由：
✓ K8s原生支持
✓ 多语言SDK
✓ 性能优异
✓ 云原生生态完善
```

### 6.5 混合使用策略


**方案组合建议**：

```
策略1：渐进式迁移
初期：Zipkin快速验证
↓
中期：SkyWalking深度监控
↓
长期：OpenTelemetry标准化

策略2：分层使用
关键服务：SkyWalking深度监控
普通服务：Zipkin轻量追踪
数据统一：OpenTelemetry标准

策略3：多后端并行
采集：OpenTelemetry SDK
导出：同时发送到Jaeger和Zipkin
分析：根据场景选择工具
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 分布式追踪本质：
   追踪一个请求在微服务间的完整调用链路

🔸 四大主流方案定位：
   SkyWalking → 国产全能型，Java首选
   Zipkin     → 轻量入门型，快速接入
   Jaeger     → 云原生型，高性能优先
   OpenTelemetry → 标准化型，未来趋势

🔸 核心数据模型：
   Trace（追踪）→ 完整链路
   Span（跨度）→ 单个步骤
   Tag（标签）→ 附加信息
```

### 7.2 关键理解要点


**🔹 选型核心考虑因素**：
```
技术栈 → Java用SkyWalking，多语言用Jaeger
团队能力 → 新手用Zipkin，DevOps成熟用Jaeger
项目规模 → 小项目Zipkin，大项目Jaeger/SkyWalking
长期规划 → 标准化优先选OpenTelemetry
```

**🔹 零侵入vs代码埋点**：
```
零侵入（SkyWalking Agent）：
优势：对业务透明，接入快
劣势：框架绑定，灵活性低

代码埋点（Zipkin/Jaeger）：
优势：灵活控制，精确采集
劣势：修改代码，有侵入性

标准SDK（OpenTelemetry）：
优势：统一标准，后端解耦
劣势：需要集成，有学习成本
```

**🔹 性能开销对比**：
```
SkyWalking：1-3%（Agent字节码增强）
Zipkin：2-5%（取决于采样率）
Jaeger：<1%（UDP传输，极致优化）
OpenTelemetry：2-4%（标准化开销）
```

### 7.3 实战选型建议


**快速决策表**：

| 你的情况 | 推荐方案 | 理由 |
|---------|---------|------|
| Spring Cloud新手 | Zipkin | 开箱即用，学习成本低 |
| Java微服务老手 | SkyWalking | 功能全面，零侵入 |
| Kubernetes平台 | Jaeger | 云原生完美集成 |
| 长期技术规划 | OpenTelemetry | 标准化，避免锁定 |
| 多语言技术栈 | Jaeger | 多语言SDK支持好 |
| 中小型项目 | Zipkin | 简单够用 |
| 大型平台 | SkyWalking/Jaeger | 性能和功能兼顾 |

### 7.4 避坑指南


**常见误区**：

```
❌ 误区1："追踪就是打日志"
   正解：追踪是结构化的链路数据，不是文本日志

❌ 误区2："100%采样才准确"
   正解：1-10%采样率足够发现问题，还能降低开销

❌ 误区3："选最新的技术就对了"
   正解：选适合团队和项目的，成熟度很重要

❌ 误区4："追踪系统越复杂越好"
   正解：够用就好，过度复杂增加维护成本
```

**实施建议**：

```
第一步：小范围试点
- 选择1-2个非核心服务
- 验证追踪效果
- 评估性能影响

第二步：逐步推广
- 接入更多服务
- 建立监控规范
- 培训团队使用

第三步：深度应用
- 结合告警规则
- 性能优化分析
- 故障快速定位

第四步：持续优化
- 调整采样策略
- 优化存储成本
- 升级追踪方案
```

### 7.5 学习路线建议


**入门阶段**（1-2周）：
```
1. 理解分布式追踪基本概念
2. 本地搭建Zipkin环境
3. Spring Cloud项目接入实践
4. 学习查看追踪链路
```

**进阶阶段**（1个月）：
```
1. 深入学习SkyWalking架构
2. 掌握Agent配置和优化
3. 了解存储选型（ES/H2/MySQL）
4. 学习告警规则配置
```

**高级阶段**（2-3个月）：
```
1. Jaeger云原生实践
2. OpenTelemetry标准应用
3. 多方案对比实战
4. 自定义埋点和扩展
```

**核心记忆口诀**：
```
追踪方案四大将，各有特色不一样
SkyWalking国产强，Java项目是首选
Zipkin简单又轻量，快速接入第一名  
Jaeger云原生王，高性能无人挡
OpenTel标准化，未来趋势要跟上
```