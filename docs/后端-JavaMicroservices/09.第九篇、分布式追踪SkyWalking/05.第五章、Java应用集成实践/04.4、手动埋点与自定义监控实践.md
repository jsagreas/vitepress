---
title: 4、手动埋点与自定义监控实践
---
## 📚 目录

1. [手动埋点基础概念](#1-手动埋点基础概念)
2. [手动创建Span实战](#2-手动创建span实战)
3. [自定义标签与指标](#3-自定义标签与指标)
4. [业务监控实践](#4-业务监控实践)
5. [异常追踪与记录](#5-异常追踪与记录)
6. [性能优化建议](#6-性能优化建议)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 手动埋点基础概念


### 1.1 什么是手动埋点


**🔸 通俗理解**
```
想象你在看电影时做笔记：
自动字幕 = SkyWalking自动监控（框架自动记录HTTP请求、数据库操作）
手写笔记 = 手动埋点（你主动记录重要情节、关键台词）

手动埋点就是：在代码中主动添加监控点，记录你关心的业务逻辑
```

**📋 核心概念**
- **自动监控局限**：只能监控框架层面（HTTP、数据库、Redis等）
- **业务逻辑盲区**：复杂的业务处理过程无法自动捕获
- **手动埋点价值**：补充业务级别的监控，让追踪更完整

### 1.2 为什么需要手动埋点


**🏠 生活类比**

```
快递追踪系统：
自动记录：揽收→分拣→运输→派送  （框架自动监控）
手动记录：客户签收时间、投诉记录  （业务手动埋点）

电商订单处理：
自动记录：HTTP请求→数据库操作
手动记录：库存检查→优惠券计算→积分扣减  （这些业务逻辑需要手动埋点）
```

**💡 实际应用场景**

| 场景 | 自动监控能做的 | 手动埋点补充的 |
|------|--------------|--------------|
| 🛒 **下单流程** | 记录HTTP请求 | 库存校验、优惠计算、积分扣减各环节耗时 |
| 💰 **支付流程** | 记录数据库操作 | 风控检查、三方支付调用、账户扣款细节 |
| 📦 **物流查询** | 记录Redis缓存 | 多物流商查询、数据聚合、结果过滤逻辑 |
| 👤 **用户行为** | 无法自动捕获 | 页面停留时长、按钮点击、搜索关键词 |

### 1.3 手动埋点 vs 自动监控


```
监控层次对比：

应用层 ┌─────────────────────────┐
      │   用户行为追踪          │ ← 手动埋点
      │   业务指标统计          │ ← 手动埋点
      ├─────────────────────────┤
      │   业务逻辑处理          │ ← 手动埋点
      │   复杂计算过程          │ ← 手动埋点
      ├─────────────────────────┤
      │   HTTP/RPC调用          │ ← 自动监控
框架层 │   数据库/缓存操作       │ ← 自动监控
      │   消息队列              │ ← 自动监控
      └─────────────────────────┘
```

**🔍 关键区别**

自动监控特点：
- ✅ 无需修改代码，插件自动工作
- ✅ 覆盖常见框架操作
- ❌ 无法感知业务语义
- ❌ 看不到业务处理细节

手动埋点特点：
- ✅ 精确控制监控点
- ✅ 记录业务级别信息
- ✅ 自定义标签和指标
- ❌ 需要修改业务代码
- ❌ 维护成本较高

---

## 2. 🔧 手动创建Span实战


### 2.1 Span的基本概念回顾


**📊 Span是什么**
```
可以把Span理解为：一段代码执行过程的"录像片段"

完整请求链路：
┌─────────────────────────────────────┐
│  Entry Span (HTTP请求入口)          │
│  ├── Local Span (业务逻辑1)         │
│  ├── Exit Span (调用Redis)          │
│  ├── Local Span (业务逻辑2)         │
│  └── Exit Span (调用MySQL)          │
└─────────────────────────────────────┘

每个Span记录：
• 开始/结束时间
• 操作名称
• 标签信息
• 日志事件
```

**🎯 Span的三种类型**

1️⃣ **Entry Span（入口）**
- 含义：请求进入应用的第一个Span
- 场景：HTTP请求、MQ消费、定时任务
- 特点：作为链路的根节点

2️⃣ **Exit Span（出口）**
- 含义：调用外部服务的Span
- 场景：HTTP调用、数据库、Redis、RPC
- 特点：连接到下游服务

3️⃣ **Local Span（本地）**
- 含义：本地业务逻辑的Span
- 场景：复杂计算、业务处理、算法逻辑
- 特点：不涉及网络调用

### 2.2 手动创建Local Span


**💻 基础示例**

```java
import org.apache.skywalking.apm.toolkit.trace.TraceContext;
import org.apache.skywalking.apm.toolkit.trace.Trace;

@Service
public class OrderService {
    
    // 方式1：使用@Trace注解（最简单）
    @Trace(operationName = "calculateOrderAmount")
    public BigDecimal calculateOrderAmount(Order order) {
        // 复杂的价格计算逻辑
        BigDecimal amount = order.getOriginalPrice();
        amount = applyDiscount(amount, order.getCouponId());
        amount = calculateShipping(amount, order.getAddress());
        return amount;
    }
    
    // 方式2：手动创建Span（更灵活）
    public void processOrder(Order order) {
        // 创建本地Span
        ActiveSpan span = TraceContext.createLocalSpan("processOrder");
        
        try {
            // 添加业务标签
            span.tag("orderId", order.getId());
            span.tag("userId", order.getUserId());
            
            // 业务逻辑
            checkInventory(order);
            deductPoints(order);
            
            span.log("订单处理完成");
            
        } catch (Exception e) {
            span.log(e);  // 记录异常
            throw e;
        } finally {
            span.close();  // 必须关闭Span
        }
    }
}
```

**🔍 代码解读**

`@Trace`注解方式：
- 优点：代码简洁，自动管理Span生命周期
- 缺点：无法动态添加标签
- 适用：简单场景，只需记录方法执行

手动创建方式：
- 优点：完全控制，可添加标签、日志
- 缺点：需要手动close，代码略繁琐
- 适用：需要记录详细信息的场景

### 2.3 创建跨服务调用的Span


**📡 Exit Span示例**

```java
@Service
public class PaymentService {
    
    public PayResult callThirdPartyPay(PayRequest request) {
        // 创建Exit Span（标记为外部调用）
        ActiveSpan span = TraceContext.createExitSpan(
            "ThirdPartyPayment",           // 操作名
            request.getPaymentGatewayUrl() // 对端地址
        );
        
        try {
            // 添加支付相关标签
            span.tag("paymentAmount", request.getAmount().toString());
            span.tag("paymentMethod", request.getMethod());
            
            // 调用第三方支付
            PayResult result = httpClient.post(
                request.getPaymentGatewayUrl(), 
                request
            );
            
            // 记录支付结果
            span.tag("paymentResult", result.getStatus());
            span.log("支付调用成功");
            
            return result;
            
        } catch (Exception e) {
            span.errorOccurred();  // 标记错误
            span.log(e);
            throw e;
        } finally {
            span.close();
        }
    }
}
```

**🎨 Span类型选择指南**

```
判断流程：

是请求入口？
  ├─ 是 → Entry Span  (HTTP接口、MQ消费)
  └─ 否 → 往下判断

调用外部服务？
  ├─ 是 → Exit Span   (HTTP调用、数据库、Redis)
  └─ 否 → Local Span  (业务逻辑、计算过程)
```

### 2.4 Span的嵌套使用


**🏗️ 复杂业务场景**

```java
@Service
public class ComplexOrderService {
    
    @Trace(operationName = "submitOrder")
    public OrderResult submitOrder(Order order) {
        
        // 1. 校验库存（Local Span）
        ActiveSpan inventorySpan = TraceContext.createLocalSpan("checkInventory");
        try {
            boolean hasStock = inventoryService.check(order.getProductId());
            inventorySpan.tag("hasStock", String.valueOf(hasStock));
        } finally {
            inventorySpan.close();
        }
        
        // 2. 调用支付（Exit Span）
        ActiveSpan paySpan = TraceContext.createExitSpan(
            "payment", 
            paymentGatewayUrl
        );
        try {
            PayResult payResult = paymentService.pay(order);
            paySpan.tag("payStatus", payResult.getStatus());
        } finally {
            paySpan.close();
        }
        
        // 3. 扣减积分（Local Span）
        ActiveSpan pointsSpan = TraceContext.createLocalSpan("deductPoints");
        try {
            pointsService.deduct(order.getUserId(), order.getPoints());
        } finally {
            pointsSpan.close();
        }
        
        return new OrderResult("success");
    }
}
```

**📈 链路追踪效果**

```
提交订单链路视图：

submitOrder (1200ms)
├── checkInventory (80ms)      ← Local Span
├── payment (950ms)            ← Exit Span
│   └── PaymentGateway (900ms) ← 下游服务
└── deductPoints (120ms)       ← Local Span
```

---

## 3. 🏷️ 自定义标签与指标


### 3.1 标签（Tag）的作用


**🔸 什么是Tag**
```
类比：给文件添加标签
文件.pdf  → 标签：[重要] [财务] [2024Q1]
Span      → 标签：[用户ID] [订单金额] [支付方式]

Tag的作用：
• 让追踪数据可搜索
• 记录业务上下文
• 便于问题定位
```

**💡 Tag vs Log 区别**

| 特性 | Tag（标签） | Log（日志） |
|------|-----------|-----------|
| 📌 **用途** | 结构化元数据 | 事件记录 |
| 🔍 **可搜索** | 是，可作为查询条件 | 否，只能浏览 |
| 📊 **展示** | 键值对形式 | 时间线事件 |
| 💾 **存储** | 索引存储 | 文本存储 |
| 🎯 **示例** | `userId=12345` | `"用户登录成功"` |

### 3.2 添加自定义标签


**📝 标签使用规范**

```java
@Service
public class UserService {
    
    public void login(String username, String device) {
        ActiveSpan span = TraceContext.createLocalSpan("userLogin");
        
        try {
            // ✅ 好的Tag命名：清晰、有意义
            span.tag("user.name", username);
            span.tag("user.id", getUserId(username));
            span.tag("device.type", device);
            span.tag("login.method", "password");
            
            // ❌ 避免的Tag：
            // span.tag("data", someObject.toString());  // 太模糊
            // span.tag("用户名", username);              // 用中文
            // span.tag("temp", "xxx");                  // 无意义命名
            
            User user = performLogin(username);
            
            // 动态添加Tag
            if (user.isVip()) {
                span.tag("user.vip", "true");
                span.tag("user.vipLevel", user.getVipLevel());
            }
            
        } finally {
            span.close();
        }
    }
}
```

**🎯 Tag命名最佳实践**

```
命名规范：
• 使用小写字母
• 用点号分隔层级（user.id, order.amount）
• 见名知意
• 保持一致性

常用Tag分类：

业务维度：
├── user.*      (用户相关: user.id, user.type)
├── order.*     (订单相关: order.id, order.amount)
├── product.*   (商品相关: product.id, product.category)
└── payment.*   (支付相关: payment.method, payment.channel)

技术维度：
├── db.*        (数据库: db.type, db.instance)
├── cache.*     (缓存: cache.hit, cache.key)
├── mq.*        (消息: mq.topic, mq.queue)
└── http.*      (HTTP: http.method, http.status)
```

### 3.3 业务指标统计


**📊 自定义指标示例**

```java
@Service
public class MetricsService {
    
    public void recordBusinessMetrics(Order order) {
        ActiveSpan span = TraceContext.createLocalSpan("recordMetrics");
        
        try {
            // 记录关键业务指标
            span.tag("metrics.orderAmount", order.getAmount().toString());
            span.tag("metrics.itemCount", String.valueOf(order.getItemCount()));
            span.tag("metrics.discountAmount", order.getDiscount().toString());
            
            // 计算并记录派生指标
            BigDecimal avgPrice = order.getAmount()
                .divide(new BigDecimal(order.getItemCount()), 2);
            span.tag("metrics.avgItemPrice", avgPrice.toString());
            
            // 记录性能指标
            long processingTime = calculateProcessTime();
            span.tag("metrics.processTime", String.valueOf(processingTime));
            
        } finally {
            span.close();
        }
    }
}
```

**💰 电商业务指标示例**

```
订单处理监控指标：

📈 转化指标
├── 下单金额：order.amount
├── 优惠金额：discount.amount  
├── 实付金额：payment.amount
└── 利润金额：profit.amount

⏱️ 性能指标
├── 库存检查：inventory.checkTime
├── 优惠计算：coupon.calculateTime
├── 支付耗时：payment.duration
└── 总处理时长：order.totalTime

👥 用户指标
├── 用户等级：user.level
├── 购买次数：user.orderCount
├── 用户来源：user.source
└── 设备类型：user.device
```

---

## 4. 💼 业务监控实践


### 4.1 用户行为追踪


**👤 用户行为监控场景**

```java
@Service
public class UserBehaviorTracker {
    
    // 页面访问追踪
    @Trace(operationName = "pageView")
    public void trackPageView(String userId, String pageName) {
        ActiveSpan span = TraceContext.activeSpan();
        
        // 用户信息
        span.tag("user.id", userId);
        span.tag("user.type", getUserType(userId));
        
        // 页面信息
        span.tag("page.name", pageName);
        span.tag("page.category", getPageCategory(pageName));
        
        // 设备信息
        span.tag("device.type", getDeviceType());
        span.tag("browser.type", getBrowserType());
        
        span.log("页面浏览记录");
    }
    
    // 搜索行为追踪
    public void trackSearch(String keyword, int resultCount) {
        ActiveSpan span = TraceContext.createLocalSpan("searchBehavior");
        
        try {
            span.tag("search.keyword", keyword);
            span.tag("search.resultCount", String.valueOf(resultCount));
            span.tag("search.hasResult", resultCount > 0 ? "true" : "false");
            
            // 记录是否热门搜索词
            if (isHotKeyword(keyword)) {
                span.tag("search.isHot", "true");
            }
            
        } finally {
            span.close();
        }
    }
}
```

**🎯 追踪数据的价值**

```
用户行为分析：

搜索分析
├── 热门搜索词：search.keyword (聚合统计)
├── 无结果搜索：search.hasResult=false (优化商品)
└── 搜索转化率：搜索→加购→下单 (漏斗分析)

页面分析  
├── 高跳出页面：page.name (页面优化)
├── 访问路径：page追踪链 (用户旅程)
└── 停留时长：通过Span时长计算
```

### 4.2 关键业务流程监控


**🛒 下单流程完整监控**

```java
@Service
public class OrderProcessService {
    
    public OrderResult processOrder(CreateOrderRequest request) {
        // 创建主Span
        ActiveSpan mainSpan = TraceContext.createLocalSpan("orderProcess");
        mainSpan.tag("order.userId", request.getUserId());
        
        try {
            // 1. 校验阶段
            ActiveSpan validateSpan = TraceContext.createLocalSpan("validateOrder");
            try {
                validateStock(request);        // 库存校验
                validateCoupon(request);       // 优惠券校验
                validateSpan.tag("validate.result", "success");
            } finally {
                validateSpan.close();
            }
            
            // 2. 计算阶段
            ActiveSpan calculateSpan = TraceContext.createLocalSpan("calculateAmount");
            try {
                PriceDetail price = calculatePrice(request);
                calculateSpan.tag("price.original", price.getOriginal().toString());
                calculateSpan.tag("price.discount", price.getDiscount().toString());
                calculateSpan.tag("price.final", price.getFinal().toString());
            } finally {
                calculateSpan.close();
            }
            
            // 3. 创建订单
            ActiveSpan createSpan = TraceContext.createLocalSpan("createOrder");
            try {
                Order order = orderRepository.save(request);
                createSpan.tag("order.id", order.getId());
                mainSpan.tag("order.id", order.getId());  // 主Span也记录
            } finally {
                createSpan.close();
            }
            
            // 4. 发送通知
            sendOrderNotification(request.getUserId());
            
            mainSpan.log("订单处理完成");
            return OrderResult.success();
            
        } catch (Exception e) {
            mainSpan.errorOccurred();
            mainSpan.tag("error.type", e.getClass().getSimpleName());
            mainSpan.log(e);
            return OrderResult.fail(e.getMessage());
        } finally {
            mainSpan.close();
        }
    }
}
```

**📊 监控效果展示**

```
订单处理链路（1850ms）：

orderProcess (1850ms)
├── validateOrder (120ms)
│   ├── 库存校验: hasStock=true
│   └── 优惠券校验: couponValid=true
├── calculateAmount (80ms)
│   ├── original=299.00
│   ├── discount=50.00
│   └── final=249.00
├── createOrder (1600ms)
│   ├── 数据库写入 (1580ms)  ← 性能瓶颈！
│   └── orderId=ORD20240923001
└── 发送通知 (50ms)
```

> 💡 **关键洞察**
> 
> 通过追踪发现：创建订单环节耗时1600ms，占总时长86%
> 
> 优化方向：
> - 检查数据库索引
> - 考虑异步创建
> - 优化SQL语句

### 4.3 KPI指标监控


**📈 关键指标追踪**

```java
@Component
public class KPIMonitor {
    
    // 支付成功率监控
    public void monitorPaymentSuccess(PaymentEvent event) {
        ActiveSpan span = TraceContext.createLocalSpan("kpi.payment");
        
        try {
            span.tag("kpi.metric", "paymentSuccessRate");
            span.tag("payment.status", event.getStatus());
            span.tag("payment.amount", event.getAmount().toString());
            span.tag("payment.method", event.getMethod());
            
            // 区分成功/失败
            if (event.isSuccess()) {
                span.tag("kpi.result", "success");
            } else {
                span.tag("kpi.result", "fail");
                span.tag("fail.reason", event.getFailReason());
            }
            
        } finally {
            span.close();
        }
    }
    
    // API响应时间监控
    @Trace(operationName = "kpi.apiResponse")
    public void monitorApiPerformance(String apiName, long responseTime) {
        ActiveSpan span = TraceContext.activeSpan();
        
        span.tag("kpi.metric", "apiResponseTime");
        span.tag("api.name", apiName);
        span.tag("api.responseTime", String.valueOf(responseTime));
        
        // SLA告警阈值
        if (responseTime > 1000) {
            span.tag("kpi.alert", "slowApi");
            span.log("API响应超过1秒");
        }
    }
}
```

**🎯 常见KPI监控**

| KPI类型 | 监控指标 | Tag示例 |
|---------|---------|---------|
| 📊 **业务指标** | 订单转化率 | `kpi.metric=orderConversion` |
| 💰 **收入指标** | GMV统计 | `kpi.metric=gmv` `amount=xxx` |
| ⏱️ **性能指标** | API响应时长 | `kpi.metric=apiLatency` `duration=xxx` |
| ✅ **可用性指标** | 成功率 | `kpi.metric=successRate` `result=success/fail` |
| 👥 **用户指标** | 活跃用户数 | `kpi.metric=activeUsers` `userId=xxx` |

---

## 5. ⚠️ 异常追踪与记录


### 5.1 异常信息记录


**🔍 异常监控的重要性**

```
为什么要记录异常：
• 快速定位问题代码位置
• 了解异常发生的业务上下文
• 统计异常发生频率
• 分析异常影响范围
```

**💻 异常记录示例**

```java
@Service
public class PaymentService {
    
    public PayResult processPayment(PayRequest request) {
        ActiveSpan span = TraceContext.createLocalSpan("payment");
        
        try {
            // 添加业务上下文
            span.tag("payment.orderId", request.getOrderId());
            span.tag("payment.amount", request.getAmount().toString());
            span.tag("payment.method", request.getMethod());
            
            // 执行支付逻辑
            PayResult result = callPaymentGateway(request);
            
            // 记录支付结果
            span.tag("payment.result", result.getStatus());
            span.log("支付成功");
            
            return result;
            
        } catch (InsufficientBalanceException e) {
            // 记录业务异常
            span.errorOccurred();
            span.tag("error.type", "InsufficientBalance");
            span.tag("error.balance", e.getCurrentBalance().toString());
            span.log("余额不足: " + e.getMessage());
            throw e;
            
        } catch (PaymentTimeoutException e) {
            // 记录超时异常
            span.errorOccurred();
            span.tag("error.type", "PaymentTimeout");
            span.tag("error.duration", String.valueOf(e.getDuration()));
            span.log(e);  // 记录完整堆栈
            throw e;
            
        } catch (Exception e) {
            // 记录未知异常
            span.errorOccurred();
            span.tag("error.type", e.getClass().getSimpleName());
            span.log(e);
            throw new PaymentException("支付失败", e);
            
        } finally {
            span.close();
        }
    }
}
```

**🎨 异常记录最佳实践**

```
✅ 应该做的：
1. 调用 span.errorOccurred() 标记错误
2. 添加 error.type Tag 分类异常
3. 使用 span.log(exception) 记录堆栈
4. 记录业务上下文信息

❌ 避免做的：
1. 不要吞掉异常（catch后不处理）
2. 不要只记录异常消息，要记录堆栈
3. 不要在finally中遗漏span.close()
4. 不要记录敏感信息（密码、密钥等）
```

### 5.2 分类记录不同异常


**📂 异常分类监控**

```java
@Component
public class ExceptionHandler {
    
    // 业务异常（预期内的异常）
    public void handleBusinessException(BusinessException e, ActiveSpan span) {
        span.errorOccurred();
        span.tag("error.category", "business");
        span.tag("error.code", e.getErrorCode());
        span.tag("error.message", e.getMessage());
        
        // 业务异常不需要记录堆栈（非系统错误）
        span.log("业务异常: " + e.getMessage());
    }
    
    // 系统异常（非预期的异常）
    public void handleSystemException(Exception e, ActiveSpan span) {
        span.errorOccurred();
        span.tag("error.category", "system");
        span.tag("error.class", e.getClass().getName());
        
        // 系统异常需要完整堆栈
        span.log(e);
        
        // 可能需要告警
        if (isCritical(e)) {
            span.tag("error.severity", "critical");
            sendAlert(e);
        }
    }
    
    // 第三方服务异常
    public void handleThirdPartyException(ThirdPartyException e, ActiveSpan span) {
        span.errorOccurred();
        span.tag("error.category", "thirdParty");
        span.tag("error.service", e.getServiceName());
        span.tag("error.statusCode", String.valueOf(e.getStatusCode()));
        
        span.log("第三方服务异常: " + e.getServiceName());
    }
}
```

**📊 异常统计分析**

```
基于Tag的异常分析：

按类型统计：
├── error.category=business  (业务异常: 60%)
├── error.category=system    (系统异常: 30%)
└── error.category=thirdParty (三方异常: 10%)

按严重程度：
├── error.severity=critical  (紧急: 5%)
├── error.severity=high      (高: 15%)
└── error.severity=medium    (中: 80%)

按业务模块：
├── module=payment  (支付异常: 40%)
├── module=order    (订单异常: 35%)
└── module=user     (用户异常: 25%)
```

---

## 6. ⚡ 性能优化建议


### 6.1 手动埋点的性能影响


**🔸 性能开销分析**

```
埋点性能开销：

无埋点        ────────────────────  (基准耗时)
自动监控      ─────────────────────── (增加5-10%)
手动埋点      ──────────────────────────  (再增加3-5%)

结论：手动埋点有性能开销，但通常可接受
```

**⚖️ 性能 vs 可观测性权衡**

```
高频场景（每秒>1000次）：
• 慎用手动埋点
• 采样监控（只监控部分请求）
• 异步记录

中频场景（每秒100-1000次）：
• 可以使用手动埋点
• 控制Tag数量
• 避免复杂计算

低频场景（每秒<100次）：
• 放心使用手动埋点
• 记录详细信息
• 帮助问题定位
```

### 6.2 优化建议


**✅ 减少性能影响的技巧**

```java
// ❌ 不好的做法：在循环中创建Span
for (Product product : products) {
    ActiveSpan span = TraceContext.createLocalSpan("processProduct");
    processProduct(product);
    span.close();
}

// ✅ 好的做法：批量处理，只创建一个Span
ActiveSpan span = TraceContext.createLocalSpan("batchProcessProducts");
try {
    span.tag("product.count", String.valueOf(products.size()));
    for (Product product : products) {
        processProduct(product);
    }
} finally {
    span.close();
}

// ✅ 更好的做法：采样监控
if (shouldTrace()) {  // 只监控10%的请求
    ActiveSpan span = TraceContext.createLocalSpan("batchProcess");
    // ...
}
```

**🎯 Tag使用优化**

```java
// ❌ 避免：Tag值过长
span.tag("request.body", request.toString());  // 可能很长

// ✅ 推荐：只记录关键字段
span.tag("request.id", request.getId());
span.tag("request.type", request.getType());

// ❌ 避免：Tag数量过多
span.tag("field1", value1);
span.tag("field2", value2);
// ... 20个Tag

// ✅ 推荐：精选关键Tag（5-10个为宜）
span.tag("key.metric1", value1);
span.tag("key.metric2", value2);
```

### 6.3 采样策略


**📊 智能采样**

```java
@Component
public class TraceSampler {
    
    // 基于请求频率的采样
    public boolean shouldTrace(String operation) {
        // 高频操作：采样10%
        if (isHighFrequency(operation)) {
            return random.nextInt(100) < 10;
        }
        
        // 中频操作：采样50%
        if (isMediumFrequency(operation)) {
            return random.nextInt(100) < 50;
        }
        
        // 低频操作：100%采样
        return true;
    }
    
    // 基于用户的采样
    public boolean shouldTraceUser(String userId) {
        // VIP用户：100%采样
        if (isVipUser(userId)) {
            return true;
        }
        
        // 普通用户：20%采样
        return userId.hashCode() % 5 == 0;
    }
    
    // 基于错误的采样
    public boolean shouldTraceError(Exception e) {
        // 系统异常：100%采样
        if (e instanceof SystemException) {
            return true;
        }
        
        // 业务异常：50%采样
        return random.nextBoolean();
    }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


🔸 **手动埋点本质**
```
• 补充自动监控的盲区
• 记录业务级别的监控数据
• 让追踪链路更完整、更有意义
```

🔸 **三种Span类型**
```
Entry Span：请求入口（HTTP、MQ）
Exit Span：外部调用（数据库、RPC、HTTP调用）
Local Span：本地逻辑（业务处理、计算）
```

🔸 **Tag vs Log**
```
Tag：结构化元数据，可搜索查询
Log：时间线事件，用于记录日志
```

### 7.2 实战最佳实践


**✅ 应该做的**
```
1. 为关键业务流程添加埋点
2. 使用有意义的Tag命名（user.id, order.amount）
3. 记录异常时要标记 span.errorOccurred()
4. 必须在finally中close Span
5. 记录业务上下文信息
6. 高频场景使用采样策略
```

**❌ 避免做的**
```
1. 不要在循环中创建大量Span
2. 不要记录敏感信息（密码、密钥）
3. 不要让Tag值过长或数量过多
4. 不要忘记关闭Span导致内存泄漏
5. 不要所有地方都埋点（性能影响）
```

### 7.3 应用场景总结


| 场景 | 适合埋点 | Tag示例 | 价值 |
|------|----------|---------|------|
| 🛒 **订单流程** | 库存检查、价格计算、优惠券 | `order.id, amount, discount` | 定位慢环节 |
| 💰 **支付流程** | 余额检查、风控、三方调用 | `payment.method, amount, result` | 追踪支付失败 |
| 👤 **用户行为** | 搜索、浏览、点击 | `user.id, action, keyword` | 分析用户行为 |
| 📊 **KPI统计** | 成功率、响应时间 | `kpi.metric, result, duration` | 监控业务指标 |
| ⚠️ **异常追踪** | 所有异常捕获点 | `error.type, category, severity` | 快速定位问题 |

### 7.4 学习路径建议


```
学习进阶路线：

1️⃣ 基础阶段
   ├── 理解Span概念
   ├── 掌握@Trace注解
   └── 学会添加简单Tag

2️⃣ 进阶阶段
   ├── 手动创建Span
   ├── 异常追踪记录
   └── 嵌套Span使用

3️⃣ 高级阶段  
   ├── 业务指标监控
   ├── 性能优化
   └── 采样策略设计
```

**🎯 实战建议**
- 从一个核心业务流程开始埋点
- 逐步扩展到其他关键流程
- 定期review追踪数据，优化Tag
- 关注性能影响，必要时采样

**核心记忆**：
> 手动埋点是自动监控的补充，不是替代
> Tag要精简有意义，异常要详细记录
> 性能和可观测性需要权衡，采样是关键
> 埋点的目的是快速定位问题，服务业务价值