---
title: 1、SkyWalking服务端部署配置
---
## 📚 目录

1. [SkyWalking服务端概述](#1-SkyWalking服务端概述)
2. [OAP服务详解](#2-OAP服务详解)
3. [单机部署实战](#3-单机部署实战)
4. [集群部署架构](#4-集群部署架构)
5. [配置文件详解](#5-配置文件详解)
6. [端口与网络配置](#6-端口与网络配置)
7. [日志系统配置](#7-日志系统配置)
8. [启动与健康检查](#8-启动与健康检查)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 SkyWalking服务端概述


### 1.1 什么是SkyWalking服务端


**通俗理解**：
想象你开了一家连锁超市，SkyWalking服务端就像是**总部的监控中心**。各个分店（微服务）把自己的运营数据（链路追踪信息）发送到总部，总部负责收集、分析、存储这些数据，然后在大屏幕上展示给你看。

```
分布式系统架构：
┌─────────────────────────────────────┐
│          监控大屏(UI界面)            │
├─────────────────────────────────────┤
│      SkyWalking服务端(总部)         │
│    ┌──────────────────────────┐    │
│    │  OAP服务(分析平台)        │    │
│    │  - 接收追踪数据           │    │
│    │  - 分析处理数据           │    │
│    │  - 存储到数据库           │    │
│    └──────────────────────────┘    │
├─────────────────────────────────────┤
│          存储层(数据库)              │
└─────────────────────────────────────┘
         ↑        ↑        ↑
         |        |        |
    服务A      服务B      服务C
   (探针)     (探针)     (探针)
```

### 1.2 服务端核心组件


SkyWalking服务端主要由两大部分组成：

**🔹 OAP服务（后端大脑）**：
```
OAP = Observability Analysis Platform
可观测性分析平台

作用：
✅ 接收探针发来的追踪数据
✅ 分析链路调用关系
✅ 计算性能指标
✅ 存储数据到数据库
✅ 提供查询接口给UI

就像超市总部的数据分析部门
```

**🔹 UI界面（可视化看板）**：
```
作用：
✅ 展示服务拓扑图
✅ 显示链路追踪详情
✅ 展示性能指标图表
✅ 告警信息展示

就像总部的监控大屏
```

### 1.3 部署模式对比


| 部署方式 | **适用场景** | **优势** | **劣势** |
|---------|------------|---------|---------|
| **单机部署** | `开发测试环境` | `部署简单快速` | `性能有限，无高可用` |
| **集群部署** | `生产环境` | `高性能、高可用` | `配置复杂，成本高` |
| **容器部署** | `云原生环境` | `弹性扩展，易管理` | `需要K8s等容器平台` |

---

## 2. 🧠 OAP服务详解


### 2.1 OAP是什么


**形象比喻**：
OAP就像是一个**智能快递分拣中心**：
- 接收包裹（追踪数据）
- 扫描分类（数据分析）
- 存储入库（写入数据库）
- 提供查询（给UI展示）

```
OAP工作流程：
探针数据 ─→ [gRPC接收] ─→ [数据解析] ─→ [指标计算]
                                          ↓
UI查询 ←─ [查询接口] ←─ [数据存储] ←─ [分析处理]
```

### 2.2 OAP核心功能模块


**📊 数据接收层**：
```
支持多种协议：
• gRPC：推荐方式，高性能二进制协议
• HTTP：兼容方式，适合跨语言
• Kafka：消息队列方式，削峰填谷

接收内容：
• Trace数据：链路追踪信息
• Metric数据：性能指标
• Log数据：日志信息（需配置）
```

**⚙️ 数据处理层**：
```
处理流程：
1. 数据解析：将原始数据解析成内部格式
2. 指标聚合：计算QPS、响应时间等指标
3. 关系分析：构建服务调用拓扑
4. 告警检测：根据规则触发告警
```

**💾 存储适配层**：
```
支持多种存储：
• ElasticSearch：推荐，搜索性能好
• H2：内置数据库，测试用
• MySQL：关系型数据库
• TiDB：分布式数据库
• InfluxDB：时序数据库
```

### 2.3 OAP性能特点


**🚀 性能优化设计**：
```
1. 批量处理：
   - 数据攒批后统一处理
   - 减少数据库写入次数
   
2. 异步处理：
   - 接收和处理解耦
   - 使用队列缓冲数据

3. 多线程模型：
   - 接收线程池
   - 处理线程池
   - 存储线程池

4. 采样策略：
   - 可配置采样率
   - 减少数据量
```

**📈 资源消耗**：
```
典型资源需求（单机）：
CPU：2-4核心
内存：4-8GB（根据数据量调整）
磁盘：主要看存储，OAP本身占用小
网络：需要稳定的网络连接

集群扩展：
• 水平扩展：增加OAP节点数量
• 垂直扩展：增加单个节点配置
```

---

## 3. 💻 单机部署实战


### 3.1 环境准备


**📋 前置条件检查**：
```bash
# 1. 检查Java版本（需要JDK 8或11）
java -version
# 应该看到：java version "1.8.0_xxx" 或 "11.0.x"

# 2. 检查系统资源
free -h    # 检查内存（建议至少4GB可用）
df -h      # 检查磁盘空间（建议至少10GB可用）

# 3. 检查端口占用（确保关键端口未被占用）
netstat -tuln | grep -E '11800|12800|8080'
```

**🔽 下载安装包**：
```bash
# 创建安装目录
mkdir -p /opt/skywalking
cd /opt/skywalking

# 下载SkyWalking（以9.5.0为例）
wget https://archive.apache.org/dist/skywalking/9.5.0/apache-skywalking-apm-9.5.0.tar.gz

# 解压
tar -zxvf apache-skywalking-apm-9.5.0.tar.gz
cd apache-skywalking-apm-bin

# 查看目录结构
ls -la
```

**📁 目录结构说明**：
```
apache-skywalking-apm-bin/
├── bin/              # 启动脚本目录
│   ├── oapService.sh       # OAP服务启动脚本
│   ├── webappService.sh    # UI服务启动脚本
│   └── startup.sh          # 一键启动脚本
├── config/           # 配置文件目录
│   ├── application.yml     # OAP核心配置
│   ├── alarm-settings.yml  # 告警配置
│   └── log4j2.xml         # 日志配置
├── oap-libs/         # OAP依赖库
├── webapp/           # UI界面程序
└── logs/             # 日志输出目录
```

### 3.2 基础配置修改


**⚙️ 最小化配置（开箱即用）**：

默认情况下，SkyWalking使用H2内存数据库，可以直接启动，但**仅适合测试**。

```yaml
# config/application.yml - 核心配置片段
storage:
  selector: ${SW_STORAGE:h2}  # 默认使用H2数据库
  h2:
    driver: ${SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource}
    url: ${SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db}
    # 内存模式，重启数据丢失！
```

**🔧 生产环境配置（使用ElasticSearch）**：
```yaml
# 修改 config/application.yml
storage:
  selector: ${SW_STORAGE:elasticsearch}  # 改用ES存储
  elasticsearch:
    namespace: ${SW_NAMESPACE:"skywalking"}
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}
    protocol: ${SW_STORAGE_ES_HTTP_PROTOCOL:"http"}
    user: ${SW_ES_USER:""}
    password: ${SW_ES_PASSWORD:""}
    # 索引设置
    indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:1}
    indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0}
```

**💡 配置说明（通俗解释）**：
```
clusterNodes: ES集群地址
• 单机：localhost:9200
• 集群：192.168.1.10:9200,192.168.1.11:9200

namespace: 命名空间（就像给数据加个前缀）
• 避免多个SkyWalking实例数据冲突
• 默认"skywalking"即可

indexShardsNumber: 分片数
• 数据分成几份存储
• 单机设为1，集群可设为3-5

indexReplicasNumber: 副本数
• 数据备份几份
• 测试环境0，生产环境1-2
```

### 3.3 快速启动步骤


**🚀 启动服务（开发环境）**：
```bash
# 方式1：一键启动（OAP + UI）
cd /opt/skywalking/apache-skywalking-apm-bin
bin/startup.sh

# 方式2：分别启动（更灵活）
# 先启动OAP
bin/oapService.sh

# 等待OAP启动完成（约30秒），再启动UI
bin/webappService.sh
```

**⏳ 启动过程观察**：
```bash
# 实时查看OAP启动日志
tail -f logs/skywalking-oap-server.log

# 看到这些信息说明启动成功：
# ✅ "OAP server started successfully!"
# ✅ "gRPC server started, host=0.0.0.0, port=11800"
# ✅ "Rest server started, host=0.0.0.0, port=12800"

# 查看UI启动日志
tail -f logs/webapp.log

# 看到这个信息说明UI启动成功：
# ✅ "Webapp started successfully!"
```

**🔍 启动验证**：
```bash
# 1. 检查进程是否启动
ps aux | grep skywalking
# 应该看到两个java进程：OAP和webapp

# 2. 检查端口监听
netstat -tuln | grep -E '11800|12800|8080'
# 11800: gRPC接收端口（探针连接）
# 12800: HTTP查询端口（UI查询）
# 8080: UI界面端口

# 3. 访问UI界面
curl http://localhost:8080
# 或浏览器打开：http://服务器IP:8080
```

### 3.4 常见启动问题


**❗ 问题1：端口被占用**
```bash
# 错误信息：Port 8080 already in use

# 解决方法1：修改端口
vim webapp/webapp.yml
# 修改 server.port 为其他端口如 8888

# 解决方法2：停止占用端口的程序
lsof -i:8080
kill -9 <PID>
```

**❗ 问题2：内存不足**
```bash
# 错误信息：OutOfMemoryError

# 解决方法：调整JVM内存
vim bin/oapService.sh
# 找到 JAVA_OPTS，修改内存参数
JAVA_OPTS="-Xms2g -Xmx4g"  # 最小2G，最大4G
```

**❗ 问题3：连接ES失败**
```bash
# 错误信息：Connection refused to elasticsearch

# 检查ES是否启动
curl http://localhost:9200
# 如果无响应，先启动ES

# 检查配置是否正确
vim config/application.yml
# 确认 clusterNodes 配置的地址能访问
```

---

## 4. 🏗️ 集群部署架构


### 4.1 为什么需要集群部署


**单机的局限性**：
```
单机部署问题：
❌ 性能瓶颈：
   - 数据量大时处理不过来
   - 单节点CPU/内存受限

❌ 可用性差：
   - 服务挂了整个监控就瘫痪
   - 无法实现故障自动切换

❌ 扩展性差：
   - 业务增长时难以扩容
   - 无法动态调整资源
```

**集群部署优势**：
```
✅ 高性能：
   • 多节点分担负载
   • 并行处理数据
   
✅ 高可用：
   • 节点故障自动摘除
   • 服务不中断
   
✅ 易扩展：
   • 水平扩展加机器
   • 负载均衡分流
```

### 4.2 集群架构设计


**🏛️ 标准集群架构**：
```
                  [Nginx负载均衡]
                        |
        ┌───────────────┼───────────────┐
        ↓               ↓               ↓
    [OAP节点1]      [OAP节点2]      [OAP节点3]
        |               |               |
        └───────────────┼───────────────┘
                        ↓
              [ElasticSearch集群]
               ES1    ES2    ES3
                        
探针数据 → Nginx → 任意OAP节点 → ES存储
UI查询  → Nginx → 任意OAP节点 → ES查询
```

**🔄 数据流转过程**：
```
1. 探针发送数据到Nginx
2. Nginx负载均衡转发到某个OAP节点
3. OAP节点处理数据
4. 数据写入ES集群
5. UI查询时，从任意OAP节点获取数据
6. OAP从ES查询数据返回
```

### 4.3 集群配置要点


**⚙️ OAP集群配置**：
```yaml
# config/application.yml
cluster:
  selector: ${SW_CLUSTER:zookeeper}  # 集群协调器
  zookeeper:
    namespace: ${SW_NAMESPACE:""}
    hostPort: ${SW_CLUSTER_ZK_HOST_PORT:localhost:2181}
    # Zookeeper用于节点发现和协调
    
    baseSleepTimeMs: ${SW_CLUSTER_ZK_SLEEP_TIME:1000}
    maxRetries: ${SW_CLUSTER_ZK_MAX_RETRIES:3}
```

**🔗 集群协调方式对比**：

| 协调方式 | **原理** | **优点** | **缺点** |
|---------|---------|---------|---------|
| **Standalone** | `单机模式` | `无需配置` | `不支持集群` |
| **Zookeeper** | `分布式协调` | `成熟稳定` | `需要ZK集群` |
| **Kubernetes** | `K8s服务发现` | `云原生友好` | `需要K8s环境` |
| **Consul** | `服务注册发现` | `轻量级` | `需要额外部署` |

**💡 集群配置建议**：
```
开发/测试环境：
• 单机standalone模式
• 使用H2内存数据库
• 快速验证功能

生产环境：
• 至少3个OAP节点（奇数个，方便选举）
• 使用Zookeeper或Kubernetes协调
• ES集群存储（至少3节点）
• Nginx做负载均衡
```

### 4.4 集群部署实战


**📋 部署步骤（以3节点为例）**：

```bash
# === 步骤1：准备3台服务器 ===
# 192.168.1.10 - OAP节点1
# 192.168.1.11 - OAP节点2  
# 192.168.1.12 - OAP节点3

# === 步骤2：每个节点安装SkyWalking ===
# 在每台机器上执行：
wget https://archive.apache.org/dist/skywalking/9.5.0/apache-skywalking-apm-9.5.0.tar.gz
tar -zxvf apache-skywalking-apm-9.5.0.tar.gz

# === 步骤3：配置集群（每个节点都要配置）===
vim config/application.yml
```

**配置示例**：
```yaml
# === 集群配置 ===
cluster:
  selector: ${SW_CLUSTER:zookeeper}
  zookeeper:
    hostPort: ${SW_CLUSTER_ZK_HOST_PORT:192.168.1.20:2181}
    # ZK地址，假设ZK部署在192.168.1.20

# === 存储配置（指向ES集群）===
storage:
  selector: ${SW_STORAGE:elasticsearch}
  elasticsearch:
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:192.168.1.30:9200,192.168.1.31:9200,192.168.1.32:9200}
    # ES集群地址
```

**🚀 启动集群**：
```bash
# 每个OAP节点执行启动
bin/oapService.sh

# 查看集群状态（在任意节点）
# 访问：http://任意节点IP:12800/internal/l7check
curl http://192.168.1.10:12800/internal/l7check
# 返回200表示正常
```

**🔄 Nginx负载均衡配置**：
```nginx
# /etc/nginx/conf.d/skywalking.conf
upstream skywalking_oap {
    # OAP的gRPC端口（探针连接）
    server 192.168.1.10:11800;
    server 192.168.1.11:11800;
    server 192.168.1.12:11800;
}

upstream skywalking_ui {
    # OAP的查询端口（UI查询）
    server 192.168.1.10:12800;
    server 192.168.1.11:12800;
    server 192.168.1.12:12800;
}

# gRPC负载均衡（探针连接）
server {
    listen 11800 http2;
    location / {
        grpc_pass grpc://skywalking_oap;
    }
}

# HTTP负载均衡（UI查询）
server {
    listen 12800;
    location / {
        proxy_pass http://skywalking_ui;
    }
}
```

---

## 5. 📝 配置文件详解


### 5.1 核心配置文件结构


SkyWalking的配置采用**模块化设计**，每个配置文件负责不同功能：

```
config/
├── application.yml        # 核心配置（最重要）
├── alarm-settings.yml     # 告警规则配置
├── log4j2.xml            # 日志配置
├── component-libraries.yml # 组件库定义
└── metadata-service-mapping.yml # 元数据映射
```

### 5.2 application.yml详解


**🔧 配置文件结构概览**：
```yaml
# ===== 1. 集群配置 =====
cluster:
  selector: ${SW_CLUSTER:standalone}  # 集群模式选择

# ===== 2. 核心服务配置 =====
core:
  default:
    role: ${SW_CORE_ROLE:Mixed}  # 角色：Mixed/Receiver/Aggregator
    restHost: ${SW_CORE_REST_HOST:0.0.0.0}
    restPort: ${SW_CORE_REST_PORT:12800}
    gRPCHost: ${SW_CORE_GRPC_HOST:0.0.0.0}
    gRPCPort: ${SW_CORE_GRPC_PORT:11800}

# ===== 3. 存储配置 =====
storage:
  selector: ${SW_STORAGE:h2}  # 存储类型选择

# ===== 4. 接收器配置 =====
receiver:
  selector: ${SW_RECEIVER:default}  # 接收器选择
```

**🎯 核心参数详解（通俗说明）**：

**1. 服务角色配置**：
```yaml
core:
  default:
    role: ${SW_CORE_ROLE:Mixed}
```
```
角色说明：
• Mixed（混合模式）：
  - 既接收数据，又处理分析
  - 单机部署用这个
  - 简单省事

• Receiver（接收者）：
  - 只负责接收数据
  - 适合高并发场景
  - 专门优化接收性能

• Aggregator（聚合者）：
  - 只负责数据分析处理
  - 适合计算密集场景
  - 专门优化分析性能

生产环境可以分离部署：
几台Receiver接收 + 几台Aggregator处理
```

**2. 端口配置**：
```yaml
restPort: ${SW_CORE_REST_PORT:12800}  # HTTP查询端口
gRPCPort: ${SW_CORE_GRPC_PORT:11800}  # gRPC接收端口
```
```
端口用途：
12800（REST端口）：
• UI界面查询数据用
• HTTP方式的探针数据上报
• 健康检查接口

11800（gRPC端口）：
• 探针上报追踪数据（主要）
• 高性能二进制协议
• 推荐探针使用这个端口
```

**3. 数据处理配置**：
```yaml
receiver-sharing-server:
  selector: ${SW_RECEIVER_SHARING_SERVER:default}
  default:
    bufferPath: ${SW_RECEIVER_BUFFER_PATH:../buffer/}
    bufferOffsetMaxFileSize: ${SW_RECEIVER_BUFFER_OFFSET_MAX_FILE_SIZE:100}
    bufferDataMaxFileSize: ${SW_RECEIVER_BUFFER_DATA_MAX_FILE_SIZE:500}
```
```
缓冲区配置（重要）：
bufferPath：数据缓冲目录
• 当处理不过来时，先存到磁盘
• 类似排队等候区

bufferOffsetMaxFileSize：偏移文件大小（MB）
• 记录处理位置的文件大小
• 一般默认100MB够用

bufferDataMaxFileSize：数据文件大小（MB）
• 缓冲数据的文件大小
• 根据流量调整，500MB是推荐值
```

### 5.3 存储配置对比


**📊 不同存储的配置对比**：

**ElasticSearch配置（生产推荐）**：
```yaml
storage:
  selector: elasticsearch
  elasticsearch:
    namespace: "skywalking"
    clusterNodes: "localhost:9200"
    protocol: "http"
    connectTimeout: ${SW_STORAGE_ES_CONNECT_TIMEOUT:3000}
    socketTimeout: ${SW_STORAGE_ES_SOCKET_TIMEOUT:30000}
    responseTimeout: ${SW_STORAGE_ES_RESPONSE_TIMEOUT:15000}
    # 批量写入配置
    bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:5000}
    flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:15}
    concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2}
```

**MySQL配置（小规模使用）**：
```yaml
storage:
  selector: mysql
  mysql:
    properties:
      jdbcUrl: ${SW_JDBC_URL:"jdbc:mysql://localhost:3306/swtest"}
      dataSource.user: ${SW_DATA_SOURCE_USER:root}
      dataSource.password: ${SW_DATA_SOURCE_PASSWORD:root}
      dataSource.cachePrepStmts: ${SW_DATA_SOURCE_CACHE_PREP_STMTS:true}
      dataSource.prepStmtCacheSize: ${SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_SIZE:250}
```

**性能对比说明**：
```
ElasticSearch：
优势：✅ 搜索快、可扩展、适合大数据量
劣势：❌ 资源占用高、配置相对复杂
建议：生产环境首选，数据量大的场景

MySQL：
优势：✅ 熟悉度高、运维简单、事务支持好
劣势：❌ 大数据量性能差、扩展性受限
建议：小规模系统、测试环境使用

H2：
优势：✅ 无需额外部署、开箱即用
劣势：❌ 内存存储、重启数据丢失
建议：仅用于快速验证、demo演示
```

---

## 6. 🌐 端口与网络配置


### 6.1 端口用途详解


**📡 SkyWalking涉及的所有端口**：

| 端口号 | **用途** | **协议** | **访问者** | **必须开放** |
|-------|---------|---------|-----------|------------|
| **11800** | `gRPC数据接收` | `gRPC/HTTP2` | `探针Agent` | `是` |
| **12800** | `REST查询接口` | `HTTP` | `UI界面` | `是` |
| **8080** | `UI界面访问` | `HTTP` | `用户浏览器` | `是` |
| **1234** | `远程调试端口` | `JVM调试` | `开发人员` | `否（开发用）` |

**🔍 端口详细说明**：

**端口11800（最重要）**：
```
作用：接收探针发来的追踪数据
协议：gRPC（基于HTTP/2）
流量：持续有数据，流量较大

配置位置：
# application.yml
core:
  default:
    gRPCPort: ${SW_CORE_GRPC_PORT:11800}

探针配置需要指向这个端口：
-Dskywalking.collector.backend_service=192.168.1.10:11800
```

**端口12800（查询端口）**：
```
作用：提供HTTP查询接口
协议：HTTP/REST
流量：按需查询，流量较小

主要接口：
GET /graphql         - GraphQL查询
GET /internal/l7check - 健康检查
GET /v3/logs/query   - 日志查询

UI通过这个端口获取数据
```

**端口8080（UI界面）**：
```
作用：Web界面访问
协议：HTTP
用户：监控人员、开发人员

可修改端口：
# webapp/webapp.yml
server:
  port: ${SW_SERVER_PORT:-8080}

访问方式：
http://服务器IP:8080
```

### 6.2 防火墙配置


**🛡️ 安全配置建议**：

**Linux防火墙（firewalld）**：
```bash
# 开放SkyWalking端口
firewall-cmd --permanent --add-port=11800/tcp
firewall-cmd --permanent --add-port=12800/tcp
firewall-cmd --permanent --add-port=8080/tcp

# 重载配置
firewall-cmd --reload

# 验证配置
firewall-cmd --list-ports
```

**iptables配置**：
```bash
# 允许11800端口（gRPC）
iptables -A INPUT -p tcp --dport 11800 -j ACCEPT

# 允许12800端口（REST）
iptables -A INPUT -p tcp --dport 12800 -j ACCEPT

# 允许8080端口（UI）
iptables -A INPUT -p tcp --dport 8080 -j ACCEPT

# 保存规则
service iptables save
```

**云服务器安全组**：
```
阿里云/腾讯云/AWS等：
1. 登录云控制台
2. 找到安全组规则
3. 添加入站规则：
   - 端口11800，协议TCP，来源：应用服务器IP段
   - 端口12800，协议TCP，来源：UI服务器IP
   - 端口8080，协议TCP，来源：办公网IP段
```

### 6.3 网络优化配置


**⚡ 性能调优参数**：

**JVM网络参数**：
```bash
# bin/oapService.sh
JAVA_OPTS="$JAVA_OPTS \
  -Djava.net.preferIPv4Stack=true \
  -Dnetworkaddress.cache.ttl=30 \
  -XX:+UseCompressedOops"

# 参数说明：
# preferIPv4Stack：优先使用IPv4
# cache.ttl：DNS缓存30秒（减少DNS查询）
# UseCompressedOops：压缩对象指针（节省内存）
```

**TCP参数优化**：
```bash
# /etc/sysctl.conf
# 增加TCP连接队列
net.core.somaxconn = 1024
net.ipv4.tcp_max_syn_backlog = 2048

# 快速回收TIME_WAIT连接
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30

# 应用配置
sysctl -p
```

---

## 7. 📋 日志系统配置


### 7.1 日志配置文件


SkyWalking使用**Log4j2**作为日志框架，配置文件位于`config/log4j2.xml`

**🔍 日志文件分类**：
```
logs/
├── skywalking-oap-server.log    # OAP主日志
├── slow-sql.log                 # 慢SQL日志
├── alarm.log                    # 告警日志
└── gc.log                       # GC日志（如果开启）
```

### 7.2 日志级别配置


**📊 日志级别说明**：
```
级别从低到高：
TRACE → DEBUG → INFO → WARN → ERROR

推荐配置：
• 开发环境：DEBUG（看详细过程）
• 测试环境：INFO（正常信息）
• 生产环境：WARN（只看警告和错误）
```

**配置示例**：
```xml
<!-- config/log4j2.xml -->
<Configuration status="WARN">
  <Appenders>
    <!-- 控制台输出 -->
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
    
    <!-- 文件输出 -->
    <RollingFile name="RollingFile" 
                 fileName="logs/skywalking-oap-server.log"
                 filePattern="logs/skywalking-oap-server-%d{yyyy-MM-dd}-%i.log.gz">
      <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
      <Policies>
        <!-- 每天滚动 -->
        <TimeBasedTriggeringPolicy interval="1"/>
        <!-- 文件大小超过100MB滚动 -->
        <SizeBasedTriggeringPolicy size="100MB"/>
      </Policies>
      <!-- 保留30个历史文件 -->
      <DefaultRolloverStrategy max="30"/>
    </RollingFile>
  </Appenders>
  
  <Loggers>
    <!-- 根日志级别 -->
    <Root level="INFO">
      <AppenderRef ref="Console"/>
      <AppenderRef ref="RollingFile"/>
    </Root>
    
    <!-- 特定包的日志级别 -->
    <Logger name="org.apache.skywalking" level="INFO"/>
    <Logger name="io.grpc.netty" level="WARN"/>
  </Loggers>
</Configuration>
```

### 7.3 日志管理实践


**🗂️ 日志轮转策略**：
```
生产环境建议：
• 按天轮转：每天生成新日志文件
• 大小限制：单文件不超过100MB
• 保留天数：保留30天（根据磁盘空间调整）
• 压缩存储：历史日志压缩为.gz格式

磁盘空间预估：
如果每天日志100MB，保留30天 = 3GB
建议预留至少10GB给日志目录
```

**🔍 日志查看技巧**：
```bash
# 实时查看最新日志
tail -f logs/skywalking-oap-server.log

# 查看最近100行
tail -n 100 logs/skywalking-oap-server.log

# 查看ERROR级别日志
grep "ERROR" logs/skywalking-oap-server.log

# 查看特定时间段日志
sed -n '/2024-01-20 10:00/,/2024-01-20 11:00/p' logs/skywalking-oap-server.log

# 统计ERROR数量
grep -c "ERROR" logs/skywalking-oap-server.log
```

**⚠️ 常见日志问题排查**：
```
问题1：磁盘空间不足
现象：日志输出中断，程序异常
解决：
  df -h  # 检查磁盘
  du -sh logs/*  # 查看日志大小
  find logs/ -name "*.gz" -mtime +30 -delete  # 删除30天前日志

问题2：日志过多影响性能
现象：IO等待高，程序变慢
解决：
  调高日志级别：INFO → WARN
  减少日志输出：关闭DEBUG日志
  增加异步输出：使用AsyncAppender

问题3：日志中文乱码
解决：
  在 bin/oapService.sh 添加：
  JAVA_OPTS="$JAVA_OPTS -Dfile.encoding=UTF-8"
```

---

## 8. ✅ 启动与健康检查


### 8.1 启动脚本详解


**📜 启动脚本分析**：
```bash
# bin/oapService.sh（核心启动脚本）
#!/bin/sh

# 1. 设置环境变量
PRG="$0"
PRGDIR=`dirname "$PRG"`
[ -z "$OAP_HOME" ] && OAP_HOME=`cd "$PRGDIR/.." >/dev/null; pwd`

# 2. 设置JVM参数
OAP_JVM_OPTS="-Xms2g -Xmx2g"  # 堆内存设置
OAP_JVM_OPTS="$OAP_JVM_OPTS -XX:+UseG1GC"  # 使用G1垃圾收集器

# 3. 启动OAP服务
java $OAP_JVM_OPTS \
     -classpath $OAP_HOME/config:$OAP_HOME/oap-libs/* \
     org.apache.skywalking.oap.server.starter.OAPServerStartUp
```

**⚙️ JVM参数调优**：
```bash
# 根据服务器配置调整参数
vim bin/oapService.sh

# 小内存服务器（4GB）
OAP_JVM_OPTS="-Xms1g -Xmx2g"

# 中等服务器（8GB）
OAP_JVM_OPTS="-Xms2g -Xmx4g"

# 大内存服务器（16GB+）
OAP_JVM_OPTS="-Xms4g -Xmx8g"

# 其他优化参数
OAP_JVM_OPTS="$OAP_JVM_OPTS -XX:+UseG1GC"  # G1垃圾收集器
OAP_JVM_OPTS="$OAP_JVM_OPTS -XX:MaxGCPauseMillis=200"  # GC停顿时间
OAP_JVM_OPTS="$OAP_JVM_OPTS -XX:+PrintGCDetails"  # GC日志
OAP_JVM_OPTS="$OAP_JVM_OPTS -Xloggc:logs/gc.log"  # GC日志文件
```

### 8.2 启动流程与验证


**🚀 标准启动流程**：

```bash
# === 步骤1：启动前检查 ===
# 检查Java版本
java -version

# 检查端口占用
netstat -tuln | grep -E '11800|12800|8080'

# 检查配置文件
cat config/application.yml | grep -v '^#' | grep -v '^$'

# === 步骤2：启动OAP服务 ===
cd /opt/skywalking/apache-skywalking-apm-bin
bin/oapService.sh

# === 步骤3：观察启动日志 ===
tail -f logs/skywalking-oap-server.log

# 成功标志：
# [main] INFO  - OAP server started successfully!
# [main] INFO  - gRPC server started, host=0.0.0.0, port=11800
# [main] INFO  - Rest server started, host=0.0.0.0, port=12800

# === 步骤4：启动UI ===
bin/webappService.sh

# === 步骤5：验证UI启动 ===
tail -f logs/webapp.log
# 看到：Webapp started successfully!
```

### 8.3 健康检查机制


**🏥 健康检查接口**：

SkyWalking提供多个健康检查接口，用于监控服务状态。

**接口1：服务健康检查**
```bash
# L7（应用层）健康检查
curl http://localhost:12800/internal/l7check

# 返回值：
# 200 OK - 服务正常
# 503 Service Unavailable - 服务异常
```

**接口2：图形化检查**
```bash
# 访问UI界面
curl http://localhost:8080

# 或浏览器打开：
# http://服务器IP:8080
# 能看到界面说明UI正常
```

**接口3：探针连接检查**
```bash
# 检查11800端口是否监听
telnet localhost 11800

# 或使用netstat
netstat -tuln | grep 11800
# 输出类似：tcp  0  0  0.0.0.0:11800  0.0.0.0:*  LISTEN
```

**🔄 自动化健康检查脚本**：
```bash
#!/bin/bash
# skywalking-health-check.sh

echo "开始检查SkyWalking服务状态..."

# 1. 检查进程
OAP_PID=$(ps aux | grep 'OAPServerStartUp' | grep -v grep | awk '{print $2}')
if [ -z "$OAP_PID" ]; then
    echo "❌ OAP服务未启动"
    exit 1
else
    echo "✅ OAP服务运行中 (PID: $OAP_PID)"
fi

# 2. 检查端口
if netstat -tuln | grep -q ':11800'; then
    echo "✅ gRPC端口(11800)正常监听"
else
    echo "❌ gRPC端口(11800)未监听"
    exit 1
fi

if netstat -tuln | grep -q ':12800'; then
    echo "✅ REST端口(12800)正常监听"
else
    echo "❌ REST端口(12800)未监听"
    exit 1
fi

# 3. HTTP健康检查
HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:12800/internal/l7check)
if [ "$HTTP_CODE" = "200" ]; then
    echo "✅ 服务健康检查通过"
else
    echo "❌ 服务健康检查失败 (HTTP: $HTTP_CODE)"
    exit 1
fi

echo "🎉 所有检查通过，服务运行正常！"
```

### 8.4 开机自启动配置


**🔄 Systemd服务配置**：

```bash
# 创建systemd服务文件
sudo vim /etc/systemd/system/skywalking-oap.service
```

**服务配置内容**：
```ini
[Unit]
Description=Apache SkyWalking OAP Server
After=network.target

[Service]
Type=forking
User=skywalking
Group=skywalking
Environment="JAVA_HOME=/usr/lib/jvm/java-11-openjdk"
ExecStart=/opt/skywalking/apache-skywalking-apm-bin/bin/oapService.sh
ExecStop=/bin/kill -s TERM $MAINPID
PrivateTmp=true
Restart=on-failure
RestartSec=30s

[Install]
WantedBy=multi-user.target
```

**启用服务**：
```bash
# 重载systemd配置
sudo systemctl daemon-reload

# 启动服务
sudo systemctl start skywalking-oap

# 设置开机自启
sudo systemctl enable skywalking-oap

# 查看服务状态
sudo systemctl status skywalking-oap

# 查看日志
sudo journalctl -u skywalking-oap -f
```

**UI服务配置**（类似）：
```bash
sudo vim /etc/systemd/system/skywalking-ui.service
```

```ini
[Unit]
Description=Apache SkyWalking UI
After=skywalking-oap.service
Requires=skywalking-oap.service

[Service]
Type=forking
User=skywalking
Group=skywalking
ExecStart=/opt/skywalking/apache-skywalking-apm-bin/bin/webappService.sh
ExecStop=/bin/kill -s TERM $MAINPID
Restart=on-failure
RestartSec=30s

[Install]
WantedBy=multi-user.target
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 OAP服务：SkyWalking的核心，负责数据接收、分析、存储
🔸 部署模式：单机（测试）、集群（生产）、容器化（云原生）
🔸 端口功能：11800(gRPC)、12800(REST)、8080(UI)
🔸 存储选择：H2(测试)、ES(推荐)、MySQL(小规模)
🔸 集群协调：Zookeeper、Kubernetes、Consul
🔸 配置优先级：环境变量 > application.yml > 默认值
```

### 9.2 关键理解要点


**🔹 为什么需要OAP服务**
```
问题场景：
• 微服务众多，追踪数据量大
• 数据格式各异，需要统一处理
• 实时分析性能瓶颈
• 持久化存储历史数据

OAP的价值：
• 集中式数据处理中心
• 标准化数据格式
• 高性能数据分析
• 灵活的存储选择
```

**🔹 单机vs集群的选择**
```
单机部署适用：
• 开发测试环境
• 微服务数量少（<10个）
• 流量不大（<1000 TPS）
• 快速验证功能

集群部署适用：
• 生产环境
• 微服务数量多（>20个）
• 高并发场景（>5000 TPS）
• 高可用性要求
```

**🔹 配置调优思路**
```
性能调优三板斧：
1. JVM调优：
   • 合理设置堆内存
   • 选择合适的GC收集器
   • 监控GC日志

2. 存储调优：
   • ES集群化部署
   • 合理设置分片副本
   • 定期清理历史数据

3. 网络调优：
   • 启用gRPC压缩
   • 调整TCP参数
   • 负载均衡分流
```

### 9.3 实际应用指导


**💼 部署最佳实践**
```
开发环境：
• 单机部署，使用H2数据库
• 日志级别DEBUG，方便排查
• 无需开机自启

测试环境：
• 单机或小集群（2节点）
• 使用ES单机或小集群
• 日志级别INFO
• 配置systemd服务

生产环境：
• 集群部署（至少3节点）
• ES集群（3-5节点）
• 日志级别WARN
• 完整的监控告警
• 定期备份配置
```

**🛠️ 运维注意事项**
```
日常维护：
• 监控磁盘空间（日志+存储）
• 定期清理历史数据
• 关注JVM内存使用
• 查看错误日志

升级操作：
• 先升级测试环境验证
• 集群滚动升级，避免中断
• 备份配置文件
• 保留历史版本以便回滚

故障处理：
• 检查进程是否存在
• 查看端口是否监听
• 分析错误日志
• 验证存储连接
```

### 9.4 常见问题速查


**❓ 启动失败怎么办？**
```
排查步骤：
1. 查看启动日志
   tail -f logs/skywalking-oap-server.log
   
2. 检查端口占用
   netstat -tuln | grep -E '11800|12800'
   
3. 验证配置文件
   检查application.yml语法
   
4. 检查存储连接
   测试ES/MySQL是否可访问
```

**❓ UI界面无法访问？**
```
排查步骤：
1. 确认UI进程启动
   ps aux | grep webapp
   
2. 检查端口监听
   netstat -tuln | grep 8080
   
3. 验证防火墙
   telnet 服务器IP 8080
   
4. 查看UI日志
   tail -f logs/webapp.log
```

**❓ 探针连接不上？**
```
排查步骤：
1. 检查11800端口
   telnet OAP_IP 11800
   
2. 验证网络连通性
   ping OAP_IP
   
3. 查看OAP日志
   grep "gRPC" logs/skywalking-oap-server.log
   
4. 检查探针配置
   确认backend_service地址正确
```

**🧠 记忆口诀**
```
服务端部署三步走：
1. 环境准备要充足（Java、端口、磁盘）
2. 配置文件要细读（存储、集群、日志）
3. 启动验证要完整（进程、端口、健康检查）

配置调优三要素：
1. JVM内存看负载（根据流量调整堆大小）
2. 存储选择看规模（小用MySQL，大用ES）
3. 日志级别看环境（开发DEBUG，生产WARN）
```

**核心理念**：
SkyWalking服务端部署不难，关键是理解每个组件的作用。单机部署快速上手，集群部署保障稳定。配置参数虽多，但抓住核心几项（存储、端口、内存）就能满足大部分需求。记住：先跑起来，再慢慢优化！