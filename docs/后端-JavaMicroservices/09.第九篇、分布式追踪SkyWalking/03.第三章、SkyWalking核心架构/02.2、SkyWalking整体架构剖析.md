---
title: 2、SkyWalking整体架构剖析
---
## 📚 目录

1. [SkyWalking是什么](#1-SkyWalking是什么)
2. [Agent探针详解](#2-Agent探针详解)
3. [OAP服务器核心功能](#3-OAP服务器核心功能)
4. [Storage存储层设计](#4-Storage存储层设计)
5. [UI控制台介绍](#5-UI控制台介绍)
6. [数据流转完整过程](#6-数据流转完整过程)
7. [架构分层设计](#7-架构分层设计)
8. [组件职责划分](#8-组件职责划分)
9. [数据处理流程](#9-数据处理流程)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 SkyWalking是什么


### 1.1 用生活例子理解SkyWalking

💡 **简单理解**：SkyWalking就像一个"智能监控系统"

```
想象你开了一家连锁餐厅：
- 每家分店都有监控摄像头 → 这就是Agent探针
- 总部的监控中心收集所有视频 → 这就是OAP服务器
- 监控录像存储在硬盘里 → 这就是Storage存储层
- 经理通过屏幕查看各店情况 → 这就是UI控制台

当顾客投诉服务慢：
1. 调出监控录像（查看调用链）
2. 看看哪个环节出问题（定位性能瓶颈）
3. 找到具体的服务员（定位问题服务）
4. 分析原因并改进（性能优化）
```

### 1.2 SkyWalking的核心价值

**🔸 解决的实际问题**

```
微服务架构的痛点：
❌ 一个请求经过10个服务，哪个服务慢了？
❌ 系统突然变慢，是哪里出问题了？
❌ 服务挂了，影响了哪些业务？
❌ 用户操作失败，具体错误在哪？

SkyWalking的解决方案：
✅ 完整追踪请求路径（链路追踪）
✅ 实时监控性能指标（性能分析）
✅ 可视化服务依赖关系（拓扑图）
✅ 快速定位故障根源（问题诊断）
```

### 1.3 SkyWalking的应用场景

**📊 实际使用场景**

| 场景 | **问题** | **SkyWalking如何帮助** |
|------|---------|----------------------|
| 🔸 **性能问题** | `某个接口特别慢` | `通过链路追踪找到慢在哪个服务` |
| 🔸 **故障定位** | `系统突然报错` | `查看调用链定位具体错误点` |
| 🔸 **容量规划** | `需要扩容哪些服务` | `通过监控数据分析服务负载` |
| 🔸 **依赖分析** | `服务间调用关系复杂` | `拓扑图清晰展示依赖关系` |

---

## 2. 🕵️ Agent探针详解


### 2.1 Agent探针是什么

🎯 **用比喻理解Agent**

```
Agent就像"贴身保镖"：
- 跟随应用程序运行 → 无需修改业务代码
- 记录所有行为 → 自动采集性能数据
- 实时上报情况 → 发送到监控中心
- 不影响主人行动 → 对业务零侵入

技术实现原理：
通过Java Agent技术（字节码增强）
在应用启动时自动注入监控代码
就像给程序装了"行车记录仪"
```

### 2.2 Agent的工作机制

**🔧 Agent如何采集数据**

```
数据采集的完整过程：

1. 应用启动时加载Agent
   java -javaagent:skywalking-agent.jar -jar your-app.jar
   ↓
2. Agent自动识别框架
   发现Spring MVC、Dubbo、MySQL等
   ↓
3. 拦截关键操作
   拦截HTTP请求、RPC调用、数据库操作
   ↓
4. 记录性能数据
   记录开始时间、结束时间、方法参数等
   ↓
5. 上报到OAP服务器
   通过gRPC协议发送数据
```

**💡 Agent采集的关键信息**

```
Span（跨度）- 一次操作的记录：
┌─────────────────────────────────┐
│ TraceId: 全局唯一的追踪ID        │
│ SpanId: 当前操作的ID             │
│ ParentSpanId: 父操作的ID         │
│ ServiceName: 服务名称            │
│ OperationName: 操作名称          │
│ StartTime: 开始时间              │
│ EndTime: 结束时间                │
│ Tags: 标签（如HTTP状态码）        │
│ Logs: 日志（如异常信息）          │
└─────────────────────────────────┘
```

### 2.3 Agent的部署方式

**📦 如何在项目中使用Agent**

```bash
# 方式1：启动参数方式（最常用）
java -javaagent:/path/to/skywalking-agent.jar \
     -Dskywalking.agent.service_name=order-service \
     -Dskywalking.collector.backend_service=127.0.0.1:11800 \
     -jar order-service.jar

# 方式2：环境变量方式
export SW_AGENT_NAME=order-service
export SW_AGENT_COLLECTOR_BACKEND_SERVICES=127.0.0.1:11800
java -javaagent:/path/to/skywalking-agent.jar -jar order-service.jar

# 方式3：Docker容器部署
FROM openjdk:11-jre
COPY skywalking-agent /skywalking-agent
COPY app.jar /app.jar
ENV SW_AGENT_NAME=my-service
ENV SW_AGENT_COLLECTOR_BACKEND_SERVICES=oap-server:11800
ENTRYPOINT ["java","-javaagent:/skywalking-agent/skywalking-agent.jar","-jar","/app.jar"]
```

**🔸 Agent配置要点**

```
核心配置项说明：

agent.service_name
  作用：服务的唯一标识
  示例：order-service, user-service
  
collector.backend_service  
  作用：OAP服务器地址
  示例：192.168.1.100:11800
  
agent.sample_n_per_3_secs
  作用：采样率控制（高流量时降低采样）
  示例：-1表示全采样，5表示3秒内最多采5条
  
plugin.exclude_plugins
  作用：禁用某些插件
  示例：不监控Redis可以禁用jedis插件
```

---

## 3. 🖥️ OAP服务器核心功能


### 3.1 OAP是什么

💡 **理解OAP的角色**

```
OAP (Observability Analysis Platform) 可观测性分析平台

用快递中心类比：
Agent → 各地快递员（采集数据）
OAP → 快递分拣中心（处理数据）
Storage → 仓库（存储数据）
UI → 客服系统（查询数据）

OAP的核心职责：
1. 接收Agent上报的数据
2. 聚合分析数据（计算指标）
3. 存储到数据库
4. 提供查询接口给UI
```

### 3.2 OAP的数据处理流程

**🔄 从接收到存储的完整链路**

```
数据处理的四个阶段：

阶段1：数据接收（Receiver）
Agent通过gRPC发送Trace数据
  ↓
OAP的Receiver模块接收
  ↓
解析并验证数据格式

阶段2：数据分析（Analysis）
流式处理每一条Trace
  ↓
提取关键指标（响应时间、错误率等）
  ↓
聚合计算（如每分钟平均响应时间）

阶段3：数据存储（Storage）
将处理后的数据写入存储层
  ↓
支持多种存储：ES、MySQL、H2等

阶段4：数据查询（Query）
UI通过GraphQL查询数据
  ↓
OAP从存储层检索
  ↓
返回给UI展示
```

### 3.3 OAP的聚合计算能力

**📊 OAP如何计算指标**

```
实时指标计算示例：

原始数据（Agent上报）：
2024-01-11 10:00:01 | order-service | /api/order/create | 150ms | success
2024-01-11 10:00:02 | order-service | /api/order/create | 200ms | success
2024-01-11 10:00:03 | order-service | /api/order/create | 180ms | error

OAP聚合计算：
时间窗口：每分钟
服务：order-service
接口：/api/order/create

计算结果：
├─ 总请求数：3
├─ 成功数：2
├─ 失败数：1
├─ 成功率：66.7%
├─ 平均响应时间：176.7ms
├─ P99响应时间：200ms
└─ 错误率：33.3%
```

**🔸 OAP支持的指标类型**

```
性能指标（Metrics）：
- CPM（Calls Per Minute）每分钟调用次数
- 响应时间（Response Time）
- 成功率（Success Rate）
- SLA（Service Level Agreement）服务等级

追踪数据（Trace）：
- 完整的调用链路
- 每个Span的详细信息
- 服务间调用关系

日志数据（Log）：
- 业务日志
- 异常堆栈
- 与Trace关联的日志
```

### 3.4 OAP的集群部署

**🏢 生产环境的高可用部署**

```
OAP集群架构：

         负载均衡器
              ↓
    ┌─────────┼─────────┐
    ↓         ↓         ↓
  OAP-1     OAP-2     OAP-3
    ↓         ↓         ↓
    └─────────┼─────────┘
              ↓
         存储集群
    (Elasticsearch Cluster)

集群优势：
✅ 高可用：一个OAP挂了不影响整体
✅ 负载均衡：多个OAP分担压力
✅ 水平扩展：流量大时增加OAP节点

配置示例：
# OAP配置集群模式
cluster:
  selector: ${SW_CLUSTER:nacos}  # 使用Nacos做集群协调
  nacos:
    serverAddr: ${SW_CLUSTER_NACOS_HOST:127.0.0.1:8848}
```

---

## 4. 💾 Storage存储层设计


### 4.1 存储层的作用

🎯 **为什么需要存储层**

```
存储层就像"档案馆"：
- 保存所有历史监控数据
- 支持快速检索查询
- 提供数据持久化能力

存储的数据类型：
📊 指标数据：服务性能、调用量等数值型数据
🔗 追踪数据：完整的调用链路、Span信息
📝 日志数据：应用日志、异常堆栈
🗺️ 拓扑数据：服务间依赖关系图
```

### 4.2 支持的存储类型

**🔧 SkyWalking支持的存储方案**

| 存储类型 | **适用场景** | **优势** | **劣势** |
|---------|------------|---------|---------|
| 🔸 **H2** | `开发测试环境` | `无需安装，开箱即用` | `内存数据库，重启丢失` |
| 🔸 **Elasticsearch** | `生产环境（推荐）` | `查询快，扩展性好` | `需要额外部署ES集群` |
| 🔸 **MySQL** | `小规模生产环境` | `运维简单，成本低` | `大数据量性能差` |
| 🔸 **TiDB** | `超大规模场景` | `分布式，无限扩展` | `运维复杂度高` |

**💡 存储选型建议**

```
场景1：本地开发测试
推荐：H2数据库
理由：无需安装，启动即用
配置：默认配置即可

场景2：中小型团队生产环境（<100服务）
推荐：Elasticsearch（单机或3节点）
理由：查询性能好，运维成本适中
配置：ES内存8GB+，SSD硬盘

场景3：大型企业生产环境（>100服务）
推荐：Elasticsearch集群（5节点以上）
理由：高可用，查询快，可扩展
配置：每节点16GB+内存，监控ES性能

场景4：超大规模（千级服务，海量数据）
推荐：TiDB或ClickHouse
理由：分布式架构，无限扩展
配置：专业DBA维护
```

### 4.3 存储的数据结构

**📋 数据在存储层的组织方式**

```
Elasticsearch存储示例：

索引1：服务指标（Metrics）
{
  "service_name": "order-service",
  "timestamp": "2024-01-11T10:00:00",
  "cpm": 1000,              // 每分钟调用次数
  "response_time": 150,      // 平均响应时间
  "success_rate": 99.5,      // 成功率
  "error_count": 5           // 错误数
}

索引2：调用链（Trace）
{
  "trace_id": "abc123",
  "spans": [
    {
      "span_id": "001",
      "service": "gateway",
      "operation": "/api/order",
      "start_time": 1704960000000,
      "end_time": 1704960000150
    },
    {
      "span_id": "002", 
      "parent_span_id": "001",
      "service": "order-service",
      "operation": "/order/create",
      "start_time": 1704960000020,
      "end_time": 1704960000130
    }
  ]
}
```

### 4.4 数据保留策略

**🗑️ 如何管理历史数据**

```
数据生命周期管理：

热数据（7天内）：
- 存储：全量数据
- 用途：实时监控、问题诊断
- 性能要求：查询速度快

温数据（7-30天）：
- 存储：聚合数据 + 部分Trace
- 用途：趋势分析、容量规划
- 性能要求：查询可接受

冷数据（30天以上）：
- 存储：仅保留关键指标
- 用途：历史回顾、合规审计
- 性能要求：归档存储

数据清理配置：
# OAP配置TTL（Time To Live）
storage:
  elasticsearch:
    dayStep: 1  # 每天一个索引
    indexShardsNumber: 1
    indexReplicasNumber: 0
    
core:
  default:
    # 指标数据保留7天
    metricsDataTTL: 7
    # Trace数据保留3天  
    traceDataTTL: 3
```

---

## 5. 🎨 UI控制台介绍


### 5.1 UI控制台的作用

💡 **可视化界面的价值**

```
UI控制台就像"驾驶舱仪表盘"：
- 实时显示系统健康状态
- 可视化展示服务调用关系
- 提供问题诊断工具
- 支持数据查询和分析

核心功能模块：
📊 仪表盘（Dashboard）：总览系统状态
🗺️ 拓扑图（Topology）：服务依赖关系
🔗 追踪（Trace）：调用链路详情
📈 指标（Metrics）：性能数据图表
⚠️ 告警（Alarm）：异常通知
```

### 5.2 拓扑图功能

**🗺️ 服务依赖关系可视化**

```
拓扑图展示的信息：

      [Gateway]
          ↓
    [Order Service] ← 200ms平均响应
          ↓
     ┌────┼────┐
     ↓    ↓    ↓
  [User] [Product] [Payment]
   50ms   30ms      100ms

节点信息：
- 服务名称
- 健康状态（绿色正常/红色异常）
- 关键指标（CPM、响应时间）

连线信息：
- 调用方向（箭头）
- 调用量大小（线条粗细）
- 响应时间（颜色深浅）

实用场景：
✅ 快速了解系统架构
✅ 发现服务瓶颈（哪个节点红了）
✅ 分析调用路径（从网关到数据库）
✅ 评估服务影响范围（下游有哪些依赖）
```

### 5.3 追踪查询功能

**🔍 如何查找问题调用**

```
Trace查询的使用步骤：

步骤1：设置查询条件
时间范围：最近1小时
服务名称：order-service  
接口名称：/api/order/create
状态：Error（只看报错的）

步骤2：查看调用列表
TraceID        | 耗时   | 状态  | 时间
abc123         | 5000ms | Error | 10:01
def456         | 150ms  | OK    | 10:02

步骤3：点击进入详情
查看完整调用链：
Gateway         [10:01:00 - 10:01:05] 5000ms
  └─ OrderService [10:01:00 - 10:01:05] 4950ms
      └─ MySQL     [10:01:01 - 10:01:05] 4900ms ← 慢查询

步骤4：分析问题原因
发现：MySQL查询耗时4.9秒
结论：数据库慢查询导致接口超时
```

### 5.4 仪表盘定制

**📊 自定义监控大屏**

```
创建自定义仪表盘：

场景：订单服务专属监控

模块1：服务概览
- 总调用量：实时CPM曲线图
- 成功率：百分比展示
- 平均响应时间：折线图

模块2：核心接口监控
- /api/order/create 响应时间
- /api/order/query 调用量
- /api/order/cancel 错误率

模块3：依赖服务健康度
- MySQL连接数
- Redis命中率  
- 消息队列堆积量

模块4：告警信息
- 最近告警列表
- 待处理问题数量
```

---

## 6. 🔄 数据流转完整过程


### 6.1 端到端数据流转

**📋 从应用到UI的完整旅程**

```
完整的数据流转链路：

步骤1：应用执行业务逻辑
用户访问：http://api.com/order/create
↓

步骤2：Agent拦截并记录
创建Span记录：
- TraceId: abc123
- 开始时间: 10:00:00
- 操作: /order/create
↓

步骤3：Agent上报数据
通过gRPC发送到OAP服务器
数据格式：Protobuf二进制
↓

步骤4：OAP接收处理
Receiver接收数据
→ 解析验证格式
→ 流式分析处理
→ 聚合计算指标
↓

步骤5：存储到数据库
写入Elasticsearch：
- metrics索引（指标）
- trace索引（链路）
↓

步骤6：UI查询展示
用户打开UI控制台
→ UI发送GraphQL查询
→ OAP从ES检索数据
→ 返回给前端展示
```

### 6.2 实时性保证

**⚡ 如何做到近实时监控**

```
时间延迟分析：

Agent → OAP：< 1秒
- gRPC长连接，低延迟传输
- 批量发送，减少网络开销

OAP → Storage：< 2秒
- 异步写入，不阻塞处理
- 批量写入ES，提高吞吐

Storage → UI：< 1秒
- ES查询响应快
- UI定时刷新（默认5秒）

总延迟：3-5秒内可见
满足实时监控需求
```

### 6.3 数据流量控制

**🚦 如何处理高并发场景**

```
流量控制机制：

Agent端控制：
采样策略：3秒内最多采样N条
防止海量请求压垮OAP

OAP端控制：
背压机制：处理不过来时通知Agent降速
队列缓冲：异步处理，削峰填谷

Storage端控制：
批量写入：积累一批数据再写入
索引优化：按时间分片，提高写入速度

实际配置示例：
# Agent采样配置
agent.sample_n_per_3_secs=5  # 3秒最多5条

# OAP队列配置  
receiver:
  buffer:
    path: ../buffer/
    bufferSize: 100000  # 队列大小10万
```

---

## 7. 🏗️ 架构分层设计


### 7.1 SkyWalking的四层架构

**📐 清晰的职责分层**

```
架构分层示意图：

┌─────────────────────────────────┐
│   第1层：数据采集层（Agent）      │
│   职责：无侵入采集应用数据        │
└─────────────────────────────────┘
              ↓ gRPC
┌─────────────────────────────────┐
│   第2层：数据分析层（OAP）        │
│   职责：聚合计算、流式处理        │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│   第3层：数据存储层（Storage）    │
│   职责：持久化存储、快速检索      │
└─────────────────────────────────┘
              ↓ GraphQL
┌─────────────────────────────────┐
│   第4层：展示层（UI）             │
│   职责：可视化展示、交互查询      │
└─────────────────────────────────┘

分层的好处：
✅ 职责清晰，易于维护
✅ 组件可替换（如换存储）
✅ 可独立扩展（如OAP集群）
✅ 故障隔离（一层挂了不影响其他）
```

### 7.2 各层技术选型

**🔧 每层使用的核心技术**

```
第1层：Agent（数据采集）
核心技术：
- Java Agent字节码增强
- gRPC通信协议
- 插件化架构（支持扩展）

主要插件：
- Web框架：Spring MVC, SpringBoot
- RPC框架：Dubbo, gRPC, Feign
- 数据库：MySQL, MongoDB, Redis
- 消息队列：Kafka, RabbitMQ

第2层：OAP（数据处理）
核心技术：
- 流式计算（实时分析）
- 时间窗口聚合
- GraphQL查询引擎
- 集群协调（Nacos/Zookeeper）

第3层：Storage（数据存储）
核心技术：
- Elasticsearch（推荐）
- MySQL、TiDB、ClickHouse
- 索引优化、分片策略

第4层：UI（可视化）
核心技术：
- Vue.js前端框架
- GraphQL数据查询
- ECharts图表库
- WebSocket实时推送
```

### 7.3 插件化扩展机制

**🔌 如何扩展支持新框架**

```
插件开发的便利性：

官方已支持插件（100+）：
- Web: Tomcat, Jetty, Undertow
- RPC: Dubbo, gRPC, Thrift
- 数据库: JDBC, MyBatis, Hibernate
- MQ: Kafka, RocketMQ, RabbitMQ
- 缓存: Redis, Memcached

自定义插件开发：
1. 继承AbstractClassEnhancePluginDefine
2. 定义拦截点（方法、注解）
3. 实现拦截逻辑（前置、后置）
4. 打包放入plugins目录

示例：监控自研RPC框架
只需实现拦截器，无需修改OAP代码
```

---

## 8. 🎯 组件职责划分


### 8.1 Agent的核心职责

**🕵️ Agent负责什么**

```
职责1：数据采集
✅ 拦截应用的关键操作
✅ 记录方法调用、参数、返回值
✅ 捕获异常信息

职责2：上下文传播
✅ 生成TraceId和SpanId
✅ 跨进程传递追踪上下文
✅ 保证调用链完整性

职责3：性能优化
✅ 异步上报，不阻塞业务
✅ 采样控制，降低开销
✅ 批量发送，减少网络请求

不负责的事：
❌ 不存储数据（内存缓冲后上报）
❌ 不做复杂计算（只记录原始数据）
❌ 不直接提供查询（数据交给OAP）
```

### 8.2 OAP的核心职责

**🖥️ OAP负责什么**

```
职责1：数据接收与验证
✅ 接收Agent上报的Trace数据
✅ 验证数据格式和完整性
✅ 处理数据解析错误

职责2：实时分析与聚合
✅ 流式处理每条Trace
✅ 计算服务指标（CPM、响应时间）
✅ 聚合多维度数据（按服务、接口、时间）

职责3：告警检测
✅ 基于规则引擎判断异常
✅ 触发告警通知（邮件、钉钉）
✅ 记录告警历史

职责4：数据查询服务
✅ 提供GraphQL查询接口
✅ 从存储层检索数据
✅ 数据转换和格式化

职责5：集群管理
✅ 节点注册与发现
✅ 负载均衡
✅ 故障转移
```

### 8.3 Storage的核心职责

**💾 Storage负责什么**

```
职责1：数据持久化
✅ 接收OAP写入的数据
✅ 建立索引加速查询
✅ 数据压缩节省空间

职责2：高效查询
✅ 支持复杂查询条件
✅ 毫秒级响应时间
✅ 聚合计算能力

职责3：数据管理
✅ 按时间分片存储
✅ 自动清理过期数据
✅ 数据备份与恢复

选型考虑：
- 小数据量：MySQL（简单）
- 中等规模：ES单机（平衡）
- 大规模：ES集群（性能）
- 超大规模：TiDB（扩展）
```

### 8.4 UI的核心职责

**🎨 UI负责什么**

```
职责1：数据可视化
✅ 图表展示（折线图、饼图）
✅ 拓扑图渲染
✅ 调用链可视化

职责2：交互查询
✅ 多维度数据筛选
✅ 时间范围选择
✅ 条件组合查询

职责3：问题诊断
✅ Trace详情展示
✅ 性能瓶颈分析
✅ 错误定位辅助

职责4：用户体验
✅ 响应式设计（适配不同屏幕）
✅ 实时数据刷新
✅ 快捷操作支持

不负责的事：
❌ 不存储数据（只展示）
❌ 不做数据处理（调用OAP接口）
❌ 不直接连存储（通过OAP查询）
```

---

## 9. 🔁 数据处理流程


### 9.1 Trace数据处理流程

**🔗 调用链数据的完整处理**

```
调用链处理的7个步骤：

步骤1：Agent生成Trace
用户请求 → Gateway
TraceId: abc123 创建
SpanId: 001 创建

步骤2：跨服务传播
Gateway → Order Service
TraceId: abc123 传递
SpanId: 002 创建（父SpanId: 001）

步骤3：Agent上报Span
异步发送到OAP
gRPC批量传输

步骤4：OAP接收解析
Receiver接收Span
解析二进制数据
验证TraceId合法性

步骤5：Span聚合
按TraceId关联Span
构建完整调用链树
计算调用时长

步骤6：存储Trace
写入ES trace索引
按天分片存储

步骤7：UI查询展示
用户搜索TraceId
OAP查询ES
返回调用链树结构
```

### 9.2 Metrics指标处理流程

**📊 性能指标的计算过程**

```
指标计算的实时处理：

输入：原始Span数据
{
  "service": "order-service",
  "endpoint": "/api/order/create", 
  "duration": 150,
  "status": "success",
  "timestamp": 1704960000000
}

处理1：提取关键信息
服务名：order-service
接口名：/api/order/create
耗时：150ms
状态：成功

处理2：时间窗口聚合（1分钟）
10:00-10:01这一分钟内：
- 总请求数：100次
- 成功数：95次  
- 失败数：5次
- 总耗时：15000ms

处理3：计算指标
CPM = 100（每分钟100次调用）
成功率 = 95/100 = 95%
平均响应时间 = 15000/100 = 150ms
P99 = 计算第99百分位数 = 280ms

处理4：存储指标
写入ES metrics索引
{
  "service": "order-service",
  "endpoint": "/api/order/create",
  "timestamp": "2024-01-11T10:00:00",
  "cpm": 100,
  "success_rate": 95,
  "avg_duration": 150,
  "p99": 280
}
```

### 9.3 拓扑图生成流程

**🗺️ 服务关系图的构建**

```
拓扑图生成的3个阶段：

阶段1：关系提取
从Span中提取：
- 调用方服务：gateway
- 被调用方服务：order-service
- 调用关系：gateway → order-service

阶段2：关系聚合
统计调用关系：
gateway → order-service (100次/分钟)
order-service → user-service (50次/分钟)
order-service → product-service (80次/分钟)

阶段3：拓扑渲染
节点：服务列表
边：调用关系
属性：调用量、响应时间、错误率

最终展示：
    [gateway]
        ↓ 100 CPM
  [order-service]
    ↓          ↓
   50 CPM    80 CPM
 [user]    [product]
```

### 9.4 告警处理流程

**⚠️ 异常检测与通知**

```
告警的触发流程：

步骤1：定义告警规则
规则：服务响应时间>1000ms
服务：order-service
检查周期：每1分钟

步骤2：实时检测
OAP每分钟检查指标
order-service响应时间：1200ms
触发条件：1200 > 1000

步骤3：告警触发
生成告警事件：
{
  "rule": "响应时间过高",
  "service": "order-service",
  "value": 1200,
  "threshold": 1000,
  "time": "2024-01-11 10:05"
}

步骤4：告警通知
发送到钉钉/邮件/短信
内容：
"告警：order-service响应时间1200ms，超过阈值1000ms"

步骤5：告警记录
存储告警历史
在UI上显示
支持告警查询和统计
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 SkyWalking四大组件：Agent、OAP、Storage、UI
🔸 Agent职责：无侵入采集数据，自动生成Trace
🔸 OAP职责：数据分析聚合，提供查询接口
🔸 Storage职责：持久化存储，支持高效检索
🔸 UI职责：可视化展示，交互式查询诊断
🔸 数据流转：Agent → OAP → Storage → UI
🔸 架构分层：采集层、分析层、存储层、展示层
🔸 核心数据：Trace（链路）、Metrics（指标）、Topology（拓扑）
```

### 10.2 关键理解要点


**🔹 Agent的工作原理**
```
字节码增强技术：
- 应用启动时自动注入监控代码
- 拦截关键方法调用
- 不修改业务代码（零侵入）

数据采集策略：
- 采样控制防止性能影响
- 异步上报不阻塞业务
- 批量发送提高效率
```

**🔹 OAP的核心能力**
```
实时流式处理：
- 接收Agent持续上报的数据
- 流式计算性能指标
- 秒级延迟的实时监控

聚合计算能力：
- 时间窗口聚合（分钟级）
- 多维度聚合（服务、接口）
- 百分位计算（P99、P95）
```

**🔹 存储层的选型策略**
```
开发测试环境：
H2数据库 → 零配置，快速启动

中小型生产环境：
Elasticsearch → 查询快，运维简单

大型生产环境：
ES集群 → 高可用，可扩展

超大规模场景：
TiDB/ClickHouse → 海量数据，分布式
```

### 10.3 实际应用价值


**🎯 解决的实际问题**
- **性能问题定位**：通过Trace快速找到慢接口
- **故障根因分析**：调用链清晰展示错误传播路径
- **容量规划**：基于监控数据评估服务压力
- **服务治理**：拓扑图识别不合理的服务依赖

**🔧 最佳实践建议**
- **Agent部署**：使用环境变量配置，便于容器化
- **采样策略**：生产环境建议3秒5条，降低性能影响
- **存储规划**：Trace保留3天，Metrics保留7天
- **告警配置**：设置合理阈值，避免告警风暴

**📈 学习路径建议**
```
第1步：本地环境搭建
- 使用H2存储快速体验
- 部署示例应用测试

第2步：理解核心概念
- TraceId/SpanId的作用
- 调用链的构建原理

第3步：生产环境部署
- ES集群搭建
- OAP高可用配置
- Agent批量部署

第4步：深入使用
- 自定义告警规则
- 性能调优
- 插件开发
```

**核心记忆口诀**：
- Agent探针前线采集，无侵入自动记录
- OAP中枢实时分析，聚合计算生成指标  
- Storage仓库持久存储，快速检索历史数据
- UI大屏可视展示，拓扑追踪一目了然