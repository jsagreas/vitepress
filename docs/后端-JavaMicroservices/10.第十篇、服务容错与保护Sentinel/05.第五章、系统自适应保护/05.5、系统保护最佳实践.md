---
title: 5、系统保护最佳实践
---
## 📚 目录

1. [系统保护核心概念](#1-系统保护核心概念)
2. [系统自适应阈值详解](#2-系统自适应阈值详解)
3. [服务分级保护策略](#3-服务分级保护策略)
4. [系统保护与熔断协作](#4-系统保护与熔断协作)
5. [限流触发机制](#5-限流触发机制)
6. [全局系统保护实战](#6-全局系统保护实战)
7. [最佳实践与总结](#7-最佳实践与总结)

---

## 1. 🛡️ 系统保护核心概念


### 1.1 什么是系统保护


> 📖 **核心理解**  
> 系统保护就像给你的应用安装一个"智能保险丝"，当系统快要撑不住时，自动切断部分请求，保护核心功能不崩溃。

**生活类比：**
```
想象一个餐厅：
正常情况：顾客有序就餐 ✅
高峰期：厨房开始忙不过来 ⚠️
系统保护：暂停接待新顾客，先服务已入座的 🛡️

目的：防止厨房崩溃，保证已有顾客的体验
```

### 1.2 为什么需要系统保护


**传统限流的局限性：**

| 保护方式 | 作用范围 | 局限性 | 适用场景 |
|---------|---------|--------|---------|
| **接口限流** | `单个API` | 无法感知系统整体负载 | API级别保护 |
| **服务降级** | `单个服务` | 不考虑系统资源状况 | 业务级保护 |
| **系统保护** | `全局系统` | 根据真实负载动态调整 | 系统级保护 |

**核心优势：**
```
🎯 自适应调节：根据系统真实负载自动调整
📊 全局视角：不只看某个接口，看整体健康度
⚡ 快速响应：毫秒级检测，秒级生效
🔄 智能恢复：负载降低后自动恢复正常
```

### 1.3 系统保护的工作原理


**基本流程：**
```
请求到达
   ↓
系统指标检测
   ↓
是否超过阈值？
   ↓
是 → 拒绝请求（快速失败）
否 → 正常处理
```

**监控的核心指标：**
```
🔸 CPU使用率：系统计算资源是否充足
🔸 系统负载：操作系统整体压力
🔸 平均响应时间：系统处理速度
🔸 入口QPS：系统并发请求量
🔸 线程数：系统并发处理能力
```

---

## 2. 📊 系统自适应阈值详解


### 2.1 自适应阈值的核心思想


> 💡 **通俗理解**  
> 不是你手动设置"CPU超过80%就限流"这种死规则，而是让系统自己学习：在什么情况下开始吃力，然后自动调整保护阈值。

**对比说明：**
```
❌ 固定阈值方式：
规则：CPU > 80% → 限流
问题：不同时段系统承受能力不同
- 白天高峰：80%可能已经很吃力
- 夜间低谷：80%还很轻松

✅ 自适应阈值方式：
规则：系统根据历史数据动态计算阈值
- 高峰期：降低阈值，提前保护
- 低谷期：提高阈值，充分利用资源
```

### 2.2 自适应算法工作机制


**BBR算法（Bottleneck Bandwidth and RTT）：**
```
核心思路：找到系统的"甜蜜点"
         ↓
系统最佳工作点 = 最大吞吐量 × 最小延迟
         ↓
超过这个点 → 性能下降 → 开始限流
```

**计算过程示意：**
```
步骤1：持续监控系统指标
┌─────────────────────────┐
│ CPU: 45%  RT: 50ms      │
│ QPS: 1000  Thread: 200  │
└─────────────────────────┘

步骤2：计算系统容量
最大QPS = 1000 (当前)
最小RT = 50ms
系统容量 = 1000 × (1000ms / 50ms) = 20000

步骤3：动态调整阈值
当前QPS接近20000 → 触发保护
```

### 2.3 自适应阈值配置


**基础配置：**
```java
// 启用系统自适应保护
SystemRule rule = new SystemRule();
rule.setHighestSystemLoad(10.0);    // 系统负载阈值
rule.setAvgRt(50);                  // 平均响应时间(ms)
rule.setMaxThread(200);             // 最大并发线程数
rule.setQps(1000);                  // 入口QPS阈值

SystemRuleManager.loadRules(Collections.singletonList(rule));
```

**配置说明：**
```
🔸 highestSystemLoad（系统负载）
   含义：系统Load1值（1分钟平均负载）
   建议：设为CPU核心数 × 0.7
   示例：8核CPU → 设置为5.6

🔸 avgRt（平均响应时间）
   含义：所有请求的平均耗时
   建议：根据业务SLA设定
   示例：要求100ms响应 → 设置50ms预警

🔸 maxThread（最大线程数）
   含义：系统最大并发处理线程
   建议：根据容器配置设定
   示例：Tomcat 200线程 → 设置150

🔸 qps（入口QPS）
   含义：系统整体每秒请求量
   建议：压测获取极限值的70%
   示例：极限2000QPS → 设置1400
```

### 2.4 阈值触发示例


**实际运行场景：**
```
场景1：CPU突然飙高
正常状态：CPU 40%, QPS 800
突发情况：CPU 85%, QPS 800
系统判断：CPU超标 → 触发保护 → 拒绝新请求
保护效果：CPU回落到60%, QPS降到500

场景2：响应时间变慢
正常状态：RT 30ms, QPS 1000
异常状态：RT 80ms, QPS 1000
系统判断：RT超标 → 触发保护 → 限制并发
保护效果：RT降到40ms, QPS降到600

场景3：负载持续上升
时刻1：Load 3.0 → 正常
时刻2：Load 6.0 → 开始预警
时刻3：Load 8.0 → 触发保护
时刻4：Load 5.0 → 自动恢复
```

---

## 3. 🎯 服务分级保护策略


### 3.1 为什么要分级保护


> 🔍 **核心问题**  
> 当系统资源不足时，不是所有服务都同等重要。核心服务必须保证，次要服务可以牺牲。

**服务重要性分级：**
```
🔥 核心服务（必保）
   - 登录认证
   - 订单支付
   - 核心数据读取
   保护策略：最高优先级，最后才限流

⭐ 重要服务（优先保）
   - 商品浏览
   - 购物车操作
   - 用户中心
   保护策略：中等优先级，适度限流

💫 普通服务（可降级）
   - 推荐系统
   - 评论功能
   - 统计分析
   保护策略：低优先级，优先牺牲
```

### 3.2 分级保护实现方案


**方案1：基于优先级的保护**
```java
// 核心服务配置
@SentinelResource(value = "coreService", 
                  blockHandler = "coreBlockHandler")
public Result coreService() {
    // 核心业务逻辑
}

// 核心服务的保护规则（阈值最高）
SystemRule coreRule = new SystemRule();
coreRule.setQps(1000);           // 允许更高QPS
coreRule.setAvgRt(100);          // 允许更长响应时间
coreRule.setGrade(RuleConstant.DEGRADE_GRADE_RT);

// 普通服务配置
@SentinelResource(value = "normalService",
                  blockHandler = "normalBlockHandler")
public Result normalService() {
    // 普通业务逻辑
}

// 普通服务的保护规则（阈值较低）
SystemRule normalRule = new SystemRule();
normalRule.setQps(500);          // 较低QPS阈值
normalRule.setAvgRt(50);         // 较短响应时间
```

**方案2：动态优先级调整**
```
系统负载等级与服务分级对应关系：

负载等级1（轻度）：Load < 3
策略：所有服务正常运行
┌──────────────────────┐
│ 核心服务 ✅ 100%      │
│ 重要服务 ✅ 100%      │
│ 普通服务 ✅ 100%      │
└──────────────────────┘

负载等级2（中度）：3 ≤ Load < 6
策略：普通服务开始限流
┌──────────────────────┐
│ 核心服务 ✅ 100%      │
│ 重要服务 ✅ 100%      │
│ 普通服务 ⚠️ 50%       │
└──────────────────────┘

负载等级3（重度）：Load ≥ 6
策略：只保核心服务
┌──────────────────────┐
│ 核心服务 ✅ 80%       │
│ 重要服务 ⚠️ 30%       │
│ 普通服务 ❌ 0%        │
└──────────────────────┘
```

### 3.3 服务分级配置实践


**完整配置示例：**
```java
@Configuration
public class SystemProtectionConfig {
    
    @PostConstruct
    public void initSystemRules() {
        List<SystemRule> rules = new ArrayList<>();
        
        // 1. 全局系统保护（兜底）
        SystemRule globalRule = new SystemRule();
        globalRule.setHighestSystemLoad(8.0);
        globalRule.setAvgRt(100);
        rules.add(globalRule);
        
        // 2. 核心服务特殊保护
        FlowRule coreFlow = new FlowRule("coreService");
        coreFlow.setGrade(RuleConstant.FLOW_GRADE_QPS);
        coreFlow.setCount(1000);
        coreFlow.setStrategy(RuleConstant.STRATEGY_DIRECT);
        
        // 3. 普通服务优先降级
        DegradeRule normalDegrade = new DegradeRule("normalService");
        normalDegrade.setGrade(RuleConstant.DEGRADE_GRADE_RT);
        normalDegrade.setCount(50);  // 50ms超时就降级
        normalDegrade.setTimeWindow(10);
        
        SystemRuleManager.loadRules(rules);
    }
}
```

**实际效果演示：**
```
场景：电商大促，系统负载飙升

时刻T1（负载正常）：
请求分布：
├─ 订单支付：200 QPS ✅
├─ 商品浏览：500 QPS ✅  
└─ 推荐系统：300 QPS ✅
系统负载：Load = 4.0

时刻T2（负载上升）：
请求分布：
├─ 订单支付：200 QPS ✅（保持）
├─ 商品浏览：500 QPS ✅（保持）
└─ 推荐系统：150 QPS ⚠️（限流50%）
系统负载：Load = 6.5

时刻T3（负载告警）：
请求分布：
├─ 订单支付：180 QPS ✅（轻微限流）
├─ 商品浏览：200 QPS ⚠️（限流60%）
└─ 推荐系统：0 QPS ❌（完全关闭）
系统负载：Load = 7.8
```

---

## 4. 🔄 系统保护与熔断协作


### 4.1 两种机制的区别


> 💡 **本质区别**  
> - **系统保护**：看整个系统的健康状态（我累不累）
> - **熔断降级**：看单个服务的调用情况（这个接口行不行）

**对比理解：**
```
系统保护：
关注点：系统整体资源（CPU、内存、负载）
触发条件：系统指标超阈值
保护范围：所有入口请求
恢复机制：系统指标正常后自动恢复

熔断降级：
关注点：单个服务健康度（响应时间、错误率）
触发条件：服务异常比例超标
保护范围：特定服务或接口
恢复机制：探测请求成功后逐步恢复
```

### 4.2 协作工作流程


**双重保护机制：**
```
请求处理流程：

请求到达
   ↓
[第一关] 系统保护检查
   ↓
系统负载是否正常？
   ↓
   是 → 继续
   否 → 拒绝（快速失败）
   ↓
[第二关] 熔断检查
   ↓
目标服务是否熔断？
   ↓
   是 → 降级处理
   否 → 正常调用
   ↓
执行业务逻辑
```

**实际场景演示：**
```
场景：订单服务调用库存服务

状况1：系统正常，服务正常
系统负载：Load = 3.0 ✅
库存服务：RT = 30ms ✅
结果：请求正常处理

状况2：系统正常，服务异常
系统负载：Load = 3.0 ✅
库存服务：RT = 500ms, 错误率30% ❌
熔断触发：库存服务熔断
结果：返回降级数据（缓存库存）

状况3：系统异常，服务正常
系统负载：Load = 8.0 ❌
库存服务：RT = 30ms ✅
系统保护触发：拒绝部分请求
结果：部分请求被拒绝

状况4：系统异常，服务也异常
系统负载：Load = 8.0 ❌
库存服务：已熔断 ❌
双重保护：系统保护 + 服务熔断
结果：快速失败 + 降级响应
```

### 4.3 协作配置实践


**完整保护配置：**
```java
@Service
public class OrderService {
    
    @Autowired
    private StockService stockService;
    
    // 系统保护 + 熔断协作
    @SentinelResource(
        value = "createOrder",
        blockHandler = "systemBlockHandler",  // 系统保护触发
        fallback = "orderFallback"            // 熔断降级触发
    )
    public OrderResult createOrder(OrderDTO order) {
        // 1. 检查库存（可能触发熔断）
        StockResult stock = stockService.checkStock(order.getProductId());
        
        // 2. 创建订单
        return orderRepository.save(order);
    }
    
    // 系统保护兜底方法
    public OrderResult systemBlockHandler(OrderDTO order, BlockException ex) {
        return OrderResult.fail("系统繁忙，请稍后重试");
    }
    
    // 服务熔断降级方法
    public OrderResult orderFallback(OrderDTO order, Throwable ex) {
        return OrderResult.fail("服务暂不可用，请稍后重试");
    }
}

// 配置类
@Configuration
public class ProtectionConfig {
    
    @PostConstruct
    public void init() {
        // 1. 系统级保护规则
        SystemRule systemRule = new SystemRule();
        systemRule.setHighestSystemLoad(6.0);
        systemRule.setAvgRt(100);
        SystemRuleManager.loadRules(Collections.singletonList(systemRule));
        
        // 2. 服务级熔断规则
        DegradeRule degradeRule = new DegradeRule("stockService");
        degradeRule.setGrade(RuleConstant.DEGRADE_GRADE_RT);
        degradeRule.setCount(200);           // 响应时间超200ms
        degradeRule.setTimeWindow(30);       // 熔断30秒
        degradeRule.setMinRequestAmount(10); // 最少10个请求
        degradeRule.setSlowRatioThreshold(0.5); // 慢调用比例50%
        DegradeRuleManager.loadRules(Collections.singletonList(degradeRule));
    }
}
```

---

## 5. ⚡ 限流触发机制


### 5.1 触发时机详解


> 📖 **核心理解**  
> 限流不是随机触发的，而是在检测到系统"危险信号"时精确触发，像汽车的ABS防抱死系统。

**触发条件判断：**
```
多指标综合判断模型：

检测周期：每秒检测一次
判断逻辑：任一指标超标即触发

指标1：CPU使用率
当前值 > 阈值 → 触发
示例：85% > 80% ✓ 触发

指标2：系统负载
当前值 > 阈值 → 触发  
示例：Load 7.5 > 6.0 ✓ 触发

指标3：平均响应时间
当前值 > 阈值 → 触发
示例：RT 150ms > 100ms ✓ 触发

指标4：并发线程数
当前值 > 阈值 → 触发
示例：Thread 250 > 200 ✓ 触发

指标5：入口QPS
当前值 > 阈值 → 触发
示例：QPS 1500 > 1000 ✓ 触发
```

### 5.2 触发后的处理流程


**完整处理链路：**
```
步骤1：检测到触发条件
系统指标：Load = 8.0 (阈值6.0)
   ↓
步骤2：激活限流策略
策略：拒绝新请求
   ↓
步骤3：请求快速失败
响应：BlockException
HTTP状态码：429 Too Many Requests
   ↓
步骤4：持续监控
每秒检查：Load是否降低
   ↓
步骤5：自动恢复
条件：Load < 6.0 持续3秒
结果：恢复正常服务
```

**实际触发示例：**
```java
@RestController
public class ApiController {
    
    @GetMapping("/api/products")
    @SentinelResource(value = "products", 
                      blockHandler = "handleBlock")
    public Result getProducts() {
        // 业务逻辑
        return Result.success(productService.list());
    }
    
    // 限流触发时的处理
    public Result handleBlock(BlockException ex) {
        // 判断触发原因
        if (ex instanceof SystemBlockException) {
            // 系统保护触发
            return Result.fail(429, "系统繁忙，请稍后重试");
        } else if (ex instanceof FlowException) {
            // 流量限流触发  
            return Result.fail(429, "访问过于频繁，请稍后重试");
        } else {
            // 其他限流触发
            return Result.fail(429, "服务限流中");
        }
    }
}
```

### 5.3 触发频率控制


**防抖动机制：**
```
问题：系统指标在阈值附近波动
Load: 5.9 → 6.1 → 5.8 → 6.2 → 5.9
     ↑      ↑      ↑      ↑
  不触发  触发?  恢复?  触发?

解决：引入稳定窗口
策略：连续N秒超标才触发
     连续M秒正常才恢复

实际效果：
时刻1：Load 6.1 (超标1秒) → 继续观察
时刻2：Load 6.3 (超标2秒) → 继续观察  
时刻3：Load 6.2 (超标3秒) → 触发保护 ✓
...
时刻10：Load 5.8 (正常1秒) → 继续观察
时刻11：Load 5.7 (正常2秒) → 继续观察
时刻12：Load 5.6 (正常3秒) → 解除保护 ✓
```

**配置示例：**
```java
@Configuration
public class SystemProtectionConfig {
    
    @Bean
    public SystemRuleManager systemRuleManager() {
        // 配置触发策略
        SystemRule rule = new SystemRule();
        rule.setHighestSystemLoad(6.0);
        
        // 触发条件：连续3秒超标
        rule.setStableWindowSize(3);
        
        // 恢复条件：连续5秒正常
        rule.setRecoveryWindowSize(5);
        
        SystemRuleManager.loadRules(Collections.singletonList(rule));
        return SystemRuleManager;
    }
}
```

---

## 6. 🌍 全局系统保护实战


### 6.1 全局保护架构设计


**整体架构图：**
```
                    ┌─────────────────┐
                    │   Nginx/网关     │
                    └────────┬────────┘
                             ↓
                    ┌─────────────────┐
                    │  全局系统保护    │
                    │  (Sentinel)     │
                    └────────┬────────┘
                             ↓
            ┌────────────────┼────────────────┐
            ↓                ↓                ↓
    ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
    │  订单服务     │ │  用户服务     │ │  商品服务     │
    │  (本地保护)   │ │  (本地保护)   │ │  (本地保护)   │
    └──────────────┘ └──────────────┘ └──────────────┘
```

**保护层级：**
```
🔸 第一层：网关层全局保护
   作用：粗粒度流量控制
   策略：基于系统总体负载
   
🔸 第二层：服务层系统保护
   作用：细粒度资源保护
   策略：基于单服务资源使用
   
🔸 第三层：接口层精确保护
   作用：业务级流量控制
   策略：基于接口重要性分级
```

### 6.2 全局保护配置实现


**网关层配置：**
```java
@Configuration
public class GatewaySystemProtection {
    
    @PostConstruct
    public void initGatewayRules() {
        // 全局系统保护规则
        SystemRule globalRule = new SystemRule();
        globalRule.setHighestSystemLoad(10.0);  // 集群总负载
        globalRule.setAvgRt(200);               // 全局平均响应时间
        globalRule.setQps(5000);                // 网关总QPS
        
        SystemRuleManager.loadRules(
            Collections.singletonList(globalRule)
        );
    }
    
    // 自定义拦截器
    @Component
    public class SystemProtectionFilter implements GlobalFilter {
        
        @Override
        public Mono<Void> filter(ServerWebExchange exchange, 
                                 GatewayFilterChain chain) {
            try {
                // 系统保护检查
                Entry entry = SphU.entry("gateway-entry");
                try {
                    return chain.filter(exchange);
                } finally {
                    entry.exit();
                }
            } catch (BlockException e) {
                // 触发系统保护
                exchange.getResponse().setStatusCode(
                    HttpStatus.TOO_MANY_REQUESTS
                );
                return exchange.getResponse().setComplete();
            }
        }
    }
}
```

**服务层配置：**
```java
@Configuration
public class ServiceSystemProtection {
    
    @PostConstruct  
    public void initServiceRules() {
        List<SystemRule> rules = new ArrayList<>();
        
        // 1. CPU保护
        SystemRule cpuRule = new SystemRule();
        cpuRule.setHighestCpuUsage(0.8);  // CPU使用率80%
        rules.add(cpuRule);
        
        // 2. 负载保护
        SystemRule loadRule = new SystemRule();
        loadRule.setHighestSystemLoad(
            Runtime.getRuntime().availableProcessors() * 0.7
        );
        rules.add(loadRule);
        
        // 3. 响应时间保护
        SystemRule rtRule = new SystemRule();
        rtRule.setAvgRt(100);  // 平均100ms
        rules.add(rtRule);
        
        // 4. 并发线程保护
        SystemRule threadRule = new SystemRule();
        threadRule.setMaxThread(200);  // 最多200线程
        rules.add(threadRule);
        
        SystemRuleManager.loadRules(rules);
    }
}
```

### 6.3 全局保护监控与调优


**监控指标面板：**
```
系统保护监控大盘
┌─────────────────────────────────────┐
│ 实时状态：✅ 正常                    │
│ 当前负载：5.2 / 8.0                 │
│ CPU使用：65% / 80%                  │
│ 平均RT：45ms / 100ms                │
│ 并发线程：150 / 200                 │
│ 入口QPS：800 / 1000                 │
├─────────────────────────────────────┤
│ 保护事件                             │
│ 14:30:15 系统负载超标 触发保护       │
│ 14:30:45 负载恢复正常 解除保护       │
│ 14:35:20 CPU使用率高 触发保护        │
└─────────────────────────────────────┘
```

**调优建议：**
```
📊 性能调优步骤：

步骤1：压测获取基准数据
- 正常QPS：1000
- 极限QPS：2000  
- 平均RT：50ms
- 最大RT：200ms

步骤2：设置保守阈值（基准×0.7）
- QPS阈值：1400
- RT阈值：70ms
- Load阈值：CPU核心数×0.7

步骤3：生产环境观察
- 监控触发频率
- 分析误触发场景
- 收集业务反馈

步骤4：动态调整优化
- 触发频繁 → 提高阈值
- 保护不及时 → 降低阈值
- 误杀请求 → 细化规则
```

---

## 7. 📋 最佳实践与总结


### 7.1 系统保护最佳实践


**🎯 核心原则：**
```
1️⃣ 分层保护原则
   网关 → 服务 → 接口，层层防护

2️⃣ 自适应优先原则  
   优先使用自适应阈值，减少人工配置

3️⃣ 业务分级原则
   核心业务最后保护，次要业务优先牺牲

4️⃣ 快速失败原则
   触发保护立即拒绝，避免资源浪费

5️⃣ 监控告警原则
   实时监控，异常及时告警
```

**📝 配置检查清单：**
```
✅ 系统保护配置检查

□ 是否设置了合理的系统负载阈值
□ 是否配置了平均响应时间阈值
□ 是否设置了最大并发线程数
□ 是否配置了入口QPS限制
□ 是否实现了BlockHandler处理
□ 是否配置了监控告警
□ 是否进行了压测验证
□ 是否制定了应急预案
```

### 7.2 常见问题与解决方案


**问题1：系统保护频繁触发**
```
现象：系统负载正常，但频繁触发保护
原因分析：
  ❌ 阈值设置过低
  ❌ 监控指标不准确
  ❌ 系统资源配置不足

解决方案：
  ✅ 通过压测重新确定阈值
  ✅ 检查监控指标采集准确性
  ✅ 评估是否需要扩容
```

**问题2：保护不及时**
```
现象：系统已经很卡，但保护未触发
原因分析：
  ❌ 阈值设置过高
  ❌ 检测周期过长
  ❌ 触发条件设置不当

解决方案：
  ✅ 降低触发阈值
  ✅ 缩短检测周期（不低于1秒）
  ✅ 调整触发条件（单指标→多指标）
```

**问题3：恢复速度慢**
```
现象：系统负载降低，但保护持续很久
原因分析：
  ❌ 恢复窗口设置过长
  ❌ 未配置自动恢复机制

解决方案：
  ✅ 调整恢复窗口时间
  ✅ 启用自适应恢复
  ✅ 配置探测请求机制
```

### 7.3 核心要点总结


**🔸 系统保护vs其他保护机制：**
```
系统保护：全局视角，保护系统整体
熔断降级：服务视角，保护单个服务
流量控制：接口视角，保护具体API

三者配合：
  系统保护（第一道防线）
    ↓
  服务熔断（第二道防线）
    ↓  
  接口限流（第三道防线）
```

**🔸 自适应阈值的价值：**
```
✅ 自动学习系统容量
✅ 动态调整保护策略
✅ 减少人工配置成本
✅ 适应业务波动变化
```

**🔸 分级保护的意义：**
```
🔥 核心业务：最大限度保障
⭐ 重要业务：尽可能保障
💫 普通业务：可降级牺牲

目标：有限资源优先保障核心价值
```

**🔸 全局保护的关键：**
```
1. 多层次防护体系
2. 统一监控告警
3. 快速故障恢复
4. 持续优化调整
```

### 7.4 实战记忆口诀


> 🧠 **记忆口诀**  
> 系统保护看全局，自适应阈值智能调  
> 分级保护有优先，核心服务最后倒  
> 限流触发快速判，恢复机制不能少  
> 监控告警要及时，优化调整效果好

**核心配置模板：**
```java
// 标准系统保护配置
SystemRule rule = new SystemRule();
rule.setHighestSystemLoad(CPU核心数 × 0.7);
rule.setAvgRt(业务SLA × 0.5);
rule.setMaxThread(容器线程数 × 0.75);
rule.setQps(压测极限QPS × 0.7);

// 记住这个公式
保护阈值 = 极限值 × 70%（留30%安全余量）
```

---

## 📚 延伸学习


**🔗 相关主题：**
- 限流算法原理（令牌桶、漏桶）
- 熔断降级策略详解
- 微服务容错设计模式
- 系统性能调优实战

**💡 思考题：**
1. 为什么系统保护要使用自适应阈值而不是固定阈值？
2. 在分级保护中，如何判断一个服务的优先级？
3. 系统保护和熔断降级如何配合才能达到最佳效果？
4. 如何避免系统保护的"误杀"问题？