---
title: 4、自定义Slot扩展
---
## 📚 目录

1. [Slot机制基础理解](#1-slot机制基础理解)
2. [SlotChain责任链模式](#2-slotchain责任链模式)
3. [自定义Slot开发实战](#3-自定义slot开发实战)
4. [Slot扩展应用场景](#4-slot扩展应用场景)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🎯 Slot机制基础理解


### 1.1 什么是Slot


**通俗理解**：把Slot想象成一条"安检流水线"

```
机场安检流程：                    Sentinel的Slot流程：
旅客进入 → 身份检查 → 行李检查 → 安检门 → 放行     请求进入 → 统计Slot → 流控Slot → 降级Slot → 系统Slot → 放行
   ↓         ↓         ↓        ↓      ↓              ↓          ↓         ↓         ↓          ↓       ↓
 起点     第1关     第2关    第3关   终点          起点       第1关      第2关      第3关      第4关    终点

特点：每个关卡独立负责一项检查，按顺序执行
```

**🔸 核心定义**
- **Slot是什么**：Sentinel中的一个处理单元，负责特定的保护功能
- **做什么用**：对请求进行检查、统计、限流、降级等操作
- **工作方式**：多个Slot串联成链，依次处理每个请求

### 1.2 为什么需要Slot机制


**🤔 问题场景**
```
如果没有Slot机制：
所有逻辑写在一起 → 代码混乱难维护 → 功能耦合严重 → 扩展困难

有了Slot机制：
每个Slot独立负责 → 职责清晰 → 易于维护 → 方便扩展
```

**💡 核心优势**
- **职责分离**：每个Slot只做一件事，代码更清晰
- **灵活组合**：可以自由调整Slot的顺序和组合
- **易于扩展**：需要新功能时，只需添加新的Slot
- **便于测试**：每个Slot可以独立测试

### 1.3 Sentinel内置Slot介绍


**📦 内置Slot清单**

| Slot名称 | **作用说明** | **生活类比** |
|---------|------------|------------|
| `NodeSelectorSlot` | 构建调用链路树 | 记录你走过的路径 |
| `ClusterBuilderSlot` | 构建集群统计节点 | 统计全局访问数据 |
| `StatisticSlot` | 统计实时数据 | 计数器，记录访问量 |
| `FlowSlot` | 流量控制检查 | 限流闸门，控制通行 |
| `DegradeSlot` | 熔断降级检查 | 保险丝，异常时断开 |
| `SystemSlot` | 系统保护检查 | 系统监控，防止过载 |
| `AuthoritySlot` | 黑白名单检查 | 门禁系统，验证身份 |

**🔄 执行顺序示意**
```
请求进入
    ↓
NodeSelectorSlot (构建调用链路)
    ↓
ClusterBuilderSlot (构建集群节点)
    ↓
StatisticSlot (统计数据)
    ↓
FlowSlot (流控检查) ← 可能被限流阻断
    ↓
DegradeSlot (降级检查) ← 可能被熔断阻断
    ↓
SystemSlot (系统检查) ← 可能被系统保护阻断
    ↓
AuthoritySlot (权限检查) ← 可能被黑名单阻断
    ↓
请求通过，执行业务逻辑
```

---

## 2. ⚙️ SlotChain责任链模式


### 2.1 责任链模式理解


**🔗 什么是责任链**

```
生活中的责任链 - 请假审批：
员工提交 → 组长审批 → 经理审批 → 总监审批 → HR备案
   ↓         ↓         ↓         ↓        ↓
  起点     第1关     第2关     第3关    终点

特点：
1. 每个节点只负责自己的审批
2. 按顺序传递到下一个节点
3. 任何节点都可以中断流程
```

**💡 在Sentinel中的应用**
- **每个Slot**：就是责任链中的一个节点
- **SlotChain**：把所有Slot串联起来的链条
- **请求处理**：沿着链条依次经过每个Slot

### 2.2 SlotChain工作机制


**🔄 处理流程**

```
请求到来
    ↓
进入SlotChain
    ↓
┌─────────────────────────┐
│  Slot1.entry()         │ ← 第1个Slot检查
│  ↓                      │
│  Slot2.entry()         │ ← 第2个Slot检查  
│  ↓                      │
│  Slot3.entry()         │ ← 第3个Slot检查
│  ↓                      │
│  ...                    │
│  ↓                      │
│  业务逻辑执行            │ ← 所有Slot通过后
│  ↓                      │
│  Slot3.exit()          │ ← 退出时倒序执行
│  ↓                      │
│  Slot2.exit()          │
│  ↓                      │
│  Slot1.exit()          │
└─────────────────────────┘
    ↓
请求结束
```

**⚠️ 中断机制**
```
如果某个Slot检查不通过：

正常流程：
Slot1(✓) → Slot2(✓) → Slot3(✓) → 业务执行

中断流程：
Slot1(✓) → Slot2(✗) → 抛出异常，直接退出
                ↓
          不再执行后续Slot
          不执行业务逻辑
```

### 2.3 ProcessorSlot接口


**🔸 核心接口定义**

```java
// ProcessorSlot是所有Slot的基础接口
public interface ProcessorSlot<T> {
    
    // 入口方法：请求进入时调用
    void entry(Context context, ResourceWrapper resourceWrapper, 
               T param, int count, boolean prioritized, Object... args) 
               throws Throwable;
    
    // 退出方法：请求退出时调用  
    void exit(Context context, ResourceWrapper resourceWrapper, 
              int count, Object... args);
}
```

**📖 参数说明**

| 参数 | **含义** | **类比理解** |
|------|---------|------------|
| `context` | 当前调用上下文 | 请求的身份证，包含来源等信息 |
| `resourceWrapper` | 被保护的资源 | 被检查的对象，比如某个接口 |
| `param` | 参数对象 | 具体的业务参数 |
| `count` | 请求数量 | 这次请求占用多少配额 |
| `prioritized` | 是否优先通过 | 是否是VIP请求 |

**🎯 关键方法作用**
```
entry()方法：
作用：在请求进入时执行检查逻辑
职责：
  1. 进行各种检查（流控、降级等）
  2. 统计数据
  3. 决定是否放行
  4. 不通过则抛出异常

exit()方法：
作用：在请求退出时执行清理逻辑
职责：
  1. 更新统计数据
  2. 清理资源
  3. 记录日志
```

---

## 3. 🛠️ 自定义Slot开发实战


### 3.1 开发自定义Slot的步骤


**📋 开发流程**
```
步骤1：继承ProcessorSlot接口
    ↓
步骤2：实现entry()和exit()方法
    ↓
步骤3：编写具体的处理逻辑
    ↓
步骤4：注册到SlotChain中
    ↓
步骤5：测试验证
```

### 3.2 实战案例：IP黑名单Slot


**🎯 需求场景**
```
业务需求：阻止特定IP访问系统
实现方式：自定义一个IP检查Slot

检查逻辑：
请求到来 → 获取IP → 检查是否在黑名单 → 决定是否放行
```

**💻 代码实现**

```java
// 1. 定义IP黑名单Slot
public class IpBlackListSlot extends AbstractLinkedProcessorSlot<DefaultNode> {
    
    // 黑名单集合（实际应该从配置中心获取）
    private Set<String> blackList = new HashSet<>();
    
    public IpBlackListSlot() {
        // 初始化黑名单
        blackList.add("192.168.1.100");
        blackList.add("192.168.1.101");
    }
    
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, 
                      DefaultNode node, int count, boolean prioritized, 
                      Object... args) throws Throwable {
        
        // 获取当前请求的IP
        String clientIp = getClientIp();
        
        // 检查是否在黑名单中
        if (blackList.contains(clientIp)) {
            // 在黑名单中，抛出异常阻断请求
            throw new BlockException("IP在黑名单中: " + clientIp);
        }
        
        // 不在黑名单，继续执行下一个Slot
        fireEntry(context, resourceWrapper, node, count, prioritized, args);
    }
    
    @Override
    public void exit(Context context, ResourceWrapper resourceWrapper, 
                     int count, Object... args) {
        // 退出时的清理逻辑
        fireExit(context, resourceWrapper, count, args);
    }
    
    // 获取客户端IP（简化版）
    private String getClientIp() {
        // 实际应该从Request中获取
        return "192.168.1.50"; // 示例
    }
}
```

**🔑 关键代码解析**
```
1. 继承AbstractLinkedProcessorSlot：
   这个抽象类已经实现了责任链的逻辑
   我们只需要实现具体的检查逻辑

2. fireEntry()方法：
   作用：将请求传递给下一个Slot
   相当于："我检查完了，交给下一关"

3. fireExit()方法：
   作用：退出时传递给上一个Slot
   相当于："我处理完了，返回上一关"

4. 抛出BlockException：
   作用：阻断请求，不再执行后续逻辑
   相当于："检查不通过，停止"
```

### 3.3 注册自定义Slot


**📝 注册方式一：使用SlotChainBuilder**

```java
// 方式1：通过SlotChainBuilder注册
public class CustomSlotChainBuilder implements SlotChainBuilder {
    
    @Override
    public ProcessorSlotChain build() {
        // 创建Slot链
        ProcessorSlotChain chain = new DefaultProcessorSlotChain();
        
        // 按顺序添加Slot
        chain.addLast(new NodeSelectorSlot());     // 节点选择
        chain.addLast(new ClusterBuilderSlot());   // 集群统计
        chain.addLast(new StatisticSlot());        // 数据统计
        
        // 添加自定义Slot（在流控之前检查）
        chain.addLast(new IpBlackListSlot());      // IP黑名单检查
        
        chain.addLast(new FlowSlot());             // 流量控制
        chain.addLast(new DegradeSlot());          // 熔断降级
        
        return chain;
    }
}
```

**📝 注册方式二：SPI机制**

```java
// 1. 在resources目录下创建文件：
// META-INF/services/com.alibaba.csp.sentinel.slotchain.SlotChainBuilder

// 2. 文件内容写入自定义Builder的全类名：
com.example.sentinel.CustomSlotChainBuilder
```

**🎯 注册位置选择**
```
IP黑名单Slot应该放在哪？

建议位置：在统计Slot之后，流控Slot之前

原因分析：
✓ 在统计之后：黑名单IP的请求也会被统计（便于分析）
✓ 在流控之前：先检查黑名单，避免浪费流控资源
✓ 顺序合理：先身份验证，再业务检查

调整建议：
实际业务可根据需要调整位置
关键是理解每个Slot的职责
```

### 3.4 实战案例：接口调用计费Slot


**🎯 业务场景**
```
场景：API接口按调用次数收费
需求：每次调用成功后记录计费信息

实现思路：
1. entry()：检查账户余额
2. exit()：扣费并记录
```

**💻 代码实现**

```java
public class BillingSlot extends AbstractLinkedProcessorSlot<DefaultNode> {
    
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, 
                      DefaultNode node, int count, boolean prioritized, 
                      Object... args) throws Throwable {
        
        // 获取用户ID（从context中获取）
        String userId = context.getOrigin();
        
        // 检查账户余额
        if (!hasEnoughBalance(userId)) {
            throw new BlockException("账户余额不足");
        }
        
        // 继续执行下一个Slot
        fireEntry(context, resourceWrapper, node, count, prioritized, args);
    }
    
    @Override
    public void exit(Context context, ResourceWrapper resourceWrapper, 
                     int count, Object... args) {
        
        // 只有请求成功才扣费
        String userId = context.getOrigin();
        String resource = resourceWrapper.getName();
        
        // 记录计费信息
        recordBilling(userId, resource, count);
        
        // 继续执行
        fireExit(context, resourceWrapper, count, args);
    }
    
    private boolean hasEnoughBalance(String userId) {
        // 检查余额逻辑
        return true;
    }
    
    private void recordBilling(String userId, String resource, int count) {
        // 记录计费：userId调用了resource接口count次
        System.out.println("计费记录：用户" + userId + 
                         "调用" + resource + " " + count + "次");
    }
}
```

**📊 执行流程**
```
请求流程：
用户调用API
    ↓
entry()检查余额
    ↓ (余额充足)
执行其他Slot检查
    ↓
执行业务逻辑
    ↓ (成功返回)
exit()记录计费
    ↓
返回结果给用户

异常流程：
用户调用API
    ↓
entry()检查余额
    ↓ (余额不足)
抛出BlockException
    ↓
直接返回错误
(不执行业务，不计费)
```

---

## 4. 🚀 Slot扩展应用场景


### 4.1 常见扩展场景


**📋 实用场景清单**

| 场景 | **Slot功能** | **实现要点** |
|------|------------|------------|
| **IP限制** | IP黑白名单检查 | entry()中检查IP是否合法 |
| **签名验证** | API签名校验 | entry()中验证请求签名 |
| **计费统计** | 调用次数计费 | exit()中记录计费信息 |
| **日志审计** | 操作日志记录 | entry()和exit()都记录 |
| **权限控制** | 用户权限检查 | entry()中检查用户权限 |
| **参数校验** | 业务参数验证 | entry()中校验参数合法性 |

### 4.2 场景一：敏感词过滤


**🎯 需求说明**
```
场景：评论系统需要过滤敏感词
要求：包含敏感词的请求直接拒绝
```

**💻 实现思路**

```java
public class SensitiveWordSlot extends AbstractLinkedProcessorSlot<DefaultNode> {
    
    // 敏感词库
    private Set<String> sensitiveWords = new HashSet<>(
        Arrays.asList("敏感词1", "敏感词2", "敏感词3")
    );
    
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, 
                      DefaultNode node, int count, boolean prioritized, 
                      Object... args) throws Throwable {
        
        // 获取请求内容（从args中取）
        if (args != null && args.length > 0) {
            String content = String.valueOf(args[0]);
            
            // 检查是否包含敏感词
            for (String word : sensitiveWords) {
                if (content.contains(word)) {
                    throw new BlockException("内容包含敏感词：" + word);
                }
            }
        }
        
        // 检查通过，继续
        fireEntry(context, resourceWrapper, node, count, prioritized, args);
    }
    
    @Override
    public void exit(Context context, ResourceWrapper resourceWrapper, 
                     int count, Object... args) {
        fireExit(context, resourceWrapper, count, args);
    }
}
```

**🔍 使用示例**
```java
@Service
public class CommentService {
    
    @SentinelResource(value = "addComment")
    public void addComment(String content) {
        // 业务逻辑：保存评论
        // Slot会自动检查content是否包含敏感词
        System.out.println("评论已保存：" + content);
    }
}
```

### 4.3 场景二：调用链路追踪


**🎯 需求说明**
```
场景：记录完整的调用链路用于问题排查
要求：记录每个请求的来源和调用路径
```

**💻 实现思路**

```java
public class TraceSlot extends AbstractLinkedProcessorSlot<DefaultNode> {
    
    @Override
    public void entry(Context context, ResourceWrapper resourceWrapper, 
                      DefaultNode node, int count, boolean prioritized, 
                      Object... args) throws Throwable {
        
        // 生成追踪ID
        String traceId = generateTraceId();
        
        // 记录开始信息
        System.out.println("[" + traceId + "] 开始调用: " + 
                         resourceWrapper.getName() + 
                         ", 来源: " + context.getOrigin());
        
        // 将traceId放入context
        context.getCurEntry().setAttachment("traceId", traceId);
        
        // 继续执行
        fireEntry(context, resourceWrapper, node, count, prioritized, args);
    }
    
    @Override
    public void exit(Context context, ResourceWrapper resourceWrapper, 
                     int count, Object... args) {
        
        // 获取traceId
        String traceId = (String) context.getCurEntry()
                                         .getAttachment("traceId");
        
        // 记录结束信息
        System.out.println("[" + traceId + "] 结束调用: " + 
                         resourceWrapper.getName());
        
        fireExit(context, resourceWrapper, count, args);
    }
    
    private String generateTraceId() {
        return "TRACE-" + System.currentTimeMillis() + 
               "-" + Thread.currentThread().getId();
    }
}
```

**📊 输出示例**
```
[TRACE-1632456789000-123] 开始调用: /api/order/create, 来源: mobile-app
[TRACE-1632456789000-123] 开始调用: /api/inventory/check, 来源: order-service
[TRACE-1632456789000-123] 结束调用: /api/inventory/check
[TRACE-1632456789000-123] 结束调用: /api/order/create
```

### 4.4 扩展开发最佳实践


**✅ 开发建议**

```
1. 单一职责原则
   - 每个Slot只做一件事
   - 避免在Slot中写复杂业务逻辑
   - 保持代码简洁清晰

2. 性能优化
   - entry()方法要快速执行
   - 避免阻塞操作（如数据库查询）
   - 使用缓存提高检查速度

3. 异常处理
   - 只抛出BlockException或其子类
   - 提供清晰的错误信息
   - 记录必要的日志

4. 位置选择
   - 根据功能选择合适位置
   - 考虑性能影响
   - 理解Slot之间的依赖关系

5. 测试验证
   - 编写单元测试
   - 测试正常和异常场景
   - 验证不影响其他Slot
```

**⚠️ 常见陷阱**

```
陷阱1：在entry()中执行耗时操作
❌ 错误：entry()中查询数据库
✅ 正确：使用缓存或异步处理

陷阱2：忘记调用fire方法
❌ 错误：检查通过后直接return
✅ 正确：必须调用fireEntry()传递给下一个Slot

陷阱3：exit()中抛出异常
❌ 错误：exit()中抛异常影响其他Slot
✅ 正确：exit()中捕获异常并记录日志

陷阱4：Slot顺序错误
❌ 错误：统计Slot放在最后
✅ 正确：统计Slot应该在检查Slot之前
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 Slot机制：责任链模式，每个Slot负责特定功能
🔸 SlotChain：Slot串联成的处理链条
🔸 ProcessorSlot：所有Slot的基础接口
🔸 entry()方法：请求进入时的检查逻辑
🔸 exit()方法：请求退出时的清理逻辑
🔸 自定义扩展：继承接口实现自己的Slot
```

### 5.2 关键理解要点


**🔹 Slot的本质**
```
Slot就像流水线上的工位：
- 每个工位负责一道工序
- 按顺序依次处理
- 任何工位都可以让产品下线（阻断请求）
- 处理完成后原路返回
```

**🔹 责任链的价值**
```
为什么用责任链：
1. 解耦：每个Slot独立，互不干扰
2. 灵活：可以自由组合和调整顺序
3. 扩展：添加新功能只需加新Slot
4. 维护：问题定位更容易
```

**🔹 自定义Slot的场景**
```
什么时候需要自定义：
✓ 内置Slot无法满足需求
✓ 需要特殊的业务检查
✓ 需要自定义统计逻辑
✓ 需要集成其他系统

不需要自定义的情况：
✗ 内置功能已经够用
✗ 简单的业务逻辑（用其他方式更好）
✗ 一次性的临时需求
```

### 5.3 实战应用指南


**🎯 开发流程**
```
1. 明确需求：要实现什么功能
2. 选择位置：在哪个Slot之前/之后
3. 设计逻辑：entry()和exit()做什么
4. 编写代码：继承接口实现方法
5. 注册Slot：加入SlotChain
6. 测试验证：确保功能正确
```

**🔧 调试技巧**
```
问题定位：
1. 打印日志：在entry()和exit()中打印
2. 查看顺序：确认Slot执行顺序
3. 异常排查：检查是否正确抛出异常
4. 性能分析：测量每个Slot的耗时
```

**核心记忆**：
- Slot是检查站，请求要过关
- 责任链模式，顺序很关键
- 自定义扩展，满足特殊需求
- entry检查，exit清理
- 合理位置，高效实现