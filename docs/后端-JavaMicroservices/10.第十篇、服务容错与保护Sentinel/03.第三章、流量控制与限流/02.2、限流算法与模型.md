---
title: 2、限流算法与模型
---
## 📚 目录

1. [流量控制基础概念](#1-流量控制基础概念)
2. [限流算法原理详解](#2-限流算法原理详解)
3. [算法对比与选择](#3-算法对比与选择)
4. [Sentinel中的应用](#4-Sentinel中的应用)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🚦 流量控制基础概念


### 1.1 什么是流量控制


**通俗理解：**
想象一下高速公路收费站，如果不控制车流量，所有车一窝蜂涌入，必然造成拥堵甚至瘫痪。流量控制就像是收费站的管理员，控制放行车辆的速度，保证道路畅通。

**专业定义：**
```
流量控制（Flow Control）：
控制进入系统的请求速率，防止系统因请求过载而崩溃
目标：保护系统稳定性，提供可预测的服务质量
```

**为什么需要流量控制？**
- 🔸 **防止系统过载** - 请求超过处理能力会导致崩溃
- 🔸 **保证服务质量** - 确保核心业务正常运行
- 🔸 **节约资源成本** - 避免无意义的资源消耗
- 🔸 **应对突发流量** - 处理秒杀、热点事件等场景

### 1.2 限流的本质


**核心思想：**
```
限流 = 在单位时间内，只允许固定数量的请求通过

就像水龙头：
- 不限流：水龙头全开，水漫金山
- 限流：控制水流速度，细水长流
```

**限流与其他保护机制的关系：**
```
系统保护体系：

┌─────────────────────────────────┐
│         用户请求                 │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      限流（Flow Control）        │  ← 控制入口流量
│   "我一次只能接待100个人"         │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      熔断（Circuit Breaker）     │  ← 保护下游服务
│   "下游挂了，我暂时不调用了"       │
└─────────────────────────────────┘
              ↓
┌─────────────────────────────────┐
│      降级（Degradation）         │  ← 保证核心功能
│   "非核心功能先关闭"              │
└─────────────────────────────────┘
```

---

## 2. ⚙️ 限流算法原理详解


### 2.1 计数器算法（固定窗口）


**原理说明：**

最简单直接的限流方式，就像用计数器记录人数一样。

**工作机制：**
```
设定规则：1秒内最多100个请求

时间轴：
00:00:00 ─────────────→ 00:00:01
         [计数器: 0→100]
         ↓
         到达100后，后续请求全部拒绝
         ↓
         00:00:01 时刻，计数器清零，重新计数
```

**图解示例：**
```
第1秒窗口（00:00:00 - 00:00:01）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
请求: ✓✓✓✓✓...✓✓✓✓✓ (100个)
      ✗✗✗ (超出，拒绝)
计数: 0 → 100 → 清零

第2秒窗口（00:00:01 - 00:00:02）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
请求: ✓✓✓✓✓...
计数: 0 → ...
```

**代码示例：**
```java
// 固定窗口计数器实现
public class FixedWindowRateLimiter {
    private long windowStart;      // 窗口起始时间
    private int counter;           // 当前计数
    private final int maxRequests; // 最大请求数
    private final long windowSize; // 窗口大小(毫秒)
    
    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // 窗口过期，重置计数器
        if (now - windowStart >= windowSize) {
            windowStart = now;
            counter = 0;
        }
        
        // 判断是否超限
        if (counter < maxRequests) {
            counter++;
            return true;  // 允许通过
        }
        return false;     // 拒绝
    }
}
```

**优缺点分析：**

✅ **优点：**
- 实现简单，内存占用小
- 性能高，判断快速

❌ **缺点：**
- 存在临界问题（窗口边界突发流量）

**临界问题详解：**
```
问题场景：
限制：100请求/秒

00:00:00.5秒时来了100个请求  ✓ (通过)
00:00:01.0秒窗口重置
00:00:01.0秒时又来了100个请求 ✓ (通过)

结果：0.5秒内通过了200个请求！
实际超出限制2倍！

时间轴示意：
00:00:00        00:00:01        00:00:02
    |              |              |
    └─ 100个 ──┘└─ 100个 ──┘
       (0.5秒内200个请求！)
```

### 2.2 滑动窗口算法


**原理说明：**

滑动窗口是对固定窗口的改进，把时间窗口分成更小的格子，窗口随时间滑动。

**工作机制：**
```
将1秒分成10个格子，每个格子100ms：

时间: 0ms   100ms  200ms  300ms ... 1000ms
格子: [1]    [2]    [3]    [4]  ... [10]
计数: 10     15     20     25   ...  5

滑动窗口计算：
当前时间600ms，统计过去1秒的请求：
= 格子[7]+[8]+[9]+[10]+[1]+[2]+[3]+[4]+[5]+[6]
```

**图解示例：**
```
滑动过程：

初始窗口（0-1000ms）
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│10│15│20│25│30│10│15│20│15│10│ = 170
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
 ↑                             ↑
开始                          结束

滑动100ms后（100-1100ms）
   ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
   │15│20│25│30│10│15│20│15│10│5 │ = 165
   └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
    ↑                             ↑
   开始                          结束
```

**代码示例：**
```java
// 滑动窗口实现
public class SlidingWindowRateLimiter {
    private final int[] buckets;    // 时间格子数组
    private final int bucketCount;  // 格子数量
    private final long bucketSize;  // 每格时长
    private final int maxRequests;  // 最大请求数
    
    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        int currentBucket = (int)((now / bucketSize) % bucketCount);
        
        // 清理过期格子
        cleanExpiredBuckets(now);
        
        // 统计窗口内总请求数
        int total = Arrays.stream(buckets).sum();
        
        if (total < maxRequests) {
            buckets[currentBucket]++;
            return true;
        }
        return false;
    }
}
```

**优势体现：**
- 更平滑的限流效果
- 解决了固定窗口的临界问题
- 精度可调（格子数量越多越精确）

### 2.3 漏桶算法（Leaky Bucket）


**原理说明：**

想象一个底部有洞的水桶，水（请求）从上面倒入，从下面固定速率流出。

**核心特点：**
```
漏桶特性：
- 水流入速度：不限制（请求随时可来）
- 水流出速度：恒定（固定速率处理）
- 桶满了：溢出（拒绝请求）

作用：把不规则的流量，整形为恒定速率的流量
```

**图解示例：**
```
漏桶模型：

请求涌入（速率不定）
    ↓ ↓ ↓↓↓ ↓ ↓↓
  ╔═══════════╗
  ║  漏桶容量  ║  ← 队列缓存请求
  ║ ▓▓▓▓▓▓▓  ║
  ║ ▓▓▓▓▓▓▓  ║
  ╚═════╤═════╝
        ↓
   固定速率处理
   (如: 100个/秒)

桶满情况：
  ╔═══════════╗
  ║ ▓▓▓▓▓▓▓▓ ║ ← 已满
  ║ ▓▓▓▓▓▓▓▓ ║
  ╚═════╤═════╝
    ✗ 溢出拒绝
```

**工作流程：**
```
步骤1: 请求到达
       ↓
步骤2: 检查桶是否有空间
       ↓
有空间 → 放入桶中 → 等待处理
       ↓
无空间 → 直接拒绝

步骤3: 后台以固定速率从桶中取出请求处理
```

**代码示例：**
```java
// 漏桶实现
public class LeakyBucketRateLimiter {
    private final Queue<Request> bucket;  // 桶（队列）
    private final int capacity;           // 桶容量
    private final int leakRate;           // 漏出速率/秒
    
    public boolean tryAcquire(Request request) {
        // 检查桶是否满了
        if (bucket.size() >= capacity) {
            return false;  // 桶满，拒绝
        }
        
        // 放入桶中
        bucket.offer(request);
        return true;
    }
    
    // 后台线程：固定速率处理请求
    private void leak() {
        while (true) {
            if (!bucket.isEmpty()) {
                Request req = bucket.poll();
                processRequest(req);  // 处理请求
            }
            Thread.sleep(1000 / leakRate);  // 控制速率
        }
    }
}
```

**应用场景：**
- 需要平滑输出流量的场景
- 保护后端系统承受能力
- 消息队列、任务调度

### 2.4 令牌桶算法（Token Bucket）


**原理说明：**

系统以恒定速率往桶里放令牌，请求来了必须拿到令牌才能通过。这是目前最常用的限流算法。

**核心机制：**
```
令牌桶运作：
1. 系统定时放令牌到桶里（如：每秒100个）
2. 桶有容量上限（如：最多200个）
3. 请求来了，尝试拿令牌：
   - 有令牌：拿走令牌，通过
   - 无令牌：拒绝请求

关键：令牌生成速率 = 限流速率
```

**图解示例：**
```
令牌桶模型：

系统定时放令牌
    ↓ ↓ ↓ ↓ ↓
  ╔═══════════╗
  ║   令牌桶   ║  容量: 200
  ║ ⭐⭐⭐⭐⭐ ║  当前: 150个令牌
  ║ ⭐⭐⭐    ║
  ╚═══════════╝
        ↑
    请求拿令牌
    
请求处理：
请求1: 拿到⭐ → ✓通过
请求2: 拿到⭐ → ✓通过
请求3: 没有⭐ → ✗拒绝
```

**与漏桶的区别：**
```
漏桶 vs 令牌桶：

漏桶：                令牌桶：
请求 → 队列 → 匀速处理   令牌生成 → 桶存储 → 请求获取

特点：                特点：
- 输出速率恒定         - 可应对突发流量
- 平滑流量            - 有令牌就能处理
- 请求可能等待         - 无令牌立即拒绝

场景：                场景：  
- 保护弱后端          - 允许突发的场景
- 需要排队的业务       - 高并发系统
```

**代码示例：**
```java
// 令牌桶实现（简化版）
public class TokenBucketRateLimiter {
    private long tokens;              // 当前令牌数
    private final long capacity;      // 桶容量
    private final long refillRate;    // 补充速率/秒
    private long lastRefillTime;      // 上次补充时间
    
    public synchronized boolean tryAcquire() {
        // 先补充令牌
        refill();
        
        // 尝试获取令牌
        if (tokens > 0) {
            tokens--;
            return true;  // 获取成功
        }
        return false;     // 无令牌，拒绝
    }
    
    private void refill() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastRefillTime;
        
        // 计算应该补充的令牌数
        long tokensToAdd = (elapsed * refillRate) / 1000;
        
        if (tokensToAdd > 0) {
            tokens = Math.min(capacity, tokens + tokensToAdd);
            lastRefillTime = now;
        }
    }
}
```

**突发流量处理：**
```
场景：限流100个/秒，桶容量200

正常情况：
时间0s: 桶中100个令牌
处理: 50个请求 → 剩余50令牌
时间1s: 补充100令牌 → 总计150令牌

突发情况：
时间1s: 突然来了150个请求
处理: 全部通过！（因为桶里有150个令牌）
时间2s: 补充100令牌 → 总计100令牌

说明：令牌桶允许一定程度的突发流量
```

---

## 3. 📊 算法对比与选择


### 3.1 四种算法对比


| 算法 | **优点** | **缺点** | **适用场景** |
|------|---------|---------|-------------|
| **固定窗口** | `实现简单`<br>`性能最高`<br>`内存占用小` | `临界突发问题`<br>`不够平滑` | `对精度要求不高`<br>`简单限流场景` |
| **滑动窗口** | `解决临界问题`<br>`更精确`<br>`可调精度` | `内存占用较大`<br>`实现复杂` | `需要精确控制`<br>`QPS限流` |
| **漏桶** | `流量平滑`<br>`保护后端` | `无法应对突发`<br>`可能增加延迟` | `需要恒定速率`<br>`消息队列` |
| **令牌桶** | `应对突发流量`<br>`灵活性高`<br>`响应快` | `实现较复杂`<br>`需要定时任务` | `高并发系统`<br>`API网关` |

### 3.2 算法特性对比


**流量处理特点：**
```
相同限流：100个/秒

固定窗口：
00:00:00 ━━━━━━━━━━━━━━ 00:00:01
         [最多100个]
         ✗ 临界可能200个

滑动窗口：
━━━━━━━━━━━━━━━━━━━━━━━━→
[持续监控，任意1秒不超100]
✓ 更精确

漏桶：
输入: ↓↓↓↓↓↓↓↓↓↓ (不规则)
输出: → → → → (100个/秒，恒定)
✓ 平滑输出

令牌桶：
令牌: ⭐⭐⭐⭐⭐ (100个/秒)
请求: ✓✓✓✓✓✓ (可突发到桶容量)
✓ 允许突发
```

### 3.3 实际选择建议


**选择决策树：**
```
需要限流？
    ↓
是否需要应对突发流量？
    ↓
是 → 令牌桶（推荐）
    示例：电商秒杀、API网关
    
否 → 是否需要精确控制？
    ↓
    是 → 滑动窗口
        示例：严格QPS限制
        
    否 → 是否需要平滑输出？
        ↓
        是 → 漏桶
            示例：消息队列、任务调度
            
        否 → 固定窗口（最简单）
            示例：简单限流、计数统计
```

**实战建议：**

> 💡 **提示**：实际项目中，**令牌桶算法使用最广泛**

**原因：**
- ✅ 能处理突发流量（用户体验好）
- ✅ 实现成熟（Guava、Sentinel都内置）
- ✅ 性能优秀（适合高并发）
- ✅ 配置灵活（可调节桶容量和速率）

> ⚠️ **注意**：具体选择要结合业务场景，没有绝对的最优算法

---

## 4. 🛡️ Sentinel中的应用


### 4.1 Sentinel的限流策略


Sentinel支持多种限流维度：

**限流维度：**
```
QPS限流：      基于每秒请求数
并发线程限流：  基于并发线程数
关联限流：      关联资源达到阈值时限流
链路限流：      根据调用链路限流
```

**实际配置示例：**
```java
// QPS限流规则
FlowRule rule = new FlowRule();
rule.setResource("getUserInfo");    // 资源名
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);  // QPS模式
rule.setCount(100);                 // 阈值：100/秒
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);

// 加载规则
FlowRuleManager.loadRules(Collections.singletonList(rule));
```

### 4.2 流量控制行为


**三种控制效果：**

| 控制方式 | **说明** | **对应算法** | **使用场景** |
|---------|---------|-------------|------------|
| **直接拒绝** | `超过阈值直接拒绝` | `令牌桶` | `秒杀、抢购` |
| **Warm Up** | `预热/冷启动方式` | `令牌桶变种` | `系统启动、流量激增` |
| **排队等待** | `匀速排队处理` | `漏桶` | `消息处理、脉冲流量` |

**图解说明：**
```
直接拒绝：
请求 → 检查令牌 → 有：✓通过  无：✗拒绝

Warm Up预热：
冷启动: 阈值从 threshold/3 逐渐升至 threshold
0s────→10s (预热期)
33  →  100 (阈值变化)

排队等待：
请求 → 加入队列 → 匀速处理
       (超时则拒绝)
```

### 4.3 实际应用案例


**案例1：秒杀接口保护**
```java
// 秒杀接口：每秒1000个请求，超过直接拒绝
@SentinelResource(value = "seckill", 
    blockHandler = "handleBlock")
public Result seckill(Long productId) {
    // 秒杀业务逻辑
    return Result.success();
}

// 限流后的处理
public Result handleBlock(Long productId, BlockException e) {
    return Result.fail("系统繁忙，请稍后再试");
}

// 规则配置
FlowRule rule = new FlowRule("seckill")
    .setCount(1000)               // 1000/秒
    .setGrade(RuleConstant.FLOW_GRADE_QPS)
    .setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);
```

**案例2：消息处理平滑限流**
```java
// 消息处理：匀速处理，避免脉冲
FlowRule rule = new FlowRule("messageProcess")
    .setCount(100)                // 100/秒
    .setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER)
    .setMaxQueueingTimeMs(500);   // 最多等待500ms
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 流量控制本质：控制系统入口流量，防止过载
🔸 限流目标：保护系统稳定性，提供可预测的服务
🔸 四大算法：固定窗口、滑动窗口、漏桶、令牌桶
🔸 算法选择：根据业务场景，令牌桶最常用
🔸 Sentinel应用：支持多维度限流，配置灵活
```

### 5.2 算法记忆要点


**形象记忆：**
```
固定窗口 = 按时间段计数
"这一秒内最多100个"

滑动窗口 = 移动的计数窗口  
"任意1秒内不超100个"

漏桶 = 水桶匀速漏水
"不管来多少，我匀速处理"

令牌桶 = 定时发放入场券
"有票就能进，没票就等"
```

### 5.3 实战关键点


**配置建议：**
- 限流阈值要基于压测数据，不能拍脑袋
- 突发场景用令牌桶，桶容量设为限流阈值的1.5-2倍
- 核心接口要有降级预案，不能只是拒绝请求
- 监控限流数据，及时调整策略

**常见误区：**

> ❌ **错误认知**：限流就是拒绝请求
> ✅ **正确理解**：限流是保护系统，可以排队、降级、预热

> ❌ **错误认知**：阈值越大越好
> ✅ **正确理解**：阈值要匹配系统真实处理能力

**记忆口诀：**
```
限流保护很重要，算法选择要记牢
固定窗口最简单，临界问题要思考
滑动窗口更精确，内存占用稍大些  
漏桶平滑很稳定，突发流量处理难
令牌桶中最常用，突发流量不用慌
实战场景选算法，业务特点要考量
```