---
title: 4、流控模式详解
---
## 📚 目录

1. [流控模式核心概念](#1-流控模式核心概念)
2. [直接模式](#2-直接模式)
3. [关联模式](#3-关联模式)
4. [链路模式](#4-链路模式)
5. [来源限流](#5-来源限流)
6. [集群流控](#6-集群流控)
7. [模式选择与实战](#7-模式选择与实战)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 流控模式核心概念


### 1.1 什么是流控模式


**通俗理解**：流控模式就是决定"怎么限流"的策略

```
现实场景类比：
┌─────────────────────────────────────┐
│  商场限流的三种方式：               │
│                                      │
│  1. 直接限流：大门口控制总人数       │
│     → 对应Sentinel的"直接模式"      │
│                                      │
│  2. 关联限流：停车场满了就限制入场   │
│     → 对应Sentinel的"关联模式"      │
│                                      │
│  3. 分通道限流：VIP通道和普通通道     │
│     → 对应Sentinel的"链路模式"      │
└─────────────────────────────────────┘
```

### 1.2 流控模式的本质作用


**核心目的**：
- 🛡️ **保护系统**：防止系统过载崩溃
- 📊 **合理分配**：让资源得到合理利用
- 🎯 **精准控制**：针对不同场景采用不同策略

**三种模式对比**：

| 流控模式 | **通俗理解** | **使用场景** | **控制粒度** |
|---------|------------|-------------|------------|
| 🎯 **直接模式** | `直接限制接口访问量` | `最常用，简单直接` | `单个资源` |
| 🔗 **关联模式** | `A接口限流看B接口脸色` | `资源竞争场景` | `资源关联` |
| 🌳 **链路模式** | `不同入口分别限流` | `同资源多入口` | `调用链路` |

---

## 2. 🎯 直接模式


### 2.1 直接模式基本原理


**什么是直接模式**：
最简单直接的限流方式，就像给接口设置一个"访问上限"

```
直接模式工作示意：

请求流程：
客户端 → [检查限流规则] → 接口处理
           ↓
      超过阈值？
       ↓     ↓
      是     否
       ↓     ↓
     拒绝   放行
```

### 2.2 直接模式配置示例


**基础配置**：
```java
// 在Controller中使用
@RestController
public class OrderController {
    
    @GetMapping("/order/create")
    @SentinelResource(value = "orderCreate")
    public String createOrder() {
        return "订单创建成功";
    }
}
```

**流控规则设置**（在Sentinel控制台）：
```
资源名：orderCreate
流控模式：直接
阈值类型：QPS
单机阈值：10
```

**含义解释**：
- `资源名`：要限流的接口标识
- `QPS阈值10`：每秒最多处理10个请求
- `直接模式`：直接对这个接口限流

### 2.3 直接模式的三种阈值类型


#### 🔸 QPS限流（最常用）


**QPS是什么**：Queries Per Second，每秒查询数

```
QPS限流示例：
设置QPS=10

时间轴：
0s ━━━━━━━ 1s ━━━━━━━ 2s
    ↓              ↓
  10个请求      10个请求
   (通过)        (通过)

第11个请求来了 → 拒绝！
```

**配置代码**：
```java
// 代码方式配置QPS限流
List<FlowRule> rules = new ArrayList<>();
FlowRule rule = new FlowRule();
rule.setResource("orderCreate");
rule.setGrade(RuleConstant.FLOW_GRADE_QPS); // QPS模式
rule.setCount(10); // 阈值10
FlowRuleManager.loadRules(rules);
```

#### 🔸 并发线程数限流


**并发线程数是什么**：同时处理的请求数量

```
并发线程限流示意：

处理槽位：[1][2][3][4][5]  ← 设置5个并发
          ↓  ↓  ↓  ↓  ↓
        请求正在处理中...

第6个请求来了 → 所有槽位都满 → 拒绝！
某个请求处理完 → 槽位空出 → 新请求可进入
```

**使用场景**：
- 🔧 **数据库连接**：防止连接池耗尽
- 🔧 **文件操作**：控制同时写文件的数量
- 🔧 **外部调用**：限制同时调用外部API的数量

**配置示例**：
```java
FlowRule rule = new FlowRule();
rule.setResource("queryOrder");
rule.setGrade(RuleConstant.FLOW_GRADE_THREAD); // 线程数模式
rule.setCount(5); // 最多5个并发
```

#### 🔸 QPS vs 并发线程数对比


| 对比维度 | **QPS限流** | **并发线程数限流** |
|---------|------------|------------------|
| **关注点** | `每秒处理多少个请求` | `同时处理多少个请求` |
| **适用场景** | `接口调用频率控制` | `资源占用控制` |
| **计数方式** | `时间窗口内统计` | `实时统计正在处理的` |
| **典型应用** | `防止接口被刷` | `防止资源耗尽` |

### 2.4 直接模式实战案例


**场景：订单接口限流**

```java
@RestController
public class OrderController {
    
    // 创建订单接口 - QPS限流
    @GetMapping("/order/create")
    @SentinelResource(
        value = "createOrder",
        blockHandler = "handleBlock"  // 限流后的处理方法
    )
    public String createOrder(@RequestParam String userId) {
        // 业务逻辑
        return "订单创建成功";
    }
    
    // 限流后的处理方法
    public String handleBlock(String userId, BlockException e) {
        return "系统繁忙，请稍后重试";
    }
}
```

**控制台规则配置**：
```
资源名：createOrder
流控模式：直接
阈值类型：QPS
单机阈值：100
```

**效果说明**：
- ✅ QPS ≤ 100：请求正常处理
- ❌ QPS > 100：触发限流，返回"系统繁忙"

---

## 3. 🔗 关联模式


### 3.1 关联模式原理解析


**什么是关联模式**：A接口的限流规则关联B接口的流量

```
关联模式示意：

场景：写操作影响读操作
┌────────────────────────────────┐
│  写接口(/order/write)          │
│      ↓                         │
│  流量太大，数据库压力大        │
│      ↓                         │
│  限制读接口(/order/query)      │ ← 关联限流
└────────────────────────────────┘

通俗理解：
"写操作太忙了，读操作先等等"
```

**核心思想**：
- 🎯 **资源竞争**：两个接口竞争同一资源（如数据库）
- 🎯 **优先保障**：保障重要接口，牺牲次要接口
- 🎯 **间接限流**：A接口流量大时，限制B接口

### 3.2 关联模式配置方法


**配置示例**：
```java
// 针对读接口配置关联限流规则
FlowRule rule = new FlowRule();
rule.setResource("queryOrder");  // 要被限流的接口
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
rule.setCount(50);
rule.setStrategy(RuleConstant.STRATEGY_RELATE); // 关联模式
rule.setRefResource("writeOrder"); // 关联的接口
```

**配置含义解释**：
```
当 writeOrder接口 的QPS > 50时
    ↓
限制 queryOrder接口 的访问
    ↓
保障写操作的正常进行
```

### 3.3 关联模式实战场景


**场景1：订单写入保护读取**

```java
@RestController
public class OrderController {
    
    // 写订单接口（优先级高）
    @PostMapping("/order/write")
    @SentinelResource("writeOrder")
    public String writeOrder(@RequestBody Order order) {
        // 写入数据库
        return "写入成功";
    }
    
    // 查询订单接口（优先级低）
    @GetMapping("/order/query")
    @SentinelResource(
        value = "queryOrder",
        blockHandler = "queryBlock"
    )
    public String queryOrder(@RequestParam String orderId) {
        // 查询数据库
        return "查询结果";
    }
    
    // 被限流后的处理
    public String queryBlock(String orderId, BlockException e) {
        return "系统繁忙，请稍后查询";
    }
}
```

**规则配置**：
```
资源名：queryOrder
流控模式：关联
关联资源：writeOrder
阈值类型：QPS
单机阈值：100
```

**工作流程**：
```
1. 正常情况：
   writeOrder QPS=50 → queryOrder正常访问

2. 写入高峰：
   writeOrder QPS=150 → queryOrder被限流
   
3. 保障效果：
   数据库压力 → 优先保证写入 → 暂停查询
```

**场景2：支付与退款的关联控制**

```
实际业务场景：
┌─────────────────────────────┐
│  支付接口：/pay/submit      │ ← 核心业务
│       ↓                     │
│  数据库/支付网关 压力大     │
│       ↓                     │
│  退款查询：/refund/query    │ ← 次要业务，被限流
└─────────────────────────────┘

目的：高峰期优先保证支付成功
```

### 3.4 关联模式使用要点


**✅ 适用场景**：
- 资源竞争：两个接口共用数据库、缓存等
- 优先级区分：明确哪个接口更重要
- 削峰填谷：高峰期保护核心业务

**⚠️ 注意事项**：
- 需要明确资源优先级
- 被限流接口要有降级方案
- 监控关联资源的流量变化

---

## 4. 🌳 链路模式


### 4.1 链路模式基本概念


**什么是链路模式**：针对不同的调用入口分别限流

```
链路模式示意图：

         同一个Service方法
              ↓
    ┌─────────────────────┐
    │  OrderService       │
    │  .queryOrder()      │
    └─────────────────────┘
         ↑         ↑
    Controller1  Controller2
    /api/order   /admin/order
         ↓         ↓
    限流规则1    限流规则2
    QPS=100     QPS=10

通俗理解：
同一个方法，从不同入口进来，分别限流
```

**核心思想**：
- 🎯 **调用链路**：根据调用来源区分限流
- 🎯 **精细控制**：同一资源不同入口不同限制
- 🎯 **场景区分**：用户接口和管理接口分开管理

### 4.2 链路模式配置方法


**Step 1：开启链路模式**（application.yml）
```yaml
spring:
  cloud:
    sentinel:
      web-context-unify: false  # 关闭context整合
```

> **为什么要关闭context整合？**
> 默认情况下，所有请求都归为一个root context，无法区分调用链路
> 关闭后，可以根据不同的入口创建不同的context

**Step 2：Service层代码**
```java
@Service
public class OrderService {
    
    @SentinelResource("orderQuery")  // 定义资源
    public String queryOrder(String orderId) {
        return "订单详情";
    }
}
```

**Step 3：多个入口调用**
```java
@RestController
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    // 入口1：用户查询订单
    @GetMapping("/api/order/query")
    public String userQuery(@RequestParam String orderId) {
        return orderService.queryOrder(orderId);
    }
    
    // 入口2：管理员查询订单
    @GetMapping("/admin/order/query")
    public String adminQuery(@RequestParam String orderId) {
        return orderService.queryOrder(orderId);
    }
}
```

**Step 4：配置链路限流规则**
```java
FlowRule rule1 = new FlowRule();
rule1.setResource("orderQuery");
rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);
rule1.setCount(100);
rule1.setStrategy(RuleConstant.STRATEGY_CHAIN); // 链路模式
rule1.setRefResource("/api/order/query"); // 针对用户入口

FlowRule rule2 = new FlowRule();
rule2.setResource("orderQuery");
rule2.setCount(10);
rule2.setStrategy(RuleConstant.STRATEGY_CHAIN);
rule2.setRefResource("/admin/order/query"); // 针对管理入口
```

### 4.3 链路模式实战案例


**场景：区分内外部调用**

```java
@Service
public class ProductService {
    
    @SentinelResource("getProduct")
    public Product getProduct(Long productId) {
        // 查询商品信息
        return productRepository.findById(productId);
    }
}

@RestController
public class ProductController {
    
    @Autowired
    private ProductService productService;
    
    // 外部API：限流严格
    @GetMapping("/api/product/{id}")
    public Product apiGetProduct(@PathVariable Long id) {
        return productService.getProduct(id);
    }
    
    // 内部调用：限流宽松
    @GetMapping("/internal/product/{id}")
    public Product internalGetProduct(@PathVariable Long id) {
        return productService.getProduct(id);
    }
}
```

**流控规则效果**：
```
入口：/api/product/{id}
    ↓
资源：getProduct → QPS限制100

入口：/internal/product/{id}
    ↓
资源：getProduct → QPS限制1000

同一个方法，不同入口，不同限制！
```

### 4.4 链路模式使用要点


**✅ 适用场景**：
- 同一方法多个入口调用
- 内外部接口区分限流
- 不同客户端分别控制

**⚠️ 配置注意**：
- 必须关闭`web-context-unify`
- 资源名要在Service层定义
- 入口路径要精确匹配

---

## 5. 🏷️ 来源限流


### 5.1 来源限流基本原理


**什么是来源限流**：根据调用方身份进行限流

```
来源限流示意：

             订单服务
                ↓
      ┌─────────────────────┐
      │  根据来源限流：      │
      │                      │
      │  App客户端 → 限流100 │
      │  Web客户端 → 限流200 │
      │  内部服务 → 不限流   │
      └─────────────────────┘

通俗理解：
看你是谁，决定给你多少流量配额
```

### 5.2 来源识别配置


**Step 1：实现来源解析器**
```java
@Component
public class RequestOriginParser implements RequestOriginParser {
    
    @Override
    public String parseOrigin(HttpServletRequest request) {
        // 从请求头获取来源标识
        String origin = request.getHeader("origin");
        
        // 根据业务规则识别来源
        if ("app".equals(origin)) {
            return "app-client";
        } else if ("web".equals(origin)) {
            return "web-client";
        } else if ("admin".equals(origin)) {
            return "admin-client";
        }
        
        return "unknown";
    }
}
```

> **来源标识可以从哪里获取？**
> - 请求头（Header）
> - 请求参数
> - Token解析
> - IP地址

**Step 2：配置来源限流规则**
```java
FlowRule rule = new FlowRule();
rule.setResource("orderCreate");
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
rule.setCount(100);
rule.setLimitApp("app-client"); // 只针对app客户端限流
```

### 5.3 来源限流实战案例


**场景：区分用户类型限流**

```java
@Component
public class UserTypeOriginParser implements RequestOriginParser {
    
    @Override
    public String parseOrigin(HttpServletRequest request) {
        String token = request.getHeader("Authorization");
        
        // 解析token获取用户类型
        UserInfo user = parseToken(token);
        
        if (user.isVip()) {
            return "vip-user";
        } else if (user.isPaid()) {
            return "paid-user";
        } else {
            return "free-user";
        }
    }
}
```

**限流规则配置**：
```java
// VIP用户：1000 QPS
FlowRule vipRule = new FlowRule();
vipRule.setResource("queryData");
vipRule.setCount(1000);
vipRule.setLimitApp("vip-user");

// 付费用户：500 QPS
FlowRule paidRule = new FlowRule();
paidRule.setResource("queryData");
paidRule.setCount(500);
paidRule.setLimitApp("paid-user");

// 免费用户：100 QPS
FlowRule freeRule = new FlowRule();
freeRule.setResource("queryData");
freeRule.setCount(100);
freeRule.setLimitApp("free-user");
```

**效果展示**：
```
请求流程：
1. 请求进来 → 解析来源 → 识别为"vip-user"
2. 应用规则 → 使用1000 QPS的限流规则
3. 判断流量 → QPS未超标 → 放行
```

### 5.4 来源限流使用技巧


**✅ 常见应用**：
- **租户隔离**：多租户系统按租户限流
- **用户分级**：VIP/普通用户差异化服务
- **来源控制**：内外部调用分开管理

**⚠️ 注意事项**：
- 来源标识要稳定可靠
- 防止来源伪造（需要认证）
- 默认来源处理策略要明确

---

## 6. 🌐 集群流控


### 6.1 集群流控核心概念


**为什么需要集群流控？**

```
单机限流的问题：

服务集群（3个实例）
┌─────────┐  ┌─────────┐  ┌─────────┐
│实例1    │  │实例2    │  │实例3    │
│QPS=100  │  │QPS=100  │  │QPS=100  │
└─────────┘  └─────────┘  └─────────┘
     ↑            ↑            ↑
  负载均衡分配请求
     ↑
总QPS可能达到300！（3×100）

集群流控的解决：
     ↓
设置总QPS=100，3个实例共享
```

**集群流控工作原理**：
```
Token Server（令牌服务器）
        ↓
  管理总的流量配额
        ↓
   ┌────────────┐
   │ QPS=100    │
   └────────────┘
     ↓    ↓    ↓
  实例1 实例2 实例3
  (请求令牌)
```

### 6.2 集群流控架构模式


#### 模式1：独立Token Server


```
独立部署Token Server：

┌──────────────┐
│ Token Server │ ← 独立服务，管理令牌
└──────────────┘
   ↑    ↑    ↑
   │    │    │
实例1 实例2 实例3 ← 业务服务，请求令牌
```

**优点**：
- 服务独立，稳定性高
- 易于扩展和管理

**缺点**：
- 需要额外部署
- 增加网络开销

#### 模式2：嵌入式Token Server


```
某个实例兼任Token Server：

┌──────────────────┐
│ 实例1            │
│ (Token Server)   │ ← 既是业务服务，又是Token Server
└──────────────────┘
        ↑    ↑
        │    │
     实例2 实例3 ← 其他实例向实例1请求令牌
```

**优点**：
- 部署简单，无需额外服务
- 减少运维成本

**缺点**：
- Token Server故障影响集群限流
- 单点压力较大

### 6.3 集群流控配置实战


**Step 1：引入依赖**
```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-cluster-server-default</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-cluster-client-default</artifactId>
</dependency>
```

**Step 2：Token Server配置**（某个实例作为Server）
```java
@Configuration
public class ClusterConfig {
    
    @PostConstruct
    public void initClusterServer() {
        // 设置为Token Server模式
        ClusterStateManager.applyState(ClusterStateManager.CLUSTER_SERVER);
        
        // 配置集群流控规则
        ClusterFlowRuleManager.loadRules(Collections.singletonList(
            new FlowRule()
                .setResource("orderCreate")
                .setCount(100)  // 集群总QPS=100
                .setClusterMode(true)  // 开启集群模式
        ));
    }
}
```

**Step 3：Token Client配置**（其他实例作为Client）
```java
@Configuration
public class ClusterConfig {
    
    @PostConstruct
    public void initClusterClient() {
        // 设置为Token Client模式
        ClusterStateManager.applyState(ClusterStateManager.CLUSTER_CLIENT);
        
        // 配置Token Server地址
        ClusterClientConfig config = new ClusterClientConfig();
        config.setServerHost("192.168.1.100");  // Token Server IP
        config.setServerPort(8719);
        ClusterClientConfigManager.applyNewConfig(config);
    }
}
```

### 6.4 集群流控应用场景


**场景：秒杀活动限流**

```java
@RestController
public class SeckillController {
    
    @GetMapping("/seckill/buy")
    @SentinelResource(
        value = "seckillBuy",
        blockHandler = "seckillBlock"
    )
    public String buy(@RequestParam Long productId) {
        // 秒杀逻辑
        return "购买成功";
    }
    
    public String seckillBlock(Long productId, BlockException e) {
        return "商品已抢光";
    }
}
```

**集群流控规则**：
```
资源名：seckillBuy
模式：集群流控
总QPS：1000（整个集群）

效果：
5个服务实例 → 共享1000 QPS配额
而不是每个实例1000 QPS
```

### 6.5 集群流控使用要点


**✅ 适用场景**：
- 多实例部署的服务
- 需要精确控制总流量
- 秒杀、抢购等场景

**⚠️ 注意事项**：
- Token Server高可用设计
- 网络延迟影响
- Fallback机制（Server不可用时降级为单机限流）

---

## 7. 🎯 模式选择与实战


### 7.1 流控模式选择指南


**选择流程图**：
```
需要限流 → 选择流控模式
    ↓
问题1：限流目标是什么？
    ↓
单个接口 → 直接模式
    ↓
问题2：是否涉及资源竞争？
    ↓
是 → 关联模式
否 → 继续
    ↓
问题3：同一资源多入口？
    ↓
是 → 链路模式
否 → 继续
    ↓
问题4：是否区分调用来源？
    ↓
是 → 来源限流
否 → 继续
    ↓
问题5：是否多实例部署？
    ↓
是 → 集群流控
否 → 直接模式
```

### 7.2 实战组合案例


**综合案例：电商订单系统**

```java
@RestController
public class OrderController {
    
    // 1. 直接模式：限制创建订单QPS
    @PostMapping("/order/create")
    @SentinelResource(
        value = "createOrder",
        blockHandler = "createBlock"
    )
    public String createOrder(@RequestBody Order order) {
        return "订单创建成功";
    }
    
    // 2. 关联模式：写入时限制查询
    @GetMapping("/order/query")
    @SentinelResource(
        value = "queryOrder",
        blockHandler = "queryBlock"
    )
    public String queryOrder(@RequestParam String orderId) {
        return "订单详情";
    }
    
    // 3. 来源限流：区分用户类型
    @GetMapping("/order/list")
    @SentinelResource("orderList")
    public List<Order> listOrders() {
        return orderService.list();
    }
    
    // 限流处理方法
    public String createBlock(Order order, BlockException e) {
        return "订单创建繁忙，请稍后重试";
    }
    
    public String queryBlock(String orderId, BlockException e) {
        return "查询繁忙，请稍后重试";
    }
}
```

**规则配置策略**：
```
1. createOrder接口：
   - 模式：集群流控
   - 总QPS：1000
   - 原因：多实例部署，精确控制总流量

2. queryOrder接口：
   - 模式：关联模式
   - 关联资源：createOrder
   - 阈值：500
   - 原因：写入高峰时限制查询，保护数据库

3. orderList接口：
   - 模式：来源限流
   - VIP用户：1000 QPS
   - 普通用户：200 QPS
   - 原因：差异化服务
```

### 7.3 常见场景最佳实践


**场景矩阵**：

| 业务场景 | **推荐模式** | **配置要点** | **注意事项** |
|---------|------------|-------------|------------|
| 🔥 **秒杀抢购** | `集群流控` | `精确控制总流量` | `配置Fallback机制` |
| 💾 **数据库保护** | `关联模式` | `写操作限制读操作` | `监控数据库负载` |
| 👥 **用户分级** | `来源限流` | `区分用户等级` | `防止来源伪造` |
| 🔗 **微服务调用** | `链路模式` | `区分调用入口` | `开启链路追踪` |
| 🎯 **普通接口** | `直接模式` | `设置合理QPS` | `结合压测确定阈值` |

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 流控模式：决定"怎么限流"的策略
🔸 直接模式：最常用，直接限制单个资源
🔸 关联模式：A接口流量大时限制B接口
🔸 链路模式：同一资源不同入口分别限流
🔸 来源限流：根据调用方身份限流
🔸 集群流控：多实例共享流量配额
```

### 8.2 关键理解要点


**🔹 模式选择原则**：
```
简单场景 → 直接模式
资源竞争 → 关联模式  
多入口调用 → 链路模式
区分来源 → 来源限流
分布式部署 → 集群流控
```

**🔹 配置注意事项**：
- 直接模式：选择合适的阈值类型（QPS/并发）
- 关联模式：明确资源优先级
- 链路模式：必须关闭context整合
- 来源限流：确保来源标识可靠
- 集群流控：做好高可用设计

**🔹 实战经验总结**：
```
1. 从简单到复杂：优先使用直接模式
2. 结合业务场景：选择最合适的模式
3. 监控和调整：根据实际流量调整阈值
4. 多模式组合：解决复杂限流需求
```

### 8.3 学习检验要点


**自我检测**：
- ✅ 能说清楚5种流控模式的区别吗？
- ✅ 知道什么场景用什么模式吗？
- ✅ 会配置基本的流控规则吗？
- ✅ 理解集群流控的工作原理吗？

**实践建议**：
1. 从直接模式开始练习
2. 在测试环境验证各种模式
3. 结合实际业务选择合适模式
4. 关注限流效果和系统表现

**核心记忆口诀**：
```
直接限流最常用，简单高效好上手
关联模式看资源，竞争场景用得着
链路模式分入口，精细控制有门道
来源限流看身份，差异服务显公平
集群流控管全局，分布部署少不了
```