---
title: 3、流控规则配置
---
## 📚 目录

1. [流控规则核心概念](#1-流控规则核心概念)
2. [FlowRule流控规则对象](#2-FlowRule流控规则对象)
3. [阈值类型详解](#3-阈值类型详解)
4. [流控模式深入理解](#4-流控模式深入理解)
5. [流控效果与表现](#5-流控效果与表现)
6. [规则持久化方案](#6-规则持久化方案)
7. [规则优先级机制](#7-规则优先级机制)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 流控规则核心概念


### 1.1 什么是流量控制


**通俗理解**：就像高速公路的收费站，控制车辆通过的速度，防止拥堵

```
没有流控的情况：
用户请求 ────────────────> 服务器
         (无限制涌入)      (可能崩溃)

有流控的情况：
用户请求 ──→ [限流检查] ──→ 服务器
              ↓ 超出阈值
           拒绝/排队      (稳定运行)
```

**核心作用**：
- 🛡️ **保护服务**：防止流量过大压垮系统
- ⚖️ **削峰填谷**：平滑处理突发流量
- 🎯 **优先保障**：保证核心业务可用

### 1.2 为什么需要流控


**实际场景举例**：

> 💡 **场景1：电商秒杀**
> 
> 平时访问量：每秒100次
> 秒杀时刻：每秒10000次
> 
> 问题：服务器只能处理每秒1000次
> 解决：设置流控规则，超出部分排队或拒绝

> ⚠️ **场景2：恶意攻击**
> 
> 正常用户：每秒1-2次请求
> 攻击者：每秒100+次请求
> 
> 解决：针对IP或用户限流，保护正常业务

---

## 2. 📋 FlowRule流控规则对象


### 2.1 FlowRule是什么


**简单理解**：FlowRule就是一个配置对象，告诉Sentinel"怎么限流"

```java
// 创建一个流控规则（就像填写一张配置表）
FlowRule rule = new FlowRule();
rule.setResource("getUserInfo");  // 对哪个接口限流
rule.setCount(100);                // 限制到多少
rule.setGrade(RuleConstant.FLOW_GRADE_QPS); // 按什么标准限
```

### 2.2 FlowRule核心属性


| 属性名 | 含义 | 通俗解释 | 示例值 |
|--------|------|----------|--------|
| **resource** | 资源名称 | 要保护的接口或方法 | `"getUserInfo"` |
| **count** | 阈值 | 允许通过的数量 | `100` |
| **grade** | 阈值类型 | 按QPS还是线程数限 | `QPS/THREAD` |
| **limitApp** | 来源应用 | 针对哪个调用方限流 | `"default"` |
| **strategy** | 流控模式 | 直接限、关联限还是链路限 | `DIRECT` |
| **controlBehavior** | 流控效果 | 超出后怎么处理 | `REJECT/WARM_UP` |

### 2.3 完整配置示例


```java
// 实际开发中的配置方式
@PostConstruct
public void initFlowRules() {
    List<FlowRule> rules = new ArrayList<>();
    
    // 规则1：限制查询接口QPS为100
    FlowRule rule1 = new FlowRule();
    rule1.setResource("getUserInfo");     // 资源名
    rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);  // 按QPS限流
    rule1.setCount(100);                  // 每秒最多100次
    
    rules.add(rule1);
    FlowRuleManager.loadRules(rules);    // 加载规则
}
```

---

## 3. 📊 阈值类型详解


### 3.1 QPS阈值（最常用）


**QPS = Queries Per Second（每秒查询数）**

**通俗理解**：就像水龙头限制每秒流出多少滴水

```
场景演示：
设置QPS阈值为10

时间轴：  |------ 1秒 ------|
请求：    ●●●●●●●●●●            → 前10个通过
         ●●●●               → 后4个被拒绝
         
结果：每秒只允许通过10个请求
```

**代码配置**：
```java
FlowRule rule = new FlowRule();
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);  // QPS模式
rule.setCount(10);  // 每秒10次
```

**适用场景**：
- ✅ 接口访问频率控制
- ✅ API限流保护
- ✅ 秒杀活动流量控制

### 3.2 线程数阈值


**通俗理解**：限制同时处理请求的工人数量

```
餐厅比喻：
QPS限流 = 限制每小时接待多少客人
线程数限流 = 限制同时服务多少桌客人

示意图：
         请求1 ──→ [线程1] ──→ 处理中
         请求2 ──→ [线程2] ──→ 处理中  ✓ 前5个占用线程
         请求3 ──→ [线程3] ──→ 处理中
         请求4 ──→ [线程4] ──→ 处理中
         请求5 ──→ [线程5] ──→ 处理中
         请求6 ──→ [等待]   ──→ 被拒绝  ✗ 超出线程数限制
```

**代码配置**：
```java
FlowRule rule = new FlowRule();
rule.setGrade(RuleConstant.FLOW_GRADE_THREAD);  // 线程数模式
rule.setCount(5);  // 最多5个线程同时处理
```

**适用场景**：
- ✅ 慢接口保护（处理时间长的请求）
- ✅ 数据库连接池控制
- ✅ 外部API调用限制

### 3.3 两种阈值对比


| 对比项 | QPS阈值 | 线程数阈值 |
|--------|---------|-----------|
| **关注点** | 请求速率 | 并发处理能力 |
| **适合场景** | 快速响应的接口 | 慢接口或异步调用 |
| **计算方式** | 时间窗口内请求数 | 同时执行的线程数 |
| **典型值** | 100-10000 | 5-50 |

---

## 4. 🔀 流控模式深入理解


### 4.1 直接模式（最常用）


**含义**：直接对当前资源进行限流

**生活场景**：
> 🎬 电影院售票：每个窗口每分钟最多卖10张票
> - 窗口A达到限制 → 窗口A停止售票
> - 窗口B不受影响 → 窗口B正常售票

**工作原理**：
```
用户请求 → [检查/getUserInfo的流量] → 判断
                                      ↓
                    超过阈值 ← [是] ← 拒绝
                    未超过   ← [否] → 通过
```

**配置示例**：
```java
FlowRule rule = new FlowRule();
rule.setResource("getUserInfo");
rule.setStrategy(RuleConstant.STRATEGY_DIRECT);  // 直接模式
rule.setCount(100);
```

### 4.2 关联模式


**含义**：当关联资源达到阈值，限流当前资源

**生活场景**：
> 🏪 超市收银：
> - 当"收银台"排队过多时
> - 暂停"入口"让顾客进入
> - 避免更拥挤

**工作原理**：
```
资源A(写操作)流量很大
        ↓
   触发关联限流
        ↓
资源B(读操作)被限流  ← 保护整体系统
```

**配置示例**：
```java
FlowRule rule = new FlowRule();
rule.setResource("queryData");              // 当前资源(读)
rule.setStrategy(RuleConstant.STRATEGY_RELATE);  // 关联模式
rule.setRefResource("writeData");           // 关联资源(写)
rule.setCount(100);

// 含义：当writeData的QPS超过100时，限流queryData
```

**实际应用**：
- 📝 写操作频繁时，限制读操作
- 🔄 数据同步时，限制查询接口
- 💾 数据库备份时，限制业务访问

### 4.3 链路模式


**含义**：只统计从指定入口进入的流量

**场景理解**：
```
服务调用链路：
    
入口A → 商品服务 → 库存检查
                      ↓
入口B → 订单服务 → 库存检查

问题：库存检查被两个入口调用
需求：只限制从"订单服务"来的流量
```

**工作流程**：
```
        [入口A] ──→ 库存检查 ✓ 不限流
                      ↑
        [入口B] ──→ 限流检查 
                      ↓
                  超过阈值 → 拒绝
```

**配置示例**：
```java
FlowRule rule = new FlowRule();
rule.setResource("checkStock");              // 资源名
rule.setStrategy(RuleConstant.STRATEGY_CHAIN);   // 链路模式
rule.setRefResource("orderService");         // 指定入口
rule.setCount(50);

// 含义：只限制从orderService调用checkStock的流量
```

### 4.4 三种模式对比表


| 模式 | 限流对象 | 使用场景 | 配置复杂度 |
|------|---------|---------|-----------|
| **直接** | 当前资源本身 | 普通接口限流 | ⭐ 简单 |
| **关联** | 关联资源影响当前资源 | 读写互斥、资源竞争 | ⭐⭐ 中等 |
| **链路** | 特定调用路径 | 服务间调用控制 | ⭐⭐⭐ 复杂 |

---

## 5. ⚡ 流控效果与表现


### 5.1 快速失败（默认）


**含义**：超过阈值立即拒绝，抛出异常

**行为表现**：
```
请求处理流程：

正常请求 → [流量检查] → 通过 → 业务处理 → 返回结果

超出阈值 → [流量检查] → 拒绝 → 抛出FlowException
                              ↓
                         立即返回错误
```

**代码配置**：
```java
FlowRule rule = new FlowRule();
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);
// 或者不设置，默认就是快速失败
```

**异常处理**：
```java
try {
    Entry entry = SphU.entry("getUserInfo");
    // 业务逻辑
    entry.exit();
} catch (BlockException e) {
    // 被限流了，返回友好提示
    return "系统繁忙，请稍后再试";
}
```

**适用场景**：
- ✅ 对实时性要求高的场景
- ✅ 无法等待的请求
- ✅ 简单的限流保护

### 5.2 Warm Up（预热/冷启动）


**含义**：系统从冷启动状态逐渐升温到设定阈值

**生活场景**：
> 🚗 汽车启动：
> - 刚启动时转速低（冷车）
> - 逐渐提速到正常转速
> - 避免冷车急加速损坏引擎

**工作原理**：
```
阈值变化过程：

时间:  0s    3s    6s    9s    12s
      ↓     ↓     ↓     ↓     ↓
QPS:  10 → 30 → 50 → 70 → 100  (目标阈值)
      ──────────────────────→
           预热期(warmup)
```

**配置示例**：
```java
FlowRule rule = new FlowRule();
rule.setCount(100);  // 最终阈值
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_WARM_UP);
rule.setWarmUpPeriodSec(10);  // 预热10秒

// 含义：10秒内从阈值的1/3逐渐升到100
```

**计算公式**：
- 初始阈值 = count / 3
- 每秒增长 = (count - 初始阈值) / warmUpPeriodSec

**适用场景**：
- ✅ 系统刚启动时
- ✅ 缓存预热场景
- ✅ 防止冷启动时大流量冲击

### 5.3 排队等待


**含义**：请求排队，匀速通过，超时则失败

**生活场景**：
> 🏦 银行排队：
> - 每个窗口固定处理速度
> - 客户排队等待
> - 超过等待时间离开

**工作原理**：
```
请求时间轴：
           
0ms   请求1 → [立即处理]
100ms 请求2 → [等待100ms] → 处理
200ms 请求3 → [等待200ms] → 处理
300ms 请求4 → [等待300ms] → 处理
400ms 请求5 → [等待400ms] → 处理
500ms 请求6 → [等待超时] → 拒绝
              ↑
         maxQueueingTimeMs
```

**配置示例**：
```java
FlowRule rule = new FlowRule();
rule.setCount(10);  // 每秒处理10个
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);
rule.setMaxQueueingTimeMs(500);  // 最多等待500ms

// 含义：匀速每100ms处理一个请求，超过500ms等待时间则拒绝
```

**匀速间隔计算**：
- 间隔时间 = 1000ms / count
- 示例：count=10，则每100ms通过一个请求

**适用场景**：
- ✅ 消息队列场景
- ✅ 需要匀速处理的任务
- ✅ 削峰填谷

### 5.4 三种效果对比


| 流控效果 | 处理方式 | 优点 | 缺点 | 使用场景 |
|---------|---------|------|------|---------|
| **快速失败** | 立即拒绝 | 简单直接 | 可能丢失请求 | 实时性要求高 |
| **Warm Up** | 逐渐放开 | 保护系统 | 初期限流严格 | 系统启动预热 |
| **排队等待** | 匀速处理 | 流量平滑 | 可能超时 | 削峰填谷 |

---

## 6. 💾 规则持久化方案


### 6.1 为什么需要持久化


**问题场景**：
```
服务启动 → 加载规则到内存 → 运行中
                              ↓
                          服务重启
                              ↓
                         规则丢失 ✗
```

**解决方案**：将规则保存到外部存储

### 6.2 持久化方式对比


**方式1：文件持久化（简单）**

```java
// 读取配置文件
String flowRulePath = "classpath:flowrule.json";

// JSON格式示例
[{
  "resource": "getUserInfo",
  "count": 100,
  "grade": 1,
  "limitApp": "default",
  "strategy": 0,
  "controlBehavior": 0
}]
```

**方式2：Nacos持久化（推荐）**

```java
// application.yml配置
spring:
  cloud:
    sentinel:
      datasource:
        flow:
          nacos:
            server-addr: localhost:8848
            dataId: sentinel-flow-rules
            groupId: DEFAULT_GROUP
            rule-type: flow
```

**Nacos中的配置**：
```json
[
  {
    "resource": "getUserInfo",
    "count": 100,
    "grade": 1,
    "controlBehavior": 0
  }
]
```

**方式3：Apollo配置中心**

```java
@Bean
public FlowRuleApolloDataSource flowRuleApolloDataSource() {
    return new FlowRuleApolloDataSource(
        "sentinel.flow-rules",  // Apollo配置key
        "application",           // namespace
        new Converter<String, List<FlowRule>>() {
            @Override
            public List<FlowRule> convert(String source) {
                return JSON.parseArray(source, FlowRule.class);
            }
        }
    );
}
```

### 6.3 持久化方案选择


| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **文件** | 简单，无依赖 | 不支持动态更新 | 开发测试 |
| **Nacos** | 动态更新，可视化管理 | 需要部署Nacos | 生产环境⭐⭐⭐ |
| **Apollo** | 功能强大，版本管理 | 配置复杂 | 大型项目 |
| **数据库** | 灵活查询 | 性能较低 | 特定需求 |

### 6.4 动态更新流程


```
Nacos配置中心                     应用服务
      │                              │
      │  1.监听配置变化                │
      │ ←─────────────────────────── │
      │                              │
      │  2.推送新规则                 │
      │ ──────────────────────────→ │
      │                              │
      │                          3.更新内存规则
      │                              │
      │  4.生效                      │
      │                              ✓
```

---

## 7. 🎯 规则优先级机制


### 7.1 什么是规则优先级


**场景理解**：
```
同一个资源配置了多条规则：

规则1：QPS限流100
规则2：线程数限流10  
规则3：针对IP限流50

问题：应该执行哪个规则？
```

### 7.2 优先级规则


**1️⃣ 精确匹配优先**

```
资源名匹配优先级：
精确资源名 > 通配符 > 默认规则

示例：
/api/user/123  (精确)  ← 最优先
/api/user/*    (通配)  ← 次优先
default        (默认)  ← 最后
```

**2️⃣ 限流维度优先级**

```
同一资源的多个限流维度：

① 来源应用限流 (limitApp)
② 资源本身限流 (resource)
③ 关联资源限流 (refResource)

执行顺序：从上到下检查
```

**3️⃣ 阈值类型组合**

```
QPS限流和线程数限流同时存在：

用户请求 → [QPS检查] → [线程数检查] → 业务处理
              ↓            ↓
           超过100      超过10
              ↓            ↓
            拒绝         拒绝

规则：都要满足才能通过（AND关系）
```

### 7.3 规则冲突处理


**场景示例**：
```java
// 规则1：全局限流
FlowRule rule1 = new FlowRule();
rule1.setResource("getUserInfo");
rule1.setCount(100);
rule1.setLimitApp("default");

// 规则2：针对特定应用限流
FlowRule rule2 = new FlowRule();
rule2.setResource("getUserInfo");
rule2.setCount(50);
rule2.setLimitApp("app-order");

// 结果：
// - 来自app-order的请求：最多50 QPS
// - 来自其他应用的请求：最多100 QPS
```

### 7.4 优先级实践建议


> 💡 **最佳实践**
> 
> ✅ **DO：推荐做法**
> - 为不同场景配置独立规则
> - 使用精确的资源名
> - 规则命名清晰有意义
> 
> ❌ **DON'T：避免做法**
> - 避免规则过于复杂
> - 避免过多通配符
> - 避免规则冲突

---

## 8. 📋 核心要点总结


### 8.1 必知必会概念


```
🔸 FlowRule：流控规则配置对象
🔸 阈值类型：QPS（请求速率）和线程数（并发数）
🔸 流控模式：直接、关联、链路三种
🔸 流控效果：快速失败、Warm Up、排队等待
🔸 规则持久化：保存规则到外部存储
🔸 规则优先级：精确匹配优先，组合规则AND关系
```

### 8.2 快速配置指南


**步骤1：确定限流目标**
- 保护哪个接口？ → 设置resource
- 限制多少流量？ → 设置count

**步骤2：选择限流维度**
- 控制请求频率 → 选QPS
- 控制并发处理 → 选线程数

**步骤3：选择流控模式**
- 普通限流 → 直接模式
- 资源关联 → 关联模式  
- 调用链路 → 链路模式

**步骤4：选择流控效果**
- 快速响应 → 快速失败
- 系统预热 → Warm Up
- 流量平滑 → 排队等待

### 8.3 常见配置模板


**模板1：普通API限流**
```java
FlowRule rule = new FlowRule("getUserInfo");
rule.setCount(100);
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
```

**模板2：秒杀活动限流**
```java
FlowRule rule = new FlowRule("seckill");
rule.setCount(1000);
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);
rule.setMaxQueueingTimeMs(5000);
```

**模板3：系统启动预热**
```java
FlowRule rule = new FlowRule("heavyTask");
rule.setCount(500);
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_WARM_UP);
rule.setWarmUpPeriodSec(60);
```

### 8.4 核心记忆口诀


```
Sentinel流控要记牢，
FlowRule配置不能少。
QPS线程两阈值，
直接关联加链路。
快速失败最常用，
预热排队看场景。
Nacos持久保规则，
优先级别要搞清。
```

**关键理解**：
- 流控本质是"削峰填谷"，保护系统稳定
- 选择合适的限流策略比设置具体数值更重要
- 持久化让规则重启不丢失
- 优先级避免规则冲突混乱