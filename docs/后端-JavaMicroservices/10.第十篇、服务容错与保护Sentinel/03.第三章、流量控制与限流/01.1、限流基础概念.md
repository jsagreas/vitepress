---
title: 1、限流基础概念
---
## 📚 目录

1. [流量控制基础概念](#1-流量控制基础概念)
2. [限流的核心原理](#2-限流的核心原理)
3. [Sentinel限流规则详解](#3-Sentinel限流规则详解)
4. [流控效果与策略](#4-流控效果与策略)
5. [实战应用场景](#5-实战应用场景)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 流量控制基础概念


### 1.1 什么是流量控制


**生活类比理解**：
```
想象一个收费站场景：
高速公路收费站 → 你的微服务接口
车辆通行       → 用户请求
收费窗口数量   → 服务处理能力

问题：
- 如果车辆过多，收费站会拥堵瘫痪
- 如果请求过多，服务器会崩溃宕机

解决方案：
- 收费站：限制通行速度，开启更多窗口
- 微服务：限制请求速率，保护服务稳定
```

**流量控制的本质**：
- **目的**：保护系统不被过多请求压垮
- **手段**：控制进入系统的请求数量或速度
- **结果**：系统稳定运行，用户体验可控

### 1.2 为什么需要流量控制


**真实场景问题**：
```
电商秒杀活动：
正常流量：100 QPS（每秒请求数）
秒杀流量：10000 QPS（暴增100倍）

不做限流的后果：
1. 数据库连接耗尽
2. 服务器CPU/内存飙升
3. 系统响应变慢甚至宕机
4. 所有用户都无法访问

做了限流的效果：
1. 允许1000个用户正常访问
2. 其余用户友好提示"稍后再试"
3. 系统稳定，部分用户满意
4. 总比全部用户都失败要好
```

### 1.3 核心术语解释


**QPS（Queries Per Second）**：
```
含义：每秒查询数/请求数
计算：1秒内处理了多少个请求

示例：
- 某接口QPS=100，表示1秒能处理100个请求
- 超过100个请求，就需要排队或拒绝
```

**并发数（线程数）**：
```
含义：同时在处理的请求数量
区别：QPS关注速度，并发数关注数量

示例：
- 并发数=10，表示同时处理10个请求
- 第11个请求来了，就要等待或拒绝

QPS vs 并发数：
假设每个请求处理耗时1秒
并发数10 → QPS最多10
并发数100 → QPS最多100
```

**突发流量**：
```
含义：短时间内流量暴增

常见场景：
- 秒杀活动开始瞬间
- 热点新闻发布
- 明星微博发布
- 系统故障恢复后的流量涌入
```

**流量削峰填谷**：
```
削峰：把突发的高峰流量削减到可承受范围
填谷：把被拒绝的流量平摊到低峰时段

           削峰前                削峰后
流量      ┌───┐                ┌─────┐
         │   │                │     │ ← 削减后的峰值
    ─────┘   └─────      ─────┤     ├─────
                              └─────┘
         高峰被压平           流量更平稳
```

---

## 2. 🔧 限流的核心原理


### 2.1 限流的两个维度


**QPS限流（请求速率控制）**：
```
控制目标：每秒通过的请求数

适用场景：
- API接口调用限制
- 搜索引擎查询限制
- 短信发送限制

示例配置：
限制QPS=100
含义：1秒内最多处理100个请求
超出部分：拒绝或排队等待

实际效果：
0-1秒：处理100个请求 ✅
第101个请求：被拒绝 ❌
等到第2秒：又可以处理100个 ✅
```

**并发数限流（线程数控制）**：
```
控制目标：同时处理的请求数量

适用场景：
- 数据库连接池
- 文件操作
- 耗时的计算任务

示例配置：
限制线程数=10
含义：最多同时处理10个请求

实际效果：
已有10个请求在处理中
第11个请求到来：等待或拒绝
某个请求处理完成：释放1个位置
第11个请求：可以进入了 ✅
```

**两种方式对比**：

| 维度 | **QPS限流** | **并发数限流** |
|------|------------|---------------|
| **关注点** | 速率（多快） | 数量（多少个） |
| **计算方式** | 时间窗口内的请求数 | 当前正在处理的数量 |
| **适用场景** | 快速请求（毫秒级） | 慢速请求（秒级） |
| **典型应用** | API调用、查询 | 数据库操作、文件IO |

### 2.2 限流算法原理


**固定窗口算法**：
```
原理：在固定时间窗口内统计请求数

时间轴：|----1秒----|----1秒----|----1秒----|
请求数：    100个        80个       120个
限制：     100 QPS
结果：      通过✅       通过✅      拒绝20个❌

缺陷：临界问题
0.9秒-1.0秒：100个请求 ✅
1.0秒-1.1秒：100个请求 ✅
实际0.2秒内：200个请求！超载了！

            第1秒        第2秒
请求   ──────┤├──────
            ↑↑
         这0.2秒实际200个请求！
```

**滑动窗口算法**：
```
原理：时间窗口不断向前滑动，更精确

固定窗口（1秒）：
|--------1秒--------|--------1秒--------|
  统计这1秒的请求量

滑动窗口（每0.1秒滑动）：
|--0.1秒--|
    |--0.1秒--|
        |--0.1秒--|
每次都统计最近1秒内的请求量

优势：
- 避免临界问题
- 限流更平滑
- 更精确控制
```

**漏桶算法**：
```
核心思想：请求像水一样注入桶，以固定速率流出

                请求到来（不规律）
                  ↓ ↓ ↓ ↓ ↓
                ┌─────────┐
                │  漏桶   │ ← 桶有容量限制
                │ ~~~~~~~ │
                └────┬────┘
                     ↓
                固定速率流出

特点：
- 流出速率恒定（QPS稳定）
- 桶满了则拒绝新请求
- 可以应对突发流量（桶的容量）

实际效果：
突发100个请求 → 进入桶中
以每秒10个的速度处理
处理完需要10秒

优点：流出速率稳定，保护下游
缺点：无法应对短时高峰需求
```

**令牌桶算法**：
```
核心思想：以固定速率生成令牌，请求获取令牌才能通过

            以固定速率生成令牌
                  ↓ ↓ ↓
                ┌─────────┐
                │令牌桶   │
                │ ●●●●●  │ ← 令牌（预存一定数量）
                └────┬────┘
                     ↓
    请求到来 → 拿到令牌 → 通过 ✅
    请求到来 → 没有令牌 → 拒绝 ❌

特点：
- 令牌生成速率固定
- 桶中可预存令牌
- 可以应对一定的突发流量

实际效果：
令牌生成速率：每秒10个
桶容量：100个令牌

正常情况：每秒处理10个请求
突发情况：可以瞬间处理100个请求
之后：恢复到每秒10个

优点：允许一定程度的突发流量
缺点：实现相对复杂
```

### 2.3 Sentinel采用的算法


**Sentinel的选择**：
```
QPS限流：滑动窗口算法
- 更精确的流量控制
- 避免固定窗口的临界问题

并发数限流：计数器
- 简单直接
- 实时统计当前处理中的请求数

为什么这样选择：
滑动窗口：适合按时间统计
计数器：适合按数量统计
组合使用：更灵活强大
```

---

## 3. 📊 Sentinel限流规则详解


### 3.1 限流规则的配置要素


**核心配置项**：
```java
// 限流规则配置示例
FlowRule rule = new FlowRule();
rule.setResource("order-service");  // 资源名称
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);  // 限流类型
rule.setCount(100);  // 限流阈值
```

**配置项详解**：

| 配置项 | **含义** | **常用值** | **说明** |
|--------|---------|-----------|---------|
| **resource** | 资源名 | "/order/create" | 要保护的接口或方法 |
| **grade** | 限流类型 | QPS/线程数 | 按什么维度限流 |
| **count** | 阈值 | 100 | 限流的具体数值 |
| **limitApp** | 来源应用 | default/具体应用名 | 针对哪个调用方限流 |
| **strategy** | 流控模式 | 直接/关联/链路 | 如何触发限流 |
| **controlBehavior** | 流控效果 | 快速失败/预热/排队 | 触发后的处理方式 |

### 3.2 限流类型详解


**QPS限流**：
```java
// QPS限流配置
FlowRule rule = new FlowRule();
rule.setResource("/api/user/query");
rule.setGrade(RuleConstant.FLOW_GRADE_QPS);  // QPS模式
rule.setCount(50);  // 每秒最多50个请求

// 实际效果
第1秒：处理50个请求 ✅
第51个请求：被拒绝 ❌（返回限流异常）
第2秒：又可以处理50个 ✅

// 适用场景
- 查询接口：响应快，关注QPS
- API调用：需要控制调用频率
- 缓存查询：快速操作场景
```

**并发线程数限流**：
```java
// 线程数限流配置
FlowRule rule = new FlowRule();
rule.setResource("/api/order/create");
rule.setGrade(RuleConstant.FLOW_GRADE_THREAD);  // 线程数模式
rule.setCount(10);  // 最多10个线程同时处理

// 实际效果
当前10个请求正在处理（每个耗时2秒）
第11个请求到来：被拒绝 ❌
2秒后某个请求完成：释放1个线程
第11个请求：可以进入了 ✅

// 适用场景
- 订单创建：操作慢，关注并发数
- 文件上传：耗时长，限制数量
- 数据库写操作：保护数据库
```

### 3.3 流控模式详解


**直接模式（最常用）**：
```java
// 直接限流：直接限制当前资源
FlowRule rule = new FlowRule();
rule.setResource("/order/create");
rule.setStrategy(RuleConstant.STRATEGY_DIRECT);  // 直接模式
rule.setCount(100);

// 效果
/order/create 接口调用超过100 → 直接限流

场景：
最常见的限流方式
直接保护当前接口
```

**关联模式（保护关联资源）**：
```java
// 关联限流：当关联资源达到阈值时，限流当前资源
FlowRule rule = new FlowRule();
rule.setResource("/order/query");  // 要限流的资源
rule.setStrategy(RuleConstant.STRATEGY_RELATE);  // 关联模式
rule.setRefResource("/order/create");  // 关联的资源
rule.setCount(50);

// 效果
当 /order/create 的QPS超过50时
限流 /order/query 接口

实际场景：
/order/create（写操作）比较重要
当写操作压力大时，限制读操作
保证写操作优先执行

类比理解：
写操作 = 救护车
读操作 = 普通车辆
救护车多了，普通车让路
```

**链路模式（细粒度控制）**：
```java
// 链路限流：只统计从指定入口进入的流量
FlowRule rule = new FlowRule();
rule.setResource("commonService");  // 共用服务
rule.setStrategy(RuleConstant.STRATEGY_CHAIN);  // 链路模式
rule.setRefResource("/order/create");  // 指定入口
rule.setCount(20);

// 调用链路
/order/create → commonService
/user/query → commonService

// 效果
只限制从 /order/create 调用 commonService 的流量
从 /user/query 调用不受限制

实际场景：
commonService 被多个接口调用
只想限制某个入口的调用
其他入口正常使用
```

---

## 4. 🎨 流控效果与策略


### 4.1 快速失败（默认方式）


**工作原理**：
```
请求到来 → 检查是否超过阈值
超过 → 立即拒绝，抛出异常
未超过 → 正常处理

           请求1-100    请求101-200
时间轴：  ──────┬───────┬─────→
           通过✅      拒绝❌

特点：
- 简单直接
- 没有等待
- 立即返回失败
```

**代码示例**：
```java
// 快速失败配置
FlowRule rule = new FlowRule();
rule.setResource("/api/query");
rule.setCount(100);
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);

// 触发限流后的处理
@GetMapping("/api/query")
public Result query() {
    try {
        // 业务逻辑
        return Result.success(data);
    } catch (BlockException e) {
        // 被限流了，返回友好提示
        return Result.error("系统繁忙，请稍后重试");
    }
}
```

**适用场景**：
- 查询类接口（失败影响小）
- 实时性要求高（不能等待）
- 明确告知用户系统繁忙

### 4.2 Warm Up预热（应对冷启动）


**问题场景**：
```
系统刚启动或长时间空闲：
缓存是空的
连接池未建立
JVM未充分预热

突然大量请求 → 系统无法承受 → 崩溃

解决方案：预热
慢慢增加流量，给系统预热时间
```

**预热原理**：
```java
// Warm Up配置
FlowRule rule = new FlowRule();
rule.setResource("/api/hot");
rule.setCount(1000);  // 最终阈值
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_WARM_UP);
rule.setWarmUpPeriodSec(60);  // 预热时长60秒

// 预热过程
阈值变化：
0-20秒：阈值从 1000/3≈333 慢慢增加
20-40秒：阈值继续增加到 666
40-60秒：阈值达到 1000（完全预热）

流量曲线：
1000 ─────────────────
                    ╱
                  ╱
                ╱
 333 ─────────╱
     0s    20s    40s    60s
```

**实际效果**：
```
系统启动时：
前60秒：逐步接受更多流量
60秒后：恢复正常处理能力

类比理解：
就像运动员：
不能上来就100%强度
需要热身，逐步加强
避免拉伤（系统崩溃）
```

### 4.3 匀速排队（削峰填谷）


**应用场景**：
```
消息队列处理：
瞬间来1000条消息
处理能力每秒10条

不用排队：
前100条处理
剩余900条丢弃 ❌

使用排队：
1000条都进队列
按每秒10条慢慢处理 ✅
100秒处理完
```

**排队原理**：
```java
// 匀速排队配置
FlowRule rule = new FlowRule();
rule.setResource("/api/message");
rule.setCount(10);  // 每秒10个
rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);
rule.setMaxQueueingTimeMs(5000);  // 最多等待5秒

// 实际效果
瞬间来100个请求：
前10个：立即处理
第11-60个：排队等待（5秒内能处理50个）
第61-100个：等待超过5秒，拒绝

请求处理：
时间    处理请求
0秒     1-10
1秒     11-20
2秒     21-30
...
```

**流量处理对比**：
```
快速失败：
100个请求 → 10个成功，90个失败
成功率：10%

匀速排队：
100个请求 → 60个成功（5秒内处理完），40个失败
成功率：60%

适用场景：
- 消息处理（可以等待）
- 日志收集（不需要立即响应）
- 批量操作（削峰处理）
```

### 4.4 流控效果对比总结


| 效果类型 | **处理方式** | **适用场景** | **优缺点** |
|---------|------------|-------------|-----------|
| **快速失败** | 立即拒绝 | 查询接口、实时操作 | ✅简单直接<br>❌失败率高 |
| **Warm Up** | 慢慢放开 | 系统启动、定时任务 | ✅保护系统<br>❌预热期间QPS低 |
| **匀速排队** | 队列等待 | 消息处理、批量操作 | ✅成功率高<br>❌响应变慢 |

---

## 5. 🚀 实战应用场景


### 5.1 电商秒杀场景


**场景分析**：
```
秒杀商品：100件
预计流量：10万人抢购
系统能力：1000 QPS

不限流后果：
10万请求瞬间打到数据库
数据库崩溃
没人能买到

限流方案：
```

**完整限流配置**：
```java
// 1. 秒杀接口限流（快速失败）
FlowRule seckillRule = new FlowRule();
seckillRule.setResource("/seckill/buy");
seckillRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
seckillRule.setCount(1000);  // 限制1000 QPS
seckillRule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);

// 2. 前端限流（用户提示）
@GetMapping("/seckill/buy")
public Result seckill(@RequestParam Long productId) {
    try {
        // 秒杀业务逻辑
        boolean success = seckillService.buy(productId);
        return Result.success(success);
    } catch (BlockException e) {
        // 触发限流，友好提示
        return Result.error("手速太慢了，商品已被抢光");
    }
}

// 3. 数据库保护（并发数限流）
FlowRule dbRule = new FlowRule();
dbRule.setResource("seckill-db");
dbRule.setGrade(RuleConstant.FLOW_GRADE_THREAD);
dbRule.setCount(50);  // 最多50个并发
```

**效果对比**：
```
不限流：
10万请求 → 全部失败 → 系统崩溃
成功：0人

限流后：
10万请求 → 1000个进入系统 → 100人成功
成功：100人
失败：99900人收到友好提示
系统：稳定运行
```

### 5.2 API网关限流


**场景分析**：
```
微服务网关：
后端服务能力有限
需要保护后端不被打垮

多种限流策略：
按用户限流
按接口限流
按来源限流
```

**多维度限流**：
```java
// 1. 按用户限流（防止恶意用户）
FlowRule userRule = new FlowRule();
userRule.setResource("/api/**");
userRule.setLimitApp("user-123");  // 针对特定用户
userRule.setCount(100);  // 每秒100次

// 2. 按接口限流（保护热点接口）
FlowRule apiRule = new FlowRule();
apiRule.setResource("/api/order/create");
apiRule.setCount(500);  // 创建订单限500 QPS

// 3. 按来源限流（区分不同调用方）
FlowRule sourceRule = new FlowRule();
sourceRule.setResource("order-service");
sourceRule.setLimitApp("mobile-app");  // 针对移动端
sourceRule.setCount(1000);

// 网关层处理
@Component
public class GatewayFlowHandler implements BlockExceptionHandler {
    @Override
    public void handle(HttpServletRequest request, 
                       HttpServletResponse response, 
                       BlockException e) {
        response.setStatus(429);  // HTTP 429 Too Many Requests
        response.getWriter().write("系统繁忙，请稍后重试");
    }
}
```

### 5.3 消息队列流量控制


**场景分析**：
```
消息消费场景：
生产者：每秒1000条消息
消费者：每秒处理100条
问题：消费速度跟不上生产速度

解决方案：
限制消费速度
匀速处理消息
```

**匀速排队配置**：
```java
// 消息消费限流
FlowRule mqRule = new FlowRule();
mqRule.setResource("message-consumer");
mqRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
mqRule.setCount(100);  // 每秒处理100条
mqRule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);
mqRule.setMaxQueueingTimeMs(10000);  // 最多等待10秒

// 消费者代码
@Service
public class MessageConsumer {
    
    @SentinelResource(value = "message-consumer")
    public void consume(Message msg) {
        // 处理消息
        processMessage(msg);
    }
}

// 实际效果
1000条消息到来：
前100条：立即处理
101-1100条：排队（10秒内处理1000条）
1101条后：拒绝（等待超时）

结果：
不会把消费者打垮
稳定的处理速度
保证系统稳定性
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🎯 流量控制本质：保护系统不被过多请求压垮
📊 两个限流维度：QPS（速率）和并发数（数量）
🔧 三种流控模式：直接、关联、链路
🎨 三种流控效果：快速失败、预热、匀速排队
```

### 6.2 关键理解要点


**QPS vs 并发数**：
```
QPS：关注速度（每秒多少个）
- 适合快速请求
- 按时间窗口统计
- 用于API限流

并发数：关注数量（同时多少个）
- 适合慢速请求
- 实时计数
- 用于资源保护
```

**流控效果选择**：
```
快速失败：
✅ 查询接口
✅ 实时要求高
❌ 重要业务

Warm Up预热：
✅ 系统启动
✅ 定时任务
❌ 流量平稳

匀速排队：
✅ 消息处理
✅ 批量操作
❌ 实时响应
```

### 6.3 实践经验总结


**限流阈值设置**：
```
1. 压测确定系统能力
2. 预留20-30%安全余量
3. 监控实际流量调整

示例：
压测结果：1200 QPS
安全余量：80%
设置阈值：1000 QPS
```

**限流降级配合**：
```
限流：控制流量进入
降级：流量过大时的备选方案

示例：
1. 限流1000 QPS
2. 超过后返回降级数据
3. 保证系统稳定
```

**核心记忆口诀**：
```
流量控制保稳定，QPS线程两维度
快速失败最直接，预热排队有策略
根据场景选方案，阈值设置需谨慎
```