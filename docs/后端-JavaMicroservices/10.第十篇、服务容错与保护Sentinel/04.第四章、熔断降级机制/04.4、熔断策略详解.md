---
title: 4、熔断策略详解
---
## 📚 本节目录

1. [熔断规则基础概念](#1-熔断规则基础概念)
2. [慢调用比例熔断](#2-慢调用比例熔断)
3. [异常比例熔断](#3-异常比例熔断)
4. [异常数熔断](#4-异常数熔断)
5. [RT响应时间熔断](#5-RT响应时间熔断)
6. [熔断策略选择指南](#6-熔断策略选择指南)
7. [触发条件深度解析](#7-触发条件深度解析)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 熔断规则基础概念


### 1.1 什么是熔断规则


**用生活例子理解熔断**：

想象你家里的保险丝（空气开关）。当电路出现短路或者负载过大时，保险丝会自动"断开"，切断电源保护整个电路。等问题解决后，再手动合上开关恢复供电。

微服务中的熔断规则就是这个道理：
```
正常情况：
用户请求 → 服务A → 服务B → 返回结果
         (一切正常，快速响应)

服务B出问题：
用户请求 → 服务A → 服务B (超时/异常)
                   ↓
                 熔断器触发！
                   ↓
         直接返回降级结果，不再调用B
```

### 1.2 熔断器的三种状态


**🔄 熔断器状态机**：
```
熔断器的三种状态：

① 关闭状态 (Closed)
   ├─ 正常放行所有请求
   ├─ 统计调用情况
   └─ 达到阈值 → 进入开启状态

② 开启状态 (Open)  
   ├─ 直接拒绝请求
   ├─ 快速失败，返回降级结果
   └─ 等待恢复时间 → 进入半开状态

③ 半开状态 (Half-Open)
   ├─ 尝试放行少量请求
   ├─ 成功 → 回到关闭状态
   └─ 失败 → 回到开启状态

状态转换流程：
关闭 → (达到阈值) → 开启 → (等待时间) → 半开 → (测试成功) → 关闭
                                    ↓ (测试失败)
                                   开启
```

**💡 通俗理解状态转换**：
- **关闭状态**：正常工作，但在观察（就像保险丝正常通电）
- **开启状态**：保护模式，拒绝服务（就像保险丝跳闸断电）
- **半开状态**：试探性恢复（就像测试一下能不能合上开关）

### 1.3 Sentinel熔断规则类型概览


Sentinel提供了4种熔断策略，分别针对不同的问题场景：

| 熔断策略 | **适用场景** | **判断依据** | **典型问题** |
|---------|------------|-------------|-------------|
| **慢调用比例** | `服务响应慢` | `慢调用占比超过阈值` | `数据库查询慢、网络延迟高` |
| **异常比例** | `服务不稳定` | `异常调用占比超过阈值` | `间歇性故障、部分失败` |
| **异常数** | `绝对异常量大` | `异常次数超过阈值` | `频繁报错、持续异常` |
| **RT响应时间** | `整体性能差` | `平均响应时间超标` | `系统过载、资源不足` |

---

## 2. ⏱️ 慢调用比例熔断


### 2.1 什么是慢调用


**生活化理解**：

你去餐厅点餐，正常情况下5分钟就能上菜。但今天厨房出了问题，每道菜都要等15分钟。如果大部分订单都这么慢，餐厅就应该暂时停止接单，不然会堵死整个厨房。

这就是"慢调用"的概念：
```
慢调用 = 响应时间超过设定阈值的调用

举例说明：
设定：超过 1000ms 算慢调用

调用1：耗时 800ms  → 正常 ✓
调用2：耗时 1200ms → 慢调用 ✗  
调用3：耗时 500ms  → 正常 ✓
调用4：耗时 1500ms → 慢调用 ✗

慢调用比例 = 2/4 = 50%
```

### 2.2 慢调用比例熔断配置


**📋 核心参数说明**：

```java
// 慢调用比例熔断规则配置
DegradeRule rule = new DegradeRule("userService")
    .setGrade(RuleConstant.DEGRADE_GRADE_RT)  // 熔断策略：慢调用比例
    .setCount(1000)          // RT阈值：1000ms，超过算慢调用
    .setSlowRatioThreshold(0.5)  // 比例阈值：50%，一半以上算慢就熔断
    .setMinRequestAmount(5)      // 最小请求数：至少5次调用才判断
    .setStatIntervalMs(10000)    // 统计时长：10秒内的统计数据
    .setTimeWindow(5);           // 熔断时长：熔断后保持5秒
```

**🔍 参数详细解释**：

```
① RT阈值 (count = 1000)
   含义：超过1000毫秒就算"慢调用"
   类比：规定"超过5分钟上菜就算慢"

② 比例阈值 (slowRatioThreshold = 0.5)
   含义：慢调用超过50%就触发熔断
   类比："如果一半以上的菜都慢，就停止接单"

③ 最小请求数 (minRequestAmount = 5)
   含义：至少要有5次调用才开始判断
   类比："至少接了5个订单，才能判断厨房是否真的慢"
   目的：避免样本太少导致误判

④ 统计时长 (statIntervalMs = 10000)
   含义：统计最近10秒内的数据
   类比："看最近10分钟的订单情况"

⑤ 熔断时长 (timeWindow = 5)
   含义：熔断后保持5秒，然后进入半开状态
   类比："停止接单5分钟，然后试着接一单看看"
```

### 2.3 慢调用熔断工作流程


**📊 完整工作流程图示**：

```
慢调用熔断完整流程：

第1阶段：统计阶段 (10秒统计窗口)
─────────────────────────────────
时间轴：0s────2s────4s────6s────8s────10s
调用1：500ms  ✓
调用2：1200ms ✗ (慢)
调用3：800ms  ✓
调用4：1500ms ✗ (慢)
调用5：1100ms ✗ (慢)
调用6：700ms  ✓
─────────────────────────────────
统计结果：6次调用，3次慢调用
慢调用比例：3/6 = 50% ≥ 阈值(50%)
满足最小请求数：6 ≥ 5
→ 触发熔断！

第2阶段：熔断阶段 (5秒熔断窗口)
─────────────────────────────────
熔断开启 (Open状态)
  ↓
所有请求被拒绝
  ↓
快速返回降级结果
  ↓
等待5秒...
─────────────────────────────────

第3阶段：恢复探测 (Half-Open状态)
─────────────────────────────────
放行1个探测请求
  ↓
成功(RT < 1000ms) → 关闭熔断器 (Closed)
失败(RT ≥ 1000ms) → 继续熔断 (Open)
```

### 2.4 实际应用场景


**🎯 适用场景分析**：

```
✅ 适合使用慢调用比例熔断：

场景1：数据库查询慢
问题：数据库负载高，查询响应慢
表现：大量请求响应时间超过1秒
方案：设置RT=1000ms，比例50%，熔断保护

场景2：第三方API调用
问题：外部服务网络不稳定
表现：部分请求严重超时
方案：设置RT=2000ms，比例60%，防止拖垮系统

场景3：复杂业务处理
问题：某些计算密集型操作
表现：高峰期处理变慢
方案：设置RT=3000ms，比例40%，避免雪崩
```

**⚙️ 参数调优建议**：

```
🔸 RT阈值设置原则：
• 正常响应时间的 2-3倍
• 太小：误判频繁
• 太大：保护不及时

示例：
正常响应：200-500ms
建议RT阈值：1000-1500ms

🔸 比例阈值设置原则：
• 保守策略：70-80%（容忍度高）
• 激进策略：30-50%（保护更严格）
• 推荐默认：50%（平衡保护和可用性）

🔸 统计时长设置：
• 短周期（5-10秒）：快速响应
• 长周期（30-60秒）：更稳定
• 推荐：10秒（适中）

🔸 熔断时长设置：
• 临时故障：5-10秒
• 持久问题：30-60秒
• 建议：从小开始逐步调整
```

---

## 3. 💥 异常比例熔断


### 3.1 异常比例的概念


**通俗理解**：

假设你开了一家快递公司，正常情况下99%的包裹都能正常送达。但突然有一天，发现50%的包裹都送不到（地址错误、收件人不在等）。这时候就应该暂停接单，检查一下系统是不是出问题了。

```
异常比例 = 发生异常的请求数 / 总请求数

实例说明：
10次调用中：
- 6次成功 ✓
- 4次异常 ✗（抛出Exception）

异常比例 = 4/10 = 40%
```

### 3.2 异常比例熔断配置


```java
// 异常比例熔断规则
DegradeRule rule = new DegradeRule("orderService")
    .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO)  // 策略：异常比例
    .setCount(0.5)           // 异常比例阈值：50%
    .setMinRequestAmount(10) // 最小请求数：10次
    .setStatIntervalMs(10000) // 统计周期：10秒
    .setTimeWindow(10);       // 熔断时长：10秒
```

**📝 参数说明**：

```
① 异常比例阈值 (count = 0.5)
   含义：异常请求超过50%触发熔断
   范围：0.0-1.0（对应0%-100%）
   
② 最小请求数 (minRequestAmount = 10)
   含义：至少10次调用才计算比例
   原因：避免小样本误判
   
   错误示例：
   只有2次调用，1次异常 = 50%
   这种情况不应该熔断（样本太小）

③ 统计周期 (statIntervalMs = 10000)
   含义：统计最近10秒的数据
   
④ 熔断时长 (timeWindow = 10)
   含义：熔断后保持10秒再尝试恢复
```

### 3.3 异常类型识别


Sentinel会捕获哪些异常？

```
✅ 会触发熔断的异常：
• RuntimeException及其子类
• Error及其子类
• 业务代码主动抛出的异常

示例代码：
public User getUser(Long id) {
    if (id == null) {
        throw new IllegalArgumentException("ID不能为空");  // ✓ 算异常
    }
    
    User user = userMapper.selectById(id);
    if (user == null) {
        throw new UserNotFoundException("用户不存在");    // ✓ 算异常
    }
    
    return user;
}

❌ 不会触发熔断的情况：
• 返回null（正常返回）
• 返回错误码对象（正常返回）
• try-catch捕获后不再抛出（已处理）

不触发示例：
public Result getUser(Long id) {
    try {
        User user = userService.findById(id);
        return Result.success(user);
    } catch (Exception e) {
        return Result.fail("查询失败");  // ✓ 不算异常（已处理）
    }
}
```

### 3.4 异常比例应用场景


**🎯 典型使用场景**：

```
场景1：数据库连接池耗尽
现象：
- 大量请求抛出 SQLException
- "Cannot get connection from pool"
- 异常比例迅速上升到60%

解决方案：
rule.setGrade(EXCEPTION_RATIO)
    .setCount(0.3)          // 30%异常就熔断
    .setMinRequestAmount(5) // 最少5次请求
    .setTimeWindow(15);     // 熔断15秒，给连接池恢复时间

场景2：第三方服务调用失败
现象：
- 支付接口频繁超时抛异常
- 网络故障导致连接失败
- 异常比例达到50%

解决方案：
rule.setGrade(EXCEPTION_RATIO)
    .setCount(0.4)          // 40%异常就熔断
    .setMinRequestAmount(10)
    .setTimeWindow(30);     // 给第三方服务更多恢复时间

场景3：业务逻辑异常
现象：
- 库存不足异常频发
- 参数校验失败多
- 数据不一致异常

注意：这种情况可能不适合用异常比例熔断
原因：这是业务问题，不是服务故障
```

**⚠️ 使用注意事项**：

```
🔸 区分业务异常和系统异常：

业务异常（不应熔断）：
- 库存不足
- 用户余额不足  
- 参数校验失败
→ 这些是正常业务流程，不应触发熔断

系统异常（应该熔断）：
- 数据库连接失败
- 网络超时
- 系统内部错误
→ 这些是系统故障，需要熔断保护

处理建议：
// 业务异常用返回值表示
public Result<Order> createOrder(OrderDTO dto) {
    if (stock < dto.getQuantity()) {
        return Result.fail("库存不足");  // 不抛异常
    }
    // ...
}

// 系统异常才抛出
public Order getOrderById(Long id) {
    try {
        return orderMapper.selectById(id);
    } catch (SQLException e) {
        throw new SystemException("数据库异常", e);  // 抛异常
    }
}
```

---

## 4. 🔢 异常数熔断


### 4.1 异常数与异常比例的区别


**关键区别理解**：

```
异常比例熔断：看的是"百分比"
示例：10次请求，5次异常 = 50%

异常数熔断：看的是"绝对数量"  
示例：1分钟内异常超过100次就熔断

对比说明：
────────────────────────────────────
场景：低流量服务
请求量：10次/分钟
异常：5次

异常比例：5/10 = 50% → 可能触发
异常数：5次 < 100次 → 不会触发
结论：异常比例更敏感
────────────────────────────────────
场景：高流量服务  
请求量：10000次/分钟
异常：120次

异常比例：120/10000 = 1.2% → 可能不触发
异常数：120次 > 100次 → 会触发
结论：异常数更能发现问题
```

### 4.2 异常数熔断配置


```java
// 异常数熔断规则配置
DegradeRule rule = new DegradeRule("paymentService")
    .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT)  // 策略：异常数
    .setCount(50)            // 异常数阈值：50次
    .setMinRequestAmount(5)  // 最小请求数：5次
    .setStatIntervalMs(60000) // 统计周期：60秒
    .setTimeWindow(30);       // 熔断时长：30秒
```

**🔍 配置参数详解**：

```
① 异常数阈值 (count = 50)
   含义：统计周期内异常达到50次就熔断
   单位：次数（绝对值）
   
   选择建议：
   • 低流量服务（<100 QPS）：10-30次
   • 中流量服务（100-1000 QPS）：50-100次
   • 高流量服务（>1000 QPS）：100-500次

② 统计周期 (statIntervalMs = 60000)
   含义：统计最近60秒（1分钟）的异常
   
   时长选择：
   • 短周期（10-30秒）：快速响应，但可能敏感
   • 长周期（60-120秒）：更稳定，但响应慢
   • 推荐：60秒（平衡点）

③ 最小请求数 (minRequestAmount = 5)
   含义：至少要有5次请求才开始统计
   
   注意：异常数模式下，这个参数影响较小
   因为关注的是异常绝对数量

④ 熔断时长 (timeWindow = 30)
   含义：熔断后保持30秒
   
   建议：
   • 瞬时故障：10-20秒
   • 持续问题：30-60秒
   • 严重故障：可设置更长
```

### 4.3 异常数熔断工作机制


**📊 工作流程示例**：

```
异常数熔断触发过程：

统计窗口：60秒
异常阈值：50次
当前时间：14:30:00

时间线统计：
14:29:00 ~ 14:29:10  异常 8次   累计: 8
14:29:10 ~ 14:29:20  异常 12次  累计: 20
14:29:20 ~ 14:29:30  异常 15次  累计: 35
14:29:30 ~ 14:29:40  异常 10次  累计: 45
14:29:40 ~ 14:29:50  异常 8次   累计: 53 ← 超过50！
                                   ↓
                              触发熔断！

熔断后行为：
14:29:50 ~ 14:30:20 (30秒)
所有请求快速失败，返回降级结果

14:30:20
进入半开状态，尝试放行请求

14:30:21
若请求成功 → 关闭熔断器
若请求异常 → 继续熔断30秒
```

### 4.4 适用场景分析


**🎯 最佳应用场景**：

```
✅ 适合异常数熔断的场景：

场景1：高流量系统保护
特点：
• QPS很高（1000+）
• 异常比例可能很低（1-2%）
• 但绝对异常数量大（每分钟几百次）

配置示例：
.setCount(200)         // 200次异常就熔断
.setStatIntervalMs(60000)  // 统计1分钟
.setTimeWindow(20)     // 熔断20秒

场景2：批处理任务
特点：
• 批量处理数据
• 关注失败总数
• 失败超过一定数量就停止

配置示例：
.setCount(100)         // 100个失败就停
.setStatIntervalMs(300000)  // 5分钟窗口
.setTimeWindow(60)     // 熔断1分钟

场景3：定时任务调用
特点：
• 周期性执行
• 连续失败需要告警
• 不关心比例，关心次数

配置示例：
.setCount(5)           // 连续5次失败
.setStatIntervalMs(30000)   // 30秒内
.setTimeWindow(300)    // 熔断5分钟
```

**⚖️ 异常数 vs 异常比例选择**：

```
使用异常数的情况：
✓ 高QPS系统（异常比例可能很低但数量大）
✓ 关注绝对故障次数
✓ 批处理场景
✓ 定时任务监控

使用异常比例的情况：
✓ 低流量系统（小样本下比例更有意义）
✓ 关注服务稳定性百分比
✓ 需要动态适应流量变化
✓ 标准化监控指标

通常建议：
根据系统QPS选择：
• QPS < 100：优先异常比例
• QPS > 1000：优先异常数
• 100-1000：两者都可，看具体需求

或者同时配置：
异常比例：快速发现突发问题
异常数：防止高流量下的绝对故障累积
```

---

## 5. ⏰ RT响应时间熔断


### 5.1 RT熔断的特殊性


**RT（Response Time）熔断说明**：

在Sentinel 1.8.0之后，传统的RT熔断被**慢调用比例**策略替代了，但RT的概念依然重要。

```
🔄 演进历史：

旧版本（< 1.8.0）：
独立的RT熔断策略
.setGrade(DEGRADE_GRADE_RT)
.setCount(100)  // 平均RT超过100ms就熔断

新版本（≥ 1.8.0）：
整合到慢调用比例
.setGrade(DEGRADE_GRADE_RT)  // 实际是慢调用比例
.setCount(100)               // RT阈值
.setSlowRatioThreshold(1.0)  // 100%算慢才熔断

原因：
旧的平均RT策略不够灵活
慢调用比例能更精确控制
```

### 5.2 RT相关概念理解


**📊 响应时间的几个概念**：

```
① 平均响应时间 (Average RT)
计算：总耗时 / 请求数
示例：
请求1: 100ms
请求2: 200ms
请求3: 150ms
平均RT = (100+200+150)/3 = 150ms

② 最大响应时间 (Max RT)
定义：统计周期内最慢的请求
示例：
请求1: 100ms
请求2: 200ms
请求3: 150ms  
最大RT = 200ms

③ P95/P99响应时间
P95: 95%的请求响应时间低于该值
P99: 99%的请求响应时间低于该值

示例（100个请求排序后）：
P95值 = 第95个请求的RT
P99值 = 第99个请求的RT

实际意义：
P95 = 500ms 表示：
95%的用户体验到的响应时间≤500ms
只有5%的用户体验较差
```

### 5.3 RT监控与慢调用关系


**🔗 RT监控如何转化为慢调用策略**：

```
传统RT熔断思路：
"平均响应时间超过阈值就熔断"

问题：
10次请求：
9次 50ms (非常快)
1次 5000ms (超级慢)
平均RT = (9×50 + 5000)/10 = 545ms

如果RT阈值=500ms，就会熔断
但实际上90%的请求都很快！

慢调用比例思路：
"超过阈值的请求占比过高才熔断"

同样的场景：
RT阈值 = 1000ms
慢调用比例 = 1/10 = 10%
比例阈值 = 50%

10% < 50%，不会熔断 ✓
更合理！

配置建议：
// 替代旧的平均RT熔断
DegradeRule rule = new DegradeRule("service")
    .setGrade(RuleConstant.DEGRADE_GRADE_RT)
    .setCount(1000)              // RT阈值1秒
    .setSlowRatioThreshold(0.8)  // 80%慢调用才熔断
    .setMinRequestAmount(10)
    .setStatIntervalMs(10000)
    .setTimeWindow(5);

效果：
只有当80%以上的请求都超过1秒时，才触发熔断
避免了个别慢请求导致的误判
```

### 5.4 RT性能监控实践


**📈 如何监控和设置合理的RT阈值**：

```
步骤1：收集基线数据
────────────────────────────
方法：
• 使用APM工具（SkyWalking、Zipkin）
• 查看Sentinel控制台实时数据
• 分析日志中的响应时间

收集指标：
• 正常情况下的P95、P99
• 高峰期的响应时间
• 最慢请求的耗时

示例数据：
服务：订单查询
P50: 50ms
P95: 200ms
P99: 500ms
最大: 2000ms

步骤2：设置合理阈值
────────────────────────────
原则：
RT阈值 = P99 × 2-3倍

示例计算：
P99 = 500ms
RT阈值 = 500 × 2 = 1000ms

慢调用比例阈值：
• 严格：30-50%
• 宽松：60-80%
• 建议：50%

最终配置：
.setCount(1000)              // 1秒算慢
.setSlowRatioThreshold(0.5)  // 50%慢就熔断
.setMinRequestAmount(20)     // 20次请求才判断
.setStatIntervalMs(10000)    // 统计10秒
.setTimeWindow(10)           // 熔断10秒

步骤3：观察和调优
────────────────────────────
监控指标：
• 熔断触发频率
• 熔断期间的业务影响
• 恢复后的表现

调优方向：
• RT阈值太小 → 频繁误判 → 增大阈值
• RT阈值太大 → 保护不及时 → 减小阈值
• 比例太低 → 过于敏感 → 提高比例
• 比例太高 → 保护不足 → 降低比例
```

---

## 6. 🎯 熔断策略选择指南


### 6.1 决策树


**📊 如何选择合适的熔断策略**：

```
选择熔断策略决策流程：

开始
  ↓
问题表现是什么？
  ├→ 响应慢但不报错
  │    ↓
  │  使用【慢调用比例】
  │  • 关注RT和比例
  │  • 适合性能问题
  │
  ├→ 频繁抛异常
  │    ↓
  │  流量大小？
  │  ├→ 低流量 (<100 QPS)
  │  │    ↓
  │  │  使用【异常比例】
  │  │  • 关注百分比
  │  │  • 小样本下更准确
  │  │
  │  └→ 高流量 (>1000 QPS)
  │       ↓
  │     使用【异常数】
  │     • 关注绝对数量
  │     • 防止故障累积
  │
  └→ 同时有慢又有异常
       ↓
     组合使用多个策略
     • 慢调用比例 + 异常比例
     • 分别配置不同规则
```

### 6.2 场景匹配矩阵


**🔍 不同场景的策略选择**：

| 场景类型 | **问题特征** | **推荐策略** | **配置要点** |
|---------|------------|-------------|-------------|
| **数据库慢查询** | `响应时间长` `不报错` | `慢调用比例` | `RT=2s, 比例50%` |
| **第三方API故障** | `超时+异常` | `慢调用比例+异常比例` | `RT=3s, 异常比例30%` |
| **缓存雪崩** | `大量异常` | `异常数` | `异常数=500, 窗口60s` |
| **系统过载** | `响应慢` `偶尔异常` | `慢调用比例` | `RT=1s, 比例60%` |
| **网络抖动** | `间歇性超时` | `慢调用比例` | `RT=2s, 比例40%` |
| **业务高峰** | `整体变慢` | `慢调用比例` | `RT动态调整` |

### 6.3 组合策略实践


**⚙️ 多策略配合使用**：

```java
// 场景：支付服务保护
// 问题：既要防止慢调用，又要防止异常累积

// 策略1：慢调用比例熔断
DegradeRule slowRule = new DegradeRule("paymentService")
    .setGrade(RuleConstant.DEGRADE_GRADE_RT)
    .setCount(2000)              // 支付接口2秒算慢
    .setSlowRatioThreshold(0.4)  // 40%慢就保护
    .setMinRequestAmount(10)
    .setStatIntervalMs(10000)
    .setTimeWindow(20);          // 熔断20秒

// 策略2：异常比例熔断  
DegradeRule exceptionRule = new DegradeRule("paymentService")
    .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO)
    .setCount(0.3)               // 30%异常就熔断
    .setMinRequestAmount(10)
    .setStatIntervalMs(10000)
    .setTimeWindow(30);          // 熔断30秒

// 策略3：异常数熔断（高峰期保护）
DegradeRule countRule = new DegradeRule("paymentService")
    .setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT)
    .setCount(100)               // 1分钟100次异常
    .setStatIntervalMs(60000)
    .setTimeWindow(60);          // 熔断1分钟

// 同时加载所有规则
DegradeRuleManager.loadRules(Arrays.asList(
    slowRule, exceptionRule, countRule
));
```

**🔄 多策略工作机制**：

```
多个规则如何协同工作：

触发逻辑：
任意一个规则触发 → 整体熔断

优先级：
没有优先级，独立判断
每个规则都在监控
第一个达到阈值的规则触发熔断

实际运行示例：
──────────────────────────────────
时刻1：14:00:00
慢调用比例：30%  ← 未达阈值(40%)
异常比例：  20%  ← 未达阈值(30%)
异常数：    50次 ← 未达阈值(100次)
状态：关闭 ✓

时刻2：14:00:30  
慢调用比例：45%  ← 达到阈值！
异常比例：  25%  ← 未达阈值
异常数：    80次 ← 未达阈值
状态：开启（慢调用规则触发）✗

时刻3：14:00:50 (熔断中)
所有请求快速失败
返回降级结果

时刻4：14:01:10 (20秒后)
慢调用规则：进入半开状态
尝试放行探测请求
──────────────────────────────────

设计思路：
• 不同角度监控（慢、异常比例、异常数）
• 互为补充，形成立体防护
• 任一维度发现问题都能保护
```

---

## 7. 🔧 触发条件深度解析


### 7.1 触发条件的完整判断逻辑


**📐 熔断触发的完整条件**：

```
熔断器触发需要同时满足：

条件① 请求数量满足
───────────────────
当前请求数 ≥ minRequestAmount

说明：
避免样本太小导致误判
例如：只有1次请求就异常，不应该熔断

示例：
minRequestAmount = 10
当前请求：5次
结果：不检查熔断条件 ✗

条件② 统计指标超过阈值  
───────────────────
根据不同策略判断：

慢调用比例：
慢调用数/总请求数 ≥ slowRatioThreshold

异常比例：
异常数/总请求数 ≥ exceptionRatio

异常数：
异常数 ≥ count

条件③ 在统计窗口内
───────────────────
当前时间 - 统计开始时间 ≤ statIntervalMs

说明：
只统计时间窗口内的数据
超出窗口的数据会被丢弃

完整判断公式：
───────────────────
触发熔断 = (请求数 ≥ 最小请求数) 
         AND (指标值 ≥ 阈值) 
         AND (在统计窗口内)
```

### 7.2 时间窗口详解


**⏰ 时间窗口的工作原理**：

```
统计窗口 (statIntervalMs)：

作用：确定统计数据的时间范围

滑动窗口机制：
────────────────────────────────────
窗口大小：10秒
当前时间：14:30:00

统计范围：14:29:50 ~ 14:30:00
  ↓
只统计这10秒内的请求

1秒后 (14:30:01)：
统计范围：14:29:51 ~ 14:30:01
  ↓
窗口向前滑动1秒

实现原理：
┌─────────────────────────────────┐
│ 14:29:50 → 14:30:00 (10秒窗口)  │
│   ↓                              │
│  旧数据被丢弃，新数据加入         │
│   ↓                              │
│ 14:29:51 → 14:30:01 (窗口滑动)  │
└─────────────────────────────────┘

熔断窗口 (timeWindow)：

作用：确定熔断持续时间

固定窗口：
────────────────────────────────────
触发时间：14:30:00
熔断时长：10秒

熔断期间：14:30:00 ~ 14:30:10
  ↓
这10秒内所有请求被拒绝

14:30:10：
  ↓
进入半开状态，尝试恢复

注意：是固定时长，不是滑动的
```

### 7.3 最小请求数的重要性


**🎯 为什么需要最小请求数**：

```
问题场景：

场景1：样本太小导致误判
───────────────────────────
异常比例阈值：50%
最小请求数：2

只有2次请求：
请求1：成功 ✓
请求2：失败 ✗

异常比例：1/2 = 50% ≥ 50%
触发熔断！

问题：
样本太小，不能代表真实情况
可能就是偶然的1次失败

场景2：设置合理的最小请求数
───────────────────────────
异常比例阈值：50%
最小请求数：20

只有2次请求：
请求1：成功 ✓  
请求2：失败 ✗

异常比例：1/2 = 50%
但请求数(2) < 最小请求数(20)
不触发熔断 ✓

当有20次请求后：
请求总数：20次
异常数：10次
异常比例：10/20 = 50%
请求数(20) ≥ 最小请求数(20)
触发熔断 ✓

样本足够大，判断更准确

最小请求数设置建议：
───────────────────────────
低流量服务 (<10 QPS)：5-10次
中流量服务 (10-100 QPS)：10-20次  
高流量服务 (>100 QPS)：20-50次

原则：
• 太小：容易误判
• 太大：保护不及时
• 建议：约等于2-5秒的请求量
```

### 7.4 实际触发案例分析


**📊 完整触发过程演示**：

```
案例：订单服务熔断

配置参数：
───────────────────────────
策略：慢调用比例
RT阈值：1000ms
慢调用比例：50%
最小请求数：10
统计周期：10秒
熔断时长：5秒

时间线分析：
───────────────────────────
14:30:00 - 14:30:10 (统计周期开始)

秒数  请求   RT    是否慢调用  累计情况
─────────────────────────────────────
1s    3次   800ms    否       总数:3  慢:0
2s    2次   1200ms   是       总数:5  慢:2
3s    4次   600ms    否       总数:9  慢:2
4s    2次   1500ms   是       总数:11 慢:4
                              ↓
                         请求数达到10！
                         慢调用:4次
                         比例:4/11=36%
                         36% < 50% ✓
                         继续观察...

5s    3次   1100ms   是       总数:14 慢:7
                              ↓
                         慢调用:7次  
                         比例:7/14=50%
                         50% ≥ 50% ✗
                         触发熔断！

14:30:05 - 14:30:10 (熔断期间)
───────────────────────────
所有请求：
请求1 → 快速失败，返回降级
请求2 → 快速失败，返回降级
...
(不再调用实际服务)

14:30:10 (5秒后)
───────────────────────────
进入半开状态
放行1个探测请求：
  ↓
成功(RT=500ms) → 关闭熔断 ✓
失败(RT=1200ms) → 继续熔断 ✗
```

---

## 8. 📋 核心要点总结


### 8.1 四种熔断策略对比


```
┌─────────────────────────────────────────────┐
│ 策略类型 │  判断依据  │  适用场景  │ 关键参数 │
├─────────────────────────────────────────────┤
│ 慢调用   │ RT+比例    │ 响应慢     │ RT阈值   │
│ 比例     │            │ 性能问题   │ 比例阈值 │
├─────────────────────────────────────────────┤
│ 异常     │ 异常占比   │ 服务不稳定 │ 异常比例 │
│ 比例     │            │ 低流量场景 │          │
├─────────────────────────────────────────────┤
│ 异常     │ 异常总数   │ 高流量场景 │ 异常数量 │
│ 数量     │            │ 绝对数保护 │          │
├─────────────────────────────────────────────┤
│ RT       │ 平均RT     │ 已被慢调用 │ -        │
│ (旧)     │            │ 比例替代   │          │
└─────────────────────────────────────────────┘
```

### 8.2 配置参数速查


**🔍 关键参数一览**：

```
通用参数：
├─ grade: 熔断策略类型
├─ count: 阈值（含义因策略而异）
├─ minRequestAmount: 最小请求数（默认5）
├─ statIntervalMs: 统计周期（默认1000ms）
└─ timeWindow: 熔断时长（秒）

策略特定参数：
慢调用比例：
└─ slowRatioThreshold: 慢调用比例阈值

异常比例：
└─ count作为比例值 (0.0-1.0)

异常数：
└─ count作为次数值

快速配置模板：
───────────────────────────
// 慢调用配置
.setGrade(DEGRADE_GRADE_RT)
.setCount(1000)              // 1秒
.setSlowRatioThreshold(0.5)  // 50%
.setMinRequestAmount(10)
.setTimeWindow(10)

// 异常比例配置
.setGrade(DEGRADE_GRADE_EXCEPTION_RATIO)
.setCount(0.3)               // 30%
.setMinRequestAmount(10)
.setTimeWindow(10)

// 异常数配置  
.setGrade(DEGRADE_GRADE_EXCEPTION_COUNT)
.setCount(50)                // 50次
.setStatIntervalMs(60000)    // 1分钟
.setTimeWindow(30)
```

### 8.3 选择决策快速指南


**⚡ 快速选择策略**：

```
第1步：识别问题类型
───────────────────
响应慢 → 慢调用比例
频繁异常 → 看流量
  ├─ 低流量 → 异常比例
  └─ 高流量 → 异常数

第2步：设置阈值
───────────────────
慢调用RT：正常RT × 2-3倍
慢调用比例：建议50%
异常比例：建议30-50%
异常数：根据QPS设定

第3步：调优验证
───────────────────
观察指标：
• 熔断频率
• 误判情况  
• 业务影响

调整方向：
• 频繁误判 → 放宽阈值
• 保护不足 → 收紧阈值
• 恢复太慢 → 减少熔断时长
• 恢复太快 → 增加熔断时长
```

### 8.4 最佳实践建议


**💡 使用建议**：

```
1. 组合使用策略
   • 慢调用 + 异常比例
   • 多维度保护更可靠

2. 合理设置最小请求数
   • 避免小样本误判
   • 根据QPS调整

3. 区分业务异常和系统异常
   • 业务异常不触发熔断
   • 系统异常才需要保护

4. 监控和告警
   • 记录熔断日志
   • 配置熔断告警
   • 定期分析数据

5. 降级方案准备
   • 提供友好的降级响应
   • 不要返回空或错误
   • 保证用户体验

6. 测试验证
   • 压测验证阈值设置
   • 模拟故障测试熔断
   • 验证恢复机制
```

**🎯 记忆要点**：
- 熔断是保险丝，自动保护系统
- 三种状态：关闭、开启、半开
- 四种策略：慢调用、异常比例、异常数、RT(已废弃)
- 触发条件：请求数+指标值+时间窗口
- 关键是选对策略，设好阈值
- 多策略组合，立体防护更可靠

**核心理念**：熔断不是目的，而是手段。目标是在故障发生时快速失败，保护系统整体稳定，然后尽快恢复服务。合理配置熔断规则，就像给系统装上了智能保险丝！