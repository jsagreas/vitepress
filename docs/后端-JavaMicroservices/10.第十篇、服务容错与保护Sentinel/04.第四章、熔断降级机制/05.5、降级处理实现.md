---
title: 5、降级处理实现
---
## 📚 目录

1. [服务降级是什么](#1-服务降级是什么)
2. [降级处理的两种方式](#2-降级处理的两种方式)
3. [blockHandler降级处理](#3-blockHandler降级处理)
4. [fallback降级处理](#4-fallback降级处理)
5. [自定义降级逻辑](#5-自定义降级逻辑)
6. [降级的最佳实践](#6-降级的最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 服务降级是什么


### 1.1 通俗理解服务降级


**🔸 生活中的例子**
```
想象你去银行办业务：

正常情况：
你 → 柜台办理业务 → 完成

高峰期降级：
你 → 柜台繁忙 → 引导你用ATM机 → 完成基本业务
               （降级方案）    （简化但可用）

这就是降级！当主要服务忙不过来时，提供一个备用方案
虽然功能简化了，但至少能用，不至于完全瘫痪
```

### 1.2 微服务中的降级


**💡 核心概念**
```
服务降级 = 当服务出问题时，提供备用处理方案

出问题的情况：
• 服务被限流了（太多请求）
• 服务调用失败了（超时、异常）
• 服务熔断了（错误太多）

降级的目的：
✅ 保证用户体验：至少给个反馈，不能白屏
✅ 防止雪崩：一个服务挂了，不能拖垮整个系统
✅ 快速响应：不要让用户一直等待
```

**🎯 降级 vs 限流 vs 熔断**
```
限流：控制进入的流量（像景区限流）
熔断：服务故障时暂时停止调用（像电路断路器）
降级：提供备用方案（像备用电源）

三者关系：
限流 → 防止过载 → 如果还是有问题 → 熔断保护 → 降级兜底
```

---

## 2. 🔧 降级处理的两种方式


### 2.1 Sentinel提供的两种降级机制


| 降级方式 | 触发场景 | 使用场景 | 优先级 |
|---------|---------|---------|--------|
| **blockHandler** | 被Sentinel规则拦截 | 限流、熔断等主动保护 | 高 |
| **fallback** | 业务代码抛异常 | 调用失败、超时等被动应对 | 低 |

**🔸 两者的区别（重要！）**
```
blockHandler：
• Sentinel主动拦截（我不让你调用）
• 场景：达到限流阈值、触发熔断规则
• 说人话：守门员说"人太多了，你别进了"

fallback：
• 代码执行出错（调用失败了）
• 场景：网络超时、服务异常、业务报错
• 说人话：进去了但没办成事，给你个备用方案

形象理解：
blockHandler = 门卫拦截（门都没进）
fallback = 进去后办砸了（进去了但失败）
```

### 2.2 两种方式的处理流程


```
请求到来
   ↓
【Sentinel规则检查】
   ↓
命中规则？
   ├── 是 → blockHandler处理 → 返回降级结果
   └── 否 → 执行业务代码
              ↓
           代码执行
              ↓
           出异常？
              ├── 是 → fallback处理 → 返回降级结果
              └── 否 → 正常返回结果
```

---

## 3. 🛡️ blockHandler降级处理


### 3.1 什么是blockHandler


**🔸 核心理解**
```
blockHandler = Sentinel规则拦截后的处理方法

触发时机：
• 达到限流阈值
• 触发熔断降级
• 系统保护规则生效
• 热点参数限流

说人话：
就像银行门口的保安，人太多时会说
"对不起，现在业务繁忙，请稍后再试"
这个"对不起，请稍后再试"就是blockHandler要做的事
```

### 3.2 blockHandler使用方法


**💻 基础示例**
```java
@Service
public class OrderService {
    
    // 1. 主方法：正常的业务逻辑
    @SentinelResource(
        value = "createOrder",           // 资源名称
        blockHandler = "handleBlock"     // 指定降级方法
    )
    public String createOrder(String userId) {
        // 正常创建订单的逻辑
        return "订单创建成功：" + userId;
    }
    
    // 2. 降级方法：被限流时调用
    // 注意：必须和主方法在同一个类中
    public String handleBlock(String userId, BlockException ex) {
        // 给用户友好的提示
        return "系统繁忙，请稍后重试";
    }
}
```

**🔑 blockHandler方法要求（重要！）**
```
必须满足的条件：
✅ 返回值类型必须和原方法一样
✅ 参数列表 = 原方法参数 + BlockException
✅ 必须是public方法
✅ 默认要在同一个类中

示例对照：
原方法：   String createOrder(String userId)
降级方法： String handleBlock(String userId, BlockException ex)
                                          ↑
                                   多了这个异常参数
```

### 3.3 blockHandler实际应用


**🎯 场景1：商品秒杀限流**
```java
@Service
public class SeckillService {
    
    @SentinelResource(
        value = "seckill",
        blockHandler = "seckillBlockHandler"
    )
    public String seckill(String productId) {
        // 执行秒杀逻辑
        return "秒杀成功";
    }
    
    // 限流后的友好提示
    public String seckillBlockHandler(String productId, BlockException ex) {
        return "商品太火爆了！请稍后再试";
    }
}
```

**🎯 场景2：查询接口限流**
```java
@RestController
public class ProductController {
    
    @GetMapping("/product/{id}")
    @SentinelResource(
        value = "getProduct",
        blockHandler = "getProductBlock"
    )
    public Product getProduct(@PathVariable String id) {
        // 查询商品详情
        return productService.findById(id);
    }
    
    // 返回缓存数据或默认数据
    public Product getProductBlock(String id, BlockException ex) {
        // 可以返回缓存数据
        Product defaultProduct = new Product();
        defaultProduct.setName("商品加载中...");
        return defaultProduct;
    }
}
```

---

## 4. 🔄 fallback降级处理


### 4.1 什么是fallback


**🔸 核心理解**
```
fallback = 业务代码出错后的兜底方案

触发时机：
• 远程调用超时
• 网络异常
• 业务异常（空指针、数据库异常等）
• 任何运行时异常

说人话：
就像你点外卖，骑手路上出了问题送不了
商家说"给您退款或换个菜"
这个补救措施就是fallback
```

### 4.2 fallback使用方法


**💻 基础示例**
```java
@Service
public class UserService {
    
    @Autowired
    private RemoteUserService remoteUserService;
    
    // 1. 主方法：调用远程服务
    @SentinelResource(
        value = "getUser",
        fallback = "getUserFallback"  // 指定兜底方法
    )
    public User getUser(String userId) {
        // 调用远程服务（可能失败）
        return remoteUserService.getUserById(userId);
    }
    
    // 2. 兜底方法：调用失败时的处理
    public User getUserFallback(String userId, Throwable ex) {
        // 返回默认用户信息
        User defaultUser = new User();
        defaultUser.setId(userId);
        defaultUser.setName("游客");
        return defaultUser;
    }
}
```

**🔑 fallback方法要求**
```
必须满足的条件：
✅ 返回值类型必须和原方法一样
✅ 参数列表 = 原方法参数 + Throwable（可选）
✅ 必须是public方法

对比blockHandler：
blockHandler：参数必须加 BlockException
fallback：    参数可以加 Throwable（更通用的异常）
```

### 4.3 fallback实际应用


**🎯 场景1：用户信息查询**
```java
@Service
public class UserService {
    
    @SentinelResource(
        value = "getUserInfo",
        fallback = "getUserInfoFallback"
    )
    public UserInfo getUserInfo(String userId) {
        // 调用用户服务（可能超时）
        return userClient.getInfo(userId);
    }
    
    // 返回本地缓存或默认信息
    public UserInfo getUserInfoFallback(String userId, Throwable ex) {
        // 1. 先尝试从本地缓存获取
        UserInfo cached = cache.get(userId);
        if (cached != null) {
            return cached;
        }
        
        // 2. 返回默认信息
        UserInfo defaultInfo = new UserInfo();
        defaultInfo.setNickname("用户" + userId);
        defaultInfo.setAvatar("default.jpg");
        return defaultInfo;
    }
}
```

**🎯 场景2：订单查询降级**
```java
@Service
public class OrderService {
    
    @SentinelResource(
        value = "queryOrder",
        fallback = "queryOrderFallback"
    )
    public Order queryOrder(String orderId) {
        // 查询订单（可能数据库异常）
        return orderMapper.selectById(orderId);
    }
    
    // 降级处理
    public Order queryOrderFallback(String orderId, Throwable ex) {
        // 记录日志
        log.error("订单查询失败：{}", orderId, ex);
        
        // 返回友好提示
        Order errorOrder = new Order();
        errorOrder.setStatus("查询失败，请稍后重试");
        return errorOrder;
    }
}
```

---

## 5. 🎨 自定义降级逻辑


### 5.1 blockHandler和fallback同时使用


**💡 两者可以配合使用**
```java
@Service
public class PaymentService {
    
    @SentinelResource(
        value = "pay",
        blockHandler = "payBlockHandler",  // 限流降级
        fallback = "payFallback"           // 异常降级
    )
    public String pay(String orderId, BigDecimal amount) {
        // 执行支付
        return paymentClient.doPay(orderId, amount);
    }
    
    // 处理限流情况
    public String payBlockHandler(String orderId, BigDecimal amount, 
                                  BlockException ex) {
        return "支付人数过多，请稍后重试";
    }
    
    // 处理调用失败
    public String payFallback(String orderId, BigDecimal amount, 
                              Throwable ex) {
        return "支付失败，请检查网络或联系客服";
    }
}
```

**🔸 执行优先级**
```
请求流程：
1. 先检查Sentinel规则
   ├── 命中规则 → 执行blockHandler
   └── 未命中 → 继续

2. 执行业务代码
   ├── 抛出异常 → 执行fallback
   └── 正常执行 → 返回结果

记忆口诀：
"先看门卫（block），再看结果（fall）"
```

### 5.2 使用外部类管理降级方法


**🔧 为什么要用外部类？**
```
问题：降级方法和业务代码混在一起，代码很乱

解决：把降级方法统一放到一个类中管理

好处：
✅ 代码更清晰
✅ 降级逻辑可复用
✅ 便于统一管理
```

**💻 外部类示例**
```java
// 1. 创建降级处理类
public class OrderFallbackHandler {
    
    // 创建订单的降级处理
    public static String createOrderFallback(String userId, Throwable ex) {
        return "订单创建失败，请稍后重试";
    }
    
    // 查询订单的降级处理
    public static Order queryOrderFallback(String orderId, Throwable ex) {
        Order order = new Order();
        order.setStatus("查询失败");
        return order;
    }
}

// 2. 在业务代码中引用
@Service
public class OrderService {
    
    @SentinelResource(
        value = "createOrder",
        fallbackClass = OrderFallbackHandler.class,  // 指定外部类
        fallback = "createOrderFallback"              // 指定方法名
    )
    public String createOrder(String userId) {
        return "订单创建成功";
    }
}
```

**⚠️ 外部类方法要求**
```
必须满足：
✅ 方法必须是 static（静态方法）
✅ 方法必须是 public
✅ 参数和返回值要匹配

为什么要static？
因为Sentinel不会创建类的实例，直接调用静态方法更高效
```

### 5.3 降级方法的最佳实践


**📋 设计降级逻辑的原则**
```
1. 快速返回
   ❌ 不要：在降级方法里再调用其他服务
   ✅ 要做：直接返回默认值或提示信息

2. 用户友好
   ❌ 不要：返回"系统异常"、"500错误"
   ✅ 要做：返回"服务繁忙，请稍后重试"

3. 记录日志
   ✅ 记录降级原因，便于排查问题
   ✅ 记录关键参数，便于重现问题

4. 数据安全
   ✅ 涉及金钱的操作：宁可失败，不能错误
   ✅ 涉及数据的操作：保证数据一致性
```

**💻 完整的降级处理示例**
```java
@Service
@Slf4j
public class PaymentService {
    
    @SentinelResource(
        value = "payment",
        blockHandler = "paymentBlock",
        fallback = "paymentFallback"
    )
    public PayResult payment(PayRequest request) {
        // 执行支付
        return paymentClient.pay(request);
    }
    
    // 限流降级
    public PayResult paymentBlock(PayRequest request, BlockException ex) {
        log.warn("支付被限流，订单号：{}", request.getOrderId());
        
        PayResult result = new PayResult();
        result.setSuccess(false);
        result.setMessage("当前支付人数过多，请稍后重试");
        return result;
    }
    
    // 异常降级
    public PayResult paymentFallback(PayRequest request, Throwable ex) {
        log.error("支付失败，订单号：{}", request.getOrderId(), ex);
        
        PayResult result = new PayResult();
        result.setSuccess(false);
        result.setMessage("支付失败，请重试或联系客服");
        
        // 如果是超时异常，提示可能成功
        if (ex instanceof TimeoutException) {
            result.setMessage("支付处理中，请勿重复提交");
        }
        
        return result;
    }
}
```

---

## 6. 🚀 降级的最佳实践


### 6.1 不同场景的降级策略


**📊 降级策略对照表**

| 业务场景 | 降级策略 | 返回内容 | 示例 |
|---------|---------|---------|------|
| 🛒 商品查询 | 返回缓存数据 | 稍旧但可用的数据 | 10分钟前的商品信息 |
| 👤 用户信息 | 返回默认信息 | 基础的默认数据 | 默认头像+昵称 |
| 💰 支付接口 | 明确失败提示 | 清晰的错误说明 | "支付失败，请重试" |
| 📝 下单接口 | 记录后异步处理 | 提示已接收 | "订单已提交，处理中" |
| 📊 统计数据 | 返回预估值 | 近似数据 | "约1000人在线" |

### 6.2 降级处理的注意事项


**⚠️ 常见问题和解决方案**

```
问题1：降级方法和原方法参数不匹配
❌ 错误示例：
原方法： String create(String id, Integer count)
降级方法：String createFallback(String id)  // 少了count参数

✅ 正确示例：
降级方法：String createFallback(String id, Integer count, Throwable ex)

---

问题2：降级方法不是public
❌ 错误示例：
private String fallback(String id, Throwable ex) { }

✅ 正确示例：
public String fallback(String id, Throwable ex) { }

---

问题3：降级方法里又调用其他服务
❌ 错误示例：
public String fallback(String id, Throwable ex) {
    return otherService.query(id);  // 可能再次失败！
}

✅ 正确示例：
public String fallback(String id, Throwable ex) {
    return "默认值";  // 直接返回
}
```

### 6.3 监控和优化


**📈 降级效果监控**
```
需要关注的指标：

1. 降级触发次数
   • 看哪个接口降级最频繁
   • 分析是否需要扩容或优化

2. 降级原因分布
   • 限流导致的降级占比
   • 异常导致的降级占比

3. 用户体验影响
   • 降级后的成功率
   • 用户重试率
   • 投诉率变化

优化方向：
✅ 降级频繁 → 考虑提高限流阈值
✅ 异常多 → 优化下游服务稳定性
✅ 用户体验差 → 改进降级返回内容
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 服务降级 = 出问题时的备用方案
🔸 blockHandler = Sentinel拦截后的处理（门卫挡住）
🔸 fallback = 代码异常后的处理（进去后失败）
🔸 降级目的 = 保证体验 + 防止雪崩 + 快速响应
```

### 7.2 关键知识点对比


**🔹 两种降级方式的区别**
```
blockHandler：
• 触发：Sentinel规则命中（限流、熔断）
• 参数：必须有BlockException
• 场景：主动保护，预防性降级

fallback：
• 触发：代码抛异常（超时、错误）
• 参数：可以有Throwable
• 场景：被动应对，补救性降级

优先级：blockHandler > fallback
```

**🔹 方法定义要求**
```
✅ 返回值：必须和原方法一致
✅ 参数：原方法参数 + 异常参数
✅ 访问权限：必须public
✅ 位置：默认同类，可用外部类（需static）
```

### 7.3 实战应用要点


**💡 降级设计原则**
```
1️⃣ 快速返回
   不要在降级方法里做复杂操作

2️⃣ 用户友好  
   给用户看得懂的提示信息

3️⃣ 记录日志
   方便排查问题和优化

4️⃣ 数据安全
   重要操作宁可失败不能出错
```

**🎯 最佳实践检查清单**
```
✅ 每个关键接口都配置了降级方法
✅ 降级返回的信息对用户友好
✅ 降级方法不会再次调用可能失败的服务
✅ 重要操作有明确的失败提示
✅ 降级触发时有日志记录
✅ 定期检查降级触发频率
```

**🔑 记忆口诀**
```
"降级就是留后路，
门卫挡住用block，
进去失败用fall，
快速友好最重要！"
```

---

**🎓 学习建议**
- 先理解blockHandler和fallback的区别
- 从简单示例开始练习
- 注意方法签名的要求
- 实际项目中逐步应用
- 关注降级效果和用户反馈