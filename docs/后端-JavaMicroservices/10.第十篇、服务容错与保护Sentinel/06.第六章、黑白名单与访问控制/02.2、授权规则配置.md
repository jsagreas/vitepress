---
title: 2、授权规则配置
---
## 📚 目录

1. [访问控制基础概念](#1-访问控制基础概念)
2. [授权规则配置详解](#2-授权规则配置详解)
3. [黑白名单实战应用](#3-黑白名单实战应用)
4. [动态配置与管理](#4-动态配置与管理)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🔐 访问控制基础概念


### 1.1 什么是访问控制


**简单理解**：就像小区门禁一样，决定谁能进、谁不能进

```
现实场景类比：
小区门禁系统：
✅ 白名单模式：只允许业主和已登记访客进入
❌ 黑名单模式：禁止小广告、推销员等人员进入

微服务中的访问控制：
✅ 白名单：只允许指定的应用访问我的服务
❌ 黑名单：禁止某些恶意应用访问我的服务
```

**核心作用**：
- **安全防护**：保护服务不被非法访问
- **流量管控**：控制哪些应用可以调用服务
- **资源隔离**：不同应用访问不同的服务资源
- **故障隔离**：隔离有问题的调用方

### 1.2 为什么需要访问控制


**常见问题场景**：

```
问题1：服务被恶意调用
场景：订单服务被未知应用频繁调用，消耗资源
解决：设置白名单，只允许购物车、支付等合法应用调用

问题2：某个应用有问题影响整体
场景：应用A有bug频繁调用失败，影响服务性能
解决：将应用A加入黑名单，暂时禁止其访问

问题3：灰度发布需要隔离流量
场景：新版本应用需要小范围测试
解决：白名单只对测试应用开放新功能
```

### 1.3 访问控制的两种策略


**策略对比**：

| 策略类型 | **工作方式** | **适用场景** | **举例** |
|---------|------------|-------------|---------|
| **白名单** | 只允许名单内的访问 | 安全要求高的核心服务 | 只允许官方APP调用支付接口 |
| **黑名单** | 禁止名单内的访问 | 需要屏蔽特定来源 | 禁止某个有bug的应用调用 |

```
白名单工作流程：
请求进来 → 检查是否在白名单 → 在名单内：允许访问
                              → 不在名单内：拒绝访问

黑名单工作流程：
请求进来 → 检查是否在黑名单 → 在名单内：拒绝访问
                              → 不在名单内：允许访问
```

---

## 2. 📋 授权规则配置详解


### 2.1 AuthorityRule 核心概念


**AuthorityRule（授权规则）**：Sentinel用来控制访问权限的规则对象

**核心属性解析**：

```java
// 创建一个授权规则
AuthorityRule rule = new AuthorityRule();

// 1. 资源名称 - 要保护的是哪个接口
rule.setResource("orderService");  // 保护订单服务

// 2. 限流应用 - 针对哪些应用进行控制
rule.setLimitApp("app1,app2");     // 针对app1和app2两个应用

// 3. 策略类型 - 白名单还是黑名单
rule.setStrategy(RuleConstant.AUTHORITY_WHITE);  // 白名单模式
// rule.setStrategy(RuleConstant.AUTHORITY_BLACK); // 黑名单模式
```

**属性详细说明**：

🔸 **resource（资源名称）**
```
含义：要保护的服务接口或资源
示例：
- "orderService" - 订单服务
- "getUserInfo" - 获取用户信息接口
- "/api/payment" - 支付API路径

理解：就像给门禁系统指定"保护哪个门"
```

🔸 **limitApp（限流应用）**
```
含义：要进行访问控制的应用列表
格式：多个应用用逗号分隔
示例：
- "app1" - 单个应用
- "app1,app2,app3" - 多个应用

理解：就像指定"哪些人/应用"受门禁管控
```

🔸 **strategy（策略类型）**
```
两种策略值：
AUTHORITY_WHITE = 0  → 白名单模式
AUTHORITY_BLACK = 1  → 黑名单模式

理解：
白名单：只有名单上的能进（默认拒绝）
黑名单：名单上的不能进（默认允许）
```

### 2.2 白名单配置实战


**场景**：订单服务只允许购物车和支付应用调用

```java
// 第一步：创建白名单规则
AuthorityRule whiteRule = new AuthorityRule();
whiteRule.setResource("createOrder");          // 保护创建订单接口
whiteRule.setLimitApp("cart-service,pay-service"); // 只允许购物车和支付服务
whiteRule.setStrategy(RuleConstant.AUTHORITY_WHITE); // 使用白名单

// 第二步：加载规则
AuthorityRuleManager.loadRules(Collections.singletonList(whiteRule));
```

**工作流程演示**：

```
场景1：购物车服务调用
cart-service → createOrder接口
检查：cart-service在白名单中 ✅
结果：允许访问

场景2：未知应用调用  
unknown-app → createOrder接口
检查：unknown-app不在白名单中 ❌
结果：拒绝访问，抛出AuthorityException

场景3：支付服务调用
pay-service → createOrder接口  
检查：pay-service在白名单中 ✅
结果：允许访问
```

### 2.3 黑名单配置实战


**场景**：发现某个应用有bug，需要临时禁止它访问

```java
// 创建黑名单规则
AuthorityRule blackRule = new AuthorityRule();
blackRule.setResource("queryOrder");           // 保护查询订单接口
blackRule.setLimitApp("buggy-app");            // 禁止有问题的应用
blackRule.setStrategy(RuleConstant.AUTHORITY_BLACK); // 使用黑名单

// 加载规则
AuthorityRuleManager.loadRules(Collections.singletonList(blackRule));
```

**工作流程演示**：

```
场景1：正常应用调用
normal-app → queryOrder接口
检查：normal-app不在黑名单中 ✅
结果：允许访问

场景2：有问题的应用调用
buggy-app → queryOrder接口
检查：buggy-app在黑名单中 ❌  
结果：拒绝访问，保护服务

场景3：其他应用调用
other-app → queryOrder接口
检查：other-app不在黑名单中 ✅
结果：允许访问
```

### 2.4 应用名称的获取


**关键问题**：Sentinel怎么知道是哪个应用在调用？

**获取方式**：

```
方式1：从HTTP请求头获取
请求头：X-App-Name: shopping-cart
Sentinel读取这个头部信息判断调用方

方式2：从Dubbo上下文获取  
RpcContext.getContext().getAttachment("application");
微服务框架自动传递应用名

方式3：自定义解析器
实现RequestOriginParser接口
public class MyOriginParser implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest request) {
        // 从token、cookie等获取应用标识
        return request.getHeader("app-id");
    }
}
```

**完整配置示例**：

```java
// 1. 注册应用来源解析器
WebCallbackManager.setRequestOriginParser(new RequestOriginParser() {
    @Override
    public String parseOrigin(HttpServletRequest request) {
        // 从请求头获取应用名称
        String appName = request.getHeader("X-App-Name");
        return appName != null ? appName : "unknown";
    }
});

// 2. 配置白名单规则
AuthorityRule rule = new AuthorityRule();
rule.setResource("payment");
rule.setLimitApp("app1,app2");  // 这里的名称就是parseOrigin返回的值
rule.setStrategy(RuleConstant.AUTHORITY_WHITE);
AuthorityRuleManager.loadRules(Collections.singletonList(rule));
```

---

## 3. 🎯 黑白名单实战应用


### 3.1 典型应用场景


**场景一：核心接口保护**

```
业务需求：支付接口只能被官方应用调用

实现方案：
AuthorityRule payRule = new AuthorityRule();
payRule.setResource("/api/pay");
payRule.setLimitApp("official-app,admin-app");  // 只允许官方和管理应用
payRule.setStrategy(RuleConstant.AUTHORITY_WHITE);

效果：其他任何应用调用支付接口都会被拦截
```

**场景二：故障应用隔离**

```
业务需求：某个应用频繁调用失败，需要临时屏蔽

实现方案：
AuthorityRule isolateRule = new AuthorityRule();
isolateRule.setResource("orderQuery");
isolateRule.setLimitApp("problematic-service");  // 有问题的服务
isolateRule.setStrategy(RuleConstant.AUTHORITY_BLACK);

效果：隔离问题应用，保护服务稳定性
```

**场景三：灰度发布控制**

```
业务需求：新功能只对测试应用开放

实现方案：
AuthorityRule grayRule = new AuthorityRule();
grayRule.setResource("newFeature");
grayRule.setLimitApp("test-app,beta-app");  // 测试应用白名单
grayRule.setStrategy(RuleConstant.AUTHORITY_WHITE);

效果：新功能只对指定应用可见，实现灰度发布
```

### 3.2 多规则组合使用


**需求**：对不同资源应用不同的访问控制策略

```java
// 规则1：支付接口使用白名单
AuthorityRule payRule = new AuthorityRule();
payRule.setResource("payment");
payRule.setLimitApp("app1,app2");
payRule.setStrategy(RuleConstant.AUTHORITY_WHITE);

// 规则2：查询接口使用黑名单
AuthorityRule queryRule = new AuthorityRule();
queryRule.setResource("query");
queryRule.setLimitApp("bad-app");
queryRule.setStrategy(RuleConstant.AUTHORITY_BLACK);

// 同时加载多个规则
List<AuthorityRule> rules = Arrays.asList(payRule, queryRule);
AuthorityRuleManager.loadRules(rules);
```

**工作效果**：

```
访问payment接口：
✅ app1调用 → 在白名单 → 允许
✅ app2调用 → 在白名单 → 允许  
❌ app3调用 → 不在白名单 → 拒绝

访问query接口：
✅ app1调用 → 不在黑名单 → 允许
❌ bad-app调用 → 在黑名单 → 拒绝
✅ app3调用 → 不在黑名单 → 允许
```

### 3.3 异常处理与降级


**被拒绝后的处理**：

```java
@RestController
public class OrderController {
    
    @GetMapping("/createOrder")
    public String createOrder() {
        try {
            // 业务逻辑
            Entry entry = SphU.entry("createOrder");
            // ... 执行订单创建
            entry.exit();
            return "订单创建成功";
            
        } catch (AuthorityException e) {
            // 被访问控制规则拦截
            return "您没有权限访问该服务";
            
        } catch (BlockException e) {
            // 其他限流、熔断等原因被拦截
            return "服务繁忙，请稍后重试";
        }
    }
}
```

**全局异常处理**：

```java
@ControllerAdvice
public class SentinelExceptionHandler {
    
    @ExceptionHandler(AuthorityException.class)
    public ResponseEntity<String> handleAuthority(AuthorityException e) {
        // 记录日志
        log.warn("访问被拒绝：{}", e.getMessage());
        
        // 返回友好提示
        return ResponseEntity
            .status(HttpStatus.FORBIDDEN)
            .body("您没有访问该资源的权限");
    }
}
```

---

## 4. 🔄 动态配置与管理


### 4.1 为什么需要动态配置


**问题场景**：

```
场景1：紧急封禁
某个应用突然异常，需要立即加入黑名单
如果代码写死 → 需要重新发版 → 太慢！

场景2：临时开放
活动期间需要临时开放某些接口权限
如果代码写死 → 活动结束还要再改一次 → 麻烦！

解决方案：动态配置
通过配置中心实时修改规则，无需重启服务
```

### 4.2 基于Nacos的动态配置


**配置流程**：

```
第一步：在Nacos创建配置
Data ID: sentinel-authority-rules
Group: DEFAULT_GROUP
配置格式: JSON

第二步：编写规则JSON
[
  {
    "resource": "orderService",
    "limitApp": "app1,app2",
    "strategy": 0
  },
  {
    "resource": "payService", 
    "limitApp": "bad-app",
    "strategy": 1
  }
]

第三步：服务监听配置变化
配置变更 → Sentinel自动加载 → 规则立即生效
```

**代码实现**：

```java
// 配置Nacos数据源
public void configureNacosDataSource() {
    // Nacos配置信息
    String serverAddr = "localhost:8848";
    String dataId = "sentinel-authority-rules";
    String groupId = "DEFAULT_GROUP";
    
    // 创建Nacos数据源
    ReadableDataSource<String, List<AuthorityRule>> dataSource = 
        new NacosDataSource<>(
            serverAddr, 
            groupId, 
            dataId,
            source -> JSON.parseArray(source, AuthorityRule.class)
        );
    
    // 注册到Sentinel
    AuthorityRuleManager.register2Property(dataSource.getProperty());
}
```

**动态调整示例**：

```
初始状态：
支付接口白名单：app1, app2

发现问题：app3也需要调用
操作：在Nacos控制台修改配置
[
  {
    "resource": "payment",
    "limitApp": "app1,app2,app3",  ← 新增app3
    "strategy": 0
  }
]

效果：保存后立即生效，无需重启
app3可以立即访问支付接口 ✅
```

### 4.3 配置管理最佳实践


**规则管理建议**：

```
1. 环境隔离
开发环境：dev-sentinel-rules
测试环境：test-sentinel-rules  
生产环境：prod-sentinel-rules

2. 规则版本控制
每次修改记录变更日志
保留历史版本便于回滚

3. 灰度发布规则
先在一台机器测试
确认无误后推广到集群

4. 监控与告警
监控规则变更事件
异常拦截量突增时告警
```

**配置示例（完整版）**：

```json
[
  {
    "resource": "orderService",
    "limitApp": "cart-service,user-service",
    "strategy": 0,
    "comment": "订单服务白名单-只允许购物车和用户服务调用"
  },
  {
    "resource": "adminAPI",
    "limitApp": "admin-app",
    "strategy": 0,
    "comment": "管理接口白名单-只允许管理后台"
  },
  {
    "resource": "publicAPI",
    "limitApp": "malicious-app,spam-bot",
    "strategy": 1,
    "comment": "公共接口黑名单-屏蔽恶意应用"
  }
]
```

---

## 5. 📋 核心要点总结


### 5.1 关键概念回顾


```
🔸 访问控制：控制哪些应用可以访问服务，类似门禁系统
🔸 AuthorityRule：授权规则对象，包含资源、应用、策略三要素
🔸 白名单：只允许名单内应用访问，默认拒绝（安全优先）
🔸 黑名单：禁止名单内应用访问，默认允许（开放优先）
🔸 动态配置：通过配置中心实时调整规则，无需重启
```

### 5.2 配置要点


**三要素记忆**：

```
Resource（资源）：
→ 保护什么？接口、方法、路径
→ 示例："orderService"、"/api/pay"

LimitApp（限流应用）：
→ 针对谁？应用名称列表
→ 示例："app1,app2"、"bad-app"

Strategy（策略）：
→ 怎么控制？白名单或黑名单
→ 0=白名单，1=黑名单
```

### 5.3 使用场景选择


| 场景 | **推荐策略** | **理由** |
|-----|------------|---------|
| 核心接口保护 | 白名单 | 安全性高，默认拒绝 |
| 临时屏蔽问题应用 | 黑名单 | 快速隔离，影响范围小 |
| 灰度发布 | 白名单 | 精确控制开放范围 |
| 公开API | 黑名单 | 保持开放，仅屏蔽恶意 |

### 5.4 实战建议


**开发阶段**：
- ✅ 先用代码配置规则，快速验证功能
- ✅ 测试白名单、黑名单不同场景
- ✅ 验证应用名称解析是否正确

**生产阶段**：
- ✅ 使用配置中心动态管理规则
- ✅ 建立规则变更审批流程  
- ✅ 监控拦截量，及时发现异常
- ✅ 保留规则变更历史，方便回滚

**故障处理**：
- ✅ 被拦截时提供清晰的错误提示
- ✅ 记录拦截日志，便于问题排查
- ✅ 提供降级方案，保证用户体验

**核心记忆口诀**：
```
访问控制三要素：资源、应用、策略定
白名单安全先：只放名单内，默认拦
黑名单够灵活：名单外放行，名单禁
动态配置是关键：实时调整无需停
```