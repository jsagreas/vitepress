---
title: 2、容错设计原则
---
## 📚 目录

1. [容错保护基础理论](#1-容错保护基础理论)
2. [微服务常见故障场景](#2-微服务常见故障场景)
3. [Sentinel核心概念](#3-Sentinel核心概念)
4. [核心要点总结](#4-核心要点总结)

---

## 1. 🛡️ 容错保护基础理论


### 1.1 什么是微服务容错？


> **通俗理解**：就像汽车的安全气囊，平时看不见，但关键时刻能救命。微服务容错就是给系统装上"安全气囊"，让服务出问题时不会导致整个系统崩溃。

**🔸 为什么需要容错？**

想象一个场景：你在电商网站下单，需要调用这些服务：

```
下单流程示意图：

用户下单
   ↓
订单服务 → 库存服务（检查库存）
   ↓          ↓
   ↓      商品服务（获取商品信息）
   ↓          ↓
支付服务 → 用户服务（获取用户信息）
   ↓
通知服务（发送短信）
```

如果**库存服务**突然响应很慢（比如数据库卡了），会发生什么？

```
❌ 没有容错保护的情况：
库存服务慢 → 订单服务等待 → 越来越多请求堆积 
→ 订单服务线程耗尽 → 订单服务崩溃 
→ 整个下单功能不可用 → 其他功能也受影响
这就是"雪崩效应"！
```

```
✅ 有容错保护的情况：
库存服务慢 → 触发快速失败机制 
→ 订单服务立即返回友好提示 
→ 其他服务正常运行 → 用户体验虽不完美但系统稳定
```

### 1.2 容错设计的八大核心原则


**📋 容错原则详解**

| 原则 | 通俗解释 | 实际场景 | 实现方式 |
|------|---------|---------|---------|
| **⚡ 快速失败** | `别傻等，超时就放弃` | `调用服务2秒无响应直接返回` | `设置超时时间` |
| **🔒 故障隔离** | `一个房间着火，别烧到其他房间` | `支付服务挂了不影响浏览商品` | `线程池隔离、信号量隔离` |
| **📉 优雅降级** | `高峰期关闭非核心功能` | `618大促时暂停推荐服务保证下单` | `降级规则配置` |
| **🛡️ 自我保护** | `系统负载高时主动拒绝部分请求` | `并发超过1000自动限流` | `流量控制` |
| **📊 监控告警** | `时刻盯着系统健康状况` | `错误率>5%立即发短信通知` | `Prometheus+Grafana` |
| **🔄 冗余设计** | `多准备几份，一个坏了有备用` | `部署3个订单服务实例` | `集群部署` |
| **📈 弹性伸缩** | `人多加桌子，人少撤桌子` | `流量高峰自动扩容服务器` | `K8s自动扩缩容` |
| **👁️ 可观测性** | `能看清系统内部在干什么` | `查看每个服务的调用链路` | `链路追踪(Skywalking)` |

**🎯 核心思想的本质**

```
容错设计的三层防护：

第一层：预防（别出问题）
- 限流：控制请求数量
- 熔断：自动隔离故障服务
- 降级：主动关闭非核心功能

第二层：隔离（出了问题别扩散）
- 线程隔离：用独立线程池
- 服务隔离：故障服务不影响其他服务
- 数据隔离：数据库分库分表

第三层：恢复（尽快恢复正常）
- 自动重试：失败后自动重试
- 熔断恢复：故障消失后自动恢复
- 健康检查：定期检测服务状态
```

### 1.3 快速失败原则详解


**🚀 什么是快速失败？**

> **核心理念**：与其傻傻等待一个可能永远不会成功的请求，不如快速失败，释放资源去处理其他请求。

**案例对比：**

```java
// ❌ 没有快速失败（危险做法）
public Order createOrder(Long userId) {
    // 调用库存服务，没设置超时时间
    Stock stock = stockService.checkStock(productId);
    // 如果库存服务挂了，这里会一直等待
    // 导致线程被占用，无法处理其他请求
    return orderRepository.save(order);
}
```

```java
// ✅ 实现快速失败（推荐做法）
@SentinelResource(value = "createOrder", 
    blockHandler = "orderBlockHandler",
    fallback = "orderFallback")
public Order createOrder(Long userId) {
    // 设置2秒超时
    Stock stock = stockService.checkStock(productId);
    return orderRepository.save(order);
}

// 快速失败后的处理
public Order orderFallback(Long userId, Throwable ex) {
    log.error("订单创建失败，快速返回", ex);
    // 返回友好提示而不是让用户一直等待
    throw new BusinessException("系统繁忙，请稍后重试");
}
```

**⏱️ 超时时间设置建议**

| 服务类型 | 推荐超时时间 | 原因 |
|---------|------------|------|
| `数据库查询` | `100-500ms` | `简单查询应该很快` |
| `内部服务调用` | `1-3秒` | `内网通信应该快速` |
| `第三方服务` | `5-10秒` | `外部网络不可控` |
| `文件上传` | `30-60秒` | `IO操作耗时较长` |

### 1.4 故障隔离原则详解


**🔒 什么是故障隔离？**

> **形象比喻**：就像船舱的水密隔舱，一个舱进水了，关上舱门，其他舱室还是安全的。

**隔离的两种主要方式：**

**方式一：线程池隔离**

```
服务A的请求处理模型（线程池隔离）：

┌─────────────────────────────────────────┐
│         订单服务（主服务）               │
├─────────────────────────────────────────┤
│                                         │
│  ┌─────────────┐  ┌─────────────┐      │
│  │  线程池A    │  │  线程池B    │      │
│  │  (5个线程)  │  │  (3个线程)  │      │
│  │   ↓↓↓↓↓    │  │   ↓↓↓      │      │
│  │ 调用库存服务 │  │ 调用支付服务 │      │
│  └─────────────┘  └─────────────┘      │
│                                         │
│  即使库存服务挂了占满5个线程，           │
│  支付服务的3个线程仍然可用！             │
└─────────────────────────────────────────┘
```

```java
// 线程池隔离配置示例
@Bean
public ThreadPoolExecutor stockThreadPool() {
    return new ThreadPoolExecutor(
        5,    // 核心线程数
        10,   // 最大线程数
        60,   // 空闲线程存活时间
        TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(100)  // 队列容量
    );
}
```

**方式二：信号量隔离**

```
信号量隔离模型（更轻量）：

请求进入 → 获取信号量许可 → 执行业务 → 释放许可
            ↓
        [许可数: 5个]
            ↓
    如果5个许可都被占用，新请求直接拒绝
    （不创建新线程，资源占用更小）
```

| 对比维度 | 线程池隔离 | 信号量隔离 |
|---------|-----------|-----------|
| **资源消耗** | `较大（每个线程占用内存）` | `很小（只是计数器）` |
| **隔离效果** | `强（完全独立线程）` | `中等（共用线程）` |
| **适用场景** | `需要异步调用、超时控制` | `纯内存操作、计算密集` |
| **性能** | `中等（线程切换开销）` | `高（无线程切换）` |

### 1.5 优雅降级原则


**📉 什么是优雅降级？**

> **生活类比**：就像飞机遇到紧急情况，先丢掉货物减轻重量，保证乘客安全落地。系统也一样，高峰期先关闭不重要的功能，保证核心功能可用。

**降级策略示例：**

```
电商系统降级优先级：

┌─────────────────────────────────────────┐
│  核心功能（绝不降级）                    │
│  - 下单功能                             │
│  - 支付功能                             │
│  - 订单查询                             │
└─────────────────────────────────────────┘
            ↑ 优先保障
┌─────────────────────────────────────────┐
│  重要功能（高峰期可降级）                │
│  - 商品推荐（展示默认推荐）              │
│  - 用户评价（暂不显示）                  │
│  - 优惠券查询（显示缓存数据）            │
└─────────────────────────────────────────┘
            ↑ 次要保障
┌─────────────────────────────────────────┐
│  非核心功能（立即降级）                  │
│  - 广告推送（直接关闭）                  │
│  - 数据统计（延后处理）                  │
│  - 日志收集（降低频率）                  │
└─────────────────────────────────────────┘
```

**实际代码实现：**

```java
// 商品推荐服务降级处理
@Service
public class ProductRecommendService {
    
    @SentinelResource(value = "recommend",
        fallback = "recommendFallback")
    public List<Product> getRecommendProducts(Long userId) {
        // 正常情况：调用推荐算法（复杂耗时）
        return aiRecommendService.recommend(userId);
    }
    
    // 降级方法：返回热销商品
    public List<Product> recommendFallback(Long userId, Throwable ex) {
        log.warn("推荐服务降级，返回默认热销商品");
        // 返回预先准备的热销商品（从缓存读取，速度快）
        return redisTemplate.opsForList()
            .range("hot:products", 0, 9);
    }
}
```

### 1.6 自我保护原则


**🛡️ 什么是自我保护？**

> **形象比喻**：就像景区限流，当游客太多时，在入口就控制人数，防止景区内拥挤踩踏。

**自我保护的触发时机：**

```
系统负载监控：

正常状态    →  预警状态  →  保护状态
(绿灯)         (黄灯)       (红灯)

CPU: 30%       60%          85%
内存: 40%       70%          90%
线程数: 50      200          500
响应时间: 100ms  500ms        2000ms

                              ↓
                         触发保护机制：
                         - 拒绝新请求
                         - 降级非核心服务
                         - 增加响应超时时间
```

**QPS限流示例：**

```java
// 限流规则：每秒最多处理100个请求
@GetMapping("/products")
@SentinelResource(value = "productList", 
    blockHandler = "handleBlock")
public Result getProducts() {
    return productService.list();
}

// 触发限流后的处理
public Result handleBlock(BlockException ex) {
    return Result.error("当前访问人数过多，请稍后再试");
}
```

| 限流策略 | 说明 | 适用场景 |
|---------|------|---------|
| **QPS限流** | `每秒请求数限制` | `API接口保护` |
| **线程数限流** | `同时处理的请求数限制` | `数据库连接保护` |
| **系统负载限流** | `根据CPU/内存自动限流` | `整体系统保护` |

### 1.7 监控告警的重要性


**📊 为什么需要监控告警？**

> **核心思想**：你不知道的问题才是最危险的。监控就是给系统装上"仪表盘"和"报警器"。

**需要监控的关键指标：**

```
微服务健康监控体系：

┌─────────────────────────────────────────┐
│  业务指标                                │
│  - 下单成功率                            │
│  - 支付成功率                            │
│  - 接口响应时间                          │
└─────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────┐
│  系统指标                                │
│  - CPU使用率                             │
│  - 内存使用率                            │
│  - 磁盘IO                                │
│  - 网络流量                              │
└─────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────┐
│  应用指标                                │
│  - JVM堆内存                             │
│  - 线程数                                │
│  - 垃圾回收次数                          │
│  - 异常数量                              │
└─────────────────────────────────────────┘
```

**告警级别设计：**

| 告警级别 | 触发条件 | 处理时间 | 通知方式 |
|---------|---------|---------|---------|
| 🔴 **紧急** | `服务完全不可用` | `立即处理` | `电话+短信+邮件` |
| 🟠 **严重** | `核心功能异常` | `15分钟内` | `短信+邮件` |
| 🟡 **警告** | `性能下降明显` | `1小时内` | `邮件` |
| 🟢 **提示** | `轻微异常` | `工作时间处理` | `日志记录` |

### 1.8 冗余设计与弹性伸缩


**🔄 冗余设计**

```
服务冗余部署示例：

                负载均衡器
                    ↓
        ┌───────────┴───────────┐
        ↓           ↓           ↓
    订单服务1    订单服务2    订单服务3
    (主节点)    (备节点)    (备节点)
    
即使一个节点挂了，其他节点继续服务
```

**📈 弹性伸缩**

> **通俗理解**：就像餐厅根据客流量增减服务员，系统也能根据流量自动增减服务器。

```
自动扩缩容流程：

监控流量 → 判断是否需要扩容 → 自动启动新实例 → 加入服务集群
   ↓
流量下降 → 判断是否可以缩容 → 下线多余实例 → 节省资源成本
```

**扩容策略示例：**

| 触发条件 | 扩容动作 | 说明 |
|---------|---------|------|
| `CPU > 70%持续5分钟` | `实例数+2` | `快速响应` |
| `请求队列>1000` | `实例数+1` | `防止请求堆积` |
| `响应时间>2秒` | `实例数翻倍` | `紧急扩容` |

### 1.9 可观测性原则


**👁️ 什么是可观测性？**

> **核心理念**：不仅要知道系统"出了什么问题"，还要知道"为什么出问题"、"影响了什么"。

**可观测性三大支柱：**

```
可观测性体系：

┌─────────────────────────────────────────┐
│  日志 (Logs)                             │
│  - 记录系统行为                          │
│  - 定位具体错误                          │
│  示例: "用户123下单失败，库存不足"       │
└─────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────┐
│  指标 (Metrics)                          │
│  - 统计数值数据                          │
│  - 发现性能趋势                          │
│  示例: "平均响应时间500ms，错误率3%"     │
└─────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────┐
│  链路追踪 (Tracing)                      │
│  - 跟踪请求路径                          │
│  - 定位慢调用环节                        │
│  示例: "订单服务→库存服务(慢)→商品服务" │
└─────────────────────────────────────────┘
```

**实际问题定位流程：**

```
问题：用户反馈下单很慢

步骤1: 查看监控指标
→ 发现订单服务响应时间从100ms升到3000ms

步骤2: 查看链路追踪
→ 发现调用库存服务耗时2800ms（问题定位！）

步骤3: 查看库存服务日志
→ 发现大量SQL慢查询，数据库连接池耗尽

步骤4: 解决方案
→ 优化SQL索引 + 增加数据库连接数
```

---

## 2. ⚠️ 微服务常见故障场景


### 2.1 雪崩效应


**❄️ 什么是雪崩效应？**

> **形象比喻**：就像多米诺骨牌，一张牌倒了，引发连锁反应，所有牌都倒下。

**雪崩发生的完整过程：**

```
雪崩效应演变过程：

阶段1: 初始故障
库存服务响应变慢（3秒 → 10秒）
   ↓
阶段2: 资源耗尽
订单服务调用库存服务
→ 线程等待时间过长
→ 订单服务线程池耗尽（无线程处理新请求）
   ↓
阶段3: 连锁反应
前端服务调用订单服务超时
→ 前端服务线程池耗尽
→ 用户无法访问整个系统
   ↓
阶段4: 系统崩溃
所有服务互相等待
→ 整个微服务集群瘫痪
```

**真实案例分析：**

假设一个购物系统有如下调用链：

```
用户请求 → 前端服务 → 订单服务 → 库存服务
                               → 商品服务
                               → 用户服务
```

```java
// 危险代码示例（没有任何保护）
@Service
public class OrderService {
    
    @Autowired
    private StockService stockService;  // 库存服务
    
    public Order createOrder(OrderDTO orderDTO) {
        // 如果库存服务挂了，这里会一直等待
        Stock stock = stockService.checkStock(orderDTO.getProductId());
        
        // 永远执行不到这里，因为线程被阻塞了
        return orderRepository.save(order);
    }
}
```

**问题分析：**

| 时间 | 事件 | 影响 |
|------|-----|------|
| `10:00` | `库存服务数据库慢查询` | `响应从100ms变为5秒` |
| `10:01` | `订单服务10个线程都在等待` | `新订单请求无法处理` |
| `10:02` | `50个请求堆积在订单服务` | `订单服务CPU飙升到90%` |
| `10:03` | `前端服务也开始等待` | `用户看到页面一直转圈` |
| `10:05` | `整个系统不可用` | `所有用户无法下单` |

### 2.2 服务雪崩的预防


**🛡️ 防雪崩的核心策略**

```
防雪崩三板斧：

1. 限流（入口控制）
   → 控制进入系统的请求数量
   → 超过阈值直接拒绝

2. 熔断（故障隔离）
   → 检测到服务异常立即停止调用
   → 避免故障传播

3. 降级（保核心弃枝叶）
   → 关闭非核心功能
   → 保证核心功能可用
```

**限流实现示例：**

```java
@RestController
public class OrderController {
    
    // 每秒最多100个请求
    @SentinelResource(value = "createOrder",
        blockHandler = "handleBlocker")
    @PostMapping("/orders")
    public Result createOrder(@RequestBody OrderDTO orderDTO) {
        return orderService.createOrder(orderDTO);
    }
    
    // 限流后的处理
    public Result handleBlocker(OrderDTO orderDTO, BlockException ex) {
        return Result.error("当前下单人数过多，请稍后重试");
    }
}
```

**熔断实现示例：**

```java
@Service
public class StockService {
    
    // 熔断规则：1秒内失败5次，熔断10秒
    @SentinelResource(value = "checkStock",
        fallback = "checkStockFallback")
    public Stock checkStock(Long productId) {
        return stockClient.check(productId);
    }
    
    // 熔断后的降级处理
    public Stock checkStockFallback(Long productId, Throwable ex) {
        log.warn("库存服务熔断，返回默认库存");
        // 返回一个安全的默认值
        return new Stock(productId, 0, false);
    }
}
```

### 2.3 服务超时与慢调用


**⏱️ 什么是慢调用？**

> **通俗理解**：就像你打电话，对方一直不接也不挂断，你的电话就一直占线，无法拨打其他电话。

**慢调用的危害：**

```
慢调用链路分析：

请求1: 调用服务A → 等待10秒 → 超时失败
请求2: 调用服务A → 等待10秒 → 超时失败
请求3: 调用服务A → 等待10秒 → 超时失败
...
100个请求 × 10秒 = 1000秒的累计等待时间
= 100个线程全部被占用 = 服务不可用！
```

**超时设置最佳实践：**

```java
@Configuration
public class FeignConfig {
    
    @Bean
    public Request.Options requestOptions() {
        return new Request.Options(
            2000,  // 连接超时：2秒
            5000   // 读取超时：5秒
        );
    }
}
```

| 超时类型 | 推荐值 | 说明 |
|---------|-------|------|
| **连接超时** | `1-3秒` | `建立连接的时间` |
| **读取超时** | `3-10秒` | `等待响应的时间` |
| **总超时** | `连接超时+读取超时` | `整个请求的最大时间` |

### 2.4 服务不可用与降级


**📉 什么时候需要降级？**

```
降级触发条件：

条件1: 错误率过高
- 1分钟内错误率超过50%
→ 触发降级，返回默认数据

条件2: 响应时间过长
- 平均响应时间超过2秒
→ 触发降级，使用缓存数据

条件3: 系统资源不足
- CPU使用率超过80%
→ 触发降级，关闭非核心功能
```

**降级策略示例：**

```java
@Service
public class ProductService {
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    // 商品详情查询（支持降级）
    @SentinelResource(value = "getProduct",
        fallback = "getProductFallback")
    public Product getProductDetail(Long productId) {
        // 正常情况：查询数据库
        return productRepository.findById(productId).orElse(null);
    }
    
    // 降级方法：返回缓存数据
    public Product getProductFallback(Long productId, Throwable ex) {
        log.warn("商品服务降级，使用缓存数据");
        // 从Redis获取缓存的商品信息
        return (Product) redisTemplate.opsForValue()
            .get("product:" + productId);
    }
}
```

**降级的两种常见方式：**

| 降级方式 | 说明 | 优点 | 缺点 |
|---------|-----|------|------|
| **返回默认值** | `返回预设的安全值` | `快速、简单` | `用户体验一般` |
| **使用缓存** | `返回之前缓存的数据` | `数据相对准确` | `可能数据过期` |

---

## 3. 🚦 Sentinel核心概念


### 3.1 Sentinel是什么？


> **一句话介绍**：Sentinel是阿里巴巴开源的流量控制和服务保护框架，专门为微服务打造的"安全卫士"。

**🔸 Sentinel能做什么？**

```
Sentinel核心功能图：

              Sentinel流量卫士
                    ↓
    ┌───────────────┼───────────────┐
    ↓               ↓               ↓
  流量控制        熔断降级       系统保护
    ↓               ↓               ↓
限制请求速率    故障自动隔离    负载自适应
QPS/并发控制   错误率统计      系统指标监控
热点限流       慢调用比例      CPU/Load保护
```

**与Hystrix的对比：**

| 对比维度 | Sentinel | Hystrix |
|---------|----------|---------|
| **开发状态** | `持续更新` | `已停止维护` |
| **控制台** | `功能强大的可视化界面` | `需要自己搭建` |
| **规则配置** | `动态修改，实时生效` | `代码硬编码` |
| **限流算法** | `多种算法可选` | `功能单一` |
| **性能** | `更轻量，开销小` | `线程池隔离开销大` |
| **适用场景** | `✅ 推荐使用` | `不再推荐` |

### 3.2 Sentinel核心概念解析


**📚 五个核心概念**

**1️⃣ 资源(Resource)**

> **通俗理解**：就是你要保护的东西，可以是一个接口、一个方法、甚至一段代码。

```java
// 资源定义示例
@SentinelResource("getUserInfo")  // 这就定义了一个资源
public User getUserInfo(Long userId) {
    return userRepository.findById(userId);
}
```

**2️⃣ 规则(Rule)**

> **通俗理解**：就是保护资源的"规矩"，比如每秒最多访问多少次。

```
规则类型分类：

流控规则 → 控制流量（QPS、并发数）
降级规则 → 熔断保护（错误率、慢调用）
热点规则 → 参数限流（针对特定参数值）
系统规则 → 整体保护（CPU、Load）
授权规则 → 访问控制（黑白名单）
```

**3️⃣ 插槽链(Slot Chain)**

> **通俗理解**：就像机场安检的多道关卡，请求要通过所有检查才能放行。

```
请求处理流程（插槽链）：

请求进入
   ↓
NodeSelectorSlot（统计节点）
   ↓
ClusterBuilderSlot（构建调用树）
   ↓
StatisticSlot（统计数据）
   ↓
FlowSlot（流量控制检查）
   ↓
DegradeSlot（降级检查）
   ↓
SystemSlot（系统保护检查）
   ↓
请求通过/被拦截
```

**4️⃣ 上下文(Context)**

> **通俗理解**：记录请求的"身份信息"，比如从哪来、去哪里。

```java
// 上下文包含的信息
Context {
    - 入口名称: "web-controller"
    - 来源应用: "order-service"  
    - 请求路径: "/api/orders"
    - 调用链路: A → B → C
}
```

**5️⃣ 指标统计(Metrics)**

> **通俗理解**：就像计数器，记录通过了多少请求、拒绝了多少请求。

```
统计维度：

时间维度：秒级、分钟级
类型维度：通过、拒绝、异常、成功
计算维度：QPS、响应时间、并发数
```

### 3.3 Sentinel工作原理


**🔄 完整工作流程**

```
Sentinel处理请求的完整流程：

1. 请求到达
   ↓
2. 创建Entry（入口点）
   ↓
3. 执行插槽链检查
   ├─ 统计插槽：记录指标
   ├─ 流控插槽：检查是否限流
   ├─ 降级插槽：检查是否熔断
   └─ 系统插槽：检查系统负载
   ↓
4. 检查通过 → 执行业务逻辑
   检查失败 → 抛出BlockException
   ↓
5. 释放Entry，更新统计数据
```

**实际代码执行过程：**

```java
@Service
public class OrderService {
    
    @SentinelResource(value = "createOrder",
        blockHandler = "handleBlock",
        fallback = "handleFallback")
    public Order createOrder(OrderDTO dto) {
        // 业务逻辑
        return orderRepository.save(order);
    }
    
    // 限流/降级后的处理
    public Order handleBlock(OrderDTO dto, BlockException ex) {
        // ex.getRule() 可以获取触发的规则
        return Order.rejected("系统繁忙");
    }
    
    // 业务异常的处理
    public Order handleFallback(OrderDTO dto, Throwable ex) {
        log.error("订单创建异常", ex);
        return Order.failed("订单创建失败");
    }
}
```

**blockHandler vs fallback 的区别：**

| 对比项 | blockHandler | fallback |
|-------|-------------|----------|
| **触发场景** | `限流、降级、系统保护` | `业务异常、运行时错误` |
| **异常类型** | `BlockException` | `Throwable` |
| **使用场景** | `流量控制场景` | `业务容错场景` |

### 3.4 限流算法详解


**🎯 Sentinel支持的限流算法**

**算法1: 滑动窗口算法（默认）**

> **形象比喻**：就像观察窗口一直在滑动，统计窗口内的请求数。

```
滑动窗口示意图：

时间轴: 0s   1s   2s   3s   4s   5s
       └────┴────┴────┴────┴────┘
窗口1:  [────────1秒窗口────────]
            5次请求 → 允许通过

窗口2:      [────────1秒窗口────────]
                8次请求 → 超过限制，拒绝

窗口持续滑动，每次统计最近1秒内的请求数
```

**算法2: 令牌桶算法**

> **形象比喻**：就像银行取号，桶里有多少令牌就能处理多少请求，没令牌就等着或拒绝。

```
令牌桶工作原理：

1. 系统以固定速率往桶里放令牌（比如每秒10个）
2. 桶有容量限制（比如最多存100个令牌）
3. 请求来了先取令牌
   - 有令牌：拿走令牌，处理请求
   - 没令牌：拒绝请求或排队等待

优点：允许一定程度的突发流量
```

**算法3: 漏桶算法**

> **形象比喻**：就像漏斗，不管上面倒多少水，下面总是匀速流出。

```
漏桶工作原理：

请求像水一样倒入桶中
桶底部匀速漏出（比如每秒10个）
桶满了就溢出（拒绝请求）

优点：流量绝对平滑
缺点：无法应对突发流量
```

**三种算法对比：**

| 算法 | 特点 | 适用场景 |
|------|-----|---------|
| **滑动窗口** | `统计精确，资源占用少` | `一般场景` |
| **令牌桶** | `支持突发流量` | `有流量峰值的场景` |
| **漏桶** | `流量绝对平滑` | `需要严格速率控制` |

### 3.5 熔断降级策略


**🔌 三种熔断策略**

**策略1: 慢调用比例**

```
慢调用熔断规则示例：

配置：
- 最大响应时间: 1秒
- 比例阈值: 50%
- 统计时长: 10秒
- 最小请求数: 10

触发条件：
10秒内收到至少10个请求
且响应时间>1秒的请求占比>50%
→ 触发熔断

熔断后：
接下来的请求直接返回降级结果
不再调用服务
```

**策略2: 异常比例**

```
异常比例熔断示例：

配置：
- 异常比例: 50%
- 统计时长: 10秒
- 最小请求数: 5

触发条件：
10秒内收到至少5个请求
且异常请求占比>50%
→ 触发熔断
```

**策略3: 异常数**

```
异常数熔断示例：

配置：
- 异常数: 10个
- 统计时长: 1分钟

触发条件：
1分钟内异常数超过10个
→ 触发熔断
```

**熔断状态转换：**

```
熔断状态机：

    关闭状态(Closed)
         ↓
    触发熔断条件
         ↓
    打开状态(Open) ─────→ 拒绝所有请求
         ↓
    等待熔断时长
         ↓
    半开状态(Half-Open)
         ↓
    尝试放行少量请求
    ↙           ↘
请求成功          请求失败
    ↓              ↓
关闭状态        重新打开
```

### 3.6 热点参数限流


**🔥 什么是热点限流？**

> **通俗理解**：就像明星演唱会，黄牛票的价格会根据座位好坏不同而不同。热点限流就是对"热门参数"做特殊限制。

**应用场景示例：**

```
场景：商品查询接口

普通商品：QPS限制100
热门商品（iPhone）：QPS限制1000（需要特殊配置）

为什么？
- 热门商品访问量大
- 需要更高的QPS
- 但也要防止击垮系统
```

**代码实现：**

```java
@RestController
public class ProductController {
    
    // 对productId参数做热点限流
    @SentinelResource(value = "getProduct",
        blockHandler = "handleBlock")
    @GetMapping("/products/{id}")
    public Product getProduct(
        @PathVariable("id") Long productId) {
        return productService.getById(productId);
    }
    
    public Product handleBlock(Long productId, BlockException ex) {
        return Product.busy("商品访问量过大");
    }
}
```

**热点规则配置：**

| 配置项 | 说明 | 示例值 |
|-------|-----|--------|
| **参数索引** | `限流的参数位置` | `0（第一个参数）` |
| **限流阈值** | `通用QPS限制` | `100` |
| **参数值** | `特殊参数值` | `productId=123` |
| **特殊阈值** | `该参数的QPS` | `1000` |

---

## 4. 📋 核心要点总结


### 4.1 容错设计核心原则记忆


```
🔸 快速失败：别傻等，设置超时快速返回
🔸 故障隔离：用线程池或信号量隔离不同服务调用
🔸 优雅降级：高峰期关闭非核心功能保证核心可用
🔸 自我保护：系统负载高时主动限流拒绝请求
🔸 监控告警：时刻监控系统健康，问题及时发现
🔸 冗余设计：多节点部署，一个挂了有备用
🔸 弹性伸缩：根据流量自动增减服务实例
🔸 可观测性：通过日志、指标、链路全面了解系统
```

### 4.2 Sentinel核心功能


```
流量控制：
- QPS限流、并发数限流
- 支持滑动窗口、令牌桶等算法
- 热点参数限流

熔断降级：
- 慢调用比例熔断
- 异常比例熔断
- 异常数熔断

系统保护：
- CPU使用率保护
- 系统Load保护
- 平均响应时间保护
- 入口QPS保护
- 并发线程数保护
```

### 4.3 关键知识点记忆


**🔹 雪崩效应防护**
```
预防 → 限流控制入口流量
隔离 → 故障服务不影响其他服务  
降级 → 保核心功能弃非核心功能
恢复 → 故障消除后自动恢复
```

**🔹 blockHandler vs fallback**
```
blockHandler → 限流/降级触发（BlockException）
fallback → 业务异常触发（Throwable）
可以同时配置，分别处理不同场景
```

**🔹 熔断状态转换**
```
关闭 → 正常运行，统计指标
打开 → 触发熔断，拒绝请求
半开 → 尝试恢复，放行少量请求测试
```

### 4.4 实际应用建议


**💼 企业开发最佳实践**

| 场景 | 推荐方案 | 说明 |
|------|---------|-----|
| **接口保护** | `QPS限流 + 熔断降级` | `防止接口被刷，故障自动隔离` |
| **第三方调用** | `超时控制 + 降级处理` | `第三方不可控，必须有备案` |
| **数据库操作** | `并发数限流 + 慢SQL熔断` | `保护数据库不被打垮` |
| **核心业务** | `热点限流 + 系统保护` | `保证核心功能优先可用` |

**🎯 配置优先级**

```
1. 先配置系统保护（防止整体崩溃）
2. 再配置核心接口限流（保证核心可用）
3. 最后配置降级规则（提供降级方案）
4. 持续监控调优（根据实际情况调整）
```

**⚠️ 常见问题避坑**

```
❌ 只配置限流不配置降级
→ 应该：限流+降级+监控 三位一体

❌ 超时时间设置过长
→ 应该：根据业务特性合理设置，一般3-5秒

❌ 熔断阈值设置不合理
→ 应该：先观察业务指标再配置，循序渐进

❌ 忽略降级方法的实现
→ 应该：降级方法要返回有意义的默认值
```

**核心记忆口诀：**
```
微服务容错记心间，八大原则要实践
快速失败别傻等，故障隔离防扩散  
优雅降级保核心，自我保护防雪崩
监控告警要及时，冗余伸缩保可用
Sentinel来护航，限流熔断加降级
热点保护防击穿，系统负载要监控
```