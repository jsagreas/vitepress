---
title: 6、第一个Sentinel应用
---
## 📚 目录

1. [Sentinel是什么](#1-Sentinel是什么)
2. [为什么需要Sentinel](#2-为什么需要Sentinel)
3. [快速上手第一个应用](#3-快速上手第一个应用)
4. [核心概念理解](#4-核心概念理解)
5. [实战演练](#5-实战演练)
6. [监控效果查看](#6-监控效果查看)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🛡️ Sentinel是什么


### 1.1 通俗理解Sentinel


想象一下，你开了一家餐厅：

```
正常情况：
顾客进店 → 点餐 → 厨房做菜 → 上菜 → 顾客满意 ✅

突发情况（流量暴增）：
100个顾客同时涌入 → 厨房忙不过来 → 菜品质量下降 → 顾客不满 ❌
甚至：厨房崩溃 → 整个餐厅瘫痪 🔥
```

**Sentinel就像餐厅的"门卫+流量控制器"**：
- 🚪 **限流**：控制进店人数，超过接待能力就排队等候
- 🛡️ **熔断**：发现厨房出问题，暂时拒绝接单，保护厨房不崩溃
- ⚡ **降级**：人太多时，只提供简餐，保证基本服务

### 1.2 官方定义


> 💡 **Sentinel**：面向分布式服务架构的**流量控制**组件，主要以流量为切入点，从**流量控制**、**熔断降级**、**系统负载保护**等多个维度保护服务的稳定性。

**核心功能**：
- 🔸 **流量控制**：限制请求速率，防止系统过载
- 🔸 **熔断降级**：快速失败，避免雪崩效应
- 🔸 **系统保护**：根据系统负载自动调节流量
- 🔸 **实时监控**：可视化查看流量和规则效果

---

## 2. 🤔 为什么需要Sentinel


### 2.1 微服务面临的问题


在微服务架构中，服务之间互相调用：

```
用户请求
   ↓
订单服务 → 库存服务 → 数据库
   ↓
支付服务 → 账户服务 → 数据库
```

**问题来了**：
- ⚠️ **流量突增**：促销活动导致流量暴增10倍
- ⚠️ **服务故障**：某个服务响应慢或挂掉
- ⚠️ **雪崩效应**：一个服务故障导致整个系统崩溃

### 2.2 没有保护机制的后果


```
❌ 没有Sentinel的情况：

库存服务响应慢（2秒/请求）
    ↓
订单服务等待库存服务
    ↓
大量线程被占用（阻塞）
    ↓
订单服务也变慢
    ↓
用户请求堆积
    ↓
整个系统崩溃 💥
```

### 2.3 有Sentinel保护的效果


```
✅ 有Sentinel的情况：

检测到库存服务响应慢
    ↓
Sentinel触发熔断（快速失败）
    ↓
订单服务不再等待，直接返回友好提示
    ↓
系统继续稳定运行 ✨
    ↓
库存服务恢复后，自动放开流量
```

---

## 3. 🚀 快速上手第一个应用


### 3.1 环境准备


**前置条件**：
- ✅ JDK 1.8 或更高版本
- ✅ Maven 3.x
- ✅ IDEA 或其他IDE

**依赖引入**：

```xml
<!-- Spring Boot项目 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
    <version>2021.0.5.0</version>
</dependency>
```

### 3.2 第一步：定义资源


**什么是资源？**
> 资源就是你想要保护的东西，可以是一段代码、一个方法、一个接口

**方式一：注解方式（推荐新手）**

```java
@RestController
public class HelloController {
    
    // @SentinelResource 就是在说："这个方法需要保护"
    @SentinelResource(value = "hello", blockHandler = "handleBlock")
    @GetMapping("/hello")
    public String hello() {
        return "Hello Sentinel!";
    }
    
    // 当触发限流时，执行这个方法
    public String handleBlock(BlockException ex) {
        return "系统繁忙，请稍后再试~";
    }
}
```

**代码解释**：
- `value = "hello"`：给资源起个名字，叫"hello"
- `blockHandler`：限流时执行的备用方法
- `BlockException`：Sentinel抛出的异常，表示被限流了

**方式二：编程方式**

```java
public String testSentinel() {
    // 定义资源名称
    Entry entry = null;
    try {
        // 进入资源
        entry = SphU.entry("testResource");
        
        // 这里是你的业务逻辑
        return "正常处理";
        
    } catch (BlockException e) {
        // 被限流了
        return "限流了，请稍后再试";
    } finally {
        // 一定要释放资源
        if (entry != null) {
            entry.exit();
        }
    }
}
```

### 3.3 第二步：设置规则


**规则是什么？**
> 规则就是告诉Sentinel：在什么情况下触发保护

**限流规则示例**：

```java
@PostConstruct  // Spring启动时自动执行
public void initFlowRules() {
    List<FlowRule> rules = new ArrayList<>();
    
    // 创建一条规则
    FlowRule rule = new FlowRule();
    rule.setResource("hello");        // 对哪个资源限流
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);  // 按QPS限流
    rule.setCount(2);                 // 每秒最多2次请求
    
    rules.add(rule);
    FlowRuleManager.loadRules(rules); // 加载规则
}
```

**规则参数说明**：

| 参数 | 含义 | 示例值 |
|-----|------|--------|
| **resource** | 资源名称 | `"hello"` |
| **grade** | 限流模式 | `QPS`（每秒请求数）或 `线程数` |
| **count** | 限流阈值 | `2`（每秒最多2个请求） |

---

## 4. 💡 核心概念理解


### 4.1 资源（Resource）


**通俗解释**：
- 资源就是你想保护的"东西"
- 可以是接口、方法、甚至一段代码

**示例理解**：
```
餐厅类比：
- 资源 = 餐桌、厨房、收银台
- 定义资源 = 标记出需要保护的地方
```

**常见资源类型**：
- ✅ REST接口：`/api/order`
- ✅ 服务方法：`OrderService.createOrder()`
- ✅ 代码块：某段关键业务逻辑

### 4.2 规则（Rule）


**规则类型对比**：

| 规则类型 | 作用 | 类比 |
|---------|------|------|
| 🚦 **流量控制** | 限制请求速率 | 餐厅限制进店人数 |
| 🛡️ **熔断降级** | 服务异常时快速失败 | 厨房故障时暂停接单 |
| ⚡ **系统保护** | 系统负载过高时保护 | CPU太高时拒绝服务 |

### 4.3 QPS vs 并发线程数


**QPS（每秒请求数）**：
```
场景：限制每秒最多处理10个请求

第1秒：收到15个请求 → 只处理10个，5个被拒绝
第2秒：收到5个请求  → 全部处理
第3秒：收到20个请求 → 只处理10个，10个被拒绝
```

**并发线程数**：
```
场景：限制同时处理的请求数为5个

当前有5个请求正在处理（线程忙）
    ↓
新来的请求会被拒绝
    ↓
直到有请求处理完（线程释放）
    ↓
才能处理新请求
```

---

## 5. 🎯 实战演练


### 5.1 完整示例代码


```java
@RestController
@RequestMapping("/demo")
public class SentinelDemoController {
    
    // 限流资源
    @SentinelResource(
        value = "queryOrder",
        blockHandler = "orderBlockHandler"
    )
    @GetMapping("/order/{id}")
    public String queryOrder(@PathVariable Long id) {
        return "订单详情：" + id;
    }
    
    // 限流处理方法
    public String orderBlockHandler(Long id, BlockException ex) {
        return "订单查询繁忙，请稍后再试！";
    }
    
    // 配置限流规则
    @PostConstruct
    public void initRules() {
        List<FlowRule> rules = new ArrayList<>();
        
        FlowRule rule = new FlowRule();
        rule.setResource("queryOrder");
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        rule.setCount(5);  // 每秒最多5个请求
        
        rules.add(rule);
        FlowRuleManager.loadRules(rules);
    }
}
```

### 5.2 测试步骤


**① 启动应用**

**② 正常访问**
```bash
curl http://localhost:8080/demo/order/123
# 返回：订单详情：123
```

**③ 快速访问（模拟高并发）**
```bash
# 使用工具快速发送10次请求
for i in {1..10}; do curl http://localhost:8080/demo/order/123; done
```

**④ 查看结果**
```
前5次：订单详情：123 ✅
后5次：订单查询繁忙，请稍后再试！❌
```

### 5.3 规则验证


**验证要点**：
- ✅ 规则是否生效？
- ✅ 限流阈值是否准确？
- ✅ 降级方法是否执行？

**验证方法**：

| 测试场景 | 预期结果 | 验证点 |
|---------|---------|--------|
| 每秒3次请求 | 全部通过 | 未触发限流 |
| 每秒6次请求 | 5次通过，1次限流 | 限流阈值正确 |
| 限流时请求 | 返回友好提示 | 降级方法生效 |

---

## 6. 📊 监控效果查看


### 6.1 启动Sentinel控制台


**下载控制台**：
```bash
# 下载sentinel-dashboard.jar
wget https://github.com/alibaba/Sentinel/releases/download/1.8.6/sentinel-dashboard-1.8.6.jar

# 启动（默认端口8080）
java -jar sentinel-dashboard-1.8.6.jar
```

**访问控制台**：
- 地址：`http://localhost:8080`
- 账号：`sentinel`
- 密码：`sentinel`

### 6.2 应用接入控制台


**配置文件**（application.yml）：
```yaml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080  # 控制台地址
        port: 8719                 # 与控制台通信端口
```

### 6.3 控制台功能


**核心面板**：

```
┌─────────────────────────────┐
│  Sentinel 控制台            │
├─────────────────────────────┤
│  📊 实时监控                │
│  · 每秒通过QPS              │
│  · 每秒拒绝QPS              │
│  · 响应时间                 │
├─────────────────────────────┤
│  📋 规则管理                │
│  · 流量控制规则             │
│  · 熔断降级规则             │
│  · 系统保护规则             │
├─────────────────────────────┤
│  📈 链路监控                │
│  · 调用链路可视化           │
│  · 资源调用关系             │
└─────────────────────────────┘
```

**监控指标说明**：

| 指标 | 含义 | 示例 |
|-----|------|------|
| **通过QPS** | 每秒成功处理的请求数 | `5` |
| **拒绝QPS** | 每秒被限流的请求数 | `3` |
| **响应时间** | 平均响应耗时 | `50ms` |
| **异常数** | 业务异常次数 | `0` |

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的概念


```
🔸 资源（Resource）
   → 需要保护的接口、方法或代码块
   → 用 @SentinelResource 或 SphU.entry() 定义

🔸 规则（Rule）
   → 限流规则：控制请求速率
   → 熔断规则：服务异常时快速失败
   → 系统规则：保护系统整体稳定

🔸 限流模式
   → QPS：每秒请求数限制
   → 线程数：并发处理数限制

🔸 降级处理
   → blockHandler：限流时的备用方法
   → fallback：异常时的降级方法
```

### 7.2 开发流程


**三步走**：

```
第1步：定义资源
    ↓
@SentinelResource(value = "资源名")

第2步：设置规则
    ↓
FlowRule rule = new FlowRule();
rule.setResource("资源名");
rule.setCount(阈值);

第3步：触发保护
    ↓
访问资源 → 触发限流 → 执行降级方法
```

### 7.3 实战检查清单


- [ ] **环境准备**：依赖引入、配置文件
- [ ] **定义资源**：标记需要保护的方法
- [ ] **设置规则**：配置限流阈值
- [ ] **降级处理**：编写友好的降级方法
- [ ] **测试验证**：模拟高并发场景
- [ ] **监控查看**：启动控制台观察效果

### 7.4 常见问题


**Q1：规则不生效？**
```
排查步骤：
① 检查资源名是否一致
② 确认规则是否加载成功
③ 查看控制台是否有规则
```

**Q2：为什么要定义blockHandler？**
```
答：限流时需要给用户友好的提示
  ❌ 不定义：抛出异常，用户看到错误页面
  ✅ 定义：返回友好提示，用户体验好
```

**Q3：QPS设置多少合适？**
```
建议：
· 根据压测结果设置
· 预留20-30%缓冲空间
· 示例：系统能承受100 QPS → 设置70-80 QPS
```

### 7.5 记忆口诀


```
📝 Sentinel三步曲：
   定义资源标保护
   设置规则控流量  
   降级处理保体验
   
📝 限流两模式：
   QPS控速率
   线程限并发
```

---

> ⚡ **下一步学习**：掌握了基础使用后，可以深入学习：
> - 流量控制的高级配置（预热、排队等待）
> - 熔断降级的策略选择
> - 热点参数限流
> - 集群流控