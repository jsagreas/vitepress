---
title: 3、Saga状态机设计模式
---
## 📚 目录


1. [Saga状态机基础概念](#1-saga状态机基础概念)
2. [事务状态定义](#2-事务状态定义)
3. [状态转换规则](#3-状态转换规则)
4. [补偿动作映射](#4-补偿动作映射)
5. [状态持久化](#5-状态持久化)
6. [状态机驱动](#6-状态机驱动)
7. [实战案例分析](#7-实战案例分析)
8. [核心要点总结](#8-核心要点总结)

---

# 🎯 **学习导航**


**前置知识**：需要了解分布式事务基础、微服务架构 → **当前学习**：Saga状态机设计 → **后续内容**：Saga协调器实现

**学习难度**：🟡 进阶级 | **预计时间**：45分钟 | **重要程度**：★★★★☆

---

## 1. 🎭 Saga状态机基础概念



### 1.1 什么是Saga状态机



**💡 生活化理解**
想象你在网上买东西的完整流程：
- **下单** → **付款** → **扣库存** → **发货** → **完成**
- 如果中间任何一步出错，都要把前面做过的步骤**撤回**

这就是Saga状态机的核心思想！

**🔸 核心定义**
```
Saga状态机：管理长事务执行过程的有限状态机
作用：记录事务进展，协调各步骤的执行和补偿
特点：每个状态代表事务的一个阶段
```

### 1.2 为什么需要状态机



**🤔 没有状态机的问题**
```
混乱场景：
• 不知道事务执行到哪一步了
• 出错时不知道该回滚哪些操作
• 重启后无法恢复事务状态
• 多个服务间协调困难
```

**✅ 状态机解决的问题**
```
有序管理：
• 清楚记录每个阶段的状态
• 明确定义什么时候执行什么操作
• 失败时知道如何补偿
• 可以暂停和恢复事务
```

### 1.3 状态机基本组成



**🧩 核心组件**
```
状态(State)：事务的各个阶段
├── 初始状态：事务开始
├── 中间状态：各个业务步骤
└── 终结状态：成功或失败

事件(Event)：触发状态变化的动作
├── 成功事件：步骤执行成功
├── 失败事件：步骤执行失败
└── 补偿事件：回滚操作

动作(Action)：状态转换时执行的操作
├── 正向动作：业务操作
└── 补偿动作：回滚操作
```

---

## 2. 📊 事务状态定义



### 2.1 标准状态分类



**🔄 基础状态类型**
```
执行状态：
• STARTED    - 事务开始
• RUNNING    - 正在执行
• COMPLETED  - 执行完成

异常状态：
• FAILED     - 执行失败
• COMPENSATING - 正在补偿
• COMPENSATED  - 补偿完成

终结状态：
• SUCCESS    - 最终成功
• ABORTED    - 最终失败
```

### 2.2 电商订单状态设计



**🛒 实际业务状态**

| **业务阶段** | **状态名称** | **状态描述** | **可执行操作** |
|-------------|-------------|-------------|---------------|
| 订单创建 | `ORDER_CREATED` | 订单已创建待处理 | 开始支付流程 |
| 支付处理 | `PAYMENT_PROCESSING` | 正在处理支付 | 等待支付结果 |
| 支付完成 | `PAYMENT_COMPLETED` | 支付成功 | 开始库存扣减 |
| 库存处理 | `INVENTORY_PROCESSING` | 正在扣减库存 | 等待库存操作 |
| 库存完成 | `INVENTORY_COMPLETED` | 库存扣减成功 | 开始发货 |
| 发货处理 | `SHIPPING_PROCESSING` | 正在安排发货 | 等待发货确认 |
| 订单完成 | `ORDER_SUCCESS` | 整个流程成功 | 无(终结状态) |

### 2.3 状态属性定义



**📝 状态详细信息**
```java
// 状态枚举定义
public enum SagaState {
    ORDER_CREATED("订单创建", true, false),
    PAYMENT_PROCESSING("支付处理中", false, false),
    PAYMENT_COMPLETED("支付完成", true, false),
    INVENTORY_PROCESSING("库存处理中", false, false),
    INVENTORY_COMPLETED("库存完成", true, false),
    SHIPPING_PROCESSING("发货处理中", false, false),
    ORDER_SUCCESS("订单成功", true, true),
    ORDER_FAILED("订单失败", true, true);
    
    private final String description;  // 状态描述
    private final boolean stable;      // 是否稳定状态
    private final boolean terminal;    // 是否终结状态
}
```

---

## 3. 🔄 状态转换规则



### 3.1 正向流程转换



**➡️ 成功路径状态转换**
```
正常业务流程：
ORDER_CREATED 
    ↓ (创建订单成功)
PAYMENT_PROCESSING
    ↓ (支付成功)  
PAYMENT_COMPLETED
    ↓ (开始库存扣减)
INVENTORY_PROCESSING
    ↓ (库存扣减成功)
INVENTORY_COMPLETED
    ↓ (开始发货)
SHIPPING_PROCESSING
    ↓ (发货成功)
ORDER_SUCCESS
```

### 3.2 异常流程转换



**⬅️ 失败补偿路径**
```
支付失败场景：
ORDER_CREATED → PAYMENT_PROCESSING → ORDER_FAILED
(无需补偿，直接失败)

库存失败场景：
ORDER_CREATED → ... → INVENTORY_PROCESSING(失败)
    ↓
COMPENSATING_PAYMENT (补偿支付)
    ↓  
ORDER_FAILED

发货失败场景：
ORDER_CREATED → ... → SHIPPING_PROCESSING(失败)
    ↓
COMPENSATING_INVENTORY (补偿库存)
    ↓
COMPENSATING_PAYMENT (补偿支付)
    ↓
ORDER_FAILED
```

### 3.3 状态转换规则实现



**⚙️ 转换逻辑代码**
```java
public class SagaStateMachine {
    
    // 定义允许的状态转换
    private static final Map<SagaState, Set<SagaState>> ALLOWED_TRANSITIONS = 
        Map.of(
            ORDER_CREATED, Set.of(PAYMENT_PROCESSING, ORDER_FAILED),
            PAYMENT_PROCESSING, Set.of(PAYMENT_COMPLETED, ORDER_FAILED),
            PAYMENT_COMPLETED, Set.of(INVENTORY_PROCESSING, COMPENSATING_PAYMENT),
            // ... 更多转换规则
        );
    
    // 验证状态转换是否合法
    public boolean canTransition(SagaState from, SagaState to) {
        return ALLOWED_TRANSITIONS.getOrDefault(from, Set.of()).contains(to);
    }
    
    // 执行状态转换
    public void transition(SagaInstance saga, SagaState newState) {
        if (!canTransition(saga.getCurrentState(), newState)) {
            throw new IllegalStateException(
                String.format("不允许从 %s 转换到 %s", 
                    saga.getCurrentState(), newState)
            );
        }
        saga.setState(newState);
    }
}
```

---

## 4. 🔧 补偿动作映射



### 4.1 补偿动作设计原则



**🎯 补偿动作特点**
```
幂等性：多次执行结果一致
• 重复退款不会多扣钱
• 重复释放库存不会出错

可靠性：补偿动作必须成功
• 如果补偿失败，需要重试
• 或者人工介入处理

业务语义：补偿要符合业务逻辑
• 支付补偿 = 退款
• 库存补偿 = 释放库存
• 积分补偿 = 扣减积分
```

### 4.2 补偿映射表设计



**📋 业务操作与补偿映射**

| **正向操作** | **操作描述** | **补偿操作** | **补偿描述** | **注意事项** |
|-------------|-------------|-------------|-------------|-------------|
| `createOrder` | 创建订单记录 | `cancelOrder` | 取消订单 | 更新状态即可 |
| `processPayment` | 扣款处理 | `refundPayment` | 退款处理 | 需要调用支付网关 |
| `reserveInventory` | 扣减库存 | `releaseInventory` | 释放库存 | 恢复库存数量 |
| `arrangeShipping` | 安排发货 | `cancelShipping` | 取消发货 | 通知物流取消 |
| `sendNotification` | 发送通知 | `sendCancelNotification` | 发送取消通知 | 用户体验考虑 |

### 4.3 补偿动作实现



**🛠️ 补偿操作代码示例**
```java
public class OrderSagaActions {
    
    // 支付操作及其补偿
    @SagaAction
    public void processPayment(OrderContext context) {
        paymentService.charge(context.getOrderId(), context.getAmount());
        log.info("支付处理完成: {}", context.getOrderId());
    }
    
    @CompensationAction
    public void compensatePayment(OrderContext context) {
        paymentService.refund(context.getOrderId(), context.getAmount());
        log.info("支付补偿完成: {}", context.getOrderId());
    }
    
    // 库存操作及其补偿
    @SagaAction  
    public void reserveInventory(OrderContext context) {
        inventoryService.reserve(context.getProductId(), context.getQuantity());
        log.info("库存预留完成: {}", context.getProductId());
    }
    
    @CompensationAction
    public void compensateInventory(OrderContext context) {
        inventoryService.release(context.getProductId(), context.getQuantity());
        log.info("库存补偿完成: {}", context.getProductId());
    }
}
```

---

## 5. 💾 状态持久化



### 5.1 持久化的重要性



**🤔 为什么要持久化状态？**
```
系统重启恢复：
• 服务重启后能继续执行事务
• 不会丢失事务的执行进度

故障恢复：
• 系统崩溃后可以从最后状态恢复
• 避免重复执行已完成的步骤

审计追踪：
• 记录事务的完整执行历史
• 便于问题排查和业务分析
```

### 5.2 状态存储设计



**🗄️ 数据库表结构**
```sql
-- Saga实例表
CREATE TABLE saga_instance (
    id BIGINT PRIMARY KEY,                -- Saga实例ID
    saga_type VARCHAR(50) NOT NULL,       -- Saga类型(如:ORDER_SAGA)
    current_state VARCHAR(50) NOT NULL,   -- 当前状态
    context_data JSON,                    -- 上下文数据
    created_time TIMESTAMP,               -- 创建时间
    updated_time TIMESTAMP,               -- 更新时间
    INDEX idx_saga_type_state (saga_type, current_state)
);

-- 状态变更历史表
CREATE TABLE saga_state_history (
    id BIGINT PRIMARY KEY,
    saga_id BIGINT NOT NULL,              -- 关联saga_instance.id
    from_state VARCHAR(50),               -- 源状态
    to_state VARCHAR(50) NOT NULL,        -- 目标状态
    event_type VARCHAR(50),               -- 触发事件
    change_time TIMESTAMP,                -- 变更时间
    INDEX idx_saga_id (saga_id)
);
```

### 5.3 持久化操作实现



**💽 状态保存代码**
```java
@Service
public class SagaPersistenceService {
    
    @Autowired
    private SagaInstanceRepository instanceRepo;
    
    @Autowired  
    private SagaHistoryRepository historyRepo;
    
    // 保存Saga状态变更
    @Transactional
    public void saveStateChange(Long sagaId, SagaState fromState, 
                               SagaState toState, String eventType) {
        
        // 更新当前状态
        SagaInstance instance = instanceRepo.findById(sagaId)
            .orElseThrow(() -> new RuntimeException("Saga实例不存在"));
        instance.setCurrentState(toState);
        instance.setUpdatedTime(LocalDateTime.now());
        instanceRepo.save(instance);
        
        // 记录状态变更历史
        SagaStateHistory history = SagaStateHistory.builder()
            .sagaId(sagaId)
            .fromState(fromState)
            .toState(toState) 
            .eventType(eventType)
            .changeTime(LocalDateTime.now())
            .build();
        historyRepo.save(history);
        
        log.info("Saga状态已保存: {} -> {}", fromState, toState);
    }
}
```

---

## 6. ⚙️ 状态机驱动



### 6.1 事件驱动模型



**📡 事件驱动原理**
```
事件触发流程：
业务操作完成 → 发布事件 → 状态机接收 → 执行转换 → 触发下一步

优点：
• 松耦合：各组件独立
• 异步处理：提高性能  
• 易扩展：新增步骤简单
```

### 6.2 状态机引擎实现



**🏗️ 核心引擎代码**
```java
@Component
public class SagaStateMachineEngine {
    
    @EventListener
    public void handleSagaEvent(SagaEvent event) {
        
        // 获取Saga实例
        SagaInstance saga = getSagaInstance(event.getSagaId());
        
        // 根据事件类型决定下一个状态
        SagaState nextState = determineNextState(
            saga.getCurrentState(), 
            event.getEventType()
        );
        
        if (nextState != null) {
            // 执行状态转换
            transitionTo(saga, nextState);
            
            // 如果不是终结状态，触发下一个动作
            if (!nextState.isTerminal()) {
                executeNextAction(saga, nextState);
            }
        }
    }
    
    private void executeNextAction(SagaInstance saga, SagaState state) {
        switch (state) {
            case PAYMENT_PROCESSING:
                sagaActions.processPayment(saga.getContext());
                break;
            case INVENTORY_PROCESSING:
                sagaActions.reserveInventory(saga.getContext());
                break;
            // ... 其他动作
        }
    }
}
```

### 6.3 定时任务支持



**⏰ 超时和重试机制**
```java
@Scheduled(fixedDelay = 30000) // 每30秒检查一次
public void checkTimeoutSagas() {
    
    // 查找超时的Saga实例
    List<SagaInstance> timeoutSagas = sagaRepository
        .findTimeoutInstances(Duration.ofMinutes(5));
    
    for (SagaInstance saga : timeoutSagas) {
        log.warn("发现超时Saga: {}, 当前状态: {}", 
            saga.getId(), saga.getCurrentState());
        
        // 根据状态决定处理方式
        if (saga.getCurrentState().isProcessing()) {
            // 处理中状态超时，可以重试
            retryAction(saga);
        } else {
            // 其他超时情况，可能需要补偿
            startCompensation(saga);
        }
    }
}
```

---

## 7. 🏪 实战案例分析



### 7.1 完整电商订单Saga



**🛍️ 业务场景**
一个完整的电商下单流程，包含：订单创建、支付处理、库存扣减、积分奖励、发货安排

**📊 状态转换图示**
```
正常流程：
START → ORDER_CREATED → PAYMENT_PROCESSING → PAYMENT_COMPLETED 
  ↓
INVENTORY_PROCESSING → INVENTORY_COMPLETED → POINTS_PROCESSING 
  ↓  
POINTS_COMPLETED → SHIPPING_PROCESSING → ORDER_SUCCESS

异常流程（库存不足）：
INVENTORY_PROCESSING(失败) → COMPENSATING_PAYMENT → ORDER_FAILED
```

### 7.2 状态机配置实现



**⚙️ Spring State Machine配置**
```java
@Configuration
@EnableStateMachine
public class OrderSagaStateMachineConfig 
    extends StateMachineConfigurerAdapter<SagaState, SagaEvent> {
    
    @Override
    public void configure(StateMachineStateConfigurer<SagaState, SagaEvent> states)
            throws Exception {
        states
            .withStates()
                .initial(ORDER_CREATED)
                .states(EnumSet.allOf(SagaState.class))
                .end(ORDER_SUCCESS)
                .end(ORDER_FAILED);
    }
    
    @Override
    public void configure(StateMachineTransitionConfigurer<SagaState, SagaEvent> transitions)
            throws Exception {
        transitions
            // 正向流程转换
            .withExternal()
                .source(ORDER_CREATED).target(PAYMENT_PROCESSING)
                .event(START_PAYMENT)
                .action(startPaymentAction())
            .and()
            .withExternal()
                .source(PAYMENT_PROCESSING).target(PAYMENT_COMPLETED)
                .event(PAYMENT_SUCCESS)
                .action(paymentCompletedAction())
            .and()
            // 异常流程转换  
            .withExternal()
                .source(PAYMENT_PROCESSING).target(ORDER_FAILED)
                .event(PAYMENT_FAILED)
                .action(paymentFailedAction());
    }
}
```

---

## 8. 📋 核心要点总结



### 8.1 必须掌握的核心概念



```
🔸 Saga状态机：管理长事务的有限状态机，记录和协调事务执行
🔸 状态定义：明确每个业务阶段的状态，包括执行、异常、终结状态  
🔸 转换规则：定义状态间的合法转换路径和触发条件
🔸 补偿映射：每个正向操作都要有对应的补偿动作
🔸 状态持久化：将状态变更保存到数据库，支持故障恢复
🔸 事件驱动：通过事件触发状态转换，实现松耦合设计
```

### 8.2 关键理解要点



**🔹 为什么状态机如此重要**
```
分布式环境下的事务管理复杂性：
• 多个服务参与，协调困难
• 网络故障导致状态不一致  
• 服务重启需要恢复状态

状态机提供的价值：
• 清晰的事务执行路径
• 完善的异常处理机制
• 可靠的故障恢复能力
```

**🔹 设计状态机的思维方式**
```
正向思考：业务正常流程的各个阶段
补偿思考：每步失败后如何回滚
异常思考：各种故障场景的处理
恢复思考：系统重启后如何继续
```

### 8.3 最佳实践建议



**✅ 状态设计原则**
- 状态要有明确的业务含义
- 区分瞬时状态和稳定状态  
- 合理设计终结状态

**✅ 转换规则设计**
- 避免状态转换的环路
- 每个状态都要有失败出口
- 补偿路径要完整

**✅ 持久化策略**
- 状态变更要原子性保存
- 记录完整的变更历史
- 考虑数据清理策略

### 8.4 常见问题与解决



**❌ 常见设计误区**
```
状态过于细粒度：
• 问题：状态太多，转换复杂
• 解决：合并相似状态，简化设计

忽略补偿设计：
• 问题：只考虑正向流程
• 解决：每个操作都设计补偿

状态不持久化：
• 问题：重启后丢失状态
• 解决：及时保存状态变更
```

### 8.5 学习检查清单



- [ ] 理解Saga状态机的基本概念和作用
- [ ] 能够设计合理的业务状态和转换规则
- [ ] 掌握补偿动作的设计原则
- [ ] 了解状态持久化的重要性和实现
- [ ] 熟悉事件驱动的状态机引擎
- [ ] 能够分析和设计实际业务的状态机

**🎯 实践建议**
- 从简单的两步事务开始练习
- 画出状态转换图帮助理解  
- 实现一个完整的订单流程状态机
- 测试各种异常场景的处理

**🔑 核心记忆要点**
> 状态机管长事务，状态转换要清晰
> 正向补偿两条路，持久化保可靠性
> 事件驱动松耦合，异常处理要完善