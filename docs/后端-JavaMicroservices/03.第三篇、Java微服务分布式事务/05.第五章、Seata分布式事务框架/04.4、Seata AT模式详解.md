---
title: 4、Seata AT模式详解
---
## 📚 目录

1. [什么是Seata AT模式](#1-什么是Seata-AT模式)
2. [AT模式核心原理](#2-AT模式核心原理)
3. [数据快照与回滚机制](#3-数据快照与回滚机制)
4. [SQL拦截与自动代理](#4-SQL拦截与自动代理)
5. [冲突检测与数据恢复](#5-冲突检测与数据恢复)
6. [AT模式实践应用](#6-AT模式实践应用)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 什么是Seata AT模式


### 1.1 通俗理解AT模式


**💡 生活类比**
```
想象你在银行转账：
传统方式：你需要手动记录每一步操作，出错时手动撤销
AT模式：银行自动帮你记录，出错时自动帮你恢复

就像有一个"智能助手"在后台默默帮你管理所有事务操作！
```

**🔸 AT模式定义**
- **全称**：Automatic Transaction mode（自动事务模式）
- **本质**：无需修改业务代码就能实现分布式事务
- **核心思想**：自动生成"反悔药"，出错时自动回滚

### 1.2 AT模式的独特优势


**🌟 为什么选择AT模式？**
```
对比其他模式：
┌─────────────┬─────────────┬─────────────┐
│   模式特点   │   业务侵入   │   学习成本   │
├─────────────┼─────────────┼─────────────┤
│ TCC模式     │ 需要大量改码 │    很高     │
│ Saga模式    │ 需要编写补偿 │    较高     │
│ AT模式      │ 几乎无侵入   │    很低     │
└─────────────┴─────────────┴─────────────┘
```

**✅ AT模式核心优势**
- **无业务侵入**：原有代码几乎不用改
- **自动补偿**：框架自动生成回滚逻辑
- **学习成本低**：开发者无需深入了解分布式事务细节
- **性能较好**：相比XA模式，性能损耗更小

### 1.3 AT模式适用场景


**🎪 最佳适用场景**
```
✅ 适合使用：
• 业务逻辑相对简单的CRUD操作
• 希望快速实现分布式事务
• 团队对分布式事务经验有限
• 对性能有一定要求

❌ 不建议使用：
• 非关系型数据库（如MongoDB）
• 业务逻辑极其复杂的场景
• 对数据一致性要求极高的金融核心业务
```

---

## 2. ⚙️ AT模式核心原理


### 2.1 AT模式工作流程


**🔄 完整工作流程图**
```
用户请求 → 业务服务A → 业务服务B → 业务服务C
    ↓           ↓           ↓           ↓
全局事务     本地事务     本地事务     本地事务
开始         执行         执行         执行
    ↓           ↓           ↓           ↓
记录快照     记录快照     记录快照     记录快照
    ↓           ↓           ↓           ↓
    └─────── 全局提交/回滚决策 ────────┘
              ↓           ↓           ↓
           清理快照     清理快照     清理快照
```

**🔸 两阶段提交详解**

**第一阶段：业务执行 + 快照记录**
```
1. 🎬 开始：TM开启全局事务
2. 📸 拦截：拦截业务SQL，生成前置快照
3. 💾 执行：执行真正的业务SQL
4. 📸 拍照：生成后置快照
5. 📝 记录：保存undo_log（回滚日志）
6. ✅ 提交：提交本地事务
```

**第二阶段：全局决策**
```
成功场景：
TM → RM: "可以提交了"
RM: 删除undo_log，释放资源

失败场景：
TM → RM: "需要回滚"
RM: 根据undo_log生成反向SQL执行回滚
```

### 2.2 核心组件职责


**🏗️ AT模式核心组件**
```
┌─ TM (事务管理器) ───────────────┐
│ • 开启全局事务              │
│ • 收集各分支事务状态        │
│ • 做出提交/回滚决策         │
└─────────────────────────────────┘
           ↕️
┌─ RM (资源管理器) ───────────────┐
│ • 拦截SQL生成快照           │
│ • 执行本地事务              │
│ • 根据指令执行回滚          │
└─────────────────────────────────┘
           ↕️
┌─ TC (事务协调器) ───────────────┐
│ • 维护全局事务状态          │
│ • 协调各RM的操作            │
│ • 存储事务日志              │
└─────────────────────────────────┘
```

---

## 3. 📸 数据快照与回滚机制


### 3.1 数据快照机制详解


**🔍 什么是数据快照？**
```
简单理解：就像给数据拍照
• 前置快照：修改前的数据长什么样
• 后置快照：修改后的数据长什么样
• 有了这两张"照片"，就能知道如何恢复数据
```

**📊 快照生成过程**
```java
// 假设执行：UPDATE user SET balance = balance - 100 WHERE id = 1

// 1. 生成前置快照（执行前）
SELECT id, balance FROM user WHERE id = 1;
// 结果：id=1, balance=1000

// 2. 执行业务SQL
UPDATE user SET balance = balance - 100 WHERE id = 1;

// 3. 生成后置快照（执行后）
SELECT id, balance FROM user WHERE id = 1;
// 结果：id=1, balance=900
```

**🗃️ undo_log表结构**
```sql
CREATE TABLE undo_log (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  branch_id BIGINT NOT NULL,           -- 分支事务ID
  xid VARCHAR(100) NOT NULL,           -- 全局事务ID
  rollback_info LONGBLOB NOT NULL,     -- 回滚信息（快照数据）
  log_status INT NOT NULL,             -- 日志状态
  log_created DATETIME NOT NULL,       -- 创建时间
  log_modified DATETIME NOT NULL       -- 修改时间
);
```

### 3.2 回滚日志内容


**📝 undo_log中存储什么？**
```json
{
  "branchId": 12345,
  "sqlUndoLogs": [
    {
      "sqlType": "UPDATE",
      "tableName": "user",
      "beforeImage": {
        "rows": [{"id": 1, "balance": 1000}]
      },
      "afterImage": {
        "rows": [{"id": 1, "balance": 900}]
      }
    }
  ]
}
```

**🔄 自动回滚过程**
```
1. 📖 读取：从undo_log中读取快照数据
2. 🔍 检查：对比当前数据与后置快照
3. ✅ 验证：确认数据没有被其他事务修改
4. 🔄 回滚：根据前置快照生成反向SQL
5. 🗑️ 清理：删除undo_log记录
```

### 3.3 自动生成反向SQL


**⚡ 反向SQL生成示例**
```sql
-- 原始操作：UPDATE user SET balance = 900 WHERE id = 1
-- 自动生成反向SQL：
UPDATE user SET balance = 1000 WHERE id = 1;

-- 原始操作：INSERT INTO user (id, name, balance) VALUES (2, 'Tom', 500)
-- 自动生成反向SQL：
DELETE FROM user WHERE id = 2;

-- 原始操作：DELETE FROM user WHERE id = 3
-- 自动生成反向SQL：
INSERT INTO user (id, name, balance) VALUES (3, 'Jerry', 800);
```

---

## 4. 🔍 SQL拦截与自动代理


### 4.1 SQL拦截机制


**🎯 拦截原理**
```
数据源代理链：
业务代码 → DataSourceProxy → ConnectionProxy → StatementProxy → 实际SQL执行
              ↓                  ↓               ↓
          全局事务管理        连接管理        SQL拦截处理
```

**🔧 核心拦截组件**
```java
// DataSourceProxy：数据源代理
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Primary
    public DataSource dataSource() {
        // 用Seata代理包装原始数据源
        return new DataSourceProxy(originalDataSource);
    }
}
```

### 4.2 自动代理工作流程


**📋 SQL执行完整流程**
```
1. 🎬 开始：业务代码执行SQL
   ↓
2. 🔍 拦截：StatementProxy拦截SQL
   ↓
3. 📊 解析：分析SQL类型（INSERT/UPDATE/DELETE）
   ↓
4. 📸 快照：生成前置快照（SELECT）
   ↓
5. ✅ 执行：执行原始业务SQL
   ↓
6. 📸 快照：生成后置快照（SELECT）
   ↓
7. 💾 保存：将快照数据保存到undo_log
   ↓
8. 🎯 注册：向TC注册分支事务
```

**💡 自动代理的智能之处**
- **透明拦截**：业务代码无感知，自动处理
- **智能解析**：自动识别SQL类型和涉及的表
- **批量优化**：批量操作时优化快照生成
- **异常处理**：SQL执行失败时自动清理资源

---

## 5. ⚡ 冲突检测与数据恢复


### 5.1 冲突检测算法


**🔍 什么是数据冲突？**
```
场景举例：
时间点1：事务A修改用户余额 1000 → 900（生成快照）
时间点2：事务B修改用户余额 900 → 800（其他系统操作）
时间点3：事务A需要回滚，但数据已经不是900了！

这就是数据冲突！
```

**🛡️ 冲突检测机制**
```
检测步骤：
1. 📖 读取当前数据库中的实际数据
2. 🔍 对比后置快照中记录的数据
3. ✅ 如果一致：说明数据未被修改，可以安全回滚
4. ❌ 如果不一致：发生冲突，需要特殊处理
```

**⚙️ 冲突处理策略**
```
┌─ 冲突处理方案 ─────────────────┐
│ 1. 🚫 直接失败：抛出异常      │
│ 2. 🔄 重试机制：等待后重试    │
│ 3. 📞 人工介入：记录日志处理  │
│ 4. 🎯 忽略冲突：强制回滚      │
└────────────────────────────────┘
```

### 5.2 数据恢复过程


**🔄 安全恢复步骤**
```
1. 🔒 加锁：获取行级锁，防止并发修改
   ↓
2. 🔍 检测：执行冲突检测算法
   ↓
3. ✅ 验证：确认数据可以安全恢复
   ↓
4. 🔄 执行：运行反向SQL进行回滚
   ↓
5. 🗑️ 清理：删除undo_log记录
   ↓
6. 🔓 解锁：释放行级锁
```

**💊 数据恢复示例**
```sql
-- 检测冲突（对比当前值与后置快照）
SELECT balance FROM user WHERE id = 1;
-- 当前值：900，后置快照：900 ✅ 无冲突

-- 执行回滚SQL
UPDATE user SET balance = 1000 WHERE id = 1;

-- 验证回滚结果
SELECT balance FROM user WHERE id = 1;
-- 结果：1000 ✅ 恢复成功
```

---

## 6. 🚀 AT模式实践应用


### 6.1 快速上手配置


**📦 基础依赖配置**
```xml
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-spring-boot-starter</artifactId>
    <version>1.6.1</version>
</dependency>
```

**⚙️ 核心配置文件**
```yaml
# application.yml
seata:
  enabled: true
  application-id: order-service
  tx-service-group: my_test_tx_group
  service:
    grouplist:
      default: 127.0.0.1:8091
  
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/seata_order
    username: root
    password: 123456
```

### 6.2 业务代码示例


**💻 简单使用示例**
```java
@Service
public class OrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private AccountService accountService;
    
    // 只需要一个注解！
    @GlobalTransactional
    public void createOrder(Order order) {
        // 1. 创建订单
        orderMapper.insert(order);
        
        // 2. 扣减库存（远程调用）
        storageService.decreaseStorage(order.getProductId(), order.getCount());
        
        // 3. 扣减余额（远程调用）
        accountService.decreaseBalance(order.getUserId(), order.getMoney());
        
        // 任何一步失败，Seata会自动回滚所有操作！
    }
}
```

### 6.3 初始化表结构


**🗃️ undo_log表创建**
```sql
-- 每个业务数据库都需要创建此表
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

---

## 7. 📋 核心要点总结


### 7.1 AT模式精华要点


```
🎯 **核心理解**：
AT模式 = 自动拍快照 + 自动生成反向SQL + 自动执行回滚
就像给每个数据操作都准备了"后悔药"！

🔸 **无业务侵入**：业务代码几乎不用改，只加@GlobalTransactional
🔸 **自动补偿**：框架自动生成回滚逻辑，无需手写补偿代码
🔸 **SQL拦截**：透明拦截所有SQL，自动生成前后快照
🔸 **数据快照**：记录操作前后的数据状态，用于回滚恢复
🔸 **冲突检测**：回滚前检查数据是否被其他事务修改
🔸 **自动回滚**：根据快照自动生成反向SQL实现数据恢复
```

### 7.2 学习记忆技巧


**🧠 记忆口诀**
```
AT模式真简单，快照回滚全自动
SQL拦截透明化，业务代码改得少
冲突检测保安全，数据恢复有保障
```

**🔤 关键概念映射**
```
A - Automatic（自动）
T - Transaction（事务）

核心特点：
📸 Snapshot（快照）
🔄 Rollback（回滚）  
🔍 Intercept（拦截）
✅ Auto（自动）
```

### 7.3 使用建议与注意事项


**✅ 最佳实践**
- 适用于简单的CRUD业务场景
- 确保业务数据库支持事务
- 合理设置超时时间
- 监控undo_log表大小，及时清理

**⚠️ 使用限制**
- 仅支持关系型数据库
- 不支持跨库JOIN操作
- 大批量操作需要注意性能
- 复杂业务逻辑建议用TCC模式

**🎯 适用场景判断**
```
选择AT模式的条件：
☑️ 使用关系型数据库（MySQL、PostgreSQL等）
☑️ 业务逻辑相对简单
☑️ 希望快速实现分布式事务
☑️ 团队技术实力一般
☑️ 对性能有一定要求

不适合AT模式：
❌ 使用NoSQL数据库
❌ 业务逻辑极其复杂
❌ 对数据一致性要求极高
❌ 需要手动控制补偿逻辑
```

### 7.4 技术价值与意义


**🌟 AT模式的技术价值**
- **降低门槛**：让普通开发者也能轻松使用分布式事务
- **提高效率**：大幅减少分布式事务的开发和维护成本
- **保证质量**：自动化机制减少人为错误
- **平滑迁移**：现有项目可以平滑接入分布式事务

**核心记忆**：
- AT模式让分布式事务变得像本地事务一样简单
- 关键在于理解"快照+回滚"的核心思想  
- 适合大部分常见的分布式事务场景
- 是微服务架构中最常用的分布式事务解决方案