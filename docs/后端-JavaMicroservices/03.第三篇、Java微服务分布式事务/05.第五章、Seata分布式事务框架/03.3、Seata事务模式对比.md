---
title: 3、Seata事务模式对比
---
## 📚 目录

1. [Seata分布式事务框架概述](#1-seata分布式事务框架概述)
2. [AT模式-自动补偿事务](#2-at模式-自动补偿事务)
3. [TCC模式-手动补偿事务](#3-tcc模式-手动补偿事务)
4. [Saga模式-长事务处理](#4-saga模式-长事务处理)
5. [XA模式-标准2PC](#5-xa模式-标准2pc)
6. [事务模式对比与选择](#6-事务模式对比与选择)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🌐 Seata分布式事务框架概述


### 1.1 什么是Seata


**简单理解**：Seata就像一个"分布式事务管家"
```
想象场景：网购下单
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   订单服务   │    │   库存服务   │    │   支付服务   │
│  创建订单    │    │  扣减库存    │    │  扣减余额    │
└──────────────┘    └──────────────┘    └──────────────┘
       ↓                    ↓                    ↓
   要么全成功，要么全失败 ← Seata保证这一点
```

**Seata全称**：Simple Extensible Autonomous Transaction Architecture
- **Simple**：使用简单，接入方便
- **Extensible**：可扩展，支持多种模式
- **Autonomous**：自治的，自动处理事务
- **Transaction**：专门处理分布式事务

### 1.2 Seata核心角色


```
Seata架构图：
┌─────────────────────────────────────────────────────────┐
│                    业务系统                              │
├─────────────────────────────────────────────────────────┤
│  订单服务(TM)     库存服务(RM)     支付服务(RM)          │
│      │                │                │               │
│      └────────────────┼────────────────┘               │
│                       │                                 │
├─────────────────────────────────────────────────────────┤
│                  TC(事务协调者)                          │
│              负责全局事务管理                            │
└─────────────────────────────────────────────────────────┘
```

**三大核心角色**：

🔸 **TC (Transaction Coordinator) - 事务协调者**
- 就像"总指挥"，负责管理全局事务
- 记录事务状态，协调提交或回滚
- 独立部署的服务器

🔸 **TM (Transaction Manager) - 事务管理器**
- 就像"发起人"，开始和结束全局事务
- 通常是业务的入口服务
- 告诉TC："开始事务"或"结束事务"

🔸 **RM (Resource Manager) - 资源管理器**
- 就像"执行者"，管理本地资源
- 包装数据库操作
- 向TC报告："我这边成功了"或"我这边失败了"

### 1.3 Seata工作流程


**简化流程**：
```
步骤流程：
1. TM请求TC开启全局事务
2. TC生成全局事务ID(XID)
3. 各个RM执行业务操作，注册分支事务
4. TM请求TC提交或回滚全局事务
5. TC协调所有RM完成最终操作

实际例子：
用户下单购买商品
    ↓
1. 订单服务(TM)：向TC申请开始全局事务
2. TC：分配XID=888888，开始管理
3. 订单服务(RM)：创建订单记录，向TC报告
4. 库存服务(RM)：扣减库存，向TC报告
5. 支付服务(RM)：扣减余额，向TC报告
6. 订单服务(TM)：所有操作成功，请求TC提交事务
7. TC：通知所有RM确认提交，事务完成 ✅
```

---

## 2. 🔄 AT模式-自动补偿事务


### 2.1 AT模式是什么


**通俗理解**：AT模式就像"自动撤销键"

```
类比：文档编辑器的撤销功能
正常操作：输入文字 → 文档改变
出错时：按Ctrl+Z → 自动恢复原状

AT模式：执行SQL → 数据改变
出错时：Seata自动生成反向SQL → 数据恢复原状
```

**AT模式特点**：
- ✅ **自动生成补偿**：不需要手写回滚代码
- ✅ **对业务无侵入**：现有代码几乎不用改
- ✅ **使用简单**：加个注解就能用
- ⚠️ **依赖数据库**：只支持关系型数据库

### 2.2 AT模式工作原理


**核心机制**：前镜像 + 后镜像 + 反向SQL

```
AT模式执行过程：

第一阶段(执行业务)：
┌─────────────────────────────────────────┐
│ 1. 记录前镜像(操作前的数据)              │
│ 2. 执行业务SQL                          │  
│ 3. 记录后镜像(操作后的数据)              │
│ 4. 生成行锁(防止其他事务修改)            │
│ 5. 提交本地事务                         │
└─────────────────────────────────────────┘

第二阶段(提交或回滚)：
成功 → 删除镜像，释放锁 ✅
失败 → 用前镜像恢复数据，释放锁 ↩️
```

**具体例子**：
```sql
-- 业务操作：扣减库存
UPDATE stock SET count = count - 1 WHERE product_id = 100;

-- AT模式自动记录：
前镜像: {product_id:100, count:50}  -- 操作前
后镜像: {product_id:100, count:49}  -- 操作后

-- 如果需要回滚，AT自动生成：
UPDATE stock SET count = 50 WHERE product_id = 100;
-- 恢复到原始状态
```

### 2.3 AT模式使用示例


**配置步骤**：
```java
// 1. 添加Seata依赖
// 2. 配置数据源代理
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        // 使用Seata数据源代理
        return new DataSourceProxy(原始数据源);
    }
}

// 3. 业务方法添加注解
@Service
public class OrderService {
    
    @GlobalTransactional  // 开启全局事务
    public void createOrder(OrderDTO order) {
        // 1. 创建订单
        orderMapper.insert(order);
        
        // 2. 调用库存服务
        stockService.reduceStock(order.getProductId(), order.getCount());
        
        // 3. 调用支付服务  
        paymentService.deductBalance(order.getUserId(), order.getAmount());
        
        // 如果任何一步失败，Seata自动回滚所有操作
    }
}
```

**创建必需的表**：
```sql
-- Seata需要的undo_log表(用于存储镜像数据)
CREATE TABLE undo_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    branch_id BIGINT NOT NULL,
    xid VARCHAR(100) NOT NULL,
    context VARCHAR(128) NOT NULL,
    rollback_info LONGBLOB NOT NULL,
    log_status INT NOT NULL,
    log_created DATETIME NOT NULL,
    log_modified DATETIME NOT NULL
);
```

### 2.4 AT模式适用场景


**✅ 适合的场景**：
- 基于关系型数据库的微服务
- 业务逻辑相对简单
- 希望快速接入分布式事务
- 对数据一致性要求高

**❌ 不适合的场景**：
- 使用NoSQL数据库（MongoDB、Redis等）
- 涉及消息队列、文件操作等非数据库资源
- 对性能要求极高的场景

---

## 3. 🔧 TCC模式-手动补偿事务


### 3.1 TCC模式是什么


**通俗理解**：TCC模式就像"预约机制"

```
生活例子：酒店预订
Try阶段：  预订房间，锁定资源("这个房间给您预留3小时")
Confirm阶段：确认入住，使用资源("正式办理入住手续")  
Cancel阶段： 取消预订，释放资源("取消预订，房间重新开放")
```

**TCC三阶段**：
- **Try**：尝试执行，锁定资源
- **Confirm**：确认执行，使用资源  
- **Cancel**：取消执行，释放资源

### 3.2 TCC模式工作原理


**执行流程**：
```
TCC两阶段提交：

第一阶段 - 预处理：
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   订单服务      │  │   库存服务      │  │   支付服务      │
│ Try:预创建订单   │  │ Try:冻结库存     │  │ Try:冻结金额     │
│ 状态:PREPARE    │  │ 冻结数量:10     │  │ 冻结金额:100    │
└─────────────────┘  └─────────────────┘  └─────────────────┘

第二阶段 - 最终处理：
成功路径 → 所有服务执行Confirm，完成业务
失败路径 → 所有服务执行Cancel，释放资源
```

**具体例子**：
```
电商下单的TCC实现：

Try阶段：
- 订单服务：创建预订单(状态=PREPARE)
- 库存服务：冻结库存(available-10, frozen+10)  
- 支付服务：冻结余额(balance-100, frozen+100)

Confirm阶段(全部成功)：
- 订单服务：订单状态改为SUCCESS
- 库存服务：扣减冻结库存(frozen-10)
- 支付服务：扣减冻结余额(frozen-100)

Cancel阶段(有服务失败)：
- 订单服务：删除预订单
- 库存服务：释放冻结库存(available+10, frozen-10)
- 支付服务：释放冻结余额(balance+100, frozen-100)
```

### 3.3 TCC模式实现示例


**接口定义**：
```java
// TCC接口定义
public interface StockTccService {
    
    // Try：冻结库存
    @TwoPhaseBusinessAction(
        name = "stockTcc",
        commitMethod = "confirm", 
        rollbackMethod = "cancel"
    )
    boolean prepareStock(@BusinessActionContextParameter("productId") Long productId,
                        @BusinessActionContextParameter("count") Integer count);
    
    // Confirm：确认扣减
    boolean confirm(BusinessActionContext context);
    
    // Cancel：释放库存
    boolean cancel(BusinessActionContext context);
}
```

**业务实现**：
```java
@Service
public class StockTccServiceImpl implements StockTccService {
    
    @Override
    public boolean prepareStock(Long productId, Integer count) {
        // Try阶段：冻结库存
        // UPDATE stock SET available = available - #{count}, 
        //                 frozen = frozen + #{count} 
        // WHERE product_id = #{productId} AND available >= #{count}
        
        return stockMapper.freezeStock(productId, count) > 0;
    }
    
    @Override  
    public boolean confirm(BusinessActionContext context) {
        // Confirm阶段：扣减冻结库存
        Long productId = (Long) context.getActionContext("productId");
        Integer count = (Integer) context.getActionContext("count");
        
        // UPDATE stock SET frozen = frozen - #{count} 
        // WHERE product_id = #{productId}
        
        return stockMapper.confirmStock(productId, count) > 0;
    }
    
    @Override
    public boolean cancel(BusinessActionContext context) {
        // Cancel阶段：释放冻结库存
        Long productId = (Long) context.getActionContext("productId");
        Integer count = (Integer) context.getActionContext("count");
        
        // UPDATE stock SET available = available + #{count}, 
        //                 frozen = frozen - #{count} 
        // WHERE product_id = #{productId}
        
        return stockMapper.cancelStock(productId, count) > 0;
    }
}
```

### 3.4 TCC模式适用场景


**✅ 适合的场景**：
- 对数据一致性要求极高
- 业务逻辑复杂，需要精确控制
- 涉及非数据库资源（消息队列、缓存、第三方接口）
- 能够设计冻结/预处理机制

**❌ 不适合的场景**：
- 业务简单，不需要复杂控制
- 开发成本敏感的项目
- 业务无法设计预处理阶段

---

## 4. 📚 Saga模式-长事务处理


### 4.1 Saga模式是什么


**通俗理解**：Saga模式就像"连环任务"

```
类比：旅行计划安排
正向执行：订机票 → 订酒店 → 订门票 → 预约导游
出现问题：取消导游 ← 退门票 ← 退酒店 ← 退机票

Saga模式：执行事务链，每步都有对应的补偿操作
```

**Saga核心思想**：
- 将长事务拆分成多个短事务
- 每个短事务都有对应的补偿操作
- 失败时按相反顺序执行补偿

### 4.2 Saga模式工作原理


**执行方式**：

🔸 **状态机模式(推荐)**：
```
订单处理状态机：
                开始
                 ↓
            [创建订单] → 失败 → [取消订单] → 结束
                 ↓ 成功
            [扣减库存] → 失败 → [恢复库存] → [取消订单] → 结束  
                 ↓ 成功
            [扣减余额] → 失败 → [恢复余额] → [恢复库存] → [取消订单] → 结束
                 ↓ 成功
               完成
```

🔸 **注解模式(简单)**：
```java
@LocalTransactional
@SagaOrchestration  
public void processOrder() {
    // 正向操作链
    createOrder();    // 补偿：cancelOrder()
    reduceStock();    // 补偿：addStock()  
    deductBalance();  // 补偿：addBalance()
}
```

### 4.3 Saga状态机配置


**JSON配置示例**：
```json
{
  "Name": "订单处理流程",
  "Comment": "处理订单的完整流程",
  "StartAt": "创建订单",
  "States": {
    "创建订单": {
      "Type": "ServiceTask", 
      "ServiceName": "orderService",
      "ServiceMethod": "createOrder",
      "CompensateState": "取消订单",
      "Next": "扣减库存"
    },
    "扣减库存": {
      "Type": "ServiceTask",
      "ServiceName": "stockService", 
      "ServiceMethod": "reduceStock",
      "CompensateState": "恢复库存",
      "Next": "扣减余额"
    },
    "扣减余额": {
      "Type": "ServiceTask",
      "ServiceName": "paymentService",
      "ServiceMethod": "deductBalance", 
      "CompensateState": "恢复余额",
      "End": true
    }
  }
}
```

### 4.4 Saga模式适用场景


**✅ 适合的场景**：
- **长流程业务**：订单处理、业务审批等
- **跨系统集成**：涉及多个外部系统  
- **最终一致性可接受**：不要求强一致性
- **业务可补偿**：每个步骤都能设计补偿操作

**❌ 不适合的场景**：
- 要求强一致性的场景
- 补偿操作复杂或无法补偿
- 业务流程简单的场景

---

## 5. ⚡ XA模式-标准2PC


### 5.1 XA模式是什么


**通俗理解**：XA模式就像"集体表决"

```
类比：班级决定去哪里春游
准备阶段：老师问每个同学"你能去XX地方吗？"
表决阶段：所有人都说"可以" → 确定去XX地方
         有人说"不行" → 取消这次春游

XA模式：协调者问各数据库"能提交吗？" 
       都说"可以" → 所有数据库提交
       有说"不行" → 所有数据库回滚
```

**XA特点**：
- ✅ **强一致性**：严格保证ACID特性
- ✅ **标准协议**：基于X/Open XA标准
- ❌ **性能较低**：需要多次网络通信
- ❌ **资源锁定**：事务期间一直锁定资源

### 5.2 XA模式工作原理


**两阶段提交**：
```
XA事务执行流程：

第一阶段(准备阶段)：
TC → 各个数据库："prepare提交吗？"
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 数据库A │  │ 数据库B │  │ 数据库C │  
│"准备好" │  │"准备好" │  │"准备好" │
└─────────┘  └─────────┘  └─────────┘
     ↓            ↓            ↓
  锁定资源    锁定资源    锁定资源

第二阶段(提交阶段)：
情况1 - 都准备好：TC → 各数据库："commit！"
情况2 - 有未准备好：TC → 各数据库："rollback！"
```

### 5.3 XA模式使用示例


**配置示例**：
```java
// XA数据源配置
@Configuration  
public class XAConfig {
    
    @Bean
    public XADataSource orderDataSource() {
        // 配置订单数据库的XA数据源
        DruidXADataSource dataSource = new DruidXADataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/order");
        return dataSource;
    }
    
    @Bean  
    public XADataSource stockDataSource() {
        // 配置库存数据库的XA数据源
        DruidXADataSource dataSource = new DruidXADataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/stock");
        return dataSource;
    }
}

// 业务使用
@Service
public class OrderService {
    
    @GlobalTransactional  // Seata全局事务
    public void createOrder() {
        // 操作订单数据库
        orderMapper.insert(order);
        
        // 操作库存数据库  
        stockMapper.reduceStock(productId, count);
        
        // XA协议保证两个数据库操作的一致性
    }
}
```

### 5.4 XA模式适用场景


**✅ 适合的场景**：
- 金融系统等对一致性要求极高的场景
- 跨数据库的事务操作
- 数据绝对不能不一致

**❌ 不适合的场景**：  
- 高并发、高性能要求的系统
- 分布式系统（网络分区问题）
- 对响应时间敏感的业务

---

## 6. 📊 事务模式对比与选择


### 6.1 四种模式对比表


| 模式特性 | **AT模式** | **TCC模式** | **Saga模式** | **XA模式** |
|---------|-----------|-------------|-------------|-----------|
| **🎯 一致性** | `最终一致性` | `最终一致性` | `最终一致性` | `强一致性` |
| **⚡ 性能** | `高` | `中` | `高` | `低` |
| **🔧 开发复杂度** | `低` | `高` | `中` | `低` |
| **📊 业务侵入性** | `几乎无侵入` | `高侵入` | `中侵入` | `无侵入` |
| **💾 资源锁定** | `短` | `中` | `短` | `长` |
| **🌐 适用范围** | `数据库事务` | `所有资源` | `长流程` | `数据库事务` |

### 6.2 选择决策树


```
选择Seata事务模式的决策流程：

开始选择事务模式
        ↓
    需要强一致性？
       / \
    是 /   \ 否
      /     \
   XA模式   涉及非数据库资源？
             / \
          是 /   \ 否  
            /     \
       TCC模式   长流程业务？
                  / \
               是 /   \ 否
                 /     \
            Saga模式  AT模式
```

### 6.3 实际选择建议


**🚀 新手首选：AT模式**
- 开发简单，接入快速
- 适合80%的业务场景
- 只需加个@GlobalTransactional注解

**⚙️ 复杂业务：TCC模式**  
- 需要精确控制事务流程
- 涉及缓存、MQ、第三方接口
- 能接受较高开发成本

**📈 长流程：Saga模式**
- 订单处理、工作流等长事务
- 业务步骤多，执行时间长
- 能设计补偿操作

**🏦 金融级：XA模式**
- 绝对不能容忍数据不一致
- 性能要求不高
- 经典的数据库事务场景

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Seata角色：TC(协调者)、TM(管理器)、RM(资源管理器)
🔸 AT模式：自动补偿，前后镜像，对业务几乎无侵入
🔸 TCC模式：手动补偿，Try-Confirm-Cancel三阶段
🔸 Saga模式：状态机编排，适合长事务和复杂流程  
🔸 XA模式：标准2PC，强一致性但性能较低
```

### 7.2 关键理解要点


**🔹 选择模式的核心考虑**
```
业务复杂度：简单用AT，复杂用TCC
一致性要求：最终一致性选AT/TCC/Saga，强一致性选XA  
性能要求：高性能选AT/Saga，低性能可用XA
开发成本：低成本选AT/XA，可接受高成本选TCC
```

**🔹 实际项目应用策略**
```
互联网项目：优先AT模式，特殊需求用TCC
金融项目：核心用XA，一般用AT
电商项目：下单流程用AT，复杂优惠计算用TCC
长流程：审批、订单履约等用Saga模式
```

### 7.3 实战应用指南


**新手入门路径**：
1. **从AT模式开始**：简单易用，快速上手
2. **理解分布式事务本质**：数据一致性问题
3. **根据业务需求选择**：不同场景用不同模式
4. **逐步深入TCC和Saga**：解决复杂业务问题

**常见问题处理**：
- **事务超时**：调整超时时间配置
- **死锁问题**：优化SQL，避免长事务
- **性能问题**：考虑异步处理，减少事务范围
- **幂等性**：补偿操作必须支持重复执行

**核心记忆口诀**：
- AT自动补偿用得多，TCC手动控制更精确
- Saga长流程状态机，XA强一致性能低
- 新手首选AT模式，复杂业务看需求