---
title: 3、TCC资源预留策略
---
## 📚 目录

1. [TCC资源预留策略概述](#1-TCC资源预留策略概述)
2. [核心预留模式详解](#2-核心预留模式详解)
3. [预留超时处理机制](#3-预留超时处理机制)
4. [典型业务应用场景](#4-典型业务应用场景)
5. [分布式资源锁定实践](#5-分布式资源锁定实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 TCC资源预留策略概述


### 1.1 什么是资源预留

**简单理解**：就像去餐厅吃饭要先订位子一样
```
现实生活中的预留：
餐厅订座 → 先占个位置 → 到时间去吃饭 → 用餐完毕释放座位

TCC资源预留：
Try阶段 → 先锁定资源 → Confirm确认使用 → 或者Cancel取消释放
```

**🔸 TCC三个阶段的通俗解释**
- **Try（尝试）**：就像试穿衣服，先把衣服拿在手里
- **Confirm（确认）**：试穿合适，决定买下来付钱
- **Cancel（取消）**：试穿不合适，把衣服放回去

### 1.2 为什么需要预留策略

**解决的核心问题**：在分布式系统中，多个操作需要同时成功或同时失败

```
问题场景：网上购物
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   扣减库存      │    │   冻结账户余额   │    │   创建订单      │
│   商品服务      │    │   支付服务      │    │   订单服务      │
│                │    │                │    │                │
│ ❌ 如果任何一个  │    │   操作失败，    │    │   其他已执行的  │
│   操作失败...   │    │   怎么办？      │    │   操作要回滚    │
└─────────────────┘    └─────────────────┘    └─────────────────┘

TCC预留策略解决方案：
第一步(Try)：所有服务都先"预留"资源，但不真正执行
第二步(Confirm/Cancel)：如果所有预留都成功，则确认；否则取消
```

---

## 2. 💰 核心预留模式详解


### 2.1 账户余额预留模式


**🔸 基本原理**
账户余额预留就像银行冻结资金一样
```
用户账户状态变化：
可用余额：1000元 → 600元（冻结400元用于购买）
冻结余额：0元 → 400元
总余额：1000元（不变）

预留成功后：
- 钱还在账户里，但被"冻结"了
- 用户看到可用余额减少了
- 实际钱没有真正扣除
```

**💡 实现思路**
```java
// Try阶段：预留资金
public boolean tryFreeze(String userId, BigDecimal amount) {
    Account account = getAccount(userId);
    
    // 检查余额是否足够
    if (account.getAvailableAmount() >= amount) {
        // 减少可用余额，增加冻结余额
        account.setAvailableAmount(account.getAvailableAmount() - amount);
        account.setFrozenAmount(account.getFrozenAmount() + amount);
        updateAccount(account);
        return true;
    }
    return false; // 余额不足，预留失败
}

// Confirm阶段：真正扣款
public void confirmDeduct(String userId, BigDecimal amount) {
    Account account = getAccount(userId);
    // 从冻结余额中扣除，总余额减少
    account.setFrozenAmount(account.getFrozenAmount() - amount);
    account.setTotalAmount(account.getTotalAmount() - amount);
    updateAccount(account);
}

// Cancel阶段：解冻资金
public void cancelFreeze(String userId, BigDecimal amount) {
    Account account = getAccount(userId);
    // 冻结余额转回可用余额
    account.setFrozenAmount(account.getFrozenAmount() - amount);
    account.setAvailableAmount(account.getAvailableAmount() + amount);
    updateAccount(account);
}
```

### 2.2 库存预留模式


**🔸 库存预留的生活化理解**
就像逛超市时，把商品先放在购物车里：
- 商品在购物车里时，其他人就不能拿了
- 你可以选择去收银台付款（Confirm）
- 也可以选择把商品放回货架（Cancel）

**📊 库存状态管理**
```
商品库存变化：
总库存：100件（不变）
可售库存：100件 → 95件（预留5件）
预留库存：0件 → 5件
```

```java
// Try阶段：预留库存
public boolean tryReserve(String productId, int quantity) {
    Product product = getProduct(productId);
    
    // 检查库存是否充足
    if (product.getAvailableStock() >= quantity) {
        // 减少可售库存，增加预留库存
        product.setAvailableStock(product.getAvailableStock() - quantity);
        product.setReservedStock(product.getReservedStock() + quantity);
        updateProduct(product);
        return true;
    }
    return false; // 库存不足
}

// Confirm阶段：确认出库
public void confirmSell(String productId, int quantity) {
    Product product = getProduct(productId);
    // 从预留库存中扣除，总库存减少
    product.setReservedStock(product.getReservedStock() - quantity);
    product.setTotalStock(product.getTotalStock() - quantity);
    updateProduct(product);
}

// Cancel阶段：释放预留
public void cancelReserve(String productId, int quantity) {
    Product product = getProduct(productId);
    // 预留库存转回可售库存
    product.setReservedStock(product.getReservedStock() - quantity);
    product.setAvailableStock(product.getAvailableStock() + quantity);
    updateProduct(product);
}
```

### 2.3 虚拟资源预留


**🔸 什么是虚拟资源**
虚拟资源是指那些非物理存在但有限制的资源，比如：
- 优惠券使用次数
- 积分兑换额度
- VIP会员特权
- 抽奖机会次数

**💡 虚拟资源预留策略**
```
积分兑换场景：
用户总积分：5000分
本次兑换需要：1000分

Try阶段：
- 可用积分：5000 → 4000（预留1000分）
- 预留积分：0 → 1000

Confirm阶段：
- 真正扣除1000积分
- 发放兑换奖品

Cancel阶段：
- 释放预留的1000积分
```

---

## 3. ⏰ 预留超时处理机制


### 3.1 为什么需要超时处理


**🔸 问题场景**
想象一下：你在餐厅订了座位，但是到了时间没来，餐厅会一直给你留着吗？

```
TCC超时问题：
Try阶段预留了资源 → 但是Confirm/Cancel一直不执行 → 资源永远被锁定

后果：
❌ 资源被长期占用
❌ 其他用户无法使用
❌ 系统性能下降
```

### 3.2 超时处理策略


**🔸 超时检测机制**
```java
// 预留记录包含时间信息
public class ReservationRecord {
    private String reservationId;    // 预留ID
    private String resourceId;       // 资源ID
    private Long amount;             // 预留数量
    private Date createTime;         // 创建时间
    private Date expireTime;         // 过期时间
    private String status;           // 状态：RESERVED, CONFIRMED, CANCELLED
}

// 定时检查过期预留
@Scheduled(fixedDelay = 30000) // 每30秒检查一次
public void checkExpiredReservations() {
    Date now = new Date();
    
    // 查找过期的预留记录
    List<ReservationRecord> expiredRecords = 
        reservationService.findExpiredReservations(now);
    
    for (ReservationRecord record : expiredRecords) {
        // 自动取消过期预留
        try {
            cancelReservation(record.getReservationId());
            log.info("自动取消过期预留: {}", record.getReservationId());
        } catch (Exception e) {
            log.error("取消预留失败: {}", e.getMessage());
        }
    }
}
```

**⏱️ 超时时间设置原则**
```
不同业务的超时时间参考：
┌─────────────────┬─────────────┬─────────────────┐
│ 业务类型         │ 超时时间     │ 设置原因        │
├─────────────────┼─────────────┼─────────────────┤
│ 支付扣款         │ 5-10分钟    │ 用户支付决策时间 │
│ 库存扣减         │ 15-30分钟   │ 购物车结算时间  │
│ 优惠券使用       │ 2-5分钟     │ 优惠券稀缺性    │
│ 秒杀商品         │ 30秒-2分钟  │ 秒杀时效性      │
└─────────────────┴─────────────┴─────────────────┘
```

---

## 4. 🏪 典型业务应用场景


### 4.1 支付冻结扣款场景


**🔸 业务流程说明**
这是最常见的TCC应用场景，就像我们平时网购支付：

```
支付流程图：
用户下单 → 选择支付方式 → 输入支付密码 → 支付成功

TCC实现：
┌─────────────┬─────────────────────────────────────┐
│ Try阶段     │ 冻结用户账户金额（钱还在，但不能用）  │
├─────────────┼─────────────────────────────────────┤
│ Confirm阶段 │ 真正扣款，转账给商家                │
├─────────────┼─────────────────────────────────────┤
│ Cancel阶段  │ 解冻金额，用户可以继续使用          │
└─────────────┴─────────────────────────────────────┘
```

**💳 支付服务实现要点**
```java
public class PaymentTCCService {
    
    // Try: 冻结支付金额
    public boolean tryPay(PaymentRequest request) {
        // 1. 验证账户余额
        if (!hasEnoughBalance(request.getUserId(), request.getAmount())) {
            return false;
        }
        
        // 2. 冻结资金
        freezeAmount(request.getUserId(), request.getAmount());
        
        // 3. 记录预留信息
        recordReservation(request.getTransactionId(), request);
        
        return true;
    }
    
    // Confirm: 完成支付
    public void confirmPay(String transactionId) {
        PaymentReservation reservation = getReservation(transactionId);
        
        // 1. 从冻结金额中扣款
        deductFromFrozen(reservation.getUserId(), reservation.getAmount());
        
        // 2. 转账给收款方
        transferToReceiver(reservation.getReceiverId(), reservation.getAmount());
        
        // 3. 更新预留状态
        updateReservationStatus(transactionId, "CONFIRMED");
    }
    
    // Cancel: 取消支付，解冻资金
    public void cancelPay(String transactionId) {
        PaymentReservation reservation = getReservation(transactionId);
        
        // 解冻资金
        unfreezeAmount(reservation.getUserId(), reservation.getAmount());
        
        // 更新状态
        updateReservationStatus(transactionId, "CANCELLED");
    }
}
```

### 4.2 机票预订场景


**🔸 机票预订的TCC应用**
机票预订是一个典型的需要TCC的场景，因为：
- 机票数量有限（资源稀缺）
- 预订到支付有时间间隔
- 需要保证不会超售

```
机票预订流程：
选择航班 → 填写乘客信息 → 选择座位 → 支付 → 出票

TCC在其中的作用：
┌──────────────────────────────────────────────────────────┐
│ Try阶段：预留机票座位（15分钟内，其他人看不到这个座位）    │
├──────────────────────────────────────────────────────────┤
│ Confirm阶段：支付成功，确认出票，座位正式分配给用户       │
├──────────────────────────────────────────────────────────┤
│ Cancel阶段：支付超时或失败，释放座位给其他用户预订        │
└──────────────────────────────────────────────────────────┘
```

**✈️ 机票预订服务要点**
```java
public class FlightBookingTCCService {
    
    // Try: 预留座位
    public boolean tryBookSeat(BookingRequest request) {
        Flight flight = getFlightInfo(request.getFlightId());
        
        // 检查是否有可用座位
        if (flight.getAvailableSeats() <= 0) {
            return false;
        }
        
        // 预留座位（减少可用座位数）
        flight.setAvailableSeats(flight.getAvailableSeats() - 1);
        flight.setReservedSeats(flight.getReservedSeats() + 1);
        
        // 记录预留信息（设置15分钟过期时间）
        createReservation(request, 15); // 15分钟过期
        
        return true;
    }
    
    // Confirm: 确认出票
    public void confirmBooking(String bookingId) {
        // 生成电子机票
        generateTicket(bookingId);
        
        // 更新座位状态为已售出
        updateSeatStatus(bookingId, "SOLD");
        
        // 发送确认邮件/短信
        sendConfirmation(bookingId);
    }
    
    // Cancel: 取消预订，释放座位
    public void cancelBooking(String bookingId) {
        BookingReservation reservation = getReservation(bookingId);
        Flight flight = getFlightInfo(reservation.getFlightId());
        
        // 释放预留座位
        flight.setReservedSeats(flight.getReservedSeats() - 1);
        flight.setAvailableSeats(flight.getAvailableSeats() + 1);
        
        updateFlightInfo(flight);
    }
}
```

### 4.3 酒店预订场景


**🔸 酒店预订的特殊性**
酒店预订比机票更复杂，因为涉及：
- 房间类型选择
- 入住退房日期
- 价格可能变动
- 取消政策

**🏨 酒店预订TCC实现**
```
酒店预订考虑因素：
┌─────────────────┬─────────────────────────────────────┐
│ 预留时长        │ 通常24小时（比机票更长）             │
├─────────────────┼─────────────────────────────────────┤
│ 价格锁定        │ 预留时锁定当前价格                  │
├─────────────────┼─────────────────────────────────────┤
│ 房间分配        │ 预留房间类型，不预留具体房间号       │
├─────────────────┼─────────────────────────────────────┤
│ 取消政策        │ 根据酒店政策处理取消费用            │
└─────────────────┴─────────────────────────────────────┘
```

---

## 5. 🔒 分布式资源锁定实践


### 5.1 分布式锁的必要性


**🔸 为什么需要分布式锁**
在分布式系统中，多个服务可能同时操作同一个资源：

```
问题场景：两个用户同时购买最后一件商品

时间线：
用户A：查询库存=1 → 准备购买
用户B：查询库存=1 → 准备购买  ← 同时进行
用户A：扣减库存：1→0 → 购买成功
用户B：扣减库存：0→-1 → 也"成功"了？？？

结果：库存变成-1，超售了！
```

**🔒 分布式锁解决方案**
```
加锁后的流程：
用户A：获取分布式锁 → 查询库存=1 → 扣减库存 → 释放锁
用户B：等待锁释放 → 获取锁 → 查询库存=0 → 购买失败 → 释放锁

结果：只有用户A购买成功，避免超售
```

### 5.2 基于Redis的分布式锁实现


**🔸 Redis分布式锁原理**
Redis提供了SET命令的原子性操作，可以实现分布式锁：

```java
public class RedisDistributedLock {
    
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * 获取分布式锁
     * @param lockKey 锁的键
     * @param lockValue 锁的值（唯一标识）
     * @param expireTime 过期时间（秒）
     * @return 是否获取成功
     */
    public boolean tryLock(String lockKey, String lockValue, long expireTime) {
        // 使用SET命令的NX参数（不存在才设置）和EX参数（设置过期时间）
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(expireTime));
        
        return Boolean.TRUE.equals(result);
    }
    
    /**
     * 释放分布式锁（使用Lua脚本保证原子性）
     */
    public boolean releaseLock(String lockKey, String lockValue) {
        String luaScript = 
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";
        
        Long result = redisTemplate.execute(
            RedisScript.of(luaScript, Long.class),
            Arrays.asList(lockKey),
            lockValue
        );
        
        return Long.valueOf(1).equals(result);
    }
}
```

### 5.3 TCC与分布式锁结合使用


**🔸 在TCC的Try阶段使用分布式锁**
```java
public class ProductTCCService {
    
    @Autowired
    private RedisDistributedLock distributedLock;
    
    // Try阶段：预留库存（使用分布式锁）
    public boolean tryReserveStock(String productId, int quantity, String transactionId) {
        String lockKey = "stock:lock:" + productId;
        String lockValue = transactionId; // 使用事务ID作为锁值
        
        // 尝试获取锁（10秒过期）
        boolean lockAcquired = distributedLock.tryLock(lockKey, lockValue, 10);
        
        if (!lockAcquired) {
            log.warn("获取库存锁失败，产品ID：{}", productId);
            return false;
        }
        
        try {
            // 在锁保护下进行库存操作
            Product product = getProduct(productId);
            
            if (product.getAvailableStock() >= quantity) {
                // 预留库存
                product.setAvailableStock(product.getAvailableStock() - quantity);
                product.setReservedStock(product.getReservedStock() + quantity);
                
                updateProduct(product);
                
                // 记录预留信息
                recordReservation(transactionId, productId, quantity);
                
                return true;
            } else {
                return false; // 库存不足
            }
        } finally {
            // 确保释放锁
            distributedLock.releaseLock(lockKey, lockValue);
        }
    }
}
```

**⚡ 分布式锁使用要点**

| **要点** | **说明** | **为什么重要** |
|----------|-----------|---------------|
| **锁的粒度** | 针对具体资源加锁（如specific商品ID） | 避免不必要的竞争，提高并发性 |
| **过期时间** | 设置合理的锁过期时间 | 防止死锁，但不能太短导致业务未完成锁就过期 |
| **锁值唯一** | 使用事务ID或UUID作为锁值 | 确保只有加锁的线程能释放锁 |
| **异常处理** | 在finally块中释放锁 | 确保即使发生异常也能释放锁 |

---

## 6. 📋 核心要点总结


### 6.1 TCC资源预留的核心理念


```
🎯 核心思想：分两步走
第一步：先占坑（Try预留）
第二步：要么确认占用（Confirm），要么让出位置（Cancel）

🔸 好处：避免分布式环境下的资源冲突
🔸 代价：需要额外的状态管理和超时处理
```

### 6.2 各种预留模式对比


| **预留模式** | **适用场景** | **实现难度** | **业务影响** |
|-------------|-------------|-------------|-------------|
| **账户余额预留** | 支付、转账 | ⭐⭐ | 用户能看到余额变化 |
| **库存预留** | 电商、票务 | ⭐⭐⭐ | 影响商品可售数量 |
| **虚拟资源预留** | 积分、优惠券 | ⭐⭐ | 用户体验较好 |
| **座位预留** | 机票、酒店 | ⭐⭐⭐⭐ | 需要复杂的状态管理 |

### 6.3 实施TCC的关键考虑


**🔸 业务设计考虑**
- **幂等性**：同一个操作执行多次结果相同
- **超时处理**：预留资源不能永久占用
- **补偿机制**：失败时能正确回滚
- **状态管理**：清楚地记录每个操作的状态

**🔸 技术实现考虑**
- **分布式锁**：避免并发问题
- **事务日志**：记录操作历史便于排查
- **监控告警**：及时发现异常情况
- **性能优化**：减少网络调用次数

**🔸 运维管理考虑**
- **数据一致性检查**：定期校验预留数据
- **清理机制**：清理过期的预留记录
- **容灾恢复**：系统故障后的恢复策略

### 6.4 最佳实践建议


**✅ 推荐做法**
```
1. 预留超时时间要合理
   - 太短：用户操作来不及
   - 太长：资源长期被占用

2. 状态机要清晰
   - 每个状态都有明确含义
   - 状态转换规则要严格

3. 异常处理要完善
   - 网络故障时的重试机制
   - 数据不一致时的修复方案

4. 监控要全面
   - 预留资源的使用情况
   - 超时取消的频率
   - 系统性能指标
```

**❌ 避免的坑**
```
1. 忘记设置超时时间
   → 导致资源永久被锁定

2. 没有考虑并发安全
   → 可能出现超售问题

3. 缺少幂等性设计
   → 重复操作导致数据错误

4. 忽略网络异常
   → 分布式调用失败时处理不当
```

**🎯 核心记忆要点**
- TCC就像现实生活中的"预约机制"
- Try阶段是"占坑"，Confirm/Cancel是"确认"或"让坑"
- 分布式锁解决并发问题，超时机制防止资源浪费
- 实现要考虑幂等性、异常处理、状态管理
- 不同业务场景选择合适的预留策略