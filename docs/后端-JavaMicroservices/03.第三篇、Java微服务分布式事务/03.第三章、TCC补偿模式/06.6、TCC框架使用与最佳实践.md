---
title: 6、TCC框架使用与最佳实践
---
## 📚 目录

1. [TCC框架基础认知](#1-TCC框架基础认知)
2. [ByteTCC框架深入解析](#2-ByteTCC框架深入解析)
3. [ByteTCC核心组件详解](#3-ByteTCC核心组件详解)
4. [配置与集成实战](#4-配置与集成实战)
5. [注解使用方式详解](#5-注解使用方式详解)
6. [业务拆分策略指南](#6-业务拆分策略指南)
7. [性能优化实用技巧](#7-性能优化实用技巧)
8. [常见陷阱与规避方案](#8-常见陷阱与规避方案)
9. [测试验证完整方法](#9-测试验证完整方法)
10. [监控与日志最佳实践](#10-监控与日志最佳实践)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🎯 TCC框架基础认知


### 1.1 什么是TCC框架


**💡 通俗理解TCC**
想象你在网购时同时买了多件商品，需要同时扣减库存、扣款、积分等。如果其中任何一步失败了，所有操作都要回滚。TCC框架就是帮你协调这些分布式操作的"总指挥"。

```
生活场景类比：
订餐 = Try阶段：预定座位、锁定菜品、预扣款项
确认 = Confirm阶段：正式入座、上菜、确认扣款
取消 = Cancel阶段：释放座位、退菜、退款

TCC就是这个过程的协调者
```

**🔸 TCC三个阶段详解**

**Try阶段**：尝试执行
- **作用**：预留资源，但不真正执行业务
- **特点**：可以失败，失败了直接返回
- **举例**：电商下单时预扣库存，但还没真正减库存

**Confirm阶段**：确认执行
- **作用**：真正执行业务操作
- **特点**：必须成功，因为Try阶段已经预留了资源
- **举例**：确认订单后真正减少库存

**Cancel阶段**：取消执行
- **作用**：释放Try阶段预留的资源
- **特点**：也必须成功，用来清理资源
- **举例**：订单失败后释放之前预扣的库存

### 1.2 为什么需要TCC框架


**🤔 没有TCC框架会怎样**

```
分布式事务场景：用户下单购买商品

步骤1：用户服务 - 扣减用户积分 ✅ 成功
步骤2：库存服务 - 减少商品库存 ✅ 成功  
步骤3：订单服务 - 创建订单记录 ❌ 失败
步骤4：支付服务 - 处理支付请求 ？未执行

问题：前面的操作已经生效，但后面失败了
结果：数据不一致！用户积分被扣了，库存也减了，但订单没创建成功
```

**✅ 有了TCC框架**

```
TCC协调流程：

Try阶段：
- 用户服务：冻结积分（不真扣） ✅
- 库存服务：预扣库存（标记占用） ✅  
- 订单服务：创建预订单 ❌ 失败！

自动触发Cancel阶段：
- 用户服务：解冻积分 ✅
- 库存服务：释放预扣库存 ✅
- 结果：所有服务状态恢复，数据一致
```

### 1.3 TCC框架的核心价值


**🎯 解决的核心问题**
- **数据一致性**：保证分布式环境下数据的最终一致
- **业务完整性**：要么全部成功，要么全部失败
- **资源利用**：通过预留机制提高成功率

**⚡ 优势特点**
- **性能较好**：相比2PC，减少了阻塞时间
- **业务定制**：每个业务可以定制自己的补偿逻辑
- **最终一致**：适合大部分业务场景的一致性要求

---

## 2. 🏗️ ByteTCC框架深入解析


### 2.1 ByteTCC框架介绍


**🔸 什么是ByteTCC**
ByteTCC是一个基于TCC机制的分布式事务框架，就像是给你的微服务系统装了一个"分布式事务管家"，专门负责协调各个服务之间的事务操作。

**🌟 ByteTCC的特色**
- **轻量级**：不需要复杂的配置，上手简单
- **高性能**：采用异步处理，性能表现优秀  
- **Spring集成**：与Spring Boot无缝集成
- **故障恢复**：支持事务日志和故障恢复

### 2.2 ByteTCC架构设计


```
ByteTCC整体架构：

应用层
┌─────────────────────────────────────┐
│  业务服务A   业务服务B   业务服务C    │
│  @TCC注解    @TCC注解    @TCC注解    │
└─────────────────────────────────────┘
               ↓
框架层  
┌─────────────────────────────────────┐
│         ByteTCC事务协调器           │
│  Try/Confirm/Cancel调用管理         │
└─────────────────────────────────────┘
               ↓
存储层
┌─────────────────────────────────────┐
│      事务日志存储（数据库/文件）      │
│       参与者状态管理                │
└─────────────────────────────────────┘
```

### 2.3 ByteTCC工作流程


**🔄 完整事务流程**

```
事务发起 → Try阶段 → 决策阶段 → Confirm/Cancel阶段

详细步骤：
1. 事务管理器创建全局事务ID
2. 依次调用所有参与者的Try方法
3. 如果所有Try都成功，调用Confirm方法
4. 如果任何Try失败，调用Cancel方法
5. 记录事务日志，支持故障恢复
```

---

## 3. 🔧 ByteTCC核心组件详解


### 3.1 事务协调器（Transaction Coordinator）


**🎯 协调器的作用**
事务协调器就像乐队指挥，负责协调所有"乐手"（各个服务）按照节拍（TCC流程）演奏。

**核心职责**：
- **事务生命周期管理**：创建、提交、回滚事务
- **参与者管理**：记录和管理所有参与事务的服务
- **状态跟踪**：跟踪每个参与者的执行状态
- **故障恢复**：系统重启后恢复未完成的事务

### 3.2 事务上下文（Transaction Context）


**📋 上下文内容**
```
事务上下文包含：
- 全局事务ID：唯一标识一次分布式事务
- 参与者列表：记录所有参与的服务和方法
- 事务状态：TRYING、CONFIRMING、CANCELLING等
- 超时设置：防止事务长时间挂起
```

### 3.3 资源管理器（Resource Manager）


**🏪 资源管理职责**
每个业务服务都有自己的资源管理器，负责：
- **业务方法注册**：注册Try/Confirm/Cancel方法
- **本地事务管理**：管理服务内部的数据一致性
- **状态持久化**：保存参与者的执行状态

### 3.4 事务日志（Transaction Log）


**📝 日志的重要性**
就像银行的交易记录一样，事务日志记录了每笔分布式事务的完整信息，确保即使系统故障也能恢复。

**日志内容**：
- 全局事务信息
- 参与者信息
- 执行状态变更
- 时间戳信息

---

## 4. ⚙️ 配置与集成实战


### 4.1 Maven依赖配置


**📦 添加ByteTCC依赖**
```xml
<dependency>
    <groupId>org.bytesoft</groupId>
    <artifactId>bytetcc-core</artifactId>
    <version>0.5.16</version>
</dependency>

<dependency>
    <groupId>org.bytesoft</groupId>
    <artifactId>bytetcc-supports</artifactId>
    <version>0.5.16</version>
</dependency>
```

### 4.2 Spring Boot集成配置


**🔧 主配置类设置**
```java
@Configuration
@EnableTransactionManagement
@EnableByteTransaction  // 启用ByteTCC
public class TransactionConfig {
    
    // 配置事务管理器
    @Bean
    public TransactionCoordinator transactionCoordinator() {
        return new TransactionCoordinatorImpl();
    }
    
    // 配置事务日志存储
    @Bean
    public TransactionRepository transactionRepository() {
        // 可以选择数据库存储或文件存储
        return new JdbcTransactionRepository();
    }
}
```

### 4.3 数据库配置


**📊 事务日志表创建**
ByteTCC需要创建几张表来存储事务信息：

```sql
-- 全局事务表
CREATE TABLE BYTETCC_TRANSACTION (
    XID VARCHAR(32) PRIMARY KEY,
    GLOBAL_TX_ID VARCHAR(32),
    BRANCH_QUALIFIER VARCHAR(32),
    STATUS INTEGER,
    CREATED_TIME TIMESTAMP,
    UPDATED_TIME TIMESTAMP
);

-- 参与者信息表  
CREATE TABLE BYTETCC_PARTICIPANT (
    XID VARCHAR(32),
    PARTICIPANT_ID VARCHAR(64),
    CLASS_NAME VARCHAR(256),
    METHOD_NAME VARCHAR(64),
    CREATED_TIME TIMESTAMP
);
```

### 4.4 配置文件设置


**📝 application.yml配置**
```yaml
bytetcc:
  # 事务超时时间（毫秒）
  timeout: 30000
  
  # 事务日志存储配置
  repository:
    type: jdbc  # 或者 file
    
  # 故障恢复配置
  recovery:
    enabled: true
    interval: 60000  # 恢复检查间隔
    
  # 性能优化配置
  optimization:
    async-confirm: true  # 异步确认
    batch-size: 100     # 批处理大小
```

---

## 5. 🏷️ 注解使用方式详解


### 5.1 @TCC注解基础用法


**🔸 注解定义TCC方法**
```java
@Service
public class OrderService {
    
    @TCC(
        confirmMethod = "confirmCreateOrder",
        cancelMethod = "cancelCreateOrder"
    )
    public void createOrder(OrderInfo order) {
        // Try阶段：预创建订单
        System.out.println("Try: 创建预订单 " + order.getOrderId());
        // 这里只做预处理，比如校验参数、预占资源
        validateOrder(order);
        preCreateOrder(order);
    }
    
    // Confirm方法：确认创建订单
    public void confirmCreateOrder(OrderInfo order) {
        System.out.println("Confirm: 确认创建订单 " + order.getOrderId());
        // 真正创建订单
        saveOrderToDatabase(order);
    }
    
    // Cancel方法：取消创建订单
    public void cancelCreateOrder(OrderInfo order) {
        System.out.println("Cancel: 取消创建订单 " + order.getOrderId());
        // 清理预创建的数据
        cleanupPreOrder(order);
    }
}
```

### 5.2 注解参数详解


**⚙️ @TCC注解参数说明**

| 参数 | 说明 | 示例 | 默认值 |
|-----|------|------|--------|
| **confirmMethod** | Confirm阶段方法名 | `"confirmCreateOrder"` | 必填 |
| **cancelMethod** | Cancel阶段方法名 | `"cancelCreateOrder"` | 必填 |
| **timeout** | 事务超时时间(毫秒) | `30000` | 30秒 |
| **propagation** | 事务传播行为 | `REQUIRED` | REQUIRED |

### 5.3 方法签名要求


**📝 重要约定**
```java
// Try、Confirm、Cancel三个方法必须满足：
// 1. 参数列表完全相同
// 2. 访问权限为public
// 3. 在同一个类中定义

@TCC(confirmMethod = "doConfirm", cancelMethod = "doCancel")
public String doTry(Long userId, BigDecimal amount) {
    // Try逻辑
    return "success";
}

// ✅ 正确：参数完全相同
public void doConfirm(Long userId, BigDecimal amount) {
    // Confirm逻辑
}

public void doCancel(Long userId, BigDecimal amount) {
    // Cancel逻辑  
}

// ❌ 错误：参数不匹配
public void doConfirm(Long userId) {  // 缺少amount参数
    // 这样会导致运行时错误
}
```

### 5.4 实际业务示例


**💰 账户服务示例**
```java
@Service
public class AccountService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    @TCC(
        confirmMethod = "confirmDeduct",
        cancelMethod = "cancelDeduct",
        timeout = 10000
    )
    public boolean deductBalance(Long userId, BigDecimal amount) {
        System.out.println("Try: 尝试扣减余额");
        
        Account account = accountRepository.findByUserId(userId);
        if (account.getBalance().compareTo(amount) < 0) {
            throw new RuntimeException("余额不足");
        }
        
        // Try阶段：冻结金额，不实际扣减
        account.setFrozenAmount(account.getFrozenAmount().add(amount));
        accountRepository.save(account);
        
        return true;
    }
    
    public void confirmDeduct(Long userId, BigDecimal amount) {
        System.out.println("Confirm: 确认扣减余额");
        
        Account account = accountRepository.findByUserId(userId);
        // 实际扣减余额
        account.setBalance(account.getBalance().subtract(amount));
        // 释放冻结金额
        account.setFrozenAmount(account.getFrozenAmount().subtract(amount));
        accountRepository.save(account);
    }
    
    public void cancelDeduct(Long userId, BigDecimal amount) {
        System.out.println("Cancel: 取消扣减余额");
        
        Account account = accountRepository.findByUserId(userId);
        // 释放冻结金额
        account.setFrozenAmount(account.getFrozenAmount().subtract(amount));
        accountRepository.save(account);
    }
}
```

---

## 6. 📐 业务拆分策略指南


### 6.1 业务拆分原则


**🎯 拆分的核心思路**
把一个复杂的业务操作拆分成多个独立的、可补偿的小操作，就像把一个大任务分解成多个小任务，每个小任务都能独立完成和回滚。

**核心原则**：
- **原子性**：每个TCC操作应该是一个完整的业务单元
- **独立性**：各个操作之间不应该有强依赖关系
- **可补偿**：每个操作都必须能够被撤销
- **幂等性**：同样的操作执行多次结果应该相同

### 6.2 电商下单业务拆分示例


**🛍️ 传统单体业务**
```java
// ❌ 不好的做法：把所有业务逻辑放在一个方法中
public void createOrder(OrderRequest request) {
    // 所有操作在一个事务中
    deductInventory(request.getProductId(), request.getQuantity());
    deductBalance(request.getUserId(), request.getAmount());
    createOrderRecord(request);
    sendNotification(request);
    updateUserPoints(request.getUserId(), request.getPoints());
}
```

**✅ TCC拆分后的业务**
```java
@Service
public class OrderCoordinator {
    
    @Autowired
    private InventoryService inventoryService;
    @Autowired  
    private AccountService accountService;
    @Autowired
    private OrderService orderService;
    
    @TCC(
        confirmMethod = "confirmCreateOrder",
        cancelMethod = "cancelCreateOrder"
    )
    public void createOrder(OrderRequest request) {
        // Try阶段：协调各个服务的Try操作
        
        // 1. 预扣库存
        inventoryService.reserveInventory(
            request.getProductId(), 
            request.getQuantity()
        );
        
        // 2. 冻结余额
        accountService.freezeBalance(
            request.getUserId(), 
            request.getAmount()
        );
        
        // 3. 创建预订单
        orderService.createPreOrder(request);
        
        // 4. 预扣积分
        pointService.reservePoints(
            request.getUserId(), 
            request.getPoints()
        );
    }
    
    public void confirmCreateOrder(OrderRequest request) {
        // Confirm阶段：确认所有操作
        inventoryService.confirmReserveInventory(request.getProductId(), request.getQuantity());
        accountService.confirmFreezeBalance(request.getUserId(), request.getAmount());  
        orderService.confirmCreatePreOrder(request);
        pointService.confirmReservePoints(request.getUserId(), request.getPoints());
    }
    
    public void cancelCreateOrder(OrderRequest request) {
        // Cancel阶段：回滚所有操作
        inventoryService.cancelReserveInventory(request.getProductId(), request.getQuantity());
        accountService.cancelFreezeBalance(request.getUserId(), request.getAmount());
        orderService.cancelCreatePreOrder(request);  
        pointService.cancelReservePoints(request.getUserId(), request.getPoints());
    }
}
```

### 6.3 拆分粒度控制


**🔍 合适的拆分粒度**

```
粒度太粗的问题：
┌─────────────────────────┐
│   一个TCC操作包含：      │  
│   - 扣库存              │
│   - 扣余额              │
│   - 创建订单            │ ← 太多业务逻辑在一起
│   - 发送通知            │   难以精确控制
└─────────────────────────┘

粒度太细的问题：
┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
│扣库存1│ │扣库存2│ │扣余额1│ │扣余额2│  ← 操作太碎片化
└──────┘ └──────┘ └──────┘ └──────┘    协调成本过高

合适的粒度：
┌──────────┐ ┌──────────┐ ┌──────────┐
│  库存服务  │ │  账户服务  │ │  订单服务  │ ← 按业务域拆分
│  TCC操作   │ │  TCC操作   │ │  TCC操作   │   职责清晰
└──────────┘ └──────────┘ └──────────┘
```

### 6.4 跨服务依赖处理


**🔄 处理服务间依赖关系**

**场景**：创建订单需要先验证用户信息
```java
// ❌ 错误做法：在TCC中调用其他服务查询
@TCC(confirmMethod = "confirmCreate", cancelMethod = "cancelCreate")
public void createOrder(OrderRequest request) {
    // 不要在TCC方法中调用远程查询！
    User user = userService.getUser(request.getUserId());  // 危险操作
    if (user == null) {
        throw new RuntimeException("用户不存在");
    }
    // ... 其他逻辑
}

// ✅ 正确做法：在调用TCC之前完成验证
@Service
public class OrderFacade {
    
    public void processOrder(OrderRequest request) {
        // 1. 先做所有的查询和验证
        User user = userService.getUser(request.getUserId());
        if (user == null) {
            throw new RuntimeException("用户不存在");
        }
        
        Product product = productService.getProduct(request.getProductId());
        if (product == null) {
            throw new RuntimeException("商品不存在");
        }
        
        // 2. 验证通过后，再开始TCC事务
        orderCoordinator.createOrder(request);
    }
}
```

---

## 7. ⚡ 性能优化实用技巧


### 7.1 异步执行优化


**🚀 异步Confirm/Cancel**
```java
// 配置异步执行
@Configuration  
public class ByteTCCConfig {
    
    @Bean
    public AsyncConfirmExecutor asyncConfirmExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("TCC-Async-");
        executor.initialize();
        return new AsyncConfirmExecutor(executor);
    }
}

// 在业务代码中使用异步
@TCC(
    confirmMethod = "confirmTransfer",
    cancelMethod = "cancelTransfer",
    asyncConfirm = true  // 启用异步确认
)
public void transfer(Long fromUser, Long toUser, BigDecimal amount) {
    // Try逻辑...
}
```

### 7.2 批处理优化


**📦 批量处理TCC操作**
```java
@Service
public class BatchOrderService {
    
    // 批量处理订单
    @TCC(
        confirmMethod = "confirmBatchOrders",
        cancelMethod = "cancelBatchOrders"
    )
    public void processBatchOrders(List<OrderRequest> orders) {
        // Try阶段：批量预处理
        for (OrderRequest order : orders) {
            validateOrder(order);
            preCreateOrder(order);
        }
    }
    
    public void confirmBatchOrders(List<OrderRequest> orders) {
        // Confirm阶段：批量确认
        batchInsertOrders(orders);  // 一次性插入所有订单
    }
}
```

### 7.3 超时时间调优


**⏰ 合理设置超时时间**
```java
// 根据业务特点设置不同的超时时间

// 快速业务：库存操作
@TCC(
    confirmMethod = "confirmReserve",
    cancelMethod = "cancelReserve", 
    timeout = 5000  // 5秒超时
)
public void reserveInventory(Long productId, Integer quantity) {
    // 库存操作通常很快
}

// 慢速业务：支付操作
@TCC(
    confirmMethod = "confirmPayment",
    cancelMethod = "cancelPayment",
    timeout = 30000  // 30秒超时
)  
public void processPayment(PaymentRequest request) {
    // 支付可能需要调用第三方，时间较长
}
```

### 7.4 连接池优化


**🏊 数据库连接池调优**
```yaml
# application.yml
spring:
  datasource:
    hikari:
      # TCC框架会频繁访问事务日志表
      maximum-pool-size: 20      # 增加连接池大小
      minimum-idle: 5            # 最小空闲连接
      connection-timeout: 30000  # 连接超时时间
      idle-timeout: 600000       # 空闲超时时间
```

### 7.5 事务日志优化


**📝 日志存储优化策略**
```java
@Configuration
public class TransactionLogConfig {
    
    // 使用Redis作为事务日志缓存
    @Bean
    public RedisTransactionLogCache transactionLogCache() {
        RedisTransactionLogCache cache = new RedisTransactionLogCache();
        cache.setExpireTime(3600);  // 1小时过期
        return cache;
    }
    
    // 定时清理历史日志
    @Scheduled(cron = "0 0 2 * * ?")  // 每天凌晨2点清理
    public void cleanupTransactionLogs() {
        // 清理7天前的事务日志
        transactionLogService.cleanup(7);
    }
}
```

---

## 8. ⚠️ 常见陷阱与规避方案


### 8.1 幂等性问题


**🔄 幂等性陷阱**
```java
// ❌ 问题代码：没有考虑幂等性
@TCC(confirmMethod = "confirmAddPoints", cancelMethod = "cancelAddPoints")
public void addUserPoints(Long userId, Integer points) {
    // Try阶段：预增加积分
    User user = userRepository.findById(userId);
    user.setPoints(user.getPoints() + points);  // 危险！重复执行会累加
    userRepository.save(user);
}

// ✅ 正确做法：使用事务ID保证幂等性
@TCC(confirmMethod = "confirmAddPoints", cancelMethod = "cancelAddPoints")
public void addUserPoints(Long userId, Integer points) {
    String transactionId = TransactionContext.getCurrentTransactionId();
    
    // 检查是否已经执行过
    if (pointsLogRepository.existsByTransactionId(transactionId)) {
        return;  // 已经执行过，直接返回
    }
    
    // 记录操作日志
    PointsLog log = new PointsLog();
    log.setTransactionId(transactionId);
    log.setUserId(userId);
    log.setPoints(points);
    log.setOperation("TRY");
    pointsLogRepository.save(log);
    
    // 执行业务逻辑
    User user = userRepository.findById(userId);
    user.setPoints(user.getPoints() + points);
    userRepository.save(user);
}
```

### 8.2 空回滚和悬挂问题


**🕳️ 空回滚陷阱**
```java
// 空回滚：Try阶段没有执行，但Cancel被调用了
// 原因：网络问题导致Try请求丢失，但框架触发了Cancel

// ✅ 防空回滚的正确做法
public void cancelDeductBalance(Long userId, BigDecimal amount) {
    String transactionId = TransactionContext.getCurrentTransactionId();
    
    // 检查Try阶段是否执行过
    OperationLog tryLog = operationLogRepository
        .findByTransactionIdAndOperation(transactionId, "TRY");
    
    if (tryLog == null) {
        // 空回滚情况：Try没执行过，记录Cancel但不做实际操作
        OperationLog cancelLog = new OperationLog();
        cancelLog.setTransactionId(transactionId);  
        cancelLog.setOperation("CANCEL");
        cancelLog.setStatus("EMPTY_ROLLBACK");
        operationLogRepository.save(cancelLog);
        return;
    }
    
    // 正常回滚逻辑
    doActualCancel(userId, amount);
}
```

### 8.3 资源悬挂陷阱


**🏗️ 悬挂问题处理**
```java
// 悬挂：Cancel先于Try执行，导致资源永久占用

public boolean deductBalance(Long userId, BigDecimal amount) {
    String transactionId = TransactionContext.getCurrentTransactionId();
    
    // 检查是否已经Cancel过了
    OperationLog cancelLog = operationLogRepository
        .findByTransactionIdAndOperation(transactionId, "CANCEL");
    
    if (cancelLog != null) {
        // 已经Cancel过了，Try不应该再执行
        throw new RuntimeException("事务已被取消，Try操作被拒绝");
    }
    
    // 正常Try逻辑
    return doActualTry(userId, amount);
}
```

### 8.4 数据一致性陷阱


**🔐 数据库事务边界**
```java
// ❌ 错误：Try/Confirm/Cancel跨越了本地事务边界
@TCC(confirmMethod = "confirmTransfer", cancelMethod = "cancelTransfer")
@Transactional  // 危险！TCC方法不应该加@Transactional
public void transferMoney(Long fromUser, Long toUser, BigDecimal amount) {
    // 这样会导致Try和Confirm在不同的数据库事务中
}

// ✅ 正确：在TCC方法内部管理事务
@TCC(confirmMethod = "confirmTransfer", cancelMethod = "cancelTransfer")
public void transferMoney(Long fromUser, Long toUser, BigDecimal amount) {
    // 使用编程式事务管理
    transactionTemplate.execute(status -> {
        // Try阶段的数据库操作
        freezeBalance(fromUser, amount);
        return null;
    });
}
```

---

## 9. 🧪 测试验证完整方法


### 9.1 单元测试策略


**🔬 TCC方法单元测试**
```java
@TestMethodOrder(OrderAnnotation.class)
class OrderServiceTest {
    
    @Mock
    private OrderRepository orderRepository;
    
    @InjectMocks
    private OrderService orderService;
    
    @Test
    @Order(1)
    void testTryCreateOrder() {
        // 准备测试数据
        OrderRequest request = new OrderRequest();
        request.setUserId(1L);
        request.setProductId(1L);
        request.setQuantity(2);
        
        // 执行Try方法
        assertDoesNotThrow(() -> {
            orderService.createOrder(request);
        });
        
        // 验证预订单是否创建
        verify(orderRepository).save(argThat(order -> 
            order.getStatus() == OrderStatus.PENDING));
    }
    
    @Test  
    @Order(2)
    void testConfirmCreateOrder() {
        // 测试Confirm方法
        OrderRequest request = new OrderRequest();
        request.setUserId(1L);
        
        orderService.confirmCreateOrder(request);
        
        // 验证订单状态是否变为确认
        verify(orderRepository).updateStatus(1L, OrderStatus.CONFIRMED);
    }
    
    @Test
    @Order(3)  
    void testCancelCreateOrder() {
        // 测试Cancel方法  
        OrderRequest request = new OrderRequest();
        request.setUserId(1L);
        
        orderService.cancelCreateOrder(request);
        
        // 验证订单是否被删除或标记为取消
        verify(orderRepository).updateStatus(1L, OrderStatus.CANCELLED);
    }
}
```

### 9.2 集成测试方案


**🔗 分布式事务集成测试**
```java
@SpringBootTest
@TestPropertySource(properties = {
    "bytetcc.enabled=true",
    "spring.datasource.url=jdbc:h2:mem:testdb"
})
class DistributedTransactionIntegrationTest {
    
    @Autowired
    private OrderCoordinator orderCoordinator;
    
    @Autowired
    private AccountService accountService;
    
    @Test
    void testSuccessfulDistributedTransaction() {
        // 准备测试数据
        setupTestUser(1L, new BigDecimal("1000"));
        setupTestProduct(1L, 100);
        
        OrderRequest request = new OrderRequest();
        request.setUserId(1L);
        request.setProductId(1L); 
        request.setQuantity(2);
        request.setAmount(new BigDecimal("200"));
        
        // 执行分布式事务
        assertDoesNotThrow(() -> {
            orderCoordinator.createOrder(request);
        });
        
        // 验证最终结果
        Account account = accountService.getAccount(1L);
        assertEquals(new BigDecimal("800"), account.getBalance());
        
        Product product = productService.getProduct(1L);
        assertEquals(98, product.getStock());
    }
    
    @Test
    void testFailedDistributedTransaction() {
        // 准备余额不足的场景
        setupTestUser(1L, new BigDecimal("50"));  // 余额不足
        setupTestProduct(1L, 100);
        
        OrderRequest request = new OrderRequest();
        request.setAmount(new BigDecimal("200"));  // 超过余额
        
        // 执行应该失败的事务
        assertThrows(InsufficientBalanceException.class, () -> {
            orderCoordinator.createOrder(request);
        });
        
        // 验证所有操作都回滚了
        Account account = accountService.getAccount(1L);
        assertEquals(new BigDecimal("50"), account.getBalance());  // 余额不变
        
        Product product = productService.getProduct(1L);
        assertEquals(100, product.getStock());  // 库存不变
    }
}
```

### 9.3 故障注入测试


**💥 模拟各种异常场景**
```java
@Test
void testNetworkFailureDuringConfirm() {
    // 模拟Confirm阶段网络故障
    
    // 1. 先成功执行Try阶段
    OrderRequest request = createTestOrderRequest();
    orderCoordinator.createOrder(request);
    
    // 2. 模拟网络异常
    mockNetworkFailure(accountService);
    
    // 3. 触发Confirm，应该能够重试成功
    TransactionRecoveryService recoveryService = 
        applicationContext.getBean(TransactionRecoveryService.class);
    
    recoveryService.recoverPendingTransactions();
    
    // 4. 验证最终一致性
    eventually(() -> {
        Account account = accountService.getAccount(request.getUserId());
        assertNotEquals(account.getFrozenAmount(), BigDecimal.ZERO);
    });
}
```

### 9.4 性能测试


**⚡ TCC框架性能测试**
```java
@Test
void testTCCPerformance() {
    int concurrentUsers = 100;
    int operationsPerUser = 10;
    
    ExecutorService executor = Executors.newFixedThreadPool(concurrentUsers);
    CountDownLatch latch = new CountDownLatch(concurrentUsers);
    
    long startTime = System.currentTimeMillis();
    
    for (int i = 0; i < concurrentUsers; i++) {
        final int userId = i;
        executor.submit(() -> {
            try {
                for (int j = 0; j < operationsPerUser; j++) {
                    OrderRequest request = createTestOrderRequest(userId);
                    orderCoordinator.createOrder(request);
                }
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await();
    long endTime = System.currentTimeMillis();
    
    long totalOperations = concurrentUsers * operationsPerUser;
    double tps = totalOperations * 1000.0 / (endTime - startTime);
    
    System.out.println("TPS: " + tps);
    assertTrue(tps > 100, "TPS should be greater than 100");
}
```

---

## 10. 📊 监控与日志最佳实践


### 10.1 事务监控指标


**📈 核心监控指标**
```java
@Component
public class TCCMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter tccTryCounter;
    private final Counter tccConfirmCounter;
    private final Counter tccCancelCounter;
    private final Timer tccDurationTimer;
    
    public TCCMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.tccTryCounter = Counter.builder("tcc.try.count")
            .description("TCC Try阶段执行次数")
            .register(meterRegistry);
            
        this.tccConfirmCounter = Counter.builder("tcc.confirm.count")
            .description("TCC Confirm阶段执行次数") 
            .register(meterRegistry);
            
        this.tccCancelCounter = Counter.builder("tcc.cancel.count")
            .description("TCC Cancel阶段执行次数")
            .register(meterRegistry);
            
        this.tccDurationTimer = Timer.builder("tcc.duration")
            .description("TCC事务执行时间")
            .register(meterRegistry);
    }
    
    public void recordTryExecution() {
        tccTryCounter.increment();
    }
    
    public void recordTransactionDuration(Duration duration) {
        tccDurationTimer.record(duration);
    }
}
```

### 10.2 结构化日志记录


**📝 详细的日志记录策略**
```java
@Aspect
@Component
public class TCCLoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(TCCLoggingAspect.class);
    
    @Around("@annotation(tcc)")
    public Object logTCCExecution(ProceedingJoinPoint joinPoint, TCC tcc) throws Throwable {
        String transactionId = TransactionContext.getCurrentTransactionId();
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        // Try阶段日志
        logger.info("TCC Try开始 - 事务ID: {}, 方法: {}, 参数: {}", 
            transactionId, methodName, Arrays.toString(args));
        
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("TCC Try成功 - 事务ID: {}, 方法: {}, 耗时: {}ms", 
                transactionId, methodName, duration);
            
            return result;
            
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            logger.error("TCC Try失败 - 事务ID: {}, 方法: {}, 耗时: {}ms, 异常: {}", 
                transactionId, methodName, duration, e.getMessage(), e);
            throw e;
        }
    }
}
```

### 10.3 事务状态可视化


**📊 事务状态监控面板**
```java
@RestController
@RequestMapping("/tcc/monitor")
public class TCCMonitorController {
    
    @Autowired
    private TransactionRepository transactionRepository;
    
    @GetMapping("/dashboard")
    public Map<String, Object> getDashboard() {
        Map<String, Object> dashboard = new HashMap<>();
        
        // 统计各状态的事务数量
        dashboard.put("tryingCount", transactionRepository.countByStatus("TRYING"));
        dashboard.put("confirmingCount", transactionRepository.countByStatus("CONFIRMING"));
        dashboard.put("cancellingCount", transactionRepository.countByStatus("CANCELLING"));
        dashboard.put("completedCount", transactionRepository.countByStatus("COMPLETED"));
        
        // 最近的事务列表
        List<Transaction> recentTransactions = transactionRepository
            .findTop10ByOrderByCreatedTimeDesc();
        dashboard.put("recentTransactions", recentTransactions);
        
        return dashboard;
    }
    
    @GetMapping("/transaction/{transactionId}")
    public TransactionDetail getTransactionDetail(@PathVariable String transactionId) {
        // 获取事务详细信息，包括所有参与者的状态
        return transactionService.getTransactionDetail(transactionId);
    }
}
```

### 10.4 异常告警机制


**🚨 实时异常告警**
```java
@Component
public class TCCAlertService {
    
    @Value("${tcc.alert.cancel-rate-threshold:0.1}")
    private double cancelRateThreshold;
    
    @Scheduled(fixedRate = 60000)  // 每分钟检查一次
    public void checkTransactionHealth() {
        // 计算最近一小时的取消率
        long totalTransactions = transactionRepository
            .countByCreatedTimeBetween(oneHourAgo(), now());
            
        long cancelledTransactions = transactionRepository
            .countByStatusAndCreatedTimeBetween("CANCELLED", oneHourAgo(), now());
        
        if (totalTransactions > 0) {
            double cancelRate = (double) cancelledTransactions / totalTransactions;
            
            if (cancelRate > cancelRateThreshold) {
                // 发送告警
                alertService.sendAlert(
                    AlertLevel.WARNING,
                    "TCC事务取消率过高",
                    String.format("当前取消率: %.2f%%, 阈值: %.2f%%", 
                        cancelRate * 100, cancelRateThreshold * 100)
                );
            }
        }
    }
    
    @EventListener
    public void handleTransactionTimeout(TransactionTimeoutEvent event) {
        // 事务超时告警
        alertService.sendAlert(
            AlertLevel.ERROR,
            "TCC事务超时",
            "事务ID: " + event.getTransactionId() + ", 超时时间: " + event.getTimeout()
        );
    }
}
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的基本概念


```
🔸 TCC核心理念：Try-Confirm-Cancel三阶段事务模式
🔸 ByteTCC框架：基于注解的轻量级TCC实现框架
🔸 事务协调器：负责协调分布式事务的核心组件
🔸 业务拆分：将复杂业务拆解为可补偿的独立操作
🔸 幂等性设计：确保重复执行不会产生副作用
```

### 11.2 关键理解要点


**🔹 TCC与传统事务的区别**
```
传统数据库事务：
- 基于ACID特性，强一致性
- 适用于单体应用
- 锁资源时间长，并发性能差

TCC分布式事务：
- 基于补偿机制，最终一致性
- 适用于微服务架构
- 预留资源模式，并发性能好
```

**🔹 成功实施TCC的关键因素**
```
业务设计：
✅ 合理的业务拆分策略
✅ 完善的补偿逻辑设计
✅ 充分的幂等性考虑

技术实现：
✅ 正确的框架配置
✅ 完善的异常处理
✅ 全面的监控日志

运维保障：
✅ 故障恢复机制
✅ 性能调优策略
✅ 及时的异常告警
```

### 11.3 实践建议与最佳实践


**💡 开发阶段建议**
```
设计原则：
- 业务拆分要合理，避免过细或过粗
- 每个TCC操作都要考虑幂等性
- Confirm和Cancel方法必须能够成功执行
- 避免在TCC方法中进行远程调用

代码实现：
- 使用事务ID确保操作幂等性
- 合理设置事务超时时间
- 做好异常处理和日志记录
- 编写完善的单元测试和集成测试
```

**⚡ 性能优化建议**
```
配置优化：
- 启用异步Confirm提高性能
- 合理配置线程池大小
- 优化数据库连接池配置
- 定期清理历史事务日志

监控告警：
- 监控事务成功率和执行时间
- 设置取消率过高的告警
- 监控系统资源使用情况
- 建立完善的日志分析体系
```

### 11.4 常见问题速查


```
问题：Try方法重复执行
解决：使用事务ID确保幂等性

问题：Confirm/Cancel方法执行失败
解决：这些方法必须设计为可重试的

问题：事务长时间挂起
解决：设置合理的超时时间，启用故障恢复

问题：性能不达预期
解决：启用异步执行，优化数据库配置

问题：监控数据不完整
解决：添加完善的指标收集和日志记录
```

**核心记忆要点**：
- TCC是分布式事务的实用解决方案，特别适合微服务架构
- 成功的关键在于合理的业务拆分和完善的补偿设计
- ByteTCC提供了简单易用的注解式编程模型
- 幂等性设计是避免数据不一致的重要保障
- 完善的监控和日志是生产环境稳定运行的基础