---
title: 2、TCC设计原则与要求
---
## 📚 目录

1. [TCC模式概述](#1-TCC模式概述)
2. [TCC三个阶段详解](#2-TCC三个阶段详解)
3. [TCC设计原则与要求](#3-TCC设计原则与要求)
4. [幂等性设计](#4-幂等性设计)
5. [业务接口设计](#5-业务接口设计)
6. [实战案例分析](#6-实战案例分析)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎯 TCC模式概述


### 1.1 什么是TCC模式


**TCC**是一种分布式事务解决方案，名字来源于三个英文单词的首字母：

```
T - Try（尝试）     → 预留资源，做准备工作
C - Confirm（确认） → 真正执行业务逻辑
C - Cancel（取消）  → 释放资源，回滚操作
```

**🔸 用生活例子理解TCC**：
想象你要在网上买一件衣服，但库存只有1件：

1. **Try阶段**：你点击"立即购买"，系统为你**预留**这件衣服30分钟
2. **Confirm阶段**：你付款成功后，系统**确认**将衣服真正卖给你
3. **Cancel阶段**：如果30分钟内你没付款，系统**取消**预留，衣服重新上架

### 1.2 TCC vs 传统事务对比


```
传统数据库事务（ACID）：
开始事务 → 执行操作 → 提交/回滚

TCC分布式事务：
Try准备 → Confirm确认 OR Cancel取消
```

**🔹 为什么需要TCC？**

传统事务在分布式系统中的问题：
- 💔 **跨服务**：无法锁定其他服务的资源
- 💔 **长时间占用**：分布式操作耗时长，锁定时间过长
- 💔 **网络问题**：网络延迟和断开会导致事务异常

TCC的优势：
- ✅ **柔性事务**：不需要长时间锁定资源
- ✅ **最终一致性**：允许中间状态，保证最终结果正确
- ✅ **高可用**：单个服务故障不影响整体流程

### 1.3 TCC适用场景


**💡 适合TCC的业务场景**：
- 🛒 **电商下单**：涉及库存、账户、积分等多个服务
- 💰 **转账业务**：需要操作多个账户
- 🎫 **订票系统**：座位预留和支付确认
- 🏨 **酒店预订**：房间预留和费用扣减

---

## 2. ⚙️ TCC三个阶段详解


### 2.1 Try阶段 - 资源预留


**🔸 Try阶段的核心任务**：
- **检查资源**：验证是否有足够的资源
- **预留资源**：为后续操作锁定必要资源
- **记录状态**：保存预留信息，便于后续确认或取消

**实际例子 - 电商下单Try阶段**：
```
订单服务Try：
├── 检查商品是否存在
├── 验证用户信息是否有效
└── 创建预订单（状态：预留中）

库存服务Try：
├── 检查库存是否充足
├── 冻结指定数量库存
└── 记录冻结记录

账户服务Try：
├── 检查账户余额是否充足
├── 冻结订单金额
└── 记录冻结流水
```

### 2.2 Confirm阶段 - 确认执行


**🔸 Confirm阶段的核心任务**：
- **执行业务**：真正执行业务逻辑
- **释放预留**：将预留的资源转为正式使用
- **更新状态**：将临时状态改为最终状态

**实际例子 - 电商下单Confirm阶段**：
```
订单服务Confirm：
├── 将预订单转为正式订单
├── 订单状态：预留中 → 已确认
└── 触发后续流程（发货等）

库存服务Confirm：
├── 将冻结库存转为已售出
├── 实际库存数量减少
└── 清理冻结记录

账户服务Confirm：
├── 将冻结金额转为实际扣费
├── 账户余额真正减少
└── 生成消费记录
```

### 2.3 Cancel阶段 - 回滚操作


**🔸 Cancel阶段的核心任务**：
- **释放资源**：归还Try阶段预留的所有资源
- **恢复状态**：将数据恢复到Try之前的状态
- **清理记录**：删除或标记无效相关的临时数据

**实际例子 - 电商下单Cancel阶段**：
```
订单服务Cancel：
├── 删除或标记预订单为已取消
├── 清理相关临时数据
└── 记录取消原因

库存服务Cancel：
├── 释放冻结的库存
├── 库存重新变为可用状态
└── 删除冻结记录

账户服务Cancel：
├── 解冻被冻结的金额
├── 账户余额恢复原状
└── 清理冻结流水记录
```

---

## 3. 📋 TCC设计原则与要求


### 3.1 预留资源设计


**🔸 预留资源的设计原则**：

```
原则1：资源隔离
预留的资源必须与正常业务资源分开管理
├── 库存管理：总库存 = 可用库存 + 冻结库存
├── 账户管理：总余额 = 可用余额 + 冻结余额
└── 避免预留资源被其他业务误用

原则2：预留时效
所有预留都必须设置合理的过期时间
├── 防止资源被长期占用
├── 自动清理超时的预留记录
└── 一般设置为几分钟到几小时不等
```

**实际设计示例**：
```java
// 库存服务的预留设计
public class InventoryService {
    
    // 预留库存
    public boolean reserveStock(String productId, int quantity, String orderId) {
        // 1. 检查可用库存
        if (getAvailableStock(productId) < quantity) {
            return false;
        }
        
        // 2. 创建预留记录
        createReservationRecord(productId, quantity, orderId);
        
        // 3. 更新可用库存（减少）
        updateAvailableStock(productId, -quantity);
        
        return true;
    }
}
```

### 3.2 确认操作设计


**🔸 确认操作的设计要点**：

```
要点1：状态转换
必须将预留状态转换为最终状态
├── 预留订单 → 正式订单
├── 冻结库存 → 已售库存
└── 冻结金额 → 实际扣款

要点2：原子操作
确认操作必须是原子的，要么全成功要么全失败
├── 使用数据库事务保证原子性
├── 避免出现部分确认的中间状态
└── 失败时能够进入Cancel阶段
```

### 3.3 取消操作设计


**🔸 取消操作的设计要求**：

```
要求1：完全回滚
必须完全撤销Try阶段的所有变更
├── 释放所有预留的资源
├── 删除所有临时创建的记录
└── 恢复到Try操作之前的状态

要求2：容错处理
Cancel操作必须能处理各种异常情况
├── Try阶段部分成功的情况
├── 网络异常导致的重复调用
└── 系统故障后的恢复处理
```

---

## 4. 🔄 幂等性设计


### 4.1 什么是幂等性


**🔸 幂等性的通俗理解**：
幂等性就是说，**同一个操作执行多次的效果和执行一次是一样的**。

```
生活中的幂等性例子：
开灯开关：无论按多少次"开"，灯都是亮的状态 ✅
电梯按钮：重复按同一层楼，电梯只会去一次 ✅

非幂等性例子：
银行转账：转账100元执行3次，就转了300元 ❌
发送短信：发送1条短信执行3次，就发了3条 ❌
```

### 4.2 TCC为什么需要幂等性


**🔸 分布式环境的挑战**：

```
网络重试问题：
客户端调用 → 网络超时 → 客户端重试 → 重复执行

可能导致的问题：
├── Try阶段：重复预留资源，资源不足
├── Confirm阶段：重复确认，数据异常  
└── Cancel阶段：重复取消，状态错乱
```

### 4.3 幂等性保证策略


#### 策略1：唯一标识符（推荐）


**原理**：给每个事务分配全局唯一ID，通过ID防重复

```java
public class OrderService {
    
    @Transactional
    public boolean tryCreateOrder(String transactionId, OrderInfo order) {
        // 1. 检查是否已经处理过
        if (isTransactionProcessed(transactionId)) {
            return getTransactionResult(transactionId);
        }
        
        // 2. 执行业务逻辑
        boolean result = doCreateOrder(order);
        
        // 3. 记录处理结果
        saveTransactionResult(transactionId, result);
        
        return result;
    }
}
```

#### 策略2：状态检查


**原理**：通过检查当前状态来判断是否需要执行

```java
public class InventoryService {
    
    public boolean confirmReserve(String orderId) {
        // 1. 查询当前预留状态
        ReservationRecord record = getReservationRecord(orderId);
        
        // 2. 根据状态决定操作
        switch (record.getStatus()) {
            case "RESERVED":
                // 执行确认逻辑
                return doConfirm(orderId);
            case "CONFIRMED":
                // 已经确认过了，直接返回成功
                return true;
            case "CANCELLED":
                // 已经取消了，返回失败
                return false;
            default:
                // 状态异常
                throw new IllegalStateException("Invalid state");
        }
    }
}
```

#### 策略3：乐观锁


**原理**：使用版本号避免并发修改冲突

```java
// 使用版本号的乐观锁示例
@Entity
public class Account {
    private Long id;
    private BigDecimal balance;
    private Long version;  // 版本号字段
    
    // 更新时检查版本号
    @Query("UPDATE Account SET balance = :balance, version = version + 1 " +
           "WHERE id = :id AND version = :version")
    int updateBalanceWithVersion(@Param("id") Long id, 
                                @Param("balance") BigDecimal balance,
                                @Param("version") Long version);
}
```

### 4.4 幂等性实现最佳实践


**💡 设计建议**：

```
1. 事务ID管理
   ├── 使用UUID或雪花算法生成全局唯一ID
   ├── 事务ID要在整个TCC流程中保持一致
   └── 建议格式：TXN_20230922_UUID

2. 状态记录表
   ├── 专门的表记录每个事务的执行状态
   ├── 包含：事务ID、操作类型、执行状态、时间戳
   └── 定期清理过期的记录

3. 超时处理
   ├── 设置合理的事务超时时间
   ├── 超时后自动进入Cancel流程
   └── 避免资源长期占用
```

---

## 5. 🔌 业务接口设计


### 5.1 业务接口侵入性分析


**🔸 什么是业务接口侵入**？

传统的业务方法：
```java
// 原来的简单业务方法
public boolean createOrder(OrderInfo order) {
    // 直接创建订单
    return orderRepository.save(order) != null;
}
```

TCC模式的业务方法：
```java
// TCC模式需要三个方法
public boolean tryCreateOrder(OrderInfo order, String txnId) {
    // Try逻辑：预留资源
}

public boolean confirmCreateOrder(String txnId) {
    // Confirm逻辑：确认操作
}

public boolean cancelCreateOrder(String txnId) {
    // Cancel逻辑：取消回滚
}
```

**🔹 侵入性影响**：
- ❌ **代码复杂度**：一个业务操作变成三个方法
- ❌ **维护成本**：需要维护更多的状态和逻辑
- ❌ **理解难度**：开发人员需要理解TCC原理
- ✅ **事务保证**：获得了分布式事务的一致性保证

### 5.2 接口设计规范


**🔸 TCC接口设计的统一规范**：

```java
// TCC业务服务接口标准模式
public interface TccBusinessService {
    
    /**
     * Try阶段 - 资源预留
     * @param businessParams 业务参数
     * @param transactionId 事务ID（全局唯一）
     * @return 预留是否成功
     */
    boolean tryOperation(BusinessParams businessParams, String transactionId);
    
    /**
     * Confirm阶段 - 确认执行  
     * @param transactionId 事务ID
     * @return 确认是否成功
     */
    boolean confirmOperation(String transactionId);
    
    /**
     * Cancel阶段 - 取消回滚
     * @param transactionId 事务ID  
     * @return 取消是否成功
     */
    boolean cancelOperation(String transactionId);
}
```

### 5.3 接口参数设计


**🔸 参数设计原则**：

```
Try阶段参数：
├── 业务参数：完整的业务操作所需数据
├── 事务ID：全局唯一标识符
└── 可选：超时时间、优先级等

Confirm/Cancel阶段参数：
├── 事务ID：必须，用于找到对应的Try操作
├── 可选：重试次数、补偿信息等
└── 原则：参数尽可能简单，减少传输开销
```

### 5.4 接口实现示例


**完整的TCC接口实现示例**：

```java
@Service
public class OrderTccService implements TccBusinessService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private TccTransactionRepository tccRepository;
    
    @Override
    @Transactional
    public boolean tryCreateOrder(OrderInfo order, String txnId) {
        try {
            // 1. 幂等性检查
            if (tccRepository.isProcessed(txnId, "TRY")) {
                return tccRepository.getResult(txnId, "TRY");
            }
            
            // 2. 业务校验
            if (!validateOrder(order)) {
                return false;
            }
            
            // 3. 创建预留订单
            Order reservedOrder = new Order();
            reservedOrder.setStatus("RESERVED");
            reservedOrder.setTransactionId(txnId);
            // ... 设置其他字段
            
            orderRepository.save(reservedOrder);
            
            // 4. 记录Try操作结果
            tccRepository.saveResult(txnId, "TRY", true);
            
            return true;
            
        } catch (Exception e) {
            // 5. 异常处理
            tccRepository.saveResult(txnId, "TRY", false);
            return false;
        }
    }
    
    @Override
    @Transactional  
    public boolean confirmCreateOrder(String txnId) {
        try {
            // 1. 幂等性检查
            if (tccRepository.isProcessed(txnId, "CONFIRM")) {
                return tccRepository.getResult(txnId, "CONFIRM");
            }
            
            // 2. 查找预留订单
            Order reservedOrder = orderRepository.findByTransactionId(txnId);
            if (reservedOrder == null) {
                return false;
            }
            
            // 3. 确认订单
            reservedOrder.setStatus("CONFIRMED");
            reservedOrder.setConfirmTime(new Date());
            orderRepository.save(reservedOrder);
            
            // 4. 记录Confirm操作结果
            tccRepository.saveResult(txnId, "CONFIRM", true);
            
            return true;
            
        } catch (Exception e) {
            tccRepository.saveResult(txnId, "CONFIRM", false);  
            return false;
        }
    }
    
    @Override
    @Transactional
    public boolean cancelCreateOrder(String txnId) {
        try {
            // 1. 幂等性检查
            if (tccRepository.isProcessed(txnId, "CANCEL")) {
                return tccRepository.getResult(txnId, "CANCEL");
            }
            
            // 2. 查找预留订单
            Order reservedOrder = orderRepository.findByTransactionId(txnId);
            if (reservedOrder != null) {
                // 3. 删除预留订单
                orderRepository.delete(reservedOrder);
            }
            
            // 4. 记录Cancel操作结果  
            tccRepository.saveResult(txnId, "CANCEL", true);
            
            return true;
            
        } catch (Exception e) {
            tccRepository.saveResult(txnId, "CANCEL", false);
            return false;
        }
    }
}
```

---

## 6. 💼 实战案例分析


### 6.1 电商下单完整流程


**场景描述**：用户购买商品，涉及订单、库存、账户三个服务

```
业务流程图：
用户下单
    ├── 订单服务：创建预留订单
    ├── 库存服务：冻结商品库存  
    └── 账户服务：冻结账户余额
             ↓
    全部Try成功？
    ├── 是 → 执行Confirm，完成购买
    └── 否 → 执行Cancel，释放资源
```

### 6.2 Try阶段实现


**各服务的Try阶段逻辑**：

```java
// 1. 订单服务Try
@TccTry
public boolean tryCreateOrder(OrderRequest request, String txnId) {
    // 创建状态为"预留中"的订单
    Order order = new Order();
    order.setUserId(request.getUserId());
    order.setProductId(request.getProductId());
    order.setQuantity(request.getQuantity());
    order.setStatus("TRYING");
    order.setTransactionId(txnId);
    
    orderRepository.save(order);
    return true;
}

// 2. 库存服务Try  
@TccTry
public boolean tryReduceStock(String productId, int quantity, String txnId) {
    // 检查库存是否充足
    Product product = productRepository.findById(productId);
    if (product.getStock() < quantity) {
        return false;
    }
    
    // 冻结库存
    product.setStock(product.getStock() - quantity);
    product.setFrozenStock(product.getFrozenStock() + quantity);
    productRepository.save(product);
    
    // 记录冻结记录
    StockFrozen frozen = new StockFrozen();
    frozen.setProductId(productId);
    frozen.setQuantity(quantity);
    frozen.setTransactionId(txnId);
    frozenRepository.save(frozen);
    
    return true;
}

// 3. 账户服务Try
@TccTry  
public boolean tryDeductBalance(String userId, BigDecimal amount, String txnId) {
    // 检查余额是否充足
    Account account = accountRepository.findByUserId(userId);
    if (account.getBalance().compareTo(amount) < 0) {
        return false;
    }
    
    // 冻结金额
    account.setBalance(account.getBalance().subtract(amount));
    account.setFrozenAmount(account.getFrozenAmount().add(amount));
    accountRepository.save(account);
    
    // 记录冻结流水
    FrozenRecord record = new FrozenRecord();
    record.setUserId(userId);
    record.setAmount(amount);
    record.setTransactionId(txnId);
    frozenRecordRepository.save(record);
    
    return true;
}
```

### 6.3 Confirm阶段实现


```java
// 1. 订单服务Confirm
@TccConfirm
public boolean confirmCreateOrder(String txnId) {
    Order order = orderRepository.findByTransactionId(txnId);
    order.setStatus("CONFIRMED"); 
    order.setConfirmTime(new Date());
    orderRepository.save(order);
    return true;
}

// 2. 库存服务Confirm
@TccConfirm
public boolean confirmReduceStock(String txnId) {
    StockFrozen frozen = frozenRepository.findByTransactionId(txnId);
    
    // 清理冻结记录（库存已经在Try阶段减少了）
    frozenRepository.delete(frozen);
    return true;
}

// 3. 账户服务Confirm  
@TccConfirm
public boolean confirmDeductBalance(String txnId) {
    FrozenRecord record = frozenRecordRepository.findByTransactionId(txnId);
    
    // 清理冻结记录（余额已经在Try阶段减少了）
    frozenRecordRepository.delete(record);
    return true;
}
```

### 6.4 Cancel阶段实现


```java
// 1. 订单服务Cancel
@TccCancel
public boolean cancelCreateOrder(String txnId) {
    Order order = orderRepository.findByTransactionId(txnId);
    if (order != null) {
        orderRepository.delete(order);  // 删除预留订单
    }
    return true;
}

// 2. 库存服务Cancel
@TccCancel  
public boolean cancelReduceStock(String txnId) {
    StockFrozen frozen = frozenRepository.findByTransactionId(txnId);
    if (frozen != null) {
        // 恢复库存
        Product product = productRepository.findById(frozen.getProductId());
        product.setStock(product.getStock() + frozen.getQuantity());
        product.setFrozenStock(product.getFrozenStock() - frozen.getQuantity());
        productRepository.save(product);
        
        // 清理冻结记录
        frozenRepository.delete(frozen);
    }
    return true;
}

// 3. 账户服务Cancel
@TccCancel
public boolean cancelDeductBalance(String txnId) {
    FrozenRecord record = frozenRecordRepository.findByTransactionId(txnId);
    if (record != null) {
        // 恢复余额
        Account account = accountRepository.findByUserId(record.getUserId());
        account.setBalance(account.getBalance().add(record.getAmount()));
        account.setFrozenAmount(account.getFrozenAmount().subtract(record.getAmount()));
        accountRepository.save(account);
        
        // 清理冻结记录
        frozenRecordRepository.delete(record);
    }
    return true;
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 TCC三阶段：Try预留 → Confirm确认 → Cancel取消
🔸 资源预留：Try阶段不真正执行，只是预留资源
🔸 幂等性：同一操作多次执行结果一致，防止重复调用
🔸 业务侵入：需要将一个业务拆分成三个方法实现
🔸 最终一致性：允许中间状态，保证最终结果正确
```

### 7.2 关键设计原则


**🔹 资源管理原则**：
```
预留资源设计：
├── 资源隔离：预留资源与可用资源分开管理
├── 时效控制：设置合理的预留超时时间
└── 状态跟踪：记录资源的预留状态和历史

确认操作设计：
├── 原子性：确认操作要么全成功要么全失败
├── 状态转换：预留状态 → 最终状态
└── 资源释放：清理临时的预留记录
```

**🔹 接口设计原则**：
```
统一规范：
├── Try方法：包含业务参数 + 事务ID
├── Confirm方法：只需要事务ID
└── Cancel方法：只需要事务ID

幂等实现：
├── 事务ID：全局唯一标识符
├── 状态检查：基于当前状态决定操作
└── 结果记录：保存每次操作的结果
```

### 7.3 实际应用指导


**适用场景判断**：
```
✅ 适合TCC的场景：
├── 涉及多个服务的业务操作
├── 对一致性要求高的核心业务
├── 可以明确定义资源预留和释放的业务
└── 允许中间状态存在的业务

❌ 不适合TCC的场景：  
├── 单服务内的数据库事务（用传统ACID即可）
├── 对性能要求极高的场景（TCC有额外开销）
├── 无法定义明确资源边界的业务
└── 不允许任何中间状态的严格业务
```

**工程实践要点**：
```
开发建议：
├── 事务协调器：使用Seata、ByteTCC等成熟框架
├── 监控告警：监控Try/Confirm/Cancel的成功率
├── 数据清理：定期清理过期的事务记录
└── 异常处理：完善的重试和容错机制

性能优化：
├── 批量操作：支持批量Try/Confirm/Cancel
├── 异步处理：非关键路径可以异步执行
├── 缓存优化：减少重复的数据库查询
└── 连接池：合理配置数据库连接池
```

### 7.4 常见问题与解决方案


**🔸 问题1：Try阶段超时怎么办？**
```
解决方案：
├── 设置合理的超时时间（根据业务特点）
├── 超时后自动触发Cancel操作
├── 实现补偿机制，清理超时的预留资源
└── 监控超时率，优化系统性能
```

**🔸 问题2：网络异常导致重复调用？**
```
解决方案：
├── 实现严格的幂等性控制
├── 使用全局唯一的事务ID
├── 记录每次操作的执行状态
└── 基于状态判断是否需要重复执行
```

**🔸 问题3：部分服务调用失败？**
```
解决方案：
├── 实现重试机制，处理临时性故障
├── 失败后触发Cancel，保证数据一致性
├── 记录失败原因，便于问题排查
└── 考虑服务降级，保证核心功能可用
```

**核心记忆口诀**：
- TCC三步走，预留确认和回滚
- 资源预留要隔离，幂等设计防重复  
- 接口侵入虽复杂，分布式事务有保障
- 最终一致是目标，柔性事务更灵活