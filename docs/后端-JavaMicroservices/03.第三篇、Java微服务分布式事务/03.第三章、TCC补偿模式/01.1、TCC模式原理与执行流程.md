---
title: 1、TCC模式原理与执行流程
---
## 📚 目录

1. [TCC模式核心原理](#1-tcc模式核心原理)
2. [TCC三阶段详解](#2-tcc三阶段详解)
3. [TCC与2PC对比分析](#3-tcc与2pc对比分析)
4. [TCC模式实现机制](#4-tcc模式实现机制)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 🎯 TCC模式核心原理


### 1.1 什么是TCC模式


**TCC**就是**Try-Confirm-Cancel**的缩写，这是一种处理分布式事务的模式。

> **💡 生活类比**  
> 想象你在网上订餐，需要同时完成三件事：扣款、减库存、预约配送。  
> **Try阶段**：先预扣钱、预占库存、预约配送员（都是"试试看"，还没真正执行）  
> **Confirm阶段**：如果都成功了，就真正扣钱、减库存、安排配送  
> **Cancel阶段**：如果有失败的，就把预扣的钱退回、释放库存、取消预约

**🔸 核心思想**
```
传统事务：要么全成功，要么全失败（刚性事务）
TCC模式：通过补偿机制保证最终一致性（柔性事务）
```

**🔸 适用场景**
- 分布式系统中的多服务协调
- 对一致性要求高但允许短暂不一致
- 需要自定义补偿逻辑的业务场景

### 1.2 柔性事务与最终一致性


**什么是柔性事务？**

柔性事务不像传统数据库事务那样严格，它允许系统在短时间内出现不一致状态，但保证最终会达到一致。

```
传统事务（刚性）：
订单服务 ←→ 支付服务 ←→ 库存服务
       ↑ 要么全成功，要么全回滚 ↑

柔性事务（TCC）：
订单服务 → 支付服务 → 库存服务
   ↓          ↓         ↓
分步执行    逐步确认    补偿回滚
```

**什么是最终一致性？**

最终一致性是指系统在一段时间后，所有节点的数据会达到一致状态。

> **🎯 理解要点**  
> 就像转账，钱从A账户扣除后，可能需要几秒钟才能到达B账户。  
> 这几秒内系统是不一致的，但最终会一致。

---

## 2. ⚙️ TCC三阶段详解


### 2.1 Try阶段（尝试执行）


**Try阶段的作用**：检查业务资源，预留必要资源，但不真正执行业务操作。

**💡 关键理解**
- Try是"试试看能不能做"，不是"真的去做"
- 要检查所有条件是否满足
- 预留资源但不修改业务数据

**🔧 Try阶段实现要点**
```java
// 示例：电商下单的Try阶段
public class OrderTryService {
    
    public boolean tryCreateOrder(OrderRequest request) {
        // 1. 检查用户余额是否足够（不真正扣款）
        if (!checkUserBalance(request.getUserId(), request.getAmount())) {
            return false;
        }
        
        // 2. 检查商品库存是否足够（预占库存但不减少）
        if (!reserveInventory(request.getProductId(), request.getQuantity())) {
            return false;
        }
        
        // 3. 预留配送资源
        if (!reserveDelivery(request.getAddress())) {
            return false;
        }
        
        return true; // Try阶段成功
    }
}
```

**Try阶段的特点**
- ✅ **可重试**：Try操作失败了可以重新尝试
- ✅ **资源预留**：锁定资源但不修改主业务数据
- ✅ **超时机制**：设置合理的超时时间

### 2.2 Confirm阶段（确认执行）


**Confirm阶段的作用**：真正执行业务操作，确认Try阶段预留的资源。

**💡 关键理解**
- Confirm是"真的去做"，使用Try阶段预留的资源
- 必须保证执行成功（幂等性）
- 不能再失败了（因为Try阶段已经检查过了）

```java
// 示例：电商下单的Confirm阶段
public class OrderConfirmService {
    
    public void confirmCreateOrder(OrderRequest request) {
        // 1. 真正扣除用户余额
        deductUserBalance(request.getUserId(), request.getAmount());
        
        // 2. 真正减少商品库存
        confirmInventoryReduction(request.getProductId(), request.getQuantity());
        
        // 3. 确认配送安排
        confirmDelivery(request.getAddress());
        
        // 4. 创建订单记录
        createOrderRecord(request);
    }
}
```

**Confirm阶段的特点**
- ✅ **幂等性**：多次执行结果一样
- ✅ **最终成功**：必须保证最终能成功执行
- ✅ **使用预留资源**：使用Try阶段预留的资源

### 2.3 Cancel阶段（取消执行）


**Cancel阶段的作用**：撤销Try阶段的操作，释放预留的资源。

**💡 关键理解**
- Cancel是"取消刚才的预留"，进行补偿操作
- 用于处理Try成功但后续流程失败的情况
- 必须能恢复到Try之前的状态

```java
// 示例：电商下单的Cancel阶段
public class OrderCancelService {
    
    public void cancelCreateOrder(OrderRequest request) {
        // 1. 释放预留的用户余额
        releaseUserBalance(request.getUserId(), request.getAmount());
        
        // 2. 释放预占的商品库存
        releaseInventory(request.getProductId(), request.getQuantity());
        
        // 3. 取消配送预约
        cancelDelivery(request.getAddress());
        
        // 4. 清理相关临时数据
        cleanupTempData(request);
    }
}
```

**Cancel阶段的特点**
- ✅ **补偿性**：撤销Try阶段的预留操作
- ✅ **幂等性**：多次执行结果一样
- ✅ **最终成功**：必须保证最终能成功执行

---

## 3. 🔄 TCC与2PC对比分析


### 3.1 执行流程对比


```
2PC（两阶段提交）执行流程：
协调者                     参与者1              参与者2
   |                         |                   |
   |----[准备阶段]----------->|                   |
   |                         |<----[准备就绪]-----|
   |----[准备阶段]-------------------------->|
   |                         |              |<--[准备就绪]
   |----[提交阶段]----------->|                   |
   |----[提交阶段]-------------------------->|
   |                         |                   |

TCC执行流程：
业务协调器                 服务A                服务B
    |                        |                   |
    |----[Try阶段]----------->|                   |
    |<---[Try成功]------------|                   |
    |----[Try阶段]------------------------->|
    |<---[Try成功]---------------------------|
    |----[Confirm阶段]------->|                   |
    |----[Confirm阶段]---------------------->|
    |                        |                   |
```

### 3.2 核心特点对比


| 对比维度 | **2PC** | **TCC** |
|---------|---------|---------|
| **阶段数量** | `2个阶段（准备+提交）` | `3个阶段（Try+Confirm+Cancel）` |
| **协调方式** | `协调者统一协调` | `业务层面协调` |
| **资源锁定** | `数据库级别锁定` | `业务级别预留` |
| **失败处理** | `自动回滚` | `业务补偿` |
| **性能影响** | `锁定时间长，性能差` | `锁定时间短，性能好` |
| **一致性** | `强一致性` | `最终一致性` |
| **适用场景** | `单机数据库事务扩展` | `分布式业务事务` |

### 3.3 优缺点分析


**2PC的问题：**
```
🔴 阻塞问题：参与者在等待协调者指令时会阻塞
🔴 单点故障：协调者故障会导致参与者一直等待
🔴 资源锁定：事务期间资源被长时间锁定
🔴 网络分区：网络故障可能导致数据不一致
```

**TCC的优势：**
```
🟢 非阻塞：各服务独立执行，不会互相阻塞
🟢 灵活补偿：可以自定义补偿逻辑
🟢 性能较好：减少了资源锁定时间
🟢 业务可控：业务逻辑更加清晰可控
```

**TCC的挑战：**
```
🟡 开发复杂：需要实现Try、Confirm、Cancel三套逻辑
🟡 数据一致性：只能保证最终一致性
🟡 补偿复杂：复杂业务的补偿逻辑难以设计
```

---

## 4. 🛠️ TCC模式实现机制


### 4.1 TCC框架组成


```
TCC分布式事务框架架构：

┌─────────────────────────────────────────────┐
│                业务应用层                    │
├─────────────────────────────────────────────┤
│           TCC事务管理器                      │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐       │
│  │事务协调器│ │资源管理器│ │补偿管理器│       │
│  └─────────┘ └─────────┘ └─────────┘       │
├─────────────────────────────────────────────┤
│                 消息中间件                   │
├─────────────────────────────────────────────┤
│     服务A        服务B        服务C          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│  │Try/C/C  │  │Try/C/C  │  │Try/C/C  │     │
│  └─────────┘  └─────────┘  └─────────┘     │
└─────────────────────────────────────────────┘
```

### 4.2 事务日志管理


**为什么需要事务日志？**

TCC模式需要记录每个阶段的执行状态，以便在异常情况下进行恢复和补偿。

```
事务日志记录内容：
┌──────────────────────────────────┐
│ 事务ID: TXN_20250922_001         │
│ 状态: TRY_SUCCESS                │
│ 参与服务: [OrderService,         │
│           PaymentService,        │
│           InventoryService]      │
│ Try结果: [SUCCESS, SUCCESS,      │
│          SUCCESS]                │
│ 创建时间: 2025-09-22 15:30:21    │
│ 超时时间: 2025-09-22 15:35:21    │
└──────────────────────────────────┘
```

**状态流转图：**
```
初始状态
   ↓
TRY_PHASE → TRY_SUCCESS → CONFIRM_PHASE → CONFIRMED ✅
    ↓           ↓              ↓
TRY_FAILED  CANCEL_PHASE → CANCELLED ✅
                ↓
           CANCEL_FAILED ❌ (需要人工干预)
```

### 4.3 异常处理机制


**超时处理**

TCC事务设置超时时间，超时后自动触发Cancel操作：

```java
// 超时检查示例
public class TccTimeoutChecker {
    
    @Scheduled(fixedDelay = 5000) // 每5秒检查一次
    public void checkTimeout() {
        List<TccTransaction> timeoutTransactions = 
            findTimeoutTransactions();
            
        for (TccTransaction tx : timeoutTransactions) {
            if (tx.getStatus() == TRY_SUCCESS) {
                // Try阶段超时，执行Cancel
                cancelTransaction(tx);
            }
        }
    }
}
```

**重试机制**

对于Confirm和Cancel操作，需要支持重试：

> **⚠️ 重要原则**  
> - Confirm和Cancel操作必须设计成**幂等**的  
> - 多次执行同样的操作，结果应该一样  
> - 通过业务主键或唯一标识来保证幂等性

### 4.4 实际应用示例


**电商订单场景的完整实现**

```java
// TCC业务服务接口
public interface TccBusinessService {
    // Try阶段：检查并预留资源
    boolean tryExecute(BusinessContext context);
    
    // Confirm阶段：确认执行
    void confirmExecute(BusinessContext context);
    
    // Cancel阶段：取消并补偿
    void cancelExecute(BusinessContext context);
}

// 订单服务的TCC实现
@Service
public class OrderTccService implements TccBusinessService {
    
    @Override
    public boolean tryExecute(BusinessContext context) {
        OrderRequest request = (OrderRequest) context.getRequest();
        
        // 1. 创建待支付订单（状态为PENDING）
        Order order = new Order();
        order.setStatus(OrderStatus.PENDING);
        order.setUserId(request.getUserId());
        order.setProductId(request.getProductId());
        orderRepository.save(order);
        
        // 2. 记录Try执行成功
        context.addResult("orderId", order.getId());
        return true;
    }
    
    @Override
    public void confirmExecute(BusinessContext context) {
        Long orderId = context.getResult("orderId", Long.class);
        
        // 将订单状态改为已确认
        Order order = orderRepository.findById(orderId);
        order.setStatus(OrderStatus.CONFIRMED);
        orderRepository.save(order);
    }
    
    @Override
    public void cancelExecute(BusinessContext context) {
        Long orderId = context.getResult("orderId", Long.class);
        
        // 取消订单
        Order order = orderRepository.findById(orderId);
        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);
    }
}
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 TCC三阶段：Try预留资源，Confirm真正执行，Cancel进行补偿
🔸 柔性事务：允许短暂不一致，保证最终一致性
🔸 业务补偿：通过业务逻辑实现事务回滚
🔸 幂等设计：Confirm和Cancel操作必须支持重复执行
🔸 超时处理：设置合理超时时间，自动触发补偿流程
```

### 5.2 关键理解要点


**🔹 TCC与传统事务的本质区别**
```
传统事务：由数据库保证ACID特性
TCC事务：由业务代码保证最终一致性

传统事务：失败时自动回滚
TCC事务：失败时需要编写补偿逻辑
```

**🔹 为什么选择TCC模式**
```
适用场景：
✅ 跨多个微服务的业务操作
✅ 对性能有要求的分布式场景
✅ 可以接受短暂数据不一致
✅ 具备设计补偿逻辑的能力

不适用场景：
❌ 简单的单机事务
❌ 必须保证强一致性
❌ 补偿逻辑过于复杂
❌ 开发团队经验不足
```

**🔹 TCC实现的关键点**
```
设计原则：
- Try操作可失败、可重试
- Confirm操作必须成功、幂等
- Cancel操作必须成功、幂等
- 每个阶段都要有清晰的边界和职责
```

### 5.3 实际应用价值


**📊 应用场景评估**
```
高价值场景：
🎯 电商下单：订单+支付+库存+物流
🎯 金融转账：账户扣款+账户入账+流水记录
🎯 积分兑换：积分扣除+商品发放+库存减少
🎯 会员充值：账户充值+积分增加+等级更新
```

**🔧 工程实践建议**
```
开发建议：
1. 先设计补偿逻辑，再编写业务代码
2. 每个操作都要支持幂等性
3. 合理设置超时时间（通常10-30秒）
4. 详细记录事务执行日志
5. 设计异常情况的人工干预流程

监控要点：
- TCC事务成功率
- 各阶段执行耗时  
- 补偿操作触发频率
- 长时间未完成的事务
```

### 5.4 学习进阶路径


```
🚀 学习路径建议：

第一步：理解分布式事务基本概念
第二步：掌握TCC三阶段核心原理  
第三步：学习主流TCC框架使用
第四步：设计和实现简单TCC案例
第五步：处理复杂业务场景的TCC设计
第六步：TCC事务的性能优化和监控
```

**核心记忆口诀**：
```
🧠 TCC记忆法：
Try试试看，预留不执行
Confirm真执行，必须能成功  
Cancel来补偿，恢复到原状
三阶段配合，最终保一致
```