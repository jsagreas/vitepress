---
title: 4、分布式事务解决方案分类
---
## 📚 目录

1. [分布式事务基础理解](#1-分布式事务基础理解)
2. [刚性事务与柔性事务](#2-刚性事务与柔性事务)
3. [两阶段提交(2PC)](#3-两阶段提交2pc)
4. [三阶段提交(3PC)](#4-三阶段提交3pc)
5. [TCC模式详解](#5-tcc模式详解)
6. [Saga模式详解](#6-saga模式详解)
7. [消息事务模式](#7-消息事务模式)
8. [方案对比与选型指导](#8-方案对比与选型指导)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 分布式事务基础理解


### 1.1 什么是分布式事务


**🏠 生活类比**：
> 想象你要买房，需要同时完成三件事：
> - 银行转账付款 💰
> - 房产局过户登记 📝  
> - 中介收取佣金 🏢
> 
> 这三件事必须**要么全成功，要么全失败**，不能出现付了钱但房子没过户的情况

**💡 技术定义**：
```
分布式事务 = 跨越多个数据库/服务的事务操作
核心要求：保证多个分布式资源的数据一致性
```

### 1.2 为什么需要分布式事务


**🔸 单体应用时代**：
```
一个应用 + 一个数据库 = 简单事务
┌─────────────┐
│   应用程序   │
├─────────────┤  
│   数据库     │ ← 本地事务就够了
└─────────────┘
```

**🔸 微服务时代**：
```
电商下单流程：
用户服务    订单服务    库存服务    支付服务
   │          │          │          │
   ▼          ▼          ▼          ▼  
 用户DB     订单DB     库存DB     支付DB

问题：如何保证这4个操作要么全成功，要么全失败？
```

### 1.3 分布式事务的挑战


**⚠️ 核心难点**：

```
网络延迟与不可靠：
• 服务A调用服务B可能超时
• 无法确定对方是真的失败还是网络问题

部分失败问题：  
• 订单创建成功，但扣库存失败
• 如何回滚已经成功的操作？

性能与一致性矛盾：
• 强一致性 → 性能差，用户等待时间长
• 最终一致性 → 短时间数据不一致
```

**🎭 经典问题场景**：
> **用户下单买手机**：
> 1. ✅ 订单服务：创建订单成功
> 2. ❌ 库存服务：扣库存失败（网络超时）
> 3. ❓ 支付服务：还没执行
> 
> **结果**：用户看到订单创建成功，但实际库存没扣，商家亏损！

---

## 2. ⚖️ 刚性事务与柔性事务


### 2.1 刚性事务（Strong Consistency）


**🔸 核心理念**：**严格遵循ACID，不允许任何数据不一致**

```
ACID四大特性：
A - Atomicity（原子性）：要么全做，要么全不做
C - Consistency（一致性）：数据始终处于一致状态  
I - Isolation（隔离性）：并发操作不互相影响
D - Durability（持久性）：成功的事务永久保存

刚性事务 = 严格按照ACID执行，一步都不能错
```

**💪 优点**：
- 数据绝对准确，不会出现不一致
- 业务逻辑简单，不用考虑中间状态

**😰 缺点**：
- 性能较差，用户等待时间长
- 可用性低，一个服务挂了整个事务就失败
- 不适合大规模分布式系统

### 2.2 柔性事务（Eventual Consistency）


**🔸 核心理念**：**允许短期不一致，保证最终一致**

```
BASE理论：
BA - Basically Available（基本可用）：系统大部分时间可用
S  - Soft State（软状态）：允许中间状态存在
E  - Eventually Consistent（最终一致）：最终会达到一致

柔性事务 = 用时间换空间，先让系统可用，慢慢修复数据
```

**🏃‍♂️ 生活类比**：
> **网购下单**：
> - 你下单后立即看到"订单提交成功"（系统可用）
> - 后台慢慢处理：检查库存、扣款、发货（最终一致）
> - 偶尔会收到"订单取消，库存不足"的通知（补偿机制）

**💡 优点**：
- 性能好，响应快
- 可用性高，部分服务故障不影响整体
- 适合大规模互联网应用

**🤔 缺点**：
- 业务逻辑复杂，需要处理中间状态
- 数据会短期不一致
- 需要补偿和重试机制

---

## 3. 🔄 两阶段提交(2PC)


### 3.1 2PC基本原理


**🎭 剧场类比**：
> **话剧演出**：
> - **准备阶段**：导演问所有演员"准备好了吗？"
> - **执行阶段**：如果都说"好了"，导演喊"开始演出！"；如果有人说"没准备好"，就"取消演出！"

**🔸 技术流程**：
```
协调者（Coordinator）与参与者（Participant）的对话：

阶段1 - 准备阶段（Prepare）：
协调者 → 所有参与者："你们能执行这个事务吗？"
参与者们：记录事务日志，锁定资源
参与者 → 协调者："我准备好了"或"我不行"

阶段2 - 提交阶段（Commit）：  
如果所有人都说"准备好了"：
  协调者 → 所有参与者："执行提交！"
  参与者们：真正执行操作，释放锁
如果有人说"不行"：
  协调者 → 所有参与者："执行回滚！"
  参与者们：撤销操作，释放锁
```

### 3.2 2PC执行流程图


```
协调者                参与者A              参与者B
   |                     |                    |
   |---准备请求---------->|                    |
   |---准备请求----------------------->|
   |                     |                    |
   |<--准备响应(Yes)------|                    |  
   |<--准备响应(Yes)----------------------|
   |                     |                    |
   |---提交请求---------->|                    |
   |---提交请求----------------------->|
   |                     |                    |
   |<--提交完成-----------|                    |
   |<--提交完成-----------------------|
```

### 3.3 2PC的问题


**🚨 致命缺陷**：

**同步阻塞问题**：
```
🔸 问题：参与者在准备阶段会锁定资源
🔸 影响：其他事务无法访问这些资源，系统吞吐量下降
🔸 场景：电商秒杀时，库存被锁住，其他用户只能等待
```

**单点故障问题**：
```
🔸 问题：协调者挂了，所有参与者不知道该提交还是回滚
🔸 影响：参与者一直等待，资源永远被锁定
🔸 场景：订单服务崩溃，库存和支付服务傻等，系统瘫痪
```

**脑裂问题**：
```
🔸 问题：协调者发完提交请求后挂了，部分参与者没收到
🔸 影响：有些参与者提交了，有些没提交，数据不一致
🔸 场景：订单创建了，但库存没扣，出现"超卖"
```

### 3.4 2PC适用场景


**✅ 适合场景**：
- 对数据一致性要求极高（银行转账）
- 参与者数量少（2-3个服务）
- 网络环境稳定的内网环境

**❌ 不适合场景**：
- 高并发互联网应用
- 跨机房、跨地域的分布式系统
- 对性能要求高的业务

---

## 4. 🔄 三阶段提交(3PC)


### 4.1 3PC改进思路


**🎯 核心改进**：**增加超时机制，减少阻塞时间**

```
3PC = 2PC + 超时机制 + 预提交阶段

改进点：
1. 增加CanCommit阶段，先询问参与者是否有能力执行
2. PreCommit阶段做预提交，但还不真正执行
3. 每个阶段都有超时，避免无限等待
```

### 4.2 3PC执行流程


**🔸 阶段1 - CanCommit（能否执行）**：
```
协调者 → 参与者："你现在有能力处理这个事务吗？"
参与者检查：资源是否可用、系统是否正常
参与者 → 协调者："有能力"或"没能力"
```

**🔸 阶段2 - PreCommit（预提交）**：
```
如果都有能力：
  协调者 → 参与者："执行预提交"
  参与者：锁定资源，写事务日志，但不提交
  参与者 → 协调者："预提交完成"

如果有人没能力：
  协调者 → 参与者："终止事务"
```

**🔸 阶段3 - DoCommit（真正提交）**：
```
协调者 → 参与者："提交事务"
参与者：真正执行操作，释放锁
```

### 4.3 3PC的改进效果


**✅ 解决的问题**：
- 减少了阻塞时间（增加了超时机制）
- 降低了参与者的等待时间

**⚠️ 依然存在的问题**：
- 网络分区时仍可能数据不一致
- 增加了一个阶段，性能反而更差
- 实际应用中很少使用

**🎯 实际价值**：
> 3PC更像是一个理论改进，证明了超时机制的重要性，但在实际项目中，我们更多使用其他方案如TCC、Saga等。

---

## 5. 🎯 TCC模式详解


### 5.1 TCC核心理念


**🏪 生活类比 - 网购预订**：
> **Try（尝试）**：先预订商品，锁定库存，但钱不扣
> **Confirm（确认）**：确认购买，真正扣钱扣库存  
> **Cancel（取消）**：取消订单，释放预订的库存

**💡 技术定义**：
```
TCC = Try + Confirm + Cancel

Try：     尝试执行，预留资源，不做实际业务操作
Confirm： 确认执行，使用预留资源，完成业务操作  
Cancel：  取消执行，释放预留资源，撤销Try操作
```

### 5.2 TCC执行流程


**🔸 正常流程**：
```
电商下单场景：

Try阶段（所有服务并行执行）：
┌─ 订单服务 ─┐   ┌─ 库存服务 ─┐   ┌─ 支付服务 ─┐
│创建待确认订单│   │预扣库存     │   │冻结账户余额│
└────────────┘   └────────────┘   └────────────┘

如果Try都成功 → 执行Confirm：
┌─ 订单服务 ─┐   ┌─ 库存服务 ─┐   ┌─ 支付服务 ─┐  
│订单状态改为│   │真正扣库存   │   │真正扣钱    │
│已确认      │   │             │   │            │
└────────────┘   └────────────┘   └────────────┘

如果Try有失败 → 执行Cancel：
┌─ 订单服务 ─┐   ┌─ 库存服务 ─┐   ┌─ 支付服务 ─┐
│删除待确认   │   │释放预扣库存│   │解冻账户余额│ 
│订单        │   │             │   │            │
└────────────┘   └────────────┘   └────────────┘
```

### 5.3 TCC代码示例


```java
// 库存服务的TCC实现
@Service
public class InventoryTccService {
    
    // Try：预扣库存
    @Tcc(confirmMethod = "confirmReduce", cancelMethod = "cancelReduce")
    public boolean tryReduce(String productId, int quantity) {
        // 检查库存是否足够
        if (getAvailableStock(productId) < quantity) {
            return false;
        }
        
        // 预扣：可用库存-quantity，冻结库存+quantity
        updateStock(productId, -quantity, quantity);
        return true;
    }
    
    // Confirm：确认扣库存  
    public boolean confirmReduce(String productId, int quantity) {
        // 将冻结库存真正扣掉
        reduceFrozenStock(productId, quantity);
        return true;
    }
    
    // Cancel：释放预扣库存
    public boolean cancelReduce(String productId, int quantity) {
        // 恢复：可用库存+quantity，冻结库存-quantity  
        updateStock(productId, quantity, -quantity);
        return true;
    }
}
```

### 5.4 TCC的优缺点


**✅ TCC优点**：
```
🔸 性能较好：不长时间锁定资源
🔸 一致性强：通过补偿保证最终一致
🔸 灵活性高：每个服务可自定义TCC逻辑
🔸 适用性广：适合大多数业务场景
```

**❌ TCC缺点**：
```  
🔸 开发复杂：每个操作要写3个方法
🔸 业务侵入：需要修改原有业务逻辑
🔸 数据设计复杂：需要额外字段存储中间状态
🔸 补偿逻辑复杂：Cancel操作必须能成功执行
```

### 5.5 TCC设计要点


**🎯 幂等性设计**：
```java
// Confirm和Cancel方法必须幂等
public boolean confirmReduce(String productId, int quantity) {
    // 检查是否已经执行过
    if (isAlreadyConfirmed(productId, quantity)) {
        return true; // 已执行过，直接返回成功
    }
    
    // 执行确认逻辑
    return doConfirm(productId, quantity);
}
```

**💡 空回滚处理**：
```
场景：Try阶段因网络问题没执行，但TCC框架认为失败要执行Cancel
解决：Cancel方法中检查Try是否真的执行过
```

**⚠️ 悬挂处理**：
```
场景：Try阶段网络延迟，Cancel先执行了，Try后执行
解决：Try方法中检查是否已经被Cancel过
```

---

## 6. 🚀 Saga模式详解


### 6.1 Saga核心理念


**🎬 电影拍摄类比**：
> **正向流程**：按剧本拍摄第1场、第2场、第3场...
> **补偿流程**：如果第3场拍坏了，要重拍第3场、删除第2场、删除第1场
> 
> Saga就是这样：**正向执行 + 反向补偿**

**💡 技术定义**：
```
Saga = 一系列本地事务 + 补偿事务

核心思想：
• 将大事务拆分成多个小的本地事务
• 每个本地事务都有对应的补偿事务  
• 如果某步失败，执行前面所有步骤的补偿操作
```

### 6.2 Saga执行模式


**🔸 编排模式（Orchestration）**：
```
有一个中央协调器控制整个流程

电商下单流程：
协调器 → 创建订单 → 扣库存 → 扣款 → 发货通知

如果扣款失败：
协调器 ← 恢复库存 ← 取消订单
```

**🔸 编舞模式（Choreography）**：  
```
每个服务自己决定下一步做什么，通过事件驱动

订单服务：创建订单 → 发布"订单创建"事件
库存服务：收到事件 → 扣库存 → 发布"库存已扣"事件
支付服务：收到事件 → 扣款 → 发布"支付完成"事件

如果支付失败 → 发布"支付失败"事件：
库存服务：收到事件 → 恢复库存 → 发布"库存已恢复"事件
订单服务：收到事件 → 取消订单
```

### 6.3 Saga代码示例


```java
// Saga编排器示例
@Component
public class OrderSagaOrchestrator {
    
    @Autowired
    private OrderService orderService;
    @Autowired  
    private InventoryService inventoryService;
    @Autowired
    private PaymentService paymentService;
    
    public void processOrder(OrderRequest request) {
        SagaTransaction saga = SagaManager.create();
        
        try {
            // 步骤1：创建订单
            String orderId = saga.execute(
                () -> orderService.createOrder(request),
                () -> orderService.cancelOrder(orderId)
            );
            
            // 步骤2：扣库存  
            saga.execute(
                () -> inventoryService.reduce(request.getProductId(), request.getQuantity()),
                () -> inventoryService.restore(request.getProductId(), request.getQuantity())
            );
            
            // 步骤3：扣款
            saga.execute(
                () -> paymentService.pay(request.getUserId(), request.getAmount()),
                () -> paymentService.refund(request.getUserId(), request.getAmount())
            );
            
            // 所有步骤成功
            saga.commit();
            
        } catch (Exception e) {
            // 有步骤失败，执行补偿
            saga.rollback();
            throw new OrderProcessException("订单处理失败", e);
        }
    }
}
```

### 6.4 Saga的优缺点


**✅ Saga优点**：
```
🔸 性能好：每步都是本地事务，执行快
🔸 可用性高：不会长时间锁定资源
🔸 扩展性好：容易添加新的业务步骤
🔸 业务清晰：事务流程一目了然
```

**❌ Saga缺点**：
```
🔸 一致性弱：中间状态对外可见
🔸 补偿复杂：每个操作都要设计补偿逻辑
🔸 业务限制：有些操作很难补偿（如发短信）
🔸 数据可见：用户可能看到中间状态
```

### 6.5 Saga设计原则


**💡 补偿原则**：
```
✅ 可补偿：每个操作都要有对应的补偿操作
✅ 幂等性：补偿操作可以执行多次
✅ 可重试：补偿失败后可以重试
✅ 可观测：记录详细日志，便于问题排查
```

**⚠️ 业务设计考虑**：
```
🔸 尽量将不可逆操作放在最后（如发送通知）
🔸 设计合理的中间状态（如"处理中"状态）
🔸 向用户明确展示当前处理状态
🔸 提供查询接口让用户了解处理进度
```

---

## 7. 📨 消息事务模式


### 7.1 消息事务基本理念


**📮 邮局寄信类比**：
> **可靠投递**：你把信交给邮局，邮局保证一定送到，如果第一次没送到会继续重试
> **最终一致**：信可能今天送到，也可能明天送到，但最终一定会送到

**💡 技术定义**：
```
消息事务 = 本地事务 + 消息队列的可靠投递

核心思想：
• 先做本地事务，成功后发送消息
• 消息队列保证消息一定被消费
• 消费者处理消息，实现最终一致性
```

### 7.2 消息事务实现方式


**🔸 本地消息表**：
```
执行流程：
1. 开启数据库事务
2. 执行业务操作（如创建订单）
3. 在同一事务中插入消息记录到消息表
4. 提交事务
5. 定时任务扫描消息表，发送未发送的消息
6. 消费者处理消息，执行对应业务

优点：实现简单，事务性强
缺点：需要额外的消息表，定时任务轮询
```

**🔸 事务消息（如RocketMQ）**：
```
执行流程：
1. 发送半消息（Prepare消息）到MQ
2. 执行本地事务
3. 根据本地事务结果确认或回滚消息
4. MQ将确认的消息投递给消费者

优点：MQ保证消息可靠性，无需额外存储
缺点：依赖特定MQ，实现相对复杂
```

### 7.3 消息事务代码示例


```java
// 基于本地消息表的实现
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private MessageRepository messageRepository;
    
    // 创建订单，同时记录消息
    public void createOrder(OrderRequest request) {
        // 1. 创建订单
        Order order = new Order(request);
        orderRepository.save(order);
        
        // 2. 在同一事务中保存消息
        Message message = new Message(
            "inventory.reduce", // 消息主题
            order.toJson(),     // 消息内容
            MessageStatus.PENDING // 待发送状态
        );
        messageRepository.save(message);
        
        // 事务提交后，订单和消息都保存成功
    }
}

// 消息发送器（定时任务）
@Component
public class MessageSender {
    
    @Scheduled(fixedDelay = 5000) // 每5秒执行一次
    public void sendPendingMessages() {
        List<Message> messages = messageRepository.findPendingMessages();
        
        for (Message message : messages) {
            try {
                // 发送消息到MQ
                messageQueue.send(message.getTopic(), message.getContent());
                
                // 标记为已发送
                message.setStatus(MessageStatus.SENT);
                messageRepository.save(message);
                
            } catch (Exception e) {
                // 发送失败，等待下次重试
                log.error("消息发送失败: {}", message.getId(), e);
            }
        }
    }
}

// 消费者
@RabbitListener(queues = "inventory.reduce")
public void handleInventoryReduce(String messageContent) {
    try {
        OrderInfo order = JSON.parseObject(messageContent, OrderInfo.class);
        
        // 执行库存扣减（幂等操作）
        inventoryService.reduce(order.getProductId(), order.getQuantity());
        
    } catch (Exception e) {
        // 处理失败，消息会重新投递
        throw new RuntimeException("库存扣减失败", e);
    }
}
```

### 7.4 消息事务的优缺点


**✅ 消息事务优点**：
```
🔸 解耦性好：服务间通过消息异步通信
🔸 性能较好：异步处理，不阻塞主流程
🔸 可扩展：容易添加新的消费者
🔸 最终一致：保证数据最终会一致
```

**❌ 消息事务缺点**：
```
🔸 时效性差：可能存在延迟
🔸 复杂性高：需要处理重复消费、消息丢失等
🔸 调试困难：异步流程不好追踪
🔸 一致性弱：短时间内数据不一致
```

### 7.5 消息事务关键问题


**🔸 消息重复处理**：
```java
// 消费端需要保证幂等
@Service  
public class InventoryService {
    
    public void reduce(String productId, int quantity, String messageId) {
        // 检查消息是否已处理
        if (isMessageProcessed(messageId)) {
            return; // 已处理，直接返回
        }
        
        // 执行业务逻辑
        doReduce(productId, quantity);
        
        // 记录消息已处理
        markMessageAsProcessed(messageId);
    }
}
```

**🔸 消息丢失处理**：
```
发送端：使用本地消息表或事务消息
传输中：MQ持久化，集群部署
接收端：手动ACK，处理成功后才确认
```

---

## 8. 📊 方案对比与选型指导


### 8.1 各方案特性对比


| **方案** | **一致性强度** | **性能** | **可用性** | **开发复杂度** | **适用场景** |
|---------|-------------|---------|-----------|--------------|-------------|
| **2PC** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | `金融转账、核心交易` |
| **3PC** | ⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐ | ⭐⭐⭐ | `理论研究，实际很少用` |
| **TCC** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | `电商下单、预订系统` |
| **Saga** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | `长流程业务、批处理` |
| **消息事务** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | `数据同步、最终一致性` |

### 8.2 选型决策树


```
开始选型
    ↓
对一致性要求高？
    ├─ 是 → 能接受性能损失？
    │       ├─ 是 → 使用 2PC
    │       └─ 否 → 使用 TCC
    └─ 否 → 业务流程长？
            ├─ 是 → 使用 Saga
            └─ 否 → 使用消息事务
```

### 8.3 实际业务场景选型


**🏪 电商下单场景**：
```
业务特点：
• 并发量大，性能要求高
• 允许短时间数据不一致
• 需要快速响应用户

推荐方案：TCC + 消息事务
• TCC处理核心事务（订单、库存、支付）
• 消息事务处理非核心业务（积分、优惠券）
```

**🏦 银行转账场景**：
```
业务特点：
• 数据一致性要求极高
• 金额不能出错
• 并发量相对较小

推荐方案：2PC或强一致性方案
• 牺牲性能保证数据绝对准确
• 可配合数据库XA事务
```

**📦 物流跟踪场景**：
```
业务特点：
• 流程较长（下单→发货→运输→签收）
• 每步相对独立
• 允许最终一致性

推荐方案：Saga模式
• 每个环节作为一个事务
• 支持长流程编排
```

**📊 数据同步场景**：
```
业务特点：
• 实时性要求不高
• 数据量大
• 需要解耦

推荐方案：消息事务
• 异步处理，不影响主业务
• 天然支持解耦
```

### 8.4 混合使用策略


**🎯 现实项目中的最佳实践**：

```java
// 电商下单：混合使用多种方案
@Service
public class OrderProcessService {
    
    // 核心业务用TCC保证强一致
    @TccTransaction
    public void processMainOrder(OrderRequest request) {
        // TCC: 订单、库存、支付
        orderTccService.createOrder(request);
        inventoryTccService.reduceStock(request); 
        paymentTccService.pay(request);
    }
    
    // 非核心业务用消息事务保证最终一致
    @EventListener
    public void handleOrderSuccess(OrderCreatedEvent event) {
        // 消息事务: 积分、优惠券、通知
        messageQueue.send("user.points.add", event);
        messageQueue.send("coupon.use", event);
        messageQueue.send("notification.send", event);
    }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 分布式事务本质：保证多个分布式资源的数据一致性
🔸 刚性vs柔性：强一致性vs最终一致性的权衡
🔸 2PC原理：两阶段提交的协调机制
🔸 TCC模式：Try-Confirm-Cancel补偿机制
🔸 Saga模式：正向执行+反向补偿
🔸 消息事务：本地事务+消息队列可靠投递
```

### 9.2 关键理解要点


**🔹 没有银弹**：
```
每种方案都有优缺点：
• 2PC：一致性强但性能差
• TCC：性能好但开发复杂  
• Saga：灵活但补偿困难
• 消息：解耦但时效性差

实际项目中要根据业务特点选择合适方案
```

**🔹 性能vs一致性**：
```
核心矛盾：
• 强一致性 → 性能差、可用性低
• 弱一致性 → 性能好、业务复杂

选择原则：
• 核心业务优先保证一致性
• 非核心业务优先保证性能
```

**🔹 业务设计的重要性**：
```
技术只是手段，业务设计更重要：
• 合理拆分事务边界
• 设计好中间状态和补偿逻辑
• 向用户透明展示处理状态
• 提供查询和申诉机制
```

### 9.3 实际应用指导


**🎯 开发建议**：
- **从简单开始**：先用消息事务，再考虑TCC
- **混合使用**：核心事务用TCC，非核心用消息
- **重视监控**：分布式事务必须有完善监控
- **做好预案**：设计异常处理和人工干预机制

**🔧 技术选型步骤**：
1. **分析业务特点**：一致性要求、性能要求、业务复杂度
2. **评估技术约束**：团队技能、现有架构、运维能力
3. **选择合适方案**：参考决策树，可以混合使用
4. **做好监控**：事务状态监控、异常告警、数据对账

**💡 避坑指南**：
- **不要过度设计**：简单业务用简单方案
- **重视幂等性**：所有操作都要支持重试
- **做好降级**：关键时刻要能快速降级
- **完善文档**：复杂的补偿逻辑要有详细文档

**核心记忆**：
> 🎯 **分布式事务核心**：在性能、一致性、复杂度之间找平衡
> 
> 🔑 **选择原则**：核心业务保一致，非核心业务保性能
> 
> 🚀 **实践要点**：从简单开始，逐步优化，混合使用