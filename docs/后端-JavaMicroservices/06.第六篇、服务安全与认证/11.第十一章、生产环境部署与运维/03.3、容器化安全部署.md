---
title: 3、容器化安全部署
---
## 📚 目录

1. [容器化部署安全概述](#1-容器化部署安全概述)
2. [Docker容器安全实践](#2-Docker容器安全实践)
3. [Kubernetes安全策略](#3-Kubernetes安全策略)
4. [镜像安全与扫描](#4-镜像安全与扫描)
5. [容器运行时安全](#5-容器运行时安全)
6. [网络策略配置](#6-网络策略配置)
7. [密钥管理最佳实践](#7-密钥管理最佳实践)
8. [服务网格安全](#8-服务网格安全)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🐳 容器化部署安全概述


### 1.1 什么是容器化安全


**通俗理解**：就像把应用装进一个个集装箱里运输，每个集装箱要确保：
- 箱子本身没有破损（镜像安全）
- 箱子里的东西不会泄露（运行时隔离）
- 箱子之间互不干扰（网络隔离）
- 箱子的钥匙安全保管（密钥管理）

```
传统部署 vs 容器化部署的安全差异：

传统部署：
应用A  应用B  应用C
  ↓      ↓      ↓
   操作系统（共享）
  ↓
硬件资源

问题：应用之间可能相互影响，安全边界模糊

容器化部署：
┌────────┐ ┌────────┐ ┌────────┐
│ 应用A  │ │ 应用B  │ │ 应用C  │
│+运行时 │ │+运行时 │ │+运行时 │
└────────┘ └────────┘ └────────┘
           ↓
        容器引擎
           ↓
        操作系统
           ↓
        硬件资源

优势：每个应用独立隔离，安全边界清晰
```

### 1.2 容器安全的核心维度


| 安全维度 | **核心问题** | **解决方案** | **重要程度** |
|---------|------------|-------------|------------|
| 🔒 **镜像安全** | `镜像是否包含漏洞？` | `漏洞扫描+可信源` | ⭐⭐⭐⭐⭐ |
| 🛡️ **运行时安全** | `容器运行时是否隔离？` | `权限控制+资源限制` | ⭐⭐⭐⭐⭐ |
| 🌐 **网络安全** | `容器间通信是否可控？` | `网络策略+服务网格` | ⭐⭐⭐⭐ |
| 🔑 **密钥安全** | `敏感信息如何存储？` | `Secrets管理+加密` | ⭐⭐⭐⭐⭐ |
| 📊 **监控审计** | `异常行为能否发现？` | `日志+监控+告警` | ⭐⭐⭐⭐ |

### 1.3 容器安全的攻击面


**常见安全风险**：
```
攻击面分析：

1. 镜像层面：
   ❌ 使用过时的基础镜像
   ❌ 包含已知漏洞的依赖
   ❌ 硬编码敏感信息
   
2. 运行时层面：
   ❌ 以root用户运行容器
   ❌ 挂载敏感目录
   ❌ 特权模式运行
   
3. 网络层面：
   ❌ 暴露不必要的端口
   ❌ 缺少网络隔离
   ❌ 未加密的服务通信
   
4. 编排层面：
   ❌ 弱认证机制
   ❌ 过度宽松的RBAC权限
   ❌ 缺少安全策略约束
```

---

## 2. 🐳 Docker容器安全实践


### 2.1 安全的Dockerfile编写


**核心原则**：最小化、无特权、多阶段构建

```dockerfile
# ❌ 不安全的写法
FROM ubuntu:latest
RUN apt-get update && apt-get install -y openjdk-17-jdk
COPY app.jar /app.jar
CMD ["java", "-jar", "/app.jar"]

# ✅ 安全的多阶段构建写法
# 第一阶段：构建应用
FROM maven:3.8-openjdk-17-slim AS builder
WORKDIR /build
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

# 第二阶段：运行环境
FROM eclipse-temurin:17-jre-alpine
LABEL maintainer="security-team@company.com"

# 创建非root用户
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# 只复制必要的文件
COPY --from=builder /build/target/app.jar /app/app.jar

# 切换到非root用户
USER appuser

# 暴露必要端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget --quiet --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

**关键安全点解释**：

🔸 **使用精简基础镜像**
```
为什么用 alpine？
- Ubuntu镜像：~70MB，包含大量不必要的工具
- Alpine镜像：~5MB，只有基本运行环境
- 攻击面更小，漏洞更少
```

🔸 **多阶段构建**
```
好处：
1. 构建工具不进入最终镜像（如Maven、Gradle）
2. 源代码不暴露在生产镜像中
3. 最终镜像体积更小

构建阶段  →  运行阶段
 (大镜像)     (小镜像)
 包含源码     只有JAR包
 包含构建工具  只有JRE
```

🔸 **非root用户运行**
```
风险对比：

root用户运行：
容器被攻破 → 拥有容器完全控制权 → 可能逃逸到宿主机

普通用户运行：
容器被攻破 → 权限受限 → 难以进行进一步攻击
```

### 2.2 Docker运行时安全配置


```bash
# ❌ 危险的运行方式
docker run -d --privileged \
  -v /:/host \
  myapp:latest

# ✅ 安全的运行方式
docker run -d \
  --name myapp \
  --user 1000:1000 \
  --read-only \
  --tmpfs /tmp \
  --security-opt=no-new-privileges \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \
  --memory="512m" \
  --cpus="1.0" \
  --network myapp-network \
  -e SPRING_PROFILES_ACTIVE=prod \
  myapp:1.0.0
```

**参数详解**：

| 参数 | **作用** | **安全意义** |
|------|---------|------------|
| `--user 1000:1000` | `指定用户ID运行` | `避免root权限` |
| `--read-only` | `文件系统只读` | `防止恶意写入` |
| `--tmpfs /tmp` | `临时目录内存挂载` | `写入数据重启消失` |
| `--security-opt=no-new-privileges` | `禁止提权` | `防止权限升级攻击` |
| `--cap-drop ALL` | `删除所有Linux能力` | `最小权限原则` |
| `--memory="512m"` | `内存限制` | `防止资源耗尽攻击` |

### 2.3 Docker安全扫描


**使用Trivy扫描镜像漏洞**：

```bash
# 安装Trivy
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# 扫描本地镜像
trivy image myapp:1.0.0

# 扫描结果示例
myapp:1.0.0 (alpine 3.18.0)
==========================
Total: 15 (CRITICAL: 2, HIGH: 5, MEDIUM: 8)

┌─────────────┬──────────────┬──────────┬────────────┬─────────────┐
│  Library    │ Vulnerability│ Severity │  Installed │   Fixed     │
├─────────────┼──────────────┼──────────┼────────────┼─────────────┤
│ openssl     │ CVE-2023-xxx │ CRITICAL │ 1.1.1q     │ 1.1.1t      │
│ curl        │ CVE-2023-yyy │ HIGH     │ 7.79.0     │ 7.79.1      │
└─────────────┴──────────────┴──────────┴────────────┴─────────────┘
```

**集成到CI/CD流程**：

```yaml
# GitLab CI示例
security-scan:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 1 --severity CRITICAL,HIGH $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  allow_failure: false
```

---

## 3. ☸️ Kubernetes安全策略


### 3.1 Pod安全策略（Security Context）


**什么是Security Context？**
> 就像给容器设置"行为规范"，规定它能做什么、不能做什么

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secure-app
spec:
  # Pod级别的安全配置
  securityContext:
    runAsNonRoot: true      # 必须以非root用户运行
    runAsUser: 1000         # 指定用户ID
    runAsGroup: 3000        # 指定组ID
    fsGroup: 2000           # 文件系统组ID
    seccompProfile:         # 系统调用过滤
      type: RuntimeDefault
  
  containers:
  - name: app
    image: myapp:1.0.0
    # 容器级别的安全配置
    securityContext:
      allowPrivilegeEscalation: false  # 禁止提权
      readOnlyRootFilesystem: true     # 只读文件系统
      capabilities:
        drop:
          - ALL                          # 删除所有能力
        add:
          - NET_BIND_SERVICE             # 只添加必要能力
    
    # 资源限制
    resources:
      limits:
        memory: "512Mi"
        cpu: "1000m"
      requests:
        memory: "256Mi"
        cpu: "500m"
    
    # 只读挂载配置
    volumeMounts:
    - name: config
      mountPath: /app/config
      readOnly: true
    - name: tmp
      mountPath: /tmp
  
  volumes:
  - name: config
    configMap:
      name: app-config
  - name: tmp
    emptyDir: {}
```

**配置要点解释**：

🔸 **runAsNonRoot: true**
```
作用：Kubernetes会检查容器是否以root运行
- 如果以root运行 → Pod启动失败
- 强制开发者使用非root用户
```

🔸 **readOnlyRootFilesystem: true**
```
原理：
常规文件系统      只读文件系统
    ↓                 ↓
可以写入          不能写入
攻击者可植入      攻击者无法植入
恶意文件          恶意文件

注意：临时文件需要用emptyDir或tmpfs
```

🔸 **capabilities管理**
```
Linux Capabilities（能力）理解：

传统：要么root（所有权限），要么普通用户（受限权限）

Capabilities：把root权限拆分成30多个细粒度权限
- CAP_NET_BIND_SERVICE：绑定1024以下端口
- CAP_SYS_ADMIN：系统管理
- CAP_NET_ADMIN：网络管理
...

最佳实践：
drop ALL → 删除所有能力
add 只添加需要的能力
```

### 3.2 RBAC权限控制


**什么是RBAC？**
> 基于角色的访问控制，类似公司里的权限管理：普通员工、部门经理、CEO拥有不同权限

```yaml
# 1. 创建ServiceAccount（相当于创建一个"账号"）
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-service-account
  namespace: production

---
# 2. 定义Role（定义"职位"能做什么）
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-role
  namespace: production
rules:
  # 只能读取ConfigMap
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "watch"]
  
  # 只能读取Secret
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get"]

---
# 3. 绑定角色（把"职位"分配给"账号"）
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-role-binding
  namespace: production
subjects:
  - kind: ServiceAccount
    name: app-service-account
    namespace: production
roleRef:
  kind: Role
  name: app-role
  apiGroup: rbac.authorization.k8s.io

---
# 4. Pod使用该ServiceAccount
apiVersion: v1
kind: Pod
metadata:
  name: secure-app
  namespace: production
spec:
  serviceAccountName: app-service-account  # 使用特定账号
  automountServiceAccountToken: true        # 自动挂载认证令牌
  containers:
  - name: app
    image: myapp:1.0.0
```

**RBAC权限设计原则**：

```
权限分层设计：

最小权限原则：
┌─────────────────────────────────┐
│  只给必需的权限，不多给一点      │
│                                 │
│  ❌ 给所有Secret读取权限         │
│  ✅ 只给特定Secret读取权限       │
└─────────────────────────────────┘

权限隔离：
开发环境  → dev-namespace  → dev-role
测试环境  → test-namespace → test-role  
生产环境  → prod-namespace → prod-role（权限最严格）
```

### 3.3 网络策略（NetworkPolicy）


**什么是NetworkPolicy？**
> 就像公司内部的门禁系统，规定哪些部门之间可以互相访问

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: app-network-policy
  namespace: production
spec:
  # 应用到哪些Pod
  podSelector:
    matchLabels:
      app: myapp
  
  # 策略类型
  policyTypes:
    - Ingress   # 入站流量
    - Egress    # 出站流量
  
  # 入站规则：谁可以访问我
  ingress:
    # 规则1：只允许来自前端服务的流量
    - from:
      - podSelector:
          matchLabels:
            app: frontend
      ports:
      - protocol: TCP
        port: 8080
    
    # 规则2：允许来自Ingress的流量
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      ports:
      - protocol: TCP
        port: 8080
  
  # 出站规则：我可以访问谁
  egress:
    # 规则1：可以访问数据库
    - to:
      - podSelector:
          matchLabels:
            app: database
      ports:
      - protocol: TCP
        port: 3306
    
    # 规则2：可以访问外部DNS
    - to:
      - namespaceSelector: {}
      ports:
      - protocol: UDP
        port: 53
    
    # 规则3：可以访问外部API（指定IP）
    - to:
      - ipBlock:
          cidr: 10.0.0.0/24
      ports:
      - protocol: TCP
        port: 443
```

**网络策略可视化**：

```
没有NetworkPolicy（默认）：
所有Pod可以互相访问
┌────────┐    ┌────────┐    ┌────────┐
│Frontend│←→  │Backend │←→  │Database│
└────────┘    └────────┘    └────────┘
     ↕            ↕            ↕
   任何Pod      任何Pod      任何Pod

应用NetworkPolicy后：
┌────────┐    ┌────────┐    ┌────────┐
│Frontend│ →  │Backend │ →  │Database│
└────────┘    └────────┘    └────────┘
              
Frontend → Backend: ✅ 允许
Frontend → Database: ❌ 拒绝（必须通过Backend）
Backend → Database: ✅ 允许
外部 → Backend: ❌ 拒绝（只能通过Ingress）
```

**实际应用场景**：

```yaml
# 场景：微服务架构的网络隔离
# 
# 架构：
#   Internet → Ingress → API Gateway → [订单服务, 用户服务] → 数据库
#
# 安全要求：
# 1. 外部只能访问API Gateway
# 2. API Gateway可以访问所有后端服务
# 3. 后端服务只能访问数据库，不能互相访问
# 4. 数据库不能被外部访问

# 1. API Gateway的网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-gateway-policy
spec:
  podSelector:
    matchLabels:
      app: api-gateway
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx  # 只接受Ingress流量
  egress:
    - to:
      - podSelector:
          matchLabels:
            tier: backend        # 可以访问所有后端服务

# 2. 后端服务的网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
spec:
  podSelector:
    matchLabels:
      tier: backend
  ingress:
    - from:
      - podSelector:
          matchLabels:
            app: api-gateway      # 只接受API Gateway流量
  egress:
    - to:
      - podSelector:
          matchLabels:
            app: database         # 只能访问数据库

# 3. 数据库的网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: database-policy
spec:
  podSelector:
    matchLabels:
      app: database
  ingress:
    - from:
      - podSelector:
          matchLabels:
            tier: backend         # 只接受后端服务流量
  egress: []                      # 不允许任何出站流量
```

---

## 4. 🔍 镜像安全与扫描


### 4.1 镜像安全基础


**镜像安全的三个关键问题**：
1. 镜像来源可信吗？（供应链安全）
2. 镜像有漏洞吗？（漏洞扫描）
3. 镜像内容合规吗？（策略检查）

```
镜像供应链安全：

不安全的流程：
开发者 → 随意拉取镜像 → 构建应用 → 部署
         ↓
      可能包含：
      - 恶意软件
      - 后门程序
      - 已知漏洞

安全的流程：
开发者 → 受信任的镜像仓库 → 扫描检查 → 签名验证 → 部署
         ↓                   ↓           ↓
      官方/私有仓库        无严重漏洞   签名有效
```

### 4.2 镜像签名与验证


**什么是镜像签名？**
> 就像快递包裹上的封条，确保内容没被篡改

```bash
# 使用Cosign签名镜像

# 1. 生成密钥对
cosign generate-key-pair

# 2. 签名镜像
cosign sign --key cosign.key myregistry.com/myapp:1.0.0

# 3. 验证签名
cosign verify --key cosign.pub myregistry.com/myapp:1.0.0
```

**在Kubernetes中强制验证**：

```yaml
# 使用Policy Controller强制验证签名
apiVersion: policy.sigstore.dev/v1beta1
kind: ClusterImagePolicy
metadata:
  name: require-signed-images
spec:
  images:
  - glob: "myregistry.com/**"
  authorities:
  - keyless:
      url: https://fulcio.sigstore.dev
    ctlog:
      url: https://rekor.sigstore.dev
```

### 4.3 漏洞扫描实践


**集成到CI/CD的完整流程**：

```yaml
# Jenkins Pipeline示例
pipeline {
    agent any
    
    stages {
        stage('Build Image') {
            steps {
                sh 'docker build -t myapp:${BUILD_NUMBER} .'
            }
        }
        
        stage('Security Scan') {
            steps {
                script {
                    // 使用Trivy扫描
                    sh """
                        trivy image \
                          --severity CRITICAL,HIGH \
                          --exit-code 1 \
                          --format json \
                          --output trivy-report.json \
                          myapp:${BUILD_NUMBER}
                    """
                }
            }
        }
        
        stage('Sign Image') {
            when {
                expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
            }
            steps {
                sh 'cosign sign --key cosign.key myapp:${BUILD_NUMBER}'
            }
        }
        
        stage('Push Image') {
            when {
                expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
            }
            steps {
                sh 'docker push myapp:${BUILD_NUMBER}'
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'trivy-report.json'
        }
        failure {
            emailext subject: "镜像安全扫描失败: ${env.JOB_NAME}",
                     body: "发现高危漏洞，请查看附件报告",
                     attachmentsPattern: 'trivy-report.json'
        }
    }
}
```

**漏洞处理流程**：

```
发现漏洞后的处理步骤：

1. 评估严重性
   ├─ CRITICAL → 立即修复，阻止部署
   ├─ HIGH     → 24小时内修复
   ├─ MEDIUM   → 1周内修复
   └─ LOW      → 计划修复

2. 修复方案
   ├─ 升级依赖版本
   ├─ 更换替代组件
   ├─ 应用安全补丁
   └─ 等待上游修复（风险接受）

3. 验证修复
   ├─ 重新扫描
   ├─ 功能测试
   └─ 回归测试

4. 文档记录
   └─ 记录漏洞ID、影响范围、修复方案
```

---

## 5. 🛡️ 容器运行时安全


### 5.1 容器隔离原理


**Linux命名空间（Namespace）**：
> 就像给每个容器一个独立的"虚拟世界"，互不干扰

```
6种主要命名空间：

1. PID Namespace（进程隔离）
   容器内：   容器外：
   PID 1      PID 1234（容器进程）
   PID 2      PID 1235
   看不到宿主机进程

2. Network Namespace（网络隔离）
   容器内：        容器外：
   eth0:172.17.0.2  eth0:192.168.1.100
   独立IP和端口    独立网络栈

3. Mount Namespace（文件系统隔离）
   容器内：     容器外：
   /app        /var/lib/docker/overlay2/...
   看到的是    实际存储位置
   独立文件系统

4. UTS Namespace（主机名隔离）
   容器内：hostname = container-xyz
   容器外：hostname = host-server

5. IPC Namespace（进程间通信隔离）
   容器之间无法共享内存、信号量等

6. User Namespace（用户隔离）
   容器内root → 容器外普通用户
   权限映射，降低风险
```

**Cgroups（控制组）**：
> 限制容器能使用的资源，防止"吃独食"

```
资源限制示例：

内存限制：
┌─────────────────────────┐
│ 容器A: 最多512MB        │
│ ████████░░░░ 60%使用    │
├─────────────────────────┤
│ 容器B: 最多1GB          │
│ ██████████░░ 80%使用    │
├─────────────────────────┤
│ 剩余内存供宿主机使用     │
└─────────────────────────┘

CPU限制：
容器A: 0.5核心 (50%单核)
容器B: 2核心   (2个完整核心)
```

### 5.2 AppArmor/SELinux安全模块


**什么是AppArmor？**
> 强制访问控制系统，定义程序能访问哪些文件和系统资源

```bash
# AppArmor配置示例
# 文件：/etc/apparmor.d/docker-myapp

#include <tunables/global>

profile docker-myapp flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>
  
  # 允许读取应用文件
  /app/** r,
  
  # 允许读写临时目录
  /tmp/** rw,
  
  # 允许读取配置
  /app/config/** r,
  
  # 禁止访问敏感文件
  deny /etc/shadow r,
  deny /root/** rw,
  deny /home/** rw,
  
  # 允许网络访问
  network inet stream,
  network inet6 stream,
  
  # 允许必要的系统调用
  capability net_bind_service,
}
```

**在Kubernetes中使用**：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secured-app
  annotations:
    container.apparmor.security.beta.kubernetes.io/app: localhost/docker-myapp
spec:
  containers:
  - name: app
    image: myapp:1.0.0
```

### 5.3 Seccomp安全配置


**什么是Seccomp？**
> 系统调用过滤器，限制容器能使用哪些系统调用

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": ["SCMP_ARCH_X86_64"],
  "syscalls": [
    {
      "names": [
        "accept", "accept4", "bind", "connect", "listen",
        "read", "write", "open", "openat", "close",
        "stat", "fstat", "lstat", "poll", "epoll_wait",
        "socket", "socketpair", "sendto", "recvfrom"
      ],
      "action": "SCMP_ACT_ALLOW"
    },
    {
      "names": ["reboot", "swapon", "swapoff"],
      "action": "SCMP_ACT_ERRNO",
      "comment": "禁止系统管理调用"
    }
  ]
}
```

**在Kubernetes中应用**：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secure-app
spec:
  securityContext:
    seccompProfile:
      type: Localhost
      localhostProfile: profiles/myapp-seccomp.json
  containers:
  - name: app
    image: myapp:1.0.0
```

---

## 6. 🌐 网络策略配置


### 6.1 服务间通信加密


**mTLS（双向TLS）原理**：
> 不仅服务器证明身份，客户端也要证明身份

```
普通HTTPS（单向TLS）：
客户端                    服务器
   |--请求握手------------>|
   |<--服务器证书----------|
   |--验证证书            |
   |--加密通信------------>|

mTLS（双向TLS）：
客户端                    服务器
   |--请求握手------------>|
   |<--服务器证书----------|
   |--客户端证书---------->|
   |                       |--验证客户端证书
   |<--验证通过------------|
   |--加密通信------------>|

优势：确保通信双方都是合法的
```

**使用Istio实现mTLS**：

```yaml
# 1. 启用全局mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: production
spec:
  mtls:
    mode: STRICT  # 强制mTLS

---
# 2. 定义流量策略
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: myapp-mtls
  namespace: production
spec:
  host: myapp.production.svc.cluster.local
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL  # 使用Istio的mTLS
```

### 6.2 入口流量控制


```yaml
# Ingress安全配置
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: secure-ingress
  annotations:
    # 强制HTTPS
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # 限流
    nginx.ingress.kubernetes.io/limit-rps: "100"
    
    # 白名单IP
    nginx.ingress.kubernetes.io/whitelist-source-range: "10.0.0.0/8,192.168.0.0/16"
    
    # WAF规则
    nginx.ingress.kubernetes.io/enable-modsecurity: "true"
    nginx.ingress.kubernetes.io/enable-owasp-core-rules: "true"
    
    # 证书管理
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.mycompany.com
    secretName: api-tls-cert
  rules:
  - host: api.mycompany.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp
            port:
              number: 8080
```

---

## 7. 🔑 密钥管理最佳实践


### 7.1 Kubernetes Secrets管理


**什么是Secrets？**
> 专门存储敏感信息的Kubernetes对象，比ConfigMap更安全

```yaml
# 创建Secret
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
  namespace: production
type: Opaque
stringData:
  username: admin
  password: SuperSecretP@ss123
  db-url: jdbc:mysql://mysql.prod.svc.cluster.local:3306/mydb

---
# 在Pod中使用Secret
apiVersion: v1
kind: Pod
metadata:
  name: myapp
spec:
  containers:
  - name: app
    image: myapp:1.0.0
    env:
    # 方式1：环境变量注入
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: db-credentials
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-credentials
          key: password
    
    # 方式2：文件挂载
    volumeMounts:
    - name: db-config
      mountPath: /etc/db
      readOnly: true
  
  volumes:
  - name: db-config
    secret:
      secretName: db-credentials
      defaultMode: 0400  # 只读权限
```

**Secrets的局限性**：
```
⚠️ Kubernetes Secrets的问题：

1. Base64编码 ≠ 加密
   - Secret内容只是Base64编码
   - etcd中的数据默认未加密
   - 有API权限就能读取

2. 解决方案：
   ├─ 启用etcd加密
   ├─ 使用外部密钥管理系统
   └─ 实施严格的RBAC
```

### 7.2 外部密钥管理（Vault）


**为什么用Vault？**
> 企业级密钥管理系统，提供加密存储、访问控制、审计日志

```yaml
# 使用Vault Injector自动注入密钥
apiVersion: v1
kind: Pod
metadata:
  name: myapp
  annotations:
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/role: "myapp-role"
    vault.hashicorp.com/agent-inject-secret-db: "secret/data/database/config"
    vault.hashicorp.com/agent-inject-template-db: |
      {{- with secret "secret/data/database/config" -}}
      export DB_USERNAME="{{ .Data.data.username }}"
      export DB_PASSWORD="{{ .Data.data.password }}"
      export DB_URL="{{ .Data.data.url }}"
      {{- end -}}
spec:
  serviceAccountName: myapp
  containers:
  - name: app
    image: myapp:1.0.0
    command: ["/bin/sh", "-c"]
    args:
    - |
      source /vault/secrets/db
      java -jar /app/app.jar
```

**Vault工作流程**：

```
密钥获取流程：

1. Pod启动
   ↓
2. Vault Agent Injector自动注入
   ↓
3. 使用ServiceAccount认证到Vault
   ↓
4. Vault验证权限
   ↓
5. 返回密钥
   ↓
6. 密钥写入临时文件（内存文件系统）
   ↓
7. 应用读取密钥启动
   ↓
8. Pod删除时密钥自动销毁
```

### 7.3 密钥轮换策略


```yaml
# 使用External Secrets Operator自动同步
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-credentials
  namespace: production
spec:
  refreshInterval: 1h  # 每小时同步一次
  secretStoreRef:
    kind: ClusterSecretStore
    name: vault-backend
  target:
    name: db-credentials
    creationPolicy: Owner
  data:
  - secretKey: username
    remoteRef:
      key: secret/database/prod
      property: username
  - secretKey: password
    remoteRef:
      key: secret/database/prod
      property: password
```

**密钥轮换最佳实践**：

```
密钥生命周期管理：

创建 → 分发 → 使用 → 轮换 → 销毁
 ↓      ↓      ↓      ↓      ↓
Vault  K8s   应用   自动   定期
生成   Secret  读取   更新   清理

轮换策略：
- 数据库密码：每30天轮换
- API密钥：每90天轮换
- TLS证书：每90天自动更新
- 应用密钥：每次部署轮换
```

---

## 8. 🕸️ 服务网格安全


### 8.1 什么是服务网格


**通俗理解**：
> 服务网格就像在微服务之间加了一层"安全卫士"，管理所有服务间的通信

```
没有服务网格：
服务A --直接调用--> 服务B
- 需要自己实现：加密、认证、重试、监控
- 每个服务都要写一遍
- 代码耦合，难以维护

有服务网格（Istio）：
服务A --> Sidecar代理 --> Sidecar代理 --> 服务B
           ↓                    ↓
        自动处理：           自动处理：
        - mTLS加密          - 认证授权
        - 流量管理          - 监控追踪
        - 熔断重试          - 日志记录
```

### 8.2 Istio安全架构


```
Istio安全组件：

┌─────────────────────────────────────────┐
│           控制平面（Istiod）             │
│  ┌──────────┐  ┌──────────┐  ┌────────┐│
│  │ 证书管理  │  │ 配置分发  │  │ 服务发现││
│  │  (CA)    │  │          │  │        ││
│  └──────────┘  └──────────┘  └────────┘│
└─────────────────────────────────────────┘
              ↓ 下发证书和策略
┌─────────────────────────────────────────┐
│              数据平面                    │
│  ┌─────────┐      ┌─────────┐          │
│  │ 服务A   │      │ 服务B   │          │
│  ├─────────┤      ├─────────┤          │
│  │Envoy    │─mTLS→│Envoy    │          │
│  │Sidecar  │      │Sidecar  │          │
│  └─────────┘      └─────────┘          │
└─────────────────────────────────────────┘
```

**自动mTLS配置**：

```yaml
# 全局启用mTLS
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT

---
# 授权策略：只允许特定服务访问
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: myapp-authz
  namespace: production
spec:
  selector:
    matchLabels:
      app: myapp
  action: ALLOW
  rules:
  # 规则1：允许frontend服务访问
  - from:
    - source:
        principals: ["cluster.local/ns/production/sa/frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/*"]
  
  # 规则2：允许admin用户访问管理接口
  - from:
    - source:
        requestPrincipals: ["cluster.local/admin"]
    to:
    - operation:
        methods: ["GET", "POST", "DELETE"]
        paths: ["/admin/*"]
```

### 8.3 零信任安全模型


**什么是零信任？**
> "永不信任，始终验证" - 即使在内网，也要验证每个请求

```
传统安全模型（城堡模型）：
┌─────────────────────────────┐
│        防火墙              │
│  ┌─────────────────────┐   │
│  │   内网（可信）       │   │
│  │  服务A ←→ 服务B      │   │
│  │  互相信任，无需验证  │   │
│  └─────────────────────┘   │
└─────────────────────────────┘
问题：一旦突破防火墙，内网畅通无阻

零信任模型：
┌─────────────────────────────┐
│  每个请求都要：             │
│  1. 认证身份                │
│  2. 授权检查                │
│  3. 加密通信                │
│                             │
│  服务A → 验证 → 服务B       │
│          ↓                  │
│       策略引擎              │
│       （每次都检查）        │
└─────────────────────────────┘
```

**使用Istio实现零信任**：

```yaml
# 默认拒绝所有流量
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: production
spec:
  {}  # 空规则 = 拒绝所有

---
# 逐个服务开放权限
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  selector:
    matchLabels:
      app: backend
  action: ALLOW
  rules:
  - from:
    - source:
        principals: ["cluster.local/ns/production/sa/frontend"]
    when:
    - key: request.headers[x-api-key]
      values: ["valid-api-key-*"]
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的安全实践


```
🔸 镜像安全：
   ✅ 使用最小化基础镜像（Alpine）
   ✅ 多阶段构建，减少攻击面
   ✅ 定期扫描漏洞，修复高危问题
   ✅ 签名验证，确保供应链安全

🔸 运行时安全：
   ✅ 非root用户运行容器
   ✅ 只读文件系统
   ✅ 删除不必要的Linux能力
   ✅ 资源限制，防止DoS

🔸 网络安全：
   ✅ NetworkPolicy限制流量
   ✅ mTLS加密服务间通信
   ✅ Ingress配置WAF和限流
   ✅ 服务网格统一管理

🔸 密钥安全：
   ✅ 不要硬编码密钥
   ✅ 使用Secrets或Vault
   ✅ 定期轮换密钥
   ✅ 最小权限访问
```

### 9.2 安全检查清单


| 检查项 | **检查内容** | **工具/方法** |
|--------|-------------|-------------|
| ✅ **镜像扫描** | `无高危漏洞` | `Trivy/Clair` |
| ✅ **镜像签名** | `签名验证通过` | `Cosign/Notary` |
| ✅ **Security Context** | `非root运行` | `kubectl describe pod` |
| ✅ **NetworkPolicy** | `流量隔离配置` | `kubectl get networkpolicy` |
| ✅ **RBAC** | `最小权限原则` | `kubectl auth can-i` |
| ✅ **Secrets** | `加密存储` | `Vault/Sealed Secrets` |
| ✅ **mTLS** | `服务间加密` | `Istio/Linkerd` |
| ✅ **监控告警** | `异常检测` | `Falco/Prometheus` |

### 9.3 容器安全的发展趋势


```
未来安全技术：

1. eBPF安全监控
   - 内核级别的实时监控
   - 零性能损耗
   - 精准异常检测

2. 机密计算
   - 运行时数据加密
   - 硬件级别隔离（TEE）
   - 保护敏感工作负载

3. 供应链安全
   - SBOM（软件物料清单）
   - SLSA框架
   - 端到端可追溯

4. 自动化安全
   - Policy as Code
   - GitOps安全
   - 持续合规检查
```

### 9.4 实战建议


**从哪里开始？**

```
安全实施优先级：

第一步（立即实施）：
1. 启用镜像扫描
2. 配置非root运行
3. 设置资源限制
4. 使用Secrets管理密钥

第二步（短期目标）：
1. 配置NetworkPolicy
2. 实施RBAC最小权限
3. 启用审计日志
4. 部署监控告警

第三步（长期规划）：
1. 引入服务网格
2. 实施零信任架构
3. 自动化安全流程
4. 持续安全演练
```

**记忆口诀**：
```
容器安全要做好，四个方面别忘掉
镜像扫描是基础，签名验证防篡改
运行隔离非root，网络策略控访问
密钥管理用Vault，服务网格全加密
```

---

**🎯 学习建议**：
1. 先理解原理，再实践配置
2. 从基础安全做起，逐步深入
3. 定期更新安全知识，关注新漏洞
4. 参与安全演练，积累实战经验
5. 文档化安全策略，团队共同遵守