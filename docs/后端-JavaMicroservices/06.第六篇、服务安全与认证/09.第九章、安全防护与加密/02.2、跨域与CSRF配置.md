---
title: 2、跨域与CSRF配置
---
## 📚 目录

1. [跨域问题的本质](#1-跨域问题的本质)
2. [CORS跨域资源共享](#2-CORS跨域资源共享)
3. [CSRF跨站请求伪护](#3-CSRF跨站请求伪护)
4. [Spring Security配置实战](#4-Spring-Security配置实战)
5. [安全策略最佳实践](#5-安全策略最佳实践)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🌍 跨域问题的本质


### 1.1 什么是跨域


**🔸 通俗理解**

想象你在自己家（网站A）想去邻居家（网站B）借东西，浏览器就像一个"门卫"，默认不允许你随便串门。这就是**同源策略**带来的跨域限制。

```
实际场景：
前端页面：http://localhost:3000
后端接口：http://localhost:8080

浏览器判断：协议相同 ✅  域名不同 ❌  端口不同 ❌
结果：拒绝访问！这就是跨域问题
```

**📋 同源策略三要素**

浏览器判断是否"同源"要看三个条件，**必须全部相同**：

- **协议**：http vs https
- **域名**：localhost vs www.example.com
- **端口**：8080 vs 3000

**🎯 跨域判断示例**

| 当前页面 | 请求地址 | 是否跨域 | 原因 |
|---------|---------|---------|------|
| `http://localhost:8080` | `http://localhost:8080/api` | ✅ 同源 | 协议、域名、端口完全相同 |
| `http://localhost:8080` | `http://localhost:3000/api` | ❌ 跨域 | 端口不同（8080 vs 3000）|
| `http://localhost:8080` | `https://localhost:8080/api` | ❌ 跨域 | 协议不同（http vs https）|
| `http://www.a.com` | `http://www.b.com/api` | ❌ 跨域 | 域名不同（a.com vs b.com）|

### 1.2 为什么需要跨域限制


**🛡️ 安全防护的必要性**

```
恶意网站攻击场景：
1. 你登录了银行网站 bank.com
2. 浏览器保存了登录凭证（Cookie）
3. 你又打开了恶意网站 evil.com
4. 恶意网站偷偷向 bank.com 发请求
5. 如果没有同源策略 → 你的钱可能被转走！

有了同源策略：
浏览器发现 evil.com 向 bank.com 请求
判断：不同源！拒绝请求！保护用户资金安全 ✅
```

**核心作用**：防止恶意网站偷偷读取或操作其他网站的数据

### 1.3 前后端分离的跨域困境


**💻 现代开发的常见场景**

```
传统开发（无跨域问题）：
┌─────────────────┐
│  前端 + 后端     │ ← 都在 localhost:8080
│  (同一个服务器)  │
└─────────────────┘

前后端分离（有跨域问题）：
┌──────────────┐         ┌──────────────┐
│   前端Vue    │ -----×--→│   后端Java   │
│ localhost:3000│  被拦截  │localhost:8080│
└──────────────┘         └──────────────┘
```

**🎯 开发环境 vs 生产环境**

```
开发环境：
前端：http://localhost:3000
后端：http://localhost:8080
问题：端口不同，必然跨域 ❌

生产环境：
前端：https://www.example.com
后端：https://api.example.com
问题：子域名不同，依然跨域 ❌

解决方案：必须配置跨域策略 ✅
```

---

## 2. 🌐 CORS跨域资源共享


### 2.1 CORS是什么


**📋 核心定义**

CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种**浏览器机制**，允许服务器明确告诉浏览器："我允许某些外部网站访问我的资源"。

```
CORS工作原理：
1. 浏览器发现跨域请求
2. 自动在请求头添加 Origin: http://localhost:3000
3. 后端检查这个来源是否被允许
4. 如果允许，返回响应头：Access-Control-Allow-Origin: http://localhost:3000
5. 浏览器看到响应头，放行请求 ✅
```

### 2.2 CORS请求类型


**🔸 简单请求**

满足所有条件才算简单请求：
- 请求方法：`GET`、`POST`、`HEAD`
- 请求头只能有：`Accept`、`Content-Type`（限定值）、`Content-Language`等
- `Content-Type` 只能是：`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`

```
简单请求流程：
客户端                          服务器
   |                              |
   |--[1] 发送请求---------------->|
   |    Origin: http://localhost:3000
   |                              |
   |<-[2] 返回响应-----------------|
   |    Access-Control-Allow-Origin: *
   |                              |
```

**🔸 预检请求（Preflight）**

不满足简单请求的条件，浏览器会先发一个"预检请求"，问问服务器"我能不能访问你"。

```
预检请求场景：
- 使用 PUT、DELETE 方法
- 自定义请求头（如 Authorization）
- Content-Type: application/json

预检请求流程：
客户端                          服务器
   |                              |
   |--[1] OPTIONS预检请求-------->|
   |    Origin: http://localhost:3000
   |    Access-Control-Request-Method: POST
   |    Access-Control-Request-Headers: Authorization
   |                              |
   |<-[2] 预检响应-----------------|
   |    Access-Control-Allow-Origin: http://localhost:3000
   |    Access-Control-Allow-Methods: POST
   |    Access-Control-Allow-Headers: Authorization
   |                              |
   |--[3] 发送真正请求------------>|
   |                              |
   |<-[4] 返回数据-----------------|
```

### 2.3 CORS核心响应头


**📊 重要响应头说明**

| 响应头 | 含义 | 示例 | 说明 |
|-------|------|------|------|
| **Access-Control-Allow-Origin** | 允许哪些来源访问 | `http://localhost:3000` 或 `*` | `*`表示允许所有来源（不安全）|
| **Access-Control-Allow-Methods** | 允许哪些HTTP方法 | `GET, POST, PUT, DELETE` | 预检请求需要 |
| **Access-Control-Allow-Headers** | 允许哪些请求头 | `Authorization, Content-Type` | 预检请求需要 |
| **Access-Control-Allow-Credentials** | 是否允许携带凭证 | `true` | 允许发送Cookie |
| **Access-Control-Max-Age** | 预检结果缓存时间 | `3600`（秒） | 避免频繁预检 |

**⚠️ 重要提醒**

```
常见错误配置：
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

❌ 这两个不能同时使用！
当允许携带凭证时，Origin 必须指定具体来源，不能用 *
```

### 2.4 Spring Security的CORS配置


**🔧 配置方式一：corsConfigurationSource()**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 启用CORS，使用自定义配置
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            );
        return http.build();
    }
    
    // CORS配置源
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        
        // 允许的来源（前端地址）
        config.setAllowedOrigins(Arrays.asList(
            "http://localhost:3000",      // 开发环境
            "https://www.example.com"     // 生产环境
        ));
        
        // 允许的请求方法
        config.setAllowedMethods(Arrays.asList(
            "GET", "POST", "PUT", "DELETE", "OPTIONS"
        ));
        
        // 允许的请求头
        config.setAllowedHeaders(Arrays.asList(
            "Authorization",    // Token认证
            "Content-Type",     // 请求数据类型
            "X-Requested-With"  // Ajax请求标识
        ));
        
        // 是否允许携带凭证（Cookie）
        config.setAllowCredentials(true);
        
        // 预检请求缓存时间（1小时）
        config.setMaxAge(3600L);
        
        // 应用到所有路径
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```

**🎯 配置要点解析**

```
核心配置项：

1. AllowedOrigins（允许来源）
   ✅ 推荐：明确指定前端地址
   ❌ 不推荐：使用 * （有安全风险）
   
2. AllowedMethods（允许方法）
   - 根据实际需要配置
   - 至少包含：GET, POST
   - RESTful API 需要：PUT, DELETE
   
3. AllowCredentials（携带凭证）
   true：允许发送Cookie和Authorization头
   false：不允许（默认）
   
4. MaxAge（缓存时间）
   - 减少预检请求次数
   - 提升性能
   - 建议：3600秒（1小时）
```

**🔧 配置方式二：全局配置类**

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")              // 对所有接口生效
                .allowedOrigins("http://localhost:3000")  // 允许的来源
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")            // 允许所有请求头
                .allowCredentials(true)         // 允许携带凭证
                .maxAge(3600);                  // 缓存1小时
    }
}
```

---

## 3. 🛡️ CSRF跨站请求伪护


### 3.1 什么是CSRF攻击


**🔸 通俗理解**

CSRF（Cross-Site Request Forgery，跨站请求伪造）就像"身份冒用"。攻击者诱导你在已登录的网站上执行非本意的操作。

```
CSRF攻击场景（银行转账）：

步骤1：你登录了银行网站 bank.com
       浏览器保存了登录Cookie

步骤2：你收到一封邮件，点击了链接
       打开了恶意网站 evil.com

步骤3：恶意网站偷偷执行：
       <form action="http://bank.com/transfer" method="POST">
         <input name="to" value="黑客账户">
         <input name="amount" value="10000">
       </form>
       <script>document.forms[0].submit();</script>

步骤4：因为浏览器自动携带 bank.com 的Cookie
       银行以为是你本人操作
       转账成功！你的钱被转走 ❌
```

**核心问题**：服务器无法判断请求是用户主动发起的，还是被恶意网站伪造的。

### 3.2 CSRF的攻击条件


**📋 三个必要条件**

```
条件1：用户已登录目标网站
      └─ 浏览器存有有效的Cookie/Session

条件2：用户访问了恶意网站
      └─ 恶意网站能够构造请求

条件3：目标网站依赖Cookie认证
      └─ 浏览器自动携带Cookie

三个条件同时满足 → CSRF攻击成功 ❌
```

### 3.3 CSRF Token防护原理


**🔐 Token机制**

CSRF Token就像一个"暗号"，每次请求都需要携带正确的暗号，恶意网站猜不到暗号，攻击就失败了。

```
CSRF Token工作流程：

步骤1：用户访问页面
       服务器生成随机Token → 存入Session
       └─ Token: "abc123xyz"

步骤2：服务器返回页面
       Token嵌入表单或放入Meta标签
       └─ <input name="_csrf" value="abc123xyz">

步骤3：用户提交表单
       请求携带Token → "_csrf=abc123xyz"

步骤4：服务器验证
       对比请求Token和Session中的Token
       ✅ 相同 → 合法请求，允许执行
       ❌ 不同/缺失 → 伪造请求，拒绝执行
```

**🎯 为什么恶意网站无法攻击**

```
恶意网站的困境：
1. 恶意网站不知道Token值（随机生成）
2. 由于同源策略，无法读取目标网站的Token
3. 构造的请求没有Token或Token错误
4. 服务器拒绝请求 → 攻击失败 ✅
```

### 3.4 Spring Security的CSRF配置


**🔧 默认启用CSRF**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // Spring Security 默认启用CSRF防护
            .csrf(Customizer.withDefaults())  
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

**⚠️ 什么时候禁用CSRF**

```
适合禁用CSRF的场景：
✅ RESTful API（前后端分离）
   └─ 使用Token认证（JWT），不依赖Cookie
   
✅ 纯后端服务（无浏览器访问）
   └─ 微服务之间调用
   
✅ 移动App接口
   └─ App不会有CSRF攻击

必须启用CSRF的场景：
❌ 传统Web应用（Session + Cookie认证）
❌ 有表单提交的页面
❌ 依赖浏览器Cookie的认证
```

**🔧 禁用CSRF配置**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())  // 禁用CSRF
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/**").permitAll()  // API接口允许访问
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

**🎯 部分路径禁用CSRF**

```java
http.csrf(csrf -> csrf
    .ignoringRequestMatchers("/api/public/**")  // 公开API不需要CSRF
    .ignoringRequestMatchers("/webhook/**")      // 第三方回调
);
```

### 3.5 前端获取和使用CSRF Token


**🔸 方式一：从Meta标签获取**

```html
<!-- 后端渲染时注入Token -->
<meta name="_csrf" content="${_csrf.token}"/>
<meta name="_csrf_header" content="${_csrf.headerName}"/>
```

```javascript
// 前端JavaScript获取Token
const token = document.querySelector('meta[name="_csrf"]').getAttribute('content');
const header = document.querySelector('meta[name="_csrf_header"]').getAttribute('content');

// 发送请求时携带
fetch('/api/data', {
    method: 'POST',
    headers: {
        [header]: token,  // 添加CSRF Token到请求头
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ data: 'value' })
});
```

**🔸 方式二：从Cookie获取**

```java
// 后端配置：CSRF Token存入Cookie
http.csrf(csrf -> csrf
    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
);
```

```javascript
// 前端从Cookie读取Token
function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
}

const csrfToken = getCookie('XSRF-TOKEN');

// 使用axios自动处理
axios.defaults.xsrfCookieName = 'XSRF-TOKEN';
axios.defaults.xsrfHeaderName = 'X-XSRF-TOKEN';
```

---

## 4. 🔧 Spring Security配置实战


### 4.1 前后端分离完整配置


**🎯 实际开发场景配置**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 1. 配置CORS跨域
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            
            // 2. 禁用CSRF（前后端分离用JWT，不需要CSRF）
            .csrf(csrf -> csrf.disable())
            
            // 3. 禁用Session（无状态认证）
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // 4. 配置认证规则
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()     // 登录接口公开
                .requestMatchers("/api/public/**").permitAll()   // 公开API
                .anyRequest().authenticated()                    // 其他需要认证
            )
            
            // 5. 添加JWT认证过滤器
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
            
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
        config.setAllowedHeaders(Arrays.asList("*"));
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```

### 4.2 传统Web应用配置


**🎯 Session + Cookie认证场景**

```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 1. 不需要CORS（同域访问）
            
            // 2. 启用CSRF防护（必须！）
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            )
            
            // 3. 表单登录
            .formLogin(form -> form
                .loginPage("/login")
                .defaultSuccessUrl("/home")
                .permitAll()
            )
            
            // 4. 登出配置
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login")
                .permitAll()
            );
            
        return http.build();
    }
}
```

### 4.3 SameSite Cookie配置


**🔸 什么是SameSite**

SameSite是Cookie的一个属性，控制Cookie在跨站请求时是否发送，也能防护CSRF。

```
SameSite取值：

Strict（严格）：
  ✅ 完全禁止跨站发送Cookie
  ❌ 用户体验差（从外部链接访问也没Cookie）

Lax（宽松，默认）：
  ✅ GET请求可以跨站发送Cookie
  ❌ POST等修改操作不发送
  
None（无限制）：
  ✅ 允许跨站发送
  ⚠️ 必须配合 Secure（HTTPS）使用
```

**🔧 Spring Boot配置SameSite**

```properties
# application.properties
server.servlet.session.cookie.same-site=lax
server.servlet.session.cookie.secure=true
server.servlet.session.cookie.http-only=true
```

```java
// 或者在代码中配置
@Bean
public CookieSameSiteSupplier cookieSameSiteSupplier() {
    return CookieSameSiteSupplier.ofLax();  // 设置为Lax
}
```

**⚠️ SameSite vs CSRF Token**

```
SameSite Cookie：
优点：浏览器原生支持，配置简单
缺点：依赖浏览器支持，老浏览器无效

CSRF Token：
优点：服务器控制，兼容性好
缺点：需要前后端配合，实现复杂

最佳实践：两者结合使用 ✅
```

---

## 5. 🎯 安全策略最佳实践


### 5.1 开发环境配置


```java
@Configuration
@Profile("dev")  // 仅在开发环境生效
public class DevSecurityConfig {
    
    @Bean
    public SecurityFilterChain devSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> cors.configurationSource(devCorsSource()))
            .csrf(csrf -> csrf.disable())  // 开发环境可以禁用CSRF
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/h2-console/**").permitAll()  // 允许H2控制台
                .anyRequest().permitAll()                       // 开发环境全部放行
            );
        return http.build();
    }
    
    private CorsConfigurationSource devCorsSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList("*"));  // 开发环境允许所有来源
        config.setAllowedMethods(Arrays.asList("*"));
        config.setAllowedHeaders(Arrays.asList("*"));
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```

### 5.2 生产环境配置


```java
@Configuration
@Profile("prod")  // 仅在生产环境生效
public class ProdSecurityConfig {
    
    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;  // 从配置文件读取
    
    @Bean
    public SecurityFilterChain prodSecurityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> cors.configurationSource(prodCorsSource()))
            .csrf(csrf -> csrf.disable())  // JWT认证不需要CSRF
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/health").permitAll()  // 健康检查
                .anyRequest().authenticated()
            );
        return http.build();
    }
    
    private CorsConfigurationSource prodCorsSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Arrays.asList(allowedOrigins));  // 明确指定前端域名
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
        config.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```

```properties
# application-prod.properties
app.cors.allowed-origins=https://www.example.com,https://admin.example.com
```

### 5.3 安全检查清单


**✅ 上线前检查**

```
CORS配置检查：
□ AllowedOrigins 不使用 *
□ 明确指定前端域名
□ AllowCredentials 配置正确
□ 生产环境禁用不必要的请求方法

CSRF配置检查：
□ Session认证必须启用CSRF
□ JWT认证可以禁用CSRF
□ Cookie配置了 SameSite
□ HTTPS环境配置了 Secure

其他安全检查：
□ 敏感接口有认证保护
□ 错误信息不泄露细节
□ 日志记录安全事件
□ 定期更新依赖版本
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的概念


**🔸 跨域CORS**
```
核心理解：
- 跨域是浏览器的安全限制，后端无此限制
- 同源策略：协议、域名、端口必须完全相同
- CORS是服务器主动允许跨域的机制
- 预检请求用于复杂请求的安全检查
```

**🔸 CSRF防护**
```
核心理解：
- CSRF是利用用户身份伪造请求的攻击
- Token机制：服务器生成随机值，请求时验证
- SameSite Cookie：浏览器层面限制Cookie发送
- Session认证必须防CSRF，Token认证可以不用
```

### 6.2 配置决策树


```
认证方式判断：
│
├─ 使用Session + Cookie？
│  ├─ 是 → 必须启用CSRF ✅
│  │      配置SameSite Cookie ✅
│  │      可能需要CORS（前后端分离）
│  │
│  └─ 否，使用JWT Token
│     └─ 禁用CSRF ✅
│        启用CORS ✅
│        无状态Session ✅
```

### 6.3 常见问题排查


**🔧 跨域问题排查**

```
问题：前端报 CORS error

排查步骤：
1️⃣ 检查浏览器控制台错误信息
   └─ 看具体是哪个响应头缺失

2️⃣ 检查后端CORS配置
   └─ AllowedOrigins 是否包含前端地址
   └─ AllowedMethods 是否包含请求方法
   └─ AllowCredentials 配置是否正确

3️⃣ 检查OPTIONS预检请求
   └─ 是否返回正确的响应头
   └─ 状态码应该是 200

4️⃣ 检查nginx等反向代理
   └─ 是否覆盖了后端的CORS配置
```

**🔧 CSRF问题排查**

```
问题：表单提交报 Invalid CSRF Token

排查步骤：
1️⃣ 确认CSRF是否启用
   └─ csrf().disable() 检查是否误禁用

2️⃣ 检查Token获取
   └─ 页面是否正确获取到Token
   └─ Meta标签或Cookie是否存在

3️⃣ 检查Token发送
   └─ 请求头或表单参数是否携带Token
   └─ 名称是否匹配（_csrf 或 X-XSRF-TOKEN）

4️⃣ 检查Token存储
   └─ Session是否过期
   └─ Cookie是否被清除
```

### 6.4 记忆口诀


```
🎯 CORS跨域要记牢
同源策略三要素，协议域名加端口
前后分离必跨域，CORS配置要允许
预检请求先问好，复杂请求才放行

🛡️ CSRF防护不能少
伪造请求真头疼，Token验证最管用
Session认证必须防，JWT可以不用管
SameSite Cookie加持，双重防护更安全

⚙️ 配置原则要清楚
开发环境可宽松，生产严格保安全
明确来源不用星，凭证携带要谨慎
定期检查配置项，安全第一记心间
```