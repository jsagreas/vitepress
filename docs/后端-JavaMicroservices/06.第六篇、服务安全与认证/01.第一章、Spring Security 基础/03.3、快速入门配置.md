---
title: 3、快速入门配置
---
## 📚 目录

1. [Spring Security是什么](#1-Spring-Security是什么)
2. [快速启用Spring Security](#2-快速启用Spring-Security)
3. [配置类详解](#3-配置类详解)
4. [内存用户配置](#4-内存用户配置)
5. [新旧版本对比](#5-新旧版本对比)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔐 Spring Security是什么


### 1.1 通俗理解


**🔸 用大白话说**：Spring Security就像是给你的应用装了一道"安全门"

```
没有Spring Security的应用：
用户 → 直接访问任何页面 → 数据被随意访问 ❌

有Spring Security的应用：
用户 → 先登录验证 → 检查权限 → 允许访问 → 访问数据 ✅
```

**💡 实际场景类比**：
```
就像进入小区：
1. 门卫检查你的身份证（登录认证）
2. 确认你是这个小区的住户（权限验证）
3. 允许你进入（访问资源）
```

### 1.2 核心功能


**🎯 Spring Security主要做两件事**：

| 功能 | 说明 | 类比 |
|------|------|------|
| **认证(Authentication)** | 验证"你是谁" | 门卫检查身份证 |
| **授权(Authorization)** | 验证"你能做什么" | 确认你能进哪栋楼 |

**📋 具体能力**：
- ✅ 登录验证：用户名密码检查
- ✅ 权限控制：不同用户看到不同页面
- ✅ 记住登录：免重复登录
- ✅ 防攻击：防止恶意访问

---

## 2. 🚀 快速启用Spring Security


### 2.1 第一步：添加依赖


**🔸 Maven项目配置**：

```xml
<!-- pom.xml中添加 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**💡 这个依赖做了什么**：
```
添加依赖后自动发生的事情：
1. 所有接口都需要登录才能访问
2. 自动生成一个登录页面
3. 默认用户名：user
4. 默认密码：控制台会打印（每次启动都不同）
```

### 2.2 第一次启动体验


**🔄 启动流程**：

```
启动应用
  ↓
访问任意接口(如 /hello)
  ↓
自动跳转到登录页 /login
  ↓
输入用户名: user
输入密码: (控制台查看)
  ↓
登录成功 → 访问到页面
```

**📌 控制台密码示例**：
```
Using generated security password: a1b2c3d4-e5f6-7890-abcd-ef1234567890
```

---

## 3. ⚙️ 配置类详解


### 3.1 @EnableWebSecurity注解


**🔸 核心作用**：告诉Spring"我要自定义安全配置了"

```java
@Configuration
@EnableWebSecurity  // ← 这个注解启用Web安全功能
public class SecurityConfig {
    // 配置内容...
}
```

**💡 理解要点**：
- `@Configuration`：标记这是配置类
- `@EnableWebSecurity`：启用Spring Security
- 两个注解必须一起用

### 3.2 HttpSecurity配置对象


**🔸 什么是HttpSecurity**：
HttpSecurity是配置HTTP请求安全规则的核心对象

**通俗理解**：
```
HttpSecurity = 安全规则配置器

你可以用它配置：
- 哪些路径需要登录
- 哪些路径不需要登录
- 登录页面在哪里
- 登录成功后跳转到哪里
```

### 3.3 SecurityConfig完整示例


**📝 基础配置示例**：

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 配置哪些请求需要认证
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()  // 公开路径
                .anyRequest().authenticated()                // 其他都需要登录
            )
            // 配置登录页面
            .formLogin(form -> form
                .loginPage("/login")           // 自定义登录页
                .defaultSuccessUrl("/home")    // 登录成功跳转
                .permitAll()                   // 登录页不需要认证
            )
            // 配置登出
            .logout(logout -> logout
                .logoutUrl("/logout")          // 登出URL
                .logoutSuccessUrl("/login")    // 登出后跳转
                .permitAll()
            );
        
        return http.build();
    }
}
```

**🔍 配置解读**：

| 配置项 | 含义 | 通俗解释 |
|--------|------|----------|
| `requestMatchers("/public/**")` | 匹配路径 | 指定哪些路径 |
| `permitAll()` | 允许所有人访问 | 不需要登录 |
| `authenticated()` | 需要认证 | 必须登录 |
| `loginPage()` | 登录页面 | 自定义登录页 |
| `defaultSuccessUrl()` | 成功跳转 | 登录后去哪 |

---

## 4. 👤 内存用户配置


### 4.1 为什么需要配置用户


**🔸 问题场景**：
```
默认情况：
- 用户名固定：user
- 密码随机：每次启动都变
- 不方便测试和开发 ❌

配置后：
- 可以设置多个用户
- 密码固定不变
- 方便测试 ✅
```

### 4.2 内存用户配置方式


**📝 配置示例**：

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    // 配置用户信息
    @Bean
    public UserDetailsService userDetailsService() {
        // 创建用户1：普通用户
        UserDetails user = User.builder()
            .username("user")
            .password(passwordEncoder().encode("123456"))
            .roles("USER")  // 角色：普通用户
            .build();
        
        // 创建用户2：管理员
        UserDetails admin = User.builder()
            .username("admin")
            .password(passwordEncoder().encode("admin123"))
            .roles("ADMIN")  // 角色：管理员
            .build();
        
        // 返回内存用户服务
        return new InMemoryUserDetailsManager(user, admin);
    }
    
    // 密码加密器（必须配置）
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

**🔑 关键点说明**：

**1. User.builder()** - 构建用户
```
.username()  → 设置用户名
.password()  → 设置密码（必须加密）
.roles()     → 设置角色
.build()     → 完成构建
```

**2. passwordEncoder()** - 密码加密
```
为什么要加密：
- 密码明文存储不安全
- BCrypt是单向加密，无法解密
- 登录时会自动对比加密后的密码
```

**3. InMemoryUserDetailsManager** - 内存管理
```
作用：在内存中存储用户信息
适用场景：开发测试环境
生产环境：应该从数据库读取用户
```

### 4.3 多用户配置示例


```java
@Bean
public UserDetailsService userDetailsService() {
    PasswordEncoder encoder = passwordEncoder();
    
    return new InMemoryUserDetailsManager(
        // 普通员工
        User.builder()
            .username("zhangsan")
            .password(encoder.encode("123456"))
            .roles("EMPLOYEE")
            .build(),
        
        // 部门经理
        User.builder()
            .username("lisi")
            .password(encoder.encode("manager123"))
            .roles("MANAGER")
            .build(),
        
        // 系统管理员
        User.builder()
            .username("admin")
            .password(encoder.encode("admin888"))
            .roles("ADMIN")
            .build()
    );
}
```

---

## 5. 🔄 新旧版本对比


### 5.1 版本演变说明


**📅 版本时间线**：
```
Spring Security 5.x (旧版本)
  ↓
Spring Security 6.x (新版本，Spring Boot 3.x使用)
```

### 5.2 核心差异对比


| 对比项 | 旧版本(5.x) | 新版本(6.x) |
|--------|-------------|-------------|
| **配置基类** | 继承`WebSecurityConfigurerAdapter` | 不需要继承，直接用`@Bean` |
| **配置方式** | 重写`configure()`方法 | 返回`SecurityFilterChain` |
| **代码风格** | 链式调用 | Lambda表达式 |
| **推荐度** | ⚠️ 已过时 | ✅ 官方推荐 |

### 5.3 旧版本配置方式


**❌ 旧版本写法（不推荐）**：

```java
// Spring Security 5.x 写法
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
            .and()
            .logout()
                .permitAll();
    }
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user")
            .password("{noop}123456")
            .roles("USER");
    }
}
```

**⚠️ 旧版本问题**：
- `WebSecurityConfigurerAdapter`在6.x中已移除
- `.and()`连接配置不够直观
- 配置方法分散，不便维护

### 5.4 新版本配置方式


**✅ 新版本写法（推荐）**：

```java
// Spring Security 6.x 写法
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .permitAll()
            )
            .logout(logout -> logout
                .permitAll()
            );
        
        return http.build();
    }
    
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
            .username("user")
            .password(passwordEncoder().encode("123456"))
            .roles("USER")
            .build();
        
        return new InMemoryUserDetailsManager(user);
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

**✅ 新版本优势**：
- 更清晰的Lambda表达式
- 配置更集中，易于理解
- 符合Spring Boot 3.x规范

### 5.5 迁移指南


**🔄 从旧版本迁移到新版本**：

```
Step 1: 移除继承
❌ extends WebSecurityConfigurerAdapter
✅ 直接用 @Configuration

Step 2: 改造configure方法
❌ @Override protected void configure(HttpSecurity http)
✅ @Bean public SecurityFilterChain filterChain(HttpSecurity http)

Step 3: 使用Lambda表达式
❌ .authorizeRequests().antMatchers().and()
✅ .authorizeHttpRequests(auth -> auth.requestMatchers())

Step 4: 分离用户配置
❌ configure(AuthenticationManagerBuilder auth)
✅ @Bean public UserDetailsService userDetailsService()
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 @EnableWebSecurity：启用Spring Security的开关
🔸 SecurityFilterChain：新版本的核心配置返回对象
🔸 HttpSecurity：配置HTTP请求安全规则的工具
🔸 UserDetailsService：提供用户信息的服务
🔸 PasswordEncoder：密码加密工具，必须配置
```

### 6.2 快速入门配置流程


**🔄 完整配置步骤**：

```
第1步：添加依赖
  ↓
第2步：创建配置类 + @EnableWebSecurity
  ↓
第3步：配置SecurityFilterChain（访问规则）
  ↓
第4步：配置UserDetailsService（用户信息）
  ↓
第5步：配置PasswordEncoder（密码加密）
  ↓
完成！启动测试
```

### 6.3 关键理解要点


**🔹 内存用户的使用场景**：
```
✅ 适用场景：
- 开发环境快速测试
- 学习Spring Security
- 简单的演示项目

❌ 不适用场景：
- 生产环境（应该用数据库）
- 用户数量较多
- 需要动态管理用户
```

**🔹 密码加密的必要性**：
```
为什么必须加密：
1. 安全要求：明文密码极不安全
2. 框架要求：Spring Security强制要求
3. 最佳实践：行业标准做法

常用加密器：
- BCryptPasswordEncoder（推荐）
- Pbkdf2PasswordEncoder
- SCryptPasswordEncoder
```

**🔹 新旧版本选择**：
```
如何选择：
- Spring Boot 3.x → 必须用新版本
- Spring Boot 2.7+ → 推荐用新版本
- Spring Boot 2.6及以下 → 可以用旧版本

学习建议：
- 直接学新版本，不要学旧版本
- 旧项目迁移时参考官方文档
```

### 6.4 常见问题解答


**❓ Q1：为什么添加依赖后所有接口都需要登录？**
```
A：这是Spring Security的默认安全策略
- 默认保护所有资源
- 可以通过配置开放部分路径
- 使用 .permitAll() 开放特定路径
```

**❓ Q2：默认密码在哪里看？**
```
A：启动应用时，控制台会打印
- 搜索关键字：Using generated security password
- 密码每次启动都不同
- 建议配置固定用户避免麻烦
```

**❓ Q3：密码加密后能解密吗？**
```
A：BCrypt是单向加密，不能解密
- 登录时：用户输入 → 加密 → 对比数据库的加密密码
- 忘记密码：只能重置，不能找回
- 这正是安全的体现
```

**❓ Q4：内存用户重启后会丢失吗？**
```
A：是的，内存用户重启就没了
- 内存用户：存在内存中，重启即失
- 数据库用户：持久化存储，不会丢失
- 开发测试用内存，生产必须用数据库
```

### 6.5 实际应用建议


**💼 开发环境配置**：
```java
// 适合开发测试的简化配置
@Bean
public SecurityFilterChain devSecurityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/api/public/**").permitAll()  // 公开API
            .anyRequest().authenticated()
        )
        .formLogin(Customizer.withDefaults())  // 使用默认登录页
        .httpBasic(Customizer.withDefaults()); // 同时支持Basic认证
    
    return http.build();
}
```

**🏢 生产环境考虑**：
```
生产环境必须：
✅ 使用数据库存储用户
✅ 实现自定义登录页面
✅ 配置HTTPS
✅ 添加验证码防爆破
✅ 实现记住我功能
✅ 配置会话管理
```

**📚 学习路径建议**：
```
阶段1：快速入门（当前）
- 理解认证授权概念
- 掌握基础配置方法
- 能配置内存用户

阶段2：进阶使用
- 数据库用户认证
- 自定义登录页面
- 权限控制实现

阶段3：高级特性
- JWT集成
- OAuth2整合
- 微服务安全
```

**🔑 核心记忆口诀**：
```
启用安全加注解，配置规则用HttpSecurity
用户信息Service管，密码加密不能忘
新版本用Bean配置，旧版本已经过时了
内存用户测试用，生产环境数据库
```

---

## 🎯 学习检查清单


**✅ 基础掌握检验**：
- [ ] 能说出Spring Security的核心作用
- [ ] 能独立添加依赖并启动项目
- [ ] 理解@EnableWebSecurity的作用
- [ ] 能配置SecurityFilterChain
- [ ] 能配置内存用户并登录

**✅ 进阶理解检验**：
- [ ] 能区分新旧版本配置方式
- [ ] 理解为什么密码必须加密
- [ ] 能配置多个用户和角色
- [ ] 知道内存用户的适用场景
- [ ] 能解决常见配置问题

**✅ 实践应用检验**：
- [ ] 能在实际项目中快速配置Spring Security
- [ ] 能根据需求自定义安全规则
- [ ] 能向生产环境迁移（数据库用户）