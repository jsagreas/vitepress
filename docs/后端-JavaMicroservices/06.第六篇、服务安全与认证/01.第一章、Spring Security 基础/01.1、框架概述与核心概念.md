---
title: 1、框架概述与核心概念
---
## 📚 目录

1. [Spring Security 是什么](#1-spring-security-是什么)
2. [认证与授权的区别](#2-认证与授权的区别)
3. [Servlet 过滤器链机制](#3-servlet-过滤器链机制)
4. [安全拦截的工作原理](#4-安全拦截的工作原理)
5. [Spring Boot 自动配置](#5-spring-boot-自动配置)
6. [安全上下文详解](#6-安全上下文详解)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔐 Spring Security 是什么


### 1.1 框架的本质


**通俗理解**：Spring Security 就像是你家门口的保安系统

```
现实生活中的门禁：              Spring Security：
                              
    刷门禁卡                      用户登录
       ↓                            ↓
  验证是否是住户                  验证用户身份
       ↓                            ↓
  检查能进哪些楼层                检查访问权限
       ↓                            ↓
    放行通过                      允许访问资源
```

**专业定义**：Spring Security 是一个强大的、高度可定制的**安全框架**，专门用于保护 Java 应用程序的安全。它主要提供两大核心功能：

- 🔑 **认证（Authentication）**：确认"你是谁"
- 🛡️ **授权（Authorization）**：确认"你能做什么"

### 1.2 为什么需要 Spring Security


**没有安全框架的问题**：
```
传统方式的困境：
- 每个接口都要写登录检查代码 → 代码重复
- 用户信息存在 Session 里 → 分布式环境麻烦  
- 权限判断逻辑分散各处 → 难以维护
- 密码明文存储 → 安全隐患
```

**使用 Spring Security 的好处**：
```
✅ 统一的安全管理
   - 一次配置，全局生效
   
✅ 完善的安全机制
   - 密码加密、防御攻击、会话管理
   
✅ 灵活的扩展能力
   - 支持自定义认证、授权逻辑
   
✅ 与 Spring 无缝集成
   - 开箱即用，配置简单
```

### 1.3 框架的核心地位


Spring Security 在微服务架构中的位置：

```
                      微服务安全架构
                           
    用户请求 → [网关] → [Spring Security] → [业务服务]
                ↓            ↓              ↓
              路由         身份认证        业务逻辑
              限流         权限校验        数据处理
              
关键作用：
- 在网关层做统一认证
- 在服务层做细粒度授权
- 保护每个微服务的安全边界
```

---

## 2. 🔑 认证与授权的区别


### 2.1 认证（Authentication）- "你是谁"


**生活化理解**：就像酒店前台验证你的身份证

```
认证过程：
                                
用户输入          系统验证         认证结果
账号密码    →    查数据库    →    成功/失败
                比对密码
                
示例场景：
- 输入用户名 admin，密码 123456
- 系统查询数据库中 admin 用户
- 对比密码是否匹配
- 匹配成功 → 认证通过
```

**技术实现要点**：
- 🔸 **用户凭证**：用户名密码、手机验证码、指纹等
- 🔸 **验证方式**：数据库比对、第三方认证、JWT令牌
- 🔸 **认证结果**：生成身份令牌，记录登录状态

### 2.2 授权（Authorization）- "你能做什么"


**生活化理解**：就像酒店房卡只能打开你预订的房间

```
授权过程：
                                
已登录用户       检查权限        授权结果
访问资源    →   角色/权限   →   允许/拒绝
                匹配规则
                
示例场景：
- 普通用户想删除文章
- 系统检查：该用户是 USER 角色
- 删除操作需要 ADMIN 角色
- 权限不足 → 拒绝访问
```

**技术实现要点**：
- 🔸 **权限模型**：角色（ROLE）、权限（PERMISSION）
- 🔸 **控制粒度**：URL级别、方法级别、数据级别
- 🔸 **判断依据**：用户角色、资源权限、业务规则

### 2.3 两者关系对比


| 对比维度 | **认证（Authentication）** | **授权（Authorization）** |
|---------|--------------------------|-------------------------|
| 📋 **核心问题** | `你是谁？` | `你能做什么？` |
| 🎯 **验证对象** | `用户身份` | `访问权限` |
| ⏱️ **执行时机** | `登录时验证` | `每次访问时检查` |
| 📝 **典型场景** | `账号密码登录` | `删除按钮是否可见` |
| 🔧 **实现方式** | `UsernamePasswordAuthenticationFilter` | `FilterSecurityInterceptor` |

**记忆口诀**：
> 认证确认身份真，授权决定权限深  
> 先问你是谁来客，再看能否进家门

---

## 3. 🔗 Servlet 过滤器链机制


### 3.1 什么是过滤器链


**生活化比喻**：就像机场的安检流程

```
乘客登机流程：                    请求处理流程：
                              
身份验证 → 行李检查 → 安检门 → 登机      请求 → 过滤器1 → 过滤器2 → ... → 业务代码
   ↓         ↓        ↓        ↓              ↓         ↓         ↓          ↓
验证身份   检查物品   金属检测  上飞机      认证检查   权限检查   日志记录   处理业务
```

**技术原理**：过滤器链是一系列按顺序执行的过滤器，每个过滤器负责一个特定的安全检查任务。

### 3.2 Spring Security 的过滤器链


**核心过滤器组成**：

```
客户端请求
    ↓
[UsernamePasswordAuthenticationFilter]  ← 处理登录请求
    ↓
[BasicAuthenticationFilter]             ← 处理 HTTP Basic 认证
    ↓
[FilterSecurityInterceptor]             ← 最后的权限检查
    ↓
业务 Controller
```

**各过滤器职责说明**：

🔸 **UsernamePasswordAuthenticationFilter**
- 作用：拦截 `/login` 请求，处理用户名密码登录
- 时机：用户提交登录表单时
- 结果：认证成功则放行，失败则跳转错误页面

🔸 **BasicAuthenticationFilter**  
- 作用：处理 HTTP Basic 认证（请求头中的用户名密码）
- 时机：每次请求都检查请求头
- 结果：提取认证信息并验证

🔸 **FilterSecurityInterceptor**
- 作用：最终的权限检查，判断是否有权限访问资源
- 时机：请求即将到达 Controller 之前
- 结果：有权限则放行，无权限则抛出异常

### 3.3 过滤器链的工作流程


**完整流程示意**：

```
用户请求 /admin/users
         ↓
    ┌─────────────────────────┐
    │ 是否携带认证信息？        │
    └─────────┬────────────────┘
              ↓ 是
    ┌─────────────────────────┐
    │ 认证信息是否有效？        │
    └─────────┬────────────────┘
              ↓ 有效
    ┌─────────────────────────┐
    │ 是否有访问权限？          │
    └─────────┬────────────────┘
              ↓ 有权限
         执行业务逻辑
              ↓
         返回响应结果

任何环节失败 → 返回 401/403 错误
```

### 3.4 自定义过滤器


**添加自定义过滤器的位置**：

```java
// 在某个过滤器之前添加
http.addFilterBefore(自定义过滤器, 目标过滤器.class);

// 在某个过滤器之后添加  
http.addFilterAfter(自定义过滤器, 目标过滤器.class);

// 替换某个过滤器
http.addFilterAt(自定义过滤器, 目标过滤器.class);
```

**常见使用场景**：
- ✅ 添加 Token 认证过滤器（JWT 验证）
- ✅ 添加验证码校验过滤器
- ✅ 添加请求日志记录过滤器

---

## 4. 🛡️ 安全拦截的工作原理


### 4.1 拦截的本质


**核心思想**：在请求到达业务代码之前，先进行安全检查

```
请求流程对比：

没有安全拦截：
客户端 → Controller → Service → 数据库
         ↑ 任何人都能访问

有安全拦截：
客户端 → [安全拦截] → Controller → Service → 数据库
         ↑ 先验证       ↑ 通过后才能访问
         身份和权限
```

### 4.2 拦截的三个层次


**🔸 URL 级别拦截**（最常用）

```java
// 配置哪些 URL 需要什么权限
http.authorizeRequests()
    .antMatchers("/public/**").permitAll()      // 公开访问
    .antMatchers("/admin/**").hasRole("ADMIN")  // 管理员访问
    .anyRequest().authenticated();              // 其他需登录
```

**说明**：
- `/public/**`：所有人都能访问（登录页、注册页等）
- `/admin/**`：只有 ADMIN 角色能访问（后台管理页面）
- `anyRequest()`：其他所有请求都需要登录

**🔸 方法级别拦截**（细粒度控制）

```java
@PreAuthorize("hasRole('ADMIN')")  // 方法执行前检查
public void deleteUser(Long id) {
    // 删除用户逻辑
}

@PostAuthorize("returnObject.owner == authentication.name")  
public Article getArticle(Long id) {
    // 只能查看自己的文章
}
```

**🔸 数据级别拦截**（最细粒度）

```java
// 根据数据属性判断权限
@PostFilter("filterObject.department == authentication.department")
public List<Employee> getEmployees() {
    // 只能看到本部门员工
}
```

### 4.3 拦截决策过程


**决策流程图**：

```
请求访问受保护资源
         ↓
    【步骤1】
  是否已认证？
    ↙     ↘
  否       是
   ↓        ↓
返回401  【步骤2】
       是否有权限？
         ↙    ↘
       否      是
        ↓       ↓
     返回403  放行访问
     
401：未认证（没登录）
403：已认证但无权限（登录了但权限不够）
```

---

## 5. ⚙️ Spring Boot 自动配置


### 5.1 什么是自动配置


**通俗理解**：就像买了即装即用的家电，插上电就能工作

```
传统 Spring Security 配置：
- 需要写大量 XML 配置
- 手动配置过滤器链
- 手动配置认证管理器
- 手动配置密码加密器

Spring Boot 自动配置：
- 添加依赖即可使用
- 自动配置核心组件
- 提供默认安全策略
- 支持属性文件配置
```

### 5.2 自动配置的触发


**只需一步，启用安全功能**：

```xml
<!-- Maven 依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**自动配置做了什么**：

✅ **自动启用**：
- 创建默认的过滤器链
- 配置默认登录页面（`/login`）
- 开启 CSRF 防护
- 启用会话管理

✅ **默认策略**：
- 所有请求都需要认证
- 提供一个默认用户（user）
- 密码在启动时打印到控制台

✅ **提供扩展点**：
- 可以覆盖默认配置
- 可以自定义认证逻辑
- 可以自定义授权规则

### 5.3 自动配置的核心类


**SecurityAutoConfiguration**：
```
功能：自动配置核心安全组件
触发条件：存在 Spring Security 相关类
作用：
  - 创建 SecurityFilterChain
  - 配置 AuthenticationManager
  - 启用方法安全注解
```

### 5.4 属性配置方式


**通过配置文件自定义**：

```yaml
spring:
  security:
    user:
      name: admin          # 默认用户名
      password: 123456     # 默认密码
      roles: ADMIN         # 默认角色
```

**说明**：这只是临时测试用，生产环境必须自定义认证逻辑！

---

## 6. 🔄 安全上下文详解


### 6.1 什么是安全上下文


**通俗理解**：安全上下文就像是你的"临时身份证"

```
登录流程：

用户登录成功
    ↓
创建认证对象（Authentication）
    ↓
存入安全上下文（SecurityContext）
    ↓
后续请求都能获取当前用户信息
```

**专业定义**：SecurityContext 是存储当前已认证用户信息的容器，它保存在 `SecurityContextHolder` 中，可以在应用的任何地方访问。

### 6.2 安全上下文的结构


**三层结构**：

```
SecurityContextHolder           ← 持有者（静态工具类）
        ↓
SecurityContext                 ← 上下文（存储容器）
        ↓
Authentication                  ← 认证对象（用户信息）
        ↓
Principal（用户信息）
Credentials（凭证）
Authorities（权限列表）
```

### 6.3 获取当前用户信息


**方式一：通过 SecurityContextHolder**

```java
// 获取认证对象
Authentication auth = SecurityContextHolder
    .getContext()
    .getAuthentication();

// 获取用户名
String username = auth.getName();

// 获取权限列表
Collection<? extends GrantedAuthority> authorities = 
    auth.getAuthorities();
```

**方式二：Controller 方法注入**

```java
@GetMapping("/user/info")
public String getUserInfo(Authentication authentication) {
    // 直接使用注入的 authentication 对象
    return "当前用户：" + authentication.getName();
}

// 或者使用 @AuthenticationPrincipal 注解
@GetMapping("/user/detail")
public String getDetail(@AuthenticationPrincipal UserDetails user) {
    return "用户详情：" + user.getUsername();
}
```

**方式三：使用 Spring EL 表达式**

```java
@PreAuthorize("authentication.name == #username")
public void updateUser(String username) {
    // 只能更新自己的信息
}
```

### 6.4 安全上下文的生命周期


**请求处理全流程**：

```
请求开始
    ↓
[SecurityContextPersistenceFilter]
    ↓
从 Session 加载 SecurityContext
    ↓
执行业务逻辑（可随时获取用户信息）
    ↓
业务处理完成
    ↓
[SecurityContextPersistenceFilter]
    ↓
将 SecurityContext 保存回 Session
    ↓
清空 ThreadLocal
    ↓
请求结束
```

**关键点**：
- 🔸 每个请求都会从 Session 恢复安全上下文
- 🔸 请求过程中可以随时获取当前用户信息
- 🔸 请求结束后会自动清理，避免内存泄漏

### 6.5 多线程环境下的安全上下文


**问题**：新线程中获取不到用户信息

```java
// 主线程中
Authentication auth = SecurityContextHolder
    .getContext()
    .getAuthentication();
    
new Thread(() -> {
    // 子线程中获取不到！
    Authentication threadAuth = SecurityContextHolder
        .getContext()
        .getAuthentication();  // null
}).start();
```

**解决方案**：配置上下文传播策略

```java
// 设置为可继承模式
SecurityContextHolder.setStrategyName(
    SecurityContextHolder.MODE_INHERITABLETHREADLOCAL
);

// 或在子线程中手动传递
SecurityContext context = SecurityContextHolder.getContext();
new Thread(() -> {
    SecurityContextHolder.setContext(context);
    // 现在可以获取到了
}).start();
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 Spring Security 本质：基于过滤器链的安全框架
🔸 认证与授权：先验证身份，再检查权限
🔸 过滤器链机制：层层拦截，逐级检查
🔸 安全拦截原理：请求到达业务代码前的安全检查
🔸 自动配置：Spring Boot 开箱即用的安全保护
🔸 安全上下文：全局访问的当前用户信息容器
```

### 7.2 关键理解要点


**🔹 认证与授权的区别**
```
认证（Authentication）：
- 验证"你是谁"
- 登录时进行
- 失败返回 401

授权（Authorization）：
- 判断"能做啥"
- 每次访问检查
- 失败返回 403
```

**🔹 过滤器链的执行顺序**
```
请求 → 认证过滤器 → 授权过滤器 → 业务代码

关键点：
- 顺序很重要，不能颠倒
- 可以自定义过滤器插入链中
- 任何环节失败都会中断请求
```

**🔹 安全上下文的使用场景**
```
✅ 获取当前登录用户信息
✅ 判断用户是否有某个权限
✅ 实现数据级权限控制
✅ 记录操作日志（谁做了什么）
```

### 7.3 实际应用指导


**新手学习路径**：
1. **理解认证和授权的区别** → 这是基础中的基础
2. **掌握过滤器链机制** → 理解 Spring Security 的工作原理
3. **学会配置 URL 权限** → 最常用的安全控制方式
4. **使用安全上下文** → 获取和使用当前用户信息

**常见应用场景**：
- 🎯 **登录功能**：使用 UsernamePasswordAuthenticationFilter
- 🎯 **权限控制**：配置 URL 规则或使用方法注解
- 🎯 **获取用户信息**：从 SecurityContext 中获取
- 🎯 **自定义认证**：实现 AuthenticationProvider 接口

**避坑指南**：
- ⚠️ 不要在子线程中直接获取安全上下文
- ⚠️ 不要在配置中暴露敏感的 URL 路径
- ⚠️ 生产环境不要使用默认用户名密码
- ⚠️ 理解 401 和 403 错误的区别

**记忆口诀**：
> Spring Security 过滤链，认证授权两关卡  
> 先问你是哪位客，再看能否进我家  
> 上下文中存身份，全局可取不用怕  
> 自动配置真方便，开箱即用顶呱呱