---
title: 1、JWT基础理论
---
## 📚 目录

1. [JWT是什么](#1-JWT是什么)
2. [JWT的三段式结构](#2-JWT的三段式结构)
3. [JWT工作原理](#3-JWT工作原理)
4. [JWT的加密方式](#4-JWT的加密方式)
5. [JWT的使用场景](#5-JWT的使用场景)
6. [JWT安全性考虑](#6-JWT安全性考虑)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🎫 JWT是什么


### 1.1 传统认证的困扰


**场景还原：用户登录后如何保持登录状态？**

```
传统Session方式的问题：

用户登录 → 服务器创建Session → 存储在服务器内存/数据库
         ↓
    返回SessionID给浏览器（Cookie）
         ↓
    每次请求都带着SessionID
         ↓
    服务器查找Session验证身份

问题来了：
❌ 服务器需要存储大量Session数据（占内存）
❌ 分布式系统中Session共享很麻烦
❌ 服务器重启后Session丢失
❌ 跨域请求时Cookie受限制
```

### 1.2 JWT的解决思路


**🔸 JWT的核心理念**

JWT（JSON Web Token）翻译过来就是"JSON格式的网络令牌"。它的核心思想很简单：

> **把用户信息直接编码在令牌里，不需要服务器存储**

就像你的身份证一样，所有信息都写在卡上，验证的人只需要看卡就知道你是谁，不需要去查档案。

```
JWT认证流程：

用户登录 → 服务器验证账号密码
         ↓
    生成JWT令牌（包含用户信息）
         ↓
    返回JWT给客户端（存在localStorage或Cookie）
         ↓
    每次请求在Header中带上JWT
         ↓
    服务器验证JWT签名和有效期

优势明显：
✅ 服务器不需要存储任何Session
✅ 天然支持分布式系统
✅ 服务器重启不影响认证
✅ 适合移动端和前后端分离
```

### 1.3 JWT的特点


**💡 无状态认证的含义**

| 特性 | 传统Session | JWT令牌 |
|------|------------|---------|
| **服务端存储** | 需要存储Session | 不需要存储 |
| **扩展性** | 难以扩展（需Session共享） | 容易扩展 |
| **跨域支持** | Cookie限制多 | 天然支持 |
| **性能消耗** | 每次查询Session | 只验证签名 |
| **适用场景** | 传统Web应用 | 微服务、移动端、前后端分离 |

---

## 2. 🧩 JWT的三段式结构


### 2.1 JWT长什么样


一个典型的JWT令牌看起来是这样的：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

看起来像一串乱码？其实它是由三部分组成，用点（`.`）分隔：

```
结构拆解：
┌──────────── Header ────────────┐.┌─────── Payload ────────┐.┌─── Signature ───┐
│ eyJhbGciOiJIUzI1NiIsInR5cCI... │.│ eyJzdWIiOiIxMjM0NTY... │.│ SflKxwRJSMeKKF2QT... │
└────────────────────────────────┘ └────────────────────────┘ └──────────────────┘
     ↓                                  ↓                           ↓
   头部信息                          负载数据                      数字签名
 (加密算法等)                      (用户信息等)                  (防篡改)
```

### 2.2 Header（头部）- 说明书


**🔸 Header的作用**

Header就像产品说明书，告诉别人这个JWT用的是什么"配方"。

```json
{
  "alg": "HS256",    // 使用的加密算法（这里是HMAC SHA256）
  "typ": "JWT"       // 令牌类型（固定是JWT）
}
```

**通俗理解**：
- `alg`（algorithm）：用什么方式加密的，就像菜谱上写"清蒸"还是"红烧"
- `typ`（type）：声明这是JWT类型的令牌

这个JSON对象会被**Base64编码**（注意不是加密！）成第一段字符串。

### 2.3 Payload（负载）- 行李箱


**🔸 Payload装的是什么**

Payload就像你的行李箱，里面装着实际要传递的信息。

```json
{
  "sub": "1234567890",        // Subject：用户ID
  "name": "张三",              // 用户名
  "role": "admin",            // 角色
  "iat": 1516239022,          // Issued At：签发时间戳
  "exp": 1516242622           // Expiration：过期时间戳
}
```

**📋 常见的Claims（声明）**

Claims就是这些键值对数据，分三类：

| 类型 | 说明 | 示例 |
|------|------|------|
| **注册声明** | JWT标准定义的字段 | `iss`签发者、`sub`主题、`exp`过期时间 |
| **公共声明** | 自定义但建议注册的字段 | `name`、`email` |
| **私有声明** | 双方约定的自定义字段 | `userId`、`role`、`permissions` |

> ⚠️ **重要提醒**：Payload只是Base64编码，**不是加密**！任何人都能解码看到内容。所以千万不要在Payload里放密码、银行卡号等敏感信息！

### 2.4 Signature（签名）- 防伪标记


**🔸 Signature的作用**

签名就像防伪标记，确保JWT没有被人篡改。

**生成方式**：
```
signature = 加密算法(
    base64编码(header) + "." + base64编码(payload),
    密钥
)
```

**通俗理解**：

想象你寄快递：
1. **Header + Payload** = 快递包裹（内容物）
2. **密钥** = 你的私人印章
3. **Signature** = 用印章在包裹上盖章

收件人验证时：
- 用相同的印章（密钥）再盖一次
- 如果印记一模一样 → 包裹没被拆过 ✅
- 如果印记不一样 → 有人动过手脚 ❌

```
验证流程：
         JWT令牌
           ↓
    提取Header和Payload
           ↓
    用密钥重新计算签名
           ↓
    ┌─────────────────┐
    │ 新签名 == 旧签名？│
    └─────────────────┘
         ↙        ↘
      是✅         否❌
    令牌有效    令牌被篡改
```

---

## 3. 🔄 JWT工作原理


### 3.1 完整的认证流程


**📊 JWT认证全景图**

```
┌─────────┐                                    ┌─────────────┐
│ 客户端  │                                    │  认证服务器  │
└────┬────┘                                    └──────┬──────┘
     │                                                │
     │ ①POST /login {username, password}              │
     │ ─────────────────────────────────────────────> │
     │                                                │
     │                                         ② 验证账号密码
     │                                                │
     │                                         ③ 生成JWT令牌
     │                                         ┌──────────────┐
     │                                         │ Header       │
     │                                         │ + Payload    │
     │                                         │ + Signature  │
     │                                         └──────────────┘
     │                                                │
     │ ④ 返回JWT令牌                                   │
     │ <───────────────────────────────────────────── │
     │ {token: "eyJhbGc..."}                          │
     │                                                │
⑤ 存储JWT                                            │
(localStorage/                                       │
 sessionStorage)                                     │
     │                                                │
     │ ⑥ 后续请求携带JWT                               │
     │ GET /api/user                                  │
     │ Header: Authorization: Bearer eyJhbGc...       │
     │ ─────────────────────────────────────────────> │
     │                                                │
     │                                         ⑦ 验证JWT签名
     │                                         ⑧ 检查过期时间
     │                                         ⑨ 提取用户信息
     │                                                │
     │ ⑩ 返回受保护资源                               │
     │ <───────────────────────────────────────────── │
     │ {userId: xxx, name: xxx}                       │
```

### 3.2 JWT的生命周期


**⏰ 从生到死的过程**

```
时间线：
  ↓
【生成】用户登录成功
  │   ├─ 创建Payload（用户信息）
  │   ├─ 设置过期时间（exp）
  │   └─ 用密钥签名
  ↓
【使用】客户端每次请求携带
  │   ├─ 放在Header的Authorization字段
  │   ├─ 格式：Bearer <token>
  │   └─ 服务器验证签名和过期时间
  ↓
【过期】超过exp时间
  │   ├─ 服务器拒绝请求（401 Unauthorized）
  │   ├─ 客户端跳转登录页
  │   └─ 或使用Refresh Token刷新
  ↓
【作废】用户登出（可选）
      └─ 客户端删除token
```

### 3.3 Refresh Token机制


**🔄 为什么需要刷新令牌**

JWT的Access Token（访问令牌）通常设置较短的过期时间（如15分钟），但总让用户重新登录体验太差。这时就需要Refresh Token（刷新令牌）。

```
双Token机制：

Access Token（访问令牌）          Refresh Token（刷新令牌）
├─ 过期时间：15分钟               ├─ 过期时间：7天
├─ 用途：访问API                 ├─ 用途：获取新的Access Token
├─ 存储：内存（不持久化）          ├─ 存储：HttpOnly Cookie（安全）
└─ 泄露风险：低（时间短）          └─ 泄露风险：需要额外保护

工作流程：
1. 登录成功 → 同时返回Access Token和Refresh Token
2. 访问API → 使用Access Token
3. Access Token过期 → 用Refresh Token换新的Access Token
4. Refresh Token也过期 → 必须重新登录
```

---

## 4. 🔐 JWT的加密方式


### 4.1 对称加密（HMAC）


**🔸 什么是对称加密**

对称加密就像用同一把钥匙锁门和开门，服务器用密钥签名，也用同一个密钥验证。

**常用算法**：
- **HS256**（HMAC with SHA-256）：最常用
- **HS384**（HMAC with SHA-384）
- **HS512**（HMAC with SHA-512）

```java
// Java使用HMAC签名JWT示例
String secretKey = "my-secret-key-2024";  // 密钥（必须保密）

// 签名过程
String signature = HMACSHA256(
    base64(header) + "." + base64(payload),
    secretKey
);

// 验证过程
boolean valid = (生成的签名 == JWT中的签名);
```

**优缺点对比**：

| 优点 | 缺点 |
|------|------|
| ✅ 算法简单，性能快 | ❌ 密钥泄露风险高 |
| ✅ 资源消耗少 | ❌ 密钥分发困难 |
| ✅ 适合单体应用 | ❌ 不适合第三方验证 |

> 💡 **适用场景**：公司内部微服务之间的认证，所有服务共享同一个密钥。

### 4.2 非对称加密（RSA/ECDSA）


**🔸 什么是非对称加密**

非对称加密像一对钥匙：
- **私钥**：只有认证服务器持有，用来签名（锁门）
- **公钥**：所有服务器都有，用来验证（开门）

```
密钥对关系：

    【认证中心】
    持有私钥🔑
       ↓ 签名
    生成JWT
       ↓
┌──────────────────┐
│  各个微服务       │
│  持有公钥🔓      │  
│  验证JWT         │
└──────────────────┘

特点：
- 私钥签名的JWT，公钥可以验证
- 公钥即使泄露，也无法伪造JWT
- 适合分布式系统
```

**常用算法**：
- **RS256**（RSA with SHA-256）：广泛使用
- **ES256**（ECDSA with SHA-256）：性能更好
- **PS256**（RSA-PSS with SHA-256）

**优缺点对比**：

| 优点 | 缺点 |
|------|------|
| ✅ 安全性高 | ❌ 算法复杂，性能较慢 |
| ✅ 密钥管理方便 | ❌ 资源消耗大 |
| ✅ 支持第三方验证 | ❌ 密钥长度较长 |

> 💡 **适用场景**：多租户系统、开放API平台、需要第三方验证JWT的场景。

### 4.3 算法选择建议


```
选型指南：

内部系统：
├─ 微服务数量少（<10个）
│  └─ 推荐：HS256（对称加密）
│     理由：性能好，管理简单
│
└─ 微服务数量多（>10个）
   └─ 推荐：RS256（非对称加密）
      理由：密钥管理安全

开放平台：
└─ 第三方需要验证JWT
   └─ 必选：RS256或ES256
      理由：公钥可以公开分发

性能要求高：
└─ 并发量大（>10000 QPS）
   └─ 推荐：HS256或ES256
      理由：计算速度快
```

---

## 5. 🎯 JWT的使用场景


### 5.1 单点登录（SSO）


**场景描述**：

你有多个系统（如OA系统、邮件系统、财务系统），希望用户只登录一次就能访问所有系统。

```
SSO流程：

用户                认证中心              系统A         系统B
 │                    │                    │             │
 │──①访问系统A──>      │                    │             │
 │                    │<──②未登录,跳转认证──│             │
 │<──────────────────③重定向到认证中心──────│             │
 │                    │                                  │
 │──④输入账号密码──>   │                                  │
 │                    │                                  │
 │                 ⑤验证成功                            │
 │                 ⑥生成JWT                             │
 │                    │                                  │
 │<──⑦返回JWT并跳回A──│                                  │
 │                    │                                  │
 │──⑧带JWT访问A──────>│                    │             │
 │                    │                    │             │
 │                                      ⑨验证JWT         │
 │                                      ⑩返回资源        │
 │<───────────────────────────────────────│             │
 │                                                       │
 │──⑪带JWT访问B────────────────────────────────────────>│
 │                                                       │
 │                                                  ⑫验证JWT
 │                                                  ⑬返回资源
 │<──────────────────────────────────────────────────────│
```

### 5.2 移动端API认证


**场景描述**：

手机APP调用后端API，传统Cookie方式不适用，JWT是最佳选择。

```
移动端使用JWT：

【登录阶段】
App → POST /api/login {username, password}
API → 验证成功，返回JWT
App → 保存JWT到本地存储（SharedPreferences/UserDefaults）

【请求阶段】  
App → GET /api/user/profile
      Header: Authorization: Bearer eyJhbGc...
API → 验证JWT，返回数据

【优势】
✅ 不依赖Cookie，适合App
✅ 支持跨域请求
✅ 可以设置长期有效（配合Refresh Token）
✅ 服务器无状态，易于扩展
```

### 5.3 微服务间认证


**场景描述**：

用户请求到达API网关，网关验证JWT后，各个微服务都可以直接信任这个JWT。

```
微服务认证链：

用户请求
   ↓
【API网关】
   ├─ 验证JWT签名
   ├─ 检查过期时间
   ├─ 提取用户信息
   └─ 转发请求（携带JWT）
       ↓
   【订单服务】
       ├─ 信任网关验证的JWT
       ├─ 直接提取用户ID
       └─ 调用【库存服务】（携带JWT）
              ↓
          【库存服务】
              ├─ 同样信任JWT
              └─ 执行业务逻辑

关键点：
- 只有网关验证JWT签名
- 内部服务信任JWT内容
- 减少重复验证，提高性能
```

---

## 6. 🛡️ JWT安全性考虑


### 6.1 常见安全问题


**⚠️ 需要注意的安全隐患**

| 问题 | 原因 | 危害 | 防范措施 |
|------|------|------|----------|
| **密钥泄露** | 密钥保存在代码中 | 攻击者可伪造JWT | 使用环境变量、密钥管理服务 |
| **算法降级** | 未验证算法类型 | 绕过签名验证 | 强制指定算法，拒绝`none` |
| **XSS攻击** | JWT存在localStorage | 被脚本窃取 | 存在HttpOnly Cookie中 |
| **重放攻击** | JWT被截获重复使用 | 身份冒用 | 添加jti（唯一ID）、设置短过期时间 |
| **敏感信息泄露** | Payload未加密 | 信息暴露 | 不在Payload放敏感数据 |

### 6.2 最佳实践


**🔒 安全使用JWT的建议**

```
【密钥管理】
✅ 使用强密钥（至少256位）
✅ 定期轮换密钥
✅ 使用密钥管理服务（如AWS KMS、HashiCorp Vault）
✅ 永远不要在代码中硬编码密钥

【算法选择】
✅ 生产环境使用RS256或ES256
✅ 明确指定算法，不信任JWT中的alg字段
✅ 禁用不安全的算法（如none、HS256弱密钥）

【令牌管理】
✅ 设置合理的过期时间（Access Token: 15分钟）
✅ 使用Refresh Token机制
✅ 重要操作要求重新验证
✅ 提供手动撤销机制（黑名单）

【传输安全】
✅ 必须使用HTTPS
✅ 不在URL中传递JWT
✅ 移动端使用安全存储（Keychain/KeyStore）
```

### 6.3 JWT黑名单实现


虽然JWT是无状态的，但有时需要主动撤销令牌（如用户登出、密码修改）。

```
黑名单方案：

【Redis黑名单】
用户登出 → 将JWT的jti存入Redis
        → 设置过期时间为JWT剩余有效期

验证JWT → 检查jti是否在黑名单中
        → 在黑名单则拒绝
        → 不在则继续验证

优点：
✅ 可以主动撤销JWT
✅ Redis性能高，影响小

缺点：
❌ 引入了状态存储
❌ 需要额外的Redis查询
```

```java
// Java伪代码示例
public boolean validateJWT(String token) {
    // 解析JWT获取jti
    String jti = parseJWT(token).getJti();
    
    // 检查黑名单
    if (redisTemplate.hasKey("blacklist:" + jti)) {
        return false; // 在黑名单中，拒绝
    }
    
    // 验证签名和过期时间
    return verifySignatureAndExpiration(token);
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 JWT本质：一种无状态的认证令牌，信息自包含
🔸 三段结构：Header（算法说明）+ Payload（用户信息）+ Signature（防篡改签名）
🔸 Base64编码：不是加密！任何人都能解码看到内容
🔸 签名作用：确保JWT未被篡改，不是为了保密
🔸 过期时间：必须设置exp，防止令牌永久有效
```

### 7.2 关键理解要点


**🔹 JWT vs Session的本质区别**

```
Session方式：
- 服务器说了算：我记住你了（存Session）
- 你带着身份证来：我查一下档案（查Session）
- 我忘记了：你得重新登记（Session丢失）

JWT方式：
- 我给你一个通行证：上面写着你的信息（生成JWT）
- 你每次带通行证来：我验证防伪标记（验证签名）
- 我不记得你：但通行证本身是可信的
```

**🔹 什么时候用JWT**

```
✅ 适合用JWT的场景：
- 微服务架构（服务间认证）
- 移动端APP（不依赖Cookie）
- 单点登录SSO（跨域认证）
- 前后端分离项目

❌ 不适合用JWT的场景：
- 需要实时撤销权限（JWT无法立即失效）
- 高敏感系统（JWT信息可被解码）
- 单体应用且对性能要求不高（Session更简单）
```

### 7.3 实践建议


**💡 新手使用JWT的建议**

```
入门阶段：
1️⃣ 先用对称加密（HS256），理解基本原理
2️⃣ 使用成熟的JWT库（Java用jjwt、.NET用JwtBearer）
3️⃣ 设置短过期时间（15分钟），强制理解Refresh Token

进阶阶段：
4️⃣ 切换到非对称加密（RS256），学习密钥管理
5️⃣ 实现黑名单机制，处理特殊撤销需求
6️⃣ 监控JWT使用情况，优化过期时间

生产环境：
7️⃣ 必须使用HTTPS
8️⃣ 密钥存环境变量或密钥管理服务
9️⃣ 定期审计JWT使用和安全配置
🔟 准备应急预案（密钥泄露时的响应流程）
```

### 7.4 常见误区


```
❌ 误区1：JWT是加密的，很安全
   → Payload只是Base64编码，任何人都能解码

❌ 误区2：JWT不会过期
   → 必须设置exp字段，否则永久有效

❌ 误区3：JWT可以随时撤销
   → JWT是无状态的，需要额外实现黑名单机制

❌ 误区4：所有信息都能放Payload
   → 绝不能放密码、银行卡等敏感信息

❌ 误区5：用了JWT就一定安全
   → 安全性取决于密钥管理、传输方式、使用场景
```

**核心记忆口诀**：
- JWT三段式，点号来分隔
- Header说算法，Payload装数据  
- Signature防篡改，密钥要保密
- Base64非加密，敏感信息莫存储
- 过期时间要设置，黑名单来补充
- HTTPS是必须，安全无小事