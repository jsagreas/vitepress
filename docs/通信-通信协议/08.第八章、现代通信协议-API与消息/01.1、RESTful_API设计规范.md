---
title: 1、RESTful_API设计规范
---
## 📚 目录

1. [REST架构基础概念](#1-REST架构基础概念)
2. [HTTP动词与CRUD映射](#2-HTTP动词与CRUD映射)
3. [URL资源设计规范](#3-URL资源设计规范)
4. [状态码正确使用](#4-状态码正确使用)
5. [JSON数据格式规范](#5-JSON数据格式规范)
6. [API版本管理策略](#6-API版本管理策略)
7. [RESTful最佳实践](#7-RESTful最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🏗️ REST架构基础概念


### 1.1 什么是REST？


**🔸 REST的本质含义**
```
REST = REpresentational State Transfer（表现层状态转移）

通俗理解：
把网络上的所有东西都看成"资源"（Resource）
通过网址（URL）来指定资源
通过HTTP方法来操作资源
```

**💡 生活中的REST比喻**
```
想象一个图书馆：
📚 书籍 = 资源（Resource）
🏷️ 书架编号 = URL地址
📋 借、还、查 = HTTP方法

例子：
/books/123        ← 指向第123号书
GET /books/123    ← 查看这本书
PUT /books/123    ← 更新这本书信息
DELETE /books/123 ← 删除这本书
```

### 1.2 REST的六大核心原则


**🎯 核心原则详解**

**1️⃣ 无状态（Stateless）**
```
含义：服务器不保存客户端的状态信息
通俗说：每次请求都要带上完整信息，服务器不记忆

好处：
✅ 服务器更简单
✅ 容易扩展
✅ 可靠性更高

示例：
❌ 错误：需要先登录，服务器记住登录状态
✅ 正确：每次请求都带上用户Token
```

**2️⃣ 统一接口（Uniform Interface）**
```
含义：所有资源都用统一的方式访问
通俗说：不管什么资源，都用同样的"语法"

统一方式：
- 用URL标识资源
- 用HTTP方法操作资源  
- 用标准状态码表示结果
- 用标准格式传输数据
```

**3️⃣ 资源标识（Resource Identification）**
```
含义：每个资源都有唯一的标识符
通俗说：每样东西都有唯一的"门牌号"

示例：
/users/123        ← 用户123
/posts/456        ← 文章456
/comments/789     ← 评论789
```

**4️⃣ 资源操作（Resource Manipulation）**
```
含义：通过表现形式操作资源
通俗说：不直接操作数据，而是通过"外在表现"操作

示例：
客户端看到的：JSON格式的用户信息
服务器内部：可能是数据库、文件等任何形式
```

**5️⃣ 自描述消息（Self-descriptive Messages）**
```
含义：消息包含足够的信息来描述如何处理
通俗说：请求和响应都要"自带说明书"

示例：
Content-Type: application/json  ← 说明数据格式
Accept: application/json        ← 说明期望的响应格式
```

**6️⃣ 超媒体驱动（HATEOAS）**
```
含义：响应中包含相关操作的链接
通俗说：告诉客户端"下一步可以做什么"

示例：
{
  "id": 123,
  "name": "张三",
  "links": {
    "self": "/users/123",
    "posts": "/users/123/posts",
    "edit": "/users/123/edit"
  }
}
```

### 1.3 为什么要使用REST？


**🚀 REST的核心优势**
```
简单易懂：
- 基于HTTP，开发者都熟悉
- 概念清晰，容易理解

标准统一：
- 行业公认的设计风格
- 工具和框架支持好

可扩展性：
- 无状态设计，容易集群
- 缓存友好，性能好

互操作性：
- 跨平台、跨语言
- 浏览器原生支持
```

---

## 2. 🔧 HTTP动词与CRUD映射


### 2.1 基本HTTP动词含义


**📋 核心HTTP动词详解**

| HTTP动词 | **含义** | **作用** | **是否安全** | **是否幂等** |
|----------|----------|----------|-------------|-------------|
| 🔍 **GET** | `获取资源` | `查询数据，不修改服务器状态` | `✅ 安全` | `✅ 幂等` |
| 📝 **POST** | `创建资源` | `提交数据，创建新资源` | `❌ 不安全` | `❌ 非幂等` |
| 🔄 **PUT** | `更新资源` | `完整替换资源内容` | `❌ 不安全` | `✅ 幂等` |
| 🔧 **PATCH** | `部分更新` | `修改资源的部分内容` | `❌ 不安全` | `❌ 非幂等` |
| 🗑️ **DELETE** | `删除资源` | `删除指定资源` | `❌ 不安全` | `✅ 幂等` |

**💡 安全性和幂等性说明**
```
安全性：不会修改服务器状态
- GET是安全的：只查询，不修改
- POST/PUT/DELETE是不安全的：会修改服务器

幂等性：多次执行结果相同
- GET /users/123：查询多次结果一样
- PUT /users/123：更新多次最终状态一样
- POST /users：创建多次会产生多个用户
- DELETE /users/123：删除多次，第一次删除，后续404
```

### 2.2 CRUD操作映射


**🔄 CRUD与HTTP动词的对应关系**

```
数据库操作        HTTP动词        API示例
────────────────────────────────────────────
CREATE (创建)  →  POST    →  POST /users
READ   (读取)  →  GET     →  GET /users/123
UPDATE (更新)  →  PUT     →  PUT /users/123
DELETE (删除)  →  DELETE  →  DELETE /users/123
```

**📝 具体使用示例**

**创建用户（CREATE）**
```http
POST /users
Content-Type: application/json

{
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25
}

响应：
HTTP/1.1 201 Created
{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25,
  "created_at": "2025-08-08T10:30:00Z"
}
```

**查询用户（READ）**
```http
GET /users/123

响应：
HTTP/1.1 200 OK
{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25
}
```

**更新用户（UPDATE）**
```http
PUT /users/123
Content-Type: application/json

{
  "name": "张三",
  "email": "zhangsan@qq.com",
  "age": 26
}

响应：
HTTP/1.1 200 OK
{
  "id": 123,
  "name": "张三", 
  "email": "zhangsan@qq.com",
  "age": 26,
  "updated_at": "2025-08-08T11:00:00Z"
}
```

**删除用户（DELETE）**
```http
DELETE /users/123

响应：
HTTP/1.1 204 No Content
```

### 2.3 PUT vs PATCH的区别


**🔄 完整更新 vs 部分更新**

```
PUT（完整替换）：
- 发送完整的资源数据
- 会覆盖所有字段
- 幂等操作

PATCH（部分修改）：
- 只发送要修改的字段
- 不影响其他字段
- 通常非幂等
```

**示例对比：**
```http
# 用户当前信息
{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25,
  "phone": "13800138000"
}

# PUT方式修改邮箱（需要发送完整数据）
PUT /users/123
{
  "name": "张三",
  "email": "zhangsan@qq.com",  ← 修改的字段
  "age": 25,
  "phone": "13800138000"       ← 不修改也要发送
}

# PATCH方式修改邮箱（只发送修改的字段）
PATCH /users/123
{
  "email": "zhangsan@qq.com"   ← 只发送要修改的
}
```

---

## 3. 🎯 URL资源设计规范


### 3.1 URL设计基本原则


**📏 核心设计原则**

**1️⃣ 名词为主，动词为辅**
```
✅ 正确示例：
GET /users          ← 名词，表示用户资源
GET /users/123      ← 名词+ID，表示特定用户
POST /users         ← 名词，创建用户

❌ 错误示例：
GET /getUsers       ← 动词+名词，不符合REST
POST /createUser    ← 动词+名词，应该用POST /users
GET /deleteUser/123 ← 动词，应该用DELETE /users/123
```

**2️⃣ 使用复数形式**
```
✅ 推荐：
/users              ← 复数，表示用户集合
/posts              ← 复数，表示文章集合
/comments           ← 复数，表示评论集合

❌ 不推荐：
/user               ← 单数，不够清晰
/post               ← 单数，容易混淆
```

**3️⃣ 层级关系清晰**
```
✅ 表示资源间的包含关系：
/users/123/posts          ← 用户123的所有文章
/posts/456/comments       ← 文章456的所有评论
/users/123/posts/456      ← 用户123的文章456

层级不要太深：
❌ /users/123/posts/456/comments/789/replies/111
✅ /comments/789/replies  或 /replies?comment_id=789
```

### 3.2 常见资源URL模式


**📂 标准资源URL设计**

```
资源操作模式：

集合资源（Collection）：
GET    /users           ← 获取用户列表
POST   /users           ← 创建新用户

单个资源（Item）：
GET    /users/123       ← 获取用户123
PUT    /users/123       ← 更新用户123
PATCH  /users/123       ← 部分更新用户123
DELETE /users/123       ← 删除用户123

嵌套资源（Nested）：
GET    /users/123/posts ← 获取用户123的文章列表
POST   /users/123/posts ← 为用户123创建文章
GET    /users/123/posts/456 ← 获取用户123的文章456
```

**🔍 查询参数的使用**

```
分页查询：
GET /users?page=2&limit=20

筛选查询：
GET /users?age=25&city=北京

排序查询：
GET /users?sort=age&order=desc

搜索查询：
GET /users?search=张三

组合查询：
GET /users?age=25&city=北京&sort=name&order=asc&page=1&limit=10
```

### 3.3 特殊操作的URL设计


**⚡ 非标准CRUD操作**

```
批量操作：
POST /users/batch              ← 批量创建用户
PUT  /users/batch              ← 批量更新用户
DELETE /users/batch            ← 批量删除用户

状态改变：
POST /users/123/activate       ← 激活用户
POST /users/123/deactivate     ← 停用用户
POST /orders/456/cancel        ← 取消订单
POST /orders/456/ship          ← 发货

复杂查询：
GET /users/search?q=张三       ← 搜索用户
GET /reports/sales             ← 销售报表
GET /statistics/users          ← 用户统计
```

**🎨 URL命名规范**

```
命名规则：
✅ 使用小写字母：/users, /posts
✅ 使用连字符分隔：/user-profiles, /order-items
✅ 避免下划线：避免 /user_profiles
✅ 简洁明了：/users 而不是 /user-information

版本控制：
/v1/users              ← URL中包含版本
/v2/users              ← 新版本API

Accept: application/vnd.api+json;version=1  ← 请求头中指定版本
```

---

## 4. 📊 状态码正确使用


### 4.1 HTTP状态码分类


**🏷️ 状态码的含义分类**

```
1xx 信息性状态码：请求已接收，继续处理
2xx 成功状态码：请求已成功处理  
3xx 重定向状态码：需要进一步操作来完成请求
4xx 客户端错误：请求有错误，服务器无法处理
5xx 服务器错误：服务器在处理请求时发生错误
```

### 4.2 常用成功状态码（2xx）


**✅ 成功状态码详解**

| 状态码 | **含义** | **使用场景** | **响应体** |
|--------|----------|-------------|-----------|
| `200 OK` | `请求成功` | `GET、PUT、PATCH成功` | `✅ 有数据` |
| `201 Created` | `资源已创建` | `POST创建成功` | `✅ 返回新资源` |
| `204 No Content` | `成功但无内容` | `DELETE成功` | `❌ 无响应体` |
| `206 Partial Content` | `部分内容` | `分片下载、分页` | `✅ 部分数据` |

**💡 使用示例**

```http
# 200 OK - 查询成功
GET /users/123
HTTP/1.1 200 OK
{
  "id": 123,
  "name": "张三"
}

# 201 Created - 创建成功
POST /users
HTTP/1.1 201 Created
Location: /users/124
{
  "id": 124,
  "name": "李四"
}

# 204 No Content - 删除成功
DELETE /users/123
HTTP/1.1 204 No Content
(无响应体)
```

### 4.3 常用客户端错误状态码（4xx）


**❌ 客户端错误状态码详解**

| 状态码 | **含义** | **使用场景** | **错误示例** |
|--------|----------|-------------|-------------|
| `400 Bad Request` | `请求格式错误` | `参数缺失、格式不正确` | `缺少必填字段` |
| `401 Unauthorized` | `未授权` | `未登录、Token无效` | `需要登录` |
| `403 Forbidden` | `禁止访问` | `权限不足` | `无权限操作` |
| `404 Not Found` | `资源不存在` | `URL错误、资源已删除` | `用户不存在` |
| `405 Method Not Allowed` | `方法不允许` | `HTTP方法不支持` | `GET不支持创建` |
| `409 Conflict` | `资源冲突` | `重复创建、状态冲突` | `邮箱已存在` |
| `422 Unprocessable Entity` | `请求格式正确但语义错误` | `业务逻辑验证失败` | `年龄不能为负数` |
| `429 Too Many Requests` | `请求过多` | `限流、频率限制` | `请求过于频繁` |

**🔍 错误响应示例**

```http
# 400 Bad Request - 参数错误
POST /users
{
  "email": "invalid-email"  ← 邮箱格式错误
}

HTTP/1.1 400 Bad Request
{
  "error": "Bad Request",
  "message": "邮箱格式不正确",
  "details": {
    "field": "email",
    "code": "INVALID_FORMAT"
  }
}

# 401 Unauthorized - 未授权
GET /users/123/private-info

HTTP/1.1 401 Unauthorized
{
  "error": "Unauthorized",
  "message": "访问令牌无效或已过期"
}

# 404 Not Found - 资源不存在
GET /users/999

HTTP/1.1 404 Not Found
{
  "error": "Not Found", 
  "message": "用户不存在"
}
```

### 4.4 常用服务器错误状态码（5xx）


**🔥 服务器错误状态码详解**

| 状态码 | **含义** | **使用场景** |
|--------|----------|-------------|
| `500 Internal Server Error` | `内部服务器错误` | `代码bug、未捕获异常` |
| `502 Bad Gateway` | `网关错误` | `上游服务不可用` |
| `503 Service Unavailable` | `服务不可用` | `系统维护、过载` |
| `504 Gateway Timeout` | `网关超时` | `上游服务响应超时` |

```http
# 500 Internal Server Error
GET /users

HTTP/1.1 500 Internal Server Error
{
  "error": "Internal Server Error",
  "message": "服务器内部错误，请稍后重试"
}
```

---

## 5. 📄 JSON数据格式规范


### 5.1 JSON基础规范


**📋 JSON格式基本要求**

```json
{
  "基本原则": {
    "字符编码": "UTF-8",
    "缩进方式": "2个空格",
    "命名规范": "camelCase或snake_case",
    "必须字段": "不能为null",
    "时间格式": "ISO 8601标准"
  }
}
```

**✅ 标准JSON示例**
```json
{
  "id": 123,
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25,
  "isActive": true,
  "createdAt": "2025-08-08T10:30:00Z",
  "updatedAt": "2025-08-08T11:00:00Z",
  "profile": {
    "avatar": "https://example.com/avatar.jpg",
    "bio": "这是个人简介"
  },
  "tags": ["开发者", "Vue.js", "JavaScript"]
}
```

### 5.2 响应数据结构规范


**🏗️ 统一响应格式**

```json
// 成功响应格式
{
  "success": true,
  "data": {
    "id": 123,
    "name": "张三"
  },
  "message": "操作成功",
  "timestamp": "2025-08-08T10:30:00Z"
}

// 错误响应格式  
{
  "success": false,
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "用户不存在",
    "details": "用户ID 123 在系统中不存在"
  },
  "timestamp": "2025-08-08T10:30:00Z"
}
```

**📋 列表数据格式**
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "id": 123,
        "name": "张三"
      },
      {
        "id": 124, 
        "name": "李四"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 150,
      "totalPages": 8
    }
  }
}
```

### 5.3 字段命名规范


**🏷️ 命名约定**

```
字段命名风格选择：
✅ camelCase：userName, createdAt, isActive
✅ snake_case：user_name, created_at, is_active

注意：选择一种风格并在整个API中保持一致

特殊字段约定：
- id：资源唯一标识符
- createdAt/created_at：创建时间
- updatedAt/updated_at：更新时间
- isDeleted/is_deleted：软删除标记
```

**⏰ 时间格式标准**
```json
{
  "时间格式说明": {
    "标准格式": "ISO 8601",
    "UTC时间": "2025-08-08T10:30:00Z",
    "带时区": "2025-08-08T18:30:00+08:00",
    "仅日期": "2025-08-08",
    "仅时间": "10:30:00"
  }
}
```

---

## 6. 🔄 API版本管理策略


### 6.1 为什么需要版本管理？


**🤔 版本管理的必要性**

```
业务发展需要：
✅ 功能迭代：新功能上线
✅ 结构调整：数据结构优化
✅ 兼容性：支持老版本客户端

问题场景：
❌ 直接修改API：破坏现有客户端
❌ 无版本控制：无法追踪变更
❌ 强制升级：用户体验差
```

**💡 版本管理的好处**
```
向后兼容：
- 老版本继续可用
- 渐进式升级
- 减少客户端修改

灰度发布：
- 新版本逐步推广
- 快速回滚
- 风险控制

清晰维护：
- 明确版本界限
- 便于问题定位
- 文档管理清晰
```

### 6.2 版本控制方法


**🎯 URL路径版本控制**
```http
# 方法1：URL路径中包含版本
GET /v1/users/123
GET /v2/users/123

优点：
✅ 直观明确
✅ 容易理解
✅ 缓存友好

缺点：
❌ URL变化大
❌ 需要维护多套路由
```

**📋 请求头版本控制**
```http
# 方法2：自定义请求头
GET /users/123
API-Version: v2

# 方法3：Accept头控制
GET /users/123  
Accept: application/vnd.api+json;version=2

优点：
✅ URL保持不变
✅ 灵活性高

缺点：
❌ 不够直观
❌ 缓存复杂
```

**🔧 查询参数版本控制**
```http
# 方法4：查询参数
GET /users/123?version=v2

优点：
✅ 简单直接
✅ 容易测试

缺点：
❌ 容易被忽略
❌ 不够规范
```

### 6.3 版本策略最佳实践


**📊 版本号规范**

```
语义化版本控制（推荐）：
v1.0.0：主版本.次版本.修订版本

主版本（Major）：
- 不兼容的API修改
- 数据结构重大变化
- 例：v1 → v2

次版本（Minor）：
- 向后兼容的功能性新增
- 新增字段（可选）
- 例：v1.0 → v1.1

修订版本（Patch）：
- 向后兼容的问题修正
- bug修复
- 例：v1.0.0 → v1.0.1
```

**⚡ 版本生命周期管理**

```
版本生命周期：

开发阶段：v2.0.0-alpha.1
测试阶段：v2.0.0-beta.1  
发布候选：v2.0.0-rc.1
正式发布：v2.0.0
维护阶段：v2.0.1, v2.0.2
弃用公告：Deprecated in v2.1.0
停止维护：End of Life

弃用流程：
1. 提前6个月公告弃用
2. 在响应头中添加弃用警告
3. 文档标记为已弃用
4. 提供迁移指南
```

**🔄 版本迁移示例**

```http
# v1版本响应
GET /v1/users/123
{
  "id": 123,
  "username": "zhangsan",
  "email": "zhangsan@example.com"
}

# v2版本响应（字段名变更）
GET /v2/users/123
{
  "id": 123,
  "name": "张三",              ← 字段名从username改为name
  "email": "zhangsan@example.com",
  "profile": {                 ← 新增profile嵌套结构
    "avatar": "avatar.jpg",
    "bio": "个人简介"
  }
}

# 弃用警告响应头
HTTP/1.1 200 OK
Deprecation: true
Sunset: Wed, 11 Nov 2025 23:59:59 GMT
Warning: 299 - "API version v1 is deprecated. Please migrate to v2."
```

---

## 7. ⭐ RESTful最佳实践


### 7.1 安全性最佳实践


**🔒 API安全要点**

**身份认证（Authentication）**
```http
# JWT Token认证
GET /users/123
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# API Key认证
GET /users/123
X-API-Key: sk_live_abcd1234...

# OAuth 2.0认证
GET /users/123
Authorization: Bearer access_token_here
```

**权限控制（Authorization）**
```json
{
  "权限检查流程": [
    "1. 验证用户身份",
    "2. 检查资源权限", 
    "3. 验证操作权限",
    "4. 执行业务逻辑"
  ],
  "错误处理": {
    "无权限": "403 Forbidden",
    "需要登录": "401 Unauthorized"
  }
}
```

**输入验证**
```javascript
// 服务端验证示例
function validateUser(data) {
  const errors = [];
  
  // 必填字段检查
  if (!data.name) errors.push('姓名是必填项');
  if (!data.email) errors.push('邮箱是必填项');
  
  // 格式验证
  if (data.email && !isValidEmail(data.email)) {
    errors.push('邮箱格式不正确');
  }
  
  // 业务规则验证
  if (data.age && data.age < 0) {
    errors.push('年龄不能为负数');
  }
  
  return errors;
}
```

### 7.2 性能优化最佳实践


**⚡ 缓存策略**

```http
# 浏览器缓存控制
GET /users/123
HTTP/1.1 200 OK
Cache-Control: max-age=3600, private
ETag: "abc123"
Last-Modified: Wed, 08 Aug 2025 10:30:00 GMT

# 条件请求
GET /users/123
If-None-Match: "abc123"

HTTP/1.1 304 Not Modified
```

**📊 分页和筛选**
```http
# 分页参数
GET /users?page=2&limit=20&sort=name&order=asc

# 字段筛选（减少数据传输）
GET /users?fields=id,name,email

# 响应格式
{
  "data": [
    {"id": 123, "name": "张三", "email": "zhangsan@example.com"}
  ],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 1500,
    "hasNext": true,
    "hasPrev": true
  }
}
```

**🔍 查询优化**
```http
# 批量查询（减少请求次数）
GET /users?ids=123,124,125

# 关联数据预加载
GET /users/123?include=posts,comments

# 搜索和过滤
GET /users?search=张三&age_min=20&age_max=30&city=北京
```

### 7.3 错误处理最佳实践


**🚨 统一错误格式**

```json
{
  "错误响应标准格式": {
    "error": {
      "code": "VALIDATION_ERROR",
      "message": "请求数据验证失败",
      "details": [
        {
          "field": "email",
          "message": "邮箱格式不正确",
          "value": "invalid-email"
        }
      ],
      "timestamp": "2025-08-08T10:30:00Z",
      "path": "/users",
      "requestId": "req_123abc"
    }
  }
}
```

**🔧 错误码设计**
```json
{
  "错误码规范": {
    "命名规则": "大写字母+下划线",
    "分类前缀": {
      "VALIDATION_": "数据验证错误",
      "AUTH_": "认证授权错误", 
      "BUSINESS_": "业务逻辑错误",
      "SYSTEM_": "系统错误"
    }
  },
  "常用错误码": {
    "VALIDATION_REQUIRED": "必填字段缺失",
    "VALIDATION_FORMAT": "格式不正确",
    "AUTH_TOKEN_INVALID": "Token无效",
    "AUTH_PERMISSION_DENIED": "权限不足",
    "BUSINESS_USER_EXISTS": "用户已存在",
    "SYSTEM_DATABASE_ERROR": "数据库错误"
  }
}
```

### 7.4 文档和测试


**📚 API文档要求**
```markdown
每个API接口都应包含：
✅ 接口描述和用途
✅ 请求方法和URL
✅ 请求参数说明
✅ 响应格式和示例
✅ 错误码说明
✅ 使用示例
```

**🧪 接口测试**
```javascript
// 测试用例示例
describe('用户API测试', () => {
  test('创建用户 - 成功', async () => {
    const userData = {
      name: '张三',
      email: 'zhangsan@example.com'
    };
    
    const response = await api.post('/users', userData);
    
    expect(response.status).toBe(201);
    expect(response.data.name).toBe('张三');
    expect(response.data.id).toBeDefined();
  });
  
  test('创建用户 - 邮箱重复', async () => {
    const userData = {
      name: '李四',
      email: 'zhangsan@example.com'  // 重复邮箱
    };
    
    const response = await api.post('/users', userData);
    
    expect(response.status).toBe(409);
    expect(response.data.error.code).toBe('EMAIL_EXISTS');
  });
});
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 REST本质：把网络资源看作可操作的对象
🔸 HTTP动词：GET查询、POST创建、PUT更新、DELETE删除
🔸 URL设计：名词为主、复数形式、层级清晰
🔸 状态码：2xx成功、4xx客户端错误、5xx服务器错误
🔸 JSON规范：统一格式、命名规范、时间标准
🔸 版本管理：向后兼容、生命周期、迁移策略
```

### 8.2 关键设计原则


**🎯 设计原则记忆**
```
资源导向：一切皆资源，用URL标识
统一接口：相同操作用相同方法
无状态性：每次请求包含完整信息
可缓存性：GET请求支持缓存
分层系统：客户端不需要知道服务器实现
按需获取：客户端可以选择需要的数据
```

**🔄 操作映射口诀**
```
GET来查询不修改，
POST创建新资源，
PUT完整替换好，
PATCH部分修改巧，
DELETE删除要记牢。
```

### 8.3 实际应用指导


**✅ 设计检查清单**
- [ ] URL是否使用名词和复数形式？
- [ ] HTTP动词是否符合语义？
- [ ] 状态码是否正确使用？
- [ ] JSON格式是否规范？
- [ ] 错误处理是否完善？
- [ ] 是否考虑了版本控制？
- [ ] 是否有API文档？
- [ ] 是否有安全措施？

**🚀 最佳实践记忆**
- **简单性**：设计要简洁明了，符合直觉
- **一致性**：整个API风格保持统一
- **可预测**：用户能猜到接口如何使用
- **可扩展**：为未来变化留有余地
- **可维护**：代码和文档易于维护

**核心记忆口诀**：
- REST设计有章法，资源名词复数化
- HTTP动词语义明，状态码要用对应
- JSON格式要规范，版本管理不可少
- 安全缓存性能好，文档测试要齐全