---
title: 1、HTTP协议
---
## 📚 目录

1. [HTTP协议基础概念](#1-HTTP协议基础概念)
2. [HTTP请求-响应模型](#2-HTTP请求响应模型)
3. [HTTP方法详解](#3-HTTP方法详解)
4. [HTTP状态码详解](#4-HTTP状态码详解)
5. [HTTP消息格式结构](#5-HTTP消息格式结构)
6. [请求头与响应头](#6-请求头与响应头)
7. [HTTP版本对比](#7-HTTP版本对比)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 HTTP协议基础概念


### 1.1 什么是HTTP协议


**🔸 简单理解HTTP**
```
HTTP = HyperText Transfer Protocol（超文本传输协议）

通俗解释：
就像邮局寄信的规则一样，HTTP是网页浏览器和网站服务器之间
传递信息时必须遵守的"通信规则"

日常例子：
你打开浏览器访问网站 → 浏览器按HTTP规则发送请求
网站服务器收到请求 → 按HTTP规则返回网页内容
```

**💡 HTTP的作用**
```
核心功能：让浏览器和服务器能够"对话"
• 浏览器：我想要这个网页
• 服务器：好的，给你网页内容
• 浏览器：我要提交表单数据
• 服务器：收到，处理完毕

没有HTTP会怎样？
就像两个人说不同语言，无法交流
```

### 1.2 HTTP协议特点


**🔸 核心特征**
```
📝 无状态协议：
• 含义：服务器不记住之前的请求
• 好处：简单，不占用额外内存
• 问题：每次都要重新确认身份
• 解决：使用Cookie和Session来记住用户

🔗 基于TCP连接：
• 含义：建立在可靠的TCP协议之上
• 好处：数据传输不会丢失
• 过程：先建立TCP连接，再发送HTTP数据

📄 文本协议：
• 含义：传输的内容人眼可读
• 好处：便于调试和理解
• 示例：GET /index.html HTTP/1.1
```

### 1.3 HTTP在网络中的位置


**🌍 协议栈位置**
```
┌─────────────────────┐
│     应用层          │ ← HTTP协议在这里
│   (HTTP/HTTPS)      │   负责网页内容传输
├─────────────────────┤
│     传输层          │ ← TCP协议
│      (TCP)          │   负责可靠传输
├─────────────────────┤
│     网络层          │ ← IP协议
│      (IP)           │   负责寻找路径
├─────────────────────┤
│   数据链路层        │ ← 以太网等
│   (Ethernet)        │   负责本地传输
└─────────────────────┘

简单理解：
HTTP = 说什么内容（网页、图片、视频）
TCP = 怎么安全送达（分包、重传、确认）
IP = 送到哪里去（寻找路由路径）
```

---

## 2. 🔄 HTTP请求响应模型


### 2.1 基本工作原理


**🔸 简单对话模型**
```
客户端（浏览器）     服务器（网站）
        |                |
        |---> 请求 ------>|  "我要首页"
        |                |  处理请求...
        |<--- 响应 <------|  "给你首页内容"
        |                |

特点：
• 一问一答：客户端问，服务器答
• 客户端主动：只有客户端能发起请求
• 无连接：回答完就断开（HTTP/1.0）
```

### 2.2 完整交互流程


**📋 详细步骤解析**
```
1. 用户输入网址
   ↓
2. 浏览器解析URL
   ↓
3. 建立TCP连接
   ↓
4. 发送HTTP请求
   ↓
5. 服务器处理请求
   ↓
6. 服务器返回HTTP响应
   ↓
7. 浏览器解析响应
   ↓
8. 渲染显示网页
```

**💻 实际例子**
```
用户操作：在地址栏输入 www.example.com

背后发生：
1. 浏览器查找 www.example.com 的IP地址
2. 与服务器的80端口建立TCP连接
3. 发送HTTP请求：GET / HTTP/1.1
4. 服务器查找首页文件
5. 返回HTML内容和200状态码
6. 浏览器渲染HTML显示网页
7. 关闭TCP连接（或保持连接）
```

### 2.3 请求响应示例


**🔸 真实HTTP交互**
```
客户端请求：
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome/91.0

服务器响应：
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
<head><title>示例网页</title></head>
<body><h1>欢迎访问</h1></body>
</html>
```

---

## 3. 📝 HTTP方法详解


### 3.1 什么是HTTP方法


**🔸 方法的作用**
```
HTTP方法 = 告诉服务器要做什么操作

生活类比：
• GET = "请给我看看"（查看商品）
• POST = "我要提交"（下订单）
• PUT = "我要更新"（修改订单）
• DELETE = "我要删除"（取消订单）
```

### 3.2 GET方法 - 获取资源


**🔸 GET方法详解**
```
用途：从服务器获取资源（网页、图片、数据等）

特点：
• 安全性：不会修改服务器数据
• 幂等性：多次请求结果相同
• 可缓存：浏览器可以缓存结果
• 参数显示：参数在URL中可见

适用场景：
✅ 浏览网页
✅ 搜索查询
✅ 获取用户信息
✅ 下载文件
```

**💻 GET请求示例**
```
请求格式：
GET /search?q=http协议&type=tutorial HTTP/1.1
Host: www.example.com

URL解析：
• /search = 访问的路径
• ? = 参数开始标志
• q=http协议 = 搜索关键词
• & = 参数分隔符
• type=tutorial = 搜索类型

服务器响应：
HTTP/1.1 200 OK
Content-Type: application/json

{"results": ["HTTP基础教程", "HTTP进阶指南"]}
```

### 3.3 POST方法 - 提交数据


**🔸 POST方法详解**
```
用途：向服务器提交数据

特点：
• 数据安全：参数在请求体中，不在URL显示
• 数据量大：可以传输大量数据
• 不可缓存：每次都是新的请求
• 副作用：会修改服务器状态

适用场景：
✅ 用户登录
✅ 提交表单
✅ 上传文件
✅ 创建新资源
```

**💻 POST请求示例**
```
登录表单提交：
POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

username=admin&password=123456

文件上传：
POST /upload HTTP/1.1
Host: www.example.com
Content-Type: multipart/form-data
Content-Length: 12345

[文件二进制数据...]
```

### 3.4 PUT方法 - 更新资源


**🔸 PUT方法详解**
```
用途：更新或创建资源

特点：
• 幂等性：多次执行结果相同
• 完整更新：通常替换整个资源
• 指定位置：明确指定资源位置

适用场景：
✅ 更新用户资料
✅ 修改文章内容
✅ 替换配置文件
```

**💻 PUT请求示例**
```
更新用户信息：
PUT /users/123 HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25
}
```

### 3.5 DELETE方法 - 删除资源


**🔸 DELETE方法详解**
```
用途：删除指定资源

特点：
• 幂等性：多次删除结果相同
• 不可逆：删除操作通常不可恢复
• 明确目标：精确指定要删除的资源

适用场景：
✅ 删除文章
✅ 移除用户
✅ 清空购物车
```

**💻 DELETE请求示例**
```
删除文章：
DELETE /articles/456 HTTP/1.1
Host: api.example.com

服务器响应：
HTTP/1.1 204 No Content
```

### 3.6 方法对比总结


| 方法 | **用途** | **数据位置** | **安全性** | **幂等性** | **缓存** |
|------|---------|-------------|-----------|-----------|---------|
| **GET** | `获取资源` | `URL参数` | `安全` | `幂等` | `可缓存` |
| **POST** | `提交数据` | `请求体` | `不安全` | `非幂等` | `不缓存` |
| **PUT** | `更新资源` | `请求体` | `不安全` | `幂等` | `不缓存` |
| **DELETE** | `删除资源` | `URL路径` | `不安全` | `幂等` | `不缓存` |

---

## 4. 📊 HTTP状态码详解


### 4.1 状态码的作用


**🔸 什么是状态码**
```
状态码 = 服务器告诉客户端处理结果

生活类比：
• 200 = "好的，给你内容"
• 404 = "抱歉，找不到"
• 500 = "服务器出故障了"
• 301 = "东西搬家了，新地址是..."
```

### 4.2 状态码分类体系


**📋 五大类别**
```
1xx - 信息响应
├── 含义：请求已收到，继续处理
├── 常见：100 Continue
└── 使用：较少遇到

2xx - 成功响应  
├── 含义：请求成功处理
├── 常见：200 OK, 201 Created
└── 使用：最常见的成功状态

3xx - 重定向
├── 含义：需要进一步操作
├── 常见：301, 302, 304
└── 使用：页面跳转、缓存控制

4xx - 客户端错误
├── 含义：客户端请求有误
├── 常见：400, 401, 403, 404
└── 使用：用户操作错误

5xx - 服务器错误
├── 含义：服务器处理失败
├── 常见：500, 502, 503
└── 使用：服务器故障
```

### 4.3 重要状态码详解


**✅ 200 OK - 请求成功**
```
含义：一切正常，服务器成功处理请求

使用场景：
• 成功获取网页
• API调用成功
• 文件下载成功

示例：
GET /index.html HTTP/1.1
→ HTTP/1.1 200 OK
  Content-Type: text/html
  [网页内容...]
```

**🔄 301 Moved Permanently - 永久重定向**
```
含义：资源永久性移动到新位置

使用场景：
• 网站改版，URL结构变化
• 域名更换
• HTTP转HTTPS

示例：
GET /old-page.html HTTP/1.1
→ HTTP/1.1 301 Moved Permanently
  Location: /new-page.html

浏览器自动跳转到新地址
```

**🔄 302 Found - 临时重定向**
```
含义：资源临时移动到新位置

使用场景：
• 临时维护页面
• 用户登录跳转
• 短网址服务

示例：
GET /admin HTTP/1.1
→ HTTP/1.1 302 Found
  Location: /login

跳转到登录页面
```

**📦 304 Not Modified - 未修改**
```
含义：资源未修改，使用缓存版本

使用场景：
• 浏览器缓存优化
• 减少网络传输
• 提高加载速度

示例：
GET /style.css HTTP/1.1
If-Modified-Since: Mon, 01 Jan 2024 00:00:00 GMT
→ HTTP/1.1 304 Not Modified

浏览器使用本地缓存的CSS文件
```

**❌ 400 Bad Request - 请求错误**
```
含义：客户端请求语法错误

常见原因：
• 请求参数格式错误
• JSON格式不正确
• 缺少必需参数

示例：
POST /api/user HTTP/1.1
Content-Type: application/json
{invalid json}
→ HTTP/1.1 400 Bad Request
```

**🔒 401 Unauthorized - 未授权**
```
含义：需要身份认证

使用场景：
• 访问需要登录的页面
• API调用缺少token
• 用户凭证无效

示例：
GET /profile HTTP/1.1
→ HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Bearer

需要提供有效的认证信息
```

**🚫 403 Forbidden - 禁止访问**
```
含义：服务器理解请求，但拒绝执行

使用场景：
• 权限不足
• IP被封禁
• 访问被限制的资源

示例：
GET /admin/users HTTP/1.1
Authorization: Bearer user-token
→ HTTP/1.1 403 Forbidden

普通用户无法访问管理员功能
```

**❓ 404 Not Found - 资源不存在**
```
含义：服务器找不到请求的资源

使用场景：
• 网页不存在
• 文件被删除
• URL输入错误

示例：
GET /non-existent-page.html HTTP/1.1
→ HTTP/1.1 404 Not Found
  Content-Type: text/html
  
  <h1>页面未找到</h1>
```

**💥 500 Internal Server Error - 服务器内部错误**
```
含义：服务器遇到意外情况，无法完成请求

常见原因：
• 程序代码错误
• 数据库连接失败
• 服务器配置问题

示例：
GET /api/data HTTP/1.1
→ HTTP/1.1 500 Internal Server Error
  Content-Type: text/html
  
  <h1>服务器错误</h1>
```

**🚪 502 Bad Gateway - 网关错误**
```
含义：作为网关的服务器收到无效响应

使用场景：
• 反向代理服务器问题
• 上游服务器故障
• 负载均衡器异常

示例：
Nginx代理服务器无法连接到后端应用服务器
→ HTTP/1.1 502 Bad Gateway
```

**🔧 503 Service Unavailable - 服务不可用**
```
含义：服务器暂时无法处理请求

使用场景：
• 服务器维护
• 流量过大
• 资源耗尽

示例：
GET /api/data HTTP/1.1
→ HTTP/1.1 503 Service Unavailable
  Retry-After: 3600
  
服务器建议1小时后重试
```

---

## 5. 📄 HTTP消息格式结构


### 5.1 HTTP消息基本结构


**🔸 消息组成**
```
HTTP消息结构：

┌─────────────────┐
│   起始行        │ ← 请求行或状态行
├─────────────────┤
│   消息头        │ ← 各种头部字段
│   (Headers)     │   
├─────────────────┤
│   空行          │ ← 必须有的分隔符
├─────────────────┤
│   消息体        │ ← 实际传输的数据
│   (Body)        │   (可选)
└─────────────────┘
```

### 5.2 HTTP请求消息格式


**📝 请求消息结构**
```
请求行：     GET /index.html HTTP/1.1
请求头：     Host: www.example.com
            User-Agent: Chrome/91.0
            Accept: text/html
            
空行：       (必须有)

请求体：     username=admin&password=123
            (GET请求通常无请求体)
```

**🔸 请求行详解**
```
格式：[方法] [URI] [版本]

示例：GET /search?q=http HTTP/1.1
├── GET          = HTTP方法
├── /search?q=http = 请求的资源路径和参数  
└── HTTP/1.1     = 协议版本
```

### 5.3 HTTP响应消息格式


**📝 响应消息结构**
```
状态行：     HTTP/1.1 200 OK
响应头：     Content-Type: text/html
            Content-Length: 1234
            Set-Cookie: session=abc123
            
空行：       (必须有)

响应体：     <html>
            <body><h1>Hello World</h1></body>
            </html>
```

**🔸 状态行详解**
```
格式：[版本] [状态码] [状态短语]

示例：HTTP/1.1 404 Not Found
├── HTTP/1.1    = 协议版本
├── 404         = 数字状态码
└── Not Found   = 状态描述
```

### 5.4 消息体类型


**📦 常见内容类型**
```
HTML网页：
Content-Type: text/html
<html><body>网页内容</body></html>

JSON数据：
Content-Type: application/json
{"name": "张三", "age": 25}

表单数据：
Content-Type: application/x-www-form-urlencoded
username=admin&password=123456

文件上传：
Content-Type: multipart/form-data
[二进制文件数据...]

纯文本：
Content-Type: text/plain
普通文本内容
```

---

## 6. 📋 请求头与响应头


### 6.1 什么是HTTP头部


**🔸 头部的作用**
```
HTTP头部 = 传递额外信息的标签

生活类比：
就像寄包裹时贴的标签：
• 收件人地址 → Host头部
• 寄件人信息 → User-Agent头部  
• 包裹重量 → Content-Length头部
• 内容类型 → Content-Type头部
```

### 6.2 重要请求头详解


**🌐 Host - 目标主机**
```
作用：指定请求的目标服务器

必需性：HTTP/1.1中必须提供
格式：Host: 域名[:端口]

示例：
Host: www.example.com
Host: api.example.com:8080

为什么需要：
一台服务器可以托管多个网站，
需要Host头来区分访问哪个网站
```

**🔍 User-Agent - 用户代理**
```
作用：标识客户端信息（浏览器、操作系统等）

用途：
• 服务器统计访问来源
• 提供针对性的内容
• 检测移动设备

示例：
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) 
           AppleWebKit/537.36 Chrome/91.0.4472.124

解读：Windows 10系统上的Chrome浏览器
```

**📥 Accept - 可接受内容**
```
作用：告诉服务器客户端能处理的内容类型

格式：Accept: 类型/子类型, 类型/子类型

示例：
Accept: text/html,application/json,*/*

解读：
• 优先接受HTML
• 也接受JSON
• 其他类型也可以（*/*）
```

**🔒 Authorization - 身份认证**
```
作用：提供身份认证信息

常见格式：
Authorization: Basic base64编码的用户名:密码
Authorization: Bearer JWT令牌

示例：
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...

用途：访问需要登录的API接口
```

**🍪 Cookie - 状态保持**
```
作用：发送之前保存的Cookie信息

格式：Cookie: name1=value1; name2=value2

示例：
Cookie: session_id=abc123; user_pref=dark_mode

用途：
• 保持登录状态
• 记住用户偏好
• 购物车内容
```

### 6.3 重要响应头详解


**📄 Content-Type - 内容类型**
```
作用：告诉客户端响应体的数据类型

常见类型：
Content-Type: text/html; charset=UTF-8
Content-Type: application/json
Content-Type: image/jpeg
Content-Type: application/pdf

字符编码：
charset=UTF-8 指定文本编码格式
```

**📏 Content-Length - 内容长度**
```
作用：指定响应体的字节数

用途：
• 客户端知道何时接收完毕
• 显示下载进度
• 检查数据完整性

示例：
Content-Length: 1234

表示响应体有1234个字节
```

**🍪 Set-Cookie - 设置Cookie**
```
作用：在客户端设置Cookie

格式：Set-Cookie: name=value; 属性

示例：
Set-Cookie: session_id=abc123; Path=/; HttpOnly
Set-Cookie: user_theme=dark; Max-Age=86400

属性说明：
• Path=/: Cookie的有效路径
• HttpOnly: 只能通过HTTP访问，不能用JavaScript
• Max-Age=86400: 有效期24小时
```

**📍 Location - 重定向地址**
```
作用：配合3xx状态码指定重定向目标

使用场景：
• 301/302重定向
• 登录成功后跳转
• 短网址展开

示例：
HTTP/1.1 302 Found
Location: https://www.new-site.com/page

浏览器会自动跳转到新地址
```

**📦 Cache-Control - 缓存控制**
```
作用：控制缓存行为

常见指令：
Cache-Control: no-cache          # 不使用缓存
Cache-Control: max-age=3600      # 缓存1小时
Cache-Control: public            # 公共缓存
Cache-Control: private           # 私有缓存

组合使用：
Cache-Control: public, max-age=86400
表示公共缓存，有效期24小时
```

### 6.4 自定义头部


**🔧 自定义头部规范**
```
命名规则：
• 以X-开头（传统方式）
• 使用短横线分隔单词
• 大小写不敏感

示例：
X-API-Version: 2.0
X-Request-ID: 123456789
X-Custom-Header: custom-value

用途：
• API版本控制
• 请求追踪
• 自定义功能
```

---

## 7. 🚀 HTTP版本对比


### 7.1 HTTP发展历程


**📈 版本演进**
```
HTTP/0.9 (1991年)
├── 功能：只支持GET方法
├── 特点：极其简单
└── 现状：已废弃

HTTP/1.0 (1996年)
├── 功能：支持多种方法和头部
├── 特点：每次请求建立新连接
└── 问题：连接开销大

HTTP/1.1 (1997年)
├── 功能：持久连接、管道化
├── 特点：目前主流版本
└── 应用：绝大多数网站

HTTP/2 (2015年)
├── 功能：多路复用、二进制协议
├── 特点：性能大幅提升
└── 应用：逐步普及中

HTTP/3 (2020年)
├── 功能：基于QUIC协议
├── 特点：更低延迟
└── 应用：开始部署
```

### 7.2 HTTP/1.1 特性详解


**🔸 HTTP/1.1 核心改进**
```
✅ 持久连接 (Keep-Alive)
问题：HTTP/1.0每次请求都要建立新连接
解决：一个TCP连接可以发送多个HTTP请求

示例：
HTTP/1.0:
连接 → 请求1 → 响应1 → 断开
连接 → 请求2 → 响应2 → 断开
连接 → 请求3 → 响应3 → 断开

HTTP/1.1:
连接 → 请求1 → 响应1 → 请求2 → 响应2 → 请求3 → 响应3 → 断开
```

**🔄 管道化 (Pipelining)**
```
机制：客户端可以连续发送多个请求，无需等待响应

优势：减少网络延迟
限制：响应必须按请求顺序返回

示例：
客户端：请求A → 请求B → 请求C
服务器：       响应A → 响应B → 响应C

问题：如果响应A很慢，B和C也必须等待
```

**📋 Host头部要求**
```
必需性：HTTP/1.1要求所有请求必须包含Host头

作用：支持虚拟主机（一台服务器多个网站）

示例：
GET /index.html HTTP/1.1
Host: www.site1.com    # 访问网站1

GET /index.html HTTP/1.1  
Host: www.site2.com    # 访问网站2

同一台服务器，不同网站
```

### 7.3 HTTP/2 重大改进


**🔸 HTTP/2 核心特性**
```
🚀 多路复用 (Multiplexing)
问题：HTTP/1.1的队头阻塞
解决：一个连接同时处理多个请求响应

传统方式：
连接1：请求A → 响应A
连接2：请求B → 响应B  
连接3：请求C → 响应C

HTTP/2方式：
连接1：请求A、B、C → 响应A、B、C（交错进行）
```

**📦 二进制分帧**
```
改进：将HTTP消息分解为二进制帧

优势：
• 更高效的解析
• 更好的错误处理
• 支持优先级控制

对比：
HTTP/1.1: GET /page HTTP/1.1\r\nHost: example.com\r\n\r\n
HTTP/2:   [二进制帧] [HEADERS帧] [DATA帧]
```

**🗜️ 头部压缩 (HPACK)**
```
问题：HTTP头部重复传输浪费带宽
解决：压缩头部，建立头部索引表

效果：
第一次请求：完整头部
后续请求：只传输变化部分

典型压缩比：85-95%
```

**⚡ 服务器推送**
```
机制：服务器主动推送资源到客户端

使用场景：
客户端请求：GET /index.html
服务器推送：/style.css, /script.js, /image.png

优势：减少往返次数，提前加载资源
限制：需要服务器和客户端都支持
```

### 7.4 性能对比分析


**📊 性能指标对比**

| 特性 | **HTTP/1.1** | **HTTP/2** | **提升效果** |
|------|--------------|------------|-------------|
| **连接复用** | `有限制` | `完全复用` | `减少连接开销` |
| **并发请求** | `6-8个连接` | `单连接无限制` | `大幅提升并发` |
| **头部压缩** | `无` | `HPACK压缩` | `节省85%+带宽` |
| **优先级** | `无` | `可设置优先级` | `关键资源优先` |
| **服务器推送** | `无` | `支持` | `减少延迟` |

**🔸 实际使用建议**
```
选择HTTP/1.1的情况：
✅ 老旧系统兼容性要求
✅ 简单的小型网站
✅ 服务器不支持HTTP/2

选择HTTP/2的情况：
✅ 现代Web应用
✅ 资源较多的网站
✅ 性能要求较高
✅ 移动端应用

升级注意事项：
⚠️ 需要HTTPS支持
⚠️ 服务器和CDN要支持
⚠️ 可能需要调整缓存策略
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基础概念


```
🔸 HTTP本质：浏览器与服务器的通信规则
🔸 请求响应：一问一答的交互模式  
🔸 无状态性：服务器不记住之前的请求
🔸 基于TCP：建立在可靠传输协议之上
🔸 文本协议：内容人眼可读，便于调试
```

### 8.2 核心知识记忆要点


**🔹 HTTP方法记忆**
```
GET - 获取 (Getting data)
POST - 提交 (Posting data)  
PUT - 更新 (Putting updates)
DELETE - 删除 (Deleting resources)

安全性：GET安全，其他不安全
幂等性：GET、PUT、DELETE幂等，POST非幂等
```

**🔹 状态码记忆**
```
2xx = 成功 (Success)
3xx = 重定向 (Redirect) 
4xx = 客户端错误 (Client Error)
5xx = 服务器错误 (Server Error)

常用状态码：
200 OK - 成功
301/302 - 重定向
401 - 未授权
403 - 禁止访问  
404 - 未找到
500 - 服务器错误
```

**🔹 重要头部记忆**
```
请求头：
• Host - 目标服务器
• User-Agent - 客户端信息
• Authorization - 身份认证
• Cookie - 状态信息

响应头：
• Content-Type - 内容类型
• Content-Length - 内容长度
• Set-Cookie - 设置Cookie
• Location - 重定向地址
```

### 8.3 实际应用价值


**🎯 开发实践**
- **Web开发**：理解前后端交互机制
- **API设计**：合理使用HTTP方法和状态码
- **性能优化**：利用缓存和HTTP/2特性
- **问题调试**：通过抓包分析HTTP交互

**🔧 故障排查**
- **网络问题**：通过状态码快速定位
- **缓存问题**：理解缓存头部机制
- **认证问题**：检查Authorization头部
- **跨域问题**：理解HTTP同源策略

**🚀 性能优化**
- **减少请求**：合并资源，使用HTTP/2
- **缓存策略**：合理设置Cache-Control
- **压缩传输**：启用gzip压缩
- **CDN加速**：利用HTTP缓存机制

**核心记忆口诀**：
```
HTTP协议很简单，一问一答是关键
GET获取POST提交，状态码把结果看  
头部信息很重要，版本升级性能好
无状态协议要记牢，Cookie Session来帮忙
```