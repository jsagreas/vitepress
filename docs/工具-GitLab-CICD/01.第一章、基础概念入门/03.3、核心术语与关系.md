---
title: 3、核心术语与关系
---
## 📚 目录

1. [Pipeline、Job、Stage关系](#1-pipeline-job-stage关系)
2. [Variables变量系统](#2-variables变量系统)
3. [Cache缓存机制](#3-cache缓存机制)
4. [Triggers触发器](#4-triggers触发器)
5. [Dependencies依赖关系](#5-dependencies依赖关系)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔄 Pipeline、Job、Stage关系


### 1.1 基本概念理解


> **💡 核心理解**
> 想象一下工厂流水线：Pipeline是整条生产线，Stage是每个工序车间，Job是车间里的具体工作任务

**🏭 生动类比**
```
现实中的工厂流水线：                GitLab CI/CD流水线：
    整条生产线                        Pipeline (流水线)
       ↓                                ↓
   各个工序车间                       Stage (阶段)  
       ↓                                ↓
   车间内具体工作                      Job (任务)
```

### 1.2 三者关系详解


**📊 层级关系图**
```
Pipeline (流水线)
├── Stage 1: 测试阶段
│   ├── Job: 单元测试
│   ├── Job: 集成测试
│   └── Job: 代码检查
├── Stage 2: 构建阶段
│   ├── Job: 编译代码
│   └── Job: 打包应用
└── Stage 3: 部署阶段
    ├── Job: 部署到测试环境
    └── Job: 部署到生产环境
```

**🔸 Pipeline（流水线）**
```yaml
# 一个完整的 .gitlab-ci.yml 文件就定义了一个 Pipeline
stages:
  - test
  - build  
  - deploy
```

> **🎯 简单理解**
> Pipeline就是你的整个自动化流程，从代码提交到最终部署的全过程

**🔸 Stage（阶段）**
```yaml
# Stage定义了流水线的各个阶段，按顺序执行
stages:
  - test     # 第一阶段：测试
  - build    # 第二阶段：构建
  - deploy   # 第三阶段：部署
```

> **⚠️ 重要特点**
> - Stage按照定义的顺序依次执行
> - 只有前一个Stage全部成功，才会执行下一个Stage
> - 同一个Stage内的Job可以并行执行

**🔸 Job（任务）**
```yaml
# 具体的工作任务
unit_test:          # Job名称
  stage: test       # 属于test阶段
  script:           # 具体要执行的命令
    - npm test

build_app:
  stage: build
  script:
    - npm run build
```

### 1.3 执行流程示意


**🔄 执行时序图**
```
开始 → Stage1(test) → Stage2(build) → Stage3(deploy) → 结束
         ↓              ↓               ↓
      [Job1]         [Job3]          [Job5]
      [Job2]         [Job4]          [Job6]
       并行            并行             并行
```

**📈 状态变化流程**
```
Pipeline状态变化：
创建 → 等待 → 运行中 → 成功/失败

Job状态变化：  
排队 → 等待 → 运行中 → 成功/失败/取消
```

---

## 2. 🔧 Variables变量系统


### 2.1 变量的作用和意义


> **💡 核心理解**
> Variables就像是流水线上的"标签纸"，记录着各种信息，让不同的工作任务能够获取和使用这些信息

**🏷️ 变量的实际用途**
- **环境配置**：开发、测试、生产环境的不同设置
- **敏感信息**：数据库密码、API密钥等
- **动态信息**：构建版本号、提交信息等
- **控制流程**：根据变量值决定是否执行某些任务

### 2.2 变量类型和作用域


**📊 变量类型对比**

| 变量类型 | **作用范围** | **定义位置** | **使用场景** | **优先级** |
|---------|-------------|-------------|-------------|-----------|
| 🌍 **全局变量** | `整个GitLab实例` | `管理员面板` | `全局配置` | `最低` |
| 🏢 **组变量** | `整个组下所有项目` | `组设置页面` | `团队共享配置` | `低` |
| 📁 **项目变量** | `单个项目` | `项目设置页面` | `项目特定配置` | `中` |
| 🔄 **Pipeline变量** | `单次流水线` | `Pipeline定义` | `动态传参` | `高` |
| ⚙️ **Job变量** | `单个任务` | `Job定义内` | `任务特定配置` | `最高` |

### 2.3 变量定义和使用


**🔧 在项目中定义变量**
```
项目设置路径：
项目 → Settings → CI/CD → Variables
```

**📝 在代码中定义变量**
```yaml
# 在 .gitlab-ci.yml 中定义
variables:
  APP_NAME: "my-awesome-app"
  BUILD_ENV: "production"
  
# 在Job中定义
build_job:
  variables:
    NODE_VERSION: "16"
  script:
    - echo "Building $APP_NAME"
    - echo "Node version: $NODE_VERSION"
```

**🎯 变量使用示例**
```yaml
deploy_job:
  script:
    - echo "部署应用: $APP_NAME"
    - echo "目标环境: $BUILD_ENV" 
    - docker build -t $APP_NAME:$CI_COMMIT_SHA .
```

### 2.4 预定义变量


> **📋 GitLab内置变量**
> GitLab自动提供很多有用的变量，不需要手动定义

**🔸 常用预定义变量**
```yaml
常用变量说明：
$CI_PROJECT_NAME          # 项目名称
$CI_COMMIT_SHA            # 提交的SHA值
$CI_COMMIT_BRANCH         # 分支名称
$CI_PIPELINE_ID           # 流水线ID
$CI_JOB_NAME             # 当前Job名称
$CI_ENVIRONMENT_NAME      # 环境名称
```

**💼 实际使用示例**
```yaml
build_and_tag:
  script:
    - echo "正在构建项目: $CI_PROJECT_NAME"
    - echo "提交版本: $CI_COMMIT_SHA"
    - docker build -t $CI_PROJECT_NAME:$CI_COMMIT_SHA .
```

---

## 3. 💾 Cache缓存机制


### 3.1 缓存的基本概念


> **💡 核心理解**
> Cache就像是工厂的"仓库"，把经常用到的材料存起来，下次需要时直接拿，不用重新采购，大大节省时间

**🏃‍♂️ 为什么需要缓存？**
```
没有缓存的情况：
Job1: 下载依赖(5分钟) → 编译(2分钟) 
Job2: 下载依赖(5分钟) → 测试(3分钟)
Job3: 下载依赖(5分钟) → 打包(1分钟)
总耗时：21分钟

有缓存的情况：
Job1: 下载依赖(5分钟) → 编译(2分钟) → 缓存依赖
Job2: 使用缓存(30秒) → 测试(3分钟)  
Job3: 使用缓存(30秒) → 打包(1分钟)
总耗时：12分钟，节省9分钟！
```

### 3.2 缓存的工作机制


**🔄 缓存生命周期**
```
创建缓存 → 上传存储 → 下载使用 → 更新缓存
    ↓          ↓         ↓         ↓
  第一个Job   GitLab存储   后续Job   有变化时
```

**📦 缓存配置示例**
```yaml
# 缓存Node.js依赖
build_job:
  cache:
    key: "$CI_COMMIT_REF_SLUG"    # 缓存key，通常用分支名
    paths:
      - node_modules/             # 要缓存的文件/目录
      - .npm/                     # npm缓存目录
  script:
    - npm install                 # 第一次会下载，后续使用缓存
    - npm run build
```

### 3.3 缓存策略详解


**🎯 缓存策略类型**

| 策略类型 | **说明** | **使用场景** | **配置方式** |
|---------|---------|-------------|-------------|
| 📥 **pull** | `只下载，不上传` | `只读取缓存的Job` | `policy: pull` |
| 📤 **push** | `只上传，不下载` | `构建缓存的Job` | `policy: push` |
| 🔄 **pull-push** | `既下载又上传（默认）` | `大多数场景` | `默认行为` |

**🔧 策略配置示例**
```yaml
# 构建依赖的Job - 只上传缓存
install_deps:
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - node_modules/
    policy: push                  # 只上传缓存
  script:
    - npm install

# 使用依赖的Job - 只下载缓存  
test_job:
  cache:
    key: "$CI_COMMIT_REF_SLUG" 
    paths:
      - node_modules/
    policy: pull                  # 只下载缓存
  script:
    - npm test
```

### 3.4 缓存最佳实践


> **⚠️ 常见误区**
> 不要把构建结果放入缓存！缓存是为了加速构建，不是为了传递构建产物

**✅ 适合缓存的内容**
- 📦 依赖包（node_modules、vendor等）
- 🔧 编译工具缓存
- 📚 下载的库文件

**❌ 不适合缓存的内容**  
- 🚀 构建产物（dist、build目录）
- 🔐 敏感信息
- 📄 日志文件

---

## 4. 🎯 Triggers触发器


### 4.1 触发器基本概念


> **💡 核心理解**
> Triggers就像是流水线的"启动开关"，不同的事件可以触发不同的自动化流程

**🔘 触发器的作用**
```
手动触发 vs 自动触发：

手动方式：
开发者 → 手动点击 → 执行Pipeline

自动触发：
代码推送 → 自动检测 → 执行Pipeline
定时任务 → 到达时间 → 执行Pipeline  
外部API → 发送请求 → 执行Pipeline
```

### 4.2 触发器类型详解


**📊 触发器类型总览**

| 触发类型 | **触发条件** | **使用场景** | **配置方式** |
|---------|-------------|-------------|-------------|
| 🔄 **Push触发** | `代码推送到仓库` | `代码变更自动测试` | `默认开启` |
| 🔀 **MR触发** | `创建/更新合并请求` | `代码审查前测试` | `merge_requests` |
| 🏷️ **Tag触发** | `创建Git标签` | `版本发布` | `tags` |
| ⏰ **定时触发** | `按计划执行` | `定期构建/清理` | `schedules` |
| 🌐 **API触发** | `外部系统调用` | `集成其他系统` | `trigger tokens` |

### 4.3 触发条件配置


**🔧 代码推送触发**
```yaml
# 只在特定分支触发
deploy_production:
  script:
    - echo "部署到生产环境"
  only:
    - main                        # 只在main分支触发
    - /^release-.*$/             # 匹配release-开头的分支

# 排除特定分支
test_job:
  script:
    - npm test
  except:
    - develop                     # 除了develop分支都触发
```

**🔀 合并请求触发**
```yaml
# 针对MR的特殊处理
mr_validation:
  script:
    - echo "验证合并请求"
  only:
    - merge_requests             # 只在MR时触发
```

**🏷️ 标签触发配置**
```yaml
# 版本发布触发
release_job:
  script:
    - echo "发布版本 $CI_COMMIT_TAG"
  only:
    - tags                       # 只在创建tag时触发
```

### 4.4 高级触发配置


**🎛️ 规则配置（Rules）**
```yaml
# 使用rules替代only/except（推荐）
deploy_job:
  script:
    - echo "智能部署"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'              # main分支
    - if: '$CI_COMMIT_TAG'                           # 有tag
    - if: '$CI_MERGE_REQUEST_ID'                     # MR状态
      when: manual                                   # 手动触发
```

**⏰ 定时触发设置**
```
设置路径：
项目 → CI/CD → Schedules → New schedule

配置示例：
- 描述：每日构建
- 间隔：0 2 * * *（每天凌晨2点）
- 分支：main
- 变量：SCHEDULE_TYPE=daily
```

---

## 5. 🔗 Dependencies依赖关系


### 5.1 依赖关系基本概念


> **💡 核心理解**
> Dependencies就像是流水线上的"接力棒"，前面的工作完成后，把结果传递给后面的工作

**🏃‍♂️ 为什么需要依赖？**
```
没有依赖管理：
Job1: 编译代码 → 产生build.jar
Job2: 运行测试 → 找不到build.jar ❌

有依赖管理：
Job1: 编译代码 → 产生build.jar → 保存artifact  
Job2: 运行测试 → 下载artifact → 获得build.jar ✅
```

### 5.2 依赖类型详解


**📊 依赖关系类型**

| 依赖类型 | **说明** | **使用场景** | **配置关键字** |
|---------|---------|-------------|---------------|
| 🔄 **Artifacts依赖** | `传递构建产物` | `构建→测试→部署` | `artifacts` |
| ⏭️ **Job依赖** | `控制执行顺序` | `必须等待前置任务` | `needs` |
| 📦 **Image依赖** | `指定运行环境` | `统一运行环境` | `image` |
| 🔧 **Service依赖** | `提供辅助服务` | `数据库、缓存等` | `services` |

### 5.3 Artifacts文件传递


**📦 构建产物传递示例**
```yaml
# 第一步：构建并保存产物
build_job:
  stage: build
  script:
    - npm run build              # 构建应用
    - ls -la dist/              # 查看构建结果
  artifacts:
    paths:
      - dist/                   # 保存dist目录
    expire_in: 1 hour          # 1小时后过期
    
# 第二步：使用构建产物进行测试
test_job:
  stage: test
  dependencies:
    - build_job                 # 依赖build_job的产物
  script:
    - ls -la dist/             # 可以访问dist目录
    - npm run test
    
# 第三步：部署构建产物
deploy_job:
  stage: deploy
  dependencies:
    - build_job                # 也依赖build_job的产物
  script:
    - scp dist/* server:/app/  # 部署到服务器
```

### 5.4 Job执行顺序控制


**⏭️ needs关键字使用**
```yaml
# 传统方式：按Stage顺序执行
stages:
  - build
  - test  
  - deploy

# 优化方式：使用needs并行执行
unit_test:
  stage: test
  needs: ["build_job"]         # 只需要等build_job完成
  script:
    - npm run unit-test

integration_test:  
  stage: test
  needs: ["build_job"]         # 可以与unit_test并行
  script:
    - npm run integration-test

deploy_staging:
  stage: deploy
  needs: 
    - unit_test                # 需要两个测试都完成
    - integration_test
  script:
    - deploy_to_staging.sh
```

**🚀 性能对比**
```
传统Stage方式：
Build(5分钟) → Test1(3分钟) + Test2(4分钟) → Deploy(2分钟)
总耗时：14分钟

使用needs优化：
Build(5分钟) → Test1(3分钟) 并行 Test2(4分钟) → Deploy(2分钟) 
总耗时：11分钟，节省3分钟！
```

### 5.5 运行环境依赖


**🐳 Docker镜像依赖**
```yaml
# 统一运行环境
variables:
  NODE_IMAGE: "node:16-alpine"

test_job:
  image: $NODE_IMAGE           # 使用Node.js环境
  script:
    - node --version
    - npm test

build_job:
  image: $NODE_IMAGE           # 使用相同环境
  script:
    - npm run build
```

**🔧 服务依赖配置**
```yaml
# 需要数据库的测试
integration_test:
  image: node:16
  services:
    - postgres:13              # 启动PostgreSQL服务
    - redis:6                  # 启动Redis服务
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: test
    POSTGRES_PASSWORD: password
  script:
    - npm run integration-test # 可以连接数据库和Redis
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 Pipeline：整个自动化流程，一次代码提交触发一个Pipeline
🔸 Stage：流水线的阶段，按顺序执行，同一阶段内Job可并行
🔸 Job：具体的工作任务，是执行的最小单位
🔸 Variables：配置信息的载体，支持多层级作用域
🔸 Cache：加速构建的利器，缓存依赖和工具
🔸 Triggers：启动流水线的各种方式和条件
🔸 Dependencies：Job间的依赖关系，控制执行顺序和数据传递
```

### 6.2 关键理解要点


**🔹 层次关系记忆**
```
Pipeline包含多个Stage
Stage包含多个Job  
Job执行具体任务
```

**🔹 变量优先级记忆**
```
Job变量 > Pipeline变量 > 项目变量 > 组变量 > 全局变量
（越具体优先级越高）
```

**🔹 缓存vs Artifacts记忆**
```
Cache：加速构建，存依赖包（node_modules）
Artifacts：传递结果，存构建产物（dist）
```

**🔹 触发器选择原则**
```
代码变更：Push触发
代码审查：MR触发  
版本发布：Tag触发
定期任务：Schedule触发
外部集成：API触发
```

### 6.3 实际应用价值


**🎯 典型工作流程**
- **提交代码** → 自动触发Pipeline
- **测试阶段** → 并行执行多个测试Job
- **构建阶段** → 编译代码，缓存依赖
- **部署阶段** → 使用构建产物部署到环境

**🔧 最佳实践建议**
- 合理设置缓存，减少重复下载
- 使用needs优化Job执行顺序
- 敏感信息用项目变量存储
- 构建产物用artifacts传递
- 根据分支设置不同的触发策略

**核心记忆口诀**：
- Pipeline是全流程，Stage按序执行
- Job是最小单位，Cache加速构建  
- Variables存配置，Triggers定时机
- Dependencies传递，Artifacts是结果

> **🎓 学习建议**
> 理解了这些核心概念，就掌握了GitLab CI/CD的精髓。建议多动手实践，从简单的Pipeline开始，逐步加入更多特性。