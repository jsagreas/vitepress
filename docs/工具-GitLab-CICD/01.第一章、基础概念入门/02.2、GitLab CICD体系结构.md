---
title: 2、GitLab CICD体系结构
---
## 📚 目录

1. [什么是GitLab CI/CD](#1-什么是gitlab-cicd)
2. [GitLab CI/CD架构组成](#2-gitlab-cicd架构组成)
3. [Pipeline管道概念](#3-pipeline管道概念)
4. [Job任务概念](#4-job任务概念)
5. [Stage阶段概念](#5-stage阶段概念)
6. [Runner执行器概念](#6-runner执行器概念)
7. [Artifacts制品概念](#7-artifacts制品概念)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 什么是GitLab CI/CD


### 1.1 CI/CD的本质含义


**🔸 CI（持续集成 - Continuous Integration）**
```
简单理解：就像团队写作业
- 每个人写自己的部分
- 定期把大家的部分合并到一起
- 自动检查合并后有没有问题
- 发现问题立即修复
```

**🔸 CD（持续部署 - Continuous Deployment）**
```
简单理解：就像自动发布系统
- 代码写好后自动打包
- 自动部署到测试环境
- 测试通过后自动部署到正式环境
- 整个过程无需人工干预
```

### 1.2 GitLab CI/CD的价值


**传统开发方式的痛点：**
```
手工流程繁琐：
开发完成 → 手动编译 → 手动测试 → 手动部署
    ↓
容易出错、效率低下、重复劳动

GitLab CI/CD解决方案：
代码提交 → 自动编译 → 自动测试 → 自动部署
    ↓
高效、可靠、可重复
```

> 💡 **生活类比**：GitLab CI/CD就像是一个智能工厂的生产线，原料（代码）进去，成品（应用）自动出来

---

## 2. 🏗️ GitLab CI/CD架构组成


### 2.1 整体架构图示


```
GitLab CI/CD 完整架构：

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   GitLab Server │    │    GitLab       │    │     目标        │
│                 │    │    Runner       │    │     环境        │
│  📁 代码仓库     │    │                 │    │                 │
│  🛠️  Pipeline    │◄──►│  🏃 执行器      │───►│  🌐 生产环境     │
│  📋 .gitlab-ci   │    │  🔧 构建工具    │    │  🧪 测试环境     │
│  📊 监控界面     │    │  📦 Docker      │    │  🚀 部署目标     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 核心组件详解


| 组件 | **作用** | **通俗解释** | **实际例子** |
|------|---------|-------------|-------------|
| 🏢 **GitLab Server** | `总指挥部` | `就像公司总部，负责规划和协调` | `存储代码，定义Pipeline规则` |
| 🏃 **GitLab Runner** | `执行工人` | `就像工厂工人，具体干活的` | `编译代码，运行测试，执行部署` |
| 📋 **.gitlab-ci.yml** | `作业指导书` | `详细的操作步骤说明` | `定义什么时候做什么事` |
| 🌐 **目标环境** | `交付地点` | `最终产品要送达的地方` | `测试服务器，生产服务器` |

**🔸 工作流程简述：**
1. **开发者** 提交代码到 GitLab
2. **GitLab Server** 根据 `.gitlab-ci.yml` 创建 Pipeline
3. **GitLab Runner** 接收任务并执行
4. **执行结果** 反馈给 GitLab Server
5. **成功后** 自动部署到目标环境

---

## 3. 🔄 Pipeline管道概念


### 3.1 Pipeline的本质


**💡 Pipeline就像工厂的生产线**
```
汽车生产线类比：
原材料 → 车架组装 → 发动机安装 → 喷漆 → 质检 → 成品

代码Pipeline：
源代码 → 编译构建 → 单元测试 → 集成测试 → 部署 → 完成
```

### 3.2 Pipeline的生命周期


**🔸 Pipeline状态流转：**
```
Pipeline状态变化过程：

pending（等待中）
    ↓
running（运行中）
    ↓
┌─ success（成功）
└─ failed（失败）
    ↓
manual（手动干预）
```

### 3.3 Pipeline触发方式


| 触发方式 | **何时触发** | **使用场景** | **实际例子** |
|---------|-------------|-------------|-------------|
| 🔄 **Push触发** | `代码推送时` | `最常用的方式` | `git push后自动开始` |
| 🔀 **MR触发** | `合并请求时` | `代码审查前测试` | `提交MR时自动测试` |
| ⏰ **定时触发** | `按时间计划` | `夜间构建` | `每天凌晨2点构建` |
| 👆 **手动触发** | `人工点击` | `特殊情况部署` | `紧急发布时手动执行` |

**🔸 实际配置示例：**
```yaml
# 最基础的Pipeline配置
stages:
  - build      # 构建阶段
  - test       # 测试阶段  
  - deploy     # 部署阶段

build_job:
  stage: build
  script:
    - echo "正在构建应用..."
    - npm install
    - npm run build
```

---

## 4. ⚙️ Job任务概念


### 4.1 Job的本质理解


**🔸 Job是Pipeline中的具体工作**
```
把Pipeline比作菜谱，Job就是具体步骤：

菜谱：红烧肉制作流程
- Job1: 准备食材（洗肉、切块）
- Job2: 炒糖色（糖色制作）  
- Job3: 炖煮（加调料炖煮）
- Job4: 收汁（大火收汁）

Pipeline：应用发布流程
- Job1: 代码检查（语法检查、代码规范）
- Job2: 编译构建（打包应用）
- Job3: 自动测试（运行测试用例）  
- Job4: 环境部署（发布到服务器）
```

### 4.2 Job的配置结构


**📋 Job配置要素：**
```yaml
job_name:                    # Job名称
  stage: test               # 属于哪个阶段
  image: node:16            # 运行环境
  script:                   # 具体要执行的命令
    - npm install
    - npm test
  only:                     # 什么时候运行
    - main
  except:                   # 什么时候不运行  
    - tags
```

### 4.3 Job的执行特点


**⭐ Job执行规则：**
- **并行执行**：同一Stage内的Job可以同时运行
- **顺序依赖**：不同Stage按顺序执行
- **失败停止**：任何Job失败，整个Pipeline停止
- **独立环境**：每个Job在独立的环境中运行

> ⚠️ **重要提醒**：Job之间默认不共享文件，需要通过Artifacts传递

---

## 5. 📊 Stage阶段概念


### 5.1 Stage的分层思想


**🔸 Stage就像楼房的楼层**
```
软件开发大楼：

🏢 4楼 - deploy (部署层)    ← 把应用发布到服务器
🏢 3楼 - test (测试层)      ← 验证功能是否正常
🏢 2楼 - build (构建层)     ← 编译打包应用
🏢 1楼 - prepare (准备层)   ← 环境准备、依赖安装

特点：必须一层层往上走，下层完成才能进入上层
```

### 5.2 常见Stage设计模式


**🎯 标准Stage模板：**
```yaml
stages:
  - prepare     # 🔧 准备阶段：环境设置、依赖下载
  - build       # 🏗️  构建阶段：代码编译、打包
  - test        # 🧪 测试阶段：单元测试、集成测试
  - security    # 🛡️  安全阶段：安全扫描、漏洞检查
  - deploy-dev  # 🚀 开发部署：部署到开发环境
  - deploy-prod # 🌟 生产部署：部署到生产环境
```

### 5.3 Stage设计最佳实践


| Stage设计原则 | **说明** | **好处** | **避免问题** |
|--------------|---------|---------|-------------|
| 🔸 **快速反馈** | `把容易失败的放前面` | `早发现问题，节省时间` | `避免长时间等待才发现错误` |
| 🔸 **逻辑分层** | `相同类型任务放同一层` | `便于理解和维护` | `避免职责混乱` |
| 🔸 **并行优化** | `无依赖关系的任务并行` | `提高执行效率` | `避免不必要的等待` |
| 🔸 **安全检查** | `部署前必须通过所有检查` | `保证质量` | `避免问题代码上线` |

---

## 6. 🏃 Runner执行器概念


### 6.1 Runner的角色定位


**🔸 Runner就像餐厅的厨师**
```
餐厅运营类比：

客人下单（代码提交）
    ↓
服务员接单（GitLab Server接收）
    ↓  
传给厨房（分配给Runner）
    ↓
厨师做菜（Runner执行Job）
    ↓
上菜给客人（返回执行结果）

厨师类型：
- 专职厨师（Specific Runner）：只为特定项目服务
- 共享厨师（Shared Runner）：为所有项目服务  
- 外包厨师（Group Runner）：为特定团队服务
```

### 6.2 Runner类型对比


| Runner类型 | **使用范围** | **配置难度** | **适用场景** | **成本** |
|-----------|-------------|-------------|-------------|---------|
| 🌍 **Shared Runner** | `整个GitLab实例` | `⭐ 简单` | `小项目，快速开始` | `共享成本` |
| 👥 **Group Runner** | `特定用户组` | `⭐⭐ 中等` | `团队项目` | `团队分摊` |
| 🎯 **Specific Runner** | `单个项目` | `⭐⭐⭐ 复杂` | `特殊需求，高安全性` | `独立承担` |

### 6.3 Runner的工作原理


**🔸 Runner工作流程：**
```
Runner工作循环：

1. 向GitLab注册自己
    ↓
2. 定期询问有没有新任务
    ↓
3. 接收到任务后开始执行
    ↓
4. 执行过程中实时汇报进度
    ↓
5. 完成后上传结果和日志
    ↓
6. 回到第2步继续等待新任务
```

**🔧 Runner安装示例：**
```bash
# 1. 下载Runner
curl -LJO https://gitlab-runner-downloads.s3.amazonaws.com/latest/rpm/gitlab-runner_amd64.rpm

# 2. 安装Runner
rpm -i gitlab-runner_amd64.rpm

# 3. 注册Runner
gitlab-runner register
```

---

## 7. 📦 Artifacts制品概念


### 7.1 Artifacts的作用


**🔸 Artifacts就像接力赛的接力棒**
```
接力赛类比：

第1棒跑完 → 把棒子交给第2棒 → 第2棒继续跑
第2棒跑完 → 把棒子交给第3棒 → 第3棒继续跑

CI/CD流程：

编译Job → 生成可执行文件 → 测试Job使用文件测试
测试Job → 生成测试报告 → 部署Job获取报告和文件
部署Job → 下载所需文件 → 部署到目标环境
```

### 7.2 Artifacts的类型


**📋 常见Artifacts类型：**

| 类型 | **用途** | **生命周期** | **实际例子** |
|------|---------|-------------|-------------|
| 🏗️ **构建产物** | `供后续阶段使用` | `Pipeline内` | `编译后的jar包，静态网站文件` |
| 📊 **测试报告** | `查看测试结果` | `长期保存` | `覆盖率报告，性能测试结果` |
| 📋 **日志文件** | `问题排查` | `短期保存` | `构建日志，错误信息` |
| 🔍 **分析结果** | `代码质量检查` | `长期保存` | `代码扫描报告，安全检查结果` |

### 7.3 Artifacts配置方法


**🔧 基础配置示例：**
```yaml
build_job:
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - dist/          # 保存构建结果
    expire_in: 1 week  # 1周后自动删除
    
test_job:
  stage: test  
  script:
    - npm test
  artifacts:
    reports:
      junit: test-results.xml    # 测试报告
    when: always                 # 无论成功失败都保存
```

### 7.4 Artifacts使用技巧


**💡 最佳实践：**

🟢 **推荐做法：**
- 只保存必要的文件，控制存储成本
- 设置合理的过期时间
- 使用压缩减少传输时间
- 为测试报告设置专门的格式

🚫 **避免做法：**
- 不要保存源代码（浪费空间）
- 不要保存敏感信息（安全风险）
- 不要设置过长的保存时间
- 不要保存过大的文件

> ⚠️ **注意事项**：Artifacts会占用存储空间，需要定期清理

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🎯 GitLab CI/CD = 自动化的软件工厂
🔄 Pipeline = 生产线，定义整体流程
⚙️ Job = 具体工作，执行特定任务  
📊 Stage = 阶段分层，控制执行顺序
🏃 Runner = 执行工人，实际干活的
📦 Artifacts = 接力棒，传递中间结果
```

### 8.2 关键理解要点


**🔹 从宏观到微观的层次关系：**
```
Pipeline（整条生产线）
    ↓
Stage（生产线的各个阶段）  
    ↓
Job（每个阶段的具体工作）
    ↓
Script（工作的具体步骤）
```

**🔹 数据流转关系：**
```
代码仓库 → GitLab Server → Runner → 目标环境
               ↑                ↓
         .gitlab-ci.yml    Artifacts制品
```

### 8.3 学习路径建议


**📚 建议学习顺序：**
1. **理解概念**：先搞清楚每个概念是什么
2. **动手实践**：创建简单的Pipeline
3. **逐步复杂**：添加更多Stage和Job
4. **优化配置**：学习高级特性和最佳实践

**🔍 学习检查清单：**
- [ ] 能解释什么是CI/CD
- [ ] 理解Pipeline、Stage、Job的关系
- [ ] 知道Runner的作用和类型
- [ ] 会配置基础的.gitlab-ci.yml
- [ ] 理解Artifacts的用途

### 8.4 实际应用价值


**🚀 掌握GitLab CI/CD后你能做什么：**
- **提高效率**：自动化重复性工作
- **减少错误**：标准化的构建和部署流程
- **快速反馈**：及时发现代码问题
- **协作提升**：团队开发更加顺畅
- **质量保证**：自动化测试保证代码质量

**🧠 核心记忆口诀：**
```
Pipeline管道分阶段，Stage层级有顺序
Job任务并行跑，Runner工人来执行  
Artifacts传制品，整体流程自动化
```

**💭 深入思考：**
- 如果你的项目没有CI/CD，手工发布会遇到什么问题？
- 一个完整的Pipeline应该包含哪些必要的Stage？
- 如何根据项目特点选择合适的Runner类型？

> 🎯 **学习建议**：理论学习后，建议立即创建一个简单的项目实践这些概念，在实践中加深理解。