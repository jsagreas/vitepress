---
title: 2、多项目Pipeline
---
## 📚 目录

1. [多项目Pipeline基础概念](#1-多项目Pipeline基础概念)
2. [跨项目触发配置](#2-跨项目触发配置)
3. [父子Pipeline设计](#3-父子Pipeline设计)
4. [Upstream与Downstream关系](#4-Upstream与Downstream关系)
5. [项目依赖管理](#5-项目依赖管理)
6. [复杂工作流设计](#6-复杂工作流设计)
7. [项目间制品共享](#7-项目间制品共享)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔗 多项目Pipeline基础概念


### 1.1 什么是多项目Pipeline

**简单理解**：就像搭积木一样，把多个项目的构建过程连接起来

```
单项目Pipeline：                多项目Pipeline：
项目A：代码 → 构建 → 测试 → 部署    项目A → 触发 → 项目B → 触发 → 项目C
                                ↓         ↓         ↓
                              前端      API      数据库
```

**核心作用**：
- **协调多个项目**：让不同项目按顺序或并行执行
- **依赖管理**：前端项目等API项目完成后再部署
- **资源共享**：多个项目共用构建结果或配置
- **统一控制**：一个地方管理整个系统的发布流程

### 1.2 为什么需要多项目Pipeline


**实际场景举例**：
```
电商系统发布场景：
1. 先部署数据库更新脚本
2. 再部署后端API服务
3. 然后部署前端页面
4. 最后部署移动APP

如果某个环节失败：
- 后续环节自动停止
- 避免系统不一致
- 统一回滚机制
```

> 💡 **通俗理解**  
> 就像装修房子，必须先做水电，再刷墙，最后装家具。每个环节都有专门的工人（项目），但需要统一协调（多项目Pipeline）

### 1.3 多项目Pipeline的类型


**🔸 触发类型分类**：
- **手动触发**：人工点击按钮启动
- **自动触发**：代码提交时自动启动
- **定时触发**：按计划时间启动
- **条件触发**：满足特定条件时启动

**🔸 关系类型分类**：
- **串行关系**：A完成→B开始→C开始
- **并行关系**：A、B、C同时开始
- **混合关系**：部分串行，部分并行

---

## 2. ⚡ 跨项目触发配置


### 2.1 基础触发配置


**核心概念**：一个项目的Pipeline完成后，自动启动另一个项目的Pipeline

```yaml
# 项目A的 .gitlab-ci.yml
stages:
  - build
  - deploy
  - trigger_downstream

# 构建阶段
build_job:
  stage: build
  script:
    - echo "构建项目A"
    - npm run build

# 触发下游项目
trigger_project_b:
  stage: trigger_downstream
  trigger:
    project: group/project-b  # 目标项目路径
    branch: main              # 目标分支
  variables:
    TRIGGERED_BY: "project-a"
    BUILD_VERSION: $CI_PIPELINE_ID
```

**配置要点说明**：
- `project`：被触发项目的完整路径
- `branch`：触发目标项目的哪个分支
- `variables`：传递给目标项目的变量

### 2.2 条件触发配置


```yaml
# 只在main分支触发
trigger_production:
  trigger:
    project: group/production-deployment
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success

# 只在测试通过后触发
trigger_integration_test:
  trigger:
    project: group/integration-tests
  dependencies:
    - unit_tests
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
      when: on_success
```

### 2.3 多目标触发


```yaml
# 同时触发多个项目
trigger_multiple:
  stage: trigger
  parallel:
    matrix:
      - PROJECT: ["group/frontend", "group/mobile-app"]
        ENVIRONMENT: ["staging", "production"]
  trigger:
    project: $PROJECT
  variables:
    DEPLOY_ENV: $ENVIRONMENT
```

---

## 3. 👥 父子Pipeline设计


### 3.1 什么是父子Pipeline


**通俗解释**：
```
父Pipeline：总指挥（主项目）
    ├── 子Pipeline1：前端团队
    ├── 子Pipeline2：后端团队  
    └── 子Pipeline3：测试团队

就像项目经理（父）管理各个小组（子）
```

**父子关系特点**：
- **父Pipeline**：控制整体流程，监控子Pipeline状态
- **子Pipeline**：执行具体任务，报告结果给父Pipeline
- **状态同步**：子Pipeline失败，父Pipeline也失败

### 3.2 创建子Pipeline


```yaml
# 父项目的配置
stages:
  - prepare
  - child_pipelines
  - finalize

# 生成子Pipeline配置
generate_child_config:
  stage: prepare
  script:
    - echo "生成子Pipeline配置文件"
    - |
      cat > child-pipeline.yml << EOF
      stages:
        - build
        - test
      child_build:
        stage: build
        script:
          - echo "子Pipeline构建任务"
      child_test:
        stage: test
        script:
          - echo "子Pipeline测试任务"
      EOF
  artifacts:
    paths:
      - child-pipeline.yml

# 触发子Pipeline
trigger_child:
  stage: child_pipelines
  trigger:
    include:
      - artifact: child-pipeline.yml
        job: generate_child_config
  variables:
    PARENT_PIPELINE_ID: $CI_PIPELINE_ID
```

### 3.3 动态子Pipeline生成


```yaml
# 根据项目变化生成不同的子Pipeline
dynamic_child_pipeline:
  stage: child_pipelines
  script:
    - |
      # 检测哪些模块发生了变化
      if git diff --name-only HEAD~1 | grep "frontend/"; then
        echo "frontend: true" >> modules.yml
      fi
      if git diff --name-only HEAD~1 | grep "backend/"; then
        echo "backend: true" >> modules.yml
      fi
      
      # 生成相应的子Pipeline配置
      python generate_pipeline.py modules.yml > child-config.yml
  artifacts:
    paths:
      - child-config.yml
  trigger:
    include:
      - artifact: child-config.yml
        job: dynamic_child_pipeline
```

---

## 4. 🔄 Upstream与Downstream关系


### 4.1 关系图解


```
上游(Upstream)项目    →    下游(Downstream)项目
     库项目         →         应用项目
     API项目        →         前端项目
     基础设施       →         业务服务
```

**通俗理解**：
- **Upstream**：像河流的上游，为下游提供"水源"（依赖、制品）
- **Downstream**：像河流的下游，接收上游的"水"（使用依赖、制品）

### 4.2 Upstream项目配置


```yaml
# 上游项目（比如API项目）配置
stages:
  - build
  - test
  - package
  - trigger_downstream

build_api:
  stage: build
  script:
    - mvn clean compile
  artifacts:
    paths:
      - target/

test_api:
  stage: test
  script:
    - mvn test
  artifacts:
    reports:
      junit: target/test-results.xml

package_api:
  stage: package
  script:
    - mvn package
    - docker build -t api:$CI_PIPELINE_ID .
  artifacts:
    paths:
      - target/*.jar

# 触发下游项目
notify_frontend:
  stage: trigger_downstream
  trigger:
    project: frontend/web-app
  variables:
    API_VERSION: $CI_PIPELINE_ID
    API_IMAGE: "api:$CI_PIPELINE_ID"
  only:
    - main
```

### 4.3 Downstream项目配置


```yaml
# 下游项目（比如前端项目）配置
stages:
  - prepare
  - build
  - deploy

# 等待上游制品
wait_for_api:
  stage: prepare
  script:
    - echo "等待API版本：$API_VERSION"
    - echo "使用API镜像：$API_IMAGE"
  rules:
    - if: $CI_PIPELINE_SOURCE == "pipeline"

build_frontend:
  stage: build
  script:
    - npm install
    - API_ENDPOINT=$API_IMAGE npm run build
  artifacts:
    paths:
      - dist/

deploy_with_api:
  stage: deploy
  script:
    - echo "部署前端，连接API：$API_IMAGE"
    - kubectl apply -f deployment.yml
  environment:
    name: staging
```

---

## 5. 📦 项目依赖管理


### 5.1 依赖关系图


```
依赖关系示例：
    共享库项目
         ↓
    ┌─────────┬─────────┐
    ↓         ↓         ↓
  项目A     项目B     项目C
    ↓         ↓         ↓
    └─────────┬─────────┘
         ↓
    集成测试项目
```

### 5.2 版本依赖配置


```yaml
# 共享库项目
stages:
  - build
  - publish
  - notify

build_library:
  stage: build
  script:
    - mvn clean package
  artifacts:
    paths:
      - target/*.jar

publish_library:
  stage: publish
  script:
    - mvn deploy
    - echo "VERSION=$CI_PIPELINE_ID" > version.env
  artifacts:
    reports:
      dotenv: version.env

# 通知所有依赖项目
notify_dependents:
  stage: notify
  parallel:
    matrix:
      - PROJECT: 
        - "group/project-a"
        - "group/project-b" 
        - "group/project-c"
  trigger:
    project: $PROJECT
  variables:
    LIBRARY_VERSION: $VERSION
    UPDATE_TYPE: "dependency"
```

### 5.3 智能依赖检测


```yaml
# 检测依赖变化并选择性触发
detect_changes:
  stage: analyze
  script:
    - |
      # 分析代码变化影响
      if git diff --name-only HEAD~1 | grep "src/core/"; then
        echo "TRIGGER_ALL=true" >> impact.env
      elif git diff --name-only HEAD~1 | grep "src/utils/"; then
        echo "TRIGGER_PARTIAL=true" >> impact.env
      else
        echo "TRIGGER_NONE=true" >> impact.env
      fi
  artifacts:
    reports:
      dotenv: impact.env

# 根据影响范围触发
trigger_full_rebuild:
  trigger:
    project: group/full-system-test
  rules:
    - if: $TRIGGER_ALL == "true"

trigger_partial_test:
  trigger:
    project: group/partial-test
  rules:
    - if: $TRIGGER_PARTIAL == "true"
```

---

## 6. 🏗️ 复杂工作流设计


### 6.1 微服务架构工作流


```
微服务发布工作流：

第一阶段（并行）：
┌─────────┬─────────┬─────────┐
│ 服务A   │ 服务B   │ 服务C   │
│构建测试 │构建测试 │构建测试 │
└─────────┴─────────┴─────────┘
         ↓
第二阶段（串行）：
┌─────────────────────────────┐
│      集成测试环境部署        │
└─────────────────────────────┘
         ↓
第三阶段（条件触发）：
┌─────────────────────────────┐
│      生产环境部署           │
│    （需要手动审批）         │
└─────────────────────────────┘
```

**配置示例**：
```yaml
# 主控制Pipeline
stages:
  - trigger_services
  - integration_test
  - production_deploy

# 并行触发所有微服务
trigger_all_services:
  stage: trigger_services
  parallel:
    matrix:
      - SERVICE: [user-service, order-service, payment-service]
  trigger:
    project: microservices/$SERVICE
  variables:
    BUILD_TYPE: "release"
    TARGET_ENV: "staging"

# 等待所有服务完成后进行集成测试
integration_test:
  stage: integration_test
  trigger:
    project: tests/integration-tests
  dependencies:
    - trigger_all_services
  variables:
    TEST_ENVIRONMENT: "staging"

# 生产部署（需要手动批准）
production_deploy:
  stage: production_deploy
  trigger:
    project: deployment/production
  when: manual
  dependencies:
    - integration_test
```

### 6.2 环境升级工作流


```yaml
# 环境递进工作流
stages:
  - dev_deploy
  - staging_deploy
  - uat_deploy
  - production_deploy

deploy_to_dev:
  stage: dev_deploy
  trigger:
    project: deployment/dev-environment
  variables:
    APP_VERSION: $CI_COMMIT_SHA

deploy_to_staging:
  stage: staging_deploy
  trigger:
    project: deployment/staging-environment
  dependencies:
    - deploy_to_dev
  variables:
    APP_VERSION: $CI_COMMIT_SHA
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"

deploy_to_uat:
  stage: uat_deploy
  trigger:
    project: deployment/uat-environment
  dependencies:
    - deploy_to_staging
  when: manual
  variables:
    APP_VERSION: $CI_COMMIT_SHA

deploy_to_production:
  stage: production_deploy
  trigger:
    project: deployment/production-environment
  dependencies:
    - deploy_to_uat
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```

---

## 7. 📤 项目间制品共享


### 7.1 制品共享机制


**什么是制品共享**：
```
项目A生成：
├── 编译好的JAR包
├── Docker镜像
├── 配置文件
└── 测试报告

项目B使用：
├── 下载JAR包作为依赖
├── 拉取Docker镜像
├── 复制配置文件
└── 参考测试报告
```

### 7.2 制品上传配置


```yaml
# 生产者项目（上传制品）
stages:
  - build
  - upload_artifacts

build_application:
  stage: build
  script:
    - mvn clean package
    - docker build -t myapp:$CI_PIPELINE_ID .
  artifacts:
    name: "myapp-$CI_PIPELINE_ID"
    paths:
      - target/*.jar
      - config/
      - docs/
    expire_in: 1 week

# 上传到制品仓库
upload_to_registry:
  stage: upload_artifacts
  script:
    - docker push $CI_REGISTRY_IMAGE:$CI_PIPELINE_ID
    - |
      # 上传到包管理器
      curl -X POST \
        -H "JOB-TOKEN: $CI_JOB_TOKEN" \
        -F package=@target/myapp.jar \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/myapp/$CI_PIPELINE_ID/myapp.jar"
```

### 7.3 制品下载使用


```yaml
# 消费者项目（下载制品）
stages:
  - download_dependencies
  - integration_build

download_upstream_artifacts:
  stage: download_dependencies
  script:
    - |
      # 下载依赖项目的制品
      curl -H "JOB-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/upstream-project-id/packages/generic/myapp/$UPSTREAM_VERSION/myapp.jar" \
        -o libs/myapp.jar
      
      # 下载Docker镜像信息
      docker pull $CI_REGISTRY_IMAGE/upstream:$UPSTREAM_VERSION
  artifacts:
    paths:
      - libs/
  variables:
    UPSTREAM_VERSION: "${UPSTREAM_PIPELINE_ID:-latest}"

integration_build:
  stage: integration_build
  script:
    - echo "使用上游制品进行集成构建"
    - cp libs/myapp.jar ./dependencies/
    - mvn clean package -Pupstream-integration
  dependencies:
    - download_upstream_artifacts
```

### 7.4 版本化制品管理


```yaml
# 制品版本管理
variables:
  ARTIFACT_VERSION: "${CI_COMMIT_TAG:-$CI_PIPELINE_ID}"
  ARTIFACT_NAME: "myapp-${ARTIFACT_VERSION}"

create_release_artifacts:
  stage: release
  script:
    - |
      # 创建版本化制品
      mkdir -p release/$ARTIFACT_VERSION
      cp target/*.jar release/$ARTIFACT_VERSION/
      cp -r config/ release/$ARTIFACT_VERSION/
      
      # 生成制品清单
      cat > release/$ARTIFACT_VERSION/manifest.json << EOF
      {
        "version": "$ARTIFACT_VERSION",
        "commit": "$CI_COMMIT_SHA",
        "pipeline": "$CI_PIPELINE_ID",
        "timestamp": "$(date -Iseconds)",
        "artifacts": [
          "myapp.jar",
          "config/"
        ]
      }
      EOF
  artifacts:
    name: "$ARTIFACT_NAME"
    paths:
      - release/$ARTIFACT_VERSION/
  only:
    - tags
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 多项目Pipeline：协调多个项目的构建和部署流程
🔸 跨项目触发：一个项目完成后自动启动另一个项目
🔸 父子Pipeline：主项目控制子项目的执行
🔸 上下游关系：项目间的依赖和数据流向
🔸 制品共享：项目间共享构建结果和资源
```

### 8.2 关键配置要点


> 📌 **触发配置核心**  
> `trigger`关键字是跨项目连接的桥梁，必须指定正确的项目路径和分支

> ⚠️ **权限注意事项**  
> 触发跨项目Pipeline需要相应的权限，确保项目间的访问权限配置正确

> 💡 **实用技巧**  
> 使用变量传递信息，让下游项目知道上游的构建版本和状态

### 8.3 实际应用价值


**🏢 企业场景应用**：
- **微服务架构**：统一管理多个服务的发布流程
- **前后端分离**：协调前端和后端的部署顺序
- **环境升级**：dev→staging→production的自动化流程
- **依赖管理**：库项目更新后自动测试相关项目

**🔧 运维实践**：
- **故障隔离**：某个项目失败不影响无关项目
- **资源优化**：避免重复构建相同的依赖
- **审批流程**：关键环境部署需要人工确认
- **版本追踪**：清晰了解各项目的版本对应关系

**📊 效率提升**：
```
传统方式：手动逐个部署，容易出错，耗时长
多项目Pipeline：自动化协调，减少人工干预，提高效率

效果对比：
人工部署：2-3小时，错误率15%
自动化部署：30分钟，错误率<2%
```

### 8.4 最佳实践建议


**🎯 设计原则**：
1. **最小依赖**：减少不必要的项目依赖关系
2. **明确责任**：每个项目职责清晰，避免重叠
3. **版本管理**：制品版本化，便于回滚和追踪
4. **错误处理**：设置合理的重试和失败处理机制

**⚡ 性能优化**：
- 并行执行无依赖的项目
- 缓存公共依赖减少重复下载
- 合理设置制品过期时间
- 使用条件触发避免不必要的执行

**🔒 安全考虑**：
- 使用项目访问token而非个人token
- 敏感信息通过变量传递，不写在配置文件中
- 定期检查和更新跨项目访问权限
- 审计Pipeline执行日志

**核心记忆**：
- 多项目Pipeline就像乐队指挥，协调各个乐器（项目）的演奏
- trigger关键字是连接项目的桥梁
- 上游为下游提供"原料"，下游使用"原料"生产"产品"
- 制品共享避免重复劳动，提高整体效率