---
title: 4、变量与环境管理
---
## 📚 目录

1. [变量基础概念](#1-变量基础概念)
2. [预定义变量使用](#2-预定义变量使用)
3. [自定义变量定义](#3-自定义变量定义)
4. [环境变量设置](#4-环境变量设置)
5. [敏感变量保护](#5-敏感变量保护)
6. [变量作用域控制](#6-变量作用域控制)
7. [变量优先级规则](#7-变量优先级规则)
8. [变量继承机制](#8-变量继承机制)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 变量基础概念


### 1.1 什么是CI/CD变量


**简单理解**：变量就像是"容器"，用来存放各种信息，比如数据库密码、API地址等。

```
想象一下现实生活：
你的钱包 = 变量名（比如叫"wallet"）
钱包里的钱 = 变量值（比如"500元"）

CI/CD中：
DATABASE_URL = 变量名
"mysql://user:pass@localhost/db" = 变量值
```

**🔸 为什么需要变量？**

```
没有变量的痛苦：
❌ 代码里写死数据库地址
❌ 密码直接写在配置文件里
❌ 不同环境要修改多处代码
❌ 敏感信息暴露在代码仓库

有了变量的好处：
✅ 配置和代码分离
✅ 敏感信息安全存储  
✅ 不同环境使用不同配置
✅ 修改配置不用改代码
```

### 1.2 GitLab CI/CD变量类型


**三大类变量**：

| 类型 | **说明** | **举例** | **使用场景** |
|------|---------|---------|-------------|
| 🏗️ **预定义变量** | `GitLab自动创建的` | `CI_PROJECT_NAME` | `获取项目信息` |
| 🔧 **自定义变量** | `我们自己定义的` | `DATABASE_URL` | `存储配置信息` |
| 🔐 **环境变量** | `运行时的系统变量` | `PATH`, `HOME` | `系统级配置` |

### 1.3 变量的工作原理


**变量使用流程图**：

```
开发者定义变量 → GitLab存储变量 → CI运行时注入 → 脚本中使用

详细过程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  定义变量    │───▶│  安全存储    │───▶│  运行时注入  │───▶│  脚本使用    │
│ APP_ENV=prod │    │ GitLab服务器 │    │ CI执行器    │    │ echo $APP_ENV│
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
```

---

## 2. 🏗️ 预定义变量使用


### 2.1 什么是预定义变量


**通俗解释**：GitLab已经为你准备好的"现成变量"，就像酒店房间里的毛巾、肥皂一样，拿来就能用。

**🔸 预定义变量的特点**：
- ✅ **自动创建**：GitLab在CI运行时自动生成
- ✅ **随时可用**：不需要你手动定义
- ✅ **内容丰富**：包含项目、分支、用户等各种信息
- ✅ **动态更新**：每次运行时内容可能不同

### 2.2 常用预定义变量详解


**📋 项目相关变量**：

```yaml
# 获取项目基本信息
deploy:
  script:
    - echo "项目名称：$CI_PROJECT_NAME"           # 输出：my-awesome-app
    - echo "项目ID：$CI_PROJECT_ID"             # 输出：12345
    - echo "项目完整路径：$CI_PROJECT_PATH"       # 输出：group/my-awesome-app
    - echo "项目URL：$CI_PROJECT_URL"           # 输出：https://gitlab.com/group/my-awesome-app
```

**🌿 分支和提交信息**：

```yaml
build:
  script:
    - echo "当前分支：$CI_COMMIT_REF_NAME"       # 输出：main 或 feature/login
    - echo "提交哈希：$CI_COMMIT_SHA"           # 输出：a1b2c3d4e5f6...
    - echo "提交信息：$CI_COMMIT_MESSAGE"       # 输出：修复登录bug
    - echo "提交作者：$CI_COMMIT_AUTHOR"        # 输出：张三 <zhangsan@example.com>
```

**⚙️ 运行环境信息**：

```yaml
test:
  script:
    - echo "任务ID：$CI_JOB_ID"                # 输出：67890
    - echo "任务名称：$CI_JOB_NAME"             # 输出：test
    - echo "流水线ID：$CI_PIPELINE_ID"          # 输出：54321
    - echo "GitLab实例：$CI_SERVER_URL"        # 输出：https://gitlab.com
```

### 2.3 预定义变量实际应用


**🎯 根据分支选择部署环境**：

```yaml
deploy:
  script:
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        echo "部署到生产环境"
        deploy_to_production
      elif [ "$CI_COMMIT_REF_NAME" = "develop" ]; then
        echo "部署到测试环境"  
        deploy_to_staging
      else
        echo "功能分支，跳过部署"
      fi
```

**📦 动态生成构建产物名称**：

```yaml
build:
  script:
    - APP_VERSION="${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
    - echo "构建版本：$APP_VERSION"              # 输出：main-a1b2c3d
    - docker build -t "myapp:$APP_VERSION" .
```

### 2.4 预定义变量速查表


| 变量名 | **含义** | **示例值** | **常用场景** |
|--------|---------|-----------|-------------|
| `CI_PROJECT_NAME` | `项目名称` | `my-app` | `Docker镜像命名` |
| `CI_COMMIT_REF_NAME` | `分支名称` | `main` | `环境判断` |
| `CI_COMMIT_SHORT_SHA` | `短提交哈希` | `a1b2c3d` | `版本标记` |
| `CI_PIPELINE_ID` | `流水线ID` | `12345` | `构建追踪` |
| `CI_JOB_TOKEN` | `任务令牌` | `glpat-xxx` | `API调用认证` |

---

## 3. 🔧 自定义变量定义


### 3.1 什么是自定义变量


**生活类比**：就像在家里贴便签纸，上面写着"WiFi密码：12345678"，需要的时候就看一眼。

**🔸 自定义变量的作用**：
- 📝 **存储配置**：数据库连接、API密钥等
- 🔄 **环境区分**：开发环境用A配置，生产环境用B配置
- 🔒 **安全存储**：密码不写在代码里
- 🎛️ **灵活控制**：随时修改不用改代码

### 3.2 在.gitlab-ci.yml中定义


**💡 文件级变量（推荐新手使用）**：

```yaml
# 在文件顶部定义全局变量
variables:
  APP_NAME: "我的应用"
  APP_VERSION: "1.0.0"
  BUILD_ENV: "production"
  DATABASE_HOST: "localhost"

# 所有任务都能使用这些变量
build:
  script:
    - echo "正在构建 $APP_NAME 版本 $APP_VERSION"

test:
  script:
    - echo "连接数据库：$DATABASE_HOST"
    - echo "运行环境：$BUILD_ENV"
```

**🎯 任务级变量（局部使用）**：

```yaml
variables:
  GLOBAL_VAR: "全局变量"

job1:
  variables:
    LOCAL_VAR: "任务1的私有变量"
    APP_ENV: "test"
  script:
    - echo $GLOBAL_VAR      # ✅ 能访问
    - echo $LOCAL_VAR       # ✅ 能访问
    - echo $APP_ENV         # 输出：test

job2:
  script:
    - echo $GLOBAL_VAR      # ✅ 能访问
    - echo $LOCAL_VAR       # ❌ 访问不到，会是空值
```

### 3.3 通过GitLab界面定义


**🖱️ 界面操作步骤**：

```
步骤详解：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  1.进入项目  │───▶│ 2.点击设置   │───▶│ 3.选择CI/CD │───▶│ 4.添加变量   │
│   页面      │    │   菜单      │    │   选项     │    │   和值      │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘

具体路径：
项目首页 → Settings → CI/CD → Variables → Add Variable
```

**📋 界面定义变量示例**：

| 字段 | **填写内容** | **说明** |
|------|-------------|---------|
| **Key** | `DATABASE_URL` | `变量名称（大写+下划线）` |
| **Value** | `mysql://user:pass@host/db` | `变量的实际值` |
| **Type** | `Variable` | `选择变量类型` |
| **Environment scope** | `*` | `所有环境都可用` |
| **Protect variable** | `☑️` | `只在保护分支可用` |
| **Mask variable** | `☑️` | `在日志中隐藏值` |

### 3.4 变量命名最佳实践


**✅ 好的命名方式**：

```yaml
variables:
  # 全大写，下划线分隔
  DATABASE_URL: "mysql://localhost/app"
  API_BASE_URL: "https://api.example.com"
  DOCKER_IMAGE_TAG: "latest"
  
  # 有意义的前缀分组
  AWS_ACCESS_KEY: "AKIA..."
  AWS_SECRET_KEY: "xxx..."
  AWS_REGION: "us-east-1"
```

**❌ 不好的命名方式**：

```yaml
variables:
  # 避免这些命名
  db: "mysql://..."           # 太简短，不清楚
  DatabaseURL: "mysql://..."   # 大小写混合
  api-url: "https://..."      # 使用连字符
  SECRET: "xxx"               # 太通用
```

**🎯 命名规范建议**：

| 规则 | **说明** | **示例** |
|------|---------|---------|
| **全大写** | `使用大写字母` | `DATABASE_URL` |
| **下划线分隔** | `用下划线连接单词` | `API_BASE_URL` |
| **有意义的名称** | `见名知意` | `SMTP_PASSWORD` 而不是 `PASS` |
| **分组前缀** | `相关变量用相同前缀` | `AWS_*`, `DOCKER_*` |

---

## 4. 🌍 环境变量设置


### 4.1 什么是环境变量


**简单理解**：环境变量就像是"房间里的空气"，无处不在，所有程序都能"呼吸"到。

**🔸 环境变量 vs 普通变量**：

```
普通变量：
就像你桌上的便签纸，只有你能看到

环境变量：
就像房间的温度，房间里的每个人都能感受到

技术对比：
┌─────────────┐    ┌─────────────┐
│   普通变量   │    │   环境变量   │
├─────────────┤    ├─────────────┤
│ 作用域小     │    │ 全局可用     │
│ 手动传递     │    │ 自动继承     │
│ CI专用      │    │ 系统级别     │
└─────────────┘    └─────────────┘
```

### 4.2 系统预设环境变量


**🖥️ 常见系统环境变量**：

```yaml
show_env:
  script:
    # 系统路径
    - echo "系统路径：$PATH"
    # 用户主目录  
    - echo "用户目录：$HOME"           # 输出：/root
    # 当前工作目录
    - echo "工作目录：$PWD"            # 输出：/builds/group/project
    # 系统用户
    - echo "当前用户：$USER"           # 输出：gitlab-runner
```

### 4.3 在CI中设置环境变量


**💡 临时设置（任务内有效）**：

```yaml
job1:
  script:
    # 方式1：直接设置
    - export MY_VAR="临时变量值"
    - echo "变量值：$MY_VAR"          # 输出：临时变量值
    
    # 方式2：一行设置并使用
    - MY_OTHER_VAR="另一个值" echo "值：$MY_OTHER_VAR"

job2:
  script:
    - echo "变量值：$MY_VAR"          # 输出：空值（上个任务设置的变量在这里无效）
```

**🔄 持久设置（跨任务共享）**：

```yaml
# 方式1：在variables中定义
variables:
  SHARED_CONFIG: "所有任务都能用"

# 方式2：使用artifacts传递
job1:
  script:
    - echo "DATABASE_URL=mysql://host/db" > .env
  artifacts:
    reports:
      dotenv: .env

job2:
  dependencies:
    - job1
  script:
    - echo "数据库地址：$DATABASE_URL"   # 能获取到job1设置的值
```

### 4.4 环境变量的实际应用


**🎯 根据环境设置不同配置**：

```yaml
variables:
  # 基础配置
  APP_NAME: "myapp"

# 开发环境任务
deploy_dev:
  script:
    - export DATABASE_URL="mysql://dev-host/myapp_dev"
    - export DEBUG="true"
    - echo "部署到开发环境：$DATABASE_URL"
  only:
    - develop

# 生产环境任务  
deploy_prod:
  script:
    - export DATABASE_URL="mysql://prod-host/myapp_prod"
    - export DEBUG="false"
    - echo "部署到生产环境：$DATABASE_URL"
  only:
    - main
```

**📦 Docker容器中的环境变量**：

```yaml
build:
  script:
    # 将CI变量传递给Docker容器
    - docker run 
        -e "APP_ENV=$CI_COMMIT_REF_NAME" 
        -e "BUILD_NUMBER=$CI_PIPELINE_ID"
        -e "API_KEY=$SECRET_API_KEY"
        myapp:latest
```

---

## 5. 🔐 敏感变量保护


### 5.1 什么是敏感变量


**生活类比**：敏感变量就像你的银行卡密码，绝对不能随便告诉别人或写在纸上。

**🔸 常见敏感信息**：
- 🔑 **密码和密钥**：数据库密码、API密钥
- 🎫 **访问令牌**：GitHub Token、云服务凭证
- 📧 **第三方服务**：邮件服务密码、支付接口密钥
- 🏠 **内部信息**：内网地址、服务器IP

**⚠️ 不保护敏感变量的风险**：

```
风险示例：
❌ 密码出现在CI日志中 → 任何能看日志的人都知道密码
❌ 代码提交到公开仓库 → 全世界都能看到你的密钥
❌ 开发者离职带走密钥 → 安全风险
❌ 日志被搜索引擎收录 → 密码公开在互联网上
```

### 5.2 变量遮掩（Masked Variables）


**🎭 什么是变量遮掩**：

```
没有遮掩的情况：
CI日志显示：echo "API密钥：sk-1234567890abcdef"
                    ↑
                 密钥暴露

有遮掩的情况：  
CI日志显示：echo "API密钥：[MASKED]"
                    ↑
                 密钥被隐藏
```

**💡 设置遮掩变量**：

```yaml
# 在GitLab界面中设置变量时：
Key: SECRET_API_KEY
Value: sk-1234567890abcdef
☑️ Mask variable    # 勾选这个选项

# 在日志中的效果
script:
  - echo "API密钥：$SECRET_API_KEY"    # 日志显示：API密钥：[MASKED]
  - curl -H "Authorization: Bearer $SECRET_API_KEY" api.example.com
    # 日志显示：curl -H "Authorization: Bearer [MASKED]" api.example.com
```

**🔍 遮掩变量的限制**：

| 要求 | **说明** | **原因** |
|------|---------|---------|
| **最少8个字符** | `变量值长度≥8` | `太短容易误遮掩` |
| **只能包含特定字符** | `字母、数字、@:.-_` | `特殊字符可能破坏遮掩` |
| **不能有空格** | `值中不能包含空格` | `空格会干扰识别` |

### 5.3 受保护变量（Protected Variables）


**🛡️ 什么是受保护变量**：

```
受保护变量的访问控制：

普通分支（feature/login）:
├─ 普通变量 ✅ 可以访问
└─ 受保护变量 ❌ 无法访问

受保护分支（main, develop）:
├─ 普通变量 ✅ 可以访问  
└─ 受保护变量 ✅ 可以访问
```

**💡 设置受保护变量**：

```yaml
# GitLab界面设置：
Key: PRODUCTION_DATABASE_PASSWORD
Value: super_secret_password_123
☑️ Protect variable    # 勾选这个选项
Environment scope: production

# 效果演示
deploy_to_prod:
  script:
    - echo "数据库密码：$PRODUCTION_DATABASE_PASSWORD"
  only:
    - main    # 只有在main分支才能获取到这个变量
```

### 5.4 敏感变量最佳实践


**✅ 推荐做法**：

```yaml
# 1. 使用有意义但不暴露信息的变量名
variables:
  DB_HOST: "localhost"           # ✅ 可以公开
  DB_NAME: "myapp"              # ✅ 可以公开

# 通过GitLab界面设置敏感变量：
# DB_PASSWORD (masked + protected)
# API_SECRET_KEY (masked + protected)

deploy:
  script:
    # 2. 敏感操作不输出详细信息
    - echo "开始连接数据库..."
    - mysql -h $DB_HOST -u $DB_USER -p$DB_PASSWORD -e "SELECT 1"
    - echo "数据库连接成功"      # ✅ 只输出结果，不输出密码
```

**❌ 危险做法**：

```yaml
# 不要这样做！
variables:
  DB_PASSWORD: "123456"         # ❌ 密码写在配置文件里

deploy:
  script:
    - echo "密码是：$DB_PASSWORD"  # ❌ 直接输出密码到日志
    - echo $DB_PASSWORD > /tmp/pwd # ❌ 将密码写入文件
```

**🔒 综合安全策略**：

| 安全措施 | **适用场景** | **设置方法** |
|---------|-------------|-------------|
| **Mask** | `所有敏感变量` | `界面勾选Mask variable` |
| **Protect** | `生产环境变量` | `界面勾选Protect variable` |
| **Environment scope** | `环境隔离` | `设置特定环境` |
| **定期轮换** | `长期使用的密钥` | `定期更新变量值` |

---

## 6. 🎯 变量作用域控制


### 6.1 什么是变量作用域


**生活类比**：作用域就像房间的门禁卡，有的卡能开所有房间，有的卡只能开特定房间。

**🔸 作用域层次结构**：

```
变量作用域从大到小：
┌─────────────────────────────────────┐
│           GitLab实例级               │ ← 整个GitLab服务器
│  ┌───────────────────────────────┐   │
│  │          组级变量              │   │ ← 整个组织/团队
│  │  ┌─────────────────────────┐   │   │
│  │  │       项目级变量        │   │   │ ← 单个项目
│  │  │  ┌───────────────────┐  │   │   │
│  │  │  │    任务级变量     │  │   │   │ ← 单个CI任务
│  │  │  └───────────────────┘  │   │   │
│  │  └─────────────────────────┘   │   │
│  └───────────────────────────────┘   │
└─────────────────────────────────────┘
```

### 6.2 项目级变量作用域


**📋 项目级变量特点**：
- ✅ **该项目内所有流水线都能使用**
- ✅ **所有分支都能访问**（除非设置了保护）
- ✅ **持久存储**，修改后立即生效

**💡 设置项目级变量**：

```yaml
# 通过GitLab界面设置的项目变量
# 项目设置 → CI/CD → Variables

# 在.gitlab-ci.yml中所有任务都能使用
build:
  script:
    - echo "项目配置：$PROJECT_CONFIG"

test:
  script:
    - echo "项目配置：$PROJECT_CONFIG"    # 同样能访问
```

### 6.3 任务级变量作用域


**🎯 任务级变量特点**：
- ✅ **只在定义的任务内有效**
- ✅ **可以覆盖同名的项目级变量**
- ✅ **任务结束后自动清理**

**💡 任务级变量示例**：

```yaml
variables:
  GLOBAL_ENV: "production"      # 全局变量
  LOG_LEVEL: "info"            # 全局日志级别

build:
  variables:
    LOG_LEVEL: "debug"         # 任务级变量，覆盖全局设置
    BUILD_TYPE: "release"      # 任务专属变量
  script:
    - echo "环境：$GLOBAL_ENV"     # 输出：production
    - echo "日志级别：$LOG_LEVEL"   # 输出：debug（被覆盖）
    - echo "构建类型：$BUILD_TYPE" # 输出：release

test:
  script:
    - echo "环境：$GLOBAL_ENV"     # 输出：production  
    - echo "日志级别：$LOG_LEVEL"   # 输出：info（全局值）
    - echo "构建类型：$BUILD_TYPE" # 输出：空值（访问不到）
```

### 6.4 环境作用域（Environment Scope）


**🌍 什么是环境作用域**：

```
环境作用域控制变量在哪些环境中可用：

开发环境变量：
Key: DATABASE_URL
Value: mysql://dev-server/myapp_dev  
Environment scope: development

生产环境变量：
Key: DATABASE_URL  
Value: mysql://prod-server/myapp_prod
Environment scope: production

通用变量：
Key: APP_NAME
Value: MyApplication
Environment scope: *                # 所有环境
```

**💡 环境作用域实际应用**：

```yaml
# 开发环境部署
deploy_dev:
  script:
    - echo "部署到：$DATABASE_URL"    # 使用dev环境的数据库
  environment:
    name: development

# 生产环境部署  
deploy_prod:
  script:
    - echo "部署到：$DATABASE_URL"    # 使用prod环境的数据库
  environment:
    name: production
```

### 6.5 作用域优先级实战


**🏆 变量优先级（从高到低）**：

```yaml
# 假设有以下变量设置：

# 1. GitLab界面项目级变量
# DATABASE_URL = "mysql://project-level/db"

# 2. .gitlab-ci.yml全局变量
variables:
  DATABASE_URL: "mysql://global-level/db"

# 3. 任务级变量
deploy:
  variables:
    DATABASE_URL: "mysql://job-level/db"
  script:
    - echo $DATABASE_URL    # 输出：mysql://job-level/db

# 优先级结果：任务级 > 文件全局 > 项目级
```

**📊 作用域优先级表**：

| 优先级 | **变量来源** | **作用范围** | **使用场景** |
|-------|-------------|-------------|-------------|
| **1 (最高)** | `任务级变量` | `单个任务` | `特殊配置覆盖` |
| **2** | `文件全局变量` | `整个CI文件` | `通用配置` |
| **3** | `项目级变量` | `整个项目` | `项目配置` |
| **4 (最低)** | `组级变量` | `整个组织` | `组织标准` |

---

## 7. 🏆 变量优先级规则


### 7.1 优先级规则详解


**🎯 理解优先级的关键**：越"靠近"任务执行的变量，优先级越高。

**📊 完整优先级顺序**：

```
优先级从高到低的详细排序：

1. 🥇 Trigger variables (流水线触发变量)
2. 🥈 Job-level variables (任务级变量)  
3. 🥉 Pipeline variables (流水线变量)
4. 🏅 Project variables (项目级变量)
5. 🎖️ Group variables (组级变量)
6. 🏆 Instance variables (实例级变量)
7. 📋 Predefined variables (预定义变量)

记忆口诀：触任流项组实预
```

### 7.2 实际优先级测试


**💡 完整测试示例**：

```yaml
# 假设在GitLab界面设置了项目级变量：
# MY_VAR = "项目级别的值"

# .gitlab-ci.yml文件级变量
variables:
  MY_VAR: "文件级别的值"
  GLOBAL_VAR: "全局变量"

# 任务级变量测试
test_priority:
  variables:
    MY_VAR: "任务级别的值"        # 最高优先级
    JOB_VAR: "任务专属变量"      
  script:
    - echo "MY_VAR的值：$MY_VAR"         # 输出：任务级别的值
    - echo "GLOBAL_VAR的值：$GLOBAL_VAR" # 输出：全局变量
    - echo "JOB_VAR的值：$JOB_VAR"       # 输出：任务专属变量

# 另一个任务不会受影响
other_job:
  script:
    - echo "MY_VAR的值：$MY_VAR"         # 输出：文件级别的值
    - echo "JOB_VAR的值：$JOB_VAR"       # 输出：空值
```

### 7.3 变量覆盖策略


**🔄 智能覆盖的实际应用**：

```yaml
variables:
  # 默认配置（适用于大多数情况）
  BUILD_ENV: "development"
  LOG_LEVEL: "info"
  DOCKER_TAG: "latest"

# 生产环境构建（覆盖部分变量）
build_production:
  variables:
    BUILD_ENV: "production"        # 覆盖环境
    LOG_LEVEL: "warn"             # 覆盖日志级别
    # DOCKER_TAG 使用默认值 "latest"
  script:
    - echo "构建环境：$BUILD_ENV"     # 输出：production
    - echo "日志级别：$LOG_LEVEL"     # 输出：warn
    - echo "Docker标签：$DOCKER_TAG" # 输出：latest

# 调试构建（只覆盖必要变量）
build_debug:
  variables:
    LOG_LEVEL: "debug"            # 只覆盖日志级别
  script:
    - echo "构建环境：$BUILD_ENV"     # 输出：development（默认值）
    - echo "日志级别：$LOG_LEVEL"     # 输出：debug
```

### 7.4 优先级最佳实践


**✅ 推荐的变量分层策略**：

```yaml
# 层级1：基础默认值（全局变量）
variables:
  APP_NAME: "myapp"
  BUILD_TIMEOUT: "10m"
  DOCKER_REGISTRY: "registry.example.com"

# 层级2：环境相关（通过GitLab界面设置）
# 开发环境：DATABASE_URL = "mysql://dev/db"
# 生产环境：DATABASE_URL = "mysql://prod/db"

# 层级3：任务特定（任务级变量）
build:
  variables:
    BUILD_TYPE: "optimized"       # 只有构建任务需要
  script:
    - echo "构建应用：$APP_NAME"
    - echo "构建类型：$BUILD_TYPE"

deploy:
  variables:
    DEPLOY_STRATEGY: "rolling"    # 只有部署任务需要
  script:
    - echo "部署应用：$APP_NAME"
    - echo "部署策略：$DEPLOY_STRATEGY"
```

**📋 变量设置决策指南**：

| 变量特征 | **推荐设置位置** | **原因** |
|---------|----------------|---------|
| **所有任务都需要** | `.gitlab-ci.yml全局` | `共享方便` |
| **敏感信息** | `GitLab界面项目级` | `安全保护` |
| **环境相关** | `GitLab界面+环境作用域` | `环境隔离` |
| **任务专属** | `任务级variables` | `避免冲突` |
| **临时调试** | `任务级variables` | `不影响他人` |

---

## 8. 🔄 变量继承机制


### 8.1 什么是变量继承


**🏠 家族遗产类比**：就像家族财产会传给后代一样，上级变量会"遗传"给下级使用。

**🔸 继承关系链条**：

```
继承流向图：
GitLab实例 → 组织/组 → 项目 → 流水线 → 任务

详细继承关系：
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  实例级变量  │────▶│   组级变量   │────▶│  项目级变量  │
│ (全局通用)  │     │  (团队共享)  │     │  (项目专用)  │
└─────────────┘     └─────────────┘     └─────────────┘
                                               │
                                               ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  任务级变量  │◀────│ 流水线变量   │◀────│ .gitlab-ci.yml │
│ (任务专属)  │     │ (动态设置)  │     │   (文件级)   │
└─────────────┘     └─────────────┘     └─────────────┘
```

### 8.2 组级变量继承


**👥 什么是组级变量**：

```
组织结构示例：
公司组织 (company)
├── 前端团队组 (frontend-team)
│   ├── 用户界面项目 (user-interface)
│   └── 管理后台项目 (admin-panel)
└── 后端团队组 (backend-team)
    ├── API服务项目 (api-service)
    └── 数据处理项目 (data-processor)

组级变量继承：
company组设置：COMPANY_NAME = "我的公司"
frontend-team组设置：TEAM_LEAD = "张三"

结果：
- user-interface项目能访问：COMPANY_NAME 和 TEAM_LEAD
- admin-panel项目能访问：COMPANY_NAME 和 TEAM_LEAD  
- api-service项目只能访问：COMPANY_NAME（不在frontend-team组）
```

**💡 组级变量设置路径**：

```
设置组级变量：
组首页 → Settings → CI/CD → Variables → Add Variable

实际效果：
# 在任何属于该组的项目CI中都能使用
deploy:
  script:
    - echo "公司名称：$COMPANY_NAME"    # 继承自公司组
    - echo "团队负责人：$TEAM_LEAD"     # 继承自团队组
```

### 8.3 项目变量继承


**📁 项目级继承机制**：

```yaml
# 项目级变量会被CI文件继承
# 在GitLab项目设置中定义：
# PROJECT_ID = "12345"
# DEFAULT_BRANCH = "main"

# .gitlab-ci.yml自动继承项目级变量
variables:
  LOCAL_CONFIG: "本地配置"          # 文件级变量

build:
  script:
    - echo "项目ID：$PROJECT_ID"        # 继承自项目级
    - echo "默认分支：$DEFAULT_BRANCH"   # 继承自项目级  
    - echo "本地配置：$LOCAL_CONFIG"     # 文件级变量
```

### 8.4 变量继承与覆盖


**🔄 继承中的覆盖规则**：

```yaml
# 假设有以下继承链：
# 组级变量：DATABASE_HOST = "group-db-server"
# 项目级变量：DATABASE_HOST = "project-db-server"  
# 文件级变量：DATABASE_HOST = "file-db-server"

variables:
  DATABASE_HOST: "file-db-server"      # 覆盖项目级和组级
  APP_VERSION: "1.0.0"                # 新增变量

production_deploy:
  variables:
    DATABASE_HOST: "prod-db-server"    # 任务级覆盖所有上级
  script:
    - echo "数据库服务器：$DATABASE_HOST"  # 输出：prod-db-server
    - echo "应用版本：$APP_VERSION"       # 输出：1.0.0

development_deploy:
  script:
    - echo "数据库服务器：$DATABASE_HOST"  # 输出：file-db-server
```

### 8.5 继承机制实际应用


**🎯 多项目统一配置**：

```yaml
# 场景：公司有多个项目，需要统一配置

# 在公司组级设置：
# DOCKER_REGISTRY = "company-registry.com"
# SECURITY_SCAN_URL = "https://security.company.com"
# NOTIFICATION_WEBHOOK = "https://chat.company.com/webhook"

# 每个项目的.gitlab-ci.yml都能使用：
build:
  script:
    - docker build -t $DOCKER_REGISTRY/myapp:$CI_COMMIT_SHA .
    - echo "推送到统一镜像仓库：$DOCKER_REGISTRY"

security_scan:
  script:
    - curl -X POST $SECURITY_SCAN_URL -d "project=$CI_PROJECT_NAME"
    - echo "安全扫描已提交"

notify:
  script:
    - curl -X POST $NOTIFICATION_WEBHOOK -d "部署完成：$CI_PROJECT_NAME"
```

**🔧 环境配置继承**：

```yaml
# 组级设置不同环境的通用配置
# DEV_CLUSTER_URL = "https://dev-k8s.company.com"  
# PROD_CLUSTER_URL = "https://prod-k8s.company.com"

# 项目级设置项目特定配置
# APP_NAME = "my-service"
# DOCKER_IMAGE = "my-service"

# .gitlab-ci.yml中组合使用
deploy_to_dev:
  script:
    - kubectl config set-cluster dev --server=$DEV_CLUSTER_URL
    - kubectl create deployment $APP_NAME --image=$DOCKER_IMAGE
  environment:
    name: development

deploy_to_prod:
  script:
    - kubectl config set-cluster prod --server=$PROD_CLUSTER_URL  
    - kubectl create deployment $APP_NAME --image=$DOCKER_IMAGE
  environment:
    name: production
```

### 8.6 继承最佳实践


**✅ 合理的继承分层**：

| 层级 | **设置内容** | **示例变量** | **使用场景** |
|------|-------------|-------------|-------------|
| **组级** | `组织通用配置` | `COMPANY_REGISTRY`, `TEAM_EMAIL` | `所有项目共享` |
| **项目级** | `项目特定配置` | `APP_NAME`, `SERVICE_PORT` | `项目内通用` |
| **文件级** | `CI流程配置` | `BUILD_SCRIPT`, `TEST_COMMAND` | `CI逻辑控制` |
| **任务级** | `任务专属配置` | `JOB_TIMEOUT`, `RESOURCE_LIMIT` | `特殊需求` |

**🚫 避免的继承问题**：

```yaml
# ❌ 不好的做法：在任务级设置通用变量
job1:
  variables:
    APP_NAME: "myapp"              # 应该在更高层级设置
    COMPANY_NAME: "我的公司"        # 应该在组级设置
  
# ✅ 好的做法：合理分层
variables:
  APP_NAME: "myapp"                # 项目级配置

job1:
  variables:
    JOB_SPECIFIC_CONFIG: "job1"    # 只有任务专属配置
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 变量本质：存储配置信息的"容器"，实现配置与代码分离
🔸 三大类型：预定义变量、自定义变量、环境变量各有用途
🔸 安全保护：敏感变量必须使用Mask和Protect功能
🔸 作用域控制：不同层级的变量有不同的使用范围
🔸 优先级规则：任务级 > 文件级 > 项目级 > 组级 > 实例级
🔸 继承机制：下级自动继承上级变量，可以覆盖但要谨慎
🔸 环境隔离：通过Environment Scope实现不同环境的配置隔离
```

### 9.2 变量使用决策流程


```
变量设置决策树：

是否是敏感信息？
├─ 是 → GitLab界面设置 + Mask + Protect
└─ 否 → 继续判断

是否所有任务都需要？  
├─ 是 → .gitlab-ci.yml全局变量
└─ 否 → 继续判断

是否环境相关？
├─ 是 → GitLab界面 + Environment Scope
└─ 否 → 任务级变量

是否多项目共享？
├─ 是 → 组级变量
└─ 否 → 项目级变量
```

### 9.3 实战应用指南


**🎯 新手入门建议**：

1. **从简单开始**：先在`.gitlab-ci.yml`中定义非敏感的全局变量
2. **逐步进阶**：学会通过GitLab界面设置项目级变量
3. **安全意识**：所有密码、密钥都要用Mask和Protect
4. **环境隔离**：开发和生产环境要用不同的变量值
5. **测试验证**：修改变量后要测试CI流水线是否正常

**🔧 常见使用模式**：

```yaml
# 模式1：基础应用配置
variables:
  APP_NAME: "myapp"
  BUILD_ENV: "production"

# 模式2：条件配置
script:
  - |
    if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
      export DEPLOY_ENV="production"
    else
      export DEPLOY_ENV="staging"  
    fi

# 模式3：敏感信息使用（通过界面设置）
script:
  - docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD
  - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

### 9.4 故障排除指南


**🔍 常见问题及解决方案**：

| 问题现象 | **可能原因** | **解决方法** |
|---------|-------------|-------------|
| `变量值为空` | `变量名拼写错误或作用域不匹配` | `检查变量名和作用域设置` |
| `敏感信息泄露` | `未设置Mask选项` | `重新设置变量并勾选Mask` |
| `变量值不正确` | `被其他层级变量覆盖` | `检查变量优先级` |
| `Protected分支无法访问` | `变量设置了Protect但分支未保护` | `设置分支保护或取消变量保护` |

**💡 调试技巧**：

```yaml
debug_variables:
  script:
    - echo "=== 变量调试信息 ==="
    - echo "项目名称：$CI_PROJECT_NAME"
    - echo "当前分支：$CI_COMMIT_REF_NAME"  
    - echo "自定义变量：$MY_CUSTOM_VAR"
    - echo "=== 环境变量 ==="
    - env | grep CI_ | head -10          # 显示CI相关环境变量
    - echo "调试完成"
```

**核心记忆口诀**：
- 变量如容器，配置代码分离清
- 预定义变量GitLab给，自定义变量我来定  
- 敏感信息要保护，Mask加Protect不忘记
- 作用域控制访问权，优先级高能覆盖
- 继承机制层层传，合理分层是关键