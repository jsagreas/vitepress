---
title: 2、gitlab-ci.yml文件结构
---
## 📚 目录

1. [.gitlab-ci.yml文件作用](#1-gitlab-ci-yml文件作用)
2. [文件位置与命名](#2-文件位置与命名)
3. [配置文件基本结构](#3-配置文件基本结构)
4. [Global keywords全局关键字](#4-global-keywords全局关键字)
5. [Job keywords任务关键字](#5-job-keywords任务关键字)
6. [第一个Pipeline示例](#6-第一个pipeline示例)
7. [配置文件验证方法](#7-配置文件验证方法)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 .gitlab-ci.yml文件作用


### 1.1 什么是.gitlab-ci.yml文件


**简单理解**：就像工厂的生产流水线说明书
```
现实中的流水线：                GitLab CI/CD流水线：
原材料 → 加工 → 质检 → 包装        代码提交 → 测试 → 构建 → 部署

流水线说明书告诉工人：           .gitlab-ci.yml告诉GitLab：
- 每个环节做什么               - 每个步骤执行什么命令
- 用什么工具                  - 用什么环境和工具
- 按什么顺序                  - 按什么顺序执行
- 出问题怎么办                - 失败了怎么处理
```

**核心作用**：
- **自动化指挥官**：告诉GitLab如何自动处理你的代码
- **流程定义器**：定义从代码到产品的完整流程
- **规则制定者**：设置什么时候执行、谁可以执行

### 1.2 为什么需要这个文件


**解决的痛点问题**：
```
🔸 手动部署的烦恼：
传统方式：程序员手动上传代码 → 手动测试 → 手动部署
问题：容易出错、效率低下、半夜加班部署

🔸 CI/CD自动化：
现代方式：提交代码 → 自动测试 → 自动构建 → 自动部署  
优势：减少错误、提高效率、随时发布
```

**实际价值体现**：
- **减少重复劳动**：写一次配置，永久自动执行
- **提高代码质量**：每次提交都自动测试
- **快速交付**：从几小时缩短到几分钟
- **降低风险**：标准化流程，减少人为错误

---

## 2. 📁 文件位置与命名


### 2.1 文件位置要求


**.gitlab-ci.yml必须放在项目根目录**
```
项目结构示例：
my-project/                  ← 项目根目录
├── .gitlab-ci.yml          ← 必须在这里！
├── src/                    ← 源代码目录
│   ├── main.js
│   └── utils.js
├── tests/                  ← 测试文件目录
├── package.json            ← 项目配置
└── README.md              ← 说明文档

位置规则：
✅ 正确：放在项目根目录
❌ 错误：放在子文件夹里
❌ 错误：放在其他位置
```

### 2.2 文件命名规范


**标准命名**：
- **必须命名**：`.gitlab-ci.yml`
- **注意事项**：
  - 以点(.)开头
  - 全小写字母
  - 中间用连字符(-)
  - 扩展名是yml

**其他可用名称**（不推荐新手使用）：
```
✅ 标准推荐：.gitlab-ci.yml
⚠️ 也可以用：.gitlab-ci.yaml
❌ 不能用：gitlab-ci.yml（缺少前面的点）
❌ 不能用：.gitlab-ci.YML（大写不行）
```

### 2.3 文件编码要求


**编码格式**：UTF-8
**换行符**：推荐使用LF（Unix格式）
**缩进规则**：使用2个空格，不要用Tab键

---

## 3. 🏗️ 配置文件基本结构


### 3.1 YAML基础语法


**什么是YAML**：
YAML是一种人类可读的数据序列化格式，比JSON更简洁易懂

```yaml
# 这是注释，用#号开头

# 基本键值对（冒号后面必须有空格）
name: "我的项目"
version: 1.0

# 列表（用减号开头）
languages:
  - JavaScript
  - Python
  - Java

# 嵌套结构（用缩进表示层级）
database:
  host: localhost
  port: 3306
  credentials:
    username: admin
    password: secret
```

**YAML语法要点**：
- **缩进敏感**：用空格缩进表示层级关系
- **冒号规则**：冒号后面必须有空格
- **列表格式**：用减号(-)表示列表项
- **注释写法**：用#号写注释说明

### 3.2 .gitlab-ci.yml整体结构


**配置文件的基本框架**：
```yaml
# ============ 全局配置区域 ============
# 定义整个Pipeline的通用设置

image: node:16                    # 全局默认Docker镜像
variables:                       # 全局变量
  NODE_ENV: production

stages:                          # 定义执行阶段
  - test                         # 测试阶段
  - build                        # 构建阶段  
  - deploy                       # 部署阶段

# ============ 任务定义区域 ============
# 定义具体要执行的任务

test-job:                        # 测试任务
  stage: test                    # 属于test阶段
  script:                        # 要执行的命令
    - npm test

build-job:                       # 构建任务
  stage: build                   # 属于build阶段
  script:
    - npm run build

deploy-job:                      # 部署任务
  stage: deploy                  # 属于deploy阶段
  script:
    - npm run deploy
```

### 3.3 配置文件的层次结构


```
.gitlab-ci.yml文件结构：
┌─────────────────────────────────┐
│         全局配置                 │
│  ┌─────────────────────────┐    │
│  │ image: 默认镜像          │    │
│  │ variables: 全局变量      │    │  
│  │ stages: 执行阶段         │    │
│  │ before_script: 前置脚本  │    │
│  └─────────────────────────┘    │
└─────────────────────────────────┘
┌─────────────────────────────────┐
│         任务定义                 │
│  ┌─────────────────────────┐    │
│  │ job1: 任务1             │    │
│  │   stage: 所属阶段        │    │
│  │   script: 执行脚本       │    │
│  │   only: 执行条件         │    │
│  └─────────────────────────┘    │
│  ┌─────────────────────────┐    │
│  │ job2: 任务2             │    │
│  │   stage: 所属阶段        │    │
│  │   script: 执行脚本       │    │
│  └─────────────────────────┘    │
└─────────────────────────────────┘
```

---

## 4. 🌐 Global keywords全局关键字


### 4.1 什么是全局关键字


**简单理解**：全局关键字就像公司的通用规章制度
- 适用于所有部门（所有Job）
- 设置一次，到处生效
- 可以被具体部门（具体Job）覆盖

### 4.2 常用全局关键字详解


#### 🖼️ image - 默认运行环境


**作用**：指定Pipeline默认使用的Docker镜像
```yaml
# 为所有任务设置默认环境
image: node:16

# 相当于告诉GitLab：
# "除非特别说明，所有任务都在Node.js 16环境中运行"

# 常用镜像示例：
image: node:16           # Node.js开发环境
image: python:3.9        # Python开发环境  
image: openjdk:11        # Java开发环境
image: alpine:latest     # 轻量级Linux环境
```

#### 🔧 variables - 全局变量


**作用**：定义在所有任务中都能使用的变量
```yaml
variables:
  # 环境变量
  NODE_ENV: production
  API_URL: https://api.example.com
  
  # 构建参数
  BUILD_VERSION: "1.0.0"
  DOCKER_REGISTRY: registry.gitlab.com

# 在任务中使用变量：
test-job:
  script:
    - echo "当前环境: $NODE_ENV"        # 输出: 当前环境: production
    - echo "API地址: $API_URL"          # 输出: API地址: https://api.example.com
```

#### 🎭 stages - 执行阶段


**作用**：定义Pipeline的执行阶段和顺序
```yaml
stages:
  - prepare     # 准备阶段：安装依赖
  - test        # 测试阶段：运行测试
  - build       # 构建阶段：编译打包
  - deploy      # 部署阶段：发布应用

# 执行顺序：
# prepare → test → build → deploy
# 前一个阶段完成后，才能执行下一个阶段
```

**阶段执行规则**：
```
执行流程：
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│ prepare │──▶│  test   │──▶│  build  │──▶│ deploy  │
└─────────┘   └─────────┘   └─────────┘   └─────────┘

串行执行：阶段按顺序执行，前面的阶段失败后面就不执行
并行执行：同一阶段内的多个任务可以并行执行
```

#### 📝 before_script - 前置脚本


**作用**：在每个任务的主要脚本之前执行
```yaml
before_script:
  - echo "开始执行任务..."
  - npm install              # 安装依赖
  - npm run setup            # 环境初始化

# 每个任务都会先执行这些命令，然后才执行任务自己的script
```

#### 🔄 after_script - 后置脚本


**作用**：在每个任务的主要脚本之后执行（无论成功还是失败）
```yaml
after_script:
  - echo "任务执行完毕"
  - npm run cleanup          # 清理临时文件
  - docker system prune -f   # 清理Docker缓存
```

### 4.3 全局关键字使用示例


```yaml
# ============ 完整的全局配置示例 ============
image: node:16                   # 默认使用Node.js 16环境

variables:                       # 全局变量
  NODE_ENV: production
  CACHE_KEY: "$CI_COMMIT_REF_SLUG"

stages:                          # 执行阶段
  - install
  - test  
  - build
  - deploy

before_script:                   # 每个任务执行前
  - echo "任务开始执行..."
  - node --version
  - npm --version

after_script:                    # 每个任务执行后
  - echo "任务执行完毕"
  - ls -la                       # 列出文件

# ============ 任务会继承上面的全局设置 ============
```

---

## 5. 💼 Job keywords任务关键字


### 5.1 什么是任务关键字


**理解概念**：任务关键字就像员工的具体工作说明书
- 每个任务（Job）都有自己的工作内容
- 任务关键字定义这个任务的具体执行方式
- 可以覆盖全局设置，实现个性化配置

### 5.2 核心任务关键字详解


#### 🎯 stage - 任务所属阶段


**作用**：指定这个任务属于哪个执行阶段
```yaml
# 不同任务归属不同阶段
install-deps:
  stage: install    # 属于install阶段
  script:
    - npm install

run-tests:
  stage: test       # 属于test阶段  
  script:
    - npm test

build-app:
  stage: build      # 属于build阶段
  script:
    - npm run build
```

#### ⚡ script - 执行脚本


**作用**：定义任务要执行的具体命令
```yaml
# 单条命令
simple-job:
  script: echo "Hello World"

# 多条命令
complex-job:
  script:
    - echo "步骤1：检查环境"
    - node --version
    - echo "步骤2：安装依赖" 
    - npm install
    - echo "步骤3：运行构建"
    - npm run build
    - echo "构建完成！"
```

**命令执行规则**：
- 命令按顺序执行
- 任何一条命令失败，整个任务失败
- 命令在指定的Docker环境中执行

#### 🖼️ image - 任务专用环境


**作用**：为特定任务指定不同的运行环境
```yaml
# 全局默认环境
image: node:16

# 大部分任务使用Node.js环境
test-frontend:
  script:
    - npm test

# 特殊任务使用Python环境
test-python:
  image: python:3.9     # 覆盖全局设置
  script:
    - pip install -r requirements.txt
    - python -m pytest

# 数据库相关任务使用专门环境
migrate-database:
  image: postgres:13    # 使用PostgreSQL环境
  script:
    - psql -c "SELECT version();"
```

#### ⚠️ only/except - 执行条件


**作用**：控制任务在什么情况下执行
```yaml
# only: 只在指定条件下执行
deploy-production:
  stage: deploy
  script:
    - npm run deploy:prod
  only:
    - main                    # 只在main分支执行
    - /^release-.*$/         # 只在release-开头的分支执行

# except: 除了指定条件外都执行  
run-tests:
  stage: test
  script:
    - npm test
  except:
    - tags                   # 不在tag上执行
    - schedules              # 不在定时任务中执行
```

#### 🕐 when - 执行时机


**作用**：控制任务何时执行
```yaml
# always: 总是执行（即使前面的任务失败）
cleanup-job:
  stage: cleanup
  script:
    - rm -rf temp/
  when: always

# on_failure: 只在前面任务失败时执行
notify-failure:
  stage: notify
  script:
    - echo "构建失败，发送通知"
  when: on_failure

# manual: 手动触发
deploy-production:
  stage: deploy
  script:
    - npm run deploy:prod
  when: manual              # 需要手动点击执行
```

#### 🔄 retry - 重试机制


**作用**：任务失败时自动重试
```yaml
# 基本重试
flaky-test:
  script:
    - npm run test:integration
  retry: 2                  # 失败后重试2次

# 高级重试配置
network-dependent-job:
  script:
    - curl https://api.example.com
  retry:
    max: 3                  # 最多重试3次
    when:
      - runner_system_failure    # 系统故障时重试
      - stuck_or_timeout_failure # 超时时重试
```

### 5.3 任务关键字组合使用


```yaml
# ============ 完整的任务配置示例 ============
deploy-production:
  stage: deploy                 # 部署阶段
  image: alpine:latest         # 使用轻量级环境
  variables:                   # 任务专用变量
    DEPLOY_ENV: production
  before_script:              # 任务前置脚本
    - apk add --no-cache curl
  script:                     # 主要执行脚本
    - echo "部署到生产环境: $DEPLOY_ENV"
    - curl -X POST "$DEPLOY_URL"
    - echo "部署完成"
  after_script:               # 任务后置脚本
    - echo "清理部署临时文件"
  only:                       # 执行条件
    - main
  when: manual                # 手动触发
  retry: 2                    # 失败重试2次
  timeout: 30m               # 超时限制30分钟
```

---

## 6. 🚀 第一个Pipeline示例


### 6.1 简单的Node.js项目Pipeline


**场景说明**：为一个Node.js项目创建基本的CI/CD流程

```yaml
# ============ 我的第一个.gitlab-ci.yml ============

# 全局配置
image: node:16                  # 使用Node.js 16环境

stages:                         # 定义三个阶段
  - test                        # 测试阶段
  - build                       # 构建阶段
  - deploy                      # 部署阶段

variables:                      # 全局变量
  NODE_ENV: production

# ============ 具体任务定义 ============

# 测试任务
run-tests:
  stage: test                   # 属于test阶段
  script:
    - echo "开始运行测试..."
    - npm install               # 安装依赖
    - npm test                  # 运行测试
    - echo "测试完成！"

# 构建任务  
build-app:
  stage: build                  # 属于build阶段
  script:
    - echo "开始构建应用..."
    - npm install               # 安装依赖
    - npm run build             # 构建应用
    - echo "构建完成！"
  artifacts:                    # 保存构建产物
    paths:
      - dist/                   # 保存dist目录
    expire_in: 1 week          # 保存1周

# 部署任务
deploy-app:
  stage: deploy                 # 属于deploy阶段
  script:
    - echo "开始部署应用..."
    - npm run deploy            # 部署应用
    - echo "部署完成！"
  only:
    - main                      # 只在main分支部署
  when: manual                  # 手动触发部署
```

### 6.2 执行流程说明


```
Pipeline执行流程：
┌─────────────────┐
│   代码提交       │ ← 开发者push代码到GitLab
└─────────────────┘
           │
           ▼
┌─────────────────┐
│  触发Pipeline    │ ← GitLab自动读取.gitlab-ci.yml
└─────────────────┘
           │
           ▼
┌─────────────────┐
│   test阶段      │ ← 执行run-tests任务
│  运行测试        │   - 安装依赖
│                │   - 运行测试
└─────────────────┘
           │ 测试通过
           ▼
┌─────────────────┐
│   build阶段     │ ← 执行build-app任务
│  构建应用        │   - 安装依赖
│                │   - 构建代码
└─────────────────┘
           │ 构建成功
           ▼
┌─────────────────┐
│   deploy阶段    │ ← 等待手动触发
│  部署应用        │   - 只在main分支
│                │   - 需要手动点击
└─────────────────┘
```

### 6.3 实际运行效果


**GitLab界面中看到的效果**：
```
Pipeline #123 (main分支)
┌────────────┐  ┌────────────┐  ┌────────────┐
│ run-tests  │─▶│ build-app  │─▶│ deploy-app │
│    ✅      │  │    ✅      │  │    ⏸️      │
│   2m 30s   │  │   1m 45s   │  │   manual   │
└────────────┘  └────────────┘  └────────────┘

状态说明：
✅ 执行成功
❌ 执行失败  
⏸️ 等待手动触发
🔄 正在执行
```

### 6.4 优化后的示例


```yaml
# ============ 优化版本的.gitlab-ci.yml ============

image: node:16

stages:
  - test
  - build  
  - deploy

# 缓存node_modules提高速度
cache:
  paths:
    - node_modules/

variables:
  NODE_ENV: production

# 全局前置脚本
before_script:
  - echo "当前工作目录: $(pwd)"
  - echo "Node.js版本: $(node --version)"
  - echo "npm版本: $(npm --version)"

# ============ 任务定义 ============

# 安装依赖（独立任务）
install-deps:
  stage: test
  script:
    - npm ci                    # 使用ci命令，比install更快
  artifacts:
    paths:
      - node_modules/          # 传递给后续任务
    expire_in: 1 hour

# 代码质量检查
code-quality:
  stage: test
  script:
    - npm run lint             # 代码规范检查
    - npm run format:check     # 格式检查
  dependencies:
    - install-deps             # 依赖install-deps任务

# 单元测试
unit-tests:
  stage: test
  script:
    - npm test                 # 运行单元测试
    - npm run coverage         # 生成覆盖率报告
  dependencies:
    - install-deps
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

# 构建应用
build-application:
  stage: build
  script:
    - npm run build:prod       # 生产环境构建
    - ls -la dist/            # 检查构建结果
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  dependencies:
    - install-deps

# 部署到开发环境
deploy-dev:
  stage: deploy
  script:
    - echo "部署到开发环境"
    - npm run deploy:dev
  environment:
    name: development
    url: https://dev.example.com
  only:
    - develop                  # 只在develop分支部署

# 部署到生产环境  
deploy-prod:
  stage: deploy
  script:
    - echo "部署到生产环境"
    - npm run deploy:prod
  environment:
    name: production
    url: https://example.com
  only:
    - main                     # 只在main分支部署
  when: manual                 # 手动触发
  dependencies:
    - build-application
```

---

## 7. ✅ 配置文件验证方法


### 7.1 为什么需要验证


**常见配置错误**：
```yaml
# ❌ 错误示例：缩进不正确
stages:
- test           # 缺少空格缩进
- build

# ❌ 错误示例：冒号后没有空格
image:node:16    # 冒号后缺少空格

# ❌ 错误示例：语法错误
script:
  - echo "hello  # 引号未闭合

# ❌ 错误示例：关键字拼写错误
scrpit:          # script拼写错误
  - npm test
```

### 7.2 GitLab内置验证器


**CI/CD配置验证页面**：
```
GitLab验证工具位置：
项目首页 → CI/CD → Editor → Validate

验证步骤：
1. 打开GitLab项目
2. 点击左侧菜单"CI/CD" → "Editor"  
3. 将配置内容粘贴到编辑器
4. 点击"Validate"按钮
5. 查看验证结果

验证结果：
✅ Configuration is valid    # 配置正确
❌ Configuration is invalid  # 配置有误，会显示具体错误
```

### 7.3 本地验证方法


**方法1：使用在线YAML验证器**
```
推荐网站：
• https://yamllint.com/
• https://yamlchecker.com/
• https://codebeautify.org/yaml-validator

使用步骤：
1. 复制.gitlab-ci.yml内容
2. 粘贴到验证网站
3. 点击验证按钮
4. 查看语法错误提示
```

**方法2：使用GitLab CLI工具**
```bash
# 安装GitLab CLI
npm install -g @gitbeaker/cli

# 验证配置文件
gitlab-ci-validator .gitlab-ci.yml

# 输出结果：
# ✅ Configuration is valid
# ❌ Error: Invalid YAML syntax at line 15
```

**方法3：使用IDE插件**
```
VS Code推荐插件：
• GitLab Workflow
• YAML Language Support  
• GitLab CI/CD

插件功能：
• 语法高亮
• 自动补全
• 实时错误检查
• 格式化代码
```

### 7.4 常见错误及解决方法


**错误类型对照表**：

| **错误类型** | **错误示例** | **正确写法** | **解决方法** |
|------------|------------|------------|------------|
| **缩进错误** | `stages:<br>- test` | `stages:<br>  - test` | `使用2个空格缩进` |
| **冒号空格** | `image:node:16` | `image: node:16` | `冒号后加空格` |
| **引号未闭合** | `echo "hello` | `echo "hello"` | `检查引号配对` |
| **拼写错误** | `scrpit:` | `script:` | `检查关键字拼写` |
| **列表格式** | `script: npm test` | `script:<br>  - npm test` | `多命令用列表格式` |

### 7.5 配置文件调试技巧


**调试步骤**：
```yaml
# 1. 添加调试信息
debug-job:
  stage: test
  script:
    - echo "=== 环境信息 ==="
    - pwd                      # 当前目录
    - ls -la                   # 文件列表
    - env | grep CI            # CI环境变量
    - echo "=== 开始执行 ==="
    - npm --version            # 检查工具版本
    - node --version

# 2. 分步骤执行
test-step-by-step:
  stage: test
  script:
    - echo "步骤1：检查环境"
    - node --version || echo "Node.js未安装"
    - echo "步骤2：安装依赖"  
    - npm install || echo "依赖安装失败"
    - echo "步骤3：运行测试"
    - npm test || echo "测试失败"

# 3. 使用条件判断
safe-deploy:
  stage: deploy
  script:
    - |
      if [ -d "dist" ]; then
        echo "构建产物存在，开始部署"
        npm run deploy
      else
        echo "构建产物不存在，跳过部署"
        exit 1
      fi
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 .gitlab-ci.yml作用：自动化流水线的指挥官，告诉GitLab如何处理代码
🔸 文件位置：必须放在项目根目录，命名为.gitlab-ci.yml
🔸 基本结构：全局配置 + 任务定义的两层结构
🔸 全局关键字：image、variables、stages、before_script等
🔸 任务关键字：stage、script、only、when等
🔸 验证方法：GitLab内置验证器 + 在线工具 + IDE插件
```

### 8.2 关键理解要点


**🔹 全局vs任务的关系**：
```
全局配置 = 公司规章制度（适用所有员工）
任务配置 = 个人工作说明（可以有特殊要求）

继承关系：
• 任务继承全局设置
• 任务可以覆盖全局设置
• 没有设置的任务使用全局默认值
```

**🔹 阶段执行规律**：
```
阶段特点：
• 串行执行：阶段按顺序执行
• 并行任务：同阶段任务可并行
• 失败停止：前阶段失败，后阶段不执行
• 依赖关系：后阶段依赖前阶段成功
```

**🔹 YAML语法要点**：
```
记忆口诀：
• 缩进用空格，不要用Tab
• 冒号后面必须有空格  
• 列表项目用减号
• 注释使用井号
```

### 8.3 实际应用价值


**💼 工作中的应用**：
- **提高效率**：一次配置，永久自动化
- **减少错误**：标准化流程，避免手动失误
- **团队协作**：统一的CI/CD流程，便于团队协作
- **快速交付**：自动化测试和部署，加快产品发布

**🔧 配置技巧**：
- **从简单开始**：先写基本配置，再逐步优化
- **分步调试**：添加echo命令输出调试信息
- **合理分工**：按功能划分任务，便于并行执行
- **善用缓存**：缓存依赖文件，提高执行速度

### 8.4 学习路径建议


**📚 循序渐进的学习步骤**：
1. **第1周**：掌握基本语法和简单配置
2. **第2周**：理解阶段概念和任务依赖
3. **第3周**：学习高级特性和优化技巧  
4. **第4周**：实际项目应用和问题解决

**🎯 练习建议**：
- 从最简单的"Hello World"开始
- 逐步添加测试、构建、部署任务
- 尝试不同的执行条件和触发方式
- 学会使用GitLab界面查看执行结果

**核心记忆口诀**：
- CI/CD配置文件是流水线说明书
- 全局设置定规则，任务配置做具体事
- 阶段串行任务并行，前面失败后面停
- YAML语法要规范，验证调试不能少