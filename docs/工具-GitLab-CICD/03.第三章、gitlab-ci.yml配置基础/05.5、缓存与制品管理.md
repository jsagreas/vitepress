---
title: 5、缓存与制品管理
---
## 📚 目录

1. [缓存与制品的基本概念](#1-缓存与制品的基本概念)
2. [cache缓存配置详解](#2-cache缓存配置详解)
3. [artifacts制品管理](#3-artifacts制品管理)
4. [dependencies依赖声明](#4-dependencies依赖声明)
5. [缓存策略选择与最佳实践](#5-缓存策略选择与最佳实践)
6. [制品存储与下载机制](#6-制品存储与下载机制)
7. [expire_in过期设置](#7-expire_in过期设置)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 缓存与制品的基本概念


### 1.1 为什么需要缓存和制品？


想象一下，你每天上班都要从家里带午餐到公司。如果每次都从头开始准备，会很浪费时间。聪明的做法是：

```
周末批量准备 → 冰箱存储 → 每天取用
     ↓
节省时间 + 提高效率 + 减少重复工作
```

**在CI/CD中也是一样的道理：**

> 💡 **通俗理解**
> 
> **缓存（Cache）** = 冰箱，存储可重复使用的"食材"
> **制品（Artifacts）** = 做好的"成品菜"，可以打包带走

### 1.2 缓存 vs 制品的核心区别


| 🆚 对比维度 | **Cache缓存** | **Artifacts制品** |
|------------|---------------|------------------|
| **用途** | 加速构建，重复利用 | 传递结果，存储产出 |
| **生命周期** | 长期存在，可被覆盖 | 短期存在，有明确过期时间 |
| **共享范围** | 同一项目的多次构建 | 同一流水线的不同任务间 |
| **典型内容** | `node_modules`、`.m2`、`.gradle` | 编译产物、测试报告、部署包 |

```
缓存使用场景：
开发者A提交代码 → 下载依赖包 → 构建成功 → 依赖包缓存
开发者B提交代码 → 直接使用缓存 → 构建更快 ⚡

制品使用场景：
构建任务 → 生成JAR包 → 存为制品
部署任务 → 下载JAR包 → 部署到服务器
```

### 1.3 实际工作场景类比


**🏗️ 软件开发就像盖房子：**

```
┌─────────────────────────────────────────┐
│              盖房子类比                   │
├─────────────────┬─────────────────────────┤
│ 🧱 原材料仓库    │ Cache缓存               │
│   (砖头、水泥)   │ (依赖包、编译工具)        │
├─────────────────┼─────────────────────────┤
│ 🏠 成品房屋      │ Artifacts制品           │
│   (可交付使用)   │ (可部署的应用程序)        │
└─────────────────┴─────────────────────────┘
```

---

## 2. 🗄️ cache缓存配置详解


### 2.1 cache的基本语法


最简单的缓存配置就像给东西贴个标签，然后放到仓库里：

```yaml
# 最基础的缓存配置
job_name:
  cache:
    key: "my-cache"           # 缓存的"标签"
    paths:                    # 要缓存的"东西"
      - node_modules/
      - .npm/
```

> 📝 **新手提示**
> 
> `key`就像仓库里的**标签纸**，相同标签的缓存会被重复使用
> `paths`就像**装箱清单**，告诉系统哪些文件夹要打包存储

### 2.2 缓存键（Key）的智能设计


**📌 静态键（固定不变）**
```yaml
cache:
  key: "node-dependencies"
  paths:
    - node_modules/
```
适用场景：依赖很少变化的项目

**📌 动态键（根据情况变化）**  
```yaml
cache:
  key: "$CI_COMMIT_REF_SLUG"    # 基于分支名
  paths:
    - node_modules/

# 实际效果：
# master分支 → key: "master"
# feature/login → key: "feature-login"
```

**📌 文件内容键（最智能）**
```yaml
cache:
  key:
    files:
      - package-lock.json     # 当这个文件变化时，缓存失效
  paths:
    - node_modules/
```

> 🧠 **记忆技巧**
> 
> *"文件不变缓存用，文件一变缓存空"*

### 2.3 缓存策略（Policy）


就像超市的进货策略一样，缓存也有不同的使用方式：

```yaml
# 策略1：拉取+推送（默认，最常用）
cache:
  key: "my-cache"
  paths:
    - node_modules/
  policy: pull-push          # 开始时下载，结束时上传

# 策略2：仅拉取（只下载，不上传）
cache:
  policy: pull              # 适用于部署任务

# 策略3：仅推送（只上传，不下载）  
cache:
  policy: push              # 适用于第一次构建
```

**🎯 策略选择指南：**

```
┌─ 任务类型 ─┬─ 推荐策略 ─┬─ 原因说明 ──────────┐
│ 构建任务   │ pull-push │ 需要使用和更新缓存  │
│ 测试任务   │ pull      │ 只需要使用，不修改  │
│ 部署任务   │ pull      │ 只需要使用编译产物  │
│ 清理任务   │ push      │ 只需要重建缓存     │
└───────────┴──────────┴──────────────────┘
```

### 2.4 多层缓存配置


```yaml
variables:
  NODE_VERSION: "16"

cache:
  - key: 
      files:
        - package-lock.json
      prefix: "$NODE_VERSION"    # 前缀区分不同环境
    paths:
      - node_modules/
    policy: pull-push
    
  - key: "gradle-$CI_COMMIT_REF_SLUG"
    paths:
      - .gradle/caches/
    policy: pull-push
```

> ⚠️ **注意事项**
> 
> 多个缓存配置会按顺序处理，就像有多个储物柜一样

---

## 3. 📦 artifacts制品管理


### 3.1 制品的基本概念


制品就像是工厂生产出来的**成品**，需要打包、标记、存储，以便后续使用：

```yaml
build_job:
  script:
    - npm run build          # 生产"成品"
    - npm run test          # 质量检查
  artifacts:
    name: "website-$CI_COMMIT_SHORT_SHA"    # 包装上的"产品名"
    paths:
      - dist/               # 要打包的"成品"
      - coverage/           # 质量报告
```

### 3.2 制品路径配置


**📁 基础路径配置**
```yaml
artifacts:
  paths:
    - build/                # 构建产物
    - dist/                 # 发布文件
    - reports/              # 报告文件
    - "*.jar"              # 通配符匹配
```

**📁 排除不需要的文件**
```yaml
artifacts:
  paths:
    - dist/
  exclude:
    - "dist/**/*.log"       # 排除日志文件
    - "dist/temp/"          # 排除临时目录
```

> 💡 **实践建议**
> 
> 就像打包行李一样，只带必需品，不要什么都装进去

### 3.3 制品报告功能


GitLab可以识别特定格式的报告，并在界面上直观展示：

```yaml
test_job:
  script:
    - npm test
  artifacts:
    reports:
      junit: "test-results.xml"        # 测试报告
      coverage: "coverage/cobertura.xml"  # 覆盖率报告
      codequality: "codequality.json"   # 代码质量报告
```

**📊 报告类型一览表：**

| 报告类型 | 文件格式 | 在GitLab中的显示 | 使用场景 |
|---------|---------|-----------------|---------|
| `junit` | XML | 🧪 测试结果页面 | 单元测试、集成测试 |
| `coverage` | XML | 📈 覆盖率图表 | 代码覆盖率分析 |
| `codequality` | JSON | 🔍 代码质量评分 | 静态代码分析 |
| `performance` | JSON | ⚡ 性能指标 | 性能测试结果 |

### 3.4 制品的when条件


```yaml
artifacts:
  paths:
    - logs/
  when: always              # 无论成功失败都保存

# 可选值说明：
# on_success: 仅成功时保存（默认）
# on_failure: 仅失败时保存  
# always: 总是保存
```

**🎯 使用场景：**
- `on_success`：正常的构建产物
- `on_failure`：调试日志、错误信息
- `always`：监控数据、统计信息

---

## 4. 🔗 dependencies依赖声明


### 4.1 依赖关系的必要性


想象一下餐厅的工作流程：

```
厨师做菜 → 服务员上菜 → 顾客用餐
   ↓         ↓          ↓
  制品      依赖        消费
```

在CI/CD中也是如此：

```yaml
build:                    # 厨师做菜
  script:
    - mvn package
  artifacts:
    paths:
      - target/*.jar

deploy:                   # 服务员上菜
  dependencies:
    - build              # 明确说明依赖build任务的产物
  script:
    - deploy target/*.jar
```

### 4.2 dependencies的工作机制


**🔄 没有dependencies的情况：**
```
任务A生成制品 → 存储到GitLab
任务B自动下载 → 所有前置任务的制品（可能很多不需要的）
```

**🎯 有dependencies的情况：**
```
任务A生成制品 → 存储到GitLab  
任务B明确声明 → 只下载指定任务的制品（精确高效）
```

### 4.3 dependencies配置示例


```yaml
stages:
  - build
  - test  
  - deploy

compile:
  stage: build
  script:
    - javac src/*.java
  artifacts:
    paths:
      - "*.class"

unit_test:
  stage: test
  dependencies:
    - compile              # 只需要编译产物
  script:
    - java -cp . TestRunner

integration_test:
  stage: test
  dependencies: []         # 空数组表示不需要任何制品
  script:
    - curl -f http://external-api/health

deploy_production:
  stage: deploy
  dependencies:
    - compile             # 明确指定只要编译产物
  script:
    - scp *.class user@server:/app/
```

> 📝 **关键理解**
> 
> `dependencies`就像点菜一样，不写就是"全套餐"，写了就是"按需点菜"

---

## 5. 🎯 缓存策略选择与最佳实践


### 5.1 缓存策略决策树


```
开始选择缓存策略
        ↓
   依赖会变化吗？
   ↙Yes        ↘No
基于文件的键    固定键名
        ↓           ↓
package-lock.json  "node-deps"
        ↓           ↓
   需要分支隔离？     全局共享
   ↙Yes    ↘No        ↓
分支键     全局键    简单策略
   ↓         ↓         ↓
"$BRANCH" "$GLOBAL"  完成
```

### 5.2 不同技术栈的缓存最佳实践


**🟨 Node.js项目**
```yaml
variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"

cache:
  key:
    files:
      - package-lock.json
  paths:
    - .npm/
    - node_modules/
  policy: pull-push

before_script:
  - npm ci --cache .npm --prefer-offline
```

**☕ Java Maven项目**
```yaml
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - .m2/repository/
  policy: pull-push

before_script:
  - mvn dependency:resolve --no-transfer-progress
```

**🐍 Python项目**
```yaml
variables:
  pip_cache_dir: "$CI_PROJECT_DIR/.cache/pip"

cache:
  key:
    files:
      - requirements.txt
  paths:
    - .cache/pip/
    - venv/
  policy: pull-push

before_script:
  - python -m venv venv
  - source venv/bin/activate
  - pip install --cache-dir .cache/pip -r requirements.txt
```

### 5.3 缓存失效的常见场景


**❌ 容易踩坑的地方：**

```yaml
# 坑1：缓存键太宽泛
cache:
  key: "global"           # 所有分支共享，容易冲突

# 坑2：缓存路径包含变化文件
cache:
  paths:
    - dist/               # 每次构建都变化，缓存无意义
    
# 坑3：忘记更新缓存
cache:
  policy: pull            # 只下载不上传，永远不更新
```

**✅ 正确的做法：**

```yaml
# 解决方案：精确的缓存策略
cache:
  key:
    files:
      - yarn.lock         # 基于依赖文件
    prefix: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG"  # 添加前缀避免冲突
  paths:
    - .yarn/cache/        # 只缓存不变的依赖
  policy: pull-push       # 正确的拉取推送策略
```

---

## 6. 📤 制品存储与下载机制


### 6.1 制品的生命周期


```
制品的一生：

创建阶段 → 存储阶段 → 传递阶段 → 消费阶段 → 过期清理
    ↓         ↓         ↓         ↓         ↓
任务生成   GitLab存储  下载分发   任务使用   自动删除
```

### 6.2 制品存储位置与容量


**📊 存储限制一览：**

| GitLab版本 | 单个制品大小 | 项目总容量 | 保存时间 |
|-----------|-------------|-----------|---------|
| **免费版** | 1GB | 无限制* | 最长30天 |
| **付费版** | 5GB | 可配置 | 可配置 |

> ⚠️ **重要提醒**
> 
> *虽然说"无限制"，但请合理使用，避免存储过多无用制品

### 6.3 制品下载机制


**🔄 自动下载规则：**

```yaml
# 情况1：默认行为（下载所有前置制品）
job1:
  artifacts:
    paths: ["file1.txt"]

job2:  
  script:
    - ls file1.txt        # ✅ 自动可用

# 情况2：选择性下载
job3:
  dependencies:
    - job1                # 只下载job1的制品
  script:
    - ls file1.txt        # ✅ 可用

# 情况3：禁用下载
job4:
  dependencies: []        # 不下载任何制品
  script:
    - ls file1.txt        # ❌ 文件不存在
```

### 6.4 跨stage制品传递


```yaml
stages:
  - build
  - test
  - package
  - deploy

# Stage 1: 构建
compile:
  stage: build
  script:
    - gcc -o myapp main.c
  artifacts:
    name: "compiled-$CI_COMMIT_SHORT_SHA"
    paths:
      - myapp
    expire_in: 1 week

# Stage 2: 测试
test:
  stage: test
  dependencies:
    - compile
  script:
    - ./myapp --test

# Stage 3: 打包
package:
  stage: package  
  dependencies:
    - compile
  script:
    - tar -czf myapp.tar.gz myapp
  artifacts:
    name: "package-$CI_COMMIT_SHORT_SHA"
    paths:
      - myapp.tar.gz

# Stage 4: 部署
deploy:
  stage: deploy
  dependencies:
    - package            # 只需要最终包，不需要源文件
  script:
    - scp myapp.tar.gz user@server:/tmp/
```

---

## 7. ⏰ expire_in过期设置


### 7.1 过期时间的重要性


就像食物有保质期一样，制品也需要设置合理的过期时间：

```
🥛 牛奶(日常制品)      → 7天过期  
🥫 罐头(发布版本)      → 6个月过期
🍞 面包(临时文件)      → 1天过期
```

### 7.2 过期时间语法


```yaml
artifacts:
  paths:
    - dist/
  expire_in: 1 week         # 1周后过期

# 支持的时间单位：
# 秒: 30 seconds, 30s
# 分: 30 minutes, 30m  
# 时: 2 hours, 2h
# 天: 3 days, 3d
# 周: 2 weeks, 2w
# 月: 1 month, 1mo  
# 年: 1 year, 1y
```

### 7.3 不同场景的过期策略


**🎯 推荐过期时间设置：**

| 制品类型 | 推荐过期时间 | 理由说明 |
|---------|-------------|---------|
| **构建产物** | `1 week` | 足够排查问题，不占用太多空间 |
| **测试报告** | `2 weeks` | 可能需要回顾分析 |
| **部署包** | `1 month` | 可能需要回滚 |
| **调试日志** | `3 days` | 临时排错用 |
| **发布版本** | `1 year` | 长期保存的正式版本 |

```yaml
# 开发分支：短期保存
develop_build:
  artifacts:
    paths:
      - dist/
    expire_in: 3 days

# 主分支：中期保存  
master_build:
  artifacts:
    paths:
      - dist/
    expire_in: 1 month

# 发布标签：长期保存
release_build:
  only:
    - tags
  artifacts:
    paths:
      - release/
    expire_in: 1 year
```

### 7.4 永不过期设置


```yaml
# 方法1：明确设置never
artifacts:
  paths:
    - important-release.zip
  expire_in: never

# 方法2：不设置expire_in（使用系统默认）
artifacts:
  paths:
    - default-expiry.zip
```

> ⚠️ **谨慎使用永不过期**
> 
> 除非是重要的发布版本，否则建议设置合理的过期时间

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 缓存vs制品：缓存加速构建，制品传递结果
🔸 缓存键设计：基于文件内容的智能缓存最有效  
🔸 制品管理：合理设置路径、报告和过期时间
🔸 依赖声明：明确指定需要的制品，提高效率
🔸 策略选择：根据任务特点选择pull/push/pull-push
```

### 8.2 关键理解要点


**🔹 缓存策略的选择原则**
```
依赖稳定 → 固定键名 → 全局共享
依赖变化 → 文件键名 → 智能更新  
分支开发 → 分支键名 → 隔离开发
多环境 → 前缀键名 → 环境区分
```

**🔹 制品管理的最佳实践**  
```
路径精确：只包含必要文件
过期合理：根据用途设置时间
依赖明确：减少无用下载
报告利用：充分使用GitLab的报告功能
```

**🔹 性能优化思路**
```
缓存命中率 ↑ = 构建时间 ↓ = 开发效率 ↑
制品大小 ↓ = 传输时间 ↓ = 流水线速度 ↑
依赖精确 → 下载减少 → 任务启动快
```

### 8.3 实际应用场景


**📱 前端项目典型配置：**
```yaml
variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"

cache:
  key:
    files:
      - package-lock.json
  paths:
    - .npm/
    - node_modules/

stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - npm ci --cache .npm
    - npm run build
  artifacts:
    name: "website-$CI_COMMIT_SHORT_SHA"
    paths:
      - dist/
    expire_in: 1 week

test:
  stage: test
  dependencies:
    - build
  script:
    - npm run test
  artifacts:
    reports:
      junit: "test-results.xml"
      coverage: "coverage/cobertura.xml"
    expire_in: 2 weeks

deploy:
  stage: deploy
  dependencies:
    - build
  script:
    - rsync -av dist/ user@server:/var/www/
```

### 8.4 故障排查清单


**🔍 缓存不生效检查：**
- ☑️ 缓存键是否正确？
- ☑️ 路径是否存在？
- ☑️ 策略是否合适？
- ☑️ 权限是否足够？

**🔍 制品下载失败检查：**
- ☑️ 前置任务是否成功？
- ☑️ 制品是否已过期？
- ☑️ dependencies配置是否正确？
- ☑️ 路径匹配是否准确？

**核心记忆：**
- 缓存是加速器，制品是传递器
- 键名要智能，路径要精确  
- 依赖要明确，过期要合理
- 策略看场景，优化无止境