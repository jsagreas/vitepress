---
title: 3、Runner配置与管理
---
## 📚 目录

1. [Runner配置文件详解](#1-Runner配置文件详解)
2. [Runner权限设置](#2-Runner权限设置)
3. [Runner标签系统](#3-Runner标签系统)
4. [并发执行配置](#4-并发执行配置)
5. [Runner监控维护](#5-Runner监控维护)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 📄 Runner配置文件详解


### 1.1 配置文件是什么


**简单理解**：就像给机器人写说明书，告诉它怎么干活

┌─ 核心概念 ─────────────────┐
│ **config.toml配置文件**        │
│ 相当于Runner的"工作手册"       │
│ 里面写着：                    │
│ • 连接哪个GitLab服务器        │
│ • 用什么身份去工作            │
│ • 一次能处理几个任务          │
│ • 工作环境怎么准备            │
└────────────────────────────┘

### 1.2 配置文件位置


**不同系统的配置文件放在哪里**：

| 操作系统 | 配置文件路径 | 说明 |
|---------|-------------|------|
| **Linux** | `/etc/gitlab-runner/config.toml` | 系统级别，所有用户共享 |
| **Windows** | `C:\GitLab-Runner\config.toml` | 默认安装位置 |
| **macOS** | `/usr/local/etc/gitlab-runner/config.toml` | Homebrew安装路径 |
| **Docker** | 容器内映射路径 | 通过volume挂载 |

💡 **记忆技巧**：就像每个操作系统都有自己的"文档"文件夹，Runner也有固定的配置文件位置。

### 1.3 配置文件基本结构


**配置文件就像一张表格，分成几个部分**：

```toml
# 全局设置 - 整个Runner的基本信息
concurrent = 4                    # 同时能跑几个任务
check_interval = 0               # 多久检查一次新任务

# Session服务器设置 - 用于调试
[session_server]
  session_timeout = 1800

# 具体的Runner配置 - 可以有多个
[[runners]]
  name = "我的第一个Runner"
  url = "https://gitlab.example.com/"
  token = "xxxx-runner-token-xxxx"
  executor = "docker"
  
  # Docker相关设置
  [runners.docker]
    image = "ubuntu:20.04"
    privileged = false
    volumes = ["/cache"]
```

**用生活例子理解**：
```
config.toml就像餐厅的工作安排表：
┌─────────────────────────────┐
│ 餐厅基本信息：               │
│ • 同时接待4桌客人（concurrent）│
│ • 每5分钟检查有无新客人      │
│                            │
│ 服务员小李的工作安排：        │
│ • 负责2号包厢              │
│ • 用标准化餐具              │
│ • 会做川菜和粤菜            │
└─────────────────────────────┘
```

### 1.4 关键配置参数详解


**🔸 concurrent（并发数）**
```toml
concurrent = 4  # 同时最多跑4个任务
```
**通俗解释**：就像厨师同时能炒几个菜。数字越大，同时处理的任务越多，但也更消耗资源。

**🔸 check_interval（检查间隔）**
```toml
check_interval = 0  # 0表示使用默认值（3秒）
```
**通俗解释**：Runner多久去GitLab问一次"有新活吗？"。时间短反应快，但会增加服务器压力。

**🔸 executor（执行器类型）**
```toml
executor = "docker"  # 使用Docker容器运行任务
```

常见执行器类型：
```
┌─ 执行器对比 ────────────────┐
│ shell    → 直接在服务器上运行 │
│ docker   → 容器中运行（推荐） │
│ kubernetes → K8s集群中运行   │
│ ssh      → 远程服务器运行     │
└────────────────────────────┘
```

### 1.5 实际配置示例


**适合新手的基础配置**：

```toml
# 基础设置
concurrent = 2              # 新手建议先设小一点
check_interval = 5          # 5秒检查一次，不要太频繁

# Runner配置
[[runners]]
  name = "开发环境Runner"
  url = "https://gitlab.com/"
  token = "你的注册token"
  executor = "docker"
  
  # Docker设置
  [runners.docker]
    image = "node:16"          # 默认使用Node.js环境
    privileged = false         # 安全起见，不给特权
    volumes = ["/cache", "/var/run/docker.sock:/var/run/docker.sock:ro"]
    
  # 缓存设置
  [runners.cache]
    Type = "local"
    Path = "/cache"
```

**配置解释**：
- `concurrent = 2`：新手阶段，同时跑2个任务足够了
- `node:16`：选择常用的Node.js环境作为默认
- `privileged = false`：为了安全，不给Docker特权模式
- 缓存设置：提高构建速度，避免重复下载

---

## 2. 🔐 Runner权限设置


### 2.1 权限系统基本概念


**权限就像门禁卡**：不同的卡能进不同的房间

┌─ 权限类比 ─────────────────┐
│ **Runner权限 = 员工工牌**     │
│                            │
│ 🟢 项目级Runner = 部门工牌   │
│    只能进自己部门           │
│                            │
│ 🟨 组级Runner = 大楼工牌     │
│    能进整个公司楼层         │
│                            │
│ 🔴 实例级Runner = 万能钥匙   │
│    能进所有地方（需谨慎）   │
└────────────────────────────┘

### 2.2 Runner权限级别


**🔸 项目级Runner（Specific Runners）**
```
特点：只为特定项目服务
适用：个人项目、小团队项目
安全性：最高（隔离性好）
配置难度：简单
```

**🔸 组级Runner（Group Runners）**
```
特点：为整个组（Group）下的所有项目服务
适用：团队共享、多项目协作
安全性：中等
配置难度：中等
```

**🔸 实例级Runner（Instance Runners）**
```
特点：为整个GitLab实例的所有项目服务
适用：大型组织、公共资源
安全性：需要特别注意
配置难度：复杂
```

### 2.3 Docker权限配置


**🔧 privileged模式**

**什么是privileged模式**：
```
普通模式：就像租房子，有一些限制
特权模式：就像自己的房子，什么都能做
```

**配置对比**：
```toml
# 安全模式（推荐）
[runners.docker]
  privileged = false
  # 只能做基本操作，安全但功能受限

# 特权模式（谨慎使用）
[runners.docker]
  privileged = true
  # 几乎无限制，功能强大但存在安全风险
```

**什么时候需要特权模式**：
- 🔸 需要构建Docker镜像（Docker in Docker）
- 🔸 需要修改系统配置
- 🔸 需要访问硬件设备

### 2.4 网络权限配置


**Docker网络配置**：

```toml
[runners.docker]
  # 网络模式设置
  network_mode = "bridge"           # 默认桥接模式
  # network_mode = "host"           # 主机网络模式
  # network_mode = "none"           # 无网络模式
  
  # DNS设置
  dns = ["8.8.8.8", "114.114.114.114"]
  
  # 额外主机映射
  extra_hosts = ["example.com:127.0.0.1"]
```

**通俗解释**：
- `bridge`模式：就像住在小区里，有独立网络但能上外网
- `host`模式：就像住在路边，直接使用主机网络
- `none`模式：就像与世隔绝，没有网络连接

### 2.5 安全最佳实践


**🛡️ 安全建议清单**：

☐ **最小权限原则**
```
只给Runner最必要的权限，不要图方便全部开放
```

☐ **定期更换Token**
```toml
# 定期重新注册Runner，更换认证token
gitlab-runner register --url xxx --registration-token xxx
```

☐ **使用专用用户**
```bash
# Linux下为Runner创建专用用户
sudo useradd --system --shell /bin/bash --home /home/gitlab-runner gitlab-runner
```

☐ **限制资源使用**
```toml
[runners.docker]
  # 限制内存使用
  memory = "2g"
  # 限制CPU使用
  cpus = "1.5"
```

---

## 3. 🏷️ Runner标签系统


### 3.1 标签系统是什么


**标签就像给Runner贴名牌**：

```
比如餐厅服务员的名牌：
┌─────────────────┐
│ 👤 服务员小王   │
│ 🍝 擅长：意大利菜│
│ 🌶️ 特长：川菜   │
│ 🕐 班次：早班   │
│ 💪 体力：重活OK  │
└─────────────────┘

Runner标签也类似：
┌─────────────────┐
│ 🖥️ Runner-01    │
│ 🐧 系统：linux   │
│ 🐳 环境：docker  │
│ ⚡ 性能：高配置   │
│ 🔧 用途：构建专用 │
└─────────────────┘
```

### 3.2 标签的作用机制


**工作原理**：Pipeline需要什么，就找对应标签的Runner

```
工作流程：
GitLab项目 → 查看.gitlab-ci.yml → 找到tags → 匹配Runner → 执行任务

示例：
.gitlab-ci.yml中写着：tags: ["docker", "linux"]
GitLab会找：既有"docker"标签又有"linux"标签的Runner
```

### 3.3 常用标签分类


**🔸 按操作系统分类**：
```
linux    → Linux系统Runner
windows  → Windows系统Runner
macos    → macOS系统Runner
```

**🔸 按执行环境分类**：
```
docker     → 支持Docker的Runner
kubernetes → K8s集群Runner
shell      → 直接在系统上运行
```

**🔸 按用途分类**：
```
build      → 专门用于构建
test       → 专门用于测试
deploy     → 专门用于部署
security   → 专门用于安全扫描
```

**🔸 按性能分类**：
```
high-cpu    → CPU密集型任务
high-memory → 内存密集型任务
gpu         → GPU加速任务
fast-ssd    → 快速存储任务
```

### 3.4 标签配置实例


**注册时设置标签**：
```bash
# 注册Runner时指定标签
gitlab-runner register \
  --url "https://gitlab.com/" \
  --registration-token "your-token" \
  --description "Docker构建专用Runner" \
  --tag-list "docker,linux,build,high-cpu"
```

**在配置文件中修改标签**：
```toml
[[runners]]
  name = "构建专用Runner"
  url = "https://gitlab.com/"
  token = "runner-token"
  executor = "docker"
  
  # 标签配置
  tags = ["docker", "linux", "build", "nodejs"]
```

### 3.5 标签最佳实践


**🎯 标签命名建议**：

```
好的标签命名：
✅ linux          → 清晰明确
✅ docker          → 技术栈相关
✅ build-server    → 功能明确
✅ high-memory     → 性能特征

避免的标签命名：
❌ runner1         → 没有意义
❌ test            → 过于宽泛
❌ 我的Runner      → 个人化
❌ temp           → 临时性质
```

**🔧 标签组合策略**：

```toml
# 开发环境Runner
tags = ["dev", "docker", "linux", "node"]

# 生产环境Runner  
tags = ["prod", "kubernetes", "linux", "high-performance"]

# 测试专用Runner
tags = ["test", "docker", "chrome", "selenium"]

# 多用途Runner
tags = ["general", "docker", "linux", "python", "node"]
```

**📋 标签管理清单**：

☐ **保持一致性**：团队使用统一的标签规范
☐ **定期清理**：删除不再使用的标签
☐ **文档记录**：维护标签说明文档
☐ **合理数量**：每个Runner不超过10个标签

---

## 4. ⚡ 并发执行配置


### 4.1 并发执行基本概念


**什么是并发**：同时做多件事情

```
生活例子：
┌─ 串行工作（一次只能做一件事）────┐
│ 洗菜 → 切菜 → 炒菜 → 装盘     │
│ 总时间：40分钟                │
└─────────────────────────────┘

┌─ 并行工作（同时做多件事）──────┐
│ 小明：洗菜 → 切菜             │
│ 小红：     炒菜 → 装盘         │
│ 总时间：20分钟                │
└─────────────────────────────┘
```

**Runner并发同理**：
- **串行**：一个任务结束后才开始下一个
- **并发**：多个任务同时进行

### 4.2 全局并发配置


**配置文件中的并发设置**：

```toml
# 全局配置：整个Runner最多同时跑几个任务
concurrent = 4

# 检查间隔：多久检查一次有无新任务（秒）
check_interval = 3
```

**如何选择并发数**：

| 服务器配置 | 建议并发数 | 说明 |
|-----------|-----------|------|
| **2核4G** | 1-2 | 轻量级任务 |
| **4核8G** | 2-4 | 中等负载 |
| **8核16G** | 4-8 | 重度构建 |
| **16核32G** | 8-16 | 大型项目 |

💡 **选择技巧**：
- CPU密集型任务：并发数 ≈ CPU核心数
- IO密集型任务：并发数可以稍大于CPU核心数
- 混合任务：从小数字开始，逐步调整

### 4.3 单个Runner并发限制


**为特定Runner设置并发限制**：

```toml
[[runners]]
  name = "开发环境Runner"
  url = "https://gitlab.com/"
  token = "runner-token"
  executor = "docker"
  
  # 这个Runner最多同时跑2个任务
  limit = 2
  
  [runners.docker]
    image = "ubuntu:20.04"
```

**实际应用场景**：
```
场景1：资源限制
服务器配置较低，需要限制单个Runner的并发数

场景2：稳定性要求
生产环境Runner，为保证稳定性限制并发

场景3：特殊用途
部署专用Runner，同时只能有一个部署任务
```

### 4.4 Docker并发配置


**Docker执行器的并发设置**：

```toml
[runners.docker]
  # 容器相关并发设置
  image = "ubuntu:20.04"
  
  # 禁用容器自动清理（需要手动管理）
  disable_cache = false
  
  # 容器网络设置
  network_mode = "bridge"
  
  # 容器资源限制
  memory = "1g"        # 每个容器最多使用1G内存
  cpus = "0.5"         # 每个容器最多使用0.5个CPU
```

**资源计算示例**：
```
服务器配置：8核16G内存
concurrent = 4（同时4个任务）
每容器限制：2G内存，1个CPU

理论最大资源使用：
内存：4 × 2G = 8G（还剩8G给系统）
CPU：4 × 1 = 4核（还剩4核给系统）
```

### 4.5 监控并发性能


**性能监控指标**：

```bash
# 查看Runner状态
gitlab-runner status

# 查看系统资源使用
top
htop
docker stats

# 查看Runner日志
gitlab-runner --debug run
```

**性能调优建议**：

```
🔸 CPU使用率持续90%以上
→ 减少并发数或增加CPU

🔸 内存使用率持续85%以上  
→ 减少并发数或增加内存

🔸 任务排队时间过长
→ 增加并发数或增加Runner数量

🔸 任务失败率较高
→ 检查资源不足问题
```

**监控配置示例**：
```toml
# 开启监控指标
[[runners]]
  url = "https://gitlab.com/"
  token = "runner-token"
  executor = "docker"
  
  # 开启Prometheus监控
  [runners.monitoring]
    enabled = true
    listen_address = ":9252"
```

---

## 5. 📊 Runner监控维护


### 5.1 监控的重要性


**为什么要监控Runner**：

```
就像医生定期体检一样：
┌─────────────────────────────┐
│ 🏥 体检目的                │
│ • 发现潜在问题              │
│ • 预防严重故障              │
│ • 保持最佳状态              │
│ • 延长设备寿命              │
└─────────────────────────────┘

Runner监控同理：
┌─────────────────────────────┐
│ 🔍 监控目的                │
│ • 及时发现故障              │
│ • 优化性能配置              │
│ • 预防资源耗尽              │
│ • 保证CI/CD稳定             │
└─────────────────────────────┘
```

### 5.2 基础状态监控


**查看Runner基本状态**：

```bash
# 查看所有Runner状态
gitlab-runner status

# 输出示例：
Runtime platform: linux/amd64
gitlab-runner version: 15.3.0
Running 2 runners
Runner status: online
```

**状态说明**：
- `online`：Runner正常运行，可以接收任务
- `offline`：Runner离线，无法接收任务
- `paused`：Runner暂停，手动停止接收任务

### 5.3 详细运行日志


**查看详细日志**：

```bash
# 查看实时日志
gitlab-runner --debug run

# 查看服务日志（systemd系统）
journalctl -u gitlab-runner -f

# 查看日志文件（如果配置了日志文件）
tail -f /var/log/gitlab-runner/gitlab-runner.log
```

**日志内容解读**：
```
正常日志示例：
INFO: Checking for jobs... requesting jobs... job=123 project=456
INFO: Starting job... job=123 project=456
INFO: Executing job... job=123 project=456
INFO: Job succeeded... job=123 project=456

异常日志示例：
ERROR: Failed to connect to GitLab... 
WARN: Job failed with exit code 1... job=123
ERROR: Docker image pull failed...
```

### 5.4 系统资源监控


**🔸 CPU和内存监控**：

```bash
# 查看实时系统资源
htop

# 查看Docker容器资源使用
docker stats

# 查看磁盘使用情况
df -h
du -sh /var/lib/docker
```

**资源监控脚本示例**：
```bash
#!/bin/bash
# runner-monitor.sh - Runner资源监控脚本

echo "=== GitLab Runner 资源监控 ==="
echo "时间: $(date)"
echo ""

# CPU使用率
cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
echo "CPU使用率: ${cpu_usage}%"

# 内存使用率
mem_usage=$(free | grep Mem | awk '{printf("%.1f"), $3/$2 * 100.0}')
echo "内存使用率: ${mem_usage}%"

# 磁盘使用率
disk_usage=$(df / | tail -1 | awk '{print $5}')
echo "磁盘使用率: ${disk_usage}"

# Runner状态
runner_status=$(gitlab-runner status | grep "Runner status")
echo "Runner状态: ${runner_status}"

echo ""
echo "==============================="
```

### 5.5 自动化维护脚本


**🔧 定期清理脚本**：

```bash
#!/bin/bash
# runner-cleanup.sh - Runner清理维护脚本

echo "开始Runner维护清理..."

# 清理Docker无用镜像
echo "清理Docker镜像..."
docker image prune -f

# 清理Docker无用容器
echo "清理Docker容器..."
docker container prune -f

# 清理Docker构建缓存
echo "清理构建缓存..."
docker builder prune -f

# 清理Runner缓存（如果使用本地缓存）
echo "清理Runner缓存..."
rm -rf /tmp/gitlab-runner-cache/*

# 检查磁盘空间
echo "检查磁盘空间..."
df -h

echo "清理完成！"
```

**设置定时任务**：
```bash
# 编辑crontab
crontab -e

# 添加定时清理任务（每天凌晨2点执行）
0 2 * * * /path/to/runner-cleanup.sh >> /var/log/runner-cleanup.log 2>&1
```

### 5.6 故障排查指南


**🚨 常见问题及解决方法**：

**问题1：Runner突然离线**
```
排查步骤：
1. 检查网络连接：ping gitlab.com
2. 检查Runner进程：ps aux | grep gitlab-runner
3. 检查系统资源：free -h, df -h
4. 重启Runner服务：sudo systemctl restart gitlab-runner
```

**问题2：任务执行失败**
```
排查步骤：
1. 查看任务日志：GitLab Web界面查看失败原因
2. 检查Runner日志：journalctl -u gitlab-runner
3. 检查Docker状态：docker info
4. 测试Runner连接：gitlab-runner verify
```

**问题3：性能下降**
```
排查步骤：
1. 检查并发设置：config.toml中的concurrent值
2. 监控资源使用：htop, docker stats
3. 清理缓存和无用文件
4. 考虑增加硬件资源或新增Runner
```

### 5.7 监控告警配置


**设置简单的监控告警**：

```bash
#!/bin/bash
# runner-alert.sh - Runner告警脚本

# 配置告警阈值
CPU_THRESHOLD=80
MEMORY_THRESHOLD=85
DISK_THRESHOLD=90

# 获取当前使用率
cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1)
mem_usage=$(free | grep Mem | awk '{printf("%.0f"), $3/$2 * 100.0}')
disk_usage=$(df / | tail -1 | awk '{print $5}' | cut -d'%' -f1)

# 检查并发送告警
if [ "$cpu_usage" -gt "$CPU_THRESHOLD" ]; then
    echo "警告：CPU使用率过高 ${cpu_usage}%" | mail -s "Runner告警" admin@example.com
fi

if [ "$mem_usage" -gt "$MEMORY_THRESHOLD" ]; then
    echo "警告：内存使用率过高 ${mem_usage}%" | mail -s "Runner告警" admin@example.com
fi

if [ "$disk_usage" -gt "$DISK_THRESHOLD" ]; then
    echo "警警：磁盘使用率过高 ${disk_usage}%" | mail -s "Runner告警" admin@example.com
fi
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 配置文件：config.toml是Runner的"说明书"，控制所有行为
🔸 权限管理：最小权限原则，根据需要给予相应权限
🔸 标签系统：合理使用标签，实现任务的精准分配
🔸 并发控制：根据硬件资源合理设置并发数量
🔸 监控维护：定期检查、及时清理、预防故障
```

### 6.2 关键理解要点


**🔹 配置文件的层次结构**
```
全局设置 → 影响整个Runner
Runner设置 → 影响特定Runner
执行器设置 → 影响执行环境
```

**🔹 权限设置的安全考虑**
```
项目级：最安全，优先选择
组级：平衡性能和安全
实例级：功能强大，需谨慎使用
```

**🔹 标签系统的设计原则**
```
清晰命名：让人一看就懂
分类合理：按系统、环境、用途分类
数量适中：每个Runner不超过10个标签
文档完善：团队共享标签规范
```

### 6.3 实际应用价值


**🎯 新手学习路径**：
1. **第一步**：学会基础配置，让Runner跑起来
2. **第二步**：理解权限机制，确保安全使用
3. **第三步**：掌握标签系统，实现精准任务分配
4. **第四步**：优化并发配置，提高执行效率
5. **第五步**：建立监控体系，保证稳定运行

**🛠️ 生产环境检查清单**：
☐ 配置文件备份完成
☐ 权限设置符合最小原则
☐ 标签规范团队统一
☐ 并发数量合理设置
☐ 监控告警机制建立
☐ 定期维护计划制定

**🔧 常用命令速查**：
```bash
# 查看状态
gitlab-runner status

# 注册Runner
gitlab-runner register

# 验证配置
gitlab-runner verify

# 查看日志
gitlab-runner --debug run

# 重启服务
sudo systemctl restart gitlab-runner
```

### 6.4 进阶学习方向


**🚀 下一步可以学习**：
- **高级执行器**：Kubernetes、SSH执行器配置
- **缓存优化**：分布式缓存、缓存策略设计
- **安全加固**：网络隔离、镜像安全扫描
- **自动化运维**：Ansible、Terraform管理Runner
- **监控告警**：Prometheus + Grafana监控方案

**核心记忆**：
- Runner配置要规范，安全权限是关键
- 标签系统巧运用，任务分配不混乱  
- 并发设置要合理，监控维护保稳定
- 新手起步重基础，循序渐进最重要