---
title: 6、GitLab Runner配置管理
---
## 📚 目录

1. [Runner配置文件基础](#1-Runner配置文件基础)
2. [Runner注册与配置参数](#2-Runner注册与配置参数)
3. [执行器类型详解](#3-执行器类型详解)
4. [Docker镜像配置策略](#4-Docker镜像配置策略)
5. [性能与并发配置](#5-性能与并发配置)
6. [标签与权限管理](#6-标签与权限管理)
7. [健康检查与监控](#7-健康检查与监控)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 Runner配置文件基础


### 1.1 配置文件位置与作用


**💡 什么是config.toml文件？**
想象一下，GitLab Runner就像是一个工人，而`config.toml`就是这个工人的"工作手册"。这个手册告诉工人：
- 🏠 去哪里接活（GitLab服务器地址）
- 🆔 用什么身份证明（认证token）
- 🛠️ 用什么工具干活（执行器类型）
- ⚡ 同时能干几件事（并发数）

**📍 配置文件位置**
```
Linux系统：   /etc/gitlab-runner/config.toml
Windows系统： C:\GitLab-Runner\config.toml
macOS系统：   /usr/local/etc/gitlab-runner/config.toml
Docker容器：  /etc/gitlab-runner/config.toml
```

### 1.2 配置文件结构解析


**🏗️ 配置文件的层次结构**
```
config.toml 配置文件
├── 全局配置 (concurrent, check_interval等)
├── Runner配置1 ([[runners]])
│   ├── 基本信息 (name, url, token)
│   ├── 执行器配置 (executor)
│   └── 执行器特定配置 ([runners.docker]等)
├── Runner配置2 ([[runners]])
└── Runner配置N ([[runners]])
```

**📋 基本配置文件示例**
```toml
# 全局设置：同时运行的任务数
concurrent = 4

# 检查新任务的间隔时间（秒）
check_interval = 30

# 会话服务器配置（用于交互式调试）
[session_server]
  session_timeout = 1800

# 第一个Runner配置
[[runners]]
  name = "my-docker-runner"           # Runner名称
  url = "https://gitlab.com/"         # GitLab实例地址
  token = "your-runner-token"         # 注册后的认证token
  executor = "docker"                 # 执行器类型
  
  # Docker执行器特定配置
  [runners.docker]
    image = "node:16"                 # 默认镜像
    privileged = false                # 是否特权模式
    volumes = ["/cache"]              # 挂载卷
```

### 1.3 配置文件的管理方式


**🔒 配置文件权限设置**
```bash
# 设置适当的文件权限（仅root和gitlab-runner用户可读写）
sudo chmod 600 /etc/gitlab-runner/config.toml
sudo chown gitlab-runner:gitlab-runner /etc/gitlab-runner/config.toml
```

**🔄 配置修改生效方式**

| 修改方式 | **何时生效** | **适用场景** |
|---------|-------------|-------------|
| `直接编辑config.toml` | `重启服务后` | `批量修改配置` |
| `gitlab-runner register` | `立即生效` | `添加新Runner` |
| `gitlab-runner unregister` | `立即生效` | `删除Runner` |

---

## 2. 🎯 Runner注册与配置参数


### 2.1 Runner注册流程详解


**🤝 什么是Runner注册？**
把Runner注册想象成"求职面试"的过程：
1. **📝 投简历**：向GitLab申请成为Runner
2. **🎫 拿到工作证**：获得registration token
3. **✅ 正式入职**：完成注册获得runner token
4. **🏃 开始工作**：Runner开始执行CI/CD任务

**📊 注册流程图示**
```
GitLab项目/组织              GitLab Runner
     |                           |
     |--[1]获取注册Token--------->|
     |   (Settings > CI/CD)      |
     |                           |
     |<--[2]发起注册请求----------|
     |   gitlab-runner register  |
     |                           |
     |--[3]返回Runner Token------>|
     |   (用于后续认证)           |
     |                           |
     |<--[4]开始接收任务----------|
     |   Runner正式工作           |
```

### 2.2 注册命令详解


**🔨 基本注册命令**
```bash
sudo gitlab-runner register \
  --url "https://gitlab.com/" \                    # GitLab实例地址
  --registration-token "your-registration-token" \ # 注册Token
  --description "My Docker Runner" \               # Runner描述
  --tag-list "docker,node,production" \           # 标签列表
  --executor "docker" \                           # 执行器类型
  --docker-image "node:16"                        # 默认Docker镜像
```

**⚙️ 注册参数详细说明**

| 参数 | **说明** | **示例** | **必填** |
|------|---------|---------|---------|
| `--url` | `GitLab实例地址` | `https://gitlab.com/` | `✅ 是` |
| `--registration-token` | `项目注册Token` | `GR1348xxx...` | `✅ 是` |
| `--description` | `Runner描述名称` | `Production Docker Runner` | `❌ 否` |
| `--tag-list` | `Runner标签` | `docker,node,prod` | `❌ 否` |
| `--executor` | `执行器类型` | `docker/shell/ssh` | `✅ 是` |
| `--docker-image` | `默认Docker镜像` | `ubuntu:20.04` | `🔶 Docker执行器需要` |

### 2.3 交互式注册演示


**💬 注册过程实际对话**
```bash
$ sudo gitlab-runner register

请输入GitLab实例URL (例如 https://gitlab.com/):
https://gitlab.com/

请输入注册token:
GR1348941abc123def456

请输入此Runner的描述:
My First Docker Runner

请输入此Runner的标签 (用逗号分隔):
docker,node,web

请输入执行器: docker, docker-ssh, shell, ssh:
docker

请输入默认Docker镜像:
node:16

✅ Runner注册成功！
```

---

## 3. 🚀 执行器类型详解


### 3.1 执行器概念理解


**🎭 什么是执行器？**
执行器就像是"不同类型的工作环境"：
- 🐳 **Docker执行器**：就像在"集装箱"里工作，干净、隔离、可重复
- 🖥️ **Shell执行器**：直接在"办公室"里工作，简单但可能互相影响
- 🔗 **SSH执行器**：远程到"其他办公室"工作
- ☸️ **Kubernetes执行器**：在"工厂车间"里工作，资源管理更精细

### 3.2 Docker执行器配置


**🐳 Docker执行器 - 最常用的选择**

> 💡 **为什么推荐Docker执行器？**
> 
> Docker执行器就像"标准化的生产线"，每次任务都在全新、干净的环境中执行，避免了"上一个任务留下的垃圾影响下一个任务"的问题。

**📝 Docker执行器完整配置**
```toml
[[runners]]
  name = "docker-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  
  [runners.docker]
    # 基础镜像配置
    image = "ubuntu:20.04"              # 默认镜像
    privileged = false                  # 是否开启特权模式
    
    # 资源限制
    memory = "2g"                       # 内存限制
    cpus = "1.0"                        # CPU限制
    
    # 卷挂载配置
    volumes = [
      "/var/run/docker.sock:/var/run/docker.sock",  # Docker-in-Docker
      "/cache:/cache"                               # 缓存目录
    ]
    
    # 网络配置
    network_mode = "host"               # 网络模式
    extra_hosts = ["gitlab.local:192.168.1.100"]
    
    # 镜像拉取策略
    pull_policy = ["if-not-present"]    # never, if-not-present, always
```

**🔧 Docker配置参数说明**

| 配置项 | **作用** | **推荐值** | **注意事项** |
|--------|---------|-----------|-------------|
| `privileged` | `特权模式开关` | `false` | `仅在需要Docker-in-Docker时开启` |
| `memory` | `内存限制` | `2g-4g` | `根据任务复杂度调整` |
| `pull_policy` | `镜像拉取策略` | `if-not-present` | `节省拉取时间` |
| `volumes` | `卷挂载` | `["/cache"]` | `用于缓存依赖包` |

### 3.3 Shell执行器配置


**🖥️ Shell执行器 - 简单直接的选择**

> ⚠️ **Shell执行器使用注意**
> 
> Shell执行器就像"直接在自己电脑上工作"，简单但要小心：不同任务可能会互相影响，需要做好清理工作。

```toml
[[runners]]
  name = "shell-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "shell"
  
  [runners.custom_build_dir]
    enabled = true                      # 启用自定义构建目录
    
  [runners.cache]
    Type = "local"                      # 本地缓存
    Path = "/tmp/gitlab-runner-cache"   # 缓存路径
```

### 3.4 执行器选择指南


**🎯 执行器选择决策树**
```
开始选择执行器
    ↓
需要环境隔离？
    ↓Yes                    ↓No
需要Kubernetes？           使用Shell执行器
    ↓Yes        ↓No         (简单项目)
Kubernetes   Docker执行器
执行器        (推荐选择)
```

**📊 执行器对比表**

| 执行器类型 | **隔离性** | **性能** | **配置复杂度** | **适用场景** |
|-----------|----------|---------|-------------|-------------|
| 🐳 **Docker** | `⭐⭐⭐⭐⭐` | `⭐⭐⭐⭐` | `⭐⭐⭐` | `生产环境推荐` |
| 🖥️ **Shell** | `⭐⭐` | `⭐⭐⭐⭐⭐` | `⭐` | `简单项目快速开始` |
| ☸️ **Kubernetes** | `⭐⭐⭐⭐⭐` | `⭐⭐⭐` | `⭐⭐⭐⭐⭐` | `大规模容器化部署` |
| 🔗 **SSH** | `⭐⭐⭐` | `⭐⭐⭐` | `⭐⭐⭐⭐` | `远程服务器执行` |

---

## 4. 🐳 Docker镜像配置策略


### 4.1 镜像选择原则


**🎨 如何选择合适的Docker镜像？**
选择Docker镜像就像"选择合适的工具箱"：
- 🔧 **基础镜像**：只有最基本的工具（ubuntu, alpine）
- 🛠️ **语言镜像**：预装了特定编程语言（node, python, java）
- 🏭 **专用镜像**：为特定任务定制（包含编译工具、测试框架等）

### 4.2 常用镜像配置示例


**📋 不同项目类型的镜像推荐**

| 项目类型 | **推荐镜像** | **说明** | **额外配置** |
|---------|-------------|---------|-------------|
| `Node.js项目` | `node:16-alpine` | `轻量级，包含npm/yarn` | `缓存node_modules` |
| `Python项目` | `python:3.9-slim` | `包含pip，体积较小` | `缓存pip包` |
| `Java项目` | `openjdk:11-jdk` | `包含JDK和Maven` | `缓存.m2目录` |
| `前端项目` | `node:16-alpine` | `用于构建和测试` | `缓存依赖包` |
| `通用项目` | `ubuntu:20.04` | `灵活性最高` | `需要安装依赖` |

**🔧 Node.js项目配置示例**
```toml
[[runners]]
  name = "nodejs-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  
  [runners.docker]
    image = "node:16-alpine"
    
    # 缓存node_modules提升构建速度
    volumes = [
      "/cache/node_modules:/cache/node_modules"
    ]
    
    # 设置npm镜像源（国内用户）
    environment = [
      "NPM_CONFIG_REGISTRY=https://registry.npmmirror.com"
    ]
```

### 4.3 镜像拉取优化


**⚡ 提升镜像拉取速度的方法**

**1️⃣ 配置镜像拉取策略**
```toml
[runners.docker]
  # 优先使用本地镜像，不存在时才拉取
  pull_policy = ["if-not-present"]
  
  # 或者永不拉取（需要手动预拉取镜像）
  # pull_policy = ["never"]
```

**2️⃣ 配置Docker镜像仓库加速**
```bash
# 编辑Docker守护进程配置
sudo vim /etc/docker/daemon.json

{
  "registry-mirrors": [
    "https://docker.mirrors.ustc.edu.cn",
    "https://hub-mirror.c.163.com"
  ]
}

# 重启Docker服务
sudo systemctl restart docker
```

**3️⃣ 预拉取常用镜像**
```bash
# 预拉取项目常用的镜像
docker pull node:16-alpine
docker pull ubuntu:20.04
docker pull python:3.9-slim

# 查看本地镜像
docker images
```

### 4.4 自定义镜像最佳实践


**🏗️ 何时需要自定义镜像？**
当项目需要：
- 📦 特定版本的多个工具组合
- 🔧 复杂的环境配置
- ⚡ 减少每次任务的安装时间

**📝 自定义镜像Dockerfile示例**
```dockerfile
# 基于官方Node.js镜像
FROM node:16-alpine

# 安装额外工具
RUN apk add --no-cache \
    git \
    curl \
    python3 \
    make \
    g++

# 设置工作目录
WORKDIR /app

# 预安装全局依赖
RUN npm install -g @vue/cli typescript

# 设置环境变量
ENV NODE_ENV=production
ENV NPM_CONFIG_REGISTRY=https://registry.npmmirror.com

# 创建缓存目录
RUN mkdir -p /cache/node_modules && \
    chmod 777 /cache
```

---

## 5. ⚡ 性能与并发配置


### 5.1 并发数配置详解


**🚦 什么是并发数？**
并发数就像"公司同时能接几个项目"：
- 💪 **并发数高**：能同时处理多个任务，效率高，但消耗资源多
- 🐌 **并发数低**：一次只能处理少数任务，稳定但可能有等待
- ⚖️ **合理设置**：根据服务器性能和任务特点平衡

**📊 并发数设置策略**

| 服务器配置 | **推荐并发数** | **说明** | **监控指标** |
|-----------|-------------|---------|-------------|
| `2核4G内存` | `2-3` | `轻量级项目` | `CPU<80%, 内存<80%` |
| `4核8G内存` | `4-6` | `中等项目` | `CPU<70%, 内存<70%` |
| `8核16G内存` | `8-12` | `大型项目` | `CPU<60%, 内存<60%` |
| `16核32G内存` | `12-20` | `企业级` | `根据实际负载调整` |

### 5.2 并发配置实践


**⚙️ 全局并发配置**
```toml
# 全局最大并发任务数
concurrent = 6

# 检查新任务的间隔（秒）
check_interval = 30

# 日志级别：debug, info, warn, error, fatal, panic
log_level = "info"
```

**🎯 单个Runner限制配置**
```toml
[[runners]]
  name = "limited-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  
  # 此Runner最大并发数
  limit = 2
  
  # 请求并发数（向GitLab请求任务的并发数）
  request_concurrency = 1
```

### 5.3 性能监控与调优


**📈 性能监控指标**
```bash
# 查看Runner状态
sudo gitlab-runner status

# 查看Runner进程资源使用
ps aux | grep gitlab-runner

# 查看系统资源使用
htop
# 或者
top

# 查看Docker容器资源使用
docker stats
```

**🔧 性能调优建议**

**CPU优化**
```toml
[runners.docker]
  # 限制单个容器CPU使用
  cpus = "2.0"
  
  # CPU权重设置
  cpu_shares = 1024
```

**内存优化**
```toml
[runners.docker]
  # 限制容器内存使用
  memory = "2g"
  
  # 禁用交换分区使用
  memory_swap = "2g"
```

**磁盘IO优化**
```toml
[runners.docker]
  # 使用更快的存储驱动
  volumes = [
    "/tmp/gitlab-runner-cache:/cache:rw"
  ]
  
  # 禁用不必要的写入
  tmpfs = {
    "/tmp": "noexec,nosuid,size=100m"
  }
```

---

## 6. 🏷️ 标签与权限管理


### 6.1 标签系统详解


**🏷️ 什么是Runner标签？**
Runner标签就像"技能标签"，告诉GitLab这个Runner擅长做什么：
- 🐳 **技术标签**：docker, kubernetes, shell
- 🌍 **环境标签**：development, staging, production
- 💻 **平台标签**：linux, windows, macos
- 🎯 **项目标签**：frontend, backend, mobile

### 6.2 标签配置策略


**📋 标签命名最佳实践**

| 标签类型 | **示例** | **用途** | **注意事项** |
|---------|---------|---------|-------------|
| `执行器类型` | `docker`, `shell` | `指定运行环境` | `与executor对应` |
| `编程语言` | `nodejs`, `python`, `java` | `语言特定任务` | `版本无关命名` |
| `部署环境` | `dev`, `staging`, `prod` | `环境隔离` | `权限分级管理` |
| `特殊功能` | `gpu`, `high-memory` | `特殊资源需求` | `硬件能力标识` |

**⚙️ 标签配置示例**
```toml
[[runners]]
  name = "production-docker-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  
  # 多个标签用逗号分隔
  tags = ["docker", "production", "nodejs", "linux"]
  
  # 是否运行无标签的任务
  run_untagged = false
```

### 6.3 权限管理配置


**🔒 Runner权限级别**

**项目级Runner**
```
作用范围：仅限单个项目
安全级别：⭐⭐⭐⭐⭐ (最安全)
配置复杂度：⭐ (最简单)
资源共享：❌ (不共享)
```

**组级Runner**
```
作用范围：组内所有项目
安全级别：⭐⭐⭐⭐ (较安全)
配置复杂度：⭐⭐ (中等)
资源共享：✅ (组内共享)
```

**实例级Runner**
```
作用范围：整个GitLab实例
安全级别：⭐⭐⭐ (需谨慎)
配置复杂度：⭐⭐⭐ (复杂)
资源共享：✅ (全局共享)
```

**🛡️ 安全配置建议**
```toml
[[runners]]
  name = "secure-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  
  # 仅运行带标签的任务（提高安全性）
  run_untagged = false
  
  # 限制能运行的项目（通过标签控制）
  tags = ["trusted-project", "production"]
  
  [runners.docker]
    # 禁用特权模式（安全）
    privileged = false
    
    # 限制网络访问
    network_mode = "none"
    
    # 只读根文件系统
    read_only = true
```

---

## 7. 🏥 健康检查与监控


### 7.1 健康检查配置


**💓 什么是健康检查？**
健康检查就像"定期体检"，确保Runner始终处于良好状态：
- 🔍 **检查连接**：能否正常连接到GitLab
- 📊 **检查资源**：CPU、内存、磁盘使用情况
- 🔧 **检查功能**：能否正常执行任务

**⚙️ 健康检查配置**
```toml
# 全局健康检查设置
concurrent = 4
check_interval = 30        # 每30秒检查一次新任务
log_level = "info"         # 日志级别

# 会话服务器（用于调试）
[session_server]
  listen_address = ":8093"
  advertise_address = "runner.example.com:8093"
  session_timeout = 1800   # 会话超时时间（秒）

[[runners]]
  name = "monitored-runner"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  
  # Runner特定的健康检查
  [runners.docker]
    # 容器健康检查
    wait_for_services_timeout = 300
    
    # 网络连接检查
    network_mode = "bridge"
```

### 7.2 监控指标收集


**📊 关键监控指标**

**系统级指标**
```bash
# CPU使用率
cat /proc/loadavg

# 内存使用情况
free -h

# 磁盘使用情况
df -h

# Runner进程状态
sudo systemctl status gitlab-runner
```

**Runner级指标**
```bash
# 查看Runner列表和状态
sudo gitlab-runner list

# 验证Runner配置
sudo gitlab-runner verify

# 查看Runner日志
sudo journalctl -u gitlab-runner -f

# 或者查看日志文件
tail -f /var/log/gitlab-runner/gitlab-runner.log
```

**任务级指标**
```bash
# 查看正在运行的任务
docker ps

# 查看任务资源使用
docker stats

# 查看任务日志
docker logs <container_id>
```

### 7.3 故障排查指南


**🔧 常见问题诊断**

**问题1：Runner离线**
```bash
# 检查网络连接
ping gitlab.com

# 检查Runner状态
sudo gitlab-runner status

# 重启Runner服务
sudo gitlab-runner restart

# 查看错误日志
sudo journalctl -u gitlab-runner --since "1 hour ago"
```

**问题2：任务执行失败**
```bash
# 验证Runner配置
sudo gitlab-runner verify

# 测试Docker连接
docker run --rm hello-world

# 检查镜像是否可用
docker pull ubuntu:20.04
```

**问题3：性能问题**
```bash
# 检查系统负载
htop

# 检查磁盘空间
df -h

# 清理Docker资源
docker system prune -a
```

**🚨 告警配置建议**
```bash
#!/bin/bash
# Runner健康检查脚本

# 检查Runner状态
if ! sudo gitlab-runner status | grep -q "alive"; then
    echo "ALERT: GitLab Runner is not running!"
    # 发送告警通知
fi

# 检查磁盘空间
DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
if [ $DISK_USAGE -gt 80 ]; then
    echo "ALERT: Disk usage is ${DISK_USAGE}%"
fi

# 检查内存使用
MEMORY_USAGE=$(free | awk 'NR==2{printf "%.2f", $3*100/$2}')
if (( $(echo "$MEMORY_USAGE > 90" | bc -l) )); then
    echo "ALERT: Memory usage is ${MEMORY_USAGE}%"
fi
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 config.toml：Runner的"工作手册"，包含所有配置信息
🔸 执行器类型：Docker(推荐)、Shell(简单)、Kubernetes(企业级)
🔸 并发配置：平衡性能与资源，避免过载
🔸 标签系统：精确匹配任务与Runner能力
🔸 权限管理：project < group < instance，安全第一
🔸 健康检查：预防胜于治疗，主动监控
```

### 8.2 关键配置要点


**🔹 新手必备配置**
```toml
# 最小可用配置
concurrent = 2
check_interval = 30

[[runners]]
  name = "my-first-runner"
  url = "https://gitlab.com/"
  token = "your-token"
  executor = "docker"
  tags = ["docker", "linux"]
  
  [runners.docker]
    image = "ubuntu:20.04"
    privileged = false
    volumes = ["/cache"]
```

**🔹 生产环境配置**
```toml
# 生产级配置
concurrent = 8
check_interval = 30
log_level = "warn"

[[runners]]
  name = "production-runner"
  url = "https://gitlab.com/"
  token = "your-token"
  executor = "docker"
  limit = 4
  tags = ["docker", "production", "nodejs"]
  run_untagged = false
  
  [runners.docker]
    image = "node:16-alpine"
    privileged = false
    memory = "2g"
    cpus = "2.0"
    pull_policy = ["if-not-present"]
    volumes = ["/cache:/cache:rw"]
```

### 8.3 最佳实践总结


**✅ 推荐做法**
- 🐳 **优先使用Docker执行器**：隔离性好，可重复
- 🏷️ **合理设置标签**：精确匹配，避免误用
- ⚡ **控制并发数**：根据硬件性能调整
- 🔒 **最小权限原则**：只给必要的权限
- 📊 **定期监控**：主动发现问题

**❌ 避免的坑**
- 🚫 **不要开启不必要的特权模式**
- 🚫 **不要设置过高的并发数**
- 🚫 **不要忽略日志和监控**
- 🚫 **不要在生产环境运行未标记任务**
- 🚫 **不要忘记定期清理Docker资源**

### 8.4 故障排查清单


**🔍 问题排查步骤**
1. **检查Runner状态** → `gitlab-runner status`
2. **验证配置文件** → `gitlab-runner verify`
3. **查看系统资源** → `htop`, `df -h`
4. **检查网络连接** → `ping gitlab.com`
5. **查看错误日志** → `journalctl -u gitlab-runner`

**核心记忆口诀**：
- *Runner配置要用心，Docker执行最放心*
- *标签权限设计好，并发监控不能少*
- *健康检查常运行，问题发现早解决*

> 🎯 **学习建议**
> 
> GitLab Runner配置看似复杂，但掌握核心概念后就很简单了。建议先用最基本的Docker执行器配置跑通第一个任务，然后逐步优化和完善配置。记住：**简单可用 > 复杂完美**！