---
title: 5、gitlab-ci.yml流水线配置
---
## 📚 目录

1. [什么是.gitlab-ci.yml文件](#1-什么是gitlab-ciyml文件)
2. [stages流水线阶段定义](#2-stages流水线阶段定义)
3. [jobs作业配置语法](#3-jobs作业配置语法)
4. [script执行脚本配置](#4-script执行脚本配置)
5. [variables变量定义](#5-variables变量定义)
6. [artifacts制品管理](#6-artifacts制品管理)
7. [cache缓存配置](#7-cache缓存配置)
8. [rules条件执行规则](#8-rules条件执行规则)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 📄 什么是.gitlab-ci.yml文件


### 1.1 基本概念理解


**简单理解**：把`.gitlab-ci.yml`想象成给GitLab的"指令清单"

```
类比生活场景：
做菜需要菜谱 → .gitlab-ci.yml就是代码的"菜谱"
菜谱告诉你：
- 先做什么（洗菜）
- 再做什么（切菜）  
- 最后做什么（炒菜）

.gitlab-ci.yml告诉GitLab：
- 先做什么（测试代码）
- 再做什么（打包代码）
- 最后做什么（部署代码）
```

### 1.2 文件位置和命名


**🎯 必须知道的要点**：

- **文件名**：必须叫`.gitlab-ci.yml`（注意前面有个点）
- **存放位置**：必须放在项目的根目录
- **文件格式**：YAML格式（一种配置文件格式）

```
项目结构示例：
my-project/
├── .gitlab-ci.yml     ← 必须在这里！
├── src/
├── package.json
└── README.md
```

### 1.3 文件的作用机制


**工作原理**：
```
开发者推送代码 → GitLab检测到.gitlab-ci.yml → 自动执行配置的任务

就像：
你把脏衣服放进洗衣机 → 洗衣机按程序自动洗衣服 → 洗好后通知你
```

**⚠️ 新手常见问题**：
- 文件名写错（比如写成`gitlab-ci.yml`缺少前面的点）
- 放错位置（放在子文件夹里）
- YAML语法错误（缩进不对）

---

## 2. 🎭 stages流水线阶段定义


### 2.1 什么是stages（阶段）


**生活化理解**：stages就像工厂的生产线

```
汽车生产线：
设计图纸 → 制造零件 → 组装车辆 → 质量检测 → 出厂销售

软件开发流水线：
测试代码 → 构建应用 → 部署测试环境 → 部署生产环境
```

### 2.2 stages配置语法


**基础语法**：
```yaml
stages:
  - test        # 第1阶段：测试
  - build       # 第2阶段：构建  
  - deploy      # 第3阶段：部署
```

**🔸 重要规则**：
- stages按**从上到下的顺序**执行
- 上一个stage完成后，才会执行下一个stage
- 如果某个stage失败，后面的stage不会执行

### 2.3 常用的stages组合


**📋 经典组合**：
```yaml
# 简单项目
stages:
  - test
  - deploy

# 标准项目  
stages:
  - test
  - build
  - deploy

# 复杂项目
stages:
  - validate    # 验证（代码检查）
  - test       # 测试
  - build      # 构建
  - deploy-dev # 部署到开发环境
  - deploy-prod # 部署到生产环境
```

### 2.4 stages执行流程图


```
代码提交
    ↓
┌─────────┐
│  test   │ ← 第1阶段：运行测试
└─────────┘
    ↓ (成功)
┌─────────┐  
│  build  │ ← 第2阶段：构建应用
└─────────┘
    ↓ (成功)
┌─────────┐
│ deploy  │ ← 第3阶段：部署应用  
└─────────┘
    ↓
部署完成
```

---

## 3. ⚙️ jobs作业配置语法


### 3.1 什么是jobs（作业）


**简单理解**：job就是具体要做的事情

```
stages是大的阶段，jobs是具体的任务

比如"考试"这个阶段包含：
- 数学考试 (job)
- 语文考试 (job)  
- 英语考试 (job)

"test"这个阶段包含：
- 单元测试 (job)
- 集成测试 (job)
- 代码检查 (job)
```

### 3.2 job的基本语法


**🔧 基础结构**：
```yaml
job名称:
  stage: 所属阶段
  script: 
    - 要执行的命令
```

### 3.3 实际job配置示例


```yaml
stages:
  - test
  - build
  - deploy

# test阶段的job
run_tests:
  stage: test
  script:
    - npm install
    - npm test

# build阶段的job  
build_app:
  stage: build
  script:
    - npm run build

# deploy阶段的job
deploy_app:
  stage: deploy
  script:
    - rsync -av ./dist/ user@server:/var/www/
```

### 3.4 job命名规范


**📝 好的命名方式**：
- `test_unit` - 单元测试
- `test_integration` - 集成测试
- `build_frontend` - 前端构建
- `deploy_production` - 生产环境部署

**❌ 避免的命名**：
- `job1`, `job2` - 没有意义
- `test-test` - 重复冗余

---

## 4. 📜 script执行脚本配置


### 4.1 script的作用


**简单理解**：script就是告诉计算机"具体怎么做"

```
生活类比：
菜谱上写"炒鸡蛋"，但具体怎么炒？
1. 打蛋
2. 热油  
3. 下蛋炒制
4. 加盐调味

script就是这些具体步骤
```

### 4.2 script语法格式


**单行命令**：
```yaml
job_name:
  script: npm test
```

**多行命令**：
```yaml
job_name:
  script:
    - npm install
    - npm test
    - npm run build
```

### 4.3 常用script示例


**🔸 前端项目**：
```yaml
test_job:
  script:
    - npm install          # 安装依赖
    - npm run lint         # 代码检查
    - npm test             # 运行测试
    - npm run build        # 构建项目
```

**🔸 后端项目**：
```yaml
test_job:
  script:
    - pip install -r requirements.txt  # 安装Python依赖
    - python -m pytest                 # 运行测试
    - python manage.py migrate         # 数据库迁移
```

### 4.4 script最佳实践


**✅ 推荐做法**：
- 每行一个命令，清晰明了
- 添加必要的注释说明
- 命令失败时整个job失败

**⚠️ 注意事项**：
- 命令按顺序执行
- 任何命令失败，后续命令不会执行
- 可以使用`||`让命令失败也继续执行

---

## 5. 🔧 variables变量定义


### 5.1 什么是variables（变量）


**生活化理解**：变量就像"代号"或"昵称"

```
生活中的例子：
- 把"13800138001"叫做"手机号"
- 把"张三"叫做"老板"

CI/CD中的例子：  
- 把"192.168.1.100"叫做"SERVER_IP"
- 把"my-app-v1.0"叫做"APP_NAME"
```

### 5.2 为什么要用变量


**🎯 主要好处**：

1. **避免重复**：不用到处写相同的值
2. **方便修改**：只需要改一个地方
3. **提高安全**：敏感信息可以隐藏
4. **增强可读性**：用有意义的名字

### 5.3 variables配置方式


**🔸 全局变量**（所有job都能用）：
```yaml
variables:
  APP_NAME: "my-awesome-app"
  VERSION: "1.0.0"
  SERVER_IP: "192.168.1.100"

stages:
  - deploy

deploy_job:
  stage: deploy
  script:
    - echo "部署 $APP_NAME 版本 $VERSION 到 $SERVER_IP"
```

**🔸 job级别变量**（只在当前job使用）：
```yaml
deploy_job:
  stage: deploy
  variables:
    DEPLOY_ENV: "production"
  script:
    - echo "部署到 $DEPLOY_ENV 环境"
```

### 5.4 常用变量示例


**📋 实用变量配置**：
```yaml
variables:
  # 应用信息
  APP_NAME: "my-web-app"
  APP_VERSION: "2.1.0"
  
  # 环境配置
  NODE_ENV: "production"
  DATABASE_URL: "postgresql://user:pass@localhost/db"
  
  # 部署配置
  DEPLOY_SERVER: "app.example.com"
  DEPLOY_PATH: "/var/www/html"
```

### 5.5 变量使用技巧


**🔸 在script中使用变量**：
```yaml
variables:
  PROJECT_NAME: "awesome-project"

build_job:
  script:
    - echo "正在构建项目：$PROJECT_NAME"
    - docker build -t $PROJECT_NAME:latest .
    - echo "构建完成！"
```

---

## 6. 📦 artifacts制品管理


### 6.1 什么是artifacts（制品）


**生活化理解**：artifacts就是"作业成果"

```
学生做作业的类比：
- 作业过程：写作业、计算、思考
- 作业成果：完成的作业本、答案

CI/CD的类比：
- 构建过程：编译、测试、打包  
- 构建成果：可执行文件、压缩包、报告
```

### 6.2 为什么需要artifacts


**🎯 主要用途**：

1. **保存构建结果**：把编译好的文件保存起来
2. **job间传递**：让后面的job能用前面的结果
3. **下载查看**：开发者可以下载查看
4. **部署使用**：部署时使用构建好的文件

### 6.3 artifacts基本配置


**🔧 简单配置**：
```yaml
build_job:
  stage: build
  script:
    - npm run build        # 构建项目
  artifacts:
    paths:
      - dist/              # 保存dist目录
```

**🔸 配置说明**：
- `paths`：指定要保存的文件或目录
- 可以指定多个路径
- 支持通配符（如`*.log`）

### 6.4 artifacts高级配置


**📋 完整配置示例**：
```yaml
build_app:
  stage: build
  script:
    - npm run build
    - npm run test
  artifacts:
    paths:
      - dist/                    # 构建产物
      - coverage/                # 测试覆盖率报告
    expire_in: 1 week           # 保存1周
    when: on_success            # 只在成功时保存
    name: "build-$CI_COMMIT_SHA" # 制品名称
```

**🔸 配置参数说明**：
- `expire_in`：保存多长时间（如`1 day`、`1 week`、`never`）
- `when`：什么时候保存（`on_success`、`on_failure`、`always`）
- `name`：制品包的名称

### 6.5 artifacts使用场景


**📊 典型使用流程**：
```
┌─────────────┐    artifacts    ┌─────────────┐
│  build阶段  │ ──────────────→ │ deploy阶段  │
│ 编译生成文件 │                 │ 使用编译文件 │
└─────────────┘                 └─────────────┘
```

**实际配置示例**：
```yaml
stages:
  - build
  - deploy

# 构建阶段：生成制品
build_frontend:
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 day

# 部署阶段：使用制品
deploy_frontend:
  stage: deploy
  script:
    - cp -r dist/* /var/www/html/  # 使用上一阶段的dist/
  dependencies:
    - build_frontend               # 依赖build_frontend的制品
```

---

## 7. ⚡ cache缓存配置


### 7.1 什么是cache（缓存）


**生活化理解**：cache就像"工具箱"

```
木工的例子：
- 每次做家具都需要工具
- 聪明的木工会准备工具箱
- 下次做家具时直接用工具箱的工具，不用重新买

CI/CD的例子：
- 每次构建都需要下载依赖包
- 用cache把依赖包保存起来  
- 下次构建时直接用缓存的包，不用重新下载
```

### 7.2 cache vs artifacts的区别


**📊 重要区别对比**：

| 特性 | **cache** | **artifacts** |
|------|-----------|---------------|
| **用途** | `提高构建速度` | `保存构建结果` |
| **内容** | `依赖包、临时文件` | `最终产物、报告` |
| **生命周期** | `多次构建复用` | `当次流水线使用` |
| **是否下载** | `不能手动下载` | `可以下载查看` |

### 7.3 cache基本配置


**🔧 简单缓存配置**：
```yaml
variables:
  npm_config_cache: ".npm"

test_job:
  script:
    - npm install
    - npm test
  cache:
    paths:
      - .npm/              # 缓存npm依赖
      - node_modules/      # 缓存安装的包
```

### 7.4 cache高级配置


**📋 完整缓存策略**：
```yaml
# 全局缓存配置
cache:
  key: "$CI_COMMIT_REF_SLUG"    # 缓存key（按分支区分）
  paths:
    - node_modules/
    - .npm/
  policy: pull-push              # 拉取并推送缓存

stages:
  - test
  - build

# 测试job：使用缓存
test_job:
  stage: test
  script:
    - npm install
    - npm test
  cache:
    key: "test-cache"
    paths:
      - node_modules/
    policy: pull                 # 只拉取缓存

# 构建job：更新缓存  
build_job:
  stage: build
  script:
    - npm install
    - npm run build
  cache:
    key: "build-cache"
    paths:
      - node_modules/
    policy: pull-push            # 拉取并更新缓存
```

**🔸 配置参数说明**：
- `key`：缓存的唯一标识
- `policy`：缓存策略（`pull`、`push`、`pull-push`）
- `paths`：要缓存的路径

### 7.5 cache最佳实践


**✅ 推荐做法**：
```yaml
# 按项目类型选择缓存内容

# Node.js项目
cache:
  paths:
    - node_modules/
    - .npm/

# Python项目  
cache:
  paths:
    - .pip-cache/
    - venv/

# Java项目
cache:
  paths:
    - .m2/repository/
    - target/
```

**⚠️ 缓存注意事项**：
- 缓存可能包含敏感信息，注意安全
- 缓存损坏时要能够重新构建
- 定期清理过期缓存

---

## 8. 🎯 rules条件执行规则


### 8.1 什么是rules（规则）


**简单理解**：rules就是"执行条件"

```
生活例子：
- 下雨天才带伞
- 工作日才上班
- 考试及格才发证书

CI/CD例子：
- 只有main分支才部署到生产环境
- 只有标签提交才发布版本
- 只有测试通过才进行部署
```

### 8.2 为什么需要rules


**🎯 主要目的**：

1. **节省资源**：不必要的job不执行
2. **控制流程**：重要操作需要满足条件
3. **提高安全**：生产部署需要严格控制
4. **灵活配置**：不同情况执行不同操作

### 8.3 rules基本语法


**🔧 基础规则配置**：
```yaml
job_name:
  script:
    - echo "执行任务"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"    # 条件：如果是main分支
      when: always                       # 动作：总是执行
    - when: never                        # 其他情况：不执行
```

### 8.4 常用rules场景


**📋 分支控制**：
```yaml
# 只在main分支部署
deploy_production:
  stage: deploy
  script:
    - echo "部署到生产环境"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# 只在develop分支部署到测试环境
deploy_testing:
  stage: deploy  
  script:
    - echo "部署到测试环境"
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
```

**📋 标签发布控制**：
```yaml
# 只有打标签时才发布
release_job:
  stage: release
  script:
    - echo "发布新版本"
  rules:
    - if: $CI_COMMIT_TAG                 # 有标签时执行
```

### 8.5 rules高级用法


**🔸 多条件组合**：
```yaml
deploy_job:
  script:
    - echo "条件部署"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"
      when: manual                       # 手动触发
    - if: $CI_COMMIT_BRANCH == "develop"
      when: always                       # 自动执行
    - when: never                        # 其他情况不执行
```

**🔸 文件变化检测**：
```yaml
test_frontend:
  script:
    - npm test
  rules:
    - changes:                           # 检测文件变化
        - "src/**/*"                     # src目录下文件变化时执行
        - "package.json"
```

### 8.6 rules实际应用


**📊 完整的分支策略**：
```yaml
stages:
  - test
  - build
  - deploy

# 所有分支都执行测试
run_tests:
  stage: test
  script:
    - npm test
  rules:
    - when: always

# 所有分支都构建
build_app:
  stage: build
  script:
    - npm run build
  rules:
    - when: always

# 只有main分支部署到生产环境
deploy_production:
  stage: deploy
  script:
    - echo "部署到生产环境"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# 只有develop分支部署到测试环境
deploy_staging:
  stage: deploy
  script:
    - echo "部署到测试环境"  
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 .gitlab-ci.yml：CI/CD的"配置清单"，告诉GitLab怎么自动化
🔸 stages：流水线阶段，按顺序执行的大步骤
🔸 jobs：具体任务，在stage中执行的实际工作
🔸 script：执行脚本，告诉计算机具体做什么
🔸 variables：变量配置，避免重复和提高可维护性
🔸 artifacts：制品管理，保存和传递构建结果
🔸 cache：缓存配置，提高构建速度和效率
🔸 rules：执行规则，控制什么时候执行什么任务
```

### 9.2 关键理解要点


**🔹 配置文件的本质**
```
.gitlab-ci.yml = 自动化脚本 = 告诉GitLab"怎么做"
就像：
- 洗衣机程序：告诉洗衣机怎么洗衣服
- 菜谱：告诉厨师怎么做菜
- CI配置：告诉GitLab怎么处理代码
```

**🔹 stages和jobs的关系**
```
stages = 大的阶段步骤
jobs = 具体的执行任务

类比考试：
stages: [笔试, 面试, 录取]
jobs: 
  - 笔试阶段：数学考试、语文考试
  - 面试阶段：技术面试、HR面试  
  - 录取阶段：发送通知、更新系统
```

**🔹 artifacts vs cache的本质区别**
```
artifacts = 作业成果（要交给老师的作业）
cache = 学习工具（下次还要用的参考书）

artifacts：构建结果，给下个阶段用
cache：依赖包等，给下次构建用
```

### 9.3 新手学习路径


**📚 建议学习顺序**：
1. **先学基础**：理解stages和jobs的概念
2. **练习script**：会写简单的执行脚本
3. **掌握variables**：学会使用变量简化配置
4. **理解artifacts**：知道怎么保存和传递文件
5. **学习cache**：提高构建效率
6. **最后rules**：掌握条件控制

**🔧 实践建议**：
- 从简单的配置开始，逐步增加复杂度
- 每次修改后观察GitLab的执行结果
- 善用GitLab的配置检查工具
- 多看官方文档和社区示例

### 9.4 常见问题和解决方法


**⚠️ 新手容易犯的错误**：

| 问题 | **原因** | **解决方法** |
|------|----------|-------------|
| **配置不生效** | `文件名或位置错误` | `确保文件名是.gitlab-ci.yml且在根目录` |
| **YAML语法错误** | `缩进或格式问题` | `使用YAML检查工具验证语法` |
| **job执行失败** | `script命令错误` | `在本地先测试命令是否正确` |
| **缓存不起作用** | `缓存key设置不当` | `检查cache key和paths配置` |
| **artifacts找不到** | `路径配置错误` | `确认artifacts paths指向正确目录` |

**💡 调试技巧**：
- 使用`echo`命令输出调试信息
- 检查GitLab CI/CD页面的详细日志
- 先在简单项目上测试配置
- 利用GitLab的配置验证功能

**核心记忆要点**：
- `.gitlab-ci.yml`是自动化的配置清单
- `stages`定义流水线阶段，`jobs`执行具体任务
- `variables`提高配置的灵活性和可维护性
- `artifacts`传递构建结果，`cache`提高构建效率
- `rules`控制执行条件，实现灵活的流水线控制