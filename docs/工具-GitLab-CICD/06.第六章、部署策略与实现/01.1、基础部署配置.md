---
title: 1、基础部署配置
---
## 📚 目录

1. [部署的基本概念](#1-部署的基本概念)
2. [部署环境准备](#2-部署环境准备)
3. [部署脚本编写](#3-部署脚本编写)
4. [SSH部署方式详解](#4-SSH部署方式详解)
5. [环境变量管理](#5-环境变量管理)
6. [部署权限配置](#6-部署权限配置)
7. [部署日志记录](#7-部署日志记录)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 部署的基本概念


### 1.1 什么是部署


**通俗理解**：部署就像**搬家**一样，把你写好的代码从开发环境"搬"到生产服务器上运行。

```
开发阶段                    部署阶段                    运行阶段
你的电脑 ──打包──> 代码包 ──上传──> 服务器 ──启动──> 用户访问
 ↓                      ↓                    ↓
写代码                  部署配置              网站运行
```

**核心作用**：
- 🔄 **自动化交付**：代码写完后自动发布到服务器
- ⚡ **快速更新**：新功能能快速上线给用户使用
- 🛡️ **稳定可靠**：确保部署过程不出错
- 📊 **可追踪**：知道什么时候部署了什么内容

### 1.2 部署与CI/CD的关系


**CI/CD流程图**：
```
代码提交 → 自动测试 → 构建打包 → 自动部署 → 用户访问
   ↓         ↓         ↓         ↓         ↓
  Git      CI阶段    CI阶段    CD阶段    生产环境
```

**简单理解**：
- **CI（持续集成）**：自动检查代码质量，打包成可用的程序
- **CD（持续部署）**：把打包好的程序自动放到服务器上运行

### 1.3 部署环境类型


| 环境类型 | **用途说明** | **特点** | **访问对象** |
|---------|------------|---------|-------------|
| 🧪 **开发环境** | `程序员写代码的地方` | `可以随便改，用来调试` | `只有开发人员` |
| 🔍 **测试环境** | `验证功能是否正常` | `模拟真实环境，测试用` | `测试人员、产品经理` |
| 🚀 **生产环境** | `真正给用户使用的` | `必须稳定，不能出错` | `所有用户` |

---

## 2. 🛠️ 部署环境准备


### 2.1 服务器基础环境


**环境准备清单**：

```
🔸 操作系统要求
• Linux系统（推荐Ubuntu/CentOS）
• 基本命令行工具
• 网络连接正常

🔸 运行环境安装
• Node.js（前端项目）
• Docker（容器化部署）
• Nginx/Apache（Web服务器）
• 数据库（MySQL/PostgreSQL等）
```

**服务器连接验证**：
```bash
# 测试服务器连接
ssh user@your-server-ip

# 检查系统信息
uname -a
free -h
df -h
```

### 2.2 GitLab Runner配置


**什么是GitLab Runner**：
GitLab Runner就像一个**专门干活的机器人**，它会按照你写的部署脚本，自动执行部署任务。

**Runner注册步骤**：
```bash
# 1. 安装GitLab Runner
curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash
sudo apt-get install gitlab-runner

# 2. 注册Runner
sudo gitlab-runner register
```

**注册时需要的信息**：
- 📍 **GitLab URL**：你的GitLab服务器地址
- 🔑 **Registration Token**：在项目设置中找到
- 🏷️ **Description**：给Runner起个名字
- 🏃 **Executor**：选择shell或docker

### 2.3 网络与安全配置


**防火墙设置**：
```bash
# 开放必要端口
sudo ufw allow 22    # SSH
sudo ufw allow 80    # HTTP
sudo ufw allow 443   # HTTPS
sudo ufw enable
```

**SSH密钥配置**：
```bash
# 生成SSH密钥对
ssh-keygen -t rsa -b 4096 -C "gitlab-ci@your-domain.com"

# 复制公钥到服务器
ssh-copy-id user@your-server-ip
```

---

## 3. 📝 部署脚本编写


### 3.1 .gitlab-ci.yml基础结构


**部署脚本就像一份**"操作说明书"，告诉GitLab该怎么把你的代码部署到服务器。

```yaml
# 定义执行阶段
stages:
  - build     # 构建阶段
  - test      # 测试阶段
  - deploy    # 部署阶段

# 构建任务
build_job:
  stage: build
  script:
    - npm install        # 安装依赖
    - npm run build     # 构建项目
  artifacts:
    paths:
      - dist/           # 保存构建结果

# 部署任务
deploy_job:
  stage: deploy
  script:
    - echo "开始部署到生产环境"
    - rsync -av dist/ user@server:/var/www/html/
  only:
    - main              # 只在main分支触发
```

### 3.2 常见部署脚本模式


**🔸 简单文件同步部署**：
```yaml
deploy_simple:
  stage: deploy
  before_script:
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'
    - eval $(ssh-agent -s)
    - ssh-add <(echo "$SSH_PRIVATE_KEY")
  script:
    - scp -r dist/* user@server:/var/www/html/
    - ssh user@server "sudo systemctl reload nginx"
```

**🔸 Docker容器化部署**：
```yaml
deploy_docker:
  stage: deploy
  script:
    - docker build -t myapp:latest .
    - docker stop myapp || true
    - docker rm myapp || true
    - docker run -d --name myapp -p 80:80 myapp:latest
```

### 3.3 部署脚本最佳实践


**脚本编写原则**：

```
✅ 幂等性：多次执行结果相同
✅ 原子性：要么全部成功，要么全部失败
✅ 可回滚：出错时能快速恢复
✅ 有日志：记录每一步操作
```

**错误处理机制**：
```yaml
deploy_with_rollback:
  stage: deploy
  script:
    - |
      # 备份当前版本
      ssh user@server "cp -r /var/www/html /var/www/backup-$(date +%Y%m%d-%H%M%S)"
      
      # 部署新版本
      if ! rsync -av dist/ user@server:/var/www/html/; then
        echo "部署失败，开始回滚"
        ssh user@server "rm -rf /var/www/html && mv /var/www/backup-* /var/www/html"
        exit 1
      fi
      
      # 验证部署结果
      if ! curl -f http://your-domain.com/health; then
        echo "健康检查失败，开始回滚"
        ssh user@server "rm -rf /var/www/html && mv /var/www/backup-* /var/www/html"
        exit 1
      fi
```

---

## 4. 🔐 SSH部署方式详解


### 4.1 SSH部署的工作原理


**SSH部署流程图**：
```
GitLab Runner               目标服务器
     |                          |
     |--[1]SSH连接--------------->|
     |<-[2]身份验证确认------------|
     |                          |
     |--[3]上传文件--------------->|
     |--[4]执行命令--------------->|
     |<-[5]返回执行结果------------|
```

**为什么选择SSH**：
- 🔒 **安全性高**：加密传输，不会被窃听
- 🚀 **速度快**：直接连接，无需中转
- 🛠️ **功能强大**：可以传文件，也可以执行命令
- 📱 **广泛支持**：所有Linux服务器都支持

### 4.2 SSH密钥配置详解


**密钥的工作原理**：
SSH密钥就像一把**特殊的钥匙**，分为两部分：
- 🔐 **私钥**：放在GitLab上，相当于你的钥匙
- 🔓 **公钥**：放在服务器上，相当于锁

```bash
# 1. 在GitLab Runner上生成密钥对
ssh-keygen -t rsa -b 4096 -f ~/.ssh/gitlab_deploy
# 会生成两个文件：
# gitlab_deploy     (私钥，保密)
# gitlab_deploy.pub (公钥，可以公开)

# 2. 将公钥添加到目标服务器
cat ~/.ssh/gitlab_deploy.pub >> ~/.ssh/authorized_keys

# 3. 设置正确的权限
chmod 600 ~/.ssh/authorized_keys
chmod 700 ~/.ssh/
```

### 4.3 GitLab项目中配置SSH密钥


**在GitLab项目中设置密钥**：

**步骤1**：进入项目 → Settings → CI/CD → Variables

**步骤2**：添加变量
- 🏷️ **Key**: `SSH_PRIVATE_KEY`
- 📝 **Value**: 私钥内容（整个gitlab_deploy文件的内容）
- 🔒 **Protected**: 勾选
- 🙈 **Masked**: 勾选

**步骤3**：在CI脚本中使用
```yaml
deploy:
  before_script:
    # 安装SSH客户端
    - apt-get update -qq && apt-get install -y -qq openssh-client
    # 启动SSH代理
    - eval $(ssh-agent -s)
    # 添加私钥
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    # 跳过主机密钥验证（可选，但要注意安全）
    - mkdir -p ~/.ssh && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
  script:
    - ssh user@server "cd /var/www && git pull origin main"
```

### 4.4 常用SSH部署命令


**文件传输命令**：
```bash
# scp：安全复制文件
scp -r dist/* user@server:/var/www/html/

# rsync：同步文件（推荐，支持增量）
rsync -avz --delete dist/ user@server:/var/www/html/
```

**远程命令执行**：
```bash
# 执行单个命令
ssh user@server "sudo systemctl restart nginx"

# 执行多个命令
ssh user@server << 'EOF'
cd /var/www/html
sudo chown -R www-data:www-data .
sudo systemctl reload nginx
echo "部署完成"
EOF
```

---

## 5. 🌐 环境变量管理


### 5.1 环境变量的作用


**什么是环境变量**：
环境变量就像**标签**一样，告诉程序在不同环境下应该使用什么配置。

**为什么需要环境变量**：
```
开发环境：数据库 = localhost
测试环境：数据库 = test-db.company.com  
生产环境：数据库 = prod-db.company.com

如果把数据库地址写死在代码里：
❌ 每个环境都要改代码
❌ 容易出错
❌ 密码暴露在代码中

使用环境变量：
✅ 一套代码，多个环境
✅ 敏感信息不暴露
✅ 配置灵活
```

### 5.2 GitLab CI/CD变量设置


**变量设置位置**：

```
📊 变量作用范围层级：
Group级别 > Project级别 > Pipeline级别 > Job级别

实际效果：
├── Group变量（所有项目都能用）
│   └── PROJECT_TYPE=web
├── Project变量（当前项目专用）
│   └── DATABASE_URL=xxx
└── Job变量（特定任务专用）
    └── DEPLOY_ENV=production
```

**变量类型说明**：

| 变量类型 | **用途** | **安全性** | **使用场景** |
|---------|---------|-----------|-------------|
| 🔓 **普通变量** | `一般配置信息` | `低` | `API地址、版本号` |
| 🔒 **Protected变量** | `敏感信息` | `中` | `只在保护分支可用` |
| 🙈 **Masked变量** | `密码等机密` | `高` | `数据库密码、密钥` |

### 5.3 环境变量使用示例


**在.gitlab-ci.yml中使用变量**：
```yaml
variables:
  # 项目级别变量
  NODE_ENV: "production"
  APP_NAME: "my-web-app"

deploy_staging:
  stage: deploy
  variables:
    # 任务级别变量
    DEPLOY_ENV: "staging"
    SERVER_HOST: "staging.example.com"
  script:
    - echo "部署到 $DEPLOY_ENV 环境"
    - echo "服务器地址: $SERVER_HOST"
    - echo "数据库: $DATABASE_URL"  # 来自项目设置
    - npm run deploy
  environment:
    name: staging
    url: https://staging.example.com

deploy_production:
  stage: deploy
  variables:
    DEPLOY_ENV: "production"
    SERVER_HOST: "production.example.com"
  script:
    - echo "部署到生产环境"
    - npm run deploy:prod
  only:
    - main
```

**在应用代码中使用环境变量**：
```javascript
// config.js
const config = {
  // 从环境变量读取配置
  apiUrl: process.env.API_URL || 'http://localhost:3000',
  dbHost: process.env.DB_HOST || 'localhost',
  dbPassword: process.env.DB_PASSWORD,
  environment: process.env.NODE_ENV || 'development'
};

// 根据环境调整配置
if (config.environment === 'production') {
  config.debug = false;
  config.logLevel = 'warn';
} else {
  config.debug = true;
  config.logLevel = 'debug';
}
```

### 5.4 敏感信息保护


**安全最佳实践**：

```
🔒 密码管理规则：
✅ 使用Masked变量存储密码
✅ 定期轮换密码
✅ 使用最小权限原则
❌ 绝不在代码中硬编码密码
❌ 不在日志中输出敏感信息
```

**密钥轮换示例**：
```yaml
# 定期更新部署密钥
rotate_keys:
  stage: maintenance
  script:
    - |
      # 生成新的SSH密钥
      ssh-keygen -t rsa -b 4096 -f /tmp/new_key
      
      # 更新服务器授权密钥
      ssh-copy-id -i /tmp/new_key user@server
      
      # 提醒更新GitLab变量
      echo "请手动更新GitLab中的SSH_PRIVATE_KEY变量"
  when: manual  # 手动触发
  only:
    - schedules  # 只在定时任务中运行
```

---

## 6. 🔐 部署权限配置


### 6.1 权限管理的重要性


**为什么要管理权限**：
权限管理就像给房子配钥匙，不同的人有不同的访问权限。

```
权限不当的风险：
❌ 开发人员误操作生产环境
❌ 测试数据污染生产数据  
❌ 未授权人员访问敏感信息
❌ 代码被恶意修改

正确权限管理的好处：
✅ 职责分离，各司其职
✅ 操作可追溯
✅ 降低安全风险
✅ 符合合规要求
```

### 6.2 GitLab项目权限配置


**GitLab权限等级**：

| 权限级别 | **能力范围** | **适用人员** |
|---------|-------------|-------------|
| 👁️ **Guest** | `查看项目，提issue` | `产品经理、业务人员` |
| 📝 **Reporter** | `下载代码，查看CI/CD` | `测试人员、实习生` |
| 🔧 **Developer** | `推送代码，管理issue` | `普通开发人员` |
| 🚀 **Maintainer** | `管理分支，配置CI/CD` | `技术负责人` |
| 👑 **Owner** | `删除项目，管理成员` | `项目所有者` |

**保护分支设置**：
```yaml
# 在GitLab中设置保护分支
分支保护规则：
├── main分支
│   ├── 推送权限：仅Maintainer
│   ├── 合并权限：Maintainer + Developer
│   └── 强制代码审查：必须
└── develop分支
    ├── 推送权限：Developer及以上
    └── 合并权限：Developer及以上
```

### 6.3 服务器权限配置


**系统用户权限设置**：
```bash
# 创建专用部署用户
sudo useradd -m -s /bin/bash deploy
sudo usermod -aG www-data deploy

# 设置sudo权限（仅限必要命令）
echo "deploy ALL=(ALL) NOPASSWD: /bin/systemctl restart nginx, /bin/systemctl reload nginx" | sudo tee /etc/sudoers.d/deploy

# 设置文件权限
sudo chown -R deploy:www-data /var/www
sudo chmod -R 755 /var/www
```

**SSH访问控制**：
```bash
# 限制SSH访问
# 编辑 /etc/ssh/sshd_config
AllowUsers deploy
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes

# 重启SSH服务
sudo systemctl restart sshd
```

### 6.4 Docker权限管理


**Docker用户权限**：
```bash
# 将部署用户加入docker组
sudo usermod -aG docker deploy

# 重新登录使权限生效
sudo -u deploy docker ps
```

**容器权限限制**：
```yaml
# 在CI脚本中使用受限权限运行容器
deploy_docker:
  script:
    - |
      docker run -d \
        --name myapp \
        --user 1000:1000 \    # 指定用户ID
        --read-only \         # 只读文件系统
        --tmpfs /tmp \        # 临时文件系统
        --cap-drop ALL \      # 移除所有特权
        --cap-add NET_BIND_SERVICE \  # 只添加必要权限
        -p 80:8080 \
        myapp:latest
```

---

## 7. 📊 部署日志记录


### 7.1 日志记录的重要性


**为什么要记录日志**：
日志就像**行车记录仪**，记录部署过程中发生的所有事情。

```
日志的作用：
🔍 故障排查：出问题时知道哪里出错了
📈 性能监控：了解部署耗时和瓶颈
🛡️ 安全审计：谁在什么时候做了什么
📊 持续改进：分析历史数据优化流程
```

### 7.2 GitLab CI/CD日志


**CI/CD日志层级**：
```
Pipeline日志（管道日志）
├── Job日志（任务日志）
│   ├── before_script日志
│   ├── script日志  
│   └── after_script日志
└── Artifacts日志（构建产物日志）
```

**日志配置示例**：
```yaml
deploy:
  stage: deploy
  before_script:
    - echo "=== 部署开始 ==="
    - echo "时间: $(date)"
    - echo "分支: $CI_COMMIT_REF_NAME"
    - echo "提交: $CI_COMMIT_SHA"
  script:
    - |
      echo "=== 开始传输文件 ==="
      if rsync -avz --progress dist/ user@server:/var/www/html/; then
        echo "✅ 文件传输成功"
      else
        echo "❌ 文件传输失败"
        exit 1
      fi
      
      echo "=== 重启服务 ==="
      if ssh user@server "sudo systemctl reload nginx"; then
        echo "✅ 服务重启成功"
      else
        echo "❌ 服务重启失败"
        exit 1
      fi
  after_script:
    - echo "=== 部署结束 ==="
    - echo "结束时间: $(date)"
```

### 7.3 应用日志管理


**应用日志配置**：
```javascript
// 日志配置示例 (Node.js)
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { 
    service: 'web-app',
    version: process.env.CI_COMMIT_SHA || 'unknown'
  },
  transports: [
    // 写入文件
    new winston.transports.File({ 
      filename: '/var/log/app/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: '/var/log/app/combined.log' 
    })
  ]
});

// 生产环境添加控制台输出
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}
```

### 7.4 日志监控与告警


**日志收集架构**：
```
应用服务器                     日志系统
     |                          |
  [应用日志] ──传输──> [日志收集器] ──存储──> [日志存储]
     |                          |                |
  [系统日志] ──────────────────────┘                |
     |                                           |
  [部署日志] ──────────────────────────────────────┘
                                                  |
                                              [监控告警]
```

**日志告警配置**：
```yaml
# 在CI脚本中添加健康检查和告警
deploy:
  script:
    - # ... 部署逻辑 ...
  after_script:
    - |
      # 检查部署是否成功
      if curl -f --max-time 30 http://your-domain.com/health; then
        echo "✅ 健康检查通过"
        # 发送成功通知
        curl -X POST "$SLACK_WEBHOOK" -d '{"text":"🚀 部署成功!"}'
      else
        echo "❌ 健康检查失败"
        # 发送失败告警
        curl -X POST "$SLACK_WEBHOOK" -d '{"text":"🚨 部署失败，请检查!"}'
        exit 1
      fi
```

**日志分析脚本**：
```bash
#!/bin/bash
# 部署后日志分析脚本

echo "=== 部署日志分析 ==="

# 检查错误日志
ERROR_COUNT=$(grep -c "ERROR" /var/log/app/error.log | tail -100)
if [ $ERROR_COUNT -gt 0 ]; then
  echo "⚠️  发现 $ERROR_COUNT 个错误"
  grep "ERROR" /var/log/app/error.log | tail -5
fi

# 检查响应时间
echo "=== 最近5分钟平均响应时间 ==="
tail -1000 /var/log/nginx/access.log | awk '{print $NF}' | awk '{sum+=$1; count++} END {print sum/count "ms"}'

# 检查服务状态
echo "=== 服务状态 ==="
systemctl status nginx --no-pager -l
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的基本概念


```
🔸 部署本质：将代码从开发环境安全可靠地发布到生产环境
🔸 SSH部署：使用加密连接安全传输文件和执行命令
🔸 环境变量：不同环境使用不同配置，保护敏感信息
🔸 权限管理：确保合适的人在合适的时间做合适的事
🔸 日志记录：记录部署过程，便于故障排查和持续改进
```

### 8.2 关键理解要点


**🔹 部署脚本编写原则**
```
自动化思维：
- 能自动化的绝不手工操作
- 脚本要具备幂等性和原子性
- 必须有错误处理和回滚机制

安全性考虑：
- 使用SSH密钥而不是密码
- 敏感信息放在环境变量中
- 遵循最小权限原则
```

**🔹 环境变量最佳实践**
```
分层管理：
- 公共配置放Group级别
- 项目特定配置放Project级别
- 敏感信息使用Protected和Masked

命名规范：
- 使用大写字母和下划线
- 前缀标识作用域（如DB_、API_）
- 避免歧义，语义清晰
```

**🔹 权限配置策略**
```
职责分离：
- 开发人员：代码提交和功能开发
- 运维人员：生产环境部署和维护
- 测试人员：测试环境验证

访问控制：
- GitLab项目权限分级管理
- 服务器用户权限最小化
- SSH密钥定期轮换
```

### 8.3 实际应用价值


**🎯 部署场景应用**
- **小型项目**：简单文件同步，快速上线
- **中型项目**：Docker容器化，环境一致性
- **大型项目**：蓝绿部署，零停机更新
- **微服务**：分布式部署，服务协调

**🔧 运维实践**
- **监控指标**：部署成功率、部署时长、回滚频率
- **故障处理**：快速定位问题，自动回滚机制
- **持续改进**：分析部署数据，优化流程
- **文档维护**：记录部署规范，团队知识共享

**核心记忆**：
- 部署自动化是DevOps的核心，减少人工错误
- 安全配置和权限管理是部署成功的基础保障
- 环境变量和日志记录是运维监控的重要手段
- 部署脚本要考虑异常情况，具备容错和恢复能力