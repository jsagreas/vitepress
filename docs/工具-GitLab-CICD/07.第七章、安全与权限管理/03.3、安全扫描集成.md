---
title: 3、安全扫描集成
---
## 📚 目录

1. [安全扫描概述](#1-安全扫描概述)
2. [依赖安全扫描](#2-依赖安全扫描)
3. [容器镜像扫描](#3-容器镜像扫描)
4. [静态应用安全测试(SAST)](#4-静态应用安全测试sast)
5. [动态应用安全测试(DAST)](#5-动态应用安全测试dast)
6. [漏洞检测配置](#6-漏洞检测配置)
7. [安全报告生成](#7-安全报告生成)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ 安全扫描概述


### 1.1 什么是GitLab安全扫描


**通俗理解**：就像给你的代码做"全身体检"，找出可能存在的安全问题。

```
想象一下：
你写了一个网站 → 就像盖了一栋房子
安全扫描 → 就像请专业人员检查房子的安全隐患
• 门锁是否牢固？（代码漏洞检查）
• 建材是否合格？（依赖组件检查）
• 结构是否稳定？（架构安全检查）
```

**GitLab CI/CD中的安全扫描**：
- **自动化执行**：每次代码提交都自动检查安全问题
- **多维度检测**：从代码到部署全流程安全检查
- **报告可视化**：直观展示发现的安全问题和修复建议

### 1.2 为什么需要安全扫描


**现实案例**：
```
❌ 没有安全扫描的后果：
• 使用了有漏洞的第三方库 → 黑客利用漏洞攻击
• 代码中存在SQL注入 → 数据库被窃取
• 容器镜像有恶意软件 → 服务器被感染

✅ 有安全扫描的好处：
• 提前发现问题 → 避免生产环境出事
• 自动化检测 → 节省人工审查时间
• 持续监控 → 新漏洞及时发现
```

### 1.3 GitLab安全扫描的类型


**四大安全扫描类型**：

| 扫描类型 | **检查什么** | **什么时候用** | **发现什么问题** |
|---------|-------------|---------------|-----------------|
| 🔍 **依赖扫描** | `第三方库和组件` | `每次构建时` | `已知漏洞的依赖包` |
| 📦 **容器扫描** | `Docker镜像` | `镜像构建后` | `镜像中的安全漏洞` |
| 📝 **SAST扫描** | `源代码` | `代码提交时` | `代码逻辑安全问题` |
| 🌐 **DAST扫描** | `运行中的应用` | `部署测试后` | `实际运行时漏洞` |

---

## 2. 📦 依赖安全扫描


### 2.1 什么是依赖安全扫描


**通俗解释**：检查你项目中使用的第三方库是否存在已知的安全漏洞。

```
生活例子：
你装修房子时 → 买了很多建材（第三方库）
依赖扫描 → 检查这些建材是否有质量问题
• 这个品牌的水管是否有爆裂风险？
• 这种电线是否容易漏电？
• 这个门锁是否容易被撬开？
```

### 2.2 GitLab依赖扫描工作原理


**扫描流程**：
```
1. 分析项目依赖清单
   ↓
2. 对比安全漏洞数据库
   ↓  
3. 发现有问题的依赖包
   ↓
4. 生成安全报告
```

**支持的项目类型**：
- **JavaScript**：`package.json` 和 `package-lock.json`
- **Python**：`requirements.txt` 和 `Pipfile.lock`
- **Java**：`pom.xml` 和 `build.gradle`
- **Ruby**：`Gemfile.lock`
- **PHP**：`composer.lock`

### 2.3 配置依赖扫描


**基础配置**：
```yaml
# .gitlab-ci.yml
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml

dependency_scanning:
  stage: test
  variables:
    # 设置扫描规则的严格程度
    DS_SEVERITY_THRESHOLD: "medium"
```

**常用配置选项**：
```yaml
variables:
  # 只扫描高危和严重漏洞
  DS_SEVERITY_THRESHOLD: "high"
  
  # 排除某些目录不扫描
  DS_EXCLUDED_PATHS: "tests/, docs/"
  
  # 指定扫描工具
  DS_DEFAULT_ANALYZERS: "gemnasium"
```

### 2.4 依赖扫描实际应用


**项目示例**：假设你有一个Node.js项目

```json
// package.json
{
  "dependencies": {
    "express": "4.16.0",    // 这个版本可能有漏洞
    "lodash": "4.17.4",     // 这个版本也可能有问题
    "mysql": "2.18.1"
  }
}
```

**扫描结果示例**：
```
🔴 发现 2 个高危漏洞：
• express 4.16.0 - 存在路径遍历漏洞
  修复建议：升级到 4.18.2 或更高版本
  
• lodash 4.17.4 - 存在原型污染漏洞  
  修复建议：升级到 4.17.21 或更高版本
```

---

## 3. 🐳 容器镜像扫描


### 3.1 什么是容器镜像扫描


**通俗理解**：检查你制作的Docker镜像里是否包含有安全问题的软件。

```
比喻说明：
Docker镜像 → 就像一个打包好的"软件包裹"
镜像扫描 → 就像海关检查包裹内容
• 包裹里的物品是否安全？
• 有没有违禁品？
• 物品的生产日期是否过期？
```

### 3.2 容器扫描检查什么


**检查内容**：
- **操作系统漏洞**：基础镜像(如Ubuntu、Alpine)的安全问题
- **软件包漏洞**：镜像中安装的软件是否有已知漏洞
- **配置问题**：容器的安全配置是否合理

**常见问题例子**：
```
❌ 发现的问题：
• 使用了过时的Ubuntu 16.04基础镜像
• 安装了有漏洞的OpenSSL版本
• 以root用户运行应用程序

✅ 修复建议：
• 更新到Ubuntu 20.04或更新版本
• 升级OpenSSL到安全版本
• 创建专用用户运行应用
```

### 3.3 配置容器扫描


**基础配置**：
```yaml
# .gitlab-ci.yml
include:
  - template: Security/Container-Scanning.gitlab-ci.yml

build:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

container_scanning:
  stage: test
  variables:
    # 指定要扫描的镜像
    CS_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

**高级配置选项**：
```yaml
container_scanning:
  variables:
    # 设置漏洞严重程度阈值
    CS_SEVERITY_THRESHOLD: "high"
    
    # 禁用某些检查规则
    CS_DISABLE_DEPENDENCY_LIST: "true"
    
    # 自定义扫描工具
    CS_ANALYZER_IMAGE: "registry.gitlab.com/gitlab-org/security-products/analyzers/trivy:latest"
```

### 3.4 镜像安全最佳实践


**安全的Dockerfile示例**：
```dockerfile
# 使用最新的稳定版基础镜像
FROM node:18-alpine

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 设置工作目录
WORKDIR /app

# 复制依赖文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制应用代码
COPY . .

# 切换到非root用户
USER nextjs

# 暴露端口
EXPOSE 3000

# 启动应用
CMD ["npm", "start"]
```

---

## 4. 🔍 静态应用安全测试(SAST)


### 4.1 什么是SAST


**简单理解**：在不运行程序的情况下，直接分析源代码找出安全问题。

```
现实比喻：
源代码 → 就像建筑图纸
SAST扫描 → 就像建筑师审查图纸
• 这里的结构设计是否有问题？
• 这个地方是否存在安全隐患？
• 材料选择是否合适？

不需要实际盖房子，就能发现图纸上的问题
```

### 4.2 SAST能发现什么问题


**常见安全问题**：

| 问题类型 | **具体表现** | **危害** | **修复方法** |
|---------|-------------|---------|-------------|
| 🔓 **SQL注入** | `用户输入直接拼接到SQL语句` | `数据库被攻击` | `使用参数化查询` |
| 🌐 **XSS漏洞** | `用户输入未过滤直接显示` | `网页被植入恶意代码` | `对输出进行HTML转义` |
| 🔑 **硬编码密码** | `密码直接写在代码里` | `密码泄露` | `使用环境变量或配置文件` |
| 📂 **路径遍历** | `文件路径未验证` | `敏感文件被访问` | `验证和限制文件路径` |

### 4.3 配置SAST扫描


**基础配置**：
```yaml
# .gitlab-ci.yml
include:
  - template: Security/SAST.gitlab-ci.yml

sast:
  stage: test
  variables:
    # 设置扫描规则严格程度
    SAST_SEVERITY_THRESHOLD: "medium"
```

**针对特定语言的配置**：
```yaml
# Java项目配置
sast:
  variables:
    SAST_JAVA_VERSION: "11"
    SAST_ANALYZER_IMAGE_TAG: "latest"

# JavaScript项目配置  
eslint-sast:
  variables:
    SAST_ESLINT_CONFIG: ".eslintrc.js"
```

### 4.4 SAST扫描结果示例


**发现的问题示例**：
```javascript
// ❌ 有问题的代码
function getUserData(userId) {
    // SQL注入风险
    const query = `SELECT * FROM users WHERE id = ${userId}`;
    return database.query(query);
}

function displayMessage(message) {
    // XSS风险
    document.innerHTML = message;
}

// 硬编码密码
const API_KEY = "sk-1234567890abcdef";
```

**修复后的代码**：
```javascript
// ✅ 修复后的代码
function getUserData(userId) {
    // 使用参数化查询
    const query = 'SELECT * FROM users WHERE id = ?';
    return database.query(query, [userId]);
}

function displayMessage(message) {
    // 安全的文本设置
    document.textContent = message;
}

// 使用环境变量
const API_KEY = process.env.API_KEY;
```

---

## 5. 🌐 动态应用安全测试(DAST)


### 5.1 什么是DAST


**通俗理解**：在应用程序实际运行时，模拟黑客攻击来发现安全漏洞。

```
形象比喻：
SAST → 看图纸找问题（静态分析）
DAST → 实际入住后找问题（动态测试）

例如：
• 门锁看起来很安全（SAST检查通过）
• 但实际使用时发现容易被撬开（DAST发现问题）
```

### 5.2 DAST vs SAST的区别


**关键差异**：

```
📝 SAST（静态扫描）：
• 分析源代码
• 不需要运行程序  
• 发现代码层面的问题
• 扫描速度快
• 可能有误报

🌐 DAST（动态扫描）：
• 测试运行中的应用
• 需要部署环境
• 发现实际运行时的问题  
• 扫描时间较长
• 结果更准确
```

### 5.3 DAST扫描过程


**扫描流程图**：
```
应用部署到测试环境
         ↓
DAST工具开始爬取网站
         ↓  
发现所有页面和接口
         ↓
模拟各种攻击测试
         ↓
记录发现的漏洞
         ↓
生成安全报告
```

### 5.4 配置DAST扫描


**基础配置**：
```yaml
# .gitlab-ci.yml
include:
  - template: Security/DAST.gitlab-ci.yml

deploy_to_test:
  stage: deploy
  script:
    - echo "部署应用到测试环境"
    - deploy_app.sh
  environment:
    name: test
    url: https://test.example.com

dast:
  stage: test
  variables:
    # 指定要扫描的目标网址
    DAST_WEBSITE: https://test.example.com
    
    # 设置扫描深度
    DAST_SPIDER_MINS: 5
    
    # 设置扫描超时时间
    DAST_TARGET_TIMEOUT: 120
```

**高级配置选项**：
```yaml
dast:
  variables:
    # 提供登录认证信息
    DAST_AUTH_URL: https://test.example.com/login
    DAST_USERNAME: test_user
    DAST_PASSWORD: test_password
    
    # 排除某些URL不扫描
    DAST_EXCLUDE_URLS: "logout,admin"
    
    # 启用API扫描
    DAST_API_SPECIFICATION: api-spec.json
```

### 5.5 DAST发现的典型问题


**常见漏洞示例**：
```
🔴 发现的安全问题：

1. 跨站脚本攻击 (XSS)
   位置：/search?q=<script>alert('xss')</script>
   风险：高危
   
2. SQL注入漏洞
   位置：/user/profile?id=1' OR '1'='1
   风险：严重
   
3. 敏感信息泄露
   位置：/debug 页面暴露了系统信息
   风险：中等
   
4. 认证绕过
   位置：直接访问 /admin 无需登录
   风险：严重
```

---

## 6. ⚙️ 漏洞检测配置


### 6.1 统一安全扫描配置


**完整的安全流水线配置**：
```yaml
# .gitlab-ci.yml
stages:
  - build
  - test
  - security
  - deploy

# 引入所有安全扫描模板
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/DAST.gitlab-ci.yml

# 全局安全配置
variables:
  # 设置全局漏洞阈值
  SECURE_LOG_LEVEL: "info"
  
  # 在发现高危漏洞时失败
  SECURITY_FAIL_ON_HIGH: "true"

build_app:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

# 安全扫描阶段
security_scanning:
  stage: security
  dependencies:
    - dependency_scanning
    - container_scanning  
    - sast
  script:
    - echo "所有安全扫描已完成"
```

### 6.2 自定义漏洞规则


**创建自定义安全规则**：
```yaml
# 自定义SAST规则
sast:
  variables:
    # 使用自定义规则文件
    SAST_RULESET: "custom-security-rules.yml"
    
  before_script:
    - |
      cat > custom-security-rules.yml << 'EOF'
      rules:
        - id: "hardcoded_password"
          severity: "high"
          pattern: 'password\s*=\s*"[^"]*"'
          message: "发现硬编码密码"
        
        - id: "sql_injection_risk"  
          severity: "critical"
          pattern: 'query.*\+.*user_input'
          message: "SQL注入风险"
      EOF
```

### 6.3 漏洞白名单配置


**忽略已知的安全问题**：
```yaml
# 创建漏洞白名单文件
variables:
  # 指定白名单文件
  DS_REMEDIATION: "security-whitelist.yml"

before_script:
  - |
    cat > security-whitelist.yml << 'EOF'
    # 已知但暂时无法修复的漏洞
    vulnerabilities:
      - cve: "CVE-2021-1234"
        reason: "第三方库漏洞，等待官方修复"
        expiry: "2024-12-31"
        
      - cve: "CVE-2021-5678"  
        reason: "测试环境专用，生产环境不存在"
        expiry: "2024-06-30"
    EOF
```

### 6.4 条件化安全扫描


**根据分支和条件执行扫描**：
```yaml
# 只在主分支执行完整扫描
full_security_scan:
  extends: .security_template
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# 合并请求时执行快速扫描  
quick_security_scan:
  extends: .security_template
  variables:
    SAST_EXCLUDED_ANALYZERS: "bandit, brakeman"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# 生产部署前的严格扫描
production_security_check:
  extends: .security_template  
  variables:
    SECURITY_FAIL_ON_MEDIUM: "true"
  rules:
    - if: $CI_COMMIT_TAG
```

---

## 7. 📊 安全报告生成


### 7.1 安全报告的作用


**为什么需要安全报告**：
```
📈 管理层需要：
• 了解项目安全状况
• 评估安全风险等级
• 制定安全改进计划

👥 开发团队需要：  
• 快速定位安全问题
• 了解修复优先级
• 跟踪修复进度

🔍 安全团队需要：
• 审计安全合规性
• 分析安全趋势
• 制定安全策略
```

### 7.2 GitLab安全报告类型


**不同类型的报告**：

| 报告类型 | **内容** | **查看方式** | **适用人群** |
|---------|---------|-------------|-------------|
| 🔍 **漏洞报告** | `具体漏洞详情和修复建议` | `合并请求页面` | `开发人员` |
| 📊 **安全仪表板** | `项目整体安全状况` | `项目安全页面` | `项目经理` |
| 📈 **趋势报告** | `安全问题变化趋势` | `安全分析页面` | `安全团队` |
| 📋 **合规报告** | `合规检查结果` | `导出PDF/Excel` | `管理层` |

### 7.3 查看和使用安全报告


**在GitLab界面查看报告**：
```
📍 查看路径：
项目首页 → 左侧菜单 → Security & Compliance → Vulnerability Report

📊 报告内容包括：
• 漏洞总数和严重程度分布
• 新发现的漏洞
• 已修复的漏洞  
• 漏洞修复建议
```

**合并请求中的安全检查**：
```
当你提交合并请求时，GitLab会显示：

✅ 安全扫描通过：
   • 依赖扫描：未发现新漏洞
   • 容器扫描：未发现新漏洞
   • SAST扫描：未发现新问题

❌ 发现安全问题：
   • 🔴 发现 2 个高危漏洞
   • 🟡 发现 5 个中等风险问题
   • 点击查看详细信息
```

### 7.4 自定义安全报告


**生成自定义报告**：
```yaml
# 生成安全报告的作业
generate_security_report:
  stage: report
  image: python:3.9
  script:
    # 收集所有安全扫描结果
    - |
      python << 'EOF'
      import json
      import datetime
      
      # 读取各种扫描结果
      with open('gl-dependency-scanning-report.json', 'r') as f:
          deps_report = json.load(f)
      
      with open('gl-sast-report.json', 'r') as f:
          sast_report = json.load(f)
      
      # 生成汇总报告
      summary = {
          "scan_date": datetime.datetime.now().isoformat(),
          "project": "$CI_PROJECT_NAME",
          "branch": "$CI_COMMIT_BRANCH",
          "vulnerabilities": {
              "critical": 0,
              "high": 0, 
              "medium": 0,
              "low": 0
          }
      }
      
      # 统计漏洞数量
      for vuln in deps_report.get('vulnerabilities', []):
          severity = vuln.get('severity', 'unknown').lower()
          if severity in summary['vulnerabilities']:
              summary['vulnerabilities'][severity] += 1
      
      # 生成HTML报告
      html_content = f"""
      <html>
      <head><title>安全扫描报告</title></head>
      <body>
          <h1>项目 {summary['project']} 安全报告</h1>
          <p>扫描时间：{summary['scan_date']}</p>
          <p>分支：{summary['branch']}</p>
          
          <h2>漏洞统计</h2>
          <ul>
              <li>严重：{summary['vulnerabilities']['critical']}</li>
              <li>高危：{summary['vulnerabilities']['high']}</li>
              <li>中等：{summary['vulnerabilities']['medium']}</li>
              <li>较低：{summary['vulnerabilities']['low']}</li>
          </ul>
      </body>
      </html>
      """
      
      with open('security-report.html', 'w') as f:
          f.write(html_content)
      EOF
      
  artifacts:
    reports:
      # GitLab会自动处理这些报告
      dependency_scanning: gl-dependency-scanning-report.json
      sast: gl-sast-report.json
    paths:
      # 自定义报告文件
      - security-report.html
    expire_in: 1 week
```

### 7.5 安全报告最佳实践


**报告使用建议**：

> 💡 **开发人员**：
> - 每次合并请求都检查安全扫描结果
> - 优先修复严重和高危漏洞
> - 了解常见安全问题的修复方法

> 📊 **项目经理**：
> - 定期查看安全仪表板
> - 跟踪漏洞修复进度
> - 在项目计划中预留安全修复时间

> 🔒 **安全团队**：
> - 设置漏洞通知和告警
> - 定期审查安全策略配置
> - 分析安全趋势制定改进措施

**报告自动化通知**：
```yaml
# 发送安全报告邮件
send_security_notification:
  stage: notify
  script:
    - |
      # 检查是否有高危漏洞
      if [ -f "gl-dependency-scanning-report.json" ]; then
        CRITICAL_COUNT=$(jq '.vulnerabilities[] | select(.severity=="Critical") | length' gl-dependency-scanning-report.json)
        
        if [ "$CRITICAL_COUNT" -gt "0" ]; then
          echo "发现 $CRITICAL_COUNT 个严重漏洞，发送告警邮件"
          # 这里可以集成邮件发送或Slack通知
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"项目 $CI_PROJECT_NAME 发现 $CRITICAL_COUNT 个严重安全漏洞，请及时处理\"}" \
            $SLACK_WEBHOOK_URL
        fi
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 安全扫描本质：自动化的代码"体检"，发现安全隐患
🔸 四种扫描类型：依赖扫描、容器扫描、SAST、DAST各有侧重
🔸 扫描时机：贯穿整个开发流程，越早发现越容易修复
🔸 报告价值：不仅要扫描，更要看懂报告并采取行动
```

### 8.2 关键理解要点


**🔹 安全扫描的互补性**：
```
每种扫描都有局限性，需要组合使用：
• 依赖扫描：发现第三方库问题
• 容器扫描：发现部署环境问题  
• SAST：发现代码逻辑问题
• DAST：发现实际运行问题

就像体检要做多项检查，不能只查一个项目
```

**🔹 扫描结果的处理策略**：
```
优先级处理：
🔴 严重/高危 → 立即修复，阻止发布
🟡 中等风险 → 计划修复，跟踪进度
🟢 低风险 → 择机修复，定期评估

平衡考虑：
• 安全性 vs 开发效率
• 扫描覆盖 vs 构建速度
• 严格检查 vs 项目进度
```

**🔹 安全文化的建立**：
```
技术层面：
• 配置自动化扫描
• 建立修复流程
• 持续改进规则

团队层面：
• 提高安全意识
• 培训修复技能
• 建立责任机制
```

### 8.3 实际应用价值


**🎯 对于新手开发者**：
- 通过扫描学习常见安全问题
- 养成安全编码的好习惯
- 了解如何修复安全漏洞

**🎯 对于项目团队**：
- 建立自动化安全检查流程
- 减少生产环境安全事故
- 提高代码质量和安全性

**🎯 对于企业组织**：
- 满足安全合规要求
- 降低安全风险和成本
- 建立安全开发文化

### 8.4 常见问题和解决方案


**🤔 扫描太慢怎么办**：
```
问题：安全扫描让CI流水线变慢
解决：
• 并行执行多种扫描
• 增量扫描只检查变更部分
• 快速扫描用于合并请求，完整扫描用于主分支
```

**🤔 误报太多怎么办**：
```
问题：扫描工具报告很多误报
解决：  
• 调整扫描规则和阈值
• 建立白名单忽略已知误报
• 选择更准确的扫描工具
```

**🤔 修复成本太高怎么办**：
```
问题：修复所有漏洞工作量太大
解决：
• 优先修复高危漏洞
• 逐步建立安全债务清理计划
• 在新功能开发中集成安全要求
```

### 8.5 学习路径建议


**📚 新手学习顺序**：
1. **理解概念**：先理解什么是安全扫描，为什么需要
2. **配置实践**：在测试项目中配置基础扫描
3. **分析报告**：学会看懂扫描报告，理解漏洞含义
4. **修复实践**：动手修复一些常见的安全问题
5. **进阶配置**：学习高级配置和自定义规则

**🎯 实践建议**：
- 从一个简单的项目开始配置安全扫描
- 故意在代码中留一些安全问题，看扫描能否发现
- 查看开源项目的安全配置，学习最佳实践
- 关注安全漏洞数据库，了解最新的安全威胁

**核心记忆要点**：
- 安全扫描是保护应用的重要防线
- 四种扫描各有作用，需要合理组合
- 扫描只是开始，修复问题才是关键
- 安全是一个持续的过程，不是一次性任务