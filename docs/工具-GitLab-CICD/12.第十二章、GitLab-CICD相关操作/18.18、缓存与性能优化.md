---
title: 18、缓存与性能优化
---
## 📚 目录

1. [缓存机制基础理解](#1-缓存机制基础理解)
2. [cache缓存配置详解](#2-cache缓存配置详解)
3. [缓存键值设计策略](#3-缓存键值设计策略)
4. [缓存策略选择指南](#4-缓存策略选择指南)
5. [依赖项缓存优化](#5-依赖项缓存优化)
6. [Docker层缓存利用](#6-Docker层缓存利用)
7. [Pipeline执行时间优化](#7-Pipeline执行时间优化)
8. [资源使用优化](#8-资源使用优化)
9. [网络传输优化](#9-网络传输优化)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🎯 缓存机制基础理解


### 1.1 什么是GitLab CI/CD缓存


**💡 通俗理解**：
想象你每天上班都要从家里带午餐，如果每次都重新做饭会很累。聪明的做法是一次做几天的份量，放冰箱里保存。GitLab CI/CD的缓存就像这个"冰箱"，把构建过程中产生的文件保存起来，下次直接用，不用重新"做饭"。

**🔸 缓存的本质**：
```
没有缓存的情况：
构建任务1 → 下载依赖 → 编译 → 测试 ✓
构建任务2 → 下载依赖 → 编译 → 测试 ✓  (重复下载)
构建任务3 → 下载依赖 → 编译 → 测试 ✓  (重复下载)

有缓存的情况：
构建任务1 → 下载依赖 → [保存到缓存] → 编译 → 测试 ✓
构建任务2 → [从缓存恢复] → 编译 → 测试 ✓  (节省时间)
构建任务3 → [从缓存恢复] → 编译 → 测试 ✓  (节省时间)
```

### 1.2 缓存vs制品的区别


很多新手容易混淆这两个概念，我们来简单对比：

| 特性 | **缓存(Cache)** | **制品(Artifacts)** |
|------|----------------|-------------------|
| **目的** | `提高构建速度` | `传递构建结果` |
| **内容** | `依赖包、编译缓存` | `可执行文件、报告` |
| **生命周期** | `可能失效，不保证存在` | `保证在指定时间内存在` |
| **使用场景** | `优化性能` | `部署和测试` |

**🔧 实际例子**：
```
Node.js项目：
缓存：node_modules/ 文件夹（依赖包）
制品：dist/ 文件夹（构建后的代码）

Java项目：
缓存：.m2/repository/ （Maven依赖）
制品：target/*.jar （编译后的jar包）
```

### 1.3 缓存工作原理图解


```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Job执行开始    │───▶│   检查缓存存在   │───▶│   恢复缓存文件   │
│                │    │                │    │                │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                ▲                       │
                                │ 不存在                │ 存在
                                │                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   上传新缓存     │◀───│   执行构建任务   │◀───│   正常执行任务   │
│                │    │                │    │                │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

---

## 2. ⚙️ cache缓存配置详解


### 2.1 基础缓存配置语法


**🔸 最简单的缓存配置**：

```yaml
# 基础语法示例
build_job:
  script:
    - npm install
    - npm run build
  cache:
    paths:
      - node_modules/    # 缓存npm依赖
```

> 💡 **新手提示**：`paths`就是告诉GitLab"把这些文件夹保存起来，下次用"

### 2.2 完整缓存配置选项


```yaml
build_job:
  script:
    - npm install
    - npm run build
  cache:
    # 缓存的键值（用来识别不同的缓存）
    key: 
      files:
        - package-lock.json    # 当这个文件变化时，缓存就失效
    
    # 要缓存的文件路径
    paths:
      - node_modules/
      - .npm/
    
    # 缓存策略
    policy: pull-push      # 既下载也上传缓存
    
    # 缓存何时生效
    when: on_success       # 只有任务成功时才保存缓存
    
    # 是否允许缓存失败
    untracked: false       # 不缓存未被Git跟踪的文件
```

### 2.3 缓存配置参数详解


**🔧 key（缓存键值）**：
```yaml
# 方式1：固定键值
cache:
  key: "my-cache"

# 方式2：基于分支名
cache:
  key: "$CI_COMMIT_REF_SLUG"

# 方式3：基于文件内容（推荐）
cache:
  key:
    files:
      - Gemfile.lock     # Ruby项目
      - package-lock.json # Node.js项目
      - pom.xml          # Java项目
```

> 🎯 **关键理解**：缓存键值就像给每个缓存起个名字，相同名字的缓存会被复用

**🔧 policy（缓存策略）**：
```yaml
# pull-push：默认策略，既下载也上传
cache:
  policy: pull-push

# pull：只下载，不上传（适合只读任务）
cache:
  policy: pull

# push：只上传，不下载（适合初始化任务）
cache:
  policy: push
```

**🔧 when（保存时机）**：
```yaml
cache:
  when: on_success    # 任务成功时保存（默认）
  when: on_failure    # 任务失败时也保存
  when: always        # 总是保存
```

---

## 3. 🔑 缓存键值设计策略


### 3.1 为什么缓存键值很重要


**💭 思考场景**：
假设你有一个购物清单APP，你希望缓存购物数据。如果每个用户都用同一个缓存名字，就会出现张三的购物清单被李四看到的问题。缓存键值就是为了避免这种"串台"现象。

```
错误设计：
用户A → 缓存键: "shopping-list" → 存储A的数据
用户B → 缓存键: "shopping-list" → 覆盖了A的数据 ❌

正确设计：
用户A → 缓存键: "shopping-list-userA" → 存储A的数据
用户B → 缓存键: "shopping-list-userB" → 存储B的数据 ✅
```

### 3.2 常见的键值设计模式


**🎯 模式1：基于文件内容**
```yaml
# Node.js项目推荐方式
cache:
  key:
    files:
      - package-lock.json
  paths:
    - node_modules/
```

**为什么这样设计？**
- `package-lock.json`记录了具体的依赖版本
- 文件内容变化 → 缓存键值变化 → 重新下载依赖
- 文件不变 → 键值不变 → 复用缓存

**🎯 模式2：组合键值**
```yaml
cache:
  key: "$CI_COMMIT_REF_SLUG-$CI_JOB_NAME"
  paths:
    - node_modules/
```

**🎯 模式3：回退键值（高级用法）**
```yaml
cache:
  - key:
      files:
        - package-lock.json
    paths:
      - node_modules/
  - key: "$CI_COMMIT_REF_SLUG"    # 回退键值
    paths:
      - node_modules/
```

> 💡 **回退机制**：如果第一个缓存找不到，就用第二个，类似"找不到精确匹配就用大概匹配"

### 3.3 不同语言的最佳实践


```yaml
# Node.js项目
node_cache:
  key:
    files:
      - package-lock.json
  paths:
    - node_modules/
    - .npm/

# Python项目  
python_cache:
  key:
    files:
      - requirements.txt
  paths:
    - .pip-cache/

# Java Maven项目
maven_cache:
  key:
    files:
      - pom.xml
  paths:
    - .m2/repository/

# PHP Composer项目
composer_cache:
  key:
    files:
      - composer.lock
  paths:
    - vendor/
```

---

## 4. 📋 缓存策略选择指南


### 4.1 三种缓存策略对比


```
构建流程可视化：

pull-push策略（默认）：
┌─────────┐  下载缓存  ┌─────────┐  执行任务  ┌─────────┐  上传缓存  ┌─────────┐
│ 开始    │ ────────▶ │ 恢复文件 │ ────────▶ │ 构建代码 │ ────────▶ │ 结束    │
└─────────┘           └─────────┘           └─────────┘           └─────────┘

pull策略（只读）：
┌─────────┐  下载缓存  ┌─────────┐  执行任务  ┌─────────┐
│ 开始    │ ────────▶ │ 恢复文件 │ ────────▶ │ 结束    │
└─────────┘           └─────────┘           └─────────┘

push策略（只写）：
┌─────────┐  执行任务  ┌─────────┐  上传缓存  ┌─────────┐
│ 开始    │ ────────▶ │ 构建代码 │ ────────▶ │ 结束    │
└─────────┘           └─────────┘           └─────────┘
```

### 4.2 策略选择实战指南


**✅ pull-push策略使用场景**：
```yaml
# 标准构建任务
build:
  script:
    - npm install      # 可能修改node_modules
    - npm run build
  cache:
    policy: pull-push  # 既要使用旧缓存，也要保存新缓存
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
```

**✅ pull策略使用场景**：
```yaml
# 测试任务（不修改依赖）
test:
  script:
    - npm test         # 只读取node_modules，不修改
  cache:
    policy: pull       # 只需要使用缓存，不用保存
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
```

**✅ push策略使用场景**：
```yaml
# 依赖安装任务
install_deps:
  script:
    - npm ci            # 全新安装依赖
  cache:
    policy: push       # 只保存缓存，不需要使用旧缓存
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
```

### 4.3 多任务缓存协作示例


```yaml
stages:
  - prepare
  - build
  - test

# 第1步：准备依赖（只上传）
prepare:
  stage: prepare
  script:
    - npm ci
  cache:
    policy: push       # 只保存，为后续任务准备缓存
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/

# 第2步：构建（既下载又上传）
build:
  stage: build
  script:
    - npm run build
  cache:
    policy: pull-push  # 使用prepare的缓存，同时保存构建缓存
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
      - dist/           # 额外缓存构建产物

# 第3步：测试（只下载）
test:
  stage: test
  script:
    - npm test
  cache:
    policy: pull       # 只使用缓存，不修改
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
```

---

## 5. 📦 依赖项缓存优化


### 5.1 不同包管理器的缓存策略


**🔸 npm缓存优化**：
```yaml
npm_build:
  before_script:
    # 设置npm缓存目录
    - npm config set cache .npm
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run build
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
      - .npm/           # 缓存npm自身的缓存
```

> 💡 **解释**：`--prefer-offline`让npm优先使用本地缓存，减少网络请求

**🔸 yarn缓存优化**：
```yaml
yarn_build:
  before_script:
    - yarn config set cache-folder .yarn-cache
    - yarn install --frozen-lockfile --cache-folder .yarn-cache
  script:
    - yarn build
  cache:
    key:
      files:
        - yarn.lock
    paths:
      - node_modules/
      - .yarn-cache/
```

**🔸 pip缓存优化**：
```yaml
python_build:
  before_script:
    - pip config set global.cache-dir .pip-cache
    - pip install -r requirements.txt
  script:
    - python setup.py build
  cache:
    key:
      files:
        - requirements.txt
    paths:
      - .pip-cache/
```

### 5.2 多层缓存策略


```yaml
# 分层缓存：系统级 + 项目级
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"

python_job:
  cache:
    # 第1层：基础系统缓存
    - key: "python-$PYTHON_VERSION"
      paths:
        - .pip-cache/pip/
    
    # 第2层：项目依赖缓存  
    - key:
        files:
          - requirements.txt
      paths:
        - .pip-cache/
        - venv/
  script:
    - python -m venv venv
    - source venv/bin/activate
    - pip install -r requirements.txt
    - python setup.py test
```

### 5.3 依赖锁定文件最佳实践


> ⚠️ **重要提醒**：始终基于锁定文件设计缓存键值

**为什么要用锁定文件？**
```
package.json（描述文件）:
"dependencies": {
  "lodash": "^4.17.0"    # 模糊版本，可能匹配4.17.0-4.99.x
}

package-lock.json（锁定文件）:
"lodash": {
  "version": "4.17.21",  # 精确版本
  "resolved": "https://...",
  "integrity": "sha512-..."
}
```

**正确的缓存设计**：
```yaml
# ✅ 正确：基于锁定文件
cache:
  key:
    files:
      - package-lock.json    # 精确控制缓存失效时机

# ❌ 错误：基于描述文件  
cache:
  key:
    files:
      - package.json         # 可能导致版本不一致
```

---

## 6. 🐳 Docker层缓存利用


### 6.1 Docker层缓存基础概念


**💭 理解Docker层缓存**：
想象建房子，每一层楼都是Docker的一层。如果底层没变，就不用重新建，直接在上面继续盖就行。

```
Dockerfile示例：
FROM node:16              ← 层1：基础镜像
COPY package*.json ./     ← 层2：复制依赖文件  
RUN npm install           ← 层3：安装依赖（耗时）
COPY . .                  ← 层4：复制源代码
RUN npm run build         ← 层5：构建应用

如果只有源代码变了：
层1-3可以复用缓存 ✅
只需要重新执行层4-5 ⚡
```

### 6.2 优化Docker缓存的写法


**🔧 优化前（缓存效果差）**：
```dockerfile
FROM node:16
COPY . .                    # 一次性复制所有文件
RUN npm install            # 源代码变化就要重新安装依赖
RUN npm run build
```

**🔧 优化后（缓存效果好）**：
```dockerfile
FROM node:16
COPY package*.json ./       # 先只复制依赖描述文件
RUN npm install            # 依赖文件不变就能复用缓存
COPY . .                   # 再复制源代码
RUN npm run build
```

### 6.3 GitLab CI中的Docker缓存配置


```yaml
build_docker:
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    # 拉取之前的镜像作为缓存
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    
    # 使用cache-from参数利用层缓存
    - >
      docker build
      --cache-from $CI_REGISTRY_IMAGE:latest
      --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      --tag $CI_REGISTRY_IMAGE:latest
      .
    
    # 推送新镜像
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
```

### 6.4 Kaniko缓存（无Docker环境）


```yaml
# 使用Kaniko在Kubernetes环境中构建
build_kaniko:
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - >
      /kaniko/executor
      --context $CI_PROJECT_DIR
      --dockerfile $CI_PROJECT_DIR/Dockerfile
      --destination $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      --cache=true                    # 启用层缓存
      --cache-repo $CI_REGISTRY_IMAGE/cache  # 缓存仓库
```

---

## 7. ⚡ Pipeline执行时间优化


### 7.1 并行化任务执行


**🎯 串行vs并行对比**：
```
串行执行（慢）：
测试Job1 → 测试Job2 → 测试Job3 → 部署    总时间：15分钟
  5分钟     5分钟      5分钟     3分钟

并行执行（快）：
测试Job1 ─┐
          ├─ 部署                      总时间：8分钟  
测试Job2 ─┤  3分钟
          │
测试Job3 ─┘
5分钟并行执行
```

**🔧 并行配置实例**：
```yaml
stages:
  - test
  - deploy

# 这些测试任务会并行执行
unit_test:
  stage: test
  script:
    - npm run test:unit

integration_test:
  stage: test  
  script:
    - npm run test:integration

lint_check:
  stage: test
  script:
    - npm run lint

# 只有所有测试通过才会执行部署
deploy:
  stage: deploy
  script:
    - npm run deploy
  needs: ["unit_test", "integration_test", "lint_check"]
```

### 7.2 智能任务依赖


```yaml
stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - npm run build
  artifacts:
    paths:
      - dist/

# 不等待其他测试，只要build完成就开始
deploy_staging:
  stage: deploy
  script:
    - deploy-to-staging.sh
  needs: ["build"]        # 只依赖build任务
  environment: staging

# 需要所有测试通过
deploy_production:
  stage: deploy  
  script:
    - deploy-to-prod.sh
  needs:                 # 依赖多个任务
    - job: build
      artifacts: true    # 需要build的产物
    - job: unit_test
      artifacts: false   # 不需要测试的产物
    - job: integration_test
      artifacts: false
  environment: production
```

### 7.3 增量构建策略


```yaml
# 只在相关文件变化时才执行
frontend_test:
  script:
    - npm test
  rules:
    - changes:           # 只有这些路径的文件变化才执行
        - "frontend/**/*"
        - "package*.json"

backend_test:
  script:
    - pytest
  rules:
    - changes:
        - "backend/**/*"
        - "requirements.txt"

# 数据库迁移只在schema变化时执行
db_migrate:
  script:
    - run-migrations.sh
  rules:
    - changes:
        - "database/**/*"
```

### 7.4 失败快速反馈


```yaml
# 快速检查放在前面
stages:
  - quick_check    # 快速检查阶段
  - build
  - test
  - deploy

# 语法检查（1分钟内完成）
lint:
  stage: quick_check
  script:
    - npm run lint
  
# 类型检查（2分钟内完成）  
type_check:
  stage: quick_check
  script:
    - npm run type-check

# 只有快速检查通过才进行耗时的构建
build:
  stage: build
  script:
    - npm run build    # 可能需要5-10分钟
  needs: ["lint", "type_check"]
```

---

## 8. 💾 资源使用优化


### 8.1 Runner资源配置


**🔧 为不同任务选择合适的Runner**：
```yaml
# 轻量级任务：小规格Runner
lint_job:
  tags:
    - small-runner     # 1核1G内存就够了
  script:
    - npm run lint

# 构建任务：中等规格Runner
build_job:
  tags:
    - medium-runner    # 2核4G内存
  script:
    - npm run build

# 测试任务：大规格Runner
test_job:
  tags:
    - large-runner     # 4核8G内存，用于并行测试
  script:
    - npm run test:parallel
```

### 8.2 内存使用优化


```yaml
# Node.js内存优化
build_node:
  variables:
    NODE_OPTIONS: "--max-old-space-size=4096"  # 设置4G内存限制
  script:
    - npm run build

# Java内存优化
build_java:
  variables:
    MAVEN_OPTS: "-Xmx2g -XX:+UseG1GC"         # 设置堆内存和垃圾回收器
  script:
    - mvn clean package

# Python内存优化
test_python:
  variables:
    PYTEST_WORKERS: "4"                        # 控制并行测试进程数
  script:
    - pytest -n $PYTEST_WORKERS
```

### 8.3 磁盘空间管理


```yaml
build_job:
  before_script:
    # 清理旧的构建文件
    - rm -rf dist/ build/ target/
    
    # 检查磁盘空间
    - df -h
  script:
    - npm run build
  after_script:
    # 清理临时文件
    - npm cache clean --force
    - rm -rf node_modules/.cache/
    
    # 再次检查磁盘使用情况
    - df -h
```

### 8.4 并发任务数量控制


```yaml
# 限制同时运行的任务数量
variables:
  GITLAB_CI_CONCURRENT_BUILDS: "3"    # 最多3个任务并行

# 为特定任务设置资源限制
heavy_task:
  resource_group: production          # 资源组，同时只能有1个任务运行
  script:
    - deploy-to-production.sh

# 数据库相关任务串行执行
db_task_1:
  resource_group: database
  script:
    - run-migration-1.sh

db_task_2:  
  resource_group: database           # 与db_task_1共享资源组
  script:
    - run-migration-2.sh
```

---

## 9. 🌐 网络传输优化


### 9.1 镜像和依赖源优化


**🔧 使用国内镜像源**：
```yaml
variables:
  # Node.js镜像源
  NPM_CONFIG_REGISTRY: "https://registry.npmmirror.com"
  
  # Python镜像源
  PIP_INDEX_URL: "https://pypi.tuna.tsinghua.edu.cn/simple"
  
  # Maven镜像源
  MAVEN_MIRROR_URL: "https://maven.aliyun.com/repository/public"

build_node:
  script:
    - npm config set registry $NPM_CONFIG_REGISTRY
    - npm install
    - npm run build

build_python:
  script:
    - pip install -i $PIP_INDEX_URL -r requirements.txt
    - python setup.py build
```

### 9.2 Git策略优化


```yaml
variables:
  # 浅克隆，只获取最新提交
  GIT_DEPTH: "1"
  
  # 不下载Git LFS文件（如果不需要的话）
  GIT_LFS_SKIP_SMUDGE: "1"

# 对于需要完整历史的任务，单独配置
security_scan:
  variables:
    GIT_DEPTH: "0"        # 获取完整历史，用于安全扫描
  script:
    - security-scanner.sh
```

### 9.3 制品传输优化


```yaml
build:
  script:
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 hour     # 缩短制品保存时间
    when: on_success      # 只在成功时保存
    compress: true        # 启用压缩（默认开启）

# 只传输必要的制品
test:
  script:
    - npm test
  artifacts:
    reports:
      junit: test-results.xml    # 只上传测试报告，不上传全部文件
```

### 9.4 缓存预热策略


```yaml
# 在非高峰时间预热缓存
cache_warmup:
  stage: .pre              # 在所有其他阶段之前执行
  script:
    - npm ci               # 预先下载依赖
  cache:
    policy: push           # 只上传缓存
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"    # 只在定时任务中执行
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```yaml
🔸 缓存本质：保存构建过程中的文件，避免重复下载和计算
🔸 缓存vs制品：缓存用于提速，制品用于传递结果
🔸 键值设计：基于依赖锁定文件，确保缓存精确失效
🔸 策略选择：pull-push（默认）、pull（只读）、push（只写）
🔸 Docker缓存：优化Dockerfile层级，利用层缓存机制
```

### 10.2 性能优化核心策略


**🎯 时间优化**：
- **并行化**：无依赖的任务并行执行
- **智能依赖**：使用`needs`精确控制任务依赖
- **增量构建**：只在相关文件变化时执行
- **快速反馈**：轻量检查放在前面

**🎯 资源优化**：
- **分级Runner**：不同任务使用合适规格的Runner
- **内存控制**：设置合理的内存限制
- **磁盘管理**：及时清理临时文件
- **并发控制**：使用资源组控制并发数量

**🎯 网络优化**：
- **镜像源**：使用国内镜像源加速下载
- **Git策略**：浅克隆减少传输量
- **制品管理**：只传输必要文件，设置合理过期时间

### 10.3 最佳实践清单


**✅ 缓存配置检查清单**：
- [ ] 使用依赖锁定文件作为缓存键值
- [ ] 为不同类型的任务选择合适的缓存策略
- [ ] 设置合理的缓存路径，避免缓存无关文件
- [ ] 考虑使用回退键值提高缓存命中率

**✅ 性能优化检查清单**：
- [ ] 识别可以并行执行的任务
- [ ] 使用`needs`减少不必要的等待
- [ ] 为快速失败的检查设置独立阶段
- [ ] 根据文件变化情况配置增量构建

**✅ 资源管理检查清单**：
- [ ] 为不同负载的任务配置合适的Runner
- [ ] 设置合理的内存和并发限制
- [ ] 定期清理缓存和临时文件
- [ ] 监控资源使用情况并及时调整

### 10.4 常见问题与解决方案


| 问题症状 | **可能原因** | **解决方案** |
|---------|-------------|-------------|
| `缓存总是失效` | `键值设计不当` | `使用依赖锁定文件作为键值` |
| `构建时间很长` | `任务串行执行` | `识别可并行任务，使用needs优化依赖` |
| `磁盘空间不足` | `缓存文件积累` | `定期清理，设置合理的缓存策略` |
| `网络下载慢` | `使用默认源` | `配置国内镜像源，使用浅克隆` |
| `Runner资源不足` | `所有任务用同一规格` | `为不同任务配置不同规格的Runner` |

### 10.5 进阶学习建议


**🚀 下一步可以深入的方向**：
- **监控指标**：学习使用GitLab的性能监控功能
- **自定义Runner**：配置和优化自己的GitLab Runner
- **高级缓存**：研究分布式缓存和外部缓存系统
- **容器优化**：深入学习Docker多阶段构建和镜像优化

**核心记忆要点**：
- 缓存设计重在键值，基于依赖文件变化
- 性能优化重在并行，减少不必要等待
- 资源管理重在分级，不同任务不同配置
- 网络优化重在就近，使用合适的镜像源

> 💡 **新手总结**：GitLab CI/CD的缓存和优化就像是给你的构建过程"装上轮子"和"加上引擎"，让原本缓慢的构建过程变得快速高效。记住关键是合理设计缓存键值，充分利用并行性，选择合适的资源配置。