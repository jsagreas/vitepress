---
title: 25、Web应用CICD实战
---
## 📚 目录

1. [Web应用CI/CD概述](#1-Web应用CI/CD概述)
2. [前端项目CI/CD配置](#2-前端项目CI/CD配置)
3. [后端API项目Pipeline](#3-后端API项目Pipeline)
4. [数据库迁移集成](#4-数据库迁移集成)
5. [静态资源部署策略](#5-静态资源部署策略)
6. [域名切换与健康检查](#6-域名切换与健康检查)
7. [回滚机制实现](#7-回滚机制实现)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🌐 Web应用CI/CD概述


### 1.1 什么是Web应用CI/CD


**🔸 简单理解**
想象你开了一家餐厅，每天都要上新菜品。传统方式是：厨师做好菜→老板试吃→觉得好吃才给客人。但这样太慢了！

CI/CD就像是给餐厅装了一条**自动化流水线**：
- **CI（持续集成）**：厨师做菜时，机器自动检查食材新鲜度、调料比例
- **CD（持续部署）**：检查通过后，自动端给客人，无需老板每次都试吃

```
传统开发流程：
开发代码 → 手动测试 → 手动部署 → 祈祷不出错 😰

CI/CD流程：
开发代码 → 自动测试 → 自动部署 → 出错自动回滚 😎
```

### 1.2 Web应用的特殊性


**🏗️ Web应用的组成部分**
```
完整的Web应用就像一栋大楼：

前端（用户看到的界面）
├── HTML/CSS/JavaScript 文件
├── 图片、字体等静态资源
└── 需要编译压缩的代码

后端（处理业务逻辑）
├── API接口服务
├── 业务逻辑代码
└── 配置文件

数据库（存储数据）
├── 数据表结构
├── 初始数据
└── 升级脚本
```

**⭐ 难度等级：** ⭐⭐⭐☆☆ （需要协调多个组件）

### 1.3 实战项目架构


**📋 我们要搭建的系统**
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 Vue.js   │────│   后端 Node.js  │────│   MySQL数据库   │
│   (Port 3000)   │    │   (Port 8080)   │    │   (Port 3306)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   GitLab CI/CD  │
                    │   自动化部署     │
                    └─────────────────┘
```

---

## 2. 🎨 前端项目CI/CD配置


### 2.1 前端项目的特点


**🎯 前端部署要做什么？**

把前端项目想象成**装修房子**：
- **原材料**：Vue/React源代码（就像水泥、砖头）
- **加工过程**：编译、压缩、优化（就像把砖头砌成墙）
- **最终产品**：静态HTML/CSS/JS文件（就像装修好的房子）
- **搬家入住**：部署到服务器（就像把房子交给客户）

```
前端构建流程：
源代码 → 安装依赖 → 编译构建 → 压缩优化 → 静态文件 → 部署上线
```

### 2.2 前端Pipeline配置


> 💡 **配置思路**：前端主要是把源代码"加工"成浏览器能直接运行的文件

```yaml
# .gitlab-ci.yml (前端部分)
stages:
  - build    # 构建阶段
  - test     # 测试阶段  
  - deploy   # 部署阶段

# 🔧 构建前端代码
build_frontend:
  stage: build
  image: node:18-alpine    # 使用Node.js环境
  before_script:
    - npm config set registry https://registry.npmmirror.com  # 使用国内镜像
  script:
    - npm install          # 安装依赖包
    - npm run build        # 编译打包
  artifacts:
    paths:
      - dist/              # 保存构建产物
    expire_in: 1 day       # 保存1天
  only:
    - main                 # 只在main分支执行
```

**🧠 记忆技巧**：`build_frontend` = 建造前端房子

### 2.3 前端测试集成


```yaml
# 🧪 前端测试
test_frontend:
  stage: test
  image: node:18-alpine
  script:
    - npm install
    - npm run test:unit    # 单元测试
    - npm run lint         # 代码规范检查
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'  # 测试覆盖率
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
```

> ⚠️ **重要提醒**：测试不通过，就不会部署，这样避免了把有问题的代码发布给用户

### 2.4 前端部署策略


**🚀 部署到不同环境**

```yaml
# 🌱 部署到测试环境
deploy_frontend_staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache rsync openssh
  script:
    - rsync -avz --delete dist/ user@test-server:/var/www/test/
  environment:
    name: staging
    url: https://test.example.com
  only:
    - develop

# 🚀 部署到生产环境  
deploy_frontend_production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache rsync openssh
  script:
    - rsync -avz --delete dist/ user@prod-server:/var/www/prod/
  environment:
    name: production
    url: https://www.example.com
  when: manual              # 手动触发，更安全
  only:
    - main
```

**📈 部署流程图示**
```
代码提交
    ↓
自动构建 → 构建成功？ → No → 停止，通知开发者
    ↓           Yes
自动测试 → 测试通过？ → No → 停止，通知开发者  
    ↓           Yes
部署到测试环境 → 手动确认 → 部署到生产环境
```

---

## 3. ⚙️ 后端API项目Pipeline


### 3.1 后端项目特点


**🔧 后端部署要做什么？**

把后端项目想象成**开餐厅的后厨**：
- **食材准备**：安装依赖包（就像准备各种调料）
- **菜谱检查**：运行测试（就像试做菜品）
- **后厨就绪**：启动服务（就像开始营业）
- **服务客人**：处理API请求（就像客人点菜）

### 3.2 后端Pipeline配置


```yaml
# 🏗️ 后端构建
build_backend:
  stage: build
  image: node:18-alpine
  script:
    - cd backend/
    - npm install
    - npm run build        # 如果有编译步骤
  artifacts:
    paths:
      - backend/node_modules/
      - backend/dist/
    expire_in: 1 day

# 🧪 后端测试  
test_backend:
  stage: test
  image: node:18-alpine
  services:
    - mysql:8.0           # 启动MySQL用于测试
  variables:
    MYSQL_ROOT_PASSWORD: testpass
    MYSQL_DATABASE: testdb
  script:
    - cd backend/
    - npm run test
    - npm run test:integration  # 集成测试
```

**💡 小贴士**：`services` 就是给你的测试环境"配菜"，需要数据库就加数据库

### 3.3 API健康检查


```yaml
# 🏥 API健康检查
health_check:
  stage: test
  image: curlimages/curl:latest
  script:
    - curl -f http://localhost:8080/health || exit 1
  needs:
    - deploy_backend_staging
  only:
    - develop
```

> 🔍 **深入思考**：为什么要做健康检查？就像餐厅开门前要确保厨房设备都正常工作

### 3.4 后端部署配置


```yaml
# 🚀 后端部署
deploy_backend:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh rsync
  script:
    # 上传代码
    - rsync -avz --exclude node_modules backend/ user@server:/app/
    # 安装依赖
    - ssh user@server "cd /app && npm install --production"
    # 重启服务
    - ssh user@server "pm2 restart api-server"
  environment:
    name: production
    url: https://api.example.com
```

**🛠️ 部署过程详解**
```
本地代码 → 上传到服务器 → 安装依赖 → 重启应用
     ↓              ↓            ↓          ↓
   打包文件      rsync同步    npm install   pm2重启
```

---

## 4. 🗄️ 数据库迁移集成


### 4.1 什么是数据库迁移


**🏠 数据库迁移就像装修房子**

想象你的数据库是一间房子：
- **初始状态**：空房子（新数据库）
- **第一次装修**：添加桌椅（创建表）
- **二次装修**：加个书柜（新增字段）
- **三次装修**：换个大床（修改字段类型）

每次"装修"都要记录下来，这样别人也能按照你的步骤装修出一模一样的房子！

### 4.2 迁移脚本管理


**📋 迁移文件示例**
```sql
-- migrations/001_create_users_table.sql
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- migrations/002_add_user_avatar.sql  
ALTER TABLE users ADD COLUMN avatar_url VARCHAR(500);

-- migrations/003_create_posts_table.sql
CREATE TABLE posts (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(255) NOT NULL,
  content TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 4.3 Pipeline中的数据库迁移


```yaml
# 🗄️ 数据库迁移
migrate_database:
  stage: deploy
  image: migrate/migrate:latest
  script:
    # 运行数据库迁移
    - migrate -path ./migrations -database "mysql://user:pass@tcp(db:3306)/myapp" up
  environment:
    name: production
  when: manual              # 手动执行，避免误操作
  allow_failure: false      # 迁移失败则停止部署
```

**⚠️ 重要注意事项**
```
数据库迁移的黄金法则：
✅ 先备份，再迁移
✅ 可以向上升级，也要能向下回滚  
✅ 测试环境先试验，生产环境再执行
❌ 绝不删除正在使用的字段
❌ 绝不在高峰期执行大型迁移
```

### 4.4 迁移回滚策略


```yaml
# 🔄 数据库回滚
rollback_database:
  stage: deploy
  image: migrate/migrate:latest
  script:
    - migrate -path ./migrations -database "mysql://user:pass@tcp(db:3306)/myapp" down 1
  environment:
    name: production
  when: manual
  only:
    - main
```

> 🚨 **警告**：数据库回滚是高风险操作，务必先在测试环境验证

---

## 5. 📦 静态资源部署策略


### 5.1 什么是静态资源


**🎨 静态资源就像装修材料**

- **图片文件**：`.jpg`, `.png`, `.svg` → 就像墙纸、装饰画
- **样式文件**：`.css` → 就像油漆、地板
- **字体文件**：`.woff`, `.ttf` → 就像特殊的装饰字体
- **JavaScript**：`.js` → 就像房子的智能控制系统

这些文件的特点是：**一旦生成就不会变化**，可以缓存很久。

### 5.2 CDN配置策略


**🌐 CDN部署配置**
```yaml
# 📡 部署到CDN
deploy_to_cdn:
  stage: deploy
  image: amazon/aws-cli:latest
  script:
    # 同步静态文件到AWS S3
    - aws s3 sync dist/static/ s3://my-app-static/ --delete
    # 设置缓存策略
    - aws s3 cp dist/static/ s3://my-app-static/ --recursive --cache-control "max-age=31536000"
    # 刷新CDN缓存
    - aws cloudfront create-invalidation --distribution-id E1234567890 --paths "/*"
  environment:
    name: cdn
```

**📊 缓存策略对比表**

| 文件类型 | 缓存时间 | 更新频率 | 策略说明 |
|---------|----------|----------|----------|
| 🖼️ **图片** | `1年` | 很少 | 文件名包含hash，变化时自动更新 |
| 🎨 **CSS** | `1年` | 经常 | 构建时生成新的hash文件名 |
| ⚡ **JS** | `1年` | 经常 | 同CSS，hash文件名策略 |
| 📄 **HTML** | `5分钟` | 经常 | 不缓存或短时间缓存 |

### 5.3 文件版本管理


```yaml
# 🏷️ 文件版本管理
version_assets:
  stage: build
  image: node:18-alpine
  script:
    # 生成版本化的文件名
    - npm run build        # 自动生成 app.abc123.js
    # 生成资源映射表
    - echo '{"app.js":"app.abc123.js","style.css":"style.def456.css"}' > dist/manifest.json
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
```

**🔄 版本更新流程图**
```
旧版本文件:               新版本文件:
app.abc123.js    →       app.def456.js
style.abc123.css →       style.def456.css
      ↓                        ↓
CDN仍保留旧文件         CDN添加新文件
   (用户缓存)           (新用户访问)
```

---

## 6. 🌍 域名切换与健康检查


### 6.1 蓝绿部署策略


**🎯 蓝绿部署就像开两家餐厅**

想象你经营一家餐厅，但担心新菜品有问题：
- **蓝色餐厅**：现在营业中，客人正在用餐
- **绿色餐厅**：准备新菜品，先不对外开放
- **切换过程**：新菜品准备好后，引导客人到绿色餐厅
- **保险措施**：如果新菜品有问题，立即引导客人回到蓝色餐厅

```
部署前状态:
用户 → 域名 → 蓝色环境 (当前版本)
              绿色环境 (空闲)

部署新版本:
用户 → 域名 → 蓝色环境 (当前版本)  
              绿色环境 (新版本) ← 部署这里

切换完成:
用户 → 域名 → 蓝色环境 (空闲)
              绿色环境 (新版本) ← 流量切换到这里
```

### 6.2 健康检查实现


```yaml
# 🏥 健康检查配置
health_check_app:
  stage: deploy
  image: curlimages/curl:latest
  script:
    # 检查基本连通性
    - curl -f http://green.example.com/health
    # 检查API功能
    - curl -f http://green.example.com/api/ping
    # 检查数据库连接
    - curl -f http://green.example.com/api/db-health
  retry: 3                  # 失败重试3次
  timeout: 2m              # 超时2分钟
```

**💡 健康检查的设计原则**
```
检查项目设计：
🟢 基础检查：服务是否启动
🟡 功能检查：核心API是否正常
🔴 依赖检查：数据库、Redis等是否连通
🟠 业务检查：关键业务流程是否正常
```

### 6.3 域名切换配置


```yaml
# 🔄 域名切换
switch_domain:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    # 更新负载均衡配置
    - |
      curl -X POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${RECORD_ID}" \
           -H "Authorization: Bearer ${CF_TOKEN}" \
           -H "Content-Type: application/json" \
           --data '{"content":"new-server-ip","name":"www.example.com","type":"A"}'
  environment:
    name: production
    url: https://www.example.com
  when: manual              # 必须手动确认
```

### 6.4 自动回滚机制


```yaml
# 🔙 自动回滚
auto_rollback:
  stage: deploy
  image: curlimages/curl:latest
  script:
    # 持续监控30分钟
    - |
      for i in {1..30}; do
        if ! curl -f https://www.example.com/health; then
          echo "Health check failed, triggering rollback"
          # 触发回滚Pipeline
          curl -X POST \
               -H "PRIVATE-TOKEN: ${CI_TOKEN}" \
               "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipeline" \
               -d "ref=rollback-branch"
          exit 1
        fi
        sleep 60  # 等待1分钟
      done
  needs:
    - switch_domain
```

---

## 7. 🔄 回滚机制实现


### 7.1 为什么需要回滚


**🚨 回滚就像紧急刹车**

想象你在开车：
- **正常情况**：按计划行驶（正常部署）
- **发现问题**：前方有障碍物（发现线上Bug）
- **紧急处理**：立即刹车或倒车（回滚到上一版本）
- **安全第一**：先避免事故，再分析原因

```
问题发现流程：
用户反馈Bug → 监控告警 → 确认影响范围 → 决定是否回滚
     ↓              ↓              ↓              ↓
   严重程度      自动检测        评估风险      快速恢复
```

### 7.2 回滚触发条件


**🎯 什么时候需要回滚？**

| 严重程度 | 问题类型 | 回滚决策 | 处理时间 |
|---------|----------|----------|----------|
| 🔴 **严重** | 系统崩溃、数据丢失 | 立即回滚 | < 5分钟 |
| 🟠 **重要** | 核心功能异常 | 评估后回滚 | < 30分钟 |
| 🟡 **一般** | 次要功能问题 | 修复后发布 | < 2小时 |
| 🟢 **轻微** | 界面小问题 | 下次版本修复 | 计划内 |

### 7.3 快速回滚实现


```yaml
# ⚡ 快速回滚Pipeline
quick_rollback:
  stage: rollback
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh rsync
  script:
    # 获取上一个稳定版本
    - LAST_STABLE=$(git describe --tags --abbrev=0 HEAD~1)
    - echo "Rolling back to version: $LAST_STABLE"
    
    # 回滚前端
    - git checkout $LAST_STABLE
    - rsync -avz dist/ user@server:/var/www/backup/
    - ssh user@server "cp -r /var/www/backup/* /var/www/html/"
    
    # 回滚后端  
    - ssh user@server "pm2 stop api-server"
    - ssh user@server "git checkout $LAST_STABLE && npm install"
    - ssh user@server "pm2 start api-server"
    
    # 验证回滚结果
    - sleep 30
    - curl -f https://www.example.com/health
  when: manual
  allow_failure: false
```

### 7.4 数据库回滚策略


> ⚠️ **重要提醒**：数据库回滚是最危险的操作，需要格外小心

```yaml
# 🗄️ 数据库回滚
rollback_database:
  stage: rollback
  image: mysql:8.0
  before_script:
    # 创建回滚前备份
    - mysqldump -h $DB_HOST -u $DB_USER -p$DB_PASS $DB_NAME > pre_rollback_backup.sql
  script:
    # 执行回滚脚本
    - mysql -h $DB_HOST -u $DB_USER -p$DB_PASS $DB_NAME < rollback_scripts/rollback_to_v2.sql
    # 验证数据完整性
    - mysql -h $DB_HOST -u $DB_USER -p$DB_PASS $DB_NAME < verify_data_integrity.sql
  artifacts:
    paths:
      - pre_rollback_backup.sql
    expire_in: 7 days
  when: manual
  only:
    - main
```

**🔒 数据库回滚安全检查清单**
- [ ] 📋 已创建当前状态的完整备份
- [ ] 🧪 回滚脚本已在测试环境验证
- [ ] 👥 相关人员已确认回滚计划
- [ ] ⏰ 选择在业务低峰期执行
- [ ] 📞 技术支持团队待命

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Web应用CI/CD：前端+后端+数据库的协调部署
🔸 前端特点：静态文件，需要构建编译，CDN分发
🔸 后端特点：服务进程，需要重启更新，健康检查
🔸 数据库迁移：结构变更，需要版本管理，支持回滚
🔸 部署策略：蓝绿部署，灰度发布，快速回滚
```

### 8.2 关键理解要点


**🔹 为什么Web应用CI/CD比较复杂？**
```
复杂性来源：
- 多个组件需要协调（前端、后端、数据库）
- 用户体验要求高（不能长时间停服）
- 数据安全要求严格（不能丢失数据）
- 版本管理复杂（静态资源版本控制）
```

**🔹 部署顺序为什么重要？**
```
正确顺序：
数据库迁移 → 后端部署 → 前端部署 → 健康检查 → 域名切换

错误后果：
- 数据库迁移失败 → 整个部署失败
- 前端先部署 → API不匹配导致错误
- 跳过健康检查 → 有问题的版本直接上线
```

### 8.3 最佳实践总结


**💪 部署策略选择**

| 项目规模 | 推荐策略 | 优点 | 缺点 |
|---------|----------|------|------|
| 🏠 **小型项目** | 直接替换 | 简单快速 | 有短暂停服 |
| 🏢 **中型项目** | 蓝绿部署 | 零停机时间 | 需要双倍资源 |
| 🏭 **大型项目** | 灰度发布 | 风险可控 | 配置复杂 |

**🎯 监控指标重点**
```
必须监控的指标：
🟢 应用响应时间 < 200ms
🟢 错误率 < 0.1%  
🟢 CPU使用率 < 70%
🟢 内存使用率 < 80%
🟢 数据库连接数 < 80%
```

**📚 学习路径建议**
```
📖 前置知识：Git基础、Linux基础、Docker容器
📝 当前主题：GitLab CI/CD、自动化部署
🚀 后续扩展：Kubernetes、微服务部署、监控告警
```

### 8.4 常见误区避免


**❗ 误区1：过度依赖自动化**
```
错误想法：设置好CI/CD就万事大吉
正确理解：自动化是工具，人的判断和监控更重要
实践建议：保留关键节点的人工确认
```

**❗ 误区2：忽视回滚机制**  
```
错误想法：部署成功就不会有问题
正确理解：线上环境复杂，问题难以完全预测
实践建议：每次部署都要准备回滚方案
```

**❗ 误区3：数据库操作不谨慎**
```
错误想法：数据库迁移和代码部署一样简单
正确理解：数据库操作影响持久化数据，错误难以恢复
实践建议：数据库操作必须手动确认，充分测试
```

**核心记忆口诀**：
- Web应用三件套，前后数据库都要好
- 部署顺序有讲究，先后端来后前端  
- 健康检查不能少，出错回滚要趁早
- 自动化虽然好，人工监控更重要