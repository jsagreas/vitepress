---
title: 6、Job作业详细配置
---
## 📚 目录

1. [Job作业基础概念](#1-Job作业基础概念)
2. [Job命名规范与要求](#2-Job命名规范与要求)
3. [script脚本命令编写](#3-script脚本命令编写)
4. [stage阶段分配管理](#4-stage阶段分配管理)
5. [tags Runner标签指定](#5-tags-Runner标签指定)
6. [触发条件控制](#6-触发条件控制)
7. [when执行时机控制](#7-when执行时机控制)
8. [allow_failure失败处理](#8-allow_failure失败处理)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 Job作业基础概念


### 1.1 什么是Job作业


**简单理解**：Job就像是一张"工作任务单"，上面写着要做什么事情、什么时候做、在哪里做。

想象一下你在餐厅点餐：
- **菜单项** = Job名称（比如"宫保鸡丁"）
- **制作步骤** = script脚本（先炒鸡丁，再加花生米...）
- **制作阶段** = stage（备菜→炒制→装盘）
- **厨师选择** = tags（川菜师傅才能做这道菜）

```
Job在CI/CD中的作用：
📋 定义具体任务：构建代码、运行测试、部署应用
⏰ 控制执行时机：什么时候执行这个任务
🏠 指定运行环境：在哪个Runner上执行
🔄 处理执行结果：成功了怎么办，失败了怎么办
```

### 1.2 Job的生命周期


**Job从创建到完成的整个过程**：

```
Job生命周期流程：
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   创建Job    │ → │  等待Runner  │ → │   开始执行   │
│   (Pending)  │    │  (Pending)   │    │  (Running)   │
└──────────────┘    └──────────────┘    └──────────────┘
                                               │
        ┌──────────────┐    ┌──────────────┐   │
        │   执行成功   │ ← │   执行完成   │ ←─┘
        │  (Success)   │    │              │
        └──────────────┘    └──────────────┘
                                   │
                            ┌──────────────┐
                            │   执行失败   │
                            │   (Failed)   │
                            └──────────────┘
```

**状态说明**：
- **Pending（等待中）**：Job已创建，等待符合条件的Runner
- **Running（运行中）**：Runner开始执行Job中的脚本
- **Success（成功）**：所有脚本都执行成功，返回码为0
- **Failed（失败）**：某个脚本执行失败，返回码非0

### 1.3 Job配置的基本结构


每个Job都有一个基本的配置模板：

```yaml
job_name:                    # Job的名称
  stage: build              # 属于哪个阶段
  script:                   # 要执行的命令
    - echo "Hello World"
  tags:                     # Runner标签
    - docker
  only:                     # 触发条件
    - master
```

这就像填写一张表格，每个字段都有特定的含义和作用。

---

## 2. 📝 Job命名规范与要求


### 2.1 命名规范基础


**Job名称就像给孩子起名字**，要清楚明白，一看就知道这个Job是做什么的。

**✅ 好的命名示例**：
```yaml
# 清晰表达Job的作用
build_frontend:             # 构建前端代码
test_unit:                  # 运行单元测试  
deploy_production:          # 部署到生产环境
lint_code_style:           # 检查代码规范
build_docker_image:        # 构建Docker镜像
```

**❌ 不好的命名示例**：
```yaml
# 含义不清楚的命名
job1:                      # 完全不知道做什么
build:                     # 构建什么？
test:                      # 测试什么？
deploy:                    # 部署到哪里？
my_job:                    # 你的工作？什么工作？
```

### 2.2 命名约定和技巧


**📋 推荐的命名模式**：

| 命名模式 | **示例** | **说明** |
|---------|----------|---------|
| **动作_对象** | `build_frontend` | 动词+名词，清晰表达操作 |
| **阶段_类型** | `test_integration` | 阶段+测试类型 |
| **环境_操作** | `production_deploy` | 环境+操作 |
| **工具_任务** | `docker_build` | 工具+任务 |

**🔤 命名技术要求**：
```
允许的字符：
✅ 字母：a-z, A-Z
✅ 数字：0-9  
✅ 下划线：_
✅ 连字符：-
✅ 冒号：:（用于分组）
✅ 空格：Job Name（会自动处理）

命名限制：
⚠️ 不能以点(.)开头
⚠️ 不能包含特殊字符：@ # $ % 等
⚠️ 长度建议控制在50个字符以内
```

### 2.3 Job分组命名


当项目比较大时，可以用**冒号(:)**对Job进行分组：

```yaml
# 前端相关Job
frontend:build:
  script:
    - npm run build

frontend:test:
  script:
    - npm run test

frontend:lint:
  script:
    - npm run lint

# 后端相关Job  
backend:build:
  script:
    - mvn compile

backend:test:
  script:
    - mvn test

# 在GitLab界面中会按组显示，更清晰
```

---

## 3. 📜 script脚本命令编写


### 3.1 script基础语法


**script就像写菜谱**，一步一步告诉计算机要做什么。

**基本格式**：
```yaml
job_name:
  script:
    - echo "第一步：准备工作"
    - ls -la                    # 查看文件列表
    - echo "第二步：开始构建"
    - npm install              # 安装依赖
    - npm run build           # 执行构建
    - echo "第三步：构建完成"
```

**⚡ 重要特点**：
- 每行都是一个独立的命令
- 命令按顺序执行，前一个成功才执行下一个
- 任何一个命令失败（返回码非0），整个Job就失败
- 就像多米诺骨牌，一个倒下，后面都停止

### 3.2 多行脚本编写


**方式一：列表格式（推荐）**
```yaml
build_app:
  script:
    - echo "开始安装依赖"
    - npm install
    - echo "开始构建应用"  
    - npm run build
    - echo "构建完成，检查结果"
    - ls -la dist/
```

**方式二：多行字符串格式**
```yaml
build_app:
  script: |
    echo "开始构建过程"
    npm install
    npm run build
    echo "构建完成"
```

**🎯 选择建议**：
- **简单命令**：用列表格式，清晰易读
- **复杂脚本**：用多行字符串，便于编写

### 3.3 脚本执行环境


**🐧 默认执行环境**：
```
运行用户：通常是gitlab-runner或root
工作目录：项目代码的根目录
Shell环境：/bin/bash（Linux）或cmd（Windows）
环境变量：GitLab预定义 + 用户自定义
```

**📁 文件和目录操作**：
```yaml
file_operations:
  script:
    - pwd                      # 显示当前目录
    - ls -la                   # 列出所有文件
    - mkdir -p build/output    # 创建目录
    - cp src/* build/          # 复制文件
    - chmod +x scripts/deploy.sh  # 修改权限
    - ./scripts/deploy.sh      # 执行脚本
```

### 3.4 错误处理和调试


**🔍 调试技巧**：
```yaml
debug_job:
  script:
    - echo "=== 环境信息 ==="
    - whoami                   # 当前用户
    - pwd                      # 当前目录
    - env | grep CI_           # GitLab环境变量
    - echo "=== 系统信息 ==="
    - uname -a                 # 系统信息
    - df -h                    # 磁盘空间
    - free -h                  # 内存信息
    - echo "=== 开始主要任务 ==="
    - npm install
```

**⚠️ 错误处理**：
```yaml
error_handling:
  script:
    - echo "执行可能失败的命令"
    - command_might_fail || echo "命令失败了，但继续执行"
    - echo "检查文件是否存在"
    - test -f package.json && echo "文件存在" || echo "文件不存在"
    - echo "设置退出时忽略错误"
    - set +e                   # 忽略后续命令的错误
    - risky_command
    - set -e                   # 重新启用错误检查
```

---

## 4. 🏗️ stage阶段分配管理


### 4.1 stage阶段概念


**stage就像工厂的生产线**，有不同的工作站，每个工作站负责不同的任务。

```
典型的CI/CD生产线：
┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐
│    构建    │→│    测试    │→│    打包    │→│    部署    │
│   build    │  │    test    │  │  package   │  │   deploy   │
└────────────┘  └────────────┘  └────────────┘  └────────────┘

同一阶段的Job可以并行运行
不同阶段的Job按顺序执行
```

### 4.2 预定义阶段


GitLab有默认的阶段顺序，即使你不定义也会使用：

```yaml
# GitLab默认阶段（按顺序执行）
stages:
  - build      # 构建阶段
  - test       # 测试阶段  
  - deploy     # 部署阶段
```

**🔄 阶段执行规则**：
- 同一阶段内的所有Job **并行执行**
- 只有当前阶段所有Job都成功，才进入下一阶段
- 任何一个Job失败，整个流水线就停止

### 4.3 自定义阶段


你可以根据项目需要定义自己的阶段：

```yaml
# 自定义更详细的阶段
stages:
  - prepare     # 准备阶段：安装依赖
  - build       # 构建阶段：编译代码
  - test        # 测试阶段：运行测试
  - security    # 安全扫描：漏洞检查
  - package     # 打包阶段：创建镜像
  - deploy      # 部署阶段：发布应用

# Job指定阶段
install_deps:
  stage: prepare
  script:
    - npm install

compile_code:
  stage: build  
  script:
    - npm run build

run_tests:
  stage: test
  script:
    - npm run test

security_scan:
  stage: security
  script:
    - npm audit

build_docker:
  stage: package
  script:
    - docker build -t myapp .

deploy_prod:
  stage: deploy
  script:
    - kubectl apply -f deployment.yaml
```

### 4.4 阶段管理最佳实践


**📊 常见阶段设计模式**：

| 阶段类型 | **用途** | **典型Job** |
|---------|----------|-------------|
| **prepare** | 环境准备 | `install_deps`, `setup_env` |
| **validate** | 代码检查 | `lint_code`, `format_check` |
| **build** | 代码构建 | `compile_frontend`, `build_backend` |
| **test** | 质量检测 | `unit_test`, `integration_test` |
| **security** | 安全扫描 | `vulnerability_scan`, `license_check` |
| **package** | 制品打包 | `build_docker`, `create_rpm` |
| **deploy** | 应用部署 | `deploy_staging`, `deploy_prod` |

**⚡ 性能优化建议**：
```
并行化原则：
✅ 把独立的任务放在同一阶段
✅ 避免不必要的阶段依赖
✅ 合理拆分长时间运行的Job

阶段设计：
• 快速失败：把容易失败的检查放前面
• 逻辑清晰：阶段名称要体现业务流程
• 适度拆分：不要过度细分阶段
```

---

## 5. 🏷️ tags Runner标签指定


### 5.1 tags标签系统概念


**tags就像餐厅的"专业厨师标签"**，不同的厨师有不同的技能标签，比如"川菜师傅"、"烘焙师"、"西餐厨师"。

```
Runner标签系统：
┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐
│   Runner-1      │   │   Runner-2      │   │   Runner-3      │
│ tags: [docker]  │   │ tags: [linux]   │   │ tags: [windows] │
│ tags: [build]   │   │ tags: [test]    │   │ tags: [deploy]  │
└─────────────────┘   └─────────────────┘   └─────────────────┘
         ↑                       ↑                       ↑
         │                       │                       │
    Docker构建任务          Linux测试任务           Windows部署任务
```

**🎯 标签的作用**：
- **任务分配**：确保Job在合适的Runner上执行
- **资源隔离**：不同类型的任务使用不同的资源
- **环境匹配**：需要特定环境的Job找到对应Runner
- **负载均衡**：合理分配工作负载

### 5.2 标签的基本使用


**单个标签指定**：
```yaml
build_app:
  stage: build
  tags:
    - docker        # 必须在有docker标签的Runner上执行
  script:
    - docker build -t myapp .
```

**多个标签指定**：
```yaml
deploy_production:
  stage: deploy  
  tags:
    - production   # 必须有production标签
    - ssh-access   # 必须有ssh-access标签
  script:
    - ssh server "systemctl restart myapp"
```

**❗ 重要理解**：
- Runner必须拥有Job要求的**所有标签**才能执行
- 如果没有匹配的Runner，Job会一直等待
- 标签区分大小写：`Docker` 和 `docker` 是不同的标签

### 5.3 常见标签分类


**🖥️ 环境类型标签**：
```yaml
# 操作系统标签
linux_job:
  tags: [linux]
  
windows_job:
  tags: [windows]
  
macos_job:
  tags: [macos]
```

**🛠️ 工具能力标签**：
```yaml
# 容器相关
docker_build:
  tags: [docker]
  script:
    - docker build .

# 编程语言环境
java_job:
  tags: [java, maven]
  script:
    - mvn compile

nodejs_job:
  tags: [nodejs, npm]
  script:
    - npm install
```

**🏢 环境级别标签**：
```yaml
# 开发环境
dev_deploy:
  tags: [development]
  
# 测试环境  
test_deploy:
  tags: [staging]
  
# 生产环境
prod_deploy:
  tags: [production, secure]
```

### 5.4 标签管理策略


**📋 标签命名规范**：
```
推荐命名模式：
• 环境类型：linux, windows, macos
• 工具软件：docker, kubectl, nodejs
• 硬件特性：gpu, ssd, high-memory
• 安全级别：secure, trusted, public
• 业务环境：dev, staging, prod
```

**⚖️ 标签使用建议**：
```
合理使用：
✅ 根据Job的实际需求选择标签
✅ 标签数量适中，不要过度细分
✅ 保持标签命名的一致性
✅ 定期清理无用的标签

避免问题：
❌ 不要使用过于具体的标签
❌ 避免标签依赖过于复杂
❌ 不要创建冗余的标签
❌ 避免标签名称含义不清
```

---

## 6. 🎯 触发条件控制


### 6.1 only/except基础概念


**only和except就像门卫**，决定什么情况下Job可以执行，什么情况下不能执行。

```
触发控制逻辑：
代码推送事件 → 检查only条件 → 检查except条件 → 决定是否执行Job

only：白名单模式（只有满足条件才执行）
except：黑名单模式（满足条件就不执行）
```

### 6.2 分支条件控制


**按分支名称控制**：
```yaml
# 只在master分支执行
deploy_production:
  script:
    - echo "部署到生产环境"
  only:
    - master

# 只在开发分支执行
deploy_staging:
  script:
    - echo "部署到测试环境"  
  only:
    - develop
    - /^feature\/.*$/    # 以feature/开头的分支

# 除了master分支都执行
run_tests:
  script:
    - npm test
  except:
    - master
```

**🌿 分支匹配规则**：
```
精确匹配：
only: [master]              # 只匹配master分支

正则表达式：
only: [/^release\/.*$/]     # 匹配release/开头的分支
only: [/^hotfix\/.*/]       # 匹配hotfix/开头的分支

多个条件：
only: [master, develop]     # master或develop分支
```

### 6.3 标签和事件控制


**按Git标签控制**：
```yaml
# 只在发布标签时执行
release_job:
  script:
    - echo "创建发布包"
  only:
    - tags                  # 任何标签
    
version_job:  
  script:
    - echo "版本发布"
  only:
    - /^v\d+\.\d+\.\d+$/   # 匹配v1.0.0格式的标签
```

**按触发事件控制**：
```yaml
# 不同触发方式的Job
push_job:
  script:
    - echo "代码推送触发"
  only:
    - pushes              # 代码推送时执行

manual_job:
  script:
    - echo "手动触发"
  only:
    - web                 # 网页手动触发

schedule_job:
  script:
    - echo "定时任务"
  only:
    - schedules           # 定时任务触发
```

### 6.4 rules现代语法


**rules是only/except的升级版**，功能更强大，语法更灵活：

```yaml
# 复杂条件判断
deploy_job:
  script:
    - echo "智能部署"
  rules:
    # 条件1：master分支且有变更
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - src/**/*
      when: always
      
    # 条件2：标签发布
    - if: '$CI_COMMIT_TAG'
      when: always
      
    # 条件3：其他情况手动执行
    - when: manual
      allow_failure: true
```

**🔧 rules语法要素**：
```
if：条件判断（使用环境变量）
changes：文件变更检测
exists：文件存在检测
when：执行时机（always/on_success/manual等）
allow_failure：是否允许失败
```

**📋 实用rules示例**：
```yaml
# 只有前端代码变更时才构建前端
build_frontend:
  script:
    - npm run build
  rules:
    - changes:
        - frontend/**/*
        - package.json
      when: always
    - when: never         # 其他情况不执行

# 生产部署需要手动确认
deploy_production:
  script:
    - kubectl apply -f production.yaml
  rules:
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
    - when: never
```

---

## 7. ⏰ when执行时机控制


### 7.1 when基础概念


**when就像智能开关**，根据不同情况决定Job什么时候执行。

```
when的执行逻辑：
前面的Job执行完成 → 检查执行结果 → 根据when条件决定是否执行当前Job

就像多米诺骨牌的智能版本：
• 有些骨牌必须等前面成功才倒下
• 有些骨牌即使前面失败也要倒下  
• 有些骨牌需要人为推动
```

### 7.2 when取值说明


**📋 所有when选项**：

| when值 | **执行时机** | **使用场景** |
|--------|-------------|--------------|
| **on_success** | 前面Job成功时执行（默认） | 正常的构建流程 |
| **on_failure** | 前面Job失败时执行 | 失败通知、清理工作 |
| **always** | 无论成功失败都执行 | 日志收集、资源清理 |
| **manual** | 手动触发执行 | 生产部署、危险操作 |
| **delayed** | 延迟一段时间后执行 | 等待服务启动 |
| **never** | 永不执行 | 临时禁用Job |

### 7.3 实际应用示例


**正常流程控制**：
```yaml
# 默认行为：前面成功才执行
deploy_app:
  stage: deploy
  script:
    - kubectl apply -f deployment.yaml
  when: on_success    # 可以省略，这是默认值
```

**失败处理机制**：
```yaml
# 构建失败时发送通知
notify_failure:
  stage: deploy
  script:
    - echo "构建失败，发送邮件通知"
    - curl -X POST "webhook-url" -d "Build failed"
  when: on_failure
```

**无条件执行**：
```yaml
# 收集日志和清理资源
cleanup_job:
  stage: deploy
  script:
    - echo "收集构建日志"
    - cp /var/log/build.log artifacts/
    - echo "清理临时文件" 
    - rm -rf temp/
  when: always
```

### 7.4 手动触发控制


**手动执行按钮**：
```yaml
# 生产环境部署需要人工确认
deploy_production:
  stage: deploy
  script:
    - echo "部署到生产环境"
    - kubectl apply -f production.yaml
  when: manual
  only:
    - master
```

**延迟执行**：
```yaml
# 等待服务启动后再执行测试
integration_test:
  stage: test
  script:
    - echo "等待服务完全启动"
    - curl http://localhost:8080/health
  when: delayed
  start_in: 5 minutes    # 延迟5分钟执行
```

### 7.5 when与rules结合


在rules中使用when可以实现更复杂的控制逻辑：

```yaml
complex_deploy:
  stage: deploy
  script:
    - echo "复杂部署逻辑"
  rules:
    # 生产分支手动部署
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
      
    # 测试分支自动部署
    - if: '$CI_COMMIT_BRANCH == "develop"'  
      when: always
      
    # 其他分支不部署
    - when: never
```

---

## 8. 🛡️ allow_failure失败处理


### 8.1 allow_failure基本概念


**allow_failure就像保险丝**，某些Job失败了不会影响整个流水线。

```
正常情况（allow_failure: false）：
Job A成功 → Job B失败 → 整个流水线失败 ❌

允许失败（allow_failure: true）：
Job A成功 → Job B失败 → 流水线继续 → Job C执行 ✅
```

**🎯 使用场景**：
- **实验性功能**：新增的测试，失败不应该阻止发布
- **可选检查**：代码质量检查，建议性质的
- **非关键任务**：通知发送，失败了也无所谓
- **手动任务**：人工确认的任务，不执行也可以

### 8.2 基本用法示例


**允许失败的测试**：
```yaml
# 主要的单元测试，失败必须停止
unit_tests:
  stage: test
  script:
    - npm run test:unit
  # allow_failure默认为false

# 实验性的性能测试，失败不阻止部署
performance_tests:
  stage: test
  script:
    - npm run test:performance
  allow_failure: true    # 失败了流水线继续
```

**可选的代码质量检查**：
```yaml
# 代码规范检查，建议性质
code_quality:
  stage: test
  script:
    - npm run lint
    - npm run style-check
  allow_failure: true
  
# 安全漏洞扫描，发现问题不一定立即阻止
security_scan:
  stage: test
  script:
    - npm audit
    - snyk test
  allow_failure: true
```

### 8.3 手动任务的失败处理


对于手动触发的任务，allow_failure特别有用：

```yaml
# 生产部署确认，可以选择不执行
manual_approval:
  stage: deploy
  script:
    - echo "生产环境部署已确认"
  when: manual
  allow_failure: true    # 不点击也不会阻止流水线

# 可选的数据库迁移
database_migration:
  stage: deploy
  script:
    - python manage.py migrate
  when: manual
  allow_failure: true
  only:
    - master
```

### 8.4 rules中的failure控制


在rules中也可以控制失败行为：

```yaml
flexible_job:
  stage: test
  script:
    - run_tests.sh
  rules:
    # 在主分支上失败必须处理
    - if: '$CI_COMMIT_BRANCH == "master"'
      allow_failure: false
      
    # 在特性分支上允许失败
    - if: '$CI_COMMIT_BRANCH =~ /^feature\/.*/'
      allow_failure: true
      
    # 其他情况不执行
    - when: never
```

### 8.5 失败处理最佳实践


**⚖️ 什么时候允许失败**：
```
✅ 适合allow_failure: true的场景：
• 代码质量检查（lint、格式化）
• 性能测试和压力测试
• 安全扫描（非阻塞性）
• 实验性功能测试
• 可选的通知任务
• 手动确认步骤

❌ 不适合allow_failure: true的场景：
• 单元测试和集成测试
• 编译和构建任务
• 关键的部署步骤
• 数据备份任务
• 安全性验证
```

**🔍 监控和处理策略**：
```yaml
# 失败时发送通知但不阻止流程
optional_check:
  stage: test
  script:
    - run_optional_check.sh
  allow_failure: true
  after_script:
    - |
      if [ $CI_JOB_STATUS == "failed" ]; then
        echo "可选检查失败，但不影响部署"
        # 可以发送警告通知
      fi
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 Job作业本质：CI/CD中的基本执行单元，定义具体任务
🔸 命名规范：清晰表达Job用途，使用合理的命名模式
🔸 script脚本：Job的核心，定义要执行的具体命令
🔸 stage阶段：组织Job执行顺序，同阶段并行，跨阶段串行
🔸 tags标签：指定Job运行的Runner，实现任务分配
🔸 触发条件：控制Job在什么情况下执行
🔸 执行时机：when决定Job相对于前面Job的执行时机
🔸 失败处理：allow_failure控制Job失败对流水线的影响
```

### 9.2 关键理解要点


**🔹 Job配置的核心逻辑**：
```
Job配置就像填写工作委托书：
• 任务名称：Job name（做什么）
• 执行内容：script（怎么做）
• 执行时机：stage + when（什么时候做）
• 执行环境：tags（在哪里做）
• 执行条件：only/except/rules（什么情况下做）
• 失败处理：allow_failure（做错了怎么办）
```

**🔹 stage阶段的设计思维**：
```
把CI/CD想象成工厂生产线：
• 每个阶段是一个工作站
• 同工作站的工人并行工作（同stage的Job并行）
• 工作站之间有先后顺序（stage之间串行）
• 某个工作站出问题，整条生产线停止
```

**🔹 触发条件的控制策略**：
```
现代推荐：优先使用rules替代only/except
rules优势：
• 语法更灵活，支持复杂条件
• 可以结合环境变量和文件变更
• 逻辑更清晰，维护更容易
```

### 9.3 实际应用指导


**💼 Job配置模板**：
```yaml
# 通用Job配置模板
job_template:
  stage: stage_name              # 指定阶段
  image: ubuntu:20.04            # 指定镜像（如果用Docker）
  tags:                          # 指定Runner标签
    - docker
    - linux
  variables:                     # 定义变量
    ENV: production
  before_script:                 # 预处理脚本
    - apt-get update
  script:                        # 主要脚本
    - echo "执行主要任务"
  after_script:                  # 后处理脚本
    - echo "清理工作"
  rules:                         # 触发条件
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: always
  allow_failure: false           # 失败处理
```

**🎯 配置最佳实践**：
```
Job设计原则：
1. 单一职责：每个Job只做一件事
2. 快速失败：容易失败的检查放前面
3. 并行优化：独立任务放同一stage
4. 资源匹配：根据需求选择合适的Runner
5. 错误处理：合理使用allow_failure

维护建议：
• 定期检查和优化Job配置
• 监控Job执行时间和成功率
• 及时清理无用的Job和stage
• 保持配置文档的更新
```

### 9.4 常见问题解答


**❓ Job一直pending怎么办？**
```
常见原因：
1. 没有匹配tags的Runner在线
2. Runner资源不足或繁忙
3. tags拼写错误或大小写不匹配

解决方法：
• 检查Runner状态和标签配置
• 简化或修正tags要求
• 联系管理员检查Runner
```

**❓ 为什么Job执行顺序不对？**
```
原因分析：
• 同一stage内的Job是并行的，没有固定顺序
• 不同stage之间按定义顺序执行
• dependencies可以改变依赖关系

解决方案：
• 需要顺序的Job放在不同stage
• 使用needs关键字定义精确依赖
• 检查stages定义顺序
```

**❓ 什么时候用allow_failure？**
```
使用原则：
✅ 非关键路径的检查（代码质量、性能测试）
✅ 实验性功能的测试
✅ 可选的手动确认步骤
✅ 不影响主流程的辅助任务

❌ 避免在关键任务上使用（构建、核心测试、关键部署）
```

**🧠 记忆要点**：
- Job是CI/CD的基本单元，像工作任务单
- script定义做什么，stage定义什么时候做
- tags选择在哪做，rules控制什么条件下做
- when控制相对时机，allow_failure控制失败影响
- 配置要清晰明确，便于维护和调试

**核心理念**：Job配置就是在回答"谁在什么时候什么地方做什么事"的问题。配置清晰，执行就顺畅！