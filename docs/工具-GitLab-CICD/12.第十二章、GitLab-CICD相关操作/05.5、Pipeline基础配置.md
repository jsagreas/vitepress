---
title: 5、Pipeline基础配置
---
## 📚 目录

1. [Pipeline基础概念](#1-Pipeline基础概念)
2. [触发条件设置](#2-触发条件设置)
3. [stages阶段定义](#3-stages阶段定义)
4. [全局脚本配置](#4-全局脚本配置)
5. [镜像与环境配置](#5-镜像与环境配置)
6. [Pipeline变量管理](#6-Pipeline变量管理)
7. [超时与性能设置](#7-超时与性能设置)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🚀 Pipeline基础概念


### 1.1 什么是Pipeline？


**简单理解**：Pipeline就像工厂的流水线，代码从提交到部署要经过多个工序

```
代码提交 → 构建 → 测试 → 部署
   ↓        ↓      ↓      ↓
  触发    编译    检查   上线
```

**核心作用**：
- **自动化流程**：不用手动执行重复操作
- **质量保证**：每次变更都经过标准检查
- **快速反馈**：问题能立即发现
- **团队协作**：统一的工作流程

### 1.2 .gitlab-ci.yml文件的作用


这个文件就是Pipeline的"剧本"，告诉GitLab要做什么、怎么做、什么时候做。

**文件位置**：必须放在项目根目录
**文件格式**：YAML格式（注意缩进）
**执行时机**：每次代码推送时自动读取

---

## 2. ⚡ 触发条件设置


### 2.1 基本触发规则


**默认触发**：任何分支的push操作都会触发Pipeline

**常用触发条件**：

| 触发方式 | 说明 | 使用场景 |
|---------|------|----------|
| `push` | 代码推送时触发 | 最常用，适合日常开发 |
| `merge_requests` | 创建MR时触发 | 代码审查前的检查 |
| `schedules` | 定时触发 | 夜间构建、定期检查 |
| `manual` | 手动触发 | 生产环境部署 |

### 2.2 分支过滤配置


**只在特定分支运行**：
```yaml
# 只在main分支运行
deploy_job:
  script:
    - echo "部署到生产环境"
  only:
    - main

# 排除某些分支
test_job:
  script:
    - echo "运行测试"
  except:
    - develop
```

**现代写法（推荐）**：
```yaml
# 使用rules（更灵活）
deploy_job:
  script:
    - echo "部署应用"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```

### 2.3 文件变更触发


只有特定文件变更才运行：
```yaml
# 只有前端文件变更时才构建前端
frontend_build:
  script:
    - npm run build
  only:
    changes:
      - "frontend/**/*"
      - "package.json"
```

---

## 3. 📋 stages阶段定义


### 3.1 stages的作用


**阶段概念**：将Pipeline分成多个步骤，按顺序执行

```
典型的Web项目阶段：
┌─────────┐   ┌─────────┐   ┌─────────┐   ┌─────────┐
│  build  │──▶│  test   │──▶│ deploy  │──▶│ cleanup │
│ (构建)  │   │ (测试)  │   │ (部署)  │   │ (清理)  │
└─────────┘   └─────────┘   └─────────┘   └─────────┘
```

### 3.2 定义执行顺序


**基础配置**：
```yaml
# 定义阶段顺序（全局配置）
stages:
  - prepare    # 准备阶段
  - build      # 构建阶段  
  - test       # 测试阶段
  - deploy     # 部署阶段

# 具体job指定所属阶段
prepare_env:
  stage: prepare
  script:
    - echo "准备环境"

build_app:
  stage: build
  script:
    - echo "构建应用"
```

### 3.3 默认stage概念


**不指定stage时的默认行为**：
- 自动归属到`test`阶段
- 如果没有定义stages，会使用默认的：`build` → `test` → `deploy`

```yaml
# 这个job会在test阶段运行
my_job:
  script:
    - echo "我在test阶段运行"
  # 没有指定stage，默认是test
```

### 3.4 阶段内并行执行


**同一阶段内的多个job会并行运行**：
```yaml
stages:
  - test

# 这两个job会同时运行
unit_test:
  stage: test
  script:
    - echo "单元测试"

lint_check:
  stage: test  
  script:
    - echo "代码检查"
```

---

## 4. 🔧 全局脚本配置


### 4.1 before_script全局脚本


**作用**：在每个job执行前都会运行的脚本

**典型用途**：
- 安装依赖包
- 设置环境变量
- 登录认证

```yaml
# 全局before_script
before_script:
  - apt-get update -qq
  - apt-get install -y git

# 具体job
build_job:
  script:
    - echo "构建开始"
    # before_script会自动在这之前执行
```

**job级别覆盖**：
```yaml
# 全局设置
before_script:
  - echo "全局准备"

my_job:
  # 这个job使用自己的before_script，会覆盖全局的
  before_script:
    - echo "特殊准备"
  script:
    - echo "执行任务"
```

### 4.2 after_script清理脚本


**作用**：job执行后的清理工作

**典型用途**：
- 清理临时文件
- 发送通知
- 收集日志

```yaml
# 全局清理
after_script:
  - rm -rf temp/
  - echo "清理完成"

deploy_job:
  script:
    - echo "部署应用"
  # 无论成功失败都会执行after_script
```

> 💡 **重要提示**：after_script即使job失败也会执行，适合做清理工作

---

## 5. 🐳 镜像与环境配置


### 5.1 image镜像指定


**镜像的作用**：为job提供运行环境，就像给程序准备一个"虚拟机"

**全局镜像设置**：
```yaml
# 所有job默认使用这个镜像
image: node:16

build_job:
  script:
    - npm install
    - npm run build
```

**job级别镜像**：
```yaml
# 全局默认镜像
image: node:16

# Python任务使用Python镜像
python_test:
  image: python:3.9
  script:
    - pip install -r requirements.txt
    - python test.py

# Node任务使用默认的node镜像
node_build:
  script:
    - npm run build
```

### 5.2 常用镜像选择


| 项目类型 | 推荐镜像 | 说明 |
|---------|----------|------|
| **Node.js** | `node:16-alpine` | 轻量级，构建快 |
| **Python** | `python:3.9-slim` | 包含基础Python环境 |
| **Java** | `openjdk:11-jdk` | Java开发环境 |
| **通用** | `ubuntu:20.04` | 灵活性最高 |

### 5.3 服务依赖配置


当job需要数据库等服务时：
```yaml
# 需要数据库的测试
test_with_db:
  image: node:16
  services:
    - postgres:13
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_pass
  script:
    - npm test
```

---

## 6. 📊 Pipeline变量管理


### 6.1 变量的作用


**变量用途**：
- 存储配置信息（如API地址）
- 管理敏感数据（如密码）
- 控制job行为（如环境标识）

### 6.2 变量定义层级


```
优先级从高到低：
┌─────────────────┐
│   Job级变量     │ ← 最高优先级
├─────────────────┤
│ Pipeline级变量  │
├─────────────────┤  
│  全局variables  │
├─────────────────┤
│  GitLab设置变量 │ ← 最低优先级
└─────────────────┘
```

### 6.3 全局变量定义


```yaml
# 全局变量（所有job都能使用）
variables:
  APP_NAME: "my-application"
  BUILD_ENV: "production"
  API_URL: "https://api.example.com"

build_job:
  script:
    - echo "构建 $APP_NAME"
    - echo "环境: $BUILD_ENV"
```

### 6.4 job级变量


```yaml
# 不同环境使用不同变量
deploy_staging:
  variables:
    DEPLOY_ENV: "staging"
    SERVER_URL: "staging.example.com"
  script:
    - echo "部署到 $DEPLOY_ENV"

deploy_production:
  variables:
    DEPLOY_ENV: "production"  
    SERVER_URL: "www.example.com"
  script:
    - echo "部署到 $DEPLOY_ENV"
```

### 6.5 内置变量使用


GitLab提供了很多有用的内置变量：

| 变量名 | 含义 | 示例值 |
|--------|------|--------|
| `$CI_COMMIT_SHA` | 提交的哈希值 | `a3b2c1d4...` |
| `$CI_COMMIT_BRANCH` | 分支名 | `main` |
| `$CI_PROJECT_NAME` | 项目名 | `my-project` |
| `$CI_PIPELINE_ID` | Pipeline ID | `12345` |

**使用示例**：
```yaml
build_job:
  script:
    - echo "构建分支: $CI_COMMIT_BRANCH"
    - echo "提交哈希: $CI_COMMIT_SHA"
    - docker build -t app:$CI_COMMIT_SHA .
```

---

## 7. ⏱️ 超时与性能设置


### 7.1 Pipeline超时设置


**为什么需要超时**：防止job卡死，浪费资源

**全局超时设置**：
```yaml
# 全局默认超时（1小时）
default:
  timeout: 1h

build_job:
  script:
    - echo "这个job最多运行1小时"
```

### 7.2 job级超时设置


```yaml
# 快速任务，5分钟超时
lint_check:
  script:
    - npm run lint
  timeout: 5m

# 耗时任务，3小时超时  
integration_test:
  script:
    - npm run test:integration
  timeout: 3h
```

### 7.3 常用时间单位


| 单位 | 含义 | 示例 |
|------|------|------|
| `s` | 秒 | `30s` |
| `m` | 分钟 | `10m` |
| `h` | 小时 | `2h` |

### 7.4 重试机制


**job失败后自动重试**：
```yaml
test_job:
  script:
    - npm test
  retry:
    max: 2           # 最多重试2次
    when:
      - runner_system_failure  # 只在系统故障时重试
      - stuck_or_timeout_failure
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 Pipeline本质：自动化的代码处理流水线
🔸 .gitlab-ci.yml：Pipeline的配置文件，定义执行规则
🔸 stages概念：将Pipeline分阶段，按顺序执行
🔸 触发条件：控制什么时候运行Pipeline
🔸 镜像作用：为job提供运行环境
🔸 变量管理：存储配置和控制job行为
```

### 8.2 最佳实践建议


**🔹 合理设计stages**：
```
推荐的stage顺序：
prepare → build → test → deploy → cleanup

- prepare: 环境准备
- build: 代码构建  
- test: 各种测试
- deploy: 部署应用
- cleanup: 清理工作
```

**🔹 变量使用原则**：
- 敏感信息用GitLab界面设置变量
- 配置信息用文件中的variables
- 环境相关的用job级变量

**🔹 性能优化技巧**：
- 选择合适的镜像（优先alpine版本）
- 设置合理的超时时间
- 相同stage的job会并行运行

### 8.3 常见错误避免


**❌ 容易犯的错误**：
```
1. YAML缩进错误 → 仔细检查空格
2. stage名字拼写错误 → 保持一致性
3. 镜像选择不当 → 选择最小化镜像
4. 忘记设置超时 → 防止job卡死
5. 变量作用域混乱 → 理解优先级
```

**✅ 推荐的文件结构**：
```yaml
# 文件开头：全局设置
image: node:16-alpine
stages:
  - build
  - test
  - deploy

variables:
  APP_NAME: "my-app"

# 中间部分：具体job
build:
  stage: build
  script:
    - npm run build

# 文件结尾：部署job
deploy:
  stage: deploy
  script:
    - echo "部署应用"
  only:
    - main
```

### 8.4 学习建议


**📚 循序渐进的学习路径**：
1. **先掌握基础**：理解Pipeline概念和简单的job
2. **再学stages**：学会分阶段组织工作流程  
3. **然后学变量**：掌握配置管理
4. **最后学高级特性**：并行、缓存、条件执行

**🎯 实践建议**：
- 从简单的`echo`命令开始
- 逐步添加真实的构建、测试命令
- 多看GitLab的Pipeline执行日志
- 遇到错误不要慌，检查YAML语法

**核心记忆口诀**：
> Pipeline如流水线，stages分步骤，  
> 触发条件要设好，镜像环境不能少，  
> 变量管理很重要，超时设置要记牢！