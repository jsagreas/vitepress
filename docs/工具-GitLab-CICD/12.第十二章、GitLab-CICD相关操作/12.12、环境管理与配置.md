---
title: 12、环境管理与配置
---
## 📚 目录

1. [环境管理基础概念](#1-环境管理基础概念)
2. [environment环境定义](#2-environment环境定义)
3. [环境URL配置与访问](#3-环境URL配置与访问)
4. [环境变量区分设置](#4-环境变量区分设置)
5. [多环境部署策略](#5-多环境部署策略)
6. [环境保护规则](#6-环境保护规则)
7. [手动部署触发机制](#7-手动部署触发机制)
8. [环境清理管理](#8-环境清理管理)
9. [环境监控集成](#9-环境监控集成)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🌍 环境管理基础概念


### 1.1 什么是环境管理


**环境管理就像管理不同的"房间"**

想象你开了一家餐厅，需要不同的区域：
```
厨房试验区 → 开发环境（dev）
员工内测区 → 测试环境（test）  
正式营业区 → 生产环境（prod）
```

> 📌 **核心概念**  
> 环境管理是指在软件开发过程中，为不同阶段的代码运行创建独立、隔离的运行空间，确保代码在不同环境下的正确性和稳定性。

**为什么需要环境管理？**

🔸 **安全隔离**：开发代码不会影响正式用户
🔸 **分阶段测试**：逐步验证代码质量
🔸 **风险控制**：问题可以在早期环境发现
🔸 **团队协作**：不同角色在对应环境工作

### 1.2 常见环境类型


```
开发环境 (Development)
    ↓ 功能完成
测试环境 (Testing)  
    ↓ 测试通过
预生产环境 (Staging)
    ↓ 最终确认
生产环境 (Production)
```

| 环境类型 | **主要用途** | **使用人员** | **稳定性要求** |
|---------|-------------|-------------|--------------|
| 🛠️ **开发环境** | 日常开发调试 | 开发人员 | 低，可以随时重启 |
| 🧪 **测试环境** | 功能测试验证 | 测试人员 | 中，需要相对稳定 |
| 🎭 **预生产环境** | 正式发布前验证 | 产品经理 | 高，接近生产环境 |
| 🚀 **生产环境** | 正式用户使用 | 运维人员 | 极高，不能出错 |

---

## 2. 📝 environment环境定义


### 2.1 environment基本语法


**在GitLab CI/CD中定义环境就像给房间贴标签**

```yaml
deploy_to_dev:
  stage: deploy
  script:
    - echo "部署到开发环境"
  environment:
    name: development                # 环境名称
    url: https://dev.example.com     # 环境访问地址
```

> 💡 **实用技巧**  
> `environment`就是告诉GitLab："这个任务要部署到哪个环境，部署完后用户可以通过什么地址访问"

### 2.2 动态环境名称


**根据分支创建不同环境**

```yaml
deploy_feature:
  stage: deploy
  script:
    - echo "部署功能分支"
  environment:
    name: review/$CI_COMMIT_REF_NAME     # 动态名称
    url: https://$CI_COMMIT_REF_NAME.review.example.com
  only:
    - branches
  except:
    - master
```

🌱 **入门理解**：
- `$CI_COMMIT_REF_NAME`是GitLab提供的变量，代表当前分支名
- 如果分支叫`feature-login`，环境名就是`review/feature-login`
- 访问地址就是`https://feature-login.review.example.com`

### 2.3 环境的生命周期管理


```yaml
# 创建环境
deploy:
  environment:
    name: production
    url: https://example.com
    on_stop: stop_production    # 指定停止任务

# 停止环境
stop_production:
  stage: deploy
  script:
    - echo "清理生产环境资源"
  environment:
    name: production
    action: stop              # 标记为停止动作
  when: manual               # 手动触发
```

---

## 3. 🔗 环境URL配置与访问


### 3.1 静态URL配置


**最简单的URL配置方式**

```yaml
deploy_to_staging:
  stage: deploy
  script:
    - kubectl apply -f k8s/staging/
  environment:
    name: staging
    url: https://staging.myapp.com     # 固定访问地址
```

### 3.2 动态URL生成


**根据部署结果动态生成访问地址**

```yaml
deploy_review:
  stage: deploy
  script:
    - |
      # 部署应用并获取实际地址
      helm install app-$CI_COMMIT_REF_SLUG ./chart
      APP_URL=$(kubectl get ingress app-$CI_COMMIT_REF_SLUG -o jsonpath='{.spec.rules[0].host}')
      echo "DYNAMIC_URL=https://$APP_URL" >> deploy.env
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: $DYNAMIC_URL                 # 使用动态地址
  artifacts:
    reports:
      dotenv: deploy.env              # 传递环境变量
```

> ⚠️ **注意事项**  
> 动态URL需要在script阶段生成，然后通过artifacts传递给environment使用

### 3.3 环境访问链接展示


**GitLab会在界面上展示环境链接**

```
部署流水线界面显示：
┌─────────────────────────────────┐
│ 🚀 部署成功                      │
│ 环境：staging                   │  
│ 🔗 访问链接：staging.myapp.com   │ ← 可直接点击
│ 部署时间：2分钟前                │
└─────────────────────────────────┘
```

---

## 4. 🔧 环境变量区分设置


### 4.1 通过GitLab变量管理环境配置


**在GitLab界面设置环境专用变量**

```
Settings → CI/CD → Variables

变量配置示例：
┌─────────────────────────────────────┐
│ 变量名：DATABASE_URL                │
│ 环境：production                    │  
│ 值：postgres://prod-db:5432/app     │
│ 受保护：✓                          │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ 变量名：DATABASE_URL                │
│ 环境：staging                       │
│ 值：postgres://test-db:5432/app     │
│ 受保护：✗                          │
└─────────────────────────────────────┘
```

### 4.2 在.gitlab-ci.yml中使用环境变量


```yaml
variables:
  # 全局默认变量
  APP_NAME: "my-application"

deploy_to_staging:
  stage: deploy
  variables:
    ENVIRONMENT: "staging"           # 任务级变量
    LOG_LEVEL: "debug"              # 测试环境用debug级别
  script:
    - echo "部署 $APP_NAME 到 $ENVIRONMENT 环境"
    - echo "数据库地址：$DATABASE_URL"    # 自动使用staging环境的值
  environment:
    name: staging

deploy_to_production:
  stage: deploy  
  variables:
    ENVIRONMENT: "production"        
    LOG_LEVEL: "error"              # 生产环境只记录错误
  script:
    - echo "部署 $APP_NAME 到 $ENVIRONMENT 环境"  
    - echo "数据库地址：$DATABASE_URL"    # 自动使用production环境的值
  environment:
    name: production
```

### 4.3 配置文件模板化


**使用环境变量生成不同环境的配置文件**

```yaml
prepare_config:
  stage: build
  script:
    - |
      # 根据环境变量生成配置文件
      cat > app.config << EOF
      database:
        url: $DATABASE_URL
        pool_size: $DB_POOL_SIZE
      redis:
        url: $REDIS_URL
      logging:
        level: $LOG_LEVEL
      features:
        debug_mode: $DEBUG_MODE
      EOF
  artifacts:
    paths:
      - app.config
    expire_in: 1 hour
```

---

## 5. 🎯 多环境部署策略


### 5.1 分支触发的环境部署


**不同分支自动部署到对应环境**

```yaml
# 开发分支部署到开发环境
deploy_dev:
  stage: deploy
  script:
    - ./scripts/deploy.sh dev
  environment:
    name: development
    url: https://dev.example.com
  only:
    - develop                        # 只有develop分支触发

# 测试分支部署到测试环境  
deploy_test:
  stage: deploy
  script:
    - ./scripts/deploy.sh test
  environment:
    name: testing
    url: https://test.example.com
  only:
    - /^test\/.*$/                   # test/开头的分支

# 主分支部署到生产环境
deploy_prod:
  stage: deploy
  script:
    - ./scripts/deploy.sh prod
  environment:
    name: production
    url: https://example.com
  only:
    - master                         # 只有master分支
  when: manual                       # 需要手动确认
```

### 5.2 蓝绿部署策略


**零停机时间的部署方案**

```yaml
# 第一步：部署到绿色环境
deploy_green:
  stage: deploy
  script:
    - ./scripts/deploy_to_green.sh
  environment:
    name: production-green
    url: https://green.example.com

# 第二步：切换流量到绿色环境
switch_to_green:
  stage: deploy
  script:
    - ./scripts/switch_traffic.sh green
  environment:
    name: production
    url: https://example.com         # 实际用户访问地址
  when: manual                       # 手动确认切换
  dependencies:
    - deploy_green
```

📊 **蓝绿部署流程图**：
```
用户流量 → 负载均衡器 → 蓝色环境(当前版本)
                  ↓
               绿色环境(新版本,待切换)

部署完成后：
用户流量 → 负载均衡器 → 绿色环境(新版本)
                  ↓  
               蓝色环境(旧版本,保留备用)
```

### 5.3 灰度发布策略


**逐步放量的安全部署**

```yaml
# 第一阶段：部署到1%用户
deploy_canary_1:
  stage: deploy
  script:
    - ./scripts/deploy_canary.sh 1   # 1%流量
  environment:
    name: production-canary
    url: https://example.com
  when: manual

# 第二阶段：扩展到10%用户  
deploy_canary_10:
  stage: deploy
  script:
    - ./scripts/deploy_canary.sh 10  # 10%流量
  environment:
    name: production-canary
    url: https://example.com
  when: manual
  dependencies:
    - deploy_canary_1

# 第三阶段：全量发布
deploy_full:
  stage: deploy
  script:
    - ./scripts/deploy_canary.sh 100 # 100%流量
  environment:
    name: production
    url: https://example.com
  when: manual
  dependencies:
    - deploy_canary_10
```

---

## 6. 🛡️ 环境保护规则


### 6.1 保护环境配置


**在GitLab界面设置环境保护**

```
Settings → CI/CD → Environments

保护规则配置：
┌─────────────────────────────────────┐
│ 环境名称：production                │
│ 保护规则：                          │
│ ✓ 只允许维护者部署                   │
│ ✓ 需要审批才能部署                   │
│ 允许的分支：master                   │
│ 允许的用户：@admin, @devops          │
└─────────────────────────────────────┘
```

### 6.2 部署审批流程


**生产环境需要审批的配置**

```yaml
deploy_to_production:
  stage: deploy
  script:
    - echo "准备部署到生产环境"
    - ./scripts/deploy_prod.sh
  environment:
    name: production
    url: https://example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      when: manual                   # 手动触发
      allow_failure: false           # 不允许失败
  before_script:
    - echo "⚠️  这是生产环境部署，请仔细确认！"
    - echo "📋 检查清单："
    - echo "   ✅ 代码已通过所有测试"
    - echo "   ✅ 已在预生产环境验证"  
    - echo "   ✅ 已通知相关人员"
```

### 6.3 部署窗口限制


**只在特定时间允许生产部署**

```yaml
deploy_production:
  stage: deploy
  script:
    - ./scripts/deploy.sh
  environment:
    name: production
  rules:
    # 只在工作日的非高峰时间部署
    - if: $CI_COMMIT_BRANCH == "master" && 
          $CI_PIPELINE_SOURCE == "web" &&
          $CI_COMMIT_TIMESTAMP > "09:00" &&
          $CI_COMMIT_TIMESTAMP < "18:00"
      when: manual
  before_script:
    - |
      HOUR=$(date +%H)
      DAY=$(date +%u)
      if [ $DAY -gt 5 ] || [ $HOUR -lt 9 ] || [ $HOUR -gt 18 ]; then
        echo "❌ 生产环境只能在工作日9:00-18:00部署"
        exit 1
      fi
```

---

## 7. 🎮 手动部署触发机制


### 7.1 基本手动触发


**需要人工确认的部署**

```yaml
deploy_manual:
  stage: deploy
  script:
    - echo "执行手动部署"
  environment:
    name: production
  when: manual                       # 需要手动点击
  allow_failure: false               # 一旦开始就不能失败
```

### 7.2 条件化手动触发


**只在特定条件下显示手动按钮**

```yaml
deploy_hotfix:
  stage: deploy
  script:
    - ./scripts/hotfix_deploy.sh
  environment:
    name: production
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\//    # 只有hotfix分支
      when: manual
    - when: never                            # 其他情况不显示
```

### 7.3 多阶段手动确认


**重要部署需要多次确认**

```yaml
# 第一步：准备部署
prepare_deploy:
  stage: prepare
  script:
    - echo "准备部署资源"
    - ./scripts/prepare.sh
  artifacts:
    paths:
      - deploy/
  when: manual

# 第二步：执行部署  
execute_deploy:
  stage: deploy
  script:
    - echo "执行实际部署"
    - ./scripts/deploy.sh
  environment:
    name: production
  dependencies:
    - prepare_deploy
  when: manual                               # 再次手动确认
  needs: 
    - prepare_deploy
```

**手动部署的用户界面显示**：
```
GitLab Pipeline界面：
┌─────────────────────────────────────┐
│ 🔄 prepare_deploy                   │
│    状态：等待手动触发               │
│    [▶️ 开始部署] 按钮                │
└─────────────────────────────────────┘
         ↓ 点击后
┌─────────────────────────────────────┐
│ ✅ prepare_deploy                   │
│ 🔄 execute_deploy                   │  
│    状态：等待手动触发               │
│    [🚀 执行部署] 按钮                │
└─────────────────────────────────────┘
```

---

## 8. 🗑️ 环境清理管理


### 8.1 自动环境清理


**过期环境自动删除**

```yaml
# 定期清理过期的review环境
cleanup_old_environments:
  stage: cleanup
  script:
    - |
      # 清理超过7天的review环境
      for env in $(gitlab-api get-environments | jq -r '.[] | select(.name | startswith("review/")) | select(.updated_at < (now - 7*24*3600) | strftime("%Y-%m-%d")) | .name'); do
        echo "清理过期环境: $env"
        ./scripts/cleanup_environment.sh $env
      done
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"    # 定时任务触发
  environment:
    name: cleanup
    action: stop
```

### 8.2 分支删除时清理环境


**分支被删除时自动清理对应环境**

```yaml
stop_review:
  stage: deploy
  script:
    - echo "清理review环境 $CI_COMMIT_REF_NAME"
    - kubectl delete namespace review-$CI_COMMIT_REF_SLUG
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop                             # 标记为停止动作
  rules:
    - if: $CI_COMMIT_BRANCH != "master"      # 非主分支
      when: manual
  allow_failure: true                        # 清理失败不影响流水线
```

### 8.3 资源成本控制


**根据资源使用量清理环境**

```yaml
monitor_and_cleanup:
  stage: monitor
  script:
    - |
      # 检查环境资源使用量
      RESOURCE_USAGE=$(kubectl top nodes | awk 'NR>1 {sum+=$3} END {print sum}')
      if [ $RESOURCE_USAGE -gt 80 ]; then
        echo "🚨 资源使用率超过80%，开始清理不活跃环境"
        ./scripts/cleanup_inactive_environments.sh
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
```

---

## 9. 📊 环境监控集成


### 9.1 部署状态监控


**集成健康检查到部署流程**

```yaml
deploy_with_monitoring:
  stage: deploy
  script:
    - ./scripts/deploy.sh
    - echo "等待服务启动..."
    - sleep 30
    - ./scripts/health_check.sh
  environment:
    name: production
    url: https://example.com
  after_script:
    - |
      # 发送部署通知到监控系统
      curl -X POST https://monitoring.example.com/api/deployments \
        -d "{
          \"environment\": \"production\",
          \"version\": \"$CI_COMMIT_SHA\",
          \"status\": \"$CI_JOB_STATUS\",
          \"url\": \"https://example.com\"
        }"
```

### 9.2 性能指标收集


**部署后自动收集性能数据**

```yaml
performance_test:
  stage: test
  script:
    - |
      # 等待服务完全启动
      echo "等待服务启动完成..."
      timeout 300 bash -c 'until curl -f $ENVIRONMENT_URL/health; do sleep 5; done'
      
      # 执行性能测试
      echo "开始性能测试..."
      ab -n 1000 -c 10 $ENVIRONMENT_URL/ > performance_report.txt
      
      # 提取关键指标
      RESPONSE_TIME=$(grep "Time per request" performance_report.txt | head -1 | awk '{print $4}')
      echo "平均响应时间: ${RESPONSE_TIME}ms"
      
      # 设置性能阈值检查
      if (( $(echo "$RESPONSE_TIME > 500" | bc -l) )); then
        echo "⚠️  响应时间超过500ms，需要关注性能问题"
      fi
  environment:
    name: $CI_COMMIT_REF_NAME
  artifacts:
    reports:
      performance: performance_report.txt
    expire_in: 1 week
```

### 9.3 告警集成


**环境异常时自动告警**

```yaml
deploy_with_alerts:
  stage: deploy
  script:
    - ./scripts/deploy.sh
  environment:
    name: production
  after_script:
    - |
      if [ "$CI_JOB_STATUS" == "failed" ]; then
        # 部署失败告警
        curl -X POST $SLACK_WEBHOOK \
          -d "{
            \"text\": \"🚨 生产环境部署失败！\",
            \"attachments\": [{
              \"color\": \"danger\",
              \"fields\": [
                {\"title\": \"项目\", \"value\": \"$CI_PROJECT_NAME\", \"short\": true},
                {\"title\": \"分支\", \"value\": \"$CI_COMMIT_REF_NAME\", \"short\": true},
                {\"title\": \"提交\", \"value\": \"$CI_COMMIT_SHA\", \"short\": true},
                {\"title\": \"流水线\", \"value\": \"$CI_PIPELINE_URL\", \"short\": false}
              ]
            }]
          }"
      else
        # 部署成功通知
        curl -X POST $SLACK_WEBHOOK \
          -d "{
            \"text\": \"✅ 生产环境部署成功\",
            \"attachments\": [{
              \"color\": \"good\",
              \"fields\": [
                {\"title\": \"环境地址\", \"value\": \"https://example.com\", \"short\": false}
              ]
            }]
          }"
      fi
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心概念


```
🔸 环境管理：为不同开发阶段创建独立的运行空间
🔸 environment定义：在.gitlab-ci.yml中声明部署目标环境
🔸 环境变量：根据环境自动使用不同的配置值
🔸 多环境策略：蓝绿部署、灰度发布、分支触发部署
🔸 环境保护：生产环境的访问控制和审批流程
🔸 手动部署：重要环境需要人工确认的安全机制
🔸 环境清理：自动清理过期环境，控制资源成本
🔸 监控集成：部署状态跟踪和性能监控
```

### 10.2 关键理解要点


**🔹 环境的本质作用**
```
理解要点：
- 环境 = 独立的运行空间 + 专用的配置
- 不同环境用于不同目的：开发、测试、生产
- 环境隔离确保代码质量和用户体验
```

**🔹 environment配置的核心**
```
关键要素：
- name：环境标识，用于GitLab界面展示
- url：环境访问地址，方便直接访问
- action：环境操作类型（创建/停止）
```

**🔹 环境变量的管理策略**
```
最佳实践：
- 敏感信息：通过GitLab Variables管理
- 环境特定：每个环境设置专用变量
- 配置模板：使用变量生成配置文件
```

### 10.3 实际应用价值


- **开发效率**：自动化的环境管理减少手工操作
- **质量保证**：分阶段验证确保代码质量  
- **风险控制**：保护规则和审批流程降低部署风险
- **成本优化**：自动清理过期环境控制资源消耗
- **团队协作**：清晰的环境划分便于团队分工

### 10.4 常见问题解决


**🔹 环境部署失败排查**
```
检查清单：
✅ 环境变量是否正确设置
✅ 部署脚本是否有执行权限  
✅ 目标环境资源是否充足
✅ 网络连接是否正常
✅ 依赖服务是否已启动
```

**🔹 环境访问问题诊断**
```
排查步骤：
1. 检查environment.url配置是否正确
2. 确认DNS解析是否生效
3. 验证负载均衡器配置
4. 检查防火墙和安全组规则
```

**🔹 环境清理注意事项**
```
安全要点：
⚠️  生产环境永远不要自动清理
⚠️  清理前确认没有重要数据
⚠️  保留日志用于问题排查
⚠️  通知相关人员清理计划
```

**核心记忆**：
- 环境管理是CI/CD的重要组成部分
- 合理的环境策略能显著提升开发效率和代码质量
- 环境保护和监控是生产安全的重要保障
- 自动化环境管理需要平衡效率和安全性