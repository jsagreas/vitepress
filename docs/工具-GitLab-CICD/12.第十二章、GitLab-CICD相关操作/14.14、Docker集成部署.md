---
title: 14、Docker集成部署
---
## 📚 目录

1. [Docker与CI/CD的关系](#1-Docker与CI-CD的关系)
2. [Docker镜像构建实践](#2-Docker镜像构建实践)
3. [Dockerfile编写要点](#3-Dockerfile编写要点)
4. [镜像仓库管理](#4-镜像仓库管理)
5. [容器部署配置](#5-容器部署配置)
6. [Docker Compose应用](#6-Docker-Compose应用)
7. [镜像版本管理策略](#7-镜像版本管理策略)
8. [容器健康检查](#8-容器健康检查)
9. [Docker资源限制](#9-Docker资源限制)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🐳 Docker与CI/CD的关系


### 1.1 为什么CI/CD需要Docker


> 💡 **通俗理解**  
> 想象一下：你在家里做的菜很好吃，但到了朋友家用他们的锅和调料，味道就变了。Docker就像是把你的厨房整个搬过去，保证在任何地方都能做出一样的菜。

**传统部署的痛点**：
```
开发环境：    我的电脑 → 代码运行正常 ✅
测试环境：    测试服务器 → 出现奇怪Bug ❌  
生产环境：    线上服务器 → 服务启动失败 ❌

问题根源：环境不一致！
- 操作系统版本不同
- 依赖库版本不同  
- 配置文件路径不同
- 环境变量设置不同
```

**Docker解决方案**：
```
🔸 环境一致性
开发环境 → Docker镜像 → 测试环境 → 生产环境
     ↓           ↓            ↓           ↓
   容器A      容器A        容器A       容器A
  (完全一致)  (完全一致)    (完全一致)   (完全一致)

🔸 快速部署
传统部署：安装系统 → 装软件 → 配环境 → 部署代码 (30分钟)
Docker部署：拉取镜像 → 启动容器 (3分钟)

🔸 版本回滚
出问题了？一键切换到上个版本的镜像
docker run my-app:v1.0  →  docker run my-app:v0.9
```

### 1.2 CI/CD中Docker的作用


**CI阶段 - 构建镜像**：
```
代码提交 → GitLab CI → 构建Docker镜像 → 推送到仓库

就像：
写好食谱 → 按食谱做菜 → 把整套厨房打包 → 放到仓库
```

**CD阶段 - 部署容器**：
```
拉取镜像 → 启动容器 → 提供服务

就像：
取出厨房包 → 在新地方组装 → 开始做菜
```

---

## 2. 🔨 Docker镜像构建实践


### 2.1 基础构建流程


**构建过程图示**：
```
源代码
   ↓
Dockerfile (构建脚本)
   ↓
docker build (构建命令)  
   ↓
Docker镜像 (可运行的包)
   ↓  
启动容器 (运行实例)
```

### 2.2 GitLab CI中的镜像构建


**基础构建配置**：
```yaml
# .gitlab-ci.yml
stages:
  - build
  - deploy

variables:
  # 镜像名称和标签
  IMAGE_NAME: "my-web-app"
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"

build-image:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind  # Docker in Docker
  before_script:
    # 登录到GitLab容器仓库
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # 构建镜像
    - docker build -t $CI_REGISTRY_IMAGE/$IMAGE_NAME:$IMAGE_TAG .
    - docker build -t $CI_REGISTRY_IMAGE/$IMAGE_NAME:latest .
    # 推送镜像
    - docker push $CI_REGISTRY_IMAGE/$IMAGE_NAME:$IMAGE_TAG
    - docker push $CI_REGISTRY_IMAGE/$IMAGE_NAME:latest
  only:
    - main
```

> 🧠 **记忆技巧**  
> **DID**原则：**D**ockerfie → **I**mage → **D**eploy  
> 先写食谱，再打包厨房，最后开张营业

### 2.3 多阶段构建优化


**为什么需要多阶段构建**：
```
单阶段构建问题：
- 镜像包含编译工具 → 镜像很大 (500MB+)
- 包含源代码 → 安全风险
- 包含开发依赖 → 运行时不需要

多阶段构建解决：
- 第一阶段：编译代码
- 第二阶段：只包含运行时文件
- 最终镜像：小而精 (50MB)
```

**多阶段Dockerfile示例**：
```dockerfile
# 第一阶段：构建阶段
FROM node:16-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# 第二阶段：运行阶段  
FROM nginx:alpine AS production
# 只复制构建结果，不要源代码和node_modules
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**优化效果对比**：
| 构建方式 | **镜像大小** | **构建时间** | **安全性** |
|---------|------------|------------|----------|
| 🔸 **单阶段** | `500MB+` | `较快` | `包含源码风险` |
| 🔸 **多阶段** | `50MB` | `稍慢` | `只包含运行文件` |

---

## 3. 📝 Dockerfile编写要点


### 3.1 Dockerfile基础结构


> 📖 **核心概念**  
> Dockerfile就像是装修图纸，告诉Docker怎么一步步搭建你的应用环境

**基础指令说明**：
```dockerfile
# 基础镜像 - 就像选择房子的地基
FROM ubuntu:20.04

# 维护者信息 - 标明这是谁的作品  
LABEL maintainer="developer@company.com"

# 工作目录 - 设置工作的房间
WORKDIR /app

# 复制文件 - 把东西搬进房间
COPY . .

# 执行命令 - 安装必要的工具
RUN apt-get update && apt-get install -y python3

# 暴露端口 - 开个门让外面能访问
EXPOSE 8080  

# 启动命令 - 房子装修好后要做什么
CMD ["python3", "app.py"]
```

### 3.2 编写最佳实践


**🎯 优化原则**：

1. **选择合适的基础镜像**：
```dockerfile
❌ 避免：FROM ubuntu:20.04        # 太大 (72MB)
✅ 推荐：FROM python:3.9-alpine   # 更小 (45MB)
✅ 更好：FROM python:3.9-slim     # 平衡 (122MB但兼容性好)
```

2. **合并RUN指令**：
```dockerfile
# ❌ 多层镜像，增大体积
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y pip
RUN apt-get clean

# ✅ 单层镜像，减小体积
RUN apt-get update && \
    apt-get install -y python3 pip && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

3. **利用构建缓存**：
```dockerfile
# ✅ 先复制依赖文件，利用缓存
COPY requirements.txt .
RUN pip install -r requirements.txt

# 再复制应用代码（经常变化）
COPY . .
```

### 3.3 常见应用类型Dockerfile


**🌐 Web应用（Node.js）**：
```dockerfile
FROM node:16-alpine

# 创建应用目录
WORKDIR /usr/src/app

# 复制依赖文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production && npm cache clean --force

# 复制应用代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001
USER nextjs

EXPOSE 3000
CMD ["npm", "start"]
```

**🐍 Python应用**：
```dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 复制并安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

EXPOSE 8000
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:app"]
```

---

## 4. 📦 镜像仓库管理


### 4.1 GitLab Container Registry


> 💡 **通俗理解**  
> Container Registry就像是Docker镜像的"网盘"，你可以上传、下载、分享你的镜像

**Registry地址结构**：
```
GitLab Registry地址组成：
registry.gitlab.com/用户名/项目名/镜像名:标签

实例：
registry.gitlab.com/mycompany/web-app/frontend:v1.0.0
            ↑            ↑        ↑         ↑
        域名地址      用户/组织   项目名     镜像:版本
```

### 4.2 镜像推送配置


**CI中的推送流程**：
```yaml
variables:
  # GitLab提供的预定义变量
  REGISTRY: $CI_REGISTRY                    # registry.gitlab.com
  IMAGE_PATH: $CI_REGISTRY_IMAGE           # 完整镜像路径
  
push-image:
  script:
    # 构建镜像
    - docker build -t $IMAGE_PATH:$CI_COMMIT_SHA .
    - docker build -t $IMAGE_PATH:latest .
    
    # 推送到Registry
    - docker push $IMAGE_PATH:$CI_COMMIT_SHA  # 具体版本
    - docker push $IMAGE_PATH:latest          # 最新版本
```

**📋 推荐标签策略**：
- `latest` - 最新稳定版本
- `v1.0.0` - 语义化版本号
- `main-abc123` - 分支名+提交号
- `develop` - 开发分支最新版

### 4.3 镜像清理策略


**存储空间管理**：
```yaml
# GitLab项目设置中的清理策略
cleanup-policy:
  enabled: true
  keep_n: 10                    # 保留最新10个版本
  older_than: "7d"              # 删除7天前的镜像
  name_regex: ".*"              # 匹配所有镜像名
  name_regex_keep: "latest|v.*" # 但保留latest和v开头的版本
```

---

## 5. 🚀 容器部署配置


### 5.1 基础部署流程


**部署架构图**：
```
GitLab CI/CD                目标服务器
     │                          │
     ├─ 构建镜像                 │
     ├─ 推送到Registry           │
     └─ 触发部署 ─────────────────┼─ 拉取镜像
                                ├─ 停止旧容器
                                ├─ 启动新容器
                                └─ 健康检查
```

### 5.2 部署配置示例


**简单部署脚本**：
```yaml
deploy:
  stage: deploy
  image: docker:20.10.16
  before_script:
    # 连接到部署服务器
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - ssh-keyscan $DEPLOY_HOST >> ~/.ssh/known_hosts
  script:
    # 在远程服务器执行部署
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        # 登录Registry
        echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
        
        # 拉取最新镜像
        docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
        
        # 停止旧容器（如果存在）
        docker stop my-app || true
        docker rm my-app || true
        
        # 启动新容器
        docker run -d \
          --name my-app \
          --restart unless-stopped \
          -p 80:8080 \
          -e DATABASE_URL=\$DATABASE_URL \
          $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
        
        # 清理旧镜像
        docker image prune -f
      "
  only:
    - main
```

### 5.3 零停机部署


**滚动更新策略**：
```yaml
deploy-rolling:
  script:
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        # 启动新容器（不同端口）
        docker run -d \
          --name my-app-new \
          -p 8081:8080 \
          $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
        
        # 等待新容器健康
        sleep 30
        
        # 切换流量（更新负载均衡配置）
        # 这里可以调用API或更新配置文件
        
        # 停止旧容器
        docker stop my-app-old || true
        docker rm my-app-old || true
        
        # 重命名容器
        docker rename my-app my-app-old || true
        docker rename my-app-new my-app
      "
```

---

## 6. 🔧 Docker Compose应用


### 6.1 什么是Docker Compose


> 💡 **生活类比**  
> 如果Docker是单个厨师，那么Docker Compose就是整个餐厅的管理系统，能同时协调厨师、服务员、收银员一起工作

**单容器 vs 多容器**：
```
单容器应用：
┌─────────────┐
│   Web应用    │  → 只能做一件事
└─────────────┘

多容器应用：
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Web前端    │  │  API后端    │  │   数据库     │
│   (Nginx)   │  │  (Node.js)  │  │  (MySQL)   │
└─────────────┘  └─────────────┘  └─────────────┘
       ↓               ↓               ↓
    处理界面        处理业务逻辑       存储数据
```

### 6.2 Docker Compose配置


**基础compose配置**：
```yaml
# docker-compose.yml
version: '3.8'

services:
  # Web应用服务
  web:
    build: .                           # 从当前目录构建
    ports:
      - "3000:3000"                   # 端口映射
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:pass@db:5432/myapp
    depends_on:
      - db                            # 依赖数据库服务
    restart: unless-stopped

  # 数据库服务
  db:
    image: postgres:13-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data  # 数据持久化
    restart: unless-stopped

  # Redis缓存服务
  redis:
    image: redis:6-alpine
    restart: unless-stopped

volumes:
  postgres_data:                      # 定义数据卷
```

### 6.3 GitLab CI中使用Compose


**部署配置示例**：
```yaml
deploy-compose:
  stage: deploy
  script:
    - |
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        # 创建部署目录
        mkdir -p /opt/myapp
        cd /opt/myapp
        
        # 下载compose文件
        curl -o docker-compose.yml $CI_PROJECT_URL/-/raw/$CI_COMMIT_SHA/docker-compose.yml
        
        # 设置环境变量
        echo 'DATABASE_PASSWORD=$DATABASE_PASSWORD' > .env
        echo 'REDIS_PASSWORD=$REDIS_PASSWORD' >> .env
        
        # 拉取最新镜像
        docker-compose pull
        
        # 重启服务（零停机）
        docker-compose up -d
        
        # 清理旧镜像
        docker image prune -f
      "
```

**🎯 Compose常用命令**：
```bash
# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs web

# 停止所有服务
docker-compose down

# 重启特定服务
docker-compose restart web
```

---

## 7. 🏷️ 镜像版本管理策略


### 7.1 版本标记策略


**📊 标记策略对比**：

| 策略类型 | **标记格式** | **适用场景** | **优缺点** |
|---------|------------|------------|----------|
| 🔸 **语义化版本** | `v1.2.3` | `正式发布` | `清晰明确，但需要手动管理` |
| 🔸 **Git提交** | `abc123f` | `开发测试` | `自动生成，但不够语义化` |
| 🔸 **分支+时间** | `main-20240921` | `日常构建` | `信息丰富，便于追溯` |
| 🔸 **环境标记** | `prod-v1.0` | `环境区分` | `环境明确，但标记复杂` |

### 7.2 自动版本管理


**基于Git标签的版本管理**：
```yaml
# 自动检测版本标签
build-release:
  stage: build
  script:
    # 获取版本信息
    - |
      if [ "$CI_COMMIT_TAG" ]; then
        VERSION=$CI_COMMIT_TAG
      else
        VERSION="$CI_COMMIT_REF_NAME-$CI_COMMIT_SHORT_SHA"
      fi
    
    # 构建并标记镜像
    - docker build -t $CI_REGISTRY_IMAGE:$VERSION .
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    
    # 推送镜像
    - docker push $CI_REGISTRY_IMAGE:$VERSION
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - tags     # 只在打标签时执行
    - main     # 或在主分支
```

### 7.3 版本回滚策略


**快速回滚流程**：
```yaml
rollback:
  stage: deploy
  script:
    - |
      # 回滚到指定版本
      ROLLBACK_VERSION=${ROLLBACK_VERSION:-"previous"}
      
      ssh $DEPLOY_USER@$DEPLOY_HOST "
        # 停止当前服务
        docker stop my-app
        
        # 启动指定版本
        docker run -d \
          --name my-app-rollback \
          --restart unless-stopped \
          -p 80:8080 \
          $CI_REGISTRY_IMAGE:$ROLLBACK_VERSION
        
        # 清理旧容器
        docker rm my-app
        docker rename my-app-rollback my-app
      "
  when: manual                        # 手动触发
  only:
    - main
```

---

## 8. 🔍 容器健康检查


### 8.1 健康检查原理


> 💡 **通俗理解**  
> 健康检查就像定期体检，让系统自动检查应用是否还"活着"且"健康"

**健康检查流程**：
```
定时检查 → 发送请求 → 检查响应 → 判断状态

健康状态：
✅ healthy   - 应用正常运行
⚠️ unhealthy - 应用出现问题  
🔄 starting  - 应用正在启动
```

### 8.2 Dockerfile中的健康检查


**基础健康检查**：
```dockerfile
# Web应用健康检查
HEALTHCHECK --interval=30s \
            --timeout=10s \
            --start-period=60s \
            --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1
```

**参数说明**：
- `--interval=30s` - 每30秒检查一次
- `--timeout=10s` - 超时时间10秒
- `--start-period=60s` - 启动后60秒才开始检查
- `--retries=3` - 失败3次才认为不健康

**高级健康检查示例**：
```dockerfile
# 数据库连接检查
HEALTHCHECK --interval=30s --timeout=5s \
  CMD python3 -c "
import psycopg2
try:
    conn = psycopg2.connect('postgresql://user:pass@localhost/db')
    conn.close()
    exit(0)
except:
    exit(1)
"

# 多项检查
HEALTHCHECK --interval=30s --timeout=10s \
  CMD /app/health-check.sh
```

### 8.3 应用级健康检查


**健康检查接口实现**：
```javascript
// Node.js健康检查接口
app.get('/health', async (req, res) => {
  try {
    // 检查数据库连接
    await db.ping();
    
    // 检查Redis连接  
    await redis.ping();
    
    // 检查关键服务
    const services = await Promise.all([
      checkDatabaseHealth(),
      checkExternalAPIHealth(),
      checkDiskSpace()
    ]);
    
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: services
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```

**🎯 健康检查最佳实践**：
- ✅ 检查核心功能，不要检查所有细节
- ✅ 快速响应，避免超时
- ✅ 有意义的错误信息
- ✅ 检查外部依赖（数据库、Redis等）
- ❌ 不要在健康检查中执行重要业务逻辑

---

## 9. ⚡ Docker资源限制


### 9.1 为什么需要资源限制


**资源竞争问题**：
```
无限制情况：
容器A ──[占用]──> CPU: 90%    ┌─ 应用响应慢
容器B ──[抢夺]──> CPU: 10%    ├─ 服务器卡顿  
容器C ──[等待]──> CPU: 0%     └─ 系统不稳定

限制后：
容器A ──[限制]──> CPU: 最多50%  ┌─ 性能可预期
容器B ──[限制]──> CPU: 最多30%  ├─ 资源分配合理
容器C ──[限制]──> CPU: 最多20%  └─ 系统稳定
```

### 9.2 CPU和内存限制


**Docker运行时限制**：
```bash
# 基础资源限制
docker run -d \
  --name my-app \
  --cpus="1.5" \              # 限制CPU使用1.5核
  --memory="512m" \           # 限制内存使用512MB
  --memory-swap="1g" \        # 限制交换空间1GB
  my-app:latest

# 更详细的CPU限制
docker run -d \
  --cpuset-cpus="0,1" \       # 只能使用CPU 0和1
  --cpu-quota=50000 \         # CPU配额（50%）
  --cpu-period=100000 \       # CPU周期
  my-app:latest
```

**Docker Compose中的限制**：
```yaml
services:
  web:
    image: my-web-app
    deploy:
      resources:
        limits:
          cpus: '1.0'           # 最多使用1个CPU核心
          memory: 512M          # 最多使用512MB内存
        reservations:
          cpus: '0.5'           # 保证至少0.5个CPU核心
          memory: 256M          # 保证至少256MB内存
```

### 9.3 监控和调优


**资源使用监控**：
```bash
# 查看容器资源使用情况
docker stats

# 实时监控特定容器
docker stats my-app

# 输出示例：
CONTAINER   CPU %   MEM USAGE/LIMIT     MEM %   NET I/O     BLOCK I/O
my-app      45.2%   312.1MiB/512MiB    60.9%   1.2MB/890kB 0B/0B
```

**性能调优建议**：

1. **内存设置**：
```yaml
# 🎯 推荐配置
小型应用：    memory: 256M-512M
中型应用：    memory: 512M-2G  
大型应用：    memory: 2G-8G
数据库：      memory: 4G-16G
```

2. **CPU设置**：
```yaml
# 🎯 推荐配置  
Web前端：     cpus: 0.5-1.0
API服务：     cpus: 1.0-2.0
数据处理：    cpus: 2.0-4.0
数据库：      cpus: 2.0-8.0
```

**📊 资源限制效果监控**：
```yaml
# GitLab CI中添加性能检查
performance-check:
  stage: test
  script:
    - |
      # 启动容器并监控30秒
      docker run -d --name test-app --memory="512m" --cpus="1.0" $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      sleep 30
      
      # 检查资源使用
      MEMORY_USAGE=$(docker stats --no-stream --format "{{.MemUsage}}" test-app)
      CPU_USAGE=$(docker stats --no-stream --format "{{.CPUPerc}}" test-app)
      
      echo "内存使用: $MEMORY_USAGE"
      echo "CPU使用: $CPU_USAGE"
      
      # 清理测试容器
      docker stop test-app && docker rm test-app
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的基本概念


```
🔸 Docker作用：解决"在我机器上能跑"的环境一致性问题
🔸 镜像构建：通过Dockerfile将应用打包成可运行的镜像
🔸 容器部署：从镜像启动容器实例，提供实际服务
🔸 版本管理：合理的标签策略确保版本可追溯和回滚
🔸 健康检查：自动监控应用状态，及时发现和处理问题
🔸 资源限制：防止容器过度消耗系统资源
```

### 10.2 关键理解要点


**🔹 Docker解决的核心问题**
```
环境一致性：
开发环境 = 测试环境 = 生产环境
"一次构建，到处运行"

快速部署：
传统部署：配置环境(30分钟) → 部署应用(10分钟)
容器部署：拉取镜像(2分钟) → 启动容器(30秒)

版本管理：
出问题？立即回滚到上个版本
需要测试？并行运行多个版本
```

**🔹 CI/CD中的Docker工作流**
```
代码变更 → 自动构建镜像 → 推送到仓库 → 自动部署更新

好处：
• 自动化：减少人工操作错误
• 一致性：确保部署环境统一  
• 快速性：快速构建和部署
• 可靠性：容易回滚和恢复
```

**🔹 Dockerfile编写原则**
```
分层优化：利用缓存机制，先装依赖再复制代码
镜像精简：使用alpine基础镜像，清理无用文件
安全性：使用非root用户，避免暴露敏感信息
可维护：清晰的注释，合理的指令顺序
```

### 10.3 实际应用指导


**🎯 新手学习路径**：
1. **理解概念**：先搞懂Docker基本概念和作用
2. **编写Dockerfile**：学会为自己的应用编写构建脚本
3. **本地测试**：在本地环境测试镜像构建和运行
4. **集成CI/CD**：在GitLab中配置自动构建和部署
5. **优化改进**：学习多阶段构建、资源限制等高级特性

**🛠️ 常见问题解决**：
```
镜像太大？
→ 使用alpine基础镜像，多阶段构建，清理缓存

构建很慢？  
→ 优化Dockerfile层次，利用缓存机制

部署失败？
→ 检查健康检查配置，查看容器日志

资源不足？
→ 设置合理的CPU和内存限制
```

**🔧 实用配置模板**：
```yaml
# 适合大多数Web应用的GitLab CI配置
stages:
  - build
  - test  
  - deploy

variables:
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA

build:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$IMAGE_TAG .
    - docker push $CI_REGISTRY_IMAGE:$IMAGE_TAG

deploy:
  stage: deploy
  script:
    - docker pull $CI_REGISTRY_IMAGE:$IMAGE_TAG
    - docker stop my-app || true
    - docker rm my-app || true
    - docker run -d --name my-app -p 80:8080 $CI_REGISTRY_IMAGE:$IMAGE_TAG
  only:
    - main
```

### 10.4 进阶学习方向


**🚀 深入学习建议**：
- **容器编排**：学习Kubernetes进行大规模容器管理
- **监控告警**：集成Prometheus + Grafana监控容器状态
- **安全加固**：容器安全扫描，镜像签名验证
- **性能优化**：容器网络优化，存储卷管理

**🧠 记忆口诀**：
> Docker打包环境一致性，CI构建CD部署自动化  
> Dockerfile分层要优化，健康检查资源要限制  
> 版本管理回滚有保障，容器编排未来方向

**核心记忆**：
- Docker = 环境一致性 + 快速部署
- CI/CD + Docker = 自动化 + 可靠性
- 实践中边学边用，问题导向学习最有效