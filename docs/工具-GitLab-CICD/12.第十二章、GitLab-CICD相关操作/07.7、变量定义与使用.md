---
title: 7、变量定义与使用
---
## 📚 目录

1. [变量概念与作用](#1-变量概念与作用)
2. [预定义变量使用](#2-预定义变量使用)
3. [自定义变量定义](#3-自定义变量定义)
4. [变量层级与优先级](#4-变量层级与优先级)
5. [变量在脚本中的使用](#5-变量在脚本中的使用)
6. [敏感变量保护](#6-敏感变量保护)
7. [变量管理最佳实践](#7-变量管理最佳实践)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 变量概念与作用


### 1.1 什么是GitLab CI/CD变量


**简单理解**：变量就像是一个"容器"，用来存放信息，这些信息可以在CI/CD流水线中重复使用。

```
举个生活例子：
你的手机通讯录存了朋友的电话号码
↓
变量就像通讯录，存储重要信息
↓  
需要打电话时直接用名字查找，不用记号码
↓
CI/CD中用变量名获取值，不用写死具体内容
```

**🔸 为什么需要变量？**
- **避免重复**：同一个值在多个地方使用，只需定义一次
- **易于维护**：需要修改时只改一个地方
- **安全保护**：敏感信息（如密码）不直接写在代码里
- **环境区分**：不同环境使用不同配置

### 1.2 变量的实际作用


**💡 实际应用场景**：
```
🔸 数据库连接：DATABASE_URL=mysql://user:pass@localhost/db
🔸 API密钥：API_KEY=abc123def456（保密信息）
🔸 部署地址：DEPLOY_URL=https://staging.example.com
🔸 版本号：APP_VERSION=v1.2.3
🔸 环境标识：ENVIRONMENT=production
```

---

## 2. 🌟 预定义变量使用


### 2.1 什么是预定义变量


**通俗解释**：GitLab自动为每个项目准备好的"现成变量"，就像酒店为客人准备的免费洗漱用品，开箱即用。

**🔹 常用预定义变量**：

| 变量名 | **作用说明** | **实际例子** |
|-------|-------------|-------------|
| `CI_PROJECT_NAME` | 项目名称 | `my-awesome-app` |
| `CI_COMMIT_SHA` | 提交的唯一标识 | `a1b2c3d4e5f6...` |
| `CI_COMMIT_BRANCH` | 当前分支名 | `main`, `develop` |
| `CI_PIPELINE_ID` | 流水线编号 | `12345` |
| `CI_JOB_NAME` | 当前任务名 | `build`, `test` |
| `CI_ENVIRONMENT_NAME` | 环境名称 | `production` |

### 2.2 预定义变量的使用方法


**📋 在.gitlab-ci.yml中使用**：
```yaml
build_job:
  script:
    - echo "正在构建项目：$CI_PROJECT_NAME"
    - echo "提交版本：$CI_COMMIT_SHA"
    - echo "分支：$CI_COMMIT_BRANCH"
    - docker build -t $CI_PROJECT_NAME:$CI_COMMIT_SHA .
```

**🎯 实际运行效果**：
```
正在构建项目：my-web-app
提交版本：a1b2c3d4e5f6789...
分支：main
docker build -t my-web-app:a1b2c3d4e5f6789 .
```

### 2.3 预定义变量的便利性


**🚀 自动化优势**：
```
传统方式：手动指定版本号
- docker build -t myapp:v1.0.1 .

使用预定义变量：自动使用提交号作为版本
- docker build -t myapp:$CI_COMMIT_SHA .

好处：
✅ 每次构建版本号都不同，避免冲突
✅ 可以精确追踪每个版本对应的代码
✅ 不需要手动更新版本号
```

---

## 3. 🔧 自定义变量定义


### 3.1 在.gitlab-ci.yml中定义变量


**🔸 全局变量定义**：
```yaml
# 整个流水线都能使用的变量
variables:
  NODE_VERSION: "18"
  APP_NAME: "my-web-app"
  BUILD_ENV: "production"
  
stages:
  - build
  - test

build_job:
  stage: build
  script:
    - echo "应用名：$APP_NAME"
    - echo "Node版本：$NODE_VERSION"
    - npm install
```

**🔸 任务级变量定义**：
```yaml
# 只在特定任务中使用的变量
test_job:
  stage: test
  variables:
    TEST_DATABASE: "test_db"
    MAX_THREADS: "4"
  script:
    - echo "测试数据库：$TEST_DATABASE"
    - echo "最大线程数：$MAX_THREADS"
    - npm test
```

### 3.2 变量定义的层次结构


**🏗️ 变量作用范围**：
```
全局变量（variables:）
├── 所有任务都能访问
├── 定义在文件顶部
└── 适合公共配置

任务变量（job variables:）
├── 只在当前任务中有效
├── 可以覆盖全局变量
└── 适合任务特定配置
```

**💫 实际示例**：
```yaml
variables:
  # 全局变量：所有任务都能用
  APP_NAME: "my-app"
  DEFAULT_ENV: "development"

build_job:
  variables:
    # 任务变量：只有build_job能用
    BUILD_TYPE: "release"
    # 覆盖全局变量
    DEFAULT_ENV: "production"
  script:
    - echo "应用：$APP_NAME"           # 输出：my-app
    - echo "环境：$DEFAULT_ENV"        # 输出：production（被覆盖）
    - echo "构建类型：$BUILD_TYPE"     # 输出：release
```

---

## 4. ⚖️ 变量层级与优先级


### 4.1 GitLab变量的四个层级


**🎯 从最高到最低优先级**：

```
实例级变量（Instance-level）
├── 整个GitLab实例的所有项目都能用
├── 只有管理员能设置
└── 优先级：最低

组级变量（Group-level）  
├── 组内所有项目都能用
├── 组管理员可以设置
└── 优先级：较低

项目级变量（Project-level）
├── 只有当前项目能用
├── 项目维护者可以设置
└── 优先级：较高

任务级变量（Job-level）
├── 在.gitlab-ci.yml中定义
├── 开发者可以设置
└── 优先级：最高
```

### 4.2 变量优先级实战理解


**🔄 优先级覆盖示例**：

假设同一个变量在不同层级都有定义：

```
实例级：DATABASE_URL = "mysql://global-db"
组级：  DATABASE_URL = "mysql://group-db"  
项目级：DATABASE_URL = "mysql://project-db"
任务级：DATABASE_URL = "mysql://job-db"

最终结果：使用 "mysql://job-db"
原因：任务级优先级最高
```

**💡 实际配置示例**：
```yaml
# 项目的.gitlab-ci.yml文件
variables:
  # 项目级变量
  API_URL: "https://api.example.com"
  
deploy_job:
  variables:
    # 任务级变量，会覆盖项目级
    API_URL: "https://staging-api.example.com"
  script:
    - echo "使用API：$API_URL"  # 输出：staging-api.example.com
```

### 4.3 各层级变量的设置方法


**🖥️ 项目级变量设置**：
```
步骤：
1. 进入项目 → Settings → CI/CD
2. 展开 "Variables" 部分
3. 点击 "Add variable"
4. 填写：
   - Key: DATABASE_PASSWORD
   - Value: your_password_here
   - 可选：勾选 "Protected"（只在保护分支使用）
   - 可选：勾选 "Masked"（在日志中隐藏）
```

**🏢 组级变量设置**：
```
步骤：
1. 进入组 → Settings → CI/CD  
2. 展开 "Variables" 部分
3. 添加变量（方法同项目级）

应用：组内所有项目自动继承这些变量
```

---

## 5. 📝 变量在脚本中的使用


### 5.1 基本使用语法


**🔸 Shell脚本中使用变量**：
```yaml
test_job:
  variables:
    DATABASE_NAME: "test_db"
    PORT: "3306"
  script:
    # 方式1：直接使用 $变量名
    - echo "数据库：$DATABASE_NAME"
    
    # 方式2：使用 ${变量名}（推荐）
    - echo "连接地址：${DATABASE_NAME}:${PORT}"
    
    # 方式3：在字符串中使用
    - echo "完整URL：mysql://user:pass@localhost:${PORT}/${DATABASE_NAME}"
```

### 5.2 变量在不同场景的使用


**🐳 Docker构建中使用变量**：
```yaml
build_docker:
  variables:
    DOCKER_TAG: "${CI_COMMIT_SHA}"
    REGISTRY: "registry.example.com"
  script:
    - docker build -t ${REGISTRY}/myapp:${DOCKER_TAG} .
    - docker push ${REGISTRY}/myapp:${DOCKER_TAG}
    
    # 同时创建latest标签
    - docker tag ${REGISTRY}/myapp:${DOCKER_TAG} ${REGISTRY}/myapp:latest
    - docker push ${REGISTRY}/myapp:latest
```

**📦 部署脚本中使用变量**：
```yaml
deploy_job:
  variables:
    DEPLOY_HOST: "production.example.com"
    APP_PORT: "8080"
  script:
    - echo "正在部署到：${DEPLOY_HOST}"
    - ssh user@${DEPLOY_HOST} "docker run -d -p ${APP_PORT}:3000 myapp:${CI_COMMIT_SHA}"
    - echo "部署完成，访问地址：http://${DEPLOY_HOST}:${APP_PORT}"
```

### 5.3 变量的条件使用


**🔀 根据分支使用不同变量**：
```yaml
deploy_job:
  script:
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        export DEPLOY_ENV="production"
        export API_URL="https://api.example.com"
      elif [ "$CI_COMMIT_BRANCH" = "develop" ]; then
        export DEPLOY_ENV="staging"  
        export API_URL="https://staging-api.example.com"
      else
        export DEPLOY_ENV="testing"
        export API_URL="https://test-api.example.com"
      fi
    - echo "部署环境：$DEPLOY_ENV"
    - echo "API地址：$API_URL"
```

**🎯 使用GitLab的rules实现条件变量**：
```yaml
variables:
  DEPLOY_STRATEGY: "manual"

# 生产环境部署
deploy_production:
  variables:
    DEPLOY_ENV: "production"
    API_URL: "https://api.example.com"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - echo "生产部署：$DEPLOY_ENV"

# 测试环境部署  
deploy_staging:
  variables:
    DEPLOY_ENV: "staging"
    API_URL: "https://staging-api.example.com"
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
  script:
    - echo "测试部署：$DEPLOY_ENV"
```

---

## 6. 🔒 敏感变量保护


### 6.1 什么是敏感变量


**🔐 敏感信息类型**：
- **数据库密码**：`DATABASE_PASSWORD`
- **API密钥**：`AWS_ACCESS_KEY`, `STRIPE_SECRET_KEY`
- **证书文件**：SSL证书、私钥
- **第三方服务Token**：`GITHUB_TOKEN`, `DOCKER_HUB_PASSWORD`

### 6.2 变量保护设置


**🛡️ Protected变量**：
```
作用：只在受保护的分支（如main）上使用
设置：在GitLab界面添加变量时勾选"Protected"

使用场景：
- 生产环境部署密钥
- 重要的API密钥
- 数据库生产环境密码

效果：
✅ 在main分支：可以使用该变量
❌ 在feature分支：无法访问该变量
```

**🎭 Masked变量**：
```
作用：在CI/CD日志中隐藏变量值
设置：在GitLab界面添加变量时勾选"Masked"

示例：
原始输出：Database password is: abc123xyz
Masked输出：Database password is: [MASKED]

注意：只能遮蔽符合特定格式的值（无空格、特殊字符）
```

### 6.3 敏感变量的最佳实践


**🔑 安全使用原则**：
```yaml
# ❌ 错误做法：直接写在代码里
deploy_job:
  script:
    - docker login -u myuser -p mypassword123
    - mysql -u root -p'hardcoded_password' -e "SELECT 1"

# ✅ 正确做法：使用变量
deploy_job:
  script:
    - docker login -u $DOCKER_USER -p $DOCKER_PASSWORD
    - mysql -u $DB_USER -p$DB_PASSWORD -e "SELECT 1"
```

**🎯 变量命名规范**：
```
敏感变量命名建议：
- DATABASE_PASSWORD（而不是 DB_PASS）
- API_SECRET_KEY（而不是 SECRET）
- PRODUCTION_TOKEN（而不是 TOKEN）

好处：
✅ 一看就知道是敏感信息
✅ 避免意外泄露
✅ 便于管理和审计
```

### 6.4 文件类型敏感变量


**📄 存储文件内容的变量**：
```yaml
# 例如：存储私钥文件内容
deploy_job:
  script:
    # 将变量内容写入文件
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    
    # 将证书内容写入文件
    - echo "$SSL_CERTIFICATE" > /etc/ssl/cert.pem
    - echo "$SSL_PRIVATE_KEY" > /etc/ssl/private.key
```

**🔧 实际应用场景**：
```
使用场景：
1. SSH私钥：用于服务器部署
2. SSL证书：用于HTTPS配置  
3. 配置文件：包含敏感信息的配置
4. 密钥文件：加密解密操作

设置方法：
1. 将整个文件内容复制粘贴到变量值中
2. 勾选"Masked"保护
3. 在脚本中将变量内容写入文件
```

---

## 7. 🚀 变量管理最佳实践


### 7.1 变量组织策略


**🏗️ 按环境分组**：
```yaml
# 开发环境变量
variables:
  DEV_API_URL: "https://dev-api.example.com"
  DEV_DATABASE_URL: "mysql://dev-db:3306/app_dev"
  
# 生产环境变量（通过GitLab界面设置）
# PROD_API_URL: "https://api.example.com"  
# PROD_DATABASE_URL: "mysql://prod-db:3306/app_prod"
```

**🎯 变量命名规范**：
```
环境前缀：
- DEV_*    : 开发环境
- STAGING_*: 测试环境  
- PROD_*   : 生产环境

功能分类：
- DB_*     : 数据库相关
- API_*    : API相关
- DOCKER_* : Docker相关
- DEPLOY_* : 部署相关

示例：
- PROD_DB_PASSWORD
- STAGING_API_KEY
- DOCKER_REGISTRY_URL
```

### 7.2 变量使用模式


**🔄 环境切换模式**：
```yaml
# 使用模板减少重复
.deploy_template: &deploy_template
  script:
    - echo "部署到：$ENVIRONMENT"
    - echo "API地址：$API_URL"
    - echo "数据库：$DATABASE_URL"
    - ./deploy.sh

deploy_staging:
  <<: *deploy_template
  variables:
    ENVIRONMENT: "staging"
    API_URL: "$STAGING_API_URL"
    DATABASE_URL: "$STAGING_DB_URL"
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"

deploy_production:
  <<: *deploy_template  
  variables:
    ENVIRONMENT: "production"
    API_URL: "$PROD_API_URL"
    DATABASE_URL: "$PROD_DB_URL"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```

### 7.3 变量维护建议


**📋 定期审查清单**：
```
🔍 每月检查：
- [ ] 删除不再使用的变量
- [ ] 更新过期的密钥和token
- [ ] 检查变量命名是否规范
- [ ] 确认敏感变量保护设置

🛡️ 安全检查：
- [ ] 敏感变量是否设置了Protected
- [ ] 密码类变量是否设置了Masked
- [ ] 是否有硬编码的敏感信息
- [ ] 变量权限是否合理
```

**🎯 团队协作规范**：
```
变量使用约定：
1. 新增变量前先检查是否已存在类似的
2. 使用统一的命名规范
3. 及时删除不用的变量
4. 敏感变量通过安全渠道分享
5. 文档记录重要变量的用途
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的概念


```
🔸 变量本质：存储可重用信息的容器，提高配置灵活性
🔸 预定义变量：GitLab自动提供，开箱即用（如CI_PROJECT_NAME）
🔸 自定义变量：根据需求定义，支持全局和任务级作用域
🔸 变量层级：实例级 < 组级 < 项目级 < 任务级（优先级递增）
🔸 敏感保护：Protected保护分支，Masked隐藏日志显示
```

### 8.2 关键理解要点


**🔹 为什么变量如此重要**：
```
代码复用：
- 同一配置多处使用，修改一处即可
- 避免硬编码，提高代码质量

环境区分：
- 不同环境使用不同配置
- 同一套代码适配多个环境

安全管理：
- 敏感信息集中管理
- 避免密码泄露到代码仓库
```

**🔹 变量使用的最佳时机**：
```
适合使用变量：
✅ 多处重复的配置信息
✅ 环境相关的参数
✅ 敏感信息（密码、密钥）
✅ 可能变化的配置

不需要使用变量：
❌ 只用一次的简单值
❌ 固定不变的常量
❌ 简单的字符串
```

### 8.3 实际应用价值


**💼 实际工作场景**：
- **多环境部署**：通过变量区分开发、测试、生产环境
- **团队协作**：统一的变量管理，避免配置冲突
- **安全合规**：敏感信息保护，满足安全审计要求
- **自动化流程**：减少手动配置，提高部署效率

**🔧 实践建议**：
```
新手起步：
1. 先掌握基本语法：$VARIABLE_NAME
2. 理解作用域：全局 vs 任务级
3. 学会设置界面操作
4. 练习敏感变量保护

进阶使用：
1. 掌握变量优先级规则
2. 设计合理的命名规范
3. 建立变量管理流程
4. 结合条件判断使用变量
```

### 8.4 常见问题解决


**❓ 新手常见困惑**：
```
Q: 变量不生效怎么办？
A: 检查变量名拼写、作用域、优先级

Q: 敏感变量如何安全使用？
A: 使用Protected+Masked，不要硬编码

Q: 如何组织大量变量？
A: 按环境和功能分类，使用统一命名规范

Q: 变量值包含特殊字符怎么处理？
A: 使用引号包围，或者base64编码
```

**🧠 记忆口诀**：
```
"变量管理三原则"：
1. 重复配置用变量，一改全部都更新
2. 敏感信息要保护，Protected加Masked
3. 命名规范要统一，环境功能分得清
```

### 8.5 学习检查点


**✅ 掌握验证标准**：
- [ ] 能解释变量的作用和价值
- [ ] 会在.gitlab-ci.yml中定义和使用变量
- [ ] 理解变量优先级和作用域
- [ ] 能正确设置敏感变量保护
- [ ] 掌握变量命名和组织最佳实践

**🎯 实践目标**：
- 能够为实际项目设计合理的变量结构
- 可以安全地管理敏感信息
- 具备排查变量相关问题的能力
- 建立良好的变量维护习惯

**核心记忆**：
- 变量是CI/CD配置的基础，掌握好变量管理是构建高效流水线的关键
- 安全性和可维护性并重，既要保护敏感信息，又要便于团队协作
- 良好的变量组织和命名规范，是项目长期维护的重要保障