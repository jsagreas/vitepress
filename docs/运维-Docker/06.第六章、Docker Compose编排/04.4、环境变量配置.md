---
title: 4、环境变量配置
---
## 📚 目录

1. [环境变量基础概念](#1-环境变量基础概念)
2. [.env环境文件详解](#2-env环境文件详解)
3. [环境变量替换机制](#3-环境变量替换机制)
4. [多环境配置管理](#4-多环境配置管理)
5. [变量优先级规则](#5-变量优先级规则)
6. [敏感信息处理](#6-敏感信息处理)
7. [环境切换方案](#7-环境切换方案)
8. [实践案例与最佳做法](#8-实践案例与最佳做法)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🌟 环境变量基础概念


### 1.1 什么是环境变量


> 📖 **核心概念**  
> 环境变量就像是给程序传递参数的"便条纸"，可以在不修改代码的情况下改变程序的行为

**💡 生活类比**：
想象你在餐厅点餐，菜谱是固定的（代码），但你可以告诉服务员"不要香菜"、"少放盐"（环境变量），最终得到符合你需求的菜品。

**🔍 Docker中的环境变量作用**：
```
┌─────────────────┐    环境变量    ┌─────────────────┐
│   宿主机系统     │ ──────────> │   Docker容器    │
└─────────────────┘              └─────────────────┘
配置信息、密码等 ──────────> 应用程序读取使用
```

### 1.2 为什么需要环境变量


**传统做法的问题**：
```
❌ 硬编码配置：
- 数据库密码写在代码里
- 不同环境要修改代码
- 敏感信息容易泄露

✅ 环境变量的优势：
- 配置与代码分离
- 不同环境使用不同配置
- 敏感信息更安全
```

**🎯 实际应用场景**：
- 🏠 **开发环境**：连接本地数据库
- 🏢 **测试环境**：连接测试数据库  
- 🌐 **生产环境**：连接生产数据库
- 🔐 **安全需求**：数据库密码、API密钥等

---

## 2. 📄 .env环境文件详解


### 2.1 .env文件的作用


> 💡 **简单理解**  
> .env文件就像一个"配置清单"，把所有需要的环境变量写在一个文件里，Docker Compose会自动读取

**📋 .env文件基本格式**：
```bash
# 这是注释，用#开头
DATABASE_URL=mysql://localhost:3306/myapp
API_KEY=your_secret_key_here
DEBUG=true
PORT=8080
```

### 2.2 .env文件使用规则


**✅ 正确的写法**：
```bash
# 基本格式：变量名=值（不要有空格）
DB_HOST=localhost
DB_PORT=3306
DB_NAME=myapp

# 字符串可以用引号包围
APP_NAME="My Application"
MESSAGE='Hello World'

# 布尔值直接写
ENABLE_DEBUG=true
PRODUCTION_MODE=false
```

**❌ 常见错误**：
```bash
# 错误：等号两边有空格
DB_HOST = localhost

# 错误：变量名包含特殊字符
DB-HOST=localhost

# 错误：注释不在行首
DB_HOST=localhost  # 这是主机地址
```

### 2.3 .env文件位置和命名


**📂 文件位置规则**：
```
project/
├── docker-compose.yml    ← Compose文件
├── .env                  ← 默认环境文件（与compose文件同级）
├── .env.dev             ← 开发环境
├── .env.test            ← 测试环境
└── .env.prod            ← 生产环境
```

**🎯 文件查找顺序**：
1. 当前目录下的 `.env` 文件
2. `docker-compose.yml` 同级目录
3. 指定的自定义环境文件

---

## 3. 🔄 环境变量替换机制


### 3.1 变量替换语法


**基本替换语法**：
```yaml
# docker-compose.yml
services:
  web:
    image: nginx:${NGINX_VERSION}
    ports:
      - "${WEB_PORT}:80"
    environment:
      - DATABASE_URL=${DB_URL}
```

**对应的.env文件**：
```bash
# .env
NGINX_VERSION=1.21
WEB_PORT=8080
DB_URL=postgresql://user:pass@db:5432/myapp
```

### 3.2 高级替换语法


**💫 带默认值的替换**：
```yaml
services:
  app:
    image: myapp:${APP_VERSION:-latest}  # 如果没设置APP_VERSION，默认用latest
    ports:
      - "${PORT:-3000}:3000"            # 默认端口3000
    environment:
      - NODE_ENV=${NODE_ENV:-development}  # 默认开发环境
```

**🔍 变量存在性检查**：
```yaml
services:
  database:
    image: postgres:${POSTGRES_VERSION:?版本号必须设置}
    environment:
      - POSTGRES_PASSWORD=${DB_PASSWORD:?数据库密码不能为空}
```

### 3.3 变量替换实例解析


**示例配置**：
```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    image: nginx:${NGINX_VERSION:-1.21}
    ports:
      - "${WEB_PORT:-80}:80"
    volumes:
      - ./html:/usr/share/nginx/html
    environment:
      - SERVER_NAME=${SERVER_NAME:-localhost}
  
  app:
    build:
      context: .
      dockerfile: Dockerfile.${BUILD_ENV:-dev}
    environment:
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASS}@db:5432/${DB_NAME}
      - REDIS_URL=redis://redis:6379/${REDIS_DB:-0}
```

**对应的.env配置**：
```bash
# .env
NGINX_VERSION=1.21
WEB_PORT=8080
SERVER_NAME=myapp.local

BUILD_ENV=prod
DB_USER=appuser
DB_PASS=secret123
DB_NAME=myapp_db
REDIS_DB=1
```

**🔄 实际替换结果**：
```yaml
# 替换后的效果（仅演示，实际不会生成这个文件）
services:
  web:
    image: nginx:1.21
    ports:
      - "8080:80"
    environment:
      - SERVER_NAME=myapp.local
  
  app:
    build:
      dockerfile: Dockerfile.prod
    environment:
      - DATABASE_URL=postgresql://appuser:secret123@db:5432/myapp_db
      - REDIS_URL=redis://redis:6379/1
```

---

## 4. 🏗️ 多环境配置管理


### 4.1 环境分离策略


**🎯 环境分类**：
- 🟢 **开发环境(dev)**：本地开发使用
- 🟡 **测试环境(test)**：自动化测试
- 🟠 **预发环境(staging)**：生产前验证
- 🔴 **生产环境(prod)**：正式运行

### 4.2 多环境文件组织


**📂 推荐的文件结构**：
```
project/
├── docker-compose.yml           # 基础配置
├── docker-compose.dev.yml       # 开发环境覆盖
├── docker-compose.prod.yml      # 生产环境覆盖
├── .env                         # 默认环境变量
├── envs/
│   ├── .env.dev                # 开发环境变量
│   ├── .env.test               # 测试环境变量
│   ├── .env.staging            # 预发环境变量
│   └── .env.prod               # 生产环境变量（加密存储）
└── scripts/
    ├── dev.sh                  # 开发启动脚本
    ├── test.sh                 # 测试启动脚本
    └── deploy.sh               # 部署脚本
```

### 4.3 环境配置示例


**基础配置 - docker-compose.yml**：
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "${APP_PORT}:3000"
    environment:
      - NODE_ENV=${NODE_ENV}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    depends_on:
      - db
      - redis

  db:
    image: postgres:${POSTGRES_VERSION}
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}

  redis:
    image: redis:${REDIS_VERSION}
```

**开发环境 - envs/.env.dev**：
```bash
# 开发环境配置
NODE_ENV=development
APP_PORT=3000

# 数据库配置（本地）
POSTGRES_VERSION=13
DB_NAME=myapp_dev
DB_USER=devuser
DB_PASSWORD=devpass123
DATABASE_URL=postgresql://devuser:devpass123@db:5432/myapp_dev

# Redis配置
REDIS_VERSION=6
REDIS_URL=redis://redis:6379/0

# 调试模式
DEBUG=true
LOG_LEVEL=debug
```

**生产环境 - envs/.env.prod**：
```bash
# 生产环境配置
NODE_ENV=production
APP_PORT=80

# 数据库配置（生产）
POSTGRES_VERSION=13
DB_NAME=myapp_prod
DB_USER=produser
DB_PASSWORD=complex_secure_password_2023!
DATABASE_URL=postgresql://produser:complex_secure_password_2023!@db:5432/myapp_prod

# Redis配置
REDIS_VERSION=6
REDIS_URL=redis://redis:6379/0

# 生产模式
DEBUG=false
LOG_LEVEL=info
```

### 4.4 环境启动脚本


**开发环境启动脚本 - scripts/dev.sh**：
```bash
#!/bin/bash

echo "🚀 启动开发环境..."

# 指定环境文件
export COMPOSE_FILE=docker-compose.yml
export ENV_FILE=envs/.env.dev

# 使用指定的环境文件启动
docker-compose --env-file $ENV_FILE up --build -d

echo "✅ 开发环境已启动"
echo "📱 应用访问地址: http://localhost:3000"
```

**生产环境部署脚本 - scripts/deploy.sh**：
```bash
#!/bin/bash

echo "🌐 部署到生产环境..."

# 安全检查
if [ ! -f "envs/.env.prod" ]; then
    echo "❌ 生产环境配置文件不存在"
    exit 1
fi

# 指定生产环境文件
export ENV_FILE=envs/.env.prod

# 拉取最新镜像并启动
docker-compose --env-file $ENV_FILE pull
docker-compose --env-file $ENV_FILE up -d --no-build

echo "✅ 生产环境部署完成"
```

---

## 5. ⚖️ 变量优先级规则


### 5.1 优先级排序


> 🎯 **记忆技巧**  
> 优先级从高到低：**直接指定 > Compose文件 > .env文件 > 系统环境**

**📊 完整优先级表**：

| 优先级 | 来源 | 说明 | 示例 |
|--------|------|------|------|
| `🔥 最高` | **Shell环境变量** | 直接在命令行设置 | `PORT=8080 docker-compose up` |
| `⭐ 高` | **Compose文件environment** | 写在docker-compose.yml中 | `environment: - PORT=3000` |
| `💫 中` | **env_file指定文件** | 显式指定的环境文件 | `env_file: - custom.env` |
| `🌟 低` | **.env文件** | 默认环境文件 | `.env`文件中的变量 |
| `🔘 最低` | **系统默认** | 操作系统环境变量 | 系统PATH等 |

### 5.2 优先级测试示例


**环境准备**：
```bash
# 系统环境变量
export APP_PORT=9090

# .env文件
echo "APP_PORT=3000" > .env
echo "APP_NAME=MyApp" > .env
```

**docker-compose.yml**：
```yaml
version: '3.8'
services:
  web:
    image: nginx
    ports:
      - "${APP_PORT}:80"  # 会使用系统环境变量的9090
    environment:
      - PORT=8080         # 直接指定，最高优先级
      - APP_NAME=${APP_NAME}  # 从.env读取MyApp
```

**🧪 测试不同启动方式**：
```bash
# 方式1：使用系统环境变量（APP_PORT=9090）
docker-compose up

# 方式2：临时覆盖（APP_PORT=7000）
APP_PORT=7000 docker-compose up

# 方式3：指定不同env文件
docker-compose --env-file custom.env up
```

### 5.3 优先级实战案例


**复杂优先级场景**：
```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    image: myapp
    environment:
      - DATABASE_HOST=prod-db.example.com  # 直接指定（高优先级）
      - DATABASE_PORT=${DB_PORT}           # 来自环境变量（中优先级）
      - DATABASE_NAME=${DB_NAME:-myapp}    # 有默认值（低优先级）
    env_file:
      - ./configs/app.env                  # 指定文件（中高优先级）
```

**配置文件们**：
```bash
# .env（默认文件）
DB_PORT=5432
DB_NAME=default_db
API_KEY=default_key

# configs/app.env（指定文件）
DB_PORT=3306
API_KEY=app_specific_key
CACHE_SIZE=100MB
```

**🔍 最终生效的配置**：
- `DATABASE_HOST`: prod-db.example.com（直接指定）
- `DATABASE_PORT`: 3306（来自app.env，优先级比.env高）
- `DATABASE_NAME`: default_db（来自.env，因为app.env没有）
- `API_KEY`: app_specific_key（来自app.env）

---

## 6. 🔐 敏感信息处理


### 6.1 敏感信息的识别


**🚨 常见敏感信息类型**：
```
🔑 认证信息：
- 数据库密码
- API密钥和Token
- 用户名密码

🛡️ 系统信息：
- 加密密钥
- 证书文件
- 内部服务地址

💳 业务信息：
- 支付密钥
- 第三方服务密钥
- 客户数据访问凭据
```

### 6.2 Docker Secrets方案


> 💡 **什么是Docker Secrets**  
> Docker Secrets就像银行的保险柜，专门存储敏感信息，只有授权的容器才能访问

**🏗️ Docker Secrets基本用法**：
```yaml
# docker-compose.yml
version: '3.8'

secrets:
  db_password:
    file: ./secrets/db_password.txt    # 从文件读取
  api_key:
    external: true                     # 外部管理的secret
    external_name: prod_api_key

services:
  app:
    image: myapp
    secrets:
      - db_password
      - api_key
    environment:
      - DATABASE_URL=postgresql://user@db:5432/myapp
      # 密码通过secret文件读取，不在环境变量中暴露
```

**📄 Secret文件创建**：
```bash
# 创建secrets目录
mkdir -p secrets

# 创建密码文件
echo "super_secret_password_2023!" > secrets/db_password.txt

# 设置安全权限
chmod 600 secrets/db_password.txt
```

**🔍 容器内Secret访问**：
```bash
# 在容器内，secrets会挂载到/run/secrets/
cat /run/secrets/db_password    # 读取数据库密码
cat /run/secrets/api_key        # 读取API密钥
```

### 6.3 环境变量加密方案


**💎 使用工具加密环境变量**：
```bash
# 使用sops加密env文件
# 安装sops
curl -LO https://github.com/mozilla/sops/releases/download/v3.7.3/sops-v3.7.3.linux

# 创建加密的环境文件
sops -e .env > .env.encrypted

# 解密使用
sops -d .env.encrypted > .env.temp
docker-compose --env-file .env.temp up
rm .env.temp  # 使用后立即删除
```

### 6.4 敏感信息最佳实践


**✅ 推荐做法**：
```bash
# 1. 分离敏感和非敏感配置
# .env.public（可以提交到代码库）
APP_NAME=MyApplication
NODE_ENV=production
LOG_LEVEL=info

# .env.secrets（不提交到代码库，单独管理）
DATABASE_PASSWORD=secret_password
API_KEY=sensitive_api_key
JWT_SECRET=jwt_signing_key
```

**🛡️ 安全措施检查清单**：
```
📋 敏感信息安全检查：
- [ ] .env.secrets 文件已添加到 .gitignore
- [ ] 生产环境使用 Docker Secrets
- [ ] 开发环境使用模拟数据
- [ ] 定期轮换密码和密钥
- [ ] 限制文件访问权限（chmod 600）
- [ ] 使用环境变量而非硬编码
- [ ] 日志中不记录敏感信息
```

**❌ 避免的危险做法**：
```bash
# ❌ 危险：敏感信息直接写在compose文件中
services:
  app:
    environment:
      - DATABASE_PASSWORD=secret123  # 会暴露在代码库中

# ❌ 危险：敏感信息在构建过程中暴露
RUN echo "API_KEY=secret" > /app/config  # 会保存在镜像层中

# ❌ 危险：敏感信息在日志中输出
echo "连接数据库：$DATABASE_URL"  # 密码会出现在日志中
```

---

## 7. 🔄 环境切换方案


### 7.1 基于脚本的切换方案


**🎯 核心思路**：为每个环境创建专门的启动脚本，一键切换环境

**📂 脚本文件结构**：
```
project/
├── scripts/
│   ├── switch-env.sh      # 环境切换主脚本
│   ├── start-dev.sh       # 开发环境启动
│   ├── start-test.sh      # 测试环境启动  
│   └── start-prod.sh      # 生产环境启动
├── envs/
│   ├── dev.env
│   ├── test.env
│   └── prod.env
└── docker-compose.yml
```

**🔧 环境切换主脚本**：
```bash
#!/bin/bash
# scripts/switch-env.sh

ENV=$1

if [ -z "$ENV" ]; then
    echo "❌ 请指定环境：dev, test, prod"
    echo "用法: ./switch-env.sh dev"
    exit 1
fi

# 检查环境配置文件是否存在
ENV_FILE="envs/${ENV}.env"
if [ ! -f "$ENV_FILE" ]; then
    echo "❌ 环境配置文件不存在: $ENV_FILE"
    exit 1
fi

echo "🔄 切换到 $ENV 环境..."

# 停止当前服务
docker-compose down

# 启动指定环境
docker-compose --env-file $ENV_FILE up -d --build

echo "✅ $ENV 环境已启动"
case $ENV in
    "dev")
        echo "🚀 开发环境: http://localhost:3000"
        ;;
    "test")
        echo "🧪 测试环境: http://localhost:3001"
        ;;
    "prod")
        echo "🌐 生产环境: http://localhost"
        ;;
esac
```

### 7.2 Make工具方案


**📄 Makefile配置**：
```makefile
# Makefile

# 默认环境
ENV ?= dev

# 环境文件路径
ENV_FILE = envs/$(ENV).env

.PHONY: help dev test prod stop clean

help:
	@echo "🚀 Docker Compose 环境管理"
	@echo ""
	@echo "可用命令："
	@echo "  make dev     - 启动开发环境"
	@echo "  make test    - 启动测试环境"  
	@echo "  make prod    - 启动生产环境"
	@echo "  make stop    - 停止所有服务"
	@echo "  make clean   - 清理所有容器和镜像"

dev:
	@echo "🔧 启动开发环境..."
	@docker-compose --env-file envs/dev.env up -d --build
	@echo "✅ 开发环境已启动: http://localhost:3000"

test:
	@echo "🧪 启动测试环境..."
	@docker-compose --env-file envs/test.env up -d --build
	@echo "✅ 测试环境已启动: http://localhost:3001"

prod:
	@echo "🌐 启动生产环境..."
	@docker-compose --env-file envs/prod.env up -d --no-build
	@echo "✅ 生产环境已启动: http://localhost"

stop:
	@echo "🛑 停止所有服务..."
	@docker-compose down
	@echo "✅ 所有服务已停止"

clean:
	@echo "🧹 清理容器和镜像..."
	@docker-compose down --volumes --remove-orphans
	@docker system prune -f
	@echo "✅ 清理完成"
```

**🎮 使用方式**：
```bash
# 查看帮助
make help

# 启动不同环境
make dev      # 开发环境
make test     # 测试环境
make prod     # 生产环境

# 管理服务
make stop     # 停止服务
make clean    # 清理环境
```

### 7.3 配置模板方案


**🎯 模板思路**：使用模板文件 + 变量替换，动态生成配置

**📄 配置模板文件 - docker-compose.template.yml**：
```yaml
version: '3.8'
services:
  app:
    image: myapp:{{APP_VERSION}}
    ports:
      - "{{APP_PORT}}:3000"
    environment:
      - NODE_ENV={{NODE_ENV}}
      - DATABASE_URL={{DATABASE_URL}}
      - REDIS_URL={{REDIS_URL}}
      - LOG_LEVEL={{LOG_LEVEL}}
    
  db:
    image: postgres:{{POSTGRES_VERSION}}
    environment:
      - POSTGRES_DB={{DB_NAME}}
      - POSTGRES_USER={{DB_USER}}
      - POSTGRES_PASSWORD={{DB_PASSWORD}}
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

**🔧 模板处理脚本**：
```bash
#!/bin/bash
# scripts/generate-compose.sh

ENV=${1:-dev}
TEMPLATE_FILE="docker-compose.template.yml"
OUTPUT_FILE="docker-compose.generated.yml"
ENV_FILE="envs/${ENV}.env"

echo "📝 生成 $ENV 环境的compose配置..."

# 读取环境变量
source $ENV_FILE

# 替换模板中的变量
sed -e "s/{{APP_VERSION}}/$APP_VERSION/g" \
    -e "s/{{APP_PORT}}/$APP_PORT/g" \
    -e "s/{{NODE_ENV}}/$NODE_ENV/g" \
    -e "s|{{DATABASE_URL}}|$DATABASE_URL|g" \
    -e "s|{{REDIS_URL}}|$REDIS_URL|g" \
    -e "s/{{LOG_LEVEL}}/$LOG_LEVEL/g" \
    -e "s/{{POSTGRES_VERSION}}/$POSTGRES_VERSION/g" \
    -e "s/{{DB_NAME}}/$DB_NAME/g" \
    -e "s/{{DB_USER}}/$DB_USER/g" \
    -e "s/{{DB_PASSWORD}}/$DB_PASSWORD/g" \
    $TEMPLATE_FILE > $OUTPUT_FILE

echo "✅ 配置文件已生成: $OUTPUT_FILE"

# 启动服务
docker-compose -f $OUTPUT_FILE up -d --build

# 清理生成的文件
rm $OUTPUT_FILE
```

---

## 8. 🎯 实践案例与最佳做法


### 8.1 完整Web应用案例


**🏗️ 项目结构**：
```
mywebapp/
├── docker-compose.yml
├── docker-compose.override.yml
├── .env.example
├── .gitignore
├── app/
│   ├── Dockerfile
│   └── src/
├── nginx/
│   └── nginx.conf
└── configs/
    ├── dev/
    │   ├── .env
    │   └── nginx.dev.conf
    ├── test/
    │   └── .env
    └── prod/
        ├── .env.encrypted
        └── nginx.prod.conf
```

**📄 主配置文件 - docker-compose.yml**：
```yaml
version: '3.8'

services:
  nginx:
    image: nginx:${NGINX_VERSION:-1.21}
    ports:
      - "${HTTP_PORT:-80}:80"
      - "${HTTPS_PORT:-443}:443"
    volumes:
      - ./nginx/nginx.${ENV:-dev}.conf:/etc/nginx/nginx.conf
      - static_files:/var/www/static
    depends_on:
      - app
    networks:
      - frontend
      - backend

  app:
    build:
      context: ./app
      target: ${BUILD_TARGET:-development}
    environment:
      - NODE_ENV=${NODE_ENV:-development}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - JWT_SECRET=${JWT_SECRET}
      - UPLOAD_PATH=/app/uploads
    volumes:
      - ./app:/app
      - static_files:/app/static
      - uploads:/app/uploads
    depends_on:
      - db
      - redis
    networks:
      - backend

  db:
    image: postgres:${POSTGRES_VERSION:-13}
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./db/init:/docker-entrypoint-initdb.d
    networks:
      - backend
    # 生产环境不暴露数据库端口
    ports:
      - "${DB_PORT:-5432}:5432"

  redis:
    image: redis:${REDIS_VERSION:-6}
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - backend

volumes:
  db_data:
  redis_data:
  static_files:
  uploads:

networks:
  frontend:
  backend:
```

**🔧 开发环境配置 - configs/dev/.env**：
```bash
# 开发环境配置
ENV=dev
NODE_ENV=development
BUILD_TARGET=development

# 服务版本
NGINX_VERSION=1.21
POSTGRES_VERSION=13
REDIS_VERSION=6

# 端口配置
HTTP_PORT=3000
HTTPS_PORT=3443
DB_PORT=5432

# 数据库配置
DB_NAME=mywebapp_dev
DB_USER=devuser
DB_PASSWORD=devpass123
DATABASE_URL=postgresql://devuser:devpass123@db:5432/mywebapp_dev

# Redis配置
REDIS_PASSWORD=redis_dev_pass
REDIS_URL=redis://:redis_dev_pass@redis:6379/0

# JWT配置（开发环境使用固定密钥）
JWT_SECRET=dev_jwt_secret_key_not_for_production

# 调试配置
DEBUG=true
LOG_LEVEL=debug
```

**🌐 生产环境配置 - configs/prod/.env**：
```bash
# 生产环境配置
ENV=prod
NODE_ENV=production
BUILD_TARGET=production

# 服务版本
NGINX_VERSION=1.21
POSTGRES_VERSION=13
REDIS_VERSION=6

# 端口配置
HTTP_PORT=80
HTTPS_PORT=443
# 生产环境不暴露数据库端口
# DB_PORT=5432

# 数据库配置（敏感信息）
DB_NAME=mywebapp_prod
DB_USER=produser
DB_PASSWORD=complex_secure_password_2023!
DATABASE_URL=postgresql://produser:complex_secure_password_2023!@db:5432/mywebapp_prod

# Redis配置
REDIS_PASSWORD=redis_prod_complex_pass_2023!
REDIS_URL=redis://:redis_prod_complex_pass_2023!@redis:6379/0

# JWT配置（生产环境使用复杂密钥）
JWT_SECRET=prod_jwt_very_complex_secret_key_2023_do_not_share!

# 生产配置
DEBUG=false
LOG_LEVEL=warn
```

### 8.2 最佳实践总结


**🎯 配置管理最佳实践**：

```
✅ DO 推荐做法：

📂 文件组织：
- 将环境文件按环境分类存放
- 使用 .env.example 提供配置模板
- 敏感文件不提交到代码库

🔐 安全管理：
- 生产环境使用 Docker Secrets
- 敏感信息单独存储和管理
- 定期轮换密码和密钥

🔄 环境切换：
- 提供简单的脚本或Makefile
- 支持一键环境切换
- 环境间配置差异最小化

📋 配置验证：
- 使用默认值避免配置缺失
- 关键配置使用 :? 语法强制检查
- 启动前验证配置完整性
```

**❌ 避免的常见问题**：

```
❌ DON'T 错误做法：

🚫 配置混乱：
- 敏感信息直接写在compose文件
- 不同环境使用同一配置文件
- 配置文件结构不清晰

🚫 安全问题：
- .env文件提交到代码库
- 密码使用简单字符串
- 日志中输出敏感信息

🚫 维护困难：
- 配置项命名不规范
- 缺少配置说明文档
- 环境切换步骤复杂
```

**📋 配置检查清单**：
```
🔍 上线前检查：
- [ ] 所有必需的环境变量已配置
- [ ] 敏感信息未暴露在代码中
- [ ] 生产环境配置已加密存储
- [ ] 数据库连接字符串正确
- [ ] 端口映射无冲突
- [ ] 网络配置正确
- [ ] 存储卷配置恰当
- [ ] 日志级别适合环境
- [ ] 性能参数已优化
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 环境变量本质：配置与代码分离的参数传递机制
🔸 .env文件作用：集中管理环境变量的配置文件
🔸 变量替换语法：${VAR}、${VAR:-default}、${VAR:?error}
🔸 优先级规则：Shell环境 > Compose文件 > env_file > .env > 系统默认
🔸 多环境管理：开发、测试、生产环境的配置分离
🔸 安全处理：敏感信息使用Secrets或加密存储
🔸 切换方案：脚本化的环境切换和部署流程
```

### 9.2 关键理解要点


**🔹 环境变量的核心价值**：
```
灵活性：同一份代码适应不同环境
安全性：敏感信息与代码分离
可维护性：配置集中管理便于修改
可移植性：容器化应用的标准配置方案
```

**🔹 配置管理的关键原则**：
```
分离原则：配置与代码彻底分离
最小权限：只提供必需的配置访问
环境一致：确保配置在各环境的一致性
安全优先：敏感信息的安全处理
```

**🔹 多环境管理的核心思维**：
```
标准化：统一的配置文件格式和命名
差异化：不同环境的特定配置
自动化：一键切换和部署流程
监控化：配置变更的审计和跟踪
```

### 9.3 实际应用价值


**💼 开发场景应用**：
- **本地开发**：快速切换数据库连接、调试模式
- **团队协作**：统一的开发环境配置标准
- **CI/CD流程**：自动化测试和部署配置
- **容器化部署**：云原生应用的标准配置方案

**🎯 生产实践价值**：
- **运维管理**：简化配置管理和环境切换
- **安全保障**：敏感信息的安全存储和访问
- **故障排查**：通过配置快速定位问题
- **扩展性**：支持应用的水平扩展和配置调优

**🧠 核心记忆口诀**：
- 环境变量配置分离，.env文件统一管理
- 变量替换有语法，优先级别要记牢  
- 多环境分类存放，安全信息单独藏
- 脚本切换很方便，最佳实践保平安