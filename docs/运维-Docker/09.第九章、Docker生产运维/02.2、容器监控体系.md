---
title: 2、容器监控体系
---
## 📚 目录

1. [容器监控基础概念](#1-容器监控基础概念)
2. [容器资源监控](#2-容器资源监控)
3. [Prometheus监控体系](#3-prometheus监控体系)
4. [Grafana可视化仪表板](#4-grafana可视化仪表板)
5. [cAdvisor资源监控](#5-cadvisor资源监控)
6. [告警机制配置](#6-告警机制配置)
7. [监控数据存储策略](#7-监控数据存储策略)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔍 容器监控基础概念


### 1.1 什么是容器监控


> **💡 核心理解**
> 容器监控就像给每个容器安装"健康体检仪"，实时监测它们的运行状态、资源使用情况和性能表现

**🎯 监控的本质**：
```
传统服务器监控：
主机 → 进程 → 应用

容器化监控：
主机 → 容器 → 应用服务
  ↓      ↓       ↓
 物理   虚拟化   微服务
```

**为什么需要容器监控**：
- **资源可见性**：容器内部资源使用情况外部不可见
- **动态特性**：容器随时创建、销毁，需要实时跟踪
- **微服务复杂性**：多个容器协同工作，需要整体监控
- **故障快速定位**：问题出现时能快速找到根源

### 1.2 容器监控的挑战


**🚨 主要难点**：

| 挑战 | 传统监控 | 容器监控 |
|------|---------|---------|
| **对象生命周期** | 服务器长期运行 | 容器频繁创建销毁 |
| **网络复杂性** | 固定IP地址 | 动态分配，网络隔离 |
| **资源共享** | 独占资源 | 共享主机资源 |
| **数据持久性** | 数据本地存储 | 容器数据易丢失 |

**💭 实际场景理解**：
```
就像监控一个快递站：
- 传统监控：固定门店，人员稳定
- 容器监控：流动摊位，人员随时换岗

需要知道：
✓ 每个摊位的货物数量（资源使用）
✓ 工作人员的效率（性能指标）  
✓ 客户满意度（服务质量）
✓ 整体运营状况（集群健康）
```

---

## 2. 📊 容器资源监控


### 2.1 核心监控指标


**🎯 CPU监控指标**：
```
CPU使用率计算逻辑：
容器CPU时间 / 系统CPU时间 × 100%

关键指标：
• cpu_usage_percent：CPU使用百分比
• cpu_user：用户态CPU时间  
• cpu_system：系统态CPU时间
• cpu_throttled：CPU被限流次数
```

**💾 内存监控指标**：
```
内存使用情况：
┌─────────────────┐
│   总分配内存     │ ← memory_limit
├─────────────────┤
│   实际使用内存   │ ← memory_usage
├─────────────────┤  
│   缓存内存      │ ← memory_cache
├─────────────────┤
│   可用内存      │ ← memory_available
└─────────────────┘

重要概念：
• RSS：物理内存使用量
• Cache：页缓存大小
• Swap：交换空间使用
```

**🗄️ 磁盘I/O监控**：
```
磁盘性能指标：
• disk_read_bytes：读取字节数
• disk_write_bytes：写入字节数
• disk_read_ops：读操作次数
• disk_write_ops：写操作次数
• disk_io_wait：I/O等待时间
```

**🌐 网络监控指标**：
```
网络流量统计：
容器网卡 → 网桥 → 主机网卡

监控点：
• network_rx_bytes：接收字节数
• network_tx_bytes：发送字节数
• network_rx_packets：接收包数
• network_tx_packets：发送包数
• network_errors：网络错误数
```

### 2.2 Docker原生监控命令


**📋 快速查看工具**：

```bash
# 查看容器实时资源使用
docker stats

# 显示结果示例：
CONTAINER ID   NAME     CPU %   MEM USAGE/LIMIT   MEM %   NET I/O       BLOCK I/O
a1b2c3d4e5f6   webapp   2.5%    256MB/1GB        25.6%   1.2MB/856KB   12MB/0B
```

**🔧 详细监控脚本**：
```bash
#!/bin/bash
# 容器资源监控脚本

# 获取所有运行中的容器
containers=$(docker ps --format "{{.Names}}")

for container in $containers; do
    echo "=== $container 监控数据 ==="
    
    # CPU和内存使用
    docker stats --no-stream --format \
    "CPU: {{.CPUPerc}} | 内存: {{.MemUsage}} ({{.MemPerc}})" $container
    
    # 磁盘使用
    docker exec $container df -h 2>/dev/null || echo "无法获取磁盘信息"
    
    echo "---"
done
```

---

## 3. 🎛️ Prometheus监控体系


### 3.1 Prometheus基础概念


> **💡 核心理解**  
> Prometheus就像一个"数据收集员"，定时去各个容器那里"收集报表"，然后存储起来供后续分析使用

**🏗️ Prometheus架构**：
```
监控目标 ←--pull--- Prometheus Server ---→ Grafana展示
   ↓                      ↓                    ↑
容器指标              时序数据库          AlertManager
cAdvisor               存储引擎              告警通知
Node Exporter           查询引擎               
```

**⚡ 工作原理**：
1. **数据采集**：定时从目标拉取监控数据
2. **数据存储**：将指标存储到时序数据库
3. **规则评估**：根据配置的规则检查异常
4. **告警触发**：发现问题时发送告警通知

### 3.2 Prometheus配置详解


**📝 主配置文件**：
```yaml
# prometheus.yml
global:
  scrape_interval: 15s     # 采集间隔
  evaluation_interval: 15s # 规则评估间隔

# 告警管理器配置
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - "alertmanager:9093"

# 采集任务配置
scrape_configs:
  # Prometheus自监控
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # 容器监控(cAdvisor)
  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']

  # 主机监控
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
```

**🚀 部署Prometheus**：
```yaml
# docker-compose.yml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.enable-lifecycle'

volumes:
  prometheus_data:
```

### 3.3 关键监控指标查询


**📈 常用PromQL查询**：

```promql
# CPU使用率
rate(container_cpu_usage_seconds_total[5m]) * 100

# 内存使用率  
container_memory_usage_bytes / container_spec_memory_limit_bytes * 100

# 磁盘I/O速率
rate(container_fs_reads_bytes_total[5m])
rate(container_fs_writes_bytes_total[5m])

# 网络流量
rate(container_network_receive_bytes_total[5m])
rate(container_network_transmit_bytes_total[5m])
```

**🔍 实用查询示例**：
```promql
# 查找CPU使用率最高的容器
topk(5, rate(container_cpu_usage_seconds_total[5m]) * 100)

# 内存使用量超过80%的容器
container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.8

# 网络异常的容器
increase(container_network_receive_errors_total[5m]) > 0
```

---

## 4. 📈 Grafana可视化仪表板


### 4.1 Grafana基础配置


**🎨 什么是Grafana**：
```
Grafana = 数据可视化平台
就像把枯燥的数字变成漂亮的图表：

原始数据：cpu_usage=75%, memory_usage=2.1GB
可视化后：
┌─────────────────────────┐
│  📊 CPU使用率           │
│  ████████████░░░░░      │ 75%
│                         │
│  📊 内存使用率           │  
│  ██████████████████░░   │ 2.1GB/4GB
└─────────────────────────┘
```

**🚀 Grafana部署配置**：
```yaml
# docker-compose.yml 添加
grafana:
  image: grafana/grafana:latest
  container_name: grafana
  ports:
    - "3000:3000"
  environment:
    - GF_SECURITY_ADMIN_PASSWORD=admin123
  volumes:
    - grafana_data:/var/lib/grafana
  depends_on:
    - prometheus
```

### 4.2 创建容器监控仪表板


**📊 核心面板配置**：

| 面板类型 | 监控对象 | 查询语句 | 显示方式 |
|---------|---------|----------|----------|
| **CPU面板** | 容器CPU使用率 | `rate(container_cpu_usage_seconds_total[5m]) * 100` | 时间序列图 |
| **内存面板** | 内存使用情况 | `container_memory_usage_bytes` | 仪表盘 |
| **网络面板** | 网络流量 | `rate(container_network_receive_bytes_total[5m])` | 面积图 |
| **磁盘面板** | 磁盘I/O | `rate(container_fs_reads_bytes_total[5m])` | 柱状图 |

**🎯 实用仪表板模板**：
```json
{
  "dashboard": {
    "title": "Docker容器监控",
    "panels": [
      {
        "title": "容器CPU使用率",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(container_cpu_usage_seconds_total{name!=\"\"}[5m]) * 100",
            "legendFormat": "{{name}}"
          }
        ]
      }
    ]
  }
}
```

### 4.3 告警面板配置


**🚨 关键告警指标**：

> **⚠️ 告警阈值建议**
> - CPU使用率 > 80%：需要关注
> - 内存使用率 > 85%：需要扩容
> - 磁盘使用率 > 90%：紧急处理
> - 容器重启次数 > 5次/小时：异常排查

```yaml
# 告警规则示例
groups:
  - name: container_alerts
    rules:
      - alert: ContainerHighCPU
        expr: rate(container_cpu_usage_seconds_total[5m]) * 100 > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "容器CPU使用率过高"
          description: "容器 {{ $labels.name }} CPU使用率达到 {{ $value }}%"
```

---

## 5. 🔬 cAdvisor资源监控


### 5.1 cAdvisor核心功能


**🎯 cAdvisor是什么**：
```
cAdvisor = Container Advisor (容器顾问)
Google开源的容器监控工具

作用：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Docker    │───▶│  cAdvisor   │───▶│ Prometheus  │
│   容器      │    │  数据采集   │    │  数据存储   │
└─────────────┘    └─────────────┘    └─────────────┘

就像给每个容器配个"健康监测仪"
```

**⚡ 监控能力**：
- **资源使用情况**：CPU、内存、网络、磁盘
- **性能指标**：延迟、吞吐量、错误率
- **容器信息**：镜像、启动时间、重启次数
- **主机信息**：系统负载、文件系统使用

### 5.2 cAdvisor部署配置


**🚀 快速部署**：
```bash
# 单独运行cAdvisor
docker run \
  --volume=/:/rootfs:ro \
  --volume=/var/run:/var/run:ro \
  --volume=/sys:/sys:ro \
  --volume=/var/lib/docker/:/var/lib/docker:ro \
  --volume=/dev/disk/:/dev/disk:ro \
  --publish=8080:8080 \
  --detach=true \
  --name=cadvisor \
  gcr.io/cadvisor/cadvisor:latest
```

**🎛️ Docker Compose配置**：
```yaml
services:
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: cadvisor
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    privileged: true
    devices:
      - /dev/kmsg
```

### 5.3 cAdvisor指标解读


**📊 关键指标含义**：

```
container_cpu_usage_seconds_total
└── 容器累计CPU使用时间(秒)
    计算使用率：rate(container_cpu_usage_seconds_total[5m]) * 100

container_memory_usage_bytes  
└── 容器内存使用字节数
    包含：应用内存 + 缓存 + 缓冲区

container_fs_reads_bytes_total
└── 容器累计磁盘读取字节数
    计算读取速率：rate(container_fs_reads_bytes_total[5m])

container_network_receive_bytes_total
└── 容器累计网络接收字节数
    计算接收速率：rate(container_network_receive_bytes_total[5m])
```

**🔍 实用查询技巧**：
```bash
# 访问cAdvisor Web界面
http://localhost:8080

# 查看特定容器指标
http://localhost:8080/containers/docker/{container_id}

# 获取JSON格式数据
curl http://localhost:8080/api/v1.3/containers/
```

---

## 6. 🚨 告警机制配置


### 6.1 AlertManager告警配置


**📢 告警流程**：
```
监控指标异常 → Prometheus规则评估 → AlertManager处理 → 发送通知

告警生命周期：
Inactive → Pending → Firing → Resolved
   ↓        ↓        ↓        ↓
正常状态   等待确认   正在告警   问题解决
```

**⚙️ AlertManager配置**：
```yaml
# alertmanager.yml
global:
  smtp_smarthost: 'localhost:587'
  smtp_from: 'alertmanager@example.org'

route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'

receivers:
- name: 'web.hook'
  email_configs:
  - to: 'admin@example.org'
    subject: '[ALERT] {{ .GroupLabels.alertname }}'
    body: |
      告警详情:
      {{ range .Alerts }}
      - 告警: {{ .Annotations.summary }}
      - 描述: {{ .Annotations.description }}
      - 时间: {{ .StartsAt }}
      {{ end }}
```

### 6.2 容器告警规则


**📋 关键告警规则**：

```yaml
# container_alerts.yml
groups:
- name: container_alerts
  rules:
  # CPU告警
  - alert: ContainerHighCPU
    expr: rate(container_cpu_usage_seconds_total{name!=""}[5m]) * 100 > 80
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "容器CPU使用率告警"
      description: "容器 {{ $labels.name }} CPU使用率已达到 {{ $value }}%，持续2分钟以上"

  # 内存告警  
  - alert: ContainerHighMemory
    expr: container_memory_usage_bytes{name!=""} / container_spec_memory_limit_bytes > 0.85
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "容器内存使用率告警"
      description: "容器 {{ $labels.name }} 内存使用率超过85%"

  # 容器重启告警
  - alert: ContainerRestarting
    expr: increase(container_start_time_seconds{name!=""}[1h]) > 5
    for: 0m
    labels:
      severity: warning
    annotations:
      summary: "容器频繁重启告警" 
      description: "容器 {{ $labels.name }} 在过去1小时内重启了 {{ $value }} 次"

  # 磁盘空间告警
  - alert: ContainerDiskSpaceLow
    expr: container_fs_usage_bytes{name!=""} / container_fs_limit_bytes > 0.9
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "容器磁盘空间不足"
      description: "容器 {{ $labels.name }} 磁盘使用率超过90%"
```

### 6.3 多渠道告警通知


**📱 告警通知方式**：

| 通知方式 | 适用场景 | 配置示例 |
|---------|---------|----------|
| **邮件通知** | 非紧急告警，详细信息 | SMTP配置 |
| **Slack通知** | 团队协作，实时消息 | Webhook URL |
| **短信通知** | 紧急故障，立即响应 | 第三方API |
| **钉钉/企微** | 企业内部，移动办公 | 机器人Webhook |

```yaml
# 多渠道通知配置
receivers:
- name: 'critical-alerts'
  email_configs:
  - to: 'ops-team@company.com'
  slack_configs:
  - api_url: 'https://hooks.slack.com/services/...'
    channel: '#alerts'
    title: '🚨 紧急告警'
    text: '{{ .CommonAnnotations.summary }}'

- name: 'warning-alerts'  
  email_configs:
  - to: 'dev-team@company.com'
```

---

## 7. 💾 监控数据存储策略


### 7.1 数据存储规划


**📊 数据量估算**：
```
假设监控规模：
- 容器数量：100个
- 监控指标：50个/容器
- 采集频率：15秒/次
- 数据保留：30天

计算过程：
100容器 × 50指标 × (86400秒/15秒) × 30天 = 8.64亿个数据点
预估存储：约10-20GB (取决于压缩率)
```

**🗄️ 存储策略设计**：
```
数据分层存储：
┌─────────────────────┐
│  实时数据 (1-7天)   │ ← 高频访问，SSD存储
├─────────────────────┤
│  历史数据 (7-30天)  │ ← 中频访问，普通磁盘  
├─────────────────────┤
│  归档数据 (30天+)   │ ← 低频访问，对象存储
└─────────────────────┘
```

### 7.2 Prometheus存储配置


**⚙️ 存储优化配置**：
```yaml
# prometheus.yml 存储相关配置
global:
  scrape_interval: 15s
  
# 存储配置
storage:
  tsdb:
    retention.time: 30d        # 数据保留30天
    retention.size: 50GB       # 最大存储50GB
    wal-compression: true      # 启用WAL压缩
    
# 远程存储配置(可选)
remote_write:
  - url: "http://remote-storage:9201/write"
    queue_config:
      max_samples_per_send: 1000
      batch_send_deadline: 5s
```

**📈 存储性能优化**：
```bash
# 存储目录权限配置
mkdir -p /data/prometheus
chown -R 65534:65534 /data/prometheus

# 存储性能调优
echo 'vm.max_map_count = 262144' >> /etc/sysctl.conf
sysctl -p
```

### 7.3 数据备份与恢复


**💾 备份策略**：
```bash
#!/bin/bash
# Prometheus数据备份脚本

BACKUP_DIR="/backup/prometheus"
DATA_DIR="/data/prometheus"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 停止数据写入（可选）
curl -X POST http://localhost:9090/api/v1/admin/tsdb/snapshot

# 压缩备份
tar -czf $BACKUP_DIR/prometheus_backup_$DATE.tar.gz -C $DATA_DIR .

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "prometheus_backup_*.tar.gz" -mtime +7 -delete

echo "备份完成: prometheus_backup_$DATE.tar.gz"
```

**🔄 数据恢复流程**：
```bash
# 恢复数据步骤
# 1. 停止Prometheus服务
docker stop prometheus

# 2. 恢复数据
tar -xzf prometheus_backup_20231201_120000.tar.gz -C /data/prometheus/

# 3. 修复权限
chown -R 65534:65534 /data/prometheus

# 4. 重启服务
docker start prometheus
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


> **🎯 监控体系核心**
> 容器监控 = 数据采集(cAdvisor) + 数据存储(Prometheus) + 数据展示(Grafana) + 告警通知(AlertManager)

```
🔸 容器监控：实时掌握容器资源使用和性能状态
🔸 Prometheus：时序数据库，负责存储和查询监控数据  
🔸 Grafana：可视化平台，将数据转化为直观图表
🔸 cAdvisor：容器数据采集器，Google开源监控工具
🔸 告警机制：异常检测和通知，保障系统稳定运行
🔸 数据存储：合理规划存储策略，平衡性能和成本
```

### 8.2 关键理解要点


**🔹 监控指标的重要性**：
```
四个维度监控：
• CPU：计算资源使用情况
• 内存：应用运行内存需求  
• 磁盘：I/O性能和存储使用
• 网络：服务间通信和外部访问
```

**🔹 监控数据的价值**：
```
实时监控 → 发现问题 → 快速响应 → 避免故障
历史数据 → 趋势分析 → 容量规划 → 优化决策  
告警通知 → 主动感知 → 及时处理 → 提升可用性
```

**🔹 工具链协作关系**：
```
数据流向：
容器 → cAdvisor → Prometheus → Grafana → 用户
        ↓          ↓           ↓
     采集数据    存储数据     展示数据

告警流向：
Prometheus → AlertManager → 通知渠道 → 运维人员
          ↓               ↓           ↓
       规则评估        告警处理     问题响应
```

### 8.3 实践指导原则


**📋 部署建议**：
- **分步实施**：先部署基础监控，再逐步完善
- **指标选择**：关注核心指标，避免过度监控
- **告警调优**：合理设置阈值，减少误报干扰
- **数据治理**：规划存储策略，控制成本增长

**🔧 运维实践**：
```bash
# 监控健康检查脚本
#!/bin/bash
check_monitoring_health() {
    # 检查Prometheus
    curl -s http://localhost:9090/api/v1/query?query=up | grep -q "success"
    
    # 检查Grafana  
    curl -s http://localhost:3000/api/health | grep -q "ok"
    
    # 检查cAdvisor
    curl -s http://localhost:8080/healthz | grep -q "ok"
    
    echo "监控系统健康状态：正常"
}
```

### 8.4 学习路径建议


**🚀 进阶学习**：
1. **基础阶段**：掌握Docker基本监控命令
2. **工具阶段**：学会部署Prometheus+Grafana
3. **配置阶段**：编写监控规则和告警配置  
4. **优化阶段**：性能调优和高级配置
5. **实战阶段**：生产环境监控体系设计

**📚 扩展知识**：
- **日志监控**：ELK Stack集成
- **链路追踪**：Jaeger分布式追踪
- **应用监控**：APM工具使用
- **云原生监控**：Kubernetes监控体系

**核心记忆**：
- 监控数据四维度：CPU、内存、磁盘、网络  
- 监控工具四件套：cAdvisor、Prometheus、Grafana、AlertManager
- 数据处理四步骤：采集、存储、展示、告警
- 运维保障四要素：实时、历史、预警、响应