---
title: 4、Docker核心对象
---
## 📚 目录

1. [Docker核心对象概述](#1-Docker核心对象概述)
2. [镜像Images详解](#2-镜像Images详解)
3. [容器Containers详解](#3-容器Containers详解)
4. [仓库Registry详解](#4-仓库Registry详解)
5. [数据卷Volume详解](#5-数据卷Volume详解)
6. [网络Network详解](#6-网络Network详解)
7. [对象间关系理解](#7-对象间关系理解)
8. [Docker生态系统](#8-Docker生态系统)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🏗️ Docker核心对象概述


### 1.1 什么是Docker核心对象


**简单理解**：Docker核心对象就像是搭积木的基本组件，每个组件都有自己的作用，组合在一起就能构建出完整的应用系统。

**五大核心对象**：
- **镜像（Images）**：应用程序的"模板"，像是软件安装包
- **容器（Containers）**：运行中的应用实例，像是正在运行的程序
- **仓库（Registry）**：存储镜像的"仓库"，像是应用商店
- **数据卷（Volume）**：数据存储空间，像是外接硬盘
- **网络（Network）**：容器之间的通信桥梁，像是网线连接

### 1.2 对象关系概览


```
Docker生态系统架构图：

        🌐 Docker Registry (仓库)
              ↓ pull/push
         📦 Images (镜像)
              ↓ run
    🏃 Containers (容器) ←→ 🔗 Networks (网络)
              ↓ mount
         💾 Volumes (数据卷)

关系说明：
• 从仓库下载镜像 → 基于镜像创建容器
• 容器通过网络互相通信
• 容器挂载数据卷持久化数据
```

> 💡 **新手提示**  
> 可以把Docker想象成一个虚拟的"软件工厂"：镜像是生产图纸，容器是生产出的产品，仓库是图纸库，数据卷是仓库空间，网络是产品间的通信线路。

---

## 2. 📦 镜像Images详解


### 2.1 镜像的本质概念


**通俗理解**：镜像就像是一个"软件安装包"，里面打包了运行应用程序所需要的一切：代码、运行环境、系统工具、库文件等。

**镜像的特点**：
- **只读性**：镜像一旦创建就不能修改，保证了一致性
- **分层存储**：像千层蛋糕一样，一层层叠加构建
- **可复用性**：一个镜像可以创建无数个容器
- **轻量化**：相比虚拟机镜像，体积小很多

### 2.2 镜像的分层结构


```
镜像分层示例（以Ubuntu + Node.js应用为例）：

┌─────────────────────────┐ ← 应用层：你的Node.js代码
│     App Layer           │
├─────────────────────────┤ ← Node.js层：Node.js运行环境  
│     Node.js Layer       │
├─────────────────────────┤ ← 系统层：Ubuntu基础系统
│     Ubuntu Base Layer   │
└─────────────────────────┘ ← 内核层：共享宿主机内核

优势：
✅ 层级复用：多个镜像可共享相同的基础层
✅ 增量更新：只需更新变化的层
✅ 存储高效：相同的层只存储一份
```

### 2.3 镜像的基本操作


**查看本地镜像**：
```bash
# 列出所有镜像
docker images

# 查看镜像详细信息
docker inspect <镜像名>
```

**镜像获取与管理**：
```bash
# 从仓库拉取镜像
docker pull nginx:latest

# 删除镜像
docker rmi <镜像ID>

# 构建自定义镜像
docker build -t myapp:1.0 .
```

> ⚠️ **注意事项**  
> 镜像名称格式：`仓库名/镜像名:标签`，如 `nginx:latest`、`mysql:8.0`

### 2.4 镜像标签的含义


| 标签类型 | **示例** | **含义说明** |
|---------|---------|-------------|
| 版本标签 | `nginx:1.21` | 指定具体版本号 |
| 环境标签 | `node:alpine` | 基于Alpine Linux的轻量版本 |
| 最新标签 | `redis:latest` | 最新稳定版本（默认） |
| 开发标签 | `mysql:beta` | 测试或开发版本 |

---

## 3. 🏃 容器Containers详解


### 3.1 容器的本质概念


**通俗理解**：如果镜像是"软件安装包"，那么容器就是"正在运行的程序"。容器是镜像的运行实例，就像从同一个安装包可以安装多个程序副本。

**容器与虚拟机的区别**：

```
传统虚拟机架构：                Docker容器架构：

┌─────────────┐                  ┌─────────────┐
│   App A     │                  │   App A     │
├─────────────┤                  ├─────────────┤
│  Guest OS   │                  │   App B     │
├─────────────┤                  ├─────────────┤
│ Hypervisor  │                  │   App C     │
├─────────────┤                  ├─────────────┤
│  Host OS    │                  │Docker Engine│
├─────────────┤                  ├─────────────┤
│  Hardware   │                  │  Host OS    │
└─────────────┘                  ├─────────────┤
                                 │  Hardware   │
                                 └─────────────┘

虚拟机：每个应用需要完整的客户机系统
容器：多个应用共享宿主机系统内核
```

### 3.2 容器的生命周期


**容器状态转换图**：
```
     创建      启动      暂停      恢复      停止      删除
Created → Running → Paused → Running → Stopped → Removed
   ↑                                      ↓
   └────────────── 重启 restart ──────────┘

状态说明：
• Created：容器已创建但未启动
• Running：容器正在运行
• Paused：容器被暂停（进程冻结）
• Stopped：容器已停止
• Removed：容器已删除
```

### 3.3 容器的基本操作


**创建和运行容器**：
```bash
# 创建并启动容器（最常用）
docker run -d --name my-nginx nginx

# 交互式启动容器
docker run -it ubuntu bash

# 后台运行并映射端口
docker run -d -p 8080:80 nginx
```

**容器管理命令**：
```bash
# 查看运行中的容器
docker ps

# 查看所有容器（包括停止的）
docker ps -a

# 停止容器
docker stop <容器ID>

# 删除容器
docker rm <容器ID>
```

### 3.4 容器的资源特性


**隔离性保障**：
- **进程隔离**：容器内进程看不到宿主机其他进程
- **文件系统隔离**：每个容器有独立的文件系统视图
- **网络隔离**：容器有独立的网络栈和IP地址
- **资源限制**：可以限制CPU、内存等资源使用

> 📊 **性能对比**  
> 容器启动时间：通常1-3秒  
> 虚拟机启动时间：通常30秒-2分钟  
> 资源开销：容器约为虚拟机的1/10

---

## 4. 🌐 仓库Registry详解


### 4.1 仓库的基本概念


**通俗理解**：Docker仓库就像是手机的"应用商店"，你可以从里面下载各种预制的镜像，也可以把自己制作的镜像上传分享给别人。

**仓库的层级结构**：
```
Docker Hub 仓库结构示例：

🌐 Docker Hub (注册服务器)
├── 📁 library (官方仓库)
│   ├── 📦 nginx (镜像仓库)
│   │   ├── 🏷️ latest
│   │   ├── 🏷️ 1.21
│   │   └── 🏷️ alpine
│   └── 📦 mysql
│       ├── 🏷️ 8.0
│       └── 🏷️ 5.7
└── 📁 username (用户仓库)
    └── 📦 myapp
        └── 🏷️ v1.0

完整镜像名格式：registry/namespace/repository:tag
示例：docker.io/library/nginx:latest
```

### 4.2 仓库的类型分类


| 仓库类型 | **访问权限** | **适用场景** | **示例** |
|---------|-------------|-------------|---------|
| **公共仓库** | 任何人可访问 | 开源项目、学习测试 | Docker Hub官方镜像 |
| **私有仓库** | 需要认证访问 | 企业内部应用 | 公司内部Registry |
| **本地仓库** | 本机访问 | 开发测试环境 | 本地搭建的Registry |

### 4.3 常用仓库操作


**镜像拉取与推送**：
```bash
# 从仓库拉取镜像
docker pull nginx:1.21

# 登录到仓库
docker login

# 推送镜像到仓库
docker push myusername/myapp:v1.0

# 搜索仓库中的镜像
docker search nginx
```

**标签管理**：
```bash
# 为镜像添加标签
docker tag nginx:latest myregistry.com/nginx:v1.0

# 查看镜像标签
docker images nginx
```

> 💡 **实用技巧**  
> 可以配置镜像加速器来提升下载速度，国内常用阿里云、网易云等镜像源。

---

## 5. 💾 数据卷Volume详解


### 5.1 数据卷的基本概念


**通俗理解**：数据卷就像是给容器外接的"移动硬盘"，用来持久化保存数据。容器删除了，数据卷中的数据还在，可以挂载到新容器继续使用。

**为什么需要数据卷**：
- **数据持久化**：容器删除后数据不丢失
- **数据共享**：多个容器可以共享同一个数据卷
- **宿主机访问**：可以直接从宿主机访问容器数据
- **备份恢复**：方便进行数据备份和恢复

### 5.2 数据卷的类型


**三种挂载方式对比**：

```
Volume挂载 (推荐)：
宿主机：/var/lib/docker/volumes/myvolume/_data
容器内：/app/data
特点：由Docker管理，最安全可靠

Bind Mount挂载：
宿主机：/home/user/data
容器内：/app/data  
特点：直接映射宿主机目录，灵活但不安全

tmpfs挂载：
内存：临时文件系统
容器内：/app/temp
特点：存储在内存中，容器停止即消失
```

### 5.3 数据卷操作实践


**创建和管理数据卷**：
```bash
# 创建数据卷
docker volume create myvolume

# 查看所有数据卷
docker volume ls

# 查看数据卷详情
docker volume inspect myvolume

# 删除数据卷
docker volume rm myvolume
```

**容器挂载数据卷**：
```bash
# Volume挂载
docker run -d -v myvolume:/app/data nginx

# Bind Mount挂载
docker run -d -v /host/path:/container/path nginx

# 只读挂载
docker run -d -v myvolume:/app/data:ro nginx
```

### 5.4 数据卷使用场景


**典型应用场景**：

```
📊 数据库数据持久化：
docker run -d -v db-data:/var/lib/mysql mysql

🗂️ 配置文件管理：
docker run -d -v /host/nginx.conf:/etc/nginx/nginx.conf nginx

📁 日志文件收集：
docker run -d -v /var/log/app:/app/logs myapp

🔄 多容器数据共享：
docker run -d -v shared-data:/shared-volume app1
docker run -d -v shared-data:/shared-volume app2
```

> ⚠️ **最佳实践**  
> 对于重要数据，推荐使用Docker管理的Volume而不是Bind Mount，因为Volume更安全、可移植性更好。

---

## 6. 🔗 网络Network详解


### 6.1 网络的基本概念


**通俗理解**：Docker网络就像是给容器之间搭建的"通信网络"，让不同容器能够相互发现和通信，就像局域网中的电脑可以互相访问一样。

**网络解决的问题**：
- **容器通信**：不同容器之间如何互相访问
- **外部访问**：外部用户如何访问容器中的服务
- **服务发现**：容器如何通过服务名找到其他容器
- **负载均衡**：如何在多个容器实例间分配流量

### 6.2 网络驱动类型


**Docker网络类型对比**：

```
bridge网络 (默认)：
┌─────────────────────────────────┐
│        宿主机 (192.168.1.100)   │
│  ┌─────────────────────────────┐│
│  │      docker0网桥            ││
│  │  ┌──────────┐ ┌──────────┐  ││
│  │  │Container1│ │Container2│  ││
│  │  │172.17.0.2│ │172.17.0.3│  ││
│  │  └──────────┘ └──────────┘  ││
│  └─────────────────────────────┘│
└─────────────────────────────────┘
适用：单主机上的容器通信

host网络：
┌─────────────────────────────────┐
│        宿主机 (192.168.1.100)   │
│  ┌──────────┐                  │
│  │Container │ 直接使用宿主机网络 │
│  │共享IP端口│                  │
│  └──────────┘                  │
└─────────────────────────────────┘
适用：需要最高网络性能的场景
```

### 6.3 网络基本操作


**网络管理命令**：
```bash
# 查看所有网络
docker network ls

# 创建自定义网络
docker network create mynetwork

# 查看网络详情
docker network inspect mynetwork

# 删除网络
docker network rm mynetwork
```

**容器网络连接**：
```bash
# 创建容器时指定网络
docker run -d --network mynetwork --name web nginx

# 运行时连接网络
docker network connect mynetwork existing-container

# 断开网络连接
docker network disconnect mynetwork existing-container
```

### 6.4 端口映射机制


**端口映射原理**：

```
端口映射示例：

外部访问 → 宿主机端口8080 → 容器端口80

┌─────────────┐    端口映射     ┌─────────────┐
│   用户浏览器  │ ────────────→ │   宿主机      │
│             │   访问:8080     │  端口:8080   │
└─────────────┘                 └─────────────┘
                                       ↓
                                ┌─────────────┐
                                │   nginx容器  │
                                │  端口:80    │
                                └─────────────┘

命令示例：docker run -p 8080:80 nginx
```

**常用端口映射**：
```bash
# 映射单个端口
docker run -p 8080:80 nginx

# 映射多个端口
docker run -p 8080:80 -p 8443:443 nginx

# 映射UDP端口
docker run -p 53:53/udp dns-server

# 随机端口映射
docker run -P nginx
```

---

## 7. 🔄 对象间关系理解


### 7.1 核心对象协作流程


**完整的Docker应用部署流程**：

```
应用部署完整流程图：

步骤1️⃣: 获取镜像
Registry → Pull → 本地Images

步骤2️⃣: 创建容器  
Images → Run → Containers

步骤3️⃣: 挂载数据卷
Volumes → Mount → Containers

步骤4️⃣: 连接网络
Networks → Connect → Containers

步骤5️⃣: 对外提供服务
Containers → Port Mapping → External Access

流程说明：
🔄 循环：容器可以基于同一镜像反复创建
🔗 关联：容器、网络、数据卷形成有机整体
♻️ 复用：镜像、网络、数据卷可被多个容器共享
```

### 7.2 对象依赖关系


**依赖关系图**：
```
强依赖关系：
Container ────依赖───→ Image (必须)
Container ────依赖───→ Network (默认bridge)

可选依赖关系：  
Container ----挂载---→ Volume (可选)
Container ----使用---→ Custom Network (可选)

共享关系：
Image ←──共享──→ Multiple Containers
Volume ←──共享──→ Multiple Containers  
Network ←──共享──→ Multiple Containers
```

### 7.3 对象生命周期管理


**生命周期关联性**：

| 对象类型 | **创建时机** | **销毁影响** | **持久性** |
|---------|-------------|-------------|-----------|
| **Image** | 构建或拉取时 | 不影响运行中的容器 | 持久存在 |
| **Container** | Run命令时 | 数据丢失（除非挂载卷） | 可删除 |
| **Volume** | 首次挂载时 | 不影响数据持久性 | 持久存在 |
| **Network** | 创建或默认 | 断开容器连接 | 持久存在 |

> 💡 **管理建议**  
> 删除容器前，确认重要数据已保存到数据卷中；删除镜像前，确认没有容器正在使用。

---

## 8. 🌟 Docker生态系统


### 8.1 生态系统架构


**Docker完整生态图**：
```
Docker生态系统全景：

开发阶段：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Dockerfile  │───→│Docker Build │───→│   Images    │
└─────────────┘    └─────────────┘    └─────────────┘
       ↑                                      │
   代码+配置                                  │push
                                             ↓
运行阶段：                            ┌─────────────┐
┌─────────────┐    ┌─────────────┐    │  Registry   │
│ Containers  │←───│Docker Run   │←───│ (仓库服务)  │
└─────────────┘    └─────────────┘    └─────────────┘
       ↓                                      ↑
┌─────────────┐                              │pull
│  Volumes    │                              │
│  Networks   │                              │
└─────────────┘                         其他开发者
```

### 8.2 核心组件说明


**Docker Engine架构**：
- **Docker Client**：用户交互的命令行工具
- **Docker Daemon**：后台服务，管理容器生命周期
- **Docker API**：REST API接口，供客户端调用
- **Container Runtime**：实际运行容器的底层组件

### 8.3 扩展工具生态


**常用Docker工具**：

```
编排工具：
🎼 Docker Compose：单机多容器编排
☸️ Kubernetes：集群容器编排  
🐝 Docker Swarm：Docker原生集群

监控工具：
📊 Portainer：Web界面管理容器
📈 cAdvisor：容器监控数据收集
🔍 Docker Stats：实时资源监控

安全工具：
🔐 Docker Bench：安全基准检查
🛡️ Clair：镜像安全扫描
🔒 Notary：镜像签名验证
```

### 8.4 企业级应用场景


**生产环境应用模式**：

```
🏢 微服务架构：
API网关 ←→ 用户服务容器
         ←→ 订单服务容器  
         ←→ 支付服务容器

🔄 CI/CD流水线：
代码提交 → 自动构建镜像 → 自动测试 → 自动部署

☁️ 云原生应用：
容器化 → 服务网格 → 自动扩缩容 → 故障自愈

🧪 开发测试：
一键部署完整测试环境 → 隔离测试 → 环境一致性
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 五大核心对象：
  镜像(Images) - 应用程序模板，只读分层存储
  容器(Containers) - 镜像的运行实例，隔离环境
  仓库(Registry) - 镜像存储分发中心
  数据卷(Volume) - 数据持久化存储方案
  网络(Network) - 容器间通信桥梁

🔸 对象关系：
  镜像 → 容器：一对多关系，一个镜像创建多个容器
  容器 ↔ 数据卷：多对多关系，实现数据持久化
  容器 ↔ 网络：多对多关系，实现容器通信
  仓库 ↔ 镜像：存储关系，镜像的分发中心
```

### 9.2 关键理解要点


**🔹 镜像与容器的本质区别**：
```
镜像 = 静态的应用程序包 (类比：软件安装包)
容器 = 动态的运行实例 (类比：运行中的程序)

关系：镜像是容器的模板，容器是镜像的实例
特点：镜像只读不变，容器可读写运行
```

**🔹 数据持久化的重要性**：
```
问题：容器删除后数据丢失
解决：使用数据卷(Volume)持久化重要数据
原则：有状态数据必须外挂存储
```

**🔹 网络通信的基本模式**：
```
容器内部通信：通过Docker网络互相访问
容器外部通信：通过端口映射对外提供服务
服务发现：通过容器名称进行网络通信
```

### 9.3 实际应用指导


**最佳实践原则**：
- **镜像构建**：采用多阶段构建减小镜像体积
- **容器运行**：一个容器只运行一个主进程
- **数据管理**：重要数据必须使用数据卷
- **网络设计**：为应用创建专用网络提高安全性

**常见使用场景**：
```
🌐 Web应用部署：
镜像(nginx) → 容器(web服务) → 网络(端口映射) → 外部访问

💾 数据库应用：  
镜像(mysql) → 容器(数据库) → 数据卷(数据持久化) → 应用连接

🔄 微服务架构：
多个镜像 → 多个容器 → 自定义网络 → 服务间通信
```

**核心记忆要点**：
- Docker五大对象各司其职，相互协作构成完整应用
- 镜像是静态模板，容器是动态实例
- 数据卷保证数据持久化，网络保证容器通信  
- 仓库是镜像的集中存储和分发中心
- 理解对象关系是掌握Docker应用的关键