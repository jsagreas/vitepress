---
title: 3、运行时安全
---
## 📚 目录

1. [运行时安全基础概念](#1-运行时安全基础概念)
2. [Seccomp安全配置](#2-seccomp安全配置)
3. [AppArmor安全模块](#3-apparmor安全模块)
4. [SELinux安全策略](#4-selinux安全策略)
5. [Capabilities权限控制](#5-capabilities权限控制)
6. [命名空间隔离](#6-命名空间隔离)
7. [安全策略执行](#7-安全策略执行)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🛡️ 运行时安全基础概念


### 1.1 什么是容器运行时安全


**通俗理解**：容器运行时安全就像给你的房子装上各种安全措施
- 🏠 **房子**：就是容器
- 🔒 **门锁**：权限控制
- 👮 **保安**：安全模块监控
- 🚫 **禁入牌**：系统调用限制

```
传统服务器安全：整台机器一个安全边界
容器运行时安全：每个容器都有独立安全边界

┌─────────────────────────────────┐
│         宿主机系统               │
├─────────┬─────────┬─────────────┤
│ 容器A   │ 容器B   │   容器C     │
│ 安全边界 │ 安全边界 │  安全边界    │
│ [策略1] │ [策略2] │  [策略3]   │
└─────────┴─────────┴─────────────┘
```

### 1.2 运行时安全的核心目标


**🎯 主要防护目标**：
- **防止容器逃逸**：阻止攻击者从容器内部攻击宿主机
- **限制系统资源**：防止恶意程序消耗过多资源
- **控制系统调用**：限制容器能执行的底层操作
- **隔离网络访问**：控制容器的网络通信权限

**💡 安全威胁场景**：
```
场景1：恶意镜像
问题：镜像包含病毒或后门程序
防护：运行时权限限制 + 行为监控

场景2：权限提升攻击
问题：攻击者试图获得root权限
防护：Capabilities控制 + SELinux策略

场景3：系统调用滥用
问题：恶意程序调用危险系统函数
防护：Seccomp过滤 + 系统调用监控
```

### 1.3 多层安全防护模型


```
Docker运行时安全防护层次：

应用层安全
    ↓
├─ 应用代码审计
├─ 依赖库扫描
└─ 运行时监控

容器层安全 ← 本章重点
    ↓
├─ Capabilities权限控制
├─ Seccomp系统调用过滤
├─ AppArmor/SELinux访问控制
└─ 命名空间隔离

系统层安全
    ↓
├─ 内核安全加固
├─ 文件系统权限
└─ 网络防火墙
```

---

## 2. 🔍 Seccomp安全配置


### 2.1 Seccomp是什么


**📋 核心定义**：
- **Seccomp**：Secure Computing Mode，安全计算模式
- **作用**：过滤容器可以使用的系统调用
- **比喻**：就像给程序戴上"手铐"，限制它能做的危险动作

```
没有Seccomp：程序可以调用所有系统函数
┌─────────────────────────────────┐
│  程序  →  所有系统调用  →  内核  │
└─────────────────────────────────┘

有Seccomp保护：危险调用被阻止
┌─────────────────────────────────┐
│  程序  →  Seccomp过滤  →  内核  │
│         ↙        ↘            │
│    允许通过    危险调用被拒绝    │
└─────────────────────────────────┘
```

### 2.2 系统调用的安全风险


**⚠️ 危险系统调用示例**：
```
reboot()     - 重启系统
mount()      - 挂载文件系统  
ptrace()     - 调试其他进程
setuid()     - 修改用户ID
socket()     - 创建网络连接
```

**💡 为什么要限制**：
- 恶意程序可能调用`reboot()`让整个服务器重启
- 攻击者可能用`mount()`挂载宿主机敏感目录
- 病毒可能用`ptrace()`监控其他容器进程

### 2.3 Docker的Seccomp配置


**🔧 默认Seccomp策略**：
```bash
# 查看Docker默认策略
docker info | grep -i seccomp

# 运行容器时查看策略状态
docker run --rm alpine grep Seccomp /proc/self/status
```

**📝 自定义Seccomp配置文件**：
```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": ["SCMP_ARCH_X86_64"],
  "syscalls": [
    {
      "names": ["read", "write", "open", "close"],
      "action": "SCMP_ACT_ALLOW"
    },
    {
      "names": ["mount", "umount"],
      "action": "SCMP_ACT_ERRNO"
    }
  ]
}
```

**🎯 配置说明**：
- `defaultAction`: 默认动作（拒绝未明确允许的调用）
- `SCMP_ACT_ALLOW`: 允许系统调用
- `SCMP_ACT_ERRNO`: 拒绝并返回错误
- `names`: 具体的系统调用名称

### 2.4 实际应用示例


**📖 应用Seccomp配置**：
```bash
# 使用自定义seccomp配置启动容器
docker run -d \
  --name secure-app \
  --security-opt seccomp=custom-profile.json \
  nginx:alpine

# 完全禁用seccomp（不推荐）
docker run -d \
  --security-opt seccomp=unconfined \
  nginx:alpine
```

> 💡 **实战提示**
> 生产环境建议先用默认配置测试应用功能，再逐步收紧权限

---

## 3. 🛠️ AppArmor安全模块


### 3.1 AppArmor基本概念


**📋 核心定义**：
- **AppArmor**：Application Armor，应用程序护甲
- **作用**：限制程序访问文件、网络等资源的权限
- **比喻**：给每个程序穿上"盔甲"，规定它能去哪里、能做什么

```
传统权限模型：用户权限控制
AppArmor模型：程序权限控制

传统方式：
用户Alice → 可以访问 /home/alice/* 所有文件

AppArmor方式：
程序nginx → 只能访问 /etc/nginx/ 和 /var/www/
程序mysql → 只能访问 /var/lib/mysql/
```

### 3.2 AppArmor工作模式


**🔧 两种工作模式**：

| 模式 | 含义 | 行为 | 适用场景 |
|------|------|------|----------|
| **Enforce** | 强制模式 | 阻止违规操作 | 生产环境 |
| **Complain** | 抱怨模式 | 记录但不阻止 | 测试调试 |

**💡 模式切换示例**：
```bash
# 查看AppArmor状态
sudo apparmor_status

# 设置配置文件为complain模式
sudo aa-complain /path/to/profile

# 设置配置文件为enforce模式  
sudo aa-enforce /path/to/profile
```

### 3.3 Docker中的AppArmor配置


**🔍 查看容器AppArmor状态**：
```bash
# 检查容器的AppArmor配置
docker exec container_name cat /proc/self/attr/current

# 查看系统AppArmor策略
sudo apparmor_status | grep docker
```

**📝 自定义AppArmor配置文件**：
```bash
# /etc/apparmor.d/docker-nginx
#include <tunables/global>

profile docker-nginx flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>
  
  # 允许访问的目录
  /etc/nginx/** r,
  /var/www/html/** r,
  /var/log/nginx/** w,
  
  # 禁止访问的目录
  deny /etc/passwd r,
  deny /root/** r,
  
  # 网络权限
  network inet tcp,
  network inet udp,
}
```

**🚀 应用AppArmor配置**：
```bash
# 加载配置文件
sudo apparmor_parser -r -W /etc/apparmor.d/docker-nginx

# 使用自定义AppArmor配置启动容器
docker run -d \
  --name nginx-secure \
  --security-opt apparmor=docker-nginx \
  nginx:alpine
```

---

## 4. 🔐 SELinux安全策略


### 4.1 SELinux基本概念


**📋 核心定义**：
- **SELinux**：Security-Enhanced Linux，安全增强Linux
- **作用**：通过强制访问控制保护系统安全
- **比喻**：给系统中的每个对象都贴上"标签"，严格控制谁能访问什么

```
传统Linux权限：rwx权限位
SELinux权限：标签匹配 + 策略规则

传统方式：
用户 → 检查文件rwx权限 → 访问文件

SELinux方式：  
进程[标签A] → 检查策略规则 → 文件[标签B]
                  ↓
              允许/拒绝访问
```

### 4.2 SELinux标签系统


**🏷️ SELinux标签格式**：
```
user:role:type:level
例如：system_u:system_r:container_t:s0

组成部分：
- user: SELinux用户
- role: 角色  
- type: 类型（最重要）
- level: 安全级别
```

**🔍 查看SELinux标签**：
```bash
# 查看文件SELinux标签
ls -Z /var/lib/docker/

# 查看进程SELinux标签
ps -eZ | grep docker

# 查看容器SELinux标签
docker exec container_name cat /proc/self/attr/current
```

### 4.3 Docker的SELinux集成


**🔧 SELinux模式设置**：
```bash
# 查看SELinux状态
getenforce

# 临时设置为permissive模式（仅记录不阻止）
sudo setenforce 0

# 临时设置为enforcing模式（强制执行）
sudo setenforce 1
```

**📝 Docker SELinux选项**：
```bash
# 启用SELinux标签
docker run -d \
  --name app-secure \
  --security-opt label=type:container_t \
  nginx:alpine

# 完全禁用SELinux（不推荐）
docker run -d \
  --security-opt label=disable \
  nginx:alpine

# 使用自定义SELinux类型
docker run -d \
  --security-opt label=type:my_container_t \
  nginx:alpine
```

### 4.4 SELinux策略管理


**📊 常用SELinux命令**：

| 命令 | 作用 | 示例 |
|------|------|------|
| `setsebool` | 设置布尔值 | `setsebool -P container_manage_cgroup on` |
| `semanage` | 管理SELinux策略 | `semanage port -a -t http_port_t -p tcp 8080` |
| `restorecon` | 恢复文件标签 | `restorecon -R /var/lib/docker` |
| `audit2allow` | 生成策略规则 | `audit2allow -w -a` |

---

## 5. ⚙️ Capabilities权限控制


### 5.1 Capabilities基本概念


**📋 核心定义**：
- **Capabilities**：能力，Linux内核的权限细分机制
- **作用**：将root权限拆分成多个小权限
- **比喻**：传统root权限像"万能钥匙"，Capabilities像"专门钥匙"

```
传统权限模型：
普通用户：权限很少
root用户：所有权限

Capabilities模型：
进程：只拥有必需的具体权限

权限示例：
CAP_NET_BIND_SERVICE - 绑定1024以下端口
CAP_SYS_TIME        - 修改系统时间  
CAP_KILL            - 杀死其他进程
CAP_CHOWN           - 修改文件所有者
```

### 5.2 Docker默认Capabilities


**🔍 Docker默认授予的Capabilities**：
```bash
# 查看容器的capabilities
docker run --rm alpine cat /proc/self/status | grep Cap

# 查看capabilities的人类可读格式
docker run --rm --cap-add=ALL alpine /bin/sh -c \
  "getpcaps \$\$ 2>&1 | grep 'Capabilities:'"
```

**📋 Docker默认Capabilities列表**：
- `CAP_CHOWN` - 修改文件所有权
- `CAP_DAC_OVERRIDE` - 忽略文件权限检查
- `CAP_FSETID` - 设置文件setuid位
- `CAP_FOWNER` - 忽略文件所有者检查
- `CAP_KILL` - 发送信号给进程
- `CAP_NET_BIND_SERVICE` - 绑定特权端口
- `CAP_NET_RAW` - 使用RAW套接字
- `CAP_SETGID` - 设置GID
- `CAP_SETUID` - 设置UID
- `CAP_SETPCAP` - 传递capabilities

### 5.3 Capabilities管理


**🔧 添加和移除Capabilities**：
```bash
# 添加特定capability
docker run -d \
  --name time-server \
  --cap-add=SYS_TIME \
  alpine sleep 3600

# 移除特定capability  
docker run -d \
  --name safe-app \
  --cap-drop=NET_RAW \
  nginx:alpine

# 移除所有默认capabilities，只添加必需的
docker run -d \
  --name minimal-app \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  nginx:alpine
```

**💡 最佳实践建议**：

| 应用类型 | 推荐Capabilities配置 | 原因 |
|----------|---------------------|------|
| **Web服务器** | `--cap-drop=ALL --cap-add=NET_BIND_SERVICE` | 只需绑定80/443端口 |
| **数据库** | `--cap-drop=ALL --cap-add=SETUID --cap-add=SETGID` | 需要切换用户身份 |
| **日志收集** | `--cap-drop=ALL --cap-add=DAC_OVERRIDE` | 需要读取各种日志文件 |

### 5.4 权限审计和监控


**🔍 Capabilities审计工具**：
```bash
# 查看进程的详细capabilities信息
docker exec container_name capsh --print

# 使用pscap查看所有进程的capabilities
pscap | grep docker

# 监控capabilities的使用情况
auditctl -w /proc/*/attr/current -p wa
```

---

## 6. 🏠 命名空间隔离


### 6.1 命名空间基本概念


**📋 核心定义**：
- **命名空间**：Linux内核的资源隔离机制
- **作用**：让每个容器看到独立的系统视图
- **比喻**：就像给每个租户提供独立的"虚拟房间"

```
没有命名空间：所有进程共享系统视图
┌─────────────────────────────────┐
│    进程A  进程B  进程C          │
│      ↓     ↓     ↓             │
│        共享系统资源              │
└─────────────────────────────────┘

有命名空间：每个进程看到独立视图
┌─────────┬─────────┬─────────────┐
│ 进程A   │ 进程B   │   进程C     │
│[视图A]  │[视图B]  │  [视图C]   │
└─────────┴─────────┴─────────────┘
```

### 6.2 六大命名空间类型


**🔧 Linux命名空间详解**：

| 命名空间 | 作用 | 隔离内容 | Docker默认 |
|----------|------|----------|------------|
| **PID** | 进程隔离 | 进程号空间 | ✅ 启用 |
| **NET** | 网络隔离 | 网络设备、路由 | ✅ 启用 |
| **MNT** | 挂载隔离 | 文件系统挂载点 | ✅ 启用 |
| **UTS** | 主机名隔离 | 主机名和域名 | ✅ 启用 |
| **IPC** | 进程通信隔离 | 信号量、消息队列 | ✅ 启用 |
| **USER** | 用户隔离 | 用户和组ID | ❌ 默认关闭 |

### 6.3 命名空间配置选项


**🔧 Docker命名空间控制**：
```bash
# 使用宿主机的PID命名空间
docker run -d \
  --name monitor-app \
  --pid=host \
  alpine sleep 3600

# 使用宿主机的网络命名空间  
docker run -d \
  --name network-tool \
  --network=host \
  alpine sleep 3600

# 使用宿主机的IPC命名空间
docker run -d \
  --name ipc-app \
  --ipc=host \
  alpine sleep 3600

# 共享另一个容器的命名空间
docker run -d \
  --name app2 \
  --pid=container:app1 \
  alpine sleep 3600
```

### 6.4 命名空间安全考量


**⚠️ 使用宿主机命名空间的风险**：

```bash
# 危险：容器可以看到宿主机所有进程
docker run --pid=host alpine ps aux

# 危险：容器可以直接访问宿主机网络
docker run --network=host nginx

# 相对安全：只是共享UTS命名空间
docker run --uts=host alpine hostname
```

**💡 安全最佳实践**：
- **避免使用** `--pid=host`：除非监控工具必需
- **谨慎使用** `--network=host`：优先使用端口映射
- **评估风险** `--ipc=host`：考虑是否真正需要
- **启用User命名空间**：生产环境强烈建议

---

## 7. 📋 安全策略执行


### 7.1 综合安全策略配置


**🎯 多层安全防护示例**：
```bash
docker run -d \
  --name production-app \
  --user 1000:1000 \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt seccomp=custom-profile.json \
  --security-opt apparmor=docker-nginx \
  --security-opt no-new-privileges:true \
  --read-only \
  --tmpfs /tmp:noexec,nosuid,size=256m \
  --memory=512m \
  --cpus=1.0 \
  nginx:alpine
```

**📝 配置说明**：
- `--user 1000:1000`: 非root用户运行
- `--cap-drop=ALL --cap-add=NET_BIND_SERVICE`: 最小权限原则
- `--security-opt no-new-privileges:true`: 阻止权限提升
- `--read-only`: 容器文件系统只读
- `--tmpfs /tmp`: 临时目录使用内存文件系统

### 7.2 安全策略验证


**🔍 验证安全配置效果**：
```bash
# 检查用户身份
docker exec production-app whoami

# 验证capabilities
docker exec production-app capsh --print

# 测试文件写入权限
docker exec production-app touch /test-file 
# 应该失败：Read-only file system

# 验证权限提升限制
docker exec production-app sudo -v
# 应该失败：no-new-privileges设置
```

### 7.3 安全监控和告警


**📊 运行时安全监控**：
```bash
# 监控系统调用
strace -e trace=all -p $(docker inspect --format '{{.State.Pid}}' container_name)

# 监控文件访问
auditctl -w /var/lib/docker -p wa -k docker_access

# 查看安全日志
journalctl -u docker.service | grep -i security
tail -f /var/log/audit/audit.log | grep AVC
```

**⚡ 自动化安全检查脚本**：
```bash
#!/bin/bash
# docker-security-check.sh

check_container_security() {
    local container=$1
    echo "=== 检查容器 $container 的安全配置 ==="
    
    # 检查用户
    echo "用户检查:"
    docker exec $container whoami
    
    # 检查capabilities
    echo "权限检查:"
    docker exec $container capsh --print | grep "Current:"
    
    # 检查SELinux/AppArmor
    echo "MAC检查:"
    docker exec $container cat /proc/self/attr/current
    
    echo "============================="
}

# 检查所有运行中的容器
for container in $(docker ps --format '{{.Names}}'); do
    check_container_security $container
done
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 运行时安全：容器运行期间的多层安全防护体系
🔸 Seccomp：系统调用过滤器，限制危险操作
🔸 AppArmor：应用程序访问控制，限制文件网络权限
🔸 SELinux：强制访问控制，基于标签的安全策略
🔸 Capabilities：细粒度权限控制，替代粗暴的root权限
🔸 命名空间：资源隔离机制，提供独立的系统视图
```

### 8.2 关键理解要点


**🔹 安全配置的平衡原则**
```
安全性 vs 功能性：
- 过度限制：应用无法正常工作
- 限制不足：存在安全风险
- 最佳实践：最小权限原则 + 功能测试验证

配置复杂度 vs 维护成本：
- 复杂配置：更安全但难维护
- 简单配置：易维护但可能不够安全
- 建议：从默认配置开始，逐步优化
```

**🔹 多层防护的必要性**
```
单一防护：
某个安全机制失效 → 整体安全失效

多层防护：
Seccomp + AppArmor + Capabilities + 命名空间
某层失效 → 其他层继续提供保护
```

### 8.3 实际应用价值


**💼 不同场景的安全策略**：

| 应用场景 | 推荐安全配置 | 关键考虑 |
|----------|-------------|----------|
| **开发测试** | 默认配置 | 功能性优先，便于调试 |
| **生产Web应用** | Seccomp + 最小Capabilities | 平衡安全性和性能 |
| **金融系统** | 全套安全机制 | 安全性第一，合规要求 |
| **边缘计算** | 轻量安全配置 | 考虑资源限制 |

**🔧 运维实践要点**：
- **渐进实施**：先测试再上线，避免影响业务
- **持续监控**：建立安全日志和告警机制
- **定期审计**：检查安全配置的有效性
- **团队培训**：确保运维人员理解安全配置

**🧠 核心记忆口诀**：
- 系统调用用Seccomp，文件访问AppArmor管
- 权限控制Capabilities，进程隔离命名空间
- SELinux标签要对应，多层防护保平安
- 最小权限是原则，安全功能要平衡

**🎯 学习路径建议**：
1. **基础阶段**：理解各安全机制的基本概念
2. **实践阶段**：在测试环境配置和验证
3. **应用阶段**：根据业务需求定制安全策略
4. **优化阶段**：持续监控和改进安全配置

通过掌握这些运行时安全技术，你可以大幅提升Docker容器的安全性，构建可信赖的容器化应用环境。记住：**安全不是一次性配置，而是持续的过程！**