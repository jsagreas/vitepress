---
title: 9、调试诊断命令
---
## 📚 目录

1. [调试诊断命令概述](#1-调试诊断命令概述)
2. [实时日志查看命令](#2-实时日志查看命令)
3. [交互式调试命令](#3-交互式调试命令)
4. [容器详细信息查看](#4-容器详细信息查看)
5. [性能监控命令](#5-性能监控命令)
6. [端口与进程查看](#6-端口与进程查看)
7. [文件变更追踪命令](#7-文件变更追踪命令)
8. [镜像层分析命令](#8-镜像层分析命令)
9. [实时事件监控](#9-实时事件监控)
10. [调试实战案例](#10-调试实战案例)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🔍 调试诊断命令概述


### 1.1 调试命令的作用


当Docker容器出现问题时，我们需要像医生诊断病人一样，通过各种"检查工具"来找出问题所在。Docker提供了一套完整的调试诊断命令，就像是给容器做"体检"的工具箱。

**🎯 核心调试场景**
```
容器无法启动 → 查看启动日志找原因
应用运行异常 → 进入容器内部检查
性能问题 → 监控资源使用情况
网络连接问题 → 检查端口映射配置
文件丢失问题 → 追踪文件变更历史
```

### 1.2 调试命令分类


| 命令类型 | **核心命令** | **主要作用** | **使用场景** |
|---------|-------------|-------------|-------------|
| 📋 **日志查看** | `docker logs` | 查看容器运行日志 | 排查启动失败、运行错误 |
| 🔧 **交互调试** | `docker exec` | 进入容器内部操作 | 文件检查、配置修改 |
| 📊 **信息查看** | `docker inspect` | 查看详细配置信息 | 配置检查、网络分析 |
| 📈 **性能监控** | `docker stats` | 实时资源使用监控 | 性能分析、资源优化 |
| 🔍 **进程查看** | `docker top` | 查看容器内进程 | 进程状态分析 |
| 🌐 **网络诊断** | `docker port` | 查看端口映射 | 网络连通性问题 |
| 📂 **变更追踪** | `docker diff` | 查看文件变更 | 数据变化分析 |
| 🏗️ **镜像分析** | `docker history` | 查看镜像构建历史 | 镜像问题排查 |
| ⚡ **事件监控** | `docker events` | 实时事件流 | 系统行为监控 |

---

## 2. 📋 实时日志查看命令


### 2.1 docker logs基础用法


`docker logs`命令就像是容器的"黑匣子记录器"，记录着容器运行过程中的所有输出信息。这是排查问题的第一步，也是最重要的一步。

**🔸 基本语法**
```bash
docker logs [OPTIONS] CONTAINER
```

**💡 核心参数说明**
```bash
# 查看容器的所有日志
docker logs my-container

# 实时跟踪日志输出（类似tail -f）
docker logs -f my-container

# 只显示最近的10行日志
docker logs --tail 10 my-container

# 显示日志的时间戳
docker logs -t my-container

# 查看指定时间范围的日志
docker logs --since "2024-01-01T10:00:00" my-container
docker logs --until "2024-01-01T12:00:00" my-container
```

### 2.2 实时日志监控实践


**🚀 实时监控场景**
```
Web应用调试：
docker logs -f --tail 100 web-server

数据库问题排查：
docker logs -f mysql-container | grep ERROR

多容器日志对比：
docker logs app1 > app1.log &
docker logs app2 > app2.log &
```

### 2.3 日志过滤技巧


**🔍 高级日志筛选**
```bash
# 只看错误级别日志（结合grep）
docker logs my-app 2>&1 | grep -i error

# 查看特定时间段的错误
docker logs --since "1h" my-app | grep ERROR

# 统计错误数量
docker logs my-app | grep -c ERROR

# 实时监控并过滤关键信息
docker logs -f my-app | grep -E "(ERROR|WARN|FATAL)"
```

**💡 日志分析实战示例**
```
场景：Web应用响应缓慢
步骤1：docker logs -f --tail 50 web-app
步骤2：观察是否有数据库连接错误
步骤3：docker logs web-app | grep -i "timeout\|connection"
步骤4：根据日志定位具体问题代码
```

---

## 3. 🔧 交互式调试命令


### 3.1 docker exec交互模式详解


`docker exec`命令就像是给你一把"万能钥匙"，让你能够"走进"正在运行的容器内部，就像进入一个虚拟的操作系统环境一样。

**🎯 核心概念理解**
```
想象容器是一个独立的房间：
- docker exec 就是给你一把钥匙进入这个房间
- -it 参数让你能够在房间里自由活动和交流
- /bin/bash 是你进入房间后使用的"语言"
```

**🔸 基本交互命令**
```bash
# 进入容器的交互式shell
docker exec -it my-container /bin/bash

# 如果容器没有bash，使用sh
docker exec -it my-container /bin/sh

# 以root用户身份进入（解决权限问题）
docker exec -it --user root my-container /bin/bash

# 在容器内执行单个命令（不进入交互模式）
docker exec my-container ls -la /app
```

### 3.2 容器内部调试技巧


**🔍 常见调试操作**

```
进入容器后的典型调试流程：

1. 检查文件系统
   ls -la /app/
   cat /app/config.properties

2. 查看进程状态
   ps aux
   netstat -tulpn

3. 检查网络连接
   ping google.com
   curl -I http://api.example.com

4. 查看系统资源
   df -h    # 磁盘空间
   free -h  # 内存使用
   top      # 实时进程监控
```

**💡 实用调试案例**
```bash
# 案例1：检查Web应用配置文件
docker exec -it web-app /bin/bash
cat /etc/nginx/nginx.conf
ls -la /var/log/nginx/

# 案例2：测试数据库连接
docker exec -it my-app /bin/bash
mysql -h db-server -u user -p
telnet redis-server 6379

# 案例3：查看应用日志文件
docker exec -it app-container /bin/bash
tail -f /var/log/application.log
```

### 3.3 临时文件操作


**📂 容器内文件操作**
```bash
# 创建临时调试脚本
docker exec -it my-container /bin/bash -c "
echo '#!/bin/bash
echo \"Debug started at: \$(date)\"
ps aux | grep java
netstat -tulpn | grep :8080
' > /tmp/debug.sh && chmod +x /tmp/debug.sh"

# 执行调试脚本
docker exec my-container /tmp/debug.sh
```

---

## 4. 📊 容器详细信息查看


### 4.1 docker inspect命令详解


`docker inspect`命令就像是容器的"身份证"和"体检报告"，包含了容器的所有配置信息和运行状态。这个命令返回的是JSON格式的详细信息。

**🔸 基本用法**
```bash
# 查看容器完整信息
docker inspect my-container

# 只查看特定字段（使用Go模板语法）
docker inspect --format='{{.State.Status}}' my-container

# 查看容器IP地址
docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' my-container

# 查看容器挂载点
docker inspect --format='{{.Mounts}}' my-container
```

### 4.2 关键信息提取


**🎯 常用信息查询**

```
容器基本状态：
docker inspect --format='{{.State.Status}}' my-container
# 输出：running/stopped/paused

容器启动时间：
docker inspect --format='{{.State.StartedAt}}' my-container

容器网络信息：
docker inspect --format='{{.NetworkSettings.IPAddress}}' my-container

端口映射信息：
docker inspect --format='{{.NetworkSettings.Ports}}' my-container

挂载卷信息：
docker inspect --format='{{range .Mounts}}{{.Source}}:{{.Destination}}{{end}}' my-container
```

### 4.3 配置信息分析


**📋 配置检查实战**
```bash
# 检查环境变量配置
docker inspect --format='{{.Config.Env}}' my-container

# 检查容器启动命令
docker inspect --format='{{.Config.Cmd}}' my-container

# 检查工作目录
docker inspect --format='{{.Config.WorkingDir}}' my-container

# 检查资源限制
docker inspect --format='Memory: {{.HostConfig.Memory}}, CPUs: {{.HostConfig.NanoCpus}}' my-container
```

**💡 故障排查应用**
```
网络连接问题排查：
1. docker inspect my-container | grep -i network
2. 检查IP地址是否正确分配
3. 检查端口映射是否配置正确
4. 检查网络模式是否合适

存储问题排查：
1. docker inspect my-container | grep -i mount
2. 检查挂载路径是否正确
3. 检查权限设置是否合理
4. 检查磁盘空间是否充足
```

---

## 5. 📈 性能监控命令


### 5.1 docker stats实时统计


`docker stats`命令就像是容器的"性能监控仪表盘"，实时显示容器的资源使用情况，包括CPU、内存、网络IO等关键指标。

**🔸 基本监控命令**
```bash
# 查看所有运行容器的实时统计
docker stats

# 查看指定容器的统计
docker stats my-container

# 只显示一次统计结果（不持续更新）
docker stats --no-stream

# 不截断容器名称显示
docker stats --no-trunc

# 只显示容器ID和名称
docker stats --format "table {{.Container}}\t{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"
```

### 5.2 性能指标解读


**📊 核心性能指标**

```
CPU使用率 (CPU %)：
- 0.50% = CPU使用率很低，正常待机状态
- 50% = 中等负载，需要关注
- 100%+ = 高负载，可能需要优化

内存使用 (MEM USAGE/LIMIT)：
- 100MiB/1GiB = 使用了100MB，限制1GB
- 比例超过80%需要关注内存优化

网络IO (NET I/O)：
- 1.2MB/800KB = 入站1.2MB，出站800KB
- 持续高IO可能有网络瓶颈

磁盘IO (BLOCK I/O)：
- 500MB/200MB = 读取500MB，写入200MB
- 高磁盘IO影响整体性能
```

### 5.3 性能问题诊断


**🔍 性能瓶颈识别**
```bash
# 持续监控并记录到文件
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemPerc}}\t{{.NetIO}}" > performance.log &

# 查找CPU使用率最高的容器
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}" | sort -k2 -nr

# 查找内存使用最多的容器
docker stats --no-stream --format "table {{.Name}}\t{{.MemUsage}}" | sort -k2 -nr
```

**💡 性能优化建议**
```
高CPU使用率解决方案：
1. 检查应用代码是否有死循环
2. 考虑增加CPU核心数限制
3. 优化算法或增加缓存

高内存使用解决方案：
1. 检查是否有内存泄漏
2. 调整JVM堆内存设置
3. 增加内存限制或优化数据结构

高网络IO解决方案：
1. 检查是否有不必要的网络请求
2. 优化数据传输格式
3. 使用缓存减少网络调用
```

---

## 6. 🔍 端口与进程查看


### 6.1 docker top进程监控


`docker top`命令让你能够查看容器内部正在运行的进程，就像在普通Linux系统中使用`top`命令一样。

**🔸 进程查看命令**
```bash
# 查看容器内的进程列表
docker top my-container

# 使用ps选项查看更详细信息
docker top my-container aux

# 查看进程树结构
docker top my-container axjf
```

**📋 进程信息解读**
```
典型输出格式：
UID    PID    PPID   C   STIME   TTY   TIME     CMD
root   1234   1000   0   10:30   ?     00:00:05 java -jar app.jar
root   1235   1234   0   10:30   ?     00:00:01 nginx: master process

字段含义：
- UID：运行用户
- PID：进程ID  
- PPID：父进程ID
- C：CPU使用率
- STIME：启动时间
- TTY：终端
- TIME：累计CPU时间
- CMD：完整命令
```

### 6.2 docker port端口映射查看


`docker port`命令帮助你查看容器的端口映射配置，这对排查网络连接问题非常重要。

**🔸 端口查看命令**
```bash
# 查看容器所有端口映射
docker port my-container

# 查看特定端口映射
docker port my-container 8080

# 查看特定协议端口
docker port my-container 8080/tcp
```

**🌐 端口映射分析**
```bash
# 典型输出示例
8080/tcp -> 0.0.0.0:8080
3306/tcp -> 127.0.0.1:3306

解读说明：
- 8080/tcp -> 0.0.0.0:8080
  容器内8080端口映射到主机所有网卡的8080端口

- 3306/tcp -> 127.0.0.1:3306  
  容器内3306端口只映射到主机本地回环地址

- 没有输出表示该端口没有映射到主机
```

### 6.3 网络连接问题诊断


**🔧 网络问题排查流程**

```
步骤1：检查端口映射配置
docker port my-web-app

步骤2：检查容器内进程是否监听端口
docker exec my-web-app netstat -tulpn

步骤3：检查主机端口是否可访问
netstat -tulpn | grep 8080

步骤4：测试网络连通性
curl -I http://localhost:8080
telnet localhost 8080
```

**💡 常见网络问题解决**
```bash
# 问题1：端口无法访问
# 检查容器是否正确映射端口
docker run -p 8080:8080 my-app

# 问题2：容器内服务未启动
docker exec -it my-container /bin/bash
ps aux | grep nginx
systemctl status nginx

# 问题3：防火墙阻塞
iptables -L
ufw status
```

---

## 7. 📂 文件变更追踪命令


### 7.1 docker diff文件变更检测


`docker diff`命令就像是文件系统的"变更记录器"，能够显示容器相对于基础镜像发生了哪些文件变更。这对于调试数据丢失或配置变更问题非常有用。

**🔸 基本用法**
```bash
# 查看容器的文件变更
docker diff my-container
```

**📋 变更类型说明**
```
A：Added（新增文件）
D：Deleted（删除文件）  
C：Changed（修改文件）

典型输出示例：
C /var
C /var/log
A /var/log/nginx
C /etc
C /etc/nginx
A /etc/nginx/nginx.conf
D /tmp/install.sh
```

### 7.2 文件变更分析


**🔍 变更分析技巧**
```bash
# 查看特定目录的变更
docker diff my-container | grep /etc

# 统计变更文件数量
docker diff my-container | wc -l

# 查看新增文件
docker diff my-container | grep "^A"

# 查看删除的文件
docker diff my-container | grep "^D"
```

**💡 实际应用场景**
```
数据持久化检查：
1. 启动容器前记录状态
2. 运行应用产生数据
3. 使用docker diff查看数据文件位置
4. 确定需要持久化的目录

配置文件调试：
1. 进入容器修改配置
2. 使用docker diff查看修改了哪些文件
3. 通过docker cp复制修改后的文件
4. 在Dockerfile中包含正确配置

应用调试：
1. 应用运行异常时查看文件变更
2. 检查日志文件是否正常生成
3. 确认临时文件是否正确清理
```

---

## 8. 🏗️ 镜像层分析命令


### 8.1 docker history镜像历史


`docker history`命令让你能够查看镜像的"族谱"，了解镜像是如何一层一层构建出来的。每一层都对应Dockerfile中的一条指令。

**🔸 基本用法**
```bash
# 查看镜像构建历史
docker history my-image:latest

# 显示完整的命令（不截断）
docker history --no-trunc my-image:latest

# 以易读格式显示文件大小
docker history --human my-image:latest
```

**📊 历史信息解读**
```
典型输出格式：
IMAGE          CREATED        CREATED BY                      SIZE
abc123def456   2 hours ago    /bin/sh -c apt-get update       45.2MB
def456ghi789   2 hours ago    /bin/sh -c WORKDIR /app         0B
ghi789jkl012   2 hours ago    /bin/sh -c FROM ubuntu:20.04    72.8MB

字段含义：
- IMAGE：层的镜像ID
- CREATED：创建时间
- CREATED BY：创建该层的命令
- SIZE：该层的大小
```

### 8.2 镜像优化分析


**🔍 镜像大小优化**
```bash
# 找出占用空间最大的层
docker history --human my-image | sort -k4 -hr

# 分析每层的作用
docker history --no-trunc my-image | grep -v "<missing>"
```

**💡 优化建议**
```
大尺寸层优化策略：

1. 合并RUN指令：
   # 优化前
   RUN apt-get update
   RUN apt-get install -y package1
   RUN apt-get install -y package2
   
   # 优化后  
   RUN apt-get update && \
       apt-get install -y package1 package2 && \
       rm -rf /var/lib/apt/lists/*

2. 使用多阶段构建：
   # 编译阶段
   FROM node:16 AS builder
   COPY . .
   RUN npm install && npm run build
   
   # 运行阶段
   FROM nginx:alpine
   COPY --from=builder /app/dist /usr/share/nginx/html

3. 清理临时文件：
   RUN apt-get update && \
       apt-get install -y wget && \
       wget http://example.com/file.tar.gz && \
       tar -xzf file.tar.gz && \
       rm file.tar.gz  # 在同一层删除临时文件
```

---

## 9. ⚡ 实时事件监控


### 9.1 docker events事件流


`docker events`命令就像是Docker的"监控摄像头"，实时记录Docker守护进程中发生的所有事件，包括容器启动、停止、网络连接、卷挂载等操作。

**🔸 基本事件监控**
```bash
# 监控所有实时事件
docker events

# 监控指定时间范围的事件
docker events --since "2024-01-01T10:00:00"
docker events --until "2024-01-01T12:00:00"

# 监控特定容器的事件
docker events --filter container=my-container

# 监控特定类型的事件
docker events --filter event=start
docker events --filter type=container
```

### 9.2 事件过滤与分析


**🔍 高级事件过滤**
```bash
# 监控容器生命周期事件
docker events --filter type=container --filter event=start --filter event=stop --filter event=die

# 监控网络相关事件
docker events --filter type=network

# 监控卷相关事件  
docker events --filter type=volume

# 监控镜像相关事件
docker events --filter type=image --filter event=pull --filter event=push
```

**📋 事件类型说明**
```
容器事件：
- create：容器创建
- start：容器启动
- stop：容器停止
- die：容器异常终止
- destroy：容器删除

网络事件：
- create：网络创建
- connect：容器连接到网络
- disconnect：容器从网络断开

镜像事件：
- pull：拉取镜像
- push：推送镜像
- tag：镜像打标签
- untag：移除标签

卷事件：
- create：卷创建
- mount：卷挂载
- unmount：卷卸载
```

### 9.3 事件监控实战


**💡 监控应用场景**
```bash
# 场景1：监控应用部署过程
docker events --filter type=container --since "5m" &
docker-compose up -d
# 观察容器启动顺序和可能的错误

# 场景2：监控系统资源变化
docker events --filter type=volume --filter type=network &
# 在另一个终端操作容器，观察资源创建/删除

# 场景3：故障排查
docker events --filter container=problematic-app --since "1h"
# 查看问题容器在过去1小时的所有事件
```

**🚨 异常事件告警**
```bash
# 创建简单的异常监控脚本
#!/bin/bash
docker events --filter event=die --filter event=kill --filter event=oom | while read event
do
    echo "ALERT: Container died at $(date): $event"
    # 可以发送邮件或调用告警接口
done
```

---

## 10. 🛠️ 调试实战案例


### 10.1 Web应用无法启动问题


**问题场景**：部署的Web应用容器启动后立即退出

**🔧 排查步骤**
```bash
# 步骤1：查看容器状态
docker ps -a
# 发现容器状态为Exited (1)

# 步骤2：查看启动日志
docker logs my-web-app
# 发现错误：Permission denied: /app/start.sh

# 步骤3：检查镜像构建历史
docker history my-web-app:latest
# 发现启动脚本没有执行权限

# 步骤4：进入容器检查文件权限
docker run -it --rm my-web-app:latest /bin/bash
ls -la /app/start.sh
# 确认文件权限问题

# 解决方案：修改Dockerfile
RUN chmod +x /app/start.sh
```

### 10.2 数据库连接问题


**问题场景**：应用无法连接到数据库容器

**🔧 排查步骤**
```bash
# 步骤1：检查网络连接
docker network ls
docker network inspect my-network

# 步骤2：检查端口映射
docker port mysql-container
docker port web-app-container

# 步骤3：测试网络连通性
docker exec web-app-container ping mysql-container
docker exec web-app-container telnet mysql-container 3306

# 步骤4：检查数据库服务状态
docker exec mysql-container ps aux | grep mysql
docker logs mysql-container | grep -i error

# 步骤5：检查防火墙设置
docker exec mysql-container netstat -tulpn | grep 3306
```

### 10.3 性能问题分析


**问题场景**：容器运行缓慢，响应时间长

**🔧 排查步骤**
```bash
# 步骤1：监控资源使用
docker stats my-slow-app
# 发现CPU使用率持续100%

# 步骤2：查看进程详情
docker top my-slow-app aux
# 发现某个进程占用大量CPU

# 步骤3：进入容器分析
docker exec -it my-slow-app /bin/bash
top -p $(pgrep java)
jstack $(pgrep java) > thread-dump.txt

# 步骤4：分析应用日志
docker logs --tail 1000 my-slow-app | grep -i "slow\|timeout\|error"

# 解决方案：
# - 优化应用代码
# - 增加CPU限制
# - 调整JVM参数
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的调试命令


```bash
🔸 日志查看：docker logs -f --tail 100 容器名
🔸 进入容器：docker exec -it 容器名 /bin/bash  
🔸 查看详情：docker inspect 容器名
🔸 性能监控：docker stats 容器名
🔸 进程查看：docker top 容器名
🔸 端口映射：docker port 容器名
🔸 文件变更：docker diff 容器名
🔸 镜像历史：docker history 镜像名
🔸 事件监控：docker events --filter container=容器名
```

### 11.2 调试问题的思维流程


**🎯 系统化排查方法**
```
第一步：观察现象
- 容器是否在运行？
- 应用是否可以访问？
- 有什么错误提示？

第二步：查看日志
- docker logs 查看启动日志
- 应用内部日志文件
- 系统错误日志

第三步：检查配置
- docker inspect 查看配置
- 环境变量是否正确
- 端口映射是否合理

第四步：资源分析
- docker stats 查看资源使用
- 磁盘空间是否充足
- 网络连接是否正常

第五步：深入调试
- docker exec 进入容器内部
- 手动测试各个组件
- 分析代码和配置文件
```

### 11.3 常见问题快速定位


| 问题类型 | **快速检查命令** | **关键排查点** |
|---------|-----------------|---------------|
| **启动失败** | `docker logs 容器名` | 查看错误日志，检查启动脚本权限 |
| **无法访问** | `docker port 容器名` | 检查端口映射，测试网络连通性 |
| **运行缓慢** | `docker stats 容器名` | 查看CPU/内存使用，分析资源瓶颈 |
| **数据丢失** | `docker diff 容器名` | 检查文件变更，确认挂载点配置 |
| **配置错误** | `docker inspect 容器名` | 查看环境变量，检查挂载卷路径 |

### 11.4 调试最佳实践


**💡 高效调试技巧**
```
1. 分层排查：从外到内，从简单到复杂
2. 保留现场：出问题时不要立即重启，先收集信息
3. 日志为王：充分利用各种日志信息
4. 工具组合：多个命令配合使用，交叉验证
5. 文档记录：记录问题和解决方案，建立知识库
```

**🚨 调试注意事项**
- 生产环境调试要谨慎，避免影响正常服务
- 使用`docker exec`时注意不要修改重要配置
- 监控命令会消耗系统资源，适时停止
- 调试完成后及时清理临时文件和进程

**核心记忆口诀**：
- 问题出现先看日志，docker logs很重要
- 进入容器用exec，交互调试效率高  
- inspect查配置，stats看性能指标
- 端口进程要清楚，diff查看文件变化
- 系统排查有步骤，工具组合效果好