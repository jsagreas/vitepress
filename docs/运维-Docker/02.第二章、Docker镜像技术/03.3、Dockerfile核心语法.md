---
title: 3、Dockerfile核心语法
---
## 📚 目录

1. [Dockerfile基本概念](#1-dockerfile基本概念)
2. [FROM基础镜像指令](#2-from基础镜像指令)
3. [RUN执行命令指令](#3-run执行命令指令)
4. [COPY复制文件指令](#4-copy复制文件指令)
5. [ADD高级复制指令](#5-add高级复制指令)
6. [WORKDIR工作目录设置](#6-workdir工作目录设置)
7. [EXPOSE端口暴露声明](#7-expose端口暴露声明)
8. [ENV环境变量设置](#8-env环境变量设置)
9. [指令最佳实践](#9-指令最佳实践)
10. [核心要点总结](#10-核心要点总结)

---

## 1. 🐳 Dockerfile基本概念


### 1.1 什么是Dockerfile


**通俗理解**：Dockerfile就像是一个**制作镜像的食谱**，告诉Docker如何一步步构建出我们想要的镜像。

```
传统方式制作镜像：              Dockerfile方式：
1. 启动一个基础容器               1. 编写Dockerfile文件
2. 进入容器手动安装软件           2. 执行docker build命令
3. 手动配置环境                  3. Docker自动按步骤构建
4. 手动提交为新镜像              4. 生成标准化镜像

问题：手动操作繁琐、易出错        优势：自动化、可重复、可版本控制
```

### 1.2 Dockerfile工作原理


**构建过程图示**：
```
Dockerfile内容          构建过程           最终镜像
┌─────────────┐       ┌─────────┐       ┌─────────┐
│FROM ubuntu  │ ──→   │ 第1层   │ ──→   │ 应用层  │
│RUN apt-get  │       │ 第2层   │       │ 软件层  │
│COPY app.py  │       │ 第3层   │       │ 基础层  │
│CMD python   │       │ 第4层   │       │ 内核层  │
└─────────────┘       └─────────┘       └─────────┘
```

**核心特点**：
- **分层构建**：每个指令创建一个新的镜像层
- **缓存机制**：相同的指令可以复用之前的层
- **自动化**：一次编写，多次构建
- **可重复**：在任何环境都能得到相同结果

### 1.3 基本语法规则


**文件格式要求**：
- 文件名必须是 `Dockerfile`（无扩展名）
- 使用UTF-8编码
- 每行一个指令
- 指令不区分大小写，但建议大写

**注释和格式**：
```dockerfile
# 这是注释，以#开头
FROM ubuntu:20.04  # 指令 参数
RUN echo "Hello World"
```

---

## 2. 🏗️ FROM基础镜像指令


### 2.1 FROM指令的作用


**核心作用**：FROM指令用来**指定基础镜像**，就像盖房子需要先有地基一样。

> 💡 **通俗理解**：FROM就是告诉Docker"我要基于哪个现有的镜像来构建新镜像"

### 2.2 基本语法格式


**语法形式**：
```dockerfile
FROM <镜像名>[:<标签>]
FROM <镜像名>[@<摘要>]
```

**常用示例**：
```dockerfile
# 使用官方Ubuntu镜像
FROM ubuntu:20.04

# 使用官方Node.js镜像
FROM node:16-alpine

# 使用官方Python镜像
FROM python:3.9-slim

# 不指定标签，默认使用latest
FROM nginx
```

### 2.3 基础镜像选择策略


| 镜像类型 | **特点** | **适用场景** | **大小** |
|---------|---------|-------------|---------|
| 🔸 **完整版** | `ubuntu:20.04` | 功能完整，工具丰富 | 开发调试 | 大（~70MB） |
| 🔸 **精简版** | `alpine:latest` | 体积小，安全性高 | 生产环境 | 小（~5MB） |
| 🔸 **应用版** | `node:16-alpine` | 预装特定软件 | 特定语言开发 | 中（~30MB） |
| 🔸 **纯净版** | `scratch` | 空白镜像 | 静态编译程序 | 最小（0MB） |

**选择建议**：
- **开发阶段**：选择功能完整的镜像，方便调试
- **生产环境**：选择精简镜像，减少攻击面
- **特定语言**：选择官方语言镜像，省去安装步骤

### 2.4 多阶段构建


**什么是多阶段构建**：在一个Dockerfile中使用多个FROM指令，实现**编译环境和运行环境分离**。

```dockerfile
# 第一阶段：编译阶段
FROM golang:1.19 AS builder
COPY . /src
WORKDIR /src
RUN go build -o app main.go

# 第二阶段：运行阶段
FROM alpine:latest
RUN apk add --no-cache ca-certificates
COPY --from=builder /src/app /app
CMD ["/app"]
```

**优势分析**：
```
传统方式问题：                    多阶段构建解决：
┌─────────────────┐             ┌──────────┐    ┌──────────┐
│   完整镜像      │             │ 构建镜像 │    │ 运行镜像 │
│ - 源代码        │    ──→      │ - 源代码 │    │ - 可执行文件│
│ - 编译工具      │             │ - 编译器 │    │ - 运行库  │
│ - 可执行文件    │             │ - 依赖库 │    │ (体积更小) │
│ (体积很大)      │             └──────────┘    └──────────┘
└─────────────────┘

结果：镜像体积从几GB减少到几十MB
```

---

## 3. ⚡ RUN执行命令指令


### 3.1 RUN指令的作用


**核心作用**：RUN指令用于**在镜像构建过程中执行命令**，比如安装软件、创建目录、下载文件等。

> 🔧 **形象比喻**：RUN就像装修房子时的施工步骤，每个RUN指令都是一个具体的施工操作

### 3.2 两种执行形式


**Shell形式**（推荐日常使用）：
```dockerfile
RUN <命令>
# 实际执行：/bin/sh -c "<命令>"
RUN apt-get update
RUN echo "Hello World" > /tmp/hello.txt
```

**Exec形式**（精确控制）：
```dockerfile
RUN ["可执行文件", "参数1", "参数2"]
# 直接执行，不通过shell
RUN ["/bin/bash", "-c", "apt-get update"]
```

### 3.3 常见使用场景


**软件安装示例**：
```dockerfile
# Ubuntu/Debian系统
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Alpine系统
RUN apk add --no-cache \
    python3 \
    py3-pip \
    curl

# CentOS/RHEL系统
RUN yum update -y && yum install -y \
    python3 \
    python3-pip \
    curl \
    && yum clean all
```

**文件操作示例**：
```dockerfile
# 创建目录
RUN mkdir -p /app/logs /app/config

# 设置权限
RUN chmod +x /app/start.sh

# 创建用户
RUN useradd -m -s /bin/bash appuser
```

### 3.4 RUN指令优化技巧


**❌ 不推荐写法**（产生过多镜像层）：
```dockerfile
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y curl
RUN rm -rf /var/lib/apt/lists/*
# 结果：4个镜像层，体积较大
```

**✅ 推荐写法**（合并命令，减少层数）：
```dockerfile
RUN apt-get update \
    && apt-get install -y \
        python3 \
        curl \
    && rm -rf /var/lib/apt/lists/*
# 结果：1个镜像层，体积更小
```

**优化要点**：
- 使用 `&&` 连接相关命令
- 使用 `\` 换行保持可读性
- 及时清理缓存文件
- 将相关操作合并到一个RUN中

---

## 4. 📂 COPY复制文件指令


### 4.1 COPY指令的作用


**核心作用**：COPY指令用于**将宿主机的文件或目录复制到镜像中**，是最常用的文件传输方式。

> 📋 **通俗理解**：COPY就像是搬家时把东西从旧房子搬到新房子，简单直接

### 4.2 基本语法格式


**语法形式**：
```dockerfile
COPY <源路径> <目标路径>
COPY ["<源路径1>", "<源路径2>", ..., "<目标路径>"]
```

**路径说明**：
```
源路径：相对于构建上下文目录（通常是Dockerfile所在目录）
目标路径：容器内的绝对路径或相对于WORKDIR的路径
```

### 4.3 常用复制场景


**复制单个文件**：
```dockerfile
# 复制配置文件
COPY app.conf /etc/app/app.conf

# 复制脚本文件
COPY start.sh /usr/local/bin/start.sh
```

**复制目录**：
```dockerfile
# 复制整个目录
COPY ./src /app/src

# 复制当前目录所有文件
COPY . /app
```

**复制多个文件**：
```dockerfile
# 使用通配符
COPY *.txt /tmp/

# 明确指定多个文件
COPY package.json package-lock.json /app/
```

### 4.4 文件权限和所有者


**权限继承规则**：
```
源文件权限    →    目标文件权限
755          →    755（保持不变）
644          →    644（保持不变）

默认所有者：root用户
```

**设置特定权限**：
```dockerfile
# 先复制，再设置权限
COPY start.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/start.sh

# 设置所有者
RUN chown appuser:appgroup /app/config.ini
```

### 4.5 .dockerignore文件


**作用**：类似`.gitignore`，指定构建时忽略的文件和目录。

**.dockerignore示例**：
```
# 忽略版本控制
.git
.gitignore

# 忽略临时文件
*.tmp
*.log
.DS_Store

# 忽略开发相关
node_modules
.env.local
coverage/

# 忽略文档
README.md
docs/
```

**文件结构对比**：
```
项目目录：                    实际复制到镜像：
├── src/                     ├── src/
├── docs/          ──→       ├── package.json
├── package.json             └── start.sh
├── README.md               
├── .git/                   （docs、README.md、.git被忽略）
└── start.sh
```

---

## 5. 📦 ADD高级复制指令


### 5.1 ADD与COPY的区别


**功能对比**：

| 功能 | **COPY** | **ADD** |
|------|---------|---------|
| 🔸 **基础复制** | ✅ 支持 | ✅ 支持 |
| 🔸 **自动解压** | ❌ 不支持 | ✅ 支持tar文件 |
| 🔸 **URL下载** | ❌ 不支持 | ✅ 支持HTTP/HTTPS |
| 🔸 **安全性** | ✅ 更安全 | ⚠️ 可能有风险 |
| 🔸 **透明度** | ✅ 行为明确 | ⚠️ 行为复杂 |

### 5.2 ADD的特殊功能


**自动解压功能**：
```dockerfile
# ADD会自动解压tar文件
ADD app.tar.gz /opt/
# 结果：解压到/opt/目录下

# COPY不会解压，只是复制
COPY app.tar.gz /opt/
# 结果：/opt/app.tar.gz文件
```

**URL下载功能**：
```dockerfile
# 从网络下载文件
ADD https://github.com/user/repo/archive/main.tar.gz /tmp/

# 等效的COPY方式（更明确）
RUN curl -O https://github.com/user/repo/archive/main.tar.gz \
    && tar -xzf main.tar.gz -C /opt \
    && rm main.tar.gz
```

### 5.3 使用建议


**推荐使用原则**：

> 💡 **最佳实践**：能用COPY就用COPY，只有需要特殊功能时才用ADD

```dockerfile
# ✅ 推荐：简单文件复制用COPY
COPY app.py /app/

# ✅ 推荐：需要解压时用ADD
ADD app.tar.gz /opt/

# ❌ 不推荐：用ADD做简单复制
ADD app.py /app/

# ❌ 不推荐：用ADD下载（不透明）
ADD https://example.com/file.tar.gz /tmp/
```

**安全考虑**：
```
COPY的优势：
- 行为简单明确
- 不执行额外操作
- 更容易审核和理解

ADD的风险：
- 自动解压可能带来安全风险
- URL下载可能失败或被劫持
- 行为不够透明
```

---

## 6. 📁 WORKDIR工作目录设置


### 6.1 WORKDIR的作用


**核心作用**：WORKDIR用于**设置工作目录**，后续的RUN、CMD、COPY等指令都会在此目录下执行。

> 🏠 **形象比喻**：WORKDIR就像设置"当前所在的房间"，之后的操作都在这个房间里进行

### 6.2 基本使用方法


**语法格式**：
```dockerfile
WORKDIR <路径>
```

**基本示例**：
```dockerfile
# 设置工作目录
WORKDIR /app

# 后续操作都在/app目录下
COPY . .                    # 等价于 COPY . /app
RUN npm install            # 在/app目录下执行
CMD ["node", "index.js"]   # 在/app目录下运行
```

### 6.3 路径处理规则


**绝对路径vs相对路径**：
```dockerfile
# 绝对路径（推荐）
WORKDIR /app
WORKDIR /var/log

# 相对路径（基于当前WORKDIR）
WORKDIR /app
WORKDIR src        # 实际路径：/app/src
WORKDIR ../config  # 实际路径：/app/config
```

**目录自动创建**：
```dockerfile
WORKDIR /path/to/nonexistent/directory
# Docker会自动创建整个路径，等价于：
# RUN mkdir -p /path/to/nonexistent/directory
```

### 6.4 与其他指令的配合


**传统方式 vs WORKDIR方式**：

❌ **传统方式**（繁琐易错）：
```dockerfile
RUN cd /app && npm install
RUN cd /app && npm run build
COPY package.json /app/package.json
CMD cd /app && node index.js
```

✅ **WORKDIR方式**（简洁清晰）：
```dockerfile
WORKDIR /app
RUN npm install
RUN npm run build
COPY package.json .
CMD ["node", "index.js"]
```

### 6.5 最佳实践


**目录结构规划**：
```dockerfile
# 应用程序目录
WORKDIR /app

# 日志目录
WORKDIR /var/log/app

# 配置目录
WORKDIR /etc/app

# 数据目录
WORKDIR /data
```

**权限考虑**：
```dockerfile
# 创建普通用户和目录
RUN groupadd -r appgroup && useradd -r -g appgroup appuser
WORKDIR /app
RUN chown appuser:appgroup /app
USER appuser
```

---

## 7. 🌐 EXPOSE端口暴露声明


### 7.1 EXPOSE的作用和误区


**核心作用**：EXPOSE指令用于**声明容器监听的端口**，但它本身**不会发布端口**。

> ⚠️ **重要误区**：很多人认为EXPOSE会自动开放端口给外部访问，实际上它只是一个"说明书"

### 7.2 EXPOSE的真正含义


**声明性质**：
```dockerfile
EXPOSE 80
EXPOSE 443
EXPOSE 3306

# 作用：
# 1. 告诉其他开发者这个镜像使用哪些端口
# 2. 为docker run -P 提供默认端口列表
# 3. 容器间通信时的端口参考
```

**实际端口发布**：
```bash
# EXPOSE只是声明，真正开放端口需要运行时指定
docker run -p 8080:80 nginx    # 将容器80端口映射到主机8080
docker run -P nginx            # 自动映射EXPOSE声明的端口
```

### 7.3 端口声明语法


**基本语法**：
```dockerfile
EXPOSE <端口号>[/<协议>]
```

**具体示例**：
```dockerfile
# 声明HTTP端口
EXPOSE 80

# 声明HTTPS端口
EXPOSE 443

# 声明TCP端口（默认）
EXPOSE 3306

# 声明UDP端口
EXPOSE 53/udp

# 声明多个端口
EXPOSE 80 443 3306
```

### 7.4 端口映射实践


**端口映射对照表**：

| Docker命令 | **效果** | **访问方式** |
|-----------|---------|-------------|
| `docker run nginx` | 容器内部80端口运行 | 无法从外部访问 |
| `docker run -p 8080:80 nginx` | 主机8080→容器80 | `localhost:8080` |
| `docker run -P nginx` | 自动映射EXPOSE端口 | `localhost:随机端口` |

**实际应用场景**：
```dockerfile
# Web应用
FROM node:16-alpine
WORKDIR /app
COPY . .
RUN npm install
EXPOSE 3000           # 声明应用端口
CMD ["npm", "start"]
```

```bash
# 运行时映射端口
docker build -t myapp .
docker run -p 8080:3000 myapp    # 外部通过8080访问
```

### 7.5 端口安全考虑


**安全原则**：
```
内部通信：容器间可直接通过EXPOSE端口通信
外部访问：必须显式映射端口才能从外部访问
最小权限：只暴露必要的端口
```

**网络隔离示例**：
```yaml
# docker-compose.yml
version: '3'
services:
  web:
    build: .
    ports:
      - "8080:3000"    # 外部可访问
  database:
    image: mysql
    expose:
      - "3306"         # 只有容器间可访问
```

---

## 8. 🔧 ENV环境变量设置


### 8.1 ENV指令的作用


**核心作用**：ENV指令用于**设置环境变量**，这些变量在镜像构建和容器运行时都可以使用。

> 💡 **通俗理解**：ENV就像给容器设置"系统设置"，告诉程序一些重要的配置信息

### 8.2 基本语法格式


**两种语法形式**：
```dockerfile
# 形式1：一次设置一个变量
ENV <key> <value>

# 形式2：一次设置多个变量
ENV <key1>=<value1> <key2>=<value2> ...
```

**实际示例**：
```dockerfile
# 单个变量设置
ENV NODE_ENV production
ENV PORT 3000

# 多个变量设置
ENV NODE_ENV=production \
    PORT=3000 \
    DEBUG=false
```

### 8.3 环境变量的使用


**在Dockerfile中使用**：
```dockerfile
ENV APP_HOME=/app
ENV APP_USER=appuser

WORKDIR $APP_HOME          # 使用变量
RUN useradd $APP_USER      # 使用变量
COPY . $APP_HOME/          # 使用变量
```

**在应用程序中使用**：
```javascript
// Node.js中读取环境变量
const port = process.env.PORT || 3000;
const env = process.env.NODE_ENV || 'development';

console.log(`Server running on port ${port} in ${env} mode`);
```

```python
# Python中读取环境变量
import os

port = int(os.environ.get('PORT', 3000))
env = os.environ.get('NODE_ENV', 'development')

print(f"Server running on port {port} in {env} mode")
```

### 8.4 常见环境变量用途


**应用配置类**：
```dockerfile
# 运行环境
ENV NODE_ENV=production
ENV PYTHON_ENV=production

# 服务端口
ENV PORT=3000
ENV HOST=0.0.0.0

# 数据库连接
ENV DB_HOST=localhost
ENV DB_PORT=5432
ENV DB_NAME=myapp
```

**系统配置类**：
```dockerfile
# 语言和编码
ENV LANG=en_US.UTF-8
ENV LC_ALL=en_US.UTF-8

# 时区设置
ENV TZ=Asia/Shanghai

# PATH路径
ENV PATH=/usr/local/bin:$PATH
```

### 8.5 环境变量的覆盖


**覆盖优先级**（从高到低）：

```
运行时设置：docker run -e PORT=8080 myapp
├─ 覆盖 ─→ docker-compose环境变量
├─ 覆盖 ─→ Dockerfile中的ENV
└─ 覆盖 ─→ 基础镜像的默认值
```

**实际覆盖示例**：
```dockerfile
# Dockerfile中设置
ENV PORT=3000
```

```bash
# 运行时覆盖
docker run -e PORT=8080 myapp    # 实际使用8080端口
```

```yaml
# docker-compose.yml中覆盖
version: '3'
services:
  app:
    build: .
    environment:
      - PORT=9000              # 实际使用9000端口
```

### 8.6 环境变量最佳实践


**安全考虑**：
```dockerfile
# ❌ 不要在ENV中设置敏感信息
ENV DB_PASSWORD=secret123      # 明文密码，不安全

# ✅ 推荐在运行时传入
ENV DB_PASSWORD=""             # 占位符
```

```bash
# 运行时安全传入敏感信息
docker run -e DB_PASSWORD=real_secret myapp
```

**默认值设置**：
```dockerfile
# 设置合理的默认值
ENV PORT=3000 \
    NODE_ENV=production \
    LOG_LEVEL=info \
    TIMEOUT=30
```

---

## 9. 🎯 指令最佳实践


### 9.1 层优化策略


**减少镜像层数**：
```dockerfile
# ❌ 不推荐：过多层
FROM ubuntu:20.04
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y pip
RUN pip install flask
COPY app.py /app/
# 结果：6个层

# ✅ 推荐：合并相关操作
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    && pip install flask \
    && rm -rf /var/lib/apt/lists/*
COPY app.py /app/
# 结果：3个层
```

### 9.2 缓存优化策略


**利用构建缓存**：
```dockerfile
# ✅ 推荐：依赖文件优先复制
FROM node:16-alpine
WORKDIR /app

# 先复制依赖文件（变化较少）
COPY package*.json ./
RUN npm install

# 再复制源代码（变化较多）
COPY . .
RUN npm run build

# 好处：源代码变化时，npm install可以使用缓存
```

### 9.3 安全最佳实践


**非root用户运行**：
```dockerfile
FROM node:16-alpine

# 创建普通用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 设置工作目录和权限
WORKDIR /app
COPY --chown=nextjs:nodejs . .

# 切换到普通用户
USER nextjs

EXPOSE 3000
CMD ["node", "server.js"]
```

### 9.4 完整示例对比


**❌ 不推荐的写法**：
```dockerfile
FROM ubuntu:20.04
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
ADD https://github.com/user/repo/archive/main.tar.gz /tmp/
RUN cd /tmp && tar -xzf main.tar.gz
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
ENV DEBUG true
EXPOSE 5000
CMD python app.py
```

**✅ 推荐的写法**：
```dockerfile
FROM python:3.9-slim

# 设置环境变量
ENV PYTHONPATH=/app \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1 \
    DEBUG=false

# 安装系统依赖
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 创建工作目录
WORKDIR /app

# 复制依赖文件并安装（利用缓存）
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN groupadd -r appuser && useradd -r -g appuser appuser
RUN chown -R appuser:appuser /app
USER appuser

# 声明端口
EXPOSE 5000

# 启动命令
CMD ["python", "app.py"]
```

---

## 10. 📋 核心要点总结


### 10.1 必须掌握的核心指令


```
🔸 FROM：指定基础镜像，构建的起点
🔸 RUN：执行构建时命令，安装软件和配置环境
🔸 COPY：复制文件到镜像，简单直接的文件传输
🔸 ADD：高级复制功能，支持解压和URL下载
🔸 WORKDIR：设置工作目录，后续操作的基础
🔸 EXPOSE：声明端口，提供服务接口信息
🔸 ENV：设置环境变量，配置应用运行参数
```

### 10.2 关键理解要点


**🔹 分层理解**
```
每个指令创建一个镜像层：
- 合并相关操作减少层数
- 利用缓存提高构建效率
- 变化频繁的操作放在后面
```

**🔹 路径和权限**
```
工作目录概念：
- WORKDIR设置当前目录
- COPY/ADD的目标路径基于WORKDIR
- 注意文件权限和用户权限
```

**🔹 优化原则**
```
构建效率：
- 利用镜像层缓存
- 合并相关RUN指令
- 选择合适的基础镜像

安全考虑：
- 使用非root用户
- 避免在ENV中设置敏感信息
- 及时清理临时文件和缓存
```

### 10.3 实际应用指导


**选择策略**：
- **COPY vs ADD**：能用COPY就用COPY，特殊需求才用ADD
- **基础镜像**：开发用完整版，生产用精简版
- **环境变量**：合理设置默认值，运行时可覆盖

**调试技巧**：
- 使用 `docker build --no-cache` 禁用缓存调试
- 使用 `docker history <镜像>` 查看层信息
- 使用多阶段构建分离编译和运行环境

**性能优化**：
- 合理规划Dockerfile指令顺序
- 利用.dockerignore减少构建上下文
- 选择合适的基础镜像大小

**核心记忆**：
- Dockerfile是镜像构建的蓝图
- 每个指令都有特定用途和最佳实践
- 分层构建带来缓存优势也要合理控制
- 安全和性能同样重要，需要平衡考虑