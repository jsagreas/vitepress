---
title: 10、Docker系统资源配置
---
## 📚 目录

1. [Docker配置文件基础概念](#1-Docker配置文件基础概念)
2. [daemon.json核心配置详解](#2-daemon.json核心配置详解)
3. [网络下载配置优化](#3-网络下载配置优化)
4. [容器运行时配置](#4-容器运行时配置)
5. [系统资源管理配置](#5-系统资源管理配置)
6. [Swarm集群配置](#6-Swarm集群配置)
7. [实践配置示例](#7-实践配置示例)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🐳 Docker配置文件基础概念


### 1.1 什么是daemon.json配置文件


> 📖 **核心概念**  
> `daemon.json`是Docker守护进程的主配置文件，相当于Docker的"总控制台"，用来告诉Docker怎样工作

**💡 生活类比**：
想象Docker是一台复杂的工厂机器，`daemon.json`就是这台机器的操作手册和设置面板。通过这个文件，我们可以：
- 🏭 调整机器的工作效率（并发数量）
- ⚡ 设置安全等级（OOM保护）
- 🔧 选择不同的工作模式（运行时）
- 🌐 配置对外的通信方式（网络设置）

### 1.2 配置文件位置和作用


**📍 文件位置**：
```
Linux系统：/etc/docker/daemon.json
Windows系统：C:\ProgramData\Docker\config\daemon.json
macOS系统：~/.docker/daemon.json
```

**🎯 核心作用**：
- **系统级配置**：影响整个Docker系统的行为
- **持久化设置**：重启Docker后配置仍然生效  
- **性能调优**：优化Docker的运行性能
- **安全管控**：配置安全相关参数

### 1.3 配置文件的基本结构


```json
{
  "key1": "value1",
  "key2": 123,
  "key3": ["item1", "item2"],
  "key4": {
    "subkey": "subvalue"
  }
}
```

**🔍 重要提醒**：
- JSON格式要求严格，不能有多余的逗号
- 字符串必须用双引号包围
- 配置修改后需要重启Docker才能生效

---

## 2. ⚙️ daemon.json核心配置详解


### 2.1 配置文件完整示例


```json
{
  "max-concurrent-downloads": 6,
  "max-concurrent-uploads": 5,
  "max-download-attempts": 5,
  "containerd-namespace": "moby",
  "containerd-plugins-namespace": "plugins.moby",
  "oom-score-adjust": -500,
  "init": true,
  "init-path": "/usr/libexec/docker-init",
  "runtimes": {
    "custom-runtime": {
      "path": "/usr/local/bin/my-runtime"
    }
  },
  "default-runtime": "runc",
  "node-generic-resources": ["NVIDIA-GPU=2"],
  "swarm-default-advertise-addr": "192.168.1.100"
}
```

### 2.2 基础理解框架


**🏗️ 配置分类**：

```
Docker配置架构
├── 网络传输配置
│   ├── max-concurrent-downloads（下载控制）
│   ├── max-concurrent-uploads（上传控制）  
│   └── max-download-attempts（重试控制）
│
├── 容器运行时配置
│   ├── containerd-namespace（容器命名空间）
│   ├── containerd-plugins-namespace（插件命名空间）
│   ├── runtimes（运行时选择）
│   └── default-runtime（默认运行时）
│
├── 系统资源配置
│   ├── oom-score-adjust（内存管理）
│   ├── init（初始化进程）
│   ├── init-path（初始化路径）
│   └── node-generic-resources（节点资源）
│
└── 集群配置
    └── swarm-default-advertise-addr（集群通信）
```

---

## 3. 📡 网络下载配置优化


### 3.1 并发下载控制


**🔸 max-concurrent-downloads**

> 💡 **通俗解释**：同时下载镜像层的最大数量，就像同时开几个下载窗口

```json
{
  "max-concurrent-downloads": 6
}
```

**🎯 配置意义**：
- **默认值**：`3` - 比较保守的设置
- **推荐值**：`6-10` - 平衡性能和稳定性
- **高性能**：`15+` - 网络条件好时可以设置更高

**📊 性能对比**：

| 并发数 | 适用场景 | 下载速度 | 系统负载 |
|-------|---------|---------|---------|
| `3` | 🟢 **网络较慢** | 稳定但较慢 | 低负载 |
| `6` | 🟡 **一般网络** | 平衡性能 | 中等负载 |
| `10` | 🟠 **高速网络** | 快速下载 | 较高负载 |
| `15+` | 🔴 **企业级网络** | 极速下载 | 高负载 |

### 3.2 并发上传控制


**🔸 max-concurrent-uploads**

> 💡 **通俗解释**：推送镜像到仓库时同时上传的层数，影响push操作的速度

```json
{
  "max-concurrent-uploads": 5
}
```

**🚀 实际应用场景**：
```bash
# 当你执行这个命令时，配置就起作用了
docker push myapp:latest

# 上传过程中会同时传输5个镜像层
# 而不是一个一个依次上传
```

### 3.3 下载重试机制


**🔸 max-download-attempts**

> 💡 **通俗解释**：下载失败时最多重试几次，避免网络抖动导致下载失败

```json
{
  "max-download-attempts": 5
}
```

**🔄 重试机制示意**：
```
下载尝试流程：
尝试1 ──失败──> 尝试2 ──失败──> 尝试3 ──成功──> 完成
   |              |              |
 网络抖动        临时故障        重连成功
```

**⚠️ 配置建议**：
- **不稳定网络**：设置为 `8-10`
- **稳定网络**：设置为 `3-5`  
- **企业内网**：设置为 `2-3`

---

## 4. 🏃‍♂️ 容器运行时配置


### 4.1 容器命名空间配置


**🔸 containerd-namespace**

> 💡 **通俗解释**：containerd的工作空间名称，就像给容器分配一个专门的房间

```json
{
  "containerd-namespace": "moby"
}
```

**🏠 命名空间作用**：
- **隔离容器**：不同命名空间的容器互不干扰
- **资源管理**：便于统一管理同一类型的容器
- **默认值**：`moby` - Docker的默认命名空间

### 4.2 插件命名空间配置


**🔸 containerd-plugins-namespace**

> 💡 **通俗解释**：containerd插件的专用空间，相当于插件的工作目录

```json
{
  "containerd-plugins-namespace": "plugins.moby"
}
```

**🔌 插件空间特点**：
- **插件隔离**：不同插件在不同空间运行
- **避免冲突**：防止插件之间相互影响
- **统一管理**：便于插件的安装和卸载

### 4.3 容器运行时选择


**🔸 runtimes 和 default-runtime**

> 💡 **通俗解释**：运行时就像不同品牌的发动机，可以选择用哪个来驱动容器

```json
{
  "runtimes": {
    "nvidia": {
      "path": "/usr/bin/nvidia-container-runtime",
      "runtimeArgs": []
    },
    "custom-runtime": {
      "path": "/usr/local/bin/my-runtime"
    }
  },
  "default-runtime": "runc"
}
```

**🚗 运行时类比**：

```
容器运行时选择
├── runc ──────────> 标准汽油发动机（默认）
├── nvidia ────────> 涡轮增压发动机（GPU加速）
├── kata ──────────> 混合动力发动机（更安全）
└── custom ────────> 定制改装发动机（特殊需求）
```

**📋 常用运行时对比**：

| 运行时 | 特点 | 适用场景 | 性能 |
|-------|------|---------|------|
| `runc` | 🟢 **标准运行时** | 一般应用 | 高性能 |
| `nvidia` | 🟡 **GPU支持** | 机器学习 | GPU加速 |
| `kata` | 🟠 **安全隔离** | 安全要求高 | 稍低性能 |
| `gvisor` | 🔴 **沙箱隔离** | 多租户环境 | 较低性能 |

---

## 5. 💾 系统资源管理配置


### 5.1 内存溢出保护


**🔸 oom-score-adjust**

> 💡 **通俗解释**：当系统内存不足时，告诉Linux系统"请不要优先杀掉Docker"

```json
{
  "oom-score-adjust": -500
}
```

**🛡️ OOM保护机制**：

```
Linux OOM Killer 工作原理
系统内存不足 ──> 扫描所有进程 ──> 计算OOM分数 ──> 杀掉高分进程

OOM分数计算：
普通进程：    0 到 1000  (分数越高越容易被杀)
Docker设置： -500       (分数较低，不容易被杀)
系统进程：   -1000      (几乎不会被杀)
```

**⚖️ 分数选择指导**：
- **-1000**：绝对不被杀掉（不推荐，可能导致系统崩溃）
- **-500**：很不容易被杀掉（推荐生产环境）
- **-100**：不太容易被杀掉（适合测试环境）
- **0**：正常优先级（默认值）

### 5.2 初始化进程配置


**🔸 init 和 init-path**

> 💡 **通俗解释**：init进程就像容器内的"管家"，负责清理僵尸进程

```json
{
  "init": true,
  "init-path": "/usr/libexec/docker-init"
}
```

**👻 僵尸进程问题**：

```
没有init进程的情况：
父进程 ──创建──> 子进程 ──意外退出──> 僵尸进程 ──堆积──> 资源泄漏

有init进程的情况：  
父进程 ──创建──> 子进程 ──意外退出──> init进程清理 ──> 资源释放
```

**🧹 init进程的作用**：
- **清理僵尸进程**：自动回收死掉的子进程
- **信号转发**：正确处理停止信号
- **资源管理**：防止资源泄漏

### 5.3 节点资源声明


**🔸 node-generic-resources**

> 💡 **通俗解释**：告诉Docker这台机器有哪些特殊资源，比如GPU、特殊硬件等

```json
{
  "node-generic-resources": [
    "NVIDIA-GPU=2",
    "SSD-Storage=4",
    "Custom-Hardware=1"
  ]
}
```

**🎯 资源声明示例**：

```
服务器资源标识
├── GPU资源
│   ├── NVIDIA-GPU=4    (4块NVIDIA GPU)
│   └── AMD-GPU=2       (2块AMD GPU)
├── 存储资源  
│   ├── SSD-Storage=8   (8块SSD硬盘)
│   └── NVMe-Storage=2  (2块NVMe硬盘)
└── 特殊硬件
    ├── FPGA=1          (1块FPGA卡)
    └── TPU=2           (2块TPU芯片)
```

---

## 6. 🌐 Swarm集群配置


### 6.1 集群广播地址配置


**🔸 swarm-default-advertise-addr**

> 💡 **通俗解释**：告诉其他节点"我的地址是这个"，就像留下自己的联系方式

```json
{
  "swarm-default-advertise-addr": "192.168.1.100"
}
```

**📡 集群通信示意**：

```
Swarm集群通信架构
Manager节点(192.168.1.100)
    |
    |── 广播自己的地址
    |
    ├── Worker节点(192.168.1.101) ──连接──> 192.168.1.100
    ├── Worker节点(192.168.1.102) ──连接──> 192.168.1.100  
    └── Worker节点(192.168.1.103) ──连接──> 192.168.1.100
```

**🔍 地址选择原则**：
- **内网地址**：集群在同一内网中
- **固定IP**：不要使用DHCP分配的动态IP
- **可访问性**：确保所有节点都能访问到这个地址

---

## 7. 🛠️ 实践配置示例


### 7.1 开发环境配置


> 💡 **场景说明**：个人开发机器，注重下载速度和稳定性

```json
{
  "max-concurrent-downloads": 8,
  "max-concurrent-uploads": 3,
  "max-download-attempts": 5,
  "oom-score-adjust": -100,
  "init": true,
  "default-runtime": "runc"
}
```

**📝 配置说明**：
- 🔸 **适中的并发数**：平衡速度和稳定性
- 🔸 **基础OOM保护**：避免Docker被意外杀掉
- 🔸 **启用init进程**：防止僵尸进程堆积

### 7.2 生产环境配置


> 💡 **场景说明**：生产服务器，注重稳定性和安全性

```json
{
  "max-concurrent-downloads": 6,
  "max-concurrent-uploads": 5,
  "max-download-attempts": 8,
  "containerd-namespace": "production",
  "oom-score-adjust": -500,
  "init": true,
  "init-path": "/usr/libexec/docker-init",
  "default-runtime": "runc",
  "node-generic-resources": ["SSD-Storage=4"]
}
```

**🏭 生产环境特点**：
- ⚡ **保守的并发设置**：确保系统稳定
- 🛡️ **强化OOM保护**：Docker不容易被杀掉
- 🔧 **资源声明**：便于容器调度
- 📛 **独立命名空间**：与其他环境隔离

### 7.3 GPU服务器配置


> 💡 **场景说明**：机器学习服务器，需要GPU支持

```json
{
  "max-concurrent-downloads": 10,
  "max-concurrent-uploads": 6,
  "max-download-attempts": 5,
  "runtimes": {
    "nvidia": {
      "path": "/usr/bin/nvidia-container-runtime"
    }
  },
  "default-runtime": "nvidia",
  "oom-score-adjust": -600,
  "init": true,
  "node-generic-resources": [
    "NVIDIA-GPU=4",
    "GPU-Memory=32GB"
  ]
}
```

**🚀 GPU配置特点**：
- 🎮 **NVIDIA运行时**：支持GPU计算
- 📊 **GPU资源声明**：标识GPU数量和内存
- 🔒 **更强OOM保护**：GPU任务通常很重要

### 7.4 配置应用步骤


**📋 应用配置的完整流程**：

```bash
# 1. 备份现有配置（如果存在）
sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.bak

# 2. 创建或编辑配置文件
sudo nano /etc/docker/daemon.json

# 3. 验证JSON格式是否正确
python -m json.tool /etc/docker/daemon.json

# 4. 重启Docker服务
sudo systemctl restart docker

# 5. 验证配置是否生效
docker info | grep -E "(Max concurrent|OOM|Runtime)"
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的配置概念


```
🔸 daemon.json：Docker的总配置文件，控制Docker的工作方式
🔸 并发控制：通过max-concurrent-*参数优化网络传输速度
🔸 命名空间：containerd-namespace提供容器隔离和管理
🔸 运行时选择：runtimes配置决定容器的执行引擎
🔸 OOM保护：oom-score-adjust防止Docker被系统误杀
🔸 集群配置：swarm-default-advertise-addr用于集群通信
```

### 8.2 关键理解要点


**🔹 配置生效机制**：
- 📁 **配置位置**：`/etc/docker/daemon.json`
- 🔄 **生效方式**：重启Docker服务后才生效
- ✅ **验证方法**：通过`docker info`命令查看

**🔹 性能优化策略**：
- 🚀 **网络优化**：调整并发下载/上传参数
- 🛡️ **稳定性优化**：配置OOM保护和重试机制
- ⚙️ **资源优化**：合理选择运行时和声明资源

**🔹 环境适配原则**：
- 🏠 **开发环境**：注重下载速度，配置相对激进
- 🏭 **生产环境**：注重稳定性，配置相对保守
- 🎮 **特殊环境**：根据硬件特性选择合适运行时

### 8.3 实际应用价值


**💼 常见应用场景**：
- **镜像仓库优化**：提高镜像下载和推送速度
- **容器化部署**：确保生产环境的稳定运行
- **GPU计算**：支持机器学习和深度学习任务
- **集群管理**：配置Docker Swarm集群节点

**🔧 运维实践要点**：
- **配置管理**：版本控制配置文件，便于回滚
- **监控观察**：关注配置变更后的系统表现
- **渐进调优**：逐步调整参数，观察效果
- **文档记录**：记录配置更改的原因和效果

**🧠 记忆要点**：
- daemon.json是Docker的"大脑"，控制Docker的行为
- 并发参数影响网络性能，OOM参数影响系统稳定性
- 不同环境需要不同的配置策略
- 配置修改后记得重启Docker服务

**核心记忆口诀**：
- 📝 daemon.json是核心，重启生效要记清
- ⚡ 并发下载提速度，OOM保护保稳定  
- 🏃‍♂️ 运行时选择看需求，命名空间来隔离
- 🌐 集群配置通信畅，资源声明调度准