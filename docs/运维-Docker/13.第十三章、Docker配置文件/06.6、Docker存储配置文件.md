---
title: 6、Docker存储配置文件
---
## 📚 目录

1. [Docker配置文件基础](#1-docker配置文件基础)
2. [存储驱动深入理解](#2-存储驱动深入理解)
3. [daemon.json配置详解](#3-daemonjson配置详解)
4. [常用存储驱动配置](#4-常用存储驱动配置)
5. [数据卷与挂载配置](#5-数据卷与挂载配置)
6. [实际配置案例](#6-实际配置案例)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🐳 Docker配置文件基础


### 1.1 什么是Docker配置文件


> 💡 **简单理解**：Docker配置文件就像是Docker的"设置界面"，用来告诉Docker如何工作

**核心配置文件位置**：
- **Linux**: `/etc/docker/daemon.json`
- **Windows**: `C:\ProgramData\docker\config\daemon.json`
- **macOS**: `~/.docker/daemon.json`

```
Docker配置文件的作用就像：
🏠 房子的装修图纸 → 告诉工人怎么装修
📱 手机的系统设置 → 告诉手机怎么运行
🐳 Docker的配置文件 → 告诉Docker怎么管理容器
```

### 1.2 为什么需要配置文件


**❌ 不用配置文件的问题**：
- Docker只能用默认设置
- 存储空间可能不够用
- 性能可能不是最优的
- 无法适配特殊环境需求

**✅ 使用配置文件的好处**：
- **自定义存储位置**：把Docker数据放到大硬盘上
- **选择最佳存储驱动**：提升性能
- **调整资源限制**：避免Docker占用太多资源
- **配置网络设置**：适应不同网络环境

### 1.3 配置文件的基本格式


```json
{
  "key": "value",
  "另一个设置": "另一个值",
  "列表设置": ["项目1", "项目2"]
}
```

> ⚠️ **重要提醒**：配置文件必须是**标准的JSON格式**，最后一个配置项后面不能有逗号！

---

## 2. 💾 存储驱动深入理解


### 2.1 什么是存储驱动


**🔸 通俗解释**：
存储驱动就像是Docker管理文件的"管家"，负责：
- 🗂️ 如何存放容器的文件
- 📦 如何管理镜像的层次结构
- 🔄 如何处理文件的读写操作

```
类比理解存储驱动：

📚 图书馆管理员（存储驱动）
├── 📖 按类别整理书籍（管理镜像层）
├── 🏷️ 给每本书编号（文件系统标识）
├── 📝 记录借阅信息（容器状态）
└── 🔍 快速找到需要的书（高效访问）

不同的管理员（存储驱动）有不同的管理方式！
```

### 2.2 Docker镜像层的概念


**镜像层就像搭积木**：

```
Docker镜像的层次结构：

    应用层 ←─ 你的程序代码
    ──────
    依赖层 ←─ 应用运行需要的库
    ──────
    系统层 ←─ 操作系统基础
    ──────
    基础层 ←─ 最底层的Linux内核
```

**📝 为什么要分层**：
- **① 节省空间**：多个镜像可以共享相同的层
- **② 加快下载**：只需要下载变化的层
- **③ 提升效率**：不需要重复存储相同内容

### 2.3 主流存储驱动对比


| 存储驱动 | **适用场景** | **性能特点** | **兼容性** |
|---------|-------------|-------------|-----------|
| `overlay2` | **🏆 推荐使用** | `读写性能优秀` | `Linux 4.0+` |
| `devicemapper` | `Red Hat系统` | `功能丰富但较慢` | `CentOS/RHEL` |
| `aufs` | `老版本Ubuntu` | `稳定但性能一般` | `Ubuntu 14.04` |
| `btrfs` | `需要快照功能` | `功能强大但复杂` | `支持Btrfs的系统` |
| `zfs` | `企业级应用` | `可靠性极高` | `支持ZFS的系统` |
| `vfs` | `调试测试用` | `性能最差` | `所有系统` |

> 💡 **新手建议**：99%的情况下使用 `overlay2` 就够了，它是现在的标准选择！

---

## 3. ⚙️ daemon.json配置详解


### 3.1 基础目录配置


```json
{
  "data-root": "/var/lib/docker",
  "exec-root": "/var/run/docker",
  "graph": "/var/lib/docker"
}
```

**🔸 配置项详解**：

**data-root（数据根目录）**：
- **作用**：Docker存放所有数据的根目录
- **包含内容**：镜像、容器、数据卷等
- **使用场景**：系统盘空间不足时，改到大硬盘

**exec-root（执行根目录）**：
- **作用**：存放容器运行时状态信息
- **包含内容**：容器PID、套接字文件等
- **特点**：通常不需要修改

**graph（图层根目录）**：
- **作用**：存储镜像层数据（已废弃，由data-root替代）
- **状态**：保留是为了向后兼容

### 3.2 存储驱动配置


```json
{
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.size=20G",
    "overlay2.override_kernel_check=true"
  ]
}
```

**storage-driver**：
- **含义**：指定使用哪种存储驱动
- **常用值**：`overlay2`（推荐）、`devicemapper`、`aufs`

**storage-opts**：
- **含义**：存储驱动的详细配置选项
- **格式**：字符串数组，每个选项一个字符串

### 3.3 实用配置示例


```json
{
  "data-root": "/home/docker-data",
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "default-shm-size": "128M",
  "userland-proxy": false
}
```

**🔸 配置说明**：
- **data-root**: 数据存储在 `/home/docker-data`（假设这个分区空间大）
- **log-opts**: 限制日志文件大小，避免占用太多空间
- **default-shm-size**: 设置共享内存大小
- **userland-proxy**: 禁用用户代理提升性能

---

## 4. 🗂️ 常用存储驱动配置


### 4.1 overlay2 配置详解


**🏆 为什么overlay2是首选**：
- ✅ **性能最佳**：读写速度快
- ✅ **内存占用少**：效率高
- ✅ **稳定性好**：经过大量测试
- ✅ **支持广泛**：现代Linux系统都支持

```json
{
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.size=50G",
    "overlay2.override_kernel_check=true"
  ]
}
```

**配置参数说明**：
- **overlay2.size**: 限制每个容器的最大存储空间
- **override_kernel_check**: 跳过内核版本检查（谨慎使用）

### 4.2 devicemapper 配置详解


**适用场景**：Red Hat系列系统（CentOS、RHEL）

```json
{
  "storage-driver": "devicemapper",
  "storage-opts": [
    "dm.thinpooldev=/dev/mapper/docker-thinpool",
    "dm.use_deferred_removal=true",
    "dm.use_deferred_deletion=true"
  ]
}
```

**🔸 devicemapper特点**：
- **优点**：功能丰富，支持快照
- **缺点**：配置复杂，性能相对较差
- **建议**：除非系统要求，否则优先选择overlay2

### 4.3 存储驱动选择指南


```
选择存储驱动的决策树：

你的系统支持overlay2吗？
├── ✅ 支持 → 选择 overlay2
└── ❌ 不支持
    ├── CentOS/RHEL系统？
    │   ├── ✅ 是 → 选择 devicemapper
    │   └── ❌ 否 → 检查其他选项
    └── 老版本Ubuntu？
        ├── ✅ 是 → 选择 aufs
        └── ❌ 否 → 选择 vfs（性能差）
```

---

## 5. 📂 数据卷与挂载配置


### 5.1 数据持久化的三种方式


```
Docker数据持久化方式对比：

🗂️ Volume（数据卷）
├── 管理方式：Docker完全管理
├── 存储位置：/var/lib/docker/volumes/
├── 使用场景：数据库文件、应用数据
└── 特点：最安全，推荐使用

📎 Bind Mount（绑定挂载）
├── 管理方式：直接使用主机目录
├── 存储位置：任意主机目录
├── 使用场景：配置文件、源代码
└── 特点：直接访问，但要注意权限

💾 tmpfs（临时文件系统）
├── 管理方式：内存中的临时存储
├── 存储位置：系统内存
├── 使用场景：临时数据、敏感信息
└── 特点：重启后数据丢失
```

### 5.2 Volume配置详解


**创建和使用数据卷**：

```bash
# 创建数据卷
docker volume create my-data

# 查看数据卷信息
docker volume inspect my-data

# 使用数据卷
docker run -v my-data:/app/data nginx
```

**配置文件中的volume设置**：

```json
{
  "data-root": "/var/lib/docker",
  "storage-driver": "overlay2",
  "default-runtime": "runc"
}
```

> 💡 **数据卷的优势**：即使删除容器，数据卷中的数据也会保留！

### 5.3 实际使用建议


**① 数据库应用**：
```bash
# MySQL数据持久化
docker run -d \
  -v mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=password \
  mysql:8.0
```

**② 配置文件管理**：
```bash
# Nginx配置文件绑定
docker run -d \
  -v /host/nginx.conf:/etc/nginx/nginx.conf \
  nginx
```

**③ 临时数据处理**：
```bash
# 使用tmpfs存储临时数据
docker run -d \
  --tmpfs /tmp:rw,size=100m \
  ubuntu
```

---

## 6. 🛠️ 实际配置案例


### 6.1 开发环境配置


**场景**：个人开发机器，需要快速启动容器

```json
{
  "data-root": "/home/docker",
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "default-shm-size": "256M",
  "userland-proxy": false,
  "experimental": true
}
```

**🔸 配置解释**：
- **data-root**: 数据存储到home目录，空间更大
- **log-opts**: 限制日志大小，避免占满磁盘
- **default-shm-size**: 增大共享内存，适合开发调试
- **experimental**: 启用实验性功能

### 6.2 生产环境配置


**场景**：生产服务器，需要稳定可靠

```json
{
  "data-root": "/opt/docker",
  "storage-driver": "overlay2",
  "log-driver": "journald",
  "storage-opts": [
    "overlay2.size=20G"
  ],
  "default-ulimits": {
    "nofile": {
      "Hard": 64000,
      "Name": "nofile",
      "Soft": 64000
    }
  },
  "live-restore": true,
  "userland-proxy": false
}
```

**🔸 生产环境特点**：
- **log-driver**: 使用系统日志，便于集中管理
- **overlay2.size**: 限制容器存储空间
- **live-restore**: Docker重启时保持容器运行
- **default-ulimits**: 设置文件句柄限制

### 6.3 配置文件管理最佳实践


**① 配置文件备份**：
```bash
# 备份当前配置
sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.backup

# 修改配置后重启Docker
sudo systemctl restart docker
```

**② 配置验证**：
```bash
# 检查配置文件语法
cat /etc/docker/daemon.json | python -m json.tool

# 查看Docker信息验证配置
docker info
```

**③ 故障恢复**：
```bash
# 如果配置有问题，恢复备份
sudo cp /etc/docker/daemon.json.backup /etc/docker/daemon.json
sudo systemctl restart docker
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 daemon.json：Docker的主配置文件，控制Docker行为
🔸 存储驱动：管理镜像和容器文件的底层技术
🔸 data-root：Docker存储所有数据的根目录
🔸 overlay2：现代Linux系统的最佳存储驱动选择
🔸 数据卷：容器数据持久化的推荐方式
```

### 7.2 关键理解要点


**🔹 存储驱动的选择逻辑**：
```
决策顺序：
1. 系统兼容性 → 能否正常运行
2. 性能表现 → 读写速度如何
3. 功能需求 → 是否满足特殊需求
4. 维护成本 → 配置管理是否复杂

99%的场景：overlay2 是最佳选择
```

**🔹 配置文件的核心作用**：
```
三个层面的配置：
- 🗂️ 存储层面：数据放哪里，怎么管理
- 🚀 性能层面：如何优化运行效率  
- 🛡️ 安全层面：如何控制资源访问
```

**🔹 数据持久化的重要性**：
```
容器的特点：
- ✅ 启动快速，部署灵活
- ❌ 数据易丢失，重启清空

解决方案：
- 📂 Volume：最安全的数据保存方式
- 📎 Bind Mount：直接使用主机目录
- 💾 tmpfs：临时数据的内存存储
```

### 7.3 实际操作指南


**🎯 新手配置建议**：

**① 基础配置（适合大多数场景）**：
```json
{
  "data-root": "/var/lib/docker",
  "storage-driver": "overlay2",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
```

**② 进阶配置（空间不足时）**：
```json
{
  "data-root": "/home/docker-data",
  "storage-driver": "overlay2",
  "storage-opts": ["overlay2.size=20G"]
}
```

**🔧 配置操作步骤**：
1. **备份现有配置**：`sudo cp /etc/docker/daemon.json /etc/docker/daemon.json.backup`
2. **编辑配置文件**：`sudo vim /etc/docker/daemon.json`
3. **验证JSON格式**：`cat /etc/docker/daemon.json | python -m json.tool`
4. **重启Docker服务**：`sudo systemctl restart docker`
5. **验证配置生效**：`docker info`

**⚠️ 注意事项**：
- **配置前先备份**：避免配置错误导致Docker无法启动
- **JSON格式要正确**：最后一项不能有逗号
- **重启后验证**：确认所有服务正常运行
- **逐步调整**：一次只改一个配置项，便于排查问题

### 7.4 常见问题解决


**❓ Docker启动失败**：
- 检查配置文件JSON格式
- 查看系统日志：`journalctl -u docker.service`
- 恢复备份配置重新尝试

**❓ 存储空间不足**：
- 修改data-root到大硬盘
- 清理无用镜像：`docker system prune`
- 限制日志文件大小

**❓ 容器数据丢失**：
- 使用数据卷持久化重要数据
- 定期备份数据卷内容
- 区分临时数据和持久数据

**核心记忆口诀**：
- 配置文件daemon.json，存储驱动要选好
- overlay2性能佳，data-root空间要够大  
- 数据卷做持久化，备份配置不能少
- JSON格式要正确，重启验证才可靠