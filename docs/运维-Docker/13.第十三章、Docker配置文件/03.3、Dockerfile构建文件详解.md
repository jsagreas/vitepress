---
title: 3、Dockerfile构建文件详解
---
## 📚 目录

1. [什么是Dockerfile](#1-什么是dockerfile)
2. [基础镜像指令FROM](#2-基础镜像指令from)
3. [运行命令指令RUN](#3-运行命令指令run)
4. [文件操作指令COPY与ADD](#4-文件操作指令copy与add)
5. [工作环境设置指令](#5-工作环境设置指令)
6. [程序运行指令CMD与ENTRYPOINT](#6-程序运行指令cmd与entrypoint)
7. [用户与权限管理](#7-用户与权限管理)
8. [构建参数与元数据](#8-构建参数与元数据)
9. [存储与网络配置](#9-存储与网络配置)
10. [高级特性指令](#10-高级特性指令)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🐳 什么是Dockerfile


### 1.1 Dockerfile基本概念


**🔸 简单理解**
```
Dockerfile = 制作容器镜像的"菜谱"
就像做菜需要菜谱一样，制作Docker镜像需要Dockerfile
```

**💡 通俗比喻**
> 想象你要教朋友做一道菜：
> - 📋 **菜谱**：Dockerfile（文本文件，包含所有步骤）
> - 🥘 **成品菜**：Docker镜像（按菜谱制作出来的结果）
> - 🍽️ **上桌享用**：Docker容器（实际运行的镜像）

### 1.2 Dockerfile的作用


**🎯 核心功能**
- **自动化构建**：不用手工配置，按脚本自动制作镜像
- **标准化部署**：同一份Dockerfile，在任何地方都能制作相同镜像
- **版本控制**：可以像代码一样管理和追踪变更

**📊 传统方式 vs Dockerfile方式**
```
传统手工方式：
启动基础系统 → 手工安装软件 → 手工配置 → 手工测试
(每次都要重复，容易出错，难以标准化)

Dockerfile方式：
编写Dockerfile → docker build → 自动制作镜像
(一次编写，到处使用，标准化程度高)
```

### 1.3 Dockerfile文件结构


**📋 基本结构**
```dockerfile
# 注释：说明这个镜像的用途
FROM ubuntu:20.04                    # 基础镜像
RUN apt-get update                   # 执行命令
COPY app.py /app/                    # 复制文件
WORKDIR /app                         # 设置工作目录
CMD ["python", "app.py"]             # 启动命令
```

**🔍 文件特点**
- **纯文本文件**：用任何文本编辑器都能编辑
- **固定文件名**：必须叫`Dockerfile`（注意大小写）
- **指令格式**：每行一个指令，格式为`指令名 参数`

---

## 2. 🏗️ 基础镜像指令FROM


### 2.1 FROM指令基本用法


**🔸 核心作用**
```
FROM = 选择"地基"
就像盖房子先要选地基一样，制作镜像先要选基础镜像
```

**💡 基本语法**
```dockerfile
# 基本格式
FROM <镜像名>:<标签>

# 实际示例
FROM ubuntu:20.04          # 使用Ubuntu 20.04作为基础
FROM python:3.9            # 使用Python 3.9官方镜像
FROM nginx:alpine          # 使用轻量版Nginx
```

### 2.2 常用基础镜像选择


**📊 镜像类型对比**
| 镜像类型 | **特点** | **大小** | **适用场景** |
|----------|----------|----------|--------------|
| 🐧 **ubuntu/debian** | `功能完整，包含常用工具` | `较大(100MB+)` | `开发测试环境` |
| 🏔️ **alpine** | `极度精简，安全性高` | `很小(5MB左右)` | `生产环境首选` |
| 🐍 **python:3.9** | `预装Python环境` | `中等(100-300MB)` | `Python应用` |
| ☕ **openjdk:11** | `预装Java环境` | `中等(200-400MB)` | `Java应用` |

**🎯 选择建议**
```
开发学习阶段：选择ubuntu/debian
→ 工具齐全，遇到问题容易调试

生产环境部署：选择alpine系列
→ 体积小，安全性高，启动快

特定语言应用：选择官方语言镜像
→ python:3.9, node:16, openjdk:11等
```

### 2.3 FROM指令高级用法


**🔧 多阶段构建**
```dockerfile
# 阶段1：编译阶段（使用完整开发环境）
FROM node:16 AS builder
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# 阶段2：运行阶段（使用精简运行环境）
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
```

**💭 多阶段构建的好处**
- **减小镜像大小**：最终镜像只包含运行时需要的文件
- **提高安全性**：不包含编译工具和源代码
- **构建效率**：可以并行构建不同阶段

---

## 3. ⚙️ 运行命令指令RUN


### 3.1 RUN指令基本概念


**🔸 简单理解**
```
RUN = 在镜像制作过程中执行命令
就像按菜谱步骤操作一样，RUN指令告诉Docker该执行什么命令
```

**💡 执行时机**
```
构建时执行：docker build时执行RUN指令
运行时不执行：容器启动后不会再执行RUN指令

类比：
RUN = 做菜时的准备工作（洗菜、切菜、调料）
CMD = 开饭时的动作（盛饭、上桌）
```

### 3.2 RUN指令语法形式


**📋 两种语法格式**

**Shell格式（推荐新手使用）**
```dockerfile
# 直接写命令，像在命令行一样
RUN apt-get update
RUN apt-get install -y python3 python3-pip
RUN pip3 install flask
```

**Exec格式（JSON数组格式）**
```dockerfile
# 用JSON数组格式，更精确但稍复杂
RUN ["apt-get", "update"]
RUN ["apt-get", "install", "-y", "python3"]
```

**🎯 格式选择建议**
- **新手推荐**：使用Shell格式，直观易懂
- **生产环境**：Exec格式更可控，避免shell解析问题

### 3.3 RUN指令最佳实践


**✅ 合并多个RUN指令**
```dockerfile
# ❌ 不好的写法（产生多个镜像层）
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip
RUN pip3 install flask

# ✅ 好的写法（合并为一层）
RUN apt-get update && \
    apt-get install -y python3 python3-pip && \
    pip3 install flask && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**💡 合并的好处**
- **减小镜像大小**：每个RUN指令都会创建一个新的镜像层
- **提高构建效率**：减少层数，加速构建过程
- **清理临时文件**：在同一层内清理，彻底删除缓存

**🧹 清理最佳实践**
```dockerfile
# Ubuntu/Debian系统清理
RUN apt-get update && \
    apt-get install -y package1 package2 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Alpine系统清理
RUN apk add --no-cache package1 package2 && \
    rm -rf /tmp/* /var/cache/apk/*
```

---

## 4. 📁 文件操作指令COPY与ADD


### 4.1 文件复制的基本概念


**🔸 为什么需要复制文件？**
```
制作镜像时需要把应用代码、配置文件等放进镜像
就像搬家时要把物品从旧房子搬到新房子一样
```

**💭 两种复制指令的区别**
```
COPY：简单复制，就像普通的文件复制
ADD：增强复制，有额外功能（解压、下载等）

新手建议：优先使用COPY，简单明了
```

### 4.2 COPY指令详解


**📋 基本语法**
```dockerfile
COPY <源路径> <目标路径>

# 实际示例
COPY app.py /app/              # 复制单个文件
COPY src/ /app/src/            # 复制整个目录
COPY *.py /app/                # 复制所有Python文件
```

**🎯 COPY指令实用示例**
```dockerfile
# 复制应用代码
COPY app.py /app/app.py        # 复制主程序
COPY requirements.txt /app/    # 复制依赖列表
COPY static/ /app/static/      # 复制静态文件目录

# 复制配置文件
COPY config.json /etc/myapp/   # 复制配置文件
COPY nginx.conf /etc/nginx/    # 复制Nginx配置
```

**💡 COPY使用技巧**
```dockerfile
# 技巧1：分层复制，利用缓存
COPY requirements.txt /app/    # 先复制依赖文件
RUN pip install -r /app/requirements.txt
COPY . /app/                   # 再复制代码

# 技巧2：设置文件权限
COPY --chown=1000:1000 app.py /app/
```

### 4.3 ADD指令详解


**🔸 ADD的特殊功能**
```
ADD除了复制文件，还有额外功能：
1. 自动解压tar文件
2. 支持URL下载（不推荐）
```

**📊 COPY vs ADD对比**
| 功能 | **COPY** | **ADD** |
|------|----------|---------|
| 📄 **复制本地文件** | ✅ 支持 | ✅ 支持 |
| 📦 **自动解压tar** | ❌ 不支持 | ✅ 支持 |
| 🌐 **URL下载** | ❌ 不支持 | ⚠️ 支持(不推荐) |
| 🎯 **推荐程度** | ⭐⭐⭐⭐⭐ 首选 | ⭐⭐ 特定场景 |

**✅ ADD适用场景示例**
```dockerfile
# 自动解压tar文件
ADD myapp.tar.gz /app/         # 自动解压到/app/目录

# 但通常更推荐明确的方式
COPY myapp.tar.gz /tmp/
RUN tar -xzf /tmp/myapp.tar.gz -C /app/ && rm /tmp/myapp.tar.gz
```

---

## 5. 🏠 工作环境设置指令


### 5.1 工作目录WORKDIR


**🔸 简单理解**
```
WORKDIR = 设置工作目录
就像在电脑上双击打开某个文件夹，之后的操作都在这个文件夹里进行
```

**💡 基本用法**
```dockerfile
WORKDIR /app                   # 设置工作目录为/app
COPY . .                       # 在/app目录下复制文件
RUN python setup.py install   # 在/app目录下执行命令
```

**🎯 WORKDIR最佳实践**
```dockerfile
# ✅ 推荐写法
FROM python:3.9
WORKDIR /app                   # 明确设置工作目录
COPY requirements.txt .        # 相对路径，复制到/app/
RUN pip install -r requirements.txt
COPY . .                       # 复制所有文件到/app/
CMD ["python", "app.py"]       # 在/app目录执行

# ❌ 不推荐写法
FROM python:3.9
COPY requirements.txt /app/requirements.txt  # 绝对路径，繁琐
RUN cd /app && pip install -r requirements.txt
COPY . /app/
CMD ["python", "/app/app.py"]
```

### 5.2 环境变量ENV


**🔸 环境变量的作用**
```
ENV = 设置环境变量
就像给应用程序设置"全局配置"，程序可以读取这些配置
```

**📋 ENV指令语法**
```dockerfile
# 设置单个环境变量
ENV KEY=value

# 设置多个环境变量
ENV KEY1=value1 KEY2=value2

# 实际示例
ENV PYTHONPATH=/app
ENV DEBUG=false
ENV PORT=8080
```

**💡 环境变量实用示例**
```dockerfile
# Python应用环境变量
ENV PYTHONDONTWRITEBYTECODE=1    # 不生成.pyc文件
ENV PYTHONUNBUFFERED=1           # 输出不缓冲
ENV PYTHONPATH=/app              # Python路径

# 应用配置环境变量
ENV NODE_ENV=production          # Node.js环境
ENV DATABASE_URL=sqlite:///app.db # 数据库连接
ENV LOG_LEVEL=info               # 日志级别
```

**🔧 环境变量的使用**
```dockerfile
# 在Dockerfile中引用环境变量
ENV APP_HOME=/opt/app
WORKDIR $APP_HOME               # 使用环境变量
COPY . $APP_HOME/               # 在其他指令中使用
```

---

## 6. 🚀 程序运行指令CMD与ENTRYPOINT


### 6.1 容器启动命令的基本概念


**🔸 启动命令的作用**
```
CMD/ENTRYPOINT = 告诉容器启动后要执行什么程序
就像双击应用图标启动程序一样，容器启动时需要知道执行什么
```

**💭 两种指令的区别（新手重点理解）**
```
CMD：容器的"默认启动程序"
- 可以被docker run命令覆盖
- 适合设置默认行为

ENTRYPOINT：容器的"固定启动程序"  
- 不能被docker run命令覆盖
- 适合制作工具型镜像
```

### 6.2 CMD指令详解


**📋 CMD指令语法**
```dockerfile
# Shell格式（推荐新手）
CMD python app.py

# Exec格式（推荐生产环境）
CMD ["python", "app.py"]

# 作为ENTRYPOINT参数
CMD ["app.py"]
```

**🎯 CMD使用示例**
```dockerfile
# Web应用启动示例
FROM python:3.9
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]      # 默认启动Web应用

# 可以在运行时覆盖
# docker run myapp python debug.py  ← 覆盖CMD
```

### 6.3 ENTRYPOINT指令详解


**🔸 ENTRYPOINT的特点**
```
ENTRYPOINT设置的命令不能被覆盖
适合制作"工具型"镜像，确保特定程序始终执行
```

**💡 ENTRYPOINT实用场景**
```dockerfile
# 制作数据库备份工具
FROM alpine
RUN apk add --no-cache mysql-client
ENTRYPOINT ["mysqldump"]       # 固定执行mysqldump
CMD ["--help"]                 # 默认显示帮助

# 使用时：
# docker run backup-tool -u user -p password mydb
# 实际执行：mysqldump -u user -p password mydb
```

### 6.4 CMD与ENTRYPOINT组合使用


**🎨 灵活组合方案**
```dockerfile
# 组合使用示例
FROM python:3.9
WORKDIR /app
COPY app.py .

ENTRYPOINT ["python"]          # 固定使用python执行
CMD ["app.py"]                 # 默认执行app.py

# 运行效果：
# docker run myapp              → python app.py
# docker run myapp debug.py    → python debug.py
```

**📊 三种组合对比**
| 配置方式 | **运行命令** | **覆盖行为** | **适用场景** |
|----------|-------------|-------------|-------------|
| 🔸 **只有CMD** | `docker run myapp` | `完全可覆盖` | `通用应用镜像` |
| 🔸 **只有ENTRYPOINT** | `docker run myapp` | `不可覆盖` | `专用工具镜像` |
| 🔸 **两者结合** | `docker run myapp` | `参数可覆盖` | `灵活工具镜像` |

---

## 7. 👤 用户与权限管理


### 7.1 USER指令基本概念


**🔸 为什么需要设置用户？**
```
默认情况下，容器以root用户运行
这存在安全风险，类似于在电脑上始终使用管理员账户

设置普通用户可以：
- 提高安全性
- 遵循最小权限原则
- 符合生产环境安全要求
```

**💡 USER指令基本用法**
```dockerfile
# 使用系统已有用户
USER nobody                    # 使用nobody用户

# 使用用户ID
USER 1000                      # 使用ID为1000的用户

# 使用用户名:组名
USER appuser:appgroup          # 指定用户和组
```

### 7.2 创建和使用非root用户


**🎯 完整的用户创建流程**
```dockerfile
FROM ubuntu:20.04

# 创建用户和组
RUN groupadd -r appgroup && \
    useradd -r -g appgroup -d /app -s /sbin/nologin appuser

# 创建应用目录并设置权限
RUN mkdir -p /app && chown -R appuser:appgroup /app

# 切换到普通用户
USER appuser

# 设置工作目录
WORKDIR /app

# 复制应用文件（注意权限）
COPY --chown=appuser:appgroup . /app/

# 启动应用
CMD ["python", "app.py"]
```

**📋 用户管理最佳实践**
```dockerfile
# 方案1：使用数字ID（推荐）
RUN adduser -D -u 1000 appuser
USER 1000:1000

# 方案2：Alpine系统创建用户
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser
USER appuser

# 方案3：Ubuntu/Debian系统创建用户
RUN groupadd -g 1000 appgroup && \
    useradd -u 1000 -g appgroup -m appuser
USER appuser
```

---

## 8. 📝 构建参数与元数据


### 8.1 构建参数ARG


**🔸 ARG指令的作用**
```
ARG = 构建时参数
就像函数的参数一样，可以在构建镜像时传入不同的值
让同一个Dockerfile能构建出不同配置的镜像
```

**💡 ARG基本用法**
```dockerfile
# 定义构建参数
ARG PYTHON_VERSION=3.9         # 带默认值
ARG APP_ENV                    # 无默认值，构建时必须提供

# 使用构建参数
FROM python:${PYTHON_VERSION}
ENV ENVIRONMENT=${APP_ENV}
```

**🔧 ARG使用示例**
```dockerfile
# 灵活的版本构建
ARG NODE_VERSION=16
ARG APP_PORT=3000

FROM node:${NODE_VERSION}
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE ${APP_PORT}
CMD ["npm", "start"]
```

**🚀 构建时传递参数**
```bash
# 使用默认参数构建
docker build -t myapp .

# 指定自定义参数构建
docker build --build-arg NODE_VERSION=14 --build-arg APP_PORT=8080 -t myapp .
```

### 8.2 标签元数据LABEL


**🔸 LABEL的作用**
```
LABEL = 给镜像贴"标签"
就像给文件夹贴标签纸一样，记录镜像的相关信息
```

**📋 LABEL常用标签**
```dockerfile
# 基本信息标签
LABEL maintainer="your-email@example.com"
LABEL version="1.0.0"
LABEL description="My awesome web application"

# 多个标签一次设置
LABEL maintainer="developer@company.com" \
      version="2.1.0" \
      description="Production web server" \
      source="https://github.com/company/myapp"
```

**🎯 实用标签示例**
```dockerfile
# 完整的标签信息
LABEL org.label-schema.build-date="2023-09-19" \
      org.label-schema.name="myapp" \
      org.label-schema.description="Web application container" \
      org.label-schema.version="1.0.0" \
      org.label-schema.vendor="My Company" \
      org.label-schema.schema-version="1.0"
```

---

## 9. 💾 存储与网络配置


### 9.1 数据卷声明VOLUME


**🔸 数据卷的基本概念**
```
VOLUME = 声明数据存储位置
告诉Docker这个目录需要持久化存储
就像指定哪些文件夹需要"备份"一样
```

**💡 为什么需要数据卷？**
```
容器数据的特点：
- 容器删除后，容器内数据会丢失
- 数据卷可以让数据在容器外持久保存
- 多个容器可以共享同一个数据卷

类比：
容器 = 临时宿舍
数据卷 = 个人储物柜（搬宿舍时可以带走）
```

**📋 VOLUME使用示例**
```dockerfile
# 声明数据卷
VOLUME ["/app/data"]           # 应用数据目录
VOLUME ["/var/log"]            # 日志目录
VOLUME ["/app/uploads", "/app/cache"]  # 多个目录

# 实际应用示例
FROM python:3.9
WORKDIR /app
COPY . /app/
VOLUME ["/app/data"]           # 数据目录持久化
EXPOSE 8080
CMD ["python", "app.py"]
```

### 9.2 端口暴露EXPOSE


**🔸 EXPOSE指令的作用**
```
EXPOSE = 声明容器使用的端口
类似于在门上贴个牌子"这是3号门"
只是声明，不会自动开放端口
```

**💭 EXPOSE的误区**
```
❌ 常见误解：EXPOSE会自动开放端口
✅ 实际作用：
  - 文档作用：告诉使用者容器监听哪些端口
  - 工具提示：一些工具会读取EXPOSE信息
  - 随机端口：docker run -P时会自动映射EXPOSE的端口
```

**🎯 EXPOSE使用示例**
```dockerfile
FROM python:3.9
WORKDIR /app
COPY . /app/
EXPOSE 8080                    # 声明应用监听8080端口
EXPOSE 9090                    # 声明监听管理端口
CMD ["python", "app.py"]

# 运行时仍需要手动映射端口
# docker run -p 8080:8080 myapp
```

---

## 10. 🔧 高级特性指令


### 10.1 健康检查HEALTHCHECK


**🔸 健康检查的意义**
```
HEALTHCHECK = 给容器做"体检"
定期检查容器内的应用是否正常运行
就像定期检查汽车引擎是否正常一样
```

**💡 健康检查的作用**
```
- 及时发现应用异常
- 自动重启不健康的容器
- 负载均衡器可以剔除不健康的实例
- 提供监控和告警依据
```

**📋 HEALTHCHECK基本语法**
```dockerfile
# 基本格式
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# 参数说明：
# --interval：检查间隔时间（默认30秒）
# --timeout：检查超时时间（默认30秒）
# --retries：重试次数（默认3次）
```

**🎯 实用健康检查示例**
```dockerfile
# Web应用健康检查
FROM python:3.9
WORKDIR /app
COPY . /app/
RUN pip install requests
EXPOSE 8080

# HTTP接口健康检查
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8080/health')" \
    || exit 1

CMD ["python", "app.py"]
```

### 10.2 触发器指令ONBUILD


**🔸 ONBUILD指令概念**
```
ONBUILD = 设置"触发器"
当有其他镜像以当前镜像为基础时，会自动执行ONBUILD指令
类似于"遗传特性"，父镜像的ONBUILD会在子镜像构建时执行
```

**💡 ONBUILD使用场景**
```
适合制作"基础镜像模板"：
- 公司内部的标准镜像
- 特定框架的基础镜像
- 通用的应用模板镜像
```

**🎯 ONBUILD实用示例**
```dockerfile
# 创建Node.js应用基础镜像
FROM node:16
WORKDIR /app

# 设置触发器指令
ONBUILD COPY package*.json ./
ONBUILD RUN npm install
ONBUILD COPY . .
ONBUILD EXPOSE 3000
ONBUILD CMD ["npm", "start"]

# 其他镜像使用这个基础镜像时：
# FROM mycompany/node-base    ← 会自动执行所有ONBUILD指令
```

### 10.3 其他实用指令


**🔧 SHELL指令**
```dockerfile
# 设置默认shell（Linux）
SHELL ["/bin/bash", "-c"]

# Windows容器设置PowerShell
SHELL ["powershell", "-command"]
```

**⏹️ STOPSIGNAL指令**
```dockerfile
# 设置停止容器的信号
STOPSIGNAL SIGTERM             # 默认信号
STOPSIGNAL SIGKILL             # 强制终止信号

# 适合需要优雅关闭的应用
STOPSIGNAL SIGUSR1             # 自定义信号
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心指令


**🎯 新手必会指令排序**
```
⭐⭐⭐ 核心必会：
FROM    - 选择基础镜像（必须掌握）
RUN     - 执行构建命令（必须掌握）  
COPY    - 复制文件（必须掌握）
WORKDIR - 设置工作目录（强烈推荐）
CMD     - 设置启动命令（必须掌握）

⭐⭐ 常用重要：
ENV     - 环境变量设置
EXPOSE  - 端口声明
USER    - 用户权限设置

⭐ 进阶使用：
ADD     - 增强复制功能
ENTRYPOINT - 固定入口点
ARG     - 构建参数
VOLUME  - 数据卷声明
LABEL   - 元数据标签
HEALTHCHECK - 健康检查
```

### 11.2 Dockerfile编写最佳实践


**✅ 新手实用建议**
```
🔸 镜像大小优化：
- 选择合适的基础镜像（alpine > ubuntu）
- 合并RUN指令，减少镜像层
- 及时清理包管理器缓存

🔸 构建效率优化：
- 把变动频繁的指令放在后面
- 利用构建缓存，先复制依赖文件
- 使用.dockerignore排除不需要的文件

🔸 安全性考虑：
- 使用非root用户运行应用
- 不在镜像中存储敏感信息
- 定期更新基础镜像

🔸 可维护性：
- 添加合适的LABEL标签
- 编写清晰的注释
- 保持Dockerfile简洁明了
```

**🎯 实用Dockerfile模板**
```dockerfile
# 通用Web应用Dockerfile模板
FROM python:3.9-alpine

# 设置元数据
LABEL maintainer="your-email@example.com" \
      version="1.0.0" \
      description="My web application"

# 创建非root用户
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser

# 设置工作目录
WORKDIR /app

# 复制依赖文件并安装（利用缓存）
COPY --chown=appuser:appgroup requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY --chown=appuser:appgroup . .

# 切换到普通用户
USER appuser

# 声明端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8080/health')" \
    || exit 1

# 启动命令
CMD ["python", "app.py"]
```

### 11.3 学习路径建议


**🛤️ 渐进式学习计划**
```
🟢 入门阶段（1-2周）：
- 掌握FROM、RUN、COPY、WORKDIR、CMD
- 能编写简单的应用镜像
- 理解镜像层的概念

🟡 进阶阶段（2-3周）：
- 学习ENV、EXPOSE、USER、ARG
- 掌握多阶段构建技巧
- 了解镜像优化方法

🔴 高级阶段（1-2周）：
- 掌握HEALTHCHECK、ONBUILD等高级指令
- 学会编写可复用的基础镜像
- 掌握企业级的Dockerfile最佳实践
```

**💡 学习建议**
- **动手实践**：每个指令都要实际测试
- **阅读官方文档**：遇到问题查阅Docker官方文档  
- **学习开源项目**：观察优秀开源项目的Dockerfile写法
- **渐进优化**：从能用到好用，逐步优化Dockerfile

**核心记忆口诀**：
```
🧠 记忆口诀：
FROM选基础，RUN做准备
COPY拿文件，WORKDIR定位置  
ENV设环境，USER管权限
EXPOSE声端口，CMD启程序
ARG传参数，LABEL贴标签
健康检查保平安，最佳实践记心间
```