---
title: 3、自定义网络管理
---
## 📚 目录

1. [docker network命令详解](#1-docker-network命令详解)
2. [创建自定义网络](#2-创建自定义网络)
3. [网络连接断开管理](#3-网络连接断开管理)
4. [容器加入网络](#4-容器加入网络)
5. [网络间通信配置](#5-网络间通信配置)
6. [DNS解析服务](#6-DNS解析服务)
7. [网络驱动选择](#7-网络驱动选择)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔧 docker network命令详解


### 1.1 什么是Docker自定义网络

🎯 **简单理解**：Docker自定义网络就像为容器搭建"专属小区网络"

```
生活中的网络类比：
默认网络 → 公共网络（所有人共享，地址随机分配）
自定义网络 → 私人小区网络（独立管理，规划明确）

Docker网络优势：
- 容器间可以通过名称直接通信
- 网络隔离提供更好的安全性
- 灵活的IP地址管理
- 支持不同的网络驱动模式
```

**🔸 网络管理的核心价值**
```
隔离性：不同业务的容器网络完全分离
可控性：精确控制容器间的网络访问
命名性：容器可以通过名称互相访问
扩展性：支持复杂的微服务架构部署
```

### 1.2 docker network基础命令

**📋 核心命令一览**

| 命令 | **功能说明** | **常用参数** |
|------|-------------|-------------|
| 🔸 **create** | `创建新网络` | `--driver, --subnet` |
| 🔸 **ls** | `列出所有网络` | `--filter, --format` |
| 🔸 **inspect** | `查看网络详情` | `--format` |
| 🔸 **rm** | `删除网络` | `--force` |
| 🔸 **connect** | `容器连接网络` | `--ip, --alias` |
| 🔸 **disconnect** | `容器断开网络` | `--force` |

**🔍 查看网络基本信息**
```bash
# 查看所有网络
docker network ls

# 查看网络详细信息
docker network inspect bridge

# 过滤特定网络
docker network ls --filter driver=bridge
```

### 1.3 默认网络类型解析

**🌐 Docker内置网络类型**

```
Docker默认提供的网络：

bridge网络：
- 默认网络类型
- 容器间可以相互访问
- 通过NAT访问外网
- IP地址自动分配

host网络：
- 直接使用主机网络
- 性能最优，但隔离性差
- 适合网络密集型应用

none网络：
- 完全隔离，无网络访问
- 适合纯计算型应用
- 需要手动配置网络
```

**💡 网络选择决策**
```
选择原则：
业务隔离需求高 → 自定义bridge网络
性能要求极高 → host网络
安全要求最高 → 自定义网络 + 防火墙规则
多服务协作 → 自定义网络 + 服务发现
```

---

## 2. 🏗️ 创建自定义网络


### 2.1 基础网络创建

**🔧 创建第一个自定义网络**

```bash
# 创建简单的自定义网络
docker network create my-network

# 创建带子网配置的网络
docker network create \
  --driver bridge \
  --subnet 172.20.0.0/16 \
  --gateway 172.20.0.1 \
  webapp-network
```

**📊 网络配置参数详解**
```
--driver：网络驱动类型
  bridge：桥接网络（默认）
  overlay：跨主机网络
  host：主机网络
  none：无网络

--subnet：子网范围
  172.20.0.0/16：私有网段
  192.168.100.0/24：小型网段

--gateway：网关地址
  通常是子网的第一个地址
  
--ip-range：可分配IP范围
  限制容器可获得的IP地址段
```

### 2.2 高级网络配置

**⚙️ 企业级网络规划**

```bash
# 创建具有完整配置的网络
docker network create \
  --driver bridge \
  --subnet 172.20.0.0/16 \
  --ip-range 172.20.100.0/24 \
  --gateway 172.20.0.1 \
  --opt com.docker.network.bridge.name=webapp-br \
  --opt com.docker.network.mtu=1500 \
  --label environment=production \
  --label project=webapp \
  production-network

# 创建带DNS配置的网络
docker network create \
  --driver bridge \
  --subnet 192.168.50.0/24 \
  --aux-address="dns-server=192.168.50.5" \
  --opt com.docker.network.bridge.enable_ip_masquerade=true \
  dns-network
```

**🔒 安全网络配置**
```bash
# 创建隔离网络（禁用外网访问）
docker network create \
  --driver bridge \
  --internal \
  --subnet 10.0.10.0/24 \
  internal-network

# 创建受限网络
docker network create \
  --driver bridge \
  --subnet 172.30.0.0/24 \
  --opt com.docker.network.bridge.enable_icc=false \
  restricted-network
```

### 2.3 网络规划最佳实践

**📋 企业网络规划指南**

```
网络命名规范：
项目名-环境-用途：webapp-prod-frontend
业务类型-层级：database-backend, web-frontend
版本化命名：app-v1-network, app-v2-network

IP段规划原则：
开发环境：172.16.x.x/24
测试环境：172.17.x.x/24  
生产环境：172.18.x.x/24
```

**🎯 不同场景的网络配置**
```bash
# Web应用三层架构网络
# 前端网络
docker network create \
  --subnet 172.20.1.0/24 \
  web-frontend

# 后端网络  
docker network create \
  --subnet 172.20.2.0/24 \
  web-backend

# 数据库网络（内部隔离）
docker network create \
  --internal \
  --subnet 172.20.3.0/24 \
  database-network
```

---

## 3. 🔌 网络连接断开管理


### 3.1 容器网络连接操作

**🔗 动态网络连接管理**

```bash
# 将运行中的容器连接到网络
docker network connect my-network nginx-container

# 连接时指定IP地址
docker network connect --ip 172.20.0.100 webapp-network web-server

# 连接时设置别名
docker network connect --alias web --alias frontend webapp-network nginx-container
```

**💡 连接操作的实际应用**
```
场景示例：

1. 蓝绿部署
   - 新版本容器先连接到测试网络
   - 验证通过后连接到生产网络
   - 旧版本容器从生产网络断开

2. 服务迁移
   - 数据库从旧网络迁移到新网络
   - 保持服务不中断
   - 逐步切换应用连接

3. 调试排错
   - 临时将调试工具连接到应用网络
   - 完成调试后断开连接
```

### 3.2 网络断开操作

**🔌 安全断开网络连接**

```bash
# 将容器从网络中断开
docker network disconnect my-network nginx-container

# 强制断开（即使容器正在运行）
docker network disconnect --force webapp-network web-server

# 验证断开结果
docker container inspect web-server --format '{{.NetworkSettings.Networks}}'
```

**⚠️ 断开操作注意事项**
```
断开前检查：
□ 确认没有其他容器依赖此连接
□ 检查应用是否会因网络断开而异常
□ 准备回滚方案

断开后验证：
□ 容器功能是否正常
□ 其他服务是否受到影响
□ 网络连通性测试
```

### 3.3 批量网络管理

**🔄 自动化网络连接管理**

```bash
#!/bin/bash
# network_batch_management.sh

# 批量连接容器到网络
connect_containers_to_network() {
    local network_name=$1
    shift
    local containers=("$@")
    
    echo "将容器批量连接到网络: $network_name"
    for container in "${containers[@]}"; do
        if docker container inspect "$container" >/dev/null 2>&1; then
            docker network connect "$network_name" "$container"
            echo "✅ $container 已连接到 $network_name"
        else
            echo "❌ 容器 $container 不存在"
        fi
    done
}

# 批量断开容器网络连接
disconnect_containers_from_network() {
    local network_name=$1
    
    echo "从网络 $network_name 批量断开所有容器"
    
    # 获取网络中的所有容器
    local containers=$(docker network inspect "$network_name" \
        --format '{{range .Containers}}{{.Name}} {{end}}')
    
    for container in $containers; do
        docker network disconnect "$network_name" "$container"
        echo "🔌 $container 已从 $network_name 断开"
    done
}

# 使用示例
connect_containers_to_network "webapp-network" "web1" "web2" "web3"
```

---

## 4. 📦 容器加入网络


### 4.1 创建时指定网络

**🚀 容器启动时的网络配置**

```bash
# 创建容器时指定自定义网络
docker run -d \
  --name web-server \
  --network webapp-network \
  nginx:alpine

# 指定IP地址创建容器
docker run -d \
  --name api-server \
  --network webapp-network \
  --ip 172.20.0.50 \
  nginx:alpine

# 设置网络别名
docker run -d \
  --name database \
  --network backend-network \
  --network-alias db \
  --network-alias mysql \
  mysql:8.0
```

**🔧 多网络容器配置**
```bash
# 容器连接多个网络
docker run -d \
  --name gateway \
  --network frontend-network \
  nginx:alpine

# 将同一容器连接到后端网络
docker network connect backend-network gateway

# 验证多网络连接
docker container inspect gateway \
  --format '{{range $net, $config := .NetworkSettings.Networks}}{{$net}}: {{$config.IPAddress}}{{"\n"}}{{end}}'
```

### 4.2 网络别名与服务发现

**🏷️ 容器网络标识管理**

```
网络别名的作用：

服务发现：
- 容器可以通过别名互相访问
- 支持多个别名指向同一容器
- 替代硬编码的IP地址

负载均衡：
- 多个容器共享相同别名
- Docker内置DNS轮询分发请求
- 实现简单的服务发现
```

**💡 服务发现实践示例**
```bash
# 创建Web服务集群
for i in {1..3}; do
    docker run -d \
      --name web-$i \
      --network webapp-network \
      --network-alias webserver \
      nginx:alpine
done

# 创建负载均衡器
docker run -d \
  --name load-balancer \
  --network webapp-network \
  -p 80:80 \
  nginx:alpine

# 在负载均衡器中配置上游服务器
# upstream webserver { server webserver; }
```

### 4.3 容器网络健康检查

**🏥 网络连通性监控**

```bash
# 容器内网络测试
# 进入容器检查网络连通性
docker exec -it web-server sh

# 容器内执行网络测试
ping api-server
nslookup database
curl http://backend-service:8080/health

# 自动化网络健康检查
#!/bin/bash
# network_health_check.sh

check_container_network() {
    local container=$1
    local target_service=$2
    
    echo "检查 $container 到 $target_service 的网络连通性"
    
    # 检查DNS解析
    if docker exec "$container" nslookup "$target_service" >/dev/null 2>&1; then
        echo "✅ DNS解析正常"
    else
        echo "❌ DNS解析失败"
        return 1
    fi
    
    # 检查网络连通性
    if docker exec "$container" ping -c 1 "$target_service" >/dev/null 2>&1; then
        echo "✅ 网络连通正常"
    else
        echo "❌ 网络连通失败"
        return 1
    fi
}

# 批量检查网络健康状态
for container in web-1 web-2 web-3; do
    check_container_network "$container" "database"
done
```

---

## 5. 🌐 网络间通信配置


### 5.1 跨网络通信设置

**🔗 不同网络间的容器通信**

```
网络间通信场景：

前后端分离：
前端网络 ←→ 后端网络
通过API网关或代理实现通信

微服务架构：
服务网络A ←→ 服务网络B  
通过服务网格或负载均衡器

数据访问：
应用网络 ←→ 数据库网络
通过数据访问层控制权限
```

**🔧 网络桥接配置**
```bash
# 创建网关容器连接多个网络
docker run -d \
  --name api-gateway \
  --network frontend-network \
  nginx:alpine

# 将网关连接到后端网络
docker network connect backend-network api-gateway

# 配置网关转发规则（Nginx配置）
upstream backend-api {
    server backend-service:8080;
}

server {
    listen 80;
    location /api/ {
        proxy_pass http://backend-api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 5.2 网络安全策略

**🛡️ 网络访问控制**

```bash
# 创建带访问控制的网络
docker network create \
  --driver bridge \
  --opt com.docker.network.bridge.enable_icc=false \
  secure-network

# 使用iptables实现网络间访问控制
# 允许特定服务间通信
iptables -A DOCKER-USER \
  -s 172.20.1.0/24 \
  -d 172.20.2.0/24 \
  -p tcp --dport 3306 \
  -j ACCEPT

# 拒绝其他跨网络访问
iptables -A DOCKER-USER \
  -s 172.20.1.0/24 \
  -d 172.20.2.0/24 \
  -j REJECT
```

**🔒 网络隔离最佳实践**
```
网络分层策略：

DMZ区域（对外服务）：
- Web服务器、负载均衡器
- 允许外网访问
- 限制对内网的访问

应用层（业务逻辑）：
- 应用服务器、API服务
- 只允许DMZ区域访问
- 可以访问数据层

数据层（数据存储）：
- 数据库、缓存服务
- 只允许应用层访问
- 完全隔离外网
```

### 5.3 服务网格配置

**🕸️ 微服务网络管理**

```bash
# 使用Docker Compose配置服务网格
version: '3.8'

services:
  web:
    image: nginx:alpine
    networks:
      - frontend
    ports:
      - "80:80"

  api:
    image: node:alpine
    networks:
      - frontend
      - backend
    depends_on:
      - database

  database:
    image: mysql:8.0
    networks:
      - backend
    environment:
      MYSQL_ROOT_PASSWORD: secret

networks:
  frontend:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.1.0/24
  
  backend:
    driver: bridge
    internal: true
    ipam:
      config:
        - subnet: 172.20.2.0/24
```

---

## 6. 🌍 DNS解析服务


### 6.1 Docker内置DNS

**📡 容器名称解析机制**

```
Docker DNS工作原理：

自动DNS服务：
- 每个自定义网络都有内置DNS服务器
- 容器名称自动注册为DNS记录
- 支持服务发现和负载均衡

DNS解析顺序：
1. 容器内部hosts文件
2. Docker内置DNS服务器
3. 宿主机DNS配置
4. 公网DNS服务器
```

**🔍 DNS解析测试**
```bash
# 在容器内测试DNS解析
docker exec -it web-container nslookup api-server
docker exec -it web-container dig api-server

# 查看容器DNS配置
docker exec -it web-container cat /etc/resolv.conf

# 测试服务发现
docker exec -it web-container ping database
docker exec -it web-container curl http://api-service:8080/health
```

### 6.2 自定义DNS配置

**⚙️ DNS服务器和解析配置**

```bash
# 创建容器时指定DNS服务器
docker run -d \
  --name web-server \
  --network webapp-network \
  --dns 8.8.8.8 \
  --dns 8.8.4.4 \
  --dns-search company.local \
  nginx:alpine

# 添加自定义DNS解析记录
docker run -d \
  --name api-server \
  --network webapp-network \
  --add-host external-service:192.168.1.100 \
  --add-host backup-db:192.168.1.200 \
  node:alpine
```

**🔧 企业内网DNS集成**
```bash
# 创建带企业DNS的网络
docker network create \
  --driver bridge \
  --subnet 172.30.0.0/24 \
  --opt com.docker.network.bridge.name=corp-bridge \
  corporate-network

# 启动容器连接企业DNS
docker run -d \
  --name app-server \
  --network corporate-network \
  --dns 192.168.10.1 \
  --dns-search corp.local \
  --dns-option timeout:2 \
  --dns-option attempts:3 \
  myapp:latest
```

### 6.3 DNS故障排查

**🔧 DNS问题诊断与解决**

```bash
#!/bin/bash
# dns_troubleshoot.sh

diagnose_dns_issues() {
    local container=$1
    
    echo "=== DNS诊断报告：$container ==="
    
    # 检查DNS配置
    echo "1. DNS配置信息："
    docker exec "$container" cat /etc/resolv.conf
    
    # 检查hosts文件
    echo "2. Hosts文件内容："
    docker exec "$container" cat /etc/hosts
    
    # 测试内部DNS解析
    echo "3. 内部DNS解析测试："
    for service in api-server database web-server; do
        if docker exec "$container" nslookup "$service" >/dev/null 2>&1; then
            echo "✅ $service 解析正常"
        else
            echo "❌ $service 解析失败"
        fi
    done
    
    # 测试外部DNS解析
    echo "4. 外部DNS解析测试："
    if docker exec "$container" nslookup google.com >/dev/null 2>&1; then
        echo "✅ 外部DNS解析正常"
    else
        echo "❌ 外部DNS解析失败"
    fi
}

# 批量诊断所有容器
for container in $(docker ps --format "{{.Names}}"); do
    diagnose_dns_issues "$container"
    echo "================================="
done
```

---

## 7. 🚗 网络驱动选择


### 7.1 Bridge驱动详解

**🌉 桥接网络驱动特性**

```
Bridge驱动特点：

工作原理：
- 在宿主机上创建虚拟网桥
- 每个容器连接到网桥
- 通过iptables规则实现NAT

适用场景：
- 单机容器部署
- 开发测试环境
- 简单的微服务架构

性能特点：
- 网络性能良好
- 配置简单易懂
- 隔离性适中
```

**⚙️ Bridge网络优化配置**
```bash
# 创建高性能bridge网络
docker network create \
  --driver bridge \
  --opt com.docker.network.bridge.name=high-perf-br \
  --opt com.docker.network.driver.mtu=9000 \
  --opt com.docker.network.bridge.enable_ip_masquerade=true \
  --opt com.docker.network.bridge.enable_icc=true \
  high-performance-network

# 禁用网络间容器通信（提高安全性）
docker network create \
  --driver bridge \
  --opt com.docker.network.bridge.enable_icc=false \
  secure-bridge-network
```

### 7.2 Overlay驱动应用

**☁️ 跨主机网络驱动**

```
Overlay驱动特点：

跨主机通信：
- 支持多台Docker主机
- 容器可以跨主机直接通信
- 内置加密和服务发现

Swarm模式：
- 需要Docker Swarm集群
- 自动负载均衡
- 滚动更新支持

适用场景：
- 容器集群部署
- 微服务生产环境
- 混合云架构
```

**🔧 Overlay网络配置**
```bash
# 初始化Swarm模式
docker swarm init --advertise-addr 192.168.1.100

# 创建overlay网络
docker network create \
  --driver overlay \
  --subnet 10.10.0.0/16 \
  --opt encrypted=true \
  multi-host-network

# 在Swarm中部署服务
docker service create \
  --name web-service \
  --network multi-host-network \
  --replicas 3 \
  --publish 80:80 \
  nginx:alpine
```

### 7.3 Host和None驱动

**🏠 特殊网络驱动应用**

```
Host网络驱动：

特点：
- 直接使用宿主机网络栈
- 最佳网络性能
- 无网络隔离

适用场景：
- 网络密集型应用
- 监控和日志收集
- 性能要求极高的服务

None网络驱动：

特点：
- 完全网络隔离
- 只有loopback接口
- 需要手动配置网络

适用场景：
- 纯计算型应用
- 最高安全要求
- 自定义网络方案
```

**💡 驱动选择决策树**
```
网络驱动选择指南：

单机部署 + 简单应用
    ↓
  Bridge驱动

多主机集群 + 服务发现
    ↓
  Overlay驱动

极致性能 + 网络密集
    ↓
  Host驱动

完全隔离 + 自定义网络
    ↓
  None驱动

特殊需求 + 第三方方案
    ↓
  Plugin驱动
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 自定义网络：为容器创建专属网络环境，实现隔离和管理
🔸 网络连接：动态连接和断开容器网络，支持灵活的部署策略  
🔸 服务发现：通过容器名称和网络别名实现自动服务发现
🔸 网络通信：配置跨网络通信和安全访问控制策略
🔸 DNS解析：利用Docker内置DNS实现服务名称解析
🔸 驱动选择：根据应用场景选择合适的网络驱动类型
```

### 8.2 关键理解要点


**🔹 自定义网络的核心价值**
```
隔离性优势：
- 不同项目的容器网络完全分离
- 避免IP地址冲突和网络干扰
- 提供更好的安全边界控制

管理便利性：
- 容器通过名称直接通信
- 支持动态网络连接和断开
- 简化复杂应用的部署配置

可扩展性：
- 支持微服务架构部署
- 便于实现负载均衡和服务发现
- 适应云原生应用需求
```

**🔹 网络驱动选择策略**
```
技术决策考量：

性能要求：
- Host驱动性能最优，但隔离性差
- Bridge驱动平衡性能和隔离
- Overlay驱动支持跨主机，性能适中

部署规模：
- 单机应用首选Bridge驱动
- 集群部署推荐Overlay驱动
- 边缘计算可考虑Host驱动

安全需求：
- 高安全要求使用自定义Bridge + 防火墙
- 完全隔离使用None驱动
- 企业级部署配合网络策略
```

**🔹 网络管理最佳实践**
```
规划设计：
- 统一的网络命名规范
- 合理的IP段分配策略
- 明确的网络拓扑结构

运维管理：
- 自动化网络连接脚本
- 完善的网络监控机制
- 标准化的故障排查流程

安全控制：
- 最小权限的网络访问
- 网络层面的访问控制
- 定期的安全审计和优化
```

### 8.3 实际应用价值


**🎯 生产环境应用场景**
- **微服务架构**：服务间网络隔离和服务发现
- **多租户系统**：不同租户的网络完全隔离
- **CI/CD流水线**：测试环境网络的动态创建和销毁
- **容器集群**：跨主机容器的统一网络管理

**🔧 运维实践建议**
- **网络规划**：制定清晰的网络架构和IP分配策略
- **自动化管理**：编写脚本实现网络的批量操作
- **监控告警**：建立网络健康检查和异常告警机制
- **文档规范**：维护完整的网络配置和操作手册

**📈 技术发展趋势**
- **服务网格**：Istio、Linkerd等服务网格技术集成
- **云原生网络**：CNI插件和Kubernetes网络模型
- **安全增强**：零信任网络和微分段技术
- **性能优化**：高性能网络驱动和硬件加速

**核心记忆口诀**：
- 自定义网络隔离好，容器通信名称找
- 连接断开很灵活，服务发现DNS巧
- 驱动选择看场景，性能安全要平衡
- 网络规划要合理，监控管理不能少