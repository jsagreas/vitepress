---
title: 5、Ajax请求中的this指向问题
---
## 📚 目录

1. [this指向问题的本质](#1-this指向问题的本质)
2. [Ajax中this指向的困惑](#2-Ajax中this指向的困惑)
3. [箭头函数解决方案](#3-箭头函数解决方案)
4. [传统解决方法](#4-传统解决方法)
5. [实际应用案例](#5-实际应用案例)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🤔 this指向问题的本质


### 1.1 什么是this指向问题


**简单理解**：在JavaScript中，`this` 就像一个"指针"，它会根据函数被调用的方式来决定指向谁。

```
想象一个场景：
你在不同地方说"我"这个词：
- 在家里说"我" → 指的是你自己
- 帮朋友转达话时说"我" → 可能指的是朋友
- 在Ajax回调中说"我" → 可能不知道指向谁了！
```

> 💡 **核心理解**：`this` 的指向不是看函数写在哪里，而是看函数怎么被调用的

### 1.2 this指向的基本规则


```javascript
// 规则1: 全局调用 - this指向window
function sayHello() {
    console.log(this); // window对象
}
sayHello();

// 规则2: 对象方法调用 - this指向调用的对象  
const person = {
    name: '张三',
    sayName() {
        console.log(this.name); // "张三"
    }
};
person.sayName();

// 规则3: 作为回调函数 - this指向可能改变
const person2 = {
    name: '李四',
    sayName() {
        console.log(this.name);
    }
};

setTimeout(person2.sayName, 1000); // undefined (this指向window)
```

---

## 2. 😵 Ajax中this指向的困惑


### 2.1 典型的this指向问题


**问题场景**：在对象方法中发送Ajax请求，回调函数里访问不到对象的属性

```javascript
// ❌ 有问题的代码
const userManager = {
    name: '用户管理器',
    users: [],
    
    loadUsers() {
        console.log('开始加载用户:', this.name); // ✅ 正常，this指向userManager
        
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/users');
        
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log('加载完成:', this.name); // ❌ undefined! 
                this.users = JSON.parse(xhr.responseText); // ❌ 报错!
            }
        };
        
        xhr.send();
    }
};

userManager.loadUsers();
```

### 2.2 为什么会出现this指向问题


```
Ajax执行流程分析：

1. 调用 userManager.loadUsers()
   ├─ this 指向 userManager ✅
   └─ 设置回调函数 xhr.onreadystatechange

2. 浏览器接收到响应，调用回调函数
   ├─ 回调函数是被XMLHttpRequest对象调用的
   ├─ 此时 this 指向 XMLHttpRequest对象 
   └─ 不再指向 userManager 对象 ❌

问题根源：回调函数的调用者变了！
```

> ⚠️ **关键理解**：Ajax的回调函数是由浏览器(XMLHttpRequest)调用的，不是由我们的对象调用的，所以this指向改变了

### 2.3 this指向问题的表现


```javascript
const dataManager = {
    apiUrl: 'https://api.example.com',
    data: null,
    
    fetchData() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', this.apiUrl); // ✅ 这里this正常
        
        xhr.onload = function() {
            // ❌ 下面这些都会有问题
            console.log(this.apiUrl);    // undefined
            this.data = xhr.responseText; // 报错
            this.processData();           // 报错: this.processData is not a function
        };
        
        xhr.send();
    },
    
    processData() {
        console.log('处理数据...');
    }
};
```

---

## 3. 🎯 箭头函数解决方案


### 3.1 箭头函数的this特性


**箭头函数的神奇之处**：它不会创建自己的this，而是"继承"外层函数的this

```javascript
// 普通函数 vs 箭头函数
const obj = {
    name: '测试',
    
    // 普通函数 - this会改变
    normalFunc() {
        setTimeout(function() {
            console.log(this.name); // undefined (this指向window)
        }, 1000);
    },
    
    // 箭头函数 - this不会改变
    arrowFunc() {
        setTimeout(() => {
            console.log(this.name); // "测试" (this仍指向obj)
        }, 1000);
    }
};
```

> 💡 **关键理解**：箭头函数像是"透明"的，它会直接使用外层的this，不会被调用方式影响

### 3.2 用箭头函数解决Ajax中的this问题


```javascript
// ✅ 使用箭头函数解决this问题
const userManager = {
    name: '用户管理器',
    users: [],
    
    loadUsers() {
        console.log('开始加载:', this.name); // ✅ 正常
        
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/users');
        
        // 使用箭头函数 - this会继承外层的this
        xhr.onreadystatechange = () => {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log('加载完成:', this.name); // ✅ 正常! 
                this.users = JSON.parse(xhr.responseText); // ✅ 正常!
                this.showUsers(); // ✅ 可以调用其他方法
            }
        };
        
        xhr.send();
    },
    
    showUsers() {
        console.log('用户列表:', this.users);
    }
};
```

### 3.3 箭头函数解决方案的优势


```
箭头函数的优势：

✅ 语法简洁：() => {} 比 function() {} 更简短
✅ this固定：不用担心this指向问题
✅ 无需额外变量：不需要 var that = this
✅ 更直观：代码逻辑更清晰

注意事项：
⚠️ 箭头函数不能用作构造函数
⚠️ 没有arguments对象
⚠️ 不能改变this指向(有时这是优势，有时是限制)
```

---

## 4. 🔧 传统解决方法


### 4.1 方法一：保存this到变量


**核心思路**：在外层把this保存到一个变量里，回调函数中使用这个变量

```javascript
const userManager = {
    name: '用户管理器',
    users: [],
    
    loadUsers() {
        // 💡 关键：把this保存到变量中
        const self = this;  // 或者用 that, me 等名字
        
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/users');
        
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                // 使用保存的变量，而不是this
                console.log('加载完成:', self.name); // ✅ 正常
                self.users = JSON.parse(xhr.responseText); // ✅ 正常
            }
        };
        
        xhr.send();
    }
};
```

> 💡 **理解要点**：变量`self`保存了原始的this指向，即使在回调函数中this改变了，`self`依然指向原来的对象

### 4.2 方法二：使用bind方法


**bind方法的作用**：强制绑定函数的this指向

```javascript
const userManager = {
    name: '用户管理器',
    users: [],
    
    loadUsers() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/users');
        
        // 💡 使用bind强制绑定this
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log('加载完成:', this.name); // ✅ 正常
                this.users = JSON.parse(xhr.responseText); // ✅ 正常
            }
        }.bind(this); // 关键：bind(this)
        
        xhr.send();
    }
};
```

**bind方法详解**：
```javascript
// bind的基本用法
function sayHello() {
    console.log('Hello, ' + this.name);
}

const person = { name: '张三' };

// 普通调用
sayHello(); // "Hello, undefined"

// 使用bind绑定this
const boundSayHello = sayHello.bind(person);
boundSayHello(); // "Hello, 张三"
```

### 4.3 方法三：使用call/apply方法


**call和apply的区别**：都能改变this指向，但传参方式不同

```javascript
// call和apply的基本区别
function greet(greeting, punctuation) {
    console.log(greeting + ', ' + this.name + punctuation);
}

const person = { name: '李四' };

// call: 参数一个个传递
greet.call(person, 'Hello', '!'); // "Hello, 李四!"

// apply: 参数用数组传递  
greet.apply(person, ['Hi', '?']); // "Hi, 李四?"
```

**在Ajax中的应用**：
```javascript
const userManager = {
    name: '用户管理器',
    
    handleResponse(responseText) {
        console.log(this.name + '处理响应:', responseText);
    },
    
    loadUsers() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/users');
        
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4 && xhr.status === 200) {
                // 使用call改变this指向
                userManager.handleResponse.call(userManager, xhr.responseText);
            }
        };
        
        xhr.send();
    }
};
```

---

## 5. 🌟 实际应用案例


### 5.1 完整的数据管理器案例


```javascript
// 实际项目中的应用示例
const DataManager = {
    baseUrl: 'https://jsonplaceholder.typicode.com',
    loading: false,
    data: [],
    
    // 💡 箭头函数方案
    fetchPosts() {
        this.loading = true;
        console.log('开始加载文章...');
        
        const xhr = new XMLHttpRequest();
        xhr.open('GET', `${this.baseUrl}/posts`);
        
        // 使用箭头函数，this指向不变
        xhr.onload = () => {
            this.loading = false;
            
            if (xhr.status === 200) {
                this.data = JSON.parse(xhr.responseText);
                this.onSuccess(); // 可以调用其他方法
            } else {
                this.onError('加载失败');
            }
        };
        
        // 错误处理也用箭头函数
        xhr.onerror = () => {
            this.loading = false;
            this.onError('网络错误');
        };
        
        xhr.send();
    },
    
    // 💡 传统方案(保存this)
    fetchPostsTraditional() {
        const self = this; // 保存this
        self.loading = true;
        
        const xhr = new XMLHttpRequest();
        xhr.open('GET', `${self.baseUrl}/posts`);
        
        xhr.onload = function() {
            self.loading = false;
            
            if (xhr.status === 200) {
                self.data = JSON.parse(xhr.responseText);
                self.onSuccess();
            }
        };
        
        xhr.send();
    },
    
    onSuccess() {
        console.log(`成功加载 ${this.data.length} 条数据`);
        this.render();
    },
    
    onError(message) {
        console.error('错误:', message);
    },
    
    render() {
        console.log('渲染数据到页面...');
    }
};

// 使用
DataManager.fetchPosts();
```

### 5.2 表单提交案例


```javascript
const FormHandler = {
    formId: 'user-form',
    submitUrl: '/api/users',
    
    init() {
        const form = document.getElementById(this.formId);
        
        // 💡 这里需要注意this指向
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            this.submitForm(form); // 箭头函数确保this正确
        });
    },
    
    submitForm(form) {
        const formData = new FormData(form);
        
        const xhr = new XMLHttpRequest();
        xhr.open('POST', this.submitUrl);
        
        // 成功回调
        xhr.onload = () => {
            if (xhr.status === 200) {
                this.onSubmitSuccess(xhr.responseText);
            } else {
                this.onSubmitError('提交失败');
            }
        };
        
        // 错误回调
        xhr.onerror = () => {
            this.onSubmitError('网络错误');
        };
        
        xhr.send(formData);
    },
    
    onSubmitSuccess(response) {
        console.log('提交成功:', response);
        this.resetForm();
    },
    
    onSubmitError(message) {
        console.error('提交失败:', message);
    },
    
    resetForm() {
        document.getElementById(this.formId).reset();
    }
};

// 初始化
FormHandler.init();
```

### 5.3 多种方案对比


```javascript
const ApiClient = {
    token: 'abc123',
    
    // 方案1: 箭头函数 (推荐)
    requestWithArrow() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/data');
        xhr.setRequestHeader('Authorization', `Bearer ${this.token}`);
        
        xhr.onload = () => {
            // this始终指向ApiClient
            console.log('Token:', this.token); // ✅
        };
        
        xhr.send();
    },
    
    // 方案2: 保存this
    requestWithSelf() {
        const self = this;
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/data');
        xhr.setRequestHeader('Authorization', `Bearer ${self.token}`);
        
        xhr.onload = function() {
            console.log('Token:', self.token); // ✅
        };
        
        xhr.send();
    },
    
    // 方案3: bind方法
    requestWithBind() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/data');
        xhr.setRequestHeader('Authorization', `Bearer ${this.token}`);
        
        xhr.onload = function() {
            console.log('Token:', this.token); // ✅
        }.bind(this);
        
        xhr.send();
    }
};
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 this指向规律：函数调用方式决定this指向
🔸 Ajax回调问题：回调函数的this不是原对象
🔸 箭头函数特性：不创建自己的this，继承外层this  
🔸 解决方案选择：箭头函数 > 保存this > bind方法
🔸 实际应用：优先使用箭头函数，简洁且可靠
```

### 6.2 关键理解要点


**🔹 为什么会有this指向问题**
```
原因分析：
- Ajax回调函数是由XMLHttpRequest对象调用的
- 不是由我们的业务对象调用的  
- 所以this指向XMLHttpRequest，而不是业务对象

记忆方法：
谁调用函数，this就指向谁
```

**🔹 箭头函数为什么能解决问题**
```
关键特性：
- 箭头函数没有自己的this
- 它会"透明地"使用外层函数的this
- 不受调用方式影响

简单理解：
箭头函数像"透明薄膜"，this会直接"穿透"到外层
```

**🔹 什么时候用哪种方案**
```
选择指南：
✅ 优先用箭头函数：简洁、直观、不易出错
✅ 老项目或不支持ES6：保存this到变量  
✅ 需要动态绑定：使用bind/call/apply
✅ 一次性绑定：bind方法
✅ 临时调用：call/apply方法
```

### 6.3 实际应用指导


**💡 最佳实践**
```javascript
// ✅ 推荐做法
const myObject = {
    data: null,
    
    loadData() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/data');
        
        // 优先使用箭头函数
        xhr.onload = () => {
            this.data = xhr.responseText;
            this.processData();
        };
        
        xhr.onerror = () => {
            this.handleError();
        };
        
        xhr.send();
    },
    
    processData() {
        // 处理数据
    },
    
    handleError() {
        // 错误处理
    }
};
```

**⚠️ 常见错误**
```javascript
// ❌ 错误做法 - 忘记处理this指向
const wrongExample = {
    name: 'test',
    
    loadData() {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', '/api/data');
        
        // 普通函数 - this指向会改变
        xhr.onload = function() {
            console.log(this.name); // undefined!
        };
        
        xhr.send();
    }
};
```

**核心记忆方法**：
- Ajax回调函数优先用箭头函数
- 箭头函数让this"穿透"到外层  
- 遇到this问题想到三种解决方案
- 简单记忆：`() => {}` 让this不变