---
title: 1、跨域问题与同源策略
---
## 📚 目录

1. [同源策略基本概念](#1-同源策略基本概念)
2. [跨域问题产生原因](#2-跨域问题产生原因)
3. [同源判断规则详解](#3-同源判断规则详解)
4. [跨域错误信息解读](#4-跨域错误信息解读)
5. [跨域场景实际分析](#5-跨域场景实际分析)
6. [子域名跨域解决方案](#6-子域名跨域解决方案)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🔒 同源策略基本概念


### 1.1 什么是同源策略


**简单理解**：同源策略就像是**网页的安全门卫**，它负责检查网页是否有权限访问其他网站的资源。

```
想象一个现实场景：
你在银行网站 www.bank.com 上登录了账户
如果没有同源策略，恶意网站 www.hacker.com 就可以：
1. 读取你银行账户的信息
2. 代替你进行转账操作
3. 获取你的个人隐私数据

这显然是非常危险的！
```

**专业定义**：同源策略（Same-Origin Policy）是浏览器的一个重要安全机制，它限制了从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。

### 1.2 同源策略的安全意义


> 💡 **安全保护作用**：防止恶意网站窃取用户数据或进行恶意操作

**保护内容包括**：
- ✅ **Cookie和本地存储** - 防止恶意网站读取敏感信息
- ✅ **DOM访问** - 防止恶意网站操作其他网站的页面
- ✅ **Ajax请求** - 防止恶意网站代替用户发起请求

**现实例子**：
```
正常情况：
用户在 https://www.taobao.com 登录购物
浏览器会保存登录状态的Cookie

如果没有同源策略：
恶意网站 https://fake-shop.com 可以：
1. 读取淘宝的登录Cookie
2. 代替用户下单购买商品
3. 获取用户的收货地址等信息
```

---

## 2. ❌ 跨域问题产生原因


### 2.1 跨域问题的本质


**根本原因**：当网页试图访问**不同源**的资源时，浏览器的同源策略会**阻止**这种访问。

```
问题场景示例：

前端网站：http://localhost:3000
后端API：  http://localhost:8080

虽然都在本地，但端口不同 → 不同源 → 产生跨域问题
```

### 2.2 常见跨域场景


**🔸 开发环境跨域**
```javascript
// 前端代码运行在 http://localhost:3000
fetch('http://localhost:8080/api/users')
  .then(response => response.json())
  .then(data => console.log(data));

// ❌ 浏览器报错：跨域请求被阻止
```

**🔸 生产环境跨域**
```javascript
// 网站部署在 https://www.mysite.com
// API服务在 https://api.mysite.com

// 子域名不同 → 跨域问题
fetch('https://api.mysite.com/data')
```

**🔸 CDN资源跨域**
```javascript
// 主站：https://www.example.com
// CDN：https://cdn.example.com

// 获取CDN上的配置文件
fetch('https://cdn.example.com/config.json')
```

### 2.3 跨域限制的具体表现


> ⚠️ **注意**：跨域限制主要针对Ajax请求，普通的`<img>`、`<script>`、`<link>`标签不受限制

**受限制的操作**：
- ❌ XMLHttpRequest/fetch请求
- ❌ 读取iframe中不同源页面的内容
- ❌ 访问不同源页面的localStorage

**不受限制的操作**：
- ✅ `<img src="其他域名的图片">`
- ✅ `<script src="其他域名的js文件">`
- ✅ `<link href="其他域名的css文件">`

---

## 3. 📏 同源判断规则详解


### 3.1 同源的三要素


**同源必须满足**：**协议** + **域名** + **端口** 完全相同

```
基准URL：https://www.example.com:443/page

协议：https://
域名：www.example.com  
端口：443 (https默认端口)
```

### 3.2 同源判断实例


**🔸 协议差异**
```
基准：https://www.example.com/api
对比：http://www.example.com/api
结果：❌ 不同源 (协议不同：https vs http)
```

**🔸 域名差异**
```
基准：https://www.example.com/api
对比：https://api.example.com/api  
结果：❌ 不同源 (子域名不同：www vs api)
```

**🔸 端口差异**
```
基准：http://localhost:3000/api
对比：http://localhost:8080/api
结果：❌ 不同源 (端口不同：3000 vs 8080)
```

**🔸 路径差异**
```
基准：https://www.example.com/admin
对比：https://www.example.com/user
结果：✅ 同源 (协议、域名、端口都相同，路径不影响同源判断)
```

### 3.3 特殊情况说明


| 对比项目 | 基准URL | 对比URL | 判断结果 | 说明 |
|---------|---------|---------|----------|------|
| **默认端口** | `https://example.com` | `https://example.com:443` | ✅ **同源** | HTTPS默认443端口 |
| **IP与域名** | `http://localhost:3000` | `http://127.0.0.1:3000` | ❌ **不同源** | 域名形式不同 |
| **www差异** | `https://example.com` | `https://www.example.com` | ❌ **不同源** | 子域名不同 |

> 💡 **重要提醒**：即使IP地址指向同一台服务器，但域名形式不同仍然是不同源

---

## 4. 🔍 跨域错误信息解读


### 4.1 常见错误信息类型


**🔸 Chrome浏览器错误**
```
Access to fetch at 'http://localhost:8080/api/users' 
from origin 'http://localhost:3000' has been blocked by CORS policy: 
No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

**通俗解释**：
- **问题**：从`http://localhost:3000`访问`http://localhost:8080`被阻止
- **原因**：目标服务器没有设置允许跨域的响应头
- **解决思路**：需要服务器添加CORS响应头

**🔸 Firefox浏览器错误**
```
Cross-Origin Request Blocked: The Same Origin Policy disallows 
reading the remote resource at http://localhost:8080/api/users. 
(Reason: CORS header 'Access-Control-Allow-Origin' missing).
```

### 4.2 错误信息快速诊断


```
错误信息分析工具：

1. 看关键词：
   - "CORS" → 跨域资源共享问题
   - "Same Origin Policy" → 同源策略限制
   - "Access-Control-Allow-Origin" → 缺少CORS响应头

2. 找源地址：
   - "from origin" → 请求发起的源
   - "at" → 请求目标的地址

3. 定位原因：
   - "missing" → 缺少必要的响应头
   - "blocked" → 请求被浏览器阻止
```

### 4.3 调试技巧


**🔧 Chrome开发者工具检查**
```
1. 打开 Network 面板
2. 发起跨域请求
3. 查看失败的请求：
   - Status: (failed) 或 (blocked:mixed-content)
   - Response Headers: 查看是否有 Access-Control-Allow-Origin

4. Console 面板会显示详细错误信息
```

> 📝 **调试提示**：
> - 请求可能已经发送到服务器，但响应被浏览器拦截
> - 简单请求和复杂请求的错误信息略有不同
> - 预检请求(OPTIONS)失败也会导致实际请求被阻止

---

## 5. 🌐 跨域场景实际分析


### 5.1 前后端分离开发场景


**典型场景**：
```
前端开发服务器：http://localhost:3000  (React/Vue等)
后端API服务器：  http://localhost:8080  (Spring Boot/Express等)
```

**产生问题的代码**：
```javascript
// 前端代码
async function fetchUsers() {
  try {
    const response = await fetch('http://localhost:8080/api/users');
    const users = await response.json();
    console.log(users);
  } catch (error) {
    console.error('请求失败:', error);
    // ❌ 跨域错误：端口不同导致不同源
  }
}
```

**问题分析**：
- **前端源**：`http://localhost:3000`
- **API源**：`http://localhost:8080`
- **差异**：端口不同（3000 vs 8080）

### 5.2 微服务架构场景


**服务分布**：
```
主应用：    https://www.myapp.com
用户服务：  https://user.myapp.com
订单服务：  https://order.myapp.com
支付服务：  https://pay.myapp.com
```

**跨域请求示例**：
```javascript
// 在主应用中调用用户服务
fetch('https://user.myapp.com/api/profile')
  .then(response => response.json())
  .then(profile => {
    // 处理用户信息
  });

// ❌ 跨域问题：子域名不同
```

### 5.3 CDN资源访问场景


**资源分布**：
```
网站主域：https://www.company.com
静态资源：https://cdn.company.com
API接口： https://api.company.com
```

**场景分析**：
```javascript
// 获取CDN上的配置文件
fetch('https://cdn.company.com/config/app-config.json')
  .then(response => response.json())
  .then(config => {
    // 使用配置信息
  });

// 问题：主域名www与CDN子域名cdn不同源
```

### 5.4 第三方API调用场景


> ⚠️ **重要限制**：浏览器端JavaScript无法直接调用大多数第三方API

**无法直接调用的原因**：
```javascript
// ❌ 这种调用通常会失败
fetch('https://api.github.com/users/octocat')
  .then(response => response.json());

// 错误原因：
// 1. 协议不同：https://mysite.com vs https://api.github.com  
// 2. 域名完全不同
// 3. 大多数第三方API不允许浏览器直接跨域访问
```

**解决思路**：
- 🔄 **代理服务器**：通过自己的后端转发请求
- 🔑 **JSONP**：仅支持GET请求的老方法  
- 🌐 **CORS支持**：极少数API支持浏览器跨域

---

## 6. 🏠 子域名跨域解决方案


### 6.1 子域名跨域问题


**典型场景**：
```
主站：   https://www.example.com
子站：   https://app.example.com
管理后台：https://admin.example.com
```

**问题表现**：
```javascript
// 在 www.example.com 页面中
fetch('https://app.example.com/api/data')
  .then(response => response.json());

// ❌ 跨域错误：子域名不同
```

### 6.2 document.domain解决方案


**🔸 基本原理**
`document.domain`可以将页面的域名设置为其**父域名**，使不同子域名的页面能够相互访问。

**🔸 使用条件**
- ✅ 必须是同一个父域名下的子域名
- ✅ 必须使用相同的协议（都是http或都是https）
- ✅ 只能设置为当前域名的父域名

**🔸 实现步骤**

**步骤1：两个页面都设置相同的document.domain**
```javascript
// 在 www.example.com 页面中
document.domain = 'example.com';

// 在 app.example.com 页面中  
document.domain = 'example.com';
```

**步骤2：通过iframe实现跨子域通信**
```html
<!-- 在 www.example.com 页面中 -->
<iframe id="appFrame" src="https://app.example.com/page.html"></iframe>

<script>
// 设置相同的父域名
document.domain = 'example.com';

window.onload = function() {
  const iframe = document.getElementById('appFrame');
  
  // 现在可以访问iframe中的内容了
  iframe.onload = function() {
    // 访问iframe中的数据
    const appData = iframe.contentWindow.getData();
    console.log('获取到子站数据:', appData);
    
    // 调用iframe中的方法
    iframe.contentWindow.updateUser('张三');
  };
};
</script>
```

**步骤3：iframe页面配合**
```html
<!-- app.example.com/page.html -->
<script>
// 设置相同的父域名
document.domain = 'example.com';

// 提供数据访问方法
function getData() {
  return {
    userCount: 1250,
    activeUsers: 89
  };
}

// 提供功能方法
function updateUser(username) {
  console.log('更新用户:', username);
  // 执行实际的用户更新操作
}
</script>
```

### 6.3 使用限制与注意事项


**🔸 使用限制**
```javascript
// ✅ 允许的设置
// 当前域名：sub.example.com
document.domain = 'example.com';  // 设置为父域名

// ❌ 不允许的设置
document.domain = 'other.com';     // 不能设置为其他域名
document.domain = 'sub.example.com'; // 不能设置为更具体的子域名
```

**🔸 安全注意事项**
> ⚠️ **安全警告**：设置`document.domain`会降低页面的安全性，只在确实需要的情况下使用

```javascript
// 设置document.domain后的风险：
// 1. 同一父域名下的所有子域名都可以访问当前页面
// 2. 如果某个子域名被恶意控制，可能影响其他子域名
// 3. 建议只在可信的子域名之间使用
```

**🔸 现代替代方案**
```javascript
// 推荐使用 postMessage 进行跨域通信
// 更安全，更灵活，支持任意域名

// 发送消息到iframe
iframe.contentWindow.postMessage({
  type: 'getUserData',
  data: { userId: 123 }
}, 'https://app.example.com');

// 接收消息
window.addEventListener('message', function(event) {
  if (event.origin !== 'https://www.example.com') return;
  
  if (event.data.type === 'getUserData') {
    // 处理数据请求
  }
});
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 同源策略：浏览器安全机制，限制不同源之间的资源访问
🔸 同源条件：协议 + 域名 + 端口 完全相同
🔸 跨域问题：访问不同源资源时浏览器的阻止行为
🔸 安全意义：防止恶意网站窃取用户数据或进行恶意操作
🔸 解决思路：服务器配置CORS、代理转发、特殊方案等
```

### 7.2 关键理解要点


**🔹 跨域不是网络问题**
```
重要认知：
- 跨域请求通常能发送到服务器
- 服务器也会正常处理并返回响应  
- 是浏览器阻止了响应的读取
- 这是浏览器的安全保护机制
```

**🔹 开发环境vs生产环境**
```
开发环境：
- 前后端分离：localhost不同端口
- 热重载服务：webpack-dev-server代理

生产环境：  
- 子域名部署：API与前端使用不同子域名
- CDN资源：静态资源与主站域名不同
- 微服务架构：不同服务使用不同域名
```

**🔹 错误信息分析技巧**
```
快速定位：
1. 看错误类型：CORS、Same Origin Policy
2. 找地址信息：from origin、at url
3. 查响应头：Access-Control-Allow-Origin
4. 检查预检：OPTIONS请求是否成功
```

### 7.3 实际应用指导


**🎯 常见场景及解决思路**

| 场景 | 问题描述 | 推荐解决方案 |
|------|----------|-------------|
| **开发调试** | `localhost不同端口` | webpack代理或后端配置CORS |
| **生产部署** | `子域名分离` | 配置CORS或使用同一域名 |
| **第三方API** | `完全不同域名` | 后端代理转发 |
| **子域名通信** | `同父域名的子域名` | postMessage或document.domain |

**🔧 解决方案选择原则**
```
优先级排序：
1. 🥇 后端配置CORS（最标准的解决方案）
2. 🥈 开发代理（开发环境临时方案）  
3. 🥉 JSONP（仅GET请求，逐渐淘汰）
4. 🏅 postMessage（iframe通信推荐）
5. ⚠️ document.domain（有安全风险，谨慎使用）
```

**🚨 安全提醒**
```
开发注意事项：
- 不要在生产环境使用 Access-Control-Allow-Origin: *
- 优先使用具体域名而不是通配符
- 了解CORS预检请求的机制
- 敏感操作建议使用同源部署
```

### 7.4 学习路径建议


**🔄 渐进学习顺序**
```
1️⃣ 理解同源策略的基本概念和安全意义
2️⃣ 掌握同源判断规则和常见跨域场景  
3️⃣ 学会分析跨域错误信息和调试技巧
4️⃣ 了解各种跨域解决方案的适用场景
5️⃣ 在实际项目中实践和优化跨域处理
```

**核心记忆**：
- 同源策略是浏览器的安全门卫，保护用户数据安全
- 协议、域名、端口三要素决定是否同源
- 跨域是浏览器限制，不是网络问题  
- 理解问题本质，选择合适的解决方案