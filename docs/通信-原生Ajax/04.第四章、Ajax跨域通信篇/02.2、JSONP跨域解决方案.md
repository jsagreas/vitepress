---
title: 2、JSONP跨域解决方案
---
## 📚 目录

1. [JSONP核心概念](#1-JSONP核心概念)
2. [JSONP工作原理](#2-JSONP工作原理)
3. [callback函数机制](#3-callback函数机制)
4. [JSONP实现步骤](#4-JSONP实现步骤)
5. [动态script标签实现](#5-动态script标签实现)
6. [错误处理和超时控制](#6-错误处理和超时控制)
7. [优势和局限性对比](#7-优势和局限性对比)
8. [安全性考虑](#8-安全性考虑)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 JSONP核心概念


### 1.1 什么是JSONP？

> 💡 **核心概念**：JSONP（JSON with Padding）是一种绕过浏览器同源策略限制的跨域解决方案
> 
> **通俗理解**：就像借用快递员（script标签）来帮你从其他小区（不同域名）取包裹（数据）

**JSONP本质**：
- 📦 **不是新技术**：是对现有技术的巧妙运用
- 🎭 **利用漏洞**：利用script标签不受同源策略限制的特性
- 📞 **回调通信**：通过函数调用的方式传递数据

### 1.2 为什么需要JSONP？

**同源策略的限制**：
```
正常Ajax请求：
网站A (http://localhost:3000) 
    ↓ ❌ 被同源策略阻止
API服务器 (http://api.example.com)

JSONP方式：
网站A (http://localhost:3000)
    ↓ ✅ script标签可以跨域
API服务器 (http://api.example.com)
```

### 1.3 JSONP vs 普通JSON

```
普通JSON数据：
{"name": "张三", "age": 25}

JSONP数据：
callback({"name": "张三", "age": 25})
```

**关键差异**：
- 🔹 **JSON**：纯数据格式
- 🔹 **JSONP**：函数调用格式，数据作为参数

---

## 2. ⚙️ JSONP工作原理


### 2.1 script标签的特殊性质

> 💡 **核心原理**：script标签从诞生起就支持跨域加载资源，这是浏览器的设计特性

**为什么script标签可以跨域？**
```
网页中常见的跨域资源加载：
<script src="https://cdn.jsdelivr.net/jquery.js"></script>  ✅ 允许
<link href="https://cdn.jsdelivr.net/bootstrap.css">        ✅ 允许  
<img src="https://example.com/photo.jpg">                   ✅ 允许

Ajax请求：
fetch('https://api.example.com/data')                       ❌ 被阻止
```

### 2.2 JSONP工作流程图

```
客户端网页                     服务器
    |                           |
    |--[1]创建script标签------->|
    |   src="api?callback=fn"   |
    |                           |
    |<--[2]返回JS代码-----------|
    |   fn({data:"hello"})      |
    |                           |
    |--[3]自动执行函数--------->|
    |   处理返回的数据          |
```

### 2.3 详细执行过程

**步骤分解**：
1. **🎯 客户端准备**：定义一个回调函数
2. **📦 发送请求**：创建script标签，src指向跨域API
3. **🔄 服务器响应**：返回函数调用形式的数据
4. **⚡ 自动执行**：浏览器执行返回的JS代码
5. **📊 数据处理**：回调函数接收并处理数据

---

## 3. 📞 callback函数机制


### 3.1 callback函数的作用

> 💡 **核心理解**：callback函数就像是你的"接头暗号"，服务器知道用这个暗号来"呼叫"你

**callback机制解析**：
```javascript
// 1. 你定义一个函数（接头人）
function handleData(data) {
    console.log('收到数据：', data);
}

// 2. 告诉服务器你的函数名
// GET请求：http://api.example.com/user?callback=handleData

// 3. 服务器返回调用你函数的代码
// 返回内容：handleData({"name": "张三", "age": 25})

// 4. 浏览器自动执行，你的函数被调用
```

### 3.2 callback函数命名规则

**常见命名方式**：
- ✅ **固定名称**：`callback`、`jsonp`、`cb`
- ✅ **动态生成**：`jsonp_123456789`（避免冲突）
- ✅ **自定义名称**：根据API文档要求

```javascript
// 不同API的callback参数名
// 百度搜索建议API
'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=keyword&cb=callback'

// 360搜索建议API  
'https://sug.so.360.cn/suggest?word=keyword&callback=callback'
```

### 3.3 全局函数 vs 局部函数

```javascript
// ❌ 避免：污染全局作用域
function globalCallback(data) {
    console.log(data);
}

// ✅ 推荐：临时全局函数，用完删除
window['temp_callback_' + Date.now()] = function(data) {
    console.log(data);
    // 用完删除
    delete window['temp_callback_' + Date.now()];
};
```

---

## 4. 🛠️ JSONP实现步骤


### 4.1 基础实现步骤

**实现JSONP的5个关键步骤**：

```javascript
// 步骤1: 定义回调函数
function myCallback(data) {
    console.log('获取到数据:', data);
    document.getElementById('result').innerHTML = data.message;
}

// 步骤2: 创建script标签
const script = document.createElement('script');

// 步骤3: 设置跨域URL（包含callback参数）
script.src = 'https://api.example.com/data?callback=myCallback';

// 步骤4: 添加到页面，触发请求
document.head.appendChild(script);

// 步骤5: 清理资源（可选）
script.onload = function() {
    document.head.removeChild(script);
};
```

### 4.2 完整代码示例

```javascript
// 封装JSONP函数
function jsonp(url, params, callback) {
    // 生成唯一回调函数名
    const callbackName = 'jsonp_callback_' + Date.now();
    
    // 将回调函数挂载到window对象
    window[callbackName] = function(data) {
        callback(data);
        // 清理：删除全局函数
        delete window[callbackName];
        // 清理：删除script标签
        document.head.removeChild(script);
    };
    
    // 构建完整URL
    const fullUrl = url + '?callback=' + callbackName + '&' + 
                    Object.keys(params).map(key => key + '=' + params[key]).join('&');
    
    // 创建并执行请求
    const script = document.createElement('script');
    script.src = fullUrl;
    document.head.appendChild(script);
}

// 使用示例
jsonp('https://api.example.com/weather', 
      {city: '北京', key: 'your_api_key'}, 
      function(data) {
          console.log('天气信息:', data);
      }
);
```

### 4.3 实际使用场景

```javascript
// 场景1: 获取搜索建议
function getSearchSuggestions(keyword) {
    jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', 
          {wd: keyword}, 
          function(data) {
              // 显示搜索建议列表
              showSuggestions(data.s);
          }
    );
}

// 场景2: 获取IP地址信息
function getIPInfo() {
    jsonp('https://ip-api.com/json', 
          {}, 
          function(data) {
              console.log('你的IP:', data.query);
              console.log('所在城市:', data.city);
          }
    );
}
```

---

## 5. 🎬 动态script标签实现


### 5.1 动态创建的优势

> 💡 **为什么动态创建？**：静态script标签在页面加载时就执行，无法控制时机；动态创建可以按需发起请求

**动态 vs 静态对比**：
```html
<!-- ❌ 静态script标签：页面一加载就执行 -->
<script src="https://api.example.com/data?callback=myCallback"></script>

<!-- ✅ 动态创建：可控制执行时机 -->
<script>
function requestData() {
    const script = document.createElement('script');
    script.src = 'https://api.example.com/data?callback=myCallback';
    document.head.appendChild(script);
}
</script>
```

### 5.2 完整的动态实现

```javascript
class JSONPRequest {
    constructor() {
        this.requestId = 0;
    }
    
    // 发起JSONP请求
    request(url, params = {}, options = {}) {
        return new Promise((resolve, reject) => {
            // 生成唯一标识
            const callbackName = 'jsonp_' + (++this.requestId) + '_' + Date.now();
            
            // 创建全局回调函数
            window[callbackName] = (data) => {
                resolve(data);
                this.cleanup(callbackName, script);
            };
            
            // 创建script标签
            const script = document.createElement('script');
            
            // 构建URL
            const fullUrl = this.buildUrl(url, {...params, callback: callbackName});
            script.src = fullUrl;
            
            // 错误处理
            script.onerror = () => {
                reject(new Error('JSONP请求失败'));
                this.cleanup(callbackName, script);
            };
            
            // 设置超时
            if (options.timeout) {
                setTimeout(() => {
                    reject(new Error('请求超时'));
                    this.cleanup(callbackName, script);
                }, options.timeout);
            }
            
            // 发起请求
            document.head.appendChild(script);
        });
    }
    
    // 构建完整URL
    buildUrl(url, params) {
        const queryString = Object.keys(params)
            .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
            .join('&');
        return url + (url.includes('?') ? '&' : '?') + queryString;
    }
    
    // 清理资源
    cleanup(callbackName, script) {
        // 删除全局回调函数
        if (window[callbackName]) {
            delete window[callbackName];
        }
        
        // 删除script标签
        if (script && script.parentNode) {
            script.parentNode.removeChild(script);
        }
    }
}

// 使用示例
const jsonpClient = new JSONPRequest();

// 发起请求
jsonpClient.request('https://api.example.com/weather', 
                   {city: '上海'}, 
                   {timeout: 5000})
    .then(data => {
        console.log('天气数据:', data);
    })
    .catch(error => {
        console.error('请求失败:', error.message);
    });
```

### 5.3 script标签生命周期管理

```javascript
function manageScriptTags() {
    const scriptCache = new Map();
    
    return {
        // 创建script标签
        createScript(url, callbackName) {
            const script = document.createElement('script');
            script.src = url;
            script.setAttribute('data-callback', callbackName);
            
            // 缓存管理
            scriptCache.set(callbackName, script);
            
            return script;
        },
        
        // 清理指定script
        removeScript(callbackName) {
            const script = scriptCache.get(callbackName);
            if (script && script.parentNode) {
                script.parentNode.removeChild(script);
                scriptCache.delete(callbackName);
            }
        },
        
        // 清理所有script
        cleanup() {
            scriptCache.forEach((script, callbackName) => {
                this.removeScript(callbackName);
            });
        }
    };
}
```

---

## 6. ⚠️ 错误处理和超时控制


### 6.1 常见错误类型

**JSONP请求中的错误情况**：
- 🔹 **网络错误**：无法连接到服务器
- 🔹 **超时错误**：请求时间过长
- 🔹 **服务器错误**：API返回错误信息
- 🔹 **回调错误**：callback函数未定义或执行出错

### 6.2 错误处理实现

```javascript
function jsonpWithErrorHandling(url, params, options = {}) {
    return new Promise((resolve, reject) => {
        const callbackName = 'jsonp_' + Date.now();
        let isCompleted = false;
        
        // 成功回调
        window[callbackName] = function(data) {
            if (isCompleted) return;
            isCompleted = true;
            
            // 检查返回数据是否包含错误信息
            if (data.error) {
                reject(new Error(data.error.message || '服务器返回错误'));
            } else {
                resolve(data);
            }
            
            cleanup();
        };
        
        // 创建script标签
        const script = document.createElement('script');
        const fullUrl = buildUrl(url, {...params, callback: callbackName});
        script.src = fullUrl;
        
        // 网络错误处理
        script.onerror = function() {
            if (isCompleted) return;
            isCompleted = true;
            reject(new Error('网络请求失败，请检查网络连接'));
            cleanup();
        };
        
        // 超时处理
        const timeout = options.timeout || 10000; // 默认10秒
        const timeoutId = setTimeout(() => {
            if (isCompleted) return;
            isCompleted = true;
            reject(new Error(`请求超时（${timeout}ms），请稍后重试`));
            cleanup();
        }, timeout);
        
        // 清理函数
        function cleanup() {
            // 清理超时定时器
            clearTimeout(timeoutId);
            
            // 删除全局回调
            if (window[callbackName]) {
                delete window[callbackName];
            }
            
            // 删除script标签
            if (script.parentNode) {
                script.parentNode.removeChild(script);
            }
        }
        
        // 发起请求
        document.head.appendChild(script);
    });
}

// 使用示例：带完整错误处理
jsonpWithErrorHandling('https://api.example.com/data', 
                      {id: 123}, 
                      {timeout: 5000})
    .then(data => {
        console.log('请求成功:', data);
    })
    .catch(error => {
        console.error('请求失败:', error.message);
        
        // 根据不同错误类型给用户不同提示
        if (error.message.includes('超时')) {
            alert('网络较慢，请稍后重试');
        } else if (error.message.includes('网络')) {
            alert('网络连接异常，请检查网络设置');
        } else {
            alert('数据加载失败：' + error.message);
        }
    });
```

### 6.3 重试机制

```javascript
function jsonpWithRetry(url, params, options = {}) {
    const maxRetries = options.maxRetries || 3;
    const retryDelay = options.retryDelay || 1000;
    
    function attempt(retryCount = 0) {
        return jsonpWithErrorHandling(url, params, options)
            .catch(error => {
                // 如果还有重试次数，且是网络错误，则重试
                if (retryCount < maxRetries && 
                    (error.message.includes('网络') || error.message.includes('超时'))) {
                    
                    console.log(`请求失败，${retryDelay}ms后进行第${retryCount + 1}次重试...`);
                    
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve(attempt(retryCount + 1));
                        }, retryDelay);
                    });
                } else {
                    // 重试次数用完或非网络错误，直接抛出错误
                    throw error;
                }
            });
    }
    
    return attempt();
}
```

---

## 7. ⚖️ 优势和局限性对比


### 7.1 JSONP的优势

| 优势特点 | **详细说明** | **实际价值** |
|---------|------------|-------------|
| 🌐 **兼容性极好** | `支持所有浏览器，包括IE6` | `无需考虑浏览器兼容问题` |
| 🚀 **实现简单** | `几行代码就能实现跨域` | `学习成本低，快速上手` |
| 📦 **无需服务器配置** | `不需要设置CORS头部` | `前端独立解决跨域问题` |
| ⚡ **性能良好** | `script标签加载效率高` | `适合简单数据获取场景` |

### 7.2 JSONP的局限性

| 局限性 | **具体表现** | **影响程度** |
|-------|------------|-------------|
| ❌ **只支持GET请求** | `无法发送POST、PUT等请求` | `🔴 严重限制` |
| ❌ **安全性较低** | `容易受到XSS攻击` | `🔴 安全风险` |
| ❌ **错误处理困难** | `难以获取详细的错误信息` | `🟡 影响调试` |
| ❌ **需要服务器支持** | `服务器必须返回JSONP格式` | `🟡 依赖后端` |

### 7.3 适用场景判断

```
✅ 适合使用JSONP的场景：
• 获取公开API数据（天气、搜索建议等）
• 第三方服务集成（地图、支付等）
• 老旧浏览器兼容需求
• 简单的数据查询需求

❌ 不适合使用JSONP的场景：
• 需要POST/PUT/DELETE请求
• 传输敏感数据
• 需要详细错误处理
• 现代浏览器环境（推荐CORS）
```

### 7.4 JSONP vs 其他跨域方案

```
跨域方案对比：

JSONP:
优点：兼容性好，实现简单
缺点：只支持GET，安全性低

CORS:
优点：功能完整，安全性高  
缺点：需要服务器配置，IE10+

PostMessage:
优点：安全可控，支持任意数据
缺点：只适合窗口间通信

代理服务器:
优点：完全透明，无限制
缺点：增加服务器复杂度
```

---

## 8. 🔒 安全性考虑


### 8.1 主要安全风险

> ⚠️ **重要提醒**：JSONP本质上是执行第三方提供的JavaScript代码，存在安全隐患

**安全风险详解**：
```javascript
// 正常的JSONP返回
callback({"name": "张三", "age": 25});

// 恶意的JSONP返回  
callback({"name": "张三"}); 
alert('你的网站被攻击了！'); 
document.cookie = '';
// 恶意代码可能：
// 1. 窃取用户cookie
// 2. 重定向到恶意网站  
// 3. 修改页面内容
// 4. 发起恶意请求
```

### 8.2 安全防护措施

**防护策略**：
```javascript
// 1. 验证数据来源
function safeJsonp(url, params, callback) {
    // 白名单验证
    const trustedDomains = [
        'api.example.com',
        'weather.api.com',
        'search.api.com'
    ];
    
    const urlObj = new URL(url);
    if (!trustedDomains.includes(urlObj.hostname)) {
        throw new Error('不受信任的API域名');
    }
    
    // 继续JSONP请求...
}

// 2. 数据验证
function validateJsonpData(data) {
    // 检查数据格式
    if (typeof data !== 'object' || data === null) {
        throw new Error('无效的数据格式');
    }
    
    // 检查必要字段
    if (!data.hasOwnProperty('status') || !data.hasOwnProperty('data')) {
        throw new Error('数据结构不正确');
    }
    
    return data;
}

// 3. 限制执行时间
function timeoutJsonp(url, params, callback, timeout = 5000) {
    const callbackName = 'jsonp_' + Date.now();
    let isExecuted = false;
    
    window[callbackName] = function(data) {
        if (isExecuted) return; // 防止多次执行
        isExecuted = true;
        
        try {
            const validData = validateJsonpData(data);
            callback(validData);
        } catch (error) {
            console.error('数据验证失败:', error.message);
        }
        
        // 清理
        delete window[callbackName];
    };
    
    // 超时保护
    setTimeout(() => {
        if (!isExecuted) {
            isExecuted = true;
            delete window[callbackName];
            console.error('JSONP请求超时');
        }
    }, timeout);
}
```

### 8.3 最佳安全实践

**安全使用指南**：
1. **🔐 只信任可靠的API**：使用知名服务商的公开API
2. **📋 数据验证**：对返回数据进行格式和内容验证
3. **⏱️ 设置超时**：避免恶意脚本长时间执行
4. **🧹 及时清理**：请求完成后立即清理全局函数和DOM元素
5. **📝 错误处理**：完善的错误处理机制

```javascript
// 安全的JSONP封装示例
class SecureJSONP {
    constructor(trustedDomains = []) {
        this.trustedDomains = trustedDomains;
        this.requestCount = 0;
    }
    
    async request(url, params = {}, options = {}) {
        // 安全检查
        this.validateUrl(url);
        
        // 限制并发请求数量
        if (this.requestCount >= 5) {
            throw new Error('并发请求数量过多');
        }
        
        this.requestCount++;
        
        try {
            const data = await this.makeRequest(url, params, options);
            return this.validateData(data);
        } finally {
            this.requestCount--;
        }
    }
    
    validateUrl(url) {
        const urlObj = new URL(url);
        if (!this.trustedDomains.includes(urlObj.hostname)) {
            throw new Error(`不受信任的域名: ${urlObj.hostname}`);
        }
    }
    
    validateData(data) {
        // 实现数据验证逻辑
        if (typeof data !== 'object') {
            throw new Error('返回数据格式错误');
        }
        return data;
    }
}
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念

```
🔸 JSONP本质：利用script标签跨域特性的解决方案
🔸 工作原理：动态创建script标签 + callback函数机制  
🔸 数据格式：callback(json_data) 的函数调用形式
🔸 实现步骤：定义回调 → 创建script → 设置src → 添加到DOM
🔸 清理资源：删除全局函数和script标签
```

### 9.2 关键理解要点


**🔹 为什么JSONP可以跨域**
```
核心原因：
• script标签天生支持跨域加载资源
• 浏览器不对script标签实施同源策略限制
• 这是Web标准的设计特性，不是漏洞

实际应用：
• CDN加载第三方库 (jQuery、Bootstrap等)
• 加载第三方统计代码 (百度统计、Google Analytics等)
• 获取第三方API数据
```

**🔹 callback函数的精妙设计**
```
设计思路：
• 服务器不知道客户端的函数名
• 通过URL参数告诉服务器回调函数名
• 服务器返回调用该函数的JS代码
• 浏览器执行JS代码，自动调用客户端函数

优势：
• 实现了跨域数据传递
• 保持了异步执行特性
• 代码简洁易懂
```

**🔹 动态script标签的必要性**
```
为什么动态创建：
• 静态script在页面加载时就执行，无法控制时机
• 动态创建可以在需要时发起请求
• 可以传递参数和处理响应
• 便于资源清理和错误处理

实现要点：
• 创建script元素
• 设置src属性（包含callback参数）
• 添加到DOM触发请求
• 请求完成后清理资源
```

### 9.3 实际应用指导

```
适用场景：
✅ 获取第三方公开API数据
✅ 实现搜索建议功能
✅ 加载天气、地图等服务
✅ 兼容老旧浏览器的跨域需求

技术选择：
• 简单数据获取 → JSONP
• 复杂交互 → CORS  
• 现代浏览器 → Fetch + CORS
• 内部系统 → 代理服务器

注意事项：
• 只能用于GET请求
• 需要服务器支持JSONP格式
• 注意安全性，只使用可信任的API
• 做好错误处理和超时控制
```

### 9.4 学习进阶路径

```
掌握顺序：
1. 理解同源策略和跨域问题
2. 学会基础JSONP实现
3. 掌握动态script标签操作
4. 实现错误处理和超时控制
5. 了解安全性问题和防护措施
6. 对比其他跨域解决方案

实践项目：
• 实现搜索建议功能
• 获取天气信息显示
• 调用公开API展示数据
• 封装通用JSONP工具函数
```

**核心记忆口诀**：
- JSONP借script跨域巧，callback函数是关键
- 动态创建控时机，数据安全要验证  
- 只支持GET有局限，现代开发CORS先
- 理解原理知应用，跨域问题不再难