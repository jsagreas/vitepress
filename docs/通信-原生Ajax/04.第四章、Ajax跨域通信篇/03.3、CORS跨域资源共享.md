---
title: 3、CORS跨域资源共享
---
## 📚 目录

1. [CORS是什么](#1-CORS是什么)
2. [为什么需要CORS](#2-为什么需要CORS)
3. [简单请求与复杂请求](#3-简单请求与复杂请求)
4. [基本CORS头设置](#4-基本CORS头设置)
5. [预检请求处理](#5-预检请求处理)
6. [凭证传递处理](#6-凭证传递处理)
7. [暴露响应头](#7-暴露响应头)
8. [开发环境配置](#8-开发环境配置)
9. [生产环境部署](#9-生产环境部署)
10. [完整实例](#10-完整实例)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 🌐 CORS是什么


### 1.1 通俗理解CORS


**CORS**全称是 **Cross-Origin Resource Sharing**，中文叫**跨域资源共享**。

```
简单类比：
🏠 你家(域名A) 想要 🏪 隔壁商店(域名B) 的商品
🚫 默认情况：浏览器不允许，说"不认识，不给"
✅ CORS机制：商店贴个纸条说"允许你家来买东西"
```

**本质含义**：
- **跨域**：访问不同域名/端口/协议的资源
- **资源共享**：让服务器主动说"我允许你访问"
- **浏览器安全机制**：保护用户不被恶意网站攻击

### 1.2 同源策略复习


**同源定义**：协议 + 域名 + 端口 完全相同

```
🌍 举例理解：
当前页面：https://www.example.com:443/page

✅ 同源：
https://www.example.com:443/api    (只是路径不同)

❌ 跨域：  
http://www.example.com:443         (协议不同：http vs https)
https://api.example.com:443        (域名不同：子域名)
https://www.example.com:8080       (端口不同：8080 vs 443)
https://www.other.com:443          (域名完全不同)
```

---

## 2. 🤔 为什么需要CORS


### 2.1 实际场景需求


**现实开发中的跨域需求**：

```
📱 前后端分离项目：
前端：http://localhost:3000      (开发服务器)
后端：http://localhost:8080      (API服务器)
❌ 问题：端口不同，无法直接调用API

🌐 CDN资源调用：
页面：https://mysite.com
图片：https://cdn.mysite.com
❌ 问题：子域名不同，无法加载资源

🔗 第三方API调用：
页面：https://myapp.com  
API：https://api.weather.com
❌ 问题：域名不同，无法获取数据
```

### 2.2 没有CORS会怎样


```javascript
// 🚫 在 https://mysite.com 页面中
fetch('https://api.other.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    // ❌ 浏览器报错：
    // Access to fetch at 'https://api.other.com/data' 
    // from origin 'https://mysite.com' has been blocked by CORS policy
    console.error('跨域请求被阻止', error);
  });
```

---

## 3. 🔍 简单请求与复杂请求


### 3.1 简单请求的条件


**简单请求**必须同时满足：

```
📋 请求方法只能是：
✅ GET
✅ POST  
✅ HEAD

📋 请求头只能包含：
✅ Accept
✅ Accept-Language
✅ Content-Language
✅ Content-Type (仅限以下值)
   - text/plain
   - multipart/form-data
   - application/x-www-form-urlencoded
```

### 3.2 请求类型判断


```javascript
// ✅ 简单请求示例
fetch('https://api.example.com/users', {
  method: 'GET',                    // ✅ 允许的方法
  headers: {
    'Accept': 'application/json'    // ✅ 允许的头
  }
});

// ❌ 复杂请求示例  
fetch('https://api.example.com/users', {
  method: 'PUT',                    // ❌ 不在允许列表
  headers: {
    'Content-Type': 'application/json',  // ❌ 不在允许列表
    'Authorization': 'Bearer token'      // ❌ 自定义头
  }
});
```

### 3.3 处理流程区别


```
🔄 简单请求流程：
浏览器 → 直接发送请求 → 服务器
       ← 检查响应头   ← 

🔄 复杂请求流程：  
浏览器 → 发送预检请求(OPTIONS) → 服务器
       ← 检查预检响应          ←
       → 发送真正请求          →
       ← 检查最终响应          ←
```

---

## 4. ⚙️ 基本CORS头设置


### 4.1 Access-Control-Allow-Origin


**作用**：告诉浏览器哪些域名可以访问资源

```javascript
// 🌟 服务器端设置（Node.js Express示例）

// ✅ 允许特定域名
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://mysite.com');
  next();
});

// ✅ 允许所有域名（开发环境）
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  next();
});

// ✅ 动态允许（推荐生产环境）
const allowedOrigins = ['https://mysite.com', 'https://admin.mysite.com'];
app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  }
  next();
});
```

### 4.2 常用CORS响应头


```javascript
// 🔧 完整的基本CORS设置
app.use((req, res, next) => {
  // 允许的域名
  res.header('Access-Control-Allow-Origin', 'https://mysite.com');
  
  // 允许的请求方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  
  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  next();
});
```

---

## 5. 🔍 预检请求处理


### 5.1 什么是预检请求


**预检请求**：浏览器在发送复杂请求前，先发送一个OPTIONS请求询问服务器是否允许。

```
💭 生活类比：
你要去朋友家做客（复杂请求）
先打电话问："我能过来吗？能带礼物吗？"（预检请求）
朋友说："可以，欢迎"（预检响应）
然后你才真正去做客（实际请求）
```

### 5.2 预检请求的触发


```javascript
// 🎯 这个请求会触发预检
fetch('https://api.example.com/users', {
  method: 'PUT',                           // ❌ 非简单方法
  headers: {
    'Content-Type': 'application/json',    // ❌ 非简单Content-Type
    'Authorization': 'Bearer token123'     // ❌ 自定义头
  },
  body: JSON.stringify({ name: '张三' })
});
```

### 5.3 处理OPTIONS请求


```javascript
// 🔧 服务器处理预检请求
app.options('*', (req, res) => {
  // 设置预检响应头
  res.header('Access-Control-Allow-Origin', 'https://mysite.com');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Max-Age', '86400'); // 缓存预检结果24小时
  res.sendStatus(200);
});

// 🔧 实际API处理
app.put('/users', (req, res) => {
  // 同样需要设置CORS头
  res.header('Access-Control-Allow-Origin', 'https://mysite.com');
  res.json({ message: '用户更新成功' });
});
```

### 5.4 预检请求流程图


```
客户端                               服务器
   |                                    |
   |--[1] OPTIONS预检请求--------------->|
   |    Method: OPTIONS                 |
   |    Access-Control-Request-Method   |
   |    Access-Control-Request-Headers  |
   |                                    |
   |<--[2] 预检响应--------------------- |
   |    Access-Control-Allow-Origin     |
   |    Access-Control-Allow-Methods    |
   |    Access-Control-Allow-Headers    |
   |                                    |
   |--[3] 实际PUT请求------------------>|
   |    Method: PUT                     |
   |    Content-Type: application/json  |
   |                                    |
   |<--[4] 实际响应---------------------|
   |    数据 + CORS头                   |
```

---

## 6. 🔐 凭证传递处理


### 6.1 什么是凭证传递


**凭证**包括：Cookie、HTTP认证信息、客户端SSL证书

```
🍪 举例说明：
用户登录后，服务器设置了登录Cookie
当Ajax请求其他接口时，需要带上这个Cookie来验证身份
但跨域请求默认不会携带Cookie
```

### 6.2 启用凭证传递


```javascript
// 🔧 前端：启用凭证传递
fetch('https://api.example.com/profile', {
  method: 'GET',
  credentials: 'include',  // 🌟 关键设置：包含凭证
  headers: {
    'Accept': 'application/json'
  }
});

// 或者使用XMLHttpRequest
const xhr = new XMLHttpRequest();
xhr.withCredentials = true;  // 🌟 关键设置：包含凭证
xhr.open('GET', 'https://api.example.com/profile');
xhr.send();
```

### 6.3 服务器支持凭证


```javascript
// 🔧 服务器：允许凭证传递
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://mysite.com'); // ❌ 不能是 '*'
  res.header('Access-Control-Allow-Credentials', 'true');          // ✅ 允许凭证
  next();
});
```

> **⚠️ 重要提醒**：当设置 `Access-Control-Allow-Credentials: true` 时，`Access-Control-Allow-Origin` 不能设置为 `*`，必须指定具体域名。

---

## 7. 📤 暴露响应头


### 7.1 默认可访问的响应头


**浏览器默认只允许前端代码访问这些响应头**：

```
✅ 默认可访问：
- Cache-Control
- Content-Language  
- Content-Type
- Expires
- Last-Modified
- Pragma
```

### 7.2 暴露自定义响应头


```javascript
// 🔧 服务器：暴露自定义响应头
app.get('/api/data', (req, res) => {
  // 设置自定义响应头
  res.header('X-Total-Count', '100');
  res.header('X-Page-Number', '1');
  
  // 暴露自定义头供前端访问
  res.header('Access-Control-Expose-Headers', 'X-Total-Count, X-Page-Number');
  res.header('Access-Control-Allow-Origin', 'https://mysite.com');
  
  res.json({ users: [...] });
});
```

### 7.3 前端读取暴露的头


```javascript
// 🔍 前端：读取暴露的响应头
fetch('https://api.example.com/data')
  .then(response => {
    // ✅ 可以读取暴露的自定义头
    const totalCount = response.headers.get('X-Total-Count');
    const pageNumber = response.headers.get('X-Page-Number');
    
    console.log('总数:', totalCount);  // 输出: 100
    console.log('页码:', pageNumber);  // 输出: 1
    
    return response.json();
  })
  .then(data => console.log(data));
```

---

## 8. 🛠️ 开发环境配置


### 8.1 webpack devServer配置


```javascript
// 📁 webpack.config.js
module.exports = {
  devServer: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',  // 后端服务器
        changeOrigin: true,               // 修改请求头中的origin
        secure: false                     // 如果是https，设置为true
      }
    }
  }
};
```

### 8.2 Vue CLI配置


```javascript
// 📁 vue.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        ws: true,          // 支持websocket
        changeOrigin: true,
        pathRewrite: {
          '^/api': '/api'  // 重写路径
        }
      }
    }
  }
};
```

### 8.3 开发环境使用示例


```javascript
// 🔧 开发环境下的Ajax请求
// 不需要写完整URL，直接使用相对路径
fetch('/api/users')  // 实际请求：http://localhost:3000/api/users
  .then(response => response.json())
  .then(data => console.log(data));

// webpack会自动转发到：http://localhost:8080/api/users
```

---

## 9. 🚀 生产环境部署


### 9.1 Nginx反向代理


```nginx
# 📁 nginx.conf
server {
    listen 80;
    server_name mysite.com;
    
    # 前端静态文件
    location / {
        root /var/www/frontend;
        try_files $uri $uri/ /index.html;
    }
    
    # API代理
    location /api/ {
        proxy_pass http://backend-server:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 9.2 Node.js生产环境CORS


```javascript
// 🔧 生产环境CORS中间件
const cors = require('cors');

const corsOptions = {
  origin: [
    'https://mysite.com',
    'https://www.mysite.com',
    'https://admin.mysite.com'
  ],
  credentials: true,                    // 允许凭证
  exposedHeaders: ['X-Total-Count'],    // 暴露自定义头
  maxAge: 86400                         // 预检请求缓存时间
};

app.use(cors(corsOptions));
```

---

## 10. 💻 完整实例


### 10.1 前端完整示例


```javascript
// 🎯 前端：处理各种CORS场景
class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  // 简单GET请求
  async getUsers() {
    try {
      const response = await fetch(`${this.baseURL}/users`, {
        method: 'GET',
        credentials: 'include',  // 包含Cookie
        headers: {
          'Accept': 'application/json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('获取用户失败:', error);
      throw error;
    }
  }
  
  // 复杂POST请求
  async createUser(userData) {
    try {
      const response = await fetch(`${this.baseURL}/users`, {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.getToken()}`
        },
        body: JSON.stringify(userData)
      });
      
      if (!response.ok) {
        throw new Error(`创建用户失败: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('创建用户失败:', error);
      throw error;
    }
  }
  
  getToken() {
    return localStorage.getItem('authToken');
  }
}

// 使用示例
const api = new ApiClient('https://api.example.com');
api.getUsers().then(users => console.log(users));
```

### 10.2 后端完整示例


```javascript
// 🔧 后端：Express完整CORS处理
const express = require('express');
const app = express();

// CORS中间件
const setupCORS = (req, res, next) => {
  const allowedOrigins = [
    'https://mysite.com',
    'https://admin.mysite.com'
  ];
  
  const origin = req.headers.origin;
  
  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
  }
  
  res.header('Access-Control-Allow-Credentials', 'true');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Accept');
  res.header('Access-Control-Expose-Headers', 'X-Total-Count, X-Page-Count');
  res.header('Access-Control-Max-Age', '86400');
  
  // 处理预检请求
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
    return;
  }
  
  next();
};

app.use(setupCORS);
app.use(express.json());

// API路由
app.get('/users', (req, res) => {
  const users = [
    { id: 1, name: '张三' },
    { id: 2, name: '李四' }
  ];
  
  res.header('X-Total-Count', users.length.toString());
  res.json(users);
});

app.post('/users', (req, res) => {
  const newUser = {
    id: Date.now(),
    ...req.body
  };
  
  res.status(201).json(newUser);
});

app.listen(8080, () => {
  console.log('服务器运行在 http://localhost:8080');
});
```

---

## 11. 📋 核心要点总结


### 11.1 必须理解的概念


```
🔸 CORS本质：服务器主动允许跨域访问的机制
🔸 同源策略：浏览器的安全限制，协议+域名+端口必须相同
🔸 简单请求：满足特定条件，直接发送的请求
🔸 复杂请求：需要预检，先发OPTIONS询问的请求
🔸 预检请求：浏览器发送OPTIONS询问服务器是否允许跨域
```

### 11.2 关键配置要点


**🔹 基本CORS设置**
```javascript
// 最基本的CORS设置
res.header('Access-Control-Allow-Origin', '具体域名');
res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
```

**🔹 凭证传递要点**
```javascript
// 前端启用凭证
fetch(url, { credentials: 'include' });

// 后端允许凭证（Origin不能是*）
res.header('Access-Control-Allow-Credentials', 'true');
res.header('Access-Control-Allow-Origin', 'https://specific-domain.com');
```

**🔹 预检请求处理**
```javascript
// 处理OPTIONS预检请求
if (req.method === 'OPTIONS') {
  // 设置CORS头
  res.sendStatus(200);
  return;
}
```

### 11.3 常见错误避免


```
❌ 常见错误1：Origin设置为*但启用了凭证传递
✅ 正确做法：启用凭证时必须指定具体域名

❌ 常见错误2：忘记处理OPTIONS预检请求  
✅ 正确做法：专门处理OPTIONS方法

❌ 常见错误3：只在某些路由设置CORS头
✅ 正确做法：使用中间件统一处理

❌ 常见错误4：开发环境正常，生产环境跨域
✅ 正确做法：生产环境也要正确配置CORS
```

### 11.4 实际应用建议


**开发环境**：使用代理服务器，避免跨域问题
**生产环境**：在后端正确设置CORS头，或使用Nginx代理
**安全考虑**：只允许可信域名访问，避免使用通配符*
**性能优化**：设置合适的预检缓存时间，减少OPTIONS请求

**核心记忆**：
- CORS是服务器说"我允许你跨域访问"
- 简单请求直接发，复杂请求先问再发
- 凭证传递时Origin不能用星号
- 开发用代理，生产配CORS