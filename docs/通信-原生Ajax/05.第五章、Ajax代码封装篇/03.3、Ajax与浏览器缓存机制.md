---
title: 3、Ajax与浏览器缓存机制
---
## 📚 目录

1. [什么是浏览器缓存](#1-什么是浏览器缓存)
2. [HTTP缓存的两大类型](#2-HTTP缓存的两大类型)
3. [强缓存机制详解](#3-强缓存机制详解)
4. [协商缓存机制详解](#4-协商缓存机制详解)
5. [Ajax中的缓存问题](#5-Ajax中的缓存问题)
6. [缓存问题的解决方案](#6-缓存问题的解决方案)
7. [实际应用场景](#7-实际应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🧠 什么是浏览器缓存


### 1.1 缓存的本质

**简单理解**：缓存就像你的记忆力，浏览器会"记住"之前访问过的资源，下次需要时直接从"记忆"中取出，而不用重新去网上下载。

```
没有缓存的情况：
用户 → "我要看图片" → 服务器 → "给你图片" → 用户看到图片
用户 → "我又要看同一张图片" → 服务器 → "再给你一次图片" → 用户看到图片

有缓存的情况：
用户 → "我要看图片" → 服务器 → "给你图片，浏览器记住它" → 用户看到图片
用户 → "我又要看同一张图片" → 浏览器 → "我记得，直接给你" → 用户立即看到图片
```

### 1.2 为什么需要缓存

- ✅ **提升速度**：不用重复下载，瞬间显示内容
- ✅ **节省流量**：减少网络传输，省钱省带宽  
- ✅ **减轻服务器压力**：服务器不用重复发送相同内容
- ✅ **改善用户体验**：页面加载更快，操作更流畅

> 💡 **生活比喻**  
> 就像你去图书馆借书，如果每次都要重新办借书证、重新找书、重新排队，会很麻烦。缓存就是让你"记住"常用的书在哪里，直接去拿就行。

---

## 2. 🔄 HTTP缓存的两大类型


### 2.1 缓存分类概览

HTTP缓存分为两大类，就像两种不同的"记忆方式"：

```
┌─────────────────────────────────────┐
│            HTTP缓存                  │
├─────────────────┬───────────────────┤
│    强缓存        │     协商缓存        │
│ (Strong Cache)   │ (Negotiation Cache)│
├─────────────────┼───────────────────┤
│ 直接使用缓存      │ 询问服务器后决定    │
│ 不发请求到服务器  │ 要发请求到服务器    │
│ 速度最快         │ 速度较快           │
└─────────────────┴───────────────────┘
```

### 2.2 两种缓存的区别


| 特征 | **强缓存** | **协商缓存** |
|------|-----------|-------------|
| 🌐 **是否发请求** | `不发请求` | `发请求询问` |
| ⚡ **速度** | `最快` | `较快` |
| 📊 **状态码** | `200 (from cache)` | `304 Not Modified` |
| 🎯 **使用场景** | `不常变的资源` | `可能会变的资源` |

---

## 3. 💪 强缓存机制详解


### 3.1 什么是强缓存

**通俗理解**：强缓存就像在你家里存零食，饿了直接吃，不用问妈妈"这个零食还能吃吗？"

浏览器直接使用本地缓存，完全不联系服务器。

### 3.2 强缓存的两个关键字段


#### 🕒 Expires (过期时间)

```http
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```

**含义**：告诉浏览器"这个资源在2025年10月21日之前都是新鲜的，直接用就行"

**问题**：
- ❌ 依赖客户端时间，如果用户改了电脑时间就出错
- ❌ 是绝对时间，不够灵活

#### 🎛️ Cache-Control (缓存控制)

```http
Cache-Control: max-age=3600
```

**含义**：告诉浏览器"这个资源可以缓存3600秒(1小时)"

**常用值**：
- `max-age=3600` - 缓存1小时
- `no-cache` - 不要直接用缓存，要问问服务器
- `no-store` - 完全不要缓存
- `public` - 任何地方都可以缓存
- `private` - 只有用户浏览器可以缓存

> 💡 **优先级**  
> Cache-Control 比 Expires 优先级更高，如果两个都有，听 Cache-Control 的

### 3.3 强缓存示例


```javascript
// 服务器设置强缓存
app.get('/api/data', (req, res) => {
    // 设置缓存1小时
    res.setHeader('Cache-Control', 'max-age=3600');
    res.json({ message: '这是数据' });
});
```

**工作流程**：
```
第一次请求：
浏览器 → 服务器 → 返回数据 + Cache-Control: max-age=3600
浏览器存储：数据 + 过期时间(当前时间 + 1小时)

第二次请求(1小时内)：
浏览器检查：过期时间还没到，直接使用缓存
结果：200 (from cache)，不发网络请求
```

---

## 4. 🤝 协商缓存机制详解


### 4.1 什么是协商缓存

**通俗理解**：协商缓存就像问朋友"你有没有新版本的游戏？"，朋友说"没有，你那个就是最新的"，你就继续用旧的。

浏览器会询问服务器："我这个缓存还能用吗？"

### 4.2 协商缓存的两对字段


#### 📅 Last-Modified & If-Modified-Since


**服务器响应**：
```http
Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT
```
**含义**：告诉浏览器"这个文件最后修改时间是2024年10月21日"

**浏览器请求**：
```http
If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT
```
**含义**：问服务器"我这个文件是2024年10月21日的，有更新吗？"

**服务器判断**：
- 如果文件没变：返回 `304 Not Modified`
- 如果文件变了：返回 `200` + 新内容

#### 🏷️ ETag & If-None-Match


**服务器响应**：
```http
ETag: "abc123xyz"
```
**含义**：给文件一个"指纹"，就像身份证号

**浏览器请求**：
```http
If-None-Match: "abc123xyz"
```
**含义**：问服务器"我这个文件指纹是abc123xyz，还是最新的吗？"

> 💡 **ETag vs Last-Modified**  
> - ETag更精确，即使时间没变但内容变了，ETag也会变
> - ETag优先级更高
> - Last-Modified只能精确到秒，ETag可以更精确

### 4.3 协商缓存示例


```javascript
// 服务器设置协商缓存
app.get('/api/news', (req, res) => {
    const etag = '"news-v1.2.3"';
    
    // 检查客户端ETag
    if (req.headers['if-none-match'] === etag) {
        res.status(304).end(); // 没变化，返回304
    } else {
        res.setHeader('ETag', etag);
        res.json({ news: '最新新闻内容' });
    }
});
```

**工作流程**：
```
第一次请求：
浏览器 → 服务器 → 返回数据 + ETag: "v1.2.3"

第二次请求：
浏览器 → 服务器 (带上 If-None-Match: "v1.2.3")
服务器检查：内容没变，返回 304
浏览器：收到304，使用本地缓存
```

---

## 5. ⚠️ Ajax中的缓存问题


### 5.1 常见的缓存问题


**问题场景**：你做了一个新闻网站，用Ajax获取最新新闻，但总是显示旧新闻。

```javascript
// 问题代码
function getNews() {
    fetch('/api/news')
        .then(res => res.json())
        .then(data => {
            console.log(data); // 总是显示缓存的旧新闻！
        });
}
```

**为什么会这样？**
- 浏览器认为GET请求的URL没变，就使用缓存
- 特别是IE浏览器，非常"固执"地使用缓存

### 5.2 GET请求的缓存特点

```
缓存规则：
- GET请求：容易被缓存
- POST请求：一般不会被缓存
- 相同URL的GET请求：浏览器可能直接返回缓存
```

> ⚠️ **注意**  
> 这就是为什么有时候你的Ajax请求"没反应"，实际上是浏览器偷偷用了缓存

---

## 6. 🛠️ 缓存问题的解决方案


### 6.1 方案一：添加时间戳参数


**原理**：让每次请求的URL都不一样，浏览器就不会使用缓存

```javascript
function getNews() {
    // 添加时间戳，确保URL每次都不同
    const timestamp = new Date().getTime();
    
    fetch(`/api/news?t=${timestamp}`)
        .then(res => res.json())
        .then(data => {
            console.log(data); // 获取最新数据
        });
}
```

**效果**：
```
第一次：/api/news?t=1634567890123
第二次：/api/news?t=1634567891456
第三次：/api/news?t=1634567892789
// 每次URL都不同，浏览器不会缓存
```

### 6.2 方案二：添加随机数参数


```javascript
function getNews() {
    // 添加随机数
    const random = Math.random();
    
    fetch(`/api/news?r=${random}`)
        .then(res => res.json())
        .then(data => console.log(data));
}
```

### 6.3 方案三：设置请求头


```javascript
function getNews() {
    fetch('/api/news', {
        headers: {
            'Cache-Control': 'no-cache',    // 不要使用缓存
            'Pragma': 'no-cache'           // 兼容老浏览器
        }
    })
    .then(res => res.json())
    .then(data => console.log(data));
}
```

### 6.4 方案四：使用POST请求


```javascript
function getNews() {
    // POST请求一般不会被缓存
    fetch('/api/news', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({})
    })
    .then(res => res.json())
    .then(data => console.log(data));
}
```

### 6.5 封装防缓存函数


```javascript
// 封装一个防缓存的Ajax函数
function ajaxNoCache(url, options = {}) {
    // 自动添加时间戳防止缓存
    const separator = url.includes('?') ? '&' : '?';
    const noCacheUrl = `${url}${separator}_t=${Date.now()}`;
    
    return fetch(noCacheUrl, {
        ...options,
        headers: {
            'Cache-Control': 'no-cache',
            ...options.headers
        }
    });
}

// 使用
ajaxNoCache('/api/news')
    .then(res => res.json())
    .then(data => console.log(data));
```

---

## 7. 🎯 实际应用场景


### 7.1 适合使用缓存的场景


```javascript
// 1. 用户头像 - 很少变化
fetch('/api/user/avatar', {
    headers: {
        'Cache-Control': 'max-age=86400' // 缓存1天
    }
});

// 2. 静态配置数据 - 基本不变
fetch('/api/config', {
    headers: {
        'Cache-Control': 'max-age=3600' // 缓存1小时
    }
});
```

### 7.2 不适合使用缓存的场景


```javascript
// 1. 实时数据 - 必须最新
function getRealTimeStock() {
    const timestamp = Date.now();
    fetch(`/api/stock?_t=${timestamp}`)  // 防缓存
        .then(res => res.json())
        .then(data => updateStockPrice(data));
}

// 2. 用户操作结果 - 需要及时反馈
function submitForm(formData) {
    fetch('/api/submit', {
        method: 'POST',  // POST请求不缓存
        body: formData
    });
}
```

### 7.3 混合策略示例


```javascript
class DataService {
    // 获取用户信息 - 允许短时间缓存
    getUserInfo(useCache = true) {
        let url = '/api/user/info';
        
        if (!useCache) {
            url += `?_t=${Date.now()}`;  // 强制刷新
        }
        
        return fetch(url);
    }
    
    // 获取实时消息 - 永远不缓存
    getMessages() {
        return fetch(`/api/messages?_t=${Date.now()}`);
    }
    
    // 获取系统配置 - 长时间缓存
    getConfig() {
        return fetch('/api/config', {
            headers: {
                'Cache-Control': 'max-age=3600'
            }
        });
    }
}
```

---

## 8. 📋 核心要点总结


### 8.1 必须理解的核心概念


```
🔸 缓存本质：浏览器的"记忆力"，避免重复下载
🔸 强缓存：直接使用缓存，不问服务器
🔸 协商缓存：问服务器后再决定是否使用缓存
🔸 Ajax缓存问题：GET请求容易被缓存，导致数据不更新
🔸 防缓存方案：时间戳、随机数、请求头、POST请求
```

### 8.2 关键理解要点


**🔹 缓存的双刃剑性质**
```
好处：速度快、省流量、减轻服务器压力
坏处：可能显示过期数据，影响实时性
关键：在性能和实时性之间找平衡
```

**🔹 Ajax中的缓存策略**
```
静态数据：充分利用缓存提升性能
动态数据：防止缓存确保实时性
用户操作：根据场景灵活选择
```

**🔹 解决方案的选择**
```
时间戳方案：最简单有效，推荐使用
请求头方案：更规范，但兼容性要注意
POST方案：适合有数据提交的场景
混合策略：根据不同数据类型区别对待
```

### 8.3 实战开发建议


- ✅ **默认防缓存**：Ajax获取动态数据时默认加时间戳
- ✅ **分场景处理**：静态资源用缓存，实时数据防缓存
- ✅ **用户体验优先**：宁可多请求一次，也不要显示错误数据
- ✅ **性能监控**：观察缓存策略对页面性能的影响

### 8.4 常见错误避免


- ❌ **忽视缓存**：不知道Ajax可能被缓存，数据更新不及时
- ❌ **过度防缓存**：所有请求都防缓存，影响性能
- ❌ **缓存策略不当**：该缓存的不缓存，不该缓存的乱缓存
- ❌ **兼容性问题**：只考虑现代浏览器，忽视IE等老浏览器

**核心记忆**：
- 缓存像记忆，提速又省力
- 强缓存不问服务器，协商缓存要询问
- Ajax防缓存，时间戳最简单
- 静态数据可缓存，动态数据要实时