---
title: 2、Promise化Ajax实现
---
## 📚 目录

1. [回调地狱问题分析](#1-回调地狱问题分析)
2. [Promise基础概念回顾](#2-Promise基础概念回顾)
3. [Ajax的Promise封装实现](#3-Ajax的Promise封装实现)
4. [resolve和reject的正确使用](#4-resolve和reject的正确使用)
5. [then和catch的链式调用](#5-then和catch的链式调用)
6. [async/await语法糖应用](#6-async-await语法糖应用)
7. [错误传播和处理机制](#7-错误传播和处理机制)
8. [Promise.all并发请求处理](#8-Promise-all并发请求处理)
9. [Promise.race竞态请求处理](#9-Promise-race竞态请求处理)
10. [取消Promise请求的实现](#10-取消Promise请求的实现)
11. [核心要点总结](#11-核心要点总结)

---

## 1. 😵 回调地狱问题分析


### 1.1 什么是回调地狱


**💡 通俗理解**：回调地狱就是函数里套函数，套了一层又一层，代码变得像"楼梯"一样越来越深，难看又难维护。

```javascript
// 😱 回调地狱示例 - 获取用户信息后获取订单，再获取订单详情
ajax('/api/user', function(userData) {
    // 第一层：获取用户信息成功
    ajax('/api/orders?userId=' + userData.id, function(orderData) {
        // 第二层：获取订单信息成功
        ajax('/api/order-detail?orderId=' + orderData.id, function(detailData) {
            // 第三层：获取订单详情成功
            console.log('最终结果:', detailData);
        }, function(error) {
            console.error('订单详情错误:', error);
        });
    }, function(error) {
        console.error('订单错误:', error);
    });
}, function(error) {
    console.error('用户错误:', error);
});
```

### 1.2 回调地狱的问题


**🚨 主要问题**：
- **📐 代码形状** - 越写越往右偏，像楼梯一样
- **🔧 难以维护** - 修改逻辑需要在多层嵌套中找位置
- **❌ 错误处理** - 每一层都要单独处理错误，重复代码多
- **🧠 难以理解** - 业务逻辑被嵌套结构打散，不好读懂

```
传统Ajax流程图：
用户信息 → 订单信息 → 订单详情 → 最终结果
   ↓         ↓         ↓         ↓
  成功      嵌套      再嵌套    三层嵌套
   ↓         ↓         ↓         ↓  
  失败    单独处理   单独处理   单独处理
```

---

## 2. 🎯 Promise基础概念回顾


### 2.1 Promise是什么


**💭 Promise的本质**：Promise就像现实生活中的"承诺"，我现在给你一个承诺，这个承诺有三种状态：

```
Promise状态机：

等待中(pending) → 要么成功(fulfilled) → 调用then
                ↘ 要么失败(rejected)  → 调用catch

一旦状态改变，就不能再变了！
```

**🔗 用生活例子理解**：
- **点外卖**：下单后商家给你一个"承诺"，会在30分钟内送达
- **pending**：正在制作中，还没有结果
- **fulfilled**：30分钟内送到了，承诺兑现 ✅
- **rejected**：超时了或者取消了，承诺失败 ❌

### 2.2 Promise基本语法


```javascript
// 📝 创建Promise的基本结构
const myPromise = new Promise((resolve, reject) => {
    // 这里写异步操作
    const success = true; // 假设这是异步操作的结果
    
    if (success) {
        resolve('成功的数据'); // 承诺成功，传递数据
    } else {
        reject('失败的原因');   // 承诺失败，传递错误
    }
});

// 📞 使用Promise的结果
myPromise
    .then(data => {
        console.log('成功了:', data); // 处理成功情况
    })
    .catch(error => {
        console.log('失败了:', error); // 处理失败情况
    });
```

### 2.3 Promise的核心优势


| 传统回调 | Promise | 优势说明 |
|---------|---------|----------|
| `callback(error, data)` | `.then(data).catch(error)` | 📝 **语法清晰**：成功失败分开处理 |
| 层层嵌套 | 链式调用 | 📏 **代码扁平**：不会越写越深 |
| 每层处理错误 | 统一catch | 🎯 **错误统一**：一个地方处理所有错误 |
| 难以组合 | Promise.all | 🔄 **易于组合**：多个异步操作轻松管理 |

---

## 3. 🔧 Ajax的Promise封装实现


### 3.1 封装思路分析


**🎯 封装目标**：把传统的Ajax回调函数改造成返回Promise的函数

```
传统Ajax：
ajax(url, successCallback, errorCallback)

Promise化Ajax：
ajaxPromise(url).then(successHandler).catch(errorHandler)
```

### 3.2 基础Promise封装


```javascript
// 📦 最简单的Promise封装版本
function ajaxPromise(url, options = {}) {
    return new Promise((resolve, reject) => {
        // 1️⃣ 创建XMLHttpRequest对象
        const xhr = new XMLHttpRequest();
        
        // 2️⃣ 设置请求参数
        const method = options.method || 'GET';
        
        // 3️⃣ 监听状态变化
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) { // 请求完成
                if (xhr.status >= 200 && xhr.status < 300) {
                    // ✅ 请求成功：调用resolve
                    resolve(xhr.responseText);
                } else {
                    // ❌ 请求失败：调用reject
                    reject(new Error(`请求失败: ${xhr.status}`));
                }
            }
        };
        
        // 4️⃣ 处理网络错误
        xhr.onerror = function() {
            reject(new Error('网络错误'));
        };
        
        // 5️⃣ 发送请求
        xhr.open(method, url);
        xhr.send(options.data || null);
    });
}
```

### 3.3 完整功能的Promise封装


```javascript
// 🚀 功能完整的Promise Ajax封装
function ajax(options) {
    // 📋 设置默认参数
    const config = {
        url: '',
        method: 'GET',
        data: null,
        headers: {},
        timeout: 5000,
        responseType: 'json',
        ...options
    };
    
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        // ⏰ 设置超时
        xhr.timeout = config.timeout;
        
        // 📄 设置响应类型
        if (config.responseType === 'json') {
            xhr.responseType = 'text'; // 我们手动解析JSON
        }
        
        // 👂 监听完成事件
        xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
                let response = xhr.responseText;
                
                // 🔄 自动解析JSON
                if (config.responseType === 'json') {
                    try {
                        response = JSON.parse(response);
                    } catch (e) {
                        reject(new Error('JSON解析失败'));
                        return;
                    }
                }
                
                resolve(response);
            } else {
                reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
            }
        };
        
        // ⚠️ 错误处理
        xhr.onerror = () => reject(new Error('网络错误'));
        xhr.ontimeout = () => reject(new Error('请求超时'));
        
        // 🚀 发送请求
        xhr.open(config.method, config.url);
        
        // 📨 设置请求头
        Object.keys(config.headers).forEach(key => {
            xhr.setRequestHeader(key, config.headers[key]);
        });
        
        // 📤 发送数据
        let sendData = config.data;
        if (config.data && typeof config.data === 'object') {
            sendData = JSON.stringify(config.data);
            xhr.setRequestHeader('Content-Type', 'application/json');
        }
        
        xhr.send(sendData);
    });
}
```

---

## 4. ✅ resolve和reject的正确使用


### 4.1 resolve的使用场景


**🎯 resolve的作用**：告诉Promise"任务成功完成了"，并把成功的结果传递出去

```javascript
// ✅ 正确的resolve使用
function fetchUserData(userId) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        xhr.onload = function() {
            if (xhr.status === 200) {
                const userData = JSON.parse(xhr.responseText);
                
                // 🎉 成功时调用resolve，传递数据
                resolve(userData);
            } else {
                // ❌ 失败时调用reject，不是resolve
                reject(new Error('用户不存在'));
            }
        };
        
        xhr.open('GET', `/api/users/${userId}`);
        xhr.send();
    });
}

// 📞 使用方式
fetchUserData(123)
    .then(user => {
        console.log('用户信息:', user); // 这里接收resolve传递的数据
    });
```

### 4.2 reject的使用场景


**🚨 reject的作用**：告诉Promise"任务失败了"，并说明失败的原因

```javascript
// 常见的reject场景
function validateAndFetch(url) {
    return new Promise((resolve, reject) => {
        // 1️⃣ 参数验证失败
        if (!url) {
            reject(new Error('URL不能为空'));
            return;
        }
        
        const xhr = new XMLHttpRequest();
        
        xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr.responseText);
            } else {
                // 2️⃣ HTTP错误
                reject(new Error(`请求失败: ${xhr.status}`));
            }
        };
        
        // 3️⃣ 网络错误
        xhr.onerror = () => reject(new Error('网络连接失败'));
        
        // 4️⃣ 超时错误
        xhr.ontimeout = () => reject(new Error('请求超时'));
        
        xhr.open('GET', url);
        xhr.send();
    });
}
```

### 4.3 resolve和reject的注意事项


**💡 重要提醒**：

```javascript
// ❌ 错误示例：resolve后还调用reject
function badExample() {
    return new Promise((resolve, reject) => {
        resolve('成功');
        reject('失败'); // 这行代码不会执行！Promise状态已经确定
    });
}

// ✅ 正确示例：确保只调用一次
function goodExample() {
    return new Promise((resolve, reject) => {
        const success = Math.random() > 0.5;
        
        if (success) {
            resolve('成功');
        } else {
            reject('失败');
        }
        // 确保resolve和reject只会调用其中一个
    });
}
```

**📝 核心规则**：
- ✅ Promise状态一旦改变就不能再变
- ✅ resolve和reject只能调用其中一个
- ✅ 多次调用同一个函数，只有第一次生效
- ✅ 建议使用`return`语句避免后续代码执行

---

## 5. 🔗 then和catch的链式调用


### 5.1 链式调用的基本概念


**🔗 链式调用的原理**：每个`.then()`都会返回一个新的Promise，所以可以一直`.then()`下去

```javascript
// 🔄 链式调用示例
ajax({url: '/api/users/1'})
    .then(user => {
        console.log('第一步：获取用户', user);
        // 🎯 返回新的Promise，继续链式调用
        return ajax({url: `/api/orders/${user.id}`});
    })
    .then(orders => {
        console.log('第二步：获取订单', orders);
        // 🎯 返回处理后的数据
        return orders.filter(order => order.status === 'paid');
    })
    .then(paidOrders => {
        console.log('第三步：筛选已支付订单', paidOrders);
    })
    .catch(error => {
        console.error('任何一步出错都会到这里:', error);
    });
```

### 5.2 链式调用的数据传递


```javascript
// 📊 数据在链式调用中的流动
function processUserData(userId) {
    return ajax({url: `/api/users/${userId}`})
        .then(user => {
            // 📝 第一步：处理用户数据
            console.log('原始用户数据:', user);
            
            // 🔄 返回处理后的数据给下一个then
            return {
                id: user.id,
                name: user.name,
                email: user.email.toLowerCase() // 邮箱转小写
            };
        })
        .then(cleanUser => {
            // 📝 第二步：获取用户的订单
            console.log('清理后的用户数据:', cleanUser);
            
            // 🔄 返回新的Ajax请求
            return ajax({url: `/api/orders/${cleanUser.id}`});
        })
        .then(orders => {
            // 📝 第三步：计算订单总数
            console.log('用户订单:', orders);
            return {
                orderCount: orders.length,
                totalAmount: orders.reduce((sum, order) => sum + order.amount, 0)
            };
        });
}

// 📞 使用
processUserData(123)
    .then(result => {
        console.log('最终结果:', result);
        // 输出: { orderCount: 5, totalAmount: 1250 }
    })
    .catch(error => {
        console.error('处理失败:', error);
    });
```

### 5.3 错误传播机制


**🚨 错误传播规则**：链式调用中任何一个环节出错，都会跳过后续的`.then()`，直接进入`.catch()`

```javascript
// 🔍 错误传播示例
ajax({url: '/api/users/1'})
    .then(user => {
        console.log('✅ 第一步成功:', user);
        return ajax({url: '/api/invalid-url'}); // 这里会失败
    })
    .then(data => {
        console.log('❌ 这里不会执行，因为上一步失败了');
        return data;
    })
    .then(finalData => {
        console.log('❌ 这里也不会执行');
    })
    .catch(error => {
        console.log('🚨 错误被捕获:', error);
        // 上面任何一个环节出错，都会来到这里
    });
```

### 5.4 在链式调用中处理错误


```javascript
// 🛠️ 链式调用中的错误恢复
function robustDataFetch(userId) {
    return ajax({url: `/api/users/${userId}`})
        .then(user => {
            return ajax({url: `/api/preferences/${user.id}`});
        })
        .catch(error => {
            console.warn('获取用户偏好失败，使用默认值:', error.message);
            // 🔄 错误恢复：返回默认值继续链式调用
            return { theme: 'light', language: 'zh-CN' };
        })
        .then(preferences => {
            console.log('用户偏好（可能是默认值）:', preferences);
            return preferences;
        });
}
```

---

## 6. 🍯 async/await语法糖应用


### 6.1 async/await是什么


**🍭 语法糖的含义**：async/await就像是Promise的"糖衣"，让异步代码看起来像同步代码一样简单

```javascript
// 😵 传统Promise链式调用
function getOrderInfo() {
    return ajax({url: '/api/users/1'})
        .then(user => {
            return ajax({url: `/api/orders/${user.id}`});
        })
        .then(orders => {
            return ajax({url: `/api/order-details/${orders[0].id}`});
        })
        .then(details => {
            return details;
        })
        .catch(error => {
            console.error('获取订单信息失败:', error);
            throw error;
        });
}

// 😍 async/await版本
async function getOrderInfo() {
    try {
        const user = await ajax({url: '/api/users/1'});
        const orders = await ajax({url: `/api/orders/${user.id}`});
        const details = await ajax({url: `/api/order-details/${orders[0].id}`});
        return details;
    } catch (error) {
        console.error('获取订单信息失败:', error);
        throw error;
    }
}
```

### 6.2 async函数的特点


**📝 async函数的特点**：
- ✅ 函数前面加`async`关键字
- ✅ 自动返回Promise对象
- ✅ 可以在函数内使用`await`
- ✅ 看起来像同步代码，实际是异步的

```javascript
// 🔍 async函数示例
async function fetchUserProfile(userId) {
    // 📊 await会等待Promise完成，然后返回结果
    const user = await ajax({url: `/api/users/${userId}`});
    console.log('获取到用户:', user);
    
    const avatar = await ajax({url: `/api/avatars/${user.avatarId}`});
    console.log('获取到头像:', avatar);
    
    // 🎯 返回组合结果
    return {
        ...user,
        avatarUrl: avatar.url
    };
}

// 📞 使用async函数
fetchUserProfile(123)
    .then(profile => {
        console.log('用户资料:', profile);
    })
    .catch(error => {
        console.error('获取失败:', error);
    });
```

### 6.3 await的使用规则


**⚠️ await使用注意事项**：

```javascript
// ✅ 正确使用await
async function correctUsage() {
    // 1️⃣ await只能在async函数内使用
    const data = await ajax({url: '/api/data'});
    
    // 2️⃣ await会等待Promise完成
    console.log('数据获取完成:', data);
    
    // 3️⃣ 可以await任何返回Promise的函数
    const result = await processData(data);
    return result;
}

// ❌ 错误使用await
function wrongUsage() {
    // 错误：不能在普通函数中使用await
    // const data = await ajax({url: '/api/data'}); // 语法错误！
}

// ✅ 在非async函数中使用Promise
function alternativeUsage() {
    return ajax({url: '/api/data'})
        .then(data => {
            console.log('数据获取完成:', data);
            return processData(data);
        });
}
```

### 6.4 错误处理的最佳实践


```javascript
// 🛡️ try/catch错误处理
async function safeDataFetch(userId) {
    try {
        // 📊 正常的业务逻辑
        const user = await ajax({url: `/api/users/${userId}`});
        const orders = await ajax({url: `/api/orders/${user.id}`});
        
        return {
            user,
            orderCount: orders.length
        };
        
    } catch (error) {
        // 🚨 统一错误处理
        console.error('数据获取失败:', error.message);
        
        // 🔄 可以选择返回默认值或重新抛出错误
        if (error.message.includes('网络')) {
            throw new Error('网络连接异常，请稍后重试');
        } else {
            return { user: null, orderCount: 0 };
        }
    }
}

// 🎯 分别处理不同类型的错误
async function detailedErrorHandling(userId) {
    let user, orders;
    
    try {
        user = await ajax({url: `/api/users/${userId}`});
    } catch (error) {
        console.error('获取用户失败:', error);
        return null;
    }
    
    try {
        orders = await ajax({url: `/api/orders/${user.id}`});
    } catch (error) {
        console.warn('获取订单失败，使用空数组:', error);
        orders = []; // 使用默认值
    }
    
    return { user, orders };
}
```

---

## 7. 🚨 错误传播和处理机制


### 7.1 Promise错误传播原理


**🔄 错误传播机制**：在Promise链中，错误会自动"冒泡"到最近的错误处理器

```
Promise链中的错误传播：

step1().then(step2).then(step3).catch(handleError)
  ↓       ↓        ↓        ↓
 成功    成功     失败    捕获错误
        ↓        ↓        ↓
       继续    跳过后续   处理错误
```

### 7.2 不同层级的错误处理


```javascript
// 📊 多层错误处理示例
function processUserOrder(userId) {
    return ajax({url: `/api/users/${userId}`})
        .then(user => {
            if (!user.active) {
                throw new Error('用户账户已停用');
            }
            return ajax({url: `/api/orders/${user.id}`});
        })
        .catch(error => {
            // 🔍 中间错误处理：可以选择恢复或重新抛出
            if (error.message.includes('账户已停用')) {
                console.warn('用户账户问题:', error.message);
                return []; // 返回空订单列表，继续后续处理
            } else {
                throw error; // 重新抛出其他错误
            }
        })
        .then(orders => {
            console.log('订单处理:', orders);
            return orders.filter(order => order.status === 'pending');
        })
        .catch(error => {
            // 🚨 最终错误处理
            console.error('处理流程失败:', error.message);
            throw new Error('订单处理服务暂时不可用');
        });
}
```

### 7.3 全局错误处理


```javascript
// 🌐 全局Promise错误处理
window.addEventListener('unhandledrejection', function(event) {
    console.error('未处理的Promise错误:', event.reason);
    
    // 📊 可以发送错误报告到服务器
    ajax({
        url: '/api/error-report',
        method: 'POST',
        data: {
            error: event.reason.message,
            url: window.location.href,
            timestamp: new Date().toISOString()
        }
    }).catch(() => {
        // 静默处理错误报告失败
    });
    
    // 阻止错误打印到控制台（可选）
    event.preventDefault();
});

// 📝 推荐的错误处理包装函数
function safeAjax(options) {
    return ajax(options)
        .catch(error => {
            // 🏷️ 统一错误格式化
            const standardError = {
                message: error.message,
                type: 'ajax_error',
                url: options.url,
                method: options.method || 'GET',
                timestamp: Date.now()
            };
            
            console.error('Ajax请求失败:', standardError);
            throw standardError;
        });
}
```

---

## 8. 🚀 Promise.all并发请求处理


### 8.1 Promise.all的基本概念


**🎯 Promise.all的作用**：同时发起多个请求，等所有请求都完成后再处理结果

```javascript
// 🔄 串行请求（一个接一个）- 慢
async function serialRequests() {
    const user = await ajax({url: '/api/users/1'});      // 等待1秒
    const posts = await ajax({url: '/api/posts/1'});     // 再等待1秒  
    const comments = await ajax({url: '/api/comments/1'}); // 再等待1秒
    
    return { user, posts, comments }; // 总共等待3秒
}

// 🚀 并行请求（同时进行）- 快
async function parallelRequests() {
    const [user, posts, comments] = await Promise.all([
        ajax({url: '/api/users/1'}),     // 同时开始
        ajax({url: '/api/posts/1'}),     // 同时开始
        ajax({url: '/api/comments/1'})   // 同时开始
    ]);
    
    return { user, posts, comments }; // 只需要等待1秒（最慢的那个）
}
```

### 8.2 Promise.all的使用场景


```javascript
// 📊 获取页面所需的所有数据
async function loadDashboard(userId) {
    try {
        console.log('🚀 开始并发加载数据...');
        
        const [userInfo, statistics, notifications, settings] = await Promise.all([
            ajax({url: `/api/users/${userId}`}),
            ajax({url: `/api/statistics/${userId}`}),
            ajax({url: `/api/notifications/${userId}`}),
            ajax({url: `/api/settings/${userId}`})
        ]);
        
        console.log('✅ 所有数据加载完成');
        
        return {
            userInfo,
            statistics,
            notifications,
            settings
        };
        
    } catch (error) {
        console.error('❌ 数据加载失败:', error);
        throw error;
    }
}

// 📞 使用示例
loadDashboard(123)
    .then(dashboardData => {
        console.log('仪表板数据:', dashboardData);
        // 渲染页面
    })
    .catch(error => {
        console.error('仪表板加载失败:', error);
        // 显示错误页面
    });
```

### 8.3 Promise.all的错误处理


**⚠️ 重要特性**：Promise.all中任何一个请求失败，整个Promise.all就会失败

```javascript
// 🛡️ 让部分失败不影响整体的解决方案
function safePromiseAll(promises) {
    return Promise.all(
        promises.map(promise => 
            promise.catch(error => ({ error, success: false }))
        )
    );
}

// 📊 使用示例
async function loadDashboardSafely(userId) {
    const results = await safePromiseAll([
        ajax({url: `/api/users/${userId}`}),
        ajax({url: `/api/statistics/${userId}`}),
        ajax({url: `/api/notifications/${userId}`}),
        ajax({url: `/api/invalid-endpoint`}) // 这个会失败
    ]);
    
    // 📝 处理结果，区分成功和失败
    const [userResult, statsResult, notifResult, invalidResult] = results;
    
    return {
        userInfo: userResult.error ? null : userResult,
        statistics: statsResult.error ? null : statsResult,
        notifications: notifResult.error ? [] : notifResult,
        hasErrors: results.some(result => result.error)
    };
}
```

### 8.4 Promise.allSettled的应用


```javascript
// 🔍 使用Promise.allSettled处理部分成功的情况
async function loadDashboardWithDetails(userId) {
    const promises = [
        ajax({url: `/api/users/${userId}`}),
        ajax({url: `/api/statistics/${userId}`}),
        ajax({url: `/api/notifications/${userId}`}),
        ajax({url: `/api/settings/${userId}`})
    ];
    
    const results = await Promise.allSettled(promises);
    
    // 📊 分析结果
    const dashboard = {};
    const errors = [];
    
    results.forEach((result, index) => {
        const keys = ['userInfo', 'statistics', 'notifications', 'settings'];
        
        if (result.status === 'fulfilled') {
            dashboard[keys[index]] = result.value;
        } else {
            dashboard[keys[index]] = null;
            errors.push(`${keys[index]}: ${result.reason.message}`);
        }
    });
    
    return { dashboard, errors };
}
```

---

## 9. 🏃 Promise.race竞态请求处理


### 9.1 Promise.race的基本概念


**🏁 Promise.race的特点**：多个Promise同时开始，谁先完成（成功或失败）就用谁的结果

```javascript
// 🏃‍♂️ Promise.race示例：超时控制
function ajaxWithTimeout(url, timeout = 5000) {
    const ajaxPromise = ajax({url});
    
    const timeoutPromise = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('请求超时'));
        }, timeout);
    });
    
    // 🏁 谁先完成用谁的结果
    return Promise.race([ajaxPromise, timeoutPromise]);
}

// 📞 使用示例
ajaxWithTimeout('/api/slow-endpoint', 3000)
    .then(data => {
        console.log('✅ 在3秒内完成:', data);
    })
    .catch(error => {
        if (error.message === '请求超时') {
            console.log('⏰ 请求超过3秒，已取消');
        } else {
            console.log('❌ 其他错误:', error);
        }
    });
```

### 9.2 多服务器竞速请求


```javascript
// 🌐 多个服务器同时请求，使用最快响应的结果
function fastestResponse(urls) {
    const promises = urls.map(url => ajax({url}));
    return Promise.race(promises);
}

// 📊 使用示例：从多个CDN获取数据
async function loadResourceFast() {
    const cdnUrls = [
        'https://cdn1.example.com/api/data',
        'https://cdn2.example.com/api/data',
        'https://cdn3.example.com/api/data'
    ];
    
    try {
        const data = await fastestResponse(cdnUrls);
        console.log('✅ 最快的CDN响应:', data);
        return data;
    } catch (error) {
        console.log('❌ 所有CDN都失败了:', error);
        throw error;
    }
}
```

### 9.3 请求重试机制


```javascript
// 🔄 使用Promise.race实现智能重试
function smartRetry(url, maxRetries = 3) {
    let attempt = 0;
    
    function tryRequest() {
        attempt++;
        console.log(`📡 第${attempt}次尝试请求: ${url}`);
        
        const requestPromise = ajax({url});
        const timeoutPromise = new Promise((resolve, reject) => {
            setTimeout(() => reject(new Error('单次请求超时')), 2000);
        });
        
        return Promise.race([requestPromise, timeoutPromise])
            .catch(error => {
                if (attempt < maxRetries) {
                    console.log(`⚠️ 第${attempt}次失败，准备重试...`);
                    return new Promise(resolve => {
                        setTimeout(() => resolve(tryRequest()), 1000); // 1秒后重试
                    });
                } else {
                    throw new Error(`所有${maxRetries}次尝试都失败了: ${error.message}`);
                }
            });
    }
    
    return tryRequest();
}

// 📞 使用示例
smartRetry('/api/unstable-endpoint')
    .then(data => {
        console.log('🎉 最终成功获取数据:', data);
    })
    .catch(error => {
        console.error('💔 彻底失败:', error.message);
    });
```

---

## 10. ❌ 取消Promise请求的实现


### 10.1 AbortController的基本使用


**🛑 取消请求的原理**：使用`AbortController`来发送取消信号

```javascript
// 🛠️ 支持取消的Ajax封装
function cancellableAjax(options) {
    const controller = new AbortController();
    
    const promise = new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        // 🎯 监听取消信号
        controller.signal.addEventListener('abort', () => {
            xhr.abort();
            reject(new Error('请求已取消'));
        });
        
        xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(`HTTP ${xhr.status}`));
            }
        };
        
        xhr.onerror = () => reject(new Error('网络错误'));
        
        xhr.open(options.method || 'GET', options.url);
        xhr.send(options.data || null);
    });
    
    // 🔗 返回Promise和取消函数
    return {
        promise,
        cancel: () => controller.abort()
    };
}

// 📞 使用示例
const request = cancellableAjax({url: '/api/large-data'});

request.promise
    .then(data => {
        console.log('✅ 数据加载完成:', data);
    })
    .catch(error => {
        if (error.message === '请求已取消') {
            console.log('🛑 用户取消了请求');
        } else {
            console.error('❌ 其他错误:', error);
        }
    });

// 🕐 3秒后取消请求
setTimeout(() => {
    request.cancel();
    console.log('⏰ 请求已被取消');
}, 3000);
```

### 10.2 页面切换时自动取消请求


```javascript
// 🔄 页面级请求管理器
class PageRequestManager {
    constructor() {
        this.activeRequests = new Set();
    }
    
    // 📤 发起请求
    request(options) {
        const controller = new AbortController();
        
        const promise = ajax({
            ...options,
            signal: controller.signal
        }).finally(() => {
            // 🧹 请求完成后清理
            this.activeRequests.delete(controller);
        });
        
        this.activeRequests.add(controller);
        
        return {
            promise,
            cancel: () => {
                controller.abort();
                this.activeRequests.delete(controller);
            }
        };
    }
    
    // 🛑 取消所有未完成的请求
    cancelAll() {
        console.log(`🧹 取消${this.activeRequests.size}个未完成请求`);
        this.activeRequests.forEach(controller => {
            controller.abort();
        });
        this.activeRequests.clear();
    }
}

// 📱 在单页应用中使用
const requestManager = new PageRequestManager();

// 🔄 页面切换时清理
window.addEventListener('beforeunload', () => {
    requestManager.cancelAll();
});

// 📞 发起请求
const userRequest = requestManager.request({url: '/api/users/1'});
userRequest.promise
    .then(user => console.log('用户数据:', user))
    .catch(error => console.log('请求被取消或失败:', error.message));
```

### 10.3 超时自动取消


```javascript
// ⏰ 带超时的请求函数
function requestWithTimeout(options, timeout = 10000) {
    const controller = new AbortController();
    
    // 🕐 设置超时取消
    const timeoutId = setTimeout(() => {
        controller.abort();
    }, timeout);
    
    const promise = ajax({
        ...options,
        signal: controller.signal
    }).finally(() => {
        clearTimeout(timeoutId); // 🧹 清理定时器
    });
    
    return {
        promise,
        cancel: () => {
            clearTimeout(timeoutId);
            controller.abort();
        }
    };
}

// 📞 使用示例
const request = requestWithTimeout({url: '/api/data'}, 5000);

request.promise
    .then(data => {
        console.log('✅ 5秒内完成:', data);
    })
    .catch(error => {
        if (error.name === 'AbortError') {
            console.log('⏰ 请求超时或被取消');
        } else {
            console.error('❌ 其他错误:', error);
        }
    });
```

---

## 11. 📋 核心要点总结


### 11.1 必须掌握的核心概念


```
🔸 回调地狱：函数嵌套问题，Promise是解决方案
🔸 Promise状态：pending → fulfilled/rejected，状态不可逆
🔸 resolve/reject：成功调用resolve，失败调用reject
🔸 链式调用：.then()返回新Promise，可以一直链下去
🔸 async/await：Promise的语法糖，让异步代码像同步代码
🔸 错误传播：错误会自动冒泡到最近的错误处理器
🔸 Promise.all：并发执行，等待所有完成
🔸 Promise.race：竞速执行，使用最先完成的结果
🔸 请求取消：使用AbortController实现取消功能
```

### 11.2 关键理解要点


**🔹 Promise vs 回调函数**
```
回调函数：层层嵌套，难以维护
Promise：链式调用，逻辑清晰
async/await：看起来像同步，实际异步执行
```

**🔹 错误处理的层次**
```
单个Promise：.catch()处理
Promise链：错误会冒泡到最近的.catch()
async/await：try/catch包裹整个流程
全局处理：unhandledrejection事件
```

**🔹 并发 vs 串行**
```
串行：一个完成再执行下一个，总时间 = 各个时间之和
并发：同时执行多个，总时间 = 最长的那个时间
选择原则：有依赖关系用串行，无依赖关系用并发
```

### 11.3 实际应用指导


**💡 最佳实践**：
- ✅ **优先使用async/await**：代码更清晰易懂
- ✅ **合理使用Promise.all**：提高页面加载速度
- ✅ **统一错误处理**：在合适的层级捕获和处理错误
- ✅ **支持请求取消**：提升用户体验
- ✅ **避免嵌套**：使用链式调用或async/await

**⚠️ 常见陷阱**：
- ❌ 忘记return Promise导致链式调用断裂
- ❌ 在非async函数中使用await
- ❌ Promise.all中一个失败导致全部失败
- ❌ 忘记处理错误导致unhandledrejection

**🎯 应用场景选择**：
- **简单请求**：直接使用Promise
- **复杂流程**：使用async/await
- **并发请求**：使用Promise.all
- **竞速请求**：使用Promise.race
- **用户交互**：支持取消功能

**核心记忆口诀**：
- Promise解决回调地狱，状态一旦变不可逆
- then串联catch捕获，async await语法糖
- all并发race竞速，error处理要统一
- 取消功能用户喜，代码清晰是王道