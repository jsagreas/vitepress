---
title: 2、提交规范与约定
---
## 📚 目录

1. [什么是提交规范](#1-什么是提交规范)
2. [Conventional Commits规范详解](#2-conventional-commits规范详解)
3. [提交消息结构深入理解](#3-提交消息结构深入理解)
4. [提交类型完全指南](#4-提交类型完全指南)
5. [作用域定义与使用](#5-作用域定义与使用)
6. [破坏性变更处理](#6-破坏性变更处理)
7. [提交模板设置实战](#7-提交模板设置实战)
8. [自动化提交检查](#8-自动化提交检查)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 什么是提交规范


### 1.1 为什么需要提交规范


**生活中的类比理解**：
想象你在写日记，如果每天都随便写"今天很好"、"事情做完了"，过了一个月你根本不知道具体发生了什么。但如果你按照格式写"学习：完成了数学作业"、"修复：解决了电脑蓝屏问题"，那就一目了然了。

**Git提交也是一样的道理**：
```
❌ 糟糕的提交消息：
- "修改了一些东西"
- "bug fix"
- "更新"
- "asdfgh"

✅ 规范的提交消息：
- "feat(user): 新增用户登录功能"  
- "fix(payment): 修复支付金额计算错误"
- "docs(readme): 更新安装说明文档"
```

### 1.2 提交规范的核心价值


**🔍 提高代码历史可读性**
```
规范前的提交历史：
commit a1b2c3d  修改了一些文件
commit e4f5g6h  bug修复
commit i7j8k9l  更新

规范后的提交历史：
commit a1b2c3d  feat(auth): 添加用户注册功能
commit e4f5g6h  fix(cart): 修复购物车商品数量显示错误  
commit i7j8k9l  docs(api): 更新API文档说明
```

**🚀 支持自动化工具**
- **自动生成更新日志**：工具可以根据提交类型自动分类
- **自动化版本发布**：根据提交类型决定版本号升级规则
- **CI/CD触发规则**：不同类型提交触发不同的自动化流程

### 1.3 团队协作的必要性


> 💡 **新手理解要点**  
> 就像团队写作业要统一格式一样，团队开发也需要统一的提交格式，这样每个人都能快速理解别人做了什么修改

---

## 2. 📋 Conventional Commits规范详解


### 2.1 Conventional Commits是什么


**简单定义**：Conventional Commits是一个规范化Git提交消息的标准，它规定了提交消息应该怎么写才能让人和机器都容易理解。

**官方定义解读**：
```
Conventional Commits 1.0.0规范建立在语义化版本之上，
为提交消息提供了一个轻量级的约定。
```

**用大白话说**：就是给Git提交消息定了一个"写作格式"，让大家都按这个格式写，这样：
- ✅ 人看得懂：一眼就知道这次改了什么
- ✅ 工具能处理：自动化工具可以解析和处理
- ✅ 团队统一：所有人都用相同的格式

### 2.2 核心规范原则


**📝 基本格式**：
```
type(scope): description

[optional body]

[optional footer(s)]
```

**用中文理解**：
```
类型(影响范围): 简短描述

[可选的详细说明]

[可选的页脚信息]
```

**实际例子对比**：
```
🔸 最简单的格式：
feat: 添加用户登录功能

🔸 带作用域的格式：
feat(auth): 添加用户登录功能

🔸 完整格式：
feat(auth): 添加用户登录功能

实现了用户名密码登录，包括：
- 登录表单验证
- 密码加密存储
- 登录状态保持

Closes #123
```

---

## 3. 🏗️ 提交消息结构深入理解


### 3.1 结构组成详解


**完整结构示意图**：
```
┌─────────────────────────────────────┐
│ type(scope): subject               │ ← 标题行（必需）
├─────────────────────────────────────┤
│ [空行]                             │ ← 分隔符
├─────────────────────────────────────┤
│ body content                       │ ← 正文（可选）
│ 详细描述本次提交的内容              │
├─────────────────────────────────────┤
│ [空行]                             │ ← 分隔符
├─────────────────────────────────────┤
│ footer information                 │ ← 页脚（可选）
│ BREAKING CHANGE: 描述破坏性变更     │
│ Closes #123                        │
└─────────────────────────────────────┘
```

### 3.2 标题行（Header）详解


**标题行格式**：`type(scope): subject`

**各部分说明**：

| 部分 | 是否必需 | 说明 | 示例 |
|------|---------|------|------|
| **type** | ✅ 必需 | 提交类型，说明这次提交是做什么的 | `feat`, `fix`, `docs` |
| **scope** | ⭐ 可选 | 影响范围，说明这次修改影响了哪个模块 | `auth`, `user`, `payment` |
| **subject** | ✅ 必需 | 简短描述，说明具体做了什么 | `添加用户登录功能` |

**标题行编写规则**：
- 🔸 **长度限制**：整行不超过50个字符（中文约25个字符）
- 🔸 **语言规范**：使用一般现在时，如"添加"而不是"添加了"
- 🔸 **首字母**：subject首字母小写
- 🔸 **结尾**：不要加句号

```
✅ 正确示例：
feat(auth): 添加用户登录功能
fix(cart): 修复商品数量显示错误

❌ 错误示例：
feat(auth): 添加了用户登录功能。  # 用了过去时，加了句号
FEAT(AUTH): ADD USER LOGIN        # 全大写
feat(auth): 添加用户登录功能，包括表单验证、密码加密、状态保持等功能  # 太长了
```

### 3.3 正文（Body）使用指南


**什么时候需要写正文**：
- ✅ 需要解释**为什么**做这个修改
- ✅ 需要说明**如何**实现的
- ✅ 修改比较复杂，标题行说不清楚

**正文编写要点**：
```
✅ 好的正文示例：
feat(payment): 添加微信支付功能

为了支持更多用户的支付需求，集成了微信支付API。
主要实现了以下功能：
- 调用微信支付统一下单接口
- 处理支付结果回调
- 添加支付状态查询

此次修改不影响现有的支付宝支付功能。

❌ 不必要的正文：
fix: 修复拼写错误

修复了一个拼写错误  # 这种简单修改不需要正文
```

### 3.4 页脚（Footer）使用场景


**常见页脚类型**：

**🔗 关联Issue**：
```
Closes #123
Fixes #456
Resolves #789
```

**⚠️ 破坏性变更**：
```
BREAKING CHANGE: 用户API的响应格式已更改
BREAKING CHANGE: 删除了旧版本的配置文件支持
```

**👥 协作者信息**：
```
Co-authored-by: 张三 <zhangsan@example.com>
Reviewed-by: 李四 <lisi@example.com>
```

---

## 4. 🏷️ 提交类型完全指南


### 4.1 必须掌握的核心类型


| 类型 | 中文含义 | 使用场景 | 示例 |
|------|---------|---------|------|
| **feat** | 新功能 | 添加新的功能特性 | `feat(user): 添加用户头像上传功能` |
| **fix** | 修复 | 修复bug或问题 | `fix(login): 修复密码验证逻辑错误` |
| **docs** | 文档 | 只修改文档 | `docs(readme): 更新安装步骤说明` |
| **style** | 格式 | 代码格式化，不影响功能 | `style: 统一代码缩进格式` |
| **refactor** | 重构 | 重构代码，不新增功能不修复bug | `refactor(utils): 优化日期处理函数` |
| **test** | 测试 | 添加或修改测试代码 | `test(auth): 添加登录功能单元测试` |
| **chore** | 杂务 | 构建、配置等辅助工作 | `chore: 升级webpack到最新版本` |

### 4.2 类型选择的判断方法


**🤔 如何选择正确的类型**？

**决策树帮助你选择**：
```
你这次提交是要：

添加新功能？ 
    → 用户能感受到新的特性？ → feat
    
修复问题？
    → 解决了程序错误或异常？ → fix
    
修改文档？
    → 只改了README、注释、文档？ → docs
    
调整格式？
    → 只是缩进、空格、分号等格式？ → style
    
重新整理代码？
    → 功能不变，但代码更好了？ → refactor
    
测试相关？
    → 添加或修改测试用例？ → test
    
其他辅助工作？
    → 配置、构建、依赖更新？ → chore
```

### 4.3 实际场景应用示例


**🔍 场景1：开发新功能**
```
# 你要添加一个搜索功能
feat(search): 添加商品搜索功能

# 你要给用户资料添加新字段  
feat(profile): 用户资料支持电话号码填写
```

**🛠️ 场景2：修复问题**
```
# 修复了一个计算错误
fix(cart): 修复购物车总价计算错误

# 修复了界面显示问题
fix(ui): 修复移动端导航菜单无法点击
```

**📚 场景3：文档更新**
```
# 更新了使用说明
docs(guide): 更新用户注册流程说明

# 修复了代码注释
docs(api): 修正用户接口参数说明
```

**🎨 场景4：代码美化**
```
# 统一了代码风格
style: 使用prettier统一代码格式

# 删除了多余的空行
style(components): 清理组件文件多余空行
```

---

## 5. 📍 作用域定义与使用


### 5.1 什么是作用域（Scope）


**简单理解**：作用域就是告诉别人"你这次修改影响了项目的哪个部分"

**生活类比**：
- 家里装修时说"我修了厨房"，厨房就是作用域
- 修车时说"我换了轮胎"，轮胎就是作用域
- 代码修改时说"我改了用户模块"，用户模块就是作用域

### 5.2 常见作用域分类


**🏗️ 按功能模块划分**：
```
auth      - 认证授权相关
user      - 用户管理相关  
product   - 商品管理相关
order     - 订单处理相关
payment   - 支付功能相关
cart      - 购物车相关
admin     - 后台管理相关
```

**📁 按技术层面划分**：
```
ui        - 用户界面相关
api       - 接口相关
db        - 数据库相关
config    - 配置文件相关
utils     - 工具函数相关
```

**📱 按平台划分**：
```
web       - 网页端
mobile    - 移动端
admin     - 管理端
```

### 5.3 作用域使用规则


**✅ 何时使用作用域**：
```
项目较大，模块较多 → 建议使用作用域
团队成员较多       → 建议使用作用域
需要自动化工具处理  → 建议使用作用域
```

**❌ 何时可以省略作用域**：
```
小项目，功能简单   → 可以省略
修改影响全局      → 可以省略
临时实验性修改    → 可以省略
```

**📝 实际使用示例**：
```
✅ 有作用域：
feat(auth): 添加第三方登录支持
fix(payment): 修复支付成功后跳转错误
docs(api): 更新用户接口文档

✅ 无作用域（合理的情况）：
feat: 添加项目初始化脚本
fix: 修复项目构建错误
docs: 更新项目README
```

### 5.4 团队作用域约定示例


**制定团队规范**：
```
前端团队作用域约定：

页面相关：
- home      首页
- profile   个人中心  
- settings  设置页面

组件相关：
- header    页头组件
- footer    页脚组件
- button    按钮组件

功能相关：
- auth      登录注册
- search    搜索功能
- chat      聊天功能
```

---

## 6. ⚠️ 破坏性变更处理


### 6.1 什么是破坏性变更


**通俗解释**：破坏性变更就是"会让现有代码无法正常工作的修改"

**生活类比**：
- 手机系统更新后，旧版APP可能无法使用 → 这就是破坏性变更
- 电器换了新插头，旧插座插不进去 → 这也是破坏性变更

**代码中的破坏性变更**：
```
❌ 删除了API接口：
旧版本：GET /api/user/info
新版本：删除了这个接口 → 破坏性变更

❌ 修改了函数参数：
旧版本：login(username, password)  
新版本：login(userInfo) → 破坏性变更

❌ 修改了数据格式：
旧版本：{name: "张三", age: 20}
新版本：{fullName: "张三", years: 20} → 破坏性变更
```

### 6.2 如何标记破坏性变更


**方法1：在提交类型后加感叹号**
```
feat!: 重新设计用户API接口
fix!: 修复配置文件格式，不兼容旧版本
```

**方法2：在页脚添加BREAKING CHANGE**
```
feat(api): 重新设计用户接口

BREAKING CHANGE: 用户接口返回格式已更改，请更新客户端代码
```

**方法3：两种方式结合使用**
```
feat!(api): 重新设计用户接口

为了提高性能和安全性，重新设计了用户相关API。

BREAKING CHANGE: 
- 用户登录接口从 POST /login 改为 POST /auth/login
- 返回数据格式从 {user: {...}} 改为 {data: {user: {...}}}
- 删除了旧版本的 /user/profile 接口

升级指南请参考：docs/migration-guide.md
```

### 6.3 破坏性变更的最佳实践


**📋 变更前的准备工作**：
- [ ] 提前通知团队成员
- [ ] 编写迁移指南文档
- [ ] 保留旧版本兼容性（如果可能）
- [ ] 充分测试新版本

**📝 提交消息写作要点**：
```
标题：明确标明是破坏性变更（用!或类型说明）
正文：详细说明变更内容和原因
页脚：列出具体的破坏性变更和解决方案
```

**实际案例**：
```
refactor!(config): 统一配置文件格式

为了简化配置管理，将所有配置文件统一为YAML格式。

这次重构优化了以下方面：
- 配置文件更易读写
- 支持配置验证
- 便于自动化处理

BREAKING CHANGE: 
配置文件格式从JSON改为YAML，影响文件：
- config.json → config.yaml  
- database.json → database.yaml

迁移步骤：
1. 使用工具转换：npm run config:migrate
2. 验证配置：npm run config:validate
3. 删除旧的JSON文件

相关文档：docs/config-migration.md
```

---

## 7. 🛠️ 提交模板设置实战


### 7.1 为什么需要提交模板


**解决的问题**：
- ✅ 避免每次都要想提交格式
- ✅ 确保团队提交格式统一
- ✅ 新人快速上手规范
- ✅ 减少提交格式错误

### 7.2 创建提交模板


**步骤1：创建模板文件**
```bash
# 在项目根目录创建模板文件
touch .gitmessage.txt
```

**步骤2：编辑模板内容**
```
# .gitmessage.txt 文件内容

# 提交类型(作用域): 简短描述
# |<----  最多50个字符  ---->|


# 详细说明（可选）
# |<----   每行最多72个字符   ---->|


# 页脚（可选）
# 例如：Closes #123, BREAKING CHANGE: 描述破坏性变更


# 提交类型说明：
# feat:     新功能
# fix:      修复bug  
# docs:     文档修改
# style:    格式调整（不影响功能）
# refactor: 代码重构
# test:     测试相关
# chore:    构建配置等辅助工作
#
# 作用域示例：
# auth, user, product, order, payment, ui, api, config
#
# 示例：
# feat(auth): 添加第三方登录支持
# fix(cart): 修复商品数量计算错误
# docs(readme): 更新安装说明
```

**步骤3：配置Git使用模板**
```bash
# 设置提交模板
git config commit.template .gitmessage.txt

# 验证配置
git config --get commit.template
```

### 7.3 使用提交模板


**提交时的体验**：
```bash
# 使用模板提交
git commit

# Git会打开编辑器，显示模板内容
# 你只需要填写具体内容，删除注释即可
```

**模板使用示例**：
```
# 编辑前（模板内容）
# 提交类型(作用域): 简短描述
# |<----  最多50个字符  ---->|

# 编辑后（实际提交）
feat(auth): 添加微信登录功能

实现了微信扫码登录，包括：
- 调用微信开放平台API
- 用户信息获取和存储  
- 登录状态管理

Closes #234
```

### 7.4 团队模板标准化


**项目级模板配置**：
```bash
# 团队成员克隆项目后执行
git config commit.template .gitmessage.txt

# 或者添加到项目初始化脚本中
echo "git config commit.template .gitmessage.txt" >> setup.sh
```

**不同项目的模板变种**：
```
# 前端项目模板
feat(组件名): 功能描述
fix(页面名): 问题描述  
style(文件名): 样式调整

# 后端项目模板  
feat(模块名): 接口或功能描述
fix(服务名): 修复问题描述
perf(模块名): 性能优化描述
```

---

## 8. 🔄 自动化提交检查


### 8.1 为什么需要自动化检查


**人工检查的问题**：
- ❌ 容易遗忘规范要求
- ❌ 团队成员理解不一致  
- ❌ Code Review时发现问题已经太晚
- ❌ 手工检查效率低下

**自动化检查的好处**：
- ✅ 提交时立即发现问题
- ✅ 强制执行团队规范
- ✅ 减少人工检查成本
- ✅ 保证代码历史质量

### 8.2 使用commitlint进行检查


**安装commitlint**：
```bash
# 安装commitlint和常规配置
npm install --save-dev @commitlint/cli @commitlint/config-conventional

# 创建配置文件
echo "module.exports = {extends: ['@commitlint/config-conventional']}" > commitlint.config.js
```

**配置Git hooks**：
```bash
# 安装husky（Git hooks管理工具）
npm install --save-dev husky

# 初始化husky
npx husky install

# 添加commit-msg hook
npx husky add .husky/commit-msg 'npx --no-install commitlint --edit $1'
```

**测试自动化检查**：
```bash
# 这些提交会被拒绝
git commit -m "随便改了点东西"        # ❌ 格式不规范
git commit -m "feat 添加新功能"       # ❌ 缺少冒号
git commit -m "FEAT: 添加新功能"      # ❌ 类型大写

# 这些提交会被接受  
git commit -m "feat: 添加新功能"      # ✅ 格式正确
git commit -m "fix(auth): 修复登录问题" # ✅ 格式正确
```

### 8.3 自定义检查规则


**基础配置文件**：
```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    // 自定义规则
    'type-enum': [2, 'always', [
      'feat',     // 新功能
      'fix',      // 修复
      'docs',     // 文档
      'style',    // 格式
      'refactor', // 重构
      'test',     // 测试
      'chore'     // 构建
    ]],
    'scope-enum': [2, 'always', [
      'auth',     // 认证
      'user',     // 用户
      'product',  // 商品
      'order',    // 订单
      'payment',  // 支付
      'ui',       // 界面
      'api',      // 接口
      'config'    // 配置
    ]],
    'subject-max-length': [2, 'always', 50],  // 标题最大长度
    'body-max-line-length': [2, 'always', 72] // 正文行最大长度
  }
}
```

**检查效果示例**：
```bash
# 违反类型规则
git commit -m "feature: 添加新功能"
# ❌ type must be one of [feat, fix, docs, style, refactor, test, chore]

# 违反作用域规则  
git commit -m "feat(login): 添加登录功能"
# ❌ scope must be one of [auth, user, product, order, payment, ui, api, config]

# 违反长度规则
git commit -m "feat(auth): 添加了一个非常复杂的用户认证功能包括登录注册找回密码等"
# ❌ subject may not be longer than 50 characters
```

### 8.4 与CI/CD集成


**GitHub Actions配置**：
```yaml
# .github/workflows/commit-check.yml
name: Commit Message Check
on: [push, pull_request]

jobs:
  commitlint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - uses: wagoid/commitlint-github-action@v4
```

**效果**：
- 🔍 Pull Request时自动检查所有提交消息
- ❌ 不符合规范的PR无法合并
- ✅ 确保主分支提交历史质量

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的基本概念


```
🔸 提交规范：统一团队Git提交消息的格式标准
🔸 Conventional Commits：业界流行的提交消息规范
🔸 消息结构：type(scope): subject + body + footer
🔸 提交类型：feat/fix/docs/style/refactor/test/chore
🔸 作用域：说明修改影响的模块或功能范围
🔸 破坏性变更：用!标记或BREAKING CHANGE说明
```

### 9.2 关键理解要点


**🔹 规范的核心价值**
```
可读性：让代码历史一目了然
自动化：支持工具自动处理
协作性：团队成员理解一致
维护性：便于项目长期维护
```

**🔹 类型选择的判断原则**
```
影响用户体验 → feat
修复程序错误 → fix  
只改文档内容 → docs
只调整代码格式 → style
重构但功能不变 → refactor
添加或修改测试 → test
构建配置等辅助 → chore
```

**🔹 作用域使用策略**
```
大项目多模块 → 必须使用作用域
小项目简单功能 → 可以省略作用域
团队协作频繁 → 建议统一作用域规范
个人项目学习 → 可灵活使用
```

### 9.3 实际应用指导


**新手入门建议**：
- 🎯 **从简单开始**：先掌握基本的type: subject格式
- 🎯 **模仿学习**：查看优秀开源项目的提交历史
- 🎯 **工具辅助**：使用模板和自动检查工具
- 🎯 **持续改进**：根据团队需要调整规范

**团队推广策略**：
- 📚 **培训说明**：向团队解释规范的价值和用法
- 🛠️ **工具配置**：统一配置提交模板和检查工具
- 📋 **文档制定**：编写团队专用的提交规范文档
- 🔄 **持续优化**：根据实际使用情况调整规范

### 9.4 常见问题与解决


**❓ "提交消息写得太麻烦"**
```
解决方案：
- 使用提交模板减少重复输入
- 配置IDE插件快速生成格式
- 从简单格式开始，逐步完善
```

**❓ "不知道选择哪个类型"**
```
解决方案：
- 记住核心类型：feat、fix、docs
- 使用决策树帮助判断
- 参考团队已有提交历史
```

**❓ "作用域不知道怎么定义"**
```
解决方案：
- 按功能模块划分最常用
- 小项目可以省略作用域
- 团队讨论统一作用域列表
```

**核心记忆**：
- 提交规范让代码历史更清晰
- type(scope): subject是基本格式
- 自动化工具帮助执行规范
- 团队协作需要统一标准