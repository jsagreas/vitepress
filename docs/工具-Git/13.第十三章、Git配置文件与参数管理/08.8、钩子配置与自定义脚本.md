---
title: 8、钩子配置与自定义脚本
---
## 📚 目录

1. [Git钩子基础概念](#1-Git钩子基础概念)
2. [钩子类型详解](#2-钩子类型详解)
3. [钩子脚本编写实践](#3-钩子脚本编写实践)
4. [钩子安装与配置](#4-钩子安装与配置)
5. [全局钩子管理](#5-全局钩子管理)
6. [团队钩子共享策略](#6-团队钩子共享策略)
7. [现代钩子工具](#7-现代钩子工具)
8. [性能优化与调试](#8-性能优化与调试)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 Git钩子基础概念


### 1.1 什么是Git钩子


**💭 思考一下**：如果你想在每次提交代码前自动检查代码格式，或者在推送代码前自动运行测试，该怎么办？

**🏷️ Git钩子** = `Hook` = **在Git操作的特定时刻自动执行的脚本**

🌰 **举个例子**：
```
就像生活中的"闹钟提醒"：
- 闹钟 = Git钩子脚本
- 设定时间 = Git操作时刻（如commit、push）
- 响铃动作 = 执行脚本内容（如代码检查）
```

### 1.2 钩子的工作原理


**🔍 深入理解**：Git钩子本质上是放在特定位置的可执行脚本文件

```
Git操作流程示意：
用户执行Git命令 → Git检查钩子目录 → 执行对应钩子脚本 → 继续Git操作

具体过程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  git commit │ -> │ pre-commit  │ -> │ 实际提交     │
│   (用户)     │    │  钩子检查    │    │   (Git)     │
└─────────────┘    └─────────────┘    └─────────────┘
```

**⚡ 快速回顾**：钩子就是Git在关键时刻"问一下"脚本："我可以继续吗？"

### 1.3 钩子的分类


Git钩子分为两大类：

| 类型 | **位置** | **作用范围** | **典型用途** |
|------|---------|-------------|-------------|
| **客户端钩子** | 本地`.git/hooks/` | 个人开发环境 | 代码检查、格式化、提交规范 |
| **服务端钩子** | 服务器仓库 | 团队协作 | 权限控制、自动部署、通知 |

---

## 2. 🔧 钩子类型详解


### 2.1 客户端钩子详解


**📋 常用客户端钩子清单**：

#### 🔸 提交相关钩子


**pre-commit**（提交前检查）
```bash
# 执行时机：git commit 之前
# 作用：检查代码质量、格式等
# 返回值：非0时阻止提交
```

💡 **实际应用场景**：
- 代码格式检查（ESLint、Prettier）
- 语法错误检测
- 单元测试运行
- 敏感信息检查

**commit-msg**（提交信息检查）
```bash
# 执行时机：提交信息输入后
# 参数：提交信息文件路径
# 作用：验证提交信息格式
```

**post-commit**（提交后执行）
```bash
# 执行时机：成功提交后
# 作用：发送通知、更新文档等
# 特点：无法阻止提交（已完成）
```

#### 🔸 推送相关钩子


**pre-push**（推送前检查）
```bash
# 执行时机：git push 之前
# 作用：运行完整测试、检查分支规范
# 优势：可以进行耗时较长的检查
```

### 2.2 服务端钩子详解


**📋 服务端钩子清单**：

**pre-receive**（接收前检查）
- 检查推送的所有引用
- 可以拒绝整个推送操作
- 适合权限控制和策略检查

**update**（更新检查）
- 对每个分支单独执行
- 可以选择性拒绝某些分支
- 适合分支级别的控制

**post-receive**（接收后执行）
- 推送成功后执行
- 适合自动部署、发送通知
- 无法阻止推送（已完成）

---

## 3. ✍️ 钩子脚本编写实践


### 3.1 Shell脚本钩子


**🎓 学习目标**：掌握最基础的Shell钩子编写

**🌰 实用示例：pre-commit代码格式检查**

```bash
#!/bin/bash
# .git/hooks/pre-commit

echo "🔍 正在检查代码格式..."

# 检查是否有待提交的JavaScript文件
js_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.js$')

if [ -n "$js_files" ]; then
    echo "📝 发现JavaScript文件，运行ESLint检查..."
    
    # 运行ESLint检查
    npx eslint $js_files
    
    if [ $? -ne 0 ]; then
        echo "❌ ESLint检查失败，请修复错误后再提交"
        exit 1
    fi
    
    echo "✅ ESLint检查通过"
fi

echo "🎉 所有检查通过，继续提交"
exit 0
```

**🔑 关键知识点**：
- `#!/bin/bash` - 指定脚本解释器
- `exit 0` - 成功退出，允许Git操作继续
- `exit 1` - 失败退出，阻止Git操作
- `git diff --cached` - 获取暂存区文件

### 3.2 Python脚本钩子


**💡 优势**：更强的文本处理能力，更好的可读性

**🌰 实用示例：commit-msg提交信息规范检查**

```python
#!/usr/bin/env python3
# .git/hooks/commit-msg

import sys
import re

def check_commit_message(file_path):
    """检查提交信息是否符合规范"""
    
    with open(file_path, 'r', encoding='utf-8') as f:
        message = f.read().strip()
    
    # 提交信息规范：type(scope): description
    pattern = r'^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .{1,50}'
    
    if re.match(pattern, message):
        print("✅ 提交信息格式正确")
        return True
    else:
        print("❌ 提交信息格式错误")
        print("📋 正确格式：type(scope): description")
        print("📋 示例：feat(user): add login functionality")
        return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("❌ 参数错误")
        sys.exit(1)
    
    commit_msg_file = sys.argv[1]
    
    if check_commit_message(commit_msg_file):
        sys.exit(0)  # 成功
    else:
        sys.exit(1)  # 失败
```

### 3.3 Node.js脚本钩子


**💡 优势**：与前端项目集成度高，可以直接使用项目依赖

**🌰 实用示例：pre-push测试运行**

```javascript
#!/usr/bin/env node
// .git/hooks/pre-push

const { execSync } = require('child_process');

console.log('🧪 运行测试套件...');

try {
    // 运行测试
    execSync('npm test', { stdio: 'inherit' });
    console.log('✅ 所有测试通过');
    process.exit(0);
} catch (error) {
    console.log('❌ 测试失败，推送被阻止');
    console.log('💡 请修复失败的测试后再推送');
    process.exit(1);
}
```

---

## 4. ⚙️ 钩子安装与配置


### 4.1 钩子文件位置


**📁 钩子存储位置**：`.git/hooks/` 目录

```
项目结构示例：
my-project/
├── .git/
│   ├── hooks/           ← 钩子脚本存放位置
│   │   ├── pre-commit   ← 提交前钩子
│   │   ├── commit-msg   ← 提交信息钩子
│   │   ├── pre-push     ← 推送前钩子
│   │   └── ...
│   └── ...
├── src/
└── README.md
```

### 4.2 钩子权限设置


**🚨 重要提醒**：钩子脚本必须有可执行权限

```bash
# 给钩子脚本添加可执行权限
chmod +x .git/hooks/pre-commit
chmod +x .git/hooks/commit-msg

# 检查权限设置
ls -la .git/hooks/
```

**🔧 权限设置示例**：
```bash
# 正确的权限显示
-rwxr-xr-x  1 user  staff  1234 Sep 21 15:30 pre-commit
#  ^^^
#  可执行权限
```

### 4.3 钩子脚本创建步骤


**📝 完整安装流程**：

```bash
# 1. 创建钩子脚本
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
echo "Hello from pre-commit hook!"
exit 0
EOF

# 2. 设置可执行权限
chmod +x .git/hooks/pre-commit

# 3. 测试钩子
git add .
git commit -m "test commit"  # 应该看到钩子输出
```

---

## 5. 🌐 全局钩子管理


### 5.1 全局钩子配置


**🤔 为什么需要全局钩子**：
- 多个项目使用相同的钩子
- 避免在每个项目中重复配置
- 统一团队开发规范

**🔧 配置全局钩子路径**：

```bash
# 创建全局钩子目录
mkdir -p ~/.git-hooks

# 配置全局钩子路径
git config --global core.hooksPath ~/.git-hooks

# 验证配置
git config --global --get core.hooksPath
```

### 5.2 全局钩子脚本示例


**🌰 创建全局pre-commit钩子**：

```bash
# 创建全局钩子脚本
cat > ~/.git-hooks/pre-commit << 'EOF'
#!/bin/bash

echo "🔍 运行全局代码检查..."

# 检查是否有调试代码
if git diff --cached | grep -E "(console\.log|debugger|TODO|FIXME)"; then
    echo "⚠️  发现调试代码或待办事项"
    echo "❓ 确定要提交吗？(y/N)"
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "❌ 提交已取消"
        exit 1
    fi
fi

echo "✅ 全局检查通过"
exit 0
EOF

# 设置权限
chmod +x ~/.git-hooks/pre-commit
```

### 5.3 项目级别钩子覆盖


**💡 灵活配置**：项目可以覆盖全局钩子设置

```bash
# 为特定项目设置钩子路径
cd my-special-project
git config core.hooksPath .git/hooks

# 恢复全局设置
git config --unset core.hooksPath
```

---

## 6. 👥 团队钩子共享策略


### 6.1 钩子共享的挑战


**❌ 常见误解**：直接提交`.git/hooks/`目录

**🔍 深入理解**：`.git/`目录不会被Git跟踪，无法通过版本控制共享

### 6.2 钩子模板方案


**🛠️ 解决方案**：在项目中创建钩子模板

```
项目结构：
my-project/
├── scripts/
│   ├── hooks/              ← 钩子模板目录
│   │   ├── pre-commit      ← 钩子模板文件
│   │   ├── commit-msg
│   │   └── install.sh      ← 安装脚本
│   └── ...
├── .git/
└── README.md
```

**🔧 安装脚本示例**：

```bash
#!/bin/bash
# scripts/hooks/install.sh

echo "📦 安装项目钩子..."

# 钩子源目录和目标目录
HOOKS_DIR="scripts/hooks"
GIT_HOOKS_DIR=".git/hooks"

# 复制钩子文件
for hook in pre-commit commit-msg pre-push; do
    if [ -f "$HOOKS_DIR/$hook" ]; then
        echo "📝 安装 $hook 钩子"
        cp "$HOOKS_DIR/$hook" "$GIT_HOOKS_DIR/$hook"
        chmod +x "$GIT_HOOKS_DIR/$hook"
        echo "✅ $hook 安装完成"
    fi
done

echo "🎉 所有钩子安装完成"
```

**📋 使用说明**：

```bash
# 新成员克隆项目后执行
git clone https://github.com/team/project.git
cd project
./scripts/hooks/install.sh
```

### 6.3 自动化钩子安装


**💡 更智能的方案**：在package.json中添加安装脚本

```json
{
  "scripts": {
    "postinstall": "./scripts/hooks/install.sh",
    "setup-hooks": "./scripts/hooks/install.sh"
  }
}
```

**✅ 优势**：
- `npm install` 后自动安装钩子
- 统一的开发环境设置
- 减少人为遗忘的可能

---

## 7. 🚀 现代钩子工具


### 7.1 Husky - 最受欢迎的钩子管理工具


**🏷️ Husky** = **简化Git钩子管理的现代工具**

**📦 安装和配置**：

```bash
# 安装Husky
npm install --save-dev husky

# 初始化Husky
npx husky install

# 设置安装后自动启用
npm pkg set scripts.prepare="husky install"
```

**🔧 添加钩子**：

```bash
# 添加pre-commit钩子
npx husky add .husky/pre-commit "npm run lint"

# 添加commit-msg钩子
npx husky add .husky/commit-msg "npx commitlint --edit $1"
```

**📁 Husky项目结构**：
```
my-project/
├── .husky/
│   ├── _/              ← Husky内部文件
│   ├── pre-commit      ← 提交前钩子
│   └── commit-msg      ← 提交信息钩子
├── package.json
└── ...
```

### 7.2 lint-staged - 只检查暂存文件


**💡 核心概念**：只对Git暂存区的文件运行检查

**🔧 配置示例**：

```json
// package.json
{
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss}": [
      "stylelint --fix"
    ],
    "*.md": [
      "markdownlint --fix"
    ]
  }
}
```

**🚀 结合Husky使用**：

```bash
# .husky/pre-commit
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx lint-staged
```

### 7.3 commitizen - 规范化提交信息


**🎯 目标**：生成标准化的提交信息

**📦 安装配置**：

```bash
# 安装commitizen和适配器
npm install --save-dev commitizen cz-conventional-changelog

# 配置适配器
echo '{ "path": "cz-conventional-changelog" }' > ~/.czrc
```

**🔧 使用方式**：

```bash
# 使用commitizen提交
git add .
npx cz  # 或者 git cz

# 交互式选择提交类型
? Select the type of change that you're committing: (Use arrow keys)
❯ feat:     A new feature
  fix:      A bug fix
  docs:     Documentation only changes
  style:    Changes that do not affect the meaning of the code
  refactor: A code change that neither fixes a bug nor adds a feature
  perf:     A code change that improves performance
  test:     Adding missing tests or correcting existing tests
```

---

## 8. ⚡ 性能优化与调试


### 8.1 钩子性能考虑


**🚨 性能问题**：钩子会影响Git操作速度

**📊 性能对比**：

| 钩子类型 | **建议执行时间** | **适合的检查** | **不适合的检查** |
|---------|----------------|---------------|----------------|
| `pre-commit` | `< 10秒` | 快速语法检查、格式化 | 完整测试套件、大文件处理 |
| `pre-push` | `< 2分钟` | 单元测试、集成测试 | 端到端测试、部署操作 |
| `commit-msg` | `< 1秒` | 文本格式检查 | 网络请求、文件操作 |

**⚡ 优化策略**：

```bash
# 1. 只检查变更的文件
changed_files=$(git diff --cached --name-only)

# 2. 并行执行检查
eslint $js_files &
stylelint $css_files &
wait  # 等待所有后台任务完成

# 3. 缓存检查结果
if [ ! -f .lint-cache ] || [ "$file" -nt ".lint-cache" ]; then
    # 运行检查并缓存结果
    run_lint_check
fi
```

### 8.2 钩子调试技巧


**🔍 调试方法**：

```bash
# 1. 添加详细日志
echo "DEBUG: 当前工作目录: $(pwd)" >&2
echo "DEBUG: 暂存文件: $(git diff --cached --name-only)" >&2

# 2. 保存调试信息到文件
exec 2>>.git/hooks/debug.log
set -x  # 启用命令跟踪

# 3. 手动测试钩子
.git/hooks/pre-commit
echo "Exit code: $?"
```

**🛠️ 常见问题解决**：

```bash
# 问题1: 钩子不执行
# 检查权限
ls -la .git/hooks/pre-commit

# 问题2: 环境变量不可用
# 在钩子中设置PATH
export PATH="/usr/local/bin:$PATH"

# 问题3: 钩子执行失败但无错误信息
# 重定向错误输出
exec 2>&1
```

### 8.3 跳过钩子执行


**⚠️ 紧急情况**：有时需要跳过钩子检查

```bash
# 跳过pre-commit钩子
git commit --no-verify -m "emergency fix"

# 跳过pre-push钩子
git push --no-verify

# 临时禁用钩子
mv .git/hooks/pre-commit .git/hooks/pre-commit.disabled
```

**🎯 最佳实践**：只在紧急情况下跳过钩子

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Git钩子本质：在Git操作特定时刻自动执行的脚本
🔸 钩子分类：客户端钩子（本地）和服务端钩子（远程）
🔸 核心钩子：pre-commit、commit-msg、pre-push、post-receive
🔸 脚本语言：Shell、Python、Node.js都可以编写钩子
🔸 权限要求：钩子脚本必须有可执行权限（chmod +x）
🔸 现代工具：Husky、lint-staged等简化钩子管理
```

### 9.2 实际应用指导


**🎯 新手入门路径**：
1. **理解概念** - 知道钩子是什么，什么时候执行
2. **简单实践** - 编写一个基础的pre-commit钩子
3. **工具使用** - 学会使用Husky管理钩子
4. **团队协作** - 掌握钩子共享和统一配置
5. **性能优化** - 了解性能考虑和调试方法

**✅ 常用钩子搭配**：
```
个人开发：
- pre-commit: 代码格式检查
- commit-msg: 提交信息规范

团队协作：
- pre-commit: ESLint + Prettier
- pre-push: 单元测试
- 配合lint-staged只检查变更文件
```

**🚨 注意事项**：
- 钩子会影响Git操作速度，要控制执行时间
- 钩子脚本要处理好错误情况和用户体验
- 团队钩子需要版本控制和自动安装机制
- 紧急情况可以使用`--no-verify`跳过钩子

### 9.3 进阶学习方向


**📈 深入方向**：
- **CI/CD集成** - 将钩子检查扩展到持续集成
- **自定义工具** - 开发适合团队的钩子管理工具
- **服务端钩子** - 学习Git服务器端的钩子应用
- **工作流优化** - 设计高效的Git工作流和质量检查流程

**💡 实际价值**：
- **代码质量** - 自动化代码检查，减少低级错误
- **团队规范** - 统一代码风格和提交规范
- **开发效率** - 早期发现问题，避免后期修复成本
- **项目维护** - 保持代码库的长期健康和可维护性

**核心记忆**：
- Git钩子是开发流程自动化的利器
- 合理使用钩子能显著提高代码质量
- 现代工具让钩子管理变得简单易用
- 性能和用户体验同样重要