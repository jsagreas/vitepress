---
title: 13、撤销与恢复操作
---
## 📚 目录

1. [撤销与恢复基础概念](#1-撤销与恢复基础概念)
2. [git revert 撤销提交](#2-git-revert-撤销提交)
3. [git checkout 撤销工作区修改](#3-git-checkout-撤销工作区修改)
4. [git restore 新版恢复命令](#4-git-restore-新版恢复命令)
5. [git reflog 引用日志](#5-git-reflog-引用日志)
6. [git fsck 文件系统检查](#6-git-fsck-文件系统检查)
7. [实战应用场景](#7-实战应用场景)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🔄 撤销与恢复基础概念


### 1.1 什么是撤销与恢复


**🔸 通俗理解**
```
想象你在写作业：
- 写错了一个字 → 用橡皮擦掉 (撤销工作区修改)
- 交了作业发现错误 → 跟老师说重新交一份 (撤销提交)
- 不小心撕掉了作业 → 从草稿本找回来 (恢复文件)

Git的撤销恢复就像这样，帮你处理各种"后悔"的情况
```

### 1.2 Git中的三个重要区域


**📋 工作流程图示**
```
工作区(Working Directory)  暂存区(Staging Area)  版本库(Repository)
     ↓                         ↓                    ↓
 你正在编辑的文件              准备提交的文件         已提交的历史版本
     ↓                         ↓                    ↓
 可以随时修改                  临时存储               永久保存
```

**🔸 每个区域的撤销方式**
- **工作区问题**：用 `git checkout` 或 `git restore` 恢复
- **暂存区问题**：用 `git restore --staged` 取消暂存
- **版本库问题**：用 `git revert` 撤销提交

### 1.3 撤销的安全等级


**⚠️ 安全性对比**
```
🟢 最安全：git revert
   - 创建新提交来撤销
   - 不修改历史记录
   - 可以随时再次撤销

🟡 中等安全：git restore / git checkout --
   - 只影响工作区
   - 未提交的修改会丢失
   - 适合日常开发

🔴 高风险：git reset --hard
   - 会完全删除提交
   - 历史记录丢失
   - 团队协作中禁用
```

---

## 2. ↩️ git revert 撤销提交


### 2.1 revert的工作原理


**🔸 核心概念**
```
revert不是删除提交，而是创建一个"反向提交"

比如原来的提交是：
+ 添加了一行代码：console.log("Hello")

revert后会创建新提交：
- 删除这行代码：console.log("Hello")

结果：代码回到修改前的状态，但历史记录完整保留
```

**💡 图解示例**
```
修改前的历史：
A → B → C (当前)

想要撤销提交C，使用 git revert C：
A → B → C → C'(revert C)
           ↑     ↑
         错误提交  撤销提交

最终效果：代码状态 = B，但保留了完整历史
```

### 2.2 基本用法


**🔧 撤销最近一次提交**
```bash
# 撤销最近一次提交
git revert HEAD

# 撤销指定提交（使用提交ID）
git revert 1a2b3c4

# 撤销指定提交（使用相对引用）
git revert HEAD~2  # 撤销倒数第三次提交
```

**📝 实际操作示例**
```bash
# 1. 查看提交历史
git log --oneline
# 输出：
# 3c4d5e6 (HEAD) 添加了错误的功能
# 2b3c4d5 修复了一个bug
# 1a2b3c4 初始提交

# 2. 撤销最近的提交
git revert HEAD
# Git会自动打开编辑器让你写撤销说明

# 3. 查看结果
git log --oneline
# 输出：
# 4d5e6f7 (HEAD) Revert "添加了错误的功能"
# 3c4d5e6 添加了错误的功能
# 2b3c4d5 修复了一个bug
# 1a2b3c4 初始提交
```

### 2.3 高级选项


**🔸 git revert -n（不自动提交）**
```bash
# -n 或 --no-commit：撤销但不立即提交
git revert -n HEAD

# 这样做的好处：
# 1. 可以检查撤销的内容
# 2. 可以修改撤销后再提交
# 3. 可以一次性撤销多个提交

# 查看撤销后的状态
git status

# 满意后手动提交
git commit -m "撤销错误的功能，并做了额外调整"
```

**🔸 撤销多个连续提交**
```bash
# 撤销从HEAD到HEAD~2的所有提交（共3个）
git revert -n HEAD~2..HEAD

# 或者指定具体的提交范围
git revert -n abc123..def456
```

### 2.4 处理冲突


**⚠️ 撤销时遇到冲突**
```bash
# 当撤销时出现冲突
git revert HEAD
# 输出：
# error: could not revert 3c4d5e6... 添加了错误的功能
# hint: after resolving the conflicts, mark the corrected paths
# hint: with 'git add <paths>' or 'git rm <paths>'
# hint: and commit the result with 'git commit'

# 1. 查看冲突文件
git status

# 2. 手动解决冲突（编辑文件）
# 3. 标记冲突已解决
git add 冲突文件.txt

# 4. 完成撤销提交
git commit
```

---

## 3. 🔄 git checkout 撤销工作区修改


### 3.1 checkout的撤销功能


**🔸 基本概念**
```
git checkout -- <file> 的作用：
把工作区的文件恢复到最近一次提交的状态

⚠️ 警告：这个操作会永久丢失未提交的修改！
```

**💡 使用场景**
```
适合以下情况：
✅ 实验性修改不满意，想要放弃
✅ 意外修改了文件，想要恢复
✅ 文件被破坏，需要恢复到正常状态

不适合：
❌ 想要保留修改历史的情况
❌ 修改很重要但暂时不想提交
```

### 3.2 基本用法


**🔧 恢复单个文件**
```bash
# 恢复指定文件到最近提交的状态
git checkout -- 文件名.txt

# 恢复多个文件
git checkout -- 文件1.txt 文件2.txt

# 恢复当前目录所有文件
git checkout -- .
```

**📝 实际示例**
```bash
# 假设你修改了 index.html，但不满意
echo "错误的内容" >> index.html

# 查看文件状态
git status
# 输出：
# modified:   index.html

# 恢复文件
git checkout -- index.html

# 再次查看状态
git status
# 输出：
# nothing to commit, working tree clean
```

### 3.3 从特定提交恢复


**🔸 从指定提交恢复文件**
```bash
# 从特定提交恢复文件
git checkout 提交ID -- 文件名.txt

# 从上一个提交恢复
git checkout HEAD~1 -- 文件名.txt

# 从指定分支恢复
git checkout 分支名 -- 文件名.txt
```

**📝 实用示例**
```bash
# 查看文件的历史版本
git log --oneline -- config.json

# 从3个提交前恢复config.json
git checkout HEAD~3 -- config.json

# 查看恢复后的状态
git status
# 输出：
# Changes to be committed:
#   modified:   config.json
```

---

## 4. 🛠️ git restore 新版恢复命令


### 4.1 restore命令简介


**🔸 为什么有restore命令**
```
Git 2.23版本引入了restore命令，目的是：
1. 让撤销操作更清晰易懂
2. 替代checkout的部分功能
3. 提供更安全的恢复选项

restore vs checkout：
- restore：专门用于恢复文件
- checkout：主要用于切换分支，恢复功能是副业
```

### 4.2 恢复工作区文件


**🔧 基本语法**
```bash
# 恢复工作区文件（等同于 git checkout -- 文件）
git restore 文件名.txt

# 恢复多个文件
git restore 文件1.txt 文件2.txt

# 恢复所有修改
git restore .
```

**📝 对比示例**
```bash
# 旧方式（checkout）
git checkout -- index.html

# 新方式（restore）
git restore index.html

# 效果完全相同，但restore更直观
```

### 4.3 git restore --staged（取消暂存）


**🔸 取消暂存的文件**
```bash
# 将文件从暂存区移回工作区
git restore --staged 文件名.txt

# 等同于旧命令
git reset HEAD 文件名.txt
```

**📝 实际操作流程**
```bash
# 1. 修改文件并添加到暂存区
echo "新内容" > test.txt
git add test.txt

# 2. 查看状态
git status
# 输出：
# Changes to be committed:
#   modified:   test.txt

# 3. 取消暂存（文件回到工作区）
git restore --staged test.txt

# 4. 查看状态
git status
# 输出：
# Changes not staged for commit:
#   modified:   test.txt
```

### 4.4 git restore --source（从指定提交恢复）


**🔸 从特定版本恢复**
```bash
# 从指定提交恢复文件
git restore --source=HEAD~2 文件名.txt

# 从指定提交ID恢复
git restore --source=abc123 文件名.txt

# 同时影响工作区和暂存区
git restore --source=HEAD~1 --staged --worktree 文件名.txt
```

**💡 高级用法**
```bash
# 恢复文件到特定版本，但不影响暂存区
git restore --source=HEAD~3 --worktree 文件名.txt

# 只恢复暂存区，不影响工作区
git restore --source=HEAD~1 --staged 文件名.txt
```

---

## 5. 📜 git reflog 引用日志


### 5.1 reflog是什么


**🔸 通俗理解**
```
reflog就像Git的"操作记录本"：
- 记录你在仓库里做的每一个操作
- 包括提交、分支切换、合并、重置等
- 即使删除了提交，reflog也能帮你找回

就像手机的通话记录，即使联系人删了，记录还在！
```

**💡 reflog的价值**
```
当你遇到以下情况时，reflog是救命稻草：
✅ 误删了重要提交
✅ reset操作过头了
✅ 不小心删除了分支
✅ 合并后发现问题想回滚
```

### 5.2 查看reflog


**🔧 基本查看命令**
```bash
# 查看当前分支的引用日志
git reflog

# 查看指定分支的reflog
git reflog 分支名

# 查看详细信息
git reflog --date=iso
```

**📝 reflog输出示例**
```bash
git reflog
# 输出：
# 3c4d5e6 (HEAD -> main) HEAD@{0}: commit: 添加新功能
# 2b3c4d5 HEAD@{1}: commit: 修复bug
# 1a2b3c4 HEAD@{2}: commit: 初始提交
# 0a1b2c3 HEAD@{3}: reset: moving to HEAD~1
# 4d5e6f7 HEAD@{4}: commit: 被reset掉的提交
```

**🔸 理解reflog条目**
```
3c4d5e6 (HEAD -> main) HEAD@{0}: commit: 添加新功能
   ↑            ↑        ↑        ↑         ↑
提交ID      当前位置   引用编号   操作类型   操作描述
```

### 5.3 使用reflog恢复


**🛠️ 恢复误删的提交**
```bash
# 1. 假设你误用了 git reset --hard
git reset --hard HEAD~3  # 误操作，删除了3个提交

# 2. 查看reflog找到丢失的提交
git reflog
# 找到：4d5e6f7 HEAD@{4}: commit: 重要的功能

# 3. 恢复到那个提交
git reset --hard 4d5e6f7

# 或者创建新分支保存
git branch 恢复分支 4d5e6f7
```

**📋 恢复删除的分支**
```bash
# 1. 误删分支
git branch -D 重要分支  # 误操作

# 2. 查看reflog（使用 -g 参数查看所有引用）
git reflog show --all

# 3. 找到分支的最后一次提交，重新创建分支
git branch 重要分支 找到的提交ID
```

---

## 6. 🔍 git fsck 文件系统检查


### 6.1 fsck的作用


**🔸 什么是fsck**
```
fsck = File System Check（文件系统检查）

作用：
- 检查Git仓库的完整性
- 找出悬空对象（dangling objects）
- 发现损坏的引用
- 帮助恢复丢失的数据

就像给电脑做体检，确保一切正常！
```

### 6.2 基本检查


**🔧 运行检查**
```bash
# 基本检查
git fsck

# 详细检查
git fsck --full

# 显示所有对象（包括悬空对象）
git fsck --unreachable
```

**📝 fsck输出示例**
```bash
git fsck --unreachable
# 输出：
# Checking object directories: 100% done.
# dangling commit 4d5e6f7a8b9c0d1e2f3g4h5i6j7k8l9m0n1o2p3q
# dangling blob 1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p7q8r9s0t
```

### 6.3 恢复悬空对象


**🛠️ 处理悬空提交**
```bash
# 1. 找到悬空提交
git fsck --unreachable | grep commit

# 2. 查看悬空提交内容
git show 悬空提交ID

# 3. 如果是需要的内容，创建分支保存
git branch 恢复的分支 悬空提交ID
```

**💡 实际恢复案例**
```bash
# 场景：删除分支后想恢复某些提交
# 1. 检查悬空对象
git fsck --unreachable | grep commit
# 输出：dangling commit abc123def456

# 2. 查看这个提交
git show abc123def456
# 发现是需要的功能

# 3. 创建分支保存
git branch 找回的功能 abc123def456

# 4. 切换到新分支
git checkout 找回的功能
```

---

## 7. 🎯 实战应用场景


### 7.1 常见撤销场景对照表


| **场景** | **问题描述** | **解决方案** | **命令** |
|---------|-------------|-------------|----------|
| **工作区误修改** | `文件改错了，还没提交` | 恢复到最近提交状态 | `git restore 文件名` |
| **暂存区想撤销** | `add了不想要的文件` | 取消暂存 | `git restore --staged 文件名` |
| **提交了错误代码** | `已经commit但发现问题` | 创建撤销提交 | `git revert HEAD` |
| **删除了重要提交** | `reset过头了` | 从reflog恢复 | `git reflog` + `git reset` |
| **分支删除了** | `误删了开发分支` | 从reflog找回 | `git reflog` + `git branch` |

### 7.2 撤销决策流程图


```
发现问题需要撤销
        ↓
   修改提交了吗？
    ↙        ↘
  没有        已提交
   ↓             ↓
工作区修改？    在团队分支上？
   ↓             ↙        ↘
git restore    是         否
            ↓             ↓
        git revert    可考虑reset
                     (但要谨慎)
```

### 7.3 团队协作中的撤销策略


**🤝 团队规范**
```
✅ 推荐做法：
- 对已推送的提交使用 git revert
- 对本地修改使用 git restore
- 重要操作前先备份分支

❌ 避免做法：
- 对已推送的提交使用 git reset --hard
- 强制推送覆盖远程历史
- 不沟通就修改共享分支
```

### 7.4 撤销操作的最佳实践


**📋 操作前检查清单**
```
在执行撤销操作前，先问自己：
□ 这个修改影响其他人吗？
□ 有没有备份重要内容？
□ 选择的撤销方式合适吗？
□ 是否需要和团队沟通？
```

**🛡️ 安全措施**
```bash
# 1. 重要操作前创建备份分支
git branch 备份分支 HEAD

# 2. 使用 --dry-run 预览操作（如果支持）
git clean --dry-run

# 3. 分步操作，避免一次性大范围修改
git restore 单个文件  # 而不是 git restore .
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 撤销三剑客：revert、restore、reflog
🔸 安全等级：revert最安全，restore中等，reset最危险
🔸 作用范围：工作区 → 暂存区 → 版本库
🔸 团队协作：已推送的提交只用revert撤销
```

### 8.2 命令速查手册


**🔧 工作区撤销**
```bash
git restore 文件名           # 恢复工作区文件
git checkout -- 文件名      # 旧版本恢复方式
git restore .               # 恢复所有工作区修改
```

**🔧 暂存区撤销**
```bash
git restore --staged 文件名  # 取消暂存
git reset HEAD 文件名       # 旧版本取消暂存方式
```

**🔧 提交撤销**
```bash
git revert HEAD             # 撤销最近提交
git revert -n HEAD          # 撤销但不自动提交
git revert HEAD~2..HEAD     # 撤销多个提交
```

**🔧 数据恢复**
```bash
git reflog                  # 查看操作历史
git fsck --unreachable      # 检查悬空对象
git branch 新分支 提交ID     # 恢复删除的内容
```

### 8.3 关键理解要点


**🔹 revert vs reset的本质区别**
```
revert：
- 创建新提交来"反做"之前的修改
- 历史记录完整保留
- 团队协作安全

reset：
- 直接删除提交历史
- 可能丢失数据
- 只适合本地使用
```

**🔹 restore vs checkout的优势**
```
restore（推荐）：
- 语义更清晰
- 功能更专一
- 选项更丰富

checkout（传统）：
- 功能混杂
- 容易误操作
- 正在被逐步替代
```

### 8.4 实际应用价值


**💼 日常开发场景**
- **代码实验**：用restore随时回滚尝试性修改
- **功能调试**：用revert快速撤销有问题的功能
- **误操作恢复**：用reflog找回丢失的重要提交
- **代码清理**：用restore清理不需要的本地修改

**🎯 团队协作技巧**
- **安全撤销**：团队分支只用revert，保护共享历史
- **实验分支**：在独立分支上可以放心使用各种撤销方式
- **沟通原则**：重要撤销操作要提前和团队沟通
- **备份习惯**：重要操作前创建备份分支

**核心记忆口诀**：
- 工作区问题用restore，暂存区问题加staged
- 提交撤销用revert，团队协作最安全
- 数据丢失找reflog，悬空对象用fsck
- 操作之前先备份，安全第一是王道