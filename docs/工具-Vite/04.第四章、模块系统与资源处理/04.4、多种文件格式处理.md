---
title: 4、多种文件格式处理
---
## 📚 目录

1. [JSON文件处理](#1-JSON文件处理)
2. [文本文件处理](#2-文本文件处理)
3. [CommonJS兼容处理](#3-CommonJS兼容处理)
4. [核心要点总结](#4-核心要点总结)

---

## 1. 📄 JSON文件处理


### 1.1 什么是JSON文件处理


**🔸 简单理解**
```
JSON处理就是：在项目中直接使用JSON文件里的数据
就像读取一个配置文件或数据文件一样简单
```

**💡 为什么需要JSON文件处理？**
- 🎯 **配置数据**：项目配置、环境变量等
- 📊 **静态数据**：用户列表、商品信息等
- 🌍 **国际化**：多语言翻译文件
- 📋 **API数据**：模拟数据、测试数据

### 1.2 JSON文件导入方式


**🔸 基础导入**
```javascript
// 数据文件：data.json
{
  "users": [
    {"id": 1, "name": "张三", "age": 25},
    {"id": 2, "name": "李四", "age": 30}
  ],
  "total": 2
}

// 导入使用
import userData from './data.json'

console.log(userData.users)    // 获取用户列表
console.log(userData.total)    // 获取总数
```

**🔸 按需导入**
```javascript
// 只要特定数据
import { users } from './data.json'    // ❌ 这样不行！JSON不支持按需导入

// 正确做法：先导入再取值
import userData from './data.json'
const { users, total } = userData      // ✅ 这样可以
```

### 1.3 常见JSON文件使用场景


**📋 配置文件示例**
```javascript
// config.json - 项目配置
{
  "apiUrl": "https://api.example.com",
  "timeout": 5000,
  "retryTimes": 3,
  "features": {
    "darkMode": true,
    "notifications": false
  }
}

// 在组件中使用
import config from './config.json'

// 发送请求时使用配置
fetch(config.apiUrl + '/users', {
  timeout: config.timeout
})
```

**🌍 多语言文件示例**
```javascript
// zh-CN.json - 中文翻译
{
  "welcome": "欢迎使用",
  "login": "登录",
  "register": "注册"
}

// en-US.json - 英文翻译  
{
  "welcome": "Welcome",
  "login": "Login", 
  "register": "Register"
}

// 使用翻译
import zhCN from './locales/zh-CN.json'
import enUS from './locales/en-US.json'

const messages = {
  'zh-CN': zhCN,
  'en-US': enUS
}
```

### 1.4 JSON处理注意事项


**⚠️ 重要提醒**
```
JSON文件导入后是什么？
- 不是字符串！是已经解析好的JavaScript对象
- 可以直接用 obj.property 访问属性
- 不需要 JSON.parse()，Vite自动处理了
```

**🔧 实际使用技巧**
```javascript
// ✅ 推荐：创建数据访问函数
import userData from './data.json'

export function getUserById(id) {
  return userData.users.find(user => user.id === id)
}

export function getAllUsers() {
  return userData.users
}

// ✅ 推荐：类型检查（TypeScript）
interface User {
  id: number
  name: string
  age: number
}

const users: User[] = userData.users
```

---

## 2. 📝 文本文件处理


### 2.1 什么是文本文件处理


**🔸 简单理解**
```
文本文件处理就是：把文本文件的内容当作字符串导入
比如读取说明文档、模板文件、SQL语句等
```

**💡 常见使用场景**
- 📖 **文档内容**：README、帮助文档
- 🎨 **模板文件**：HTML模板、邮件模板
- 🗃️ **SQL语句**：复杂查询语句
- 📜 **配置脚本**：Shell脚本、配置文件

### 2.2 文本文件导入方式


**🔸 使用查询参数**
```javascript
// template.html
<div class="welcome">
  <h1>欢迎使用我们的系统</h1>
  <p>请先登录您的账户</p>
</div>

// 导入为文本字符串
import htmlTemplate from './template.html?raw'

console.log(typeof htmlTemplate)  // "string"
console.log(htmlTemplate)         // 输出HTML源码
```

**🔸 处理不同文本格式**
```javascript
// 导入CSS文件内容
import cssContent from './styles.css?raw'

// 导入SQL查询语句
import querySQL from './query.sql?raw'

// 导入Markdown文档
import readme from './README.md?raw'

// 使用文本内容
function loadTemplate() {
  document.body.innerHTML = htmlTemplate
}
```

### 2.3 文本内容处理技巧


**🔧 字符串处理方法**
```javascript
import template from './email-template.html?raw'

// 替换模板变量
function generateEmail(userName, content) {
  return template
    .replace('{{userName}}', userName)
    .replace('{{content}}', content)
}

// 使用
const emailHTML = generateEmail('张三', '您的订单已发货')
```

**📊 文本数据解析**
```javascript
// data.csv 文件内容
// name,age,city
// 张三,25,北京
// 李四,30,上海

import csvContent from './data.csv?raw'

function parseCSV(csvText) {
  const lines = csvText.trim().split('\n')
  const headers = lines[0].split(',')
  
  return lines.slice(1).map(line => {
    const values = line.split(',')
    const obj = {}
    headers.forEach((header, index) => {
      obj[header] = values[index]
    })
    return obj
  })
}

const userData = parseCSV(csvContent)
// 结果：[{name: '张三', age: '25', city: '北京'}, ...]
```

### 2.4 文本文件处理最佳实践


**💯 推荐做法**
```javascript
// 创建专门的文本处理工具
class TextProcessor {
  static loadTemplate(templateText, variables = {}) {
    let result = templateText
    Object.entries(variables).forEach(([key, value]) => {
      result = result.replace(new RegExp(`{{${key}}}`, 'g'), value)
    })
    return result
  }
  
  static splitLines(text) {
    return text.split('\n').filter(line => line.trim())
  }
}

// 使用
import template from './template.html?raw'
const html = TextProcessor.loadTemplate(template, {
  title: '欢迎页面',
  message: '登录成功'
})
```

---

## 3. 🔄 CommonJS兼容处理


### 3.1 什么是CommonJS兼容


**🔸 问题背景**
```
现状：
- Vite使用ESM（ES模块）: import/export
- Node.js传统使用CommonJS: require/module.exports
- 很多老的npm包还是CommonJS格式

解决：Vite自动把CommonJS转换成ESM，让我们能正常使用
```

**💡 为什么需要兼容？**
- 📦 **老包支持**：很多npm包还是CommonJS
- 🔧 **工具兼容**：构建工具、插件等
- 🌉 **平滑迁移**：从老项目迁移到Vite

### 3.2 CommonJS支持机制


**🔸 自动转换过程**
```
原理：
1. Vite扫描node_modules中的包
2. 发现CommonJS格式的包
3. 自动转换成ESM格式
4. 缓存转换结果，提高性能
```

**📋 扫描流程图**
```
项目启动
    ↓
扫描依赖包
    ↓
检测模块格式
    ↓
┌─────────────┬─────────────┐
│  ESM格式    │ CommonJS格式 │
│  直接使用   │  需要转换   │
└─────────────┴─────────────┘
                    ↓
                预构建转换
                    ↓
                缓存结果
                    ↓
                正常使用
```

### 3.3 实际使用示例


**🔸 使用CommonJS包**
```javascript
// 这些包可能是CommonJS格式，但可以正常使用
import lodash from 'lodash'              // 工具库
import moment from 'moment'              // 时间处理
import axios from 'axios'                // HTTP请求

// Vite会自动处理，你不需要关心它们的模块格式
const users = lodash.uniqBy(userList, 'id')
const now = moment().format('YYYY-MM-DD')
```

**🔸 混合使用示例**
```javascript
// ESM格式的包
import { ref, reactive } from 'vue'

// CommonJS格式的包（自动转换）
import _ from 'lodash'

// 你的ESM代码
export default {
  setup() {
    const data = reactive({
      list: []
    })
    
    // 使用CommonJS包的功能
    const uniqueList = _.uniqBy(data.list, 'id')
    
    return { data, uniqueList }
  }
}
```

### 3.4 CommonJS使用注意事项


**⚠️ 常见问题**
```javascript
// ❌ 错误：不能在ESM中使用require
const fs = require('fs')  // 报错！

// ✅ 正确：使用import
import fs from 'fs'

// ❌ 错误：不能直接使用module.exports
module.exports = { name: 'test' }  // 报错！

// ✅ 正确：使用export
export default { name: 'test' }
```

**🔧 解决兼容性问题**
```javascript
// 如果某个包导入有问题，可以这样处理：

// 方法1：使用动态导入
const somePackage = await import('problematic-package')

// 方法2：在vite.config.js中配置
export default {
  optimizeDeps: {
    include: ['problematic-package']  // 强制预构建
  }
}

// 方法3：使用别名
export default {
  resolve: {
    alias: {
      '@utils': path.resolve(__dirname, 'src/utils')
    }
  }
}
```

### 3.5 性能优化技巧


**⚡ 依赖预构建优化**
```javascript
// vite.config.js
export default {
  optimizeDeps: {
    // 显式包含需要预构建的包
    include: [
      'lodash',
      'moment', 
      'axios'
    ],
    // 排除不需要预构建的包
    exclude: [
      'some-esm-package'
    ]
  }
}
```

**📊 监控转换过程**
```bash
# 开发时可以看到预构建信息
vite
# 输出类似：
# Pre-bundling dependencies:
#   lodash
#   moment
# Dependencies pre-bundled in 1.2s
```

---

## 4. 📋 核心要点总结


### 4.1 必须掌握的基本概念


```
🔸 JSON处理：直接导入JSON文件，自动解析为对象
🔸 文本处理：使用?raw参数导入文件内容为字符串
🔸 CommonJS兼容：Vite自动转换老格式包，无需手动处理
🔸 预构建机制：自动扫描和转换依赖，提高开发性能
```

### 4.2 关键理解要点


**🔹 文件处理的本质**
```
JSON导入 → 解析后的JavaScript对象（不是字符串）
文本导入 → 原始字符串内容（需要手动处理）
CommonJS → 自动转换成ESM（透明处理）
```

**🔹 使用场景选择**
```
JSON文件：
✅ 配置数据、静态数据
✅ 多语言翻译文件
✅ API模拟数据

文本文件：
✅ HTML模板、邮件模板
✅ SQL语句、脚本文件
✅ 文档内容、说明文件

CommonJS兼容：
✅ 使用老的npm包
✅ 工具库、插件
✅ 项目迁移过程
```

**🔹 性能优化要点**
```
预构建缓存：
- 依赖包只转换一次
- 缓存在node_modules/.vite中
- 依赖变化时自动重新构建

开发体验：
- 热更新支持所有文件格式
- 错误信息清晰明确
- 自动处理格式转换
```

### 4.3 实际应用建议


**💯 最佳实践**
```
JSON文件使用：
- 创建类型定义（TypeScript）
- 使用访问函数封装
- 按功能模块拆分文件

文本文件处理：
- 使用模板引擎思维
- 创建统一的处理工具
- 考虑国际化需求

CommonJS兼容：
- 优先使用ESM格式的包
- 配置预构建优化
- 监控构建性能
```

**🔧 实用技巧**
- 📁 **文件组织**：按类型和功能分类存放
- 🎯 **类型安全**：使用TypeScript定义数据结构
- ⚡ **性能监控**：关注预构建时间和缓存效果
- 🔍 **调试方法**：利用浏览器开发工具查看模块加载

**核心记忆**：
- JSON导入得对象，文本导入加?raw
- CommonJS自动转，开发体验不用愁
- 预构建机制强，性能优化有保障
- 文件处理要分类，按需使用效果好