---
title: 8、进阶话题与扩展
---
## 📚 目录

1. [微前端架构](#1-微前端架构)
2. [SSR与同构](#2-SSR与同构)
3. [PWA应用](#3-PWA应用)
4. [核心要点总结](#4-核心要点总结)

> 📖 **预计阅读时间：25分钟**  
> 🎯 **难度等级：⭐⭐⭐⭐☆**  
> 🔖 **标签：** `#进阶` `#架构` `#性能优化`

---

## 1. 🏗️ 微前端架构


### 1.1 什么是微前端？


**💡 通俗理解**
```
想象一个大型购物网站：
传统方式：整个网站是一个巨大的项目
微前端：把网站拆分成多个小项目

首页模块 → 独立的Vue项目
商品详情 → 独立的React项目  
用户中心 → 独立的Angular项目
购物车 → 独立的Vue项目

每个小项目可以：
✅ 独立开发、独立部署
✅ 使用不同技术栈
✅ 不同团队负责
✅ 互不影响
```

**🔸 核心概念**
```
微前端 = 把一个大前端应用拆分成多个小应用

好处：
• 技术栈自由：每个模块用不同框架
• 团队独立：不同团队负责不同模块
• 部署灵活：单个模块更新不影响其他
• 维护简单：代码量小，容易理解

缺点：
• 复杂度增加：需要额外的协调机制
• 性能开销：多个应用同时运行
• 学习成本：需要了解微前端框架
```

### 1.2 主流微前端方案


#### 🎯 single-spa - 微前端先驱


**核心思想**：一个主应用管理多个子应用的生命周期

```javascript
// 主应用配置
import { registerApplication, start } from 'single-spa'

// 注册子应用
registerApplication({
  name: 'header-app',        // 应用名称
  app: () => import('./header/main.js'),  // 应用入口
  activeWhen: ['/'],         // 激活条件
})

registerApplication({
  name: 'product-app',
  app: () => import('./product/main.js'),
  activeWhen: ['/product'],
})

// 启动微前端
start()
```

**🔧 Vite中集成single-spa**
```javascript
// vite.config.js
export default {
  build: {
    lib: {
      entry: 'src/main.js',
      name: 'myMicroApp',
      formats: ['system']  // 使用SystemJS格式
    }
  }
}
```

#### 🚀 qiankun - 阿里开源方案


**特点**：基于single-spa，提供了更完整的解决方案

```javascript
// 主应用
import { registerMicroApps, start } from 'qiankun'

registerMicroApps([
  {
    name: 'vue-app',           // 应用名称
    entry: '//localhost:3001', // 应用地址
    container: '#vue-container', // 挂载容器
    activeRule: '/vue',        // 激活路由
  },
  {
    name: 'react-app',
    entry: '//localhost:3002',
    container: '#react-container',
    activeRule: '/react',
  },
])

start()
```

**💡 为什么选择qiankun？**
```
single-spa：需要自己解决很多问题
qiankun：帮你解决了常见问题

qiankun额外提供：
✅ 自动样式隔离
✅ JS沙箱机制
✅ 资源预加载
✅ 通信机制
✅ 错误处理
```

#### ⚡ Module Federation - Webpack5新特性


**核心思想**：应用之间直接共享模块，像使用本地模块一样

```javascript
// webpack.config.js (Vite也支持)
new ModuleFederationPlugin({
  name: 'host',              // 当前应用名
  remotes: {
    mf_remote: 'remote@http://localhost:3001/remoteEntry.js'
  }
})

// 使用远程模块
const RemoteComponent = React.lazy(() => import('mf_remote/Button'))
```

**🔧 在Vite中使用**
```javascript
// 使用 @originjs/vite-plugin-federation
import federation from '@originjs/vite-plugin-federation'

export default {
  plugins: [
    federation({
      name: 'host-app',
      remotes: {
        remote_app: 'http://localhost:3001/assets/remoteEntry.js'
      }
    })
  ]
}
```

### 1.3 子应用通信机制


**🔄 常见通信方式**

```javascript
// 1. 全局事件总线
// 主应用
window.eventBus = new EventTarget()

// 子应用A发送消息
window.eventBus.dispatchEvent(new CustomEvent('userLogin', {
  detail: { userId: 123, name: '张三' }
}))

// 子应用B接收消息
window.eventBus.addEventListener('userLogin', (event) => {
  console.log('用户登录了:', event.detail)
})

// 2. 全局状态管理
// 主应用提供全局store
window.globalStore = {
  state: { user: null },
  setState(newState) {
    this.state = { ...this.state, ...newState }
    this.notify()
  },
  subscribe(callback) {
    this.listeners.push(callback)
  }
}
```

### 1.4 样式隔离和JS沙箱


**🎨 样式隔离解决方案**

```css
/* 问题：子应用样式互相污染 */
.header { color: red; }  /* 应用A的样式 */
.header { color: blue; } /* 应用B的样式，会覆盖A */

/* 解决方案1：CSS Modules */
.header_abc123 { color: red; }  /* 自动生成唯一类名 */

/* 解决方案2：命名空间 */
.app-a .header { color: red; }
.app-b .header { color: blue; }

/* 解决方案3：Shadow DOM */
// 创建隔离的DOM环境
const shadow = container.attachShadow({ mode: 'closed' })
```

**🔒 JS沙箱机制**

```javascript
// 问题：全局变量污染
window.userName = '张三'  // 应用A设置
window.userName = '李四'  // 应用B覆盖了A的设置

// qiankun的沙箱解决方案
class SandBox {
  constructor() {
    this.sandboxWindow = {}  // 虚拟window对象
  }
  
  active() {
    // 激活时恢复子应用的全局状态
    Object.keys(this.sandboxWindow).forEach(key => {
      window[key] = this.sandboxWindow[key]
    })
  }
  
  inactive() {
    // 失活时保存子应用的全局状态
    Object.keys(this.sandboxWindow).forEach(key => {
      this.sandboxWindow[key] = window[key]
      delete window[key]
    })
  }
}
```

---

## 2. 🖥️ SSR与同构


### 2.1 什么是SSR？


**💡 通俗理解**
```
普通网页（CSR - 客户端渲染）：
1. 浏览器下载空白HTML
2. 下载JavaScript文件
3. JS执行后才显示内容
4. 用户看到页面（慢）

SSR（服务端渲染）：
1. 服务器直接生成完整HTML
2. 浏览器立即显示内容
3. 后续下载JS增强交互
4. 用户立即看到页面（快）

就像：
CSR = 在家组装家具（慢）
SSR = 买现成家具（快）
```

**🔸 SSR的优势**
```
✅ 首屏加载快：服务器直接返回完整页面
✅ SEO友好：搜索引擎能抓取到完整内容
✅ 社交分享：能正确显示页面标题和描述

❌ 服务器压力大：每次请求都要渲染
❌ 开发复杂：需要考虑服务端和客户端
❌ 交互延迟：需要等JS下载完才能交互
```

### 2.2 Vite SSR实现


**🚀 基础SSR设置**

```javascript
// vite.config.js
export default {
  build: {
    ssr: true,           // 启用SSR构建
    rollupOptions: {
      input: {
        client: 'src/entry-client.js',  // 客户端入口
        server: 'src/entry-server.js'   // 服务端入口
      }
    }
  }
}

// src/entry-server.js - 服务端入口
import { createApp } from './main.js'

export function render() {
  const app = createApp()
  return app  // 返回Vue应用实例
}

// src/entry-client.js - 客户端入口  
import { createApp } from './main.js'

const app = createApp()
app.mount('#app')  // 客户端激活
```

**🖥️ 服务器端代码**

```javascript
// server.js
import express from 'express'
import { render } from './dist/entry-server.js'

const app = express()

app.get('*', async (req, res) => {
  try {
    // 1. 渲染应用
    const appHtml = await render(req.url)
    
    // 2. 生成完整HTML
    const html = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>我的SSR应用</title>
        </head>
        <body>
          <div id="app">${appHtml}</div>
          <script src="/dist/entry-client.js"></script>
        </body>
      </html>
    `
    
    res.send(html)
  } catch (error) {
    res.status(500).send('服务器错误')
  }
})

app.listen(3000)
```

### 2.3 数据预取和状态同步


**📊 数据预取模式**

```javascript
// 路由组件中定义数据预取
export default {
  // 服务端调用
  async serverPrefetch() {
    const data = await fetchUserData()
    this.$store.commit('setUser', data)
  },
  
  // 客户端调用
  async mounted() {
    if (!this.$store.state.user) {
      const data = await fetchUserData()
      this.$store.commit('setUser', data)
    }
  }
}

// 服务端渲染时
const store = createStore()
await store.dispatch('fetchInitialData')  // 预取数据

// 将状态序列化到HTML中
const stateScript = `
  <script>
    window.__INITIAL_STATE__ = ${JSON.stringify(store.state)}
  </script>
`

// 客户端恢复状态
const initialState = window.__INITIAL_STATE__
const store = createStore(initialState)
```

### 2.4 SSG - 静态站点生成


**💡 SSG是什么？**
```
SSG = 构建时预渲染所有页面

适用场景：
✅ 博客网站：内容不常变化
✅ 文档网站：页面结构固定
✅ 营销页面：内容相对静态

优势：
• 性能最佳：纯静态文件
• 部署简单：可用CDN
• 成本最低：无服务器压力
```

```javascript
// 使用Vite插件实现SSG
import { defineConfig } from 'vite'
import { ssgBuild } from 'vite-plugin-ssg'

export default defineConfig({
  plugins: [
    ssgBuild({
      routes: [        // 要预渲染的路由
        '/',
        '/about',
        '/blog/post-1',
        '/blog/post-2'
      ]
    })
  ]
})
```

---

## 3. 📱 PWA应用


### 3.1 什么是PWA？


**💡 通俗理解**
```
PWA = 让网页像手机App一样好用

普通网页的问题：
❌ 必须联网才能用
❌ 不能安装到桌面
❌ 不能发送推送通知
❌ 体验不如原生App

PWA的改进：
✅ 离线也能正常使用
✅ 可以安装到桌面
✅ 支持推送通知
✅ 接近原生App体验

实际体验：
• 打开网页，点击"添加到主屏幕"
• 在桌面上像App一样启动
• 没网络时也能浏览缓存的内容
```

### 3.2 Service Worker实现


**⚙️ Service Worker是什么？**
```
Service Worker = 网页的后台服务

作用：
• 拦截网络请求
• 缓存文件和数据
• 后台同步
• 推送通知

工作原理：
网页 → Service Worker → 网络
      ↓
    本地缓存
```

**🔧 基础Service Worker**

```javascript
// public/sw.js
const CACHE_NAME = 'my-app-v1'
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js',
  '/images/logo.png'
]

// 安装Service Worker
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('缓存已打开')
        return cache.addAll(urlsToCache)  // 缓存指定文件
      })
  )
})

// 拦截网络请求
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)         // 先查缓存
      .then((response) => {
        if (response) {
          return response               // 有缓存就返回缓存
        }
        return fetch(event.request)     // 没缓存就请求网络
      })
  )
})

// 在主线程中注册Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(() => console.log('SW注册成功'))
    .catch(() => console.log('SW注册失败'))
}
```

### 3.3 离线缓存策略


**📦 常见缓存策略**

```javascript
// 1. Cache First - 缓存优先
// 适用：不常变化的资源（图片、CSS、JS）
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  )
})

// 2. Network First - 网络优先  
// 适用：经常变化的数据（API接口）
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .catch(() => caches.match(event.request))  // 网络失败才用缓存
  )
})

// 3. Stale While Revalidate - 缓存同时更新
// 适用：希望快速响应但数据要保持更新
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open(CACHE_NAME).then(cache => {
      return cache.match(event.request).then(cachedResponse => {
        const fetchPromise = fetch(event.request).then(networkResponse => {
          cache.put(event.request, networkResponse.clone())  // 更新缓存
          return networkResponse
        })
        return cachedResponse || fetchPromise  // 优先返回缓存
      })
    })
  )
})
```

### 3.4 应用清单配置


**📋 manifest.json配置**

```json
{
  "name": "我的PWA应用",
  "short_name": "MyApp",
  "description": "这是一个PWA示例应用",
  "start_url": "/",
  "display": "standalone",          
  "background_color": "#ffffff",    
  "theme_color": "#000000",         
  "orientation": "portrait",        
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512.png", 
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

**💡 配置说明**
```
display模式：
• "browser"：在浏览器中打开
• "standalone"：像App一样全屏显示
• "minimal-ui"：显示最少的浏览器UI
• "fullscreen"：完全全屏

图标要求：
• 至少192x192和512x512两个尺寸
• PNG格式，支持透明背景
• 用于添加到主屏幕时显示
```

### 3.5 推送通知功能


**🔔 Web推送通知**

```javascript
// 1. 请求通知权限
async function requestNotificationPermission() {
  const permission = await Notification.requestPermission()
  if (permission === 'granted') {
    console.log('通知权限已获取')
  }
}

// 2. 在Service Worker中处理推送
self.addEventListener('push', (event) => {
  const data = event.data.json()
  
  const options = {
    body: data.body,
    icon: '/icons/icon-192.png',
    badge: '/icons/badge.png',
    actions: [
      { action: 'view', title: '查看' },
      { action: 'close', title: '关闭' }
    ]
  }
  
  event.waitUntil(
    self.registration.showNotification(data.title, options)
  )
})

// 3. 处理通知点击
self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  
  if (event.action === 'view') {
    clients.openWindow('/notification-detail')
  }
})
```

### 3.6 Vite PWA插件


**🔧 使用vite-plugin-pwa**

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    VitePWA({
      registerType: 'autoUpdate',        // 自动更新
      includeAssets: ['favicon.ico', 'apple-touch-icon.png'],
      manifest: {
        name: '我的Vite PWA应用',
        short_name: 'VitePWA',
        description: '使用Vite构建的PWA应用',
        theme_color: '#ffffff',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          }
        ]
      },
      workbox: {                        // 缓存配置
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\.example\.com/,
            handler: 'NetworkFirst',    // API使用网络优先
            options: {
              cacheName: 'api-cache'
            }
          }
        ]
      }
    })
  ]
})
```

---

## 4. 📋 核心要点总结


### 4.1 必须掌握的核心概念


```
🔸 微前端：大应用拆分成多个小应用，独立开发部署
🔸 SSR：服务器端渲染，提升首屏性能和SEO效果  
🔸 PWA：让网页具备原生App的体验和功能
🔸 Service Worker：网页的后台服务，实现离线和缓存
🔸 同构：同一套代码在服务端和客户端都能运行
```

### 4.2 技术选择指南


**🎯 微前端选择**
```
项目规模：
• 小项目：不建议使用微前端
• 中大型项目：考虑微前端架构

技术栈：
• 统一技术栈：选择single-spa或qiankun
• 混合技术栈：推荐Module Federation

团队情况：
• 单团队：微前端收益不大
• 多团队：微前端能提升开发效率
```

**🖥️ 渲染方式选择**
```
内容特点：
• 静态内容：SSG最佳
• 动态内容：SSR适合
• 交互为主：CSR即可

SEO需求：
• 需要SEO：必选SSR或SSG
• 不需要SEO：CSR最简单

服务器资源：
• 资源充足：可选SSR
• 资源有限：推荐SSG或CSR
```

**📱 PWA应用场景**
```
适合PWA的应用：
✅ 工具类应用：计算器、记事本
✅ 内容类应用：新闻、博客
✅ 电商应用：商品浏览、购物车
✅ 社交应用：聊天、动态

不适合PWA：
❌ 游戏应用：性能要求高
❌ 系统应用：需要底层权限
❌ 复杂交互：原生体验更好
```

### 4.3 实际应用建议


**🚀 技术演进路径**
```
新手学习顺序：
1. 掌握基础Vite配置
2. 学习SSR基本概念
3. 了解PWA核心功能
4. 最后接触微前端架构

项目实践建议：
• 从简单的PWA功能开始
• 逐步加入缓存策略
• 根据需要选择SSR
• 最后考虑微前端拆分
```

**⚠️ 常见误区**
```
❌ 为了技术而技术：不是所有项目都需要这些技术
❌ 过早优化：在项目规模不大时就使用微前端
❌ 忽视成本：这些技术会增加开发和维护复杂度
✅ 根据实际需求选择：解决具体问题才使用相应技术
```

**🧠 记忆要点**
```
微前端：大化小，各自管
SSR渲染：服务端，快加载
PWA应用：像App，能离线  
技术选择：看需求，不盲从
```
