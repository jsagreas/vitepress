---
title: 3、缓存策略与性能优化
---
## 📚 目录

1. [缓存策略基础概念](#1-缓存策略基础概念)
2. [文件缓存策略](#2-文件缓存策略)
3. [压缩优化](#3-压缩优化)
4. [CDN与分发](#4-CDN与分发)
5. [HTTP缓存策略](#5-HTTP缓存策略)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 缓存策略基础概念


### 1.1 什么是缓存策略


**🔸 通俗理解**
```
缓存就像家里的储物柜：
- 把常用的东西放在身边，下次拿取更快
- 网站缓存就是把文件"存储"在用户电脑上
- 下次访问时直接从本地读取，不用重新下载

为什么需要缓存？
用户访问网站 → 下载很多文件（CSS、JS、图片）→ 很慢
有了缓存 → 第二次访问直接用本地文件 → 很快！
```

### 1.2 缓存的工作原理


**💡 简单流程**
```
第一次访问网站：
用户浏览器 → 请求文件 → 服务器 → 返回文件 → 存到缓存

第二次访问网站：
用户浏览器 → 检查缓存 → 有文件！→ 直接使用 → 页面秒开
```

### 1.3 缓存带来的问题


**⚠️ 更新困扰**
```
问题：网站更新了，但用户还在用旧的缓存文件
结果：用户看到的还是旧版本

解决思路：
让浏览器知道"这个文件变了，需要重新下载"
```

---

## 2. 📁 文件缓存策略


### 2.1 文件 Hash 是什么


**🔸 Hash 的通俗解释**
```
Hash 就像文件的"指纹"：
- 每个文件内容不同，指纹就不同
- 文件内容变了，指纹也会变
- 通过指纹可以判断文件是否更新过

示例：
旧文件：main.js → 指纹：main.abc123.js
新文件：main.js → 指纹：main.def456.js（内容变了，指纹也变了）
```

### 2.2 Vite 中的 Hash 配置


**🔧 基础配置**
```javascript
// vite.config.js
export default {
  build: {
    // 给文件名加上 hash 指纹
    rollupOptions: {
      output: {
        // JS 文件的命名规则
        entryFileNames: 'js/[name].[hash].js',
        // CSS 文件的命名规则  
        assetFileNames: 'assets/[name].[hash].[ext]'
      }
    }
  }
}
```

**📊 Hash 类型对比**

| Hash类型 | **含义** | **什么时候变** | **适用场景** |
|---------|----------|---------------|-------------|
| `[hash]` | `整个项目的指纹` | `任何文件变化` | `强缓存场景` |
| `[chunkhash]` | `单个文件块的指纹` | `当前文件变化` | `精确缓存控制` |
| `[contenthash]` | `文件内容的指纹` | `文件内容变化` | `最精确的缓存` |

### 2.3 缓存失效机制


**🔄 自动缓存更新**
```
工作原理：
1. 文件没变化 → hash 不变 → 浏览器用缓存 ✅
2. 文件有变化 → hash 改变 → 浏览器重新下载 ✅

实际效果：
旧版本：main.abc123.js（缓存1年）
新版本：main.def456.js（文件名不同，强制下载新的）
```

### 2.4 浏览器缓存优化实践


**⚡ 最佳实践配置**
```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      output: {
        // 入口文件使用 contenthash（最精确）
        entryFileNames: 'js/[name].[contenthash:8].js',
        // 代码块文件
        chunkFileNames: 'js/[name].[contenthash:8].js',
        // 静态资源文件
        assetFileNames: 'assets/[name].[contenthash:8].[ext]'
      }
    }
  }
}
```

**📋 缓存时间建议**
```
HTML 文件：不缓存（或缓存很短时间）
→ 因为它要指向最新的 JS/CSS 文件

JS/CSS 文件：长期缓存（1年）
→ 因为文件名带 hash，更新时文件名会变

图片/字体：中期缓存（30天）
→ 变化频率不高，但也不是完全不变
```

---

## 3. 🗜️ 压缩优化


### 3.1 什么是 Gzip 压缩


**🔸 压缩的通俗理解**
```
压缩就像打包行李箱：
- 把衣服压缩后能装更多东西
- 网络传输时把文件"压缩"后传输更快
- 到了用户电脑再"解压"使用

效果对比：
原始文件：app.js (100KB)
gzip压缩：app.js.gz (30KB) ← 传输这个，节省70%流量
```

### 3.2 Vite 中启用压缩


**🔧 Gzip 压缩配置**
```javascript
// 安装插件
// npm install vite-plugin-compression -D

// vite.config.js
import compression from 'vite-plugin-compression'

export default {
  plugins: [
    // 启用 gzip 压缩
    compression({
      algorithm: 'gzip',        // 压缩算法
      ext: '.gz',               // 压缩文件扩展名
      threshold: 1024,          // 只压缩大于 1KB 的文件
      deleteOriginFile: false   // 保留原文件
    })
  ]
}
```

**🚀 Brotli 压缩（更高效）**
```javascript
// Brotli 压缩效果更好，但需要服务器支持
compression({
  algorithm: 'brotliCompress',
  ext: '.br',
  threshold: 1024
})
```

### 3.3 压缩效果对比


**📊 实际压缩效果**

| 文件类型 | **原始大小** | **Gzip后** | **Brotli后** | **压缩率** |
|---------|-------------|-----------|-------------|-----------|
| `JavaScript` | `200KB` | `60KB (70%)` | `50KB (75%)` | `很明显` |
| `CSS` | `50KB` | `12KB (76%)` | `10KB (80%)` | `很明显` |
| `HTML` | `20KB` | `6KB (70%)` | `5KB (75%)` | `明显` |
| `图片` | `100KB` | `95KB (5%)` | `94KB (6%)` | `很小` |

> 💡 **记住**：压缩主要对文本文件有效，图片等二进制文件效果有限

### 3.4 资源压缩最佳实践


**✅ 推荐做法**
```javascript
// 完整的压缩配置
export default {
  plugins: [
    // 同时启用两种压缩
    compression({
      algorithm: 'gzip',
      ext: '.gz',
      threshold: 1024,        // 大于1KB才压缩
      filter: /\.(js|css|html|txt|xml|json)$/  // 只压缩文本文件
    }),
    compression({
      algorithm: 'brotliCompress',
      ext: '.br',
      threshold: 1024
    })
  ]
}
```

---

## 4. 🌐 CDN与分发


### 4.1 什么是 CDN


**🔸 CDN 的通俗理解**
```
CDN 就像快递的分拣中心：
- 全国各地都有分拣点，就近配送
- 网站文件也可以放在全球各地的服务器上
- 用户访问时从最近的服务器下载，速度更快

传统方式：
北京用户 → 访问上海服务器 → 很慢（距离远）

CDN方式：
北京用户 → 访问北京CDN节点 → 很快（距离近）
```

### 4.2 CDN 部署策略


**🚀 基本配置思路**
```javascript
// vite.config.js
export default {
  build: {
    // CDN 基础路径
    base: 'https://cdn.example.com/my-app/',
    
    rollupOptions: {
      external: ['vue', 'lodash'],  // 这些库从 CDN 加载
      output: {
        globals: {
          vue: 'Vue',
          lodash: '_'
        }
      }
    }
  }
}
```

### 4.3 静态资源 CDN 配置


**📦 分离静态资源**
```javascript
// 将不同类型文件放到不同 CDN
export default {
  build: {
    rollupOptions: {
      output: {
        assetFileNames: (assetInfo) => {
          // 图片放到图片 CDN
          if (/\.(png|jpg|jpeg|gif|svg)$/.test(assetInfo.name)) {
            return 'https://img-cdn.example.com/[name].[hash].[ext]'
          }
          // CSS/JS 放到静态资源 CDN
          return 'https://static-cdn.example.com/[name].[hash].[ext]'
        }
      }
    }
  }
}
```

### 4.4 全球加速优化


**🌍 CDN 选择建议**

| CDN服务商 | **特点** | **适用场景** | **成本** |
|-----------|----------|-------------|----------|
| `阿里云CDN` | `国内速度快` | `主要服务国内用户` | `中等` |
| `腾讯云CDN` | `覆盖面广` | `国内外都有用户` | `中等` |
| `Cloudflare` | `全球覆盖好` | `国际化应用` | `有免费版` |

> 💡 **小贴士**：可以同时使用多个 CDN，根据用户地理位置自动选择最优节点

---

## 5. 🔄 HTTP缓存策略


### 5.1 HTTP 缓存基础


**🔸 缓存的两种工作方式**
```
强缓存（不问服务器）：
浏览器：这个文件我有缓存，直接用！
→ 速度最快，但可能用到旧文件

协商缓存（问一下服务器）：
浏览器：服务器，这个文件更新了吗？
服务器：没更新，用你的缓存吧！
→ 确保是最新的，但多了一次请求
```

### 5.2 缓存头配置


**⚙️ Vite 中的缓存配置**
```javascript
// vite.config.js
export default {
  server: {
    // 开发环境的缓存设置
    headers: {
      'Cache-Control': 'no-cache'  // 开发时不缓存，确保看到最新代码
    }
  },
  preview: {
    // 预览环境的缓存设置
    headers: {
      'Cache-Control': 'max-age=31536000'  // 生产环境长期缓存
    }
  }
}
```

### 5.3 长期缓存实现


**🎯 分类缓存策略**
```javascript
// 针对不同文件类型设置不同缓存策略
const cacheConfig = {
  // HTML 文件：短期缓存
  html: 'max-age=300',           // 5分钟
  
  // 带 hash 的静态资源：长期缓存
  staticWithHash: 'max-age=31536000, immutable',  // 1年，不可变
  
  // 不带 hash 的资源：中期缓存
  staticNoHash: 'max-age=86400'  // 1天
}
```

### 5.4 缓存失效处理


**🔄 完整的缓存策略**
```
文件分层缓存：

1. HTML 入口文件
   ├── 缓存时间：5分钟
   └── 目的：快速获取最新的资源引用

2. JS/CSS 文件（带hash）
   ├── 缓存时间：1年
   └── 目的：文件名变了就是新文件，可以长期缓存

3. 图片/字体文件
   ├── 缓存时间：30天
   └── 目的：平衡缓存效果和更新需求

实际效果：
- 用户第一次访问：下载所有文件
- 日常访问：只下载 HTML，其他都用缓存
- 网站更新后：只下载变化的文件
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 缓存本质：把文件存在用户电脑上，下次访问更快
🔸 Hash机制：文件内容变化时文件名也变化，自动更新缓存
🔸 压缩优化：减少文件大小，传输速度更快
🔸 CDN分发：就近访问，全球加速
🔸 HTTP缓存：通过HTTP头控制浏览器缓存行为
```

### 6.2 关键理解要点


**🔹 为什么需要 Hash**
```
没有 Hash 的问题：
网站更新 → 用户浏览器还用旧缓存 → 看到旧版本

有了 Hash 的解决：
网站更新 → 文件名变化 → 浏览器自动下载新文件 ✅
```

**🔹 压缩的适用范围**
```
文本文件（JS、CSS、HTML）：压缩效果显著 ✅
图片、视频等二进制文件：压缩效果很小 ❌

记住：压缩主要针对代码文件，不要指望压缩图片
```

**🔹 缓存策略的分层思维**
```
HTML文件：短缓存（要能及时更新文件引用）
JS/CSS：长缓存（文件名带hash，变了就是新文件）
图片：中等缓存（变化不频繁，但也需要更新能力）
```

### 6.3 实际应用建议


**✅ 推荐配置组合**
```javascript
// 生产环境最佳实践
export default {
  build: {
    rollupOptions: {
      output: {
        // 使用 contenthash，精确控制缓存
        entryFileNames: 'js/[name].[contenthash:8].js',
        assetFileNames: 'assets/[name].[contenthash:8].[ext]'
      }
    }
  },
  plugins: [
    // 启用 gzip 压缩
    compression({
      algorithm: 'gzip',
      threshold: 1024
    })
  ]
}
```

**🎯 性能优化检查清单**
- [x] **文件hash**: 确保缓存能正确更新
- [x] **gzip压缩**: 减少传输文件大小  
- [x] **CDN部署**: 就近访问提升速度
- [x] **缓存策略**: 不同文件不同缓存时间
- [x] **监控效果**: 检查实际的加载速度提升

### 6.4 常见问题避免


**❌ 容易犯的错误**
```
错误1：所有文件都用相同的缓存时间
正确：HTML短缓存，静态资源长缓存

错误2：忘记配置文件hash
正确：生产环境必须使用contenthash

错误3：压缩配置过于复杂
正确：简单的gzip配置就够用了
```

**核心记忆**：
- 缓存让网站更快，Hash让缓存更准确
- 压缩让传输更快，CDN让访问更快  
- 不同文件用不同策略，分层思维很重要
- 配置要简单实用，过度优化适得其反