---
title: 5、错误处理与异常管理
---
## 📚 目录

1. [错误处理基础概念](#1-错误处理基础概念)
2. [错误处理中间件](#2-错误处理中间件)
3. [404错误专项处理](#3-404错误专项处理)
4. [自定义错误体系](#4-自定义错误体系)
5. [异步错误捕获](#5-异步错误捕获)
6. [全局错误处理器](#6-全局错误处理器)
7. [生产环境错误管理](#7-生产环境错误管理)
8. [核心要点总结](#8-核心要点总结)

---

## 1. 🎯 错误处理基础概念


### 1.1 为什么需要错误处理


**生活化理解**：错误处理就像给房子装防盗门一样重要
```
没有错误处理的网站 = 没有防盗门的房子
- 一出问题就崩溃
- 用户看到奇怪的技术错误
- 服务器可能直接停止运行

有错误处理的网站 = 有完善安防的房子  
- 优雅地处理各种异常
- 给用户友好的提示
- 记录问题便于修复
```

### 1.2 Express中的错误类型


**🏷️ 常见错误分类**：
```
语法错误类：
❌ 代码写错了 → 服务器启动就报错
❌ 变量名拼写错误 → ReferenceError

运行时错误类：
❌ 访问不存在的属性 → TypeError  
❌ 数组越界访问 → undefined
❌ 数据库连接失败 → ConnectionError

业务逻辑错误类：
❌ 用户权限不足 → 403 Forbidden
❌ 资源不存在 → 404 Not Found  
❌ 参数格式错误 → 400 Bad Request
```

### 1.3 错误处理的核心原则


**🎯 处理原则**：
```
用户友好：不让用户看到技术错误信息
系统稳定：错误不能导致整个应用崩溃
便于调试：开发者能快速定位问题根源
安全考虑：不泄露敏感的系统信息
```

---

## 2. ⚙️ 错误处理中间件


### 2.1 错误中间件的特殊之处


**核心概念**：错误处理中间件是Express中的特殊中间件

```javascript
// 普通中间件：3个参数
app.use((req, res, next) => {
    // 正常处理逻辑
});

// 错误处理中间件：4个参数（多了err）
app.use((err, req, res, next) => {
    // 错误处理逻辑
});
```

**🔍 关键理解**：
- **4个参数是标志** - Express通过参数个数识别错误中间件
- **必须放在最后** - 错误处理中间件要放在所有路由之后
- **捕获所有错误** - 能捕获到前面中间件传递来的错误

### 2.2 next(err) 错误传递机制


**错误传递流程图**：
```
路由处理器发现错误
        ↓
    调用 next(err)
        ↓
跳过所有普通中间件
        ↓
直接到达错误处理中间件
        ↓
    处理错误并响应
```

**实际代码示例**：
```javascript
// 路由中发现错误
app.get('/users/:id', (req, res, next) => {
    const userId = req.params.id;
    
    if (!userId || userId < 1) {
        // 发现错误，传递给错误处理中间件
        const error = new Error('用户ID无效');
        error.status = 400;
        return next(error);  // 关键：调用next(err)
    }
    
    res.json({ id: userId, name: '张三' });
});

// 错误处理中间件（放在最后）
app.use((err, req, res, next) => {
    res.status(err.status || 500).json({
        message: err.message,
        error: process.env.NODE_ENV === 'development' ? err : {}
    });
});
```

### 2.3 错误中间件的执行顺序


**执行顺序示意图**：
```
请求进入
    ↓
路由中间件1 → 正常执行
    ↓
路由中间件2 → 发现错误，next(err)
    ↓
跳过中间件3、4、5...
    ↓
错误处理中间件 → 处理错误
    ↓
返回错误响应
```

---

## 3. 🚫 404错误专项处理


### 3.1 404错误的特殊性


**概念理解**：404不是程序错误，而是"资源找不到"
```
404的本质：
- 不是代码出错
- 而是用户访问了不存在的页面
- 需要特殊处理，不能用错误中间件
```

### 3.2 统一404处理策略


**处理位置**：404处理器要放在所有路由之后，错误中间件之前

```javascript
const express = require('express');
const app = express();

// 所有正常路由
app.get('/', (req, res) => {
    res.send('首页');
});

app.get('/about', (req, res) => {
    res.send('关于我们');
});

// 404处理器（重要：放在所有路由后面）
app.use((req, res, next) => {
    res.status(404).json({
        message: '页面不存在',
        url: req.originalUrl,
        method: req.method
    });
});

// 错误处理中间件（最后）
app.use((err, req, res, next) => {
    res.status(500).json({ message: '服务器内部错误' });
});
```

### 3.3 友好的404页面


**用户体验优化**：
```javascript
// 返回友好的404信息
app.use((req, res, next) => {
    const is404 = true;
    
    res.status(404).json({
        success: false,
        message: '您访问的页面不存在',
        suggestions: [
            '检查URL拼写是否正确',
            '返回首页重新导航',
            '联系客服获取帮助'
        ],
        requestedUrl: req.originalUrl,
        timestamp: new Date().toISOString()
    });
});
```

---

## 4. 🎨 自定义错误体系


### 4.1 为什么需要自定义错误类


**业务需求**：不同类型的错误需要不同的处理方式
```
用户权限错误 → 返回403，提示登录
参数验证错误 → 返回400，指出具体问题  
数据库错误 → 返回500，记录详细日志
第三方服务错误 → 返回502，启动重试机制
```

### 4.2 创建自定义错误类


```javascript
// 基础错误类
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        this.isOperational = true; // 标记这是可预期的业务错误
        
        Error.captureStackTrace(this, this.constructor);
    }
}

// 具体的错误类型
class ValidationError extends AppError {
    constructor(message) {
        super(message, 400);
        this.name = 'ValidationError';
    }
}

class AuthenticationError extends AppError {
    constructor(message = '身份验证失败') {
        super(message, 401);
        this.name = 'AuthenticationError';
    }
}

class NotFoundError extends AppError {
    constructor(resource = '资源') {
        super(`${resource}不存在`, 404);
        this.name = 'NotFoundError';
    }
}

module.exports = { AppError, ValidationError, AuthenticationError, NotFoundError };
```

### 4.3 错误类型分类和标准化


**错误分类表**：

| 错误类型 | 状态码 | 使用场景 | 用户提示 |
|---------|--------|----------|----------|
| **ValidationError** | `400` | 参数格式错误 | 请检查输入参数 |
| **AuthenticationError** | `401` | 身份验证失败 | 请重新登录 |
| **AuthorizationError** | `403` | 权限不足 | 您没有访问权限 |
| **NotFoundError** | `404` | 资源不存在 | 请求的资源不存在 |
| **ConflictError** | `409` | 资源冲突 | 资源已存在或冲突 |
| **RateLimitError** | `429` | 请求过于频繁 | 请稍后再试 |
| **ServerError** | `500` | 服务器内部错误 | 服务暂时不可用 |

**使用示例**：
```javascript
const { ValidationError, NotFoundError } = require('./errors');

app.get('/users/:id', async (req, res, next) => {
    try {
        const { id } = req.params;
        
        // 参数验证
        if (!id || isNaN(id)) {
            throw new ValidationError('用户ID必须是有效数字');
        }
        
        // 查找用户
        const user = await User.findById(id);
        if (!user) {
            throw new NotFoundError('用户');
        }
        
        res.json(user);
    } catch (error) {
        next(error); // 传递给错误处理中间件
    }
});
```

---

## 5. ⚡ 异步错误捕获


### 5.1 异步操作的错误处理难点


**问题说明**：异步操作中的错误不会被Express自动捕获
```javascript
// ❌ 错误示例：异步错误不会被捕获
app.get('/async-error', (req, res) => {
    setTimeout(() => {
        throw new Error('异步错误'); // 这个错误不会被Express捕获！
    }, 1000);
});

// ❌ Promise错误也不会自动捕获  
app.get('/promise-error', (req, res) => {
    Promise.resolve().then(() => {
        throw new Error('Promise错误'); // 也不会被自动捕获
    });
});
```

### 5.2 Promise错误的捕获技巧


**解决方案1：使用try-catch + async/await**
```javascript
app.get('/users', async (req, res, next) => {
    try {
        // 异步操作可能出错
        const users = await User.findAll();
        const processedUsers = await processUsers(users);
        
        res.json(processedUsers);
    } catch (error) {
        next(error); // 捕获后传递给错误处理中间件
    }
});
```

**解决方案2：Promise的catch处理**
```javascript
app.get('/posts', (req, res, next) => {
    Post.findAll()
        .then(posts => res.json(posts))
        .catch(next); // 直接把next作为catch的处理函数
});
```

### 5.3 创建异步错误处理包装器


**实用工具函数**：
```javascript
// 异步错误捕获包装器
const asyncCatch = (fn) => {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
};

// 使用包装器简化代码
app.get('/users/:id', asyncCatch(async (req, res) => {
    const user = await User.findById(req.params.id);
    if (!user) {
        throw new NotFoundError('用户');
    }
    res.json(user);
}));
```

---

## 6. 🛡️ 全局错误处理器


### 6.1 统一错误处理中间件


**完整的错误处理器**：
```javascript
const globalErrorHandler = (err, req, res, next) => {
    // 设置默认值
    err.statusCode = err.statusCode || 500;
    err.status = err.status || 'error';
    
    // 根据环境返回不同的错误信息
    if (process.env.NODE_ENV === 'development') {
        sendErrorDev(err, res);
    } else {
        sendErrorProd(err, res);
    }
};

// 开发环境：返回详细错误信息
const sendErrorDev = (err, res) => {
    res.status(err.statusCode).json({
        status: err.status,
        error: err,
        message: err.message,
        stack: err.stack
    });
};

// 生产环境：返回简化错误信息
const sendErrorProd = (err, res) => {
    // 可预期的业务错误，可以告诉用户
    if (err.isOperational) {
        res.status(err.statusCode).json({
            status: err.status,
            message: err.message
        });
    } else {
        // 未知错误，不暴露细节
        console.error('ERROR:', err);
        res.status(500).json({
            status: 'error',
            message: '服务器内部错误'
        });
    }
};

module.exports = globalErrorHandler;
```

### 6.2 错误日志记录


**日志记录策略**：
```javascript
const winston = require('winston');

// 配置日志记录器
const logger = winston.createLogger({
    level: 'error',
    format: winston.format.json(),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.Console()
    ]
});

const errorLogger = (err, req, res, next) => {
    // 记录错误详细信息
    logger.error({
        message: err.message,
        stack: err.stack,
        url: req.originalUrl,
        method: req.method,
        ip: req.ip,
        userAgent: req.get('User-Agent'),
        timestamp: new Date().toISOString()
    });
    
    next(err); // 继续传递给下一个错误处理器
};

// 使用日志中间件
app.use(errorLogger);
app.use(globalErrorHandler);
```

---

## 7. 🏭 生产环境错误管理


### 7.1 错误信息脱敏


**安全考虑**：生产环境不能暴露敏感信息
```javascript
const sanitizeError = (err) => {
    // 数据库错误脱敏
    if (err.name === 'MongoError') {
        return new AppError('数据库操作失败', 500);
    }
    
    // JWT错误脱敏  
    if (err.name === 'JsonWebTokenError') {
        return new AppError('身份验证失败', 401);
    }
    
    // 文件系统错误脱敏
    if (err.code === 'ENOENT') {
        return new AppError('文件不存在', 404);
    }
    
    return err;
};

const productionErrorHandler = (err, req, res, next) => {
    const sanitizedError = sanitizeError(err);
    
    res.status(sanitizedError.statusCode || 500).json({
        success: false,
        message: sanitizedError.message || '服务器内部错误'
    });
};
```

### 7.2 错误率监控指标


**监控关键指标**：
```javascript
// 错误统计中间件
let errorStats = {
    total: 0,
    byType: {},
    byHour: {}
};

const errorStatsMiddleware = (err, req, res, next) => {
    // 统计总错误数
    errorStats.total++;
    
    // 按错误类型统计
    const errorType = err.constructor.name;
    errorStats.byType[errorType] = (errorStats.byType[errorType] || 0) + 1;
    
    // 按小时统计
    const hour = new Date().getHours();
    errorStats.byHour[hour] = (errorStats.byHour[hour] || 0) + 1;
    
    next(err);
};

// 监控接口
app.get('/admin/error-stats', (req, res) => {
    res.json({
        ...errorStats,
        errorRate: errorStats.total / totalRequests * 100
    });
});
```

### 7.3 异常监控和告警


**告警机制**：
```javascript
const alertThreshold = {
    errorRate: 5, // 错误率超过5%
    consecutive: 10 // 连续10个错误
};

let consecutiveErrors = 0;

const alertMiddleware = (err, req, res, next) => {
    consecutiveErrors++;
    
    // 检查是否需要告警
    if (consecutiveErrors >= alertThreshold.consecutive) {
        sendAlert({
            type: 'consecutive_errors',
            count: consecutiveErrors,
            lastError: err.message
        });
        consecutiveErrors = 0; // 重置计数
    }
    
    next(err);
};

const sendAlert = (alertData) => {
    // 发送邮件/短信/钉钉通知
    console.log('🚨 系统告警:', alertData);
    // 实际项目中会调用通知服务
};
```

---

## 8. 📋 核心要点总结


### 8.1 必须掌握的核心概念


```
🔸 错误中间件：4个参数(err, req, res, next)，放在最后
🔸 错误传递：使用next(err)将错误传递给错误处理中间件  
🔸 404处理：单独处理，放在所有路由后、错误中间件前
🔸 异步错误：需要用try-catch或Promise.catch手动捕获
🔸 自定义错误：创建错误类，便于分类处理
🔸 环境区分：开发环境显示详细信息，生产环境保护敏感数据
```

### 8.2 错误处理最佳实践


**处理流程图**：
```
请求进入
    ↓
路由处理逻辑
    ↓
发生错误？ ─No─→ 正常响应
    ↓Yes
调用next(err)
    ↓
错误日志记录
    ↓
错误信息脱敏
    ↓
返回统一格式错误响应
    ↓
错误统计和监控
```

### 8.3 中间件顺序总结


**正确的中间件顺序**：
```javascript
// 1. 全局中间件
app.use(express.json());
app.use(cors());

// 2. 路由中间件
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);

// 3. 404处理器
app.use((req, res, next) => {
    res.status(404).json({ message: '页面不存在' });
});

// 4. 错误日志记录
app.use(errorLogger);

// 5. 错误统计监控  
app.use(errorStatsMiddleware);

// 6. 全局错误处理器（最后）
app.use(globalErrorHandler);
```

### 8.4 实际开发要点


**开发建议**：
- ✅ **统一错误格式** - 所有错误响应保持一致的JSON结构
- ✅ **分层错误处理** - 业务层、服务层、数据层分别处理对应错误
- ✅ **错误码规范** - 制定项目内统一的错误码体系  
- ✅ **日志分级** - error/warn/info不同级别，便于问题排查
- ✅ **监控告警** - 设置合理的错误率阈值和告警机制

**记忆要点**：
- 错误中间件四参数，一定要放最后面
- 异步错误要手动捕获，不然Express抓不到
- 生产环境要脱敏，开发环境要详细
- 404是特殊情况，需要单独处理