---
title: 5、错误处理与日志系统
---
## 📚 目录

1. [错误处理基础概念](#1-错误处理基础概念)
2. [错误类型与分类](#2-错误类型与分类)
3. [错误捕获与处理策略](#3-错误捕获与处理策略)
4. [自定义错误处理系统](#4-自定义错误处理系统)
5. [日志系统的重要性](#5-日志系统的重要性)
6. [日志级别与分类](#6-日志级别与分类)
7. [专业日志工具](#7-专业日志工具)
8. [生产环境最佳实践](#8-生产环境最佳实践)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🚨 错误处理基础概念


### 1.1 为什么需要错误处理


**错误处理就像给程序买保险**，程序运行时总会遇到各种意外情况：

```
现实情况类比：
开车时可能遇到：爆胎、没油、堵车、违章
程序运行时可能遇到：网络断开、文件丢失、内存不足、用户输入错误

处理方式：
开车：准备备胎、随时加油、规划路线、遵守交规
程序：错误捕获、异常处理、日志记录、用户提示
```

**错误处理的核心目标**：
- 🛡️ **保护程序**：避免崩溃，保持稳定运行
- 📝 **记录问题**：知道什么时候出错了，为什么出错
- 🔧 **快速修复**：能够迅速定位和解决问题
- 👥 **用户体验**：给用户友好的错误提示

### 1.2 错误处理的基本思路


**三步走策略**：
```
1. 预防错误：在可能出错的地方做检查
   ↓
2. 捕获错误：用try/catch等方式抓住错误
   ↓  
3. 处理错误：记录日志、返回友好信息、必要时重试
```

---

## 2. 🔍 错误类型与分类


### 2.1 业务错误 vs 系统错误


理解这两种错误的区别很重要，就像区分"感冒"和"骨折"：

**🏥 业务错误（可预期的错误）**
```javascript
// 就像用户感冒，可以预料和处理
const loginUser = (username, password) => {
  // 用户名为空 - 业务错误
  if (!username) {
    throw new Error('用户名不能为空');
  }
  
  // 密码错误 - 业务错误  
  if (password !== 'correct123') {
    throw new Error('密码错误');
  }
  
  return { id: 1, name: username };
};
```

**💥 系统错误（不可预期的错误）**
```javascript
// 就像突然骨折，需要紧急处理
const readUserFile = () => {
  try {
    // 磁盘损坏、权限不足 - 系统错误
    const data = fs.readFileSync('/path/to/user.json');
    return JSON.parse(data);
  } catch (error) {
    // 系统级错误，需要记录并告警
    console.error('系统错误:', error.message);
    throw error;
  }
};
```

**📊 错误类型对比表**

| 特征 | 业务错误 | 系统错误 |
|------|----------|----------|
| **可预期性** | ✅ 可以预测 | ❌ 难以预测 |
| **处理方式** | 返回错误信息给用户 | 记录日志，可能需要重启 |
| **用户感知** | 友好提示 | 系统维护中 |
| **示例** | 密码错误、格式不对 | 数据库连接失败、内存溢出 |

### 2.2 常见错误分类


**🎯 按错误来源分类**
```
用户输入错误：
├── 必填字段为空
├── 格式不正确  
├── 数据超出范围
└── 权限不足

系统运行错误：
├── 网络连接失败
├── 文件读写错误
├── 数据库操作失败  
└── 内存不足

程序逻辑错误：
├── 空指针引用
├── 类型转换错误
├── 数组越界
└── 函数调用错误
```

---

## 3. 🛠️ 错误捕获与处理策略


### 3.1 try/catch 基础用法


**try/catch 就像给代码穿防弹衣**：

```javascript
// 同步代码的错误捕获
const safeParseJSON = (jsonString) => {
  try {
    // 可能出错的代码放在try里
    const result = JSON.parse(jsonString);
    console.log('解析成功:', result);
    return result;
  } catch (error) {
    // 出错了就跳到catch里处理
    console.error('JSON解析失败:', error.message);
    return null; // 返回默认值
  }
};

// 使用示例
safeParseJSON('{"name": "张三"}');  // 正常解析
safeParseJSON('无效JSON');          // 捕获错误，返回null
```

### 3.2 异步错误处理策略


**Promise 错误处理**：
```javascript
// Promise链式调用的错误处理
const fetchUserData = async (userId) => {
  try {
    // 每个异步操作都可能出错
    const user = await getUserById(userId);
    const profile = await getUserProfile(user.id);
    const permissions = await getUserPermissions(user.id);
    
    return {
      user,
      profile, 
      permissions
    };
  } catch (error) {
    // 任何一步出错都会被这里捕获
    console.error('获取用户数据失败:', error.message);
    
    // 根据错误类型做不同处理
    if (error.message.includes('网络')) {
      throw new Error('网络连接失败，请稍后重试');
    } else if (error.message.includes('权限')) {
      throw new Error('没有权限访问该用户信息');
    } else {
      throw new Error('系统繁忙，请稍后重试');
    }
  }
};
```

**回调函数错误处理**：
```javascript
// Node.js 传统的错误优先回调
const readConfigFile = (callback) => {
  fs.readFile('config.json', 'utf8', (err, data) => {
    if (err) {
      // 第一个参数是错误
      return callback(new Error('配置文件读取失败: ' + err.message));
    }
    
    try {
      const config = JSON.parse(data);
      // 成功时错误参数为null
      callback(null, config);
    } catch (parseErr) {
      callback(new Error('配置文件格式错误: ' + parseErr.message));
    }
  });
};
```

### 3.3 全局错误处理中间件


**Express 全局错误处理**就像医院的急诊科，处理所有没被处理的错误：

```javascript
// 全局错误处理中间件（必须放在最后）
const globalErrorHandler = (err, req, res, next) => {
  // 记录错误详情
  console.error('发生错误:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    time: new Date()
  });
  
  // 区分错误类型，返回不同响应
  if (err.name === 'ValidationError') {
    // 数据验证错误
    return res.status(400).json({
      success: false,
      message: '数据格式错误',
      details: err.message
    });
  }
  
  if (err.name === 'UnauthorizedError') {
    // 权限错误
    return res.status(401).json({
      success: false,
      message: '没有访问权限'
    });
  }
  
  // 其他未知错误
  res.status(500).json({
    success: false,
    message: '服务器内部错误，请稍后重试'
  });
};

// 在 app.js 中使用
app.use(globalErrorHandler);
```

---

## 4. 🎨 自定义错误处理系统


### 4.1 自定义错误类


**创建专门的错误类型**，就像医院分科室一样：

```javascript
// 基础自定义错误类
class AppError extends Error {
  constructor(message, statusCode = 500, errorCode = 'UNKNOWN_ERROR') {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.isOperational = true; // 标记为可操作的错误
    
    // 捕获堆栈信息
    Error.captureStackTrace(this, this.constructor);
  }
}

// 具体的错误类型
class ValidationError extends AppError {
  constructor(message, field) {
    super(message, 400, 'VALIDATION_ERROR');
    this.field = field;
  }
}

class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource}不存在`, 404, 'NOT_FOUND');
    this.resource = resource;
  }
}

class AuthenticationError extends AppError {
  constructor(message = '身份验证失败') {
    super(message, 401, 'AUTH_ERROR');
  }
}
```

### 4.2 错误码标准化


**统一的错误码系统**，让错误信息更规范：

```javascript
// 错误码配置
const ERROR_CODES = {
  // 用户相关错误 (1000-1999)
  USER_NOT_FOUND: {
    code: 1001,
    message: '用户不存在',
    httpStatus: 404
  },
  INVALID_PASSWORD: {
    code: 1002, 
    message: '密码错误',
    httpStatus: 400
  },
  
  // 数据验证错误 (2000-2999)
  MISSING_REQUIRED_FIELD: {
    code: 2001,
    message: '缺少必填字段',
    httpStatus: 400
  },
  
  // 系统错误 (5000-5999)
  DATABASE_CONNECTION_FAILED: {
    code: 5001,
    message: '数据库连接失败',
    httpStatus: 500
  }
};

// 错误工厂函数
const createError = (errorType, details = {}) => {
  const errorConfig = ERROR_CODES[errorType];
  if (!errorConfig) {
    throw new Error(`未知错误类型: ${errorType}`);
  }
  
  const error = new AppError(
    errorConfig.message,
    errorConfig.httpStatus,
    errorConfig.code
  );
  
  // 添加额外详情
  Object.assign(error, details);
  return error;
};

// 使用示例
const loginUser = (username, password) => {
  if (!username) {
    throw createError('MISSING_REQUIRED_FIELD', { field: 'username' });
  }
  
  if (password !== 'correct123') {
    throw createError('INVALID_PASSWORD');
  }
  
  return { success: true };
};
```

### 4.3 错误信息脱敏策略


**生产环境要保护敏感信息**，就像医生不会把病历给无关的人看：

```javascript
// 错误信息脱敏处理
const sanitizeError = (error, isProduction = false) => {
  const baseResponse = {
    success: false,
    errorCode: error.errorCode || 'UNKNOWN_ERROR',
    message: error.message
  };
  
  if (isProduction) {
    // 生产环境：隐藏敏感信息
    return {
      ...baseResponse,
      message: error.isOperational ? error.message : '系统繁忙，请稍后重试'
      // 不返回 stack、详细路径等敏感信息
    };
  } else {
    // 开发环境：返回详细信息
    return {
      ...baseResponse,
      stack: error.stack,
      details: error.details
    };
  }
};
```

---

## 5. 📝 日志系统的重要性


### 5.1 为什么需要日志


**日志就像程序的"黑匣子"**，记录程序运行的重要信息：

```
飞机黑匣子记录：速度、高度、操作记录、对话录音
程序日志记录：请求信息、错误详情、性能数据、用户操作

作用对比：
飞机：事故分析、找出原因、改进安全
程序：错误排查、性能优化、安全监控
```

**日志的核心价值**：
- 🔍 **问题诊断**：快速定位程序出错的原因
- 📊 **性能监控**：了解系统运行状况  
- 🛡️ **安全审计**：追踪可疑操作和攻击
- 📈 **业务分析**：分析用户行为和系统使用情况

### 5.2 console 基础日志


**console 是最简单的日志工具**，适合开发调试：

```javascript
// 基础 console 日志方法
const demoConsoleLogging = () => {
  // 普通信息输出
  console.log('用户登录成功', { userId: 123, time: new Date() });
  
  // 警告信息（黄色显示）
  console.warn('数据库连接缓慢，请检查网络');
  
  // 错误信息（红色显示）
  console.error('支付接口调用失败', new Error('网络超时'));
  
  // 调试信息
  console.debug('调试信息：用户权限检查通过');
  
  // 表格形式显示数据
  console.table([
    { name: '张三', age: 25, city: '北京' },
    { name: '李四', age: 30, city: '上海' }
  ]);
  
  // 计时功能
  console.time('数据库查询');
  // ... 执行数据库查询
  console.timeEnd('数据库查询'); // 输出：数据库查询: 45.123ms
};
```

**console 的局限性**：
- ❌ 无法持久化保存
- ❌ 无法按级别过滤
- ❌ 无法结构化输出
- ❌ 生产环境性能影响

---

## 6. 📊 日志级别与分类


### 6.1 日志级别详解


**日志级别就像医院的紧急程度分类**：

```
🚨 ERROR (错误)：需要立即处理的严重问题
类比：急诊红色标签 - 生命危险，立即抢救
示例：数据库连接失败、支付接口异常、系统崩溃

⚠️ WARN (警告)：需要关注但不紧急的问题  
类比：急诊黄色标签 - 需要关注，但不危及生命
示例：内存使用率高、API响应慢、配置文件缺失

ℹ️ INFO (信息)：重要的业务流程记录
类比：病历记录 - 正常诊疗过程记录
示例：用户登录、订单创建、文件上传完成

🔧 DEBUG (调试)：开发调试用的详细信息
类比：化验单详细数据 - 医生诊断用，患者不需要看
示例：函数调用参数、变量值变化、SQL查询语句
```

### 6.2 结构化日志记录


**结构化日志让信息更易于分析**：

```javascript
// 简单的结构化日志实现
class SimpleLogger {
  constructor(level = 'INFO') {
    this.level = level;
    this.levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
  }
  
  // 格式化日志输出
  formatLog(level, message, meta = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      ...meta
    };
    
    return JSON.stringify(logEntry);
  }
  
  // 检查日志级别
  shouldLog(level) {
    return this.levels[level] >= this.levels[this.level];
  }
  
  debug(message, meta) {
    if (this.shouldLog('DEBUG')) {
      console.log(this.formatLog('DEBUG', message, meta));
    }
  }
  
  info(message, meta) {
    if (this.shouldLog('INFO')) {
      console.log(this.formatLog('INFO', message, meta));
    }
  }
  
  warn(message, meta) {
    if (this.shouldLog('WARN')) {
      console.warn(this.formatLog('WARN', message, meta));
    }
  }
  
  error(message, meta) {
    if (this.shouldLog('ERROR')) {
      console.error(this.formatLog('ERROR', message, meta));
    }
  }
}

// 使用示例
const logger = new SimpleLogger('INFO');

logger.info('用户登录', {
  userId: 123,
  ip: '192.168.1.1',
  userAgent: 'Chrome/91.0'
});

logger.error('数据库连接失败', {
  database: 'users',
  error: 'Connection timeout',
  retryCount: 3
});
```

### 6.3 日志上下文管理


**为每个请求添加唯一标识**，方便追踪完整流程：

```javascript
// 请求上下文中间件
const addRequestContext = (req, res, next) => {
  // 生成唯一请求ID
  req.requestId = require('crypto').randomUUID();
  req.startTime = Date.now();
  
  // 记录请求开始
  logger.info('请求开始', {
    requestId: req.requestId,
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });
  
  // 监听响应结束
  res.on('finish', () => {
    const duration = Date.now() - req.startTime;
    logger.info('请求结束', {
      requestId: req.requestId,
      statusCode: res.statusCode,
      duration: `${duration}ms`
    });
  });
  
  next();
};

// 在业务逻辑中使用上下文
const getUserProfile = (req, res) => {
  const { requestId } = req;
  const { userId } = req.params;
  
  logger.info('开始获取用户资料', { requestId, userId });
  
  try {
    const profile = getUserById(userId);
    logger.info('用户资料获取成功', { requestId, userId });
    res.json(profile);
  } catch (error) {
    logger.error('用户资料获取失败', { 
      requestId, 
      userId, 
      error: error.message 
    });
    res.status(500).json({ error: '获取用户资料失败' });
  }
};
```

---

## 7. 🛠️ 专业日志工具


### 7.1 Winston 日志库


**Winston 是 Node.js 最流行的日志库**，功能强大且灵活：

```javascript
const winston = require('winston');

// 创建 Winston 日志器
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'user-service' },
  transports: [
    // 错误日志写入文件
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    
    // 所有日志写入文件
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    })
  ]
});

// 开发环境添加控制台输出
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

// 使用示例
logger.info('用户登录成功', { userId: 123, ip: '127.0.0.1' });
logger.error('数据库连接失败', new Error('Connection timeout'));
```

### 7.2 日志文件输出与轮转


**日志文件管理**就像图书馆管理书籍，需要分类存放和定期整理：

```javascript
const winston = require('winston');
require('winston-daily-rotate-file');

// 配置日志轮转
const logger = winston.createLogger({
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    // 按日期轮转的错误日志
    new winston.transports.DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: '20m',      // 单个文件最大20MB
      maxFiles: '14d',     // 保留14天
      zippedArchive: true  // 压缩旧文件
    }),
    
    // 按日期轮转的综合日志
    new winston.transports.DailyRotateFile({
      filename: 'logs/app-%DATE%.log',
      datePattern: 'YYYY-MM-DD-HH',  // 按小时轮转
      maxSize: '100m',
      maxFiles: '7d'
    })
  ]
});

// 日志清理事件
logger.on('rotate', (oldFilename, newFilename) => {
  console.log(`日志文件轮转: ${oldFilename} -> ${newFilename}`);
});
```

### 7.3 日志收集和分析


**集中式日志管理**适合多服务器环境：

```javascript
// 发送日志到外部系统
const winston = require('winston');
const ElasticsearchTransport = require('winston-elasticsearch');

const logger = winston.createLogger({
  transports: [
    // 发送到 Elasticsearch
    new ElasticsearchTransport({
      level: 'info',
      clientOpts: {
        host: 'http://localhost:9200'
      },
      index: 'app-logs'
    }),
    
    // 本地文件备份
    new winston.transports.File({
      filename: 'logs/backup.log'
    })
  ]
});

// 监控关键业务指标
const logBusinessMetrics = (action, result, duration) => {
  logger.info('业务指标', {
    category: 'business-metrics',
    action,
    result,
    duration,
    timestamp: new Date()
  });
};

// 使用示例
logBusinessMetrics('user-login', 'success', 145);
logBusinessMetrics('payment', 'failed', 2300);
```

---

## 8. 🏭 生产环境最佳实践


### 8.1 环境配置区分


**不同环境需要不同的日志策略**：

```javascript
// 环境配置
const config = {
  development: {
    logLevel: 'debug',
    logToConsole: true,
    logToFile: false,
    prettyPrint: true
  },
  testing: {
    logLevel: 'warn',
    logToConsole: false,
    logToFile: true,
    prettyPrint: false
  },
  production: {
    logLevel: 'info',
    logToConsole: false,
    logToFile: true,
    prettyPrint: false,
    enableMetrics: true
  }
};

// 根据环境创建日志器
const createLogger = (env = 'development') => {
  const envConfig = config[env];
  const transports = [];
  
  if (envConfig.logToConsole) {
    transports.push(new winston.transports.Console({
      format: envConfig.prettyPrint 
        ? winston.format.simple()
        : winston.format.json()
    }));
  }
  
  if (envConfig.logToFile) {
    transports.push(new winston.transports.File({
      filename: `logs/${env}.log`
    }));
  }
  
  return winston.createLogger({
    level: envConfig.logLevel,
    transports
  });
};
```

### 8.2 错误监控和告警


**自动监控和告警系统**：

```javascript
// 错误统计和告警
class ErrorMonitor {
  constructor() {
    this.errorCounts = new Map();
    this.alertThresholds = {
      error: 10,    // 错误数超过10个
      warn: 50,     // 警告数超过50个
      timeWindow: 5 * 60 * 1000  // 5分钟时间窗口
    };
  }
  
  // 记录错误
  recordError(level, message) {
    const now = Date.now();
    const key = `${level}-${Math.floor(now / this.alertThresholds.timeWindow)}`;
    
    const count = this.errorCounts.get(key) || 0;
    this.errorCounts.set(key, count + 1);
    
    // 检查是否需要告警
    this.checkAlert(level, count + 1);
  }
  
  // 检查告警条件
  checkAlert(level, count) {
    const threshold = this.alertThresholds[level];
    if (threshold && count >= threshold) {
      this.sendAlert(level, count);
    }
  }
  
  // 发送告警
  sendAlert(level, count) {
    console.error(`🚨 告警: ${level}级别错误在5分钟内出现${count}次`);
    
    // 实际项目中可以：
    // - 发送邮件
    // - 发送短信
    // - 调用钉钉/企业微信接口
    // - 写入告警系统
  }
  
  // 清理过期数据
  cleanup() {
    const now = Date.now();
    const cutoff = now - this.alertThresholds.timeWindow * 2;
    
    for (const [key] of this.errorCounts) {
      const [, timestamp] = key.split('-');
      if (parseInt(timestamp) * this.alertThresholds.timeWindow < cutoff) {
        this.errorCounts.delete(key);
      }
    }
  }
}

// 集成到日志系统
const errorMonitor = new ErrorMonitor();

const monitoringLogger = winston.createLogger({
  transports: [
    new winston.transports.Console(),
    {
      log: (info, callback) => {
        // 记录到监控系统
        if (info.level === 'error' || info.level === 'warn') {
          errorMonitor.recordError(info.level, info.message);
        }
        callback();
      }
    }
  ]
});
```

### 8.3 性能监控日志


**记录关键性能指标**：

```javascript
// 性能监控中间件
const performanceLogger = (req, res, next) => {
  const start = process.hrtime.bigint();
  const startMemory = process.memoryUsage();
  
  res.on('finish', () => {
    const end = process.hrtime.bigint();
    const endMemory = process.memoryUsage();
    
    const responseTime = Number(end - start) / 1000000; // 转换为毫秒
    const memoryDiff = endMemory.heapUsed - startMemory.heapUsed;
    
    logger.info('性能指标', {
      category: 'performance',
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      responseTime: `${responseTime.toFixed(2)}ms`,
      memoryUsage: `${Math.round(memoryDiff / 1024 / 1024 * 100) / 100}MB`,
      userAgent: req.get('User-Agent'),
      ip: req.ip
    });
    
    // 慢请求告警
    if (responseTime > 1000) {
      logger.warn('慢请求检测', {
        url: req.url,
        responseTime: `${responseTime.toFixed(2)}ms`,
        threshold: '1000ms'
      });
    }
  });
  
  next();
};
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 错误分类：业务错误vs系统错误，不同处理策略
🔸 错误捕获：try/catch、Promise、回调函数错误处理
🔸 全局处理：Express中间件统一处理未捕获错误
🔸 自定义错误：创建专业的错误类和错误码系统
🔸 日志级别：DEBUG、INFO、WARN、ERROR的使用场景
🔸 日志工具：从console到Winston的进阶使用
🔸 生产实践：环境配置、监控告警、性能追踪
```

### 9.2 关键理解要点


**🔹 错误处理的本质**
```
预防 > 捕获 > 处理 > 恢复

就像开车：
- 预防：遵守交规，检查车况
- 捕获：刹车、转向避险  
- 处理：停车检查，呼叫救援
- 恢复：修理后继续行驶
```

**🔹 日志记录的价值**
```
日志 = 程序的"医疗记录"

记录内容：
- 症状：出现了什么问题
- 诊断：错误的具体原因
- 治疗：采取了什么措施
- 效果：问题是否解决
```

**🔹 生产环境的要求**
```
开发环境：详细调试，快速定位
测试环境：验证逻辑，模拟异常  
生产环境：稳定可靠，性能优先

三个环境的平衡：
可读性 ← → 性能
详细度 ← → 安全性
```

### 9.3 实际应用价值


**🎯 对新手开发者的建议**
- **从简单开始**：先用好try/catch和console，再学习高级工具
- **养成习惯**：在关键位置主动添加错误处理和日志
- **区分场景**：开发调试vs生产运行需要不同策略
- **持续优化**：根据实际问题不断完善错误处理机制

**🔧 实际项目应用**
- **API开发**：统一错误响应格式，记录请求日志
- **数据处理**：处理文件读写、数据库操作的异常
- **第三方集成**：网络请求、支付接口的错误重试
- **性能优化**：通过日志分析找出性能瓶颈

**核心记忆口诀**：
- 错误分两类，业务和系统要区分
- try catch包一层，异步错误别忘记  
- 日志有层级，开发生产策略异
- 监控加告警，问题发现要及时