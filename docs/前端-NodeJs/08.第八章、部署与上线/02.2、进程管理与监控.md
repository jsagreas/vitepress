---
title: 2、进程管理与监控
---
## 📚 目录

1. [进程管理基础概念](#1-进程管理基础概念)
2. [PM2 进程管理器详解](#2-PM2-进程管理器详解)
3. [集群模式与负载均衡](#3-集群模式与负载均衡)
4. [进程监控与故障处理](#4-进程监控与故障处理)
5. [零停机部署实现](#5-零停机部署实现)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🎯 进程管理基础概念


### 1.1 为什么需要进程管理


**传统运行方式的问题**
```bash
# 直接运行 Node.js 应用
node app.js

问题：
❌ 程序崩溃后无法自动重启
❌ 退出终端后程序就停止了
❌ 无法充分利用多核CPU
❌ 难以监控程序运行状态
❌ 无法实现负载均衡
```

**进程管理器解决的问题**
```
✅ 自动重启：程序崩溃后自动恢复
✅ 后台运行：脱离终端独立运行
✅ 多进程：充分利用服务器资源
✅ 监控功能：实时查看运行状态
✅ 负载均衡：多进程间分担请求
✅ 日志管理：统一收集和管理日志
```

### 1.2 进程管理的核心概念


**什么是进程守护**
```
简单理解：就像给程序配了个"保姆"

保姆的职责：
- 看护程序正常运行
- 程序"生病"(崩溃)时重新启动
- 记录程序的"成长日记"(日志)
- 在程序忙不过来时叫帮手(多进程)
```

**什么是集群模式**
```
生活例子：餐厅服务

单进程 = 一个服务员：
顾客多了就忙不过来，服务员累倒就没人服务了

集群模式 = 多个服务员：
多人分担工作，一人请假还有其他人顶上
```

---

## 2. 🚀 PM2 进程管理器详解


### 2.1 PM2 简介与安装


**PM2 是什么**
```
PM2 = Process Manager 2
一个专业的 Node.js 进程管理器

就像：
- Windows 的任务管理器
- 但专门为 Node.js 应用设计
- 功能更强大、更智能
```

**安装 PM2**
```bash
# 全局安装 PM2
npm install -g pm2

# 验证安装
pm2 --version
```

### 2.2 PM2 基本命令操作


**启动应用**
```bash
# 最简单的启动方式
pm2 start app.js

# 指定应用名称
pm2 start app.js --name "my-app"

# 集群模式启动（利用所有CPU核心）
pm2 start app.js -i max

# 启动时设置环境变量
pm2 start app.js --env production
```

**管理应用**
```bash
# 查看所有应用状态
pm2 list

# 停止应用
pm2 stop my-app        # 按名称停止
pm2 stop 0             # 按ID停止
pm2 stop all           # 停止所有

# 重启应用
pm2 restart my-app     # 重启指定应用
pm2 restart all        # 重启所有应用

# 重新加载（0停机时间）
pm2 reload my-app

# 删除应用
pm2 delete my-app      # 删除指定应用
pm2 delete all         # 删除所有应用
```

**实用命令**
```bash
# 查看实时日志
pm2 logs                # 所有应用日志
pm2 logs my-app         # 指定应用日志

# 查看详细信息
pm2 show my-app

# 监控面板
pm2 monit

# 保存当前应用列表
pm2 save

# 开机自启动
pm2 startup
```

### 2.3 PM2 配置文件详解


**创建配置文件**
```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    // 基本配置
    name: 'my-app',                    // 应用名称
    script: './app.js',                // 启动脚本
    
    // 运行环境
    instances: 'max',                  // 进程数量 (max=CPU核心数)
    exec_mode: 'cluster',              // 运行模式
    
    // 自动重启配置
    watch: false,                      // 监听文件变化自动重启
    ignore_watch: ['node_modules'],    // 忽略监听的文件夹
    
    // 内存和重启策略
    max_memory_restart: '300M',        // 内存超过300M自动重启
    min_uptime: '10s',                 // 最小运行时间
    max_restarts: 10,                  // 最大重启次数
    
    // 环境变量
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 8080
    },
    
    // 日志配置
    log_file: './logs/combined.log',   // 合并日志
    out_file: './logs/out.log',        // 标准输出日志
    error_file: './logs/error.log',    // 错误日志
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
    
    // 其他配置
    time: true,                        // 日志显示时间
    autorestart: true,                 // 自动重启
    merge_logs: true                   // 合并集群日志
  }]
}
```

**使用配置文件**
```bash
# 使用配置文件启动
pm2 start ecosystem.config.js

# 指定环境启动
pm2 start ecosystem.config.js --env production

# 重新加载配置
pm2 reload ecosystem.config.js
```

---

## 3. ⚖️ 集群模式与负载均衡


### 3.1 单进程 vs 多进程对比


**单进程模式问题**
```
服务器配置：4核CPU
单进程运行：只用了25%的CPU资源

问题分析：
┌─────────────────────────────────┐
│ CPU核心1: ████████████ (100%)   │ ← Node.js进程运行在这里
│ CPU核心2: ░░░░░░░░░░░░ (0%)     │ ← 闲置
│ CPU核心3: ░░░░░░░░░░░░ (0%)     │ ← 闲置  
│ CPU核心4: ░░░░░░░░░░░░ (0%)     │ ← 闲置
└─────────────────────────────────┘

结果：资源浪费，性能受限
```

**集群模式优势**
```
多进程充分利用CPU资源：

┌─────────────────────────────────┐
│ CPU核心1: ████████████ (100%)   │ ← Worker进程1
│ CPU核心2: ████████████ (100%)   │ ← Worker进程2
│ CPU核心3: ████████████ (100%)   │ ← Worker进程3
│ CPU核心4: ████████████ (100%)   │ ← Worker进程4
└─────────────────────────────────┘

结果：性能提升3-4倍
```

### 3.2 cluster 模块基础


**Node.js 内置集群**
```javascript
// cluster-demo.js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`主进程 ${process.pid} 正在运行`);
  
  // 创建工作进程
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // 监听进程退出
  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
    // 自动重启
    cluster.fork();
  });
  
} else {
  // 工作进程创建HTTP服务器
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Hello from worker ${process.pid}\n`);
  }).listen(8000);
  
  console.log(`工作进程 ${process.pid} 已启动`);
}
```

**集群架构图解**
```
                    负载均衡器
                        │
            ┌───────────┼───────────┐
            │           │           │
        Worker1     Worker2     Worker3
        (PID:123)   (PID:124)   (PID:125)
            │           │           │
        处理请求1   处理请求2   处理请求3

主进程(Master)职责：
- 管理所有工作进程
- 分发客户端请求
- 监控进程健康状态
- 自动重启崩溃进程
```

### 3.3 PM2 集群配置


**简单集群启动**
```bash
# 启动4个进程实例
pm2 start app.js -i 4

# 根据CPU核心数自动创建进程
pm2 start app.js -i max

# 查看集群状态
pm2 list
```

**高级集群配置**
```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'web-cluster',
    script: './app.js',
    instances: 'max',              // 进程数 = CPU核心数
    exec_mode: 'cluster',          // 集群模式
    
    // 集群特定配置
    instance_var: 'INSTANCE_ID',   // 实例ID环境变量
    merge_logs: true,              // 合并日志输出
    
    // 负载均衡策略
    listen_timeout: 3000,          // 监听超时时间
    kill_timeout: 5000,            // 强制杀死超时时间
    
    // 集群重启配置
    wait_ready: true,              // 等待ready信号
    max_restarts: 3,               // 最大重启次数
    restart_delay: 1000            // 重启延迟时间
  }]
}
```

---

## 4. 📊 进程监控与故障处理


### 4.1 实时监控功能


**PM2 监控面板**
```bash
# 启动监控面板
pm2 monit

显示内容：
┌─────────────────────────────────────┐
│ Process Name    │ Status │ CPU │ Mem │
├─────────────────┼────────┼─────┼─────┤
│ my-app-0        │ online │ 15% │ 45M │
│ my-app-1        │ online │ 18% │ 42M │
│ my-app-2        │ online │ 12% │ 48M │
│ my-app-3        │ online │ 20% │ 44M │
└─────────────────────────────────────┘

实时信息：
- CPU使用率
- 内存使用量
- 进程状态
- 重启次数
```

**Web监控面板**
```bash
# 启动Web监控 (需要注册PM2账户)
pm2 web

# 或使用第三方监控
pm2 install pm2-server-monit
```

### 4.2 内存监控与自动重启


**内存泄漏检测**
```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'my-app',
    script: './app.js',
    
    // 内存监控配置
    max_memory_restart: '200M',    // 超过200M自动重启
    min_uptime: '30s',             // 最小运行30秒
    max_restarts: 5,               // 1分钟内最多重启5次
    
    // 健康检查
    health_check_grace_period: 3000,  // 健康检查宽限期
    wait_ready: true,                 // 等待应用就绪信号
    listen_timeout: 8000              // 监听超时
  }]
}
```

**应用中发送就绪信号**
```javascript
// app.js
const app = require('express')();

app.listen(3000, () => {
  console.log('服务器启动成功');
  
  // 发送就绪信号给PM2
  if (process.send) {
    process.send('ready');
  }
});

// 优雅关闭处理
process.on('SIGINT', () => {
  console.log('正在优雅关闭服务器...');
  // 执行清理工作
  process.exit(0);
});
```

### 4.3 进程崩溃处理策略


**异常捕获和报告**
```javascript
// 全局异常处理
process.on('uncaughtException', (error) => {
  console.error('未捕获异常:', error);
  
  // 记录错误日志
  console.error('进程即将退出，错误原因:', error.message);
  
  // 优雅退出
  process.exit(1);
});

// Promise 异常处理
process.on('unhandledRejection', (reason, promise) => {
  console.error('未处理的Promise拒绝:', reason);
  console.error('在Promise:', promise);
});
```

**重启策略配置**
```javascript
// 智能重启配置
module.exports = {
  apps: [{
    name: 'stable-app',
    script: './app.js',
    
    // 重启策略
    autorestart: true,             // 启用自动重启
    max_restarts: 10,              // 最大重启次数
    restart_delay: 1000,           // 重启延迟1秒
    
    // 异常重启条件
    min_uptime: '10s',             // 运行超过10秒才算成功启动
    exponential_backoff_restart_delay: 100,  // 指数回退延迟
    
    // 重启时机
    cron_restart: '0 2 * * *',     // 每天凌晨2点重启
    watch: false,                  // 不监听文件变化
    ignore_watch: ['node_modules', 'logs']
  }]
}
```

---

## 5. 🔄 零停机部署实现


### 5.1 什么是零停机部署


**传统部署问题**
```
传统部署流程：
1. 停止服务器        ← 用户无法访问
2. 更新代码         ← 用户无法访问  
3. 启动服务器        ← 用户无法访问
4. 服务恢复正常      ← 可能几分钟后

问题：服务中断，用户体验差
```

**零停机部署原理**
```
零停机部署流程：
1. 新进程启动                    ← 旧进程继续服务
2. 新进程就绪后接管请求           ← 平滑切换
3. 旧进程停止处理新请求           ← 完成现有请求后退出
4. 旧进程优雅关闭                ← 无服务中断

优势：用户感受不到更新过程
```

### 5.2 PM2 reload 实现零停机


**reload vs restart 区别**
```bash
# restart：先停止再启动（有停机时间）
pm2 restart my-app

# reload：滚动更新（零停机时间）
pm2 reload my-app
```

**reload 工作原理**
```
集群滚动更新过程：

时间点1：
Worker1 ████ (处理请求)
Worker2 ████ (处理请求) 
Worker3 ████ (处理请求)
Worker4 ████ (处理请求)

时间点2：启动新的Worker1
Worker1 ████ (旧版本，仍处理请求)
Worker1-new ████ (新版本，准备就绪)
Worker2 ████ (处理请求)
Worker3 ████ (处理请求) 
Worker4 ████ (处理请求)

时间点3：新Worker1接管，旧Worker1退出
Worker1-new ████ (处理请求)
Worker2 ████ (旧版本)
Worker2-new ████ (新版本，准备中)
Worker3 ████ (处理请求)
Worker4 ████ (处理请求)

...逐个更新所有Worker
```

### 5.3 优雅关闭实现


**应用层优雅关闭**
```javascript
// app.js
const express = require('express');
const app = express();

let server;
let isShuttingDown = false;

// 启动服务器
server = app.listen(3000, () => {
  console.log('服务器启动在端口 3000');
  
  // 通知PM2应用已就绪
  if (process.send) {
    process.send('ready');
  }
});

// 处理关闭信号
process.on('SIGINT', gracefulShutdown);
process.on('SIGTERM', gracefulShutdown);

function gracefulShutdown(signal) {
  console.log(`收到 ${signal} 信号，开始优雅关闭...`);
  
  isShuttingDown = true;
  
  // 停止接受新连接
  server.close((err) => {
    if (err) {
      console.error('关闭服务器时发生错误:', err);
      process.exit(1);
    }
    
    console.log('服务器已优雅关闭');
    process.exit(0);
  });
  
  // 设置强制退出超时
  setTimeout(() => {
    console.error('强制退出服务器');
    process.exit(1);
  }, 30000); // 30秒超时
}

// 中间件：检查是否正在关闭
app.use((req, res, next) => {
  if (isShuttingDown) {
    res.status(503).send('服务器正在维护，请稍后重试');
    return;
  }
  next();
});
```

**部署脚本示例**
```bash
#!/bin/bash
# deploy.sh

echo "开始部署应用..."

# 拉取最新代码
git pull origin main

# 安装依赖
npm install --production

# 零停机重启
pm2 reload ecosystem.config.js

echo "部署完成！"
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 进程管理本质：给Node.js应用配个"保姆"，自动看护和重启
🔸 PM2核心功能：进程守护、集群模式、监控管理、日志收集
🔸 集群模式意义：充分利用多核CPU，提升应用性能和可靠性
🔸 零停机部署：滚动更新，用户无感知的版本升级
🔸 监控的重要性：及时发现问题，预防服务中断
```

### 6.2 关键实践要点


**🔹 PM2 使用最佳实践**
```
日常开发：
- 开发环境用 nodemon，生产环境用 PM2
- 始终使用配置文件管理应用
- 合理设置内存限制和重启策略

生产部署：
- 使用集群模式充分利用CPU
- 配置日志轮转避免日志文件过大
- 设置开机自启和定时重启
```

**🔹 故障预防策略**
```
代码层面：
- 全局异常捕获和处理
- 实现优雅关闭逻辑
- 避免内存泄漏

配置层面：
- 合理的重启次数限制
- 适当的内存阈值设置
- 监控告警机制
```

**🔹 性能优化建议**
```
进程数量：
- 通常设为CPU核心数
- CPU密集型应用可以少一些
- I/O密集型可以多一些

内存管理：
- 监控内存使用趋势
- 设置合理的重启阈值
- 定期分析内存泄漏
```

### 6.3 常见问题解决


| 问题场景 | 原因分析 | 解决方案 |
|---------|---------|---------|
| **应用频繁重启** | `内存泄漏或异常过多` | `检查代码，修复内存泄漏，完善异常处理` |
| **集群模式不生效** | `配置错误或应用不兼容` | `检查配置文件，确保应用支持集群` |
| **零停机失败** | `应用没有优雅关闭逻辑` | `实现SIGTERM信号处理` |
| **监控数据异常** | `PM2版本或配置问题` | `更新PM2版本，检查配置` |

### 6.4 学习路径建议


**基础阶段（1周）**
```
1. 理解进程管理概念
2. 掌握PM2基本命令
3. 学会编写配置文件
4. 实践启动停止重启操作
```

**进阶阶段（1-2周）**
```
1. 深入集群模式配置
2. 掌握监控和日志管理
3. 实现优雅关闭逻辑
4. 练习零停机部署
```

**生产阶段（持续实践）**
```
1. 制定监控告警策略
2. 优化性能配置参数
3. 建立故障处理流程
4. 自动化部署脚本
```

**核心记忆要点**：
- PM2是Node.js的专业"保姆"，负责进程看护和管理
- 集群模式让单核变多核，性能成倍提升
- reload实现零停机，用户无感知更新
- 监控预警很重要，及时发现解决问题
- 优雅关闭保体验，异常处理防崩溃