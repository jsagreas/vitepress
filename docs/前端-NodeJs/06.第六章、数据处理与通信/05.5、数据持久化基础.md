---
title: 5、数据持久化基础
---
## 📚 目录

1. [数据持久化概念理解](#1-数据持久化概念理解)
2. [JSON文件存储数据](#2-JSON文件存储数据)
3. [文件读写的并发处理](#3-文件读写的并发处理)
4. [内存数据存储](#4-内存数据存储)
5. [数据库连接基础](#5-数据库连接基础)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 💾 数据持久化概念理解


### 1.1 什么是数据持久化


> 💡 **通俗理解**：数据持久化就是把程序运行时的数据保存起来，即使程序关闭、电脑重启，数据也不会丢失。

**日常生活类比**：
```
就像你写日记一样：
- 不写在纸上 → 只记在脑子里，可能忘记（内存数据）
- 写在日记本 → 随时可以翻看，不会丢失（持久化数据）

程序也是一样：
- 变量存储 → 程序关闭就没了
- 文件/数据库 → 永久保存，随时读取
```

### 1.2 为什么需要数据持久化


**🔸 核心需求**
```
用户数据保存：
- 用户注册信息
- 用户操作记录
- 用户个人设置

业务数据管理：
- 商品信息
- 订单记录
- 日志信息

程序状态保持：
- 应用配置
- 缓存数据
- 临时文件
```

### 1.3 常见的持久化方式


```
轻量级存储：
├── JSON文件 → 简单数据，开发测试
├── 文本文件 → 日志记录，配置信息
└── 内存缓存 → 临时数据，快速访问

专业级存储：
├── 关系型数据库 → MySQL、PostgreSQL
├── 文档数据库 → MongoDB
└── 键值数据库 → Redis
```

---

## 2. 📄 JSON文件存储数据


### 2.1 JSON存储的优缺点


> 💡 **适用场景**：小项目、配置数据、开发测试阶段

**✅ 优势**：
- 无需安装数据库，开箱即用
- 格式简单，人类可读
- 与JavaScript天然兼容
- 适合小规模数据

**❌ 限制**：
- 不适合大量数据
- 没有查询功能
- 并发写入容易出错
- 数据结构相对简单

### 2.2 基础的JSON数据操作


**🔸 读取JSON数据**
```javascript
const fs = require('fs').promises;

// 读取用户数据
async function loadUsers() {
    try {
        const data = await fs.readFile('users.json', 'utf8');
        return JSON.parse(data);
    } catch (error) {
        // 文件不存在时返回空数组
        if (error.code === 'ENOENT') {
            return [];
        }
        throw error;
    }
}

// 使用示例
loadUsers().then(users => {
    console.log('用户列表：', users);
});
```

**🔸 保存JSON数据**
```javascript
// 保存用户数据
async function saveUsers(users) {
    try {
        const jsonData = JSON.stringify(users, null, 2); // 格式化输出
        await fs.writeFile('users.json', jsonData, 'utf8');
        console.log('用户数据保存成功');
    } catch (error) {
        console.error('保存失败：', error.message);
    }
}

// 添加新用户
async function addUser(newUser) {
    const users = await loadUsers();
    users.push({
        id: Date.now(), // 简单的ID生成
        ...newUser,
        createdAt: new Date().toISOString()
    });
    await saveUsers(users);
}
```

### 2.3 简单数据结构设计


**🔸 用户管理示例**
```javascript
// users.json 文件结构
[
    {
        "id": 1691234567890,
        "username": "张三",
        "email": "zhangsan@example.com",
        "age": 25,
        "createdAt": "2024-08-03T06:30:00.000Z"
    },
    {
        "id": 1691234567891,
        "username": "李四",
        "email": "lisi@example.com", 
        "age": 28,
        "createdAt": "2024-08-03T06:31:00.000Z"
    }
]
```

**🔸 完整的数据管理类**
```javascript
class JsonDataStore {
    constructor(filename) {
        this.filename = filename;
    }

    // 读取所有数据
    async load() {
        try {
            const data = await fs.readFile(this.filename, 'utf8');
            return JSON.parse(data);
        } catch (error) {
            return []; // 文件不存在返回空数组
        }
    }

    // 保存数据
    async save(data) {
        const jsonData = JSON.stringify(data, null, 2);
        await fs.writeFile(this.filename, jsonData, 'utf8');
    }

    // 添加记录
    async add(item) {
        const data = await this.load();
        item.id = Date.now(); // 自动生成ID
        data.push(item);
        await this.save(data);
        return item;
    }

    // 查找记录
    async find(condition) {
        const data = await this.load();
        return data.filter(item => {
            return Object.keys(condition).every(key => 
                item[key] === condition[key]
            );
        });
    }
}

// 使用示例
const userStore = new JsonDataStore('users.json');

// 添加用户
userStore.add({
    username: '王五',
    email: 'wangwu@example.com',
    age: 30
});

// 查找用户
userStore.find({ age: 25 }).then(users => {
    console.log('25岁的用户：', users);
});
```

---

## 3. 🔄 文件读写的并发处理


### 3.1 并发问题的理解


> ⚠️ **问题描述**：多个操作同时读写同一个文件时，可能导致数据丢失或文件损坏

**🔸 问题示例**：
```
用户A：读取文件 → 添加数据 → 保存文件
用户B：读取文件 → 添加数据 → 保存文件

如果同时进行：
1. A读取：[{id:1, name:'张三'}]
2. B读取：[{id:1, name:'张三'}] (同样的数据)
3. A添加：[{id:1, name:'张三'}, {id:2, name:'李四'}]
4. B添加：[{id:1, name:'张三'}, {id:3, name:'王五'}]
5. A保存：李四被保存
6. B保存：覆盖A的结果，李四丢失！
```

### 3.2 简单的锁机制


```javascript
class SafeJsonStore {
    constructor(filename) {
        this.filename = filename;
        this.isWriting = false; // 写入锁
        this.writeQueue = []; // 等待队列
    }

    // 安全的写入方法
    async safeWrite(data) {
        return new Promise((resolve, reject) => {
            // 添加到等待队列
            this.writeQueue.push({ data, resolve, reject });
            // 尝试处理队列
            this.processQueue();
        });
    }

    async processQueue() {
        // 如果正在写入，等待
        if (this.isWriting || this.writeQueue.length === 0) {
            return;
        }

        this.isWriting = true;
        const { data, resolve, reject } = this.writeQueue.shift();

        try {
            const jsonData = JSON.stringify(data, null, 2);
            await fs.writeFile(this.filename, jsonData, 'utf8');
            resolve();
        } catch (error) {
            reject(error);
        } finally {
            this.isWriting = false;
            // 处理下一个
            setTimeout(() => this.processQueue(), 0);
        }
    }

    async add(item) {
        const data = await this.load();
        item.id = Date.now();
        data.push(item);
        await this.safeWrite(data);
        return item;
    }
}
```

### 3.3 更好的解决方案


> 💡 **实际建议**：对于简单项目，使用数据库；对于复杂项目，考虑专业的消息队列

```javascript
// 使用 node-cache 进行内存缓存
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 }); // 10分钟过期

class CachedJsonStore {
    constructor(filename) {
        this.filename = filename;
        this.cacheKey = `data_${filename}`;
    }

    async load() {
        // 先从缓存读取
        let data = cache.get(this.cacheKey);
        if (data) {
            return data;
        }

        // 缓存没有，从文件读取
        try {
            const fileData = await fs.readFile(this.filename, 'utf8');
            data = JSON.parse(fileData);
            cache.set(this.cacheKey, data); // 存入缓存
            return data;
        } catch (error) {
            return [];
        }
    }

    async save(data) {
        await fs.writeFile(this.filename, JSON.stringify(data, null, 2), 'utf8');
        cache.set(this.cacheKey, data); // 更新缓存
    }
}
```

---

## 4. 🧠 内存数据存储


### 4.1 内存存储的特点


> 💡 **核心理解**：内存存储就是把数据保存在程序运行内存中，读写速度极快，但程序重启就丢失

**🔸 适用场景**：
```
临时数据缓存：
- 用户登录状态
- 计算结果缓存
- 频繁访问的数据

会话管理：
- 用户在线状态
- 购物车数据
- 临时表单数据

实时数据：
- 聊天消息
- 实时通知
- 游戏状态
```

### 4.2 简单的内存存储实现


```javascript
class MemoryStore {
    constructor() {
        this.data = new Map(); // 使用Map存储数据
    }

    // 设置数据
    set(key, value, ttl = null) {
        const item = {
            value: value,
            expires: ttl ? Date.now() + ttl * 1000 : null
        };
        this.data.set(key, item);
    }

    // 获取数据
    get(key) {
        const item = this.data.get(key);
        if (!item) return null;

        // 检查是否过期
        if (item.expires && Date.now() > item.expires) {
            this.data.delete(key);
            return null;
        }

        return item.value;
    }

    // 删除数据
    delete(key) {
        return this.data.delete(key);
    }

    // 清理过期数据
    cleanup() {
        const now = Date.now();
        for (const [key, item] of this.data) {
            if (item.expires && now > item.expires) {
                this.data.delete(key);
            }
        }
    }
}

// 使用示例
const cache = new MemoryStore();

// 存储用户登录状态（5分钟过期）
cache.set('user_123_login', { userId: 123, loginTime: new Date() }, 300);

// 获取用户状态
const loginStatus = cache.get('user_123_login');
console.log('用户登录状态：', loginStatus);
```

### 4.3 高级内存管理


```javascript
class AdvancedMemoryStore {
    constructor(maxSize = 1000) {
        this.data = new Map();
        this.maxSize = maxSize;
        this.accessOrder = []; // 记录访问顺序
    }

    set(key, value, ttl = null) {
        // 如果达到最大容量，删除最少使用的
        if (this.data.size >= this.maxSize && !this.data.has(key)) {
            const oldestKey = this.accessOrder.shift();
            this.data.delete(oldestKey);
        }

        const item = {
            value: value,
            expires: ttl ? Date.now() + ttl * 1000 : null,
            accessCount: 0
        };

        this.data.set(key, item);
        this.updateAccessOrder(key);
    }

    get(key) {
        const item = this.data.get(key);
        if (!item) return null;

        // 检查过期
        if (item.expires && Date.now() > item.expires) {
            this.data.delete(key);
            this.removeFromAccessOrder(key);
            return null;
        }

        // 更新访问记录
        item.accessCount++;
        this.updateAccessOrder(key);
        return item.value;
    }

    updateAccessOrder(key) {
        // 移除旧的位置
        this.removeFromAccessOrder(key);
        // 添加到末尾（最新访问）
        this.accessOrder.push(key);
    }

    removeFromAccessOrder(key) {
        const index = this.accessOrder.indexOf(key);
        if (index > -1) {
            this.accessOrder.splice(index, 1);
        }
    }

    // 获取内存使用情况
    getStats() {
        return {
            size: this.data.size,
            maxSize: this.maxSize,
            usage: `${(this.data.size / this.maxSize * 100).toFixed(1)}%`
        };
    }
}
```

---

## 5. 🗄️ 数据库连接基础


### 5.1 数据库基础概念


> 💡 **简单理解**：数据库就是专门存储和管理数据的软件，比文件存储更强大、更安全

**🔸 数据库 vs 文件存储**：
```
文件存储：
- 像存放在文件夹里的Excel表格
- 简单直接，但功能有限
- 适合小量数据

数据库：
- 像专业的图书馆管理系统
- 功能强大，支持复杂查询
- 适合大量数据和复杂应用
```

### 5.2 MongoDB连接示例


> 💡 **MongoDB特点**：文档数据库，存储JSON格式数据，与JavaScript配合很好

```javascript
// 1. 安装 MongoDB 驱动
// npm install mongodb

const { MongoClient } = require('mongodb');

class MongoDBStore {
    constructor() {
        this.client = null;
        this.db = null;
        this.url = 'mongodb://localhost:27017'; // 本地MongoDB地址
        this.dbName = 'myapp'; // 数据库名称
    }

    // 连接数据库
    async connect() {
        try {
            this.client = new MongoClient(this.url);
            await this.client.connect();
            this.db = this.client.db(this.dbName);
            console.log('✅ MongoDB 连接成功');
        } catch (error) {
            console.error('❌ MongoDB 连接失败：', error.message);
        }
    }

    // 添加用户
    async addUser(user) {
        const collection = this.db.collection('users');
        const result = await collection.insertOne({
            ...user,
            createdAt: new Date()
        });
        return result.insertedId;
    }

    // 查找用户
    async findUsers(query = {}) {
        const collection = this.db.collection('users');
        return await collection.find(query).toArray();
    }

    // 关闭连接
    async close() {
        if (this.client) {
            await this.client.close();
            console.log('MongoDB 连接已关闭');
        }
    }
}

// 使用示例
async function mongoExample() {
    const store = new MongoDBStore();
    await store.connect();
    
    // 添加用户
    const userId = await store.addUser({
        username: '张三',
        email: 'zhangsan@example.com',
        age: 25
    });
    
    // 查找用户
    const users = await store.findUsers({ age: { $gte: 18 } }); // 查找年龄>=18的用户
    console.log('成年用户：', users);
    
    await store.close();
}
```

### 5.3 MySQL连接示例


> 💡 **MySQL特点**：关系型数据库，使用表格结构存储数据，需要预先设计表结构

```javascript
// 1. 安装 MySQL 驱动
// npm install mysql2

const mysql = require('mysql2/promise');

class MySQLStore {
    constructor() {
        this.connection = null;
        this.config = {
            host: 'localhost',
            user: 'root',
            password: 'your_password',
            database: 'myapp'
        };
    }

    // 连接数据库
    async connect() {
        try {
            this.connection = await mysql.createConnection(this.config);
            console.log('✅ MySQL 连接成功');
            
            // 创建用户表（如果不存在）
            await this.createUserTable();
        } catch (error) {
            console.error('❌ MySQL 连接失败：', error.message);
        }
    }

    // 创建用户表
    async createUserTable() {
        const sql = `
            CREATE TABLE IF NOT EXISTS users (
                id INT AUTO_INCREMENT PRIMARY KEY,
                username VARCHAR(50) NOT NULL,
                email VARCHAR(100) UNIQUE NOT NULL,
                age INT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `;
        await this.connection.execute(sql);
    }

    // 添加用户
    async addUser(user) {
        const sql = 'INSERT INTO users (username, email, age) VALUES (?, ?, ?)';
        const [result] = await this.connection.execute(sql, [
            user.username,
            user.email,
            user.age
        ]);
        return result.insertId;
    }

    // 查找用户
    async findUsers(condition = '') {
        let sql = 'SELECT * FROM users';
        if (condition) {
            sql += ` WHERE ${condition}`;
        }
        const [rows] = await this.connection.execute(sql);
        return rows;
    }

    // 关闭连接
    async close() {
        if (this.connection) {
            await this.connection.end();
            console.log('MySQL 连接已关闭');
        }
    }
}

// 使用示例
async function mysqlExample() {
    const store = new MySQLStore();
    await store.connect();
    
    // 添加用户
    const userId = await store.addUser({
        username: '李四',
        email: 'lisi@example.com',
        age: 28
    });
    
    // 查找成年用户
    const adults = await store.findUsers('age >= 18');
    console.log('成年用户：', adults);
    
    await store.close();
}
```

### 5.4 ORM/ODM工具简介


> 💡 **ORM/ODM理解**：让你用JavaScript对象的方式操作数据库，不用写复杂的SQL语句

**🔸 主要工具**：
```
Mongoose (MongoDB)：
- 为MongoDB提供对象建模
- 定义数据结构和验证规则
- 提供简单的API操作

Sequelize (MySQL/PostgreSQL)：
- 关系型数据库的ORM工具
- 自动生成SQL语句
- 支持数据关联和迁移

Prisma (现代化选择)：
- 类型安全的数据库工具
- 自动生成客户端代码
- 支持多种数据库
```

**🔸 Mongoose简单示例**：
```javascript
// npm install mongoose
const mongoose = require('mongoose');

// 定义用户模型
const UserSchema = new mongoose.Schema({
    username: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    age: { type: Number, min: 0 },
    createdAt: { type: Date, default: Date.now }
});

const User = mongoose.model('User', UserSchema);

// 连接数据库
mongoose.connect('mongodb://localhost:27017/myapp');

// 使用模型
async function ormExample() {
    // 创建用户
    const user = new User({
        username: '王五',
        email: 'wangwu@example.com',
        age: 30
    });
    await user.save();

    // 查找用户
    const adults = await User.find({ age: { $gte: 18 } });
    console.log('成年用户：', adults);
}
```

---

## 6. 🎯 实际应用场景


### 6.1 数据备份策略


> 💡 **备份重要性**：就像重要文件要备份一样，应用数据也需要定期备份

```javascript
class DataBackup {
    constructor(primaryStore, backupStore) {
        this.primary = primaryStore;
        this.backup = backupStore;
    }

    // 自动备份
    async autoBackup() {
        try {
            const data = await this.primary.load();
            await this.backup.save(data);
            console.log(`✅ 数据备份成功：${new Date().toLocaleString()}`);
        } catch (error) {
            console.error('❌ 备份失败：', error.message);
        }
    }

    // 定期备份（每小时一次）
    startAutoBackup() {
        setInterval(() => {
            this.autoBackup();
        }, 60 * 60 * 1000); // 1小时
    }

    // 恢复数据
    async restore() {
        try {
            const backupData = await this.backup.load();
            await this.primary.save(backupData);
            console.log('✅ 数据恢复成功');
        } catch (error) {
            console.error('❌ 恢复失败：', error.message);
        }
    }
}
```

### 6.2 数据迁移基础概念


> 💡 **数据迁移**：将数据从一种存储方式转移到另一种，比如从JSON文件迁移到数据库

```javascript
class DataMigration {
    // 从JSON迁移到MongoDB
    async migrateJsonToMongo(jsonFile, mongoCollection) {
        try {
            // 读取JSON数据
            const jsonData = await fs.readFile(jsonFile, 'utf8');
            const data = JSON.parse(jsonData);

            // 批量插入到MongoDB
            if (data.length > 0) {
                const result = await mongoCollection.insertMany(data);
                console.log(`✅ 迁移成功：${result.insertedCount} 条记录`);
            }
        } catch (error) {
            console.error('❌ 迁移失败：', error.message);
        }
    }

    // 数据格式转换
    transformData(oldData) {
        return oldData.map(item => ({
            ...item,
            // 添加新字段
            version: '2.0',
            updatedAt: new Date(),
            // 重命名字段
            fullName: item.username,
            // 删除不需要的字段
            // username: undefined
        }));
    }
}
```

### 6.3 选择合适的存储方案


**🔸 决策指南**：
```
项目规模小（<1000条记录）：
→ JSON文件存储
→ 开发简单，维护方便

项目规模中等（1000-10万条记录）：
→ SQLite数据库
→ 单文件数据库，无需服务器

项目规模大（>10万条记录）：
→ MongoDB / MySQL
→ 专业数据库，性能可靠

实时性要求高：
→ Redis + 数据库
→ 内存缓存 + 持久化存储

多用户并发：
→ 专业数据库 + 连接池
→ 避免文件锁问题
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的概念


```
🔸 数据持久化：让数据在程序重启后仍然存在
🔸 JSON存储：适合小项目和简单数据的轻量级方案
🔸 并发问题：多个操作同时读写可能导致数据丢失
🔸 内存存储：速度快但重启丢失，适合临时数据
🔸 数据库：专业的数据管理方案，功能强大
```

### 7.2 关键理解要点


**🔹 存储方式选择**：
```
数据量决定方案：
- 少量数据 → JSON文件
- 中等数据 → SQLite
- 大量数据 → MongoDB/MySQL

使用场景决定技术：
- 配置数据 → JSON文件
- 用户数据 → 数据库
- 临时数据 → 内存存储
- 缓存数据 → Redis
```

**🔹 并发安全**：
```
问题识别：
- 多个用户同时操作
- 数据读写时间差
- 最后写入覆盖前面的

解决思路：
- 使用锁机制
- 队列处理写入
- 选择专业数据库
```

### 7.3 实际应用建议


**✅ 最佳实践**：
- 小项目先用JSON，后期可迁移到数据库
- 重要数据必须备份
- 选择合适的存储方案，不要过度设计
- 学会使用ORM工具简化开发

**⚠️ 常见误区**：
- 不要在所有情况下都使用数据库
- 不要忽视数据备份的重要性
- 不要在高并发场景使用文件存储
- 不要在内存中存储重要的持久化数据

**核心记忆**：
- 数据持久化是为了数据不丢失
- JSON适合小项目，数据库适合大项目
- 内存快但易丢失，文件慢但永久
- 选择存储方案要考虑数据量和并发量