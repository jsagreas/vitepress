---
title: 2、Promise 异步处理
---
## 📚 目录

1. [什么是Promise](#1-什么是Promise)
2. [Promise的三种状态](#2-Promise的三种状态)
3. [创建和使用Promise](#3-创建和使用Promise)
4. [Promise方法详解](#4-Promise方法详解)
5. [Promise链式调用](#5-Promise链式调用)
6. [Promise静态方法](#6-Promise静态方法)
7. [回调函数转Promise](#7-回调函数转Promise)
8. [实际应用场景](#8-实际应用场景)
9. [核心要点总结](#9-核心要点总结)

---

## 1. 🎯 什么是Promise


### 1.1 Promise解决的问题


**回调地狱问题**：
```javascript
// 传统回调写法 - 嵌套太深，难以维护
fs.readFile('file1.txt', (err, data1) => {
  if (err) throw err;
  fs.readFile('file2.txt', (err, data2) => {
    if (err) throw err;
    fs.readFile('file3.txt', (err, data3) => {
      if (err) throw err;
      console.log('所有文件读取完成');
    });
  });
});
```

**Promise的优雅解决**：
```javascript
// Promise写法 - 链式调用，逻辑清晰
readFilePromise('file1.txt')
  .then(() => readFilePromise('file2.txt'))
  .then(() => readFilePromise('file3.txt'))
  .then(() => console.log('所有文件读取完成'))
  .catch(err => console.error('出错了:', err));
```

### 1.2 Promise是什么


> **💡 简单理解**：Promise就像现实生活中的"承诺"
> - 我承诺明天给你一个结果
> - 这个结果要么是**成功的**（我做到了）
> - 要么是**失败的**（我没做到）
> - 现在还**不知道**结果（还在处理中）

**Promise定义**：
```
Promise是JavaScript中处理异步操作的一种方式
它代表一个异步操作的最终完成或失败
Promise让异步代码看起来更像同步代码
```

### 1.3 Promise的本质作用


**🔸 解决的核心问题**：
- ✅ **避免回调地狱** - 不再层层嵌套
- ✅ **错误处理统一** - 用catch统一处理错误
- ✅ **代码更易读** - 链式调用符合人的思维
- ✅ **更好的控制** - 明确的状态管理

---

## 2. 📊 Promise的三种状态


### 2.1 状态图示


```
Promise状态转换图：

    创建Promise
         |
    pending(等待中)
      /        \
fulfilled      rejected
(已成功)       (已失败)
     |            |
  调用then()   调用catch()
```

### 2.2 三种状态详解


| 状态 | 英文名 | 中文含义 | 说明 | 能否改变 |
|------|--------|----------|------|----------|
| **⏳ 等待中** | `pending` | 初始状态 | 异步操作还在进行中 | ✅ 可以变成其他状态 |
| **✅ 已成功** | `fulfilled` | 操作成功 | 异步操作成功完成 | ❌ 状态不可再改变 |
| **❌ 已失败** | `rejected` | 操作失败 | 异步操作失败了 | ❌ 状态不可再改变 |

### 2.3 状态转换示例


```javascript
// 创建一个Promise - 初始状态是pending
const promise = new Promise((resolve, reject) => {
  console.log('当前状态: pending');
  
  // 模拟异步操作
  setTimeout(() => {
    const success = Math.random() > 0.5;
    
    if (success) {
      resolve('操作成功!'); // 状态变为fulfilled
    } else {
      reject('操作失败!');  // 状态变为rejected
    }
  }, 1000);
});

// 状态改变后会触发对应的处理函数
promise
  .then(result => console.log('成功:', result))
  .catch(error => console.log('失败:', error));
```

---

## 3. 🔧 创建和使用Promise


### 3.1 创建Promise的基本语法


```javascript
const myPromise = new Promise((resolve, reject) => {
  // 执行异步操作
  // 成功时调用 resolve(结果)
  // 失败时调用 reject(错误)
});
```

### 3.2 创建Promise的完整示例


```javascript
// 示例：模拟网络请求
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    console.log(`开始获取用户${userId}的数据...`);
    
    // 模拟网络延迟
    setTimeout(() => {
      if (userId > 0) {
        // 成功情况
        const userData = {
          id: userId,
          name: '张三',
          email: 'zhangsan@example.com'
        };
        resolve(userData); // 调用resolve传递成功结果
      } else {
        // 失败情况
        reject(new Error('用户ID必须大于0')); // 调用reject传递错误
      }
    }, 1000);
  });
}

// 使用Promise
fetchUserData(123)
  .then(user => {
    console.log('获取用户成功:', user);
  })
  .catch(error => {
    console.log('获取用户失败:', error.message);
  });
```

### 3.3 理解resolve和reject


**🔸 resolve函数**：
- 作用：将Promise状态改为fulfilled
- 参数：成功的结果数据
- 触发：then()方法

**🔸 reject函数**：
- 作用：将Promise状态改为rejected  
- 参数：错误信息或Error对象
- 触发：catch()方法

---

## 4. 📋 Promise方法详解


### 4.1 then() - 处理成功结果


**基本语法**：
```javascript
promise.then(成功的回调函数, 失败的回调函数)
```

**常用写法**：
```javascript
// 只处理成功情况
promise.then(result => {
  console.log('成功:', result);
});

// 同时处理成功和失败
promise.then(
  result => console.log('成功:', result),
  error => console.log('失败:', error)
);
```

### 4.2 catch() - 处理错误


```javascript
promise.catch(error => {
  console.log('出错了:', error);
});

// catch()等价于then(null, errorCallback)
promise.then(null, error => {
  console.log('出错了:', error);
});
```

### 4.3 finally() - 最终处理


> **💡 理解finally**：无论成功还是失败都会执行

```javascript
fetchUserData(123)
  .then(user => console.log('用户:', user))
  .catch(error => console.log('错误:', error))
  .finally(() => {
    console.log('请求结束，清理资源');
    // 比如：隐藏loading图标、关闭连接等
  });
```

### 4.4 完整的错误处理示例


```javascript
function downloadFile(url) {
  return new Promise((resolve, reject) => {
    console.log('开始下载:', url);
    
    setTimeout(() => {
      if (url.includes('.pdf')) {
        resolve('文件下载成功');
      } else {
        reject(new Error('只支持PDF文件'));
      }
    }, 2000);
  });
}

downloadFile('document.pdf')
  .then(result => {
    console.log('✅', result);
    return '文件保存到本地';
  })
  .then(saveResult => {
    console.log('✅', saveResult);
  })
  .catch(error => {
    console.log('❌ 下载失败:', error.message);
  })
  .finally(() => {
    console.log('🔄 下载任务结束');
  });
```

---

## 5. 🔗 Promise链式调用


### 5.1 什么是链式调用


> **💡 简单理解**：就像工厂流水线，一个步骤完成后传递给下一个步骤

```javascript
// 链式调用的基本模式
promise
  .then(步骤1)
  .then(步骤2)
  .then(步骤3)
  .catch(处理所有错误);
```

### 5.2 链式调用的核心规则


**🔸 返回值传递规则**：
- `then()`中返回的值会传递给下一个`then()`
- 如果返回Promise，会等待该Promise完成
- 如果不返回值，下一个`then()`收到`undefined`

```javascript
function step1() {
  return new Promise(resolve => {
    setTimeout(() => resolve('步骤1完成'), 1000);
  });
}

function step2(data) {
  return new Promise(resolve => {
    setTimeout(() => resolve(data + ' -> 步骤2完成'), 1000);
  });
}

function step3(data) {
  return new Promise(resolve => {
    setTimeout(() => resolve(data + ' -> 步骤3完成'), 1000);
  });
}

// 链式调用示例
step1()
  .then(result1 => {
    console.log(result1); // "步骤1完成"
    return step2(result1);
  })
  .then(result2 => {
    console.log(result2); // "步骤1完成 -> 步骤2完成"
    return step3(result2);
  })
  .then(result3 => {
    console.log(result3); // "步骤1完成 -> 步骤2完成 -> 步骤3完成"
  })
  .catch(error => {
    console.log('任何一步出错都会到这里:', error);
  });
```

### 5.3 链式调用的最佳实践


**✅ 推荐写法**：
```javascript
// 清晰的链式调用
fetchUser(123)
  .then(user => validateUser(user))
  .then(validUser => saveToDatabase(validUser))
  .then(savedUser => sendEmail(savedUser))
  .then(() => console.log('用户处理完成'))
  .catch(error => console.log('处理失败:', error));
```

**❌ 避免的写法**：
```javascript
// 不要在then中嵌套Promise
fetchUser(123)
  .then(user => {
    validateUser(user)
      .then(validUser => {
        saveToDatabase(validUser)
          .then(savedUser => {
            // 这又变成回调地狱了!
          });
      });
  });
```

---

## 6. ⚡ Promise静态方法


### 6.1 Promise.all() - 并发处理


> **💡 理解all()**：所有Promise都成功才算成功，有一个失败就算失败

```javascript
// 模拟三个网络请求
const request1 = fetch('/api/user');
const request2 = fetch('/api/posts'); 
const request3 = fetch('/api/comments');

// 等待所有请求完成
Promise.all([request1, request2, request3])
  .then(results => {
    console.log('所有请求都成功了:', results);
    // results是一个数组，包含三个请求的结果
  })
  .catch(error => {
    console.log('有请求失败了:', error);
    // 只要有一个失败，就会执行这里
  });
```

**实际应用场景**：
```javascript
// 同时获取用户信息和权限信息
function getUserInfo(userId) {
  const userPromise = fetchUser(userId);
  const permissionPromise = fetchPermissions(userId);
  
  return Promise.all([userPromise, permissionPromise])
    .then(([user, permissions]) => {
      return { ...user, permissions };
    });
}
```

### 6.2 Promise.race() - 竞态处理


> **💡 理解race()**：谁先完成就用谁的结果，不管成功还是失败

```javascript
// 网络请求超时控制
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('请求超时')), timeout);
  });
  
  return Promise.race([fetchPromise, timeoutPromise]);
}

fetchWithTimeout('/api/data', 3000)
  .then(response => console.log('请求成功:', response))
  .catch(error => console.log('请求失败或超时:', error));
```

### 6.3 Promise.allSettled() - 获取所有结果


> **💡 理解allSettled()**：不管成功失败，等所有Promise完成，获取每个的结果

```javascript
const promises = [
  fetch('/api/user'),
  fetch('/api/posts'),
  fetch('/api/invalid-url') // 这个会失败
];

Promise.allSettled(promises)
  .then(results => {
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        console.log(`请求${index + 1}成功:`, result.value);
      } else {
        console.log(`请求${index + 1}失败:`, result.reason);
      }
    });
  });
```

### 6.4 Promise.any() - 任意成功


> **💡 理解any()**：只要有一个成功就算成功，全部失败才算失败

```javascript
// 尝试多个服务器，任意一个响应就行
const servers = [
  fetch('https://server1.com/api'),
  fetch('https://server2.com/api'),
  fetch('https://server3.com/api')
];

Promise.any(servers)
  .then(response => {
    console.log('有服务器响应了:', response);
  })
  .catch(error => {
    console.log('所有服务器都无响应:', error);
  });
```

### 6.5 Promise.resolve() 和 Promise.reject()


```javascript
// 创建立即成功的Promise
const successPromise = Promise.resolve('立即成功');
successPromise.then(result => console.log(result)); // "立即成功"

// 创建立即失败的Promise
const failPromise = Promise.reject(new Error('立即失败'));
failPromise.catch(error => console.log(error.message)); // "立即失败"

// 实际应用：统一返回Promise
function getData(useCache = false) {
  if (useCache) {
    return Promise.resolve(缓存数据); // 立即返回缓存
  } else {
    return fetch('/api/data'); // 发起网络请求
  }
}
```

---

## 7. 🔄 回调函数转Promise


### 7.1 util.promisify() - Node.js内置转换


```javascript
const fs = require('fs');
const util = require('util');

// 传统回调方式
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.log('读取失败:', err);
  } else {
    console.log('文件内容:', data);
  }
});

// 使用promisify转换
const readFilePromise = util.promisify(fs.readFile);

readFilePromise('file.txt', 'utf8')
  .then(data => console.log('文件内容:', data))
  .catch(err => console.log('读取失败:', err));
```

### 7.2 自定义promisify实现


```javascript
// 简单的promisify实现
function promisify(fn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };
}

// 使用自定义promisify
const readFilePromise = promisify(fs.readFile);
readFilePromise('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.log(err));
```

### 7.3 手动包装回调函数


```javascript
// 包装setTimeout
function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

// 使用
delay(2000)
  .then(() => console.log('2秒后执行'));

// 包装数据库查询（假设使用mysql）
function queryDatabase(sql) {
  return new Promise((resolve, reject) => {
    db.query(sql, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}
```

---

## 8. 🚀 实际应用场景


### 8.1 文件操作链式处理


```javascript
const fs = require('fs').promises;

// 复制并处理文件
function processFile(inputFile, outputFile) {
  return fs.readFile(inputFile, 'utf8')
    .then(content => {
      // 处理内容：转换为大写
      return content.toUpperCase();
    })
    .then(processedContent => {
      // 写入新文件
      return fs.writeFile(outputFile, processedContent);
    })
    .then(() => {
      console.log('文件处理完成');
    })
    .catch(error => {
      console.log('文件处理失败:', error.message);
    });
}

processFile('input.txt', 'output.txt');
```

### 8.2 HTTP请求处理


```javascript
const https = require('https');

function httpRequest(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (response) => {
      let data = '';
      
      response.on('data', chunk => {
        data += chunk;
      });
      
      response.on('end', () => {
        resolve(data);
      });
      
      response.on('error', error => {
        reject(error);
      });
    });
  });
}

// 链式处理多个API请求
httpRequest('https://api.github.com/users/octocat')
  .then(userData => {
    const user = JSON.parse(userData);
    console.log('用户名:', user.login);
    return httpRequest(`https://api.github.com/users/${user.login}/repos`);
  })
  .then(reposData => {
    const repos = JSON.parse(reposData);
    console.log('仓库数量:', repos.length);
  })
  .catch(error => {
    console.log('请求失败:', error.message);
  });
```

### 8.3 错误重试机制


```javascript
function retryOperation(operation, maxRetries = 3) {
  return new Promise((resolve, reject) => {
    function attempt(retryCount) {
      operation()
        .then(resolve)
        .catch(error => {
          if (retryCount < maxRetries) {
            console.log(`第${retryCount + 1}次重试...`);
            setTimeout(() => attempt(retryCount + 1), 1000);
          } else {
            reject(error);
          }
        });
    }
    
    attempt(0);
  });
}

// 使用重试机制
retryOperation(() => httpRequest('https://unreliable-api.com'))
  .then(result => console.log('请求成功:', result))
  .catch(error => console.log('重试3次后仍失败:', error));
```

---

## 9. 📋 核心要点总结


### 9.1 必须掌握的核心概念


```
🔸 Promise本质：解决回调地狱，让异步代码更优雅
🔸 三种状态：pending(等待) → fulfilled(成功) | rejected(失败)
🔸 基本方法：then(处理成功) + catch(处理错误) + finally(最终处理)
🔸 链式调用：返回值传递到下一个then，返回Promise会等待完成
🔸 静态方法：all(全部成功)、race(竞态)、allSettled(全部结果)
🔸 回调转换：util.promisify()或手动包装
```

### 9.2 关键理解要点


**🔹 Promise不是魔法**：
```
Promise只是一种编程模式，本质上还是异步回调
只是把嵌套的回调变成了链式调用
让代码更容易理解和维护
```

**🔹 状态不可逆**：
```
Promise状态一旦改变就不能再变
这保证了结果的确定性
避免了状态混乱的问题
```

**🔹 错误传播**：
```
Promise链中任何一个环节出错
都会被后面的catch捕获
这实现了统一的错误处理
```

### 9.3 实际开发建议


**✅ 最佳实践**：
- 总是用catch处理错误
- 在Promise链中返回值或Promise
- 使用Promise.all处理并发操作
- 用finally清理资源

**❌ 常见误区**：
- 忘记return导致undefined传递
- 在then中嵌套Promise
- 不处理rejected状态
- 混用async/await和then/catch

### 9.4 记忆要点


**Promise记忆口诀**：
```
Promise承诺待兑现，三状态转换不可逆
then接成功catch接错，finally清理最贴心
链式调用要return，all等全部race竞速
promisify转回调，异步编程更优雅
```

**学习建议**：
- 先理解概念，再看代码
- 多练习链式调用
- 掌握错误处理模式
- 了解与async/await的关系