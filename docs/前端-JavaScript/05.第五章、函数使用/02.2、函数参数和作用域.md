---
title: 2、函数参数和作用域
---
## 📚 目录

1. [函数参数详解](#1-函数参数详解)
2. [作用域机制](#2-作用域机制)
3. [变量提升](#3-变量提升)
4. [闭包概念](#4-闭包概念)
5. [核心要点总结](#5-核心要点总结)

---

## 1. 📝 函数参数详解


### 1.1 基本参数传递


**🔸 核心概念**
```javascript
// 最基本的参数传递
function greet(name) {
    console.log("Hello " + name);
}

greet("张三");  // Hello 张三
```

**💡 参数传递原理**
```
JavaScript中参数传递的本质：
• 基本类型：传值（复制一份）
• 对象类型：传引用（共享同一个对象）

简单理解：
数字、字符串 → 复制一份给函数
数组、对象 → 把地址给函数
```

### 1.2 默认参数


**🔸 ES6默认参数语法**
```javascript
// 旧写法：手动检查
function oldWay(name) {
    name = name || "游客";
    return "欢迎 " + name;
}

// 新写法：直接设默认值
function newWay(name = "游客") {
    return "欢迎 " + name;
}

console.log(newWay());        // 欢迎 游客
console.log(newWay("小明"));  // 欢迎 小明
```

**⚡ 实际应用场景**
```javascript
// 配置对象默认值
function createButton(text = "按钮", color = "blue") {
    return `<button style="color: ${color}">${text}</button>`;
}

// API请求默认配置
function fetchData(url, timeout = 5000) {
    // 发送请求逻辑
    console.log(`请求 ${url}，超时 ${timeout}ms`);
}
```

### 1.3 剩余参数（...args）


**🔸 处理不定数量参数**
```javascript
// 计算多个数字的和
function sum(...numbers) {
    let total = 0;
    for (let num of numbers) {
        total += num;
    }
    return total;
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15
```

**💻 与arguments的区别**
```javascript
// 旧方式（不推荐）
function oldSum() {
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}

// 新方式（推荐）
function newSum(...nums) {
    return nums.reduce((total, num) => total + num, 0);
}

// 剩余参数的优势：
// ✅ 真正的数组，可以用数组方法
// ✅ 箭头函数中也能用
// ✅ 语义更清晰
```

---

## 2. 🏠 作用域机制


### 2.1 作用域基本概念


**🔸 什么是作用域**
```
作用域就是变量的"活动范围"
简单理解：变量在哪里能被访问到

三种主要作用域：
🌍 全局作用域：整个程序都能访问
🏠 函数作用域：只在函数内部能访问  
📦 块级作用域：只在{}内部能访问
```

### 2.2 全局作用域


**🌍 全局作用域特点**
```javascript
// 全局变量：在任何地方都能访问
var globalVar = "我是全局的";
let globalLet = "我也是全局的";

function test() {
    console.log(globalVar);  // 能访问到
    console.log(globalLet);  // 能访问到
}

// 在浏览器中，var声明的全局变量会成为window属性
console.log(window.globalVar);  // "我是全局的"
console.log(window.globalLet);  // undefined（let不会）
```

### 2.3 函数作用域


**🏠 函数作用域规则**
```javascript
function outer() {
    var functionVar = "函数内部变量";
    
    function inner() {
        console.log(functionVar);  // 能访问外层函数的变量
    }
    
    inner();
}

// console.log(functionVar);  // 报错！外部无法访问函数内变量
```

**🔍 作用域链查找**
```javascript
var global = "全局";

function level1() {
    var level1Var = "第1层";
    
    function level2() {
        var level2Var = "第2层";
        console.log(global);     // 找到全局的
        console.log(level1Var);  // 找到第1层的
        console.log(level2Var);  // 找到第2层的
    }
    
    level2();
}

// 查找顺序：当前作用域 → 上级作用域 → 再上级... → 全局作用域
```

### 2.4 块级作用域


**📦 let和const的块级作用域**
```javascript
// var：没有块级作用域
if (true) {
    var varVariable = "var声明";
}
console.log(varVariable);  // 能访问到

// let/const：有块级作用域
if (true) {
    let letVariable = "let声明";
    const constVariable = "const声明";
}
// console.log(letVariable);  // 报错！块外无法访问
```

**🔄 循环中的作用域问题**
```javascript
// 经典面试题：var的问题
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);  // 输出：3, 3, 3
    }, 100);
}

// 用let解决
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);  // 输出：0, 1, 2
    }, 100);
}
```

---

## 3. ⬆️ 变量提升


### 3.1 变量提升概念


**🔸 什么是变量提升**
```
变量提升：JavaScript引擎把变量声明"提前"到作用域顶部
注意：只提升声明，不提升赋值！

简单理解：
var和function声明会被"移动"到最前面
let和const不会提升（有暂时性死区）
```

### 3.2 var的提升行为


**📈 var提升示例**
```javascript
// 我们写的代码
console.log(myVar);  // undefined（不是报错）
var myVar = "Hello";

// JavaScript引擎实际执行的顺序
var myVar;           // 声明被提升
console.log(myVar);  // undefined
myVar = "Hello";     // 赋值还在原位置
```

**⚠️ 常见的提升陷阱**
```javascript
// 陷阱1：循环中的var
for (var i = 0; i < 3; i++) {
    // ...
}
console.log(i);  // 3（i泄漏到外部）

// 陷阱2：函数内的var
function test() {
    console.log(name);  // undefined
    if (false) {
        var name = "张三";  // 即使不执行，声明也被提升
    }
}
```

### 3.3 let/const的暂时性死区


**🚫 暂时性死区（TDZ）**
```javascript
// let/const在声明前无法访问
console.log(myLet);  // ReferenceError: Cannot access before initialization
let myLet = "Hello";

// const必须在声明时赋值
// const name;  // SyntaxError: Missing initializer
const name = "张三";
```

**💡 最佳实践**
```javascript
// ✅ 推荐：先声明再使用
let userName;
userName = "用户名";

// ✅ 推荐：const用于不变的值
const API_URL = "https://api.example.com";

// ❌ 不推荐：var容易造成混乱
var data;  // 尽量避免使用var
```

---

## 4. 🔒 闭包概念


### 4.1 什么是闭包


**🔸 闭包的定义**
```
闭包：函数能够访问外部函数的变量，即使外部函数已经执行完毕

简单理解：
内层函数"记住"了外层函数的变量
这些变量不会被垃圾回收，一直保存着
```

**💡 最简单的闭包示例**
```javascript
function outer() {
    let message = "Hello";
    
    function inner() {
        console.log(message);  // 访问外部变量
    }
    
    return inner;
}

let fn = outer();  // outer执行完了
fn();              // "Hello" - 但还能访问message！
```

### 4.2 闭包的实际应用


**🏭 创建私有变量**
```javascript
function createCounter() {
    let count = 0;  // 私有变量
    
    return {
        increment() {
            count++;
            return count;
        },
        decrement() {
            count--;
            return count;
        },
        getCount() {
            return count;
        }
    };
}

let counter = createCounter();
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.getCount());   // 2
// console.log(counter.count);     // undefined（无法直接访问）
```

**🎯 模块模式**
```javascript
let userModule = (function() {
    let users = [];  // 私有数据
    
    return {
        addUser(name) {
            users.push(name);
        },
        getUsers() {
            return [...users];  // 返回副本，保护原数据
        },
        getUserCount() {
            return users.length;
        }
    };
})();

userModule.addUser("张三");
userModule.addUser("李四");
console.log(userModule.getUsers());     // ["张三", "李四"]
console.log(userModule.getUserCount()); // 2
```

### 4.3 闭包常见问题


**⚠️ 循环中的闭包陷阱**
```javascript
// 问题代码
let funcs = [];
for (var i = 0; i < 3; i++) {
    funcs[i] = function() {
        console.log(i);  // 都输出3
    };
}

// 解决方案1：使用let
let funcs2 = [];
for (let i = 0; i < 3; i++) {
    funcs2[i] = function() {
        console.log(i);  // 输出0, 1, 2
    };
}

// 解决方案2：立即执行函数
let funcs3 = [];
for (var i = 0; i < 3; i++) {
    funcs3[i] = (function(index) {
        return function() {
            console.log(index);
        };
    })(i);
}
```

**💾 内存注意事项**
```javascript
// 注意：闭包会保持外部变量的引用
function createHandler(element) {
    let largeData = new Array(1000000).fill("data");
    
    return function() {
        // 即使不使用largeData，它也不会被回收
        console.log("处理点击");
    };
}

// 优化：只保留需要的数据
function createOptimizedHandler(element) {
    let elementId = element.id;  // 只保留需要的
    
    return function() {
        console.log("处理元素：" + elementId);
    };
}
```

---

## 5. 📋 核心要点总结


### 5.1 必须掌握的核心概念


```
🔸 函数参数：默认参数、剩余参数(...args)、参数传递机制
🔸 作用域：全局、函数、块级作用域的区别和查找规则
🔸 变量提升：var会提升，let/const有暂时性死区
🔸 闭包：内层函数访问外层变量，常用于私有变量和模块
```

### 5.2 关键理解要点


**🔹 参数传递本质**
```
基本类型传值：
let a = 10;
function change(x) { x = 20; }
change(a);  // a还是10

对象类型传引用：
let obj = {name: "张三"};
function change(o) { o.name = "李四"; }
change(obj);  // obj.name变成"李四"
```

**🔹 作用域链查找**
```
查找变量的顺序：
当前作用域 → 外层作用域 → 再外层... → 全局作用域 → 报错

记忆口诀：由内向外，逐层查找
```

**🔹 闭包的核心价值**
```
主要用途：
• 创建私有变量（数据封装）
• 模块化开发（避免全局污染）
• 保持状态（计数器、缓存等）
```

### 5.3 实际开发指导


**✅ 最佳实践**
```javascript
// 1. 优先使用let/const
const name = "张三";     // 不变的值用const
let age = 18;           // 可变的值用let

// 2. 默认参数简化代码
function greet(name = "朋友") {
    return `你好，${name}！`;
}

// 3. 剩余参数处理多参数
function sum(...numbers) {
    return numbers.reduce((a, b) => a + b, 0);
}

// 4. 合理使用闭包
function createAPI(baseURL) {
    return {
        get(path) { return fetch(baseURL + path); },
        post(path, data) { /* 实现 */ }
    };
}
```

**⚠️ 常见陷阱避免**
```javascript
// 避免：在循环中用var创建函数
// 避免：过度使用闭包导致内存泄漏
// 避免：在不了解提升的情况下混用var/let
// 避免：忘记设置默认参数导致undefined
```

**核心记忆**：
- 参数传递要分清：基本类型传值，对象传引用
- 作用域查找有顺序：由内向外逐层找
- 变量提升要小心：var会提升，let/const不会
- 闭包很有用：私有变量和模块化的好帮手