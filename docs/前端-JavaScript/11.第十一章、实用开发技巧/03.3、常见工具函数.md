---
title: 3、常见工具函数
---
## 📚 目录

1. [数据类型判断](#1-数据类型判断)
2. [深拷贝与浅拷贝](#2-深拷贝与浅拷贝)
3. [数组去重](#3-数组去重)
4. [对象合并](#4-对象合并)
5. [常用正则表达式](#5-常用正则表达式)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🔍 数据类型判断


### 1.1 为什么需要准确的类型判断


**🔸 核心问题**
```javascript
typeof [] // "object" - 不够准确
typeof null // "object" - 这是个历史bug
[] instanceof Array // true - 但跨iframe会失效
```

**💡 实际需求**
- 判断是否为数组，用于不同的处理逻辑
- 区分对象和数组，防止错误操作
- 验证函数参数类型，提高代码健壮性

### 1.2 最佳类型判断方法


**🎯 万能类型判断函数**
```javascript
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

// 使用示例
console.log(getType([])); // "array"
console.log(getType({})); // "object"
console.log(getType(null)); // "null"
console.log(getType('hello')); // "string"
console.log(getType(123)); // "number"
```

**🔧 具体类型判断函数**
```javascript
// 判断是否为数组
function isArray(value) {
  return Array.isArray(value);
}

// 判断是否为对象（排除null和数组）
function isObject(value) {
  return value !== null && typeof value === 'object' && !Array.isArray(value);
}

// 判断是否为函数
function isFunction(value) {
  return typeof value === 'function';
}

// 判断是否为空值
function isEmpty(value) {
  if (value === null || value === undefined) return true;
  if (typeof value === 'string') return value.length === 0;
  if (Array.isArray(value)) return value.length === 0;
  if (typeof value === 'object') return Object.keys(value).length === 0;
  return false;
}
```

### 1.3 实际应用场景


**📋 表单验证中的应用**
```javascript
function validateInput(data) {
  if (!isObject(data)) {
    throw new Error('参数必须是对象');
  }
  
  if (isEmpty(data.name)) {
    return '姓名不能为空';
  }
  
  return '验证通过';
}
```

---

## 2. 📦 深拷贝与浅拷贝


### 2.1 核心概念理解


**🔸 浅拷贝**：只复制第一层，深层的对象还是共享引用

```
原对象:  { name: 'Tom', info: { age: 20 } }
        ↓ 浅拷贝
新对象:  { name: 'Tom', info: ←同一个引用→ }
```

**🔸 深拷贝**：完全独立的副本，互不影响

```
原对象:  { name: 'Tom', info: { age: 20 } }
        ↓ 深拷贝  
新对象:  { name: 'Tom', info: { age: 20 } }  ←完全独立
```

### 2.2 浅拷贝实现方法


**🎯 对象浅拷贝**
```javascript
const obj = { name: 'Tom', info: { age: 20 } };

// 方法1：Object.assign()
const copy1 = Object.assign({}, obj);

// 方法2：扩展运算符（推荐）
const copy2 = { ...obj };

// 验证浅拷贝特点
copy2.name = 'Jerry';  // 不影响原对象
copy2.info.age = 30;   // 影响原对象！
console.log(obj.info.age); // 30
```

**🎯 数组浅拷贝**
```javascript
const arr = [1, 2, { a: 3 }];

// 方法1：扩展运算符
const copy1 = [...arr];

// 方法2：slice()
const copy2 = arr.slice();

// 方法3：Array.from()
const copy3 = Array.from(arr);
```

### 2.3 深拷贝实现方法


**🔧 简单版深拷贝（适合大多数场景）**
```javascript
function deepClone(obj) {
  // 基本类型直接返回
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 数组处理
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item));
  }
  
  // 对象处理
  const cloned = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  return cloned;
}
```

**⚡ JSON方法（适合简单数据）**
```javascript
function jsonClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// 注意：JSON方法的局限性
// ❌ 不能处理函数、undefined、Symbol
// ❌ 不能处理循环引用
// ✅ 适合纯数据对象
```

### 2.4 实际应用对比


| 场景 | 推荐方法 | 原因 |
|------|---------|------|
| **简单数据复制** | `JSON.parse(JSON.stringify())` | 简单快速 |
| **包含函数的对象** | 自定义`deepClone` | JSON不支持函数 |
| **性能要求高** | 浅拷贝 + 按需深拷贝 | 避免不必要的深拷贝 |
| **复杂嵌套对象** | Lodash的`cloneDeep` | 处理更全面 |

---

## 3. 🔄 数组去重


### 3.1 为什么需要数组去重


**💡 常见场景**
- 用户选择的标签去重
- 合并多个数组后去重
- 从服务器获取的重复数据清理

### 3.2 现代数组去重方法


**🎯 Set方法（最简单推荐）**
```javascript
function uniqueArray(arr) {
  return [...new Set(arr)];
}

// 使用示例
const numbers = [1, 2, 2, 3, 3, 4];
console.log(uniqueArray(numbers)); // [1, 2, 3, 4]

const strings = ['a', 'b', 'a', 'c'];
console.log(uniqueArray(strings)); // ['a', 'b', 'c']
```

**🔧 filter + indexOf方法**
```javascript
function uniqueArray2(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}
```

### 3.3 对象数组去重


**🎯 按属性去重**
```javascript
function uniqueByProperty(arr, property) {
  const seen = new Map();
  return arr.filter(item => {
    const key = item[property];
    if (seen.has(key)) {
      return false;
    }
    seen.set(key, true);
    return true;
  });
}

// 使用示例
const users = [
  { id: 1, name: 'Tom' },
  { id: 2, name: 'Jerry' },
  { id: 1, name: 'Tom' }, // 重复
];

console.log(uniqueByProperty(users, 'id'));
// [{ id: 1, name: 'Tom' }, { id: 2, name: 'Jerry' }]
```

**⚡ 多属性组合去重**
```javascript
function uniqueByMultipleProps(arr, props) {
  const seen = new Set();
  return arr.filter(item => {
    const key = props.map(prop => item[prop]).join('|');
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

// 按name和age组合去重
const people = [
  { name: 'Tom', age: 20 },
  { name: 'Tom', age: 25 },
  { name: 'Tom', age: 20 }, // 重复
];

console.log(uniqueByMultipleProps(people, ['name', 'age']));
```

---

## 4. 🔗 对象合并


### 4.1 对象合并的常见需求


**💡 实际场景**
- 合并配置对象和默认值
- 合并用户输入和系统默认设置  
- API响应数据的合并处理

### 4.2 浅合并方法


**🎯 Object.assign()方法**
```javascript
const defaults = { 
  theme: 'light', 
  size: 'medium',
  features: { search: true }
};

const userConfig = { 
  theme: 'dark',
  features: { filter: true }
};

// 浅合并
const config = Object.assign({}, defaults, userConfig);
console.log(config);
// {
//   theme: 'dark',      // 被覆盖
//   size: 'medium',     // 保留默认值
//   features: { filter: true } // 整个对象被替换！
// }
```

**⚡ 扩展运算符（推荐）**
```javascript
const config = { ...defaults, ...userConfig };
// 结果同上，但语法更简洁
```

### 4.3 深合并方法


**🔧 递归深合并**
```javascript
function deepMerge(target, source) {
  const result = { ...target };
  
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      if (isObject(source[key]) && isObject(result[key])) {
        // 递归合并嵌套对象
        result[key] = deepMerge(result[key], source[key]);
      } else {
        // 直接赋值
        result[key] = source[key];
      }
    }
  }
  
  return result;
}

// 使用示例
const merged = deepMerge(defaults, userConfig);
console.log(merged);
// {
//   theme: 'dark',
//   size: 'medium',
//   features: { search: true, filter: true } // 正确合并！
// }
```

**📋 多对象合并**
```javascript
function mergeMultiple(...objects) {
  return objects.reduce((result, obj) => deepMerge(result, obj), {});
}

// 使用示例
const config1 = { a: 1, b: { x: 1 } };
const config2 = { b: { y: 2 }, c: 3 };
const config3 = { b: { z: 3 }, d: 4 };

const final = mergeMultiple(config1, config2, config3);
// { a: 1, b: { x: 1, y: 2, z: 3 }, c: 3, d: 4 }
```

---

## 5. 🔤 常用正则表达式


### 5.1 正则表达式的作用


**💡 核心用途**
- **数据验证**：手机号、邮箱、身份证格式检查
- **数据提取**：从文本中提取特定信息
- **数据替换**：批量替换和格式化文本

### 5.2 必备验证正则


**📱 手机号验证**
```javascript
function isValidPhone(phone) {
  const phoneRegex = /^1[3-9]\d{9}$/;
  return phoneRegex.test(phone);
}

// 使用示例
console.log(isValidPhone('13812345678')); // true
console.log(isValidPhone('12812345678')); // false
```

**📧 邮箱验证**
```javascript
function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// 使用示例
console.log(isValidEmail('user@example.com')); // true
console.log(isValidEmail('invalid.email'));    // false
```

**🔐 密码强度验证**
```javascript
function validatePassword(password) {
  // 至少8位，包含字母和数字
  const strongRegex = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*?&]{8,}$/;
  return strongRegex.test(password);
}

// 使用示例
console.log(validatePassword('abc123456')); // true
console.log(validatePassword('12345678'));  // false（只有数字）
```

### 5.3 常用数据提取


**🔍 提取数字**
```javascript
function extractNumbers(text) {
  const numberRegex = /\d+/g;
  return text.match(numberRegex) || [];
}

// 使用示例
const text = '价格是100元，原价150元';
console.log(extractNumbers(text)); // ['100', '150']
```

**🌐 提取URL**
```javascript
function extractUrls(text) {
  const urlRegex = /https?:\/\/[^\s]+/g;
  return text.match(urlRegex) || [];
}

// 使用示例
const content = '访问 https://example.com 或 http://test.com';
console.log(extractUrls(content));
// ['https://example.com', 'http://test.com']
```

### 5.4 数据格式化


**💰 格式化金额**
```javascript
function formatMoney(amount) {
  return amount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// 使用示例
console.log(formatMoney(1234567)); // "1,234,567"
```

**📞 格式化手机号**
```javascript
function formatPhone(phone) {
  return phone.replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
}

// 使用示例
console.log(formatPhone('13812345678')); // "138-1234-5678"
```

### 5.5 实用正则工具函数


**🔧 通用验证函数**
```javascript
const validators = {
  // 中文姓名
  chineseName: /^[\u4e00-\u9fa5]{2,4}$/,
  
  // 身份证号
  idCard: /^\d{17}[\dX]$/,
  
  // QQ号
  qq: /^[1-9]\d{4,10}$/,
  
  // 车牌号
  carNumber: /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-Z][A-Z0-9]{5}$/
};

function validate(type, value) {
  return validators[type] ? validators[type].test(value) : false;
}

// 使用示例
console.log(validate('chineseName', '张三'));  // true
console.log(validate('qq', '123456789'));     // true
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的工具函数


```javascript
// 🔍 类型判断 - 万能方法
const getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();

// 📦 深拷贝 - 简单实用
const deepClone = (obj) => JSON.parse(JSON.stringify(obj)); // 适合纯数据

// 🔄 数组去重 - 现代写法
const unique = (arr) => [...new Set(arr)];

// 🔗 对象合并 - 常用操作
const merge = (obj1, obj2) => ({ ...obj1, ...obj2 }); // 浅合并

// 🔤 常用验证 - 手机邮箱
const isPhone = (phone) => /^1[3-9]\d{9}$/.test(phone);
const isEmail = (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
```

### 6.2 使用场景总结


**🎯 实际开发中的应用**

| 工具函数 | **主要用途** | **使用频率** |
|---------|-------------|-------------|
| **类型判断** | `参数验证、条件判断` | ⭐⭐⭐⭐⭐ |
| **深浅拷贝** | `数据处理、状态管理` | ⭐⭐⭐⭐⭐ |
| **数组去重** | `数据清理、用户选择` | ⭐⭐⭐⭐ |
| **对象合并** | `配置处理、数据组合` | ⭐⭐⭐⭐ |
| **正则验证** | `表单验证、数据格式化` | ⭐⭐⭐⭐⭐ |

### 6.3 最佳实践建议


**💡 代码组织建议**
```javascript
// 创建工具函数库
const utils = {
  // 类型判断
  getType: (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase(),
  isArray: Array.isArray,
  isObject: (value) => value !== null && typeof value === 'object' && !Array.isArray(value),
  
  // 数据处理
  deepClone: (obj) => JSON.parse(JSON.stringify(obj)),
  unique: (arr) => [...new Set(arr)],
  merge: (obj1, obj2) => ({ ...obj1, ...obj2 }),
  
  // 验证
  isPhone: (phone) => /^1[3-9]\d{9}$/.test(phone),
  isEmail: (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
};

// 统一导出使用
export default utils;
```

**⚡ 性能优化提示**
- **选择合适的方法**：简单场景用简单方法
- **避免过度拷贝**：不是所有情况都需要深拷贝
- **缓存正则对象**：频繁使用的正则表达式可以提前定义
- **优先使用原生方法**：如`Array.isArray()`比自定义判断更快

**🔧 实际应用建议**
- **建立工具函数库**：把常用函数整理成模块
- **写好注释文档**：说明函数用途和限制
- **添加错误处理**：对异常输入进行处理
- **保持函数纯净**：避免副作用，便于测试和复用

**核心记忆**：
- 工具函数要简单实用，解决实际问题
- 类型判断、数据拷贝、数组去重是高频需求
- 正则表达式重点掌握验证和格式化场景
- 性能和可读性要平衡，优先选择简单可靠的方案