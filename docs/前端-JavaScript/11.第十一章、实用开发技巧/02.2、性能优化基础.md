---
title: 2、性能优化基础
---
## 📚 目录

1. [避免全局变量](#1-避免全局变量)
2. [减少DOM操作](#2-减少DOM操作)
3. [事件委托优化](#3-事件委托优化)
4. [防抖和节流基础](#4-防抖和节流基础)
5. [内存泄漏预防](#5-内存泄漏预防)
6. [核心要点总结](#6-核心要点总结)

---

## 1. 🌐 避免全局变量


### 1.1 什么是全局变量


**全局变量**：在任何地方都能访问的变量，存储在全局作用域中。

```javascript
// 这些都是全局变量
var userName = "张三";        // var声明的全局变量
score = 100;                 // 没有声明关键字，自动成为全局变量
window.appName = "我的应用";  // 直接挂在window上
```

### 1.2 全局变量的问题


**🔸 为什么要避免全局变量？**
```
问题1：命名冲突
├── 多个脚本文件可能使用相同变量名
├── 第三方库可能覆盖你的变量
└── 团队开发时容易重名

问题2：内存占用
├── 全局变量不会被垃圾回收
├── 页面关闭前一直占用内存
└── 大量全局变量影响性能

问题3：难以维护
├── 不知道变量在哪里被修改
├── 调试困难
└── 代码耦合度高
```

### 1.3 最佳实践


**✅ 推荐做法**
```javascript
// 1. 使用立即执行函数
(function() {
    var userName = "张三";  // 局部变量，不会污染全局
    var score = 100;
    
    // 只暴露必要的接口
    window.MyApp = {
        getUserName: function() { return userName; },
        getScore: function() { return score; }
    };
})();

// 2. 使用模块模式
const UserModule = {
    _name: "张三",  // 私有属性（约定用_开头）
    _score: 100,
    
    getName() { return this._name; },
    getScore() { return this._score; }
};

// 3. ES6模块（推荐）
// 在单独的文件中
export const userName = "张三";
export function getScore() { return 100; }
```

**❌ 要避免的做法**
```javascript
// 避免：无意创建全局变量
function calculateScore() {
    result = score * 2;  // 忘记声明，变成全局变量
    return result;
}

// 避免：大量全局变量
var userName, userAge, userScore, userLevel, userExp, userGold;
```

---

## 2. 🔧 减少DOM操作


### 2.1 为什么要减少DOM操作


**DOM操作的代价**：
```
性能影响：
├── DOM操作比JS计算慢100倍以上
├── 每次修改可能触发重排重绘
├── 频繁操作会阻塞页面渲染
└── 大量操作导致页面卡顿
```

### 2.2 常见的性能问题


**❌ 低效的DOM操作**
```javascript
// 问题1：重复查询DOM
for (let i = 0; i < 1000; i++) {
    document.getElementById("list").innerHTML += "<li>项目" + i + "</li>";
    // 每次都查询DOM，且触发1000次重排
}

// 问题2：频繁修改样式
const box = document.querySelector(".box");
box.style.width = "100px";   // 触发重排
box.style.height = "100px";  // 再次触发重排
box.style.background = "red"; // 触发重绘
```

### 2.3 优化技巧


**✅ 批量操作DOM**
```javascript
// 优化1：缓存DOM查询
const list = document.getElementById("list");
let html = "";
for (let i = 0; i < 1000; i++) {
    html += "<li>项目" + i + "</li>";
}
list.innerHTML = html;  // 只操作一次DOM

// 优化2：使用文档片段
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
    const li = document.createElement("li");
    li.textContent = "项目" + i;
    fragment.appendChild(li);
}
list.appendChild(fragment);  // 一次性插入
```

**✅ 批量修改样式**
```javascript
// 方法1：使用cssText
const box = document.querySelector(".box");
box.style.cssText = "width: 100px; height: 100px; background: red;";

// 方法2：使用CSS类
/* CSS */
.big-red-box {
    width: 100px;
    height: 100px;
    background: red;
}

// JavaScript
box.className = "big-red-box";  // 只触发一次重排
```

**✅ 离线操作**
```javascript
// 先隐藏元素，修改完再显示
const container = document.querySelector(".container");
container.style.display = "none";  // 脱离文档流

// 进行大量修改...
for (let i = 0; i < 100; i++) {
    // 各种DOM操作
}

container.style.display = "block";  // 重新显示，只重排一次
```

### 2.4 实用技巧


**📊 DOM操作性能对比**
| 操作方式 | **性能** | **使用场景** |
|---------|---------|-------------|
| `innerHTML` | `快` | `大量HTML内容` |
| `createElement + appendChild` | `中等` | `需要事件绑定的元素` |
| `insertAdjacentHTML` | `快` | `插入HTML片段` |
| `documentFragment` | `最快` | `大量DOM节点创建` |

---

## 3. 🎯 事件委托优化


### 3.1 什么是事件委托


**事件委托**：利用事件冒泡，将事件绑定在父元素上，通过判断触发元素来执行相应操作。

```
普通绑定：                    事件委托：
父容器                        父容器 ← 绑定事件
├── 按钮1 ← 绑定事件            ├── 按钮1
├── 按钮2 ← 绑定事件            ├── 按钮2  
├── 按钮3 ← 绑定事件            ├── 按钮3
└── 按钮4 ← 绑定事件            └── 按钮4
```

### 3.2 为什么使用事件委托


**🔸 传统绑定的问题**
```javascript
// 问题：给每个按钮单独绑定事件
const buttons = document.querySelectorAll(".btn");
buttons.forEach(btn => {
    btn.addEventListener("click", function() {
        console.log("点击了按钮");
    });
});
// 100个按钮 = 100个事件监听器 = 占用大量内存
```

**✅ 事件委托的优势**
```
优势对比：
├── 内存占用：1个监听器 vs 100个监听器
├── 动态元素：新增按钮自动有事件
├── 代码维护：统一事件处理逻辑
└── 性能更好：减少事件绑定开销
```

### 3.3 事件委托实现


**✅ 基础事件委托**
```javascript
// 容器绑定一个事件，处理所有按钮点击
document.querySelector(".container").addEventListener("click", function(e) {
    // 检查点击的是否是按钮
    if (e.target.classList.contains("btn")) {
        console.log("点击了按钮：" + e.target.textContent);
    }
});
```

**✅ 实际应用示例**
```javascript
// 商品列表的删除功能
document.querySelector(".product-list").addEventListener("click", function(e) {
    // 点击删除按钮
    if (e.target.classList.contains("delete-btn")) {
        const productId = e.target.dataset.id;
        deleteProduct(productId);
    }
    
    // 点击编辑按钮
    if (e.target.classList.contains("edit-btn")) {
        const productId = e.target.dataset.id;
        editProduct(productId);
    }
});

// HTML结构
/*
<div class="product-list">
    <div class="product-item">
        <span>商品1</span>
        <button class="edit-btn" data-id="1">编辑</button>
        <button class="delete-btn" data-id="1">删除</button>
    </div>
    <!-- 动态添加的商品也会自动有事件 -->
</div>
*/
```

### 3.4 事件委托注意事项


**⚠️ 常见问题**
```javascript
// 问题：事件目标判断不准确
document.querySelector(".list").addEventListener("click", function(e) {
    // 错误：如果按钮内有其他元素，e.target可能不是按钮
    if (e.target.tagName === "BUTTON") {
        // 点击按钮内的图标时，e.target是图标而不是按钮
    }
});

// 解决：使用closest()查找最近的目标元素
document.querySelector(".list").addEventListener("click", function(e) {
    const button = e.target.closest(".btn");
    if (button) {
        console.log("点击了按钮");
    }
});
```

---

## 4. ⏱️ 防抖和节流基础


### 4.1 什么是防抖和节流


**概念理解**：
```
防抖（Debounce）：
电梯关门 - 有人来就重新计时
应用：搜索框输入、按钮重复点击

节流（Throttle）：
地铁发车 - 固定间隔发车，错过等下班
应用：滚动事件、鼠标移动
```

### 4.2 防抖（Debounce）


**🔸 核心思想**：在事件触发n秒后才执行，如果n秒内再次触发，则重新计时。

**✅ 防抖实现**
```javascript
// 简单防抖函数
function debounce(func, delay) {
    let timer;
    return function() {
        clearTimeout(timer);  // 清除之前的定时器
        timer = setTimeout(() => {
            func.apply(this, arguments);
        }, delay);
    };
}

// 使用示例：搜索框
const searchInput = document.querySelector("#search");
const debouncedSearch = debounce(function() {
    console.log("执行搜索：" + this.value);
    // 实际的搜索逻辑
}, 500);

searchInput.addEventListener("input", debouncedSearch);
```

**🎯 防抖应用场景**
```javascript
// 1. 搜索框实时搜索
const searchBox = debounce(function(keyword) {
    // 调用搜索API
    fetch(`/search?q=${keyword}`);
}, 300);

// 2. 防止按钮重复点击
const submitBtn = debounce(function() {
    // 提交表单
    submitForm();
}, 1000);

// 3. 窗口大小改变
const handleResize = debounce(function() {
    // 重新计算布局
    calculateLayout();
}, 200);
window.addEventListener("resize", handleResize);
```

### 4.3 节流（Throttle）


**🔸 核心思想**：规定时间内只执行一次，无论触发多少次。

**✅ 节流实现**
```javascript
// 简单节流函数
function throttle(func, delay) {
    let timer;
    return function() {
        if (timer) return;  // 如果定时器存在，直接返回
        
        timer = setTimeout(() => {
            func.apply(this, arguments);
            timer = null;  // 执行完重置定时器
        }, delay);
    };
}

// 使用示例：滚动事件
const throttledScroll = throttle(function() {
    console.log("滚动位置：" + window.scrollY);
}, 100);

window.addEventListener("scroll", throttledScroll);
```

**🎯 节流应用场景**
```javascript
// 1. 滚动加载更多
const loadMore = throttle(function() {
    if (window.scrollY + window.innerHeight >= document.body.scrollHeight) {
        console.log("加载更多数据");
    }
}, 200);

// 2. 鼠标移动事件
const handleMouseMove = throttle(function(e) {
    console.log(`鼠标位置：${e.clientX}, ${e.clientY}`);
}, 50);

// 3. 页面滚动进度
const updateProgress = throttle(function() {
    const scrolled = (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
    document.querySelector(".progress").style.width = scrolled + "%";
}, 100);
```

### 4.4 防抖vs节流对比


| 特性 | **防抖** | **节流** |
|------|---------|---------|
| **执行时机** | `最后一次触发后延迟执行` | `固定间隔执行` |
| **适用场景** | `搜索框、按钮点击` | `滚动、鼠标移动` |
| **用户体验** | `避免频繁请求` | `保证响应流畅` |
| **资源消耗** | `减少无意义的执行` | `控制执行频率` |

---

## 5. 🧹 内存泄漏预防


### 5.1 什么是内存泄漏


**内存泄漏**：程序中已分配的内存无法被垃圾回收机制回收，导致内存占用持续增长。

```
正常情况：               内存泄漏：
分配内存 → 使用 → 释放     分配内存 → 使用 → 无法释放 → 内存占用越来越多
```

### 5.2 常见的内存泄漏场景


**❌ 场景1：忘记清除定时器**
```javascript
// 问题代码
function startTimer() {
    setInterval(() => {
        console.log("定时执行");
    }, 1000);
    // 没有清除定时器，即使页面跳转也会继续执行
}

// 正确做法
function startTimer() {
    const timerId = setInterval(() => {
        console.log("定时执行");
    }, 1000);
    
    // 页面卸载时清除
    window.addEventListener("beforeunload", () => {
        clearInterval(timerId);
    });
}
```

**❌ 场景2：事件监听器没有移除**
```javascript
// 问题代码
function bindEvents() {
    const button = document.querySelector("#btn");
    button.addEventListener("click", handleClick);
    // 元素删除后，事件监听器仍然存在
}

// 正确做法
function bindEvents() {
    const button = document.querySelector("#btn");
    button.addEventListener("click", handleClick);
    
    // 清理函数
    return function cleanup() {
        button.removeEventListener("click", handleClick);
    };
}

const cleanup = bindEvents();
// 需要时调用清理
cleanup();
```

**❌ 场景3：闭包引用外部变量**
```javascript
// 问题代码
function createHandler() {
    const largeData = new Array(1000000).fill("数据");  // 大量数据
    
    return function(e) {
        console.log("处理事件");
        // 即使不使用largeData，闭包也会保持引用
    };
}

// 正确做法
function createHandler() {
    const needData = "只保留需要的数据";
    
    return function(e) {
        console.log("处理事件：" + needData);
    };
}
```

### 5.3 预防内存泄漏的最佳实践


**✅ 1. 及时清理定时器**
```javascript
class Component {
    constructor() {
        this.timers = [];  // 统一管理定时器
    }
    
    addTimer(callback, delay) {
        const timerId = setInterval(callback, delay);
        this.timers.push(timerId);
        return timerId;
    }
    
    destroy() {
        // 清理所有定时器
        this.timers.forEach(clearInterval);
        this.timers = [];
    }
}
```

**✅ 2. 使用WeakMap避免循环引用**
```javascript
// 使用WeakMap存储DOM相关数据
const elementData = new WeakMap();

function setElementData(element, data) {
    elementData.set(element, data);  // 元素被删除时，数据自动清理
}

function getElementData(element) {
    return elementData.get(element);
}
```

**✅ 3. 合理使用事件委托**
```javascript
// 避免：给每个元素绑定事件
items.forEach(item => {
    item.addEventListener("click", handler);  // 可能忘记清理
});

// 推荐：使用事件委托
container.addEventListener("click", function(e) {
    if (e.target.classList.contains("item")) {
        handler(e);
    }
});
```

### 5.4 检测内存泄漏的方法


**🔍 浏览器开发者工具**
```
检测步骤：
1. 打开Chrome DevTools
2. 进入Memory面板
3. 录制堆快照（Heap Snapshot）
4. 执行可能泄漏的操作
5. 再次录制快照
6. 对比两次快照的差异
```

**💡 简单的内存监控**
```javascript
// 简单监控内存使用
function checkMemory() {
    if (performance.memory) {
        console.log({
            used: Math.round(performance.memory.usedJSHeapSize / 1048576) + " MB",
            total: Math.round(performance.memory.totalJSHeapSize / 1048576) + " MB",
            limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576) + " MB"
        });
    }
}

// 定期检查
setInterval(checkMemory, 5000);
```

---

## 6. 📋 核心要点总结


### 6.1 必须掌握的核心概念


```
🔸 全局变量污染：命名冲突、内存占用、难维护
🔸 DOM操作优化：批量操作、缓存查询、离线修改
🔸 事件委托：一个监听器处理多个元素，支持动态元素
🔸 防抖节流：防抖重新计时，节流固定间隔
🔸 内存泄漏：定时器、事件监听器、闭包引用要清理
```

### 6.2 关键理解要点


**🔹 性能优化的基本思路**
```
减少操作频率：
- 批量DOM操作替代单次操作
- 事件委托替代多个监听器
- 防抖节流控制执行频率

及时清理资源：
- 清除不用的定时器
- 移除事件监听器
- 避免不必要的变量引用
```

**🔹 实际应用中的权衡**
```
性能 vs 开发效率：
- 不需要过度优化简单页面
- 重点优化高频操作和大数据场景
- 先保证功能正确，再考虑性能优化
```

### 6.3 实际应用价值


**🎯 日常开发场景**
- **表单验证**：防抖避免频繁校验
- **搜索功能**：防抖减少请求次数
- **列表操作**：事件委托处理删除编辑
- **页面滚动**：节流优化滚动监听
- **组件销毁**：清理定时器和事件

**🛠️ 优化检查清单**
```javascript
// 开发时的自检清单
const optimizationChecklist = {
    "避免全局变量": "✓ 使用模块模式或立即执行函数",
    "DOM操作优化": "✓ 批量操作，缓存DOM查询",
    "事件委托": "✓ 列表操作使用事件委托",
    "防抖节流": "✓ 高频事件添加防抖或节流",
    "内存清理": "✓ 组件销毁时清理定时器和事件"
};
```

**核心记忆**：
- 性能优化重在减少不必要的操作和及时清理资源
- 全局污染、频繁DOM操作、内存泄漏是最常见的性能问题
- 防抖节流和事件委托是前端开发的必备技能
- 优化要适度，先保证功能正确再考虑性能