---
title: 2、let和const
---
## 📚 目录

1. [为什么需要let和const](#1-为什么需要let和const)
2. [let块级作用域详解](#2-let块级作用域详解)
3. [const常量声明](#3-const常量声明)
4. [与var的核心区别](#4-与var的核心区别)
5. [暂时性死区](#5-暂时性死区)
6. [实际开发最佳实践](#6-实际开发最佳实践)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🤔 为什么需要let和const


### 1.1 var的问题

在ES6之前，JavaScript只有`var`来声明变量，但它有很多问题：

```javascript
// var的问题1：没有块级作用域
if (true) {
    var name = "张三";
}
console.log(name); // "张三" - 变量泄漏到全局

// var的问题2：可以重复声明
var age = 20;
var age = 30; // 不会报错，但很危险

// var的问题3：变量提升混乱
console.log(score); // undefined（不是报错）
var score = 100;
```

### 1.2 ES6的解决方案

ES6引入了`let`和`const`来解决这些问题：

```
let：声明可变的变量，有块级作用域
const：声明常量，有块级作用域，不能重新赋值
```

**🎯 核心理念**：让变量的行为更可预测，减少bug

---

## 2. 🎯 let块级作用域详解


### 2.1 什么是块级作用域

**块级作用域**就是`{}`包围的区域内，变量只在这个区域有效

```javascript
// let有块级作用域
{
    let name = "张三";
    console.log(name); // "张三" - 块内可以访问
}
console.log(name); // 报错：name is not defined

// 对比var没有块级作用域
{
    var age = 20;
}
console.log(age); // 20 - 可以访问，变量泄漏了
```

### 2.2 实际应用场景


**🔸 for循环中的经典问题**
```javascript
// 用var的问题
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i); // 输出：3, 3, 3（不是期望的0, 1, 2）
    }, 100);
}

// 用let解决
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i); // 输出：0, 1, 2（正确！）
    }, 100);
}
```

**🔸 if语句中的变量隔离**
```javascript
let score = 85;

if (score >= 90) {
    let level = "优秀";
    console.log(level);
} else if (score >= 80) {
    let level = "良好";  // 这里的level和上面的level不冲突
    console.log(level); // "良好"
}

// console.log(level); // 报错：level在这里不存在
```

### 2.3 let的基本规则

```javascript
// ✅ 正确用法
let name = "张三";
name = "李四";        // 可以重新赋值
console.log(name);    // "李四"

// ❌ 错误用法
let age = 20;
let age = 30;         // 报错：不能重复声明

// ✅ 不同作用域可以同名
let city = "北京";
{
    let city = "上海"; // 不冲突
    console.log(city); // "上海"
}
console.log(city);     // "北京"
```

---

## 3. 📦 const常量声明


### 3.1 const的基本概念

**const**用来声明常量，一旦赋值就不能改变

```javascript
// ✅ 正确用法
const PI = 3.14159;
const API_URL = "https://api.example.com";

// ❌ 错误用法
const name = "张三";
name = "李四";        // 报错：不能重新赋值

const age;            // 报错：声明时必须赋值
```

### 3.2 对象和数组的特殊情况

**重要**：const只是保证**变量指向的地址不变**，不是保证值不变

```javascript
// 对象：可以修改属性，不能重新赋值
const person = {
    name: "张三",
    age: 20
};

person.age = 25;      // ✅ 可以修改属性
person.city = "北京"; // ✅ 可以添加属性
console.log(person);  // {name: "张三", age: 25, city: "北京"}

// person = {};       // ❌ 不能重新赋值

// 数组：可以修改元素，不能重新赋值
const fruits = ["苹果", "香蕉"];
fruits.push("橙子");  // ✅ 可以添加元素
fruits[0] = "葡萄";   // ✅ 可以修改元素
console.log(fruits);  // ["葡萄", "香蕉", "橙子"]

// fruits = [];       // ❌ 不能重新赋值
```

### 3.3 何时使用const

```javascript
// 基本数据类型的常量
const MAX_COUNT = 100;
const USER_ROLES = {
    ADMIN: "admin",
    USER: "user"
};

// 不会重新赋值的对象/数组
const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
};

const menuItems = ["首页", "产品", "关于我们"];
```

---

## 4. ⚔️ 与var的核心区别


### 4.1 作用域对比


| 特性 | var | let | const |
|------|-----|-----|-------|
| **作用域** | `函数作用域` | `块级作用域` | `块级作用域` |
| **重复声明** | `✅ 允许` | `❌ 不允许` | `❌ 不允许` |
| **重新赋值** | `✅ 允许` | `✅ 允许` | `❌ 不允许` |
| **声明提升** | `有（undefined）` | `有（暂时性死区）` | `有（暂时性死区）` |

### 4.2 实际对比例子


```javascript
// 作用域差异
function testScope() {
    if (true) {
        var a = 1;    // 函数作用域
        let b = 2;    // 块级作用域
        const c = 3;  // 块级作用域
    }
    
    console.log(a); // 1 - var可以访问
    // console.log(b); // 报错 - let不能访问
    // console.log(c); // 报错 - const不能访问
}

// 重复声明差异
var name = "张三";
var name = "李四";   // ✅ var允许

let age = 20;
// let age = 30;    // ❌ let不允许

const PI = 3.14;
// const PI = 3.14159; // ❌ const不允许
```

### 4.3 循环中的表现


```javascript
// var在循环中的问题
var funcs = [];
for (var i = 0; i < 3; i++) {
    funcs[i] = function() {
        return i; // 都返回3（最终的i值）
    };
}
console.log(funcs[0]()); // 3
console.log(funcs[1]()); // 3

// let解决了这个问题
var funcs2 = [];
for (let i = 0; i < 3; i++) {
    funcs2[i] = function() {
        return i; // 返回各自的i值
    };
}
console.log(funcs2[0]()); // 0
console.log(funcs2[1]()); // 1
```

---

## 5. ⚠️ 暂时性死区


### 5.1 什么是暂时性死区

**暂时性死区**（TDZ）：在`let`/`const`声明之前访问变量会报错

```javascript
// var的行为（变量提升）
console.log(name); // undefined（不报错）
var name = "张三";

// let/const的行为（暂时性死区）
console.log(age);  // 报错：Cannot access 'age' before initialization
let age = 20;

console.log(PI);   // 报错：Cannot access 'PI' before initialization  
const PI = 3.14;
```

### 5.2 暂时性死区的范围


```javascript
let name = "全局张三";

function test() {
    // 这里开始是name的暂时性死区
    console.log(name); // 报错！不是访问全局的name
    
    let name = "局部李四"; // 声明后死区结束
    console.log(name); // "局部李四"
}

test();
```

### 5.3 为什么有暂时性死区

**目的**：让错误更早暴露，避免意外使用未初始化的变量

```javascript
// 避免这种混乱的情况
function badExample() {
    console.log(typeof name); // var时代：undefined
    // ... 很多代码 ...
    var name = "张三";
}

// 现在的行为更清晰
function goodExample() {
    // console.log(name); // 直接报错，问题立即发现
    let name = "张三";
}
```

---

## 6. 💡 实际开发最佳实践


### 6.1 声明变量的优先级


```
优先级：const > let > var

1. 默认使用 const
2. 需要重新赋值时使用 let  
3. 避免使用 var（除非维护老代码）
```

### 6.2 实际应用指南


**🔸 使用const的场景**
```javascript
// 常量配置
const CONFIG = {
    API_BASE_URL: "https://api.example.com",
    MAX_RETRY: 3
};

// 不会重新赋值的变量
const userList = [];
const currentUser = getCurrentUser();
const elements = document.querySelectorAll('.item');

// 函数声明
const calculateTotal = (items) => {
    return items.reduce((sum, item) => sum + item.price, 0);
};
```

**🔸 使用let的场景**
```javascript
// 循环计数器
for (let i = 0; i < 10; i++) {
    // ...
}

// 条件赋值
let message;
if (success) {
    message = "操作成功";
} else {
    message = "操作失败";
}

// 需要重新赋值的变量
let currentPage = 1;
let isLoading = false;
```

### 6.3 团队开发规范


```javascript
// ✅ 好的实践
const MAX_COUNT = 100;        // 常量用const
const users = [];             // 不重新赋值用const
let currentIndex = 0;         // 需要改变用let

// ❌ 避免的做法
var count = 0;                // 避免var
let API_URL = "...";          // 常量不要用let
const index = 0; index++;     // const不能重新赋值
```

### 6.4 ESLint配置建议


```javascript
// .eslintrc.js 推荐配置
{
  "rules": {
    "no-var": "error",              // 禁用var
    "prefer-const": "error",        // 优先使用const
    "no-const-assign": "error"      // 禁止修改const
  }
}
```

---

## 7. 📋 核心要点总结


### 7.1 必须记住的核心概念


```
🔸 let：可变变量，块级作用域，不能重复声明
🔸 const：常量，块级作用域，不能重新赋值
🔸 块级作用域：{}包围的区域，变量只在内部有效
🔸 暂时性死区：声明前访问会报错，比var更严格
🔸 最佳实践：默认const，需要改变才用let，避免var
```

### 7.2 关键区别记忆


| 对比项 | **var** | **let** | **const** |
|-------|---------|---------|-----------|
| 🎯 **使用场景** | `过时，避免使用` | `需要重新赋值` | `不需要重新赋值` |
| 📦 **作用域** | `函数作用域` | `块级作用域` | `块级作用域` |
| 🔄 **重新赋值** | `✅ 可以` | `✅ 可以` | `❌ 不可以` |
| 📝 **重复声明** | `✅ 可以` | `❌ 不可以` | `❌ 不可以` |
| ⚡ **声明提升** | `undefined` | `报错(TDZ)` | `报错(TDZ)` |

### 7.3 实际开发记忆口诀


```
默认const，需变let，
块级作用域要记清。
暂时死区防错误，
现代JS更严谨。
```

### 7.4 常见错误避免


```javascript
// ❌ 常见错误
let name = "张三";
let name = "李四";        // 重复声明

const age;               // 未初始化
const score = 90;
score = 95;              // 重新赋值

// ✅ 正确写法  
let name = "张三";
name = "李四";           // 重新赋值

const age = 20;          // 声明时初始化
let score = 90;          // 用let如果需要改变
score = 95;
```

**核心记忆**：
- **const优先**：能用const就用const
- **let次选**：需要重新赋值才用let  
- **告别var**：现代开发中避免使用var
- **块级作用域**：{}内的变量只在{}内有效