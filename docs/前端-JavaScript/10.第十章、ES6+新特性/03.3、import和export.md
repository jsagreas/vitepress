---
title: 3、import和export
---
## 📚 目录

1. [什么是模块化](#1-什么是模块化)
2. [export导出详解](#2-export导出详解)
3. [import导入详解](#3-import导入详解)
4. [模块化的实际应用](#4-模块化的实际应用)
5. [常见问题与注意事项](#5-常见问题与注意事项)
6. [最佳实践建议](#6-最佳实践建议)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🏗️ 什么是模块化


### 1.1 模块化的基本概念


**🔸 什么是模块？**
```
简单理解：模块就像一个"工具箱"
• 每个工具箱里装着相关的工具（函数、变量、类）
• 需要什么工具就打开对应的工具箱
• 不同工具箱互不干扰，井然有序

代码层面：模块就是一个JavaScript文件
• 一个.js文件 = 一个模块
• 每个模块有自己的作用域
• 模块之间通过import/export交换数据
```

**💡 为什么需要模块化？**
```
没有模块化的问题：

全局变量污染：
var userName = "张三";    // main.js
var userName = "李四";    // user.js
// 后面的会覆盖前面的，出现意外bug

代码难以维护：
// 所有代码都在一个文件里
// 1000行代码混在一起
// 找个函数都要翻半天

依赖关系混乱：
// 不知道哪个函数依赖哪个
// 删除代码时战战兢兢
// 不敢动，怕牵一发动全身
```

### 1.2 模块化解决方案对比


**📊 各种模块化方案**

| **方案** | **时期** | **特点** | **使用场景** |
|---------|---------|---------|-------------|
| **全局变量** | 原始时代 | 变量污染，难维护 | 已淘汰 |
| **CommonJS** | Node.js | `require`/`module.exports` | 服务端 |
| **AMD** | RequireJS | 异步加载，浏览器友好 | 逐渐淘汰 |
| **ES6模块** | 现代标准 | `import`/`export`，官方标准 | **主流方案** |

**🎯 ES6模块的优势**
```
官方标准：
• ECMAScript官方规范
• 浏览器原生支持
• 工具链完善

语法简洁：
• import/export语法直观
• 静态分析友好
• 支持按需加载

功能强大：
• 默认导出/命名导出
• 动态导入
• 模块作用域隔离
```

---

## 2. 📤 export导出详解


### 2.1 export的基本概念


**🔸 什么是export？**
```
简单理解：export就是"打包发货"
• 把模块内的东西打包好
• 贴上标签（名称）
• 准备发给其他模块使用

语法作用：
• 声明哪些内容可以被外部访问
• 给导出的内容起名字
• 决定导出的方式
```

### 2.2 命名导出（Named Export）


**📝 基本语法**
```javascript
// math.js - 数学工具模块
export const PI = 3.14159;
export let counter = 0;

export function add(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}
```

**🔄 先声明后导出**
```javascript
// user.js - 用户管理模块
const userName = "张三";
const userAge = 25;

function getUserInfo() {
    return `${userName}, ${userAge}岁`;
}

function updateUserName(newName) {
    userName = newName;
}

// 统一导出
export { userName, userAge, getUserInfo, updateUserName };
```

**🏷️ 重命名导出**
```javascript
// utils.js - 工具函数模块
function validate(data) {
    return data !== null && data !== undefined;
}

function format(text) {
    return text.trim().toLowerCase();
}

// 导出时重命名
export { 
    validate as checkData,
    format as formatText 
};
```

### 2.3 默认导出（Default Export）


**🔸 什么是默认导出？**
```
理解：每个模块的"主要产品"
• 一个模块只能有一个默认导出
• 代表这个模块最重要的功能
• 导入时可以自由命名

类比：
• 命名导出 = 商店里的各种商品（有固定名称）
• 默认导出 = 商店的招牌产品（可以随意称呼）
```

**📝 默认导出语法**
```javascript
// calculator.js - 计算器模块（主要功能）
class Calculator {
    add(a, b) { return a + b; }
    subtract(a, b) { return a - b; }
    multiply(a, b) { return a * b; }
    divide(a, b) { return b !== 0 ? a / b : 0; }
}

export default Calculator;
```

```javascript
// api.js - API请求模块
async function request(url, options = {}) {
    const response = await fetch(url, options);
    return response.json();
}

// 直接导出函数
export default request;
```

### 2.4 混合导出


**🔀 同时使用命名导出和默认导出**
```javascript
// db.js - 数据库模块
class Database {
    connect() { /* 连接数据库 */ }
    query(sql) { /* 执行查询 */ }
}

const dbConfig = {
    host: 'localhost',
    port: 3306
};

function createConnection() {
    return new Database();
}

// 默认导出主要的类
export default Database;

// 命名导出辅助功能
export { dbConfig, createConnection };
```

---

## 3. 📥 import导入详解


### 3.1 import的基本概念


**🔸 什么是import？**
```
简单理解：import就是"收货开箱"
• 从其他模块接收打包的内容
• 根据标签（名称）取出需要的东西
• 在当前模块中使用

语法作用：
• 声明要使用哪个模块的内容
• 指定导入的内容和名称
• 建立模块间的依赖关系
```

### 3.2 导入命名导出


**📥 基本导入语法**
```javascript
// main.js - 主程序文件
import { add, multiply, PI } from './math.js';

console.log(add(5, 3));        // 8
console.log(multiply(4, 6));   // 24
console.log(PI);               // 3.14159
```

**🏷️ 重命名导入**
```javascript
// app.js
import { 
    checkData as validate,
    formatText as format 
} from './utils.js';

const isValid = validate("hello");
const text = format("  WORLD  ");
```

**📦 全部导入**
```javascript
// index.js
import * as MathUtils from './math.js';

console.log(MathUtils.add(2, 3));     // 5
console.log(MathUtils.PI);            // 3.14159
```

### 3.3 导入默认导出


**📥 默认导入语法**
```javascript
// app.js
import Calculator from './calculator.js';
import apiRequest from './api.js';

const calc = new Calculator();
console.log(calc.add(10, 5));

apiRequest('/users').then(users => {
    console.log(users);
});
```

**🔸 默认导入的特点**
```
自由命名：
import Calc from './calculator.js';      // ✅ 可以
import MyCalculator from './calculator.js'; // ✅ 也可以
import 随便什么名字 from './calculator.js';    // ✅ 都行

注意：导入的名字可以任意，但建议有意义
```

### 3.4 混合导入


**🔀 同时导入默认和命名导出**
```javascript
// main.js
import Database, { dbConfig, createConnection } from './db.js';

// 使用默认导出
const db = new Database();

// 使用命名导出
console.log(dbConfig.host);
const connection = createConnection();
```

**📝 语法糖写法**
```javascript
// 等价写法1：分开导入
import Database from './db.js';
import { dbConfig, createConnection } from './db.js';

// 等价写法2：混合导入
import Database, { dbConfig, createConnection } from './db.js';
```

---

## 4. 🚀 模块化的实际应用


### 4.1 项目结构组织


**📁 典型的模块化项目结构**
```
项目目录结构：
my-project/
├── src/
│   ├── utils/           # 工具函数模块
│   │   ├── math.js
│   │   ├── string.js
│   │   └── date.js
│   ├── api/            # API请求模块
│   │   ├── user.js
│   │   └── product.js
│   ├── components/     # 组件模块
│   │   ├── Header.js
│   │   └── Footer.js
│   └── main.js         # 主入口文件
└── index.html
```

**🏗️ 模块职责划分**
```javascript
// utils/math.js - 数学工具
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

// utils/string.js - 字符串工具  
export const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);
export const truncate = (str, length) => str.length > length ? str.slice(0, length) + '...' : str;

// api/user.js - 用户API
export async function getUser(id) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
}

export async function updateUser(id, data) {
    const response = await fetch(`/api/users/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data)
    });
    return response.json();
}
```

### 4.2 实际使用示例


**📱 构建一个简单的用户管理应用**

```javascript
// models/User.js - 用户数据模型
export default class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
        this.id = Date.now();
    }
    
    getDisplayName() {
        return `${this.name} (${this.email})`;
    }
}
```

```javascript
// services/userService.js - 用户服务
import User from '../models/User.js';

const users = [];

export function createUser(name, email) {
    const user = new User(name, email);
    users.push(user);
    return user;
}

export function getAllUsers() {
    return [...users];
}

export function findUserById(id) {
    return users.find(user => user.id === id);
}
```

```javascript
// main.js - 主程序
import { createUser, getAllUsers } from './services/userService.js';
import { capitalize } from './utils/string.js';

// 创建用户
const user1 = createUser(capitalize('john doe'), 'john@example.com');
const user2 = createUser(capitalize('jane smith'), 'jane@example.com');

// 显示所有用户
const allUsers = getAllUsers();
allUsers.forEach(user => {
    console.log(user.getDisplayName());
});
```

### 4.3 模块间通信模式


**🔄 常见的模块通信方式**

```javascript
// eventBus.js - 事件总线模块
class EventBus {
    constructor() {
        this.events = {};
    }
    
    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    
    emit(event, data) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(data));
        }
    }
}

export default new EventBus();
```

```javascript
// userModule.js - 用户模块
import eventBus from './eventBus.js';

export function loginUser(username) {
    // 登录逻辑
    console.log(`${username} 登录成功`);
    
    // 通知其他模块
    eventBus.emit('userLogin', { username, time: new Date() });
}
```

```javascript
// notificationModule.js - 通知模块
import eventBus from './eventBus.js';

// 监听用户登录事件
eventBus.on('userLogin', (data) => {
    console.log(`欢迎 ${data.username}！登录时间：${data.time}`);
});

export function showNotification(message) {
    console.log(`通知：${message}`);
}
```

---

## 5. ⚠️ 常见问题与注意事项


### 5.1 浏览器兼容性


**🌐 浏览器支持情况**
```
现代浏览器支持：
✅ Chrome 61+
✅ Firefox 60+ 
✅ Safari 10.1+
✅ Edge 16+

使用方式：
<script type="module" src="main.js"></script>

注意：必须添加 type="module" 属性
```

**🔧 兼容性解决方案**
```html
<!-- 现代浏览器使用ES6模块 -->
<script type="module" src="main.js"></script>

<!-- 旧浏览器降级方案 -->
<script nomodule src="bundle.js"></script>
```

### 5.2 常见错误及解决


**❌ 错误1：忘记添加文件扩展名**
```javascript
// ❌ 错误写法
import { add } from './math';

// ✅ 正确写法  
import { add } from './math.js';
```

**❌ 错误2：循环依赖**
```javascript
// a.js
import { funcB } from './b.js';
export function funcA() { return funcB(); }

// b.js  
import { funcA } from './a.js';  // ❌ 循环依赖
export function funcB() { return funcA(); }

// ✅ 解决方案：重新设计模块结构
// common.js
export function sharedFunction() { /* 共同逻辑 */ }
```

**❌ 错误3：CORS跨域问题**
```
问题：直接打开HTML文件会出现跨域错误
解决：使用本地服务器

简单解决方案：
npm install -g http-server
http-server .
```

### 5.3 性能考虑


**⚡ 模块加载优化**
```javascript
// 避免导入整个模块（如果只需要一部分）
// ❌ 导入全部
import * as _ from 'lodash';

// ✅ 按需导入
import { debounce, throttle } from 'lodash';

// ✅ 更好的方式
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
```

**🔄 动态导入（按需加载）**
```javascript
// 传统方式：所有模块都会被立即加载
import heavyModule from './heavyModule.js';

// 动态导入：需要时才加载
async function loadHeavyFeature() {
    const { default: heavyModule } = await import('./heavyModule.js');
    return heavyModule;
}

// 使用示例
document.getElementById('loadBtn').addEventListener('click', async () => {
    const module = await loadHeavyFeature();
    module.doSomething();
});
```

---

## 6. 💡 最佳实践建议


### 6.1 模块设计原则


**🎯 单一职责原则**
```javascript
// ❌ 不好的设计：一个模块做太多事情
// userUtils.js
export function validateUser() { /* 验证逻辑 */ }
export function formatUser() { /* 格式化逻辑 */ }
export function saveUser() { /* 保存逻辑 */ }
export function sendEmail() { /* 邮件逻辑 */ }

// ✅ 好的设计：职责分离
// userValidator.js
export function validateUser() { /* 只做验证 */ }

// userFormatter.js  
export function formatUser() { /* 只做格式化 */ }

// userService.js
export function saveUser() { /* 只做数据操作 */ }

// emailService.js
export function sendEmail() { /* 只做邮件发送 */ }
```

**📦 模块大小控制**
```
建议：
• 单个模块文件不超过300行代码
• 导出的功能不超过10个
• 一个模块专注解决一类问题

判断标准：
• 能否用一句话说清楚模块的作用？
• 模块名是否能准确反映其功能？
• 是否存在明显不相关的功能？
```

### 6.2 命名规范


**🏷️ 文件命名**
```
推荐规范：
• 使用小写字母和连字符：user-service.js
• 或使用驼峰命名：userService.js
• 保持项目内命名风格一致

文件名要反映内容：
✅ userValidator.js    （清楚表达功能）
✅ dateUtils.js       （工具类模块）
✅ apiClient.js       （API客户端）
❌ helper.js          （太模糊）
❌ utils.js           （太宽泛）
```

**📝 导出命名**
```javascript
// 命名导出：使用有意义的名称
export const MAX_RETRY_COUNT = 3;
export function validateEmail(email) { /* ... */ }
export class UserManager { /* ... */ }

// 默认导出：文件名和导出名保持一致
// Calculator.js
export default class Calculator { /* ... */ }

// apiClient.js  
export default class ApiClient { /* ... */ }
```

### 6.3 目录结构建议


**📁 推荐的项目结构**
```
src/
├── components/          # 可复用组件
│   ├── Button/
│   │   ├── Button.js
│   │   └── Button.css
│   └── Modal/
│       ├── Modal.js
│       └── Modal.css
├── services/           # 业务服务层
│   ├── userService.js
│   ├── productService.js
│   └── authService.js
├── utils/             # 通用工具函数
│   ├── format.js
│   ├── validate.js
│   └── constants.js
├── api/               # API接口层
│   ├── endpoints.js
│   └── client.js
└── main.js           # 应用入口
```

**🔧 模块导入顺序**
```javascript
// 推荐的导入顺序
// 1. 第三方库
import React from 'react';
import axios from 'axios';

// 2. 自己项目的模块（按相对路径距离）
import { API_BASE_URL } from '../config/constants.js';
import { validateUser } from '../utils/validate.js';
import UserService from './UserService.js';

// 3. 样式文件
import './UserComponent.css';
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的核心概念


```
🔸 模块化本质：将代码分割成独立的、可复用的单元
🔸 export作用：声明模块对外提供的接口（API）
🔸 import作用：引入其他模块提供的功能
🔸 模块作用域：每个模块都有独立的作用域，避免全局污染
🔸 依赖关系：通过import/export建立清晰的模块依赖图
```

### 7.2 关键语法总结


**📤 export语法速查**
```javascript
// 命名导出
export const name = "value";
export function func() {}
export { var1, var2 };
export { var1 as newName };

// 默认导出
export default class MyClass {}
export default function() {}
export default "value";

// 混合导出
export default MyClass;
export { helper1, helper2 };
```

**📥 import语法速查**
```javascript
// 导入命名导出
import { name1, name2 } from './module.js';
import { name as newName } from './module.js';
import * as ModuleName from './module.js';

// 导入默认导出
import MyClass from './module.js';
import myFunc from './module.js';

// 混合导入
import MyClass, { helper1, helper2 } from './module.js';

// 动态导入
const module = await import('./module.js');
```

### 7.3 实践要点


**🎯 设计原则**
```
模块设计：
• 单一职责：一个模块只做一类事情
• 高内聚：相关功能放在同一模块
• 低耦合：模块间依赖关系简单清晰

命名原则：
• 见名知意：模块名和导出名要清楚表达功能
• 保持一致：项目内命名风格要统一
• 避免冲突：使用命名空间避免名称冲突
```

**⚡ 性能优化**
```
加载优化：
• 按需导入：只导入需要的功能
• 动态导入：大模块延迟加载
• 避免循环依赖：合理设计模块结构

开发体验：
• 模块大小适中：单个文件不要过大
• 依赖关系清晰：容易理解和维护
• 测试友好：模块功能独立，便于单元测试
```

### 7.4 常见应用场景


**🚀 实际项目中的应用**
```
工具函数模块：
• 日期处理、字符串操作、数学计算
• 一次编写，多处使用

业务服务模块：
• 用户管理、商品管理、订单处理
• 封装业务逻辑，提供统一接口

组件模块：
• UI组件、表单组件、图表组件
• 提高代码复用性和维护性

配置模块：
• API地址、常量定义、环境配置
• 集中管理配置信息
```

**核心记忆**：
- import/export是ES6模块化的核心语法
- export声明模块的"产品"，import使用其他模块的"产品"
- 合理的模块化设计让代码更清晰、更易维护
- 掌握基本语法后，重点是学会设计模块结构

---

> **💡 学习建议**
> 
> 模块化编程不只是语法问题，更是编程思维的转变：
> - **从面条式代码到模块化架构**
> - **从全局变量到模块作用域**  
> - **从混乱依赖到清晰接口**
>
> **实践中掌握：**
> 1. 先从简单的工具函数模块开始
> 2. 逐步尝试更复杂的业务模块
> 3. 在实际项目中体会模块化的优势