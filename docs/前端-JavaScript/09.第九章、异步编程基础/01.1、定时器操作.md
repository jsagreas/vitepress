---
title: 1、定时器操作
---
## 📚 目录

1. [定时器是什么](#1-定时器是什么)
2. [setTimeout延时执行](#2-setTimeout延时执行)
3. [setInterval重复执行](#3-setInterval重复执行)
4. [清除定时器](#4-清除定时器)
5. [回调函数详解](#5-回调函数详解)
6. [实际应用场景](#6-实际应用场景)
7. [核心要点总结](#7-核心要点总结)

---

## 1. 🕐 定时器是什么


### 1.1 基本概念


**🔸 定时器的作用**
```
定时器：让JavaScript在指定时间后执行某些代码
用途：处理需要延迟或重复执行的操作
本质：异步操作，不会阻塞代码继续执行
```

**💡 为什么需要定时器**
```
现实需求：
• 3秒后隐藏提示信息
• 每隔1秒更新时间显示
• 延迟加载某些内容
• 动画效果的逐帧更新

没有定时器的问题：
• 无法延迟执行代码
• 无法创建重复任务
• 无法实现动画效果
```

### 1.2 定时器类型


```
JavaScript提供两种定时器：

setTimeout()：延时执行一次
┌─────────────────────────────────────┐
│ 现在     3秒后                       │
│  │       │                         │
│  │       └── 执行代码（只执行一次）    │
│  └── 设置定时器                      │
└─────────────────────────────────────┘

setInterval()：重复执行
┌─────────────────────────────────────┐
│ 现在   1秒   2秒   3秒   4秒   ...   │
│  │     │     │     │     │          │
│  │     ├──── ├──── ├──── ├──── 执行  │
│  └── 设置定时器                      │
└─────────────────────────────────────┘
```

---

## 2. ⏰ setTimeout延时执行


### 2.1 基本语法


**🔸 语法结构**
```javascript
setTimeout(回调函数, 延迟时间毫秒);

// 基本用法
setTimeout(function() {
    console.log("3秒后执行这段代码");
}, 3000);
```

**💡 参数说明**
```javascript
setTimeout(callback, delay, param1, param2);

参数解释：
• callback：要执行的函数（回调函数）
• delay：延迟时间，单位毫秒（1秒 = 1000毫秒）
• param1, param2：可选，传给回调函数的参数
```

### 2.2 实际使用示例


**🔧 三种常见写法**
```javascript
// 方式1：匿名函数
setTimeout(function() {
    alert("时间到了！");
}, 2000);

// 方式2：箭头函数（推荐）
setTimeout(() => {
    console.log("2秒后执行");
}, 2000);

// 方式3：函数名（不加括号）
function showMessage() {
    console.log("定时任务执行了");
}
setTimeout(showMessage, 1000);
```

**⚡ 传递参数的方法**
```javascript
function greet(name, age) {
    console.log(`你好${name}，你${age}岁了`);
}

// 传递参数给回调函数
setTimeout(greet, 1000, "小明", 18);
// 输出：你好小明，你18岁了

// 或者用箭头函数包装
setTimeout(() => {
    greet("小红", 20);
}, 1000);
```

### 2.3 返回值和标识


**🔢 定时器ID**
```javascript
// setTimeout返回一个数字ID
const timerId = setTimeout(() => {
    console.log("这段代码可能不会执行");
}, 5000);

console.log(timerId); // 输出：1（第一个定时器的ID）

// 可以用这个ID来取消定时器
clearTimeout(timerId);
```

---

## 3. 🔄 setInterval重复执行


### 3.1 基本语法


**🔸 语法结构**
```javascript
setInterval(回调函数, 间隔时间毫秒);

// 每隔1秒执行一次
setInterval(function() {
    console.log("每秒都会输出这句话");
}, 1000);
```

### 3.2 实际使用示例


**⏱️ 制作数字时钟**
```javascript
function updateClock() {
    const now = new Date();
    const time = now.toLocaleTimeString();
    console.log("当前时间：" + time);
}

// 每秒更新一次时间
setInterval(updateClock, 1000);
```

**📊 简单计数器**
```javascript
let count = 0;

const counter = setInterval(() => {
    count++;
    console.log(`计数：${count}`);
    
    // 计数到10就停止
    if (count >= 10) {
        clearInterval(counter);
        console.log("计数结束！");
    }
}, 1000);
```

### 3.3 setTimeout vs setInterval


| 特性 | **setTimeout** | **setInterval** |
|------|---------------|----------------|
| **执行次数** | `只执行一次` | `重复执行` |
| **适用场景** | `延迟操作` | `周期性任务` |
| **停止方法** | `clearTimeout()` | `clearInterval()` |
| **常见用途** | `延迟提示、延迟加载` | `时钟、轮播图、动画` |

---

## 4. 🛑 清除定时器


### 4.1 为什么要清除定时器


**⚠️ 不清除的问题**
```javascript
// 问题代码：定时器会一直运行
setInterval(() => {
    console.log("我会一直执行，占用内存！");
}, 1000);

// 页面关闭了，定时器还在运行
// 会造成内存泄漏！
```

### 4.2 清除方法


**🔧 clearTimeout清除延时器**
```javascript
// 设置定时器
const delayTimer = setTimeout(() => {
    console.log("这段代码不会执行");
}, 5000);

// 2秒后取消定时器
setTimeout(() => {
    clearTimeout(delayTimer);
    console.log("定时器已取消");
}, 2000);
```

**🔧 clearInterval清除重复器**
```javascript
let seconds = 0;

const timer = setInterval(() => {
    seconds++;
    console.log(`已过去 ${seconds} 秒`);
    
    // 10秒后自动停止
    if (seconds >= 10) {
        clearInterval(timer);
        console.log("计时结束");
    }
}, 1000);
```

### 4.3 实际应用案例


**📱 手机验证码倒计时**
```javascript
function startCountdown(button) {
    let countdown = 60;
    button.disabled = true;
    
    const timer = setInterval(() => {
        countdown--;
        button.textContent = `${countdown}秒后重新获取`;
        
        if (countdown <= 0) {
            clearInterval(timer);
            button.disabled = false;
            button.textContent = "获取验证码";
        }
    }, 1000);
}

// 使用：startCountdown(document.getElementById('codeBtn'));
```

---

## 5. 📞 回调函数详解


### 5.1 什么是回调函数


**🔸 回调函数概念**
```
回调函数（Callback）：
• 作为参数传递给其他函数的函数
• 在特定时机被"回调"（调用）
• 定时器中的回调函数在时间到达时执行

简单理解：
"我先去做别的事，时间到了你叫我一下"
这个"叫我"的动作就是回调
```

### 5.2 回调函数的不同写法


**💡 三种常见写法**
```javascript
// 写法1：直接写函数体
setTimeout(function() {
    console.log("匿名函数回调");
}, 1000);

// 写法2：箭头函数（最常用）
setTimeout(() => {
    console.log("箭头函数回调");
}, 1000);

// 写法3：使用函数名
function myCallback() {
    console.log("命名函数回调");
}
setTimeout(myCallback, 1000); // 注意：函数名后不加()
```

### 5.3 回调函数的作用域


**🔍 变量访问规则**
```javascript
let message = "外部变量";

setTimeout(() => {
    let innerMessage = "内部变量";
    console.log(message);      // ✅ 可以访问外部变量
    console.log(innerMessage); // ✅ 可以访问内部变量
}, 1000);

// console.log(innerMessage); // ❌ 错误！外部无法访问内部变量
```

**🔄 闭包的应用**
```javascript
function createTimer(name) {
    return function() {
        console.log(`${name}的定时器触发了`);
    };
}

setTimeout(createTimer("用户A"), 1000); // 输出：用户A的定时器触发了
setTimeout(createTimer("用户B"), 2000); // 输出：用户B的定时器触发了
```

---

## 6. 🎯 实际应用场景


### 6.1 用户体验优化


**💬 提示信息自动消失**
```javascript
function showToast(message) {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed; top: 20px; right: 20px;
        background: #333; color: white; padding: 10px;
        border-radius: 4px;
    `;
    
    document.body.appendChild(toast);
    
    // 3秒后自动移除
    setTimeout(() => {
        document.body.removeChild(toast);
    }, 3000);
}

// 使用
showToast("保存成功！");
```

**⏳ 防抖操作**
```javascript
let searchTimer;

function handleSearch(keyword) {
    // 清除之前的定时器
    clearTimeout(searchTimer);
    
    // 500毫秒后再执行搜索
    searchTimer = setTimeout(() => {
        console.log(`搜索：${keyword}`);
        // 实际的搜索逻辑
    }, 500);
}

// 用户快速输入时，只有停止输入500ms后才会真正搜索
```

### 6.2 动画和交互


**🎠 简单轮播图**
```javascript
const images = ['img1.jpg', 'img2.jpg', 'img3.jpg'];
let currentIndex = 0;

function nextSlide() {
    currentIndex = (currentIndex + 1) % images.length;
    document.getElementById('slideImg').src = images[currentIndex];
}

// 每3秒切换一张图片
setInterval(nextSlide, 3000);
```

**⚡ 页面加载进度**
```javascript
function simulateLoading() {
    let progress = 0;
    const progressBar = document.getElementById('progress');
    
    const timer = setInterval(() => {
        progress += Math.random() * 10;
        progressBar.style.width = Math.min(progress, 100) + '%';
        
        if (progress >= 100) {
            clearInterval(timer);
            console.log("加载完成！");
        }
    }, 100);
}
```

### 6.3 性能优化技巧


**🎯 避免内存泄漏**
```javascript
class Timer {
    constructor() {
        this.timers = [];
    }
    
    addTimeout(callback, delay) {
        const id = setTimeout(() => {
            callback();
            this.removeTimer(id);
        }, delay);
        this.timers.push(id);
        return id;
    }
    
    addInterval(callback, delay) {
        const id = setInterval(callback, delay);
        this.timers.push(id);
        return id;
    }
    
    removeTimer(id) {
        clearTimeout(id);
        clearInterval(id);
        this.timers = this.timers.filter(timer => timer !== id);
    }
    
    clearAll() {
        this.timers.forEach(id => {
            clearTimeout(id);
            clearInterval(id);
        });
        this.timers = [];
    }
}

// 使用
const timerManager = new Timer();
timerManager.addTimeout(() => console.log("延时任务"), 1000);
// 页面卸载时清除所有定时器
// timerManager.clearAll();
```

---

## 7. 📋 核心要点总结


### 7.1 必须掌握的基本概念


```
🔸 定时器作用：延迟或重复执行代码，实现异步操作
🔸 setTimeout：延迟执行一次，适合一次性任务
🔸 setInterval：重复执行，适合周期性任务
🔸 清除定时器：防止内存泄漏，使用clearTimeout/clearInterval
🔸 回调函数：定时器到期时执行的函数，支持多种写法
```

### 7.2 关键理解要点


**🔹 异步执行特性**
```
重要理解：
• 定时器不会阻塞代码执行
• 后面的代码会立即执行，不等定时器
• 定时器在后台计时，时间到了才执行回调

代码执行顺序：
console.log("1");
setTimeout(() => console.log("2"), 1000);
console.log("3");
// 输出：1, 3, (1秒后)2
```

**🔹 定时器精度问题**
```
注意事项：
• setTimeout(fn, 0) 不是立即执行
• 浏览器有最小延迟限制（约4ms）
• 页面不活跃时定时器可能变慢
• 不适合精确计时，适合用户交互
```

**🔹 最佳实践**
```
推荐做法：
• 使用箭头函数简化代码
• 及时清除不需要的定时器
• 避免在定时器中执行复杂操作
• 使用防抖避免频繁触发
```

### 7.3 实际应用价值


- **用户体验**：提示消息、加载动画、轮播图
- **性能优化**：防抖搜索、延迟加载、批量操作
- **交互效果**：倒计时、进度条、定时刷新
- **异步处理**：模拟延迟、错误重试、数据轮询

### 7.4 常见问题避免


```
❌ 常见错误：
• 忘记清除定时器导致内存泄漏
• 在setInterval中使用this指向错误
• 定时器嵌套导致性能问题
• 误用setInterval做一次性任务

✅ 正确做法：
• 保存定时器ID并及时清除
• 使用箭头函数保持this指向
• 合理选择setTimeout vs setInterval
• 在组件销毁时清理所有定时器
```

**核心记忆**：
- 定时器是异步操作的基础，setTimeout延时一次，setInterval重复执行
- 回调函数在时间到达时执行，支持传参和作用域访问
- 务必清除不需要的定时器，避免内存泄漏
- 实际应用中多用于用户体验优化和性能提升